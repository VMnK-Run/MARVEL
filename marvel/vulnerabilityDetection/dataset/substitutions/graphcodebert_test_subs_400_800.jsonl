{"project": "qemu", "commit_id": "d44168fffa07fc57e61a37da65e9348661dec887", "target": 1, "func": "static USBDevice *usb_net_init(const char *cmdline)\n\n{\n\n    USBDevice *dev;\n\n    QemuOpts *opts;\n\n    int idx;\n\n\n\n    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);\n\n    if (!opts) {\n\n\n\n    qemu_opt_set(opts, \"type\", \"nic\");\n\n    qemu_opt_set(opts, \"model\", \"usb\");\n\n\n\n    idx = net_client_init(NULL, opts, 0);\n\n    if (idx == -1) {\n\n\n\n\n\n    dev = usb_create(NULL /* FIXME */, \"usb-net\");\n\n\n\n\n    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);\n\n    qdev_init_nofail(&dev->qdev);\n\n    return dev;\n", "idx": 4093, "substitutes": {"usb_net_init": ["usb_net_bind", "usb_network_Init", "usb_network_init", "usb_netlyinit", "usb_netlybind", "usb_network_bind", "usb_netlyInit", "usb_network_create", "usb_net_create", "usb_net_Init", "usb_netlycreate"], "cmdline": ["commandstring", "commandlines", "Cmdline", "commandLINE", " cmdlines", "mdLine", " cmdLINE", "commandLine", "cmdlines", "mdLINE", "CmdLine", "commandline", " cmdLine", "cmdstring", "cmdLINE", " cmdstring", "cmdLine", "mdline", "mdlines", "Cmdstring"], "dev": [" prod", "doc", "util", "den", "de", "conn", "priv", "od", "debug", "ach", "d", "v", "van", " device", "att", "ow", "nt", "data", "Device", "Dev", "ad", "dd", "gu", "devices", "serv", "obj", "w", "val", " Dev", "di", "die", "adv", "ve", "rem", "device", "pad", "dn", "sd", "mem", "plug", "def", "DEV", "wd", "ver", "usb", "DE", "ot", "new", "vo", "fo", "db", "end", "cam", " conn", "instance", "disc", "test", "hw", "var", "final", "dis", "env", "tech", "des", "del", "go", "ev"], "opts": ["prots", "optters", "oprs", "opms", "copps", "optcs", "opss", "opgs", " optss", " copcs", "optct", " opcs", " copTS", "optts", " opters", "optths", "optgs", " copt", "optTS", "prot", "OPs", "opfs", "opths", "optt", " opths", "opct", "proTS", " copters", " optts", "OPcs", "opcs", " opt", " opfs", " optfs", "OPps", "opt", "OPts", "OPms", "prors", " opct", "OPct", " opss", "ops", " oprs", "optss", "opTS", "copms", " opgs", " opTS", " copts", "optfs", "iopts", "optps", "iopTS", "iopgs", "OPths", "opters", "optrs", " optrs", "opps", " coprs", "optms", "copts", "cops", "iopt"], "idx": ["Idy", " idxs", "IDdx", "IDix", "Idx", "Idix", "idi", " idxf", "IDxf", "IDx", "idsxs", "IDi", " idy", " idi", "idy", "Idxf", "Iddx", "idix", "midix", "idsx", "ridxs", "IDy", " idix", "midx", "idsdx", "riddx", "IDxs", "iddx", "Idxs", "idxs", "idxf", "idsix", "midxs", "ridix", " iddx", "ridx", "midi"]}}
{"project": "FFmpeg", "commit_id": "238ddd6482d7aea2e917760a9bef291030a11e61", "target": 1, "func": "static void pkt_dump_internal(void *avcl, FILE *f, int level, const AVPacket *pkt,\n\n                              int dump_payload, AVRational time_base)\n\n{\n\n    HEXDUMP_PRINT(\"stream #%d:\\n\", pkt->stream_index);\n\n    HEXDUMP_PRINT(\"  keyframe=%d\\n\", (pkt->flags & AV_PKT_FLAG_KEY) != 0);\n\n    HEXDUMP_PRINT(\"  duration=%0.3f\\n\", pkt->duration * av_q2d(time_base));\n\n    /* DTS is _always_ valid after av_read_frame() */\n\n    HEXDUMP_PRINT(\"  dts=\");\n\n    if (pkt->dts == AV_NOPTS_VALUE)\n\n        HEXDUMP_PRINT(\"N/A\");\n\n    else\n\n        HEXDUMP_PRINT(\"%0.3f\", pkt->dts * av_q2d(time_base));\n\n    /* PTS may not be known if B-frames are present. */\n\n    HEXDUMP_PRINT(\"  pts=\");\n\n    if (pkt->pts == AV_NOPTS_VALUE)\n\n        HEXDUMP_PRINT(\"N/A\");\n\n    else\n\n        HEXDUMP_PRINT(\"%0.3f\", pkt->pts * av_q2d(time_base));\n\n    HEXDUMP_PRINT(\"\\n\");\n\n    HEXDUMP_PRINT(\"  size=%d\\n\", pkt->size);\n\n    if (dump_payload)\n\n        av_hex_dump(f, pkt->data, pkt->size);\n\n}\n", "idx": 4095, "substitutes": {"avcl": ["savfl", " avc", " avCl", "afc", "afcl", "savCl", "afCl", "avc", " avfl", "savc", "avCl", "avfl", "affl", "savcl"], "f": ["fr", "t", "p", "fn", "fi", "lf", "tf", "d", "v", "fac", "fb", "fd", "file", "w", "ff", "sf", "h", "o", "fc", "i", "b", "F", "fed", "rf", "buffer", "fp", "cf", "e", "m", "fs", "uf", "c", "bf", "fx"], "level": ["limit", "debug", "le", "Level", "func", "vl", "lc", "length", "offset", "version", "style", "depth", "fl", "where", "levels", "lvl", "layer", "vel", "link", "type", "tag", "len", "scale", "flag", "priority", "mode", "lev", "hl"], "pkt": ["pdu", "precmd", "opkt", "perkt", "Packet", "pct", "proacket", "Pwk", " pek", "powercmd", "powerkt", "perct", "prkt", "pracket", "opnt", " pft", "pft", "permcht", "permkt", "pet", "opunct", "Pant", "opwk", "powerek", "portkat", "peracket", "opacket", "portct", "portkt", "patchek", "permcmd", "patchkt", "patchempt", "opcmd", "Pcht", "prnt", "pingacket", "proct", "procmd", "pkat", "Pcmd", " packet", "Pdu", "powerempt", "pingkt", "preacket", "ppft", "pcht", " pant", "percmd", "pcmd", " pkat", "pnt", "prekt", " pwk", "powerdu", "Pnt", " punct", "pinget", "packet", " pet", "prent", "powerant", "ppacket", "opet", " pcmd", "powernt", " pct", "pingunct", "prokt", "Pkat", "Pct", "prft", " pnt", "patchnt", "permacket", "pek", "portcmd", "Pkt", " pcht", "pwk", "ppkt", "punct", "pant", "ppcmd", " pdu", "ppnt", " pempt", "pempt"], "dump_payload": ["dump_workLOAD", "dump_payl", "dump_workload", "dump2payl", "dump_publine", "dump_ayloads", "dump_Payloads", "dump2payloads", "dump_Payload", "dump_payline", "dump2payline", "dump_payLOAD", "dump_payloads", "dump2Payl", "dump_PayLOAD", "dump_ayl", "dump_publoads", "dump_Payl", "dump_workl", "dump_workloads", "dump_Payline", "dump_ayload", "dump_publ", "dump2Payloads", "dump_pubLOAD", "dump2Payload", "dump_pubload", "dump_ayline", "dump2Payline", "dump2payload"], "time_base": ["window_ase", "window8base", "Time_Base", " time_back", "time9link", "time_bi", "window8bi", "time9bar", "window_base", " time_link", " time_bar", "window8bas", " time_based", "time2back", "time9bas", "window_bas", "window_bi", "time2bas", "time8ase", " time_bas", "time_ase", "window8ase", "time9base", "time_bar", "time_bas", "time_based", "time2based", "Time_base", "time_link", "time2base", "time_Base", "time8bi", "time8base", "Time_bas", "time_back", "time8bas"]}}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static void handle_mousewheel(SDL_Event *ev)\n\n{\n\n    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);\n\n    SDL_MouseWheelEvent *wev = &ev->wheel;\n\n    InputButton btn;\n\n\n\n    if (wev->y > 0) {\n\n        btn = INPUT_BUTTON_WHEEL_UP;\n\n    } else if (wev->y < 0) {\n\n        btn = INPUT_BUTTON_WHEEL_DOWN;\n\n    } else {\n\n        return;\n\n    }\n\n\n\n    qemu_input_queue_btn(scon->dcl.con, btn, true);\n\n    qemu_input_event_sync();\n\n    qemu_input_queue_btn(scon->dcl.con, btn, false);\n\n    qemu_input_event_sync();\n\n}\n", "idx": 4104, "substitutes": {"ev": ["eas", "ever", "dev", "vent", "el", "ech", "esc", "vc", "v", "except", "ec", "Ev", "veh", "EV", "eg", "ele", "em", "inv", "serv", "ep", "crit", "ew", "ell", "vet", "eva", "ve", "eng", "eve", "ie", "iq", "ee", "ex", "resp", "exc", "enc", "e", "cam", "esp", "ek", "sv", "eb", "ov", "hw", "ent", "env", "ef", "eh", "er", "err", "cmd", "event"], "scon": ["sCon", " sconn", "Sconn", "stsdon", "SCon", "wscon", "sconst", "dsdon", "sdon", "stsCon", " sco", "Scon", "wsdon", "gescon", "gesconn", "stscons", "scons", "stscon", " sdon", "sconn", "wsCon", "wscons", "Sco", "Sconst", "dsco", "sco", " scons", "Sdon", "gesco", "dsCon", " sCon", " sconst", "gesconst", "dscon"], "wev": ["nwv", " sevs", "ueva", "weev", "theyf", "veb", "uev", " wef", "wex", " wevs", "uef", "veva", " weva", "nwva", "veev", "weva", "theyv", "wevich", "nwb", " sev", " sex", "wef", "theyva", "hev", "uevich", "vex", " wex", "heev", "nwev", "heb", " wevich", "vev", " weev", "vevs", " seev", "heva", "web", "theyvich", "wevs"], "btn": ["bn", "lu", "butt", "fn", "pkg", "button", "bh", "bt", "focus", "ctr", "sbm", "addon", "bj", "wx", "token", "label", "mu", "bolt", "fb", "msg", "sync", "rl", "tap", "typ", "txt", "cb", "fw", "obj", "layout", "kt", "widget", "fl", "output", "toggle", "attr", "bs", "fc", "b", "resp", "pb", "usb", "bl", "ctrl", "buffer", "tag", "status", "tp", "jp", "ck", "og", "bg", "fp", "pin", "ko", "conv", "tn", "bool", "bp", "cli", "tk", "ack", "tab", "cmd", "batch", "bd"]}}
{"project": "qemu", "commit_id": "0c0eb30260b424d2a68603b89f1d829db18772c2", "target": 1, "func": "static void init_virtio_dev(TestServer *s)\n\n{\n\n    QPCIBus *bus;\n\n    QVirtioPCIDevice *dev;\n\n    uint32_t features;\n\n\n\n    bus = qpci_init_pc(NULL);\n\n    g_assert_nonnull(bus);\n\n\n\n    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);\n\n    g_assert_nonnull(dev);\n\n\n\n    qvirtio_pci_device_enable(dev);\n\n    qvirtio_reset(&dev->vdev);\n\n    qvirtio_set_acknowledge(&dev->vdev);\n\n    qvirtio_set_driver(&dev->vdev);\n\n\n\n    features = qvirtio_get_features(&dev->vdev);\n\n    features = features & VIRTIO_NET_F_MAC;\n\n    qvirtio_set_features(&dev->vdev, features);\n\n\n\n    qvirtio_set_driver_ok(&dev->vdev);\n\n}\n", "idx": 4141, "substitutes": {"s": ["t", "os", "S", "p", "ds", "is", "ps", "spec", "w", "ss", "h", "ssl", "sq", "ses", "socket", "rs", "gs", "su", "ts", "stats", "fs", "sv", "sis", "sb", "er", "services"], "bus": ["US", "os", "util", "p", "host", "ch", "conn", "cus", "way", "cat", "bur", "board", "ctx", "pc", " BUS", "bug", "serv", "Bus", "mount", "h", "lock", "bs", "chain", "soc", "proc", "b", "plug", "gen", "root", "buf", "http", "usb", "proxy", "boot", "uses", "local", "bridge", "loop", "cs", "ac", "us", "c", "user", "back", "bu", "box", "sys", "BUS", "bc"], "dev": ["out", "doc", "order", "den", "de", "cast", "th", "form", "temp", "dest", "priv", "conn", "debug", "d", "cho", "v", "van", "nt", "Dev", "dd", "gu", "serv", "obj", "w", "val", "prop", "watch", "pro", "port", "ve", "pad", "device", "rem", "adv", "build", "sd", "mem", "off", "def", "DEV", "ver", "comment", "buf", "stick", "usb", "row", "develop", "vo", "db", "cam", "end", "rent", "der", "addr", "test", "window", "var", "ac", "desc", "tech", "env", "des", "client", "sky", "vol", "go", "ev", "av", "dem"], "features": ["flags", "tools", "states", "tests", " events", "fixes", " products", "details", "properties", "times", "ATURES", "types", "plugins", "length", "relations", " facts", "facts", "frames", "devices", "issues", " flags", "sections", " Features", "performance", " attributes", "fts", "fields", "versions", "events", "ributes", " details", "ensions", "lists", "rows", "mas", "ints", "Features", " feature", "feature", "ids", "abilities", " ports", "faces", "xs", "reports", "results", "actions", "utils", "bits", "fs", " capabilities", "bugs", "cs", " feat", "drivers", "ances", "orts", "forms", "settings", "feat", " interfaces", "ats", " dimensions", "acts", "weights", "eatures", "services"]}}
{"project": "FFmpeg", "commit_id": "9f36ea57ae6eefb42432220feab0350494f4144c", "target": 1, "func": "int av_packet_split_side_data(AVPacket *pkt){\n\n    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){\n\n        int i;\n\n        unsigned int size;\n\n        uint8_t *p;\n\n\n\n        p = pkt->data + pkt->size - 8 - 5;\n\n        for (i=1; ; i++){\n\n            size = AV_RB32(p);\n\n            if (size>INT_MAX || p - pkt->data < size)\n\n                return 0;\n\n            if (p[4]&128)\n\n                break;\n\n            p-= size+5;\n\n        }\n\n\n\n        pkt->side_data = av_malloc_array(i, sizeof(*pkt->side_data));\n\n        if (!pkt->side_data)\n\n            return AVERROR(ENOMEM);\n\n\n\n        p= pkt->data + pkt->size - 8 - 5;\n\n        for (i=0; ; i++){\n\n            size= AV_RB32(p);\n\n            av_assert0(size<=INT_MAX && p - pkt->data >= size);\n\n            pkt->side_data[i].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n            pkt->side_data[i].size = size;\n\n            pkt->side_data[i].type = p[4]&127;\n\n            if (!pkt->side_data[i].data)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(pkt->side_data[i].data, p-size, size);\n\n            pkt->size -= size + 5;\n\n            if(p[4]&128)\n\n                break;\n\n            p-= size+5;\n\n        }\n\n        pkt->size -= 8;\n\n        pkt->side_data_elems = i+1;\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4159, "substitutes": {"pkt": ["fkg", "upman", "preq", "statkt", "pkg", "tconn", "opkt", "payacet", "Packet", "ptx", "patchkg", " punc", "expmsg", "Pmsg", "apacket", "apwp", "postacket", "formacket", "fkt", " pkg", "pareq", "paunc", "prkt", "pvert", "pracket", "pingunc", "wpett", "Pman", "postkg", "pingvert", "wpkt", "upkg", "pman", "packkt", "pact", "respkt", "ccmd", "pconn", "cpkt", "apcmd", "upnt", "Ptx", "pcast", "commet", "tkt", "pict", "ipkt", " pac", "pet", "opunct", "Pth", "pingkg", "respacket", "portacet", "pfeat", "commth", "apkt", "wpelt", "picast", "pth", "opacket", "cacket", "upwd", "repacket", " pact", "patchunct", "pingcmd", "wpwp", "pacmd", "portkt", "upacket", "payac", "Pconn", "patchkt", "paynt", "statact", "patchett", "pikg", "formelt", " pcast", "packtext", "prnt", "pagt", "expett", "postett", "formkt", "pingacket", " ptx", "partett", "formkg", "portett", "pac", "piact", "pingth", " packet", "apvt", "apwd", "packacket", "repcmd", " pett", "pingkt", "cpunct", "apkg", "upunct", " preq", "patx", "ipacket", "commvert", "Pet", "partfeat", "pett", "ckt", "opconn", "respcast", " pvt", "Pvert", "pcmd", "paykg", "apman", "pnt", "expacket", "apgt", "statcast", "formendor", "paett", "actkg", "actett", "Pwd", "expkt", "pawp", "tacket", "Pnt", "cpett", " punct", "postkt", "pikt", "pinget", "packet", "ipunct", "wpacket", "ptext", "tnt", "paict", "pgt", "pvt", "postconn", "paacet", "ipkg", "payett", "apnt", " pcmd", "partkt", "packcast", "pendor", "wpconn", "punc", "apreq", "commkt", "pingunct", "repkt", " pendor", "postfeat", "actkt", "repkg", "pacet", "ckg", " pnt", "prvt", "pwp", " ptext", "pelt", "partkg", "upett", "actfeat", "payacket", "cpkg", "pwd", "paacket", "paunct", "portict", "payict", "Pkt", "pakt", "wpgt", "payendor", "statkg", "pmsg", "expnt", "facket", "punct", "pant", "wpkg", " pconn", "formac", "apunct", "paykt", " pmsg", "felt", "upkt", "resptext", "pingconn"], "i": ["id", "l", "ii", "ini", "it", "hi", "di", "gi", "ie", "y", "ci", "ami", "ims", "qi", "cli", "n", "ei", "ix", "ic", "si", "j", "ji", "b", "index", "at", "zi", "iri", "pi", "x", "phi", "us", "ia", "is", "f", "ind", "mi", "io", "ri", "chain", "ip", "ex", "multi", "e", "ti", "m", "ai", "im", "I", "s", "by", "u", "out", "init", "li", "sim", "ki", "fi", "bi", "v", "me", "\u0438", "uri", "o", "in", "ice", "ui", "iu", "ij", "xi", "status", "um", "from", "err", "batch"], "size": ["get", "id", "l", "sum", "ize", "send", "description", "reason", "body", "date", "scroll", "height", "now", "sn", "area", "gravity", "count", "c", "message", "start", "n", "z", "general", "Size", "sp", "data", "scope", "equal", "ose", "si", "power", "align", "empty", "index", "name", "timeout", "member", "zero", "large", "buffer", "new", "len", "code", "storage", "dimension", "pi", "block", "total", "shape", "capacity", "small", "limit", "loss", "SIZE", "address", "version", "ne", "span", "space", "source", "format", "group", "when", "shift", "fee", "sh", "tree", "type", "end", "sample", "e", "m", "unit", "engine", "number", "s", "notice", "sized", "t", "max", "speed", "form", "south", "use", "v", "length", "to", "position", "offset", "set", "style", "needed", "time", "bytes", "g", "network", "status", "scale", "global", "sv", "zone", "window", "see", "value", "cache"], "p": ["pp", "pkg", "l", "pc", "q", "wp", "pro", "pt", "ap", "y", "fp", "up", "bp", "pl", "c", "n", "pre", "ptr", "cp", "progress", "a", "sp", "data", "ps", "app", "r", "post", "j", "h", "php", "b", "at", "pb", "dp", "op", "pi", "pod", "lp", "f", "d", "att", "mp", "pa", "port", "br", "ip", "np", "point", "peer", "e", "m", "conv", "pid", "pe", "s", "u", "vp", "t", "rep", "v", "ping", "pg", "partial", "pm", "g", "pr", "tp", "jp", "P", "parse", "cache", "public"]}}
{"project": "qemu", "commit_id": "d3ac1a87b228bcd231d19acf1ebe9844b7639237", "target": 1, "func": "static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n    scsi_req_cancel(s->req);\n\n}\n", "idx": 4165, "substitutes": {"dev": ["pp", "os", "de", "conn", "od", "d", "v", "data", "app", "ctx", "Dev", "ad", "dd", "w", "req", "h", "ve", "pad", "device", "o", "io", "port", "sd", "mem", "proc", "def", "DEV", "ver", "buf", "md", "cam", "db", "iv", "unknown", "raw", "home", "test", "hw", "pi", "dis", "des", "sys", "ev", "out", "cmd", "dem"], "p": ["pp", "t", "cp", "pkg", "lp", "f", "d", "v", "sp", "r", "pc", "q", "w", "pa", "h", "i", "proc", "b", "np", "g", "pb", "fp", "tp", "dp", "m", "P", "bp", "c"], "s": ["t", "os", "S", "syn", "ds", "south", "is", "a", "sp", "ps", "spec", "q", "sl", "sam", "set", "ss", "j", "h", "so", "ns", "b", "state", "sq", "ses", "sts", "rs", "gs", "ts", "es", "stats", "fs", "sv", "cs", "c", "ls", "n", "qs", "sys", "sol", "se", "sa"]}}
{"project": "qemu", "commit_id": "4508d81a788f451c83604e1d0033243e191d71a7", "target": 1, "func": "ram_addr_t ppc405_set_bootinfo (CPUState *env, ppc4xx_bd_info_t *bd,\n\n                                uint32_t flags)\n\n{\n\n    ram_addr_t bdloc;\n\n    int i, n;\n\n\n\n    /* We put the bd structure at the top of memory */\n\n    if (bd->bi_memsize >= 0x01000000UL)\n\n        bdloc = 0x01000000UL - sizeof(struct ppc4xx_bd_info_t);\n\n    else\n\n        bdloc = bd->bi_memsize - sizeof(struct ppc4xx_bd_info_t);\n\n    stl_phys(bdloc + 0x00, bd->bi_memstart);\n\n    stl_phys(bdloc + 0x04, bd->bi_memsize);\n\n    stl_phys(bdloc + 0x08, bd->bi_flashstart);\n\n    stl_phys(bdloc + 0x0C, bd->bi_flashsize);\n\n    stl_phys(bdloc + 0x10, bd->bi_flashoffset);\n\n    stl_phys(bdloc + 0x14, bd->bi_sramstart);\n\n    stl_phys(bdloc + 0x18, bd->bi_sramsize);\n\n    stl_phys(bdloc + 0x1C, bd->bi_bootflags);\n\n    stl_phys(bdloc + 0x20, bd->bi_ipaddr);\n\n    for (i = 0; i < 6; i++)\n\n        stb_phys(bdloc + 0x24 + i, bd->bi_enetaddr[i]);\n\n    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);\n\n    stl_phys(bdloc + 0x2C, bd->bi_intfreq);\n\n    stl_phys(bdloc + 0x30, bd->bi_busfreq);\n\n    stl_phys(bdloc + 0x34, bd->bi_baudrate);\n\n    for (i = 0; i < 4; i++)\n\n        stb_phys(bdloc + 0x38 + i, bd->bi_s_version[i]);\n\n    for (i = 0; i < 32; i++)\n\n        stb_phys(bdloc + 0x3C + i, bd->bi_s_version[i]);\n\n    stl_phys(bdloc + 0x5C, bd->bi_plb_busfreq);\n\n    stl_phys(bdloc + 0x60, bd->bi_pci_busfreq);\n\n    for (i = 0; i < 6; i++)\n\n        stb_phys(bdloc + 0x64 + i, bd->bi_pci_enetaddr[i]);\n\n    n = 0x6A;\n\n    if (flags & 0x00000001) {\n\n        for (i = 0; i < 6; i++)\n\n            stb_phys(bdloc + n++, bd->bi_pci_enetaddr2[i]);\n\n    }\n\n    stl_phys(bdloc + n, bd->bi_opbfreq);\n\n    n += 4;\n\n    for (i = 0; i < 2; i++) {\n\n        stl_phys(bdloc + n, bd->bi_iic_fast[i]);\n\n        n += 4;\n\n    }\n\n\n\n    return bdloc;\n\n}\n", "idx": 4166, "substitutes": {"env": ["ptr", "et", "dev", "de", "ch", "el", "ec", "vs", "con", "txt", "cur", "ld", "en", " st", "proc", "sh", "ses", "buf", "vd", "code", "e", "te", "ed", "pl", "tx", "pe", "shell", "ev"], "bd": ["py", "bo", "hd", "disabled", "bn", "dev", "dt", "de", "th", "ds", "bh", "bi", "bt", "nb", "od", "td", "d", "el", " BD", "board", "done", "dd", "ded", "bar", "cd", "edd", "ben", "don", "ld", "br", "fl", "dat", "bs", "gd", "sd", "nuts", "b", "bb", "bro", "def", "bind", "ond", "sh", "md", "bl", "bel", "gb", "kb", "vd", "ba", "non", "pd", "db", "bg", "shell", "cond", "rd", "disc", "deb", "desc", "sb", "dis", "nd", "des", "bf", "bin", "box", "amb", "rb", "BD", "bc", "lib"], "flags": ["ds", " flag", " args", "atts", " fs", "ps", "fd", "files", " options", "options", " attributes", " features", "FLAG", " fields", "Flags", "ns", "fu", " props", "ts", " bits", "bits", "fs", "flag", "args", "settings", " fmt", "fields", "ags"], "bdloc": ["bclocation", "bbloc", "baloc", "boloc", "bllc", "bdprop", "hdlc", "dLOC", "gdabs", "bdlocal", "breg", "dbprop", "bdnz", "BDLOC", "bardloc", "bafc", "blconn", "bolocation", "balocation", "rodreg", "bclit", "bderr", "dlocation", "bLoc", "bdesc", "blfc", "ldlocation", "bclocal", "blzero", "dloc", "djreg", "dbLOC", "bllocation", "bcprop", "bcalloc", "djloc", "blval", "blko", "bllit", "rodloc", "ldcoord", "bbpl", "bcval", "ldzip", "blloc", "rodko", "gdloc", "balit", "hdlocation", "bcreg", "bcpos", "bedoci", "bopl", "bclib", "bdval", "bdLoc", "blpl", "bdco", "bedloc", "bcco", "bautil", "bloci", "baco", "bardlocation", "hdLOC", "bllib", "bbprop", "bdutil", "BDlocation", "BDLoc", "bdrec", "bapos", "bldesc", "ldLOC", "blLOC", "bcok", "bclc", "bcoci", "bdfc", "bbok", "bcdesc", "boabs", "dbloc", "bardlit", "bdlocation", "bdreg", "boreg", "bardfc", "hdlocal", "dcoord", "bcrec", "eddcoord", "bdzip", "bcsc", "bbzero", "bLOC", "bdpos", "blabs", "blreg", "bczip", "bllocal", "bdalloc", "blalloc", "bcutil", "bdlib", "dbreg", "bcfc", "blc", "bdzero", "bdcoord", "bedlocation", "bedalloc", "blocation", "bbLOC", "eddloc", "bddesc", "bdabs", "bdlit", "bczero", "bbreg", "bdsc", "bolit", "bcloc", "hdloc", "eddlocation", "blrec", "bcerr", "bdlc", "bcLOC", "djpos", "blok", "bareg", "gdconn", "blutil", "bcnz", "bdko", "borec", "blerr", "rodsc", "rodlocation", "bazip", "djlocation", "bdpl", "gdlib", "ldloc", "dLoc", "bcabs", "bdconn", "bloc", "bbval", "bdLOC", "eddLOC", "bblib", "bcconn", "bapl", "bberr", "bdok", "boval", "bardnz", "balc", "banz", "balocal", "hdLoc", "BDloc", "ldreg", "bdoci", "bosc", "bofc", "rodlit", "bardko", "bcpl", "bardco"], "i": ["key", "p", "id", "ii", "ini", "it", "q", "asi", "hi", "di", "gi", "iq", "ie", "y", "remote", "ci", "ami", "ni", "qi", "cli", "er", " ii", "ei", "ity", "ix", "ic", "si", "oi", "j", "ji", "b", "index", "name", "zi", "this", "try", "pi", "x", "phi", "us", "is", "eu", "mi", "gu", "ri", "io", "chain", "ex", "ip", "point", "multi", "print", "e", "ti", "m", "ai", "I", "u", "init", "dr", "li", "sim", "ki", "fi", "bi", "v", "me", "\u0438", "uri", "in", "g", "ui", "iu", "xi", "ij", "status", "um", "ico"], "n": ["Ni", "t", "p", "no", "l", "v", "nn", " ni", "j", "ne", "cn", "o", "nm", "ns", "nu", "nan", "g", "len", "sn", "m", "na", "N", "ni", "num", "count", "c", "nb", "nc"]}}
{"project": "qemu", "commit_id": "92cb05574b7bd489be81f9c58497dc7dfe5d8859", "target": 0, "func": "bool virtio_ipl_disk_is_valid(void)\n\n{\n\n    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());\n\n}\n", "idx": 4173, "substitutes": {}}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    int ret = 0;\n\n\n\n    if (bdrv_set_key(bs, password) != 0) {\n\n        monitor_printf(mon, \"invalid password\\n\");\n\n        ret = -EPERM;\n\n    }\n\n    if (mon->password_completion_cb)\n\n        mon->password_completion_cb(mon->password_opaque, ret);\n\n\n\n    monitor_read_command(mon, 1);\n\n}\n", "idx": 4178, "substitutes": {"mon": ["ain", "bo", "util", "co", "monkey", "sim", "mark", "von", "dm", "den", "mons", "ms", "mont", "cat", "mi", "mu", "mitter", "my", "serv", "con", "mun", "sam", "chron", "Mon", "don", "mos", "di", "comm", "MON", "mat", "ston", " monitor", "dat", "ann", "mas", "mt", "manager", "met", "mx", "ver", "md", "mn", "pers", "store", "tom", "admin", "om", "mit", "mint", "m", "mm", "san", "ai", "wat", "num", "irm", "on", "mot", "rain", "meter", "mate", "tem", "demon", "min", "man", "mond", "mut", "monitor"], "password": ["key", "Password", "hello", "sword", "token", "private", "secret", "pass", "hash", "prefix", "padding", "words", "login", "username", "description", "wordpress", "pty", "phrase", "word", "wd", "paste", "text", "command", "crypt", "pattern", "past", "auth", "user", " Password", "REDACTED", "email", "picture", "value", "PASS"], "opaque": ["psolete", "compque", "compaques", "pacity", " Opacity", "ipaque", "paque", "OPaque", " Opacement", "opaques", "opacement", "pacement", "oplacity", "oplaque", "opque", "opsolete", "ipque", "oplacement", "ipaques", " Opaque", "opacity", "compaque", " Opsolete", "OPque", "OPaques", "oplsolete"], "bs": ["ubs", "oss", "bos", "bh", "bi", "is", "bm", "ms", "aus", "bid", "ps", "aos", "bas", " os", "ths", "js", "ns", "asis", "mas", "bb", "BS", "ons", "pb", "gs", "ts", "obs", "lbs", "has", "acs", "bits", "fs", "its", "bis", "bp", "cs", "sb", "us", "als", "ls", "aps", "ats", "sys", "bc"]}}
{"project": "FFmpeg", "commit_id": "9c3a8693a20da3ad89a327bf778e13c2cd74c81c", "target": 0, "func": "dshow_cycle_devices(AVFormatContext *avctx, ICreateDevEnum *devenum,\n\n                    enum dshowDeviceType devtype, IBaseFilter **pfilter)\n\n{\n\n    struct dshow_ctx *ctx = avctx->priv_data;\n\n    IBaseFilter *device_filter = NULL;\n\n    IEnumMoniker *classenum = NULL;\n\n    IMoniker *m = NULL;\n\n    const char *device_name = ctx->device_name[devtype];\n\n    int skip = (devtype == VideoDevice) ? ctx->video_device_number\n\n                                        : ctx->audio_device_number;\n\n    int r;\n\n\n\n    const GUID *device_guid[2] = { &CLSID_VideoInputDeviceCategory,\n\n                                   &CLSID_AudioInputDeviceCategory };\n\n    const char *devtypename = (devtype == VideoDevice) ? \"video\" : \"audio\";\n\n\n\n    r = ICreateDevEnum_CreateClassEnumerator(devenum, device_guid[devtype],\n\n                                             (IEnumMoniker **) &classenum, 0);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not enumerate %s devices.\\n\",\n\n               devtypename);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    while (!device_filter && IEnumMoniker_Next(classenum, 1, &m, NULL) == S_OK) {\n\n        IPropertyBag *bag = NULL;\n\n        char *buf = NULL;\n\n        VARIANT var;\n\n\n\n        r = IMoniker_BindToStorage(m, 0, 0, &IID_IPropertyBag, (void *) &bag);\n\n        if (r != S_OK)\n\n            goto fail1;\n\n\n\n        var.vt = VT_BSTR;\n\n        r = IPropertyBag_Read(bag, L\"FriendlyName\", &var, NULL);\n\n        if (r != S_OK)\n\n            goto fail1;\n\n\n\n        buf = dup_wchar_to_utf8(var.bstrVal);\n\n\n\n        if (pfilter) {\n\n            if (strcmp(device_name, buf))\n\n                goto fail1;\n\n\n\n            if (!skip--)\n\n                IMoniker_BindToObject(m, 0, 0, &IID_IBaseFilter, (void *) &device_filter);\n\n        } else {\n\n            av_log(avctx, AV_LOG_INFO, \" \\\"%s\\\"\\n\", buf);\n\n        }\n\n\n\nfail1:\n\n        if (buf)\n\n            av_free(buf);\n\n        if (bag)\n\n            IPropertyBag_Release(bag);\n\n        IMoniker_Release(m);\n\n    }\n\n\n\n    IEnumMoniker_Release(classenum);\n\n\n\n    if (pfilter) {\n\n        if (!device_filter) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Could not find %s device.\\n\",\n\n                   devtypename);\n\n            return AVERROR(EIO);\n\n        }\n\n        *pfilter = device_filter;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4196, "substitutes": {"ctx": ["tc", "t", "cm", "cp", "p", "conf", "co", "pkg", "cv", "tmp", "config", "conn", "wx", "msg", "dc", "obj", "cb", "txt", "loc", "cc", "abc", "handle", "comm", "gc", "history", "mem", "np", "resp", "today", "act", "ctrl", "pool", "cf", "jp", "cfg", "xc", "ca", "addr", "hw", "ct", "x", "tm", "tx", "cmd", "Context", "xp", "context", "sys", "ctl", "mc"], "device_filter": [" device_limit", "property2map", " device_transform", "device__name", "resource_name", "device_type", "devicelylimit", "resource_ref", "device__type", "resource_filter", "device2filter", "property_Filter", "property2filter", "device2map", "property_filter", "device_limit", "devicelyfilter", "device__filter", "device_transform", "device__ref", "device2Filter", "devicelytransform", "property_map", "device_ref", "device_map", "property2Filter", "device_Filter", "resource_type"], "classenum": ["groupnum", " classum", "Classeng", "processum", " classen", " classinal", "classum", "CLASSum", "classeseng", "Classen", "groupinal", "classen", "processenum", " classnum", "classesenum", "Classum", "processnum", "CLASSenum", "CLASSeng", "groupenum", "Classinal", "groupum", "classeng", "classesum", "classnum", "classinal", "processen", "Classenum", "Classnum"], "m": ["gm", "t", "cm", "p", "dm", "bm", "ms", "d", "v", "l", "mi", "mu", "mp", "em", "msg", "sm", "map", "w", "k", "j", "h", "module", "i", "mem", "mt", "b", "manager", "mx", "g", "mn", "mb", "M", "ma", "y", "vm", "mm", "tm", "mod", "c", "am", "n", "man", "mc", "mr"], "device_name": ["device2number", "deviceetytype", "Device_id", "project_def", "project_type", "device_type", "Device_Name", "dev_name", "deviceetydefault", "Device_NAME", "Device_name", "device_id", "device_NAME", "device2name", "device_number", "dev_number", "device2names", "project_name", "deviceetyname", "dev_type", "dev_names", "device_def", "device_default", "project_default", "device_names", "device_Name", "device2type", "deviceetydef"], "r": ["rc", "dr", "t", "fr", " err", "p", "actor", "f", "kr", "arr", "er", "R", "re", "lr", "it", "rr", "error", "q", "w", "or", "h", "ry", "j", "br", "sr", "rem", "vr", "cr", "attr", "i", "rb", "ror", "rg", "result", "RR", "usr", "hr", "nr", "g", "pr", "rar", "rs", "ir", "ar", "repl", "rn", "rec", "rank", "status", "res", " R", "after", "rd", "tr", "c", "Error", "ren", "n", "rt", " rc", "err", "run", "mr"], "device_guid": ["device_sead", "device_seid", "device_gaids", "device_uuID", "device_GuId", "device_guad", "device_seids", "device_uuId", "device_gaad", "device_uuids", "device_guids", "device_cuId", "device_uuid", "device_Guids", "device_guId", "device_cuids", "device_uuad", "device_guID", "device_gaid", "device_cuid", "device_cuID", "device_Guid", "device_GuID"], "devtypename": ["devtyrenname", "devtypternname", "devtyrenAME", "devtypternAME", "devtytername", "devtyppenAME", "devtylename", "devTypename", "devtyptername", "devtyperename", "devtyperame", "devtypenname", "devTyrenname", "devtyternname", "devtyrenename", "devtyternAME", "devtyppenname", "devTyrenename", "devtyrename", "devtyperAME", "devtyternename", "devTyrenAME", "devtyppenename", "devtypername", "devTypenname", "devtyppename", "devtypenAME", "devtypenename", "devtylenename", "devtylenAME", "devtypternename", "devtylenname", "devTypenename", "devTyrename", "devTypenAME"], "bag": ["jar", "pack", "pkg", "grab", "binary", "card", "bed", "bar", "ag", "map", "folder", "pad", "package", "gc", "bow", "buff", "b", "car", "pb", "band", "zip", "zag", "buffer", "comb", "ball", "container", "grid", "storage", "bank", "pak", "sb", "rag", "bin", "bags", "box", "tab", "ab", "wb", "batch", "widget"], "buf": ["rc", "BU", "p", "bound", "pkg", "cv", "tmp", "rw", "data", "mu", "pg", "msg", "bar", "txt", "cb", "w", "Buffer", "str", "prop", "br", "buff", "Buff", "mem", "b", "np", "orig", "bl", "mb", "ref", "buffer", "new", "pool", "cmp", "cam", "db", "browser", "conv", "vec", "window", "uf", "seq", "bin", "cmd", "queue", "box", "rb", "next", "err", "bc", "wb", "batch"], "var": ["AR", "t", "pack", "dev", "ser", "art", "let", "temp", "cast", "pkg", "tmp", "v", "col", "vard", "bar", "tar", "serv", "map", "obj", "w", "str", "val", "txt", "br", "vr", "usr", "par", "V", "ver", "car", "term", "rad", "ref", "y", "tag", "ar", "row", "ars", "iter", "variable", "browser", "iv", "star", "addr", "Var", "expr", "mod", "null", "vol", "box", "tab", "av"], "skip": ["seek", " sr", " iter", "limit", "sk", "ips", " snap", "Skip", "sp", "spec", "pass", "scan", "error", " seek", "check", "send", "disable", "counter", "offset", "chip", "depth", " skipping", "read", " scan", "ip", "jump", "stop", "index", "step", " sk", "write", "serial", "zero", "strip", "status", "iter", "find", "scale", "loop", "snap", "start", "sleep", " Skip", " skipped", "run", " sp"]}}
{"project": "FFmpeg", "commit_id": "a755b725ec1d657609c8bd726ce37e7cf193d03f", "target": 0, "func": "static int do_decode(AVCodecContext *avctx, AVPacket *pkt)\n\n{\n\n    int got_frame;\n\n    int ret;\n\n\n\n    av_assert0(!avctx->internal->buffer_frame->buf[0]);\n\n\n\n    if (!pkt)\n\n        pkt = avctx->internal->buffer_pkt;\n\n\n\n    // This is the lesser evil. The field is for compatibility with legacy users\n\n    // of the legacy API, and users using the new API should not be forced to\n\n    // even know about this field.\n\n    avctx->refcounted_frames = 1;\n\n\n\n    // Some codecs (at least wma lossless) will crash when feeding drain packets\n\n    // after EOF was signaled.\n\n    if (avctx->internal->draining_done)\n\n        return AVERROR_EOF;\n\n\n\n    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        ret = avcodec_decode_video2(avctx, avctx->internal->buffer_frame,\n\n                                    &got_frame, pkt);\n\n        if (ret >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))\n\n            ret = pkt->size;\n\n    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        ret = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame,\n\n                                    &got_frame, pkt);\n\n    } else {\n\n        ret = AVERROR(EINVAL);\n\n    }\n\n\n\n    if (ret == AVERROR(EAGAIN))\n\n        ret = pkt->size;\n\n\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (avctx->internal->draining && !got_frame)\n\n        avctx->internal->draining_done = 1;\n\n\n\n    if (ret >= pkt->size) {\n\n        av_packet_unref(avctx->internal->buffer_pkt);\n\n    } else {\n\n        int consumed = ret;\n\n\n\n        if (pkt != avctx->internal->buffer_pkt) {\n\n            av_packet_unref(avctx->internal->buffer_pkt);\n\n            if ((ret = av_packet_ref(avctx->internal->buffer_pkt, pkt)) < 0)\n\n                return ret;\n\n        }\n\n\n\n        avctx->internal->buffer_pkt->data += consumed;\n\n        avctx->internal->buffer_pkt->size -= consumed;\n\n        avctx->internal->buffer_pkt->pts   = AV_NOPTS_VALUE;\n\n        avctx->internal->buffer_pkt->dts   = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    if (got_frame)\n\n        av_assert0(avctx->internal->buffer_frame->buf[0]);\n\n\n\n    return 0;\n\n}\n", "idx": 4198, "substitutes": {"avctx": [" avcontext", "averreq", "wavctx", "afca", "averconn", "avwp", "averwx", "iverjac", "afcmd", "ivctx", "vrtx", "avcmd", "varcheck", "savsys", "navtx", "vrsys", "avectx", "wavtx", "iverconn", "versys", "averloc", "avectl", "avfc", "averctl", "wavcmd", "avwx", "devcontext", "avercu", "ajnp", "iverloc", "averwp", "iverctx", "avernp", "averca", " avcmp", "ivercu", "savcontext", "avcf", " avnc", " avreq", "vrctx", "vrconn", "vertx", "afctl", "wavcheck", "avcu", "wavcontext", "afctx", "wavwp", "varctx", "navctx", "avconfig", "avsys", "savctx", "avnp", "avetx", "averkw", "evtx", " avctl", "aveconfig", "ajcfg", "ivcu", " avtx", "avecmp", "avercmp", "avcheck", "evca", "ajconn", "ivercfg", "avctl", " avkw", "savctrl", "avctrl", "ivercheck", " avcheck", "averjac", "vrctl", "avcp", "vrcu", "wavcmp", "ajloc", "avpkg", "averfc", "navcu", "avercontext", "avcontext", "averctx", "aveca", "ajwp", "avecheck", "avecol", "AVtx", "ajctx", "avercmd", "navcmd", "vrfc", "avloc", "navcontext", "vercu", "verctrl", "devmk", "afcheck", " avcol", "ivercontext", "vrcmp", "avnc", " avca", "avefc", "varpkg", "avesys", "vrcontext", "avercfg", "savcp", "avjac", "avcfg", "devctx", "devcmd", "vartx", "iverwx", "avmk", "avercheck", "avca", "AVcontext", "avecfg", "iverconfig", "averconfig", "avconn", "ajcontext", " avcu", "avecontext", "AVnc", "iverpkg", "avreq", "AVctx", " avcp", "avepkg", "iverkw", "afcmp", "devtx", "wavnp", "evcontext", "navctl", "avertx", "avkw", "evctx", "afcontext", "varsys", "savctl", "wavpkg", "vercontext", "avecf", "varwx", "wavctl", "navnc", "avectrl", "afpkg", "avercol", " avpkg", "wavsys", "aftx", "avcmp", "aversys", "aveconn", "avejac", "avercp", "wavcfg", "ivtx", " avcfg", "avcol", "avecmd", "avercf", "avermk", "devcu", "avereq", "iversys", "avtx", "verctx", "ivcfg", " avcf", "vrcfg", "navmk"], "pkt": ["pdu", "pkg", "Packet", "pct", "proacket", "ppelt", "ppdt", "apacket", "ppet", "pront", " pkg", "prkt", "pracket", "prodt", "dkg", "upkg", "ppunct", "upnt", "prokg", "pet", "kct", "ppdu", "apkt", "Pkg", "ppwk", "cacket", "ppqt", "dkt", "ck", "dacket", "prnt", " pqt", "proct", "pbunct", "upelt", " packet", "pk", "kacket", "paramkt", "apkg", "paramunct", "paramwk", "pqt", "prct", "ckt", "cct", "kkt", "pnt", "paramkg", " pwk", "Pnt", " punct", "packet", " pet", "ppkg", "cnt", "paqt", "kkg", "pbct", "ppacket", " pelt", "ppct", " pct", "prokt", "Pct", "pbacket", "ckg", " pnt", "pelt", " pdt", "dk", "apk", "Pkt", "pakt", "padu", "pwk", "proet", "ppkt", "pant", "punct", "pbkt", "upkt", " pdu", "pdt", "ppnt"], "got_frame": ["got_Frame", "got_point", "fetched_frame", "gone_frames", "fetched_feature", "got_part", "got_role", "got12frame", "got_label", "gone_point", "got12label", " got_Frame", "gotexistingzo", "drawn_frame", "got12role", "get_label", "gotexistingframes", "fetched_channel", "gotexistingshot", "fetched___channel", "got___frame", "got___component", "fetched___frame", "got___channel", "drawn_shot", "got_feature", "got_channel", " got_component", "got_component", "get_frame", "got_zo", "get_role", "drawn_frames", "drawn_zo", "got_shot", "gone_part", "got_frames", "fetched___feature", "gotexistingframe", "got___feature", "got___Frame", " got_frames", "got___frames", "gone_frame"], "ret": ["deg", "get", "gt", "vers", "RET", "arr", "nt", "cont", "not", "ured", "orted", "txt", "rem", "gc", "pret", "over", "net", "iter", "det", "uf", "final", "url", "cmd", "compl", "success", "progress", "arg", "rm", "re", "fun", "j", "mat", "secure", "mem", "mt", "def", "ref", "len", "ts", "ort", "try", "flag", "num", "sys", "reset", "tf", "eval", "f", "att", "ft", "rets", "ext", "port", "nz", "rest", "repl", "round", "alf", "aux", "plain", "alt", "rt", "reg", "out", "img", "t", "elt", "dt", "max", "tmp", "ll", "cat", "Ret", "hash", "val", "result", "resp", "lt", "usr", "rev", "mel", "status", "jp", "res", "tr", "ter", "desc", "back", "err"]}}
{"project": "qemu", "commit_id": "e8f1f9db8787be08e0ae3ed5a94da68966dbfff1", "target": 0, "func": "void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)\n\n{\n\n    VLANState *vlan;\n\n    VLANClientState *vc;\n\n\n\n    vlan = qemu_find_vlan(vlan_id);\n\n\n\n   for(vc = vlan->first_client; vc != NULL; vc = vc->next)\n\n        if (!strcmp(vc->name, device))\n\n            break;\n\n\n\n    if (!vc) {\n\n        monitor_printf(mon, \"can't find device %s\\n\", device);\n\n        return;\n\n    }\n\n    qemu_del_vlan_client(vc);\n\n}\n", "idx": 4209, "substitutes": {"mon": ["util", "monkey", "com", "dm", "mons", "mont", "mi", "mu", "serv", "con", "mun", "sam", "Mon", "MON", " Mon", "mat", "ann", "mt", "met", "mn", "onet", "om", "dom", "mer", "cond", "mir", "mm", "san", "ai", "wat", "mot", "min", "meter", "tem", "man", "mut", "monitor"], "vlan_id": ["vlanpooltag", "vlanpoolid", "vlan2Id", "vlan2info", "vlanpoolinfo", "vlan_info", "vaneablemid", "vlan2id", "vnet_tag", "vlan_Id", "vlan2tag", "vane_ids", "vlan_ids", "vlanableId", "vnet_Id", "vaneableId", "vnet_id", "vnet_info", "vlanpoolId", "vaneableid", "vlanableid", "vane_Id", "vlanableids", "vlan_tag", "vane_mid", "vlanablemid", "vaneableids", "vane_id", "vlan_mid"], "device": ["hello", "dev", "door", "family", "controller", "resource", "plugin", "data", "hid", "Device", "component", "scope", "address", "connection", "node", "phy", "module", "pad", "package", "attribute", "location", "VICE", "link", "DEV", "name", "feature", "slave", "property", "serial", "network", "interface", "command", "product", "remote", "display", " Device", "unit", "model", "sequence", "number", "mode", "android", "pod", "directory", "value", "template"], "vlan": ["vlen", "evLAN", "VLAN", "wLAN", "evlan", "wran", "vLAN", "evran", "evann", "evlad", " volt", "evolt", "vran", " vLAN", "vnet", " vann", "wnet", "Vlen", "evlen", "Vann", "Vlan", "Volt", "Vran", "Vlad", "volt", "vann", " vlen", "Vnet", " vnet", " vran", "wlan", " vlad", "vlad"], "vc": ["tc", "mc", "liv", "rc", "vp", "cu", "cp", "util", "von", "cv", "fi", "ll", "cil", "vin", "v", "att", "lc", "cont", "pc", "ic", "dc", "rl", "serv", "ev", "VC", "fw", "coll", "vv", "cb", "cc", "umi", "dq", "ve", "vr", "cn", "comm", "gc", "ship", "fc", "cow", "ht", "ju", "vd", "ctrl", "ib", "vm", "jp", "cf", "ich", "iv", "xc", "vec", "sv", "ce", "cs", "irm", "lv", "client", "c", "wcs", "lic", "ls", "WC", "voc", "vt", "nc", "av", "bc"]}}
{"project": "qemu", "commit_id": "82ca891283a08cddd659b534592fe00f2159bc74", "target": 0, "func": "static void vfio_bar_write(void *opaque, hwaddr addr,\n\n                           uint64_t data, unsigned size)\n\n{\n\n    VFIOBAR *bar = opaque;\n\n    union {\n\n        uint8_t byte;\n\n        uint16_t word;\n\n        uint32_t dword;\n\n        uint64_t qword;\n\n    } buf;\n\n\n\n    switch (size) {\n\n    case 1:\n\n        buf.byte = data;\n\n        break;\n\n    case 2:\n\n        buf.word = cpu_to_le16(data);\n\n        break;\n\n    case 4:\n\n        buf.dword = cpu_to_le32(data);\n\n        break;\n\n    default:\n\n        hw_error(\"vfio: unsupported write size, %d bytes\\n\", size);\n\n        break;\n\n    }\n\n\n\n    if (pwrite(bar->fd, &buf, size, bar->fd_offset + addr) != size) {\n\n        error_report(\"%s(,0x%\"HWADDR_PRIx\", 0x%\"PRIx64\", %d) failed: %m\",\n\n                     __func__, addr, data, size);\n\n    }\n\n\n\n    DPRINTF(\"%s(BAR%d+0x%\"HWADDR_PRIx\", 0x%\"PRIx64\", %d)\\n\",\n\n            __func__, bar->nr, addr, data, size);\n\n\n\n    /*\n\n     * A read or write to a BAR always signals an INTx EOI.  This will\n\n     * do nothing if not pending (including not in INTx mode).  We assume\n\n     * that a BAR access is in response to an interrupt and that BAR\n\n     * accesses will service the interrupt.  Unfortunately, we don't know\n\n     * which access will service the interrupt, so we're potentially\n\n     * getting quite a few host interrupts per guest interrupt.\n\n     */\n\n    vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr]));\n\n}\n", "idx": 4211, "substitutes": {"opaque": ["opoid", "ogaques", "Opacity", " opane", "iopaque", "opaques", "OPaque", " oposter", "Opaque", "ogoid", " opaques", "iopane", "OPoid", "iopacity", "Oposter", "ogoster", "OPoster", "Opane", "oposter", "ogaque", "opane", "ioposter", " opoid", "opacity", " opacity", "OPaques"], "addr": ["ptr", "dr", "ace", "inter", "host", "pkg", "work", "debug", "id", "r", "lr", "ctx", "ix", "ad", "address", "loc", "offset", "or", "alias", "handle", "br", "pad", "adr", "align", "dh", "attr", "arp", "ip", "mem", "mt", "usr", "index", "name", " address", "at", "rs", "ref", "row", "ord", "res", "coord", "hw", "Address", "tx", "src", "start", "ack", "rt", "pos", "url", "err", "cmd", "add"], "data": ["rew", "out", "extra", "p", "share", "no", "d", "length", "done", "mu", "image", "ad", "hash", "DATA", "error", "msg", "padding", "address", "map", "w", "obj", "str", "trans", "Data", "pad", "align", "device", "empty", "dat", "action", "attr", "value", "format", "bytes", "ret", "def", "mem", "step", "type", "zero", "buffer", "da", "ata", "len", "ord", "text", "ops", " DATA", "rel", "res", "raw", "bits", "window", "tx", "bin", "block", "pos", "frame", "cache", "batch"], "size": ["capacity", "gz", "small", "t", "max", "Size", "weight", "loss", "dim", "news", "sum", "sp", "length", "SIZE", "see", "ize", "sent", "error", "address", "send", "offset", "set", "style", "equal", "reason", "time", "empty", "space", "format", "mem", "name", "shift", "sy", "sh", "fee", "g", "type", "zero", "height", "len", "sn", "code", "sym", "unknown", "scale", "unit", "window", "num", "number", "count", "sha", "s", "message", "n", "z", "shape", "value"], "bar": ["hello", " foo", "watch", "Bar", "que", " hist", "bill", "row", " br", "comb", "coord", "bridge", "rage", "bp", "queue", " ret", "box", "tick", " buffer", "grab", "handler", "arg", "worker", " ax", "hub", " buck", " job", "bug", " ay", "pas", "ax", "bart", "b", "car", " block", "ay", "chan", "pause", "item", " oy", "block", "tab", "ab", " toolbar", "org", "piece", "good", "br", "pad", " ab", " ah", "hist", " Bar", "nob", " bars", " b", "bg", "pair", "foo", "var", "aux", "by", "bag", " barr", "cor", " tab", " batch", "gob", "bench", "bars", "usr", " vec", "store", "ar", " ch", "ca", "job", "batch"], "buf": ["ptr", "doc", "fg", "pkg", "cv", "tmp", "ctx", "msg", "txt", "cb", "w", "map", "cur", "Buffer", "obj", "good", "req", "port", "br", "buff", "off", "mem", "b", "usr", "bl", "cap", "pb", "ref", "buffer", "ba", "img", "pool", "area", "iter", "alloc", "len", "vec", "tr", "foo", "window", "uf", "var", "tx", "env", "aux", "queue", "seq", "broad", "block", "box", "pos", "tab", "bag", "err", "cmd", "batch"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mcf5208evb_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    CPUM68KState *env;\n\n    int kernel_size;\n\n    uint64_t elf_entry;\n\n    target_phys_addr_t entry;\n\n    qemu_irq *pic;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"m5208\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find m68k CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Initialize CPU registers.  */\n\n    env->vbr = 0;\n\n    /* TODO: Configure BARs.  */\n\n\n\n    /* DRAM at 0x40000000 */\n\n    memory_region_init_ram(ram, \"mcf5208.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    memory_region_add_subregion(address_space_mem, 0x40000000, ram);\n\n\n\n    /* Internal SRAM.  */\n\n    memory_region_init_ram(sram, \"mcf5208.sram\", 16384);\n\n    vmstate_register_ram_global(sram);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000, sram);\n\n\n\n    /* Internal peripherals.  */\n\n    pic = mcf_intc_init(address_space_mem, 0xfc048000, env);\n\n\n\n    mcf_uart_mm_init(address_space_mem, 0xfc060000, pic[26], serial_hds[0]);\n\n    mcf_uart_mm_init(address_space_mem, 0xfc064000, pic[27], serial_hds[1]);\n\n    mcf_uart_mm_init(address_space_mem, 0xfc068000, pic[28], serial_hds[2]);\n\n\n\n    mcf5208_sys_init(address_space_mem, pic);\n\n\n\n    if (nb_nics > 1) {\n\n        fprintf(stderr, \"Too many NICs\\n\");\n\n        exit(1);\n\n    }\n\n    if (nd_table[0].used)\n\n        mcf_fec_init(address_space_mem, &nd_table[0],\n\n                     0xfc030000, pic + 36);\n\n\n\n    /*  0xfc000000 SCM.  */\n\n    /*  0xfc004000 XBS.  */\n\n    /*  0xfc008000 FlexBus CS.  */\n\n    /* 0xfc030000 FEC.  */\n\n    /*  0xfc040000 SCM + Power management.  */\n\n    /*  0xfc044000 eDMA.  */\n\n    /* 0xfc048000 INTC.  */\n\n    /*  0xfc058000 I2C.  */\n\n    /*  0xfc05c000 QSPI.  */\n\n    /* 0xfc060000 UART0.  */\n\n    /* 0xfc064000 UART0.  */\n\n    /* 0xfc068000 UART0.  */\n\n    /*  0xfc070000 DMA timers.  */\n\n    /* 0xfc080000 PIT0.  */\n\n    /* 0xfc084000 PIT1.  */\n\n    /*  0xfc088000 EPORT.  */\n\n    /*  0xfc08c000 Watchdog.  */\n\n    /*  0xfc090000 clock module.  */\n\n    /*  0xfc0a0000 CCM + reset.  */\n\n    /*  0xfc0a4000 GPIO.  */\n\n    /* 0xfc0a8000 SDRAM controller.  */\n\n\n\n    /* Load kernel.  */\n\n    if (!kernel_filename) {\n\n        fprintf(stderr, \"Kernel image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                           NULL, NULL, 1, ELF_MACHINE, 0);\n\n    entry = elf_entry;\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL);\n\n    }\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_image_targphys(kernel_filename, 0x40000000,\n\n                                          ram_size);\n\n        entry = 0x40000000;\n\n    }\n\n    if (kernel_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    env->pc = entry;\n\n}\n", "idx": 4213, "substitutes": {"args": ["flags", "doc", "config", "conn", "ras", "atts", "arg", "ms", "arr", "yes", "vs", "ins", "arms", "GS", "eds", "locks", "yrs", "words", "amps", "aws", "points", "changes", "ns", "js", "md", "ians", "limits", "gs", "ars", "ts", "Args", "actions", "vals", "bits", "fs", "cs", "orders", "ams", "names", "ants", "apps", "parts", "settings", "aps", "ags", "params", "cmd"], "cpu_model": ["cpuetymachine", " cpu_filename", "cpu_name", "cpuThefilename", "kernel_domain", "pu_module", "cpuetymodel", "gpu_mode", "cpu_record", "pu_name", "cpu00mode", "cpu_mod", "cpu_machine", "kernel_model", "cpu_filename", "cpuThetype", "pu_model", "cpuetymodels", "cpu_mode", "pu_record", "gpu_model", "cpuThemodel", "cpuPmode", "cpuPmethod", "cpu00domain", " cpu_machine", "kernel_mod", "gpu_machine", "cpuPmachine", "kernel_mode", "gpu_method", " cpu_type", "cpuPmodel", "cpu_module", "cpuThemachine", "cpu_models", "cpu00model", "pu_type", "pu_models", "cpu_type", "cpu_method", "pu_machine", "cpuetytype", "cpu00mod", "cpu_domain"], "kernel_filename": ["kernelacprofile", "system_filename", "system_profile", "kernelacfilename", "kernel_source", "kernelablefilename", "kernel_profile", "kernelablefile", "kernel_username", "kernelablefiles", "kernel_file", "system_username", "kernelitysource", "kernel_files", "system_file", "kernelacsource", "system_files", "kernelityfilename", "kernelableusername", "system_source", "kernelityfile", "kernelityprofile", "kernelacfile"], "env": ["eas", "ptr", "et", "dev", "environment", "ds", "conn", "eu", "esc", "ped", "v", "org", "sp", "ec", "vs", "ctx", "Ev", "eg", "em", "vt", "obj", "ep", "server", "ew", "en", "nv", "era", "here", "export", "eng", "js", "mem", "proc", "exc", "eni", "vm", "enc", "e", "cam", "end", "iv", "jp", "esp", "sv", "hw", "ent", "window", "ef", "pe", "context", "shell", "er", "ev", "viron", "event", "sw"], "kernel_size": ["kernel2count", " kernel_len", "kernel_count", " kernel_count", " kernel2name", "kernel2size", " kernel2len", "kernel_name", "kernel2name", " kernel2size", " kernel_name", " kernel2count", "kernel2len", "kernel_len"], "elf_entry": ["rel_size", "elfseqrecord", "rel_cell", "elfseqcell", "rel_entry", "elf_record", "elf_size", "rel_record", "elfseqentry", "elfseqsize", "elf_cell"], "entry": ["ptr", "conf", "elta", "pixel", "channel", "error", "field", "address", "connection", "ry", "cell", "ary", "pointer", "index", "par", "slot", "ries", "info", "nr", "row", "byte", "import", "count", "rance", "start", "value", "second"], "pic": ["py", "pick", "doc", "pot", "p", "phys", "jac", "syn", "ds", "fi", "lp", "ig", "iac", "sp", "er", "ps", "eric", "wic", "mi", "pc", "ic", "ping", "Pic", "ics", "wit", "pas", "txt", "wp", "spr", "style", "pa", "png", "pins", "hog", "fc", "anc", "js", "pres", "maker", "pol", "script", "pb", " Pic", "pr", "pers", "xi", "img", "jp", "cam", "capt", "pin", "pse", "pen", "pi", "fig", "lic", "shot", "nic", "kit", "virt", "tick", "picture", "sys", "xp", "plain", "magic", "pan", "mc", "mic", "pict"], "address_space_mem": ["address_pace_num", "address_system_mb", "address_pace_mem", "address_pace0sum", "locationmopblock", "address_system_memory", "address_pace_sys", "address_space_memory", "address__", "address_machine_addr", "address_space_mi", "address_space_hist", "address_space_mb", "address_space___num", "address_block", "address_space___mem", "address_spaceLres", "addressport_", "address_store_mem", "address_space_Mem", "address_space0sum", "addressmop_", "location__", "address_machine_mem", "address_space___emb", "address_pace_hist", "address_pace_em", "address_space_ram", "address_spaceLnm", "address_pace_mb", "address_space___err", "address_space___ms", "address_machine_em", "address_space__mem", "location_block", "address_space_addr", "address_space___memory", "address_space__addr", "address_machine_mi", "address_space_nm", "address_space___Mem", "address_system_mem", "address_pace0hist", "address_space_em", "address_spaceLmem", "address_space_err", "address_space__hist", "address_pace0mem", "addressportblock", "address_pace_sum", "locationmop_", "address_space__mi", "address_space_sum", "address_space__em", "address_space0hist", "address_store_emb", "address_pace_memory", "address_store_Mem", "address_store_ms", "address_space_emb", "address_space_sys", "address_space0mem", "address_space_ms", "address_space_num", "addressmopblock", "address_space_res", "address_space__sum", "address_pace_err"], "ram": ["sc", "rum", "lim", "sim", "lam", "ras", "rm", "sum", "RAM", "tar", "sam", "red", "ra", "rem", "ru", "space", "sd", "mem", "gram", "def", "memory", "iam", "mb", "gem", "gb", "row", "ma", "process", "rank", "cam", "um", "res", "na", "raw", "rom", "mm", "gra", "region", "rain", "ro", "am", "sky", "arm", "tem", "ran", "jam", "rb", "dem"], "sram": ["aslam", "Smb", "svram", "sslam", "ssam", " sream", "assam", "Smem", "sssam", "smem", "svsam", "asgram", "Sream", "ssgram", "slam", " slam", "sream", "ssream", "ssram", "svream", "asram", "ssmem", "smb", "svgram", " ssam", " smb", "Sram", " sgram", "sgram", "Sgram"]}}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)\n\n{\n\n    QObject *token;\n\n    const char *val;\n\n\n\n    if (ap == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    assert(token && token_get_type(token) == JSON_ESCAPE);\n\n    val = token_get_value(token);\n\n\n\n    if (!strcmp(val, \"%p\")) {\n\n        return va_arg(*ap, QObject *);\n\n    } else if (!strcmp(val, \"%i\")) {\n\n        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));\n\n    } else if (!strcmp(val, \"%d\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, int)));\n\n    } else if (!strcmp(val, \"%ld\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, long)));\n\n    } else if (!strcmp(val, \"%lld\") ||\n\n               !strcmp(val, \"%I64d\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, long long)));\n\n    } else if (!strcmp(val, \"%s\")) {\n\n        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));\n\n    } else if (!strcmp(val, \"%f\")) {\n\n        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));\n\n    }\n\n    return NULL;\n\n}\n", "idx": 4217, "substitutes": {"ctxt": ["CTtx", "kttx", "ctext", "ktext", "pttx", "conttx", "ptxt", "CText", "contxt", "ktxt", "cttx", "kttxt", "cttxt", "cattxt", "ctct", "CTxt", "pttxt", "CTtxt", "catxt", "contct", "catct", "cattx", "ptext", "conttxt", "CTct"], "ap": ["rep", "apache", "art", "api", "ach", "sp", "att", "app", "aw", "mp", "ad", "tap", "ag", "wp", "map", "ep", "sam", "amp", "aj", "pa", "ax", "rap", "av", "each", "ast", "apa", "arp", "ip", "np", " sap", "appy", "alg", "cap", "oa", "gap", "apt", "ape", "tp", "ar", "bp", "snap", "ac", "Ap", "ak", "AP", "aug", "hap", "am", "aps", "al", "ats", "pan", "ab"], "token": ["key", "t", "util", "ski", "fn", "form", "tf", "kn", "normal", "label", "list", "field", "call", "bar", "typ", "rule", "trigger", "node", "single", "object", "handle", "ok", "complete", "span", "TO", "empty", "word", "mt", "annot", "state", "name", "info", "tree", "at", "type", "row", "forward", "tool", "sn", "record", "oken", "variable", "tg", "prototype", "TN", "stat", "Token", "table", "operator", "initial", "header", "number", "template", "atom", "item", "KEN", "block", "start", "context", "local", "event", "tn"], "val": ["bo", "fail", "VAL", "util", "p", "elt", "lit", "dev", "lu", "old", "el", "eval", "sel", "vc", "cho", "v", "col", "it", "bil", "fb", "ele", "msg", "serv", "typ", "txt", "str", "cur", "prop", "req", "valid", "ve", "lex", "kl", "pal", "bal", "oval", "mem", "err", "il", "ver", "pol", "buf", "bl", "pr", "ref", "text", "len", "rol", "rel", "iv", "vals", "vec", "sv", "test", "pl", "var", "x", "gold", "tx", "lv", "cal", "vol", "grad", "al", "sol", "value", "reg", "tl", "Val", "aval"]}}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "static inline uint64_t ldq_phys_internal(hwaddr addr,\n\n                                         enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* I/O case */\n\n        addr = memory_region_section_addr(section, addr);\n\n\n\n        /* XXX This is broken when device endian != cpu endian.\n\n               Fix and add \"endian\" variable check */\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        val = io_mem_read(section->mr, addr, 4) << 32;\n\n        val |= io_mem_read(section->mr, addr + 4, 4);\n\n#else\n\n        val = io_mem_read(section->mr, addr, 4);\n\n        val |= io_mem_read(section->mr, addr + 4, 4) << 32;\n\n#endif\n\n    } else {\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)\n\n                                & TARGET_PAGE_MASK)\n\n                               + memory_region_section_addr(section, addr));\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            val = ldq_le_p(ptr);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            val = ldq_be_p(ptr);\n\n            break;\n\n        default:\n\n            val = ldq_p(ptr);\n\n            break;\n\n        }\n\n    }\n\n    return val;\n\n}\n", "idx": 4218, "substitutes": {"addr": ["gz", "p", "host", "eth", "art", "pkg", "id", "arr", "msg", "ag", "loc", "alias", "handle", "dh", "adj", "net", "arity", "coord", "tx", "hop", "arm", "url", "cmd", "ace", "inter", "work", "a", "dist", "r", "ix", "obj", "align", "arp", "i", "mem", "mt", "index", "at", "ref", "ord", "x", "src", "nl", "ack", "urg", "load", "rc", "org", "ad", "address", "map", "pad", "oad", "adr", "ip", "asm", " address", "point", "adder", "rs", "Address", "alt", "rt", "add", "dr", "lr", "hash", "offset", "attr", "usr", "act", "store", "alloc", "ar", "res", "hw", "expr", "ac", "sha", "ash", "pos", "err"], "endian": ["endia", "endness", "Endian", " endia", "ENDric", "endians", "endric", "endIAN", "Endric", " endians", "ENDian", "Endians", "mentia", "mentians", "EndIAN", "ENDians", "engness", " endness", "endsIAN", "endsians", "ENDIAN", "mentian", "engians", "endsric", "mentness", "endsian", "engian", "engia"], "ptr": ["deg", "dr", "fr", "rep", "p", "inter", "rod", "td", "prime", "ctr", "ped", "ind", "arr", "r", "pipe", "ctx", "sp", "ps", "pc", "cont", "func", "pointers", "address", "loc", "offset", "cert", "req", "handle", "port", "pad", "vr", "adr", "pt", "attr", "dh", "js", "proc", "pointer", "np", "index", "point", "Ptr", "pr", "ref", "tp", "ts", "jp", "alloc", "rect", "rel", "tr", "pi", "var", "pos", "dep", "err", "cmd", "seek"], "val": ["VAL", "util", "p", "sel", "id", "l", "arr", "it", "loc", "str", "valid", "pt", "slot", "pret", "pol", "ival", " res", "pl", "tx", " ret", "Val", "aval", " el", "el", "data", "crit", "ell", "ret", "mem", " aval", " v", "ref", "len", "rol", "all", "x", "als", "vol", "eval", " eval", "label", "pal", "point", " value", "rel", "alt", "vt", "fail", "elt", "lit", "cho", "v", " var", "prop", "bal", "resp", "il", "trace", "bl", " Val", "pr", "status", " update", "res", "vals", " arg", "test", "update", "lev", "cal", " al", "al", "value", "err"], "section": ["our", "portion", "error", "day", "description", "setting", "slot", "term", "row", "area", "ment", "page", "mod", "event", "journal", "j", "index", "name", "comment", "member", "example", "record", "instance", "part", "header", "behavior", "division", "region", "block", "man", "tab", "action", "entry", "activity", "config", "sections", "address", "reader", "version", "port", "lock", "size", "group", "format", "sector", "state", "feature", "definition", "pool", "pair", "table", "number", "param", "local", "year", "function", "element", "sect", "position", "prefix", "set", "module", "option", "link", "Section", "step", "tag", "status", "line", "side", "job", "global", "service", "test", "se", "second"]}}
{"project": "qemu", "commit_id": "200668ba0839e664f0e4d0bcdc55ab5a163a418a", "target": 0, "func": "void main_loop_wait(int nonblocking)\n\n{\n\n    fd_set rfds, wfds, xfds;\n\n    int ret, nfds;\n\n    struct timeval tv;\n\n    int timeout;\n\n\n\n    if (nonblocking)\n\n        timeout = 0;\n\n    else {\n\n        timeout = qemu_calculate_timeout();\n\n        qemu_bh_update_timeout(&timeout);\n\n    }\n\n\n\n    os_host_main_loop_wait(&timeout);\n\n\n\n    tv.tv_sec = timeout / 1000;\n\n    tv.tv_usec = (timeout % 1000) * 1000;\n\n\n\n    /* poll any events */\n\n    /* XXX: separate device handlers from system ones */\n\n    nfds = -1;\n\n    FD_ZERO(&rfds);\n\n    FD_ZERO(&wfds);\n\n    FD_ZERO(&xfds);\n\n    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);\n\n    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);\n\n    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));\n\n\n\n    qemu_run_all_timers();\n\n\n\n    /* Check bottom-halves last in case any of the earlier events triggered\n\n       them.  */\n\n    qemu_bh_poll();\n\n\n\n}\n", "idx": 4221, "substitutes": {"nonblocking": ["nonusing", " nonusing", " NONblocking", "onblocking", " NONforcing", " nonblock", "anoblock", "nonblock", "Nonblock", "nonblocks", "onforcing", "anoblocks", " NONusing", " nonforcing", "anoblocking", "onusing", "nonforcing", "Nonblocks", "Nonblocking", " nonblocks"], "rfds": ["rfears", "rbns", "fwvs", "rfjs", "rafps", "rafvs", "rfensions", "rafcs", "rafjs", "fwjs", "fgjs", "fwbs", "fwns", "rfns", "rbps", "fwrs", "fgrs", "rbds", "rafd", "rfargs", "cfDS", "rbcs", "fgs", "rfd", "fwDS", "fwears", "rafensions", "rafs", "rfDS", "rbd", "fwensions", "cfs", "cfds", "rafds", "rfbs", "fwds", "rfrs", "rfs", "rfcs", "cfargs", "rfps", "rafrs", "rafDS", "fwcs", "fwargs", "rafns", "fgensions", "rafargs", "fws", "fgargs", "rbrs", "rfvs", "fgears", "rbbs", "rbjs", "rafbs", "fwd", "rafears", "fwps", "fgds", "fgvs"], "wfds": ["wvds", "wrfds", "wxfms", "wrfths", "wufds", "wcfns", "wfonds", "wfwds", "wufonds", "swfns", "wfths", "wvns", "wfns", "wfgds", "awfeds", "wrfuds", "wfwtes", "wfads", "wdfds", "wwtes", "wfwargs", "winufonds", "webfds", "wvDS", "rwxfds", "awfargs", "awfsargs", "ewfuds", "awfseds", "wxfns", "wfwors", "wufads", "wdfrs", "wfors", "winfonds", "wcfrs", "wfsonds", "wcfds", "wfsdds", "wkuds", "wfsys", "wfps", "ewxfuds", "wwps", "wlfps", "winufds", "wlfds", "wfwps", "winfads", "wfrs", "wxftes", "rwfns", "weblfps", "wfsms", "winfdds", "rwxfns", "wdfers", "rwxfers", "wlftes", "wxfargs", "wfdds", "wxfers", "wlfms", "wxfrs", "rwfds", "winufads", "nfms", "wfgads", "wfDS", "webfps", "wrfjs", "wfys", "swxfDS", "swfDS", "wlfDS", "wfwys", "wlfns", "wwds", "wlfors", "wxfths", "wlfys", "wfsuds", "nfstes", "nfsms", "wlfuds", "swxfys", "ewfjs", "wfsds", "wdfns", "wfsads", "rwfrs", "winufdds", "wkths", "wfgdds", "wfargs", "nfsds", "nftes", "awfys", "winfds", "wxfuds", "wfseds", "wfjs", "rwfers", "swxfds", "swfds", "wfeds", "webftes", "wwors", "webfors", "wfstes", "wxfys", "wxfeds", "awfds", "nfsuds", "ewxfths", "wufdds", "ewfths", "ewfds", "wvys", "wfuds", "wfms", "nfuds", "wfsargs", "wfweds", "wfers", "weblftes", "wfgonds", "wxfDS", "awfsys", "wftes", "weblfors", "awfsds", "wkjs", "swfys", "weblfds", "wxfjs", "wxfds", "ewxfjs", "ewxfds", "wcfers", "wkds", "swxfns", "rwxfrs"], "xfds": ["fgards", "fxks", "uffks", "fxdds", "fxrs", "xfards", "fgaults", "fifrs", "xfdays", "uffcs", "fgdays", "cfd", "xfd", "xfcs", "rafcs", "fxcs", "fifeds", "fxds", "cfrs", "fxeds", "xfrs", "xfuds", "fwns", "fbdays", "xfeds", "fwDs", "fwrs", "fifds", "fbaults", "fifdays", "fgrs", "xffcs", "fxuds", "fweds", "fwda", "uffuds", "fxd", "fifda", "cfdds", "cfds", "rafds", "fifns", "fwds", "rafda", "xfDs", "fwdds", "fxards", "rfcs", "fbrs", "rfuds", "fwcs", "xfda", "rfks", "xfns", "rafns", "fifaults", "fgDs", "xfaults", "fgcs", "fbds", "uffds", "fxns", "fifcs", "xffns", "fwards", "xffeds", "fxDs", "fwd", "xffds", "fgds", "xfdds", "xfks"], "ret": ["rc", "t", "inter", "elt", "gt", "reset", "no", "dt", "pert", "tt", "tmp", "success", "RET", "rm", "arg", "nt", "re", "r", "Ret", "it", "ft", "rets", "unt", "val", "j", "rem", "mt", "result", "def", "lt", "resp", "err", "usr", "ref", "status", "iter", "len", "rect", "res", "det", "tr", "flag", " Ret", "ct", "num", "back", "alt", "reply", "rt", "vt", "out", "tn"], "nfds": ["nfids", "nFds", "nlfdays", "nxfdays", "nsfids", "Nxfrs", "Nxfys", "Nfbs", "Nxfods", "ncfx", "ncfids", "nxfids", "nxfns", "nFns", "nfdos", "nxfods", "nxfys", "nfrs", "nfcds", "Nxfbs", "nfsns", " nxfx", "nfdes", "nscfrs", "nxfrs", "nfsrs", "Nxfns", "nfbs", "nbfrs", "nxfx", " nxfrs", "ncfdos", "nferids", "nbfds", " nxfds", "nvods", "nbfods", " nfx", "nbrfds", "nrfods", "nfns", "nbrfrs", "nsfds", "nlfrs", "Nfods", "Nfrs", "Nfns", "nrfds", "Nfys", "nfcbs", "nvdes", "nfys", "nfdays", "nfcrs", "nxfdes", "nfcods", "nxfds", "nscfids", "nrfrs", "Nxfds", "nferds", "nxfbs", "nfsods", "nferrs", "nrfdes", "nfsds", " nxfdays", "nlfds", "ncfrs", "nbrfods", "nFbs", "ncfdays", "nlfx", "nfods", "nsfdos", " nfrs", "nvrs", "nfsbs", "nfsys", "nfx", "ncfds", "nFys", "nvds", "nxfdos", "nscfdos", "nscfds", "nferdos", "Nfds", "nsfrs", "nbfdes", "nbrfdes", " nfdays"], "tv": ["tc", "json", "vp", "html", "dt", "td", "cv", "tmp", "tt", "tf", "poll", "sec", "gov", "v", "news", "tz", "xml", "ev", "txt", "cb", "vv", "watch", "TV", "nr", " v", "pb", "opt", "tp", " TV", "ts", "tg", "volt", "yt", "tm", "qt", "tx", "tk", " t", "rt", "vt", "timer", "event", "tn"], "timeout": ["tc", "json", "capacity", "t", "latest", "total", "max", "dt", "tmp", "tt", "limit", "OUT", "period", "v", "sp", "wait", "it", "policy", "bolt", "error", "duration", "connection", "frequency", "options", "version", "server", "watch", "delay", "course", "resolution", "lock", "option", "time", "attribute", "span", "size", "history", "value", "slot", "type", "scroll", "response", "opt", "buffer", "height", "status", "ts", "print", "range", "seconds", "unit", "service", "sequence", "window", "number", "Timeout", "settings", "n", "directory", "spin", "T", "timer", "out"]}}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "void bdrv_invalidate_cache_all(Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    Error *local_err = NULL;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    while ((it = bdrv_next(it, &bs)) != NULL) {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(aio_context);\n\n        bdrv_invalidate_cache(bs, &local_err);\n\n        aio_context_release(aio_context);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 4253, "substitutes": {"errp": ["arrP", " errnp", "riskp", "eorP", "errpa", "arrping", " errping", "arrnp", " errP", "eorp", " errpa", "arrpa", "riskP", "eorping", "errping", "risknp", "riskpa", "errnp", "arrp", "errP", "eorpa"], "bs": ["ubs", "bn", "lb", "bos", "bps", "ds", "bh", "bi", "bt", "ists", "bm", "aus", "blog", "vs", "ps", "bas", "ics", "ss", "ns", "js", "b", "bb", "BS", "boxes", "pb", "bl", "rs", "gs", "ts", "es", "obs", "bg", "lbs", "ubis", "acs", "bits", "its", "fs", "bis", "bp", "cs", "base", "sb", "as", "bf", "ls", "bsp", "ats", "sys", "bc"], "local_err": [" local_str", "Local_err", "local___rr", "local___err", " local_result", "local_msg", "localErrr", "localmyreason", "Local_rr", "localErmsg", " local_msg", "local_er", "Local_er", "local_rr", "local___msg", "Local_msg", " local_reason", "localmyerr", "localmyer", "localmyrr", " local_er", "localErerr", "localErstr", "local___er", "local_str", "local_result", " local_rr", "local_reason"], "it": ["init", "ait", "t", "p", "lit", "el", "id", "ind", "l", "hit", "r", "pit", "ut", "wait", "IT", "ic", "ul", "q", "ist", "lat", "j", "h", "in", "i", "ip", "ex", "est", "il", "at", "ib", "ir", "iter", "mit", "its", "ert", "itted", "quit", "ed", "iti", "yt", "It", "item", "shot", "ITS", "n", "al", "sit", "out"], "aio_context": ["aio_instance", "aio_object", "aio____object", "aio___context", "aIO_thread", "aIO_client", "aio_status", "aio_client", "aio_handle", "aio_thread", "aible_context", "aible_object", "aio___ctx", "aio___thread", "aio____context", "aio___client", "aio____handle", "aible_config", "aible_handle", "aio____config", "aIO_ctx", "aio_config", "aio___instance", "aio_ctx", "aIO_instance", "aIO_context", "aIO_status", "aio___status"]}}
{"project": "FFmpeg", "commit_id": "ec07efa70012845e8642df67a4a773f510a17088", "target": 1, "func": "static int parse_adaptation_sets(AVFormatContext *s)\n\n{\n\n    WebMDashMuxContext *w = s->priv_data;\n\n    char *p = w->adaptation_sets;\n\n    char *q;\n\n    enum { new_set, parsed_id, parsing_streams } state;\n\n    if (!w->adaptation_sets) {\n\n        av_log(s, AV_LOG_ERROR, \"The 'adaptation_sets' option must be set.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on\n\n    state = new_set;\n\n    while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {\n\n        if (*p == ' ')\n\n            continue;\n\n        else if (state == new_set && !strncmp(p, \"id=\", 3)) {\n\n            void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));\n\n            if (mem == NULL)\n\n                return AVERROR(ENOMEM);\n\n            w->as = mem;\n\n            ++w->nb_as;\n\n            w->as[w->nb_as - 1].nb_streams = 0;\n\n            w->as[w->nb_as - 1].streams = NULL;\n\n            p += 3; // consume \"id=\"\n\n            q = w->as[w->nb_as - 1].id;\n\n            while (*p != ',') *q++ = *p++;\n\n            *q = 0;\n\n            p++;\n\n            state = parsed_id;\n\n        } else if (state == parsed_id && !strncmp(p, \"streams=\", 8)) {\n\n            p += 8; // consume \"streams=\"\n\n            state = parsing_streams;\n\n        } else if (state == parsing_streams) {\n\n            struct AdaptationSet *as = &w->as[w->nb_as - 1];\n\n            q = p;\n\n            while (*q != '\\0' && *q != ',' && *q != ' ') q++;\n\n            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);\n\n            if (as->streams == NULL)\n\n                return AVERROR(ENOMEM);\n\n            as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);\n\n            if (as->streams[as->nb_streams - 1] < 0) return -1;\n\n            if (*q == '\\0') break;\n\n            if (*q == ' ') state = new_set;\n\n            p = ++q;\n\n        } else {\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 4255, "substitutes": {"s": ["t", "os", "S", "conf", "ds", "f", "ms", "v", "r", "ps", "less", "ss", "h", "aws", "comm", "source", "ns", "js", "hs", "b", "sq", "sys", "sts", "sg", "rs", "gs", "Ws", "ts", "es", "m", "fs", "sv", "cs", "c", "sb", "ls", "ats", "z"], "w": ["rew", "t", "util", "th", "wh", "work", "ww", "f", "l", "v", "wx", "rw", "wall", "r", "worker", "wal", "aw", "z", "wa", "words", "weights", "fw", "wp", "lang", "wk", "ew", "saw", "h", "wo", "wt", "word", "history", "ex", "wn", "we", "tw", "wd", "W", "g", "write", "y", "wi", "wl", "nw", "raw", "wr", "etc", "args", "hw", "window", "wat", "var", "x", "workers", "wcs", "kw", "writer", "man", "web", "iw", "wb", "sw"], "p": ["ph", "vp", "pp", "t", "cp", "pkg", "lp", "f", "a", "progress", "d", "l", "v", "sp", "r", "ps", "pc", "ping", "pg", "wp", "ep", "pm", "pa", "pro", "port", "j", "h", "pad", "pt", "dq", "i", "ip", "ap", "b", "np", "par", "point", "g", "pb", "pr", "pers", "peer", "y", "fp", "tp", "perm", "jp", "op", "dp", "pat", "m", "up", "P", "bp", "pi", "part", "pl", "x", "pid", "c", "pod", "pe", "pos", "n", "xp", "u", "pre"], "q": ["pp", "query", "qual", "ch", "pkg", "quality", "qq", "quiet", "f", "d", "vc", "v", "r", "pc", "quant", "Q", "qv", "ping", "pg", "k", "dq", "ue", "h", "qu", "j", "pt", "iq", "eq", "i", "ip", "quote", "requ", "sq", "que", "g", "comment", "e", "m", "quest", "aq", "quit", "qa", "qi", "qt", "c", "queue", "pid", "pe", "qs", "z", "u"], "state": ["key", "commit", "l", "error", "STATE", "only", "stats", "operator", "count", "start", "event", "ace", "no", "progress", "success", "a", "race", "scope", "note", "st", "power", "color", "State", "name", "index", "err", "comment", "stat", "ate", "part", "mode", "action", "states", "debug", "component", "policy", "change", "version", "port", "size", "type", "peer", "command", "process", "print", "e", "m", "te", "pair", "pe", "local", "go", "out", "close", "function", "t", "length", "hash", "position", "val", "set", "style", "option", "section", "role", "trace", "step", "are", "store", "tag", "status", "base", "test", "al", "see", "cache"], "mem": ["lim", "phys", " Mem", "temp", "ll", "bm", "ms", "dim", "sum", "mi", "me", "mp", "em", "sm", "my", "address", "map", "val", "mat", "nm", "buff", "ret", "ap", "mt", "emb", "asm", "il", "memory", "mx", "mn", "mb", "ref", "store", "pool", "alloc", "vm", "m", "raw", "mm", "ram", "im", "tm", "mod", "arm", "cache", "Mem", "tab", "go", "reg", "mc"], "as": ["nos", "vers", "aus", "asi", "mas", "ns", "of", "ma", "las", "marks", "ams", "c", "les", "cas", "aps", "eas", "modules", "nas", "a", "ares", "ps", "bas", "pas", "asha", "js", "As", "ias", "ows", "at", "new", "ts", "ads", "has", "raw", "ase", "all", "ais", "was", "us", "als", "am", "ats", "ab", "sa", "is", "aos", "aw", "ask", "aws", "AS", "ass", "bs", "asm", "rs", "ars", "acs", "jas", "var", "ls", "ags", "asks", "os", "oss", "ess", "ems", "cast", "ras", "ms", "mos", "ast", "an", "buf", "ar", "es", "asers", "names", "ac", "au", "al"], "nb_as": ["nb__aos", "nbplhas", "nb5asi", "n__mas", "nb_ac", "NB__ms", "kB_has", "n_mas", "nb___ras", "nr_as", "nbPras", "n_ras", "nb5as", "NB__as", "nb__as", "nb_aos", "nr_las", "nb__mas", "nb_asi", "n__ids", "nb_ids", "NB_ac", "nbplpas", "kBplpas", "n_as", "NB_as", "nb_ras", "n__as", "n__ras", "kBplasi", "nr_rs", "nb___as", "NB_As", "nb_mas", "nb_asc", "kBplas", "nbPaos", "nb_has", "nr_AS", "nb_ms", "nb__As", "nb__ras", "n_ids", "kBplhas", "nb__ids", "nb5pas", "nb__ms", "nb_As", "kB_as", "nb___AS", "nb___las", "kB_pas", "nb_pas", "nb_rs", "nr_ras", "nbplasi", "nb5has", "nb__rs", "nb_las", "nr_aos", "NB_asc", "NB__As", "NB_ms", "NB_ras", "kB_asi", "nbPas", "nbplas", "nbPrs", "nb_AS"]}}
{"project": "qemu", "commit_id": "e549e7161f37416ff66971d77d021d30057045ca", "target": 1, "func": "static QObject *parse_keyword(JSONParserContext *ctxt)\n\n{\n\n    QObject *token, *ret;\n\n    JSONParserContext saved_ctxt = parser_context_save(ctxt);\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(token) != JSON_KEYWORD) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_keyword(token, \"true\")) {\n\n        ret = QOBJECT(qbool_from_int(true));\n\n    } else if (token_is_keyword(token, \"false\")) {\n\n        ret = QOBJECT(qbool_from_int(false));\n\n\n\n    } else {\n\n        parse_error(ctxt, token, \"invalid keyword `%s'\", token_get_value(token));\n\n        goto out;\n\n    }\n\n\n\n    return ret;\n\n\n\nout: \n\n    parser_context_restore(ctxt, saved_ctxt);\n\n\n\n    return NULL;\n\n}", "idx": 4256, "substitutes": {"ctxt": ["utctx", "mttxt", "ctext", "acttx", "utxt", "cXT", "actext", "actXT", "ctXT", "mttx", "ctect", "actpt", "mtxt", "ctx", "conttx", "ctxtxt", "cxt", "contxt", "curXT", "cttx", "curtxt", "cttxt", "uttx", "ctxext", "contpt", "mtect", "curect", "ctpt", "curxt", "actect", "ctctx", "curtx", "acttxt", "ctxpt", "uttxt", "ctxctx", "curext", "ctxxt", "conttxt", "actctx", "actxt", "ctxtx"], "token": ["key", "scan", "error", "field", "typ", "twitter", "txt", "handle", "TO", "none", "current", "character", "response", "text", "row", "target", "oken", "operator", "final", "interrupted", "user", "KEN", "message", "start", "event", "json", "ski", "no", "resource", "data", "normal", "list", "note", "rule", "tar", "trigger", "kt", "wt", "word", "tower", "termin", "buffer", "tool", "initial", "session", "header", "item", "context", "tn", "reset", "tf", "temp", "component", "piece", "ok", "span", "source", "tree", "input", "type", "pair", "Token", "table", "number", "topic", "local", "t", "element", "spec", "channel", "language", "node", "single", "complete", "info", "iterator", "tag", "document", "variable", "prototype", "atom", "next", "template"], "ret": ["t", "elt", "lit", "gt", "dt", "ll", "RET", "rm", "rot", "cat", "arr", "nt", "re", "att", "cont", "Ret", "it", "ft", "rets", "txt", "unt", "obj", "val", "set", "rem", "mem", "mt", "result", "resp", "def", "lt", "pret", "mb", "rev", "ref", "rest", "print", "jp", "res", "det", "rel", "report", "tr", "ert", "reg", "bool", " Ret", " RET", "flag", "uf", "alt", "rt", "out", "cmd"]}}
{"project": "FFmpeg", "commit_id": "5b29af624fe8be5379fd649019a04ff44bfde04f", "target": 0, "func": "static int aac_encode_frame(AVCodecContext *avctx,\n\n                            uint8_t *frame, int buf_size, void *data)\n\n{\n\n    AACEncContext *s = avctx->priv_data;\n\n    int16_t *samples = s->samples, *samples2, *la;\n\n    ChannelElement *cpe;\n\n    int i, j, chans, tag, start_ch;\n\n    const uint8_t *chan_map = aac_chan_configs[avctx->channels-1];\n\n    int chan_el_counter[4];\n\n    FFPsyWindowInfo windows[AAC_MAX_CHANNELS];\n\n\n\n    if (s->last_frame)\n\n        return 0;\n\n    if (data) {\n\n        if (!s->psypp) {\n\n            memcpy(s->samples + 1024 * avctx->channels, data,\n\n                   1024 * avctx->channels * sizeof(s->samples[0]));\n\n        } else {\n\n            start_ch = 0;\n\n            samples2 = s->samples + 1024 * avctx->channels;\n\n            for (i = 0; i < chan_map[0]; i++) {\n\n                tag = chan_map[i+1];\n\n                chans = tag == TYPE_CPE ? 2 : 1;\n\n                ff_psy_preprocess(s->psypp, (uint16_t*)data + start_ch,\n\n                                  samples2 + start_ch, start_ch, chans);\n\n                start_ch += chans;\n\n            }\n\n        }\n\n    }\n\n    if (!avctx->frame_number) {\n\n        memcpy(s->samples, s->samples + 1024 * avctx->channels,\n\n               1024 * avctx->channels * sizeof(s->samples[0]));\n\n        return 0;\n\n    }\n\n\n\n    start_ch = 0;\n\n    for (i = 0; i < chan_map[0]; i++) {\n\n        FFPsyWindowInfo* wi = windows + start_ch;\n\n        tag      = chan_map[i+1];\n\n        chans    = tag == TYPE_CPE ? 2 : 1;\n\n        cpe      = &s->cpe[i];\n\n        for (j = 0; j < chans; j++) {\n\n            IndividualChannelStream *ics = &cpe->ch[j].ics;\n\n            int k;\n\n            int cur_channel = start_ch + j;\n\n            samples2 = samples + cur_channel;\n\n            la       = samples2 + (448+64) * avctx->channels;\n\n            if (!data)\n\n                la = NULL;\n\n            if (tag == TYPE_LFE) {\n\n                wi[j].window_type[0] = ONLY_LONG_SEQUENCE;\n\n                wi[j].window_shape   = 0;\n\n                wi[j].num_windows    = 1;\n\n                wi[j].grouping[0]    = 1;\n\n            } else {\n\n                wi[j] = ff_psy_suggest_window(&s->psy, samples2, la, cur_channel,\n\n                                              ics->window_sequence[0]);\n\n            }\n\n            ics->window_sequence[1] = ics->window_sequence[0];\n\n            ics->window_sequence[0] = wi[j].window_type[0];\n\n            ics->use_kb_window[1]   = ics->use_kb_window[0];\n\n            ics->use_kb_window[0]   = wi[j].window_shape;\n\n            ics->num_windows        = wi[j].num_windows;\n\n            ics->swb_sizes          = s->psy.bands    [ics->num_windows == 8];\n\n            ics->num_swb            = tag == TYPE_LFE ? 12 : s->psy.num_bands[ics->num_windows == 8];\n\n            for (k = 0; k < ics->num_windows; k++)\n\n                ics->group_len[k] = wi[j].grouping[k];\n\n\n\n            apply_window_and_mdct(avctx, s, &cpe->ch[j], samples2);\n\n        }\n\n        start_ch += chans;\n\n    }\n\n    do {\n\n        int frame_bits;\n\n        init_put_bits(&s->pb, frame, buf_size*8);\n\n        if ((avctx->frame_number & 0xFF)==1 && !(avctx->flags & CODEC_FLAG_BITEXACT))\n\n            put_bitstream_info(avctx, s, LIBAVCODEC_IDENT);\n\n        start_ch = 0;\n\n        memset(chan_el_counter, 0, sizeof(chan_el_counter));\n\n        for (i = 0; i < chan_map[0]; i++) {\n\n            FFPsyWindowInfo* wi = windows + start_ch;\n\n            tag      = chan_map[i+1];\n\n            chans    = tag == TYPE_CPE ? 2 : 1;\n\n            cpe      = &s->cpe[i];\n\n            put_bits(&s->pb, 3, tag);\n\n            put_bits(&s->pb, 4, chan_el_counter[tag]++);\n\n            for (j = 0; j < chans; j++) {\n\n                s->cur_channel = start_ch + j;\n\n                ff_psy_set_band_info(&s->psy, s->cur_channel, cpe->ch[j].coeffs, &wi[j]);\n\n                s->coder->search_for_quantizers(avctx, s, &cpe->ch[j], s->lambda);\n\n            }\n\n            cpe->common_window = 0;\n\n            if (chans > 1\n\n                && wi[0].window_type[0] == wi[1].window_type[0]\n\n                && wi[0].window_shape   == wi[1].window_shape) {\n\n\n\n                cpe->common_window = 1;\n\n                for (j = 0; j < wi[0].num_windows; j++) {\n\n                    if (wi[0].grouping[j] != wi[1].grouping[j]) {\n\n                        cpe->common_window = 0;\n\n                        break;\n\n                    }\n\n                }\n\n            }\n\n            s->cur_channel = start_ch;\n\n            if (cpe->common_window && s->coder->search_for_ms)\n\n                s->coder->search_for_ms(s, cpe, s->lambda);\n\n            adjust_frame_information(s, cpe, chans);\n\n            if (chans == 2) {\n\n                put_bits(&s->pb, 1, cpe->common_window);\n\n                if (cpe->common_window) {\n\n                    put_ics_info(s, &cpe->ch[0].ics);\n\n                    encode_ms_info(&s->pb, cpe);\n\n                }\n\n            }\n\n            for (j = 0; j < chans; j++) {\n\n                s->cur_channel = start_ch + j;\n\n                encode_individual_channel(avctx, s, &cpe->ch[j], cpe->common_window);\n\n            }\n\n            start_ch += chans;\n\n        }\n\n\n\n        frame_bits = put_bits_count(&s->pb);\n\n        if (frame_bits <= 6144 * avctx->channels - 3) {\n\n            s->psy.bitres.bits = frame_bits / avctx->channels;\n\n            break;\n\n        }\n\n\n\n        s->lambda *= avctx->bit_rate * 1024.0f / avctx->sample_rate / frame_bits;\n\n\n\n    } while (1);\n\n\n\n    put_bits(&s->pb, 3, TYPE_END);\n\n    flush_put_bits(&s->pb);\n\n    avctx->frame_bits = put_bits_count(&s->pb);\n\n\n\n    // rate control stuff\n\n    if (!(avctx->flags & CODEC_FLAG_QSCALE)) {\n\n        float ratio = avctx->bit_rate * 1024.0f / avctx->sample_rate / avctx->frame_bits;\n\n        s->lambda *= ratio;\n\n        s->lambda = FFMIN(s->lambda, 65536.f);\n\n    }\n\n\n\n    if (!data)\n\n        s->last_frame = 1;\n\n    memcpy(s->samples, s->samples + 1024 * avctx->channels,\n\n           1024 * avctx->channels * sizeof(s->samples[0]));\n\n    return put_bits_count(&s->pb)>>3;\n\n}\n", "idx": 4260, "substitutes": {"avctx": [" avcontext", "devctl", "wavctx", "ajctl", "ahctl", "afobj", "afcmd", "abctx", "avcv", "avcmd", "avaddr", "ahobj", "avectx", "wavtx", " avcv", "ahaddr", "ahcontext", "ajdoc", "devcontext", "ahdoc", "avpid", "svtx", "abcontext", "afjac", "ajcmd", " avobj", "afctl", "wavcontext", "afctx", "afconf", "afcomp", "ahconf", "ajcv", " avctl", "ajcfg", " avtx", "avctl", "ahctx", "ahjac", "avcontext", "ajobj", "ajtx", "abcv", "ajjac", "AVtx", "afpid", "ajctx", " avconf", "ahtx", "afaddr", "afdoc", "ahcomp", "avjac", "avcfg", "devctx", "abctl", "svcontext", "svctx", "avconf", "AVcontext", "avecfg", "avobj", "ajcontext", "AVctl", "avecontext", "svcmd", "AVctx", "devtx", "ajpid", "afcontext", "ajaddr", "wavctl", "ahpid", "aftx", "avcomp", " avcfg", "avdoc", "ajcomp", "avtx", "aveobj"], "frame": ["fram", "f", "length", "channel", "frames", "image", "fb", "call", "version", "time", "chain", "state", "feature", "Frame", "seed", "fe", "code", "sample", "face", "sequence", "window", "header", "seq", "video", "block", "context", "rame", "event"], "buf_size": ["bufogsize", "bufoglength", "buf_len", "bufogwidth", "buf2width", "buf2size", "buf2len", " buf_width", "buf_width", "bufoglen", "buf_length", "buf2length", " buf_length", " buf_len"], "data": ["tif", "json", "t", "p", "no", "a", "d", "r", "done", "to", "channel", "mu", "image", "media", "error", "DATA", "padding", "any", "str", "valid", "Data", "only", "output", "empty", "dat", "size", "none", "multiple", "format", "value", "bytes", "result", "mat", "name", "info", "buf", "response", "zero", "buffer", "text", "ata", "new", "da", "record", " DATA", "res", "raw", "table", "bool", "window", "bin", "video", "message", "block", "array", "input", "out", "cache", "batch"], "s": ["p", "l", "ains", "ns", "sq", "ses", "gs", "stats", "xs", "comments", "its", "ims", "c", "settings", "n", "qs", "sc", "S", "a", "ps", "ctx", "ins", "vs", "obj", "w", "less", "ss", "h", "changes", "js", "b", "sts", "ts", "ops", "bits", "fs", "args", "sb", "als", "series", "ats", "sys", "states", "tests", "sports", "details", "is", "f", "d", "aws", "bs", "space", "rs", "e", "m", "cs", "as", "ls", "t", "os", "ds", "ms", "v", "spec", "set", "comm", "hs", "g", "es", "actions", "utils", "sv", "parts", "sw"], "samples": ["champles", "examples", "exensions", "ssizes", "Sizes", "testsfaces", "Samples", "nsizes", "camples", "nsents", "sensions", "ispaces", "isannels", "censions", "sfaces", "namples", " samps", "exources", "insizes", "opensamples", "ssamps", "ssumps", "exays", "itsources", "opensences", "isays", "spaces", " sents", " sourses", "Sents", "Samps", "ssources", "tumps", "itsamples", "camps", "Sourses", "ssents", "insents", "nsamples", "opensamps", " sumps", "insamps", "sources", "ssamples", "tamps", "itsanguages", "Sources", "testsamps", "isamples", "sannels", "Sumps", "samps", "examps", "exences", "sumps", "exanguages", "sourses", "isamps", "sents", "sizes", "testsamples", "nources", "testsences", "namps", "exfaces", "opensfaces", "Spaces", "nsamps", "insamples", "Sannels", "tamples", "tourses", "sanguages", " sizes", "sences", "cays", "itsamps", "says", "chources", "chumps", "nanguages", "isensions", "champs"], "samples2": ["Samps102", "samples102", "Samples2", "saves102", "samples256", "SamplesTwo", "Samples256", "Samps256", "saves1", "savesTwo", "samples12", "samples1", "SampsTwo", "Sampst", "Samples12", "Samples102", "samplesTwo", "samps2", "sviews1", "sizes1", "samps12", "samplest", "samps102", "sampst", "sessions12", "samps256", "sviews12", "soundst", "Samplest", "Samps2", "sviews256", "sampsTwo", "sonentsTwo", "sessions1", "sessions256", "Samples1", "sviews2", "samplet", "saves2", "Samps1", "samps1", "sessions2", "Samps12", "sonents102", "sonents1", "sizes2", "sonents2"], "la": ["ka", "elt", "lp", "ea", "l", "lc", "label", "ml", "wa", "lang", "els", "ld", "kl", "layer", "lt", "lag", "da", "ma", "wl", "na", "loop", "lo", "ta", "ls", "lambda", "lis", "lab", "sa"], "cpe": ["pge", "camte", "camke", "cpy", "mcoe", "pcse", "cse", "acke", "ccce", "ccoe", "Cple", "Cope", "mcpe", "cte", "cample", "cce", "cge", " cse", "Cpy", "acpe", "cces", " cuke", "ppe", "campe", " cces", "pope", "pcpe", "acpy", "Cpe", " cce", "mcuke", " cke", "ccpe", "coe", "pces", "mcce", "acope", "pcge", "cuke", "pple", " cge", "pse", "cple", "cope", "acte", "ccuke", "acple", "cke", " cte", " cple", " coe", "ppy", "pcces"], "i": ["key", "p", "id", "l", "ii", "ini", "it", "q", "hi", "di", "gi", "ie", "ma", "y", "ci", "ami", "ims", "qi", "c", "n", "er", " I", "ei", "ch", "ix", "si", "oi", "h", "ji", "b", "index", "name", "at", "zi", "try", "pi", "x", "phi", "series", "ia", "f", "ind", "mi", "io", "ri", "ip", "ex", "point", "multi", "e", "ti", "m", "iii", "ai", "im", "I", "u", "dr", "init", "t", "li", "ki", "bi", "v", "me", "\u0438", "in", "info", "g", "ui", "iu", "ij", "xi", "status", "um"], "j": ["bo", "json", "fr", "ng", "dj", "kh", "p", "ch", "bj", "f", "jj", "v", "l", "ind", "att", "jl", "it", "q", "jc", "obj", "aj", "jo", "h", "br", "o", "next", "ji", "js", "jump", "b", "oj", "g", "ijk", "Ja", "ij", "y", "kj", "jp", "e", "uj", "m", "jas", "ja", "job", "jit", "x", "J", "c", "n", "z", "ev"], "chans": ["achaus", "achants", "cpones", " chaus", "chins", "chnans", "chands", " chanks", "ichanes", "achados", " chats", "chados", "channers", "tchans", " chants", " chanes", "achans", "chaus", "thanes", "shands", " chands", "shados", "cpins", "echanes", "cheats", "tchanes", "chats", "chanks", "tchants", "ichants", "thands", "tchanks", " chados", "cheados", "cheans", "chnados", "echins", "chants", "chanes", "cpanks", "achats", "echands", "cpans", "ichans", "ichaus", "echanks", "shanes", "achands", "chones", "echans", "quanks", "thados", "chnanners", "echats", " channers", "achanes", "echants", "quins", "chnats", "thans", "quones", "shans", "cheanners", "quans", "echones"], "tag": ["key", "t", "Tag", "task", "pkg", "debug", "cat", "token", "col", "label", "hash", "error", "bug", "msg", "prefix", "field", "month", "ag", "prop", "style", "port", "kind", "nick", "attribute", "attr", "word", "format", "mt", "par", "name", "feature", "comment", "car", "term", "date", "type", "tail", "tags", "rat", "product", "match", "code", "stat", "bit", "pair", "flag", "var", "mod", "mot", "cmd", "feat", "brand", "ack", "go", "reg", "TAG"], "start_ch": ["start_col", "Start_ch", "start2ach", "start_ach", " start_channel", "end_Ch", "end_channel", "start___sh", "try_Ch", " start_cho", "Start_chan", "start_sh", " start_col", " start_ach", "start___cell", "start_channel", "start_cell", "start_com", "start2ch", "start_con", "start_Ch", "start_wh", " start_con", " start_chan", "Start_sh", "start___chan", "start_che", "end_chan", "end_ch", "Start_cell", "try_cho", " start_Ch", "start___ch", "start_chan", "try_wh", "start_cho", " start_che", "try_ch", "start2col", "start2chan", " start_com"], "chan_map": ["chan__maps", "channel_table", "chanplMap", "chanpllist", "chanMmap", "chan_Map", "chan_hash", "chan_match", "channel2list", "channel_match", "channel_map", "channel_shape", "chan2shape", "chan_list", "chanMmask", "chanMmatch", "channel_tag", "chan_mask", "chan_tag", "channel2shape", "chan_maps", "channel_list", "channel2map", "chanpltag", "channel_manager", "channel_maps", "channel_hash", "channel_Map", "channel2maps", "chanplmap", "channel_filter", "chan_table", "chan_shape", "chan__list", "channel_cap", "chan_cap", "chan__map", "chan2map", "chan2maps", "chan_filter", "channel_mask", "chan_manager", "chan__shape", "chan2list"], "chan_el_counter": ["chan_el_count", "chan_id_counter", "chan_id_table", "chan_el_table", "chan_id_nr", "chan_el_nr", "chan_id_count"], "windows": ["Window", " hints", "Windows", " wins", "details", "ms", "wx", "vs", "wal", "frames", " wid", " widgets", "holes", "eds", "ks", " queues", "w", "words", "irs", "wo", "aws", "views", "lists", "rows", "mas", "ints", "ows", "we", "blocks", " wires", "boxes", " managers", "keys", "ids", "wid", "images", "res", "win", "window", "workers", "parts", "wcs", "aps", "pages", "qs", "sys"], "wi": ["ei", "wen", "wx", " ni", "wiki", "wic", "mu", "wal", "live", "wit", "hi", "wk", "Wi", "wo", "wei", "igi", "WI", "ye", "xi", "hei", "wid", "nw", "ours", "wr", "wat", "gra", "feat", "xp", "wig"], "ics": ["icks", "ists", "pic", " ic", "cus", "css", "ms", "ips", "ikes", "ic", "ICS", "ks", "cons", "icc", "irs", "bs", "ris", "ns", "ints", "icons", "ts", "xs", "stats", "acs", "fs", "ik", "ices", "its", "cs", "xes", "wcs", "ls", "nic", "qs", "ats", "IC", "mc", "mic", "ico"], "k": ["ka", " K", "key", "K", "ch", "mk", "v", "kid", "q", "ks", "w", "unk", "km", "kt", "kind", "ok", "kl", "ket", "b", "an", "g", "kj", "m", "ik", "c", "tk", "n"]}}
{"project": "FFmpeg", "commit_id": "6a6bc43f5f79587b8936334cc0b3a6616f4807ac", "target": 0, "func": "static int dxtory_decode_v2_420(AVCodecContext *avctx, AVFrame *pic,\n\n                                const uint8_t *src, int src_size)\n\n{\n\n    GetByteContext gb;\n\n    GetBitContext  gb2;\n\n    int nslices, slice, slice_height, ref_slice_height;\n\n    int cur_y, next_y;\n\n    uint32_t off, slice_size;\n\n    uint8_t *Y, *U, *V;\n\n    int ret;\n\n\n\n    bytestream2_init(&gb, src, src_size);\n\n    nslices = bytestream2_get_le16(&gb);\n\n    off = FFALIGN(nslices * 4 + 2, 16);\n\n    if (src_size < off) {\n\n        av_log(avctx, AV_LOG_ERROR, \"no slice data\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!nslices || avctx->height % nslices) {\n\n        avpriv_request_sample(avctx, \"%d slices for %dx%d\", nslices,\n\n                              avctx->width, avctx->height);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    ref_slice_height = avctx->height / nslices;\n\n    if ((avctx->width & 1) || (avctx->height & 1)) {\n\n        avpriv_request_sample(avctx, \"Frame dimensions %dx%d\",\n\n                              avctx->width, avctx->height);\n\n    }\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n\n        return ret;\n\n\n\n    Y = pic->data[0];\n\n    U = pic->data[1];\n\n    V = pic->data[2];\n\n\n\n    cur_y  = 0;\n\n    next_y = ref_slice_height;\n\n    for (slice = 0; slice < nslices; slice++) {\n\n        slice_size   = bytestream2_get_le32(&gb);\n\n        slice_height = (next_y & ~1) - (cur_y & ~1);\n\n        if (slice_size > src_size - off) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"invalid slice size %\"PRIu32\" (only %\"PRIu32\" bytes left)\\n\",\n\n                   slice_size, src_size - off);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (slice_size <= 16) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid slice size %\"PRIu32\"\\n\", slice_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (AV_RL32(src + off) != slice_size - 16) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Slice sizes mismatch: got %\"PRIu32\" instead of %\"PRIu32\"\\n\",\n\n                   AV_RL32(src + off), slice_size - 16);\n\n        }\n\n        init_get_bits(&gb2, src + off + 16, (slice_size - 16) * 8);\n\n        dx2_decode_slice_420(&gb2, avctx->width, slice_height, Y, U, V,\n\n                             pic->linesize[0], pic->linesize[1],\n\n                             pic->linesize[2]);\n\n\n\n        Y += pic->linesize[0] *  slice_height;\n\n        U += pic->linesize[1] * (slice_height >> 1);\n\n        V += pic->linesize[2] * (slice_height >> 1);\n\n        off += slice_size;\n\n        cur_y   = next_y;\n\n        next_y += ref_slice_height;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4306, "substitutes": {"avctx": [" avcontext", "AVcp", "ajctl", "avercv", "abctx", "avcv", "avcmd", " avcmd", "ravctx", "avcpu", "avectx", "averkt", "abcpu", "ajcc", "awctx", "ajcats", "avectl", "avfc", "avetc", "ravcontext", "ajfc", "abcontext", " avcmp", "savcontext", "afjac", "ajcmd", "Avtx", "devjac", "afcpu", "varcmd", "auxcfg", "afctx", "ravjac", "varctx", "savctx", "abtx", "avetx", " avkt", "ajcv", "varctl", " avjac", " avctl", "ajcfg", " avtx", "avecmp", "avercmp", "avctl", "avcp", "avertc", "avcss", "awcpu", "avpkg", "averfc", "avercontext", "avercpu", "avcontext", "ajtx", "devcfg", "avtc", "averctx", "avekt", "Avctx", "varcats", "ajctx", " avconf", "avercmd", "auxctx", "avkt", "ravpkg", "avefc", "auxtx", "ravcpu", "avjac", "avcfg", "devctx", "awcmp", "abctl", "avecp", "AVcmp", "ajkt", "savcss", "awtx", "avecv", "avconf", "afcfg", "avecfg", "ajcontext", "avercss", "avercc", "avecontext", "AVctx", " avcp", "ravcmd", "afcmp", "devtx", "avertx", "avecc", "afcontext", "afpkg", " avpkg", "savcpu", "avcmp", " avcpu", "aftx", "abcmp", "averconf", "avcc", "avercp", "avecats", " avcfg", "Avkt", "avecmd", "abconf", "auxjac", "AVtc", " avcss", "avtx", "avcats", "Avcontext", "ajcp", "avecpu"], "pic": ["phot", "py", "fr", "pick", "doc", "phys", "p", "syn", "sp", "ps", "ctx", "pit", "pc", "image", "mp", "ic", "file", "Pic", "piece", "txt", "Picture", "style", "pa", "sci", "png", "fps", "px", "gc", "photo", "fc", "np", "sys", "pr", "fp", "photos", "jp", "cam", "Pict", "peg", "pi", "parse", "ac", "gif", "shot", "feat", "kit", "picture", "frame", "img", "mic", "pict"], "src": ["ptr", "ur", "rc", "sc", "init", "ser", "tmp", "sp", "ctx", "ins", "cont", "scan", "serv", "inst", "sub", "txt", "obj", "loc", "str", "cur", "sci", "png", "sr", "in", "bs", "source", "fc", "proc", "input", "rs", "bg", "iv", "raw", "sb", "gin", "s", "sys", "sur", "img"], "src_size": ["source_name", "rc_shape", "src_ize", "source_size", "source_len", "rc_size", "rc_SIZE", "src_shape", "sys_Size", "src32ize", "src32Size", "sys_size", "src_Size", "src_len", "src_name", " src_Size", "sys_SIZE", "src_SIZE", " src_len", "src32size", " src_ize"], "gb": ["py", "gm", "fg", "gt", "cv", "nb", "fi", "bt", "bm", "ctx", "pc", "fb", "eg", "hub", "gu", "vt", "gpu", "bd", "cd", "cb", "gc", "buff", "hog", "bs", "gd", "rb", " rg", "rg", "attr", "bb", " rgb", "g", "mb", "Gb", "kb", "gs", "xy", "db", "bg", "tg", "cfg", "GB", "storage", "sv", "args", "eb", "yg", "uf", "sb", "gif", "bf", "gin", "sys", " rc", " GB", "lib", "uv"], "gb2": ["gm2", "cb2", "gb3", "GB1", "GB3", "cb3", "cb5", "cb1", "GB2", "GB5", "gb1", "gb5", "gm5", "gm3", "gm1"], "nslices": ["nsletets", "nslexes", "nsplales", "snluletes", "nslexales", "nslicedes", "NSpersees", "nslicests", "npersees", "nslicletes", "outslicences", "nsciets", "snlicles", "nslames", " nsletices", "nslimales", "nsciales", " nslicets", "nspersees", "snlice", "outslibes", "nlicqs", "NSlicese", "nslamales", "outslibets", " nsciles", "nsseques", " nsletets", "nspersements", "nscilces", "nslice", "nslicences", "nperseqs", " nscilies", "nslicments", "nslicmes", "nscalles", "nsples", "snlicies", "nscilices", "snlicests", "nlicments", "nsseque", "NSlimese", "nlicedes", "nspreadies", "snluies", "nscilmes", "nsitnessmes", "nspreades", "nsletales", "NSpersee", "nsclqs", "nslimies", "nscledes", "nslexies", "NSperseletes", "nsperseqs", " nslicies", "snlues", "nsluies", "nslime", "nsciices", "nspreade", "nslenese", "nscies", "nslicqs", "snlue", "nslibmes", "nscilies", "NSperseers", "nslene", "nssequers", "nspreadletes", "nslexces", "NSlice", " nscilales", "nscles", "nsperseales", "outslibmes", "NSlicales", "nsitnessences", "nsletes", "NSlimales", " nslicces", "nslibences", "nsperseletes", "nslexests", "nscallies", "nsitnesses", "nsple", "nlices", "nsperseles", "nscilets", "nslicers", "outslices", "outslicets", " nsletes", "NSlicletes", "outslibences", "nscilences", "nsperseers", "nslibes", "nsciles", "snlamales", "snlamests", "nsplese", "nperseedes", "npersements", "nslenales", "nslimes", "NSlicers", "nssequletes", "nslicales", "nslinqs", "nslinedes", "snlicales", "nslicese", "nslimese", "nscallces", "nslexles", "nslicets", "snlicletes", "NSlime", " nslicices", "nspersee", "nsclments", "nslibets", "nslues", "nslines", "nslimers", "nsperseedes", "nslamles", "nsluletes", "NSlices", "nslamests", "nsperseests", "nsletices", "NSlimes", "snlames", "outslicmes", " nsletales", "nslicies", "nslue", "nslicces", "nscallales", "snlices", "nsitnessets", "nslinments", "nslimletes", "nslicles", " nscilces", "nslicices", "nslenes", " nslicales", "nscilales", "snlamles"], "slice": ["pose", "save", "share", "limit", "sel", "ind", "volume", "dim", "sp", "length", "spec", "label", "split", "piece", "ask", "sub", "sl", "plot", "single", "sci", "axis", "depth", "lock", "mix", "i", "chain", "ie", "slot", "index", "slave", "shift", "ice", "Sl", "range", "seed", "zero", "second", "perm", "clip", "sample", "face", "late", "crop", "pair", "scale", "cut", "square", "star", "tile", "sequence", "lower", "angle", "series", "pe", "skip", "batch", "se", "sort"], "slice_height": ["slice_length", "slice_distance", " slice_depth", "sample_distance", "slice_depth", " slice_length", "sample_size", "sample_length", "sample_height"], "ref_slice_height": ["ref_slice_window", "ref_tile2depth", "ref_slice2depth", "ref_tile2height", "ref_slice2height", "ref_slice_length", "ref_sample_width", "ref_slice_bottom", "ref_tile_height", "ref_slice2window", "ref_sample_length", "ref_sample_height", "ref_tile_depth", "ref_sample_max", "ref_tile_y", "ref_sample_window", "ref_slice_width", "ref_sample_size", "ref_slice2max", "ref_slice2size", "ref_tile_bottom", "ref_slice_max", "ref_slice_depth", "ref_slice_size", "ref_slice_y", "ref_tile2bottom", "ref_tile2y", "ref_slice2y", "ref_slice2bottom"], "cur_y": ["curTimeoy", "Cur_x", "curTimeyy", "current_hot", "cur_ym", "Cur_y", "current_ym", "cur_oy", " cur_oy", "current_x", "curTimey", "cur____y", "Cur_hot", "cur_yy", "cur_hot", " cur_yy", "cur____yy", "cur____oy", "cur_x", "current_y"], "next_y": ["cur_ny", "next___yt", "cur_yt", "next_ym", " next_ny", "nextJy", "next_ey", " next_Y", "next___y", "next_Y", "cur_ey", "nextJny", " next_ym", " next_ey", "nextJyt", "next___ny", "nextJey", "next_ny", "next___ey", "next_yt"], "off": ["out", " Off", "old", "dev", "no", "tmp", "full", "down", "att", "ow", "length", " pos", " on", "OFF", "it", " offset", "Off", "obj", "offer", "ext", "offset", "fun", "set", "ff", "j", "ok", "o", "pad", "before", "size", "ex", "of", "def", "pres", "shift", "buf", "at", "over", "ref", "new", "now", " coff", "end", "op", "after", "det", "ed", "addr", "offs", "base", "Offset", "on", "aux", " OFF", "from", "original", "kw", "push", "open", "pos", "start", "err", "hand"], "slice_size": ["slice_rate", " slice_length", "slice_sum", "slice_style", "slice1size", "ice_sum", "slice_length", "slice67length", "slice_SIZE", "sample_style", "slice64size", "slice64style", "ice_size", "sample_height", "slice5size", "slice5sum", "slice67rate", "slice1height", "slice1sum", "slice64height", "slice64SIZE", "sample_rate", "ice_height", "slice1set", "slice5height", "slice67size", "sample_length", "ice_set", "slice5set", "slice_set", "sample_SIZE", "slice67SIZE", "sample_size"], "Y": ["Py", "XY", "S", "FY", "X", "Year", "H", "R", "Q", "C", "TY", "YP", "YC", "CH", "D", "B", "A", "F", "W", "Z", "SY", "M", "G", "y", "E", "N", "P", "I", "J", "My", "YY", "OU", "YE", "MY", "T", "YS"], "U": ["UF", "US", "UT", "UC", "S", "MU", "Ut", "X", "Tu", "T", "GU", "CU", "UE", "You", "EU", "C", "SU", "UN", "UL", "LU", "UP", "UV", "UTF", "UR", "F", "UI", "UX", "P", "UD", "UID", "UU", "I", "Lu", "Us", "OU", "u", "Up"], "V": ["VI", "VAL", "S", "X", "T", "VD", "v", "VA", "H", "R", "VOL", "C", "VC", "VB", "Vol", "TV", "VG", "VT", "GV", "UV", "B", "AV", "Vector", "F", "VER", "VR", "M", "G", "VO", "VW", "N", "P", "Va", "CV", "VL", "I", "IV", "VM", "VS"], "ret": ["t", "reset", "elt", "gt", "tf", "progress", "f", "RET", "v", "nt", "re", "r", "cont", "data", "Ret", "it", "not", "ft", "Return", "rets", "txt", "val", "ry", "rem", "mem", "result", "resp", "err", "def", "rev", "ref", "len", "print", "res", "det", "try", "tr", "flag", " Ret", "final", "rt", "back", "alt", "value", "out"]}}
{"project": "FFmpeg", "commit_id": "6ebc7240606e8f1fccd2edbe4ffac150053a16cc", "target": 0, "func": "static int read_sbr_grid(AACContext *ac, SpectralBandReplication *sbr,\n\n                         GetBitContext *gb, SBRData *ch_data)\n\n{\n\n    int i;\n\n    unsigned bs_pointer = 0;\n\n    // frameLengthFlag ? 15 : 16; 960 sample length frames unsupported; this value is numTimeSlots\n\n    int abs_bord_trail = 16;\n\n    int num_rel_lead, num_rel_trail;\n\n    unsigned bs_num_env_old = ch_data->bs_num_env;\n\n\n\n    ch_data->bs_freq_res[0] = ch_data->bs_freq_res[ch_data->bs_num_env];\n\n    ch_data->bs_amp_res = sbr->bs_amp_res_header;\n\n    ch_data->t_env_num_env_old = ch_data->t_env[bs_num_env_old];\n\n\n\n    switch (ch_data->bs_frame_class = get_bits(gb, 2)) {\n\n    case FIXFIX:\n\n        ch_data->bs_num_env                 = 1 << get_bits(gb, 2);\n\n        num_rel_lead                        = ch_data->bs_num_env - 1;\n\n        if (ch_data->bs_num_env == 1)\n\n            ch_data->bs_amp_res = 0;\n\n\n\n        if (ch_data->bs_num_env > 4) {\n\n            av_log(ac->avccontext, AV_LOG_ERROR,\n\n                   \"Invalid bitstream, too many SBR envelopes in FIXFIX type SBR frame: %d\\n\",\n\n                   ch_data->bs_num_env);\n\n            return -1;\n\n        }\n\n\n\n        ch_data->t_env[0]                   = 0;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        abs_bord_trail = (abs_bord_trail + (ch_data->bs_num_env >> 1)) /\n\n                   ch_data->bs_num_env;\n\n        for (i = 0; i < num_rel_lead; i++)\n\n            ch_data->t_env[i + 1] = ch_data->t_env[i] + abs_bord_trail;\n\n\n\n        ch_data->bs_freq_res[1] = get_bits1(gb);\n\n        for (i = 1; i < ch_data->bs_num_env; i++)\n\n            ch_data->bs_freq_res[i + 1] = ch_data->bs_freq_res[1];\n\n        break;\n\n    case FIXVAR:\n\n        abs_bord_trail                     += get_bits(gb, 2);\n\n        num_rel_trail                       = get_bits(gb, 2);\n\n        ch_data->bs_num_env                 = num_rel_trail + 1;\n\n        ch_data->t_env[0]                   = 0;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        for (i = 0; i < num_rel_trail; i++)\n\n            ch_data->t_env[ch_data->bs_num_env - 1 - i] =\n\n                ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;\n\n\n\n        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);\n\n\n\n        for (i = 0; i < ch_data->bs_num_env; i++)\n\n            ch_data->bs_freq_res[ch_data->bs_num_env - i] = get_bits1(gb);\n\n        break;\n\n    case VARFIX:\n\n        ch_data->t_env[0]                   = get_bits(gb, 2);\n\n        num_rel_lead                        = get_bits(gb, 2);\n\n        ch_data->bs_num_env                 = num_rel_lead + 1;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        for (i = 0; i < num_rel_lead; i++)\n\n            ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;\n\n\n\n        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);\n\n\n\n        get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);\n\n        break;\n\n    case VARVAR:\n\n        ch_data->t_env[0]                   = get_bits(gb, 2);\n\n        abs_bord_trail                     += get_bits(gb, 2);\n\n        num_rel_lead                        = get_bits(gb, 2);\n\n        num_rel_trail                       = get_bits(gb, 2);\n\n        ch_data->bs_num_env                 = num_rel_lead + num_rel_trail + 1;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        if (ch_data->bs_num_env > 5) {\n\n            av_log(ac->avccontext, AV_LOG_ERROR,\n\n                   \"Invalid bitstream, too many SBR envelopes in VARVAR type SBR frame: %d\\n\",\n\n                   ch_data->bs_num_env);\n\n            return -1;\n\n        }\n\n\n\n        for (i = 0; i < num_rel_lead; i++)\n\n            ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;\n\n        for (i = 0; i < num_rel_trail; i++)\n\n            ch_data->t_env[ch_data->bs_num_env - 1 - i] =\n\n                ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;\n\n\n\n        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);\n\n\n\n        get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);\n\n        break;\n\n    }\n\n\n\n    if (bs_pointer > ch_data->bs_num_env + 1) {\n\n        av_log(ac->avccontext, AV_LOG_ERROR,\n\n               \"Invalid bitstream, bs_pointer points to a middle noise border outside the time borders table: %d\\n\",\n\n               bs_pointer);\n\n        return -1;\n\n    }\n\n\n\n    ch_data->bs_num_noise = (ch_data->bs_num_env > 1) + 1;\n\n\n\n    ch_data->t_q[0]                     = ch_data->t_env[0];\n\n    ch_data->t_q[ch_data->bs_num_noise] = ch_data->t_env[ch_data->bs_num_env];\n\n    if (ch_data->bs_num_noise > 1) {\n\n        unsigned int idx;\n\n        if (ch_data->bs_frame_class == FIXFIX) {\n\n            idx = ch_data->bs_num_env >> 1;\n\n        } else if (ch_data->bs_frame_class & 1) { // FIXVAR or VARVAR\n\n            idx = ch_data->bs_num_env - FFMAX(bs_pointer - 1, 1);\n\n        } else { // VARFIX\n\n            if (!bs_pointer)\n\n                idx = 1;\n\n            else if (bs_pointer == 1)\n\n                idx = ch_data->bs_num_env - 1;\n\n            else // bs_pointer > 1\n\n                idx = bs_pointer - 1;\n\n        }\n\n        ch_data->t_q[1] = ch_data->t_env[idx];\n\n    }\n\n\n\n    ch_data->e_a[0] = -(ch_data->e_a[1] != bs_num_env_old); // l_APrev\n\n    ch_data->e_a[1] = -1;\n\n    if ((ch_data->bs_frame_class & 1) && bs_pointer) { // FIXVAR or VARVAR and bs_pointer != 0\n\n        ch_data->e_a[1] = ch_data->bs_num_env + 1 - bs_pointer;\n\n    } else if ((ch_data->bs_frame_class == 2) && (bs_pointer > 1)) // VARFIX and bs_pointer > 1\n\n        ch_data->e_a[1] = bs_pointer - 1;\n\n\n\n    return 0;\n\n}\n", "idx": 4307, "substitutes": {"ac": ["tc", "mc", "ace", "cu", "et", "jac", "sac", "ach", "fac", "iac", "att", "Ac", "acer", "pc", "ad", "ic", "ag", "aci", "cc", "aic", "ica", "fc", "anc", "ap", "rac", "mac", "act", "at", "apt", "acc", "acs", "AC", "acl", "cs", "ct", "bc", "ak", "c", "am", "oc", "pac", "ab", "mic"], "sbr": ["sbre", "jshr", "asbr", "sbc", " sbc", "jsbr", "spr", "ssbre", "assbc", " shr", "asbc", " spr", "jsBR", "ssBR", "asspr", "jsbre", "shr", "asBR", "sshr", "assBR", " sBR", "ssbr", "aspr", "assbr", "sBR", " sbre"], "gb": ["py", "gm", "bn", "ch", "bm", "ha", "fb", "eg", "hub", "pg", "gu", "vg", "cb", "gc", "gy", "gio", "rb", "gd", "rg", "bytes", "gram", "bb", "g", "pb", "mb", "sg", "kb", "gs", "Gb", "gh", "gnu", "vm", "xy", "db", "bg", "tg", "cfg", "gg", "GB", "storage", "eb", "args", "yg", "csv", "tm", "sb", "gif", "nb", "img", "bc", "wb"], "ch_data": ["ech2data", "ch2dat", "ch_da", "ach_name", "ach_defined", "ch_result", "ach_info", " chtdat", "ch_builder", "ch_block", " chtata", "chptData", "cheartydat", "ch3dev", "changedinfo", "chartytable", "ch2device", "change_info", "cholydata", "chan_div", "ach2data", "chtda", "ach_data", " chtresult", "chptinfo", "chan_data", " chttable", "ch_cache", "ch5defined", "chMDATA", "ch2data", "cheartydata", "ach_dev", "ech2ata", "chtclient", "ch___dat", " ch_table", "chn_dat", " chtdata", "ch1data", "ch_table", "chptclient", " chtresults", "chtdef", "ch8device", "changeddat", "ch2module", "ch2cache", "chtsession", "achtata", "ch1da", "change_entry", "ech_data", "ach2ata", "ch_db", "chtentry", "chptcache", "ch_window", "chttable", "ch_dat", "ch2bin", "che_info", "ch2ata", "cheartyinfo", "chptdat", "ach_db", "ch___block", "chtptbuilder", "ch2DATA", "ech_da", "chtdat", "ch8dev", " chmdata", " ch_dat", "chartyata", "chdinfo", "ch1client", "ch_entry", "ch3device", "ch0client", "chdentry", "chptconnection", " ch2module", "chartyname", "chtwindow", "chtresult", "ach_ata", "chtdata", "cht_Data", "chn_bin", "ch2da", "ach2defined", " chmdat", "chtptData", "achtdata", "ch5ata", "chanptdiv", "form_data", "che_def", "chartptinfo", "change_data", "chart_info", "cht_DATA", "chtname", "ch8cache", "ch_info", "ch_device", " ch2DATA", "ch_bin", " ch2data", "ch_def", "chtptdata", "chMmodule", "chartptdata", "chn_den", "chn_data", "ech_Data", "ach_dat", "ch8connection", " ch_block", "chtinfo", "chtptda", "ech_connection", "cholydat", "ch_lan", " ch_window", "ch_den", "ch2den", "ch1ata", "changedentry", "cht_builder", " ch_result", "ch8data", "ch3data", " chmdevice", " ch_device", "ch_defined", "ch_Data", "ch_ata", " ch_results", "chanptdata", "ach2dat", "cht_data", "ch_name", "ch_dev", "ch1div", "ach2lan", "form_ata", "ch1dat", "ch2defined", "chtden", "ch0data", "ch2table", "ch_results", "ch2window", "chMdata", "chart_session", "achtname", "chddat", "chanptclient", "chptda", "chptbuilder", " ch_name", "chptdata", " ch_ata", "chptsession", "cht_da", "ach_table", "chptname", "ch1name", "chtresults", "chmdevice", "ch0da", "che_dat", "ch0DATA", "ch_connection", " ch_db", "ch8ata", "chan_client", "ach_device", "cheartydef", "chn_cache", "ech2dat", "chartyinfo", "chartydat", "ch_module", "cholyinfo", "ch___db", "change_dat", "ch___data", "chmdat", "form_device", "ach_lan", " chtname", "chn_window", "chtDATA", "chartydata", "ch_client", "cholydb", "ach2table", "ch5data", "chartydef", "che_data", "chart_data", "ch2Data", "chtata", "achtdat", " chtwindow", "ch_session", "chptdiv", "changeddata", "cht_client", "ch1Data", " ch_module", "ch2lan", "ch5dat", "chmdata", "chptata", "ch_DATA", "ech_dat", "ech_cache", "chddata", "chartptsession", "ech2Data", "ech_ata", "ch_div", " ch_DATA", "ech2da"], "i": [" m", " I", "t", "li", "ski", "ei", " multi", "sim", "ki", "bi", "ind", "ii", " ni", "ini", "mi", "ix", " bi", " pi", "me", "it", "ic", "parent", "q", "\u0438", " x", "hi", "uri", " e", "si", "oi", "di", "j", "gi", "span", "in", "ji", "ip", " li", "index", "point", "g", " v", "multi", "ui", "iu", "xi", "y", "ij", "zi", "status", "PI", " ti", "ti", "ci", "m", "print", "ami", "ai", "pi", " j", "im", " mi", "x", "I", "ims", "phi", "cli", "us", "qi", "er", "u", " ii", "batch"], "num_rel_lead": ["num_ref_leader", "num_rel_fac", "num_rel_tail", "num_rel__lead", "num_reloothLead", "num_reloothleader", "num_rel_Lead", "num_rel___lead", "num_rel___Lead", "num_rel__Lead", "num_ref_lead", "num_rel_shift", "num_rel__leader", "num_ref_Lead", "num_rel__fac", "num_reloothfac", "num_rel___leader", "num_ref_tail", "num_rel_leader", "num_reloothlead", "num_ref_fac", "num_rel__tail", "num_rel___shift"], "num_rel_trail": ["num_rel_tril", "num_rel__profiling", "num_rel__profile", "num_rel_trile", "num_rel_Trailing", "num_rel__traile", "num_rel_Traile", "num_rel__traill", "num_rel_profiling", "num_rel__profill", "num_rel__trailing", "num_rel_Trail", "num_rel_Traill", "num_rel_profil", "num_rel_trill", "num_rel_traill", "num_rel_profill", "num_rel_traile", "num_rel__trail", "num_rel__profil", "num_rel_triling", "num_rel_trailing", "num_rel_profile"]}}
{"project": "qemu", "commit_id": "45b339b18c660eb85af2ba25bfcaed5469660d77", "target": 0, "func": "static int uhci_complete_td(UHCIState *s, UHCI_TD *td, UHCIAsync *async, uint32_t *int_mask)\n\n{\n\n    int len = 0, max_len, err, ret;\n\n    uint8_t pid;\n\n\n\n    max_len = ((td->token >> 21) + 1) & 0x7ff;\n\n    pid = td->token & 0xff;\n\n\n\n    ret = async->packet.result;\n\n\n\n    if (td->ctrl & TD_CTRL_IOS)\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n\n\n    if (ret < 0)\n\n        goto out;\n\n\n\n    len = async->packet.result;\n\n    td->ctrl = (td->ctrl & ~0x7ff) | ((len - 1) & 0x7ff);\n\n\n\n    /* The NAK bit may have been set by a previous frame, so clear it\n\n       here.  The docs are somewhat unclear, but win2k relies on this\n\n       behavior.  */\n\n    td->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK);\n\n    if (td->ctrl & TD_CTRL_IOC)\n\n        *int_mask |= 0x01;\n\n\n\n    if (pid == USB_TOKEN_IN) {\n\n        if (len > max_len) {\n\n            ret = USB_RET_BABBLE;\n\n            goto out;\n\n        }\n\n\n\n        if ((td->ctrl & TD_CTRL_SPD) && len < max_len) {\n\n            *int_mask |= 0x02;\n\n            /* short packet: do not update QH */\n\n            trace_usb_uhci_packet_complete_shortxfer(async->queue->token,\n\n                                                    async->td);\n\n            return TD_RESULT_NEXT_QH;\n\n        }\n\n    }\n\n\n\n    /* success */\n\n    trace_usb_uhci_packet_complete_success(async->queue->token, async->td);\n\n    return TD_RESULT_COMPLETE;\n\n\n\nout:\n\n    /*\n\n     * We should not do any further processing on a queue with errors!\n\n     * This is esp. important for bulk endpoints with pipelining enabled\n\n     * (redirection to a real USB device), where we must cancel all the\n\n     * transfers after this one so that:\n\n     * 1) If they've completed already, they are not processed further\n\n     *    causing more stalls, originating from the same failed transfer\n\n     * 2) If still in flight, they are cancelled before the guest does\n\n     *    a clear stall, otherwise the guest and device can loose sync!\n\n     */\n\n    while (!QTAILQ_EMPTY(&async->queue->asyncs)) {\n\n        UHCIAsync *as = QTAILQ_FIRST(&async->queue->asyncs);\n\n        uhci_async_unlink(as);\n\n        uhci_async_cancel(as);\n\n    }\n\n\n\n    switch(ret) {\n\n    case USB_RET_STALL:\n\n        td->ctrl |= TD_CTRL_STALL;\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n        s->status |= UHCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        trace_usb_uhci_packet_complete_stall(async->queue->token, async->td);\n\n        return TD_RESULT_NEXT_QH;\n\n\n\n    case USB_RET_BABBLE:\n\n        td->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL;\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n        s->status |= UHCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        /* frame interrupted */\n\n        trace_usb_uhci_packet_complete_babble(async->queue->token, async->td);\n\n        return TD_RESULT_STOP_FRAME;\n\n\n\n    case USB_RET_NAK:\n\n        td->ctrl |= TD_CTRL_NAK;\n\n        if (pid == USB_TOKEN_SETUP)\n\n            break;\n\n        return TD_RESULT_NEXT_QH;\n\n\n\n    case USB_RET_IOERROR:\n\n    case USB_RET_NODEV:\n\n    default:\n\n\tbreak;\n\n    }\n\n\n\n    /* Retry the TD if error count is not zero */\n\n\n\n    td->ctrl |= TD_CTRL_TIMEOUT;\n\n    err = (td->ctrl >> TD_CTRL_ERROR_SHIFT) & 3;\n\n    if (err != 0) {\n\n        err--;\n\n        if (err == 0) {\n\n            td->ctrl &= ~TD_CTRL_ACTIVE;\n\n            s->status |= UHCI_STS_USBERR;\n\n            if (td->ctrl & TD_CTRL_IOC)\n\n                *int_mask |= 0x01;\n\n            uhci_update_irq(s);\n\n            trace_usb_uhci_packet_complete_error(async->queue->token,\n\n                                                 async->td);\n\n        }\n\n    }\n\n    td->ctrl = (td->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) |\n\n        (err << TD_CTRL_ERROR_SHIFT);\n\n    return TD_RESULT_NEXT_QH;\n\n}\n", "idx": 4315, "substitutes": {"s": ["t", "os", "S", "p", "ds", "is", "d", "v", "ps", "w", "set", "ss", "self", "h", "st", "bs", "ns", "ssl", "ses", "sts", "sg", "rs", "gs", "ts", "stat", "stats", "fs", "sv", "sb", "c", "ls", "n", "sys", "sw", "states"], "td": ["tc", "tif", "hd", "t", "elt", "dev", "gt", "dt", "th", "tf", "ds", "tmp", "od", "TD", "d", "ind", "att", "nt", "pc", "ad", "fd", "dd", "cd", "edd", "txt", "bd", "typ", "ld", "ud", "pad", "dl", "pt", "dat", "dn", "sd", "dh", "ht", "ssl", "lt", "cot", "def", "md", "pb", "tag", "tp", "ts", "pd", "db", "tg", "det", "tr", "dad", "rd", "disc", "dll", "table", "desc", "nd", "cmd", "tk", "cod", "ctl", "tl", "tn"], "async": ["asspc", "raspc", "rasyn", "assyn", "ASynchronous", "ASsync", "syn", "jasynchronous", "astercs", "assynchronous", "Asynchronous", "ascore", "rasynchronous", " asdule", "maskie", "ascs", "lassync", " asynchronous", "sync", "ASyn", " asyn", "lasyn", "askie", "masynchronous", "massync", "jasynchron", "lasync", "asteryn", "Assync", "ssync", "rasync", "asssync", " asynchron", "masdule", "jaskie", "asterynchronous", "assync", "rascore", "asdule", "asynchron", "asyn", "asynchronous", "jasync", " askie", "Aspc", "aspc", " assync", "Asdule", "AScore", "Ascs", " ascs", "masynchron", "masync", "synchronous", "asterync", "lasynchronous", "ASync", "Ascore", "Async", "Asyn"], "int_mask": ["int__flag", "inter_Mask", "int_filter", "alt_batch", "int8flag", "int8mask", "alt_mask", "int00mask", "intitymask", "int_flag", "Int_filter", "alt_filter", "alt_ma", "int__Mask", "int_Mask", "int_ma", "int_batch", "int00const", "int00filter", "Int_const", "Int_ask", "int__mask", "intityma", "int_ask", "int00ask", "Int_mask", "inter_flag", "int8Mask", "inter_mask", "intitybatch", "intityfilter", "int_const"], "max_len": ["max_en", "main_en", " max_en", "inv_length", "Max_en", "inv_lon", "Max_len", "max_lf", "main11en", "max2en", "main11len", "max_length", "max_Len", "max11en", "max11ll", "max_ll", " max_Len", "main11lon", "main_lon", "inv_lf", "max2Len", "main_len", "Max_length", "main_ll", "max2len", "max11lon", "max_lon", "inv_len", "main11ll", "max11len", " max_length", "Max_Len", "max2length"], "err": ["fr", "rc", "init", "elt", "ch", "inner", "progress", "lp", "ind", "arr", "r", "rr", "oe", "error", "msg", "cb", "cert", "str", "attr", "proc", "resp", "rev", "ner", "rs", "iter", "cmp", "res", "er"], "ret": ["deg", "rc", "t", "rep", "reset", "elt", "gt", "dt", "lit", "tmp", "tf", "ll", "RET", "rm", "rot", "cat", "arr", "nt", "re", "cont", "att", "Ret", "fin", "sent", "ft", "rets", "txt", "red", "val", "ld", "prot", "rem", "mem", "mt", "result", "resp", "def", "lt", "pret", "rev", "tail", "ref", "len", "repl", "code", "status", "res", "tr", "flag", "bool", "test", "uf", "tech", "del", "alt", "nl", "reply", "rt", "out"], "pid": ["os", " PID", "p", "elt", "pkg", "ds", "id", "bid", "sp", "token", "ps", " pos", "thread", "ctx", "pc", "fin", "fd", "ping", "typ", "phy", "pa", " p", "vid", "port", "pt", "proc", "po", "state", "sid", "mn", " pc", "type", "pr", "mid", "status", " fid", "tp", "len", "pat", "pin", " sid", "iat", "pri", "base", "pi", "part", "uid", "phi", " pend", "oid", "pe", "pos", "sys", "pan", " tid"], "as": ["nas", "os", "oss", "asp", "is", "a", "ras", "ms", "mes", "aos", "ask", "pas", "sam", "pa", "or", "ast", "AS", "ass", "bs", "js", "As", "ap", "ias", "an", "rs", "ma", "ars", "las", "ar", "jas", "acs", "ase", "ais", "cs", "ac", "was", "us", " es", "am", "asks", "ab", "sa"]}}
{"project": "qemu", "commit_id": "9d27abd94fe2c48281a77112d58422b392a80f7b", "target": 0, "func": "static void cpu_x86_dump_state(FILE *f)\n\n{\n\n    int eflags;\n\n    char cc_op_name[32];\n\n    eflags = cc_table[CC_OP].compute_all();\n\n    eflags |= (DF & DF_MASK);\n\n    if ((unsigned)env->cc_op < CC_OP_NB)\n\n        strcpy(cc_op_name, cc_op_str[env->cc_op]);\n\n    else\n\n        snprintf(cc_op_name, sizeof(cc_op_name), \"[%d]\", env->cc_op);\n\n    fprintf(f, \n\n            \"EAX=%08x EBX=%08X ECX=%08x EDX=%08x\\n\"\n\n            \"ESI=%08x EDI=%08X EBP=%08x ESP=%08x\\n\"\n\n            \"CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\\n\"\n\n            \"EIP=%08x\\n\",\n\n            env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], \n\n            env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], \n\n            env->cc_src, env->cc_dst, cc_op_name,\n\n            eflags & DF_MASK ? 'D' : '-',\n\n            eflags & CC_O ? 'O' : '-',\n\n            eflags & CC_S ? 'S' : '-',\n\n            eflags & CC_Z ? 'Z' : '-',\n\n            eflags & CC_A ? 'A' : '-',\n\n            eflags & CC_P ? 'P' : '-',\n\n            eflags & CC_C ? 'C' : '-',\n\n            env->eip);\n\n#if 1\n\n    fprintf(f, \"ST0=%f ST1=%f ST2=%f ST3=%f\\n\", \n\n            (double)ST0, (double)ST1, (double)ST(2), (double)ST(3));\n\n#endif\n\n}\n", "idx": 4337, "substitutes": {"f": ["df", "fr", "t", "p", "fn", "fi", "tf", "d", "fm", "v", "r", "fb", "fd", "file", "q", "fw", "w", "ff", "sf", "h", "o", "fc", "fa", "b", "F", "g", "rf", "fp", "cf", "e", "fs", "uf", "c", "n", "z", "u"], "eflags": ["EFlages", "erelags", "efglains", "eflains", "eflsatches", "eflcods", "eblsaps", "eflsugs", "embedlags", "efklats", "eflsages", "eblaves", "eblugs", "epslills", "efklages", "epslags", "eflems", "reflags", "reflig", "efklig", "efmlangs", "eflenasks", "eflinks", "efklagn", "eflagged", "efmlinks", "efrlags", "erelsags", "eblaps", "efflags", "EFlods", "eblsugs", "efflages", "embedlems", "eblatts", "efllugs", "eflages", "epsliills", "eflugs", "eadlenags", "efliats", "efslats", "eflaks", "efmods", "ethlenasks", "eflisags", "efllags", "eadlags", "efylags", "embedlenags", "eflnags", "efleninks", "eflcages", "efglages", "erelsills", "eflsills", "refklig", "eblsages", "efmlars", "eflsains", "efflaps", "epsliars", "efliagged", "refklats", "efliagn", "refklags", "ethlugs", "efylagged", "efslig", "efliills", "alfylagged", "eflisugs", "eflisains", "ethlains", "epsliags", "eflagn", "embedlenems", "efmages", "eblages", "eflenugs", "eflsems", "eadlenugs", "efliags", "efflugs", "EFmods", "erelaks", "erelsaks", "efrlaps", "eadlains", "epslars", "alflags", "embedleninks", "reflats", "eadlenains", "efglasks", "efglugs", "eflig", "efliaps", "eflars", "efllasks", "eftlods", "eflenains", "efliars", "eflats", "eflatts", "erelages", "eflcatts", "alflagged", "ethlenags", "eflsinks", "eflods", "efylages", "eblsags", "efllains", "eflaves", "eflenangs", "eflonds", "efrlugs", "eftlages", "ebliaves", "eblagn", "efslags", "ethlenugs", "efylaps", "eflnatts", "alfylaps", "refklages", "EFmatts", "efglags", "eadlatches", "ebliatts", "eflills", "efliatts", "efflagged", "ethlasks", "eflenags", "alfylages", "eflsaps", "efrlages", "efmlills", "eflsangs", "embedlinks", "eflaps", "eflcags", "eflisatches", "eadlenatches", "efmags", "efklatts", "eflionds", "efliages", "efslages", "embedlangs", "eflenatches", "efklaves", "epslionds", "efmatts", "EFmags", "eflnagn", "alflages", "efmlems", "eflangs", "erelsages", "alflaps", "eblags", "efliig", "eflenems", "ebliags", "eftlags", "eflasks", "eflnaves", "EFmages", "reflages", "efmlags", "eflatches", "alfylags", "eflsags", "efglills", "embedlenangs", "efmlonds", "eadlugs", "ethlenains", "EFlatts", "efglaks", "eflsaks", "efliaves", "eftlatts", "epslonds", "efklags", "erelills", "ethlags", "ebliagn", "EFlags"], "cc_op_name": ["cc_oper_Name", "cc_op___names", "cc_op__names", "cc_op_no", "cc_op2name", "cc_oper_str", "cc_op___desc", "cc_oper_name", "cc_op_desc", "cc_op_names", "cc_var_name", "cc_op__name", "cc_op___name", "cc_op2names", "cc_op2type", "cc_OP_name", "cc_op_string", "cc_OP_str", "cc_op_type", "cc_op_code", "cc_op__type", "cc_var2name", "cc_op___str", "cc_var2names", "cc_op___no", "cc_op_Name", "cc_var_type", "cc_OP_type", "cc_op___Name", "cc_var2type", "cc_op_str", "cc_op___type", "cc_var_names", "cc_OP_no"]}}
{"project": "FFmpeg", "commit_id": "612ecfbbbb3f4238d44cca5f250ffc6147d03ec2", "target": 0, "func": "static int gif_read_image(GifState *s)\n\n{\n\n    int left, top, width, height, bits_per_pixel, code_size, flags;\n\n    int is_interleaved, has_local_palette, y, pass, y1, linesize, n, i;\n\n    uint8_t *ptr, *spal, *palette, *ptr1;\n\n\n\n    left = bytestream_get_le16(&s->bytestream);\n\n    top = bytestream_get_le16(&s->bytestream);\n\n    width = bytestream_get_le16(&s->bytestream);\n\n    height = bytestream_get_le16(&s->bytestream);\n\n    flags = bytestream_get_byte(&s->bytestream);\n\n    is_interleaved = flags & 0x40;\n\n    has_local_palette = flags & 0x80;\n\n    bits_per_pixel = (flags & 0x07) + 1;\n\n\n\n    av_dlog(s->avctx, \"image x=%d y=%d w=%d h=%d\\n\", left, top, width, height);\n\n\n\n    if (has_local_palette) {\n\n        bytestream_get_buffer(&s->bytestream, s->local_palette, 3 * (1 << bits_per_pixel));\n\n        palette = s->local_palette;\n\n    } else {\n\n        palette = s->global_palette;\n\n        bits_per_pixel = s->bits_per_pixel;\n\n    }\n\n\n\n    /* verify that all the image is inside the screen dimensions */\n\n    if (left + width > s->screen_width ||\n\n        top + height > s->screen_height)\n\n        return AVERROR(EINVAL);\n\n\n\n    /* build the palette */\n\n    n = (1 << bits_per_pixel);\n\n    spal = palette;\n\n    for(i = 0; i < n; i++) {\n\n        s->image_palette[i] = (0xffu << 24) | AV_RB24(spal);\n\n        spal += 3;\n\n    }\n\n    for(; i < 256; i++)\n\n        s->image_palette[i] = (0xffu << 24);\n\n    /* handle transparency */\n\n    if (s->transparent_color_index >= 0)\n\n        s->image_palette[s->transparent_color_index] = 0;\n\n\n\n    /* now get the image data */\n\n    code_size = bytestream_get_byte(&s->bytestream);\n\n    ff_lzw_decode_init(s->lzw, code_size, s->bytestream,\n\n                       s->bytestream_end - s->bytestream, FF_LZW_GIF);\n\n\n\n    /* read all the image */\n\n    linesize = s->picture.linesize[0];\n\n    ptr1 = s->picture.data[0] + top * linesize + left;\n\n    ptr = ptr1;\n\n    pass = 0;\n\n    y1 = 0;\n\n    for (y = 0; y < height; y++) {\n\n        ff_lzw_decode(s->lzw, ptr, width);\n\n        if (is_interleaved) {\n\n            switch(pass) {\n\n            default:\n\n            case 0:\n\n            case 1:\n\n                y1 += 8;\n\n                ptr += linesize * 8;\n\n                if (y1 >= height) {\n\n                    y1 = pass ? 2 : 4;\n\n                    ptr = ptr1 + linesize * y1;\n\n                    pass++;\n\n                }\n\n                break;\n\n            case 2:\n\n                y1 += 4;\n\n                ptr += linesize * 4;\n\n                if (y1 >= height) {\n\n                    y1 = 1;\n\n                    ptr = ptr1 + linesize;\n\n                    pass++;\n\n                }\n\n                break;\n\n            case 3:\n\n                y1 += 2;\n\n                ptr += linesize * 2;\n\n                break;\n\n            }\n\n        } else {\n\n            ptr += linesize;\n\n        }\n\n    }\n\n    /* read the garbage data until end marker is found */\n\n    ff_lzw_decode_tail(s->lzw);\n\n    s->bytestream = ff_lzw_cur_ptr(s->lzw);\n\n    return 0;\n\n}\n", "idx": 4341, "substitutes": {"s": ["p", "conf", "l", "sl", "ns", "ses", "gs", "stats", "comments", "its", "ims", "ants", "settings", "qs", "S", "a", "ps", "vs", "ins", "serv", "obj", "w", "less", "ss", "h", "tes", "changes", "js", "b", "sts", "ts", "ops", "stat", "fs", "sis", "session", "sb", "als", "ats", "sys", "states", "sports", "details", "is", "ports", "aws", "bs", "ex", "rs", "m", "bis", "cs", "as", "ls", "t", "os", "ds", "ms", "spec", "set", "comm", "hs", "rates", "status", "es", "sv", "parts", "params", "sw"], "top": ["t", "html", "Top", "upper", "there", "origin", "high", "to", "parent", "position", "my", "typ", "offset", "lat", "lon", "pt", "size", "center", "tops", "TOP", "current", "tp", "bot", "tool", "clip", "best", "op", "target", "bottom", "table", "lower", "part", "title", "x", "on", "client", "hop", "above", "user", "localhost", "public", "widget"], "height": ["capacity", "created", "through", "html", "host", "ch", "wh", "ty", "high", "volume", "length", "inches", "hash", "density", "padding", "resolution", "version", "style", "era", "h", "depth", "build", "he", "rows", "size", "chain", "history", "ht", "ows", "Height", "available", "gh", "range", "rank", "bottom", "radius", "bits", "headers", "window", "x", "count", "above", "sky", "shape", "hang"], "bits_per_pixel": ["bits_PER_pixel", "bits_peripblock", "bits_Per_Pixel", "bits_per__page", "bits_per___page", "bits_lastipbyte", "bits_per_Pixel", "bits_Per_page", "bits_per_char", "bits_per___byte", "bits_lastipblock", "bits_last_pixel", "bits_per__component", "bits_perippixel", "bits_last_byte", "bits_perJpixel", "bits_per_page", "bits_per__Pixel", "bits_last_block", "bits_per_px", "bits_per___Pixel", "bits_per_frame", "bits_PER_byte", "bits_PER_component", "bits_per_byte", "bits_per___pixel", "bits_per__pixel", "bits_per_block", "bits_last_frame", "bits_Per_byte", "bits_per__byte", "bits_Per_pixel", "bits_peripframe", "bits_perJpx", "bits_per_component", "bits_perJpage", "bits_lastipframe", "bits_peripbyte", "bits_PER_px", "bits_lastippixel", "bits_PER_char", "bits_PER_page"], "code_size": ["code2Size", "code5no", "code_Size", "image_year", "code2type", "code_no", "code5type", "image_type", "code2size", "code5Size", "code_type", "code_year", "code2no", "image_no", "image_Size", "code5size", "image_size"], "flags": ["grades", "quality", "details", "properties", "times", "atts", "types", "planes", "words", "locks", "options", "groups", "fields", "missions", "ports", "pins", "kind", "events", "units", "lists", "levels", "Flags", "styles", "format", "lag", "rates", "heads", "limits", "tags", "products", "keys", "status", "ts", "faces", "ops", "stats", "reports", "members", "actions", "lines", "vals", "bits", "fs", "flag", "features", "args", "cs", "comments", "bugs", "mask", "ants", "settings", "aps", "ats", "acts", "weights", "ags", "states"], "is_interleaved": ["is_interlineaving", "is_intbleaved", "is_interleave", "is_interleaded", "is_intladed", "is_interlaved", "is_interleaves", "is_interpleaves", "is_interpleave", "is_interlaving", "is_intlaved", "is_intbleaves", "is_interladed", "is_interlaves", "is_intbleave", "is_interbleave", "is_interoleaded", "is_intleaded", "is_intleaves", "is_interbleaving", "is_interpleaving", "is_intlaving", "is_interoleaving", "is_interlineaded", "is_interleaving", "is_intlave", "is_intleaved", "is_interlineave", "is_intleaving", "is_intleave", "is_interlineaved", "is_intbleaving", "is_interbleaved", "is_interoleaved", "is_interpleaved", "is_interbleaves", "is_interoleave", "is_interlave"], "has_local_palette": ["has_local_pixelte", "has_local_palte", "has_local_palet", "has_local_Palet", "has_local_allete", "has_local_alette", "has_local_calettes", "has_local_calette", "has_local_pixelette", "has_local_pallete", "has_local_callete", "has_local_pixelme", "has_local_calme", "has_local_palettes", "has_local_calet", "has_local_Pallete", "has_local_alme", "has_local_pixelettes", "has_local_alte", "has_local_palme", "has_local_Palette", "has_local_Palettes", "has_local_alettes", "has_local_alet"], "y": ["py", "t", "p", "yi", "ch", "dy", "l", "ym", "j", "yo", "h", "ys", "gy", "ye", "b", "ey", "Y", "scroll", "ny", "xy", "e", "m", "yp", "ya", "c", "z", "yy"], "pass": ["p", "ch", "f", "dim", "r", "channel", "path", "ep", "val", "ss", "k", "depth", "read", "rows", "result", "Y", "level", "zero", "row", "code", "line", "scale", "test", "xx", "pe", "pos", "z"], "y1": ["xy1", "xy2", "Y2", "y2", "Y7", "y3", " y3", "xy7", " y7", "y7", "Y3", "Y1", " y2", "xy3"], "linesize": ["codesize", "lsiz", "lsz", "linesz", "itemsiz", "codesz", "linesiz", "linessize", "codessize", "codesiz", "lsize", "itemsz", "lssize", "itemssize", "itemsize"], "n": ["t", "p", "no", "d", "l", "nn", "nt", "r", "w", "k", "j", "o", "cn", "ne", "nm", "size", "ns", "nu", "nan", " N", "np", "b", "index", "name", "g", "mn", "network", "len", "sn", "m", "na", "N", "pi", "ni", "names", "num", "number", "count", "c", "nl", "nb", "nc"], "i": ["init", "t", "li", "ei", "p", "sim", "ki", "ij", "bi", "f", "is", "id", "l", "ii", "v", "ini", "ind", "mi", "ix", "me", "it", "ic", "q", "\u0438", "si", "oi", "j", "di", "gi", "ri", "in", "chain", "ip", "b", "index", "slice", "esi", "ui", "multi", "iu", "xi", "ma", "zi", "cgi", "status", "e", "ci", "ti", "m", "this", "print", "ami", "iter", "ter", "ai", "pi", "ims", "qi", "I", "phi", "us", "c", "cli", "x", "batch"], "ptr": ["dr", "p", "inter", "copy", "pert", "ind", "arr", "sp", "pipe", "length", "pointers", "offset", "pad", "buff", "mem", "pointer", "np", "bl", "ref", "row", "alloc", "iv", "rect", "tr", "pen", "addr", "ro", "pos", "err"], "spal": [" spam", "espal", "Spall", "ospar", "spar", "psale", " spar", " spall", "psal", "spel", " spac", "ospall", "Spel", "psel", "Spa", "SPall", "spa", "ispal", "espale", "espam", "espall", "spale", "Spar", "Spal", " spa", "spam", " spale", "spall", "Spale", "SPale", "ospal", "espel", "espac", "spac", "ispale", "ispar", "SPal", "ospam", "Spam", "SPac", "ispa", "psam"], "palette": ["sallete", "matotype", "sallette", "Palotype", "salette", " palettes", "alettes", "stalme", "fillete", "cholete", "fillette", "callette", "temal", "pllete", " palte", "stallete", "temlete", "plettes", "Palette", "choette", " pallete", "calette", "pallete", "Pallete", "choal", "palme", "salme", "palotype", "stalal", "alette", "matlette", "calal", "stalette", "temette", "alte", "plte", "matlete", "filotype", "salal", "palal", "callete", "chome", "palte", "filette", "matette", "temlette", "palettes", "Pallette", "pallette", "allete", "plette"], "ptr1": ["p3", "pointer1", "p0", "pointer2", "pad2", "p1", "pad3", "pad0", "p2", "ptr3", "pointer3", "pad1", "ptr0", "pointer0", "ptr2"]}}
{"project": "FFmpeg", "commit_id": "43a4cb070bf7588c53fd192e8fbc71a52fa14a4c", "target": 0, "func": "static int alac_encode_frame(AVCodecContext *avctx, uint8_t *frame,\n\n                             int buf_size, void *data)\n\n{\n\n    AlacEncodeContext *s = avctx->priv_data;\n\n    PutBitContext *pb = &s->pbctx;\n\n    int i, out_bytes, verbatim_flag = 0;\n\n\n\n    if (avctx->frame_size > DEFAULT_FRAME_SIZE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"input frame size exceeded\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (buf_size < 2 * s->max_coded_frame_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"buffer size is too small\\n\");\n\n        return -1;\n\n    }\n\n\n\nverbatim:\n\n    init_put_bits(pb, frame, buf_size);\n\n\n\n    if (s->compression_level == 0 || verbatim_flag) {\n\n        // Verbatim mode\n\n        const int16_t *samples = data;\n\n        write_frame_header(s, 1);\n\n        for (i = 0; i < avctx->frame_size * avctx->channels; i++) {\n\n            put_sbits(pb, 16, *samples++);\n\n        }\n\n    } else {\n\n        init_sample_buffers(s, data);\n\n        write_frame_header(s, 0);\n\n        write_compressed_frame(s);\n\n    }\n\n\n\n    put_bits(pb, 3, 7);\n\n    flush_put_bits(pb);\n\n    out_bytes = put_bits_count(pb) >> 3;\n\n\n\n    if (out_bytes > s->max_coded_frame_size) {\n\n        /* frame too large. use verbatim mode */\n\n        if (verbatim_flag || s->compression_level == 0) {\n\n            /* still too large. must be an error. */\n\n            av_log(avctx, AV_LOG_ERROR, \"error encoding frame\\n\");\n\n            return -1;\n\n        }\n\n        verbatim_flag = 1;\n\n        goto verbatim;\n\n    }\n\n\n\n    return out_bytes;\n\n}\n", "idx": 4344, "substitutes": {"avctx": [" avcontext", "wavctx", "avercv", "abctx", "avcv", "abcu", "wavtx", "avectx", "afhistory", "abconn", "avwcs", "ajwcs", "abcfg", "avecu", "cvctl", "abcontext", "ajjp", "Avtx", "avcu", "wavcontext", "afctx", "averwcs", "abtx", "avetx", "averhistory", "ajcv", " avctl", "avejp", "ajcfg", " avtx", "avctl", "cvcontext", "airhistory", "auctx", "avpkg", "cvctx", "avercontext", "avcontext", "ajtx", "averctx", "wavjp", "Avctx", "ajctx", " avjp", " avhistory", "avcfg", "aucu", "abctl", "ajcu", "avjp", "avecv", " avconn", "aukw", "avhistory", "aircu", "auhistory", "averjp", "avconn", " avcu", "avecontext", "airkw", "avepkg", "avertx", "avkw", "afcontext", "afpkg", "aftx", "airctx", "avekw", "avewcs", " avcfg", "avtx", "Avcontext", "abpkg", "Avconn", "avehistory", "cvtx"], "frame": ["fr", "iframe", " frames", "fram", "length", "channel", "image", "frames", " sequence", "style", "package", "time", "in", "fc", "word", "chain", "state", "feature", "point", "info", "range", "Frame", "type", "buffer", " framed", "sample", "flow", "code", "framework", "face", "bit", "ime", "ce", "base", "sequence", "window", "header", "AME", "feat", "video", "block", "context", "ence", "rame", "event"], "buf_size": ["bufablesize", "bufingshape", "bufPlevel", " buf_loss", "bufablebytes", "pool_level", "buf_shape", "bufingsize", "bufbufloss", "bufablelevel", "poolingsize", "pool_shape", "poolingbytes", "bufPshape", "buf_loss", "buf_level", "uf_SIZE", " buf_limit", "uf_size", "buf_index", "buf_length", "pool_bytes", "bufableshape", "bufbufsize", "poolingshape", "bufingbytes", "bufbuflimit", "buf_limit", "poolinglevel", "bufinglevel", "bufPbytes", "pool_size", "bufPsize", "buf_SIZE", "uf_index", "buf_bytes", "uf_length"], "data": ["flags", "t", "p", "f", "a", "d", "length", "to", "r", "mu", "image", "frames", "DATA", "padding", " Data", "any", "Data", "o", "next", "dat", "size", "none", "bytes", "name", "buf", "buffer", "text", "ata", "new", "sample", " DATA", "m", "res", "raw", "bits", "table", "missing", "values", "args", "all", "window", "bin", "video", "message", "block", "n", "load", "value", "batch"], "s": ["t", "os", "S", "p", "ds", "is", "a", "d", "l", "v", "ms", "sp", "ps", "ctx", "ins", "spec", "z", "sl", "less", "set", "ss", "iss", "h", "aws", "comm", "j", "bs", "js", "ns", "hs", "ssl", "b", "sq", "g", "ses", "sts", "rs", "gs", "ts", "es", "e", "stats", "m", "xs", "fs", "its", "sis", "sv", "cs", "args", "ims", "sb", "as", "c", "als", "ls", "parts", "ats", "n", "sys", "qs", "sw", "sa"], "pb": ["py", "vp", "pp", "cp", "p", "lb", "pkg", "td", "cv", "bj", "tmp", "lp", "bm", "PB", "sp", "ps", "ctx", "pc", "fb", "mp", "pg", "tap", "wp", "cb", "obj", "pm", "ub", "pa", "pt", "px", "bs", "ap", "mt", "np", "b", "buf", "gb", "fp", "tp", "dp", "pd", "jp", "pool", "vm", "bp", "pl", "uf", "sb", "tk", "rb", "pan", "wb"], "i": [" m", " I", "t", "li", "init", "p", "sim", "ki", "bi", "ind", "ii", "ini", "mi", "ix", " bi", "me", "it", "MI", "ic", "gu", "\u0438", " x", "hi", "si", "j", "di", "gi", "span", "in", "ip", "g", "ui", "multi", "iu", "xi", "y", "zi", "iter", " ti", "ci", "ti", "m", "ai", "pi", " j", "im", " mi", "x", "I", "phi", "qi", "c", "cli", " ii", "batch"], "out_bytes": ["out_errors", "out_Bytes", "OUT_tes", "out_bits", "out___bytes", "out__bytes", "out_cells", "out__parts", " out_bits", "out_lines", "OUT_bytes", "out_parts", "outMemcells", "OUT_pieces", "out__Bytes", " out_pages", "out__bits", "out_pages", "out_pieces", "outMemtes", " out_errors", " out_parts", "outMembytes", "OUT_lines", " out_lines", "outMemlines", " out_Bytes", " out_cells", "out___lines", "out_tes", "out___tes", "out___pieces", " out_tes"], "samples": ["saces", "ssamps", "sources", "examples", "ssamples", "taces", "Sizes", "tamples", "tamps", "Sources", "Saces", "Samples", "Sents", "Samps", "ssources", "examps", "samps", "ssents", "namples", "sents", "sizes", "nizes", "exources", "exents", "namps", "tizes", "naces"]}}
{"project": "qemu", "commit_id": "2725aec70114cf1bee00443aeb47a305f9b0c665", "target": 1, "func": "static void i440fx_update_memory_mappings(PCII440FXState *d)\n\n{\n\n    int i, r;\n\n    uint32_t smram;\n\n    bool smram_enabled;\n\n\n\n    memory_region_transaction_begin();\n\n    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,\n\n               &d->pam_regions[0]);\n\n    for(i = 0; i < 12; i++) {\n\n        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;\n\n        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,\n\n                   &d->pam_regions[i+1]);\n\n    }\n\n    smram = d->dev.config[I440FX_SMRAM];\n\n    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);\n\n    memory_region_set_enabled(&d->smram_region, !smram_enabled);\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 4360, "substitutes": {"d": ["df", "dr", "t", "dL", "p", "dev", "de", "dt", "dm", "ds", "f", "od", "debug", "ind", "l", "draw", "data", "ad", "fd", "dd", "dc", "send", "w", "ld", "di", "j", "st", "o", "dl", "in", "dn", "dat", "D", "dh", "sd", "gd", "dict", "b", "dx", "md", "da", "du", "status", "new", "pd", "ord", "db", "m", "rd", "x", "c", "s", "n", "out", "bd"], "i": ["key", "init", " I", "ei", "li", "RI", "p", "sim", "ki", "bi", "is", "id", "ind", "ii", "v", "ini", "l", "mi", "ix", "to", "me", "it", "abi", "ic", "q", "\u0438", "asi", "uri", "si", "oi", "di", "j", "gi", "io", "in", "ri", "ie", "ip", "iq", "ex", "index", "name", "info", "at", "g", "ui", "multi", "iu", "ij", "ir", "xi", "zi", "status", "print", "ci", "ti", "m", "ami", "ai", "pi", "im", "x", "I", "phi", "qi", "cli", "by", "u", " ii", "batch"], "r": ["ur", "rc", "dr", "t", "p", "rm", "rw", "re", "R", "er", "rr", "q", "w", "h", "j", "o", "sr", "vr", "cr", "rg", "b", "g", "pr", "rs", "rar", "rf", "range", "ar", "rn", "e", "m", "res", "pair", "rd", "c", "ro", "n", "rt", "rb", "u", "reg", "mr"], "smram": ["smmem", "svram", "smm", " smarm", "swcam", "igmram", "smcam", "mmgram", "svarm", "swgram", " spram", " spmem", "samam", "swram", " smmem", "svam", " spgram", "svrain", "igmgram", "smmm", "mmrain", "smgram", "smam", "mmram", "swater", "svmm", "swwater", "igmcam", "samgram", "smarm", "smrain", " smgram", " spcam", "mmmm", " smcam", "scam", " smwater", "samram", "svgram", "igmmem", "samarm", "sgram", " smam", "srain", "sram", "smwater"], "smram_enabled": ["smram_enable", "smmm_Enabled", "smram_required", "smgram_enable", "smramxenabled", "smmm_enabled", "smmm_online", "smram_online", "smmem_enabled", "smmem_required", "smram_encrypted", "smgram_enabled", "smmm_position", "smgram_Enabled", "smmem_online", "smram_position", "smramxEnabled", "smram_Enabled", "smramxonline", "smmem_enable", "smgram_encrypted", "smramxposition"]}}
{"project": "qemu", "commit_id": "e98768d43799cd3f00b358bfbe455fdae793d3e8", "target": 1, "func": "static int vmdk_open_vmdk4(BlockDriverState *bs,\n\n                           BlockDriverState *file,\n\n                           int flags)\n\n{\n\n    int ret;\n\n    uint32_t magic;\n\n    uint32_t l1_size, l1_entry_sectors;\n\n    VMDK4Header header;\n\n    VmdkExtent *extent;\n\n    int64_t l1_backup_offset = 0;\n\n\n\n    ret = bdrv_pread(file, sizeof(magic), &header, sizeof(header));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    if (header.capacity == 0) {\n\n        int64_t desc_offset = le64_to_cpu(header.desc_offset);\n\n        if (desc_offset) {\n\n            return vmdk_open_desc_file(bs, flags, desc_offset << 9);\n\n        }\n\n    }\n\n\n\n    if (le64_to_cpu(header.gd_offset) == VMDK4_GD_AT_END) {\n\n        /*\n\n         * The footer takes precedence over the header, so read it in. The\n\n         * footer starts at offset -1024 from the end: One sector for the\n\n         * footer, and another one for the end-of-stream marker.\n\n         */\n\n        struct {\n\n            struct {\n\n                uint64_t val;\n\n                uint32_t size;\n\n                uint32_t type;\n\n                uint8_t pad[512 - 16];\n\n            } QEMU_PACKED footer_marker;\n\n\n\n            uint32_t magic;\n\n            VMDK4Header header;\n\n            uint8_t pad[512 - 4 - sizeof(VMDK4Header)];\n\n\n\n            struct {\n\n                uint64_t val;\n\n                uint32_t size;\n\n                uint32_t type;\n\n                uint8_t pad[512 - 16];\n\n            } QEMU_PACKED eos_marker;\n\n        } QEMU_PACKED footer;\n\n\n\n        ret = bdrv_pread(file,\n\n            bs->file->total_sectors * 512 - 1536,\n\n            &footer, sizeof(footer));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        /* Some sanity checks for the footer */\n\n        if (be32_to_cpu(footer.magic) != VMDK4_MAGIC ||\n\n            le32_to_cpu(footer.footer_marker.size) != 0  ||\n\n            le32_to_cpu(footer.footer_marker.type) != MARKER_FOOTER ||\n\n            le64_to_cpu(footer.eos_marker.val) != 0  ||\n\n            le32_to_cpu(footer.eos_marker.size) != 0  ||\n\n            le32_to_cpu(footer.eos_marker.type) != MARKER_END_OF_STREAM)\n\n        {\n\n            return -EINVAL;\n\n        }\n\n\n\n        header = footer.header;\n\n    }\n\n\n\n    if (le32_to_cpu(header.version) >= 3) {\n\n        char buf[64];\n\n        snprintf(buf, sizeof(buf), \"VMDK version %d\",\n\n                 le32_to_cpu(header.version));\n\n        qerror_report(QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n                bs->device_name, \"vmdk\", buf);\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    l1_entry_sectors = le32_to_cpu(header.num_gtes_per_gte)\n\n                        * le64_to_cpu(header.granularity);\n\n    if (l1_entry_sectors == 0) {\n\n        return -EINVAL;\n\n    }\n\n    l1_size = (le64_to_cpu(header.capacity) + l1_entry_sectors - 1)\n\n                / l1_entry_sectors;\n\n    if (le32_to_cpu(header.flags) & VMDK4_FLAG_RGD) {\n\n        l1_backup_offset = le64_to_cpu(header.rgd_offset) << 9;\n\n    }\n\n    extent = vmdk_add_extent(bs, file, false,\n\n                          le64_to_cpu(header.capacity),\n\n                          le64_to_cpu(header.gd_offset) << 9,\n\n                          l1_backup_offset,\n\n                          l1_size,\n\n                          le32_to_cpu(header.num_gtes_per_gte),\n\n                          le64_to_cpu(header.granularity));\n\n    extent->compressed =\n\n        le16_to_cpu(header.compressAlgorithm) == VMDK4_COMPRESSION_DEFLATE;\n\n    extent->has_marker = le32_to_cpu(header.flags) & VMDK4_FLAG_MARKER;\n\n    extent->version = le32_to_cpu(header.version);\n\n    extent->has_zero_grain = le32_to_cpu(header.flags) & VMDK4_FLAG_ZERO_GRAIN;\n\n    ret = vmdk_init_tables(bs, extent);\n\n    if (ret) {\n\n        /* free extent allocated by vmdk_add_extent */\n\n        vmdk_free_last_extent(bs);\n\n    }\n\n    return ret;\n\n}\n", "idx": 4362, "substitutes": {"bs": ["os", "bn", "bos", "ds", "bh", "bi", "bt", "bm", "ms", "blog", "vs", "ps", "bas", "ks", "cb", "iss", "js", "ns", "b", "bb", "BS", "bl", "rs", "ib", "gs", "kb", "ts", "obs", "bg", "lbs", "bits", "fs", "its", "bis", "bp", "cs", "sb", "bf", "ls", "sys", "bc", "bd"], "file": ["fil", "fr", "out", "entry", "os", "disk", "fi", "lf", "limit", "f", "resource", "le", "File", "data", "channel", "path", "image", "fd", "files", "rule", "txt", "offset", "filename", "handle", "port", "lock", "io", "size", "chain", "format", "bytes", "section", "dir", "state", "buffer", "store", "fp", "document", "db", "line", "page", "domain", "table", "fs", "grid", "base", "model", "ile", "queue", "vol", "block", "stream", "be"], "flags": ["ptr", "fn", "lf", "details", "properties", " Flags", "func", "fd", "files", "locks", "options", "FLAG", "kind", "posts", "ensions", "xf", "Flag", "Flags", "size", "xxx", "lag", "heads", "fp", "ts", "faces", "stats", "cond", "lines", "utils", "vals", "bits", "flag", "features", "args", "bool", "fs", "cs", "comments", "mask", "ants", "settings", "nl", "weights", "fields", "cmd", "ags"], "ret": ["t", "reset", "elt", "gt", "inter", "lit", "details", "ll", "RET", "rm", "att", "nt", "re", "cont", "not", "Ret", "ft", "Return", "rets", "txt", "cert", "val", "j", "ry", "complete", "rem", "rier", "format", "mem", "mt", "result", "resp", "def", "usr", "pret", "jump", "net", "ber", "rest", "len", "status", "print", "pat", "rect", "res", "det", "report", "tr", "ter", "flag", "try", "reg", " Ret", "final", " alt", "back", "alt", "plain", "rt", "out", "cmd"], "magic": ["dr", "journal", "pic", "mag", "handler", "cookie", "major", "volume", "data", "special", "spec", "policy", "hash", "image", "field", "prefix", "padding", "medium", "offset", "version", "style", "method", "kind", "module", "power", "size", "vector", "format", "parser", "metadata", "slot", "name", "usage", "comment", "script", "type", "icon", "serial", "tag", "command", "area", "code", "generic", "head", "domain", "table", "flag", "base", "zone", "sequence", "mask", "meta", "Magic", "brand", "spin", "frame", "cmd"], "l1_size": ["l1xsize", "l1_name", "l1__Size", "l2_name", "l2_sum", "l1xsum", "l1xSize", "l1__sum", "l1__size", "l1_sum", "l2_size", "l1xname", "l1__name", "l1_Size", "l2_Size"], "l1_entry_sectors": ["l1_entry_secs", "l1_entry_psegments", "l1_entry_psectors", "l1_entry_psecs", "l1_entry_spectors", "l1_entry_pectors", "l1_entry_spevers", "l1_entry_segments", "l1_entry_psevers", "l1_entry_spegments", "l1_entry_pevers", "l1_entry_pecs", "l1_entry_severs", "l1_entry_pegments", "l1_entry_specs"], "header": ["key", "dr", "entry", "order", "hd", "commit", "journal", "ptr", "heading", "handler", "data", "policy", "field", "oder", "msg", "parent", "padding", "drm", "offset", "version", "self", "h", "prot", "liner", "body", "size", "vector", "history", "metadata", "layer", "format", "section", "index", "name", "ver", "comment", "term", "adder", "tree", "type", "detail", "buffer", "tag", "status", "iter", "document", "holder", "column", "HEAD", "variable", "line", "head", "table", "flag", "summary", "headers", "title", "window", "Header", "meta", "writer", "block", "er", "frame", "cache", "event", "sort"], "extent": ["xtents", "indant", "contents", "contant", "extency", "xtant", "xtent", "indent", "indency", "indents", "extents", "extant", "contency", "content", "xtency"], "pad": ["ptr", "pick", "ped", "dash", "blank", "wait", "ad", "prefix", "padding", "offset", "amp", "pay", "prep", "align", "fix", "ap", "frac", "bind", "quad", "mac", "paste", "cap", "type", "adder", "wrap", "end", "pat", "ads", "crop", "scale", "help", "addr", "attach", "patch", "pod", "cod", "grad", "push", "add", "Pad", "batch"], "QEMU_PACKED": ["QEMU_PAIXed", "QEMU_PackedLED", "QEMU_PALLED", "QEMU_PIXITED", "QEMU_PackedES", "QEMU_PASHed", "QEMU_PINKed", "QEMU_PACKITED", "QEMU_PACKES", "QEMU_PAACKITED", "QEMU_PINKLED", "QEMU_PAIXLED", "QEMU_PASHED", "QEMU_PACKLED", "QEMU_PAACKED", "QEMU_PALLLED", "QEMU_MACKed", "QEMU_Packeded", "QEMU_PALLES", "QEMU_PIXED", "QEMU_PASHLED", "QEMU_MACKES", "QEMU_MACKED", "QEMU_PAACKLED", "QEMU_PACKed", "QEMU_MACKLED", "QEMU_PAACKES", "QEMU_PIXLED", "QEMU_PAACKed", "QEMU_PINKES", "QEMU_PIXed", "QEMU_PALLed", "QEMU_PALLITED", "QEMU_PAIXED", "QEMU_PINKED", "QEMU_PackedED", "QEMU_PASHES", "QEMU_PAIXITED"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void control_to_network(RDMAControlHeader *control)\n\n{\n\n    control->type = htonl(control->type);\n\n    control->len = htonl(control->len);\n\n    control->repeat = htonl(control->repeat);\n\n}\n", "idx": 4385, "substitutes": {"control": ["rc", "fail", "view", "compl", "form", "config", "delete", "controller", "load", "management", "length", "cont", "component", "critical", "trl", "radio", "prefix", "check", "change", "call", "send", "obj", "edit", "setup", "hold", "layout", "ell", "handle", "build", "description", "comm", "output", "driver", "cell", "current", "info", "connect", "input", "roll", "scroll", "ctrl", "command", "close", "code", "rol", "content", "cond", "rel", "report", "help", "exec", "unknown", "follow", "accept", "desc", "Control", "number", "client", "update", "settings", "null", "create", "ctl", "cmd", "add"]}}
{"project": "qemu", "commit_id": "95129d6fc9ead97155627a4ca0cfd37282883658", "target": 0, "func": "static bool use_multiport(VirtIOSerial *vser)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(vser);\n\n    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);\n\n}\n", "idx": 4389, "substitutes": {"vser": ["vsector", "vertor", "vccer", "vcer", "vcther", "vcserv", "vtsector", "vercer", "vtther", "vcser", "vtserv", "vtor", " vserv", "vther", "vctor", "verser", " vther", "vserv", " vsector", " vtor", " vcer", "vcsector", "vtser"], "vdev": ["dev", "vdevice", "gdevice", "vav", "fobj", "fdev", "gdev", " vobj", "fdevice", "vobj", "gserv", " vav", " vserv", "vvar", "dvar", "fserv", "dav", "vserv", " vvar", " vdevice", " vev", "tvev", "vev", "ddev", "tvvar", "gobj", "tvdev", "tvav"]}}
{"project": "FFmpeg", "commit_id": "56ee3f9de7b9f6090d599a27d33a392890a2f7b8", "target": 0, "func": "static int poll_filter(OutputStream *ost)\n\n{\n\n    OutputFile    *of = output_files[ost->file_index];\n\n    AVFrame *filtered_frame = NULL;\n\n    int frame_size, ret;\n\n\n\n    if (!ost->filtered_frame && !(ost->filtered_frame = avcodec_alloc_frame())) {\n\n        return AVERROR(ENOMEM);\n\n    } else\n\n        avcodec_get_frame_defaults(ost->filtered_frame);\n\n    filtered_frame = ost->filtered_frame;\n\n\n\n    if (ost->enc->type == AVMEDIA_TYPE_AUDIO &&\n\n        !(ost->enc->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE))\n\n        ret = av_buffersink_get_samples(ost->filter->filter, filtered_frame,\n\n                                         ost->st->codec->frame_size);\n\n    else\n\n        ret = av_buffersink_get_frame(ost->filter->filter, filtered_frame);\n\n\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (filtered_frame->pts != AV_NOPTS_VALUE) {\n\n        filtered_frame->pts = av_rescale_q(filtered_frame->pts,\n\n                                           ost->filter->filter->inputs[0]->time_base,\n\n                                           ost->st->codec->time_base) -\n\n                              av_rescale_q(of->start_time,\n\n                                           AV_TIME_BASE_Q,\n\n                                           ost->st->codec->time_base);\n\n    }\n\n\n\n    switch (ost->filter->filter->inputs[0]->type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        if (!ost->frame_aspect_ratio)\n\n            ost->st->codec->sample_aspect_ratio = filtered_frame->sample_aspect_ratio;\n\n\n\n        do_video_out(of->ctx, ost, filtered_frame, &frame_size);\n\n        if (vstats_filename && frame_size)\n\n            do_video_stats(ost, frame_size);\n\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        do_audio_out(of->ctx, ost, filtered_frame);\n\n        break;\n\n    default:\n\n        // TODO support subtitle filters\n\n        av_assert0(0);\n\n    }\n\n\n\n    av_frame_unref(filtered_frame);\n\n\n\n    return 0;\n\n}\n", "idx": 4411, "substitutes": {"ost": ["rost", "et", "host", "art", "ty", "ott", "nt", "ocol", "sta", "wp", "ox", "ist", "each", "ous", "cern", "tto", "etc", "hop", "oc", " nost", "embed", "old", "irst", "oop", "arent", "post", "lov", "alist", "obj", "boost", "asts", "pty", "st", "ud", "ief", "oo", "mem", "aud", "ocr", "ord", "utt", "ops", "ort", "rob", "sys", "ict", "otype", "tt", "news", "org", "ow", "\u00f3", "odore", "ld", "oad", "wn", "est", "ond", "osta", "onet", "OST", "wind", "rest", "om", "your", "yt", "and", "ob", "rt", "oe", "ust", "owl", "oard", "os", "oss", "od", "ether", "ast", "oster", "o", "wow", "lost", "usr", "ird", "ot", "obs", "areth", "addr", "oth", "expr", "must", "olog", "oid", "xp", "stream"], "of": ["oned", "os", "et", "oco", "lf", "el", "bj", "OF", "ow", "to", "avored", "\u00f3", "it", " OF", "Of", "boost", "less", " lov", "or", "ocket", "one", "wo", "OO", "ok", " os", "o", "so", "oi", "with", "off", " af", "root", "eff", "zero", "ot", "om", "orf", "omp", "new", "oof", "osi", " od", "uf", "on", "oft", "ef", "des", "from", "oid", "oen", "eh", "by", "oe", "out", "oa", "ol", "sw"], "filtered_frame": ["filtered_process", "filtered23word", "filered_frames", "filtered23Frame", "filpped___channel", "filted_component", "filorted_frame", "filteredmychannel", "filtered_channel", "filtered_fram", "filpped___image", "fillectedmyframe", "filteredJmessage", "filteredJframe", "filteredJfram", "fillected_channel", "filteringJframe", "filted___Frame", "filteredJrecord", "filendered_frame", "filtered___component", "filtered__frames", "filteredJface", "filtered__channel", "filteredmyframe", "filtered_step", "fillected_message", "filtered_record", "filted___record", "filterededpoint", "filtered_window", "filtered__step", "filtered_fr", "filtered_file", "filtered____frames", "filteredJFrame", "fillectedmyfeature", "filoded_zone", "filtered____fram", "filtered_state", "filened23role", "filtered_sample", "filtered___row", "filteredtFrame", "filtered__role", "filered____frame", "filted___process", "filorted____word", "filtered_role", "filered_frame", "filteredbedframes", "fillected____from", "filendered___frame", "filtering_block", "filted_process", "filtered___fr", "filtered_from", "filtered_block", "filtered___block", "filoded7frame", "filteredmyfeature", "filtered_message", "filteringJFrame", "filtering_input", "filtered__word", "filpped___step", "filoded7process", "filoded_process", "filorted____frame", "filtered_component", "filted___sample", "filtered_point", "filtering_component", "filened_row", "filtered2channel", "fillected____channel", "filtered____message", "filtered_word", "filtered____channel", "filteringJsample", "filtered____frame", "filened23word", "filtered2frame", "filendered_sample", "filterededcomponent", "filoded7zone", "filened_frame", "filteredtrow", "filteredtframe", "filtered23role", "filtered___sample", "filteredbedinput", "filendered_point", "filtered2message", "filtering_sample", "filtered23frame", "filted___image", "filanned_frame", "filpped_step", "filteredJsample", "filted_fram", "filannedJface", "filendered_component", "filannedJframe", "filtered____component", "filteredJchannel", "fillectedmyface", "filtered2from", "filtered__component", "filtered_feature", "filtering_Frame", "filted___fram", "filtered___record", "filterededframe", "filtering_frame", "filpped_channel", "filorted_word", "filorted____fr", "filterededsample", "filtered_length", "filted_frame", "fillectedmychannel", "filtered____file", "filpped_frame", "fillected____frame", "filered_component", "filtered___process", "filanned_face", "filtered__file", "filanned_state", "filened23row", "filtered_zone", "filtered23record", "filteredJfrom", "filened23frame", "filtered_frames", "filendered___point", "filteredJstate", "filted_Frame", "filteredJfeature", "filted___frame", "filpped_image", "filendered___component", "filered____component", "filtered____fr", "filtering_fram", "filoded_frame", "filtered___input", "fillected____message", "filered____file", "filtered___image", "filtering_row", "filtered23fram", "filted_sample", "filtered___Frame", "filtered___point", "fillected_from", "filtered_row", "filtered___channel", "filtered__image", "filtering_window", "filpped___frame", "filtered_image", "filtered___word", "filted_record", "filteredmyface", "filteredbedframe", "filtered_Frame", "filtered___frame", "filteredtsample", "fillected_frame", "filered_file", "filened_word", "filted_window", "filtered7frame", "filannedJstate", "filtered___fram", "filtered_input", "filtered__frame", "filtered_face", "filorted_fr", "filtered___frames", "filtered7process", "filered____frames", "filannedJfram", "filtered___step", "filtered__row", "filtered23row", "fillected_face", "filted_length", "filtered____from", "filtered____word", "filtered7zone", "filteredJrow", "filteringJrow", "filanned_fram", "filted_image", "filtered____window", "fillected_feature", "filendered___sample", "filtering_frames", "filened_role", "filteredbedblock"], "frame_size": ["frame_scale", "fram8loss", "fram_ize", "frame16size", "fram_member", "frame_sn", "Frame_size", "frame64info", "fram8size", "frame64member", "frame64number", "Frame_number", "frame16SIZE", "fram8member", "Frame_info", "Frame_Size", "sample_offset", "frame16number", "frame64ize", " frame_length", "frame64Size", "frame_offset", "frame_SIZE", "frame_member", "frame_number", "frame8member", "Frame_SIZE", "frame64size", "frame_length", " frame_sn", "frame_Size", "frame_info", "frame_storage", "sample_scale", "fram_loss", "frame8ize", "fram_size", "fram8ize", "Frame_storage", "frame_ize", "frame64loss", "frame_loss", "sample_SIZE", "frame16storage", "frame8loss", "sample_size", "frame8size"], "ret": ["deg", "out", "t", "elt", "reset", "gt", "ern", "tmp", "tf", "ll", "RET", "rm", "arg", "arr", "nt", "re", "att", "cont", "Ret", "ft", "rets", "ext", "val", "fun", "j", "rem", "mem", "mt", "result", "lt", "def", "jump", "pret", "resp", "sys", "buf", "nz", "net", "usr", "rev", "ref", "mel", "len", "jp", "print", "res", "after", "try", "tr", "ter", "ert", "reg", " Ret", "final", "alf", "back", "alt", "nl", "rt", "value", "err", "cmd"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void *memory_region_get_ram_ptr(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n", "idx": 4440, "substitutes": {"mr": ["fr", "hm", "gm", "rpm", "lp", "ln", "rer", "mk", "ms", "kr", "rm", "ctr", "fm", "lr", "r", "lc", "pc", "rr", "ml", "rl", "drm", "pm", "br", "vr", "adr", "nm", "asm", "mt", "usr", "hr", "nr", "md", "mn", "shr", "rs", "rar", "ocr", "wm", "rn", "m", "wr", "Mr", "bp", "MR", "irm", "wcs", "arry"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)\n\n{\n\n    afq->avctx             = avctx;\n\n    afq->next_pts          = AV_NOPTS_VALUE;\n\n    afq->remaining_delay   = avctx->delay;\n\n    afq->remaining_samples = avctx->delay;\n\n    afq->frame_queue       = NULL;\n\n}\n", "idx": 4479, "substitutes": {"avctx": [" avcontext", "wavctx", "avkt", "Avtx", "afcontext", "wavpkg", "afctl", "Avpkg", "afctx", "apobj", "afobj", "wavcontext", "apkt", "aptx", "wavctl", "abctx", "abtx", "AVobj", "avetx", " avpkg", " avctl", "aftx", " avtx", "apconn", "wavtx", "avectx", "avctl", "appkg", "afkt", "AVconn", "AVcontext", "avconn", "apctx", "avpkg", "avobj", "avcontext", "avtx", "Avcontext", "apcontext", "abcontext", "abpkg", "avekt", "avecontext", "Avctx", "AVctx", "afconn"], "afq": ["faque", "afc", "iefQ", "abquit", "faq", " afch", "iefqi", "iefq", "afqi", "afch", "abq", "iefquire", "iefquit", "abque", "ajque", "ifquit", "ifque", " afqueue", "fac", " afc", "afqs", "famquire", "abquest", "affce", "aimQ", " afquit", "affdq", "aimque", "aphquest", "afQ", " afquest", "aimq", "ifquest", "famqi", "aphqueue", " afck", "awqs", "ajq", " afQ", "ifq", "awck", "aphque", "afqueue", "aphch", "aphq", " afque", "awce", "famdq", "afquire", "iefdq", "afque", "affqi", "ajch", "affqs", "affq", "famq", "iefque", "faquest", " afqs", "awq", "faquit", "afck", "affquire", "affck", "afquest", "afquit", "afce", "aphc", " afce", "ajqueue", "aimquit", "afdq"]}}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)\n\n{\n\n    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);\n\n}\n", "idx": 4488, "substitutes": {"cpu": ["cu", "cp", "p", " CPU", "util", "ork", "phys", "processor", "thread", "pc", "component", "hz", "linux", "gpu", "node", "phy", "chip", "uu", "gc", "nu", "mem", "proc", "clock", "met", "CPU", "gnu", "xi", "process", "vm", "gp", "pu", "core", "hw", "cum", "pid", "c", "nic", "nc"], "parm": ["sparms", "parms", "pparm", " parms", "pcarp", "pdem", "tparm", "Param", " pparam", "tparp", "ppay", "pay", "sparm", "spparam", "Parm", "pcdem", "tpay", " param", "Pparam", "pparp", "pparam", "parp", "pcay", "ppdem", "Parms", "sparam", "pcarm", "param", "tpdem"]}}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME(rgb24tobgr15)(const uint8_t *src, uint8_t *dst, int src_size)\n\n{\n\n    const uint8_t *s = src;\n\n    const uint8_t *end;\n\n    const uint8_t *mm_end;\n\n    uint16_t *d = (uint16_t *)dst;\n\n    end = s + src_size;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*src):\"memory\");\n\n    __asm__ volatile(\n\n        \"movq          %0, %%mm7    \\n\\t\"\n\n        \"movq          %1, %%mm6    \\n\\t\"\n\n        ::\"m\"(red_15mask),\"m\"(green_15mask));\n\n    mm_end = end - 11;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movd          %1, %%mm0    \\n\\t\"\n\n            \"movd         3%1, %%mm3    \\n\\t\"\n\n            \"punpckldq    6%1, %%mm0    \\n\\t\"\n\n            \"punpckldq    9%1, %%mm3    \\n\\t\"\n\n            \"movq       %%mm0, %%mm1    \\n\\t\"\n\n            \"movq       %%mm0, %%mm2    \\n\\t\"\n\n            \"movq       %%mm3, %%mm4    \\n\\t\"\n\n            \"movq       %%mm3, %%mm5    \\n\\t\"\n\n            \"psrlq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $3, %%mm3    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %2, %%mm3    \\n\\t\"\n\n            \"psrlq         $6, %%mm1    \\n\\t\"\n\n            \"psrlq         $6, %%mm4    \\n\\t\"\n\n            \"pand       %%mm6, %%mm1    \\n\\t\"\n\n            \"pand       %%mm6, %%mm4    \\n\\t\"\n\n            \"psrlq         $9, %%mm2    \\n\\t\"\n\n            \"psrlq         $9, %%mm5    \\n\\t\"\n\n            \"pand       %%mm7, %%mm2    \\n\\t\"\n\n            \"pand       %%mm7, %%mm5    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n            \"psllq        $16, %%mm3    \\n\\t\"\n\n            \"por        %%mm3, %%mm0    \\n\\t\"\n\n            MOVNTQ\"     %%mm0, %0       \\n\\t\"\n\n            :\"=m\"(*d):\"m\"(*s),\"m\"(blue_15mask):\"memory\");\n\n        d += 4;\n\n        s += 12;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        const int b = *s++;\n\n        const int g = *s++;\n\n        const int r = *s++;\n\n        *d++ = (b>>3) | ((g&0xF8)<<2) | ((r&0xF8)<<7);\n\n    }\n\n}\n", "idx": 4519, "substitutes": {"src": ["rc", "sc", "inner", "dest", "sel", "ind", "data", "r", "cont", "ins", "inst", "sub", "loc", "cur", "st", "h", "sr", "in", "bs", "source", "b", "usr", "sh", "input", "rs", "sn", "sv", "x", "sb", "c", "start", "hl", "sur", "out"], "dst": ["ddest", "rbr", " dbr", " dsts", "dput", "psts", "pdest", " ddest", "rsts", "pput", "rst", "dbr", " dput", "wsts", "wst", "pst", "wbr", "rdest", "wdest", "wput", "dsts"], "src_size": ["src_ize", "src_offset", "src64size", "src_loc", "src64ize", "src_Size", " src_Size", " src_offset", "src64Size", " src_loc", " src_ize"], "s": ["t", "os", "S", "p", "ans", "ds", "south", "is", "a", "f", "ms", "l", "v", "sp", "r", "ps", "ins", "ies", "sl", "w", "ss", "si", "st", "h", "j", "o", "rows", "bs", "i", "js", "ns", "ows", "b", "sd", "hs", "g", "sts", "rs", "gs", "ts", "es", "e", "m", "stats", "sym", "fs", "its", "sv", "cs", "ims", "x", "sb", "as", "c", "als", "ls", "n", "ats", "qs", "start", "u", "se", "sw"], "end": ["t", "p", "max", "dest", "f", "ended", "ender", "id", "v", "length", "ut", "ad", "send", "w", "offset", "set", "en", "ff", "st", "h", "until", "size", "mt", "stop", "est", "begin", " End", "rest", "e", "m", "END", "ment", "ending", "all", "ent", "nd", "End", "start", "z", "out", "last", "close"], "mm_end": ["mmm_ends", "term_END", "term_end", "mm_END", "mem_begin", "mm_ender", "mem_start", "mem_end", "mmm_start", "mm_begin", "mmm_end", "mem_size", "term_ender", "mm_ends", "mm_start", "mm_size"], "d": ["t", "p", "dt", "ds", "dm", "f", "a", "l", "v", "r", "data", "dos", "ad", "fd", "dd", "dc", "w", "j", "h", "di", "o", "st", "dn", "D", "i", "did", "dat", "sd", "dict", "b", "g", "y", "da", "dp", "e", "db", "m", "x", "c", "n", "z", "u", "out", "bd"]}}
{"project": "qemu", "commit_id": "e61031cdd81826c433a8bbfa3aca2bae4ffaf845", "target": 1, "func": "static gboolean gd_motion_event(GtkWidget *widget, GdkEventMotion *motion,\n\n                                void *opaque)\n\n{\n\n    GtkDisplayState *s = opaque;\n\n    int x, y;\n\n    int mx, my;\n\n    int fbh, fbw;\n\n    int ww, wh;\n\n\n\n    fbw = surface_width(s->ds) * s->scale_x;\n\n    fbh = surface_height(s->ds) * s->scale_y;\n\n\n\n    gdk_drawable_get_size(gtk_widget_get_window(s->drawing_area), &ww, &wh);\n\n\n\n    mx = my = 0;\n\n    if (ww > fbw) {\n\n        mx = (ww - fbw) / 2;\n\n    }\n\n    if (wh > fbh) {\n\n        my = (wh - fbh) / 2;\n\n    }\n\n\n\n    x = (motion->x - mx) / s->scale_x;\n\n    y = (motion->y - my) / s->scale_y;\n\n\n\n    if (x < 0 || y < 0 ||\n\n        x >= surface_width(s->ds) ||\n\n        y >= surface_height(s->ds)) {\n\n        return TRUE;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_X, x,\n\n                             surface_width(s->ds));\n\n        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_Y, y,\n\n                             surface_height(s->ds));\n\n        qemu_input_event_sync();\n\n    } else if (s->last_x != -1 && s->last_y != -1 && gd_is_grab_active(s)) {\n\n        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_X, x - s->last_x);\n\n        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_Y, y - s->last_y);\n\n        qemu_input_event_sync();\n\n    }\n\n    s->last_x = x;\n\n    s->last_y = y;\n\n\n\n    if (!qemu_input_is_absolute() && gd_is_grab_active(s)) {\n\n        GdkScreen *screen = gtk_widget_get_screen(s->drawing_area);\n\n        int x = (int)motion->x_root;\n\n        int y = (int)motion->y_root;\n\n\n\n        /* In relative mode check to see if client pointer hit\n\n         * one of the screen edges, and if so move it back by\n\n         * 200 pixels. This is important because the pointer\n\n         * in the server doesn't correspond 1-for-1, and so\n\n         * may still be only half way across the screen. Without\n\n         * this warp, the server pointer would thus appear to hit\n\n         * an invisible wall */\n\n        if (x == 0) {\n\n            x += 200;\n\n        }\n\n        if (y == 0) {\n\n            y += 200;\n\n        }\n\n        if (x == (gdk_screen_get_width(screen) - 1)) {\n\n            x -= 200;\n\n        }\n\n        if (y == (gdk_screen_get_height(screen) - 1)) {\n\n            y -= 200;\n\n        }\n\n\n\n        if (x != (int)motion->x_root || y != (int)motion->y_root) {\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n            GdkDevice *dev = gdk_event_get_device((GdkEvent *)motion);\n\n            gdk_device_warp(dev, screen, x, y);\n\n#else\n\n            GdkDisplay *display = gtk_widget_get_display(widget);\n\n            gdk_display_warp_pointer(display, screen, x, y);\n\n#endif\n\n            s->last_x = -1;\n\n            s->last_y = -1;\n\n            return FALSE;\n\n        }\n\n    }\n\n    return TRUE;\n\n}\n", "idx": 4521, "substitutes": {"widget": ["gui", " w", "view", "html", "draw", "ctx", "board", "game", " widgets", "fw", "w", "wp", "wk", "ew", "layout", " win", "wt", "wid", "document", " window", "idget", "win", "grid", "Widget", "window", "box", "web"], "motion": ["request", "mpeg", "relation", "activity", "Motion", "pose", "loss", "moving", "mega", "draw", "direction", "upload", "image", "media", "error", "position", " Motion", "change", "otion", "phy", "resolution", "version", "mission", "release", "params", "mage", "feature", "response", "detail", "mor", "command", "tor", "movie", "flow", "m", "machine", "sense", "up", "gravity", "mass", "distance", "reference", "mot", "move", "mode", "video", "message", "frame", "mouse", "event", "spirit"], "opaque": ["Opacity", "obacity", "OPaque", "roposit", "oppaque", "ropacity", "Opaque", "ropent", "oplay", "oppent", "Opent", "obaque", "oposit", "Oposit", "opposit", "opent", "opacity", " oplay", "OPlay", " opacity", "oblay", "oppacity", "OPacity", "ropaque"], "s": ["p", "conf", "l", "sl", "gets", "uploads", "ns", "sq", "ses", "gs", "plays", "stats", "results", "its", "ims", "c", "settings", "n", "qs", "er", "sort", "search", "S", "a", "r", "ps", "vs", "ins", "app", "w", "less", "ss", "h", "changes", "i", "js", "sd", "ows", "b", "sts", "ts", "browser", "bits", "fs", "sis", "sb", "us", "als", "series", "ats", "sys", "states", "tests", "details", "is", "f", "d", "sam", "ports", "events", "aws", "params", "views", "bs", "space", "ex", "styles", "rs", "ids", "m", "cs", "as", "forms", "terms", "ls", "t", "os", "ds", "south", "ms", "v", "spec", "ies", "sm", "comm", "hs", "an", "g", "ties", "status", "es", "ar", "service", "sv", "aunts", "ears", "parts", "se", "sw"], "x": ["hello", "p", "X", "ux", " xx", "a", "xe", "l", "wx", "zx", "xa", "ix", "xml", "ml", "w", "ox", "ax", "one", "lon", "lat", "h", "lex", "px", "xf", "time", "xt", "i", "ex", "wd", "dx", "rx", "xxxx", "at", "yx", "xi", "height", "xy", "xs", "m", "xc", "xxx", "ct", "tx", "on", "xx", "xp", "z", "fx"], "y": ["py", "key", "t", "yi", "ch", "hy", "dy", "ty", "ym", "yn", "ies", "icy", "ky", "h", "yo", "ry", "ys", "wy", "lon", "gy", "i", "ye", "ey", "b", "Y", "ery", "sys", "sy", "axy", "height", "ny", "ly", "xy", "cy", "asy", "ay", "m", "aily", "ya", "iy", "oy", "yt", "on", "sky", "hot", "by", "fy", "yy", "uy", "vy"], "mx": ["ux", "ms", "xe", "wx", "ym", "zx", "mi", "ix", "xa", "mp", "hz", "ml", "gray", "ox", "ax", "wy", "px", "ex", "ey", "dx", "rx", "yx", "nz", "mn", "mb", "axy", "xi", "ma", "cox", "wm", "xy", "obs", "mie", "xs", "m", "xc", "mm", "xes", "ai", "mo", "tx", "xx", "xp", "mouse", "mr", "fx"], "my": ["py", "MY", "ity", "mmm", "ty", "mk", "ms", "ym", "mi", "me", "ies", "gray", "ox", "ky", "ry", "mine", "ys", "mys", "gy", "i", "mis", "mem", "ey", "ery", "memory", "yx", "mn", "axy", "ma", "ny", "cy", "xy", "sym", "m", "ami", "ody", "mm", "aily", "oy", "ni", "My", "sky", "am", "by", "fy", "yy", "rey", "mic", "vy"], "fbh": ["bw", "ebx", "wbgo", "FBh", "rbh", "facebookb", "fbb", "bfhz", "bh", "facebookh", "abbz", "bfh", "FBgo", "facebookz", "fbz", "bx", "FBz", "ebh", "abbh", "bmw", "ebhr", "fbhz", "facebookgo", "fwh", "fwb", "fbx", "rbb", "ebhz", "facebookw", "bhr", "bfw", "wbh", "FBw", "bfz", "wbw", "fww", "rbgo", "fbhr", "abbw", "bmx", "bmhr", "wbz", "abbhz", "bmh", "ebw", "fbgo", "rbw", "ebz", "fwgo"], "fbw": ["fbmm", "FBh", "fbW", "FBmm", "lbh", "FBW", "fbwm", "facebookh", "fbwr", "lbw", "facebookx", "bfh", "bbW", "wbf", "bbw", "lbmm", "tfh", "fcwr", "wbwm", "tfwd", "fbx", "fbwd", "wbwr", "bfx", "facebookw", "bfw", "wbh", "tfW", "bbwd", "fbf", "FBw", "facebookW", "fcw", "wbx", "wbw", "bfwm", "facebookf", "facebookwm", "bff", "bfwr", "FBwd", "facebookmm", "fch", "tfw", "bbh", "fcx", "lbW"], "ww": ["vp", "lb", "dy", "work", "week", "whe", "west", "kk", "wide", "rw", "wx", "nn", "org", "ctx", "wal", "eg", "pg", "wa", "fw", "wp", "w", "wk", "ew", "wo", " www", "wy", "wt", "wow", "wn", "we", "ht", "wd", "rx", "wl", "wm", "nw", "www", "hw", "wat", "lv", "hop", "ross", "kw", "WW", "hl", "iw", "nox", "wb", "sw", "fx"], "wh": ["ph", "hd", "sch", "html", "kh", "ch", "th", "haw", "work", "whe", "kr", "rw", "wx", "hz", "wa", "zh", "wp", "w", "hi", "fw", "wk", "h", "wy", "WH", "ht", "we", "tw", "wd", "how", "sh", "gh", "wind", "thus", "height", "nw", "cf", "tr", "www", "wr", "hw", "white", "window", "hop", "wcs", "kw", "Wh", "hl", "iw", "sw"]}}
{"project": "FFmpeg", "commit_id": "b46a77f19ddc4b2b5fa3187835ceb602a5244e24", "target": 0, "func": "int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,\n\n                         int level)\n\n{\n\n    VDPAUHWContext *hwctx = avctx->hwaccel_context;\n\n    VDPAUContext *vdctx = avctx->internal->hwaccel_priv_data;\n\n    VdpVideoSurfaceQueryCapabilities *surface_query_caps;\n\n    VdpDecoderQueryCapabilities *decoder_query_caps;\n\n    VdpDecoderCreate *create;\n\n    void *func;\n\n    VdpStatus status;\n\n    VdpBool supported;\n\n    uint32_t max_level, max_mb, max_width, max_height;\n\n    VdpChromaType type;\n\n    uint32_t width;\n\n    uint32_t height;\n\n\n\n    vdctx->width            = UINT32_MAX;\n\n    vdctx->height           = UINT32_MAX;\n\n\n\n    if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height))\n\n        return AVERROR(ENOSYS);\n\n\n\n    if (hwctx) {\n\n        hwctx->reset            = 0;\n\n\n\n        if (hwctx->context.decoder != VDP_INVALID_HANDLE) {\n\n            vdctx->decoder = hwctx->context.decoder;\n\n            vdctx->render  = hwctx->context.render;\n\n            vdctx->device  = VDP_INVALID_HANDLE;\n\n            return 0; /* Decoder created by user */\n\n        }\n\n\n\n        vdctx->device           = hwctx->device;\n\n        vdctx->get_proc_address = hwctx->get_proc_address;\n\n\n\n        if (hwctx->flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)\n\n            level = 0;\n\n\n\n        if (!(hwctx->flags & AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH) &&\n\n            type != VDP_CHROMA_TYPE_420)\n\n            return AVERROR(ENOSYS);\n\n    } else {\n\n        AVHWFramesContext *frames_ctx = NULL;\n\n        AVVDPAUDeviceContext *dev_ctx;\n\n\n\n        // We assume the hw_frames_ctx always survives until ff_vdpau_common_uninit\n\n        // is called. This holds true as the user is not allowed to touch\n\n        // hw_device_ctx, or hw_frames_ctx after get_format (and ff_get_format\n\n        // itself also uninits before unreffing hw_frames_ctx).\n\n        if (avctx->hw_frames_ctx) {\n\n            frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n        } else if (avctx->hw_device_ctx) {\n\n            int ret;\n\n\n\n            avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);\n\n            if (!avctx->hw_frames_ctx)\n\n                return AVERROR(ENOMEM);\n\n\n\n            frames_ctx            = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n            frames_ctx->format    = AV_PIX_FMT_VDPAU;\n\n            frames_ctx->sw_format = avctx->sw_pix_fmt;\n\n            frames_ctx->width     = avctx->coded_width;\n\n            frames_ctx->height    = avctx->coded_height;\n\n\n\n            ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);\n\n            if (ret < 0) {\n\n                av_buffer_unref(&avctx->hw_frames_ctx);\n\n                return ret;\n\n            }\n\n        }\n\n\n\n        if (!frames_ctx) {\n\n            av_log(avctx, AV_LOG_ERROR, \"A hardware frames context is \"\n\n                   \"required for VDPAU decoding.\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        dev_ctx = frames_ctx->device_ctx->hwctx;\n\n\n\n        vdctx->device           = dev_ctx->device;\n\n        vdctx->get_proc_address = dev_ctx->get_proc_address;\n\n\n\n        if (avctx->hwaccel_flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)\n\n            level = 0;\n\n    }\n\n\n\n    if (level < 0)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device,\n\n                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        surface_query_caps = func;\n\n\n\n    status = surface_query_caps(vdctx->device, type, &supported,\n\n                                &max_width, &max_height);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    if (supported != VDP_TRUE ||\n\n        max_width < width || max_height < height)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device,\n\n                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        decoder_query_caps = func;\n\n\n\n    status = decoder_query_caps(vdctx->device, profile, &supported, &max_level,\n\n                                &max_mb, &max_width, &max_height);\n\n#ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE\n\n    if ((status != VDP_STATUS_OK || supported != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) {\n\n        profile = VDP_DECODER_PROFILE_H264_MAIN;\n\n        status = decoder_query_caps(vdctx->device, profile, &supported,\n\n                                    &max_level, &max_mb,\n\n                                    &max_width, &max_height);\n\n    }\n\n#endif\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n\n\n    if (supported != VDP_TRUE || max_level < level ||\n\n        max_width < width || max_height < height)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        create = func;\n\n\n\n    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        vdctx->render = func;\n\n\n\n    status = create(vdctx->device, profile, width, height, avctx->refs,\n\n                    &vdctx->decoder);\n\n    if (status == VDP_STATUS_OK) {\n\n        vdctx->width  = avctx->coded_width;\n\n        vdctx->height = avctx->coded_height;\n\n    }\n\n\n\n    return vdpau_error(status);\n\n}\n", "idx": 4524, "substitutes": {"avctx": [" avcontext", "auxconn", "hwcfg", "navtx", " avcb", "hwcontext", "avectx", "awctx", "averctl", "ampkg", "devcontext", "evcmp", "ajnp", "amctx", "avtimeout", "avernp", "svtx", " avcmp", "afjac", "awcfg", "devcmp", "acttx", "afctx", "navctx", "awjac", "avnp", "evtx", " avctl", " avjac", "ajkl", " avtx", "avcheck", "hwtx", "avctl", "avpkg", "avcontext", "ajtx", "avetimeout", "averctx", "avecheck", "ajcb", "AVtx", "actctx", "ajctx", "auxctx", "actval", "auxtx", "svcmp", "avenp", "avjac", "avcfg", "devctx", "navkl", "awcmp", "amconn", "avercheck", "AVcmp", "svcontext", "awtx", "awconn", "svctx", " avconn", "AVcontext", "avconn", "avcb", "amctl", " avkl", "awcontext", "AVctx", "afconn", "avertimeout", "devtx", "actctl", "evcontext", "avertx", "navcb", "evctx", "auxctl", " avpkg", "auxpkg", "avcmp", "aftx", "auxval", "avkl", "ajcheck", "averval", " avcfg", "avtx", "avval", "ajtimeout"], "profile": [" profiling", " descriptor", " dep", " prog", " definition", " descript", " file", " depth", " proto", "prof", " db", "def", " usage", " df", " prof", " block", "db", " profiles", " def", " mode", " Profile", " pro", " family", " std", " performance", " database", "Profile", " density"], "level": ["limit", "family", "debug", "l", "high", "Level", "vl", "length", "file", "error", "scope", "stack", "version", "style", "depth", "levels", "location", "lvl", "vel", "layer", "group", "link", "index", "state", "role", "interface", "tag", "try", "scale", "loop", "priority", "count", "mode", "pe", "message", "local", "err"], "hwctx": ["hdpkg", "hardtxt", "htcp", "htcmd", "hdnp", "fwcmp", "hwcfg", "htctx", "hwcontext", "hardtx", "htcmp", "hwnp", "hopcmp", "hhtx", "iwpkg", "ethertx", "hopctx", "hardctx", "hwcrit", "hdtx", "himcmd", "iwkl", "etherctx", "hdcontext", "hddl", "hzctx", "hzcfg", "hawcrit", "hdctx", "hhcmp", "httx", "htnp", "hwtx", "hawctx", "iwdl", "hawcontext", "himctx", "himtx", "hwcmp", "hhcu", "hzcrit", "hoptx", "himcp", "htcfg", "hdcmd", "iwnp", "hwtxt", "iwtxt", "hdcp", "iwctx", "hwcp", "iwtx", "fwtx", "hdcmp", "hzcontext", "fwctx", "hwpkg", "hawcfg", "iwcmp", "hawkl", "etherdl", "fwcontext", "ethercontext", "hztx", "iwcontext", "hopcu", "hhctx", "hwcu", "htkl", "hardpkg", "htcrit", "hwcmd", "hwdl", "hwkl", "htcontext", "iwcu", "hawtx", "hzpkg", "hdtxt"], "vdctx": ["hdcu", "vdpy", "vidcontext", "vrtx", "dbconn", "nvcu", "vdcrit", "xdcp", "xdjac", "hdconn", "lvctx", "vrcrit", "vdtmp", "ddtx", "visioncmp", "svtx", "ndctx", "hdtx", "vrctx", "ddjac", "dbjac", "hdcontext", "ndcrit", "vdpkg", "hdctx", "vtcontext", "vdcontext", "udtx", "vidpy", "vdcu", "xdpy", "dbctx", "vttmp", "vctx", "vidtmp", "xdtx", "visionctx", "vrcmp", "vtctx", "ndcu", "hdcp", "lvcp", "nvcp", "lvcu", "vdcmp", "hdcmp", "svcontext", "vdjac", "ndcmp", "svctx", "xdctx", "udctx", "xdcmp", "ndcontext", "vidcp", "hdtmp", "svjac", "nvcmp", "ddctx", "svpkg", "nvcontext", "nvctx", "vdconn", "vccontext", "visiontx", "vidtx", "udcp", "vdcp", "vdtx", "dbtx", "ndtx", "udpy", "vttx", "vcctx", "xdcrit", "vccu", "vidctx", "xdpkg", "ddpkg", "visioncontext", "svcu", "nvtx", "hdjac", "xdconn", "lvtx"], "surface_query_caps": ["surface_query_params", "surface_query_cap", "surface_query_abilities", "surface_search_caps", "surface_search_cap", "surface_search_abilities", "surface_search_params"], "decoder_query_caps": ["decoder_query_types", "decoder_search_types", "decoder_query_cap", "decoder_search_caps", "decoder_search_abilities", "decoder_search_cap", "decoder_query_abilities"], "create": ["created", "save", "activate", "use", "draw", "call", "check", "destroy", "send", "force", "setup", "build", "read", "creat", "clear", "make", "name", "connect", "add", "process", "code", "attach", "update", "open", "load", "execute", "Create", "close"], "func": ["tc", "function", "rc", "util", "unc", "fn", "cast", "actor", "family", "f", "fac", "ctx", "call", "con", "cb", "cc", "fun", "fc", "imp", "proc", "act", "cf", "code", "res", "conv", "callback", "cmd"], "status": [" statistic", " stable", "progress", " prog", " spec", " description", " debug", " flag", "Status", " fps", " success", "valid", " stat", " severity", " exists", "result", "state", " code", " speed", " progress", " mode", "flag", " performed", " ok", " protocol", " performance", " stream", "stream"], "supported": ["Supported", "forced", "disabled", "util", "created", "connected", "verified", "enabled", "installed", "Support", "required", "platform", "allowed", "loaded", " unsupported", "approved", "available", "support", "mounted", "found", "initialized", "locked", "handled", "used", "conv", " connected", "failed", "lib"], "max_level": ["maxdlevels", "ax_depth", "max_levels", "ax_vel", "max_depth", "maxddepth", "ax_level", "ax_levels", "maxdvel", "maxdlevel", "max_vel"], "max_mb": ["maxmframe", "maxmmb", "max_frame", "maxmthread", "maxmlevel", " max_frame", "max_thread", " max_thread"], "max_width": ["max_Width", "max_wid", " max_Width", " max_wid"], "max_height": ["max_Height", "max___mount", " max_mount", " max_Height", "max_depth", "max___depth", "max___height", "max_mount", "max___Height", " max_depth"], "type": ["tc", "key", "view", "t", "TYPE", "ty", "family", "types", "length", "spec", "ype", "error", "file", "Type", "typ", "options", "version", "style", "prop", "method", "kind", "module", "time", "size", "driver", "format", "color", "state", "index", "name", "ver", "role", "info", "interface", "class", " TYPE", "tag", "command", "tp", "tool", "what", "test", "var", "brand", "pe", "message", "event", "template"], "height": ["ptr", "capacity", "host", "max", "ch", "quality", "ty", "family", "volume", "dim", "draw", "length", "data", "hash", "density", "padding", "address", "resolution", "chip", "depth", "h", "build", "kind", "power", "device", "read", "size", "history", "Height", "ht", "memory", "arch", "buffer", "hei", "command", "rank", "bottom", "radius", "scale", "gravity", "window", "total", "shape", "input", "grow", "hang"], "frames_ctx": ["faces_conn", " frames_urg", "frames_cv", "frames___ctx", "frames___urg", "frames___cmp", "faces_cmp", "faces_ctx", "frames_cc", "faces_cc", "frames_conn", "frames___conn", "frames_tx", "frames_cmp", "frames_urg", "frames___cc", "frames___tx", " frames_tx", " frames_cv", "frames___cv"], "dev_ctx": ["dev_pkg", "dev2cmp", "ev_pkg", "dev_cmp", "ev_ctx", "dev2pkg", "ev_cmp", "dev2ctx", "ev_tx", "dev_tx", "dev2tx"], "ret": ["VAL", "active", "deep", "RET", "re", "put", "Ret", "error", "val", "prop", "valid", "rem", "layer", "resp", "def", "result", "info", "class", "cond", "flag", "final", "alt", " resp", "value", "last", "mediate"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int estimate_qp(MpegEncContext *s, int dry_run){\n\n    if (s->next_lambda){\n\n        s->current_picture_ptr->f.quality =\n\n        s->current_picture.f.quality = s->next_lambda;\n\n        if(!dry_run) s->next_lambda= 0;\n\n    } else if (!s->fixed_qscale) {\n\n        s->current_picture_ptr->f.quality =\n\n        s->current_picture.f.quality = ff_rate_estimate_qscale(s, dry_run);\n\n        if (s->current_picture.f.quality < 0)\n\n            return -1;\n\n    }\n\n\n\n    if(s->adaptive_quant){\n\n        switch(s->codec_id){\n\n        case AV_CODEC_ID_MPEG4:\n\n            if (CONFIG_MPEG4_ENCODER)\n\n                ff_clean_mpeg4_qscales(s);\n\n            break;\n\n        case AV_CODEC_ID_H263:\n\n        case AV_CODEC_ID_H263P:\n\n        case AV_CODEC_ID_FLV1:\n\n            if (CONFIG_H263_ENCODER)\n\n                ff_clean_h263_qscales(s);\n\n            break;\n\n        default:\n\n            ff_init_qscale_tab(s);\n\n        }\n\n\n\n        s->lambda= s->lambda_table[0];\n\n        //FIXME broken\n\n    }else\n\n        s->lambda = s->current_picture.f.quality;\n\n    update_qscale(s);\n\n    return 0;\n\n}\n", "idx": 4539, "substitutes": {"s": ["p", "times", "bes", "gets", "ains", "ns", "ses", "gs", "xs", "stats", "comments", "its", "ims", "c", "n", "qs", "z", "services", "S", "a", "r", "vs", "ps", "ins", "w", "less", "ss", "h", "changes", "mods", "js", "b", "sts", "ts", "ops", "ads", "has", "fs", "args", "sb", "als", "ats", "sys", "ers", "states", "tests", "sports", "is", "f", "ports", "events", "aws", "views", "bs", "rs", "m", "acs", "cs", "as", "terms", "ls", "ags", "t", "os", "ess", "ds", "south", "ms", "v", "ies", "sets", "sm", "eds", "set", "comm", "hs", "an", "g", "ties", "es", "sv", "aunts", "parts", "se", "sw"], "dry_run": ["dryNetrun", "dryoseview", "dryNetRun", "dryPostRun", " dry_clean", "dryNetmode", "dryPostmode", "dry_clean", "drylyrange", " dry_mode", "dryPostclean", "dryoseRun", "drylyrun", "drylyRun", " dry_running", "dry_mode", "dryOverrun", "dryOverrunning", "drylyview", "dryNetclean", "dryoserange", "dry_remove", " dry_range", " dry_view", "dryPostrun", " dry_remove", "dry_view", "dry_Run", "dryOverremove", "dryoserun", " dry_Run", "dryOverRun", "dry_running", "dry_range"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)\n\n{\n\n    if (use_icount) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);\n\n    if (use_icount) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n", "idx": 4540, "substitutes": {"ctx": ["tc", "cm", "cp", "conf", "cu", "co", " cx", "pkg", "tmp", "conn", "wx", "obj", "cb", "cc", "CT", "req", "ok", "history", " context", "act", "cmp", "jp", "cf", "ck", "cfg", "xc", "ca", "hw", "ct", "tx", "qt", "c", "bc", "cmd", "Context", "kw", "cas", "wcs", "context", "sys", "nc", "mc"], "sprn": ["prnc", "sprnm", " prn", "prnm", "prN", "srN", "sprN", "srn", "sprnc", "srnm", " prnc", " prnm", "prn", "srnc", " prN"], "gprn": [" gprnb", "bgprr", "gpolr", "bgkrnm", "gvrnm", "gkrr", " gcrno", "gprr", "gkrnt", "gcrnb", "gprnb", "gpolnb", "bgkrn", "gprnt", "gkrn", "gsprnt", "gcrn", "gvrr", "bgprn", "bgprnm", " gcrr", "gcrno", "gcrr", "gkrnm", "gvrn", " gcrnb", " gprr", "gsprn", "bgkrr", "gpoln", "gvrnt", "bgprnt", " gprno", "bgkrnt", "gsprno", "gprnm", "gprno", "gsprnm", "gsprr", " gcrn", "gpolno", "gsprnb"]}}
{"project": "qemu", "commit_id": "46746dbaa8c2c421b9bda78193caad57d7fb1136", "target": 0, "func": "static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev)\n\n{\n\n#ifdef CONFIG_KVM\n\n    struct kvm_irqfd irqfd = {\n\n        .fd = event_notifier_get_fd(&vdev->intx.interrupt),\n\n        .gsi = vdev->intx.route.irq,\n\n        .flags = KVM_IRQFD_FLAG_RESAMPLE,\n\n    };\n\n    struct vfio_irq_set *irq_set;\n\n    int ret, argsz;\n\n    int32_t *pfd;\n\n\n\n    if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() ||\n\n        vdev->intx.route.mode != PCI_INTX_ENABLED ||\n\n        !kvm_resamplefds_enabled()) {\n\n        return;\n\n    }\n\n\n\n    /* Get to a known interrupt state */\n\n    qemu_set_fd_handler(irqfd.fd, NULL, NULL, vdev);\n\n    vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n    vdev->intx.pending = false;\n\n    pci_irq_deassert(&vdev->pdev);\n\n\n\n    /* Get an eventfd for resample/unmask */\n\n    if (event_notifier_init(&vdev->intx.unmask, 0)) {\n\n        error_report(\"vfio: Error: event_notifier_init failed eoi\");\n\n        goto fail;\n\n    }\n\n\n\n    /* KVM triggers it, VFIO listens for it */\n\n    irqfd.resamplefd = event_notifier_get_fd(&vdev->intx.unmask);\n\n\n\n    if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd)) {\n\n        error_report(\"vfio: Error: Failed to setup resample irqfd: %m\");\n\n        goto fail_irqfd;\n\n    }\n\n\n\n    argsz = sizeof(*irq_set) + sizeof(*pfd);\n\n\n\n    irq_set = g_malloc0(argsz);\n\n    irq_set->argsz = argsz;\n\n    irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK;\n\n    irq_set->index = VFIO_PCI_INTX_IRQ_INDEX;\n\n    irq_set->start = 0;\n\n    irq_set->count = 1;\n\n    pfd = (int32_t *)&irq_set->data;\n\n\n\n    *pfd = irqfd.resamplefd;\n\n\n\n    ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set);\n\n    g_free(irq_set);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to setup INTx unmask fd: %m\");\n\n        goto fail_vfio;\n\n    }\n\n\n\n    /* Let'em rip */\n\n    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n\n\n    vdev->intx.kvm_accel = true;\n\n\n\n    trace_vfio_intx_enable_kvm(vdev->vbasedev.name);\n\n\n\n    return;\n\n\n\nfail_vfio:\n\n    irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN;\n\n    kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd);\n\nfail_irqfd:\n\n    event_notifier_cleanup(&vdev->intx.unmask);\n\nfail:\n\n    qemu_set_fd_handler(irqfd.fd, vfio_intx_interrupt, NULL, vdev);\n\n    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n#endif\n\n}\n", "idx": 4551, "substitutes": {"vdev": ["cvdev", "pev", "vdevice", "versiondev", "kserv", "vlink", "vconf", "vcenv", "cvdevice", " vlink", "tdev", "wdevice", "vcomment", " vval", "vccam", "vserial", "tDev", "Vconf", "hev", "vDev", "Vval", "fserial", " vev", "kvar", "kgo", " vcomment", "vev", "kev", " vdriver", "penv", "klink", "wDev", "Vdriver", "vconn", "cvDEV", "kDEV", "fconn", "vcmem", "Vlink", "wev", "hdev", "tDEV", "versiondriver", "hDev", "Vserial", "tvar", "vdriver", "kenv", "pdev", "versionconf", "kdevice", "Vmem", "tdevice", "uvlink", "vcdev", "vcver", "svdev", "Vhost", "cvvar", "vdb", "kserial", "vclink", "vchost", "svver", "hdevice", "vgo", "fdev", "vhost", "Vdev", "vval", "vcgo", "wdev", " vgo", "svcomment", "Vdb", " vserv", "vvar", "vccomment", "vcdebug", " vconf", " venv", " vhost", "uvdev", "tev", " vver", "vDEV", " vserial", "vver", "kcam", " vdebug", "vmem", "uvenv", "kconn", " vmem", " vconn", "vcserv", "vdebug", "versiondb", "svdebug", "pserv", "kdev", " vdb", "kval", "fserv", "vcam", "uvhost", "vserv", "venv", " vcam"], "irq_set": ["irq_tree", "irqueueproset", "irq8Set", "irq__st", "irq__mod", "irq_reset", "irqu_mod", "irqueueproreset", "irchptSET", "irq2Set", "irqresset", "irqptstart", "irch_set", "irQ_Set", "irdq_set", "irquresset", "irdqacsource", "irdqacset", "irch_SET", "irq_entry", "irq___set", "irq_base", "irq_mod", "irq2set", "irquresmod", "irdqacreset", "irq__set", "irqptSet", "irch_Set", "irdq_source", "irqptSET", "irqrestree", "irQ_stat", "irQ_set", "irqacreset", "irqresmod", "irQ_state", "irquresst", "irq_st", "irQ_SET", "irq2base", "irq8SET", "irqlogstat", "irq___base", "irq8set", "irqu_set", "irq_init", "irqresstate", "irqueueproinit", "irq_SET", "irqptset", "irQ_base", "irq_stat", "irqueue_set", "irqresSET", "irqresSet", "irchptstart", "irq_source", "irqproreset", "irq_store", "irqproset", "irchptset", "irq__tree", "irqlogstore", "irchptSet", "irq8state", "irqurestree", "irqu_tree", "irch_start", "irq_state", "irqresst", "irqlogset", "irqproinit", "irQ_store", "irqlogentry", "irq_Set", "irq_start", "irQ_entry", "irdq_reset", "irqacsource", "irqueue_init", "irq___Set", "irqu_st", "irqueue_reset", "irqacset"], "ret": ["rc", "lit", "sec", "success", "RET", "Ret", "call", "val", "prop", " mem", "ry", "mem", "resp", "def", "class", "ref", " val", "status", "vals", "flag", " res", "final", " resp", "err", "cmd", "Val"], "argsz": ["agsz", "Argsz", "arscz", "agscz", "arszh", "argsze", "framesze", "argsce", " argsce", "arszi", "idszi", "argszh", "paramsze", "paramsiz", " argszek", "msze", "Argsze", " argsze", "argszo", " argszh", "argscz", "arszo", "argszi", "paramszek", "idscz", "argszek", "agszi", " argsiz", "inszi", "agsce", "agszh", "argsiz", "mszek", "framesz", " argszo", "msz", "msiz", "frameszi", "insz", " argszi", " argsZ", "agszo", "argsZ", "framesZ", "ArgsZ", "insce", "idszh", "idsz", "paramsz", "Argszi", "inszh", "arsz"], "pfd": [" pdata", "Pdata", "Pdd", "wFD", " pfx", "pbfd", "Pfd", "wfd", "pbfp", "PFD", "pbdata", " pdd", "Pfp", "pdata", "pbFD", "wfx", "pdd", "pfp", " pfp", "pfx", "Pfx", "pFD", "wdd", " pFD"]}}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evfsnabs(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);\n\n#else\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);\n\n    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n", "idx": 4555, "substitutes": {"ctx": ["tc", "sc", "cp", "co", "unc", "jac", "pkg", "cv", "tmp", "work", "conn", "config", "mk", "vc", "ctr", "ind", "wx", "nt", "lc", "prefix", "inst", "typ", "txt", "cb", "obj", "loc", "crit", "cc", "cur", "abc", "kt", "req", "cl", "kl", "anc", "ann", "history", "resp", "np", "today", "act", "std", "kb", "alloc", "cmp", "jp", "ck", "cf", "cfg", "xs", "xc", "gp", "iat", "etc", "that", "hw", "ct", "kg", "desc", "tm", "tx", "qt", "c", "bc", "wcs", "pause", "kw", "aux", "xp", "context", "urg", "ctl", "nc", "cmd"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,\n\n                                unsigned size)\n\n{\n\n    IMXTimerGState *s = (IMXTimerGState *)opaque;\n\n\n\n    DPRINTF(\"g-read(offset=%x)\", offset >> 2);\n\n    switch (offset >> 2) {\n\n    case 0: /* Control Register */\n\n        DPRINTF(\" cr = %x\\n\", s->cr);\n\n        return s->cr;\n\n\n\n    case 1: /* prescaler */\n\n        DPRINTF(\" pr = %x\\n\", s->pr);\n\n        return s->pr;\n\n\n\n    case 2: /* Status Register */\n\n        DPRINTF(\" sr = %x\\n\", s->sr);\n\n        return s->sr;\n\n\n\n    case 3: /* Interrupt Register */\n\n        DPRINTF(\" ir = %x\\n\", s->ir);\n\n        return s->ir;\n\n\n\n    case 4: /* Output Compare Register 1 */\n\n        DPRINTF(\" ocr1 = %x\\n\", s->ocr1);\n\n        return s->ocr1;\n\n\n\n\n\n    case 9: /* cnt */\n\n        imx_timerg_update_counts(s);\n\n        DPRINTF(\" cnt = %x\\n\", s->cnt);\n\n        return s->cnt;\n\n    }\n\n\n\n    IPRINTF(\"imx_timerg_read: Bad offset %x\\n\",\n\n            (int)offset >> 2);\n\n    return 0;\n\n}\n", "idx": 4556, "substitutes": {"opaque": ["oplaques", "opaques", "paque", "OPaque", "opface", "oppaque", "OPface", "oplque", " opade", "oppient", "pque", "boque", "boade", "boient", "oplaque", "opque", "opient", "paques", " opient", "oppque", " opque", "oppade", "opade", "oplface", "OPque", "OPaques", "pface", "boaque"], "offset": ["key", "kh", "bound", "reset", "no", "origin", "sp", "data", "length", "SIZE", "position", "error", "padding", "address", "frequency", "set", "unk", "alias", "pad", "o", "attribute", "align", "output", "location", "off", "pointer", "slot", "index", "point", "shift", "usage", "amount", "timeout", "type", "scroll", "ref", "buffer", "row", "operation", "alloc", "area", "len", "seed", "end", "addr", "base", "window", "slice", "Offset", "count", "from", "oid", "block", "pos", "start", "seek", " offsets"], "size": ["Size", "sp", "length", "SIZE", "ize", "IZE", "address", "set", "h", "align", "body", "mem", "name", "shift", "amount", "type", "command", "len", "e", "num", "number", "count", "message", "start", "n", "z"], "s": ["p", "tains", "sl", "ains", "ns", "alls", "sq", "ses", "gs", "y", "plays", "stats", "ials", "its", "ims", "ches", "ants", "itions", "settings", "des", "aps", "qs", "izes", "S", "sp", "ps", "ins", " slots", "ss", "j", "h", "ves", "js", "b", "sts", "olds", "new", "ts", "ops", "has", "bits", "fs", " jumps", "sis", "sb", "als", "iffs", "ands", "sys", "sol", "ions", "is", "ind", "ments", "ords", "sam", "ports", "aws", "bs", "ries", "rs", "bugs", "bis", "as", "ls", "Js", "os", "ess", "grades", "ists", "ds", "ms", "spec", "ies", " values", "sm", "eds", "iss", "outs", "comm", "hs", "ssl", "rates", "erences", "g", "es", "reports", "vals", "sv", "parts", "params"]}}
{"project": "qemu", "commit_id": "430b26a82da61876c4eaf559ae02332582968043", "target": 0, "func": "static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    /* Read rules from config file or command line options */\n\n    s->config_file = g_strdup(qemu_opt_get(opts, \"config\"));\n\n    ret = read_config(s, s->config_file, options, errp);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    /* Set initial state */\n\n    s->state = 1;\n\n\n\n    /* Open the image file */\n\n    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options, \"image\",\n\n                               bs, &child_file, false, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    bs->supported_write_flags = BDRV_REQ_FUA &\n\n        bs->file->bs->supported_write_flags;\n\n    bs->supported_zero_flags = (BDRV_REQ_FUA | BDRV_REQ_MAY_UNMAP) &\n\n        bs->file->bs->supported_zero_flags;\n\n    ret = -EINVAL;\n\n\n\n    /* Set request alignment */\n\n    s->align = qemu_opt_get_size(opts, \"align\", 0);\n\n    if (s->align && (s->align >= INT_MAX || !is_power_of_2(s->align))) {\n\n        error_setg(errp, \"Cannot meet constraints with align %\" PRIu64,\n\n                   s->align);\n\n        goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    if (ret < 0) {\n\n        g_free(s->config_file);\n\n    }\n\n    qemu_opts_del(opts);\n\n    return ret;\n\n}\n", "idx": 4563, "substitutes": {"bs": ["ubs", "os", "uts", "bos", "bps", "ds", "bh", "bi", "bm", "bes", "aus", "blog", "bed", "ps", "vs", "aos", "hz", "bas", "locks", "obj", "cb", "ks", "lets", "ss", "bles", "ports", "outs", "aws", "aks", "js", "ns", "hs", "bytes", "b", "tops", "bec", "BS", "boxes", "pb", "bl", "rs", "ib", "gs", "abilities", "las", "ts", "cks", "obs", "ops", "stats", "lbs", "ubis", "acs", "res", "vals", "bits", "fs", "its", "bis", "bp", "cs", "sb", "als", "ls", "bu", "ats", "qs", "bc"], "options": ["aches", "json", "os", "uts", "p", "details", "config", "properties", "times", "ms", "ps", "some", "objects", "obj", "Options", "ptions", "IONS", "errors", "caps", "option", "styles", "ex", "tops", "currency", "closure", "keys", "opt", "ts", "es", "ops", "stats", "checks", "results", "actions", "vals", "bits", "ices", "fs", "values", "args", "its", "ims", "comes", " Options", "parts", "als", "ption", "settings", "terms", "wcs", "weights", "params", "eps"], "flags": ["ents", "weight", " flag", " Flags", " fs", "files", "FLAG", "Flag", "Flags", "ns", " af", "fee", "ts", "res", "vals", "bits", "fs", "flag", "features", "args", "mask", "count", " fmt", "fields", "cmd", "ags"], "errp": ["errps", " errps", "errorpb", "errper", "errorpy", "iterP", "orderp", "iterpa", "iterpre", "errpa", " errpb", "iterps", "ererps", "strpy", "ererP", "rerps", "errpy", "aerv", "rerper", "ererpa", " errpre", "errpp", " errP", "errsp", "ererp", "aerP", "arrper", " errpa", "arrpa", " errpkg", "errpb", "errorv", " errpp", "errorp", "strP", "errv", "errorpkg", "ordersp", "errorP", "rerpa", "aerp", "orderpp", "errpre", "orderps", "erersp", " errpy", "ererpre", " errv", "iterp", "strpb", "arrps", "errpkg", " errsp", "errP", "arrp", "rerp", "iterper", "aerpkg", "ererpp", "strp"], "s": ["ubs", "p", "https", "sl", "gets", "self", "ains", "ns", "sq", "ses", "gs", "y", "sn", "stats", "its", "ims", "c", "settings", "qs", "services", "S", "ps", "vs", "ins", "w", "less", "ss", "j", "h", "changes", "i", "js", "b", "sts", "ts", "has", "bits", "fs", "sb", "als", "ats", "sys", "sa", "sports", "details", "is", "sam", "aws", "so", "rs", "bis", "cs", "as", "ls", "t", "os", "ds", "ms", "v", "ies", "set", "comm", "hs", "ssl", "g", "es", "utils", "sv", "params", "sw"], "opts": ["operpt", " oppt", "roptx", "alensions", " opps", " opters", "pregs", "opth", "alters", " coptr", "oppt", "oppgs", "alrs", "opopt", "opt", "opensions", "imts", "altr", " oprs", "popts", "iopgs", "ropts", "optters", "poptx", "roppt", "optts", "imters", " optx", "preTS", "opcs", "opttr", "prers", "operrs", " copts", "poptes", "optps", "iopTS", "alts", "ioppt", " copensions", " optes", "copts", "optr", "copps", "iopcs", "prets", "oppcs", "copopt", " opopt", "precs", "preters", "opert", " opt", "iopters", "ioprs", "copals", "opters", "operts", "ropters", "optx", "oppTS", "optpt", "oprs", "imth", "impt", "opgs", "alcs", "opals", "ropth", "optopt", "optth", " copters", "optensions", "oppts", "opTS", "optals", "roptes", "iopts", "optes", "popters", "opps", " opals", "iopt"], "local_err": ["local___eas", "localinginit", "local___norm", "locfulerr", "local_priv", "totalityerr", "localpyerror", "loc_err", "error_priv", "local_error", "localityexp", "local_out", "locallyexp", "locallycb", "loc_arr", "local_bug", "local_buf", "internal_error", "local_eas", "localjeas", "local___err", "totalityattr", "localjerr", "localitybug", "local_cb", "localfulerr", "localjnorm", "error_error", "error_cb", "local___bug", "localpyerr", " local_buf", "loc_eas", "locjerr", "loc_bug", "total_attr", "locallyattr", "totalityexp", "localingerr", "locallyerror", "local_arr", "locjnorm", "localpyer", "local_exp", "localfulkr", "localityinit", "localityattr", "totalityinit", "total_exp", "localpystate", "localingattr", "local_init", "local_er", "internal_state", "local_req", "localjbug", "localityerr", "locfulkr", "localitynorm", "locjeas", "localityeas", "local2out", "loc_norm", "localfulbug", "locallyinit", "locallyerr", "internal_err", "local2err", "error_err", " local_er", "local_state", "local2arr", "local_norm", "loc_out", "locfulbug", "localingexp", "locjbug", "local_kr", "total_init", "loc_kr", "loc_req", "total_err", "local2req", "internal_er", "local_attr", "locallypriv"], "ret": ["get", "deg", "gt", "RET", "__", "nt", "cont", "it", "ry", "rem", "gc", "over", "net", "opt", "iter", "det", " alt", "url", "inter", "success", "arg", "re", "pas", "fun", "j", "sat", "mt", "def", "at", "ber", "ref", "len", "try", "flag", "failed", "backed", "reset", "att", "ft", "rets", "cert", "got", "off", "nz", "print", " RET", "bool", "alt", "rt", "out", "t", "elt", "lit", "dt", "ll", "Ret", "Return", "val", "resp", "result", "usr", "g", "rev", "status", "jp", "res", "tr", "ter", " Ret", "expr", "back", "al"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_full_negative(void)\n\n{\n\n    const char *str = \" \\t -321\";\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 18446744073709551295LLU);\n\n}\n", "idx": 4569, "substitutes": {"str": ["out", "fr", "t", "sc", "Str", "ctr", "arr", "r", "sp", "list", "q", "msg", "txt", "obj", "st", "br", "i", "b", "g", "buf", "shr", "pr", "rs", "buffer", "text", "ocr", "enc", "res", "tr", "service", "cs", "seq", "STR", "c", "gr", "s", "n"], "err": ["rc", " er", "Er", "dr", "elt", "ch", "cer", " dr", " ver", " gr", "ctr", "kr", "arr", "er", "r", "lr", " cr", "rr", "oe", "error", " ptr", "msg", " r", "diff", "ox", "urg", " terr", "req", " error", "errors", "br", "cr", "attr", "i", "resp", "result", "exc", "nr", "fee", "pr", "rs", "ocr", "iter", "rn", "res", "der", "tr", " fr", " res", "gr", "Error", "sys", " rc", "ev", "cmd"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t exynos4210_fimd_read(void *opaque, target_phys_addr_t offset,\n\n                                  unsigned size)\n\n{\n\n    Exynos4210fimdState *s = (Exynos4210fimdState *)opaque;\n\n    int w, i;\n\n    uint32_t ret = 0;\n\n\n\n    DPRINT_L2(\"read offset 0x%08x\\n\", offset);\n\n\n\n    switch (offset) {\n\n    case FIMD_VIDCON0 ... FIMD_VIDCON3:\n\n        return s->vidcon[(offset - FIMD_VIDCON0) >> 2];\n\n    case FIMD_VIDTCON_START ... FIMD_VIDTCON_END:\n\n        return s->vidtcon[(offset - FIMD_VIDTCON_START) >> 2];\n\n    case FIMD_WINCON_START ... FIMD_WINCON_END:\n\n        return s->window[(offset - FIMD_WINCON_START) >> 2].wincon;\n\n    case FIMD_SHADOWCON:\n\n        return s->shadowcon;\n\n    case FIMD_WINCHMAP:\n\n        return s->winchmap;\n\n    case FIMD_VIDOSD_START ... FIMD_VIDOSD_END:\n\n        w = (offset - FIMD_VIDOSD_START) >> 4;\n\n        i = ((offset - FIMD_VIDOSD_START) & 0xF) >> 2;\n\n        switch (i) {\n\n        case 0:\n\n            ret = ((s->window[w].lefttop_x & FIMD_VIDOSD_COORD_MASK) <<\n\n            FIMD_VIDOSD_HOR_SHIFT) |\n\n            (s->window[w].lefttop_y & FIMD_VIDOSD_COORD_MASK);\n\n            break;\n\n        case 1:\n\n            ret = ((s->window[w].rightbot_x & FIMD_VIDOSD_COORD_MASK) <<\n\n                FIMD_VIDOSD_HOR_SHIFT) |\n\n                (s->window[w].rightbot_y & FIMD_VIDOSD_COORD_MASK);\n\n            break;\n\n        case 2:\n\n            if (w == 0) {\n\n                ret = s->window[w].osdsize;\n\n            } else {\n\n                ret = (pack_upper_4(s->window[w].alpha_val[0]) <<\n\n                    FIMD_VIDOSD_AEN0_SHIFT) |\n\n                    pack_upper_4(s->window[w].alpha_val[1]);\n\n            }\n\n            break;\n\n        case 3:\n\n            if (w != 1 && w != 2) {\n\n                DPRINT_ERROR(\"bad read offset 0x%08x\\n\", offset);\n\n                return 0xBAADBAAD;\n\n            }\n\n            ret = s->window[w].osdsize;\n\n            break;\n\n        }\n\n        return ret;\n\n    case FIMD_VIDWADD0_START ... FIMD_VIDWADD0_END:\n\n        w = (offset - FIMD_VIDWADD0_START) >> 3;\n\n        i = ((offset - FIMD_VIDWADD0_START) >> 2) & 1;\n\n        return s->window[w].buf_start[i];\n\n    case FIMD_VIDWADD1_START ... FIMD_VIDWADD1_END:\n\n        w = (offset - FIMD_VIDWADD1_START) >> 3;\n\n        i = ((offset - FIMD_VIDWADD1_START) >> 2) & 1;\n\n        return s->window[w].buf_end[i];\n\n    case FIMD_VIDWADD2_START ... FIMD_VIDWADD2_END:\n\n        w = (offset - FIMD_VIDWADD2_START) >> 2;\n\n        return s->window[w].virtpage_width | (s->window[w].virtpage_offsize <<\n\n            FIMD_VIDWADD2_OFFSIZE_SHIFT);\n\n    case FIMD_VIDINTCON0 ... FIMD_VIDINTCON1:\n\n        return s->vidintcon[(offset - FIMD_VIDINTCON0) >> 2];\n\n    case FIMD_WKEYCON_START ... FIMD_WKEYCON_END:\n\n        w = ((offset - FIMD_WKEYCON_START) >> 3) + 1;\n\n        i = ((offset - FIMD_WKEYCON_START) >> 2) & 1;\n\n        return s->window[w].keycon[i];\n\n    case FIMD_WKEYALPHA_START ... FIMD_WKEYALPHA_END:\n\n        w = ((offset - FIMD_WKEYALPHA_START) >> 2) + 1;\n\n        return s->window[w].keyalpha;\n\n    case FIMD_DITHMODE:\n\n        return s->dithmode;\n\n    case FIMD_WINMAP_START ... FIMD_WINMAP_END:\n\n        return s->window[(offset - FIMD_WINMAP_START) >> 2].winmap;\n\n    case FIMD_WPALCON_HIGH ... FIMD_WPALCON_LOW:\n\n        return s->wpalcon[(offset - FIMD_WPALCON_HIGH) >> 2];\n\n    case FIMD_TRIGCON:\n\n        return s->trigcon;\n\n    case FIMD_I80IFCON_START ... FIMD_I80IFCON_END:\n\n        return s->i80ifcon[(offset - FIMD_I80IFCON_START) >> 2];\n\n    case FIMD_COLORGAINCON:\n\n        return s->colorgaincon;\n\n    case FIMD_LDI_CMDCON0 ... FIMD_LDI_CMDCON1:\n\n        return s->ldi_cmdcon[(offset - FIMD_LDI_CMDCON0) >> 2];\n\n    case FIMD_SIFCCON0 ... FIMD_SIFCCON2:\n\n        i = (offset - FIMD_SIFCCON0) >> 2;\n\n        return s->sifccon[i];\n\n    case FIMD_HUECOEFCR_START ... FIMD_HUECOEFCR_END:\n\n        i = (offset - FIMD_HUECOEFCR_START) >> 2;\n\n        return s->huecoef_cr[i];\n\n    case FIMD_HUECOEFCB_START ... FIMD_HUECOEFCB_END:\n\n        i = (offset - FIMD_HUECOEFCB_START) >> 2;\n\n        return s->huecoef_cb[i];\n\n    case FIMD_HUEOFFSET:\n\n        return s->hueoffset;\n\n    case FIMD_VIDWALPHA_START ... FIMD_VIDWALPHA_END:\n\n        w = ((offset - FIMD_VIDWALPHA_START) >> 3);\n\n        i = ((offset - FIMD_VIDWALPHA_START) >> 2) & 1;\n\n        return s->window[w].alpha_val[i] &\n\n                (w == 0 ? 0xFFFFFF : FIMD_VIDALPHA_ALPHA_LOWER);\n\n    case FIMD_BLENDEQ_START ... FIMD_BLENDEQ_END:\n\n        return s->window[(offset - FIMD_BLENDEQ_START) >> 2].blendeq;\n\n    case FIMD_BLENDCON:\n\n        return s->blendcon;\n\n    case FIMD_WRTQOSCON_START ... FIMD_WRTQOSCON_END:\n\n        return s->window[(offset - FIMD_WRTQOSCON_START) >> 2].rtqoscon;\n\n    case FIMD_I80IFCMD_START ... FIMD_I80IFCMD_END:\n\n        return s->i80ifcmd[(offset - FIMD_I80IFCMD_START) >> 2];\n\n    case FIMD_VIDW0ADD0_B2 ... FIMD_VIDW4ADD0_B2:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_VIDW0ADD0_B2) >> 3].buf_start[2];\n\n    case FIMD_SHD_ADD0_START ... FIMD_SHD_ADD0_END:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_SHD_ADD0_START) >> 3].shadow_buf_start;\n\n    case FIMD_SHD_ADD1_START ... FIMD_SHD_ADD1_END:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_SHD_ADD1_START) >> 3].shadow_buf_end;\n\n    case FIMD_SHD_ADD2_START ... FIMD_SHD_ADD2_END:\n\n        return s->window[(offset - FIMD_SHD_ADD2_START) >> 2].shadow_buf_size;\n\n    case FIMD_PAL_MEM_START ... FIMD_PAL_MEM_END:\n\n        w = (offset - FIMD_PAL_MEM_START) >> 10;\n\n        i = ((offset - FIMD_PAL_MEM_START) >> 2) & 0xFF;\n\n        return s->window[w].palette[i];\n\n    case FIMD_PALMEM_AL_START ... FIMD_PALMEM_AL_END:\n\n        /* Palette aliases for win 0,1 */\n\n        w = (offset - FIMD_PALMEM_AL_START) >> 10;\n\n        i = ((offset - FIMD_PALMEM_AL_START) >> 2) & 0xFF;\n\n        return s->window[w].palette[i];\n\n    }\n\n\n\n    DPRINT_ERROR(\"bad read offset 0x%08x\\n\", offset);\n\n    return 0xBAADBAAD;\n\n}\n", "idx": 4570, "substitutes": {"opaque": ["OPos", "play", "paque", "OPaque", "opaques", "OPatile", "oppaque", " opaques", "oplay", "OPca", "pque", "opque", "opca", "opatile", " opatile", " opca", " opque", "oppca", " oplay", "oppatile", "OPlay", " opos", "OPque", "OPaques", "pos", "opos", "oppaques"], "offset": ["key", "et", "kh", "id", "error", "offer", "frequency", "alias", "slot", "scroll", "range", "response", "row", "area", "now", "into", "count", "encrypted", "message", "start", "z", "inter", "sp", "data", "OFF", "onto", "output", "empty", "mt", "pointer", "index", "timeout", "operation", "zero", "ref", "buffer", "flag", "kernel", "header", "adjusted", "bound", "reset", "padding", "address", "delay", "layout", "pad", "location", "off", "point", "shift", "amount", "type", "command", "os", "oint", "length", "position", "set", "style", "object", "o", "attribute", "trace", "alloc", "inet", "line", "bit", "addr", "window", "Offset", "from", "oid", "pos", "seek"], "size": ["Size", "weight", "l", "sp", "length", "SIZE", "ize", "IZE", "address", "set", "style", "h", "align", "mem", "name", "shift", "type", "len", "e", "args", "count", "message", "start", "n", "z", "seek"], "s": ["p", "conf", "tains", "uns", "bes", "ations", "sl", "gets", "ains", "ns", "sq", "ses", "gs", "y", "comments", "its", "ches", "itions", "ants", "c", "n", "qs", "ing", "izes", "ents", "S", "ps", "vs", "ins", "less", "ss", "changes", "js", "sts", "ts", "ops", "browser", "bits", "fs", " jumps", "sis", "sb", "als", "ands", "ats", "sys", "ers", "ions", "is", "ments", " parts", "ports", "events", "aws", "bs", "ries", "rs", "m", "ed", "bis", "orders", "cs", "as", "ls", "acts", "Js", "resses", "t", "os", "ists", " ads", "ds", "ests", "ms", "v", "aces", "ies", "eds", "outs", "o", "comm", "ings", "hs", "ssl", "rates", "erences", "g", "es", "sv", "parts", "alls"], "w": ["rew", "t", "p", "wh", "temp", "f", "a", "d", "l", "v", "wx", "rw", "wall", "r", "ow", "q", "wa", "fw", "wp", "wk", "ew", "k", "self", "h", "o", "pt", "wt", "word", "ex", "ht", "b", "tw", "index", "name", "W", "g", "xi", "wi", "y", "wid", "row", "nw", "end", "m", "raw", "win", "all", "hw", "window", "x", "c", "kw", "n", "start", "z", "iw", "wb", "sw", "widget"], "i": ["ia", "li", "p", "bi", "f", "id", "l", "ii", "v", "ini", "ind", "d", "mi", "ix", "it", "ic", "hi", "si", "di", "j", "h", "o", "in", "ip", "b", "index", "ui", "iu", "ib", "ij", "ir", "y", "xi", "e", "ci", "ti", "m", "iat", "pi", "x", "I", "phi", "n", "u"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER(ucf64_absd)(float64 a)\n\n{\n\n    return float64_abs(a);\n\n}\n", "idx": 4571, "substitutes": {"a": ["la", "ia", "t", "p", "aa", "alpha", "ea", "ana", "d", "l", "v", "r", "data", "ae", "sta", "w", "o", "apa", "i", "b", "A", "an", "g", "ba", "ata", "ma", "acc", "area", "da", "m", "na", "ca", "au", "ac", "ta", "as", "c", "s", "aaa", "n", "z", "u", "oa", "va", "sa"]}}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState *qemu_chr_open_null(const char *id,\n\n                                           ChardevBackend *backend,\n\n                                           ChardevReturn *ret,\n\n                                           Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n    ChardevCommon *common = backend->u.null;\n\n\n\n    chr = qemu_chr_alloc(common, errp);\n\n    if (!chr) {\n\n        return NULL;\n\n    }\n\n    chr->chr_write = null_chr_write;\n\n    chr->explicit_be_open = true;\n\n    return chr;\n\n}\n", "idx": 4607, "substitutes": {"id": ["key", "init", " rid", "ID", "bid", "ad", "fd", "kid", "Id", "uri", "rid", "ip", "ident", "name", "sid", "ref", "mid", "ids", "tag", "wid", "end", "head", "base", "uid", "pid", "aid", "oid", "bad"], "backend": [" backind", " backends", "backender", " backnd", "stender", "backengine", " backender", "Backends", "Backengine", "stind", "stengine", "Backnd", "stnd", "backind", " backengine", "Backind", "backends", "Backender", "backnd", "stend", "stends", "Backend"], "ret": ["pet", "et", "lit", "RET", "rm", "nt", "re", "Ret", "unt", "val", "rem", "mem", "mt", "resp", "met", "std", "rev", "ref", "rest", "repl", "res", "det", "etc", "uf", "aux", "rt", "reg"], "errp": ["Erp", " errps", "erps", "errm", "errpo", "errorpa", "errpa", "ererps", "errorm", " errpo", " errm", " errP", "Erpa", "ererp", "Erm", " errpa", "errorp", "erpo", "errorP", " errr", "erp", "errr", "ErP", "ererr", "errP", "ererpo", "err", "errps"], "chr": ["cherar", " chbr", "clr", " chsr", "CHsr", "CHdr", "chebr", "chrt", "chbr", " chdr", "schrc", "chrc", "chrb", "chsr", " chrb", "cherdr", "chtr", "chnrb", "Chr", "cherrar", "chert", "clrt", "chnrat", "clrc", "Chrc", "Chdr", "chertr", "chersr", "cheadr", "Chrat", "cherrc", "echar", "chrat", "chnadr", "cherr", " chrator", "echrb", "cheradr", "echr", " chrc", "chnrc", "chrar", "Char", " chtr", " chrat", "CHr", "chadr", "chrator", "schar", "clbr", "Chbr", "chndr", "chnrator", "chnrar", "chnr", "cherc", "schr", "chdr", "schbr", "chnar", "cher", "CHtr", " chrt", "echrator"], "common": ["general", "util", "specific", "primary", "com", "full", "Common", "high", "normal", "known", "shared", "qualified", "uch", "other", "pro", "comm", "recent", "standard", "seen", "current", "low", "onet", "non", "un", "m", "generic", "san", "global", "basic", "central", "client", " Common", "unique", "custom", "public"]}}
{"project": "qemu", "commit_id": "8ec14402029d783720f4312ed8a925548e1dad61", "target": 0, "func": "static int packet_enqueue(CompareState *s, int mode)\n\n{\n\n    ConnectionKey key;\n\n    Packet *pkt = NULL;\n\n    Connection *conn;\n\n\n\n    if (mode == PRIMARY_IN) {\n\n        pkt = packet_new(s->pri_rs.buf,\n\n                         s->pri_rs.packet_len,\n\n                         s->pri_rs.vnet_hdr_len);\n\n    } else {\n\n        pkt = packet_new(s->sec_rs.buf,\n\n                         s->sec_rs.packet_len,\n\n                         s->sec_rs.vnet_hdr_len);\n\n    }\n\n\n\n    if (parse_packet_early(pkt)) {\n\n        packet_destroy(pkt, NULL);\n\n        pkt = NULL;\n\n        return -1;\n\n    }\n\n    fill_connection_key(pkt, &key);\n\n\n\n    conn = connection_get(s->connection_track_table,\n\n                          &key,\n\n                          &s->conn_list);\n\n\n\n    if (!conn->processing) {\n\n        g_queue_push_tail(&s->conn_list, conn);\n\n        conn->processing = true;\n\n    }\n\n\n\n    if (mode == PRIMARY_IN) {\n\n        if (!colo_insert_packet(&conn->primary_list, pkt)) {\n\n            error_report(\"colo compare primary queue size too big,\"\n\n                         \"drop packet\");\n\n        }\n\n    } else {\n\n        if (!colo_insert_packet(&conn->secondary_list, pkt)) {\n\n            error_report(\"colo compare secondary queue size too big,\"\n\n                         \"drop packet\");\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4609, "substitutes": {"s": ["os", "S", "p", "sports", "ds", "details", "south", "is", "a", "v", "ares", "r", "ps", "vs", "ins", "ies", "serv", "less", "set", "ss", "events", "aws", "comm", "h", "j", "changes", "bs", "mods", "js", "ns", "hs", "b", "state", "ses", "sts", "rs", "gs", "ties", "ts", "ops", "stats", "m", "comments", "fs", "its", "bis", "sis", "sv", "orders", "ims", "aunts", "args", "cs", "sb", "c", "als", "parts", "ls", "as", "services", "ats", "qs", "sys", "ags", "states"], "mode": ["ace", "MODE", "de", "ance", "dm", "raid", " Mode", "dim", "ze", "direction", "ode", "me", "nom", "position", "my", "stay", "style", "pro", "method", "module", "phrase", "ie", "tower", "format", "mt", "state", "def", "due", "role", "step", "md", "type", "mid", "command", "status", "omp", "area", "mit", "m", "te", "ase", "mm", "Mode", "tm", "mod", "settings", "med", "mate", "params", "cmd", "dem"], "key": ["cp", "ke", "conf", "host", "pkg", "tmp", "temp", "sk", "mk", "id", "kk", "sum", "token", "col", "ctx", "hash", "kid", "msg", "cert", "node", "wk", "leader", "set", "val", "k", "kt", " KEY", "ip", "link", "name", "mac", "fee", "net", "keys", "row", "tag", "KEY", "code", "cond", "ca", "pair", "res", "ek", "pri", "Key", "client", "tk", "kw", "context", "ack", "by", "out"], "pkt": ["phpgt", "pkg", "perkt", "Packet", "pct", "Pmsg", "ppet", " pkg", "wpkt", "ipnt", "packkt", "ipmsg", "phpkt", "pet", "ipkt", "pingkg", "peracket", "ipet", "pakg", "phpqt", "ipct", "pingcmd", "pacmd", "paet", "paynt", " pqt", "pingacket", "paymsg", " packet", "packacket", "payet", " pett", "phpacket", "pingkt", "tpkt", "ipacket", "Pet", "pqt", "packqt", "perkg", "pett", "pernt", "wpkl", "pcmd", "paykl", "paykg", "pnt", "paett", "packet", " pet", "tpct", "ppkg", "wpacket", "pgt", "pkl", "ppacket", "ipkg", "tpacket", "payett", " pcmd", "ppct", " pct", "wpmsg", " pnt", "tpet", "payacket", " pgt", "paacket", "Pkt", "pakt", "packct", "pmsg", "ppkt", "paykt", " pmsg", " pkl", "ppnt", "packgt"], "conn": ["conf", "p", "connected", "gt", "pkg", "nt", "connection", "txt", "cur", "ns", " mc", " cc", "adj", "connect", "net", "db", "n", "nc", "cmd", "cp", "ch", "ach", "nn", "ctx", "con", "pas", "obj", "Conn", "j", "mem", "proc", "enc", "nw", "num", "auth", "sys", "canon", "ait", "pub", "ctr", "org", "att", "lang", "cb", "cert", "good", " win", "ne", "np", "rn", "conv", "exec", "ct", "rt", "reg", " con", "t", "oss", "pg", "sync", "gate", "comm", "ann", "cell", "ssl", "resp", "gen", "g", "buf", "jp", "cfg", " ssh", "win", "addr", "client"]}}
{"project": "FFmpeg", "commit_id": "6c77805fc84a63b74e5025b4d7eeea24c8138cf3", "target": 0, "func": "enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)\n\n{\n\n    int i;\n\n    for(i=0; i<4 && tags[i]; i++){\n\n        enum CodecID id= codec_get_id(tags[i], tag);\n\n        if(id!=CODEC_ID_NONE) return id;\n\n    }\n\n    return CODEC_ID_NONE;\n\n}\n", "idx": 4610, "substitutes": {"tags": ["flags", "tests", "uts", "strings", "phones", "tracks", "times", "atts", "finals", "ps", "vs", "relations", "ugs", "nets", "links", "sets", "words", "pieces", "amps", "fields", "pins", "aws", "lists", "styles", "maps", "blocks", "lights", "Tags", "keys", "products", "images", "ts", "stats", "reports", "marks", "waves", "bugs", "values", "orders", "ims", "workers", "cards", "terms", "pages", "ats", "weights", "ags", "cats", "guards"], "tag": ["key", "t", "Tag", "pack", "tmp", "id", "cat", "sum", "image", "ad", "bug", "tar", "ag", "map", "node", "version", "attribute", "word", "format", "state", "name", "comment", "at", "type", "ref", "row", "category", "match", "bit", "unit", "pair", "flag", "byte", "var", "count", "oid", "feat", "block", "out", "TAG", "event", "big"], "i": [" m", " I", "t", "li", "init", " err", " multi", "sim", "ki", "fi", "bi", "is", "f", "id", "ind", "v", " ni", "ini", "ii", "mi", "ix", " bi", " pi", "it", " it", "ic", "gu", "q", "\u0438", "hi", "uri", " init", "si", "j", "di", "h", "gi", "span", "io", "in", "chain", "ip", "ex", "ji", "index", "point", "g", " v", "multi", "iu", "ui", "xi", "y", "zi", "print", "e", " ti", "ci", "m", "ti", "ai", "pi", " j", "ims", " mi", "x", "I", "phi", "im", "qi", "cli", "z", "go", " ii"]}}
{"project": "qemu", "commit_id": "27e0c9a1bbd166a67c16291016fba298a8e47140", "target": 0, "func": "static void ide_atapi_identify(IDEState *s)\n\n{\n\n    uint16_t *p;\n\n\n\n    if (s->identify_set) {\n\n\tmemcpy(s->io_buffer, s->identify_data, sizeof(s->identify_data));\n\n\treturn;\n\n    }\n\n\n\n    memset(s->io_buffer, 0, 512);\n\n    p = (uint16_t *)s->io_buffer;\n\n    /* Removable CDROM, 50us response, 12 byte packets */\n\n    put_le16(p + 0, (2 << 14) | (5 << 8) | (1 << 7) | (2 << 5) | (0 << 0));\n\n    padstr((char *)(p + 10), s->drive_serial_str, 20); /* serial number */\n\n    put_le16(p + 20, 3); /* buffer type */\n\n    put_le16(p + 21, 512); /* cache size in sectors */\n\n    put_le16(p + 22, 4); /* ecc bytes */\n\n    padstr((char *)(p + 23), s->version, 8); /* firmware version */\n\n    padstr((char *)(p + 27), \"QEMU DVD-ROM\", 40); /* model */\n\n    put_le16(p + 48, 1); /* dword I/O (XXX: should not be set on CDROM) */\n\n#ifdef USE_DMA_CDROM\n\n    put_le16(p + 49, 1 << 9 | 1 << 8); /* DMA and LBA supported */\n\n    put_le16(p + 53, 7); /* words 64-70, 54-58, 88 valid */\n\n    put_le16(p + 62, 7);  /* single word dma0-2 supported */\n\n    put_le16(p + 63, 7);  /* mdma0-2 supported */\n\n#else\n\n    put_le16(p + 49, 1 << 9); /* LBA supported, no DMA */\n\n    put_le16(p + 53, 3); /* words 64-70, 54-58 valid */\n\n    put_le16(p + 63, 0x103); /* DMA modes XXX: may be incorrect */\n\n#endif\n\n    put_le16(p + 64, 3); /* pio3-4 supported */\n\n    put_le16(p + 65, 0xb4); /* minimum DMA multiword tx cycle time */\n\n    put_le16(p + 66, 0xb4); /* recommended DMA multiword tx cycle time */\n\n    put_le16(p + 67, 0x12c); /* minimum PIO cycle time without flow control */\n\n    put_le16(p + 68, 0xb4); /* minimum PIO cycle time with IORDY flow control */\n\n\n\n    put_le16(p + 71, 30); /* in ns */\n\n    put_le16(p + 72, 30); /* in ns */\n\n\n\n    if (s->ncq_queues) {\n\n        put_le16(p + 75, s->ncq_queues - 1);\n\n        /* NCQ supported */\n\n        put_le16(p + 76, (1 << 8));\n\n    }\n\n\n\n    put_le16(p + 80, 0x1e); /* support up to ATA/ATAPI-4 */\n\n#ifdef USE_DMA_CDROM\n\n    put_le16(p + 88, 0x3f | (1 << 13)); /* udma5 set and supported */\n\n#endif\n\n    memcpy(s->identify_data, p, sizeof(s->identify_data));\n\n    s->identify_set = 1;\n\n}\n", "idx": 4611, "substitutes": {"s": ["t", "os", "S", "sports", "ds", "details", "south", "is", "d", "ms", "r", "ps", "vs", "ins", "spec", "ies", "sl", "less", "set", "ss", "h", "aws", "comm", "changes", "bs", "i", "js", "ns", "hs", "source", "ex", "sq", "rates", "sys", "an", "ses", "sts", "g", "rs", "gs", "y", "ts", "es", "stats", "its", "fs", "bis", "sv", "cs", "ims", "sb", "c", "als", "parts", "ls", "as", "settings", "n", "qs", "ats", "se", "sw"], "p": ["vp", "pp", "t", "cp", "pkg", "lp", "f", "v", "sp", "ps", "pc", "mp", "ping", "post", "q", "pg", "wp", "pm", "pa", "pro", "h", "j", "br", "power", "php", "self", "port", "i", "ip", "ap", "proc", "np", "b", "result", "err", "point", "g", "at", "pb", "per", "pers", "pr", "peer", "fp", "tp", "dp", "op", "jp", "ar", "perm", "m", "new", "after", "up", "P", "bp", "pi", "x", "pid", "c", "pe", "xp", "local", "er", "pre", "cache"]}}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "static int kvm_put_xsave(CPUState *env)\n\n{\n\n#ifdef KVM_CAP_XSAVE\n\n    int i, r;\n\n    struct kvm_xsave* xsave;\n\n    uint16_t cwd, swd, twd, fop;\n\n\n\n    if (!kvm_has_xsave())\n\n        return kvm_put_fpu(env);\n\n\n\n    xsave = qemu_memalign(4096, sizeof(struct kvm_xsave));\n\n    memset(xsave, 0, sizeof(struct kvm_xsave));\n\n    cwd = swd = twd = fop = 0;\n\n    swd = env->fpus & ~(7 << 11);\n\n    swd |= (env->fpstt & 7) << 11;\n\n    cwd = env->fpuc;\n\n    for (i = 0; i < 8; ++i)\n\n        twd |= (!env->fptags[i]) << i;\n\n    xsave->region[0] = (uint32_t)(swd << 16) + cwd;\n\n    xsave->region[1] = (uint32_t)(fop << 16) + twd;\n\n    memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,\n\n            sizeof env->fpregs);\n\n    memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,\n\n            sizeof env->xmm_regs);\n\n    xsave->region[XSAVE_MXCSR] = env->mxcsr;\n\n    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv;\n\n    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,\n\n            sizeof env->ymmh_regs);\n\n    r = kvm_vcpu_ioctl(env, KVM_SET_XSAVE, xsave);\n\n    qemu_free(xsave);\n\n    return r;\n\n#else\n\n    return kvm_put_fpu(env);\n\n#endif\n\n}\n", "idx": 4615, "substitutes": {"env": ["et", "conf", "conn", "cur", "self", "forge", "ah", "net", "vm", "db", "esp", "them", "er", "viron", "cmd", "event", "uv", "eas", "ptr", "extra", "query", "gear", "dev", "rod", "environment", "draw", "worker", "ctx", "vs", "vert", "inv", "obj", "ew", "en", "h", "export", "ve", "esm", "eng", "proc", "exc", "pb", "enc", "code", "ent", "sb", "context", "shell", "entry", "config", "esc", "org", "cb", "ext", "nv", "era", "here", "manager", "e", "end", "te", "ov", "var", "qt", "ef", "ev", "vt", "va", "assets", "vp", "doc", "disk", "cv", "her", "v", "ec", "enter", "pg", "server", "req", "gate", "ee", "info", "buf", "erd", "addr", "hw", "window", "desc"], "i": ["t", "li", "ei", "p", "sim", "bi", "f", "id", "ind", "v", "ii", "ini", "l", "d", "mi", "ix", "me", "it", "ic", "q", "\u0438", "w", "si", "k", "j", "di", "h", "port", "gi", "o", "ri", "in", "size", "chain", "ip", "ie", "b", "info", "g", "ui", "multi", "iu", "xi", "y", "zi", "e", "ti", "ci", "m", "ami", "ai", "pi", "x", "I", "phi", "qi", "c", "s", "n", "u", "mc"], "r": ["rc", "dr", "t", "p", "f", "d", "l", "v", "re", "R", "er", "it", "rr", "q", "w", "k", "h", "ry", "br", "sr", "cr", "rg", "result", "b", "g", "pr", "rs", "rf", "rar", "ir", "y", "ar", "rn", "e", "m", "res", "rd", "x", "c", "s", "n", "rt", "rb", "u", "mr"], "xsave": ["xxsave", "xpave", "xgo", "ixsav", "mxsave", "Xsave", "ixsee", "xexport", "txsav", "oxsav", "lexdestroy", "axave", "rxsav", "xmlsave", "xpsav", "xsee", "mxclose", "xstore", " xsubmit", "exexport", "xscale", "uxsav", "ixave", "rxuse", "xxave", "txsave", "xdelete", "xmldelete", "Xsav", "xpnew", "oxuse", "exscale", "mximport", "uxgoal", "rxsave", "xpgoal", " xset", "plexuse", "txset", "xmlgo", "ixscale", "Xset", "ixexport", "ixclose", "xmlclose", "exsave", "axdelete", "xpsend", "xxsend", "ixsubmit", "plexdestroy", "lexsubmit", "exsav", "wxstore", "xpsubmit", "iximport", "exclose", "dxsubmit", "uxdestroy", "axsave", "lexsav", "oxstore", "xclose", "xgoal", "uxsee", "ixdestroy", "xpsave", "xmlgoal", "oxgoal", "wxsave", "xmlexport", "dxclose", " xsend", "axgoal", "xsend", "xset", "xnew", "Xnew", "xmlnew", "uxsubmit", "xave", "xuse", "xxsav", "uxsave", "oxdelete", "txnew", "oxgo", "exnew", "aximport", "axgo", " xscale", "dxsave", "rxdestroy", "oxsave", "dxsav", "lexgoal", "oxdestroy", "ximport", "lexsee", "mxave", "xsav", "wxave", "plexsav", "xdestroy", "lexnew", "wxsav", "txave", "plexsave", " xnew", " xsav", "xsubmit", "ixsave", "oxave", "txstore", "ixnew", " xave", "lexsave", "axclose", " xclose"], "cwd": ["tcw", "dcds", "cachewd", "ncad", "cw", "tcwl", "rcdir", "ccdir", "ccwd", " cds", "cwid", " cwl", "ncwd", "ccld", " cad", "rcw", " cwa", "cov", "cud", "fld", "fdir", "rcov", "ccud", "tcwid", "cachew", "dcwd", "cad", "tcwd", "cld", "rcwd", "cwl", "ncwa", "dcwa", " cud", "ncov", "ncw", " cld", "cachewl", " cwid", "cdir", "ncds", "dcad", "ncdir", "cds", "fwd", "fud", "cwa", " cov", " cdir", "cachewid", " cw"], "swd": ["twm", "wnfd", "twl", "wndl", "awfd", "wnm", "swdl", "wnds", "smp", "twp", " swds", "ewd", "swwd", "smfd", "ewt", "twD", " swt", "awdl", "ewD", "awds", " swfd", "awp", "awl", "awwd", "twds", "twfd", "twdl", "swt", "awd", "swm", "wnl", "swfd", "smd", "awt", "swl", "awm", "awD", "ewds", " swD", "swds", "wnd", "swD", " swl", "twwd", "swp", "smwd"], "twd": ["twm", "sdds", "twl", "sww", " twm", "tfd", "sdw", " twds", "whl", " twad", "sdd", "tfad", "tfp", "twp", "trd", "tww", " twl", "trp", "swad", " twp", "tfl", "whw", "sdl", "twds", "swm", "twad", "trm", "tfds", "swl", "trds", "swds", "whds", "swp", "whd"], "fop": ["vopl", "flip", "wOP", "flhop", "fOP", "wop", "flopt", "vop", "vip", "frop", "fopp", "dop", "vhop", "flOP", "wrop", "flop", "bfhop", "bfop", "fhop", " fopp", "fopt", " fhop", "vOP", " fops", "bfops", " fopl", "dopl", "vrop", "fip", "dopp", "flrop", "flops", "fops", "dhop", " fopt", "bfopt", "wip", "vopp", "fopl"]}}
{"project": "FFmpeg", "commit_id": "57d04d3f11290d1848efa3b47031762f936d4cb3", "target": 1, "func": "static inline void blockCopy(uint8_t dst[], int dstStride, uint8_t src[], int srcStride,\n\n\tint numLines, int levelFix)\n\n{\n\n\tint i;\n\n\tif(levelFix)\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\t\t\t\tasm volatile(\n\n\t\t\t\t\t\t\"movl %4, %%eax \\n\\t\"\n\n\t\t\t\t\t\t\"movl %%eax, temp0\\n\\t\"\n\n\t\t\t\t\t\t\"pushl %0 \\n\\t\"\n\n\t\t\t\t\t\t\"pushl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"leal (%2,%2), %%eax\t\\n\\t\"\n\n\t\t\t\t\t\t\"leal (%3,%3), %%ebx\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYOffset, %%mm2\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYScale, %%mm3\t\\n\\t\"\n\n\t\t\t\t\t\t\"pxor %%mm4, %%mm4\t\\n\\t\"\n\n\n\n#define SCALED_CPY\t\t\t\t\t\\\n\n\t\t\t\t\t\t\"movq (%0), %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq (%0,%2), %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psubusb %%mm2, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psubusb %%mm2, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"punpcklbw %%mm4, %%mm0 \\n\\t\"\\\n\n\t\t\t\t\t\t\"punpckhbw %%mm4, %%mm5 \\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"packuswb %%mm5, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, (%1)\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"punpcklbw %%mm4, %%mm1 \\n\\t\"\\\n\n\t\t\t\t\t\t\"punpckhbw %%mm4, %%mm5 \\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"packuswb %%mm5, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, (%1, %3)\t\\n\\t\"\\\n\n\n\n\t\t\t\t\t\t\"1:\t\t\t\\n\\t\"\n\nSCALED_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\nSCALED_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"decl temp0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"jnz 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\t\t\t\"popl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"popl %0 \\n\\t\"\n\n\t\t\t\t\t\t: : \"r\" (src),\n\n\t\t\t\t\t\t\"r\" (dst),\n\n\t\t\t\t\t\t\"r\" (srcStride),\n\n\t\t\t\t\t\t\"r\" (dstStride),\n\n\t\t\t\t\t\t\"m\" (numLines>>2)\n\n\t\t\t\t\t\t: \"%eax\", \"%ebx\"\n\n\t\t\t\t\t);\n\n#else\n\n\t\t\t\tfor(i=0; i<numLines; i++)\n\n\t\t\t\t\tmemcpy(\t&(dst[dstStride*i]),\n\n\t\t\t\t\t\t&(src[srcStride*i]), BLOCK_SIZE);\n\n#endif\n\n\t}\n\n\telse\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\t\t\t\tasm volatile(\n\n\t\t\t\t\t\t\"movl %4, %%eax \\n\\t\"\n\n\t\t\t\t\t\t\"movl %%eax, temp0\\n\\t\"\n\n\t\t\t\t\t\t\"pushl %0 \\n\\t\"\n\n\t\t\t\t\t\t\"pushl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"leal (%2,%2), %%eax\t\\n\\t\"\n\n\t\t\t\t\t\t\"leal (%3,%3), %%ebx\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYOffset, %%mm2\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYScale, %%mm3\t\\n\\t\"\n\n\n\n#define SIMPLE_CPY\t\t\t\t\t\\\n\n\t\t\t\t\t\t\"movq (%0), %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq (%0,%2), %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, (%1)\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, (%1, %3)\t\\n\\t\"\\\n\n\n\n\t\t\t\t\t\t\"1:\t\t\t\\n\\t\"\n\nSIMPLE_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\nSIMPLE_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"decl temp0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"jnz 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\t\t\t\"popl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"popl %0 \\n\\t\"\n\n\t\t\t\t\t\t: : \"r\" (src),\n\n\t\t\t\t\t\t\"r\" (dst),\n\n\t\t\t\t\t\t\"r\" (srcStride),\n\n\t\t\t\t\t\t\"r\" (dstStride),\n\n\t\t\t\t\t\t\"m\" (numLines>>2)\n\n\t\t\t\t\t\t: \"%eax\", \"%ebx\"\n\n\t\t\t\t\t);\n\n#else\n\n\t\t\t\tfor(i=0; i<numLines; i++)\n\n\t\t\t\t\tmemcpy(\t&(dst[dstStride*i]),\n\n\t\t\t\t\t\t&(src[srcStride*i]), BLOCK_SIZE);\n\n#endif\n\n\t}\n\n}\n", "idx": 4639, "substitutes": {"dst": ["lst", "sst", "edost", "dt", "dct", "delpt", " dsts", "sdtd", "edct", "mtd", "sdst", "edst", "mnt", "lpt", "Dtd", "ltd", "st", "Dst", "dost", "sdnt", "mst", "edsts", "mt", "Dct", " dct", "std", "snt", "dnt", "delst", "sdt", "dtd", "Dost", "Dsts", "dpt", "Dpt", "lsts", "deltd", " dost", "delsts", "dsts"], "dstStride": ["dstRestide", "dstStrrid", "dstStoreride", "dntStide", "dndStrict", "dntStrrid", "dstRestitch", "dstRestrip", "dstStoreide", "dndStrride", "dstEstr", "dstRestride", "dndStitch", "dstRestrict", "dstSTr", "dststride", "dstSTridden", "dstStide", "dndRestrip", "dstRestr", "dntStridden", "dstStrridden", "dstStrride", "dstStitch", "dstSTrid", "dstSTide", "dndStr", "dstStridden", "dstSTitch", "dntStrridden", "dstStorerid", "dntStrid", "dndStrrip", "dndRestitch", "dstStrrict", "dststrict", "dndStrip", "dndRestr", "dstEstitch", "dndRestride", "dndStide", "dndStride", "dstStoreridden", "dstSTrip", "dststrip", "dstEstride", "dststide", "dstEstrip", "dstStrip", "dstStr", "dndStrrict", "dstStrrip", "dstStrid", "dstSTride", "dntStride", "dstStrict", "dntStrride"], "src": ["rc", "sc", "ser", "syn", "tmp", "dest", "sel", "r", "ins", "sync", "rl", "inst", "sub", "txt", "cb", "sl", "str", "cur", "loc", "trans", "ss", "st", "supp", "sr", "in", "bs", "source", "ssl", "usr", "sq", "sys", "sh", "std", "sts", "rs", "sn", "rel", "sv", "sb", "hl", "rt", "sur", "stream", "sw"], "srcStride": ["srcStrride", "srcstru", "stSide", "srcChride", "srcSTro", "stStrid", "stStide", "srcStri", "srcRestrid", "sourceStri", "srcStro", "sbStride", "srcRestri", "sbSTrid", "srcSrid", "srcstride", "stStru", "srcStide", "srcSru", "srcStrrid", "srcRestide", "srcSide", "srcSTride", "srcSTide", "srcDescride", "srcSTri", "srcRestride", "srcRestate", "sourceSTride", "srcState", "srcChate", "sbStrid", "sourceStide", "srcDescrid", "srcStrri", "srcSTate", "sourceStrid", "srcStru", "srcChrid", "sbSTate", "sourceStride", "srcStrid", "srcRestro", "stSru", "srcSTrid", "srcstrid", "sbStro", "sbSTro", "srcChro", "sourceSTri", "srcDescru", "sbState", "stStride", "sourceSTrid", "srcSride", "sourceSTide", "stSride", "srcstide", "srcDescide", "sbSTride", "stSrid"], "numLines": ["numLocks", "numCLlines", "numLites", "numBLines", "numDLites", "numLine", "numDLlines", "numCLines", "numCLists", " numLists", "numBllines", "numRine", "numRists", "numCLelines", " numLlines", "numBlines", "numBlocks", "numRines", "numRelines", "numBLlines", "numRlines", "numBLocks", " numLine", " numLelines", " numLites", " numLocks", "numBLine", "numBlites", "numDLocks", "numLists", "numLlines", "numRocks", "numDLines", "numLelines"], "levelFix": ["stylefix", "levelfix", " levelfix", "LevelFix", "levelChange", " levelAdjust", "styleAdd", "depthFix", " levelAdd", " levelChange", "lvlChange", "styleFix", "levelAdjust", "depthChange", "LevelAdjust", "styleAdjust", "Levelfix", "LevelAdd", "levelAdd", "lvlFix"], "i": ["mc", "key", " m", " I", "ei", "li", "ski", "json", " multi", "sim", " iter", "ki", "bi", "is", "ms", "ii", " ni", "ini", "mi", " pos", " bi", " pi", "me", "it", " my", "ix", "ic", "gu", "\u0438", "asi", "hi", "si", " p", "di", "j", "oi", "gi", "span", "ri", "in", "iq", "ip", "chain", " li", "index", "info", "g", "ui", " si", "multi", "iu", "xi", "zi", "status", " ti", "ci", "ti", "m", " counter", "ai", "pi", " j", " index", " mi", " di", "I", "ims", "qi", "cli", "phi", "series", " ii", "batch"]}}
{"project": "qemu", "commit_id": "ff5ce21e1b959206f257967d6de2efa6f4e3d188", "target": 1, "func": "build_tpm2(GArray *table_data, BIOSLinker *linker)\n\n{\n\n    Acpi20TPM2 *tpm2_ptr;\n\n\n\n    tpm2_ptr = acpi_data_push(table_data, sizeof *tpm2_ptr);\n\n\n\n    tpm2_ptr->platform_class = cpu_to_le16(TPM2_ACPI_CLASS_CLIENT);\n\n    tpm2_ptr->control_area_address = cpu_to_le64(0);\n\n    tpm2_ptr->start_method = cpu_to_le32(TPM2_START_METHOD_MMIO);\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)tpm2_ptr, \"TPM2\", sizeof(*tpm2_ptr), 4, NULL, NULL);\n\n}\n", "idx": 4645, "substitutes": {"tpm2_ptr": ["tpm1_tr", "tpm2_tch", "tpm1_pointers", "tpmto___ptr", "tpm2__obj", "tpm1_req", "tpm2___ptr", "tpm2_tr", "tpm2_th", "tpm02_pointer", "tpm2___Ptr", "tpm2_obj", "tpm1_env", "tpm12_req", "tpm2ptptr", "tpm2___ctr", "tpm2ptenv", "tpm2__ptr", "tpmto___Ptr", "tpm2__tr", "tpm12_tch", "tpm2ptaddr", "tpm02_ptr", "tpm2_env", "tpm2___obj", "tpm2_pointer", "tpm2__pointer", "tpm2_ctr", "tpm3_tr", "tpm2_Ptr", "tpm2__req", "tpm1_obj", "tpm3_obj", "tpm3_ptr", "tpmto___obj", "tpmto_ptr", "tpm2_req", "tpm02_obj", "tpm1_addr", "tpm3_Ptr", "tpm1_ptr", "tpmto___ctr", "tpm3_pointer", "tpmto_obj", "tpm12_obj", "tpm2_pointers", "tpm2_p", "tpmto_ctr", "tpmto_Ptr", "tpm02_p", "tpm2ptpointers", "tpm2_addr", "tpm2__p", "tpm12_ptr"]}}
{"project": "FFmpeg", "commit_id": "ae93965359e71c1f88ba170f8efd6a198344c235", "target": 1, "func": "int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush)\n\n{\n\n    do {\n\n        int nb_output = 0;\n\n        int min_poc   = INT_MAX;\n\n        int i, min_idx, ret;\n\n\n\n        if (s->sh.no_output_of_prior_pics_flag == 1) {\n\n            for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n\n                HEVCFrame *frame = &s->DPB[i];\n\n                if (!(frame->flags & HEVC_FRAME_FLAG_BUMPING) && frame->poc != s->poc &&\n\n                        frame->sequence == s->seq_output) {\n\n                    ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);\n\n                }\n\n            }\n\n        }\n\n\n\n        for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n\n            HEVCFrame *frame = &s->DPB[i];\n\n            if ((frame->flags & HEVC_FRAME_FLAG_OUTPUT) &&\n\n                frame->sequence == s->seq_output) {\n\n                nb_output++;\n\n                if (frame->poc < min_poc) {\n\n                    min_poc = frame->poc;\n\n                    min_idx = i;\n\n                }\n\n            }\n\n        }\n\n\n\n        /* wait for more frames before output */\n\n        if (!flush && s->seq_output == s->seq_decode && s->sps &&\n\n            nb_output <= s->sps->temporal_layer[s->sps->max_sub_layers - 1].num_reorder_pics)\n\n            return 0;\n\n\n\n        if (nb_output) {\n\n            HEVCFrame *frame = &s->DPB[min_idx];\n\n            AVFrame *dst = out;\n\n            AVFrame *src = frame->frame;\n\n            const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);\n\n            int pixel_shift = !!(desc->comp[0].depth_minus1 > 7);\n\n\n\n            ret = av_frame_ref(out, src);\n\n            if (frame->flags & HEVC_FRAME_FLAG_BUMPING)\n\n                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT | HEVC_FRAME_FLAG_BUMPING);\n\n            else\n\n                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            for (i = 0; i < 3; i++) {\n\n                int hshift = (i > 0) ? desc->log2_chroma_w : 0;\n\n                int vshift = (i > 0) ? desc->log2_chroma_h : 0;\n\n                int off = ((frame->window.left_offset >> hshift) << pixel_shift) +\n\n                          (frame->window.top_offset   >> vshift) * dst->linesize[i];\n\n                dst->data[i] += off;\n\n            }\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"Output frame with POC %d.\\n\", frame->poc);\n\n            return 1;\n\n        }\n\n\n\n        if (s->seq_output != s->seq_decode)\n\n            s->seq_output = (s->seq_output + 1) & 0xff;\n\n        else\n\n            break;\n\n    } while (1);\n\n\n\n    return 0;\n\n}\n", "idx": 4668, "substitutes": {"s": ["p", "conf", "https", "times", "sl", "gets", "self", "ains", "ns", "sq", "current", "ses", "gs", "sym", "stats", "comments", "its", "ims", "c", "settings", "n", "qs", "sort", "services", "S", "a", "ps", "ins", "scope", "obj", "w", "less", "ss", "sf", "h", "changes", "js", "b", "ashes", "sts", "ts", "ops", "this", "fs", "snap", "session", "sb", "series", "ats", "sys", "states", "sa", "details", "f", "is", "sam", "events", "aws", "span", "bs", "space", "source", "sg", "rs", "sample", "e", "m", "cs", "as", "ls", "t", "os", "ds", "south", "ms", "v", "spec", "to", "set", "comm", "in", "hs", "an", "g", "store", "es", "actions", "sv", "parts", "se", "sw"], "out": ["screen", "t", "os", "gt", "ch", "tmp", "f", "OUT", "v", "to", "ctx", "list", "file", "obj", "w", "set", "outs", "o", "output", "in", "io", "ns", "js", "b", "result", "err", "point", "at", "buf", "g", "ref", "y", "ot", "pool", "new", "res", "conv", "table", "cs", "window", "x", "aux", "c", "us", "client", "Out", "n", "sys", "cmd"], "i": ["key", "p", "ori", "id", "ii", "ini", "it", "q", "my", "hi", "di", "gi", "iq", "y", "remote", "iter", "ci", "ims", "qi", "cli", "n", " ii", "json", "ei", "ix", "list", "ic", "any", "si", "oi", "j", "h", "ji", "index", "zi", "record", "instance", "try", "pi", "x", "phi", "is", "f", "ind", "mi", "span", "ri", "ip", "point", "multi", "ti", "m", "ai", "im", "I", "init", "li", "sim", "ki", "fi", "bi", "v", "to", "me", "\u0438", "in", "history", "info", "g", "ui", "iu", "xi", "ij", "window", "client", "batch"], "min_idx": ["min_endp", "min_bidx", "min_idxs", "min_fdxs", "min_idc", "min_endx", "min_pidxs", "min_idl", "min_fdx", "min_endindex", "min_Idxs", "min_Idxc", "min_pidl", "min___idx", "min_bidxc", "min_fdix", "min___indexc", "min_idy", "min_idix", "min_bidxs", "min_pidx", "min_Idc", "min_indexp", "min_Idix", "min_fdl", "min___indexx", "min_indexy", "min_indexx", "min_endy", "min_Idp", "min_Idindex", "min_bidindex", "min_pidix", "min___indexp", "min_Idy", "min_Idx", "min_Idl", "min_endxc", "min___idc", "min_idxc", "min___idp", "min_idp", "min_endxs", "min___idy", "min_indexc", "min_endc", "min_idindex", "min___indexy"], "ret": ["reset", "elt", "gt", "dt", "tmp", "ll", "full", "RET", "rm", "nt", "re", "Ret", "it", "ft", "Return", "rets", "txt", "val", "j", "mem", "mt", "resp", "result", "def", "err", "sys", "buf", "ref", "status", "print", "res", "rel", "tr", "bin", "alt", "rt"], "frame": ["fr", "family", "fram", "join", "filter", "file", "field", "call", "send", "one", "show", "reason", "slice", "term", "response", "interface", "range", "row", "remote", "target", "movie", "page", "user", "queue", "message", "rame", "ence", "event", "embed", "ace", "forced", "draw", "list", "profile", "word", "proc", "def", "ref", "buffer", "code", "flow", "instance", "ce", "session", "header", "seq", "shot", "feat", "block", "request", "reset", "iframe", "f", "component", "image", "version", "chain", "source", "format", "we", "state", "feature", "point", "type", "fe", "command", "process", "e", " Frame", "framework", "sequence", "foo", "owner", "fire", "close", "function", "scene", "relation", "cast", "form", "use", "ze", "channel", "position", "force", "set", "style", "module", "link", "role", "trace", "step", "are", "Frame", "front", "document", "face", "cf", "line", "base", "zone", "window", "video", "next"], "nb_output": ["nb___write", "nb_position", "nb_write", "nie_output", "NR_write", "nb_written", "NR_output", "nie____written", "nb___output", "nb____input", "bh_exit", "nie_input", "nb_response", "nie____input", "nie____write", "nb___exit", "nie____output", "nb_exit", "nie_write", "nb_Output", "NB_exit", "nb____write", "bh_Output", "nb___config", "NB_output", "NB_position", "nb____written", "NB_Output", "nb____output", "nb_config", "nb___Output", "nb_input", "nie_written", "NR_config", "nb___position", "NR_Output", "bh_response", "bh_output"], "dst": ["tst", "Dbr", "dbr", "tbr", "Dst", "tot", "Ddest", " dot", "ddest", " dbr", "Dot", "dot", "tdest", " ddest"], "src": ["ptr", "rc", "sc", "fr", "init", "ser", "tmp", "config", "dest", "sec", "sel", "sup", "spec", "rl", "inst", "sub", "sl", "txt", "loc", "str", "obj", "req", "sf", "supp", "st", "sr", "in", "fc", "source", "proc", "usr", "sq", "comp", "slice", "std", "rs", "stock", "rel", "conv", "addr", "sb", "seq", "rt", "aux", "feat", "sys", "load", "img"], "desc": ["sc", "rc", "doc", "dr", "dev", "DES", "ds", "sec", "dest", "esc", "dist", "d", "ec", "col", "dc", "txt", "loc", "pro", "description", "asc", "req", "dict", "def", "dir", "comp", "buf", "ref", "decl", "cmp", "rec", "Desc", "vec", "disc", "des", "feat", "dep"]}}
{"project": "FFmpeg", "commit_id": "4b9ac0b5f070f35eff671d83cee436db40631112", "target": 0, "func": "static int mpegaudio_parse(AVCodecParserContext *s1,\n\n                           AVCodecContext *avctx,\n\n                           uint8_t **poutbuf, int *poutbuf_size, \n\n                           const uint8_t *buf, int buf_size)\n\n{\n\n    MpegAudioParseContext *s = s1->priv_data;\n\n    int len, ret;\n\n    uint32_t header;\n\n    const uint8_t *buf_ptr;\n\n\n\n    *poutbuf = NULL;\n\n    *poutbuf_size = 0;\n\n    buf_ptr = buf;\n\n    while (buf_size > 0) {\n\n\tlen = s->inbuf_ptr - s->inbuf;\n\n\tif (s->frame_size == 0) {\n\n            /* special case for next header for first frame in free\n\n               format case (XXX: find a simpler method) */\n\n            if (s->free_format_next_header != 0) {\n\n                s->inbuf[0] = s->free_format_next_header >> 24;\n\n                s->inbuf[1] = s->free_format_next_header >> 16;\n\n                s->inbuf[2] = s->free_format_next_header >> 8;\n\n                s->inbuf[3] = s->free_format_next_header;\n\n                s->inbuf_ptr = s->inbuf + 4;\n\n                s->free_format_next_header = 0;\n\n                goto got_header;\n\n            }\n\n\t    /* no header seen : find one. We need at least MPA_HEADER_SIZE\n\n               bytes to parse it */\n\n\t    len = MPA_HEADER_SIZE - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n\t    if (len > 0) {\n\n\t\tmemcpy(s->inbuf_ptr, buf_ptr, len);\n\n\t\tbuf_ptr += len;\n\n\t\tbuf_size -= len;\n\n\t\ts->inbuf_ptr += len;\n\n\t    }\n\n\t    if ((s->inbuf_ptr - s->inbuf) >= MPA_HEADER_SIZE) {\n\n            got_header:\n\n\t\theader = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |\n\n\t\t    (s->inbuf[2] << 8) | s->inbuf[3];\n\n\n\n                ret = mpa_decode_header(avctx, header);\n\n                if (ret < 0) {\n\n\t\t    /* no sync found : move by one byte (inefficient, but simple!) */\n\n\t\t    memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n\n\t\t    s->inbuf_ptr--;\n\n                    dprintf(\"skip %x\\n\", header);\n\n                    /* reset free format frame size to give a chance\n\n                       to get a new bitrate */\n\n                    s->free_format_frame_size = 0;\n\n\t\t} else {\n\n                    s->frame_size = ret;\n\n#if 0\n\n                    /* free format: prepare to compute frame size */\n\n\t\t    if (decode_header(s, header) == 1) {\n\n\t\t\ts->frame_size = -1;\n\n                    }\n\n#endif\n\n\t\t}\n\n\t    }\n\n        } else \n\n#if 0\n\n        if (s->frame_size == -1) {\n\n            /* free format : find next sync to compute frame size */\n\n\t    len = MPA_MAX_CODED_FRAME_SIZE - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n            if (len == 0) {\n\n\t\t/* frame too long: resync */\n\n                s->frame_size = 0;\n\n\t\tmemmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n\n\t\ts->inbuf_ptr--;\n\n            } else {\n\n                uint8_t *p, *pend;\n\n                uint32_t header1;\n\n                int padding;\n\n\n\n                memcpy(s->inbuf_ptr, buf_ptr, len);\n\n                /* check for header */\n\n                p = s->inbuf_ptr - 3;\n\n                pend = s->inbuf_ptr + len - 4;\n\n                while (p <= pend) {\n\n                    header = (p[0] << 24) | (p[1] << 16) |\n\n                        (p[2] << 8) | p[3];\n\n                    header1 = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |\n\n                        (s->inbuf[2] << 8) | s->inbuf[3];\n\n                    /* check with high probability that we have a\n\n                       valid header */\n\n                    if ((header & SAME_HEADER_MASK) ==\n\n                        (header1 & SAME_HEADER_MASK)) {\n\n                        /* header found: update pointers */\n\n                        len = (p + 4) - s->inbuf_ptr;\n\n                        buf_ptr += len;\n\n                        buf_size -= len;\n\n                        s->inbuf_ptr = p;\n\n                        /* compute frame size */\n\n                        s->free_format_next_header = header;\n\n                        s->free_format_frame_size = s->inbuf_ptr - s->inbuf;\n\n                        padding = (header1 >> 9) & 1;\n\n                        if (s->layer == 1)\n\n                            s->free_format_frame_size -= padding * 4;\n\n                        else\n\n                            s->free_format_frame_size -= padding;\n\n                        dprintf(\"free frame size=%d padding=%d\\n\", \n\n                                s->free_format_frame_size, padding);\n\n                        decode_header(s, header1);\n\n                        goto next_data;\n\n                    }\n\n                    p++;\n\n                }\n\n                /* not found: simply increase pointers */\n\n                buf_ptr += len;\n\n                s->inbuf_ptr += len;\n\n                buf_size -= len;\n\n            }\n\n\t} else \n\n#endif\n\n        if (len < s->frame_size) {\n\n            if (s->frame_size > MPA_MAX_CODED_FRAME_SIZE)\n\n                s->frame_size = MPA_MAX_CODED_FRAME_SIZE;\n\n\t    len = s->frame_size - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n\t    memcpy(s->inbuf_ptr, buf_ptr, len);\n\n\t    buf_ptr += len;\n\n\t    s->inbuf_ptr += len;\n\n\t    buf_size -= len;\n\n\t}\n\n        //    next_data:\n\n        if (s->frame_size > 0 && \n\n            (s->inbuf_ptr - s->inbuf) >= s->frame_size) {\n\n            *poutbuf = s->inbuf;\n\n            *poutbuf_size = s->inbuf_ptr - s->inbuf;\n\n\t    s->inbuf_ptr = s->inbuf;\n\n\t    s->frame_size = 0;\n\n\t    break;\n\n\t}\n\n    }\n\n    return buf_ptr - buf;\n\n}\n", "idx": 4681, "substitutes": {"s1": ["p0", "js1", "p1", "js0", "s5", "s2", "pOne", "rs1", "rs5", " s2", "js2", "rs2", " s3", " sOne", "s0", "jsOne", "s3", "rs3", "sOne", " s0", " s5", "p2"], "avctx": [" avcontext", "evcontext", "wavctx", "evctx", "averconn", "wavpkg", "wavcontext", "averpkg", "avcfg", " avpkg", "wavconn", "wavcfg", " avcfg", " avconn", "avconn", "avpkg", "evcfg", "avercontext", "avcontext", "averctx", "evconn"], "poutbuf": ["poutbuff", "Poutbuff", "pnvec", "Poutbuffer", "prawbuffer", "pointbuffer", "Pinbuf", "pointbuf", "poutbuffer", "pointcv", "pnbuffer", "Pinvec", "pinbuf", "poutvec", "prawvec", "pinbuff", "Poutbuf", "Poutcb", "Pincb", "pincv", "pinbuffer", "pncb", "Pincv", "pincb", "prawbuf", "pinvec", "Poutvec", "poutcv", "Pinbuff", "pointbuff", "prawcb", "Pinbuffer", "Poutcv", "pnbuf", "poutcb"], "poutbuf_size": ["poutbuffer_size", "poutbuf_num", "poutbuffer_num", "poutbuffer_Size", "poutbuffer_start", "poutbuf_SIZE", "poutbuf_start", "poutbuf_Size", "poutbuffer_SIZE"], "buf": ["ptr", "BU", "cv", "tmp", "OUT", "data", "SIZE", "xff", "msg", "bar", "cb", "Buffer", "RAW", "ff", "buff", "Buff", "bytes", "b", "np", "pb", "ref", "buffer", "alloc", "end", "raw", "vec", "foo", "uf", "queue", "bf", "bin", "broad", "BR", "block", "out", "cmd", "wb"], "buf_size": ["buf0length", "buf67index", "buff_start", "buff_store", "buff_len", "bufmodsent", "buff_length", "buf_index", "buf_store", " buffer_Size", " buf_ize", " buf_index", " buf_length", "buf0store", "bufmodoffset", "buf2ize", "buf1capacity", "buf_Size", "buff1size", "buf_capacity", "buf67length", "bufncapacity", "bufnstart", " buffer_len", "cb_c", "bufnsize", "buf0shape", "buff_size", "buf2Size", "buf0size", "cb_offset", "buf_sent", "bufnlen", "buf2len", "cb_sent", "buf_start", "buf_length", "buff_capacity", "buff1start", "buf1start", "buf_ize", "buff_shape", "buf_c", "buf1len", "bufmodsize", "buf_shape", "buff1len", "buf_len", " buffer_size", "buf2size", "buf1size", " buffer_ize", "buff1capacity", "buf_offset", "buf67ize", "buf67size", "bufmodc", "cb_size"], "s": ["conf", "https", "full", "l", "sl", "gets", "uploads", "ns", "sq", "ses", "gs", "y", "stats", "comments", "its", "ims", "c", "settings", "qs", "n", "z", "er", "eps", "S", "scripts", "a", "ps", "vs", "ins", "less", "ss", "h", "j", "tes", "changes", "i", "js", "b", "http", "sts", "ts", "ops", "browser", "simple", "bits", "fs", "storage", "sb", "als", "ats", "sys", "ers", "states", "sa", "sports", "details", "is", "sam", "aws", "so", "bs", "space", "source", "ex", "state", "rs", "rest", "m", "acs", "bis", "cs", "as", "terms", "ls", "local", "t", "os", "ess", "ds", "south", "ms", "spec", "ies", "sm", "sync", "set", "comm", "hs", "ssl", "g", "store", "status", "es", "sv", "aunts", "parts", "sql", "se", "sw"], "len": ["fn", "l", "nt", "sl", " le", "str", "valid", "iter", "vec", "pl", "L", " alt", "n", "hl", "z", " clen", " el", "compl", "el", "lf", "Len", "ler", "ml", "fun", "en", "lon", "h", "ell", "mem", "ref", "un", "lv", "lic", "vol", "nl", " l", "lim", "limit", "lp", "f", "lc", "fin", "ld", "fl", "size", "comp", " bl", "ls", "del", "alt", "lib", "la", "t", "li", "html", "elt", "lit", "ln", "ll", "le", "length", "col", "els", "val", "dl", "kl", "lt", "il", "rev", "cmp", "late", "lan", "pos", "gl", "err"], "ret": ["t", "reset", "elt", "gt", "tf", "success", "ll", "RET", "arr", "nt", "re", "cont", "Ret", "fin", "ft", "rets", "true", "ext", "ben", "val", "fun", "valid", "rem", "mem", "mt", "result", "lt", "def", "rev", "ref", "ber", "repl", "status", "rect", "res", "det", "tr", "ter", "back", "nl", "alt", "rt", "out"], "header": ["key", "dr", "fr", "t", "html", "dt", "lp", "heading", "data", "lr", "token", "filter", "question", "rr", "hash", "prefix", "msg", "tar", "txt", " HDR", "offset", "version", "description", "h", "package", "body", "format", "metadata", "layer", "result", "section", "index", "name", "definition", "comment", "type", "detail", "tail", "buffer", "tag", "response", "text", "holder", "HEAD", "line", "head", "table", "flag", "headers", "title", "window", "part", "Header", "magic", "timer", "message", "er", "frame", "err", "cmd"], "buf_ptr": [" buf_rel", " buf_tr", "buf_rep", "uf_pointer", "buf_pr", " buf_pos", " buf_pointer", " buf_pr", "uf_pad", "buf_rel", "buffer_tr", "uf_addr", "buf_addr", "buf_pos", "buf_tr", "uf_ptr", "buffer_rep", "buf_pad", "buffer_pointer", "buffer_ptr", "buf_pointer"], "inbuf_ptr": ["inbuffer_ref", "inbufibdesc", "inbox__tr", "inbuf__ptr", "inbuf_Ptr", "inbox__pointer", "inbuf_pointer", "inbox_addr", "inbuffer_vr", "inbuf__tr", "inbuffer_ctr", "inbuf_ctr", "inqueue_addr", "inbr_addr", "inbuffer_tr", "inbuffer_Ptr", "inbox_ptr", "inbox_tr", "inbox__ptr", "inbuf_vr", "inbufibptr", "inqueue_tr", "inbuffer_addr", "inbox__addr", "inbr_req", "inbuf_addr", "inbuf__pointer", "inbox_pointer", "inbufibaddr", "inbuffer_ptr", "inqueue_prime", "inqueue_pointer", "inbr_tr", "inbuf_prime", "inqueue_desc", "inbuf_ref", "inbuffer_pointer", "inbuf_tr", "inbuf_req", "inbr_ptr", "inqueue_ptr", "inbuf_desc", "inbuf__addr", "inbufibprime"]}}
{"project": "FFmpeg", "commit_id": "33d69a90085d30af8a292d9364b835a26565d6b9", "target": 0, "func": "JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)\n\n{\n\n    int ret = 0;\n\n    JNIEnv *env = NULL;\n\n\n\n    *attached = 0;\n\n\n\n    pthread_mutex_lock(&lock);\n\n    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {\n\n\n\n        av_log(log_ctx, AV_LOG_INFO, \"Retrieving current Java virtual machine using Android JniInvocation wrapper\\n\");\n\n        if (check_jni_invocation(log_ctx) == 0) {\n\n            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||\n\n                (java_vm = get_java_vm(\"libdvm.so\", log_ctx)) != NULL ||\n\n                (java_vm = get_java_vm(\"libart.so\", log_ctx)) != NULL) {\n\n                av_log(log_ctx, AV_LOG_INFO, \"Found Java virtual machine using Android JniInvocation wrapper\\n\");\n\n            }\n\n        }\n\n    }\n\n    pthread_mutex_unlock(&lock);\n\n\n\n    if (!java_vm) {\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not retrieve a Java virtual machine\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);\n\n    switch(ret) {\n\n    case JNI_EDETACHED:\n\n        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Failed to attach the JNI environment to the current thread\\n\");\n\n            env = NULL;\n\n        } else {\n\n            *attached = 1;\n\n        }\n\n        break;\n\n    case JNI_OK:\n\n        break;\n\n    case JNI_EVERSION:\n\n        av_log(log_ctx, AV_LOG_ERROR, \"The specified JNI version is not supported\\n\");\n\n        break;\n\n    default:\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Failed to get the JNI environment attached to this thread\");\n\n        break;\n\n    }\n\n\n\n    return env;\n\n}\n", "idx": 4685, "substitutes": {"attached": ["attsanged", "Attachable", "ATTachment", "ATTached", "attenended", "attsadded", "attsached", "attended", "readded", "attsributed", "reachable", "achadded", "attsachable", "achanged", "attenached", "attributed", "ATTributed", "reached", "achached", "attachment", "attadded", "attanged", "attenachable", "attachable", "Attended", "achended", "achachable", "achributed", "Attached", "reanged", "attenachment", "ATTachable", "attsended", "Attachment", "ATTended"], "log_ctx": ["bugptkw", "logtctx", "resource_ctx", " log_gz", "logzcrit", "loglexrect", "Log_context", "Log_cfg", " log_obj", "log_cv", "log_conn", "logptloc", "loggertz", " log_rect", "logzcmp", "logptcv", "logtrec", "logzcfg", " log_rec", "logptcmp", "loggermem", "logtxctx", "logtxtz", "log_rx", "logLogctx", "logptbuf", "logxscope", "logzcontext", "bugptmem", " log_tx", "logxctx", "log_cond", "logxcond", "loglexctx", "log_crit", "loglogcond", "log_cmp", " log_handle", " log_cond", "loglycas", "loglogscope", "log_obj", "logLogtx", "loglexrx", "logtxtxt", " log_rx", "logptctx", "loglyctx", "loggerkw", " log_txt", "logLogcv", "logLoggz", "loglexobj", "logtmem", "resource_cas", "bug_kw", " log_gc", "Log_ctx", "log_buf", "logttx", "logzctx", "log_context", "loggertx", " log_scope", "loggerrec", "logtxhandle", "log_rect", " log_kw", "log_tz", "loggercmp", "logptgc", "loggerctx", "log_gz", "resource_tz", "Log_tz", "log_prefix", "bug_mem", "logptkw", "resourcelytz", "logtcmp", "loglogctx", "loggercfg", "logztx", "logptmem", "log_kw", "bug_cmp", "log_gc", "logpttx", "logtcontext", "resourcelyctx", "logxtx", " log_context", "logptcontext", " log_cv", "logtloc", "log_rec", "log_handle", "logtxconn", "log_mem", "loglogtx", "logtxtx", "loglytz", " log_prefix", "loggercontext", "resource_conn", "bug_ctx", "log_tx", "loglyconn", " log_cmp", "logptgz", "logtxcas", " log_crit", "log_cas", " log_loc", "bugptcmp", "log_txt", "resourcelycas", "log_cfg", "bugptctx", "loggergc", "log_loc", "logztz", "log_scope", "resourcelyconn", "logtbuf", " log_buf", "logtkw"], "env": ["eas", "ptr", "init", "vp", "doc", "entry", "et", "gear", "dev", "elt", "environment", "cv", "tmp", "conn", "eu", "priv", "nil", "v", "ec", "vs", "ctx", "oe", "msg", "inv", "vt", "obj", "cb", "txt", "ext", "server", "ew", "en", "nv", "export", "here", "ve", "attr", "ret", "proc", "result", "def", "name", "ah", "buf", "buffer", "new", "enc", "e", "erd", "end", "instance", "this", "addr", "ov", "ent", "var", "window", "tx", "ef", "kw", "endif", "null", "eh", "context", "dep", "er", "ev", "viron", "err", "cmd"]}}
{"project": "qemu", "commit_id": "4652b8f3e1ec91bb9d6f00e40df7f96d1f1aafee", "target": 1, "func": "static int perform_cow(BlockDriverState *bs, QCowL2Meta *m)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    Qcow2COWRegion *start = &m->cow_start;\n\n    Qcow2COWRegion *end = &m->cow_end;\n\n    unsigned buffer_size;\n\n    unsigned data_bytes = end->offset - (start->offset + start->nb_bytes);\n\n    bool merge_reads;\n\n    uint8_t *start_buffer, *end_buffer;\n\n    QEMUIOVector qiov;\n\n    int ret;\n\n\n\n    assert(start->nb_bytes <= UINT_MAX - end->nb_bytes);\n\n    assert(start->nb_bytes + end->nb_bytes <= UINT_MAX - data_bytes);\n\n    assert(start->offset + start->nb_bytes <= end->offset);\n\n    assert(!m->data_qiov || m->data_qiov->size == data_bytes);\n\n\n\n    if (start->nb_bytes == 0 && end->nb_bytes == 0) {\n\n        return 0;\n\n    }\n\n\n\n    /* If we have to read both the start and end COW regions and the\n\n     * middle region is not too large then perform just one read\n\n     * operation */\n\n    merge_reads = start->nb_bytes && end->nb_bytes && data_bytes <= 16384;\n\n    if (merge_reads) {\n\n        buffer_size = start->nb_bytes + data_bytes + end->nb_bytes;\n\n    } else {\n\n        /* If we have to do two reads, add some padding in the middle\n\n         * if necessary to make sure that the end region is optimally\n\n         * aligned. */\n\n        size_t align = bdrv_opt_mem_align(bs);\n\n        assert(align > 0 && align <= UINT_MAX);\n\n        assert(QEMU_ALIGN_UP(start->nb_bytes, align) <=\n\n               UINT_MAX - end->nb_bytes);\n\n        buffer_size = QEMU_ALIGN_UP(start->nb_bytes, align) + end->nb_bytes;\n\n    }\n\n\n\n    /* Reserve a buffer large enough to store all the data that we're\n\n     * going to read */\n\n    start_buffer = qemu_try_blockalign(bs, buffer_size);\n\n    if (start_buffer == NULL) {\n\n        return -ENOMEM;\n\n    }\n\n    /* The part of the buffer where the end region is located */\n\n    end_buffer = start_buffer + buffer_size - end->nb_bytes;\n\n\n\n    qemu_iovec_init(&qiov, 2 + (m->data_qiov ? m->data_qiov->niov : 0));\n\n\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    /* First we read the existing data from both COW regions. We\n\n     * either read the whole region in one go, or the start and end\n\n     * regions separately. */\n\n    if (merge_reads) {\n\n        qemu_iovec_add(&qiov, start_buffer, buffer_size);\n\n        ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov);\n\n    } else {\n\n        qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        ret = do_perform_cow_read(bs, m->offset, end->offset, &qiov);\n\n    }\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Encrypt the data if necessary before writing it */\n\n    if (bs->encrypted) {\n\n        if (!do_perform_cow_encrypt(bs, m->offset, start->offset,\n\n                                    start_buffer, start->nb_bytes) ||\n\n            !do_perform_cow_encrypt(bs, m->offset, end->offset,\n\n                                    end_buffer, end->nb_bytes)) {\n\n            ret = -EIO;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* And now we can write everything. If we have the guest data we\n\n     * can write everything in one single operation */\n\n    if (m->data_qiov) {\n\n        qemu_iovec_reset(&qiov);\n\n        if (start->nb_bytes) {\n\n            qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        }\n\n        qemu_iovec_concat(&qiov, m->data_qiov, 0, data_bytes);\n\n        if (end->nb_bytes) {\n\n            qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        }\n\n        /* NOTE: we have a write_aio blkdebug event here followed by\n\n         * a cow_write one in do_perform_cow_write(), but there's only\n\n         * one single I/O operation */\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov);\n\n    } else {\n\n        /* If there's no guest data then write both COW regions separately */\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, end->offset, &qiov);\n\n    }\n\n\n\nfail:\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    /*\n\n     * Before we update the L2 table to actually point to the new cluster, we\n\n     * need to be sure that the refcounts have been increased and COW was\n\n     * handled.\n\n     */\n\n    if (ret == 0) {\n\n        qcow2_cache_depends_on_flush(s->l2_table_cache);\n\n    }\n\n\n\n    qemu_vfree(start_buffer);\n\n    qemu_iovec_destroy(&qiov);\n\n    return ret;\n\n}\n", "idx": 4697, "substitutes": {"bs": ["ubs", "lb", "bos", "bps", "ds", "bh", "bi", "bm", "bes", "ms", "aus", "vs", "aos", "cb", "ss", "bles", "js", "ns", "hs", "b", "bb", "BS", "boxes", "ses", "pb", "bl", "sts", "gb", "rs", "gs", "ts", "es", "obs", "bg", "lbs", "ubis", "bits", "fs", "its", "bis", "bp", "cs", "sb", "ls", "sys", "bc", "bd"], "m": ["hm", "gm", "cm", "p", "conf", "sim", "dm", "config", "f", "bm", "d", "ms", "v", "rm", "l", "r", "mi", "me", "mp", "sm", "msg", "pm", "km", "j", "module", "esm", "rem", "mat", "nm", "i", "metadata", "mt", "b", "mac", "met", "md", "mn", "M", "y", "om", "vm", "perm", "e", "mm", "tm", "mod", "c", "am", "n", "man", "managed", "mc", "mr"], "s": ["t", "os", "S", "p", "ds", "is", "ms", "v", "sp", "ps", "sm", "set", "ss", "j", "i", "js", "ns", "hs", "b", "space", "state", "ses", "sts", "rs", "gs", "ts", "sn", "fs", "sv", "cs", "sb", "c", "ls", "n", "sys"], "start": ["get", "key", "p", "save", "art", "id", "it", "error", "q", "ish", "pro", "before", "root", "range", "y", "iter", "first", "pre", "event", "starting", "draw", "data", "app", "check", "st", "kind", "power", "name", "new", "this", "try", "all", "part", "open", "started", "entry", "ind", "need", "trans", "size", "source", "space", "stop", "state", "rest", "match", "rank", "e", "and", "add", "create", "close", "init", "parent", "offset", "set", "style", "time", "in", "begin", "info", "step", "middle", "store", "Start", "addr", "from", "sky", "pos", "next"], "end": ["p", "save", "entity", "it", "send", "each", "only", "east", "eff", "ment", "up", "final", "enable", "End", "rend", "run", "event", "dev", "ended", "except", "data", "app", "vert", "post", "hend", "en", "or", "st", "ell", "export", "eng", "ade", "b", "exc", "comment", "ord", "enc", "edge", "ort", "all", "ent", "open", "last", "entry", "order", "ad", "change", "ext", "good", "until", "ex", "stop", "est", "rest", "wrap", "e", "after", "ed", "ending", "and", "nd", "endif", "create", "add", "close", "max", "v", "ec", "append", "server", "set", "begin", "END", "env", "update"], "buffer_size": [" buffer2Size", " buffer2mode", "buffer_offset", "buffer2size", "buffer2storage", "device_size", " buffer2speed", "Buffer_offset", " buffer_Size", "buffer_rate", " buffer2storage", " buffer2size", "buffer64count", "buffer2info", "buffer64Size", "buffer2SIZE", " buffer_SIZE", "buffer2Size", " buffer_rate", "buffer64size", "buffer64offset", " buffer2SIZE", "device_count", "Buffer_size", "buffer_count", " buffer_speed", "buffer2count", "buffer_info", "buffer2mode", "Buffer_Size", "buffer_mode", "buffer_length", "buffer_name", " buffer_length", " buffer_name", "Buffer_count", " buffer_mode", "device_SIZE", " buffer_storage", "buffer_SIZE", "buffer_speed", "buffer_Size", "buffer_storage", "device_info", "buffer2speed"], "merge_reads": ["merfer_reads", "merge_locks", "mergeingwritten", "mergeablereads", "mergefulchecks", "mergeoutloads", "mergeingreads", "merumeingreads", "merge___requisites", "mergefulread", "mergeableread", "merfer_read", "mergelyreads", "mergeingrows", "merger_checks", "merge___read", "mergeingvalues", "merferlyreads", "mergefulreads", "merume_reads", "merger_read", "merfer_requisites", "mergeoutlocks", "mergelyvalues", "merger_keys", "merumeingwritten", "merge_read", "merge_rows", "merferlyread", "merume_values", "merging_loads", "merfer_values", "merging_reads", "merume_written", "mergingablereads", "merge___reads", "merume_rows", "mergelyrequisites", "mergingableread", "merge_checks", "merferlyrequisites", "merferlyvalues", "mergeoutread", "merge_loads", "mergeableloads", "merger_reads", "merge_values", "mergingablelocks", "mergingableloads", "mergeablelocks", "merge_keys", "merge___values", "merumeingvalues", "mergeoutreads", "merging_locks", "merging_read", "mergelyread", "mergefulkeys", "merge_written", "merumeingrows", "merge_requisites"], "start_buffer": [" start_binary", "start_button", "startablebuffer", "stopabledevice", " start_base", "stopablebutton", "start___base", "startingbutton", " start_cache", "startablestore", "stop_buffer", "start_base", "startablebutton", "start_device", "start_surface", "startingstore", " start_surface", "startabledevice", "start_offset", "stopablebuffer", "start___buffer", "start_binary", "stop_button", "start_cache", "stop_device", " start_device", "start___device", "start___cache", " start_offset", "stop_store", "startingdevice", "startingbuffer", "stopablestore", "start_store"], "end_buffer": ["end_Buffer", "end__buffer", " end_buff", "end_buf", "end_device", " end_buf", "end___buffer", " end_Buffer", "end_cache", "end___cache", "end_buff", "end___Buffer", "end__cache", "end__Buffer", "end__buf", "end___buf", " end_device", " end_cache"], "qiov": ["Qconv", "qiop", "qij", "quconv", "qqiop", "quiev", "Qiov", " qiev", "quij", "qconv", " qij", "qqiov", "qqiev", "quiov", "Qiop", "qiev", "quiop", "Qiev", "qqij", " qiop", " qconv"], "ret": ["et", "elt", "lit", "RET", "re", "Ret", "Return", "str", "val", "rem", "resp", "result", "net", "rev", "status", "rel", "vals", "ter", "flag", "num", "final", " alt", "alt", " resp", "out"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "void sws_rgb2rgb_init(int flags)\n\n{\n\n#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX\n\n    if (flags & SWS_CPU_CAPS_SSE2)\n\n        rgb2rgb_init_SSE2();\n\n    else if (flags & SWS_CPU_CAPS_MMX2)\n\n        rgb2rgb_init_MMX2();\n\n    else if (flags & SWS_CPU_CAPS_3DNOW)\n\n        rgb2rgb_init_3DNOW();\n\n    else if (flags & SWS_CPU_CAPS_MMX)\n\n        rgb2rgb_init_MMX();\n\n    else\n\n#endif /* HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX */\n\n        rgb2rgb_init_C();\n\n}\n", "idx": 4698, "substitutes": {"flags": ["ents", "grades", "members", "details", "properties", "atts", "planes", " Flags", "ps", "frames", "files", "words", "locks", "options", "amps", "fps", "fts", "pins", "FLAG", "ports", "posts", "Flags", "styles", "lag", "heads", "gnu", "limits", "tags", "products", "ts", "cond", "lines", "actions", "comments", "bits", "vals", "flag", "features", "allows", "cs", "bugs", "workers", "mask", "parts", "goal", "settings", "wcs", "terms", "packages", "aps", "laws", "weights", "fields", "cmd", "ags"]}}
{"project": "FFmpeg", "commit_id": "292850b634240045805e3c2001aed6f046034e93", "target": 0, "func": "static double tget_double(GetByteContext *gb, int le)\n\n{\n\n    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};\n\n    return i.f64;\n\n}\n", "idx": 4718, "substitutes": {"gb": ["gm", "gt", "cv", "nb", "bt", "gov", "hub", "eg", "pg", "gu", "vg", "dd", "cb", "gc", "gd", "rg", "bb", "g", "pb", "mb", "gh", "kb", "gs", "sg", "cgi", "Gb", "db", "bg", "tg", "cfg", "gg", "gp", "GB", "eb", "yg", "sb", "bf", "rb", " GB", "bc"], "le": ["tle", " little", "ke", "ity", "elt", "de", "el", " ce", " ke", "ble", "led", "ped", "ode", " ble", "ele", " Le", "less", " de", "he", "ve", "ne", "yle", " angle", " ie", "ige", "agle", "ee", "ole", " ele", "ple", "ale", " ge", " needle", "te", "Le", " pe", "ce", " alle", "ile", "LE", " ty", " LE", "les", "sle", "be"]}}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_power5plus(CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_clear,\n\n                 0x60000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750FX_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_970_HID5, \"HID5\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 POWERPC970_HID5_INIT);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    /* XXX: not correct */\n\n    gen_low_BATs(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMUCFG, \"MMUCFG\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, SPR_NOACCESS,\n\n                 0x00000000); /* TOFIX */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMUCSR0, \"MMUCSR0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000); /* TOFIX */\n\n    spr_register(env, SPR_HIOR, \"SPR_HIOR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_hior, &spr_write_hior,\n\n                 0x00000000);\n\n    spr_register(env, SPR_CTRL, \"SPR_CTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_UCTRL, \"SPR_UCTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_VRSAVE, \"SPR_VRSAVE\",\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->slb_nr = 64;\n\n#endif\n\n    init_excp_970(env);\n\n    env->dcache_line_size = 128;\n\n    env->icache_line_size = 128;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc970_irq_init(env);\n\n    /* Can't find information on what this should be on reset.  This\n\n     * value is the one used by 74xx processors. */\n\n    vscr_init(env, 0x00010000);\n\n}\n", "idx": 4760, "substitutes": {"env": ["stage", "et", "conf", "pkg", "conn", "msg", "txt", "cur", "dh", "ie", "net", "vm", "db", "det", "esp", "hl", "er", "viron", "cmd", "event", "gear", "dev", "rod", "environment", "el", "gov", "vs", "ctx", "worker", "inv", "obj", "w", "ew", "en", "ve", "esm", "eng", "site", "ten", "ner", "code", "nw", "tk", "context", "shell", "entry", "esc", "org", "ut", "cb", "nv", "era", "here", "eq", "e", "end", "home", "ev", "vt", "dem", "vp", "dt", "cv", "v", "ec", "enter", "vv", "server", "req", "ect", "emb", "usr", "act", "erd", "addr", "hw", "window", "desc"]}}
{"project": "FFmpeg", "commit_id": "15d14ce47cb39b93a80a2c6b8396db81c16934e6", "target": 1, "func": "static int64_t get_bit_rate(AVCodecContext *ctx)\n\n{\n\n    int64_t bit_rate;\n\n    int bits_per_sample;\n\n\n\n    switch (ctx->codec_type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n    case AVMEDIA_TYPE_DATA:\n\n    case AVMEDIA_TYPE_SUBTITLE:\n\n    case AVMEDIA_TYPE_ATTACHMENT:\n\n        bit_rate = ctx->bit_rate;\n\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);\n\n        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;\n\n        break;\n\n    default:\n\n        bit_rate = 0;\n\n        break;\n\n    }\n\n    return bit_rate;\n\n}\n", "idx": 4761, "substitutes": {"ctx": ["tc", "mc", "ka", "cp", "pkg", "cv", "conn", "aus", "mk", "news", "wx", "iac", "nt", "pc", "animate", "dc", "inst", "txt", "obj", "loc", "unk", "cc", "crit", "wp", "abc", "kt", "req", "comm", "dl", "gc", "mom", "lex", "kl", "anc", "js", "ns", "proc", "resp", "np", "today", "act", "kb", "ij", "kj", "ocr", "cmp", "jp", "ck", "cf", "xs", "cfg", "xc", "exec", "iat", "etc", "addr", "that", "hw", "ct", "desc", "tm", "tx", "aux", "pause", "wcs", "cmd", "kick", "kw", "oc", "xp", "context", "ctl", "bc"], "bit_rate": ["bit_stream", "bitituderate", "bit_width", "bit5frequency", "bit8rate", "bit67change", "bug_rate", "byte_length", "bit_range", "bitlerace", "bit67stream", "bit5stream", "bar_stream", "bit_speed", "bitlyrate", "bar67stream", "bit_frequency", "bug_race", " bit_race", "bar_rate", "bitlydevice", "bit_length", "bit67rate", "bit_system", "bit_score", " bit_device", " bit_error", "bit_scale", "bug_system", "bitmodrate", "bar67frequency", "bit_change", "bar67change", "bit_component", "bitlyrange", "bitletrange", "byte_component", "byte_speed", "byte_range", "bit_rates", "bitlesystem", "bit_race", "bit5rate", "bit5change", " bit_range", "byte_rate", " bit_rates", "bit_error", "bitlerange", "bar67rate", "bititudedepth", "bit8component", "bar_frequency", "bit67frequency", "byte_width", "bitmodrange", " bit_scale", "bit8width", "byte_score", " bit_depth", "bitlerate", "bit8range", "bar_change", "bitituderace", "bitmoddevice", "bit_depth", "bug_range", "bitletcomponent", "bit_device", "bitletrate", "bitletwidth", "bititudescale"], "bits_per_sample": ["bits_per_frame", "bits_perPcomponent", "bits_to_sample", "bits_for_scale", "bits_for_Sample", "bits_to_ample", "bits_for_space", "bits_per_component", "bits_perPSample", "bits_per_space", "bits_for_frame", "bits_per_scale", "bits_per_channel", "bits_to_Sample", "bits_per_ample", "bits_perPsample", "bits_to_component", "bits_perPample", "bits_for_channel", "bits_for_sample", "bits_per_Sample", "bits_for_component"]}}
{"project": "FFmpeg", "commit_id": "7631f14bb35e8467d4ffaaa2b34e60614eb37c71", "target": 0, "func": "static int mkv_write_codecprivate(AVFormatContext *s, AVIOContext *pb,\n\n                                  AVCodecParameters *par,\n\n                                  int native_id, int qt_id)\n\n{\n\n    AVIOContext *dyn_cp;\n\n    uint8_t *codecpriv;\n\n    int ret, codecpriv_size;\n\n\n\n    ret = avio_open_dyn_buf(&dyn_cp);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (native_id) {\n\n        ret = mkv_write_native_codecprivate(s, par, dyn_cp);\n\n    } else if (par->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if (qt_id) {\n\n            if (!par->codec_tag)\n\n                par->codec_tag = ff_codec_get_tag(ff_codec_movvideo_tags,\n\n                                                    par->codec_id);\n\n            if (   ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag) == par->codec_id\n\n                && (!par->extradata_size || ff_codec_get_id(ff_codec_movvideo_tags, AV_RL32(par->extradata + 4)) != par->codec_id)\n\n            ) {\n\n                int i;\n\n                avio_wb32(dyn_cp, 0x5a + par->extradata_size);\n\n                avio_wl32(dyn_cp, par->codec_tag);\n\n                for(i = 0; i < 0x5a - 8; i++)\n\n                    avio_w8(dyn_cp, 0);\n\n            }\n\n            avio_write(dyn_cp, par->extradata, par->extradata_size);\n\n        } else {\n\n            if (!ff_codec_get_tag(ff_codec_bmp_tags, par->codec_id))\n\n                av_log(s, AV_LOG_WARNING, \"codec %s is not supported by this format\\n\",\n\n                       avcodec_get_name(par->codec_id));\n\n\n\n            if (!par->codec_tag)\n\n                par->codec_tag = ff_codec_get_tag(ff_codec_bmp_tags,\n\n                                                  par->codec_id);\n\n            if (!par->codec_tag && par->codec_id != AV_CODEC_ID_RAWVIDEO) {\n\n                av_log(s, AV_LOG_ERROR, \"No bmp codec tag found for codec %s\\n\",\n\n                       avcodec_get_name(par->codec_id));\n\n                ret = AVERROR(EINVAL);\n\n            }\n\n\n\n            ff_put_bmp_header(dyn_cp, par, ff_codec_bmp_tags, 0, 0);\n\n        }\n\n    } else if (par->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        unsigned int tag;\n\n        tag = ff_codec_get_tag(ff_codec_wav_tags, par->codec_id);\n\n        if (!tag) {\n\n            av_log(s, AV_LOG_ERROR, \"No wav codec tag found for codec %s\\n\",\n\n                   avcodec_get_name(par->codec_id));\n\n            ret = AVERROR(EINVAL);\n\n        }\n\n        if (!par->codec_tag)\n\n            par->codec_tag = tag;\n\n\n\n        ff_put_wav_header(s, dyn_cp, par, FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX);\n\n    }\n\n\n\n    codecpriv_size = avio_close_dyn_buf(dyn_cp, &codecpriv);\n\n    if (codecpriv_size)\n\n        put_ebml_binary(pb, MATROSKA_ID_CODECPRIVATE, codecpriv,\n\n                        codecpriv_size);\n\n    av_free(codecpriv);\n\n    return ret;\n\n}\n", "idx": 4762, "substitutes": {"s": ["sc", "t", "os", "S", "p", "pkg", "ds", "a", "ms", "v", "sp", "r", "ps", "q", "w", "set", "ss", "self", "h", "js", "ns", "sq", "an", "ses", "sts", "sg", "socket", "rs", "gs", "ts", "es", "m", "fs", "sv", "cs", "x", "as", "c", "ls", "ats", "sys", "sw", "sa"], "pb": ["vp", "pp", "cp", "p", "pub", "pkg", "cv", "tmp", "lp", "sp", "ctx", "pc", "mp", "cb", "ub", "pa", "pro", "prep", "proc", "np", "fp", "tp", "pd", "jp", "gp", "conv", "pl", "uf", "tk"], "par": ["ph", "pp", "rep", "cp", "p", "pub", "dev", "conf", "task", "Par", "pkg", "arg", "sp", "att", "ps", "app", "pc", "pass", "mp", "parent", "tar", "pas", "PAR", "crit", "prop", "pa", "pro", "req", "ok", "prep", "rem", "pal", "arp", "proc", "resp", "def", "pres", "pol", "arch", "per", "pers", "pr", "pard", "decl", "peer", "ars", "ar", "tp", "jp", "op", "repl", "pat", "perm", "rel", "star", "mm", "plan", "kar", "pri", "parse", "part", "pl", "var", "param", "ran", "pre", "params", "cmd"], "native_id": ["native_if", "native___ids", "nativevisionpic", "nativevisionid", "nn_oid", "parentityid", "nativeOpic", "nativeOoid", "native_len", "native_pic", "nativevisionlen", "nn_len", "nn_id", "parent_id", "native___if", "native_oid", "native_tag", "nativeitytag", "parentitytag", "nativeOid", "nn_pic", "parentityif", "native___tag", "nativeOlen", "native___id", "parentityids", "parent_ids", "nativeityids", "nativeityif", "parent_if", "native_ids", "parent_tag", "nativevisionoid", "nativeityid"], "qt_id": ["qt_mi", "qtmykey", "qtokeid", "quant_mi", "qtokestatus", "qq_status", "qtmyid", "quant_id", "qtokeside", "qt_key", "qt___mi", "qtmymi", "qtmymid", "qt___key", "qq_Id", "qtokeId", "qt_side", "qt___id", "qq_id", "qt_status", "quant_mid", "quant_key", "qq_side", "qt_mid", "qt___mid", "qt_Id"], "dyn_cp": ["dyn_jp", "din_fp", "dynptcp", "dyn_cb", "dYN___cp", "dyn_cas", "dyn_wp", "dynJCP", "dyn_tp", "dawn_cas", "dyn5cp", "dynJcas", "dynJconn", "din_cs", "dyn_conn", "dyn___cs", "dyn_cmp", "din_cp", "din_cv", "dawn_cp", "dyn___cv", "dyn_ctx", "dYN_buf", "dawn_jp", "dyn5cmp", "dYN_CP", "dYN_bp", "dynJjp", "dynptgc", "dync_fp", "dyn5ctx", "dYN___CP", "dyn_cv", "dyn___cb", "dyn_bp", "dYN___tp", "dyn_CP", "dyn___conn", "dynJcaps", "dync_cp", "dyn___fp", "dYN_tp", "dync_wp", "dyn5cpp", "dyn___tp", "dynptfp", "dYN_cp", "dyn___cp", "dyn___CP", "dynptwp", "dYN_conn", "dynJbuf", "dync_gc", "dyn_cpp", "dyn_gc", "dYN___bp", "dyn___ctx", "dynJcp", "dyn___cpp", "dyn___buf", "dyn_fp", "dyn_cs", "dyn___cmp", "dyn___bp", "dyn_caps", "dyn_buf", "dawn_caps"], "codecpriv": ["codecriv", "odecriv", "codocpriv", "odecprivate", "codencriv", "odecPriv", "codecprivate", "codencPriv", "odcpriv", "codocPriv", "odcprivate", "odcPriv", "codocriv", "codencprivate", "codencpriv", "codcPriv", "codocprivate", "odecpriv", "odcriv", "codecPriv", "codcprivate", "codcpriv", "codcriv"], "ret": ["deg", "get", "t", "elt", "inter", "gt", "reset", "limit", "ll", "RET", "__", "arg", "rm", "arr", "nt", "re", "att", "Ret", "ft", "Return", "rets", "val", "fun", "ry", "rem", "gc", "xt", "mem", "mt", "resp", "def", "result", "mb", "rev", "ref", "ber", "mel", "len", "status", "res", "try", "tr", "ter", "flag", " RET", " Ret", "rt", "secondary", "alt", "value", "err", "cmd"], "codecpriv_size": ["codecprivate_size", "codecpriv_len", "codecprivate_Size", "codecprivxlength", "codecpriv_length", "codecpriv_Size", "codecprivate_len", "codecprivxSize", "codecprivate_length", "codecprivxlen", "codecprivxsize"], "i": [" m", "t", "li", "p", "sim", "is", "l", "ii", "ind", "mi", "ix", "it", "ic", "q", "\u0438", "hi", "si", "oi", "j", "di", "h", "o", "gi", "io", "in", "b", "ui", "multi", "iu", "xi", "y", "zi", "iter", "e", "ci", "ti", "m", "ai", "pi", " j", "im", "ims", "x", "I", "phi", "qi", "c", "cli", "us", "n", "u", " ii"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line_size, const DCTELEM *block/*align 16*/){\n\n    int i, dc = (block[0] + 15) >> 5;\n\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += line_size;\n\n    }\n\n}\n", "idx": 4766, "substitutes": {"dest": ["master", "save", "host", "sum", "cont", "it", "scan", "msg", "loc", "di", "reason", "slice", "decl", "opt", "target", "iter", "comb", "display", "coord", "them", "Dest", "start", "sort", "search", "ptr", "cp", "dev", "copy", "success", "delete", "origin", "resource", "dist", "dim", "way", "sp", "nom", "list", "check", "transform", "st", "output", "dat", "mem", "comment", "gest", "all", "src", "transfer", "temp", "d", "dc", "trans", "axis", "good", "port", "params", "ports", "size", "source", "chain", "ident", "est", "shift", "comp", "rest", "match", "end", "rel", "table", "del", "alt", "local", "out", "max", "tmp", "v", "pipe", "spec", "server", "gate", "result", "usr", "orig", "selected", "buf", "status", "tr", "reverse", "global", "addr", "desc", "route", "see", "dep"], "line_size": ["line_SIZE", "Line_size", " line_Size", " line_start", " line_SIZE", "Line_space", "line_space", "Line_pos", "line_start", "line_Size", "line_pos"], "block": ["conf", "pack", "copy", "config", "Block", "label", "list", "image", "scan", "pixel", "field", "check", "rule", "map", "cl", "set", "lock", "chain", "word", "cell", "link", "source", "proc", "point", "bl", "type", "ref", "buffer", "row", "line", "byte", "bin", "null", "box", "load", "event"], "i": ["t", "li", " err", "p", "sim", "ki", "bi", "ind", "v", "ii", " ni", "ini", "mi", "ix", " bi", " pi", " n", "me", "it", "ic", "q", "asi", "si", "ish", "j", "di", "gi", "ie", "ip", "ex", "index", "g", " v", "multi", "ui", "iu", "xi", "zi", "iter", "status", " ti", "ci", "ti", "m", "print", "ai", "pi", " j", "im", "ims", "x", "I", " k", "qi", "c", "phi", "n", " ii", "batch"], "cm": ["tc", "gm", "ace", "hm", "cp", "conf", "rum", "com", "cv", "form", "bm", "ms", "ctr", "fm", "ym", "rm", "lc", "cont", "fine", "mp", "dc", "cd", "cc", "pm", "km", "comm", "cn", "gc", "sem", "cr", "nm", "mom", "fc", "asm", "mt", "mn", "iam", "mb", "ctrl", "CM", "vm", "cf", "cy", "ci", "wm", "m", "um", "ca", "cut", "mm", "rom", "disc", "ct", "csv", "mod", "c", "gr", "med", "arm", "mc", "mr"]}}
{"project": "qemu", "commit_id": "a01aedc8d32e6f5b08a4041b62be3c5fab7a3382", "target": 1, "func": "void object_property_add_bool(Object *obj, const char *name,\n\n                              bool (*get)(Object *, Error **),\n\n                              void (*set)(Object *, bool, Error **),\n\n                              Error **errp)\n\n{\n\n    BoolProperty *prop = g_malloc0(sizeof(*prop));\n\n\n\n    prop->get = get;\n\n    prop->set = set;\n\n\n\n    object_property_add(obj, name, \"bool\",\n\n                        get ? property_get_bool : NULL,\n\n                        set ? property_set_bool : NULL,\n\n                        property_release_bool,\n\n                        prop, errp);\n\n}\n", "idx": 4768, "substitutes": {"obj": ["os", "phys", "elt", "bh", "bj", "tmp", "org", "nt", "ctx", "objects", "inst", "txt", "self", "object", "j", "o", "pt", "js", "ex", "ht", "np", "oj", "act", "onet", "y", "ot", "xy", "obs", "ck", " ob", "rect", "og", "this", "hw", "Obj", "ob", "sys", "rb", "out"], "name": ["key", "t", "order", "p", "named", "Name", "no", "ame", "f", "id", "v", "common", "normal", "label", "path", "prefix", "w", "str", "attr", "nm", "word", "ns", "ex", "b", "g", "term", "property", "type", "ma", "len", "m", "base", "part", "names", "var", "title", "n", "local", "NAME"], "get": ["access", "query", "et", "p", "util", "let", "eval", "full", "getting", "le", "draw", "entity", "put", "it", "list", "msg", "check", "select", "call", "force", "gets", "got", "export", "handle", "show", "pull", "read", "build", "ge", "secure", "ret", "GET", "gen", "info", "g", "like", "maybe", "Get", "print", "end", "find", "give", "generic", "exec", " Get", "del", "create", "gener", "pre", "cmd"], "set": ["hide", "et", "p", "save", "reset", "ch", "let", "use", "delete", "full", "put", "it", "list", "hash", "sets", "change", "force", "send", "sub", "sl", "edit", "disable", "en", "handle", "st", "ge", "secure", "apply", "Set", "ex", "clear", "gen", "make", "ver", "sys", "write", "given", "range", "ets", "store", "end", "SET", "local", "test", "parse", "mod", "update", "settings", "create", "del", "move", "open", "n", "add", "value", "place"], "errp": [" ErrP", " erpr", "errorpo", " err", " errps", "erps", " errpr", "errpo", "errorpa", "errpa", " errpo", " errP", " erps", " Errpa", " errpa", " Errp", "errorp", " Errpo", "errorP", " errr", "erpr", "erp", "errpr", " erp", "errr", "errP", "err", "errps"], "prop": ["ph", "ptr", "key", "rep", "cp", "p", "conf", "lit", "pub", "ch", "pkg", "tmp", "Prop", "properties", "mk", "priv", "fac", "pred", "arr", "nt", "ps", "col", "att", "spec", "ctx", "list", "bug", "msg", "bar", "map", "plot", "val", "pro", " Prop", "j", "supp", "prot", "pt", "attr", "proc", "po", "def", " props", "info", "comp", "term", "buf", "property", "pb", "pr", "cap", "per", "opt", "acc", "xy", "jp", "op", "cfg", "fo", "rel", "rop", "pl", "mod", "pid", "orig", "kw", "feat", "pos", "cmd"]}}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static inline int mirror(int v, int m){\n\n    if     (v<0) return -v;\n\n    else if(v>m) return 2*m-v;\n\n    else         return v;\n\n}\n", "idx": 4769, "substitutes": {"v": ["vp", "t", "p", "tv", "vi", "cv", "f", "d", "vc", "l", "vs", "mi", "vert", "qv", "q", "ev", "vt", "vv", "val", "version", "k", "nv", "j", "h", "ve", "u", "wire", "i", "vector", "b", "ver", "g", "vm", "um", "iv", "conv", "sv", "pi", "im", "x", "lv", "c", "n", "V", "value", "av", "va", "uv"], "m": ["gm", "t", "cm", "p", "dm", "f", "bm", "d", "mk", "l", "ms", "r", "mi", "mu", "mp", "sm", "q", "pm", "k", "j", "h", "esm", "i", "mt", "b", "g", "md", "mn", "M", "ma", "vm", "perm", "mm", "tm", "c", "n", "mc", "mr"]}}
{"project": "qemu", "commit_id": "cd7fdfe59f4f965665dcd9868fe3764f5256d6aa", "target": 1, "func": "void virtio_blk_data_plane_stop(VirtIOBlockDataPlane *s)\n\n{\n\n    if (!s->started) {\n\n        return;\n\n    }\n\n    s->started = false;\n\n    trace_virtio_blk_data_plane_stop(s);\n\n\n\n    /* Stop thread or cancel pending thread creation BH */\n\n    if (s->start_bh) {\n\n        qemu_bh_delete(s->start_bh);\n\n        s->start_bh = NULL;\n\n    } else {\n\n        event_poll_notify(&s->event_poll);\n\n        qemu_thread_join(&s->thread);\n\n    }\n\n\n\n    ioq_cleanup(&s->ioqueue);\n\n\n\n    s->vdev->binding->set_host_notifier(s->vdev->binding_opaque, 0, false);\n\n\n\n    event_poll_cleanup(&s->event_poll);\n\n\n\n    /* Clean up guest notifier (irq) */\n\n    s->vdev->binding->set_guest_notifiers(s->vdev->binding_opaque, 1, false);\n\n\n\n    vring_teardown(&s->vring);\n\n}\n", "idx": 4770, "substitutes": {"s": ["p", "l", "my", "sl", "gets", "ains", "ns", "sq", "ses", "gs", "y", "stats", "results", "comments", "its", "ims", "n", "qs", "eps", "services", "S", "r", "vs", "ps", "ins", "serv", "w", "less", "ss", "h", "changes", "ssh", "i", "js", "b", "sts", "ts", "ops", "fs", "sis", "args", "sb", "als", "ats", "sys", "sol", "states", "sports", "syn", "details", "is", "ports", "params", "aws", "bs", "source", "rs", "m", "cs", "ls", "t", "os", "ds", "ms", "v", "spec", "ies", "sm", "set", "comm", "hs", "ssl", "an", "g", "pers", "store", "ties", "es", "sv", "parts", "still", "se", "sw"]}}
{"project": "FFmpeg", "commit_id": "ddef3d902f0e4cbd6be6b3e5df7ec158ce51488b", "target": 1, "func": "static int mov_write_tkhd_tag(AVIOContext *pb, MOVMuxContext *mov,\n\n                              MOVTrack *track, AVStream *st)\n\n{\n\n    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,\n\n                                      track->timescale, AV_ROUND_UP);\n\n    int version = duration < INT32_MAX ? 0 : 1;\n\n    int flags   = MOV_TKHD_FLAG_IN_MOVIE;\n\n    int rotation = 0;\n\n    int group   = 0;\n\n\n\n    uint32_t *display_matrix = NULL;\n\n    int      display_matrix_size, i;\n\n\n\n    if (st) {\n\n        if (mov->per_stream_grouping)\n\n            group = st->index;\n\n        else\n\n            group = st->codecpar->codec_type;\n\n\n\n        display_matrix = (uint32_t*)av_stream_get_side_data(st, AV_PKT_DATA_DISPLAYMATRIX,\n\n                                                            &display_matrix_size);\n\n        if (display_matrix && display_matrix_size < 9 * sizeof(*display_matrix))\n\n            display_matrix = NULL;\n\n    }\n\n\n\n    if (track->flags & MOV_TRACK_ENABLED)\n\n        flags |= MOV_TKHD_FLAG_ENABLED;\n\n\n\n    if (track->mode == MODE_ISM)\n\n        version = 1;\n\n\n\n    (version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92); /* size */\n\n    ffio_wfourcc(pb, \"tkhd\");\n\n    avio_w8(pb, version);\n\n    avio_wb24(pb, flags);\n\n    if (version == 1) {\n\n        avio_wb64(pb, track->time);\n\n        avio_wb64(pb, track->time);\n\n    } else {\n\n        avio_wb32(pb, track->time); /* creation time */\n\n        avio_wb32(pb, track->time); /* modification time */\n\n    }\n\n    avio_wb32(pb, track->track_id); /* track-id */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    if (!track->entry && mov->mode == MODE_ISM)\n\n        (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff);\n\n    else if (!track->entry)\n\n        (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0);\n\n    else\n\n        (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration);\n\n\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb16(pb, 0); /* layer */\n\n    avio_wb16(pb, group); /* alternate group) */\n\n    /* Volume, only for audio */\n\n    if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        avio_wb16(pb, 0x0100);\n\n    else\n\n        avio_wb16(pb, 0);\n\n    avio_wb16(pb, 0); /* reserved */\n\n\n\n    /* Matrix structure */\n\n\n    if (st && st->metadata) {\n\n        AVDictionaryEntry *rot = av_dict_get(st->metadata, \"rotate\", NULL, 0);\n\n        rotation = (rot && rot->value) ? atoi(rot->value) : 0;\n\n    }\n\n\n    if (display_matrix) {\n\n        for (i = 0; i < 9; i++)\n\n            avio_wb32(pb, display_matrix[i]);\n\n\n    } else if (rotation == 90) {\n\n        write_matrix(pb,  0,  1, -1,  0, track->par->height, 0);\n\n    } else if (rotation == 180) {\n\n        write_matrix(pb, -1,  0,  0, -1, track->par->width, track->par->height);\n\n    } else if (rotation == 270) {\n\n        write_matrix(pb,  0, -1,  1,  0, 0, track->par->width);\n\n\n    } else {\n\n        write_matrix(pb,  1,  0,  0,  1, 0, 0);\n\n    }\n\n    /* Track width and height, for visual only */\n\n    if (st && (track->par->codec_type == AVMEDIA_TYPE_VIDEO ||\n\n               track->par->codec_type == AVMEDIA_TYPE_SUBTITLE)) {\n\n        int64_t track_width_1616;\n\n        if (track->mode == MODE_MOV) {\n\n            track_width_1616 = track->par->width * 0x10000ULL;\n\n        } else {\n\n            track_width_1616 = av_rescale(st->sample_aspect_ratio.num,\n\n                                                  track->par->width * 0x10000LL,\n\n                                                  st->sample_aspect_ratio.den);\n\n            if (!track_width_1616 ||\n\n                track->height != track->par->height ||\n\n                track_width_1616 > UINT32_MAX)\n\n                track_width_1616 = track->par->width * 0x10000ULL;\n\n        }\n\n        if (track_width_1616 > UINT32_MAX) {\n\n            av_log(mov->fc, AV_LOG_WARNING, \"track width is too large\\n\");\n\n            track_width_1616 = 0;\n\n        }\n\n        avio_wb32(pb, track_width_1616);\n\n        if (track->height > 0xFFFF) {\n\n            av_log(mov->fc, AV_LOG_WARNING, \"track height is too large\\n\");\n\n            avio_wb32(pb, 0);\n\n        } else\n\n            avio_wb32(pb, track->height * 0x10000U);\n\n    } else {\n\n        avio_wb32(pb, 0);\n\n        avio_wb32(pb, 0);\n\n    }\n\n    return 0x5c;\n\n}", "idx": 4781, "substitutes": {"pb": ["tc", "vp", "pp", "cp", "p", "lb", "pel", "conf", "rpm", "pkg", "bps", "cv", "tmp", "bj", "lp", "aus", "PB", "sp", "func", "ctx", "pc", "fb", "mp", "pg", "typ", "wp", "cb", "cc", "orp", "ub", "amp", "pro", "pm", "pt", "px", "gc", "bs", "rb", "emb", "np", "resp", "bb", "proc", "erb", "buf", "pr", "peer", "fp", "tp", "pool", "jp", "dp", "bp", "uf", "stab", "tx", "sb", "patch", "tk", "tab", "nb", "bc", "wb"], "mov": ["smov", "mutote", "Move", "smovi", " move", "smote", "mote", "smOV", "Mav", "cmav", "mav", "mutOV", "cmov", "cmote", "mutove", "mutov", "cmOV", "smav", "cmovi", " mOV", "cmove", " movi", "movi", "smove", "mOV", "MOV", "move", "Mov", " mav"], "track": ["search", "dr", "t", "task", "form", "tmp", "tf", "train", "review", "rm", "r", "rack", "rr", "Track", "sync", "check", "transform", "disable", "setup", "set", "claim", "vr", "sort", "pt", "time", "history", "metadata", "mt", "stall", "met", "comment", "trace", "info", "roll", "trak", "store", "tracking", "tag", "tp", "match", "rank", "row", "record", "stat", "find", "report", "tr", "follow", "session", "round", "trip", "tm", "runtime", "src", "move", "rt", "kick", "skip", "ack", "tab", "batch", "stream", "run", "seek", "add"], "st": ["ST", "stage", "sc", "t", "irst", "th", "td", "tmp", "mont", "sp", "r", "nt", "ctx", "cont", "ost", "sm", "stack", "inst", "sta", "stable", "sl", "str", "cur", "ist", "sth", "so", "pt", "mt", "ste", "stop", "state", "step", "std", "sts", "store", "rest", "sn", "stat", "tr", "sv", "stream", "ct", "nd", "St", "src", "start", "rt", "se", "sw", "station"], "display_matrix": ["display_formatrices", "display_manrix", "display_mattx", "display_nonrices", "display_mitrices", "display_nonrie", "display_metrices", "display_mMatrix", "display_metric", "display_matrie", "display_formatMatrix", "display_managerication", "display_matric", "display_atMatrix", "display_atrix", "display_atric", "display_mitric", "display_managerMatrix", "display_matrices", "display_formatric", "display_atrie", "display_formatrix", "display_nonrix", "display_atix", "display_manrices", "display_matMatrix", "display_metrix", "display_managerrices", "display_dimrix", "display_matix", "display_mittx", "display_mettx", "display_dimMatrix", "display_atrices", "display_dimrices", "display_formatix", "display_manrie", "display_mrices", "display_mitrix", "display_mrix", "display_formatication", "display_mitix", "display_formattx", "display_managerrix", "display_matication", "display_manMatrix", "display_atication"], "display_matrix_size": ["display_matrix_sum", "display_matrices_set", "display_matrix_data", "display_matrices_SIZE", "display_matrix_set", "display_matrix_Size", "display_matrices_sum", "display_matrix_len", "display_matrices_data", "display_matrix_SIZE", "display_matrices_len", "display_matrices_size", "display_matrices_Size"], "i": ["t", "p", "f", "d", "id", "v", "ii", "ind", "ix", "si", "k", "j", "di", "port", "in", "ip", "index", "slice", "g", "m", "pi", "x", "I", "c", "s", "n", "z"]}}
{"project": "FFmpeg", "commit_id": "4189fe11ffcbdcd311eb9a3437586a94492c4cde", "target": 1, "func": "static int vobsub_read_seek(AVFormatContext *s, int stream_index,\n\n                            int64_t min_ts, int64_t ts, int64_t max_ts, int flags)\n\n{\n\n    MpegDemuxContext *vobsub = s->priv_data;\n\n\n\n    /* Rescale requested timestamps based on the first stream (timebase is the\n\n     * same for all subtitles stream within a .idx/.sub). Rescaling is done just\n\n     * like in avformat_seek_file(). */\n\n    if (stream_index == -1 && s->nb_streams != 1) {\n\n        int i, ret = 0;\n\n        AVRational time_base = s->streams[0]->time_base;\n\n        ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base);\n\n        min_ts = av_rescale_rnd(min_ts, time_base.den,\n\n                                time_base.num * (int64_t)AV_TIME_BASE,\n\n                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);\n\n        max_ts = av_rescale_rnd(max_ts, time_base.den,\n\n                                time_base.num * (int64_t)AV_TIME_BASE,\n\n                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);\n\n        for (i = 0; i < s->nb_streams; i++) {\n\n            int r = ff_subtitles_queue_seek(&vobsub->q[i], s, stream_index,\n\n                                            min_ts, ts, max_ts, flags);\n\n            if (r < 0)\n\n                ret = r;\n\n        }\n\n        return ret;\n\n    }\n\n\n\n\n\n    return ff_subtitles_queue_seek(&vobsub->q[stream_index], s, stream_index,\n\n                                   min_ts, ts, max_ts, flags);\n\n}", "idx": 4798, "substitutes": {"s": ["sc", "t", "os", "p", "S", "sports", "ds", "https", "is", "a", "ms", "v", "ps", "spec", "ins", "w", "less", "ss", "self", "h", "aws", "comm", "bs", "ns", "js", "hs", "b", "ex", "sq", "g", "sts", "scl", "rs", "gs", "es", "m", "acs", "fs", "its", "sv", "cs", "sb", "c", "als", "as", "ls", "ats", "n", "sys", "qs", "eps"], "stream_index": ["streamationind", "line_instance", "stream8mix", "line_Index", "video_Index", "streamIdindex", "stream_id", "streamIdinstance", "lineIdindex", "videoitychain", "stream___index", "streamNameinstance", "streamityindex", "streamNameIndex", "stream_instance", "lineIdweight", "line_weight", "stream___connection", "video_index", "videoitymix", " stream_list", "streamingind", "streamitymix", "streamationlist", "file_distance", "stream_mix", "file_index", "video_mix", "stream_chain", "file_connection", "fileingdistance", "stream_list", "stream_request", " stream_Index", "lineIdIndex", "stream_ind", "fileingind", "video_chain", "stream_weight", "streamingdistance", "line_index", "videoityindex", "streamIdweight", "streamIdIndex", "stream_distance", "stream_Index", "videoityIndex", "stream8Index", "streamingindex", "stream_loop", " stream_ind", "stream_connection", "fileingindex", "file_ind", "stream___ind", "fileingconnection", "stream___distance", " stream_request", "streamityIndex", "streamationid", "lineIdinstance", "streamingconnection", " stream_loop", "stream8index", "streamationrequest", "streamationindex", " stream_id", "streamNameweight", "stream8loop", "streamitychain", "streamationloop", "stream8chain", "stream8request", "streamNameindex", "streamationIndex"], "min_ts": ["eminlyts", "midlyids", "emin_ts", "minEtd", "minuteEmt", "minPats", "min_posts", "min___posts", "minlyids", "minlyats", "minPmt", "minlymt", "min_ids", "minuteEtes", "min___ms", "mid_ids", "minptts", "minPts", "minuteEts", "min_td", "minlytimes", "minute_tes", "minute_mt", " min_ms", " min_mt", "minEtes", "min___ts", "midlymt", "mid_ts", "min_tes", "min_ls", "minEmt", "minute_ts", "min___mt", "minimts", "emin_ats", "minimds", "minPids", " min_ds", "eminlyls", "minptms", "min_ds", "mid_mt", " min_fs", "min_times", "eminlytimes", "min_mt", "minute_td", "midlyats", "midlyts", "mid_ats", "mintts", "mintids", "mintmt", "minimposts", "minptposts", "minimfs", "min_ats", "minlyts", "min_ms", "minuteEtd", "emin_ls", "emin_times", "minptmt", "min_fs", " min_posts", "minEts", "mintats", "eminlyats", "minlyls"], "ts": ["t", "uts", "ents", "Ts", "elt", "ems", "td", "ds", "tt", "times", "ms", "atts", "ps", "vs", "tim", "ins", "tz", "ics", "rets", "txt", "ens", "amps", "inters", "fts", "ports", "outs", "posts", "points", "pt", "wt", "tes", "bs", "mods", "ns", "js", "TS", "mt", "ints", "lt", "sts", "ets", "rs", "gs", "tp", "xs", "stats", "tips", "stones", "vals", "its", "fs", "cs", "ims", "tm", "tx", "aints", "als", "ls", "aps", "ats", "qs"], "max_ts": ["max8ts", "min_cs", "max8ets", "max_tes", "prime_sts", " max_ps", "prime_ets", " max_times", "max12ps", "max_t", " max_ds", " max_t", "total_ts", "max2t", "max_ps", "max__ts", "min_t", "total_tz", "max_sts", "max__times", "min_tes", "prime_amps", "max12mt", "max12tes", "max_mt", "max__ds", "max_ets", "max_cs", "max_amps", "total_ls", "max_ds", " max_mt", "max_ls", " max_tes", "max2ts", "max12ts", "max8amps", "max8sts", "prime_ts", "max2ds", "max_times", "max2times", "total_times", "max__t", "max_tz"], "flags": ["doms", "uts", "fits", "details", " flag", "atts", "types", "ms", " Flags", "func", "ps", "files", " options", "locks", "options", "amps", "fps", "pins", "FLAG", "posts", "ensions", "xf", "Flag", "Flags", "lag", "fee", "heads", "tags", "cf", "faces", "cond", "members", "comments", "bits", "fs", "flag", "features", "args", "alf", "orts", "aints", "wcs", " fmt", "nl", "ats", "acts", "weights", "fields", "cmd", "ags"], "vobsub": ["vobsdata", " vobub", "vobjob", "vobbyrec", "vobub", "vobbot", " vobbot", " vobbbot", "vobbyweb", "avoysub", "avobrec", "voybatch", "vobbsub", "vobbatch", "avobweb", "veobsub", "vobsbot", "veembsub", "voyjob", "vobbbot", "voberbot", " vobbdata", "voberub", "veembjob", "vobsrec", "veobbatch", "avoyrc", "veobjob", "vobdata", "vorgbatch", "vembjob", "avobsub", "vobbub", "vobsrc", "vorgsel", "vorgjob", "voyrec", "vobrec", "voysub", "vobweb", "vobsweb", "vobersub", "veembsel", " vobdata", "vobbysub", "vembbatch", "avobrc", "vobsel", "vembsel", "veembbatch", "veobsel", "vorgsub", "vobbyrc", "vobbdata", "vembsub", "voyweb", "voberdata", " vobbsub", "avoyweb", "voyrc", "vobssub", "avoyrec", "voysel", " vobbub", "vobrc"], "i": ["t", "ei", "li", "p", "sim", "ki", "bi", "is", "id", "ind", "ii", "v", "l", "r", "ini", "ix", "mi", "me", "it", "ic", "q", "gu", "\u0438", "hi", "uri", "si", "k", "oi", "j", "di", "gi", "ri", "in", "chain", "ip", "iq", "ji", "index", "info", "ui", "multi", "iu", "xi", "ir", "y", "zi", "iter", "ij", "e", "ci", "ti", "m", "ai", "pi", "im", "x", "I", "qi", "phi", "c", "cli", "jj", "n", "batch"]}}
{"project": "FFmpeg", "commit_id": "c177f2ec4a21d62fdefd925ad69c24a2f9dad303", "target": 0, "func": "static av_cold int aac_encode_init(AVCodecContext *avctx)\n\n{\n\n    AACContext *s = avctx->priv_data;\n\n    int ret = AVERROR(EINVAL);\n\n    AACENC_InfoStruct info = { 0 };\n\n    CHANNEL_MODE mode;\n\n    AACENC_ERROR err;\n\n    int aot = FF_PROFILE_AAC_LOW + 1;\n\n    int sce = 0, cpe = 0;\n\n\n\n    if ((err = aacEncOpen(&s->handle, 0, avctx->channels)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to open the encoder: %s\\n\",\n\n               aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (avctx->profile != FF_PROFILE_UNKNOWN)\n\n        aot = avctx->profile + 1;\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_AOT, aot)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set the AOT %d: %s\\n\",\n\n               aot, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (aot == FF_PROFILE_AAC_ELD + 1 && s->eld_sbr) {\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_SBR_MODE,\n\n                                       1)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to enable SBR for ELD: %s\\n\",\n\n                   aac_get_error(err));\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_SAMPLERATE,\n\n                                   avctx->sample_rate)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set the sample rate %d: %s\\n\",\n\n               avctx->sample_rate, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    switch (avctx->channels) {\n\n    case 1: mode = MODE_1;       sce = 1; cpe = 0; break;\n\n    case 2: mode = MODE_2;       sce = 0; cpe = 1; break;\n\n    case 3: mode = MODE_1_2;     sce = 1; cpe = 1; break;\n\n    case 4: mode = MODE_1_2_1;   sce = 2; cpe = 1; break;\n\n    case 5: mode = MODE_1_2_2;   sce = 1; cpe = 2; break;\n\n    case 6: mode = MODE_1_2_2_1; sce = 2; cpe = 2; break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unsupported number of channels %d\\n\", avctx->channels);\n\n        goto error;\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELMODE,\n\n                                   mode)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unable to set channel mode %d: %s\\n\", mode, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELORDER,\n\n                                   1)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unable to set wav channel order %d: %s\\n\",\n\n               mode, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (avctx->flags & CODEC_FLAG_QSCALE || s->vbr) {\n\n        int mode = s->vbr ? s->vbr : avctx->global_quality;\n\n        if (mode <  1 || mode > 5) {\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"VBR quality %d out of range, should be 1-5\\n\", mode);\n\n            mode = av_clip(mode, 1, 5);\n\n        }\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Note, the VBR setting is unsupported and only works with \"\n\n               \"some parameter combinations\\n\");\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATEMODE,\n\n                                       mode)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to set the VBR bitrate mode %d: %s\\n\",\n\n                   mode, aac_get_error(err));\n\n            goto error;\n\n        }\n\n    } else {\n\n        if (avctx->bit_rate <= 0) {\n\n            if (avctx->profile == FF_PROFILE_AAC_HE_V2) {\n\n                sce = 1;\n\n                cpe = 0;\n\n            }\n\n            avctx->bit_rate = (96*sce + 128*cpe) * avctx->sample_rate / 44;\n\n            if (avctx->profile == FF_PROFILE_AAC_HE ||\n\n                avctx->profile == FF_PROFILE_AAC_HE_V2 ||\n\n                s->eld_sbr)\n\n                avctx->bit_rate /= 2;\n\n        }\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATE,\n\n                                       avctx->bit_rate)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to set the bitrate %d: %s\\n\",\n\n                   avctx->bit_rate, aac_get_error(err));\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    /* Choose bitstream format - if global header is requested, use\n\n     * raw access units, otherwise use ADTS. */\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_TRANSMUX,\n\n                                   avctx->flags & CODEC_FLAG_GLOBAL_HEADER ? 0 : s->latm ? 10 : 2)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set the transmux format: %s\\n\",\n\n               aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (s->latm && s->header_period) {\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_HEADER_PERIOD,\n\n                                       s->header_period)) != AACENC_OK) {\n\n             av_log(avctx, AV_LOG_ERROR, \"Unable to set header period: %s\\n\",\n\n                    aac_get_error(err));\n\n             goto error;\n\n        }\n\n    }\n\n\n\n    /* If no signaling mode is chosen, use explicit hierarchical signaling\n\n     * if using mp4 mode (raw access units, with global header) and\n\n     * implicit signaling if using ADTS. */\n\n    if (s->signaling < 0)\n\n        s->signaling = avctx->flags & CODEC_FLAG_GLOBAL_HEADER ? 2 : 0;\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_SIGNALING_MODE,\n\n                                   s->signaling)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set signaling mode %d: %s\\n\",\n\n               s->signaling, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_AFTERBURNER,\n\n                                   s->afterburner)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set afterburner to %d: %s\\n\",\n\n               s->afterburner, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (avctx->cutoff > 0) {\n\n        if (avctx->cutoff < (avctx->sample_rate + 255) >> 8) {\n\n            av_log(avctx, AV_LOG_ERROR, \"cutoff valid range is %d-20000\\n\",\n\n                   (avctx->sample_rate + 255) >> 8);\n\n            goto error;\n\n        }\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_BANDWIDTH,\n\n                                       avctx->cutoff)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to set the encoder bandwidth to %d: %s\\n\",\n\n                   avctx->cutoff, aac_get_error(err));\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    if ((err = aacEncEncode(s->handle, NULL, NULL, NULL, NULL)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to initialize the encoder: %s\\n\",\n\n               aac_get_error(err));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if ((err = aacEncInfo(s->handle, &info)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to get encoder info: %s\\n\",\n\n               aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n#if FF_API_OLD_ENCODE_AUDIO\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto error;\n\n    }\n\n#endif\n\n    avctx->frame_size = info.frameLength;\n\n    avctx->delay      = info.encoderDelay;\n\n    ff_af_queue_init(avctx, &s->afq);\n\n\n\n    if (avctx->flags & CODEC_FLAG_GLOBAL_HEADER) {\n\n        avctx->extradata_size = info.confSize;\n\n        avctx->extradata      = av_mallocz(avctx->extradata_size +\n\n                                           FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!avctx->extradata) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto error;\n\n        }\n\n\n\n        memcpy(avctx->extradata, info.confBuf, info.confSize);\n\n    }\n\n    return 0;\n\nerror:\n\n    aac_encode_close(avctx);\n\n    return ret;\n\n}\n", "idx": 4800, "substitutes": {"avctx": [" avcontext", "averparams", "wavctx", "ravdict", "ajhistory", "avdict", "vartmp", "avercv", "ajparams", "avcv", "aversc", "ravctx", "avgc", "ivertx", "avectx", "wavtx", "ravcontext", "ravparams", "avercu", "avertmp", " avdict", "iverctx", " avsys", " avheight", "vrcv", "averca", " avcmp", "ajjp", "vrctx", "iverdict", "avcu", "varctx", "navctx", "avsys", "avnp", "iverpy", "avetx", "avedt", " avkt", "averhistory", "avergc", " avcookie", "ravjp", " avtx", "avercmp", "AVsc", "averparent", "vrgc", " avkw", "cvkw", "cvcontext", "ravcu", "avparams", "varcontext", "avpkg", "ivernp", "ajparent", "cvctx", "avercontext", "avcontext", "averctx", "avtmp", "aveca", "avekt", "iverheight", " avjp", " avhistory", "ajctx", "aversetup", "avheight", "avkt", "ivercontext", "averpy", "ajdt", "ravca", "avdt", "avesys", "averpkg", "avenp", "AVcmp", "ajcu", "ajkt", "iversetup", "avjp", "ravcv", "avecv", "avcookie", "avca", "avconf", "vrpkg", "ivergc", "avhistory", "averjp", "AVcontext", "navdt", "ajpy", "ajcontext", "avsetup", "ravheight", "avecontext", "AVctx", "avepkg", "navsys", "ajsys", "wavnp", "avkw", " avtmp", " avsc", "avsc", "ajsetup", "avcmp", "averconf", "varcookie", "ravconf", "iverparent", "avekw", "avpy", "avparent", "avtx", "aveconf", "navhistory", "wavgc", "avehistory", "avercookie", "avegc", "cvtx"], "s": ["sc", "t", "os", "S", "p", "sports", "ds", "is", "a", "ms", "d", "v", "vs", "ctx", "ins", "ps", "ies", "sm", "sam", "w", "set", "ss", "self", "h", "j", "ys", "bs", "source", "js", "ns", "hs", "sq", "ses", "scl", "sts", "rs", "gs", "y", "ts", "es", "stats", "fs", "its", "sv", "cs", "sb", "c", "ls", "ats", "qs", "sys", "sa"], "mode": ["key", "stage", "MODE", "master", "pose", "door", "config", "use", "dim", "spec", "nom", "channel", "me", "policy", "direction", "menu", "error", "position", "scope", "version", "style", "kind", "module", "power", "only", "device", "option", "toggle", "multiple", "format", "metadata", "proc", "state", "name", "role", "phase", "multi", "type", "mid", "command", "status", "cmp", "code", "m", "scale", " scheme", "loop", "operator", "mm", "theme", "Mode", "purpose", "sequence", "mask", "mod", "mate", "message", "params", "cmd"], "err": ["fr", "gz", "conf", "arr", "it", "error", "msg", "txt", "ver", "iter", " res", "c", "gr", "z", "er", "cmd", "eas", "dev", "ch", "r", "ler", "obj", " terr", "or", "later", "ez", "js", "ner", "try", "report", "all", "sys", "Er", "kr", "rr", "ger", "good", " msg", "die", "here", "off", "fee", "rn", "e", "Error", "aaa", "notice", "ev", "out", "dr", "t", "elt", "dt", "warn", "cer", "rer", "lr", "norm", "cor", "req", " error", "cr", "attr", "result", "resp", "usr", "nr", "rev", "late", "cfg", "erd", "res", "tr", "test", "timer", "mr"]}}
{"project": "FFmpeg", "commit_id": "24947d4988012f1f0fd467c83418615adc11c3e8", "target": 1, "func": "static int vorbis_floor1_decode(vorbis_context *vc,\n\n                                vorbis_floor_data *vfu, float *vec)\n\n{\n\n    vorbis_floor1 *vf = &vfu->t1;\n\n    GetBitContext *gb = &vc->gb;\n\n    uint16_t range_v[4] = { 256, 128, 86, 64 };\n\n    unsigned range = range_v[vf->multiplier - 1];\n\n    uint16_t floor1_Y[258];\n\n    uint16_t floor1_Y_final[258];\n\n    int floor1_flag[258];\n\n    unsigned class, cdim, cbits, csub, cval, offset, i, j;\n\n    int book, adx, ady, dy, off, predicted, err;\n\n\n\n\n\n    if (!get_bits1(gb)) // silence\n\n        return 1;\n\n\n\n// Read values (or differences) for the floor's points\n\n\n\n    floor1_Y[0] = get_bits(gb, ilog(range - 1));\n\n    floor1_Y[1] = get_bits(gb, ilog(range - 1));\n\n\n\n    av_dlog(NULL, \"floor 0 Y %d floor 1 Y %d \\n\", floor1_Y[0], floor1_Y[1]);\n\n\n\n    offset = 2;\n\n    for (i = 0; i < vf->partitions; ++i) {\n\n        class = vf->partition_class[i];\n\n        cdim   = vf->class_dimensions[class];\n\n        cbits  = vf->class_subclasses[class];\n\n        csub = (1 << cbits) - 1;\n\n        cval = 0;\n\n\n\n        av_dlog(NULL, \"Cbits %u\\n\", cbits);\n\n\n\n        if (cbits) // this reads all subclasses for this partition's class\n\n            cval = get_vlc2(gb, vc->codebooks[vf->class_masterbook[class]].vlc.table,\n\n                            vc->codebooks[vf->class_masterbook[class]].nb_bits, 3);\n\n\n\n        for (j = 0; j < cdim; ++j) {\n\n            book = vf->subclass_books[class][cval & csub];\n\n\n\n            av_dlog(NULL, \"book %d Cbits %u cval %u  bits:%d\\n\",\n\n                    book, cbits, cval, get_bits_count(gb));\n\n\n\n            cval = cval >> cbits;\n\n            if (book > -1) {\n\n                floor1_Y[offset+j] = get_vlc2(gb, vc->codebooks[book].vlc.table,\n\n                vc->codebooks[book].nb_bits, 3);\n\n            } else {\n\n                floor1_Y[offset+j] = 0;\n\n            }\n\n\n\n            av_dlog(NULL, \" floor(%d) = %d \\n\",\n\n                    vf->list[offset+j].x, floor1_Y[offset+j]);\n\n        }\n\n        offset+=cdim;\n\n    }\n\n\n\n// Amplitude calculation from the differences\n\n\n\n    floor1_flag[0] = 1;\n\n    floor1_flag[1] = 1;\n\n    floor1_Y_final[0] = floor1_Y[0];\n\n    floor1_Y_final[1] = floor1_Y[1];\n\n\n\n    for (i = 2; i < vf->x_list_dim; ++i) {\n\n        unsigned val, highroom, lowroom, room, high_neigh_offs, low_neigh_offs;\n\n\n\n        low_neigh_offs  = vf->list[i].low;\n\n        high_neigh_offs = vf->list[i].high;\n\n        dy  = floor1_Y_final[high_neigh_offs] - floor1_Y_final[low_neigh_offs];  // render_point begin\n\n        adx = vf->list[high_neigh_offs].x - vf->list[low_neigh_offs].x;\n\n        ady = FFABS(dy);\n\n        err = ady * (vf->list[i].x - vf->list[low_neigh_offs].x);\n\n        off = err / adx;\n\n        if (dy < 0) {\n\n            predicted = floor1_Y_final[low_neigh_offs] - off;\n\n        } else {\n\n            predicted = floor1_Y_final[low_neigh_offs] + off;\n\n        } // render_point end\n\n\n\n        val = floor1_Y[i];\n\n        highroom = range-predicted;\n\n        lowroom  = predicted;\n\n        if (highroom < lowroom) {\n\n            room = highroom * 2;\n\n        } else {\n\n            room = lowroom * 2;   // SPEC mispelling\n\n        }\n\n        if (val) {\n\n            floor1_flag[low_neigh_offs]  = 1;\n\n            floor1_flag[high_neigh_offs] = 1;\n\n            floor1_flag[i]               = 1;\n\n            if (val >= room) {\n\n                if (highroom > lowroom) {\n\n                    floor1_Y_final[i] = val - lowroom + predicted;\n\n                } else {\n\n                    floor1_Y_final[i] = predicted - val + highroom - 1;\n\n                }\n\n            } else {\n\n                if (val & 1) {\n\n                    floor1_Y_final[i] = predicted - (val + 1) / 2;\n\n                } else {\n\n                    floor1_Y_final[i] = predicted + val / 2;\n\n                }\n\n            }\n\n        } else {\n\n            floor1_flag[i]    = 0;\n\n            floor1_Y_final[i] = predicted;\n\n        }\n\n\n\n        av_dlog(NULL, \" Decoded floor(%d) = %u / val %u\\n\",\n\n                vf->list[i].x, floor1_Y_final[i], val);\n\n    }\n\n\n\n// Curve synth - connect the calculated dots and convert from dB scale FIXME optimize ?\n\n\n\n    ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, floor1_flag, vf->multiplier, vec, vf->list[1].x);\n\n\n\n    av_dlog(NULL, \" Floor decoded\\n\");\n\n\n\n    return 0;\n\n}\n", "idx": 4801, "substitutes": {"vc": ["vp", "cu", "gt", "tv", "vi", "cv", "vin", "v", "vl", "lc", "ctx", "vs", "veh", "pc", "ic", "inv", "vg", "serv", "VC", "fw", "cb", "vv", "cc", "nv", "vet", "vr", "GV", "fc", "cow", "ht", "vd", "ib", "vm", "vo", "iv", "xc", "conv", "sv", "csv", "lv", "c", "wcs", "voc", "vt", "av", "bc", "vy", "uv"], "vfu": ["svfu", " vau", "vrf", "mbo", "mrf", "mfu", " vFu", "vbo", "mFu", "svrf", " vbo", " vrf", "svpu", "vcpu", "vcau", "vpu", "svbo", "svFu", "vau", "vcfu", "vFu", "svau", " vpu"], "vec": ["tv", "cv", "sel", "v", "ec", "ff", "nv", "vid", "ve", "fc", "vector", "def", "ver", "buf", "ref", "len", "xy", "cam", "iv", "sv", "cod", "pos", "ev", "uv"], "vf": ["invfa", "verbf", "versionf", "svfd", "versionfc", "ovfd", "vlf", "vcfx", "avbf", " vfd", "cvff", "cvf", " vff", "vrfac", "verfc", "vrfa", " vbf", "avfu", "verf", " vfx", "vclf", "vrff", "vfs", " vfo", "vfo", " vfs", "avcf", "vfa", "ovfc", "vrfunc", "Vfc", "vtf", "svfal", "devff", "devfc", "cfs", "cvfac", "vF", "svfa", "cvfunc", "verfo", "vcfu", "invf", "versionfal", "avfx", "vcfunc", "svfc", "vfal", " vfc", "vrfc", "vfc", "cfc", "vfunc", "vrc", "vrf", "invfunc", "Vbf", "vbf", "vtfunc", "svc", "Vfo", "vtlf", "vcf", "Vf", "svcf", "avfa", " vF", "vcfac", "vfl", "avf", "vfd", "svfs", "ovfs", "versionfs", "vcfa", "vrcf", "vrF", "vcbf", "devF", " vfl", "vfx", "devf", "avc", "invlf", "vtfa", "cf", "vff", "vcff", "svf", " vfal", "svfl", "vfac", "cfl", "ovf"], "gb": ["gm", "gz", "bn", "html", "lb", "gt", "cv", "bt", "bm", "binary", "ctx", "fb", "eg", "hub", "linux", "pg", "vg", "rl", "gpu", "cb", "ruby", "gc", "io", "hog", "gd", "rb", "rg", "asm", "b", "bb", "bytes", "g", "pb", "mb", "range", "Gb", "gs", "kb", "gnu", "vm", "xy", "db", "cfg", "bg", "tg", "ubis", "gg", "gp", "GB", "bits", "storage", "rect", "eb", "yg", "gam", "csv", "sb", "gif", "bf", "nb", "vt", "img", "wb", "uv"], "range_v": ["Range_v", "range_h", " range_c", " range_h", "Range_cv", "range_c", "range_cv", "range_m", "Range_c", " range_m", "Range_m"], "floor1_Y": ["floor0_YY", "floorOne_X", "floor11_Y", "floor1___D", "floor0_Y", "floor1_MY", "floor6_N", "floor11_X", "floor1XYY", "floor1Xy", "floor1___YY", "floor1___Y", "floor6_Y", "floorOne_Y", "floorOne_YY", "floor1_D", "floor1_YY", "floor11_S", "floor1_S", "floor0_y", "floor1_X", "floor6_MY", "floor6_X", "floor1_N", "floor1_y", "floor1___y", "floorOne_y", "floor1XY", "floor1XX"], "floor1_Y_final": ["floor1_Y2Final", "floor1_Y_last", "floor1_y_final", "floor1_Y2last", "floor1_Y2final", "floor1_y_last", "floor1_Y_unsigned", "floor1_y_Final", "floor1_Y_Final", "floor1_Y2unsigned", "floor1_y_unsigned"], "floor1_flag": ["floor1_offset", "floor2_offset", "floor2_flag", "floor1Toffset", "floor1Tflags", "floor1Tflag", "floor2_x", "floor1Tx", "floor2_flags", "floor1_x", "floor1_flags"], "class": ["sc", "pack", "Class", "classes", "id", "binary", "l", "lc", "lass", "spec", "label", "list", "file", "ic", "scope", "cd", "con", "cl", "cc", "style", "prop", "course", "kind", "module", "bus", "size", "chain", "fc", "cell", "ex", "classified", "b", "state", "index", "name", "link", "type", " Class", "interface", "CLASS", "status", "code", "line", "table", "base", "cs", "title", "test", "count", "c", "user", "vol", "box", "lab", "lib"], "cdim": [" cdimen", "condim", " cdimm", "cedim", "czom", "cedimm", "ddims", "codims", "condiv", "condip", "codiam", "ddimen", " cdiam", "ddom", "codir", "cdims", "cdiam", "czip", "cdimen", "cdimm", "czimen", " cdiv", "cdiv", "ddim", "cdom", "codim", "cdip", "ddip", "ddiam", " cdip", "cedip", " cdims", "czim", "cdir", "cediv", "condimm", " cdir", "ddir", " cdom"], "cbits": ["pbis", "cvbits", " ckeys", "cbanks", "pbanks", "Cbs", "cuints", "cbugs", "cubits", "cbs", "cobs", " cobs", "acvals", "cnets", " cbanks", "cumvals", "cobps", "coints", " cbs", "cybits", "cvkeys", " cbit", "cflags", "Cvals", "covals", "acits", "acbs", "lobs", " cbugs", "rcbits", "lbits", " cbis", "cbytes", "cunets", "cvals", "cvbps", " cvals", "cints", "cumobs", "cuits", "cbis", "ckeys", "rcobs", "cubugs", "rcbs", "cokeys", "pbits", " cnets", "coobs", "coits", " cbps", "cvits", " cints", " cits", "lbs", "pbs", "cobugs", "Cbit", "cbps", "acbits", "acbit", "cobits", "cits", "lbytes", "cukeys", "rcbytes", "cybs", "acflags", " cbytes", "cbit", "cybanks", "acnets", "Cbits", " cflags", "cybis", "cuflags", "cumbps", "cumbits"], "csub": ["ckssub", "cssubs", "dsum", "cusubs", "codesubs", "rsub", "codesub", "csUB", "dsug", "csssub", "ksUB", "cksub", "cksug", "ksubs", "cussub", "csubs", "rssub", "codessub", "ksub", "csug", "kssub", "dsubs", "cksUB", "csum", "rsum", "cusub", "codesug", "cksum", "cssUB", "codesum", "dsub", "cssub", "cksubs", "cusum", "rsubs"], "cval": ["cvol", " cserv", "cVAL", "Cvalue", "cpVal", "call", "cdata", "vall", "nval", " cbin", "tVal", "tserv", "rcVal", "acval", "lcvalue", " cdata", "tval", "dcvalid", "deval", "rbin", "acVal", " cVAL", " ctest", "cptest", " cVal", " ceval", "nserv", "tvalue", "xcserv", "dcval", " cvol", "lcval", "vVAL", "cvalid", "xcval", "cabel", "cvals", "dvalue", "lcvol", "cVal", "rvals", "rcdef", " cvals", "cpval", " cabel", " cvalue", "cdef", "cpdef", "cbin", "Cval", "rserv", "vval", "xcvalue", "acdata", "xceval", "ctest", " cdef", " call", "dserv", "Cdata", "lcvalid", "cvalue", "dval", "acvalue", "dcserv", "ceval", "rval", "nbin", "lcabel", "rcval", "vvol", "CVal", "lcVal", "lcserv", "nvals", "lcVAL", " cvalid", "cserv", "dcabel", "lcall", "rctest"], "offset": ["order", "seek", "bound", "origin", "id", "ind", "length", "ix", "error", "position", "prefix", "address", "set", "axis", "pad", "o", "attribute", "lock", "location", "size", "pointer", "index", "slot", "point", "shift", "slice", "trace", "timeout", "scroll", "range", "type", "buffer", "seed", "row", "end", "table", "base", "Offset", "count", "pos", "start", "next", "batch"], "i": ["li", "p", "through", "bi", "f", "a", "is", "id", "l", "v", "ii", "ini", "ind", "r", "mi", "ix", "me", "it", "ic", "\u0438", "si", "ish", "k", "h", "di", "o", "gi", "lock", "io", "in", "ri", "ie", "ex", "ip", "b", "index", "name", "info", "at", "iu", "multi", "ij", "y", "xi", "zi", "e", "ci", "ti", "m", "ai", "pi", "im", "x", "I", "phi", "us", "c", "by", "n"], "j": ["json", "fr", "dj", "p", "bj", "d", "jj", "v", "l", "jl", "it", "q", "jc", "other", "aj", "k", "jo", "h", "o", "js", "ji", "jump", "b", "index", "oj", "g", "ij", "y", "kj", "jp", "uj", "m", "jas", "try", "job", "ja", "x", "jack", "c", "us", "J", "n", "z", "er", "bot"], "book": ["bo", "buy", "journal", "pack", "family", "card", "led", "volume", "label", "quant", "check", "thing", "obj", "reader", "cb", "counter", "hold", "alias", "read", "package", "bus", "BOOK", "cell", "b", " bookmark", "bind", "car", "buf", "books", "black", "uc", "Book", "area", "cmp", "record", "unit", "home", "table", "base", "test", "bank", "var", "count", "bc", "item", "bin", "back", "bu", "block", "box", "chapter", "ab", "lib"], "adx": ["madxi", " adox", "adxi", "adrx", "aidrx", "madx", "madrx", " adrx", "aidox", "adox", "aidx", " adxi", "aidxi", "madox"], "ady": ["kay", "aa", "adapt", "along", "wx", "rr", "my", "aj", "ax", "az", "adv", "adr", "ey", "mx", "nr", "addy", "ay", "asy", "ads", "ya", "aily", "ac", "eddy", "yan", "oly", "arm", "fy", "uy", "ada"], "dy": ["py", "dj", "dt", "ds", "ty", "dim", "dd", "ded", "phy", "dq", "die", "wy", "dl", "dn", "did", "ey", "dir", "dx", "y", "xy", "ay", "dll", "iy", "oy", "deb", "yd", "yy", "dem"], "off": ["bo", "dev", "loss", "prof", "obj", "ox", "ff", "wo", "ok", "o", "oo", "attr", "of", "def", "buf", "height", "op", "opp", "fo", "det", "ov", "offs", "on", "pos", "oe"], "predicted": ["replicated", "indicted", "replicted", "predicated", "prediction", "redicated", "indicated", "rediction", "induced", "indiction", "reduced", "repliction", "repluced", "preduced", "redicted"], "err": ["ptr", "rc", "order", "elt", "progress", "train", "arr", "lr", "rate", "rr", "norm", "error", "msg", "obj", "str", "br", "cr", "attr", "result", "buf", "ner", "rev", "iter", "res", "er", "ev", "score"]}}
{"project": "qemu", "commit_id": "b3f7f0c5e6449be7275f1762bccbfa2177395a3b", "target": 1, "func": "static void colo_process_checkpoint(MigrationState *s)\n{\n    QIOChannelBuffer *bioc;\n    QEMUFile *fb = NULL;\n    int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n    Error *local_err = NULL;\n    int ret;\n    failover_init_state();\n    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);\n    if (!s->rp_state.from_dst_file) {\n        error_report(\"Open QEMUFile from_dst_file failed\");\n    /*\n     * Wait for Secondary finish loading VM states and enter COLO\n     * restore.\n     */\n    colo_receive_check_message(s->rp_state.from_dst_file,\n                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);\n    if (local_err) {\n    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);\n    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));\n    object_unref(OBJECT(bioc));\n    qemu_mutex_lock_iothread();\n    vm_start();\n    qemu_mutex_unlock_iothread();\n    trace_colo_vm_state_change(\"stop\", \"run\");\n    while (s->state == MIGRATION_STATUS_COLO) {\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n        if (current_time - checkpoint_time <\n            s->parameters.x_checkpoint_delay) {\n            int64_t delay_ms;\n            delay_ms = s->parameters.x_checkpoint_delay -\n                       (current_time - checkpoint_time);\n            g_usleep(delay_ms * 1000);\n        ret = colo_do_checkpoint_transaction(s, bioc, fb);\n        if (ret < 0) {\n        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\nout:\n    /* Throw the unreported error message after exited from loop */\n    if (local_err) {\n        error_report_err(local_err);\n    if (fb) {\n        qemu_fclose(fb);\n    if (s->rp_state.from_dst_file) {\n        qemu_fclose(s->rp_state.from_dst_file);", "idx": 4815, "substitutes": {"s": ["states", "t", "os", "S", "p", "sports", "steps", "ds", "details", "south", "is", "https", "ms", "l", "v", "r", "ps", "spec", "ins", "vs", "ies", "less", "ss", "self", "events", "aws", "h", "comm", "changes", "bs", "source", "js", "ns", "hs", "state", "sq", "ses", "sts", "rs", "gs", "ts", "es", "e", "ops", "stats", "has", "results", "m", "its", "fs", "sis", "sv", "cs", "args", "ims", "parts", "als", "settings", "ls", "series", "ats", "n", "sys", "qs", "sw", "services"], "bioc": ["jiog", "fiob", " biog", "biroc", "boos", "giob", "giov", "bios", "biosc", "biocation", "biOC", "jiroc", "niov", "jiocy", "yiosc", "jiocation", "jiok", "pios", "gios", " biov", "boocy", " biocy", "boob", " biob", "pioc", "hiog", "jiosc", "booc", "fiov", "biok", " biOC", "hioc", "yioc", " bioko", "kioc", "nioc", "biou", "biob", "yiocation", "kiocation", "boov", "niob", "hiou", "bioko", "piov", "piob", " biou", "biog", "jiou", "jiov", "kiosc", "yiok", "biov", "jioc", "jioko", "fioc", "gioc", "biocy", "boroc", " biroc", "fiOC", "niOC", "kiok", "hioko"], "fb": ["hd", "fg", "lb", "fn", "fi", "nb", "tf", "bt", "raf", "fm", "fd", "fw", "cb", "ff", "abb", "xf", "buff", "fc", "FB", "bb", "fab", "xb", "erb", "buf", "pb", "mb", "usb", "gb", "rf", "fp", "db", "bg", "bridge", "eb", "bp", "deb", "uf", "facebook", "sb", "stab", "ob", "bf", "rb", "wb"], "current_time": ["current12time", "currentpyTime", "Current_time", "current_speed", "capacitytimespeed", "current_etime", "capacitytimeetime", "current_timeout", "currentjlevel", "current_hour", "current12request", "currentjmoney", "current_name", "currentingname", "givenvaltime", "current_level", "Current_Time", "capacity_time", "currentingtime", "critical_runtime", "criticalTimetime", "capacitytimetime", "currentvallevel", "currentingruntime", "currentTimename", "capacity_etime", "currentvaltime", "currentTimeruntime", "current_request", "criticalTimeruntime", "currentvalrequest", "critical_hour", "currentTimetime", "currentTimespeed", "currenttimeetime", "Current_timeout", "current_runtime", "current12level", "critical_time", "criticalTimehour", "currentvalmoney", "currenttimetime", "currentpytimeout", "given_money", "given_time", "currenttimespeed", "currentpytime", "givenvalrequest", "currentinghour", "given_request", "currentTimehour", "current_Time", "given_level", "givenvalmoney", "currentTimeetime", "criticalTimename", "givenvallevel", "critical_name", "current_money", "capacity_speed", "current12money", "currentjtime", "currentjrequest"], "local_err": ["local_notice", "internal_arr", "local___attr", "locallynotice", "local___Er", "managed_err", "local_error", "localaxyr", "local_cfg", "internal___err", "internal___r", "local_buf", "local___r", "local___err", "localederr", "local___cfg", "managedlyelt", "managed_arr", "internal_r", "local_msg", "local_r", "singlelyerr", "localaxyarr", " local_buf", "single_attr", "local_timer", "single_Er", "single_notice", "locallyattr", "local_arr", "local___br", "managed_cfg", "localednotice", " local_msg", "singlelyEr", "singlelynotice", "locallyelt", "singlelyattr", "managed_elt", "managedlycfg", " local_error", "local_er", "managedlyarr", "locallyarr", "localedattr", "localedtimer", "locallyerr", "single_err", "localaxybr", "internal_err", "local___elt", "localaxyerr", "managedlyerr", " local_er", "local_Er", "locallyEr", "internal___br", "localedEr", "local_elt", "locallycfg", "internal___arr", "internal_br", "localeder", "localedmsg", " local_timer", "local___arr", "local___notice", "local_br", "local_attr"], "ret": ["deg", "git", "t", "elt", "inter", "gt", "reset", "tf", "ll", "RET", "rm", "arg", "nt", "re", "r", "cont", "Ret", "ft", "rets", "ext", "val", "mail", "rem", "jump", "mt", "result", "usr", "resp", "lt", "def", "err", "sys", "net", "ber", "ref", "status", "len", "iter", "res", "tr", "job", "flag", " RET", " Ret", "args", "back", "alt", "nl", "reply", "rt", "out"], "delay_ms": ["dl_mb", "late_min", "delay_mm", "delay3ms", "delay3min", "late00min", "late_mas", "late00ms", "skip_mm", "delay_ls", "delaylymas", "delaylyms", "late_ms", "late00mas", "delay_ds", "dl_ts", "delay00ts", "delay_mo", "delaylyds", "delay_min", "delay_mas", "skip_ms", "skip_ls", "dl_ms", "late00ds", "delay_ts", "delay00ms", "skip_mo", "delay_fs", "delay00min", "dl_fs", "delay3mas", "delaylymin", "late_ds", "delay00mb", "delay00fs", "delay00ds", "delay3ds", "delay00mas", "delay_mb"]}}
{"project": "qemu", "commit_id": "c97294ec1b9e36887e119589d456557d72ab37b5", "target": 0, "func": "static void pc_init1(QEMUMachineInitArgs *args,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    MemoryRegion *system_memory = get_system_memory();\n\n    MemoryRegion *system_io = get_system_io();\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *gsi;\n\n    qemu_irq *i8259;\n\n    qemu_irq *smi_irq;\n\n    GSIState *gsi_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n    ISADevice *floppy;\n\n    MemoryRegion *ram_memory;\n\n    MemoryRegion *pci_memory;\n\n    MemoryRegion *rom_memory;\n\n    DeviceState *icc_bridge;\n\n    FWCfgState *fw_cfg = NULL;\n\n    PcGuestInfo *guest_info;\n\n\n\n    if (xen_enabled() && xen_hvm_init(&ram_memory) != 0) {\n\n        fprintf(stderr, \"xen hardware virtual machine initialisation failed\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE);\n\n    object_property_add_child(qdev_get_machine(), \"icc-bridge\",\n\n                              OBJECT(icc_bridge), NULL);\n\n\n\n    pc_cpus_init(args->cpu_model, icc_bridge);\n\n\n\n    if (kvm_enabled() && kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    /* Check whether RAM fits below 4G (leaving 1/2 GByte for IO memory).\n\n     * If it doesn't, we need to split it in chunks below and above 4G.\n\n     * In any case, try to make sure that guest addresses aligned at\n\n     * 1G boundaries get mapped to host addresses aligned at 1G boundaries.\n\n     * For old machine types, use whatever split we used historically to avoid\n\n     * breaking migration.\n\n     */\n\n    if (args->ram_size >= 0xe0000000) {\n\n        ram_addr_t lowmem = gigabyte_align ? 0xc0000000 : 0xe0000000;\n\n        above_4g_mem_size = args->ram_size - lowmem;\n\n        below_4g_mem_size = lowmem;\n\n    } else {\n\n        above_4g_mem_size = 0;\n\n        below_4g_mem_size = args->ram_size;\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_memory = g_new(MemoryRegion, 1);\n\n        memory_region_init(pci_memory, NULL, \"pci\", UINT64_MAX);\n\n        rom_memory = pci_memory;\n\n    } else {\n\n        pci_memory = NULL;\n\n        rom_memory = system_memory;\n\n    }\n\n\n\n    guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size);\n\n\n\n    guest_info->has_acpi_build = has_acpi_build;\n\n\n\n    guest_info->has_pci_info = has_pci_info;\n\n    guest_info->isapc_ram_fw = !pci_enabled;\n\n\n\n    if (smbios_defaults) {\n\n        /* These values are guest ABI, do not change */\n\n        smbios_set_defaults(\"QEMU\", \"Standard PC (i440FX + PIIX, 1996)\",\n\n                            args->machine->name);\n\n    }\n\n\n\n    /* allocate ram and load rom/bios */\n\n    if (!xen_enabled()) {\n\n        fw_cfg = pc_memory_init(system_memory,\n\n                       args->kernel_filename, args->kernel_cmdline,\n\n                       args->initrd_filename,\n\n                       below_4g_mem_size, above_4g_mem_size,\n\n                       rom_memory, &ram_memory, guest_info);\n\n    }\n\n\n\n    gsi_state = g_malloc0(sizeof(*gsi_state));\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_pc_setup_irq_routing(pci_enabled);\n\n        gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,\n\n                                 GSI_NUM_PINS);\n\n    } else {\n\n        gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi,\n\n                              system_memory, system_io, args->ram_size,\n\n                              below_4g_mem_size,\n\n                              above_4g_mem_size,\n\n                              pci_memory, ram_memory);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus = isa_bus_new(NULL, system_io);\n\n        no_hpet = 1;\n\n    }\n\n    isa_bus_irqs(isa_bus, gsi);\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        i8259 = kvm_i8259_init(isa_bus);\n\n    } else if (xen_enabled()) {\n\n        i8259 = xen_interrupt_controller_init();\n\n    } else {\n\n        cpu_irq = pc_allocate_cpu_irq();\n\n        i8259 = i8259_init(isa_bus, cpu_irq[0]);\n\n    }\n\n\n\n    for (i = 0; i < ISA_NUM_IRQS; i++) {\n\n        gsi_state->i8259_irq[i] = i8259[i];\n\n    }\n\n    if (pci_enabled) {\n\n        ioapic_init_gsi(gsi_state, \"i440fx\");\n\n    }\n\n    qdev_init_nofail(icc_bridge);\n\n\n\n    pc_register_ferr_irq(gsi[13]);\n\n\n\n    pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL);\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, xen_enabled(),\n\n        0x4);\n\n\n\n    pc_nic_init(isa_bus, pci_bus);\n\n\n\n    ide_drive_get(hd, MAX_IDE_BUS);\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        if (xen_enabled()) {\n\n            dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        } else {\n\n            dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        }\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            char busname[] = \"ide.0\";\n\n            dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i],\n\n                               ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            /*\n\n             * The ide bus name is ide.0 for the first bus and ide.1 for the\n\n             * second one.\n\n             */\n\n            busname[4] = '0' + i;\n\n            idebus[i] = qdev_get_child_bus(DEVICE(dev), busname);\n\n        }\n\n    }\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, args->boot_order,\n\n                 floppy, idebus[0], idebus[1], rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled(false)) {\n\n        pci_create_simple(pci_bus, piix3_devfn + 2, \"piix3-usb-uhci\");\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        I2CBus *smbus;\n\n\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              gsi[9], *smi_irq,\n\n                              kvm_enabled(), fw_cfg);\n\n        smbus_eeprom_init(smbus, 8, NULL, 0);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n", "idx": 4835, "substitutes": {"args": ["flags", "tests", "config", "ras", "atts", "arg", "ms", "aus", "arr", "arms", "aw", "users", "links", "objects", "GS", "locks", "obj", "amps", "options", "self", "aws", "caps", "points", "units", "changes", "GV", "js", "ns", "ians", "range", "limits", "gs", "ids", "ars", "images", "Args", "ts", "artifacts", "checks", "results", "cfg", "actions", "bits", "values", "orders", "ams", "ims", "ants", "apps", "parts", "aux", "terms", "settings", "cmd", "aps", "qs", "sys", "fields", "params", "yes", "eps"], "pci_enabled": ["pci_enable", "pci_Enabled", "pico_Enabled", "pci__enabled", "pci8enable", "pci__enable", "pico_enabled", "pci8Enabled", "pci8required", "pci__Enabled", "pci__required", "pico_enable", "pci_required", "pico_required", "pci8enabled"], "kvmclock_enabled": ["kvmclock_provided", "kvmclock_enable", "kvmlock_enabled", "kvmclocklyprovided", "kvmclocklyEnabled", "kvmclocklyenabled", "kvmlock_Enabled", "kvmclock2Enabled", "kvmlock_supported", "kvmclock2provided", "kvmclock_supported", "kvmclock_Enabled", "kvmlock_enable", "kvmclocklyenable", "kvmclock2enabled", "kvmclock2enable"], "system_memory": ["system_library", "system7library", "system7memory", "system__storage", "ram_system", "system__memory", "system7system", "ram_storage", "system7storage", "system_system", "system_storage", "system__library", "ram_library", "system__system"], "system_io": ["systemityerror", "system___error", "system_library", "sys_library", "system___library", "sys_ios", "system_error", "system_ios", "sys_error", "sys_io", "systemityio", "system___ios", "systemitylibrary", "systemityios", "system___io"], "i": ["ia", " I", "t", "li", "ei", "p", "bi", "a", "l", "ii", "si", "j", "di", "h", "io", "ip", "b", "xi", "e", "ci", "m", "pi", " j", "im", "I", "phi", "n", "ati"], "below_4g_mem_size": ["below_4g_mem_space", "below_4g_mem_len", "below_4g_mem_name", "below_4g_mem_Size"], "above_4g_mem_size": ["above_4g_ram_sum", "above_4g_Mem_size", "above_4g_ram_SIZE", "above_4g_mem_sum", "above_4g_Mem_SIZE", "above_4g_ram_size", "above_4g_Mem_Size", "above_4g_mem_Size", "above_4g_mem_SIZE"], "pci_bus": ["pci_boot", "pca_bus", "pci0bus", "pci_disk", "pca_disk", "pca_boot", "pci1boot", "pci0boot", "pci0dev", "pci1bus", "pci_dev", "pci0disk", "pci1dev", "pci1disk", "pca_dev"], "isa_bus": ["isa_boot", "isaamboot", "ista_bus", "isa_machine", "ista_machine", "isaambook", "isaambus", "isaammachine", "ista_book", "isa_book", "ista_boot"], "i440fx_state": ["i440fax_resource", "i440fax_status", "i440fx2status", "i440fxptstatus", "i440fxptstart", "i440fxptstate", "i440fx_status", "i440fxptresource", "i440fx2start", "i440fax_start", "i440fx2state", "i440faxptstatus", "i440fx_start", "i440faxptstart", "i440faxptstate", "i440faxptresource", "i440fx2resource", "i440fax_state", "i440fx_resource"], "cpu_irq": ["cpu_pirQ", "cpu__mirq", "cpu__irq", "cpu__irQ", "cpu__irques", "cpu_irQ", "cpu_pirqs", "cpu_irqs", "cpu_mirqs", "cpu_ibrQ", "cpu_mirq", "cpu__irqs", "cpu_mirQ", "cpu_irques", "cpu_pirq", "cpu_mirques", "cpu_ibrques", "cpu_ibrqs", "cpu__mirqs", "cpu__mirques", "cpu_pirques", "cpu_ibrq", "cpu__mirQ"], "gsi": ["mgsi", "mgsa", "mgdi", " gdi", "Gsm", "gdi", "Gdi", "Gsa", "gsm", " gsm", "Gsi", "gsa", "mgsm", " gsa"], "i8259": ["I9266", "i5259", "i9285", "i80285", "I9285", "i80191", "I8266", "i5191", "i8266", "i8285", "I8259", "i80259", "i8191", "i5266", "i9266", "i80266", "I8191", "I9259", "i5285", "i9259", "I9191", "I8285", "i9191"], "smi_irq": ["smi_pirq", "smi__pirqs", "smi_mirQ", "smi_pirqs", "smi__pirQ", "smi_IRq", "smi_irQ", "smi_irqs", "smi_mirq", "smi__irqs", "smi_pirQ", "smi__irq", "smi__irQ", "smi_IRQ", "smi_mirqs", "smi__pirq", "smi_IRqs"], "gsi_state": ["gami_state", "gsi__info", "gami_info", "gsi__config", "gsi_info", "gsi__status", "gsi_status", "gsi__state", "gami_config", "gsi_config", "gami_status"], "hd": ["HD", "dr", "ds", "haw", "dm", "dylib", "hid", "ha", "hz", "dd", "ded", "cd", "hi", "rh", "ld", "h", "he", "dl", "dh", "dn", "ssh", "ht", "hs", "him", "vd", "hw", "hp", "rt", "bd"], "MAX_IDE_BUS": ["MAX_IDEIPBO", "MAX_IDE__BO", "MAX_IDES__BO", "MAX_DE_IN", "MAX_IDEIPBUS", "MAX_IDES_PATH", "MAX_IDES__PATH", "MAX_IDEIPPATH", "MAX_IDE__IN", "MAX_DE_PATH", "MAX_DE_US", "MAX_IDE__US", "MAX_IDES__BUS", "MAX_DE_BUS", "MAX_IDES_BUS", "MAX_IDE_BO", "MAX_IDE_PATH", "MAX_IDE_IN", "MAX_IDE_US", "MAX_IDE__PATH", "MAX_IDE__BUS", "MAX_IDES_BO"], "MAX_IDE_DEVS": ["MAX_IDE_DAVs", "MAX_IDE2DEFS", "MAX_IDE2DEVS", "MAX_IDE_DAVS", "MAX_IDE_DVs", "MAX_IDE_DVS", "MAX_IDE_DEPS", "MAX_IDE2DVS", "MAX_IDE_DRVS", "MAX_IDE2DFS", "MAX_IDE_DAFS", "MAX_IDE_DRPS", "MAX_IDE_DRFS", "MAX_IDE2DEVs", "MAX_IDE_DEVs", "MAX_IDE_DFS", "MAX_IDE_DEFS", "MAX_IDE_DAPS", "MAX_IDE_DPS", "MAX_IDE2DPS", "MAX_IDE2DVs", "MAX_IDE2DEPS", "MAX_IDE_DRVs"], "idebus": ["itedev", "ridebus", "linebus", "linebal", "idestate", "linedev", "ridestate", "idebal", "linestate", "itebus", "idedev", "itestate", "itebal", "ridebal", "ridedev"], "rtc_state": ["rtf_states", "rtc__port", "rtc_states", "rtf_port", "rtc__status", "rtc_status", "rtc_port", "rtc__states", "rtf_status", "rtc__state", "rtf_state"], "floppy": ["flppy", "FLogo", "plppy", "FLppy", "plogo", "sloppy", "slppy", "FLoppy", "ploop", "floop", "slogo", "flogo", "ploppy", "FLoop", "sloop"], "ram_memory": ["ram_mem", "rammmstorage", "ram67memory", "system_metadata", "ram_hash", "ram_directory", "rammmmemory", "mem_directory", "mem_hash", "ram_metadata", "ram_storage", "ram67storage", "ram67hash", "system_storage", "rammmhash", "mem_storage", "system_mem", "ram67directory", "rammmdirectory", "mem_memory"], "pci_memory": ["pcu_ram", "pci___mem", "pcu_message", "pcu_memory", "pci___ram", "pci___memory", "pcu_mem", "pci___message", "pci_ram", "pci_mem", "pci_message"], "rom_memory": ["rom_mem", "ram_mem", "romacymem", "rom_margin", "ram_margin", "romaxymem", "romaxymachine", "romacymachine", "romaxymargin", "romacymargin", "ram_machine", "rom_machine", "romaxymemory", "romacymemory"], "icc_bridge": ["icc_device", "uci___forge", "uci_plugin", "icc67device", "icc_plugin", "uci_bridge", "ic_bridge", "icc___ridge", "ic_link", "icc_forge", "uci___plugin", "icc_dev", "icc_ridge", "iccptmaster", "uci_forge", "fc___device", "iccacdevice", "icc_master", "icoptbind", "icc_bind", "iccptbridge", "icc___forge", "icoptmaster", "fc_dev", "ico_device", "icc67dev", "iccacmaster", "icc___dev", "icoptbridge", "ico_bind", "icc___plugin", "uci_ridge", "icoptdevice", "fc___link", "ico_master", "uci___bridge", "icc___bridge", "icc67bridge", "fc___bridge", "fc_bridge", "icc67link", "icc___link", "fc_link", "uci___ridge", "iccptbind", "fc___dev", "icc_link", "ic_dev", "iccptdevice", "ic_ridge", "icc___device", "iccacbind", "ico_bridge", "iccacbridge", "fc_device"], "fw_cfg": ["fc_cfg", "fw2cfg", "fc_conf", "fc_fg", "fw_config", "fw_conf", "fw2conf", "fw2config", "fw_fg", "fw2fg", "fc_config"], "guest_info": ["guestuserfo", "guest2error", "guestusererror", "guest_error", "guet_error", "guestmyerror", "guest2dict", "guest_dict", "guet2info", "guet_dict", "guet2fo", "guestuserinfo", "guet_info", "guest_fo", "guestuserdict", "guestmyfo", "guet2error", "guet2dict", "guest2info", "guestmydict", "guest2fo", "guet_fo", "guestmyinfo"]}}
{"project": "qemu", "commit_id": "4bb3893908385836410346725dd9e584dcd24836", "target": 0, "func": "uint32_t wm8750_adc_dat(void *opaque)\n\n{\n\n    WM8750State *s = (WM8750State *) opaque;\n\n    uint32_t *data;\n\n\n\n    if (s->idx_in >= sizeof(s->data_in))\n\n        wm8750_in_load(s);\n\n\n\n    data = (uint32_t *) &s->data_in[s->idx_in];\n\n    s->req_in -= 4;\n\n    s->idx_in += 4;\n\n    return *data;\n\n}\n", "idx": 4842, "substitutes": {"opaque": ["ioposit", "patile", "boaques", "boacity", "ogaques", "ocaque", "iopaque", "opaques", "paque", "ogque", "iopque", "iopaques", "obaque", "ogosit", "opatile", "oposit", "obque", "opque", "paques", "obosit", "ocaques", "boatile", "ogaque", "ocacity", "ocatile", "opacity", "obaques", "pacity", "boaque"], "s": ["t", "os", "S", "ess", "conf", "p", "syn", "ds", "details", "is", "ms", "l", "sp", "soc", "ps", "spec", "sm", "sync", "z", "scope", "sl", "less", "ss", "self", "j", "h", "comm", "aws", "so", "source", "st", "bs", "space", "js", "ns", "hs", "ssl", "state", "i", "sq", "b", "ex", "g", "ses", "sts", "rs", "store", "gs", "y", "ts", "es", "stat", "stats", "ops", "fs", "service", "sis", "sv", "bis", "sb", "als", "ls", "qs", "n", "sys", "se", "sw", "sa"], "data": ["rew", "t", "relation", "p", "f", "a", "d", "join", "v", "r", "to", "mu", "aw", "DATA", "map", "str", "valid", "Data", "only", "o", "output", "empty", "dat", "format", "bytes", "result", "step", "response", "buffer", "text", "ata", " DATA", "m", "content", "raw", "rel", "window", "block", "message", "n", "value", "out", "batch"]}}
{"project": "qemu", "commit_id": "09e68369a88d7de0f988972bf28eec1b80cc47f9", "target": 0, "func": "static QmpInputVisitor *to_qiv(Visitor *v)\n\n{\n\n    return container_of(v, QmpInputVisitor, visitor);\n\n}\n", "idx": 4849, "substitutes": {"v": ["vp", "t", "p", "tv", "vi", "f", "gov", "vc", "l", "vs", "qv", "q", "vt", "ev", "w", "vv", "h", "j", "o", "vr", "i", "b", "V", "g", "y", "vm", "e", "m", "sv", "x", "c", "vis", "n", "u", "av", "uv"]}}
{"project": "FFmpeg", "commit_id": "11de006babf735aafa3462d43dd2c02bb6ac6e2f", "target": 0, "func": "static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    struct video_data *s = s1->priv_data;\n\n    AVFrame *frame = s1->streams[0]->codec->coded_frame;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    int res;\n\n\n\n    av_init_packet(pkt);\n\n    if ((res = mmap_read_frame(s1, pkt)) < 0) {\n\n        return res;\n\n    }\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (frame && s->interlaced) {\n\n        frame->interlaced_frame = 1;\n\n        frame->top_field_first = s->top_field_first;\n\n    }\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    return pkt->size;\n\n}\n", "idx": 4873, "substitutes": {"s1": ["tsOne", "wsone", "wsOne", "ts1", "rs0", "ts3", "rsone", "s2", "c0", "ts2", "rs1", "ts0", "S1", " s2", "rs2", " s3", "ws2", " sOne", "s0", "S2", "S3", "ws0", " sone", "sone", "c1", "sOne", "rsOne", " s0", "s3", "ws1", "c2"], "pkt": ["pet", "tct", "ppct", "tpkt", " pct", "opkt", "Packet", "pct", "Pct", "Pet", "pqt", "tpet", "opacket", "ppet", "opqt", "tpqt", "ppqt", "Pkt", "tacket", "Pqt", "packet", " pet", "ppkt", " pqt", "tet", " packet", "tpacket", "tkt", "opet"], "s": ["t", "os", "S", "p", "conf", "ds", "f", "ms", "d", "v", "ps", "spec", "ins", "z", "w", "less", "ss", "h", "aws", "space", "ns", "js", "b", "sq", "sid", "g", "rs", "gs", "ts", "e", "stats", "m", "bits", "fs", "sv", "session", "c", "ls", "series", "ats", "qs", "sys", "yes"], "frame": ["request", "fr", "ace", "t", "scene", "reset", "cast", "f", "fram", "iframe", "data", "draw", "channel", "sent", "component", "frames", "file", "image", "error", "q", "scope", "position", "force", "ox", "version", "set", "style", "one", "self", "valid", "profile", "result", "state", "def", "feature", "point", "info", "role", "trace", "type", "Frame", "response", "code", "e", "flow", "face", "m", "cf", "line", "bit", "flag", "base", "zone", "sequence", "window", "header", "feat", "video", "message", "picture", "block", "next", "rame", "close"], "res": ["ptr", "out", "VAL", "os", "reset", "respons", "details", "RES", "ras", "ms", "re", "ps", "RS", "Res", "pas", "red", "resolution", " Res", "str", "val", "cons", "ress", "rem", "size", "ret", "js", "result", "resh", "pres", "resp", "resources", "pers", "rev", "rs", "rest", "ber", "ts", "results", "vals", "fs", " RES", "gr", "des", "err"], "interlaced": ["interlacing", "interLaced", "InterLacing", "Interloved", "interLacing", "interboved", "InterLaced", "interbadic", "InterLadic", "InterLoved", "interreloved", "interrelaced", "interbaced", "interLadic", "interreladic", "interbacing", "interLoved", "interloved", "Interladic", "interrelacing", "Interlacing", "Interlaced", "interladic"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void bonito_pcihost_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = bonito_pcihost_initfn;\n\n    dc->no_user = 1;\n\n}\n", "idx": 4874, "substitutes": {"klass": ["eklass", "kicklasses", "ekclass", "Kls", "Kclass", "Klasses", "iklasses", "kicklass", "klasses", " kls", "eklasses", " klasses", "iklass", " kclass", "kickwl", " kwl", "ikls", "kclass", "Klass", "kls", "ekls", "kickls", "Kwl", "ikclass", "kwl"], "data": ["json", "key", "rc", "d", "func", "mu", " sd", "DATA", " Data", "di", "Data", "o", "dat", "def", "name", " d", "type", "da", "ata", "rec", " DATA", "res", "m", "raw", " dat", "c", "bin"], "dc": ["mc", "tc", "cm", "cp", "dm", "mk", "d", "iac", "ec", "lc", "ctx", "cca", "pc", "cd", "deck", "ga", " DC", "cc", "dk", "di", "gc", "cr", "fc", "nz", "pb", "da", "dp", "ck", "db", "ca", "disc", "DC", "ac", "c", "oc", "nc", "bc"], "k": ["ka", "key", "kh", "kan", "ke", "p", "K", "ki", "sk", "kn", "mk", "kk", "kr", "q", "ks", "aka", "wk", "ku", "dk", "kt", "j", "ok", "km", "i", "g", "kj", "ck", "ko", "ik", "ek", "kar", "ak", "c", "tk", "kw", "kit", "n"]}}
{"project": "FFmpeg", "commit_id": "955aec3c7c7be39b659197e1ec379a09f2b7c41c", "target": 0, "func": "static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base)\n\n{\n\n    uint32_t v, spf;\n\n    MPADecodeHeader c;\n\n    int vbrtag_size = 0;\n\n    MP3DecContext *mp3 = s->priv_data;\n\n\n\n    ffio_init_checksum(s->pb, ff_crcA001_update, 0);\n\n\n\n    v = avio_rb32(s->pb);\n\n    if(ff_mpa_check_header(v) < 0)\n\n      return -1;\n\n\n\n    if (avpriv_mpegaudio_decode_header(&c, v) == 0)\n\n        vbrtag_size = c.frame_size;\n\n    if(c.layer != 3)\n\n        return -1;\n\n\n\n    spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */\n\n\n\n    mp3->frames = 0;\n\n    mp3->size   = 0;\n\n\n\n    mp3_parse_info_tag(s, st, &c, spf);\n\n    mp3_parse_vbri_tag(s, st, base);\n\n\n\n    if (!mp3->frames && !mp3->size)\n\n        return -1;\n\n\n\n    /* Skip the vbr tag frame */\n\n    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);\n\n\n\n    if (mp3->frames)\n\n        st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},\n\n                                    st->time_base);\n\n    if (mp3->size && mp3->frames && !mp3->is_cbr)\n\n        st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf);\n\n\n\n    return 0;\n\n}\n", "idx": 4879, "substitutes": {"s": ["sc", "t", "os", "p", "S", "sports", "ds", "south", "is", "a", "ms", "sp", "r", "ps", "vs", "ins", "ctx", "sl", "w", "ss", "h", "aws", "bs", "i", "ns", "js", "hs", "b", "space", "sq", "sys", "g", "sts", "rs", "gs", "ts", "es", "stats", "its", "fs", "sv", "cs", "ims", "sb", "us", "ls", "n", "ats", "z", "qs", "se"], "st": ["ST", "ust", "stage", "sc", "fr", "t", "et", "th", "tmp", "tt", "sp", "r", "nt", "ctx", "ut", "it", "ost", "sta", "stable", "inst", "str", "set", "ss", "ist", "sth", "ast", "h", "pt", "so", "mt", "ste", "usr", "est", "stop", "b", "step", "std", "sts", "rest", "ts", "end", "stat", "storage", "sv", "stream", "ct", "nd", "St", "src", "start", "se", "sw"], "base": [" Base", "p", "bound", "max", " max", "bi", "f", "a", "origin", "id", "l", "sp", "r", "bas", " bases", "w", "offset", "server", "set", "pa", "h", "se", " start", "size", "i", " BASE", "b", "ui", "zero", "kb", "buffer", " bas", " from", "end", " b", "Base", "m", "e", "based", "db", "ase", "scale", "bp", "ta", "x", " k", "bf", "pe", "start", "out"], "v": [" va", "vp", "t", "p", "tv", "vi", "cv", "f", "vc", "l", " var", " sv", "r", "vs", "qv", " vs", "q", "vt", " x", "ev", "w", "vv", "version", "nv", "h", "j", "ve", "u", "vr", "wire", "i", " env", " h", " av", "b", "ver", " value", "g", " ov", "buffer", " val", "vm", " vm", "iv", "m", "conv", "sv", "ov", "var", "lv", " tv", "x", " f", " V", "V", "value", "av", "uv"], "spf": ["bspfs", "Sph", "spef", "aspfc", "spfr", "spfx", "psfc", " spfx", "ppz", "bspfc", "sph", "bspf", " spfc", "ppc", "spv", " spv", " spfs", "spl", " spz", " sph", "Spl", "psev", "lpf", "lpz", "spel", "spm", " spfr", " spl", "lph", "spev", "psv", "aspm", "spz", "psel", "lpfs", "ppfr", "aspv", "spfc", "Spf", "psef", "psefx", "spfs", "lpfr", "espf", "esph", " spm", "psf", "ppf", "espl", "espv", "Spv", "spefx", "psm", " spc", "lpfc", "spc", "bsph", "aspf", "lpc"], "c": ["tc", "sc", "rc", "t", "cm", "cp", "co", "p", "cu", "conf", "com", "cv", "config", "f", " C", "d", "l", "vc", "ec", "lc", "cont", "ctx", "r", "pc", "dc", "C", "cd", "con", "cb", "cl", "cc", "cur", "abc", "h", "gc", "cr", "fc", "anc", "b", "cmp", "cf", "enc", "ci", "m", "ca", "xc", "comments", "etc", "ce", "cs", "ct", "ac", "bc", "wcs", "kw", "cod", "cache", "mc"], "mp3": ["mp33", " mp5", " mpth", "emp33", "mptx", "emp3", "img3", " mp4", "MP1", "mp5", " mp03", "mx03", "amp3", "mp43", "mpeg3", "amp4", "mk3", "mpThree", "cmptx", "emp2", "cmpant", "pp2", "mt3", "cmp3", "MP23", "avlet", "mpeg5", " mpry", " mp2", "av4", "cmp33", "mpegth", "avThree", "img43", "MPthree", "pp7", "mp1", "avack", "MP03", "cmp2", "mpegack", "m2", "mk6", " mpdef", "MP6", "mp2", "m4", "mph3", "cp6", "cp3", "cmp5", "omp5", "mph03", "MP5", "cmp6", "mp03", "pp3", "omp3", " mpThree", "cmp03", "emp03", "ompthree", " mp1", "m03", "av3", "mk43", " mplet", "mxment", "MP3", "mpant", "imgdef", "mpry", "cmp4", "omp03", "amplet", "mkdef", "proc23", "proc3", "m5", "mplet", "cp7", "MPry", " mp43", "mry", "mpment", "mphment", "omp2", "mt2", "cmpment", " mp6", "mx3", "mpthree", "cp2", "av03", "proc03", "omp33", "mpth", "mp23", "omp1", "mp6", "pp6", "mp7", "mpeg2", "mpack", "mpdef", "mtx", "ampThree", "omp23", "mt03", "mxant", "mpeg03", " mptx", "avth", "mphant", "mt4", "mp4", " mpack", "img6", " mp7", "mpeg6", "procthree", "MP2", "m3"]}}
{"project": "qemu", "commit_id": "ad523590f62cf5d44e97388de370d27b95b25aff", "target": 0, "func": "void memory_region_iommu_replay_all(MemoryRegion *mr)\n\n{\n\n    IOMMUNotifier *notifier;\n\n\n\n    IOMMU_NOTIFIER_FOREACH(notifier, mr) {\n\n        memory_region_iommu_replay(mr, notifier, false);\n\n    }\n\n}\n", "idx": 4892, "substitutes": {"mr": ["dr", "hm", "gm", "cm", "rpm", "bm", "mk", "rer", "kr", "rm", "ms", "r", "lr", "rr", "mp", "ml", "rl", "drm", "ire", "br", "vr", "sr", "adr", "rg", "mt", "hr", "mx", "memory", "mn", "shr", "rs", "rar", "wm", "rn", "m", "tr", "mm", "Mr", "MR", "irm", "tm", "rt", "rb", "mc"], "notifier": ["notger", " notizer", " noter", "Notifer", "NOTer", "notizer", " notifiable", "neifier", "Notifier", " notger", "notifer", "Notify", "NOTizer", "noifier", "noify", "noizer", " notifer", " NOTifer", " NOTifier", "notify", "noifer", " notify", "NOTifiable", "NOTifer", "Notger", "NOTifier", "neify", "notifiable", "neger", " NOTifiable", "neifer", "noter", "NOTify", " NOTer"]}}
{"project": "qemu", "commit_id": "dc638fadb54c911019227ae37656560c49a209b9", "target": 0, "func": "static int usb_uhci_piix3_initfn(PCIDevice *dev)\n\n{\n\n    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);\n\n    uint8_t *pci_conf = s->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);\n\n    return usb_uhci_common_initfn(s);\n\n}\n", "idx": 4893, "substitutes": {"dev": ["conf", "p", "de", "ch", "conn", "priv", "debug", "d", "v", "att", "nt", "data", "spec", "Device", "Dev", "dd", "devices", "serv", "obj", "w", "pro", "av", "ve", "pad", "device", "adv", "sd", "mem", "proc", "def", "DEV", "ver", "info", "buf", "usb", "serial", "remote", "develop", "vo", "db", "cam", "raw", "test", "hw", "desc", "dis", "des", "block", "sys", "go", "ev", "out", "cmd", "dem"], "s": ["sc", "t", "S", "p", "conf", "syn", "ds", "south", "f", "a", "is", "v", "ps", "sync", "sl", "w", "ss", "self", "h", "comm", "bs", "i", "ns", "js", "b", "state", "sq", "sh", "ses", "sts", "rs", "su", "ts", "es", "m", "fs", "sis", "sv", "cs", "c", "ls", "n", "sys", "sol", "sa"], "pci_conf": ["pci_con", "pdi_conf", "pcierdict", "pdi_cfg", "pcierconf", "pci_req", "pdi_dict", "pci__conf", "pci_acc", "pci_dict", "pdi_acc", "pci__config", "pci__acc", "pci__cfg", "puci_req", "puci_cfg", "puci_config", "pciercon", "puci_conf", "pdi_config", "pci_cfg", "pdi_con", "pcierconfig", "pci_config"]}}
{"project": "FFmpeg", "commit_id": "842b6c14bcfc1c5da1a2d288fd65386eb8c158ad", "target": 0, "func": "static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)\n\n{\n\n    MpegTSWrite *ts = s->priv_data;\n\n    uint8_t data[1012], *q, *desc_length_ptr, *program_info_length_ptr;\n\n    int val, stream_type, i;\n\n\n\n    q = data;\n\n    put16(&q, 0xe000 | service->pcr_pid);\n\n\n\n    program_info_length_ptr = q;\n\n    q += 2; /* patched after */\n\n\n\n    /* put program info here */\n\n\n\n    val = 0xf000 | (q - program_info_length_ptr - 2);\n\n    program_info_length_ptr[0] = val >> 8;\n\n    program_info_length_ptr[1] = val;\n\n\n\n    for(i = 0; i < s->nb_streams; i++) {\n\n        AVStream *st = s->streams[i];\n\n        MpegTSWriteStream *ts_st = st->priv_data;\n\n        AVDictionaryEntry *lang = av_dict_get(st->metadata, \"language\", NULL,0);\n\n        switch(st->codec->codec_id) {\n\n        case AV_CODEC_ID_MPEG1VIDEO:\n\n        case AV_CODEC_ID_MPEG2VIDEO:\n\n            stream_type = STREAM_TYPE_VIDEO_MPEG2;\n\n            break;\n\n        case AV_CODEC_ID_MPEG4:\n\n            stream_type = STREAM_TYPE_VIDEO_MPEG4;\n\n            break;\n\n        case AV_CODEC_ID_H264:\n\n            stream_type = STREAM_TYPE_VIDEO_H264;\n\n            break;\n\n        case AV_CODEC_ID_CAVS:\n\n            stream_type = STREAM_TYPE_VIDEO_CAVS;\n\n            break;\n\n        case AV_CODEC_ID_DIRAC:\n\n            stream_type = STREAM_TYPE_VIDEO_DIRAC;\n\n            break;\n\n        case AV_CODEC_ID_MP2:\n\n        case AV_CODEC_ID_MP3:\n\n            stream_type = STREAM_TYPE_AUDIO_MPEG1;\n\n            break;\n\n        case AV_CODEC_ID_AAC:\n\n            stream_type = (ts->flags & MPEGTS_FLAG_AAC_LATM) ? STREAM_TYPE_AUDIO_AAC_LATM : STREAM_TYPE_AUDIO_AAC;\n\n            break;\n\n        case AV_CODEC_ID_AAC_LATM:\n\n            stream_type = STREAM_TYPE_AUDIO_AAC_LATM;\n\n            break;\n\n        case AV_CODEC_ID_AC3:\n\n            stream_type = STREAM_TYPE_AUDIO_AC3;\n\n            break;\n\n        default:\n\n            stream_type = STREAM_TYPE_PRIVATE_DATA;\n\n            break;\n\n        }\n\n        *q++ = stream_type;\n\n        put16(&q, 0xe000 | ts_st->pid);\n\n        desc_length_ptr = q;\n\n        q += 2; /* patched after */\n\n\n\n        /* write optional descriptors here */\n\n        switch(st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            if(st->codec->codec_id==AV_CODEC_ID_EAC3){\n\n                *q++=0x7a; // EAC3 descriptor see A038 DVB SI\n\n                *q++=1; // 1 byte, all flags sets to 0\n\n                *q++=0; // omit all fields...\n\n            }\n\n            if(st->codec->codec_id==AV_CODEC_ID_S302M){\n\n                *q++ = 0x05; /* MPEG-2 registration descriptor*/\n\n                *q++ = 4;\n\n                *q++ = 'B';\n\n                *q++ = 'S';\n\n                *q++ = 'S';\n\n                *q++ = 'D';\n\n            }\n\n\n\n            if (lang) {\n\n                char *p;\n\n                char *next = lang->value;\n\n                uint8_t *len_ptr;\n\n\n\n                *q++ = 0x0a; /* ISO 639 language descriptor */\n\n                len_ptr = q++;\n\n                *len_ptr = 0;\n\n\n\n                for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) {\n\n                    next = strchr(p, ',');\n\n                    if (strlen(p) != 3 && (!next || next != p + 3))\n\n                        continue; /* not a 3-letter code */\n\n\n\n                    *q++ = *p++;\n\n                    *q++ = *p++;\n\n                    *q++ = *p++;\n\n\n\n                if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS)\n\n                    *q++ = 0x01;\n\n                else if (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED)\n\n                    *q++ = 0x02;\n\n                else if (st->disposition & AV_DISPOSITION_VISUAL_IMPAIRED)\n\n                    *q++ = 0x03;\n\n                else\n\n                    *q++ = 0; /* undefined type */\n\n\n\n                    *len_ptr += 4;\n\n                }\n\n\n\n                if (*len_ptr == 0)\n\n                    q -= 2; /* no language codes were written */\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            {\n\n                const char default_language[] = \"und\";\n\n                const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language;\n\n\n\n                if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {\n\n                    uint8_t *len_ptr;\n\n                    int extradata_copied = 0;\n\n\n\n                    *q++ = 0x59; /* subtitling_descriptor */\n\n                    len_ptr = q++;\n\n\n\n                    while (strlen(language) >= 3 && (sizeof(data) - (q - data)) >= 8) { /* 8 bytes per DVB subtitle substream data */\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        /* Skip comma */\n\n                        if (*language != '\\0')\n\n                            language++;\n\n\n\n                        if (st->codec->extradata_size - extradata_copied >= 5) {\n\n                            *q++ = st->codec->extradata[extradata_copied + 4]; /* subtitling_type */\n\n                            memcpy(q, st->codec->extradata + extradata_copied, 4); /* composition_page_id and ancillary_page_id */\n\n                            extradata_copied += 5;\n\n                            q += 4;\n\n                        } else {\n\n                            /* subtitling_type:\n\n                             * 0x10 - normal with no monitor aspect ratio criticality\n\n                             * 0x20 - for the hard of hearing with no monitor aspect ratio criticality */\n\n                            *q++ = (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10;\n\n                            if ((st->codec->extradata_size == 4) && (extradata_copied == 0)) {\n\n                                /* support of old 4-byte extradata format */\n\n                                memcpy(q, st->codec->extradata, 4); /* composition_page_id and ancillary_page_id */\n\n                                extradata_copied += 4;\n\n                                q += 4;\n\n                            } else {\n\n                                put16(&q, 1); /* composition_page_id */\n\n                                put16(&q, 1); /* ancillary_page_id */\n\n                            }\n\n                        }\n\n                    }\n\n\n\n                    *len_ptr = q - len_ptr - 1;\n\n                } else if (st->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) {\n\n                    uint8_t *len_ptr = NULL;\n\n                    int extradata_copied = 0;\n\n\n\n                    /* The descriptor tag. teletext_descriptor */\n\n                    *q++ = 0x56;\n\n                    len_ptr = q++;\n\n\n\n                    while (strlen(language) >= 3) {\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        /* Skip comma */\n\n                        if (*language != '\\0')\n\n                            language++;\n\n\n\n                        if (st->codec->extradata_size - 1 > extradata_copied) {\n\n                            memcpy(q, st->codec->extradata + extradata_copied, 2);\n\n                            extradata_copied += 2;\n\n                            q += 2;\n\n                        } else {\n\n                            /* The Teletext descriptor:\n\n                             * teletext_type: This 5-bit field indicates the type of Teletext page indicated. (0x01 Initial Teletext page)\n\n                             * teletext_magazine_number: This is a 3-bit field which identifies the magazine number.\n\n                             * teletext_page_number: This is an 8-bit field giving two 4-bit hex digits identifying the page number. */\n\n                            *q++ = 0x08;\n\n                            *q++ = 0x00;\n\n                        }\n\n                    }\n\n\n\n                    *len_ptr = q - len_ptr - 1;\n\n                 }\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (stream_type == STREAM_TYPE_VIDEO_DIRAC) {\n\n                *q++ = 0x05; /*MPEG-2 registration descriptor*/\n\n                *q++ = 4;\n\n                *q++ = 'd';\n\n                *q++ = 'r';\n\n                *q++ = 'a';\n\n                *q++ = 'c';\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_DATA:\n\n            if (st->codec->codec_id == AV_CODEC_ID_SMPTE_KLV) {\n\n                *q++ = 0x05; /* MPEG-2 registration descriptor */\n\n                *q++ = 4;\n\n                *q++ = 'K';\n\n                *q++ = 'L';\n\n                *q++ = 'V';\n\n                *q++ = 'A';\n\n            }\n\n            break;\n\n        }\n\n\n\n        val = 0xf000 | (q - desc_length_ptr - 2);\n\n        desc_length_ptr[0] = val >> 8;\n\n        desc_length_ptr[1] = val;\n\n    }\n\n    mpegts_write_section1(&service->pmt, PMT_TID, service->sid, ts->tables_version, 0, 0,\n\n                          data, q - data);\n\n}\n", "idx": 4896, "substitutes": {"s": ["t", "os", "S", "sports", "conf", "ds", "ms", "v", "ps", "spec", "ins", "serv", "sl", "less", "ss", "aws", "comm", "in", "ns", "js", "hs", "source", "b", "sq", "g", "sts", "rs", "gs", "ops", "stats", "m", "fs", "sv", "cs", "ims", "c", "ls", "series", "n", "ats", "sys", "se", "services"], "service": ["Service", "t", "task", "is", "handler", "vc", "v", "sp", "ctx", "file", "serv", "address", "server", "set", "spe", "source", "js", "state", "info", "ice", "support", "store", "y", "command", "status", "process", "m", "storage", "sv", "session", "c", "sky", "library", "start", "context", "se", "event", "services"], "ts": ["tc", "t", "uts", "Ts", "td", "ds", "tt", "ms", "nt", "ps", "vs", "ics", "ss", "tes", "pt", "wt", "bs", "ns", "js", "TS", "mt", "hs", "sts", "rs", "ops", "stats", "its", "cs", "ta", "tx", "als", "terms", "ls", "aps", "ats", "tn"], "data": ["key", "t", "a", "d", "v", "arr", "length", "xff", "DATA", " Data", "w", "str", "Data", "bytes", "def", "name", "buf", "zero", "buffer", "ata", "len", "code", " DATA", "vals", "values", "window", "final", "x", "block", "n", "ATA", "value", "stream"], "q": ["pp", "query", "t", "qual", "ch", "pkg", "quality", "qq", "cv", "f", "d", "l", "v", "length", "it", "quant", "Q", "qv", "w", "req", "dq", "ue", "k", "qu", "j", "pt", "iq", "quote", "eq", "b", "sq", "g", "buf", "m", "aq", "quit", "qa", "x", "qi", "seq", "qt", "c", "queue", "qs", "z", "u"], "desc_length_ptr": ["desc_size_ptr", "desc_length_len", "desc_size_length", "desc_length_tr", "desc_length_length", "desc_size_len", "desc_size_tr"], "program_info_length_ptr": ["program_info_length_addr", "program_info_length_offset", "program_info_length_req", "program_info_Length_req", "program_info_length2pointers", "program_info_len_req", "program_info_len_ptr", "program_info_length2req", "program_info_len_tr", "program_info_len_addr", "program_info_len_desc", "program_info_length_obj", "program_info_length2ptr", "program_info_Length_length", "program_info_length2addr", "program_info_len_obj", "program_info_length_pointers", "program_info_Length_addr", "program_info_Length_pointers", "program_info_length_desc", "program_info_length_length", "program_info_Length_ptr", "program_info_len_length", "program_info_len_offset", "program_info_length_tr"], "val": [" el", "VAL", "t", "elt", " delta", "ch", "max", "alpha", "eval", "sel", " eval", "l", "v", "ctx", "it", "z", "valid", "u", "pt", "pal", "ret", "bal", "mem", " aval", "b", " value", "buf", " v", "pr", "ref", "len", " valid", "res", "vals", "ival", "bit", " len", "Value", "au", "AL", "x", "num", "tx", "seq", "lev", "vol", " al", " interval", "al", "vt", "value", "Val", "aval"], "stream_type": ["streamlcategory", "streamertemplate", "streamingid", "streamingpolicy", "sample_id", "streamablename", "stream_id", "streamingtype", "track_style", " stream_category", "sample_name", "streamingmodule", "streamityinfo", "streamlTYPE", "streamlycategory", "sampleityname", "streamablecategory", "stream_category", "wrappererpolicy", "streamerstyle", "streamityTYPE", " stream_ty", "ream_status", "stream_name", "stream_info", "streamlistTYPE", "streamingstyle", "streamlistcategory", "streamityname", " stream_TYPE", "stream_ty", "stream_owner", "streamertype", "streamitytype", "sample_info", "streamityspec", "sampleityinfo", "stream_ype", "wrapperertype", "stream_TYPE", "stream_template", "trackitynumber", "streamlnumber", "streamlisttype", "iteratoringtype", "streamablemodule", "stream_style", "streamlytype", "stream_spec", "streamltype", "streamableowner", " stream_name", " stream_owner", "streamerpolicy", "ream_TYPE", "stream_number", "trackitytype", "ream_spec", "wrapper_style", "streamlyname", "iterator_category", "sampleityid", "streamabletype", "wrappererstyle", "sampleitytype", "ream_type", "streamingtemplate", "streamingcategory", "streamlstyle", "streamitystyle", "iterator_module", "iteratoringmodule", "iterator_id", "wrapper_template", "streamitynumber", "stream_module", "track_number", "streamityid", "wrapper_policy", "streamlype", "wrapperertemplate", "streamableid", "iteratoringcategory", "stream_status", "iterator_type", "trackitystyle", "streamitystatus", "streamlyowner", "stream_policy", "wrapper_type", "iteratoringid", "track_type", " stream_ype", "sample_type", "streamlistype"], "i": ["t", "li", "ei", "sim", "ki", "bi", "id", "ind", "v", "l", "ini", "ii", "mi", "ix", "me", "it", "ic", "\u0438", "hi", "si", "k", "oi", "j", "di", "gi", "ri", "in", "ji", "ip", "b", "index", "info", "g", "ui", "multi", "iu", "xi", "y", "ij", "zi", "e", "ci", "ti", "m", "ai", "pi", "x", "I", "phi", "qi", "c", "cli", "u", "batch"], "st": ["ST", "stage", "sc", "t", "irst", "th", "td", "tt", "bt", "v", "sp", "nt", "it", "ost", "sta", "sm", "stable", "sl", "str", "set", "ss", "ist", "pt", "so", "ste", "stop", "est", "sh", "std", "sts", "step", "rest", "sn", "tr", "sv", "stream", "ct", "nd", "St", "src", "start", "rt", "se", "sw", "station"], "ts_st": ["js_ste", "js__ST", "ts__ST", "ts__st", "js__sc", "ts_sc", "ts_ste", "ts__sc", "js_st", "js__st", "js_ST", "js__ste", "ts__ste", "js_sc", "ts_ST"], "lang": ["ng", "ind", "l", "ang", "lc", "ec", "obj", "loc", "sl", "trans", "translation", "kl", "lvl", "def", "bl", "kb", "keys", "enc", "angs", "line", "mo", "desc", "meta", "cod", "nl", "pos", "hl", "lib"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_addi_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tDIS(fprintf (logfile, \"addi.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));\n\n\tcris_cc_mask(dc, 0);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\ttcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));\n\n\ttcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 4899, "substitutes": {"dc": ["tc", "df", "dr", "rc", "sc", "cm", "doc", "cu", "de", "dt", "dm", "ds", "d", "vc", "dim", "cat", "draw", "lc", "cont", "cca", "ec", "pc", "dd", "cd", "loc", "ga", "cc", "di", "dl", "dat", "fc", " mc", "design", "def", "currency", "dir", "fee", "inc", "da", "du", "dp", "db", "coord", "ca", "mm", "disc", "DC", "cs", "ac", "desc", "bc", "c", "wcs", "kw", "oc", "sys", "ctl", "nc", "mc"], "t0": ["tempfrom", "p0", " tear", "p1", "T180", " t180", "t180", " t1", "tn1", "cZero", "p3", "tc1", "tnarg", " targ", "c0", "T1", "tn0", "T2", " tZero", "tc2", " t3", "temp1", " t2", "c180", "targ", "Targ", "Tear", "t2", "tZero", "Tfrom", "t1", "tear", "tfrom", " tfrom", "TZero", "c1", "tc0", "tcear", "p2", "temp0", "T0", "t3", "T3"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_trap (DisasContext *ctx, uint32_t opc,\n\n                      int rs, int rt, int16_t imm)\n\n{\n\n    int cond;\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv t1 = tcg_temp_new();\n\n\n\n    cond = 0;\n\n    /* Load needed operands */\n\n    switch (opc) {\n\n    case OPC_TEQ:\n\n    case OPC_TGE:\n\n    case OPC_TGEU:\n\n    case OPC_TLT:\n\n    case OPC_TLTU:\n\n    case OPC_TNE:\n\n        /* Compare two registers */\n\n        if (rs != rt) {\n\n            gen_load_gpr(t0, rs);\n\n            gen_load_gpr(t1, rt);\n\n            cond = 1;\n\n        }\n\n        break;\n\n    case OPC_TEQI:\n\n    case OPC_TGEI:\n\n    case OPC_TGEIU:\n\n    case OPC_TLTI:\n\n    case OPC_TLTIU:\n\n    case OPC_TNEI:\n\n        /* Compare register to immediate */\n\n        if (rs != 0 || imm != 0) {\n\n            gen_load_gpr(t0, rs);\n\n            tcg_gen_movi_tl(t1, (int32_t)imm);\n\n            cond = 1;\n\n        }\n\n        break;\n\n    }\n\n    if (cond == 0) {\n\n        switch (opc) {\n\n        case OPC_TEQ:   /* rs == rs */\n\n        case OPC_TEQI:  /* r0 == 0  */\n\n        case OPC_TGE:   /* rs >= rs */\n\n        case OPC_TGEI:  /* r0 >= 0  */\n\n        case OPC_TGEU:  /* rs >= rs unsigned */\n\n        case OPC_TGEIU: /* r0 >= 0  unsigned */\n\n            /* Always trap */\n\n            generate_exception(ctx, EXCP_TRAP);\n\n            break;\n\n        case OPC_TLT:   /* rs < rs           */\n\n        case OPC_TLTI:  /* r0 < 0            */\n\n        case OPC_TLTU:  /* rs < rs unsigned  */\n\n        case OPC_TLTIU: /* r0 < 0  unsigned  */\n\n        case OPC_TNE:   /* rs != rs          */\n\n        case OPC_TNEI:  /* r0 != 0           */\n\n            /* Never trap: treat as NOP. */\n\n            break;\n\n        }\n\n    } else {\n\n        int l1 = gen_new_label();\n\n\n\n        switch (opc) {\n\n        case OPC_TEQ:\n\n        case OPC_TEQI:\n\n            tcg_gen_brcond_tl(TCG_COND_NE, t0, t1, l1);\n\n            break;\n\n        case OPC_TGE:\n\n        case OPC_TGEI:\n\n            tcg_gen_brcond_tl(TCG_COND_LT, t0, t1, l1);\n\n            break;\n\n        case OPC_TGEU:\n\n        case OPC_TGEIU:\n\n            tcg_gen_brcond_tl(TCG_COND_LTU, t0, t1, l1);\n\n            break;\n\n        case OPC_TLT:\n\n        case OPC_TLTI:\n\n            tcg_gen_brcond_tl(TCG_COND_GE, t0, t1, l1);\n\n            break;\n\n        case OPC_TLTU:\n\n        case OPC_TLTIU:\n\n            tcg_gen_brcond_tl(TCG_COND_GEU, t0, t1, l1);\n\n            break;\n\n        case OPC_TNE:\n\n        case OPC_TNEI:\n\n            tcg_gen_brcond_tl(TCG_COND_EQ, t0, t1, l1);\n\n            break;\n\n        }\n\n        generate_exception(ctx, EXCP_TRAP);\n\n        gen_set_label(l1);\n\n    }\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 4924, "substitutes": {"ctx": ["tc", "sc", "cm", "cp", "conf", " cx", "pkg", "cv", "cci", "conn", "ctr", "wx", "obj", "cc", "setup", "KC", "fc", " context", "act", "cmp", "jp", "ck", "ci", "cfg", "cf", "xc", "ca", "iat", "hw", "ct", "tm", "tx", "c", "cmd", "Context", "kw", "cas", "context", "nc", "mc"], "opc": [" copct", "opcc", "Opci", "opcr", " opci", "operc", "iopc", "Opc", "optcu", "iopcn", " opC", "opcp", "optcount", "opci", "Opcp", "iopct", "hopcp", "Opcu", "hopcr", "optci", "hopc", " ipct", "ropcp", "opct", "optc", "opcount", "opcu", "ropcount", "hopci", "ropc", " opct", "hopcount", "opercn", " ipci", "opC", "opcn", "optcr", "oppcc", "operct", " copC", "iopcc", " copci", "opercc", "oppcn", "optcp", "oppct", "hopcu", "oppc", " ipC", "ropcr", " copc", " ipc"], "rs": ["acks", "ptr", "rc", "arts", "ems", "rpm", "ds", "acts", "times", "ras", "ms", "rm", "r", "ps", "RS", "ins", "re", "rss", "rr", "vs", "rl", "ks", "amps", "fps", "rings", "rows", "ris", "mods", "ns", "mt", "rx", "rates", "sys", "ires", "ars", "ts", "repl", "pps", "xs", "res", "rd", "fs", "Rs", "rans", "cs", "ims", "as", "ls", "s", "rob", "ats", "aps", "reg", "mr"], "rt": ["ptr", "rc", "t", "fr", "gt", "rpm", "tmp", "tt", "rm", " addr", "rw", "rot", "nt", "r", "rr", "rl", "RT", "vr", "rid", "wt", "pt", "attr", "rows", "TX", "rb", "mt", "lt", "rx", "act", " mt", "rf", "rat", "RM", "rn", "iter", "xs", "rect", "res", "rd", "irt", "addr", "mitt", "irm", "x", "tm", "rin", "grad", " ret", "reg", "mr"], "imm": ["orm", "gm", " imp", "lim", "emp", "sim", "rpm", "bm", "fm", "rm", "dim", "att", "mi", "rr", "em", "sm", "mun", "lamm", "susp", "pm", "utm", "esm", "mat", "attr", "imp", "asm", "mt", "vm", "um", "perm", "cmp", "m", "mm", "amm", "reg", "mitt", "im", "ims", "irm", "snap", "tm", " im", "Imm", "alt", "mut"], "cond": ["fail", "conf", "compl", "bound", " count", "form", "sec", "success", "ind", "circ", " Cond", "pred", "cont", "thread", "not", "condition", " ind", "fd", "dd", "post", "check", "call", "con", "day", "red", "respond", "cert", "cc", "fun", "crit", "ld", "req", "hold", "lock", " conditional", "reason", "chain", " cont", "resp", "state", "def", "ond", "comp", "connect", " condition", "close", "cmp", "cf", "ci", "Cond", "bool", "ct", "rupt", "count", "mod", "bc", "pos", "pre", "cmd", " con"]}}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset,\n\n                                 unsigned size)\n\n{\n\n    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;\n\n    uint32_t ret;\n\n    int bank;\n\n    if (offset >= 0x200)\n\n        return 0;\n\n\n\n    bank = pxa2xx_gpio_regs[offset].bank;\n\n    switch (pxa2xx_gpio_regs[offset].reg) {\n\n    case GPDR:\t\t/* GPIO Pin-Direction registers */\n\n        return s->dir[bank];\n\n\n\n    case GPSR:\t\t/* GPIO Pin-Output Set registers */\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pxa2xx GPIO: read from write only register GPSR\\n\");\n\n        return 0;\n\n\n\n    case GPCR:\t\t/* GPIO Pin-Output Clear registers */\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pxa2xx GPIO: read from write only register GPCR\\n\");\n\n        return 0;\n\n\n\n    case GRER:\t\t/* GPIO Rising-Edge Detect Enable registers */\n\n        return s->rising[bank];\n\n\n\n    case GFER:\t\t/* GPIO Falling-Edge Detect Enable registers */\n\n        return s->falling[bank];\n\n\n\n    case GAFR_L:\t/* GPIO Alternate Function registers */\n\n        return s->gafr[bank * 2];\n\n\n\n    case GAFR_U:\t/* GPIO Alternate Function registers */\n\n        return s->gafr[bank * 2 + 1];\n\n\n\n    case GPLR:\t\t/* GPIO Pin-Level registers */\n\n        ret = (s->olevel[bank] & s->dir[bank]) |\n\n                (s->ilevel[bank] & ~s->dir[bank]);\n\n        qemu_irq_raise(s->read_notify);\n\n        return ret;\n\n\n\n    case GEDR:\t\t/* GPIO Edge Detect Status registers */\n\n        return s->status[bank];\n\n\n\n    default:\n\n        hw_error(\"%s: Bad offset \" REG_FMT \"\\n\", __FUNCTION__, offset);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4961, "substitutes": {"opaque": ["oplosition", "Opatile", "opaques", "OPaque", "OPatile", " oposition", "opois", "Opaque", " opois", " opaques", "oplay", "omposition", "ompois", "oplaque", "oplois", "Oplay", "opatile", " opatile", "ompaque", "oposition", "Opaques", " oplay", "OPlay", "OPaques"], "offset": ["key", "et", "kh", "id", "path", "file", "error", "offer", "frequency", "alias", "slot", "slice", "scroll", "range", "area", "now", "offs", "ta", "count", "encrypted", "start", "origin", "sp", "data", "r", "OFF", "mt", "pointer", "index", "name", "usage", "timeout", "ref", "buffer", "len", "code", "flag", "batch", "entry", "bound", "reset", "f", "padding", "address", "port", "pad", "location", "off", "point", "shift", "type", "end", "e", "t", "length", "position", "prefix", "set", "ff", "o", "attribute", "buf", "inet", "job", "addr", "window", "Offset", "client", "from", "oid", "pos", "err", "seek", "template"], "size": ["Size", "data", "length", "SIZE", "ize", "send", "set", "read", "body", "format", "mem", "name", "shift", "buf", "type", "buffer", "len", "area", "code", "e", "window", "count", "c", "message", "start", "n", "z"], "s": ["ubs", "p", "ations", "gets", "ees", "ains", "ns", "ores", "sq", "ses", "gs", "sn", "stats", "its", "ims", "ches", "ants", "itions", "c", "des", "settings", "aps", "qs", "ing", "izes", "S", "ums", "a", "r", "ps", "ins", "w", "less", "ss", "h", "ves", "changes", "i", "js", "mods", "b", "sts", "ts", "fs", "sis", "sb", "als", "ands", "ats", "sys", "ers", "states", "ions", "is", "d", "ments", "ords", "sam", "ports", "aws", "bs", "ries", "rs", "ed", "bis", "orders", "ances", "as", "ls", "resses", "t", "os", "ists", "ds", "ms", "ests", "v", "ies", "eds", "outs", "comm", "ings", "hs", "rates", "erences", "g", "ities", "es", "sv", "parts", "alls", "sw"], "ret": ["t", "elt", "reset", "gt", "ll", "f", "RET", "rm", "v", "arg", "nt", "re", "Ret", "ft", "Return", "rets", "ral", "txt", "red", "pas", "val", "set", "rem", "read", "gc", "mem", "result", "lt", "resp", "def", "pret", "g", "new", "status", "jp", "print", "res", "det", "tr", "ert", "flag", "uf", "final", "back", "alt", "rt", "value", "out"], "bank": ["bn", "family", "volume", "bid", "scan", "file", "field", "k", "alias", "parser", "root", "ver", "db", "model", "bridge", "ANK", "bo", " banks", "dev", "leaf", "bm", "ban", "token", " Bank", "rule", "anch", "kind", "device", "b", "comment", "pb", "gem", "buffer", "bang", "ay", "browser", "iban", "sb", "brand", "block", "binding", "bird", "shop", "Bank", "order", "card", "board", "brain", "lang", "port", "bus", "chain", "group", "tree", "type", "black", "farm", "pool", "rank", "bg", "table", "agency", "book", "jack", "library", "go", "bag", " branch", " banking", "plant", "ank", "disk", "ame", "country", "prefix", "account", "stay", "node", "cell", "bb", "tag", "banks", "service", "base", "bin", "rb", "cash", "batch"]}}
{"project": "FFmpeg", "commit_id": "8eb76217d0137b7adad438f6c923310fbc1fc4c1", "target": 1, "func": "static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)\n{\n    int y;\n    unsigned char P[2];\n    /* 4-color block encoding: each 4x4 block is a different color */\n    for (y = 0; y < 8; y++) {\n        if (!(y & 3)) {\n            P[0] = bytestream2_get_byte(&s->stream_ptr);\n            P[1] = bytestream2_get_byte(&s->stream_ptr);\n        memset(s->pixel_ptr,     P[0], 4);\n        memset(s->pixel_ptr + 4, P[1], 4);\n        s->pixel_ptr += s->stride;\n    /* report success */\n    return 0;", "idx": 4995, "substitutes": {"s": ["p", "conf", "save", "https", "l", "q", "self", "ains", "ns", "sq", "gs", "stats", "ims", "c", "settings", "n", "qs", "z", "query", "S", "a", "resource", "sp", "vs", "ps", "w", "less", "ss", "h", "i", "js", "b", "http", "sts", "ts", "this", "fs", "session", "sb", "sys", "webkit", "details", "is", "f", "d", "aws", "space", "asm", "state", "rs", "e", "m", "cs", "ls", "t", "os", "ess", "ds", "ms", "v", "spec", "set", "comm", "an", "g", "status", "es", "res", "sv", "se", "sw"], "frame": [" response", " sample", " screen", " image", "iframe", " frames", "f", " video", "image", "frames", " sequence", " pixel", " chunk", "Frame", " input", " block", " command", "movie", " window", " Frame", " message", " event", "block", " f", " t", " fram", " stream", "rame"], "y": ["py", "key", "t", "yi", "p", "sim", "dy", "ley", "ty", "ym", "col", " yo", " Ny", " ya", "ies", " my", "hey", " ly", "my", "ady", "any", " busy", " ye", "j", "ys", "wy", " py", "gy", "i", "ye", " dy", "ey", "Y", "sy", " Y", "scroll", "axy", "yet", "ny", "ly", "xy", "ay", "cy", "height", " i", "aily", "iy", "oy", " j", "ya", "yr", "yu", "x", "yl", "yt", "c", " ty", " Yi", "sky", " try", "hot", "yy", "uy", "icy"], "P": ["PO", "p", "S", "Message", "K", "X", "T", "PM", "LP", "PUT", "H", "R", "FP", "Q", "New", "C", "CP", "BP", "YP", "Type", "PD", "PA", "Path", "DP", "CA", "Other", "Progress", "This", "IP", "Array", "A", "Y", "Compare", "State", "F", "M", "PK", "MP", "G", "PI", "PT", "TP", "NP", "PE", "Pay", "PP", "GP", "AMP", "N", "L", "Part", "J", "AP", "JP", "Query", "PR", "PIN", "Ps", "Pad", "V", "SP", "PS", "Patch"]}}
{"project": "qemu", "commit_id": "1964a397063967acc5ce71a2a24ed26e74824ee1", "target": 0, "func": "static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)\n\n{\n\n    MigrationState *s = opaque;\n\n    if (qemu_file_get_error(s->file)) {\n\n        goto out;\n\n    }\n\n\n\n    s->xfer_limit = new_rate;\n\n\n\nout:\n\n    return s->xfer_limit;\n\n}\n", "idx": 5035, "substitutes": {"opaque": ["ipacity", "ipaque", "OPush", "iopaque", "opush", "OPaque", "OPatile", "opaques", " Oposit", "oplush", " Opush", "popatile", " Opatile", "iopaques", "popaque", "oplaque", "oplatile", "iopacity", "opatile", "oposit", "ipatile", "ipaques", "popacity", "popaques", " Opaque", "opacity", "OPosit", "oplosit", "iopatile"], "new_rate": [" new_rat", " new_rates", " new_width", " new_currency", "new_currency", " new_Rate", "newPrat", "newvalcurrency", "newlyrate", "newlyrat", "newPrates", "newPwidth", " new_fee", "newlywidth", "newvalRate", "new_fee", "newPrate", "newvalrate", "new_rat", "new_rates", "newlyrates", "new_Rate", "new_width", "newvalfee"], "s": ["states", "t", "p", "S", "ess", "ds", "is", "a", "ares", "r", "ps", "ins", "ies", "serv", "eds", "sl", "less", "ss", "j", "h", "o", "outs", "changes", "bs", "ns", "js", "hs", "ssl", "b", "sq", "rates", "sys", "g", "ses", "sts", "pers", "rs", "gs", "Ws", "ts", "stats", "m", "its", "sis", "sv", "cs", "session", "ches", "sb", "als", "c", "parts", "ls", "ats", "n", "qs", "sol", "se", "services"]}}
{"project": "FFmpeg", "commit_id": "aefdb735c3df9480c1ca9bcf4a3835bd66271bd1", "target": 0, "func": "static void reverse_matrixing(float *su1, float *su2, int *prev_code,\n\n                              int *curr_code)\n\n{\n\n    int i, nsample, band;\n\n    float mc1_l, mc1_r, mc2_l, mc2_r;\n\n\n\n    for (i = 0, band = 0; band < 4 * 256; band += 256, i++) {\n\n        int s1 = prev_code[i];\n\n        int s2 = curr_code[i];\n\n        nsample = 0;\n\n\n\n        if (s1 != s2) {\n\n            /* Selector value changed, interpolation needed. */\n\n            mc1_l = matrix_coeffs[s1 * 2    ];\n\n            mc1_r = matrix_coeffs[s1 * 2 + 1];\n\n            mc2_l = matrix_coeffs[s2 * 2    ];\n\n            mc2_r = matrix_coeffs[s2 * 2 + 1];\n\n\n\n            /* Interpolation is done over the first eight samples. */\n\n            for (; nsample < 8; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) +\n\n                     c2 * INTERPOLATE(mc1_r, mc2_r, nsample);\n\n                su1[band + nsample] = c2;\n\n                su2[band + nsample] = c1 * 2.0 - c2;\n\n            }\n\n        }\n\n\n\n        /* Apply the matrix without interpolation. */\n\n        switch (s2) {\n\n        case 0:     /* M/S decoding */\n\n            for (; nsample < 256; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                su1[band + nsample] =  c2       * 2.0;\n\n                su2[band + nsample] = (c1 - c2) * 2.0;\n\n            }\n\n            break;\n\n        case 1:\n\n            for (; nsample < 256; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                su1[band + nsample] = (c1 + c2) *  2.0;\n\n                su2[band + nsample] =  c2       * -2.0;\n\n            }\n\n            break;\n\n        case 2:\n\n        case 3:\n\n            for (; nsample < 256; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                su1[band + nsample] = c1 + c2;\n\n                su2[band + nsample] = c1 - c2;\n\n            }\n\n            break;\n\n        default:\n\n            assert(0);\n\n        }\n\n    }\n\n}\n", "idx": 5044, "substitutes": {"su1": ["des1", "uu1", "san101", "uu64", "ru64", "u1", "sudo2", " su001", "pu71", "sudo001", "sn2", "su9", "SU101", "su30", "SU2", "san2", "bu2", "uu2", "SUOne", "sn001", "u2", "uu71", "sn1", "des2", "su64", "u101", "def", "pu3", "du2", "ru1", "SU0", "ru71", "Su0", "tu0", "bu001", "tu1", "du1", "su3", "SU64", "des9", "san71", "func", "suOne", "Su71", "bu1", "pu0", "tu9", "su001", "tu001", "duOne", "su71", "sn30", "ru2", "tu2", "_", " su0", "ru9", "su0", "su101", "Su3", "du0", "tu30", "SU1", " su71", "san1", "u71", "des0", "SU71", " su3", "bu30", " suOne", "sudo1", "Su1", "pu1", "ru0"], "su2": [" su0", "ru02", "desTwo", "des02", "su0", "so0", "sutwo", "sn1", "tu02", "su22", "so1", " sutwo", "des2", "Su3", "du0", "Su22", "cu02", "du02", "su02", " su4", " su02", "tu9", "rutwo", "duTwo", " suTwo", "uu0", "suTwo", "uu9", "tu5", "so22", " su22", "sn2", "su9", " su3", "cu3", "du9", "du2", "du5", "uu5", "ru1", "ru2", "dutwo", "so2", "sntwo", "tuTwo", "Su4", "tu4", "Su0", "uuTwo", "Sutwo", "tu0", "tu2", "su4", "cuTwo", "su5", "Su2", "tu1", "du1", "tutwo", "Su1", "cu2", "uu2", "su3", "des3", "sn3"], "prev_code": ["pre_data", "Previous___code", "prev_cell", "Previous___case", "pre_code", "prev___cell", "Previous_buffer", "prevliccode", "prevlicbuffer", "prev___buffer", "prev___case", "Previous___buffer", "prevliccell", "prevencecase", "prevliccase", "pre_codes", "Previous_code", "pre_image", "prevencebuffer", "Previous_cell", "prevencecell", "prev_buffer", "Previous_case", "prev_data", "prev_case", "prevencecode", "prev___code", "Previous___cell", "prev_image", "prev_codes"], "curr_code": ["currCcodes", "currb_error", "curr_codes", "currCcode", "currb_ode", "currCode", "currb_Code", "currb_codes", "curr_ode", "currb_code", "curr_Code", "curr_error", "currCCode"], "i": ["t", "p", "inter", "art", "bi", "is", "id", "l", "ii", "v", "ini", "ind", "r", "mi", "ix", " bi", "me", "it", "ic", "\u0438", "mount", "j", "di", "o", "gi", "io", "ri", "chain", "ip", "b", "index", "point", "slice", "multi", "ij", "y", "xi", "ci", "ti", "m", "sym", "ai", "pi", " j", "im", "window", "x", "I", "phi", "client", "s", "n", "go", " ii", "batch"], "nsample": ["namesamine", "keysample", "unssample", "ensample", "atsam", "nspling", "keyssample", "ncale", "atsamp", "connam", "nample", "atsimer", "stssample", "NSample", "nscale", "nsoom", "namesamp", "inssample", "csample", "mnam", "nisamine", "nam", "ansample", "namesumo", "nmem", "xsemon", "nsrace", "atsample", "ansenge", "connickle", " nsrace", "namesshot", "nissample", "ssample", " nssample", " nsam", "csimer", "stscale", "onsirm", "atspling", "bssample", "nsemark", "ainsim", "conspling", "xsoom", "nsim", "onssample", "insamp", "nasimble", "consample", "nasample", "ansshot", "mnaple", "nisimble", "bsamp", "nassample", "namesmem", "keyscale", "xsamp", "unsumo", "namesam", "ainsample", "msmem", "msample", "namesrace", "xsirm", "nisample", "nsimble", "nossample", "ansimer", "xsickle", "anscale", "onsgrade", "nsmem", "netscale", "NSwarm", "nsimer", "atschange", "nameschange", "onsimble", "mnample", "nasimer", "nssample", "cssample", "enspace", "anssample", "NSamp", "namesenge", "mnemon", "nosample", "mnumo", "nasshot", "conngrade", "xspling", "onsamp", "msam", "namesickle", "consamp", "unsample", "mssample", "mnoom", "nsshot", "nspace", "noscale", "xsaple", "onsam", "nickle", "stsshot", "atswarm", "sam", "onsemon", "enssample", "atsickle", "connample", "nosamp", "NScale", "NSsample", "onsshot", "atscale", "insimer", "nsenge", "space", "onspling", "mnsample", "onsimer", "insgrade", "namesim", "sample", "onsemark", "NSam", " nscale", "stsample", " nswarm", "nsickle", "namessample", "xsample", "connsample", "namespace", "mnchange", "namesimer", "namescale", "NSrace", "sshot", "nasemark", "onsample", "nsgrade", "bsam", "bsample", "insample", "nsumo", "conssample", "nsemon", "atssample", "nsirm", "ensam", "namesample", "conncale", "mnimer", "csamine", "NSoom", "nsaple", "insam", "atsim", "NSaple", "ainssample", "netssample", "xssample", "nschange", "nisimer", "nswarm", "netsample", "scale", "mnirm", "nsamp", "namespling", "nisemark", "ainsam", "netsshot", "keysenge", "nsamine", "nsam", "unsimer"], "band": ["stage", "key", "light", "art", "bid", "filter", "field", "day", "dB", "plot", "statement", "frequency", "handle", "layer", "burst", "slice", "range", "display", "boot", "bridge", "gain", "broad", "bo", "work", "binary", "handler", "period", "iband", "hub", "dd", "j", "kind", "power", "st", "device", "brid", "word", "b", "index", "bind", "part", "brand", "block", "man", "nb", "tab", "load", "bound", "Band", "weight", " Band", "plugin", "d", "ind", "board", "component", "bard", "port", "bright", "io", "chain", "group", "plug", "lag", "plane", "command", "stand", "jack", "library", "function", "disk", "border", "channel", "style", "amber", "tag", "bit", "job", "window", "bin", "back", "stream", "batch"], "mc1_l": ["mcOne__c", "mcOne_c", "mc12l", "mc1__lin", "mc1pyl", "mc1_le", "mc1pyll", "mc1_ll", "mc101mml", "mc1_1", "mcOne_li", "mc1mmc", "mc1mm1", "mcOne_ll", "mc1_c", "mc1_lin", "mc101_c", "mcOne__ll", "mc101_l", "mcOne__lin", "mc101mm1", "mc101_kl", "mc12lin", "mc1mml", "mcOne__l", "mcOne_l", "mc1__c", "mc1pyc", "mc1_li", "mc101mmkl", "mc101mmc", "mcOne_lin", "mc101_1", "mc1pylin", "mc1mmkl", "mc12ll", "mcOne_le", "mc1_kl", "mcOne_r", "mc1__l", "mc12c", "mc1__ll"], "mc1_r": ["mcOne_p", "mc1_er", "mc51_rr", "mc1__b", "mc51_r", "mcOne_b", "mc1__p", "mcOne__b", "mc1__r", "mcOne__p", "mc1_or", "mc1__n", "mc1__or", "mc1_p", "mc1_right", "mc1mmright", "mc1_rr", "mc1mmrr", "mcOne_or", "mcOne_l", "mc1_n", "mcOne__r", "mc1__er", "mc1mmr", "mcOne__or", "mcOne_er", "mc51_right", "mcOne_r", "mc51_er", "mcOne_n", "mc1__l", "mc1mmer", "mc1_b"], "mc2_l": ["mc96_e", "mc2_la", "mc12_le", "mc2_lc", "mc22ls", "mc12_m", "mc7_lr", "mc2pyb", "mc96_lc", "mc2pylc", "mc22m", "mc2_m", "mc2pyl", "mc7_l", "mc2_le", "mc22l", "mc2pylr", "mc2_ls", "mc2_lr", "mc96_la", "mc12_l", "mc2_b", "mc7_lc", "mc22le", "mc7_b", "mc96_l", "mc12_ls", "mc2_e"], "mc2_r": ["mc42___pair", "mcball_p", "mcball___r", "mc5_r", "mc42___g", "mc2___rc", "mc2___pair", "mc5_p", "mc2_rr", "mc2_p", "mcball_rr", "mc2___p", "mc2_right", "mc42_right", "mc5_rc", "mc2___g", "mc2_rc", "mc42_g", "mcball___p", "mc5_l", "mc42___r", "mc2_pair", "mcball_rc", "mcball___rr", "mc42___right", "mcball_r", "mc2___rr", "mc42_pair", "mc2___right", "mc42_r", "mc2_g", "mcball___rc", "mc2___r"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_disk_reset(DeviceState *dev)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);\n\n    uint64_t nb_sectors;\n\n\n\n    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));\n\n\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    nb_sectors /= s->qdev.blocksize / 512;\n\n    if (nb_sectors) {\n\n        nb_sectors--;\n\n    }\n\n    s->qdev.max_lba = nb_sectors;\n\n    /* reset tray statuses */\n\n    s->tray_locked = 0;\n\n    s->tray_open = 0;\n\n}\n", "idx": 5054, "substitutes": {"dev": ["ptr", "de", "ds", "conn", "priv", "nt", "Device", "spec", "Dev", "ad", "dd", "serv", "obj", "pro", "ve", "pad", "device", "sd", "mem", "proc", "def", "DEV", "ver", "info", "buf", "cam", "raw", "test", "hw", "des", "go", "ev", "out", "cmd", "dem"], "s": ["S", "p", "ds", "is", "ms", "ps", "vs", "ins", "spec", "ies", "sync", "serv", "sl", "sam", "obj", "ss", "self", "j", "aws", "comm", "st", "bs", "js", "ns", "hs", "b", "state", "sq", "g", "ses", "sts", "rs", "gs", "y", "ts", "es", "ops", "stats", "m", "fs", "sis", "sv", "cs", "ears", "ims", "sb", "des", "ls", "ats", "qs", "sol", "se", "eps", "sw", "states"], "nb_sectors": ["nb_seors", "nb_sections", "nb_specs", "nb_spectors", "nb_vellers", "nb_spegments", "nb_sellers", "nb_pellers", "nb_nections", "nb_geholders", "nb_learers", "nb_vearers", "nb_pelements", "nb_pecs", "nb_peors", "nb_seholders", "nb_speors", "nb_vecs", "nb_velements", "nb_tectors", "nb_sedllers", "nb_secs", "nb_segments", "nb_pegments", "nb_geors", "nb_nellers", "nb_spellers", "nb_serctors", "nb_vectors", "nb_seers", "nb_necs", "nb_serctions", "nb_speholders", "nb_gellers", "nb_speers", "nb_neors", "nb_telements", "nb_sedctors", "nb_tecs", "nb_lectors", "nb_lelements", "nb_gectors", "nb_selements", "nb_pectors", "nb_spections", "nb_lellers", "nb_sedarers", "nb_serors", "nb_veholders", "nb_peers", "nb_nelements", "nb_sercs", "nb_sedlements", "nb_teors", "nb_nectors", "nb_veors", "nb_negments", "nb_neers", "nb_searers"]}}
{"project": "FFmpeg", "commit_id": "eedd9148733ff4467c62092ad1c1a26d6125b249", "target": 1, "func": "static int read_part_of_packet(AVFormatContext *s, int64_t *pts,\n\n                               int *len, int *strid, int read_packet) {\n\n    AVIOContext *pb = s->pb;\n\n    PVAContext *pvactx = s->priv_data;\n\n    int syncword, streamid, reserved, flags, length, pts_flag;\n\n    int64_t pva_pts = AV_NOPTS_VALUE, startpos;\n\n    int ret;\n\n\n\nrecover:\n\n    startpos = avio_tell(pb);\n\n\n\n    syncword = avio_rb16(pb);\n\n    streamid = avio_r8(pb);\n\n    avio_r8(pb);               /* counter not used */\n\n    reserved = avio_r8(pb);\n\n    flags    = avio_r8(pb);\n\n    length   = avio_rb16(pb);\n\n\n\n    pts_flag = flags & 0x10;\n\n\n\n    if (syncword != PVA_MAGIC) {\n\n        pva_log(s, AV_LOG_ERROR, \"invalid syncword\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {\n\n        pva_log(s, AV_LOG_ERROR, \"invalid streamid\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n    if (reserved != 0x55) {\n\n        pva_log(s, AV_LOG_WARNING, \"expected reserved byte to be 0x55\\n\");\n\n    }\n\n    if (length > PVA_MAX_PAYLOAD_LENGTH) {\n\n        pva_log(s, AV_LOG_ERROR, \"invalid payload length %u\\n\", length);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {\n\n        pva_pts = avio_rb32(pb);\n\n        length -= 4;\n\n    } else if (streamid == PVA_AUDIO_PAYLOAD) {\n\n        /* PVA Audio Packets either start with a signaled PES packet or\n\n         * are a continuation of the previous PES packet. New PES packets\n\n         * always start at the beginning of a PVA Packet, never somewhere in\n\n         * the middle. */\n\n        if (!pvactx->continue_pes) {\n\n            int pes_signal, pes_header_data_length, pes_packet_length,\n\n                pes_flags;\n\n            unsigned char pes_header_data[256];\n\n\n\n            pes_signal             = avio_rb24(pb);\n\n            avio_r8(pb);\n\n            pes_packet_length      = avio_rb16(pb);\n\n            pes_flags              = avio_rb16(pb);\n\n            pes_header_data_length = avio_r8(pb);\n\n\n\n            if (pes_signal != 1 || pes_header_data_length == 0) {\n\n                pva_log(s, AV_LOG_WARNING, \"expected non empty signaled PES packet, \"\n\n                                          \"trying to recover\\n\");\n\n                avio_skip(pb, length - 9);\n\n                if (!read_packet)\n\n                    return AVERROR(EIO);\n\n                goto recover;\n\n            }\n\n\n\n            ret = avio_read(pb, pes_header_data, pes_header_data_length);\n\n            if (ret != pes_header_data_length)\n\n                return ret < 0 ? ret : AVERROR_INVALIDDATA;\n\n            length -= 9 + pes_header_data_length;\n\n\n\n            pes_packet_length -= 3 + pes_header_data_length;\n\n\n\n            pvactx->continue_pes = pes_packet_length;\n\n\n\n            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20)\n\n                pva_pts = ff_parse_pes_pts(pes_header_data);\n\n        }\n\n\n\n        pvactx->continue_pes -= length;\n\n\n\n        if (pvactx->continue_pes < 0) {\n\n            pva_log(s, AV_LOG_WARNING, \"audio data corruption\\n\");\n\n            pvactx->continue_pes = 0;\n\n        }\n\n    }\n\n\n\n    if (pva_pts != AV_NOPTS_VALUE)\n\n        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);\n\n\n\n    *pts   = pva_pts;\n\n    *len   = length;\n\n    *strid = streamid;\n\n    return 0;\n\n}\n", "idx": 5060, "substitutes": {"s": ["sc", "t", "os", "p", "S", "conf", "ds", "south", "is", "a", "ms", "l", "v", "sp", "ps", "ins", "sm", "z", "w", "set", "ss", "aws", "bs", "ns", "js", "hs", "b", "sq", "g", "ses", "sts", "sg", "scl", "rs", "gs", "ar", "ts", "es", "e", "stats", "m", "fs", "its", "sv", "cs", "x", "sb", "c", "as", "us", "ls", "ats", "n", "sys", "qs", "sw"], "pts": ["cmdt", "ptt", "portsets", "pkgts", "ptts", "portt", "cmdsets", "pkgs", "cmdts", "ptsets", "ports", "portts", "pkgsets", "cmds", "pkgt"], "len": ["elt", "lf", "lp", "ln", "ll", "el", "Len", "l", "fin", "ml", "lang", "loc", "offset", "val", "ld", "en", "dl", "size", "mem", "bytes", "seq", "ls", "nl", "lan", "pos", "load"], "strid": [" strId", "streamide", " strname", "streamId", "stride", "stringname", "stringid", "stringId", "streamname", "strId", " stride", "strname", "stringide"], "read_packet": ["readtpacket", "read_octacket", "readtoctets", "read_octets", "read_octET", "readtoctET", "read_ppets", "readtoctacket", "readtpackET", "read_ppET", "read_presET", "read_presets", "read_octet", "read_ppacket", "readtoctet", "read_packET", "readtpackacket", "read_ppet", "read_packacket", "readtpackets", "read_presacket", "read_preset", "read_packets"], "pb": ["tc", "py", "vp", "pp", "cp", "p", "lb", "rpm", "pkg", "td", "cv", "bj", "tmp", "lp", "PB", "sp", "func", "ctx", "pc", "fb", "mp", "ping", "pg", "msg", "typ", "wp", "cb", "sam", "amp", "pm", "pa", "prot", "pt", "bs", "asm", "proc", "np", "bb", "b", "emb", "mt", "erb", "buf", "sys", "gb", "peer", "buffer", "fp", "tp", "ts", "pd", "jp", "db", "pool", "dp", "um", "tg", "vm", "conv", "bp", "eb", "bank", "pl", "uf", "tm", "sb", "tx", "pid", "stab", "tk", "tab", "rb", "wb"], "pvactx": ["puvcttx", "pvpecttx", "pvactxp", "pvpacttx", "pvictx", "pvicttx", "pvctex", "pvpactx", "pvictX", "pvpactex", "puvctx", "pvctX", "puvctxp", "puvactxp", "pvpectex", "pvecttx", "pvctxX", "puvactx", "pvpectx", "pvpactX", "pvectx", "pvactex", "pvectX", "pvcttx", "pvictxp", "puvactX", "puvacttx", "puvctX", "pvctxex", "pvctxp", "pvctx", "pvpectX", "pvctxtx", "pvacttx", "pvectex", "pvctxx", "pvactX"], "syncword": ["synno", "synctag", "yncWord", "yncbyte", " syncbyte", "synwords", " syncwords", "locktext", "scanwords", "yncno", "synWord", " synctext", "locktype", "syncwords", "syncno", "scanword", "scanWord", "synterm", "syncbyte", " synctype", "synctext", "polltype", " synctag", "synword", "pollword", "synbyte", "polltag", "syncWord", "scanterm", "lockword", "yncterm", "yncword", "syncterm", "polltext", "yncwords", "synctype", "locktag", " syncno"], "streamid": ["steamid", " streamoid", "specID", "streamident", "reammid", "Streamoid", "streamId", "steamID", "streamID", "StreamID", "streamtype", "reamident", "streaminfo", "poolId", "usertype", " streamtype", "hostident", "hostide", "channelid", " streamident", "reamID", " streamide", "reamifier", "channelID", " streamID", "formlike", "streamifier", "channelId", "streammid", "poolid", "hostid", "userID", "streamlike", "userid", "formId", " streamifier", " streaminfo", "reaminfo", "streamide", " streammid", "formID", "formid", "StreamId", "specoid", "hostifier", "userId", "reamide", "specid", "reamId", "reamiden", "streamiden", " streamiden", "steamId", "pooliden", "channelmid", "Streamtype", "Streamid", " streamlike", "reamid", "streamoid", "poolinfo", "steamlike", " streamId"], "reserved": ["Resumed", "REServed", "reolved", "presserved", "responsolved", "REServation", "resserved", "resumed", "responservation", "RESumed", "verserved", "responserved", "Reservation", "verservation", "reervation", "Resolved", "RESolved", "preservation", "Reserved", "responsumed", "preserved", "presolved", "versolved", "presumed", "versserved", "stickervation", "reservation", "stickolved", "resolved", "stickerved", "stickumed", "reerved"], "flags": ["tests", "grades", "items", "properties", "atts", "types", "planes", "ps", "relations", "vs", "frames", "words", "locks", "options", "fps", "fields", "missions", "ports", "Flags", "ints", "bytes", "blocks", "rates", "heads", "limits", "tags", "abilities", "ts", "faces", "ops", "stats", "actions", "vals", "bits", "utils", "flag", "features", "args", "mask", "orts", "ants", "settings", "acts", "weights", "ags"], "length": ["capacity", "pp", "ENGTH", "quality", "form", "limit", "full", "f", "l", "volume", "join", "data", "error", "position", "padding", "duration", "pieces", "performance", "offset", "options", "other", "h", "ength", "always", "pad", "php", "time", "size", "word", "bytes", "name", "amount", "maximum", "type", "range", "buffer", "height", "end", "expected", "loop", "sequence", "L", "count", "angle", "message", "total", "shape", "load", "lib", "Length"], "pts_flag": ["pts_tag", "pts1flag", "pts1flags", "ptts_limit", "pts1tag", "pts_limit", "pts1only", "ptps_tag", "pts_mask", "ptts_flag", "ptts_flags", "ptps_only", "pts_only", "ptts_field", "pts_field", "pts_flags", "ptps_flag", "ptps_flags", "ptts_mask"], "startpos": ["endcol", "startingval", " startposition", "stoppos", "stopPOS", " startval", " startPos", "endPos", " startPOS", "endPOS", "startposition", " startcol", "startingpos", "stopPos", "startPos", "endposition", "startval", "endval", "startcol", "startingPos", "stopcol", "startPOS", "startingposition", "endpos"], "ret": ["VAL", "reset", "lit", "details", "progress", "RET", "re", "Ret", "fin", "rets", "val", "prop", "ry", "fit", "rem", "mem", "resp", "result", "rs", "ref", "rev", "rel", "res", "vals", "alt", " resp"], "pes_signal": ["pes_SIGNet", "pes_signals", "pes_consaler", "pes_discaler", "pes_conset", "pes_SIGNal", "pes_signaler", "pes_consalog", "pes_discet", "pes_SIGNals", "pes_signar", "pes_SIGNar", "pes_discal", "pes_signalog", "pes_seal", "pes_packaler", "pes_packar", "pes_consal", "pes_sealer", "pes_SIGNaler", "pes_sear", "pes_discalog", "pes_SIGNalog", "pes_signet", "pes_packal", "pes_packals", "pes_seals"], "pes_header_data_length": ["pes_header_data_size", "pes_header_block_size", "pes_header_block_length", "pes_header_data_len", "pes_header_block_len", "pes_header_block_long", "pes_header_data_long"], "pes_packet_length": ["pes_packet_p", "pes_packets__", "pes_packet_size", "pes_packets_p", "pes_packet_data", "pes_packet_len", "pes_packacket_size", "pes_packacket_data", "pes_packacket_length", "pes_packacket_len", "pes_packet__"], "pes_flags": ["pe_options", "pe_flag", "pes___options", "pes_features", "pes_options", "pes___features", "pe_features", "pe_flags", "pes_flag", "pes___flag", "pes___flags"], "pes_header_data": ["pes_header_block", "pes_Header_table", "pes_header_table", "pes_Header_block", "pes_header_DATA", "pes_Header_data", "pes_Header_DATA"]}}
{"project": "FFmpeg", "commit_id": "60f10e0ad37418cc697765d85b0bc22db70f726a", "target": 1, "func": "static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){\n\n    int i;\n\n    int dc0;\n\n\n\n    dc0=0;\n\n    for(i=0;i<8; i++)\n\n        dc0+= src[i-stride];\n\n    dc0= 0x01010101*((dc0 + 4)>>3);\n\n\n\n    for(i=0; i<8; i++){\n\n        ((uint32_t*)(src+i*stride))[0]=\n\n        ((uint32_t*)(src+i*stride))[1]= dc0;\n\n    }\n\n}\n", "idx": 5071, "substitutes": {"src": ["ptr", "rc", "sc", "RC", "ser", "pkg", "bh", "tmp", "dest", "inner", "load", "ctr", "sup", "usc", "ins", "rl", "inst", "zh", "sl", "txt", "obj", "cur", "cc", "ipl", "req", "supp", "st", "sr", "in", "source", "bb", "sq", "http", "input", "rs", "now", "sn", "jp", "iv", "sb", "rt", "hl", "impl", "sys", "rb", "sur", "img", "bc"], "stride": ["strine", "STRimate", "stockimate", "divimate", "specride", "strice", "specider", "STRide", "stockider", "STRice", "brice", "STRride", "constider", "stockride", "brride", "STRider", " strice", "constide", " strider", "stockide", "strimate", "specine", "constride", "constade", " strade", "strride", "brider", "divride", "strade", "STRade", "bride", "specide", "divine", "strider", " strride", "STRine", "divide", "divider"], "i": ["key", "p", "id", "ii", "ini", "it", "q", "my", "ogi", "asi", "hi", "di", "gi", "y", "remote", "PI", "iter", "ci", "ik", "loop", "ims", "qi", "cli", " ii", "json", " I", "ei", "ix", "ic", "si", "oi", "j", "ji", "index", "at", "zi", "this", "try", "pi", "x", "phi", "series", "is", "ind", "mi", "io", "ri", "chain", "ip", "ex", "point", "multi", "print", " ti", "ti", "m", "iy", "ai", "im", "I", "go", "init", "dr", "li", "sim", "ki", "bi", "to", " bi", "me", "\u0438", "uri", "o", "in", "info", "g", "ui", "iu", "ij", "xi", "err"], "dc0": ["fc02", "arcVal", "disc00", "dcno", "discSystem", "dc1", "ccano", "cca0", " dcSystem", " dc2", "DC7", "lc12", "fc0", "DC8", "DC1", " dc90", " dcno", "di00", "lc00", "fc1", "dc02", "dc12", "di12", "dc8", "dcVal", "dc2", "dc90", "dc00", "pc5", "arc1", "tc90", "DC0", "ccaZero", " dc5", "DC2", "pc02", "tcZero", " dc1", " dc12", "dc7", "disc1", "dcSystem", "dc5", "arc8", "fc5", "lc0", "DC00", " dc00", " dc02", " dcZero", "arc0", "DCVal", "disc2", "fcVal", "pc0", "fc8", "pc1", "disc7", "disc0", " dc7", "tc0", "cca90", "di0", "tcno", "dcZero", "DCSystem"]}}
{"project": "qemu", "commit_id": "955cc8c9541779e09895a9c5ccbf8ace15d884f5", "target": 0, "func": "static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,\n\n                              uint16_t index, uint16_t num)\n\n{\n\n    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);\n\n\n\n    if (index >= VIRTIO_PCI_QUEUE_MAX) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Current code in virtio.c relies on 4K alignment. */\n\n    if (addr && (align != 4096)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (!vdev) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    virtio_queue_set_addr(vdev, index, addr);\n\n    if (!addr) {\n\n        virtio_queue_set_vector(vdev, index, 0);\n\n    } else {\n\n        /* Fail if we don't have a big enough queue. */\n\n        /* TODO: Add interface to handle vring.num changing */\n\n        if (virtio_queue_get_num(vdev, index) > num) {\n\n            return -EINVAL;\n\n        }\n\n        virtio_queue_set_vector(vdev, index, index);\n\n    }\n\n    /* tell notify handler in case of config change */\n\n    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;\n\n    return 0;\n\n}\n", "idx": 5093, "substitutes": {"sch": ["ph", "isch", "sc", "isc", "kh", "ch", "ih", "th", "https", "sk", "mk", "ach", "kr", "org", "sp", "sm", "rh", "wk", "chid", "hed", "ssh", "orsche", "sd", "soc", "hs", "ssl", "Sch", "sh", "sg", "gh", "chn", "ich", "yz", "sche", "tk", "shop", "sw"], "addr": ["ptr", "init", "ace", "phys", "conf", "host", "eth", "pkg", "conn", "arr", "ctx", "aff", "ix", "ad", "hash", "msg", "prefix", "address", "map", "cb", "loc", "offset", "obj", "set", "alias", "gate", "pad", "oad", "lock", "ok", "attr", "ip", "ssl", "np", "shift", "sys", "act", "ref", "alloc", "cmp", "ord", "len", "res", "coord", "help", "ac", "x", "src", "rt", "nl", "alt", "ack", "add", "pos", "url", "cmd"], "align": ["ign", "conf", "pack", "config", "weight", "work", "dim", "rot", "aff", "label", "xff", "hash", "scan", "map", "diff", "address", "offset", "val", "pay", "loc", "alias", "coll", "lock", "mix", "aligned", "shift", "adj", "sign", "len", "cmp", "rank", "tool", "rol", "rel", "coord", "hal", "angle", "block", "al", "shape", "ctl", "cmd", "sw"], "index": ["key", "init", "order", "active", "max", "config", "success", "id", "ind", "insert", "sp", "length", "ix", "thread", "ctx", "hash", "position", "address", "diff", "loc", "offset", "val", "set", "ion", "node", "axis", "alias", "valid", "ok", "each", "gate", "attr", "size", "i", "vector", "slot", "info", "level", "connect", "slice", "timeout", "type", "zero", "ref", "seed", "row", "height", "Index", "len", "rank", "iter", "find", "end", "instance", "loop", "round", "x", "number", "open", "block", "pos", "start", "add", "n", "seek"], "num": ["NUM", "phys", "mon", "max", "no", "dim", "sum", "ctx", "nom", "mult", "con", "node", "offset", "en", "valid", "nm", "size", "mem", "np", "name", "net", "Num", "mn", "new", "len", "cmp", "um", "end", "un", "all", "number", "count", "on", "x", "n", "pos", "add", "nb", "out"], "vdev": ["vscan", "vdevice", "ddevice", "wdevice", "nval", " vval", "nvmem", "evend", "nvdebug", " vev", "vvserv", "vev", "evserv", "vblock", "uvdebug", "uvmem", "vardev", "wserv", "uvblock", "wev", "vartest", "verdev", "dswitch", "ddata", "envde", "envend", "nvstick", "verdevice", "nserv", "vvdev", "vde", "varscan", "vvval", "uvde", " vscan", "vstick", "vdata", " vstick", "vvev", "verev", "uvscan", "evdevice", " vde", "uvend", "vend", "uvtest", "envdev", "vswitch", "vval", "nev", "wdev", "wdata", " vserv", "envdebug", "uvdev", "wend", "nvswitch", " vblock", " vdata", " vdebug", "vmem", "nvdata", " vmem", "varblock", "vdebug", "ndev", " vend", "nvdev", " vswitch", "verdata", "uvstick", "vtest", "nvdevice", " vtest", "vserv", " vdevice", "evdev", "ddev"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    rtl8139_do_receive(opaque, buf, size, 1);\n\n}\n", "idx": 5099, "substitutes": {"opaque": ["indade", "boaques", "boacity", "opaques", "paque", "indque", " oposter", " opaques", " opade", "indacity", "pque", "boque", "boade", "poster", "opque", "paques", " opque", "oposter", "opacity", " opacity", "booster", "indaque", "opade", "boaque"], "buf": ["doc", "p", "bound", "cv", "v", "data", "bar", "map", "Buffer", "aka", "br", "buff", "Buff", "ann", "mem", "bytes", "b", "bb", "uffer", "pb", "cap", " vec", "buffer", "raw", "vec", "window", "uf", " avail", "queue", "bin", "block", "box", "tab", "rb", "bag", " buffer", " buff", "bc", "batch"], "size": ["small", "t", " resize", "Size", "form", "news", "see", "sum", "SIZE", "length", " notice", "ize", "sent", "send", "offset", "set", " Size", " sizes", "empty", "body", "space", "name", "fee", "g", "type", "len", "code", "e", "sn", "count", "message", "n", "shape", " count"]}}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||\n\n        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n        (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        return lchown(rpath(fs_ctx, path, buffer),\n\n                      credp->fc_uid, credp->fc_gid);\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n\n        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        return local_set_mapped_file_attr(fs_ctx, path, credp);\n\n    }\n\n    return -1;\n\n}\n", "idx": 5102, "substitutes": {"fs_ctx": ["fsaccontext", " fs_jp", "fs_cfg", "fs_setup", "ns_conn", "fs5ctx", "fskcur", "irs5cont", "cs_ctx", "fsdbcfg", "ns_context", "fs2tx", "irs_cont", "fs___cv", "fts_client", "fsptctx", "fs_src", "httpptsrc", "http_ctx", "fs_hw", "fsacsetup", "http_context", "fskctx", "httpptvoc", "httpptcontext", "fsptcont", "httpptctx", "fts_cp", "fs___voc", "ns_setup", "cs_jp", "fspttx", "fs___context", "ns_co", "cs_obj", "fs_conn", "fsptcontext", "irs5hw", "fs5hw", "http_src", "fsdbjp", "fs_cont", "http_voc", "cs_cfg", "fs_tx", "fs___ctx", " fs_co", "fts_ctx", "fsacctx", "fspthw", "fsdbcur", "fs___cmp", "ns_cmp", "fs5tx", "fs_cur", "fsptvoc", "fsdbcp", "fs5cont", "fs2cont", "fs_client", "fsdbctx", "fs_cv", " fs_cur", "fs_co", "fs_cmp", "fskjp", "ns_tx", "fs2hw", "fs_jp", "fsptsrc", "fsdbclient", "fs_cp", "irs5tx", "fsacconn", "fts_cfg", "fskco", "irs5ctx", "irs_tx", "fs_context", "irs_hw", "fs2ctx", "ns_cv", "irs_ctx", "fs_voc", "fsdbco", "fs___src", "fs_obj", "ns_ctx"], "fs_path": ["fsaccontext", "cs_crit", "cs_self", "cs_context", "fs5self", "fs5ctx", "fs_device", "fs5crit", "fsacctx", "cs_ctx", "cs_path", "cs_device", "fs_self", "fsacdevice", "fs_context", "fsacpath", "fs5path", "fs_crit"], "credp": ["cpredpi", "ccedp", "ancredp", "cedp", "ucredp", "codedP", " credpkg", "ccedpi", "ccledp", "cursorp", "csedp", "cledpy", "ccledpi", "ucpredpi", "callcedlp", "crednp", " ciedp", "cledpolicy", "credpi", "cppedpt", "crodp", "ancriedpr", " ciedpolicy", "cedP", " cashedi", "chedp", "cppedpi", " credphp", "cpredpp", "codedp", "crede", "ccedpr", "ciedphp", "cedinfo", "chede", " Criednp", " Criedp", "ancriedp", "ccedpy", "cppedpp", "credpress", "ucredpt", "credv", "crodinfo", "ecrode", "ciedp", "ccedop", "credlp", "credpolicy", "credinfo", "cashedp", " credpolicy", "ancredpr", "ecredvp", "credP", "ccedv", "cedlp", "ccledlp", "callcedP", "csedpt", "ccednp", "ucredpp", "ucredpi", "crodvp", "credvp", " Criedlp", "ucpredpt", " cashedop", "chedvp", "cedop", "criedpress", "codedop", "csedpi", "credpp", "ancredpress", "criednp", "cursorop", "cursori", "cpredpt", "cashedop", "ecrodinfo", "callredp", " Credpi", "cashedi", " Credp", "ciedpy", "criedp", "cledp", "credpt", "callcedop", "ecrede", "ecrodvp", " Criedpi", " credpy", "ccedpkg", "credpy", "ccedpress", "chedinfo", "criedlp", "credop", "criedv", "criedpr", "ecredp", "ecredinfo", " credop", "cede", "cledphp", "ucpredp", "callcedp", "ancriedv", "cclednp", "cpredp", "ciedpolicy", "csedpp", "ccedlp", "ccedpolicy", "ecrodp", "callredlp", " ciedpy", "cashedpkg", "credphp", " Credlp", " Crednp", "crode", "ancriedpress", "credpr", "cedvp", "callredP", "codedlp", "callredop", "ucpredpp", "cppedp", "cursorpkg", " cashedp", "criedpi", " credi", "ccedphp", "ccedP", "ancredv", " cashedpkg", "credpkg", " ciedphp", "ccedi", "credi"], "buffer": ["extra", " Buffer", "limit", "f", "binary", "v", "data", "length", "channel", "fb", "append", "stack", "bar", "Buffer", "phrase", "pad", "package", "buff", "Buff", "available", "mem", "b", "pointer", "result", "comment", "buf", "que", "password", "trace", "pb", "text", "command", "row", "iter", "flow", "raw", "page", "flag", "base", "byte", "bank", "window", "bridge", "uf", "c", "queue", "block", "message", "cache", "batch", "template"], "path": ["key", "entry", "cp", "p", "pkg", "th", "form", "temp", "full", "data", "length", "ctx", "PATH", "image", "file", "prefix", "transform", "w", "node", "str", "loc", "prop", "Path", "port", "package", "chain", "history", "ip", "link", "pointer", "b", "dir", "name", "root", "index", "current", "trace", "ref", "text", "end", "pattern", "raw", "ath", "test", "patch", "route", "context", "binding", "url", "value", "stream", "cmd", "template"]}}
{"project": "qemu", "commit_id": "ff9d38963e55598b40237735426225c35de6c7e5", "target": 0, "func": "static void qdict_crumple_test_recursive(void)\n\n{\n\n    QDict *src, *dst, *rule, *vnc, *acl, *listen;\n\n    QObject *child, *res;\n\n    QList *rules;\n\n\n\n    src = qdict_new();\n\n    qdict_put(src, \"vnc.listen.addr\", qstring_from_str(\"127.0.0.1\"));\n\n    qdict_put(src, \"vnc.listen.port\", qstring_from_str(\"5901\"));\n\n    qdict_put(src, \"vnc.acl.rules.0.match\", qstring_from_str(\"fred\"));\n\n    qdict_put(src, \"vnc.acl.rules.0.policy\", qstring_from_str(\"allow\"));\n\n    qdict_put(src, \"vnc.acl.rules.1.match\", qstring_from_str(\"bob\"));\n\n    qdict_put(src, \"vnc.acl.rules.1.policy\", qstring_from_str(\"deny\"));\n\n    qdict_put(src, \"vnc.acl.default\", qstring_from_str(\"deny\"));\n\n    qdict_put(src, \"vnc.acl..name\", qstring_from_str(\"acl0\"));\n\n    qdict_put(src, \"vnc.acl.rule..name\", qstring_from_str(\"acl0\"));\n\n\n\n    res = qdict_crumple(src, &error_abort);\n\n\n\n    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);\n\n\n\n    dst = qobject_to_qdict(res);\n\n\n\n    g_assert_cmpint(qdict_size(dst), ==, 1);\n\n\n\n    child = qdict_get(dst, \"vnc\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    vnc = qobject_to_qdict(child);\n\n\n\n    child = qdict_get(vnc, \"listen\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    listen = qobject_to_qdict(child);\n\n    g_assert_cmpstr(\"127.0.0.1\", ==, qdict_get_str(listen, \"addr\"));\n\n    g_assert_cmpstr(\"5901\", ==, qdict_get_str(listen, \"port\"));\n\n\n\n    child = qdict_get(vnc, \"acl\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    acl = qobject_to_qdict(child);\n\n\n\n    child = qdict_get(acl, \"rules\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);\n\n    rules = qobject_to_qlist(child);\n\n    g_assert_cmpint(qlist_size(rules), ==, 2);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"fred\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"allow\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"bob\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"deny\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    /* With recursive crumpling, we should see all names unescaped */\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(vnc, \"acl.name\"));\n\n    child = qdict_get(vnc, \"acl\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    acl = qdict_get_qdict(vnc, \"acl\");\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(acl, \"rule.name\"));\n\n\n\n    QDECREF(src);\n\n    QDECREF(dst);\n\n}\n", "idx": 5104, "substitutes": {"src": ["sel", "SOURCE", "cont", "scan", "sl", "txt", "loc", "str", "cur", "supp", "sr", "sq", "gs", "fp", "sn", "its", "ripp", "hl", "sur", "obl", "ptr", "sc", "copy", "scripts", "buster", "dist", "ins", "rl", "lat", "st", "secure", "js", "dict", "proc", "sts", "new", "stat", "rol", "sb", "impl", "sys", "rc", "construct", "syn", "dest", "nil", "ctr", "ind", "usc", "zh", "cb", "setup", "ipl", "trans", "bs", "source", "resh", "comp", "std", "scl", "rs", "iv", "rel", "rt", "ser", "lr", "sync", "inst", "Source", "ssl", "usr", "java", "rect", "addr", "rb", "input", "grow", "sw"], "dst": ["dsust", "daot", " dnt", "dev", "dct", "dnd", "dest", "ddsts", "ddest", "deot", "ddst", " drc", "dact", " dsts", "dust", " dtd", "dsst", " dv", "dsot", " dust", "Dst", "wust", "wtd", "dsrc", " dct", "dv", "dstd", "wst", "Dnd", "dnt", "dot", "dsnt", "dtd", " dnd", "Dsts", "detd", " dot", "dsv", "dast", "Dest", "wnt", "ddnd", " dest", "dsct", "dsts", "darc", "drc"], "rule": ["Rule", "policy", "file", "msg", "force", "disable", "node", "val", "attr", "ule", "fc", "group", "def", "comment", "member", "row", "rec", "record", "rol", "pri", "base", "test", "desc", "tx", "item", "cle", "event", "action"], "vnc": ["VNC", "jnic", "vtnic", "fnp", "vscn", "vsnc", "fcn", "vtnc", "vNC", "vnis", "Vnc", " vnp", "vtcn", "fnc", "jnis", "Vcn", "vtnis", "vnp", "jcn", " vNC", "evNC", "vsnic", "evcn", "Vnp", "vnic", "jnp", " vcn", "vcn", " vco", "evnc", "vsnis", "jnc", "fco", "evnp", "jco", "vco"], "acl": ["flags", "sc", "ace", "et", "ch", "config", "ach", "except", "ctx", "policy", "media", "ic", "msg", "cl", "ast", "attr", "anc", "annot", "mac", "op", "rol", "ca", "exec", "priority", "ac", "owner", "aux", "ack", "sys"], "listen": ["laten", "intenable", "allenn", "clener", "listening", "opener", "listeng", "listens", "latens", "listEn", "batchon", "listeden", "listeen", "clenn", "batchEn", "allen", "inten", "allener", " listenable", "latener", "clening", "listedener", "intened", "listenn", "listedeen", "listener", "listedeng", "liston", "latenn", " listeen", " liston", "batchen", "lateng", "allening", " listEn", "batcheen", "latenable", "clen", "listened", "intener", "latening", "listedens", "opens", "listedEn", "latened", "openg", "listedon", " listener", "open", "listenable", " listened"], "child": ["get", "key", "fr", "fn", "id", "nt", "file", "error", "q", "my", "handle", "root", "friend", "Child", "decl", "row", "remote", "bot", "cle", "sort", "dev", "weak", "ch", "el", "handler", "ach", "except", "list", "ew", "brother", "control", "ell", "def", "name", "comment", "member", "new", "instance", "try", "all", "part", "core", "session", "item", "block", "shell", "request", "entry", "ow", "fd", "reader", "cl", "port", "cow", "group", "children", "tree", "type", "command", "table", "local", "create", "add", "lib", "close", "sim", "task", "ll", "col", "parent", "force", "node", "other", "server", "cell", "echo", "job", "test", "ward", "client", "back", "reply", "cache", "batch"], "res": ["out", "rc", "reset", "respons", "ser", "RES", "resource", "rera", "r", "re", "Res", "rr", "rss", "fresh", "error", "pas", "red", "resolution", "val", "crit", "cons", "trans", "req", "ress", "rem", "rex", "ret", "rus", "resp", "result", "resh", "pres", "rx", "usr", "sys", "resources", "hr", "rek", "def", "response", "rev", "rs", "ref", "rest", "rec", "rez", "results", "rel", "vals", "us", "gr", "aux", "ro", "ack", "rt", "sol", "reg"], "rules": ["flags", "tests", "items", "Rules", "relations", "frames", "links", "files", "options", "groups", "errors", "events", "views", "rows", "blocks", "children", "rs", "keys", "ops", "results", "actions", "vals", "comments", "values", "fields", "params"]}}
{"project": "qemu", "commit_id": "68ab47e4b4ecc1c4649362b8cc1e49794d1a6537", "target": 1, "func": "static void test_validate_fail_alternate(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefAlternate *tmp;\n\n    Visitor *v;\n\n    Error *err = NULL;\n\n\n\n    v = validate_test_init(data, \"3.14\");\n\n\n\n    visit_type_UserDefAlternate(v, NULL, &tmp, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_UserDefAlternate(tmp);\n\n}\n", "idx": 5121, "substitutes": {"data": ["rew", "json", "t", "form", "d", "join", "spec", "mu", "error", "DATA", "obj", "reader", "Data", "device", "bus", "empty", "dat", "next", "in", "mem", "result", "def", "info", "step", "text", "ata", "da", "rel", "raw", "table", "missing", "initial", "accept", "window", "context", "input", "out", "batch"], "unused": ["unspecified", " unspecified", "unespecified", "unuse", "uneused", " untusable", " untused", "uneusable", " unuse", "unusable", " unusable", " untuse", "uneuse", " untspecified"], "tmp": ["ptr", "json", "vp", "emp", "p", "old", "pkg", "cv", "temp", "tt", "mk", "sp", "nt", "ctx", "mp", "txt", "sam", "obj", "nv", "params", "buff", "dat", "attr", "rb", "np", "buf", "mb", "img", "cmp", "perm", "xy", "jp", "m", "etc", "tn", "Temp", "snap", "var", "src", "aaa", "tab", "nb", "vt", "mut", "imm", "uv"], "v": ["vp", "t", "p", "tv", "vi", "cv", "f", "vc", "l", "r", "vs", "it", "q", "vt", "ev", "w", "vv", "j", "h", "vr", "o", "i", "b", "V", "ver", "g", "y", "vm", "m", "sv", "ov", "var", "x", "vis", "u", "av", "vy", "uv"], "err": ["eas", "ptr", "fr", "Er", "order", "conf", "dev", "eor", "temp", "priv", "kr", "arr", "r", "ec", "rr", "error", "msg", "txt", "obj", "cert", "str", " terr", "req", "die", "br", "cr", "attr", "resp", "usr", "nr", "buf", "fee", "trace", "rs", "peer", "ocr", "iter", "erd", "res", "coord", "der", "gr", "aaa", "notice", "sys", "er", "ev", "cmd", "mr"]}}
{"project": "qemu", "commit_id": "c95de7e2c40da4235ceda6d134ae069dae80157e", "target": 1, "func": "static int qcow2_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int ret;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n\n    return bdrv_co_flush(bs->file);\n\n}", "idx": 5129, "substitutes": {"bs": ["ubs", "bos", "bps", "bh", "bi", "ils", "css", "aus", "bes", "irms", "cus", "vs", "aos", "hz", "bas", "ks", "ss", "bles", "outs", "aws", "js", "ns", "hs", "asis", "b", "ashes", "BS", "blocks", "ses", "bl", "sts", "gs", "ts", "cks", "obs", "lbs", "ubis", "acs", "uses", "bits", "its", "fs", "bis", "cs", "ims", "sb", "als", "ls", "bsp", "rys", "ats", "bc"], "s": ["t", "os", "S", "p", "ds", "is", "a", "ms", "v", "ps", "ies", "less", "ss", "iss", "h", "aws", "ys", "comm", "j", "js", "ns", "hs", "ssl", "b", "sq", "g", "ses", "sts", "pers", "rs", "gs", "ts", "stats", "has", "bits", "its", "sis", "bis", "cs", "args", "ims", "sb", "als", "as", "ls", "ats", "n", "sys", "sa"], "ret": ["deg", "ptr", "rep", "elt", "reset", "gt", "dt", "lit", "prime", "sec", "ll", "RET", "rm", "cat", "att", "nt", "re", "cont", "arr", "Ret", "ft", "rets", "txt", "red", "cert", "ext", "val", "str", "prop", "fun", "ry", "vet", "prot", "rem", "mt", "result", "lt", " fut", "err", "pret", "mac", "def", "usr", "nz", "net", "resp", "alg", "rev", "print", "jp", "res", "det", "try", "tr", "reg", "addr", "expr", "desc", " alt", "back", "alt", "reply", "rt", "grad", "del", "out", "cmd"]}}
{"project": "FFmpeg", "commit_id": "f7cf12b209c3a1ac2d6b797c585b593a5e9a461d", "target": 1, "func": "static int vc1_init_common(VC1Context *v)\n\n{\n\n    static int done = 0;\n\n    int i = 0;\n\n\n\n    v->hrd_rate = v->hrd_buffer = NULL;\n\n\n\n    /* VLC tables */\n\n    if(!done)\n\n    {\n\n        done = 1;\n\n        init_vlc(&ff_vc1_bfraction_vlc, VC1_BFRACTION_VLC_BITS, 23,\n\n                 ff_vc1_bfraction_bits, 1, 1,\n\n                 ff_vc1_bfraction_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_norm2_vlc, VC1_NORM2_VLC_BITS, 4,\n\n                 ff_vc1_norm2_bits, 1, 1,\n\n                 ff_vc1_norm2_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_norm6_vlc, VC1_NORM6_VLC_BITS, 64,\n\n                 ff_vc1_norm6_bits, 1, 1,\n\n                 ff_vc1_norm6_codes, 2, 2, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_imode_vlc, VC1_IMODE_VLC_BITS, 7,\n\n                 ff_vc1_imode_bits, 1, 1,\n\n                 ff_vc1_imode_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        for (i=0; i<3; i++)\n\n        {\n\n            init_vlc(&ff_vc1_ttmb_vlc[i], VC1_TTMB_VLC_BITS, 16,\n\n                     ff_vc1_ttmb_bits[i], 1, 1,\n\n                     ff_vc1_ttmb_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_ttblk_vlc[i], VC1_TTBLK_VLC_BITS, 8,\n\n                     ff_vc1_ttblk_bits[i], 1, 1,\n\n                     ff_vc1_ttblk_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_subblkpat_vlc[i], VC1_SUBBLKPAT_VLC_BITS, 15,\n\n                     ff_vc1_subblkpat_bits[i], 1, 1,\n\n                     ff_vc1_subblkpat_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n        }\n\n        for(i=0; i<4; i++)\n\n        {\n\n            init_vlc(&ff_vc1_4mv_block_pattern_vlc[i], VC1_4MV_BLOCK_PATTERN_VLC_BITS, 16,\n\n                     ff_vc1_4mv_block_pattern_bits[i], 1, 1,\n\n                     ff_vc1_4mv_block_pattern_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_cbpcy_p_vlc[i], VC1_CBPCY_P_VLC_BITS, 64,\n\n                     ff_vc1_cbpcy_p_bits[i], 1, 1,\n\n                     ff_vc1_cbpcy_p_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_mv_diff_vlc[i], VC1_MV_DIFF_VLC_BITS, 73,\n\n                     ff_vc1_mv_diff_bits[i], 1, 1,\n\n                     ff_vc1_mv_diff_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n        }\n\n        for(i=0; i<8; i++)\n\n            init_vlc(&ff_vc1_ac_coeff_table[i], AC_VLC_BITS, vc1_ac_sizes[i],\n\n                     &vc1_ac_tables[i][0][1], 8, 4,\n\n                     &vc1_ac_tables[i][0][0], 8, 4, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_msmp4_mb_i_vlc, MB_INTRA_VLC_BITS, 64,\n\n                 &ff_msmp4_mb_i_table[0][1], 4, 2,\n\n                 &ff_msmp4_mb_i_table[0][0], 4, 2, INIT_VLC_USE_STATIC);\n\n    }\n\n\n\n    /* Other defaults */\n\n    v->pq = -1;\n\n    v->mvrange = 0; /* 7.1.1.18, p80 */\n\n\n\n    return 0;\n\n}\n", "idx": 5138, "substitutes": {"v": ["vp", "t", "p", "dev", "tv", "vi", "cv", "f", "vc", "l", "vs", "q", "inv", "ev", "w", "vv", "k", "nv", "h", "j", "ve", "vr", "b", "V", "ver", "g", "vm", "vo", "m", "conv", "sv", "ov", "var", "x", "c", "n", "vt", "value", "av", "uv"], "i": ["json", "init", " I", "t", "li", "ei", "p", "dr", "sim", "ki", "bi", "ind", "ii", "ini", "sp", "mi", "ix", " bi", "me", "it", "tim", "ic", "gu", "\u0438", "asi", "hi", "si", "oi", "j", "di", "gi", "o", "ri", "in", "io", "chain", "ip", "ji", "js", "b", "index", "name", "ui", "multi", "iu", "ij", "xi", "y", "zi", "status", "ti", "ci", "m", "this", "iii", "ami", "iri", "ai", "pi", " j", "im", "x", "I", "ta", "qi", "cli", "series", "n", "er", "u", "err", " ii", "batch"]}}
{"project": "FFmpeg", "commit_id": "73e8e8dbf969b9a0bc1591abcfeba474a42e47bc", "target": 1, "func": "int av_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    int ret, i;\n    AVStream *st;\n    for(;;){\n        AVPacketList *pktl = s->raw_packet_buffer;\n        if (pktl) {\n            *pkt = pktl->pkt;\n            if(s->streams[pkt->stream_index]->codec->codec_id != CODEC_ID_PROBE ||\n               !s->streams[pkt->stream_index]->probe_packets ||\n               s->raw_packet_buffer_remaining_size < pkt->size){\n                AVProbeData *pd = &s->streams[pkt->stream_index]->probe_data;\n                av_freep(&pd->buf);\n                pd->buf_size = 0;\n                s->raw_packet_buffer = pktl->next;\n                s->raw_packet_buffer_remaining_size += pkt->size;\n                av_free(pktl);\n                return 0;\n        av_init_packet(pkt);\n        ret= s->iformat->read_packet(s, pkt);\n        if (ret < 0) {\n            if (!pktl || ret == AVERROR(EAGAIN))\n                return ret;\n            for (i = 0; i < s->nb_streams; i++)\n                s->streams[i]->probe_packets = 0;\n        st= s->streams[pkt->stream_index];\n        switch(st->codec->codec_type){\n        case AVMEDIA_TYPE_VIDEO:\n            if(s->video_codec_id)   st->codec->codec_id= s->video_codec_id;\n            break;\n        case AVMEDIA_TYPE_AUDIO:\n            if(s->audio_codec_id)   st->codec->codec_id= s->audio_codec_id;\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            if(s->subtitle_codec_id)st->codec->codec_id= s->subtitle_codec_id;\n            break;\n        if(!pktl && (st->codec->codec_id != CODEC_ID_PROBE ||\n                     !st->probe_packets))\n            return ret;\n        add_to_pktbuf(&s->raw_packet_buffer, pkt, &s->raw_packet_buffer_end);\n        s->raw_packet_buffer_remaining_size -= pkt->size;\n        if(st->codec->codec_id == CODEC_ID_PROBE){\n            AVProbeData *pd = &st->probe_data;\n            av_log(s, AV_LOG_DEBUG, \"probing stream %d\\n\", st->index);\n            --st->probe_packets;\n            pd->buf = av_realloc(pd->buf, pd->buf_size+pkt->size+AVPROBE_PADDING_SIZE);\n            memcpy(pd->buf+pd->buf_size, pkt->data, pkt->size);\n            pd->buf_size += pkt->size;\n            memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE);\n            if(av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)){\n                //FIXME we dont reduce score to 0 for the case of running out of buffer space in bytes\n                set_codec_from_probe_data(s, st, pd, st->probe_packets > 0 ? AVPROBE_SCORE_MAX/4 : 0);\n                if(st->codec->codec_id != CODEC_ID_PROBE){\n                    pd->buf_size=0;\n                    av_freep(&pd->buf);\n                    av_log(s, AV_LOG_DEBUG, \"probed stream %d\\n\", st->index);", "idx": 5146, "substitutes": {"s": ["p", "conf", "https", "times", "l", "self", "uploads", "ains", "ns", "sq", "ses", "gs", "y", "stats", "results", "xs", "its", "ims", "c", "aps", "n", "qs", "z", "eps", "services", "S", "a", "ares", "sp", "r", "ps", "vs", "ins", "ctx", "w", "less", "ss", "h", "j", "changes", "js", "b", "http", "sts", "tags", "ts", "ads", "has", "bits", "fs", "args", "als", "series", "ats", "sys", "sports", "details", "is", "events", "aws", "bs", "styles", "ex", "sg", "rs", "ids", "m", "summary", "cs", "as", "terms", "ls", "ags", "t", "os", "ds", "ms", "v", "spec", "comm", "hs", "these", "ssl", "g", "es", "utils", "sv", "parts", "sw"], "pkt": ["dppt", "pkg", "dpet", "opkt", "perkt", "wpvc", "Packet", "pct", "proacket", "respshot", "ppelt", "Pwk", "fett", "payvc", "apacket", "ppet", "fkt", "expqt", "apet", " pkg", "pck", "wpett", "brshot", "wpkt", "upkg", "packkt", "respkt", "tpkg", " pvc", "packpt", "respkg", "prokg", "pet", "opunct", "fnt", "pingkg", "respacket", "peracket", "apkt", "ppt", "ppwk", "dpacket", "opacket", "perelt", "ppck", "upacket", "yett", "brqt", "dkt", "dacket", "expett", "pingacket", "welt", "yqt", " packet", "packacket", " pett", "payet", "pingkt", "tpkt", "apkg", "upunct", "dpkt", "Pet", "pqt", "perkg", "pett", "ppshot", "ppmsg", "pvc", "brkt", "pnt", "tpshot", "expshot", " pwk", "expkt", "Pnt", "Pett", "packet", " pet", "ppkg", "opkg", "wpet", "pppt", " pelt", "ppacket", "tpacket", "apnt", "payett", "brett", "ppct", "wkg", " pct", "prokt", "Pct", " pnt", "ykt", "pelt", " pck", "wacket", "pingelt", "Pkt", "dmsg", "pwk", "yshot", "ppkt", "pshot", "pmsg", "wkt", "facket", "dck", "punct", "apunct", "paykt", " pmsg", "upkt", "proelt", "ppnt"], "ret": ["deg", "pet", "out", "t", "fail", "reset", "inter", "gt", "elt", "tf", "nil", "RET", "rm", "arg", "att", "r", "re", "nt", "cont", "arr", "Ret", "it", "fin", "ft", "hash", "error", "not", "Return", "rets", "txt", "red", "str", "val", "fun", "j", "prot", "rem", "ez", "empty", "xt", "mt", "resp", "def", "result", "pret", "at", "nz", "rev", "ber", "ref", "zero", "len", "iter", "print", "jp", "res", "det", "after", "tr", "ter", "ert", "flag", " RET", " Ret", "rt", "alt", "err", "cmd"], "i": ["t", "li", "p", "bound", "sim", "ki", "bi", "id", "ind", "v", "ii", "l", "ini", "mi", "ix", "it", "ic", "gu", "hi", "uri", "si", "k", "oi", "j", "di", "gi", "ri", "in", "chain", "ip", "index", "info", "ui", "multi", "iu", "ij", "y", "ir", "zi", "xi", "ci", "ti", "m", "ai", "pi", "im", "ims", "x", "I", "phi", "qi", "c", "cli", "us", "n", "mc", "batch"], "st": ["ST", "ust", "stage", "sc", "dr", "t", "elt", "irst", "art", "th", "td", "tmp", "tt", "bt", "dest", "sp", "nt", "ut", "put", "ost", "sta", "stable", "inst", "obj", "str", "set", "ld", "ist", "kt", "se", "ast", "pt", "mt", "ste", "usr", "est", "stop", "sh", "std", "step", "at", "sts", "store", "rest", "ts", "sn", "end", "stat", "storage", "test", "ct", "must", "nd", "src", "St", "start", "rt", "stru", "stream", "sw"], "pktl": [" pwdls", "pktll", "pntls", "pktls", "pktln", "peltlb", "prqtli", "pqtle", " pwdl", "pktla", "packetlt", "prktls", "pktle", "pqtli", "pwklb", "prktli", "spktli", " pcmdls", "pcmdls", "proktln", "spktlt", "proktli", "pktfl", "expwkl", "expktla", "pderli", "pderl", "pactl", "prktl", "packetli", "pqtl", "puxle", " pwdll", "petL", " pktlc", "phpkwl", " pcmdln", "phpktfl", "pactL", "peltlc", "packetln", "pwklc", "pttli", "proactL", "expktlc", "pkgl", "pactln", "pktlt", "pntl", " pktln", "phpkwfl", "pqtls", "pckl", "pcmdln", "pttl", " pcmdli", "pwdlc", "petli", " pktls", "punctlc", "prentln", "pcmdli", "petln", "petls", "spptl", "prqtle", "peltl", "phpkwlp", "pptl", "phpktle", "pkwle", "expktlb", "pderlt", "phpktl", "peltla", "pckfl", "prqtl", "proktL", "pptlt", "pderln", "spptlt", "pkwfl", " pcmdl", "pkglc", "pkgls", "prentL", " pwdlc", "pktli", "pktlb", "pktlc", "proactl", "pckle", "pwkla", "expwklb", "punctl", "ptxtle", "pkwl", "pactli", "punctlb", "petl", "prqtls", "pttls", "pttln", "pptln", "ptxtli", "puxlp", "pwkll", "pptli", "pktL", "puxl", "pkwlp", "pwkl", "pkgll", "proactln", "pntli", "punctla", "expktl", "ptxtls", "packetl", "expwkla", "pwdl", "expwklc", "spptln", "pntle", "proactli", "spktln", "pwkls", "phpkwle", "ptxtl", "spptli", " pktli", "pktlp", "spktl", "puxfl", " pktll", "prktle", "pcklp", "pwdls", "phpktlp", "pcmdl", "pwdll", "prentl", "prentli", "proktl"], "pd": ["hd", "dj", "pp", "p", "dt", "rpm", "td", "ds", "lp", "od", "d", "ped", "ps", "fd", "dd", "cd", "edd", "pes", "PD", "pm", "ld", "ud", "dl", "dn", "dat", "sd", "gd", "dh", "np", "pdf", "wd", "po", "md", "pb", "pard", "vd", "tp", "dp", "pat", "xd", "pl", "xx", "tk", "ecd", "ctl", "bd"], "probe_packets": ["probe_presens", "probe_pageseters", "probe_pagesets", "probe_pet", "probe_buffeters", "probe_packeters", "probe_pETS", "probe_framesETS", "probe_buffet", "probe_framesens", "probe_pets", "probe_pagesens", "probe_packETS", "probe_framesets", "probe_messet", "probe_pens", "probe_buffens", "probe_packet", "probe_presets", "probe_messETS", "probe_preset", "probe_pageset", "probe_packens", "probe_buffets", "probe_messets", "probe_frameset", "probe_preseters", "probe_messens"]}}
{"project": "qemu", "commit_id": "df8ad9f128c15aa0a0ebc7b24e9a22c9775b67af", "target": 1, "func": "static int nbd_can_accept(void)\n\n{\n\n    return nb_fds < shared;\n\n}\n", "idx": 5171, "substitutes": {}}
{"project": "qemu", "commit_id": "b4f72e31b924bec2c18fe0b2a8c6462dbed9dcb2", "target": 1, "func": "static int net_connect(struct XenDevice *xendev)\n\n{\n\n    struct XenNetDev *netdev = container_of(xendev, struct XenNetDev, xendev);\n\n    int rx_copy;\n\n\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"tx-ring-ref\",\n\n                             &netdev->tx_ring_ref) == -1) {\n\n        return -1;\n\n    }\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"rx-ring-ref\",\n\n                             &netdev->rx_ring_ref) == -1) {\n\n        return 1;\n\n    }\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"event-channel\",\n\n                             &netdev->xendev.remote_port) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"request-rx-copy\", &rx_copy) == -1) {\n\n        rx_copy = 0;\n\n    }\n\n    if (rx_copy == 0) {\n\n        xen_be_printf(&netdev->xendev, 0, \"frontend doesn't support rx-copy.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,\n\n                                          netdev->xendev.dom,\n\n                                          netdev->tx_ring_ref,\n\n                                          PROT_READ | PROT_WRITE);\n\n    netdev->rxs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,\n\n                                          netdev->xendev.dom,\n\n                                          netdev->rx_ring_ref,\n\n                                          PROT_READ | PROT_WRITE);\n\n    if (!netdev->txs || !netdev->rxs) {\n\n        return -1;\n\n    }\n\n    BACK_RING_INIT(&netdev->tx_ring, netdev->txs, XC_PAGE_SIZE);\n\n    BACK_RING_INIT(&netdev->rx_ring, netdev->rxs, XC_PAGE_SIZE);\n\n\n\n    xen_be_bind_evtchn(&netdev->xendev);\n\n\n\n    xen_be_printf(&netdev->xendev, 1, \"ok: tx-ring-ref %d, rx-ring-ref %d, \"\n\n                  \"remote port %d, local port %d\\n\",\n\n                  netdev->tx_ring_ref, netdev->rx_ring_ref,\n\n                  netdev->xendev.remote_port, netdev->xendev.local_port);\n\n\n\n    net_tx_packets(netdev);\n\n    return 0;\n\n}\n", "idx": 5172, "substitutes": {"xendev": ["exendek", "xendingeps", "xbeginee", "wendedev", "xstartev", " xnddev", "xenterev", "xentee", "xentel", "xenteg", "xendsel", " xendef", " xendee", "xEndec", "xEndek", "xentdev", "oxendDev", "xendsev", "xendedef", "xenteman", "xnderv", "xfindev", "exendeg", "xendedDev", "xestec", "exentel", "wxentev", "xendererv", "oxbeginee", "myenddev", "xendserv", "xndiver", "wendediver", "exendoc", "xendingel", "wxendov", "xendew", "xENDdev", "xentDev", "oxbegindev", "xenev", "wendev", "wendeddev", "xenterv", "wxentel", "xndesc", "zendew", "xenerv", "xentew", "xentec", " xndef", "zendedew", "wenerv", "xbegindev", "xnddev", "exentev", "xendedee", "xentiv", "xendingDev", "axendeps", "xendedel", "xendeg", "xbeginev", "xendoc", "xndef", "wxenteman", "xendingdev", "xbeginel", "xendDev", "xenddev", "exentserv", "xndeg", "xendederv", "myendingel", "exentec", "xestek", "xendef", "xstartdev", "exendiver", "xenee", "xenedev", "xeneddev", "wendiver", "oxendev", "exentiv", "oxbeginev", "myendingdev", "xenedef", "axendev", "xfindov", "xstarterv", "exentdev", "exendel", "zendedeg", " xenddev", "xENDev", "xenderev", "xentek", "xentereps", "wxentov", "xndee", "xendeman", "xbeginoc", "xendel", "exendserv", "exenddev", "xendedesc", "exentoc", "xndiv", "xenteps", "wenderv", "exenterv", " xndiv", "xendek", " xendiv", "xeddev", "xndev", "xederv", "xfindel", "xendedserv", "wenev", "myendingev", "xeniv", "zendev", "myendingiver", "exentiver", "xendsov", "xentiver", "exendev", "xfindeman", "wxendeman", "xediver", "xENDerv", "zendeddev", "xendeev", "xndDev", "xendseman", " xendesc", "wenddev", "axendingDev", "exenteg", "xendov", "xbeginserv", "oxbeginDev", "exentek", "xendedev", "xendedeg", "zendedev", " xndee", "xendingiv", "xendec", "xEnddev", "xENDek", "xestiv", "axenddev", "xenterDev", "xenderv", "xndew", "xendiver", " xndesc", "xentov", "xendedoc", "xenterdev", "exenderv", "xentev", "wendederv", "wxendel", "axendDev", "exendiv", "xbeginDev", "myendiver", "xendingiver", "xbegineg", "xendeps", "xentoc", "axendingev", "oxendee", "zendeg", "exendec", "xEndev", "xendiv", "xendedew", "xedev", "wxendev", "axendingdev", "xendeerv", "xestev", "zenddev", "xendee", "xendesc", "axendingeps", "xentserv", "myendel", "xendeddev", "xendingev", "xestdev", "myendev", "xenedesc", "xendediver", " xndev", "xestiver", "oxenddev"], "netdev": ["networkdriver", "enpriv", "plaingu", "NETdev", "netDev", "etcam", " netDEV", "networkdebug", "netdiv", "netcam", "munenv", " netcam", "netval", "totalvalid", "natdiv", "plaindevice", "etdevice", "potcam", "natve", "matcam", "netsdevice", "batdev", "webgu", "potvalid", "notepriv", "plainve", "ntdiv", "motdebug", "nerdev", "mungu", "mondev", "endev", "noteDEV", "plainvalid", "natdev", "plaindev", "networkdev", "networkserv", "endevice", "netdata", "natgo", "potgu", "natev", "networkbuild", "natcam", "webserv", "notedev", "webdraw", " netdebug", "ntdevice", " netDev", " netvalid", "netdraw", "webver", "nutserv", "neDEV", "motvalid", "matver", "networkdevice", "connDEV", " netpriv", "networkvar", "NETdata", "conndevice", "networkdiv", "netdriver", "nerprop", "networkval", "netsev", "netsdevelop", "networkvalid", "conndev", "nepad", "plaingo", "netev", "nedevice", "matev", "netvalid", "batDev", " netserv", "batver", "networkdraw", "netver", "potdev", "batvalid", "nutdevice", "networkgo", "webpriv", "potprop", "netserv", "etvar", " netver", "notedevice", "netgo", "netgu", "nerdevice", "nerdebug", "matdev", "nerDev", "networkDev", "netdevice", "matgu", "networkev", "netvar", "mondevice", "networkcam", " netpad", "mundevice", "nutpriv", "nutDEV", "etdev", "nutDev", "webgo", "nerev", "netsdebug", "potver", "webdev", "NETdevice", "etgo", "matDev", "matve", "nedev", "netscam", "plaindebug", "plainev", "nextdev", "networkpriv", "motdev", "nerserv", "netpriv", "etenv", "matval", "netsdev", "connbuild", "ntver", "monpad", "enval", "NETcam", "webev", "nextgo", "netdevelop", "networkdevelop", "ntdriver", "totalval", "netsvalid", "networkdata", "netDEV", " netgo", "networkver", "webdevice", "netsgo", "netprop", "nerve", "networkDEV", "totaldev", "netpad", "etvalid", "motev", " netdevice", "netsver", "webcam", "natprop", "plaindraw", "nextdevice", "webenv", "netbuild", "natdevelop", "webDEV", "ntdev", "potve", "etdiv", " netdiv", " netdata", "nercam", "matvalid", "totalev", " netbuild", "netenv", "netdebug", "potev", "webval", "monDEV", "natvar", "nextvalid", "mundev", "potDev", " netdriver", "nutdev", "etgu", "netve", "nerpriv"], "rx_copy": ["rxmycopy", "tx_parent", "rx___copy", "rx___cop", "rx___co", "tx_copy", "rx_clone", "tx_map", "rxlogmap", "rf_co", "rx_co", "rx_clip", "rx_parent", "rf_cop", "rx_map", "ry_clone", "rxlogcop", "ry_match", "tx_clip", "rxlogcopy", "tx_ready", "rxmyready", "rx_ready", "rx___skip", "rxmyclip", "rf_copy", "rxlogclone", "ry_clip", "tx_cop", "rx_skip", "rx_cop", "rf_skip", "tx_clone", "ry_copy", "rxmyparent", "rx_match"]}}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "static bool do_modify_softint(CPUSPARCState *env, uint32_t value)\n\n{\n\n    if (env->softint != value) {\n\n        env->softint = value;\n\n#if !defined(CONFIG_USER_ONLY)\n\n        if (cpu_interrupts_enabled(env)) {\n\n\n            cpu_check_irqs(env);\n\n\n        }\n\n#endif\n\n        return true;\n\n    }\n\n    return false;\n\n}", "idx": 5174, "substitutes": {"env": ["entry", "vp", "doc", "query", "environment", "cv", "conn", "gov", "priv", "esc", "v", "ec", "vs", "worker", "ctx", "policy", "eg", "qv", "enter", "txt", "cb", "vv", "obj", "server", "ext", "ew", "en", "req", "nv", "era", "here", "cur", "forge", "rb", "ee", " environment", "emb", "ah", "NV", "walker", "manager", "cap", "e", "end", "cfg", "db", "erd", "engine", "sv", "ov", "hw", "window", "desc", "Environment", "qt", "ef", "EN", "cal", "timer", "block", "er", "ev", "viron", "err", "uv"], "value": ["key", "hello", "VAL", "max", "weight", "v", "data", "error", "field", "address", "val", "description", "ve", "package", "attribute", "time", "size", "state", "index", "name", " Value", "current", "input", "property", "fee", "type", "buffer", "new", "status", "code", "variable", "instance", "unit", "values", "operator", "test", "VALUE", "Value", "initial", "expression", "update", "create", "total", "V", "widget"]}}
{"project": "FFmpeg", "commit_id": "9af6abdc17deb95c9b1f1d9242ba49b8b5e0b016", "target": 1, "func": "static int decodeTonalComponents (GetBitContext *gb, tonal_component *pComponent, int numBands)\n\n{\n\n    int i,j,k,cnt;\n\n    int   components, coding_mode_selector, coding_mode, coded_values_per_component;\n\n    int   sfIndx, coded_values, max_coded_values, quant_step_index, coded_components;\n\n    int   band_flags[4], mantissa[8];\n\n    float  *pCoef;\n\n    float  scalefactor;\n\n    int   component_count = 0;\n\n\n\n    components = get_bits(gb,5);\n\n\n\n    /* no tonal components */\n\n    if (components == 0)\n\n        return 0;\n\n\n\n    coding_mode_selector = get_bits(gb,2);\n\n    if (coding_mode_selector == 2)\n\n\n\n\n    coding_mode = coding_mode_selector & 1;\n\n\n\n    for (i = 0; i < components; i++) {\n\n        for (cnt = 0; cnt <= numBands; cnt++)\n\n            band_flags[cnt] = get_bits1(gb);\n\n\n\n        coded_values_per_component = get_bits(gb,3);\n\n\n\n        quant_step_index = get_bits(gb,3);\n\n        if (quant_step_index <= 1)\n\n\n\n\n        if (coding_mode_selector == 3)\n\n            coding_mode = get_bits1(gb);\n\n\n\n        for (j = 0; j < (numBands + 1) * 4; j++) {\n\n            if (band_flags[j >> 2] == 0)\n\n                continue;\n\n\n\n            coded_components = get_bits(gb,3);\n\n\n\n            for (k=0; k<coded_components; k++) {\n\n                sfIndx = get_bits(gb,6);\n\n\n\n                pComponent[component_count].pos = j * 64 + (get_bits(gb,6));\n\n                max_coded_values = SAMPLES_PER_FRAME - pComponent[component_count].pos;\n\n                coded_values = coded_values_per_component + 1;\n\n                coded_values = FFMIN(max_coded_values,coded_values);\n\n\n\n                scalefactor = ff_atrac_sf_table[sfIndx] * iMaxQuant[quant_step_index];\n\n\n\n                readQuantSpectralCoeffs(gb, quant_step_index, coding_mode, mantissa, coded_values);\n\n\n\n                pComponent[component_count].numCoefs = coded_values;\n\n\n\n                /* inverse quant */\n\n                pCoef = pComponent[component_count].coef;\n\n                for (cnt = 0; cnt < coded_values; cnt++)\n\n                    pCoef[cnt] = mantissa[cnt] * scalefactor;\n\n\n\n                component_count++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return component_count;\n\n}", "idx": 5190, "substitutes": {"gb": ["py", "gm", "gz", "bn", "gt", "ian", "bt", "goo", "gc", "rg", "gs", "vm", "db", "uf", "ch", "bm", "hub", "eg", "vg", "ruby", "phy", "buff", "gd", "b", "def", "pb", "Gb", "mg", "gnu", "GB", "bits", "storage", "csv", "sb", "gif", "nb", "fb", "cb", "bs", "mb", "sg", "gh", "Int", "bg", "gg", "and", "_", "bf", "img", "html", "cv", "pg", "bb", "g", "kb", "wm", "cfg", "tg", "yg", "rb", "wb"], "pComponent": [" pChild", "phpComponent", "mCell", "tComp", "PComponent", "podComp", "pFrame", "mComp", " pInstance", "pComp", "phpInstance", " pFrame", "pCell", "mComponent", "cpComp", "PComp", "tFrame", "tChild", "podComponent", "tComponent", "cpParameter", "podMember", "pChild", "pInstance", "pMember", "pParameter", "phpParameter", "mMember", "phpComp", "podCell", "PFrame", "PChild", " pMember", "cpComponent", "cpInstance", " pCell", " pComp", " pParameter"], "numBands": ["numBanded", " numBrounds", " numBrards", "numCBounds", "numBonds", "numRodes", "numBRards", "numBRomes", "numBards", "numBasks", "numEBards", " numBounds", "numEBounds", "numBrards", "numEBands", "numRounds", " numBonds", "numBrands", "numCBands", "numCasks", " numBanded", "numBodes", "numCBanded", " numBards", "numCands", "numCanded", "numRonds", " numBasks", " numBodes", "numBRands", "numBromes", "numBrounds", "numCBasks", " numBrands", "numEBomes", "numBrodes", "numBounds", " numBromes", "numBRounds", "numRands", "numBronds", "numBomes", "numCounds", " numBomes"], "i": ["ia", "p", "sim", "ki", "bi", "ind", "v", "ii", "ini", "mi", "ix", "it", "ic", "asi", "si", "di", "h", "io", "in", "ie", "ip", "b", "index", "ui", "multi", "iu", "ij", "y", "xi", "zi", "e", "ci", "ti", "m", "ami", "ik", "ai", "pi", "im", "ims", "x", "I", "phi", "us", "c", "ni", "n", "by", "u", "out"], "j": ["bo", "json", "fr", "key", "dj", "p", "jac", "ch", "ian", "bj", "el", "jj", "v", "ind", "ii", "col", "jl", "it", "kid", "q", "jc", "obj", "str", "aj", "jo", "h", "br", "o", "ji", "js", "jump", "b", "index", "oj", "adj", "g", "pr", "ij", "y", "kj", "jp", "uj", "m", "try", "tr", "ja", "job", "jit", "x", "J", "c", "n", "pos", "z", "out"], "k": ["ka", "key", "kh", "ke", "p", "K", "ki", "sk", "mk", "kk", "kr", "v", "uk", "ikk", "ark", "kid", "q", "ask", "ks", "unk", "wk", "ku", "km", "dk", "kt", "kind", "ok", "kl", "ijk", "kj", "acc", "ck", "m", "ko", "ik", "ek", "ak", "tk", "kw", "kick", "n", "context", "z"], "cnt": ["cuount", "colnc", " cNT", "cuct", "cNT", "cpt", "cstant", "ucnt", "secNT", "conNT", " cpt", "cunt", " cwd", "secpt", "crnt", "ucnz", "cnz", "Cstant", "conount", "crt", "crnz", "colnt", "compnt", "Cpt", "compwd", "Cot", "curt", "cct", "crpt", "ucpt", "compNT", "crnc", "colrt", "compot", "cot", " cstant", "Cnt", " cnc", "cwd", "cnc", "connt", " crt", "CNT", "conrt", "secnt", "secstant", "colNT", " cnz", "ucnc", "conct", "Crt", "count", " cct", "Cwd", "connc", "Cnc", " cot", " count"], "components": ["compaints", "comensions", "configidates", "comorts", "ompaints", "Components", "comports", "configutes", "contodes", "ompensions", "comonents", "commarts", "compensions", "proances", "conents", "omponents", "contorts", "compances", "commonents", "carts", "commodes", "configarts", "Compands", "commutes", "compients", " compances", "compands", "ompients", "proients", "cients", "caints", "commorts", "contonents", "comodes", "Compaints", "configonents", "contensions", " compands", "commensions", "proonents", "cidates", "censions", " compients", "cutes", "commidates", "Compients", "comparts", "Compances", "computes", "compodes", "Compensions", "compidates", "proands"], "coding_mode_selector": ["coding_mode_lectutor", "coding_mode_selectoring", "coding_mode_connectator", "coding_mode_motors", "coding_mode_motOR", "coding_mode_lectors", "coding_mode_collector", "coding_mode_connectOR", "coding_mode_selectensor", "coding_mode_successoring", "coding_mode_selectractor", "coding_mode_Selectoring", "coding_mode_Selector", "coding_mode_successor", "coding_mode_Selectractor", "coding_mode_motor", "coding_mode_selectors", "coding_mode_connectlor", "coding_mode_motractor", "coding_mode_connector", "coding_mode_collectoring", "coding_mode_Selectutor", "coding_mode_lectensor", "coding_mode_connectutor", "coding_mode_Selectlor", "coding_mode_electors", "coding_mode_Selectors", "coding_mode_electensor", "coding_mode_collectors", "coding_mode_elector", "coding_mode_electlor", "coding_mode_successors", "coding_mode_lector", "coding_mode_selectOR", "coding_mode_Selectator", "coding_mode_connectors", "coding_mode_selectlor", "coding_mode_SelectOR", "coding_mode_selectutor", "coding_mode_selectator", "coding_mode_lectOR", "coding_mode_Selectensor", "coding_mode_electOR", "coding_mode_lectator"], "coding_mode": ["coder_settings", "coding_metadata", "coding_option", "coding_side", "coding___method", "coder_type", "coder_method", "coder_option", "coder_metadata", "codingThemode", "codingisttype", "coding_settings", "codingThesettings", "coder_side", "coding___side", "coding_type", "codingistoption", "coding___mode", "coder_mode", "codingThetype", "coding_method", "codingistmetadata", "coding___type", "codingistmode"], "coded_values_per_component": ["coded_values_per64part", "coded_values_per2sample", "coded_values_Per_comp", "coded_values_per_channel", "coded_values_PER_part", "coded_values_Per_frame", "coded_values_PER_channel", "coded_values_per_part", "coded_values_per_comp", "coded_values_per2component", "coded_values_Per_component", "coded_values_PER_component", "coded_values_PER_frame", "coded_values_per_sample", "coded_values_Per_sample", "coded_values_per64frame", "coded_values_PER_sample", "coded_values_per64sample", "coded_values_per_frame", "coded_values_per64component", "coded_values_per2comp", "coded_values_per2frame"], "sfIndx": ["sfindx", "sfIndex", "sfIdix", "SFIndex", "SFindix", "sbIdx", "sfindX", "SFindX", "sfindy", "sfINDx", "sfINDix", "sfIndexex", "sfIdy", "sfINDX", "sfindex", "sfindix", "SFindex", "sfIndy", "sfIdex", "SFindx", "sfIndexx", "sfIndexix", "sbIndix", "SFIndix", "sfIndX", "sfIndix", "sfINDex", "sbIndy", "sbIdix", "sbIndex", "sfIdX", "sfIndexy", "sfIdx", "sbIdex", "sbIdy", "SFIndX", "SFIndx", "sbIndx"], "coded_values": ["cod_values", "coded_value", "oded_times", "cod_vals", "oded_value", "oded_values", "coded_states", "oded_codes", "oded_models", "coded_maps", "codedThestates", "codedThevalues", "coded_files", "oded_files", "coded_models", "oded_vals", "codedThetimes", "cod_maps", "oded_states", "codedThefiles", "coded_times", "coded_vals", "coded_codes"], "max_coded_values": ["max_oded_parts", "max_oded_values", "max_oded_lines", "max_coded_rows", "max_coded__values", "max_coded_parts", "max_codededbytes", "max_oded_bytes", "max_coded__value", "max_oded_value", "max_codedJbytes", "max_codedJparts", "max_coded_bytes", "max_codededparts", "max_coded__codes", "max_coded_codes", "max_oded_codes", "max_codedJvalues", "max_coded_value", "max_oded_rows", "max_coded_lines", "max_codededvalues", "max_coded__lines"], "quant_step_index": ["quant_step_i", "quant_step2index", "quant_step2Index", "quant_step_id", "quant_Step_size", "quant_step_size", "quant_Step_Index", "quant_Step_ind", "quant_step_position", "quant_step_ind", "quant_Step_i", "quant_Step_length", "quant_Step_index", "quant_Step_id", "quant_step2ind", "quant_Step_position", "quant_step_length", "quant_step2size", "quant_step_Index"], "coded_components": ["coded_corees", "coded_chorts", "coded_chices", "coded_compients", "coded_comrees", "coded_compounds", "coded_commients", "coded_comounds", "coded_comprees", "coded_comices", "coded_Compices", "coded_Components", "coded_comparts", "coded_comonents", "coded_commonents", "coded_comorts", "coded_compices", "coded_appients", "coded_chonents", "coded_apponents", "coded_commorts", "coded_chounds", "coded_comients", "coded_appsarts", "coded_coients", "coded_apparts", "coded_appices", "coded_coorts", "coded_appsices", "coded_commrees", "coded_Comports", "coded_coonents", "coded_comarts", "coded_Compounds", "coded_appsonents", "coded_appsients", "coded_comports"], "band_flags": ["Band_styles", "band_options", "Band_groups", "band_Flags", "band_groups", "bandlyflag", "Band_options", "band__flags", "bandlyflags", "bandlygroups", "band__styles", "Band_properties", "band_flag", "Band_flags", "band__flag", "bandlyFlags", "Band_mask", "bandlyoptions", "Band_Flags", "band_properties", "band_mask", "Band_flag", "band_styles", "band__mask", "bandlyproperties"], "mantissa": ["Maintissa", "Maintitude", "mantsitude", "motitude", "mantitude", "mantsiate", "Maintice", "maintitude", "Mantice", "Mantissa", "motice", "motissa", "mantsissa", "motiate", "Mantitude", "Mantiate", "mantsice", "maintissa", "maintice", "maintiate", "Maintiate", "mantiate", "mantice"], "pCoef": ["pcCffe", "pCoeff", "pcCoef", "pCef", "pSeffe", "pcCoffe", "pcCef", "pcCoec", "pCffe", "pCec", "pCaleff", "pSeef", "pCalffe", "pSeeff", "pCalec", "pcCec", "pcCeff", "pCoec", "pCoffe", "pCeff", "pcCoeff", "pCalef", "pSeec"], "scalefactor": ["scalleffactor", "scalepfactor", "scalelfract", "scalelfact", "scaleffactor", "scalelfunc", "scalelffactor", "sccalelfunc", "scalepract", "sccalelfactor", "scallefactor", "sccalelfract", "scaleffract", "sccalefract", "scallefunc", "scalleffunc", "scalafunc", "scalefunc", "scallefort", "scalefort", "scalefffactor", "scallefact", "scalafactor", "scalafact", "sccalefactor", "scalepunc", "scalefact", "sccalefunc", "sccalelffactor", "scalleffort", "scalepactor", "scaleffort", "scaleffact", "scaleffunc", "scalelfactor", "scalafort", "scalleffact", "scalefract", "scalelfort", "sccaleffactor"], "component_count": ["module_type", "componentNamenum", " component2index", "chipitykey", "module_start", "component_spec", "chip_count", "componentNamecount", " component2count", " component_index", "chipitycount", " component_length", "component_key", "chip_info", "component2num", "component_type", "componentityspec", " component_num", "module_num", "moduleNamecount", "module_count", "componentitynum", " component2num", "component2count", "componentNamestart", "componentitycount", "chipityspec", "chip_key", "componentNametype", "component_length", "chipityinfo", "componentitykey", "component_index", "chip_spec", "component2length", "componentitystart", "componentityinfo", " component2length", "moduleNametype", "component_num", "moduleNamenum", "component_info", "moduleNamestart", "component2index", "componentitytype", "component_start"]}}
{"project": "qemu", "commit_id": "3401c0d95ffb9a9a57093ee002d24d014ffed4f8", "target": 1, "func": "static void do_send_key(const char *string)\n\n{\n\n    char keybuf[16], *q;\n\n    uint8_t keycodes[16];\n\n    const char *p;\n\n    int nb_keycodes, keycode, i;\n\n\n\n    nb_keycodes = 0;\n\n    p = string;\n\n    while (*p != '\\0') {\n\n        q = keybuf;\n\n        while (*p != '\\0' && *p != '-') {\n\n            if ((q - keybuf) < sizeof(keybuf) - 1) {\n\n                *q++ = *p;\n\n            }\n\n            p++;\n\n        }\n\n        *q = '\\0';\n\n        keycode = get_keycode(keybuf);\n\n        if (keycode < 0) {\n\n            term_printf(\"unknown key: '%s'\\n\", keybuf);\n\n            return;\n\n        }\n\n        keycodes[nb_keycodes++] = keycode;\n\n        if (*p == '\\0')\n\n            break;\n\n        p++;\n\n    }\n\n    /* key down events */\n\n    for(i = 0; i < nb_keycodes; i++) {\n\n        keycode = keycodes[i];\n\n        if (keycode & 0x80)\n\n            kbd_put_keycode(0xe0);\n\n        kbd_put_keycode(keycode & 0x7f);\n\n    }\n\n    /* key up events */\n\n    for(i = nb_keycodes - 1; i >= 0; i--) {\n\n        keycode = keycodes[i];\n\n        if (keycode & 0x80)\n\n            kbd_put_keycode(0xe0);\n\n        kbd_put_keycode(keycode | 0x80);\n\n    }\n\n}\n", "idx": 5191, "substitutes": {"keybuf": ["Keybuf", "callbuff", "skybag", "keyscodes", "callbuffer", "netcb", "Keycb", "netbuf", "Keypad", "keybuff", "phrasebuff", "charcmd", "KEYbuf", " keycmd", "wordbuf", "phrasepad", "skybuf", "charbuf", " keybuff", "keybag", "keysbuffer", " keybuffer", "skybuffer", "keycmd", "KEYbuffer", "charcb", "netcodes", "wordbuff", "phrasebuf", "callcodes", "netcmd", "keycb", "keybuffer", "Keybuff", "charcodes", "wordbuffer", "Keycode", "KEYcb", "charcode", "Keybuffer", "phrasecode", "keysbuf", "Keybag", " keybag", "charbuffer", " keypad", "wordcode", " keycb", "keysbuff", "callbuf", "KEYbuff", "keypad", "charbuff"], "q": ["t", "query", "pp", "qual", "cp", "ch", "pkg", "qq", "f", "a", "v", "quant", "Q", "qv", "k", "dq", "ue", "j", "qu", "pt", "quer", "iq", "eq", "quote", "ip", "b", "sq", "que", "g", "buf", "buffer", "aq", "quit", "qa", "qi", "qt", "c", "queue", "pe", "qs", "n", "z", "u"], "keycodes": ["Keybuf", "keylines", "activecodes", "keycases", "keynames", " keycache", " keyobjects", "aircases", "readcod", " keycod", "eyobjects", "playcod", "Keycache", "keycod", "activecases", "linkcases", " keylines", "Keycod", "linkcod", "airbuf", "aircod", "activecod", "Keynames", "activebuf", " keynames", "Keyodes", "playnames", "keycache", "linkbuf", "eycache", "keyodes", " keyodes", "playbuf", "playcodes", "keyobjects", "readcodes", "Keyobjects", "eycodes", "eyodes", "aircodes", "readodes", "linkcodes", "Keycodes", "Keylines", "readlines"], "p": ["pp", "t", "cp", "pkg", "f", "d", "l", "v", "sp", "r", "ps", "pc", "path", "post", "ping", "pg", "prefix", "piece", "wp", "w", "str", "pa", "pro", "j", "h", "port", "pad", "php", "pt", "ip", "ap", "b", "pointer", "par", "point", "g", "pb", "pr", "pers", "pard", "y", "fp", "tp", "jp", "pat", "m", "pair", "pen", "P", "parse", "part", "pl", "pi", "pid", "c", "pod", "s", "pos", "n", "pe", "u", "pre"], "nb_keycodes": ["nb_checkboards", "nbJcheckboards", "nb_noteboards", "nb_firetags", "nb_condbooks", "nb_condodes", "nb_keyscode", "nb_keysvalues", "nb_kemaps", "nb_firecodes", "nb_keyodes", "nb_hashodes", "nb_checkcode", "nb_keybooks", "nbJkeyodes", "nb_notevalues", "nb_firebooks", "nbJcheckodes", "nb_keymaps", "nb_keyvalues", "nb_charodes", "nb_keytags", "nb_checkodes", "nbJkeyboards", "nb_popbooks", "nb_popodes", "nbJkeycode", "nb_readlines", "nb_readmaps", "nbJcheckcodes", "nb_notelines", "nbJcheckcode", "nb_keyslines", "nb_charlines", "nb_keylines", "nb_kecodes", "nb_notemaps", "nb_keystyles", "nb_noteodes", "nb_poptags", "nb_charvalues", "nb_keycode", "nb_keyscodes", "nb_hashlines", "nb_hashcodes", "nb_keysstyles", "nb_condtags", "nb_charcodes", "nb_keysboards", "nb_keysmaps", "nb_fireodes", "nb_kelines", "nb_kestyles", "nb_notecode", "nb_condcodes", "nb_readstyles", "nb_hashmaps", "nb_notecodes", "nb_popcodes", "nb_keyboards", "nb_readcodes", "nb_checkcodes", "nb_keysodes", "nbJkeycodes"], "keycode": ["condframe", "eyframe", "keyclass", "keycat", "querycode", "condcode", " keycat", "kvalue", "posecat", "KeyCode", "Keystroke", "posestroke", "bycondition", "aircod", "Keycoded", "ycondition", "yvalue", "lockcode", " keyvalue", "keycache", "xcode", "ycoded", "lockcod", "ycoe", "kstroke", " keyframe", "xcoded", "cyclass", "condcoe", "ysee", "eycode", "firecode", "keycomment", "byline", "kce", " keytry", "eyce", " keycoe", " keystroke", " keyline", "keyframe", "cycode", "keyvalue", "yline", "playcode", "airsee", " keycondition", "charce", "charcode", "locklink", "charcard", "bycod", "bycode", "firestroke", "cycomment", "querycache", "querycoded", "xstroke", "querystroke", "bytetry", "kcard", "posecode", "playcard", " keycod", "notecode", "jsoncomment", "aircode", "firecat", "jsonsee", "locksee", "firecache", "keycoe", "kcache", "notecod", "cysee", "keytry", "yclass", "kcoded", "bytecode", "jsonclass", "xCode", "keysee", "jsoncode", "ycode", " keycache", "keyCode", "keycoded", " keyCode", "keycod", "kcoe", "bytestroke", "kcode", " keyce", "keycard", "notesee", " keycard", "posecache", "ycod", "keycondition", "playtry", "keylink", "keyline", "condce", "bytecard", "keystroke", "notelink", "airlink", "eycoe", "Keycode", "ycomment", " keycoded", "playstroke", "keyce"], "i": ["json", "init", "ei", "li", "ori", "ki", "fi", "bi", "is", "id", "ind", "ii", "ini", "mi", "ix", "me", "it", "list", "ic", "my", "\u0438", "hi", "uri", "si", "oi", "j", "di", "gi", "ri", "in", "ie", "ip", "chain", "iq", "ji", "index", "info", "slice", "ui", "multi", "iu", "ij", "ir", "xi", "zi", "iter", "remote", "ci", "ti", "this", "record", "m", "ami", "iri", "iy", "ai", "pi", "im", "ims", "qi", "I", "phi", "us", "cli", "mc"]}}
{"project": "qemu", "commit_id": "5d39c799c3245244ebb1e89da0177dbc089962b2", "target": 0, "func": "void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    double d;\n\n    char *ptr;\n\n    FdMigrationState *s;\n\n    const char *value = qdict_get_str(qdict, \"value\");\n\n\n\n    d = strtod(value, &ptr);\n\n    switch (*ptr) {\n\n    case 'G': case 'g':\n\n        d *= 1024;\n\n    case 'M': case 'm':\n\n        d *= 1024;\n\n    case 'K': case 'k':\n\n        d *= 1024;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    max_throttle = (uint32_t)d;\n\n    s = migrate_to_fms(current_migration);\n\n\n\n    if (s) {\n\n        qemu_file_set_rate_limit(s->file, max_throttle);\n\n    }\n\n    \n\n}\n", "idx": 5198, "substitutes": {"mon": ["util", "fn", "dm", "mons", "mi", "mu", "mp", "serv", "con", "Mon", "watch", "MON", " monitor", "dir", "manager", "mx", "bean", "m", "dog", "mm", "wat", "Mu", "Monitor", "on", "meter", "man", "mut", "monitor"], "qdict": ["dqdata", "qualdom", "qdb", "sqdata", "sqdom", " qobj", "sqobj", "qualdb", "sqmsg", "qmsg", "qconf", "sqdict", "qualdata", "qudict", " qconf", "dqdb", "qobj", "sqdb", "dqdict", "quconf", "qdom", "qumsg", "qdata", "quobj", "dqdom", "sqconf", "qualdict", " qmsg"], "ret_data": ["retrowdata", "return_content", "retregobj", "ret_obj", "return_data", "retregcontent", "return_obj", "ret_content", "retrowobj", "retrowcontent", "retregdata"], "d": ["p", " delta", " dr", " disp", " D", "mind", "q", "diff", "di", "dh", "dn", " dx", "dx", "c", "n", "z", "dev", "dm", "a", " dra", "dim", "r", "data", "done", "dd", "w", "j", "h", "dig", "dat", "D", "sd", "i", "did", "gd", "b", "dp", "pd", " diff", " del", "x", " dur", "dy", "f", "ind", "fd", "dc", " Dj", "depth", " done", " den", " dw", "e", "m", " det", "dis", "out", "dr", "t", "dt", "td", "ds", "v", "dra", "length", " dd", " dy", "g", "pos", " dist"], "ptr": ["dr", "p", "inter", "eth", "th", "tmp", "prime", "ctr", "ped", "ind", "sp", "arr", "ps", "length", "pc", "pointers", "address", "str", "inters", "req", "j", "pad", "vr", "pt", "attr", "vector", "proc", "pointer", "index", "Ptr", "pr", "rev", "ref", "tip", "tp", "ts", "iter", "iv", "pair", "tr", "pen", "addr", "tile", "test", "pl", "desc", "expr", "rob", "pos", "context", "hl"], "s": ["t", "os", "S", "p", "sports", "ds", "south", "f", "is", "a", "l", "v", "sp", "r", "ps", "spec", "ins", "sm", "sl", "w", "ss", "h", "j", "st", "o", "bs", "ns", "hs", "ssl", "b", "g", "socket", "sts", "rs", "gs", "su", "ts", "sn", "e", "es", "stats", "m", "fs", "sv", "cs", "sb", "c", "ls", "n", "sys", "still", "sw", "sa"], "value": ["key", "json", "vp", "v", "data", "image", "language", "field", "address", "str", "val", "ue", "description", "vr", "attribute", "result", "name", "current", "memory", "property", "type", "buffer", "text", "status", "sample", "content", "values", "sv", "VALUE", "Value", "sequence", "reference", "expression", "message", "widget"]}}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_efdneg(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);\n\n#else\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n", "idx": 5201, "substitutes": {"ctx": ["tc", "co", "pkg", "conn", "nt", "typ", "txt", "loc", "cur", "xs", "etc", "tx", "c", "wcs", "Context", "kw", "ctl", "nc", "mc", "cmd", "sc", "cm", "cp", "jac", "work", "wx", "obj", "crit", "kt", "ck", "kg", "pause", "context", "urg", "cu", "config", "ctr", "ind", "lc", "cb", "cl", "lex", "np", "today", "std", "kj", "ct", "aux", "ork", "unc", "warn", "cv", "tmp", "mk", "prefix", "inst", "cc", "abc", "req", "kl", "anc", "history", "resp", "act", "kb", "cmp", "jp", "cf", "cfg", "xc", "gp", "hw", "desc", "xp", "bc", "batch"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_srlq(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    TCGv t0 = tcg_temp_local_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    TCGv t2 = tcg_temp_local_new();\n\n    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);\n\n    tcg_gen_movi_tl(t1, 0xFFFFFFFF);\n\n    tcg_gen_shr_tl(t2, t1, t2);\n\n    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);\n\n    gen_load_spr(t0, SPR_MQ);\n\n    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_and_tl(t0, t0, t2);\n\n    gen_load_spr(t1, SPR_MQ);\n\n    tcg_gen_andc_tl(t1, t1, t2);\n\n    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);\n\n    gen_set_label(l2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t2);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n", "idx": 5219, "substitutes": {"ctx": ["tc", "gz", "p", "conf", "pkg", "conn", "nt", "loc", "self", "wd", "xs", "etc", "tx", "c", "wcs", "kw", "ctl", "nc", "mc", "cmd", "sc", "cm", "cp", "jac", " cx", "work", "wx", "scope", "check", "obj", "crit", "kt", "js", "ck", "kg", "x", "push", "context", "sys", "voc", "cu", "bh", "config", "ind", "cb", "cl", "lex", "np", "today", "std", "scl", "ct", "aux", "ka", "cv", "tmp", "prefix", "cc", "abc", "req", "wordpress", "dl", "kl", "history", "resp", "act", "cmp", "jp", "cf", "cfg", "xc", "addr", "hw", "expr", "xp", "bc", "batch"]}}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n\n{\n\n    VirtQueueElement elem;\n\n    VirtQueue *vq;\n\n\n\n    vq = vser->c_ivq;\n\n    if (!virtio_queue_ready(vq)) {\n\n        return 0;\n\n    }\n\n    if (!virtqueue_pop(vq, &elem)) {\n\n        return 0;\n\n    }\n\n\n\n    /* TODO: detect a buffer that's too short, set NEEDS_RESET */\n\n    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);\n\n\n\n    virtqueue_push(vq, &elem, len);\n\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n\n    return len;\n\n}\n", "idx": 5222, "substitutes": {"vser": ["nvSer", "nvicer", "vSer", " vSer", "svser", "nvcer", "svSer", "vcer", "Viter", "svsel", "Vtur", " vicer", "nvsoc", "svsec", "viciter", "svobj", "nvser", "svtur", " vobj", "Vsel", "viter", "svsoc", "vicser", "vicsel", "victur", "vobj", "vicer", "vtur", " vsec", "nvsec", "nvobj", " vsoc", "vsec", " vcer", "svcer", "vsel", "vsoc", "Vser", "svicer", "sviter"], "buf": ["doc", "bn", " buff", "cv", "bh", "fb", "msg", "txt", "cb", "Buffer", "br", "buff", "Buff", "mem", "bytes", "b", "bb", "pb", "cap", "buffer", "db", "bg", "raw", "vec", "uf", "seq", "queue", "bf", "bin", "cmd", "ob", "block", "box", "rb", " buffer", "img", "bc", "wb", "batch"], "len": ["t", " l", "compl", "elt", "syn", "el", "lp", "ll", "ln", "Len", "l", "le", "lf", "ind", "v", "nt", "length", "sp", "fin", "str", "val", "fun", "ld", "en", "h", "fl", "kl", "size", "ret", "mem", "resp", " bl", "enc", "cmp", "wid", "end", "e", "vec", "all", " length", "pl", "L", "seq", " fmt", "nl", "lan", "pos", "n", "nc", "err", " clen", "lib"], "elem": ["atelement", "elelt", "ateq", "telement", "elt", "element", " elev", "melement", "gelev", "elelem", "ielem", "ielement", "elelement", " eld", "Elem", "telev", "atelev", "telem", "Elev", "melt", "elev", "teq", "Elt", "gelem", "eq", "velev", "elelems", "eld", "gelement", "telete", "meld", "meq", "elems", "velement", "velt", "Elems", "ielete", "eleld", "atelem", "melev", " elems", "gelete", " elt", "melem", "ielev", "velem", "elelev", "Eld", "elete", "Element"], "vq": [" vqq", " vcs", "vp", "uvcs", "uvcu", "ique", "evque", "idq", "invque", "evld", "Vque", "vmq", "vmque", "vip", " vue", "uvq", " vdq", "invkg", "vcs", "nvque", "nvq", "bque", "uvqueue", "Vq", "nvqueue", "invq", "nq", "vqueue", "viq", " vp", "vidq", "iq", "np", "evue", "evq", "nvcu", "vqq", "bq", "vmkg", "vue", "vld", "ndq", "Vld", " vque", " vkg", "vkg", "vdq", " vcu", "bqueue", "invdq", "nvcs", " vqueue", "vcu", "nqq", "vque", "vmdq", "viqq", "evdq", "Vue", " vld"]}}
{"project": "qemu", "commit_id": "9a10bbb4e83b184faef6fa744396a6775283c0aa", "target": 0, "func": "void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm,\n\n                  qemu_irq sci_irq)\n\n{\n\n    memory_region_init(&pm->io, OBJECT(lpc_pci), \"ich9-pm\", ICH9_PMIO_SIZE);\n\n    memory_region_set_enabled(&pm->io, false);\n\n    memory_region_add_subregion(pci_address_space_io(lpc_pci),\n\n                                0, &pm->io);\n\n\n\n    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->s4_val);\n\n\n\n    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);\n\n    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,\n\n                          \"acpi-gpe0\", ICH9_PMIO_GPE0_LEN);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);\n\n\n\n    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,\n\n                          \"acpi-smi\", 8);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);\n\n\n\n    pm->irq = sci_irq;\n\n    qemu_register_reset(pm_reset, pm);\n\n    pm->powerdown_notifier.notify = pm_powerdown_req;\n\n    qemu_register_powerdown_notifier(&pm->powerdown_notifier);\n\n\n\n    acpi_cpu_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                          &pm->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);\n\n\n\n    if (pm->acpi_memory_hotplug.is_enabled) {\n\n        acpi_memory_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                                 &pm->acpi_memory_hotplug);\n\n    }\n\n}\n", "idx": 5229, "substitutes": {"lpc_pci": ["lpc__mci", "lpc_dcm", "lpc_dki", "lpc_pcci", "lpc_epcu", "lpc_ppci", "lpc_plso", "lpc_cpci", "lpc_plcu", "lpc_pki", "lpc__mce", "lpc_ipce", "lpc_dcul", "lpc_epci", "lpc_ppcu", "lpc_plcul", "lpc__pcu", "lpc__pci", "lpc_ppi", "lpc_ipci", "lpc_pcul", "lpc_dso", "lpc_mce", "lpc_gcu", "lpc_mci", "lpc_epcul", "lpc_gki", "lpc_dcu", "lpc_ipcu", "lpc_dco", "lpc_pcu", "lpc_cpcu", "lpc_pso", "lpc_pcm", "lpc_cpcm", "lpc_pco", "lpc_cppi", "lpc_mcu", "lpc_mpi", "lpc_gcci", "lpc_epso", "lpc_dcci", "lpc_mcm", "lpc_dce", "lpc_pce", "lpc_dpi", "lpc_plci", "lpc__pcm", "lpc__mcu", "lpc__pce", "lpc_ppcci", "lpc_dci", "lpc__mcm", "lpc_ipcm", "lpc_mco", "lpc_gci", "lpc_ppki"], "pm": ["gm", "pp", "master", "p", "rpm", "pkg", "PM", "pc", "em", "my", "wp", "rem", "pt", "wd", "mx", "pn", "term", "prom", "vm", "ami", "ams", "mod", "imm", "managed", "json", "cm", "cp", "dev", "dm", "bm", "rm", "ps", "ctx", "nom", "post", "dd", "obj", "mt", "po", "pb", "gem", "member", "pi", "am", "hm", "activity", "temp", "vim", "mi", "policy", "mp", "sam", "pa", "nm", "asm", "pool", "process", "perm", "cam", "m", "im", "pid", "param", "program", "vp", "phys", "tmp", "ms", "v", "pg", "module", "px", "pr", "wm", "um", "mm", "test", "ram", "mr"], "sci_irq": ["sci_irqu", "sci_mrq", "sci_irch", "sci_mirch", "sci_mirqs", "sci_mrqu", "sci_mrqs", "sci_irv", "sci_hrch", "sci_irsqu", "sci_irsQ", "sci_pirQ", "sci_pirq", "sci_irQ", "sci_mirq", "sci_pirqu", "sci_irsq", "sci_mrch", "sci_mrQ", "sci_hrq", "sci_irqs", "sci_mrv", "sci_hrqs", "sci_pirv", "sci_irsv"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)\n\n{\n\n    uint8_t ret;\n\n\n\n    OMAP_8B_REG(addr);\n\n    cpu_physical_memory_read(addr, (void *) &ret, 1);\n\n    return ret;\n\n}\n", "idx": 5250, "substitutes": {"opaque": ["osaque", "buffacity", "buffaque", "ospaque", "opc", "opacity", "ospacity", "opkt", "buffc", "ospc", "oskt", "osacity", "osc", "buffkt", "ospkt"], "addr": ["ptr", "dr", "t", "p", "work", "id", "arr", "data", "sp", "ctx", "ix", "ad", "hash", "address", "obj", "map", "ag", "offset", "set", "self", "handle", "pad", "adr", "align", "dh", "attr", "arp", "mem", "mt", "asm", "ident", " address", "index", "bind", "off", "act", "arch", "ref", "store", "row", "alloc", "ord", "hw", "var", "tx", "src", "ash", "alt", "ack", "add", "url", "err", "cmd", "seek"], "ret": ["ptr", "t", "elt", "lit", "gt", "RET", "arg", "rm", "arr", "r", "re", "nt", "cont", "Ret", "hash", "ft", "q", "rets", "txt", "val", "j", "rem", "mem", "mt", "result", "resp", "err", "info", "buf", "ref", "new", "print", "res", "ter", "ert", "reg", "flag", " Ret", "rt", "alt", "reply", "out", "last"]}}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)\n\n{\n\n    q->pending++;\n\n    set_bit(q->queue, n_IRQ);\n\n}\n", "idx": 5263, "substitutes": {"q": ["entry", "t", "query", "p", "conf", "ch", "pkg", "qq", "th", "v", "r", "ix", "Q", "w", "ox", "cl", "req", "ue", "dq", "h", "qu", "comm", "o", "pt", "iq", "eq", "i", "requ", "state", "sq", "que", "y", "ck", "m", "up", "aq", "quit", "ql", "qa", "qi", "count", "qt", "c", "queue", "ob", "qs", "n", "z", "next"], "n_IRQ": ["n_IRQueue", "n_RCQ", "n_AIRQ", "n_AIRQU", "n_DIRQL", "n_MRQU", "n_DIRQ", "n_IRQuery", "n_MRQueue", "n_RCQueue", "n_RCQuery", "n_IRCQueue", "n_IRQL", "n_AIRQueue", "n_irQuery", "n_irQ", "n_MRQL", "n_IRCMQ", "n_IRCQ", "n_MRQ", "n_irQueue", "n_RCMQ", "n_DIRQU", "n_AIRQL", "n_DIRQueue", "n_IRQU", "n_IRCQuery", "n_IRMQ", "n_irMQ"], "pending": ["did", "dstate", "nid", "nending", "nues", "pstate", "queuestate", "dues", "pid", "queueid", "dending", "nstate", "queueending", "pues", "queueues"]}}
{"project": "FFmpeg", "commit_id": "77d2ef13a8fa630e5081f14bde3fd20f84c90aec", "target": 1, "func": "static int matroska_decode_buffer(uint8_t** buf, int* buf_size,\n\n                                  MatroskaTrack *track)\n\n{\n\n    MatroskaTrackEncoding *encodings = track->encodings.elem;\n\n    uint8_t* data = *buf;\n\n    int isize = *buf_size;\n\n    uint8_t* pkt_data = NULL;\n\n    int pkt_size = isize;\n\n    int result = 0;\n\n    int olen;\n\n\n\n    if (pkt_size >= 10000000)\n\n        return -1;\n\n\n\n    switch (encodings[0].compression.algo) {\n\n    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:\n\n        return encodings[0].compression.settings.size;\n\n    case MATROSKA_TRACK_ENCODING_COMP_LZO:\n\n        do {\n\n            olen = pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING);\n\n            result = av_lzo1x_decode(pkt_data, &olen, data, &isize);\n\n        } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000);\n\n        if (result)\n\n            goto failed;\n\n        pkt_size -= olen;\n\n        break;\n\n#if CONFIG_ZLIB\n\n    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {\n\n        z_stream zstream = {0};\n\n        if (inflateInit(&zstream) != Z_OK)\n\n            return -1;\n\n        zstream.next_in = data;\n\n        zstream.avail_in = isize;\n\n        do {\n\n            pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size);\n\n            zstream.avail_out = pkt_size - zstream.total_out;\n\n            zstream.next_out = pkt_data + zstream.total_out;\n\n            result = inflate(&zstream, Z_NO_FLUSH);\n\n        } while (result==Z_OK && pkt_size<10000000);\n\n        pkt_size = zstream.total_out;\n\n        inflateEnd(&zstream);\n\n        if (result != Z_STREAM_END)\n\n            goto failed;\n\n        break;\n\n    }\n\n#endif\n\n#if CONFIG_BZLIB\n\n    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n\n        bz_stream bzstream = {0};\n\n        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n\n            return -1;\n\n        bzstream.next_in = data;\n\n        bzstream.avail_in = isize;\n\n        do {\n\n            pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size);\n\n            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n\n            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n\n            result = BZ2_bzDecompress(&bzstream);\n\n        } while (result==BZ_OK && pkt_size<10000000);\n\n        pkt_size = bzstream.total_out_lo32;\n\n        BZ2_bzDecompressEnd(&bzstream);\n\n        if (result != BZ_STREAM_END)\n\n            goto failed;\n\n        break;\n\n    }\n\n#endif\n\n    default:\n\n        return -1;\n\n    }\n\n\n\n    *buf = pkt_data;\n\n    *buf_size = pkt_size;\n\n    return 0;\n\n failed:\n\n    av_free(pkt_data);\n\n    return -1;\n\n}\n", "idx": 5277, "substitutes": {"buf": ["rc", "doc", "p", "cast", "pkg", "cv", "tmp", "v", "arr", "cb", "w", "Buffer", "h", "br", "pad", "read", "buff", "dat", "bs", "mem", "bytes", "b", "que", "bl", "cap", "buffer", "alloc", "enc", "window", "uf", "var", "seq", "queue", "cmd", "block", "pos", "rb", "input", "bc", "wb", "batch"], "buf_size": ["buff_count", "buf_Size", "buf_len", "buf_count", "buf2size", "buf2len", "buff_len", "buff_SIZE", "buff_Size", "buff_length", "buf_length", "buf2SIZE", "buf2length", "buf_SIZE", "buff_size"], "track": ["search", "t", "seek", "pack", "tracks", "train", "rm", "r", "rack", "race", "Track", "sync", "transform", "handle", "claim", "metadata", "index", "bind", "met", "trace", "roll", "store", "tracking", "match", "sound", "record", "stat", "report", "tr", "session", "round", "fire", "queue", "kick", "cmd", "ack", "tab", "stream", "run", "batch"], "encodings": ["eccodings", "ENCodings", "encordings", "ENCODings", "eccodities", "encodering", "enccodions", "encodities", "ecoders", "encODers", "encodedering", "encordions", "eccodrings", "enccoders", "encODings", "encorders", "ENCODering", "encODing", "enccoding", "ENCODers", "ecodrings", "enccodering", "encordrings", "encordities", "encording", "ecodities", "encodeding", "encodions", "enccodities", "ENCODing", "encODrings", "eccodions", "ecodions", "enccodrings", "encodrings", "eccoders", "enccodings", "ecodings", "ecoding", "encoders", "ENCoders", "ecodering", "encODering", "ENCodering", "encODions", "encodedings", "encODities", "ENCoding", "eccodering", "eccoding", "encodeders", "encoding", "encordering"], "data": ["out", "t", "p", "d", "length", "r", "mu", "image", "aw", "error", "DATA", " Data", "map", "w", "str", "offset", "good", "Data", "read", "empty", "dat", "size", "mem", "bytes", "result", "name", "info", "type", "buffer", "ata", "len", "iter", "xy", "end", " DATA", "results", "raw", "table", "initial", "window", "bin", "open", "n", "array", "pos", "start", "next", "value", "cache", "batch"], "pkt_data": ["packet_id", "pktipcache", "packet_Data", "pkt___length", "packetipid", "pnt_size", "pkt2size", "packet_len", "pkt_mem", "pktlybuffer", "pktiprel", "packet_num", "pkt_buffer", "packetipcache", "pkt___data", "pkt1name", "pkt_name", "packetiprel", "pct_len", "pkt1data", "packet_data", "pktlystep", "pkt1num", "packet_buffer", "pkt_str", "pktlydata", "pkt_window", "packet_size", "pkt_cache", "pct_size", "pktlymem", "packet_length", "pktlysize", "pnt_data", "pktipdata", "pkt_id", "pkt___time", "pkt_len", "pkt_step", "packet_time", "pkt_num", "packet_window", "pkt2len", "pct_data", "pnt_buffer", "packet_rel", "pkt2data", "pkt_time", "pnt_mem", "pktlylen", "packet_str", "pct_step", "pkt___window", "pkt_rel", "pkt_size", "packet_cache", "pkt_length", "pkt_Data", "packet_name", "packetipdata", "pkt1str", "pkt2name", "pktipid"], "olen": ["legal", "wan", "linger", "aken", "aled", "den", "temp", "agger", "ln", "oul", "half", "claimed", "regon", "led", "ken", "done", "nom", " leftover", "written", "known", "ele", "hat", "hung", "won", "equipped", "broken", "sol", "ilee", "innie", "ldon", "haven", "uin", "cn", "kl", "lost", "seen", "lvl", "sofar", "mem", "zon", "het", "didn", "sid", "mn", "rown", "alg", "oin", "mel", "len", "wid", "rn", "oled", "occupied", "held", "lol", "lan", "alt", "filled", "olid", "failed", "angled", "killed"]}}
{"project": "FFmpeg", "commit_id": "63b1866ae1e19ff0d694746a84e2eac859cda462", "target": 0, "func": "static void ac3_extract_exponents_c(uint8_t *exp, int32_t *coef, int nb_coefs)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < nb_coefs; i++) {\n\n        int e;\n\n        int v = abs(coef[i]);\n\n        if (v == 0)\n\n            e = 24;\n\n        else {\n\n            e = 23 - av_log2(v);\n\n            if (e >= 24) {\n\n                e = 24;\n\n                coef[i] = 0;\n\n            }\n\n            av_assert2(e >= 0);\n\n        }\n\n        exp[i] = e;\n\n    }\n\n}\n", "idx": 5281, "substitutes": {"coef": ["conef", "Coef", "coefficient", "Coefficient", "calefficients", "calef", "caleff", "coneff", "calefficient", "coeff", "Coefficients", "conefficient", "coefficients", " coff", "conefficients", " coefficients", "Coff", "Coeff", "coff", " coeff", "conff"], "nb_coefs": ["nb_coeferences", "nb_cocfrs", "nb_coffes", "nb_coffries", "nb_coofs", "nb_coefrs", "nb_coffs", "nb_coefes", "nb_cocferences", "nb_coeffrs", "nb_cocfs", "nb_cooferences", "nb_coifes", "nb_coffls", "nb_coefries", "nb_coifries", "nb_coefferences", "nb_coefls", "nb_coifs", "nb_coeffes", "nb_coofrs", "nb_coeffries", "nb_coeffs", "nb_coifls", "nb_coeffls"], "i": ["key", " m", " I", "init", "li", "json", "ei", "sim", "ki", "fi", "bi", "is", "id", "ind", "v", "ii", "ini", "l", "mi", "ix", " pi", "it", "me", "list", "ic", "\u0438", "hi", "uri", "si", "oi", "di", "j", "o", "gi", "ri", "chain", "ip", "ji", "index", "name", "point", "info", "slice", "ui", "multi", "iu", "xi", "y", "ij", "zi", "status", "print", " ti", "ti", "ci", "m", "iy", "ai", "pi", "im", "ims", "sequence", "x", "I", "phi", "qi", "series", "s", "n", "go", " ii", "batch"], "e": ["ei", "et", "de", "element", "el", "eu", "a", "f", "d", "v", "le", "ec", "entity", "r", "ae", "me", "eg", "oe", "error", "em", "diff", "en", "one", "ue", "h", "se", "o", "ne", "eur", "ge", "ie", "ee", "ex", "we", "b", "est", "g", "fe", "es", "E", "end", "te", "m", "ate", "ed", "ce", "eb", "eeee", "ent", "x", "c", "ef", "EEE", "pe", "er", "ev", "err", "be"]}}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void vhost_log_stop(MemoryListener *listener,\n\n                           MemoryRegionSection *section)\n\n{\n\n    /* FIXME: implement */\n\n}\n", "idx": 5283, "substitutes": {"listener": ["LISTeners", "istener", "Listeners", "listening", "LISTender", "Listening", "listeners", "istening", "LISTener", "isteners", "listender", "Listener", "Listender", "istender", "LISTening"], "section": ["key", "entry", "journal", "environment", "ECTION", "portion", "sect", "channel", "sections", "version", "course", "description", "lex", "setting", "cell", "group", "sector", "Section", "comment", "tag", "ment", "page", "job", "header", "division", "region", "directory", "event"]}}
{"project": "qemu", "commit_id": "79853e18d904b0a4bcef62701d48559688007c93", "target": 0, "func": "static void spapr_hotplug_req_event(sPAPRDRConnector *drc, uint8_t hp_action)\n\n{\n\n    struct hp_log_full *new_hp;\n\n    struct rtas_error_log *hdr;\n\n    struct rtas_event_log_v6 *v6hdr;\n\n    struct rtas_event_log_v6_maina *maina;\n\n    struct rtas_event_log_v6_mainb *mainb;\n\n    struct rtas_event_log_v6_hp *hp;\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n    sPAPRDRConnectorType drc_type = drck->get_type(drc);\n\n\n\n    new_hp = g_malloc0(sizeof(struct hp_log_full));\n\n    hdr = &new_hp->hdr;\n\n    v6hdr = &new_hp->v6hdr;\n\n    maina = &new_hp->maina;\n\n    mainb = &new_hp->mainb;\n\n    hp = &new_hp->hp;\n\n\n\n    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6\n\n                               | RTAS_LOG_SEVERITY_EVENT\n\n                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED\n\n                               | RTAS_LOG_OPTIONAL_PART_PRESENT\n\n                               | RTAS_LOG_INITIATOR_HOTPLUG\n\n                               | RTAS_LOG_TYPE_HOTPLUG);\n\n    hdr->extended_length = cpu_to_be32(sizeof(*new_hp)\n\n                                       - sizeof(new_hp->hdr));\n\n\n\n    spapr_init_v6hdr(v6hdr);\n\n    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);\n\n\n\n    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);\n\n    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));\n\n    mainb->subsystem_id = 0x80; /* External environment */\n\n    mainb->event_severity = 0x00; /* Informational / non-error */\n\n    mainb->event_subtype = 0x00; /* Normal shutdown */\n\n\n\n    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);\n\n    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));\n\n    hp->hdr.section_version = 1; /* includes extended modifier */\n\n    hp->hotplug_action = hp_action;\n\n\n\n\n\n    switch (drc_type) {\n\n    case SPAPR_DR_CONNECTOR_TYPE_PCI:\n\n        hp->drc.index = cpu_to_be32(drck->get_index(drc));\n\n        hp->hotplug_identifier = RTAS_LOG_V6_HP_ID_DRC_INDEX;\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;\n\n        break;\n\n    default:\n\n        /* we shouldn't be signaling hotplug events for resources\n\n         * that don't support them\n\n         */\n\n        g_assert(false);\n\n        return;\n\n    }\n\n\n\n    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq));\n\n}\n", "idx": 5298, "substitutes": {"drc": ["edroc", "crc", " dpc", "sdsrc", "rsrc", " dsc", "duc", "Duc", "rrc", "dsc", "sdpc", "rRC", " duc", "rpc", "sdrc", "cuc", " dric", "Dric", "Dsc", " droc", "dRC", "dric", "dsrc", "edsc", "DRC", "droc", "edRC", "sdRC", "cric", " dRC", "cRC", "Drc", "Droc", "dpc", "edrc", " dsrc"], "hp_action": ["HP_cmd", "hp_act", "HP_act", "HP_action", "HP_type", "hp_cmd", "hp_type"], "new_hp": ["new_host", "new___host", "old_hp", "remote___phy", "fresh_hl", "NEW_health", "new__gp", " new_host", "new___ip", "remote___ha", "fresh_hp", "freshJhl", "old_php", "new_ih", " new_ip", "news_phy", "new____ha", "new2php", "old___gp", "newlyhp", "remote_hp", "remote_ping", "now_hp", "new__php", "new_hyper", "new____phy", "new___phy", "new_rh", "new2phy", "new___gp", "new_hl", "remote_phy", "now_ih", "new____ping", "news_ha", "NEW_rh", "new_eth", "new2hp", "newlycp", "NEW_phil", "new__phy", "old___hp", "old_gp", "news_hp", "new_ha", "remote_ha", "new___ha", "unique_hp", "new_ping", "newJhp", "news_php", "unique_cp", " new_phy", "new__ih", "old_phy", "new__hl", "remote___ping", "new_sh", "new_ip", "fresh_phy", "new_phil", "new_hr", "NEW_hp", "newJhl", "new_gp", "news_ht", "news_hyper", "news_sh", "new_phy", "old___phy", "remote___hp", "new__eth", "freshJhp", "new_php", "newJphy", "unique_eth", "now_hyper", "newlyeth", "freshJgp", "unique_hr", "new___hp", "new____hp", "newlyhr", "old___php", "new_health", "new__hyper", "new_ht", "newJgp", "new___ping", "new_cp", "freshJphy", "now_eth", "new__hp", "new___ht", "new___php", "fresh_gp", "new2gp"], "hdr": ["hheader", "hhdr", "hrd", " hld", "hrid", "ohbr", "heder", "thrid", "shder", "thder", " hpar", "Hder", "phDR", "Hheader", "thrr", " hder", "phrd", "Hdr", "Hbr", "Hars", "hld", "highDR", "ohars", "phpar", "ahdr", " hheader", "highars", "hhheader", "hhder", "ahder", "ohdr", "ahDR", "thrd", " hbr", " hDR", "shdr", "hedr", "hars", "ohDR", "HDR", "hbr", "hder", "heheader", "ohr", "highheader", "thpar", "bhheader", " hr", "thdr", "phdr", "bhdr", " hrr", "highdr", "ohheader", "thheader", "hDR", "shrid", "ohder", "phheader", "ohld", "phder", "hpar", "hr", "ahheader", "Hr", "hrr", " hrid", "bhder", "Hld", " hrd", "shrr"], "v6hdr": ["v6phdr", "v4phld", "v6vpr", "v6HDR", "v4Hrr", "v6hpr", "v6Hix", "v6achld", "v6achDR", "v6phpr", "v6khrec", "v6hDR", "v4hpr", "v6Hr", "v6dhix", "v6hr", "v4ohDR", "v6hrec", "v4Hdr", "v4phpr", "v6hld", "v616hDR", "v6achpr", "v6vdr", "v6Hrec", "v6khDR", "v6Hld", "v4hld", "v616hrec", "v4ohr", "v616dhdr", "v6khdr", "v6khix", "v6achdr", "v6hrr", "v4HDR", "v4hdr", "v6Hder", "v616dhDR", "v4ohld", "v6vDR", "v6hder", "v6Hrr", "v616hix", "v6phrr", "v4hder", "v6Hdr", "v4ohdr", "v6ohr", "v6dhdr", "v616dhix", "v4phdr", "v6phld", "v616hdr", "v616dhrec", "v6hix", "v6chDR", "v6ohdr", "v6phr", "v4hDR", "v6chrr", "v4hr", "v4Hder", "v6chdr", "v6chder", "v4hrr", "v6ohDR", "v6ohld", "v6dhrec", "v6phDR", "v4phDR", "v6phder", "v6dhDR", "v6vld"], "maina": ["MainA", "mainea", " mainc", "mainas", "Mainc", "ainba", "masterae", "masterea", "ainb", "mainc", " mainA", "mastera", " mainae", "Mainae", "aina", "Mainb", " mainea", "masterb", "mainba", "sidea", "Mainea", "Mainba", " mainas", "masterc", "sideba", "Mainas", "masteras", "ainA", "sideA", "Maina", "mainA", "mainae", "masterA", "sideb"], "mainb": ["primarya", "dona", "donba", "mainf", " mainr", "masterf", "mainby", "mind", "minl", "masterv", "centralbb", "mainba", "masterbar", "centralb", "mainr", " mainf", "sideba", "masterby", "primaryb", "Maina", " mainv", " maine", "sideb", "matea", " mainbody", " mainback", "done", " mainh", " maind", "mainbb", "masterr", "mastera", "Mainb", "Mainh", "sidea", "maine", "genbody", "mainback", "mainh", "mainbar", " mainba", "Mainback", "maind", "mateb", "sidee", "minv", "masterb", "centralbar", " mainby", " mainbar", "minbb", "mainv", "matebar", "Mainr", "donb", "masterd", "masterbb", "primaryh", "Mainf", "mina", "matebb", "masterbody", "genby", "genb", " mainbb", " mainl", "masterl", "mainl", "minb", "Mainbar", "mainbody", "centrala", "primaryback"], "hp": ["ph", "ptr", "vp", "hd", "dr", "git", "pp", "cp", "phys", "p", "hess", "hyper", "oh", "ih", "pkg", "hops", "eth", "html", "lp", "tt", "apache", "ps", "ha", "hz", "prof", "wp", "hm", "hi", "phy", "drm", "chip", "h", "physical", "php", "dh", "driver", "ip", "ht", "proc", "np", "hs", "history", "hist", "http", "mn", "pr", "tp", "health", "HP", "gp", "hw", "pha", "phi", "hop", "hap", "mot", "hl", "ots", "cmd"], "drck": ["rk", " drcki", "prkk", " drk", "drcker", "drkk", "drk", "prcker", "prck", "ptrcki", " drkk", "rcker", "ptrk", "rkk", "rck", "drcki", "ptrck", "ptrkk", "prcki", " drcker", "prk"]}}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static TCGReg tcg_out_tlb_load(TCGContext *s, TCGReg addr, int mem_index,\n\n                               TCGMemOp s_bits, int which)\n\n{\n\n    const TCGReg r0 = TCG_REG_O0;\n\n    const TCGReg r1 = TCG_REG_O1;\n\n    const TCGReg r2 = TCG_REG_O2;\n\n    int tlb_ofs;\n\n\n\n    /* Shift the page number down.  */\n\n    tcg_out_arithi(s, r1, addr, TARGET_PAGE_BITS, SHIFT_SRL);\n\n\n\n    /* Mask out the page offset, except for the required alignment.  */\n\n    tcg_out_movi(s, TCG_TYPE_TL, TCG_REG_T1,\n\n                 TARGET_PAGE_MASK | ((1 << s_bits) - 1));\n\n\n\n    /* Mask the tlb index.  */\n\n    tcg_out_arithi(s, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND);\n\n    \n\n    /* Mask page, part 2.  */\n\n    tcg_out_arith(s, r0, addr, TCG_REG_T1, ARITH_AND);\n\n\n\n    /* Shift the tlb index into place.  */\n\n    tcg_out_arithi(s, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL);\n\n\n\n    /* Relative to the current ENV.  */\n\n    tcg_out_arith(s, r1, TCG_AREG0, r1, ARITH_ADD);\n\n\n\n    /* Find a base address that can load both tlb comparator and addend.  */\n\n    tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]);\n\n    if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) {\n\n        tcg_out_addi(s, r1, tlb_ofs & ~0x3ff);\n\n        tlb_ofs &= 0x3ff;\n\n    }\n\n\n\n    /* Load the tlb comparator and the addend.  */\n\n    tcg_out_ld(s, TCG_TYPE_TL, r2, r1, tlb_ofs + which);\n\n    tcg_out_ld(s, TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend));\n\n\n\n    /* subcc arg0, arg2, %g0 */\n\n    tcg_out_cmp(s, r0, r2, 0);\n\n\n\n    /* If the guest address must be zero-extended, do so now.  */\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, r0, addr, 0, SHIFT_SRL);\n\n        return r0;\n\n    }\n\n    return addr;\n\n}\n", "idx": 5304, "substitutes": {"s": ["t", "S", "p", "conf", "ds", "is", "a", "ms", "d", "v", "r", "ps", "ins", "q", "sm", "z", "sync", "obj", "w", "ss", "self", "h", "aws", "comm", "i", "ns", "js", "ex", "b", "ssl", "space", "sq", "hs", "an", "g", "ses", "sts", "sg", "socket", "rs", "sys", "gs", "y", "ties", "ts", "es", "stats", "m", "fs", "its", "sv", "cs", "ims", "x", "csv", "sb", "c", "as", "ls", "n", "qs", "ats", "sw"], "addr": ["ptr", "rc", "dr", "gz", "host", "eth", "pkg", "a", "id", "r", "ctx", "rr", "ad", "hash", "prefix", "address", "map", "ag", "offset", "alias", "handle", "pad", "oad", "adr", "arp", "ip", "mem", "asm", " address", "name", "arch", "rs", "ref", "store", "alloc", "db", "rel", "hw", "Address", "src", "from", "nl", "start", "ack", "add", "url", "cmd"], "mem_index": ["mem2Index", "mem_num", "mem_number", "mem2ind", "memory_ind", "mem_ind", "mem_Index", "mem2number", "memory_num", "memory_number", "mem2index", "memory_index", "memory_Index"], "s_bits": ["s__mask", "p__bit", " s_bit", " s_mask", "s_bit", "s__blocks", "s_ps", " s_blocks", "s_blocks", "p_blocks", "s___bit", "p__blocks", "p_bits", "s__bit", "p__bits", "s__bits", "s___blocks", "p_ps", "p__ps", "s___ps", "s_mask", "s___mask", "s___bits", "s__ps", "p_bit"], "which": ["ptr", "why", "whose", "isc", "clus", "through", "whether", "eth", "nil", "is", "focus", "ctr", "every", "hat", "select", "wit", "filename", "via", "method", "chip", "each", "where", "ctl", "index", "how", "colour", "selected", "selection", "type", " Which", "command", "find", "this", "what", "bit", "Which", "and", "from", "who", "using", "cmd"], "tlb_ofs": ["tlb_effd", "tlb_OFis", "tlb_ofy", "tlb_fonts", "tlb_oftis", "tlb_offd", "tlb_fontd", "tlb_effs", "tlb_dirS", "tlb_Ofi", "tlb_defs", "tlb_ofis", "tlb_OFsb", "tlb_effS", "tlb_fontr", "tlb_ofts", "tlb_dirg", "tlb_defis", "tlb_Ofd", "tlb_ofty", "tlb_bufs", "tlb_OFs", "tlb_ofi", "tlb_defS", "tlb_ofS", "tlb_tells", "tlb_dirs", "tlb_OFx", "tlb_OFr", "tlb_Ofs", "tlb_ofr", "tlb_offx", "tlb_Ofr", "tlb_ofg", "tlb_bufg", "tlb_ofx", "tlb_OFi", "tlb_offS", "tlb_offts", "tlb_OFts", "tlb_defy", "tlb_effg", "tlb_OFS", "tlb_fonti", "tlb_offs", "tlb_bufS", "tlb_oftS", "tlb_tellx", "tlb_effts", "tlb_ofd", "tlb_offsb", "tlb_effsb", "tlb_ofsb", "tlb_tellS", "tlb_OFy", "tlb_OFd"]}}
{"project": "qemu", "commit_id": "838ef602498b8d1985a231a06f5e328e2946a81d", "target": 0, "func": "static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,\n\n                        void *s, void *sp)\n\n{\n\n    DPRINTF(\"CURL (AIO): Sock action %d on fd %d\\n\", action, fd);\n\n    switch (action) {\n\n        case CURL_POLL_IN:\n\n            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);\n\n            break;\n\n        case CURL_POLL_OUT:\n\n            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);\n\n            break;\n\n        case CURL_POLL_INOUT:\n\n            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);\n\n            break;\n\n        case CURL_POLL_REMOVE:\n\n            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);\n\n            break;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 5306, "substitutes": {"curl": ["ccurl", "cssl", "CURL", "ccURL", "Curl", "Cll", "ccll", "cll", "ccssl", " cll", "Cssl", " cURL", "cURL", " cssl"], "fd": ["df", "ptr", "hd", "gz", "fr", "unc", "fn", "dt", "td", "ds", "fi", "lf", "form", "f", "disk", "handler", "d", "ind", "func", "data", "ctx", " sd", "ad", "fin", "dd", "fb", "cb", "fps", "ld", "ff", "sf", "ud", "fl", "dl", "dat", "fc", "sd", "gd", "dial", "def", " df", " d", "std", "fed", "buffer", "da", "fp", " fid", "pd", "cf", "db", "cond", "fs", "desc", "uf", "nd", "callback", "FD", "stream", "bd"], "action": ["function", "activity", "form", "a", "func", "draw", "aff", "policy", " ACTION", "call", "change", "typ", "trigger", "aj", "fun", "version", "k", "j", "effect", "format", "off", "state", "index", "name", "act", "step", "type", "operation", "status", "code", "op", "flow", "what", "actions", "Action", "acl", "ac", "ACT", "ACTION", "mod", "ak", "mode", "c", "ction", "pos", "activation", "cmd", "event", " act"], "s": ["sc", "t", "S", "p", "ds", "f", "a", "ms", "d", "v", "r", "ps", "ins", "sl", "ss", "si", "sf", "aws", "bs", "space", "ns", "js", "i", "b", "sq", "socket", "sts", "sg", "rs", "gs", "ts", "sn", "seconds", "fs", "sv", "args", "cs", "sb", "c", "as", "ls", "n", "ats", "sa"], "sp": ["ptr", "sc", "vp", "pp", "p", "tmp", "sk", "ps", "ctx", "vs", "pc", " ss", "si", "ss", "sf", "dh", "ns", "ap", "js", "np", "resp", "osp", "sh", "fp", "esp", "sv", "SP", "sw", "fx"]}}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "SwsFunc yuv2rgb_get_func_ptr (SwsContext *c)\n\n{\n\n#if defined(HAVE_MMX2) || defined(HAVE_MMX)\n\n    if(c->flags & SWS_CPU_CAPS_MMX2){\n\n\tswitch(c->dstFormat){\n\n\tcase PIX_FMT_RGB32: return yuv420_rgb32_MMX2;\n\n\tcase PIX_FMT_BGR24: return yuv420_rgb24_MMX2;\n\n\tcase PIX_FMT_BGR565: return yuv420_rgb16_MMX2;\n\n\tcase PIX_FMT_BGR555: return yuv420_rgb15_MMX2;\n\n\t}\n\n    }\n\n    if(c->flags & SWS_CPU_CAPS_MMX){\n\n\tswitch(c->dstFormat){\n\n\tcase PIX_FMT_RGB32: return yuv420_rgb32_MMX;\n\n\tcase PIX_FMT_BGR24: return yuv420_rgb24_MMX;\n\n\tcase PIX_FMT_BGR565: return yuv420_rgb16_MMX;\n\n\tcase PIX_FMT_BGR555: return yuv420_rgb15_MMX;\n\n\t}\n\n    }\n\n#endif\n\n#ifdef HAVE_MLIB\n\n    {\n\n\tSwsFunc t= yuv2rgb_init_mlib(c);\n\n\tif(t) return t;\n\n    }\n\n#endif\n\n#ifdef HAVE_ALTIVEC\n\n    if (c->flags & SWS_CPU_CAPS_ALTIVEC)\n\n    {\n\n\tSwsFunc t = yuv2rgb_init_altivec(c);\n\n\tif(t) return t;\n\n    }\n\n#endif\n\n\n\n    av_log(c, AV_LOG_WARNING, \"No accelerated colorspace conversion found\\n\");\n\n\n\n    switch(c->dstFormat){\n\n    case PIX_FMT_BGR32:\n\n    case PIX_FMT_RGB32: return yuv2rgb_c_32;\n\n    case PIX_FMT_RGB24: return yuv2rgb_c_24_rgb;\n\n    case PIX_FMT_BGR24: return yuv2rgb_c_24_bgr;\n\n    case PIX_FMT_RGB565:\n\n    case PIX_FMT_BGR565:\n\n    case PIX_FMT_RGB555:\n\n    case PIX_FMT_BGR555: return yuv2rgb_c_16;\n\n    case PIX_FMT_RGB8:\n\n    case PIX_FMT_BGR8:  return yuv2rgb_c_8_ordered_dither;\n\n    case PIX_FMT_RGB4:\n\n    case PIX_FMT_BGR4:  return yuv2rgb_c_4_ordered_dither;\n\n    case PIX_FMT_RGB4_BYTE:\n\n    case PIX_FMT_BGR4_BYTE:  return yuv2rgb_c_4b_ordered_dither;\n\n    case PIX_FMT_MONOBLACK:  return yuv2rgb_c_1_ordered_dither;\n\n    default:\n\n    \tassert(0);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 5308, "substitutes": {"c": ["tc", "mc", "sc", "rc", "t", "cm", "cu", "p", "co", "conf", "cp", "ch", "unc", "com", "cv", "f", "d", "vc", "v", "l", "r", "lc", "cont", "ec", "ctx", "pc", "dc", "call", "C", "con", "cd", "w", "cl", "cb", "cc", "set", "cur", "abc", "icc", "h", "cn", "gc", "cr", "fc", "chain", "b", "g", "enc", "cf", "e", "cam", "m", "ca", "container", "conv", "etc", "ce", "cs", "ct", "ac", "n", "z", "nc", "cache", "bc"]}}
{"project": "qemu", "commit_id": "e5f34cdd2da54f28d90889a3afd15fad2d6105ff", "target": 1, "func": "static void vnc_set_share_mode(VncState *vs, VncShareMode mode)\n\n{\n\n#ifdef _VNC_DEBUG\n\n    static const char *mn[] = {\n\n        [0]                           = \"undefined\",\n\n        [VNC_SHARE_MODE_CONNECTING]   = \"connecting\",\n\n        [VNC_SHARE_MODE_SHARED]       = \"shared\",\n\n        [VNC_SHARE_MODE_EXCLUSIVE]    = \"exclusive\",\n\n        [VNC_SHARE_MODE_DISCONNECTED] = \"disconnected\",\n\n    };\n\n    fprintf(stderr, \"%s/%d: %s -> %s\\n\", __func__,\n\n            vs->csock, mn[vs->share_mode], mn[mode]);\n\n#endif\n\n\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive--;\n\n    }\n\n    vs->share_mode = mode;\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive++;\n\n    }\n\n}\n", "idx": 5314, "substitutes": {"vs": ["vp", "vi", "blogs", "ds", "details", "vers", "is", "ils", "vc", "ms", "v", "news", "vl", "ps", "ins", "inv", "ev", "serv", "ks", "vv", "fps", "ss", "ports", "posts", "vr", "ves", "lists", "views", "bs", "changes", "ns", "js", "hs", "ver", "ses", "sts", "rs", "gs", "ts", "es", "obs", "vm", "xs", "lbs", "stats", "lines", "vals", "fs", "sv", "ov", "cs", "values", "ims", "lv", "otes", "sb", "docs", "services", "wcs", "ls", "parts", "aps", "Vs", "qs", "pages", "vt", "VS", "eps", "uv"], "mode": ["MODE", "de", " macro", "ms", "dim", " mirror", "ode", "direction", "me", "send", "node", "options", "set", "self", "pty", "power", "module", "option", "device", "time", "size", "metadata", "format", "mt", "state", "name", "ODE", "mac", "role", "md", "multi", "type", "member", "mid", "command", "status", "cmp", "xy", "mit", "perm", "m", "te", "ase", "mm", "test", "Mode", "mod", "sty", "settings", "move", " ty", "mate", "pe", "value"], "mn": ["ng", "nos", "ems", "fn", "mus", "dm", "kn", "ln", "MN", "ms", "fm", "mph", "mind", "mi", "ins", "mu", "yn", "mp", "ml", "mun", "km", "mos", "cn", "nm", "mis", "dn", "ns", "wn", "mt", "np", "pres", "gn", "mx", "md", "mb", "pers", "wm", "mit", "mins", "mm", "san", "sv", "men", "man", "nc", "mc", "mr", "tn"], "vd": ["df", "hd", "dt", "disk", "ds", "VD", "vc", "ead", "fd", "dd", "sta", "vv", "ld", "nv", "vid", "ud", "ve", "dn", "gd", "sd", "wd", "md", "ued", "ord", "vm", "pd", "db", "xd", "dll", "desc", "lv", "nd", "cod", "vision", "bd"], "num_exclusive": ["count__free", "numwwindows", "num__secondary", "numEexternal", "num_free", "numwexternal", "num__free", "count_exclusive", "num_secondary", "num__windows", "count__external", "numEex", "numEexclusive", "count__ex", "number_windows", "num_windows", "num_external", "number_external", "count_ex", "count_free", "count__exclusive", "count_external", "num__exclusive", "numwsecondary", "number_secondary", "num_ex", "number_exclusive", "numwexclusive", "num__external", "numEfree", "num__ex"]}}
{"project": "FFmpeg", "commit_id": "7cc8d616aab68ba5534e5a74214786ad08aac5ce", "target": 1, "func": "uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)\n\n{\n\n    uint32_t scratch = 0;\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n\n\n    for (; buf < buf_end - 3; buf += 4)\n\n        scratch ^= *((const uint32_t*)buf);\n\n\n\n    scratch = xor_32_to_8(scratch);\n\n\n\n    for (; buf < buf_end; buf++)\n\n\n\n\n    return scratch;\n\n}", "idx": 5327, "substitutes": {"buf": ["gz", "bn", "pkg", "far", "arr", "bur", "msg", "loc", "cur", "Buff", "que", "iter", "now", "db", "coord", "vec", "loop", "bp", "uf", "queue", "broad", "box", "cmd", "ptr", "cp", "pack", "ctx", "xff", "obj", "aka", "buff", "b", "err", "buffer", "raw", "abet", "seq", "bu", "block", "batch", "urg", "pend", "rc", "ctr", "func", "cb", "Buffer", "port", "br", "pad", "nm", "off", "cap", "pool", "end", "var", "bf", "go", "img", "doc", "cv", "length", "pg", "bar", "ff", "req", "ann", "begin", "act", "bl", "alloc", "keep", "addr", "window", "pos", "rb", "av", "bc", "wb", "seek"], "buf_size": ["buf_scale", "buff_count", "buf_Size", "buf_len", "buf_count", "buff_len", "buffer_size", "buffer_scale", "buf_zone", "buffer_SIZE", "buffer_Size", "buf_SIZE", "buff_size", "buff_zone"], "buf_end": ["buf_bound", "db_end", "buf2end", "buf2stop", "buf_ender", "buf2start", "buf2size", "db_stop", " buf2end", "max_size", "buf_start", " buf2start", "max_end", " buf_ended", "buf_ended", "db_ender", "buf2ended", "db_size", "buf2ender", "max_bound", "max_END", "buf_END", "buf_stop", " buf2ended", " buf_start"]}}
{"project": "FFmpeg", "commit_id": "f354f30836a3148275ce60d19bbc581310249ad2", "target": 0, "func": "void ff_er_frame_start(ERContext *s)\n\n{\n\n    if (!s->avctx->err_recognition)\n\n        return;\n\n\n\n    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,\n\n           s->mb_stride * s->mb_height * sizeof(uint8_t));\n\n    s->error_count    = 3 * s->mb_num;\n\n    s->error_occurred = 0;\n\n}\n", "idx": 5353, "substitutes": {"s": ["tests", "t", "os", "S", "ess", "sports", "ds", "details", "is", "ms", "l", "v", "ps", "spec", "ins", "vs", "q", "w", "less", "ss", "sf", "events", "aws", "comm", "tes", "h", "uploads", "bs", "js", "ns", "hs", "asm", "sq", "g", "ses", "sts", "rs", "gs", "plays", "ts", "es", "sn", "ops", "stats", "comments", "fs", "its", "sv", "cs", "ims", "sb", "c", "parts", "als", "ls", "ats", "qs", "sys", "n", "se", "eps", "states"]}}
{"project": "FFmpeg", "commit_id": "f98c9fb27de84dc4f6123537b754eb2fe1a80c02", "target": 0, "func": "av_cold int MPV_common_init(MpegEncContext *s)\n\n{\n\n    int y_size, c_size, yc_size, i, mb_array_size, mv_table_size, x, y, threads;\n\n\n\n    if(s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n\n        s->mb_height = (s->height + 31) / 32 * 2;\n\n    else if (s->codec_id != CODEC_ID_H264)\n\n        s->mb_height = (s->height + 15) / 16;\n\n\n\n    if(s->avctx->pix_fmt == PIX_FMT_NONE){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"decoding to PIX_FMT_NONE is not supported.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if((s->encoding || (s->avctx->active_thread_type & FF_THREAD_SLICE)) &&\n\n       (s->avctx->thread_count > MAX_THREADS || (s->avctx->thread_count > s->mb_height && s->mb_height))){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"too many threads\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if((s->width || s->height) && av_image_check_size(s->width, s->height, 0, s->avctx))\n\n        return -1;\n\n\n\n    dsputil_init(&s->dsp, s->avctx);\n\n    ff_dct_common_init(s);\n\n\n\n    s->flags= s->avctx->flags;\n\n    s->flags2= s->avctx->flags2;\n\n\n\n    if (s->width && s->height) {\n\n        s->mb_width  = (s->width  + 15) / 16;\n\n        s->mb_stride = s->mb_width + 1;\n\n        s->b8_stride = s->mb_width*2 + 1;\n\n        s->b4_stride = s->mb_width*4 + 1;\n\n        mb_array_size= s->mb_height * s->mb_stride;\n\n        mv_table_size= (s->mb_height+2) * s->mb_stride + 1;\n\n\n\n        /* set chroma shifts */\n\n        avcodec_get_chroma_sub_sample(s->avctx->pix_fmt,&(s->chroma_x_shift),\n\n                                      &(s->chroma_y_shift) );\n\n\n\n        /* set default edge pos, will be overriden in decode_header if needed */\n\n        s->h_edge_pos= s->mb_width*16;\n\n        s->v_edge_pos= s->mb_height*16;\n\n\n\n        s->mb_num = s->mb_width * s->mb_height;\n\n\n\n        s->block_wrap[0]=\n\n        s->block_wrap[1]=\n\n        s->block_wrap[2]=\n\n        s->block_wrap[3]= s->b8_stride;\n\n        s->block_wrap[4]=\n\n        s->block_wrap[5]= s->mb_stride;\n\n\n\n        y_size = s->b8_stride * (2 * s->mb_height + 1);\n\n        c_size = s->mb_stride * (s->mb_height + 1);\n\n        yc_size = y_size + 2 * c_size;\n\n\n\n        /* convert fourcc to upper case */\n\n        s->codec_tag = ff_toupper4(s->avctx->codec_tag);\n\n\n\n        s->stream_codec_tag = ff_toupper4(s->avctx->stream_codec_tag);\n\n\n\n        s->avctx->coded_frame= (AVFrame*)&s->current_picture;\n\n\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_index2xy, (s->mb_num+1)*sizeof(int), fail) //error ressilience code looks cleaner with this\n\n        for(y=0; y<s->mb_height; y++){\n\n            for(x=0; x<s->mb_width; x++){\n\n                s->mb_index2xy[ x + y*s->mb_width ] = x + y*s->mb_stride;\n\n            }\n\n        }\n\n        s->mb_index2xy[ s->mb_height*s->mb_width ] = (s->mb_height-1)*s->mb_stride + s->mb_width; //FIXME really needed?\n\n\n\n        if (s->encoding) {\n\n            /* Allocate MV tables */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->p_mv_table_base            , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_forw_mv_table_base       , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_back_mv_table_base       , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_direct_mv_table_base     , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            s->p_mv_table           = s->p_mv_table_base            + s->mb_stride + 1;\n\n            s->b_forw_mv_table      = s->b_forw_mv_table_base       + s->mb_stride + 1;\n\n            s->b_back_mv_table      = s->b_back_mv_table_base       + s->mb_stride + 1;\n\n            s->b_bidir_forw_mv_table= s->b_bidir_forw_mv_table_base + s->mb_stride + 1;\n\n            s->b_bidir_back_mv_table= s->b_bidir_back_mv_table_base + s->mb_stride + 1;\n\n            s->b_direct_mv_table    = s->b_direct_mv_table_base     + s->mb_stride + 1;\n\n\n\n            if(s->msmpeg4_version){\n\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->ac_stats, 2*2*(MAX_LEVEL+1)*(MAX_RUN+1)*2*sizeof(int), fail);\n\n            }\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->avctx->stats_out, 256, fail);\n\n\n\n            /* Allocate MB type table */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_type  , mb_array_size * sizeof(uint16_t), fail) //needed for encoding\n\n\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->lambda_table, mb_array_size * sizeof(int), fail)\n\n\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix  , 64*32   * sizeof(int), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix  , 64*32   * sizeof(int), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix16, 64*32*2 * sizeof(uint16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix16, 64*32*2 * sizeof(uint16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->reordered_input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail)\n\n\n\n            if(s->avctx->noise_reduction){\n\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->dct_offset, 2 * 64 * sizeof(uint16_t), fail)\n\n            }\n\n        }\n\n    }\n\n\n\n    s->picture_count = MAX_PICTURE_COUNT * FFMAX(1, s->avctx->thread_count);\n\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->picture, s->picture_count * sizeof(Picture), fail)\n\n    for(i = 0; i < s->picture_count; i++) {\n\n        avcodec_get_frame_defaults((AVFrame *)&s->picture[i]);\n\n    }\n\n\n\n    if (s->width && s->height) {\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->error_status_table, mb_array_size*sizeof(uint8_t), fail)\n\n\n\n        if(s->codec_id==CODEC_ID_MPEG4 || (s->flags & CODEC_FLAG_INTERLACED_ME)){\n\n            /* interlaced direct mode decoding tables */\n\n            for(i=0; i<2; i++){\n\n                int j, k;\n\n                for(j=0; j<2; j++){\n\n                    for(k=0; k<2; k++){\n\n                        FF_ALLOCZ_OR_GOTO(s->avctx,    s->b_field_mv_table_base[i][j][k], mv_table_size * 2 * sizeof(int16_t), fail)\n\n                        s->b_field_mv_table[i][j][k] = s->b_field_mv_table_base[i][j][k] + s->mb_stride + 1;\n\n                    }\n\n                    FF_ALLOCZ_OR_GOTO(s->avctx, s->b_field_select_table [i][j], mb_array_size * 2 * sizeof(uint8_t), fail)\n\n                    FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_mv_table_base[i][j], mv_table_size * 2 * sizeof(int16_t), fail)\n\n                    s->p_field_mv_table[i][j] = s->p_field_mv_table_base[i][j]+ s->mb_stride + 1;\n\n                }\n\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_select_table[i], mb_array_size * 2 * sizeof(uint8_t), fail)\n\n            }\n\n        }\n\n        if (s->out_format == FMT_H263) {\n\n            /* cbp values */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->coded_block_base, y_size, fail);\n\n            s->coded_block= s->coded_block_base + s->b8_stride + 1;\n\n\n\n            /* cbp, ac_pred, pred_dir */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->cbp_table     , mb_array_size * sizeof(uint8_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->pred_dir_table, mb_array_size * sizeof(uint8_t), fail)\n\n        }\n\n\n\n        if (s->h263_pred || s->h263_plus || !s->encoding) {\n\n            /* dc values */\n\n            //MN: we need these for error resilience of intra-frames\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->dc_val_base, yc_size * sizeof(int16_t), fail);\n\n            s->dc_val[0] = s->dc_val_base + s->b8_stride + 1;\n\n            s->dc_val[1] = s->dc_val_base + y_size + s->mb_stride + 1;\n\n            s->dc_val[2] = s->dc_val[1] + c_size;\n\n            for(i=0;i<yc_size;i++)\n\n                s->dc_val_base[i] = 1024;\n\n        }\n\n\n\n        /* which mb is a intra block */\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->mbintra_table, mb_array_size, fail);\n\n        memset(s->mbintra_table, 1, mb_array_size);\n\n\n\n        /* init macroblock skip table */\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->mbskip_table, mb_array_size+2, fail);\n\n        //Note the +1 is for a quicker mpeg4 slice_end detection\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);\n\n\n\n        s->parse_context.state= -1;\n\n        if((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){\n\n            s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n\n            s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n\n            s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n\n        }\n\n    }\n\n\n\n    s->context_initialized = 1;\n\n    s->thread_context[0]= s;\n\n\n\n    if (s->width && s->height) {\n\n    if (s->encoding || (HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_SLICE)) {\n\n        threads = s->avctx->thread_count;\n\n\n\n        for(i=1; i<threads; i++){\n\n            s->thread_context[i]= av_malloc(sizeof(MpegEncContext));\n\n            memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n\n        }\n\n\n\n        for(i=0; i<threads; i++){\n\n            if(init_duplicate_context(s->thread_context[i], s) < 0)\n\n                goto fail;\n\n            s->thread_context[i]->start_mb_y= (s->mb_height*(i  ) + s->avctx->thread_count/2) / s->avctx->thread_count;\n\n            s->thread_context[i]->end_mb_y  = (s->mb_height*(i+1) + s->avctx->thread_count/2) / s->avctx->thread_count;\n\n        }\n\n    } else {\n\n        if(init_duplicate_context(s, s) < 0) goto fail;\n\n        s->start_mb_y = 0;\n\n        s->end_mb_y   = s->mb_height;\n\n    }\n\n    }\n\n\n\n    return 0;\n\n fail:\n\n    MPV_common_end(s);\n\n    return -1;\n\n}\n", "idx": 5356, "substitutes": {"s": ["p", "conf", "bes", "l", "gets", "ains", "ns", "sq", "ses", "ges", "gs", "stats", "xs", "results", "comments", "its", "ims", "ants", "c", "settings", "des", "n", "qs", "eps", "sc", "S", "r", "ps", "vs", "ins", "obj", "w", "less", "ss", "h", "changes", "mods", "js", "ows", "sts", "ts", "ops", "ads", "has", "bits", "fs", "args", "sb", "als", "ats", "sys", "states", "tests", "sports", "details", "is", "ports", "events", "aws", "params", "views", "bs", "styles", "ex", "sg", "rs", "ids", "ars", "e", "bis", "orders", "cs", "as", "terms", "ls", "ags", "t", "os", "ds", "south", "ms", "v", "ies", "sets", "eds", "set", "ast", "comm", "hs", "erences", "g", "pers", "ties", "ar", "es", "actions", "sv", "aunts", "parts", "se", "sw"], "y_size": ["v_SIZE", "vwsize", "vwSIZE", "y_SIZE", "vwid", "v_size", "ywsize", "vwshape", "ywshape", "v_id", "ywSIZE", "ywid", "v_shape", "y_shape", "y_id"], "c_size": ["cctSIZE", "cctsize", "cv_SIZE", "c_height", "cv_count", "cv_size", "c_SIZE", "cctcount", "cctheight", "c_count", "cv_height"], "yc_size": ["ycptset", "ycptid", "ycptSIZE", "ya_id", "yc_SIZE", "ycptsize", "yc_set", "ya_size", "ya_set", "ya_SIZE", "yc_id"], "i": ["t", "p", "bi", "f", "l", "v", "ii", "mi", "it", "si", "in", "ip", "b", "index", "g", "ij", "ci", "ti", "m", "ai", "pi", "im", "I", "c", "n"], "mb_array_size": ["mb_arr_SIZE", "mb_arrayabsize", "mb_array_len", "mb_arr_scale", "mb_array_scale", "mb_arrayablen", "mb_array_name", "mb_array_space", "mb_arr_size", "mb_arrayabscale", "mb_array_SIZE", "mb_arrayabSIZE", "mb_arr_len", "mb_array_shape"], "mv_table_size": ["mv_table_space", "mv_Table_size", "mv_table_Size", "mv_table__type", "mv_table_SIZE", "mv_table__Size", "mv_buffer_SIZE", "mv_table_empty", "mv_table_type", "mv_Table_name", "mv_Table_type", "mv_table_name", "mv_buffer_space", "mv_Table_Size", "mv_buffer_empty", "mv_buffer_size", "mv_table__name", "mv_table__size"], "x": ["p", "X", "f", "id", "l", "v", "ix", "w", "px", "time", "size", "xt", "ex", "index", "dx", "rx", "mx", "height", "xy", "xs", "m", "tx", "c", "z", "fx"], "y": ["py", "key", "t", "p", "ch", "dy", "v", "ym", "o", "ys", "size", "b", "Y", "sy", "height", "ny", "xy", "cy", "m", "iy", "yt", "c", "n", "yy", "vy"], "threads": ["counteds", " threadi", "Threads", "counti", "counts", " threadeds", "threadeds", "threadi", "Threadi", "Threadeds"]}}
{"project": "FFmpeg", "commit_id": "03847eb8259291b4ff1bd840bd779d0699d71f96", "target": 0, "func": "int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,\n\n                          const char *filename, void *logctx,\n\n                          unsigned int offset, unsigned int max_probe_size)\n\n{\n\n    AVProbeData pd = { filename ? filename : \"\", NULL, -offset };\n\n    unsigned char *buf = NULL;\n\n    int ret = 0, probe_size;\n\n\n\n    if (!max_probe_size) {\n\n        max_probe_size = PROBE_BUF_MAX;\n\n    } else if (max_probe_size > PROBE_BUF_MAX) {\n\n        max_probe_size = PROBE_BUF_MAX;\n\n    } else if (max_probe_size < PROBE_BUF_MIN) {\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (offset >= max_probe_size) {\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;\n\n        probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) {\n\n        int score = probe_size < max_probe_size ? AVPROBE_SCORE_RETRY : 0;\n\n        int buf_offset = (probe_size == PROBE_BUF_MIN) ? 0 : probe_size>>1;\n\n        void *buftmp;\n\n\n\n        if (probe_size < offset) {\n\n            continue;\n\n        }\n\n\n\n        /* read probe data */\n\n        buftmp = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE);\n\n        if(!buftmp){\n\n            av_free(buf);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        buf=buftmp;\n\n        if ((ret = avio_read(pb, buf + buf_offset, probe_size - buf_offset)) < 0) {\n\n            /* fail if error was not end of file, otherwise, lower score */\n\n            if (ret != AVERROR_EOF) {\n\n                av_free(buf);\n\n                return ret;\n\n            }\n\n            score = 0;\n\n            ret = 0;            /* error was end of file, nothing read */\n\n        }\n\n        pd.buf_size += ret;\n\n        pd.buf = &buf[offset];\n\n\n\n        memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);\n\n\n\n        /* guess file format */\n\n        *fmt = av_probe_input_format2(&pd, 1, &score);\n\n        if(*fmt){\n\n            if(score <= AVPROBE_SCORE_RETRY){ //this can only be true in the last iteration\n\n                av_log(logctx, AV_LOG_WARNING, \"Format %s detected only with low score of %d, misdetection possible!\\n\", (*fmt)->name, score);\n\n            }else\n\n                av_log(logctx, AV_LOG_DEBUG, \"Format %s probed with size=%d and score=%d\\n\", (*fmt)->name, probe_size, score);\n\n        }\n\n    }\n\n\n\n    if (!*fmt) {\n\n        av_free(buf);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* rewind. reuse probe buffer to avoid seeking */\n\n    ret = ffio_rewind_with_probe_data(pb, &buf, pd.buf_size);\n\n\n\n    return ret;\n\n}\n", "idx": 5357, "substitutes": {"pb": ["tc", "vp", "pp", "cp", "p", "lb", "phys", "conf", "pkg", "cv", "tmp", "bh", "lp", "bj", "ab", "aus", "PB", "ctx", "pc", "mp", "pg", "typ", "cb", "ub", "pro", "proc", "np", "bb", "tp", "jp", "pd", "xc", "plan", "job", "uf", "stab", "sb", "tx", "tk", "rb", "bc"], "fmt": [" flt", " fMT", "Flt", "bfformat", " fformat", " fFormat", "fMT", "Ftm", "ofMT", "bfMT", "fFormat", "ftm", " ftm", "ofmt", "sftm", "fformat", "sflt", "bfmt", "Fmt", "bfFormat", "Fformat", "flt", "offormat", "sfmt", "sfformat", "ofFormat"], "filename": ["fil", "json", "bn", "whether", "fn", "tmp", "ame", "family", "bh", "subject", "binary", "sbm", "whatever", "a", "f", "nil", "length", "path", "fle", "file", "prefix", "files", "exist", "txt", "username", "uri", "aka", "buff", "nm", "location", "source", "metadata", "gettable", "bol", "name", "sufficient", "buffer", "text", "fp", "jpg", "wav", "ename", "existent", "println", "held", "src", "directory", "Filename", "seek"], "logctx": ["lnmsg", "Loghandle", "evalmsg", "logconfig", "lnconfig", "evalhandle", "evalconfig", "lnhandle", "evalctx", "lnctx", "Logmsg", "Logctx", "loghandle", "logmsg", "Logconfig"], "offset": ["ptr", "order", "et", "bound", "reset", "unc", "tmp", "origin", "rot", "score", "length", "to", "OFF", "error", "position", "prefix", "padding", "address", "ext", "unk", "set", "axis", "handle", "o", "pad", "align", "attribute", "output", "attr", "size", "location", "i", "off", "pointer", "annot", "index", "slot", "name", "shift", "slice", "esi", "sector", "timeout", "scroll", "initialized", "ref", "buffer", "range", "fp", "len", "row", "end", "addr", "base", "offs", "window", "Offset", "count", "item", "original", "skip", "start", "batch", "url", "cache", "seek"], "max_probe_size": ["max_prose_SIZE", "max_probe1size", "max_probe_SIZE", "max_probe67SIZE", "max_probe_data", "max_proce_size", "max_proce_Size", "max_prochange67max", "max_prove_env", "max_prose_len", "max_prove_count", "max_prochange67size", "max_prochange67SIZE", "max_prochange_SIZE", "max_probe67info", "max_probeptenv", "max_prose_time", "max_probe2len", "max_probe_time", "max_probe67size", "max_probe_env", "max_probeptsize", "max_probe_type", "max_prove_name", "max_prove_Size", "max_probe1type", "max_prose_size", "max_prochange_max", "max_proce_SIZE", "max_prochange_info", "max_proce_max", "max_prove_size", "max_prose_count", "max_probe67max", "max_probe1SIZE", "max_prose_type", "max_probe_set", "max_probe_name", "max_proce_len", "max_probe2size", "max_probe_max", "max_prochange_size", "max_probeptSIZE", "max_probe_Size", "max_probeptSize", "max_prose_set", "max_prochange67info", "max_probe_info", "max_probe_count", "max_prose_data", "max_probe_len", "max_probe2max", "max_prose_Size", "max_prove_SIZE"], "buf": ["gz", "bn", "pkg", "bed", "msg", "txt", "loc", "cur", "gc", "Buff", "iter", "db", "vec", "bp", "uf", "queue", "box", "cmd", "ptr", "cp", "data", "ctx", "xff", "obj", "aka", "buff", "mem", "proc", "b", "ref", "buffer", "seq", "bu", "block", "bh", "temp", "dest", "priv", "fb", "cb", "Buffer", "port", "br", "abb", "cap", "pool", "cam", "bg", "foo", "var", "bf", "bag", "img", "doc", "cv", "tmp", "cat", "norm", "bar", "prop", "ff", "attr", "bytes", "orig", "alloc", "cmp", "cf", "rab", "window", "desc", "cache", "rb", "next", "err", "bc", "wb", "batch"], "probe_size": ["proute_color", "prose_offset", "prose_member", "prober_size", "prose_Size", "probe67max", "probe67min", "proce_since", "probe___Size", "proutelencolor", "probable___Size", "probe67div", "probe_scale", "prozo_size", "probeablecolor", "proze_shift", "proble_SIZE", "probe7size", "probe2type", "proce_len", "probe_length", "proute_message", "probe2count", "probe_SIZE", "probe_message", "probe_type", "probe2size", "probe2time", "prozo67min", "probe_color", "procho_size", "probe_offset", "proble_size", "proute_storage", "procho_type", "probe67scale", "probe___size", "proze_size", "probable_size", "prozo67size", "proze_max", "probable___size", "probe67length", "probelensize", "probable___length", "probe1size", "prose_size", "proutelenstorage", "prose_time", "proute_size", "probelenmessage", "proce_code", "prober_length", "probe67size", "probe_since", "probe7since", "probe___since", "probe_name", "prober_time", "prozo_min", "probeablesize", "prose_SIZE", "proutelensize", "probe2offset", "probe_Size", "proce_Size", "probe2length", "probe67SIZE", "probable_length", "probe1since", "probe7name", "probe67shift", "prose_count", "probe_global", "probe_storage", "procho_offset", "prozo_news", "probe1length", "probelenstorage", "proble_scale", "probeablestorage", "probelencolor", "probable___since", "proce_length", "prozo67SIZE", "probe2SIZE", "probe_time", "probe67news", "probe7global", "probe_code", "probe_min", "prozo67news", "proce_global", "probe67code", "proce_size", "proble_div", "probe_news", "probe_len", "probe_max", "probeablemessage", "proce_name", "probe___length", "probable_since", "probe_div", "procho_length", "probe_member", "probe1Size", "prozo_SIZE", "probe_count", "probe_shift", "probable_Size", "proutelenmessage"], "buftmp": [" buctmb", "boktmp", "bufmp", " buktemp", "bufetemp", "buctrap", "buxtmb", " buctmp", "buftemp", "buktemp", "bufortyp", "buffmb", "buffmp", "bufpp", "bufortmp", "bubtcp", "bufettmp", "buffcp", "buftr", " buftrap", "buktr", "bubtpp", " buktmp", "buxtemp", "buftrap", "buftmb", "bufetmp", "bufetr", "buxtmp", " buftr", "buxttmp", "boftyp", "bofttmp", "buktmp", " bukttmp", "buffyp", "boktyp", "buktyp", "boftcp", " buctpp", "bufcp", " bucttmp", "buktcp", "bufortcp", "buctmp", "bubtmp", " buktr", "bucttmp", " bufttmp", " buftcp", "buffrap", "buforttmp", "boftmp", "buftyp", "buctpp", " buctcp", "bufttmp", "buftcp", "bukttmp", "bufftmp", "bokttmp", "buftpp", "bubtmb", " buftemp", "buxtr", "buctcp", "buctmb", " buctrap", " buftmb", " buftpp", "buxtrap", "bufmb", "boktcp"]}}
{"project": "qemu", "commit_id": "0752706de257b38763006ff5bb6b39a97e669ba2", "target": 1, "func": "static void slirp_smb(SlirpState* s, Monitor *mon, const char *exported_dir,\n\n                      struct in_addr vserver_addr)\n\n{\n\n    static int instance;\n\n    char smb_conf[128];\n\n    char smb_cmdline[128];\n\n    FILE *f;\n\n\n\n    snprintf(s->smb_dir, sizeof(s->smb_dir), \"/tmp/qemu-smb.%ld-%d\",\n\n             (long)getpid(), instance++);\n\n    if (mkdir(s->smb_dir, 0700) < 0) {\n\n        config_error(mon, \"could not create samba server dir '%s'\\n\",\n\n                     s->smb_dir);\n\n        return;\n\n    }\n\n    snprintf(smb_conf, sizeof(smb_conf), \"%s/%s\", s->smb_dir, \"smb.conf\");\n\n\n\n    f = fopen(smb_conf, \"w\");\n\n    if (!f) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"could not create samba server \"\n\n                     \"configuration file '%s'\\n\", smb_conf);\n\n        return;\n\n    }\n\n    fprintf(f,\n\n            \"[global]\\n\"\n\n            \"private dir=%s\\n\"\n\n            \"smb ports=0\\n\"\n\n            \"socket address=127.0.0.1\\n\"\n\n            \"pid directory=%s\\n\"\n\n            \"lock directory=%s\\n\"\n\n            \"log file=%s/log.smbd\\n\"\n\n            \"smb passwd file=%s/smbpasswd\\n\"\n\n            \"security = share\\n\"\n\n            \"[qemu]\\n\"\n\n            \"path=%s\\n\"\n\n            \"read only=no\\n\"\n\n            \"guest ok=yes\\n\",\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            exported_dir\n\n            );\n\n    fclose(f);\n\n\n\n    snprintf(smb_cmdline, sizeof(smb_cmdline), \"%s -s %s\",\n\n             SMBD_COMMAND, smb_conf);\n\n\n\n    if (slirp_add_exec(s->slirp, 0, smb_cmdline, &vserver_addr, 139) < 0) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"conflicting/invalid smbserver address\\n\");\n\n    }\n\n}\n", "idx": 5361, "substitutes": {"s": ["p", "l", "sing", "sl", "self", "ns", "sq", "ses", "gs", "y", "sym", "stats", "ims", "c", "n", "qs", "S", "a", "sp", "r", "ps", "less", "ss", "h", "st", "j", "js", "b", "sts", "fs", "sis", "sb", "als", "ats", "sa", "details", "is", "sam", "params", "aws", "so", "bs", "source", "ex", "state", "rs", "m", "as", "ls", "t", "ds", "south", "v", "spec", "sm", "sync", " S", "sub", "set", "iss", "comm", "hs", "an", "g", "store", "ties", "status", "es", "service", "sv", "al", "se", "sw"], "mon": [" m", "monkey", "von", "den", "dm", "pai", "mons", "mont", "mi", "mut", "mu", "mitter", "con", "mun", "ox", "Mon", "umi", "MON", " Mon", "mat", "ann", "colm", "mt", "mx", "met", "an", "mn", "non", "tom", "dom", "um", "mint", "m", "mer", "mm", "san", "num", "mill", "on", "meter", "son", "mate", "demon", "man", " mu", "monitor"], "exported_dir": ["exlated_path", "exports_dir", "exported_doc", "exported_directory", "exlated_doc", "exported_block", "exlated_dir", "exports_block", "exlated_DIR", "exported_DIR", "exports_path", "exports_directory", "exported_path"], "vserver_addr": [" verver_address", " verver_add", " vserver_address", " vserver__add", " vserver__addr", "vserver_add", "vServer_add", " vserver_add", " verver_addr", " vserver__address", "vServer_addr", "vServer_host", "vserver_host"], "instance": ["entry", "ton", "master", "order", "ance", "Instance", "id", " instances", "component", "upload", "image", "parent", "inst", "performance", "node", "counter", "alias", "power", "anti", "index", "name", " inst", "usage", "nce", "ANCE", "member", "seed", "INST", "record", "osi", "ami", "unit", "test", "once", "owner", "count", "ances", "pe", "create"], "smb_conf": ["smb__dir", "smb__conf", "sdb_con", "sdb_def", "smb_cmd", "sdb_cfg", "smt_conf", "smb_dir", "smb__def", "smb_cfg", "smb_con", "smt_con", "smm_con", "smt_conv", "smt_config", "smb_config", "sdb_dir", "smb__cmd", "sdb_cmd", "smm_cfg", "smb__con", "smm_config", "smb_def", "sdb_config", "smb__config", "sdb_conf", "smb_conv", "smm_conf"], "smb_cmdline": ["smb_mdLine", "smb_ctrl", "smb_commandline", "smb_mdl", "smb_commandLine", "smb__cmdLine", "smb_ctrline", "smb_cmdine", "smb_Cmdline", "smb__mdline", "smb__cmdl", "smb_commandl", "smb_cmdl", "smb_cmdLine", "smb__mdLine", "smb_cmdeline", "smb_Cmdl", "smb_ctrLine", "smb_CmdLine", "smb__mdl", "smb_commandeline", "smb_ctreline", "smb_commandine", "smb_mdeline", "smb__cmdline", "smb_ctrine", "smb_mdline"], "f": ["af", "df", "fr", "t", "p", "fn", "fi", "tf", "lf", "ln", "raf", "d", "l", "fm", "v", "fac", "r", "fb", "fd", "file", "w", "ff", "k", "sf", "h", "j", "o", "xf", "fc", "fa", "i", "b", "F", "rf", "fe", "fp", "y", "cf", "e", "fo", "m", "fs", "ent", "uf", "c", "ef", "bf", "open", "z", "u"]}}
{"project": "qemu", "commit_id": "bf298f83c35da854632c5be75733a4aa95a780bf", "target": 0, "func": "void tlb_set_page(CPUState *env, target_ulong vaddr,\n\n                  target_phys_addr_t paddr, int prot,\n\n                  int mmu_idx, target_ulong size)\n\n{\n\n    PhysPageDesc *p;\n\n    unsigned long pd;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    unsigned long addend;\n\n    CPUTLBEntry *te;\n\n    CPUWatchpoint *wp;\n\n    target_phys_addr_t iotlb;\n\n\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n    p = phys_page_find(paddr >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        pd = IO_MEM_UNASSIGNED;\n\n    } else {\n\n        pd = p->phys_offset;\n\n    }\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_set_page: vaddr=\" TARGET_FMT_lx \" paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\\n\",\n\n           vaddr, (int)paddr, prot, mmu_idx, is_softmmu, pd);\n\n#endif\n\n\n\n    address = vaddr;\n\n    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {\n\n        /* IO memory case (romd handled later) */\n\n        address |= TLB_MMIO;\n\n    }\n\n    addend = (unsigned long)qemu_get_ram_ptr(pd & TARGET_PAGE_MASK);\n\n    if ((pd & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) {\n\n        /* Normal RAM.  */\n\n        iotlb = pd & TARGET_PAGE_MASK;\n\n        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM)\n\n            iotlb |= IO_MEM_NOTDIRTY;\n\n        else\n\n            iotlb |= IO_MEM_ROM;\n\n    } else {\n\n        /* IO handlers are currently passed a physical address.\n\n           It would be nice to pass an offset from the base address\n\n           of that region.  This would avoid having to special case RAM,\n\n           and avoid full address decoding in every device.\n\n           We can't use the high bits of pd for this because\n\n           IO_MEM_ROMD uses these as a ram address.  */\n\n        iotlb = (pd & ~TARGET_PAGE_MASK);\n\n        if (p) {\n\n            iotlb += p->region_offset;\n\n        } else {\n\n            iotlb += paddr;\n\n        }\n\n    }\n\n\n\n    code_address = address;\n\n    /* Make accesses to pages with watchpoints go via the\n\n       watchpoint trap routines.  */\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) {\n\n            iotlb = io_mem_watch + paddr;\n\n            /* TODO: The memory case can be optimized by not trapping\n\n               reads of pages with a write breakpoint.  */\n\n            address |= TLB_MMIO;\n\n        }\n\n    }\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    env->iotlb[mmu_idx][index] = iotlb - vaddr;\n\n    te = &env->tlb_table[mmu_idx][index];\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||\n\n            (pd & IO_MEM_ROMD)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&\n\n                   !cpu_physical_memory_is_dirty(pd)) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 5381, "substitutes": {"env": ["vp", "ei", "conf", "dev", "environment", "cv", "config", "conn", "esc", "v", "ec", "vs", "ctx", "worker", "policy", "enter", "vt", "connection", "obj", "w", "node", "map", "server", "en", "ue", "h", "nv", "ve", "here", "eng", "site", "state", "ah", "network", "vm", "e", "erd", "sv", "hw", "window", "Environment", "ef", "pe", "context", "shell", "er", "ev", "viron"], "vaddr": ["vmaddr", "mpad", "vphost", "paddress", " vadd", "ppad", "vppkg", "fdr", "phost", "maddr", "vaddress", "vptr", "madr", "hdr", " vaddress", "fptr", "vpptr", "vpaddress", "cvaddr", "vloc", " vadr", "vpaddr", "vdr", "hptr", "padr", "vpadd", "maddress", "vhost", " vdr", "cvpad", " vdomain", "haddress", "vmloc", "xdomain", " vpkg", "vdomain", "xadr", "vpattr", "pattr", " vptr", "vpkg", "cvadr", "vadd", "vadr", "vattr", "cvaddress", "padd", "ppkg", "xaddress", "ploc", " vhost", "xaddr", "pdomain", "faddress", "vmattr", "haddr", "faddr", "pptr", "vmaddress", "vploc", "vpad"], "paddr": ["paddress", "pchash", "maddr", "vref", "vaddress", "vptr", "ppobj", "madr", "pcaddr", "ppadd", "padr", "pcaddress", "maddress", " pref", "tpaddress", "pref", " pptr", " padr", "vhash", "vurl", "tpaddr", "vobj", " paddress", " padd", "cpref", "vadd", "pcurl", "vadr", "cpadr", "tpurl", "purl", "padd", "ppptr", "phash", "cpaddr", " pobj", "pptr", "pobj", "cpaddress", "mref", "tphash", "ppaddr"], "prot": ["tif", "top", "conf", "eth", "tf", "period", "rot", "org", "ocol", "policy", " proto", "tz", "typ", "phy", "version", "style", "platform", "Prot", "pro", "port", "kind", "format", "ip", "def", " PROT", "sy", "net", "password", "type", "icon", "inet", "pat", "prototype", "rin", "ef", "bf", " protocol", " protocols", "bot"], "mmu_idx": ["mmu_indx", "mmu_dxs", "mmu_dy", "mmu_dx", "mmu_indy", "mmu_indb", "mmu_Idx", "mmu_indxc", "mmu_idy", "mmu_Idxc", "mmu_Idy", "mmu_db", "mmu_indxs", "mmu_idb", "mmu_idxs", "mmu_idxc", "mmu_Idxs"], "size": ["capacity", "small", "total", "max", "Size", "speed", "news", "sum", "sp", "data", "length", "SIZE", "ize", "sent", "send", "set", "style", "si", " Size", "city", " sizes", "body", "empty", "space", "bytes", "mem", "name", "sh", "fee", "g", "large", "network", "buffer", "len", "area", "sn", "e", "page", "scale", "storage", "sv", "zone", "num", "count", "iz", "sha", "message", "pos", "z", "shape", "too", "cache", "sw"], "p": ["ph", "vp", "pp", "t", "cp", "rep", "pkg", "lp", "d", "l", "v", "sp", "ps", "pc", "post", "ping", "pg", "mp", "pm", "pa", "j", "php", "pt", "ap", "ip", "proc", "np", "par", "g", "pb", "pr", "pers", "fp", "tp", "perm", "jp", "dp", "pat", "m", "page", "P", "bp", "pi", "parse", "pl", "pid", "c", "pe", "n", "pre"], "pd": ["py", "ptr", "hd", "pp", "cp", "dt", "disk", "td", "ds", "pkg", "lp", "d", "ped", "dim", "planes", "ps", "hid", "pc", "fd", "ping", "dd", "pg", "density", "ppa", "cd", "edd", "PD", "dc", "pm", "ld", "pa", "dq", "pad", "dl", "px", "pt", "php", "dh", "dn", "sd", "dat", "np", "po", "wd", "pdf", "pn", "md", "pb", "std", "password", "pard", "da", "tp", "dp", "pps", "pat", "xd", "addr", "pi", "pl", "pid", "ppo", "pe", "pos", "ecd", "ctl", "dds", "isd", "bd"], "index": ["ity", "primary", "id", "ind", "sp", "ctx", "hash", "loc", "offset", "si", "axis", "alias", "port", "i", "ip", "link", "info", "interface", "inc", "Index", "code", "pin", "page", "base", "count", "pos", "context"], "address": ["ptr", "entry", "order", "cp", "a", "resource", "length", "policy", "condition", "image", "error", "position", "enter", "dd", "path", "map", "node", "offset", "alias", "description", "port", "device", "attribute", "adr", "location", "ip", "pointer", "memory", "comment", "point", "password", "interface", "network", "buffer", "command", "area", "code", "end", "page", "table", "addr", "Address", "number", "reference", "distance", "x", "region", "email", "message", "start", "array", "block", "shape", "directory", "cache", "action"], "code_address": ["codeaddroffset", "page_offset", "codeaddraddr", "page_index", "code_index", "page_location", "code_order", "page_order", "codeaddraddress", "page_address", "page_addr", "code_offset", "code_addr", "codeaddrindex", "code_location"], "addend": [" Addend", " Adduntil", " addEnd", " AddEnd", "addbegin", "endend", "endbegin", "Addender", "endEnd", "adduntil", "Addend", "Adduntil", "addEnd", " addender", " addbegin", "addender", "AddEnd", " adduntil", "endender", "Addbegin"], "te": ["tc", "tle", "ace", "t", "ote", "ke", "de", "txt", "ue", "ne", "ge", "ie", "ket", "ste", "tw", "ape", "ffe", "tr", "ce", "ta", "tm", "tx", "pe", "rt", "oe", "se", "TE", "be"], "wp": ["ph", "vp", "cp", "pkg", "ww", "lp", "rw", "wx", "sp", "ctx", "pc", "mp", "pg", "dc", "w", "ep", "wk", "dq", "wordpress", "wo", "pt", "wt", "ip", "ht", "np", "wd", "WP", "wu", "pb", "fp", "tp", "dp", "jp", "yp", "wr", "bp", "hw", "tx", "tk", "kw", "iw"], "iotlb": ["otlbs", "iolp", "oidlbs", "motlp", "riotLB", "ietlbs", "hotlas", "natlb", "ioticlb", "ietlas", "ioplp", "ietLB", "riotlb", "skylb", "otlp", "ootlam", "iotbl", "riotlbs", "skylam", "natzb", "irisbl", "iotlam", "ootbl", "iolbs", "iotlab", "riotlp", "otlas", "oidLB", "otlb", "skybl", "ioticlp", "ioplb", "potlp", "dotlab", "motzb", "ioplas", "dotlp", "ioticzb", "natlp", "irislab", "natlab", "otzb", "oidlb", "skylab", "ootlab", "iotlp", "iotzb", "iolab", "hotlab", "motlab", "potlb", "ietlp", "iotLB", "dotlb", "ietlab", "hotlb", "iotlas", "potlab", "otlab", "ioplab", "potlas", "potlbs", "irislam", "ietzb", "iolb", "iotlbs", "hotlp", "irislb", "ootlb", "oidlp", "motlb", "dotzb", "ioticlas", "ietlb", "ioplbs"]}}
{"project": "qemu", "commit_id": "b3a2319792ad5c0f0f8c3d2f4d02b95fd7efbc69", "target": 0, "func": "void *slavio_intctl_init(target_phys_addr_t addr, target_phys_addr_t addrg,\n\n                         const uint32_t *intbit_to_level,\n\n                         qemu_irq **irq, qemu_irq **cpu_irq,\n\n                         unsigned int cputimer)\n\n\n\n{\n\n    int slavio_intctl_io_memory, slavio_intctlm_io_memory, i;\n\n    SLAVIO_INTCTLState *s;\n\n\n\n    s = qemu_mallocz(sizeof(SLAVIO_INTCTLState));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->intbit_to_level = intbit_to_level;\n\n    for (i = 0; i < MAX_CPUS; i++) {\n\n\tslavio_intctl_io_memory = cpu_register_io_memory(0, slavio_intctl_mem_read, slavio_intctl_mem_write, s);\n\n\tcpu_register_physical_memory(addr + i * TARGET_PAGE_SIZE, INTCTL_SIZE,\n\n                                     slavio_intctl_io_memory);\n\n    }\n\n\n\n    slavio_intctlm_io_memory = cpu_register_io_memory(0, slavio_intctlm_mem_read, slavio_intctlm_mem_write, s);\n\n    cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory);\n\n\n\n    register_savevm(\"slavio_intctl\", addr, 1, slavio_intctl_save, slavio_intctl_load, s);\n\n    qemu_register_reset(slavio_intctl_reset, s);\n\n    *irq = qemu_allocate_irqs(slavio_set_irq, s, 32);\n\n\n\n    *cpu_irq = qemu_allocate_irqs(slavio_set_timer_irq_cpu, s, MAX_CPUS);\n\n    s->cputimer_bit = 1 << s->intbit_to_level[cputimer];\n\n    slavio_intctl_reset(s);\n\n    return s;\n\n}\n", "idx": 5386, "substitutes": {"addr": ["ptr", "dr", "rc", "ace", "p", "host", "eth", "pkg", "work", "a", "id", "v", "arg", "r", "ix", "to", "ad", "prefix", "address", "ag", "offset", "gate", "pad", "oad", "adr", "in", "dh", "arp", "ip", "off", "mt", "name", "mac", "act", "at", "g", "oa", "ref", "ar", "now", "ord", "db", "m", "res", "grid", "hw", "Address", "ac", "x", "tx", "on", "ash", "rt", "cmd", "add"], "addrg": ["dirn", "addG", "prefixn", " addrj", " addrmg", "addressg", "addressmg", "addrj", "addrG", "prefixG", "addgm", "addressG", " addrG", " addrgm", "prefixj", " addrn", "addrmg", "addrn", "addmg", "addrgm", "dirG", "prefixg", "addressgm", "addg", "dirj", "dirg"], "intbit_to_level": ["intbit_to_bit", "intbit_TO_level", "intbit_to_state", "intbit_TO_levels", "intbit_to_Level", "intbit_to_mask", "intbit_TO_mask", "intbit_from_Level", "intbit_from_vel", "intbit_from_level", "intbit_to_vel", "intbit_TO_state", "intbit_to_levels", "intbit_to_field", "intbit_from_bit"], "irq": ["piru", " irqq", " iru", "irque", " irql", "interque", "interql", "ierql", " irque", "pirdq", "pirql", "ierq", "irqq", "interu", "iru", "pirqq", "irql", "pirque", "ierqq", " irdq", "pirq", "irdq", "ierdq", "interq"], "cpu_irq": ["cpu__virquire", "cpu_ironque", "cpu__irq", "cpu_irQ", "cpu__virq", "cpu_irong", "cpu_iterQ", "cpu__virqa", "cpu_iterg", "cpu_mirque", "cpu_mirq", "cpu_ironQ", "cpu_virque", "cpu__virque", "cpu_irque", "cpu_virqa", "cpu_ierqa", "cpu_nirque", "cpu_mirQ", "cpu_virq", "cpu_mirg", "cpu_virquire", "cpu_iterque", "cpu_ierquire", "cpu_ierq", "cpu_nirqa", "cpu_nirquire", "cpu_irquire", "cpu_irqa", "cpu__irqa", "cpu_ierque", "cpu_irg", "cpu_nirq", "cpu_ironq", "cpu__irquire", "cpu__irque", "cpu_iterq"], "cputimer": ["ccutrim", "dcputer", "cpetrim", " cputrim", "cpter", "dcpentim", "dcpenter", "ccuttimer", "cptrim", "cputrim", "cputtimer", "ccutim", "cputim", "cpttimer", " cpetimer", " cpetim", "cuter", "cpentimer", "cpentim", "cputer", "cptimer", " cputim", "ccutimer", "dcpentime", "cpentime", "dcputime", "cutimer", "cptime", " cputtimer", "dcpentimer", " cpetrim", "cputime", "dcputimer", "cutime", "cpettimer", "cptim", "dcputim", "cpetimer", "cutim", "cpenter", " cpettimer", "cpetim"], "slavio_intctl_io_memory": ["slavio_intctl_net_buffer", "slavio_intctl_i_mem", "slavio_intctl_i_message", "slavio_intctl_io_address", "slavio_intctl_io2message", "slavio_intctl_io_mem", "slavio_intctl_io2network", "slavio_intctl_io_message", "slavio_intctl_io_position", "slavio_intctl_io2buffer", "slavio_intctl_io2memory", "slavio_intctl_net_network", "slavio_intctl_i_address", "slavio_intctl_i_position", "slavio_intctl_net_mem", "slavio_intctl_io_buffer", "slavio_intctl_i_memory", "slavio_intctl_io_network", "slavio_intctl_net_memory", "slavio_intctl_io2address", "slavio_intctl_io2mem"], "slavio_intctlm_io_memory": ["slavio_intctlm_io_media", "slavio_intctlm_io2message", "slavio_intctlm_co2message", "slavio_intctlm_i_mem", "slavio_intctlm_io_address", "slavio_intctlm_i_media", "slavio_intctlm_co_memory", "slavio_intctlm_co2memory", "slavio_intctlm_io_storage", "slavio_intctlm_co2storage", "slavio_intctlm_i_memory", "slavio_intctlm_io2address", "slavio_intctlm_io2storage", "slavio_intctlm_co_storage", "slavio_intctlm_io_message", "slavio_intctlm_io2memory", "slavio_intctlm_co2address", "slavio_intctlm_co_message", "slavio_intctlm_i_storage", "slavio_intctlm_i_address", "slavio_intctlm_io_mem", "slavio_intctlm_co_address"], "i": ["t", "li", "ei", "p", "sim", "ki", "bi", "id", "l", "ii", "v", "ind", "ini", "mi", "ix", "me", "it", "si", "k", "oi", "j", "di", "gi", "ri", "in", "ip", "ex", "b", "index", "ui", "multi", "iu", "xi", "y", "ij", "zi", "print", "ci", "ti", "m", "ai", "pi", "im", "x", "I", "phi", "qi", "cli", "sql", "n", "u"], "s": ["p", "conf", "l", "sl", "ns", "sq", "gs", "y", "stats", "its", "ims", "ants", "c", "n", "z", "er", "S", "a", "ares", "sp", "r", "ps", "ins", "w", "less", "ss", "h", "j", "changes", "js", "b", "sts", "ts", "fs", "session", "sb", "ats", "sys", "tests", "details", "is", "f", "aws", "bs", "source", "space", "state", "socket", "rs", "e", "m", "cs", "ls", "t", "os", "ds", "ms", "v", "spec", "set", "single", "se", "comm", "hs", "g", "ar", "es", "sv", "params", "sw"]}}
{"project": "qemu", "commit_id": "1e5ffbedded7ded797f5042d82b70109a712b4c0", "target": 1, "func": "void helper_frndint(void)\n\n{\n\n    ST0 = rint(ST0);\n\n}\n", "idx": 5408, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "fc5a905a6d0c76d9fb8d838ac83f6219a7a5e20f", "target": 0, "func": "static void start_children(FFStream *feed)\n\n{\n\n    if (no_launch)\n\n        return;\n\n\n\n    for (; feed; feed = feed->next) {\n\n        if (feed->child_argv && !feed->pid) {\n\n            feed->pid_start = time(0);\n\n\n\n            feed->pid = fork();\n\n\n\n            if (feed->pid < 0) {\n\n                http_log(\"Unable to create children\\n\");\n\n                exit(1);\n\n            }\n\n            if (!feed->pid) {\n\n                /* In child */\n\n                char pathname[1024];\n\n                char *slash;\n\n                int i;\n\n\n\n                av_strlcpy(pathname, my_program_name, sizeof(pathname));\n\n\n\n                slash = strrchr(pathname, '/');\n\n                if (!slash)\n\n                    slash = pathname;\n\n                else\n\n                    slash++;\n\n                strcpy(slash, \"ffmpeg\");\n\n\n\n                http_log(\"Launch command line: \");\n\n                http_log(\"%s \", pathname);\n\n                for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)\n\n                    http_log(\"%s \", feed->child_argv[i]);\n\n                http_log(\"\\n\");\n\n\n\n                for (i = 3; i < 256; i++)\n\n                    close(i);\n\n\n\n                if (!ffserver_debug) {\n\n                    i = open(\"/dev/null\", O_RDWR);\n\n                    if (i != -1) {\n\n                        dup2(i, 0);\n\n                        dup2(i, 1);\n\n                        dup2(i, 2);\n\n                        close(i);\n\n                    }\n\n                }\n\n\n\n                /* This is needed to make relative pathnames work */\n\n                chdir(my_program_dir);\n\n\n\n                signal(SIGPIPE, SIG_DFL);\n\n\n\n                execvp(pathname, feed->child_argv);\n\n\n\n                _exit(1);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 5416, "substitutes": {"feed": ["connected", "full", "join", "flight", "rss", "pass", "alert", "send", "handle", "supp", "valid", "each", "connect", "row", "iter", "page", "loop", "lo", "feeding", "queue", "escape", "json", "handler", "data", "wait", "oooo", "pop", "hub", "post", "check", "build", "def", "op", "flow", "report", "fs", "follow", "import", "push", "context", "tab", "load", "df", "af", "entry", "config", "poll", "f", "good", "pull", "read", "format", "socket", "fe", "acc", "Feed", "jack", "hyd", "add", "mail", "fail", "form", "food", "channel", "hook", "set", "hold", "link", "gen", "write", "cf", "parse", "test", "accept", "update", "atom", "frame", "stream", "batch"], "pathname": ["Pathnode", "pathName", "programname", "Pathname", "patternName", "athfile", "portName", "portfile", " pathName", "Pathkey", "Path0", "Pathfile", "filetree", "athtree", "filename", " pathno", "pathnum", "filenum", "athname", "pathnode", "portname", " pathstring", "pathkey", "Pathsize", "athsize", "PathName", "pathstart", "athstart", "pathfile", "portno", " pathtree", "path0", "athName", "patternnode", "Pathnum", "pathno", " pathnode", "fileName", "pathsize", "ath0", "athno", "pathtree", " pathkey", " pathsize", "Pathno", "Pathstart", " pathstart", "patternstring", " path0", "Pathtree", "programtree", "patternname", "programName", "Pathstring", "programkey", "athnum", "pathstring"], "slash": ["strlash", "strashed", "slug", "slush", "splasher", "sslashed", "lasher", "slsl", " sllash", "SLsl", "lashing", "sllash", "sashing", "spllash", " slug", "flug", "slashing", "sslay", "splashing", "slasher", "flash", "sash", "flashing", "splsl", "SLush", "splashed", "lash", "strasher", "lashed", "stray", " slashed", "splush", "strash", "splug", "sashed", " slhash", "sug", "slay", "splash", "SLug", "lug", "SLay", "sslug", "slashed", " slasher", "SLash", "splhash", " slush", "strug", "sslash", " slsl", "slhash", "SLashed", "lhash", "flasher"], "i": ["p", "id", "l", "ii", "ini", "it", "q", "hi", "k", "di", "gi", "slice", "y", "ci", "ims", "qi", "c", "cli", "n", "z", "mc", " ii", "ei", "ix", "list", "ic", "si", "oi", "j", "h", "b", "index", "zi", "pi", "x", "phi", "ia", "is", "eu", "d", "ind", "mi", "gu", "io", "chain", "ip", "mac", "point", "multi", "cgi", "print", "e", "ti", "m", "iy", "ai", "im", "I", "go", "u", "init", "t", "li", "sim", "ki", "fi", "bi", "v", "me", "\u0438", "uri", "o", "in", "g", "ui", "iu", "xi", "ij", "batch"]}}
{"project": "FFmpeg", "commit_id": "8adff79b6d30d1ae2cb9cf906e1d7fcd759cd638", "target": 1, "func": "static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)\n\n{\n\n    MOVContext *mov = s->priv_data;\n\n    int i, j;\n\n\n\n    if (!mov->fragment_index_complete)\n\n        return 0;\n\n\n\n    for (i = 0; i < mov->fragment_index_count; i++) {\n\n        if (mov->fragment_index_data[i]->track_id == st->id) {\n\n            MOVFragmentIndex *index = index = mov->fragment_index_data[i];\n\n            for (j = index->item_count - 1; j >= 0; j--) {\n\n                if (index->items[j].time <= timestamp) {\n\n                    if (index->items[j].headers_read)\n\n                        return 0;\n\n\n\n                    return mov_switch_root(s, index->items[j].moof_offset);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 5429, "substitutes": {"s": ["sc", "t", "os", "p", "S", "ds", "f", "is", "d", "v", "sp", "r", "spec", "q", "w", "set", "ss", "self", "comm", "bs", "js", "ns", "hs", "b", "sq", "sys", "g", "scl", "sts", "rs", "gs", "ts", "es", "e", "stats", "m", "fs", "sv", "cs", "x", "us", "c", "sb", "n", "qs", "z", "ats", "stream"], "st": ["ST", "ust", "stage", "sc", " ST", "t", "irst", "th", "tt", "bt", "sp", "nt", "Stream", "ut", "ost", "sta", "stack", "inst", "stable", "str", "ss", "ist", "ast", "pt", "so", "ste", "stop", "est", "std", "sts", "rest", "tr", "nd", "us", "St", "start", "sw"], "timestamp": ["tmeline", "Timeness", "temeline", "temeness", " timance", "timetime", "Timetime", "tmetime", "timeness", "temetime", "tmestamp", "Timeline", "imestamp", "Timestamp", "Timance", "imance", " timeline", "timeline", "imetime", "imeline", " timetime", "tmeness", "temestamp", "timance"], "mov": ["moduleove", "smov", "commova", "tmove", "vov", "amav", "smood", "amov", " move", "commove", "tmov", "mutud", "tmovi", "commoval", "vove", "lov", "moval", "tmOV", "moduleov", "mav", "mutOV", "cov", "amove", "cove", "lOV", "amud", "mutov", "love", "mutove", "moduleoodle", "voval", "moduleood", " mood", "amovi", "cood", " mOV", " movi", "movi", "smove", "commov", "lood", " moodle", "moodle", "mood", "mOV", "move", "tmav", " mav", "mud", "cOV", "amOV", "vova", "tmud", "smoodle", "mova"], "i": ["init", " I", "li", "ski", "sim", "ki", "bi", "is", "id", "ind", "ii", "ms", "ini", "mi", "ix", "to", "me", "it", "ic", "q", "my", "\u0438", "si", "ish", "oi", "di", "gi", "span", "ri", "in", "io", "iq", "ip", "ie", "at", "ui", "multi", "iu", "xi", "y", "ij", "zi", "e", "ci", "ti", "m", "instance", "ami", "iy", "ai", "pi", "im", "ims", "x", "I", "phi", "us", "qi", "by", "er", " ii", "batch"], "j": ["bo", "json", "fr", "key", "dj", "p", "bj", "el", "bi", "f", "gov", "ind", "v", "jj", "l", "r", "jl", "it", "kid", "q", "note", "jc", "obj", "other", "aj", "str", "k", "req", "jo", "br", "o", "jet", "pt", "bs", "js", "ji", "jump", "b", "oj", "adj", "g", "Ja", "pr", "ij", "kj", "y", "jp", "uj", "m", "job", "ja", "jit", "x", "count", "je", "J", "user", "jack", "n", "z", "er", "ev"], "index": ["search", "fail", "order", "active", "connected", "max", "config", "f", "archive", "ind", "l", "data", "to", "list", "image", "error", "position", "check", "rule", "address", "map", "node", "ion", "IND", "h", "ok", "valid", "ne", "empty", "size", "available", "link", "ex", "group", "online", "root", "point", "level", "connect", "info", "date", "type", "zero", "range", "author", "row", "status", "Index", "iter", "e", "find", "instance", "page", "engine", "table", "initial", "all", "test", "num", "x", "count", "update", "open", "pos", "n", "cache", "out", "run"]}}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)\n\n{\n\n    switch(tag) {\n\n    case 0x4801:\n\n        track->track_id = get_be32(pb);\n\n        break;\n\n    case 0x4804:\n\n        get_buffer(pb, track->track_number, 4);\n\n        break;\n\n    case 0x4B01:\n\n        track->edit_rate.den = get_be32(pb);\n\n        track->edit_rate.num = get_be32(pb);\n\n        break;\n\n    case 0x4803:\n\n        get_buffer(pb, track->sequence_ref, 16);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 5430, "substitutes": {"track": ["t", "seek", "task", "pkg", "tracks", "form", "tf", "reflect", "train", "rack", "component", "rr", "Track", "dd", "sync", "check", "send", "transform", "hold", "req", "claim", "port", "sort", "pt", "recent", "package", "gc", "mt", "index", "stall", "met", "sys", "trace", "roll", "store", "tracking", "row", "tp", "rec", "rank", "stat", "record", "find", "report", "tr", "mm", "install", "project", "follow", "window", "trip", "route", "rt", "kick", "skip", "start", "ack", "tab", "batch"], "pb": ["vp", "pp", "cp", "p", "lb", "pack", "pkg", "bps", "cv", "bj", "lp", "PB", "pc", "fb", "mp", "pg", "prefix", "typ", "wp", "obj", "amp", "orp", "ub", "pa", "pm", "px", "pt", "buff", "gc", "bs", "asm", "emb", "np", "b", "bb", "proc", "resp", "buf", "buffer", "fp", "tp", "dp", "jp", "vm", "pool", "gp", "bp", "pl", "uf", "stab", "client", "obb", "tk", "xp", "sys", "bc", "wb"], "tag": ["key", "commit", "Tag", "pack", "our", "id", "cat", "label", "error", "bug", "field", "prefix", "tar", "ag", "style", "gate", "pad", "word", "state", "name", "feature", "comment", "level", "date", "type", "tail", "tags", "match", "code", "bit", "peg", "flag", "reg", "snap", "count", "oid", "riot", "feat", "bad", "TAG", "event", "batch"]}}
{"project": "FFmpeg", "commit_id": "e947b75b1c76ef6793209c2c445b8c224a28717a", "target": 1, "func": "int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p)\n\n{\n\n    int ret = 0;\n\n    if (av_strstart(p, \"pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,\", &p)) {\n\n        AVIOContext pb;\n\n        RTSPState *rt = s->priv_data;\n\n        AVDictionary *opts = NULL;\n\n        int len = strlen(p) * 6 / 8;\n\n        char *buf = av_mallocz(len);\n\n        AVInputFormat *iformat;\n\n\n\n        if (!buf)\n\n            return AVERROR(ENOMEM);\n\n        av_base64_decode(buf, p, len);\n\n\n\n        if (rtp_asf_fix_header(buf, len) < 0)\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Failed to fix invalid RTSP-MS/ASF min_pktsize\\n\");\n\n        init_packetizer(&pb, buf, len);\n\n        if (rt->asf_ctx) {\n\n            avformat_close_input(&rt->asf_ctx);\n\n        }\n\n\n\n        if (!(iformat = av_find_input_format(\"asf\")))\n\n            return AVERROR_DEMUXER_NOT_FOUND;\n\n\n\n        rt->asf_ctx = avformat_alloc_context();\n\n        if (!rt->asf_ctx) {\n\n            av_free(buf);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        rt->asf_ctx->pb      = &pb;\n\n        av_dict_set(&opts, \"no_resync_search\", \"1\", 0);\n\n\n\n        if ((ret = ff_copy_whiteblacklists(rt->asf_ctx, s)) < 0) {\n\n            av_dict_free(&opts);\n\n            return ret;\n\n        }\n\n\n\n        ret = avformat_open_input(&rt->asf_ctx, \"\", iformat, &opts);\n\n        av_dict_free(&opts);\n\n        if (ret < 0) {\n\n            av_free(buf);\n\n            return ret;\n\n        }\n\n        av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0);\n\n        rt->asf_pb_pos = avio_tell(&pb);\n\n        av_free(buf);\n\n        rt->asf_ctx->pb = NULL;\n\n    }\n\n    return ret;\n\n}\n", "idx": 5437, "substitutes": {"s": ["sc", "t", "os", "S", "conf", "ds", "f", "a", "v", "r", "ps", "vs", "serv", "w", "set", "ss", "st", "aws", "h", "sr", "bs", "ns", "js", "hs", "b", "state", "sq", "sys", "g", "ses", "sts", "sg", "socket", "rs", "gs", "ts", "sn", "e", "es", "stats", "xs", "res", "fs", "its", "sv", "cs", "sb", "c", "settings", "ls", "n", "ats", "qs"], "p": ["vp", "pp", "t", "cp", "pkg", "lp", "f", "a", "d", "l", "v", "sp", "r", "ps", "data", "pc", "ping", "q", "padding", "wp", "str", "pa", "pro", "j", "h", "pad", "o", "pt", "i", "ap", "b", "np", "pn", "g", "at", "pr", "fp", "tp", "jp", "pat", "m", "P", "bp", "part", "c", "n"], "pb": ["vp", "t", "pp", "cp", "pkg", "td", "cv", "tmp", " outp", "lp", "bj", "nb", "bh", " xp", "PB", "sp", " np", "ps", "ctx", "pc", " PB", "mp", " proto", " pl", "pg", "pas", "txt", "cb", "wp", "ub", "pa", "pt", "apa", "buff", "bs", "b", "np", "kb", "ref", "fp", "tp", "dp", "jp", "db", "tg", "bp", "pl", "uf", "sb", "tx", "tk", " resp", "pac", "tab", "rb", "pan", "wb", "batch"], "rt": ["ptr", "rc", "fr", "t", "hd", "gt", "dt", "art", "tt", "bt", "ind", "rm", "rot", "rw", "att", "nt", "r", "ctx", "it", "rr", "ft", "rl", "txt", "RT", "rh", "req", "vr", "pt", "wt", "ret", "ht", "mt", "usr", "lt", "rx", "act", "at", "net", "rs", "rev", "apt", "ot", "ts", "rn", "rec", "rect", "res", "rd", "irt", "addr", "hw", "ct", "round", "tx", "qt", "nd", "rin", "feat", "NT", "ack", "rb", "vt", "reg", "cmd"], "opts": ["optters", "Opt", "opms", "optcs", "operters", "iopcs", " opments", " copcs", "optct", " copms", " copments", "iopms", "Opmt", "optts", "porTS", " opters", "optths", "optmt", " copents", "porments", "optTS", "opptions", "ports", "opths", "optt", "opents", "optptions", "opmt", "opct", "Opptions", "optents", "opcs", " opt", "optments", "iopths", " opct", "opt", " opmt", " opents", "opTS", "operct", " copts", "iopts", "ropments", " copths", " opptions", "ropts", "opters", "operts", "Opts", " opms", "optms", "operms", "ropTS", "opments"], "buf": ["ptr", "vp", "gz", "doc", "cp", "pack", "pkg", "cv", "tmp", "bh", "v", "rw", "arr", "data", "ctx", "xff", "fb", "pg", "msg", "txt", "cb", "Buffer", "str", "h", "br", "pad", "gc", "buff", "Buff", "bs", "mem", "bytes", "b", "proc", "mb", "bl", "cap", "ref", "buffer", "text", "fp", "len", "cam", "raw", "conv", "vec", "bp", "uf", "seq", "tx", "ob", "cmd", "bin", "queue", "block", "box", "rb", " buffer", "img", "bc", "wb", "batch"], "iformat": ["iformap", "initialati", " uniformAT", " uniformat", "iefart", " uniformate", " uniformet", "iformate", " uniformset", "iformet", "iformiat", "mindat", "ivariart", "initialat", "ivariap", "\u30a7ap", "iformant", " uniformati", "mindati", "initialAT", "\u30a7at", "instet", "ivariant", "initialate", "mindAT", "\u30a7ant", " uniformsiat", "mindate", "instat", "instate", " uniformiat", "iformart", "iefat", "iformAT", "iefap", "iefant", "ivariat", "iformati", " uniformsat", " uniformsate", "instiat", "\u30a7art"]}}
{"project": "FFmpeg", "commit_id": "9a3f10695a011861dcf5a649e3e72580b1a4eed4", "target": 1, "func": "static int ra144_encode_frame(AVCodecContext *avctx, uint8_t *frame,\n\n                              int buf_size, void *data)\n\n{\n\n    static const uint8_t sizes[LPC_ORDER] = {64, 32, 32, 16, 16, 8, 8, 8, 8, 4};\n\n    static const uint8_t bit_sizes[LPC_ORDER] = {6, 5, 5, 4, 4, 3, 3, 3, 3, 2};\n\n    RA144Context *ractx;\n\n    PutBitContext pb;\n\n    int32_t lpc_data[NBLOCKS * BLOCKSIZE];\n\n    int32_t lpc_coefs[LPC_ORDER][MAX_LPC_ORDER];\n\n    int shift[LPC_ORDER];\n\n    int16_t block_coefs[NBLOCKS][LPC_ORDER];\n\n    int lpc_refl[LPC_ORDER];    /**< reflection coefficients of the frame */\n\n    unsigned int refl_rms[NBLOCKS]; /**< RMS of the reflection coefficients */\n\n    int energy = 0;\n\n    int i, idx;\n\n\n\n    if (buf_size < FRAMESIZE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"output buffer too small\\n\");\n\n        return 0;\n\n    }\n\n    ractx = avctx->priv_data;\n\n\n\n    /**\n\n     * Since the LPC coefficients are calculated on a frame centered over the\n\n     * fourth subframe, to encode a given frame, data from the next frame is\n\n     * needed. In each call to this function, the previous frame (whose data are\n\n     * saved in the encoder context) is encoded, and data from the current frame\n\n     * are saved in the encoder context to be used in the next function call.\n\n     */\n\n    for (i = 0; i < (2 * BLOCKSIZE + BLOCKSIZE / 2); i++) {\n\n        lpc_data[i] = ractx->curr_block[BLOCKSIZE + BLOCKSIZE / 2 + i];\n\n        energy += (lpc_data[i] * lpc_data[i]) >> 4;\n\n    }\n\n    for (i = 2 * BLOCKSIZE + BLOCKSIZE / 2; i < NBLOCKS * BLOCKSIZE; i++) {\n\n        lpc_data[i] = *((int16_t *)data + i - 2 * BLOCKSIZE - BLOCKSIZE / 2) >>\n\n                      2;\n\n        energy += (lpc_data[i] * lpc_data[i]) >> 4;\n\n    }\n\n    energy = ff_energy_tab[quantize(ff_t_sqrt(energy >> 5) >> 10, ff_energy_tab,\n\n                                    32)];\n\n\n\n    ff_lpc_calc_coefs(&ractx->lpc_ctx, lpc_data, NBLOCKS * BLOCKSIZE, LPC_ORDER,\n\n                      LPC_ORDER, 16, lpc_coefs, shift, FF_LPC_TYPE_LEVINSON,\n\n                      0, ORDER_METHOD_EST, 12, 0);\n\n    for (i = 0; i < LPC_ORDER; i++)\n\n        block_coefs[NBLOCKS - 1][i] = -(lpc_coefs[LPC_ORDER - 1][i] <<\n\n                                        (12 - shift[LPC_ORDER - 1]));\n\n\n\n    /**\n\n     * TODO: apply perceptual weighting of the input speech through bandwidth\n\n     * expansion of the LPC filter.\n\n     */\n\n\n\n    if (ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx)) {\n\n        /**\n\n         * The filter is unstable: use the coefficients of the previous frame.\n\n         */\n\n        ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[1]);\n\n        ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx);\n\n    }\n\n    init_put_bits(&pb, frame, buf_size);\n\n    for (i = 0; i < LPC_ORDER; i++) {\n\n        idx = quantize(lpc_refl[i], ff_lpc_refl_cb[i], sizes[i]);\n\n        put_bits(&pb, bit_sizes[i], idx);\n\n        lpc_refl[i] = ff_lpc_refl_cb[i][idx];\n\n    }\n\n    ractx->lpc_refl_rms[0] = ff_rms(lpc_refl);\n\n    ff_eval_coefs(ractx->lpc_coef[0], lpc_refl);\n\n    refl_rms[0] = ff_interp(ractx, block_coefs[0], 1, 1, ractx->old_energy);\n\n    refl_rms[1] = ff_interp(ractx, block_coefs[1], 2,\n\n                            energy <= ractx->old_energy,\n\n                            ff_t_sqrt(energy * ractx->old_energy) >> 12);\n\n    refl_rms[2] = ff_interp(ractx, block_coefs[2], 3, 0, energy);\n\n    refl_rms[3] = ff_rescale_rms(ractx->lpc_refl_rms[0], energy);\n\n    ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[0]);\n\n    put_bits(&pb, 5, quantize(energy, ff_energy_tab, 32));\n\n    for (i = 0; i < NBLOCKS; i++)\n\n        ra144_encode_subblock(ractx, ractx->curr_block + i * BLOCKSIZE,\n\n                              block_coefs[i], refl_rms[i], &pb);\n\n    flush_put_bits(&pb);\n\n    ractx->old_energy = energy;\n\n    ractx->lpc_refl_rms[1] = ractx->lpc_refl_rms[0];\n\n    FFSWAP(unsigned int *, ractx->lpc_coef[0], ractx->lpc_coef[1]);\n\n    for (i = 0; i < NBLOCKS * BLOCKSIZE; i++)\n\n        ractx->curr_block[i] = *((int16_t *)data + i) >> 2;\n\n    return FRAMESIZE;\n\n}\n", "idx": 5452, "substitutes": {"avctx": [" avcontext", "savcontext", "capcp", "avertx", "capcss", "capctx", "ajctl", " avcc", " avtmp", "abtmp", "abctx", "savctx", "savcp", "abtx", " avctl", "capcontext", "Avctl", " avtx", "avcc", "ajconn", "savcss", "avctl", " avconn", "avcp", "avcss", "avconn", "ajcontext", "avcontext", " avcss", "avtx", "avercc", "avertmp", "avtmp", "Avcontext", "averctx", "Avconn", "Avctx", "ajctx", " avcp", "abcc"], "frame": ["fram", "iframe", "f", " frames", "channel", "frames", "image", "error", "field", "call", "version", "time", "feature", "Frame", "buffer", "row", "command", "code", "flow", "face", "ce", "sequence", "window", "message", "block", "rame", "event"], "buf_size": ["bufbufSIZE", "uf_length", "buf2number", "buf_number", "buf_Size", "bufbufnumber", "uf_Size", "buf_len", "buf2size", "buf2len", "uf_SIZE", "uf_size", " buf_SIZE", "buf_length", " buf_number", "bufbuflen", "bufbufsize", "buf2SIZE", " buf_len", "buf_SIZE"], "data": ["rew", "length", "mu", "image", "frames", "DATA", "padding", " Data", "Data", "feed", "empty", "size", "chain", "value", "bytes", "pointer", "def", "state", "index", "memory", "buf", "step", "response", "zero", "type", "buffer", "text", "ata", "area", " DATA", "res", "raw", "bits", "table", "window", "bin", "message", "block", "next", " buffer", "batch"], "sizes": ["ssized", "csizers", "sizers", "csizes", "csamples", " sized", "ssamples", "ssizers", "sized", "samples", " sizers", " samples", "ssizes", "csized"], "bit_sizes": ["bit_shiz", "bit_Siz", "bit_ssize", "bit_Sizes", "bit_shizers", "bit_siz", "bit_shize", "bit_shizes", "bit_Sizers", "bit_size", "bit_Size", "bit_ssizes", "bit_sizers", "bit_ssizers", "bit_ssiz"], "ractx": ["ractionz", "collectx", "rentxt", "ractionor", "connectlex", "renttx", "ractedx", "investz", "acttx", "rentlex", "ractor", "actX", "collector", "processtx", "racty", "investor", "connectx", "ractedX", "renty", "connectX", "actx", "ractionlex", "collecty", "racttx", "ractedor", "collectxt", "rentor", "ractionxt", "rentx", "ractlex", "investx", "ractz", "ractxt", "processX", "ractionx", "processx", "rentX", "ractiony", "ractionX", "ractX", "ractedz", "investX", "connecty"], "pb": [" prob", "p", "PB", " np", " PB", " ep", " proto", " pl", " clipboard", " offset", " pref", " p", " ab", "buf", " pc", " envelope", " peer", " ssh", " pe", " buf", "uf", "sb", " prot", " protocol", " sketch", " pa", " anew", " eb", " blob"], "lpc_data": ["lpc_values", "lpc___value", "lpo_dict", "lcu___dat", "lPC_fields", "lPC2DATA", "lpo_Data", "lpc4values", "lpc_fields", "lpc___params", "lpc4name", "lpc2options", "lPC_cache", "lcu___data", "lpcityblock", "lmic_values", "lwp_value", "L_", "lpc_Data", "lpc8Data", "lpc_cache", "lcu_dat", "lPC2options", "lpc4Data", "lcu_name", "lPC_block", "lpc___DATA", "lpc0key", "lpc___dat", "lpc0data", "lpc___data", "lpc_block", "lPC_table", "lcu_data", "lpc_value", "lpc_options", "lpc___table", " l_", "lpc0dict", "lmic_name", "lpc_dict", "lpc_params", "l_", "lwp_data", "lcu_Data", "lpc4data", "lpc___Data", "lpc2data", "lpc2table", "lmic_data", "lpc2DATA", "lPC_data", "lpc8name", "lPC2table", "lmic_Data", "lPC_DATA", "lcu___name", "lmic4values", "lpc___name", "lpc_name", "lmic4Data", "lwp_table", "lpo_data", "lpo_key", "lpc_DATA", "lPC2data", "lpc0Data", "lpc8data", "lpcitydata", "lpcityfields", " L_", "lpc8values", "lpc_table", "lwp_params", "lPC_options", "lpcityDATA", "lpc_dat", "lmic4data", "lmic4name", "lpc_key", "lcu___Data", "lpc___options"], "lpc_coefs": ["lpc_coeps", "lpc_coefions", "lpc_coefps", "lpc_coffions", "lpc_coepls", "lpc_coeffls", "lpc_coeffs", "lpc_coeffps", "lpc_coffps", "lpc_coeffions", "lpc_coepps", "lpc_coffs", "lpc_coefls", "lpc_coffls", "lpc_coepions"], "LPC_ORDER": ["LPC_NUMR", "LPC_NUMBER", "LPC_IDR", "LPC_OWNERS", "LPC_ORer", "LPC_ORER", "LPC_ENTR", "LPC_ENTER", "LPC_OrdBER", "LPC_DIRR", "LPC_ORDR", "LPC_ENTBER", "LPC_OrdER", "LPC_OWNR", "LPC_OrdAR", "LPC_ENTERS", "LPC_DIRER", "LPC_IDERS", "LPC_OWNER", "LPC_NUMAR", "LPC_ORBER", "LPC_OWNBER", "LPC_ORDBER", "LPC_NUMer", "LPC_IDer", "LPC_ORDERS", "LPC_NUMERS", "LPC_IDAR", "LPC_ORDAR", "LPC_Order", "LPC_IDBER", "LPC_ORERS", "LPC_ORDer", "LPC_DIRBER", "LPC_ENTer", "LPC_OWNer", "LPC_NUMER", "LPC_IDER", "LPC_DIRer"], "shift": ["Shift", "pack", "balance", "sup", "xff", "hash", "transform", "diff", "offset", "set", "version", "alias", "power", "align", "mix", "center", "jump", "shr", "seed", "ref", "flow", "scale", "mask", "push", "start"], "block_coefs": ["block_cooferences", "block_coffs", "block_coofs", "block_coffers", "block_coefers", "block_coefls", "block_coefferences", "block_coofls", "block_coffls", "block_coeffls", "block_coeferences", "block_coofers", "block_cofferences", "block_coeffers", "block_coeffs"], "NBLOCKS": ["NFLOCKES", "NBLOCKES", "NSLANKs", "NBLKES", "NBLACKS", "NSLOCKINS", "NCLANKs", "NBLANKES", "NBLOCs", "NBLANKS", "NBLICKSIZE", "NBLOCSIZE", "NBLACKSIZE", "NFLANKES", "NSLOCKSI", "NFLANKs", "NBLICKSI", "NSLANKSI", "NSLOCKS", "NCLOCKs", "NBLACKES", "NBLANKSI", "NBLOCKSI", "NBLOCS", "NFLANKS", "NBLOCKs", "NBLOCKSIZE", "NBLOCKINS", "NBLACKINS", "NBLACKs", "NCLANKES", "NFLOCKS", "NCLANKSIZE", "NSLANKINS", "NBLANKINS", "NCLOCKES", "NBLICKINS", "NSLOCKs", "NCLANKS", "NFLOCKs", "NSLANKSIZE", "NCLOCKSIZE", "NCLOCKS", "NBLKs", "NBLACKSI", "NBLOCES", "NSLOCKSIZE", "NBLANKSIZE", "NBLICKS", "NBLKS", "NSLANKS", "NBLICKs", "NBLANKs"], "lpc_refl": ["lpc2refl", "lpc_recl", "lpc_mfl", "lpc_grepl", "lpc_mfr", "lpc_repl", "lpc2refr", "lpc_refr", "lpc_grecl", "lpc_rfr", "lpc2rfr", "lpc2rcl", "lpc_mpl", "lpc2rfl", "lpc2recl", "lpc_rfl", "lpc_grefr", "lpc2repl", "lpc_rcl", "lpc2rpl", "lpc_grefl", "lpc_rpl", "lpc_mcl"], "refl_rms": ["refl_rems", "refl_urMS", "refl_orMS", "refl_urps", "refl_orms", "refl_reps", "refl_rmi", "refl_ormi", "refl_urmi", "refl_orps", "refl_rps", "refl_reMS", "refl_remi", "refl_rMS", "refl_urms"], "i": ["dr", "init", "ei", "li", "p", "sim", "ki", "bi", "is", "f", "a", "id", "ind", "ii", "v", "ini", "l", "mi", "ix", "me", "it", "list", "ic", "parent", "\u0438", "asi", "hi", "uri", "si", "oi", "di", "j", "h", "o", "gi", "depth", "io", "in", "ri", "ji", "ip", "chain", "index", "ui", "multi", "iu", "xi", "y", "ij", "zi", "remote", "e", "ti", "ci", "m", "this", "iii", "ami", "ai", "pi", "im", "ims", "x", "I", "phi", "qi", "cli", "c", "us", "series", "n", "mc", "batch"], "idx": ["indx", " idi", "index", "ridX", " idX", "indi", "indX", "ridi", "idex", "idi", "idX", "ridx", " idex", "ridex"]}}
{"project": "FFmpeg", "commit_id": "86ab6b6e08e2982fb5785e0691c0a7e289339ffb", "target": 0, "func": "static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)\n\n{\n\n    int t = rc->range * (uint64_t)cumFreq / total_freq;\n\n\n\n    rc->code1 += t + 1;\n\n    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);\n\n\n\n    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {\n\n        unsigned byte = bytestream2_get_byte(gb);\n\n        rc->code = (rc->code << 8) | byte;\n\n        rc->code1 <<= 8;\n\n        rc->range <<= 8;\n\n    }\n\n}\n", "idx": 5457, "substitutes": {"gb": ["gm", "gz", "gt", "bt", "eg", "fb", "hub", "pg", "vg", "cb", "gc", "px", "buff", "gio", "gd", "rb", "rg", "bb", "g", "pb", "sg", "mb", "kb", "gs", "buffer", "cgi", "gh", "vm", "Gb", "db", "bg", "tg", "cfg", "gg", "gp", "GB", "storage", "eb", "hw", "yg", "sb", "gif", "bf", "bsp", "nb", "img", "bc"], "rc": ["tc", "isc", "RC", "rw", "pc", "roc", "loc", "cur", "ry", "gc", "ctrl", "row", "ci", "etc", "c", "oc", "hl", "nc", "rm", "wx", "r", "ic", "rl", "obj", "arc", "rh", "proc", "irc", "uc", "ocr", "ck", "instance", "rent", "ce", "auth", "rin", "src", "ack", "sys", "config", "lp", "ctr", "lc", "rr", "dc", "ri", "fc", "rx", "rs", "rec", "rn", "ric", "cs", "aux", "rt", "lib", "cv", "ec", "auc", "sync", "cc", "req", "cr", "anc", "frac", "usr", "rac", "hr", "info", "cmp", "res", "rd", "expr", "ac", "desc", "rb"], "cumFreq": [" cumfrereq", "cumFreeq", "cumFreQ", "cumFrreq", "cumFck", " cumfrerequency", "cumFiqs", "cumFrQ", "cumfrerequency", " cumfreq", " cumFrerequency", "cumFreqs", "cumfreck", " cumFrereq", "cumFreereq", "cuFck", "cumFreeQ", " cumFreqs", "cumFreeve", "cumFiq", "cumSpeve", " cumfreve", " cumfreqs", " cumFreve", "cuFrereq", "cuFq", "cuFreq", "cumFrck", "cumFiQ", " cumFreQ", "cumSpeQ", "cumSpeq", "cuFreQ", "cuFreck", "cumFirequency", "cumfreQ", "cumFreve", "cumFreck", "cumfreve", "cumFrerequency", "cumfreqs", "cuFQ", "cumFrq", "cumFrereq", "cumFq", "cumFQ", "cumfreq", " cumfreQ", "cumfrereq", "cumSpereq"], "freq": ["frqs", "freQ", "frqq", "frreq", " freqs", " freQ", "FreQ", "freqq", " frereq", "Freqs", "freqs", "frq", "Frereq", " freqq", "Freqq", "Freq", "frereq", "frQ"], "total_freq": ["total_waveqs", "total_rej", "total_waveqq", "total_Frej", "total_FreQ", "total_reqs", "total_ratei", "total_Frei", "total_req", "total_feix", "total_freQ", "total_rateqs", "total_rei", "total_freqs", "total_Freqs", "total_frej", "total_waveq", "total_rateq", "total_ratej", "total_frei", "total_feQ", "total_waveQ", "total_feq", "total_Freq", "total_feqs", "total_Freix", "total_Freqq", "total_freix", "total_freqq"]}}
{"project": "qemu", "commit_id": "64a31d5c3d73396a88563d7a504654edc85aa854", "target": 0, "func": "static int dmg_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVDMGState *s = bs->opaque;\n\n    off_t info_begin,info_end,last_in_offset,last_out_offset;\n\n    uint32_t count;\n\n    uint32_t max_compressed_size=1,max_sectors_per_chunk=1,i;\n\n    int64_t offset;\n\n\n\n    s->fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (s->fd < 0)\n\n        return -errno;\n\n    bs->read_only = 1;\n\n    s->n_chunks = 0;\n\n    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;\n\n\n\n    /* read offset of info blocks */\n\n    offset = lseek(s->fd, -0x1d8, SEEK_END);\n\n    if (offset < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    info_begin = read_off(s->fd, offset);\n\n    if (info_begin == 0) {\n\n\tgoto fail;\n\n    }\n\n\n\n    if (read_uint32(s->fd, info_begin) != 0x100) {\n\n        goto fail;\n\n    }\n\n\n\n    count = read_uint32(s->fd, info_begin + 4);\n\n    if (count == 0) {\n\n        goto fail;\n\n    }\n\n    info_end = info_begin + count;\n\n\n\n    offset = info_begin + 0x100;\n\n\n\n    /* read offsets */\n\n    last_in_offset = last_out_offset = 0;\n\n    while (offset < info_end) {\n\n        uint32_t type;\n\n\n\n\tcount = read_uint32(s->fd, offset);\n\n\tif(count==0)\n\n\t    goto fail;\n\n        offset += 4;\n\n\n\n\ttype = read_uint32(s->fd, offset);\n\n\tif (type == 0x6d697368 && count >= 244) {\n\n\t    int new_size, chunk_count;\n\n\n\n            offset += 4;\n\n            offset += 200;\n\n\n\n\t    chunk_count = (count-204)/40;\n\n\t    new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);\n\n\t    s->types = qemu_realloc(s->types, new_size/2);\n\n\t    s->offsets = qemu_realloc(s->offsets, new_size);\n\n\t    s->lengths = qemu_realloc(s->lengths, new_size);\n\n\t    s->sectors = qemu_realloc(s->sectors, new_size);\n\n\t    s->sectorcounts = qemu_realloc(s->sectorcounts, new_size);\n\n\n\n\t    for(i=s->n_chunks;i<s->n_chunks+chunk_count;i++) {\n\n\t\ts->types[i] = read_uint32(s->fd, offset);\n\n\t\toffset += 4;\n\n\t\tif(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) {\n\n\t\t    if(s->types[i]==0xffffffff) {\n\n\t\t\tlast_in_offset = s->offsets[i-1]+s->lengths[i-1];\n\n\t\t\tlast_out_offset = s->sectors[i-1]+s->sectorcounts[i-1];\n\n\t\t    }\n\n\t\t    chunk_count--;\n\n\t\t    i--;\n\n\t\t    offset += 36;\n\n\t\t    continue;\n\n\t\t}\n\n\t\toffset += 4;\n\n\n\n\t\ts->sectors[i] = last_out_offset+read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->sectorcounts[i] = read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->offsets[i] = last_in_offset+read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->lengths[i] = read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\tif(s->lengths[i]>max_compressed_size)\n\n\t\t    max_compressed_size = s->lengths[i];\n\n\t\tif(s->sectorcounts[i]>max_sectors_per_chunk)\n\n\t\t    max_sectors_per_chunk = s->sectorcounts[i];\n\n\t    }\n\n\t    s->n_chunks+=chunk_count;\n\n\t}\n\n    }\n\n\n\n    /* initialize zlib engine */\n\n    s->compressed_chunk = qemu_malloc(max_compressed_size+1);\n\n    s->uncompressed_chunk = qemu_malloc(512*max_sectors_per_chunk);\n\n    if(inflateInit(&s->zstream) != Z_OK)\n\n\tgoto fail;\n\n\n\n    s->current_chunk = s->n_chunks;\n\n\n\n    return 0;\n\nfail:\n\n    close(s->fd);\n\n    return -1;\n\n}\n", "idx": 5482, "substitutes": {"bs": ["ubs", "os", "bos", "bps", "ds", "bh", "bi", "bm", "aus", "ms", "blog", "bes", "ps", "vs", "aos", "ks", "fps", "ss", "ns", "js", "hs", "b", "BS", "ses", "pb", "bl", "rs", "gs", "ts", "es", "obs", "cks", "stats", "acs", "bits", "fs", "its", "bis", "bp", "cs", "sb", "as", "ls", "bc"], "filename": ["fil", "kan", "journal", "fn", "ame", "family", "f", "subject", "binary", "FN", "path", "fle", "file", "prefix", "files", "txt", "username", "uri", "description", "kl", "nm", "location", "source", "ames", "bol", "dir", "name", "buffer", "jpg", "fp", "ename", "fs", "names", "directory", "Filename", "SourceFile"], "flags": ["conf", "properties", " flag", "types", "files", " options", "locks", "options", "FLAG", "kind", "Flag", "Flags", "ns", " whence", "tags", "status", "ts", "faces", "vals", "bits", "fs", "flag", "args", "settings", "fields", "ags"], "s": ["ubs", "p", "l", "locks", "sl", "gets", "self", "ains", "ns", "sq", "ses", "gs", "y", "sn", "stats", "results", "xs", "its", "ims", "ches", "n", "qs", "eps", "S", "ps", "vs", "ins", "w", "less", "ss", "j", "h", "changes", "js", "mods", "b", "http", "sts", "ts", "ops", "ads", "bits", "fs", "sis", "sb", "als", "ats", "sys", "ers", "states", "tests", "sports", "details", "is", "sam", "ports", "params", "aws", "so", "views", "rs", "ids", "m", "bis", "cs", "as", "ls", "ags", "t", "os", "ds", "ms", "ies", "comm", "hs", "erences", "g", "pers", "status", "es", "res", "sv", "ears", "parts", "se", "sw"], "info_begin": ["info_go", "index_Begin", " info2Begin", "info11Begin", "index_end", "inf_begin", "info_enter", "info67bind", " info2coord", "info64begin", " info_gun", "infoThebind", "info64EGIN", " info_Begin", "info2gun", "info_gun", "infoThego", "info_center", "info_bind", "index_center", "info67coord", "info2coord", "info_commit", " info2gun", "info2begin", "inf_EGIN", " info_commit", " info_go", "inf_enter", "info11begin", "info_coord", "info_EGIN", "info67begin", "infoThebegin", "info67gun", " info2begin", " info_EGIN", "info67go", "index_begin", "info11commit", " info_bind", " info_coord", "info67Begin", "infoTheBegin", "info2Begin", "info_Begin", "info64enter"], "info_end": ["inf_end", "info00post", "INFO_post", "info_End", "info00end", "info_END", " info_stop", "inf_End", "info2end", "info2End", "inf_ended", "info_ended", "info_post", "inf_start", "info00begin", "INFO_start", "info_stop", "INFO_begin", " info_END", "info_start", "info2ended", "info00start", " info_start", "INFO_end", "info2start"], "last_in_offset": ["last_inptlength", "last_in_error", "last_in_length", "last_inptoffset", "last_out_off", "last_out_error", "last_out_length", "last_in_Offset", "last_out_Offset", "last_in_off", "last_inptOffset", "last_inpterror"], "last_out_offset": ["last_out_addr", "last_out_index", "last_in_Offset", "last_out_Offset", "last_out_size", "last_in_size", "last_in_index", "last_out_point", "last_in_point", "last_in_addr"], "count": ["p", "conf", "sum", "cont", "call", "C", "counter", "frequency", "cycle", "body", "current", "cond", "page", "c", "n", "z", "cmd", "more", "success", "list", "check", "h", "kind", "index", "name", "comment", "found", "len", "code", "try", "flag", "all", "core", "num", "Count", "total", "nb", "ount", "collection", "limit", "ctr", "version", "depth", "read", "size", "chain", "currency", "amount", "command", "table", "ct", "number", "add", "max", "v", "length", "hash", "country", "force", "cd", "cc", "result", "info", "act", "class", "base", "cache", "batch"], "i": ["init", "t", "p", "limit", "f", "id", "l", "v", "ii", "ind", "it", "j", "ip", "b", "index", "info", "y", "iter", "e", "ci", "ti", "m", "pi", "x", "I", "c", "n"], "offset": ["key", "et", "id", "volume", "error", "field", "offer", "frequency", "alias", "iso", "before", "ET", "slot", "scroll", "fp", "now", "eta", "offs", "ta", "start", "ptr", "extra", "no", "origin", "sp", "OFF", "output", "mt", "pointer", "index", "at", "atomic", "timeout", "operation", "zero", "ref", "buffer", "len", "instance", "flag", "item", "batch", "action", "top", "entry", "adjusted", "order", "reset", "bound", "limit", "balance", "f", "padding", "address", "until", "pad", "location", "size", "off", "point", "shift", "amount", "end", "e", "after", "number", "skip", "length", "to", "position", "prefix", "set", "style", "o", "option", "attribute", "info", "trace", "iterator", "store", "addr", "base", "Offset", "oid", "pos", "next", "seek"], "type": ["tc", "ptr", "key", "t", "TYPE", "cast", "weight", "ty", "id", "types", "length", "token", "ype", "error", "ping", "check", "Type", "style", "kind", "time", "where", "size", "word", "format", "color", "state", "name", "info", "role", "comment", "class", "buffer", "tag", "status", "category", "what", "try", "unit", "table", "base", "test", "title", "ct", "pe", "message", "event"], "new_size": ["new_offset", "new__count", "new_Size", " new_Size", " new_score", "new_error", "new67area", "new_SIZE", " new_area", "new__Size", "new67Size", " new_SIZE", " new_offset", "new__size", "new____error", "newlexscore", "new____size", " new_error", "new____count", "new67size", "new67len", "new_area", "new_len", " new_len", "new_count", "new_score", "new____Size", "new__offset", "newlexSIZE", "newlexsize", "newlexSize", " new_count"], "chunk_count": ["chacket_list", "chunks_total", "chownjcount", "chunkjmax", "chacket8num", "chunk_counter", "chunk6total", "chunks_ind", "chown_amount", "chacket_count", "chunk6ind", "chunk_total", "chunk8list", "chunk32size", "chunk32num", "chunk8ind", "chunk_ind", "chownjmax", "chunk_num", "chown_max", "chunk6count", "chunk_amount", "chunk8num", "chownjamount", "chacket8size", "chunk8size", "chunk_length", "chacket_num", "chunk6length", "chownjcounter", "chunk8count", "chunkjcounter", "chunk_size", "chacket_size", "chunks_count", "chown_counter", "chunks_length", "chunkjcount", "chown_count", "chunkjamount", "chunk_max", "chunk8total", "chunk32count", "chacket8list", "chunk32list", "chacket8count", "chunk8length", "chunk_list"]}}
{"project": "qemu", "commit_id": "df8bf7a7fe75eb5d5caffa55f5cd4292b757aea6", "target": 1, "func": "bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)\n\n{\n\n    assert(pkt);\n\n\n\n    return pkt->vlan_stripped;\n\n}\n", "idx": 5490, "substitutes": {"pkt": [" pix", " put", "vkin", " pct", "Put", "Pact", "vkt", "pct", "Pct", " pnt", "vcmd", "put", "vnt", "pcmd", " pact", "pnt", "pput", "Pix", "pkin", "Pkt", "pakt", "Pnt", "pix", " pkin", "pact", "ppkt", "paix", "ppact", "pant", "Pkin", "Pcmd", "ppnt", " pcmd"]}}
{"project": "qemu", "commit_id": "0920a17199d23b3def3a60fa1fbbdeadcdda452d", "target": 1, "func": "static Visitor *validate_test_init_raw(TestInputVisitorData *data,\n\n                                       const char *json_string)\n\n{\n\n    Visitor *v;\n\n\n\n    data->obj = qobject_from_json(json_string);\n\n    g_assert(data->obj != NULL);\n\n\n\n    data->qiv = qmp_input_visitor_new_strict(data->obj);\n\n    g_assert(data->qiv != NULL);\n\n\n\n    v = qmp_input_get_visitor(data->qiv);\n\n    g_assert(v != NULL);\n\n\n\n    return v;\n\n}\n", "idx": 5500, "substitutes": {"data": ["id", "join", "error", "call", "pro", "di", "valid", "package", "where", "ns", "date", "db", "defined", "message", "start", "json", "query", "analy", "dev", "no", "work", "delete", "database", "draw", "normal", "done", "mu", "dd", "check", "obj", "define", "device", "empty", "dat", "def", "name", "storage", "initial", "num", "auth", "open", "action", "request", "config", "details", "api", "debug", "d", "component", "aw", "ad", "image", "map", "reader", "Data", "read", "size", "format", "state", "definition", "ata", "command", "process", "rel", "table", "missing", "made", "add", "ds", "form", "DATA", "select", "info", "store", "da", "dal", "accept", "update", "al", "input", "batch"], "json_string": ["json_resource", " jsonWresource", "json_join", "jsonWs", "jsonswdump", "jsonswstr", "json_str", "json_dump", "json_s", " jsonWstr", "jsonWresource", " jsonWstring", "jsonetjoin", "son_dump", " json_str", "jsonswstring", "jsonetstring", "jsonWstr", "jsonWstring", " json_resource", "son_str", " json_s", "son_string", "jsonetdump", " jsonWs", "jsonetstr", "jsonswjoin", "son_join"], "v": ["view", "vp", "t", "p", "dev", "tv", "vi", "cv", "f", "vc", "l", "vs", "it", "qv", "inv", "q", "ev", "vv", "nv", "j", "av", "ve", "vr", "u", "h", "i", "b", "V", "ver", "g", "y", "vm", "vo", "mint", "iv", "m", "conv", "sv", "ov", "var", "lv", "x", "vu", "vt", "value", "nov", "vy", "uv"]}}
{"project": "qemu", "commit_id": "660edd4eda903e32811a4929d1434cceda3284aa", "target": 1, "func": "static int connect_namedsocket(const char *path)\n\n{\n\n    int sockfd, size;\n\n    struct sockaddr_un helper;\n\n\n\n    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\n    if (sockfd < 0) {\n\n        fprintf(stderr, \"socket %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    strcpy(helper.sun_path, path);\n\n    helper.sun_family = AF_UNIX;\n\n    size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n\n    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n\n        fprintf(stderr, \"socket error\\n\");\n\n\n        return -1;\n\n    }\n\n\n\n    /* remove the socket for security reasons */\n\n    unlink(path);\n\n    return sockfd;\n\n}", "idx": 5508, "substitutes": {"path": ["key", "p", "host", "pkg", "th", "config", "dest", "full", "temp", "spec", "PATH", "file", "prefix", "address", "txt", "w", "transform", "ATH", "filename", "Path", "self", "h", "kind", "port", "chain", "history", "format", "proc", "pointer", "dir", "name", "type", "ref", "text", "pattern", "m", "rect", "ath", "test", "x", "patch", "user", "message", "context", "value", "stream", "cmd", "template"], "sockfd": ["sinkfc", "socksfs", " sockstream", " sockfc", " sockedstream", "persockfc", "sipptr", " sckfc", "sinkptr", " sockdir", "sckfc", " sockedfd", "persocketfc", "sinkFD", "socketfc", "sckptr", "sackFD", "persockfs", "sckFD", " sckptr", "socketfd", "sinkfd", "sigFD", "sockedfc", "sockFD", "sixfd", "sockptr", "sOCKfd", "socketFD", "sackhandle", "persockfd", "sockfs", "sixstream", "sockstream", " sockFD", " sockhandle", "sOCKdir", "sockedstream", "sockhandle", " sockedhandle", "persockFD", "socksfd", " socksdir", "socksfc", "sixhandle", "sinkfs", "persocketfs", "sackstream", "sockedptr", "sOCKFD", " sockptr", " sipfd", "socksFD", "sigfd", " sckFD", " socksFD", " sipptr", "sockedhandle", "sixFD", "sOCKf", "sigf", "socksptr", " sipFD", "socksdir", "persocketFD", "sockdir", "sockedfd", "sackfd", "sipfc", "sckfd", " sockf", "socketfs", "persocketfd", " socksf", " socksfd", "socksf", "sipFD", "sockfc", "sigdir", " sockedFD", " sckfd", "sipfd", "sockedFD", " sipfc", "sockf"], "size": ["capacity", "small", "max", "Size", "news", "sum", "length", "SIZE", "ize", "sent", "z", "send", "offset", "ose", " Size", "city", "empty", "space", "mem", "name", "fee", "sh", "g", "large", "zero", "height", "len", "area", "sn", "scale", "storage", "number", "count", "sha", "message", "n", "total", "shape", "too", "grow", "seek"], "helper": ["utilpers", "perhelp", "utilper", "shpers", "hater", " Helper", " Helpper", "helppers", "toolpper", "helpter", "hhelp", "hpers", "helping", "halber", "toolper", "toolpers", "hipers", "helpper", "hHelper", "helpers", "perpers", "utilpper", "hiter", "helhelp", " Helpers", "shper", " Helter", "hiper", "shpper", "helpping", "utilping", "shter", "perper", "hper", "happer", "perHelper", "helpHelper", "perpper", "halper", "haber", "halter", "helphelp", "hapers", "helber", "helppper", "toolber", "helter", "haper", "halpper", "helpber", "halpers", "hipper", "helHelper", "perping"]}}
{"project": "qemu", "commit_id": "a1c3e4b839f8e7ec7f1792b8a11c63ca845aa021", "target": 1, "func": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)\n{\n    EHCIState *s = ptr;\n    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);\n    uint32_t old = *mmio;\n    int i;\n    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);\n    /* Only aligned reads are allowed on OHCI */\n    if (addr & 3) {\n        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"\n                TARGET_FMT_plx \"\\n\", addr);\n        return;\n    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {\n        handle_port_status_write(s, (addr-PORTSC)/4, val);\n        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n        return;\n    if (addr < OPREGBASE) {\n        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"\n                TARGET_FMT_plx \"\\n\", addr);\n        return;\n    /* Do any register specific pre-write processing here.  */\n    switch(addr) {\n    case USBCMD:\n        if (val & USBCMD_HCRESET) {\n            ehci_reset(s);\n            val = s->usbcmd;\n            break;\n        /* not supporting dynamic frame list size at the moment */\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n                    val & USBCMD_FLS);\n            val &= ~USBCMD_FLS;\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n            if (s->pstate == EST_INACTIVE) {\n                SET_LAST_RUN_CLOCK(s);\n            s->usbcmd = val; /* Set usbcmd for ehci_update_halt() */\n            ehci_update_halt(s);\n            qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));\n        break;\n    case USBSTS:\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n        val = s->usbsts;\n        ehci_update_irq(s);\n        break;\n    case USBINTR:\n        val &= USBINTR_MASK;\n        break;\n    case FRINDEX:\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n        break;\n    case CONFIGFLAG:\n        val &= 0x1;\n        if (val) {\n            for(i = 0; i < NB_PORTS; i++)\n                handle_port_owner_write(s, i, 0);\n        break;\n    case PERIODICLISTBASE:\n        if (ehci_periodic_enabled(s)) {\n            fprintf(stderr,\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n              \"      is enabled and HC is enabled\\n\");\n        break;\n    case ASYNCLISTADDR:\n        if (ehci_async_enabled(s)) {\n            fprintf(stderr,\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n              \"      is enabled and HC is enabled\\n\");\n        break;\n    *mmio = val;\n    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);", "idx": 5509, "substitutes": {"ptr": ["dr", "t", "p", "inter", "th", "ctr", "ind", "v", "sp", "r", "arr", "att", "ctx", "ps", "cont", "pointers", "address", "obj", "req", "handle", "h", "ry", "pad", "pt", "dh", "ret", "js", "mem", "proc", "pointer", "resp", "Ptr", "pr", "rev", "ref", "store", "alloc", "ts", "rect", "tr", "ash", "rt", "err", "add"], "addr": ["host", "eth", "pkg", "id", "arr", "msg", "loc", "alias", "handle", "dh", "md", "net", "row", "iter", "coord", "tx", "arm", "hl", "url", "cmd", "oa", "ace", "old", "inter", "work", "arg", "sp", "data", "r", "ix", "ctx", "dd", "obj", "lat", "kt", "ret", "arp", "mem", "mt", "index", "name", "at", "ref", "ord", "len", "ck", "x", "on", "src", "grad", "ack", "sys", "rc", "order", "ctr", "ind", "ad", "address", "trans", "ld", "pad", "adr", "size", "ip", "np", "state", "mac", "rs", "rel", "Address", "var", "alt", "rt", "add", "dr", "init", "phys", "elt", "ser", "v", "hash", "tz", "offset", "set", "gate", "attr", "act", "rev", "tp", "cmp", "ar", "res", "hw", "ac", "ash", "pos", "err"], "val": ["key", "VAL", "p", "sel", "it", "loc", "valid", "pt", "slot", "pol", "ival", "tx", " ret", "cmd", "Val", "aval", "old", "inter", "dev", "el", "arg", "data", "ctx", "obj", "ve", "ret", "mem", "def", "index", " v", "ref", "len", "stat", "rol", "num", "x", "vol", "grad", "sol", "eval", " eval", "high", " vel", " value", "rel", "var", "alt", "V", "vt", "reg", "doc", "elt", "cho", "v", "hash", "set", "prop", "hold", "bal", "resp", "orig", "buf", " Val", "pr", "status", " update", " valid", "res", "vals", " arg", "sv", "test", "cal", "al", "pos", "value", "err"], "s": ["t", "os", "S", "p", "ds", "is", "ms", "v", "sp", "r", "ps", "vs", "spec", "sm", "z", "serv", "sync", "sl", "w", "sam", "obj", "set", "ss", "self", "st", "h", "j", "comm", "aws", "changes", "bs", "js", "ns", "hs", "ssl", "b", "state", "sq", "sd", "g", "ses", "sts", "rs", "store", "gs", "status", "ts", "es", "e", "stats", "m", "bits", "fs", "sv", "cs", "ims", "sb", "c", "als", "ls", "n", "qs", "sys", "ats", "se", "sw"], "mmio": ["memio", "dmios", "memcho", "mmi", "lammio", "mlio", " mmcho", "ramiot", "mpios", "mmao", "mmmiol", "mlia", " mmie", "mmios", "mpi", "mmiot", "ramio", "memios", " mmIO", "dmIO", "wmios", "mlie", "lammao", "mmmio", "lammios", "mmcho", "mmia", "mmie", "ramios", "wmi", "memie", "wmio", "dmio", " mmiot", "mpiol", "memIO", "wmiol", "memia", "lammiot", "mmmi", "ramao", "mlios", "mmiol", "mmIO", "mmmios", "mpio", " mmia", " mmao", "dmcho", " mmios"], "i": ["t", " tmp", " l", "p", " err", " max", " ref", "v", " var", "r", " offset", "set", " init", "or", " ip", " start", " rel", " stored", " out", " res", " len", "x", " dist", "Val", " sp"]}}
{"project": "FFmpeg", "commit_id": "cf7d2f2d2134c0854edf2db91e7436ac2bc9874f", "target": 0, "func": "static av_cold int dnxhd_encode_init(AVCodecContext *avctx)\n\n{\n\n    DNXHDEncContext *ctx = avctx->priv_data;\n\n    int i, index, bit_depth, ret;\n\n\n\n    switch (avctx->pix_fmt) {\n\n    case AV_PIX_FMT_YUV422P:\n\n        bit_depth = 8;\n\n        break;\n\n    case AV_PIX_FMT_YUV422P10:\n\n        bit_depth = 10;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"pixel format is incompatible with DNxHD\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->cid = ff_dnxhd_find_cid(avctx, bit_depth);\n\n    if (!ctx->cid) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"video parameters incompatible with DNxHD\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    av_log(avctx, AV_LOG_DEBUG, \"cid %d\\n\", ctx->cid);\n\n\n\n    index = ff_dnxhd_get_cid_table(ctx->cid);\n\n    if (index < 0)\n\n        return index;\n\n    ctx->cid_table = &ff_dnxhd_cid_table[index];\n\n\n\n    ctx->m.avctx    = avctx;\n\n    ctx->m.mb_intra = 1;\n\n    ctx->m.h263_aic = 1;\n\n\n\n    avctx->bits_per_raw_sample = ctx->cid_table->bit_depth;\n\n\n\n    ff_blockdsp_init(&ctx->bdsp, avctx);\n\n    ff_fdctdsp_init(&ctx->m.fdsp, avctx);\n\n    ff_mpv_idct_init(&ctx->m);\n\n    ff_mpegvideoencdsp_init(&ctx->m.mpvencdsp, avctx);\n\n    ff_pixblockdsp_init(&ctx->m.pdsp, avctx);\n\n    if (!ctx->m.dct_quantize)\n\n        ctx->m.dct_quantize = ff_dct_quantize_c;\n\n\n\n    if (ctx->cid_table->bit_depth == 10) {\n\n        ctx->m.dct_quantize     = dnxhd_10bit_dct_quantize;\n\n        ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;\n\n        ctx->block_width_l2     = 4;\n\n    } else {\n\n        ctx->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym;\n\n        ctx->block_width_l2     = 3;\n\n    }\n\n\n\n    if (ARCH_X86)\n\n        ff_dnxhdenc_init_x86(ctx);\n\n\n\n    ctx->m.mb_height = (avctx->height + 15) / 16;\n\n    ctx->m.mb_width  = (avctx->width  + 15) / 16;\n\n\n\n    if (avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT) {\n\n        ctx->interlaced   = 1;\n\n        ctx->m.mb_height /= 2;\n\n    }\n\n\n\n    ctx->m.mb_num = ctx->m.mb_height * ctx->m.mb_width;\n\n\n\n#if FF_API_QUANT_BIAS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (ctx->intra_quant_bias == FF_DEFAULT_QUANT_BIAS &&\n\n        avctx->intra_quant_bias != FF_DEFAULT_QUANT_BIAS)\n\n        ctx->intra_quant_bias = avctx->intra_quant_bias;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    // XXX tune lbias/cbias\n\n    if ((ret = dnxhd_init_qmat(ctx, ctx->intra_quant_bias, 0)) < 0)\n\n        return ret;\n\n\n\n    /* Avid Nitris hardware decoder requires a minimum amount of padding\n\n     * in the coding unit payload */\n\n    if (ctx->nitris_compat)\n\n        ctx->min_padding = 1600;\n\n\n\n    if ((ret = dnxhd_init_vlc(ctx)) < 0)\n\n        return ret;\n\n    if ((ret = dnxhd_init_rc(ctx)) < 0)\n\n        return ret;\n\n\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size,\n\n                      ctx->m.mb_height * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs,\n\n                      ctx->m.mb_height * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits,\n\n                      ctx->m.mb_num * sizeof(uint16_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale,\n\n                      ctx->m.mb_num * sizeof(uint8_t), fail);\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    if (avctx->thread_count > MAX_THREADS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"too many threads\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->thread[0] = ctx;\n\n    for (i = 1; i < avctx->thread_count; i++) {\n\n        ctx->thread[i] = av_malloc(sizeof(DNXHDEncContext));\n\n        memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext));\n\n    }\n\n\n\n    return 0;\n\nfail:  // for FF_ALLOCZ_OR_GOTO\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 5539, "substitutes": {"avctx": [" avcontext", "avecm", "averreq", "wavctx", "AVcp", "averconn", "avecrit", "avcmd", "AVcfg", " avcb", " avcmd", "avectx", "averkt", "avercrit", "awctx", "AVcrit", "wavcmd", "avetc", "averdj", "avertmp", " avsetup", "savcrit", " avcmp", "navdj", "savcontext", "ajjp", "savtx", "avecb", "avercm", "wavcontext", "afctx", "navctx", "savtmp", "savctx", "savconf", "avetx", " avkt", " avjac", "wavhistory", "avejp", " avtx", "avcrit", "avecmp", "avercmp", " avcrit", "avdj", "savcmd", "averjac", "avcp", "avertc", "savhistory", "avetmp", "avercontext", "avcontext", "avtc", "averctx", "avtmp", "avekt", "AVtx", "ajctx", "aversetup", " avconf", "avercmd", " avhistory", "navcontext", "avkt", "wavreq", "avercfg", "avjac", "avcfg", "avercb", "awcmp", "avercomp", "avesetup", "avecp", "AVcmp", "vercmp", "ajkt", "avjp", "awtx", "avecomp", "wavkt", "avconf", " avconn", "avhistory", "ajtc", "averjp", "avcm", "AVcontext", "avecfg", "vercp", "avconn", "avcb", "avsetup", " avcomp", "avecontext", "awcontext", "AVctx", "avreq", "afconn", "afcmp", "avertx", "afcontext", " avtmp", "ajcrit", "vercfg", "avcmp", " avdj", "wavcfg", "navjac", "avcomp", "ajcm", " avcfg", "avecmd", "avereq", "avtx", "verctx", "aveconf"], "ctx": ["tc", "co", "conf", "pkg", "conn", "iac", "nt", "msg", "txt", "loc", "cn", "gc", "ctrl", "etc", "tx", "c", "settings", "Context", "kw", "cas", "ctl", "nc", "mc", "cmd", "json", "sc", "cm", "cp", "jac", "handler", "wx", "scope", "check", "obj", "crit", "kt", "proc", "timeout", "ck", "dad", "acl", "context", "sys", "voc", "ia", "rc", "cu", "config", "temp", "func", "lc", "dc", "cb", "ok", "np", "point", "std", "command", "conv", "iat", "that", "ct", "aux", "local", "unc", "td", "cv", "cookie", "prefix", "inst", "cc", "prop", "abc", "req", "course", "module", "kl", "anc", "history", "resp", "info", "act", "cmp", "cf", "jp", "cfg", "xc", "ca", "hw", "expr", "ac", "desc", "ppo", "xp", "params", "bc"], "i": ["li", "p", "bi", "l", "ii", "v", "mi", " bi", "it", "si", "j", "ip", "b", " v", "y", "e", "ci", "ti", "m", "ai", "pi", " j", "x", "I", "c", "n", " ii"], "index": ["search", "key", "init", "fail", "request", "query", "max", "no", "success", "nil", "id", "ind", "data", "col", "length", "list", "image", "condition", "error", "inn", "position", "check", "address", "loc", "offset", "val", "set", "ion", "axis", "IND", "port", "empty", "location", "size", "result", "info", "point", "connect", "slice", "level", "timeout", "interface", "zero", "row", "new", "Index", "iter", "find", "column", "instance", "unknown", "table", "missing", "initial", "test", "num", "number", "count", "x", "pos", "n", "input", "value", "err", "seek"], "bit_depth": ["bit_width", "bitLengthdepth", "byte_depth", "bit_Depth", "bit2depth", "bit_level", "bit_module", " bit_details", "byte_length", "bit2size", " bit_deep", "bit_length", " bit_length", "bit_details", "bit_size", "bittlength", "bit_default", "bittdepth", "bit2width", " bit_density", "bit2length", "bitlengthlength", " bit_module", "bitLengthlength", " bit_level", "byte_domain", "bitLengthmodule", "bitlengthdepth", "bitlengthdensity", " bit_Depth", "byte_width", "bitLengthdeep", "bit_density", "bittdetails", "bit_distance", "byte_default", " bit_distance", "byte_size", "bit_deep", "bit_domain", "bitlengthdetails", "bittdensity"], "ret": ["rew", "reset", "gt", "fi", "ll", "arr", "re", "mi", "ft", "txt", "val", "rem", "mem", "result", "ref", "new", "match", "print", "jp", "res", "rel", "bool", "alt", "out"]}}
{"project": "FFmpeg", "commit_id": "ccce723c6d0ea1ea89ea6c47160a07d37cdeeba2", "target": 0, "func": "static int vc1_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size, n_slices = 0, i;\n\n    VC1Context *v = avctx->priv_data;\n\n    MpegEncContext *s = &v->s;\n\n    AVFrame *pict = data;\n\n    uint8_t *buf2 = NULL;\n\n    const uint8_t *buf_start = buf, *buf_start_second_field = NULL;\n\n    int mb_height, n_slices1=-1;\n\n    struct {\n\n        uint8_t *buf;\n\n        GetBitContext gb;\n\n        int mby_start;\n\n    } *slices = NULL, *tmp;\n\n\n\n    v->second_field = 0;\n\n\n\n    if(s->flags & CODEC_FLAG_LOW_DELAY)\n\n        s->low_delay = 1;\n\n\n\n    /* no supplementary picture */\n\n    if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == VC1_CODE_ENDOFSEQ)) {\n\n        /* special case for last picture */\n\n        if (s->low_delay == 0 && s->next_picture_ptr) {\n\n            *pict = s->next_picture_ptr->f;\n\n            s->next_picture_ptr = NULL;\n\n\n\n            *data_size = sizeof(AVFrame);\n\n        }\n\n\n\n        return buf_size;\n\n    }\n\n\n\n    if (s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) {\n\n        if (v->profile < PROFILE_ADVANCED)\n\n            avctx->pix_fmt = AV_PIX_FMT_VDPAU_WMV3;\n\n        else\n\n            avctx->pix_fmt = AV_PIX_FMT_VDPAU_VC1;\n\n    }\n\n\n\n    //for advanced profile we may need to parse and unescape data\n\n    if (avctx->codec_id == AV_CODEC_ID_VC1 || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {\n\n        int buf_size2 = 0;\n\n        buf2 = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n        if (IS_MARKER(AV_RB32(buf))) { /* frame starts with marker and needs to be parsed */\n\n            const uint8_t *start, *end, *next;\n\n            int size;\n\n\n\n            next = buf;\n\n            for (start = buf, end = buf + buf_size; next < end; start = next) {\n\n                next = find_next_marker(start + 4, end);\n\n                size = next - start - 4;\n\n                if (size <= 0) continue;\n\n                switch (AV_RB32(start)) {\n\n                case VC1_CODE_FRAME:\n\n                    if (avctx->hwaccel ||\n\n                        s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                        buf_start = start;\n\n                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);\n\n                    break;\n\n                case VC1_CODE_FIELD: {\n\n                    int buf_size3;\n\n                    if (avctx->hwaccel ||\n\n                        s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                        buf_start_second_field = start;\n\n                    tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1));\n\n                    if (!tmp)\n\n                        goto err;\n\n                    slices = tmp;\n\n                    slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n                    if (!slices[n_slices].buf)\n\n                        goto err;\n\n                    buf_size3 = vc1_unescape_buffer(start + 4, size,\n\n                                                    slices[n_slices].buf);\n\n                    init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,\n\n                                  buf_size3 << 3);\n\n                    /* assuming that the field marker is at the exact middle,\n\n                       hope it's correct */\n\n                    slices[n_slices].mby_start = s->mb_height >> 1;\n\n                    n_slices1 = n_slices - 1; // index of the last slice of the first field\n\n                    n_slices++;\n\n                    break;\n\n                }\n\n                case VC1_CODE_ENTRYPOINT: /* it should be before frame data */\n\n                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);\n\n                    init_get_bits(&s->gb, buf2, buf_size2 * 8);\n\n                    ff_vc1_decode_entry_point(avctx, v, &s->gb);\n\n                    break;\n\n                case VC1_CODE_SLICE: {\n\n                    int buf_size3;\n\n                    tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1));\n\n                    if (!tmp)\n\n                        goto err;\n\n                    slices = tmp;\n\n                    slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n                    if (!slices[n_slices].buf)\n\n                        goto err;\n\n                    buf_size3 = vc1_unescape_buffer(start + 4, size,\n\n                                                    slices[n_slices].buf);\n\n                    init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,\n\n                                  buf_size3 << 3);\n\n                    slices[n_slices].mby_start = get_bits(&slices[n_slices].gb, 9);\n\n                    n_slices++;\n\n                    break;\n\n                }\n\n                }\n\n            }\n\n        } else if (v->interlace && ((buf[0] & 0xC0) == 0xC0)) { /* WVC1 interlaced stores both fields divided by marker */\n\n            const uint8_t *divider;\n\n            int buf_size3;\n\n\n\n            divider = find_next_marker(buf, buf + buf_size);\n\n            if ((divider == (buf + buf_size)) || AV_RB32(divider) != VC1_CODE_FIELD) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Error in WVC1 interlaced frame\\n\");\n\n                goto err;\n\n            } else { // found field marker, unescape second field\n\n                if (avctx->hwaccel ||\n\n                    s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                    buf_start_second_field = divider;\n\n                tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1));\n\n                if (!tmp)\n\n                    goto err;\n\n                slices = tmp;\n\n                slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n                if (!slices[n_slices].buf)\n\n                    goto err;\n\n                buf_size3 = vc1_unescape_buffer(divider + 4, buf + buf_size - divider - 4, slices[n_slices].buf);\n\n                init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,\n\n                              buf_size3 << 3);\n\n                slices[n_slices].mby_start = s->mb_height >> 1;\n\n                n_slices1 = n_slices - 1;\n\n                n_slices++;\n\n            }\n\n            buf_size2 = vc1_unescape_buffer(buf, divider - buf, buf2);\n\n        } else {\n\n            buf_size2 = vc1_unescape_buffer(buf, buf_size, buf2);\n\n        }\n\n        init_get_bits(&s->gb, buf2, buf_size2*8);\n\n    } else\n\n        init_get_bits(&s->gb, buf, buf_size*8);\n\n\n\n    if (v->res_sprite) {\n\n        v->new_sprite  = !get_bits1(&s->gb);\n\n        v->two_sprites =  get_bits1(&s->gb);\n\n        /* res_sprite means a Windows Media Image stream, AV_CODEC_ID_*IMAGE means\n\n           we're using the sprite compositor. These are intentionally kept separate\n\n           so you can get the raw sprites by using the wmv3 decoder for WMVP or\n\n           the vc1 one for WVP2 */\n\n        if (avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {\n\n            if (v->new_sprite) {\n\n                // switch AVCodecContext parameters to those of the sprites\n\n                avctx->width  = avctx->coded_width  = v->sprite_width;\n\n                avctx->height = avctx->coded_height = v->sprite_height;\n\n            } else {\n\n                goto image;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (s->context_initialized &&\n\n        (s->width  != avctx->coded_width ||\n\n         s->height != avctx->coded_height)) {\n\n        ff_vc1_decode_end(avctx);\n\n    }\n\n\n\n    if (!s->context_initialized) {\n\n        if (ff_msmpeg4_decode_init(avctx) < 0 || ff_vc1_decode_init_alloc_tables(v) < 0)\n\n            goto err;\n\n\n\n        s->low_delay = !avctx->has_b_frames || v->res_sprite;\n\n\n\n        if (v->profile == PROFILE_ADVANCED) {\n\n            s->h_edge_pos = avctx->coded_width;\n\n            s->v_edge_pos = avctx->coded_height;\n\n        }\n\n    }\n\n\n\n    /* We need to set current_picture_ptr before reading the header,\n\n     * otherwise we cannot store anything in there. */\n\n    if (s->current_picture_ptr == NULL || s->current_picture_ptr->f.data[0]) {\n\n        int i = ff_find_unused_picture(s, 0);\n\n        if (i < 0)\n\n            goto err;\n\n        s->current_picture_ptr = &s->picture[i];\n\n    }\n\n\n\n    // do parse frame header\n\n    v->pic_header_flag = 0;\n\n    if (v->profile < PROFILE_ADVANCED) {\n\n        if (ff_vc1_parse_frame_header(v, &s->gb) < 0) {\n\n            goto err;\n\n        }\n\n    } else {\n\n        if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n            goto err;\n\n        }\n\n    }\n\n\n\n    if (avctx->debug & FF_DEBUG_PICT_INFO)\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"pict_type: %c\\n\", av_get_picture_type_char(s->pict_type));\n\n\n\n    if ((avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE)\n\n        && s->pict_type != AV_PICTURE_TYPE_I) {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Sprite decoder: expected I-frame\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if ((s->mb_height >> v->field_mode) == 0) {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"image too short\\n\");\n\n        goto err;\n\n    }\n\n\n\n    // process pulldown flags\n\n    s->current_picture_ptr->f.repeat_pict = 0;\n\n    // Pulldown flags are only valid when 'broadcast' has been set.\n\n    // So ticks_per_frame will be 2\n\n    if (v->rff) {\n\n        // repeat field\n\n        s->current_picture_ptr->f.repeat_pict = 1;\n\n    } else if (v->rptfrm) {\n\n        // repeat frames\n\n        s->current_picture_ptr->f.repeat_pict = v->rptfrm * 2;\n\n    }\n\n\n\n    // for skipping the frame\n\n    s->current_picture.f.pict_type = s->pict_type;\n\n    s->current_picture.f.key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n\n\n    /* skip B-frames if we don't have reference frames */\n\n    if (s->last_picture_ptr == NULL && (s->pict_type == AV_PICTURE_TYPE_B || s->dropable)) {\n\n        goto err;\n\n    }\n\n    if ((avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B) ||\n\n        (avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I) ||\n\n         avctx->skip_frame >= AVDISCARD_ALL) {\n\n        goto end;\n\n    }\n\n\n\n    if (s->next_p_frame_damaged) {\n\n        if (s->pict_type == AV_PICTURE_TYPE_B)\n\n            goto end;\n\n        else\n\n            s->next_p_frame_damaged = 0;\n\n    }\n\n\n\n    if (ff_MPV_frame_start(s, avctx) < 0) {\n\n        goto err;\n\n    }\n\n\n\n    v->s.current_picture_ptr->f.interlaced_frame = (v->fcm != PROGRESSIVE);\n\n    v->s.current_picture_ptr->f.top_field_first  = v->tff;\n\n\n\n    s->me.qpel_put = s->dsp.put_qpel_pixels_tab;\n\n    s->me.qpel_avg = s->dsp.avg_qpel_pixels_tab;\n\n\n\n    if ((CONFIG_VC1_VDPAU_DECODER)\n\n        &&s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n        ff_vdpau_vc1_decode_picture(s, buf_start, (buf + buf_size) - buf_start);\n\n    else if (avctx->hwaccel) {\n\n        if (v->field_mode && buf_start_second_field) {\n\n            // decode first field\n\n            s->picture_structure = PICT_BOTTOM_FIELD - v->tff;\n\n            if (avctx->hwaccel->start_frame(avctx, buf_start, buf_start_second_field - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->decode_slice(avctx, buf_start, buf_start_second_field - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->end_frame(avctx) < 0)\n\n                goto err;\n\n\n\n            // decode second field\n\n            s->gb = slices[n_slices1 + 1].gb;\n\n            s->picture_structure = PICT_TOP_FIELD + v->tff;\n\n            v->second_field = 1;\n\n            v->pic_header_flag = 0;\n\n            if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"parsing header for second field failed\");\n\n                goto err;\n\n            }\n\n            v->s.current_picture_ptr->f.pict_type = v->s.pict_type;\n\n\n\n            if (avctx->hwaccel->start_frame(avctx, buf_start_second_field, (buf + buf_size) - buf_start_second_field) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->decode_slice(avctx, buf_start_second_field, (buf + buf_size) - buf_start_second_field) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->end_frame(avctx) < 0)\n\n                goto err;\n\n        } else {\n\n            s->picture_structure = PICT_FRAME;\n\n            if (avctx->hwaccel->start_frame(avctx, buf_start, (buf + buf_size) - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->decode_slice(avctx, buf_start, (buf + buf_size) - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->end_frame(avctx) < 0)\n\n                goto err;\n\n        }\n\n    } else {\n\n        if (v->fcm == ILACE_FRAME && s->pict_type == AV_PICTURE_TYPE_B)\n\n            goto err; // This codepath is still incomplete thus it is disabled\n\n\n\n        ff_er_frame_start(s);\n\n\n\n        v->bits = buf_size * 8;\n\n        v->end_mb_x = s->mb_width;\n\n        if (v->field_mode) {\n\n            uint8_t *tmp[2];\n\n            s->current_picture.f.linesize[0] <<= 1;\n\n            s->current_picture.f.linesize[1] <<= 1;\n\n            s->current_picture.f.linesize[2] <<= 1;\n\n            s->linesize                      <<= 1;\n\n            s->uvlinesize                    <<= 1;\n\n            tmp[0]          = v->mv_f_last[0];\n\n            tmp[1]          = v->mv_f_last[1];\n\n            v->mv_f_last[0] = v->mv_f_next[0];\n\n            v->mv_f_last[1] = v->mv_f_next[1];\n\n            v->mv_f_next[0] = v->mv_f[0];\n\n            v->mv_f_next[1] = v->mv_f[1];\n\n            v->mv_f[0] = tmp[0];\n\n            v->mv_f[1] = tmp[1];\n\n        }\n\n        mb_height = s->mb_height >> v->field_mode;\n\n        for (i = 0; i <= n_slices; i++) {\n\n            if (i > 0 &&  slices[i - 1].mby_start >= mb_height) {\n\n                if (v->field_mode <= 0) {\n\n                    av_log(v->s.avctx, AV_LOG_ERROR, \"Slice %d starts beyond \"\n\n                           \"picture boundary (%d >= %d)\\n\", i,\n\n                           slices[i - 1].mby_start, mb_height);\n\n                    continue;\n\n                }\n\n                v->second_field = 1;\n\n                v->blocks_off   = s->mb_width  * s->mb_height << 1;\n\n                v->mb_off       = s->mb_stride * s->mb_height >> 1;\n\n            } else {\n\n                v->second_field = 0;\n\n                v->blocks_off   = 0;\n\n                v->mb_off       = 0;\n\n            }\n\n            if (i) {\n\n                v->pic_header_flag = 0;\n\n                if (v->field_mode && i == n_slices1 + 2) {\n\n                    if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n                        av_log(v->s.avctx, AV_LOG_ERROR, \"Field header damaged\\n\");\n\n                        continue;\n\n                    }\n\n                } else if (get_bits1(&s->gb)) {\n\n                    v->pic_header_flag = 1;\n\n                    if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n                        av_log(v->s.avctx, AV_LOG_ERROR, \"Slice header damaged\\n\");\n\n                        continue;\n\n                    }\n\n                }\n\n            }\n\n            s->start_mb_y = (i == 0) ? 0 : FFMAX(0, slices[i-1].mby_start % mb_height);\n\n            if (!v->field_mode || v->second_field)\n\n                s->end_mb_y = (i == n_slices     ) ? mb_height : FFMIN(mb_height, slices[i].mby_start % mb_height);\n\n            else\n\n                s->end_mb_y = (i <= n_slices1 + 1) ? mb_height : FFMIN(mb_height, slices[i].mby_start % mb_height);\n\n            if (s->end_mb_y <= s->start_mb_y) {\n\n                av_log(v->s.avctx, AV_LOG_ERROR, \"end mb y %d %d invalid\\n\", s->end_mb_y, s->start_mb_y);\n\n                continue;\n\n            }\n\n            ff_vc1_decode_blocks(v);\n\n            if (i != n_slices)\n\n                s->gb = slices[i].gb;\n\n        }\n\n        if (v->field_mode) {\n\n            v->second_field = 0;\n\n            if (s->pict_type == AV_PICTURE_TYPE_B) {\n\n                memcpy(v->mv_f_base, v->mv_f_next_base,\n\n                       2 * (s->b8_stride * (s->mb_height * 2 + 1) + s->mb_stride * (s->mb_height + 1) * 2));\n\n            }\n\n            s->current_picture.f.linesize[0] >>= 1;\n\n            s->current_picture.f.linesize[1] >>= 1;\n\n            s->current_picture.f.linesize[2] >>= 1;\n\n            s->linesize                      >>= 1;\n\n            s->uvlinesize                    >>= 1;\n\n        }\n\n        av_dlog(s->avctx, \"Consumed %i/%i bits\\n\",\n\n                get_bits_count(&s->gb), s->gb.size_in_bits);\n\n//  if (get_bits_count(&s->gb) > buf_size * 8)\n\n//      return -1;\n\n        if(s->error_occurred && s->pict_type == AV_PICTURE_TYPE_B)\n\n            goto err;\n\n        if(!v->field_mode)\n\n            ff_er_frame_end(s);\n\n    }\n\n\n\n    ff_MPV_frame_end(s);\n\n\n\n    if (avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {\n\nimage:\n\n        avctx->width  = avctx->coded_width  = v->output_width;\n\n        avctx->height = avctx->coded_height = v->output_height;\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF)\n\n            goto end;\n\n#if CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER\n\n        if (vc1_decode_sprites(v, &s->gb))\n\n            goto err;\n\n#endif\n\n        *pict      = v->sprite_output_frame;\n\n        *data_size = sizeof(AVFrame);\n\n    } else {\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            *pict = s->current_picture_ptr->f;\n\n        } else if (s->last_picture_ptr != NULL) {\n\n            *pict = s->last_picture_ptr->f;\n\n        }\n\n        if (s->last_picture_ptr || s->low_delay) {\n\n            *data_size = sizeof(AVFrame);\n\n            ff_print_debug_info(s, pict);\n\n        }\n\n    }\n\n\n\nend:\n\n    av_free(buf2);\n\n    for (i = 0; i < n_slices; i++)\n\n        av_free(slices[i].buf);\n\n    av_free(slices);\n\n    return buf_size;\n\n\n\nerr:\n\n    av_free(buf2);\n\n    for (i = 0; i < n_slices; i++)\n\n        av_free(slices[i].buf);\n\n    av_free(slices);\n\n    return -1;\n\n}\n", "idx": 5567, "substitutes": {"avctx": [" avcontext", "wavctx", "cvcmp", "vrtx", "abctx", "avcmd", " avcmd", "wavconn", "avectx", "wavtx", "vrcas", "ahcookie", "abconn", "awctx", "avectl", "camjp", "vrjp", " avcmp", "abcontext", "ahpkg", "Avtx", "vconn", "vrctx", " avtxt", "vertx", "afctl", "afctx", "abtx", "awjac", "avetx", " avcookie", " avjac", " avtx", " avcas", "avctl", "ahctx", "cvcontext", "vrctl", "avpkg", "cvctx", "vtx", "avcontext", "averctx", "avertxt", "vctx", "Avctx", "avtxt", "vrcmp", "awcmd", "vrcontext", "averpkg", "avjac", "avcfg", "camctx", "afjp", "avjp", "awtx", "avcookie", " avconn", "avconn", "vccas", "afcmp", "vccfg", "verjac", "wavctl", "ahtxt", " avpkg", "vcontext", "avcas", "vcctx", "camcmp", "avcmp", "Avctl", "aveconn", "vccmd", " avcfg", "avtx", "verctx", "Avconn", "vrcmd", "vrcfg", "avercookie", "vercmd", "camctl", "cvtx"], "data": ["t", "doc", "p", "present", "frame", "f", "a", "d", "length", "mu", "image", "file", "DATA", "padding", "obj", "str", "RAW", "png", "nothing", "pad", "Data", "output", "empty", "dat", "bytes", "def", "name", "input", "zero", "buffer", "text", "ata", "area", "this", "m", "content", "rel", " DATA", "raw", "missing", "snap", "window", "INFO", "bin", "n", "message", "block", "value", "ATA", "batch"], "data_size": ["buf_size", "data_SIZE", "buf_Size", "data_length", " data_send", " data_SIZE", "buf_length", " data_Size", "data_send", "data_Size"], "avpkt": ["avppkt", "awpct", " avPwd", "avpaacket", "avpracket", "avdpkt", "avPwd", "awcpck", "awcpct", "avpj", "avdpacket", "avprekt", " avpdat", "awpth", "avpadat", " avpconn", " avPdat", "avppct", "avpakt", " avPacket", "avpdat", "avpreacket", "avcpct", "avppck", "avprej", "avdpconn", "avprkt", "awpck", "avpck", " avpacket", " avpj", "avcpkt", "avcpth", "avPkt", "avprwd", " avpwd", " avPkt", "avPacket", "avppth", "avPck", "avPconn", " avPj", "awcpth", " avPconn", "avprdat", "avpth", "avPct", "avcpck", "avpacket", "avPth", "avpconn", "avpawd", "avdpj", "avPj", "avpreconn", "avpwd", "avpct", "awpkt", "avPdat", "awcpkt"], "buf": ["init", "t", "doc", "p", "max", "pkg", "cv", "bh", "r", "ctx", "SIZE", "xff", "fb", "pg", "msg", "map", "cb", "txt", "Buffer", "cur", "ff", "br", "buff", "dat", "Buff", "mem", "bytes", "b", "emb", "begin", "orig", "pb", "cap", "bl", "ref", "buffer", "img", "alloc", "cmp", "enc", "cam", "raw", "vec", "conv", "uf", "seq", "bc", "src", "queue", "bin", "box", "pos", "batch", "rb", "err", "cmd", "wb", "uv"], "i": ["t", "p", "bi", "f", "id", "l", "ii", "mi", "it", "si", "j", "di", "b", "g", "ij", "ci", "ti", "m", "pi", "im", "x", "I", "phi", "qi", "c", "n", "z"], "v": ["vp", "t", "p", "tv", "vi", "cv", "f", "vc", "l", "vs", "qv", "q", "vt", "ev", "w", "vv", "nv", "j", "h", "ve", "vr", "u", "b", "ver", "g", "rev", "vm", "m", "iv", "conv", "sv", "lv", "env", "c", "video", "n", "V", "av", "va", "uv"], "s": ["p", "https", "sl", "ns", "sq", "ses", "gs", "stats", "comments", "its", "c", "wcs", "n", "qs", "z", "services", "S", "a", "sp", "vs", "ps", "ctx", "ins", "scope", "serv", "w", "less", "ss", "h", "j", "st", "js", "soc", "b", "sts", "ts", "fs", "session", "sb", "ats", "context", "sys", "ers", "f", "is", "sam", "aws", "bs", "space", "sh", "rs", "abilities", "e", "cam", "m", "conv", "cs", "ls", "t", "os", "ds", "ms", "spec", "ies", "sm", "set", "hs", "ssl", "g", "status", "es", "sv", "se", "sw"], "pict": ["phot", "doc", "pkg", "pic", "fi", "fac", "ctx", "msg", "Pic", "txt", "obj", "pas", "Picture", "prop", "png", "kt", "pt", "buff", "mat", "ht", "np", "pres", "fat", "act", "pr", "cam", "capt", "stat", "Pict", "iat", "ct", "qi", "seq", "fig", "feat", "Capt", "picture", "img"], "buf2": ["buff1", "uf0", "buf0", "uf2", "buf3", "buffer2", "buf1", "buff2", "buff0", "uf1", "buff3", "buffer3", "uf3", "buffer0", "buffer1"], "buf_start": ["buf_size", "buf2id", "buf2end", "buf2start", "uf_id", "buf2size", "uf_start", "uf_size", "uf_end", "buf_id", "buf_end"], "buf_start_second_field": ["buf_start_first_length", "buf_start_second_length", "buf_start_first_fields", "buf_start_second_fields", "buf_start_second_byte", "buf_start_first_field", "buf_start_first_byte"], "mb_height": ["mb_size", "buf_size", "mbavmax", "buf_width", "mbavheight", "mb_max", "buf_max", "mbavwidth", "mb_width", "mbavsize", "buf_height"], "slices": ["sizets", "sples", "Slimions", "slicices", "slicions", "Slicions", "Slices", "slimets", "Slimices", "splets", "Slimes", "Slicices", "slicets", "Slicets", "slimes", "Slimets", "sizions", "slimions", "sizices", "slimices", "sizes", "splions", "splices"], "tmp": ["ptr", "cv", "temp", "mk", "sp", "mp", "obj", "txt", "png", "js", "proc", "np", "boxes", "img", "photos", "perm", "cmp", "cam", "xy", "cond", "conv", "etc", "test", "seq", "src", "pos", "params", "uv"], "size": ["Size", "limit", "length", "SIZE", "ize", "send", "address", "offset", "time", "body", "empty", "space", "bytes", "name", "fee", "type", "buffer", "height", "len", "content", "scale", "window", "count", "message", "shape"], "n_slices": ["n_slimides", "n_sples", "n_splses", "n_slimes", "n_slicses", "n_scoides", "n_slimses", "n_splides", "n_Scoses", "n_slicides", "n_Slicides", "n_splES", "n_slicES", "n_scoes", "n_Scoes", "n_Slicses", "n_Slices", "n_ScoES", "n_SlicES", "n_Scoides", "n_scoES", "n_slimES", "n_scoses"]}}
{"project": "qemu", "commit_id": "b85114f8cfbede8b153db68875973ef0790bf296", "target": 0, "func": "void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)\n\n{\n\n    bs->detect_zeroes = blk->root_state.detect_zeroes;\n\n}\n", "idx": 5581, "substitutes": {"blk": ["brak", "Blk", "Blb", "plak", "blak", " blj", "Blak", "brck", "Blck", "brk", " blb", "plk", "plj", "blj", " blak", "Blj", " blck", "blck", "blb", "brb", "plck"], "bs": ["ubs", "bn", "uts", "os", "bos", "bps", "ds", "bm", "ms", "aus", "aos", "bas", "ss", "bus", "ns", "js", "bytes", "b", "bb", "BS", "bl", "pb", "gb", "gs", "ts", "obs", "lbs", "acs", "bits", "its", "fs", "bis", "sb", "als", "ls", "bsp", "s", "qs", "sys", "bc", "zb"]}}
{"project": "qemu", "commit_id": "42119fa3568dc7e8c82447c861678a5987d06d91", "target": 0, "func": "vcard_emul_mirror_card(VReader *vreader)\n\n{\n\n    /*\n\n     * lookup certs using the C_FindObjects. The Stan Cert handle won't give\n\n     * us the real certs until we log in.\n\n     */\n\n    PK11GenericObject *firstObj, *thisObj;\n\n    int cert_count;\n\n    unsigned char **certs;\n\n    int *cert_len;\n\n    VCardKey **keys;\n\n    PK11SlotInfo *slot;\n\n    VCard *card;\n\n\n\n    slot = vcard_emul_reader_get_slot(vreader);\n\n    if (slot == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    firstObj = PK11_FindGenericObjects(slot, CKO_CERTIFICATE);\n\n    if (firstObj == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    /* count the certs */\n\n    cert_count = 0;\n\n    for (thisObj = firstObj; thisObj;\n\n                             thisObj = PK11_GetNextGenericObject(thisObj)) {\n\n        cert_count++;\n\n    }\n\n\n\n    if (cert_count == 0) {\n\n        PK11_DestroyGenericObjects(firstObj);\n\n        return NULL;\n\n    }\n\n\n\n    /* allocate the arrays */\n\n    vcard_emul_alloc_arrays(&certs, &cert_len, &keys, cert_count);\n\n\n\n    /* fill in the arrays */\n\n    cert_count = 0;\n\n    for (thisObj = firstObj; thisObj;\n\n                             thisObj = PK11_GetNextGenericObject(thisObj)) {\n\n        SECItem derCert;\n\n        CERTCertificate *cert;\n\n        SECStatus rv;\n\n\n\n        rv = PK11_ReadRawAttribute(PK11_TypeGeneric, thisObj,\n\n                                   CKA_VALUE, &derCert);\n\n        if (rv != SECSuccess) {\n\n            continue;\n\n        }\n\n        /* create floating temp cert. This gives us a cert structure even if\n\n         * the token isn't logged in */\n\n        cert = CERT_NewTempCertificate(CERT_GetDefaultCertDB(), &derCert,\n\n                                       NULL, PR_FALSE, PR_TRUE);\n\n        SECITEM_FreeItem(&derCert, PR_FALSE);\n\n        if (cert == NULL) {\n\n            continue;\n\n        }\n\n\n\n        certs[cert_count] = cert->derCert.data;\n\n        cert_len[cert_count] = cert->derCert.len;\n\n        keys[cert_count] = vcard_emul_make_key(slot, cert);\n\n        cert_count++;\n\n        CERT_DestroyCertificate(cert); /* key obj still has a reference */\n\n    }\n\n\n\n    /* now create the card */\n\n    card = vcard_emul_make_card(vreader, certs, cert_len, keys, cert_count);\n\n    g_free(certs);\n\n    g_free(cert_len);\n\n    g_free(keys);\n\n\n\n    return card;\n\n}\n", "idx": 5582, "substitutes": {"firstObj": ["topNow", "topObject", " firstPos", "firstPos", " firstRes", "topArg", "startObject", "firstNow", "firstCtrl", "topPos", "smallObj", "topObj", "smallCtrl", "startOb", "thisOb", "startObj", "masterPos", "thisNow", "smallOb", "firstVo", "fullOb", " firstObject", "topVo", " firstOb", "smallPos", " firstArg", "fullObj", "fullPos", " firstCtrl", " firstVo", "currentObj", "topOb", "firstRes", "masterOb", " firstNow", "topRes", "thisObject", "masterCtrl", "currentOb", "firstOb", "firstObject", "masterObj", "fullRes", "fullArg", "currentObject", "firstArg", "fullVo"], "thisObj": ["currentobj", " thisExt", "rightObj", "nowOb", "thisOb", "todayObj", "singleAss", "sinceObj", " thisVo", "nowObject", "currentObj", "firstRes", "thatExt", "curAss", "rightAss", "thisObject", "firstVol", "rightVo", "parentVo", "singleInst", "methodOb", "currentObject", "thatRes", "singleOb", "firstEx", "firstCtrl", "nowInst", "hereObject", "thisVo", "methodVol", "thisStr", "nowObj", "currentArg", "sinceVo", "thatObj", "curOb", " thisEx", "parentInst", "currentEx", "theseObj", "hereCtrl", "rightOb", "curObj", "thisArg", " thisOb", "todayOb", "methodObj", "firstExt", " thisArg", "firstArg", "singleObj", "thisInst", "thisRes", " thisObject", "theseObject", "curVo", "thisobj", "thisNow", "firstVo", "thisExt", "todayLt", "hereObj", "thisAss", "theseEx", "firstStr", " thisobj", "parentOb", "singleVo", "thisCtrl", "currentOb", "sinceStr", "firstObject", "parentObj", "currentNow", "theseNow", "nowVo", " thisVol", " thisRes", "firstNow", "thisLt", "sinceEx", "hereOb", " thisStr", "nowLt", "currentCtrl", "thisVol", "thisEx", " thisLt", "firstobj", "firstOb"], "cert_count": ["ctr_add", "cert_list", "der_count", "cert_index", "Cert_count", "cert_sum", "certCountbase", "ert_amount", "ert_Count", "cert64sum", " cert_length", "certCountlen", "cert_cache", "cert_code", "ert_code", "der_index", "ctr2add", "cert5code", "ctr2sum", "cert_found", "ctr_counter", "ert_search", "cert5mount", "ert_mount", "cert5count", "cert2count", "cert67sum", "certptchild", "cert_length", "der_cache", "thread_len", "certzcollection", "ert_cache", "ert_found", "thread_count", "cert2sum", " cert_counter", "cert_counter", "Cert_list", "thread_Count", "ctr_count", "cert_collection", "cert67add", "cert2counter", "ptr_count", " cert_Count", "cert67counter", "der_base", "cert_Count", "cert5amount", "cert_mount", "cert64count", "cert67count", "certzlist", "ctr2count", "cert_child", "der_double", "cert64add", "cert5Count", "cert_group", "cert2add", "certCountdouble", "Cert_collection", "ctr_sum", "ptr_group", "ctr2counter", "cert_double", "cert64counter", "cert_base", "ert_id", "cert_id", "certptgroup", "cert_add", "der_len", "der_code", "cert_search", "cert5id", "ptr_child", "Cert_Count", "certzCount", "certptcount", "ert_count", "cert_amount", "cert5search", "certCountcount", "certzcount"], "certs": ["cts", "Certigs", "extcs", " certes", "ertc", "alerts", "ertigs", "celts", "paths", "ctains", "ertts", "alertgs", "contigs", "contains", "Certls", "pts", "extrs", "certes", "certls", "ptrs", "ptts", " certts", "certigs", "certc", " certains", "exts", "ptcs", "celcs", "certxs", "ctigs", "celes", "pathgs", "Certs", "certts", "pathses", "alertses", "extts", "pathxs", "conts", "certains", " certcs", "certses", "certcs", " certls", "ertcs", "ertrs", " certc", "celses", "erts", "celgs", "ertes", "celxs", "cels", "contts", "certgs", "ertls", "Certc", " certigs", "certrs", "alertxs", "ctts"], "cert_len": ["cert2mem", "cert_gen", "cert_list", "cert2list", "cert_lim", "cert64gen", "ert_Len", "ver_lim", "cert2len", " cert64len", "cert_length", "Cert_Len", "cert_Len", "Cert_list", " cert_Len", "ver_sl", " cert_gen", " cert_size", "cert_lib", "cert67lim", "ert_mem", " cert64gen", "cert67gen", "cert2Len", " cert64Len", "cert67sl", "cert64Len", "ver_len", " cert64lib", "cert2length", "cert_sl", "ert_len", " cert_lib", "ver_gen", "ert_list", "cert_size", "cert_mem", "Cert_length", "cert67len", "cert64len", "cert64lib", "Cert_len"], "keys": ["key", "items", "ds", "scripts", "vers", "codes", "types", "ps", "balls", "chains", "users", "files", "ics", "weights", "writers", "locks", "ks", "rots", "els", "eds", "groups", "pins", "ports", "ves", "rows", "bs", "Keys", "lights", "books", "tags", "ids", "images", "ops", "checks", "xs", "actions", "banks", "vals", "values", "headers", "bys", "names", "ams", "cards", "workers", "parts", "als", "ots", "ers", "fields", "cats", "services"], "slot": ["key", "pot", "journal", "gro", "ser", "sp", "ctx", "tz", "scope", "z", "spot", "note", "sl", "node", " slots", "loc", "si", "lot", "layout", "j", "handle", "module", "lock", "pt", "kl", "option", "location", "space", "soc", "pointer", "index", "slice", "sid", "role", "usb", "binding", "timeout", "seed", "ref", "row", "ot", "pool", "zo", "holder", "storage", "service", "loop", "table", "zone", "snap", "session", "ct", "item", "shot", "vol", "magic", "kit", "pos", "tab", "Slot"], "card": ["dr", "t", "pack", "cast", "ll", "controller", "cat", "cont", "board", "list", "carry", "ul", "craft", "wild", "deck", "arc", "cc", "php", "gc", "cell", " cards", "Card", "cart", "car", "roll", "cap", "rar", "row", "new", "ar", "cf", "guard", "raw", "star", "var", "cards", "book", "and", "ARD", "c", "cas", "ard"], "derCert": ["derAlert", "descert", "delcert", "DerCert", "erKey", "erCrit", "derPub", "DERCert", "DerCrit", "drcert", "derItem", "DerCtrl", " dercert", " derCtrl", "dCtrl", "desVal", " derPub", "delCrit", "serVal", "DerPub", "drAlert", "serCert", "derCtrl", "dercert", "drCrit", "derServ", "dItem", "delAlert", "dcert", "drKey", "delCert", "derCrit", "delServ", "erAlert", "DerItem", "erCert", "ercert", "DerVal", "sercert", "derVal", "DerKey", "DerServ", " derCrit", "derKey", "desPub", "erServ", " derServ", "Dercert", "delKey", "desCert", "DERKey", "DERcert", "DERServ", "drCert", "serPub", "dCert", "drPub", " derItem"], "cert": ["ptr", "key", "t", "pub", "cp", "compl", "pot", "cast", "pkg", "temp", "conn", "ctr", "ind", "cat", "cont", "secret", "alert", "pg", "note", "con", "tar", "obj", "str", "cur", "crit", "val", "good", "req", "valid", "pt", "cr", "ret", "cell", "proc", "ssl", "result", "def", "ver", "car", "date", "trust", "Cert", "acc", "cf", "crypt", "cfg", "ca", "der", "tr", "pair", "ert", "ERT", "ce", "test", "ct", "deb", "mod", "cal", "cel", "alt", "vol", "mail", "cmd"], "rv": ["rrm", "errf", "srv", "rbvr", " rf", "srve", "rm", "rrvr", " rm", "rve", "prvr", " rvr", " rve", "crve", "prve", "crvr", "rf", "errvd", "prf", "errv", "srvr", "errvr", "prv", "rbv", "rbvd", "crf", "rrve", "rbf", "crv", "rvr", "rvd", "rrv", "srm", " rvd"]}}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static uint64_t megasas_fw_time(void)\n\n{\n\n    struct tm curtime;\n\n    uint64_t bcd_time;\n\n\n\n    qemu_get_timedate(&curtime, 0);\n\n    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |\n\n        ((uint64_t)curtime.tm_min & 0xff)  << 40 |\n\n        ((uint64_t)curtime.tm_hour & 0xff) << 32 |\n\n        ((uint64_t)curtime.tm_mday & 0xff) << 24 |\n\n        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |\n\n        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);\n\n\n\n    return bcd_time;\n\n}\n", "idx": 5587, "substitutes": {"curtime": ["pubword", "cmptime", "cmdword", "Curtimer", "objcase", "thinktime", "clientword", " curtimeout", "curdate", "cmpword", "urrule", "ctrrate", " curmetadata", "urinstance", "CurTime", "currentdate", "pubtime", "thinkmetadata", "urpost", "cmdinstance", "curword", "ctrtime", "urrate", "urword", "grtime", "urdate", "chartime", "curtim", " curtim", "urmetadata", "pubdata", " curdata", "grtimer", "clientitem", "charresponse", "curtimeout", "conttime", "ctrword", "uritem", "cmddate", "ctrrule", "grtim", " curcase", "conttimer", "closecase", "currule", "curtimer", "currate", "currenttimer", "curresponse", " curtimer", "grdate", " curword", "charitem", "conttim", "urtime", "curdata", "cmprule", "currenttime", "objtimeout", "ctrlcase", "cmprate", "closetime", " curpost", "Curtime", "closedata", "cmdtime", "charword", "ctrldata", "currentTime", "clientresponse", " curinstance", "thinkdate", " curdate", "curcase", "clienttime", "urresponse", "contdate", "curTime", "closeword", "thinkpost", "objdata", "ctrltime", "ctrltimeout", "curmetadata", "curpost", "objtime", "Curdate", " curTime", "curitem", "pubcase", "curinstance"], "bcd_time": ["bdd_value", "bcdamvalue", "bcdjtime", "bcd_code", "bcdtTime", "bdd_Time", "bCD_t", "bCD_times", "bcd_rate", "bpd_code", "bcd_t", "bcdamtime", "bpd_rate", "bcdtrate", "bpd_Time", "bcd_data", "bcd_Time", "bcdjcode", "bcdamTime", "bCD_data", "bcd_value", "bdd_time", "bdd_rate", "bcdjTime", "bcdamrate", "bcdjrate", "bcdttime", "bcd_times", "bpd_time", "bCD_time", "bcdtvalue"]}}
{"project": "qemu", "commit_id": "107e4b352cc309f9bd7588ef1a44549200620078", "target": 1, "func": "static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)\n\n{\n\n    OfDpaFlow *flow;\n\n    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;\n\n\n\n    flow = g_new0(OfDpaFlow, 1);\n\n    if (!flow) {\n\n        return NULL;\n\n    }\n\n\n\n    flow->cookie = cookie;\n\n    flow->mask.tbl_id = 0xffffffff;\n\n\n\n    flow->stats.install_time = flow->stats.refresh_time = now;\n\n\n\n    return flow;\n\n}\n", "idx": 5607, "substitutes": {"cookie": ["key", "entry", "jar", "copy", "tmp", "aco", "binary", "id", "token", "label", "policy", "stay", "cb", "node", "login", "ookie", "chip", "kind", "lock", "gc", "cn", "cycle", "attr", "metadata", "mem", "cell", "name", "company", "sid", "term", "cook", " Cookie", "timeout", "keeper", "store", "cmp", "code", "domain", "table", "flag", "session", "window", "remember", " cookies", "uid", "mask", "pid", "bin", "magic", "callback", "cache", "cmd", "batch"], "flow": ["down", "Flow", "bolt", "q", "call", "send", "low", "lif", "row", "fp", "up", "bridge", "loop", "stream", "mill", "queue", "loader", "message", "event", "access", "foreign", "grab", "flake", "way", "wall", "draw", "future", "scope", "w", "control", "export", "tower", "usage", "buffer", "new", "instance", "session", "import", "transfer", "load", "payment", "df", "order", "loss", "tf", "f", "card", "ow", "board", "aw", "port", "fl", "lock", "cow", "allow", "fee", "zip", "command", "pool", "sequence", "qa", "foo", "goal", "out", "fail", "relation", "plant", "form", "fine", "flash", "channel", "fw", "hold", "feed", "cell", "step", "forward", "cf", "container", "OW", "window", "ward", "frame", "flows", "batch"]}}
{"project": "FFmpeg", "commit_id": "fc9b22dd2e5de851a89245b5357e710b93587278", "target": 0, "func": "static int rtp_open(URLContext *h, const char *uri, int flags)\n\n{\n\n    RTPContext *s;\n\n    int port, is_output, ttl, local_port;\n\n    char hostname[256];\n\n    char buf[1024];\n\n    char path[1024];\n\n    const char *p;\n\n\n\n    is_output = (flags & URL_WRONLY);\n\n\n\n    s = av_mallocz(sizeof(RTPContext));\n\n    if (!s)\n\n        return AVERROR(ENOMEM);\n\n    h->priv_data = s;\n\n\n\n    url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port,\n\n              path, sizeof(path), uri);\n\n    /* extract parameters */\n\n    ttl = -1;\n\n    local_port = -1;\n\n    p = strchr(uri, '?');\n\n    if (p) {\n\n        if (find_info_tag(buf, sizeof(buf), \"ttl\", p)) {\n\n            ttl = strtol(buf, NULL, 10);\n\n        }\n\n        if (find_info_tag(buf, sizeof(buf), \"localport\", p)) {\n\n            local_port = strtol(buf, NULL, 10);\n\n        }\n\n    }\n\n\n\n    build_udp_url(buf, sizeof(buf),\n\n                  hostname, port, local_port, ttl);\n\n    if (url_open(&s->rtp_hd, buf, flags) < 0)\n\n        goto fail;\n\n    local_port = udp_get_local_port(s->rtp_hd);\n\n    /* XXX: need to open another connection if the port is not even */\n\n\n\n    /* well, should suppress localport in path */\n\n\n\n    build_udp_url(buf, sizeof(buf),\n\n                  hostname, port + 1, local_port + 1, ttl);\n\n    if (url_open(&s->rtcp_hd, buf, flags) < 0)\n\n        goto fail;\n\n\n\n    /* just to ease handle access. XXX: need to suppress direct handle\n\n       access */\n\n    s->rtp_fd = udp_get_file_handle(s->rtp_hd);\n\n    s->rtcp_fd = udp_get_file_handle(s->rtcp_hd);\n\n\n\n    h->max_packet_size = url_get_max_packet_size(s->rtp_hd);\n\n    h->is_streamed = 1;\n\n    return 0;\n\n\n\n fail:\n\n    if (s->rtp_hd)\n\n        url_close(s->rtp_hd);\n\n    if (s->rtcp_hd)\n\n        url_close(s->rtcp_hd);\n\n    av_free(s);\n\n    return AVERROR(EIO);\n\n}\n", "idx": 5617, "substitutes": {"h": ["ph", "hd", "hm", "t", "kh", "host", "oh", "ih", "th", "bh", "l", "v", "H", "hash", "w", "rh", "k", "handle", "here", "he", "comm", "dh", "ssh", "history", "hs", "ht", "b", "ah", "hr", "sh", "http", "y", "m", "hw", "x", "hh", "hp", "c", "eh", "hl"], "uri": ["ur", "vp", "query", "html", "subject", "resource", "origin", "prefix", "q", "address", "connection", "username", "filename", "description", "uu", "qu", "u", "ri", " URI", "i", "ip", "format", "name", "http", "ui", "password", "URI", "remote", "fp", "href", "domain", "iri", "qi", "route", "uni", "message", "picture", "url"], "flags": ["doms", "details", "properties", "atts", "types", "ms", "planes", " Flags", "vs", "mates", "frames", "locks", "options", "amps", "fps", "pins", "ports", "FLAG", "kind", "posts", "Flags", "ints", "heads", "limits", "tags", "status", "ts", "faces", "stats", "lbs", "cond", "members", "uses", "vals", "bits", "fs", "flag", "features", "args", "bugs", "mask", "alf", "parts", "packages", "settings", "wcs", "aps", "ats", "acts", "affles", "weights", "fields", "params", "ags"], "s": ["https", "l", "sl", "self", "ns", "sq", "ses", "gs", "y", "stats", "its", "ims", "c", "settings", "n", "qs", "z", "sc", "S", "a", "sp", "r", "ps", "vs", "ins", "serv", "w", "less", "ss", "j", "st", "i", "js", "b", "sts", "ts", "ops", "has", "fs", "args", "sb", "us", "als", "ats", "sys", "sa", "is", "f", "d", "sam", "aws", "so", "bs", "sh", "socket", "rs", "e", "m", "cs", "as", "ls", "t", "os", "ds", "south", "ms", "v", "spec", "comm", "o", "hs", "ssl", "g", "status", "es", "sv", "se", "sw"], "port": ["ptr", "key", "t", "order", "cp", "host", " sport", "ported", "limit", "id", "v", "database", "length", "direction", " Port", "channel", "component", "file", "position", "address", "duration", "connection", "server", "Port", "version", "pport", "ports", "pad", "device", "eport", "size", "ip", "state", "index", "trace", "socket", "proxy", "timeout", "type", "pr", "http", "row", "len", "ORT", "ort", "line", "page", "PORT", "priority", "pi", "number", "window", "count", "pid", "client", "queue", "pe", "pos", "batch"], "is_output": ["Is_hidden", "Is_input", " is_input", "Is_enabled", "is_enabled", " is_network", "is__output", "is__enabled", "is_hidden", "is__input", "is_network", "Is_output", " is_hidden", "is_input", "is__hidden"], "ttl": ["tdtl", "traced", "tld", "ttd", "ttL", "attl", "tracel", "gtm", "rtol", "tt", "tracetl", "otnl", "TTl", "ott", "ttm", "gtl", "payl", "attol", "rtll", "payll", "tttl", "tltl", "payol", "ntol", "TTm", "tL", "ettol", "TTol", "TTtl", "otol", "tlol", "atttl", "paytl", "ntm", "ttol", "tll", "traceol", "ttll", "gtol", "tdl", "etttl", "otL", "tdnl", "otl", "ntl", "ttnl", "ettll", "ettl", "nttl", "tdol", "gttl", "rtl", "TTt", "ottl", "attd", "rttl", "attnl", "tl", "TTL", "ttt"], "local_port": ["sameLocalpport", " local_PORT", " local_ort", " local_peer", "sameLocalport", "same_port", "localLocalPort", "local_pport", "sameLocalPort", " local_boat", "local_server", "localLocalpport", "sameLocalports", "local_ort", "local_PORT", " local_server", "localLocalport", "local_boat", "same_pport", "same_ports", "same_Port", " local_ports", "localLocalports", "local_peer", "local_Port", "local___peer", "local___port", "local___ports", " local_Port", "local_ports"], "hostname": ["bindnames", "hostName", "Hostnumber", "hostnum", "nickName", "hostnames", "bindName", "ipName", "domainName", "HostName", "bindname", "Hostnum", "hostno", "bindame", "ostName", " hostno", " hostnumber", " hostame", "Hostna", "nickname", "ipnum", "ipname", "Hostnames", "domainnumber", " hostName", "nickna", " hostna", "hostame", "hostnumber", "domainnames", "Hostname", " hostnum", "ostname", " hostnames", "ipno", "Hostno", "Hostame", "ostnumber", "hostna", "domainname"], "buf": ["bn", "pkg", "bt", "bed", "rw", "msg", "txt", "str", "cur", "Buff", "text", "fp", "iter", "db", "vec", "bp", "uf", "queue", "box", "cmd", "uv", "ptr", "cp", "data", "r", "ctx", "xff", "filename", "eng", "buff", "mat", "mem", "proc", "b", "err", "pb", "buffer", "raw", "nb", "fb", "map", "Buffer", "cb", "br", "pad", "np", "dir", "cap", "ba", "pool", "cam", "end", "conv", "bag", "img", "vp", "doc", "cast", "cv", "tmp", "length", "pg", "bar", "comm", "bytes", "usr", "trace", "late", "cfg", "addr", "window", "desc", "bin", "rb", "cache", "bc", "wb", "batch"], "path": ["key", "host", "pkg", "config", "full", "binary", "id", "length", "PATH", "component", "file", "prefix", "server", "prop", "Path", "alias", "package", "time", "body", "chain", "history", "format", "pointer", "dir", "root", "name", "info", "type", "rev", "text", "stat", "pattern", "ath", "base", "part", "desc", "client", "route", "pid", "user", "context", "url", "cmd", "template"], "p": ["ph", "vp", "t", "pp", "cp", "rep", "pkg", "lp", "f", "a", "d", "l", "v", "sp", "r", "ps", "data", "pc", "ping", "pg", "q", "wp", "prop", "pa", "o", "pt", "i", "ap", "b", "np", "pn", "pb", "pr", "fp", "tp", "jp", "op", "pat", "m", "P", "pid", "c", "n", "u", "pre"]}}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static float get_band_cost_UPAIR7_mips(struct AACEncContext *s,\n\n                                       PutBitContext *pb, const float *in,\n\n                                       const float *scaled, int size, int scale_idx,\n\n                                       int cb, const float lambda, const float uplim,\n\n                                       int *bits)\n\n{\n\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    int i;\n\n    float cost = 0;\n\n    int qc1, qc2, qc3, qc4;\n\n    int curbits = 0;\n\n\n\n    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cb-1];\n\n    float   *p_codes = (float   *)ff_aac_codebook_vectors[cb-1];\n\n\n\n    for (i = 0; i < size; i += 4) {\n\n        const float *vec, *vec2;\n\n        int curidx, curidx2, sign1, count1, sign2, count2;\n\n        int   *in_int = (int   *)&in[i];\n\n        float *in_pos = (float *)&in[i];\n\n        float di0, di1, di2, di3;\n\n        int t0, t1, t2, t3, t4;\n\n\n\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n\n\n\n        __asm__ volatile (\n\n            \".set push                                          \\n\\t\"\n\n            \".set noreorder                                     \\n\\t\"\n\n\n\n            \"ori        %[t4],      $zero,      7               \\n\\t\"\n\n            \"ori        %[sign1],   $zero,      0               \\n\\t\"\n\n            \"ori        %[sign2],   $zero,      0               \\n\\t\"\n\n            \"slt        %[t0],      %[t4],      %[qc1]          \\n\\t\"\n\n            \"slt        %[t1],      %[t4],      %[qc2]          \\n\\t\"\n\n            \"slt        %[t2],      %[t4],      %[qc3]          \\n\\t\"\n\n            \"slt        %[t3],      %[t4],      %[qc4]          \\n\\t\"\n\n            \"movn       %[qc1],     %[t4],      %[t0]           \\n\\t\"\n\n            \"movn       %[qc2],     %[t4],      %[t1]           \\n\\t\"\n\n            \"movn       %[qc3],     %[t4],      %[t2]           \\n\\t\"\n\n            \"movn       %[qc4],     %[t4],      %[t3]           \\n\\t\"\n\n            \"lw         %[t0],      0(%[in_int])                \\n\\t\"\n\n            \"lw         %[t1],      4(%[in_int])                \\n\\t\"\n\n            \"lw         %[t2],      8(%[in_int])                \\n\\t\"\n\n            \"lw         %[t3],      12(%[in_int])               \\n\\t\"\n\n            \"slt        %[t0],      %[t0],      $zero           \\n\\t\"\n\n            \"movn       %[sign1],   %[t0],      %[qc1]          \\n\\t\"\n\n            \"slt        %[t2],      %[t2],      $zero           \\n\\t\"\n\n            \"movn       %[sign2],   %[t2],      %[qc3]          \\n\\t\"\n\n            \"slt        %[t1],      %[t1],      $zero           \\n\\t\"\n\n            \"sll        %[t0],      %[sign1],   1               \\n\\t\"\n\n            \"or         %[t0],      %[t0],      %[t1]           \\n\\t\"\n\n            \"movn       %[sign1],   %[t0],      %[qc2]          \\n\\t\"\n\n            \"slt        %[t3],      %[t3],      $zero           \\n\\t\"\n\n            \"sll        %[t0],      %[sign2],   1               \\n\\t\"\n\n            \"or         %[t0],      %[t0],      %[t3]           \\n\\t\"\n\n            \"movn       %[sign2],   %[t0],      %[qc4]          \\n\\t\"\n\n            \"slt        %[count1],  $zero,      %[qc1]          \\n\\t\"\n\n            \"slt        %[t1],      $zero,      %[qc2]          \\n\\t\"\n\n            \"slt        %[count2],  $zero,      %[qc3]          \\n\\t\"\n\n            \"slt        %[t2],      $zero,      %[qc4]          \\n\\t\"\n\n            \"addu       %[count1],  %[count1],  %[t1]           \\n\\t\"\n\n            \"addu       %[count2],  %[count2],  %[t2]           \\n\\t\"\n\n\n\n            \".set pop                                           \\n\\t\"\n\n\n\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n\n              [sign1]\"=&r\"(sign1), [count1]\"=&r\"(count1),\n\n              [sign2]\"=&r\"(sign2), [count2]\"=&r\"(count2),\n\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n\n              [t4]\"=&r\"(t4)\n\n            : [in_int]\"r\"(in_int)\n\n            : \"memory\"\n\n        );\n\n\n\n        curidx = 8 * qc1;\n\n        curidx += qc2;\n\n\n\n        curidx2 = 8 * qc3;\n\n        curidx2 += qc4;\n\n\n\n        curbits += p_bits[curidx];\n\n        curbits += upair7_sign_bits[curidx];\n\n        vec     = &p_codes[curidx*2];\n\n\n\n        curbits += p_bits[curidx2];\n\n        curbits += upair7_sign_bits[curidx2];\n\n        vec2    = &p_codes[curidx2*2];\n\n\n\n        __asm__ volatile (\n\n            \".set push                                          \\n\\t\"\n\n            \".set noreorder                                     \\n\\t\"\n\n\n\n            \"lwc1       %[di0],     0(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di1],     4(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di2],     8(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di3],     12(%[in_pos])               \\n\\t\"\n\n            \"abs.s      %[di0],     %[di0]                      \\n\\t\"\n\n            \"abs.s      %[di1],     %[di1]                      \\n\\t\"\n\n            \"abs.s      %[di2],     %[di2]                      \\n\\t\"\n\n            \"abs.s      %[di3],     %[di3]                      \\n\\t\"\n\n            \"lwc1       $f0,        0(%[vec])                   \\n\\t\"\n\n            \"lwc1       $f1,        4(%[vec])                   \\n\\t\"\n\n            \"lwc1       $f2,        0(%[vec2])                  \\n\\t\"\n\n            \"lwc1       $f3,        4(%[vec2])                  \\n\\t\"\n\n            \"nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \\n\\t\"\n\n\n\n            \".set pop                                           \\n\\t\"\n\n\n\n            : [di0]\"=&f\"(di0), [di1]\"=&f\"(di1),\n\n              [di2]\"=&f\"(di2), [di3]\"=&f\"(di3)\n\n            : [in_pos]\"r\"(in_pos), [vec]\"r\"(vec),\n\n              [vec2]\"r\"(vec2), [IQ]\"f\"(IQ)\n\n            : \"$f0\", \"$f1\", \"$f2\", \"$f3\",\n\n              \"memory\"\n\n        );\n\n\n\n        cost += di0 * di0 + di1 * di1\n\n                + di2 * di2 + di3 * di3;\n\n    }\n\n\n\n    if (bits)\n\n        *bits = curbits;\n\n    return cost * lambda + curbits;\n\n}\n", "idx": 5621, "substitutes": {"s": ["sc", "p", "ds", "a", "sp", "ps", "sl", "w", "ss", "bs", "ns", "ssl", "sq", "sts", "sg", "rs", "gs", "es", "sn", "e", "fs", "sv", "cs", "sb", "c", "as", "sa"], "pb": ["tc", "vp", "pp", "cp", "p", "lb", "bps", "cv", "nb", "lp", "bm", "ctx", "pc", "mp", "BP", "pm", "pa", "np", "xb", "fp", "tp", "bp", "pl", "uf", "sb", "bf", "tk", "rb"], "in": ["din", "mc", "init", "p", "aled", "nin", "IN", "config", "is", "vin", "ind", "sum", "data", "ins", "it", "scan", "inn", "con", "params", "mat", "tin", "gen", "isin", "at", "inc", "ar", "pin", "m", "conv", "raw", "all", "ac", "inf", "rin", "bin", "gin", "pos", "input", "out", "In", "add"], "scaled": ["scales", " unscaved", "SCaled", "shanned", "staled", " unscaled", "Scalled", "escaled", "shashed", "shaling", "shale", "scashed", " unscaling", " scanned", "scaved", "shalled", "scalled", "SCaped", "Scales", "Scaled", "escales", "stalled", " scashed", "stale", "staped", "SCalled", "escanned", "Scanned", "descanned", "escaling", " scales", "scale", " unscalled", "scanned", "escalled", "SCale", "SCaling", "SCaved", "shaved", "scaling", "descalled", " scaling", "escale", "escaped", "escashed", "shaled", " scalled", "descaling", " scale", "scaped", "descaled"], "size": ["sc", "small", "cm", "Size", "l", "dim", "see", "ze", "length", "SIZE", "ize", "check", "send", "loc", "offset", "set", "si", "bytes", "np", "name", "shift", "g", "fee", "range", "len", "area", "sn", "code", "ci", "m", "scale", "win", "pi", "cs", "count", "iz", "c", "mode", "z", "shape", "score"], "scale_idx": ["scale_IdX", "scale_Idw", "scale_Idco", "scale_itX", "scale_itx", "scale_idxs", "scale_idX", "scale_Idx", "scale_Idy", "scale_idey", "scale_idco", "scale_idex", "scale_itw", "scale_ideX", "scale_infow", "scale_infox", "scale_Idxs", "scale_infoX", "scale_itco", "scale_infoco", "scale_idw", "scale_idexs", "scale_idy"], "cb": ["tc", "rc", "sc", "cu", "cp", "conf", "lb", "bound", "cv", "nb", "ctr", "CB", "lc", "ctx", "cor", "dc", "cd", "loc", "cc", "cale", "oi", "gc", "cr", "bs", "fc", "cell", "bb", "gb", "ctrl", "cf", "ck", "db", "cfg", "coord", "crop", "bp", "sb", "cli", "ob", "bf", "callback", "rb", "nc", "bc", "wb"], "lambda": ["lu", "igma", "alpha", "lam", "ima", " nu", "elta", "mega", "lr", "Lim", "mu", " lam", "Alpha", "tap", "dB", "appa", "mas", "nu", "eye", "beta", "da", " gamma", "pha", "Mu", "phi", "Lu", "aug"], "uplim": ["uphib", "iuplims", "uplims", "uplom", "uselib", "uppim", "uphims", "uphom", "uselom", "iuplim", "uppims", "uppib", "uselims", "uplib", "uppom", "iuplib", "iuplom", "iuppom", "uselim", "iuppims", "iuppib", "iuppim", "uphim"], "bits": ["flags", "items", "bps", "codes", "ins", "pins", "outs", "units", "rows", "bs", "ns", "ints", "bytes", "blocks", "heads", "limits", "gs", "xs", "vals", "its", "bit", "fs", "bis", "cs", "ls", "qs", "ats"], "i": ["init", "t", "li", "ei", "p", "sim", "ki", "bi", "is", "f", "id", "l", "ii", "v", "ini", "ind", "mi", "ix", " bi", "me", "it", "ic", "\u0438", "asi", "hi", "uri", "si", "oi", "j", "di", "gi", "o", "ri", "ji", "ip", "b", "index", "info", "slice", "ui", "multi", "iu", "ij", "xi", "y", "zi", "status", " ti", "ti", "ci", "m", "iii", "this", "ai", "pi", " j", "im", "ims", "x", "I", "phi", "c", "cli", "n", "go", "u", "err", " ii", "batch"], "qc1": ["qt3", " qr1", "qt5", "qr0", "qr8", " qr8", "qt1", "qc0", "qut5", "qrc5", "qr2", "qlc0", "qlc5", "quc0", " qc0", "qc8", "qrc8", "qlc3", "qunc0", "quc3", "qrc2", "qunc8", "qrc0", "qut1", "qut0", "qrc3", "qut3", "qlc1", "qunc2", "qunc1", "qrc1", "qt0", "qr1", " qr0", "quc1", " qr2", "qc5", "quc5", " qc8"], "qc2": ["Qc2", "qunc22", "eqcTwo", "qt6", "qec4", "QtTwo", "Qc6", "qt1", "eqc22", "quncTwo", "qccTwo", "Qt6", "qlc4", "qcc6", "qtTwo", "qlc2", "qcc2", "qcc1", "eqlcTwo", "qc6", "eqlc4", "qcr2", "qc22", "qunc4", "qlcTwo", "qcrTwo", "eqc2", "qcr6", "qec2", "qcr1", "Qc1", "qec22", "qlc22", "qunc2", "Qt1", "QcTwo", "eqlc2", "qt2", "qcTwo", "Qt2", "eqc4", "qecTwo", "eqlc22"], "qc3": ["qt3", "qfc3", "qnThree", "qupc43", "qpc3", "qn4", "qpc2", "qdc4", "qdc8", "qc43", "qufc8", "qdcThree", "qn3", "qdc3", "quc43", "qn8", "qarc43", "quc8", "quc4", "qcthree", "qpcthree", "qc8", "qfc8", "quc3", "qupcthree", "qtthree", "qupc2", "quc2", "qufcThree", "qarcthree", "qufc4", "qucthree", "qt2", "qucThree", "qarc2", "qarc3", "qupc3", "qufc3", "qpc43", "qfcThree", "qcThree", "qfc4", "qt43"], "qc4": ["qt4", "Qc2", "Qc4", "Qt4", "qn4", "qt5", " qn8", "qr5", "Qc44", "qr8", "qn2", "qn8", "Qc8", "qr2", "qc44", "qcr44", "qcr8", "qr4", "qc8", " qc5", " qn2", "Qt8", "qcr2", " qn5", "qt8", "ql44", " qn4", "qcr4", "qt2", "ql4", "Qt44", "qn5", "ql8", "Qt2", "ql2", "qt44", "qc5", " qc8"], "p_bits": ["np_bits", "p_its", "p__its", "p_ints", "p__ints", "p__bits", "np_ints", "np_codes", "p__codes", "np_its"], "p_codes": ["p_names", "p_code", " p_ops", " p_names", " p_code", "p_ops"], "vec": ["sc", "cv", "vc", "v", "ec", "col", "spec", "vert", "q", "val", "ve", "mat", "vector", "ver", "buf", "act", "iv", "res", "conv", "vals", "cs", "var", "seq", "bin", "vol", "vis", "ev"], "vec2": [" vec3", "cv3", " vec6", "vol2", " vec1", "cv2", "vec1", "vec3", "vol6", "vec6", "vol1", "vol3", "cv6", "cv1"], "curidx": ["curidsy", "curidex", "CurIdy", "curridx", "CurIdex", "curridk", "curidsk", "curridy", "Curidy", "curidk", "curIdex", "CurIdk", "curIdk", "Curidk", "Curidx", "curIdx", "curidsex", "CurIdx", "curIdy", "curridex", "curidy", "Curidex", "curidsx"], "curidx2": ["curidxt1", "curindxt0", "curidy2", "curindx4", "curidxt4", "curindx2", "curidy4", "curidex4", "curindx0", "curidx4", "curidy1", "curidxt0", "curidex2", "curidex0", "curidy0", "curidex1", "curindxt4", "curindxt1", "curindx1", "curidx0", "curindxt2", "curidxt2", "curidx1"], "sign1": [" sign3", " sign01", "Sign3", "Sign1", "sum3", "sign3", "Sign01", "sum1", "sum01", "sign01"], "count1": ["cycleone", "cycle0", "collectone", "collectx", "cyclex", "collect1", "countone", "countx", " countx", "count0", " count0", "collect0", "cycle1", " countone"], "sign2": ["sign6", "sum0", "score1", "score6", "sum2", "sign0", " sign0", "score2", "sum6", "sum1", " sign6", "score0"], "count2": ["sum5", " count02", "sum2", "count02", " count5", "Count5", "Count2", "count3", " count3", "Count02", "Count3", "count5", "sum02", "sum3"], "in_int": ["in_float", "out_int", "out_ind", "in___ind", "out_str", "in_str", "in___str", "in_ind", "in___int", "in___float", "out_float"], "in_pos": ["out_position", "out_int", "out_cos", "in_position", "out_pos", "in2cos", "in2int", "in_cos", "in2position", "in2pos"], "di0": ["ci50", "Di3", "ci1", "di50", "Di0", "Di1", "ci3", "Di50", "ci0", " di50"], "di1": ["chi4", "chi1", "siOne", "si0", "di4", "si1", " di4", " diOne", "chi0", "si4", "diOne", "chiOne"], "di2": ["Di5", "Di4", "di4", " di4", "di5", "i2", "Di6", "i4", " di6", "i6", " di5", "Di2", "i5", "di6"], "di3": ["di03", " di03", "i03", "Di4", "di4", "Di3", " di4", "Di03", "i8", "i4", "i3", "di8", " di8", "Di8"], "t0": ["at0", " t00", "t00", "y00", "at1", "y1", "y0", "at00"], "t1": ["tt1", "te01", "T91", "tt01", "te0", "te1", "T1", "t01", "t91", "T0", "tt0", "tt91", "te91", "T01"], "t2": ["tt1", "Ttwo", "T102", "ttwo", "dt102", "t102", "tttwo", "dt1", "T1", "tt2", "T2", "dttwo", "dt2", "tt102"], "t3": [" t03", "et03", "v6", " t6", "t6", "t03", "v03", " tthree", "tthree", "v3", "etthree", "et3", "et6", "vthree"], "t4": ["tfour", "intfour", "T5", " t5", "int3", " tfour", "int4", "T4", "int5", "Tfour", "t5", "T3"]}}
{"project": "qemu", "commit_id": "c1990ebfa11265d3aa9b6a4d5d1a02bd3f9ac5c6", "target": 1, "func": "QObject *json_parser_parse_err(QList *tokens, va_list *ap, Error **errp)\n\n{\n\n    JSONParserContext ctxt = {};\n\n    QList *working = qlist_copy(tokens);\n\n    QObject *result;\n\n\n\n    result = parse_value(&ctxt, &working, ap);\n\n\n\n    QDECREF(working);\n\n\n\n    error_propagate(errp, ctxt.err);\n\n\n\n    return result;\n\n}\n", "idx": 5624, "substitutes": {"tokens": ["stocets", "Tokentials", "tolkens", "tokents", "tokskens", "tocens", "tojENS", "stokkens", "tojens", "tolens", "TocENS", "tocentials", "stockens", "tocents", "targkens", "tolentials", "stokets", "Tockens", "toksens", "stocents", "tockens", "TokENS", "Tocentials", "Tokkens", "toksets", "Tokens", "tocets", "targents", "tocENS", "toksents", "tokkens", "tolENS", "targets", "stokens", "tokENS", "stocens", "stokents", "tokentials", "Tocens", "tojentials", "targens", "tokets", "tojkens"], "ap": ["et", "p", "api", " rap", "att", "app", "mp", "tap", "ag", "apping", "ep", "amp", "pa", "apa", "arp", "ip", " sap", "appy", "cap", "gap", "ipp", "apt", "ape", "ar", "snap", "ac", "Ap", "AP", "hap", " AP", "am", "aps", "al", "av", "ab", " sp", "ing"], "errp": ["dangerpy", " errps", "erps", "diepy", "eorP", "errpa", "diepa", "dangerP", "dangerpa", "dangerp", "errpy", "erP", "eorpat", " errP", "dieP", "eorp", " errpa", "erpat", "errpat", "diep", " errpat", " errpy", "erp", "eorps", "errP", "errps"], "working": ["existing", "picked", "starting", "Working", "running", "tmp", "work", "moving", "checking", "picking", "worker", "ching", "works", "padding", "being", "ordering", "worked", "testing", "opening", "thinking", "learning", "looking", "winning", "acting", "including", "facing", "processing", "going", "loading", "ending", "walking", "workers", "tx", "aux", "standing", "packing", "xp", "using", "playing", "ing"], "result": ["json", "master", "p", "total", "tmp", "either", "success", "f", "work", "nil", "r", "data", "obj", "other", "cur", "the", "self", "object", "valid", "complete", "package", "output", "ret", "root", "current", "response", "answer", "new", "match", "same", "this", "results", "res", "instance", "Result", "unknown", "that", "test", "all", "final", "goal", "mate", "successful", "message", "cache", "next", "out", "event"]}}
{"project": "qemu", "commit_id": "6817efea3a0d1bf87be815970cdb014c5a64b628", "target": 1, "func": "static int init_directories(BDRVVVFATState* s,\n\n                            const char *dirname, int heads, int secs,\n\n                            Error **errp)\n\n{\n\n    bootsector_t* bootsector;\n\n    mapping_t* mapping;\n\n    unsigned int i;\n\n    unsigned int cluster;\n\n\n\n    memset(&(s->first_sectors[0]),0,0x40*0x200);\n\n\n\n    s->cluster_size=s->sectors_per_cluster*0x200;\n\n    s->cluster_buffer=g_malloc(s->cluster_size);\n\n\n\n    /*\n\n     * The formula: sc = spf+1+spf*spc*(512*8/fat_type),\n\n     * where sc is sector_count,\n\n     * spf is sectors_per_fat,\n\n     * spc is sectors_per_clusters, and\n\n     * fat_type = 12, 16 or 32.\n\n     */\n\n    i = 1+s->sectors_per_cluster*0x200*8/s->fat_type;\n\n    s->sectors_per_fat=(s->sector_count+i)/i; /* round up */\n\n\n\n    s->offset_to_fat = s->offset_to_bootsector + 1;\n\n    s->offset_to_root_dir = s->offset_to_fat + s->sectors_per_fat * 2;\n\n\n\n    array_init(&(s->mapping),sizeof(mapping_t));\n\n    array_init(&(s->directory),sizeof(direntry_t));\n\n\n\n    /* add volume label */\n\n    {\n\n        direntry_t* entry=array_get_next(&(s->directory));\n\n        entry->attributes=0x28; /* archive | volume label */\n\n        memcpy(entry->name, s->volume_label, sizeof(entry->name));\n\n    }\n\n\n\n    /* Now build FAT, and write back information into directory */\n\n    init_fat(s);\n\n\n\n    s->cluster_count=sector2cluster(s, s->sector_count);\n\n\n\n    mapping = array_get_next(&(s->mapping));\n\n    mapping->begin = 0;\n\n    mapping->dir_index = 0;\n\n    mapping->info.dir.parent_mapping_index = -1;\n\n    mapping->first_mapping_index = -1;\n\n    mapping->path = g_strdup(dirname);\n\n    i = strlen(mapping->path);\n\n    if (i > 0 && mapping->path[i - 1] == '/')\n\n        mapping->path[i - 1] = '\\0';\n\n    mapping->mode = MODE_DIRECTORY;\n\n    mapping->read_only = 0;\n\n    s->path = mapping->path;\n\n\n\n    for (i = 0, cluster = 0; i < s->mapping.next; i++) {\n\n        /* MS-DOS expects the FAT to be 0 for the root directory\n\n         * (except for the media byte). */\n\n        /* LATER TODO: still true for FAT32? */\n\n        int fix_fat = (i != 0);\n\n        mapping = array_get(&(s->mapping), i);\n\n\n\n        if (mapping->mode & MODE_DIRECTORY) {\n\n            mapping->begin = cluster;\n\n            if(read_directory(s, i)) {\n\n                error_setg(errp, \"Could not read directory %s\",\n\n                           mapping->path);\n\n                return -1;\n\n            }\n\n            mapping = array_get(&(s->mapping), i);\n\n        } else {\n\n            assert(mapping->mode == MODE_UNDEFINED);\n\n            mapping->mode=MODE_NORMAL;\n\n            mapping->begin = cluster;\n\n            if (mapping->end > 0) {\n\n                direntry_t* direntry = array_get(&(s->directory),\n\n                        mapping->dir_index);\n\n\n\n                mapping->end = cluster + 1 + (mapping->end-1)/s->cluster_size;\n\n                set_begin_of_direntry(direntry, mapping->begin);\n\n            } else {\n\n                mapping->end = cluster + 1;\n\n                fix_fat = 0;\n\n            }\n\n        }\n\n\n\n        assert(mapping->begin < mapping->end);\n\n\n\n        /* next free cluster */\n\n        cluster = mapping->end;\n\n\n\n        if(cluster > s->cluster_count) {\n\n            error_setg(errp,\n\n                       \"Directory does not fit in FAT%d (capacity %.2f MB)\",\n\n                       s->fat_type, s->sector_count / 2000.0);\n\n            return -1;\n\n        }\n\n\n\n        /* fix fat for entry */\n\n        if (fix_fat) {\n\n            int j;\n\n            for(j = mapping->begin; j < mapping->end - 1; j++)\n\n                fat_set(s, j, j+1);\n\n            fat_set(s, mapping->end - 1, s->max_fat_value);\n\n        }\n\n    }\n\n\n\n    mapping = array_get(&(s->mapping), 0);\n\n    s->sectors_of_root_directory = mapping->end * s->sectors_per_cluster;\n\n    s->last_cluster_of_root_directory = mapping->end;\n\n\n\n    /* the FAT signature */\n\n    fat_set(s,0,s->max_fat_value);\n\n    fat_set(s,1,s->max_fat_value);\n\n\n\n    s->current_mapping = NULL;\n\n\n\n    bootsector = (bootsector_t *)(s->first_sectors\n\n                                  + s->offset_to_bootsector * 0x200);\n\n    bootsector->jump[0]=0xeb;\n\n    bootsector->jump[1]=0x3e;\n\n    bootsector->jump[2]=0x90;\n\n    memcpy(bootsector->name,\"QEMU    \",8);\n\n    bootsector->sector_size=cpu_to_le16(0x200);\n\n    bootsector->sectors_per_cluster=s->sectors_per_cluster;\n\n    bootsector->reserved_sectors=cpu_to_le16(1);\n\n    bootsector->number_of_fats=0x2; /* number of FATs */\n\n    bootsector->root_entries=cpu_to_le16(s->sectors_of_root_directory*0x10);\n\n    bootsector->total_sectors16=s->sector_count>0xffff?0:cpu_to_le16(s->sector_count);\n\n    /* media descriptor: hard disk=0xf8, floppy=0xf0 */\n\n    bootsector->media_type = (s->offset_to_bootsector > 0 ? 0xf8 : 0xf0);\n\n    s->fat.pointer[0] = bootsector->media_type;\n\n    bootsector->sectors_per_fat=cpu_to_le16(s->sectors_per_fat);\n\n    bootsector->sectors_per_track = cpu_to_le16(secs);\n\n    bootsector->number_of_heads = cpu_to_le16(heads);\n\n    bootsector->hidden_sectors = cpu_to_le32(s->offset_to_bootsector);\n\n    bootsector->total_sectors=cpu_to_le32(s->sector_count>0xffff?s->sector_count:0);\n\n\n\n    /* LATER TODO: if FAT32, this is wrong */\n\n    /* drive_number: fda=0, hda=0x80 */\n\n    bootsector->u.fat16.drive_number = s->offset_to_bootsector == 0 ? 0 : 0x80;\n\n    bootsector->u.fat16.signature=0x29;\n\n    bootsector->u.fat16.id=cpu_to_le32(0xfabe1afd);\n\n\n\n    memcpy(bootsector->u.fat16.volume_label, s->volume_label,\n\n           sizeof(bootsector->u.fat16.volume_label));\n\n    memcpy(bootsector->u.fat16.fat_type,\n\n           s->fat_type == 12 ? \"FAT12   \" : \"FAT16   \", 8);\n\n    bootsector->magic[0]=0x55; bootsector->magic[1]=0xaa;\n\n\n\n    return 0;\n\n}\n", "idx": 5630, "substitutes": {"s": ["p", "conf", "https", "full", "l", "sl", "self", "ns", "ses", "gs", "y", "sym", "stats", "results", "xs", "its", "ims", "c", "settings", "n", "qs", "eps", "services", "S", "a", "r", "ps", "vs", "w", "less", "ss", "h", "esm", "changes", "js", "b", "sts", "ts", "stat", "ops", "simple", "fs", "storage", "csv", "sb", "series", "ats", "sys", "states", "tests", "sports", "details", "is", "sam", "ports", "events", "aws", "params", "bs", "space", "source", "state", "rs", "m", "cs", "as", "ls", "t", "os", "ds", "south", "ms", "v", "spec", "ies", "sync", "sm", "set", "single", "comm", "hs", "an", "g", "store", "status", "es", "utils", "service", "sv", "parts", "se", "sw"], "dirname": ["dirnames", "dirn", " dirName", "pathName", "dirame", "portName", "DIRame", "DIRname", " dirnames", "pathame", "dirName", "pathname", "disknam", " dirnam", "DIRName", "dirnam", "portn", "portname", "DIRnames", "pathnames", "diskName", " dirame", "portnam", " dirn", "diskn", "diskname"], "heads": ["runs", "ih", "uns", "ms", "links", "sets", "sections", "locks", "loads", "irs", "h", "ths", "bs", "ints", "resh", "ashes", "maps", "blocks", "sh", "ires", "ts", "reads", "head", "its", "offs", "headers", "urs", "cycles"], "secs": ["seqss", "seqsd", "micross", "secp", "seqp", "strss", "micros", "secss", "strs", "microsd", "strsd", "seqs", "microp", "secsd", "strp"], "errp": ["errps", "erp", "errsp", " errps", "errorsp", "ersp", "erps", "errr", "errorp", " errsp", "errorr", " errr", "err", "errorps"], "bootsector": ["ootsection", "rootsector", "Bootsection", "rootsection", "rootvector", "bootvector", "ootsector", "Bootvector", "bootsection", "ootvector", "Bootsector"], "mapping": ["emoding", "omapping", "matching", "mappings", " mapper", "cmap", " matching", "minding", "dapping", "vapping", "mmap", "Mapper", "Map", "omap", "smapping", "smap", "emapped", "dap", " map", "imapper", "commapper", "emapper", "mapper", "Mapping", "commoding", "imapping", "cmapping", "imapped", "remapper", "latching", "mmapper", "Mappings", "lapped", "lapper", "mmapped", "Mmap", "remutation", "remapping", "commapping", " mmap", "ematching", "vapped", " mutation", "cmapper", "vapper", "Mutation", "map", "Minding", "moding", " mappings", "dapper", " mapped", "emapping", "smapper", "imatching", "remapped", "omapper", "Matching", "commapped", "lapping", "mapped", "ommap", "tmap", "smapped", "dinding", "omapped", "mmapping", "ominding", "Mapped", "dapped", "mmappings", "tmapper", "cmapped", "tmapped", "tmapping", "mutation", " moding", "vap"], "i": ["init", "t", "li", "p", "ori", "sim", "fi", "bi", "is", "f", "a", "id", "ind", "ii", "v", "l", "data", "mi", "ix", "it", "list", "ic", "z", "\u0438", "si", "oi", "di", "h", "o", "gi", "io", "chain", "ip", "b", "index", "info", "slice", "ui", "iu", "multi", "xi", "ij", "y", "zi", "status", "e", "ci", "ti", "m", "iri", "ai", "pi", "im", "ni", "x", "I", "phi", "qi", "c", "cli", "n", "u", "batch"], "cluster": ["clust", "glust", "pluster", "custers", "plusters", "gluration", "plust", "gluster", "pluration", "glusters", "custer", "cust", "clusters", "curation", "cluration"], "entry": ["key", "jar", "office", "de", "element", "delete", "resource", "archive", "nt", "channel", "it", "file", "connection", "folder", "or", "port", "ry", "option", "attribute", "ie", "word", "cell", "link", "ary", "section", "dir", "name", "def", "index", "comment", "member", "ner", "row", "Entry", "e", "record", "ment", "instance", "rent", "line", "page", "pair", "try", "child", "existent", "byte", "ent", "import", "item", "directory", "er", "se", "event"]}}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)\n\n{\n\n    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);\n\n    s->freq = PXA25X_FREQ;\n\n    s->tm4 = NULL;\n\n}\n", "idx": 5646, "substitutes": {"base": [" Base", "p", "bound", "reset", "f", "origin", "bid", "common", "data", "real", "re", "prefix", "bas", "stable", "check", " bases", "address", "phy", "set", "profile", "b", "birth", "name", "mac", "info", "orig", "root", "mb", "type", "ref", "buffer", "area", "Base", "eta", "based", "ase", "bp", "basic", "bf", "back", "from", "kit", "create", "se", "template"], "irqs": ["irqu", "ibrqs", " mirqs", " irfs", "mircles", "arqu", "irques", "ircles", "ircs", " ircles", " mircles", "mirqs", "pircs", "ibrques", " ircs", " mirfs", "arques", "arcs", "pirques", "arqs", "irfs", "pirqs", " mircs", "pirqu", "ibrqu", "ibrcs", "mircs", "mirfs"], "s": ["t", "S", "p", "ds", "details", "is", "a", "ps", "spec", "ins", "sync", "sl", "set", "ss", "j", "aws", "h", "comm", "so", "bs", "i", "js", "ns", "source", "sq", "info", "sts", "response", "rs", "store", "gs", "su", "ts", "stats", "fs", "service", "sv", "sb", "settings", "services", "ls", "ats", "sol", "sa"]}}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "struct omap_mpu_state_s *omap2420_mpu_init(unsigned long sdram_size,\n\n                const char *core)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)\n\n            g_malloc0(sizeof(struct omap_mpu_state_s));\n\n    ram_addr_t sram_base, q2_base;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq dma_irqs[4];\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    SysBusDevice *busdev;\n\n    struct omap_target_agent_s *ta;\n\n\n\n    /* Core */\n\n    s->mpu_model = omap2420;\n\n    s->env = cpu_init(core ?: \"arm1136-r2\");\n\n    if (!s->env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->sdram_size = sdram_size;\n\n    s->sram_size = OMAP242X_SRAM_SIZE;\n\n\n\n    s->wakeup = qemu_allocate_irqs(omap_mpu_wakeup, s, 1)[0];\n\n\n\n    /* Clocks */\n\n    omap_clk_init(s);\n\n\n\n    /* Memory-mapped stuff */\n\n    cpu_register_physical_memory(OMAP2_Q2_BASE, s->sdram_size,\n\n                    (q2_base = qemu_ram_alloc(NULL, \"omap2.dram\",\n\n                                              s->sdram_size)) | IO_MEM_RAM);\n\n    cpu_register_physical_memory(OMAP2_SRAM_BASE, s->sram_size,\n\n                    (sram_base = qemu_ram_alloc(NULL, \"omap2.sram\",\n\n                                                s->sram_size)) | IO_MEM_RAM);\n\n\n\n    s->l4 = omap_l4_init(OMAP2_L4_BASE, 54);\n\n\n\n    /* Actually mapped at any 2K boundary in the ARM11 private-peripheral if */\n\n    cpu_irq = arm_pic_init_cpu(s->env);\n\n    s->ih[0] = omap2_inth_init(0x480fe000, 0x1000, 3, &s->irq[0],\n\n                    cpu_irq[ARM_PIC_CPU_IRQ], cpu_irq[ARM_PIC_CPU_FIQ],\n\n                    omap_findclk(s, \"mpu_intc_fclk\"),\n\n                    omap_findclk(s, \"mpu_intc_iclk\"));\n\n\n\n    s->prcm = omap_prcm_init(omap_l4tao(s->l4, 3),\n\n                    s->irq[0][OMAP_INT_24XX_PRCM_MPU_IRQ], NULL, NULL, s);\n\n\n\n    s->sysc = omap_sysctl_init(omap_l4tao(s->l4, 1),\n\n                    omap_findclk(s, \"omapctrl_iclk\"), s);\n\n\n\n    for (i = 0; i < 4; i ++)\n\n        dma_irqs[i] =\n\n                s->irq[omap2_dma_irq_map[i].ih][omap2_dma_irq_map[i].intr];\n\n    s->dma = omap_dma4_init(0x48056000, dma_irqs, s, 256, 32,\n\n                    omap_findclk(s, \"sdma_iclk\"),\n\n                    omap_findclk(s, \"sdma_fclk\"));\n\n    s->port->addr_valid = omap2_validate_addr;\n\n\n\n    /* Register SDRAM and SRAM ports for fast DMA transfers.  */\n\n    soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(q2_base),\n\n                         OMAP2_Q2_BASE, s->sdram_size);\n\n    soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(sram_base),\n\n                         OMAP2_SRAM_BASE, s->sram_size);\n\n\n\n    s->uart[0] = omap2_uart_init(omap_l4ta(s->l4, 19),\n\n                    s->irq[0][OMAP_INT_24XX_UART1_IRQ],\n\n                    omap_findclk(s, \"uart1_fclk\"),\n\n                    omap_findclk(s, \"uart1_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART1_TX],\n\n                    s->drq[OMAP24XX_DMA_UART1_RX],\n\n                    \"uart1\",\n\n                    serial_hds[0]);\n\n    s->uart[1] = omap2_uart_init(omap_l4ta(s->l4, 20),\n\n                    s->irq[0][OMAP_INT_24XX_UART2_IRQ],\n\n                    omap_findclk(s, \"uart2_fclk\"),\n\n                    omap_findclk(s, \"uart2_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART2_TX],\n\n                    s->drq[OMAP24XX_DMA_UART2_RX],\n\n                    \"uart2\",\n\n                    serial_hds[0] ? serial_hds[1] : NULL);\n\n    s->uart[2] = omap2_uart_init(omap_l4ta(s->l4, 21),\n\n                    s->irq[0][OMAP_INT_24XX_UART3_IRQ],\n\n                    omap_findclk(s, \"uart3_fclk\"),\n\n                    omap_findclk(s, \"uart3_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART3_TX],\n\n                    s->drq[OMAP24XX_DMA_UART3_RX],\n\n                    \"uart3\",\n\n                    serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL);\n\n\n\n    s->gptimer[0] = omap_gp_timer_init(omap_l4ta(s->l4, 7),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER1],\n\n                    omap_findclk(s, \"wu_gpt1_clk\"),\n\n                    omap_findclk(s, \"wu_l4_iclk\"));\n\n    s->gptimer[1] = omap_gp_timer_init(omap_l4ta(s->l4, 8),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER2],\n\n                    omap_findclk(s, \"core_gpt2_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[2] = omap_gp_timer_init(omap_l4ta(s->l4, 22),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER3],\n\n                    omap_findclk(s, \"core_gpt3_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[3] = omap_gp_timer_init(omap_l4ta(s->l4, 23),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER4],\n\n                    omap_findclk(s, \"core_gpt4_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[4] = omap_gp_timer_init(omap_l4ta(s->l4, 24),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER5],\n\n                    omap_findclk(s, \"core_gpt5_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[5] = omap_gp_timer_init(omap_l4ta(s->l4, 25),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER6],\n\n                    omap_findclk(s, \"core_gpt6_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[6] = omap_gp_timer_init(omap_l4ta(s->l4, 26),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER7],\n\n                    omap_findclk(s, \"core_gpt7_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[7] = omap_gp_timer_init(omap_l4ta(s->l4, 27),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER8],\n\n                    omap_findclk(s, \"core_gpt8_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[8] = omap_gp_timer_init(omap_l4ta(s->l4, 28),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER9],\n\n                    omap_findclk(s, \"core_gpt9_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[9] = omap_gp_timer_init(omap_l4ta(s->l4, 29),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER10],\n\n                    omap_findclk(s, \"core_gpt10_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[10] = omap_gp_timer_init(omap_l4ta(s->l4, 30),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER11],\n\n                    omap_findclk(s, \"core_gpt11_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[11] = omap_gp_timer_init(omap_l4ta(s->l4, 31),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER12],\n\n                    omap_findclk(s, \"core_gpt12_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    omap_tap_init(omap_l4ta(s->l4, 2), s);\n\n\n\n    s->synctimer = omap_synctimer_init(omap_l4tao(s->l4, 2), s,\n\n                    omap_findclk(s, \"clk32-kHz\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    s->i2c[0] = omap2_i2c_init(omap_l4tao(s->l4, 5),\n\n                    s->irq[0][OMAP_INT_24XX_I2C1_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_I2C1_TX],\n\n                    omap_findclk(s, \"i2c1.fclk\"),\n\n                    omap_findclk(s, \"i2c1.iclk\"));\n\n    s->i2c[1] = omap2_i2c_init(omap_l4tao(s->l4, 6),\n\n                    s->irq[0][OMAP_INT_24XX_I2C2_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_I2C2_TX],\n\n                    omap_findclk(s, \"i2c2.fclk\"),\n\n                    omap_findclk(s, \"i2c2.iclk\"));\n\n\n\n    s->gpio = qdev_create(NULL, \"omap2-gpio\");\n\n    qdev_prop_set_int32(s->gpio, \"mpu_model\", s->mpu_model);\n\n    qdev_prop_set_ptr(s->gpio, \"iclk\", omap_findclk(s, \"gpio_iclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk0\", omap_findclk(s, \"gpio1_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk1\", omap_findclk(s, \"gpio2_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk2\", omap_findclk(s, \"gpio3_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk3\", omap_findclk(s, \"gpio4_dbclk\"));\n\n    if (s->mpu_model == omap2430) {\n\n        qdev_prop_set_ptr(s->gpio, \"fclk4\", omap_findclk(s, \"gpio5_dbclk\"));\n\n    }\n\n    qdev_init_nofail(s->gpio);\n\n    busdev = sysbus_from_qdev(s->gpio);\n\n    sysbus_connect_irq(busdev, 0, s->irq[0][OMAP_INT_24XX_GPIO_BANK1]);\n\n    sysbus_connect_irq(busdev, 3, s->irq[0][OMAP_INT_24XX_GPIO_BANK2]);\n\n    sysbus_connect_irq(busdev, 6, s->irq[0][OMAP_INT_24XX_GPIO_BANK3]);\n\n    sysbus_connect_irq(busdev, 9, s->irq[0][OMAP_INT_24XX_GPIO_BANK4]);\n\n    ta = omap_l4ta(s->l4, 3);\n\n    sysbus_mmio_map(busdev, 0, omap_l4_region_base(ta, 1));\n\n    sysbus_mmio_map(busdev, 1, omap_l4_region_base(ta, 0));\n\n    sysbus_mmio_map(busdev, 2, omap_l4_region_base(ta, 2));\n\n    sysbus_mmio_map(busdev, 3, omap_l4_region_base(ta, 4));\n\n    sysbus_mmio_map(busdev, 4, omap_l4_region_base(ta, 5));\n\n\n\n    s->sdrc = omap_sdrc_init(0x68009000);\n\n    s->gpmc = omap_gpmc_init(s, 0x6800a000, s->irq[0][OMAP_INT_24XX_GPMC_IRQ],\n\n                             s->drq[OMAP24XX_DMA_GPMC]);\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = omap2_mmc_init(omap_l4tao(s->l4, 9), dinfo->bdrv,\n\n                    s->irq[0][OMAP_INT_24XX_MMC_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_MMC1_TX],\n\n                    omap_findclk(s, \"mmc_fclk\"), omap_findclk(s, \"mmc_iclk\"));\n\n\n\n    s->mcspi[0] = omap_mcspi_init(omap_l4ta(s->l4, 35), 4,\n\n                    s->irq[0][OMAP_INT_24XX_MCSPI1_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_SPI1_TX0],\n\n                    omap_findclk(s, \"spi1_fclk\"),\n\n                    omap_findclk(s, \"spi1_iclk\"));\n\n    s->mcspi[1] = omap_mcspi_init(omap_l4ta(s->l4, 36), 2,\n\n                    s->irq[0][OMAP_INT_24XX_MCSPI2_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_SPI2_TX0],\n\n                    omap_findclk(s, \"spi2_fclk\"),\n\n                    omap_findclk(s, \"spi2_iclk\"));\n\n\n\n    s->dss = omap_dss_init(omap_l4ta(s->l4, 10), 0x68000800,\n\n                    /* XXX wire M_IRQ_25, D_L2_IRQ_30 and I_IRQ_13 together */\n\n                    s->irq[0][OMAP_INT_24XX_DSS_IRQ], s->drq[OMAP24XX_DMA_DSS],\n\n                    omap_findclk(s, \"dss_clk1\"), omap_findclk(s, \"dss_clk2\"),\n\n                    omap_findclk(s, \"dss_54m_clk\"),\n\n                    omap_findclk(s, \"dss_l3_iclk\"),\n\n                    omap_findclk(s, \"dss_l4_iclk\"));\n\n\n\n    omap_sti_init(omap_l4ta(s->l4, 18), 0x54000000,\n\n                    s->irq[0][OMAP_INT_24XX_STI], omap_findclk(s, \"emul_ck\"),\n\n                    serial_hds[0] && serial_hds[1] && serial_hds[2] ?\n\n                    serial_hds[3] : NULL);\n\n\n\n    s->eac = omap_eac_init(omap_l4ta(s->l4, 32),\n\n                    s->irq[0][OMAP_INT_24XX_EAC_IRQ],\n\n                    /* Ten consecutive lines */\n\n                    &s->drq[OMAP24XX_DMA_EAC_AC_RD],\n\n                    omap_findclk(s, \"func_96m_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    /* All register mappings (includin those not currenlty implemented):\n\n     * SystemControlMod\t48000000 - 48000fff\n\n     * SystemControlL4\t48001000 - 48001fff\n\n     * 32kHz Timer Mod\t48004000 - 48004fff\n\n     * 32kHz Timer L4\t48005000 - 48005fff\n\n     * PRCM ModA\t48008000 - 480087ff\n\n     * PRCM ModB\t48008800 - 48008fff\n\n     * PRCM L4\t\t48009000 - 48009fff\n\n     * TEST-BCM Mod\t48012000 - 48012fff\n\n     * TEST-BCM L4\t48013000 - 48013fff\n\n     * TEST-TAP Mod\t48014000 - 48014fff\n\n     * TEST-TAP L4\t48015000 - 48015fff\n\n     * GPIO1 Mod\t48018000 - 48018fff\n\n     * GPIO Top\t\t48019000 - 48019fff\n\n     * GPIO2 Mod\t4801a000 - 4801afff\n\n     * GPIO L4\t\t4801b000 - 4801bfff\n\n     * GPIO3 Mod\t4801c000 - 4801cfff\n\n     * GPIO4 Mod\t4801e000 - 4801efff\n\n     * WDTIMER1 Mod\t48020000 - 48010fff\n\n     * WDTIMER Top\t48021000 - 48011fff\n\n     * WDTIMER2 Mod\t48022000 - 48012fff\n\n     * WDTIMER L4\t48023000 - 48013fff\n\n     * WDTIMER3 Mod\t48024000 - 48014fff\n\n     * WDTIMER3 L4\t48025000 - 48015fff\n\n     * WDTIMER4 Mod\t48026000 - 48016fff\n\n     * WDTIMER4 L4\t48027000 - 48017fff\n\n     * GPTIMER1 Mod\t48028000 - 48018fff\n\n     * GPTIMER1 L4\t48029000 - 48019fff\n\n     * GPTIMER2 Mod\t4802a000 - 4801afff\n\n     * GPTIMER2 L4\t4802b000 - 4801bfff\n\n     * L4-Config AP\t48040000 - 480407ff\n\n     * L4-Config IP\t48040800 - 48040fff\n\n     * L4-Config LA\t48041000 - 48041fff\n\n     * ARM11ETB Mod\t48048000 - 48049fff\n\n     * ARM11ETB L4\t4804a000 - 4804afff\n\n     * DISPLAY Top\t48050000 - 480503ff\n\n     * DISPLAY DISPC\t48050400 - 480507ff\n\n     * DISPLAY RFBI\t48050800 - 48050bff\n\n     * DISPLAY VENC\t48050c00 - 48050fff\n\n     * DISPLAY L4\t48051000 - 48051fff\n\n     * CAMERA Top\t48052000 - 480523ff\n\n     * CAMERA core\t48052400 - 480527ff\n\n     * CAMERA DMA\t48052800 - 48052bff\n\n     * CAMERA MMU\t48052c00 - 48052fff\n\n     * CAMERA L4\t48053000 - 48053fff\n\n     * SDMA Mod\t\t48056000 - 48056fff\n\n     * SDMA L4\t\t48057000 - 48057fff\n\n     * SSI Top\t\t48058000 - 48058fff\n\n     * SSI GDD\t\t48059000 - 48059fff\n\n     * SSI Port1\t4805a000 - 4805afff\n\n     * SSI Port2\t4805b000 - 4805bfff\n\n     * SSI L4\t\t4805c000 - 4805cfff\n\n     * USB Mod\t\t4805e000 - 480fefff\n\n     * USB L4\t\t4805f000 - 480fffff\n\n     * WIN_TRACER1 Mod\t48060000 - 48060fff\n\n     * WIN_TRACER1 L4\t48061000 - 48061fff\n\n     * WIN_TRACER2 Mod\t48062000 - 48062fff\n\n     * WIN_TRACER2 L4\t48063000 - 48063fff\n\n     * WIN_TRACER3 Mod\t48064000 - 48064fff\n\n     * WIN_TRACER3 L4\t48065000 - 48065fff\n\n     * WIN_TRACER4 Top\t48066000 - 480660ff\n\n     * WIN_TRACER4 ETT\t48066100 - 480661ff\n\n     * WIN_TRACER4 WT\t48066200 - 480662ff\n\n     * WIN_TRACER4 L4\t48067000 - 48067fff\n\n     * XTI Mod\t\t48068000 - 48068fff\n\n     * XTI L4\t\t48069000 - 48069fff\n\n     * UART1 Mod\t4806a000 - 4806afff\n\n     * UART1 L4\t\t4806b000 - 4806bfff\n\n     * UART2 Mod\t4806c000 - 4806cfff\n\n     * UART2 L4\t\t4806d000 - 4806dfff\n\n     * UART3 Mod\t4806e000 - 4806efff\n\n     * UART3 L4\t\t4806f000 - 4806ffff\n\n     * I2C1 Mod\t\t48070000 - 48070fff\n\n     * I2C1 L4\t\t48071000 - 48071fff\n\n     * I2C2 Mod\t\t48072000 - 48072fff\n\n     * I2C2 L4\t\t48073000 - 48073fff\n\n     * McBSP1 Mod\t48074000 - 48074fff\n\n     * McBSP1 L4\t48075000 - 48075fff\n\n     * McBSP2 Mod\t48076000 - 48076fff\n\n     * McBSP2 L4\t48077000 - 48077fff\n\n     * GPTIMER3 Mod\t48078000 - 48078fff\n\n     * GPTIMER3 L4\t48079000 - 48079fff\n\n     * GPTIMER4 Mod\t4807a000 - 4807afff\n\n     * GPTIMER4 L4\t4807b000 - 4807bfff\n\n     * GPTIMER5 Mod\t4807c000 - 4807cfff\n\n     * GPTIMER5 L4\t4807d000 - 4807dfff\n\n     * GPTIMER6 Mod\t4807e000 - 4807efff\n\n     * GPTIMER6 L4\t4807f000 - 4807ffff\n\n     * GPTIMER7 Mod\t48080000 - 48080fff\n\n     * GPTIMER7 L4\t48081000 - 48081fff\n\n     * GPTIMER8 Mod\t48082000 - 48082fff\n\n     * GPTIMER8 L4\t48083000 - 48083fff\n\n     * GPTIMER9 Mod\t48084000 - 48084fff\n\n     * GPTIMER9 L4\t48085000 - 48085fff\n\n     * GPTIMER10 Mod\t48086000 - 48086fff\n\n     * GPTIMER10 L4\t48087000 - 48087fff\n\n     * GPTIMER11 Mod\t48088000 - 48088fff\n\n     * GPTIMER11 L4\t48089000 - 48089fff\n\n     * GPTIMER12 Mod\t4808a000 - 4808afff\n\n     * GPTIMER12 L4\t4808b000 - 4808bfff\n\n     * EAC Mod\t\t48090000 - 48090fff\n\n     * EAC L4\t\t48091000 - 48091fff\n\n     * FAC Mod\t\t48092000 - 48092fff\n\n     * FAC L4\t\t48093000 - 48093fff\n\n     * MAILBOX Mod\t48094000 - 48094fff\n\n     * MAILBOX L4\t48095000 - 48095fff\n\n     * SPI1 Mod\t\t48098000 - 48098fff\n\n     * SPI1 L4\t\t48099000 - 48099fff\n\n     * SPI2 Mod\t\t4809a000 - 4809afff\n\n     * SPI2 L4\t\t4809b000 - 4809bfff\n\n     * MMC/SDIO Mod\t4809c000 - 4809cfff\n\n     * MMC/SDIO L4\t4809d000 - 4809dfff\n\n     * MS_PRO Mod\t4809e000 - 4809efff\n\n     * MS_PRO L4\t4809f000 - 4809ffff\n\n     * RNG Mod\t\t480a0000 - 480a0fff\n\n     * RNG L4\t\t480a1000 - 480a1fff\n\n     * DES3DES Mod\t480a2000 - 480a2fff\n\n     * DES3DES L4\t480a3000 - 480a3fff\n\n     * SHA1MD5 Mod\t480a4000 - 480a4fff\n\n     * SHA1MD5 L4\t480a5000 - 480a5fff\n\n     * AES Mod\t\t480a6000 - 480a6fff\n\n     * AES L4\t\t480a7000 - 480a7fff\n\n     * PKA Mod\t\t480a8000 - 480a9fff\n\n     * PKA L4\t\t480aa000 - 480aafff\n\n     * MG Mod\t\t480b0000 - 480b0fff\n\n     * MG L4\t\t480b1000 - 480b1fff\n\n     * HDQ/1-wire Mod\t480b2000 - 480b2fff\n\n     * HDQ/1-wire L4\t480b3000 - 480b3fff\n\n     * MPU interrupt\t480fe000 - 480fefff\n\n     * STI channel base\t54000000 - 5400ffff\n\n     * IVA RAM\t\t5c000000 - 5c01ffff\n\n     * IVA ROM\t\t5c020000 - 5c027fff\n\n     * IMG_BUF_A\t5c040000 - 5c040fff\n\n     * IMG_BUF_B\t5c042000 - 5c042fff\n\n     * VLCDS\t\t5c048000 - 5c0487ff\n\n     * IMX_COEF\t\t5c049000 - 5c04afff\n\n     * IMX_CMD\t\t5c051000 - 5c051fff\n\n     * VLCDQ\t\t5c053000 - 5c0533ff\n\n     * VLCDH\t\t5c054000 - 5c054fff\n\n     * SEQ_CMD\t\t5c055000 - 5c055fff\n\n     * IMX_REG\t\t5c056000 - 5c0560ff\n\n     * VLCD_REG\t\t5c056100 - 5c0561ff\n\n     * SEQ_REG\t\t5c056200 - 5c0562ff\n\n     * IMG_BUF_REG\t5c056300 - 5c0563ff\n\n     * SEQIRQ_REG\t5c056400 - 5c0564ff\n\n     * OCP_REG\t\t5c060000 - 5c060fff\n\n     * SYSC_REG\t\t5c070000 - 5c070fff\n\n     * MMU_REG\t\t5d000000 - 5d000fff\n\n     * sDMA R\t\t68000400 - 680005ff\n\n     * sDMA W\t\t68000600 - 680007ff\n\n     * Display Control\t68000800 - 680009ff\n\n     * DSP subsystem\t68000a00 - 68000bff\n\n     * MPU subsystem\t68000c00 - 68000dff\n\n     * IVA subsystem\t68001000 - 680011ff\n\n     * USB\t\t68001200 - 680013ff\n\n     * Camera\t\t68001400 - 680015ff\n\n     * VLYNQ (firewall)\t68001800 - 68001bff\n\n     * VLYNQ\t\t68001e00 - 68001fff\n\n     * SSI\t\t68002000 - 680021ff\n\n     * L4\t\t68002400 - 680025ff\n\n     * DSP (firewall)\t68002800 - 68002bff\n\n     * DSP subsystem\t68002e00 - 68002fff\n\n     * IVA (firewall)\t68003000 - 680033ff\n\n     * IVA\t\t68003600 - 680037ff\n\n     * GFX\t\t68003a00 - 68003bff\n\n     * CMDWR emulation\t68003c00 - 68003dff\n\n     * SMS\t\t68004000 - 680041ff\n\n     * OCM\t\t68004200 - 680043ff\n\n     * GPMC\t\t68004400 - 680045ff\n\n     * RAM (firewall)\t68005000 - 680053ff\n\n     * RAM (err login)\t68005400 - 680057ff\n\n     * ROM (firewall)\t68005800 - 68005bff\n\n     * ROM (err login)\t68005c00 - 68005fff\n\n     * GPMC (firewall)\t68006000 - 680063ff\n\n     * GPMC (err login)\t68006400 - 680067ff\n\n     * SMS (err login)\t68006c00 - 68006fff\n\n     * SMS registers\t68008000 - 68008fff\n\n     * SDRC registers\t68009000 - 68009fff\n\n     * GPMC registers\t6800a000   6800afff\n\n     */\n\n\n\n    qemu_register_reset(omap2_mpu_reset, s);\n\n\n\n    return s;\n\n}\n", "idx": 5670, "substitutes": {"sdram_size": ["sdram_base", "sdram_scale", "sdramtsize", "sdram_SIZE", "sdgram2Size", "sdram2size", "sdram2length", "sdram0set", "sdram_style", "sdramtbase", "sdgram_len", "sdgram_size", "sdramtset", "sdgram_Size", "sdrum_style", "sdrum_scale", "sdramtname", "sdram0base", "sdrum_SIZE", "sdgram_SIZE", "sdrum_size", "sdgram2length", "sdgram_mode", "sdram2Size", "sdram0size", "sdram2SIZE", "sdram_length", "sdgram2SIZE", "sdram_name", "sdgram2size", "sdram_mode", "sdram_Size", "sdram_set", "sdgram_length", "sdmem_name", "sdmem_base", "sdmem_size", "sdram2len", "sdram_len", "sdmem_set", "sdram0name"], "core": ["key", "aster", " Core", "sc", "cp", "primary", "pure", "copy", "cer", "binary", "processor", "col", "board", "pc", "ready", "Core", "force", "node", "ox", "ether", "platform", "k", "ve", "gate", "cycle", "cr", "io", "cow", "ie", "ores", "cpu", "type", "ore", "cy", "gp", "raw", "bit", "pu", "ca", "base", "ce", "c", "ro", "custom", "er", "program", "score"], "s": ["p", "l", "sl", "gets", "ns", "ses", "gs", "y", "stats", "its", "ims", "c", "des", "settings", "n", "qs", "eps", "services", "S", "a", "ares", "sp", "r", "ps", "vs", "ins", "obj", "w", "less", "ss", "h", "j", "changes", "js", "b", "sts", "ts", "ops", "bits", "fs", "args", "sb", "als", "ats", "states", "sa", "tests", "sports", "details", "is", "d", "sam", "ports", "params", "aws", "so", "bs", "source", "space", "rs", "e", "m", "cs", "as", "ls", "t", "os", "ds", "ms", "v", "spec", "ies", "sm", "set", "o", "comm", "hs", "an", "g", "status", "es", "utils", "service", "sv", "se"], "sram_base": ["sgram_enable", "sgram_buffer", "sramxb", "sram0buffer", "sram0base", "sram_offset", "smem_b", "smem_base", "sram_size", "sramxbase", "sram0offset", "sgram_base", "sgram_offset", "sram_enable", "sram_b", "sramxsize", "sram_buffer", "sram0enable", "smem_size"], "q2_base": ["q2_Base", "q12_Base", "q3_store", "q2_bas", "q2tBase", "q3_Base", "q12_bas", "q2_ase", "q3tBase", "q12_ase", "q2tbase", "q12_base", "q2tstore", "q3_base", "q2_store", "q3tstore", "q3tbase"], "cpu_irq": ["cpu_pirQ", "cpu__pirq", "cpu_iraqs", "cpu__irq", "cpu_irqu", "cpu_irQ", "cpu_pirch", "cpu_pirqi", "cpu_erq", "cpu_pirqs", "cpu_irad", "cpu__irch", "cpu_irqs", "cpu_mirqs", "cpu_ird", "cpu_mirk", "cpu_mirq", "cpu__pirch", "cpu__pirqs", "cpu_drQ", "cpu_mirch", "cpu_mirqi", "cpu__irqs", "cpu_ierQ", "cpu_iraqi", "cpu_irak", "cpu_arqs", "cpu_mirQ", "cpu_irk", "cpu_iraq", "cpu_pirq", "cpu_drqs", "cpu_irqi", "cpu_ierq", "cpu__pirQ", "cpu_arch", "cpu_ierqi", "cpu_erqs", "cpu_erqu", "cpu_mird", "cpu_mirqu", "cpu_irch", "cpu_ark", "cpu_arq", "cpu_ierqs", "cpu_erqi", "cpu_ard", "cpu_drq", "cpu_iraqu", "cpu_drqi", "cpu_arQ", "cpu__irQ"], "dma_irqs": ["dma_pirques", "dma_pirq", "dma_iroqs", "dma_irqu", "dma_rinq", "dma_rinqu", "dma_irq", "dma_iroques", "dma_iroqu", "dma_iroq", "dma_rinques", "dma_irques", "dma_rinqs", "dma_pirqu", "dma_pirqs"], "dinfo": [" ddata", "dInfo", " dInfo", "dinf", "Dinfo", "vdata", "vInfo", "ddata", "Ddata", "vinfo", "Dinf", "DInfo", "vinf", " dinf"], "i": ["ia", " I", "li", "p", "ki", "fi", "l", "v", "ii", " bi", " pi", "it", "si", "oi", "j", "di", "o", "io", "b", "iu", "y", "e", "ci", "m", "iy", "ai", "pi", "I"], "busdev": ["blockio", "boardinfo", " busdevice", "businfo", "busdevice", "boarddevice", "busio", " busio", "boarddev", "blockinfo", "blockdev", "blockdevice", "boardio", " businfo"], "ta": ["tc", "ka", "aa", "tta", "ha", "Ta", "wa", "tap", "ga", "pa", "ra", "fa", "ba", "da", "ata", "ts", "ti", "te", " ki", "ca", "ai", "au", "tm", "sha", "TA", "ao", "tu", "va", "sa"]}}
{"project": "qemu", "commit_id": "c878da3b27ceeed953c9f9a1eb002d59e9dcb4c6", "target": 0, "func": "static void tcg_out_qemu_ld_slow_path (TCGContext *s, TCGLabelQemuLdst *label)\n\n{\n\n    int s_bits;\n\n    int ir;\n\n    int opc = label->opc;\n\n    int mem_index = label->mem_index;\n\n    int data_reg = label->datalo_reg;\n\n    int data_reg2 = label->datahi_reg;\n\n    int addr_reg = label->addrlo_reg;\n\n    uint8_t *raddr = label->raddr;\n\n    uint8_t **label_ptr = &label->label_ptr[0];\n\n\n\n    s_bits = opc & 3;\n\n\n\n    /* resolve label address */\n\n    reloc_pc14 (label_ptr[0], (tcg_target_long) s->code_ptr);\n\n\n\n    /* slow path */\n\n    ir = 3;\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, TCG_AREG0);\n\n#if TARGET_LONG_BITS == 32\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);\n\n#else\n\n#ifdef TCG_TARGET_CALL_ALIGN_ARGS\n\n    ir |= 1;\n\n#endif\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, label->addrhi_reg);\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);\n\n#endif\n\n    tcg_out_movi (s, TCG_TYPE_I32, ir, mem_index);\n\n    tcg_out_call (s, (tcg_target_long) qemu_ld_helpers[s_bits], 1);\n\n    tcg_out32 (s, B | 8);\n\n    tcg_out32 (s, (tcg_target_long) raddr);\n\n    switch (opc) {\n\n    case 0|4:\n\n        tcg_out32 (s, EXTSB | RA (data_reg) | RS (3));\n\n        break;\n\n    case 1|4:\n\n        tcg_out32 (s, EXTSH | RA (data_reg) | RS (3));\n\n        break;\n\n    case 0:\n\n    case 1:\n\n    case 2:\n\n        if (data_reg != 3)\n\n            tcg_out_mov (s, TCG_TYPE_I32, data_reg, 3);\n\n        break;\n\n    case 3:\n\n        if (data_reg == 3) {\n\n            if (data_reg2 == 4) {\n\n                tcg_out_mov (s, TCG_TYPE_I32, 0, 4);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 4, 3);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 3, 0);\n\n            }\n\n            else {\n\n                tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 3, 4);\n\n            }\n\n        }\n\n        else {\n\n            if (data_reg != 4) tcg_out_mov (s, TCG_TYPE_I32, data_reg, 4);\n\n            if (data_reg2 != 3) tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3);\n\n        }\n\n        break;\n\n    }\n\n    /* Jump to the code corresponding to next IR of qemu_st */\n\n    tcg_out_b (s, 0, (tcg_target_long) raddr);\n\n}\n", "idx": 5672, "substitutes": {"s": ["t", "os", "S", "p", "ds", "south", "is", "a", "l", "r", "ps", "ins", "scope", "sm", "z", "lang", "w", "less", "set", "ss", "self", "h", "in", "source", "ns", "space", "js", "b", "ssl", "sq", "an", "g", "scl", "sg", "sts", "rs", "gs", "y", "ts", "es", "e", "sym", "m", "simple", "fs", "its", "sv", "cs", "session", "ims", "x", "sb", "c", "as", "ls", "n", "sys", "out", "sw"], "label": ["Label", "util", "mark", "el", "button", "binary", "l", "ind", "data", "list", "field", "prefix", "call", "LAB", "abel", "sl", "loc", "ox", "val", "address", "style", "leader", "layout", "alias", "ell", "node", "module", "align", "span", "link", "cell", "group", "b", "state", "index", "name", "il", "info", "role", "comment", "bl", "LI", "range", "type", "target", "status", "process", "line", "local", "summary", "desc", "route", "loader", "block", "message", "tab", "lab", "value", "lib"], "s_bits": ["s__properties", "t_its", "s_bit", "t__pins", "s_properties", "t_flags", "s__pins", " s_its", "t__its", "s__its", "t_bits", "s__bytes", "s__bit", " s_flags", "s__bits", "t_pins", "s_flags", "s__flags", " s_bytes", "s_bytes", "t__flags", " s_properties", "s_its", "t__bits", "s_pins", " s_bit"], "ir": ["ptr", "pir", "dr", "init", "isc", "rc", " sr", "inter", "ih", "ier", "nil", "is", "id", "ibr", "r", "IR", "lr", "mi", "rr", "river", "arc", "ire", "iro", "war", "irs", "rir", "iso", "Ir", "vr", "sr", "adr", "nir", "rid", " shr", "ris", "i", "imp", "outer", "irc", "dir", "rint", "igr", "hr", "walker", "err", " intr", " IR", "pr", "ref", "ij", "ar", "iter", "iv", "world", "iri", "irt", "mir", "ni", "yr", "irm", "var", "iron", "ior", "rin", "virt", " wr", "vir", "ira", "mr"], "raddr": ["wptr", "maddr", "vtag", "rloc", " rptr", "vptr", " rref", "waddr", "wreg", "baddress", "mptr", "baddr", "mattr", "raddress", "mreg", " rreg", "mtag", " rattr", "rptr", "bloc", "rreg", "wloc", " rtag", "vattr", "waddress", " raddress", " rloc", "bptr", "rref", "rtag", "rattr", "vaddr", "mref", "wref"], "label_ptr": ["label_pos", " label_obj", "label__ptr", "label__addr", "label___addr", " label_addr", "lab_pointer", "label___pointer", "label_desc", "loc_addr", "label_pointer", "label_addr", "loc_ts", "label___desc", "label__pointer", "label_obj", "label_ts", "label__desc", " label_pointer", "loc_pos", "lab_addr", "lab_ptr", "label___ptr", "lab_desc", "loc_ptr"]}}
{"project": "qemu", "commit_id": "46321d6b5f8c880932a6b3d07bd0ff6f892e665c", "target": 0, "func": "static int nbd_negotiate_handle_info(NBDClient *client, uint32_t length,\n\n                                     uint32_t opt, uint16_t myflags,\n\n                                     Error **errp)\n\n{\n\n    int rc;\n\n    char name[NBD_MAX_NAME_SIZE + 1];\n\n    NBDExport *exp;\n\n    uint16_t requests;\n\n    uint16_t request;\n\n    uint32_t namelen;\n\n    bool sendname = false;\n\n    bool blocksize = false;\n\n    uint32_t sizes[3];\n\n    char buf[sizeof(uint64_t) + sizeof(uint16_t)];\n\n    const char *msg;\n\n\n\n    /* Client sends:\n\n        4 bytes: L, name length (can be 0)\n\n        L bytes: export name\n\n        2 bytes: N, number of requests (can be 0)\n\n        N * 2 bytes: N requests\n\n    */\n\n    if (length < sizeof(namelen) + sizeof(requests)) {\n\n        msg = \"overall request too short\";\n\n        goto invalid;\n\n    }\n\n    if (nbd_read(client->ioc, &namelen, sizeof(namelen), errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    be32_to_cpus(&namelen);\n\n    length -= sizeof(namelen);\n\n    if (namelen > length - sizeof(requests) || (length - namelen) % 2) {\n\n        msg = \"name length is incorrect\";\n\n        goto invalid;\n\n    }\n\n    if (nbd_read(client->ioc, name, namelen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    name[namelen] = '\\0';\n\n    length -= namelen;\n\n    trace_nbd_negotiate_handle_export_name_request(name);\n\n\n\n    if (nbd_read(client->ioc, &requests, sizeof(requests), errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    be16_to_cpus(&requests);\n\n    length -= sizeof(requests);\n\n    trace_nbd_negotiate_handle_info_requests(requests);\n\n    if (requests != length / sizeof(request)) {\n\n        msg = \"incorrect number of  requests for overall length\";\n\n        goto invalid;\n\n    }\n\n    while (requests--) {\n\n        if (nbd_read(client->ioc, &request, sizeof(request), errp) < 0) {\n\n            return -EIO;\n\n        }\n\n        be16_to_cpus(&request);\n\n        length -= sizeof(request);\n\n        trace_nbd_negotiate_handle_info_request(request,\n\n                                                nbd_info_lookup(request));\n\n        /* We care about NBD_INFO_NAME and NBD_INFO_BLOCK_SIZE;\n\n         * everything else is either a request we don't know or\n\n         * something we send regardless of request */\n\n        switch (request) {\n\n        case NBD_INFO_NAME:\n\n            sendname = true;\n\n            break;\n\n        case NBD_INFO_BLOCK_SIZE:\n\n            blocksize = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    exp = nbd_export_find(name);\n\n    if (!exp) {\n\n        return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_UNKNOWN,\n\n                                          opt, errp, \"export '%s' not present\",\n\n                                          name);\n\n    }\n\n\n\n    /* Don't bother sending NBD_INFO_NAME unless client requested it */\n\n    if (sendname) {\n\n        rc = nbd_negotiate_send_info(client, opt, NBD_INFO_NAME, length, name,\n\n                                     errp);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n    }\n\n\n\n    /* Send NBD_INFO_DESCRIPTION only if available, regardless of\n\n     * client request */\n\n    if (exp->description) {\n\n        size_t len = strlen(exp->description);\n\n\n\n        rc = nbd_negotiate_send_info(client, opt, NBD_INFO_DESCRIPTION,\n\n                                     len, exp->description, errp);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n    }\n\n\n\n    /* Send NBD_INFO_BLOCK_SIZE always, but tweak the minimum size\n\n     * according to whether the client requested it, and according to\n\n     * whether this is OPT_INFO or OPT_GO. */\n\n    /* minimum - 1 for back-compat, or 512 if client is new enough.\n\n     * TODO: consult blk_bs(blk)->bl.request_alignment? */\n\n    sizes[0] = (opt == NBD_OPT_INFO || blocksize) ? BDRV_SECTOR_SIZE : 1;\n\n    /* preferred - Hard-code to 4096 for now.\n\n     * TODO: is blk_bs(blk)->bl.opt_transfer appropriate? */\n\n    sizes[1] = 4096;\n\n    /* maximum - At most 32M, but smaller as appropriate. */\n\n    sizes[2] = MIN(blk_get_max_transfer(exp->blk), NBD_MAX_BUFFER_SIZE);\n\n    trace_nbd_negotiate_handle_info_block_size(sizes[0], sizes[1], sizes[2]);\n\n    cpu_to_be32s(&sizes[0]);\n\n    cpu_to_be32s(&sizes[1]);\n\n    cpu_to_be32s(&sizes[2]);\n\n    rc = nbd_negotiate_send_info(client, opt, NBD_INFO_BLOCK_SIZE,\n\n                                 sizeof(sizes), sizes, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* Send NBD_INFO_EXPORT always */\n\n    trace_nbd_negotiate_new_style_size_flags(exp->size,\n\n                                             exp->nbdflags | myflags);\n\n    stq_be_p(buf, exp->size);\n\n    stw_be_p(buf + 8, exp->nbdflags | myflags);\n\n    rc = nbd_negotiate_send_info(client, opt, NBD_INFO_EXPORT,\n\n                                 sizeof(buf), buf, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* If the client is just asking for NBD_OPT_INFO, but forgot to\n\n     * request block sizes, return an error.\n\n     * TODO: consult blk_bs(blk)->request_align, and only error if it\n\n     * is not 1? */\n\n    if (opt == NBD_OPT_INFO && !blocksize) {\n\n        return nbd_negotiate_send_rep_err(client->ioc,\n\n                                          NBD_REP_ERR_BLOCK_SIZE_REQD, opt,\n\n                                          errp,\n\n                                          \"request NBD_INFO_BLOCK_SIZE to \"\n\n                                          \"use this export\");\n\n    }\n\n\n\n    /* Final reply */\n\n    rc = nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, opt, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    if (opt == NBD_OPT_GO) {\n\n        client->exp = exp;\n\n        QTAILQ_INSERT_TAIL(&client->exp->clients, client, next);\n\n        nbd_export_get(client->exp);\n\n        rc = 1;\n\n    }\n\n    return rc;\n\n\n\n invalid:\n\n    if (nbd_drop(client->ioc, length, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_INVALID, opt,\n\n                                      errp, \"%s\", msg);\n\n}\n", "idx": 5673, "substitutes": {"client": ["view", "master", "util", "co", "sim", "Client", "config", "conn", "api", "plugin", "handler", "google", "channel", "component", "prefix", "call", "con", "connection", "force", "cl", "server", "control", "self", "php", "cell", "ip", "manager", "info", "connect", "http", "net", "command", "product", "admin", "code", "contact", "ci", "this", "service", "ce", "core", "window", "ct", "cli", "c", "context", "local", "web", "cache", "cmd", "public"], "length": ["ptr", "json", "capacity", "p", "oh", "ENGTH", "form", "family", "full", "half", "l", "volume", "ow", "data", "SIZE", "path", "position", "padding", "duration", "address", "transform", "performance", "offset", "h", "ength", "always", "build", "read", "depth", "time", "bus", "location", "size", "available", "history", "word", "vector", "result", "root", "trace", "amount", "maximum", "type", "operation", "buffer", "command", "len", "height", "health", "end", "obs", "code", "head", "loop", "all", "sequence", "number", "count", "phi", "ob", "message", "start", "total", "shape", "next", "value", "last", "Length", "be"], "opt": ["max", "optional", "use", "parent", "scope", "ext", "other", "option", "attr", "ip", "slot", "exclusive", "socket", "write", "timeout", "ts", "op", "unknown", "loop", "global", "accept", "session", "meta", "settings", "sys", "params", "cmd", "batch"], "myflags": ["myFlags", "keyflags", "getflags", "keyflag", "keyFlags", "myflag", "getFlags", " myflag", "mymask", " myFlags", "getmask", " mymask", "keymask", "getflag"], "errp": ["rrm", "ererpar", "errpar", " err", " errps", "errpass", "rrp", "warnp", "iterpp", " erpass", "warnpa", "errpa", "diepa", "arrm", "arrping", "iterps", " errping", "ererps", "warnpar", "ererpa", "erping", "erpass", "errpp", "ererp", "arrpp", " erping", " errpa", "errorps", "dieping", "errorp", "diep", "erpa", "warnps", "iterping", "iterm", " errr", "errping", " errpass", "dier", "erp", " erp", "rrping", "iterp", "rrpp", "errr", "errorping", "arrp", " errpar", "errm", "err", "errps"], "rc": [" rid", "RC", " ref", " ro", "xff", " src", " sock", " cur", " r", " proc", "cur", " cursor", " pri", " loc", " priv", " exc", " code", "rs", "row", "len", " ans", " row", " ok", " c", "oc", " sc", " clen", " rec"], "name": ["key", "init", "order", "named", "Name", "no", "ame", "resource", "id", "v", "news", "sp", "data", "r", "path", "file", "error", "parent", "prefix", "address", "w", "str", "alias", "o", "only", "package", "time", "nm", "size", "word", "attr", "mem", "index", "info", "an", "comment", "net", "type", "member", "new", "all", "part", "names", "window", "num", "x", "on", " NAME", " names", " Name", "message", "n", "local", "out", "NAME"], "requests": ["questencies", "quries", "recems", "twents", "reques", "redirements", " requirements", "recents", "pents", "waries", " requues", "questces", "responsests", "questines", "requesters", " reques", "sequces", "Requces", "receries", "requers", "keysines", "reqests", "wests", "reqers", "requencies", "Requests", "requeries", " requesters", "pests", "sequues", "acquines", "Requirements", "requems", "twems", "Requues", "sequesters", "tests", "redests", "wairements", "recers", "wues", "questirements", "Requessions", " requessions", "questests", " requries", "reqes", "Reques", "questesters", "tirements", "Requesters", "keysirements", "peries", "pems", "redements", "requements", "tweries", "questues", "questers", "requessions", "keysencies", "quirements", "keysests", "waests", "sequirements", "requines", "sequests", "reqesters", "acquencies", "wirements", "requents", " requements", "recesters", "requces", "reqirements", "questessions", "tries", "reces", "redries", "requries", "acquests", "Requers", "requues", "requirements", "waesters", "acquirements", "responsesters", "responsirements", "responsues", "quests", "westers", "recirements", "tements", "sequries", "twests", "recests"], "request": ["hello", "query", "reset", "task", "QUEST", "resource", "suggest", "argument", "question", "condition", "error", "call", "ask", "address", "connection", "server", "version", "consider", "req", "complete", "package", "attribute", "time", "result", "requ", "index", "est", "memory", "shift", "response", "type", "buffer", "command", "Request", "record", "quest", "pair", "try", "child", "test", "session", "header", "window", "reference", "import", "item", "queue", "push", "message", "reply", "create", "frame", "event"], "namelen": ["nameenen", "namelineon", "namemen", "namemar", "filelinen", "namelineen", "basellens", "naminelern", "nameliness", "basellown", "namalener", "namelinEN", "namellown", "namabelen", "namelinelen", "namellen", "nameselens", "namelem", "namlenen", "namellob", "naminelen", "namelooen", "lifabelet", "sanelren", "baseler", "namelinren", "nameelength", "namellens", "nomelen", "nameenener", "nameloess", "nameeleng", "nomellen", "nameenength", "namelinown", "nameleen", "nameken", "nomellade", "namabelaren", "nomellEN", "namellun", "namelinearen", "namelaren", "namelear", "namalength", "namelar", "namemlen", "namelessem", "nomelern", "namelon", "sanlenren", "sanetize", "sanlenoen", "namelinon", "namewen", "namelown", "namelz", "nametength", "namearun", "namelength", "nameloren", "namellength", "nameneng", "nameller", "namelest", "namekest", "namelistear", "namelize", "namabeler", "sanleness", "filelen", "nameselength", "nameleown", "namelineens", "namelinade", "baselen", "namelineEN", "sanelun", "filelinlen", "lifelem", "namelinlen", "lifelen", "nametize", "namellest", "sanetun", "namesteng", "namenener", "nomelade", "namesellob", "namlenren", "nametun", "namelun", "nomellern", "nameten", "lifabelen", "namesellen", "nomelllen", "namellar", "nomelens", "saneten", "nomelEN", "namellade", "baseller", "namellEN", "nameselen", "nomellest", "namelistlen", "namelessaren", "namabelem", "nameleng", "sanelength", "namemener", "namenameens", "namelade", "namelEN", "basellen", "nameless", "baselown", "namelessen", "sanetength", "namabelet", "filelinear", "sanelize", "nomellens", "namelener", "namelren", "namelineear", "namelinen", "filelon", "filellen", "namenameown", "saneless", "baselz", "namenength", "namelinob", "namewob", "sanelen", "lifelaren", "namelineet", "lifelet", "namelesset", "sanlenen", "namesellens", "namelinength", "namelern", "namelinar", "nomelar", "nameliston", "namelineade", "nomelest", "namelens", "namestength", "namearize", "namelob", "lifabelem", "nameler", "namelinz", "namelllen", "nomellener", "lifabelaren", "baselens", "namlenoen", "namelet", "nameelener", "nomelener", "namesten", "filelinon", "nameelen", "namelinoen", "namelineem", "namenameen", "filelear", "namenamez", "nameeneng", "nameloen", "saneloen", "namelinens", "namalen", "namearength", "namenen", "namewength", "namellener", "naminelest", "namabelown", "namelinear", "namewens", "namekern", "namelisten", "namellern", "namelinener", "namellz", "namestener", "namleness", "basellz", "namaleng", "nomellar", "nameselob", "namesellength", "namellize", "nameleer", "namearen"], "sizes": ["diz", "sists", " siz", "gists", "dists", "sizers", "siz", " sists", "gizers", "dizers", "dizes", " sizers", "gizes", "giz"], "buf": ["cast", "data", "map", "cb", "Buffer", "str", "br", "buff", "mem", "b", "def", "cap", "ref", "buffer", "ba", "pool", "alloc", "raw", "window", "uf", "var", "seq", "desc", "block", "box", " buffer", "img"], "msg": ["ug", "out", "gm", "doc", "gz", "sim", "ch", "pkg", "tmp", "mag", "ms", "arg", "label", "eg", "q", "str", "j", "comm", "ge", "nm", "mem", "jump", "rg", "state", "comment", "g", "md", "sg", "mb", "mg", "alg", "gs", "mn", "status", "mess", "og", "bg", "m", "res", "cfg", " message", "mm", "Msg", "med", "broad", "message", "urg", "err", "cmd"]}}
{"project": "qemu", "commit_id": "28b70c9dbdce0d517ade9c04c7d7ae05c8b76d2f", "target": 0, "func": "static int scsi_req_stream_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    switch (buf[0]) {\n\n    /* stream commands */\n\n    case ERASE_12:\n\n    case ERASE_16:\n\n        cmd->xfer = 0;\n\n        break;\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case WRITE_6:\n\n        cmd->len = 6;\n\n        cmd->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16);\n\n        if (buf[1] & 0x01) { /* fixed */\n\n            cmd->xfer *= dev->blocksize;\n\n        }\n\n        break;\n\n    case READ_16:\n\n    case READ_REVERSE_16:\n\n    case VERIFY_16:\n\n    case WRITE_16:\n\n        cmd->len = 16;\n\n        cmd->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16);\n\n        if (buf[1] & 0x01) { /* fixed */\n\n            cmd->xfer *= dev->blocksize;\n\n        }\n\n        break;\n\n    case REWIND:\n\n    case LOAD_UNLOAD:\n\n        cmd->len = 6;\n\n        cmd->xfer = 0;\n\n        break;\n\n    case SPACE_16:\n\n        cmd->xfer = buf[13] | (buf[12] << 8);\n\n        break;\n\n    case READ_POSITION:\n\n        cmd->xfer = buf[8] | (buf[7] << 8);\n\n        break;\n\n    case FORMAT_UNIT:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    /* generic commands */\n\n    default:\n\n        return scsi_req_length(cmd, dev, buf);\n\n    }\n\n    return 0;\n\n}\n", "idx": 5676, "substitutes": {"cmd": ["init", "query", "cp", "conf", "host", "pkg", "form", "Cmd", "conn", "config", "controller", "ctr", "mk", "news", "cat", "att", "nt", "cont", "ctx", "cor", "msg", "call", "cd", "send", "txt", "ext", "crit", "hold", "req", "control", "kt", "kind", "comm", "ann", "resp", "def", "wd", "bind", "comp", "act", "md", "opt", "text", "command", "rest", "cmp", "op", "find", "cfg", "content", "det", "exec", "raw", "help", "quit", "job", "addr", "utils", "ct", "desc", "and", "auth", "nd", "cli", "kick", "cod", "del", "quick", "add", "urg", "dep", "batch"], "dev": ["doc", "conn", "priv", "debug", "v", "nt", "Device", "ctx", "Dev", "devices", "dd", "serv", "w", "server", "pro", " Dev", "adv", "ve", "device", "driver", "mem", "proc", "def", "DEV", "wd", "ver", "md", "serial", "develop", "cam", "db", "det", "home", "addr", "hw", "window", "var", "env", "des", "rend", "go", "ev", "dep", "event", "dem"], "buf": ["deg", "bn", "pkg", "bed", "arr", "msg", "txt", "Buff", "text", "db", "vec", "etc", "bp", "uf", "queue", "box", "uv", "pack", "ctx", "w", "aka", "buff", "proc", "b", "blocks", "pb", "agg", "ref", "buffer", "len", "raw", "args", "seq", "block", "grad", "tab", "bh", "fam", "func", "aw", "fb", "cb", "Buffer", "ext", "packed", "br", "pad", "nm", "bs", "off", "cap", "conv", "var", "aux", "go", "bag", "img", "doc", "cv", "tmp", "v", "cat", "bar", "val", "prop", "ff", "comm", "bytes", "orig", "act", "cfg", "window", "desc", "bin", "cache", "rb", "err", "bc", "wb", "batch"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_tst_cc (DisasContext *dc, TCGv cc, int cond)\n\n{\n\n\tint arith_opt, move_opt;\n\n\n\n\t/* TODO: optimize more condition codes.  */\n\n\n\n\t/*\n\n\t * If the flags are live, we've gotta look into the bits of CCS.\n\n\t * Otherwise, if we just did an arithmetic operation we try to\n\n\t * evaluate the condition code faster.\n\n\t *\n\n\t * When this function is done, T0 should be non-zero if the condition\n\n\t * code is true.\n\n\t */\n\n\tarith_opt = arith_cc(dc) && !dc->flags_uptodate;\n\n\tmove_opt = (dc->cc_op == CC_OP_MOVE) && dc->flags_uptodate;\n\n\tswitch (cond) {\n\n\t\tcase CC_EQ:\n\n\t\t\tif (arith_opt || move_opt) {\n\n\t\t\t\t/* If cc_result is zero, T0 should be \n\n\t\t\t\t   non-zero otherwise T0 should be zero.  */\n\n\t\t\t\tint l1;\n\n\t\t\t\tl1 = gen_new_label();\n\n\t\t\t\ttcg_gen_movi_tl(cc, 0);\n\n\t\t\t\ttcg_gen_brcondi_tl(TCG_COND_NE, cc_result, \n\n\t\t\t\t\t\t   0, l1);\n\n\t\t\t\ttcg_gen_movi_tl(cc, 1);\n\n\t\t\t\tgen_set_label(l1);\n\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_andi_tl(cc, \n\n\t\t\t\t\t\tcpu_PR[PR_CCS], Z_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_NE:\n\n\t\t\tif (arith_opt || move_opt)\n\n\t\t\t\ttcg_gen_mov_tl(cc, cc_result);\n\n\t\t\telse {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tZ_FLAG);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, Z_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_CS:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], C_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_CC:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS], C_FLAG);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, C_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_VS:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], V_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_VC:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\tV_FLAG);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, V_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_PL:\n\n\t\t\tif (arith_opt || move_opt) {\n\n\t\t\t\tint bits = 31;\n\n\n\n\t\t\t\tif (dc->cc_size == 1)\n\n\t\t\t\t\tbits = 7;\n\n\t\t\t\telse if (dc->cc_size == 2)\n\n\t\t\t\t\tbits = 15;\t\n\n\n\n\t\t\t\ttcg_gen_shri_tl(cc, cc_result, bits);\n\n\t\t\t\ttcg_gen_xori_tl(cc, cc, 1);\n\n\t\t\t} else {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tN_FLAG);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, N_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_MI:\n\n\t\t\tif (arith_opt || move_opt) {\n\n\t\t\t\tint bits = 31;\n\n\n\n\t\t\t\tif (dc->cc_size == 1)\n\n\t\t\t\t\tbits = 7;\n\n\t\t\t\telse if (dc->cc_size == 2)\n\n\t\t\t\t\tbits = 15;\t\n\n\n\n\t\t\t\ttcg_gen_shri_tl(cc, cc_result, 31);\n\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tN_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_LS:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\tC_FLAG | Z_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_HI:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv tmp;\n\n\n\n\t\t\t\ttmp = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\ttcg_gen_xori_tl(tmp, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tC_FLAG | Z_FLAG);\n\n\t\t\t\t/* Overlay the C flag on top of the Z.  */\n\n\t\t\t\ttcg_gen_shli_tl(cc, tmp, 2);\n\n\t\t\t\ttcg_gen_and_tl(cc, tmp, cc);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, Z_FLAG);\n\n\n\n\t\t\t\ttcg_temp_free(tmp);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_GE:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t/* Overlay the V flag on top of the N.  */\n\n\t\t\ttcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2);\n\n\t\t\ttcg_gen_xor_tl(cc,\n\n\t\t\t\t       cpu_PR[PR_CCS], cc);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, N_FLAG);\n\n\t\t\ttcg_gen_xori_tl(cc, cc, N_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_LT:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t/* Overlay the V flag on top of the N.  */\n\n\t\t\ttcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2);\n\n\t\t\ttcg_gen_xor_tl(cc,\n\n\t\t\t\t       cpu_PR[PR_CCS], cc);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, N_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_GT:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv n, z;\n\n\n\n\t\t\t\tn = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\tz = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n\t\t\t\t/* To avoid a shift we overlay everything on\n\n\t\t\t\t   the V flag.  */\n\n\t\t\t\ttcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);\n\n\t\t\t\ttcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);\n\n\t\t\t\t/* invert Z.  */\n\n\t\t\t\ttcg_gen_xori_tl(z, z, 2);\n\n\n\n\t\t\t\ttcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);\n\n\t\t\t\ttcg_gen_xori_tl(n, n, 2);\n\n\t\t\t\ttcg_gen_and_tl(cc, z, n);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, 2);\n\n\n\n\t\t\t\ttcg_temp_free(n);\n\n\t\t\t\ttcg_temp_free(z);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_LE:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv n, z;\n\n\n\n\t\t\t\tn = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\tz = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n\t\t\t\t/* To avoid a shift we overlay everything on\n\n\t\t\t\t   the V flag.  */\n\n\t\t\t\ttcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);\n\n\t\t\t\ttcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);\n\n\n\n\t\t\t\ttcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);\n\n\t\t\t\ttcg_gen_or_tl(cc, z, n);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, 2);\n\n\n\n\t\t\t\ttcg_temp_free(n);\n\n\t\t\t\ttcg_temp_free(z);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_P:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], P_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_A:\n\n\t\t\ttcg_gen_movi_tl(cc, 1);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tBUG();\n\n\t\t\tbreak;\n\n\t};\n\n}\n", "idx": 5694, "substitutes": {"dc": ["tc", "mc", "rc", "dr", "sc", "cm", "cp", "cu", "co", "doc", "dt", "cci", "dm", "ds", "d", "vc", "cat", "iac", "func", "ec", "lc", "ctx", "cca", "pc", "dd", "cd", "wp", "ga", "kt", "dk", "di", "dl", "gc", "dat", "fc", "mac", "da", "du", "dp", "cf", "rec", "ci", "document", "coord", "mm", "disc", "DC", "cs", "desc", "c", "cmd", "kw", "sys", "ctl", "nc", "bc", "mic"], "cc": ["tc", "mc", "rc", "sc", "pp", "isc", "cu", " gcc", "co", "jac", "cp", "cong", "cci", "cv", "ll", "vc", "kk", "jj", "ucc", "func", "ec", "lc", "cont", "cca", "ctx", "pc", "ic", "dd", "craft", "tch", "cl", "ff", "CC", "php", "gc", "cn", "ship", "fc", "soc", "cell", " mc", "bb", "ssl", "zz", "inc", "acc", " ac", "ck", "cmp", "cf", "code", "cy", "addr", "ce", "cs", " c", "ct", "ac", "xx", "c", "cz", "cmd", " rc", "ctl", "nc", "bc", " bc", " ecc"], "cond": ["bo", "conf", "sec", "ind", " Cond", "pred", "cont", "wait", "condition", "dd", "check", "con", "respond", "red", "crit", "hold", "req", "lock", "chain", "when", "resp", "ond", "bind", "comp", "given", "wind", "command", "status", "cmp", "Cond", "bit", "flag", "bool", "ct", "cod", "pos", "Condition", "cmd"], "arith_opt": ["arith_opted", "arith____oss", "arich_pot", "arthur_oss", "arithlyop", "arith____opt", "arith_loss", "arich_opt", "arthur_Opt", "arich___optim", "arich___op", "arith___opted", "arich___pot", "arith_Opt", "arithlypot", "arith_obj", "arth_loss", "arthur____opt", "arich___opt", "arith_pot", "arith___pot", "arth_op", "arthur_opt", "arth_opted", "arith___obj", "arthur____Opt", "arth_opt", "arith___optim", "arith_optim", "arith_op", "arthur_op", "arich_optim", "arithlyopt", "arith____op", "arich_op", "arith___op", "arith___opt", "arth_obj", "arthur____op", "arith_oss", "arith____Opt", "arthur____oss", "arithlyoptim"], "move_opt": ["movelyoptim", "movinglyopt", "moveingop", "moving_opt", "movinglyto", "fire_pred", "movelyop", "remove_lit", "fire_op", "moveingpred", "movinglyop", "remove_optim", " move_op", "move_lit", "moving_to", "move_op", "fireingop", "fire_opt", "move_tr", "move_to", "fireingoptim", "fireingpred", "moveingopt", "moving_lit", "move_pred", "move_optim", "remove_op", "fireingopt", "moveingoptim", "remove_opt", "movelyopt", "moving_op", "movelyto", "move_crit", "fire_optim", " move_crit", "movelylit", " move_tr", "movinglylit"], "l1": ["lup", " lup", "lmb", "L1", "li3", " l2", " l001", " lng", "sl1", "sl2", "l2", "lng", "limb", "slup", "l3", " l0", "li0", "liup", "lc0", "lc2", "l0", "L0", " lmb", "l001", "lc001", " l3", "ling", "li2", "lc1", "Lmb", "L2", "Lng", "L001", "li1", "sl3"]}}
{"project": "qemu", "commit_id": "b4854f1384176d897747de236f426d020668fa3c", "target": 0, "func": "void do_smm_enter(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    CPUState *cs = CPU(cpu);\n\n    target_ulong sm_state;\n\n    SegmentCache *dt;\n\n    int i, offset;\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"SMM: enter\\n\");\n\n    log_cpu_state_mask(CPU_LOG_INT, CPU(cpu), CPU_DUMP_CCOP);\n\n\n\n    env->hflags |= HF_SMM_MASK;\n\n    if (env->hflags2 & HF2_NMI_MASK) {\n\n        env->hflags2 |= HF2_SMM_INSIDE_NMI_MASK;\n\n    } else {\n\n        env->hflags2 |= HF2_NMI_MASK;\n\n    }\n\n    cpu_smm_update(env);\n\n\n\n    sm_state = env->smbase + 0x8000;\n\n\n\n#ifdef TARGET_X86_64\n\n    for (i = 0; i < 6; i++) {\n\n        dt = &env->segs[i];\n\n        offset = 0x7e00 + i * 16;\n\n        x86_stw_phys(cs, sm_state + offset, dt->selector);\n\n        x86_stw_phys(cs, sm_state + offset + 2, (dt->flags >> 8) & 0xf0ff);\n\n        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);\n\n        x86_stq_phys(cs, sm_state + offset + 8, dt->base);\n\n    }\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e64, env->gdt.limit);\n\n\n\n    x86_stw_phys(cs, sm_state + 0x7e70, env->ldt.selector);\n\n    x86_stq_phys(cs, sm_state + 0x7e78, env->ldt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e74, env->ldt.limit);\n\n    x86_stw_phys(cs, sm_state + 0x7e72, (env->ldt.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7e88, env->idt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e84, env->idt.limit);\n\n\n\n    x86_stw_phys(cs, sm_state + 0x7e90, env->tr.selector);\n\n    x86_stq_phys(cs, sm_state + 0x7e98, env->tr.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e94, env->tr.limit);\n\n    x86_stw_phys(cs, sm_state + 0x7e92, (env->tr.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7ed0, env->efer);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7ff8, env->regs[R_EAX]);\n\n    x86_stq_phys(cs, sm_state + 0x7ff0, env->regs[R_ECX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fe8, env->regs[R_EDX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fe0, env->regs[R_EBX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fd8, env->regs[R_ESP]);\n\n    x86_stq_phys(cs, sm_state + 0x7fd0, env->regs[R_EBP]);\n\n    x86_stq_phys(cs, sm_state + 0x7fc8, env->regs[R_ESI]);\n\n    x86_stq_phys(cs, sm_state + 0x7fc0, env->regs[R_EDI]);\n\n    for (i = 8; i < 16; i++) {\n\n        x86_stq_phys(cs, sm_state + 0x7ff8 - i * 8, env->regs[i]);\n\n    }\n\n    x86_stq_phys(cs, sm_state + 0x7f78, env->eip);\n\n    x86_stl_phys(cs, sm_state + 0x7f70, cpu_compute_eflags(env));\n\n    x86_stl_phys(cs, sm_state + 0x7f68, env->dr[6]);\n\n    x86_stl_phys(cs, sm_state + 0x7f60, env->dr[7]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f48, env->cr[4]);\n\n    x86_stq_phys(cs, sm_state + 0x7f50, env->cr[3]);\n\n    x86_stl_phys(cs, sm_state + 0x7f58, env->cr[0]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);\n\n    x86_stl_phys(cs, sm_state + 0x7f00, env->smbase);\n\n#else\n\n    x86_stl_phys(cs, sm_state + 0x7ffc, env->cr[0]);\n\n    x86_stl_phys(cs, sm_state + 0x7ff8, env->cr[3]);\n\n    x86_stl_phys(cs, sm_state + 0x7ff4, cpu_compute_eflags(env));\n\n    x86_stl_phys(cs, sm_state + 0x7ff0, env->eip);\n\n    x86_stl_phys(cs, sm_state + 0x7fec, env->regs[R_EDI]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe8, env->regs[R_ESI]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe4, env->regs[R_EBP]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe0, env->regs[R_ESP]);\n\n    x86_stl_phys(cs, sm_state + 0x7fdc, env->regs[R_EBX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd8, env->regs[R_EDX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd4, env->regs[R_ECX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd0, env->regs[R_EAX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fcc, env->dr[6]);\n\n    x86_stl_phys(cs, sm_state + 0x7fc8, env->dr[7]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7fc4, env->tr.selector);\n\n    x86_stl_phys(cs, sm_state + 0x7f64, env->tr.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f60, env->tr.limit);\n\n    x86_stl_phys(cs, sm_state + 0x7f5c, (env->tr.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7fc0, env->ldt.selector);\n\n    x86_stl_phys(cs, sm_state + 0x7f80, env->ldt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f7c, env->ldt.limit);\n\n    x86_stl_phys(cs, sm_state + 0x7f78, (env->ldt.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f74, env->gdt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f70, env->gdt.limit);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f58, env->idt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f54, env->idt.limit);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        dt = &env->segs[i];\n\n        if (i < 3) {\n\n            offset = 0x7f84 + i * 12;\n\n        } else {\n\n            offset = 0x7f2c + (i - 3) * 12;\n\n        }\n\n        x86_stl_phys(cs, sm_state + 0x7fa8 + i * 4, dt->selector);\n\n        x86_stl_phys(cs, sm_state + offset + 8, dt->base);\n\n        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);\n\n        x86_stl_phys(cs, sm_state + offset, (dt->flags >> 8) & 0xf0ff);\n\n    }\n\n    x86_stl_phys(cs, sm_state + 0x7f14, env->cr[4]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);\n\n    x86_stl_phys(cs, sm_state + 0x7ef8, env->smbase);\n\n#endif\n\n    /* init SMM cpu state */\n\n\n\n#ifdef TARGET_X86_64\n\n    cpu_load_efer(env, 0);\n\n#endif\n\n    cpu_load_eflags(env, 0, ~(CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C |\n\n                              DF_MASK));\n\n    env->eip = 0x00008000;\n\n    cpu_x86_update_cr0(env,\n\n                       env->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK |\n\n                                      CR0_PG_MASK));\n\n    cpu_x86_update_cr4(env, 0);\n\n    env->dr[7] = 0x00000400;\n\n\n\n    cpu_x86_load_seg_cache(env, R_CS, (env->smbase >> 4) & 0xffff, env->smbase,\n\n                           0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_SS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n}\n", "idx": 5707, "substitutes": {"cpu": ["cu", "cp", "p", "ork", "task", "apache", "rpm", "frame", "aco", "conn", "processor", "ctx", "mu", "pc", "hz", "linux", "prof", "gpu", "phy", "pty", "uu", "bench", "gc", "hog", "mem", "proc", "np", "clock", "mac", "mx", "arch", "CPU", "xi", "tp", "process", "vm", "ck", "jp", "pool", "bit", "pu", "core", "hw", "cum", "c", "hap", "nic", "ola", "nc", "cmd"], "env": ["et", "kh", "conn", "skin", "self", "gc", "dn", "dh", "forge", "ah", "response", "vm", "db", "esp", "operator", "er", "nc", "viron", "cmd", "eps", "uv", "eas", "sc", "ei", "equ", "query", "gear", "dev", "environment", "el", "origin", "vs", "ctx", "worker", "inv", "scope", "serv", "obj", "ew", "en", "ve", "eng", "esm", "eur", "proc", "ner", "enc", "kernel", "ent", "context", "shell", "web", "eu", "esc", "org", "func", "cb", "ext", "nv", "era", "here", " environment", "uint", "gn", "manager", "eni", "e", "end", "iv", "head", "engine", "exec", "ov", "Environment", "qt", "ef", "_", "eh", "oe", "vt", "ev", "init", "vp", "cv", "v", "ec", "vv", "server", "eve", "ee", "gen", "NV", "buf", "console", "erd", "der", "addr", "hw", "window", "next", "sw"], "cs": ["tc", "icks", "sc", "rc", "cm", "cp", "ch", "ds", "cv", "ces", "acts", "css", "cus", "vc", "ctr", "ras", "ec", "vs", "ctx", "ps", "pc", "ics", "ks", "els", "cc", "ss", "cons", "CS", "ys", "cn", "gc", "ths", "bs", "ns", "js", "hs", "sq", "sts", "rs", "gs", "ts", "cf", "cks", "ck", "checks", "ads", "acs", "ce", "ct", "ims", "sb", "c", "wcs", "ls", "s", "cas", "ats", "aps", "sys", "qs", "nc", "yes"], "sm_state": [" sm_store", "model_state", "sm2config", "shellammustart", "esm_status", "sm_start", " sm_State", "shellammucache", "smtstate", "sm0remote", "sm_stat", "model_states", "smammucache", "orea7stat", "sm_post", "esm_role", "sta_store", "stamtrole", " sm2State", "sm_see", "sm8state", "sm_resource", "inv_remote", "smxstatus", "sm_config", "sm2stat", "perm_powered", " sm_resource", "orea_remote", "sm_powered", " sm_se", "smmtrole", " sm_tag", "sm_store", "sm2post", "smgrconfig", "stamtstate", "sm2State", "smmttag", "sm0role", "sm_se", "sta_post", "sm7state", "sm___stat", "esm_store", " sm_STATE", "sm_State", "inv_state", "sm0store", "model_config", "sm___state", "sm2store", "sm_role", " sm2start", "inv_status", "sm2states", "shell_powered", "smgrstates", " sm_status", "inv0state", "sm____state", "sta_state", "modelgrstate", "sm_status", "shellammustate", "smammustate", "sm_part", "smmtstate", "sm____role", "smgrstate", "sm8monitor", "orea7state", "inv0remote", "smxpowered", "orea_stat", "smxstore", "smmtstore", "inv0monitor", " sm_role", "inv_monitor", "smxstate", "inv0status", "smtstat", "sm7see", "sm_remote", "sm___remote", "sta_role", "stamtpost", "smammustart", "sm____store", "smgrstat", "shell_cache", "sm7remote", "sm_cache", "sm0monitor", "sm7part", "shellammupowered", "smammupowered", "perm_part", "sm2start", "sm_STATE", "sm2resource", "smmtSTATE", "smmtpost", "modelgrstates", "stamtstore", "shell_start", "smtremote", "sm_monitor", " sm_start", "sm_states", "modelgrstat", "sm2role", "esm_state", "sm7powered", " sm_powered", " sm_size", "sm7stat", "perm_state", "shell_state", "orea_state", "orea7remote", " sm2state", "sm8status", "sm0status", "sm8remote", "sm0state", "modelgrconfig", "sm____post", " sm2resource", "sm_size", "sm_tag", "perm_see", "model_stat", "sm2state"], "dt": ["tc", "tif", "hd", "t", "dj", "et", "elt", "gt", "td", "dm", "ds", "tt", "bt", "lp", "d", "ctx", "fd", "dd", "tz", "dc", "typ", "txt", "kt", "dq", "di", "dl", "cn", "dat", "dh", "ect", "dn", "mt", "pb", "tp", "ts", "dp", "db", "iat", "ct", "ta", "tm", "qt", "tk", "rt", "ctl", "DT", "kat", "tn"], "i": [" I", "t", "li", "p", "sim", "bi", "is", "a", "id", "ii", "v", "ini", "mi", "ix", " bi", "me", "it", "ic", "gu", "asi", "hi", "si", "oi", "di", "j", "o", "gi", "span", "ri", "in", "ji", "ip", "index", "ui", "multi", "iu", "xi", "y", "ij", "zi", "status", "e", "ci", "ti", "m", "ami", "ai", "pi", " j", "ims", "x", "I", "phi", "qi", "c", "cli", "n", " ii", "batch"], "offset": ["key", "entry", "extra", "adjusted", "order", "reset", "origin", "id", "ix", "ut", "position", "append", "prefix", "error", "padding", "address", "option", "options", "set", "style", "alias", "iso", "o", "pad", "align", "output", "attribute", "location", "size", "attr", "ip", "off", "outer", "pointer", "sector", "index", "slot", "shift", "point", "slice", "ui", "trace", "scroll", "seed", "ref", "buffer", "term", "fp", "ot", "remote", "timeout", "end", "info", "addr", "base", "tile", "reference", "Offset", "associated", "item", "queue", "encrypted", "pos", "start", "batch", "seek"]}}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,\n\n                        const char *default_devaddr)\n\n{\n\n    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;\n\n    PCIDevice *pci_dev;\n\n    DeviceState *dev;\n\n    int i;\n\n\n\n    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);\n\n    pci_dev = pci_create(pci_nic_names[i], devaddr);\n\n    dev = &pci_dev->qdev;\n\n    if (nd->id)\n\n        dev->id = qemu_strdup(nd->id);\n\n    dev->nd = nd;\n\n    qdev_init(dev);\n\n    nd->private = dev;\n\n    return pci_dev;\n\n}\n", "idx": 5718, "substitutes": {"nd": ["ng", "hd", "ant", "fn", "td", "nil", "ln", "od", "d", "ind", "news", "nn", "nt", "ctx", "fd", "nih", "dd", "inn", "nor", "cd", "inst", "ld", "nv", "dk", "ne", "dl", "dn", "nda", "sd", "ND", "ns", "wn", "dat", "np", "gn", "ond", "md", "mn", "std", "und", "vd", "wind", "rest", "ord", "rn", "pd", "nw", "ck", "sn", "rd", "ined", "ent", "them", "nl", "n", "rt", "nb", "nc", "hn"], "default_model": ["default_mode", "default___model", "FAULT_link", "default_models", "FAULT_model", "default_Model", "FAULT_device", "FAULT_mode", "Default_models", "Default_mode", "Default_Model", "Default_model", "default_link", "FAULT___link", "FAULT___model", "default_device", "FAULT___mode", "FAULT___device", "default___mode", "default___link", "default___device"], "default_devaddr": ["default_evname", "default_Devaddr", "default_evaddress", "default_deviceaddr", "default_evaddr", "default_Devaddress", "default_deviceattr", "default_privname", "default_privaddress", "default_Devattr", "default_Devname", "default_evattr", "default_devaddress", "default_devattr", "default_deviceaddress", "default_privaddr", "default_devname"], "devaddr": ["avaddress", "deviceaddress", "evadd", "Devadd", " devadd", "devref", "Devptr", " devref", "evaddress", " devadr", "avurl", "deviceadd", "deviceurl", "deviceptr", "avaddr", "deviceaddr", "evref", " devptr", "avadr", "devaddress", "Devaddr", " devurl", "deviceadr", "deviceref", " devaddress", "evaddr", "devadd", "devadr", "devurl", "devptr", "Devaddress"], "pci_dev": ["pcu_device", "pci_Dev", "pci_ev", "pci_device", "pci_conn", "pico_device", "pci___dev", "pcu_def", "pcu_conn", "ppi_div", "pci___Dev", "pico_dev", "pci___conn", "pcu_dev", "pcu_Dev", "ppi_dev", "pico_nt", "ppi_pad", "pci_nt", "pci_def", "pci___def", "pico_ev", "pci_pad", "ppi_ev", "pci_div", "pci___device"], "dev": ["p", "sum", "nt", "send", "watch", "di", "rem", "DEV", "wd", "ver", "md", "vd", "develop", "fo", "det", "unknown", "des", "cmd", "dj", "pack", "de", "data", "normal", "dd", "serv", "obj", "w", "h", "ve", "adv", "device", "dat", "sd", "mem", "def", "err", "comment", "new", "raw", "ent", "push", "den", "priv", "debug", "d", "ind", "ow", "Dev", "gu", "die", "ov", "var", "del", "add", "go", "ev", "out", "disk", "cast", "cho", "v", "stable", "val", "info", "vo", "res", "tr", "test", "hw", "desc", "env", "av", "sw"], "i": [" m", " I", "t", "li", "p", "bi", "is", "f", "id", "ind", "v", "ii", "ini", "mi", "ix", " bi", " n", "it", "\u0438", " x", "si", "k", "oi", "di", "j", "gi", "index", " v", "multi", "xi", "y", "ij", "zi", " ti", "ci", "ti", "m", "ami", "iy", "ai", "pi", " j", "x", "I", "phi", "qi", "s", "n", " ii"]}}
{"project": "FFmpeg", "commit_id": "d2ee495fb241fa4ef5b8b56161328c4379d1c79a", "target": 1, "func": "void ff_mlp_init_x86(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n#if HAVE_7REGS && HAVE_TEN_OPERANDS\n\n    c->mlp_filter_channel = mlp_filter_channel_x86;\n\n#endif\n\n}\n", "idx": 5731, "substitutes": {"c": ["tc", "sc", "t", "cm", "p", "ch", "config", "f", "a", "d", "vc", "v", "ec", "lc", "ctx", "pc", "dc", "C", "cd", "con", "cc", "h", "o", "fc", "b", "g", "uc", "cf", "e", "ci", "m", "ca", "xc", "cs", "ac", "bc", "mc"], "avctx": [" avcontext", "ovcontext", "avcontext", "Avcontext", "Avconn", " avconn", "Avctx", "avcmp", "ovconn", "ovcmp", "Avcmp", " avcmp", "avconn", "ovctx"]}}
{"project": "FFmpeg", "commit_id": "295b79b5d8c0cf0a9691f8d6b512aa1e289d528d", "target": 1, "func": "static av_cold int roq_encode_init(AVCodecContext *avctx)\n{\n    RoqContext *enc = avctx->priv_data;\n    av_lfg_init(&enc->randctx, 1);\n    enc->framesSinceKeyframe = 0;\n    if ((avctx->width & 0xf) || (avctx->height & 0xf)) {\n        av_log(avctx, AV_LOG_ERROR, \"Dimensions must be divisible by 16\\n\");\n        return AVERROR(EINVAL);\n    if (avctx->width > 65535 || avctx->height > 65535) {\n        av_log(avctx, AV_LOG_ERROR, \"Dimensions are max %d\\n\", enc->quake3_compat ? 32768 : 65535);\n        return AVERROR(EINVAL);\n    if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1)))\n        av_log(avctx, AV_LOG_ERROR, \"Warning: dimensions not power of two, this is not supported by quake\\n\");\n    enc->width = avctx->width;\n    enc->height = avctx->height;\n    enc->framesSinceKeyframe = 0;\n    enc->first_frame = 1;\n    enc->last_frame    = av_frame_alloc();\n    enc->current_frame = av_frame_alloc();\n    if (!enc->last_frame || !enc->current_frame) {\n    enc->tmpData      = av_malloc(sizeof(RoqTempdata));\n    enc->this_motion4 =\n        av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect));\n    enc->last_motion4 =\n        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));\n    enc->this_motion8 =\n        av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect));\n    enc->last_motion8 =\n        av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect));\n    return 0;", "idx": 5754, "substitutes": {"avctx": [" avcontext", "ajpx", "ajpkg", "wavctx", "ajdl", "avedl", "varkt", "avrt", "avert", "abctx", "avcmd", "wavca", "abcu", "avaddr", " avcb", "ravctx", "avgc", "avectx", "avepool", "ravcrit", "avco", "avpx", "avercrit", "avepy", "averco", "averpt", "wavcmd", "avekl", "navca", "avecu", "averrt", "avercu", "averkl", "ajgc", "averca", "vactx", "abcontext", "ajcmd", "Avtx", "vacu", "avecb", "varcmd", "avcu", "varctx", "vardl", "navctx", "wavcp", "avconfig", "wavjac", "aveaddr", "abtx", "avetx", " avkt", "avergc", "aveconfig", "vacheck", " avtx", "avcrit", "avcheck", " avcheck", "navaddr", "averjac", "avcp", "navpt", "Avcb", "ravcu", "avpool", "avpkg", "apctx", "ajrt", "navcp", "avcontext", "ajconfig", "averctx", "wavaddr", "aveca", "avekt", "avecheck", "Avctx", "ajctx", "avercmd", "navcmd", "avkt", "averpy", "avept", "aveco", "ajpt", "avjac", "ajco", "navkl", "abcp", "avecp", "ajkt", "varpool", "appt", "navpkg", "avca", "wavkt", "varpx", "averconfig", "ajcontext", "ravtx", "avcb", " avcu", "avecontext", "apaddr", " avcp", "avepkg", "avpt", "wavkl", "avertx", "ajaddr", "wavpy", " avpkg", "wavcu", "abcrit", "avkl", "navpx", "avejac", "vatx", "avercp", "appkg", "ajpool", "avpy", "avecmd", "avtx", "abkt", "Avcontext", "abpkg", "ajcp", "varca", "avdl", "avegc", "ajca"], "enc": ["util", "et", "bn", "conn", "iac", "nt", "ang", "pc", "ens", "iq", "Enc", "vec", "etc", "c", "kw", "oc", "encrypted", "nc", "equ", "pack", "enth", "ctx", "eric", "eg", "ic", "con", "obj", "ew", "en", "En", "kt", "ell", "eng", "buff", "proc", "exc", "pres", "inc", "utt", "rent", "acl", "disc", "ent", "ENT", "num", "auth", "ENC", "nec", "ack", "ict", "rc", "config", "sec", "orc", "eval", "oder", "lang", "fc", "acc", "rec", "iv", "conv", "ct", "lib", "unc", "cv", "mont", "ec", "col", "auc", "coll", "abc", "chest", "anc", "act", "buf", "alg", "xc", "ENG", "ac", "desc", "env", "cod"]}}
{"project": "FFmpeg", "commit_id": "fd1588919d2c70288a1a3fea1aefdd3ea2c424bb", "target": 1, "func": "void ff_h264_flush_change(H264Context *h)\n\n{\n\n    int i, j;\n\n\n\n    h->next_outputed_poc = INT_MIN;\n\n    h->prev_interlaced_frame = 1;\n\n    idr(h);\n\n\n\n    h->poc.prev_frame_num = -1;\n\n    if (h->cur_pic_ptr) {\n\n        h->cur_pic_ptr->reference = 0;\n\n        for (j=i=0; h->delayed_pic[i]; i++)\n\n            if (h->delayed_pic[i] != h->cur_pic_ptr)\n\n                h->delayed_pic[j++] = h->delayed_pic[i];\n\n        h->delayed_pic[j] = NULL;\n\n    }\n\n    ff_h264_unref_picture(h, &h->last_pic_for_ec);\n\n\n\n    h->first_field = 0;\n\n    ff_h264_sei_uninit(&h->sei);\n\n    h->recovery_frame = -1;\n\n    h->frame_recovered = 0;\n\n    h->current_slice = 0;\n\n    h->mmco_reset = 1;\n\n    for (i = 0; i < h->nb_slice_ctx; i++)\n\n        h->slice_ctx[i].list_count = 0;\n\n}\n", "idx": 5755, "substitutes": {"h": ["pp", "kh", "p", "host", "ih", "ha", "it", "q", "hi", "self", "k", "handle", "dh", "ah", "y", "hal", "hp", "c", "hl", "ph", "dev", "ch", "H", "w", "rh", "he", "php", "ht", "mem", "b", "http", "has", "header", "x", "phi", "hm", "th", "bh", "temp", "hhh", "zh", "here", "ho", "hist", "sh", "gh", "m", "uh", "hh", "HH", "eh", "go", "hd", "html", "oh", "wh", "v", "hash", "hz", "comm", "history", "hs", "hr", "info", "g", "help", "base", "hw", "window", "cache"], "i": ["p", "l", "ii", "ini", "it", "hi", "ish", "di", "uu", "gi", "ie", "y", "remote", "ci", "ami", "ni", "ims", "qi", "c", "cli", "n", "z", "mc", " ii", " I", "ei", "ski", "a", "MI", "ix", "ic", "si", "oi", "ji", "b", "index", "zi", "try", "pi", "x", "us", "is", "ind", "mi", "gu", "ri", "chain", "ip", "point", "multi", " ti", "ti", "m", "iy", "ai", "im", "I", "spin", "u", "li", "sim", "ki", "fi", "bi", "v", "me", "\u0438", "uri", "o", "in", "il", "info", "g", "ui", "iu", "ij", "xi", "wi", "status", "um"], "j": ["json", "fr", "dj", "li", "p", "jac", "fi", "bi", "f", "l", "jj", "v", "ind", "ii", "jl", "it", "q", "jc", "obj", "aj", "si", "k", "br", "o", "ji", "js", "jump", "b", "oj", "g", "at", "pr", "ij", "kj", "y", "jp", "uj", "m", "ja", "pi", "x", "J", "c", "s", "n", "z"]}}
{"project": "FFmpeg", "commit_id": "4dbcdfa86d1405f7e5c0ec14a4be7d2fb5903d7b", "target": 0, "func": "static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out)\n\n{\n\n    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);\n\n    void *dst;\n\n    if (o_out)\n\n        *o_out= o;\n\n    if (!o || o->offset<=0)\n\n        return AVERROR_OPTION_NOT_FOUND;\n\n\n\n    if (o->max*den < num*intnum || o->min*den > num*intnum) {\n\n        av_log(obj, AV_LOG_ERROR, \"Value %lf for parameter '%s' out of range\\n\", num, name);\n\n        return AVERROR(ERANGE);\n\n    }\n\n\n\n    dst= ((uint8_t*)obj) + o->offset;\n\n\n\n    switch (o->type) {\n\n    case FF_OPT_TYPE_FLAGS:\n\n    case FF_OPT_TYPE_INT:   *(int       *)dst= llrint(num/den)*intnum; break;\n\n    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= llrint(num/den)*intnum; break;\n\n    case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;\n\n    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;\n\n    case FF_OPT_TYPE_RATIONAL:\n\n        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};\n\n        else                 *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);\n\n        break;\n\n    default:\n\n        return AVERROR(EINVAL);\n\n    }\n\n    return 0;\n\n}\n", "idx": 5762, "substitutes": {"obj": ["bo", "fr", "t", "os", "phys", "co", "pkg", "bj", "tmp", "bh", "conn", "org", "arr", "nt", "ctx", "objects", "inst", "txt", "str", "ist", "self", "object", "j", "so", "vr", "attr", "nm", "js", "np", "err", "act", "onet", "ref", "opt", "img", "ot", "ij", "cmp", "xy", "rect", "iv", "hw", "window", "Obj", "expr", "src", "ob", "oid", "rt", "n", "pos", "rb", "out", "cmd"], "name": ["key", "p", "named", "Name", "no", "ame", "f", "a", "id", "data", "length", "spec", "label", "me", "path", "file", "error", "parent", "prefix", "w", "str", "val", "alias", "nam", "cn", "reason", "time", "nm", "attr", "word", "size", "nan", "def", "info", "cap", "type", "ma", "code", "m", "part", "names", "var", "title", "number", "n", "NAME"], "num": ["util", "conf", "p", "mark", "sum", "tim", "msg", "typ", "nam", "valid", "rem", "none", "Number", "net", "mn", "na", "coord", "cum", "final", "uf", "n", " number", "dev", "no", "dim", "draw", "nom", "mu", "mult", "note", "con", "en", "eng", "mat", "index", "Num", "zero", "non", "new", "ord", "un", "anon", "all", "on", " NUM", "vol", "block", "tu", "nb", "NUM", "th", "f", "gpu", "nm", "off", "np", "multi", "om", "perm", "end", "m", "missing", "number", "phys", "mon", "max", "form", "to", "quant", "node", "val", "grade", "comm", "nu", "orig", "cmp", "um", "alph", "cal", "al", "pos"], "den": ["deg", "omin", "mind", "diff", "di", "rem", "none", "dn", "ey", "ver", "mn", "range", "bill", "du", "des", "uni", "iden", "una", "wen", "DEN", "dev", "von", "dim", "vert", "con", "don", "en", "dat", "mem", "nan", "def", "non", "Den", "len", "pen", " len", "vol", "limit", "fam", " Den", "fin", "ven", "die", "ne", "size", "dir", "dan", "perm", "conv", "unit", "goal", "zen", "min", "EN", "nov", "dem", " DEN", "mon", "ki", "mont", "length", "norm", "ann", "nu", "gen", "da", "der", "scale", "dal", "window", "env", "bin", "lan", "pos", "DI"], "intnum": ["integernumber", "uintnumber", "intnumber", "Intnet", "integernet", "uintNUM", "shortnum", "integerNUM", " intmem", "INTnumber", "startum", "intermon", " intnumber", "innam", "uintnam", "indnumber", " intenum", "internum", "extnum", " intNUM", "longmon", "stringden", "intNUM", "uintnum", "INTmem", "IntNUM", "stringnum", "innum", "INTum", "interNUM", "integerenum", "startmon", "intern", "stringn", "indnam", "Intnum", "shortum", "uintn", "extum", "longn", "inmem", "intmon", "extNUM", "uintden", "intnet", "internet", "integernum", "integernam", "startnum", "startnam", "stringum", " intum", "indenum", "longden", "integermon", "longnum", "indmon", "intnam", "uintmem", "intum", "longmem", "shortmon", "INTNUM", "indn", "longum", "extmon", "interum", "intmem", "uintum", "INTnum", "longnam", "shortNUM", " intmon", "indnum", "intn", "indum", " intnam", "uintmon", "inum", "intenum", "intden", "Intmon", "INTmon"], "o_out": [" o_client", "oplaceonly", "oplaceset", "e_in", " o_type", "e_set", "ogintype", "e_only", "o_only", " o_in", "o_int", "o_type", "o_client", "e_out", "o_Out", " o_Out", "oginin", "o_in", " o_int", "oginout", "o_set", "oplaceout", "oplacein", "oginOut"], "o": ["bo", "t", "os", "p", "co", "no", "f", "a", "ou", "d", "l", "v", "ow", "er", "to", "goo", "image", "w", "ox", "ion", "or", "object", "one", "oi", "iso", "h", "so", "oo", "io", "ano", "none", "i", "po", "O", "onet", "opt", "y", "ot", "oin", "oos", "vo", "e", "fo", "op", "m", "go", "lo", "owner", "ta", "c", "ob", "ro", "s", "n", "ao", "oe", "u", "out", "oa", "imo"], "dst": ["dinpend", " dcr", " dstore", "ddest", "daST", "disstore", "Dna", " dstr", "Dst", " ddest", " drest", "didst", "dalst", "diddest", "dalrest", "dlset", "odst", "Dsts", "Ddest", "dalstr", "dast", "drast", "Dest", "dpend", "dsdest", "odrest", "dlst", "draest", "drest", "dlsts", "dbl", "Dbl", "disst", "dalstore", "dlstore", "Dset", " dest", "dinst", "dsts", "Drest", "drasts", "dsST", "dest", "dldest", "didcr", " dsts", "dsst", "odna", "dindest", "dna", " dset", "dST", "dset", "didstore", " dST", "odest", "disrest", "dspend", " dna", "dlcr", " dbl", "draset", "dlbl", "dinST", "disstr", "didset", "dcr", "dstr", "didST", "Dstr", "dadest", "dstore", "drastr", " dpend"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void qxl_realize_common(PCIQXLDevice *qxl, Error **errp)\n\n{\n\n    uint8_t* config = qxl->pci.config;\n\n    uint32_t pci_device_rev;\n\n    uint32_t io_size;\n\n\n\n    qxl->mode = QXL_MODE_UNDEFINED;\n\n    qxl->generation = 1;\n\n    qxl->num_memslots = NUM_MEMSLOTS;\n\n    qemu_mutex_init(&qxl->track_lock);\n\n    qemu_mutex_init(&qxl->async_lock);\n\n    qxl->current_async = QXL_UNDEFINED_IO;\n\n    qxl->guest_bug = 0;\n\n\n\n    switch (qxl->revision) {\n\n    case 1: /* spice 0.4 -- qxl-1 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V04;\n\n        io_size = 8;\n\n        break;\n\n    case 2: /* spice 0.6 -- qxl-2 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V06;\n\n        io_size = 16;\n\n        break;\n\n    case 3: /* qxl-3 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V10;\n\n        io_size = 32; /* PCI region size must be pow2 */\n\n        break;\n\n    case 4: /* qxl-4 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V12;\n\n        io_size = pow2ceil(QXL_IO_RANGE_SIZE);\n\n        break;\n\n    default:\n\n        error_setg(errp, \"Invalid revision %d for qxl device (max %d)\",\n\n                   qxl->revision, QXL_DEFAULT_REVISION);\n\n        return;\n\n    }\n\n\n\n    pci_set_byte(&config[PCI_REVISION_ID], pci_device_rev);\n\n    pci_set_byte(&config[PCI_INTERRUPT_PIN], 1);\n\n\n\n    qxl->rom_size = qxl_rom_size();\n\n    memory_region_init_ram(&qxl->rom_bar, OBJECT(qxl), \"qxl.vrom\",\n\n                           qxl->rom_size, &error_abort);\n\n    vmstate_register_ram(&qxl->rom_bar, &qxl->pci.qdev);\n\n    init_qxl_rom(qxl);\n\n    init_qxl_ram(qxl);\n\n\n\n    qxl->guest_surfaces.cmds = g_new0(QXLPHYSICAL, qxl->ssd.num_surfaces);\n\n    memory_region_init_ram(&qxl->vram_bar, OBJECT(qxl), \"qxl.vram\",\n\n                           qxl->vram_size, &error_abort);\n\n    vmstate_register_ram(&qxl->vram_bar, &qxl->pci.qdev);\n\n    memory_region_init_alias(&qxl->vram32_bar, OBJECT(qxl), \"qxl.vram32\",\n\n                             &qxl->vram_bar, 0, qxl->vram32_size);\n\n\n\n    memory_region_init_io(&qxl->io_bar, OBJECT(qxl), &qxl_io_ops, qxl,\n\n                          \"qxl-ioports\", io_size);\n\n    if (qxl->id == 0) {\n\n        vga_dirty_log_start(&qxl->vga);\n\n    }\n\n    memory_region_set_flush_coalesced(&qxl->io_bar);\n\n\n\n\n\n    pci_register_bar(&qxl->pci, QXL_IO_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_IO, &qxl->io_bar);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_ROM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->rom_bar);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_RAM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vga.vram);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_VRAM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vram32_bar);\n\n\n\n    if (qxl->vram32_size < qxl->vram_size) {\n\n        /*\n\n         * Make the 64bit vram bar show up only in case it is\n\n         * configured to be larger than the 32bit vram bar.\n\n         */\n\n        pci_register_bar(&qxl->pci, QXL_VRAM64_RANGE_INDEX,\n\n                         PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                         PCI_BASE_ADDRESS_MEM_TYPE_64 |\n\n                         PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                         &qxl->vram_bar);\n\n    }\n\n\n\n    /* print pci bar details */\n\n    dprint(qxl, 1, \"ram/%s: %d MB [region 0]\\n\",\n\n           qxl->id == 0 ? \"pri\" : \"sec\",\n\n           qxl->vga.vram_size / (1024*1024));\n\n    dprint(qxl, 1, \"vram/32: %d MB [region 1]\\n\",\n\n           qxl->vram32_size / (1024*1024));\n\n    dprint(qxl, 1, \"vram/64: %d MB %s\\n\",\n\n           qxl->vram_size / (1024*1024),\n\n           qxl->vram32_size < qxl->vram_size ? \"[region 4]\" : \"[unmapped]\");\n\n\n\n    qxl->ssd.qxl.base.sif = &qxl_interface.base;\n\n    if (qemu_spice_add_display_interface(&qxl->ssd.qxl, qxl->vga.con) != 0) {\n\n        error_setg(errp, \"qxl interface %d.%d not supported by spice-server\",\n\n                   SPICE_INTERFACE_QXL_MAJOR, SPICE_INTERFACE_QXL_MINOR);\n\n        return;\n\n    }\n\n    qemu_add_vm_change_state_handler(qxl_vm_change_state_handler, qxl);\n\n\n\n    qxl->update_irq = qemu_bh_new(qxl_update_irq_bh, qxl);\n\n    qxl_reset_state(qxl);\n\n\n\n    qxl->update_area_bh = qemu_bh_new(qxl_render_update_area_bh, qxl);\n\n    qxl->ssd.cursor_bh = qemu_bh_new(qemu_spice_cursor_refresh_bh, &qxl->ssd);\n\n}\n", "idx": 5767, "substitutes": {"qxl": ["qqxl", "qtryl", "eqxhl", "qrxhl", "qtxls", "tryxxla", "querpayln", "qxz", "qdxlr", "quxsl", "qfxel", "qxdel", "equxli", "qplexdl", "tryxl", "qrxl", "tryxxel", "qaxll", "quxhl", "qxll", "quxlp", "requdxz", "qwxlp", "ryinxla", "qxsdl", "uexlc", "qxylp", "uemxdl", "wxli", "qpayln", "quxel", "corexfl", "qtryel", "qydl", "qpayl", "qtxl", "qmxla", "qtryla", "qxlist", "iqxli", "qqxpel", "iqrxl", "qxpdl", "quuxl", "qxpla", "qxil", "corexfls", "qaxml", "qaxlen", "ryinxlb", "qxxdl", "questuxdl", "eqxli", "uexli", "quxlc", "sqxfl", "qinxl", "qxmlfl", "qufxlp", "qwxel", "ryxlb", "sqxel", "sqxli", "qplexl", "qaxlr", "qqxplp", "qylli", "querpayml", "equxl", "qexlc", "qexdl", "qfxli", "qxfls", "qxill", "requdxll", "qqrxel", "ryxl", "qfxlc", "qxiz", "qxL", "cachexl", "quxll", "sqinxli", "equxel", "qxmlel", "quxli", "corexla", "quxfL", "iqrxel", "qxcli", "qxlp", "qqxel", "uemxlc", "qxhl", "qxyli", "qexel", "qdxz", "qqrxml", "quxfls", "qxyml", "qmxhl", "wxl", "cachexlc", "qxcla", "qxpel", "tryxxdl", "qexl", "qtrylb", "qxdlc", "sqxlr", "qeylp", "qxls", "qxsel", "sqxmll", "querxml", "tryxxl", "qeyl", "corexfla", "qpayll", "qaxel", "qfxlp", "qnexel", "qinxlr", "quxlr", "qrxml", "iqxl", "questxla", "ryinxl", "quuxhl", "corexdl", "qaxfl", "qxfla", "sqinxla", "qxmllen", "qxxla", "ryinxli", "querxll", "qxplist", "iqxsl", "qtrysl", "qqxpl", "wxsel", "qxsl", "qylla", "querxl", "sqxla", "qaxl", "qinxla", "tryxel", "qqxplist", "qpxl", "tryxla", "qqxlp", "qqxlist", "quxfhl", "sqxl", "qwxlc", "sqxlen", "sqinxlr", "qxli", "qqrxl", "qxln", "qinxli", "qxfl", "qxdl", "qplexlc", "qxfdl", "qxyhl", "qmxlc", "uemxl", "requdxl", "qxyln", "requdxlr", "qexli", "eqxel", "qwxl", "wxsli", "qdxll", "qxsla", "qxla", "qfxdl", "qxsli", "querxln", "ryxli", "qyllb", "equxhl", "qxxl", "sqxmllen", "cachexel", "qxfL", "tryxdl", "qpxla", "quxla", "qmxli", "quxfl", "qnexl", "iqrxli", "qnexml", "qeylist", "qxdli", "wxdl", "eqxl", "qyli", "quxL", "qxlb", "qmxdl", "qyel", "corexl", "sqxmlfl", "quxls", "querpayll", "cachexla", "qqrxln", "qxilr", "qufxel", "uemxli", "qaxla", "qeyel", "iqrxsl", "qxslc", "requxlr", "quxdl", "qxpl", "qmxls", "qpxel", "qxclr", "qqxln", "qpayml", "qxlc", "questuxli", "qrxli", "qinxlb", "qxplp", "qxxel", "qfxl", "uexl", "quxl", "cachexsel", "qxlr", "qxpls", "qxpfl", "cachexslc", "qxcl", "qmxl", "qufxl", "uexdl", "questxli", "qtxhl", "qxmll", "qxml", "qxlen", "quuxli", "qrxsl", "qrxln", "qnexln", "requxll", "querpayl", "qqxml", "qpxdl", "qxyl", "qxdhl", "requxz", "qrxel", "quxz", "qxyll", "questuxla", "qyl", "corexfdl", "qtrydl", "questuxl", "qyll", "questxdl", "qufxlc", "qxfhl", "corexls", "qaxln", "iqxel", "qtryli", "cachexsl", "questxl", "requxl", "qxplen", "qtxL", "wxel", "qdxl", "sqxmlel", "quuxla", "qexla", "qxyel", "cachexsla", "sqinxl", "wxsdl", "qxylist", "qaxli", "qxdla", "qfxla", "qplexli", "qexlp", "wxsl", "qxel", "ryxla"], "errp": ["Erp", " errps", "rrp", "erps", "errorpb", " errpb", " errping", "erP", "rrpb", " errP", "errpb", "errorp", " errr", "errping", "erp", "rrping", "errr", "errorping", "ErP", "errP", "Erps", "err", "Err", "errps"], "config": ["general", "rc", "conf", "apache", "conn", "controller", "data", "length", "cont", "spec", "channel", "policy", "con", "connection", "map", "ext", "options", "setup", "set", "control", "attribute", "setting", "bus", "profile", "chain", "driver", "history", "state", "def", "lag", "info", "adj", "tree", "figure", "support", "FIG", "admin", "command", "capt", "cfg", "Config", "content", "bits", "table", "etc", "storage", "ct", "fig", "settings", "c", "cmd", "feat", "mot", "param", "input", " CONFIG", "cache", "bc"], "pci_device_rev": ["pci_dev_ref", "pci_device2ref", "pci_device_info", "pci_dev_ev", "pci_dev_ptr", "pci_dev_rel", "pci_device_id", "pci_dev_id", "pci_dev_info", "pci_device_rel", "pci_device2rev", "pci_dev_bre", "pci_device2re", "pci_device_re", "pci_deviceistrev", "pci_device2bre", "pci_device_bre", "pci_device_ptr", "pci_dev_res", "pci_device_ev", "pci_deviceistres", "pci_device_ref", "pci_device_serv", "pci_device_res", "pci_device2res", "pci_device_vol", "pci_dev_rev", "pci_deviceistserv", "pci_dev_re", "pci_dev_vol", "pci_deviceistvol", "pci_dev_serv"], "io_size": ["io_scale", "io_format", " iozrange", " io7code", "io64info", "io_large", "io_capacity", "io00align", "iolenlimit", "io_default", " io_data", " io_range", " io_code", "io_general", "io_Size", " iozformat", "co00large", "co00capacity", "io00strength", "io7size", "ioxrange", "io6size", "cpu6general", "ioptcapacity", "IO_size", "ioxformat", "ioptdefault", "IO_scale", "iolenSize", "co_default", "io00general", "iozsize", "io64size", "ioptlarge", "io64format", "co_large", " iozinfo", "ioptsize", "io7format", "co00size", "io_strength", "io64range", "io_range", "cpu_general", "ioxsize", "io00default", "cpu6strength", " io7size", "iolenscale", "io_limit", "IO_limit", "io00large", "io_code", "cpu_size", "cpu_strength", "ioxinfo", " io7format", "io_info", "ioLsize", "io64capacity", " io_info", " io7data", "cpu6size", "io00capacity", "io_align", "co00default", "co_size", "ioLstrength", "io64large", "io6align", "iolensize", "io6strength", "io7code", "io_data", "iozrange", "iozinfo", "cpu_align", "ioLalign", "cpu6align", "io00size", " iozsize", "io64default", "IO_Size", "ioLgeneral", "io6general", "iozformat", "co_capacity", " io_format", "io7data"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = ( 3 * dc +  1) >> 1;\n\n    dc = (17 * dc + 64) >> 7;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 4; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n", "idx": 5781, "substitutes": {"dest": ["master", "save", "host", "sum", "cont", "it", "msg", "loc", "mount", "ist", "reason", "decl", "seed", "opt", "target", "iter", "comb", "coord", "Dest", "n", "sort", "search", "ptr", "cp", "dev", "copy", "success", "delete", "origin", "dist", "dim", "way", "sp", "draw", "wait", "nom", "list", "check", "transform", "st", "output", "dat", "mem", "comment", "gest", "src", "transfer", "last", "temp", "ctr", "dc", "address", "trans", "good", "port", "size", "source", "chain", "est", "shift", "rest", "match", "rel", "table", "alt", "add", "out", "tmp", "v", "pipe", "spec", "parent", "server", "gate", "result", "usr", "orig", "buf", "store", "status", "tr", "reverse", "global", "addr", "desc", "route", "pos", "see", "dep"], "linesize": ["lsiz", " linessize", " linesIZE", "linesiz", "linessize", "lsizing", "inessize", "lsizes", "netsiz", " linesizer", "lsize", "linesizes", "inesizes", "linesizer", "lsizer", "netsIZE", "netsize", "linesizing", " linesizing", "lssize", " linesiz", "lsIZE", "netsizing", "inesizer", "linesIZE", "inesize", " linesizes"], "block": ["entry", "pack", "copy", "join", "Block", "pixel", "list", "scan", "field", "check", "map", "cl", "set", "trans", "lock", "chain", "word", "link", "cell", "ip", "group", "stop", "source", "point", "bl", "type", "buffer", "row", "BL", "record", "line", "unit", "bin", "bf", "param", "box", "load", "event"], "i": [" m", " I", "ei", "li", "init", " err", "sim", " iter", "bi", "is", "ind", "ii", "v", "ini", "sp", "mi", "ix", " bi", " pi", "it", "me", "ic", "q", " x", "asi", "si", "j", "di", "chain", "ip", "index", "point", "g", " v", "ui", "multi", "iu", "xi", "y", "zi", "iter", "print", " ti", "ti", "ci", "m", "ai", "pi", "im", "ims", " mi", "x", "I", "phi", "qi", "c", "n", "z", " ii", "batch"], "cm": ["tc", "gm", "ace", "hm", "cp", "co", "conf", "ch", "copy", "com", "cv", "form", "bm", "ctr", "fm", "ym", "rm", "lc", "cont", "fine", "pc", "mp", "dc", "sm", "cd", "map", "cl", "cc", "pm", "km", "module", "comm", "cn", "gc", "sem", "cr", "nm", "fc", "asm", "mb", "CM", "cmp", "cy", "um", "ci", "wm", "m", "vm", "ca", "ck", "cut", "rom", "mm", "cs", "ct", "mask", "csv", "c", "mode", "cmd", "gr", "mc", "mr"]}}
{"project": "FFmpeg", "commit_id": "a70c27e813346a11e5fff3d329ecba82fb76826a", "target": 1, "func": "static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)\n\n{\n\n    switch(mode){\n\n    case 0: //no shift\n\n        return src[0];\n\n    case 1: // 1/4 shift\n\n        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;\n\n    case 2: // 1/2 shift\n\n        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;\n\n    case 3: // 3/4 shift\n\n        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;\n\n    }\n\n    return 0; //should not occur\n\n}\n", "idx": 5789, "substitutes": {"src": ["view", "bn", "sel", "scan", "sl", "txt", "loc", "str", "cur", "supp", "sr", "gc", "sq", "sn", "etc", "gin", "ripp", "hl", "ctl", "sur", "sort", "ptr", "sc", "bj", "dist", "ins", "rl", "obj", "lat", "st", "dat", "proc", "enc", "stab", "sb", "impl", "sys", "ack", "load", "rc", "syn", "th", "dest", "sec", "ctr", "usc", "cb", "ipl", "bs", "source", "fc", "np", "comp", "std", "rs", "iv", "rt", "img", "ser", "warn", "tmp", "ul", "sync", "inst", "sub", "cc", "req", "in", "ssl", "bb", "usr", "tp", "hw", "bin", "input", "stream", "bc", "sw"], "stride": ["scoperide", "keyider", "volider", "STRride", "scopeause", "volide", "sprride", "Strider", "wrided", "sharpided", "arrride", "sprause", "keyide", "shrorate", "divide", " strade", "scopeude", "divider", "divorate", "strine", "STRiden", " stripe", "volride", "divause", "scopeine", "keyiden", "drided", "scopeorate", "scopeided", "drride", "striden", "syside", "sysider", "sprade", "arrider", "wrride", "drine", "sysided", "divine", "scopeape", "scopeope", "sharpause", "STRided", "sharpipe", "STRide", "Strride", "sprided", "Stride", "sharpide", "strause", " strided", "divade", "strope", "Strause", "divride", "strade", " strape", "strape", "spride", "STRope", "shrine", " strride", " striden", "Strided", "wrude", "strorate", "Strope", "Strape", "keyided", "scopeide", "sharpiden", "driden", "Strine", "arrine", "shride", "volided", " strider", "strided", "divided", "wride", "scopeider", "STRipe", "strride", "strude", "stripe", "drider", "strider", "STRine", "arride", "sysiden", "STRude", "sharpride", "dride", "shrause"], "mode": ["key", "MODE", "order", "de", "dm", "d", "id", "dim", "direction", "ode", "rate", "error", "position", "str", "style", "depth", "kind", "module", "option", "ror", "format", "mt", "state", "def", "role", "step", "md", "act", "type", "range", "mid", "command", "status", "code", "um", "te", "m", "scale", "mm", "theme", "Mode", "im", "tm", "mod", "ide", "move"], "r": ["rc", "dr", "t", "p", "f", "d", "l", "v", "arr", "lr", "R", "rate", "rr", "it", "q", "w", "str", "or", "h", "vr", "sr", "o", "cr", "attr", "i", "rb", "b", "nr", "g", "pr", "range", "rf", "rs", "ir", "rar", "ar", "e", "m", "rect", "rd", "c", "rt", "er", "u", "err", "mr"]}}
{"project": "qemu", "commit_id": "4c4f0e4801ac79632d03867c88aafc90b4ce503c", "target": 1, "func": "static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    uint32_t retval = -1;\n\n    int idx;\n\n\n\n    DPRINTF(\"%s: addr %08x\\n\", __func__, addr);\n\n    if (addr & 0xF) {\n\n        goto out;\n\n    }\n\n    idx = (addr >> 6) & 0x3;\n\n    if (addr == 0x0) {\n\n        /* TIFR (TFRR) */\n\n        retval = opp->tifr;\n\n        goto out;\n\n    }\n\n    switch (addr & 0x30) {\n\n    case 0x00: /* TICC (GTCCR) */\n\n        retval = opp->timers[idx].ticc;\n\n        break;\n\n    case 0x10: /* TIBC (GTBCR) */\n\n        retval = opp->timers[idx].tibc;\n\n        break;\n\n    case 0x20: /* TIPV (TIPV) */\n\n        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);\n\n        break;\n\n    case 0x30: /* TIDE (TIDR) */\n\n        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);\n\n        break;\n\n    }\n\n\n\nout:\n\n    DPRINTF(\"%s: => %08x\\n\", __func__, retval);\n\n\n\n    return retval;\n\n}\n", "idx": 5797, "substitutes": {"opaque": ["patile", "Opus", "Opatile", "paque", "OPaque", "OPatile", "ogacity", "OPus", "Opaque", " oposter", "opus", "oplay", "ogatile", "poster", "Oplay", "opatile", " opatile", "ogoster", "oposter", "ogaque", "opacity", " oplay", "OPlay", " opacity", " opus", "pacity"], "addr": ["ptr", "dr", "rc", "gz", "inter", "host", "gt", "pkg", "work", "id", "arr", "lr", "r", "data", "ix", "sp", "ad", "hash", "dd", "address", "obj", "map", "loc", "offset", "trans", "alias", "gate", "pad", "adr", "align", "attr", "arp", "ip", "asm", "mem", "np", "off", " address", "act", "arch", "rs", "ord", "rn", "res", "coord", "hw", "Address", "x", "on", "tx", "src", "alt", "grad", "pos", "ack", "rt", "hl", "url", "cmd", "add"], "len": ["lp", "ln", "Len", "l", "id", "data", "length", "ize", "field", "val", "en", "size", "mem", "type", "ref", "cmp", " length", "num", "seq", "bin", "ls", "lan", "n", "al", "lib", "Length"], "opp": ["offensive", "oppers", "pp", "emp", "hess", "sim", "roth", "pkg", "form", "bj", " Opp", "ott", "cho", "join", "fac", "oit", "school", "app", "xff", "ost", "animate", "prof", "obj", "Opp", "supp", "comm", "hog", "itz", "ip", "jump", "plug", "company", "adj", "ijk", "stick", "agg", "eff", "ipp", "ij", "omp", "op", "sie", "jp", "perm", "pread", "ogg", "rog", "upp", "ik", "odd", "operator", "hom", "makers", "ppo", "obb", "kick", "oc", "Lev", "impl", "oph", "obl", "evil", "pps", "oise"], "idx": ["idv", "indx", "indix", " idxs", "sidxf", "Idex", "identct", "sidxe", "sidx", "Idx", "identx", "idval", "ridval", "dbv", " idindex", "dbxs", "idxb", " idxf", "identindex", "identix", "identxes", "identxs", "Idv", "dbx", " idval", " idxes", "idix", " idg", "identxb", "idxes", "ridex", "ridxs", "dbval", " idix", "index", "identex", "indindex", " idxe", " idxb", "idindex", "indg", "sidxes", "idxe", "identg", " idct", "Idxs", "indxb", "idxs", " idv", "idct", "idxf", "identxf", "identxe", "indct", "identv", "indxs", "idex", "idg", "ridv", "ridx", " idex", "indv"]}}
{"project": "qemu", "commit_id": "40f860cd6c1aa0d3399e3f8158f20bdc5b2bfbfe", "target": 0, "func": "static void gen_exception_insn(DisasContext *s, int offset, int excp)\n\n{\n\n    gen_a64_set_pc_im(s->pc - offset);\n\n    gen_exception(excp);\n\n    s->is_jmp = DISAS_JUMP;\n\n}\n", "idx": 5810, "substitutes": {"s": ["os", "p", "S", "ds", "south", "is", "a", "d", "ps", "ctx", "q", "sync", "serv", "sl", "w", "set", "ss", "h", "so", "bs", "ns", "js", "hs", "b", "state", "sq", "g", "sts", "rs", "gs", "y", "ts", "es", "sn", "sv", "cs", "sb", "c", "as", "ls", "n", "qs", "sys", "se", "sw"], "offset": ["ptr", "top", "et", "p", "inter", "bound", "sp", "length", "to", "pc", "error", "position", "padding", "address", "loc", "amp", "set", "o", "pad", "location", "i", "off", "mt", "pointer", "slot", "index", "point", "shift", "ref", "row", "fp", "len", "coord", "addr", "offs", "part", "Offset", "oid", "original", "pos", "start", "seek"], "excp": [" exCP", "exceptwp", "pexcp", "nexvp", "pexfp", "desvp", "Exp", "exceptp", "pexCP", "Excp", "exCP", " exwp", "desfp", "Exwp", "exfp", "ExCP", "exceptCP", "nexfp", "exwp", "nexCP", "pexvp", "desCP", "exceptcp", "descp", "nexcp", "exvp"]}}
{"project": "qemu", "commit_id": "ca6b6e1e68ac44b2e8895da10dd1c80dc03d08b7", "target": 0, "func": "static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)\n\n{\n\n    const QDictEntry *ent;\n\n    const char *arg_name;\n\n    const QObject *arg_obj;\n\n    bool has_exec_key = false;\n\n    QDict *dict = NULL;\n\n\n\n    if (qobject_type(request) != QTYPE_QDICT) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,\n\n                   \"request is not a dictionary\");\n\n        return NULL;\n\n    }\n\n\n\n    dict = qobject_to_qdict(request);\n\n\n\n    for (ent = qdict_first(dict); ent;\n\n         ent = qdict_next(dict, ent)) {\n\n        arg_name = qdict_entry_key(ent);\n\n        arg_obj = qdict_entry_value(ent);\n\n\n\n        if (!strcmp(arg_name, \"execute\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n\n                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\",\n\n                           \"string\");\n\n                return NULL;\n\n            }\n\n            has_exec_key = true;\n\n        } else if (strcmp(arg_name, \"arguments\")) {\n\n            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (!has_exec_key) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n        return NULL;\n\n    }\n\n\n\n    return dict;\n\n}\n", "idx": 5820, "substitutes": {"request": ["get", "query", "p", "reset", "QUEST", "art", "config", "frame", "python", "insert", "argument", "question", "path", "enter", "q", "xml", "call", "transform", "req", "object", "complete", "package", "requ", "current", "response", "new", "Request", "forward", "document", "quest", "raw", "pair", "initial", "project", "reference", "import", "update", "first", "from", "open", "express", "message", "context", "create", "reply", "input", "start", "public"], "errp": ["errorpre", "derp", "derpa", "rerwp", " errps", " erpat", "erps", "rrp", "iterP", "iterpa", "dercp", "derpc", "errorpa", "errpa", "iterpre", "errorpc", "errorwp", "rerpt", "errcp", "erP", "errwp", "rrpb", "rerpc", "erping", " errP", " erps", "derwp", "rercp", " erP", "erpat", "errpb", "derpt", "errpat", "errorp", " errpat", "rerpb", "errorP", "rerpa", "iterping", "errpre", "errping", "rrcp", "errpc", "erp", "derpb", " erp", "errpt", "iterp", "iterpt", "rrping", "errorping", "rerping", "errP", "rerp", "derping", "erpre", "errps"], "ent": ["gent", "ant", "entry", "pent", "out", "ents", "et", "art", "ient", "el", "conn", "sec", "ind", "mont", "att", "entity", "nt", "ow", "ec", "cont", "sent", "quant", "it", " Ent", "inst", "obj", "cur", "ew", "en", "k", "or", "st", "kt", "comm", "eng", "imp", "anc", "eq", "ident", "def", "met", "md", "net", "inc", "enc", "rec", "e", "rent", "det", "Ent", "ENT", "ct", "ac", "inf", "nd", "gr", "pl", "oc", "n", "add", "ict", "ev", "mut", "event"], "arg_name": ["app_nam", "tag_info", "arg7type", " argacame", "arg7info", "argNameattr", " argacNAME", "argtpath", "ar___path", "arg_NAME", "argacNAME", " argacname", "ar_local", "ar_num", "arg8time", " arg_ame", "arg___name", "arg_type", "ar___local", "argNametype", "argacname", "ar_name", "arg8nam", "tag_obj", "arg_ame", "arg_attr", "app_time", "argtnum", "ar___name", "argtname", " arg_attr", "argNamename", "arg7obj", "arg___local", "argtlocal", "arg_num", "arg_names", "argacnames", "arg8local", " arg_type", "tag_name", " arg_names", "arg_path", "ar___num", "arg7name", "argacame", "arg___path", " arg_NAME", " argacnames", "argNamenames", "app_name", "app_local", "arg_time", "arg_local", "arg___num", "ar_path", "tag_type", "arg8name", "arg_info", "arg_nam"], "arg_obj": ["cmd_bj", " arg_value", "arg___val", "arg_value", "arg64obj", "arg_bj", " arg_o", "cmd64bj", "arg64bj", "cmd64name", "arg_addr", "arg___object", " arg_addr", "cmd_val", "arg_o", "arg_val", "cmd64val", "arg_object", "cmd64obj", " arg_val", "cmd_obj", "arg___addr", " arg_object", "arg___obj", "cmd_name", "arg64val", "arg64name"], "dict": ["get", "pp", "conf", "pkg", "full", "sum", "arr", "nt", "msg", "str", "cur", "wd", "response", "db", "pl", "inf", "cmd", "json", "compl", "subject", "database", "draw", "list", "dd", "con", "obj", "build", "output", "dat", "def", "bind", "found", "new", "pd", "all", "session", "null", "vol", "context", "sys", "ict", "load", "df", "d", "map", "cert", "ld", "state", "dir", "tree", "print", "table", "ct", "nd", "del", "local", "out", "dr", "hd", "doc", "td", "ds", "upper", "hash", "collect", "cd", "result", "document", "container", "rd", "input", "cache", "bd"]}}
{"project": "FFmpeg", "commit_id": "7e4fe5162ab94a413e04caae19193c5e7a4c6478", "target": 0, "func": "static void sha1_transform(uint32_t state[5], const uint8_t buffer[64])\n\n{\n\n    uint32_t block[80];\n\n    unsigned int i, a, b, c, d, e;\n\n\n\n    a = state[0];\n\n    b = state[1];\n\n    c = state[2];\n\n    d = state[3];\n\n    e = state[4];\n\n#if CONFIG_SMALL\n\n    for (i = 0; i < 80; i++) {\n\n        int t;\n\n        if (i < 16)\n\n            t = AV_RB32(buffer + 4 * i);\n\n        else\n\n            t = rol(block[i-3] ^ block[i-8] ^ block[i-14] ^ block[i-16], 1);\n\n        block[i] = t;\n\n        t += e + rol(a, 5);\n\n        if (i < 40) {\n\n            if (i < 20)\n\n                t += ((b&(c^d))^d)     + 0x5A827999;\n\n            else\n\n                t += ( b^c     ^d)     + 0x6ED9EBA1;\n\n        } else {\n\n            if (i < 60)\n\n                t += (((b|c)&d)|(b&c)) + 0x8F1BBCDC;\n\n            else\n\n                t += ( b^c     ^d)     + 0xCA62C1D6;\n\n        }\n\n        e = d;\n\n        d = c;\n\n        c = rol(b, 30);\n\n        b = a;\n\n        a = t;\n\n    }\n\n#else\n\n    for (i = 0; i < 15; i += 5) {\n\n        R0(a, b, c, d, e, 0 + i);\n\n        R0(e, a, b, c, d, 1 + i);\n\n        R0(d, e, a, b, c, 2 + i);\n\n        R0(c, d, e, a, b, 3 + i);\n\n        R0(b, c, d, e, a, 4 + i);\n\n    }\n\n    R0(a, b, c, d, e, 15);\n\n    R1(e, a, b, c, d, 16);\n\n    R1(d, e, a, b, c, 17);\n\n    R1(c, d, e, a, b, 18);\n\n    R1(b, c, d, e, a, 19);\n\n    for (i = 20; i < 40; i += 5) {\n\n        R2(a, b, c, d, e, 0 + i);\n\n        R2(e, a, b, c, d, 1 + i);\n\n        R2(d, e, a, b, c, 2 + i);\n\n        R2(c, d, e, a, b, 3 + i);\n\n        R2(b, c, d, e, a, 4 + i);\n\n    }\n\n    for (; i < 60; i += 5) {\n\n        R3(a, b, c, d, e, 0 + i);\n\n        R3(e, a, b, c, d, 1 + i);\n\n        R3(d, e, a, b, c, 2 + i);\n\n        R3(c, d, e, a, b, 3 + i);\n\n        R3(b, c, d, e, a, 4 + i);\n\n    }\n\n    for (; i < 80; i += 5) {\n\n        R4(a, b, c, d, e, 0 + i);\n\n        R4(e, a, b, c, d, 1 + i);\n\n        R4(d, e, a, b, c, 2 + i);\n\n        R4(c, d, e, a, b, 3 + i);\n\n        R4(b, c, d, e, a, 4 + i);\n\n    }\n\n#endif\n\n    state[0] += a;\n\n    state[1] += b;\n\n    state[2] += c;\n\n    state[3] += d;\n\n    state[4] += e;\n\n}\n", "idx": 5826, "substitutes": {"state": ["key", "init", "config", "f", "resource", "r", "spec", "it", "list", "hash", "error", "check", "bar", "call", "rule", "map", "trans", "STATE", "port", "lock", "size", "space", "dict", "State", "index", "info", "step", "trace", "range", "seed", "type", "store", "tag", "status", "iter", "print", "area", "unit", "loop", "base", "test", "core", "user", "open", "monitor", "start", "local", "cache", "event", "states"], "buffer": ["capacity", "screen", "out", "p", "max", "limit", "f", "binary", "v", "data", "length", "board", "xff", "q", "padding", "Buffer", "offset", "output", "buff", "empty", "word", "size", "index", "memory", "buf", "type", "seed", "text", "command", "code", "page", "base", "byte", "sequence", "window", "bin", "message", "n", "total", "input", "cache", "batch"], "block": ["view", "pack", "no", "config", "join", "filter", "board", "Block", "channel", "list", "hash", "it", "field", "q", "sync", "check", "prefix", "map", "node", "set", "control", "object", "lock", "chain", "group", "link", "ip", "proc", "blocks", "point", "bl", "type", "range", "ref", "row", "pool", "tag", "line", "bit", "unit", "model", "table", "base", "byte", "part", "window", "mask", "bin", "box", "load", "frame", "cache", "batch"], "i": ["p", "id", "l", "ii", "ini", "it", "q", "asi", "hi", "di", "gi", "ie", "y", "iter", "ci", "ami", " j", "ims", "qi", "cli", "n", " ii", "ite", "json", "ei", "ity", "ix", "ic", "si", "oi", "j", "h", "ji", "index", "name", "zi", "try", "pi", "x", "phi", "is", "f", "ind", "mi", "depth", "io", "ri", "chain", "ip", "multi", "ti", "m", "iy", "ai", "im", "I", "s", "u", "init", "li", "sim", "ki", "bi", "v", " bi", "me", "o", "in", "info", "g", "ui", "iu", "ij", "xi", "status", "um", "client", "sql", "err"], "a": ["p", "ea", "l", "ap", "ma", "y", "area", "ami", "ta", "n", "z", "er", "oa", "el", "ach", "r", "app", "w", "en", "j", "h", "A", "at", "this", "ate", "all", "x", "am", "ab", "action", "sa", "ia", "aa", "f", "ae", "ad", "pa", "fa", "ba", "m", "ed", "ai", "as", "s", "aaa", "ao", "go", "u", "va", "la", "v", "to", "ga", "o", "ee", "an", "g", "da", "ar", "es", "ca", "au", "ac", "ak", "al"], "b": ["bo", "p", "ch", "bi", "bt", "f", "ab", "l", "v", "r", "to", "it", "fb", "ad", "bar", "bd", "cb", "w", "h", "j", "br", "o", "abb", "body", "bs", "B", "rb", "bb", "erb", "g", "bl", "mb", "lib", "gb", "ib", "ba", "y", "ar", "es", "db", "bg", "m", "ed", "eb", "base", "bp", "sb", "as", "ob", "bf", "back", "bu", "n", "by", "z", "nb", "u", "bc", "wb", "be"], "c": ["tc", "rc", "sc", "cu", "cp", "co", "cm", "p", "unc", "ch", "conf", "com", "cv", "f", "vc", "v", "cat", "l", "r", "ec", "lc", "col", "cont", "pc", "ad", "cor", "ic", "dc", "C", "con", "cd", "cb", "cl", "w", "cc", "cur", "arc", "h", "o", "gc", "cr", "fc", "chain", "g", "y", "ar", "enc", "cf", "ci", "can", "m", "ca", "ce", "cs", "ct", "ac", "x", "n", "z", "u", "cache", "bc"], "d": ["dr", "p", "dev", "dt", "de", "td", "ds", "dm", "f", "l", "id", "v", "ind", "r", "done", "it", "ad", "fd", "dd", "dc", "q", "cd", "w", "str", "ld", "di", "h", "j", "o", "ud", "dn", "D", "dat", "sd", "dh", "dir", "dx", "g", "md", "at", "da", "du", "y", "dp", "dom", "db", "m", "der", "ed", "and", "nd", "as", "del", "s", "n", "z", "er", "u", "bd"], "e": ["ei", "et", "p", "de", "el", "ea", "f", "eu", "l", "v", "le", "ec", "r", "re", "ae", "entity", "it", "oe", "em", "w", "en", "ue", "h", "o", "ne", "ie", "ee", "est", "err", "an", "g", "at", "y", "es", "E", "end", "m", "te", "ate", "ed", "ek", "ce", "eb", "x", "and", "s", "n", "er", "u", "se", "be"], "t": ["tc", "ant", "et", "p", "dt", "td", "tt", "ty", "temp", "l", "v", "att", "r", "to", "it", "vt", "tar", "tu", "w", "set", "h", "st", "j", "o", "u", "pt", "wt", "ret", "mt", " ot", "at", "g", "trace", "term", "type", "tree", " T", "y", "ot", "tp", "ts", "status", "ti", "text", "te", "m", "tg", "tr", "ert", "title", "ent", "ta", "x", "qt", "rt", "n", "total", "er", "T", "out"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_int64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int64_t *v = pv;\n\n    qemu_get_sbe64s(f, v);\n\n    return 0;\n\n}\n", "idx": 5834, "substitutes": {"f": ["df", "af", "fr", "t", "p", "form", "fi", "lf", "tf", "d", "l", "fm", "fac", "r", "fb", "fd", "file", "q", "fw", "w", "sf", "h", "fc", "i", "b", "F", "g", "fp", "cf", "e", "fo", "m", "fs", "ile", "uf", "c", "bf", "inf", "fx"], "pv": ["pV", " pV", "ppV", "Pvi", "ppv", " pvt", " pvi", "prV", "Pj", " pj", "ppvt", "ppj", "PV", "prv", "prvi", "pj", "Pvt", "pvi", "Pv", "pvt"], "size": ["p", " enc", "Size", " sized", "sp", "SIZE", "length", " notice", "ize", " ignored", " Size", " st", " shr", " sh", " sum", "len", "e", " len", " unused", "pe", "s", " scale", " sp", " count"], "v": ["out", "vp", "t", "p", "tv", "vi", "cv", "a", "l", "r", "q", "ev", "w", "k", "nv", "j", "h", "u", "o", "i", "b", "V", "g", "vm", "m", "sv", "ov", "x", "c", "s", "n", "vt", "value", "av", "va", "uv"]}}
{"project": "qemu", "commit_id": "ad5b88b1f198182642b6cbf3dacb4cade0c80fb9", "target": 1, "func": "static void acpi_build_update(void *build_opaque, uint32_t offset)\n\n{\n\n    AcpiBuildState *build_state = build_opaque;\n\n    AcpiBuildTables tables;\n\n\n\n    /* No state to update or already patched? Nothing to do. */\n\n    if (!build_state || build_state->patched) {\n\n        return;\n\n    }\n\n    build_state->patched = 1;\n\n\n\n    acpi_build_tables_init(&tables);\n\n\n\n    acpi_build(build_state->guest_info, &tables);\n\n\n\n    assert(acpi_data_len(tables.table_data) == build_state->table_size);\n\n    memcpy(build_state->table_ram, tables.table_data->data,\n\n           build_state->table_size);\n\n\n\n    acpi_build_tables_cleanup(&tables, true);\n\n}\n", "idx": 5837, "substitutes": {"build_opaque": ["build_opatile", "build_operaque", "build_operosit", "build_opsaque", "build_iopaque", "build_opsatile", "build_opanse", "build_iopanse", "build_operque", "build_oposit", "build_operatile", "build_iopque", "build_obaques", "build_popaque", "build_operaques", "build_obatile", "build_opque", "build_popatile", "build_opsaques", "build_operanse", "build_iopatile", "build_opaques", "build_popanse", "build_popque", "build_obaque", "build_obosit", "build_opsosit"], "offset": ["os", "ian", "ips", "ogo", "ae", "address", "abled", "itness", "unk", "oby", "foot", "oo", "body", "size", "bytes", "ah", "ids", "alloc", "oot", "code", "ops", "abytes", "ending", "acl", "oes", "rend", "load", " offsets"], "build_state": ["build_states", "buildptstates", " build_request", "build_control", "buildipresource", "buildptoperator", "uild_context", "buildedstate", "buildipstate", "buildptState", "buildingstate", "buildedState", "buildtimerole", "buildtimeState", "build_init", "buildedorder", "buildingsize", "build2pointer", "uild_control", "build2State", "build_resource", "buildingstats", "buildingcount", "build_request", " build_size", "build2count", "buildedstates", "buildtimestate", "build_operator", "buildptrole", "build_size", "build_stats", " build_STATE", "buildptstate", "build_order", "build2states", " build_count", " build_pointer", "buildingstates", "build_role", "build_pointer", "uild_resource", " build_style", "buildipcontrol", " build_stats", "buildinginit", " build_states", "buildedpointer", " build_init", "build_estate", "build_count", "buildtimerequest", " build_order", " build2stats", " build_State", " build2state", "buildptrequest", "build_style", "buildipcontext", "build_STATE", "buildedSTATE", "build2state", "build2stats", " build_estate", " build_operator", "build_context", " build_role", " build2count", "uild_state", "build_State"], "tables": ["Tests", "nases", "tources", " tiffs", "tiffs", "Tabled", "tabases", "trees", "vtates", "Tiffs", "vtests", "tators", "Tources", " tresses", "rotorders", "contables", "tabled", "vtickets", "tenurtles", "detators", "detians", "traceources", "tenables", " turtles", "Tabases", " tests", "pables", "torders", "vtables", "vtamps", "portests", "roturtles", "pabled", " tators", "detests", " torders", "contiffs", " tabases", "rotables", "tates", "tests", "nables", "rotresses", "tases", "tamps", "nests", "traceables", "vtrees", "Tables", "portators", "turtles", "Tases", "portables", "nates", "tians", "Tates", "tresses", "tracerees", "contabases", "traceabled", "pickets", "Trees", "prees", " tians", "Tamps", "pamps", "portians", "tenresses", "contrees", "tickets", "vtases", "detables", "pources", " trees", "Tickets", "tenorders"]}}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int amr_nb_encode_init(AVCodecContext *avctx)\n\n{\n\n    AMRContext *s = avctx->priv_data;\n\n\n\n    if (avctx->sample_rate != 8000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only 8000Hz sample rate supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    avctx->frame_size  = 160;\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n\n\n\n\n    s->enc_state = Encoder_Interface_init(s->enc_dtx);\n\n    if (!s->enc_state) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Encoder_Interface_init error\\n\");\n\n\n        return -1;\n\n    }\n\n\n\n    s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);\n\n    s->enc_bitrate = avctx->bit_rate;\n\n\n\n    return 0;\n\n}", "idx": 5845, "substitutes": {"avctx": [" avcontext", "avecm", "wavctx", "avefx", " avcb", "verpkg", "avectx", "averkt", "ajconf", "afproc", "ajfx", "avekl", " avcm", "avertmp", "devobj", "iverctx", "avtimeout", "cvcm", "wavcb", " avcmp", "aveproc", "avcf", "vertx", "devcmp", " avobj", "wavcontext", "afctx", "navctx", "avconfig", "afconf", "iverwd", "avetx", "averkw", " avkt", " avproc", " avjac", "aveconfig", "ajcfg", " avtx", "avercmp", " avkw", "averjac", "cvcontext", "avetmp", "wavcmp", "ajtmp", "ajproc", "avpkg", "cvctx", "avercontext", "avcontext", "ajconfig", "avfx", "avetimeout", "averctx", "avtmp", "averobj", "avekt", "ajjac", "ajcb", "AVtx", "ajctx", "avproc", "avkt", "ivercontext", "wavreq", "averpkg", "avercfg", "avjac", "avcfg", "devctx", "navkl", " avcli", "ivertmp", "vercmp", "averfx", "navcf", "avconf", " avconn", "ajcmp", "avcm", "AVconn", "AVcontext", "avconn", "avwd", "averconfig", "avobj", "ajcontext", "avcb", "avecontext", "AVctx", "avreq", "avertimeout", "afwd", "devtx", "wavkl", "avkw", "avertx", "afcontext", " avtmp", "avecf", "avewd", "wavcf", " avpkg", "avcli", "avcmp", "averproc", "avkl", "aveconn", "avercli", "avekw", "navreq", " avcfg", "aftmp", "ajcli", "avereq", "avtx", "verctx", "aveconf", "ajtimeout", "cvtx"], "s": ["t", "os", "S", "ess", "p", "sports", "ds", "details", "is", "a", "f", "ms", "l", "v", "ps", "spec", "vs", "gets", "w", "less", "set", "ss", "self", "ports", "j", "aws", "h", "bs", "i", "js", "ns", "hs", "b", "sq", "g", "sts", "rs", "gs", "ts", "es", "stats", "fs", "its", "sv", "cs", "ims", "sb", "c", "als", "ls", "ats", "qs", "sys", "se"]}}
{"project": "FFmpeg", "commit_id": "c6bdc90890250ce351b260eff69ce3c0d0745a62", "target": 1, "func": "void help(void)\n\n{\n\n    printf(\"dct-test [-i] [<test-number>]\\n\"\n\n           \"test-number 0 -> test with random matrixes\\n\"\n\n           \"            1 -> test with random sparse matrixes\\n\"\n\n           \"            2 -> do 3. test from mpeg4 std\\n\"\n\n           \"-i          test IDCT implementations\\n\"\n\n           \"-4          test IDCT248 implementations\\n\");\n\n    exit(1);\n\n}\n", "idx": 5846, "substitutes": {}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(slw)\n\n{\n\n    if (T1 & 0x20) {\n\n        T0 = 0;\n\n    } else {\n\n        T0 = T0 << T1;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 5855, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "e3052ce7b177164da8aecfec065650fa5733e2d1", "target": 1, "func": "static int get_num(ByteIOContext *pb, int *len)\n\n{\n\n    int n, n1;\n\n\n\n    n = get_be16(pb);\n\n    (*len)-=2;\n\n//    n &= 0x7FFF;\n\n    if (n >= 0x4000) {\n\n        return n - 0x4000;\n\n    } else {\n\n        n1 = get_be16(pb);\n\n        (*len)-=2;\n\n        return (n << 16) | n1;\n\n    }\n\n}\n", "idx": 5864, "substitutes": {"pb": ["ph", "tc", "vp", "pp", "cp", "p", "lb", "pkg", "bj", "bh", "lp", "aus", "PB", "ctx", "pc", "fb", "mp", "pg", "wp", "cb", "amp", "pm", "ub", "pa", "px", "pt", "arp", "ip", "ap", "proc", "b", "np", "bb", "resp", "buf", "buffer", "tp", "jp", "ker", "bp", "pl", "uf", "stab", "cmd", "tk", "ab", "wb"], "len": ["fil", "lim", "elt", "compl", "den", "lit", "syn", "el", "lf", "lp", "ln", "ll", "limit", "Len", "l", "le", "v", "nt", "length", "fin", "coll", "sl", "fun", "ld", "en", "fl", "kl", "mat", "size", "vel", "lvl", "il", "wid", "un", "cond", "vec", "pl", "ls", "lis", "nl", "del", "hl", "pos", "gl", "lib"], "n": ["ng", "t", "p", "fn", "ll", "d", "l", "v", "nn", "nt", "r", "norm", "ul", "z", "nor", "note", "en", "j", "h", "ne", "cn", "none", "nm", "dn", "i", "ns", "nu", "nan", "b", "np", "gn", " fn", "name", "an", "nr", "pn", "mn", "g", "y", "sn", "un", "m", "na", "N", "all", "ni", "num", "number", "x", "on", "c", "nl", "nb", "nc", "out", "tn"], "n1": [" nfirst", " n2", "snn", "gnfirst", "sn1", "kn", "n11", "nn", "nat2", "N2", "ng11", "nat1", "gn9", "ngone", "none", "sn9", "n6", "nfirst", "n9", "gnn", "sn11", "gn6", "gn1", "Nfirst", "kfirst", "k1", "N1", "snone", "sn6", "gn11", "ng1", "ng6", "natfirst", "gnone", "n2", "k9", "snfirst"]}}
{"project": "qemu", "commit_id": "e5ba83c53add51796e8ea787d2b7cb1f9c3cb72d", "target": 0, "func": "CPUState *ppc440ep_init(MemoryRegion *address_space_mem, ram_addr_t *ram_size,\n\n                        PCIBus **pcip, const unsigned int pci_irq_nrs[4],\n\n                        int do_init, const char *cpu_model)\n\n{\n\n    MemoryRegion *ram_memories\n\n        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));\n\n    target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS];\n\n    target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS];\n\n    CPUState *env;\n\n    qemu_irq *pic;\n\n    qemu_irq *irqs;\n\n    qemu_irq *pci_irqs;\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"440-Xilinx\"; // XXX: should be 440EP\n\n    }\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    ppc_booke_timers_init(env, 400000000, 0);\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n\n\n    /* SDRAM controller */\n\n    memset(ram_bases, 0, sizeof(ram_bases));\n\n    memset(ram_sizes, 0, sizeof(ram_sizes));\n\n    *ram_size = ppc4xx_sdram_adjust(*ram_size, PPC440EP_SDRAM_NR_BANKS,\n\n                                    ram_memories,\n\n                                    ram_bases, ram_sizes,\n\n                                    ppc440ep_sdram_bank_sizes);\n\n    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */\n\n    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,\n\n                      ram_bases, ram_sizes, do_init);\n\n\n\n    /* PCI */\n\n    pci_irqs = g_malloc(sizeof(qemu_irq) * 4);\n\n    pci_irqs[0] = pic[pci_irq_nrs[0]];\n\n    pci_irqs[1] = pic[pci_irq_nrs[1]];\n\n    pci_irqs[2] = pic[pci_irq_nrs[2]];\n\n    pci_irqs[3] = pic[pci_irq_nrs[3]];\n\n    *pcip = ppc4xx_pci_init(env, pci_irqs,\n\n                            PPC440EP_PCI_CONFIG,\n\n                            PPC440EP_PCI_INTACK,\n\n                            PPC440EP_PCI_SPECIAL,\n\n                            PPC440EP_PCI_REGS);\n\n    if (!*pcip)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN);\n\n\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    return env;\n\n}\n", "idx": 5875, "substitutes": {"address_space_mem": ["address_area_mem", "address_area_memory", "address_space_addr", "address_space_memory", "address_area_addr", "address_space_ram", "address_area_ram"], "ram_size": ["ram2space", "gram_Size", "ram2size", "ram_dim", "gram_ize", "gram_space", "ram_SIZE", "gram_size", "ram_space", "ram_Size", "gram_SIZE", "ram_ize", "ram_time", "gram_time", "gram_dim", "ram2dim", "ram2Size"], "pcip": ["cipes", "pcipes", "bcipes", "cio", "cip", "bcio", "bcip", "pcio", "PCio", "bcips", "PCips", "PCip", "PCipes", "pcips", "cips"], "pci_irq_nrs": ["pci_irq_drs", "pci_irq_sris", "pci_irq_dls", "pci_irq_nbrc", "pci_irq_dris", "pci_irq_src", "pci_irq_nbls", "pci_irq_srs", "pci_irq_nbris", "pci_irq_sls", "pci_irq_nris", "pci_irq_nls", "pci_irq_drc", "pci_irq_nbrs", "pci_irq_nrc"], "do_init": ["do2Init", "do_start", "do2start", "proc_start", "proc_Init", "do2init", "do_Init", "proc_init"], "cpu_model": ["CPU_state", "chip_config", "cpu_state", "processor_model", "chip_Model", "cpu_machine", "cpu_controller", "cpu_mode", "hog_model", "hog_controller", "cpu_config", "CPU_type", "cpu_Model", "hog_models", "processor_mode", "chip_model", "chip_controller", "CPU_model", "processor_models", "hog_machine", "cpu_models", "cpu_type", "CPU_Model"], "ram_memories": ["ram_manories", "ram_medograms", "ram_medories", "ram_medors", "ram_tempory", "ram_histaries", "ram_histors", "ram_history", "ram_temaries", "ram_manograms", "ram_memaries", "ram_manors", "ram_medaries", "ram_tempories", "ram_memograms", "ram_tempograms", "ram_manaries", "ram_memors", "ram_tempors", "ram_memory", "ram_temograms", "ram_histograms", "ram_temparies", "ram_temors", "ram_temories", "ram_temory", "ram_histories"], "ram_bases": ["ram_abains", "ram_chodes", "ram_chases", "ram_basones", "ram_chales", "ram_baores", "ram_bores", "ram_basases", "ram_baases", "ram_bids", "ram_blins", "ram_stids", "ram_nbaves", "ram_bodes", "ram5bases", "ram_bins", "ram_nbores", "ram_base", "ram_pids", "def", "ram5stids", "ram_basodes", "new", "ram_basales", "ram_baves", "ram_blaves", "ram_beodes", "ram_abids", "func", "ram5base", "ram_bales", "ram_pains", "ram_stases", "exec", "ram_blases", "ram_stains", "ram_beones", "ram_abases", "ram5stases", "ram_abase", "ram5bains", "ram_beases", "ram_baaves", "ram_nbins", "ram_beales", "ram_nbases", "ram_chones", "ram_stase", "ram_pases", "ram_bones", "ram_blores", "ram_bains", "ram5stase", "ram_pase", "ram5stains", "ram5bids"], "ram_sizes": ["ram_masockets", "ram_sides", "ram_bets", "ram_masists", "ram_Sets", "ram2sists", "ram_lists", "ram_sists", "ram_sockets", "ram_Sists", "ram2bizes", "ram_Sizes", "ram_howers", "ram_hists", "ram_nsockets", "ram2bets", "ram_lockets", "ram_Sowers", "ram_mides", "ram_seamples", "ram_bizes", "ram2bists", "ram_sinks", "ram2bowers", "ram_seinks", "ram_hizes", "ram_bowers", "ram_lapes", "ram_sapes", "ram_masizes", "ram_lizes", "ram_mamples", "ram_lamples", "ram_samples", "ram_sowers", "ram_hets", "ram_nsizes", "ram_sets", "ram_seizes", "ram_mizes", "ram_minks", "ram_bists", "ram2sets", "ram2sizes", "ram_links", "ram_masapes", "ram_lides", "ram_nsists", "ram2sowers", "ram_nsapes", "ram_seides"], "env": ["stage", "conf", "conn", "cur", "forge", "him", "ah", "esp", "etc", "tx", "er", "viron", "event", "uv", "eas", "ei", "equ", "dev", "door", "environment", "vs", "ctx", "worker", "app", "eg", "obj", "ew", "en", "vid", "eng", "esm", "js", "proc", "po", "pres", "enc", "ent", "tk", "context", "shell", "eu", "priv", "esc", "ped", "org", "cb", "nv", "era", "here", "np", "e", "cam", "end", "iv", "ov", "Environment", "qt", "pe", "eh", "ev", "vt", "init", "vp", "doc", "cv", "tmp", "v", "ec", "server", "eve", "anc", "ee", "usr", "buf", "network", "erd", "sv", "hw", "window", "chart", "timer"], "pic": ["py", "pick", "fg", "p", "ig", "iac", "eric", "wic", "pc", "ic", "sync", "Pic", "ics", "txt", "aci", "Picture", "png", "icc", "pa", "gc", "fc", "anc", "pol", " Pic", "icon", "bot", "jp", "capt", "cam", "pin", "peg", "pi", "ac", "bc", "nic", "feat", "pac", "picture", "mc", "mic", "pict"], "irqs": ["irtcs", "rirq", "irixes", "rirqs", "mirqi", "irtongs", " irongs", "irics", " irbacks", "iriques", "irques", "irces", "irjs", "ierews", " irews", "mirq", "ircs", "ireqs", " irqi", "mirqs", "pircs", "rirjs", " ircs", "rqs", "irtqs", "rerques", "iriqs", "irebacks", "irtq", " irxes", "rjs", "rerqs", "irxes", "ierqi", "pirques", "pirqs", "pirongs", "irbacks", "rerjs", "ierqs", "rirques", "rques", " irces", "ireqi", "irqi", "ireews", "irongs", "irtces", " irques", "pirqi", "pirq", "irews", "rq", "irtqi", "mircs", "pirxes", "rerq", "pirces", "ierbacks", "irq"], "pci_irqs": ["pci_nirqs", "pci_ircs", "pci_virks", "pci_nircs", "pci_vircs", "pci_virq", "pci_virqs", "pci_mirqs", "pci_irks", "pci_mirq", "pci_irq", "pci_nirq", "pci_mirks", "pci_nirks", "pci_mircs"]}}
{"project": "qemu", "commit_id": "146beee5d9f94d96ab3bf54ac355a263290b75ac", "target": 0, "func": "static int piix4_initfn(PCIDevice *dev)\n\n{\n\n    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    isa_bus_new(&d->dev.qdev);\n\n\n\n    pci_conf = d->dev.config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge\n\n    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);\n\n\n\n    piix4_dev = &d->dev;\n\n    qemu_register_reset(piix4_reset, d);\n\n    return 0;\n\n}\n", "idx": 5899, "substitutes": {"dev": ["doc", "pub", "conf", "den", "de", "ch", "disk", "config", "conn", "priv", "debug", "dist", "v", "nt", "data", "app", "spec", "Dev", "ad", "dd", "gu", "devices", "serv", "obj", "w", "pro", "die", "av", "ve", "pad", "device", "build", "bus", "adv", "port", "sd", "mem", "off", "def", "DEV", "ver", "info", "buf", "md", "store", "da", "new", "develop", "vo", "cam", "db", "end", "boot", "raw", "home", "hw", "desc", "env", "des", "block", "sys", "go", "ev", "out", "cmd", "dem"], "d": ["dr", "dj", "t", "p", "dt", "ds", "dm", "debug", "l", "v", "ind", "r", "done", "ad", "fd", "dd", "dc", "bd", "w", "ld", "di", "j", "h", "o", "dl", "device", "dh", "dn", "D", "dat", "sd", "did", "dict", "b", "dx", "g", "da", "pd", "end", "db", "e", "m", "nd", "c", "n", "z", "out", "dos"], "pci_conf": ["pci_ref", "pcietcfg", "pcietconfig", "pci00cfg", "pci00dev", "pci2conf", "pdi_config", "pci_rc", "pci00config", "pci_con", "ppi_rc", "pdi_info", "ppi_ref", "pci2state", "pdi_state", "ppi_dev", "ppi_cfg", "pci00conf", "ppi_def", "pdi_con", "pci_dev", "pci_def", "pci_config", "ppi_config", "pdi_conf", "pcietrc", "pcietconf", "pci2con", "pci_state", "pci_cfg", "pci2config", "pci_info", "ppi_conf"]}}
{"project": "FFmpeg", "commit_id": "d6945aeee419a8417b8019c7c92227e12e45b7ad", "target": 1, "func": "static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)\n\n{\n\n    int i;\n\n    pixel *dst = (pixel *) _dst;\n\n    dctcoef *src = (dctcoef *) _src;\n\n    stride /= sizeof(pixel);\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        dst[0] += src[0];\n\n        dst[1] += src[1];\n\n        dst[2] += src[2];\n\n        dst[3] += src[3];\n\n        dst[4] += src[4];\n\n        dst[5] += src[5];\n\n        dst[6] += src[6];\n\n        dst[7] += src[7];\n\n\n\n        dst += stride;\n\n        src += 8;\n\n    }\n\n\n\n    memset(_src, 0, sizeof(dctcoef) * 64);\n\n}\n", "idx": 5905, "substitutes": {"_dst": ["_wst", "___disdest", "_sst", "___disrc", "_lest", "_wdest", "_sest", "_lot", "_lst", "_drc", "___ddest", "_dsrc", "___dst", "_newdest", "_sot", "_dsst", "_dsot", "_dut", "_disut", "_ddest", "_dsest", "_wut", "_lrc", "_newst", "_dest", "_disrc", "___dut", "___disst", "_disst", "_disdest", "___disut", "_dot", "_newut", "_newrc", "_wrc", "___drc"], "_src": ["_source", "__sys", "__src", " _source", "__sc", "___src", "__rc", "__source", "___rc", " _sys", "___source", " _rc", "_sys", " _sr", "_sr", "___sc", "_sc", "_rc"], "stride": ["stides", "Strope", "strice", "Strade", "stade", "STRice", "STRide", "zice", "Stride", "STRride", " strue", "collue", "strides", "collide", "stope", "Strides", "strope", "collope", "zride", " strope", "strride", "arrride", "arrice", "strade", "zope", "stue", "strue", "stide", "collride", " strides", "STRope", " strride", "arride", "arrope", " strade", "zide"], "i": [" m", "init", "t", "li", "ei", "p", " multi", "sim", "ki", "bi", "ind", "v", "ii", "ini", "id", "d", "mi", "ix", " bi", "me", "it", "ic", "\u0438", " x", "asi", "si", "j", "di", "ie", "ip", "index", "g", " v", "multi", "ui", "iu", "xi", "y", "ij", "zi", "PI", "print", " ti", "ci", "ti", "m", "e", "ai", "pi", "im", "x", "I", "qi", "phi", "c", "n", " ii", "batch"], "dst": ["dracut", "pdsrc", " dstore", "ddest", "dend", "draword", "dddest", "pddest", "Dsrc", "idput", "Dst", " ddest", "dru", "dx", " dct", " dx", "doneword", "idst", "fdstore", "modbsp", "drast", "disru", "Dest", " dsrc", "disdest", " dword", "ddsts", "idx", "drsts", "donelas", "cdsts", "dword", "dport", "modst", "pdST", " dcut", "disst", "donebr", " dend", "dbr", "cdbr", " dput", "discut", "cdbsp", "idstore", "dradest", "fddest", " dest", "donest", "adbr", "dsts", "drasts", "drabr", "dcut", "iddest", "cdput", "dct", "dest", "drgest", "ddst", " dsts", "fdst", "drst", "dput", "pdsts", "cdcheck", "drbsp", "pdst", "adsts", "dST", "dgest", "ddST", "dcheck", "draru", "cdst", " dST", "delst", "DST", "idport", "modsts", "delbr", "delsts", "adend", "fdput", " dru", " dbr", " dcheck", " dlas", "disbsp", "disput", "discheck", "pdest", "adx", " dport", "dsrc", " dbsp", "delbsp", "dralas", "delgest", "adport", "adct", "delend", "idct", "dlas", "dbsp", "adst", "dstore", "cdcut", "modgest"], "src": ["pp", "pkg", "sel", "scan", "sl", "txt", "loc", "cur", "ist", "via", "supp", "sr", "sq", "ctrl", "fp", "iter", "sn", "ripp", "hl", "sur", "sort", "uv", "ptr", "sc", "pack", "dist", "r", "ins", "rl", "filename", "st", "proc", "stock", "stat", "stab", "sb", "seq", "impl", "sys", "load", "rc", "syn", "nil", "sec", "dest", "ctr", "lp", "usc", "func", "cb", "ipl", "bs", "source", "fc", "uint", "np", "comp", "std", "rs", "iv", "rel", "rt", "lib", "ser", "warn", "sup", "ul", "sync", "inst", "req", "attr", "usr", "tp", "rb"]}}
{"project": "FFmpeg", "commit_id": "fbaf75b166cd067cf383a75ffcccb1e2b370bf6d", "target": 1, "func": "static int output_frame(H264Context *h, AVFrame *dst, AVFrame *src)\n\n{\n\n    int i;\n\n    int ret = av_frame_ref(dst, src);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (!h->sps.crop)\n\n        return 0;\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        int hshift = (i > 0) ? h->chroma_x_shift : 0;\n\n        int vshift = (i > 0) ? h->chroma_y_shift : 0;\n\n        int off    = ((h->sps.crop_left >> hshift) << h->pixel_shift) +\n\n            (h->sps.crop_top  >> vshift) * dst->linesize[i];\n\n        dst->data[i] += off;\n\n    }\n\n    return 0;\n\n}\n", "idx": 5908, "substitutes": {"h": ["ph", "hd", "hm", "t", "pp", "kh", "p", "host", "oh", "ih", "ch", "bh", "th", "f", "d", "l", "v", "ec", "H", "r", "hash", "hz", "q", "rh", "k", "self", "he", "j", "comm", "o", "dh", "history", "ht", "hs", "b", "ah", "info", "sh", "g", "http", "rec", "m", "hw", "window", "header", "x", "hh", "hp", "c", "hl", "cache"], "dst": ["dct", "ddest", "dest", "desST", "dend", "sddest", "sdest", "sdend", "hst", "dbl", "desot", "sdst", "dsest", "dsst", "Dbl", " dv", "Dst", " ddest", " dend", "hdest", "stdest", "dST", "hbl", "Dct", " dct", "dv", "desct", " dST", "dot", "Dend", "Dv", "stst", "stest", "DST", " dot", "Ddest", "desst", "Dest", "dsdest", "stend", "Dot", " dest", "hv", "dsend", " dbl"], "src": ["sur", "ur", "rc", "sc", "fr", "ser", "th", "inner", "syn", "dest", "f", "sel", "sec", "v", "r", "it", "inst", "st", "vr", "sr", "in", "bs", "source", "b", "usr", "sq", "sys", "sh", "rs", "sn", "iv", "rel", "conv", "stream", "s", "start", "hl", "rt", "input", "img"], "i": ["key", "p", "id", "l", "ii", "ini", "it", "asi", "hi", "di", "gi", "iq", "y", "ci", "ami", "ik", "qi", "cli", "c", "n", "ei", "r", "ix", "ic", "si", "oi", "j", "ji", "b", "index", "name", "zi", "pi", "x", "phi", "us", "is", "f", "ind", "mi", "gu", "span", "io", "ri", "chain", "ip", "ex", "multi", "e", "ti", "m", "ai", "sequence", "im", "I", "s", "u", "init", "t", "li", "sim", "ki", "bi", "v", "to", "me", "\u0438", "o", "info", "g", "ui", "iu", "xi", "ir", "ij", "status", "jp", "sql", "gl", "batch"]}}
{"project": "qemu", "commit_id": "100f8f26086ad85a9361f2883edd55bc337ce594", "target": 1, "func": "void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)\n\n{\n\n    double units = 1.0;\n\n\n\n    /* if cfg.op_size is defined and smaller than size we compute unit count */\n\n    if (ts->cfg.op_size && size > ts->cfg.op_size) {\n\n        units = (double) size / ts->cfg.op_size;\n\n    }\n\n\n\n    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;\n\n    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;\n\n\n\n    if (is_write) {\n\n        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;\n\n        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;\n\n    } else {\n\n        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;\n\n        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;\n\n    }\n\n}\n", "idx": 5920, "substitutes": {"ts": ["tc", "modules", "t", "Ts", "uts", "ents", "arts", "steps", "ds", "tt", "times", "ms", "types", "atts", "ps", "vs", "ins", "tz", "ics", "ks", "txt", "fts", "inters", "tis", "ss", "asts", "lets", "ports", "outs", "posts", "amps", "tes", "ths", "wt", "lists", "bs", "nuts", "js", "ns", "TS", "mt", "hs", "pots", "sts", "heads", "rs", "gs", "testers", "ties", "tp", "mint", "lbs", "actions", "acs", "vals", "tr", "fs", "its", "cs", "ims", "tm", "parts", "als", "terms", "wcs", "ls", "aps", "ats", "qs", "tl", "eps", "tn"], "is_write": [" is_writer", " is_writ", " is_written", "is_wrote", "isDwrote", "isDwriter", "isDwritten", "is_written", "is_writ", " is_writing", "is_writer", "isDwrite", " is_wrote", "is_writing"], "size": ["assets", "capacity", "small", "total", "Size", "speed", "weight", "use", "news", "dim", "sum", "see", "data", "length", "SIZE", "ize", "sent", "scope", "padding", "address", "send", "words", "options", "set", "style", "any", "export", "city", " sizes", "units", "time", "body", "empty", "space", "chain", "format", "bytes", "index", "memory", "fee", "amount", "password", "g", "ui", "large", "zero", "buffer", "member", "height", "len", "status", "code", "members", "scale", "storage", "unit", "args", "values", "number", "count", "settings", "message", "cache", "sized", "shape", "params"]}}
{"project": "qemu", "commit_id": "e8a095dadb70e2ea6d5169d261920db3747bfa45", "target": 1, "func": "void bdrv_remove_aio_context_notifier(BlockDriverState *bs,\n\n                                      void (*attached_aio_context)(AioContext *,\n\n                                                                   void *),\n\n                                      void (*detach_aio_context)(void *),\n\n                                      void *opaque)\n\n{\n\n    BdrvAioNotifier *ban, *ban_next;\n\n\n\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {\n\n        if (ban->attached_aio_context == attached_aio_context &&\n\n            ban->detach_aio_context   == detach_aio_context   &&\n\n            ban->opaque               == opaque)\n\n        {\n\n            QLIST_REMOVE(ban, list);\n\n            g_free(ban);\n\n\n\n            return;\n\n        }\n\n    }\n\n\n\n    abort();\n\n}\n", "idx": 5931, "substitutes": {"bs": ["os", "bn", "bos", "bps", "ds", "bh", "bi", "bm", "aus", "ms", "blog", "vs", "bas", "ss", "bles", "ns", "bytes", "b", "bb", "BS", "pb", "bl", "gs", "ts", "lbs", "acs", "bits", "fs", "its", "bis", "bp", "cs", "base", "sb", "bf", "ls", "s", "ats", "bc", "bd"], "attached_aio_context": ["attached_aive_text", "attached_aive_config", "attached_aio_data", "attached_aio_config", "attached_aio_content", "attached_aive_context", "attached_aio_case", "attached_ai_path", "attached_ai_text", "attached_aio_name", "attached_aio_path", "attached_aive_content", "attached_aio_text", "attached_ai_context", "attached_ai_case"], "detach_aio_context": ["detach_aive_config", "detach_aios_context", "detach_aios_Context", "detach_aive_history", "detach_aios_text", "detach_aio_text", "detach_aios_config", "detach_aio_config", "detach_aive_system", "detach_aive_text", "detach_aio_history", "detach_aio_connection", "detach_aive_context", "detach_aive_connection", "detach_aio_system", "detach_aio_Context"], "opaque": ["opience", "operacity", "ompacity", "opunct", "ipacity", "operatile", "ipaque", "ompaques", "opaques", "paque", "ipience", " opaques", "opsatile", "pience", "operaques", "opsaque", "opsacity", "opsaques", "opatile", "ompaque", "paques", "operaque", "ipatile", "ipaques", "ipunct", "punct", " opunct", "opacity", " opacity", "ompience", "pacity"], "ban": ["Ban", "ain", "wan", "bn", "kan", "ank", "cast", "warn", "pai", "raf", "card", "news", "van", "ang", "AN", "scan", "bug", "brush", "pas", "gray", "alias", "gate", "span", " Ban", "uan", "ann", "istan", "annot", "isen", "gan", "an", "dan", "stan", "anned", "icon", "vote", "bang", "bean", "tag", "wid", "can", "cam", "awan", "pin", "anan", "fan", "iban", "plan", "san", "bank", "ram", "var", "iron", "irm", "forth", "avan", "auth", "bin", "rain", "plain", "broad", "ran", "man", "pan", "batch"], "ban_next": ["ban_data", "iban_prev", "fan__prev", "iban_next", "fan_next", "iban_data", "fan__next", "fan__first", "ban__ne", "ban_ne", "ban_first", "fan__ne", "ban__prev", "fan_prev", "ban__next", "ban__first", "fan_first", "ban_prev", "fan_ne"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)\n\n{\n\n    TCGv_i64 tmp;\n\n    TCGv tmp2;\n\n\n\n    /* Load value and extend to 64 bits.  */\n\n    tmp = tcg_temp_new_i64();\n\n    tmp2 = load_reg(s, rlow);\n\n    tcg_gen_extu_i32_i64(tmp, tmp2);\n\n    dead_tmp(tmp2);\n\n    tcg_gen_add_i64(val, val, tmp);\n\n    tcg_temp_free_i64(tmp);\n\n}\n", "idx": 5962, "substitutes": {"s": ["sc", "t", "os", "S", "p", "ess", "ds", "is", "a", "v", "r", "ps", "ctx", "spec", "ysis", "less", "ss", "h", "js", "ns", "hs", "b", "sq", "g", "ses", "scl", "sg", "rs", "gs", "ts", "es", "xs", "fs", "sb", "c", "as", "ls", "sys"], "val": ["key", "VAL", "p", "alpha", "el", "eval", " eval", "v", "l", "ind", "data", "ctx", "it", "z", "serv", "valid", "u", "pt", "ret", "bal", "mem", " aval", "b", "err", " value", "pol", " v", "pr", "ref", "m", "vals", "ival", "vec", "test", "pl", "x", "tx", "item", "cal", "vol", "al", "sol", "vt", "value", "reg", "Val", "aval"], "rlow": ["rxlow", "Rhard", " rlight", "mrLow", "rtLow", "mrlev", " rLow", "rlight", "rlower", "rorhard", "Rlower", "rxlev", "rLow", "rorlow", "RLow", "rtlower", "rlev", "mrlight", "rhard", "Rlow", "rtlow", "rthard", "rorlower", "rorLow", "rxLow", "mrlow", "rxlight", " rlev"], "tmp": ["py", "ptr", "gm", "gz", "t", " prob", "p", "emp", " mut", "cp", "tv", "copy", "pkg", "cv", "temp", "tt", "mk", "v", "sp", " np", "nt", "ctx", "nom", " junk", "mp", " ind", " ptr", "tar", "obj", "txt", "cb", "cur", "pro", "buff", "Buff", "np", "appy", "resp", "orig", "buf", "mb", "zero", "gb", "zip", " pts", "cmp", " td", "xy", "perm", "mint", "jp", " temp", "mm", "tn", "etc", " mp", "Temp", "snap", "pl", "test", "uf", "tm", "rt", "aaa", " t", "tu", "img", " sp", "uv"], "tmp2": ["stage1", "stage02", "pb02", "cache2", " tmp3", " tmp1", "mp3", "pbtwo", "jp02", " tmptwo", "tmp1", "jp1", "temp3", "mp2", "temp4", " tmp02", "pb2", "tmp3", " tmp4", "mptwo", "cache02", "jptwo", "obj02", "temp1", "tmptwo", "stage2", "obj1", "obj3", "mp02", "temp2", "obj2", "tmp4", "stagetwo", "jp2", "mp4", "pb3", "cachetwo", "mp1", "cache3", "tmp02"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_bmdma_simple_rw(void)\n\n{\n\n    QPCIDevice *dev;\n\n    void *bmdma_base, *ide_base;\n\n    uint8_t status;\n\n    uint8_t *buf;\n\n    uint8_t *cmpbuf;\n\n    size_t len = 512;\n\n    uintptr_t guest_buf = guest_alloc(guest_malloc, len);\n\n\n\n    PrdtEntry prdt[] = {\n\n        {\n\n            .addr = cpu_to_le32(guest_buf),\n\n            .size = cpu_to_le32(len | PRDT_EOT),\n\n        },\n\n    };\n\n\n\n    dev = get_pci_device(&bmdma_base, &ide_base);\n\n\n\n    buf = g_malloc(len);\n\n    cmpbuf = g_malloc(len);\n\n\n\n    /* Write 0x55 pattern to sector 0 */\n\n    memset(buf, 0x55, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 0, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Write 0xaa pattern to sector 1 */\n\n    memset(buf, 0xaa, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Read and verify 0x55 pattern in sector 0 */\n\n    memset(cmpbuf, 0x55, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 0, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n    /* Read and verify 0xaa pattern in sector 1 */\n\n    memset(cmpbuf, 0xaa, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 1, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n\n\n    g_free(buf);\n\n    g_free(cmpbuf);\n\n}\n", "idx": 5963, "substitutes": {"dev": ["doc", "den", "de", "disk", "ds", "conn", "priv", "d", "v", "van", "nt", "data", "app", "hid", "spec", "Dev", "Device", "ad", "scan", "dd", "gu", "serv", "obj", "w", "en", "di", "ve", "adv", "device", "pad", "eng", "sd", "link", "mem", "def", "DEV", "ver", "sh", "md", "stick", "serial", "develop", "cam", "tr", "hw", "dis", "env", "tech", "des", "vol", "sys", "go", "ev", "av", "cmd", "dem"], "bmdma_base": ["bmdma_ref", "bmdpe_base", "bmdme__base", "bmdma_file", "bmdma__ref", "bmdme__ref", "bmdma_bin", "bmdma__file", "bmdme__file", "bmdma_Base", "bmdpe_ref", "bmdme__Base", "bmdma_cache", "bmdme_ref", "bmdma__Base", "bmdpe_bin", "bmdme_file", "bmdpe_cache", "bmdma__base", "bmdme_base", "bmdme_Base"], "ide_base": ["ineAbal", "ide_balance", "ideAbase", "iden_state", "ine_bal", " ide_store", "ideAbasic", "ide_bas", "ine_balance", "ide___state", "ide_prefix", "ide_label", "ke_label", "iden___base", "iden___balance", "hide_bal", " ide_ase", "ide_type", "hide_bas", "ineAbase", "ide_file", "iden_base", "ide_state", "ineAbalance", "ide5bal", "ide1base", "ide0bas", "hide_prefix", "ide1basic", "iden___file", "hide_base", "ide1bal", "ideAbalance", "ke_type", "ine_base", "iden_file", "ide_bal", "ine_basic", "ineAbasic", "ideAbal", "ide___base", "iden___state", "ide_store", "ke_base", " ide_bas", "ide5balance", "ide0base", "ide0store", "ide_basic", "ide_ase", "ide5basic", "ide5base", "iden_balance", "ide0ase", "ide___file", "ide1balance", "ide___balance"], "status": ["flags", "sex", "git", "sc", "access", "dr", "atus", "compl", "sim", "ser", "syn", "speed", "details", "success", "progress", "id", "ms", "score", "spec", "wait", "list", "error", "ping", "Status", "msg", "check", "sync", "prefix", "str", "login", "version", "si", "valid", "gc", "reason", "size", "format", "STAT", "confirmed", "result", "state", "resp", "name", "ssl", "info", "comment", "act", "type", "stat", "stats", "res", "uses", " Status", "scale", "service", "flag", "summary", "cli", "vis", "notice", "sys", "wrapper", "err", "sw"], "buf": ["gz", "doc", "lim", "vp", "cp", "pkg", "cv", "tmp", "ctr", "fac", "func", "data", "ctx", "norm", "msg", "map", "cb", "Buffer", "txt", "loc", "obj", "cur", "str", "aka", "br", "buff", "Buff", "size", "mem", "bytes", "b", "def", "bl", "cap", "ref", "buffer", "len", "alloc", "cam", "db", "stat", "vec", "tr", "window", "uf", "var", "bc", "desc", "seq", "queue", "bin", "rain", "broad", "block", "cache", "rb", "img", "cmd", "wb", "batch"], "cmpbuf": ["ctxdata", "cmpdata", "compuf", "permbuffer", "mpdata", "compdata", "cmpmsg", "mpbuff", "txtmsg", "colldata", "ctxbuf", "ctxuf", "collbuff", "compbuf", "cmpuf", "permbuf", "permdata", "txtbuf", "txtbuffer", "compbuff", "mpbuffer", "permbuff", "compmsg", "txtbuff", "cmpbuffer", "mpmsg", "compbuffer", "collbuf", "cmpbuff", "mpbuf", "ctxbuff", "colluf"], "prdt": ["drtd", " prti", "prdet", "perdt", " prdj", " prdh", "sprdet", "krDT", "prtp", " prtz", "predt", "privdt", "perdet", "PRtp", "perdl", " prmt", "drti", "permt", "Prtg", "perds", "prtg", "prtd", "prcmd", "krdt", " prdet", "drds", "PRti", "predj", " prds", "poldf", "prds", "drdt", " prtd", "prtz", " prtp", "Prtp", "sprdl", "prti", "prDT", "prmt", "sprdf", "PRds", "sprtz", "privtp", "poldt", "prdl", "prdh", "Prds", "polds", "sprdt", "sprdh", "PRtg", " prtk", "poldh", "prtk", "pulldet", "poldl", "pullmt", "krtp", "Prtz", "poldet", "krtg", "pretp", "privdj", "sprcmd", "Prdt", "sprds", "pretk", "Prcmd", "prdf", "PRdt", " prdl", "PRDT", "prdj", " prcmd", "PrDT", "privtk", "pulldt", "PRtd", "pulldl", " prdf"]}}
{"project": "FFmpeg", "commit_id": "33f58c3616d2870d3861da68217ef9d05cc5047a", "target": 1, "func": "static int idcin_read_packet(AVFormatContext *s,\n\n                             AVPacket *pkt)\n\n{\n\n    int ret;\n\n    unsigned int command;\n\n    unsigned int chunk_size;\n\n    IdcinDemuxContext *idcin = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int i;\n\n    int palette_scale;\n\n    unsigned char r, g, b;\n\n    unsigned char palette_buffer[768];\n\n    uint32_t palette[256];\n\n\n\n    if (s->pb->eof_reached)\n\n        return AVERROR(EIO);\n\n\n\n    if (idcin->next_chunk_is_video) {\n\n        command = avio_rl32(pb);\n\n        if (command == 2) {\n\n            return AVERROR(EIO);\n\n        } else if (command == 1) {\n\n            /* trigger a palette change */\n\n            if (avio_read(pb, palette_buffer, 768) != 768)\n\n                return AVERROR(EIO);\n\n            /* scale the palette as necessary */\n\n            palette_scale = 2;\n\n            for (i = 0; i < 768; i++)\n\n                if (palette_buffer[i] > 63) {\n\n                    palette_scale = 0;\n\n                    break;\n\n\n\n\n            for (i = 0; i < 256; i++) {\n\n                r = palette_buffer[i * 3    ] << palette_scale;\n\n                g = palette_buffer[i * 3 + 1] << palette_scale;\n\n                b = palette_buffer[i * 3 + 2] << palette_scale;\n\n                palette[i] = (r << 16) | (g << 8) | (b);\n\n\n\n\n\n        chunk_size = avio_rl32(pb);\n\n\n\n\n\n        /* skip the number of decoded bytes (always equal to width * height) */\n\n        avio_skip(pb, 4);\n\n        chunk_size -= 4;\n\n        ret= av_get_packet(pb, pkt, chunk_size);\n\n        if (ret < 0)\n\n            return ret;\n\n        if (command == 1) {\n\n            uint8_t *pal;\n\n\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n\n                                          AVPALETTE_SIZE);\n\n            if (ret < 0)\n\n                return ret;\n\n            memcpy(pal, palette, AVPALETTE_SIZE);\n\n            pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n        pkt->stream_index = idcin->video_stream_index;\n\n        pkt->duration     = 1;\n\n    } else {\n\n        /* send out the audio chunk */\n\n        if (idcin->current_audio_chunk)\n\n            chunk_size = idcin->audio_chunk_size2;\n\n        else\n\n            chunk_size = idcin->audio_chunk_size1;\n\n        ret= av_get_packet(pb, pkt, chunk_size);\n\n        if (ret < 0)\n\n            return ret;\n\n        pkt->stream_index = idcin->audio_stream_index;\n\n        pkt->duration     = chunk_size / idcin->block_align;\n\n\n\n        idcin->current_audio_chunk ^= 1;\n\n\n\n\n    if (idcin->audio_present)\n\n        idcin->next_chunk_is_video ^= 1;\n\n\n\n    return ret;\n", "idx": 5965, "substitutes": {"s": ["t", "os", "p", "S", "conf", "sports", "ds", "f", "a", "v", "ps", "spec", "vs", "ins", "w", "less", "set", "ss", "aws", "bs", "js", "ns", "ex", "hs", "sq", "sys", "ses", "sts", "sg", "gs", "ts", "e", "stats", "m", "fs", "its", "sv", "cs", "sb", "c", "parts", "ls", "n", "ats", "local", "qs", "sw"], "pkt": ["prokg", "pet", "fkg", "pcnt", "tmsg", "compacket", "npacket", "pkg", "prokt", "cpwd", "wet", "pqt", "proacket", " pnt", "fmsg", " pvt", "wacket", "compnt", "wwd", "compkt", "pcvt", "npnt", "npkt", " pwd", "cpnt", "pnt", "fkt", "ppqt", " pkg", "pwd", "cpvt", "pcacket", "tacket", "cpacket", "npqt", "compkg", "packet", "ppkt", " pet", "pckt", "pmsg", "wkt", "facket", " pqt", "tnt", "tkg", "cpet", "cpkt", "cpmsg", " pmsg", "pvt", "ppacket", "ppnt", "promsg", " packet", "tkt"], "ret": ["fail", "t", "conf", "elt", "reset", "gt", "inter", "RET", "v", "cat", "att", "nt", "re", "not", "Ret", "it", "ft", "error", "Return", "rets", "cert", "val", "ry", "complete", "rem", "mem", "mt", "result", "resp", "def", "err", "pret", "lag", "over", "net", "response", "rev", "ber", "ref", "len", "iter", "print", "status", "rect", "res", "det", "after", "report", "tr", "ter", "flag", "summary", "try", "reg", "rt", "back", "alt", "reply", "magic", "value", "out", "run"], "command": ["function", "request", "capacity", "key", "commit", "button", "controller", "handler", "volume", "which", "argument", "direction", "menu", "channel", "component", "condition", "position", "call", "Command", "duration", "minute", "frequency", "version", "method", "description", "power", "requisite", "comm", "option", "attribute", "communication", "format", "confirmed", "history", "name", "slave", "shift", "comment", "definition", "password", "timeout", "type", "operation", "example", "buffer", "category", "code", "height", "process", "rank", "sequence", "distance", "count", "mode", "magic", "message", "directory", "context", "execute", "cmd", "event", "action"], "chunk_size": ["chunk_scale", "chunk_count", "chunkitySize", "chunklenSize", "chrawityshare", "chunklenspeed", "chunkingSIZE", "chunkitysize", "chunk_share", "chunk_speed", "chraw_share", "chraw_member", "chunkedscale", "chunktsize", "chunk_Size", "chunktSize", "chunklenindex", "chunktmember", "chunk_member", "chunktshare", "chunkitymember", "chraw_Size", "chrawitysize", "chrawitySize", "chunkingscale", "chunk_SIZE", "chunkityshare", "chrawitymember", "chunkedSIZE", "chunklensize", "chunk_index", "chunkingsize", "chraw_size", "chunkedsize"], "idcin": [" idcoin", " idgin", "idgin", "Idcoin", "adcin", "idsin", "midcin", "Idcin", "midci", "Idsin", " idci", "Idtin", "Idgin", "adgin", "kindci", "Idvin", "midvin", "kindcin", "Idci", "idtin", " idsin", " idtin", "idvin", "adci", "kindcoin", "kindvin", "adtin", "idcoin", "midsin", " idvin", "idci"], "pb": ["tc", "py", "sc", "vp", "pp", "cp", "p", "pkg", "td", "cv", "bj", "nb", "lp", "ab", "PB", "ctx", "pc", "fb", "mp", "ping", "pg", "typ", "tap", "wp", "cb", "obj", "pm", "ub", "pa", "prot", "pt", "px", "bs", "proc", "np", "bb", "iov", "emb", "resp", "buf", "mb", "buffer", "fp", "tp", "dp", "jp", "pool", "um", "db", "tg", "bp", "eb", "snap", "pl", "uf", "sb", "tx", "ob", "tk", "sys", "rb", "pan", "oa", "wb", "uv"], "i": ["key", "p", "id", "l", "ii", "ini", "it", "k", "di", "gi", "iq", "slice", "y", "ci", "ami", "ims", "qi", "cli", "n", "z", " ii", "ei", "progress", "ix", "ic", "si", "oi", "j", "ji", "index", "name", "zi", "this", "try", "pi", "x", "phi", "ia", "is", "f", "ind", "mi", "span", "io", "ri", "chain", "ip", "ex", "point", "multi", "print", "ti", "m", "ai", "I", "init", "dr", "li", "sim", "ki", "bi", "v", "me", "\u0438", "uri", "set", "in", "info", "ui", "iu", "xi", "ij", "status", "um", "client", "batch"], "palette_scale": ["paletteingsort", "palaxy_scale", "palette_step", "palant_shape", "palalo_sort", "palettePscale", "palalo_fail", "palettePsort", "palendix_color", "palendix_stroke", "palette____scale", "palalo_spec", "paletteingsync", "palette_tile", "palaloPspec", "palette13color", "palaloPsort", "palette_pad", "palette13step", "palaxy_pad", "palettePfail", "palendix____color", "palant_scale", "palendix____step", "palettePspec", "palette_stroke", "palalo_scale", "palette_shape", "palendix_scale", "palettes_scale", "paletteingtile", "palettes_size", "palaxy_radius", "palaloPscale", "palendix_step", "paletteingsize", "palette_size", "palette_shift", "palette_scan", "palette_radius", "palette____step", "palette_Scale", "palette_color", "palette_sort", "palaloPfail", "palette_spec", "palaxy_scan", "palette_store", "palette13stroke", "palant_Scale", "palendix____scale", "paletteingspec", "palette13scale", "paletteingscale", "palette_sync", "palette_fail", "paletteingfail", "palette____color", "palettes_store", "palant_shift", "palendix____stroke", "palette____stroke"], "r": ["rc", "dr", "t", "p", "f", "a", "d", "l", "\u0440", "lr", "R", "re", "rate", "rr", "rl", "vr", "sr", "ri", "cr", "rg", "rx", "rs", "rf", "rar", "ar", "e", "m", "rd", "tr", "x", "c", "gr", "ro", "n", "rt", "rb", "u", "mr"], "g": ["gm", "fg", "gt", "a", "d", "l", "v", "green", "pg", "gu", "ger", "gray", "ga", "groups", "j", "gi", "gc", "ge", "gy", "gd", "gio", "group", "rg", "gen", "gb", "G", "gs", "bg", "m", "tg", "gg", "gp", "gam", "gold", "gr", "c", "gre", "gin", "go", "u"], "b": ["t", "p", "nb", "bi", "f", "a", "d", "l", "v", "fb", "bas", "cb", "j", "h", "br", "o", "bs", "B", "bb", "beta", "gb", "ib", "ba", "y", "db", "bg", "m", "base", "sb", "c", "bin", "n", "z", "rb", "u", "bc", "be"], "palette_buffer": ["palet_buffer", "palette5buf", "palette_buff", "palette67match", "palette_width", "palette67database", "palette67iter", "palette5iter", "palette0buffer", "palette67server", "palet_iter", "pallete_buf", "palellow_match", "palette_buf", "palette67buffer", "pallete_buff", "palette_iter", "palellow_store", "palellow_iter", "palette0Buffer", "palet_buf", "palellow_buffer", "palette_database", "palette_index", "palette67Buffer", "palette_Buffer", "pallete_database", "palette_store", "palette5width", "palet_width", "palette0server", "palette_match", "palellow_database", "pallete_buffer", "palette_server", "palette5buffer", "palellow_Buffer", "palellow_server", "palette67store", "palette0store"], "palette": [" pallette", "colte", "colgon", "alilette", "chette", "Palet", " palettes", "lette", "aliettes", "palue", "Palette", "palett", "lettes", "colette", "llette", "palet", "chte", "Palue", "lue", "palgon", "polgon", "aliette", "polett", "colett", "Palettes", " palue", "palte", "chett", "chgon", " palet", "aliet", "polte", "polette", "palettes", "Pallette", "pallette"], "pal": ["ph", "font", "pp", "p", "el", "bat", "sel", "fac", "arr", "att", "col", "pixel", "quant", "ele", "ul", "sam", "Pal", "flat", "val", "isal", "pro", "ell", " Pal", "ass", "buff", "dat", "bal", "cell", "mem", "pol", "bl", "buffer", "mel", "pat", "local", "apple", "table", "pl", "gr", "bin", "cal", "cel", "pod", "pac", "phil", "al", "vol", "sal", "nl", "cache", "batch"]}}
{"project": "FFmpeg", "commit_id": "009f829dde811af654af7110326aea3a72c05d5e", "target": 1, "func": "static inline void RENAME(yuv2rgb555_2)(SwsContext *c, const uint16_t *buf0,\n\n                                        const uint16_t *buf1, const uint16_t *ubuf0,\n\n                                        const uint16_t *ubuf1, const uint16_t *vbuf0,\n\n                                        const uint16_t *vbuf1, const uint16_t *abuf0,\n\n                                        const uint16_t *abuf1, uint8_t *dest,\n\n                                        int dstW, int yalpha, int uvalpha, int y)\n\n{\n\n    x86_reg uv_off = c->uv_off << 1;\n\n\n\n    //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(\n\n    __asm__ volatile(\n\n        \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n        \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n        \"push %%\"REG_BP\"                        \\n\\t\"\n\n        YSCALEYUV2RGB(%%REGBP, %5, %6)\n\n        \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n        /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */\n\n#ifdef DITHER1XBPP\n\n        \"paddusb \"BLUE_DITHER\"(%5), %%mm2      \\n\\t\"\n\n        \"paddusb \"GREEN_DITHER\"(%5), %%mm4      \\n\\t\"\n\n        \"paddusb \"RED_DITHER\"(%5), %%mm5      \\n\\t\"\n\n#endif\n\n        WRITERGB15(%%REGb, 8280(%5), %%REGBP)\n\n        \"pop %%\"REG_BP\"                         \\n\\t\"\n\n        \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n        :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n           \"a\" (&c->redDither), \"m\"(uv_off)\n\n    );\n\n}\n", "idx": 5981, "substitutes": {"c": ["tc", "rc", "t", "cm", "cp", "p", "co", "conf", "ch", "cv", "f", "d", "l", "v", "ec", "lc", "ctx", "cont", "dc", "C", "con", "cb", "cc", "h", "fc", "b", "g", "cf", "e", "ci", "ca", "ce", "cs", "ct", "ac", "s", "n", "bc"], "buf0": ["bu00", "queuezero", "uf0", "uf2", "batch000", "batch1", "uf00", "queue0", "uf000", "bu1", "buffer000", "buffer2", "batch2", "bufzero", "ufzero", "buf2", "buf000", "uf1", "queue1", "buffer0", "buffer1", "queue00", "batch0", "buzero", "bu0", "buf00"], "buf1": ["buffer01", "vec2", "buff1", "buf10", "vec0", "uf0", "uf2", "buffer10", "buf01", "buffer2", "buff2", "uf01", "buff0", "buf2", "vec01", "buff10", "vec1", "uf1", "uf10", "buffer0", "buffer1"], "ubuf0": ["umbuf0", "ubbuf000", "abbuf0", "ublim1", "umuf0", "ubuf000", "ubbuf2", "ubimg00", "ubf1", "ubuffer1", "ubimg1", "ublim0", "ubuffer0", "ubbuf8", "ublim8", "ubimg2", "ubuf8", "ublim000", "umbuf8", "ubuffer8", "ubuffer000", "ubf00", "abuf2", "ubbuf00", "umbuf000", "umuf8", "abuf00", "umuf1", "ubuf00", "abbuf2", "ubuf2", "ubbuf0", "abbuf00", "ubbuf1", "ubimg0", "ubf0", "abbuf1", "umbuf1", "umuf000", "ubf2"], "ubuf1": ["umbuf0", "ubbuf2", "abbuf0", "umuf0", "ubbuff0", "ubtxt0", "umufOne", "ubbuffOne", "ubbuf8", "ubbuff1", "ublf2", "ubuf8", "ubuff2", "umbuf8", "ubuff1", "abuf2", "ubtxtOne", "ubuff8", "ubuff0", "ubufOne", "umuf8", "umuf1", "ubbuff8", "ublf0", "abbuf2", "umbufOne", "ublf8", "ubbufOne", "ubuf2", "abuf8", "ubbuf0", "ubbuf1", "ublf1", "ubtxt8", "abbuf1", "umbuf1", "abbuf8", "ubtxt1"], "vbuf0": ["vuf2", "vbuffer0", "fuf0", "fbuf0", "fuf1", "fbuf2", "fuf2", "fbuf1", "vbuff2", "vbuffer2", "vbuf2", "vbuffer1", "vuf0", "vbuff0", "vuf1", "vbuff1"], "vbuf1": ["vbuffer8", "vuf2", "vbuffer0", "fuf0", "fbuf0", "fuf1", "fbuf2", "fuf2", "fbuf8", "fbuf1", "vbuf8", "vbuff2", "fuf8", "vuf8", "vbuffer2", "vbuf2", "vbuffer1", "vuf0", "vbuff8", "vbuff0", "vuf1", "vbuff1"], "abuf0": ["ubbuf2", "abbuf0", "ubbuf5", "abff0", "abimg2", "ubuf5", "abimg1", "abff5", "abuf5", "abuf2", "abimg0", "abff2", "abbuf2", "ubuf2", "ubbuf0", "ubbuf1", "abbuf5", "abff1", "abbuf1", "abimg5"], "abuf1": ["ubbuf2", "abbuf0", "abbuff1", "abuff2", "abbuff8", "abuff8", "ubbuf8", "ubuf8", "abuff0", "abuf2", "abbuf2", "ubuf2", "abuf8", "abuff1", "abbuff2", "ubbuf0", "ubbuf1", "abbuff0", "abbuf1", "abbuf8"], "dest": ["ptr", "master", "tmp", "temp", "origin", "dist", "sp", "spec", "path", "dc", "obj", "w", "loc", "trans", "self", "port", "st", "output", "source", "mem", "result", "usr", "est", "slave", "orig", "ref", "tip", "rest", "target", "iter", "end", "tr", "window", "desc", "src", "Dest", "out"], "dstW": ["destU", "destA", "dostN", "dstU", "DestN", "DstU", "ddestU", "dstN", "dostW", "ddestW", "dstA", "destW", "DestW", "destN", "DstW", "DstN", "DstA", "DestA", "DestU", "ddestN", "dostU", "dostA", "ddestA"], "yalpha": ["yyma", "Ybeta", "xalpha", "yybeta", "yma", "Yma", "Yalpha", "xma", "yrc", "Yrc", "xbeta", "ybeta", "yyalpha", "xrc", "yyrc"], "uvalpha": ["upllambda", "uirelpi", "uplpi", "urelho", "uplpha", "uivalpha", "uirelho", "urelpha", "uirellambda", "urelpi", "uwlpi", "urellambda", "uwlho", "uvalho", "uivalpi", "uplho", "uvalpi", "uivalho", "uwlpha", "uwllambda", "uvallambda", "uirelpha", "uivallambda"], "y": ["py", "t", "yi", "p", "ch", "dy", "ty", "ym", "ry", "ys", "gy", "i", "b", "Y", "sy", "iny", "ny", "ly", "cy", "xy", "ay", "yp", "iy", "oy", "yd", "x", "yy", "vy"]}}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)\n\n{\n\n    VirtIOBlockReq *req = virtio_blk_alloc_request(s);\n\n\n\n    if (!virtqueue_pop(s->vq, &req->elem)) {\n\n        virtio_blk_free_request(req);\n\n        return NULL;\n\n    }\n\n\n\n    return req;\n\n}\n", "idx": 6007, "substitutes": {"s": ["os", "S", "p", "ds", "is", "v", "ares", "ps", "spec", "ins", "ies", "z", "sl", "less", "set", "ss", "j", "h", "bs", "js", "ns", "hs", "b", "sq", "ses", "sts", "rs", "gs", "y", "ts", "es", "fs", "its", "bis", "cs", "ims", "als", "c", "ls", "qs", "sys", "sol"], "req": ["request", "fr", "out", "p", "pkg", "qq", "grab", "ind", " rap", "require", "circ", "r", "ps", " q", "rr", "q", "msg", "required", "obj", "txt", "ext", "crit", " requisite", "dq", "good", "j", "needed", "rem", "iq", "resp", "requ", "err", "sq", "rx", " requ", "comp", "buf", "low", "ref", "alloc", "tek", "jp", "res", "quest", " res", "qa", "desc", " reg", "seq", "tx", "qt", " resp", "ack", "urg", "ev", "reg", "cmd"]}}
{"project": "FFmpeg", "commit_id": "f7a02d5d694bcef993b0229c9e57f22421fed637", "target": 0, "func": "static int output_packet(InputStream *ist, const AVPacket *pkt)\n\n{\n\n    int ret = 0, i;\n\n    int got_output;\n\n\n\n    AVPacket avpkt;\n\n    if (!ist->saw_first_ts) {\n\n        ist->dts = ist->st->avg_frame_rate.num ? - ist->st->codec->has_b_frames * AV_TIME_BASE / av_q2d(ist->st->avg_frame_rate) : 0;\n\n        ist->pts = 0;\n\n        if (pkt != NULL && pkt->pts != AV_NOPTS_VALUE && !ist->decoding_needed) {\n\n            ist->dts += av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n\n            ist->pts = ist->dts; //unused but better to set it to a value thats not totally wrong\n\n        }\n\n        ist->saw_first_ts = 1;\n\n    }\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->dts;\n\n    if (ist->next_pts == AV_NOPTS_VALUE)\n\n        ist->next_pts = ist->pts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE) {\n\n        ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n        if (ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)\n\n            ist->next_pts = ist->pts = ist->dts;\n\n    }\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int duration;\n\n    handle_eof:\n\n\n\n        ist->pts = ist->next_pts;\n\n        ist->dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = decode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = decode_video    (ist, &avpkt, &got_output);\n\n            if (avpkt.duration) {\n\n                duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0 && ist->st->codec->time_base.den != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                duration = ((int64_t)AV_TIME_BASE *\n\n                                ist->st->codec->time_base.num * ticks) /\n\n                                ist->st->codec->time_base.den;\n\n            } else\n\n                duration = 0;\n\n\n\n            if(ist->dts != AV_NOPTS_VALUE && duration) {\n\n                ist->next_dts += duration;\n\n            }else\n\n                ist->next_dts = AV_NOPTS_VALUE;\n\n\n\n            if (got_output)\n\n                ist->next_pts += duration; //FIXME the duration is not correct in some cases\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        avpkt.dts=\n\n        avpkt.pts= AV_NOPTS_VALUE;\n\n\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            if(ist->st->codec->codec_type != AVMEDIA_TYPE_AUDIO)\n\n                ret = avpkt.size;\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        rate_emu_sleep(ist);\n\n        ist->dts = ist->next_dts;\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n\n                             ist->st->codec->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (pkt->duration) {\n\n                ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->st->codec->time_base.num * ticks) /\n\n                                  ist->st->codec->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n        ist->pts = ist->dts;\n\n        ist->next_pts = ist->next_dts;\n\n    }\n\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6008, "substitutes": {"ist": ["tif", "et", "art", "iop", "artist", "wikipedia", "empt", "tml", "isted", "wp", "supp", "each", "pt", "wd", "ister", "ous", "esp", "its", "ik", "hl", "ace", "irst", "htt", "work", "dist", "pop", "list", "pas", "alist", "edit", "ief", "st", "iste", "isi", "xt", "iest", "ht", "pect", "sts", "tip", "gest", "ort", "ert", "iz", "feat", "ush", "express", "sys", "ict", "assert", "reat", "pir", "ift", "is", "ista", "ind", "istar", "elist", "exist", "istically", "ism", "ive", "ld", "port", "oad", "dit", "istor", "est", "ick", "hist", "rank", "iat", "irm", "isting", "IST", "eh", "ust", "ess", "ists", "iana", "istant", "ont", "spect", "inst", "ire", "ast", "ilst", "lect", "usr", "il", "meet", "ird", "ij", "erd", "rit", "xp"], "pkt": ["pdu", "npacket", "pkg", "Packet", "pct", "patchkg", "patchwt", "Pwk", "apacket", "compkt", "paycht", " pkg", "p_", "prkt", "pracket", "pto", "postkg", "pp_", "ppto", "dnt", "pb_", " pvc", "cpkt", "pacht", "tkt", "cpwk", "apwt", "apkt", "Pkg", "pmt", "ppwk", "cacket", "cpnt", "patchkt", "paynt", "cpct", "cpacket", "dkt", " pwt", "dacket", " pqt", "postdu", "npwk", " packet", "Pdu", "compacket", "compvc", "pbto", "apett", "apkg", "patchacket", "apmt", "prett", "pqt", "dqt", "prmt", "pett", "ckt", "pcht", "pvc", "npkt", "pnt", " pwk", "tacket", "cpqt", " punct", "postkt", "packet", "tnt", "cnt", "ppacket", "cvc", "twk", "Punct", " pto", " pct", "Pct", " pnt", "npett", "compnt", "payacket", "npunct", "npmt", "pwt", "paacket", "Pkt", " pcht", "pakt", "pwk", "postwk", "ppkt", "pant", "punct", "paykt", " pdu", "ppnt", " p_"], "i": ["ia", "t", "li", "p", "fi", "bi", "f", "v", "ii", "mi", "ix", "si", "j", "b", "index", "il", "g", "iu", "ij", "ti", "m", "pi", "im", "x", "I", "c", "n"], "got_output": ["got___message", "need_output", " got_wrong", "gotfuldata", "got___console", "gotfuloutput", "got_Output", "need_console", "got_wrong", "need_message", "got_exit", " got_exit", "got_message", " got_Output", "need_data", "got_console", "gotfulconsole", "got_data", "got___output", "gotfulmessage", "got___data"], "avpkt": ["avopcmd", "avptt", "vrpacket", "avjptx", "avnpelt", "avphpmsg", "avopdat", "aveopkw", "avparwk", "avwpacket", "avnpcmd", "vrparacket", "avopwk", "avpakat", " avnpkg", "avmkt", "AVpct", "rootlikekt", "avptx", "avepet", "avnpdt", "ovpeet", "avpcmd", "rootpdat", "avipdt", "avenpkt", "avjpmsg", "avpacmd", "avnpvt", "ovpett", "avenpelt", " avnpwk", "aveptt", "avoptx", "avpagt", "avnpwk", "avmelt", "avepelt", "avgwk", "avgkg", "avphpkt", "avpaelt", "rootpkat", "avpelt", "AVnpwk", "avpdt", "avopvt", "avphptx", "avnpct", "aveptx", "ovpekt", "avpgt", "AVnpkt", "avpakt", "avpdat", "aveopmsg", "avwptt", "avapkt", "avtpdt", "aveoptx", "avpett", "avPwk", "avipwk", "avPkt", "avwpwk", "avgkt", "avmcmd", "ovpkt", "rootlikecmd", " avnpdt", "avepacket", "avpekt", "avewpacket", "avepgt", "avpkg", "vrpdt", "avopct", "avPct", "rootlikekat", "avepkw", "avPvt", " avpwk", "avpct", "AVnpct", "avapacket", "AVnpvt", "avepkt", "avepmsg", "avaptt", "avtpkt", "avlikekt", "avjpkt", "avewpkt", "avepcmd", "avpkat", "avPett", "avapgt", "avlikecmd", "aveopkt", "avpatt", "avpeett", " avnpkt", "avpeet", "avpect", "avnpkt", "ovpet", "avewptt", "avphpkw", "vrpwk", "avlikedat", "avpaet", "avwpkg", "avenpet", "avpmsg", "avpacket", "avtpwk", "avopkt", "vrparwk", "rootpkt", "avwpdt", "avPet", "avopet", "vrparkt", "avipkt", "avpaacket", "vrpkt", "avparkt", "avpkw", "AVpvt", " avpdt", "avmet", "avtpacket", "avpardt", "avpadat", "ovpect", "avnpet", "rootpcmd", " avpkg", "avparacket", "avipacket", "avwpkt", "avnpkg", "vrpardt", "ovpeett", "ovpct", "avwpgt", "avpvt", "avpwk", "AVpkt", "avopett", "avewpgt", "avopkat", "avlikekat", "avopkw", "AVpwk", "avenpcmd", "rootlikedat", "avopmsg", "avpet", "avgdt", "avjpkw"], "duration": [" timeout", "no", "f", "d", "v", "r", "length", "wait", "str", " wait", "span", "time", "resp", "result", " fut", "timeout", "Duration", "rest", "len", "m", "loop", "repeat", "alt", "total", "err", " dur"]}}
{"project": "qemu", "commit_id": "ea375f9ab8c76686dca0af8cb4f87a4eb569cad3", "target": 1, "func": "void qemu_system_reset(void)\n\n{\n\n    QEMUResetEntry *re, *nre;\n\n\n\n    /* reset all devices */\n\n    QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {\n\n        re->func(re->opaque);\n\n    }\n\n\n}", "idx": 6025, "substitutes": {"re": ["rew", "entry", "rep", "co", "reset", "de", "com", "rer", "rm", "le", "r", "real", "rate", "con", "RE", "red", "ire", "set", "ue", "ry", "se", "he", "rem", "ne", "ru", "ge", "ri", "ret", "mem", "resp", "range", "rs", "ref", "ar", "cre", "rec", "e", "rez", "m", "res", "pair", "report", "ere", "Re", "ce", "ent", "ro", "gre", "ren", "n", "ree", "al", "pre", "reg", "vre", "be"], "nre": ["nmRE", "nmcre", "nmre", "nncre", "nRE", "nnRE", "Nres", "Ncre", "nry", "Nre", " nry", "nnres", "ncre", " nres", " ncre", "nnry", "nmres", "Nry", "nnre", "nres", " nRE"]}}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static void sd_reset(SDState *sd, BlockDriverState *bdrv)\n\n{\n\n    uint64_t size;\n\n    uint64_t sect;\n\n\n\n    if (bdrv) {\n\n        bdrv_get_geometry(bdrv, &sect);\n\n    } else {\n\n        sect = 0;\n\n    }\n\n    size = sect << 9;\n\n\n\n    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;\n\n\n\n    sd->state = sd_idle_state;\n\n    sd->rca = 0x0000;\n\n    sd_set_ocr(sd);\n\n    sd_set_scr(sd);\n\n    sd_set_cid(sd);\n\n    sd_set_csd(sd, size);\n\n    sd_set_cardstatus(sd);\n\n    sd_set_sdstatus(sd);\n\n\n\n    sd->bdrv = bdrv;\n\n\n\n    if (sd->wp_groups)\n\n        g_free(sd->wp_groups);\n\n    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;\n\n    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);\n\n    memset(sd->function_group, 0, sizeof(int) * 6);\n\n    sd->erase_start = 0;\n\n    sd->erase_end = 0;\n\n    sd->size = size;\n\n    sd->blk_len = 0x200;\n\n    sd->pwd_len = 0;\n\n    sd->expecting_acmd = 0;\n\n}\n", "idx": 6032, "substitutes": {"sd": ["sch", "sk", "sing", "sta", "send", "sl", "di", "md", "vd", "sn", "ci", "db", "mod", "des", "ard", "score", "sc", "dev", "dist", "draw", "dd", "ss", "si", "ell", "st", "ud", "reci", "dat", "gd", "sy", "ord", "pd", "storage", "san", "disc", "sb", "sa", "df", "th", "sec", "d", "ind", "ad", "fd", "sam", "ld", "so", "ond", "sh", "sg", "ed", "and", "nd", "dis", "s", "add", "hd", "sim", "td", "ds", "form", "south", "od", "SD", "sm", "cd", "dk", "dl", "sv", "desc", "sky", "cod", "se", "bd"], "bdrv": ["bDrvr", "bsrov", "bdarov", "blerver", "bDrcer", "bDRw", "bdrvr", "bdl", "bDrv", "bderf", "bdrivd", "wdrvr", " bDRv", "bdvd", "ibdrw", "bvrp", "ibvrf", "bderver", "bridcer", "blervr", "bvrm", "bdervd", "bdervc", "htrv", "ibvrch", "briv", "bdr", " bderv", "bvrf", "bsrm", "wderv", "ibdrv", "hsrvd", "ibdrf", "bsrvr", "bdrch", "hdrov", "bdrcer", "bdrr", "bdv", "bdril", "wdercer", " bvrv", "htrl", "bvrvc", "bdervr", "ibvrw", "hsrm", "bdrvd", " bdrp", "bdriv", "htrvd", " bvrvr", "hdrm", " bdrvd", "bdrl", "bvrh", "bdrp", "hdrl", "bdrf", "hdrr", " bdrvc", "bsrw", "htrr", " bdrw", "btrvd", "bsrch", "bdrver", " bdercv", "btrh", "bdercv", "bdarv", "bdrov", " bdrcv", "wdrvd", "bsrf", "bridvr", "ibvrv", "wdrcer", "btrw", "bderw", " bDRh", "bdrm", "bdrir", " bdrh", "wdervd", " bDRp", " bDRw", "bDrvd", "wdervr", "bdrcv", "bvrv", "hsrov", "bsrvd", "bdrvc", "btrr", " bdrvr", "bderch", "brivd", "btrv", "bridvd", "bricv", "bDRp", "bDRh", "bsrcv", "hdrv", "bvrch", "hdrvd", "btrp", "bDRv", "bdrw", "bdercer", "bvrver", "bdarvd", "wdrv", "bdrh", "brivr", " bdervd", "ibdrch", "bderv", "bdarm", "bvrvd", " bdervr", "bvrov", "bridv", " bvrver", "bvrvr", " bvrvc", "btrl", "bsrv", "blervc", "blerv", " bdrver", "bvrw", "hsrv"], "size": ["p", "l", "sum", "ize", "loc", "row", "height", "area", "sn", "count", "c", "n", "z", "sc", "Size", "dim", "sp", "data", "ew", "h", "st", "align", "empty", "mem", "index", "name", "buffer", "len", "storage", "num", "x", "iz", "total", "shape", "capacity", "small", "limit", "sec", "news", "SIZE", "address", "space", "shift", "sh", "s", "t", "max", "south", "v", "length", "to", "sent", "offset", "set", "section", "memory", "g", "status", "scale", "sv", "pos", "se", "sw"], "sect": ["rc", "access", "gz", "ess", "ch", "config", "sec", "ec", "col", "ctx", "length", "put", "mult", "z", "change", "sections", "con", "tab", "diff", "loc", "crit", "set", "cc", "aj", "control", "st", "port", "j", "ECT", "ect", "ex", "eq", "resp", "sector", "section", "sq", "index", "adj", "act", "step", "connect", "shift", "scroll", "sh", "zero", "row", "len", "cond", "test", "ct", "rupt", "round", "seq", "mod", "client", "count", "x", "issue", "n", "touch", "pos", "ctl", "se", "sw"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void phys_page_set(AddressSpaceDispatch *d,\n\n                          target_phys_addr_t index, target_phys_addr_t nb,\n\n                          uint16_t leaf)\n\n{\n\n    /* Wildly overreserve - it doesn't matter much. */\n\n    phys_map_node_reserve(3 * P_L2_LEVELS);\n\n\n\n    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);\n\n}\n", "idx": 6033, "substitutes": {"d": ["dr", "t", "p", "dt", "de", "dm", "ds", "f", "a", "v", "r", "ad", "fd", "dd", "dc", "cd", "dq", "di", "dn", "D", "dat", "did", "sd", "dh", "b", "dx", "md", "da", "du", "dp", "pd", "e", "m", "dll", "c", "bd"], "index": ["key", "active", "primary", "id", "ind", "nn", "ctx", "ix", "label", "position", "address", "node", "offset", "val", "set", "si", "loc", "iso", "size", "i", "level", "slice", "type", "ref", "inc", "row", "Index", "iter", "find", "local", "base", "num", "x", "count", "tx", "block", "pos", "value"], "nb": ["bn", "lb", "bj", "gov", "bm", "nn", "nt", "note", "cb", "ub", "abb", "cn", "nm", "iq", "nu", "b", "bb", "np", "NB", "xb", "nr", "nz", "pb", "mb", "gb", "kb", "nob", "ib", "db", "tn", "num", "sb", "nd", "bf", "obb", "n", "rb", "wb", "batch", "bd"], "leaf": ["af", "gt", "de", "deep", "let", "lf", "nt", "label", "aw", "parent", "ul", "stack", "stable", "lang", "node", "ld", "depth", "valid", "empty", "lvl", "root", "slave", "level", "tree", "fee", " Leaf", "locked", "oot", "Le", "conv", "table", "flag", "child", "bool", "aux", "bf", "alt", "local", "batch"]}}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static inline void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n\n                              const int *const_args)\n\n{\n\n    int c;\n\n\n\n    switch (opc) {\n\n    case INDEX_op_exit_tb:\n\n        if (check_fit_tl(args[0], 13)) {\n\n            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN);\n\n            tcg_out_movi_imm13(s, TCG_REG_O0, args[0]);\n\n        } else {\n\n            tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_I0, args[0] & ~0x3ff);\n\n            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN);\n\n            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0,\n\n                           args[0] & 0x3ff, ARITH_OR);\n\n        }\n\n        break;\n\n    case INDEX_op_goto_tb:\n\n        if (s->tb_jmp_offset) {\n\n            /* direct jump method */\n\n            uint32_t old_insn = *(uint32_t *)s->code_ptr;\n\n            s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf;\n\n            /* Make sure to preserve links during retranslation.  */\n\n            tcg_out32(s, CALL | (old_insn & ~INSN_OP(-1)));\n\n        } else {\n\n            /* indirect jump method */\n\n            tcg_out_ld_ptr(s, TCG_REG_T1, (uintptr_t)(s->tb_next + args[0]));\n\n            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_T1, 0, JMPL);\n\n        }\n\n        tcg_out_nop(s);\n\n        s->tb_next_offset[args[0]] = s->code_ptr - s->code_buf;\n\n        break;\n\n    case INDEX_op_call:\n\n        if (const_args[0]) {\n\n            tcg_out_calli(s, args[0]);\n\n        } else {\n\n            tcg_out_arithi(s, TCG_REG_O7, args[0], 0, JMPL);\n\n        }\n\n        /* delay slot */\n\n        tcg_out_nop(s);\n\n        break;\n\n    case INDEX_op_br:\n\n        tcg_out_bpcc(s, COND_A, BPCC_PT, args[0]);\n\n        tcg_out_nop(s);\n\n        break;\n\n    case INDEX_op_movi_i32:\n\n        tcg_out_movi(s, TCG_TYPE_I32, args[0], (uint32_t)args[1]);\n\n        break;\n\n\n\n#define OP_32_64(x)                             \\\n\n        glue(glue(case INDEX_op_, x), _i32):    \\\n\n        glue(glue(case INDEX_op_, x), _i64)\n\n\n\n    OP_32_64(ld8u):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUB);\n\n        break;\n\n    OP_32_64(ld8s):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSB);\n\n        break;\n\n    OP_32_64(ld16u):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUH);\n\n        break;\n\n    OP_32_64(ld16s):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSH);\n\n        break;\n\n    case INDEX_op_ld_i32:\n\n    case INDEX_op_ld32u_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUW);\n\n        break;\n\n    OP_32_64(st8):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STB);\n\n        break;\n\n    OP_32_64(st16):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STH);\n\n        break;\n\n    case INDEX_op_st_i32:\n\n    case INDEX_op_st32_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STW);\n\n        break;\n\n    OP_32_64(add):\n\n        c = ARITH_ADD;\n\n        goto gen_arith;\n\n    OP_32_64(sub):\n\n        c = ARITH_SUB;\n\n        goto gen_arith;\n\n    OP_32_64(and):\n\n        c = ARITH_AND;\n\n        goto gen_arith;\n\n    OP_32_64(andc):\n\n        c = ARITH_ANDN;\n\n        goto gen_arith;\n\n    OP_32_64(or):\n\n        c = ARITH_OR;\n\n        goto gen_arith;\n\n    OP_32_64(orc):\n\n        c = ARITH_ORN;\n\n        goto gen_arith;\n\n    OP_32_64(xor):\n\n        c = ARITH_XOR;\n\n        goto gen_arith;\n\n    case INDEX_op_shl_i32:\n\n        c = SHIFT_SLL;\n\n    do_shift32:\n\n        /* Limit immediate shift count lest we create an illegal insn.  */\n\n        tcg_out_arithc(s, args[0], args[1], args[2] & 31, const_args[2], c);\n\n        break;\n\n    case INDEX_op_shr_i32:\n\n        c = SHIFT_SRL;\n\n        goto do_shift32;\n\n    case INDEX_op_sar_i32:\n\n        c = SHIFT_SRA;\n\n        goto do_shift32;\n\n    case INDEX_op_mul_i32:\n\n        c = ARITH_UMUL;\n\n        goto gen_arith;\n\n\n\n    OP_32_64(neg):\n\n\tc = ARITH_SUB;\n\n\tgoto gen_arith1;\n\n    OP_32_64(not):\n\n\tc = ARITH_ORN;\n\n\tgoto gen_arith1;\n\n\n\n    case INDEX_op_div_i32:\n\n        tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 0);\n\n        break;\n\n    case INDEX_op_divu_i32:\n\n        tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 1);\n\n        break;\n\n\n\n    case INDEX_op_brcond_i32:\n\n        tcg_out_brcond_i32(s, args[2], args[0], args[1], const_args[1],\n\n                           args[3]);\n\n        break;\n\n    case INDEX_op_setcond_i32:\n\n        tcg_out_setcond_i32(s, args[3], args[0], args[1],\n\n                            args[2], const_args[2]);\n\n        break;\n\n    case INDEX_op_movcond_i32:\n\n        tcg_out_movcond_i32(s, args[5], args[0], args[1],\n\n                            args[2], const_args[2], args[3], const_args[3]);\n\n        break;\n\n\n\n    case INDEX_op_add2_i32:\n\n        tcg_out_addsub2(s, args[0], args[1], args[2], args[3],\n\n                        args[4], const_args[4], args[5], const_args[5],\n\n                        ARITH_ADDCC, ARITH_ADDX);\n\n        break;\n\n    case INDEX_op_sub2_i32:\n\n        tcg_out_addsub2(s, args[0], args[1], args[2], args[3],\n\n                        args[4], const_args[4], args[5], const_args[5],\n\n                        ARITH_SUBCC, ARITH_SUBX);\n\n        break;\n\n    case INDEX_op_mulu2_i32:\n\n        c = ARITH_UMUL;\n\n        goto do_mul2;\n\n    case INDEX_op_muls2_i32:\n\n        c = ARITH_SMUL;\n\n    do_mul2:\n\n        /* The 32-bit multiply insns produce a full 64-bit result.  If the\n\n           destination register can hold it, we can avoid the slower RDY.  */\n\n        tcg_out_arithc(s, args[0], args[2], args[3], const_args[3], c);\n\n        if (SPARC64 || args[0] <= TCG_REG_O7) {\n\n            tcg_out_arithi(s, args[1], args[0], 32, SHIFT_SRLX);\n\n        } else {\n\n            tcg_out_rdy(s, args[1]);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_qemu_ld_i32:\n\n        tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], false);\n\n        break;\n\n    case INDEX_op_qemu_ld_i64:\n\n        tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], true);\n\n        break;\n\n    case INDEX_op_qemu_st_i32:\n\n        tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]);\n\n        break;\n\n    case INDEX_op_qemu_st_i64:\n\n        tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]);\n\n        break;\n\n\n\n    case INDEX_op_movi_i64:\n\n        tcg_out_movi(s, TCG_TYPE_I64, args[0], args[1]);\n\n        break;\n\n    case INDEX_op_ld32s_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSW);\n\n        break;\n\n    case INDEX_op_ld_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDX);\n\n        break;\n\n    case INDEX_op_st_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STX);\n\n        break;\n\n    case INDEX_op_shl_i64:\n\n        c = SHIFT_SLLX;\n\n    do_shift64:\n\n        /* Limit immediate shift count lest we create an illegal insn.  */\n\n        tcg_out_arithc(s, args[0], args[1], args[2] & 63, const_args[2], c);\n\n        break;\n\n    case INDEX_op_shr_i64:\n\n        c = SHIFT_SRLX;\n\n        goto do_shift64;\n\n    case INDEX_op_sar_i64:\n\n        c = SHIFT_SRAX;\n\n        goto do_shift64;\n\n    case INDEX_op_mul_i64:\n\n        c = ARITH_MULX;\n\n        goto gen_arith;\n\n    case INDEX_op_div_i64:\n\n        c = ARITH_SDIVX;\n\n        goto gen_arith;\n\n    case INDEX_op_divu_i64:\n\n        c = ARITH_UDIVX;\n\n        goto gen_arith;\n\n    case INDEX_op_ext32s_i64:\n\n        tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRA);\n\n        break;\n\n    case INDEX_op_ext32u_i64:\n\n        tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRL);\n\n        break;\n\n    case INDEX_op_trunc_shr_i32:\n\n        if (args[2] == 0) {\n\n            tcg_out_mov(s, TCG_TYPE_I32, args[0], args[1]);\n\n        } else {\n\n            tcg_out_arithi(s, args[0], args[1], args[2], SHIFT_SRLX);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_brcond_i64:\n\n        tcg_out_brcond_i64(s, args[2], args[0], args[1], const_args[1],\n\n                           args[3]);\n\n        break;\n\n    case INDEX_op_setcond_i64:\n\n        tcg_out_setcond_i64(s, args[3], args[0], args[1],\n\n                            args[2], const_args[2]);\n\n        break;\n\n    case INDEX_op_movcond_i64:\n\n        tcg_out_movcond_i64(s, args[5], args[0], args[1],\n\n                            args[2], const_args[2], args[3], const_args[3]);\n\n        break;\n\n\n\n    gen_arith:\n\n        tcg_out_arithc(s, args[0], args[1], args[2], const_args[2], c);\n\n        break;\n\n\n\n    gen_arith1:\n\n\ttcg_out_arithc(s, args[0], TCG_REG_G0, args[1], const_args[1], c);\n\n\tbreak;\n\n\n\n    default:\n\n        fprintf(stderr, \"unknown opcode 0x%x\\n\", opc);\n\n        tcg_abort();\n\n    }\n\n}\n", "idx": 6043, "substitutes": {"s": ["p", "conf", "q", "self", "ns", "sq", "ses", "gs", "y", "sym", "stats", "results", "its", "ims", "cli", "n", "qs", "z", "er", "eps", "services", "S", "dev", "r", "ps", "vs", "ctx", "obj", "w", "less", "ss", "h", "tes", "changes", "i", "js", "b", "http", "sts", "ts", "stat", "simple", "bits", "storage", "x", "sb", "us", "als", "ats", "sys", "states", "tests", "sports", "details", "is", "setup", "aws", "bs", "source", "socket", "rs", "m", "bis", "as", "ls", "t", "os", "ds", "south", "ms", "v", "ies", "sm", "sync", "set", "comm", "in", "hs", "ssl", "an", "g", "store", "ties", "status", "es", "sv", "aunts", "sql", "se", "sw"], "opc": ["oppC", "epcs", "epc", "OPlc", "eplc", "iopc", " oplc", "opn", " opC", "oplc", " opn", " opcs", "ioplc", "opplc", " opcode", "OPcs", "opcs", "OPc", "iopC", "opcode", "OPcode", "opC", "iopn", "oppn", "oppc", "epcode"], "args": ["flags", "related", "tests", "grades", "properties", "ras", "atts", "arg", "ms", "roots", "arr", "vs", "ins", "arms", "users", "objects", "issues", "words", "locks", "ks", "els", "amps", "fields", "errors", "axis", "aws", "units", "points", "changes", "rows", "ns", "js", "resp", "blocks", "ians", "range", "rs", "limits", "gs", "tags", "ids", "ties", "Args", "ts", "headers", "ads", "xs", "members", "actions", "seconds", "vals", "bits", "fs", "bugs", "values", "cs", "orders", "ams", "ims", "workers", "ants", "features", "parts", "aux", "terms", "names", "settings", "qs", "weights", "ags", "params"], "const_args": ["const_flags", "const_keys", "const_ms", "const_arg", " const_flags", "static_keys", " const_vals", "const2args", "static_args", "const2flags", " const2arg", "const___ms", " const2vals", "const2arg", "const_vals", "static_params", " const2args", "const___params", "static_ms", " const_arg", "const___args", "const___keys", "const_params", "const2vals", " const2flags"], "c": ["cp", "p", " C", "a", "f", "l", "ec", "lc", "call", "C", "w", "cb", " ec", " e", "or", "fc", "b", "code", "e", "cs", "ac", "count", "Count", "n", " count"]}}
{"project": "FFmpeg", "commit_id": "df824548d031dbfc5fa86ea9e0c652bd086b55c4", "target": 0, "func": "static int eightsvx_decode_frame(AVCodecContext *avctx, void *data,\n\n                                 int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    EightSvxContext *esc = avctx->priv_data;\n\n    int n, out_data_size;\n\n    int ch, ret;\n\n    uint8_t *src;\n\n\n\n    /* decode and interleave the first packet */\n\n    if (!esc->samples && avpkt) {\n\n        int packet_size = avpkt->size;\n\n\n\n        if (packet_size % avctx->channels) {\n\n            av_log(avctx, AV_LOG_WARNING, \"Packet with odd size, ignoring last byte\\n\");\n\n            if (packet_size < avctx->channels)\n\n                return packet_size;\n\n            packet_size -= packet_size % avctx->channels;\n\n        }\n\n        esc->samples_size = !esc->table ?\n\n            packet_size : avctx->channels + (packet_size-avctx->channels) * 2;\n\n        if (!(esc->samples = av_malloc(esc->samples_size)))\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* decompress */\n\n        if (esc->table) {\n\n            const uint8_t *buf = avpkt->data;\n\n            uint8_t *dst;\n\n            int buf_size = avpkt->size;\n\n            int i, n = esc->samples_size;\n\n\n\n            if (buf_size < 2) {\n\n                av_log(avctx, AV_LOG_ERROR, \"packet size is too small\\n\");\n\n                return AVERROR(EINVAL);\n\n            }\n\n\n\n            /* the uncompressed starting value is contained in the first byte */\n\n            dst = esc->samples;\n\n            for (i = 0; i < avctx->channels; i++) {\n\n                *(dst++) = buf[0]+128;\n\n                delta_decode(dst, buf + 1, buf_size / avctx->channels - 1, (buf[0]+128)&0xFF, esc->table);\n\n                buf += buf_size / avctx->channels;\n\n                dst += n / avctx->channels - 1;\n\n            }\n\n        } else {\n\n            raw_decode(esc->samples, avpkt->data, esc->samples_size);\n\n        }\n\n    }\n\n\n\n    /* get output buffer */\n\n    av_assert1(!(esc->samples_size % avctx->channels || esc->samples_idx % avctx->channels));\n\n    esc->frame.nb_samples = FFMIN(MAX_FRAME_SIZE, esc->samples_size - esc->samples_idx)  / avctx->channels;\n\n    if ((ret = avctx->get_buffer(avctx, &esc->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = esc->frame;\n\n\n\n    out_data_size = esc->frame.nb_samples;\n\n    for (ch = 0; ch<avctx->channels; ch++) {\n\n        src = esc->samples + esc->samples_idx / avctx->channels + ch * esc->samples_size / avctx->channels;\n\n        memcpy(esc->frame.data[ch], src, out_data_size);\n\n    }\n\n    out_data_size *= avctx->channels;\n\n    esc->samples_idx += out_data_size;\n\n\n\n    return esc->table ?\n\n        (avctx->frame_number == 0)*2 + out_data_size / 2 :\n\n        out_data_size;\n\n}\n", "idx": 6063, "substitutes": {"avctx": [" avcontext", "wavctx", "ajpkg", "navkw", "averconn", "ajctl", "iverjac", "afcmd", "ivercmd", "abctx", "avcmd", "abcu", "ajkw", " avcmd", "ravctx", "avectx", "wavtx", "abconn", "averctl", "ravcontext", "avecu", "avercu", "iverctx", " avcmp", "abcontext", "ajjp", "ajcmd", "afctl", " avobj", "avcu", "wavcontext", "afctx", "navctx", "avconfig", "abtx", "wavobj", "avetx", "afconfig", " avctl", "aveconfig", "ajcfg", " avtx", "avecmp", "abcmd", "ajconn", "avctl", "afcu", "averjac", "ravcu", "avcp", "wavcmp", "avpkg", "avercontext", "avcontext", "ajtx", "ajconfig", "ajobj", "averctx", "ajjac", "AVtx", " avjp", "ajctx", "avercmd", "navcmd", "avercfg", "avjac", "avcfg", "afjp", "abcp", "avecp", "avjp", " avconn", "ajcmp", "AVcontext", "avecfg", "avconn", "averconfig", "avobj", "ajcontext", "ravtx", "AVctl", "avecontext", "AVctx", "afconn", "avepkg", "afcmp", "iverkw", "avkw", "afcontext", "wavpkg", "afpkg", "aftx", "avcmp", "abcmp", "aveconn", "avejac", "navjac", "abjac", " avcfg", "avecmd", "avtx", "aveobj", "abpkg", "ajcp"], "data": ["out", "t", "p", "f", "a", "load", "d", "id", "r", "length", "mu", "image", "DATA", "padding", "map", "w", "offset", "Data", "o", "read", "feed", "pad", "dat", "size", "multiple", "format", "value", "bytes", "def", "name", "response", "type", "buffer", "text", "ata", "len", "m", "actions", "raw", "table", "base", "window", "mode", "bin", "video", "message", "start", "cache", "input", "frame", "stream", "batch"], "got_frame_ptr": ["got_frame2pointer", "got_data_ptr", "got_frame2pointers", "got_frame2ptr", "got_frame_pointer", "got_data_addr", "got_frame2addr", "got_frame_pointers", "got_data_pointer", "got_frame_addr", "got_data_pointers"], "avpkt": ["avPdu", " avpdu", "afpkt", "avvpmt", "afpdu", "avmkt", "avmdu", "avepamt", "avpamt", "avpcmd", "avvpft", "afPcmd", "afPacket", "avpacmd", "avjpmt", "avvacket", " avPnt", "avPcmd", "afpcmd", "ajppkt", "avdcmd", "afcpdu", "avppdu", "ajpacket", "avppnt", "avpk", "afpacket", "avdkt", "afPth", "avpakt", "avpft", "ajpk", " avPct", "avcpdu", "avppcmd", "avPkt", "avPacket", "avmcmd", "avPnt", "avpackcmd", "avcpk", "afmacket", "avpdu", "avpackacket", "avopct", "avPct", "ajppct", "avvk", "avpct", "afcpcmd", "afmct", "ajpkt", "avmacket", "avdth", "avepkt", "avppkt", "avmct", "avcpacket", "avjpkt", "avcpnt", " avPdu", "avepcmd", "avpmt", "afpth", "avppct", "avpaft", "avcpct", "avmk", "avvpkt", "avppacket", "avdacket", "avvkt", "avcpcmd", "avepacmd", " avPkt", "avepaft", "avopacket", "ajppacket", "afcpkt", "avpackkt", "ajpct", "afcpacket", "avpacket", "afPkt", " avpnt", "avopkt", "avepakt", "avvct", "afpk", "avjpft", "avopk", "ajppk", "avpnt", "afmk", "afpct", "avepft", "avppk", "avcpkt", " avpct", "afmkt", "avepmt", "avpth", "avPth", "avpackth", "avvpcmd", "avjpcmd"], "esc": ["sc", "rc", "Esc", "equ", "isc", "ess", "ebook", "eth", "eur", "https", "sec", "eval", "sel", "ech", "except", "ec", "lc", "ctx", "eg", "pg", "eco", "loc", "ep", " ec", "ew", "abc", "asc", "eca", "phrase", "osc", "eng", "esm", "chest", "ez", "ssh", "imp", "ect", "eq", "secure", "ex", "irc", "exc", "bec", "ah", "egal", "comm", "sh", "esi", "psc", "established", "ocr", "es", "ape", "rez", "xc", "esp", "exec", "ek", "disc", "eb", "desc", "env", "ef", "escape", "oc", "eh", "ecd", "ev"], "n": ["t", "p", "d", "l", "v", "nn", "id", "nt", "r", "w", "en", "k", "h", "j", "o", "cn", "nm", "size", "ns", " N", "nan", "b", "np", "g", "mn", "len", "sn", "m", "na", "N", "ni", "names", "num", "count", "c", "s", "z", "nb", "nc", "out"], "out_data_size": ["out_data_num", "out_window_len", "out_data_len", "out_window_num", "out_data_length", "out_window_length", "out_window_size"], "ch": ["sc", "conf", "ih", "th", "bi", "ach", "cho", "col", "channel", "och", "cor", "q", "cb", "k", "h", "CH", "chain", "ip", "Ch", "y", "cht", "chan", "cs", "count", "c", "z"], "ret": ["rc", "reset", "elt", "fi", "ll", "nt", "re", "Ret", "fin", "val", "ry", "rem", "mem", "mt", "result", "net", "rs", "ref", "new", "status", "match", "rel", "res", "conv", "rt", "alt", "sys"], "src": ["ptr", "rc", "sc", "bh", "tmp", "dest", "ctr", "dist", "scan", "inst", "sub", "txt", "cb", "loc", "trans", "st", "attr", "source", "usr", "rs", "sn", "iv", "addr", "sb", "bin", "sys", "input", "img"], "buf": ["init", "rc", "doc", "lim", "cp", "pack", "max", "pkg", "ux", "cv", "tmp", "nb", "arr", "ctx", "mu", "xff", "norm", "msg", "map", "txt", "cb", "Buffer", "ff", "h", "br", "buff", "Buff", "mem", "emb", "b", "np", "err", "off", "pb", "bl", "cap", "buffer", "iter", "cam", "db", "end", "late", "coord", "raw", "vec", "conv", "foo", "uf", "var", "seq", "tx", "desc", "queue", "cmd", "box", "pos", "rb", "img", "bc", "batch"], "dst": ["Dnet", "sest", "wST", "idest", "sst", "iddest", "wrest", "dest", "drest", "dnd", "dend", " dnet", "ddest", "sdput", "sddest", "sdest", "sdst", "bend", "jest", "dput", "Dput", "idput", "Dst", "dost", " dend", " ddest", " drest", "idnd", "dST", "bST", "brest", "idost", "idst", "wst", "Dnd", "bst", " dST", "jst", "Dost", "DST", "jnd", "wend", "idnet", "Ddest", "jost", "dnet", "Dest", " dest", " dost", "sST"], "i": ["init", "t", "li", "p", "sim", "ki", "bi", "is", "id", "l", "v", "ii", "ini", "d", "mi", "ix", "it", "ic", "si", "k", "j", "di", "h", "gi", "io", "ip", "b", "index", "g", "ui", "multi", "iu", "xi", "y", "zi", "status", "e", "ti", "ci", "m", "ai", "pi", "im", "x", "I", "phi", "qi", "c", "cli", "z", "u"]}}
{"project": "qemu", "commit_id": "80dcfb8532ae76343109a48f12ba8ca1c505c179", "target": 0, "func": "static int virtio_serial_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIOSerial *s = opaque;\n\n    VirtIOSerialPort *port;\n\n    uint32_t max_nr_ports, nr_active_ports, ports_map;\n\n    unsigned int i;\n\n    int ret;\n\n\n\n    if (version_id > 3) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* The virtio device */\n\n    ret = virtio_load(&s->vdev, f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (version_id < 2) {\n\n        return 0;\n\n    }\n\n\n\n    /* The config space */\n\n    qemu_get_be16s(f, &s->config.cols);\n\n    qemu_get_be16s(f, &s->config.rows);\n\n\n\n    qemu_get_be32s(f, &max_nr_ports);\n\n    tswap32s(&max_nr_ports);\n\n    if (max_nr_ports > tswap32(s->config.max_nr_ports)) {\n\n        /* Source could have had more ports than us. Fail migration. */\n\n        return -EINVAL;\n\n    }\n\n\n\n    for (i = 0; i < (max_nr_ports + 31) / 32; i++) {\n\n        qemu_get_be32s(f, &ports_map);\n\n\n\n        if (ports_map != s->ports_map[i]) {\n\n            /*\n\n             * Ports active on source and destination don't\n\n             * match. Fail migration.\n\n             */\n\n            return -EINVAL;\n\n        }\n\n    }\n\n\n\n    qemu_get_be32s(f, &nr_active_ports);\n\n\n\n    /* Items in struct VirtIOSerialPort */\n\n    for (i = 0; i < nr_active_ports; i++) {\n\n        uint32_t id;\n\n        bool host_connected;\n\n\n\n        id = qemu_get_be32(f);\n\n        port = find_port_by_id(s, id);\n\n        if (!port) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        port->guest_connected = qemu_get_byte(f);\n\n        host_connected = qemu_get_byte(f);\n\n        if (host_connected != port->host_connected) {\n\n            /*\n\n             * We have to let the guest know of the host connection\n\n             * status change\n\n             */\n\n            send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN,\n\n                               port->host_connected);\n\n        }\n\n\n\n        if (version_id > 2) {\n\n            uint32_t elem_popped;\n\n\n\n            qemu_get_be32s(f, &elem_popped);\n\n            if (elem_popped) {\n\n                qemu_get_be32s(f, &port->iov_idx);\n\n                qemu_get_be64s(f, &port->iov_offset);\n\n\n\n                qemu_get_buffer(f, (unsigned char *)&port->elem,\n\n                                sizeof(port->elem));\n\n                virtqueue_map_sg(port->elem.in_sg, port->elem.in_addr,\n\n                                 port->elem.in_num, 1);\n\n                virtqueue_map_sg(port->elem.out_sg, port->elem.out_addr,\n\n                                 port->elem.out_num, 1);\n\n\n\n                /*\n\n                 *  Port was throttled on source machine.  Let's\n\n                 *  unthrottle it here so data starts flowing again.\n\n                 */\n\n                virtio_serial_throttle_port(port, false);\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 6069, "substitutes": {"f": ["af", "fr", "t", "p", "conf", "fi", "tf", "form", "lf", "a", "full", "d", "l", "fac", "v", "fm", "far", "r", "it", "fb", "file", "fd", "ft", "q", "fw", "w", "ff", "sf", "j", "h", "o", "fl", "xf", "buff", "fc", "fa", "ex", "b", "of", "F", "g", "safe", "fed", "rf", "ref", "fp", "cf", "e", "fo", "um", "fs", "ac", "uf", "c", "ef", "bf", "z", "out", "fx"], "opaque": ["Opene", " opsolete", "ogque", "ogacity", "Opaque", "oplaco", "oplque", "oplacity", " opene", "opsaque", "opssolete", "popaque", "oplaque", "opaco", "opque", "opsolete", "opene", "popaco", " opque", "Opsolete", "popacity", "popque", "ogaque", "opsque", "opacity", "ogaco", "Opque", "opsene"], "version_id": ["versionofid", "versionationip", "versionitydb", "version2id", "version2time", "versionofnumber", "versionalitytype", "versionTypeis", "version_type", "ver_bug", "versionTypedb", "versionTypeId", "versionoftype", "versionityis", "versionTypeid", "versionationlink", "version_link", "section_is", "ver_id", "version_time", "section_Id", "message_ip", "version_is", "messageewid", "version__type", "versionewip", "versionewlink", "sectionityId", "versionalityid", "version_ip", "sectionityis", "version_Id", "ver_number", "message_id", "version2type", "version_number", "version__id", "section_db", "version_db", "versionewid", "versionityId", "versionalitybug", "versionityid", "versionofbug", "message_link", "version__time", "ver_type", "sectionitydb", "messageewip", " version_time", "versionalitynumber", "section_id", "versionationid", "sectionityid", "version__no", "version_no", "messageewlink", " version_type", "version_bug", "version2no", " version_no"], "s": ["t", "os", "S", "ess", "p", "sports", "conf", "ds", "is", "a", "v", "sp", "r", "ps", "spec", "serv", "sl", "sam", "set", "ss", "single", "h", "aws", "comm", "params", "source", "js", "ns", "hs", "ssl", "b", "state", "sq", "ses", "sts", "socket", "rs", "store", "gs", "su", "ts", "es", "ops", "stats", "fs", "service", "sis", "sv", "its", "session", "sb", "c", "settings", "ls", "series", "n", "qs", "sys", "se", "sw", "services"], "port": ["key", "pp", "p", "present", "host", "pc", "file", "connection", "pro", "handle", "pt", "slot", "slave", "interface", "row", "remote", "mit", "page", "bridge", "project", "queue", "cp", "seat", "Port", "export", "h", "ve", "j", "device", "profile", "driver", "comment", "proxy", "timeout", "member", "ort", "report", "try", "part", "import", "pod", " transport", "entry", " sport", "plugin", "component", "policy", "address", "version", "pport", "ports", "eport", "group", "state", "point", "socket", "type", "peer", "pool", "m", "table", "pe", "t", "ported", "v", "pipe", "channel", "ping", "parent", "position", "server", "link", "info", "tag", "gp", "service", "PORT", "test", "client", "player", "public"], "max_nr_ports": ["max_NR_ports", "max_num_planes", "max_nr_players", "max_NR_pointers", "max_nr_devices", "max_nrptports", "max_nrntplanes", "max_nr_planes", "max_nr67orts", "max_NR_users", "max_nrptps", "max_nr_users", "max_NR_devices", "max_NR_planes", "max_nrptplanes", "max_nr_rows", "max_nr_ps", "max_nrntpointers", "max_nr_values", "max_nr67planes", "max_NR_rows", "max_nr_points", "max_nir67ports", "max_num_devices", "max_nrdjobs", "max_nrdports", "max_NR_points", "max_nir_orts", "max_nrntports", "max_nir_ports", "max_nrntvalues", "max_nr_jobs", "max_nr_orts", "max_num_ports", "max_NR_jobs", "max_NR_values", "max_nir67orts", "max_NR_ps", "max_nir_planes", "max_num_players", "max_nr67ports", "max_nrptrows", "max_nr_pointers", "max_nrdusers", "max_nir67planes", "max_nrddevices"], "nr_active_ports": ["nr_active__ports", "nr_active___ports", "nr_activedports", "nr_active_pages", "nr_active___players", "nr_active2pages", "nr_active_options", "nr_nr_pages", "nr_activeablecells", "nr_active2ports", "nr_active_port", "nr_nr_ports", "nr_activeedcells", "nr_active___pages", "nr_active__port", "nr_active_workers", "nr_active2workers", "nr_activ_options", "nr_activeableports", "nr_nr_players", "nr_activedcells", "nr_activeedoptions", "nr_activeableoptions", "nr_activ_ports", "nr_activeableplayers", "nr_active___workers", "nr_activedplayers", "nr_active_hops", "nr_activeedplayers", "nr_activeedports", "nr_active_planes", "nr_nr_workers", "nr_activ_cells", "nr_active__hops", "nr_active2players", "nr_activedoptions", "nr_activ_players", "nr_active_cells", "nr_active_players", "nr_active__planes"], "ports_map": ["planes_list", "portserMAP", "ports_list", "portserMap", "ports_maps", "types_map", "ports_cap", "services_map", "services_MAP", "orts_map", "ports__map", "ports__reg", "ports_reg", "planes_map", "orts_ap", "ports__list", "ports_load", "ports_table", "types_list", "ports_dict", "orts_list", "portsermap", "types_reg", "ports_Map", "planes_cap", "types_maps", "services_load", "planes_dict", "ports__maps", "services_Map", "orts_table", "portserload", "ports_MAP", "ports_ap"], "i": [" m", " I", "t", "ei", "li", "p", " multi", " err", "sim", "dr", "init", "ki", "bi", "ind", "ii", " ni", "ini", "mi", "ix", " pi", "it", "me", "q", "\u0438", "hi", "uri", "si", "oi", "j", "di", "gi", "ri", "in", "iq", "chain", "ji", "index", "point", "info", "g", " v", " si", "multi", "ui", "iu", "xi", "ij", "y", "zi", " ti", "ci", "ti", "m", "ai", "pi", " index", " j", " mi", " di", "I", "im", "phi", "qi", "ims", "cli", "us", "n", "u", " ii", "batch"], "ret": ["t", "reset", "lit", "gt", "verified", "tmp", "nil", "ll", "gov", "RET", "v", "r", "re", "nt", "cont", "Ret", "Return", "rets", "pas", "txt", "cb", "cert", "val", "got", "ry", "valid", "erey", "mem", "mt", "result", "resp", "def", "usr", "pret", "over", "rev", "ref", "new", "len", "jp", "print", "res", "det", "try", "tr", "ter", "flag", "reg", "bool", " Ret", "final", "rt", "alt", "backed", "out"], "id": ["ptr", "key", "dr", "t", "order", "is", "ID", "bid", "d", "it", "ad", "fd", "hash", "kid", "Id", "str", "vid", "h", "rid", "time", "ip", "ident", "index", "name", "info", "sid", "ref", "mid", "ids", "tag", " fid", "wid", "code", "m", "part", "window", "uid", "ide", "pid", "aid", "oid", "url", " tid"], "host_connected": ["certfulconn", "host_active", "host_pressed", "human_visible", "cert_pressed", "hostingclosed", "host__connected", " host_loaded", " host_created", "host_connection", "host_established", "hostenconnected", "ghostrettyconnection", "host__established", "hostedconnected", "certfulpressed", "ghost_updated", "hostrettyconnected", "hosterconnected", "hostrettyupdated", "hostfulpressed", "hostedupdated", "human_accessible", "host_updated", "server_connected", "host_loaded", "cert_active", "host_created", "host_visible", "hosterconn", "ghost_opened", "hostfulconn", "hostrettyopened", "hostedconnection", "host_accessible", "hostenpressed", "server_closed", "hostingconnection", "host_conn", "hostfulactive", "hosterpressed", "host_colored", "cert_conn", "human_established", "ghost_connected", "hosteractive", "host__visible", "host_closed", "certfulconnected", "server_colored", "ghostrettyopened", "host__accessible", "ghostrettyconnected", " host_connection", "hostfulconnected", "hostenconn", "hostrettyconnection", "human_connected", "hostenactive", "hostedopened", "hostingconnected", "certfulactive", "ghostrettyupdated", "host_opened", "ghost_connection", "server_connection", "hostingcolored", "cert_connected"], "elem_popped": ["elem_copped", "elem_popping", "elem_POpled", "elem_dropp", "elem_POpp", "elem_copp", "ii", "elem_popp", "elem_droplet", "cont", "elem_POplet", "elem_cops", "elem_copled", "elem_poplet", "elem_drops", "elem_dropped", "elem_crops", "elem_cropped", "elem_POpping", "elem_pops", "elem_popled", "elem_dropled", "elem_POpped", "elem_POps", "elem_cropping", "_", "elem_dropping", "elem_croplet"]}}
{"project": "qemu", "commit_id": "130257dc443574a9da91dc293665be2cfc40245a", "target": 0, "func": "static CharDriverState *qemu_chr_open_spice_port(const char *id,\n\n                                                 ChardevBackend *backend,\n\n                                                 ChardevReturn *ret,\n\n                                                 Error **errp)\n\n{\n\n    const char *name = backend->spiceport->fqdn;\n\n    CharDriverState *chr;\n\n    SpiceCharDriver *s;\n\n\n\n    if (name == NULL) {\n\n        fprintf(stderr, \"spice-qemu-char: missing name parameter\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    chr = chr_open(\"port\", spice_port_set_fe_open);\n\n    s = chr->opaque;\n\n    s->sin.portname = g_strdup(name);\n\n\n\n    return chr;\n\n}\n", "idx": 6092, "substitutes": {"id": ["key", "init", "rc", "ID", "bid", "hid", "hash", "ad", "kid", "Id", "vid", "kind", "rid", "ip", "ident", "bind", "sid", "ref", "mid", "ids", "tag", "code", "end", "db", "uid", "pid", "oid", "iden"], "backend": ["Backide", "guind", "backide", "Backest", "bbenter", "bbender", "backender", "bend", "guend", "bbend", "BACKended", "Backenter", "BACKend", "backended", "bind", "BACKender", "backind", "best", "bide", "guide", "Backind", "bbended", "Backender", "guest", "backest", "Backended", "Backend", "backenter", "BACKenter"], "ret": ["et", "lit", "gt", "sel", "RET", "rm", "nt", "re", "Ret", "rets", "txt", "val", "mem", "mt", "resp", "def", "sys", "std", "ref", "res", "det", "desc", "des", "reply", "rt", "reg"], "errp": ["erpp", "Erps", "errpar", "Erpp", "Erpar", "erp", "Erp", "erpar", "erps", "nrpar", "errpp", "nrps", "nrp", "nrpp", "errps"], "name": ["key", "order", "Name", "no", "ame", "f", "a", "l", "data", "r", "normal", "spec", "label", "path", "aw", "error", "prefix", "w", "str", "version", "alias", "nam", "j", "ne", "o", "nm", "size", "source", "word", "mem", "b", "ident", "def", "info", "net", "type", "ref", "ma", "admin", "len", "na", "up", "base", "zone", "title", "names", "part", "x", "c", "create", "open", "nl", "n", "local", "NAME", "close"], "chr": ["cherar", " chrs", " chsr", "ochr", "chru", "ichsr", "ichar", "CHsr", " chdr", "echr", "echdr", "chrb", "chsr", " chrb", "Chr", "chedr", "ochrs", "Chdr", "Chrb", " chR", "ochsr", "chersr", "chcr", "cherr", "echR", "ochdr", "CHrb", "Char", "echcr", "CHr", "chrs", "checr", " chcr", "cheR", "thru", "ichr", "CHar", "ichru", "chR", "thar", "Chrs", "Chsr", "thsr", "chdr", "cherru", "cher", "thr"], "s": ["os", "S", "p", "sports", "ds", "is", "sp", "r", "ps", "ins", "w", "ss", "self", "o", "bs", "source", "ns", "js", "hs", "ssl", "sq", "g", "socket", "ses", "sts", "rs", "gs", "y", "ts", "es", "fs", "its", "sis", "sv", "cs", "session", "bis", "sb", "c", "ls", "n", "ats", "sys", "qs"]}}
{"project": "qemu", "commit_id": "ec53b45bcd1f74f7a4c31331fa6d50b402cd6d26", "target": 0, "func": "void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)\n\n{\n\n#if defined(TARGET_HAS_ICE)\n\n    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);\n\n\n\n    breakpoint_invalidate(cpu, breakpoint->pc);\n\n\n\n    g_free(breakpoint);\n\n#endif\n\n}\n", "idx": 6098, "substitutes": {"cpu": ["cu", "cp", "ork", "clus", "phys", "os", " CPU", "util", "cv", "aco", "percent", "processor", "ctx", "mu", "pc", "linux", "prof", "gpu", "physical", "bench", "gc", "proc", "np", "clock", "comp", "arch", "CPU", "socket", "target", "tp", "process", "alloc", "ck", "boot", "bits", "pu", "core", "hw", "cum", "ct", "cpp", "aux", "nic", "sys", "nc"], "breakpoint": ["Breakp", "breakline", " breakpointer", "workscope", "Breakpointer", "breakingzone", "Breakzone", "blockline", "breakingscope", "windowpointer", "breakPoint", " breakpage", " breakp", "breakingtag", "workoint", "windowpoint", "breakingoint", "blockpoint", "breakingpage", "BreakPoint", "breakscope", "workpoint", "blockp", "worktag", "breaktag", "blockPoint", "Breakoint", " breakline", "breakingPoint", "breakpage", " breakPoint", " breakzone", "breakingpoint", "Breakpoint", "breakp", " breakscope", "breakoint", "breakzone", " breaktag", "breakpointer", "windowoint", "windowpage", "Breakline", " breakoint", "Breakpage"]}}
{"project": "FFmpeg", "commit_id": "1eaff98c8320d9ba48fbaec2a558f31f4104de98", "target": 1, "func": "static int flv_write_trailer(AVFormatContext *s)\n\n{\n\n    int64_t file_size;\n\n\n\n    AVIOContext *pb = s->pb;\n\n    FLVContext *flv = s->priv_data;\n\n    int i;\n\n\n\n    /* Add EOS tag */\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVCodecContext *enc = s->streams[i]->codec;\n\n        FLVStreamContext *sc = s->streams[i]->priv_data;\n\n        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n            enc->codec_id == AV_CODEC_ID_H264)\n\n            put_avc_eos_tag(pb, sc->last_ts);\n\n    }\n\n\n\n    file_size = avio_tell(pb);\n\n\n\n    /* update information */\n\n    avio_seek(pb, flv->duration_offset, SEEK_SET);\n\n    put_amf_double(pb, flv->duration / (double)1000);\n\n    avio_seek(pb, flv->filesize_offset, SEEK_SET);\n\n    put_amf_double(pb, file_size);\n\n\n\n    avio_seek(pb, file_size, SEEK_SET);\n\n    return 0;\n\n}\n", "idx": 6103, "substitutes": {"s": ["t", "os", "p", "S", "conf", "ds", "https", "f", "aus", "ms", "v", "ps", "vs", "ins", "spec", "w", "less", "fps", "ss", "h", "aws", "comm", "bs", "js", "ns", "hs", "ex", "sq", "sys", "http", "ses", "sts", "g", "rs", "gs", "ts", "es", "stats", "m", "xs", "fs", "its", "sv", "args", "cs", "ims", "sb", "c", "parts", "ls", "ats", "n", "qs", "eps"], "file_size": ["file_SIZE", "file2data", "file_offset", " file_data", "FILE_name", " file_offset", "FILE_SIZE", "file2Size", "file_name", " file_Size", " file_SIZE", "file2size", "file2length", "file_Size", "FILE_Size", " file_length", "file_data", "file_length", "FILE_size"], "pb": ["tc", "vp", "pp", "cp", "p", "lb", "pel", "pkg", "bps", "cv", "bh", "bj", "lp", "td", "PB", "func", "ctx", "pc", "fb", "mp", "pg", "typ", "wp", "cb", "amp", "orp", "ub", "pa", "req", "pm", "pt", "px", "rb", "emb", "b", "np", "bb", "proc", "resp", "xb", "erb", "buf", "mt", "mb", "gb", "fp", "tp", "dp", "jp", "um", "db", "bp", "eb", "pl", "uf", "stab", "sb", "patch", "tm", "ob", "tk", "tab", "nb", "wb", "zb"], "flv": ["filov", "llv", "vlf", "slov", "flovt", "flushv", "filuv", "ilf", "llvc", " flvt", "filv", "flvm", "slv", "filf", " flvc", "flf", "flushf", "fluv", "ilv", "ilvt", "filvc", "llf", " flov", "flov", "flof", "flvt", "vlv", " flf", " flvm", "flushvm", "flvc", " fluv", "vlvm", "sluv"], "i": ["id", " wi", "ii", " ni", "ini", " pi", "it", "my", "hi", "di", "gi", " si", "y", "remote", "ci", "ami", " j", "ims", "qi", " ii", " I", "ski", "ix", "list", "ic", "si", "oi", "j", "ji", "index", "name", "zi", "instance", "pi", "x", "phi", "us", "series", "is", "ind", "mi", "ri", "chain", "ex", "ip", "multi", " ti", "ti", " ki", "m", "ai", "im", " mi", "I", "go", "t", "li", " multi", "sim", " iter", "ki", "bi", "ms", " bi", "me", "uri", "o", "in", " li", "info", "g", "ui", "iu", "xi", "ij", "batch"], "enc": ["equ", "et", "cv", "conn", "vc", "ec", "ctx", "eric", "pc", "oder", "coll", "ens", "cc", "en", "eng", "fc", "iq", "anc", "Enc", "act", "inc", "code", "ck", "acc", "cmp", "xc", "conv", "ENG", "ent", "auth", "env", "c", "ENC", "cod", "oc", "ack", "ev", "nc"], "sc": ["tc", "mc", "rc", "isc", "sch", "ch", "cv", "SC", "esc", "sp", "ec", "lc", "ctx", "pc", "Sc", "arc", "cc", "ss", "sci", "asc", "osc", "gc", "cr", "fc", "anc", " subsc", "scl", "uc", "acc", "cs", "c", "nc", "bc", "sw"]}}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static const void *boston_fdt_filter(void *opaque, const void *fdt_orig,\n\n                                     const void *match_data, hwaddr *load_addr)\n\n{\n\n    BostonState *s = BOSTON(opaque);\n\n    MachineState *machine = s->mach;\n\n    const char *cmdline;\n\n    int err;\n\n    void *fdt;\n\n    size_t fdt_sz, ram_low_sz, ram_high_sz;\n\n\n\n    fdt_sz = fdt_totalsize(fdt_orig) * 2;\n\n    fdt = g_malloc0(fdt_sz);\n\n\n\n    err = fdt_open_into(fdt_orig, fdt, fdt_sz);\n\n    if (err) {\n\n        fprintf(stderr, \"unable to open FDT\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0])\n\n            ? machine->kernel_cmdline : \" \";\n\n    err = qemu_fdt_setprop_string(fdt, \"/chosen\", \"bootargs\", cmdline);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    ram_low_sz = MIN(256 * M_BYTE, machine->ram_size);\n\n    ram_high_sz = machine->ram_size - ram_low_sz;\n\n    qemu_fdt_setprop_sized_cells(fdt, \"/memory@0\", \"reg\",\n\n                                 1, 0x00000000, 1, ram_low_sz,\n\n                                 1, 0x90000000, 1, ram_high_sz);\n\n\n\n    fdt = g_realloc(fdt, fdt_totalsize(fdt));\n\n    qemu_fdt_dumpdtb(fdt, fdt_sz);\n\n\n\n    s->fdt_base = *load_addr;\n\n\n\n    return fdt;\n\n}\n", "idx": 6108, "substitutes": {"opaque": [" Oplay", "oplaques", "obacity", "OPaque", "opaques", "oppaque", "Opaque", "oplay", "OPsolete", "oplacity", "Opoch", "obaque", "oplaque", " Opoch", "Oplay", "opsolete", "opca", "opoch", "Opsolete", "obca", "oppca", " Opaque", "opacity", "OPlay", "obaques", " Opsolete", "oppacity", "oppaques", "oplca", "OPoch"], "fdt_orig": ["fdp_origin", "fdt__prop", "fdp_original", "fdt__Orig", "fdx_original", "fdt_Orig", "fdp_Orig", "fdx_prop", "fdt_raw", "fdt_prop", "fdt__orig", "fdx_orig", "fdt_original", "fdt_origin", "fdx_Orig", "fdp_orig", "fdt__original", "fdp_raw"], "match_data": ["matchmatdata", "cache_data", "cache_bytes", "matchmatbytes", "matchmatbuffer", "cachematdata", "matchmathash", "match_bytes", "cachemathash", "match_buffer", "cache_buffer", "cachematbuffer", "cachematbytes", "cache_hash", "match_hash"], "load_addr": ["loaderref", "load_pad", "loader_address", "load_ref", "loadADpad", "loader_pad", "loadaddraddr", "load_hash", "loader_addr", "loaderaddr", "loadaddrref", "loadaddraddress", " load_address", "load_address", "loaderaddress", " load_ref", "loaderhash", " load_hash", "loadADaddress", "loadADaddr", "loadaddrhash"], "s": ["t", "os", "S", "p", "sports", "sand", "ds", "south", "is", "sac", "a", "v", "sing", "sp", "ps", "sm", "sl", "less", "ss", "self", "j", "h", "st", "so", "bs", "ns", "hs", "b", "state", "sq", "g", "ses", "sts", "rs", "m", "fs", "sv", "sis", "session", "sb", "services", "ls", "sys", "se", "sw", "sa"], "machine": ["achine", "sim", "host", "Machine", "dm", " machines", "handler", "smart", "volume", "normal", "me", "menu", "policy", "sm", "rule", "node", "server", "leader", "human", "alias", "iso", "power", "module", "agent", "device", "mob", "chain", "link", "mem", "proc", "manager", "memory", "computer", "network", "vm", "process", "movie", "m", "instance", "container", "domain", "engine", "model", "zone", "mass", "template", "mode", "magic", "demon", "series", "message", "man", "spin", "money", "managed", "mouse", "mc", "monitor"], "cmdline": ["cmdl", "commnet", "commline", "commandlog", "commandeline", "commandle", "commLine", " cmdle", "cmdle", "mdLine", "commandl", " cmdl", "commandLine", " cmdeline", "cmdeline", "cmdnet", "commandline", "mdle", " cmdLine", "cmdlog", "comml", "commandnet", "cmdLine", " cmdnet", "mdline", " cmdlog", "commlog", "commeline"], "err": ["eas", "dr", "Er", "order", "gz", "fr", "conf", "elt", "eor", "warn", "cer", "inner", "css", "kr", " ni", "score", "arr", "r", "lr", " cr", "rr", "norm", " ptr", "error", " score", "cb", "spr", " terr", "errors", "die", "good", "br", "here", "or", "req", "later", "cr", "only", "attr", "i", "rb", "none", "resp", "usr", " intr", "nr", "fee", "level", "pr", "ner", "rar", "iter", "rn", "code", "e", "cfg", "res", "ere", " len", "test", "yr", "count", "c", "Error", "aaa", "n", "notice", "er", "ev", "timer", "mr"], "fdt": ["lntt", "fdtr", "fredtr", "frtt", "frT", "fdr", "dfpt", "feedt", "aftte", " fidw", "FDte", "lntd", "fcit", "fdd", "fcw", "fcT", "frt", "fdta", "fedg", "fdpt", "fredts", "fedpt", "dfp", "fnt", "lnte", "dfg", " fidt", "fpt", "fctt", "flte", "lnwt", "fmr", "dfw", "windtd", "dfta", "fltd", "dfit", "aftt", "dftt", "dftr", "find", "FDtt", "fints", "fdit", "fdg", "aftta", "FDl", "windl", "FDta", "windt", "fmt", "dfd", "fg", "fdwt", "fint", "lnT", "feedtd", "FDt", "fmtd", "ft", "fd", "fedtr", "fedt", "fcc", "fdtd", "windta", " fidts", "ftr", "fl", "fdtt", "dfr", " filt", "fredta", "frwt", "fdnt", "fcp", "FDT", "ftd", "dfte", "afttt", "fdp", "lnw", "flt", "fdw", "fdl", "feedT", "dfT", "feedr", "fdc", "FDp", "FDtd", " filc", "fdT", "dfnt", "dft", "finnt", "fdte", " fidc", "fts", "fdts", "FDit", "dfts", "lnt", "fcwt", "fta", " filts", "fmT", "fredt", " filw", "fct", "fcts", "dftd", "flw"], "fdt_sz": ["fdt_enspect", "fdt_szn", "fdt_sq", "fdt_sst", "fdt_Sz", "fdt_sdst", "fdt_mpect", "fdt_aszi", "fdt_miz", "fdt_insq", "fdt_szi", "fdt_sld", "fdt_sgn", "fdt_ensld", "fdt_insz", "fdt_lsld", "fdt_sdzn", "fdt_Sld", "fdt_rsq", "fdt_ssz", "fdt_cv", "fdt_mld", "fdt_ssst", "fdt_asz", "fdt_siz", "fdt_sdz", "fdt_tsld", "fdt_sszn", "fdt_mz", "fdt_getsv", "fdt_rsz", "fdt_lsgn", "fdt_getsiz", "fdt_rsiz", "fdt_getsce", "fdt_ciz", "fdt_lsz", "fdt_asld", "fdt_cce", "fdt_getsz", "fdt_ssiz", "fdt_sce", "fdt_cz", "fdt_Sq", "fdt_tsz", "fdt_Siz", "fdt_tsgn", "fdt_tszi", "fdt_Spect", "fdt_ensiz", "fdt_insiz", "fdt_asgn", "fdt_spect", "fdt_lszi", "fdt_sdiz", "fdt_ensz", "fdt_sv"], "ram_low_sz": ["ram_low_Sz", "ram_low_Sq", "ram_low_sq", "ram_low_sze", "ram_low_sgn", "ram_low_Siz", "ram_low_esiz", "ram_low_rsz", "ram_low_sx", "ram_low_esz", "ram_low_rsze", "ram_low_insj", "ram_low_dsz", "ram_low_sld", "ram_low_esgn", "ram_low_sj", "ram_low_insZ", "ram_low_Sj", "ram_low_esze", "ram_low_rsgn", "ram_low_SZ", "ram_low_Sld", "ram_low_insz", "ram_low_dsZ", "ram_low_insld", "ram_low_siz", "ram_low_insiz", "ram_low_Sx", "ram_low_dsiz", "ram_low_dsq", "ram_low_sZ", "ram_low_rsiz", "ram_low_insx"], "ram_high_sz": ["ram_high_ll", "ram_high_Szi", "ram_high_giz", "ram_high_sZ", "ram_high_dsiz", "ram_high_lZ", "ram_high_csiz", "ram_high_cszi", "ram_high_gz", "ram_high_Sl", "ram_high_siz", "ram_high_sci", "ram_high_gzi", "ram_high_csl", "ram_high_Sz", "ram_high_dszi", "ram_high_lzi", "ram_high_dsz", "ram_high_liz", "ram_high_lz", "ram_high_gci", "ram_high_Siz", "ram_high_dsZ", "ram_high_szi", "ram_high_dsci", "ram_high_sl", "ram_high_csz"]}}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n#if CONFIG_ZLIB\n\n    AVIOContext ctx;\n\n    uint8_t *cmov_data;\n\n    uint8_t *moov_data; /* uncompressed data */\n\n    long cmov_len, moov_len;\n\n    int ret = -1;\n\n\n\n    avio_rb32(pb); /* dcom atom */\n\n    if (avio_rl32(pb) != MKTAG('d','c','o','m'))\n\n        return AVERROR_INVALIDDATA;\n\n    if (avio_rl32(pb) != MKTAG('z','l','i','b')) {\n\n        av_log(c->fc, AV_LOG_ERROR, \"unknown compression for cmov atom !\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_rb32(pb); /* cmvd atom */\n\n    if (avio_rl32(pb) != MKTAG('c','m','v','d'))\n\n        return AVERROR_INVALIDDATA;\n\n    moov_len = avio_rb32(pb); /* uncompressed size */\n\n    cmov_len = atom.size - 6 * 4;\n\n\n\n    cmov_data = av_malloc(cmov_len);\n\n    if (!cmov_data)\n\n        return AVERROR(ENOMEM);\n\n    moov_data = av_malloc(moov_len);\n\n    if (!moov_data) {\n\n        av_free(cmov_data);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    avio_read(pb, cmov_data, cmov_len);\n\n    if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)\n\n        goto free_and_return;\n\n    if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0)\n\n        goto free_and_return;\n\n    atom.type = MKTAG('m','o','o','v');\n\n    atom.size = moov_len;\n\n    ret = mov_read_default(c, &ctx, atom);\n\nfree_and_return:\n\n    av_free(moov_data);\n\n    av_free(cmov_data);\n\n    return ret;\n\n#else\n\n    av_log(c->fc, AV_LOG_ERROR, \"this file requires zlib support compiled in\\n\");\n\n    return AVERROR(ENOSYS);\n\n#endif\n\n}\n", "idx": 6112, "substitutes": {"c": ["tc", "mc", "sc", "t", "cm", "cp", "p", "co", "cv", "f", "vc", "v", "ec", "lc", "cont", "pc", "ic", "dc", "C", "con", "w", "cc", "abc", "icc", "h", "fc", "b", "g", "uc", "cmp", "cf", "e", "ci", "cam", "m", "xc", "ca", "cs", "ct", "ac", "cas", "nc", "bc"], "pb": ["tc", "py", "vp", "pp", "cp", "p", "apy", "pkg", "bps", "td", "bj", "tf", "lp", "tmp", "PB", "sp", "ps", "pc", "fb", "mp", "pg", "typ", "wp", "cb", "txt", "pm", "ub", "pa", "pro", "pt", "px", "bs", "proc", "np", "bb", "emb", "erb", "buf", "peer", "tp", "pool", "jp", "dp", "bp", "eb", "pl", "uf", "stab", "sb", "tx", "ob", "tk", "sys", "rb", "pan", "ab", "wb"], "atom": ["orm", "key", "entry", "phys", "p", "conf", "pot", "element", "tmp", "binary", "orb", "att", "data", "nt", "to", "app", "msg", "xml", "typ", "tar", "obj", "node", "prop", "or", "o", "pt", "attribute", "mat", "attr", "ap", "asm", "proc", "b", "np", "index", "name", "het", "adj", "at", "atomic", "term", "type", "opt", "y", "ata", "om", "op", "um", "m", "pair", "unit", "base", "part", "num", "x", "and", "tm", "item", "kat", "cmd", "n", "al", "tab", "article", "out", "ab"], "ctx": ["tc", "sc", "cp", "p", "conf", " cx", "pkg", "cv", "tmp", "conn", "wx", "lc", "tz", "dc", "txt", "obj", "cb", "loc", "cc", "cur", "abc", "j", "gc", "px", "fc", "ns", " context", "np", "wd", "sys", "cmp", "cf", " ac", "jp", "cfg", "xs", "xc", "conv", "hw", "ct", " buf", "ac", "tx", "cmd", "kw", "cas", "context", " sc", "ctl", "nc", "bc"], "cmov_data": ["cmnov_ata", "cmova_len", "cmov__Data", "cmovpyata", "cmove_area", "cmvo_dat", "cmove_len", "cmove_length", "cmov_dat", "cmov_area", "cmov_no", "cmovpyData", "cmove_buf", "cmnov_dat", "cmov____dat", "cmov_addr", "cmov2data", "cmov____bin", "cmnovpyData", "cmvo____mem", "cmvo_data", "cmov8addr", "cmov7len", "cmov____mem", "cmov__data", "cmvo_mem", "cmov8len", "cmvo____dat", "cmnovpyata", "cmov_bin", "cmov2type", "cmov7data", "cmove_type", "cmov_buf", "cmov__dat", "cmov7area", "cmova_no", "cmov_bus", "cmov_Data", "cmov____data", "cmnovpydata", "cmove_ata", "cmov2len", "cmov_type", "cmovpydat", "cmov7length", "cmov__ata", "cmvo_bin", "cmnov_Data", "cmov2addr", "cmova_data", "cmove_data", "cmov8data", "cmvo____bin", "cmvo____data", "cmov_ata", "cmnov_data", "cmnovpydat", "cmov8type", "cmov_mem", "cmov_length", "cmova_bus", "cmove_addr", "cmovpydata"], "moov_data": ["movo_mem", "moov_", "monov_", "moove_len", "moov_length", "moove_num", "poovalobj", "moov_type", "moov_num", "moaj_len", "moov_mem", "moove_", "poovobj", "moaj_size", "moove_type", "moaj_mem", "moove_data", "moove_bytes", "mooval_", "moov_size", "monovobj", "poov_", "moov_str", "movo_length", "mooveobj", "moov_bytes", "moovalobj", "moove_Data", "movo_data", "movo_str", "moaj_data", "moovobj", "moov_Data", "pooval_"], "cmov_len": ["cmove_syn", "cmov_win", "cmove_len", "cmove_length", "cmovitywin", "cmob_len", "cmov_l", "cmov_lon", "cmovi_len", "cmnov_win", "cmovitlength", "cmovtlen", "cmovitl", "cmov2length", "cmove_el", "cmov_den", "cmnov_lon", "cmov2Len", "cmovtdata", "cmov_syn", "cmnovitylen", "cmovtlength", "cmnovitywin", "cmovitdata", "cmob_den", "cmov2len", "cmovi_length", "cmovitlen", "cmob_length", "cmovitylen", "cmov2den", "cmov_el", "cmove_Len", "cmove_data", "cmnov_len", "cmovtl", "cmov_Len", "cmnovitylon", "cmob_Len", "cmove_mem", "cmovi_data", "cmovi_l", "cmov_mem", "cmovitylon", "cmov_length"], "moov_len": ["moovatlon", "moov_l", "moovo_str", "moaven_rel", "moovtdata", "moaven_ler", "moov__str", "moov__den", "moovtsize", "moove_len", "moova_lon", "moovo_den", "moov_en", "moovo__el", "moovtlen", "moovo_len", "moovo__len", "moov2str", "moaven_len", "moov3len", "moova_data", "moovatdata", "moov_fin", "moova_len", "moov3ler", "moovo_el", "moove_en", "moov_lp", "moov_rel", "moova_gen", "moov_lon", "moov_def", "moova_fin", "moova_ls", "moovo__den", "moovJsize", "moov_ls", "moov3rel", "moov_lib", "moove_data", "moovJdata", "moovi_lib", "moovi_l", "moaven_lp", "moov__len", "moovi_ls", "moov_size", "moov_den", "moov2den", "moov_str", "moov2el", "moovo__str", "moova_size", "moovJlen", "moov_ler", "moovtlon", "moov2len", "moove_def", "moovatsize", "moovJlon", "moov__el", "moov3lp", "moov_gen", "moovi_len", "moovatlen", "moov_el"]}}
{"project": "FFmpeg", "commit_id": "170870b77c8c71304f9eae946d49aa5e30a464bc", "target": 1, "func": "static int sdp_parse_rtpmap(AVFormatContext *s,\n\n                            AVCodecContext *codec, RTSPStream *rtsp_st,\n\n                            int payload_type, const char *p)\n\n{\n\n    char buf[256];\n\n    int i;\n\n    AVCodec *c;\n\n    const char *c_name;\n\n\n\n    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and\n\n     * see if we can handle this kind of payload.\n\n     * The space should normally not be there but some Real streams or\n\n     * particular servers (\"RealServer Version 6.1.3.970\", see issue 1658)\n\n     * have a trailing space. */\n\n    get_word_sep(buf, sizeof(buf), \"/ \", &p);\n\n    if (payload_type >= RTP_PT_PRIVATE) {\n\n        RTPDynamicProtocolHandler *handler;\n\n        for (handler = RTPFirstDynamicPayloadHandler;\n\n             handler; handler = handler->next) {\n\n            if (!strcasecmp(buf, handler->enc_name) &&\n\n                codec->codec_type == handler->codec_type) {\n\n                codec->codec_id          = handler->codec_id;\n\n                rtsp_st->dynamic_handler = handler;\n\n                if (handler->open)\n\n                    rtsp_st->dynamic_protocol_context = handler->open();\n\n                break;\n\n            }\n\n        }\n\n    } else {\n\n        /* We are in a standard case\n\n         * (from http://www.iana.org/assignments/rtp-parameters). */\n\n        /* search into AVRtpPayloadTypes[] */\n\n        codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);\n\n    }\n\n\n\n    c = avcodec_find_decoder(codec->codec_id);\n\n    if (c && c->name)\n\n        c_name = c->name;\n\n    else\n\n        c_name = (char *) NULL;\n\n\n\n    if (c_name) {\n\n        get_word_sep(buf, sizeof(buf), \"/\", &p);\n\n        i = atoi(buf);\n\n        switch (codec->codec_type) {\n\n        case CODEC_TYPE_AUDIO:\n\n            av_log(s, AV_LOG_DEBUG, \"audio codec set to: %s\\n\", c_name);\n\n            codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;\n\n            codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;\n\n            if (i > 0) {\n\n                codec->sample_rate = i;\n\n                get_word_sep(buf, sizeof(buf), \"/\", &p);\n\n                i = atoi(buf);\n\n                if (i > 0)\n\n                    codec->channels = i;\n\n                // TODO: there is a bug here; if it is a mono stream, and\n\n                // less than 22000Hz, faad upconverts to stereo and twice\n\n                // the frequency.  No problem, but the sample rate is being\n\n                // set here by the sdp line. Patch on its way. (rdm)\n\n            }\n\n            av_log(s, AV_LOG_DEBUG, \"audio samplerate set to: %i\\n\",\n\n                   codec->sample_rate);\n\n            av_log(s, AV_LOG_DEBUG, \"audio channels set to: %i\\n\",\n\n                   codec->channels);\n\n            break;\n\n        case CODEC_TYPE_VIDEO:\n\n            av_log(s, AV_LOG_DEBUG, \"video codec set to: %s\\n\", c_name);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    return -1;\n\n}\n", "idx": 6125, "substitutes": {"s": ["sc", "t", "os", "S", "ds", "south", "f", "a", "is", "v", "spec", "ctx", "q", "sm", "sl", "w", "set", "ss", "h", "space", "ns", "js", "sq", "sys", "g", "an", "sts", "sg", "rs", "gs", "es", "sn", "e", "m", "simple", "conv", "fs", "sv", "cs", "x", "us", "z", "sw"], "codec": ["podig", "peduc", "castac", "packig", "oderer", "codet", "celleco", "codender", "cryptfc", " codect", "pedect", "coduc", " codet", "typerer", "Codoc", "CodEC", "codoe", "Codec", " codica", "codef", "packeca", "predec", "Codrc", "podet", " coderer", "podec", " codef", "odeco", "rotect", "codac", " codoe", " codac", "cmdect", "odec", "odener", "codeca", " coduc", " codEC", "Codoe", "objec", "codect", "rotec", "castec", "typec", "codener", " codeca", "predener", "cellec", "codEC", "pedeco", " codener", "objeca", " codoc", "odeca", "cmdiac", "codfc", " codisc", "odica", "objener", "cryptEC", "codig", "odfc", "odac", "odoe", "Coderer", " codender", "cmdec", "pedef", "podeca", "casteco", "codiac", " codrc", "codeco", "pedeca", "odEC", "cmdef", "cdrc", "packet", "codrc", "cdec", " codeco", "codisc", "odisc", "odoc", "cdoc", "cmdac", "Codisc", "roteco", "packec", "pedec", "predeca", "cmduc", "odiac", "coderer", "typfc", " codiac", "objoc", "cdEC", "castEC", "codoc", "codica", "pedEC", "cmdeca", "cryptec", "typeca", "rotender", "cryptica", "predEC", "cellect", " codfc", "cellender", " codig"], "rtsp_st": ["rtspe_st", "rtsps_stream", "rtsp_stream", "rtssp_con", "rtspckst", "rtsptstream", "rtsspckcon", "rtsps_st", "rtsptst", "rtsp_start", "rtsp_cont", "rtssp_stream", "rtsp2sc", "rtssp_cont", "rtspckcon", "rtssp_st", "rtsp2stream", "rtsspckstream", "rtsptcon", "rtspe_start", "rtsspckst", "rtspckcont", "rtsptcont", "rtspe_stream", "rtsp_con", "rtspckstream", "rtsspckcont", "rtsp2st", "rtsps_sc", "rtsp_sc"], "payload_type": ["payload_ype", "payloadPype", "payloads_type", "payloads_TYPE", "payload_Type", "payloadPtype", "payloadPType", "payloads_name", "payloads_ype", "payloads_tag", "payloadPname", "payload_TYPE", "payloads_Type", "payload_tag", "payload_name"], "p": ["vp", "pp", "t", "cp", "pkg", "lp", "f", "a", "v", "sp", "r", "ps", "ctx", "pc", "pass", "post", "ping", "q", "pas", "wp", "w", "prop", "pa", "k", "h", "pad", "pt", "b", "np", "par", "point", "pn", "g", "pb", "pard", "tp", "jp", "op", "m", "P", "bp", "pi", "part", "x", "pid", "pe", "n", "pos", "params"], "buf": ["pkg", "msg", "txt", "str", "cur", "Buff", "text", " br", "fp", "iter", "db", "bp", "uf", "tx", "queue", "box", " buffer", " buff", "cmd", "cp", "pack", "data", "ctx", "mu", "xff", "w", "h", "buff", "mem", "b", "pb", "buffer", "raw", " cmd", "seq", "pause", "block", "ait", "bh", "cb", "Buffer", "port", "br", "pad", "bs", "off", " arr", "cap", "pool", "cam", " b", "conv", "bag", "out", "img", "vp", " tmp", "doc", "cv", "tmp", "v", "req", "history", " buffers", "bytes", "result", "window", "bin", "cache", "rb", "err", "bc", "wb", "batch"], "i": ["capacity", " I", "init", "li", "ori", "ki", "fi", "bi", "is", "l", "ii", " ni", "v", "ini", "mi", "length", " bi", "mu", "it", "ic", "\u0438", "hi", "si", "ish", "oi", "di", "j", "adi", "gi", "o", "io", "ip", "b", "index", "info", "ui", "multi", "iu", "xi", "y", "zi", "ti", "ci", "m", "ami", "ai", "pi", "im", "ni", "qi", "I", "phi", "cli", "n", " ii", "ati"], "c": ["tc", "mc", "rc", "sc", "cu", "cp", "co", "cm", "conf", "ch", "com", "f", "d", "vc", "cat", "ec", "lc", "dc", "C", "con", "coll", "cd", "cb", "cc", "abc", "cn", "cr", "fc", "uc", "cmp", "cf", "enc", "ci", "cam", "can", "ca", "etc", "ce", "cs", "ct", "ac", "cod", "u", "nc", "bc"], "c_name": [" c__names", "c_type", "code_name", " c__name", "dc_type", "c__NAME", "cnamenames", "c_data", "ec_Name", "codeopkey", "cnamename", "c_path", "rc___NAME", "copname", "crowmodel", "crowname", "codeoplink", "rc_name", "c__alias", "c___alias", " c_value", "ec_NAME", "cnamevalue", "c2name", "copkey", "c_link", "code_key", "crowlink", "c__path", "c___NAME", " c__value", "c_key", "ec_name", "code_link", "c_value", "c2NAME", "rc_NAME", " c_names", "codeopname", "code_model", "c_NAME", "c_model", "cnamepath", " c__path", "codeopmodel", "crowkey", "rc_alias", "c2Name", "rc___name", "c___name", "c__names", "dc_data", "dc_key", "c_names", "dc_name", "rc___alias", " c_path", "coplink", "c_Name", "copmodel", "c_alias", "c__value", "c__name"], "handler": ["host", "full", "filter", "menu", "error", "connection", "handle", "interesting", "only", "parser", "layer", "how", "unknown", "loop", "loader", "er", "Handler", "managed", "event", "hand", "through", "dev", "no", "way", "data", "worker", "done", "check", "obj", "folder", "or", "h", "later", "profile", "driver", "pointer", "index", "usage", "timeout", "new", "handled", "holder", "instance", "runner", "magic", "lambda", "finder", "context", "man", "shape", "failed", "wrapper", "entry", "controller", "func", "policy", "reader", "here", "when", "manager", "definition", "sh", "command", "engine", "older", "owner", "writer", "callback", "function", "hander", "actor", "inner", "processor", "hook", "ready", "server", "style", "attribute", "history", "info", "iterator", "job", "test", "window", "client", "player", "timer"]}}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "void ff_mpv_frame_end(MpegEncContext *s)\n\n{\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    /* redraw edges for the frame if decoding didn't complete */\n\n    // just to make sure that all data is rendered.\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {\n\n        ff_xvmc_field_end(s);\n\n    } else\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    emms_c();\n\n\n\n    if (s->current_picture.reference)\n\n        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n\n}\n", "idx": 6140, "substitutes": {"s": ["sc", "t", "os", "S", "p", "sports", "ds", "f", "times", "ms", "v", "r", "ps", "q", "w", "ss", "sf", "h", "aws", "comm", "bs", "js", "ns", "ex", "b", "hs", "sq", "g", "ses", "sts", "sg", "scl", "rs", "gs", "ts", "e", "stats", "m", "fs", "its", "sv", "aunts", "cs", "ims", "sb", "c", "ls", "ats", "qs", "n", "states"], "xvmc_acceleration": ["xvmc_accelation", "xvmc_accentometer", "xvmc_acccelering", "xvmc_acceling", "xvmc_accelator", "xvmc_accceleration", "xvmc_accenting", "xvmc_accelometer", "xvmc_accentation", "xvmc_accceling", "xvmc_acccelometer", "xvmc_accelerator", "xvmc_accelering", "xvmc_acccelation", "xvmc_acccelerator", "xvmc_accelerometer", "xvmc_acccelator", "xvmc_accentator", "xvmc_acccelerometer"], "FF_ENABLE_DEPRECATION_WARNINGS": ["FF_ENABLE_DEPRECATION_WARNs", "FF_ENABLE_DEPRECATION_ERRORs", "FF_ENABLE_DEPRECATION_WARs", "FF_ENABLE_DEPRECATION_WARNINGs", "FF_ENABLE_DEPRECATION_ERRORS", "FF_ENABLE_DEPRECATION_WARS", "FF_ENABLE_DEPRECATION_WARNS"]}}
{"project": "FFmpeg", "commit_id": "b67f3d65757e9b08a797f584ee818ad7cfe7b303", "target": 1, "func": "static int read_ffserver_streams(AVFormatContext *s, const char *filename)\n\n{\n\n    int i, err;\n\n    AVFormatContext *ic;\n\n    int nopts = 0;\n\n\n\n    err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL);\n\n    if (err < 0)\n\n        return err;\n\n    /* copy stream format */\n\n    s->nb_streams = ic->nb_streams;\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        AVStream *st;\n\n        AVCodec *codec;\n\n\n\n        // FIXME: a more elegant solution is needed\n\n        st = av_mallocz(sizeof(AVStream));\n\n        memcpy(st, ic->streams[i], sizeof(AVStream));\n\n        st->codec = avcodec_alloc_context();\n\n        if (!st->codec) {\n\n            print_error(filename, AVERROR(ENOMEM));\n\n            ffmpeg_exit(1);\n\n        }\n\n        avcodec_copy_context(st->codec, ic->streams[i]->codec);\n\n        s->streams[i] = st;\n\n\n\n        codec = avcodec_find_encoder(st->codec->codec_id);\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (audio_stream_copy) {\n\n                st->stream_copy = 1;\n\n            } else\n\n                choose_sample_fmt(st, codec);\n\n        } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            if (video_stream_copy) {\n\n                st->stream_copy = 1;\n\n            } else\n\n                choose_pixel_fmt(st, codec);\n\n        }\n\n\n\n        if(!st->codec->thread_count)\n\n            st->codec->thread_count = 1;\n\n        if(st->codec->thread_count>1)\n\n            avcodec_thread_init(st->codec, st->codec->thread_count);\n\n\n\n        if(st->codec->flags & CODEC_FLAG_BITEXACT)\n\n            nopts = 1;\n\n    }\n\n\n\n    if (!nopts)\n\n        s->timestamp = av_gettime();\n\n\n\n    av_close_input_file(ic);\n\n    return 0;\n\n}\n", "idx": 6160, "substitutes": {"s": ["sc", "t", "os", "S", "ess", "p", "ds", "is", "a", "ms", "l", "v", "sp", "r", "ps", "spec", "ins", "obj", "w", "set", "ss", "aws", "bs", "js", "ns", "b", "sts", "sg", "rs", "gs", "ts", "es", "ops", "stats", "m", "acs", "its", "fs", "sv", "cs", "x", "sb", "als", "c", "ls", "ats", "n", "sys"], "filename": ["fil", "json", "mpeg", "fn", "ame", "family", "f", "sbm", "nil", "v", "SOURCE", "r", "FN", "path", "fle", "file", "prefix", "msg", "txt", "username", "mson", "png", "WARNING", "FIL", "kl", "nm", "source", "asm", "name", "jpg", "kj", "fp", "ename", "fs", "title", "AME", "println", "FS", "til", "Filename", "SourceFile"], "i": ["json", " I", "t", "li", "p", "sim", "bi", "is", "l", "id", "ii", " ni", "v", "ini", "ind", "mi", "ix", " bi", "me", "it", "list", " x", "asi", "hi", "si", "di", "j", "gi", "ri", "iq", "ip", "ie", "ji", "index", "g", "ui", " si", "multi", "iu", "xi", "y", "ij", "zi", "status", " ti", "ci", "ti", "m", "e", "ami", "try", "ai", "pi", " j", "im", "ims", "x", "I", "phi", "qi", "series", "n", "z", "go", "gl", " ii", "batch"], "err": ["fr", "Er", "ei", "order", "gz", "conf", "elt", "rc", "out", "cer", "ln", "priv", "l", "kr", "arr", "ec", "r", "lr", "it", "rr", "eg", "norm", "error", "msg", "txt", "obj", "cb", "str", "or", "die", "here", "h", "br", "cr", "attr", "empty", "asm", "result", "usr", "nr", "buf", "fee", "trace", "pr", "ner", "ir", "iter", "rn", "code", "e", "try", "pl", "cli", "c", "Error", "aaa", "n", "notice", "er", "ev", "timer", "cmd", "mr"], "ic": ["mc", "tc", "ia", "sc", "isc", "et", "p", "ici", "pic", "ig", "ict", "vc", "iac", "lc", "ctx", "wic", "eric", "pc", "it", "ix", "icing", "ics", "aic", "cc", "ive", "ica", "icc", "irs", "ican", "sci", "gc", "sic", "fc", "anc", "iq", "ip", "irc", "ick", "icon", "inc", "rec", "ci", "ric", "ik", "ct", "ac", "c", "lic", "nic", "oc", "IC", "bc", "mic", "ico"], "st": ["stage", "fr", "et", "art", "nt", "cont", "it", "sta", "sl", "str", "ist", "pt", "net", "etc", "stream", "start", "z", "sc", "irst", " est", "sp", "put", "stack", "stri", "obj", " St", "kt", "mt", "sts", "ts", "ck", "stat", "storage", "stru", "th", "tt", "ut", "ost", "cl", "so", "stop", "est", "state", "sh", "std", "stan", "rest", "end", "ct", "nd", "St", "rt", "ST", "ust", "t", "td", "tmp", "sm", "stable", "inst", "set", "ast", "ste", "usr", "step", "act", "store", "must", "sty", "se", "sw"], "codec": ["dedek", "contel", "celleco", "oderer", "challic", "predica", "dedect", "callect", "predac", "ondoc", "cmpec", "compdec", " codect", "ordec", "codpeg", "communica", "cellener", "codeenc", "condpeg", "qualeco", "callEC", "condeco", "dedec", "CodEC", "contc", " codc", "condisc", "odeter", "dependEC", "qualEC", "predeter", "Codec", " codica", "dedeco", "codef", "compcc", "cellEC", "predec", "ordect", "goeca", " coderer", "communerer", "celleca", "odeco", "codac", " codac", "challpeg", "codeica", "equec", "odec", "odener", "codeca", " codEC", "codc", "cmpdec", "dependica", "ldek", "challeco", "qualic", "codect", "communew", "ldec", "coddec", "odel", "codener", "odef", " codeca", "condic", "qualec", "contec", "propec", "codeec", "predener", "cellec", "compec", "codEC", "cellisc", "edec", "contoder", "cododer", "codcc", "odeca", " codoc", "codic", "cryptect", "codek", "propeco", "odica", "equerer", " codek", "orddec", "qualel", "cmpcc", "dependec", "callec", "cryptEC", "odac", "cmpenc", "codedec", "odenc", "odpeg", " codew", "edEC", "predric", "equect", "communec", "Codect", "odew", "condec", "codeco", "condect", "odEC", "codeisc", "codenc", "odc", "condEC", "ondEC", "godec", "ondeco", " codeco", "codisc", "odisc", "predect", "goec", "condica", "challec", "edeca", "odoc", "preddec", "codel", "Codisc", "predel", " cododer", "predeca", "propisc", "celleter", "codeter", "condel", "qualpeg", "cellef", "callisc", "edeco", "coderer", "ododer", "codew", "equef", "codric", "ordeca", "condeca", "ldeco", "dependect", "codecc", "codoc", "codica", "cellerer", "condric", "Codeco", "qualric", "Codpeg", "ldect", "cryptec", "ondec", "odect", "cryptica", "goect", "compenc", "proppeg", "codeeca", "predEC", "condenc", "predisc", "cellect", " codel"]}}
{"project": "FFmpeg", "commit_id": "ff763351e74550df3b9a0465634d1ec48b15b043", "target": 1, "func": "static void uninit(AVFilterContext *ctx)\n\n{\n\n    ZScaleContext *s = ctx->priv;\n\n\n\n    zimg_filter_graph_free(s->graph);\n\n\n    av_freep(&s->tmp);\n\n    s->tmp_size = 0;\n\n}", "idx": 6165, "substitutes": {"ctx": ["tc", "mc", "sc", "cm", "cp", "unc", "jac", " cx", "pkg", "cv", "conn", "ctr", "wx", "pc", "dc", "txt", "cb", "loc", "cc", "crit", "abc", "kt", "fc", "anc", "np", "act", "ij", "cmp", "jp", "ck", "cfg", "xc", "ca", "hw", "ct", "ac", "tx", "bc", "c", "kw", "context", "nc", "cmd"], "s": ["os", "S", "ess", "p", "pkg", "ds", "sk", "is", "a", "sp", "ps", "vs", "sm", "q", "sl", "sam", "set", "ss", "j", "h", "comm", "aws", "st", "bs", "i", "js", "ns", "hs", "b", "sq", "sys", "sh", "sts", "sg", "scl", "rs", "gs", "ts", "stats", "acs", "fs", "sv", "cs", "ims", "sb", "c", "as", "ls", "qs", "ats", "z", "n", "sw", "sa"]}}
{"project": "qemu", "commit_id": "47e04430ed3e6ab835f023a5c84381ca2ce9f4d8", "target": 0, "func": "static void decode_bo_addrmode_post_pre_base(CPUTriCoreState *env,\n\n                                             DisasContext *ctx)\n\n{\n\n    uint32_t op2;\n\n    uint32_t off10;\n\n    int32_t r1, r2;\n\n    TCGv temp;\n\n\n\n    r1 = MASK_OP_BO_S1D(ctx->opcode);\n\n    r2  = MASK_OP_BO_S2(ctx->opcode);\n\n    off10 = MASK_OP_BO_OFF10_SEXT(ctx->opcode);\n\n    op2 = MASK_OP_BO_OP2(ctx->opcode);\n\n\n\n    switch (op2) {\n\n    case OPC2_32_BO_CACHEA_WI_SHORTOFF:\n\n    case OPC2_32_BO_CACHEA_W_SHORTOFF:\n\n    case OPC2_32_BO_CACHEA_I_SHORTOFF:\n\n        /* instruction to access the cache */\n\n        break;\n\n    case OPC2_32_BO_CACHEA_WI_POSTINC:\n\n    case OPC2_32_BO_CACHEA_W_POSTINC:\n\n    case OPC2_32_BO_CACHEA_I_POSTINC:\n\n        /* instruction to access the cache, but we still need to handle\n\n           the addressing mode */\n\n        tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_CACHEA_WI_PREINC:\n\n    case OPC2_32_BO_CACHEA_W_PREINC:\n\n    case OPC2_32_BO_CACHEA_I_PREINC:\n\n        /* instruction to access the cache, but we still need to handle\n\n           the addressing mode */\n\n        tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_CACHEI_WI_SHORTOFF:\n\n    case OPC2_32_BO_CACHEI_W_SHORTOFF:\n\n        /* TODO: Raise illegal opcode trap,\n\n                 if tricore_feature(TRICORE_FEATURE_13) */\n\n        break;\n\n    case OPC2_32_BO_CACHEI_W_POSTINC:\n\n    case OPC2_32_BO_CACHEI_WI_POSTINC:\n\n        if (!tricore_feature(env, TRICORE_FEATURE_13)) {\n\n            tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        } /* TODO: else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_BO_CACHEI_W_PREINC:\n\n    case OPC2_32_BO_CACHEI_WI_PREINC:\n\n        if (!tricore_feature(env, TRICORE_FEATURE_13)) {\n\n            tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        } /* TODO: else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_BO_ST_A_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL);\n\n        break;\n\n    case OPC2_32_BO_ST_A_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LESL);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_A_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL);\n\n        break;\n\n    case OPC2_32_BO_ST_B_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB);\n\n        break;\n\n    case OPC2_32_BO_ST_B_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_UB);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_B_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB);\n\n        break;\n\n    case OPC2_32_BO_ST_D_SHORTOFF:\n\n        gen_offset_st_2regs(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2],\n\n                            off10, ctx);\n\n        break;\n\n    case OPC2_32_BO_ST_D_POSTINC:\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2], ctx);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_D_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10);\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);\n\n        tcg_gen_mov_tl(cpu_gpr_a[r2], temp);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_DA_SHORTOFF:\n\n        gen_offset_st_2regs(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2],\n\n                            off10, ctx);\n\n        break;\n\n    case OPC2_32_BO_ST_DA_POSTINC:\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2], ctx);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_DA_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10);\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);\n\n        tcg_gen_mov_tl(cpu_gpr_a[r2], temp);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_H_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW);\n\n        break;\n\n    case OPC2_32_BO_ST_H_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUW);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_H_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_SHORTOFF:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        gen_offset_st(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_POSTINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        tcg_gen_qemu_st_tl(temp, cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUW);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        gen_st_preincr(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_W_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL);\n\n        break;\n\n    case OPC2_32_BO_ST_W_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUL);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_W_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL);\n\n        break;\n\n    }\n\n}\n", "idx": 6186, "substitutes": {"env": ["et", "conf", "dev", "environment", "pkg", "cv", "config", "conn", "gov", "esc", "ec", "installed", "map", "cb", "server", "setup", "ew", "en", "set", "nv", "req", "eng", "site", "buf", "code", "e", "erd", "cfg", "te", "jp", "esp", "hw", "window", "tx", "param", "kw", "context", "er", "ev", "viron"], "ctx": ["tc", "mc", "sc", "cp", "conf", "jac", " cx", "pkg", "cv", "work", "conn", "mk", "ind", "wx", "sp", "prefix", "cb", "loc", "cc", "setup", "crit", "kt", "req", "kind", "mom", "ann", "asm", "np", "resp", "def", "act", "std", "cmp", "jp", "ck", "cfg", "xs", "xc", "conv", "exec", "hw", "ct", "desc", "tm", "tx", "bc", "tk", "kw", "grad", "xp", "context", "shape", "ctl", "nc", "cmd"], "op2": ["OP4", "typetwo", "oplet", "OPlet", "op4", "ip3", "oper3", "OP2", "iptwo", "op02", "OP02", "OP3", "ip2", " op3", " op1", " op02", "type4", "typelet", "OPtwo", " op0", "r3", "oper2", "oper4", "oper02", "optwo", "type2", "operlet", "opertwo", "op1", "rtwo", "op0", "op3", "oper0", " optwo", "OP0", "ip1"], "off10": ["offerTen", "offTen", "ff2010", "OFFTen", "off0010", "ref50", "refTen", "shift0010", "OFF12", "Off90", "off90", "shift10", "offer12", "offer90", "offset20", " off0010", "offset10", "offerDir", "shift12", "OFF10", "OFF090", "Off50", "Off090", "ref90", "off2010", "ff10", "offDir", "offer50", " off12", "Off10", "Off12", "ff20", "offer2010", "OffTen", "offer090", "offset0010", "offsetDir", "offer20", "off12", "off090", "off50", "off20", "offset2010", "ffDir", "ref10", "offset12", "offer10"], "r1": [" r4", " r3", "p0", "p1", "t0", "dr0", "p3", "dr8", " r8", "dr1", " r0", "r8", "dr4", "r3", "t2", "t1", "p8", "p4", "p2", "r0", "r4", "t3"], "r2": [" r7", "pr2", "nr2", "p0", "nr1", "er02", "p1", "dr02", "p02", "srtwo", " rtwo", "sr02", "pr62", "Rtwo", "dr2", "drlet", "ortwo", "err8", "ertwo", "R2", " r8", "Rb", "err02", "r02", "R1", "artwo", "dr1", "or5", "ar5", " r5", "nrtwo", "nr02", " r62", "rlet", "pr0", "r8", "sr7", "er7", "pb", " r02", "r7", "sr2", "err2", "r5", "rtwo", "rTwo", "er2", "arTwo", "r62", "ar2", "ptwo", " rb", "pr02", "or2", "errtwo", "nr8", "p62", "p2", "plet", "r0", " r0", "rb", "orTwo", " rTwo", "nrlet"], "temp": [" program", " tmp", " prev", " ts", "tv", " gp", "tmp", " tf", " cur", " dc", " mem", " scratch", " tsp", " tw", "mint", "tg", " Temp", " instr", "Temp", " temperature", " buf", " tv", "tx", " unused", " template", " wr", "vt", " bc"]}}
{"project": "qemu", "commit_id": "bee62662a312b99b4418b558a99b3963a4cbff07", "target": 0, "func": "static int kvm_mips_get_fpu_registers(CPUState *cs)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n    int err, ret = 0;\n\n    unsigned int i;\n\n\n\n    /* Only get FPU state if we're emulating a CPU with an FPU */\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)) {\n\n        /* FPU Control Registers */\n\n        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_IR,\n\n                                    &env->active_fpu.fcr0);\n\n        if (err < 0) {\n\n            DPRINTF(\"%s: Failed to get FCR_IR (%d)\\n\", __func__, err);\n\n            ret = err;\n\n        }\n\n        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_CSR,\n\n                                    &env->active_fpu.fcr31);\n\n        if (err < 0) {\n\n            DPRINTF(\"%s: Failed to get FCR_CSR (%d)\\n\", __func__, err);\n\n            ret = err;\n\n        } else {\n\n            restore_fp_status(env);\n\n        }\n\n\n\n        /* Floating point registers */\n\n        for (i = 0; i < 32; ++i) {\n\n            if (env->CP0_Status & (1 << CP0St_FR)) {\n\n                err = kvm_mips_get_one_ureg64(cs, KVM_REG_MIPS_FPR_64(i),\n\n                                              &env->active_fpu.fpr[i].d);\n\n            } else {\n\n                err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FPR_32(i),\n\n                                      &env->active_fpu.fpr[i].w[FP_ENDIAN_IDX]);\n\n            }\n\n            if (err < 0) {\n\n                DPRINTF(\"%s: Failed to get FPR%u (%d)\\n\", __func__, i, err);\n\n                ret = err;\n\n            }\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 6189, "substitutes": {"cs": ["icks", "sc", "cm", "cp", "jac", "ds", "cv", "ces", "css", "cus", "ras", "ec", "ps", "vs", "ctx", "ins", "ics", "ks", "cc", "ss", "CS", "caps", "ys", "gc", "bs", "js", "ns", "cell", "proc", "hs", "sts", "rs", "gs", "ts", "cks", "ck", "acs", "fs", "ce", "csv", "c", "wcs", "Cs", "ls", "s", "cas", "ats", "qs", "acts", "cz", "yes"], "cpu": ["ka", "sc", "cp", "ork", "cv", "config", "conn", "processor", "ec", "ctx", "serv", "gpu", "obj", "node", "cc", "setup", "cn", "gc", "device", "cow", "mem", "proc", "name", "arch", "CPU", "net", "tp", "process", "vm", "cf", "ck", "cmp", "stat", "boot", "cam", "runner", "pu", "core", "hw", "c", "aux", "client", "ola", "cache"], "env": ["stage", "et", "estate", "conn", "ea", "skin", "ie", "ah", "esi", "net", "vm", "db", "esp", "enable", "queue", "email", "loader", "start", "er", "viron", "nc", "cmd", "sc", "ei", "equ", "cp", "extra", "gear", "dev", "door", "environment", "el", "vs", "ctx", "worker", "eg", "stack", "serv", "obj", "ew", "en", "export", "ve", "esm", "eng", "eur", "proc", "exc", "ner", "enc", "runner", "session", "context", "shell", "entry", "den", "config", "eu", "esc", "org", "ext", "nv", "era", "here", " environment", "manager", "eni", "bean", "e", "end", "cam", "te", "engine", "Environment", "ef", "eh", "ev", "vp", "doc", "cv", "v", "ec", "spec", "enter", "server", "eve", "ee", "console", "cfg", "der", "sv", "hw", "window", "desc", "next", "sw"], "err": ["fr", "gz", "conf", "conn", "arr", "it", "error", "msg", "txt", "diff", "str", "ry", "ie", "term", "rar", "iter", "db", "coord", "arm", "er", "cmd", "eas", "ptr", "ach", "r", "obj", "ell", "exc", "ner", "try", "raw", "sys", "rc", "Er", "order", "eor", "priv", "kr", "rr", "cb", "die", "here", "br", "off", "fee", "repl", "rn", "e", "rel", "yr", "Error", "aaa", "virt", "notice", "oe", "ev", "dr", "elt", "warn", "cer", "inner", "ll", "rer", "lr", "norm", "cor", "hz", "req", "cr", "attr", "fer", "result", "usr", "resp", "hr", "nr", "trace", "cfg", "res", "der", "test", "rb", "mr"], "i": ["dr", "t", "li", "ei", "p", "sim", "fi", "bi", "is", "id", "ind", "v", "ii", "ini", "l", "r", "mi", "ix", "me", "it", "ic", "q", "asi", "hi", "si", "oi", "j", "di", "gi", "o", "ri", "in", "iq", "ip", "ie", "ji", "b", "index", "slice", "g", "ui", "multi", "iu", "xi", "y", "ij", "zi", "status", "ci", "ti", "m", "ami", "ai", "pi", " j", "x", "I", "phi", "c", "cli", "n", "u", " ii", "batch"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_loongson_integer(DisasContext *ctx, uint32_t opc,\n\n                                 int rd, int rs, int rt)\n\n{\n\n    const char *opn = \"loongson\";\n\n    TCGv t0, t1;\n\n\n\n    if (rd == 0) {\n\n        /* Treat as NOP. */\n\n        MIPS_DEBUG(\"NOP\");\n\n        return;\n\n    }\n\n\n\n    switch (opc) {\n\n    case OPC_MULT_G_2E:\n\n    case OPC_MULT_G_2F:\n\n    case OPC_MULTU_G_2E:\n\n    case OPC_MULTU_G_2F:\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DMULT_G_2E:\n\n    case OPC_DMULT_G_2F:\n\n    case OPC_DMULTU_G_2E:\n\n    case OPC_DMULTU_G_2F:\n\n#endif\n\n        t0 = tcg_temp_new();\n\n        t1 = tcg_temp_new();\n\n        break;\n\n    default:\n\n        t0 = tcg_temp_local_new();\n\n        t1 = tcg_temp_local_new();\n\n        break;\n\n    }\n\n\n\n    gen_load_gpr(t0, rs);\n\n    gen_load_gpr(t1, rt);\n\n\n\n    switch (opc) {\n\n    case OPC_MULT_G_2E:\n\n    case OPC_MULT_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        opn = \"mult.g\";\n\n        break;\n\n    case OPC_MULTU_G_2E:\n\n    case OPC_MULTU_G_2F:\n\n        tcg_gen_ext32u_tl(t0, t0);\n\n        tcg_gen_ext32u_tl(t1, t1);\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        opn = \"multu.g\";\n\n        break;\n\n    case OPC_DIV_G_2E:\n\n    case OPC_DIV_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_ext32s_tl(t0, t0);\n\n            tcg_gen_ext32s_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);\n\n            tcg_gen_mov_tl(cpu_gpr[rd], t0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"div.g\";\n\n        break;\n\n    case OPC_DIVU_G_2E:\n\n    case OPC_DIVU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"divu.g\";\n\n        break;\n\n    case OPC_MOD_G_2E:\n\n    case OPC_MOD_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"mod.g\";\n\n        break;\n\n    case OPC_MODU_G_2E:\n\n    case OPC_MODU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"modu.g\";\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DMULT_G_2E:\n\n    case OPC_DMULT_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        opn = \"dmult.g\";\n\n        break;\n\n    case OPC_DMULTU_G_2E:\n\n    case OPC_DMULTU_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        opn = \"dmultu.g\";\n\n        break;\n\n    case OPC_DDIV_G_2E:\n\n    case OPC_DDIV_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);\n\n            tcg_gen_mov_tl(cpu_gpr[rd], t0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"ddiv.g\";\n\n        break;\n\n    case OPC_DDIVU_G_2E:\n\n    case OPC_DDIVU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"ddivu.g\";\n\n        break;\n\n    case OPC_DMOD_G_2E:\n\n    case OPC_DMOD_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"dmod.g\";\n\n        break;\n\n    case OPC_DMODU_G_2E:\n\n    case OPC_DMODU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"dmodu.g\";\n\n        break;\n\n#endif\n\n    }\n\n\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s\", opn, regnames[rd], regnames[rs]);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 6193, "substitutes": {"ctx": ["tc", "mc", "cm", "cp", "conf", " cx", "pkg", "tmp", "work", "conn", "obj", "txt", "cb", "cc", "setup", "CC", "KC", " context", "cmp", "xc", "hw", "ct", "tx", "bc", "Context", "kw", "context", "nc", "cmd"], "opc": ["copc", "OPx", "oppf", "OPcn", "opx", "oopcs", "iopf", "iopcs", "iopc", "OPpc", "opcin", " opcs", "coppc", "OPf", " opcin", "oppx", "iopcin", "opppc", "oopn", "opcs", "OPc", "copn", "opf", "OPn", "opcn", "iopx", "iopn", "copcn", "oppn", "oopcin", "oppcn", "oopc", "oppc"], "rd": ["dr", "rc", "rod", "th", "ds", "lf", "rer", "d", "ind", "rm", "rw", "dra", "r", "lr", "R", "rss", "rr", "fin", "dd", "rl", "red", "rh", "ld", "req", "ra", "di", "dq", "each", "rid", "sr", "ru", "ri", "cr", "dat", "sd", "rg", "usr", "rx", "hr", "md", "std", "rown", "ird", "rf", "decl", "da", "mid", "ord", "add", "rn", "ck", "wr", "round", "nd", "ren", "RD", "nder", "rb", "err", "mr", "bd"], "rs": ["rc", "ubs", "arts", "ds", "ras", "ms", "ps", "RS", "vs", "ins", "rss", "rr", "pc", "ros", "ks", "rings", "ra", "sr", "ri", "rows", "ris", "bs", "ns", "js", "rates", "ries", "sts", "ars", "ts", "pps", "xs", "fs", "Rs", "cs", "ims", "orts", "ro", "ls", "rys", "s", "ats", "mr"], "rt": ["rc", "fr", "dt", "tt", "bt", "rm", "rw", "r", "nt", "rr", "ft", "rl", "RT", "rh", "vr", "rid", "pt", "wt", "ri", "cr", "adr", "mt", "rx", "hr", "pr", "rf", "rat", "rn", "wr", "tm", "tx", "rb", "vt", "mr"], "opn": ["optN", "hopnp", "OPnp", "OPcn", "opne", " opne", "Opc", " opnp", " opns", "opr", "Opcn", "Opn", "hopn", "hopc", "optne", "optn", "optc", "OPc", "Opns", " opcn", "opnp", "hopr", "OPn", "opcn", "OPr", "oppne", "OPns", " opr", " opN", "opN", "oppn", "opns", "oppc", "oppN"], "t0": ["tt1", " t000", " tzero", "p0", "q000", "t8", "lat0", "T000", "tt0", "ta0", "t050", " T1", "p000", "taZero", "tau", "tt10", "ttZero", "TZero", "ent0", "ent1", "tt050", "T4", "p1", "Tzero", "t10", "t000", "q8", "pt2", "T8", "tt8", "pt0", "t2", "ttos", "ptau", "it0", "T0", "it1", " t00", "ent4", "ta2", "q1", " T8", "T1", "it000", " T10", "lat1", "l0", "q0", "ptZero", "tzero", "T050", "tt000", " t4", "l1", " t8", "taau", "tos", " tau", "Tos", "t4", "latos", " tZero", " t2", "entzero", "tZero", "tt00", " t10", "T00", "t00", "lat050", "l8", " T0"], "t1": ["tt1", "pt001", "token15", "nt1", "dt8", " t9", "t8", " tp", "m01", "wt01", "nt0", "dt1", "lOne", " t15", "wt1", "tt0", "tt15", "m8", "t001", "wt15", " t001", "p8", "atone", "tree9", "tree1", "t01", " t01", "m2", "tree0", "p1", "tdONE", "token1", "pt9", "at0", "td0", "dt001", "tOne", "t7", "T9", "wtp", "TONE", " t7", "tone", "td1", "pt0", "treeONE", "tONE", "t2", "at9", "l7", "at1", "T0", "pt8", "T15", "m1", "tt7", "ptOne", "t15", "Tone", "T1", "p01", "dtOne", "time15", "l0", "ptone", "pt1", "l1", " t8", "t9", "tokenp", "time1", "token01", " t2", " tONE", "tp", " tOne", "ttOne", "ntONE", "p2", "time0"]}}
{"project": "qemu", "commit_id": "7d489dcdf5fd71b5052ffd401b869a627e1c751f", "target": 0, "func": "static void vfio_pci_load_rom(VFIOPCIDevice *vdev)\n\n{\n\n    struct vfio_region_info reg_info = {\n\n        .argsz = sizeof(reg_info),\n\n        .index = VFIO_PCI_ROM_REGION_INDEX\n\n    };\n\n    uint64_t size;\n\n    off_t off = 0;\n\n    size_t bytes;\n\n\n\n    if (ioctl(vdev->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) {\n\n        error_report(\"vfio: Error getting ROM info: %m\");\n\n        return;\n\n    }\n\n\n\n    trace_vfio_pci_load_rom(vdev->vbasedev.name, (unsigned long)reg_info.size,\n\n                            (unsigned long)reg_info.offset,\n\n                            (unsigned long)reg_info.flags);\n\n\n\n    vdev->rom_size = size = reg_info.size;\n\n    vdev->rom_offset = reg_info.offset;\n\n\n\n    if (!vdev->rom_size) {\n\n        vdev->rom_read_failed = true;\n\n        error_report(\"vfio-pci: Cannot read device rom at \"\n\n                    \"%s\", vdev->vbasedev.name);\n\n        error_printf(\"Device option ROM contents are probably invalid \"\n\n                    \"(check dmesg).\\nSkip option ROM probe with rombar=0, \"\n\n                    \"or load from file with romfile=\\n\");\n\n        return;\n\n    }\n\n\n\n    vdev->rom = g_malloc(size);\n\n    memset(vdev->rom, 0xff, size);\n\n\n\n    while (size) {\n\n        bytes = pread(vdev->vbasedev.fd, vdev->rom + off,\n\n                      size, vdev->rom_offset + off);\n\n        if (bytes == 0) {\n\n            break;\n\n        } else if (bytes > 0) {\n\n            off += bytes;\n\n            size -= bytes;\n\n        } else {\n\n            if (errno == EINTR || errno == EAGAIN) {\n\n                continue;\n\n            }\n\n            error_report(\"vfio: Error reading device ROM: %m\");\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 6196, "substitutes": {"vdev": ["cvdev", "avev", "vscan", "vdevice", "evev", "valgu", "valprop", "Vserv", " vgu", "cvdevice", "vcdevice", "tdev", "formgu", " vbuild", "vcomment", "vstat", "varbuild", "valcomment", "cvdebug", "tserv", "mval", " vvar", " vev", " vcomment", " vprop", "vev", "valdev", "vbuild", "mcomment", "vblock", "formserver", "mdebug", "vardev", "vcval", "formswitch", "varnt", "avver", "formstat", "uvblock", "avdev", "vnt", " vdes", "evgo", "uvdef", "avdef", " vdef", "valserver", "formtest", "mdevice", "avbuild", "uvev", "mprop", "evdef", "tdevice", "cvdiv", "vcdev", " vscan", "vcver", "svdev", "svdes", "evplayer", "cvplayer", "avnt", "valswitch", "vdata", "vdb", "formvar", "avplayer", "vplayer", "svdevice", "uvscan", "evdevice", "valgo", "evver", "svver", "valdata", "vgo", "vswitch", "valdevice", "Vdev", "evdb", "vval", "cvval", " vgo", "vccomment", "vcdebug", "vcblock", "vgu", "vvar", " vdiv", "cvver", "cvdef", "cvdes", "uvdev", "svserv", "formdev", " vver", "vdiv", "cvserver", "vver", "evdata", " vdata", " vdebug", "vcdiv", "vrstat", "varev", "evcomment", "vdebug", "Vver", "vcev", " vswitch", " vdb", "svserver", "uvcomment", "evblock", "evscan", " vnt", "Vdevice", "vdef", "vrdev", "vserver", "vdes", "vtest", "vprop", " vtest", "vserv", " vdevice", "evdev", "tver", " vserver", "vrtest", "vrvar", "mdev", "avdb", " vstat"], "size": ["full", "sum", "ize", "send", "readable", "gs", "height", "area", "now", "sn", "count", "negative", "settings", "start", "n", "general", "izes", "items", "Size", "no", "sp", "data", "done", "scope", "any", "equal", "si", "power", "tes", "empty", "sd", "mem", "index", "name", "large", "serial", "zero", "new", "len", "used", "raw", "storage", "args", "num", "mode", "total", "shape", "capacity", "small", "SIZE", "address", "city", "io", "space", "group", "sh", "amount", "fee", "type", "sample", "cs", "number", "s", "year", "init", "os", "max", "speed", "ms", "length", "to", "sent", "offset", "set", "needed", "complete", " sizes", "time", "info", "g", "memory", "status", "scale", "global", "title", "pos"], "bytes": ["flags", "os", "steps", "items", "eros", "bps", "ds", "details", "times", "classes", "bes", "ms", "ips", "codes", "types", "ales", "ones", "some", "frames", "users", "pointers", "files", "words", "pieces", "gets", "errors", "loads", "outs", "Bytes", "tes", "units", "io", "points", "rows", "bs", "ns", "blocks", "sites", "keys", "gs", "es", "reads", "ops", "xs", "seconds", "lines", "vals", "bits", "uses", "checks", "values", "features", "byte", "cs", "args", "parts", "ls", "les", "pages", "cells", "total", "odes", "resses"]}}
{"project": "qemu", "commit_id": "684e508c23d28af8d6ed2c62738a0f60447c8274", "target": 1, "func": "static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_max_ns);\n\n\n\n        if (max_ns) {\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 6206, "substitutes": {"ctx": ["tc", "mc", "rc", "sc", "cm", "cp", "co", "p", "pkg", "tmp", "work", "conn", "mk", "ctr", "aus", "wx", "nt", "pc", "prefix", "tz", "txt", "cb", "cc", "cur", "kt", "req", "ok", "comm", "gc", "kl", "js", "history", "mt", "resp", "np", "act", "ctrl", "pool", "cmp", "cf", "ck", "jp", "cfg", "xs", "xc", "ca", "etc", "addr", "that", "hw", "ct", "ac", "window", "tm", "tx", "c", "wcs", "cmd", "Context", "kw", "xp", "context", "nc", "bc"], "blocking": ["restricted", "starting", "latest", "limited", "running", "optional", "quiet", "poll", "full", "enabled", "advertising", "checking", "calling", "joining", "being", "cl", "partial", "forcing", "always", "lock", "available", "fully", "confirmed", "ssl", "blocks", "exclusive", "majority", "including", "timeout", "friendly", "locked", "status", "excluding", "ocking", "loading", "speaking", "sharing", "necessary", "broad", "block", "using", "echo", "locking", "ing"]}}
{"project": "qemu", "commit_id": "f1d3b99154138741161fc52f5a8c373bf71613c6", "target": 1, "func": "static void pci_basic(gconstpointer data)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QPCIBus *bus;\n\n    QVirtQueuePCI *tx, *rx;\n\n    QGuestAllocator *alloc;\n\n    void (*func) (const QVirtioBus *bus,\n\n                  QVirtioDevice *dev,\n\n                  QGuestAllocator *alloc,\n\n                  QVirtQueue *rvq,\n\n                  QVirtQueue *tvq,\n\n                  int socket) = data;\n\n    int sv[2], ret;\n\n\n\n    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    bus = pci_test_start(sv[1]);\n\n    dev = virtio_net_pci_init(bus, PCI_SLOT);\n\n\n\n    alloc = pc_alloc_init();\n\n    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 0);\n\n    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 1);\n\n\n\n    driver_init(&qvirtio_pci, &dev->vdev);\n\n    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);\n\n\n\n    /* End test */\n\n    close(sv[0]);\n\n    guest_free(alloc, tx->vq.desc);\n\n    pc_alloc_uninit(alloc);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n    qpci_free_pc(bus);\n\n    test_end();\n\n}\n", "idx": 6217, "substitutes": {"data": ["rc", "p", "f", "d", "r", "mu", " sd", "DATA", "obj", "w", "str", "val", "Data", "device", "dat", "sd", "size", "def", " d", "buf", "ref", "ata", "new", "db", " DATA", "res", " dat", "addr", "window", "bin", "box", "pos", "out"], "dev": ["doc", "den", "de", "disk", "dt", "ds", "conn", "priv", "debug", "d", "v", "nt", "Device", "Dev", "ad", "dd", "gu", "serv", "obj", "w", "loc", "pro", "di", "adv", "ve", "device", "pt", "sd", "driver", "mem", "def", "wd", "DEV", "ver", "buf", "md", "stick", "serial", "vo", "db", "fo", "iv", "rent", "res", "cam", "der", "tr", "test", "hw", "var", "env", "tech", "des", "vol", "go", "ev", "av", "cmd", "dem"], "bus": ["os", "phys", "host", "disk", "pkg", "family", "cus", "cat", "nt", "bur", "board", "ctx", " BUS", "msg", "sync", "loc", "Bus", "mount", "self", "br", "lock", "bs", "chain", "soc", "bal", "proc", "b", "state", "gen", "def", "root", "ver", "buf", "usb", "serial", "type", "boot", "res", "local", "bits", "home", "loop", "base", "ac", "book", "us", "bu", "vol", "block", "box", "pos", "sys", "BUS", "out", "bc", "lib"], "tx": ["tc", "t", "task", "eth", "tt", "ty", "tl", "wx", "ps", "ctx", "tim", "mp", "q", "tz", "tab", "txt", "loc", "ox", "trans", "ax", "st", "lex", "pt", "TX", "ex", "mt", "mx", "pr", "ts", "db", "ti", "tg", "res", "Tx", "tr", "mm", "test", "fx", "ct", "x", "tm", "ta", "tri", "tk", " ty", "context", "rt", "vt", "cmd", "tn"], "rx": ["rc", "dr", "ux", "raf", "rw", "wx", "r", "re", "rack", "ctx", "lr", "rr", "rl", "txt", "loc", "ox", "ax", "ra", "req", "ry", "vr", "lex", "ri", "ru", "cr", "rex", "rou", "mx", "pr", "rs", "rf", "rec", "rax", "rez", "xs", "res", "tr", "x", "rin", "rys", "xp", "rt", "rb", "mr", "fx"], "alloc": ["ptr", "init", "sc", "access", "cu", "util", "oss", "unc", "isc", "toc", "pkg", "disk", "cp", "conn", "priv", "gov", "sec", "org", "ec", "nt", "ctx", "pc", "rss", "scan", "coll", "loc", "ax", "req", "ok", "attr", "soc", "mem", "proc", "fat", "err", "cpu", "buf", "nz", "at", "agg", "ref", "acc", "pool", "can", "enc", "res", "ca", "exec", "iat", "reg", "addr", "all", "ac", "uf", "aux", "vol", "oc", "sys", "urg", "grow"], "func": ["tc", "df", "function", "wrapper", "unc", "fn", "pkg", "rpm", "cast", "f", "fac", "lc", "ctx", "call", "con", "obj", "cb", "cc", "fun", "prop", "method", "fc", "proc", "b", "buf", "cf", "conv", "exec", "grid", "var", "bc", "c", "bin", "vol", "callback", "impl", "nc", "cmd"], "rvq": ["rdvQ", "rdvrue", "rvpQ", "rpQ", "rvpque", "rdvue", "rvrQ", "rvrue", "rvQ", "rdvrq", "rdvque", "rdvq", "rpq", "rvrq", "rvpue", "rpque", "rvrque", "rdvrQ", "rvpq", "rpue", "rdvrque", "rvue", "rvque"], "tvq": ["tgql", "tvqueue", "vdq", "uvdq", "uvqueue", "tgq", "vddq", "vdql", "tgdq", "tvql", "tvdq", "tgqueue", "uvq", "uvql", "vdqueue"], "socket": ["et", "pack", "ser", "th", "Socket", "ty", "sel", "id", "sp", "ec", " sock", "address", "set", "ss", "ocket", "port", "size", "proc", "ssl", "sq", "buf", "timeout", "serial", "addr", "x", "sys", "stream"], "sv": ["ptr", "sc", "syn", "cv", "ds", "vc", "v", "sum", "sp", "vs", "spec", " sd", "sm", "sync", "serv", "vt", "sl", "set", "si", "ss", "nv", "sf", "st", "av", "aws", "sr", "spe", "esm", "ve", "sd", "size", "sq", "buf", "sy", "scl", "sh", "gs", "sa", "su", "ts", "sn", "stats", "vals", "tr", "service", "pse", "cs", "snap", "csv", "sb", "services", "wcs", "s", "sys", "ev", "se", "sw", "uv"], "ret": ["ptr", "out", "t", "p", "lit", "fi", "tmp", "conn", "sel", "RET", "sp", "r", "nt", "cont", "Ret", "it", "sent", "ft", "rets", "val", "set", "j", "st", "sat", "mem", "mt", "result", "resp", "def", "buf", "ref", "buffer", "row", "store", "status", "len", "res", "tr", "vec", "x", "back", "rt", "err"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_full_negative(void)\n\n{\n\n    const char *str = \" \\t -321\";\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, NULL, 0, &res);\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, -321ul);\n\n}\n", "idx": 6241, "substitutes": {"str": ["out", "fr", "t", "p", "Str", "ctr", "arr", "r", "data", "list", "msg", "txt", "w", "obj", "sl", "st", "br", "i", "b", "g", "shr", "rs", "buffer", "text", "ocr", "enc", "res", "tr", "cs", "seq", "STR", "c", "gr", "del", "s", "n"], "err": ["rc", " er", "Er", "dr", "elt", "sim", "ch", " gr", "ctr", "id", "ind", "kr", "arr", "er", "r", "lr", " cr", "rr", "oe", "error", " ptr", "msg", " r", "obj", "urg", " terr", " typ", " error", "br", "cr", "attr", "i", "ex", "resp", "result", "exc", "nr", "act", "sys", "pr", "rs", "iter", "rn", "e", "acc", "res", "rel", "der", "tr", " fr", "gr", "Error", "z", " rc", "ev", "cmd"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static int vnc_validate_certificate(struct VncState *vs)\n\n{\n\n    int ret;\n\n    unsigned int status;\n\n    const gnutls_datum_t *certs;\n\n    unsigned int nCerts, i;\n\n    time_t now;\n\n\n\n    VNC_DEBUG(\"Validating client certificate\\n\");\n\n    if ((ret = gnutls_certificate_verify_peers2 (vs->tls_session, &status)) < 0) {\n\n\tVNC_DEBUG(\"Verify failed %s\\n\", gnutls_strerror(ret));\n\n\treturn -1;\n\n    }\n\n\n\n    if ((now = time(NULL)) == ((time_t)-1)) {\n\n\treturn -1;\n\n    }\n\n\n\n    if (status != 0) {\n\n\tif (status & GNUTLS_CERT_INVALID)\n\n\t    VNC_DEBUG(\"The certificate is not trusted.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n\n\t    VNC_DEBUG(\"The certificate hasn't got a known issuer.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_REVOKED)\n\n\t    VNC_DEBUG(\"The certificate has been revoked.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_INSECURE_ALGORITHM)\n\n\t    VNC_DEBUG(\"The certificate uses an insecure algorithm\\n\");\n\n\n\n\treturn -1;\n\n    } else {\n\n\tVNC_DEBUG(\"Certificate is valid!\\n\");\n\n    }\n\n\n\n    /* Only support x509 for now */\n\n    if (gnutls_certificate_type_get(vs->tls_session) != GNUTLS_CRT_X509)\n\n\treturn -1;\n\n\n\n    if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts)))\n\n\treturn -1;\n\n\n\n    for (i = 0 ; i < nCerts ; i++) {\n\n\tgnutls_x509_crt_t cert;\n\n\tVNC_DEBUG (\"Checking certificate chain %d\\n\", i);\n\n\tif (gnutls_x509_crt_init (&cert) < 0)\n\n\t    return -1;\n\n\n\n\tif (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) {\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_expiration_time (cert) < now) {\n\n\t    VNC_DEBUG(\"The certificate has expired\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_activation_time (cert) > now) {\n\n\t    VNC_DEBUG(\"The certificate is not yet activated\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_activation_time (cert) > now) {\n\n\t    VNC_DEBUG(\"The certificate is not yet activated\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tgnutls_x509_crt_deinit (cert);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6243, "substitutes": {"vs": ["vp", "blogs", "ds", "vers", "ms", "v", "roots", "ps", "links", "inv", "fps", "ss", "posts", "caps", "lists", "views", "changes", "bs", "ns", "js", "hs", "ses", "sts", "rs", "vd", "ts", "vm", "obs", "es", "stats", "lbs", "lines", "verts", "vals", "fs", "sv", "cs", "hw", "ims", "otes", "docs", "wcs", "terms", "ls", "ails", "s", "Vs", "pages", "qs", "vt", "VS", "eps"], "ret": ["deg", "rc", "fail", "t", "reset", "gt", "tmp", "ll", "RET", "v", "nt", "re", "r", "cont", "data", "Ret", "red", "val", "mem", "mt", "result", "resp", "err", "def", "rev", "iter", "code", "res", "try", "tr", "ter", "flag", "x", "back", "alt", "rt", "er", "out"], "status": ["flags", "access", "sc", "check", "ity", "active", "compl", "no", "config", "progress", "success", "temp", "use", "id", "wait", "post", "error", "Status", "msg", "note", "stay", "prefix", "sync", "login", "version", "si", "str", "set", "handle", "st", "valid", "ok", "server", "only", "reason", "size", "confirmed", "STAT", "result", "state", "ssl", "name", "index", "info", "comment", "step", "g", "current", "rev", "admin", "code", "stat", "res", "uses", "comments", "tr", "flag", "summary", "test", "title", "count", "client", "mode", "magic", "message", "out", "sw"], "certs": [" certS", "curs", "ptrids", "ptrps", "certids", "ertids", "certps", "ertts", "cfrs", "ertps", "certS", "certes", "compls", "ptrs", "Certts", " certts", "cfes", "complps", "certrs", "comples", "cfs", "Certs", "cures", "certts", "CertS", "cfcs", "Certrs", "currs", "certcs", "ertcs", "ertrs", "erts", "complids", "ertes", "curcs", " certrs", "ertS", "ptres"], "nCerts": [" ncertments", "nCertits", " ncerti", " ncertabs", " ncertits", " ncertries", "ncertries", "nCookits", "nDocs", " nCertes", "nPKries", " ncerts", "ncertes", "nDoces", "nCookabs", "nPKs", "nVali", "nCertabs", "nPKments", "nCertments", "nVals", "nCerti", " nCerters", " nCertments", "ncertabs", "nVales", "ncertments", " nCerti", "ncerters", " nCertits", "ncertits", "nLocs", "nCerters", "ncerti", "nDoci", "ncerts", " ncerters", "nCooks", "nCertes", "nLocries", " nCertabs", " nCertries", "nLocments", "nCertries", "nDocers", " ncertes", "nCookes", "nValers"], "i": ["dr", "t", "li", "ei", "p", "sim", "fi", "bi", "is", "id", "ind", "ii", "v", "ini", "mi", "ix", "tim", "me", "it", "ic", "gu", "\u0438", "hi", "counter", "si", "di", "j", "gi", "o", "in", "chain", "ip", "ji", "index", "ui", "multi", "iu", "xi", "ir", "ij", "zi", "iter", "y", "cgi", "ci", "ti", "m", "e", "iri", "ai", "pi", "im", "ims", "qi", "I", "phi", "cli", "c", "s", "n", "u", "batch"], "now": ["ptr", "gm", "t", "created", "old", "dt", "max", "tmp", "tt", "since", "sp", "ow", "ctx", "wait", "to", "tz", "ready", "NOW", "Now", "wa", "w", "set", "hold", "or", "st", "here", "ok", "gc", "time", "before", "off", "mt", "when", "current", "today", "at", "date", "new", " Now", "never", " NOW", "after", "raw", "iat", "tr", "test", "tm", "on", "null", "start"], "cert": ["ptr", "key", "out", "t", "pub", "cp", "compl", "cast", "cer", "temp", "conn", "ctr", "card", "sp", "data", "cont", "pg", "msg", "tar", "con", "str", "cur", "crit", "j", "valid", "pt", " Cert", "cr", "chain", "mem", "ssl", "result", "gen", "ver", "ificate", "car", "pr", "trust", "Cert", "crypt", "cf", "cfg", "ca", "pair", "der", "tr", "ert", "ce", "test", "ct", "pl", "client", "c", "alt", "er", "mail", "cmd"]}}
{"project": "qemu", "commit_id": "85df0de4cfe54fd64df7e37448cd152d0c9199a4", "target": 0, "func": "int fw_cfg_add_callback(void *opaque, uint16_t key, FWCfgCallback callback,\n\n                        void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    FWCfgState *s = opaque;\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    if (key >= FW_CFG_MAX_ENTRY || !(key & FW_CFG_WRITE_CHANNEL)\n\n        || len > 65535)\n\n        return 0;\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n\n\n    return 1;\n\n}\n", "idx": 6251, "substitutes": {"opaque": ["paco", "ipaque", "oaco", "opaques", "OPaque", "paque", "oaques", "oaque", "entaques", "pque", "popaque", "opaco", "entient", "opque", "ipque", "opient", "paques", "popient", "ipaques", "entque", "ipaco", "popque", "popaques", "OPient", "entaque", "oque", "OPque", "OPaques"], "key": ["sk", "id", "sum", "path", "q", "str", "k", "handle", "ey", "root", "ver", "net", "y", "row", "page", "count", "event", "query", "dev", "ch", "no", "token", "list", "kid", "any", "kind", "i", "po", "index", "name", "at", "member", "keys", "code", "raw", "ek", "flag", "child", "priority", "header", "num", "mask", "x", "item", "null", "total", "entry", "primary", "temp", "att", "policy", "address", "version", "port", "size", "chain", "ip", "ex", "state", "mac", "fee", "type", "owner", "max", "length", "hash", "position", "prefix", "offset", "link", "info", "act", "trace", "tag", "KEY", "base", "expr", "window", "Key", "ak", "client", "oid", "next", "value", "cache"], "callback": ["function", "config", "conn", "plugin", "handler", "binary", "soon", "func", "CB", "future", "component", "Callback", "call", "msg", "connection", "cb", "native", "phy", "cc", "ff", "handle", "fc", "metadata", "value", "parser", "result", "state", "cell", "bind", "binding", "closure", "timeout", "band", "pb", "buffer", "command", "fp", "back", "library", "message", "background", "context", "wrapper", "cmd", "event", "close"], "callback_opaque": ["callback_obque", "callback_compience", "callback_ipaque", "callback_popacity", "callback_obacity", "callback_operacity", "callback_popaque", "callback_compient", "callback_operaque", "callback_opensaque", "callback_compaque", "callback_opus", "callback_opensient", "callback_opsaque", "callback_ropaque", "callback_compaques", "callback_opience", "callback_operus", "callback_ipience", "callback_opsus", "callback_opque", "callback_popus", "callback_opacity", "callback_ipacity", "callback_opensience", "callback_operaques", "callback_opsaques", "callback_opensacity", "callback_ropacity", "callback_compacity", "callback_popaques", "callback_ropque", "callback_opient", "callback_obaque", "callback_ropaques", "callback_opsacity", "callback_ipient", "callback_obaques", "callback_compque", "callback_opaques"], "data": ["out", "extra", "no", "binary", "d", "length", "done", "to", "mu", "image", "DATA", "padding", "any", "partial", "val", "Data", "pad", "device", "empty", "dat", "size", "body", "action", "ns", "bytes", "info", "buf", "timeout", "response", "type", "buffer", "text", "ata", "area", "ops", "content", "results", "rel", "raw", "bits", "table", "missing", "all", "window", "bin", "message", "pos", "input", "value", "cache", "batch"], "len": ["fil", "t", " l", "lim", "compl", "elt", "fn", "el", "lf", "lp", "ln", "ll", "limit", "Len", "l", "tl", "length", "nt", "fin", "msg", "coll", " le", "loc", "str", "val", "fun", "ld", "en", "lon", "fl", "dl", "kl", "size", "fc", "lvl", "mem", "bytes", "buf", " bl", "wid", "enc", "cmp", "all", " length", "pl", "num", "seq", "lic", "ls", "vol", "nl", "lan", "n", "pos", "err", " clen", "lib"], "s": ["t", "os", "S", "p", "ds", "details", "ii", "r", "ps", "spec", "ins", "vs", "w", "less", "ss", "j", "h", "o", "comm", "st", "changes", "bs", "i", "js", "ns", "hs", "b", "sq", "g", "ses", "sts", "rs", "store", "gs", "status", "ts", "sn", "e", "stats", "m", "fs", "sv", "bis", "ants", "sb", "c", "services", "als", "ls", "n", "qs", "sys", "ats", "ers", "se", "sw", "states"]}}
{"project": "FFmpeg", "commit_id": "3e1028c625e11d9d19376f5c88267de1cee8fa70", "target": 1, "func": "static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],\n\n                                   int order, int qlevel, int len, int bps)\n\n{\n\n    int i, j;\n\n    int ebps = 1 << (bps-1);\n\n    unsigned sigma = 0;\n\n\n\n    for (i = order; i < len; i++)\n\n        sigma |= decoded[i] + ebps;\n\n\n\n    if (sigma < 2*ebps)\n\n        return;\n\n\n\n    for (i = len - 1; i >= order; i--) {\n\n        int64_t p = 0;\n\n        for (j = 0; j < order; j++)\n\n            p += coeffs[j] * (int64_t)decoded[i-order+j];\n\n        decoded[i] -= p >> qlevel;\n\n    }\n\n    for (i = order; i < len; i++, decoded++) {\n\n        int32_t p = 0;\n\n        for (j = 0; j < order; j++)\n\n            p += coeffs[j] * (uint32_t)decoded[j];\n\n        decoded[j] += p >> qlevel;\n\n    }\n\n}\n", "idx": 6272, "substitutes": {"decoded": ["desode", " decoding", "decoding", "encoder", "descoded", " decode", " decded", "descaned", "ecoder", "delcoded", "decached", "ecoded", "descoding", "decaned", "decode", "ecrypted", " decrypted", "decaled", "definedoded", "ecded", "deded", "definedrypted", "descode", "decoder", "definedoding", "ecaled", " deccoded", "ecached", "deloded", " decached", "octcoded", " decaled", "decrypted", "definedcoded", "decded", "octoding", "deloding", "Decoded", "encaled", "deoded", "Deccoded", "ecoding", " decoder", "octoded", "eccoded", "enccoded", "Decoding", "ecayed", "encoded", " decayed", "ecaned", "decayed", "octrypted", "ecode", "encode", "Decrypted", " decaned", "desoder", "desoded", "delayed", "deached", "deccoded", "encoding"], "coeffs": [" coffjs", "CoefficientS", "coefficientss", "coffes", "coefficientes", " coffiths", " coffs", "coefficientsts", " coeffiths", "coeffics", "coffs", " coeffes", "coffiths", "coffS", "coefficjs", "coefficientts", " coeffjs", "coefjs", "coffjs", "Coefficientts", "Coefficients", "coeffjs", "coefficientS", "coeffes", "coeffS", " coffes", "Coeffts", "coefficientiths", "CoeffS", "coeffts", "coefs", "Coeffs", "coefficientsS", "coffts", "coefficients", "coeffiths"], "order": ["ptr", "p", "no", "limit", "unit", "id", "score", "r", "length", "ode", "rate", "error", "position", "force", "address", "offset", "ordering", "grade", "en", "ordered", "Order", "depth", "size", "before", "group", "off", "index", "dir", "random", "root", "level", "ice", "over", "type", "seed", "store", "range", "row", "zero", "ord", "rank", "code", "end", "record", "e", "op", "edge", "iter", "ase", "scale", "after", "addr", "orders", "base", "priority", "sequence", "num", "byte", "count", "mode", "user", "angle", "pe", "block", "pos", "er", "err", "sort"], "qlevel": ["qmode", "iqlow", "iqLevel", "dqscale", "qqlow", "qqscale", "iqlevel", "Qlow", "cflvl", "QLevel", "dqlevel", "qqmode", "qlvl", "qlevels", "qtmode", "qqtest", "qqLevel", "qLevel", "qtlvl", "qtlevel", "cftime", " qlevels", "qttime", "qtest", "qqtime", "Qlvl", "qqlevel", "qqlevels", " qscale", "iqlvl", "qtime", "Qlevel", "qlow", " qtest", "dqlevels", "qqlvl", "dqtest", "cfmode", "qscale", "cflevel"], "len": ["lim", "elt", "den", "fn", "ds", "limit", "el", "lp", "ln", "ll", "lf", "Len", "l", "le", "ind", "arr", "nt", "length", "list", "coll", "lang", "loc", "els", "val", "ld", "en", "grade", "lon", "ell", "dl", "size", "lvl", "vel", "mem", "bytes", "end", "db", "rel", "vec", "all", "seq", "bin", "ls", "lis", "lan", "del", "n", "pos", "nl"], "bps": ["hops", "steps", "grades", "ds", "ips", "ps", "ones", "hz", "days", "inters", "fps", "errors", "bles", "pins", "points", "ONES", "levels", "bs", "ints", "bytes", "tops", "TPS", "iers", "rates", "ries", "gs", "tp", "pps", "ops", "xs", "lines", "bits", "its", "orders", "places", "ls", "s", "ats", "params", "eps"], "i": ["ia", "init", " I", "ei", "li", "ori", "p", "sim", "ki", "bi", "is", "f", "id", "ind", "v", "ii", "l", "ini", "r", "mi", "ix", "me", "it", "list", "ic", "\u0438", "asi", "uri", "si", "oi", "di", "h", "gi", "ri", "in", "io", "ie", "ip", "chain", "ji", "b", "index", "info", "at", "ui", "multi", "iu", "ij", "xi", "y", "zi", "ir", "print", "e", "ci", "ti", "m", "this", "iii", "ami", "ik", "ai", "pi", "im", "ims", "x", "I", "qi"], "j": ["key", "fr", "ng", "kh", "p", "ii", "it", "q", "str", "k", "handle", "di", "pt", "ie", "jump", "adj", "ver", "ijk", "mn", "y", "n", "z", "bo", "json", "dj", "jac", "bj", "r", "jl", "ix", "note", "jc", "obj", "jo", "ge", "ji", "js", "ju", "b", "at", "try", "pi", "je", "on", "jj", "ind", "att", "aj", "br", "bs", "oj", "kj", "uj", "m", "rel", "jit", "by", "ev", "dr", "t", "bi", "v", "other", "g", "Ja", "pr", "ij", "jp", "ja", "job", "J", "next", "bot"]}}
{"project": "FFmpeg", "commit_id": "b853cfe7eaf13b7d4ff3ceba7098544ccc049df8", "target": 0, "func": "static int read_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFormatContext *ic = NULL;\n\n    int err, i, ret;\n\n    int st_index[AVMEDIA_TYPE_NB];\n\n    AVPacket pkt1, *pkt = &pkt1;\n\n    int eof = 0;\n\n    int pkt_in_play_range = 0;\n\n    AVDictionaryEntry *t;\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;\n\n    SDL_mutex *wait_mutex = SDL_CreateMutex();\n\n\n\n    memset(st_index, -1, sizeof(st_index));\n\n    is->last_video_stream = is->video_stream = -1;\n\n    is->last_audio_stream = is->audio_stream = -1;\n\n    is->last_subtitle_stream = is->subtitle_stream = -1;\n\n\n\n    ic = avformat_alloc_context();\n\n    ic->interrupt_callback.callback = decode_interrupt_cb;\n\n    ic->interrupt_callback.opaque = is;\n\n    err = avformat_open_input(&ic, is->filename, is->iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(is->filename, err);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    if ((t = av_dict_get(format_opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Option %s not found.\\n\", t->key);\n\n        ret = AVERROR_OPTION_NOT_FOUND;\n\n        goto fail;\n\n    }\n\n    is->ic = ic;\n\n\n\n    if (genpts)\n\n        ic->flags |= AVFMT_FLAG_GENPTS;\n\n\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    err = avformat_find_stream_info(ic, opts);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"%s: could not find codec parameters\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n\n\n    if (ic->pb)\n\n        ic->pb->eof_reached = 0; // FIXME hack, ffplay maybe should not use url_feof() to test for the end\n\n\n\n    if (seek_by_bytes < 0)\n\n        seek_by_bytes = !!(ic->iformat->flags & AVFMT_TS_DISCONT);\n\n\n\n    is->max_frame_duration = (ic->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (start_time != AV_NOPTS_VALUE) {\n\n        int64_t timestamp;\n\n\n\n        timestamp = start_time;\n\n        /* add the stream start time */\n\n        if (ic->start_time != AV_NOPTS_VALUE)\n\n            timestamp += ic->start_time;\n\n        ret = avformat_seek_file(ic, -1, INT64_MIN, timestamp, INT64_MAX, 0);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"%s: could not seek to position %0.3f\\n\",\n\n                    is->filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    is->realtime = is_realtime(ic);\n\n\n\n    for (i = 0; i < ic->nb_streams; i++)\n\n        ic->streams[i]->discard = AVDISCARD_ALL;\n\n    if (!video_disable)\n\n        st_index[AVMEDIA_TYPE_VIDEO] =\n\n            av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,\n\n                                wanted_stream[AVMEDIA_TYPE_VIDEO], -1, NULL, 0);\n\n    if (!audio_disable)\n\n        st_index[AVMEDIA_TYPE_AUDIO] =\n\n            av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,\n\n                                wanted_stream[AVMEDIA_TYPE_AUDIO],\n\n                                st_index[AVMEDIA_TYPE_VIDEO],\n\n                                NULL, 0);\n\n    if (!video_disable)\n\n        st_index[AVMEDIA_TYPE_SUBTITLE] =\n\n            av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,\n\n                                wanted_stream[AVMEDIA_TYPE_SUBTITLE],\n\n                                (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ?\n\n                                 st_index[AVMEDIA_TYPE_AUDIO] :\n\n                                 st_index[AVMEDIA_TYPE_VIDEO]),\n\n                                NULL, 0);\n\n    if (show_status) {\n\n        av_dump_format(ic, 0, is->filename, 0);\n\n    }\n\n\n\n    is->show_mode = show_mode;\n\n\n\n    /* open the streams */\n\n    if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) {\n\n        stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);\n\n    }\n\n\n\n    ret = -1;\n\n    if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) {\n\n        ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]);\n\n    }\n\n    if (is->show_mode == SHOW_MODE_NONE)\n\n        is->show_mode = ret >= 0 ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT;\n\n\n\n    is->refresh_tid = SDL_CreateThread(refresh_thread, is);\n\n\n\n    if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) {\n\n        stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]);\n\n    }\n\n\n\n    if (is->video_stream < 0 && is->audio_stream < 0) {\n\n        fprintf(stderr, \"%s: could not open codecs\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    if (infinite_buffer < 0 && is->realtime)\n\n        infinite_buffer = 1;\n\n\n\n    for (;;) {\n\n        if (is->abort_request)\n\n            break;\n\n        if (is->paused != is->last_paused) {\n\n            is->last_paused = is->paused;\n\n            if (is->paused)\n\n                is->read_pause_return = av_read_pause(ic);\n\n            else\n\n                av_read_play(ic);\n\n        }\n\n#if CONFIG_RTSP_DEMUXER || CONFIG_MMSH_PROTOCOL\n\n        if (is->paused &&\n\n                (!strcmp(ic->iformat->name, \"rtsp\") ||\n\n                 (ic->pb && !strncmp(input_filename, \"mmsh:\", 5)))) {\n\n            /* wait 10 ms to avoid trying to get another packet */\n\n            /* XXX: horrible */\n\n            SDL_Delay(10);\n\n            continue;\n\n        }\n\n#endif\n\n        if (is->seek_req) {\n\n            int64_t seek_target = is->seek_pos;\n\n            int64_t seek_min    = is->seek_rel > 0 ? seek_target - is->seek_rel + 2: INT64_MIN;\n\n            int64_t seek_max    = is->seek_rel < 0 ? seek_target - is->seek_rel - 2: INT64_MAX;\n\n// FIXME the +-2 is due to rounding being not done in the correct direction in generation\n\n//      of the seek_pos/seek_rel variables\n\n\n\n            ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"%s: error while seeking\\n\", is->ic->filename);\n\n            } else {\n\n                if (is->audio_stream >= 0) {\n\n                    packet_queue_flush(&is->audioq);\n\n                    packet_queue_put(&is->audioq, &flush_pkt);\n\n                }\n\n                if (is->subtitle_stream >= 0) {\n\n                    packet_queue_flush(&is->subtitleq);\n\n                    packet_queue_put(&is->subtitleq, &flush_pkt);\n\n                }\n\n                if (is->video_stream >= 0) {\n\n                    packet_queue_flush(&is->videoq);\n\n                    packet_queue_put(&is->videoq, &flush_pkt);\n\n                }\n\n                if (is->seek_flags & AVSEEK_FLAG_BYTE) {\n\n                   //FIXME: use a cleaner way to signal obsolete external clock...\n\n                   update_external_clock_pts(is, (double)AV_NOPTS_VALUE);\n\n                } else {\n\n                   update_external_clock_pts(is, seek_target / (double)AV_TIME_BASE);\n\n                }\n\n            }\n\n            is->seek_req = 0;\n\n            eof = 0;\n\n            if (is->paused)\n\n                step_to_next_frame(is);\n\n        }\n\n        if (is->queue_attachments_req) {\n\n            avformat_queue_attached_pictures(ic);\n\n            is->queue_attachments_req = 0;\n\n        }\n\n\n\n        /* if the queue are full, no need to read more */\n\n        if (infinite_buffer<1 &&\n\n              (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE\n\n            || (   (is->audioq   .nb_packets > MIN_FRAMES || is->audio_stream < 0 || is->audioq.abort_request)\n\n                && (is->videoq   .nb_packets > MIN_FRAMES || is->video_stream < 0 || is->videoq.abort_request)\n\n                && (is->subtitleq.nb_packets > MIN_FRAMES || is->subtitle_stream < 0 || is->subtitleq.abort_request)))) {\n\n            /* wait 10 ms */\n\n            SDL_LockMutex(wait_mutex);\n\n            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n\n            SDL_UnlockMutex(wait_mutex);\n\n            continue;\n\n        }\n\n        if (eof) {\n\n            if (is->video_stream >= 0) {\n\n                av_init_packet(pkt);\n\n                pkt->data = NULL;\n\n                pkt->size = 0;\n\n                pkt->stream_index = is->video_stream;\n\n                packet_queue_put(&is->videoq, pkt);\n\n            }\n\n            if (is->audio_stream >= 0 &&\n\n                is->audio_st->codec->codec->capabilities & CODEC_CAP_DELAY) {\n\n                av_init_packet(pkt);\n\n                pkt->data = NULL;\n\n                pkt->size = 0;\n\n                pkt->stream_index = is->audio_stream;\n\n                packet_queue_put(&is->audioq, pkt);\n\n            }\n\n            SDL_Delay(10);\n\n            if (is->audioq.size + is->videoq.size + is->subtitleq.size == 0) {\n\n                if (loop != 1 && (!loop || --loop)) {\n\n                    stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);\n\n                } else if (autoexit) {\n\n                    ret = AVERROR_EOF;\n\n                    goto fail;\n\n                }\n\n            }\n\n            eof=0;\n\n            continue;\n\n        }\n\n        ret = av_read_frame(ic, pkt);\n\n        if (ret < 0) {\n\n            if (ret == AVERROR_EOF || url_feof(ic->pb))\n\n                eof = 1;\n\n            if (ic->pb && ic->pb->error)\n\n                break;\n\n            SDL_LockMutex(wait_mutex);\n\n            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n\n            SDL_UnlockMutex(wait_mutex);\n\n            continue;\n\n        }\n\n        /* check if packet is in play range specified by user, then queue, otherwise discard */\n\n        pkt_in_play_range = duration == AV_NOPTS_VALUE ||\n\n                (pkt->pts - ic->streams[pkt->stream_index]->start_time) *\n\n                av_q2d(ic->streams[pkt->stream_index]->time_base) -\n\n                (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000\n\n                <= ((double)duration / 1000000);\n\n        if (pkt->stream_index == is->audio_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->audioq, pkt);\n\n        } else if (pkt->stream_index == is->video_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->videoq, pkt);\n\n        } else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->subtitleq, pkt);\n\n        } else {\n\n            av_free_packet(pkt);\n\n        }\n\n    }\n\n    /* wait until the end */\n\n    while (!is->abort_request) {\n\n        SDL_Delay(100);\n\n    }\n\n\n\n    ret = 0;\n\n fail:\n\n    /* close each stream */\n\n    if (is->audio_stream >= 0)\n\n        stream_component_close(is, is->audio_stream);\n\n    if (is->video_stream >= 0)\n\n        stream_component_close(is, is->video_stream);\n\n    if (is->subtitle_stream >= 0)\n\n        stream_component_close(is, is->subtitle_stream);\n\n    if (is->ic) {\n\n        avformat_close_input(&is->ic);\n\n    }\n\n\n\n    if (ret != 0) {\n\n        SDL_Event event;\n\n\n\n        event.type = FF_QUIT_EVENT;\n\n        event.user.data1 = is;\n\n        SDL_PushEvent(&event);\n\n    }\n\n    SDL_DestroyMutex(wait_mutex);\n\n    return 0;\n\n}\n", "idx": 6277, "substitutes": {"arg": ["Arg", "doc", "p", "inter", "v", "arr", "argument", "ctx", "pc", "it", "pg", "call", "ag", "w", "arc", "val", "ive", "ax", "adi", "gc", "in", "arp", "ary", "g", "ref", "buffer", "inc", "ar", "op", "jp", "og", "mm", "args", "base", "param", "AR", "out"], "is": ["isc", "id", "it", "ish", "ist", "iso", "stats", "IS", "its", "ik", "ims", "Is", "vs", "ins", "isf", "ics", "isal", "or", "isi", "ris", "js", "at", "does", "ts", "has", "bits", "sis", "ais", "was", "us", "isl", "lis", "isa", "sys", "ia", "ism", "tis", "ys", "ri", "bs", "ip", "iris", "isin", "ires", "rest", "ids", "bis", "ai", "im", "irm", "and", "as", "s", "IC", "init", "os", "oss", "ists", "bi", "ms", "ips", "ies", "inst", "set", "iss", "in", "il", "info", "are", "ui", "ib", "ir", "ar", "es", "ois", "parts"], "ic": ["mc", "tc", "ia", "init", "cu", "et", "ici", "pic", "ict", "vc", " nic", "iac", "circ", "ec", "lc", "ix", "wic", "eric", "it", "pc", "icing", "dc", "ics", "aci", "aic", "icc", "kt", "gc", "sic", "fc", "anc", "ip", "ex", "irc", "ick", "il", "icon", "ib", "cit", "inc", "ij", "op", "ci", "ric", "tic", "iat", "ik", "pi", "ct", "ac", "iz", "cli", "nic", "oc", "kit", "voc", "IC", "bc", "mic", "ico"], "err": ["eas", "fr", "dr", "order", "Er", "gz", "conf", "elt", "dev", "cer", "inner", "ctr", "kr", "score", "arr", "r", "lr", "rr", "norm", "hz", "error", "msg", "my", "tar", "txt", "cb", "str", "val", "any", "or", "req", "die", "errors", "br", "cr", "attr", "js", "outer", "resp", "usr", "result", "nr", "buf", "fee", "pr", "ner", "ber", "rar", "go", "len", "iter", "rn", "e", "repl", "cfg", "res", "coord", "der", "try", "ter", "test", " Err", "count", "c", "Error", "plain", "aaa", "notice", "sys", "er", "ev", "cmd", "mr"], "i": ["ei", "li", "p", "inter", "sim", "ki", "fi", "bi", "id", "ind", "ii", "ini", "mi", "ix", "me", "it", "gu", "\u0438", "si", "oi", "j", "di", "gi", "io", "in", "chain", "ip", "ji", "index", "ui", "multi", "iu", "ij", "ir", "y", "zi", "iter", "xi", "e", "ci", "ti", "m", "ai", "pi", "im", "ims", "x", "I", "phi", "qi", "us", "fire", "n", "u", "batch"], "ret": ["dr", "pub", "elt", "gt", "dt", "fi", "ll", "RET", "cat", "arr", "nt", "mi", "att", "re", "Ret", "fin", "rr", "ft", "rets", "txt", "val", "rem", "gc", "mem", "mt", "result", "resp", "def", "usr", "at", "nz", "rev", "ref", "opt", "mid", "len", "iter", "jp", "print", "res", "rel", "addr", " Ret", "alt", "reply", "rt", "out", "cmd", "tn"], "st_index": ["st_info", "stairind", "str2id", "sttxorder", "stairid", "str2order", "st_number", "ST_number", "str2index", "stxtype", "sttxindex", "stxindex", "stxnum", "sttxid", "stplind", "st_ind", "ST_info", "st_type", "ST_num", "st2id", "stplnumber", "ST_index", "str_index", "st_num", "stplindex", "str_id", "st_id", "stairindex", "sttxind", "stplinfo", "st2ind", "st2num", "st2type", "ST_ind", "str2ind", "st_order", "str_order", "st2index", "str_ind", "st2order", "ST_type", "stairorder"], "pkt1": ["packet0", "pnt1", "pkt0", "pk3", "packet1", "packet3", "cpacket3", "packet2", "cpkt1", "ptx1", "pnt2", "pet1", " pkt3", "ptx8", "cpkt8", "pk1", "pet3", " pet1", " pkt2", "ptx3", " pet2", "pkt8", "pnt0", " pkt0", "packet8", "cpacket1", "pkt2", "pet2", "cpkt3", "cpacket8", "pnt3", "pk8", "pet0", " pet0", " pet3", "pkt3"], "pkt": ["ckt", "pdu", "Pkt", " pct", "cdu", "cacket", "Packet", " pdu", "cct", "pct", "Pct", " packet", "packet", "Pdu"], "t": ["tc", "p", "dt", "tt", "temp", "f", "d", "v", "r", "nt", "to", "it", "vt", "tar", "tap", "txt", "k", "kt", "o", "pt", "g", "tree", "at", "tip", "opt", "ot", "ts", "e", "ti", "te", "tg", "m", "tr", "table", "ct", "ent", "ta", "tm", "c", "rt", "n", "tu", "T", "template"], "opts": ["prots", " opats", " optals", "opms", "opx", "optionstp", "opats", "opgs", "iopps", "opertd", "optionsx", "roptp", "optts", " optgs", "operx", "opals", " opps", "ropx", "opertp", "proms", "optionstd", "optgs", "OPats", "OPs", "optds", "opct", " optts", "optd", "opds", " opct", "OPps", "OPts", " opds", "ops", " ops", " opgs", "optals", "roptd", "operct", "iopts", "proct", "optp", "ropts", "operts", " optds", "optionsts", "opps", " opals", " opms", "iops", "props", "iopats", "operms", "operps"], "orig_nb_streams": ["orig_nb_Streami", "orig_nb_swers", "orig_nb_sws", "orig_nb_lengthings", "orig_nb_roundings", "orig_nb_lengthi", "orig_nb_hostS", "orig_nb_Streamers", "orig_nb_streamers", "orig_nb_rounders", "orig_nb_lengthers", "orig_nb_swings", "orig_nb_rounds", "orig_nb_streamS", "orig_nb_roundS", "orig_nb_Streams", "orig_nb_StreamS", "orig_nb_lengthS", "orig_nb_lengths", "orig_nb_hosts", "orig_nb_hosters", "orig_nb_swS", "orig_nb_hosti", "orig_nb_reamS", "orig_nb_reams", "orig_nb_streamings", "orig_nb_streami", "orig_nb_reamers"], "wait_mutex": ["wait_mtx", "wait_mtex", "wait_mtlock", "wait_Mutlock", "wait_mutx", "wait_muex", "wait_Mutx", "wait_mulock", "wait_mux", "wait_mutlock", "wait_mtix", "wait_mutix", "wait_muix", "wait_Mutex", "wait_Mutix"]}}
{"project": "FFmpeg", "commit_id": "859bb3cfee28efff9c965d4c9320c7837b85849e", "target": 0, "func": "int ff_xvmc_field_start(MpegEncContext *s, AVCodecContext *avctx)\n\n{\n\n    struct xvmc_pix_fmt *last, *next, *render = (struct xvmc_pix_fmt*)s->current_picture.data[2];\n\n    const int mb_block_count = 4 + (1 << s->chroma_format);\n\n\n\n    assert(avctx);\n\n    if (!render || render->xvmc_id != AV_XVMC_ID ||\n\n        !render->data_blocks || !render->mv_blocks) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Render token doesn't look as expected.\\n\");\n\n        return -1; // make sure that this is a render packet\n\n    }\n\n\n\n    if (render->filled_mv_blocks_num) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Rendering surface contains %i unprocessed blocks.\\n\",\n\n               render->filled_mv_blocks_num);\n\n        return -1;\n\n    }\n\n    if (render->allocated_mv_blocks   < 1 ||\n\n        render->allocated_data_blocks <  render->allocated_mv_blocks*mb_block_count ||\n\n        render->start_mv_blocks_num   >= render->allocated_mv_blocks                ||\n\n        render->next_free_data_block_num >\n\n                        render->allocated_data_blocks -\n\n                        mb_block_count*(render->allocated_mv_blocks-render->start_mv_blocks_num)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Rendering surface doesn't provide enough block structures to work with.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    render->picture_structure = s->picture_structure;\n\n    render->flags             = s->first_field ? 0 : XVMC_SECOND_FIELD;\n\n    render->p_future_surface  = NULL;\n\n    render->p_past_surface    = NULL;\n\n\n\n    switch(s->pict_type) {\n\n        case  FF_I_TYPE:\n\n            return 0; // no prediction from other frames\n\n        case  FF_B_TYPE:\n\n            next = (struct xvmc_pix_fmt*)s->next_picture.data[2];\n\n            if (!next)\n\n                return -1;\n\n            if (next->xvmc_id != AV_XVMC_ID)\n\n                return -1;\n\n            render->p_future_surface = next->p_surface;\n\n            // no return here, going to set forward prediction\n\n        case  FF_P_TYPE:\n\n            last = (struct xvmc_pix_fmt*)s->last_picture.data[2];\n\n            if (!last)\n\n                last = render; // predict second field from the first\n\n            if (last->xvmc_id != AV_XVMC_ID)\n\n                return -1;\n\n            render->p_past_surface = last->p_surface;\n\n            return 0;\n\n    }\n\n\n\nreturn -1;\n\n}\n", "idx": 6293, "substitutes": {"s": ["t", "os", "S", "p", "sports", "ds", "details", "is", "times", "a", "v", "ps", "ctx", "vs", "spec", "ins", "eds", "w", "less", "ss", "self", "uploads", "events", "aws", "comm", "h", "views", "bs", "styles", "js", "ns", "hs", "b", "sq", "http", "ses", "sts", "sg", "rs", "gs", "plays", "ts", "es", "e", "this", "stats", "simple", "fs", "its", "aunts", "sv", "cs", "args", "as", "ims", "parts", "c", "als", "settings", "ls", "sb", "des", "ats", "n", "sys", "qs", "series", "params", "sort", "states"], "avctx": [" avcontext", "vrkw", "vercu", "avkw", "uvctx", "vrctx", "vrconn", "avecb", "averconn", "avecas", "airctl", "aircfg", "avercas", "vancfg", "uvconn", "avcu", "aircas", "ivctx", "avercfg", "ajctx", "vercfg", "avjac", "avcfg", "vanctx", "avercb", "avcas", "airctx", "ivcu", "ivcaps", "aveconn", "avjp", "avectx", "ajconn", "avejac", "avctl", "uvcfg", "avekw", "vercaps", "averjac", " avcfg", "avcaps", "averjp", "avectl", "averctl", "avecfg", "avconn", "uvkw", "vancontext", "avercontext", "avcontext", "avercaps", "verctx", "ivcfg", "avercu", "averctx", "avcb", "ajjac", "ajcb", "vanjp", "vrcfg", " avjp"], "last": ["latest", "prev", "query", "old", "max", "full", "l", "length", "Last", "list", "send", "any", "style", "self", "st", "show", "ret", "chain", "jump", "state", "current", "comment", "rev", "rest", "las", "end", "this", "table", "reverse", "base", "all", "final", "nd", "first", "rend", "push", "cache", "close"], "next": ["ptr", "entry", "ng", "latest", "prev", "extra", "primary", "more", "foreign", "button", "gov", "nav", "l", "data", "future", "normal", "append", "big", "txt", "obj", "other", "self", "j", "valid", "ne", "body", "none", "about", "link", "Next", "result", "gen", "mobile", "current", "info", "buf", "response", "ner", "network", "new", "forward", "front", "end", "this", "jp", "after", "head", "follow", "header", "nd", "first", "want", "secondary", "then", "nl", "reply", "start", "n", "video", "second"], "render": ["fr", "reflect", "review", "filter", "send", "plot", "vr", "response", "remote", "display", "hal", "rendered", "user", "rend", "run", "cmd", "embed", "erer", "progress", "play", "draw", "r", "re", "trigger", "transform", "build", "output", "profile", "Render", "proc", "record", "find", "runner", "report", "pen", "raw", "header", "request", "wrapper", "order", "reset", "debug", "respond", "drm", "layout", "format", "state", "download", "detail", "match", "print", "end", "rel", "head", "riot", "writer", "nder", "relation", "html", "form", "evaluate", "req", "complete", "metadata", "design", "result", "dump", "begin", "buf", "trace", "write", "rev", "tag", "front", "rect", "res", "parse", "update", "video", "cache", "player", "frame", "err", "template"]}}
{"project": "FFmpeg", "commit_id": "0eec40b713eee84e2aec8af35ccce059817cad2a", "target": 1, "func": "static int calculate_bitrate(AVFormatContext *s)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    int i, j;\n\n    int64_t lensum = 0;\n\n    int64_t maxpos = 0;\n\n\n\n    for (i = 0; i<s->nb_streams; i++) {\n\n        int64_t len = 0;\n\n        AVStream *st = s->streams[i];\n\n\n\n        if (!st->nb_index_entries)\n\n            continue;\n\n\n\n        for (j = 0; j < st->nb_index_entries; j++)\n\n            len += st->index_entries[j].size;\n\n        maxpos = FFMAX(maxpos, st->index_entries[j-1].pos);\n\n        lensum += len;\n\n    }\n\n    if (maxpos < avi->io_fsize*9/10) // index does not cover the whole file\n\n        return 0;\n\n    if (lensum*9/10 > maxpos || lensum < maxpos*9/10) // frame sum and filesize mismatch\n\n        return 0;\n\n\n\n    for (i = 0; i<s->nb_streams; i++) {\n\n        int64_t len = 0;\n\n        AVStream *st = s->streams[i];\n\n        int64_t duration;\n\n\n\n        for (j = 0; j < st->nb_index_entries; j++)\n\n            len += st->index_entries[j].size;\n\n\n\n        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)\n\n            continue;\n\n        duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp;\n\n        st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num);\n\n    }\n\n    return 1;\n\n}\n", "idx": 6307, "substitutes": {"s": ["t", "os", "p", "S", "sports", "ds", "is", "a", "aus", "ms", "times", "v", "f", "r", "vs", "ps", "ins", "spec", "less", "ss", "aws", "o", "h", "comm", "bs", "ns", "js", "sq", "g", "ses", "sts", "rs", "gs", "ts", "es", "ops", "m", "acs", "fs", "its", "aunts", "sv", "cs", "sis", "ims", "sb", "c", "parts", "ls", "ats", "n", "qs", "sw"], "avi": ["VI", "ia", "ava", "vp", "jac", "vi", "IA", "bi", "vc", "v", "webkit", "mi", "ahi", "opus", "alist", "aci", "aic", "ive", "adi", "ano", "audi", "format", "AV", "ui", "audio", "cam", "ti", "ami", "wav", "iat", "ja", "ai", "pi", "au", "oga", "gra", "cli", "video", "ats", "mic", "av", "ati", "aver"], "i": ["p", "id", "l", "ii", "ini", "it", "hi", "di", "gi", "ie", "iq", "y", "ci", "ami", "ik", "ims", "qi", " ii", "json", " I", "ei", "ix", "ic", "si", "ji", "b", "index", "zi", "record", "try", "pi", "x", "phi", "us", "series", "ia", "is", "ind", "mi", "ri", "ip", "multi", "print", "e", "ti", "m", "ai", "im", "I", "u", "init", "li", "sim", "ki", "bi", "v", "to", "me", "\u0438", "uri", "o", "in", "info", "g", "ui", "iu", "ij", "xi", "ir", "um", "batch"], "j": ["bo", "json", "fr", "ng", "dj", "t", "li", "p", "bj", "bi", "el", "l", "jj", "v", "ind", "att", "er", "jl", "ix", "it", "q", "msg", "note", "jc", "obj", "other", "aj", "str", "k", "jo", "h", "br", "o", "jet", "pt", "ji", "js", "jump", "off", "b", "ie", "ju", "err", "oj", "adj", "g", "at", "bl", "mn", "pr", "ij", "kj", "y", "len", "jp", "uj", "m", "try", "ja", "job", "jen", "jit", "je", "on", "J", "n", "pos", "z", "by", "ev", "out"], "st": ["stage", "art", "nt", "sta", "sl", "str", "ist", "pt", "net", "interface", "sn", "tra", "etc", "lo", "start", "z", "sc", "ace", "irst", "sp", "list", "dd", "stri", "stack", "obj", "ss", "sth", "mt", "proc", "sts", "utt", "stat", "stru", "station", "th", "tt", "lc", "ut", "ost", "ft", "sam", "ld", "so", "stop", "est", "sh", "std", "stan", "rest", "ct", "nd", "St", "rt", "ust", "ST", "dr", "t", "td", "sm", "inst", "stable", "set", "ast", "ste", "lt", "usr", "step", "store", "sv", "must", "sty", "se", "sw"], "duration": ["extra", "doc", "relation", "origin", "d", "volume", "dim", "length", "future", "direction", "ler", " dur", "fd", "padding", "uration", "resolution", "frequency", "urations", "delay", "depth", "vid", "span", "time", "size", "format", "result", "dx", "amount", "timeout", "Duration", "date", "len", "end", "record", "unit", "ni", "window", "number", "runtime", "count", "distance", "trip", "feat", "video", "n", "total", "gl", "uv"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_st16(TCGv val, TCGv addr, int index)\n\n{\n\n    tcg_gen_qemu_st16(val, addr, index);\n\n    dead_tmp(val);\n\n}\n", "idx": 6335, "substitutes": {"val": ["key", "VAL", "p", "cv", "eval", "sel", "vc", "ind", "v", "arg", "arr", "data", "ctx", "msg", "serv", "obj", "txt", "valid", "lex", "ret", "mem", "resp", "def", "b", "buf", "g", "pol", "fee", "act", "ref", "status", "rol", "local", "vals", "test", "ct", "x", "tx", "item", "cal", "cod", "al", "vt", "value", "Val", "uv"], "addr": ["ptr", "dr", "et", "inter", "host", "work", "id", "ind", "ctx", " pos", "ad", " ptr", "address", "obj", "node", "offset", "aj", "loc", "self", "handle", " mem", "gate", "pad", "oad", "align", "mem", " loc", " address", "act", "ref", "alloc", "now", "help", "hw", "var", "tx", "src", "pos", "ack", "add", "urg", "cmd", " act"], "index": ["order", "no", "id", "ind", " sidx", "length", " ind", "position", "address", "offset", "set", "ion", "IND", "location", "size", "i", "point", "slice", "connect", "zero", "inc", "row", "Index", "find", "cond", "coord", "num", "x", "count", "number", "pos", "seek", "add"]}}
{"project": "qemu", "commit_id": "2f295167e0c429cec233aef7dc8e9fd6f90376df", "target": 1, "func": "static void q35_host_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);\n\n\n\n    hc->root_bus_path = q35_host_root_bus_path;\n\n    dc->realize = q35_host_realize;\n\n    dc->props = mch_props;\n\n    /* Reason: needs to be wired up by pc_q35_init */\n\n    dc->user_creatable = false;\n\n    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);\n\n    dc->fw_name = \"pci\";\n\n}\n", "idx": 6346, "substitutes": {"klass": ["Kls", "Kclass", "Klasses", "iklasses", "klasses", " kls", " klasses", "iklass", "tkclass", " kclass", "tklass", "tkls", "tkcl", "ikcl", "ikls", "kclass", " kcl", "Klass", "kls", "tklasses", "ikclass", "kcl"], "data": ["json", "rew", "rc", "dev", "d", "mu", "DATA", " Data", "obj", "w", "di", "Data", "bus", "dat", "result", "def", "name", "info", " d", "type", "ata", "new", " DATA", "res", "m", "bin", "params"], "dc": ["tc", "df", "rc", "doc", "cm", "cp", "cu", "dt", "td", "dm", "ds", "d", "dra", "iac", "ec", "cca", "pc", "dd", "cd", " DC", "cc", "ga", "dk", "di", "gc", "adr", "cr", "fc", "design", "currency", "mac", "da", "du", "dp", "cf", "cam", "db", "ca", "disc", "DC", "cs", "desc", "ac", "bc", "c", "cmd", "oc", "nc", "mc", "bd"], "hc": ["hac", "hdc", " Hbc", "Hci", "hgc", "phci", "hbc", "phc", " Hgc", "Hcc", " hbc", "Hac", "ohac", "phac", "phcc", "ehgc", "hcc", "ohci", " Hdc", "ehbc", "ohc", "hci", "ohcc", "Hc", "ehdc", " Hc", "ehc", " hgc", " hdc"]}}
{"project": "qemu", "commit_id": "340849a9ff2a246bbc9a2da3f079c9fdbd2d5852", "target": 1, "func": "static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr,\n\n                                                 Error **errp)\n\n{\n\n    struct addrinfo ai, *res;\n\n    int rc;\n\n    Error *err = NULL;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n\n\n    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;\n\n    ai.ai_family = inet_ai_family_from_address(saddr, &err);\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return NULL;\n\n    }\n\n\n\n    if (saddr->host == NULL || saddr->port == NULL) {\n\n        error_setg(errp, \"host and/or port not specified\");\n\n        return NULL;\n\n    }\n\n\n\n    /* lookup */\n\n    rc = getaddrinfo(saddr->host, saddr->port, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\",\n\n                   saddr->host, saddr->port, gai_strerror(rc));\n\n        return NULL;\n\n    }\n\n    return res;\n\n}\n", "idx": 6374, "substitutes": {"saddr": ["sqladdon", "slive", "Sconn", "sqladdress", "jsadd", "sqladdr", "ssadd", "sord", "southacre", "sqllive", " saddress", "jspart", "inspart", "sysadd", "sysaddr", "sysadr", "spart", " sadd", " sert", "dsarp", "jsaddress", "dsaddr", "sarp", "saddress", "Saddr", "dsaddress", "ssadr", "southarp", " sarp", "mysaddress", "mysaddr", "dsord", "jsert", "southaddr", "jsaddon", "jslive", "ssert", "sconn", " sord", "dsacre", "sacre", "Sadr", "insaddr", "jsadr", " sadr", "mysaddon", "Saddress", "jsconn", "insaddress", "sadd", "ssaddr", "Sadd", " sacre", "sadr", "jsaddr", "dsadd", "myslive", "Spart", "insconn", "sysaddress", "southord", "saddon", "sert"], "errp": ["errps", "acerP", "sprpy", "rrp", "rrps", "acerp", " errpart", "fxpat", "errpa", " errping", "errorwp", "errpy", "fxpy", "errwp", "ererpc", "rrpc", "errorpart", "rrpa", " errP", "aerps", "acerwp", " errpc", "aerpc", " errwp", "confp", "sprpat", "arrpa", "errpat", "errorp", " errpat", "confpc", "fxp", "aerp", "sprp", "errorP", "errping", "ererping", "errpc", " errpy", "arrpc", "acerpart", "aerpa", "errpart", "arrps", "arrp", "errP", "confping", "ererp"], "ai": [" aux", "pai", "aus", "ii", " ba", " ta", "asi", "hi", "di", "iq", " av", "iam", "air", "ape", "ci", "ami", "oa", "ei", " ali", "aut", "a", "aki", " a", "ali", " ay", "AI", " ga", " am", "i", " wa", "ay", " ap", "ais", "auth", " pa", " fa", "hai", "sa", "ia", "ait", "aa", " au", "api", " an", "mi", "ae", "aci", "aj", "pa", "ass", " da", " ah", "cgi", " ac", "ti", "acs", " acc", " mi", "aaa", "ao", "ain", "aim", "ki", "bi", " na", "ras", " sa", " bi", "oci", " ail", " ca", "ui", "ar", "aq", "addr", "au", " di", " ar", "aug", "ak", "ati"], "res": ["ptr", "reset", "RES", "conn", "full", "ras", "ms", "arr", "r", "re", "RS", "Res", "pas", "obj", "j", "ress", "rem", "gc", "ret", "i", "js", "ex", "mem", "GR", "resp", "result", "resh", "act", "response", "rs", "rev", "ber", "rest", "rec", "rez", "results", "rel", "der", "raw", "reg", "addr", " RES", "gr", "ro", "s", "ack", "out", "mr"], "rc": ["tc", "sc", "isc", "co", "RC", "cv", "sec", "ctr", "ras", "usc", "ec", " ro", " cr", "pc", "rr", "cor", " src", "sync", "rl", "roc", "cd", "cb", "arc", "cur", " ec", "cc", "ry", "ok", "gc", "cr", "fc", "iq", "irc", "rx", "hr", "nr", "nz", "rs", "uc", "cmp", "rn", "rec", "ck", "code", " clen", "ce", "cs", "rin", "src", "c", "rob", " sc", "rt", "ack", "nc", "bc"], "err": ["eas", "fr", "dr", "Er", "ei", "gz", "order", "p", "elt", "eor", "ch", "warn", "cer", "inner", "conn", "kr", "org", "arr", "ec", "r", "lr", "rr", "oe", "error", "cor", "msg", "txt", "cb", "obj", "urg", " terr", "errors", "die", "req", "later", "attr", "rb", "resp", "exc", "usr", "ait", "ah", "erb", "buf", "fee", "rs", "iter", "rn", "erd", "cfg", "der", "esp", "ere", "addr", " Err", "gr", "Error", "aaa", "notice", "er", "ev", "timer", "cmd", "mr"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void bamboo_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    unsigned int pci_irq_nrs[4] = { 28, 27, 26, 25 };\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *isa = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_memories\n\n        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));\n\n    hwaddr ram_bases[PPC440EP_SDRAM_NR_BANKS];\n\n    hwaddr ram_sizes[PPC440EP_SDRAM_NR_BANKS];\n\n    qemu_irq *pic;\n\n    qemu_irq *irqs;\n\n    PCIBus *pcibus;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    uint64_t elf_entry;\n\n    uint64_t elf_lowaddr;\n\n    hwaddr loadaddr = 0;\n\n    target_long initrd_size = 0;\n\n    DeviceState *dev;\n\n    int success;\n\n    int i;\n\n\n\n    /* Setup CPU. */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = \"440EP\";\n\n    }\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, machine->cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    if (env->mmu_model != POWERPC_MMU_BOOKE) {\n\n        fprintf(stderr, \"MMU model %i not supported by this machine.\\n\",\n\n            env->mmu_model);\n\n        exit(1);\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, cpu);\n\n    ppc_booke_timers_init(cpu, 400000000, 0);\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n\n\n    /* SDRAM controller */\n\n    memset(ram_bases, 0, sizeof(ram_bases));\n\n    memset(ram_sizes, 0, sizeof(ram_sizes));\n\n    ram_size = ppc4xx_sdram_adjust(ram_size, PPC440EP_SDRAM_NR_BANKS,\n\n                                   ram_memories,\n\n                                   ram_bases, ram_sizes,\n\n                                   ppc440ep_sdram_bank_sizes);\n\n    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */\n\n    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,\n\n                      ram_bases, ram_sizes, 1);\n\n\n\n    /* PCI */\n\n    dev = sysbus_create_varargs(TYPE_PPC4xx_PCI_HOST_BRIDGE,\n\n                                PPC440EP_PCI_CONFIG,\n\n                                pic[pci_irq_nrs[0]], pic[pci_irq_nrs[1]],\n\n                                pic[pci_irq_nrs[2]], pic[pci_irq_nrs[3]],\n\n                                NULL);\n\n    pcibus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (!pcibus) {\n\n        fprintf(stderr, \"couldn't create PCI controller!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_alias(isa, NULL, \"isa_mmio\",\n\n                             get_system_io(), 0, PPC440EP_PCI_IOLEN);\n\n    memory_region_add_subregion(get_system_memory(), PPC440EP_PCI_IO, isa);\n\n\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    if (pcibus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            /* There are no PCI NICs on the Bamboo board, but there are\n\n             * PCI slots, so we can pick whatever default model we want. */\n\n            pci_nic_init_nofail(&nd_table[i], pcibus, \"e1000\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Load kernel. */\n\n    if (kernel_filename) {\n\n        success = load_uimage(kernel_filename, &entry, &loadaddr, NULL,\n\n                              NULL, NULL);\n\n        if (success < 0) {\n\n            success = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                               &elf_lowaddr, NULL, 1, PPC_ELF_MACHINE,\n\n                               0, 0);\n\n            entry = elf_entry;\n\n            loadaddr = elf_lowaddr;\n\n        }\n\n        /* XXX try again as binary */\n\n        if (success < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (initrd_filename) {\n\n        initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR,\n\n                                          ram_size - RAMDISK_ADDR);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load ram disk '%s' at %x\\n\",\n\n                    initrd_filename, RAMDISK_ADDR);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* If we're loading a kernel directly, we must load the device tree too. */\n\n    if (kernel_filename) {\n\n        if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR,\n\n                                    initrd_size, kernel_cmdline) < 0) {\n\n            fprintf(stderr, \"couldn't load device tree\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n}\n", "idx": 6385, "substitutes": {"machine": ["hello", "achine", "host", "hard", "Machine", "sim", "environment", "config", "controller", "handler", "smart", "common", "green", "man", "entity", "worker", "me", "menu", "policy", "image", "linux", "check", "note", "connection", "node", "server", "alias", "iso", "power", "module", "agent", "device", "gate", "chain", "link", "state", "manager", "computer", "memory", "keeper", "comment", "password", "command", "vm", "process", "display", "m", "instance", "world", "domain", "engine", "model", "job", "zone", "managed", "session", "template", "mode", "magic", "series", "message", "shell", "money", "frame", "mouse", "mc", "monitor"], "kernel_filename": ["kernelpylabel", "system_filename", "kernelpydetails", "kernel_label", "kernellogfilename", "machine_name", "machine_file", "machine_type", "kernelpyfilename", "machine_filename", "kernel_details", "kernel_file", "kernelloglabel", "kernellogfile", "kernel_name", "kernelpyfile", "kernel_type", "system_details", "system_file", "system_label", "kernellogdetails"], "kernel_cmdline": ["kernel_commandlines", "kernel_cmdlink", "kernel_hostlines", "kernel_bindlink", "kernel_extline", "kernel_extlines", "kernel_bindname", "kernel_extlink", "kernel_hostname", "kernel_bindline", "kernel_bindlines", "kernel_cmdname", "kernel_commandlink", "kernel_cmdlines", "kernel_commandline", "kernel_commandname", "kernel_hostline"], "initrd_filename": ["initrd_Filename", "initrs_json", "initrb_files", "initrd__file", "initrdetyfilename", "initrd__files", "initrs_directory", "initrb_filename", "initrd_files", "initrd_directory", "initrdetydirectory", "initrd__filename", "initrd_json", "initrd_file", "initrs_file", "initrs_filename", "initrdetyfile", "initrb_Filename", "initrb_file", "initrd__Filename", "initrdetyjson"], "pci_irq_nrs": ["pci_irq_snrs", "pci_irq2snps", "pci_irq_sris", "pci_irq2snrs", "pci_irq_sodes", "pci_irq_nps", "pci_irq2nodes", "pci_irq_srs", "pci_irq_numodes", "pci_irq_numris", "pci_irq_snodes", "pci_irq_numrs", "pci_irq2nris", "pci_irq_snris", "pci_irq2snodes", "pci_irq_nris", "pci_irq_snps", "pci_irq_numps", "pci_irq_sps", "pci_irq2nps", "pci_irq_nodes", "pci_irq2nrs", "pci_irq2snris"], "address_space_mem": ["address_line_memory", "address_space2mem", "address_space2ram", "address_space_memory", "address_space2map", "address_space_ram", "address_line_map", "address_line_ram", "address_line_mem", "address_space_map", "address_space2memory"], "isa": ["ia", "isc", "aa", "aria", "ea", "is", "ista", "ISA", "ii", "sta", "esa", "asi", "aka", "si", "iso", "amin", "igi", "isi", "iva", "ida", "asa", "ami", "ya", "sis", "ina", "ila", "sha", "iza", "agi"], "ram_memories": ["ram_temologies", "ram_tempory", "ram_histologies", "ram_history", "ram_histos", "ram_temos", "ram_cryptograms", "ram_cryptory", "ram_memologies", "ram_temometers", "ram_tempories", "ram_tempos", "ram_memograms", "ram_histometers", "ram_memos", "ram_cryptories", "ram_memory", "ram_temograms", "ram_histograms", "ram_tempometers", "ram_memometers", "ram_temories", "ram_temory", "ram_cryptologies", "ram_histories"], "ram_bases": ["ram_nbias", "ram_Bias", "ram_nbounds", "ram_Base", "ram_beias", "ram_bounds", "ram_beases", "ram_base", "ram_nbases", "ram_bias", "ram_Bounds", "ram_bease", "ram_nbase", "ram_beounds", "ram_Bases"], "ram_sizes": ["ram_ssizes", "ram_sizers", "ram_ssids", "ram_ssizers", "ram_seizers", "ram_bumbers", "ram_bizes", "ram_bids", "ram_ssumbers", "ram_seumbers", "ram_bizers", "ram_seids", "ram_seizes", "ram_sumbers", "ram_sids"], "pic": ["inis", "ig", "fi", "mi", "eric", "wic", "pc", "ic", "asi", "wp", "txt", "pa", "gc", "isi", "fc", "anc", "pol", "xi", "jp", "cam", "pin", "ik", "pi", "pid", "nic", "pac", "pan", "mc", "mic"], "irqs": ["rinqs", "IRq", " irq", "ireqq", "iorews", "irques", "ireigs", " irews", "rinques", "mirq", "ireqs", "mirews", "mirqs", "iorqs", "irigs", "IRqs", "rinews", "pirews", "ireques", "pirques", "irqq", "pirqs", "mirques", "pirigs", "iorqq", "pirqq", "ireqi", "irqi", "IRqi", "ireews", "IRques", "rinq", " irques", "pirqi", "pirq", "irews", "ireq", "iorigs", "irq"], "pcibus": ["mcia", "mcis", "mcibus", " pcis", "pcia", "pcis", "pciu", "PCiu", "PCia", "PCis", " pcia", "PCibus", "mciu", " pciu"], "cpu": ["uda", "ka", "cu", "cp", "uart", " CPU", "phys", "util", "disk", "cv", "conn", "aco", "processor", "ctx", "mu", "pc", "pixel", "linux", "gpu", "node", "nice", "chip", "uu", "cn", "gc", "php", "device", "cow", "nu", "mem", "proc", "clock", "np", "po", "mac", "computer", "memory", "CPU", "net", "bean", "pool", "process", "vm", "cam", "ck", "boot", "pu", "rom", "ce", "core", "hw", "cum", "ram", "client", "cli", "desktop", "nic", "ola", "cache", "cmd"], "env": ["stage", "et", "conf", "conn", "ea", "em", "alias", "net", "vm", " vm", "db", "esp", "er", "viron", "eas", "ei", "ote", "equ", "extra", "gear", "environment", "el", "except", "vs", "ctx", "app", "worker", "eg", "con", "obj", "ew", "en", "export", "ve", "eng", "device", "mem", "proc", "po", "def", "enc", "ent", " agent", "context", "docker", "entry", "den", "config", "eu", "priv", "common", "ext", "nv", "era", "here", "agent", " environment", "eni", " ent", "e", "end", "te", "engine", "ef", " en", "pe", "oe", "ev", "vt", "dem", "cookie", "v", "ec", "me", "enter", "server", " engine", "ee", "info", "buf", "erd", "hw", "window", "desc", " ev", " envoy"], "elf_entry": ["ipel_info", "elf_ptr", "ipel_entry", "elf2entry", "elf_addr", "ipel_addr", "ipel_ptr", "elf2addr", "elf_info", "elf2ptr", "elf2info"], "elf_lowaddr": ["elf_highptr", "elf_loadaddress", "elf_highaddress", "elf_smalladdress", "elf_lowptr", "elf_loadaddr", "elf_smallr", "elf_smalladdr", "elf_smallptr", "elf_highaddr", "elf_loadr", "elf_lowr", "elf_lowaddress", "elf_highr", "elf_loadptr"], "dev": ["doc", "de", "disk", "ds", "conn", "cho", "Dev", "fin", "gu", "serv", "node", "di", "ve", "device", "sd", "mem", "def", "DEV", "vm", "cam", "vo", "db", "res", "hw", "sys", "ev", "vision"], "success": ["ia", "rc", "os", "d", " o", "Success", "aj", "k", "j", "h", "ok", "o", " successes", "result", "usr", "b", "A", "g", "status", "code", "e", "res", "lo", "num", "s", "go", "err", " clen"], "i": ["ia", "t", "li", "p", "fi", "f", "l", "v", "ii", "r", "mi", "it", "j", "h", "io", "ip", "b", "g", "iu", "y", "e", "ci", "m", "pi", "im", "x", "I", "c"]}}
{"project": "qemu", "commit_id": "6476615d385eb249105b25873ef30ba4b9c808dc", "target": 0, "func": "void HELPER(stpq)(CPUS390XState *env, uint64_t addr,\n\n                  uint64_t low, uint64_t high)\n\n{\n\n    uintptr_t ra = GETPC();\n\n\n\n    if (parallel_cpus) {\n\n#ifndef CONFIG_ATOMIC128\n\n        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);\n\n#else\n\n        int mem_idx = cpu_mmu_index(env, false);\n\n        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);\n\n\n\n        Int128 v = int128_make128(low, high);\n\n        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);\n\n#endif\n\n    } else {\n\n        check_alignment(env, addr, 16, ra);\n\n\n\n        cpu_stq_data_ra(env, addr + 0, high, ra);\n\n        cpu_stq_data_ra(env, addr + 8, low, ra);\n\n    }\n\n}\n", "idx": 6408, "substitutes": {"env": ["et", "conf", "pkg", "conn", "msg", "txt", "cur", "self", "ah", "net", "vm", "db", "esp", "tx", "queue", "er", "nc", "viron", "cmd", "ptr", "sc", "equ", "dev", "environment", "sp", "vs", "ctx", "con", "obj", "w", "en", "En", "ra", "h", "st", "ve", "proc", "enc", "nw", "code", "context", "shell", "rc", "entry", "den", "config", "esc", "org", "cb", "nv", "outer", "eq", "e", "end", "te", "home", "Environment", "EN", "eh", "vt", "ev", "init", "cv", "v", "enter", "pg", "node", "server", "erd", "hw", "window", "desc", "sw"], "addr": ["ptr", "rc", "ace", "dr", "inter", "eth", "pkg", "work", "id", "arr", "r", "ix", "ctx", "ad", "hash", "msg", "address", "obj", "loc", "offset", "alias", "handle", "gate", "pad", "adr", "align", "attr", "arp", "mem", "asm", "name", "act", "arch", "oa", "ref", "store", "ord", "tp", "now", "arity", "coord", "hw", "Address", "expr", "x", "tx", "src", "rt", "sha", "alt", "pos", "ack", "url", "cmd", "add"], "low": ["small", "lim", "old", "lu", "light", "dem", "little", "ind", "l", "le", "Low", "lc", "data", "diff", "hi", "loc", "offset", "pro", "req", "dl", "size", "mem", "level", "slice", "range", "zero", "row", "mid", "len", "now", "ly", "cmp", "flow", "late", "m", "scale", "lo", "lower", "nd", "dis", "mode", "min", "from", "local", "gl", "last"], "high": ["top", "co", "bound", "max", "higher", "alpha", "upper", "full", "v", "re", "length", "hub", "igh", "peak", "hi", "cur", "ra", "h", "rem", "ho", "history", "hist", "sh", "gh", "range", "highest", "large", "hei", "height", "row", "mid", "end", "flow", " High", "High", "pper", "up", "lo", "x", "phi", "final", "med", "vol", "hl", "value", "last", "close"]}}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, long width)\n\n{\n\n#ifdef HAVE_MMX\n\n\tasm volatile(\n\n\t\t\"movq \"MANGLE(bm01010101)\", %%mm4\\n\\t\"\n\n\t\t\"mov %0, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movq (%1, %%\"REG_a\",4), %%mm0\t\\n\\t\"\n\n\t\t\"movq 8(%1, %%\"REG_a\",4), %%mm1\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\"movq %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm4, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm1\t\t\\n\\t\"\n\n\t\t\"movd %%mm0, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movd %%mm1, (%2, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"add $4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t: : \"g\" (-width), \"r\" (src1+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n\t\t: \"%\"REG_a\n\n\t);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tdstU[i]= src1[4*i + 1];\n\n\t\tdstV[i]= src1[4*i + 3];\n\n\t}\n\n#endif\n\n        assert(src1 == src2);\n\n}\n", "idx": 6432, "substitutes": {"dstU": ["dostUU", "dstUV", "destU", "dstoreUF", " dstrEU", "dstoreU", "dstCU", " dstUU", " dstrUV", "DstU", "dstoreUs", "dLstU", "dLstoreUs", "dstUp", " dstrU", "dndUT", "dLstoreU", "dstrEU", "ddestU", "dSTU", "dLstCU", "ddestUT", "dldUs", "dstUU", "DSTUp", "dldCU", " dstEU", "dstoreCU", "dndU", "DstUT", "dctUs", "dstUF", "dSTUp", "destUV", "dostUV", "dLstoreCU", "destEU", "dstrU", "dLstUs", "dSTUT", "dldU", "dostEU", "dctUF", "ddestUp", "DSTUT", "dstrUV", "dLstoreUF", "DstUp", "DSTU", "dndUp", "dstUs", "dLstUF", "dstUT", "dctU", "dctCU", "dostU", "dstEU", "destUU", "dstrUU", "dldUF", " dstUV", " dstrUU"], "dstV": ["dstVW", "dstUV", "sdstVs", "DstP", " dndV", "sdstVW", "sdostVW", "dsetP", "drcN", "DstUV", "dndT", "dstJ", "dsetV", "drcP", "DstV", "dstP", "dndVC", "dstVC", " dndT", "DdestP", "ddestV", " dstVC", " dndVC", "dntVC", "dostVW", "dstN", "DdestUV", "dstVs", "dostV", "ddestUV", "ddestP", "sdostV", "dntJ", "dntG", "drcUV", "drcV", "dndG", "dntVW", "DdestV", "DdestN", "sdstV", "drcG", "dstT", "dmpV", "dndV", "dostVs", "drcVC", "dntVs", "DstN", "drcT", "dstG", "dntV", "sdostJ", "dmpJ", " dndG", " dstT", "ddestN", " dstG", "dntT", "sdstJ", "dsetUV", "sdostVs", "dmpVs", "dmpVW", "dostJ", "dsetN"], "src1": ["dest4", "source3", "source0", "sin0", "source1", "rc01", "src01", "rc0", "source2", " src01", "rc3", " src0", "source4", "dest1", "dest0", "rc4", "rc1", "src4", "src3", "src0", "srcA", "rc2", "dest2", "sin2", " src3", "sourceA", "source01", "sinA", "rcA", "sin1"], "src2": ["source0", "source3", "source1", "inst3", "rc0", "src02", "source2", "rc3", " src0", "inst1", "rc1", "inst2", "rc02", "src3", "src0", "rc2", " src02", " src3", "inst02"], "i": ["key", "p", "id", "ii", "ini", " pi", "it", "asi", "hi", "di", "gi", "slice", "remote", "iter", "ci", "ami", " j", "ims", "qi", "cli", " ii", " I", "ei", " err", "sp", "ix", "ic", "si", "oi", "j", "ji", "b", "index", "name", " v", "zi", "this", " missing", "pi", "x", "phi", "is", "ind", "mi", "depth", "span", "ri", "chain", "ip", "point", "multi", "M", " ti", "ti", "m", "ai", "I", "init", "t", "li", "sim", "ki", "fi", "bi", "v", "me", "\u0438", " x", "uri", "in", "info", "ui", "iu", "xi", "ij", "status", "batch"]}}
{"project": "FFmpeg", "commit_id": "fdbbf2e0fc1bb91a5d735a49f39337eb172e68a7", "target": 0, "func": "static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){\n\n    int i,j,xy,yz;\n\n    int res;\n\n    for(i=0; i<8; i++){\n\n        for(j=1; j<7; j++){\n\n            xy = j * stride + i;\n\n            yz = j * 8 + i;\n\n            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];\n\n            res +=2;\n\n            res >>=2;\n\n            dest[xy] = (uint8_t)res;\n\n        }\n\n    }\n\n}\n", "idx": 6452, "substitutes": {"dest": ["ptr", "master", "save", "temp", "priv", "d", "dist", "v", "cat", "sum", "data", "spec", "list", "scan", "map", "w", "obj", "loc", "trans", "set", "port", "source", "mem", "result", "usr", "est", "decl", "rest", "target", "new", "iter", "tr", "table", "vec", "desc", "Dest", "pos", "out"], "src": ["ur", "sur", "rc", "sc", "ptr", "view", "ch", "ser", "copy", "inner", "syn", "pkg", "sec", "ctr", "usc", "ins", "sync", "inst", "sub", "txt", "sl", "loc", "str", "cur", "Source", "supp", "st", "sr", "in", "secure", "source", "js", "proc", "b", "sq", "comp", "slice", "sh", "rs", "img", "stock", "desc", "sb", "seq", "s", "impl", "rt", "input", "stream", "bc"], "stride": ["frude", "Strude", "stIDE", "STRIDE", "Strade", "STRide", "spate", "Stride", "fride", "STRride", "strate", "spide", "sprade", "state", "spIDE", "STRate", "strride", "strade", "strude", "stide", "sprude", "spride", "frade", "strIDE"], "i": ["ia", "init", " I", "li", "sim", "ki", "bi", "is", "f", "id", "ind", "ii", "v", "ini", "l", "mi", "ix", "me", "it", "ic", "my", "\u0438", "hi", "si", "ish", "di", "h", "o", "io", "ie", "ip", "iq", "ji", "at", "ui", "iu", "multi", "ij", "y", "xi", "zi", "iter", "e", "ti", "ci", "wi", "m", "ami", "iat", "ai", "pi", "im", "ims", "x", "I", "phi", "us", "qi", "ni", "IJ", "by", "n", "z", " ii"], "j": ["json", "fr", "key", "dj", "kh", "p", "jac", "let", "bj", "bi", "el", "jj", "v", "r", "jl", "it", "q", "jc", "obj", "other", "aj", "ion", "jo", "br", "o", "pt", "ge", "bs", "js", "ji", "ie", "jump", "ju", "oj", "at", "ij", "y", "kj", "jp", "uj", "e", "jas", "ja", "job", "jit", "x", "je", "on", "J", "n", "by", "z", "er"], "xy": ["py", "json", "XY", "roxy", "oxy", "cho", "wx", "rot", "ube", "ele", "z", "my", "ox", "hi", "che", "iso", "biz", "wy", "px", "io", "ie", "ey", "dx", "mx", "yx", "zz", "zip", "axy", "y", "ot", "zo", "ay", "fo", "coord", "xxx", "oy", "chan", "foo", "x", "yt", "xx", "sky", "pos", "fy", "oe", "yy"], "yz": ["gz", "dj", "yi", "qq", "iaz", "hz", "tz", "zh", "fy", "ox", "loc", "lat", "uz", "ky", "az", "biz", "yout", "ry", "dq", "wy", "ez", "gy", "iq", "js", "zon", "cart", "sys", "yx", "nz", "zz", "zip", "axy", "y", "ot", "zi", "cy", "xxx", "zy", "oy", "oz", "yt", "zzy", "xx", "eddy", "sky", "z", "cz", "yy", "err", "lib"], "res": ["rc", "VAL", "os", "reset", "prime", "RES", "css", "resource", "ms", "sum", "r", "re", "ps", "Res", "rss", "norm", "obj", "red", "resolution", "val", "cons", "req", "ress", "dq", "rem", "ret", "js", "bs", "mem", "resh", "result", "pres", "def", "resp", "rs", "rest", "stock", "results", "cond", "rel", "vals", "vec", "cs", "expr", "gr", "des", "vol", "z", "sol", "yes"]}}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME(uyvyToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(\n\n        \"mov                  %0, %%\"REG_a\"         \\n\\t\"\n\n        \"1:                                         \\n\\t\"\n\n        \"movq  (%1, %%\"REG_a\",2), %%mm0             \\n\\t\"\n\n        \"movq 8(%1, %%\"REG_a\",2), %%mm1             \\n\\t\"\n\n        \"psrlw                $8, %%mm0             \\n\\t\"\n\n        \"psrlw                $8, %%mm1             \\n\\t\"\n\n        \"packuswb          %%mm1, %%mm0             \\n\\t\"\n\n        \"movq              %%mm0, (%2, %%\"REG_a\")   \\n\\t\"\n\n        \"add                  $8, %%\"REG_a\"         \\n\\t\"\n\n        \" js                  1b                    \\n\\t\"\n\n        : : \"g\" ((x86_reg)-width), \"r\" (src+width*2), \"r\" (dst+width)\n\n        : \"%\"REG_a\n\n    );\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++)\n\n        dst[i]= src[2*i+1];\n\n#endif\n\n}\n", "idx": 6455, "substitutes": {"dst": ["lst", "sest", "sst", "ddest", "dest", "sdest", "hst", " dbr", " dsts", "ldest", " dtd", "dput", "Dtd", "Dput", "Dst", " ddest", "hdest", "hest", "Dbr", "dbr", "sput", " dput", "lbr", "dtd", "Dsts", "lsts", "Ddest", "Dest", " dest", "htd", "dsts"], "src": ["ust", "ptr", "ur", "rc", "sc", "out", "sur", "pack", "RC", "th", "dest", "sec", "ctr", "sup", "dist", "usc", "r", "ins", "rl", "inst", "sub", "txt", "sl", "loc", "str", "cur", "trans", "filename", "via", "req", "st", "supp", "sr", "in", "attr", "source", "proc", "usr", "sq", "sys", "slice", "rs", "ord", "desc", "x", "sb", "seq", "bin", "s", "hl", "rt", "rb", "input", "img", "lib"], "unused": [" unchecked", "sunchecked", "Universe", "sunused", "unuse", "universe", " universe", " unuse", "suniverse", "sunuse", "Unchecked", "Unuse", "unchecked", "Unused"], "i": ["init", " I", "t", "li", " err", "p", "sim", "ki", "bi", "is", "f", "id", "ind", "v", "ii", "ini", "sp", "l", "mi", "ix", " bi", "me", "it", "ic", "gu", "\u0438", "si", "oi", "di", "j", "gi", "span", "ri", "chain", "ip", "b", "index", " v", "multi", "iu", "ui", "xi", "y", "zi", "iter", " ti", "ci", "ti", "m", "status", "try", "ai", " j", "pi", "im", "ims", "x", "I", "phi", "qi", "cli", "uni", "n", "u", " ii", "batch"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_number(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        int64_t decoded;\n\n        int skip;\n\n    } test_cases[] = {\n\n        { \"0\", 0 },\n\n        { \"1234\", 1234 },\n\n        { \"1\", 1 },\n\n        { \"-32\", -32 },\n\n        { \"-0\", 0, .skip = 1 },\n\n        { },\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QInt *qint;\n\n\n\n        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));\n\n        g_assert(qint);\n\n        g_assert(qint_get_int(qint) == test_cases[i].decoded);\n\n        if (test_cases[i].skip == 0) {\n\n            QString *str;\n\n\n\n            str = qobject_to_json(QOBJECT(qint));\n\n            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);\n\n            QDECREF(str);\n\n        }\n\n\n\n        QDECREF(qint);\n\n    }\n\n}\n", "idx": 6486, "substitutes": {"i": ["dr", " I", "t", "li", "ei", "p", "yi", "sim", "init", " iter", "ki", "ori", "bi", "is", "id", "ind", "v", "ii", "ini", "mi", "ix", " bi", " n", "me", "it", "to", "ic", "\u0438", " x", "asi", "uri", "si", "oi", "j", "di", "gi", "ri", "io", "chain", "ip", "ji", "index", "info", " v", "multi", "ui", "iu", "ij", "y", "xi", "zi", "status", " ti", "ci", "ti", "m", "ai", "pi", " index", " j", "ims", "x", "I", "phi", "cli", "series", "n", "go", "gl", " ii", "batch"], "encoded": ["Enccoded", "enached", "decoding", "encoder", "enrypted", "enaled", "Encoded", "ecoder", "Encrypted", "exprypted", "decached", "ecoded", "encleted", "enoded", " decrypted", "decanded", "decaled", "expoding", "decoder", "encached", " encrypted", "ecached", " decoded", "enored", " decaled", "decrypted", "encanded", " encored", "expcoded", "encaled", "enanded", "eccoded", "enccoded", "decored", "encored", " decleted", "Encoding", " encanded", "enoder", "decleted", "encrypted", "expoded", "deccoded", "encoding", "decoded", "enleted"], "test_cases": ["fake_cases", "old_tests", "test2times", "test17features", "update_except", "fake_steps", "old_case", "test___case", " test_times", "test17except", "test___abilities", "test67cases", "train_case", "fake_times", "old___abilities", "test_times", "test_case", "test17drivers", "test67case", "test___cases", "test_except", "train_packs", "test2cases", "test_packs", "old_cases", "test2steps", "train_cases", "test___packs", "test_steps", "update_cases", " test_case", " test_abilities", "update_drivers", "test_drivers", "old___case", "test_tests", "test17cases", "test___tests", "old___cases", "old___tests", "old_abilities", "test_abilities", "test67abilities", "test_features", "update_features"], "qint": ["qqinter", "dqbit", "quinter", "qqind", "qucheck", "qinter", "qui", "qqInt", "quint", "queryINT", "iqpoint", "qstr", "qqint", "queryint", "iqint", "qqpoint", "queryInt", "qbit", "dquint", "dqInt", " qind", " qi", "qINT", " qinit", "qvint", "quinit", "gi", "dqint", "quINT", "iqbit", "qvcheck", " qpoint", " quint", "qind", " qinter", "qvstr", "queryind", "dqcheck", "dqstr", "gint", "qInt", "qinit", "qqINT", "quind", "ginit", " qbit", "qpoint", "dqpoint", "iqinter", "qcheck", "dqinter", "qi", "quuint", " qInt", "qvuint", "gInt", "quInt", "qustr", "qquint"], "str": ["fr", "dr", "t", "p", "Str", "temp", "ctr", "arr", "draw", "r", "sp", "cont", "msg", "txt", "obj", "spr", "ss", "st", "j", "br", "sr", "cr", "chain", "ns", "mt", "g", "buf", "shr", "sts", "pr", "rs", "bl", "text", "String", "print", "tr", "cs", "seq", "STR", "vol", "s", "n", "url", "sw"]}}
{"project": "FFmpeg", "commit_id": "951e715cebfaffced7f13c1525771ff917fe1d38", "target": 1, "func": "static int video_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFrame *frame = avcodec_alloc_frame();\n\n    int64_t pts_int;\n\n    double pts;\n\n    int ret;\n\n\n\n#if CONFIG_AVFILTER\n\n    AVFilterGraph *graph = avfilter_graph_alloc();\n\n    AVFilterContext *filt_out = NULL;\n\n    int64_t pos;\n\n    int last_w = is->video_st->codec->width;\n\n    int last_h = is->video_st->codec->height;\n\n\n\n    if ((ret = configure_video_filters(graph, is, vfilters)) < 0)\n\n        goto the_end;\n\n    filt_out = is->out_video_filter;\n\n#endif\n\n\n\n    for (;;) {\n\n#if !CONFIG_AVFILTER\n\n        AVPacket pkt;\n\n#else\n\n        AVFilterBufferRef *picref;\n\n        AVRational tb;\n\n#endif\n\n        while (is->paused && !is->videoq.abort_request)\n\n            SDL_Delay(10);\n\n#if CONFIG_AVFILTER\n\n        if (   last_w != is->video_st->codec->width\n\n            || last_h != is->video_st->codec->height) {\n\n            av_dlog(NULL, \"Changing size %dx%d -> %dx%d\\n\", last_w, last_h,\n\n                    is->video_st->codec->width, is->video_st->codec->height);\n\n            avfilter_graph_free(&graph);\n\n            graph = avfilter_graph_alloc();\n\n            if ((ret = configure_video_filters(graph, is, vfilters)) < 0)\n\n                goto the_end;\n\n            filt_out = is->out_video_filter;\n\n            last_w = is->video_st->codec->width;\n\n            last_h = is->video_st->codec->height;\n\n        }\n\n        ret = get_filtered_video_frame(filt_out, frame, &picref, &tb);\n\n        if (picref) {\n\n            pts_int = picref->pts;\n\n            pos     = picref->pos;\n\n            frame->opaque = picref;\n\n        }\n\n\n\n        if (av_cmp_q(tb, is->video_st->time_base)) {\n\n            av_unused int64_t pts1 = pts_int;\n\n            pts_int = av_rescale_q(pts_int, tb, is->video_st->time_base);\n\n            av_dlog(NULL, \"video_thread(): \"\n\n                    \"tb:%d/%d pts:%\"PRId64\" -> tb:%d/%d pts:%\"PRId64\"\\n\",\n\n                    tb.num, tb.den, pts1,\n\n                    is->video_st->time_base.num, is->video_st->time_base.den, pts_int);\n\n        }\n\n#else\n\n        ret = get_video_frame(is, frame, &pts_int, &pkt);\n\n#endif\n\n\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (!ret)\n\n            continue;\n\n\n\n        pts = pts_int * av_q2d(is->video_st->time_base);\n\n\n\n#if CONFIG_AVFILTER\n\n        ret = output_picture2(is, frame, pts, pos);\n\n#else\n\n        ret = output_picture2(is, frame, pts,  pkt.pos);\n\n        av_free_packet(&pkt);\n\n#endif\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (step)\n\n            if (cur_stream)\n\n                stream_pause(cur_stream);\n\n    }\n\n the_end:\n\n#if CONFIG_AVFILTER\n\n    avfilter_graph_free(&graph);\n\n#endif\n\n    av_free(frame);\n\n    return 0;\n\n}\n", "idx": 6489, "substitutes": {"arg": ["ng", "Arg", "doc", "p", "inter", "v", "arr", "argument", "ctx", "pc", "it", "ark", "pg", "call", "ag", "obj", "val", "ax", "j", "gc", "in", "arp", "i", "slot", "info", "g", "ref", "inc", "ar", "jp", "og", "mm", "args", "base", "param", "err", "cmd", "event"], "is": ["isc", "times", "id", " indis", "ii", " IS", "it", "ks", "ish", "ist", "iso", "ates", "plays", "stats", "IS", "nis", "its", "isp", "ims", "cms", "Is", "ps", "ins", "ic", "isf", "ics", "any", "isal", "isi", "ris", "i", "js", "does", "ts", "has", "bits", "fs", "sis", "args", "ais", "was", "us", "isl", "lis", "isa", "states", "details", "ism", "tis", "ports", "ri", "bs", "ip", "iris", "isin", "ids", "ars", "ti", "bis", "im", "orts", "as", "terms", "ls", "s", "vis", "init", "os", "oss", "ists", "ms", "ips", " cis", "iss", "mis", "info", "are", "ar", "es", "obs", "ois", "parts"], "frame": ["request", "fr", "dr", "t", "scene", "p", "form", "iframe", "f", "load", " frames", "draw", "channel", "image", "fb", "frames", "position", "msg", "call", "ox", "version", "show", "profile", "word", "link", "proc", "state", "def", "feature", "point", "info", "Frame", "ref", "row", "process", " framed", "zo", "movie", "face", " Frame", " timeframe", "page", "base", "window", "shot", "feat", "video", "block", "message", "picture", "ence", "rame", "out"], "pts_int": ["pts2str", "ptns2int", "pts_Int", "ptns_ints", "pts2inter", "ptxs_int", "pts_inter", "ptns2ints", "pts_str", "ptns_int", "ptns2inter", "ptref", "ptns2str", "pts2int", "ptns_inter", "pts2ints", "ppref", "ptxs_ints", "ptns_str", "pts_ints", "aptref", "ptxs_Int", "iptref"], "pts": ["aptts", "tdts", "tds", "PTts", " ptrsd", "PTn", " ptrts", "ptxs", "aptsd", "portsets", "iptxs", "ptts", "portxs", "iptsets", "PTsd", "ports", "portts", " ptrs", "PTs", "ipts", "tdxs", "ptsets", "apts", "ptn", "iptts", " ptrn", "ptsd", "aptn", "tdsets"], "ret": ["deg", "t", "reset", "elt", "gt", "fi", "f", "ll", "RET", "v", "rm", "att", "nt", "re", "Ret", "it", "hash", "ft", "rets", "val", "fun", "br", "rem", "gc", "mem", "mt", "result", "resp", "def", "err", "at", "net", "rev", "ref", "ber", "len", "status", "print", "res", "det", "cond", "tr", "flag", "reg", " RET", "expr", "desc", "back", "alt", "nl", "reply", "out"], "graph": ["json", "dr", "ng", "query", "github", "host", "p", "jac", "pkg", "raph", "conn", "van", "Graph", "draw", "data", "ctx", "path", "pg", "stack", "connection", "map", "node", "png", "layout", "h", "port", "igraph", "gc", "profile", "gd", "history", "driver", "dict", "gen", "memory", "adj", "g", "tree", "buf", "gh", "net", "network", "sign", "ref", "go", "closure", "pool", "og", "container", "pen", "reg", "session", "window", "qa", "stream", "ograph", "gr", "vol", "box", "context", "man", "shape", "cache", "widget"], "filt_out": ["flt_cache", "fld_in", "filt_in", "filt_ex", "fld_to", "fld_ex", "filtaxyin", "filtaxyout", "filtaxyto", "filt_to", "filt_cache", "filtensum", "filt_co", "fld_sum", "filtenin", "fld_co", "flt_out", "fld_out", "filt_Out", "filtenout", "filtenpool", "filt_sum", "fld_pool", "filt_pool", "flt_Out"], "pos": ["ptr", "top", "t", "os", "doc", "p", "pose", "conf", "limit", "Pos", "ms", "rot", "sp", "data", "ps", "pc", "position", "loc", "offset", "val", "trans", "pro", "port", "st", "pt", "size", "POS", "off", "resp", "po", "def", "slot", "pres", "point", "at", "pr", "ref", "len", "ts", "op", "cond", "res", "base", "x", "pid", "bin", "alt", "start", "z"], "pkt": ["opct", "Pkt", " pct", "opacket", " pkl", "opkt", "Pkl", "Packet", "pct", "Pct", "pkl", "opkl", " packet", "packet"], "picref": ["pictureref", "picturero", "Picref", "pcreference", "igref", " picrel", "piRef", "picRef", "picreference", "pinarg", "icref", "nicro", "Picrel", "nicarg", "pcrel", "nicref", "pegRef", " picreference", "picro", "PicRef", "pireference", "picarg", "pcref", "pegreference", "igRef", "pegrel", "icreference", " picrange", "piref", "pirep", "icrep", "Picreference", "picrange", "pegref", "picrel", "picrep", " picRef", "nicRef", "pinRef", "picturereference", "igreference", "pcRef", "pinro", "pinreference", "igarg", "nicreference", "pcarg", "nicrel", "icRef", "pinrange", "picturearg", "pcrep", "pinref", "pcrange"], "tb": ["rtb", "ptb", " ptrb", " ptb", "rtbl", " ptbase", "tbl", "ptbe", "ctb", " tp", " tbs", "trb", " Tb", "trbs", " tbase", "tbase", " tbl", "ctp", "ctbe", " trb", " Tbase", "ctbb", "rtbs", "trbe", "tbs", "tp", "trbl", " tbe", " tbb", "ptbb", " Tbb", "tbb", "ptp", "rtbe", "tbe", " Trb", " ptbb"]}}
{"project": "qemu", "commit_id": "e13e973eedba0a52b4b8b079c4b85cdc68b7b4f0", "target": 1, "func": "static int ccid_initfn(USBDevice *dev)\n\n{\n\n    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);\n\n\n\n    s->bus = ccid_bus_new(&dev->qdev);\n\n    s->card = NULL;\n\n    s->cardinfo = NULL;\n\n    s->migration_state = MIGRATION_NONE;\n\n    s->migration_target_ip = 0;\n\n    s->migration_target_port = 0;\n\n    s->dev.speed = USB_SPEED_FULL;\n\n    s->notify_slot_change = false;\n\n    s->powered = true;\n\n    s->pending_answers_num = 0;\n\n    s->last_answer_error = 0;\n\n    s->bulk_in_pending_start = 0;\n\n    s->bulk_in_pending_end = 0;\n\n    s->current_bulk_in = NULL;\n\n    ccid_reset_error_status(s);\n\n    s->bulk_out_pos = 0;\n\n    ccid_reset_parameters(s);\n\n    ccid_reset(s);\n\n    return 0;\n\n}\n", "idx": 6500, "substitutes": {"dev": ["doc", "conf", "den", "de", "disk", "dm", "ds", "conn", "priv", "debug", "d", "v", "nt", "Device", "Dev", "ad", "dd", "devices", "serv", "obj", "w", "loc", "prop", "pro", " Dev", "port", "ve", "pad", "device", "o", "bus", "av", "driver", "mem", "proc", "def", "DEV", "ver", "info", "buf", "usb", "serial", "cam", "db", "raw", "home", "test", "hw", "window", "tech", "des", "block", "sys", "ev", "out", "cmd", "dem"], "s": ["l", "locks", "sl", "gets", "ns", "ses", "gs", "y", "stats", "results", "its", "ims", "settings", "n", "qs", "er", "eps", "services", "S", "r", "ps", "vs", "ins", "w", "less", "ss", "j", "h", "mods", "js", "i", "b", "sts", "ts", "ops", "ads", "fs", "args", "us", "ats", "sys", "sol", "ers", "states", "tests", "sports", "details", "is", "sam", "ports", "aws", "bs", "rs", "ids", "m", "conv", "bis", "cs", "as", "ls", "t", "os", "ds", "ms", "spec", "sets", "sync", "set", "hs", "g", "pers", "es", "actions", "sv", "parts"]}}
{"project": "qemu", "commit_id": "5a1972c8472fafd519a68b689fdcaf33ec857945", "target": 1, "func": "static void ppc4xx_pob_reset (void *opaque)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n\n\n    pob = opaque;\n\n    /* No error */\n\n    pob->bear = 0x00000000;\n\n    pob->besr[0] = 0x0000000;\n\n    pob->besr[1] = 0x0000000;\n\n}\n", "idx": 6507, "substitutes": {"opaque": ["ocaque", "opaques", "OPaque", "oaques", "oaque", "popolean", "opllay", "poplay", "oplay", "oplacity", "opolean", "popaque", "opsaque", "opsacity", "oplaque", "opsolean", "oacity", "ocaques", "popacity", "ocacity", "opacity", "OPaques", "OPacity", "opslay", "oplolean"], "pob": ["poz", "proz", "pmoby", " porp", " pog", "Porp", "pub", "pdeb", "pog", "ppog", "proby", "probi", "tiporb", "tipobe", "probs", "porp", " poy", " porb", "pmobi", "pobs", "tipob", "paoz", "pobi", "pmoz", "pmob", " pobe", "paob", "pingob", "prob", "ppob", " pobi", "pporb", "pingobe", "ppobb", "poy", "proy", " pobs", " pdeb", "pobe", "poby", "Porb", "pmobs", "prorp", "porb", "prub", "pingorb", "pmoy", " pub", "Pobb", "Pob", "paoby", "Pub", " pobb", "tipdeb", "Pog", "pingdeb", "pobb", "paoy", "probb"]}}
{"project": "FFmpeg", "commit_id": "5d20f19be25c973fe10d0d17db9245002585710d", "target": 1, "func": "int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt)\n\n{\n\n    int i, j, t, rconpointer = 0;\n\n    uint8_t tk[8][4];\n\n    int KC = key_bits >> 5;\n\n    int rounds = KC + 6;\n\n    uint8_t log8[256];\n\n    uint8_t alog8[512];\n\n\n\n    if (!enc_multbl[FF_ARRAY_ELEMS(enc_multbl)-1][FF_ARRAY_ELEMS(enc_multbl[0])-1]) {\n\n        j = 1;\n\n        for (i = 0; i < 255; i++) {\n\n            alog8[i] = alog8[i + 255] = j;\n\n            log8[j] = i;\n\n            j ^= j + j;\n\n            if (j > 255)\n\n                j ^= 0x11B;\n\n        }\n\n        for (i = 0; i < 256; i++) {\n\n            j = i ? alog8[255 - log8[i]] : 0;\n\n            j ^= (j << 1) ^ (j << 2) ^ (j << 3) ^ (j << 4);\n\n            j = (j ^ (j >> 8) ^ 99) & 255;\n\n            inv_sbox[j] = i;\n\n            sbox[i] = j;\n\n        }\n\n        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },\n\n                     log8, alog8, inv_sbox);\n\n        init_multbl2(enc_multbl[0], (const int[4]) { 0x2, 0x1, 0x1, 0x3 },\n\n                     log8, alog8, sbox);\n\n    }\n\n\n\n    if (key_bits != 128 && key_bits != 192 && key_bits != 256)\n\n        return -1;\n\n\n\n    a->rounds = rounds;\n\n\n\n    memcpy(tk, key, KC * 4);\n\n\n\n    for (t = 0; t < (rounds + 1) * 16;) {\n\n        memcpy(a->round_key[0].u8 + t, tk, KC * 4);\n\n        t += KC * 4;\n\n\n\n        for (i = 0; i < 4; i++)\n\n            tk[0][i] ^= sbox[tk[KC - 1][(i + 1) & 3]];\n\n        tk[0][0] ^= rcon[rconpointer++];\n\n\n\n        for (j = 1; j < KC; j++) {\n\n            if (KC != 8 || j != KC >> 1)\n\n                for (i = 0; i < 4; i++)\n\n                    tk[j][i] ^= tk[j - 1][i];\n\n            else\n\n                for (i = 0; i < 4; i++)\n\n                    tk[j][i] ^= sbox[tk[j - 1][i]];\n\n        }\n\n    }\n\n\n\n    if (decrypt) {\n\n        for (i = 1; i < rounds; i++) {\n\n            av_aes_block tmp[3];\n\n            tmp[2] = a->round_key[i];\n\n            subshift(&tmp[1], 0, sbox);\n\n            mix(tmp, dec_multbl, 1, 3);\n\n            a->round_key[i] = tmp[0];\n\n        }\n\n    } else {\n\n        for (i = 0; i < (rounds + 1) >> 1; i++) {\n\n            FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds-i]);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6509, "substitutes": {"a": ["eas", "ace", "ava", "p", "aa", "f", "ach", "v", "ae", "app", "it", "w", "aka", "h", "o", "apa", "b", "A", "an", "at", "act", "y", "ma", "ar", "area", "e", "this", "m", "na", "ca", "au", "ac", "ta", "x", "as", "ak", "c", "aux", "am", "aaa", "s", "ao", "n", "ack", "ab", "sa"], "key": ["init", "json", "et", "ke", "ch", "sk", "mk", "id", "v", "list", "hash", "obj", "str", "k", "lock", "ket", "ey", "name", "ice", "type", "seed", "keys", "y", "text", "KEY", "row", "ck", "iv", "te", "pair", "ek", "table", "x", "Key", "ak", "kw", "kit", "box", "input"], "key_bits": ["key_mask", " key_files", "hash_bit", "int_bit", "key2bits", "key0its", " key_its", " key_values", " key_bots", "key_its", "key_bytes", "int_bits", "key0abilities", "key_files", "KEY_bits", "KEY_mask", "hash_bits", "key_bots", "hash_its", "key2bit", "key_values", "int_bytes", "key0values", "key0bits", " key_abilities", "key_bit", "KEY_bit", "key_abilities", "key2bytes"], "decrypt": ["Decrypt", "scrypt", "encrypt", "Decryption", "enccrypt", "sccrypt", "encode", "decryption", "deccrypt", "encryption", "scode", "scryption", "decode", "Deccrypt", "Decode"], "i": ["p", "id", "l", "ii", "ini", "it", "q", "hi", "di", "gi", "ie", "y", "iter", "ci", "ami", "qi", "n", "z", "er", "ite", "ei", "r", "ix", "ic", "si", "ji", "b", "index", "name", "zi", "this", "pi", "x", "phi", "ia", "is", "f", "ind", "mi", "gu", "ri", "io", "ip", "point", "multi", "e", "ti", "m", "ai", "im", "I", "s", "u", "dr", "li", "sim", "ki", "bi", "v", "me", "\u0438", "o", "in", "info", "g", "ui", "iu", "ij", "xi", "status", "um", "jp"], "j": ["json", "dj", "li", "p", "jac", "ch", "prime", "bi", "f", "jj", "v", "ii", "l", "r", "jl", "ix", "it", "q", "note", "jc", "obj", "str", "aj", "ion", "si", "prop", "k", "jo", "h", "br", "o", "lock", "io", "di", "ji", "js", "jump", "ie", "b", "index", "oj", "adj", "g", "tree", "iu", "pr", "ij", "y", "kj", "ot", "jp", "uj", "m", "jas", "try", "ja", "job", "pi", "ni", "jit", "J", "n", "z", "err"], "t": ["tc", "p", "dt", "td", "tf", "tt", "T", "bt", "d", "l", "v", "nt", "r", "to", "it", "q", "z", "typ", "tar", "txt", "set", "k", "kt", "st", "h", "o", "u", "pt", "wt", "ht", "mt", "at", "g", "trace", "type", "tip", "y", "ot", "tp", "ts", " ti", "ti", "te", "m", "tr", "test", "ent", "ct", "ta", "tm", "tx", "qt", "c", "rt", "s", "n", "tu", "vt", "out"], "tk": ["tc", "tif", "json", "util", "kh", "tv", "td", "tt", "sk", "ty", "tf", "mk", "kk", "kr", "uk", "ctx", "tar", "typ", "obj", "txt", "tap", "look", "wk", "ku", "kt", "k", "dk", "self", "ok", "kl", "wt", "ket", "term", "ijk", "new", "tp", "tek", "tg", "te", "ek", "ik", "kar", "table", "tile", "awk", "ac", "ta", "tm", "qt", "ak", "sky", "kit", "kw", "tu"], "log8": [" log7", "cat9", " log9", "ogoo", "log32", "olog6", "alogode", "alog7", "log4", "log08", "el28", " logo", "logoo", "alogoo", " logoo", " log2", "og4", "cat7", "alog28", "olog2", "alog32", " log4", "alogoff", " logode", "log9", "el08", "og8", "alog9", "alog08", "alogo", "alog2", "ologoff", "log6", "olog8", "catode", " log08", "alog4", "cat8", "log2", "logode", "log7", " log32", "logo", "log28", "el8", "el32", " log6", "logoff", " logoff", "alog6", " log28", "ologo"], "alog8": ["alog24", "cat9", "cil32", "og64", "afo", "log80", "log32", "og24", "ang9", "lang64", "lang24", "af8", "blog4", "ateg08", "alog7", "cil9", "blog7", "log08", "blog64", "af9", "lang4", "cil80", "lang8", "langbl", "alog32", "cil8", "alog64", "ateg9", "afbl", "alog80", "log9", "ang80", "ll64", "sl8", "alog9", "cato", "alog08", "ang32", "sl64", "catbl", "alogo", "sl9", "og7", "ll8", "blog8", "og8", "lango", "ob4", "alog4", "cat8", "lang08", "ll24", "log7", "ob08", "sl08", "alogbl", "ateg8", "blogo", "obo", "lang9", "lang7", "ll7", "ob8", "log64", "blog08", "ang8", "ateg64"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tunsigned int width, unsigned int height,\n\n\tint lumStride, int chromStride, int dstStride)\n\n{\n\n\t//FIXME interpolate chroma\n\n\tRENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);\n\n}\n", "idx": 6519, "substitutes": {"ysrc": ["iesrs", "asrs", "vsurg", "ysr", "sysr", "iesr", "ssurg", "assrc", "yssrc", "sssrc", "ssrc", "iessrc", "sysrs", "asr", "asrc", "ysrs", "sysrc", "ysurg", "iesurg", "ssr", "syssrc", "iesrc", "vsr", "vssrc"], "usrc": ["umsr", "udsrc", "ussrc", " usr", "aususc", "ausrc", "usesrc", "cussrc", "umsirc", "usr", "usirc", "usesr", "udssrc", "auscur", "cususc", "cusrc", " ussrc", "umsrc", " usirc", "umssrc", "udscur", "ususc", "cuscur", "uscur", "usesirc", "udsusc", "usessrc", "aussrc"], "vsrc": ["ivsource", "ivrc", "fsr", " vsource", " vsr", "Vrc", "vrc", "Vsource", " vrc", "dsource", "fsource", "vstr", "Vsr", "dsrc", "Vsrc", "frc", "vsource", "fsrc", "dstr", " vstr", "ivsrc", "ivstr", "vsr", "drc"], "dst": ["lst", "dasts", "sst", "fnt", "ddest", "dnd", "sdest", "ddst", " dsts", "ldest", "dddest", "fst", "lnd", "fdest", " ddest", "ddnt", "snt", "dnt", " dnd", "snd", "lsts", "dadest", "dast", "ddnd", "dand", "dsts", "fnd"], "height": ["html", "ch", "stroke", "loss", "wh", "family", "length", "inches", "error", "density", "padding", "resolution", "h", "depth", "build", "he", "size", "history", "ht", "Height", "gh", "y", "rank", "bottom", "crop", "gravity", "headers", "window", "yt", "above", "angle", "sky", "shape", "frame", "grow", "hang"], "lumStride": ["lumRestride", "lumSTride", "lumSTrid", "lumStr", "lumLide", "lumRestr", "lumstbit", "limStrid", "lumStrr", "limStbit", "lumSTr", "lumLride", "limStrride", "limStrrid", "lumStide", "lamStrrid", "lumstride", "limStide", "lumStrbit", "lamStrr", "lamStrrat", "lamStrat", "lamStrid", "lumStbit", "limStride", "lumLrid", "lumStrride", "lumLbit", "lamStride", "lamStrride", "limStrbit", "lumRestrat", "lumSTrat", "lamStr", "lumRestrid", "lumStrrat", "lumStrrid", "lumStrid", "lumstrid", "lumstide", "lumStrat"], "chromStride": ["chromStrrid", "romStrrid", "romStr", "chromChride", "chromStrbit", "romStrride", "chromChbit", "romStide", "romStride", "chromstrid", "romStrr", "chromstide", "chromStrr", "chromChide", "chromStr", "romStbit", "chromChrid", "romStrbit", "romStrid", "chromstr", "chromstride", "chromStrride", "chromStbit", "chromStide", "chromStrid"], "dstStride": ["dstRestide", "dstStrrid", "dststbit", "dustStr", "dstRestride", "dstStrr", "dustStrr", "dststride", "dstStide", "dstRestr", "destStr", "deststride", "dstStrride", "dstRestbit", "dststrid", "dstStbit", "dstStrbit", "dustStrbit", "dststr", "deststide", "dustStride", "deststr", "dustStbit", "destStide", "dstRestrid", "destStride", "dststide", "dustStrride", "dstStr", "deststrid", "dstStrid", "destStrid", "dustStide"]}}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,\n\n                                  sPAPRMachineState *spapr)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);\n\n    int index = ppc_get_vcpu_dt_id(cpu);\n\n    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                       0xffffffff, 0xffffffff};\n\n    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()\n\n        : SPAPR_TIMEBASE_FREQ;\n\n    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n    uint32_t page_sizes_prop[64];\n\n    size_t page_sizes_prop_size;\n\n    uint32_t vcpus_per_socket = smp_threads * smp_cores;\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};\n\n    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));\n\n    sPAPRDRConnector *drc;\n\n    int drc_index;\n\n    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];\n\n    int i;\n\n\n\n    drc = spapr_drc_by_id(TYPE_SPAPR_DRC_CPU, index);\n\n    if (drc) {\n\n        drc_index = spapr_drc_index(drc);\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index)));\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"reg\", index)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"device_type\", \"cpu\")));\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"cpu-version\", env->spr[SPR_PVR])));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-block-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-line-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-block-size\",\n\n                           env->icache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-line-size\",\n\n                           env->icache_line_size)));\n\n\n\n    if (pcc->l1_dcache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-size\",\n\n                               pcc->l1_dcache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 dcache size for cpu\");\n\n    }\n\n    if (pcc->l1_icache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-size\",\n\n                               pcc->l1_icache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 icache size for cpu\");\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"timebase-frequency\", tbfreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"clock-frequency\", cpufreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"status\", \"okay\")));\n\n    _FDT((fdt_setprop(fdt, offset, \"64-bit\", NULL, 0)));\n\n\n\n    if (env->spr_cb[SPR_PURR].oea_read) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,purr\", NULL, 0)));\n\n    }\n\n\n\n    if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-segment-sizes\",\n\n                          segs, sizeof(segs))));\n\n    }\n\n\n\n    /* Advertise VMX/VSX (vector extensions) if available\n\n     *   0 / no property == no vector extensions\n\n     *   1               == VMX / Altivec available\n\n     *   2               == VSX available */\n\n    if (env->insns_flags & PPC_ALTIVEC) {\n\n        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset, false);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    if (nb_numa_nodes > 1) {\n\n        _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cpu));\n\n    }\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n", "idx": 6524, "substitutes": {"cs": ["sc", "cu", "cp", "ces", "ds", "cus", "css", "ms", "ec", "vs", "ps", "ctx", "ix", "pc", "ks", "cc", "CS", "cn", "gc", "bs", "js", "ns", "hs", "proc", "sts", "rs", "ts", "cks", "ci", "acs", "fs", "core", "ct", "c", "cms", "ls", "s", "cas", "sys"], "fdt": ["fdn", "ondt", "dfb", "fdwt", "dfdt", "fcn", "dlwt", "fdb", "ondte", "FDt", "dft", "fdc", "dlt", "FDs", "tdc", "FDn", "fdte", "udb", "dlts", "fxg", "FDte", "fdts", "iddb", "iddts", "dfts", "dlte", "fxt", "fcwt", "tdg", "fds", "uddt", "udt", "fcte", "fddt", "iddt", "dls", "dlg", "fxc", "tdt", "dlc", "dln", "fct", "idddt", "fdg", "fcts", "ondts", "udts", "fcs", "ondwt"], "offset": ["ptr", "entry", "extra", "exclusive", "util", "bound", "optional", "f", "origin", "id", "length", "error", "position", "padding", "address", "tab", "frequency", "set", "si", "style", "axis", "alias", "handle", "o", "lock", "align", "attribute", "pad", "location", "vector", "format", "off", "pointer", "index", "slot", "shift", "point", "atomic", "timeout", "initialized", "seed", "interface", "slice", "row", "operation", "scroll", "buffer", "offs", "tile", " index", "num", "x", "Offset", "count", "secondary", "oid", "encrypted", "pos", "start", "batch", "seek"], "spapr": ["spaspR", " spaprd", " spipR", "ispaper", "spampp", " spiprd", "spasprd", "spapro", "spappr", "spaptr", "spappro", "spipR", "spamprb", "spaptrar", " spiprar", "spipr", "ispapr", "spampro", "spiprar", "spaper", "spaprar", "spaprb", "spappp", "ispaperb", "ispapep", "spasprar", "spapep", "spapR", "spaperb", "ispapp", "spaspr", "spapero", "spampr", "spaprd", "ispapro", "spapprb", "ispapero", "spiprd", " spipr", "ispaprb", "spaptR", "spaptrd", "spapp", " spapR", " spaprar"], "cpu": ["ka", "sc", "cu", "cp", "util", "phys", "cv", "conn", "aco", "lp", "processor", "ctx", "thread", "pc", "linux", "density", "prof", "gpu", "node", "cc", "cn", "gc", "device", "nu", "mem", "proc", "clock", "mac", "mx", "CPU", "pool", "process", "vm", "ck", "stat", "tp", "boot", "pu", "core", "hw", "cum", "us", "c", "cli", "nic", "sys", "nc", "cache", "cmd"], "env": ["ei", "equ", "conf", "dev", "estate", "environment", "cv", "config", "conn", "priv", "pillar", "v", "ec", "vs", "ctx", "ework", "scope", "map", "cb", "obj", "ext", "en", "eng", "attr", "proc", "buf", "cap", "e", "end", "cfg", "win", "window", "ef", "pe", "context", "er", "ev", "viron"], "pcc": ["Pcc", "pCC", "cpcs", "cpcc", "Pcs", " pct", "cpct", "pct", "Pct", " pCC", " pcs", "cpCC", "PCC", "pcs"], "segs": ["begm", "begments", "segments", "begs", "veg", " segments", " seg", "seg", "vegm", "segm", "beg", "vegments", " segm", "vegs"], "page_sizes_prop": ["page_sizers_property", "page_sizers_tmp", "page_sizes_tmp", "page_sizes_property", "page_sizes_ps", "page_sizers_ps", "page_sizers_prop"], "page_sizes_prop_size": ["page_sizes_property_val", "page_sizes_property_length", "page_sizes_prop2size", "page_sizes_prop2length", "page_sizes_prop_len", "page_sizes_prop2val", "page_sizes_prop_length", "page_sizes_property_size", "page_sizes_prop2len", "page_sizes_prop_val", "page_sizes_property_len"], "pft_size_prop": ["pft_size2properties", "pft_size_properties", "pft_size_desc", "pft_size_buf", "pft_name2buf", "pft_name_desc", "pft_name2properties", "pft_size2prop", "pft_name_prop", "pft_name2prop", "pft_size2buf", "pft_name_buf", "pft_size2desc", "pft_name2desc", "pft_name_properties"], "drc": ["Dfc", "Darc", "dcur", " drs", "Dcur", "prt", "Drt", "bdrs", "prc", "pRC", " drom", " darc", "pfc", "bdRC", " drt", " dfc", "dRC", "bdrc", "DRC", " dcur", "bdrom", " dRC", "bdarc", "Drs", "dfc", "Drc", "drs", "drt", "Drom", "drom", "darc"], "drc_index": ["drc_count", "dRC_count", "drc2Index", "drc__Index", "drc2id", "drc_Index", "drc_num", "drc_size", "dRC_num", "drc__num", "dRC_index", "drc__index", "dRC_size", "drc__size", "drc2index", "drc_id", "dRC_id", "dRC_Index"], "radix_AP_encodings": ["radix_prop_enoding", "radix_prop_encODings", "radix_prop_enccoding", "radix_prop_enodings", "radix_prop_encodesING", "radix_prop_enccodING", "radix_prop_enODing", "radix_prop_encodesINGS", "radix_prop_enODINGS", "radix_prop_encodesing", "radix_prop_encodINGS", "radix_prop_enodING", "radix_prop_enODING", "radix_prop_encODINGS", "radix_prop_enccodings", "radix_prop_encODing", "radix_prop_encodings", "radix_prop_encodesings", "radix_prop_enodINGS", "radix_prop_encodING", "radix_prop_enODings", "radix_prop_encoding", "radix_prop_enccodINGS", "radix_prop_encODING"], "i": ["p", "f", "a", "id", "l", "ii", "it", "list", "si", "j", "di", "o", "io", "b", "index", "point", "y", "e", "ci", "m", "base", " j", " index", "x", "I", "c", "n", " ii"]}}
{"project": "qemu", "commit_id": "f94d18d6c6df388fde196d3ab252f57e33843a8b", "target": 0, "func": "static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)\n\n{\n\n    XHCIState *xhci = epctx->xhci;\n\n    XHCIStreamContext *stctx;\n\n    XHCITransfer *xfer;\n\n    XHCIRing *ring;\n\n    USBEndpoint *ep = NULL;\n\n    uint64_t mfindex;\n\n    int length;\n\n    int i;\n\n\n\n    trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid);\n\n\n\n    /* If the device has been detached, but the guest has not noticed this\n\n       yet the 2 above checks will succeed, but we must NOT continue */\n\n    if (!xhci->slots[epctx->slotid - 1].uport ||\n\n        !xhci->slots[epctx->slotid - 1].uport->dev ||\n\n        !xhci->slots[epctx->slotid - 1].uport->dev->attached) {\n\n        return;\n\n    }\n\n\n\n    if (epctx->retry) {\n\n        XHCITransfer *xfer = epctx->retry;\n\n\n\n        trace_usb_xhci_xfer_retry(xfer);\n\n        assert(xfer->running_retry);\n\n        if (xfer->timed_xfer) {\n\n            /* time to kick the transfer? */\n\n            mfindex = xhci_mfindex_get(xhci);\n\n            xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n\n            if (xfer->running_retry) {\n\n                return;\n\n            }\n\n            xfer->timed_xfer = 0;\n\n            xfer->running_retry = 1;\n\n        }\n\n        if (xfer->iso_xfer) {\n\n            /* retry iso transfer */\n\n            if (xhci_setup_packet(xfer) < 0) {\n\n                return;\n\n            }\n\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n            assert(xfer->packet.status != USB_RET_NAK);\n\n            xhci_complete_packet(xfer);\n\n        } else {\n\n            /* retry nak'ed transfer */\n\n            if (xhci_setup_packet(xfer) < 0) {\n\n                return;\n\n            }\n\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n            if (xfer->packet.status == USB_RET_NAK) {\n\n                return;\n\n            }\n\n            xhci_complete_packet(xfer);\n\n        }\n\n        assert(!xfer->running_retry);\n\n        xhci_ep_free_xfer(epctx->retry);\n\n        epctx->retry = NULL;\n\n    }\n\n\n\n    if (epctx->state == EP_HALTED) {\n\n        DPRINTF(\"xhci: ep halted, not running schedule\\n\");\n\n        return;\n\n    }\n\n\n\n\n\n    if (epctx->nr_pstreams) {\n\n        uint32_t err;\n\n        stctx = xhci_find_stream(epctx, streamid, &err);\n\n        if (stctx == NULL) {\n\n            return;\n\n        }\n\n        ring = &stctx->ring;\n\n        xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING);\n\n    } else {\n\n        ring = &epctx->ring;\n\n        streamid = 0;\n\n        xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING);\n\n    }\n\n    assert(ring->dequeue != 0);\n\n\n\n    while (1) {\n\n        length = xhci_ring_chain_length(xhci, ring);\n\n        if (length <= 0) {\n\n            break;\n\n        }\n\n        xfer = xhci_ep_alloc_xfer(epctx, length);\n\n        if (xfer == NULL) {\n\n            break;\n\n        }\n\n\n\n        for (i = 0; i < length; i++) {\n\n            TRBType type;\n\n            type = xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL);\n\n            assert(type);\n\n        }\n\n        xfer->streamid = streamid;\n\n\n\n        if (epctx->epid == 1) {\n\n            xhci_fire_ctl_transfer(xhci, xfer);\n\n        } else {\n\n            xhci_fire_transfer(xhci, xfer, epctx);\n\n        }\n\n        if (xfer->complete) {\n\n            xhci_ep_free_xfer(xfer);\n\n            xfer = NULL;\n\n        }\n\n\n\n        if (epctx->state == EP_HALTED) {\n\n            break;\n\n        }\n\n        if (xfer != NULL && xfer->running_retry) {\n\n            DPRINTF(\"xhci: xfer nacked, stopping schedule\\n\");\n\n            epctx->retry = xfer;\n\n            break;\n\n        }\n\n    }\n\n\n\n    ep = xhci_epid_to_usbep(epctx);\n\n    if (ep) {\n\n        usb_device_flush_ep_queue(ep->dev, ep);\n\n    }\n\n}\n", "idx": 6532, "substitutes": {"epctx": ["epsconn", "ippkg", "ephistory", "epercfg", "epsctx", " epconfig", "epscfg", "petimeout", "eptimeout", "eqtimeout", " epcfg", "epcontext", "peca", "epcmd", "epconn", "aptx", "pecontext", "pehistory", "eccontext", "apcmp", "ipctx", "pepkg", "eppkg", "epcfg", "ipca", "espcmp", "epspkg", "epscontext", "ipconn", "espcontext", "epca", "epscmd", " eptx", "ecconfig", "ipcontext", "ipcmp", "eqctx", "appkg", "ipcmd", "ectx", "eptx", "espctx", "epscmp", "epconfig", "epstimeout", "epsfunc", "pecmp", "epfunc", "eperctx", "apctx", "epshistory", "epsinit", "pectx", "ecpkg", "epercontext", "epstx", " epcontext", "ecconn", "epsca", "eqcontext", "eccmp", "apcontext", "espfunc", "iptx", "epsconfig", "iphistory", "eqpkg", "apcmd", "eperinit", "epinit", "epcmp", "ecctx", "pefunc", " epinit"], "streamid": ["channeluid", "streamident", "streamId", "streamID", "streamuid", "reamident", "windowid", "reamuid", "channelid", "reamID", " streamident", "reamid", "channelId", "windowident", " streamuid", "windowID", "windowId", "reamId", " streamID", " streamId"], "xhci": ["xccs", "xdhlink", "xhcs", "xhlink", "xxrhcci", "Xheki", " cxwni", "xhinco", "xihcit", "xhipy", "xwci", "xrhiesta", "wxhcit", "rxhki", "xclink", "xwni", "xohcli", " cxhni", "xhmci", "xheni", " cxwco", "xhcit", "xhwcci", "rxheci", "xohlink", "xdhci", "xhwlic", "xhco", "xihci", "xhici", "xohdi", "xdohcs", "xhcgi", "wxohcit", "xohci", "xhidi", "wxhc", "xhcci", "xcci", "xahcom", "xhecu", "xhcom", "xheci", "rxhepy", "xhinni", "wxohcli", "xhki", "xxhlic", " cxhci", "xccom", "xohcit", "rxhcu", "Xhci", "xxrhiesta", "xihcli", "rxhlci", "rxhcgi", "rxhedi", "xhlci", " cxhcci", "xhecom", "xdohci", "xwcci", "xheki", "xahci", "Xheci", " cxwci", "wxohc", "Xhcom", "Xhki", "Xhecci", "xheco", "xhicgi", "xhecgi", "xhc", "rxhlcu", "Xhcci", "xdohlink", "rxhecgi", "xohc", "xdohuci", "xxrhci", "rxhldi", "rxhdi", "Xhecom", "xcki", "xhldi", "xharpy", "xhecci", "xhcu", "xdhcs", "xohki", "xhlcit", "xhuci", "xhmcs", "xrhci", "wxohci", "xdhuci", "xrhcci", "xhlic", "xhwiesta", "rxhci", "xxhiesta", "xahki", "xhcli", "xhmlink", "xhiesta", "xccci", "xohuci", "xhlcu", "xihc", "wxhci", "xhmuci", "xhepy", "xwco", "xohcs", "xhni", " cxwcci", "xhlcli", "xhinci", "xrhlic", "xhardi", "rxhlki", "xhilic", "xxhcci", "xhdi", "xhlki", "xharcgi", "xcuci", "xxrhlic", "xhiiesta", "xahcci", "xohcu", "xhpy", " cxhco", "wxhcli", "xhedi", "rxhpy", "xhicci", "xharci", "xxhci", "xhwci", "xhincci", "xhlc"], "stctx": ["ostconn", " sttx", "stcontext", "ostctx", "sttx", " stconn", "ostcontext", "stconn", "styconn", " stcontext", "osttx", "styctx", "stycontext", "stytx"], "xfer": ["lexfer", "fxporter", "eference", "mxter", "tfer", "xhr", "pxporter", "xxporter", "xffer", "oxfer", "xxver", "rxformer", "mxcer", "eyformer", "crossference", "dxfer", "xference", "xxhr", "xxferred", "oxference", "nexbury", "uxferred", "checkference", "xyference", "crossception", "mxference", "mxformer", "lexcer", "axference", "zxffer", "ixfer", "exbury", "xferred", "lexference", "mxft", "rxbury", "xpect", "exporter", "xxputer", "xxference", "zxporter", "rxpire", "vference", "dxffer", "vfr", "xfr", "rxference", "exference", "vporter", "tference", "exiter", "xxfer", "mxporter", "zxfer", "workFER", "xver", "ecer", "fxfer", "rxfe", "ttransfer", "exfer", "pxft", "crossffer", "eyfer", "crossfer", "oxputer", "uxformer", "xxcer", "rxcer", "tter", "crossiter", "xFER", "mxfire", "xputer", "rxfer", "ixcer", "wxfer", "nexfer", "xcer", " xfort", "xxter", "rxiter", "pxfer", "workferred", "oxter", "ixfort", "oxfe", "uxbury", "xbury", "fxft", "oxlate", " xferred", "xfe", "wxporter", "zxpire", "efer", "oxporter", "crossferred", "zxference", "wxfort", "crossfe", "crosshr", "xiter", "rxtransfer", "oxcer", " xiter", "checkbury", "rxver", "wxiter", "xformer", "eyference", "ixception", "workfer", "xxtransfer", "oxferred", "oxbury", "nexference", "xxlate", "axlate", "zxfe", "ixhr", "uxporter", "wxpect", "wxformer", "crossporter", "oxpire", "xyfer", "oxver", "xter", "vfer", "wxft", "mxfer", "xception", "xlate", "xfort", "dxporter", "wxference", "axfer", "eyfire", "ixference", "uxfort", "checkferred", "ixft", "nexferred", "uxfer", "axputer", " xference", "expect", "uxiter", "xpire", "xft", "xypire", "zxferred", " xpire", "lexfr", "zxiter", "rxferred", "ixiter", "oxtransfer", "ixpect", "checkfer", "xxception", "xyiter", "xxpire", "ixferred", "uxference", "lexfe", "dxfe", "eter", "fxfort", "oxfr", "oxformer", "xporter", "workporter", "zxFER", " xporter", "ixporter", "crosstransfer", "pxfort", "lexporter", " xFER", "xxft", "xtransfer", "rxfire", "xfire"], "ring": ["ng", "ray", "path", "ping", "prefix", "ral", "sam", "rings", "ra", "setting", "ri", "ings", "Ring", "range", "rs", "rest", "record", "rol", "rel", "star", "inding", "ram", "ling", "rin", "ro", "binding", "reg", "ing"], "ep": ["ever", "vp", "pp", "cp", "et", "p", "dev", "eth", "pkg", "EP", "ech", "sp", "ec", "pipe", "ele", "mp", "eg", "peak", "wp", "ew", "eper", "Ep", "ip", "ap", "est", "pb", "peer", "tp", "dp", "op", "e", "ape", "gp", "esp", "ek", "eb", "env", "ef", "pe", "ept", "ream", "er", "ev", "dep", "eps"], "mfindex": ["mcindex", "mfaindex", " mvIndex", "mferind", " mvvalue", "mfIndex", "dmfaddress", "mofindex", "mferIndex", "mfind", "mrfoffset", "mlfindex", "mlfpointer", "mrfindex", "mcvalue", "mfapointer", "mvvalue", " mfIndex", "dmfaaddress", " mfvalue", "mfacoffset", "mfaddress", "mfanum", " mxfIndex", "dmfnum", "dmfaindex", "mxfindex", "mcIndex", "dmfpointer", "mvIndex", "dmfapointer", "mofnum", " mvindex", "mrfIndex", "mofaddress", "mfvalue", "mfaaddress", "mofpointer", "dmfindex", "mfervalue", " mvind", "mfpointer", "dmfanum", " mxfoffset", "mcind", "mvindex", "mlfaddress", "mfacIndex", " mfoffset", "mferindex", "mfnum", "mxfIndex", "mlfnum", "mfacindex", " mfind", "mvind", "mfoffset", "mxfoffset", " mxfindex"], "length": ["ptr", "ffff", "t", " l", "fi", "l", "le", "sp", "data", "z", "duration", "sl", "ish", "en", "h", "ength", "link", "len", " len", "byte", "sequence", "count", "phi", "total", "load", "Length"], "i": ["t", "li", "p", "ki", "fi", "bi", "f", "id", "l", "v", "ii", "it", "si", "j", "di", "o", "io", "ip", "ci", "ti", "m", "iat", "ai", "pi", " j", "I", "phi", "c"]}}
{"project": "FFmpeg", "commit_id": "b04665ac028d26747396eaf4dbf9188225a6f2a1", "target": 0, "func": "static int opt_preset(const char *opt, const char *arg)\n\n{\n\n    FILE *f=NULL;\n\n    char filename[1000], tmp[1000], tmp2[1000], line[1000];\n\n    int i;\n\n    const char *base[3]= { getenv(\"HOME\"),\n\n                           \"/usr/local/share\",\n\n                           \"/usr/share\",\n\n                         };\n\n\n\n    for(i=!base[0]; i<3 && !f; i++){\n\n        snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s.ffpreset\", base[i], i ? \"\" : \".\", arg);\n\n        f= fopen(filename, \"r\");\n\n        if(!f){\n\n            char *codec_name= *opt == 'v' ? video_codec_name :\n\n                              *opt == 'a' ? audio_codec_name :\n\n                                            subtitle_codec_name;\n\n            snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s-%s.ffpreset\", base[i],  i ? \"\" : \".\", codec_name, arg);\n\n            f= fopen(filename, \"r\");\n\n        }\n\n    }\n\n    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||\n\n              is_dos_path(arg))){\n\n        snprintf(filename, sizeof(filename), arg);\n\n        f= fopen(filename, \"r\");\n\n    }\n\n\n\n    if(!f){\n\n        fprintf(stderr, \"File for preset '%s' not found\\n\", arg);\n\n        av_exit(1);\n\n    }\n\n\n\n    while(!feof(f)){\n\n        int e= fscanf(f, \"%999[^\\n]\\n\", line) - 1;\n\n        if(line[0] == '#' && !e)\n\n            continue;\n\n        e|= sscanf(line, \"%999[^=]=%999[^\\n]\\n\", tmp, tmp2) - 2;\n\n        if(e){\n\n            fprintf(stderr, \"%s: Preset file invalid\\n\", filename);\n\n            av_exit(1);\n\n        }\n\n        if(!strcmp(tmp, \"acodec\")){\n\n            opt_audio_codec(tmp2);\n\n        }else if(!strcmp(tmp, \"vcodec\")){\n\n            opt_video_codec(tmp2);\n\n        }else if(!strcmp(tmp, \"scodec\")){\n\n            opt_subtitle_codec(tmp2);\n\n        }else if(opt_default(tmp, tmp2) < 0){\n\n            fprintf(stderr, \"%s: Invalid option or argument: %s=%s\\n\", filename, tmp, tmp2);\n\n            av_exit(1);\n\n        }\n\n    }\n\n\n\n    fclose(f);\n\n\n\n    return 0;\n\n}\n", "idx": 6535, "substitutes": {"opt": ["init", "Opt", "let", "no", "config", "altern", "oop", "cat", "org", "not", "it", "ost", "parent", "prefix", "typ", "txt", "obj", "ext", "options", "str", "crit", "prop", "j", "option", "attr", "lt", "pres", "name", "ver", "buf", "alg", "type", "cmp", "op", "stat", "OP", "etc", "opted", "expr", "var", "bin", "kw", "alt", "open", "params", "cmd"], "arg": ["key", "gt", "arr", "path", "file", "msg", "call", "ag", "txt", "loc", "str", "supp", "valid", "nick", "slot", "par", "range", "decl", "target", "kw", "cmd", "event", "pack", "argument", "list", "w", "ax", "ret", "word", "arp", "mem", "def", "err", "name", "agg", "ref", "op", "flag", "args", "null", "vol", "ack", "Arg", "ring", "config", "sec", "ext", "mac", "lag", "rest", "match", "star", "var", "param", "ob", "reg", "doc", "v", "spec", "val", "req", "attr", "emb", "g", "alg", "tag", "ar", "bit", "parse", "cal", "params"], "f": ["fr", "t", "fg", "p", "fn", "fi", "tf", "form", "lf", "full", "d", "l", "v", "fm", "fac", "func", "r", "fb", "fd", "file", "fw", "w", "ff", "sf", "h", "j", "o", "fl", "xf", "feed", "fc", "b", "F", "elf", "g", "found", "fed", "rf", "y", "fp", "fe", "cf", "e", "fo", "m", "try", "fs", "uf", "alf", "x", "c", "bf", "n", "u", "stream"], "filename": ["fil", "fr", "fn", "path", "file", "files", "msg", "txt", "png", "ames", "root", "slice", "fp", "target", "wav", "message", "n", "json", "subject", "amd", "origin", "binary", "username", "folder", "j", "output", "name", "buffer", "this", "csv", "src", "directory", "sys", "Filename", "mpeg", "temp", "config", "nil", "dest", "fd", "stem", "nm", "size", "source", "pdf", "dir", "jpg", "ename", "bf", "original", "out", "latest", "unc", "disk", "ame", "unction", "ln", "length", "prefix", "kl", "tp", "xxx", "lua", "names", "title", "window", "video", "sql", "err"], "tmp": ["top", "out", "t", "cp", "emp", "copy", "td", "pkg", "temp", "mk", "sp", "nt", "to", "ctx", "upload", "path", "mp", "file", "split", "prefix", "msg", "tar", "tu", "obj", "txt", "sam", "png", "nam", "st", "buff", "size", "proc", "np", "dir", "name", "orig", "slice", "buf", "mb", "zip", "img", "jpg", "cmp", "clip", "fake", "perm", "tg", "etc", "mm", "test", "part", "snap", "tm", "src", "rt", "shot", "tem", "video", "tab", "stuff", "cache", "cmd", "template"], "tmp2": [" tmp3", "txt6", " tmp1", "mp3", "mp6", "tmp1", "txt2", "temp3", "temp4", " tmp4", "mp2", "tmp3", "tmp6", "temp1", "temp6", "temp2", "tmp4", "txt1", "mp4", "txt3", "mp1", " tmp6"], "line": ["entry", "out", "co", "inter", "limit", "ln", "d", "l", "le", "LINE", "pipe", "list", "file", "error", "call", "force", "str", "lock", "word", "ie", "Line", "link", "cell", "lin", "comment", "range", "row", "len", "iter", "code", "end", "e", "ine", "lines", "page", "flag", "lo", "header", "eline", "c", " Line", "nl", "block", "pe", "pos", "frame", "se"], "i": ["key", "init", "t", "li", "ei", "p", "sim", "ki", "bi", "is", "id", "ind", "ii", "v", "ini", "mi", "ix", "me", "it", "list", "ic", "gu", "z", "\u0438", "any", "si", "oi", "j", "di", "o", "gi", "ri", "io", "in", "ji", "ip", "index", "info", "g", "ui", "multi", "iu", "xi", "y", "ij", "zi", "status", "e", "ti", "ci", "m", "ami", "ai", "pi", "im", "ims", "x", "I", "phi", "us", "c", "qi", "cli", "n", "gl"], "base": ["bound", "max", "prime", "id", "real", "it", "list", "file", "prefix", "bas", "bar", "force", "stack", "absolute", "node", "val", "set", "server", "profile", "space", "chain", "quote", "size", "b", "root", "name", "tree", "range", "type", "tail", "buffer", "rest", "store", "status", "area", "Base", "based", "bit", "ase", "relative", "win", "bare", "var", "basic", "client", "enable", "null", "block", "start", "box", "sys", "cache", "se", "template"], "codec_name": ["coditor___size", "coditor___name", "codEC_name", "codec_no", "coditor_len", "codec_type", "codec2Name", "codecityid", "coditor_id", "codecitylen", "codEC_type", "codecityname", "codec2type", "codec2no", "coditor___id", "codEC_no", "codec_Name", "codec_id", "codecitysize", "coditor_name", "codec_len", "codec___size", "codec___name", "codEC_Name", "coditor___len", "codec2name", "codec___len", "codec_size", "codec___id", "coditor_size"]}}
{"project": "FFmpeg", "commit_id": "fdbc544d29176ba69d67dd879df4696f0a19052e", "target": 1, "func": "static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)\n\n{\n\n    ASFContext *asf  = s->priv_data;\n\n    AVIOContext *pb  = s->pb;\n\n    uint64_t size    = avio_rl64(pb);\n\n    uint16_t nb_desc = avio_rl16(pb);\n\n    int i, ret;\n\n\n\n    for (i = 0; i < nb_desc; i++) {\n\n        uint16_t name_len, type, val_len;\n\n        uint8_t *name = NULL;\n\n\n\n        name_len = avio_rl16(pb);\n\n        if (!name_len)\n\n            return AVERROR_INVALIDDATA;\n\n        name = av_malloc(name_len);\n\n        if (!name)\n\n            return AVERROR(ENOMEM);\n\n        avio_get_str16le(pb, name_len, name,\n\n                         name_len);\n\n        type    = avio_rl16(pb);\n\n        val_len = avio_rl16(pb);\n\n\n\n        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    align_position(pb, asf->offset, size);\n\n    return 0;\n\n}\n", "idx": 6543, "substitutes": {"s": ["sc", "t", "os", "p", "S", "ds", "f", "a", "ms", "v", "sp", "ps", "ctx", "ins", "q", "less", "ss", "h", "o", "in", "bs", "js", "ns", "hs", "b", "sq", "sts", "sg", "rs", "gs", "y", "ts", "es", "e", "stats", "m", "fs", "its", "sv", "cs", "x", "as", "sb", "c", "ls", "n", "ats", "sys", "sa"], "g": ["gm", " m", "gas", "gt", " gp", "pg", "msg", "vg", "gu", "ga", "j", "gc", "ge", "gd", "group", "gen", "sg", "G", "gb", "gs", "mg", "bg", "tg", "cfg", "gp", "gg", "m", "go"], "asf": [" asfo", "rasv", "asfe", " asfe", "asfo", " asv", "asuf", "Asc", "asc", "Asf", "Asfe", "Asuf", " asc", "Asfo", "rasf", "Asv", "atsuf", "rasc", "asv", "atsfo", "atsfe", " asuf", "atsf", "rasfo"], "pb": ["py", "vp", "pp", "cp", "p", "pkg", "td", "cv", "bj", "lp", "PB", "sp", "ctx", "pc", "fb", "mp", "pg", "typ", "wp", "cb", "phy", "amp", "orp", "pm", "pa", "ub", "prot", "pt", "apa", "bs", "ap", "asm", "proc", "np", "emb", "resp", "mt", "erb", "buf", "mb", "pr", "peer", "fp", "tp", "dp", "jp", "pool", "tg", "gp", "iat", "summary", "bp", "eb", "pl", "uf", "stab", "sb", "ob", "queue", "tk", "xp", "tab", "rb", "pan", "ab", "wb"], "i": [" m", " I", "t", "li", "ei", "p", " multi", "sim", "init", " iter", "bi", "is", "ms", "ind", "v", "ii", "ini", "mi", "ix", " bi", " pi", "it", "me", "ic", "q", "si", "j", "di", "in", "iq", "chain", "ex", " li", "index", "ui", " si", "multi", "iu", "xi", "y", "zi", "status", "print", " ti", "ci", "ti", "m", "ai", "pi", "im", " di", " mi", "x", "I", "ims", "phi", "c", "qi", "us", "n", "z", "go", " ii", "batch"], "ret": ["elt", "reset", "gt", "ll", "RET", "r", "re", "nt", "not", "Ret", "ft", "rets", "txt", "red", "val", "fun", "port", "j", "rem", "mt", "result", "lt", "def", "err", "pret", "resp", "term", "over", "ber", "ref", "mel", "status", "len", "print", "jp", "res", "rel", "det", "try", "tr", "ter", "job", "flag", " RET", " Ret", "aux", "rt", "alt", "nl", "out"], "name_len": ["Name_len", " name_Len", " name_ll", "Name_loc", "name_den", "val_Len", "Name_Len", " name_length", " name_list", " name_fin", " name_elt", "name_elt", "name_num", "namelengthden", "name_ln", "Name_length", "val_spec", " name_num", "name_list", "name_spec", "name_ll", " name_ln", "name_Len", "namelengthLen", "name_fin", "name_lon", "namelengthlen", "name_length", "val_den", "Name_lon", "name_loc", "namelengthspec"], "type": ["key", "t", "TYPE", "cast", "form", "ty", "id", "types", "cat", "length", "ype", "ping", "parent", "error", "Type", "typ", "other", "val", "style", "kind", "time", "size", "format", "color", "ver", "info", "role", "class", "tag", "len", "op", "what", "try", "unit", "ime", "test", "desc", "pe", "by", "ack", "value", "ico"], "val_len": ["valjlen", "val_val", "value_ln", "val67Len", "val_pl", "value_mem", "val67len", "value_val", "value_pl", "val67ln", " val_compl", "value_len", "val_ln", "val_compl", "valjpl", "value_Len", "val_mem", " val_Len", "val67pl", "val_Len", "valjLen", "valjln"], "name": ["key", "t", "p", "Name", "no", "ame", "a", "id", "v", "data", "length", "label", "me", "path", "error", "parent", "prefix", "str", "val", "alias", "nam", "nm", "size", "word", "mem", "b", "def", "info", "ref", "ma", "new", "len", "code", "record", "m", "na", "local", "part", "names", "var", "num", "title", "null", "n", "create", "value", "NAME"]}}
{"project": "qemu", "commit_id": "3f910692c287e1c611c00e763ebeb95ed0e017f8", "target": 1, "func": "static int vhdx_log_write(BlockDriverState *bs, BDRVVHDXState *s,\n\n                          void *data, uint32_t length, uint64_t offset)\n\n{\n\n    int ret = 0;\n\n    void *buffer = NULL;\n\n    void *merged_sector = NULL;\n\n    void *data_tmp, *sector_write;\n\n    unsigned int i;\n\n    int sector_offset;\n\n    uint32_t desc_sectors, sectors, total_length;\n\n    uint32_t sectors_written = 0;\n\n    uint32_t aligned_length;\n\n    uint32_t leading_length = 0;\n\n    uint32_t trailing_length = 0;\n\n    uint32_t partial_sectors = 0;\n\n    uint32_t bytes_written = 0;\n\n    uint64_t file_offset;\n\n    VHDXHeader *header;\n\n    VHDXLogEntryHeader new_hdr;\n\n    VHDXLogDescriptor *new_desc = NULL;\n\n    VHDXLogDataSector *data_sector = NULL;\n\n    MSGUID new_guid = { 0 };\n\n\n\n    header = s->headers[s->curr_header];\n\n\n\n    /* need to have offset read data, and be on 4096 byte boundary */\n\n\n\n    if (length > header->log_length) {\n\n        /* no log present.  we could create a log here instead of failing */\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    if (guid_eq(header->log_guid, zero_guid)) {\n\n        vhdx_guid_generate(&new_guid);\n\n        vhdx_update_headers(bs, s, false, &new_guid);\n\n    } else {\n\n        /* currently, we require that the log be flushed after\n\n         * every write. */\n\n        ret = -ENOTSUP;\n\n        goto exit;\n\n    }\n\n\n\n    /* 0 is an invalid sequence number, but may also represent the first\n\n     * log write (or a wrapped seq) */\n\n    if (s->log.sequence == 0) {\n\n        s->log.sequence = 1;\n\n    }\n\n\n\n    sector_offset = offset % VHDX_LOG_SECTOR_SIZE;\n\n    file_offset = (offset / VHDX_LOG_SECTOR_SIZE) * VHDX_LOG_SECTOR_SIZE;\n\n\n\n    aligned_length = length;\n\n\n\n    /* add in the unaligned head and tail bytes */\n\n    if (sector_offset) {\n\n        leading_length = (VHDX_LOG_SECTOR_SIZE - sector_offset);\n\n        leading_length = leading_length > length ? length : leading_length;\n\n        aligned_length -= leading_length;\n\n        partial_sectors++;\n\n    }\n\n\n\n    sectors = aligned_length / VHDX_LOG_SECTOR_SIZE;\n\n    trailing_length = aligned_length - (sectors * VHDX_LOG_SECTOR_SIZE);\n\n    if (trailing_length) {\n\n        partial_sectors++;\n\n    }\n\n\n\n    sectors += partial_sectors;\n\n\n\n    /* sectors is now how many sectors the data itself takes, not\n\n     * including the header and descriptor metadata */\n\n\n\n    new_hdr = (VHDXLogEntryHeader) {\n\n                .signature           = VHDX_LOG_SIGNATURE,\n\n                .tail                = s->log.tail,\n\n                .sequence_number     = s->log.sequence,\n\n                .descriptor_count    = sectors,\n\n                .reserved            = 0,\n\n                .flushed_file_offset = bdrv_getlength(bs->file->bs),\n\n                .last_file_offset    = bdrv_getlength(bs->file->bs),\n\n              };\n\n\n\n    new_hdr.log_guid = header->log_guid;\n\n\n\n    desc_sectors = vhdx_compute_desc_sectors(new_hdr.descriptor_count);\n\n\n\n    total_length = (desc_sectors + sectors) * VHDX_LOG_SECTOR_SIZE;\n\n    new_hdr.entry_length = total_length;\n\n\n\n    vhdx_log_entry_hdr_le_export(&new_hdr);\n\n\n\n    buffer = qemu_blockalign(bs, total_length);\n\n    memcpy(buffer, &new_hdr, sizeof(new_hdr));\n\n\n\n    new_desc = buffer + sizeof(new_hdr);\n\n    data_sector = buffer + (desc_sectors * VHDX_LOG_SECTOR_SIZE);\n\n    data_tmp = data;\n\n\n\n    /* All log sectors are 4KB, so for any partial sectors we must\n\n     * merge the data with preexisting data from the final file\n\n     * destination */\n\n    merged_sector = qemu_blockalign(bs, VHDX_LOG_SECTOR_SIZE);\n\n\n\n    for (i = 0; i < sectors; i++) {\n\n        new_desc->signature       = VHDX_LOG_DESC_SIGNATURE;\n\n        new_desc->sequence_number = s->log.sequence;\n\n        new_desc->file_offset     = file_offset;\n\n\n\n        if (i == 0 && leading_length) {\n\n            /* partial sector at the front of the buffer */\n\n            ret = bdrv_pread(bs->file, file_offset, merged_sector,\n\n                             VHDX_LOG_SECTOR_SIZE);\n\n            if (ret < 0) {\n\n                goto exit;\n\n            }\n\n            memcpy(merged_sector + sector_offset, data_tmp, leading_length);\n\n            bytes_written = leading_length;\n\n            sector_write = merged_sector;\n\n        } else if (i == sectors - 1 && trailing_length) {\n\n            /* partial sector at the end of the buffer */\n\n            ret = bdrv_pread(bs->file,\n\n                            file_offset,\n\n                            merged_sector + trailing_length,\n\n                            VHDX_LOG_SECTOR_SIZE - trailing_length);\n\n            if (ret < 0) {\n\n                goto exit;\n\n            }\n\n            memcpy(merged_sector, data_tmp, trailing_length);\n\n            bytes_written = trailing_length;\n\n            sector_write = merged_sector;\n\n        } else {\n\n            bytes_written = VHDX_LOG_SECTOR_SIZE;\n\n            sector_write = data_tmp;\n\n        }\n\n\n\n        /* populate the raw sector data into the proper structures,\n\n         * as well as update the descriptor, and convert to proper\n\n         * endianness */\n\n        vhdx_log_raw_to_le_sector(new_desc, data_sector, sector_write,\n\n                                  s->log.sequence);\n\n\n\n        data_tmp += bytes_written;\n\n        data_sector++;\n\n        new_desc++;\n\n        file_offset += VHDX_LOG_SECTOR_SIZE;\n\n    }\n\n\n\n    /* checksum covers entire entry, from the log header through the\n\n     * last data sector */\n\n    vhdx_update_checksum(buffer, total_length,\n\n                         offsetof(VHDXLogEntryHeader, checksum));\n\n\n\n    /* now write to the log */\n\n    ret = vhdx_log_write_sectors(bs, &s->log, &sectors_written, buffer,\n\n                                 desc_sectors + sectors);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    if (sectors_written != desc_sectors + sectors) {\n\n        /* instead of failing, we could flush the log here */\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    s->log.sequence++;\n\n    /* write new tail */\n\n    s->log.tail = s->log.write;\n\n\n\nexit:\n\n    qemu_vfree(buffer);\n\n    qemu_vfree(merged_sector);\n\n    return ret;\n\n}\n", "idx": 6545, "substitutes": {"bs": ["os", "ubs", "ds", "bh", "bt", "bm", "ms", "vs", "ps", "aos", "ss", "ns", "js", "b", "bb", "BS", "blocks", "ses", "bl", "sts", "rs", "gs", "ts", "es", "obs", "lbs", "fs", "its", "bp", "cs", "sb", "ls", "sys", "bc"], "s": ["t", "os", "S", "p", "ds", "is", "ms", "v", "sp", "r", "ps", "vs", "serv", "server", "ss", "h", "comm", "changes", "ns", "js", "hs", "b", "state", "support", "ses", "sts", "socket", "rs", "store", "gs", "ts", "sn", "es", "stats", "actions", "comments", "bits", "fs", "its", "sv", "bis", "cs", "session", "sb", "settings", "ls", "qs", "n", "sys", "services"], "data": ["extra", "binary", "d", "image", "error", "DATA", "reader", "partial", "Data", "o", "body", "size", "bytes", "buf", "text", "ata", "command", "row", "table", "bin", "message", "block", "pos", "next", "batch"], "length": ["ptr", "capacity", "t", "present", "oh", "ENGTH", "limit", "family", "full", "enth", "half", "f", "l", "SIZE", "position", "DATA", "padding", "duration", "address", "required", "version", "h", "ength", "read", "location", "size", "available", "before", "history", "bytes", "index", "name", "shift", "term", "amount", "maximum", "type", "row", "len", "height", "end", "expected", "head", "loop", "all", "L", "number", "count", "HH", "angle", "message", "start", "block", "total", "shape", "Length"], "offset": ["ptr", "t", "reset", "f", "origin", "id", "rot", "position", "error", "padding", "address", "version", "set", "o", "foot", "pad", "location", "size", "vector", "off", "pointer", "sector", "index", "slot", "shift", "trace", "timeout", "range", "seed", "ref", "row", "len", "head", "page", "addr", "base", "window", "Offset", "ob", "block", "pos", "start", "message", "out", "seek"], "buffer": ["ptr", "binary", "v", "channel", "address", "Buffer", "buff", "size", "history", "sector", "section", "memory", "comment", "buf", "tail", "row", "command", "table", "base", "writer", "block", "message", "cache", "batch"], "merged_sector": ["merged_ser", "merged2sector", "merged_section", "merged2vector", "merge_sector", "merge_ser", "merged2ser", "merged2section", "merge_section", "merge_vector", "merged_vector"], "data_tmp": [" data_mp", "data_mp", " data_writer", "dataactmp", "data_writer", " data_buf", "dataacmp", "data_buf", "dataacbuf", "dataacwriter"], "sector_write": ["sector2writ", "section_write", "sector2write", "sector_len", "sector___len", "sector___write", "sector_writ", "sector2offset", "section_offset", "sector___writ", "sector2len", "section_writ", "sector___offset", "section_len"], "i": ["t", " l", "p", "f", "l", "ii", " pos", "set", "si", "j", "di", "o", "ip", "info", " v", " si", "e", "ci", " len", "pi", " j", " index", "I", "phi", "start", " t", " count"], "sector_offset": ["sector_id", "sector_left", "ector_offset", "leader_offset", "sector_length", "test_id", "ector_area", "leader_off", "vector_offset", "sector_Offset", "sector_area", "testityoffset", "sector_start", "leader_index", "sectoritymask", "sectorityid", "vector_Offset", "testityleft", "sector_index", "sector_point", "test_offset", "sectorityoffset", "leader_no", "ector_index", "testitymask", "vector_point", "ector_start", "sector_off", "test_mask", "vector_length", "sector_no", "testityid", "sectorityleft", "test_left", "sector_mask"], "desc_sectors": ["desc_pectors", "desc_beors", "desc_veors", "desc_belements", "desc_bectors", "desc_vectors", "desc_selements", "desc_pegments", "desc_peors", "desc_segments", "desc_velements", "desc_seors", "desc_begments", "desc_pelements", "desc_vegments"], "sectors": [" seors", "veriers", "spegments", "vevers", "vellers", "severs", "teors", "negments", "seriers", "tegments", "nellers", "speriers", "vectors", "veors", " sellers", "vegments", "tectors", " seriers", "sellers", "tellers", " severs", "neriers", "nectors", "spectors", "segments", " segments", "spevers", "seors"], "total_length": ["total_duration", " total_len", "total_offset", "total_len", " total_duration", " total_offset"], "aligned_length": [" aligned___distance", "aligned67offset", "alignedlycommand", "aligneditylength", "aligneditydistance", "aligned_duration", "reported_offset", " aligned_offset", "aligned_capacity", "aligned___distance", "aligned___offset", "aligned___length", "aligned_Length", "aligned67direction", "aligned_distance", "fixedtlength", "aligned_value", "balanced_value", " aligned_Length", "aligned_direction", "alignedlylen", "aligned_len", "fixedtcommand", "aligned_build", "balanced_capacity", "aligneditylen", "aligned___duration", " aligned___duration", "reported_direction", "aligned_offset", "alignedlylength", "alignedlycount", "alignedmingvalue", "alignedJdistance", "alignedmingcapacity", "aligned_position", "fixed_len", " aligned_distance", "alignedtcommand", "aligned___build", "aligned_count", "fixedtlen", "alignedityduration", " aligned___length", " aligned_position", "aligned67value", "alignedminglength", "aligned___direction", "alignedtcount", "aligned67length", "alignedmingresult", " aligned_duration", "balanced_length", "aligned67capacity", "alignedJduration", "aligned_result", "aligned_command", "reported_length", "fixed_command", "aligned67result", "aligned67build", " aligned_len", "alignedtlength", "reported_build", "fixedtcount", "aligned___len", "alignedtlen", "balanced_result", "fixed_count", " aligned___len", "alignedJlength", "alignedJlen", "fixed_length"], "file_offset": ["file__offset", "base_index", "file__start", "file_off", "file___page", "file_start", "byte_start", "file__index", "file64offset", "byte_offset", "base_page", "base_offset", "file64start", "byte_off", "file_index", "file_page", "file___offset", "file64index", "file___start", "file___index", "file__page", "base_start", "byte_index", "file64off"], "header": ["wrapper", "dr", "ptr", "t", "master", "order", "p", "config", "heading", "handler", "hawk", "subject", "filter", "policy", "hash", "padding", "address", "server", "version", "description", "h", "prot", "attribute", "body", "profile", "history", "metadata", "layer", "state", "index", "section", "comment", "tree", "definition", "response", "peer", "status", "document", "record", "head", "tr", "table", "summary", "headers", "window", "Header", "meta", "writer", "block", "er", "frame", "cache", "event"], "new_hdr": ["new_hld", "new_chdr", "new_hder", "new_cder", "new_shdr", "new_shld", "new_chder", "new_cld", "new_cDR", "new_chld", "new_cdr", "new_shDR", "new_chDR", "new_hDR", "new_shder"], "new_desc": ["next_def", "next_description", "next_desc", "new_description", "new_def", "new_des", "new2def", "next___desc", "new___def", "next___description", "new___description", "new2description", "new___desc", "next_des", "next___des", "next___def", "new2desc", "new2des", "new___des"], "data_sector": [" data_table", "data_section", " data_section", " data_ser", "data_table", "data_ser"], "partial_sectors": ["partial_bevers", "partial_serctors", "partial_vevers", "partial_veors", "partial_segments", "partial_beors", "partial_vegments", "partial_seors", "partial_spegments", "partial_serores", "partial_sercars", "partial_sesctors", "partial_speors", "partial_vecars", "partial_sescars", "partial_begments", "partial_secars", "partial_sesors", "partial_spevers", "partial_bectors", "partial_veores", "partial_sesores", "partial_vectors", "partial_spectors", "partial_seores", "partial_severs", "partial_serors"], "sequence": ["controller", "component", "secret", "position", "note", "counter", "frequency", "server", "version", "delay", "choice", "cycle", "next", "action", "chain", "section", "index", "step", "timeout", "serial", "seed", "store", "command", "sample", "sequ", "expected", "scale", "repeat", "reference", "seq", "queue", "series", "message", "ence", "frame", "se", "batch"]}}
{"project": "qemu", "commit_id": "aa4a3dce1c88ed51b616806b8214b7c8428b7470", "target": 1, "func": "static void vmxnet3_net_uninit(VMXNET3State *s)\n\n{\n\n    g_free(s->mcast_list);\n\n    vmxnet_tx_pkt_reset(s->tx_pkt);\n\n    vmxnet_tx_pkt_uninit(s->tx_pkt);\n\n    vmxnet_rx_pkt_uninit(s->rx_pkt);\n\n    qemu_del_nic(s->nic);\n\n}\n", "idx": 6547, "substitutes": {"s": ["os", "S", "sports", "ds", "details", "is", "a", "d", "l", "v", "r", "ps", "spec", "ins", "vs", "ies", "sl", "w", "less", "set", "ss", "h", "aws", "comm", "changes", "bs", "js", "ns", "hs", "sq", "ses", "sts", "rs", "gs", "y", "ties", "ts", "ops", "stats", "fs", "its", "sv", "args", "cs", "sb", "c", "as", "ls", "n", "qs", "sol", "states"]}}
{"project": "FFmpeg", "commit_id": "ec3b22326dc07fb8300a577bd6b17c19a0f1bcf7", "target": 1, "func": "static int http_prepare_data(HTTPContext *c)\n\n{\n\n    int i;\n\n\n\n    switch(c->state) {\n\n    case HTTPSTATE_SEND_DATA_HEADER:\n\n        memset(&c->fmt_ctx, 0, sizeof(c->fmt_ctx));\n\n        if (c->stream->feed) {\n\n            /* open output stream by using specified codecs */\n\n            c->fmt_ctx.oformat = c->stream->fmt;\n\n            c->fmt_ctx.nb_streams = c->stream->nb_streams;\n\n            for(i=0;i<c->fmt_ctx.nb_streams;i++) {\n\n                AVStream *st;\n\n                st = av_mallocz(sizeof(AVStream));\n\n                c->fmt_ctx.streams[i] = st;\n\n                if (c->stream->feed == c->stream)\n\n                    memcpy(st, c->stream->streams[i], sizeof(AVStream));\n\n                else\n\n                    memcpy(st, c->stream->feed->streams[c->stream->feed_streams[i]], sizeof(AVStream));\n\n\n\n                st->codec.frame_number = 0; /* XXX: should be done in\n\n                                               AVStream, not in codec */\n\n            }\n\n            c->got_key_frame = 0;\n\n        } else {\n\n            /* open output stream by using codecs in specified file */\n\n            c->fmt_ctx.oformat = c->stream->fmt;\n\n            c->fmt_ctx.nb_streams = c->fmt_in->nb_streams;\n\n            for(i=0;i<c->fmt_ctx.nb_streams;i++) {\n\n                AVStream *st;\n\n                st = av_mallocz(sizeof(AVStream));\n\n                c->fmt_ctx.streams[i] = st;\n\n                memcpy(st, c->fmt_in->streams[i], sizeof(AVStream));\n\n                st->codec.frame_number = 0; /* XXX: should be done in\n\n                                               AVStream, not in codec */\n\n            }\n\n            c->got_key_frame = 0;\n\n        }\n\n        init_put_byte(&c->fmt_ctx.pb, c->pbuffer, PACKET_MAX_SIZE,\n\n                      1, c, NULL, http_write_packet, NULL);\n\n        c->fmt_ctx.pb.is_streamed = 1;\n\n        /* prepare header */\n\n        av_write_header(&c->fmt_ctx);\n\n        c->state = HTTPSTATE_SEND_DATA;\n\n        c->last_packet_sent = 0;\n\n        break;\n\n    case HTTPSTATE_SEND_DATA:\n\n        /* find a new packet */\n\n#if 0\n\n        fifo_total_size = http_fifo_write_count - c->last_http_fifo_write_count;\n\n        if (fifo_total_size >= ((3 * FIFO_MAX_SIZE) / 4)) {\n\n            /* overflow : resync. We suppose that wptr is at this\n\n               point a pointer to a valid packet */\n\n            c->rptr = http_fifo.wptr;\n\n            c->got_key_frame = 0;\n\n        }\n\n        \n\n        start_rptr = c->rptr;\n\n        if (fifo_read(&http_fifo, (UINT8 *)&hdr, sizeof(hdr), &c->rptr) < 0)\n\n            return 0;\n\n        payload_size = ntohs(hdr.payload_size);\n\n        payload = av_malloc(payload_size);\n\n        if (fifo_read(&http_fifo, payload, payload_size, &c->rptr) < 0) {\n\n            /* cannot read all the payload */\n\n            av_free(payload);\n\n            c->rptr = start_rptr;\n\n            return 0;\n\n        }\n\n        \n\n        c->last_http_fifo_write_count = http_fifo_write_count - \n\n            fifo_size(&http_fifo, c->rptr);\n\n        \n\n        if (c->stream->stream_type != STREAM_TYPE_MASTER) {\n\n            /* test if the packet can be handled by this format */\n\n            ret = 0;\n\n            for(i=0;i<c->fmt_ctx.nb_streams;i++) {\n\n                AVStream *st = c->fmt_ctx.streams[i];\n\n                if (test_header(&hdr, &st->codec)) {\n\n                    /* only begin sending when got a key frame */\n\n                    if (st->codec.key_frame)\n\n                        c->got_key_frame |= 1 << i;\n\n                    if (c->got_key_frame & (1 << i)) {\n\n                        ret = c->fmt_ctx.format->write_packet(&c->fmt_ctx, i,\n\n                                                                   payload, payload_size);\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n            if (ret) {\n\n                /* must send trailer now */\n\n                c->state = HTTPSTATE_SEND_DATA_TRAILER;\n\n            }\n\n        } else {\n\n            /* master case : send everything */\n\n            char *q;\n\n            q = c->buffer;\n\n            memcpy(q, &hdr, sizeof(hdr));\n\n            q += sizeof(hdr);\n\n            memcpy(q, payload, payload_size);\n\n            q += payload_size;\n\n            c->buffer_ptr = c->buffer;\n\n            c->buffer_end = q;\n\n        }\n\n        av_free(payload);\n\n#endif\n\n        {\n\n            AVPacket pkt;\n\n\n\n            /* read a packet from the input stream */\n\n            if (c->stream->feed) {\n\n                ffm_set_write_index(c->fmt_in, \n\n                                    c->stream->feed->feed_write_index,\n\n                                    c->stream->feed->feed_size);\n\n            }\n\n            \n\n            if (av_read_packet(c->fmt_in, &pkt) < 0) {\n\n                if (c->stream->feed && c->stream->feed->feed_opened) {\n\n                    /* if coming from feed, it means we reached the end of the\n\n                       ffm file, so must wait for more data */\n\n                    c->state = HTTPSTATE_WAIT_FEED;\n\n                    return 1; /* state changed */\n\n                } else {\n\n                    /* must send trailer now because eof or error */\n\n                    c->state = HTTPSTATE_SEND_DATA_TRAILER;\n\n                }\n\n            } else {\n\n                /* send it to the appropriate stream */\n\n                if (c->stream->feed) {\n\n                    /* if coming from a feed, select the right stream */\n\n                    for(i=0;i<c->stream->nb_streams;i++) {\n\n                        if (c->stream->feed_streams[i] == pkt.stream_index) {\n\n                            pkt.stream_index = i;\n\n                            if (pkt.flags & PKT_FLAG_KEY) {\n\n                                c->got_key_frame |= 1 << i;\n\n                            }\n\n                            /* See if we have all the key frames, then \n\n                             * we start to send. This logic is not quite\n\n                             * right, but it works for the case of a \n\n                             * single video stream with one or more\n\n                             * audio streams (for which every frame is \n\n                             * typically a key frame). \n\n                             */\n\n                            if (!c->stream->send_on_key || ((c->got_key_frame + 1) >> c->stream->nb_streams)) {\n\n                                goto send_it;\n\n                            }\n\n                        }\n\n                    }\n\n                } else {\n\n                    AVCodecContext *codec;\n\n                send_it:\n\n                    /* Fudge here */\n\n                    codec = &c->fmt_ctx.streams[pkt.stream_index]->codec;\n\n\n\n                    codec->key_frame = ((pkt.flags & PKT_FLAG_KEY) != 0);\n\n\n\n#ifdef PJSG\n\n                    if (codec->codec_type == CODEC_TYPE_AUDIO) {\n\n                        codec->frame_size = (codec->sample_rate * pkt.duration + 500000) / 1000000;\n\n                        /* printf(\"Calculated size %d, from sr %d, duration %d\\n\", codec->frame_size, codec->sample_rate, pkt.duration); */\n\n                    }\n\n#endif\n\n\n\n                    if (av_write_packet(&c->fmt_ctx, &pkt, 0))\n\n                        c->state = HTTPSTATE_SEND_DATA_TRAILER;\n\n\n\n                    codec->frame_number++;\n\n                }\n\n\n\n                av_free_packet(&pkt);\n\n            }\n\n        }\n\n        break;\n\n    default:\n\n    case HTTPSTATE_SEND_DATA_TRAILER:\n\n        /* last packet test ? */\n\n        if (c->last_packet_sent)\n\n            return -1;\n\n        /* prepare header */\n\n        av_write_trailer(&c->fmt_ctx);\n\n        c->last_packet_sent = 1;\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 6556, "substitutes": {"c": ["tc", "p", "co", "conf", "vc", "l", "cont", "pc", "call", "C", "cn", "gc", "ci", "etc", "oc", "n", "nc", "mc", "cm", "cp", "ch", "com", "a", "r", "ctx", "con", "w", "h", "b", "err", "at", "uc", "enc", "this", "ce", "rc", "cu", "config", "f", "d", "lc", "dc", "cb", "cl", "fc", "chain", "rec", "e", "can", "cam", "m", "cs", "ct", "t", "cv", "form", "v", "cat", "ec", "cd", "coll", "cc", "abc", "comm", "o", "cr", "anc", "g", "cmp", "cf", "xc", "ca", "ac", "cal", "cod", "cache", "bc"], "i": [" wi", "ii", " ni", "ini", " pi", "it", "hi", " all", "di", "gi", "ie", "slice", " si", "y", "remote", "PI", "ci", "ami", " j", "ims", "qi", "cli", " t", " ii", " count", "json", " I", "ei", "ski", "ix", "list", "ic", "si", "oi", "j", "ji", "index", " v", "zi", "pi", "x", "phi", "us", "series", " port", " l", "is", "eu", "ind", "mi", "gu", "ri", "io", "chain", "ip", "ex", "point", "multi", "rest", " ti", "ti", "e", "m", "ai", "im", " mi", " k", "I", "u", " m", "li", " multi", "sim", " iter", "ki", "bi", "v", " pos", " bi", "me", "to", " my", "\u0438", "uri", " p", "in", "history", " li", "info", "g", "ui", "iu", "xi", "ij", "status", " index", "err", "batch"], "st": ["ust", "ST", "stage", "sc", "ace", "t", "et", "irst", "art", "no", "th", "cast", "tt", "ind", "sp", "nt", "cont", "ut", "it", "ost", "ft", "sta", "sm", "stable", "inst", "stack", "sl", "sam", "red", "str", "z", "set", "ld", "ist", "sth", "kt", "ast", "kl", "pt", "mt", "ste", "stop", "est", "sh", "std", "net", "sts", "step", "rest", "sn", "stat", "storage", "sv", "must", "ct", "nd", "St", "start", "sw"], "codec": ["odec", "componentesc", "oderer", "componentenc", "coeec", "coeeman", "coderer", "codeenc", "codeman", "dependvec", "codeesc", "dependerer", "codeec", "odvec", "codvec", "codenc", "coeenc", "codeerer", "componenteman", "codevec", "componentec", "codeeman", "codesc", "coeesc", "dependec"], "frame_number": ["frameckdate", "component_span", "state_number", "frameCountzero", "frame64code", "frame_zero", "frameCountnumber", "frame64date", "frame_key", "state_date", "frame____span", "component___name", "component___number", "component___span", "framecknumber", "frame_span", "frame_date", "frame_name", "frameckcode", "component___zero", "frame___zero", "frame___span", "frameckkey", "frame_code", "frame____name", "component_name", "frameCountspan", "frame____zero", "frame___number", "frame___name", "frameCountname", "component_zero", "state_code", "frame64number", "component_number", "frame64key", "frame____number", "state_key"]}}
{"project": "FFmpeg", "commit_id": "65db4899fa8790049bec3af16ecdb75dd81051fd", "target": 1, "func": "static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)\n\n{\n\n    if (!buffer->cmd) {\n\n        AVBufferRef *buf = buffer->user_data;\n\n        av_buffer_unref(&buf);\n\n    }\n\n    mmal_buffer_header_release(buffer);\n\n}\n", "idx": 6575, "substitutes": {"port": ["cp", "p", " sport", "id", "pc", "position", "connection", "address", "Port", "version", "ports", "pad", "ip", "socket", "timeout", "ref", "ort", "m", "gp", "page", "table", "PORT", "window", "number", "pid", "pod", "age"], "buffer": ["request", "entry", "seek", "cast", "button", "frame", "reflect", "data", "error", "sync", "bar", "address", "map", "Buffer", "server", "phrase", "pad", "device", "attribute", "buff", "empty", "profile", "index", "comment", "uffer", "timeout", "zero", "interface", "command", "iter", "match", "face", "head", "table", "bridge", "ter", "base", "flag", "header", "window", "reference", "queue", "null", "transfer", "timer", "callback", "block", "message", "program", "cache", "batch"], "buf": ["ph", "ptr", "pkg", "cv", "bh", "tmp", "mk", "v", "arr", "nt", "data", "func", "bar", "txt", "map", "cb", "aka", "br", "buff", "Buff", "ah", "bl", "cap", "ref", "alloc", "iter", "vec", "uf", "var", "seq", "queue", "cmd", "box", "rb", "bag", "bc", "batch"]}}
{"project": "qemu", "commit_id": "61c7480fa36775cc2baa2f8141f0c64a15f827b5", "target": 1, "func": "CPUArchState *cpu_copy(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUState *new_cpu = cpu_init(cpu_model);\n\n    CPUArchState *new_env = cpu->env_ptr;\n\n    CPUBreakpoint *bp;\n\n    CPUWatchpoint *wp;\n\n\n\n    /* Reset non arch specific state */\n\n    cpu_reset(new_cpu);\n\n\n\n    memcpy(new_env, env, sizeof(CPUArchState));\n\n\n\n    /* Clone all break/watchpoints.\n\n       Note: Once we support ptrace with hw-debug register access, make sure\n\n       BP_CPU break/watchpoints are handled correctly on clone. */\n\n    QTAILQ_INIT(&cpu->breakpoints);\n\n    QTAILQ_INIT(&cpu->watchpoints);\n\n    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {\n\n        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);\n\n    }\n\n    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n\n        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);\n\n    }\n\n\n\n    return new_env;\n\n}\n", "idx": 6577, "substitutes": {"env": ["ptr", "vp", "et", "dev", "environment", "cv", "conn", "v", "ec", "vs", "ctx", "me", "eg", "enter", "ev", "obj", "w", "node", "server", "cur", "ew", "en", "nv", "h", "ve", "esm", "eve", "eq", "np", "ah", "buf", "buffer", "vm", "enc", "e", "end", "esp", "sv", "window", "ef", "context", "er", "vt", "viron", "err"], "cpu": ["ka", "cu", "cp", "util", "clus", "uart", "rpm", "apache", "CU", "python", "processor", "efficiency", "ctx", "rane", "pixel", "linux", "prof", "gpu", "CP", "node", "ruby", "uu", "bench", "cn", "gc", "ne", "none", "hog", "profile", "nu", "proc", "clock", "currency", "name", "computer", "que", "nz", "CPU", "net", "lif", "gb", "ilo", "bean", "process", "crypt", "coin", "stat", "ockey", "runner", "pu", "core", "hw", "cum", "ni", "us", "goal", "aux", "software", "nic", "library", "docker"], "new_cpu": ["new___pu", "admin_uu", "exportingCPU", "new67uu", "newingenv", "newablegnu", "old_cpu", "new_uu", "new_cu", "new___cpu", "New_cpu", "new_processor", "newingCPU", "old___pu", "old_cp", "new_gnu", "old___cpu", "export_env", "New_gnu", "newlyprocessor", "admin67processor", "new67processor", "admin67cpu", "admin_processor", "admin67uu", "newingcp", "new___cu", "old___cp", "old_pu", "newablepu", "old_cu", "new_pu", "export_cp", "New_pu", "exportingcp", "export_cpu", "newlyuu", "admin_cpu", "New_nic", "newablenic", "new67cpu", "new_nic", "export_CPU", "new_CPU", "new_cp", "new___cp", "newlycpu", "old___cu", "exportingenv", "exportingcpu", "newingcpu", "newablecpu"], "new_env": ["new_environment", "new___env", "new_en", "new___vert", " new_environment", "new_ptr", "new_db", "NEW_end", "NEW_en", "newResenvironment", " new_ptr", "new___environment", "NEW_ev", "newResptr", "new_vert", "new_end", " new_db", "newResenv", " new_en", " new_vert", "new_ev", "new___db", "newResen", "NEW_env"], "bp": ["vp", "pp", "cp", "p", "lb", "bps", "bh", "bj", "lp", "bt", "PB", "vs", "pc", "BP", "br", "bs", "arp", "BIP", "np", "bb", "osp", "pb", "bl", "gb", "kb", "ipp", "ba", "fp", "tp", "dp", "pd", "jp", "bg", "lbs", "lip", "yp", "gp", "wr", "isp", "eb", "sb", "hp", "bf", "bsp", "nb", "bc"], "wp": ["vp", "cp", "p", "pkg", "ww", "lp", "vc", "wx", "rw", "wal", "pc", "mp", "w", "fw", "wk", "wordpress", "wy", "php", "wt", "arp", "wn", "we", "np", "ht", "wd", "WP", "wu", "pb", "wi", "fp", "tp", "dp", "wl", "jp", "wm", "nw", "yp", "wr", "mm", "hw", "hp", "hop", "iw", "wb"]}}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "static void avc_luma_vt_and_aver_dst_16x16_msa(const uint8_t *src,\n\n                                               int32_t src_stride,\n\n                                               uint8_t *dst, int32_t dst_stride)\n\n{\n\n    int32_t loop_cnt;\n\n    int16_t filt_const0 = 0xfb01;\n\n    int16_t filt_const1 = 0x1414;\n\n    int16_t filt_const2 = 0x1fb;\n\n    v16u8 dst0, dst1, dst2, dst3;\n\n    v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8;\n\n    v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r;\n\n    v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l;\n\n    v16i8 src65_l, src87_l;\n\n    v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l;\n\n    v16i8 filt0, filt1, filt2;\n\n    v16u8 res0, res1, res2, res3;\n\n\n\n    filt0 = (v16i8) __msa_fill_h(filt_const0);\n\n    filt1 = (v16i8) __msa_fill_h(filt_const1);\n\n    filt2 = (v16i8) __msa_fill_h(filt_const2);\n\n\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n    ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_r, src21_r, src32_r, src43_r);\n\n    ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_l, src21_l, src32_l, src43_l);\n\n\n\n    for (loop_cnt = 4; loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src5, src6, src7, src8);\n\n        src += (4 * src_stride);\n\n\n\n        XORI_B4_128_SB(src5, src6, src7, src8);\n\n        ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_r, src65_r, src76_r, src87_r);\n\n        ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_l, src65_l, src76_l, src87_l);\n\n        out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, filt0, filt1, filt2);\n\n        out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2);\n\n        out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2);\n\n        out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, filt0, filt1, filt2);\n\n        out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2);\n\n        out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2);\n\n        out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2);\n\n        out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2);\n\n        SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5);\n\n        SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5);\n\n        SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7);\n\n        SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7);\n\n        LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3);\n\n        PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l,\n\n                    out3_r, res0, res1, res2, res3);\n\n        XORI_B4_128_UB(res0, res1, res2, res3);\n\n        AVER_UB4_UB(res0, dst0, res1, dst1, res2, dst2, res3, dst3,\n\n                    res0, res1, res2, res3);\n\n        ST_UB4(res0, res1, res2, res3, dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n\n\n        src10_r = src54_r;\n\n        src32_r = src76_r;\n\n        src21_r = src65_r;\n\n        src43_r = src87_r;\n\n        src10_l = src54_l;\n\n        src32_l = src76_l;\n\n        src21_l = src65_l;\n\n        src43_l = src87_l;\n\n        src4 = src8;\n\n    }\n\n}\n", "idx": 6580, "substitutes": {"src": ["rc", "sc", "seek", "RC", "ser", "syn", "dest", "sel", "ctr", "load", "dist", "ins", "url", "scan", "sync", "rl", "inst", "serv", "sub", "sl", "ul", "loc", "cur", "st", "supp", "sr", "source", "usr", "sys", "comp", "std", "rs", "enc", "sn", "stat", "iv", "rol", "tr", "addr", "sb", "rob", "rt", "input", "img", "sort"], "src_stride": ["src_dride", "src_Strension", "src_bride", "src_trides", "src_strade", "src_strid", "src_strate", "src_decension", "src_trend", "src_slide", "src_tride", "src_drend", "src_strides", "src_STRade", "src_slension", "src_Strate", "src_slade", "src_strension", "src_divice", "src_brride", "src_Stride", "src_decate", "src_Strid", "src_strend", "src_STRid", "src_drride", "src_divade", "src_decade", "src_STRide", "src_Strade", "src_strride", "src_trride", "src_strice", "src_divide", "src_divid", "src_Strice", "src_slate", "src_STRice", "src_brend", "src_decide", "src_drides", "src_brides"], "dst": ["ssrc", " ddest", "sest", "dsrc", "sst", "Ddest", "ddest", "dest", "sdest", "Dsrc", " dest", "Dest", "Dst", " dsrc"], "dst_stride": ["dst_trend", "dst_strride", "dst_slider", "dst_strend", "dst_trride", "dst_tride", "dst_slide", "dst_decend", "dst_slend", "dst_decide", "dst_trider", "dst_strider", "dst_slride", "dst_decride", "dst_decider"], "loop_cnt": ["loop_tcnt", "loop_CNT", "loop_cnc", "loop_lcnc", "loop_cNT", "loop_cgt", "loop_tcnc", "loop_Cgt", "loop_Cnt", "loop_lcgt", "loop_Cnc", "loop_tcgt", "loop_tcNT", "loop_lcnt", "loop_lcNT"], "dst0": [" dset4", "dest4", "dost4", " dst4", " dset1", "dset1", "dest1", "dest0", "dset4", " dset0", "dost1", "dst4", "dost0", "dset0"], "dst1": ["ddest1", "dput2", "dast2", "dast1", "dput1", "dst5", "dast5", "daput1", "dest1", "ddest5", "dest3", "daput3", "dput3", "dest5", "daput5", "ddest3", "dest2", "dast3", "ddest2", "daput2", "dput5"], "dst2": [" dsp6", "dost02", "dost6", " dst6", "dput02", "dost8", "dost2", "dput8", "dput2", "dst02", " dst8", "dput6", "dst8", " dsp02", "dsp8", "dsp6", " dsp2", " dst02", "dsp02", " dsp8", "dsp2", "dst6"], "dst3": ["dint2", " dint1", " dint3", " dint2", "dost8", "dost2", "dint8", "dost3", " dst8", "dst8", "dest8", "dest1", "dest3", "dint3", "dest2", " dint8", "dost1", "dint1"], "src0": ["source0", "source3", "source1", " src00", "rc0", "source2", "src00", "rc3", "sr1", "rc00", "rc1", "sr0", "sr00", "source5", "rc5", "rc2"], "src1": ["source0", "source3", "source1", " src11", "proc6", "rc01", "src01", "proc3", "rc0", "source2", " src01", "sys2", "rc3", "source4", "src11", "source6", "sys3", "rc4", "rc1", "sys0", "rc6", "rc2", "sys1", "proc1", "source11", "source01", "rc11", "proc2"], "src2": ["source0", "source3", "source1", " src10", "rc0", "src02", "source2", "ser1", "rc3", "source4", "ser2", "ser0", "rc4", "src10", "rc1", "ser4", "rc02", "source10", "rc2", " src02", "source02", "rc10", "ser02"], "src3": ["source43", "source3", "source0", "usr1", "sc03", "ser03", "source1", "rc03", "rc43", "rc0", "source2", "rc3", "source4", "ser2", "src43", " src03", "usr43", "rc4", "rc1", "usr3", "sc2", "src03", "sc3", "rc2", "usr2", "source03", "ser3"], "src4": ["source0", "source3", "sn44", "sc6", "sn4", "rc44", "rc0", "source2", "src32", "rc3", "rc32", "source4", "src44", " src44", "rc4", "source44", "sc4", "sc2", "sc5", "rc6", "rc5", "rc2", "source5", "sn32", "source32"], "src5": ["srcFive", "inst5", "rc5", "st5", "stFive", "inst65", "instFive", "rcFive", "st65", "rc65", "src65"], "src6": ["rc6", "sr7", "sr8", "src48", "source8", "rc48", "sr48", "sr6", "rc8", "rc7", "source7", "source6", "source48"], "src7": [" src07", "sr07", "sr7", "rc07", "sr17", "sr8", "src17", "src07", "rc17", "rc8", "rc7", " src17"], "src8": ["src9", "source5", "rc5", "rc0", "source0", "source8", "rc9", "rc8", "source9", " src9"], "src10_r": ["src90_r", "src10_R", "src10_pr", "src90_pr", "src8_m", "src8_l", "src8_r", "src8_R", "src90_R", "src10_m", "src90_l"], "src32_r": ["src3200r", "src32_er", "src42_r", "src42_sr", "src42_l", "src3200er", "src3200sr", "src32_sr", "src3200l", "src42_er"], "src54_r": ["src43_k", "src54_ro", "src54___k", "src54_k", "src54___ro", "src43_ro", "src54___l", "src54___r"], "src76_r": ["src74_l", "src76_R", "src74_m", "src74_r", "src76_m", "src74_R"], "src21_r": ["src41_ro", "src41_right", "src21_right", "src41_r", "src41_l", "src21_ro"], "src43_r": ["src43_R", "src65_cr", "src43_cr", "src65_ro", "src65_R", "src43_ro"], "src65_r": ["src66_e", "src66_r", "src65_e", "src65_ro", "src66_ro", "src66_l"], "src87_r": ["src57_r", "src57_p", "src57_R", "src87_R", "src57_l", "src87_p"], "src10_l": ["src80_l", "src10_lb", "src80_ml", "src80_lb", "src10_ls", "src80_ls", "src10_ml"], "src32_l": ["src32ablecl", "src32ablerl", "src44_cl", "src32_cl", "src44ablecl", "src32ablel", "src44_rl", "src44ablerl", "src32_rl", "src44_ll", "src32ablell", "src44ablell", "src32_ll", "src44_l", "src44ablel"], "src54_l": ["src62_loc", "src54_loc", "src54_c", "src62_l", "src62_pl", "src62_c", "src54_pl"], "src76_l": ["src65_lp", "src76_lp", "src76___pl", "src65_pl", "src76_m", "src76___l", "src76___m", "src76___lp", "src76_pl", "src65_m"], "src21_l": ["src21_ls", "src31_p", "src31_l", "src31_h", "src21_h", "src31_ls", "src21_p"], "src43_l": ["src43___lp", "src43_ml", "src73_lp", "src43_pl", "src43___l", "src73___pl", "src73___ml", "src73_pl", "src43___ml", "src73_l", "src73___l", "src43_lp", "src73___lp", "src43___pl", "src73_ml"], "src65_l": ["src65_b", "src48_b", "src48_p", "src65_p", "src48_l", "src65_h", "src48_h"], "src87_l": ["src63_l", "src63_h", "src87_lb", "src63_lb", "src63_lc", "src87_h", "src87_lc"], "out0_r": ["out10_r", "out10_R", "out10_p", "out02R", "out0_p", "out0_m", "out0_R", "out10_m", "out02r", "out02m", "out02p"], "out1_r": ["out1_fr", "out4_r", "out4_fr", "out4_rd", "out1_rd"], "out2_r": ["out02_r", "out02_re", "out02_l", "out2_b", "out2_re", "out02_b"], "out3_r": ["out15_r", "out15_R", "out3_R", "out3_s", "out15_l", "out15_s"], "out0_l": ["out0_ll", "out0_sl", "out10_ll", "out0_m", "out10_sl", "out10_m", "out10_l"], "out1_l": ["out1_t", "out3_hl", "out1_hl", "out3_n", "out1_n", "out3_t"], "out2_l": ["out12_m", "out12_i", "out2_m", "out12_sl", "out2_i", "out12_l", "out2_sl"], "out3_l": ["out1_d", "out3_h", "out3_b", "out1_b", "out3_d", "out1_h"], "filt0": ["felt1", " fittee", " fil9", " fil0", " fil5", "filt3", "fil2", "fletee", "flet1", "fil0", " fitt3", "filtration9", " fitt0", "fil9", "fitt9", "fitt3", "fitt5", "fittee", "filtration0", "fitt1", "filtee", "fil5", "fitt0", "filtration2", " filt3", "flet3", "felt3", " filtee", "filt9", " filt5", "felt0", " filt9", "fitt2", "filt5", " fil2", "filtration5", "feltee", " fitt1", "flet0"], "filt1": ["frilt3", "ffilter1", " filt4", "filt3", "firm2", "ffilter3", "firt4", "filtration1", "filtrationOne", "filtration3", " fault0", "fault4", "fil0", "firt1", "friltOne", "fil4", "firm3", " fault4", "firt0", "firt5", "fil5", "filtration2", "frirm3", "ffilterOne", "frilt2", "frilt1", "fil1", "ffilter2", "frirmOne", "fault5", " filt5", "filtOne", "filt4", "fault1", " fault1", "frirm2", "filt5", "firm1", " fault5", "frirm1", "firmOne", "fault0"], "filt2": ["frilt3", " filt42", " filt4", " fld4", "frird2", "filt3", "facet5", "fil2", "facet4", "fil3", " fld5", "facet2", "fird3", "fift6", "fil4", "fird12", "frird12", "fld5", "facet42", "fil6", "fird6", "fil12", "frilt6", "fld2", "frird3", "fil5", "fird2", "filt42", " fld42", "fift12", "fift3", "fift2", "fld42", "frilt2", "fld4", " fld2", " filt5", "filt6", "filt4", "frilt12", "frird6", "filt5", "filt12", "fil42"], "res0": ["Res3", "Res1", "pres1", "pres3", "Res2", "Res0", "pres2", "pres0"], "res1": [" res01", "resolution4", "pres1", "resolution01", " res4", "resolution1", "pres0", "res01", "res4", "resolution0", "pres01", "pres4"], "res2": ["Res02", "Res8", " res8", " res4", "Res2", "pres02", "pres2", "pres8", "res02", "res4", " res02", "res8", "Res4", "pres4"], "res3": ["ret5", " res03", "pres3", "ret43", "pres5", "res03", "ret3", " res5", "pres43", "res43", " res43", "res5", "pres03", "ret03"]}}
{"project": "qemu", "commit_id": "6e99c631f116221d169ea53953d91b8aa74d297a", "target": 0, "func": "static int net_socket_can_send(void *opaque)\n\n{\n\n    NetSocketState *s = opaque;\n\n\n\n    return qemu_can_send_packet(&s->nc);\n\n}\n", "idx": 6594, "substitutes": {"opaque": ["opoid", "ocoid", "ocaque", "ogity", " Opacement", " Opause", "opacement", " opacement", "ogacity", "hopacement", " opossibly", "ogoid", " opause", "plaque", "opossibly", "hopossibly", "opause", " Opossibly", "hopause", "ogaque", "ocacity", " Opaque", "placity", "opacity", "hopaque", "ploid", "opity", "plity", "ocity"], "s": ["t", "os", "p", "ess", "S", "ds", "is", "a", "v", "sp", "r", "ps", "q", "sm", "sl", "sam", "less", "set", "ss", "j", "aws", "o", "i", "hs", "b", "sq", "sts", "rs", "gs", "ts", "fs", "sis", "sv", "cs", "sb", "c", "ls", "ats", "n"]}}
{"project": "qemu", "commit_id": "64d7e9a421fea0ac50b44541f5521de455e7cd5d", "target": 0, "func": "static void ppc_prep_init (ram_addr_t ram_size,\n\n                           const char *boot_device,\n\n                           const char *kernel_filename,\n\n                           const char *kernel_cmdline,\n\n                           const char *initrd_filename,\n\n                           const char *cpu_model)\n\n{\n\n    CPUState *env = NULL;\n\n    char *filename;\n\n    nvram_t nvram;\n\n    M48t59State *m48t59;\n\n    int PPC_io_memory;\n\n    int linux_boot, i, nb_nics1, bios_size;\n\n    ram_addr_t ram_offset, bios_offset;\n\n    uint32_t kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    PCIBus *pci_bus;\n\n    qemu_irq *i8259;\n\n    qemu_irq *cpu_exit_irq;\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DriveInfo *fd[MAX_FD];\n\n\n\n    sysctrl = qemu_mallocz(sizeof(sysctrl_t));\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"602\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        if (env->flags & POWERPC_FLAG_RTC_CLK) {\n\n            /* POWER / PowerPC 601 RTC clock frequency is 7.8125 MHz */\n\n            cpu_ppc_tb_init(env, 7812500UL);\n\n        } else {\n\n            /* Set time-base frequency to 100 Mhz */\n\n            cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n        }\n\n        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(NULL, \"ppc_prep.ram\", ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = qemu_ram_alloc(NULL, \"ppc_prep.bios\", BIOS_SIZE);\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        bios_size = get_image_size(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size > 0 && bios_size <= BIOS_SIZE) {\n\n        target_phys_addr_t bios_addr;\n\n        bios_size = (bios_size + 0xfff) & ~0xfff;\n\n        bios_addr = (uint32_t)(-bios_size);\n\n        cpu_register_physical_memory(bios_addr, bios_size,\n\n                                     bios_offset | IO_MEM_ROM);\n\n        bios_size = load_image_targphys(filename, bios_addr, bios_size);\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PPC PREP bios '%s'\\n\", bios_name);\n\n    }\n\n    if (filename) {\n\n        qemu_free(filename);\n\n    }\n\n\n\n    if (linux_boot) {\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                          initrd_filename);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        /* For now, OHW cannot boot from the network. */\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    isa_mem_base = 0xc0000000;\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        hw_error(\"Only 6xx bus is supported on PREP machine\\n\");\n\n    }\n\n    i8259 = i8259_init(first_cpu->irq_inputs[PPC6xx_INPUT_INT]);\n\n    pci_bus = pci_prep_init(i8259);\n\n    /* Hmm, prep has no pci-isa bridge ??? */\n\n    isa_bus_new(NULL);\n\n    isa_bus_irqs(i8259);\n\n    //    pci_bus = i440fx_init();\n\n    /* Register 8 MB of ISA IO space (needed for non-contiguous map) */\n\n    PPC_io_memory = cpu_register_io_memory(PPC_prep_io_read,\n\n                                           PPC_prep_io_write, sysctrl,\n\n                                           DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0x80000000, 0x00800000, PPC_io_memory);\n\n\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus);\n\n    //    openpic = openpic_init(0x00000000, 0xF0000000, 1);\n\n    //    pit = pit_init(0x40, i8259[0]);\n\n    rtc_init(2000, NULL);\n\n\n\n    if (serial_hds[0])\n\n        serial_isa_init(0, serial_hds[0]);\n\n    nb_nics1 = nb_nics;\n\n    if (nb_nics1 > NE2000_NB_MAX)\n\n        nb_nics1 = NE2000_NB_MAX;\n\n    for(i = 0; i < nb_nics1; i++) {\n\n        if (nd_table[i].model == NULL) {\n\n\t    nd_table[i].model = qemu_strdup(\"ne2k_isa\");\n\n        }\n\n        if (strcmp(nd_table[i].model, \"ne2k_isa\") == 0) {\n\n            isa_ne2000_init(ne2000_io[i], ne2000_irq[i], &nd_table[i]);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], \"ne2k_pci\", NULL);\n\n        }\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    for(i = 0; i < 1/*MAX_IDE_BUS*/; i++) {\n\n        isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                     hd[2 * i],\n\n\t\t     hd[2 * i + 1]);\n\n    }\n\n    isa_create_simple(\"i8042\");\n\n\n\n    cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);\n\n    DMA_init(1, cpu_exit_irq);\n\n\n\n    //    SB16_init();\n\n\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n    }\n\n    fdctrl_init_isa(fd);\n\n\n\n    /* Register speaker port */\n\n    register_ioport_read(0x61, 1, 1, speaker_ioport_read, NULL);\n\n    register_ioport_write(0x61, 1, 1, speaker_ioport_write, NULL);\n\n    /* Register fake IO ports for PREP */\n\n    sysctrl->reset_irq = first_cpu->irq_inputs[PPC6xx_INPUT_HRESET];\n\n    register_ioport_read(0x398, 2, 1, &PREP_io_read, sysctrl);\n\n    register_ioport_write(0x398, 2, 1, &PREP_io_write, sysctrl);\n\n    /* System control ports */\n\n    register_ioport_read(0x0092, 0x01, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0092, 0x01, 1, &PREP_io_800_writeb, sysctrl);\n\n    register_ioport_read(0x0800, 0x52, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0800, 0x52, 1, &PREP_io_800_writeb, sysctrl);\n\n    /* PCI intack location */\n\n    PPC_io_memory = cpu_register_io_memory(PPC_intack_read,\n\n                                           PPC_intack_write, NULL,\n\n                                           DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0xBFFFFFF0, 0x4, PPC_io_memory);\n\n    /* PowerPC control and status register group */\n\n#if 0\n\n    PPC_io_memory = cpu_register_io_memory(PPC_XCSR_read, PPC_XCSR_write,\n\n                                           NULL, DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0xFEFF0000, 0x1000, PPC_io_memory);\n\n#endif\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    m48t59 = m48t59_init(i8259[8], 0, 0x0074, NVRAM_SIZE, 59);\n\n    if (m48t59 == NULL)\n\n        return;\n\n    sysctrl->nvram = m48t59;\n\n\n\n    /* Initialise NVRAM */\n\n    nvram.opaque = m48t59;\n\n    nvram.read_fn = &m48t59_read;\n\n    nvram.write_fn = &m48t59_write;\n\n    PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, \"PREP\", ram_size, ppc_boot_device,\n\n                         kernel_base, kernel_size,\n\n                         kernel_cmdline,\n\n                         initrd_base, initrd_size,\n\n                         /* XXX: need an option to load a NVRAM image */\n\n                         0,\n\n                         graphic_width, graphic_height, graphic_depth);\n\n\n\n    /* Special port to get debug messages from Open-Firmware */\n\n    register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL);\n\n}\n", "idx": 6605, "substitutes": {"ram_size": ["ram_length", "rom_SIZE", "ram_scale", " ram_Size", " ram_space", "ram_SIZE", "rom_name", "rom_device", "ram_space", "ram_Size", " ram_length", "rom_size", "ram_name", " ram_scale", " ram_SIZE", "ram_device"], "boot_device": ["cpuingaddress", "cpu_dev", "cpuingdev", "cpu_directory", "boot_directory", "cpu_device", "boot_address", "cpuingdirectory", "cpu_address", "bootingdev", "bootingdevice", "bootingdirectory", "boot_dev", "bootingaddress", "cpuingdevice"], "kernel_filename": ["disk_file", "disk_family", "disk_filename", "disk_binary", "kernel_username", "kernel_family", "kernel_file", "disk_username", "kernel_address", "disk_address", "disk_fp", "kernel_fp", "kernel_binary"], "kernel_cmdline": ["kernel_commandcode", "kernel_ctrl", "kernel_directcode", "kernel_directl", "kernel_ctrline", "kernel_directline", "kernel_cmdl", "kernel_commandl", "kernel_cmdcode", "kernel_commandline", "kernel_ctrcode"], "initrd_filename": ["initrd_Filename", "initrt_filename", "initrt_Filename", "initrd_name", "initrt_name", "initrd_file", "initrt_file"], "cpu_model": ["pu_variable", "cpu2label", "cpu_label", "CPU_type", "cpu2variable", "CPU_name", "CPU_label", "cli_name", "cli67model", "cpu_fine", "cpu_Model", "pu_model", "pu2Model", "cpu2Model", "pu2variable", "cpu2name", "cpu2model", "cpu_name", "cpu_type", "cli_model", "cpu2type", "cpu67rule", "cpu67relation", "cli67relation", "cli67rule", "cpu_relation", "cpu67model", "cpu_variable", "pu2model", "CPU_fine", "cli_relation", "cpu_rule", "cli_rule", "CPU_Model", "pu_name", "pu_Model", "pu2name", "cpu67name", "CPU_model", "cli67name"], "env": ["entry", "vp", "t", "ei", "conf", "gear", "dev", "door", "environment", "cv", "tmp", "conn", "eu", "esc", "ped", "v", "ec", "vs", "ctx", "worker", "menu", "policy", "enter", "vt", "bar", "obj", "cb", "vv", "ext", "server", "ew", "en", "iev", "nv", "era", "here", "export", "eng", "forge", "mem", "proc", "ee", "state", "po", "ah", "manager", "info", "buf", "eni", "cap", "buffer", "vm", "e", "db", "end", "te", "esp", "window", "ent", "desc", "Environment", "ef", "qt", "context", "er", "ev", "viron", "err", "event", "uv"], "filename": ["fil", "json", "fn", "ame", "family", "ln", "f", "sbm", "processor", "path", "fle", "file", "prefix", "txt", "username", "uri", "FIL", "kl", "nm", "location", "ames", "name", "jpg", "fp", "rn", "wav", "ename", "fs", "lua", "println", "src", "nl", "til", "Filename"], "nvram": ["nngram", "nvmem", "vram", "nnram", "NVram", "nvrom", "NVgram", "nnrom", "nnmem", "nvgram", "vmem", "NVrom", "NVmem", "vrom", "vgram"], "m48t59": ["m64T59", "m48n60", "m48p60", "m48p59", "m64T23", "m64t58", "m48T59", "m48t23", "m64t23", "m48t58", "m64T58", "m64t59", "m48n23", "m48T58", "m48T23", "m48T60", "m48p58", "m64t60", "m48p23", "m48n59", "m48n58", "m64T60", "m48t60"], "PPC_io_memory": ["PPC_physical_address", "PPC_physical2mem", "PPC_physical_size", "PPC_physical2address", "PPC_io2memory", "PPC_io_address", "PPC_io_size", "PPC_io2mem", "PPC_physical_memory", "PPC_io2address", "PPC_physical_mem", "PPC_physical2size", "PPC_physical2memory", "PPC_io_mem", "PPC_io2size"], "linux_boot": ["linux_bus", "kernel_bus", "linux_start", "cpu_start", "kernel_bs", "kernel_boot", "cpu_bus", "linux_bs", "linux5bus", "kernel_Boot", "cpu_boot", "linux5boot", "linux5Boot", "linux_Boot", "linux5bs"], "i": ["t", "li", "p", "sim", "fi", "bi", "f", "id", "l", "v", "ii", "ini", "ind", "r", "mi", "ix", "tim", "me", "it", "gu", "hi", "si", "k", "j", "h", "di", "gi", "in", "ex", "b", "index", "info", "g", "ui", "multi", "iu", "xi", "y", "zi", "e", "ci", "ti", "m", "ami", "ai", "pi", "im", "ims", "qi", "I", "phi", "c", "cli", "sql", "n"], "nb_nics1": ["nb_micsize", "nb_micksize", "nb_niscmb", "nb_niscize", "nb_nicks3", "nb_nimsmb", "nb_nicks1", "nb_micsmb", "nb_mics3", "nb_nisc3", "nb_micks3", "nb_nicksize", "nb_nims3", "nb_nicsmb", "nb_nimsize", "nb_nisc1", "nb_mics1", "nb_micksmb", "nb_nims1", "nb_nicsize", "nb_micks1", "nb_nicksmb", "nb_nics3"], "bios_size": ["bio_name", "bio_sha", "bios_memory", "biosibmemory", "bio_memory", "bios_name", "bio_size", "biosibsha", "bios_sha", "biosibname", "biosibsize"], "ram_offset": ["RAM_addr", "gram_location", "RAM_offset", "ram__seed", "gram_offset", "ram_location", "ram67index", "RAM_index", "ram67seed", "ram__index", "ram__offset", "ram_address", "gram_size", "ram67addr", "ram_seed", "gram_Offset", "ram__addr", "ram_addr", "ram67offset", "RAM_seed", "ram_Offset", "gram_addr", "ram_index", "gram_address"], "bios_offset": ["bio_name", "bios__address", "bios_index", "bos_addr", "bio_index", "bios__name", "bio_online", "bios_address", "bios_online", "bios_name", "bos_address", "bios__addr", "bos_name", "bio_offset", "bos_offset", "bios__offset"], "kernel_base": ["kernel2base", "system_base", "kernel2size", "kernel_name", "kernel_buffer", "kernel2name", "system_size", "system_name", "kernel2buffer", "system_buffer"], "initrd_base": ["initrd2base", "initrs_name", "initrd_length", "initrd_name", "initrs_length", "initrs_base", "initrd2name", "initrs_size", "initrd2size", "initrd2length"], "kernel_size": ["kernel_SIZE", "kernel_count", "kernel_name", "system_size", "system_name", "system_count", "system_SIZE"], "initrd_size": ["initrs_name", "initrd_SIZE", "initrd_len", "initrd_name", "initrs_len", "initrs_size", "initrs_SIZE"], "pci_bus": ["pci_boot", "pci2boot", "pci_us", "pki_us", "pci__BUS", "pki_BUS", "pci__boot", "pci2us", "pki_boot", "pci2bus", "pci_BUS", "pci__us", "pki_bus", "pci__bus", "pci2BUS"], "i8259": ["i5259", "pi5259", "i3285", "pi5192", "pi8191", "i3192", "i5191", "i3259", "i8285", "pi8285", "i6285", "pi5285", "i6192", "pi8259", "i8191", "pi5191", "i8192", "i6259", "pi8192", "i6191", "i5192", "i5285", "i3191"], "cpu_exit_irq": ["cpu_exit_pirqs", "cpu_exit_irqs", "cpu_exit_mirq", "cpu_exit_pirQ", "cpu_exit_pirque", "cpu_exit_irQ", "cpu_exit_mirqs", "cpu_exit_mirQ", "cpu_exit_irque", "cpu_exit_mrqs", "cpu_exit_pirq", "cpu_exit_mrque", "cpu_exit_mrQ", "cpu_exit_mirque", "cpu_exit_mrq"], "ppc_boot_device": ["ppc_boot_buffer", "ppc_boot2dev", "ppc_boot_dev", "ppc_bind_model", "ppc_bind_dev", "ppc_boot2model", "ppc_bind_buffer", "ppc_boot_model", "ppc_boot2buffer", "ppc_boot2device", "ppc_bind_device"], "hd": ["HD", "dr", "ds", "dm", "hid", "ha", "dd", "cd", "rh", "ld", "h", "dl", "dn", "dh", "sd", "hs", "ht", "him", "md", "vd", "kb", "da", "wid", "pd", "ed", "hw", "hp", "hn", "bd"], "MAX_IDE_BUS": ["MAX_IDEOPBUS", "MAX_IDE_BS", "MAX_IDEOPUS", "MAX_IDE2DOS", "MAX_IDE2BS", "MAX_IDE_DOS", "MAX_IDEOPDOS", "MAX_IDE2US", "MAX_ID_BS", "MAX_ID_US", "MAX_ID_BUS", "MAX_ID_DOS", "MAX_IDEOPBS", "MAX_IDE_US", "MAX_IDE2BUS"], "MAX_IDE_DEVS": ["MAX_IDE_DIRV", "MAX_IDE_DVS", "MAX_IDE_DEPS", "MAX_IDE_DIRBS", "MAX_IDE_DPV", "MAX_IDE_DIRVS", "MAX_IDE_DPPS", "MAX_IDE_DBS", "MAX_IDE_DEV", "MAX_IDE_DPVS", "MAX_IDE_DPBS", "MAX_IDE_DPS", "MAX_IDE_DIRPS", "MAX_IDE_DV", "MAX_IDE_DEBS"], "fd": ["df", "fr", "dt", "td", "fi", "ds", "lf", "f", "d", "id", "pipe", "fb", "dd", "dc", "cd", "ff", "fl", "dl", "fc", "sd", "dir", "fat", "wd", "fp", "du", "fs", "pid", "FD", "bd"], "MAX_FD": ["Max_FH", "Max_DIR", "Max_FS", "Max_FD", "MAX_DIR", "MAX_FS", "MAX_FH"]}}
{"project": "FFmpeg", "commit_id": "15ea222778caaec0877b3f9938140b707c931d96", "target": 0, "func": "static void copy_picture_field(InterlaceContext *s,\n\n                               AVFrame *src_frame, AVFrame *dst_frame,\n\n                               AVFilterLink *inlink, enum FieldType field_type,\n\n                               int lowpass)\n\n{\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n\n    int hsub = desc->log2_chroma_w;\n\n    int vsub = desc->log2_chroma_h;\n\n    int plane, j;\n\n\n\n    for (plane = 0; plane < desc->nb_components; plane++) {\n\n        int cols  = (plane == 1 || plane == 2) ? -(-inlink->w) >> hsub : inlink->w;\n\n        int lines = (plane == 1 || plane == 2) ? -(-inlink->h) >> vsub : inlink->h;\n\n        uint8_t *dstp = dst_frame->data[plane];\n\n        const uint8_t *srcp = src_frame->data[plane];\n\n\n\n        av_assert0(cols >= 0 || lines >= 0);\n\n\n\n        lines = (lines + (field_type == FIELD_UPPER)) / 2;\n\n        if (field_type == FIELD_LOWER)\n\n            srcp += src_frame->linesize[plane];\n\n        if (field_type == FIELD_LOWER)\n\n            dstp += dst_frame->linesize[plane];\n\n        if (lowpass) {\n\n            int srcp_linesize = src_frame->linesize[plane] * 2;\n\n            int dstp_linesize = dst_frame->linesize[plane] * 2;\n\n            for (j = lines; j > 0; j--) {\n\n                const uint8_t *srcp_above = srcp - src_frame->linesize[plane];\n\n                const uint8_t *srcp_below = srcp + src_frame->linesize[plane];\n\n                if (j == lines)\n\n                    srcp_above = srcp; // there is no line above\n\n                if (j == 1)\n\n                    srcp_below = srcp; // there is no line below\n\n                s->lowpass_line(dstp, cols, srcp, srcp_above, srcp_below);\n\n                dstp += dstp_linesize;\n\n                srcp += srcp_linesize;\n\n            }\n\n        } else {\n\n            av_image_copy_plane(dstp, dst_frame->linesize[plane] * 2,\n\n                                srcp, src_frame->linesize[plane] * 2,\n\n                                cols, lines);\n\n        }\n\n    }\n\n}\n", "idx": 6622, "substitutes": {"s": ["sc", "t", "os", "p", "S", "ds", "is", "a", "d", "l", "v", "sp", "r", "sl", "w", "ss", "self", "h", "ns", "ssl", "b", "sq", "an", "g", "ses", "sts", "sg", "rs", "gs", "ar", "e", "m", "fs", "cs", "sb", "c", "ls", "n", "sa"], "src_frame": [" src_process", "upload_effect", "usr_Frame", "target_scope", "src_sequence", "upload_frame", "src_window", " src_effect", "srcpoframe", "upload_component", "target_frames", "usr_effect", "srcmmeffect", "uploadpofunction", "srcmlframe", " src_window", "srcpocomponent", "srcpofunction", "src2sequence", "srcptcomponent", "targetipframes", "srcpoeffect", "srcationprocess", "srcptframe", "srcptframes", "srcmleffect", "src2frames", "sr_sequence", "targetipframe", "srcmlwindow", "srcationframe", "targetipscope", "srcipframe", "sr_frame", "src_scope", "srcmmsequence", " src_component", "srcmmframe", "src_process", "srcmmFrame", "usr_sequence", "src_Frame", "src_effect", " src_frames", "src2frame", "upload_function", "uploadpocomponent", "srcmlprocess", "uploadpoeffect", "usr_frame", "targetipFrame", "sr_frames", "target_frame", "srcipframes", "srcipscope", "src_frames", "srcipFrame", "srcationeffect", "src_function", "src_component", "target_Frame", "srcationwindow", "uploadpoframe", "srcptwindow"], "dst_frame": ["dest_frames", "dst_sequence", "dsrc_sequence", "dst_table", "ddest_fram", "dstiptable", "ddest_frame", "dstipframes", "dst_fram", "dsrc_frames", "dst_frames", "dest_table", "dest_frame", "dst_session", "dsrc_frame", "dstipframe", "dstipsession", "dsrc_Frame", "dest_session", "ddest_frames", "dst_Frame"], "inlink": [" inroute", "pinlink", "inlabel", "ninmatch", "cinlist", "inconnection", "rinlabel", "inlinked", "dinlabel", "cinconnection", "fromlink", "rinload", "instream", "Inconnect", "innload", "cinlike", "vinink", "cinctl", "rinlink", "inload", "innink", "inconnect", "pinlinked", "cinLink", "fromctl", "dinlinks", " inlinks", "innroute", "vinlinked", "ninink", "dinctl", "inlist", "dinload", "pinstream", "inink", "vinstream", "Inmatch", " inlinked", "vinlog", "inLink", "innlink", "inmatch", "cinlinks", "cinink", " instream", "Inlinked", "cinmatch", " inLink", "innlabel", "dinlist", "dinlike", "ninconnect", "inctl", "pinroute", "inlinks", "dinroute", "dinconnection", "innlinked", " inlist", "fromlike", "innlog", "vinlink", "dinlink", "Inink", "Inlink", "vinroute", "ninlink", "inlog", "inlike", "Inlog", "cinconnect", "dinLink", "inroute", "fromconnection", "cinlink", "rinroute"], "field_type": ["channel_type", "player_type", " field_name", "playercasehandle", "field_ype", "query64type", "field_id", "field_relation", "channel64operator", "fieldNamehandle", "player_mode", "channel64type", " field_file", "query_Type", "field_name", "field64ype", "channel_relation", "fieldTypename", "query64id", "channel_operator", "fieldcasemode", "fieldtypetype", "fieldtypefile", "field64operator", "fieldcasetype", "field64id", "playercasemode", "query_type", "field64option", "field_class", "player_handle", "query_id", "fieldtypename", "fieldcasehandle", "field64type", "fieldNameclass", "field64Type", "field_mode", "fieldcaseclass", "fieldNametype", "field_operator", "query64ype", "fieldNamemode", "fieldtypeclass", "fieldTypetype", "query_ype", "channel64relation", "playercaseclass", "fieldTypeclass", "field_option", "field_Type", "field_handle", " field_class", "player_class", "channel_option", "field64relation", "field_file", "channel64option", "query64Type", "playercasetype", "fieldTypefile"], "lowpass": ["slowcross", "highpass", "slowpass", "lowPass", "highPass", "highPASS", "LowPASS", " lowPass", " lowcross", "Lowpass", "slowPASS", "highcross", "LowPass", "slowPass", "Lowcross", "lowPASS", "lowcross"], "desc": ["ptr", "sc", "dr", "doc", "dev", "ds", "config", "sec", "esc", "dist", "dim", "ec", "lc", "cont", "cor", " Desc", "dc", "msg", "sub", "txt", "diff", "ext", "ript", "asc", "description", "or", "req", "comm", "fc", "def", "dir", "info", "comment", "cmp", "rec", "tor", "enc", "cam", "det", "ca", "conv", "Desc", "reg", "disc", "meta", "des", "dep", "cmd", "lib"], "plane": ["ane", "stroke", "id", "pei", "connection", "plot", "alias", "unity", "jet", "package", "panel", "lane", "forge", "slave", "atten", "slice", "que", "ine", " planes", "project", "user", "bo", "flake", "way", "planes", "normal", "vert", "scope", "note", "en", "ve", "profile", "buffer", "flow", "ker", "pen", "flag", "straight", "priority", "eline", "mode", "POSE", "place", "pose", "den", " Plane", "limit", "anes", "board", "component", "animate", "ask", "version", "axis", "layout", "depth", "port", "span", "pal", "cone", "clip", "plan", "square", "sequence", "goal", "pe", "plate", "cube", "half", "pipe", "me", "position", "offset", "flat", "gate", "ice", "trace", "sheet", "pin", "line", "zone", "window", "mate", "player", "frame"], "j": ["json", "fr", "dj", "p", "ch", "bj", "d", "l", "jj", "ind", "v", "r", "jl", "it", "q", "jc", "other", "aj", "k", "jo", "port", "h", "o", "jet", "br", "bs", "i", "ji", "js", "jump", "ie", "index", "oj", "g", "ij", "kj", "y", "jp", "uj", "m", "jas", "ja", "job", "jit", "J", "jack", "n", "z"], "dstp": ["dputl", "drestm", "dstl", "drestv", "dndl", "destf", "dputjp", " dstP", "drestp", "dstd", "dctp", "dstv", "dostf", "dstP", "dostm", "copy", "destd", "destl", "dostd", "dndjp", " dstf", " destp", "arc", " dstv", " dstm", "dctm", "dservp", " dstd", "def", "dostfp", "dostp", " dstsm", "dndm", "dctd", "dstfp", " destjp", "dservfp", " dostp", "drestP", " dstsP", "dstm", " dostfp", "destm", " dostf", " dostd", "dstjp", "jpg", "xy", "destjp", "conv", "dstf", " dstsp", "_", "destp", "dstsm", "dservm", " dostm", "img", "dputp", " dstfp", " destl", "dndp", "dstsp", "dservf", "destP", " dstjp", "dstsv", "destv", " dstsv", "dstsP", " destm", "dputm", "destfp", " dstl"], "srcp": ["ourcepb", "srcm", "rcg", "srcl", "rccp", "rcf", "syncp", "srcP", "ourcep", "rcping", "srccp", "sourcep", "srcf", "sourcef", "srcg", "srcpa", " srcf", "securel", "sortg", "srcn", "rcP", "secureping", "sortpa", "procm", " srcl", "sourcel", "securen", " srccp", " srcn", "sortP", "syncpa", "procpid", "srcpid", "srcpb", "rcp", " srcP", " srcm", "ourcem", "rcm", "sourceping", "srcping", "sortcp", "securep", "sortm", "rcn", "rcl", "sourcem", "ourceP", "procp", " srcpid", " srcpb", "syncm", "sourcen", "rcpid", "sourceP", "sortp", "syncg", "rcpb", "rcpa"], "srcp_above": ["srcP_over", "srcp_upper", "srcP_above", "srcp_over", "srcP_upper", "srcP_below", "srcP_area", "srcP_behind", "srcp_area", "srcp_behind", "srcp_within"], "srcp_below": ["srcm_low", "srcm_bottom", "srcm_floor", "srcp_bottom", "srcm_Below", "srcm_allows", "srcp_low", "srcp_floor", "srcp_allows", "srcm_below", "srcm_above", "srcp_Below"]}}
{"project": "qemu", "commit_id": "d96391c1ffeb30a0afa695c86579517c69d9a889", "target": 1, "func": "target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)\n\n{\n\n    check_hwrena(env, 0);\n\n    return env->CP0_EBase & 0x3ff;\n\n}\n", "idx": 6628, "substitutes": {"env": ["entry", "vp", "doc", "conf", "gear", "dev", "environment", "cv", "config", "gov", "esc", "v", "org", "sp", "data", "vs", "ctx", "enter", "msg", "ev", "obj", "w", "vv", "server", "set", "cur", "en", "self", "nv", "h", "st", "ve", "nc", "eng", "next", "mem", "proc", "result", "state", "ten", "ah", "info", "buf", "buffer", "e", "end", "te", "ov", "window", "desc", "ef", "context", "vt", "viron", "event", "uv"]}}
{"project": "qemu", "commit_id": "9cb805fd2674f474d058fee6d7aa9e83fcd3d336", "target": 1, "func": "void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#elif defined(TARGET_S390X)\n\n    CPUState *cs;\n\n    S390CPU *cpu;\n\n\n\n    CPU_FOREACH(cs) {\n\n        cpu = S390_CPU(cs);\n\n        if (cpu->env.cpu_num == monitor_get_cpu_index()) {\n\n            if (s390_cpu_restart(S390_CPU(cs)) == -1) {\n\n                error_set(errp, QERR_UNSUPPORTED);\n\n                return;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n#else\n\n    error_set(errp, QERR_UNSUPPORTED);\n\n#endif\n\n}\n", "idx": 6635, "substitutes": {"errp": ["lrp", "arrsp", "arrP", "lrping", "Erp", "rrp", "nerpb", "ererpt", "Erpp", "Ersp", "errpy", "rrpy", "nerping", "rrpb", "bufpy", "nerpy", "rrpt", "errpp", " errP", "ererpy", "errsp", "arrpp", "bufpre", "errpb", " errpp", "bufp", "bufpt", "errpre", "lrpy", "errping", "nerp", "lrpb", "ererpre", "errpt", " errsp", "rrping", "ErP", "arrp", "errP", "rrpre", "ererp"], "cs": ["tc", "icks", "sc", "rc", "cp", "ces", "ds", "acts", "cus", "css", "ms", "ips", "ras", "ec", "ps", "ix", "vs", "ctx", "pc", "ins", "ics", "eds", "ks", "cc", "irs", "CS", "ys", "gc", "onents", "bs", "ns", "js", "ows", "sts", "rs", "gs", "ts", "cks", "ck", "cf", "checks", "acs", "fs", "its", "ce", "ims", "csv", "ants", "c", "wcs", "ls", "s", "cas", "qs", "ats", "rys", "aps"], "cpu": ["ka", "cu", "cp", "uart", "util", "pkg", "copy", "cv", "percent", "processor", "nn", "cat", "ctx", "thread", "pixel", "pc", "hz", "linux", "prof", "gpu", "ruby", "chip", "uu", "port", "cn", "gc", "none", "anc", "proc", "clock", "currency", "mx", "computer", "socket", "CPU", "net", "console", "bean", "alloc", "process", "cf", "ck", "cam", "vm", "tp", "runner", "pu", "kernel", "core", "hw", "cum", "aux", "c", "pid", "goal", "sky", "nic", "cal", "client", "cas", "cache", "cmd", "docker"]}}
{"project": "qemu", "commit_id": "e175bce587936bf479889881488821ea8d61c89c", "target": 1, "func": "void helper_single_step(CPUX86State *env)\n\n{\n\n#ifndef CONFIG_USER_ONLY\n\n    check_hw_breakpoints(env, 1);\n\n    env->dr[6] |= DR6_BS;\n\n#endif\n\n    raise_exception(env, EXCP01_DB);\n\n}\n", "idx": 6641, "substitutes": {"env": ["sc", "vp", "entry", "rc", "dev", "environment", "cv", "ds", "conn", "gov", "esc", "v", "vs", "ctx", "eg", "scope", "obj", "w", "vv", "cb", "ext", "txt", "ew", "en", "En", "nv", "h", "nc", "ve", "server", "eng", "req", "st", "rb", "def", "ah", "manager", "ten", "buf", "console", "store", "vm", "code", "e", "erd", "end", "cfg", "engine", "sv", "ov", "window", "desc", "sb", "queue", "block", "context", "shell", "er", "ev", "viron", "sw", "uv"]}}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static av_always_inline void rv40_weak_loop_filter(uint8_t *src,\n\n                                                   const int step,\n\n                                                   const int stride,\n\n                                                   const int filter_p1,\n\n                                                   const int filter_q1,\n\n                                                   const int alpha,\n\n                                                   const int beta,\n\n                                                   const int lim_p0q0,\n\n                                                   const int lim_q1,\n\n                                                   const int lim_p1)\n\n{\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n    int i, t, u, diff;\n\n\n\n    for (i = 0; i < 4; i++, src += stride) {\n\n        int diff_p1p0 = src[-2*step] - src[-1*step];\n\n        int diff_q1q0 = src[ 1*step] - src[ 0*step];\n\n        int diff_p1p2 = src[-2*step] - src[-3*step];\n\n        int diff_q1q2 = src[ 1*step] - src[ 2*step];\n\n\n\n        t = src[0*step] - src[-1*step];\n\n        if (!t)\n\n            continue;\n\n\n\n        u = (alpha * FFABS(t)) >> 7;\n\n        if (u > 3 - (filter_p1 && filter_q1))\n\n            continue;\n\n\n\n        t <<= 2;\n\n        if (filter_p1 && filter_q1)\n\n            t += src[-2*step] - src[1*step];\n\n\n\n        diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0);\n\n        src[-1*step] = cm[src[-1*step] + diff];\n\n        src[ 0*step] = cm[src[ 0*step] - diff];\n\n\n\n        if (filter_p1 && FFABS(diff_p1p2) <= beta) {\n\n            t = (diff_p1p0 + diff_p1p2 - diff) >> 1;\n\n            src[-2*step] = cm[src[-2*step] - CLIP_SYMM(t, lim_p1)];\n\n        }\n\n\n\n        if (filter_q1 && FFABS(diff_q1q2) <= beta) {\n\n            t = (diff_q1q0 + diff_q1q2 + diff) >> 1;\n\n            src[ 1*step] = cm[src[ 1*step] - CLIP_SYMM(t, lim_q1)];\n\n        }\n\n    }\n\n}\n", "idx": 6646, "substitutes": {"src": ["tc", "pkg", "sel", "cont", "it", "scan", "sl", "txt", "loc", "str", "cur", "via", "supp", "sr", "sq", "slice", "eff", "seed", "gs", "fp", "iter", "sn", "boot", "its", "c", "hl", "sur", "url", "sort", "ptr", "sc", "screen", "dist", "nn", "r", "ins", "ic", "rl", "obj", "control", "st", "secure", "proc", "irc", "http", "sites", "new", "raw", "stab", "sb", "block", "impl", "sys", "ack", "load", "tn", "ur", "rc", "syn", "bh", "config", "dest", "sec", "ctr", "usc", "func", "bs", "source", "uint", "np", "rx", "rs", "iv", "conv", "aux", "s", "rt", "ser", "inner", "ln", "spec", "sync", "inst", "cc", "req", "ssl", "usr", "result", "nr", "ij", "tp", "cmp", "reverse", "addr", "cache", "rb", "input", "stream", "bc", "sw"], "step": ["ride", "stage", "key", "steps", "save", "stroke", "filter", "path", "pass", "error", "watch", "layer", "scroll", "seed", "row", "height", "iter", "display", "page", "walk", "loop", "hop", "move", "start", "tick", "run", "progress", "dim", "way", "draw", "wait", "check", "stack", "device", "next", "driver", "pointer", "index", "name", "try", "patch", "mode", "push", "block", "touch", "shape", "load", "STEP", "order", "weight", "debug", "track", "change", "version", "delay", "read", "lock", "chain", "space", "group", "stop", "feature", "shift", "lag", "roll", "match", "print", "table", "sequence", "skip", "Step", "dt", "channel", "rate", "drop", "set", "chip", "time", "history", "store", "status", "scale", "test", "window", "trip", "update", "route", "input", "frame", "batch"], "stride": ["strange", "STRIDE", "swategy", "swide", "STRide", "stockIDE", "swride", "STRride", " strategy", "swIDE", "stockride", "STRategy", "stringange", "stockide", "stringride", "strride", "stringategy", "stockategy", "stange", "stringide", "stategy", "stide", " strride", " strange", "strIDE", "strategy"], "filter_p1": ["filter_p0", "filter_h2", "filter_h3", "filter_pt2", "filter_P6", "filter_plet", "filter_spOne", "filter_p6", "filter_tlet", "filter_t2", "filter_h1", "filter_t3", "filter_P2", "filter_cp2", "filter_t1", "filter_POne", "filter_q5", "filter_sp2", "filter_q2", "filter_cp5", "filter_qOne", "filter_sp6", "filter_ptlet", "filter_q6", "filter_h0", "filter_pt1", "filter_q0", "filter_cp0", "filter_pOne", "filter_P0", "filter_p2", "filter_P1", "filter_cp1", "filter_p3", "filter_p5", "filter_P5", "filter_P3", "filter_pt3", "filter_sp1", "filter_q3"], "filter_q1": ["filter_p0", "filter_pp1", "filter_Q4", "filter_dq1", "filter_dq4", "filter_ppw", "filter_Q2", "filter_dq0", "filter_dqx", "filter_px", "filter_pw", "filter_dqw", "filter_qu2", "filter_pp2", "filter_q2", "filter_Q0", "filter_dq2", "filter_qu1", "filter_Q1", "filter_q0", "filter_p2", "filter_qx", "filter_Q3", "filter_p3", "filter_qux", "filter_q4", "filter_pp0", "filter_q3", "filter_dq3", "filter_qu0", "filter_p4", "filter_qw"], "alpha": ["la", "rc", "extra", "igma", "weight", "a", "filter", "mu", "Alpha", "si", "asc", "power", "appa", "fa", "ho", "A", "ma", "da", "height", "area", "ar", "ca", " gamma", "scale", "star", "acl", "mad", "pi", "pha", "ac", "qa", "au", "phi", "ta", "phas", "angle", "lambda"], "beta": ["tc", "extra", "margin", "igma", "Beta", "cv", "prime", "bi", "binary", "v", "fine", "mu", "bil", "norm", "factor", "stable", "Alpha", "cb", "abc", "\u03b2", "mix", "fc", "fa", "nu", "confirmed", "b", "fee", "ba", "buffer", "ma", "late", "eta", "scale", "unit", "bis", "base", "pi", "pha", "ta", "phi", "bf", "lambda", "grad"], "lim_p0q0": ["lim_p0p0", "lim_p1q9", "lim_p0dq8", "lim_p1p0", "lim_p1q0", "lim_p0q9", "lim_p0p8", "lim_p0dq9", "lim_p0dq1", "lim_p0q1", "lim_p0h9", "lim_p1q1", "lim_p1q8", "lim_p0dq2", "lim_p0p9", "lim_p0dq0", "lim_p0h0", "lim_p0Q8", "lim_p1p8", "lim_p0h2", "lim_p0p1", "lim_p1p2", "lim_p0Q2", "lim_p1p1", "lim_p0Q1", "lim_p1p9", "lim_p1q2", "lim_p0Q0", "lim_p0h1", "lim_p0q8", "lim_p0q2", "lim_p0p2"], "lim_q1": ["lim_Q2", "lim_QOne", "lim_quantOne", "lim_quant2", "lim_p0", "lim_quant1", "lim_Q0", "lim_q0", "lim_q2", "lim_Q1", "lim_qOne", "lim_p2", "lim_quant0", "lim_pOne"], "lim_p1": ["lim_m1", "lim_cp1", "lim_cp9", "lim_p0", "lim_t3", "lim_t2", "lim_t1", "lim_q9", "lim_t0", "lim_m3", "lim_m2", "lim_p3", "lim_q0", "lim_q2", "lim_p2", "lim_m0", "lim_t9", "lim_cp2", "lim_cp0", "lim_p9"], "cm": ["tc", "gm", "cp", "co", "conf", "com", "cv", "bm", "ctr", "fm", "ym", "lc", "cont", "fine", "ctx", "mp", "em", "dc", "cl", "cc", "pm", "km", "ry", "module", "cn", "gc", "mom", "cr", "nm", "fc", "sem", "rem", "asm", "mn", "mb", "iam", "CM", "vm", "wm", "um", "ci", "m", "ca", "mm", "rom", "core", "ct", "irm", "ram", "im", "c", "cms", "tk", "cache", "mc"], "i": ["init", "li", "p", "inter", "sim", "bi", "is", "f", "id", "ind", "ii", "v", "ini", "mi", "ix", "me", "it", "ic", "si", "j", "di", "in", "ip", "ex", "index", "at", "ui", "multi", "iu", "xi", "y", "zi", "status", "ci", "ti", "m", "ai", "pi", " j", "ims", "x", "I", "phi", "qi", "c", "cli", "n", "start", "out", " ii", "batch"], "t": ["tc", "p", "total", "dt", "td", "tf", "tt", "temp", "tmp", "a", "f", "d", "l", "v", "to", "it", "tz", "q", "vt", "tar", "txt", "set", "h", "j", "st", "o", "pt", "wt", "time", "xt", "b", "tree", "at", "g", "trace", "type", " T", "tip", "y", "ot", "tp", "ts", "new", "status", "ti", "te", "m", "tg", "tr", "iat", "table", "test", "title", "ent", "ta", "tm", "all", "qt", "c", "rt", "n", "tu", "T", "out"], "u": ["ur", "util", "p", "lu", "upper", "f", "eu", "ou", "v", "ut", "mu", "it", "ul", "q", "ue", "uu", "o", "units", "nu", "fu", "ui", "iu", "uc", "um", "un", "m", "unit", "au", "uf", "uid", "us", "c", "uni", "tu", "U", "uv"], "diff": ["df", "extra", "conf", "dev", "hard", "td", "tf", "tmp", "debug", "d", "dist", "Delta", "Diff", "length", "it", "dust", "fd", "error", "split", "different", "change", "dd", "call", " difference", "offset", "equal", "good", "dirty", "dl", "changes", "mix", "dh", "attr", "fix", "driver", "added", "def", "shift", "comment", "eff", "range", "ref", "new", "cmp", "changed", "cond", "det", "edge", "help", "missing", "test", "part", "distance", "update", "del", "iff", "add", "err"]}}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void con_disconnect(struct XenDevice *xendev)\n\n{\n\n    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);\n\n\n\n    if (con->chr) {\n\n        qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL);\n\n        qemu_chr_fe_release(con->chr);\n\n    }\n\n    xen_be_unbind_evtchn(&con->xendev);\n\n\n\n    if (con->sring) {\n\n        if (!xendev->dev) {\n\n            munmap(con->sring, XC_PAGE_SIZE);\n\n        } else {\n\n            xengnttab_unmap(xendev->gnttabdev, con->sring, 1);\n\n        }\n\n        con->sring = NULL;\n\n    }\n\n}\n", "idx": 6650, "substitutes": {"xendev": ["xsendir", "wendedev", "xtnddev", " xndec", " xndeg", " xnddev", "xendedek", "xendsem", "xendsel", "xtndir", " xendsel", "wxendef", " xendsek", "xentdev", "xsendef", "xendsev", "xendedef", "xindev", "wendedef", " xendel", "xsendoc", "xtendir", "xndir", " xndew", "xndec", "wxendedef", "xendew", "wxendedew", "wendev", "xenterv", "xentew", "xentec", "xendsdev", "xnddev", "xsendev", "xendedel", "xendem", "xendeg", "xentef", "xbeginev", "xendoc", "xndef", "xbeginel", "xndel", "xenddev", "xndeg", "xendedir", "xendederv", "xendef", " xendek", "wendedoc", "wxendedev", "xendseg", " xendeg", " xenddev", " xendsev", "xendel", "xendir", "xsenderv", "xindec", "xsenddev", "wenderv", "xendek", "xndev", "xinddev", "wendoc", "wxendeddev", "xbeginek", "xbeginem", "xtendev", " xendsem", "wxenddev", "xendsek", "xendedev", "xendedeg", " xendem", "xendec", "xenderv", "xndew", "xendedoc", "xtndev", "xentev", "wendederv", " xndel", " xendew", "xentoc", "wendef", "xendedew", "wxendev", "xtenddev", "xendedem", "wxendew", " xendec", "xendeddev", "xindew", " xndev"], "con": ["ain", "canon", "ocon", "tun", "rc", "out", "conf", " cons", "co", "mon", "pan", "cast", "com", "conn", " CON", " uncon", "fac", "cat", "Cons", "col", "cont", "scan", "call", "connection", "lang", "don", "cons", "en", "Conn", "gate", "comm", "cn", "dn", "fc", "dial", "ver", "cone", "connect", "act", "an", "stan", "non", "ctrl", "bean", " co", "Con", " conn", "CON", "un", "can", "conv", "pen", " Con", "ac", "num", " conc", "c", "client", "rain", "cal", "ran", "man", "go", "acon", "cmd"]}}
{"project": "FFmpeg", "commit_id": "8772d2511a4ac45f275eaef2b4b6b1ef132c993b", "target": 1, "func": "static int normalize_bits(int num, int width)\n\n{\n\n    if (!num)\n\n        return 0;\n\n    if (num == -1)\n\n        return width;\n\n    if (num < 0)\n\n        num = ~num;\n\n\n\n    return width - av_log2(num);\n\n}\n", "idx": 6670, "substitutes": {"num": ["t", "NUM", "p", "mon", "max", "th", "multipl", "dim", "sum", "draw", "to", "nom", "tim", "mu", "mult", "msg", "check", "note", "con", "mun", "set", "en", "one", "nam", "valid", "comm", "eng", "none", "nm", "mix", "nu", "mem", "off", "np", "result", "index", "name", "orig", "mn", "Num", "net", "zero", "type", "new", "ord", "cmp", "um", "m", "na", "coord", "conv", "bit", "missing", "im", "snap", "number", "final", "alph", "cal", "block", "n", "pos", "al"]}}
{"project": "qemu", "commit_id": "2e63eb2becc228232f12a1ea30a91b2aa8c5cecd", "target": 1, "func": "static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->realize = xen_pt_realize;\n\n    k->exit = xen_pt_unregister_device;\n\n    k->config_read = xen_pt_pci_read_config;\n\n    k->config_write = xen_pt_pci_write_config;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->desc = \"Assign an host PCI device with Xen\";\n\n    dc->props = xen_pci_passthrough_properties;\n\n};", "idx": 6674, "substitutes": {"klass": ["eklass", "tklor", "ekclass", "kjlass", "iklas", "kjstal", "kicklass", " kls", "tkstal", "tkestro", "kickestro", "kjlor", "kickstal", "klor", "kjestro", "iklass", "tkclass", " kclass", "tklass", "tkls", "ikcl", "kstal", "ikls", " kcl", "kclass", "kestro", " klas", "kls", "ekls", "klas", "kicklor", "ikclass", "tklas", "kcl", "ekcl"], "data": ["json", "key", "d", "r", "mu", " sd", "DATA", " Data", "di", "kind", "module", "Data", "o", "dat", "result", "def", "name", " d", "ata", " DATA", "res", "m", "raw", "bin", "value", "cache"], "dc": ["mc", "df", "tc", "rc", "dr", "doc", "cm", "cp", "cu", "dt", "dm", "ds", "d", "iac", "ec", "lc", "cca", "pc", "dd", "cd", "ga", "cc", " DC", "dk", "di", "adr", "gc", "cr", "fc", "md", "nz", "da", "dp", "db", "ca", "disc", "DC", "ac", "desc", "c", "oc", "nc", "bc"], "k": ["ka", "key", "t", "kh", "ke", "kan", "K", "ki", "sk", "kn", "mk", "kk", "kr", "uk", "it", "ikk", "q", "ks", "wk", "ku", "dk", "kt", "km", "ok", "j", "kind", "kl", "anc", "g", "ijk", "rek", "kj", "ck", "ko", "ik", "ek", "kar", "ak", "c", "tk", "kick", "kit", "kw", "ack", "z"]}}
{"project": "qemu", "commit_id": "fa1298c2d623522eda7b4f1f721fcb935abb7360", "target": 1, "func": "static int ohci_bus_start(OHCIState *ohci)\n\n{\n\n    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                    ohci_frame_boundary,\n\n                    ohci);\n\n\n\n    if (ohci->eof_timer == NULL) {\n\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n\n        ohci_die(ohci);\n\n        return 0;\n\n    }\n\n\n\n    trace_usb_ohci_start(ohci->name);\n\n\n\n    /* Delay the first SOF event by one frame time as\n\n     * linux driver is not ready to receive it and\n\n     * can meet some race conditions\n\n     */\n\n\n\n    ohci_eof_timer(ohci);\n\n\n\n    return 1;\n\n}\n", "idx": 6685, "substitutes": {"ohci": ["ahli", "ihpi", "ohdi", "hhcci", "hli", "orgdi", "orgcu", "orgci", " ehci", "Ohci", "hhci", "ehdi", " ehcu", "orgcci", "ahc", "hrc", "ihli", "Ohdi", "hcci", "ohcu", "ahdi", "hc", "ehci", "ahcu", "hrci", "hhdi", "hrcci", "ohli", "ehcci", "ehli", " ohcci", "ahca", "ohc", "ohca", "hci", " ohcu", "ohcci", " ohdi", "ehpi", "Ohcci", "ihci", "ehca", "ohpi", "Ohcu", " ehcci", " ehca", "hcu", "ahcci", "hdi", "ehcu", "ahpi", "ehc", "hrpi", "ihdi", "hpi", "ahci", "hhcu"]}}
{"project": "qemu", "commit_id": "3ac2f2f765a0bc18dfb18c38a522e6123289ffc1", "target": 1, "func": "void bdrv_image_info_specific_dump(fprintf_function func_fprintf, void *f,\n\n                                   ImageInfoSpecific *info_spec)\n\n{\n\n    QObject *obj, *data;\n\n    Visitor *v = qmp_output_visitor_new(&obj);\n\n\n\n    visit_type_ImageInfoSpecific(v, NULL, &info_spec, &error_abort);\n\n    visit_complete(v, &obj);\n\n    assert(qobject_type(obj) == QTYPE_QDICT);\n\n    data = qdict_get(qobject_to_qdict(obj), \"data\");\n\n    dump_qobject(func_fprintf, f, 1, data);\n\n\n    visit_free(v);\n\n}", "idx": 6699, "substitutes": {"func_fprintf": ["func_dformat", "func_dprintf", "func_fprint", "func__fwp", "func_vprintf", "func_vformat", "func__vprintf", "func_lfwp", "func_fformat", "func_dprint", "func__fprintf", "func_lfprint", "func_mformat", "func__fformat", "func__vformat", "func_fwp", "func_dprintln", "func__vprint", "func_lfformat", "func__vwp", "func_vprint", "func_vprintln", "func_mprintf", "func_mprintln", "func__fprint", "func_fprintln", "func_lfprintf", "func_mprint", "func_vwp", "func_dwp"], "f": ["fr", "t", "p", "fn", "fi", "lf", "full", "d", "l", "fac", "func", "fb", "fd", "file", "w", "fun", "ff", "h", "o", "xf", "fc", "b", "F", "g", "rf", "fp", "cf", "fs", "uf", "c", "bf", "from", "fx"], "info_spec": ["infommmatch", "fo_spec", "info_spe", "fo_spe", "infoptspec", " info_match", "info_data", "infommspe", "info_match", " info_spe", "infommspec", "info2match", "fo_data", "info2spec", "infoptdata", "infoptspe", "info2spe"], "obj": ["bo", "t", "os", "elt", "pkg", "bj", "tmp", "bh", "ind", "org", "att", "nt", "arr", "ctx", "cont", "typ", "cb", "txt", "str", "self", "object", "j", "o", "nm", "attr", "ie", "js", "ex", "ht", "b", "po", "resp", "np", "oj", "info", "orig", "act", "pr", "ref", "opt", "y", "ot", "vo", "obs", "og", "xy", "iv", "res", "opp", "addr", "expr", "ent", "Obj", "hw", "src", "ob", "oid", "tk", "oc", "alt", "pos", "objects", "cmd"], "data": ["json", "rew", "extra", "t", "p", "details", "d", "done", "mu", "list", "error", "DATA", "pretty", " Data", "map", "str", "partial", "di", "valid", "Data", "o", "output", "dat", "ns", "metadata", "group", "bytes", "np", "def", "result", "name", "format", "info", "type", "keys", "da", "ata", "text", "iter", " DATA", "m", "results", "rel", "raw", "content", "ed", "help", "table", "missing", "all", "message", "n", "context", "value", "cache", "batch"], "v": ["view", "vp", "p", "tv", "vi", "cv", "d", "l", "vc", "r", "vs", "it", "q", "vt", "ev", "w", "nv", "j", "h", "ve", "vr", "o", "u", "i", "b", "ver", "g", "y", "vm", "m", "iv", "conv", "sv", "ov", "pi", "x", "lv", "c", "vis", "V", "av", "vy", "uv"]}}
{"project": "FFmpeg", "commit_id": "7b94df232a4b76c44e243e618573f8d331a1eb1c", "target": 0, "func": "static int srt_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *got_sub_ptr, AVPacket *avpkt)\n\n{\n\n    AVSubtitle *sub = data;\n\n    AVBPrint buffer;\n\n    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;\n\n    int size, ret;\n\n    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);\n\n    FFASSDecoderContext *s = avctx->priv_data;\n\n\n\n    if (p && size == 16) {\n\n        x1 = AV_RL32(p     );\n\n        y1 = AV_RL32(p +  4);\n\n        x2 = AV_RL32(p +  8);\n\n        y2 = AV_RL32(p + 12);\n\n    }\n\n\n\n    if (avpkt->size <= 0)\n\n        return avpkt->size;\n\n\n\n    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);\n\n\n\n    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);\n\n    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);\n\n    av_bprint_finalize(&buffer, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    *got_sub_ptr = sub->num_rects > 0;\n\n    return avpkt->size;\n\n}\n", "idx": 6708, "substitutes": {"avctx": [" avcontext", "savcontext", "savtx", "afcontext", "abtc", "afctl", "Avcmp", "afctx", "abctx", "savctx", "afpkg", " avpkg", " avctl", "avcmp", "aftx", "Avctl", " avtx", "aveconn", "avectx", "avctl", "abconn", " avconn", "avconn", "avpkg", "savpkg", "avetc", "avcontext", " avtc", "avtx", "avtc", "Avcontext", "abcontext", "avecontext", "Avctx", " avcmp", "afcmp"], "data": ["rew", "t", "inner", "form", "d", "join", "length", "to", "path", "image", "ad", "DATA", "padding", "obj", "txt", "str", "description", "pad", "Data", "device", "feed", "empty", "dat", "action", "body", "def", "name", "buf", "at", "input", "text", "ata", "da", "area", " DATA", "rel", "raw", "table", "missing", "window", "as", "bin", "video", "message", "block", "next", "value", "stream", "batch"], "got_sub_ptr": ["got_sub2ptr", "got_rel_ptr", "got_sub2tr", "got_sub_rel", "got_rel_pos", "got_sub_tr", "got_subxpos", "got_relxaddr", "got_relxpos", "got_rel_addr", "got_relxtr", "got_desc_ref", "got_sub_ref", "got_desc_addr", "got_sub2pos", "got_relxptr", "got_sub2ref", "got_desc_rel", "got_sub_pos", "got_subxptr", "got_sub2addr", "got_sub2rel", "got_sub_addr", "got_subxtr", "got_rel_tr", "got_desc_ptr", "got_subxaddr"], "avpkt": ["avpwp", "ajpkg", "avPdu", "avdpkt", " avpdu", "avnpacket", "avnpcmd", "avcppt", "avopwk", "avpreacket", "avprekg", "avdpkg", "avpcht", "raftpawk", "raftpakt", "avecpdu", " avpett", "avpcmd", "avpppt", "raftpkt", "avppt", "avPcmd", "raftpacket", "ajprekt", "avprewk", "avcpkg", " avcpwp", "avecppt", "avpacht", "avppdu", "ajpacket", "avppnt", "avnpdu", "avpawk", " avcpacket", "raftpcht", "avpakt", "avcpwp", " avcpcmd", "avpett", "avcpdu", "ajpnt", "avPkt", "avPacket", " avcpdu", "avPnt", "avpdu", "avpkg", " avcpet", "avecpkt", "ajpkt", " avcpett", "avepkt", "aveppt", "avppkt", "avcpacket", "avcpnt", "avprekt", "avPett", "avcpet", "avepdu", " avpet", "avnppt", " avpacket", "avppacket", "avnpett", "avcpcmd", "avepnt", "avopacket", "avnpkt", "avprecht", "avprent", "ajprent", "ajprekg", "avPkg", "avppkg", "avecpnt", "avpacket", "raftpwk", "avopkt", " avpwp", "raftpacht", "avnpnt", "avopcht", " avpcmd", "avPet", "avpaacket", "avpnt", "avdpacket", "ajpreacket", "avnpet", " avpkg", "raftpaacket", "avcpkt", " avcpkt", "avcpett", "avdpwp", "avpwk", " avcpkg", "avppwp", "avpet"], "sub": [" unsub", "sc", "rc", "butt", "sim", "ch", "bi", "sec", "sel", "subject", "sup", "v", "sing", "sum", "con", "Sub", "txt", "sl", "sam", "SU", "set", "ub", "ext", "j", "st", "supp", "buff", " subp", "b", "info", "buf", "pb", "text", "tag", " subt", "um", "un", "tr", "job", "summary", "pl", "desc", "sb", "mod", "aux", "ob", " subs", "tab", "sur", "pre", "ab", "add"], "buffer": ["ptr", "out", "screen", "view", "temp", "f", "binary", "v", "sum", "length", "board", "file", "stack", "bar", "builder", "address", "Buffer", "h", "phrase", "pad", "package", "output", "buff", "mem", "result", "b", "clear", "comment", "buf", "uffer", "pb", "ref", "row", "text", "command", "match", "sound", "document", "iter", "surface", "line", "engine", "table", "base", "stream", "window", " buf", "uf", "reference", "sequence", "queue", "null", "callback", "message", "context", "cache", "writer", " buff", "batch", "template"], "size": ["gz", "id", "l", "sum", "ize", "send", "str", "body", "sid", "height", "area", "sn", "count", "c", "message", "n", "start", "z", "score", "general", "extra", "Size", "no", "dim", "sp", "scope", "h", "power", "empty", "mem", "index", "name", "len", "code", "storage", "shape", "capacity", "small", "loss", "news", "SIZE", "padding", "address", "space", "format", "state", "shift", "fee", "type", "e", "m", "summary", "number", "notice", "t", "max", "speed", "use", "v", "length", "sent", "position", "offset", "set", "style", "g", "store", "status", "scale", "window", "pos", "value", "cache", "sw"], "ret": ["ptr", "t", "reset", "elt", "gt", "tf", "success", "f", "RET", "arg", "nt", "re", "r", "not", "Ret", "ft", "rets", "txt", "ext", "val", "fun", "j", "complete", "rem", "gc", "mem", "mt", "result", "def", "resp", "buf", "nz", "rev", "ref", "len", "repl", "print", "iter", "code", "status", "res", "tr", "ter", "flag", " Ret", "uf", "final", "back", "alt", "rt", "value", "out", "tn"], "p": ["vp", "pp", "t", "cp", "pkg", "lp", "d", "l", "v", "sp", "r", "ps", "pc", "post", "ping", "pg", "q", "padding", "wp", "pa", "j", "power", "pad", "pt", "i", "ip", "ap", "b", "np", "g", "at", "pb", "per", "y", "fp", "tp", "perm", "jp", "op", "dp", "m", "up", "P", "bp", "c", "pe", "pos", "n", "u", "pre"], "s": ["sc", "t", "os", "S", "ds", "is", "sp", "ps", "spec", "ins", "serv", "w", "sam", "set", "ss", "h", "bs", "ns", "js", "b", "sq", "sts", "sg", "rs", "gs", "ts", "fs", "its", "sv", "cs", "sb", "c", "ls", "ats", "n", "sys", "se", "sa"]}}
{"project": "FFmpeg", "commit_id": "221f902f1dc167bdc0bfdff6b6af3214ae3cc1f4", "target": 1, "func": "static int filter_slice(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)\n\n{\n\n    YADIFContext *s = ctx->priv;\n\n    ThreadData *td  = arg;\n\n    int refs = s->cur->linesize[td->plane];\n\n    int df = (s->csp->comp[td->plane].depth_minus1 + 8) / 8;\n\n    int pix_3 = 3 * df;\n\n    int slice_h = td->h / nb_jobs;\n\n    int slice_start = jobnr * slice_h;\n\n    int slice_end   = (jobnr == nb_jobs - 1) ? td->h : (jobnr + 1) * slice_h;\n\n    int y;\n\n\n\n    /* filtering reads 3 pixels to the left/right; to avoid invalid reads,\n\n     * we need to call the c variant which avoids this for border pixels\n\n     */\n\n    for (y = slice_start; y < slice_end; y++) {\n\n        if ((y ^ td->parity) & 1) {\n\n            uint8_t *prev = &s->prev->data[td->plane][y * refs];\n\n            uint8_t *cur  = &s->cur ->data[td->plane][y * refs];\n\n            uint8_t *next = &s->next->data[td->plane][y * refs];\n\n            uint8_t *dst  = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]];\n\n            int     mode  = y == 1 || y + 2 == td->h ? 2 : s->mode;\n\n            s->filter_line(dst + pix_3, prev + pix_3, cur + pix_3,\n\n                           next + pix_3, td->w - 6,\n\n                           y + 1 < td->h ? refs : -refs,\n\n                           y ? -refs : refs,\n\n                           td->parity ^ td->tff, mode);\n\n            s->filter_edges(dst, prev, cur, next, td->w,\n\n                            y + 1 < td->h ? refs : -refs,\n\n                            y ? -refs : refs,\n\n                            td->parity ^ td->tff, mode);\n\n        } else {\n\n            memcpy(&td->frame->data[td->plane][y * td->frame->linesize[td->plane]],\n\n                   &s->cur->data[td->plane][y * refs], td->w * df);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 6727, "substitutes": {"ctx": ["tc", "ia", "sc", "cm", "jac", " cx", "ds", "pkg", "tmp", "conn", "nil", "vc", "pc", "obj", "cc", "kt", "cn", "gc", "fc", "anc", "ns", "bs", "np", "act", "sg", "cmp", "cf", "ck", "xc", "cs", "hw", "ct", "ac", "tx", "bc", "c", "cmd", "kw", "grad", "context", "ctl", "nc", "mc", "tn"], "arg": ["ng", "Arg", "t", "doc", "p", "inter", "ray", "v", "arr", "ang", "argument", "ad", "ark", "call", "ag", "obj", "val", "ax", "gate", "in", "attr", "arp", "ann", "i", "ary", "info", "g", "md", "pb", "at", "ref", "ar", "ay", "args", "param", "cand", "input", "reg", "cmd"], "jobnr": [" jobnumber", "jumpnr", "bugnb", "jobattr", "jobnor", "tasknb", " jobn", "jumpn", "tasknos", "bugnor", "jumpattr", "bugnos", "jobn", "jumpnor", "bugnr", "jobnb", "jumpnum", "taskn", " jobnb", "jobnos", " jobnum", "tasknumber", " jobsn", "bugattr", "tasknum", "tasksn", "tasknr", "jobNR", "Jobnr", "jobnum", " jobgr", "tasknor", "jobsn", "Jobsn", "jumpnos", "Jobnum", " jobNR", "taskNR", "taskgr", "taskattr", "JobNR", "buggr", "jumpnb", "jobnumber", "bugnumber", "jobgr"], "nb_jobs": ["nbTimejobs", "number_results", "numberjframes", "nb___frames", "span_jobs", "spanipobs", "number_jobs", "span_obs", "nbjframes", "nbipjobs", "spanipjobs", "NB_frames", "nb___videos", "nbJobs", "number_frames", "span_groups", "nbipgroups", "NBJframes", "nbofjobs", "NB_videos", "nbJjobs", "nbipobs", "nbofframes", "nbjblocks", "NB_jobs", "numberjblocks", "nbTimeresults", "nbofobs", "nbjresults", "nb___jobs", "NBJjobs", "nbJvideos", "spanipmodels", "NB_obs", "NBJobs", "numberjresults", "nbjjobs", "span_models", "spanipgroups", "nb_videos", "nb_groups", "nb_frames", "nb___obs", "nbTimeframes", "nb_models", "nbJframes", "nbipmodels", "number_blocks", "nbTimeblocks", "nb_obs", "nb_blocks", "numberjjobs", "nbofvideos", "NBJvideos", "nb_results"], "s": ["sc", "states", "t", "os", "S", "p", "ds", "tmp", "is", "a", "sac", "sp", "r", "ps", "ins", "spec", "sm", "sl", "sam", "set", "ss", "h", "st", "ys", "so", "bs", "js", "ns", "hs", "ssl", "b", "sq", "g", "ses", "sts", "sg", "scl", "rs", "gs", "ts", "es", "stat", "stats", "utils", "fs", "sv", "cs", "sb", "c", "as", "src", "ls", "ats", "sys", "sw", "sa"], "td": ["tc", "tif", "hd", "t", "elt", "dev", "gt", "dt", "dm", "tf", "tt", "ty", "od", "TD", "d", "mont", "att", "nt", "pc", "ad", "SD", "fd", "dd", "cd", "bd", "edd", "typ", "tu", "txt", "obj", "ld", "ud", "dl", "pt", "dat", "dn", "sd", "dh", "ht", "tw", "md", "pb", "std", "vd", "tp", "ts", "pd", "ti", "tg", "tic", "det", "tr", "dad", "rd", "disc", " TD", "desc", "ta", "tm", "nd", "rt", "cmd", "tk", "cod", "tab", "cz", "ctl", "managed", "tl", "dem", "tn"], "y": ["py", "key", "yer", "t", "yi", "p", "ch", "hy", "dy", "ley", "ty", "v", "ym", "ies", "yn", "my", "hey", "ady", "w", "icy", "any", "ky", "j", "yo", "yout", "ys", "h", "wy", "ry", "io", "gy", "i", "ye", "ip", "ey", "b", "Y", "ery", "sys", "sy", "axy", "yet", "ny", "ly", "cy", "ay", "xy", "asy", "m", "sym", "try", "ya", "aily", "iy", "oy", "yr", "year", "yt", "yl", "yu", "x", "yd", "sky", "hot", "kit", "n", "z", "go", "yy", "rey", "uy", "vy"], "prev": ["Prev", "ptr", "pend", "dr", "pub", "inter", "cv", "tmp", "neg", "pred", "re", "veh", "vert", "rr", "vious", "inv", "serv", "obj", "via", "ve", "vr", "rem", "before", "cop", "history", "ip", "pres", "par", "current", "orig", "ver", "per", "cap", "rev", "ref", "tip", "new", "cmp", "rec", "iter", "perm", "op", "iv", "rel", "up", "pri", "var", "first", "ren", "sys", "pre"], "cur": ["ph", "ptr", "ur", "rc", "dr", "sc", "cp", "inter", "ch", "ser", "cv", "th", "cer", "ctr", "mk", "cat", "cont", "bur", "cor", "dc", "serv", "con", "cb", "Cur", "ve", "sr", "cr", "fer", "proc", "result", "dir", "current", "orig", "buf", "car", "ver", "rev", "ctrl", "row", "iter", "rec", "now", "cmp", "cul", "keep", " Cur", "der", "tr", "ter", "pri", "deb", "ct", "desc", "src", "c", "gr", "currently", "sur", "pre", "err", "cmd"], "next": ["ptr", "get", "fr", "sec", "v", "nn", "pred", "nt", "data", "path", "obj", "node", "en", "j", "st", "br", "ne", "ve", "sen", "nu", "Next", "np", "gen", "current", "ver", "buf", "nr", "net", "adj", "ner", "new", "target", "now", "nw", "end", "obs", "ter", "pri", "final", "nd", "first", "then", "nl", "n", "start", "z", "out", "last", "be"], "dst": ["rost", " dut", "nest", "sdST", "nbr", "ddest", "dest", "dnd", "dsST", "sddest", "bost", "bsts", " dbr", "dsnd", "nst", " dsts", "sdst", "nsts", "dsst", "sdnd", "rut", "Dst", "dost", "rsts", "Dbr", "rst", "dbr", "dST", "bST", "bst", "bdest", "dut", "Dsts", "but", "bnd", "Dest", "dsdest", " dest", " dost", "dsts"]}}
{"project": "qemu", "commit_id": "d5fee0bbe68d5e61e2d2beb5ff6de0b9c1cfd182", "target": 0, "func": "int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,\n\n                              int mmu_idx)\n\n{\n\n    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */\n\n        /* TODO - Unsupported */\n\n        error_report(\"Guest Radix Support Unimplemented\");\n\n        exit(1);\n\n    } else { /* Guest uses hash */\n\n        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);\n\n    }\n\n}\n", "idx": 6753, "substitutes": {"cpu": ["cu", "cp", "ork", " CPU", "phys", "util", "conn", "pai", "cil", "processor", "nt", "ctx", "pc", "linux", "prof", "gpu", "cc", "chip", "gc", "proc", "clock", "np", "mac", "CPU", "onet", "alloc", "process", "jp", "ck", "boot", "gp", "pu", "aq", "kernel", "core", "hw", "cum", "pid", "c", "nic", "sys"], "eaddr": ["oadr", "eadd", "adrs", " elddr", " eldd", "eddrs", "eddd", "eadr", "eddr", "adr", " eldder", "oadder", " eldrs", "adder", "addr", "edddr", "eddder", "eadrs", "eadder", "oaddr", "add"], "rwx": ["rwv", "RWc", "rhx", "wxy", "wxx", "RWv", "wxc", "rbx", "ourw", "ourx", "ourxs", "rhy", "rwc", "randxx", "rhc", "randx", "rwxx", "rwy", "rbxs", "ourxx", "randxs", "wxv", "rww", "RWx", "rwxs", "RWy", "rbxx", "rhv", "rbw", "randw"], "mmu_idx": ["mmu_basedz", "mmu_basedu", "mmu_fdx", "mmu_idsv", "mmu_idu", "mmu_Idv", "mmu_fdv", "mmu_idm", "mmu_basedv", "mmu_Idx", "mmu_fdz", "mmu_fdm", "mmu_idv", "mmu_idz", "mmu_Idm", "mmu_idsz", "mmu_Idz", "mmu_basedx", "mmu_idsx", "mmu_idsu"]}}
{"project": "FFmpeg", "commit_id": "1f361124d97cf8b8ce6d3aacb10cdc53706470de", "target": 1, "func": "int ff_img_read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n    VideoDemuxData *s = s1->priv_data;\n\n    char filename_bytes[1024];\n\n    char *filename = filename_bytes;\n\n    int i;\n\n    int size[3]           = { 0 }, ret[3] = { 0 };\n\n    AVIOContext *f[3]     = { NULL };\n\n    AVCodecContext *codec = s1->streams[0]->codec;\n\n\n\n    if (!s->is_pipe) {\n\n        /* loop over input */\n\n        if (s->loop && s->img_number > s->img_last) {\n\n            s->img_number = s->img_first;\n\n        }\n\n        if (s->img_number > s->img_last)\n\n            return AVERROR_EOF;\n\n        if (s->use_glob) {\n\n#if HAVE_GLOB\n\n            filename = s->globstate.gl_pathv[s->img_number];\n\n#endif\n\n        } else {\n\n        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),\n\n                                  s->path,\n\n                                  s->img_number) < 0 && s->img_number > 1)\n\n            return AVERROR(EIO);\n\n        }\n\n        for (i = 0; i < 3; i++) {\n\n            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,\n\n                           &s1->interrupt_callback, NULL) < 0) {\n\n                if (i >= 1)\n\n                    break;\n\n                av_log(s1, AV_LOG_ERROR, \"Could not open file : %s\\n\",\n\n                       filename);\n\n                return AVERROR(EIO);\n\n            }\n\n            size[i] = avio_size(f[i]);\n\n\n\n            if (!s->split_planes)\n\n                break;\n\n            filename[strlen(filename) - 1] = 'U' + i;\n\n        }\n\n\n\n        if (codec->codec_id == AV_CODEC_ID_NONE) {\n\n            AVProbeData pd;\n\n            AVInputFormat *ifmt;\n\n            uint8_t header[PROBE_BUF_MIN + AVPROBE_PADDING_SIZE];\n\n            int ret;\n\n            int score = 0;\n\n\n\n            ret = avio_read(f[0], header, PROBE_BUF_MIN);\n\n            if (ret < 0)\n\n                return ret;\n\n\n            avio_skip(f[0], -ret);\n\n            pd.buf = header;\n\n            pd.buf_size = ret;\n\n            pd.filename = filename;\n\n\n\n            ifmt = av_probe_input_format3(&pd, 1, &score);\n\n            if (ifmt && ifmt->read_packet == ff_img_read_packet && ifmt->raw_codec_id)\n\n                codec->codec_id = ifmt->raw_codec_id;\n\n        }\n\n\n\n        if (codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)\n\n            infer_size(&codec->width, &codec->height, size[0]);\n\n    } else {\n\n        f[0] = s1->pb;\n\n        if (url_feof(f[0]))\n\n            return AVERROR(EIO);\n\n        if (s->frame_size > 0) {\n\n            size[0] = s->frame_size;\n\n        } else {\n\n            size[0] = 4096;\n\n        }\n\n    }\n\n\n\n    if (av_new_packet(pkt, size[0] + size[1] + size[2]) < 0)\n\n        return AVERROR(ENOMEM);\n\n    pkt->stream_index = 0;\n\n    pkt->flags       |= AV_PKT_FLAG_KEY;\n\n    if (s->ts_from_file) {\n\n        struct stat img_stat;\n\n        if (stat(filename, &img_stat))\n\n            return AVERROR(EIO);\n\n        pkt->pts = (int64_t)img_stat.st_mtime;\n\n        av_add_index_entry(s1->streams[0], s->img_number, pkt->pts, 0, 0, AVINDEX_KEYFRAME);\n\n    } else if (!s->is_pipe) {\n\n        pkt->pts      = s->pts;\n\n    }\n\n\n\n    pkt->size = 0;\n\n    for (i = 0; i < 3; i++) {\n\n        if (f[i]) {\n\n            ret[i] = avio_read(f[i], pkt->data + pkt->size, size[i]);\n\n            if (!s->is_pipe)\n\n                avio_close(f[i]);\n\n            if (ret[i] > 0)\n\n                pkt->size += ret[i];\n\n        }\n\n    }\n\n\n\n    if (ret[0] <= 0 || ret[1] < 0 || ret[2] < 0) {\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO); /* signal EOF */\n\n    } else {\n\n        s->img_count++;\n\n        s->img_number++;\n\n        s->pts++;\n\n        return 0;\n\n    }\n\n}", "idx": 6763, "substitutes": {"s1": ["js1", "js9", "js3", "ds3", "ds0", "s2", "s6", "S9", "s9", "S1", " s2", "js2", " s9", " s3", "S0", " s6", "s0", "S6", "S2", "S3", "ds1", "s3", " s0", "js6", "ds2"], "pkt": ["pet", "ppct", " pet", "Pkt", " pct", "ppet", "Packet", "pct", "Pct", "Pet", "ppacket", " packet", "packet", "ppkt"], "s": ["p", "save", "conf", "https", "times", "l", "sl", "ns", "sq", "ses", "gs", "stats", "comments", "its", "ims", "c", "n", "qs", "search", "sc", "S", "a", "sp", "ps", "vs", "ins", "w", "less", "ss", "h", "j", "st", "changes", "sd", "js", "b", "sts", "ts", "ops", "has", "fs", "session", "sb", "series", "ats", "sys", "sa", "sports", "details", "is", "sam", "aws", "space", "source", "styles", "state", "rs", "m", "conv", "cs", "as", "ls", "local", "os", "ess", "sim", "ds", "south", "ms", "v", "spec", "sync", "set", "single", "comm", "ssl", "g", "status", "es", "sv", "se", "sw"], "filename_bytes": ["username_seconds", "filename_seconds", "username_bytes", "username_Bytes", "filename2Bytes", " filename_tes", "username_keys", "filename_lines", "filename_Bytes", "filename_keys", "filename2byte", "username_lines", "path_tes", "filename_byte", "path_bytes", " filename_Bytes", " filename_byte", "filename_uses", "filename_tes", "filename2bytes", "path_uses", "filename2tes"], "filename": ["fil", "json", "mpeg", "kan", "unc", "fn", "fi", "tmp", "ame", "family", "nil", "binary", "l", "v", "subject", "far", "sbm", "length", "FN", "url", "path", "image", "file", "fle", "position", "prefix", "files", "sorry", "upload", "txt", "username", "river", "folder", "png", "via", "description", "FIL", "output", "nm", "ames", "source", "location", "metadata", "result", "name", "buf", "buffer", "jpg", "fp", "status", "kj", "ename", "fs", "title", "names", "AME", "final", "src", "original", "ren", "video", "n", "til", "nl", "Filename", "directory", "NAME"], "i": ["p", "id", "l", "ii", "ini", "tim", "it", "q", "k", "di", "gi", "iq", "y", "ci", "qi", "c", "cli", "n", "z", " ii", "ei", "ix", "ic", "si", "oi", "j", "h", "ji", "index", "zi", "pi", "x", "ia", "d", "ind", "mi", "port", "io", "ri", "ip", "ex", "point", "multi", "cgi", "e", "ti", "m", "ai", "im", "I", "go", "u", "out", "init", "t", "li", "sim", "ki", "bi", "v", "to", "me", "\u0438", "uri", "o", "in", "g", "ui", "iu", "ij", "xi", "status", "um", "batch"], "size": ["order", "small", "share", "max", "Size", "form", "use", "v", "dim", "sp", "data", "length", "SIZE", "ize", "error", "send", "offset", "equal", "set", "style", "en", "grade", "needed", "export", "fit", "source", "format", "name", "g", "fee", "type", "buffer", "status", "len", "sn", "scale", "count", "message", "start", "z", "shape", "cache", "score"], "ret": ["get", "rc", "dr", "reset", "elt", "gt", "dt", "pert", "RET", "v", "arr", "r", "re", "nt", "Ret", "it", "rr", "ft", "rets", "true", "txt", "offset", "val", "fun", "set", "en", "j", "valid", "ry", "read", "rem", "mem", "ary", "result", "def", "err", "usr", "jump", "buf", "nz", "net", "rev", "ref", "buffer", "tail", "ner", "len", "status", "ber", "iter", "code", "res", "after", "utils", "tr", "ter", "flag", "try", "test", " Ret", "uf", "back", "alt", "rt", "er", "next", "value", "out", "cmd", "score"], "f": ["fr", "t", "p", "fn", "fi", "a", "d", "l", "v", "fac", "r", "it", "fb", "fd", "file", "q", "fw", "w", "ff", "sf", "h", "j", "o", "fl", "xf", "fc", "b", "of", "F", "g", "rf", "buffer", "y", "fp", "fe", "iter", "e", "m", "fs", "window", "uf", "c", "bf", "n", "u"], "codec": ["chec", " codEC", "Codenc", "coddec", "compoc", "cedoc", " coddec", "predric", "codep", "comprc", "cdenc", "Codoc", "CodEC", "codric", "chdec", "cedric", "codoc", "compec", "codEC", "Codec", " codep", "codenc", "predec", "cdrc", "cedec", " codric", " codoc", "Codrc", "codrc", "predic", "codic", "chep", " codic", "cdec", "cedic", "Coddec", "compenc", "chEC", "predoc", "cdoc", "Codep"], "pd": [" prod", " program", " ed", " pdf", " bo", " prog", " sd", " ep", " proto", "PD", " proc", " dd", " pars", " dw", " cd", " df", " prof", " pc", " cond", " td", " ad", " pro", " pe", " pooled", " prot", " prov", " din", " dh", " buff"], "ifmt": ["IFlt", " ifformat", "IFMT", "flt", "fformat", "ifformat", " iflt", "IFmt", "ifMT", "fMT", " ifMT", "IFformat", "fmt", "iflt"], "header": ["dr", "extra", "t", "border", "heading", "filter", "length", "list", "file", "padding", "address", "tar", " HDR", "offset", "version", "h", "metadata", "format", "layer", "index", "name", "info", "type", "buffer", "tag", "command", "status", "iter", "code", "holder", "HEAD", "head", "table", "flag", "headers", "var", "Header", "writer", "block", "er"], "img_number": ["img7no", "img_type", "orig_number", "img_id", "image_position", "orig_num", "orig_id", "img_no", "img7number", "imgugnum", "img__num", "img__name", "imgugnumber", "img_last", "img___no", "image_no", "img_name", "img7id", "image_name", "img_nr", "img_first", "image_type", "image_first", "image_last", "img__nb", "img_note", "image_nb", "img__number", "image_number", "imguglast", "img_position", "img_num", "img___number", "img___position", "orig_no", "image_nr", "image_num", "imgugtype", "img7num", "img_nb", "image_note", "img___note"]}}
{"project": "qemu", "commit_id": "40c4ed3f95f0b2ffa0848df0fc311556bb7472a1", "target": 1, "func": "void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    IDEBus *bus = opaque;\n\n    IDEState *s = idebus_active_if(bus);\n\n    uint8_t *p;\n\n\n\n    /* PIO data access allowed only when DRQ bit is set */\n\n    if (!(s->status & DRQ_STAT))\n\n        return;\n\n\n\n    p = s->data_ptr;\n\n    *(uint16_t *)p = le16_to_cpu(val);\n\n    p += 2;\n\n    s->data_ptr = p;\n\n    if (p >= s->data_end)\n\n        s->end_transfer_func(s);\n\n}\n", "idx": 6775, "substitutes": {"opaque": ["patile", "boos", "opoid", "oux", "paque", "oaque", "oppaque", "ooid", "oppux", "oppoid", "boque", "hopque", "pux", "opque", "opatile", "poid", "oatile", " opque", "hopos", "opux", "oppatile", " opos", "hopaque", "opos", "boaque"], "addr": ["ptr", "rc", "host", "eth", "id", "v", "arr", "data", "ix", "ad", " ptr", "address", "loc", "attr", "mem", " address", "ref", "wid", "cmp", "db", "rol", "rel", "res", "tx", "src", "hl", "pos", "cmd"], "val": ["key", "VAL", "eval", "sel", " eval", "v", "data", " data", "serv", "txt", "valid", "ret", "mem", " aval", "state", "slot", "resp", " vel", " value", "buf", " v", "pol", "ref", " seq", "cmp", "rol", "res", " arg", "vals", "test", "Value", "var", "x", "seq", "tx", " ty", "vol", "alt", "pos", "vt", "value", "reg", "Val", "uv"], "bus": ["os", "phys", "dev", "aque", "l", " device", "bur", "board", "ctx", "bolt", "Bus", "mount", " busy", "handle", "port", "h", "gate", "device", "lock", "bs", "chain", "driver", "b", "proxy", " mailbox", "onet", "usb", "store", "stick", "boot", "ase", "home", "bridge", "loop", "base", "us", "c", "pod", " unused", "back", "box", "sys", "BUS"], "s": ["t", "os", "S", "sports", "ds", "is", "a", "f", "ms", "l", "v", "sp", "ps", "vs", "spec", "sm", "z", "sl", "less", "ss", "self", "h", "j", "comm", "so", "bs", "sd", "ns", "js", "hs", "space", "state", "b", "sq", "g", "ses", "sts", "socket", "rs", "store", "gs", "y", "status", "ts", "es", "e", "stats", "m", "fs", "sis", "sv", "cs", "sb", "als", "c", "us", "ls", "qs", "sys", "sol", "se", "sa"], "p": ["ptr", "vp", "pp", "t", "cp", "pkg", "lp", "f", "d", "l", "v", "sp", "ps", "pc", "mp", "ping", "post", "q", "wp", "pa", "pro", "j", "pad", "php", "pt", "i", "ap", "ip", "np", "b", "point", "g", "pb", "pr", "pers", "fp", "tp", "perm", "jp", "op", "dp", "m", "P", "pu", "bp", "pi", "parse", "pl", "x", "c", "pe", "n", "pre"]}}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *s,\n\n                                                     PutBitContext *pb, const float *in, float *out,\n\n                                                     const float *scaled, int size, int scale_idx,\n\n                                                     int cb, const float lambda, const float uplim,\n\n                                                     int *bits, const float ROUNDING)\n\n{\n\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    int i;\n\n    int qc1, qc2, qc3, qc4;\n\n\n\n    uint8_t  *p_bits  = (uint8_t  *)ff_aac_spectral_bits[cb-1];\n\n    uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[cb-1];\n\n    float    *p_vec   = (float    *)ff_aac_codebook_vectors[cb-1];\n\n\n\n    abs_pow34_v(s->scoefs, in, size);\n\n    scaled = s->scoefs;\n\n    for (i = 0; i < size; i += 4) {\n\n        int curidx, curidx2;\n\n        int *in_int = (int *)&in[i];\n\n        uint8_t v_bits;\n\n        unsigned int v_codes;\n\n        int t0, t1, t2, t3, t4, t5, t6, t7;\n\n        const float *vec1, *vec2;\n\n\n\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n\n\n\n        __asm__ volatile (\n\n            \".set push                      \\n\\t\"\n\n            \".set noreorder                 \\n\\t\"\n\n\n\n            \"ori    %[t4],  $zero,  4       \\n\\t\"\n\n            \"slt    %[t0],  %[t4],  %[qc1]  \\n\\t\"\n\n            \"slt    %[t1],  %[t4],  %[qc2]  \\n\\t\"\n\n            \"slt    %[t2],  %[t4],  %[qc3]  \\n\\t\"\n\n            \"slt    %[t3],  %[t4],  %[qc4]  \\n\\t\"\n\n            \"movn   %[qc1], %[t4],  %[t0]   \\n\\t\"\n\n            \"movn   %[qc2], %[t4],  %[t1]   \\n\\t\"\n\n            \"movn   %[qc3], %[t4],  %[t2]   \\n\\t\"\n\n            \"movn   %[qc4], %[t4],  %[t3]   \\n\\t\"\n\n            \"lw     %[t0],  0(%[in_int])    \\n\\t\"\n\n            \"lw     %[t1],  4(%[in_int])    \\n\\t\"\n\n            \"lw     %[t2],  8(%[in_int])    \\n\\t\"\n\n            \"lw     %[t3],  12(%[in_int])   \\n\\t\"\n\n            \"srl    %[t0],  %[t0],  31      \\n\\t\"\n\n            \"srl    %[t1],  %[t1],  31      \\n\\t\"\n\n            \"srl    %[t2],  %[t2],  31      \\n\\t\"\n\n            \"srl    %[t3],  %[t3],  31      \\n\\t\"\n\n            \"subu   %[t4],  $zero,  %[qc1]  \\n\\t\"\n\n            \"subu   %[t5],  $zero,  %[qc2]  \\n\\t\"\n\n            \"subu   %[t6],  $zero,  %[qc3]  \\n\\t\"\n\n            \"subu   %[t7],  $zero,  %[qc4]  \\n\\t\"\n\n            \"movn   %[qc1], %[t4],  %[t0]   \\n\\t\"\n\n            \"movn   %[qc2], %[t5],  %[t1]   \\n\\t\"\n\n            \"movn   %[qc3], %[t6],  %[t2]   \\n\\t\"\n\n            \"movn   %[qc4], %[t7],  %[t3]   \\n\\t\"\n\n\n\n            \".set pop                       \\n\\t\"\n\n\n\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n\n              [t4]\"=&r\"(t4), [t5]\"=&r\"(t5), [t6]\"=&r\"(t6), [t7]\"=&r\"(t7)\n\n            : [in_int]\"r\"(in_int)\n\n            : \"memory\"\n\n        );\n\n\n\n        curidx = 9 * qc1;\n\n        curidx += qc2 + 40;\n\n\n\n        curidx2 = 9 * qc3;\n\n        curidx2 += qc4 + 40;\n\n\n\n        v_codes = (p_codes[curidx] << p_bits[curidx2]) | (p_codes[curidx2]);\n\n        v_bits  = p_bits[curidx] + p_bits[curidx2];\n\n        put_bits(pb, v_bits, v_codes);\n\n\n\n        if (out) {\n\n           vec1 = &p_vec[curidx*2 ];\n\n           vec2 = &p_vec[curidx2*2];\n\n           out[i+0] = vec1[0] * IQ;\n\n           out[i+1] = vec1[1] * IQ;\n\n           out[i+2] = vec2[0] * IQ;\n\n           out[i+3] = vec2[1] * IQ;\n\n        }\n\n    }\n\n}\n", "idx": 6778, "substitutes": {"s": ["sc", "init", "S", "p", "ds", "f", "a", "v", "sp", "ps", "spec", "ins", "ss", "self", "sf", "h", "aws", "bs", "ns", "js", "hs", "source", "state", "sq", "sts", "sg", "rs", "gs", "es", "ts", "e", "stats", "fs", "its", "sv", "cs", "sb", "c", "src", "as", "ls", "qs", "ats", "sys", "sa"], "pb": ["tc", "vp", "pp", "cp", "lb", "bps", "cv", " cp", "bh", "lp", "bm", "ctx", "kB", "pc", "BP", "wp", "pm", "pa", "np", "xb", "fp", "tp", "bp", "pl", "uf", "sb", "bf", "tk", "nb"], "in": ["din", "init", "doc", "t", "p", "nin", "IN", "inner", "f", "vin", "ind", "l", "sum", "data", "ins", "it", "scan", "inn", "ex", "isin", "inc", "new", "m", "pin", "local", "raw", "up", "rin", "c", "bin", "min", "gin", "inf", "input", "In"], "out": ["t", "os", "p", "gt", "tmp", "OUT", "v", "data", "to", "w", "flat", "set", "outs", "o", "output", "result", "b", "buf", "net", "new", "ot", "res", "conv", "final", "Out", "n", "sys"], "scaled": ["rculed", "pscalled", "Scaling", "Scatted", "SCaled", " unscaled", "sculed", "expaling", "configale", "staled", "Scalled", "escaled", "desculed", "configaled", " unsculed", "shaling", "rcaled", " unscale", "shale", "expalled", " unscaling", "expatted", "configaling", "scalled", "esculed", "scatted", "Scaled", "descale", "stalled", "shaped", "stale", "SCalled", "configaped", "Scale", "pscatted", "escaling", "scale", " unscalled", "rcaling", "staling", "rcale", "SCale", "SCaling", "escalled", "scaling", "descalled", "escale", "pscaled", "escaped", "shaled", "expaled", "pscaling", "scaped", "descaled"], "size": ["sc", "capacity", "small", "cm", "max", "Size", "no", "south", "l", "dim", "see", "sum", "length", "SIZE", "ctx", "ize", "send", "loc", "offset", "set", "si", " Size", " sizes", "empty", "shift", "slice", "g", "fee", "type", "range", "len", "area", "sn", "ci", "scale", "win", "zone", "number", "count", "c", "z", "shape", "score"], "scale_idx": ["scale_idice", "scale_edt", "scaleableidt", "scale_iterX", "scale_idt", "scale_iterx", "scale_indxs", "scaleableidxt", "scale_didt", "scale_indxc", "scale_Idxc", "scale_indx", "scale_identice", "scale_idxs", "scale_idX", "scale_edxt", "scale_idxes", "scale_Idx", "scale_Idy", "scale_identt", "scale_idex", "scale_identxt", "scale_didxt", "scaleableidx", "scale_indX", "scale_idexes", "scale_idxt", "scale_ideX", "scale_identx", "scaleableedx", "scale_idz", "scaleableidice", "scale_didx", "scale_Idxs", "scale_edice", "scaleableedice", "scale_iterxes", "scale_idez", "scaleableedt", "scale_idy", "scale_didice", "scaleableedxt", "scale_indz", "scale_iterz", "scale_indy", "scale_indxes", "scale_edx", "scale_idxc"], "cb": ["tc", "sc", "cu", "cp", "conf", "lb", "bound", "dt", "cv", "nb", "gov", "ctr", "CU", "usc", "CB", "lc", "ctx", "cor", "dc", "bar", "cd", "loc", "cc", "cale", "cn", "gc", "cr", "fc", "cell", "bb", "fee", "gb", "ctrl", "cf", "ck", "db", "cfg", "coord", "conv", "bp", "eb", "sb", "cli", "ob", "bf", "callback", "rb", "ctl", "nc", "bc", "wb"], "lambda": ["lu", "igma", "alpha", "lam", "ima", "Delta", "elta", "mega", "lr", "lc", "mu", "density", "Alpha", "dB", "hi", "LU", "appa", "nu", "beta", "da", "LA", " gamma", "LG", "pha", "Mu", "phi", "aug", "Lu"], "uplim": ["uppIM", "uippIM", "umlength", "uippims", "uplims", "uplength", "uppim", "uppength", "umlims", "umlIM", "uppims", "uiplim", "umlim", "uippength", "uiplength", "uippim", "uplIM", "uiplims", "uiplIM"], "bits": ["flags", "items", "bps", "bi", "codes", "ms", "planes", "pins", "outs", "units", "bs", "ints", "bytes", "heads", "limits", "gs", "xs", "bit", "its", "vals", "bis", "cs", "bf", "ls", "qs", "weights"], "ROUNDING": [" ROUND1", "RoundingING", "ROUNDing", " ROUNDED", "Roundinging", "RINDing", "Rround1", "RroundED", "RIND1", " RoundingED", " RoundingING", "RINDING", " ROUNDing", "ROUNDED", "Rounding1", "Rrounding", "ROUND1", " Rounding1", "RoundingED", "RroundING", " Roundinging", "RINDED"], "i": ["ia", "init", " I", "ei", "li", "ski", "t", "key", "sim", "ki", "bi", "is", "id", "ind", "ii", "ini", "mi", "ix", " bi", "me", "it", "ic", "gu", "hi", "uri", "si", "oi", "j", "di", "gi", "o", "ri", "ji", "ip", "index", "info", "slice", "g", "ui", "multi", "iu", "ij", "y", "xi", "zi", "iter", "status", " ti", "ti", "ci", "m", "this", "ai", "pi", " j", "im", "ims", "x", "I", "cli", "n", "err", " ii", "batch"], "qc1": [" qr1", "qfc2", "qdc2", "qrc4", "qpc2", "qfc1", " qr4", "qdc4", " qr6", " qrc2", "qc0", "qdc1", "qr2", " qrc4", "qrc6", "qr4", " qc0", "qc6", "qrc2", "qrc0", "qdc0", " qrc1", " qc6", "qpc4", "qpc0", "qr6", "qrc1", "qpc1", "qfc6", "qr1", " qr2", "qfc4", " qrc0"], "qc2": ["qt3", "qt5", "qrc4", "qrc102", " qec3", "quc7", "qrc5", " qc7", "qlc4", "qlc5", " qlc5", "qcc4", "qlc2", "qcc2", " qlc2", "qc102", "qec5", " qc5", " qec7", "quc3", "qrc2", "quc2", " qec5", " qec2", " qc102", "qec2", "qcc5", "qt2", "qlc102", "qec7", "qt7", " qlc4", "qcc102", "qec3", "qc7", "qc5", "quc5", " qlc102"], "qc3": ["qpc3", "questc2", "qup3", "quc23", "questcthree", "qac3", "qpc2", "quc7", "qn3", "qup23", "questpcthree", "qup11", "qcthree", "qpcthree", "qup7", "qp7", "qn11", "qc23", "quc3", "qp3", "qpcThree", "quc11", "questc3", "qunc3", "qct2", "questpc3", "qacthree", "qp23", "qn23", "qunc11", "qctthree", "qunc23", "questpc2", "questpcThree", "qct3", "qacThree", "qunc7", "qctThree", "qac2", "qc7", "qc11", "qp11", "qn7", "qcThree", "questcThree"], "qc4": ["qt4", "qt3", " qdc8", "ql5", "qc04", "qt6", "qrc4", " qc04", "qdc4", "qm12", "qdc3", " qdc6", "qm5", " ql04", "qrc6", "qc12", "qarc4", " qdc4", "qarc12", " qc12", "qc8", "qrc8", " qc5", "qc6", "qrc3", " ql12", "qt8", "qm04", " ql5", "ql12", " ql4", " qc6", " qdc3", "ql4", "qdc6", "qarc04", "qm4", "ql04", "qarc5", "qc5", " qc8", "qdc8"], "p_bits": ["p___maps", "c___codes", "c_bits", "p_bs", "c_codes", "p___bs", "p___codes", "c_bs", "p___bits", "c___bs", "c___bits", "p_maps", "c_maps", "c___maps"], "p_codes": ["pmlterms", "P_terms", "P_codes", "pmlouts", "P_bits", "pmlbits", "P_outs", "p_terms", "p_outs", "pmlcodes"], "p_vec": ["p2vals", "P_buf", "p2vec", "P_vec", "P_vals", "P_ver", "p_vals", "p2ver", "p2buf", "p_buf", "p_ver"], "curidx": [" curidz", "curidc", " curIdx", "curidz", " curIdz", " curidy", "curridx", "curdx", " curIdy", " curIdc", "curridy", "curdz", "curridc", "curridz", "curdc", "curIdc", "curIdx", "curdy", "curIdy", "curidy", "curIdz", " curidc"], "curidx2": ["curIdex0", "curidix0", "curIdex2", "curidy2", "curIdex1", "curIdx0", "curidix1", "curidy1", "curidex2", "curidex0", "curidex1", "curidy0", "curidx0", "curIdx1", "curidix2", "curIdx2", "curidx1"], "in_int": [" in_str", "in_uint", " in2uint", " in2int", "in2uint", " in_uint", "in_str", "in2ind", "in_ind", "in2str", "in2int", " in2str", " in_ind", " in2ind"], "v_bits": ["v_flags", "v_fields", "p_fields", "p_flags", "v2bits", "v2flags", "v2fields", "v2codes"], "v_codes": ["v_code", "v__bits", "v__code", "v_values", "v__codes", "v__values", " v_values", " v_code"], "t0": ["v7", "v2", "v1", "T7", "T1", "T2", "v0", "T0"], "t1": ["tt1", "T001", "tt01", "t8", " t8", "T1", "t001", "T8", "t01", "tt8", " t001", "tt001", " t01", "T01"], "t2": [" tb", "tt256", "T256", " t02", "Tb", "tt2", "T02", "tt02", "T2", "tb", "t256", "t02", "ttb", " t256"], "t3": [" t03", "v7", "v4", "T03", "t03", "v03", "T4", "T7", "v3", "T3"], "t4": ["tsN", "t413", "tuN", "tt413", "ts4", "ts413", "ttN", "tu4", "tN", "tt4", "tu413"], "t5": ["tt5", "te6", "et50", "t005", "te005", "et5", "te50", "te5", "et005", "tt50", "t50", "et6", "tt005", "tt6"], "t6": ["t8", "dt6", "t06", "t26", "T06", "dt26", "T6", "T8", "T26", "tt8", "tt26", "dt8", "dt06", "tt06", "tt6"], "t7": ["tc11", "tc13", "t11", "tc4", "tt13", "t13", "tt7", " t11", "tt4", "tc7", "tt11", " t13"], "vec1": ["vector5", "buf3", "v1", "vector3", "vec0", "v3", "buf0", "buf1", "vec5", "v5", "v0", "vector1", "vec3", "buf5", "vector0"], "vec2": [" vec4", "val1", "val4", "cv1", "val5", " vec5", "vec5", "cv2", "cv5", "cv4", "val2", "vec4"]}}
{"project": "FFmpeg", "commit_id": "eef9f06508354d1c7d5624c1c18997e7974288f1", "target": 0, "func": "static int stream_component_open(PlayerState *is, int stream_index)\n\n{\n\n    AVFormatContext *ic = is->ic;\n\n    AVCodecContext *avctx;\n\n    AVCodec *codec;\n\n    SDL_AudioSpec wanted_spec, spec;\n\n    AVDictionary *opts;\n\n    AVDictionaryEntry *t = NULL;\n\n    int ret = 0;\n\n\n\n    if (stream_index < 0 || stream_index >= ic->nb_streams)\n\n        return -1;\n\n    avctx = ic->streams[stream_index]->codec;\n\n\n\n    opts = filter_codec_opts(codec_opts, avctx->codec_id, ic, ic->streams[stream_index], NULL);\n\n\n\n    codec = avcodec_find_decoder(avctx->codec_id);\n\n    avctx->workaround_bugs   = workaround_bugs;\n\n    avctx->idct_algo         = idct;\n\n    avctx->skip_frame        = skip_frame;\n\n    avctx->skip_idct         = skip_idct;\n\n    avctx->skip_loop_filter  = skip_loop_filter;\n\n    avctx->error_concealment = error_concealment;\n\n\n\n    if (fast)\n\n        avctx->flags2 |= AV_CODEC_FLAG2_FAST;\n\n\n\n    if (!av_dict_get(opts, \"threads\", NULL, 0))\n\n        av_dict_set(&opts, \"threads\", \"auto\", 0);\n\n    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO)\n\n        av_dict_set(&opts, \"refcounted_frames\", \"1\", 0);\n\n    if (!codec ||\n\n        (ret = avcodec_open2(avctx, codec, &opts)) < 0) {\n\n        goto fail;\n\n    }\n\n    if ((t = av_dict_get(opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Option %s not found.\\n\", t->key);\n\n        ret =  AVERROR_OPTION_NOT_FOUND;\n\n        goto fail;\n\n    }\n\n\n\n    /* prepare audio output */\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        is->sdl_sample_rate = avctx->sample_rate;\n\n\n\n        if (!avctx->channel_layout)\n\n            avctx->channel_layout = av_get_default_channel_layout(avctx->channels);\n\n        if (!avctx->channel_layout) {\n\n            fprintf(stderr, \"unable to guess channel layout\\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n        if (avctx->channels == 1)\n\n            is->sdl_channel_layout = AV_CH_LAYOUT_MONO;\n\n        else\n\n            is->sdl_channel_layout = AV_CH_LAYOUT_STEREO;\n\n        is->sdl_channels = av_get_channel_layout_nb_channels(is->sdl_channel_layout);\n\n\n\n        wanted_spec.format = AUDIO_S16SYS;\n\n        wanted_spec.freq = is->sdl_sample_rate;\n\n        wanted_spec.channels = is->sdl_channels;\n\n        wanted_spec.silence = 0;\n\n        wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;\n\n        wanted_spec.callback = sdl_audio_callback;\n\n        wanted_spec.userdata = is;\n\n        if (SDL_OpenAudio(&wanted_spec, &spec) < 0) {\n\n            fprintf(stderr, \"SDL_OpenAudio: %s\\n\", SDL_GetError());\n\n            ret = AVERROR_UNKNOWN;\n\n            goto fail;\n\n        }\n\n        is->audio_hw_buf_size = spec.size;\n\n        is->sdl_sample_fmt          = AV_SAMPLE_FMT_S16;\n\n        is->resample_sample_fmt     = is->sdl_sample_fmt;\n\n        is->resample_channel_layout = avctx->channel_layout;\n\n        is->resample_sample_rate    = avctx->sample_rate;\n\n    }\n\n\n\n    ic->streams[stream_index]->discard = AVDISCARD_DEFAULT;\n\n    switch (avctx->codec_type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        is->audio_stream = stream_index;\n\n        is->audio_st = ic->streams[stream_index];\n\n        is->audio_buf_size  = 0;\n\n        is->audio_buf_index = 0;\n\n\n\n        /* init averaging filter */\n\n        is->audio_diff_avg_coef  = exp(log(0.01) / AUDIO_DIFF_AVG_NB);\n\n        is->audio_diff_avg_count = 0;\n\n        /* since we do not have a precise anough audio fifo fullness,\n\n           we correct audio sync only if larger than this threshold */\n\n        is->audio_diff_threshold = 2.0 * SDL_AUDIO_BUFFER_SIZE / avctx->sample_rate;\n\n\n\n        memset(&is->audio_pkt, 0, sizeof(is->audio_pkt));\n\n        packet_queue_init(&is->audioq);\n\n        SDL_PauseAudio(0);\n\n        break;\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        is->video_stream = stream_index;\n\n        is->video_st = ic->streams[stream_index];\n\n\n\n        packet_queue_init(&is->videoq);\n\n        is->video_tid = SDL_CreateThread(video_thread, is);\n\n        break;\n\n    case AVMEDIA_TYPE_SUBTITLE:\n\n        is->subtitle_stream = stream_index;\n\n        is->subtitle_st = ic->streams[stream_index];\n\n        packet_queue_init(&is->subtitleq);\n\n\n\n        is->subtitle_tid = SDL_CreateThread(subtitle_thread, is);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\nfail:\n\n    av_dict_free(&opts);\n\n\n\n    return ret;\n\n}\n", "idx": 6801, "substitutes": {"is": ["isc", "os", "ms", "ps", "isf", "ics", "ism", "tis", "ish", "iss", "ist", "isi", "ris", "i", "ip", "iris", "isu", "isin", "are", "rs", "ib", "ir", "plays", "ar", "has", "IS", "its", "ik", "bis", "sis", "isp", "cs", "ais", "ims", "was", "as", "us", "isl", "lis", "s", "ls", "isa", "IC", "Is"], "stream_index": ["stream_max", "path_inc", "streamingpos", "streamnpoint", "path_index", "channel_ind", "streamNameind", "stream2number", " stream2index", "stream_point", "streamndirectory", "stream_inc", "record_status", "srcingpoint", " stream2ind", "src_directory", "channel_index", "stream_long", "streamingdirectory", "src_index", "channel_max", "stream2Index", "src_pos", "record_point", " stream_number", " stream_Index", "streamingpoint", "record_index", " stream2number", "stream_ind", "srcingindex", "stream_pos", "streamNamelong", "srcingdirectory", "stream_number", "src_point", "srcingpos", "streamNameinc", "stream_directory", "stream2index", "stream2ind", " stream2Index", "stream_Index", "path_ind", "streamingindex", "stream_condition", " stream_ind", "path_long", "record_condition", "stream_status", "streamNameindex", "streamnindex", "streamnpos"], "ic": ["tc", "mc", "ia", "icer", "isc", "util", "ici", "pic", "vc", " nic", "iac", "ec", "lc", "ctx", "eric", "wic", "pc", "ix", "it", "onic", "icing", "ics", "ICS", "aci", "aic", "cc", "ica", "icc", "ican", "sic", "fc", "i", "ip", "irc", "ick", "iu", "icon", "ci", "ric", "iat", "ik", "ct", "ac", "lic", "nic", "oc", "IC", "bc", "mic", "ico"], "avctx": [" avcontext", "wavctx", "avefunc", "averconn", "vrtx", "abctx", "avecrit", "avcmd", "ajkw", " avcmd", "ravctx", "avcpu", "avectx", "wavtx", "avercrit", "avetry", "avtry", "averloc", "abloc", "avectl", "avetc", " avtc", "avertmp", "ajtry", "wavcb", "aveloc", "abcontext", " avcmp", "afkw", "avcf", "vrctx", " avtxt", "vertx", "avecb", " avobj", "afctx", "abtx", "avetx", " avjac", "ravfunc", "avecmp", " avtx", "avercmp", "avcrit", "ajconn", "avctl", " avkw", "afloc", "averjac", "vrctl", "avcp", "wavcmp", "ajloc", "avpkg", "avercontext", "avcontext", "ajobj", "ajtx", "avtc", "averctx", "avtmp", "averobj", "aftc", "ajjac", "avertxt", "ajctx", "avercmd", "avloc", "averkj", "avtxt", "vrcmp", "vrcb", "vrcontext", "averpkg", "avjac", "avecp", "verloc", " avconn", "ajcmp", "avkj", " avkj", "ravtry", "avconn", "avobj", "ajcontext", "avcb", "avecontext", "wavtmp", "ajkj", " avcp", "afconn", "avepkg", "afcmp", "avertx", "avkw", "avfunc", "afcontext", " avtmp", "ajcpu", "avecf", "wavctl", "ajcrit", "afpkg", " avpkg", "avcmp", " avcpu", "aftx", "aveconn", "avercp", "ravloc", "avecmd", "avercf", "ajcf", "avtx", "verctx", "aveobj", "avetxt", "ajfunc", "vercmd", "avecpu"], "codec": ["odec", "crypteca", "codeca", "cpec", "cryptdec", "coreca", "codet", "odac", "Coderer", "oderer", "choect", "corec", "codect", " codect", "cmpec", "cpect", "odpeg", "coddec", "codpeg", "coderer", "oddec", "cmpac", " codet", " coddec", "codeoc", " codeca", "cdeca", "codeac", "opeca", "coret", "cmpoc", "codeec", "codoc", "codecc", "cppeg", "Codec", "cdect", "chodec", "cddec", "chopeg", "cdrc", "odrc", "Codrc", "codcc", "codrc", "cdet", "odect", "cryptec", "opect", "corect", "opdec", "cryptect", "cdec", "odcc", "Coddec", "choec", "odoc", "codac", "cpdec", "cderer", "opec", "cmpcc"], "wanted_spec": ["wanted2spe", "wanted9spe", "wanted9spec", "want_spec", "want_format", "wanted_spe", "wanted9format", "wanted2spec", "want_spe", "wanted2format", "wanted_format"], "spec": [" specification", "form", "config", "sk", "id", "pc", "xml", "SPEC", "rule", "ra", "params", "spe", "pec", "format", "ident", " specs", "comp", "comment", "Spec", "tag", "status", "cmp", "match", "instance", "cs", "meta", "pos", "stream"], "opts": ["optters", "okt", "optcs", "OPpt", "okcs", "operters", "iopcs", "oppTS", "ropps", " optps", "iopps", "roppt", "OPTS", "okTS", "optts", " optpt", " opters", "options", "operTS", "optTS", "ropcs", "ioptions", "opptions", "OPs", "copcs", "operets", "optt", "opert", "oppt", "okins", "opets", " optts", "OPcs", "opttions", "opcs", " opt", " opets", "opercs", "opins", "OPps", "OPts", "opt", "OPins", "oppts", " optcs", "ops", "opTS", "iopts", "optins", "oppps", "optps", "ropts", "opters", "operts", "iopTS", "OPt", "okps", "optets", "opps", "copts", "cops", "copt", "opertions", "okts"], "t": ["tc", "et", "p", "dt", "td", "tmp", "tt", "temp", "f", "a", "d", "l", "v", "nt", "r", "to", "token", "not", "it", "tap", "tu", "txt", "w", "kt", "j", "o", "pt", "i", "lt", "tree", "at", " T", "tip", "opt", "ot", "ts", "e", "te", "m", "tr", "ct", "ent", "ta", "tm", "c", "n", "rt", "T"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void keyword_literal(void)\n\n{\n\n    QObject *obj;\n\n    QBool *qbool;\n\n    QObject *null;\n\n    QString *str;\n\n\n\n    obj = qobject_from_json(\"true\", NULL);\n\n    qbool = qobject_to_qbool(obj);\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == true);\n\n\n\n    str = qobject_to_json(obj);\n\n    g_assert(strcmp(qstring_get_str(str), \"true\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_json(\"false\", NULL);\n\n    qbool = qobject_to_qbool(obj);\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == false);\n\n\n\n    str = qobject_to_json(obj);\n\n    g_assert(strcmp(qstring_get_str(str), \"false\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    qbool = qobject_to_qbool(qobject_from_jsonf(\"%i\", false));\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == false);\n\n    QDECREF(qbool);\n\n\n\n    /* Test that non-zero values other than 1 get collapsed to true */\n\n    qbool = qobject_to_qbool(qobject_from_jsonf(\"%i\", 2));\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == true);\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_json(\"null\", NULL);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QNULL);\n\n\n\n    null = qnull();\n\n    g_assert(null == obj);\n\n\n\n    qobject_decref(obj);\n\n    qobject_decref(null);\n\n}\n", "idx": 6816, "substitutes": {"obj": ["py", "et", "co", "pkg", "arr", "nt", "cont", "it", "msg", "txt", "cur", "ist", "self", "wo", "vr", "pt", "none", "ie", "adj", "net", "opt", "y", "og", "unknown", "pl", "cmd", "bo", "json", "no", "bj", "el", "sp", "ctx", "con", "j", "st", "buff", "js", "ht", "po", "def", "ref", "utt", "ck", "ent", "src", "obo", "vol", "sys", "ind", "org", "br", "so", "off", "np", "oj", "onet", "xy", "iv", "rel", "Obj", "ob", "alt", "rt", "out", "init", "os", "oss", "elt", "inner", "tmp", "inst", "object", "o", "attr", "imp", "resp", "act", "buf", "pr", "ot", "cmp", "obs", "rect", "res", "addr", "expr", "pos", "err"], "qbool": ["qqolean", "qualbo", "query88", "qqbits", "quflag", "qualstrong", "qlib", "requbool", "queryuint", "queryolean", "equint", "qu88", "gbo", "sqdebug", "querjl", "iqlock", "qqcond", " qflag", "ckbool", "querool", "questool", "qqbool", "quolean", "qubis", "qqool", " qbit", "qualbyte", "questlib", "querybis", "requfol", "requbo", "qbol", "qbits", "querbo", "questlock", "eqbo", "eqool", "quint", "questfol", "querbool", "qqbo", "qqbol", "qualbil", "qulock", "dqbyte", "qresult", "qujl", "questlocked", "eqflag", "ck88", "requlocked", "qolean", "qstrong", "eqdebug", "dqbool", " qlock", "iqool", "querlock", "eqbol", "dqool", "questuint", "qualool", " qool", "gbol", "querybool", "querydebug", "qufol", " qbr", "dqlib", "qualuint", "eqcond", "ckbits", "eqfl", "quarr", "qubil", " qarr", "ckbo", "dqstrong", "dqbo", "qdebug", " qbol", "dqbis", " qolean", "qulocked", "gbool", "eqlock", "sqbis", "qflag", "sqbo", "iqflag", "qqresult", "qcond", "eqbis", "q88", "qbyte", "qqbil", "qubit", " qbil", "qool", "qubo", "queststrong", "eqolean", "queryresult", "qjl", "questjl", "sqflag", "querbit", "sqbil", "qlock", "qarr", "eqbool", "qualbool", "querycond", " qlib", "golean", "querarr", "qubol", "qbo", " qfl", "iqbol", "quool", "qbit", "dquint", "querybo", "querybol", "ckbol", "qlocked", "qbis", "questbyte", "questbo", "eqresult", "questdebug", "qfol", "qufl", " qbo", "sqool", "qbil", "qudebug", "qbr", "questfl", "iqbil", "queryfl", "qfl", "questbr", "questbool", "sqbool", "qubits", "ckolean", "qubool", "qquint", "iqbool", "dqbr"], "null": ["ull", "json", "t", "util", "qual", "temp", "nil", "full", "id", "v", "nt", "ctx", "not", "it", "list", "parent", "q", "native", "unt", "node", "object", "port", "valid", "gc", "empty", "none", "buff", "available", "nan", "result", "root", "il", "comment", "g", "sys", "pr", "ref", "new", "target", "this", "un", "rect", "rel", "Null", "ail", "ill", "all", "test", "c", " Null", "ob", "alt", "n", "local", "load"], "str": ["dr", "fr", "t", "doc", "p", "Str", "art", "form", "temp", "inner", "arr", "r", "sp", "spec", "nt", "ps", "list", "prefix", "ml", "msg", "coll", "txt", "sl", "ext", "st", "j", "br", "pt", "dat", "ns", "mt", "def", "usr", "sys", "buf", "comp", "pr", "ref", "buffer", "text", "enc", "ts", "print", "rec", "db", "rel", "res", "raw", "tr", "wr", "its", "cs", "STR", "gr", "vol", "s", "url", "pre", "out"]}}
{"project": "qemu", "commit_id": "093209cd681fe9fb65bd8a1c2ff711b8168bbfcd", "target": 0, "func": "static void ppc_core99_init (ram_addr_t ram_size,\n\n                             const char *boot_device,\n\n                             const char *kernel_filename,\n\n                             const char *kernel_cmdline,\n\n                             const char *initrd_filename,\n\n                             const char *cpu_model)\n\n{\n\n    CPUState *env = NULL, *envs[MAX_CPUS];\n\n    char *filename;\n\n    qemu_irq *pic, **openpic_irqs;\n\n    int unin_memory;\n\n    int linux_boot, i;\n\n    ram_addr_t ram_offset, bios_offset, vga_bios_offset;\n\n    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;\n\n    PCIBus *pci_bus;\n\n    MacIONVRAMState *nvr;\n\n    int nvram_mem_index;\n\n    int vga_bios_size, bios_size;\n\n    int pic_mem_index, dbdma_mem_index, cuda_mem_index, escc_mem_index;\n\n    int ide_mem_index[3];\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    void *fw_cfg;\n\n    void *dbdma;\n\n    uint8_t *vga_bios_ptr;\n\n    int machine_arch;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n#ifdef TARGET_PPC64\n\n        cpu_model = \"970fx\";\n\n#else\n\n        cpu_model = \"G4\";\n\n#endif\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        /* Set time-base frequency to 100 Mhz */\n\n        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n#if 0\n\n        env->osi_call = vga_osi_call;\n\n#endif\n\n        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);\n\n        envs[i] = env;\n\n    }\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(NULL, \"ppc_core99.ram\", ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = qemu_ram_alloc(NULL, \"ppc_core99.bios\", BIOS_SIZE);\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    cpu_register_physical_memory(PROM_ADDR, BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n\n\n    /* Load OpenBIOS (ELF) */\n\n    if (filename) {\n\n        bios_size = load_elf(filename, NULL, NULL, NULL,\n\n                             NULL, NULL, 1, ELF_MACHINE, 0);\n\n\n\n        qemu_free(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PowerPC bios '%s'\\n\", bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    /* allocate and load VGA BIOS */\n\n    vga_bios_offset = qemu_ram_alloc(NULL, \"ppc_core99.vbios\", VGA_BIOS_SIZE);\n\n    vga_bios_ptr = qemu_get_ram_ptr(vga_bios_offset);\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME);\n\n    if (filename) {\n\n        vga_bios_size = load_image(filename, vga_bios_ptr + 8);\n\n        qemu_free(filename);\n\n    } else {\n\n        vga_bios_size = -1;\n\n    }\n\n    if (vga_bios_size < 0) {\n\n        /* if no bios is present, we can still work */\n\n        fprintf(stderr, \"qemu: warning: could not load VGA bios '%s'\\n\",\n\n                VGABIOS_FILENAME);\n\n        vga_bios_size = 0;\n\n    } else {\n\n        /* set a specific header (XXX: find real Apple format for NDRV\n\n           drivers) */\n\n        vga_bios_ptr[0] = 'N';\n\n        vga_bios_ptr[1] = 'D';\n\n        vga_bios_ptr[2] = 'R';\n\n        vga_bios_ptr[3] = 'V';\n\n        cpu_to_be32w((uint32_t *)(vga_bios_ptr + 4), vga_bios_size);\n\n        vga_bios_size += 8;\n\n\n\n        /* Round to page boundary */\n\n        vga_bios_size = (vga_bios_size + TARGET_PAGE_SIZE - 1) &\n\n            TARGET_PAGE_MASK;\n\n    }\n\n\n\n    if (linux_boot) {\n\n        uint64_t lowaddr = 0;\n\n        int bswap_needed;\n\n\n\n#ifdef BSWAP_NEEDED\n\n        bswap_needed = 1;\n\n#else\n\n        bswap_needed = 0;\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, kernel_base,\n\n                                    ram_size - kernel_base, bswap_needed,\n\n                                    TARGET_PAGE_SIZE);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              kernel_base,\n\n                                              ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                         initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        /* We consider that NewWorld PowerMac never have any floppy drive\n\n         * For now, OHW cannot boot from the network.\n\n         */\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'c' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    isa_mem_base = 0x80000000;\n\n\n\n    /* Register 8 MB of ISA IO space */\n\n    isa_mmio_init(0xf2000000, 0x00800000, 1);\n\n\n\n    /* UniN init */\n\n    unin_memory = cpu_register_io_memory(unin_read, unin_write, NULL);\n\n    cpu_register_physical_memory(0xf8000000, 0x00001000, unin_memory);\n\n\n\n    openpic_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *));\n\n    openpic_irqs[0] =\n\n        qemu_mallocz(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        /* Mac99 IRQ connection between OpenPIC outputs pins\n\n         * and PowerPC input pins\n\n         */\n\n        switch (PPC_INPUT(env)) {\n\n        case PPC_FLAGS_INPUT_6xx:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];\n\n            /* Not connected ? */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            /* Check this */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];\n\n            break;\n\n#if defined(TARGET_PPC64)\n\n        case PPC_FLAGS_INPUT_970:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];\n\n            /* Not connected ? */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            /* Check this */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];\n\n            break;\n\n#endif /* defined(TARGET_PPC64) */\n\n        default:\n\n            hw_error(\"Bus model not supported on mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n    pic = openpic_init(NULL, &pic_mem_index, smp_cpus, openpic_irqs, NULL);\n\n    if (PPC_INPUT(env) == PPC_FLAGS_INPUT_970) {\n\n        /* 970 gets a U3 bus */\n\n        pci_bus = pci_pmac_u3_init(pic);\n\n        machine_arch = ARCH_MAC99_U3;\n\n    } else {\n\n        pci_bus = pci_pmac_init(pic);\n\n        machine_arch = ARCH_MAC99;\n\n    }\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus, vga_bios_offset, vga_bios_size);\n\n\n\n    escc_mem_index = escc_init(0x80013000, pic[0x25], pic[0x24],\n\n                               serial_hds[0], serial_hds[1], ESCC_CLOCK, 4);\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init_nofail(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n    dbdma = DBDMA_init(&dbdma_mem_index);\n\n\n\n    /* We only emulate 2 out of 3 IDE controllers for now */\n\n    ide_mem_index[0] = -1;\n\n    hd[0] = drive_get(IF_IDE, 0, 0);\n\n    hd[1] = drive_get(IF_IDE, 0, 1);\n\n    ide_mem_index[1] = pmac_ide_init(hd, pic[0x0d], dbdma, 0x16, pic[0x02]);\n\n    hd[0] = drive_get(IF_IDE, 1, 0);\n\n    hd[1] = drive_get(IF_IDE, 1, 1);\n\n    ide_mem_index[2] = pmac_ide_init(hd, pic[0x0e], dbdma, 0x1a, pic[0x02]);\n\n\n\n    /* cuda also initialize ADB */\n\n    if (machine_arch == ARCH_MAC99_U3) {\n\n        usb_enabled = 1;\n\n    }\n\n    cuda_init(&cuda_mem_index, pic[0x19]);\n\n\n\n    adb_kbd_init(&adb_bus);\n\n    adb_mouse_init(&adb_bus);\n\n\n\n    macio_init(pci_bus, PCI_DEVICE_ID_APPLE_UNI_N_KEYL, 0, pic_mem_index,\n\n               dbdma_mem_index, cuda_mem_index, NULL, 3, ide_mem_index,\n\n               escc_mem_index);\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    /* U3 needs to use USB for input because Linux doesn't support via-cuda\n\n       on PPC64 */\n\n    if (machine_arch == ARCH_MAC99_U3) {\n\n        usbdevice_create(\"keyboard\");\n\n        usbdevice_create(\"mouse\");\n\n    }\n\n\n\n    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)\n\n        graphic_depth = 15;\n\n\n\n    /* The NewWorld NVRAM is not located in the MacIO device */\n\n    nvr = macio_nvram_init(&nvram_mem_index, 0x2000, 1);\n\n    pmac_format_nvram_partition(nvr, 0x2000);\n\n    macio_nvram_map(nvr, 0xFFF04000);\n\n    /* No PCI init: the BIOS will do it */\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, machine_arch);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(\"cmdline\", CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());\n\n    if (kvm_enabled()) {\n\n#ifdef CONFIG_KVM\n\n        uint8_t *hypercall;\n\n\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, kvmppc_get_tbfreq());\n\n        hypercall = qemu_malloc(16);\n\n        kvmppc_get_hypercall(env, hypercall, 16);\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());\n\n#endif\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, get_ticks_per_sec());\n\n    }\n\n\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 6829, "substitutes": {"ram_size": ["RAM_size", "RAM_scale", "ram0device", "ram_area", "ram_length", "ramaxysize", "RAM_offset", "ramaxyoffset", "ram_scale", "ram_dim", "rom_offset", " ram_dim", "ram0size", "ramaxydevice", "ram0offset", "rom_device", "RAM_area", "ram0number", " ram_length", "rom_number", "rom_size", "ram_device", "ram_number", "ramaxynumber"], "boot_device": ["boot_address", "start_drive", "boot_drive", "start_device", "start_address", "start_dev", "bootingdev", "bootingdrive", "bootingdevice", "boot_dev", "bootingaddress"], "kernel_filename": ["disk_file", "disk_target", "cpu_filename", "kernel_fn", "disk_filename", "disk_location", "kernelpyfilename", "cpu_file", "kernel_file", "kernelpyfile", "cpu_uri", "cpu_fn", "kernelpytarget", "kernel_uri", "kernel_location", "kernel_target", "kernelpylocation"], "kernel_cmdline": ["kernel_initbase", "kernel_hostbase", "kernel_hostname", "kernel_initname", "kernel_cmdname", "kernel_commandline", "kernel_commandbase", "kernel_commandname", "kernel_cmdbase", "kernel_hostline", "kernel_initline"], "initrd_filename": ["initrd_Filename", "initrb_filename", "initrd_file", "initrb_fn", "initrd_fn", "initrb_Filename", "initrb_file"], "cpu_model": ["core_version", "CPU_domain", " cpu_mod", "cpuetyModel", "CPU_models", "cpuetymodel", "core_Model", "cpu_rule", "cpuistModel", "cpu_mod", "cpuetymodels", "cpuThemode", "core_mode", "cpuTheversion", "cpu_mode", "cpu_domain", "cpuetyinterface", "cpuThemodel", "CPU_mode", "cpu_interface", "cpuistlink", "cpu_link", "cpu_Model", "core_model", "cpuistmod", "crypt_function", "CPU_interface", "CPU_model", " cpu_link", "cpu_models", "crypt_rule", "cpu_function", "crypt_model", " cpu_Model", "cpuistmodel", "CPU_Model", "cpu_version", "cpuTheModel"], "env": ["stage", "et", "conn", "ea", "txt", "ah", "vm", "db", "esp", "er", "viron", "event", "uv", "eas", "ptr", "ei", "gear", "dev", "door", "environment", "handler", "vs", "ctx", "worker", "Ev", "eg", "obj", "ew", "en", "iev", "h", "ve", "eng", "mem", "proc", "def", "pres", "po", "buffer", "enc", "code", "ent", "context", "shell", "entry", "eu", "ped", "esc", "policy", "cb", "nv", "era", "manager", "eni", "e", "end", "te", "engine", "var", "qt", "ef", "eh", "vt", "ev", "init", "vp", "t", "ds", "fi", "v", "ec", "spec", "bar", "vv", "server", "ee", "buf", "erd", "sv", "window", "err"], "envs": ["revs", "EnVs", "enports", " enports", "Enports", "Enps", "ENvs", "Env", " enps", "reVs", "Envs", " enVs", "enps", "rev", "ENv", "enVs", "reports", "ENps", "ENVs"], "MAX_CPUS": ["MAX_CPus", "MAX_CPUUS", "MAX_CAPUs", "MAX_CAPUS", "MAX_CPUINS", "MAX_CPUus", "MAX_CPINS", "MAX_CAPus", "MAX_CAPINS", "MAX_CPUUs", "MAX_CPUs"], "filename": ["tty", "fil", "fn", "disk", "fi", "family", "processor", "file", "files", "txt", "username", "uri", "river", "rir", "location", "driver", "metadata", "fp", "framework", "bite", "fs", "lua", "src", "settings", "directory", "til", "Filename"], "pic": ["p", "ig", "fi", "sp", "ps", "eric", "pipe", "pc", "mp", "ic", "ics", "pa", "pins", "ican", "fc", "proc", "pol", "jp", "cam", "pin", "pen", "peg", "pi", "ac", "nic", "pac", "picture", "mc", "mic"], "openpic_irqs": ["openpic__irqs", "openpic_iques", "openpic_prques", "openpic_iq", "openpic_rcs", "openpic_prcs", "openpic_iqs", "openpic_rq", "openpic_rqs", "openpic__iqs", "openpic__irq", "openpic_irques", "openpic__iques", "openpic__ircs", "openpic_prq", "openpic__irques", "openpic_prqs", "openpic_irq", "openpic_rques", "openpic_ics", "openpic_ircs", "openpic__ics", "openpic__iq"], "unin_memory": ["current67mem", "cpu_memory", "current_mem", "current_capacity", "current_memory", "current_size", "cpu_size", "cpu67size", "current67size", "cpu67memory", "current67memory", "cpu67capacity", "cpu_mem", "cpu67mem", "current67capacity", "cpu_capacity"], "linux_boot": ["linux_start", "cpu_bit", "cpu_start", "linux_offset", "linux_bit", "linux2offset", "cpu_offset", "linux2base", "cpu_base", "linux_loop", "cpu_Boot", "cpu_boot", "linux_Boot", "linux_base", "linux2boot", "cpu_loop", "linux2bit"], "i": ["t", "li", "ei", "p", "sim", "bi", "f", "a", "id", "l", "v", "ii", "ini", "ind", "mi", "ix", "tim", "me", "it", "gu", "hi", "si", "k", "j", "di", "gi", "in", "ip", "b", "index", "g", "ui", "multi", "iu", "xi", "y", "ij", "zi", "e", "ci", "ti", "m", "ami", "ai", "pi", "im", "ims", "x", "I", "phi", "qi", "c", "s", "n", "z", "batch"], "ram_offset": ["mem_offset", "ram_position", "ram2start", "gram_location", "mem_off", "mem_base", "ram2location", "ram_loc", "ro_seek", "ram_start", "ram67seek", "gram_offset", "ram2offset", "ram_off", "ram67size", "ram_base", "ram_location", "ram67loc", "mem_pos", "ram2pos", "ro_loc", "ramistloc", "ram_seek", "ram2off", "ramistseek", "ramistoffset", "gram_position", "ram2base", "ram2position", "ram67offset", "ramistsize", "ro_offset", "gram_start", "ro_size", "ram_pos"], "bios_offset": ["bios_slot", "bio_block", "bios__address", "bios_base", "bio_slot", "bios___slot", "bios_address", "bios2offset", "bios2base", "bios2slot", "bios___block", "bios___base", "bios___offset", "bios_block", "bio_offset", "bios__offset", "bio_address", "bios2address", "bio_base", "bios__block", "bios___address"], "vga_bios_offset": ["vga_bios_address", "vga_bio_size", "vga_bio_offset", "vga_bios_set", "vga_bio_address", "vga_bio_set"], "kernel_base": ["kernel2base", "kernel2size", "cpu_address", "kernel_buffer", "kernel_address", "cpu_size", "cpu_base", "kernel2address", "kernel2buffer", "cpu_buffer"], "kernel_size": ["kernel_number", "kernel_name", " kernel_number", " kernel_name"], "initrd_base": ["initrt_base", "initrt_size", "initrt_offset", "initrdtfile", "initrd_file", "initrd_offset", "initrt_file", "initrdtbase", "initrdtsize", "initrdtoffset"], "initrd_size": ["initrd_Size", "initrb_capacity", "initrd_capacity", "initrb_size", "initrb_Size"], "pci_bus": ["pci_boot", "pci__BUS", "pki_bs", "pci___boot", "pki_BUS", "pci__boot", "pci___BUS", "pci___bs", "pci_bs", "pki_boot", "pci___bus", "pci_BUS", "pci__bs", "pki_bus", "pci__bus"], "nvr": [" nVR", "nvae", "dvr", " nvp", "nnvp", "dvae", " nvae", "dvp", "nnvae", "nnVR", "nvp", "nnvr", "dVR", "nVR"], "nvram_mem_index": ["nvram_memory_size", "nvram_memory_address", "nvram_mem2type", "nvram_mem_address", "nvram_memory_type", "nvram_mem_type", "nvram_memory_index", "nvram_mem2index", "nvram_mem_size", "nvram_mem2size", "nvram_mem2address"], "vga_bios_size": ["vga_bio_size", "vga_bios_space", "vga_bios_index", "vga_biosetspace", "vga_biosetname", "vga_biosetindex", "vga_bio_index", "vga_bios_name", "vga_bio_name", "vga_biosetsize", "vga_bio_space"], "bios_size": ["bios1SIZE", "bios1storage", "bios_SIZE", "bios1size", "bias_size", "bias_SIZE", "bios_storage", "bias_storage"], "pic_mem_index": ["pic_mem_column", "pic_dim_address", "pic_mem_pos", "pic_dim_column", "pic_dimipaddress", "pic_dimipindex", "pic_dimipcolumn", "pic_memityindex", "pic_memipindex", "pic_dim_pos", "pic_mem_address", "pic_memitycolumn", "pic_memipaddress", "pic_memipcolumn", "pic_memityaddress", "pic_dimippos", "pic_memippos", "pic_memitypos", "pic_dim_index"], "dbdma_mem_index": ["dbdma_memory_index", "dbdma_memory_address", "dbdma_mem_num", "dbdma_mem_Index", "dbdma_mem_address", "dbdma_memory_Index", "dbdma_memory_num"], "cuda_mem_index": ["cuda_memory_index", "cuda_mem_device", "cuda_memory_Index", "cuda_memory_address", "cuda_memory_device", "cuda_mem_Index", "cuda_mem_address"], "escc_mem_index": ["escc_memory_address", "escc_memtindex", "escc_memtoffset", "escc_memtnum", "escc_mem_num", "escc_memory_num", "escc_mem_address", "escc_mem_offset", "escc_memtaddress", "escc_memory_offset", "escc_memory_index"], "ide_mem_index": ["ide_memxcycle", "ide_mem_address", "ide_memory_info", "ide_memxinfo", "ide_mem_cycle", "ide_memory_index", "ide_memxindex", "ide_memxaddress", "ide_memory_address", "ide_memory_cycle", "ide_mem_info"], "ppc_boot_device": ["ppc_boot2dev", "ppc_boot_dev", "ppc_booteddevice", "ppc_cpu_device", "ppc_boot2address", "ppc_boot2model", "ppc_booteddev", "ppc_boot_model", "ppc_cpu_dev", "ppc_boot2device", "ppc_cpu_address", "ppc_bootedaddress", "ppc_cpu_model", "ppc_boot_address", "ppc_bootedmodel"], "hd": ["HD", "dr", "dt", "ds", "haw", "hid", "ha", "dd", "hi", "rh", "ld", "h", "he", "dl", "dh", "gd", "sd", "ht", "hs", "him", "had", "md", "vd", "kb", "pd", "dri", "hp", "hyd", "bd"], "MAX_IDE_BUS": ["MAX_IDELEBU", "MAX_IDELEUS", "MAX_IDE2FS", "MAX_IDE_BU", "MAX_IDELEFS", "MAX_IDE2US", "MAX_IDELEBUS", "MAX_ID_US", "MAX_ID_BUS", "MAX_ID_BU", "MAX_IDE2BU", "MAX_ID_FS", "MAX_IDE2BUS", "MAX_IDE_US", "MAX_IDE_FS"], "MAX_IDE_DEVS": ["MAX_IDE_DESFS", "MAX_IDE_DVICE", "MAX_IDE_INVS", "MAX_IDE_DVS", "MAX_IDE_DEPS", "MAX_IDE_DESPS", "MAX_IDE_INFS", "MAX_IDE_DESVS", "MAX_IDE_INVICE", "MAX_IDE_DEFS", "MAX_IDE_DFS", "MAX_IDE_DEVICE", "MAX_IDE_DPS", "MAX_IDE_DESVICE", "MAX_IDE_INPS"], "fw_cfg": ["fw2cfg", "hw2cfg", "hw_init", "hw2init", "fw2init", "hw_cfg", "fw_config", "hw_config", "fw_init", "hw2config", "fw2config", "fw_fg", "fw2fg", "hw_fg", "hw2fg"], "dbdma": ["bdtmas", "bddme", "bdtme", "dbdmas", "dbtma", "dbgme", "dbtmas", "bdtma", "dbtme", "dbgms", "bddma", "dbsdma", "dbdme", "bddmas", "bdtms", "dbgmas", "dbsdme", "dbsdms", "dbgma", "dbtms", "dbdms", "dbsdmas", "bddms"], "vga_bios_ptr": ["vga_biosacptr", "vga_bios_pointer", "vga_bios__ptr", "vga_bios__pointer", "vga_bio_handle", "vga_biosacpointer", "vga_bios_handle", "vga_bios__addr", "vga_bios_addr", "vga_bio_addr", "vga_biosacaddr", "vga_biosachandle", "vga_bio_ptr", "vga_bios__handle", "vga_bio_pointer"], "machine_arch": ["machineableplatform", "cpu_core", "machineablearchs", "machineablearch", "cpu_arch", "cpu_archs", "machine_core", "machineablecore", "machine_platform", "machine_archs", "cpu_platform"]}}
{"project": "qemu", "commit_id": "492c30af2567a59413c064f88eb81e1691865195", "target": 0, "func": "void DMA_run(void)\n\n{\n\n    /* XXXXX */\n\n}\n", "idx": 6838, "substitutes": {}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "INLINE int16 extractFloat64Exp( float64 a )\n\n{\n\n\n\n    return ( a>>52 ) & 0x7FF;\n\n\n\n}\n", "idx": 6844, "substitutes": {"a": ["la", "ia", "ava", "p", "aa", "ua", "d", "l", "att", "r", "ae", "sta", "aka", "h", "j", "o", "b", "A", "g", "ma", "ata", "da", "area", "ba", "acc", "m", "na", "ca", "au", "ac", "ta", "as", "aux", "c", "am", "aaa", "n", "ao", "go", "va", "sa"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint32_t helper_fcmp_un(uint32_t a, uint32_t b)\n\n{\n\n    CPU_FloatU fa, fb;\n\n    uint32_t r = 0;\n\n\n\n    fa.l = a;\n\n    fb.l = b;\n\n\n\n    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {\n\n        update_fpu_flags(float_flag_invalid);\n\n        r = 1;\n\n    }\n\n\n\n    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {\n\n        r = 1;\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 6852, "substitutes": {"a": ["la", "af", "ia", "t", "p", "aa", "ea", "f", "l", "r", "ae", "eca", "apa", "ama", "ara", "i", "A", "an", "at", "oa", "ba", "ma", "da", "area", "ar", "e", "m", "ca", "ya", "ac", "ta", "x", "as", "c", "am", "aaa", "s", "ao", "n", "al", "u", "anta", "va", "sa"], "b": ["t", "p", "bi", "f", "d", "l", "v", "bar", "w", "cb", "ub", "body", "bs", "i", "B", "bb", "xb", "g", "pb", "ib", "ba", "y", "m", "bis", "eb", "bp", "base", "bc", "c", "ob", "bf", "n", "z", "nb", "u", "ab", "wb", "be"], "fa": ["eas", "af", " va", "ia", "ava", "aa", "lu", "fn", "ua", "alpha", "fi", "ea", "f", "raf", "fal", " FA", "ae", "ifa", "fd", "wa", " ta", "Fa", "ga", "pa", "ra", " ca", "apa", "fc", " af", "fat", " df", "ba", "FA", "fe", "ma", "cf", "da", "fo", "na", "ca", "afa", "ac", "ta", " ff", "bf", " al", "al", "ao", "oa", "va", "sa"], "fb": ["hd", "fg", "fi", "tf", "bj", "nb", "f", "raf", "bm", "uff", "fd", "fw", "cb", "ub", "ff", "abb", "xf", "buff", "fc", "bs", "FB", "fen", "bb", "fab", "erb", "pb", "gb", "rf", "fe", "fp", "db", "bg", "abl", "eb", "bp", "deb", "uf", "alf", "afi", "facebook", "ob", "bf", "obb", "zb", "rb", "wb", "fx"]}}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static int vhost_user_start(VhostUserState *s)\n\n{\n\n    VhostNetOptions options;\n\n\n\n    if (vhost_user_running(s)) {\n\n        return 0;\n\n    }\n\n\n\n    options.backend_type = VHOST_BACKEND_TYPE_USER;\n\n    options.net_backend = &s->nc;\n\n    options.opaque = s->chr;\n\n\n\n    s->vhost_net = vhost_net_init(&options);\n\n\n\n    return vhost_user_running(s) ? 0 : -1;\n\n}\n", "idx": 6867, "substitutes": {"s": ["t", "os", "S", "ess", "sports", "p", "conf", "ds", "details", "south", "is", "a", "v", "r", "ps", "spec", "ins", "ies", "z", "obj", "w", "less", "set", "ss", "h", "aws", "comm", "se", "changes", "bs", "i", "js", "ns", "hs", "b", "source", "sq", "sys", "g", "ses", "sts", "rs", "gs", "y", "ties", "ts", "es", "stats", "m", "its", "cs", "ims", "sb", "c", "ls", "ats", "qs", "n", "params", "eps"], "options": ["flags", "tools", "os", "ions", "p", "cp", "config", "details", "properties", "times", "ms", "to", "some", "policy", "scope", "tions", "obj", "Options", "ptions", "lets", "IONS", "ports", "outs", "o", "option", "caps", "io", "ables", "ssh", "closure", "keys", "tags", "opt", "abilities", "ts", "op", "e", "ops", "stats", "results", "checks", "actions", "vals", "bits", "etc", "values", "args", "allows", "sequence", "names", "parts", "als", "settings", "ption", "ls", "terms", "ats", "weights", "params", "eps", "services"]}}
{"project": "FFmpeg", "commit_id": "7a206eb32f624171a35235f714d44ee9dec9abcb", "target": 0, "func": "static int alac_set_info(ALACContext *alac)\n\n{\n\n    GetByteContext gb;\n\n\n\n    bytestream2_init(&gb, alac->avctx->extradata,\n\n                     alac->avctx->extradata_size);\n\n\n\n    bytestream2_skipu(&gb, 12); // size:4, alac:4, version:4\n\n\n\n    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);\n\n    if (alac->max_samples_per_frame >= UINT_MAX/4){\n\n        av_log(alac->avctx, AV_LOG_ERROR,\n\n               \"max_samples_per_frame too large\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    bytestream2_skipu(&gb, 1);  // compatible version\n\n    alac->sample_size          = bytestream2_get_byteu(&gb);\n\n    alac->rice_history_mult    = bytestream2_get_byteu(&gb);\n\n    alac->rice_initial_history = bytestream2_get_byteu(&gb);\n\n    alac->rice_limit           = bytestream2_get_byteu(&gb);\n\n    alac->channels             = bytestream2_get_byteu(&gb);\n\n    bytestream2_get_be16u(&gb); // maxRun\n\n    bytestream2_get_be32u(&gb); // max coded frame size\n\n    bytestream2_get_be32u(&gb); // average bitrate\n\n    bytestream2_get_be32u(&gb); // samplerate\n\n\n\n    return 0;\n\n}\n", "idx": 6879, "substitutes": {"alac": ["altAc", "malacer", "placc", "baloc", "calain", "malmac", "balacs", "altain", "elacs", "aviac", "alacc", "malacs", " alacs", "caloc", "malacc", "aliace", " alacc", "balsac", "aliAC", "ellacs", "alAc", "altade", "avAc", "aliacl", "ralacs", "arac", "calAC", "alain", "plac", "arace", "ayac", "talac", "relmac", "malam", "alc", "alic", "elac", "calic", "calact", " alic", "relacl", "calacs", "elljac", "aljack", "malAc", "elacc", " aljack", " almac", " aliac", "alacl", "altoc", "balac", "ralacl", "relac", "ayAC", "alade", "talade", "ayic", "alsac", " alc", "malAC", "calac", "talacer", "ellac", "plc", " alam", "relacc", " alAc", "alAC", "aliiac", "ellacc", " alace", "altac", " alsac", "aloc", "alam", "alact", "malace", "relam", "aracc", "aliacs", "avjack", "maljac", "calval", "aljac", "balval", " alacl", "balacc", "ralac", "alace", "altacer", "almac", "alacer", "talAc", "eljac", " alAC", "alval", "balace", "balacl", "aliac", "malac", "aliacc", "altval", "placl", "ayact", "alijack", "alacs", "avac", "malade", " alact", "ralsac", "relace", "aliAc", "calace", "aracl", "balain"], "gb": ["py", "deg", "gm", "gt", "msg", "uge", "gc", "rg", "gs", "vm", "db", "bridge", "gin", " GB", "managed", "git", "gov", "data", " eg", "eg", "hub", "dd", "ge", "gd", "DB", "b", "gem", "Gb", "buffer", "maybe", "GB", "storage", "args", "csv", "sb", "gif", "nb", " pg", "priv", "gu", "gpu", "cb", "RGB", "io", " rgb", "mb", "xy", "bg", "gg", "eb", "bf", "img", "lib", "cv", "pg", "ga", "server", " db", "attr", " rg", "bb", "g", "kb", "wm", "cfg", "tg", "gp", "sv", "yg", "sky", "rb", "grow"]}}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_send_command(SDHCIState *s)\n\n{\n\n    SDRequest request;\n\n    uint8_t response[16];\n\n    int rlen;\n\n\n\n    s->errintsts = 0;\n\n    s->acmd12errsts = 0;\n\n    request.cmd = s->cmdreg >> 8;\n\n    request.arg = s->argument;\n\n    DPRINT_L1(\"sending CMD%u ARG[0x%08x]\\n\", request.cmd, request.arg);\n\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n\n\n\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n\n        if (rlen == 4) {\n\n            s->rspreg[0] = (response[0] << 24) | (response[1] << 16) |\n\n                           (response[2] << 8)  |  response[3];\n\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n\n            DPRINT_L1(\"Response: RSPREG[31..0]=0x%08x\\n\", s->rspreg[0]);\n\n        } else if (rlen == 16) {\n\n            s->rspreg[0] = (response[11] << 24) | (response[12] << 16) |\n\n                           (response[13] << 8) |  response[14];\n\n            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |\n\n                           (response[9] << 8)  |  response[10];\n\n            s->rspreg[2] = (response[3] << 24) | (response[4] << 16) |\n\n                           (response[5] << 8)  |  response[6];\n\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n\n                            response[2];\n\n            DPRINT_L1(\"Response received:\\n RSPREG[127..96]=0x%08x, RSPREG[95..\"\n\n                  \"64]=0x%08x,\\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\\n\",\n\n                  s->rspreg[3], s->rspreg[2], s->rspreg[1], s->rspreg[0]);\n\n        } else {\n\n            ERRPRINT(\"Timeout waiting for command response\\n\");\n\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n\n                s->norintsts |= SDHC_NIS_ERR;\n\n            }\n\n        }\n\n\n\n        if ((s->norintstsen & SDHC_NISEN_TRSCMP) &&\n\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n\n            s->norintsts |= SDHC_NIS_TRSCMP;\n\n        }\n\n    }\n\n\n\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n\n        s->norintsts |= SDHC_NIS_CMDCMP;\n\n    }\n\n\n\n    sdhci_update_irq(s);\n\n\n\n    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n\n        s->data_count = 0;\n\n        sdhci_data_transfer(s);\n\n    }\n\n}\n", "idx": 6891, "substitutes": {"s": ["p", "conf", "https", "bes", "l", "gets", "ns", "sq", "ses", "gs", "y", "stats", "xs", "its", "ims", "ants", "settings", "n", "qs", "services", "S", "ps", "vs", "ins", "less", "ss", "h", "changes", "i", "js", "b", "sts", "ts", "ops", "ads", "fs", "sis", "sb", "als", "ats", "sys", "ers", "states", "tests", "sports", "details", "is", "events", "aws", "ys", "views", "bs", "rs", "m", "bis", "cs", "as", "ls", "t", "os", "ds", "south", "ms", "v", "ies", "set", "hs", "ssl", "g", "store", "es", "utils", "sv", "se", "sw"], "request": ["search", "hello", "order", "query", "cp", "reset", "QUEST", "art", "task", "delete", "application", "re", "worker", "question", "position", "q", "change", "select", "call", "transform", "setup", "set", "req", " query", "complete", "package", "word", "requ", "est", "begin", "store", "command", "Request", " requesting", "forward", "document", "record", "quest", "pair", "report", "initial", "project", "test", "reference", "trip", "import", "first", "item", "client", "transfer", "open", "message", "create", "execute", "cmd"], "response": ["get", "view", "present", "application", "connection", "description", "phrase", "range", "results", "model", "des", "message", "er", "search", "json", "query", "more", "no", "success", "python", "data", "list", "ve", "output", "empty", "site", "example", "zero", "answer", "new", "report", "all", "block", "total", "sol", "entry", "collection", "reset", "question", "image", "version", "point", "tree", "process", "sample", "e", "values", "sequence", "out", "relation", "respons", "frame", "v", "onse", "Response", "hash", "ping", "position", "server", "object", "o", "attribute", "vector", "bytes", "resp", "result", "memory", "given", "network", "status", "es", "document", "res", "line", "window", " Response", "route", "then", "reply", "pos", "array", "cache", "next", "value", "se", "yes", "template"], "rlen": [" rlic", "rrli", "rrlen", "Rtl", "erlin", "nrli", "mlin", "rLen", "mlen", "erlength", "nrlic", " rfin", "mLen", "rrlic", "reelt", "rli", "relen", "Rlen", " rLen", "Relt", "Rlength", "relt", " relt", "rfin", "tLen", " rsl", " rtl", "rlength", " rli", "nrlen", "tlength", "reLen", "Rfin", "rlic", " rlin", "erLen", "retl", "erlen", "mlength", "rtl", "nrsl", "rlin", "tlen", " rlength", "RLen", "rsl", "tfin", "rrsl"]}}
{"project": "qemu", "commit_id": "ddf21908961073199f3d186204da4810f2ea150b", "target": 0, "func": "static void test_dealloc_types(void)\n\n{\n\n    UserDefOne *ud1test, *ud1a, *ud1b;\n\n    UserDefOneList *ud1list;\n\n\n\n    ud1test = g_malloc0(sizeof(UserDefOne));\n\n    ud1test->base = g_new0(UserDefZero, 1);\n\n    ud1test->base->integer = 42;\n\n    ud1test->string = g_strdup(\"hi there 42\");\n\n\n\n    qapi_free_UserDefOne(ud1test);\n\n\n\n    ud1a = g_malloc0(sizeof(UserDefOne));\n\n    ud1a->base = g_new0(UserDefZero, 1);\n\n    ud1a->base->integer = 43;\n\n    ud1a->string = g_strdup(\"hi there 43\");\n\n\n\n    ud1b = g_malloc0(sizeof(UserDefOne));\n\n    ud1b->base = g_new0(UserDefZero, 1);\n\n    ud1b->base->integer = 44;\n\n    ud1b->string = g_strdup(\"hi there 44\");\n\n\n\n    ud1list = g_malloc0(sizeof(UserDefOneList));\n\n    ud1list->value = ud1a;\n\n    ud1list->next = g_malloc0(sizeof(UserDefOneList));\n\n    ud1list->next->value = ud1b;\n\n\n\n    qapi_free_UserDefOneList(ud1list);\n\n}\n", "idx": 6919, "substitutes": {"ud1test": ["aud71test", "udOncetxt", "mud1tests", "mud1tested", "uid1test", "disk001show", "disk1show", "ud101style", "udOnever", "mud1test", "ub101style", "disk1testing", "ud001test", "ub1style", "udontest", "ub101testing", "uidOncetrain", "udonetests", "ud5train", "ud7train", "ud1key", "ud1py", "ud91tests", "ud91true", "ud21tests", "uid1txt", "ub1tests", "ub1key", "disk001test", "ud101test", "ud4key", "ud7testing", "ud51train", "ud51test", "ud01show", "aud1test", "ub101tests", "ub51key", "aud71train", "udonstyle", "aud1train", "ud21true", "ud71train", "ub1train", "mud91test", "ud21test", "ud001testing", "ud01testing", "udricshow", "mud91true", "udonetrue", "ud1txt", "ub51train", "udonetested", "disk1txt", "ud1style", "udrictxt", "ud001txt", "ud1true", "mud91tests", "disk001testing", "ud101testing", "ud7tests", "ud71test", "disk001txt", "udOnetest", "mud91tested", "udOncetrain", "udonetest", "ud7style", "udOnetrain", "ud5ver", "ud1ver", "udOncetest", "ub101test", "ud01txt", "ud7txt", "uid1ver", "ud101tests", "udrictesting", "ud4train", "uidOncetxt", "ud7py", "uidOncever", "ud1tests", "ud1tested", "aud71txt", "ud7test", "ub1testing", "udrictest", "ud4test", "udOncever", "aud1py", "udontesting", "ud101train", "udOnepy", "ud51style", "disk1test", "ud71txt", "udOnetxt", "ud4style", "ud101key", "ud5test", "ud1train", "ub51style", "uid1train", "ud91test", "udontests", "ud5txt", "mud1true", "ud1show", "ud71py", "aud1txt", "ud1testing", "ud21tested", "ud91tested", "ud01test", "ub1test", "ud51key", "ud001show", "aud71py", "ub51test", "uidOncetest"], "ud1a": ["ud1ca", "ud12ia", "ud01a", "udOnceagent", "ud11a", "udappelement", "grad1ad", "uu1ab", "udOnceelement", "ud12a", "grad01ad", "hd1p", "ud18ca", "ud81area", "ud18ia", "ud81a", "ud9ai", "ud61agent", "ud5ar", "ud100n", "ud1r", "ud5attribute", "ub61agent", "urd1a", "ud10a", "ub61aa", "uu127a", "ub1aa", "grad1element", "ud13r", "ud100a", "urd18ia", "ud1element", "ud81an", "hd1l", "ud81n", "ub81n", "ud18a", "ub1a", "ub61ai", "grad1agent", "ub1an", "udOnepart", "ud61a", "ud9aa", "udOneca", "ub81an", "hd1a", "grad01a", "ub1agent", "uu127ar", "ud1ia", "urd1ia", "udOnea", "ud9agent", "ub1n", "ud1ai", "urd18ca", "udappa", "urd18part", "urd18a", "ud1l", "udOner", "ud01element", "hd17l", "ud01agent", "ud1ab", "ud1attribute", "ud10aa", "uu1a", "ud127ab", "ud5ab", "ud127ar", "ud1n", "udOneia", "hd17r", "ud1p", "ud11ab", "ud1ad", "ub81area", "hd1r", "ud13a", "ud01area", "ud13l", "ud18part", "ud1part", "grad01element", "udOnep", "ud17p", "urd1ca", "uu1attribute", "ub1ai", "ud127attribute", "hd17a", "ud61aa", "ud100area", "ud12ca", "hd17p", "udOncea", "ud61ai", "udOncead", "ud11attribute", "uu127ab", "ud1an", "ub1area", "ud13p", "ud17r", "ud9a", "ud01ad", "ud1agent", "ub81a", "ud11ar", "grad01agent", "udappagent", "ud10agent", "ud01n", "udappad", "grad1a", "ud10ai", "ud17l", "ub61a", "ud127a", "udOnel", "uu127attribute", "ud12part", "ud01an", "ud17a", "ud1aa", "urd1part", "ud100an", "ud1ar", "ud1area", "ud5a", "uu1ar"], "ud1b": ["ud1ba", "ud120b", "aud1j", "ud01reb", "ud1eb", "gd51b", "ud11rb", "ud12beta", "udprebeta", "dd1l", "dd2b", "ud001b", "ud81a", "aud1rb", "aud01rb", "ud51b", "ud12b", "ud1r", "ud01rb", "aud1reb", "ud3a", "ud12ba", "ud11r", "ud01b", "ud1rb", "ud01cb", "vd1reb", "udachebrowser", "audOner", "ud1br", "ud1beta", "udachej", "ud1bot", "ud01bin", "ud1j", "vd1b", "gd51bot", "vd1bin", "ud110eb", "udi1b", "udoned", "udonereb", "udi001j", "ud3l", "gd51ba", "ud11eb", "ud81l", "ud01j", "udi001browser", "aud1eb", "ud12bot", "ud120reb", "vd01b", "ud51beta", "ud120bin", "ud01eb", "ud51bot", "dd1obj", "aud01eb", "ud3b", "ud1d", "aud1d", "ud1l", "ud001br", "udOner", "ud110rb", "gd1beta", "vd01bin", "udi001br", "ud11b", "ud1bin", "gd51beta", "ud11reb", "udi1browser", "aud01b", "vd01cb", "ud110reb", "audOned", "udpreba", "ud11j", "ud1cb", "udachebr", "ud01browser", "dd2obj", "udacheb", "udonebin", "ud1obj", "udonecb", "gd1b", "ud120cb", "aud1r", "udoneb", "ud51ba", "udi1br", "ud11d", "ud1browser", "audOneb", "dd1a", "dd2l", "dd1b", "udi1j", "vd1cb", "udi001b", "ud001j", "ud110b", "aud01reb", "ud2b", "ud1reb", "gd1ba", "dd2a", "udoner", "ud3obj", "aud1b", "ud2a", "udonej", "ud81obj", "udprebot", "udOned", "ud2l", "audOnej", "ud2obj", "gd1bot", "udpreb", "ud01br", "udOnej", "vd01reb", "udOneb", "ud001browser", "ud81b"], "ud1list": ["ud51list", "ud5list", "udOnecollection", "ud6batch", "ud1level", "xd1entry", "ud2list", "ud1log", "ud12err", "ud591level", "rod1detail", "audOnenot", "ud7l", "udtxno", "ud6level", "udOneerr", "ud3list", "rod11test", "udOneall", "udOnelevel", "udtxlist", "ud11test", "ud5LIST", "ud11err", "aud591log", "ud591log", "aud1err", "ud1List", "ud6list", "udOnelist", "xd1list", "aud591level", "ud11detail", "ud12all", "aud591collection", "audOneall", "ud7List", "ud10test", "ud3List", "ud3l", "aud1log", "ud6log", "udOnenot", "xdOneentry", "ud2List", "rod11detail", "ud12list", "ud11LIST", "ub1list", "udOncelist", "udd1list", "ud1l", "ud10detail", "rod11list", "ud10LIST", "ud1LIST", "udd1level", "xd1log", "ub7test", "ud5detail", "ud1err", "ud10list", "aud1not", "aud591list", "ud11all", "udtxbatch", "ud51entry", "ud11no", "uddtxlevel", "ud7test", "ud1line", "udtxlevel", "rod1list", "ub1l", "ud51line", "ud7list", "xd1line", "ud2test", "uddtxlist", "aud1level", "ud11level", "ud591list", "ud11batch", "udOneline", "ub1List", "audOnelist", "ud1all", "ud5test", "ud1batch", "xdOneline", "udOncelog", "ub7List", "uddtxno", "udOnceentry", "rod1LIST", "ud1detail", "udOnelog", "ud11not", "udOneentry", "ud591collection", "ub7list", "ud12not", "ud1collection", "aud1all", "ud2l", "uddtxbatch", "rod1test", "ud11list", "ud6collection", "xdOnelog", "ud1entry", "audOneerr", "ud3test", "aud1list", "ub7l", "udOnceline", "ub1test", "ud1no", "udd1no", "ud51log", "aud1collection", "xdOnelist", "ud1not", "udd1batch", "ud6no", "rod11LIST"]}}
{"project": "qemu", "commit_id": "362786f14a753d8a5256ef97d7c10ed576d6572b", "target": 0, "func": "void net_checksum_calculate(uint8_t *data, int length)\n\n{\n\n    int hlen, plen, proto, csum_offset;\n\n    uint16_t csum;\n\n\n\n    if ((data[14] & 0xf0) != 0x40)\n\n\treturn; /* not IPv4 */\n\n    hlen  = (data[14] & 0x0f) * 4;\n\n    plen  = (data[16] << 8 | data[17]) - hlen;\n\n    proto = data[23];\n\n\n\n    switch (proto) {\n\n    case PROTO_TCP:\n\n\tcsum_offset = 16;\n\n\tbreak;\n\n    case PROTO_UDP:\n\n\tcsum_offset = 6;\n\n\tbreak;\n\n    default:\n\n\treturn;\n\n    }\n\n\n\n    if (plen < csum_offset+2)\n\n\treturn;\n\n\n\n    data[14+hlen+csum_offset]   = 0;\n\n    data[14+hlen+csum_offset+1] = 0;\n\n    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);\n\n    data[14+hlen+csum_offset]   = csum >> 8;\n\n    data[14+hlen+csum_offset+1] = csum & 0xff;\n\n}\n", "idx": 6927, "substitutes": {"data": ["p", "digital", "button", "join", "str", "self", "valid", "current", "date", "text", "row", "ma", "results", "final", "tx", "c", "message", "n", "extra", "dev", "no", "a", "r", "done", "list", "device", "output", "empty", "dat", "def", "index", "name", "at", "zero", "buffer", "len", "code", "this", "raw", "bits", "all", "num", "x", "block", "total", "debug", "d", "att", "board", "component", "image", "ad", "padding", "version", "pad", "Data", "read", "bus", "size", "chain", "format", "off", "input", "ata", "m", "rel", "table", "values", "sequence", "number", "add", "out", "t", "form", "v", "hash", "DATA", "o", "history", "bytes", "result", "buf", "trace", "da", "um", "content", "window", "update", "bin", "video", "next", "cache", "public", "batch"], "length": ["p", "d", "l", "v", "en", "h", "ength", "size", "type", "len", "code", "end", "e", "block", "Length"], "hlen": ["itfil", "vLen", "zlen", "historymil", "bhlib", "historyalign", "explu", "highlf", "hlu", "ihla", "bhlen", "ihlib", "highlu", "highLen", "phlength", "khden", "tlength", "highfil", " hcoll", "pLen", "hli", "historylf", "vlen", "phden", "zLen", " hmil", "rhLen", "itlen", "ihli", "bhla", "hwlen", "hLen", "hmil", "explen", "hlib", "hwla", "highmil", "ten", "Hlength", "Hlen", "bhli", "halign", "plength", "highlen", "pen", "highalign", "hden", "Hen", " hli", "khlen", "phlen", "hlength", "rhcoll", "hwLen", "ven", "hcoll", "rhmil", "phen", " hLen", "tLen", " hlib", "vlength", "hwlength", "ihden", "italign", "tlen", "HLen", "highcoll", "historylen", "zlength", "hfil", "explf", "ihlength", "expfil", " hla", "vden", "historyfil", "hen", "hlf", " hden", "historylu", " hlength", "itmil", "khLen", "zla", "ihen", "rhlen", "ihlen", "hla"], "plen": [" Plang", "plens", "pelength", " plun", "lpen", "plien", "persen", "palenum", "polade", "plun", "lpatten", "PLen", "iplen", "Plang", "plenum", " Plens", "Plens", "platten", "palen", "polun", "plang", "pelear", "persength", "Plen", "iplien", "lpenum", "perslen", "pelen", "persear", " Pllen", "PLlen", "palien", "PLength", "pollen", "pellen", " plens", "Plade", "plade", "plear", "plength", "pllen", "lpien", "PLear", "palatten", " Plen", "iplenum", "Pllen", "Plun", " pllen", "polen", " plade", " plang", "iplatten"], "proto": ["progo", "Proocol", "rotop", "Protype", "prbe", "ropo", "procgo", "protype", "prpo", "procpo", "Propo", "prto", "Probe", "Proto", "proocol", "propo", "procto", "PROtype", "pocol", "pro", "prTO", "pto", "prgo", "po", "roco", "Proo", "ProTO", "proTO", "protop", "proco", "pbe", "PROto", "PROTO", "prtop", "procol", "probe", "proo", "roto", "PROtop", "Progo", "proctype", "prtype", "Protop", "Proco", "prco"], "csum_offset": ["csum___style", "cssum_padding", "csul_size", "csum_style", "cssum_off", "csum_position", "csul_position", "csum_off", "cssum_error", "csum_error", "csum_size", "csum___Offset", "cssum_offset", "csumptfield", "cssum_slot", "csum_Offset", "cssum_field", "csum___offset", "csum_optional", "cssum_type", "csum_index", "csumptoffset", "csul_offset", "csum_field", "cssum_index", "csum_type", "cssum_Offset", "csum_padding", "csum_slot", "csum___slot", "cssum_size", "csumpterror", "cssum_pointer", "csum_pointer", "csumpttype", "cssum_style", "csul_Offset"], "csum": ["csssum", "cssunc", "ckssum", " csul", "cossum", "cssul", "checksump", "checksunc", "cosum", "rssum", "csump", "rsul", "cksunc", " csam", "cussum", "cusul", "cksam", "cksul", "cosul", "cusump", "rsump", "cksumer", "cosumer", "cssum", "csam", "checksul", "checksumer", "rsum", "checksam", "cksum", " cssum", "checkssum", "csunc", "csul", "checksum", "csumer", "cusum"]}}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static void x86_cpu_parse_featurestr(const char *typename, char *features,\n\n                                     Error **errp)\n\n{\n\n    char *featurestr; /* Single 'key=value\" string being parsed */\n\n    static bool cpu_globals_initialized;\n\n    bool ambiguous = false;\n\n\n\n    if (cpu_globals_initialized) {\n\n        return;\n\n    }\n\n    cpu_globals_initialized = true;\n\n\n\n    if (!features) {\n\n        return;\n\n    }\n\n\n\n    for (featurestr = strtok(features, \",\");\n\n         featurestr;\n\n         featurestr = strtok(NULL, \",\")) {\n\n        const char *name;\n\n        const char *val = NULL;\n\n        char *eq = NULL;\n\n        char num[32];\n\n        GlobalProperty *prop;\n\n\n\n        /* Compatibility syntax: */\n\n        if (featurestr[0] == '+') {\n\n            plus_features = g_list_append(plus_features,\n\n                                          g_strdup(featurestr + 1));\n\n            continue;\n\n        } else if (featurestr[0] == '-') {\n\n            minus_features = g_list_append(minus_features,\n\n                                           g_strdup(featurestr + 1));\n\n            continue;\n\n        }\n\n\n\n        eq = strchr(featurestr, '=');\n\n        if (eq) {\n\n            *eq++ = 0;\n\n            val = eq;\n\n        } else {\n\n            val = \"on\";\n\n        }\n\n\n\n        feat2prop(featurestr);\n\n        name = featurestr;\n\n\n\n        if (g_list_find_custom(plus_features, name, compare_string)) {\n\n            error_report(\"warning: Ambiguous CPU model string. \"\n\n                         \"Don't mix both \\\"+%s\\\" and \\\"%s=%s\\\"\",\n\n                         name, name, val);\n\n            ambiguous = true;\n\n        }\n\n        if (g_list_find_custom(minus_features, name, compare_string)) {\n\n            error_report(\"warning: Ambiguous CPU model string. \"\n\n                         \"Don't mix both \\\"-%s\\\" and \\\"%s=%s\\\"\",\n\n                         name, name, val);\n\n            ambiguous = true;\n\n        }\n\n\n\n        /* Special case: */\n\n        if (!strcmp(name, \"tsc-freq\")) {\n\n            int64_t tsc_freq;\n\n\n\n            tsc_freq = qemu_strtosz_metric(val, NULL);\n\n            if (tsc_freq < 0) {\n\n                error_setg(errp, \"bad numerical value %s\", val);\n\n                return;\n\n            }\n\n            snprintf(num, sizeof(num), \"%\" PRId64, tsc_freq);\n\n            val = num;\n\n            name = \"tsc-frequency\";\n\n        }\n\n\n\n        prop = g_new0(typeof(*prop), 1);\n\n        prop->driver = typename;\n\n        prop->property = g_strdup(name);\n\n        prop->value = g_strdup(val);\n\n        prop->errp = &error_fatal;\n\n        qdev_prop_register_global(prop);\n\n    }\n\n\n\n    if (ambiguous) {\n\n        error_report(\"warning: Compatibility of ambiguous CPU model \"\n\n                     \"strings won't be kept on future QEMU versions\");\n\n    }\n\n}\n", "idx": 6935, "substitutes": {"typename": ["typpename", "tyrenename", "typenename", "tyternamer", "tytonename", "tylenames", "tyrenames", "tyrenAME", "typedame", "typtonamer", "tytonamer", "TYpenAME", "typedename", "typenamer", "typerame", "tytoname", "typtonow", "tylenAME", "TYlenames", "typenames", "typerename", "TYpename", "tyternow", "TYlenAME", "tylename", "typpenamer", "typerames", "typpenow", "typtoname", "TYlenename", "typenow", "typedow", "TYpenames", "typtonename", "TYpenename", "tytername", "TYlename", "typerAME", "typenAME", "typedamer", "tyternename", "tylenename", "tytonow", "tyrename", "typpenename"], "features": ["flags", "tests", "strings", "items", "fn", "details", "properties", "classes", "types", "facts", "frames", "words", "fts", "fields", "ports", "errors", "events", "rows", "ns", "mas", "ints", "Features", "feature", "keys", "products", "faces", "stats", "results", "reports", "actions", "xs", "vals", "bits", "fs", "its", "values", "cs", "args", "names", "parts", "terms", "feat", "acts", "weights", "eatures"], "errp": ["rarp", "Erp", "Erpe", "warnpc", "warnp", "diepp", "rarpat", "ererm", " errm", "errpp", "ererp", "rarpp", "Erm", "errpe", "errpat", "rarpc", "warnpp", "diep", "diepat", " errr", "ererpe", "errpc", "diepc", " errpe", "errr", "ererr", "errm", "Err", "warnpat"], "featurestr": ["corestring", "querystr", "featstring", "resultstring", "Featurestring", "familySTR", "featurevol", "featurecur", "featuresstr", "featurest", "featurearr", " featureobj", "spanstr", "jsonSTR", "featstr", "remoteStr", " featureline", "sequencest", "featureobj", "featname", "familystr", "spanstring", " featurestring", "framevol", "teststr", "personstr", "featst", "remotestr", "Featurename", "feat0", "personchain", "spanbr", "testStr", "personarr", "querystring", "familydel", "query0", "framearr", "remoteSTR", "featuresSTR", "jsonstr", "framest", "featurebr", "featuredel", "featline", "featarr", "remotedel", "personcoll", "testSTR", "fingerarr", "fingerstr", "featureSTR", "framestr", "featcoll", " featureStr", "resultstr", "Featurearr", "expressionstr", "expressionStr", "featSTR", "feature0", "featobj", "teststring", "fingercoll", "sequencearr", "resultStr", "featureStr", "featcur", "featurename", "featurechain", "queryname", "featuresstring", "coreobj", " featurename", "featStr", " feature0", "sequencevol", "featureline", "coreStr", "corestr", "featurecoll", "resultline", "expressionstring", "jsonStr", " featurearr", " featurecur", "fingerchain", "jsonname", "featvol", "sequencestr", "expressioncur", "Featurestr", "spanStr", "featdel", " featureSTR", "featuresStr", "featurestring", "familyStr", " featurebr", "featbr", "featchain"], "cpu_globals_initialized": ["cpu_globalsNotstarted", "cpu_globALS_Initialized", "cpu_globals_Initialized", "cpu_globals__init", "cpu_globalsNotinitialized", "cpu_globalsNotinit", "cpu_globals_init", "cpu_globals__initialized", "cpu_globalls_loaded", "cpu_globALS_created", "cpu_globALS_initialized", "cpu_globals_started", "cpu_globalls_started", "cpu_globalsNotloaded", "cpu_globalls_initialized", "cpu_globals_created", "cpu_globalls_init", "cpu_globals_loaded", "cpu_globALS_loaded", "cpu_globals__loaded", "cpu_globALS_init"], "name": ["key", "qual", "id", "path", "call", "true", "loc", "str", "self", "alias", "nam", "none", "root", "par", "ver", "term", "range", "ma", "ni", "mod", "n", "start", "cmd", "event", "old", "no", "dim", "data", "normal", "scope", "word", "nan", "mem", "def", "comment", "admin", "len", "new", "code", "raw", "part", "item", "order", "Name", "common", "label", "ext", "ne", "size", "group", "tree", "type", "missing", "var", "min", "local", "create", "NAME", "doc", "ame", "col", "spec", "parent", "prefix", "o", "in", "attr", "info", "an", "base", "test", "title", "names", "pos", "value"], "val": ["key", "fail", "VAL", "util", "elt", "dev", "el", "eval", "sel", "cho", "v", "dim", "data", "col", "ctx", "label", "it", "msg", "typ", "loc", "str", "req", "valid", "attr", "ret", "mem", "def", "index", "ver", "pol", "lib", "buf", "pr", "range", "ref", "type", "len", "stat", "rel", "res", "vals", "unit", "vec", "values", "addr", "test", "expr", "Value", "var", "x", "seq", "tx", "item", "vol", "pos", "vt", "value", "err", "Val"], "eq": ["init", "extra", "equ", "et", "p", "qual", "elt", "alpha", "qq", "el", "eval", "sel", "id", "ctx", "ext", "quant", "ele", "error", "different", "diff", "ox", "offset", "equal", "fun", "req", "ue", "ep", "valid", "alias", "ne", "imp", "ie", "ip", "ex", "iq", "np", "ident", "echo", "sq", "rx", "comp", "eff", "zero", "inc", "ref", "len", "cmp", "match", "omp", "xy", "cond", "rel", "pair", "test", "expr", "desc", "seq", "aux", "ef", "xp", "rt", "err", "cmd", "eps", "fx"], "num": ["t", "NUM", "mon", "max", "fn", "no", "temp", "id", "dim", "sum", "nt", "label", "msg", "gpu", "con", "node", "valid", "gc", "none", "attr", "nm", "ns", "nu", "mem", "np", "def", "Number", "index", "nr", " numeric", "Num", "multi", "zero", "row", "new", "um", "na", "unit", "flag", "test", "number", "desc", "count", " NUM", "x", "param", "cal", "n", "local", "nb", "value"], "prop": ["ph", "key", "rep", "cp", "p", "pub", "pkg", "Prop", "priv", "pred", "func", "col", "ps", "obj", "plot", "pro", " Prop", "pt", "attr", "proc", "def", "po", "par", "comp", "term", "property", "pr", "decl", "jp", "op", "fo", "cfg", "stat", "pri", "rop", "test", "expr", "desc", "mod", "pid", "feat", "pos", "dep", "err", "cmd"], "tsc_freq": ["tsc_Freq", "tsc_freQ", "tsc_reqs", "tsc_Frez", "tsc_frej", "tsc_treQ", "tsc2Freq", "tsc_frez", "tsc_feq", "tsc_req", "tsc_Frej", "tsc_fez", "tsc2freqi", "tsc_nuz", "tsc_Freck", "tsc_reQ", "tsc2freQ", "tsc_freqi", "tsc_freqs", "tsc_fej", "tsc_nuqs", "tsc_treqi", "tsc2FreQ", "tsc_feck", "tsc2frez", "tsc2Frez", "tsc_Freqi", "tsc_reck", "tsc_feqs", "tsc_trez", "tsc_nuq", "tsc_FreQ", "tsc_treq", "tsc2Freqi", "tsc_feQ", "tsc_nuck", "tsc_freck", "tsc_Freqs", "tsc2freq"]}}
{"project": "qemu", "commit_id": "361dcc790db8c87b2e46ab610739191ced894c44", "target": 1, "func": "static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,\n\n                                               VirtQueue *vq,\n\n                                               EventNotifierHandler *handler,\n\n                                               int n)\n\n{\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);\n\n    int rc;\n\n\n\n    /* Set up virtqueue notify */\n\n    rc = k->set_host_notifier(qbus->parent, n, true);\n\n    if (rc != 0) {\n\n        fprintf(stderr, \"virtio-scsi: Failed to set host notifier (%d)\\n\",\n\n                rc);\n\n        exit(1);\n\n    }\n\n    r->host_notifier = *virtio_queue_get_host_notifier(vq);\n\n    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);\n\n    aio_set_event_notifier(s->ctx, &r->host_notifier, handler);\n\n\n\n    r->parent = s;\n\n\n\n    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {\n\n        fprintf(stderr, \"virtio-scsi: VRing setup failed\\n\");\n\n        exit(1);\n\n    }\n\n    return r;\n\n}\n", "idx": 6946, "substitutes": {"s": ["t", "os", "S", "p", "ds", "is", "a", "v", "sp", "ps", "q", "w", "less", "ss", "self", "h", "j", "o", "sr", "bs", "i", "js", "ns", "hs", "b", "sq", "g", "ses", "sts", "socket", "rs", "gs", "ts", "es", "fs", "its", "service", "sv", "cs", "sb", "c", "src", "ls", "qs", "sys", "services"], "vq": ["vrw", "nvpkg", " vv", " vue", "nvq", "pQ", "nviq", "vrq", "nvv", "vv", "sue", "vcv", "viq", "spe", "nvqu", "piq", " vpkg", "vw", "vcpkg", " vw", "vcq", "nvw", "sq", "vqu", "vpkg", "pq", "vue", "pqu", "vpe", " vpe", "vrue", "vQ", " vQ", "vrpe", "nvQ", "vcw", " viq", " vqu", "sw"], "handler": ["function", "kh", "hander", "fn", "management", "func", "er", "worker", "policy", "error", "reader", "cb", "server", "folder", "handle", "h", "parser", "anger", "manager", "band", "type", "command", "handled", "holder", "han", "job", "base", "test", "older", "behavior", "lambda", "message", "callback", "Handler", "wrapper", "event", "hand"], "n": ["t", " l", "p", "nat", "fn", "no", "d", "l", "v", "nn", "nt", "w", "node", "h", "j", "o", "cn", "nm", "dn", "i", "ns", " ng", "nu", "b", "np", "name", "nr", "g", "net", "y", "sn", "nw", "m", "na", "N", " ns", "num", "number", "count", "c", "nl", "nb", "nc", "tn"], "qbus": ["quus", " qstate", "qmu", " qboot", "qqdev", "qus", "dqus", "qstate", " qBus", "qBus", "qqbus", " qdev", "QBus", "qBUS", "qudev", " squs", " sqBUS", "quBUS", " qmu", "qumu", "Qboot", "dqboot", "Qbus", " sqbus", " sqmu", "qqboot", "Qus", "qubus", " qus", "dqBus", "qqstate", "qboot", "dqbus", " qBUS", "qdev", "qustate", "quboot"], "k": ["ka", "key", "kh", "ke", "kan", "sch", "K", "ki", "sk", "kn", "KR", "mk", "kk", "kr", "uk", "ikk", "ks", "aka", "wk", "km", "kt", "j", "kind", "kl", "g", "ijk", "kj", "ck", "ker", "ik", "ek", "kar", "ak", "tk", "kw", "kick", "kit"], "r": ["ur", "fr", "dr", "p", "rer", "d", "l", "v", "rw", "kr", "re", "R", "lr", "rr", "q", "w", "rh", "or", "req", "j", "br", "vr", "sr", "cr", "attr", "ret", "i", "rb", "rg", "result", "b", "usr", "hr", "nr", "g", "pr", "rs", "rar", "ar", "rn", "rec", "m", "res", "rel", "rd", "tr", "gr", "c", "ro", "rt", "er", "u", "err", "mr"], "rc": ["sc", "isc", "co", "RC", "ctr", "nt", "ec", " ro", " cr", "pc", "rr", "cor", "sync", "rl", "dc", "con", "roc", "cd", "cb", "arc", "cur", "cc", " ec", "ry", "ok", "gc", "cr", "fc", " cc", "irc", "rx", "nr", "act", "rs", "inc", "uc", "row", "cmp", "rn", "ck", " RC", "rec", "code", "res", "ko", "ce", " res", "desc", "x", "ac", "src", "ro", "ack", "rt", "nc", "err", "yes"]}}
{"project": "qemu", "commit_id": "7d91ddd25e3a4e5008a2ac16127d51a34fd56bf1", "target": 1, "func": "void qemu_net_queue_purge(NetQueue *queue, NetClientState *from)\n\n{\n\n    NetPacket *packet, *next;\n\n\n\n    QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) {\n\n        if (packet->sender == from) {\n\n            QTAILQ_REMOVE(&queue->packets, packet, entry);\n\n\n            g_free(packet);\n\n        }\n\n    }\n\n}", "idx": 6951, "substitutes": {"queue": ["forced", "journal", "config", "archive", "database", "processor", "worker", "question", "menu", "channel", "list", "Q", "q", "bar", "select", "connection", "required", "server", "ue", "dq", "port", "module", "complete", "profile", "quote", "league", "que", "manager", "console", "Queue", "store", "buffer", "command", "pool", "line", "ques", "grid", "table", "quit", "job", "test", "sequence", "qa", "loop", "cue", "frame", "batch"], "from": ["fr", "starting", "os", "old", "bound", "foreign", "form", "without", "origin", "org", "to", "sent", "component", "str", "founder", "or", "st", "with", "From", "about", "before", "source", "of", "name", "info", "new", "now", "end", "after", "star", "initial", "owner", "as", "user", "start", "by", "er"], "packet": ["packup", "packacket", " packacket", "ppup", "octel", "packageel", "packageET", "ppel", "PackET", "packsacket", "Packacket", "compel", "Packet", "packsum", "octet", "octup", "ppET", "compum", " Packet", " Packacket", "packum", " packup", " packum", "ppet", " Packel", "packel", "packageet", "packsel", "packce", "octacket", " Packce", "compet", " packce", "ppce", "packageacket", "Packel", " packET", " packel", "octET", "packET", "ppacket", "packset", "compacket"], "next": ["ptr", "key", "entry", "ng", "fr", "prev", " entry", "inner", "tmp", "sec", "nt", "future", "path", " NEXT", "node", "set", "ne", "chain", "link", "Next", "nr", "net", "response", "ner", "network", "member", "new", "this", "after", "line", "page", "sequence", "window", "nd", "seq", "nl", "reply", "er", "last"]}}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,\n\n                                   size_t datalen)\n\n{\n\n    ssize_t ret = gnutls_read(*session, data, datalen);\n\n    if (ret < 0) {\n\n        if (ret == GNUTLS_E_AGAIN) {\n\n            errno = EAGAIN;\n\n        } else {\n\n            errno = EIO;\n\n        }\n\n        ret = -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 6953, "substitutes": {"session": ["Session", "view", "ess", "task", "conn", "api", "common", "sp", "brain", "shared", "parent", "account", "connection", "tab", "server", "set", "version", "j", "lock", "site", "state", "bind", "sid", "connect", "ession", "binding", "store", "process", "test", "window", "client", "route", "local", "se", "lib", "close"], "data": ["rew", "json", "t", "load", "d", "mu", "image", "ad", "DATA", "reader", "partial", "pad", "Data", "package", "read", "empty", "dat", "size", "ns", "bytes", "def", "buf", "buffer", "text", "ata", "da", "new", "sample", " DATA", "rel", "raw", "accept", "window", "message", "block", "input", "batch"], "datalen": ["dalun", "daltength", " dalen", "Dalize", "dalize", "dalten", "dale", "dallen", " datalize", "Datalength", " dalength", "damelize", "dalength", "dalen", "Datalun", "datalize", " datalength", "damelen", "damelun", "dallength", "Dalun", " dalize", "Datalize", " dale", "dalte", "datalun", " datale", "dallun", "dalle", "dallize", "datalength", "daltize", "datale", "Dalen", "Datalen", "Dalength", "damelength"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int slice_end(AVCodecContext *avctx, AVFrame *pict)\n\n{\n\n    Mpeg1Context *s1  = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n\n\n    if (!s1->mpeg_enc_ctx_allocated || !s->current_picture_ptr)\n\n        return 0;\n\n\n\n    if (s->avctx->hwaccel) {\n\n        if (s->avctx->hwaccel->end_frame(s->avctx) < 0)\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"hardware accelerator failed to decode picture\\n\");\n\n    }\n\n\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration)\n\n        ff_xvmc_field_end(s);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    /* end of slice reached */\n\n    if (/* s->mb_y << field_pic == s->mb_height && */ !s->first_field) {\n\n        /* end of image */\n\n\n\n        ff_er_frame_end(&s->er);\n\n\n\n        ff_MPV_frame_end(s);\n\n\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            int ret = av_frame_ref(pict, &s->current_picture_ptr->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->current_picture_ptr);\n\n        } else {\n\n            if (avctx->active_thread_type & FF_THREAD_FRAME)\n\n                s->picture_number++;\n\n            /* latency of 1 frame for I- and P-frames */\n\n            /* XXX: use another variable than picture_number */\n\n            if (s->last_picture_ptr != NULL) {\n\n                int ret = av_frame_ref(pict, &s->last_picture_ptr->f);\n\n                if (ret < 0)\n\n                    return ret;\n\n                ff_print_debug_info(s, s->last_picture_ptr);\n\n            }\n\n        }\n\n\n\n        return 1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 6956, "substitutes": {"avctx": [" avcontext", "vjac", "avclient", "wavctx", "avkt", "afcontext", "vrctx", "vrcmp", "vcp", "averclient", "wavcontext", "afctx", " avtmp", "vrcontext", "vrtx", " avpath", "wavctl", "aptx", "avepath", "averpath", "aveaddr", "afconn", "avjac", "apjac", "avetx", " avkt", "avaddr", "auaddr", " avctl", "avcmp", "aftx", "svcp", "avecp", "afcp", "avpath", " avtx", "svcontext", "aveconn", "avectx", "avctl", "avejac", " avclient", "aveclient", "avercp", "wavkt", "svctx", "apcp", "aftmp", "avcp", " avconn", "auctx", "aujac", "avectl", "avconn", "apctx", "AVaddr", "avercontext", "autx", "avcontext", "avtx", "vtx", "avertmp", "averctx", "avtmp", "svconn", "avekt", "avecontext", "AVjac", "vctx", "AVtx", "AVctx", " avcp", " avcmp", "afcmp"], "pict": ["phot", "isch", "phys", "pkg", "pic", "fi", "hun", " picture", "pai", "ksh", "eric", "pit", "ctx", " img", "bug", "Pic", "txt", "pas", "phy", "Picture", "png", "sci", "lot", "camera", "mat", "hog", " pic", "ht", "pres", "hist", "act", "aunt", "pain", "jp", "cam", "stat", "capt", "Pict", "pl", "seq", "iz", "fig", "gif", "riot", "feat", "hot", "virt", "picture", "shit", "img", "fx"], "s1": ["ss1", " s01", "sts11", "wsone", "sts2", "ps2", "s01", "ss01", "gsone", "cs2", "ss2", " sul", "sul", "s2", "gs1", "gs2", " s11", "ssone", " s2", "s11", "ws2", "gs01", "cs1", "stsone", "ws11", " sone", "csul", "psul", "sone", "sts1", "ps1", "ws1"], "s": ["p", "conf", "l", "sl", "self", "ns", "sq", "ses", "gs", "y", "stats", "comments", "its", "ims", "c", "settings", "n", "qs", "S", "a", "sp", "r", "ps", "vs", "ins", "ctx", "w", "less", "ss", "h", "j", "changes", "i", "js", "b", "sts", "ts", "stat", "has", "simple", "bits", "fs", "sis", "args", "sb", "us", "als", "ats", "sys", "states", "sports", "details", "is", "f", "d", "news", "ports", "aws", "bs", "scl", "rs", "m", "acs", "bis", "cs", "as", "ls", "t", "os", "ess", "ds", "ms", "v", "spec", "ies", "comm", "hs", "g", "pers", "ties", "es", "sv", "aunts", "parts", "sw"], "xvmc_acceleration": ["xvmc_maccelation", "xvmc_accelation", "xvmc_maccelometer", "xvmc_acnowometer", "xvmc_maccelration", "xvmc_acceling", "xvmc_accelerration", "xvmc_maccelerration", "xvmc_accelration", "xvmc_macceleration", "xvmc_maccelering", "xvmc_accelometer", "xvmc_macceling", "xvmc_aclimation", "xvmc_acnowration", "xvmc_aclimration", "xvmc_acliming", "xvmc_acnowation", "xvmc_accelering", "xvmc_aclimometer", "xvmc_accelerometer", "xvmc_acnowing", "xvmc_maccelerometer"], "picture_number": [" picture_value", " picture_num", "picture_sequence", "picturepovalue", " picture_sequence", "picture_num", "pictureposequence", "pictureponum", "pictureponumber", "picture_value"]}}
{"project": "FFmpeg", "commit_id": "d82eccea2bf905cd51889954658f4e7f64876df8", "target": 1, "func": "static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,\n\n                                                    int16_t *block, int n)\n\n{\n\n    int level, i, j, run;\n\n    RLTable *rl = &ff_rl_mpeg1;\n\n    uint8_t * const scantable = s->intra_scantable.permutated;\n\n    const int qscale          = s->qscale;\n\n    OPEN_READER(re, &s->gb);\n\n    i = -1;\n\n\n\n    // special case for first coefficient, no need to add second VLC table\n\n    UPDATE_CACHE(re, &s->gb);\n\n    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {\n\n        level = (3 * qscale) >> 1;\n\n        if (GET_CACHE(re, &s->gb) & 0x40000000)\n\n            level = -level;\n\n        block[0] = level;\n\n        i++;\n\n        SKIP_BITS(re, &s->gb, 2);\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            goto end;\n\n    }\n\n\n\n    /* now quantify & encode AC coefficients */\n\n    for (;;) {\n\n        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);\n\n\n\n        if (level != 0) {\n\n            i += run;\n\n            j  = scantable[i];\n\n            level = ((level * 2 + 1) * qscale) >> 1;\n\n            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n\n            SKIP_BITS(re, &s->gb, 1);\n\n        } else {\n\n            /* escape */\n\n            run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);\n\n            UPDATE_CACHE(re, &s->gb);\n\n            level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);\n\n\n\n            i += run;\n\n            j  = scantable[i];\n\n            if (level < 0) {\n\n                level = ((-level * 2 + 1) * qscale) >> 1;\n\n                level = -level;\n\n            } else {\n\n                level = ((level * 2 + 1) * qscale) >> 1;\n\n            }\n\n        }\n\n\n\n        block[j] = level;\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            break;\n\n        UPDATE_CACHE(re, &s->gb);\n\n    }\n\nend:\n\n    LAST_SKIP_BITS(re, &s->gb, 2);\n\n    CLOSE_READER(re, &s->gb);\n\n    s->block_last_index[n] = i;\n\n    return 0;\n\n}\n", "idx": 6972, "substitutes": {"s": ["p", "conf", "times", "bes", "ains", "ns", "gs", "stats", "results", "comments", "its", "ims", "c", "settings", "qs", "S", "dev", "a", "r", "re", "ps", "ins", "vs", "serv", "ss", "h", "tes", "changes", "js", "b", "sts", "ts", "ops", "has", "fs", "args", "sb", "als", "ats", "sys", "details", "is", "d", "events", "bs", "scl", "sg", "rs", "e", "m", "cs", "as", "ls", "t", "os", "ds", "ms", "set", "se", "comm", "hs", "ssl", "rates", "g", "es", "res", "sv", "parts", "params"], "block": ["commit", "pack", "Block", "label", "list", "channel", "scan", "field", "check", "map", "w", "cl", "set", "lock", "chain", "word", "group", "mem", "blocks", "bl", "range", "type", "ref", "buffer", "row", "rec", "record", "line", "bit", "unit", "byte", "number", "bin", "box", "ack", "load", "frame", "out"], "n": ["no", "d", "l", "v", "r", "w", "en", "ry", "ne", "lock", "ns", "b", "name", "g", "ner", "rn", "e", "un", "rec", "m", "line", "N", "x", "c", "ran", "z"], "level": ["key", "quality", "id", "l", "volume", "condition", "error", "q", "call", "diff", "hi", "VEL", "where", "lvl", "layer", "low", "row", "loop", "lo", "count", "ler", "equal", "ose", "h", "LC", "index", "zero", "ale", "len", "priority", "lower", "LE", "total", "top", "cost", "limit", "debug", "ind", "high", "lc", "change", "version", "ld", "depth", "lock", "size", "group", "state", "point", "roll", "type", "command", "print", "te", "number", "goal", "pe", "local", "go", "fail", "le", "Level", "length", "position", "val", "time", "levels", "vel", "info", "role", "trace", "g", "console", "step", "status", "variable", "line", "bit", "scale", "global", "test", "frame"], "i": ["ia", "t", "li", "ei", "p", "ori", "ki", "limit", "bi", "is", "f", "api", "l", "ii", "v", "ini", "r", "mi", "ix", "it", "list", "ic", "q", "z", "hi", "uri", "si", "di", "gi", "io", "in", "ri", "ip", "index", "info", "g", "ui", "iu", "multi", "ij", "ir", "y", "xi", "zi", "e", "ci", "ti", "m", "iat", "iri", "loop", "ai", "pi", "im", "x", "I", "phi", "c", "cli", "start", "u", "batch"], "j": ["json", "fr", "dj", "bi", "f", "jj", "l", "ind", "v", "r", "jl", "it", "q", "jc", "k", "br", "o", "lock", "bs", "js", "ji", "jump", "ret", "b", "index", "g", "pr", "ij", "row", "kj", "y", "jp", "uj", "rel", "res", "ja", "job", "x", "J", "pos", "z", "out"], "run": ["rc", "init", "fail", "runs", "running", "no", "nil", "rm", "play", "r", "Run", "rr", "pass", "pre", "call", "change", "con", "fun", "set", "UN", "ra", "lock", "ru", "in", "index", "err", "name", "step", "roll", "range", "ref", "row", "new", "len", "end", "un", "record", "rel", "runner", "une", "line", "try", "loop", "pair", "win", "round", "seq", "update", "bin", "thin", "skip", "ran", "add", "go", "load", "pos", "out", "grow"], "rl": ["rc", "lb", "lf", "lp", "ll", "raf", "l", "kr", "rw", "lr", "r", "rr", "rh", "ra", "vr", "dl", "sr", "rg", "ssl", "rx", "rs", "rf", "gb", "rn", "rol", "rel", "arl", "RL", "lv", "rin", "ro", "ls", "nl", "hl", "rt", "rb", "tl"], "scantable": [" scannabe", "scantsabe", "scandtable", "scarenttable", "ScANTabe", "scandable", "scantiable", "ScANTable", "scANTiable", "scentatable", "scantsTable", "scantTable", "scantabe", "scANTable", "scANTabe", "scarentiable", "scANTTable", "ScANTability", "scannable", "scANTability", "scanntable", "scandabe", "Scantability", "scANTables", " scantabe", "scandables", "scANTtable", "ScANTtable", " scannatable", " scanttable", "scarentable", "Scantabe", "scantsable", "scanttable", "ScANTTable", "ScantTable", "scarentability", "Scanttable", "Scantiable", "scantables", "scentabe", " scantatable", "scantatable", " scanntable", "ScANTables", "Scantables", " scannable", "Scantable", "ScANTiable", "scantability", "scentable", "scandiable", "scANTatable", "scantsables", "scandTable", "scannatable", "scenttable", "scandability", "scannabe"]}}
{"project": "FFmpeg", "commit_id": "b853cfe7eaf13b7d4ff3ceba7098544ccc049df8", "target": 0, "func": "static void stream_close(VideoState *is)\n\n{\n\n    VideoPicture *vp;\n\n    int i;\n\n    /* XXX: use a special url_shutdown call to abort parse cleanly */\n\n    is->abort_request = 1;\n\n    SDL_WaitThread(is->read_tid, NULL);\n\n    SDL_WaitThread(is->refresh_tid, NULL);\n\n    packet_queue_destroy(&is->videoq);\n\n    packet_queue_destroy(&is->audioq);\n\n    packet_queue_destroy(&is->subtitleq);\n\n\n\n    /* free all pictures */\n\n    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {\n\n        vp = &is->pictq[i];\n\n#if CONFIG_AVFILTER\n\n        avfilter_unref_bufferp(&vp->picref);\n\n#endif\n\n        if (vp->bmp) {\n\n            SDL_FreeYUVOverlay(vp->bmp);\n\n            vp->bmp = NULL;\n\n        }\n\n    }\n\n    SDL_DestroyMutex(is->pictq_mutex);\n\n    SDL_DestroyCond(is->pictq_cond);\n\n    SDL_DestroyMutex(is->subpq_mutex);\n\n    SDL_DestroyCond(is->subpq_cond);\n\n    SDL_DestroyCond(is->continue_read_thread);\n\n#if !CONFIG_AVFILTER\n\n    sws_freeContext(is->img_convert_ctx);\n\n#endif\n\n    av_free(is);\n\n}\n", "idx": 6997, "substitutes": {"is": ["isc", "os", "oss", "ists", "ms", "id", "news", "ps", "it", "ic", "isf", "ics", "ism", "tis", "ish", "iss", "isal", "ist", "or", "in", "isi", "bs", "ris", "js", "mis", "ns", "iris", "il", "info", "isin", "are", "rs", "does", "rest", "es", "has", "IS", "bits", "fs", "its", "bis", "sis", "ais", "cs", "ims", "irm", "ois", "was", "dis", "us", "as", "parts", "\u00eds", "isl", "lis", "s", "ls", "isa", "vis", "sys", "Is"], "vp": ["tif", "ptr", "mpeg", "cp", "p", "rpm", "pkg", "cv", "lp", "vc", "v", "vim", "tml", "vs", "vert", "mp", "qv", "vg", "ev", "tap", "wp", "txt", "vv", "VB", "phy", "orp", "nv", "pty", "vr", "pt", "px", "resp", "vP", "pb", "prov", "fp", "tp", "vm", "jp", "avi", "dp", "VO", "iv", "cmp", "gp", "verb", "conv", "esp", "sv", "bp", "expr", "VP", "csv", "lv", "cmd", "video", "xp", "vt", "av", "ulp", "uv"], "i": ["key", " m", "init", "t", "li", "p", " multi", "sim", "ki", "fi", "bi", "f", "ind", "v", "ii", " ni", "l", "mi", "ix", " bi", "me", "it", "ic", "my", "\u0438", "asi", "si", "di", "j", "gi", "in", "iq", "ip", "ex", "ie", "ji", "index", "name", "point", "g", " v", "multi", "ui", "iu", "xi", "y", "ij", "zi", "iter", "print", "e", "ti", "ci", "m", "ai", "pi", "im", " j", "ims", "x", "I", "phi", "qi", "us", "c", "n", "go", "u", " ii", "batch"]}}
{"project": "FFmpeg", "commit_id": "560b10a6c3627cccf6735170d370cf9e3d38e805", "target": 1, "func": "static void init_gain_table(COOKContext *q) {\n\n    int i;\n\n    q->gain_size_factor = q->samples_per_channel/8;\n\n    for (i=0 ; i<23 ; i++) {\n\n        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,\n\n                               (1.0/(double)q->gain_size_factor));\n\n    }\n\n    memset(&q->gain_copy, 0, sizeof(COOKgain));\n\n    memset(&q->gain_current, 0, sizeof(COOKgain));\n\n    memset(&q->gain_now, 0, sizeof(COOKgain));\n\n    memset(&q->gain_previous, 0, sizeof(COOKgain));\n\n}\n", "idx": 6999, "substitutes": {"q": ["entry", "gm", "t", "query", "pp", "p", "co", "conf", "cp", "ch", "pkg", "qq", "form", "tt", "config", "f", "v", "r", "question", "quant", "Q", "pg", "rl", "z", "check", "w", "k", "dq", "req", "ry", "qu", "comm", "h", "ue", "iq", "eq", "requ", "sq", "info", "y", "cf", "ck", "db", "m", "quest", "aq", "etc", "quit", "qa", "qi", "qt", "c", "queue", "gr", "cal", "qs", "hl", "add", "er", "out"], "i": ["key", "p", "id", "ii", "ini", " pi", "it", "my", "hi", "di", "gi", "y", "ci", "ami", " j", "ims", "qi", "cli", " ii", " I", "ei", "yi", "ix", "ic", "si", "oi", "j", "index", "zi", "try", "pi", "x", "phi", "us", "is", "ind", "mi", "gu", " e", "span", "ri", "chain", "ip", "ex", "multi", "e", "ti", "m", "ai", "im", "sequence", " mi", "I", "spin", "out", " m", "init", "li", "sim", "ki", "fi", "bi", "v", "me", "\u0438", " x", "uri", "o", "in", "info", "g", "ui", "iu", "xi", "ij", "status", "client", "batch"]}}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void qpa_fini_out (HWVoiceOut *hw)\n\n{\n\n    void *ret;\n\n    PAVoiceOut *pa = (PAVoiceOut *) hw;\n\n\n\n    audio_pt_lock (&pa->pt, AUDIO_FUNC);\n\n    pa->done = 1;\n\n    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);\n\n    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);\n\n\n\n    if (pa->s) {\n\n        pa_simple_free (pa->s);\n\n        pa->s = NULL;\n\n    }\n\n\n\n    audio_pt_fini (&pa->pt, AUDIO_FUNC);\n\n    g_free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n}\n", "idx": 7004, "substitutes": {"hw": ["vp", "phys", "rpm", "pkg", "haw", "whe", "mph", "wx", "xa", "ha", "hub", "hz", "aw", "hip", "wa", "fw", "w", "ether", "phy", "rh", "wk", "ew", "wo", "aws", "qu", "wy", "hog", "ht", "hs", "him", "we", "wd", "wu", "hist", "wi", "nw", "vo", "aaaa", "hh", "hop", "xp", "iw"], "ret": ["pet", "rep", "et", "elt", "reset", "gt", "tmp", "RET", "rm", "arr", "nt", "re", "Ret", "ft", "rets", "txt", "ply", "ruby", "val", "rem", "mem", "mt", "resp", "result", "par", "pret", "ref", "repl", "print", "pat", "res", "vals", "aux", "alt", "reply", "nl", "rt", "vt", "reg"], "pa": ["ka", "pet", "wan", "ace", "pp", "rep", "p", "pkg", "ea", "pai", "a", "whe", "ena", "opa", "ha", "pc", "Pa", "mp", "ping", "ada", "ppa", "pas", "aka", "phy", "pm", "ga", "PA", "jo", " PA", "pt", "apa", "qua", "fa", "ara", "ap", "quote", "po", "asia", "que", "pol", "pb", "paste", "sa", "ma", "ape", "jp", "eta", "pse", "pu", "ja", "pi", "pha", "au", "qa", "ta", "ppo", "pe", "pan", "oa", "pee", "ota"]}}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_device_init(SCSIDevice *s)\n\n{\n\n    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);\n\n    if (sc->init) {\n\n        return sc->init(s);\n\n    }\n\n    return 0;\n\n}\n", "idx": 7017, "substitutes": {"s": ["t", "os", "p", "S", "sports", "ds", "south", "is", "d", "ms", "v", "sp", "r", "ps", "spec", "ysis", "w", "less", "ss", "si", "h", "aws", "st", "i", "js", "ns", "sd", "b", "sq", "sts", "rs", "gs", "y", "ts", "its", "sv", "cs", "ims", "sb", "c", "ls", "ats", "qs", "n"], "sc": ["tc", "rc", "isc", "sch", "scrib", "pic", "sec", "SC", "esc", "sup", "usc", "sp", "ec", "lc", "pc", "dc", "Sc", "cl", "cc", "ss", "sci", "asc", "osc", "gc", "sic", "cr", "anc", "sq", "psc", "scl", "uc", "cam", "ca", "disc", "sv", "cs", "desc", "bc", "sche", "c", "nc", "mc", "mic"]}}
{"project": "qemu", "commit_id": "aaa0eb75e2e56d483c89731a447c999985713b43", "target": 0, "func": "static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,\n\n                             int nb_sectors, int dirty)\n\n{\n\n    int64_t start, end;\n\n    unsigned long val, idx, bit;\n\n\n\n    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n\n\n    for (; start <= end; start++) {\n\n        idx = start / (sizeof(unsigned long) * 8);\n\n        bit = start % (sizeof(unsigned long) * 8);\n\n        val = bs->dirty_bitmap[idx];\n\n        if (dirty) {\n\n            val |= 1 << bit;\n\n        } else {\n\n            val &= ~(1 << bit);\n\n        }\n\n        bs->dirty_bitmap[idx] = val;\n\n    }\n\n}\n", "idx": 7019, "substitutes": {"bs": ["ubs", "uts", "bos", "bps", "ds", "bh", "bm", "aus", "bes", "ms", "vs", "ps", "aos", "hz", "bas", "ss", "iss", "js", "ns", "hs", "b", "BS", "pb", "sts", "bl", "rs", "gs", "ts", "cks", "obs", "lbs", "acs", "bits", "fs", "its", "bis", "bp", "cs", "eb", "sb", "ls", "bsp", "s", "qs", "sys", "bc"], "sector_num": ["sector2cum", "sector2mon", "ector_Num", "sector2Num", "sector1Num", "sector_Num", "ector_num", "sector_cum", "ector_nom", "sectorationnum", "sector1num", "ector_number", "sectorityNum", "sectorationnumber", "ector_mon", "sector_nom", "sector_number", "ector_on", "sectoritynum", "sector2number", "sector1mon", "sector_mon", "sectorationcum", "sector1number", "sectorationNum", "sector2num", "sectorityon", "sector_on", "ector_cum", "sectoritynom"], "nb_sectors": ["nb_pectors", "nb_pecs", "nb_vectors", "nb_peors", "nb_seors", "nb_sesors", "nb_speors", "nb_vegments", "nb_vecs", "nb_sesllers", "nb_specs", "nb_spectors", "nb_vellers", "nb_spegments", "nb_sesplanes", "nb_sellers", "nb_pellers", "nb_veors", "nb_secs", "nb_veplanes", "nb_sesctors", "nb_peplanes", "nb_pegments", "nb_segments", "nb_seplanes"], "dirty": ["forced", "kept", "clean", " Dirty", "weak", "deep", "checked", "done", "fresh", "qualified", "graded", "pretty", "stable", "need", "required", "my", "broken", "visible", "needed", "valid", "always", "draft", "important", "confirmed", "backed", "mounted", "atomic", "initialized", "friendly", "finished", "locked", "status", "dollar", "missing", "rounded", "marked", " dirt", "modified", "meta", "magic", "hidden", "irty", "managed"], "start": ["ST", "get", "init", "entry", "starting", "art", "be", "origin", "id", "d", "ind", "sp", "it", "path", "check", "offset", "trans", "ish", "ist", "axis", "set", "st", "gate", "read", "pt", "next", "in", "before", "space", "time", "i", "stop", "root", "index", "begin", "shift", "step", "point", "range", "wind", "rest", "iter", "rank", "Start", "match", "boot", "print", "try", "addr", "part", "x", "import", "client", "first", "from", "pos", "input", "pre", "seek", "add"], "end": ["bound", "max", "limit", "ended", "except", "org", "length", "fin", "hend", "append", "send", "ext", "offset", "ep", "ff", "en", "ue", "until", "eng", "size", "ex", "stop", "est", "begin", "range", "ape", "len", "e", "edge", "END", "ort", "after", "ending", "ent", "nd", "End", "then", "last", "event", "close"], "val": ["bo", " el", "VAL", " tx", "elt", "lit", "qual", "dev", "eval", " ver", "sel", " eval", "v", " var", "ctx", "it", " ptr", "serv", " x", "sl", "crit", "prop", "valid", " bin", "pt", "px", "pal", "ret", "bal", "oval", " lit", "def", "point", " value", "pol", " v", " Val", " vec", "pr", "bl", "xy", " valid", "stat", "rol", "rel", " arg", "vals", "ival", " oval", "test", "pl", "var", "x", "tx", "als", " vol", " ty", "vol", "cal", " ret", "al", "sol", "vt", "value", "Val", "aval"], "idx": ["indx", "indix", "idnex", "IDix", " idindex", "indxf", " idnex", "idX", "IDex", " idz", " idxf", "edix", "IDx", "edX", "idsX", "idix", "ideix", "idsx", "indz", "kidix", " idix", "idz", "index", "idenex", "idindex", "edz", " idX", "edx", "IDnex", "kidindex", "iddx", "idsex", "idsxf", "idxf", "kiddx", "ideex", "indX", "inddx", "idex", "kidx", " iddx", "indindex", " idex"], "bit": ["bo", "git", "lit", "butt", "ch", "bi", "bt", "id", "BIT", "col", "ut", "it", "board", "bolt", "bug", "offset", "set", "lot", "port", "lock", "bus", "fix", "word", "format", "off", "b", "state", "point", "level", "tag", "bot", "op", "code", "ort", "cond", "Bit", "bits", "cut", "unit", "flag", "bool", "byte", "test", "ac", "mask", "x", "bin", "block", "pos", "batch"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt,\n\n    int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx)\n\n{\n\n    size_t fetched = 0;\n\n    struct iovec *src = pkt->vec;\n\n\n\n    *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM;\n\n\n\n    while (fetched < pkt->virt_hdr.gso_size) {\n\n\n\n        /* no more place in fragment iov */\n\n        if (*dst_idx == NET_MAX_FRAG_SG_LIST) {\n\n            break;\n\n        }\n\n\n\n        /* no more data in iovec */\n\n        if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) {\n\n            break;\n\n        }\n\n\n\n\n\n        dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset;\n\n        dst[*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset,\n\n            pkt->virt_hdr.gso_size - fetched);\n\n\n\n        *src_offset += dst[*dst_idx].iov_len;\n\n        fetched += dst[*dst_idx].iov_len;\n\n\n\n        if (*src_offset == src[*src_idx].iov_len) {\n\n            *src_offset = 0;\n\n            (*src_idx)++;\n\n        }\n\n\n\n        (*dst_idx)++;\n\n    }\n\n\n\n    return fetched;\n\n}\n", "idx": 7027, "substitutes": {"pkt": ["pdu", "spnt", "ppdu", "ppct", "spdu", " pct", "pkg", "dct", "Packet", "pct", "ppconn", " pnt", "pakg", "spct", "payacket", "pnt", "fkt", " pkg", "prkt", "pracket", "Pconn", "Pkt", "prdu", "pakt", "payconn", "paynt", "dkg", "padu", "Pnt", "spacket", "dkt", "dacket", "packet", "ppkt", "prnt", "tdu", "spkt", "facket", "pant", "fdu", "tnt", "tkg", "pconn", "fct", "paykt", "spkg", " pdu", "ppacket", "ppnt", " packet", "tkt"], "src_idx": ["src_docf", "src_Idv", "src_idv", "src_midxc", "src_defk", "src__Idn", "src_IDn", "srcptidxc", "src_idxf", "src_idxes", "src_iterc", "src_idpt", "src_defpt", "src_indxf", "src_idxc", "src_pidex", "src_defl", "src_idey", "srcptmidxc", "src_idez", "srcptmidz", "src_idk", "src_docc", "src_idexc", "srcptmidv", "src_idindex", "src_indf", "src_index", "src_iterx", "src_indexn", "src_midx", "src_ideex", "src_docx", "src_midv", "src_idf", "src_pidx", "src_pidz", "src_defx", "src_IDindex", "src_idex", "src__idindex", "src_indexx", "srcptidv", "src_Idx", "src_idn", "src_indv", "src_ido", "src_idy", "src_infoxc", "src_doco", "src_indl", "src_indpt", "srcptidz", "src_Idn", "src_infov", "src_indk", "src__Idxes", "src_indexxes", "src_infox", "src__Idx", "src_idz", "src_ink", "src_inx", "src__idx", "src_Idindex", "src_Idxf", "src_IDxes", "src__idn", "src__idxes", "src_indz", "src_idev", "src_idc", "src_iterf", "src__Idindex", "src_midz", "srcptmidx", "src_indexindex", "src_indc", "src_inl", "src_IDx", "src_idl", "src_indy", "src_infoz", "src_Idxes", "src_inpt", "src_pidy", "src_Idy", "src_indx", "srcptidx", "src_indo", "src_itero"], "src_offset": ["src__Offset", "src_extra", "src0len", "rc_extra", "src_base", "src_Offset", "rc_offset", "src_seek", "src_error", " src_error", "src__len", " src_Offset", "src_pos", "src__reset", "rc_len", "img_pos", "img_offset", "src0off", "rc_reset", "srcityoffset", "rc_pos", "src_scroll", "srcitybase", "src0pos", "rc_base", " src_off", "img_scroll", "img_seek", "src__offset", "src_len", "src_off", "srcityOffset", "src_reset", "srcityextra", "rc_off", "src_shift", "rc_Offset", " src_shift", "src0offset", " src_len"], "dst": ["idv", "idest", "iddest", "pdot", "dct", "ddest", "sddest", "dnd", "dest", "pest", "ddst", "dlt", "ppt", "sdst", "pdx", "dddest", "pnd", "dsst", "jest", "dcp", "mcp", "sdcp", "pdst", "Dst", " ddest", "mnd", "mst", "idnd", "Dcp", "Dct", "dx", " dct", "mx", " dx", "dv", "idst", "idpt", "pdnd", "ddv", "sdot", "dot", "jst", "Dv", "ddpt", "mdest", "pst", " dnd", "dslt", "jnd", "jpt", "dpt", "Dpt", "Ddest", "Dlt", "mot", " dot", "dsdest", "Dot", " dlt", "dsct"], "dst_idx": ["dst_Idx", "dst_iterh", "dst_Idn", "dst_idh", "dst_midxs", "dst_fx", "dst_idxc", "dst_midx", "dst_indexsw", "dst_ridw", "dst_inx", "dst_idci", "dst_idm", "dst_ndxs", "dst_ndx", "dst_indexst", "dst_inb", "dst_drci", "dst_idy", "dst_timest", "dst_drx", "dst_idsz", "dst_idez", "dst_midr", "dst_Idst", "dst_idr", "dst_fz", "dst_ndw", "dst_fpx", "dst_idsb", "dst__idz", "dst_pix", "dst_Idl", "dst_indexx", "dst_inr", "dst_timey", "dst_idel", "dst__idr", "dst_pipx", "dst_Idsw", "dst_pidx", "dst_idn", "dst_trz", "dst__idn", "dst__idx", "dst_idsn", "dst_trsw", "dst_pifx", "dst_ridxs", "dst_Idr", "dst_iterx", "dst_indexz", "dst_idxs", "dst_idw", "dst_idsw", "dst_iterst", "dst_pidxc", "dst_iden", "dst_idb", "dst_idz", "dst_timex", "dst_idsx", "dst_midn", "dst_idsr", "dst_drxc", "dst_timeh", "dst_idst", "dst_idfx", "dst_drz", "dst_piz", "dst_ffx", "dst_ridx", "dst_pidz", "dst_idex", "dst_trst", "dst_trx", "dst_idpx", "dst_midw", "dst_ridm", "dst_pidci", "dst_idl", "dst_midb", "dst_Idz", "dst_inn", "dst_ndm", "dst_midm", "dst_itery"], "src": ["ptr", "rc", "sc", "ser", "syn", "pkg", "tmp", "dest", "sec", "sel", "usc", "ins", "rl", "inst", "sub", "txt", "sl", "loc", "str", "cur", "via", "req", "st", "supp", "vr", "source", "proc", "ssl", "usr", "sq", "rx", "comp", "buf", "sys", "sels", "rs", "sn", "obs", "rel", "desc", "sb", "seq", "rob", "hl", "rt", "sur", "img", "bc"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lsi_ram_write(void *opaque, target_phys_addr_t addr,\n\n                          uint64_t val, unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n    uint32_t newval;\n\n    uint32_t mask;\n\n    int shift;\n\n\n\n    newval = s->script_ram[addr >> 2];\n\n    shift = (addr & 3) * 8;\n\n    mask = ((uint64_t)1 << (size * 8)) - 1;\n\n    newval &= ~(mask << shift);\n\n    newval |= val << shift;\n\n    s->script_ram[addr >> 2] = newval;\n\n}\n", "idx": 7033, "substitutes": {"opaque": ["patile", "Opempty", "Opacity", "Opatile", " opempty", "paque", "opllay", "Opaque", "oplque", " oposter", "oplay", "oplempty", "oplaque", "poster", "Oplay", "opque", "Oposter", "opatile", " opatile", " opque", "opempty", "oposter", "opacity", " oplay", " opacity", "Opque", "pacity"], "addr": ["ptr", "dr", "order", "inter", "work", "conn", "id", "ind", "arr", "r", "att", "ix", "ctx", "sp", "url", "ad", "hash", "address", "ag", "obj", "loc", "offset", "trans", "gate", "pad", "adr", "align", "attr", "i", "arp", "off", "asm", "state", " address", "index", "nr", "at", "store", "ref", "alloc", "wid", "ord", "now", "len", "coord", "help", "hw", "ac", "x", "num", "tx", "Address", "src", "arm", "grad", "pos", "ack", "add", "urg", "block", "err", "cmd"], "val": ["VAL", " tx", "p", "elt", "eval", "sel", " eval", "v", "arg", "arr", "it", "ul", "loc", " mem", " msg", "valid", "mem", " aval", " value", "pol", " v", "bl", " Val", "ref", "res", " arg", "ival", "vec", " oval", "vals", " res", "bit", "test", "x", "tx", " vol", "vol", "am", " ret", "al", "value", "Val"], "size": ["max", "Size", "weight", "sum", "SIZE", "length", "ize", "scope", "address", "send", "offset", "style", "space", "index", "name", "fee", "sh", "type", "height", "len", "sn", "scale", "unit", "zone", "window", "number", "num", "count", "message", "n", "pos", "start", "shape"], "s": ["t", "S", "p", "ds", "is", "sp", "r", "ps", "spec", "z", "sl", "less", "set", "ss", "j", "st", "o", "comm", "h", "bs", "i", "ns", "js", "hs", "ssl", "asm", "sq", "g", "ses", "sts", "rs", "store", "gs", "y", "status", "ts", "sn", "es", "stats", "m", "fs", "sis", "sv", "sb", "c", "ls", "n", "sys", "se", "sw"], "newval": ["Newvalue", " newv", "newVal", "fresheval", "nextval", "nexteval", "freshbal", "nextserv", "NEWvalue", "oldvalue", "Newserv", "Newval", "newv", " newbal", "NEWbal", " newvalue", "nextVal", "NEWeval", " newVal", " neweval", "nextvalue", "NEWstate", "nextstate", "freshVal", "freshval", "oldVal", "NEWVal", "newvalue", "newserv", "Newv", " newstate", "oldval", "oldv", "NEWval", " newserv", "neweval", "newstate", "NewVal", "newbal"], "mask": ["flags", "hide", "key", " masked", "conf", " masks", "share", "mark", "pack", "form", "weight", "sk", "mk", "ms", "sum", "filter", "label", "hash", "Mask", "ask", "map", "mount", "hold", "module", "miss", "lock", "gate", "mt", "clear", "mac", "allow", "sign", "mb", "zero", "black", "ma", "match", "m", "cond", "bit", "scale", "flag", "acl", "tile", "window", "alph", "block", "box", "shape"], "shift": ["Shift", "ptr", "share", "half", "ctr", "sup", "ind", "length", "ix", "hash", " offset", "address", "map", "diff", "loc", "offset", " align", "aj", "sub", "delay", "axis", "j", "ress", "handle", "pad", " shr", "align", "sort", "off", " step", "index", "sq", "slice", "step", "sh", "shr", "hift", "side", "scale", "transform", "window", "distance", "count", "push", "set", "start", "pos", "add", "sleep", "seek"]}}
{"project": "FFmpeg", "commit_id": "7117547298b13d6f52a20d6a62a27dc0a1c3e263", "target": 1, "func": "static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)\n\n{\n\n    int ret, i;\n\n\n\n    frame->width  = s->avctx->width  + 2;\n\n    frame->height = s->avctx->height + 2;\n\n    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)\n\n        return ret;\n\n    for (i = 0; frame->data[i]; i++) {\n\n        int offset = frame->linesize[i] + (1 << sps->pixel_shift);\n\n        frame->data[i] += offset;\n\n    }\n\n    frame->width  = s->avctx->width;\n\n    frame->height = s->avctx->height;\n\n\n\n    return 0;\n\n}\n", "idx": 7048, "substitutes": {"s": ["os", "S", "ess", "conf", "ds", "details", "is", "times", "ms", "v", "ps", "ctx", "ins", "ies", "sl", "gets", "less", "fps", "ss", "iss", "events", "aws", "comm", "ains", "bs", "mods", "ns", "js", "ex", "hs", "sq", "sys", "g", "ses", "sts", "rs", "gs", "ts", "ops", "bits", "fs", "its", "aunts", "cs", "ims", "parts", "c", "als", "ls", "aps", "n", "ats", "qs"], "frame": ["fr", "view", "stroke", "fram", "filter", "frames", "file", "error", "one", "show", "package", "response", "row", "remote", "page", "project", "queue", "message", "picture", "rame", "event", "ace", "data", "draw", "list", "w", "profile", "word", "buffer", "new", "ce", "session", "block", "context", "total", "load", "request", "wrapper", "reset", "iframe", "f", "component", "fb", "image", "version", "layout", "lock", "source", "state", "feature", "point", "process", "print", "e", "head", "sequence", "library", "out", "close", "scene", "cast", "element", "form", "use", "to", "channel", "force", "object", "module", "complete", "info", "trace", "console", "Frame", "store", "front", "cf", "face", "line", "base", "zone", "window", "update", "video", "render"], "sps": ["Spe", "csss", "sepse", "SPS", "sbs", " sss", "spe", " sPS", " spse", "Sps", "sePS", " sbs", "csps", "sss", "sPS", "csPS", "sebs", "Sss", "seps", "spse", "cspe", " spe"], "ret": ["t", "reset", "elt", "gt", "no", "tmp", "f", "ll", "RET", "v", "r", "re", "nt", "cont", "Ret", "it", "ft", "rets", "txt", "red", "ext", "val", "j", "rem", "mt", "resp", "result", "def", "err", "pret", "ber", "ref", "len", "print", "res", "det", "try", "ter", "flag", " Ret", "rt", "alt", "out"], "i": ["key", "init", "ei", "li", "p", "sim", "fi", "bi", "is", "f", "id", "ind", "v", "ii", "l", "ini", "mi", "ix", "it", "ic", "asi", "any", "uri", "set", "si", "oi", "j", "di", "o", "gi", "span", "ri", "u", "chain", "ip", "index", "info", "ui", "multi", "iu", "ij", "xi", "zi", "status", "print", "ci", "ti", "m", "iri", "iat", "ai", "pi", "im", "ims", "ni", "x", "I", "phi", "qi", "batch"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "static void avc_luma_vt_16w_msa(const uint8_t *src, int32_t src_stride,\n\n                                uint8_t *dst, int32_t dst_stride,\n\n                                int32_t height)\n\n{\n\n    int32_t loop_cnt;\n\n    int16_t filt_const0 = 0xfb01;\n\n    int16_t filt_const1 = 0x1414;\n\n    int16_t filt_const2 = 0x1fb;\n\n    v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8;\n\n    v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r;\n\n    v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l;\n\n    v16i8 src65_l, src87_l;\n\n    v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l;\n\n    v16u8 res0, res1, res2, res3;\n\n    v16i8 filt0, filt1, filt2;\n\n\n\n    filt0 = (v16i8) __msa_fill_h(filt_const0);\n\n    filt1 = (v16i8) __msa_fill_h(filt_const1);\n\n    filt2 = (v16i8) __msa_fill_h(filt_const2);\n\n\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n    ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_r, src21_r, src32_r, src43_r);\n\n    ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_l, src21_l, src32_l, src43_l);\n\n\n\n    for (loop_cnt = (height >> 2); loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src5, src6, src7, src8);\n\n        src += (4 * src_stride);\n\n\n\n        XORI_B4_128_SB(src5, src6, src7, src8);\n\n        ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_r, src65_r, src76_r, src87_r);\n\n        ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_l, src65_l, src76_l, src87_l);\n\n        out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, filt0, filt1, filt2);\n\n        out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2);\n\n        out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2);\n\n        out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, filt0, filt1, filt2);\n\n        out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2);\n\n        out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2);\n\n        out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2);\n\n        out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2);\n\n        SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5);\n\n        SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7);\n\n        SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5);\n\n        SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7);\n\n        PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l,\n\n                    out3_r, res0, res1, res2, res3);\n\n        XORI_B4_128_UB(res0, res1, res2, res3);\n\n\n\n        ST_UB4(res0, res1, res2, res3, dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n\n\n        src10_r = src54_r;\n\n        src32_r = src76_r;\n\n        src21_r = src65_r;\n\n        src43_r = src87_r;\n\n        src10_l = src54_l;\n\n        src32_l = src76_l;\n\n        src21_l = src65_l;\n\n        src43_l = src87_l;\n\n        src4 = src8;\n\n    }\n\n}\n", "idx": 7066, "substitutes": {"src": ["ptr", "rc", "sc", "seek", "RC", "ser", "syn", "dest", "ctr", "dist", "ind", "cont", "ins", "scan", "sync", "rl", "inst", "serv", "sub", "sl", "ul", "loc", "cur", "st", "supp", "sr", "source", "usr", "rx", "sys", "std", "rs", "img", "tp", "sn", "stat", "iv", "tr", "addr", "sb", "s", "rt", "input", "stream", "sort"], "src_stride": ["src_brIDE", "src_nameIDE", "src_specide", "src_specate", "src_nameride", "src_brude", "src_bride", "src_strade", "src_strate", "src_nameate", "src_strider", "src2brate", "src2brIDE", "src_tride", "src2strate", "src_Strate", "src2brride", "src_striade", "src_strude", "src_brate", "src_StrIDE", "src_trude", "src_brride", "src2bride", "src_striude", "src_Stride", "src_strIDE", "src_specider", "src_brider", "src_brade", "src2stride", "src_nameide", "src_striide", "src_trade", "src_strride", "src_trride", "src2strride", "src_striride", "src_strice", "src_Strider", "src2strIDE", "src_Strride", "src_Strice", "src_brice", "src_specice"], "dst": ["indest", " dput", "inst", "dput", "inest", "Ddest", "ddest", "dest", "Dput", "Dest", " dest", "input", "Dst", " ddest"], "dst_stride": ["dst_trend", "dst_strride", "dst_decade", "dst_strade", "dst_bride", "dst_trade", "dst_strend", "dst_trride", "dst_tride", "dst_decend", "dst_decide", "dst_brend", "dst_decride", "dst_brade", "dst_brride"], "height": ["max", "ctr", "dim", "padding", "resolution", "style", "depth", "read", "size", "chain", "Height", "shift", "step", "std", "buffer", "rank", "scale", "base", "window", "count", "sty", "mode", "angle", "kw", "block", "shape", "grow"], "loop_cnt": ["loop_lctxt", "loop_cst", "loop_lcst", "loop_bcnt", "loop_bctxt", "loop_bcst", "loop_gcst", "loop_gcpt", "loop_gctxt", "loop_lcpt", "loop_lcnt", "loop_ctxt", "loop_cpt", "loop_gcnt", "loop_bcpt"], "src0": ["source0", "source3", "source1", " src00", "rc0", "source2", "src00", "rc3", "source4", "sr1", "rc00", "rc4", "rc1", "sr00", "sr0", "rc2"], "src1": ["source0", "source3", "source1", " src11", "rc01", "src01", "rc0", "source2", " src01", "sys2", "rc3", "source4", "src11", "sys3", "rc4", "rc1", "sys0", "rc2", "sys1", "source11", "source01", "rc11"], "src2": ["source0", "source3", "sourceor", "source1", "srcor", "rc0", "src02", "ser5", "source2", "ser1", "rc3", "ser2", "rcor", "rc4", "rc1", "ser4", " srcor", "rc02", "source5", "rc2", " src02", "rc5", "ser3", "source02", "ser02"], "src3": ["source3", "source0", "rc23", "sc03", "rc03", " src23", "rc0", "source2", "rc3", "source4", " src03", "rc4", "sc2", "source23", "src03", "sc3", "source5", "sc5", "rc2", "rc5", "source03", "src23"], "src4": ["source3", "src40", "rc04", "sc6", "source40", "sourceN", "srcN", "rcN", "source2", "rc3", "inst04", "source4", "src44", "inst6", " src44", "inst4", "rc4", "inst2", "source44", "sc4", "rc40", "sc2", " srcN", "src04", "source5", "rc6", "rc2", "rc5", "sc04", " src40", "rc44"], "src5": ["source5", "inst5", "src25", "ser5", "src05", "inst65", "source05", "inst25", "inst05", "ser25", "ser65", "source65", "ser05", "src65", "source25"], "src6": ["inst66", "inst8", "inst7", "rc6", "source66", "source8", "source7", "rc66", "rc8", "rc7", "inst6", "source6", "src66"], "src7": ["rc6", " src13", "source13", "source8", "src13", "rc13", "rc8", "rc7", "source7", "source6"], "src8": ["src9", "src16", "source8", "source7", "rc9", "rc16", "source16", "rc8", "rc7", " src16", "source9", " src9"], "src10_r": ["src90_r", "src90_lr", "src10_lr", "src90_p", "src10_p", "src90_l"], "src32_r": ["src31_R", "src31_l", "src32Yro", "src322R", "src64_ro", "src31_r", "src64_l", "src32_ar", "src32_ro", "src31_ro", "src32Yar", "src32_R", "src32Yl", "src322ro", "src32Yr", "src64_r", "src64_ar", "src322r", "src322l"], "src54_r": ["src03_rb", "src03_l", "src54___rt", "src03_rt", "src54___rb", "src03_r", "src54___l", "src54___r", "src54_rt", "src54_rb"], "src76_r": ["src75_rc", "src76_rb", "src75_rb", "src75_r", "src76_rc", "src75_l"], "src21_r": ["src23_r", "src23_l", "src21_R", "src21_m", "src23_R", "src32_ro", "src23_p", "src32_m", "src21_ro", "src21_p"], "src43_r": ["src43_R", "src43_rel", "src43_p", "src65_p", "src65_h", "src43_h"], "src65_r": ["src65_er", "src45_l", "src45_r", "src65_rb", "src45_rb", "src45_er"], "src87_r": ["src97_p", "src872rs", "src872l", "src87_rs", "src97_rs", "src97_l", "src87_p", "src872r", "src97_r", "src872p"], "src10_l": ["src10_le", "src36_le", "src36_li", "src36_ml", "src10Timeli", "src36_l", "src10_li", "src10Timeml", "src10Timele", "src10_ml", "src10Timel"], "src32_l": ["src10_la", "src32__la", "src32__el", "src32___r", "src10___la", "src10___l", "src32_la", "src32___l", "src32_el", "src32___la", "src32__r", "src10_el", "src10___el", "src32___el", "src32__l", "src10___r"], "src54_l": ["src52_lin", "src54_L", "src54___lp", "src52_lp", "src54___L", "src54_lp", "src54___lin", "src54_lin", "src54___l", "src52_l", "src52_L"], "src76_l": ["src75_le", "src75_L", "src76_kl", "src75_kl", "src75_l", "src76_le", "src76_L"], "src21_l": ["src21_ls", "src48_ls", "src48ingl", "src21ingls", "src48ingr", "src21Plb", "src21_lb", "src21ingl", "src21ingr", "src21inglb", "src48_l", "src21Pls", "src21Pr", "src48inglb", "src48ingls", "src21Pl", "src48_lb", "src48_r"], "src43_l": ["src74_l", "src43_lb", "src74_lb", "src43_L", "src74_li", "src74_L", "src43_li"], "src65_l": ["src20_m", "src20_h", "src65ablem", "src65ablel", "src20_l", "src65_la", "src20_la", "src20ablela", "src65ableh", "src20ableh", "src20ablel", "src20ablem", "src65_h", "src65ablela", "src65_m"], "src87_l": ["src77_r", "src77_ll", "src87___li", "src87___r", "src87_li", "src87___l", "src77_li", "src87_ll", "src77_l", "src87___ll"], "out0_r": ["out10_r", "out10_p", "out0rh", "out0rp", "out10_b", "out0_p", "out0_h", "out0rr", "out0rb", "out10_h", "out0_b"], "out1_r": ["out1_ro", "out5_dr", "out1_dr", "out5_r", "out5_rd", "out1_rd", "out5_ro"], "out2_r": ["out1_rs", "out1_hr", "out2_rs", "out2_hr"], "out3_r": ["out43_n", "out367r", "out367n", "out3_n", "out43_r", "out43_sr", "out367sr", "out367l", "out3_sr", "out43_l"], "out0_l": ["out2_m", "out2_n", "out0_m", "out2_L", "out0_L", "out0_n"], "out1_l": ["out3_m", "out1_m", "out1_b", "out3_b", "out1_w", "out3_w"], "out2_l": ["out2ptm", "out2_m", "out2_e", "out2ptl", "out2_li", "out1_m", "out1_e", "out2ptli", "out1_li", "out2pte"], "out3_l": ["out12_la", "out3___j", "out300l", "out3_pl", "out12___pl", "out12_pl", "out12___l", "out3___pl", "out12_l", "out12_j", "out3_j", "out300j", "out3___l", "out3___la", "out12___la", "out300la", "out12___j", "out3_la", "out300pl"], "res0": ["Res1", "pres1", "Res0", "Res2", "pres2", "pres0"], "res1": ["critone", "crit1", "rand8", "Res8", "Res1", "crit01", "Resone", "crit8", "res01", "randone", "rand1", "rand01", "res8", "resone", "Res01"], "res2": ["loss1", "pres1", " res8", " restwo", "loss8", "loss2", "pres2", "pres8", "losstwo", "prestwo", "res8", "restwo"], "res3": ["err43", " res15", " res8", "err3", "err8", "RES15", "err15", "RES8", "RES43", "res43", "RES3", " res43", "res8", "res15"], "filt0": ["felt1", "ffilter1", "felt2", "viltration2", "flt1", "flet6", "flet2", "vilt0", "filtration1", "ffilter5", "viltration0", "flilt1", "fift6", "flet1", "viltration1", "flt6", "felt5", "filtration0", "flilt0", "vilt5", "filtration2", "fift2", "fift1", "flilt2", "flift0", "ffilter2", "flt2", "felt0", "flift6", "filt6", "ffilter0", "vilt1", "viltration5", "fift0", "flift1", "flilt6", "filt5", "filtration5", "vilt2", "flet0", "flt0", "flift2"], "filt1": [" filt4", " fld4", " fil0", " fil5", "falt5", "faultOne", "filt3", " fldOne", " fil3", "fil3", "filtration1", "filtrationOne", "filtration3", "fond0", " filtOne", "fault4", "fil0", "filtration4", " fil1", "fond3", "fault3", "fil5", " fld3", " filt3", "falt1", "fld4", "fld3", "fil1", "fond5", " filt5", "fond1", "falt0", "filtOne", "filt4", "falt3", "fault1", "filt5", " fld1", "fld1", "fldOne"], "filt2": ["fault2", "vilt3", "facilt4", "faciltration2", "vault1", "filtSecond", "filt3", "vaultL", "fot4", "filtL", "faultL", "filt22", "faltL", "fitt4", "faciltrationSecond", "filtrationSecond", "filtration4", "facilt22", "facilt2", "filtration22", "vault3", "fitt3", "faciltSecond", "fitt1", "fotSecond", "fault3", "fot2", "filtration2", "falt1", "vault2", "faciltration4", "vilt1", "filt4", "falt3", "fault1", "viltL", "fitt2", "faciltration22", "falt2", "fot22", "fitt22", "vilt2", "fittL", "fittSecond"]}}
{"project": "qemu", "commit_id": "6b33f3ae8b79726ef0812597b8a83c3e82d31514", "target": 0, "func": "static int img_commit(int argc, char **argv)\n\n{\n\n    int c, ret, flags;\n\n    const char *filename, *fmt, *cache, *base;\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs, *base_bs;\n\n    bool progress = false, quiet = false, drop = false;\n\n    bool writethrough;\n\n    Error *local_err = NULL;\n\n    CommonBlockJobCBInfo cbi;\n\n    bool image_opts = false;\n\n    AioContext *aio_context;\n\n\n\n    fmt = NULL;\n\n    cache = BDRV_DEFAULT_CACHE;\n\n    base = NULL;\n\n    for(;;) {\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"f:ht:b:dpq\",\n\n                        long_options, NULL);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch(c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case 't':\n\n            cache = optarg;\n\n            break;\n\n        case 'b':\n\n            base = optarg;\n\n            /* -b implies -d */\n\n            drop = true;\n\n            break;\n\n        case 'd':\n\n            drop = true;\n\n            break;\n\n        case 'p':\n\n            progress = true;\n\n            break;\n\n        case 'q':\n\n            quiet = true;\n\n            break;\n\n        case OPTION_OBJECT: {\n\n            QemuOpts *opts;\n\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n\n                                           optarg, true);\n\n            if (!opts) {\n\n                return 1;\n\n            }\n\n        }   break;\n\n        case OPTION_IMAGE_OPTS:\n\n            image_opts = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Progress is not shown in Quiet mode */\n\n    if (quiet) {\n\n        progress = false;\n\n    }\n\n\n\n    if (optind != argc - 1) {\n\n        error_exit(\"Expecting one image file name\");\n\n    }\n\n    filename = argv[optind++];\n\n\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n\n                          user_creatable_add_opts_foreach,\n\n                          NULL, NULL)) {\n\n        return 1;\n\n    }\n\n\n\n    flags = BDRV_O_RDWR | BDRV_O_UNMAP;\n\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n\n    if (ret < 0) {\n\n        error_report(\"Invalid cache option: %s\", cache);\n\n        return 1;\n\n    }\n\n\n\n    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet);\n\n    if (!blk) {\n\n        return 1;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    qemu_progress_init(progress, 1.f);\n\n    qemu_progress_print(0.f, 100);\n\n\n\n    if (base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (!base_bs) {\n\n            error_setg(&local_err, QERR_BASE_NOT_FOUND, base);\n\n            goto done;\n\n        }\n\n    } else {\n\n        /* This is different from QMP, which by default uses the deepest file in\n\n         * the backing chain (i.e., the very base); however, the traditional\n\n         * behavior of qemu-img commit is using the immediate backing file. */\n\n        base_bs = backing_bs(bs);\n\n        if (!base_bs) {\n\n            error_setg(&local_err, \"Image does not have a backing file\");\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    cbi = (CommonBlockJobCBInfo){\n\n        .errp = &local_err,\n\n        .bs   = bs,\n\n    };\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n    commit_active_start(\"commit\", bs, base_bs, BLOCK_JOB_DEFAULT, 0,\n\n                        BLOCKDEV_ON_ERROR_REPORT, common_block_job_cb, &cbi,\n\n                        &local_err, false);\n\n    aio_context_release(aio_context);\n\n    if (local_err) {\n\n        goto done;\n\n    }\n\n\n\n    /* When the block job completes, the BlockBackend reference will point to\n\n     * the old backing file. In order to avoid that the top image is already\n\n     * deleted, so we can still empty it afterwards, increment the reference\n\n     * counter here preemptively. */\n\n    if (!drop) {\n\n        bdrv_ref(bs);\n\n    }\n\n\n\n    run_block_job(bs->job, &local_err);\n\n    if (local_err) {\n\n        goto unref_backing;\n\n    }\n\n\n\n    if (!drop && bs->drv->bdrv_make_empty) {\n\n        ret = bs->drv->bdrv_make_empty(bs);\n\n        if (ret) {\n\n            error_setg_errno(&local_err, -ret, \"Could not empty %s\",\n\n                             filename);\n\n            goto unref_backing;\n\n        }\n\n    }\n\n\n\nunref_backing:\n\n    if (!drop) {\n\n        bdrv_unref(bs);\n\n    }\n\n\n\ndone:\n\n    qemu_progress_end();\n\n\n\n    blk_unref(blk);\n\n\n\n    if (local_err) {\n\n        error_report_err(local_err);\n\n        return 1;\n\n    }\n\n\n\n    qprintf(quiet, \"Image committed.\\n\");\n\n    return 0;\n\n}\n", "idx": 7069, "substitutes": {"argc": ["argumentb", "axb", "opc", " argb", "optv", "argumentl", "axcs", "argsp", " arglc", "axc", "argsc", "argumentlc", "argscs", "argp", "optl", "argcs", "opv", " argl", "argumentv", "optc", "opcs", "argumentcs", "argl", " argcs", "opp", "argb", "arglc", "argumentc", "argsv", " argp", "axv", "optlc"], "argv": ["argsk", " argw", "Argp", "targetc", "Argv", "argsp", "argw", " argk", "argsc", "calv", "calw", "argp", "targetk", "Argc", " argvs", "calvs", " argf", "argsw", "argk", "targetf", "argsvs", "argf", "Argf", "calc", "targetv", "argsf", "argsv", " argp", "argvs"], "c": ["tc", "rc", "t", "cu", "cp", "co", "unc", "p", "f", "d", "ind", "v", "l", "ec", "lc", "col", "cont", "r", "pc", "ctx", "dc", "C", "cd", "con", "cb", "arc", "cc", "cur", "abc", "k", "h", "cn", "gc", "fc", "i", "b", "g", "inc", "uc", "cmp", "code", "e", "cf", "m", "ce", "cs", "ct", "ac", "count", "bc", "n", "z", "u", "nc", "mc"], "ret": ["rc", "reset", "fi", "RET", "nt", "cont", "Ret", "fin", "fd", "txt", "ext", "val", "fun", "result", "resp", "usr", "std", "new", "fp", "len", "status", "rel", "res", "conv", "desc", "alt", "out"], "flags": ["grades", "properties", "times", "types", "ps", "links", "files", "locks", "options", "errors", "FLAG", "events", "fc", "Flags", "heads", "tags", "status", "ops", "stats", "members", "actions", "comments", "bits", "fs", "flag", "features", "acl", "cs", "args", "vals", "mask", "mode", "wcs", "settings", "weights", "fields", "cmd", "ags", "states"], "filename": ["fil", "fn", "tmp", "ame", "family", "f", "binary", "url", "path", "file", "prefix", "files", "bas", "txt", "username", "description", "location", "nm", "source", "ames", "metadata", "b", "dir", "name", "buf", "buffer", "fp", "target", "ename", "fs", "title", "src", "wcs", "bf", "Filename"], "fmt": [" flt", "tfancy", "Flt", "Ffm", " fformat", "formfm", "bmt", "Fancy", " fancy", "bformat", "formmt", "ffm", "fancy", " fwt", "tfformat", "tfmt", "fformat", "bwt", "formlt", "Fmt", "Fformat", "fwt", "Fwt", "blt", "flt", " ffm", "formformat", "tflt"], "cache": ["aches", "master", "util", "cp", "conf", "cu", "limit", "temp", "config", "ach", "ache", "path", "file", "position", "prefix", "dc", "force", "coll", "options", "depth", "miss", "dirty", "size", "chain", "source", "format", "mem", "dir", "memory", "comment", "timeout", "store", "buffer", "ca", "table", "acher", "storage", "acl", "cs", "ac", "client", "cas", "local", "Cache"], "base": ["key", "origin", "path", "file", "parent", "prefix", "bas", "scope", "force", "offset", "server", "alias", "size", "source", "format", "chain", "profile", "b", "state", "dir", "root", "name", "memory", "quote", "sys", "buffer", "history", "area", "db", "Base", "bottom", "based", "ase", "storage", "scale", "bare", "bin", "back", "local", "template"], "blk": ["slks", "slK", "slk", "slj", "BLk", "BLj", " blks", "BLks", "BLK", "blks", "blK", " blj", "blj", " blK"], "bs": ["ubs", "bos", "ds", "bh", "bi", "bm", "vs", "ps", "bas", "cb", "ss", "outs", "bb", "BS", "blocks", "bl", "sts", "gs", "ts", "obs", "lbs", "fs", "its", "bp", "cs", "sb", "bc", "bd"], "base_bs": ["base_gs", " base_gs", "base_sb", " base_sb", " base_fs", "base_fs"], "writethrough": ["createnthrown", "createthough", "writethrown", "writertrown", "writertost", "createnthost", "writertough", "createthrown", "createnthough", "writetost", "createnthrough", "writetough", "createthost", "writenthough", "writethost", "writertrough", "writenthrough", "writetrown", "writenthrown", "writethough", "createthrough", "writenthost", "writetrough"], "local_err": ["localjcb", "local___progress", "shared_error", "local_progress", "local_error", "local___err", "shared_progress", "localjerr", "local___error", "shared_cb", "localjerror", "local___cb", "localjprogress", "local_cb", "shared_err"], "cbi": ["fbm", "bcbf", "cbm", "bcbm", "bcbi", "tbf", "tbi", "fbf", "fbi", "fbid", "tbid", "tbm", "bcbid", "cbid", "cbf"], "aio_context": ["aioopctx", "aios_info", "aioopinfo", "aio_info", "aioopContext", "aio2info", "aio2ctx", "aioopcontext", "aio2context", "aios_Context", "aios_ctx", "aio_Context", "aio_ctx", "aios_context", "aio2Context"], "long_options": [" long2values", "long67option", "long67types", "long67flags", "long_types", " long_flags", "long_option", " long2flags", " long_values", " long_option", "long_flags", "long2types", "long67options", " long_types", " long2types", "long2option", "long_values", " long2options", "long2flags", "long2values", " long2option", "long2options"], "opts": ["openTS", "optters", "optcs", "iopcs", "alcs", "ropps", "iopps", "OPTS", "opsts", " opcs", " opsts", "optts", " opters", "options", "ropcs", "ioptions", "altions", "OPs", "optports", "OPters", "opents", "OPcs", "opcs", " opports", "roptions", "OPts", "opports", "ops", " ops", "OPsts", "opTS", " opTS", "opens", "iopts", "ropts", "alts", "opters", "alps", "opensts", "opps", "OPports"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "unsigned long setup_arg_pages(void * mh, char ** argv, char ** env)\n\n{\n\n    unsigned long stack_base, error, size;\n\n    int i;\n\n    int * stack;\n\n    int argc, envc;\n\n\n\n    /* Create enough stack to hold everything.  If we don't use\n\n     * it for args, we'll use it for something else...\n\n     */\n\n    size = stack_size;\n\n\n\n    error = target_mmap(0,\n\n                        size + qemu_host_page_size,\n\n                        PROT_READ | PROT_WRITE,\n\n                        MAP_PRIVATE | MAP_ANONYMOUS,\n\n                        -1, 0);\n\n    if (error == -1)\n\n        qerror(\"stk mmap\");\n\n\n\n    /* we reserve one extra page at the top of the stack as guard */\n\n    target_mprotect(error + size, qemu_host_page_size, PROT_NONE);\n\n\n\n    stack_base = error + size;\n\n    stack = (void*)stack_base;\n\n/*\n\n *    | STRING AREA |\n\n *    +-------------+\n\n *    |      0      |\n\n*    +-------------+\n\n *    |  apple[n]   |\n\n *    +-------------+\n\n *           :\n\n *    +-------------+\n\n *    |  apple[0]   |\n\n *    +-------------+\n\n *    |      0      |\n\n *    +-------------+\n\n *    |    env[n]   |\n\n *    +-------------+\n\n *           :\n\n *           :\n\n *    +-------------+\n\n *    |    env[0]   |\n\n *    +-------------+\n\n *    |      0      |\n\n *    +-------------+\n\n *    | arg[argc-1] |\n\n *    +-------------+\n\n *           :\n\n *           :\n\n *    +-------------+\n\n *    |    arg[0]   |\n\n *    +-------------+\n\n *    |     argc    |\n\n *    +-------------+\n\n * sp->    |      mh     | address of where the a.out's file offset 0 is in memory\n\n *    +-------------+\n\n*/\n\n    /* Construct the stack Stack grows down */\n\n    stack--;\n\n\n\n    /* XXX: string should go up there */\n\n\n\n    *stack = 0;\n\n    stack--;\n\n\n\n    /* Push the absolute path of our executable */\n\n    DPRINTF(\"pushing apple %s (0x%x)\\n\", (char*)argv[0], (int)argv[0]);\n\n    stl(stack, (int) argv[0]);\n\n\n\n    stack--;\n\n\n\n    stl(stack, 0);\n\n    stack--;\n\n\n\n    /* Get envc */\n\n    for(envc = 0; env[envc]; envc++);\n\n\n\n    for(i = envc-1; i >= 0; i--)\n\n    {\n\n        DPRINTF(\"pushing env %s (0x%x)\\n\", (char*)env[i], (int)env[i]);\n\n        stl(stack, (int)env[i]);\n\n        stack--;\n\n\n\n        /* XXX: remove that when string will be on top of the stack */\n\n        page_set_flags((int)env[i], (int)(env[i]+strlen(env[i])), PROT_READ | PAGE_VALID);\n\n    }\n\n\n\n    /* Add on the stack the interp_prefix choosen if so */\n\n    if(interp_prefix[0])\n\n    {\n\n        char *dyld_root;\n\n        asprintf(&dyld_root, \"DYLD_ROOT_PATH=%s\", interp_prefix);\n\n        page_set_flags((int)dyld_root, (int)(dyld_root+strlen(interp_prefix)+1), PROT_READ | PAGE_VALID);\n\n\n\n        stl(stack, (int)dyld_root);\n\n        stack--;\n\n    }\n\n\n\n#ifdef DONT_USE_DYLD_SHARED_MAP\n\n    {\n\n        char *shared_map_mode;\n\n        asprintf(&shared_map_mode, \"DYLD_SHARED_REGION=avoid\");\n\n        page_set_flags((int)shared_map_mode, (int)(shared_map_mode+strlen(shared_map_mode)+1), PROT_READ | PAGE_VALID);\n\n\n\n        stl(stack, (int)shared_map_mode);\n\n        stack--;\n\n    }\n\n#endif\n\n\n\n#ifdef ACTIVATE_DYLD_TRACE\n\n    char * extra_env_static[] = {\"DYLD_DEBUG_TRACE=yes\",\n\n    \"DYLD_PREBIND_DEBUG=3\", \"DYLD_UNKNOW_TRACE=yes\",\n\n    \"DYLD_PRINT_INITIALIZERS=yes\",\n\n    \"DYLD_PRINT_SEGMENTS=yes\", \"DYLD_PRINT_REBASINGS=yes\", \"DYLD_PRINT_BINDINGS=yes\", \"DYLD_PRINT_INITIALIZERS=yes\", \"DYLD_PRINT_WARNINGS=yes\" };\n\n\n\n    char ** extra_env = malloc(sizeof(extra_env_static));\n\n    bcopy(extra_env_static, extra_env, sizeof(extra_env_static));\n\n    page_set_flags((int)extra_env, (int)((void*)extra_env+sizeof(extra_env_static)), PROT_READ | PAGE_VALID);\n\n\n\n    for(i = 0; i<9; i++)\n\n    {\n\n        DPRINTF(\"pushing (extra) env %s (0x%x)\\n\", (char*)extra_env[i], (int)extra_env[i]);\n\n        stl(stack, (int) extra_env[i]);\n\n        stack--;\n\n    }\n\n#endif\n\n\n\n    stl(stack, 0);\n\n    stack--;\n\n\n\n    /* Get argc */\n\n    for(argc = 0; argv[argc]; argc++);\n\n\n\n    for(i = argc-1; i >= 0; i--)\n\n    {\n\n        DPRINTF(\"pushing arg %s (0x%x)\\n\", (char*)argv[i], (int)argv[i]);\n\n        stl(stack, (int) argv[i]);\n\n        stack--;\n\n\n\n        /* XXX: remove that when string will be on top of the stack */\n\n        page_set_flags((int)argv[i], (int)(argv[i]+strlen(argv[i])), PROT_READ | PAGE_VALID);\n\n    }\n\n\n\n    DPRINTF(\"pushing argc %d \\n\", argc);\n\n    stl(stack, argc);\n\n    stack--;\n\n\n\n    DPRINTF(\"pushing mh 0x%x \\n\", (int)mh);\n\n    stl(stack, (int) mh);\n\n\n\n    /* Stack points on the mh */\n\n    return (unsigned long)stack;\n\n}\n", "idx": 7099, "substitutes": {"mh": ["mmhs", "bmhs", "mmth", "bmph", " mth", " mhs", "mth", "bmth", "bmh", " mph", "mmph", "mph", "mmh", "mhs"], "argv": ["cmdl", "argvin", "argsl", "argumentvs", "argsp", "argsvin", "cmdc", "packc", "argsc", "arc", "argp", " argl", " argvs", "arvs", "argumentv", "arp", "packvin", " argvin", "packv", "argl", "argsvs", "argumentp", "cmdv", "argumentc", "packvs", "argsv", " argp", "argvs", "arv", "cmdp"], "env": ["stage", "et", "conf", "menu", "call", "txt", "wd", "ver", "iter", "db", "esp", "etc", "tx", "kw", "er", "viron", "cmd", "gear", "dev", "environment", "arg", "vs", "ctx", "worker", "app", "vert", "obj", "ew", "en", "ve", "proc", "dict", "def", "pres", "ten", "code", "args", "context", "config", "priv", "ped", "map", "ext", "nv", "here", "eq", "np", "gn", "e", "end", "var", "nd", "qt", "ev", "vt", "init", "vp", "doc", "cv", "tmp", "v", "ec", "server", "req", "vel", "ee", "result", "buf", "ter", "global", "test", "window", "desc"], "stack_base": ["line_bottom", "line_Base", "ack__size", "ack_bas", "stack2size", "line_buffer", "stack__bal", "line_base", "stack__bas", "stack67bas", "ack__bas", " stack_size", "stack_bottom", "stack2base", "stack2Base", "stack_bal", "stack2bottom", "stack_buffer", "stack_size", " stack_buffer", "stack__size", "ack_base", "stack_Base", "ack__bal", "ack_size", "stack2buffer", "stack67size", "stack__base", "stack_bas", "stack67bal", "ack_bal", "ack__base", "stack67base"], "error": ["rc", "fail", "order", "relation", "danger", "max", "no", "alpha", "success", "debug", "r", "length", "ignore", "bug", "change", "force", "check", "red", "offset", "style", "errors", "iso", "or", "alias", "lock", "option", "empty", "ERROR", "ror", "result", "exc", "index", "info", "problem", "type", "detail", "ref", "match", "rank", "code", "e", "scale", "base", "parse", "owner", "mode", "angle", "Error", "ack", "total", "er", "frame", "err", "event"], "size": ["capacity", "small", "max", "speed", "Size", "south", "percent", "dim", "sum", "length", "SIZE", "normal", "ize", "z", "scope", "padding", "send", "si", "style", "time", "empty", "space", "format", "name", "shift", "fee", "g", "password", "large", "scroll", "network", "zero", "height", "len", "area", "sn", "code", "scale", "storage", "dimension", "global", "pi", "zone", "window", "count", "sha", "mode", "n", "notice", "total", "shape", "grow"], "i": [" I", "t", "li", "ei", "p", "sim", "fi", "bi", "is", "id", "ind", "v", "ii", "ini", "mi", "ix", "me", "it", "ic", "gu", "\u0438", "hi", "uri", "si", "k", "oi", "j", "di", "gi", "o", "ri", "in", "ji", "ip", "index", "ui", "iu", "multi", "xi", "y", "wi", "zi", "ij", "remote", " ti", "ti", "ci", "m", "e", "status", "ami", "ai", "pi", " j", "im", "x", "I", "qi", "phi", "c", "cli", "u", " ii"], "stack": ["acks", "top", "stage", "tc", "function", "out", "pack", "upper", "track", "v", "arg", "sp", "func", "wall", "thread", "wait", "pop", "list", "hash", "scope", "check", "call", "str", "mount", "set", "st", "depth", "package", "where", "profile", "chain", "history", "space", "index", "Stack", "shift", "slice", "trace", "level", "tree", "roll", "scroll", "store", "buffer", "row", "height", "iter", "code", "end", "line", "engine", "storage", "loop", "base", "window", "var", "queue", "null", "push", "alt", "block", "pos", "ack", "context", "back", "load", "frame", "cache", "batch"], "argc": ["parcc", "Argcc", "parcs", "parc", "parcount", " argcc", " argcount", "argcc", "argcs", " argcs", "Argc", "argcount", "Argcount", "Argcs"], "envc": ["portcu", "envp", "terci", " envz", "envC", "varc", "nerC", "environmentu", "envz", "environmentl", "envuc", "envu", "evsc", "enuc", "portci", "environmentc", "envci", " envce", "terC", "enl", "evc", "nerci", " envci", "varuc", "enC", "environmentp", "envce", "envsc", "envcu", "ptrcy", "evci", "envcy", " envcu", "evC", "environmentcu", "ptrc", "varC", "enc", "terp", "ptrci", "evcy", "nerp", "evce", "portc", "environmentce", " envu", "varl", "environmentz", "portu", " envC", " envcy", "nerc", "environmentC", "environmentci", "terc", "ptrC", "evz", " envsc", "environmentuc", "envl", "environmentsc"], "dyld_root": ["dyild_root", "dyld___start", "dyld_start", "dyld_prefix", "dyld___index", "dyland___prefix", "dyll_roots", "dyll_root", "dyld_roots", "dyland___root", "dyll_prefix", "dyldtprefix", "dyland___index", "dyild_parent", "dyland_start", "dyild_prefix", "dyld__parent", "dyld_oot", "dyll_parent", "dyldtoot", "dyld_parent", "dyld__root", "dyldtroot", "dyild_oot", "dyland_index", "dyld__home", "dyld__prefix", "dyland_prefix", "dyland_root", "dyll_home", "dyld___root", "dyland___start", "dyld_index", "dyldtparent", "dyld___prefix", "dyll_oot", "dyld_home"], "shared_map_mode": ["shared_map_mask", "shared_map___default", "shared_prearg", "shared_map___mask", "shared_blockarg", "shared_map___mode", "shared_maparg", "shared_map_", "shared_map_default", "shared_map__type", "shared_map__key", "shared_map_key", "shared_map___type", "shared_map__mode", "shared_map__default", "shared_block_", "shared_pre_", "shared_map_type"]}}
{"project": "qemu", "commit_id": "10a412dab3f54439ea3d60274eb41668f7d83bd2", "target": 0, "func": "int sd_do_command(SDState *sd, SDRequest *req,\n\n                  uint8_t *response) {\n\n    uint32_t last_status = sd->card_status;\n\n    sd_rsp_type_t rtype;\n\n    int rsplen;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {\n\n        return 0;\n\n    }\n\n\n\n    if (sd_req_crc_validate(req)) {\n\n        sd->card_status |= COM_CRC_ERROR;\n\n        rtype = sd_illegal;\n\n        goto send_response;\n\n    }\n\n\n\n    sd->card_status &= ~CARD_STATUS_B;\n\n    sd_set_status(sd);\n\n\n\n    if (last_status & CARD_IS_LOCKED) {\n\n        if (!cmd_valid_while_locked(sd, req)) {\n\n            sd->card_status |= ILLEGAL_COMMAND;\n\n            fprintf(stderr, \"SD: Card is locked\\n\");\n\n            rtype = sd_illegal;\n\n            goto send_response;\n\n        }\n\n    }\n\n\n\n    if (last_status & APP_CMD) {\n\n        rtype = sd_app_command(sd, *req);\n\n        sd->card_status &= ~APP_CMD;\n\n    } else\n\n        rtype = sd_normal_command(sd, *req);\n\n\n\n    if (rtype == sd_illegal) {\n\n        sd->card_status |= ILLEGAL_COMMAND;\n\n    }\n\n\n\n    sd->current_cmd = req->cmd;\n\n\n\nsend_response:\n\n    switch (rtype) {\n\n    case sd_r1:\n\n    case sd_r1b:\n\n        sd_response_r1_make(sd, response, last_status);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r2_i:\n\n        memcpy(response, sd->cid, sizeof(sd->cid));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r2_s:\n\n        memcpy(response, sd->csd, sizeof(sd->csd));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r3:\n\n        sd_response_r3_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r6:\n\n        sd_response_r6_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r7:\n\n        sd_response_r7_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r0:\n\n    case sd_illegal:\n\n    default:\n\n        rsplen = 0;\n\n        break;\n\n    }\n\n\n\n#ifdef DEBUG_SD\n\n    if (rsplen) {\n\n        int i;\n\n        DPRINTF(\"Response:\");\n\n        for (i = 0; i < rsplen; i++)\n\n            printf(\" %02x\", response[i]);\n\n        printf(\" state %d\\n\", sd->state);\n\n    } else {\n\n        DPRINTF(\"No response %d\\n\", sd->state);\n\n    }\n\n#endif\n\n\n\n    return rsplen;\n\n}\n", "idx": 7105, "substitutes": {"sd": ["hd", "sc", "sim", "dev", "td", "ds", "form", "th", "south", "sk", "sec", "od", "d", "ind", "dist", "sing", "amd", "sp", "draw", "ad", "SD", "fd", "dd", "sta", "cd", "bd", "sl", "sam", "server", "si", "ss", "ld", "di", "ell", "dk", "dl", "gd", "js", "ssl", "def", "sy", "sh", "md", "sg", "std", "decl", "vd", "store", "sn", "pd", "db", "dll", "reg", "sv", "san", "desc", "and", "sb", "nd", "mod", "des", "dis", "sky", "s", "sql", "ard", "sys", "se", "sw", "sa"], "req": ["request", "fr", "sc", "query", "conf", "compl", "task", "pkg", "qq", "config", "sec", "conn", "ind", "dist", "sp", "r", "ps", "ctx", "spec", "q", "inv", "need", "msg", "required", "call", "ext", "crit", "pro", "j", "needed", "comm", "iq", "rb", "js", "proc", "resp", "requ", "sq", "rx", "md", "ref", "rec", "jp", "this", "res", "quest", "cond", "esp", "exec", "expr", "desc", "seq", "qt", "tx", "client", "aux", "ack", "urg", "reg", "cmd"], "response": ["request", "entry", "json", "os", "reset", "respons", "form", "frame", "v", "application", "onse", "sp", "r", "Response", "data", "rss", "image", "error", "connection", "send", "version", "style", "description", "ve", "output", "vector", "resp", "result", "def", "memory", "definition", "tree", "amount", "given", "trace", "zero", "example", "answer", "command", "res", "service", "all", "sequence", "window", "des", "then", "reply", "message", "block", "pos", "sol", "value", "out", "yes"], "rtype": ["trfunction", "ertype", "vrtry", "rstatus", "errtype", "resvalue", "regclass", "restype", "rype", "trtry", " rType", "regtype", " rstyle", "Rtype", "roype", "vrtype", " rtyp", "rdtype", "roTYPE", "rver", "rfunction", "erver", "rTYPE", "rotype", "rstyle", "rdstyle", "rtyp", "rrtag", "rrtype", "mrstatus", "resclass", "rrstyle", "rtry", "rrtyp", "rtag", "mTYPE", "rrclass", "regtyp", "erclass", "mrtag", "rpe", "trtype", "restyp", "rType", "Rype", "mtype", "mvalue", " rpe", "restry", "errpe", "ertyp", "trtimeout", "mrtype", " rtag", "erTYPE", "Rpe", "mrstyle", "resype", "rtimeout", " rfunction", "regTYPE", "errype", "vrtimeout", "RType", " rtimeout", "rovalue", "resTYPE", " rstatus", "erstyle", "rclass", "errType", " rtry", " rTYPE", "vrfunction", "rdTYPE", "rvalue", "mype", " rclass", "rdver", " rver", "rrstatus", " rype", "rrtry"], "rsplen": ["rsplent", "rsclEN", "rsplien", " rsclun", "rsplize", " rsplize", "rsplenc", "stspleeth", "rspalar", "inspalenc", "rspenian", "rspalent", "rspleeth", " rsclEN", "rssplian", " rsplun", "rsfllen", "rsimplen", "rsreplun", "rsclize", "csplar", "stsplen", "emsplag", "rssplien", "ryspalen", "stspleen", "rsplerien", "rsflen", "emssplag", "rspleren", "rsplun", "rsPLlen", "rsplugen", "stspleth", "rsploen", "rsplugeth", "rspledEN", "rsflar", "rsplugener", "insplenc", "rspleEN", "rspalag", "rsclun", "rsplens", "rsslener", "csflar", "ryspalien", "inspalen", "rssploen", "rssplens", "rsplEN", "emsplien", "rspleden", "rsslEN", "rspallen", "rssplag", "csplen", "rspaloen", " rsplEN", "rspleener", "rspledize", "csfllen", "rsimplien", "rsplener", "rsPLar", "insplian", "rsplian", "rsflian", "rssleth", "rsplar", "rspleth", "rysplag", "cspllen", "rsclen", "rspalien", "rspenenc", "rysplens", "rssplen", " rsclen", "stsplener", "rssplenc", "rssplent", "csflen", "rsimplag", "rsreplize", "rsplerag", "stsplEN", "rspledun", "csplian", " rsclize", "rspalian", "rspenen", "inspalian", "stspleener", "rysplen", "rsPLen", "insplen", "rsplag", "emssplent", "rsplugEN", "ryspalag", "rysplien", "rspalens", "rsimplens", "rsreplen", "ryspalens", "csflian", "emsplen", "emsplent", "stspleEN", "rspalen", "insploen", "emssplien", "rspenoen", "rspalenc", "rsreplEN", "rspllen", "rsslen", "inspaloen", "emssplen", "rspleen", "rsplerent", "rsPLian"]}}
{"project": "qemu", "commit_id": "9646f4927faf68e8690588c2fd6dc9834c440b58", "target": 0, "func": "void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,\n\n                   uint32_t *eax, uint32_t *ebx,\n\n                   uint32_t *ecx, uint32_t *edx)\n\n{\n\n    X86CPU *cpu = x86_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t pkg_offset;\n\n\n\n    /* test if maximum index reached */\n\n    if (index & 0x80000000) {\n\n        if (index > env->cpuid_xlevel) {\n\n            if (env->cpuid_xlevel2 > 0) {\n\n                /* Handle the Centaur's CPUID instruction. */\n\n                if (index > env->cpuid_xlevel2) {\n\n                    index = env->cpuid_xlevel2;\n\n                } else if (index < 0xC0000000) {\n\n                    index = env->cpuid_xlevel;\n\n                }\n\n            } else {\n\n                /* Intel documentation states that invalid EAX input will\n\n                 * return the same information as EAX=cpuid_level\n\n                 * (Intel SDM Vol. 2A - Instruction Set Reference - CPUID)\n\n                 */\n\n                index =  env->cpuid_level;\n\n            }\n\n        }\n\n    } else {\n\n        if (index > env->cpuid_level)\n\n            index = env->cpuid_level;\n\n    }\n\n\n\n    switch(index) {\n\n    case 0:\n\n        *eax = env->cpuid_level;\n\n        *ebx = env->cpuid_vendor1;\n\n        *edx = env->cpuid_vendor2;\n\n        *ecx = env->cpuid_vendor3;\n\n        break;\n\n    case 1:\n\n        *eax = env->cpuid_version;\n\n        *ebx = (cpu->apic_id << 24) |\n\n               8 << 8; /* CLFLUSH size in quad words, Linux wants it. */\n\n        *ecx = env->features[FEAT_1_ECX];\n\n        if ((*ecx & CPUID_EXT_XSAVE) && (env->cr[4] & CR4_OSXSAVE_MASK)) {\n\n            *ecx |= CPUID_EXT_OSXSAVE;\n\n        }\n\n        *edx = env->features[FEAT_1_EDX];\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            *ebx |= (cs->nr_cores * cs->nr_threads) << 16;\n\n            *edx |= CPUID_HT;\n\n        }\n\n        break;\n\n    case 2:\n\n        /* cache info: needed for Pentium Pro compatibility */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = 1; /* Number of CPUID[EAX=2] calls required */\n\n        *ebx = 0;\n\n        if (!cpu->enable_l3_cache) {\n\n            *ecx = 0;\n\n        } else {\n\n            *ecx = L3_N_DESCRIPTOR;\n\n        }\n\n        *edx = (L1D_DESCRIPTOR << 16) | \\\n\n               (L1I_DESCRIPTOR <<  8) | \\\n\n               (L2_DESCRIPTOR);\n\n        break;\n\n    case 4:\n\n        /* cache info: needed for Core compatibility */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, count, eax, ebx, ecx, edx);\n\n            *eax &= ~0xFC000000;\n\n        } else {\n\n            *eax = 0;\n\n            switch (count) {\n\n            case 0: /* L1 dcache info */\n\n                *eax |= CPUID_4_TYPE_DCACHE | \\\n\n                        CPUID_4_LEVEL(1) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                *ebx = (L1D_LINE_SIZE - 1) | \\\n\n                       ((L1D_PARTITIONS - 1) << 12) | \\\n\n                       ((L1D_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L1D_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 1: /* L1 icache info */\n\n                *eax |= CPUID_4_TYPE_ICACHE | \\\n\n                        CPUID_4_LEVEL(1) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                *ebx = (L1I_LINE_SIZE - 1) | \\\n\n                       ((L1I_PARTITIONS - 1) << 12) | \\\n\n                       ((L1I_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L1I_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 2: /* L2 cache info */\n\n                *eax |= CPUID_4_TYPE_UNIFIED | \\\n\n                        CPUID_4_LEVEL(2) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                if (cs->nr_threads > 1) {\n\n                    *eax |= (cs->nr_threads - 1) << 14;\n\n                }\n\n                *ebx = (L2_LINE_SIZE - 1) | \\\n\n                       ((L2_PARTITIONS - 1) << 12) | \\\n\n                       ((L2_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L2_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 3: /* L3 cache info */\n\n                if (!cpu->enable_l3_cache) {\n\n                    *eax = 0;\n\n                    *ebx = 0;\n\n                    *ecx = 0;\n\n                    *edx = 0;\n\n                    break;\n\n                }\n\n                *eax |= CPUID_4_TYPE_UNIFIED | \\\n\n                        CPUID_4_LEVEL(3) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                pkg_offset = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);\n\n                *eax |= ((1 << pkg_offset) - 1) << 14;\n\n                *ebx = (L3_N_LINE_SIZE - 1) | \\\n\n                       ((L3_N_PARTITIONS - 1) << 12) | \\\n\n                       ((L3_N_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L3_N_SETS - 1;\n\n                *edx = CPUID_4_INCLUSIVE | CPUID_4_COMPLEX_IDX;\n\n                break;\n\n            default: /* end of info */\n\n                *eax = 0;\n\n                *ebx = 0;\n\n                *ecx = 0;\n\n                *edx = 0;\n\n                break;\n\n            }\n\n        }\n\n\n\n        /* QEMU gives out its own APIC IDs, never pass down bits 31..26.  */\n\n        if ((*eax & 31) && cs->nr_cores > 1) {\n\n            *eax |= (cs->nr_cores - 1) << 26;\n\n        }\n\n        break;\n\n    case 5:\n\n        /* mwait info: needed for Core compatibility */\n\n        *eax = 0; /* Smallest monitor-line size in bytes */\n\n        *ebx = 0; /* Largest monitor-line size in bytes */\n\n        *ecx = CPUID_MWAIT_EMX | CPUID_MWAIT_IBE;\n\n        *edx = 0;\n\n        break;\n\n    case 6:\n\n        /* Thermal and Power Leaf */\n\n        *eax = env->features[FEAT_6_EAX];\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 7:\n\n        /* Structured Extended Feature Flags Enumeration Leaf */\n\n        if (count == 0) {\n\n            *eax = 0; /* Maximum ECX value for sub-leaves */\n\n            *ebx = env->features[FEAT_7_0_EBX]; /* Feature flags */\n\n            *ecx = env->features[FEAT_7_0_ECX]; /* Feature flags */\n\n            if ((*ecx & CPUID_7_0_ECX_PKU) && env->cr[4] & CR4_PKE_MASK) {\n\n                *ecx |= CPUID_7_0_ECX_OSPKE;\n\n            }\n\n            *edx = 0; /* Reserved */\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 9:\n\n        /* Direct Cache Access Information Leaf */\n\n        *eax = 0; /* Bits 0-31 in DCA_CAP MSR */\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 0xA:\n\n        /* Architectural Performance Monitoring Leaf */\n\n        if (kvm_enabled() && cpu->enable_pmu) {\n\n            KVMState *s = cs->kvm_state;\n\n\n\n            *eax = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EAX);\n\n            *ebx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EBX);\n\n            *ecx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_ECX);\n\n            *edx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EDX);\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 0xB:\n\n        /* Extended Topology Enumeration Leaf */\n\n        if (!cpu->enable_cpuid_0xb) {\n\n                *eax = *ebx = *ecx = *edx = 0;\n\n                break;\n\n        }\n\n\n\n        *ecx = count & 0xff;\n\n        *edx = cpu->apic_id;\n\n\n\n        switch (count) {\n\n        case 0:\n\n            *eax = apicid_core_offset(cs->nr_cores, cs->nr_threads);\n\n            *ebx = cs->nr_threads;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_SMT;\n\n            break;\n\n        case 1:\n\n            *eax = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);\n\n            *ebx = cs->nr_cores * cs->nr_threads;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_CORE;\n\n            break;\n\n        default:\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_INVALID;\n\n        }\n\n\n\n        assert(!(*eax & ~0x1f));\n\n        *ebx &= 0xffff; /* The count doesn't need to be reliable. */\n\n        break;\n\n    case 0xD: {\n\n        KVMState *s = cs->kvm_state;\n\n        uint64_t ena_mask;\n\n        int i;\n\n\n\n        /* Processor Extended State */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {\n\n            break;\n\n        }\n\n        if (kvm_enabled()) {\n\n            ena_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);\n\n            ena_mask <<= 32;\n\n            ena_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);\n\n        } else {\n\n            ena_mask = -1;\n\n        }\n\n\n\n        if (count == 0) {\n\n            *ecx = 0x240;\n\n            for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {\n\n                const ExtSaveArea *esa = &x86_ext_save_areas[i];\n\n                if ((env->features[esa->feature] & esa->bits) == esa->bits\n\n                    && ((ena_mask >> i) & 1) != 0) {\n\n                    if (i < 32) {\n\n                        *eax |= 1u << i;\n\n                    } else {\n\n                        *edx |= 1u << (i - 32);\n\n                    }\n\n                    *ecx = MAX(*ecx, esa->offset + esa->size);\n\n                }\n\n            }\n\n            *eax |= ena_mask & (XSTATE_FP_MASK | XSTATE_SSE_MASK);\n\n            *ebx = *ecx;\n\n        } else if (count == 1) {\n\n            *eax = env->features[FEAT_XSAVE];\n\n        } else if (count < ARRAY_SIZE(x86_ext_save_areas)) {\n\n            const ExtSaveArea *esa = &x86_ext_save_areas[count];\n\n            if ((env->features[esa->feature] & esa->bits) == esa->bits\n\n                && ((ena_mask >> count) & 1) != 0) {\n\n                *eax = esa->size;\n\n                *ebx = esa->offset;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n    case 0x80000000:\n\n        *eax = env->cpuid_xlevel;\n\n        *ebx = env->cpuid_vendor1;\n\n        *edx = env->cpuid_vendor2;\n\n        *ecx = env->cpuid_vendor3;\n\n        break;\n\n    case 0x80000001:\n\n        *eax = env->cpuid_version;\n\n        *ebx = 0;\n\n        *ecx = env->features[FEAT_8000_0001_ECX];\n\n        *edx = env->features[FEAT_8000_0001_EDX];\n\n\n\n        /* The Linux kernel checks for the CMPLegacy bit and\n\n         * discards multiple thread information if it is set.\n\n         * So don't set it here for Intel to make Linux guests happy.\n\n         */\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            if (env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ||\n\n                env->cpuid_vendor2 != CPUID_VENDOR_INTEL_2 ||\n\n                env->cpuid_vendor3 != CPUID_VENDOR_INTEL_3) {\n\n                *ecx |= 1 << 1;    /* CmpLegacy bit */\n\n            }\n\n        }\n\n        break;\n\n    case 0x80000002:\n\n    case 0x80000003:\n\n    case 0x80000004:\n\n        *eax = env->cpuid_model[(index - 0x80000002) * 4 + 0];\n\n        *ebx = env->cpuid_model[(index - 0x80000002) * 4 + 1];\n\n        *ecx = env->cpuid_model[(index - 0x80000002) * 4 + 2];\n\n        *edx = env->cpuid_model[(index - 0x80000002) * 4 + 3];\n\n        break;\n\n    case 0x80000005:\n\n        /* cache info (L1 cache) */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = (L1_DTLB_2M_ASSOC << 24) | (L1_DTLB_2M_ENTRIES << 16) | \\\n\n               (L1_ITLB_2M_ASSOC <<  8) | (L1_ITLB_2M_ENTRIES);\n\n        *ebx = (L1_DTLB_4K_ASSOC << 24) | (L1_DTLB_4K_ENTRIES << 16) | \\\n\n               (L1_ITLB_4K_ASSOC <<  8) | (L1_ITLB_4K_ENTRIES);\n\n        *ecx = (L1D_SIZE_KB_AMD << 24) | (L1D_ASSOCIATIVITY_AMD << 16) | \\\n\n               (L1D_LINES_PER_TAG << 8) | (L1D_LINE_SIZE);\n\n        *edx = (L1I_SIZE_KB_AMD << 24) | (L1I_ASSOCIATIVITY_AMD << 16) | \\\n\n               (L1I_LINES_PER_TAG << 8) | (L1I_LINE_SIZE);\n\n        break;\n\n    case 0x80000006:\n\n        /* cache info (L2 cache) */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = (AMD_ENC_ASSOC(L2_DTLB_2M_ASSOC) << 28) | \\\n\n               (L2_DTLB_2M_ENTRIES << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ITLB_2M_ASSOC) << 12) | \\\n\n               (L2_ITLB_2M_ENTRIES);\n\n        *ebx = (AMD_ENC_ASSOC(L2_DTLB_4K_ASSOC) << 28) | \\\n\n               (L2_DTLB_4K_ENTRIES << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ITLB_4K_ASSOC) << 12) | \\\n\n               (L2_ITLB_4K_ENTRIES);\n\n        *ecx = (L2_SIZE_KB_AMD << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ASSOCIATIVITY) << 12) | \\\n\n               (L2_LINES_PER_TAG << 8) | (L2_LINE_SIZE);\n\n        if (!cpu->enable_l3_cache) {\n\n            *edx = ((L3_SIZE_KB / 512) << 18) | \\\n\n                   (AMD_ENC_ASSOC(L3_ASSOCIATIVITY) << 12) | \\\n\n                   (L3_LINES_PER_TAG << 8) | (L3_LINE_SIZE);\n\n        } else {\n\n            *edx = ((L3_N_SIZE_KB_AMD / 512) << 18) | \\\n\n                   (AMD_ENC_ASSOC(L3_N_ASSOCIATIVITY) << 12) | \\\n\n                   (L3_N_LINES_PER_TAG << 8) | (L3_N_LINE_SIZE);\n\n        }\n\n        break;\n\n    case 0x80000007:\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = env->features[FEAT_8000_0007_EDX];\n\n        break;\n\n    case 0x80000008:\n\n        /* virtual & phys address size in low 2 bytes. */\n\n        if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) {\n\n            /* 64 bit processor, 48 bits virtual, configurable\n\n             * physical bits.\n\n             */\n\n            *eax = 0x00003000 + cpu->phys_bits;\n\n        } else {\n\n            *eax = cpu->phys_bits;\n\n        }\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            *ecx |= (cs->nr_cores * cs->nr_threads) - 1;\n\n        }\n\n        break;\n\n    case 0x8000000A:\n\n        if (env->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) {\n\n            *eax = 0x00000001; /* SVM Revision */\n\n            *ebx = 0x00000010; /* nr of ASIDs */\n\n            *ecx = 0;\n\n            *edx = env->features[FEAT_SVM]; /* optional features */\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 0xC0000000:\n\n        *eax = env->cpuid_xlevel2;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 0xC0000001:\n\n        /* Support for VIA CPU's CPUID instruction */\n\n        *eax = env->cpuid_version;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = env->features[FEAT_C000_0001_EDX];\n\n        break;\n\n    case 0xC0000002:\n\n    case 0xC0000003:\n\n    case 0xC0000004:\n\n        /* Reserved for the future, and now filled with zero */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    default:\n\n        /* reserved values: zero */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    }\n\n}\n", "idx": 7109, "substitutes": {"env": ["et", "conf", "conn", "msg", "txt", "ah", "net", "vm", "db", "operator", "queue", "er", "cmd", "event", "uv", "eas", "sc", "dev", "environment", "vs", "ctx", "app", "worker", "vert", "inv", "serv", "obj", "ew", "en", "st", "ve", "eng", "esm", "proc", "exc", "enc", "code", "kernel", "sb", "context", "rc", "config", "eu", "esc", "org", "nv", "era", "here", "outer", "manager", "eni", "peer", "e", "end", "external", "Environment", "qt", "param", "ev", "vt", "doc", "actor", "cv", "v", "ec", "server", "req", "gate", "attr", "eve", "act", "console", "buf", "network", "erd", "sv", "addr", "hw", "window", "desc", "client", "timer", "err", "sw"], "index": ["key", "conn", "id", "insert", "sum", "path", "condition", "error", "loc", "alias", "handle", "valid", "where", "cycle", "available", "slice", "connect", "date", "scroll", "seed", "range", "row", "height", "Index", "unknown", "page", "loop", "no", "success", "delete", "data", "ctx", "ix", "list", "check", "si", "empty", "timeout", "zero", "code", "find", "instance", "initial", "num", "x", "null", "open", "block", "context", "shape", "order", "limit", "config", "ind", "thread", "change", "address", "version", "ion", "axis", "lock", "location", "size", "ex", "we", "state", "point", "level", "fee", "type", "rank", "can", "number", "local", "init", "fail", "frame", "length", "hash", "position", "offset", "set", "vector", "link", "info", "trace", "status", "cmp", "scale", "addr", "base", "window", "update", "pos", "input", "value"], "count": ["pack", "max", "config", "ind", "length", "z", "offset", "depth", "read", "size", "name", "info", "current", "cap", "add", "len", "process", "code", "flag", "child", "base", "c", "Count", "start", "total", "cache"], "eax": ["eix", "ieape", "eape", " eau", "xears", "Eox", " eix", "Eax", "eeox", "erox", "xeax", "eeax", "eiake", "eeape", "erax", "ebake", "ebax", "xeaw", "eau", "meaj", "xeox", "eiax", "ebix", "eca", "ebca", "eaap", "eaj", "eaape", "meox", "eica", "eraw", "eap", "meax", "Eaj", "meaw", "eaaw", "eeaw", "eaw", "eox", " eake", " eca", "eake", "ieaw", "meau", "eeaj", " eaj", "eaax", "ieap", "ears", "eeau", "eeap", "erars", "eiix", "ieax", " eox", "mears"], "ebx": ["ebt", "edy", "eby", "ecxml", "egp", "evalx", "egxml", "evalux", "abbt", "debx", "egt", "obx", "erbx", "egtx", "abbz", "egax", "ebxml", "edix", "ibix", "egex", "obt", "ebax", "debix", "egy", "ebix", "ibt", "oby", "ecy", "abbtx", "obtx", "erbax", "evalp", "debex", "abby", "edp", "erbxml", "edz", "ibxx", "ibx", "ebtx", "ebex", "debz", "edt", "evalt", "egx", "evalxx", "erbix", "ecex", "ebux", "ecix", "egix", "abbix", "ebp", "egxx", "ebxx", "egz", "edux", "ecz", "egux", "ecax", "evalix", "abbx", "ebz"], "ecx": ["epX", "ekpx", "epy", "ekwx", "eby", "egX", "eec", "ecv", "egtx", "edix", "escxi", "egex", "edc", "eew", "eetx", "ebxi", "eeex", "egy", "execx", "ebix", "ekxi", "egxi", "eex", "ecy", "edv", "ekw", "ecX", "ecxi", "edw", "execix", "epx", "execex", "execw", "ecpx", "ecc", " ecxi", "ekex", "ekc", "ectx", "edxi", "escpx", "escwx", "edex", "ebex", " ecpx", "egx", " ecwx", "epxi", "ecex", "edtx", "ecix", "escx", "egv", "ekx", "ebv", "ecw", "ebw", "ebX", "ebtx", "eexi", "ecwx"], "edx": ["efx", "efex", "eedux", "iedxx", "pedxx", "pedx", "eedx", " edxc", "edxf", "sedz", "edxc", "ingxc", "sedxx", "edX", "eeex", "pedz", "nedj", "ebbit", "eex", "enedxx", "iedg", "hedz", "nedx", "pedux", " edex", "sedux", "edxx", "enedx", "eedxx", "enxf", "edj", "hedxf", "nedz", "ingex", "eeX", "enedxf", "edz", "enj", " edX", "ingX", "ectx", "edbit", "iedxf", "ebtx", "edex", "EDxx", "ebex", "iedx", "edtx", "EDxf", "EDg", "ecex", "enedg", "efbit", "sedx", "eedz", "enz", "hedj", "enx", "edux", "EDx", "ingx", "hedx", "edg", "eexc", "eftx", "ecbit", "nedxf"], "cpu": ["ka", "sc", "cu", "cp", "util", "p", "phys", "os", "pkg", "cv", "config", "conn", "processor", "ec", "ctx", "pc", "linux", "prof", "gpu", "ox", "cn", "gc", "device", "nu", "proc", "np", "mx", "socket", "CPU", "net", "pool", "process", "vm", "ck", "stat", "tp", "cmp", "pu", "kernel", "core", "hw", "us", "c", "nic", "sys", "nc", "cache"], "cs": ["tc", "sc", "ubs", "cp", "ds", "cv", "ces", "acts", "css", "cus", "ras", "ms", "ares", "ec", "ps", "vs", "ctx", "spec", "ins", "ks", "cc", "ss", "cons", "CS", "caps", "cn", "ys", "ns", "js", "hs", "proc", "cases", "act", "sts", "rs", "gs", "ars", "ts", "cks", "cf", "obs", "stats", "checks", "acs", "actions", "utils", "fs", "args", "ims", "csv", "otes", "c", "cms", "wcs", "ls", "cas", "qs", "aps", "sys", "cells"], "pkg_offset": ["pkg_off", "pkgxoffset", " sock_offset", "pkg2offset", "pkgxref", " sock_off", " sock_size", " sock_ref", "pkgxsize", "pkg2size", "pkg_ref", "pkg2ref", "pkgxoff", "pkg_size", "pkg2off"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static void prepare_app_arguments(int *argc_ptr, char ***argv_ptr)\n\n{\n\n    char *argstr_flat;\n\n    wchar_t **argv_w;\n\n    int i, buffsize = 0, offset = 0;\n\n\n\n    if (win32_argv_utf8) {\n\n        *argc_ptr = win32_argc;\n\n        *argv_ptr = win32_argv_utf8;\n\n        return;\n\n    }\n\n\n\n    win32_argc = 0;\n\n    argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc);\n\n    if (win32_argc <= 0 || !argv_w)\n\n        return;\n\n\n\n    /* determine the UTF-8 buffer size (including NULL-termination symbols) */\n\n    for (i = 0; i < win32_argc; i++)\n\n        buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,\n\n                                        NULL, 0, NULL, NULL);\n\n\n\n    win32_argv_utf8 = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize);\n\n    argstr_flat     = (char *)win32_argv_utf8 + sizeof(char *) * (win32_argc + 1);\n\n    if (win32_argv_utf8 == NULL) {\n\n        LocalFree(argv_w);\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < win32_argc; i++) {\n\n        win32_argv_utf8[i] = &argstr_flat[offset];\n\n        offset += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,\n\n                                      &argstr_flat[offset],\n\n                                      buffsize - offset, NULL, NULL);\n\n    }\n\n    win32_argv_utf8[i] = NULL;\n\n    LocalFree(argv_w);\n\n\n\n    *argc_ptr = win32_argc;\n\n    *argv_ptr = win32_argv_utf8;\n\n}\n", "idx": 7111, "substitutes": {"argc_ptr": ["argc_tr", "argv__tip", "argci_rect", "argc7pointer", "argci_tr", "argc_tip", "argci__rect", "argv_tr", "argv__pointer", "argc7tr", "argv__tr", "argc__Ptr", "argv__Ptr", "argc__rect", "argci__tr", "argc_rect", "argci__ptr", "argc_Ptr", "argci__pointer", "argc7ptr", "argci_pointer", "argc__ptr", "argci_ptr", "argv_pointer", "argc7tip", "argc__pointer", "argc__tr", "argc__tip", "argc_pointer", "argv_tip", "argv__ptr", "argv_Ptr"], "argv_ptr": ["argv_pointers", "arguv_ptr", "arguv_fp", "argv_loc", "argl_ptr", "argv_rep", "argv__pointer", "argl_pointer", "argv_copy", "argc_pointers", "arguv_copy", "argc_loc", "argl_rep", "argv_dep", "argl_pointers", "argv___ptr", "argc__loc", "argv__pointers", "arguv_dep", "argv___dep", "argv___copy", "argc__ptr", "argv__loc", "argv_pointer", "argc__pointer", "argv_fp", "argc_pointer", "argv__ptr", "argv___fp", "argc__pointers"], "argstr_flat": ["argstr__hat", "argstring_flat", "argstr2flush", "argstr__full", "argstring_at", "argbr__full", "argstr_flush", "argstr___flat", "argst_flat", "argbr__lit", "argstring__at", "argstr_normal", "argstr_full", "argstring__normal", "argStr__full", "argbr_full", "argst_flush", "argstr_att", "argbr_lit", "argbr_flat", "argstr_hat", "argstring_hat", "argStr_sat", "argstring_normal", "argstr_at", "argstr_lit", "argstr2flat", "argbr__flat", "argStr_full", "argbr__att", "argbr_att", "argstr__at", "argstring__flat", "argstr___att", "argstr__normal", "argstr2full", "argStr__flat", "argstr__att", "argStr_flat", "argstring__hat", "argStr__sat", "argstr_sat", "argstr___lit", "argst_full", "argstr__sat", "argstr___full", "argstr__lit", "argstr__flat"], "argv_w": ["argsv_w", "argv4way", "argl_wp", "argv___r", "argp_W", "argc_ws", "argv_wp", "argv_t", "argsv_sw", "argv_r", "argv_wt", "argv_W", "argvpywt", "argv_aw", "argv4w", "argv__wh", "argl_w", "argp_w", "argv8w", "argvs_wl", "argv_wh", "argl_wa", "argp_r", "argc_way", "argv__W", "argvjraw", "argvs_w", "argc_w", "argv_c", "argv_way", "argvs_t", "argl_wt", "argc_wr", "argv_ws", "argv_raw", "argvpyw", "argv_wr", "argvpywl", "argv4aw", "argv__ws", "argvjwh", "argv1sw", "argv4ws", "argv__w", "argv___W", "argc_aw", "argv8wl", "argvpyt", "argv8wt", "argv__raw", "argp_c", "argv_wl", "argv_wa", "argvs_wt", "argv___c", "argv__wr", "argv___w", "argv8t", "argc_W", "argv1w", "argsv_nw", "argv_nw", "argv_sw", "argvjw", "argv1nw"], "i": ["p", "id", "l", "ii", "ini", "it", "q", "di", "gi", "slice", "y", "remote", "ci", "ami", "loop", " j", "ims", "qi", "c", "cli", "n", " ii", "ei", "ski", "origin", "ix", "ic", "si", "oi", "j", "ji", "index", "zi", "instance", "pi", "x", "phi", "us", "is", "ind", "mi", "gu", "ri", "chain", "ip", "ex", "multi", "print", "e", "ti", "m", "iii", "ai", "im", "I", "init", "t", "li", "sim", "ki", "bi", "v", "to", "me", "parent", "\u0438", "offset", "uri", "in", "info", "g", "ui", "iu", "xi", "ij", "status", "batch"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)\n\n{\n\n    switch (size) {\n\n    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;\n\n    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;\n\n    default: abort();\n\n    }\n\n}\n", "idx": 7119, "substitutes": {"op0": ["msg4", "top4", "oppk", " opk", "jp02", "jp0", "op2", "op50", "msg1", "op4", "opt1", "opt0", "jp1", " op2", "cmd0", "cop0", "cop48", "op02", "cmd02", "ost50", "cop2", " op50", "jp4", "hop6", "opk", "opp6", "opt4", " op48", " op6", "oper4", "opp0", " op4", "op48", "hop02", "ost2", "ost48", "hop1", "ost0", "top1", "cmd1", "top0", "oper1", "oper0", "msg0", "hop0", "op6", "cop50", "opp1", "hopk"], "op1": ["pop01", "Op01", "Op0", "og64", "pop1", "map01", "og0", "pop6", "op001", "op01", "op2", "opt1", "op64", " op2", "Op1", "map0", "opt6", " op64", "Op001", " op3", "map1", "top01", "map001", "pop2", "pop001", " op6", "top64", "og01", "pop0", "og1", "pop3", "opt3", "top1", "op3", "top0", "opt2", " op01", "op6"], "size": ["capacity", "small", "Size", "use", "dim", "sum", "length", "SIZE", "ize", "scope", "send", "offset", "ose", "style", "body", "empty", "space", "slot", "index", "shift", "fee", "ui", "type", "height", "len", "sn", "scale", "dimension", "zone", "number", "count", "iz", "message", "n", "sized", "shape"]}}
{"project": "FFmpeg", "commit_id": "2f996b8397ee0e646a824f3dfcbd291a114af348", "target": 0, "func": "int MP3lame_encode_frame(AVCodecContext *avctx,\n\n                     unsigned char *frame, int buf_size, void *data)\n\n{\n\n\tMp3AudioContext *s = avctx->priv_data;\n\n\tint num, i;\n\n//av_log(avctx, AV_LOG_DEBUG, \"%X %d %X\\n\", (int)frame, buf_size, (int)data);\n\n//        if(data==NULL)\n\n//            return lame_encode_flush(s->gfp, frame, buf_size);\n\n\n\n\t/* lame 3.91 dies on '1-channel interleaved' data */\n\n\tif (s->stereo) {\n\n\t\tnum = lame_encode_buffer_interleaved(s->gfp, data,\n\n\t\t\tMPA_FRAME_SIZE, frame, buf_size);\n\n\t} else {\n\n\t\tnum = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,\n\n\t\t\tframe, buf_size);\n\n\n\n/*av_log(avctx, AV_LOG_DEBUG, \"in:%d out:%d\\n\", MPA_FRAME_SIZE, num);\n\nfor(i=0; i<num; i++){\n\n    av_log(avctx, AV_LOG_DEBUG, \"%2X \", frame[i]);\n\n}*/\n\n\t}\n\n\n\n\treturn num;\n\n}\n", "idx": 7122, "substitutes": {"avctx": [" avcontext", "avtxt", "wavctx", " avtxt", " avca", " avcc", "wavcontext", "ovcmp", "vca", "vcontext", "ovcc", "avcmp", "avcc", "vtxt", "avca", "Avtxt", "Avca", "wavcmp", "ovctx", "ovcontext", "avcontext", "Avcontext", "wavcc", "vctx", "Avctx", " avcmp"], "frame": ["scene", "fr", "fram", "f", "id", "draw", "filter", "spec", "channel", "component", "image", "file", "fb", "field", "force", "version", "style", "time", "chain", "word", "feature", "point", "step", "trace", "Frame", "buffer", "process", "code", "sample", "face", "flow", "cond", "ime", "ce", "base", "part", "window", "sequence", "feat", "video", "block", "context", "rame", "cmd", "event"], "buf_size": ["bufmodsize", "buf_space", "bufmodlen", " buf_space", "buf_Size", "buf_fee", " buf_Size", "buf5set", "buf_len", "buf2width", "buf2size", "buf2len", " buf2size", " buf_width", "buf5size", "buf_set", "buf_width", "buf5fee", "bufmodspace", " buf2len", " buf2space", " buf_set", " buf_len", "buf5Size", "bufmodwidth", " buf2width", "buf2space", " buf_fee"], "data": ["rew", "t", "extra", "p", "no", "f", "a", "d", "id", "length", "done", "normal", "mu", "channel", "image", "file", "error", "DATA", "padding", "str", "valid", "Data", "device", "next", "empty", "size", "none", "value", "bytes", "result", "def", "buf", "zero", "buffer", "text", "ata", "sample", "this", "end", " DATA", "raw", "all", "window", "mode", "bin", "video", "message", "block", "context", "cache", "load", "stream", "batch"], "s": ["sc", "t", "os", "S", "ess", "p", "ds", "is", "ps", "spec", "ins", "z", "sl", "sam", "less", "set", "ss", "iss", "h", "comm", "ass", "so", "js", "ns", "hs", "ex", "sq", "http", "sts", "rs", "gs", "ts", "es", "stats", "sis", "sv", "cs", "sb", "c", "als", "ls", "qs", "ats", "sys", "se", "sw", "sa"], "num": [" number", "NUM", "mon", "sim", "no", "f", "id", "dim", "umber", "sum", " nu", "prim", "nom", "tim", "quant", "check", "con", "val", "en", " remain", "good", "nam", "valid", "umi", "comm", "nm", "nu", "mem", "off", "result", "index", " numb", "Number", "ver", "pn", "mn", "Num", " sum", "len", "om", "um", "perm", "un", "code", "m", "coord", "snap", "number", "uf", "final", "cal", "n", "total"], "i": ["t", "p", "f", "id", "l", "v", "ii", "mi", "ix", "it", "si", "j", "in", "ip", "b", "index", "g", "iu", "ij", "m", "ai", "pi", "im", "x", "I", "c", "n"]}}
{"project": "qemu", "commit_id": "53628efbc8aa7a7ab5354d24b971f4d69452151d", "target": 1, "func": "int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)\n\n{\n\n    int offset = 0, counter = 10;\n\n    int res;\n\n\n\n    if (!s->chr_sync_read) {\n\n        return 0;\n\n    }\n\n    \n\n    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {\n\n        return replay_char_read_all_load(buf);\n\n    }\n\n\n\n    while (offset < len) {\n\n        do {\n\n            res = s->chr_sync_read(s, buf + offset, len - offset);\n\n            if (res == -1 && errno == EAGAIN) {\n\n                g_usleep(100);\n\n            }\n\n        } while (res == -1 && errno == EAGAIN);\n\n\n\n        if (res == 0) {\n\n            break;\n\n        }\n\n\n\n        if (res < 0) {\n\n            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n                replay_char_read_all_save_error(res);\n\n            }\n\n            return res;\n\n        }\n\n\n\n        offset += res;\n\n\n\n        if (!counter--) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_char_read_all_save_buf(buf, offset);\n\n    }\n\n    return offset;\n\n}\n", "idx": 7125, "substitutes": {"s": ["t", "os", "S", "p", "sports", "sim", "conf", "ds", "details", "is", "a", "sp", "r", "ps", "spec", "q", "sm", "serv", "sl", "less", "set", "ss", "st", "h", "comm", "source", "js", "ns", "hs", "ssl", "b", "state", "sq", "space", "ses", "sts", "rs", "store", "gs", "ts", "stats", "has", "service", "fs", "sv", "cs", "ims", "sb", "client", "c", "ls", "n", "ats", "sys", "er", "se", "states"], "buf": ["doc", "lim", "p", "pkg", "cast", "cv", "tmp", "limit", "v", "data", "ctx", "q", "bar", "cb", "Buffer", "offset", "cur", "ff", "br", "buff", "Buff", "bs", "mem", "bytes", "b", "off", "orig", "pb", "cap", "ref", "buffer", "iter", "db", "raw", "vec", "bp", "window", "uf", "seq", "queue", "bf", "bin", "cmd", "block", "box", "pos", "rb", "bag", "img", "bc", "wb", "batch"], "len": ["lim", "elt", "syn", "lf", "el", "limit", "ln", "ll", "Len", "l", "sp", "length", "fin", "list", "mult", "z", "offset", "val", "cl", "en", "fl", "size", "mem", "bytes", "il", "ref", "mid", "cmp", "iter", "end", "vec", "all", "num", "L", "count", "seq", "ls", "nl", "lan", "pos", "n"], "res": ["vers", "full", "arr", "pc", "rss", "error", "msg", "str", " Res", "rem", "ver", "response", "results", "cond", "vec", "gr", "des", "cmd", "ptr", "flags", "RES", "resource", "r", "re", "ps", "Res", "serv", "obj", "resolution", "cons", "ress", "ret", "i", "js", "proc", "pres", "index", "zero", "mid", "ts", "rez", "fs", "mask", "was", "sys", "reset", "prime", "details", "func", "resh", "rs", "rest", "repl", "rel", "conv", "cs", "out", "reg", "os", "max", "respons", "ser", "ms", "red", "offset", "val", "req", "bytes", "result", "resp", "act", "pers", "rev", "pr", "cmp", "es", "vals", "expr", "pos", "err", "mr"], "counter": ["ounter", "conf", "inner", "controller", "ctr", "card", "processor", "TER", "scope", "frequency", "nc", "depth", "vector", "outer", "clock", "pointer", "currency", "random", "walker", "level", "atomic", "nr", "timeout", "ber", "iter", "mer", "ter", "repeat", "sequence", "number", "count", "c", "loader", "finder", "Counter", "batch", "context", "timer", "mr"]}}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int decode_b_picture_secondary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status;\n\n\n\n    bitplane_decoding(&v->skip_mb_plane, v);\n\n    if (status < 0) return -1;\n\n#if TRACE\n\n    if (v->mv_mode == MV_PMODE_MIXED_MV)\n\n    {\n\n        status = bitplane_decoding(&v->mv_type_mb_plane, v);\n\n        if (status < 0)\n\n            return -1;\n\n#if TRACE\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"MB MV Type plane encoding: \"\n\n               \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n    }\n\n\n\n    //bitplane\n\n    status = bitplane_decoding(&v->direct_mb_plane, v);\n\n    if (status < 0) return -1;\n\n#if TRACE\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"MB Direct plane encoding: \"\n\n           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"Skip MB plane encoding: \"\n\n           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n\n\n    /* FIXME: what is actually chosen for B frames ? */\n\n    v->s.mv_table_index = get_bits(gb, 2); //but using vc9_ tables\n\n    v->cbpcy_vlc = &vc9_cbpcy_p_vlc[get_bits(gb, 2)];\n\n\n\n    if (v->dquant)\n\n    {\n\n        vop_dquant_decoding(v);\n\n    }\n\n\n\n    if (v->vstransform)\n\n    {\n\n        v->ttmbf = get_bits(gb, 1);\n\n        if (v->ttmbf)\n\n        {\n\n            v->ttfrm = get_bits(gb, 2);\n\n            av_log(v->s.avctx, AV_LOG_INFO, \"Transform used: %ix%i\\n\",\n\n                   (v->ttfrm & 2) ? 4 : 8, (v->ttfrm & 1) ? 4 : 8);\n\n        }\n\n    }\n\n    /* Epilog (AC/DC syntax) should be done in caller */\n\n    return 0;\n\n}\n", "idx": 7130, "substitutes": {"v": ["view", "vp", "p", "dev", "tv", "vi", "cv", "f", "vc", "l", "vs", "it", "qv", "inv", "ev", "w", "vv", "val", "version", "k", "nv", "j", "h", "ve", "vr", "wire", "qu", "i", "b", "V", "ver", "current", "g", "detail", "rev", "vd", "y", "vm", "um", "m", "iv", "conv", "sv", "ov", "all", "window", "var", "lv", "x", "env", "c", "s", "video", "cache", "er", "vt", "value", "av", "sw", "uv"], "gb": ["py", "gm", "git", "bn", "html", "gt", "cv", "bt", "bm", "ctx", "eg", "fb", "hub", "pg", "gu", "vg", "goo", "gpu", "cd", "cb", "phy", " db", "gc", "px", "attr", "gy", "gd", "rb", "bs", "rg", "bb", "g", "mb", "sg", "Gb", "kb", "gs", "gnu", "db", "bg", "tg", "cfg", "gg", "gp", "GB", "storage", "bridge", "eb", "csv", "sb", "gif", "bf", "nb", " GB", "img", "bc", "wb"], "status": ["active", "p", "id", "scan", "error", "msg", "str", "iso", "valid", "only", "gc", " Status", "comments", "score", "access", "sc", "progress", "success", "sp", "data", "wait", "list", "check", "note", "gone", "si", "st", "i", "js", "index", "name", "usage", "code", "stat", "try", "fs", "flag", "x", "using", "entry", "atus", "details", "is", "login", "version", "size", "source", "ex", "format", "state", "cgi", "summary", "s", "vis", "by", "add", "sex", "html", "sim", "use", "spec", "ping", "Status", "sync", "prefix", "wa", "xml", "result", "ssl", "resp", "g", "res", "uses", "update", "gl", "err", "sw"]}}
{"project": "FFmpeg", "commit_id": "0efb6106118c17308b3fdc3190f5e5bf84b01d5c", "target": 1, "func": "static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        MXFTrack *track = s->streams[i]->priv_data;\n\n        /* SMPTE 379M 7.3 */\n\n        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))\n\n            return i;\n\n    }\n\n    /* return 0 if only one stream, for OP Atom files with 0 as track number */\n\n    return s->nb_streams == 1 ? 0 : -1;\n\n}\n", "idx": 7150, "substitutes": {"s": ["t", "os", "p", "S", "sports", "ds", "https", "f", "a", "aus", "is", "ms", "v", "r", "ps", "spec", "ins", "w", "less", "ss", "h", "aws", "comm", "bs", "ns", "js", "hs", "b", "sq", "sys", "g", "ses", "sts", "rs", "gs", "ts", "es", "e", "stats", "m", "fs", "its", "sv", "ims", "x", "parts", "c", "als", "ls", "n", "qs", "ats"], "klv": ["kvl", "keyll", "qlv", "keylv", "sklp", "qdl", "sklv", "qLV", "kdl", " klp", "keydl", " kll", "kll", "ktlc", "qll", "skvl", " klc", "ktvl", " kLV", "klc", "ktlp", "keyLV", " kvl", "klp", "ktlv", " kdl", "kLV", "sklc"], "i": ["p", "id", " wi", "ii", " ni", "ini", "l", " pi", "it", "hi", "ish", "k", "di", " is", "gi", "iq", " si", "y", "iter", "ci", " j", "ims", "n", " ii", " I", "ei", " err", "ix", " it", "list", "ic", "si", "oi", "j", "ji", "index", "try", "pi", "x", "phi", "us", "ind", "mi", " init", "ri", "chain", "ip", "point", "multi", "print", " ti", "e", "ti", "m", "ai", "im", " mi", "I", "u", "init", "t", "li", " multi", "sim", " info", " iter", "ki", "bi", "v", " bi", "me", "uri", "o", "in", " li", "ui", "iu", "xi", "ij", " index", "batch"], "track": ["search", "t", "seek", "util", "pack", "form", "train", "r", "rack", "race", "Track", "collect", "check", "transform", "hold", "handle", "sort", "attr", "bind", "met", "info", "trace", "roll", "trak", "store", "tracking", "row", "tag", "match", "tp", "stat", "find", "record", "report", "tr", "follow", "stream", "trip", "tm", "count", "ack", "tab", "cache", "cmd", "batch", "add"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void vc1_mc_1mv(VC1Context *v, int dir)\n\n{\n\n    MpegEncContext *s = &v->s;\n\n    H264ChromaContext *h264chroma = &v->h264chroma;\n\n    uint8_t *srcY, *srcU, *srcV;\n\n    int dxy, mx, my, uvmx, uvmy, src_x, src_y, uvsrc_x, uvsrc_y;\n\n    int v_edge_pos = s->v_edge_pos >> v->field_mode;\n\n    int i;\n\n    uint8_t (*luty)[256], (*lutuv)[256];\n\n    int use_ic;\n\n\n\n    if ((!v->field_mode ||\n\n         (v->ref_field_type[dir] == 1 && v->cur_field_type == 1)) &&\n\n        !v->s.last_picture.f.data[0])\n\n        return;\n\n\n\n    mx = s->mv[dir][0][0];\n\n    my = s->mv[dir][0][1];\n\n\n\n    // store motion vectors for further use in B frames\n\n    if (s->pict_type == AV_PICTURE_TYPE_P) {\n\n        for (i = 0; i < 4; i++) {\n\n            s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][0] = mx;\n\n            s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][1] = my;\n\n        }\n\n    }\n\n\n\n    uvmx = (mx + ((mx & 3) == 3)) >> 1;\n\n    uvmy = (my + ((my & 3) == 3)) >> 1;\n\n    v->luma_mv[s->mb_x][0] = uvmx;\n\n    v->luma_mv[s->mb_x][1] = uvmy;\n\n\n\n    if (v->field_mode &&\n\n        v->cur_field_type != v->ref_field_type[dir]) {\n\n        my   = my   - 2 + 4 * v->cur_field_type;\n\n        uvmy = uvmy - 2 + 4 * v->cur_field_type;\n\n    }\n\n\n\n    // fastuvmc shall be ignored for interlaced frame picture\n\n    if (v->fastuvmc && (v->fcm != ILACE_FRAME)) {\n\n        uvmx = uvmx + ((uvmx < 0) ? (uvmx & 1) : -(uvmx & 1));\n\n        uvmy = uvmy + ((uvmy < 0) ? (uvmy & 1) : -(uvmy & 1));\n\n    }\n\n    if (!dir) {\n\n        if (v->field_mode && (v->cur_field_type != v->ref_field_type[dir]) && v->second_field) {\n\n            srcY = s->current_picture.f.data[0];\n\n            srcU = s->current_picture.f.data[1];\n\n            srcV = s->current_picture.f.data[2];\n\n            luty  = v->curr_luty;\n\n            lutuv = v->curr_lutuv;\n\n            use_ic = v->curr_use_ic;\n\n        } else {\n\n            srcY = s->last_picture.f.data[0];\n\n            srcU = s->last_picture.f.data[1];\n\n            srcV = s->last_picture.f.data[2];\n\n            luty  = v->last_luty;\n\n            lutuv = v->last_lutuv;\n\n            use_ic = v->last_use_ic;\n\n        }\n\n    } else {\n\n        srcY = s->next_picture.f.data[0];\n\n        srcU = s->next_picture.f.data[1];\n\n        srcV = s->next_picture.f.data[2];\n\n        luty  = v->next_luty;\n\n        lutuv = v->next_lutuv;\n\n        use_ic = v->next_use_ic;\n\n    }\n\n\n\n    if (!srcY || !srcU) {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Referenced frame missing.\\n\");\n\n        return;\n\n    }\n\n\n\n    src_x   = s->mb_x * 16 + (mx   >> 2);\n\n    src_y   = s->mb_y * 16 + (my   >> 2);\n\n    uvsrc_x = s->mb_x *  8 + (uvmx >> 2);\n\n    uvsrc_y = s->mb_y *  8 + (uvmy >> 2);\n\n\n\n    if (v->profile != PROFILE_ADVANCED) {\n\n        src_x   = av_clip(  src_x, -16, s->mb_width  * 16);\n\n        src_y   = av_clip(  src_y, -16, s->mb_height * 16);\n\n        uvsrc_x = av_clip(uvsrc_x,  -8, s->mb_width  *  8);\n\n        uvsrc_y = av_clip(uvsrc_y,  -8, s->mb_height *  8);\n\n    } else {\n\n        src_x   = av_clip(  src_x, -17, s->avctx->coded_width);\n\n        src_y   = av_clip(  src_y, -18, s->avctx->coded_height + 1);\n\n        uvsrc_x = av_clip(uvsrc_x,  -8, s->avctx->coded_width  >> 1);\n\n        uvsrc_y = av_clip(uvsrc_y,  -8, s->avctx->coded_height >> 1);\n\n    }\n\n\n\n    srcY += src_y   * s->linesize   + src_x;\n\n    srcU += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n    srcV += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n\n\n    if (v->field_mode && v->ref_field_type[dir]) {\n\n        srcY += s->current_picture_ptr->f.linesize[0];\n\n        srcU += s->current_picture_ptr->f.linesize[1];\n\n        srcV += s->current_picture_ptr->f.linesize[2];\n\n    }\n\n\n\n    /* for grayscale we should not try to read from unknown area */\n\n    if (s->flags & CODEC_FLAG_GRAY) {\n\n        srcU = s->edge_emu_buffer + 18 * s->linesize;\n\n        srcV = s->edge_emu_buffer + 18 * s->linesize;\n\n    }\n\n\n\n    if (v->rangeredfrm || use_ic\n\n        || s->h_edge_pos < 22 || v_edge_pos < 22\n\n        || (unsigned)(src_x - s->mspel) > s->h_edge_pos - (mx&3) - 16 - s->mspel * 3\n\n        || (unsigned)(src_y - 1)        > v_edge_pos    - (my&3) - 16 - 3) {\n\n        uint8_t *uvbuf = s->edge_emu_buffer + 19 * s->linesize;\n\n\n\n        srcY -= s->mspel * (1 + s->linesize);\n\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, srcY,\n\n                                 s->linesize, s->linesize,\n\n                                 17 + s->mspel * 2, 17 + s->mspel * 2,\n\n                                 src_x - s->mspel, src_y - s->mspel,\n\n                                 s->h_edge_pos, v_edge_pos);\n\n        srcY = s->edge_emu_buffer;\n\n        s->vdsp.emulated_edge_mc(uvbuf, srcU,\n\n                                 s->uvlinesize, s->uvlinesize,\n\n                                 8 + 1, 8 + 1,\n\n                                 uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, v_edge_pos >> 1);\n\n        s->vdsp.emulated_edge_mc(uvbuf + 16, srcV,\n\n                                 s->uvlinesize, s->uvlinesize,\n\n                                 8 + 1, 8 + 1,\n\n                                 uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, v_edge_pos >> 1);\n\n        srcU = uvbuf;\n\n        srcV = uvbuf + 16;\n\n        /* if we deal with range reduction we need to scale source blocks */\n\n        if (v->rangeredfrm) {\n\n            int i, j;\n\n            uint8_t *src, *src2;\n\n\n\n            src = srcY;\n\n            for (j = 0; j < 17 + s->mspel * 2; j++) {\n\n                for (i = 0; i < 17 + s->mspel * 2; i++)\n\n                    src[i] = ((src[i] - 128) >> 1) + 128;\n\n                src += s->linesize;\n\n            }\n\n            src  = srcU;\n\n            src2 = srcV;\n\n            for (j = 0; j < 9; j++) {\n\n                for (i = 0; i < 9; i++) {\n\n                    src[i]  = ((src[i]  - 128) >> 1) + 128;\n\n                    src2[i] = ((src2[i] - 128) >> 1) + 128;\n\n                }\n\n                src  += s->uvlinesize;\n\n                src2 += s->uvlinesize;\n\n            }\n\n        }\n\n        /* if we deal with intensity compensation we need to scale source blocks */\n\n        if (use_ic) {\n\n            int i, j;\n\n            uint8_t *src, *src2;\n\n\n\n            src = srcY;\n\n            for (j = 0; j < 17 + s->mspel * 2; j++) {\n\n                int f = v->field_mode ? v->ref_field_type[dir] : ((j + src_y - s->mspel) & 1) ;\n\n                for (i = 0; i < 17 + s->mspel * 2; i++)\n\n                    src[i] = luty[f][src[i]];\n\n                src += s->linesize;\n\n            }\n\n            src  = srcU;\n\n            src2 = srcV;\n\n            for (j = 0; j < 9; j++) {\n\n                int f = v->field_mode ? v->ref_field_type[dir] : ((j + uvsrc_y) & 1);\n\n                for (i = 0; i < 9; i++) {\n\n                    src[i]  = lutuv[f][src[i]];\n\n                    src2[i] = lutuv[f][src2[i]];\n\n                }\n\n                src  += s->uvlinesize;\n\n                src2 += s->uvlinesize;\n\n            }\n\n        }\n\n        srcY += s->mspel * (1 + s->linesize);\n\n    }\n\n\n\n    if (s->mspel) {\n\n        dxy = ((my & 3) << 2) | (mx & 3);\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0]    , srcY    , s->linesize, v->rnd);\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8, srcY + 8, s->linesize, v->rnd);\n\n        srcY += s->linesize * 8;\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize    , srcY    , s->linesize, v->rnd);\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize + 8, srcY + 8, s->linesize, v->rnd);\n\n    } else { // hpel mc - always used for luma\n\n        dxy = (my & 2) | ((mx & 2) >> 1);\n\n        if (!v->rnd)\n\n            s->hdsp.put_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16);\n\n        else\n\n            s->hdsp.put_no_rnd_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16);\n\n    }\n\n\n\n    if (s->flags & CODEC_FLAG_GRAY) return;\n\n    /* Chroma MC always uses qpel bilinear */\n\n    uvmx = (uvmx & 3) << 1;\n\n    uvmy = (uvmy & 3) << 1;\n\n    if (!v->rnd) {\n\n        h264chroma->put_h264_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy);\n\n        h264chroma->put_h264_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy);\n\n    } else {\n\n        v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy);\n\n        v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy);\n\n    }\n\n}\n", "idx": 7168, "substitutes": {"v": ["get", "nov", "vp", "view", "p", "dev", "tv", "vi", "cv", "f", "vc", "l", "vs", "it", "qv", "inv", "q", "vt", "ev", "w", "vv", "version", "nv", "h", "ve", "vr", "o", "qu", "vector", "b", "ver", "g", "rev", "vd", "y", "vm", "e", "this", "browser", "m", "iv", "conv", "sv", "ov", "window", "x", "lv", "c", "vol", "vis", "video", "cache", "z", "V", "wire", "av", "va", "uv"], "dir": [" direction", "deg", "dr", "ptr", "init", "inter", "dt", "dy", "dm", "d", "ind", "dim", "rot", "id", "draw", "col", "direction", "cont", "path", "file", "dc", "Dir", "loc", "trans", "depth", "kind", "di", "dirty", "DIR", "dn", "dial", "driver", "group", "direct", "def", "wd", "manager", " d", "tree", "rad", "ir", "row", "iter", "db", " Dir", "rect", "cond", "det", "rel", "try", "table", "desc", "tri", "dis", "mode", "vol", "grad", "directory", "start", "local", "dep", "cmd"], "s": ["p", "conf", "https", "times", "l", "ns", "sq", "ses", "gs", "stats", "its", "c", "settings", "n", "qs", "sort", "services", "sc", "S", "a", "sp", "vs", "ctx", "ps", "ins", "serv", "w", "less", "ss", "h", "st", "js", "b", "http", "sts", "ts", "ops", "fs", "session", "cpp", "sb", "als", "series", "ats", "sys", "sav", "details", "f", "is", "d", "sam", "bs", "space", "source", "state", "rs", "m", "conv", "bis", "cs", "as", "ls", "t", "os", "sim", "ds", "south", "ms", "spec", "comm", "hs", "ssl", "g", "status", "sv", "sql", "se", "sw"], "h264chroma": ["h264cha", "h264chromas", "h264pixelarea", "h264chromA", "h_roma", "h265chromarea", "h264chromarea", "h_chroma", "h264chiparea", "h264pixelas", "h_romarea", "h265chromas", "h264chipas", "h264roma", "h264chipa", "h264comA", "h264romas", "h_chromarea", "h_romA", "h_chromA", "h264pixelca", "h_romas", "h264coma", "h_chromas", "h264pixela", "h264comas", "h264romarea", "h265chroma", "h264chas", "h264chca", "h264chipA", "h264comarea", "h264charea", "h264romA", "h265chromca", "h264chromca"], "srcY": ["srcXY", "sourceXY", "sourceZ", "rcX", "srcX", "rcY", "rcXY", "srcZ", " srcXY", " srcZ", "rcZ", "sourceY", "sourceX", " srcX"], "srcU": ["sourceUI", "secureM", "sourceM", "srcUI", "srcUV", "sourceU", "secureUI", "srcM", "sourceUV", "secureU", " srcUI", " srcM", "secureUV", " srcUV"], "srcV": ["sourceV", " srcG", "rcY", "sourceG", "sourceU", "srcG", "sourceY", "rcV", "rcG", "rcU"], "dxy": ["sdwx", "nwy", "pxy", "sdxf", "sdwy", "pwx", "nxy", "dxf", "pwy", "pxf", "dwx", "sdxy", "dwy", "nxf", "nwx"], "mx": ["py", "mmm", "mk", "ms", "wx", "mes", "zx", "mi", "mp", "hz", "ml", "xml", "txt", "ox", "phy", "px", "mys", "mis", "colm", "mem", "mt", "ey", "rx", "memory", "yx", "md", "mn", "mb", "nz", "mac", "axy", "y", "mmmm", "ma", "wm", "xy", "mie", "MX", "m", "xs", "mm", "yz", "x", "tm", "xx", "tx", "sys", "yy", "mouse", "mc", "mic", "mr"], "my": ["py", "why", "mon", "Mi", "mmm", "ame", "ty", "mk", "ms", "ym", "mi", "MI", "me", "ies", "TY", "ady", "fy", "omy", "phy", "ox", "pm", "ky", "pty", "mine", "ys", "mys", "gy", "mis", "colm", "mem", " MY", "ias", "him", "ery", "memory", "mn", "axy", "y", "mmmm", "ny", "mid", "cy", "ma", "mie", "sym", "m", "maybe", "ami", "ody", "try", "mm", "zzy", "mire", "ony", "My", "sky", "am", "ury", "MY", "rey", "yes", "mic", "vy"], "uvmx": ["uvix", "uvmware", "uvpy", " umy", "ouvmx", "uvk", " uvmrx", " uvmn", " umn", "ucvox", "uvmk", "upmix", " uvmox", "uvpx", "uvware", "upmware", "uVMy", "uvx", "upmk", "ouvx", "uvmix", "ucvware", " uVMx", "ucvx", "ucvy", " umx", "uVMware", " uVMox", "uvimx", "uvmox", "uVMx", "uvimware", "uVMrx", "ouvmix", "ouvware", "ouvk", "uvimy", "uvmrx", "uVMn", "uvprx", "ouvmware", "uvmn", " umrx", "ouvix", "umrx", " uVMy", "uvimox", "umn", "umy", "uvimk", " uvmware", "uVMox", " uVMware", "uvimix", "umx", "ouvmk", "uvpn", "upmx"], "uvmy": ["vvmy", "uvpy", "uummm", "nvy", "uugy", "uvny", "uumx", "udgy", "udmx", "uvmi", "uimy", "vvmis", "vvmx", "udmy", "uumis", "uumy", "nvmi", "udpy", "avmy", "uupy", "uimx", "cvmi", "uumm", "uuny", "avgy", "nvgy", "uumi", "uipy", "ucgy", "ucmi", "uvmm", "uumpy", "vvpy", "avy", "uummy", "uvgy", "uvmis", "uummx", "cvmx", "udny", "cvmy", "cvny", "ummm", "udmi", "nvmy", "uvy", "umgy", "ummx", "uimis", "ummy", "avmi", "udmm", "ucmy", "ucy"], "src_x": ["source_ex", "source_X", "src_X", "source_x", "src_ex"], "src_y": ["src_my", "rc_Y", "rc_my", "src2my", "src2Y", "rc_y", "src2y", "rc_x", "src2x", "src_Y"], "uvsrc_x": ["uvsrc_ex"], "uvsrc_y": ["uvsource_y", "uvsource_Y", "uvsource_xy", "uvsource_x", "uvsrc_xy", "uvsrc_Y"], "i": ["ia", "init", "li", "p", "sim", "ki", "bi", "f", "is", "id", "ind", "ii", "ini", "mi", "ix", "tim", "me", "it", "ic", "gu", "\u0438", "hi", "uri", "si", "di", "h", "gi", "io", "in", "ri", "chain", "ip", "iq", "ji", "b", "index", "info", "point", "g", "ui", "multi", "iu", "xi", "ij", "zi", "status", "ti", "ci", "m", "iy", "ai", "pi", "im", "qi", "I", "phi", "x", "c", "cli", " ii"], "luty": ["sluta", "sluti", "slut", "lut", "luti", "Luty", " luta", "Luta", " lut", "Lut", "luta", "Luti", " luti", "sluty"], "lutuv": ["lUTuu", "lutuu", "lutui", "lutu", "lUTu", "ludu", " lutuu", " ludui", "ludui", " lutu", "luduu", " lutui", "lUTuv", "luvui", "lUTui", " luduu", "luduv", "luvu", "luvuu", "luvuv", " ludu", " luduv"], "use_ic": ["use2pic", "use_i", " use_ac", "use2ac", " use_i", "use2i", " use_pic", "use_pic", "use2ic", "use_ac"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)\n\n{\n\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n\n\tasm volatile(\n\n\t\t\"movq \"MANGLE(bm01010101)\", %%mm4\\n\\t\"\n\n\t\t\"mov %0, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movq (%1, %%\"REG_a\",4), %%mm0\t\\n\\t\"\n\n\t\t\"movq 8(%1, %%\"REG_a\",4), %%mm1\t\\n\\t\"\n\n\t\t\"movq (%2, %%\"REG_a\",4), %%mm2\t\\n\\t\"\n\n\t\t\"movq 8(%2, %%\"REG_a\",4), %%mm3\t\\n\\t\"\n\n\t\tPAVGB(%%mm2, %%mm0)\n\n\t\tPAVGB(%%mm3, %%mm1)\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\"movq %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm4, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm1\t\t\\n\\t\"\n\n\t\t\"movd %%mm0, (%4, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movd %%mm1, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"add $4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t: : \"g\" ((long)-width), \"r\" (src1+width*4), \"r\" (src2+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n\t\t: \"%\"REG_a\n\n\t);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tdstU[i]= (src1[4*i + 1] + src2[4*i + 1])>>1;\n\n\t\tdstV[i]= (src1[4*i + 3] + src2[4*i + 3])>>1;\n\n\t}\n\n#endif\n\n}\n", "idx": 7174, "substitutes": {"dstU": ["dstUV", "drcUt", " dstUt", "dcrUt", " dsetUV", "dcrUs", "lndUp", "DSTUt", " dstUV", "dSTEU", "DstU", " dstUs", "dcrU", "dstUp", "dndUT", "lndUT", "ddestU", "dSTU", "ddestUT", " dsetU", "drcEU", "dndUV", "dsetUs", "lndU", "lstU", "dndUs", "lstUp", "dstsU", "dndU", "dndUt", "dstUt", "dSTUp", "dsetU", "dcrUV", "dSTUT", "ddestUp", "DSTEU", "drcU", "DstUt", "DstEU", "DSTU", "dndUp", "dstEU", "lstUT", "dstsEU", "dstUT", "dsetUV", "dstUs", "dstsUt", "dSTUt", "dsetUt", " dsetUt", " dsetUs"], "dstV": ["dSTTV", "dLstIV", "DstP", "dLstoreG", "dLstoreVA", "dLstoreIV", "DstG", "dSTP", "dstoreG", "DstV", "dreatV", "dSTR", "dSTG", "dputV", "dndR", "dstM", "dLstG", "dostG", " dSTTV", "dstoreVA", "dstoreV", "dreatEv", "dstoreIV", "DndR", "dSTM", "dstEv", "dreatTV", " dSTM", "dstR", "destP", "dLstV", "dLstVA", " dSTV", "dostV", "dputEv", " dstTV", "dndP", "dostVA", "DstR", "destR", "DndG", "dndG", " dstM", "destG", "dstVA", "dndVA", "dputM", " dstEv", "DndP", "dputTV", "dndV", "dostIV", " dSTEv", "dreatM", "DndV", "dstG", "dstIV", "destV", "dSTV", "dSTEv", "dstP", "dndIV", "dLstoreV", "dstTV"], "src1": ["source3", "usr1", "source0", "usr001", "pse1", "source1", "stock21", "src21", "rc01", "usrOne", "src01", "rc001", "rc0", "source2", " src01", "srcOne", "rc3", " srcOne", "pse3", " src15", " src0", "stock1", "src001", "rc1", " src21", "pse15", "stock15", "src15", "src3", "pse21", "src0", " src001", "rc2", "rcOne", "usr2", " src3", "source01", "stock3"], "src2": ["usc1", "usrtwo", "source3", "usr1", " src512", "rc512", "srcTwo", "source1", "src512", "srctwo", "rc0", "src02", "supptwo", "sync2", "source2", "rc3", " src0", "usc02", "syncTwo", "sync1", "supp02", "supp1", "usc512", "sync0", "rc1", "supp2", "rctwo", " srcTwo", "rc02", "usc2", "src3", "src0", "rc2", " src02", "usr2", "rcTwo", " src3", "usr02", "sourceTwo"], "i": ["key", "init", " I", "t", "li", "ei", " err", "p", "sim", "ki", "bi", "is", "id", "ind", "ii", "v", "ini", "sp", "data", "mi", "ix", " pi", "it", "me", "ic", "gu", "\u0438", "si", "oi", "di", "j", "depth", "gi", "o", "span", "ri", "in", "attr", "chain", "ip", "index", "name", "info", "ui", "multi", "M", "iu", "xi", "ij", "zi", "status", " ti", "ti", "ci", "m", "print", "um", "ami", "ai", "pi", " j", "x", "I", "qi", "phi", "cli", "us", "n", "err", " ii", "batch"]}}
{"project": "FFmpeg", "commit_id": "ba15aab4a4a296c632bd8d3428b002055109c7d1", "target": 0, "func": "static int mtv_read_header(AVFormatContext *s)\n\n{\n\n    MTVDemuxContext *mtv = s->priv_data;\n\n    AVIOContext   *pb  = s->pb;\n\n    AVStream        *st;\n\n    unsigned int    audio_subsegments;\n\n\n\n    avio_skip(pb, 3);\n\n    mtv->file_size         = avio_rl32(pb);\n\n    mtv->segments          = avio_rl32(pb);\n\n    avio_skip(pb, 32);\n\n    mtv->audio_identifier  = avio_rl24(pb);\n\n    mtv->audio_br          = avio_rl16(pb);\n\n    mtv->img_colorfmt      = avio_rl24(pb);\n\n    mtv->img_bpp           = avio_r8(pb);\n\n    mtv->img_width         = avio_rl16(pb);\n\n    mtv->img_height        = avio_rl16(pb);\n\n    mtv->img_segment_size  = avio_rl16(pb);\n\n\n\n    /* Calculate width and height if missing from header */\n\n\n\n    if(mtv->img_bpp>>3){\n\n    if(!mtv->img_width && mtv->img_height)\n\n        mtv->img_width=mtv->img_segment_size / (mtv->img_bpp>>3)\n\n                        / mtv->img_height;\n\n\n\n    if(!mtv->img_height && mtv->img_width)\n\n        mtv->img_height=mtv->img_segment_size / (mtv->img_bpp>>3)\n\n                        / mtv->img_width;\n\n    }\n\n    if(!mtv->img_height || !mtv->img_width || !mtv->img_segment_size){\n\n        av_log(s, AV_LOG_ERROR, \"width or height or segment_size is invalid and I cannot calculate them from other information\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    avio_skip(pb, 4);\n\n    audio_subsegments = avio_rl16(pb);\n\n\n\n    if (audio_subsegments == 0) {\n\n        avpriv_request_sample(s, \"MTV files without audio\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    mtv->full_segment_size =\n\n        audio_subsegments * (MTV_AUDIO_PADDING_SIZE + MTV_ASUBCHUNK_DATA_SIZE) +\n\n        mtv->img_segment_size;\n\n    mtv->video_fps         = (mtv->audio_br / 4) / audio_subsegments;\n\n\n\n    // FIXME Add sanity check here\n\n\n\n    // all systems go! init decoders\n\n\n\n    // video - raw rgb565\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if(!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, mtv->video_fps);\n\n    st->codec->codec_type      = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id        = AV_CODEC_ID_RAWVIDEO;\n\n    st->codec->pix_fmt         = AV_PIX_FMT_RGB565BE;\n\n    st->codec->width           = mtv->img_width;\n\n    st->codec->height          = mtv->img_height;\n\n    st->codec->sample_rate     = mtv->video_fps;\n\n    st->codec->extradata       = av_strdup(\"BottomUp\");\n\n    st->codec->extradata_size  = 9;\n\n\n\n    // audio - mp3\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if(!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, AUDIO_SAMPLING_RATE);\n\n    st->codec->codec_type      = AVMEDIA_TYPE_AUDIO;\n\n    st->codec->codec_id        = AV_CODEC_ID_MP3;\n\n    st->codec->bit_rate        = mtv->audio_br;\n\n    st->need_parsing           = AVSTREAM_PARSE_FULL;\n\n\n\n    // Jump over header\n\n\n\n    if(avio_seek(pb, MTV_HEADER_SIZE, SEEK_SET) != MTV_HEADER_SIZE)\n\n        return AVERROR(EIO);\n\n\n\n    return 0;\n\n\n\n}\n", "idx": 7177, "substitutes": {"s": ["sc", "t", "os", "S", "p", "ds", "is", "a", "ms", "v", "sp", "r", "ps", "ctx", "ins", "w", "set", "ss", "h", "aws", "bs", "i", "ns", "js", "hs", "b", "sq", "sys", "an", "ses", "sts", "scl", "rs", "gs", "ts", "es", "e", "stats", "m", "fs", "sv", "cs", "as", "c", "ls", "ats", "n", "qs"], "mtv": ["modtv", "mty", "mmvi", "esmTV", "vmv", "gmfont", "amvv", "bmvt", "remnexus", "mti", "remtv", "cmuffy", "mtw", "manvert", "mtg", "Mvv", "remtar", "minvt", "remtif", "gtv", "wmvv", "mttv", "mmobile", "hmvv", "emvt", "wmtar", "dmyout", "gmmobile", "mdtek", "esmtv", "mtar", "gmTV", "revolt", "cmwire", "mailtv", "imvolt", "smrss", "pmvv", "cmtg", "cmv", "moduleverb", "emvert", "emfont", "bmtv", "mv", "MTV", "gmvt", "vmtek", "lemvt", "amyout", "mantar", "esmtek", "remvi", "amvi", "rmyout", "mrss", "fmyout", "pmtar", "rmtek", "rmrss", "retv", "gmwire", "imtg", "remvv", "hmyout", "reyout", "remyout", "amtif", "mettw", "smtar", "fmtemp", "Mti", "rmvolt", "mtvt", "pmfont", "amnexus", "mirti", "dmrss", "amvolt", "mtvi", "matvolt", "mvert", "minvv", "amvt", "mantw", "mailvolt", "pmtek", "modtek", "lemtv", "mtk", "mcoord", "emtar", "amfont", "lemouch", "emyout", "imyout", "mtt", "gvolt", "emvolt", "omtif", "Mtt", "mvent", "matmobile", "remvt", "gmyout", "gyout", "amtip", "rmTV", "remvert", "mailtw", "bmty", "bmrss", "mtouch", "mintek", "onyout", "smyout", "mantv", "mtip", "cmverb", "onvent", " mTV", "emwire", "smvolt", "cmyout", "hmvolt", "mtek", "mtemp", "mmvt", "gmrss", "remti", "miryout", "rmtv", "remver", "mttar", "Mv", "retar", "emvv", "lv", "hmtemp", "dmty", "cmtar", "rmvent", "lemty", "mtvv", "pmtif", "omtar", "cmtv", "dmtv", "mirvt", "gmti", "mdvv", "hmcoord", "muffy", "armtv", "omtv", "mver", "mTV", "emtif", "cmvolt", "mmvolt", "esmtip", " mtek", "mmouch", "emmobile", "hmvt", "mettv", "mvolt", "emtk", "smvt", "armtar", "armvolt", "modulev", "mouch", "vmfont", "modvolt", "esmvolt", "ontv", "mvv", "remvolt", "lTV", "hmuffy", "armvt", "imtar", "gvt", "armfont", "rmmobile", "remobile", "vmtv", "mettip", "retk", "mwire", "cmtek", "gmtt", "smtv", "armwire", "mmtv", "mmtw", "Mtv", "smmobile", "esmtw", "hmtg", "mnexus", "mirtv", "hmvent", "mmvv", "vmtar", "mverb", "esmti", "ltt", "vmvolt", "mmtar", "mfont", "armnexus", "ammobile", "dmvolt", "ltv", "pmyout", "mvt", "amtv", "mintv", "wmti", "mattv", "moduletv", "mvi", "esmfont", "manvv", "amtar", "gmtar", "mantif", "mailtar", "gmtek", "amwire", " mvolt", "onvolt", "mdtv", "mtif", "imtv", "gmtv", "wmtv", "gmvolt", "hmver", "dmcoord", "remtek", "amtw", "mdvt", "wmvt", "dmtemp", "fmcoord", "wmvolt", "smtk", "wmyout", "hmtek", "hmtv", "lemrss", "amtek", "emtv", "lemtar", "imuffy", "amver", "omvv", "gmv", "cmmobile", "wmTV", "cmfont", "hmvi", "pmtv", "vmverb", "moduletek", "metfont", "modti", "myout", "manvolt", "gmvv", "dmvt", "matwire", "fmtv"], "pb": ["tc", "py", "vp", "pp", "cp", "p", "lb", "pack", "pkg", "td", "cv", "bj", "tf", "lp", "tmp", "PB", "sp", "ctx", "pc", "fb", "mp", "pg", "typ", "wp", "cb", "obj", "pm", "ub", "pa", "port", "pt", "span", "gc", "buff", "bs", "proc", "np", "bb", "emb", "resp", "erb", "buf", "mb", "pr", "peer", "buffer", "fp", "tp", "dp", "jp", "pool", "db", "vm", "um", "gp", "bp", "eb", "snap", "pl", "uf", "lv", "sb", "ob", "tk", "xp", "tab", "rb", "vt", "oa", "wb", "bot"], "st": ["ST", "ust", "sc", "fr", "bt", "sp", "ft", " ss", "sl", "sam", "str", "ss", "ist", "sth", "ast", "so", "mt", "ste", "est", "std", "sts", "rest", "sn", "sv", "ct", "St", "se", "sw"], "audio_subsegments": ["audio_subtelements", "audio_subvegs", "audio_subbegment", "audio_Subbements", "audio_subbegments", "audio_subschelements", "audio_subtements", "audio_subbeges", "audio_subbelements", "audio_subperseges", "audio_subpersegment", "audio_subveges", "audio_subvements", "audio_subsegment", "audio_subbements", "audio_subsegs", "audio_Subsegs", "audio_subtegment", "audio_subtegments", "audio_subschegment", "audio_Subselements", "audio_Subbeges", "audio_Subbegments", "audio_Subsements", "audio_subschegments", "audio_subvegment", "audio_Subsegments", "audio_subschements", "audio_subpersements", "audio_Subsegment", "audio_Subseges", "audio_subsements", "audio_subselements", "audio_subteges", "audio_Subbelements", "audio_subbegs", "audio_subschegs", "audio_Subbegment", "audio_subvegments", "audio_subpersegs", "audio_Subbegs", "audio_subtegs", "audio_subperselements", "audio_subpersegments", "audio_subseges"]}}
{"project": "qemu", "commit_id": "a890643958f03aaa344290700093b280cb606c28", "target": 1, "func": "static bool qht_insert__locked(struct qht *ht, struct qht_map *map,\n\n                               struct qht_bucket *head, void *p, uint32_t hash,\n\n                               bool *needs_resize)\n\n{\n\n    struct qht_bucket *b = head;\n\n    struct qht_bucket *prev = NULL;\n\n    struct qht_bucket *new = NULL;\n\n    int i;\n\n\n\n    do {\n\n        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {\n\n            if (b->pointers[i]) {\n\n                if (unlikely(b->pointers[i] == p)) {\n\n                    return false;\n\n                }\n\n            } else {\n\n                goto found;\n\n            }\n\n        }\n\n        prev = b;\n\n        b = b->next;\n\n    } while (b);\n\n\n\n    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));\n\n    memset(b, 0, sizeof(*b));\n\n    new = b;\n\n    i = 0;\n\n    atomic_inc(&map->n_added_buckets);\n\n    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {\n\n        *needs_resize = true;\n\n    }\n\n\n\n found:\n\n    /* found an empty key: acquire the seqlock and write */\n\n    seqlock_write_begin(&head->sequence);\n\n    if (new) {\n\n        atomic_rcu_set(&prev->next, b);\n\n    }\n\n    b->hashes[i] = hash;\n\n    /* smp_wmb() implicit in seqlock_write_begin.  */\n\n    atomic_set(&b->pointers[i], p);\n\n    seqlock_write_end(&head->sequence);\n\n    return true;\n\n}\n", "idx": 7191, "substitutes": {"ht": ["hd", "hm", "host", "gt", "ch", "th", "bh", "tt", "bt", "bm", "ach", "v", "att", "mu", "hip", "ld", "hold", "dq", "h", "handle", "dh", "ap", " h", "mt", "sh", "help", "hw", "ct", "vt"], "map": ["view", "master", "cp", "conf", "pack", "host", "form", "app", "apper", "policy", "image", "mp", "list", "sm", "set", "k", "h", "lock", "Map", "ap", "metadata", "mem", "mt", "dict", "maps", "index", "tree", "sh", "mg", "ape", "pool", "m", "table", "bridge", "mm", "window", "header", "mask", "pl", "MAP", "block", "man", "shape", "load", "cache"], "head": ["top", "ptr", "hd", "view", "master", "doc", "old", "commit", "host", "init", "th", "df", "heading", "data", "ad", "parent", "Head", "hold", "one", "headed", "h", "he", "lock", "before", "history", "link", "off", "dict", "mem", "root", "index", "name", "md", "heads", "tail", " HEAD", "front", "mit", "this", "holder", "stock", "HEAD", "help", "headers", "header", "window", "first", "cmd", "back", "block", "start", "ack", "cache", "next", "stream", "run"], "p": ["ptr", "vp", "pp", "t", "cp", "rep", "pkg", "lp", "d", "v", "sp", "ps", "pc", "it", "mp", "ping", "q", "wp", "w", "pa", "h", "j", "pad", "o", "ap", "ip", "np", "g", "pb", "fp", "tp", "perm", "op", "jp", "m", "up", "P", "bp", "part", "pid", "c", "pos", "n", "u", "pre"], "hash": ["key", "kh", "html", "oh", "ch", " hashing", "prime", "bh", "her", "id", "sum", "data", "length", "address", "prop", "handle", "h", "chip", "proof", "lock", "dh", "ho", "ap", " h", "ah", "shift", "sh", "type", "ref", "tag", "height", "cmp", "match", "holder", "addr", "Hash", "sha", "ash", "block"], "needs_resize": ["needs_resization", "needs_reization", "needs_oversiz", "needs_resign", "needs_renign", "needs_fixize", "needs_resiz", "needs_fixign", "needs_reizing", "needs_windowsiz", "needs_windowsign", "needs_reshiz", "needs_oversign", "needs_reize", "needs_renization", "needs_reshign", "needs_ressize", "needs_renize", "needs_reiz", "needs_oversize", "needs_windowsization", "needs_resizing", "needs_reign", "needs_fixiz", "needs_fixizing", "needs_reshizing", "needs_oversization", "needs_windowsize", "needs_rensize", "needs_reshization", "needs_reshsize", "needs_reshize"], "b": ["bo", "reb", "t", "bound", "lb", "bh", "nb", "bt", "bi", "a", "bm", "d", "ab", "v", "f", "l", "buf", "r", "fb", "bar", "bd", "cb", "w", "h", "j", "br", "o", "buff", "body", "bs", "B", "bb", "g", "lib", "pb", "mb", "bl", "gb", "ib", "buffer", "y", "go", "e", "db", "m", "bg", "blue", "bit", "bridge", "bis", "base", "eb", "bp", "sb", "c", "ob", "bin", "back", "s", "n", "rb", "bc", "wb", "batch", "be"], "prev": ["Prev", "ptr", "vp", "pp", "old", "upper", "tmp", "v", "sp", "vs", "mp", "vious", "parent", "cur", "self", "h", "j", "br", "before", "history", "jump", "pres", "root", "current", "adj", "buf", "orig", "rev", "tail", "cmp", "iter", "rel", "reverse", "header", "var", "first", "ren", "next", "pre", "av", "last"], "new": ["existing", "t", "old", "created", "a", "d", "news", "v", "r", "normal", "to", "fresh", "known", "parent", "New", "different", "w", "other", "set", "self", "good", "h", "j", "o", "false", "recent", "result", "root", "name", "current", "g", "found", "pb", "NEW", "now", "end", "un", "m", "missing", "snap", "first", "create", "from", "null", "unique", "n", "add", "next", "out"], "i": ["ori", "id", "ii", "ini", "it", "hi", "di", "gi", "iq", "y", "remote", "iter", "ci", "ami", " j", "ims", "n", " ii", " I", "ei", "ski", "ix", "list", "ic", "si", "j", "ji", "index", "zi", "try", "iri", "pi", "x", "phi", "is", "ind", "mi", "ri", "io", "chain", "ex", "ip", "multi", "print", " ti", "ti", "e", "m", "ai", "im", "I", "s", " m", "init", "t", "li", " multi", "sim", "fi", "bi", "ms", "v", "me", "\u0438", "uri", "o", "in", "info", "g", "ui", "iu", "xi", "ij", "status", "client", "batch"]}}
{"project": "FFmpeg", "commit_id": "6e1b1a27a4034c578018d5042b3c8228278c4cd6", "target": 1, "func": "static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)\n\n{\n\n    pkt->data      = NULL;\n\n    pkt->side_data = NULL;\n\n    if (pkt->buf) {\n\n        AVBufferRef *ref = av_buffer_ref(src->buf);\n\n        if (!ref)\n\n            return AVERROR(ENOMEM);\n\n        pkt->buf  = ref;\n\n        pkt->data = ref->data;\n\n    } else {\n\n        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);\n\n    }\n\n#if FF_API_DESTRUCT_PACKET\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    pkt->destruct = dummy_destruct_packet;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    if (pkt->side_data_elems && dup)\n\n        pkt->side_data = src->side_data;\n\n    if (pkt->side_data_elems && !dup) {\n\n        return av_copy_packet_side_data(pkt, src);\n\n    }\n\n    return 0;\n\n\n\nfailed_alloc:\n\n    av_destruct_packet(pkt);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 7204, "substitutes": {"pkt": ["apptext", "apck", "pkg", "perkt", "appacket", "Packet", "ptx", "pct", " pux", "path", "Pwk", "Pmsg", "apacket", "partnt", "ppet", "apet", "pck", "appkt", "jppt", "tpkg", "Ptext", "appnt", "Ptx", "perwk", "phpkt", "tmsg", "tkt", "pet", "hnt", "peracket", "apkt", "tpnt", "ppt", "pth", "Pkg", "pdr", "ppck", "hacket", "phpdr", "jpkt", " pth", "pux", "Ppt", "payth", "paynt", " pqt", " ptx", "paux", "Pcmd", " packet", "jpacket", "payux", "phpacket", "tpkt", "patx", "Pet", "pqt", "perkg", "pernt", "hkt", "pcmd", "pnt", "apgt", " ppt", " pwk", "Pgt", "tacket", "phpcmd", "Pnt", "partct", "packet", "ptext", "tnt", "paqt", "pgt", "tpacket", "apnt", "partkt", " pcmd", "apqt", "jpnt", " pct", "Pck", "Pct", "paycmd", "Pdr", "hdt", " pnt", "partacket", " ptext", " pdt", "apct", "payacket", " pdr", " pgt", "paacket", "Pkt", "pakt", "pwk", "pmsg", "ppkt", "pant", "Pdt", "paykt", " pmsg", "pdt", "ppnt"], "src": ["rc", "sc", "RC", "syn", "ser", "pkg", "tmp", "inner", "sec", "dest", "sel", "sup", "sp", "SOURCE", "cont", "ins", "ctx", "spec", "sync", "rl", "inst", "sub", "obj", "loc", "cur", "via", "st", "supp", "sr", "source", "proc", "usr", "sq", "comp", "rs", "inc", "rest", "now", "sn", "cmp", "iv", "rel", "pri", "addr", "sb", "aux", "rt", "s", "rob", "start", "ack", "sys", "urg", "sur", "img"], "dup": ["dug", "depi", "depp", "Dupa", "dev", "duP", "duv", "neg", "ameph", "dupp", " dupa", " duP", " dug", "DuP", "Duph", "amepp", "keps", "neP", "deph", "drav", "dupi", "duph", "dupa", "deps", "Dup", "kep", "drapi", "nep", "Dupp", "draps", "dups", "Dupi", "Dug", "amep", "drap", "kev", "nepa", "dep", "kepi", "amepi"], "ref": ["ptr", "af", "rc", "co", "conf", "inter", "tmp", "f", "use", "grab", "id", "func", "r", "re", "col", "q", "obj", "cb", "val", "prop", "req", "k", "br", "ret", "mem", "resp", "def", "REF", "index", "info", "buf", "mb", "range", "new", "pool", "cmp", "rec", "rel", "addr", "eb", "Ref", "reference", "uf", "c", "ob", "ro", "ef", "null", "alt", "tab", "cache", "lib"]}}
{"project": "qemu", "commit_id": "aa8f057e74ae08014736a690ff41f76c756f75f1", "target": 0, "func": "static void virtio_crypto_instance_init(Object *obj)\n\n{\n\n    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);\n\n\n\n    /*\n\n     * The default config_size is sizeof(struct virtio_crypto_config).\n\n     * Can be overriden with virtio_crypto_set_config_size.\n\n     */\n\n    vcrypto->config_size = sizeof(struct virtio_crypto_config);\n\n\n\n    object_property_add_link(obj, \"cryptodev\",\n\n                             TYPE_CRYPTODEV_BACKEND,\n\n                             (Object **)&vcrypto->conf.cryptodev,\n\n                             virtio_crypto_check_cryptodev_is_used,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);\n\n}\n", "idx": 7213, "substitutes": {"obj": ["bo", "fr", "t", "phys", "oss", "elt", "pkg", "tmp", "bh", "mk", "kr", "org", "nt", "cont", "ctx", "it", "inst", "typ", "txt", "kt", "object", "j", "o", "pt", "attr", "bs", "js", "resp", "po", "act", "onet", "y", "ocr", "cmp", "xy", "ck", "obs", "instance", "rect", "res", "osi", "hw", "expr", "Obj", "ob", "obo", "tk", "obb", "oc", "cmd"], "vcrypto": ["vccryptpo", "vcCryptpo", "vcrototo", "vcryptoto", "cvroton", "vccryptoo", "VCcryptso", "VCcryptho", "VCrypto", "vccryptho", "cvryptO", "vcryptho", "vcprotpo", "vcrotso", "vcryptiono", "vcproto", "VCryptho", "vcryptO", "VCcrypto", "vcrotoo", "vcryptoo", "vcCryptoo", "vcredo", "vcroto", "vcprotho", "vcCrypton", "cvrototo", "VCcryptpo", "vcCrypto", "vcryptionho", "VCryptoo", "vccryptso", "vcryptso", "vcroton", "VCryptso", "vcprotoo", "vcryptionoo", "cvrotO", "vcrypton", "VCryptpo", "vcredoto", "cvryptoto", "vcCryptso", "vcryptpo", "vcCryptoto", "cvroto", "cvrypton", "vcryptionpo", "vcCryptO", "vcredO", "vcrotpo", "vcredon", "vccrypto", "cvrypto", "VCcryptoo", "vcrotO"]}}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_sh4_handle_mmu_fault(CPUState * env, target_ulong address, int rw,\n\n\t\t\t     int mmu_idx, int is_softmmu)\n\n{\n\n    target_ulong physical;\n\n    int prot, ret, access_type;\n\n\n\n    access_type = ACCESS_INT;\n\n    ret =\n\n\tget_physical_address(env, &physical, &prot, address, rw,\n\n\t\t\t     access_type);\n\n\n\n    if (ret != MMU_OK) {\n\n\tenv->tea = address;\n\n\tswitch (ret) {\n\n\tcase MMU_ITLB_MISS:\n\n\tcase MMU_DTLB_MISS_READ:\n\n\t    env->exception_index = 0x040;\n\n\t    break;\n\n\tcase MMU_DTLB_MULTIPLE:\n\n\tcase MMU_ITLB_MULTIPLE:\n\n\t    env->exception_index = 0x140;\n\n\t    break;\n\n\tcase MMU_ITLB_VIOLATION:\n\n\t    env->exception_index = 0x0a0;\n\n\t    break;\n\n\tcase MMU_DTLB_MISS_WRITE:\n\n\t    env->exception_index = 0x060;\n\n\t    break;\n\n\tcase MMU_DTLB_INITIAL_WRITE:\n\n\t    env->exception_index = 0x080;\n\n\t    break;\n\n\tcase MMU_DTLB_VIOLATION_READ:\n\n\t    env->exception_index = 0x0a0;\n\n\t    break;\n\n\tcase MMU_DTLB_VIOLATION_WRITE:\n\n\t    env->exception_index = 0x0c0;\n\n\t    break;\n\n\tcase MMU_IADDR_ERROR:\n\n\tcase MMU_DADDR_ERROR_READ:\n\n\t    env->exception_index = 0x0c0;\n\n\t    break;\n\n\tcase MMU_DADDR_ERROR_WRITE:\n\n\t    env->exception_index = 0x100;\n\n\t    break;\n\n\tdefault:\n\n\t    assert(0);\n\n\t}\n\n\treturn 1;\n\n    }\n\n\n\n    address &= TARGET_PAGE_MASK;\n\n    physical &= TARGET_PAGE_MASK;\n\n\n\n    return tlb_set_page(env, address, physical, prot, mmu_idx, is_softmmu);\n\n}\n", "idx": 7222, "substitutes": {"env": ["et", "conf", "estate", "conn", "txt", "cur", "ah", "vm", "db", "operator", "er", "cmd", "event", "ptr", "query", "gear", "dev", "door", "environment", "vs", "ctx", "worker", "inv", "obj", "ew", "en", "ve", "eng", "esm", "proc", "ner", "answer", "code", "ent", "sb", "context", "man", "rb", "shell", "entry", "config", "esc", "policy", "cb", "nv", "era", "die", "here", "state", "manager", "e", "end", "te", "engine", "Environment", "ef", "eh", "ev", "vt", "init", "vp", "cv", "v", "ec", "enter", "vv", "server", "set", "console", "buf", "network", "store", "erd", "cfg", "global", "sv", "window", "desc", "ener", "see"], "address": ["ptr", "request", "ace", "order", "host", "eth", "controller", "resource", "a", "private", "length", "r", "path", "error", "position", "account", "connection", "map", "server", "object", "port", "description", "read", "attribute", "device", "adr", "location", "shape", "ip", "pointer", "result", "index", "name", "memory", "current", "trace", "password", "response", "network", "interface", "ref", "buffer", "command", "type", "range", "record", "page", "ase", "domain", "pair", "addr", "table", "service", "Address", "reference", "route", "message", "start", "context", "add", "array", "value", "event", "action"], "rw": ["ptr", "rew", "seek", "work", "resource", "r", "worker", "aw", "wa", "wer", "wp", "w", "rh", "ew", "word", "mem", "RW", "write", "rar", "rf", "wind", "row", "alloc", "wrap", "nw", "rd", "wr", "addr", "hw", "ram", "ro", "writer", "rt", "rb", "wb", "sw"], "mmu_idx": ["mmu__idk", "mmu_idf", "mmu_ridx", "mmu_isdy", "mmu_idxf", "mmu__midy", "mmu__idy", "mmu_indx", "mmu_idk", "mmu_isdxf", "mmu__midxf", "mmu_Idxf", "mmu_indy", "mmu_midy", "mmu__idxf", "mmu_ridy", "mmu_Idx", "mmu_idy", "mmu__midf", "mmu__midx", "mmu_Idy", "mmu_ridxf", "mmu_midxf", "mmu_midx", "mmu_ridf", "mmu__idf", "mmu_midf", "mmu_isdx", "mmu_Idf", "mmu_indk", "mmu__idx", "mmu_indxf", "mmu_isdk"], "is_softmmu": ["is_softmmx", "is_softmcu", "is_hardmmu", "is_softmemus", "is_hardmmx", "is_softMMcu", "is_softmemx", "is_softmcus", "is_softmodeus", "is_softmmus", "is_softmemu", "is_softmodeut", "is_softmmut", "is_hardmmut", "is_softmodex", "is_softmmcu", "is_softmccu", "is_softMMus", "is_softmemut", "is_softmodeu", "is_hardmmus", "is_softMMu", "is_hardmmcu"], "physical": ["restricted", "ptr", "vp", "phys", "p", "primary", "total", "pure", "host", "config", "binary", "resource", "private", "real", "path", "virtual", "protected", "prefix", "native", "phy", "reported", "Physical", "server", "port", "read", "attribute", "ip", "pointer", "memory", "pn", "readable", "current", "net", "information", "operation", "network", "type", "target", "tp", "remote", "print", " reference", "variable", " pointer", "relative", "home", "personal", " hardware", "phone", "basic", "reference", "external", "accessible", "secondary", " protocol", "localhost", "encrypted", "local", "public"], "prot": ["tif", "ptr", "phys", "p", "primary", "eth", "tf", "controller", "rot", "att", "ocol", "col", "channel", "pc", "ft", " proto", "virtual", "protected", "typ", "chron", "phy", "version", "prop", "Prot", "pro", "port", "method", "format", "ht", "ip", "pb", "net", "type", "password", "rf", "ref", "tp", "status", "inet", "pattern", "pat", "iot", "tech", " protocol", "pos"], "ret": ["ptr", "deg", "out", "git", "t", "rc", "p", "reset", "inter", "gt", "eth", "elt", "lit", "pert", "RET", "rot", "att", "nt", "re", "cont", "Ret", "hash", "ft", "virtual", "rets", "pas", "ext", "cert", "val", "port", "sat", "mem", "mt", "result", "resp", "def", "nz", "response", "rev", "ref", "rf", "rest", "status", "len", "jp", "res", "tr", "ter", "addr", "test", "tech", "back", "alt", "reply", "virt", "rt", "vt", "err", "cmd"], "access_type": ["accessitytype", " access_typ", "access00type", "accessureType", "access00ype", "access_typ", " access_TYPE", "Access_ype", "accessuretimeout", "access_token", "access00TYPE", "access00Type", "accessuretyp", "access_ype", " access_Type", "accessureTYPE", "Access_TYPE", "Access_type", "access_timeout", "accessitytimeout", "Access_Type", "accessitytyp", "accessuretype", " access_token", "accessityType", " access_timeout", "accessuretoken", "access_Type", "access_TYPE"]}}
{"project": "qemu", "commit_id": "40dfc16f5fe0afb66f9436718781264dfadb6c61", "target": 1, "func": "static int virtio_blk_device_exit(DeviceState *dev)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIOBlock *s = VIRTIO_BLK(dev);\n\n#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE\n\n    remove_migration_state_change_notifier(&s->migration_state_notifier);\n\n    virtio_blk_data_plane_destroy(s->dataplane);\n\n    s->dataplane = NULL;\n\n#endif\n\n    qemu_del_vm_change_state_handler(s->change);\n\n    unregister_savevm(dev, \"virtio-blk\", s);\n\n    blockdev_mark_auto_del(s->bs);\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 7243, "substitutes": {"dev": ["hd", "doc", "de", "th", "ds", "conn", "priv", "d", "v", "att", "data", "nt", "spec", "Dev", "ad", "scan", "dd", "serv", "w", "watch", "pro", "nv", "adv", "pad", "device", "pt", "ve", "mem", "proc", "def", "DEV", "ver", "prom", "buf", "md", "g", "serial", "cam", "iv", "det", "tr", "test", "hw", "tm", "dis", "env", "des", "go", "ev", "cmd", "dem"], "vdev": [" vdi", "vdevice", "vdi", " vdet", "wev", "vmdet", "wdevice", "whw", "wdev", "vtdi", "vtdev", "vmdev", "uvev", "vtdet", "vhw", "vmdi", "vdet", " vev", "uvdev", " vdevice", "uvhw", "vev", " vhw", "uvdevice"], "s": ["t", "S", "p", "ds", "details", "f", "is", "a", "ms", "l", "v", "sp", "r", "vs", "ps", "spec", "ins", "sm", "w", "ss", "self", "j", "aws", "comm", "h", "bs", "i", "js", "ns", "hs", "b", "sq", "g", "ses", "sts", "rs", "gs", "ts", "es", "stats", "m", "comments", "fs", "its", "sis", "sv", "cs", "args", "ims", "sb", "c", "ls", "n", "qs", "params", "cmd", "sw", "services"]}}
{"project": "qemu", "commit_id": "0479097859372a760843ad1b9c6ed3705c6423ca", "target": 1, "func": "static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,\n\n                             void *opaque, Error **errp)\n\n{\n\n    uint64_t value;\n\n    MemoryRegion *mr;\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);\n\n\n\n    mr = ddc->get_memory_region(dimm);\n\n    value = memory_region_size(mr);\n\n\n\n    visit_type_uint64(v, name, &value, errp);\n\n}\n", "idx": 7267, "substitutes": {"obj": ["vp", "t", "os", "p", "elt", "pkg", "bh", "tmp", "bj", "org", "func", "nt", "ctx", "cont", "inst", "txt", "object", "h", "o", "vr", "pt", "Object", "js", "ex", "ht", "proc", "np", "resp", "po", "oj", "adj", "act", "onet", "ref", "op", "xy", "opp", "obs", "rect", "instance", "hw", "Obj", "ob", "oid", "sys", "objects", "cmd"], "v": ["vp", "t", "p", "tv", "vi", "cv", "f", "d", "vc", "l", "r", "vs", "qv", "q", "ev", "w", "vv", "nv", "h", "j", "o", "vr", "b", "V", "g", "mint", "m", "iv", "conv", "sv", "c", "vu", "vis", "vt", "av", "vy", "uv"], "name": ["key", "t", "p", "named", "Name", "no", "ame", "id", "data", "path", "prefix", "w", "str", "alias", "nam", "attr", "size", "word", "event", "ident", "def", "info", " prefix", "comment", "property", "type", "len", " key", "ename", "part", "names", "var", "title", "ni", " NAME", " names", " Name", "n", "NAME"], "opaque": ["popcode", "obcode", "Opaque", "opacity", "popaque", "opcode", "Opcode", "Opaz", "opaz", "Opacity", "obacity", "popacity", "obaz", "obaque", "popaz"], "errp": ["lerpad", " errps", "rrp", "cerp", "rrps", "errorpa", "errpa", " errpad", "rrpa", " errP", "lerps", " errpa", "errorps", "lerpa", "rrP", "errpad", "cerps", "errorp", "errorP", "cerpad", "cerpa", "lerp", "errP", "errps"], "value": ["key", "json", "vp", "VAL", "function", "tv", "max", "checked", "sum", "data", "length", "field", "bar", "address", "w", "val", "version", "ue", "description", "port", "attribute", "output", "size", "word", "oval", "result", "index", " Value", "memory", "trace", "property", "type", "buffer", "local", "unit", "scale", "values", "byte", "Value", "VALUE", "message", "array", "total", "see", "widget"], "mr": ["hm", "cm", "rpm", "mar", "bm", "mk", "kr", "rm", "ms", "r", "lr", "rr", "mp", "ml", "rl", "drm", "rh", "pm", "vr", "sr", "adr", "rg", "mt", "usr", "hr", "mn", "shr", "mb", "rs", "rar", "pr", "RM", "ocr", "wm", "mer", "m", "mir", "tr", "Mr", "MR", "gr", "er", "mc"], "dimm": ["digm", "mImm", "edem", "damm", "distamm", "dim", "mimm", "edimm", " damm", "ddimm", "distim", "edImm", " dom", "mom", " digm", "distigm", "mem", "ddim", " dem", " dim", "dom", "edom", " dImm", "distimm", "dImm", "ddigm", "ddamm", "dem"], "ddc": [" ddfc", "dedc", "dedfc", "tdC", "eedca", "tdc", "eedC", "tdcs", " ddlc", "ddslc", "ddlc", "ddC", "tdfc", "dedC", "ddca", " ddC", " ddca", "dedcs", "eedc", "eedlc", "ddsca", "ddsC", "ddcs", "ddsc", " ddcs", "ddfc"]}}
{"project": "qemu", "commit_id": "821303f59b63ab832f0921f070db55e95bb21858", "target": 1, "func": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n                             uint32_t token, uint32_t nargs, target_ulong args,\n                             uint32_t nret, target_ulong rets)\n{\n    if ((token >= TOKEN_BASE)\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n        if (call->fn) {\n            call->fn(spapr, token, nargs, args, nret, rets);\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n    rtas_st(rets, 0, -3);\n    return H_PARAMETER;", "idx": 7269, "substitutes": {"spapr": ["spiprc", "sparpR", "spaprs", " spipR", "sparprs", " spipfr", " spiprs", "sparpfr", "spipR", "spiprs", "spipfr", " spaprs", "spamprar", "spaprc", " spapfr", " spiprc", " spiprar", "spapeR", "spamprc", "spipr", "spaperar", "spiprar", " spaprc", "spaper", "spaprar", "spapsR", "spapR", "spaperc", "spampr", "spampR", " spipr", "spapsfr", "spapsr", "spapsrs", " spapR", " spaprar", "sparpr", "spapfr"], "token": ["key", "function", "t", "reset", "no", "kn", "data", "normal", "error", "field", "position", "note", "typ", "trigger", "txt", "ask", "node", "padding", "offset", "WT", "rule", "frequency", "kt", "ok", "wt", "TO", "time", "none", "word", "before", "format", "value", "random", "tree", "password", "date", "serial", "seed", "type", "target", "len", "now", "oken", "prototype", "TN", "local", "Token", "table", "tn", "window", "number", "year", "header", "atom", "topic", "KEN", "message", "block", "notice", "tick", "input", "callback", "event", "batch", "template"], "nargs": ["pnfull", "nfull", "snarg", "pnarg", " nvals", "cnarg", "narg", "Ngs", " nfull", "cnargs", " nrows", " narg", "snvals", " ngs", "Nvals", "nvals", "cnrows", "pnargs", "snargs", "pnrows", "cnfull", "Narg", "Nargs", "sngs", "nrows", "ngs"], "args": ["flags", "doc", "ems", "ds", "uns", "ras", "ms", "arg", "arr", "ps", "ctx", "ins", "arms", "frames", "files", "gets", "ens", "groups", "fields", "aws", "ns", "js", "rs", "keys", "gs", "ids", "ars", "Args", "ts", "stats", "xs", "vals", "fs", "cs", "uments", "ams", "names", "ais", "ants", "aux", "terms", "ands", "qs", "ags", "params"], "nret": ["nrets", " nrets", "Nrets", " Nret", " npret", "nnalt", "nalt", " nreturn", " nalt", " Npret", " Nrets", "Nreturn", "nnreturn", "Nret", "nnrets", "Npret", " Nreturn", "nreturn", "nnret", "Nalt", "npret"], "rets": ["uts", "ras", "RET", "types", "arr", "nt", "secret", "fts", "errors", "outs", "events", "lists", "rows", "ret", "ns", "ints", "mt", "def", "ses", "sts", "rs", "keys", "gs", "ties", "ts", "results", "res", "vals", "its", "fs", "values", "cs", "uments", "ants", "aux", "urs", "als", "ls", "qs", "rt", "uds", "vt", "fields", "alls", "states"], "call": ["commit", "t", "co", "cast", "form", "f", "ll", "Call", "eval", "use", "circ", "draw", "col", "label", "list", "check", "con", "send", "node", "ell", "build", "dial", "word", "cell", "def", "make", "roll", "ref", "row", "close", "rec", "contact", "find", "can", "exec", "table", "all", "ALL", "ac", " cal", "update", "c", "create", "cal", "back", "push", "block", "local", "load", "frame", "execute", "run", "add"]}}
{"project": "qemu", "commit_id": "afa46c468acc18914c2773538f1b088c507766ee", "target": 0, "func": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd)\n\n{\n\n    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, req->dev);\n\n    SCSIGenericReq *r = DO_UPCAST(SCSIGenericReq, req, req);\n\n    int ret;\n\n\n\n    if (cmd[0] != REQUEST_SENSE && req->lun != s->qdev.lun) {\n\n        DPRINTF(\"Unimplemented LUN %d\\n\", req->lun);\n\n        scsi_req_build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED));\n\n        scsi_req_complete(&r->req, CHECK_CONDITION);\n\n        return 0;\n\n    }\n\n\n\n    if (-1 == scsi_req_parse(&r->req, cmd)) {\n\n        BADF(\"Unsupported command length, command %x\\n\", cmd[0]);\n\n        scsi_command_complete(r, -EINVAL);\n\n        return 0;\n\n    }\n\n    scsi_req_fixup(&r->req);\n\n\n\n    DPRINTF(\"Command: lun=%d tag=0x%x len %zd data=0x%02x\", lun, tag,\n\n            r->req.cmd.xfer, cmd[0]);\n\n\n\n#ifdef DEBUG_SCSI\n\n    {\n\n        int i;\n\n        for (i = 1; i < r->req.cmd.len; i++) {\n\n            printf(\" 0x%02x\", cmd[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    if (r->req.cmd.xfer == 0) {\n\n        if (r->buf != NULL)\n\n            qemu_free(r->buf);\n\n        r->buflen = 0;\n\n        r->buf = NULL;\n\n        ret = execute_command(s->bs, r, SG_DXFER_NONE, scsi_command_complete);\n\n        if (ret < 0) {\n\n            scsi_command_complete(r, ret);\n\n            return 0;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (r->buflen != r->req.cmd.xfer) {\n\n        if (r->buf != NULL)\n\n            qemu_free(r->buf);\n\n        r->buf = qemu_malloc(r->req.cmd.xfer);\n\n        r->buflen = r->req.cmd.xfer;\n\n    }\n\n\n\n    memset(r->buf, 0, r->buflen);\n\n    r->len = r->req.cmd.xfer;\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n\n        r->len = 0;\n\n        return -r->req.cmd.xfer;\n\n    } else {\n\n        return r->req.cmd.xfer;\n\n    }\n\n}\n", "idx": 7315, "substitutes": {"req": ["deg", "gz", "p", "conf", "pkg", "nt", "q", "msg", "cur", "pro", "iq", "sq", "term", "md", "decl", "cond", "esp", "tx", "gr", "ptr", "query", "dev", "qq", "progress", "grab", "dist", "wx", "ps", "ctx", "inv", "crit", "j", "sem", "mem", "requ", "err", "http", "ref", "quest", "seq", "quick", "urg", "request", "pub", "ctr", "ind", "org", "rr", "good", "eq", "comp", "tek", "rec", "perm", "rel", "qt", "aux", "out", "reg", "init", "rep", "task", "require", "dq", "needed", "comm", "attr", "resp", "buf", "alg", "pr", "tag", "cmp", "jp", "cfg", "res", "expr", "desc", "dep"], "cmd": ["gt", "pkg", "vc", "cont", "msg", "call", "send", "txt", "str", "cur", "wo", "wd", "dx", "term", "md", "opt", "text", "now", "cond", "det", "quit", "tx", "kw", "cp", "ch", "qq", "com", "dist", "arg", "ctx", "normal", "check", "phy", "crit", "fun", "control", "adv", "js", "mem", "mt", "dict", "code", "ck", "op", "cy", "raw", "try", "args", "seq", "grad", "quick", "tab", "urg", "ctr", "ind", "news", "att", "cb", "ext", "good", "off", "mac", "comp", "std", "command", "om", "xy", "exec", "ct", "nd", "init", "t", "form", "Cmd", "cookie", "cat", "cd", "force", "prop", "dq", "comm", "buf", "act", "cmp", "cfg", "help", "desc", "cod", "xp", "batch"], "s": ["sc", "t", "os", "S", "p", "ds", "a", "l", "sp", "ps", "spec", "q", "serv", "sl", "str", "set", "ss", "h", "j", "sr", "so", "bs", "js", "ns", "hs", "b", "sd", "sq", "sh", "g", "rs", "store", "gs", "ts", "sn", "stats", "m", "res", "sb", "c", "ls", "n", "sys", "er", "se", "sw"], "r": ["fr", "p", "l", "rw", "it", "error", "q", "str", "k", "self", "ry", "vr", "sr", "rem", "response", "rar", "gr", "c", "n", "er", "re", "rl", "obj", "w", "rh", "or", "j", "h", "b", "ref", "this", "item", "ro", "rc", "f", "d", "kr", "R", "rr", "br", "rx", "rs", "rest", "rec", "e", "m", "rel", "var", "rt", "reg", "dr", "t", "rer", "v", "lr", "o", "cr", "attr", "usr", "hr", "nr", "g", "pr", "ar", "res", "rd", "tr", "rb", "err", "mr"], "ret": ["deg", "dr", "t", "elt", "reset", "gt", "inter", "dt", "no", "f", "RET", "arg", "nt", "re", "Ret", "ft", "Return", "rets", "ext", "str", "val", "j", "rem", "mem", "mt", "resp", "usr", "def", "result", "err", "nz", "std", "ref", "len", "status", "print", "jp", "pat", "res", "conv", "tr", "ter", "flag", "try", " RET", " Ret", "num", "back", "alt", "reply", "rt", "out", "tn"], "i": ["key", "init", "t", "li", "p", "sim", "bi", "is", "ms", "ind", "ii", "v", "ini", "id", "mi", "ix", "MI", "me", "it", "ic", "z", "\u0438", "si", "j", "di", "gi", "span", "io", "in", "iq", "ex", "b", "index", "mac", "info", "point", "ui", "multi", "xi", "y", "zi", "PI", "ci", "ti", "m", "ami", "ai", "pi", " j", "ims", "x", "I", "count", "phi", "cli", "us", "qi", "n"]}}
{"project": "qemu", "commit_id": "fc6c9257c6dd47316a1c55d356bcd89bdc5fd642", "target": 0, "func": "void ip6_input(struct mbuf *m)\n\n{\n\n    struct ip6 *ip6;\n\n\n\n    DEBUG_CALL(\"ip6_input\");\n\n    DEBUG_ARG(\"m = %lx\", (long)m);\n\n    DEBUG_ARG(\"m_len = %d\", m->m_len);\n\n\n\n    if (m->m_len < sizeof(struct ip6)) {\n\n        goto bad;\n\n    }\n\n\n\n    ip6 = mtod(m, struct ip6 *);\n\n\n\n    if (ip6->ip_v != IP6VERSION) {\n\n        goto bad;\n\n    }\n\n\n\n    /* check ip_ttl for a correct ICMP reply */\n\n    if (ip6->ip_hl == 0) {\n\n        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,\"ttl\");*/\n\n        goto bad;\n\n    }\n\n\n\n    /*\n\n     * Switch out to protocol's input routine.\n\n     */\n\n    switch (ip6->ip_nh) {\n\n    case IPPROTO_TCP:\n\n        /*tcp_input(m, hlen, (struct socket *)NULL);*/\n\n        break;\n\n    case IPPROTO_UDP:\n\n        /*udp_input(m, hlen);*/\n\n        break;\n\n    case IPPROTO_ICMPV6:\n\n        icmp6_input(m);\n\n        break;\n\n    default:\n\n        m_free(m);\n\n    }\n\n    return;\n\nbad:\n\n    m_free(m);\n\n}\n", "idx": 7324, "substitutes": {"m": ["gm", "t", "cm", "hm", "p", "dm", "f", "bm", "ms", "l", "v", "d", "mk", "rm", "r", "mi", "mu", "mp", "em", "msg", "z", "sm", "q", "k", "h", "j", "o", "esm", "mat", "nm", "i", "mt", "b", "mx", "g", "trace", "M", "mb", "y", "ma", "wm", "perm", "vm", "mm", "im", "tm", "mod", "c", "am", "n", "man", "imm", "managed", "mut", "mc", "mr"], "ip6": ["ip8", "clipnet", "IP3", " ip3", "IP06", "IP8", "IPhttps", "order6", "ip63", "ep2", " sipcan", "ip2", "cliphttps", " sip63", " ipnet", " ipac", "ipac", "ep4", "ep6", "ipnet", "clip4", " ip16", "p8", "ep3", "p6", "p3", "ep8", "IP64", "IP2", "ip4", "int6", "ip06", "IP6", " sip6", "lat6", "int16", "IPnet", "clip6", "ip64", " ip2", " sip3", "ep64", "int64", "ip3", "ipcan", "ipp64", "ip16", "ep16", "ipp2", "iphttps", "IP4", "ipphttps", "ippcan", " ip8", "order63", "ippac", "ipp16", "p16", "lat64", "order3", "IP16", "ipp63", " sip64", "ipp3", " ip4", "ep06", "int06", "IPac", "latcan", " iphttps", " siphttps", "lathttps", "ipp6"]}}
{"project": "qemu", "commit_id": "677ef6230b603571ae05125db469f7b4c8912a77", "target": 0, "func": "void fork_start(void)\n\n{\n\n    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);\n\n    pthread_mutex_lock(&exclusive_lock);\n\n    mmap_fork_start();\n\n}\n", "idx": 7326, "substitutes": {}}
{"project": "qemu", "commit_id": "2f859f80c2077e00237ea1dfae2523ebd8377f5f", "target": 0, "func": "static int write_dump_pages(DumpState *s)\n\n{\n\n    int ret = 0;\n\n    DataCache page_desc, page_data;\n\n    size_t len_buf_out, size_out;\n\n#ifdef CONFIG_LZO\n\n    lzo_bytep wrkmem = NULL;\n\n#endif\n\n    uint8_t *buf_out = NULL;\n\n    off_t offset_desc, offset_data;\n\n    PageDescriptor pd, pd_zero;\n\n    uint8_t *buf;\n\n    int endian = s->dump_info.d_endian;\n\n    GuestPhysBlock *block_iter = NULL;\n\n    uint64_t pfn_iter;\n\n\n\n    /* get offset of page_desc and page_data in dump file */\n\n    offset_desc = s->offset_page;\n\n    offset_data = offset_desc + sizeof(PageDescriptor) * s->num_dumpable;\n\n\n\n    prepare_data_cache(&page_desc, s, offset_desc);\n\n    prepare_data_cache(&page_data, s, offset_data);\n\n\n\n    /* prepare buffer to store compressed data */\n\n    len_buf_out = get_len_buf_out(s->page_size, s->flag_compress);\n\n    if (len_buf_out == 0) {\n\n        dump_error(s, \"dump: failed to get length of output buffer.\\n\");\n\n        goto out;\n\n    }\n\n\n\n#ifdef CONFIG_LZO\n\n    wrkmem = g_malloc(LZO1X_1_MEM_COMPRESS);\n\n#endif\n\n\n\n    buf_out = g_malloc(len_buf_out);\n\n\n\n    /*\n\n     * init zero page's page_desc and page_data, because every zero page\n\n     * uses the same page_data\n\n     */\n\n    pd_zero.size = cpu_convert_to_target32(s->page_size, endian);\n\n    pd_zero.flags = cpu_convert_to_target32(0, endian);\n\n    pd_zero.offset = cpu_convert_to_target64(offset_data, endian);\n\n    pd_zero.page_flags = cpu_convert_to_target64(0, endian);\n\n    buf = g_malloc0(s->page_size);\n\n    ret = write_cache(&page_data, buf, s->page_size, false);\n\n    g_free(buf);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to write page data(zero page).\\n\");\n\n        goto out;\n\n    }\n\n\n\n    offset_data += s->page_size;\n\n\n\n    /*\n\n     * dump memory to vmcore page by page. zero page will all be resided in the\n\n     * first page of page section\n\n     */\n\n    while (get_next_page(&block_iter, &pfn_iter, &buf, s)) {\n\n        /* check zero page */\n\n        if (is_zero_page(buf, s->page_size)) {\n\n            ret = write_cache(&page_desc, &pd_zero, sizeof(PageDescriptor),\n\n                              false);\n\n            if (ret < 0) {\n\n                dump_error(s, \"dump: failed to write page desc.\\n\");\n\n                goto out;\n\n            }\n\n        } else {\n\n            /*\n\n             * not zero page, then:\n\n             * 1. compress the page\n\n             * 2. write the compressed page into the cache of page_data\n\n             * 3. get page desc of the compressed page and write it into the\n\n             *    cache of page_desc\n\n             *\n\n             * only one compression format will be used here, for\n\n             * s->flag_compress is set. But when compression fails to work,\n\n             * we fall back to save in plaintext.\n\n             */\n\n             size_out = len_buf_out;\n\n             if ((s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) &&\n\n                    (compress2(buf_out, (uLongf *)&size_out, buf, s->page_size,\n\n                    Z_BEST_SPEED) == Z_OK) && (size_out < s->page_size)) {\n\n                pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_ZLIB,\n\n                                                   endian);\n\n                pd.size  = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#ifdef CONFIG_LZO\n\n            } else if ((s->flag_compress & DUMP_DH_COMPRESSED_LZO) &&\n\n                    (lzo1x_1_compress(buf, s->page_size, buf_out,\n\n                    (lzo_uint *)&size_out, wrkmem) == LZO_E_OK) &&\n\n                    (size_out < s->page_size)) {\n\n                pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_LZO,\n\n                                                   endian);\n\n                pd.size  = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#endif\n\n#ifdef CONFIG_SNAPPY\n\n            } else if ((s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) &&\n\n                    (snappy_compress((char *)buf, s->page_size,\n\n                    (char *)buf_out, &size_out) == SNAPPY_OK) &&\n\n                    (size_out < s->page_size)) {\n\n                pd.flags = cpu_convert_to_target32(\n\n                                        DUMP_DH_COMPRESSED_SNAPPY, endian);\n\n                pd.size  = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#endif\n\n            } else {\n\n                /*\n\n                 * fall back to save in plaintext, size_out should be\n\n                 * assigned to s->page_size\n\n                 */\n\n                pd.flags = cpu_convert_to_target32(0, endian);\n\n                size_out = s->page_size;\n\n                pd.size = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf, s->page_size, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n            }\n\n\n\n            /* get and write page desc here */\n\n            pd.page_flags = cpu_convert_to_target64(0, endian);\n\n            pd.offset = cpu_convert_to_target64(offset_data, endian);\n\n            offset_data += size_out;\n\n\n\n            ret = write_cache(&page_desc, &pd, sizeof(PageDescriptor), false);\n\n            if (ret < 0) {\n\n                dump_error(s, \"dump: failed to write page desc.\\n\");\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\n    ret = write_cache(&page_desc, NULL, 0, true);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to sync cache for page_desc.\\n\");\n\n        goto out;\n\n    }\n\n    ret = write_cache(&page_data, NULL, 0, true);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to sync cache for page_data.\\n\");\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    free_data_cache(&page_desc);\n\n    free_data_cache(&page_data);\n\n\n\n#ifdef CONFIG_LZO\n\n    g_free(wrkmem);\n\n#endif\n\n\n\n    g_free(buf_out);\n\n\n\n    return ret;\n\n}\n", "idx": 7327, "substitutes": {"s": ["p", "conf", "l", "cont", "self", "ns", "sq", "ses", "gs", "y", "stats", "its", "ims", "c", "settings", "n", "qs", "er", "ctl", "ptr", "S", "dev", "a", "ps", "vs", "list", "serv", "w", "less", "ss", "h", "changes", "i", "js", "b", "def", "http", "sts", "ts", "stat", "bits", "fs", "sis", "args", "sb", "us", "sys", "details", "is", "d", "func", "sam", "aws", "so", "bs", "source", "ex", "state", "rs", "m", "cs", "as", "_", "ls", "local", "t", "os", "sim", "ds", "south", "ms", "v", "spec", "sm", "set", "comm", "hs", "an", "g", "store", "status", "es", "sv", "parts", "sql", "se", "sw"], "page_desc": [" page_spec", "pageNamedesc", "page_info", "pageNamespec", "pageKeyinfo", "pageKeyesc", "meta_trans", "meta_cd", "pageNameesc", "pagelogcd", "pagelogtrans", "pageingdesc", "pageingcd", "pageingdes", "page_des", "pageNameinfo", "pagelogdesc", "page_esc", "pageKeyspec", "page_spec", "page_cd", "meta_des", "page_trans", "meta_desc", " page_esc", "pageKeydesc", "pageingtrans", " page_info", "pagelogdes"], "page_data": ["row_def", "pageNamedesc", "row_data", "page_info", "pageNamecontent", " page_size", "page_cache", "row_info", "page_content", "meta_iter", "page_def", "row_cache", "meta_data", "page_size", "pageNamedata", "meta_info", "pagelyiter", " page_content", "pagelyinfo", "pagelydata", "meta_def", "pageNamesize", "pagelydef", "page_iter"], "len_buf_out": ["len_bufaxyouts", "len_buf3in", "len_buf_err", "len_buf2out", "len_buf3Out", "len_buf_Out", "len_uf_in", "len_buf2output", "len_buffer_in", "len_buf3out", "len_uf_size", "len_buf_size", "len_buffer_outs", "len_bufaxysize", "len_uf_ou", "len_buf_ou", "len_buf2in", "len_buffer_out", "len_buf_outs", "len_uf_err", "len_uf_outs", "len_uf_Out", "len_uf_output", "len_buf3ou", "len_buf_output", "len_buf_in", "len_uf_out", "len_bufaxyout", "len_bufaxyin", "len_buf2err"], "size_out": ["size_in", "sizevalOUT", " size_in", "sizevalout", "size_bin", "sizevalin", " size_bin", "sizevalbin", "size_OUT", " size_OUT"], "buf_out": ["bufswOut", "buf_tmp", "buffer_no", "buf_no", "bufswin", "bufswtmp", "bufswout", "buf_in", "buf_Out", "buffer_in", "buffer_out", "buf_OUT", "buffer_OUT", "buffer_tmp", "buffer_Out"], "offset_desc": ["offset___Desc", "Offset_description", "Offset_meta", "offset__esc", "offset__comp", "link_dc", "offset_sc", "offset_Desc", "offset67desc", "link_comp", "offset___des", "offset_ind", "Offset_des", "offset_esc", "offset_dir", "Offset_sc", "offset___sc", "offset2data", "offset_comp", "offset2desc", "offset_des", "offset_dc", "offset2ind", "offset_meta", "offset___info", "link_esc", "offsetptdc", " offset_ind", "offset67description", "offset_info", "Offset_Desc", "offset___description", "offset_description", "offset___desc", "offset67Desc", " offset_dir", "offset__dc", "offset67meta", "Offset_desc", "offset2dir", "offset__desc", "offsetptesc", "link_desc", "offset___meta", "offsetptdesc", "offsetptcomp", "Offset_info"], "offset_data": [" offset__bytes", "offset__no", "position_value", "offset_name", "offset_no", "offset__bytes", " offset__no", " offset__data", "offset_dat", " offset_size", "data_dat", "offset_size", "data_off", "offset_value", "offset_buf", "offset_off", " offset_no", "offset_num", "position_data", "offsetjoff", "off_data", "data_data", "offsetjinfo", "offset_bytes", "datajdata", " offset_bytes", "offset__data", "datajdat", "start_data", "offset_info", "offsetmmbuf", "offsetYsize", "offset_index", "offsetmmdata", "start_index", "datajoff", "off_name", "offset__size", "start_num", "offsetjdat", " offset__size", "offsetjdata", "datajinfo", "position_dat", "offsetYnum", "offsetYindex", "offsetYdata", "data_info", "offsetmmdesc", "off_desc", "off_buf", "start_size", "offsetmmname", "position_desc"], "pd": ["p", " pdf", " cp", "ds", " pg", "ps", " sd", "dd", "PD", "PDF", " md", " dd", " db", "pt", " dw", " PD", "pdf", " cd", " df", "md", " pts", " td", " pt", " pr", " pci", "pid", "bf", " ps", "bd"], "pd_zero": ["pd_neutral", "pdjfree", "pd__final", "pdjneutral", "pd_module", "pdaminfo", "dd_neutral", "pdMtotal", "pc_zero", "pdjmodule", "pdMzero", "pd_info", "pd_final", "pdjzero", "edd_zero", "dd_leader", "dd_zero", "pd__total", "pd__zero", "pd_total", "sd_info", "pdamtotal", "dd_global", "edd_free", "sdMtotal", "pd_user", "pdamfinal", "pdJzero", "sdMzero", "pdodoreglobal", "sd_final", "sd_zero", "pdodorezero", "edd_module", "edd_neutral", "sdMinfo", "pdamzero", "pdMfinal", "sd_total", "dd_reset", "pdodoreneutral", "pd_leader", "pdJreset", "pdJleader", "pd_reset", "sdMfinal", "pc_fee", "pd_global", "pdMinfo", "pd_fee", "pd__info", "pd_free", "pc_user"], "buf": ["ptr", "out", "doc", "BU", "pkg", "cv", "tmp", "bed", "rw", "v", "data", "mates", "mu", "msg", "bar", "cb", "Buffer", "w", "txt", "ff", "br", "buff", "Buff", "bs", "ret", "mem", "bytes", "b", "err", "result", "blocks", "boxes", "cap", "ref", "buffer", "img", "len", "iter", "cam", "db", "page", "vec", "raw", "window", "uf", "bc", "seq", "queue", "bin", "broad", "block", "box", "pos", "rb", "cache", "cmd", "wb", "batch"], "block_iter": ["block_iterator", " block_map", " block_ip", "block___ip", "block2gen", "block2iterator", " block_iterator", "block2iter", " block_gen", "block___iter", "block___iterator", "block_gen", "block2map", "block_ip", "block_map", "block___gen"], "pfn_iter": ["pfn___index", "pfn___iterator", "pfn2init", "pwn2init", "pfn_index", "pfn___iter", "pnn_iter", "pnn_num", "pfn_ser", "pwn_ser", "pfn2iter", "pfn_init", "pnn_index", "pwn_init", "pfn___num", "pfn___init", "pfn_iterator", "pfn___ser", "pwn_iter", "pwn2ser", "pfn2ser", "pnn_iterator", "pwn2iter", "pfn_num"]}}
{"project": "qemu", "commit_id": "d516f74c99b1a2c289cfba0bacf125cbc9b681e3", "target": 0, "func": "static void do_ext_interrupt(CPUS390XState *env)\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    uint64_t mask, addr;\n\n    LowCore *lowcore;\n\n    ExtQueue *q;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_EXT)) {\n\n        cpu_abort(CPU(cpu), \"Ext int w/o ext mask\\n\");\n\n    }\n\n\n\n    lowcore = cpu_map_lowcore(env);\n\n\n\n    if (env->pending_int & INTERRUPT_EXT_CLOCK_COMPARATOR) {\n\n        lowcore->ext_int_code = cpu_to_be16(EXT_CLOCK_COMP);\n\n        lowcore->cpu_addr = 0;\n\n        env->pending_int &= ~INTERRUPT_EXT_CLOCK_COMPARATOR;\n\n    } else if (env->pending_int & INTERRUPT_EXT_CPU_TIMER) {\n\n        lowcore->ext_int_code = cpu_to_be16(EXT_CPU_TIMER);\n\n        lowcore->cpu_addr = 0;\n\n        env->pending_int &= ~INTERRUPT_EXT_CPU_TIMER;\n\n    } else if (env->pending_int & INTERRUPT_EXT_SERVICE) {\n\n        g_assert(env->ext_index >= 0);\n\n        /*\n\n         * FIXME: floating IRQs should be considered by all CPUs and\n\n         *        shuld not get cleared by CPU reset.\n\n         */\n\n        q = &env->ext_queue[env->ext_index];\n\n        lowcore->ext_int_code = cpu_to_be16(q->code);\n\n        lowcore->ext_params = cpu_to_be32(q->param);\n\n        lowcore->ext_params2 = cpu_to_be64(q->param64);\n\n        lowcore->cpu_addr = cpu_to_be16(env->core_id | VIRTIO_SUBCODE_64);\n\n        env->ext_index--;\n\n        if (env->ext_index == -1) {\n\n            env->pending_int &= ~INTERRUPT_EXT_SERVICE;\n\n        }\n\n    } else {\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    mask = be64_to_cpu(lowcore->external_new_psw.mask);\n\n    addr = be64_to_cpu(lowcore->external_new_psw.addr);\n\n    lowcore->external_old_psw.mask = cpu_to_be64(get_psw_mask(env));\n\n    lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr);\n\n\n\n    cpu_unmap_lowcore(lowcore);\n\n\n\n    DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__,\n\n            env->psw.mask, env->psw.addr);\n\n\n\n    load_psw(env, mask, addr);\n\n}\n", "idx": 7332, "substitutes": {"env": ["conf", "conn", "msg", "dn", "forge", "ie", "ah", "net", "response", "vm", "db", "queue", "er", "cmd", "event", "uv", "eas", "ei", "gear", "dev", "door", "environment", "vs", "ctx", "worker", "eg", "qv", "inv", "obj", "ew", "en", "export", "ve", "eng", "esm", "ner", "answer", "enc", "args", "ent", "tk", "context", "shell", "config", "esc", "org", "ae", "cb", "nv", "era", "here", "die", "outer", "eq", "manager", "peer", "e", "end", "te", "exec", "engine", "qt", "eh", "vt", "ev", "vp", "doc", "t", "cv", "v", "ec", "enter", "vv", "server", "gate", "eve", "ee", "console", "erd", "cfg", "global", "sv", "hw", "window", "desc", "chart", "err"], "cpu": ["ka", "cu", "cp", "ork", "p", "total", "conn", "aco", "sp", "ctx", "mu", "pc", "hz", "gpu", "node", "chip", "port", "cn", "gc", "nu", "ip", "proc", "np", "clock", "mx", "CPU", "net", "tp", "vm", "process", "cam", "alloc", "jp", "pu", "base", "core", "hw", "num", "c", "sys", "cache"], "mask": ["flags", "key", "master", " masked", "conf", " masks", "pack", "ch", "pkg", "weight", "sk", "use", "mk", "id", "sum", "filter", "hash", "Mask", "check", "ask", "address", "map", "offset", "set", "alias", "handle", "module", "miss", "lock", "size", "clear", "state", "name", "feature", "info", "mx", "mac", "sign", "mn", "cap", "type", "nz", " Mask", "tag", "match", "code", "perm", "ck", "m", "bit", "bits", "tr", "flag", "qa", "window", "count", "mode", "magic", "open", "block", "box", "ack", "shape", "cache", "cmd", "batch"], "addr": ["ptr", "dr", "phys", "host", "eth", "art", "pkg", "mk", "ix", "ctx", "rr", "ad", "hash", "address", "map", "loc", "offset", "alias", "port", "ress", "gate", "pad", "adr", "align", "attr", "arp", "ip", "mem", "mt", "mac", "act", "arch", "store", "tag", "ar", "arity", "iat", "ai", "on", "hop", "src", "alt", "arm", "pos", "ack", "sys", "err", "cmd", "seek"], "lowcore": ["lowscore", "lowcrypt", "slowport", "deepcycle", "highcode", "lowcache", "lowrate", "lightore", "levelrate", "highcpu", "lowcode", "lowercycle", "lowerserver", " lowcpu", "littleore", "slowcache", "loce", " lowworker", "hardore", "shortcore", "lightrate", "lowserver", "highcore", "lowrow", "lowport", "slowrate", "lowerready", "highcrypt", "lowore", "lowerstore", "leftcenter", "slowCore", "littleworker", "slowscore", "deepserver", " lowscore", "levelcore", "lowercore", "lowworker", "slowready", "flowconn", "lowCore", " lowstore", "lowdisk", "lowce", "lowcpu", "littlecache", "leftscore", " lowserver", "levelore", "highworker", " lowcache", "lowercpu", "slowserver", "lowerore", "Lowcore", "flowcore", "locore", "levelgate", "leveldisk", "shortdisk", "lightcore", " lowore", "loCore", "slowdisk", "leftore", "lowercache", "littlescore", "Lowrow", " lowconn", "slowcore", "highscore", "levelcache", "hardcrypt", "deepcpu", "lowercode", "Lowconn", "lowconn", "leftserver", "deepcore", "highore", "littlestore", "loserver", "levelport", "slowcode", "leftrate", " lowcrypt", " lowce", " lowcenter", "lowerCore", "lowerscore", "highready", "slowcpu", " lowrow", " lowCore", "littlecore", "slowore", "lightcenter", "deepore", "slowce", "lowcycle", "slowcycle", "shortgate", " lowrate", "leftcore", "hardcore", "lowgate", "lowstore", "slowgate", "deeprate", "lowcenter", "hardscore", "lowready", "flowrow", "shortport", "deepscore", "highrate"], "q": ["t", "query", "p", "conf", "ch", "pkg", "qq", "cv", "f", "d", "v", "r", "it", "quant", "Q", "qv", "inv", "msg", "w", "req", "ue", "dq", "k", "qu", "ve", "j", "quer", "iq", "eq", "requ", "sq", "que", "g", "y", "e", "ck", "flow", "m", "quest", "aq", "qa", "qi", "seq", "qt", "queue", "qs", "z", "cache", "cmd"], "ext_index": ["ext8index", "Ext_index", "ext2num", "ext2Index", "external2number", "external_index", "extPnumber", "extPIndex", "ext2index", "external2Index", "ext_ind", "extpoIndex", "external_switch", "external_Index", "extPnum", "extgrindex", "extgrind", "ext_num", "external2index", "external2num", "ext_switch", "ext8ind", "ext_number", "ext8int", "ext8Index", "extposwitch", "extgrnumber", "external_num", "extpoindex", "Ext_int", "extgrIndex", "ext_int", "Ext_ind", "Ext_Index", "extPindex", "external_ind", "external_number", "ext2number", "ext_Index"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void verdex_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    PXA2xxState *cpu;\n\n    DriveInfo *dinfo;\n\n    int be;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n\n\n    uint32_t verdex_rom = 0x02000000;\n\n    uint32_t verdex_ram = 0x10000000;\n\n\n\n    cpu = pxa270_init(address_space_mem, verdex_ram, cpu_model ?: \"pxa270-c0\");\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (!dinfo && !qtest_enabled()) {\n\n        fprintf(stderr, \"A flash image must be given with the \"\n\n                \"'pflash' parameter\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    if (!pflash_cfi01_register(0x00000000, NULL, \"verdex.rom\", verdex_rom,\n\n                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                               sector_len, verdex_rom / sector_len,\n\n                               2, 0, 0, 0, 0, be)) {\n\n        fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Interrupt line of NIC is connected to GPIO line 99 */\n\n    smc91c111_init(&nd_table[0], 0x04000300,\n\n                    qdev_get_gpio_in(cpu->gpio, 99));\n\n}\n", "idx": 7334, "substitutes": {"machine": ["achine", "sim", "hard", "Machine", "host", "dm", "task", "config", "handler", "me", "component", "linux", "connection", "node", "server", "iso", "power", "module", "device", "link", "state", "manager", "computer", "memory", "net", "network", "vm", "process", "m", "instance", "domain", "model", "session", "mill", "shell", "frame", "mc", "dem", "monitor"], "cpu_model": ["pu_mode", "cpu_config", "cpu_id", "cpu2Model", "cpu_models", " cpu_mode", "pu_type", "cpu_Model", "pu_model", "cpu2model", "pu_config", "cpu_type", "cpu2type", "cpu_mode", " cpu_Model", "cpu2mode", "cpu2id", "pu_Model", " cpu_models", "cpu2config", "pu_id"], "cpu": ["cu", "cp", "phys", "p", "util", "achine", "copy", "disk", "pai", "processor", "ctx", "pc", "hz", "linux", "prof", "gpu", "node", "setup", "chip", "device", "gc", "mem", "proc", "clock", "np", "computer", "mx", "memory", "CPU", "xi", "ilo", "bean", "pool", "process", "vm", "boot", "gp", "pu", "core", "hw", "cum", "cli", "c", "nic", "frame", "cache"], "dinfo": [" dINFO", "linf", "dINFO", "rfo", "lINFO", "Dinfo", "linfo", "ddata", "pdinfo", "rInfo", "Dinf", " dinf", " dfo", "rinformation", "Ddata", "dinformation", "lInfo", "sdinfo", "sdfo", "DInfo", "sddata", "rinfo", "pdinformation", "pdInfo", "dInfo", "dinf", "DINFO", "rINFO", "pdINFO", "Dinformation", "sdInfo", "Dfo", "rinf", "lfo", " ddata", " dInfo", "dfo"], "be": ["bo", "ke", " BE", "de", "obe", " Be", " bo", "use", "bes", "ble", " ne", "le", "ze", "cho", "ae", "itte", "it", "oe", "z", "\u662f", "Be", "one", "ue", "st", "he", "br", "ne", "ve", "or", "ge", " je", "beat", "we", "b", "are", "fe", "ot", "e", " b", "end", "te", "BE", "ine", "ate", "scale", "ere", "ed", "ce", " pe", " Bo", "eb", "ide", "enable", "ob", "by", "abe", " probe", "se"], "address_space_mem": ["address_system_mem", "address_system_memory", "address_space2mem", "address_space_memory", "address_space2map", "address_system_reg", "address_system_map", "address_space2reg", "address_space_map", "address_space_reg"]}}
{"project": "qemu", "commit_id": "e3737b820b45e54b059656dc3f914f895ac7a88b", "target": 1, "func": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVBochsState *s = bs->opaque;\n    uint32_t i;\n    struct bochs_header bochs;\n    int ret;\n    bs->read_only = 1; // no write support yet\n    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n    if (ret < 0) {\n        return ret;\n    if (strcmp(bochs.magic, HEADER_MAGIC) ||\n        strcmp(bochs.type, REDOLOG_TYPE) ||\n        strcmp(bochs.subtype, GROWING_TYPE) ||\n\t((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n        error_setg(errp, \"Image not in Bochs format\");\n        return -EINVAL;\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n    } else {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n    s->catalog_size = le32_to_cpu(bochs.catalog);\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n                     s->catalog_size * 4);\n    if (ret < 0) {\n        goto fail;\n    for (i = 0; i < s->catalog_size; i++)\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\n    s->extent_size = le32_to_cpu(bochs.extent);\n    if (s->catalog_size < bs->total_sectors / s->extent_size) {\n        error_setg(errp, \"Catalog size is too small for this disk size\");\n        ret = -EINVAL;\n        goto fail;\n    qemu_co_mutex_init(&s->lock);\n    return 0;\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;", "idx": 7347, "substitutes": {"bs": ["ubs", "os", "uts", "bos", "bps", "ds", "bh", "bi", "is", "bm", "bes", "aus", "blog", "vs", "ps", "aos", "bas", "locks", "fps", "ss", "outs", "js", "asis", "hs", "ns", "b", "bb", "BS", "boxes", "bl", "pb", "sts", "rs", "gs", "las", "ts", "es", "obs", "cks", "lbs", "ubis", "bits", "fs", "its", "bis", "bp", "cs", "sb", "als", "ls", "ats", "qs", "sys", "bc"], "options": ["os", "bos", "details", "config", "times", "data", "ps", "Options", "ptions", "o", "option", "styles", "limits", "tags", "keys", "ts", "es", "ops", "stats", "vals", "fs", "values", "args", "meta", "settings", "ption", "params"], "flags": ["ds", " flag", "types", "ps", "files", "FLAG", "kind", "Flag", "Flags", "ns", "tags", "status", "ts", "res", "vals", "bits", "fs", "flag", "features", "args", "mask", "mode", "settings", "fields", "cmd", "ags"], "errp": ["rrm", "Erp", "rrp", "errpa", "diepa", " errpb", "rrpb", " errm", " errP", "dieP", " erP", "Erm", "errpe", " errpa", "errpb", "rrP", "Erpb", "diep", "diepe", " erpe", " erpa", " errpe", " erp", "ErP", "errP", "errm"], "s": ["l", "cont", " ss", "sl", "ns", "sq", "ses", "gs", "stats", "its", "ims", "n", "qs", "eps", "services", "S", "sp", "vs", "ps", "ins", "obj", "less", "ss", "h", "changes", "js", "b", "sts", "ts", "bits", "fs", "args", "sb", "als", "ats", "sys", "ers", "states", "sa", "details", "is", "func", "rs", "m", "acs", "bis", "cs", "as", "ls", "os", "ds", "ms", "ies", "comm", "hs", "ssl", "store", "es", "actions", "sv"], "i": ["key", " I", "t", "li", "ei", "p", "sim", "ki", "bi", "is", "ind", "ii", "v", "ini", "mi", "ix", " bi", "me", "pc", "it", "ic", "gu", "\u0438", "uri", "si", "oi", "j", "di", "gi", "o", "io", "ji", "ip", "b", "ui", " si", "multi", "iu", "xi", "y", "wi", "zi", "ma", " ti", "ti", "ci", "m", "ami", "ai", "pi", " j", "im", " mi", "x", "I", "ims", "qi", "c", "cli", "n", "u", " ii"], "bochs": ["brochtts", "bochnjs", "Bochs", "boCHds", "rochms", "rochs", "foachs", "bochtrs", "boachis", "bachains", "bokhts", "oochss", "bochnstats", "bochms", "bochS", "bochtS", "bochts", "foachis", "bochls", "fochls", "rochts", "bochnabs", "oochnis", "boechts", "muchjs", "brochti", "bochstats", "ooachjs", "bochrs", "fochds", "bochains", "boachds", "oochries", "boechs", "bochedjs", "boochi", "muochabs", "brochi", "bochtls", "bocmdds", "ooochs", "bochnrs", "bochnms", "oochstats", "boechms", "brochls", "ooachstats", "boochts", "bochedains", "ooochries", "boochabs", "bokhjs", "bokhsb", "fochnis", "fochis", " bochjs", "boochls", "bochtjs", "roechts", "boiahs", "boochns", "boechis", "boCHs", "fochns", "boechss", "roechs", "bochanjs", "fochrs", "boCHjs", "bochjs", " boechsb", "BochtS", "bochnS", "bochabs", "bouthss", "boachjs", "muochds", "oochds", "boochis", "bochns", "bochis", "muochis", "foochs", "muchabs", "boCHsb", "bochsb", "BochS", "oochnls", "bochds", "fochjs", "bochedls", "muchs", "boichs", "boechains", "bochedns", "boachs", "bocmdts", "foachls", "bachjs", "muochjs", "boachstats", "boachls", "muchts", "bochnss", "brochs", "oochnds", "bocheds", "foochrs", "roechms", " bochsb", "bachs", "boichms", " boechs", "muchis", "bokhs", "fochs", "boochs", "boochrs", "bochi", "boiahjs", "fochnds", "bochanS", "bochtries", "foochns", "Bochtjs", "boochjs", "muochts", "bochnns", "boCHts", "muochs", "bochries", "bochnis", "boochries", "boechi", "oochjs", "ooochjs", "bouths", "bacheds", "bachedjs", "bachls", "boechjs", "bochnds", "brochtls", "brochts", "bochti", "muchds", "bachedains", " boechjs", "bochtts", "bochans", "Bochjs", "Bochts", "bochss", "foochjs", "boochds", "oochis", "oochls", " bochts", "oochns", "boCHis", "ooachs", "bochnains", "boiahstats", "oochnss", "boichts", " boechts", "bachedls", "boechls", "bouthls", "bochnls", "bocmds", "oochs", "bochnts", "boechsb", "bocmdabs"], "ret": ["deg", "get", "out", "t", "elt", "lit", "gt", "reset", "inter", "dt", "tf", "ll", "RET", "arg", "rm", "att", "nt", "re", "cont", "Ret", "fin", "ft", "rets", "txt", "cert", "val", "set", "ry", "vet", "fit", "rem", "ez", "mem", "mt", "resp", "def", "usr", "result", "net", "ber", "mel", "len", "iter", "print", "code", "status", "res", "det", "after", "try", "tr", "ter", "reg", " RET", " Ret", " alt", "back", "alt", "reply", "del", "rt", "err", "cmd"]}}
{"project": "FFmpeg", "commit_id": "3b9a913db4d303a0305a80de496b1933cba8980f", "target": 1, "func": "offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence)\n\n{\n\n    offset_t offset1;\n\n    offset_t pos= s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));\n\n\n\n    if (whence != SEEK_CUR && whence != SEEK_SET)\n\n        return -EINVAL;\n\n\n\n    if (whence == SEEK_CUR) {\n\n        offset1 = pos + (s->buf_ptr - s->buffer);\n\n        if (offset == 0)\n\n            return offset1;\n\n        offset += offset1;\n\n    }\n\n    offset1 = offset - pos;\n\n    if (!s->must_flush &&\n\n        offset1 >= 0 && offset1 < (s->buf_end - s->buffer)) {\n\n        /* can do the seek inside the buffer */\n\n        s->buf_ptr = s->buffer + offset1;\n\n    } else {\n\n        if (!s->seek)\n\n            return -EPIPE;\n\n\n\n#ifdef CONFIG_MUXERS\n\n        if (s->write_flag) {\n\n            flush_buffer(s);\n\n            s->must_flush = 1;\n\n        } else\n\n#endif //CONFIG_MUXERS\n\n        {\n\n            s->buf_end = s->buffer;\n\n        }\n\n        s->buf_ptr = s->buffer;\n\n        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)\n\n            return -EPIPE;\n\n        s->pos = offset;\n\n    }\n\n    s->eof_reached = 0;\n\n    return offset;\n\n}\n", "idx": 7351, "substitutes": {"s": ["p", "https", "times", "self", "ns", "sq", "ses", "gs", "y", "stats", "xs", "comments", "its", "ims", "c", "n", "qs", "er", "services", "S", "a", "ps", "vs", "ins", "serv", "less", "ss", "h", "changes", "i", "js", "b", "http", "sts", "ts", "ops", "stat", "fs", "sb", "als", "ats", "sys", "states", "sports", "details", "is", "sam", "ports", "events", "aws", "bs", "state", "rs", "m", "acs", "bis", "cs", "as", "ls", "ags", "t", "os", "ds", "south", "ms", "v", "spec", "ies", "set", "comm", "hs", "g", "ties", "es", "service", "sv", "parts", "se", "sw"], "offset": ["key", "et", "p", "l", "error", "field", "loc", "before", "slot", "term", "scroll", "fp", "eta", "ta", "count", "start", "ptr", "extra", "no", "a", "origin", "sp", "OFF", "align", "i", "pointer", "index", "timeout", "zero", "ref", "buffer", "op", "meta", "total", "top", "adjusted", "reset", "bound", "optional", "f", "padding", "address", "port", "location", "size", "off", "point", "shift", "amount", "e", "end", "ed", "original", "skip", "t", "oss", "ms", "length", "to", "position", "set", "style", "o", "option", "trace", "bit", "addr", "base", "Offset", "oid", "pos", "cache", "seek", " offsets"], "whence": ["Whence", "funCE", "funcer", "nevercent", " whenced", "tainace", "whenCE", "wherecer", "freecer", "whenced", "wheCE", "tainCE", "wherece", "wheze", "funce", "Whenace", " whences", "Whences", "whences", "whereced", "freece", " whenace", " whencent", "whencent", "freeces", "freecent", " whencer", "neverces", "whencer", "whece", "whereze", "whecer", "funze", "wheced", "neverce", " whenCE", "nevercer", "WhenCE", " whenze", "taince", "whenze", "tainces", "whenace"], "offset1": ["z1", "Offset0", "attribute1", "offset3", "attribute0", "indexOne", "address0", " offset01", "pointerOne", "indexOnce", " offset0", "Offset2", "offsetone", " offsetOnce", "position2", "pointer4", "slotone", "pointer1", " offsetId", "offOne", " offset4", "slot0", "offset2", "index1", " offset2", "slot1", "Offset3", "positionId", "address1", "positionone", "offsetOne", "pointer001", "attribute001", "positionOne", "attribute4", "Offset1", "offset01", " offsetOne", "position01", " offsetone", "z3", "position0", "pointerOnce", "offset0", "pointer0", " offset001", "offsetOnce", "OffsetId", "offset001", "offsetId", "off1", "slotOne", "position1", "address01", "addressone", "offset4", "index0", "offone"]}}
{"project": "qemu", "commit_id": "18b21a2f83a26c3d6a9e7f0bdc4e8eb2b177e8f6", "target": 0, "func": "void ppc_translate_init(void)\n\n{\n\n    int i;\n\n    char* p;\n\n    size_t cpu_reg_names_size;\n\n    static int done_init = 0;\n\n\n\n    if (done_init)\n\n        return;\n\n\n\n    cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, \"env\");\n\n\n\n    p = cpu_reg_names;\n\n    cpu_reg_names_size = sizeof(cpu_reg_names);\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        snprintf(p, cpu_reg_names_size, \"crf%d\", i);\n\n        cpu_crf[i] = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                            offsetof(CPUState, crf[i]), p);\n\n        p += 5;\n\n        cpu_reg_names_size -= 5;\n\n    }\n\n\n\n    for (i = 0; i < 32; i++) {\n\n        snprintf(p, cpu_reg_names_size, \"r%d\", i);\n\n        cpu_gpr[i] = tcg_global_mem_new(TCG_AREG0,\n\n                                        offsetof(CPUState, gpr[i]), p);\n\n        p += (i < 10) ? 3 : 4;\n\n        cpu_reg_names_size -= (i < 10) ? 3 : 4;\n\n#if !defined(TARGET_PPC64)\n\n        snprintf(p, cpu_reg_names_size, \"r%dH\", i);\n\n        cpu_gprh[i] = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                             offsetof(CPUState, gprh[i]), p);\n\n        p += (i < 10) ? 4 : 5;\n\n        cpu_reg_names_size -= (i < 10) ? 4 : 5;\n\n#endif\n\n\n\n        snprintf(p, cpu_reg_names_size, \"fp%d\", i);\n\n        cpu_fpr[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                            offsetof(CPUState, fpr[i]), p);\n\n        p += (i < 10) ? 4 : 5;\n\n        cpu_reg_names_size -= (i < 10) ? 4 : 5;\n\n\n\n        snprintf(p, cpu_reg_names_size, \"avr%dH\", i);\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n        cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[0]), p);\n\n#else\n\n        cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[1]), p);\n\n#endif\n\n        p += (i < 10) ? 6 : 7;\n\n        cpu_reg_names_size -= (i < 10) ? 6 : 7;\n\n\n\n        snprintf(p, cpu_reg_names_size, \"avr%dL\", i);\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n        cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[1]), p);\n\n#else\n\n        cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[0]), p);\n\n#endif\n\n        p += (i < 10) ? 6 : 7;\n\n        cpu_reg_names_size -= (i < 10) ? 6 : 7;\n\n    }\n\n\n\n    cpu_nip = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, nip), \"nip\");\n\n\n\n    cpu_msr = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, msr), \"msr\");\n\n\n\n    cpu_ctr = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, ctr), \"ctr\");\n\n\n\n    cpu_lr = tcg_global_mem_new(TCG_AREG0,\n\n                                offsetof(CPUState, lr), \"lr\");\n\n\n\n    cpu_xer = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, xer), \"xer\");\n\n\n\n    cpu_reserve = tcg_global_mem_new(TCG_AREG0,\n\n                                     offsetof(CPUState, reserve), \"reserve\");\n\n\n\n    cpu_fpscr = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                       offsetof(CPUState, fpscr), \"fpscr\");\n\n\n\n    cpu_access_type = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                             offsetof(CPUState, access_type), \"access_type\");\n\n\n\n    /* register helpers */\n\n#define GEN_HELPER 2\n\n#include \"helper.h\"\n\n\n\n    done_init = 1;\n\n}\n", "idx": 7360, "substitutes": {"i": ["id", "ii", "ini", "it", "q", "my", "hi", "di", "gi", "none", "iq", " si", "y", "remote", "ci", "ami", " j", "ni", "ims", "qi", "cli", "n", "er", " ii", " I", "ei", "ix", "list", "ic", "si", "oi", "j", "ji", "index", "zi", "this", "try", "iri", "pi", "x", "us", "ia", "is", "ind", "mi", "ri", "io", "ip", "ex", "mac", "point", "multi", " ti", "ti", "m", "ai", "im", " mi", "I", "go", "dr", "li", " multi", "sim", "ki", "bi", "v", "to", " bi", "me", "\u0438", "uri", "set", "in", "info", " Xi", "ui", "iu", "xi", "ij", "status", "sql", "batch"], "p": ["out", "vp", "t", "pp", "cp", "rep", "pkg", "lp", "f", "a", "progress", "d", "l", "v", "sp", "r", "ps", "pc", "it", "policy", "post", "ping", "pg", "q", "wp", "ep", "set", "pa", "h", "j", "port", "o", "php", "pt", "pad", "br", "lock", "imp", "ip", "ap", "b", "np", "point", "g", "at", "pb", "pr", "y", "fp", "tp", "dp", "jp", "op", "perm", "pool", "m", "up", "P", "bp", "pi", "part", "pl", "x", "pid", "c", "pe", "n", "pos", "xp", "pre", "cache"], "cpu_reg_names_size": ["cpu_reg_names_Size", "cpu_reg_names_count", "cpu_reg_name_sum", "cpu_reg_files_length", "cpu_reg_names_style", "cpu_reg_names_length", "cpu_reg_files_name", "cpu_reg_names_sum", "cpu_reg_files_ize", "cpu_reg_names_space", "cpu_reg_names_type", "cpu_reg_name_space", "cpu_reg_files_type", "cpu_reg_files_SIZE", "cpu_reg_name_Size", "cpu_reg_name_size", "cpu_reg_names_ize", "cpu_reg_names_scale", "cpu_reg_names_SIZE", "cpu_reg_files_size", "cpu_reg_names_name", "cpu_reg_files_Size", "cpu_reg_name_SIZE"]}}
{"project": "qemu", "commit_id": "7d08d85645def18eac2a9d672c1868a35e0bcf79", "target": 0, "func": "static void gen_mtfsfi(DisasContext *ctx)\n\n{\n\n    int bf, sh;\n\n    TCGv_i64 t0;\n\n    TCGv_i32 t1;\n\n\n\n    if (unlikely(!ctx->fpu_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_FPU);\n\n        return;\n\n    }\n\n    bf = crbD(ctx->opcode) >> 2;\n\n    sh = 7 - bf;\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    gen_reset_fpstatus();\n\n    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));\n\n    t1 = tcg_const_i32(1 << sh);\n\n    gen_helper_store_fpscr(cpu_env, t0, t1);\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i32(t1);\n\n    if (unlikely(Rc(ctx->opcode) != 0)) {\n\n        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);\n\n        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);\n\n    }\n\n    /* We can raise a differed exception */\n\n    gen_helper_float_check_status(cpu_env);\n\n}\n", "idx": 7380, "substitutes": {"ctx": ["tc", "mc", "ka", "sc", "cu", "cp", "p", "cm", "jac", "kh", "co", " cx", "pkg", "ork", "conn", "ctr", "ind", "wx", "nt", "lc", "pc", "pg", "dc", "prefix", "txt", "cb", "loc", "obj", "cc", "crit", "cl", "kt", "req", "comm", "dl", "gc", "kl", "fc", "anc", "history", "np", "resp", "today", "cpu", "act", "ctrl", "tp", "cmp", "jp", "ck", "cf", "cfg", "this", "xc", "gp", "ca", "hw", "ct", "tm", "tx", "cmd", "kw", "xp", "context", "rt", "ctl", "nc", "bc"], "bf": ["ptr", "fg", "bn", "lb", "BF", "tf", "bh", "bt", "f", "lf", "bm", "fb", "ft", "cb", " kb", "ff", "sf", "xf", "fc", "bs", "rb", "FB", "b", "bb", "bol", "sq", "fab", "buf", "bl", "pb", "mb", "gb", "kb", "cf", "db", "bg", "bp", "eb", "uf", "sb", "bsp", "nb", "bc", "bd"], "sh": ["ph", "sc", "kh", "sch", "wh", "bh", "sk", "shi", "she", "ksh", "sp", "sm", "igh", "sl", "cl", "si", "ss", "style", "sf", "h", "ssh", "SH", "sd", "ho", "size", "hs", "resh", "tw", "sq", "shift", "how", "sy", "shr", "gh", "scl", "ly", "sn", "Sh", "sv", "cs", "sb", "sha", "broad", "s", "shell", "se", "sw"], "t0": [" t000", "wt0", " t8", "p0", "ts1", "p1", "t9", " tau", " t9", "p3", "wtau", "wt9", "t8", "t000", "T1", "T9", "T8", " tZero", " t3", "ts0", "wt000", "T000", "wt1", "tZero", "Tau", "ts8", " T1", " T3", "tau", "TZero", " T0", "tsZero", "T0", "t3"], "t1": ["tsOne", " t8", "p0", "ts1", "p1", "i4", "TOne", "dt8", "ot1", "dt001", "t4", "t8", "tOne", "iable", "i2", "dt1", "T1", "T2", "ts2", "dt2", " t2", "ot4", "t2", "t001", "ot2", " tOne", " t001", " table", "p8", "p001", "table", "i1", " t4", "p2", "otable", "T0"]}}
{"project": "qemu", "commit_id": "1e356fc14beaa3ece6c0e961bd479af58be3198b", "target": 1, "func": "void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)\n\n{\n\n    int i;\n\n    size_t pagesize = getpagesize();\n\n\n\n    memory = (memory + pagesize - 1) & -pagesize;\n\n    for (i = 0; i < memory / pagesize; i++) {\n\n        memset(area + pagesize * i, 0, 1);\n\n    }\n\n}\n", "idx": 7393, "substitutes": {"fd": [" dst", "ptr", "dev", "fi", "d", " file", "id", " fs", " output", "FD", " sd", "file", " channel", " io", " handle", " db", " pid", "fc", " af", "dir", " d", " df", "fp", " path", " pointer", "pid", " f", " stream", "stream"], "area": ["ka", "ia", "aa", "aria", "a", "ha", "prefix", "address", "arc", "aka", "ica", "alias", "ra", "Area", "size", "space", "format", "section", "dir", "rea", " areas", "are", "range", "ref", "buffer", "row", "ata", "ma", "code", "ca", "page", "storage", "base", "zone", "window", "ta", "region", "angle", "array", "va"], "memory": ["ia", "capacity", "function", "margin", "Memory", "balance", "bm", "resource", "volume", "database", "data", "mi", "length", "me", "RAM", "media", "position", "address", "map", "imei", "description", "power", "gc", "location", "size", "history", "metadata", "mem", "bytes", "pointer", "usage", "mx", "write", "maximum", "mb", "network", "buffer", "ma", "now", "record", "m", "ami", "page", "radius", "storage", "ram", "window", "reference", "mode", "region", "secondary", "library", " Memory", "message", "age", "value", "cache"], "errp": [" errh", "Errorps", "ErrorP", "Erp", " errps", "Erh", "Errorp", "ErP", "Errorh", "errh", "errP", " errP", "Erps", "errps"], "i": ["key", " m", " I", "ei", "li", "init", "ity", "sim", "ki", "fi", "bi", "ind", "ii", "v", "ini", "l", "mi", "ix", " bi", "MI", "it", "ic", "\u0438", " x", "asi", " e", "si", "oi", "j", "di", "gi", "ri", "ji", "ip", "index", " v", "multi", "ui", "iu", "xi", "y", "ij", "zi", " ti", "ci", "ti", "m", "ai", "pi", " j", "im", " mi", "x", "I", "qi", "phi", "sequence", "ims", "cli", "client", "n", " ii", "batch"]}}
{"project": "FFmpeg", "commit_id": "4029f05c8b0943a5446f254142d5e2bfedb50a0d", "target": 1, "func": "static int cuvid_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt)\n\n{\n\n    CuvidContext *ctx = avctx->priv_data;\n\n    AVHWDeviceContext *device_ctx = (AVHWDeviceContext*)ctx->hwdevice->data;\n\n    AVCUDADeviceContext *device_hwctx = device_ctx->hwctx;\n\n    CUcontext dummy, cuda_ctx = device_hwctx->cuda_ctx;\n\n    AVFrame *frame = data;\n\n    CUVIDSOURCEDATAPACKET cupkt;\n\n    AVPacket filter_packet = { 0 };\n\n    AVPacket filtered_packet = { 0 };\n\n    CUdeviceptr mapped_frame = 0;\n\n    int ret = 0, eret = 0;\n\n\n\n    if (ctx->bsf && avpkt->size) {\n\n        if ((ret = av_packet_ref(&filter_packet, avpkt)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"av_packet_ref failed\\n\");\n\n            return ret;\n\n        }\n\n\n\n        if ((ret = av_bsf_send_packet(ctx->bsf, &filter_packet)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"av_bsf_send_packet failed\\n\");\n\n            av_packet_unref(&filter_packet);\n\n            return ret;\n\n        }\n\n\n\n        if ((ret = av_bsf_receive_packet(ctx->bsf, &filtered_packet)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"av_bsf_receive_packet failed\\n\");\n\n            return ret;\n\n        }\n\n\n\n        avpkt = &filtered_packet;\n\n    }\n\n\n\n    ret = CHECK_CU(cuCtxPushCurrent(cuda_ctx));\n\n    if (ret < 0) {\n\n        av_packet_unref(&filtered_packet);\n\n        return ret;\n\n    }\n\n\n\n    memset(&cupkt, 0, sizeof(cupkt));\n\n\n\n    if (avpkt->size) {\n\n        cupkt.payload_size = avpkt->size;\n\n        cupkt.payload = avpkt->data;\n\n\n\n        if (avpkt->pts != AV_NOPTS_VALUE) {\n\n            cupkt.flags = CUVID_PKT_TIMESTAMP;\n\n            if (avctx->pkt_timebase.num && avctx->pkt_timebase.den)\n\n                cupkt.timestamp = av_rescale_q(avpkt->pts, avctx->pkt_timebase, (AVRational){1, 10000000});\n\n            else\n\n                cupkt.timestamp = avpkt->pts;\n\n        }\n\n    } else {\n\n        cupkt.flags = CUVID_PKT_ENDOFSTREAM;\n\n    }\n\n\n\n    ret = CHECK_CU(cuvidParseVideoData(ctx->cuparser, &cupkt));\n\n\n\n    av_packet_unref(&filtered_packet);\n\n\n\n    if (ret < 0) {\n\n        if (ctx->internal_error)\n\n            ret = ctx->internal_error;\n\n        goto error;\n\n    }\n\n\n\n    if (av_fifo_size(ctx->frame_queue)) {\n\n        CUVIDPARSERDISPINFO dispinfo;\n\n        CUVIDPROCPARAMS params;\n\n        unsigned int pitch = 0;\n\n        int offset = 0;\n\n        int i;\n\n\n\n        av_fifo_generic_read(ctx->frame_queue, &dispinfo, sizeof(CUVIDPARSERDISPINFO), NULL);\n\n\n\n        memset(&params, 0, sizeof(params));\n\n        params.progressive_frame = dispinfo.progressive_frame;\n\n        params.second_field = 0;\n\n        params.top_field_first = dispinfo.top_field_first;\n\n\n\n        ret = CHECK_CU(cuvidMapVideoFrame(ctx->cudecoder, dispinfo.picture_index, &mapped_frame, &pitch, &params));\n\n        if (ret < 0)\n\n            goto error;\n\n\n\n        if (avctx->pix_fmt == AV_PIX_FMT_CUDA) {\n\n            ret = av_hwframe_get_buffer(ctx->hwframe, frame, 0);\n\n            if (ret < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"av_hwframe_get_buffer failed\\n\");\n\n                goto error;\n\n            }\n\n\n\n            ret = ff_decode_frame_props(avctx, frame);\n\n            if (ret < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"ff_decode_frame_props failed\\n\");\n\n                goto error;\n\n            }\n\n\n\n            for (i = 0; i < 2; i++) {\n\n                CUDA_MEMCPY2D cpy = {\n\n                    .srcMemoryType = CU_MEMORYTYPE_DEVICE,\n\n                    .dstMemoryType = CU_MEMORYTYPE_DEVICE,\n\n                    .srcDevice     = mapped_frame,\n\n                    .dstDevice     = (CUdeviceptr)frame->data[i],\n\n                    .srcPitch      = pitch,\n\n                    .dstPitch      = frame->linesize[i],\n\n                    .srcY          = offset,\n\n                    .WidthInBytes  = FFMIN(pitch, frame->linesize[i]),\n\n                    .Height        = avctx->coded_height >> (i ? 1 : 0),\n\n                };\n\n\n\n                ret = CHECK_CU(cuMemcpy2D(&cpy));\n\n                if (ret < 0)\n\n                    goto error;\n\n\n\n                offset += avctx->coded_height;\n\n            }\n\n        } else if (avctx->pix_fmt == AV_PIX_FMT_NV12) {\n\n            AVFrame *tmp_frame = av_frame_alloc();\n\n            if (!tmp_frame) {\n\n                av_log(avctx, AV_LOG_ERROR, \"av_frame_alloc failed\\n\");\n\n                ret = AVERROR(ENOMEM);\n\n                goto error;\n\n            }\n\n\n\n            tmp_frame->format        = AV_PIX_FMT_CUDA;\n\n            tmp_frame->hw_frames_ctx = av_buffer_ref(ctx->hwframe);\n\n            tmp_frame->data[0]       = (uint8_t*)mapped_frame;\n\n            tmp_frame->linesize[0]   = pitch;\n\n            tmp_frame->data[1]       = (uint8_t*)(mapped_frame + avctx->coded_height * pitch);\n\n            tmp_frame->linesize[1]   = pitch;\n\n            tmp_frame->width         = avctx->width;\n\n            tmp_frame->height        = avctx->height;\n\n\n\n            ret = ff_get_buffer(avctx, frame, 0);\n\n            if (ret < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"ff_get_buffer failed\\n\");\n\n                av_frame_free(&tmp_frame);\n\n                goto error;\n\n            }\n\n\n\n            ret = av_hwframe_transfer_data(frame, tmp_frame, 0);\n\n            if (ret) {\n\n                av_log(avctx, AV_LOG_ERROR, \"av_hwframe_transfer_data failed\\n\");\n\n                av_frame_free(&tmp_frame);\n\n                goto error;\n\n            }\n\n\n\n            av_frame_free(&tmp_frame);\n\n        } else {\n\n            ret = AVERROR_BUG;\n\n            goto error;\n\n        }\n\n\n\n        frame->width = avctx->width;\n\n        frame->height = avctx->height;\n\n        if (avctx->pkt_timebase.num && avctx->pkt_timebase.den)\n\n            frame->pts = av_rescale_q(dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkt_timebase);\n\n        else\n\n            frame->pts = dispinfo.timestamp;\n\n\n\n        /* CUVIDs opaque reordering breaks the internal pkt logic.\n\n         * So set pkt_pts and clear all the other pkt_ fields.\n\n         */\n\n        frame->pkt_pts = frame->pts;\n\n        av_frame_set_pkt_pos(frame, -1);\n\n        av_frame_set_pkt_duration(frame, 0);\n\n        av_frame_set_pkt_size(frame, -1);\n\n\n\n        frame->interlaced_frame = !dispinfo.progressive_frame;\n\n\n\n        if (!dispinfo.progressive_frame)\n\n            frame->top_field_first = dispinfo.top_field_first;\n\n\n\n        *got_frame = 1;\n\n    } else {\n\n        *got_frame = 0;\n\n    }\n\n\n\nerror:\n\n    if (mapped_frame)\n\n        eret = CHECK_CU(cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame));\n\n\n\n    eret = CHECK_CU(cuCtxPopCurrent(&dummy));\n\n\n\n    if (eret < 0)\n\n        return eret;\n\n    else\n\n        return ret;\n\n}\n", "idx": 7398, "substitutes": {"avctx": [" avcontext", "afthread", "averreq", "awcfg", "wavctx", "afcontext", "avecb", "afcb", "wavreq", "avreq", "afctx", "afcmd", "avercfg", "Avcmd", "avcfg", "wavca", "avcmd", " avcmp", "awcmp", "Avcfg", "aftx", "avcmp", " avcb", " avcmd", " avtx", "hwcontext", "avecmp", "avercmp", "avectx", "hwtx", "wavcfg", "averthread", "hwconn", "avca", " avcfg", "awctx", " avconn", "afcfg", "hwctx", "avereq", "avecfg", "avconn", "awthread", "avcb", "avcontext", "avtx", "averctx", "Avcontext", "aveca", "avecontext", "Avctx", "avthread", "averca", "afconn", "afcmp"], "data": ["rew", "out", "extra", "t", "p", "present", "share", "form", "f", "load", "d", "id", "r", "to", "length", "mu", "image", "ad", "DATA", "scope", "padding", "native", "version", "one", "pad", "module", "Data", "device", "package", "feed", "empty", "dat", "read", "in", "size", "group", "format", "bytes", "pointer", "name", "info", "buf", "input", "response", "type", "buffer", "text", "ata", "class", "ref", "record", " DATA", "m", "rel", "res", "raw", "table", "window", "tx", "bin", "video", "message", "block", "context", "next", "value", "cache", "action"], "got_frame": ["generated_data", "got___frame", "got__frames", "generated___data", "got___channel", "got__channel", "got2frame", "got_channel", "generated___channel", "generated_frames", "generated___frame", "got2channel", "got2frames", "generated_frame", "generated_channel", "got__frame", "got2data", "generated___frames", "got__data", "got_data", "got___frames", "got_frames", "got___data"], "avpkt": ["wavwpacket", "avdpkt", "avwpct", "avwpacket", "afpkt", "avwkt", "avnpacket", "wavpnt", "wavwpnt", " avcpoint", "avmkt", "avpodkg", "avwpce", "avmkg", "ajpkgkt", "avdpce", "avwpnt", "avepet", "avpkgacket", "afppnt", "avcpkin", "wavcpet", "avepce", "afppett", "avmelt", "avepelt", "avckt", "ajpacket", "avppnt", "avpelt", "wavpct", "wavwpkt", "avnpct", " avcpacket", "avcelt", "avnpkin", " avcpct", "avpett", "afppkt", "avPkt", "avPacket", "wavpet", "avPnt", "avepacket", "avewpacket", "avpkg", "ajpkgct", " avcpet", "avopct", "avPct", "avpct", "ajpkt", "avpkin", "avmacket", "avwelt", "wavwpct", "avppett", "afpnt", "avepkt", "avppkt", "afpett", "avemkg", "avwacket", "avcpacket", "wavpacket", "avwpet", "avcpnt", "avewpkt", " avcpelt", "avPett", "avcpet", "avpkgkt", " avpoint", "avppct", "avdpet", " avpelt", "avpayet", " avpet", "avcpct", "avemacket", " avpacket", "avppacket", "avnpett", "avpayct", "avnpkt", "avcnt", "avpaykt", "ajpct", "avpoint", "avpacket", "avopkt", "avcacket", "wavcpkin", "avcet", "avnpnt", "avcce", "afppct", "avepkg", "avPet", "avopet", "avewpce", "avpkget", "wavcpacket", "avpodacket", "avcpelt", "avpodkt", "afpct", "avpnt", "avdpacket", "avewpet", "avpodelt", "avnpet", "wavpkt", "avemelt", "avemkt", "avcpkt", "avcpoint", " avcpkt", "avwpkt", "avpce", "wavpkin", "wavcpkt", " avpct", "ajpkgacket", "avopoint", "avpkgct", "avwkg", "avpayoint", "avpet", "avcct", "avPelt", "avpkgkin"], "ctx": ["tc", "mc", "cm", "cp", "conf", "util", "jac", "pkg", "cv", "config", "conn", "wx", "func", "nt", "lc", "dc", "prefix", "scope", "obj", "cb", "txt", "loc", "cc", "setup", "abc", "req", "handle", "module", "gc", "mom", "proc", "np", "act", "timeout", "cmp", "cf", "cam", "ck", "cfg", "jp", "this", "xc", "acl", "addr", "hw", "ct", "ac", "desc", "tm", "tx", "qt", "bc", "Context", "kw", "context", "sys", "ctl", "cmd"], "device_ctx": ["dev_pkg", "window_cp", "window_obj", "window_ctx", "device_tx", "devicepypkg", "device_req", "dev_obj", "dev_ctx", "device_pkg", "device_obj", "devicepyreq", "devicepyctx", "devicepyobj", "dev_req", "device_cp", "window_tx"], "device_hwctx": ["device_hwpkg", "device2fwcontext", "device_hwobj", "device2fwctx", "device_syspkg", "device_auxaddr", "device_fwcontext", "device2hwctx", "device2fwpkg", "device2hwobj", "device_auxcontext", "device_fwtx", "device_fwobj", "device2hwpkg", "device_auxtx", "device_fwpkg", "device_hwcontext", "device_sysobj", "device_hwtx", "device_iwpkg", "device_iwaddr", "device_syscontext", "device_hwaddr", "device_fwctx", "device_iwctx", "device2hwcontext", "device2fwobj", "device_iwobj", "device_iwcontext", "device_iwtx", "device_auxctx", "device_sysctx", "device_fwaddr"], "dummy": ["Dummy", "dumper", "sdummy", "dcalloc", "Dup", "sdumper", "dcumper", "sdalloc", "dcup", "dcummy", "dup", "Dumper", "dalloc", "Dalloc", "sdup"], "frame": ["draw", "channel", "component", "image", "error", "msg", "reason", "chain", "state", "point", "trace", "response", "Frame", "row", "command", "process", "flow", "base", "sequence", "window", "message", "block", "context", "cmd", "event", "action"], "cupkt": ["ucckid", "casak", "ucckt", "cmpqt", "wpkid", "etchupet", "cpunct", "sockt", "wpiat", "wpqt", "caskt", "camkg", "cupak", "rapak", "cupkw", " cupett", "ucccht", "etchupunct", "cmpkid", "wpcht", "cupqt", "camkt", "sockw", "cupiat", "uccelt", "etchupelt", "cmpkg", "uccet", "sociat", "cmpelt", "cupett", "wpkw", "socett", "cupunct", "etchupkt", "rapkt", "vpqt", "wpett", "camqt", "cupkg", "vpkg", "cpelt", "wpkt", "cpqt", "cupkid", "caskg", " cupiat", "uccnt", "cupet", "camak", "casqt", "wpkg", "rapqt", "rapkg", " cupkw", "cupelt", "cpkt", "cpet", "wpet", "vpkt", "cupnt", "cmpet", "vpet", "cmpnt", "cmpkt", "wpnt", "cmpcht", "uccqt", "cmpunct", "cupcht"]}}
{"project": "qemu", "commit_id": "30ca440eec9fe1d7eec5a48addac656438778278", "target": 0, "func": "static void hotplug(void)\n\n{\n\n    qtest_start(\"-device virtio-net-pci\");\n\n\n\n    qpci_plug_device_test(\"virtio-net-pci\", \"net1\", PCI_SLOT_HP, NULL);\n\n    qpci_unplug_acpi_device_test(\"net1\", PCI_SLOT_HP);\n\n\n\n    test_end();\n\n}\n", "idx": 7420, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct8_add_sse2(uint8_t *dst, int16_t *block, int stride)\n\n{\n\n    __asm__ volatile(\n\n        \"movdqa   0x10(%1), %%xmm1 \\n\"\n\n        \"movdqa   0x20(%1), %%xmm2 \\n\"\n\n        \"movdqa   0x30(%1), %%xmm3 \\n\"\n\n        \"movdqa   0x50(%1), %%xmm5 \\n\"\n\n        \"movdqa   0x60(%1), %%xmm6 \\n\"\n\n        \"movdqa   0x70(%1), %%xmm7 \\n\"\n\n        H264_IDCT8_1D_SSE2(%%xmm0, %%xmm1, %%xmm2, %%xmm3, %%xmm4, %%xmm5, %%xmm6, %%xmm7)\n\n        TRANSPOSE8(%%xmm4, %%xmm1, %%xmm7, %%xmm3, %%xmm5, %%xmm0, %%xmm2, %%xmm6, (%1))\n\n        \"paddw          %4, %%xmm4 \\n\"\n\n        \"movdqa     %%xmm4, 0x00(%1) \\n\"\n\n        \"movdqa     %%xmm2, 0x40(%1) \\n\"\n\n        H264_IDCT8_1D_SSE2(%%xmm4, %%xmm0, %%xmm6, %%xmm3, %%xmm2, %%xmm5, %%xmm7, %%xmm1)\n\n        \"movdqa     %%xmm6, 0x60(%1) \\n\"\n\n        \"movdqa     %%xmm7, 0x70(%1) \\n\"\n\n        \"pxor       %%xmm7, %%xmm7 \\n\"\n\n        STORE_DIFF_8P(%%xmm2, (%0),      %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm0, (%0,%2),   %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm1, (%0,%2,2), %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm3, (%0,%3),   %%xmm6, %%xmm7)\n\n        \"lea     (%0,%2,4), %0 \\n\"\n\n        STORE_DIFF_8P(%%xmm5, (%0),      %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm4, (%0,%2),   %%xmm6, %%xmm7)\n\n        \"movdqa   0x60(%1), %%xmm0 \\n\"\n\n        \"movdqa   0x70(%1), %%xmm1 \\n\"\n\n        STORE_DIFF_8P(%%xmm0, (%0,%2,2), %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm1, (%0,%3),   %%xmm6, %%xmm7)\n\n        :\"+r\"(dst)\n\n        :\"r\"(block), \"r\"((x86_reg)stride), \"r\"((x86_reg)3L*stride), \"m\"(ff_pw_32)\n\n    );\n\n}\n", "idx": 7428, "substitutes": {"dst": ["idsrc", "idht", "dsrc", "Dht", "Dbl", "dht", "fst", "fht", "idst", "fsrc", "idbl", "Dsrc", "fbl", "Dst", "dbl"], "block": ["pack", "no", "data", "length", "Block", "obj", "cl", "set", "device", "lock", "kl", "chain", "mem", "blocks", "buf", "bl", "type", "ref", "buffer", "row", "len", "mm", "byte", "tx", "bin", "kw", "start", "load"], "stride": ["collride", "strope", "collope", " strope", "strice", "dride", "drope", " strride", "strride", "drice", "collide", " strice", "drride", "collice"]}}
{"project": "qemu", "commit_id": "3a51dee658b9cc781acd57dd11bffbd1e402f93d", "target": 0, "func": "static void ide_identify(IDEState *s)\n\n{\n\n    uint16_t *p;\n\n    unsigned int oldsize;\n\n\n\n    memset(s->io_buffer, 0, 512);\n\n    p = (uint16_t *)s->io_buffer;\n\n    stw(p + 0, 0x0040);\n\n    stw(p + 1, s->cylinders); \n\n    stw(p + 3, s->heads);\n\n    stw(p + 4, 512 * s->sectors); /* sectors */\n\n    stw(p + 5, 512); /* sector size */\n\n    stw(p + 6, s->sectors); \n\n    stw(p + 20, 3); /* buffer type */\n\n    stw(p + 21, 512); /* cache size in sectors */\n\n    stw(p + 22, 4); /* ecc bytes */\n\n    padstr((uint8_t *)(p + 27), \"QEMU HARDDISK\", 40);\n\n#if MAX_MULT_SECTORS > 1    \n\n    stw(p + 47, MAX_MULT_SECTORS);\n\n#endif\n\n    stw(p + 48, 1); /* dword I/O */\n\n    stw(p + 49, 1 << 9); /* LBA supported, no DMA */\n\n    stw(p + 51, 0x200); /* PIO transfer cycle */\n\n    stw(p + 52, 0x200); /* DMA transfer cycle */\n\n    stw(p + 54, s->cylinders);\n\n    stw(p + 55, s->heads);\n\n    stw(p + 56, s->sectors);\n\n    oldsize = s->cylinders * s->heads * s->sectors;\n\n    stw(p + 57, oldsize);\n\n    stw(p + 58, oldsize >> 16);\n\n    if (s->mult_sectors)\n\n        stw(p + 59, 0x100 | s->mult_sectors);\n\n    stw(p + 60, s->nb_sectors);\n\n    stw(p + 61, s->nb_sectors >> 16);\n\n    stw(p + 80, (1 << 1) | (1 << 2));\n\n    stw(p + 82, (1 << 14));\n\n    stw(p + 83, (1 << 14));\n\n    stw(p + 84, (1 << 14));\n\n    stw(p + 85, (1 << 14));\n\n    stw(p + 86, 0);\n\n    stw(p + 87, (1 << 14));\n\n}\n", "idx": 7430, "substitutes": {"s": ["t", "os", "S", "sports", "ans", "ds", "details", "is", "a", "ms", "l", "v", "r", "ps", "vs", "ins", "z", "less", "ss", "h", "aws", "o", "comm", "events", "changes", "bs", "i", "ns", "js", "b", "hs", "sq", "an", "g", "ses", "sts", "sys", "rs", "gs", "y", "ts", "es", "e", "ops", "stats", "m", "results", "its", "bis", "sv", "cs", "ims", "ants", "as", "c", "als", "parts", "ls", "sb", "n", "ats", "qs", "se", "sw"], "p": ["vp", "pp", "t", "cp", "pkg", "lp", "f", "progress", "d", "v", "sp", "r", "ps", "pc", "it", "post", "ping", "pg", "q", "mp", "wp", "w", "pa", "pro", "h", "j", "br", "power", "php", "pt", "port", "pad", "i", "ap", "ip", "proc", "np", "b", "point", "g", "at", "pb", "per", "pers", "pr", "fp", "tp", "ar", "jp", "dp", "op", "perm", "m", "up", "P", "bp", "pi", "x", "pid", "c", "pe", "n", "xp", "er", "pre"], "oldsize": ["oldSize", "oldercapacity", "oldscale", "oldersy", "olddim", "oldcache", "hardcache", "hardscale", " oldspace", " oldSIZE", "oldercache", "lowsize", "Oldsize", " oldscale", " oldcapacity", " olddim", "olderSIZE", "hardsize", " OldSize", "olderscale", "olderspace", " Oldsize", "OldSIZE", " oldcap", "oldsy", "oldspace", " oldsy", " Oldsy", "oldcap", " Oldcap", " oldSize", "oldcapacity", "lowcapacity", " oldcache", "lowSize", "olderSize", "olderdim", "oldSIZE", "Olddim", "lowspace", "oldercap", "oldersize"]}}
{"project": "FFmpeg", "commit_id": "7ec9c5ce8a753175244da971fed9f1e25aef7971", "target": 0, "func": "static int encode_apng(AVCodecContext *avctx, AVPacket *pkt,\n\n                       const AVFrame *pict, int *got_packet)\n\n{\n\n    PNGEncContext *s = avctx->priv_data;\n\n    int ret;\n\n    int enc_row_size;\n\n    size_t max_packet_size;\n\n    APNGFctlChunk fctl_chunk = {0};\n\n\n\n    if (pict && avctx->codec_id == AV_CODEC_ID_APNG && s->color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        uint32_t checksum = ~av_crc(av_crc_get_table(AV_CRC_32_IEEE_LE), ~0U, pict->data[1], 256 * sizeof(uint32_t));\n\n\n\n        if (avctx->frame_number == 0) {\n\n            s->palette_checksum = checksum;\n\n        } else if (checksum != s->palette_checksum) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Input contains more than one unique palette. APNG does not support multiple palettes.\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    enc_row_size    = deflateBound(&s->zstream, (avctx->width * s->bits_per_pixel + 7) >> 3);\n\n    max_packet_size =\n\n        AV_INPUT_BUFFER_MIN_SIZE + // headers\n\n        avctx->height * (\n\n            enc_row_size +\n\n            (4 + 12) * (((int64_t)enc_row_size + IOBUF_SIZE - 1) / IOBUF_SIZE) // fdAT * ceil(enc_row_size / IOBUF_SIZE)\n\n        );\n\n    if (max_packet_size > INT_MAX)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (avctx->frame_number == 0) {\n\n        if (!pict)\n\n            return AVERROR(EINVAL);\n\n\n\n        s->bytestream = avctx->extradata = av_malloc(FF_MIN_BUFFER_SIZE);\n\n        if (!avctx->extradata)\n\n            return AVERROR(ENOMEM);\n\n\n\n        ret = encode_headers(avctx, pict);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        avctx->extradata_size = s->bytestream - avctx->extradata;\n\n\n\n        s->last_frame_packet = av_malloc(max_packet_size);\n\n        if (!s->last_frame_packet)\n\n            return AVERROR(ENOMEM);\n\n    } else if (s->last_frame) {\n\n        ret = ff_alloc_packet2(avctx, pkt, max_packet_size, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        memcpy(pkt->data, s->last_frame_packet, s->last_frame_packet_size);\n\n        pkt->size = s->last_frame_packet_size;\n\n        pkt->pts = pkt->dts = s->last_frame->pts;\n\n    }\n\n\n\n    if (pict) {\n\n        s->bytestream_start =\n\n        s->bytestream       = s->last_frame_packet;\n\n        s->bytestream_end   = s->bytestream + max_packet_size;\n\n\n\n        // We're encoding the frame first, so we have to do a bit of shuffling around\n\n        // to have the image data write to the correct place in the buffer\n\n        fctl_chunk.sequence_number = s->sequence_number;\n\n        ++s->sequence_number;\n\n        s->bytestream += 26 + 12;\n\n\n\n        ret = apng_encode_frame(avctx, pict, &fctl_chunk, &s->last_frame_fctl);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        fctl_chunk.delay_num = 0; // delay filled in during muxing\n\n        fctl_chunk.delay_den = 0;\n\n    } else {\n\n        s->last_frame_fctl.dispose_op = APNG_DISPOSE_OP_NONE;\n\n    }\n\n\n\n    if (s->last_frame) {\n\n        uint8_t* last_fctl_chunk_start = pkt->data;\n\n        uint8_t buf[26];\n\n\n\n        AV_WB32(buf + 0, s->last_frame_fctl.sequence_number);\n\n        AV_WB32(buf + 4, s->last_frame_fctl.width);\n\n        AV_WB32(buf + 8, s->last_frame_fctl.height);\n\n        AV_WB32(buf + 12, s->last_frame_fctl.x_offset);\n\n        AV_WB32(buf + 16, s->last_frame_fctl.y_offset);\n\n        AV_WB16(buf + 20, s->last_frame_fctl.delay_num);\n\n        AV_WB16(buf + 22, s->last_frame_fctl.delay_den);\n\n        buf[24] = s->last_frame_fctl.dispose_op;\n\n        buf[25] = s->last_frame_fctl.blend_op;\n\n        png_write_chunk(&last_fctl_chunk_start, MKTAG('f', 'c', 'T', 'L'), buf, 26);\n\n\n\n        *got_packet = 1;\n\n    }\n\n\n\n    if (pict) {\n\n        if (!s->last_frame) {\n\n            s->last_frame = av_frame_alloc();\n\n            if (!s->last_frame)\n\n                return AVERROR(ENOMEM);\n\n        } else if (s->last_frame_fctl.dispose_op != APNG_DISPOSE_OP_PREVIOUS) {\n\n            if (!s->prev_frame) {\n\n                s->prev_frame = av_frame_alloc();\n\n                if (!s->prev_frame)\n\n                    return AVERROR(ENOMEM);\n\n\n\n                s->prev_frame->format = pict->format;\n\n                s->prev_frame->width = pict->width;\n\n                s->prev_frame->height = pict->height;\n\n                if ((ret = av_frame_get_buffer(s->prev_frame, 32)) < 0)\n\n                    return ret;\n\n            }\n\n\n\n            // Do disposal, but not blending\n\n            memcpy(s->prev_frame->data[0], s->last_frame->data[0],\n\n                   s->last_frame->linesize[0] * s->last_frame->height);\n\n            if (s->last_frame_fctl.dispose_op == APNG_DISPOSE_OP_BACKGROUND) {\n\n                uint32_t y;\n\n                uint8_t bpp = (s->bits_per_pixel + 7) >> 3;\n\n                for (y = s->last_frame_fctl.y_offset; y < s->last_frame_fctl.y_offset + s->last_frame_fctl.height; ++y) {\n\n                    size_t row_start = s->last_frame->linesize[0] * y + bpp * s->last_frame_fctl.x_offset;\n\n                    memset(s->prev_frame->data[0] + row_start, 0, bpp * s->last_frame_fctl.width);\n\n                }\n\n            }\n\n        }\n\n\n\n        av_frame_unref(s->last_frame);\n\n        ret = av_frame_ref(s->last_frame, (AVFrame*)pict);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        s->last_frame_fctl = fctl_chunk;\n\n        s->last_frame_packet_size = s->bytestream - s->bytestream_start;\n\n    } else {\n\n        av_frame_free(&s->last_frame);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7448, "substitutes": {"avctx": [" avcontext", "avctr", "wavctx", "averconn", "avercv", "apctr", "abctx", "avcv", "avecrit", "avcmd", "navtx", "savconn", "afcp", "avectx", "wavtx", " avcv", "abconn", "avecu", "avercu", "averkl", "apcontext", "abtxt", "abcontext", "savcontext", "ajcmd", " avctr", " avtxt", "vertx", " avobj", "avcu", "wavcontext", "afctx", "navctx", "navct", "wavjac", "avect", "savctx", "abtx", "afconf", "avetx", " avcookie", " avjac", " avtx", "avcrit", "navcrit", " avcrit", "ajconn", "abcookie", "averjac", "avcp", "avpkg", "apctx", "avercontext", "avcontext", "ajtx", "avectr", "averctx", "averobj", "abcv", "avertxt", "ajctx", "avercmd", "navcontext", "avtxt", "avct", "averpkg", "aptx", "avjac", "avecp", "ajcu", "avcookie", "verconn", "avconf", " avconn", "avconn", "avobj", "ajcontext", " avcu", "avecontext", " avkl", " avct", "afconn", "avepkg", "avertx", "afcontext", "vercontext", "afpkg", "abkl", "aftx", "averconf", "avkl", "aveconn", "avejac", "avercp", "navjac", "avecmd", "avtx", "verctx", "aveconf", "aveobj", "savcu", "avercookie"], "pkt": ["ppkg", "apkt", " pqt", "apacket", "pkg", "apkg", "ppacket", "pqt", " pkg", " packet", "packet", "ppkt", "ppqt", "apqt"], "pict": ["phot", "isch", "phys", "p", "pic", " pictures", "pai", " picture", "hum", "eric", "pit", "quant", "image", "agic", " img", "Pic", "pas", "phy", "Picture", "prop", "png", "sci", "pty", "kt", "comm", "photo", " pic", "fen", "fat", "pres", "act", "jpg", "pain", "photos", "avi", "capt", "stat", "cam", "Pict", "anim", "pen", " feat", "ct", "jit", "qi", "Fi", "fig", "mot", "gif", "cheat", "feat", "plain", "virt", "picture", "img"], "got_packet": ["got_ppel", "got___packseter", "got_packsel", "got_ppet", "got_packeter", "got_packets", "got___packet", "got___packset", "got___packsel", "got___packeter", "got_pel", "got_packset", "got_packel", "got___packel", "got_pets", "got___packets", "got___packsets", "got_ppets", "got_peter", "got_packsets", "got_pet", "got_ppeter", "got_packseter"], "s": ["p", "conf", "https", "l", "ns", "sq", "ses", "gs", "stats", "its", "ims", "c", "settings", "qs", "n", "services", "sc", "S", "scripts", "sac", "sp", "ps", "ctx", "w", "less", "ss", "st", "h", "sd", "js", "i", "b", "sts", "ts", "fs", "sis", "sb", "als", "ats", "sys", "sa", "sports", "is", "news", "sam", "ports", "aws", "so", "bs", "state", "sh", "scl", "sg", "rs", "m", "cs", "ls", "os", "ess", "ds", "v", "spec", "sm", "set", "hs", "ssl", "g", "pers", "store", "es", "utils", "sv", "aunts", "sw"], "ret": ["deg", "get", "fail", "t", "reset", "inter", "gt", "elt", "tf", "ll", "f", "RET", "arr", "nt", "re", "cont", "Ret", "fin", "it", "ft", "Return", "rets", "ext", "val", "fun", "rem", "gc", "mem", "mt", "result", "resp", "err", "usr", "rev", "ber", "ref", "len", "match", "print", "status", "res", "conv", "tr", "ter", "flag", "try", " RET", "final", "rt", "alt", "value", "out", "cmd"], "enc_row_size": ["enc_col_Size", "enc_rows_name", "enc_col_SIZE", "enc_rowxSIZE", "enc_row_name", "enc_row2name", "enc_rowxname", "enc_col_size", "enc_rowxsize", "enc_row2SIZE", "enc_col_max", "enc_pixel_size", "enc_row_max", "enc_pixel_len", "enc_pixel_SIZE", "enc_col_len", "enc_row2size", "enc_col_name", "enc_rowxoffset", "enc_row_Size", "enc_row2Size", "enc_rows_offset", "enc_row_offset", "enc_row_len", "enc_row_SIZE", "enc_rows_SIZE", "enc_rows_size"], "max_packet_size": ["max_packets_count", "max_packacket_size", "max_packets_size", "max_packet_length", "max_packets_SIZE", "max_packet_scale", "max_packets_Size", "max_packacket_scale", "max_packets_length", "_", "max_packet_Size", "max_packet_SIZE", "max_packet_count", "max_packacket_Size", "CT", "max_packacket_SIZE"]}}
{"project": "qemu", "commit_id": "d62b5dea30284eacd88055bb08db7c295655945f", "target": 0, "func": "BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,\n\n                                 QEMUIOVector *qiov, int nb_sectors,\n\n                                 BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BlockDriverAIOCB *ret;\n\n\n\n    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);\n\n\n\n    if (!drv)\n\n        return NULL;\n\n    if (bdrv_check_request(bs, sector_num, nb_sectors))\n\n        return NULL;\n\n\n\n    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,\n\n                              cb, opaque);\n\n\n\n    if (ret) {\n\n\t/* Update stats even though technically transfer has not happened. */\n\n\tbs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\tbs->rd_ops ++;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 7449, "substitutes": {"bs": ["ubs", "bn", "bos", "bps", "ds", "bh", "is", "css", "bm", "bes", "aus", "blog", "ms", "irms", "ctr", "vs", "ps", "aos", "hz", "bas", "outs", "js", "ns", "hs", "b", "bb", "bec", "BS", "boxes", "pb", "sts", "rs", "gb", "gs", "ts", "cks", "obs", "lbs", "ubis", "acs", "vals", "bits", "fs", "its", "bis", "bp", "cs", "eb", "ims", "sb", "als", "bf", "ls", "bsp", "qs", "sys", "bc", "bd"], "sector_num": ["sector2Num", "sector_tim", " sector_tim", "sectorixnum", "pixel_int", "sectoretynum", "sector_number", "sector_dec", "sectorixdec", " sector_no", "sectorixhom", " sector_mon", " sector_Num", "sectoretyno", "sector_hom", " sector_number", "pixel_dec", "sectoretyhom", "sector_int", "pixel_num", "sector2mon", "sector_Num", "pixel_hom", "sectoretymon", "sector2number", "sector_no", "sector_mon", "sector2num", " sector_hom", "sectorixint"], "qiov": ["qqiva", "qqiour", "qiop", " qiva", "aqiva", "aqiour", "qiosity", " kiev", " qiour", " kiop", "Qiosity", " kiov", "aqovi", "Qiov", " qiev", "qqiov", "Qiop", "qiour", "qiev", " qiosity", "Qiev", "qqovi", "qiva", "qovi", " qiop", "aqiov", " qovi", " kiosity"], "nb_sectors": ["nb_begments", "nb_sullers", "nb_schevers", "nb_psevers", "nb_seors", "nb_scheors", "nb_speivers", "nb_vegments", "nb_spectors", "nb_beurers", "nb_vellers", "nb_spegments", "nb_sellers", "nb_pseors", "nb_suors", "nb_veivers", "nb_peors", "nb_speors", "nb_psegments", "nb_temors", "nb_suivers", "nb_temctors", "nb_velements", "nb_temlements", "nb_temves", "nb_seivers", "nb_pevers", "nb_neves", "nb_segments", "nb_pegments", "nb_bellers", "nb_spellers", "nb_vectors", "nb_suctors", "nb_schectors", "nb_scheriers", "nb_spevers", "nb_seurers", "nb_neors", "nb_severs", "nb_seves", "nb_speriers", "nb_parsectors", "nb_parsegments", "nb_parsellers", "nb_veurers", "nb_veves", "nb_selements", "nb_seriers", "nb_bectors", "nb_pectors", "nb_parseurers", "nb_neriers", "nb_psectors", "nb_nelements", "nb_nectors", "nb_veors", "nb_nevers"], "cb": ["tc", "cm", "cp", "conf", "unc", "dt", "fn", "cv", "nb", "bt", "ctr", "func", "CB", "ctx", "cd", "cc", "fun", "cr", "fc", "bb", "pb", "gb", "ctrl", "cf", "ck", "db", "cfg", "conv", "job", "bp", "eb", "c", "cmd", "bf", "callback", "rb", "nc", "bc"], "opaque": ["suppaque", "hoponymous", "hopula", "oppa", "obacity", "paque", "opaques", "suppque", "oppaque", "topula", "hopally", "ppa", "opula", "supponymous", "hopque", "obaque", "imally", "opque", "obesc", "suppula", "pesc", "paques", "impa", "imaque", "oponymous", "opally", "opesc", "toponymous", "pally", "topaque", "opacity", "topque", "hopacity", "obaques", "hopaque", "oppacity", "oppaques", "oppesc", "hoppa", "pacity", "imacity"], "drv": ["drw", "drix", "drV", "DRw", "srv", "drivr", "drvr", "Drb", "drva", "srw", "driiver", "trh", "drx", "drj", " drva", " drj", "Drv", " drw", "driv", "trv", "Drvr", "driver", " drb", "driva", "triver", "driV", " drV", "drb", "srb", "drih", "Drw", "driw", " driver", "srj", "srvr", "DRva", " drvr", "drij", "DRv", "drh", "DRV", " drx", " drh", "trx"], "ret": ["pet", "out", "t", "elt", "lit", "gt", "reset", "tmp", "ll", "f", "RET", "rm", "arg", "cat", "nt", "re", "cont", "Ret", "it", "ft", "rets", "pas", "red", "cert", "val", "got", "j", "sat", "rem", "mt", "result", "resp", "lt", "def", "pret", "usr", "at", "rev", "ref", "len", "repl", "print", "jp", "status", "rect", "res", "det", "report", "tr", "ter", "ert", "flag", "bool", "leg", " Ret", " RET", "final", "back", "alt", "plain", "rt", "backed", "err"], "rd_ops": ["ptr_bytes", "rdvbytes", "rd_bits", "rdvhops", "rd__bytes", "rdvops", "ptrvops", "rdvbits", "rdpohops", "rdpoops", "ptr_hops", "rd_hops", "ptrvbytes", "rdpobytes", "ptr_bits", "ptrvbits", "ptr_ops", "rd__ops", "rd_bytes", "ptrvhops", "rd__hops", "rdpobits", "rd__bits"]}}
{"project": "qemu", "commit_id": "56b4a42a2e0ae74cee629abcb82993e79deeb356", "target": 0, "func": "static void migrate_set_downtime(QTestState *who, const char *value)\n\n{\n\n    QDict *rsp;\n\n    gchar *cmd;\n\n\n\n    cmd = g_strdup_printf(\"{ 'execute': 'migrate_set_downtime',\"\n\n                          \"'arguments': { 'value': %s } }\", value);\n\n    rsp = qtest_qmp(who, cmd);\n\n    g_free(cmd);\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n}\n", "idx": 7458, "substitutes": {"who": ["fil", " wo", "why", "compl", "wh", "since", "whe", "which", "WHERE", "because", "hu", "stro", "good", "yo", "wo", "WH", "where", " whom", " WHO", "how", "wid", " wh", "What", "what", "someone", "both", "well", "that", "wat", "hel", "kill", "hop", "Who", "you", " which", "WHO", " Who", "mail"], "value": ["json", "key", "hello", "vp", "place", "v", "data", "label", "field", "change", "rule", "node", "val", "set", "ue", "attribute", "format", "name", " Value", "property", "type", "text", "pain", "new", "now", "content", "unit", "values", "VALUE", "Value", "update", "widget"], "rsp": [" rsm", "srosp", " rSP", "rrSP", "Rtp", "rSP", "rpl", "Rpl", "rosp", "srresp", "rrsc", " rpl", "Rsp", "srSP", "rrpt", "rtp", " rsc", "Rsc", "resp", " rtp", " rresp", "rsc", "rsSP", "rrsm", "Rresp", "rsm", "rpt", " rosp", "rsesp", "rssp", "srsp", "rrpl", "rrsp", "Rsm", " rpt", "rrtp", " resp", "rspt", "rresp", "Rosp", "RSP"], "cmd": ["ptr", "key", "cp", "gt", "ch", "pkg", "Cmd", "mk", "ctr", "ind", "cat", "func", "col", "ctx", "msg", "call", "cd", "send", "txt", "obj", "ext", "str", "cb", "fun", "prop", "control", "req", "dq", "handle", "comm", "miss", "buff", "mem", "mt", "def", "bind", "buf", "md", "text", "command", "cmp", "cf", "cfg", "content", "exec", "cut", "help", "ct", "c", "urg", "ctl", "batch"]}}
{"project": "qemu", "commit_id": "90e26f5aacd265257f7de58ee59f72dc36dff40e", "target": 0, "func": "target_ulong do_arm_semihosting(CPUARMState *env)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    target_ulong args;\n\n    target_ulong arg0, arg1, arg2, arg3;\n\n    char * s;\n\n    int nr;\n\n    uint32_t ret;\n\n    uint32_t len;\n\n#ifdef CONFIG_USER_ONLY\n\n    TaskState *ts = cs->opaque;\n\n#else\n\n    CPUARMState *ts = env;\n\n#endif\n\n\n\n    if (is_a64(env)) {\n\n        /* Note that the syscall number is in W0, not X0 */\n\n        nr = env->xregs[0] & 0xffffffffU;\n\n        args = env->xregs[1];\n\n    } else {\n\n        nr = env->regs[0];\n\n        args = env->regs[1];\n\n    }\n\n\n\n    switch (nr) {\n\n    case TARGET_SYS_OPEN:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        s = lock_user_string(arg0);\n\n        if (!s) {\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        }\n\n        if (arg1 >= 12) {\n\n            unlock_user(s, arg0, 0);\n\n            return (uint32_t)-1;\n\n        }\n\n        if (strcmp(s, \":tt\") == 0) {\n\n            int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO;\n\n            unlock_user(s, arg0, 0);\n\n            return result_fileno;\n\n        }\n\n        if (use_gdb_syscalls()) {\n\n            ret = arm_gdb_syscall(cpu, arm_semi_cb, \"open,%s,%x,1a4\", arg0,\n\n                                  (int)arg2+1, gdb_open_modeflags[arg1]);\n\n        } else {\n\n            ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644));\n\n        }\n\n        unlock_user(s, arg0, 0);\n\n        return ret;\n\n    case TARGET_SYS_CLOSE:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"close,%x\", arg0);\n\n        } else {\n\n            return set_swi_errno(ts, close(arg0));\n\n        }\n\n    case TARGET_SYS_WRITEC:\n\n        {\n\n          char c;\n\n\n\n          if (get_user_u8(c, args))\n\n              /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n              return (uint32_t)-1;\n\n          /* Write to debug console.  stderr is near enough.  */\n\n          if (use_gdb_syscalls()) {\n\n                return arm_gdb_syscall(cpu, arm_semi_cb, \"write,2,%x,1\", args);\n\n          } else {\n\n                return write(STDERR_FILENO, &c, 1);\n\n          }\n\n        }\n\n    case TARGET_SYS_WRITE0:\n\n        if (!(s = lock_user_string(args)))\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        len = strlen(s);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"write,2,%x,%x\",\n\n                                   args, len);\n\n        } else {\n\n            ret = write(STDERR_FILENO, s, len);\n\n        }\n\n        unlock_user(s, args, 0);\n\n        return ret;\n\n    case TARGET_SYS_WRITE:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        len = arg2;\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"write,%x,%x,%x\",\n\n                                   arg0, arg1, len);\n\n        } else {\n\n            s = lock_user(VERIFY_READ, arg1, len, 1);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret = set_swi_errno(ts, write(arg0, s, len));\n\n            unlock_user(s, arg1, 0);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case TARGET_SYS_READ:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        len = arg2;\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"read,%x,%x,%x\",\n\n                                   arg0, arg1, len);\n\n        } else {\n\n            s = lock_user(VERIFY_WRITE, arg1, len, 0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            do {\n\n                ret = set_swi_errno(ts, read(arg0, s, len));\n\n            } while (ret == -1 && errno == EINTR);\n\n            unlock_user(s, arg1, len);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case TARGET_SYS_READC:\n\n       /* XXX: Read from debug console. Not implemented.  */\n\n        return 0;\n\n    case TARGET_SYS_ISTTY:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"isatty,%x\", arg0);\n\n        } else {\n\n            return isatty(arg0);\n\n        }\n\n    case TARGET_SYS_SEEK:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"lseek,%x,%x,0\",\n\n                                   arg0, arg1);\n\n        } else {\n\n            ret = set_swi_errno(ts, lseek(arg0, arg1, SEEK_SET));\n\n            if (ret == (uint32_t)-1)\n\n              return -1;\n\n            return 0;\n\n        }\n\n    case TARGET_SYS_FLEN:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_flen_cb, \"fstat,%x,%x\",\n\n                                   arg0, arm_flen_buf(cpu));\n\n        } else {\n\n            struct stat buf;\n\n            ret = set_swi_errno(ts, fstat(arg0, &buf));\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return buf.st_size;\n\n        }\n\n    case TARGET_SYS_TMPNAM:\n\n        /* XXX: Not implemented.  */\n\n        return -1;\n\n    case TARGET_SYS_REMOVE:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            ret = arm_gdb_syscall(cpu, arm_semi_cb, \"unlink,%s\",\n\n                                  arg0, (int)arg1+1);\n\n        } else {\n\n            s = lock_user_string(arg0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret =  set_swi_errno(ts, remove(s));\n\n            unlock_user(s, arg0, 0);\n\n        }\n\n        return ret;\n\n    case TARGET_SYS_RENAME:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        GET_ARG(3);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"rename,%s,%s\",\n\n                                   arg0, (int)arg1+1, arg2, (int)arg3+1);\n\n        } else {\n\n            char *s2;\n\n            s = lock_user_string(arg0);\n\n            s2 = lock_user_string(arg2);\n\n            if (!s || !s2)\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                ret = (uint32_t)-1;\n\n            else\n\n                ret = set_swi_errno(ts, rename(s, s2));\n\n            if (s2)\n\n                unlock_user(s2, arg2, 0);\n\n            if (s)\n\n                unlock_user(s, arg0, 0);\n\n            return ret;\n\n        }\n\n    case TARGET_SYS_CLOCK:\n\n        return clock() / (CLOCKS_PER_SEC / 100);\n\n    case TARGET_SYS_TIME:\n\n        return set_swi_errno(ts, time(NULL));\n\n    case TARGET_SYS_SYSTEM:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"system,%s\",\n\n                                   arg0, (int)arg1+1);\n\n        } else {\n\n            s = lock_user_string(arg0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret = set_swi_errno(ts, system(s));\n\n            unlock_user(s, arg0, 0);\n\n            return ret;\n\n        }\n\n    case TARGET_SYS_ERRNO:\n\n#ifdef CONFIG_USER_ONLY\n\n        return ts->swi_errno;\n\n#else\n\n        return syscall_err;\n\n#endif\n\n    case TARGET_SYS_GET_CMDLINE:\n\n        {\n\n            /* Build a command-line from the original argv.\n\n             *\n\n             * The inputs are:\n\n             *     * arg0, pointer to a buffer of at least the size\n\n             *               specified in arg1.\n\n             *     * arg1, size of the buffer pointed to by arg0 in\n\n             *               bytes.\n\n             *\n\n             * The outputs are:\n\n             *     * arg0, pointer to null-terminated string of the\n\n             *               command line.\n\n             *     * arg1, length of the string pointed to by arg0.\n\n             */\n\n\n\n            char *output_buffer;\n\n            size_t input_size;\n\n            size_t output_size;\n\n            int status = 0;\n\n#if !defined(CONFIG_USER_ONLY)\n\n            const char *cmdline;\n\n#endif\n\n            GET_ARG(0);\n\n            GET_ARG(1);\n\n            input_size = arg1;\n\n            /* Compute the size of the output string.  */\n\n#if !defined(CONFIG_USER_ONLY)\n\n            cmdline = semihosting_get_cmdline();\n\n            if (cmdline == NULL) {\n\n                cmdline = \"\"; /* Default to an empty line. */\n\n            }\n\n            output_size = strlen(cmdline) + 1; /* Count terminating 0. */\n\n#else\n\n            unsigned int i;\n\n\n\n            output_size = ts->info->arg_end - ts->info->arg_start;\n\n            if (!output_size) {\n\n                /* We special-case the \"empty command line\" case (argc==0).\n\n                   Just provide the terminating 0. */\n\n                output_size = 1;\n\n            }\n\n#endif\n\n\n\n            if (output_size > input_size) {\n\n                 /* Not enough space to store command-line arguments.  */\n\n                return -1;\n\n            }\n\n\n\n            /* Adjust the command-line length.  */\n\n            if (SET_ARG(1, output_size - 1)) {\n\n                /* Couldn't write back to argument block */\n\n                return -1;\n\n            }\n\n\n\n            /* Lock the buffer on the ARM side.  */\n\n            output_buffer = lock_user(VERIFY_WRITE, arg0, output_size, 0);\n\n            if (!output_buffer) {\n\n                return -1;\n\n            }\n\n\n\n            /* Copy the command-line arguments.  */\n\n#if !defined(CONFIG_USER_ONLY)\n\n            pstrcpy(output_buffer, output_size, cmdline);\n\n#else\n\n            if (output_size == 1) {\n\n                /* Empty command-line.  */\n\n                output_buffer[0] = '\\0';\n\n                goto out;\n\n            }\n\n\n\n            if (copy_from_user(output_buffer, ts->info->arg_start,\n\n                               output_size)) {\n\n                status = -1;\n\n                goto out;\n\n            }\n\n\n\n            /* Separate arguments by white spaces.  */\n\n            for (i = 0; i < output_size - 1; i++) {\n\n                if (output_buffer[i] == 0) {\n\n                    output_buffer[i] = ' ';\n\n                }\n\n            }\n\n        out:\n\n#endif\n\n            /* Unlock the buffer on the ARM side.  */\n\n            unlock_user(output_buffer, arg0, output_size);\n\n\n\n            return status;\n\n        }\n\n    case TARGET_SYS_HEAPINFO:\n\n        {\n\n            target_ulong retvals[4];\n\n            uint32_t limit;\n\n            int i;\n\n\n\n            GET_ARG(0);\n\n\n\n#ifdef CONFIG_USER_ONLY\n\n            /* Some C libraries assume the heap immediately follows .bss, so\n\n               allocate it using sbrk.  */\n\n            if (!ts->heap_limit) {\n\n                abi_ulong ret;\n\n\n\n                ts->heap_base = do_brk(0);\n\n                limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE;\n\n                /* Try a big heap, and reduce the size if that fails.  */\n\n                for (;;) {\n\n                    ret = do_brk(limit);\n\n                    if (ret >= limit) {\n\n                        break;\n\n                    }\n\n                    limit = (ts->heap_base >> 1) + (limit >> 1);\n\n                }\n\n                ts->heap_limit = limit;\n\n            }\n\n\n\n            retvals[0] = ts->heap_base;\n\n            retvals[1] = ts->heap_limit;\n\n            retvals[2] = ts->stack_base;\n\n            retvals[3] = 0; /* Stack limit.  */\n\n#else\n\n            limit = ram_size;\n\n            /* TODO: Make this use the limit of the loaded application.  */\n\n            retvals[0] = limit / 2;\n\n            retvals[1] = limit;\n\n            retvals[2] = limit; /* Stack base */\n\n            retvals[3] = 0; /* Stack limit.  */\n\n#endif\n\n\n\n            for (i = 0; i < ARRAY_SIZE(retvals); i++) {\n\n                bool fail;\n\n\n\n                if (is_a64(env)) {\n\n                    fail = put_user_u64(retvals[i], arg0 + i * 8);\n\n                } else {\n\n                    fail = put_user_u32(retvals[i], arg0 + i * 4);\n\n                }\n\n\n\n                if (fail) {\n\n                    /* Couldn't write back to argument block */\n\n                    return -1;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    case TARGET_SYS_EXIT:\n\n        if (is_a64(env)) {\n\n            /* The A64 version of this call takes a parameter block,\n\n             * so the application-exit type can return a subcode which\n\n             * is the exit status code from the application.\n\n             */\n\n            GET_ARG(0);\n\n            GET_ARG(1);\n\n\n\n            if (arg0 == ADP_Stopped_ApplicationExit) {\n\n                ret = arg1;\n\n            } else {\n\n                ret = 1;\n\n            }\n\n        } else {\n\n            /* ARM specifies only Stopped_ApplicationExit as normal\n\n             * exit, everything else is considered an error */\n\n            ret = (args == ADP_Stopped_ApplicationExit) ? 0 : 1;\n\n        }\n\n        gdb_exit(env, ret);\n\n        exit(ret);\n\n    case TARGET_SYS_SYNCCACHE:\n\n        /* Clean the D-cache and invalidate the I-cache for the specified\n\n         * virtual address range. This is a nop for us since we don't\n\n         * implement caches. This is only present on A64.\n\n         */\n\n        if (is_a64(env)) {\n\n            return 0;\n\n        }\n\n        /* fall through -- invalid for A32/T32 */\n\n    default:\n\n        fprintf(stderr, \"qemu: Unsupported SemiHosting SWI 0x%02x\\n\", nr);\n\n        cpu_dump_state(cs, stderr, fprintf, 0);\n\n        abort();\n\n    }\n\n}\n", "idx": 7462, "substitutes": {"env": ["et", "conf", "pkg", "conn", "msg", "wp", "cur", "self", "esp", "wcs", "er", "viron", "cmd", "oa", "event", "ptr", "cp", "dev", "environment", "vs", "ctx", "worker", "app", "scope", "inv", "serv", "obj", "w", "ew", "en", "eng", "js", "proc", "enc", "nw", "this", "context", "shell", "entry", "config", "esc", "org", "cb", "nv", "here", "neck", "e", "end", "param", "vis", "ev", "vt", "init", "vp", "cv", "v", "ec", "enter", "pg", "server", "req", "eve", "cfg", "sv", "addr", "hw", "window", "desc", "rb", "timer", "err", "sw"], "cpu": ["tc", "ka", "sc", "t", "cu", "cp", "p", "os", "util", " CPU", "rpm", "pkg", "apache", "conn", "aco", "sp", "dylib", "ctx", "pc", "hz", "linux", "gpu", "ruby", "cn", "gc", "device", "nu", "proc", "np", "clock", "mx", "CPU", "gnu", "ilo", "tp", "process", "alloc", "ck", "jp", "vm", "boot", "pu", "core", "hw", "cum", "lua", "us", "aux", "cli", "nic", "sys", "nc"], "cs": ["tc", "sc", "cp", "ds", "cus", "css", "ms", "ec", "ps", "vs", "ctx", "ins", "pc", "ks", "cc", "ss", "cons", "CS", "ys", "cn", "bs", "ns", "hs", "sts", "rs", "gs", "cks", "ck", "cf", "acs", "fs", "ct", "wcs", "ls", "aps", "sys", "nc"], "args": ["flags", "items", "fn", "ds", "ig", "uns", "aus", "ms", "arg", "ras", "arr", "att", "vs", "ins", "arms", "locks", "ks", "els", "j", "rows", "js", "ns", "err", "pres", "abis", "rs", "limits", "gs", "ars", "Args", "res", "actions", "vals", "bits", " arg", "fs", "ims", "names", "ants", "aux", "parts", "qs", "ags", "params", "tn"], "arg0": ["args0", "agg08", "tag0", "Arg1", "argument5", "tag5", "member0", "args1", "agg0", "argument1", " arg000", "ret2", "member08", "ret1", "tag1", "arg08", "arg4", "args2", "Arg5", "doc0", "block2", "ret0", "arg000", "block0", "doc5", "member06", "member2", "argument0", "argument3", " arg08", "ret000", "block1", "agg1", "args06", "argument2", "doc4", "Arg3", "Arg0", " arg06", " arg5", "Arg000", "arg5", "tag4", "args3", " arg4", "member1", "doc1", "arg06", "Arg2"], "arg1": ["args0", "Arg1", "args1", "argument1", "date3", "args2", "date0", "argument0", "argument3", "date1", "argument2", "prop1", "Arg0", "args3", "prop0", "prop2", "Arg2", "prop3"], "arg2": ["args0", "tag5", "date2", "tag6", "arg02", "args1", "argument1", "arg6", "doc02", "args2", "tag2", "doc5", "argument0", "argument3", "doc2", "tag02", "doc6", "date02", "argument2", "date5", "date6", "arg5", "args3"], "arg3": ["Arg3", "arg03", "arg4", "Arg4", " arg03", "tag4", " arg4", "tag2", "tag3", "tag03", "Arg2", "Arg03"], "s": ["t", "p", "S", "strings", "ds", "f", "is", "ms", "v", "r", "ps", "spec", "ins", "sl", "gets", "obj", "str", "less", "txt", "ss", "sam", "h", "aws", "tes", "bs", "space", "ns", "js", "hs", "b", "ssl", "sq", "sys", "g", "sts", "sg", "scl", "rs", "gs", "stats", "m", "fs", "its", "sv", "ims", "sb", "us", "ls", "n", "ats", "qs", "sql", "u"], "nr": ["ptr", "ng", "Ni", "nos", "our", " nos", "gov", "nah", " hr", " sidx", "kr", " ni", " ne", "ctr", "r", "er", "rr", "nor", "cb", "or", "nv", " yr", "nick", " NR", "sr", "nir", "nar", "nm", "about", "adr", " inval", "np", "usr", " intr", "hr", "nz", "ner", " nib", " nm", "rar", "rn", "nw", "sn", "uj", "arity", " resid", "ours", "radius", "tr", "ter", " ns", "byter", "wr", "ni", "num", "number", "gr", "NR", "nl", "aaa", "n", "nb", "nc", "err", "mr", "tn"], "ret": ["dr", "t", "reset", "elt", "gt", "lit", "success", "RET", "arg", "rm", "arr", "data", "nt", "re", "Ret", "url", "hash", "it", "rets", "pas", "obj", "ext", "val", "j", "ry", "ne", "gc", "jump", "mt", "result", "lt", "err", "def", "resp", "mem", "usr", "net", "ref", "row", "new", "status", "end", "res", "vals", "tr", "ter", "flag", "try", " RET", " Ret", "alt", "nl", "rt", "out"], "len": ["flags", "elt", "syn", "ll", "Len", "l", "length", "fin", "offset", "fun", "trans", "en", "size", "mem", "bytes", "rev", "ref", "rel", "vec", "flag", "seq", "bin", "ls", "nl", "alt", "lan", "ran", "lib"], "ts": ["tc", "t", "uts", "os", "Ts", "gt", "ds", "ms", "ps", "vs", "ins", "tz", "ics", "ens", "ss", "ys", "tes", "bs", "ns", "js", "hs", "TS", "mt", "sts", "rs", "gs", "tp", "ops", "stats", "fs", "us", "als", "ls", "ats", "rt", "vt", "tn"]}}
{"project": "FFmpeg", "commit_id": "1f28a991effadc64acd6915805b989ab43500f08", "target": 0, "func": "static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,\n\n                                         void *logctx, int size)\n\n{\n\n    uint8_t *user_data;\n\n    int e, build, i;\n\n\n\n    if (size < 16 || size >= INT_MAX - 16)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    user_data = av_malloc(16 + size + 1);\n\n    if (!user_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < size + 16; i++)\n\n        user_data[i] = get_bits(gb, 8);\n\n\n\n    user_data[i] = 0;\n\n    e = sscanf(user_data + 16, \"x264 - core %d\", &build);\n\n    if (e == 1 && build > 0)\n\n        h->x264_build = build;\n\n    if (e == 1 && build == 1 && !strncmp(user_data+16, \"x264 - core 0000\", 16))\n\n        h->x264_build = 67;\n\n\n\n    if (strlen(user_data + 16) > 0)\n\n        av_log(logctx, AV_LOG_DEBUG, \"user data:\\\"%s\\\"\\n\", user_data + 16);\n\n\n\n    av_free(user_data);\n\n    return 0;\n\n}\n", "idx": 7471, "substitutes": {"h": ["hd", "hm", "p", "host", "oh", "ih", "th", "bh", "f", "v", "r", "H", "ec", "hash", "hz", "w", "hi", "rh", "self", "he", "comm", "dh", "history", "ht", "hs", "b", "hist", "hr", "ah", "http", "m", "uh", "help", "hw", "hh", "hp", "c", "uth", "hl", "eh"], "gb": ["py", "gm", "gt", "fb", "eg", "hub", "pg", "vg", "cb", "universal", "gc", "ge", "gy", "rb", "rg", "bb", "g", "pb", "mb", "Gb", "kb", "gs", "db", "bg", "tg", "cfg", "gg", "GB", "yg", "sb", "gif", "gow", "bf", "nb", " GB", "img", "wb"], "logctx": ["launchcontext", "plotctx", "Logcc", "plotjac", "plotcontext", " logwork", "LOGcontext", "launchcoord", "logwork", "logjac", "Logcoord", " logcontext", " logcoord", "LOGwork", "LOGjac", "LOGctx", "logcc", " logjac", "launchcc", "launchctx", "logcoord", "Logcontext", "logcontext", " logcc", "Logctx", "plotwork"], "size": ["ffff", "capacity", "small", "max", "Size", "south", "use", "v", "sum", "ze", "data", "length", "SIZE", "ize", "position", "send", "offset", "power", "time", "empty", "body", "space", "format", "bytes", "name", "shift", "g", "fee", "sh", "large", "type", "scroll", "range", "height", "len", "now", "sn", "code", "m", "scale", "ce", "num", "number", "count", "year", "x", "c", "s", "message", "n", "z", "shape", "too", "cache", "sw", "sized"], "user_data": ["user1Data", "user_len", "usaptlog", "user_ata", "form1Data", "User_data", "user_next", " user_area", "user_DATA", "userPData", " user_dat", "user_dat", "user_list", "userPdata", "usereddata", "userptdata", "user_Data", "userPlength", "user_da", "user_log", "User_cache", " user_Data", "user1buffer", "form1dat", "userptdat", " user_list", "User_buffer", "User_val", "form_Data", "user_cache", "user_area", "userListcache", "form_buffer", " user_ata", "open_data", " user_DATA", "open_next", "user_result", "useredarea", "User_da", "form_dat", " user_more", "user_index", "userptlog", "User_list", "usermylen", "open_Data", "userListDATA", "User_DATA", "user_length", "userListindex", "open_ata", "usa_result", " user_len", "form_data", "user_buffer", "usa_data", "useredata", "User_Data", "usermylength", "form1buffer", "user1data", "userPlen", "usa_log", "User_index", " user_length", "usermydata", "usermyData", "userListdata", "userptDATA", "user1dat", "form1data", "usaptdata", "user_more", "usaptresult", "user_val", "userptresult"], "e": ["t", "ei", "et", "de", "element", "el", "eu", "eval", "d", "l", "le", "ze", "r", "ec", "ae", "me", "it", "eg", "oe", "error", "ep", "en", "ne", "eng", "complete", "ge", "ie", "ee", "we", "err", "est", "g", "eff", "fe", "es", "E", "end", "te", "ate", "ere", "ed", "eb", "eeee", "ent", "c", "ef", "EEE", "pe", "eps", "er", "ev", "se", "event"], "build": ["fail", "BU", "util", "p", "pack", "dev", "construct", "th", "no", "use", "f", "success", "d", "l", "v", "length", "dd", "builder", "sl", "built", "boost", "ld", "ff", "good", "or", "j", "false", "link", "building", "b", "make", "g", "type", "Build", "add", "test", "all", "round", "ac", "count", "uild", "c", "bf", "pe", "n", "create", "load", "ship", "se", "lib", "be"], "i": ["t", "li", "p", "sim", "bi", "is", "id", "ind", "ii", "v", "l", "ini", "mi", "ix", "r", "it", "ic", "q", "si", "oi", "j", "di", "port", "gi", "o", "io", "in", "chain", "ip", "ji", "b", "index", "point", "ui", "multi", "iu", "ij", "y", "zi", "PI", "ci", "ti", "m", "ai", "pi", "im", "ims", "ni", "x", "I", "phi", "qi", "c", "s", "u", "batch"]}}
{"project": "FFmpeg", "commit_id": "ae21776207e8a2bbe268e7c9e203f7599dd87ddb", "target": 0, "func": "void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n\n{\n\n    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);\n\n    AVFilterPad *dst = link->dstpad;\n\n    int i;\n\n\n\n    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);\n\n\n\n    if (!(filter_samples = dst->filter_samples))\n\n        filter_samples = avfilter_default_filter_samples;\n\n\n\n    /* prepare to copy the samples if the buffer has insufficient permissions */\n\n    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||\n\n        dst->rej_perms & samplesref->perms) {\n\n\n\n        av_log(link->dst, AV_LOG_DEBUG,\n\n               \"Copying audio data in avfilter (have perms %x, need %x, reject %x)\\n\",\n\n               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);\n\n\n\n        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,\n\n                                                          samplesref->audio->nb_samples);\n\n        link->cur_buf->pts                = samplesref->pts;\n\n        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;\n\n\n\n        /* Copy actual data into new samples buffer */\n\n        for (i = 0; samplesref->data[i]; i++)\n\n            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);\n\n\n\n        avfilter_unref_buffer(samplesref);\n\n    } else\n\n        link->cur_buf = samplesref;\n\n\n\n    filter_samples(link, link->cur_buf);\n\n}\n", "idx": 7472, "substitutes": {"link": ["pp", "light", "mark", "flex", "id", "l", "path", "scan", "call", "drive", "loc", "self", "handle", "slave", "connect", "mit", "db", "ment", "page", "loop", "lo", "url", "query", "dev", "pack", "play", "way", "sp", "list", "dd", "ml", "check", "ink", "device", "def", "tool", "lay", "flow", "flag", "all", "open", "block", "load", "entry", "let", "d", "lc", "thread", "label", "map", "ld", "port", "lock", "chain", "source", "download", "type", "command", "match", "e", "rel", "library", "skip", "local", "go", "mail", "lib", "relation", "li", "share", "task", "disk", "ln", "le", "me", "parent", "set", "style", "dl", "ssl", "info", "network", "tag", "line", "test", "route", "frame", "stream", "Link", "linked"], "samplesref": ["sizesRef", "Sampseb", "sonentsbr", "sonentsRef", "Samplesrev", " samplesRef", " sampskb", "sonesREF", "Sampsrev", "samplesval", " samplesbr", "sonentsrev", "sordsrel", " sampsreference", "Samplesval", "sonesob", "spleskb", "Sampsif", "splesreference", "sampleskb", "Samplesef", "Sampsrange", "sourcesRef", "sampsbr", "Sampsref", "splesref", "samplesef", "sonentskb", "Sampsold", "sizesrel", "sentsreference", "Sampsval", "sampsob", "samplesreference", "sourcesob", "sonentsrange", "sonesrange", "simsRef", "sampsRef", "sonentsrel", "sampsrel", "sonesrel", "sampleseb", "sentsob", "samplesif", "sampsef", " sampleslf", "sizesref", "sourcesbr", "sonesreference", "Samplesreference", "samplesrev", "sentsrange", " sampleskb", "sampslf", "sentsref", "sizesif", " samplesrange", "SampsREF", "Samplesref", "SampsRef", " sampsob", "simsreference", "sampsrev", "sampsold", "sentslf", "samplesrange", "sampsif", "SamplesRef", "Samplesrange", "sourcesreference", "sampsval", "Sampleseb", "samplesRef", " sampsbr", "sonentsreference", "sourcesold", "sordsrange", "samplesold", "samplesREF", "sampskb", "sourcesrel", "SamplesREF", "sourcesref", "samplesrel", "Samplesrel", " samplesob", "Sampsreference", "sonentseb", "sourcesef", "sonesref", "Sampsef", "splesval", "sonentsref", " sampslf", "sampsREF", "sordsRef", " sampsrange", "sordsref", " sampsRef", "sentsif", "Samplesold", "sampleslf", "sentsrel", "sentseb", "sampsreference", "sordsrev", "sentsRef", "sordslf", " sampsref", "splesRef", "sordsreference", "samplesbr", "simsold", "sampseb", "Samplesif", "splesef", "sampsref", "simsref", "sampsrange", "splesREF", "sizesob", "Sampsrel", " samplesreference", "samplesob", " samplesrel", "sonesval", " sampsrel"], "filter_samples": ["filter___nample", "filter_samps", "filter_damps", "filter_dents", "filter_mamps", "filter_unsets", "filter_gamps", "filter_unsamps", "filter_commamps", "filter_tamp", "filter___sample", "filter___sources", "filter_namples", "filter___samps", "filter_mizes", "filter_sents", "filter_mamp", "filter_Sample", "filter_namps", "filter_exents", "filter___namps", "filter_gvals", "filter_mamples", "filter_spvals", "filter_pources", "filter_commources", "filter_nources", "filter___nources", "filter_examps", "filter_Sacks", "filter_damples", "filter_nets", "filter_tamps", "filter_packs", "filter_tents", "filter_nample", "filter_unsamples", "filter_vamples", "filter_sample", "filter_examples", "filter_spamps", "filter_Samps", "filter_commamples", "filter_sources", "filter_tvals", "filter_gizes", "filter_exources", "filter_vamps", "filter_tets", "filter_pamples", "filter_tizes", "filter_tources", "filter_unsources", "filter_sets", "filter_samp", "filter_sizes", "filter_tamples", "filter_exacks", "filter_vizes", "filter___samples", "filter_pamps", "filter_commample", "filter_gamples", "filter_Samples", "filter_Sources", "filter_spizes", "filter_svals", "filter___namples", "filter_sacks", "filter_spamples", "filter_vamp"], "dst": ["lst", "sdut", " distant", "sest", "dlst", "idest", " dut", "sst", "ddest", "dest", " detc", "adut", "sddest", "dldest", "sdsp", "fsp", "sdest", "detc", "lsp", "dlt", "dsest", "ldest", "sdst", "addest", "dsst", " dtd", "dsot", "fst", "dsp", "ltd", "lot", "dsost", "distant", "Dst", "lest", " ddest", "lost", "dost", "fdest", "fest", "idost", "dlsp", " dsp", "idst", "sdlt", "Dsp", "dsut", "letc", "dot", "dut", "dtd", "Dost", "adlt", "adtd", "lut", "idistant", "dsistant", " dot", "dletc", "adst", "Ddest", "adost", "sost", "Dest", " dest", " dlt", " dost"], "i": ["key", "p", "ii", " ni", " pi", "it", "di", "gi", "slice", " si", "y", "ci", " j", "ims", "cli", " ii", " count", " I", "ix", "list", "ic", "si", "j", "ji", "index", " v", "zi", " c", "pi", "x", "phi", "us", " port", " l", "ind", "mi", " e", "span", "chain", "ip", "mac", "multi", " ti", "ti", "m", "ai", " mi", " k", "I", "s", " m", "init", "li", " multi", "sim", " iter", " info", "ki", "bi", " pos", " bi", "me", "\u0438", " x", " p", "o", "in", " li", "info", "g", "ui", "iu", "xi", "ij", " index", " di", "batch"]}}
{"project": "qemu", "commit_id": "d85937e683f6ff4d68293cb24c780fb1f6820d2c", "target": 0, "func": "static qemu_irq *ppce500_init_mpic(PPCE500Params *params, MemoryRegion *ccsr,\n\n                                   qemu_irq **irqs)\n\n{\n\n    qemu_irq *mpic;\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    int i, j, k;\n\n\n\n    mpic = g_new(qemu_irq, 256);\n\n    dev = qdev_create(NULL, \"openpic\");\n\n    qdev_prop_set_uint32(dev, \"nb_cpus\", smp_cpus);\n\n    qdev_prop_set_uint32(dev, \"model\", params->mpic_version);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n\n\n    k = 0;\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        for (j = 0; j < OPENPIC_OUTPUT_NB; j++) {\n\n            sysbus_connect_irq(s, k++, irqs[i][j]);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        mpic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n\n\n    memory_region_add_subregion(ccsr, MPC8544_MPIC_REGS_OFFSET,\n\n                                s->mmio[0].memory);\n\n\n\n    return mpic;\n\n}\n", "idx": 7480, "substitutes": {"params": ["json", "p", "conf", "config", "details", "properties", "types", "ps", "spec", "ctx", "phis", "eters", "phy", "pins", "posts", "caps", "points", "changes", "par", "tags", "gs", "sym", "ops", "m", "members", "results", "mm", "args", "pi", "ams", "as", "parts", "cms", "param", "settings", "terms", "AMS", "services"], "ccsr": [" acsur", "iscrs", "cksr", " acsr", "sctr", " acspr", "iscSR", "cfrs", "iscsur", "mcsr", "ccSR", "cfsr", "ccrs", "iscsr", "ccspr", "scsr", "cfSR", "mcsur", "cksur", "mctr", "ckrs", "cctr", "ckSR", "scsur", "ccsur", "scspr", "cfsur", "mcspr", " actr"], "irqs": ["irqu", " irq", "irteries", "ireries", " irqu", "irgs", " irws", "irtq", "irtqs", "irws", " irgs", " irdds", "pirqs", "ierqs", " ireries", "irtgs", "irdds", "irtdds", "pirqu", "pirq", "ierws", "iergs", "irtqu", "pireries", "ierdds", "irq", "irtws"], "mpic": ["mpric", "mpics", "mpico", " mpirc", "ompik", "pic", " mppic", "peic", "mirc", "MPIC", "mpik", "mppic", "peico", " mpiac", "mpIC", "mpac", "pik", "ppics", "opic", "MPik", "ompic", "ppic", "maric", "miac", "ppico", " mpac", "MPicon", "pric", "MPico", "opik", "opIC", "piac", "mac", "pirc", "ppIC", "marric", " mpik", " mpric", "marpic", "ompIC", "mpirc", "mpicon", "opicon", "ompicon", "mpiac", "MPics", "pac", "peIC", "marik", "MPic", "mic", "peics"], "dev": ["doc", "p", "de", "disk", "ds", "form", "priv", "debug", "d", "dist", "v", "data", "ow", "Device", "Dev", "dd", "gu", "devices", "gpu", "obj", "w", "pro", "h", "development", "ve", "pad", "device", "adv", "eng", "av", "sd", "js", "mem", "off", "def", "DEV", "ver", "info", "g", "md", "serial", "DE", "new", "develop", "vo", "db", "cam", "res", "rent", "det", "raw", "tr", "test", "hw", "window", "var", "desc", "dis", "des", "sky", "n", "sys", "go", "ev", "out", "cmd", "dem"], "s": ["t", "os", "S", "p", "ds", "is", "a", "d", "v", "sp", "ps", "serv", "sl", "w", "ss", "h", "bs", "sd", "js", "ns", "hs", "ssl", "b", "g", "socket", "sts", "sg", "rs", "gs", "ts", "es", "sym", "stats", "m", "local", "fs", "storage", "sv", "cs", "sb", "c", "n", "sys", "sw"], "i": ["ei", "li", "p", "ki", "bi", "is", "id", "ind", "ii", "v", "ini", "mi", "ix", "me", "it", "ic", "\u0438", "hi", "uri", "si", "oi", "di", "o", "gi", "ri", "in", "ie", "ip", "iq", "chain", "ji", "index", "point", "at", "ui", "multi", "iu", "xi", "y", "remote", "zi", "ij", "status", "e", "ci", "ti", "m", "this", "ami", "iy", "ai", "pi", "im", "ims", "x", "I", "phi", "us", "qi", "cli", "by", "n", "er", " ii"], "j": ["json", "fr", "ng", "dj", "kh", "p", "jac", "bj", "el", "jj", "v", "l", "ii", "att", "jl", "it", "kid", "q", "msg", "ev", "note", "jc", "obj", "str", "aj", "si", "jo", "br", "o", "pt", "bs", "ji", "js", "jump", "b", "oj", "adj", "g", "pr", "ij", "y", "kj", "jp", "e", "uj", "m", "try", "ja", "job", "jit", "je", "J", "c", "n", "by", "z", "u"], "k": ["ka", "key", "kh", "ke", "p", "conf", "K", "ki", "kn", "sk", "mk", "kk", "v", "kr", "uk", "kid", "q", "ks", "unk", "wk", "km", "ku", "kind", "ok", "o", "dk", "kl", "g", "kj", "isk", "ck", "m", "ko", "ik", "ek", "c", "kw", "n", "z"]}}
{"project": "qemu", "commit_id": "33577b47c64435fcc2a1bc01c7e82534256f1fc3", "target": 0, "func": "CharDriverState *qemu_chr_new(const char *label, const char *filename, void (*init)(struct CharDriverState *s))\n\n{\n\n    const char *p;\n\n    CharDriverState *chr;\n\n    QemuOpts *opts;\n\n    Error *err = NULL;\n\n\n\n    if (strstart(filename, \"chardev:\", &p)) {\n\n        return qemu_chr_find(p);\n\n    }\n\n\n\n    opts = qemu_chr_parse_compat(label, filename);\n\n    if (!opts)\n\n        return NULL;\n\n\n\n    chr = qemu_chr_new_from_opts(opts, init, &err);\n\n    if (err) {\n\n        error_report_err(err);\n\n    }\n\n    if (chr && qemu_opt_get_bool(opts, \"mux\", 0)) {\n\n        qemu_chr_fe_claim_no_fail(chr);\n\n        monitor_init(chr, MONITOR_USE_READLINE);\n\n    }\n\n    return chr;\n\n}\n", "idx": 7481, "substitutes": {"label": ["hide", "key", "Label", "lit", "el", "leaf", "id", "l", "data", "path", "prefix", "msg", "LAB", "abel", "els", "loc", "node", "layout", "alias", "description", "handle", "module", "location", "link", "cell", "color", "format", "name", "bind", "info", "bl", "type", "tag", "target", "abl", "rel", "title", "desc", "local", "lab", "value"], "filename": ["fil", "json", "vp", "fn", "nil", "f", "subject", "family", "l", "v", "data", "path", "file", "prefix", "files", "rl", "txt", "username", "uri", "str", "png", "description", "kl", "output", "nm", "location", "source", "driver", "metadata", "asm", "attr", "name", "input", "text", "fp", "tp", "rn", "pen", "fs", "title", "src", "s", "til", "Filename", "cmd"], "init": ["reset", "conn", "id", "it", "ic", "msg", "call", "cb", "set", "Init", "ok", "i", "js", "gen", "bind", "info", " fn", "buf", "act", "initialized", "seed", "fp", "alloc", "iter", "new", "late", "up", "iat", "initial", "base", "update", "c", "bin", "start", "n", "create", "load", "cmd"], "p": ["vp", "pp", "t", "cp", "rep", "pkg", "pic", "lp", "f", "progress", "d", "l", "v", "sp", "r", "ps", "pc", "path", "q", "wp", "pa", "j", "pt", "i", "ip", "ap", "np", "par", "g", "pb", "pr", "fp", "tp", "perm", "jp", "pat", "m", "P", "bp", "part", "pid", "c", "s", "pos", "n", "pre"], "chr": [" chbr", "Chrt", "ichrc", "electrc", "ichsr", "qr", "ichar", " chro", "chebr", "chbr", "echr", "chrt", "schrc", "chrc", " chdr", "chsr", "cherro", "schsr", "chtr", "Chr", "hrc", "chor", "electr", "chedr", "Chrc", "chra", "chedar", "Chdr", "hrt", "chro", "chera", "chedtr", "echar", "cherr", " chra", "qtr", "cheror", "Char", "chedro", " chtr", "hr", "chet", "hrs", "cherra", "ichro", "chrs", " cht", "chetr", "ichr", "cht", "schar", " chor", "qbr", "echro", "electrs", "chnrt", "chndr", "echtr", "Chrs", "chnr", "chero", "ichtr", "schr", "qt", "electrt", "echsr", "chdr", "chnar", "cher", " chrt", "echrc", "cheor"], "opts": ["optters", "opte", "oprs", "ottions", " oppt", "optsts", "iopps", "OPtions", "optks", " opks", "opsts", "optts", " opsts", "otte", " opps", " options", " opters", "options", "opks", "optte", "otts", "ports", "OPs", "opents", "porsts", "iopte", " opars", "oppt", "optents", "opttions", "OPks", " opte", "opers", "iopars", "OPts", "operrs", "opars", "ops", " ops", " oprs", " opents", "optars", "iopts", "otents", "optps", "optrs", "porters", "porpt", "opters", "operts", "opps", "OPrs", "opertions", "optpt"], "err": ["eas", "Er", "fr", "out", "gz", "elt", "eor", "ch", "warn", "conf", "cer", "kr", "arr", "er", "r", "rr", "norm", "error", "msg", "obj", "txt", "cb", "errors", "or", "die", "cr", "attr", "ns", "js", "resp", "usr", "erb", "buf", "fee", "pr", "iter", "rn", "e", "erd", "cfg", "res", "test", "gr", "riot", "aaa", "notice", "sys", "oe", "ev", "timer", "eps", "mr"]}}
{"project": "qemu", "commit_id": "7873df408dd44eb92840b108211d5aa5db7db526", "target": 0, "func": "static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,\n\n                            const char *model, const char *name,\n\n                            const char *ifname, const char *script,\n\n                            const char *downscript, const char *vhostfdname,\n\n                            int vnet_hdr, int fd)\n\n{\n\n    TAPState *s;\n\n\n\n    s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);\n\n    if (!s) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    if (tap_set_sndbuf(s->fd, tap) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd || tap->has_fds) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"fd=%d\", fd);\n\n    } else if (tap->has_helper) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"helper=%s\",\n\n                 tap->helper);\n\n    } else {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n                 \"ifname=%s,script=%s,downscript=%s\", ifname, script,\n\n                 downscript);\n\n\n\n        if (strcmp(downscript, \"no\") != 0) {\n\n            snprintf(s->down_script, sizeof(s->down_script), \"%s\", downscript);\n\n            snprintf(s->down_script_arg, sizeof(s->down_script_arg),\n\n                     \"%s\", ifname);\n\n        }\n\n    }\n\n\n\n    if (tap->has_vhost ? tap->vhost :\n\n        vhostfdname || (tap->has_vhostforce && tap->vhostforce)) {\n\n        int vhostfd;\n\n\n\n        if (tap->has_vhostfd) {\n\n            vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname);\n\n            if (vhostfd == -1) {\n\n                return -1;\n\n            }\n\n        } else {\n\n            vhostfd = -1;\n\n        }\n\n\n\n        s->vhost_net = vhost_net_init(&s->nc, vhostfd,\n\n                                      tap->has_vhostforce && tap->vhostforce);\n\n        if (!s->vhost_net) {\n\n            error_report(\"vhost-net requested but could not be initialized\");\n\n            return -1;\n\n        }\n\n    } else if (tap->has_vhostfd || tap->has_vhostfds) {\n\n        error_report(\"vhostfd= is not valid without vhost\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7490, "substitutes": {"tap": ["tif", "tc", "p", "conn", "pai", "raf", "eat", "tim", "typ", "wp", "submit", "amp", "each", "ap", " tapped", "apt", "comb", "db", "ta", "tm", "ctl", "pan", "cmd", "wan", "pot", "apache", "sp", "opa", "tar", "transform", "Tap", "phy", "lat", "php", "wt", "buff", "tw", "pb", "tip", "dp", "op", "flag", "snap", "tk", "tu", "tf", "config", "att", "map", "pa", "ip", "format", "lag", "socket", "cap", "TP", "hap", "tun", "t", "vp", "rep", "td", "tmp", "cat", "ping", "peak", "ga", "trace", "tag", "tp", "capt", "pin", "tg", "tr", "parse", "trap", "wat", "kat"], "peer": ["ptr", "p", "eth", "el", "conn", "handler", "sp", "ctx", "channel", "pc", "parent", "ger", "connection", "node", "server", "pro", "self", "port", "camera", "vr", "proc", "ssl", "socket", "net", "network", "buffer", "target", "tp", "pool", "ker", "instance", "ter", "owner", "client", "pid", "pe", "context", "er", "nc"], "model": ["dev", "dm", "el", "config", "controller", "models", "entity", "channel", "label", "policy", "image", "file", "sm", "address", "server", "version", "style", "port", "module", "device", "size", "link", "layer", "ver", "type", "network", "member", "serial", "Model", "command", "m", "domain", "base", "owner", "mod", "mode", "brand", "pe", "man", "action"], "name": ["key", "named", "host", "Name", "dev", "no", "el", "ame", "family", "id", "data", "normal", "channel", "path", "file", "address", "version", "filename", "alias", "nam", "nm", "size", "format", "info", "net", "cap", "type", "ename", "title", "part", "names", "mod", "n", "local", "NAME", "action"], "ifname": ["IFname", "ifno", "tifid", " ifName", " ifno", "tifnames", " ifn", "ifnames", " ifid", "IfName", "poolname", "ifName", "poolid", " ifame", "tifame", "IFName", "poolnames", "ifid", "ifn", "tifname", "Ifame", "poolno", "tifno", "IFn", "tifn", "Ifname", "tifName", "ifame", " ifnames"], "script": ["tc", "sc", "dev", "td", "scripts", "id", "cript", "pipe", "file", "address", "set", "style", "fun", "control", "description", "png", "option", "attr", "size", "source", "driver", "profile", "js", "sd", "info", "comment", "sh", "timeout", "type", "password", "buffer", "tag", "command", "exec", "test", "region", "sql", "shell", "program", "cmd", "lib", "action", "template"], "downscript": ["Downcommand", "downcommand", " downtemplate", "upcommand", "downtemplate", " downscripts", "upscripts", "droptemplate", "upscript", "subfunction", "upstyle", " downstyle", "Downscript", "Downscripts", " downScript", "dropScript", "downstyle", "Downstyle", "DOWNcommand", "upfunction", "uptemplate", "downscripts", " downcommand", "downScript", "downfunction", "subscript", "upScript", "Downfunction", "subcommand", "subscripts", "DOWNscripts", "DOWNScript", "DOWNscript", "dropstyle", "dropscript", "DOWNstyle"], "vhostfdname": ["vbindFDno", "vhostfdlen", "vhostfname", "vbindFDName", "vhostfcName", "vbindFDname", "vhostfcno", "vbindfdno", "vhostFDlen", "vhostFDName", "vHostfdName", "vbindfdName", "vhostfcname", "vhostfpName", "vhostfppath", "vhostfdpath", "vhostdirName", "vbindFDnum", "vbindfdname", "vhostFDnum", "vhostfilelen", "vbindfdnum", "vhostfpno", "vHostFDname", "vhostfileName", "vHostfdlen", "vhostfdno", "vhostFDno", "vhostfnum", "vhostfcnum", "vhostfdnum", "vhostdirlen", "vHostFDName", "vHostFDlen", "vhostfpname", "vhostFDname", "vhostfName", "vhostFDpath", "vHostfdname", "vhostdirname", "vhostfdName", "vhostfilename", "vhostfno", "vhostfcpath"], "vnet_hdr": ["vnet_hrd", "vnet_thdr", "vnet_phdr", "vnet_phr", "vnet_hhld", "vnet_wpar", "vnet_thrd", "vnet_wdr", "vnet_hhdr", "vnet_hpar", "vnet_phrd", "vnet_hDR", "vnet_phint", "vnet_thr", "vnet_hr", "vnet_hhDR", "vnet_wld", "vnet_hhpar", "vnet_hld", "vnet_hint", "vnet_thint", "vnet_wDR"], "fd": ["df", "ptr", "ffff", "hd", "dt", "fn", "td", "fi", "ds", "conn", "f", "handler", "d", "fm", "data", "pipe", "fin", "fb", "file", "dd", "connection", "cb", "ld", "ff", "handle", "port", "ud", "fl", "dl", "io", "dat", "fc", "sd", "gd", "ctl", "size", "dir", "buf", "socket", "fed", "buffer", "fp", " fid", "cf", "pd", "db", "rd", "fs", "addr", "window", "pid", "bf", "writer", "FD", "stream", "bd"], "s": ["tools", "p", "https", "sl", "gets", "ns", "sq", "ses", "gs", "y", "sn", "sym", "stats", "c", "des", "n", "qs", "services", "S", "sp", "ps", "vs", "ins", "less", "ss", "j", "changes", "js", "b", "sts", "tags", "ts", "fs", "csv", "sb", "als", "series", "ats", "sys", "sol", "states", "tests", "sports", "details", "is", "sam", "ports", "aws", "bs", "styles", "socket", "sg", "rs", "m", "as", "ls", "t", "os", "ds", "south", "ms", "spec", "ies", "sync", "sm", "set", "comm", "hs", "ssl", "g", "store", "ties", "es", "service", "sv", "sql", "sw"], "vhostfd": ["vstorefl", "evostfd", "svhostfin", "vtargetfd", "vportfi", "vserverfd", "vestarpid", "vheadd", "vehostpid", "svheadfin", "svhostfs", " vhostFD", "valuehostFD", "evostfp", "vhostfi", "vportfc", "vostfp", "vestarfp", "valuehostfd", "vserverfin", "vtargetfs", "vbindfd", "vestarfin", "vlocalhostFD", "vehostfin", "evhostfp", "vheadfs", "vserverfp", " vHostfi", "vhostfp", "evostflo", "vlocalhostpd", "evhostfd", "vheadfd", "vbindfi", "vlocalhostfin", "vstarpid", "vbarfd", "vstarfd", "vstoreflo", "vHostFD", " vhostfi", "vportfin", "valuelocalhostpd", "svheadd", "valuehostfin", "vportpd", "vostfd", "vhostfin", " vhostfc", "svhostd", "svhostfd", "vstarfp", "vbindpd", "vbindFD", "vlocalhostfp", "vstarfin", "vbindfin", "vcertfin", " vHostfd", "vhostpid", "vehostfp", "vhostfl", "vostfl", "vstorefd", "valuelocalhostfd", "vHostfd", "vhostflo", "evostfl", "vtargetfin", "valuehostpd", "vcertd", " vHostFD", "vhostfs", "vbarfl", "valuelocalhostFD", "evhostflo", "vlocalhostpid", "valuelocalhostfin", "vportFD", "vcertfd", "vHostfc", "svheadfs", "vbindfc", "vestarfd", "vbarfp", " vHostfc", "vtargetd", "vheadfin", "vhostfc", "vhostd", "vcertfs", "vhostpd", "vstorefp", "svheadfd", "vhostFD", "vHostfi", "vehostfd", "evhostfl", "vbarflo", "vportfd", "vlocalhostfd", "vostflo", "vserverpid"]}}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "int qdev_prop_check_globals(void)\n\n{\n\n    GList *l;\n\n    int ret = 0;\n\n\n\n    for (l = global_props; l; l = l->next) {\n\n        GlobalProperty *prop = l->data;\n\n        ObjectClass *oc;\n\n        DeviceClass *dc;\n\n        if (prop->used) {\n\n            continue;\n\n        }\n\n        if (!prop->user_provided) {\n\n            continue;\n\n        }\n\n        oc = object_class_by_name(prop->driver);\n\n        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);\n\n        if (!oc) {\n\n            error_report(\"Warning: global %s.%s has invalid class name\",\n\n                       prop->driver, prop->property);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n        dc = DEVICE_CLASS(oc);\n\n        if (!dc->hotpluggable && !prop->used) {\n\n            error_report(\"Warning: global %s.%s=%s not used\",\n\n                       prop->driver, prop->property, prop->value);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 7491, "substitutes": {"l": ["la", "t", "li", "p", "lb", "lit", "el", "lf", "lp", "ll", "ln", "v", "lc", "jl", "list", "ul", "z", "rl", "ml", "sl", "lang", "loc", "ld", "j", "fl", "dl", "kl", "o", "i", "b", "lin", "lt", "il", "g", "bl", "m", "acl", "lo", "all", "pl", "L", "lv", "c", "ls", "nl", "al", "hl", "local", "u", "tl", "ol"], "prop": ["ph", "key", "pick", "pp", "rep", "cp", "p", "conf", "lit", "prev", "pkg", "tmp", "Prop", "priv", "grab", "properties", "arg", "pred", "att", "col", "ps", "spec", "post", "msg", "typ", "loc", "str", "pro", "req", "j", "supp", "prot", "pt", "attr", "proc", "resp", "def", "err", "comp", "term", "buf", "pb", "per", "pr", "property", "decl", "opt", "tag", "prov", "perm", "op", "jp", "opp", "cfg", "rel", "rop", "test", "desc", "feat", "pos", "tab", "dep", "cmd"], "oc": ["rc", "toc", "isc", "ocon", "co", "OC", "unc", "oss", "oco", "erc", "orc", "aco", "org", "ec", "ocated", "oci", "pc", "ost", "roc", "mot", "obj", "loc", "ox", "arc", "orp", "ocate", "or", "ock", "yo", "ok", "o", "osc", "oca", "soc", "uc", "ot", "ocr", "alloc", "oot", "og", "ac", "bc", "c", "ob", "ro", "ocation", "oid", "ocal", "nic", "voc", "oe", "mc", "ico"], "dc": ["tc", "df", "rc", "dr", "doc", "cu", "cp", "sc", "dt", "de", "dm", "d", "vc", "ec", "lc", "cca", "pc", "dd", "cd", "loc", "cc", "dk", "di", "dq", "device", "gc", "fc", "driver", "mn", "dp", "cf", "cam", "db", "cmp", "disc", "DC", "ac", "bc", "c", "cmd", "nc", "mc", "bd"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int qesd_init_out (HWVoiceOut *hw, audsettings_t *as)\n\n{\n\n    ESDVoiceOut *esd = (ESDVoiceOut *) hw;\n\n    audsettings_t obt_as = *as;\n\n    int esdfmt = ESD_STREAM | ESD_PLAY;\n\n    int err;\n\n    sigset_t set, old_set;\n\n\n\n    sigfillset (&set);\n\n\n\n    esdfmt |= (as->nchannels == 2) ? ESD_STEREO : ESD_MONO;\n\n    switch (as->fmt) {\n\n    case AUD_FMT_S8:\n\n    case AUD_FMT_U8:\n\n        esdfmt |= ESD_BITS8;\n\n        obt_as.fmt = AUD_FMT_U8;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n    case AUD_FMT_U32:\n\n        dolog (\"Will use 16 instead of 32 bit samples\\n\");\n\n\n\n    case AUD_FMT_S16:\n\n    case AUD_FMT_U16:\n\n    deffmt:\n\n        esdfmt |= ESD_BITS16;\n\n        obt_as.fmt = AUD_FMT_S16;\n\n        break;\n\n\n\n    default:\n\n        dolog (\"Internal logic error: Bad audio format %d\\n\", as->fmt);\n\n        goto deffmt;\n\n\n\n    }\n\n    obt_as.endianness = AUDIO_HOST_ENDIANNESS;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n\n\n    hw->samples = conf.samples;\n\n    esd->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!esd->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        return -1;\n\n    }\n\n\n\n    esd->fd = -1;\n\n    err = pthread_sigmask (SIG_BLOCK, &set, &old_set);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    esd->fd = esd_play_stream (esdfmt, as->freq, conf.dac_host, NULL);\n\n    if (esd->fd < 0) {\n\n        qesd_logerr (errno, \"esd_play_stream failed\\n\");\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&esd->pt, qesd_thread_out, esd, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask(restore) failed\\n\");\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    if (close (esd->fd)) {\n\n        qesd_logerr (errno, \"%s: close on esd socket(%d) failed\\n\",\n\n                     AUDIO_FUNC, esd->fd);\n\n    }\n\n    esd->fd = -1;\n\n\n\n fail2:\n\n    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask(restore) failed\\n\");\n\n    }\n\n\n\n fail1:\n\n    qemu_free (esd->pcm_buf);\n\n    esd->pcm_buf = NULL;\n\n    return -1;\n\n}\n", "idx": 7498, "substitutes": {"hw": ["eas", "rew", "hd", "hm", "vp", "wan", "shake", "rpm", "htt", "pkg", "haw", "ww", "whe", "aus", "ews", "wx", "rw", "ow", "rack", "ctx", "ha", "igm", "aw", "hz", "hub", "igh", "wp", "fw", "ether", "phy", "rh", " HW", "ew", "wk", "w", "war", "wo", "aws", "each", "wy", "hog", "dh", "arp", "ht", "hs", "olf", "wn", "wd", "him", "wu", "mx", "usr", "sh", "ipp", "wind", "wi", "nw", "ich", "home", "MW", "hh", "hop", "wcs", "hap", "kw", "xp", "hl", "iw", "sw"], "as": ["nas", "os", "is", "a", "ras", "aus", "ach", "ms", "aos", "aw", "asar", "pas", "asi", "ra", "ast", "aws", "AS", "ass", "bs", "asha", "As", "asm", "ias", "asia", "an", "rs", "ars", "ar", "las", "ay", "ts", "asy", "has", "acs", "asa", "jas", "ase", "ais", "ams", "au", "ac", "ak", "us", "aux", "am", "s", "sa"], "esd": ["esds", "etssd", "sesda", "cesl", "sesg", "cesn", "easdc", "esdat", "vesd", "epssd", "esn", "essn", "easd", "besds", " esdi", "epsds", "gesdat", "etsdc", "esdo", "cesd", "essl", " esdh", "besg", "easda", "besd", "esda", "epsd", "gesl", "sessd", "sesdl", "esg", " esdl", "sesdc", " esdo", "esdh", "sesd", "etsda", "vesds", "essdh", "sespid", " esg", "essdat", " essd", "gesn", "besdi", "vesdo", "sesds", "esdl", "gesd", "vesdh", "sesdi", "epsdl", "essd", "espid", "bessd", "cesdat", "essds", "bespid", "eassd", " esds", "etsd", "esl", "esdi", " espid", "esdc", "essdo"], "err": ["eas", "rc", "Er", "dr", "fr", "gz", "eor", "ch", "cer", "dy", "priv", "kr", "arr", "r", "rss", "rr", "error", "bug", "msg", "txt", "cb", "ox", "str", " ec", "spr", "or", "br", "cr", "attr", "i", "rb", "ex", "resp", "usr", "exc", " intr", "ver", "nr", "buf", "ner", "iter", "rn", "cmp", "erd", "cfg", "e", "res", "try", "ter", "ere", "test", "orer", " Err", "yr", "cli", "Error", "notice", "sys", "er", "ev", "timer", "mr"], "set": ["get", "sc", "et", "conf", "reset", "ch", "cast", "config", "sk", "sp", "col", "ctx", "scan", "sets", "sync", "check", "change", "con", "sm", "loc", "en", "st", "valid", "read", "gc", "dat", "size", "sd", "Set", "ex", "clear", "gen", "ver", "g", "store", "new", "status", "SET", "stat", "end", "m", "local", "iat", "san", "test", "ac", "sb", "c", "start", "out", "sw", "add"], "old_set": [" old_SET", "old___block", " old_add", " old_Set", "old2SET", "old_SET", "old___SET", "old___set", "old_add", "old2set", "old___add", "old_block", "old_Set", " old_block", "old___Set", "old2add"]}}
{"project": "qemu", "commit_id": "03a63484a6978f68caff087bbaabcd1d383563af", "target": 1, "func": "static void monitor_find_completion(const char *cmdline)\n\n{\n\n    const char *cmdname;\n\n    char *args[MAX_ARGS];\n\n    int nb_args, i, len;\n\n    const char *ptype, *str;\n\n    const mon_cmd_t *cmd;\n\n    const KeyDef *key;\n\n\n\n    parse_cmdline(cmdline, &nb_args, args);\n\n#ifdef DEBUG_COMPLETION\n\n    for(i = 0; i < nb_args; i++) {\n\n        monitor_printf(cur_mon, \"arg%d = '%s'\\n\", i, (char *)args[i]);\n\n    }\n\n#endif\n\n\n\n    /* if the line ends with a space, it means we want to complete the\n\n       next arg */\n\n    len = strlen(cmdline);\n\n    if (len > 0 && qemu_isspace(cmdline[len - 1])) {\n\n        if (nb_args >= MAX_ARGS)\n\n            return;\n\n        args[nb_args++] = qemu_strdup(\"\");\n\n    }\n\n    if (nb_args <= 1) {\n\n        /* command completion */\n\n        if (nb_args == 0)\n\n            cmdname = \"\";\n\n        else\n\n            cmdname = args[0];\n\n        readline_set_completion_index(cur_mon->rs, strlen(cmdname));\n\n        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n            cmd_completion(cmdname, cmd->name);\n\n        }\n\n    } else {\n\n        /* find the command */\n\n        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n            if (compare_cmd(args[0], cmd->name))\n\n                goto found;\n\n        }\n\n        return;\n\n    found:\n\n        ptype = next_arg_type(cmd->args_type);\n\n        for(i = 0; i < nb_args - 2; i++) {\n\n            if (*ptype != '\\0') {\n\n                ptype = next_arg_type(ptype);\n\n                while (*ptype == '?')\n\n                    ptype = next_arg_type(ptype);\n\n            }\n\n        }\n\n        str = args[nb_args - 1];\n\n        if (*ptype == '-' && ptype[1] != '\\0') {\n\n            ptype += 2;\n\n        }\n\n        switch(*ptype) {\n\n        case 'F':\n\n            /* file completion */\n\n            readline_set_completion_index(cur_mon->rs, strlen(str));\n\n            file_completion(str);\n\n            break;\n\n        case 'B':\n\n            /* block device name completion */\n\n            readline_set_completion_index(cur_mon->rs, strlen(str));\n\n            bdrv_iterate(block_completion_it, (void *)str);\n\n            break;\n\n        case 's':\n\n            /* XXX: more generic ? */\n\n            if (!strcmp(cmd->name, \"info\")) {\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for(cmd = info_cmds; cmd->name != NULL; cmd++) {\n\n                    cmd_completion(str, cmd->name);\n\n                }\n\n            } else if (!strcmp(cmd->name, \"sendkey\")) {\n\n                char *sep = strrchr(str, '-');\n\n                if (sep)\n\n                    str = sep + 1;\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for(key = key_defs; key->name != NULL; key++) {\n\n                    cmd_completion(str, key->name);\n\n                }\n\n            } else if (!strcmp(cmd->name, \"help|?\")) {\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for (cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n                    cmd_completion(str, cmd->name);\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    for(i = 0; i < nb_args; i++)\n\n        qemu_free(args[i]);\n\n}\n", "idx": 7521, "substitutes": {"cmdline": ["commnet", "commline", " cmdtype", "mdtype", "commandlines", "Cmdline", "mdname", " cmdlines", "commLine", "commandname", "mdLine", "mdnet", "commandLine", "cmdlines", "cmdnet", "CmdLine", "commandline", " cmdLine", "Cmdname", "commandnet", "cmdLine", "commandtype", "mdline", "cmdtype", "mdlines"], "cmdname": ["CmdName", "ctrno", "cdNAME", "mdlen", "mdnames", "mddefault", " cmdName", "mdn", "commline", "ctrname", "msgline", "cmdno", "cdn", "cmdName", " cmddefault", "commName", "mdName", "mdno", " cmdlen", "commandno", "cmdn", "mdname", "commandnames", "commname", "msgtitle", "cmdtitle", " cmdtitle", "cdname", "commandname", " cmdn", "ctrline", "cmdNAME", " cmdNAME", "msgname", " cmdnames", "msgName", "Cmdnames", "commandline", "cmddefault", "Cmdlen", "cmdnames", "Cmdname", "mdNAME", "commdefault", "mdtitle", "mdline", "ctrnames", "cmdlen"], "args": ["flags", "tests", "strings", "items", "ig", "details", "ras", "atts", "arg", "ms", "types", "arr", "vs", "ps", "files", "words", "options", "posts", "aws", "points", "changes", "rows", "ns", "js", "md", "rs", "keys", "gs", "limits", "ars", "images", "ts", "Args", "stats", "results", "xs", "actions", "lines", "vals", "bits", "fs", "values", "orders", "cs", "ams", "names", "ims", "uments", "parts", "aux", "terms", "s", "qs", "array", "pos", "ags", "params"], "MAX_ARGS": ["MAX_ASYS", "MAX_PARMS", "MAX_REGS", "MAX_PARYS", "MAX_ASMS", "MAX_PARG", "MAX_ASG", "MAX_WARMS", "MAX_ASGV", "MAX_PARGV", "MAX_REG", "MAX_WARGS", "MAX_ARTS", "MAX_PARTS", "MAX_REGV", "MAX_RETS", "MAX_ARG", "MAX_WARG", "MAX_ASGS", "MAX_ASTS", "MAX_ARGV", "MAX_PARGS", "MAX_ARYS", "MAX_WARYS", "MAX_ARMS"], "nb_args": ["nb___flags", "nb__arg", "NB_params", "NB_args", "db_mails", "nb_cats", "nb__mails", "nv_amps", "NB_flags", "bnPresults", "nb_options", "nbjsargs", "bn_bots", "nb____amps", "nb_states", "db_args", "nb_limits", "NB_Args", "nb___args", "nb__Args", "nb____cats", "nu_args", "nr_states", "nb___cats", "nv___options", "nu_params", "NB_parts", "nb___bots", "bnPbots", "nb__apps", "nbPbots", "nb_bots", "nv___amps", "nb_arg", "nb_mails", "nb_apps", "nbjsoptions", "nb_Args", "bnPargs", "nb_gs", "nb___amps", "NB_arg", "nb__params", "nb__vals", "nb_bytes", "nb_vals", "nr_gs", "nbPresults", "nb__bots", "nb___limits", "NB_apps", "nb__bytes", "nbjscats", "db_values", "nv_options", "nbPargs", "nb_aux", "bn_args", "nr_args", "nb___options", "nb___results", "nb_values", "nb_changes", "nb_params", "nb__flags", "nb_results", "nb_parts", "nv___args", "nb____options", "nb___vals", "bn_results", "nu_changes", "nbjsamps", "nb_amps", "db_bots", "bnPlimits", "nr_aux", "nu_flags", "nb__args", "nb__values", "nv_cats", "nb___apps", "nb____args", "nb_flags", "bn_limits", "nv_args", "NB_vals", "NB_bytes", "nv___cats", "nbPlimits"], "i": ["init", "ei", "li", "p", "sim", "ki", "fi", "bi", "f", "is", "ind", "ii", "l", "ini", "v", "id", "mi", "ix", "me", "it", "list", "ic", "gu", "\u0438", "hi", "si", "oi", "j", "di", "gi", "io", "in", "ri", "ie", "ip", "ji", "index", "info", "g", "ui", "multi", "iu", "ij", "y", "xi", "zi", "iter", "e", "ci", "ti", "m", "ami", "try", "iri", "ai", "pi", "im", "ims", "qi", "I", "phi", "us", "c", "cli", "x", "n", "u"], "len": ["li", "lim", "elt", "lit", "el", "lf", "lp", "ln", "ll", "Len", "l", "limit", "full", "length", "lc", "fin", "list", "ml", "sl", "loc", "cl", "val", "fun", "ld", "en", "lon", "dl", "kl", "size", "bytes", "lt", "il", "mid", "cmp", "lig", "line", "ail", "vec", "pl", "L", "ls", "del", "nl", "lan", "n", "pos", "z", "lis", "Length"], "ptype": ["ctpe", "ototype", "petpe", "aptotype", "mintype", "vetyp", "ntype", "ctip", "pretotype", "typyp", "eptype", "eptpe", "petotype", "iptype", "montpe", "plotype", "pltype", " ptotype", "iptyp", "pointime", "minttype", "iptpe", "mintpe", "aptiff", "apttype", "cttype", "otiff", "vettype", "vetotype", "montotype", " ptip", " ptyp", "ctotype", "pointotype", "ptask", "nttype", "pointtype", "ptotype", "prettype", "iptotype", "otype", "ptip", "ptiff", "petype", "aptyp", "montask", " ptask", "typotype", "istpe", "petyp", "istype", "aptype", "monttype", "montype", "pointype", "ptrype", "isttype", "eptyp", "montyp", "ipttype", "ctype", "pretip", "typype", "vetype", "ptime", " pttype", "epttype", "ptrotype", "ptriff", "pttype", "otask", "typpe", "otyp", "istyp", "eptotype", "ptpe", "ntotype", "plype", "eptime", "plime", "istotype", "ptyp", "ntyp", "ptryp", "aptpe", "mintotype", "pretype", "ctyp"], "str": ["fr", "dr", "t", "p", "Str", "ch", "sec", "f", "ctr", "sp", "data", "arr", "r", "list", "file", "prefix", "msg", "inst", "obj", "txt", "cur", "trans", "st", "br", "read", "cr", "ns", "mt", "b", "err", "name", "buf", "pr", "rs", "buffer", "text", "ocr", "print", "res", "raw", "tr", "part", "seq", "STR", "vol", "s", "pos", "n", "out"], "cmd": ["clean", "gt", "pkg", "conn", "nt", "msg", "call", "send", "txt", "cur", "handle", "md", "cond", "quit", "cli", "c", "start", "cp", "ch", "qq", "dm", "rm", "ctx", "normal", "check", "obj", "phy", "fun", "kt", "mem", "proc", "dict", "def", "name", "bind", "cy", "ck", "find", "op", "raw", "try", "mode", "quick", "sys", "load", "ctr", "news", "cb", "cl", "ext", "good", "ok", "dir", "comp", "std", "command", "om", "exec", "that", "ct", "nd", "qt", "del", "add", "go", "init", "form", "Cmd", "mk", "cat", "col", "cd", "req", "dq", "comm", "cr", "resp", "cmp", "cf", "cfg", "job", "help", "window", "desc", "update", "kick", "cod", "batch"], "key": ["doc", "ke", "mk", "id", "data", "col", "ctx", "token", " Key", "prefix", "obj", "val", "k", "kind", "attr", "link", "def", "index", "type", "keys", "tag", "KEY", "code", "ck", "Key", "value"]}}
{"project": "qemu", "commit_id": "10a412dab3f54439ea3d60274eb41668f7d83bd2", "target": 0, "func": "static void sd_response_r1_make(SDState *sd,\n\n                                uint8_t *response, uint32_t last_status)\n\n{\n\n    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;\n\n    uint32_t status;\n\n\n\n    status = (sd->card_status & ~mask) | (last_status & mask);\n\n    sd->card_status &= ~CARD_STATUS_C | APP_CMD;\n\n\n\n    response[0] = (status >> 24) & 0xff;\n\n    response[1] = (status >> 16) & 0xff;\n\n    response[2] = (status >> 8) & 0xff;\n\n    response[3] = (status >> 0) & 0xff;\n\n}\n", "idx": 7556, "substitutes": {"sd": ["hd", "sc", "sim", "td", "ds", "sk", "sec", "od", "south", "d", "ind", "dash", "sing", "draw", "SD", "dd", "sta", "cd", "sam", "ss", "si", "ld", "style", "dk", "dl", "gd", "sy", "md", "sh", "sg", "vd", "sa", "store", "pd", "sn", "storage", "service", "sv", "sb", "dis", "sky", "s", "ard", "sys", "se", "dds", "bd"], "response": ["request", "view", "entry", "collection", "query", "relation", "reset", "environment", "respons", "api", "volume", "database", "onse", "application", "Response", "question", "channel", "list", "image", "error", "position", "connection", "version", "object", "ve", "attribute", "output", "profile", "vector", "value", "resp", "result", "point", "tree", "network", "buffer", "answer", "display", "e", "res", "all", "sequence", "window", "reference", "route", "transfer", "reply", "message", "array", "block", "next", "frame", "cache", "template"], "last_status": [" last_message", "last___status", " last___status", "last_msg", "last2stat", "last___stat", "last_stat", " last_msg", " last___msg", " last_stat", " last_Status", " last___stat", "last2status", "last_Status", "last2Status", "last_message", "last2msg", "last___Status", "last___message", " last___message", "last___msg"], "status": ["request", "sex", "sc", "active", "details", "success", "progress", "id", "sp", "data", "spec", "wait", "error", "ping", "Status", "msg", "sync", "xml", "check", "str", "login", "set", "version", "trans", "description", "iso", "valid", "reason", "gc", "i", "result", "state", "index", "name", "resp", "type", "command", "match", "code", "admin", "stat", "health", "res", "uses", "report", "service", "flag", "summary", "sequence", "magic", "s", "message", "value", "params", "score"]}}
{"project": "FFmpeg", "commit_id": "5674d4b0a35a34b75e3533a8580e0b5a0a8895a7", "target": 0, "func": "static int mpc8_decode_frame(AVCodecContext * avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MPCContext *c = avctx->priv_data;\n\n    GetBitContext gb2, *gb = &gb2;\n\n    int i, j, k, ch, cnt, res, t;\n\n    Band *bands = c->bands;\n\n    int off;\n\n    int maxband, keyframe;\n\n    int last[2];\n\n\n\n    keyframe = c->cur_frame == 0;\n\n\n\n    if(keyframe){\n\n        memset(c->Q, 0, sizeof(c->Q));\n\n        c->last_bits_used = 0;\n\n    }\n\n    init_get_bits(gb, buf, buf_size * 8);\n\n    skip_bits(gb, c->last_bits_used & 7);\n\n\n\n    if(keyframe)\n\n        maxband = mpc8_get_mod_golomb(gb, c->maxbands + 1);\n\n    else{\n\n        maxband = c->last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2);\n\n        if(maxband > 32) maxband -= 33;\n\n    }\n\n    c->last_max_band = maxband;\n\n\n\n    /* read subband indexes */\n\n    if(maxband){\n\n        last[0] = last[1] = 0;\n\n        for(i = maxband - 1; i >= 0; i--){\n\n            for(ch = 0; ch < 2; ch++){\n\n                last[ch] = get_vlc2(gb, res_vlc[last[ch] > 2].table, MPC8_RES_BITS, 2) + last[ch];\n\n                if(last[ch] > 15) last[ch] -= 17;\n\n                bands[i].res[ch] = last[ch];\n\n            }\n\n        }\n\n        if(c->MSS){\n\n            int mask;\n\n\n\n            cnt = 0;\n\n            for(i = 0; i < maxband; i++)\n\n                if(bands[i].res[0] || bands[i].res[1])\n\n                    cnt++;\n\n            t = mpc8_get_mod_golomb(gb, cnt);\n\n            mask = mpc8_get_mask(gb, cnt, t);\n\n            for(i = maxband - 1; i >= 0; i--)\n\n                if(bands[i].res[0] || bands[i].res[1]){\n\n                    bands[i].msf = mask & 1;\n\n                    mask >>= 1;\n\n                }\n\n        }\n\n    }\n\n    for(i = maxband; i < c->maxbands; i++)\n\n        bands[i].res[0] = bands[i].res[1] = 0;\n\n\n\n    if(keyframe){\n\n        for(i = 0; i < 32; i++)\n\n            c->oldDSCF[0][i] = c->oldDSCF[1][i] = 1;\n\n    }\n\n\n\n    for(i = 0; i < maxband; i++){\n\n        if(bands[i].res[0] || bands[i].res[1]){\n\n            cnt = !!bands[i].res[0] + !!bands[i].res[1] - 1;\n\n            if(cnt >= 0){\n\n                t = get_vlc2(gb, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1);\n\n                if(bands[i].res[0]) bands[i].scfi[0] = t >> (2 * cnt);\n\n                if(bands[i].res[1]) bands[i].scfi[1] = t & 3;\n\n            }\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < maxband; i++){\n\n        for(ch = 0; ch < 2; ch++){\n\n            if(!bands[i].res[ch]) continue;\n\n\n\n            if(c->oldDSCF[ch][i]){\n\n                bands[i].scf_idx[ch][0] = get_bits(gb, 7) - 6;\n\n                c->oldDSCF[ch][i] = 0;\n\n            }else{\n\n                t = get_vlc2(gb, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2);\n\n                if(t == 64)\n\n                    t += get_bits(gb, 6);\n\n                bands[i].scf_idx[ch][0] = ((bands[i].scf_idx[ch][2] + t - 25) & 0x7F) - 6;\n\n            }\n\n            for(j = 0; j < 2; j++){\n\n                if((bands[i].scfi[ch] << j) & 2)\n\n                    bands[i].scf_idx[ch][j + 1] = bands[i].scf_idx[ch][j];\n\n                else{\n\n                    t = get_vlc2(gb, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2);\n\n                    if(t == 31)\n\n                        t = 64 + get_bits(gb, 6);\n\n                    bands[i].scf_idx[ch][j + 1] = ((bands[i].scf_idx[ch][j] + t - 25) & 0x7F) - 6;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    for(i = 0, off = 0; i < maxband; i++, off += SAMPLES_PER_BAND){\n\n        for(ch = 0; ch < 2; ch++){\n\n            res = bands[i].res[ch];\n\n            switch(res){\n\n            case -1:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++)\n\n                    c->Q[ch][off + j] = (av_lfg_get(&c->rnd) & 0x3FC) - 510;\n\n                break;\n\n            case 0:\n\n                break;\n\n            case 1:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){\n\n                    cnt = get_vlc2(gb, q1_vlc.table, MPC8_Q1_BITS, 2);\n\n                    t = mpc8_get_mask(gb, 18, cnt);\n\n                    for(k = 0; k < SAMPLES_PER_BAND / 2; k++, t <<= 1)\n\n                        c->Q[ch][off + j + k] = (t & 0x20000) ? (get_bits1(gb) << 1) - 1 : 0;\n\n                }\n\n                break;\n\n            case 2:\n\n                cnt = 6;//2*mpc8_thres[res]\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += 3){\n\n                    t = get_vlc2(gb, q2_vlc[cnt > 3].table, MPC8_Q2_BITS, 2);\n\n                    c->Q[ch][off + j + 0] = mpc8_idx50[t];\n\n                    c->Q[ch][off + j + 1] = mpc8_idx51[t];\n\n                    c->Q[ch][off + j + 2] = mpc8_idx52[t];\n\n                    cnt = (cnt >> 1) + mpc8_huffq2[t];\n\n                }\n\n                break;\n\n            case 3:\n\n            case 4:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += 2){\n\n                    t = get_vlc2(gb, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3];\n\n                    c->Q[ch][off + j + 1] = t >> 4;\n\n                    c->Q[ch][off + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF);\n\n                }\n\n                break;\n\n            case 5:\n\n            case 6:\n\n            case 7:\n\n            case 8:\n\n                cnt = 2 * mpc8_thres[res];\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++){\n\n                    t = get_vlc2(gb, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5];\n\n                    c->Q[ch][off + j] = t;\n\n                    cnt = (cnt >> 1) + FFABS(c->Q[ch][off + j]);\n\n                }\n\n                break;\n\n            default:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++){\n\n                    c->Q[ch][off + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2);\n\n                    if(res != 9){\n\n                        c->Q[ch][off + j] <<= res - 9;\n\n                        c->Q[ch][off + j] |= get_bits(gb, res - 9);\n\n                    }\n\n                    c->Q[ch][off + j] -= (1 << (res - 2)) - 1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels);\n\n\n\n    c->cur_frame++;\n\n\n\n    c->last_bits_used = get_bits_count(gb);\n\n    if(c->cur_frame >= c->frames)\n\n        c->cur_frame = 0;\n\n    *data_size =  MPC_FRAME_SIZE * 2 * avctx->channels;\n\n\n\n    return c->cur_frame ? c->last_bits_used >> 3 : buf_size;\n\n}\n", "idx": 7558, "substitutes": {"avctx": [" avcontext", "evcontext", "evctx", "cvcmp", "avcfg", " avcmp", " avctl", "avcmp", "AVcmp", " avtx", "avectx", "avctl", "cvcontext", " avcfg", "avectl", "evctl", "AVcontext", "avecfg", "evcfg", "cvctx", "avcontext", "avtx", "avecontext", "AVtx", "AVctx", "cvtx"], "data": ["p", "a", "d", "r", "length", "mu", "DATA", "map", "pad", "Data", "read", "empty", "dat", "size", "body", "value", "bytes", "b", "def", "buffer", "text", "ata", "area", "m", "raw", "bits", "window", "bin", "message", "block", "input", "frame", "batch"], "data_size": ["buf_size", "buf_Size", "data_length", "buf_len", "buf_length", "data_Size", "data_len"], "avpkt": [" avpud", "avnpth", "avppkt", "avnpmit", "avPdu", " avPmit", "avjpkt", " avpdu", "avdud", "avPpt", " avPdu", "avjpud", "avPud", "avpmit", "avjpdu", "avpud", "avbppt", "avnpct", "avbpkt", "avdkt", " avPacket", "avjpth", " avPpt", " avPud", " avPth", " avpacket", "avppacket", " avppt", "avdacket", " avPct", "avjpmit", "avbpqt", "avPkt", "avjpacket", " avPkt", "avPacket", " avpmit", "avnpkt", " avpct", "avpppt", "avpdu", "avbpacket", " avPqt", " avpth", "avPmit", "avpth", "avPct", "avpacket", "avppqt", "avPth", "avppt", "avpqt", " avpqt", "avpct", "avjpct", "avddu", "avPqt"], "buf": ["rc", "p", "cv", "tmp", "nb", "v", "rw", "arr", "r", "ctx", "xff", "fb", "txt", "cb", "cur", "br", "read", "buff", "dat", "mem", "bytes", "b", "pb", "bl", "mb", "buffer", "db", "raw", "vec", "uf", "queue", "rb", "img", "cmd", "wb"], "c": ["tc", "rc", "sc", "cm", "cp", "p", "cu", "co", "conf", "com", "cv", "config", "f", "l", "v", "r", "lc", "ctx", "ec", "cont", "pc", "dc", "call", "C", "con", "coll", "cd", "cb", "cl", "cc", "cur", "abc", "h", "cn", "gc", "cr", "fc", "chain", "anc", "b", "comp", "g", "ctrl", "cmp", "enc", "e", "ci", "this", "m", "cf", "cam", "ca", "etc", "ce", "cs", "ct", "ac", "bc", "cal", "nc", "cache", "mc"], "gb2": ["mb5", "mb2", "gb3", "gb1", "gb5", "bg3", "db1", "cb2", "cb5", "sb5", "db2", "db3", "bg2", "sb2", "cb1", "bg1", "cb12", "mb12", "cb3", "sb12", "gb12"], "gb": ["py", "gm", "gz", "gt", "cv", "tmp", "bt", "bm", "fb", "eg", "hub", "pg", "goo", "gpu", "cb", "phy", "gc", "buff", "gd", "rb", "rg", "bytes", "b", "bb", "g", "mb", "band", "kb", "buffer", "gs", "ib", "gnu", "jpg", "db", "bg", "cfg", "tg", "gg", "GB", "bits", "storage", "eb", "uf", "csv", "sb", "gif", "nb", "img", "wb", "bd"], "i": ["init", "li", "ei", "p", "ki", "bi", "is", "mk", "id", "l", "v", "ii", "ind", "ini", "r", "mi", "ix", "it", "ic", "q", "\u0438", "hi", "si", "ish", "h", "di", "o", "gi", "io", "ji", "ip", "ie", "b", "index", "info", "ui", "multi", "iu", "ij", "xi", "y", "zi", "print", "e", "ci", "ti", "m", "ami", "ik", "ai", "pi", "ni", "im", "x", "I", "qi", "phi", "cli", "n"], "j": ["json", "dj", "bi", "jj", "v", "l", "it", "q", "jc", "aj", "o", "ji", "js", "jump", "index", "g", "ij", "kj", "jp", "uj", "m", "rel", "job", "J", "pos", "n", "z"], "k": ["ka", "key", "kh", "ke", "p", "K", "ki", "sk", "mk", "kk", "v", "kid", "q", "w", "km", "kind", "ok", "o", "g", "kj", "ck", "m", "ko", "ik", "ek", "ak", "z"], "ch": ["ph", "cha", "isch", "sc", "sch", "cp", "kh", "html", "chi", "through", "th", "el", "wh", "chu", "ech", "sk", "ach", "cho", "ind", "ble", "sp", "col", "chat", "channel", "och", "tch", "q", "zh", "chron", "cl", "chip", "ry", "che", "he", "CH", "qu", "chid", "h", "history", "ip", "ht", "ex", "cell", "hr", "ah", "sh", "Ch", "gh", "y", "height", "chn", "cht", "cy", "ich", "ay", "yet", "ca", "ek", "chan", "cs", "count", "tx", "sky", "hl"], "cnt": ["acount", " cNT", "lcnt", "cNT", "acct", "ncrt", "lcNT", "uncct", " cnd", "uncnd", " ccount", "crt", "Cct", "ccount", "Ccount", "account", "ncct", "lccount", "cct", "acnt", "uncnt", "lcct", "uncount", "Cnt", " crt", "ncount", "CNT", "ncnt", "Crt", "count", " cct", "acnd", "Count", "cnd", " count"], "res": ["rc", "os", "rep", "prev", "reset", "max", "RES", "success", "progress", "ras", "ms", "r", "re", "ps", "Res", "rss", "hash", "resolution", "val", "cons", "req", "ress", "rem", "ret", "chain", "resp", "result", "pres", "def", "rates", "resources", "range", "rev", "rs", "ref", "rest", "results", "rel", "vals", "raw", "bits", "reg", "tx", "seq", "sys", "err"], "t": ["tc", "p", "total", "dt", "tf", "tt", "f", "r", "nt", "tz", "typ", "tu", "txt", "o", "pt", "wt", "ret", "g", "type", "y", "ot", "tp", "ts", "ti", "te", "m", "tg", "tr", "ta", "tm", "n", "rt", "T"], "bands": ["states", "ions", "phones", "tracks", "bps", "codes", "classes", "models", "plugins", "planes", "balls", "dos", "chains", "videos", "frames", "devices", "files", "rooms", "words", "boards", "groups", "rings", "versions", "pins", "missions", "bright", "bars", "lists", "bs", "asters", " couples", "blocks", "lights", "boxes", "cats", "band", "heads", "gs", "tags", "products", "images", "photos", "artifacts", " brokers", "reports", "members", "banks", "bats", "bits", "bys", "archs", "apps", "parts", "hands", "ands", "cells", "tones", "objects", "dds"], "off": ["no", "f", "OFF", " offset", "error", "Off", "w", "offset", "ff", "ok", "o", "miss", " af", "of", "low", "eff", "new", "command", "op", "raw", "offs", " out", "on", "from", "pos", "out", "cmd"], "maxband": ["maximumbin", "powerbin", "maximumband", "hugefilter", " maxbrid", "Maxbridge", "oxbands", "highman", "highbridge", " maxcloud", "powerdisk", " maxdisk", "maximumBand", "largestbridge", "starfilter", "sumbridge", "highbrid", "Maxbands", "oxcloud", "starband", "hugeBand", "maxcloud", "maxbrid", "newline", "hugebin", "maximumbrid", "maximumiband", "maxbands", "axBand", "starbin", "highdisk", "maxfilter", "maximumline", "maxdisk", " maxbands", "highline", "maxBand", "axcloud", "maxline", "maxbridge", "finalBand", "maximumdisk", "powerBand", "MaxBand", " maxbin", " maxfilter", "highBand", "finalbands", "newband", "maxbin", "finalbin", "highiband", "maxman", "summan", "newnode", "sumBand", "powerband", "Maxband", "oxband", "axband", "maxnode", "newdisk", "highnode", "maxiband", "largestBand", "maximumnode", "axbands", "finalband", "sumband", "hugeband", "axbin", " maxbridge", "starBand", " maxman", "largestband", " maxiband", "oxBand", " maxBand", "highband"], "keyframe": ["powerframes", " keychannel", "linkchain", "powersequence", "linkframes", "powerfram", "KEYframe", "Keyfram", "popframes", "Keyframe", "powerchannel", "KEYchannel", "Keystroke", "mainframes", "linkframe", "keychannel", "mainstroke", "linkfram", "popfram", "Keyframes", "KeyFrame", " keystroke", " keysequence", "popframe", "keyframes", "keystroke", "keychain", "powerFrame", "keysequence", " keychain", "mainframe", "keyFrame", "KEYFrame", "Keysequence", " keyfram", " keyFrame", "powerframe", "KEYfram", "popchain", "mainfram", "keyfram", " keyframes"], "last": ["latest", "prev", "master", "old", "worst", "max", "cast", "no", "full", "since", "Last", "list", "shared", "scope", "pretty", "stable", "any", "largest", "style", "asts", "most", "good", "st", "ast", "show", "needed", "only", "sort", "build", "sold", "before", "history", "def", "est", "slave", "highest", "best", "rest", "las", "never", "now", "end", " Last", "same", "used", "bottom", "based", "both", "reverse", "base", "all", "lower", " lasts", "final", "count", "nd", "first", "ands", "push", "cache", " LAST", "total", "next", "out"], "mask": ["key", " masks", "max", "no", "weight", "Mask", "ask", "map", "offset", "ok", "miss", "lock", "correct", "result", "clear", "info", "eff", "zero", " cond", "cond", "m", "flag", "num", "final", " clear", "box", "batch"], "cur_frame": ["cur__state", "cur___frame", "current_frame", "current_bit", "cur_bit", "cur___state", "cur__bit", "cur_image", "cur___image", "cur___bit", "cur_state", "current_state", "current_image", "cur__frame", "cur__image"]}}
{"project": "qemu", "commit_id": "da57febfed7bad11be79f047b59719c38abd0712", "target": 0, "func": "DeviceState *qdev_try_create(BusState *bus, const char *name)\n\n{\n\n    DeviceState *dev;\n\n\n\n    if (object_class_by_name(name) == NULL) {\n\n        return NULL;\n\n    }\n\n    dev = DEVICE(object_new(name));\n\n    if (!dev) {\n\n        return NULL;\n\n    }\n\n\n\n    if (!bus) {\n\n        bus = sysbus_get_default();\n\n    }\n\n\n\n    qdev_set_parent_bus(dev, bus);\n\n    qdev_prop_set_globals(dev);\n\n\n\n    return dev;\n\n}\n", "idx": 7579, "substitutes": {"bus": ["bo", "util", "phys", "os", "host", "cast", "cus", "cat", "func", "nt", "ctx", "board", " BUS", "bolt", "bug", "bar", "loc", "Bus", "mount", "handle", "port", "gate", "lock", "device", "bs", "chain", "driver", "proc", "b", "state", "def", "buf", "stick", "serial", "db", "boot", "used", "bridge", "loop", "base", "test", "book", "us", "aux", "c", "bu", "back", "vol", "block", "box", "pos", "sys", "BUS", "bc", "lib", "hand"], "name": ["key", "named", "Name", "no", "ame", "family", "id", "data", "label", "path", "file", "parent", "prefix", "w", "str", "filename", "lat", "alias", "nam", "nm", "word", "mem", "ident", "term", "cap", "type", "class", "new", "len", "code", "m", "part", "names", "title", "c", "n", "value", "NAME"], "dev": ["ptr", "out", "doc", "de", "disk", "ch", "tmp", "th", "conn", "priv", "ach", "d", "v", "nt", "data", "app", "Device", "ow", "Dev", "normal", "scan", "dd", "gu", "devices", "serv", "gpu", "obj", "w", "any", "val", "cur", "prop", "pro", "di", "development", "ve", "av", "device", "pad", "dat", "dn", "sd", "mem", "proc", "def", "DEV", "ver", "current", "buf", "stick", "usb", "DE", "enc", "cam", "db", "res", "tr", "test", "hw", "final", "tech", "des", "del", "sw", "local", "go", "ev", "dep", "cmd", "dem"]}}
{"project": "qemu", "commit_id": "31478f26ab4ed82d35b763bbf259810d0c8b44e1", "target": 1, "func": "Visitor *qobject_input_visitor_new_keyval(QObject *obj)\n\n{\n\n    QObjectInputVisitor *v = qobject_input_visitor_base_new(obj);\n\n\n\n    v->visitor.type_int64 = qobject_input_type_int64_keyval;\n\n    v->visitor.type_uint64 = qobject_input_type_uint64_keyval;\n\n    v->visitor.type_bool = qobject_input_type_bool_keyval;\n\n    v->visitor.type_str = qobject_input_type_str;\n\n    v->visitor.type_number = qobject_input_type_number_keyval;\n\n    v->visitor.type_any = qobject_input_type_any;\n\n    v->visitor.type_null = qobject_input_type_null;\n\n    v->visitor.type_size = qobject_input_type_size_keyval;\n\n\n\n    return &v->visitor;\n\n}\n", "idx": 7590, "substitutes": {"obj": ["bo", "os", "oss", "bh", "tmp", "gov", "org", "nt", "it", "txt", "object", "j", "o", "pt", "comm", "attr", "bs", "js", "ht", "resp", "bb", "po", "oj", "act", "pr", "onet", "ref", "opt", "ot", "xy", "obs", "og", "rect", "hw", "Obj", "ob", "obo", "cmd"], "v": ["get", "vp", "dev", "tv", "ch", "vi", "cv", "f", "vc", "l", "vs", "qv", "em", "inv", "ev", "vt", "w", "vv", "val", "version", "en", "nv", "j", "av", "ve", "st", "qu", "u", "value", "b", "ver", "g", "y", "om", "vm", "e", "m", "iv", "conv", "etc", "sv", "ov", "pi", "lv", "x", "env", "vis", "z", "V", "wire", "nov", "vy", "uv"]}}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)\n\n{\n\n    int iomemtype;\n\n    pl080_state *s;\n\n\n\n    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));\n\n    iomemtype = cpu_register_io_memory(0, pl080_readfn,\n\n                                       pl080_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->nchannels = nchannels;\n\n    /* ??? Save/restore.  */\n\n    return s;\n\n}\n", "idx": 7596, "substitutes": {"base": ["key", "p", "reset", "bound", "total", "max", "balance", "f", "use", "id", "l", "v", "bid", "it", "file", "position", "prefix", "bas", "padding", " bases", "address", "offset", "set", "pa", "k", "handle", "h", "se", "size", "i", "b", "state", "root", "name", "index", "memory", "cpu", "birth", "mb", "type", "zero", "ref", "buffer", "y", "range", "area", "Base", "m", "based", "relative", "ase", "scale", "bare", "bp", "bit", "x", "c", "bf", "null", "pe", "start", "local", "frame", "out"], "irq": ["irqu", "irick", " irequ", "iraqu", "iriqu", "iroqi", " drqi", " cirqu", " drch", "ibrck", "irck", "irequ", "iraqi", "ireqs", "iriv", "iroqu", "ibrv", "irqs", " cirqi", " cirq", " ireqi", "riv", "irv", " drqu", "iroqs", "riq", "iraq", "ibrq", "irch", " irech", "ireqi", "irqi", "rick", "iraqs", " circh", "ibrqu", " ireq", "iroq", "riqu", "iriq", "ireq", " drq"], "nchannels": ["nquunks", "nChords", "narchannels", "nChaps", "narchunks", " narchunks", "nnaps", "nChars", "ncunks", " narchannels", "nachusters", "nChunks", "Nchaps", "nChannels", "ncans", "nquusters", "NChaps", "nquannels", " nChannels", "nachans", " narchans", " nChunks", "Nchords", "nchans", "nquars", "narchans", "nchars", "NChannels", " nchusters", "nachunks", " nChars", "nChans", "nachars", "nchusters", " nchars", "nachaps", "narchars", "nchunks", " narchars", "nchaps", " nchunks", "nChusters", "nchords", "nnords", "nachannels", "Nchannels", "ncars", "NChans", " nChusters", "nachords", "NChords", "nnannels", " nchans", "nnans", "ncannels", "Nchans"], "iomemtype": ["iomEMtypes", "iomeminype", "iomeminposition", "iomomposition", "iomEMkind", "iomeemrole", "iomimertype", "iomomrole", "olyneemcat", "iamEMType", "iomEmrole", "iomEmtype", "iomemetype", "iomeminrole", "iomemekind", "iomeembase", "iomiemtype", "iomiemrole", "olynemtype", "iomemsType", "iomimerrole", "iomembase", "ioticemtype", "iomEMType", "iomeemcat", "iamEMtypes", "iomemstypes", "iamemType", "olyneemtype", "iomemetypes", "iomiemcat", "iomimerbase", "iomemype", "iomomype", "ioticemintype", "iomemstype", "iomemeType", "olynembase", "iomemkind", "olyneemrole", "iomeemtype", "iamemtypes", "iamEMtype", "iomemskind", "iomemposition", "iomEmype", "ioticeminrole", "iomiembase", "ioticeminposition", "iamemkind", "iomemintype", "iamemtype", "iomimercat", "olyneembase", "olynemrole", "iomEmposition", "iomemcat", "iomEMtype", "iamEMkind", "iomomtype", "ioticemrole", "ioticemype", "iomemrole", "olynemcat", "ioticemposition", "iomemType", "ioticeminype", "iomemtypes"], "s": ["t", "os", "S", "p", "sports", "save", "ds", "details", "is", "a", "f", "l", "v", "r", "ps", "spec", "ins", "ies", "sl", "w", "gets", "set", "ss", "single", "self", "ports", "j", "h", "o", "st", "so", " is", "bs", "i", "js", "ns", "source", "b", "ings", "sq", "an", "g", "ses", "sts", "sys", "pers", "rs", "gs", "y", "status", "ts", "es", "e", "stats", "m", "fs", "its", "sv", "bis", "cs", "ears", "sb", "c", "ls", "n", "qs", "z", "ats", "ers", "se", "services"]}}
{"project": "FFmpeg", "commit_id": "596b5c488fa1d40f114a64d3b73e1863cab073fb", "target": 0, "func": "static av_cold void init_coef_vlc(VLC *vlc, uint16_t **prun_table,\n\n                                  float **plevel_table, uint16_t **pint_table,\n\n                                  const CoefVLCTable *vlc_table)\n\n{\n\n    int n                        = vlc_table->n;\n\n    const uint8_t  *table_bits   = vlc_table->huffbits;\n\n    const uint32_t *table_codes  = vlc_table->huffcodes;\n\n    const uint16_t *levels_table = vlc_table->levels;\n\n    uint16_t *run_table, *level_table, *int_table;\n\n    float *flevel_table;\n\n    int i, l, j, k, level;\n\n\n\n    init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0);\n\n\n\n    run_table    = av_malloc(n * sizeof(uint16_t));\n\n    level_table  = av_malloc(n * sizeof(uint16_t));\n\n    flevel_table = av_malloc(n * sizeof(*flevel_table));\n\n    int_table    = av_malloc(n * sizeof(uint16_t));\n\n    i            = 2;\n\n    level        = 1;\n\n    k            = 0;\n\n    while (i < n) {\n\n        int_table[k] = i;\n\n        l            = levels_table[k++];\n\n        for (j = 0; j < l; j++) {\n\n            run_table[i]    = j;\n\n            level_table[i]  = level;\n\n            flevel_table[i] = level;\n\n            i++;\n\n        }\n\n        level++;\n\n    }\n\n    *prun_table   = run_table;\n\n    *plevel_table = flevel_table;\n\n    *pint_table   = int_table;\n\n    av_free(level_table);\n\n}\n", "idx": 7598, "substitutes": {"vlc": ["vlcc", "wlcs", "wlc", "plpc", "wlcc", "vrl", "vrpc", "vrci", "flcc", "vrc", "vlci", "plci", "nlci", "vll", "vlcs", "flcs", "rlcs", "nlpc", "pll", "plc", "rlt", "vlpc", "vlt", "nlc", "flc", "flt", "wlt", "rlc", "nll", "rlcc"], "prun_table": ["prun___table", "prunc_tab", "prun__database", "prun_list", "prun__tab", "prange_table", "prun___TABLE", "prange_TABLE", "prun2list", "prunc_list", "prunstab", "prange___TABLE", "prunslist", "prun_tab", "prange___list", "prun__list", "pruncsdatabase", "pruncslist", "prange_list", "prun2table", "prange___table", "prun_TABLE", "pruncstab", "prange_tree", "prunc_table", "pruncstable", "prun2TABLE", "prunstable", "prun__table", "prun2tree", "prun___tree", "prun_tree", "prun_database", "prange___tree", "prunsdatabase", "prun___list", "prunc_database"], "plevel_table": ["pleVEL_stable", "plevelitytable", "pleVEL_tree", "pleep_tab", "plevelityTABLE", "plevel_tree", "plevel___TABLE", "pleep_stable", "plevel_TABLE", "pleVEL_table", "plevel___tree", "plevel_tab", "plevel___table", "pleep_TABLE", "plevel___stable", "plevel_stable", "pleVEL_TABLE", "plevelitytab", "pleep_table", "plevelitystable"], "pint_table": ["pind_table", "pint__cache", "pind_list", "pint__TABLE", "pint2tab", "pint_data", "pint_list", "pint_cache", "pint2table", "pind_cache", "pint__list", "pint_TABLE", "pind_TABLE", "pind_tab", "pint2TABLE", "pint__table", "pint_tab", "pind_data", "pint2data"], "vlc_table": ["vlcs_cache", "vlac_tree", "vlcf_tree", "vlc_server", "vlcs_TABLE", "vlc_cache", "vlc_tree", "vlxc_window", "vlcpyinternal", "vlc_TABLE", "vlc_target", "vlc_window", "vlxc_total", "vlcpytotal", "vlc_internal", "vlc_t", "vlxcpytable", "vlcf_table", "vlac_buffer", "vlac_target", "vlcf_server", "vlc_tab", "vlxcpytotal", "vlac_table", "vlcpywindow", "vlcpytable", "vlxcpywindow", "vlxcpyinternal", "vlac_tab", "vlac_t", "vlcf_tab", "vlxc_internal", "vlcs_table", "vlcs_tab", "vlxc_table", "vlc_total", "vlc_buffer"], "table_bits": ["buffer_flags", "table___flags", "table_limits", "table_plugins", "table_flags", " table_plugins", "table___codes", "table___plugins", " table_flags", "table_keys", "buffer_keys", "table___bits", "buffer_limits", "buffer_bits"], "table_codes": ["treemopcells", "binary___names", "binary_codes", "binary_names", "binary___checks", "binary___codes", "table___details", "tablemopcells", "binary_checks", "table___codes", "tablemopnames", "table_properties", "tablemopcodes", "table_details", "tree_properties", "tablemopbits", "binary_details", "tree_bits", "treemopproperties", "table_checks", "tree_cells", "table___names", "treemopcodes", "table_cells", "table___checks", "tablemopdetails", "tree_codes", "treemopbits", "binary___details", "tablemopchecks", "table_names", "tablemopproperties"], "levels_table": ["levels00table", "levels8table", "lights_top", "levels_database", "levelsaltable", "levels_point", "levelsaloption", "levelsalpoint", "levels_file", "levels00option", "levels8tab", "levels8file", "levels_option", "levelsaltop", " levels_tab", "lights_option", "lights_point", "levels_top", "lights_table", "levels_tab", "levels00top", "levels8database", " levels_database", " levels_file", "levels00point"], "run_table": [" run64source", "runalllist", "rungtable", "returnetstorage", "ru_source", "ruingsource", " run64table", " run64list", "returnettable", "return_list", " run_to", "runalfile", "run_file", "runingtable", "run64source", "rungcase", "return_table", "runingtype", "runalcase", "ru_table", " run_source", "run_type", "run_case", "ru_type", "runalltable", "runallentry", "ruingtype", "runallstorage", "run64to", "run_list", "run_source", "run64list", "run_entry", "runettable", "run_to", " run_case", "return_storage", " run64to", "runetlist", "runaltable", "returnetentry", " run_file", "returnetlist", "return_entry", "runallist", "runingsource", "ru_list", "rungfile", "ruinglist", "runetstorage", "run64table", "runetentry", " run_list", "runalto", "ruingtable", "runalsource", "run_storage", "runinglist", "runglist"], "level_table": ["int__cache", "role_table", "int_container", "levellytable", "leveltsystem", "role64index", "level_body", "role64internal", "level_cache", "level67container", "int__table", "vel_list", "int_collection", "lvl_system", "leveltinternal", "level_system", "level_container", "level32cache", "lvl_tree", "level67index", "lvl67tree", "level_tree", "lvl67container", "level67tree", "level64list", "int__container", "level32collection", "level67system", "level32container", "levellysystem", "leveltcontainer", "level__cache", "role_index", "level64index", "lvl67system", "level67body", "role_internal", "lvl_container", "role64body", "levellytree", "role_body", "level_internal", "vel_able", "level64able", "level64table", "level__table", "level64body", "level64internal", "lvl67table", "leveltindex", "level32table", "levelttree", "role64table", "int__collection", "leveltbody", "vel_table", "level_collection", "int_cache", "lvl_table", "level_list", "level_able", "level67internal", "levelttable", "level__container", "levellycontainer", "level64stable", "vel_stable", "level_stable", "level_index", "level__collection", "level67table"], "int_table": ["intitylist", "intablescope", "int_container", "intitydict", "int2table", "intacinternal", "int10internal", "intableable", "run_module", "int_list", "rint_tree", "int_internal", "ints_window", "intxtable", "intiletable", "intsvaltable", "intitymodule", "int_able", "string10able", "int2module", "int_window", "intsvalable", "intacable", "intvalwindow", "intablewindow", "ints_able", "int_scope", "intAtable", "intactable", "int_module", "string10internal", "run_list", "run_dict", "int_sequence", "intAable", "intxscope", "intvalable", "int2list", "intvaltable", "rint_list", "int10table", "ints_table", "int2dict", "intAsequence", "intptcontainer", "intacsequence", "string10table", "ints_scope", "intptlist", "string_sequence", "string10sequence", "intsvalscope", "int_tree", "intilecontainer", "intxwindow", "intpttree", "intvalscope", "int10able", "rint_table", "int_dict", "intxable", "intitytable", "rint_container", "intsvalwindow", "intiletree", "string_internal", "intabletable", "string_table", "intAinternal", "int10sequence", "intpttable", "intilelist", "string_able"], "flevel_table": ["flevellytable", "flevel_index", "frun2tab", "flevelaltable", "frun_collection", "flevel67buffer", "fleveledinternal", "frun32TABLE", "flevellycollection", "fall_list", "fprint_tab", "flevellyTABLE", "flevelertable", "flevel32TABLE", "flevel_tab", "fprint_entry", "frun_public", "flevel_list", "flevel_TABLE", "flvl_buffer", "frun_table", "frun32collection", "flevel_collection", "frun_TABLE", "flevel32collection", "flevelaltotal", "frun2master", "flevelermaster", "flevel67index", "flevel1table", "flevel2tab", "flevel_total", "flevel_master", "flevelertab", "fleveledtab", "flvl_total", "flevel1entry", "flevel1tab", "fprint_internal", "frun_list", "flevellypublic", "flevelalbuffer", "frun32table", "flvl_table", "flevel1internal", "flevel_internal", "fleveledentry", "flevel67table", "flevelerlist", "flevel67total", "flevel_buffer", "fall_tab", "flevel_array", "flevel2master", "fprint_table", "fall_array", "frun2table", "flevel2list", "frun2list", "flevel_entry", "flevel32public", "frun_tab", "flvl_index", "frun_master", "flevel_public", "flevel32table", "flevel2table", "fleveledtable", "frun32public", "flevelalindex", "fall_table"], "i": ["key", "ei", "li", "p", "ki", "bi", "f", "is", "ii", "v", "ini", "r", "mi", "ix", "it", "ic", "hi", "si", "depth", "di", "o", "h", "ri", "in", "ie", "ip", "b", "index", "info", "g", "ui", "iu", "ij", "y", "xi", "zi", "ir", "e", "ci", "ti", "m", "ik", "ai", "pi", "im", "x", "I", "phi", "qi", "n", "u", " ii"], "l": ["la", "li", "p", "lu", "lit", "el", "lp", "ll", "ln", "le", "v", "lr", "lc", "ul", "q", "ml", "sl", "cl", "ell", "fl", "kl", "lin", "il", "len", "ly", "lo", "pl", "L", "ls", "nl", "n", "hl", "z", "tl"], "j": ["py", "bo", "json", "ng", "fr", "dj", "ph", "key", "p", "bj", "f", "jj", "v", "r", "jl", "it", "q", "jc", "obj", "other", "aj", "jo", "br", "o", "pt", "js", "ji", "jump", "b", "g", "ij", "y", "kj", "row", "jp", "e", "uj", "m", "jas", "try", "job", "ja", "je", "x", "J", "n", "z"], "k": ["ka", "key", "sc", "t", "kh", "ke", "p", "ki", "K", "sk", "mk", "kk", "v", "id", "kr", "r", "it", "ark", "ic", "kid", "q", "ask", "ks", "wk", "ku", "km", "kind", "o", "kl", "index", "g", "ijk", "kj", "y", "ck", "m", "ko", "ik", "ek", "ak", "tk", "kw", "n", "z"], "level": ["key", "fail", "co", "p", "cost", "fi", "f", "full", "id", "v", "le", "Level", "volume", "length", "col", "mi", "label", "list", "error", "z", "node", "val", "depth", "fl", "kl", "where", "levels", "lvl", "vel", "state", "index", "info", "role", "g", "point", "roll", "type", "len", "status", "print", "wl", "m", "loop", "lo", "test", "pl", "L", "count", "pe", "local"]}}
{"project": "FFmpeg", "commit_id": "d7b2bb5391bf55e8f9421bff7feb4c1fddfac4bf", "target": 0, "func": "static inline int parse_nal_units(AVCodecParserContext *s,\n\n                                  AVCodecContext *avctx,\n\n                                  const uint8_t *buf, int buf_size)\n\n{\n\n    H264ParseContext *p = s->priv_data;\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n    H2645NAL nal = { NULL };\n\n\n\n    unsigned int pps_id;\n\n    unsigned int slice_type;\n\n    int state = -1, got_reset = 0;\n\n    int field_poc[2];\n\n    int ret;\n\n\n\n    /* set some sane default values */\n\n    s->pict_type         = AV_PICTURE_TYPE_I;\n\n    s->key_frame         = 0;\n\n    s->picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN;\n\n\n\n    ff_h264_sei_uninit(&p->sei);\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    for (;;) {\n\n        const SPS *sps;\n\n        int src_length, consumed;\n\n        buf = avpriv_find_start_code(buf, buf_end, &state);\n\n        if (buf >= buf_end)\n\n            break;\n\n        --buf;\n\n        src_length = buf_end - buf;\n\n        switch (state & 0x1f) {\n\n        case H264_NAL_SLICE:\n\n        case H264_NAL_IDR_SLICE:\n\n            // Do not walk the whole buffer just to decode slice header\n\n            if ((state & 0x1f) == H264_NAL_IDR_SLICE || ((state >> 5) & 0x3) == 0) {\n\n                /* IDR or disposable slice\n\n                 * No need to decode many bytes because MMCOs shall not be present. */\n\n                if (src_length > 60)\n\n                    src_length = 60;\n\n            } else {\n\n                /* To decode up to MMCOs */\n\n                if (src_length > 1000)\n\n                    src_length = 1000;\n\n            }\n\n            break;\n\n        }\n\n\n\n        consumed = ff_h2645_extract_rbsp(buf, src_length, &nal);\n\n        if (consumed < 0)\n\n            break;\n\n\n\n        ret = init_get_bits(&nal.gb, nal.data, nal.size * 8);\n\n        if (ret < 0)\n\n            goto fail;\n\n        get_bits1(&nal.gb);\n\n        nal.ref_idc = get_bits(&nal.gb, 2);\n\n        nal.type    = get_bits(&nal.gb, 5);\n\n\n\n        switch (nal.type) {\n\n        case H264_NAL_SPS:\n\n            ff_h264_decode_seq_parameter_set(&nal.gb, avctx, &p->ps);\n\n            break;\n\n        case H264_NAL_PPS:\n\n            ff_h264_decode_picture_parameter_set(&nal.gb, avctx, &p->ps,\n\n                                                 nal.size_bits);\n\n            break;\n\n        case H264_NAL_SEI:\n\n            ff_h264_sei_decode(&p->sei, &nal.gb, &p->ps, avctx);\n\n            break;\n\n        case H264_NAL_IDR_SLICE:\n\n            s->key_frame = 1;\n\n\n\n            p->poc.prev_frame_num        = 0;\n\n            p->poc.prev_frame_num_offset = 0;\n\n            p->poc.prev_poc_msb          =\n\n            p->poc.prev_poc_lsb          = 0;\n\n        /* fall through */\n\n        case H264_NAL_SLICE:\n\n            get_ue_golomb(&nal.gb);  // skip first_mb_in_slice\n\n            slice_type   = get_ue_golomb_31(&nal.gb);\n\n            s->pict_type = ff_h264_golomb_to_pict_type[slice_type % 5];\n\n            if (p->sei.recovery_point.recovery_frame_cnt >= 0) {\n\n                /* key frame, since recovery_frame_cnt is set */\n\n                s->key_frame = 1;\n\n            }\n\n            pps_id = get_ue_golomb(&nal.gb);\n\n            if (pps_id >= MAX_PPS_COUNT) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"pps_id %u out of range\\n\", pps_id);\n\n                goto fail;\n\n            }\n\n            if (!p->ps.pps_list[pps_id]) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"non-existing PPS %u referenced\\n\", pps_id);\n\n                goto fail;\n\n            }\n\n            p->ps.pps = (const PPS*)p->ps.pps_list[pps_id]->data;\n\n            if (!p->ps.sps_list[p->ps.pps->sps_id]) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"non-existing SPS %u referenced\\n\", p->ps.pps->sps_id);\n\n                goto fail;\n\n            }\n\n            p->ps.sps = (SPS*)p->ps.sps_list[p->ps.pps->sps_id]->data;\n\n\n\n            sps = p->ps.sps;\n\n\n\n            p->poc.frame_num = get_bits(&nal.gb, sps->log2_max_frame_num);\n\n\n\n            s->coded_width  = 16 * sps->mb_width;\n\n            s->coded_height = 16 * sps->mb_height;\n\n            s->width        = s->coded_width  - (sps->crop_right + sps->crop_left);\n\n            s->height       = s->coded_height - (sps->crop_top   + sps->crop_bottom);\n\n            if (s->width <= 0 || s->height <= 0) {\n\n                s->width  = s->coded_width;\n\n                s->height = s->coded_height;\n\n            }\n\n\n\n            switch (sps->bit_depth_luma) {\n\n            case 9:\n\n                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P9;\n\n                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P9;\n\n                else                                  s->format = AV_PIX_FMT_YUV420P9;\n\n                break;\n\n            case 10:\n\n                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P10;\n\n                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P10;\n\n                else                                  s->format = AV_PIX_FMT_YUV420P10;\n\n                break;\n\n            case 8:\n\n                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P;\n\n                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P;\n\n                else                                  s->format = AV_PIX_FMT_YUV420P;\n\n                break;\n\n            default:\n\n                s->format = AV_PIX_FMT_NONE;\n\n            }\n\n\n\n            avctx->profile = ff_h264_get_profile(sps);\n\n            avctx->level   = sps->level_idc;\n\n\n\n            if (sps->frame_mbs_only_flag) {\n\n                p->picture_structure = PICT_FRAME;\n\n            } else {\n\n                if (get_bits1(&nal.gb)) { // field_pic_flag\n\n                    p->picture_structure = PICT_TOP_FIELD + get_bits1(&nal.gb); // bottom_field_flag\n\n                } else {\n\n                    p->picture_structure = PICT_FRAME;\n\n                }\n\n            }\n\n\n\n            if (nal.type == H264_NAL_IDR_SLICE)\n\n                get_ue_golomb(&nal.gb); /* idr_pic_id */\n\n            if (sps->poc_type == 0) {\n\n                p->poc.poc_lsb = get_bits(&nal.gb, sps->log2_max_poc_lsb);\n\n\n\n                if (p->ps.pps->pic_order_present == 1 &&\n\n                    p->picture_structure == PICT_FRAME)\n\n                    p->poc.delta_poc_bottom = get_se_golomb(&nal.gb);\n\n            }\n\n\n\n            if (sps->poc_type == 1 &&\n\n                !sps->delta_pic_order_always_zero_flag) {\n\n                p->poc.delta_poc[0] = get_se_golomb(&nal.gb);\n\n\n\n                if (p->ps.pps->pic_order_present == 1 &&\n\n                    p->picture_structure == PICT_FRAME)\n\n                    p->poc.delta_poc[1] = get_se_golomb(&nal.gb);\n\n            }\n\n\n\n            /* Decode POC of this picture.\n\n             * The prev_ values needed for decoding POC of the next picture are not set here. */\n\n            field_poc[0] = field_poc[1] = INT_MAX;\n\n            ff_h264_init_poc(field_poc, &s->output_picture_number, sps,\n\n                             &p->poc, p->picture_structure, nal.ref_idc);\n\n\n\n            /* Continue parsing to check if MMCO_RESET is present.\n\n             * FIXME: MMCO_RESET could appear in non-first slice.\n\n             *        Maybe, we should parse all undisposable non-IDR slice of this\n\n             *        picture until encountering MMCO_RESET in a slice of it. */\n\n            if (nal.ref_idc && nal.type != H264_NAL_IDR_SLICE) {\n\n                got_reset = scan_mmco_reset(s, &nal.gb, avctx);\n\n                if (got_reset < 0)\n\n                    goto fail;\n\n            }\n\n\n\n            /* Set up the prev_ values for decoding POC of the next picture. */\n\n            p->poc.prev_frame_num        = got_reset ? 0 : p->poc.frame_num;\n\n            p->poc.prev_frame_num_offset = got_reset ? 0 : p->poc.frame_num_offset;\n\n            if (nal.ref_idc != 0) {\n\n                if (!got_reset) {\n\n                    p->poc.prev_poc_msb = p->poc.poc_msb;\n\n                    p->poc.prev_poc_lsb = p->poc.poc_lsb;\n\n                } else {\n\n                    p->poc.prev_poc_msb = 0;\n\n                    p->poc.prev_poc_lsb =\n\n                        p->picture_structure == PICT_BOTTOM_FIELD ? 0 : field_poc[0];\n\n                }\n\n            }\n\n\n\n            if (sps->pic_struct_present_flag) {\n\n                switch (p->sei.picture_timing.pic_struct) {\n\n                case SEI_PIC_STRUCT_TOP_FIELD:\n\n                case SEI_PIC_STRUCT_BOTTOM_FIELD:\n\n                    s->repeat_pict = 0;\n\n                    break;\n\n                case SEI_PIC_STRUCT_FRAME:\n\n                case SEI_PIC_STRUCT_TOP_BOTTOM:\n\n                case SEI_PIC_STRUCT_BOTTOM_TOP:\n\n                    s->repeat_pict = 1;\n\n                    break;\n\n                case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n\n                case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n\n                    s->repeat_pict = 2;\n\n                    break;\n\n                case SEI_PIC_STRUCT_FRAME_DOUBLING:\n\n                    s->repeat_pict = 3;\n\n                    break;\n\n                case SEI_PIC_STRUCT_FRAME_TRIPLING:\n\n                    s->repeat_pict = 5;\n\n                    break;\n\n                default:\n\n                    s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0;\n\n                    break;\n\n                }\n\n            } else {\n\n                s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0;\n\n            }\n\n\n\n            if (p->picture_structure == PICT_FRAME) {\n\n                s->picture_structure = AV_PICTURE_STRUCTURE_FRAME;\n\n                if (sps->pic_struct_present_flag) {\n\n                    switch (p->sei.picture_timing.pic_struct) {\n\n                    case SEI_PIC_STRUCT_TOP_BOTTOM:\n\n                    case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n\n                        s->field_order = AV_FIELD_TT;\n\n                        break;\n\n                    case SEI_PIC_STRUCT_BOTTOM_TOP:\n\n                    case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n\n                        s->field_order = AV_FIELD_BB;\n\n                        break;\n\n                    default:\n\n                        s->field_order = AV_FIELD_PROGRESSIVE;\n\n                        break;\n\n                    }\n\n                } else {\n\n                    if (field_poc[0] < field_poc[1])\n\n                        s->field_order = AV_FIELD_TT;\n\n                    else if (field_poc[0] > field_poc[1])\n\n                        s->field_order = AV_FIELD_BB;\n\n                    else\n\n                        s->field_order = AV_FIELD_PROGRESSIVE;\n\n                }\n\n            } else {\n\n                if (p->picture_structure == PICT_TOP_FIELD)\n\n                    s->picture_structure = AV_PICTURE_STRUCTURE_TOP_FIELD;\n\n                else\n\n                    s->picture_structure = AV_PICTURE_STRUCTURE_BOTTOM_FIELD;\n\n                s->field_order = AV_FIELD_UNKNOWN;\n\n            }\n\n\n\n            av_freep(&nal.rbsp_buffer);\n\n            return 0; /* no need to evaluate the rest */\n\n        }\n\n        buf += consumed;\n\n    }\n\n    /* didn't find a picture! */\n\n    av_log(avctx, AV_LOG_ERROR, \"missing picture in access unit\\n\");\n\nfail:\n\n    av_freep(&nal.rbsp_buffer);\n\n    return -1;\n\n}\n", "idx": 7609, "substitutes": {"s": ["t", "os", "S", "sports", "ans", "ds", "is", "a", "ms", "v", "sp", "ps", "vs", "ins", "spec", "ies", "sets", "ss", "ports", "h", "aws", "uploads", "changes", "i", "ns", "js", "hs", "b", "styles", "sq", "ses", "sts", "pers", "rs", "gs", "ts", "es", "stats", "its", "fs", "sv", "cs", "sb", "c", "src", "as", "ls", "parts", "settings", "ats", "n", "qs"], "avctx": [" avcontext", "avcontext", "avcv", " avcv", "camctx", "camcv", "Avcontext", " avpkg", "Avctx", "Avcv", "Avpkg", "campkg", "camcontext", "avpkg"], "buf": ["ptr", "doc", "bound", "pack", "lit", "max", "pkg", "cv", "tmp", "limit", "checked", "data", "length", "ctx", "wait", "done", "xff", "fb", "msg", "bar", "cb", "Buffer", "aka", "str", "port", "br", "pad", "read", "buff", "Buff", "bs", "sofar", "off", "bytes", "b", "np", "err", "result", "orig", "mem", "pb", "mb", "ref", "buffer", "len", "iter", "end", "db", "cam", "raw", "vec", "bp", "window", "uf", "count", "bc", "seq", "src", "queue", "ob", "block", "box", "pos", "n", "rb", "img", "cmd", "wb", "batch"], "buf_size": ["buf5ize", "buf2loc", "buf_sent", "buf2ize", "buf2end", " buf_sent", "buf2start", "buf5size", "buf2size", "buf_start", "bufishsent", "buf5end", "buf_length", "bufishize", "buf_ize", " buf_ize", "bufishloc", "buf2sent", "buf2length", " buf_length", " buf_loc", " buf_start", "bufishsize", "buf_loc"], "p": ["vp", "pp", "t", "cp", "pkg", "lp", "f", "d", "v", "sp", "ps", "ctx", "pc", "ping", "wp", "pa", "pro", "h", "j", "pt", "i", "ap", "proc", "b", "np", "par", "pb", "per", "pers", "tp", "jp", "m", "P", "bp", "c", "pe", "n"], "buf_end": ["buf2end", "db_len", "db_End", "buftend", "uf_ends", "bufxend", "queue_ends", "buf__ended", "uf_start", "uf_end", "buf2send", "buf_End", "buf__start", "buf_END", "buf__ends", "bufxends", "buf_stop", "queue_start", "buf_send", "queue_end", "bufxstart", "db_end", "buf2len", "db_send", "buf_start", " buf_ended", "buf2End", "buftstop", "uf_stop", " buf_start", "buf__end", "buf_len", "buftstart", "buftends", " buf_ends", "bufxstop", "buf_ends", "buf_ended", "queue_END"], "pps_id": ["par_type", "sliceovclass", "sliceuucount", "sliceovcount", "sliceuutype", "sliceovid", "par_class", "sliceuuid", "par_count", "sliceuuclass", "paruutype", "par_id", "slice_count", "paruuclass", "paruuid", "slice_id", "paruucount", "sliceovtype", "slice_class"], "slice_type": [" slice_types", "slice_types", "slice_name", "slice_kind", " slice_name", " slice_kind"], "field_poc": ["field_opOC", "field_pct", "field_opct", "field_hoc", "field_apos", "field_opos", "field_opoc", "field_apct", "field_pos", "field_apOC", "field_hos", "field_apoc", "field_pOC", "field_hOC", "field_hct"], "ret": ["reset", "lit", "gt", "elt", "tmp", "success", "RET", "nt", "re", "cont", "Ret", "it", "orted", "ft", "Return", "rets", "red", "val", "fun", "complete", "rem", "read", "mem", "mt", "result", "def", "err", "usr", "pret", "found", "ber", "ref", "iter", "rect", "res", "conv", "tr", "ter", "flag", "try", " RET", "count", "aux", "back", "alt", "encrypted", "rt", "backed", "out"], "sps": ["ssPS", "ssmp", " smp", "Sfs", " sPS", "sfs", "smp", "ssfs", "Sps", "Smp", " sfs", "ssps", "SPS", "sPS"], "src_length": ["srcxlength", "sort_location", " src_distance", "srcjstream", "sys_time", "srcxlen", "src_distance", "src1count", "srcjmaximum", "src1distance", "srcJlength", " src_ength", " src_count", " src_Length", "src_time", "src6length", "src_stream", "src_maximum", "src_array", "src1length", "src6ength", "srcJtime", "srcxcode", "srcxend", "src6Length", "rc_stream", " src_code", "srcjlength", "src_location", "src1len", "sys_length", "src_ength", "src_end", "src6len", "src_len", "sort_time", "src_Length", "rc_length", "sort_length", "src_code", "src_number", " src_end", "sys_array", "src_count", "rc_maximum", " src_len", " src_number", "srcJarray"], "consumed": ["Consume", "consumption", "reserved", " unconsumed", "Consumed", "coserved", "resumed", "conserved", " unconsalted", " consume", "resumption", "Conserved", " unconsumption", " consumers", " consalted", "cosumed", "cosume", " unconsume", "consume", "Consalted", " consumption", "resume", "Consumers", "consalted", "cosumption", "consumers", "Consumption", "cosumers"]}}
{"project": "FFmpeg", "commit_id": "c94326c1fc2fb5719c6f28fe1b95c0c74417998b", "target": 1, "func": "static av_always_inline void FUNC(intra_pred)(HEVCContext *s, int x0, int y0,\n\n                                              int log2_size, int c_idx)\n\n{\n\n#define PU(x) \\\n\n    ((x) >> s->ps.sps->log2_min_pu_size)\n\n#define MVF(x, y) \\\n\n    (s->ref->tab_mvf[(x) + (y) * min_pu_width])\n\n#define MVF_PU(x, y) \\\n\n    MVF(PU(x0 + ((x) << hshift)), PU(y0 + ((y) << vshift)))\n\n#define IS_INTRA(x, y) \\\n\n    (MVF_PU(x, y).pred_flag == PF_INTRA)\n\n#define MIN_TB_ADDR_ZS(x, y) \\\n\n    s->ps.pps->min_tb_addr_zs[(y) * (s->ps.sps->tb_mask+2) + (x)]\n\n#define EXTEND(ptr, val, len)         \\\n\ndo {                                  \\\n\n    pixel4 pix = PIXEL_SPLAT_X4(val); \\\n\n    for (i = 0; i < (len); i += 4)    \\\n\n        AV_WN4P(ptr + i, pix);        \\\n\n} while (0)\n\n\n\n#define EXTEND_RIGHT_CIP(ptr, start, length)                                   \\\n\n        for (i = start; i < (start) + (length); i += 4)                        \\\n\n            if (!IS_INTRA(i, -1))                                              \\\n\n                AV_WN4P(&ptr[i], a);                                           \\\n\n            else                                                               \\\n\n                a = PIXEL_SPLAT_X4(ptr[i+3])\n\n#define EXTEND_LEFT_CIP(ptr, start, length) \\\n\n        for (i = start; i > (start) - (length); i--) \\\n\n            if (!IS_INTRA(i - 1, -1)) \\\n\n                ptr[i - 1] = ptr[i]\n\n#define EXTEND_UP_CIP(ptr, start, length)                                      \\\n\n        for (i = (start); i > (start) - (length); i -= 4)                      \\\n\n            if (!IS_INTRA(-1, i - 3))                                          \\\n\n                AV_WN4P(&ptr[i - 3], a);                                       \\\n\n            else                                                               \\\n\n                a = PIXEL_SPLAT_X4(ptr[i - 3])\n\n#define EXTEND_DOWN_CIP(ptr, start, length)                                    \\\n\n        for (i = start; i < (start) + (length); i += 4)                        \\\n\n            if (!IS_INTRA(-1, i))                                              \\\n\n                AV_WN4P(&ptr[i], a);                                           \\\n\n            else                                                               \\\n\n                a = PIXEL_SPLAT_X4(ptr[i + 3])\n\n\n\n    HEVCLocalContext *lc = s->HEVClc;\n\n    int i;\n\n    int hshift = s->ps.sps->hshift[c_idx];\n\n    int vshift = s->ps.sps->vshift[c_idx];\n\n    int size = (1 << log2_size);\n\n    int size_in_luma_h = size << hshift;\n\n    int size_in_tbs_h  = size_in_luma_h >> s->ps.sps->log2_min_tb_size;\n\n    int size_in_luma_v = size << vshift;\n\n    int size_in_tbs_v  = size_in_luma_v >> s->ps.sps->log2_min_tb_size;\n\n    int x = x0 >> hshift;\n\n    int y = y0 >> vshift;\n\n    int x_tb = (x0 >> s->ps.sps->log2_min_tb_size) & s->ps.sps->tb_mask;\n\n    int y_tb = (y0 >> s->ps.sps->log2_min_tb_size) & s->ps.sps->tb_mask;\n\n\n\n    int cur_tb_addr = MIN_TB_ADDR_ZS(x_tb, y_tb);\n\n\n\n    ptrdiff_t stride = s->frame->linesize[c_idx] / sizeof(pixel);\n\n    pixel *src = (pixel*)s->frame->data[c_idx] + x + y * stride;\n\n\n\n    int min_pu_width = s->ps.sps->min_pu_width;\n\n\n\n    enum IntraPredMode mode = c_idx ? lc->tu.intra_pred_mode_c :\n\n                              lc->tu.intra_pred_mode;\n\n    pixel4 a;\n\n    pixel  left_array[2 * MAX_TB_SIZE + 1];\n\n    pixel  filtered_left_array[2 * MAX_TB_SIZE + 1];\n\n    pixel  top_array[2 * MAX_TB_SIZE + 1];\n\n    pixel  filtered_top_array[2 * MAX_TB_SIZE + 1];\n\n\n\n    pixel  *left          = left_array + 1;\n\n    pixel  *top           = top_array  + 1;\n\n    pixel  *filtered_left = filtered_left_array + 1;\n\n    pixel  *filtered_top  = filtered_top_array  + 1;\n\n    int cand_bottom_left = lc->na.cand_bottom_left && cur_tb_addr > MIN_TB_ADDR_ZS( x_tb - 1, (y_tb + size_in_tbs_v) & s->ps.sps->tb_mask);\n\n    int cand_left        = lc->na.cand_left;\n\n    int cand_up_left     = lc->na.cand_up_left;\n\n    int cand_up          = lc->na.cand_up;\n\n    int cand_up_right    = lc->na.cand_up_right    && cur_tb_addr > MIN_TB_ADDR_ZS((x_tb + size_in_tbs_h) & s->ps.sps->tb_mask, y_tb - 1);\n\n\n\n    int bottom_left_size = (FFMIN(y0 + 2 * size_in_luma_v, s->ps.sps->height) -\n\n                           (y0 + size_in_luma_v)) >> vshift;\n\n    int top_right_size   = (FFMIN(x0 + 2 * size_in_luma_h, s->ps.sps->width) -\n\n                           (x0 + size_in_luma_h)) >> hshift;\n\n\n\n    if (s->ps.pps->constrained_intra_pred_flag == 1) {\n\n        int size_in_luma_pu_v = PU(size_in_luma_v);\n\n        int size_in_luma_pu_h = PU(size_in_luma_h);\n\n        int on_pu_edge_x    = !av_mod_uintp2(x0, s->ps.sps->log2_min_pu_size);\n\n        int on_pu_edge_y    = !av_mod_uintp2(y0, s->ps.sps->log2_min_pu_size);\n\n        if (!size_in_luma_pu_h)\n\n            size_in_luma_pu_h++;\n\n        if (cand_bottom_left == 1 && on_pu_edge_x) {\n\n            int x_left_pu   = PU(x0 - 1);\n\n            int y_bottom_pu = PU(y0 + size_in_luma_v);\n\n            int max = FFMIN(size_in_luma_pu_v, s->ps.sps->min_pu_height - y_bottom_pu);\n\n            cand_bottom_left = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_bottom_left |= (MVF(x_left_pu, y_bottom_pu + i).pred_flag == PF_INTRA);\n\n        }\n\n        if (cand_left == 1 && on_pu_edge_x) {\n\n            int x_left_pu   = PU(x0 - 1);\n\n            int y_left_pu   = PU(y0);\n\n            int max = FFMIN(size_in_luma_pu_v, s->ps.sps->min_pu_height - y_left_pu);\n\n            cand_left = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_left |= (MVF(x_left_pu, y_left_pu + i).pred_flag == PF_INTRA);\n\n        }\n\n        if (cand_up_left == 1) {\n\n            int x_left_pu   = PU(x0 - 1);\n\n            int y_top_pu    = PU(y0 - 1);\n\n            cand_up_left = MVF(x_left_pu, y_top_pu).pred_flag == PF_INTRA;\n\n        }\n\n        if (cand_up == 1 && on_pu_edge_y) {\n\n            int x_top_pu    = PU(x0);\n\n            int y_top_pu    = PU(y0 - 1);\n\n            int max = FFMIN(size_in_luma_pu_h, s->ps.sps->min_pu_width - x_top_pu);\n\n            cand_up = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_up |= (MVF(x_top_pu + i, y_top_pu).pred_flag == PF_INTRA);\n\n        }\n\n        if (cand_up_right == 1 && on_pu_edge_y) {\n\n            int y_top_pu    = PU(y0 - 1);\n\n            int x_right_pu  = PU(x0 + size_in_luma_h);\n\n            int max = FFMIN(size_in_luma_pu_h, s->ps.sps->min_pu_width - x_right_pu);\n\n            cand_up_right = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_up_right |= (MVF(x_right_pu + i, y_top_pu).pred_flag == PF_INTRA);\n\n        }\n\n        memset(left, 128, 2 * MAX_TB_SIZE*sizeof(pixel));\n\n        memset(top , 128, 2 * MAX_TB_SIZE*sizeof(pixel));\n\n        top[-1] = 128;\n\n    }\n\n    if (cand_up_left) {\n\n        left[-1] = POS(-1, -1);\n\n        top[-1]  = left[-1];\n\n    }\n\n    if (cand_up)\n\n        memcpy(top, src - stride, size * sizeof(pixel));\n\n    if (cand_up_right) {\n\n        memcpy(top + size, src - stride + size, size * sizeof(pixel));\n\n        EXTEND(top + size + top_right_size, POS(size + top_right_size - 1, -1),\n\n               size - top_right_size);\n\n    }\n\n    if (cand_left)\n\n        for (i = 0; i < size; i++)\n\n            left[i] = POS(-1, i);\n\n    if (cand_bottom_left) {\n\n        for (i = size; i < size + bottom_left_size; i++)\n\n            left[i] = POS(-1, i);\n\n        EXTEND(left + size + bottom_left_size, POS(-1, size + bottom_left_size - 1),\n\n               size - bottom_left_size);\n\n    }\n\n\n\n    if (s->ps.pps->constrained_intra_pred_flag == 1) {\n\n        if (cand_bottom_left || cand_left || cand_up_left || cand_up || cand_up_right) {\n\n            int size_max_x = x0 + ((2 * size) << hshift) < s->ps.sps->width ?\n\n                                    2 * size : (s->ps.sps->width - x0) >> hshift;\n\n            int size_max_y = y0 + ((2 * size) << vshift) < s->ps.sps->height ?\n\n                                    2 * size : (s->ps.sps->height - y0) >> vshift;\n\n            int j = size + (cand_bottom_left? bottom_left_size: 0) -1;\n\n            if (!cand_up_right) {\n\n                size_max_x = x0 + ((size) << hshift) < s->ps.sps->width ?\n\n                                                    size : (s->ps.sps->width - x0) >> hshift;\n\n            }\n\n            if (!cand_bottom_left) {\n\n                size_max_y = y0 + (( size) << vshift) < s->ps.sps->height ?\n\n                                                     size : (s->ps.sps->height - y0) >> vshift;\n\n            }\n\n            if (cand_bottom_left || cand_left || cand_up_left) {\n\n                while (j > -1 && !IS_INTRA(-1, j))\n\n                    j--;\n\n                if (!IS_INTRA(-1, j)) {\n\n                    j = 0;\n\n                    while (j < size_max_x && !IS_INTRA(j, -1))\n\n                        j++;\n\n                    EXTEND_LEFT_CIP(top, j, j + 1);\n\n                    left[-1] = top[-1];\n\n                }\n\n            } else {\n\n                j = 0;\n\n                while (j < size_max_x && !IS_INTRA(j, -1))\n\n                    j++;\n\n                if (j > 0)\n\n                    if (x0 > 0) {\n\n                        EXTEND_LEFT_CIP(top, j, j + 1);\n\n                    } else {\n\n                        EXTEND_LEFT_CIP(top, j, j);\n\n                        top[-1] = top[0];\n\n                    }\n\n                left[-1] = top[-1];\n\n            }\n\n            left[-1] = top[-1];\n\n            if (cand_bottom_left || cand_left) {\n\n                a = PIXEL_SPLAT_X4(left[-1]);\n\n                EXTEND_DOWN_CIP(left, 0, size_max_y);\n\n            }\n\n            if (!cand_left)\n\n                EXTEND(left, left[-1], size);\n\n            if (!cand_bottom_left)\n\n                EXTEND(left + size, left[size - 1], size);\n\n            if (x0 != 0 && y0 != 0) {\n\n                a = PIXEL_SPLAT_X4(left[size_max_y - 1]);\n\n                EXTEND_UP_CIP(left, size_max_y - 1, size_max_y);\n\n                if (!IS_INTRA(-1, - 1))\n\n                    left[-1] = left[0];\n\n            } else if (x0 == 0) {\n\n                EXTEND(left, 0, size_max_y);\n\n            } else {\n\n                a = PIXEL_SPLAT_X4(left[size_max_y - 1]);\n\n                EXTEND_UP_CIP(left, size_max_y - 1, size_max_y);\n\n            }\n\n            top[-1] = left[-1];\n\n            if (y0 != 0) {\n\n                a = PIXEL_SPLAT_X4(left[-1]);\n\n                EXTEND_RIGHT_CIP(top, 0, size_max_x);\n\n            }\n\n        }\n\n    }\n\n    // Infer the unavailable samples\n\n    if (!cand_bottom_left) {\n\n        if (cand_left) {\n\n            EXTEND(left + size, left[size - 1], size);\n\n        } else if (cand_up_left) {\n\n            EXTEND(left, left[-1], 2 * size);\n\n            cand_left = 1;\n\n        } else if (cand_up) {\n\n            left[-1] = top[0];\n\n            EXTEND(left, left[-1], 2 * size);\n\n            cand_up_left = 1;\n\n            cand_left    = 1;\n\n        } else if (cand_up_right) {\n\n            EXTEND(top, top[size], size);\n\n            left[-1] = top[size];\n\n            EXTEND(left, left[-1], 2 * size);\n\n            cand_up      = 1;\n\n            cand_up_left = 1;\n\n            cand_left    = 1;\n\n        } else { // No samples available\n\n            left[-1] = (1 << (BIT_DEPTH - 1));\n\n            EXTEND(top,  left[-1], 2 * size);\n\n            EXTEND(left, left[-1], 2 * size);\n\n        }\n\n    }\n\n\n\n    if (!cand_left)\n\n        EXTEND(left, left[size], size);\n\n    if (!cand_up_left) {\n\n        left[-1] = left[0];\n\n    }\n\n    if (!cand_up)\n\n        EXTEND(top, left[-1], size);\n\n    if (!cand_up_right)\n\n        EXTEND(top + size, top[size - 1], size);\n\n\n\n    top[-1] = left[-1];\n\n\n\n    // Filtering process\n\n    if (!s->ps.sps->intra_smoothing_disabled_flag && (c_idx == 0  || s->ps.sps->chroma_format_idc == 3)) {\n\n        if (mode != INTRA_DC && size != 4){\n\n            int intra_hor_ver_dist_thresh[] = { 7, 1, 0 };\n\n            int min_dist_vert_hor = FFMIN(FFABS((int)(mode - 26U)),\n\n                                          FFABS((int)(mode - 10U)));\n\n            if (min_dist_vert_hor > intra_hor_ver_dist_thresh[log2_size - 3]) {\n\n                int threshold = 1 << (BIT_DEPTH - 5);\n\n                if (s->ps.sps->sps_strong_intra_smoothing_enable_flag && c_idx == 0 &&\n\n                    log2_size == 5 &&\n\n                    FFABS(top[-1]  + top[63]  - 2 * top[31])  < threshold &&\n\n                    FFABS(left[-1] + left[63] - 2 * left[31]) < threshold) {\n\n                    // We can't just overwrite values in top because it could be\n\n                    // a pointer into src\n\n                    filtered_top[-1] = top[-1];\n\n                    filtered_top[63] = top[63];\n\n                    for (i = 0; i < 63; i++)\n\n                        filtered_top[i] = ((64 - (i + 1)) * top[-1] +\n\n                                           (i + 1)  * top[63] + 32) >> 6;\n\n                    for (i = 0; i < 63; i++)\n\n                        left[i] = ((64 - (i + 1)) * left[-1] +\n\n                                   (i + 1)  * left[63] + 32) >> 6;\n\n                    top = filtered_top;\n\n                } else {\n\n                    filtered_left[2 * size - 1] = left[2 * size - 1];\n\n                    filtered_top[2 * size - 1]  = top[2 * size - 1];\n\n                    for (i = 2 * size - 2; i >= 0; i--)\n\n                        filtered_left[i] = (left[i + 1] + 2 * left[i] +\n\n                                            left[i - 1] + 2) >> 2;\n\n                    filtered_top[-1]  =\n\n                    filtered_left[-1] = (left[0] + 2 * left[-1] + top[0] + 2) >> 2;\n\n                    for (i = 2 * size - 2; i >= 0; i--)\n\n                        filtered_top[i] = (top[i + 1] + 2 * top[i] +\n\n                                           top[i - 1] + 2) >> 2;\n\n                    left = filtered_left;\n\n                    top  = filtered_top;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    switch (mode) {\n\n    case INTRA_PLANAR:\n\n        s->hpc.pred_planar[log2_size - 2]((uint8_t *)src, (uint8_t *)top,\n\n                                          (uint8_t *)left, stride);\n\n        break;\n\n    case INTRA_DC:\n\n        s->hpc.pred_dc((uint8_t *)src, (uint8_t *)top,\n\n                       (uint8_t *)left, stride, log2_size, c_idx);\n\n        break;\n\n    default:\n\n        s->hpc.pred_angular[log2_size - 2]((uint8_t *)src, (uint8_t *)top,\n\n                                           (uint8_t *)left, stride, c_idx,\n\n                                           mode);\n\n        break;\n\n    }\n\n}\n", "idx": 7622, "substitutes": {"s": ["t", "os", "S", "p", "ds", "is", "ms", "v", "ps", "ctx", "ins", "w", "ss", "h", "ns", "js", "b", "g", "rs", "gs", "ts", "e", "fs", "cs", "c", "n"], "x0": ["rx0", "x2", "rx2", "x1", "rx1", "ex1", "ex0", " x1", " x2", "ex2"], "y0": [" y1", "b1", "gyElement", "yElement", "gy1", "b0", " yElement", "y1", "gy0", "bElement"], "log2_size": ["log3_SIZE", "log3_len", "log3_size", "log2_SIZE", "log2_len"], "c_idx": ["c_Idxs", "c_ridxs", "c_ridg", "c_Idx", "c_idg", "c_idy", "c_nx", "c_Idg", "c_Idy", "c_ng", "c_idxs", "c_nxs", "c_ridx", "c_ridy", "c_ny"], "i": ["init", "ei", "li", "t", "p", "ki", "bi", "is", "id", "ind", "ii", "ini", "mi", "ix", "me", "it", "ic", "q", "hi", "si", "oi", "di", "gi", "in", "ji", "ip", "index", "g", "ui", "iu", "multi", "xi", "ij", "zi", "status", "ci", "ti", "m", "ai", "pi", "ni", "ims", "qi", "I", "phi", "cli", "u"], "a": ["la", "ava", "t", "aa", "alpha", "ea", "xa", "alias", "ap", "b", "A", "an", "at", "ba", "ma", "area", "na", "ca", "au", "ac", "ta", "as", "aux", "c", "am", "aaa", "va", "sa"]}}
{"project": "FFmpeg", "commit_id": "6f3d2fb18bb6225c27e22a95846c42f2093dc3b7", "target": 0, "func": "static void end_last_frame(AVFilterContext *ctx)\n\n{\n\n    TileContext *tile    = ctx->priv;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n    AVFilterBufferRef *out_buf = outlink->out_buf;\n\n\n\n    outlink->out_buf = NULL;\n\n    ff_start_frame(outlink, out_buf);\n\n    while (tile->current < tile->nb_frames)\n\n        draw_blank_frame(ctx, out_buf);\n\n    ff_draw_slice(outlink, 0, out_buf->video->h, 1);\n\n    ff_end_frame(outlink);\n\n    tile->current = 0;\n\n}\n", "idx": 7649, "substitutes": {"ctx": ["tc", "gm", "sc", "gru", "cm", "cp", "jac", "fn", "pkg", " cx", "cv", "conn", "ind", "wx", "lc", "tz", "piece", "obj", "cb", "loc", "cc", "setup", "kt", "req", "gc", "kl", "fc", "anc", "js", "resp", "np", "act", "kb", "ij", "cmp", "jp", "ck", "cf", "cfg", "xs", "xc", "hw", "ct", "desc", "tx", "bc", "c", "qt", "cmd", "Context", "kw", "context", "ctl", "nc", "mc", "fx"], "tile": ["tif", "tle", "tc", "tty", "key", " Tile", "util", "ace", "sim", "th", "tf", "sel", "entity", "col", "draw", "thread", "pixel", "Tile", "piece", "node", "TI", "offset", "kt", "chip", "port", "tier", "module", "toggle", "cell", "color", "sil", "ten", "feature", "slice", "tree", "trace", "info", "til", "detail", "il", "store", "tip", "buffer", "term", "ts", "tool", "ti", "te", "coord", "scale", "grid", "table", "unit", "texture", "title", "num", "mask", "window", "count", "tiny", "shot", "feat", "tu", "vt", "frame", "cache", "template"], "outlink": [" outline", "gategroup", "Outline", "outlay", " outgate", "outLink", "outlet", " outLink", "outcheck", "outputcheck", "otlink", " outlay", "outputlet", "outlinked", " outlinked", " outcheck", "connLink", "oloop", "outline", "outerlink", "outloop", "outgate", "connpack", " outgroup", " outln", "connlink", "outergate", "outpack", " outlet", "outerlinked", "otlay", "oucheck", "offlinked", "outerline", "otloop", "offLink", "outln", "otln", "gatelink", "Outpack", "oulink", " outpack", "olay", "offlink", "otgroup", "outputlink", "oulet", "OutLink", "Outgate", "Outlinked", " outloop", "gateln", "outgroup", "Outlink", "olink"], "out_buf": ["out_buff", "in_cb", "out64buf", " out_db", "outMemcomb", "out_uf", "out_buffer", "outbufbuf", "out64uf", "out_msg", "out64msg", " out_comb", "out___uf", "outbufmem", "in_buf", " out_Buff", "out64Buff", "outbufbuffer", "outMemtab", "out_db", "out_mem", "in_buff", "out_tab", "out_Buff", "in_mem", "outbufbuff", "in_buffer", "out_comb", " out_buff", "out2buff", "out__cb", "outMemuf", "out2buf", "outMembuf", "out__buffer", "out___db", "out__buf", " out_msg", "out_cb", "out___buf", "out__buff", "out2uf", " out_tab", " out_uf"]}}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "void av_register_output_format(AVOutputFormat *format)\n\n{\n\n    AVOutputFormat **p = &first_oformat;\n\n\n\n    while (*p != NULL)\n\n        p = &(*p)->next;\n\n\n\n    *p = format;\n\n    format->next = NULL;\n\n}\n", "idx": 7651, "substitutes": {"format": ["get", "function", "init", "vp", "html", "reset", "fn", "form", "config", "f", "join", "v", "cat", "data", "to", "list", "file", "prefix", "transform", "flat", "version", "style", "set", "layout", "MAT", "port", "package", "output", "mat", "fc", "mt", "name", "at", "type", "text", "fp", "new", "print", "op", "Format", "raw", "unit", "missing", "parse", "null", "feat", "ats", "AT", "pre", "template"], "p": ["vp", "pp", "rep", "cp", "t", "pkg", "lp", "f", "a", "d", "l", "sp", "ps", "pc", "it", "post", "ping", "q", "wp", "ep", "pa", "pro", "j", "port", "h", "o", "pad", "k", "i", "ap", "proc", "np", "b", "par", "point", "g", "pb", "per", "pr", "pers", "peer", "y", "fp", "tp", "jp", "op", "pat", "m", "pair", "P", "bp", "parse", "part", "pl", "pid", "c", "pod", "er"]}}
{"project": "qemu", "commit_id": "d5de7839d78b08c7bd14b03dac0413699b90da67", "target": 1, "func": "static void decode_32Bit_opc(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    int op1;\n\n    int32_t r1, r2, r3;\n\n    int32_t address, const16;\n\n    int8_t b, const4;\n\n    int32_t bpos;\n\n    TCGv temp, temp2, temp3;\n\n\n\n    op1 = MASK_OP_MAJOR(ctx->opcode);\n\n\n\n    /* handle JNZ.T opcode only being 7 bit long */\n\n    if (unlikely((op1 & 0x7f) == OPCM_32_BRN_JTT)) {\n\n        op1 = OPCM_32_BRN_JTT;\n\n    }\n\n\n\n    switch (op1) {\n\n/* ABS-format */\n\n    case OPCM_32_ABS_LDW:\n\n        decode_abs_ldw(env, ctx);\n\n\n    case OPCM_32_ABS_LDB:\n\n        decode_abs_ldb(env, ctx);\n\n\n    case OPCM_32_ABS_LDMST_SWAP:\n\n        decode_abs_ldst_swap(env, ctx);\n\n\n    case OPCM_32_ABS_LDST_CONTEXT:\n\n        decode_abs_ldst_context(env, ctx);\n\n\n    case OPCM_32_ABS_STORE:\n\n        decode_abs_store(env, ctx);\n\n\n    case OPCM_32_ABS_STOREB_H:\n\n        decode_abs_storeb_h(env, ctx);\n\n\n    case OPC1_32_ABS_STOREQ:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n        temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n        temp2 = tcg_temp_new();\n\n\n\n        tcg_gen_shri_tl(temp2, cpu_gpr_d[r1], 16);\n\n        tcg_gen_qemu_st_tl(temp2, temp, ctx->mem_idx, MO_LEUW);\n\n\n\n        tcg_temp_free(temp2);\n\n        tcg_temp_free(temp);\n\n\n    case OPC1_32_ABS_LD_Q:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n        temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n\n\n        tcg_gen_qemu_ld_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LEUW);\n\n        tcg_gen_shli_tl(cpu_gpr_d[r1], cpu_gpr_d[r1], 16);\n\n\n\n        tcg_temp_free(temp);\n\n\n    case OPC1_32_ABS_LEA:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n        tcg_gen_movi_tl(cpu_gpr_a[r1], EA_ABS_FORMAT(address));\n\n\n/* ABSB-format */\n\n    case OPC1_32_ABSB_ST_T:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        b = MASK_OP_ABSB_B(ctx->opcode);\n\n        bpos = MASK_OP_ABSB_BPOS(ctx->opcode);\n\n\n\n        temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n        temp2 = tcg_temp_new();\n\n\n\n        tcg_gen_qemu_ld_tl(temp2, temp, ctx->mem_idx, MO_UB);\n\n        tcg_gen_andi_tl(temp2, temp2, ~(0x1u << bpos));\n\n        tcg_gen_ori_tl(temp2, temp2, (b << bpos));\n\n        tcg_gen_qemu_st_tl(temp2, temp, ctx->mem_idx, MO_UB);\n\n\n\n        tcg_temp_free(temp);\n\n        tcg_temp_free(temp2);\n\n\n/* B-format */\n\n    case OPC1_32_B_CALL:\n\n    case OPC1_32_B_CALLA:\n\n    case OPC1_32_B_J:\n\n    case OPC1_32_B_JA:\n\n    case OPC1_32_B_JL:\n\n    case OPC1_32_B_JLA:\n\n        address = MASK_OP_B_DISP24(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, 0, 0, 0, address);\n\n\n/* Bit-format */\n\n    case OPCM_32_BIT_ANDACC:\n\n        decode_bit_andacc(env, ctx);\n\n\n    case OPCM_32_BIT_LOGICAL_T1:\n\n        decode_bit_logical_t(env, ctx);\n\n\n    case OPCM_32_BIT_INSERT:\n\n        decode_bit_insert(env, ctx);\n\n\n    case OPCM_32_BIT_LOGICAL_T2:\n\n        decode_bit_logical_t2(env, ctx);\n\n\n    case OPCM_32_BIT_ORAND:\n\n        decode_bit_orand(env, ctx);\n\n\n    case OPCM_32_BIT_SH_LOGIC1:\n\n        decode_bit_sh_logic1(env, ctx);\n\n\n    case OPCM_32_BIT_SH_LOGIC2:\n\n        decode_bit_sh_logic2(env, ctx);\n\n\n    /* BO Format */\n\n    case OPCM_32_BO_ADDRMODE_POST_PRE_BASE:\n\n        decode_bo_addrmode_post_pre_base(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_BITREVERSE_CIRCULAR:\n\n        decode_bo_addrmode_bitreverse_circular(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_LD_POST_PRE_BASE:\n\n        decode_bo_addrmode_ld_post_pre_base(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_LD_BITREVERSE_CIRCULAR:\n\n        decode_bo_addrmode_ld_bitreverse_circular(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_STCTX_POST_PRE_BASE:\n\n        decode_bo_addrmode_stctx_post_pre_base(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_LDMST_BITREVERSE_CIRCULAR:\n\n        decode_bo_addrmode_ldmst_bitreverse_circular(env, ctx);\n\n\n/* BOL-format */\n\n    case OPC1_32_BOL_LD_A_LONGOFF:\n\n    case OPC1_32_BOL_LD_W_LONGOFF:\n\n    case OPC1_32_BOL_LEA_LONGOFF:\n\n    case OPC1_32_BOL_ST_W_LONGOFF:\n\n    case OPC1_32_BOL_ST_A_LONGOFF:\n\n        decode_bol_opc(env, ctx, op1);\n\n\n/* BRC Format */\n\n    case OPCM_32_BRC_EQ_NEQ:\n\n    case OPCM_32_BRC_GE:\n\n    case OPCM_32_BRC_JLT:\n\n    case OPCM_32_BRC_JNE:\n\n        const4 = MASK_OP_BRC_CONST4_SEXT(ctx->opcode);\n\n        address = MASK_OP_BRC_DISP15_SEXT(ctx->opcode);\n\n        r1 = MASK_OP_BRC_S1(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, r1, 0, const4, address);\n\n\n/* BRN Format */\n\n    case OPCM_32_BRN_JTT:\n\n        address = MASK_OP_BRN_DISP15_SEXT(ctx->opcode);\n\n        r1 = MASK_OP_BRN_S1(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, r1, 0, 0, address);\n\n\n/* BRR Format */\n\n    case OPCM_32_BRR_EQ_NEQ:\n\n    case OPCM_32_BRR_ADDR_EQ_NEQ:\n\n    case OPCM_32_BRR_GE:\n\n    case OPCM_32_BRR_JLT:\n\n    case OPCM_32_BRR_JNE:\n\n    case OPCM_32_BRR_JNZ:\n\n    case OPCM_32_BRR_LOOP:\n\n        address = MASK_OP_BRR_DISP15_SEXT(ctx->opcode);\n\n        r2 = MASK_OP_BRR_S2(ctx->opcode);\n\n        r1 = MASK_OP_BRR_S1(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, r1, r2, 0, address);\n\n\n/* RC Format */\n\n    case OPCM_32_RC_LOGICAL_SHIFT:\n\n        decode_rc_logical_shift(env, ctx);\n\n\n    case OPCM_32_RC_ACCUMULATOR:\n\n        decode_rc_accumulator(env, ctx);\n\n\n    case OPCM_32_RC_SERVICEROUTINE:\n\n        decode_rc_serviceroutine(env, ctx);\n\n\n    case OPCM_32_RC_MUL:\n\n        decode_rc_mul(env, ctx);\n\n\n/* RCPW Format */\n\n    case OPCM_32_RCPW_MASK_INSERT:\n\n        decode_rcpw_insert(env, ctx);\n\n\n/* RCRR Format */\n\n    case OPC1_32_RCRR_INSERT:\n\n        r1 = MASK_OP_RCRR_S1(ctx->opcode);\n\n        r2 = MASK_OP_RCRR_S3(ctx->opcode);\n\n        r3 = MASK_OP_RCRR_D(ctx->opcode);\n\n        const16 = MASK_OP_RCRR_CONST4(ctx->opcode);\n\n        temp = tcg_const_i32(const16);\n\n        temp2 = tcg_temp_new(); /* width*/\n\n        temp3 = tcg_temp_new(); /* pos */\n\n\n\n        tcg_gen_andi_tl(temp2, cpu_gpr_d[r3+1], 0x1f);\n\n        tcg_gen_andi_tl(temp3, cpu_gpr_d[r3], 0x1f);\n\n\n\n        gen_insert(cpu_gpr_d[r2], cpu_gpr_d[r1], temp, temp2, temp3);\n\n\n\n        tcg_temp_free(temp);\n\n        tcg_temp_free(temp2);\n\n        tcg_temp_free(temp3);\n\n\n/* RCRW Format */\n\n    case OPCM_32_RCRW_MASK_INSERT:\n\n        decode_rcrw_insert(env, ctx);\n\n\n/* RCR Format */\n\n    case OPCM_32_RCR_COND_SELECT:\n\n        decode_rcr_cond_select(env, ctx);\n\n\n    case OPCM_32_RCR_MADD:\n\n        decode_rcr_madd(env, ctx);\n\n\n    case OPCM_32_RCR_MSUB:\n\n        decode_rcr_msub(env, ctx);\n\n\n/* RLC Format */\n\n    case OPC1_32_RLC_ADDI:\n\n    case OPC1_32_RLC_ADDIH:\n\n    case OPC1_32_RLC_ADDIH_A:\n\n    case OPC1_32_RLC_MFCR:\n\n    case OPC1_32_RLC_MOV:\n\n    case OPC1_32_RLC_MOV_64:\n\n    case OPC1_32_RLC_MOV_U:\n\n    case OPC1_32_RLC_MOV_H:\n\n    case OPC1_32_RLC_MOVH_A:\n\n    case OPC1_32_RLC_MTCR:\n\n        decode_rlc_opc(env, ctx, op1);\n\n\n\n\n\n\n    }\n\n}", "idx": 7654, "substitutes": {"env": ["init", "vp", "entry", "query", "et", "kh", "conf", "dev", "estate", "den", "environment", "pkg", "cv", "conn", "esc", "v", "ec", "vs", "enter", "inv", "vt", "serv", "obj", "cb", "server", "ew", "en", "nv", "eng", "ten", "network", "vm", "nw", "e", "erd", "code", "sv", "ov", "hw", "window", "tx", "qt", "eh", "context", "er", "ev", "viron", "cmd", "event"], "ctx": ["tc", "gz", "kh", "conf", "pkg", "conn", "msg", "txt", "loc", "gc", "xs", "bp", "tx", "wcs", "kw", "cas", "cmd", "mc", "event", "sc", "cm", "cp", "jac", " cx", "work", "handler", "wx", "sp", "scope", "check", "serv", "obj", "crit", "wk", "kt", "mom", "js", "proc", "def", "nw", "ck", "tk", "context", "config", "func", "cb", "HK", " context", "np", "std", "scl", "cam", "exec", "that", "ct", "qt", "init", "cv", "tmp", "mk", "tz", "cc", "req", "ann", "resp", "act", "kb", "cmp", "jp", "cfg", "xc", "addr", "hw", "xp", "params", "bc", "batch"], "op1": [" popOnly", "pop01", "Op0", "pop1", " pop1", "copId", " opId", "OPId", "op01", "op2", "opn", " opOnly", " pop0", "OP01", " op2", " opn", "cop101", "OP2", "Op1", "cop0", "oc01", "oc101", "hop11", "cop01", "cop2", "pop2", "cop1", "popn", " op0", "OP1", "opId", " pop2", "opOnly", "cop11", "hop01", "hop101", "hop0", "OPn", "Op2", "oc11", "hop1", "op0", "op11", "oc1", " op01", "OP0", "op101", "OpOnly", "hop2"], "r1": [" r7", "R7", "rond", "rank1", "rank7", "rankond", " rOne", "rcone", "rc0", "R2", "Rond", "RMap", "R1", "rc3", "ROne", "rone", "R0", "rank2", "R3", "rc1", " rond", "r7", "Rone", "rcMap", "rcOne", "rMap", " rMap", "rOne", "r0", " r0", " rone"], "r2": ["rtwo", "mtwo", "ttwo", "t2", "r02", " r02", "m02", "t0", "t02", "r0", " r0", "m0", " rtwo", "m2"], "r3": ["mard", " rard", "R03", "R3", "m1", " r03", "rard", "R1", "Rard", "m03", "r03", "m3"], "address": ["ptr", "ace", "order", "assembly", "a", "bm", "ach", "resource", "argument", "length", "condition", "position", "prefix", "offset", "alias", "port", "phrase", "option", "attribute", "location", "word", "vector", "asm", "pointer", "index", "name", "memory", "point", "trace", "comment", "type", "interface", "operation", "buffer", "store", "command", "network", "variable", "ase", "table", "addr", "base", "ai", "byte", "Address", "number", "reference", "distance", "ash", "angle", "block", "directory", "context", "message", "shape", "value", "execute", "action"], "const16": ["cont16", "inst15", "inst8", "cont12", " const8", "const12", " const15", "const8", "cont8", "inst16", "const15", " const12", "inst12", "cont15"], "b": ["p", "bi", "a", "bm", "binary", "v", "cb", "br", "bs", "B", "bb", "bl", "mb", "ib", "buffer", "ba", "db", "base", "bp", "eb", "sb", "bc", "ob", "bf", "bin", "block", "nb", "ab", "be"], "const4": ["Const4", "cont44", "const44", "Const8", " const8", "const64", " const44", "cont64", "const8", "cont4", "cont8", " const64", "Const64", "Const44"], "bpos": ["cbindex", "cbposition", "boffset", "abpos", "abindex", "bbposition", "cboffset", "bindex", "bbindex", "aboffset", "bposition", "abposition", "bboffset", "cbpos", "bbpos"], "temp": ["tc", "ptr", "t", "master", "emp", "p", "tmp", "mi", "tim", "mp", "pre", "prefix", "stem", "typ", "txt", "map", "tar", "unt", "w", "port", "perature", "pt", "time", "ip", "mem", "index", "memory", "current", "term", "cap", "buffer", "height", "status", "fake", " Temp", "mint", "local", "tr", "mm", "Temp", "base", " temperature", "test", "ta", "tm", "EMP", "mod", "tem", "context", "tab", "input", "timer", "cache", "template"], "temp2": ["template2", "temp22", "temp7", "tmp22", "tempTwo", " temp1", "ptr3", "tmp1", "temp02", "emp5", "temp4", "tem5", "tmp3", "template7", "pt2", "tem1", "tmp2", "ptTwo", "ptr02", "emp2", "temp1", "tem2", "ptr2", "tmpor", "tem02", "tem4", "templateTwo", "empor", "temp5", "tmp5", "template22", "tmp7", "temTwo", " temp4", "tem3", "template1", "tmp4", "temor", "ptr22", "emp1", "tem7", "pt1", " temp5", "tmp02", "tempor", "tem22"], "temp3": ["tmp03", "m03", "tmp3", "t2", "t6", "t03", "tmp6", "temp6", "tmp2", "temp03", "m6", "t3", "m2", "m3"]}}
{"project": "FFmpeg", "commit_id": "a150bad4062a29fc11b32117bc1ade38115cd95b", "target": 0, "func": "AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,\n\n                                                            int perms)\n\n{\n\n    AVFilterBufferRef *picref =\n\n        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,\n\n                                                  frame->width, frame->height,\n\n                                                  frame->format);\n\n    if (!picref)\n\n        return NULL;\n\n    avfilter_copy_frame_props(picref, frame);\n\n    return picref;\n\n}\n", "idx": 7659, "substitutes": {"frame": ["df", "request", "scene", "ace", "doc", "fr", "entry", "zo", "pose", "cast", " image", "f", "data", "draw", "pixel", "component", "list", "image", "file", "channel", "rame", "frames", "call", "piece", "force", "version", "one", "show", "module", "profile", "word", "ie", "cell", "state", "feature", "point", "trace", "range", "Frame", "ref", "buffer", "row", "remote", " input", "process", "code", "sample", "movie", "face", "flow", "instance", " timeframe", "line", "page", " framed", " Frame", "ce", "base", "part", "window", "zone", "sequence", " fr", "user", "from", "shot", "feat", "video", "block", "picture", "load", "event", "close"], "perms": ["PERmissions", "Perm", " perfs", "permms", "Permissions", "permMS", "PERfs", "perMS", "PerMS", "Perms", " perm", "PERents", "permissions", " perents", "perm", " permissions", "perfs", " perMS", "PERm", "permfs", "PERMS", "PERms", "perments", "perents"], "picref": ["picelf", "pictureref", "Picdef", "picob", "Picref", " picdef", "imgref", " picrel", "pictureRef", "preference", "picRef", "picreference", "imgdef", "icdef", "icref", "picturerel", "micreference", " picreference", "PicRef", " pictureRef", "picdef", "icreference", "pref", " picelf", "Picreference", "pictureelf", "picrel", "micref", "imgreference", " picRef", "pdef", "micdef", "imgob", "pob", " pictureref", " pictureelf", "micRef", "icRef", " picob", " picturerel"]}}
{"project": "qemu", "commit_id": "b7b5233ad7fdd9985bb6d05b7919f3a20723ff2c", "target": 1, "func": "void *g_realloc(void *ptr, size_t size)\n\n{\n\n    size_t old_size, copy;\n\n    void *new_ptr;\n\n\n\n    if (!ptr)\n\n        return g_malloc(size);\n\n    old_size = *(size_t *)((char *)ptr - 16);\n\n    copy = old_size < size ? old_size : size;\n\n    new_ptr = g_malloc(size);\n\n    memcpy(new_ptr, ptr, copy);\n\n    g_free(ptr);\n\n    return new_ptr;\n\n}\n", "idx": 7662, "substitutes": {"ptr": ["dr", "fr", "t", "rep", "p", "inter", "prime", "dest", "ctr", "ped", "d", " addr", "ind", "sp", "r", "pipe", "ctx", "arr", "length", "pc", "ping", "pointers", "scope", "inst", "address", "obj", "loc", "offset", "inters", "handle", "br", "pad", "pt", "dh", "mem", "pointer", "po", "index", "err", "Ptr", "pr", "ref", "buffer", "tp", "iter", "code", "alloc", "len", "rect", "rel", " pointer", "tr", "addr", "expr", "src", "pos", "pre", "dep"], "size": ["capacity", "small", "p", "max", "Size", "id", "sum", "sp", "data", "length", "SIZE", "ize", "scope", "address", "any", "equal", "style", "si", " Size", "span", "time", "empty", "space", "index", "name", "sh", "sy", "fee", "g", "type", "zero", "new", "height", "len", "code", "sn", "now", "ci", "scale", "dimension", "number", "num", "count", "s", "z", "shape"], "old_size": ["older_hash", "old67scale", "old_scale", "old_SIZE", "oldaxysize", "OLD_size", "old_count", "old__SIZE", "old_length", "older_scale", " old_sum", " old_type", " old_count", "old67hash", "OLD_length", "old67size", "old_hash", "old_type", "older_size", "old_Size", "old67Size", "older_Size", "old__length", "old_sum", "oldaxycount", "old__size", "oldaxytype", "OLD_SIZE"], "copy": ["cp", "co", "save", "share", "limit", "delete", "le", "opy", "sp", "Copy", "ignore", "clone", "error", "sync", "check", "force", "map", "gc", "ge", "cop", "replace", "link", "ip", "quote", "memory", "slice", "ice", "write", "store", "clip", "same", "scale", "repeat", "ce", "core", "count", "move", "transfer", "push", "skip", "create", "go", "load", "score"], "new_ptr": [" new_addr", "newlyfp", "new_pt", " new_pointer", "newlyptr", "new_Ptr", " new_Ptr", "new___pt", "new_fp", " new_ctx", "new___Ptr", "new_ctx", " new_pt", " new_desc", "new__fp", "new_pointer", "new__obj", "new___ptr", "new_pr", " new_obj", "new_obj", "new___addr", "new_addr", " new_pr", "new__pr", " new_fp", "new_desc", "newlypr", "new__ptr", "newlyobj"]}}
{"project": "FFmpeg", "commit_id": "369cb092ecbbaff20bb0a2a1d60536c3bc04a8f0", "target": 1, "func": "static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc)\n\n{\n\n    AVStream *st;\n\n    OutputStream *ost;\n\n    AVCodecContext *audio_enc;\n\n\n\n    ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO);\n\n    st  = ost->st;\n\n\n\n    audio_enc = st->codec;\n\n    audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n    if (!ost->stream_copy) {\n\n        char *sample_fmt = NULL;\n\n\n\n        MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st);\n\n\n\n        MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st);\n\n        if (sample_fmt &&\n\n            (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Invalid sample format '%s'\\n\", sample_fmt);\n\n            exit_program(1);\n\n        }\n\n\n\n        MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st);\n\n    }\n\n\n\n    return ost;\n\n}\n", "idx": 7666, "substitutes": {"o": ["bo", "t", "os", "p", "co", "f", "od", "ou", "d", "v", "options", "or", "oi", "ok", "so", "io", "oo", "i", "po", "O", "onet", "y", "ot", "om", "enc", "vo", "e", "og", "op", "mo", "on", "c", "ob", "s", "n", "u", "out", "oa"], "oc": ["tc", "ocon", "toc", "isc", "os", "et", "co", "OC", "unc", "oss", "ace", "oco", "erc", "vc", "usc", "ec", "oci", "ic", "roc", "arc", "loc", "cc", "aic", "ive", "ok", "osc", "oad", "anc", "soc", "irc", "uc", "ot", "ocr", "enc", "vo", "ous", "og", "ct", "ac", "c", "ob", "oid", "ocation", "ocal", "voc", "ict", "nc", "mc", "mic", "ico"], "st": ["ST", "ust", "stage", "sc", "fr", "t", "os", "otype", "et", "irst", "art", "th", "tt", "ty", "sec", "sp", "nt", "put", "ut", "ft", "pg", "sta", "spect", "stable", "inst", "stack", "sl", "cl", "str", "ss", "ist", "ld", "ast", "se", "so", "pt", "i", "mt", "ste", "stop", "est", "usr", "proc", "sys", "step", "std", "sts", "stan", "net", "store", "rest", "ot", "ocr", "ts", "sn", "stat", "rd", "storage", "ct", "nd", "sty", "St", "src", "ob", "start", "rt", "stream", " nost", "sw", "be"], "ost": ["ST", "bo", "ust", "os", "rost", "co", "oss", "host", "irst", "otype", "art", "et", "tt", "od", " est", "ott", "org", "nt", "\u00f3", "post", " soc", "sta", "inst", "roc", "boost", "ist", "or", "ast", "oad", "so", "oo", "wo", "mt", " bos", "est", "OST", "rest", "ot", "ocr", " ut", "utt", "obs", "op", "ort", "rog", " sto", "ct", "yt", "tx", "us", "src", "ob", "oid", "St", "oe", "stream", " nost", "sw"], "audio_enc": ["media_ens", "audio_ac", "audio___enc", "volume_en", "music_en", "audio__Enc", "audio_rc", "music_ENC", "media_enc", "audio__ec", "volume_enc", "volume_Enc", "audio_inc", "audio2enc", "music_ec", "audio___ens", "media_ac", "audio_ens", "audio_ec", "audio___inc", "audio___ec", " audio_en", "audio__en", " audio_ec", "audio__enc", "audio_Enc", "music_enc", "audio2Enc", "audio_ent", " audio_rc", "audio2rc", "media_ec", " audio_Enc", "audio_en", "media_inc", "audio_ENC", "volume_ent", "media_en", "audio2en", "audio2ec"], "sample_fmt": ["sample_ttx", "sample_vtx", "sample_fnd", "sample_Fmt", "sample_flt", "sample__vlt", "sampleablefretx", "sample__fmt", "sample_forlt", "sample_mtx", "sample_vformat", "sample_Fnd", "sample_cmm", "sample__vMT", "sample__vtx", "sample_fdr", "sample_fmm", "sample_fmn", "sampleablefmt", "sample__ftx", "sample_mMT", "sample_fMT", "sample_ltx", "sample__fMT", "sampleableftx", "sample_tdr", "sampleablefrelt", "sample_tmt", "sample_tmn", "sample_tlt", "sample_cmt", "sample_mmt", "sample_lmm", "sample_tmm", "sample_fformat", "sampleableflt", "sample_fremt", "sample_formp", "sample_vMT", "sample_frelt", "sample_mlt", "sample_vmm", "sample_Fmm", "sample_fmp", "sample_lmt", "sampleablefrepl", "sample_Flt", "sample_lnd", "sample_cformat", "sample_tmp", "sample_fpl", "sample_FMT", "sample_ftx", "sample_frepl", "sample_Fpl", "sampleablefpl", "sample_fretx", "sample_Ftx", "sample_clt", "sample__flt", "sampleablefremt", "sample_formt", "sample__vmt", "sample_vmt", "sample_formn", "sample_vdr", "sample_vlt"]}}
{"project": "FFmpeg", "commit_id": "221402c1c88b9d12130c6f5834029b535ee0e0c5", "target": 1, "func": "static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    AVFrame *const p   = data;\n    int compressed, xmin, ymin, xmax, ymax;\n    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,\n                 bytes_per_scanline;\n    uint8_t *ptr;\n    const uint8_t *buf_end = buf + buf_size;\n    const uint8_t *bufstart = buf;\n    uint8_t *scanline;\n    int ret = -1;\n    if (buf[0] != 0x0a || buf[1] > 5) {\n        av_log(avctx, AV_LOG_ERROR, \"this is not PCX encoded data\\n\");\n    compressed = buf[2];\n    xmin       = AV_RL16(buf + 4);\n    ymin       = AV_RL16(buf + 6);\n    xmax       = AV_RL16(buf + 8);\n    ymax       = AV_RL16(buf + 10);\n    if (xmax < xmin || ymax < ymin) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid image dimensions\\n\");\n    w = xmax - xmin + 1;\n    h = ymax - ymin + 1;\n    bits_per_pixel     = buf[3];\n    bytes_per_line     = AV_RL16(buf + 66);\n    nplanes            = buf[65];\n    bytes_per_scanline = nplanes * bytes_per_line;\n    if (bytes_per_scanline < (w * bits_per_pixel * nplanes + 7) / 8 ||\n        (!compressed && bytes_per_scanline > buf_size / h)) {\n        av_log(avctx, AV_LOG_ERROR, \"PCX data is corrupted\\n\");\n    switch ((nplanes << 8) + bits_per_pixel) {\n    case 0x0308:\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n        break;\n    case 0x0108:\n    case 0x0104:\n    case 0x0102:\n    case 0x0101:\n    case 0x0401:\n    case 0x0301:\n    case 0x0201:\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"invalid PCX file\\n\");\n    buf += 128;\n    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n        return ret;\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    p->pict_type = AV_PICTURE_TYPE_I;\n    ptr    = p->data[0];\n    stride = p->linesize[0];\n    scanline = av_malloc(bytes_per_scanline + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!scanline)\n        return AVERROR(ENOMEM);\n    if (nplanes == 3 && bits_per_pixel == 8) {\n        for (y = 0; y < h; y++) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++) {\n                ptr[3 * x]     = scanline[x];\n                ptr[3 * x + 1] = scanline[x + bytes_per_line];\n                ptr[3 * x + 2] = scanline[x + (bytes_per_line << 1)];\n            ptr += stride;\n    } else if (nplanes == 1 && bits_per_pixel == 8) {\n        const uint8_t *palstart = bufstart + buf_size - 769;\n        if (buf_size < 769) {\n            av_log(avctx, AV_LOG_ERROR, \"File is too short\\n\");\n            ret = avctx->err_recognition & AV_EF_EXPLODE ?\n                  AVERROR_INVALIDDATA : buf_size;\n            goto end;\n        for (y = 0; y < h; y++, ptr += stride) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            memcpy(ptr, scanline, w);\n        if (buf != palstart) {\n            av_log(avctx, AV_LOG_WARNING, \"image data possibly corrupted\\n\");\n            buf = palstart;\n        if (*buf++ != 12) {\n            av_log(avctx, AV_LOG_ERROR, \"expected palette after image data\\n\");\n            ret = avctx->err_recognition & AV_EF_EXPLODE ?\n                  AVERROR_INVALIDDATA : buf_size;\n            goto end;\n    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */\n        GetBitContext s;\n        for (y = 0; y < h; y++) {\n            init_get_bits(&s, scanline, bytes_per_scanline << 3);\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++)\n                ptr[x] = get_bits(&s, bits_per_pixel);\n            ptr += stride;\n    } else {    /* planar, 4, 8 or 16 colors */\n        int i;\n        for (y = 0; y < h; y++) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++) {\n                int m = 0x80 >> (x & 7), v = 0;\n                for (i = nplanes - 1; i >= 0; i--) {\n                    v <<= 1;\n                    v  += !!(scanline[i * bytes_per_line + (x >> 3)] & m);\n                ptr[x] = v;\n            ptr += stride;\n    if (nplanes == 1 && bits_per_pixel == 8) {\n        pcx_palette(&buf, (uint32_t *)p->data[1], 256);\n    } else if (bits_per_pixel < 8) {\n        const uint8_t *palette = bufstart + 16;\n        pcx_palette(&palette, (uint32_t *)p->data[1], 16);\n    *got_frame = 1;\n    ret = buf - bufstart;\nend:\n    av_free(scanline);\n    return ret;", "idx": 7670, "substitutes": {"avctx": [" avcontext", "navcontext", "afjac", "avertx", "afcontext", " avreq", "aircpp", "avercas", "avercpp", "avcu", "afctx", "afcmd", "navctx", "navcas", "averpkg", "afpkg", "avjac", "avcmd", "airpkg", "avcas", "AVctx", "avcmp", "afcas", "navtx", "aftx", "airctx", " avcmd", "svreq", "avecmp", " avtx", "svcontext", "avgc", "avectx", "afcpp", "afcu", "navjac", "averjac", " avgc", "svctx", " avconn", "avecmd", "aircu", "AVconn", "AVcontext", "navgc", "avpkg", "afgc", "avconn", "AVreq", "avcontext", "avtx", "avercu", "avcpp", "averctx", "svconn", "avecontext", "avreq", " avcmp", "afcmp"], "data": ["t", "frame", "f", "a", "d", "r", "length", "channel", "image", "file", "DATA", "padding", "map", "reader", "obj", "str", "Data", "pad", "read", "feed", "output", "dat", "size", "next", "in", "bytes", "name", "response", "ref", "buffer", "text", "ata", "rec", "xy", "record", "res", "rel", "page", "bits", "raw", "window", "bin", "video", "message", "block", "batch", "input", "value", "action"], "got_frame": ["got__image", "got_image", "received_msg", "received_image", "received_frame", "got_msg", "got__msg", "got__frame", "received_state", "got_state", "got__state"], "avpkt": ["avcpacket", "wavPett", " avpds", "wavpct", "wavpacket", "avPwd", "avcpnt", "avpnt", "afpct", "avspett", "wavpkt", "afpkt", "avlpacket", "afcpct", "afpwd", "afpacket", "avPett", "wavPacket", "afcpwd", "wavPkt", "avcpct", "avpett", "avcpwd", " avPct", " avPds", "avlpct", "avcpkt", "avpbct", "avspkt", "avspacket", "avspct", "avPkt", "avlpwd", " avPkt", "avPacket", "avcpett", "avcpds", "avlpkt", "avPnt", " avpct", "afcpkt", "avpbds", "wavPct", "afcpacket", "avPct", "avpacket", " avPnt", " avpnt", "avpwd", "avpct", "avpbnt", "avpbkt", "avPds", "avpds", "wavpett"], "buf": ["deg", "pkg", "fac", "msg", "txt", "str", "cur", "Buff", "burst", "que", "iter", "db", "coord", "vec", "uf", "queue", "box", "cmd", "pack", "r", "ctx", "xff", "list", "obj", "aka", "buff", "dat", "mem", "proc", "pb", "ref", "buffer", "len", "used", "raw", "num", "seq", "bu", "bh", "ctr", "func", "fb", "map", "cb", "Buffer", "port", "br", "pad", "nm", "bs", "cap", "pool", "cam", "conv", "var", "bag", "img", "vp", "doc", "cv", "tmp", "pg", "prop", "ff", "req", "emb", "bytes", "orig", "bl", "alloc", "cmp", "front", "late", "tr", "addr", "desc", "bin", "cache", "rb", "err", "batch"], "p": ["pp", "rep", "t", "f", "d", "v", "r", "ps", "pc", "q", "prop", "pro", "j", "o", "ap", " P", "comp", "pb", "fp", "m", "P", "c", "pos", "n", "u"], "compressed": ["compression", "Compress", "compacted", " uncompression", "Compression", "contended", "Compended", "ompressed", " uncompresses", " uncompacted", "buffpacked", " uncomppacked", "buffressed", "compress", "ompress", "ompacted", "Compacted", "Compressed", "compresses", "Compresses", "buffacted", "contresses", " uncompended", "comppacked", " uncompressed", "ompression", "omppacked", "buffression", "contress", "compended", "contressed", " uncompress"], "xmin": ["ximax", "yMin", "xiMin", " xsort", " xMin", "ixmins", "ysmall", "oxsmall", "ixonly", "ixmin", "ixbegin", "lmins", "oxonly", "lmax", "lbegin", "oxmins", "yonly", "ymins", "ximin", "xsort", "xfrom", "ysort", "lmin", "ixmax", "oxmin", "ixsmall", "oxfrom", "yfrom", "xonly", "xisort", "xbegin", " xmins", " xbegin", "ixfrom", "xmins", "xMin", "oxmax", "xsmall"], "ymin": ["nymin", " yminute", "yMin", "erystar", "symax", "symin", "mymax", "symins", " ysmall", "ysmall", " yonly", "mystart", "mymin", "ystart", "aysmall", " ystar", " yMin", "eryminute", "eymin", "aymin", "skyonly", "yminute", " ymins", "skystart", "yonly", "sysmall", "ymins", "eystart", "aymins", "eystar", " ystart", "skymin", "eryMin", "eymax", "skymins", "eyMin", "erymin", "nymins", "ystar", "eyminute", "myminute", "nyonly", "aymax", "nystart"], "xmax": ["xax", "XMax", "ixma", "xMax", "xMAX", "rxend", "rxMax", " xend", "ixMAX", "exmin", "Xax", "ixmin", "xlast", "oxax", "oxma", "Xmin", " xMAX", "ixax", "exax", " xMax", "ixlast", "Xend", "oxMAX", "oxmin", "ixmax", "Xmax", "oxend", "rxmax", " xlast", "xend", " xma", " xax", "exlast", "xma", "exmax", "oxmax", "rxax"], "ymax": ["iemaj", "uyail", "iemapper", "ypagic", "ymagic", "iyand", "ymad", "ypatch", "uyake", "ymapper", "ypain", "iemand", "yragic", "ymatch", "nyatch", "ymand", "ymake", "ymaj", "yrax", "ypax", "yratch", "ymmand", "nyax", "ynac", "iyaj", "ymmaj", "yrody", "ymmain", "nyagic", "ypail", "yrad", "ypad", "iyapper", "ypac", "uyax", "ymmail", "nyody", "yrac", "ymmake", "ymac", "ynad", "iyax", "uyain", "ynax", "yrail", "ynail", "ymail", "ymmax", "ymain", "ymody", "ypake", "iemax", "ymmapper", "ypody"], "w": ["wh", "work", "ww", "d", "l", "v", "wx", "rw", "r", "wal", "aw", "wa", "wp", "fw", "ew", "wt", "size", "ex", "wn", "we", "tw", "wd", "W", "g", "height", "wid", "wl", "nw", "m", "wr", "win", "hw", "window", "kw", "n", "xp", "z", "iw", "wb", "sw"], "h": ["ph", "hd", "hm", "kh", "html", "ch", "ih", "oh", "max", "bh", "wh", "f", "l", "v", "high", "r", "H", "length", "ha", "hz", "q", "hi", "k", "he", "o", "rows", "size", "ho", "ht", "b", "hs", "hr", "height", "m", "hw", "hh", "c", "n", "z", "u"], "bits_per_pixel": ["bits_PER_pixel", "bits_for_pixel", "bits_per_image", "bits_PER_chip", "bits_per__image", "bits_PER_channel", "bits_per2pixel", "bits_per2channel", "bits_per_chip", "bits_PER_Pixel", "bits_per_channel", "bits_per_color", "bits_PER_image", "bits_per_line", "bits_per2Pixel", "bits_for_line", "bits_for_color", "bits_per__channel", "bits_per_Pixel", "bits_per__pixel", "bits_per___pixel", "bits_per___chip", "bits_per___channel"], "bytes_per_line": ["bytes_in_page", "bytes_perxpage", "bytes_perxpixel", "bytes_Per_page", "bytes_Per_line", "bytes_Per_pixel", "bytes_in_Line", "bytes_per_block", "bytes_in_line", "bytes_per_Line", "bytes_perxLine", "bytes_per_pixel", "bytes_per_page", "bytes_perxline", "bytes_Per_Line", "bytes_Per_block"], "nplanes": ["nanes", "ncplanes", "numframes", "ncpages", "nrblocks", "nblocks", "gframes", "mplanes", "nmodules", "gpages", "ncmodules", "numpages", "dplane", "mblocks", "nsframes", "dplanes", "nsplanes", "danes", "gplanes", "nlines", " nanes", "nframes", "numlines", "gbands", "nsbands", "glines", "numanes", "nbands", "cpages", "anplanes", "mframes", "anframes", "nsplane", "cplane", "numplanes", "cplanes", "cbands", "nbplanes", "nbfiles", " nplane", "nbpages", "anlines", "mplane", "numfiles", "dframes", "nrplanes", "nrframes", "nrplane", "anpages", "nspages", "numplane", "npages", "gplane", "nummodules", "nbmodules", "nsblocks", "nplane", " nframes", "ncfiles", "nfiles"], "stride": ["collride", "strine", "slride", "glides", "gline", "colline", "glride", "strides", "collide", "strride", "sline", "collides", "slides", "glide", "slide"], "y": ["key", "t", "yi", "ch", "dy", "ym", "ies", "my", "j", "gy", "b", "ey", "Y", "sy", "height", "cy", "xy", "m", "iy", "yt", "c", "n", "z", "yy"], "x": ["t", "max", "X", "f", "l", "wx", "ix", "ox", "px", "size", "ex", "dx", "rx", "height", "xy", "xs", "m", "xc", "n", "xp", "z"], "bytes_per_scanline": ["bytes_per_binblock", "bytes_per_checklines", "bytes_per_scanLine", "bytes_per_checklink", "bytes_per_checkline", "bytes_per_canline", "bytes_per_binline", "bytes_per_Scanline", "bytes_per_Scanner", "bytes_per_Scanblock", "bytes_per_canLine", "bytes_per_checkLine", "bytes_per_canblock", "bytes_per_scanner", "bytes_per_ScanLine", "bytes_per_binner", "bytes_per_Scanlines", "bytes_per_scanlink", "bytes_per_scanlines", "bytes_per_scanblock", "bytes_per_Scanlink"], "ptr": ["fr", "dr", "rc", "temp", "progress", "ctr", "arr", "pointers", "map", "cur", "req", "br", "pad", "buff", "mem", "pointer", "np", "Ptr", "cap", "ref", "alloc", "tr", "addr", "desc", "src", "err", "cmd", "seek"], "buf_end": ["buff_end", "buff_start", "buff_ends", "buf_start", "buf_ends"], "bufstart": ["bufstop", "camstart", "camend", "capStart", "bufferstop", "camstop", "capstop", "bufend", "bufferend", "bufStart", "capend", "bufferstart", "bufferStart", "camStart", "capstart"], "scanline": ["rowLine", "scanLine", "ScanLine", " scanlines", "rowline", " scanLine", "scanlen", "Scanlen", "Scanline", "Scanlines", " scanlen", "scanlines", "rowlen", "rowlines"]}}
{"project": "qemu", "commit_id": "196a778428989217b82de042725dc8eb29c8f8d8", "target": 1, "func": "static void ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIQXLDevice *d = opaque;\n\n    uint32_t io_port = addr - d->io_base;\n\n\n\n    switch (io_port) {\n\n    case QXL_IO_RESET:\n\n    case QXL_IO_SET_MODE:\n\n    case QXL_IO_MEMSLOT_ADD:\n\n    case QXL_IO_MEMSLOT_DEL:\n\n    case QXL_IO_CREATE_PRIMARY:\n\n        break;\n\n    default:\n\n        if (d->mode == QXL_MODE_NATIVE || d->mode == QXL_MODE_COMPAT)\n\n            break;\n\n        dprint(d, 1, \"%s: unexpected port 0x%x in vga mode\\n\", __FUNCTION__, io_port);\n\n        return;\n\n    }\n\n\n\n    switch (io_port) {\n\n    case QXL_IO_UPDATE_AREA:\n\n    {\n\n        QXLRect update = d->ram->update_area;\n\n        qemu_mutex_unlock_iothread();\n\n        d->ssd.worker->update_area(d->ssd.worker, d->ram->update_surface,\n\n                                   &update, NULL, 0, 0);\n\n        qemu_mutex_lock_iothread();\n\n        break;\n\n    }\n\n    case QXL_IO_NOTIFY_CMD:\n\n        d->ssd.worker->wakeup(d->ssd.worker);\n\n        break;\n\n    case QXL_IO_NOTIFY_CURSOR:\n\n        d->ssd.worker->wakeup(d->ssd.worker);\n\n        break;\n\n    case QXL_IO_UPDATE_IRQ:\n\n        qxl_set_irq(d);\n\n        break;\n\n    case QXL_IO_NOTIFY_OOM:\n\n        if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) {\n\n            break;\n\n        }\n\n        pthread_yield();\n\n        if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) {\n\n            break;\n\n        }\n\n        d->oom_running = 1;\n\n        d->ssd.worker->oom(d->ssd.worker);\n\n        d->oom_running = 0;\n\n        break;\n\n    case QXL_IO_SET_MODE:\n\n        dprint(d, 1, \"QXL_SET_MODE %d\\n\", val);\n\n        qxl_set_mode(d, val, 0);\n\n        break;\n\n    case QXL_IO_LOG:\n\n        if (d->guestdebug) {\n\n            fprintf(stderr, \"qxl/guest: %s\", d->ram->log_buf);\n\n        }\n\n        break;\n\n    case QXL_IO_RESET:\n\n        dprint(d, 1, \"QXL_IO_RESET\\n\");\n\n        qxl_hard_reset(d, 0);\n\n        break;\n\n    case QXL_IO_MEMSLOT_ADD:\n\n        PANIC_ON(val >= NUM_MEMSLOTS);\n\n        PANIC_ON(d->guest_slots[val].active);\n\n        d->guest_slots[val].slot = d->ram->mem_slot;\n\n        qxl_add_memslot(d, val, 0);\n\n        break;\n\n    case QXL_IO_MEMSLOT_DEL:\n\n        qxl_del_memslot(d, val);\n\n        break;\n\n    case QXL_IO_CREATE_PRIMARY:\n\n        PANIC_ON(val != 0);\n\n        dprint(d, 1, \"QXL_IO_CREATE_PRIMARY\\n\");\n\n        d->guest_primary.surface = d->ram->create_surface;\n\n        qxl_create_guest_primary(d, 0);\n\n        break;\n\n    case QXL_IO_DESTROY_PRIMARY:\n\n        PANIC_ON(val != 0);\n\n        dprint(d, 1, \"QXL_IO_DESTROY_PRIMARY\\n\");\n\n        qxl_destroy_primary(d);\n\n        break;\n\n    case QXL_IO_DESTROY_SURFACE_WAIT:\n\n        d->ssd.worker->destroy_surface_wait(d->ssd.worker, val);\n\n        break;\n\n    case QXL_IO_DESTROY_ALL_SURFACES:\n\n        d->ssd.worker->destroy_surfaces(d->ssd.worker);\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: ioport=0x%x, abort()\\n\", __FUNCTION__, io_port);\n\n        abort();\n\n    }\n\n}\n", "idx": 7696, "substitutes": {"opaque": ["patile", "ipaque", "iopaque", "opaques", "paque", "oppaque", "iopque", " opade", "iopaques", "pque", "opque", "opatile", " opatile", "ipque", "paques", "ipatile", "ipaques", "oppade", "opacity", "oppatile", " opacity", "oppacity", "iopatile", "pacity", "opade", "pade"], "addr": ["ptr", "inter", "host", "eth", "pkg", "work", "conn", "ix", "hash", "ad", "prefix", "address", "obj", "loc", "offset", "trans", "alias", "pad", "oad", "adr", "i", "ip", "name", "at", "ref", "wid", "now", "ord", "alloc", "db", "res", "coord", "hw", "Address", "env", "src", "cmd", "pos", "ack", "add", "start", "oa"], "val": ["key", "VAL", "p", "conf", "eval", "sel", "cho", "v", "data", "ctx", "it", "serv", "ret", "mem", "name", "rx", " value", "buf", "pol", "buffer", "xy", "db", "m", "res", "vals", "ival", "unit", "base", "Value", "var", "x", "seq", "update", "tx", "vol", "al", "local", "vt", "value", "Val"], "d": ["dr", "t", "dj", "p", "conf", "dev", "de", "dt", "td", "dm", "ds", "f", "debug", "l", "ind", "dim", "id", "r", "done", "ad", "fd", "dd", "dc", "ded", "q", "cd", "send", "w", "diff", "ld", "self", "dq", "di", "j", "h", "o", "dl", "dat", "dn", "sd", "D", "dh", "did", "dict", "result", "dx", "dump", "name", "g", "md", "da", "du", "ord", "rest", "pd", "e", "db", "dom", "m", "end", "der", "rd", "ed", "all", "nd", "mod", "c", "z", "ctl", "bd"]}}
{"project": "FFmpeg", "commit_id": "4cec43a9eeb58eb9e581a2d9d25f78e5bfbb0960", "target": 0, "func": "static int h264_slice_header_parse(H264Context *h, H264SliceContext *sl)\n\n{\n\n    const SPS *sps;\n\n    const PPS *pps;\n\n    unsigned int first_mb_in_slice;\n\n    unsigned int pps_id;\n\n    int ret;\n\n    unsigned int slice_type, tmp, i;\n\n    int last_pic_structure, last_pic_droppable;\n\n    int needs_reinit = 0;\n\n    int field_pic_flag, bottom_field_flag;\n\n    int frame_num, droppable, picture_structure;\n\n    int mb_aff_frame = 0;\n\n\n\n    first_mb_in_slice = get_ue_golomb(&sl->gb);\n\n\n\n    if (first_mb_in_slice == 0) { // FIXME better field boundary detection\n\n        if (h->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {\n\n            ff_h264_field_end(h, sl, 1);\n\n        }\n\n\n\n        h->current_slice = 0;\n\n        if (!h->first_field) {\n\n            if (h->cur_pic_ptr && !h->droppable) {\n\n                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                          h->picture_structure == PICT_BOTTOM_FIELD);\n\n            }\n\n            h->cur_pic_ptr = NULL;\n\n        }\n\n    }\n\n\n\n    slice_type = get_ue_golomb_31(&sl->gb);\n\n    if (slice_type > 9) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"slice type %d too large at %d\\n\",\n\n               slice_type, first_mb_in_slice);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (slice_type > 4) {\n\n        slice_type -= 5;\n\n        sl->slice_type_fixed = 1;\n\n    } else\n\n        sl->slice_type_fixed = 0;\n\n\n\n    slice_type         = ff_h264_golomb_to_pict_type[slice_type];\n\n    sl->slice_type     = slice_type;\n\n    sl->slice_type_nos = slice_type & 3;\n\n\n\n    if (h->nal_unit_type  == NAL_IDR_SLICE &&\n\n        sl->slice_type_nos != AV_PICTURE_TYPE_I) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"A non-intra slice in an IDR NAL unit.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    pps_id = get_ue_golomb(&sl->gb);\n\n    if (pps_id >= MAX_PPS_COUNT) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"pps_id %u out of range\\n\", pps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!h->ps.pps_list[pps_id]) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"non-existing PPS %u referenced\\n\",\n\n               pps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!h->setup_finished) {\n\n        h->ps.pps = (const PPS*)h->ps.pps_list[pps_id]->data;\n\n    } else if (h->ps.pps != (const PPS*)h->ps.pps_list[pps_id]->data) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"PPS changed between slices\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!h->ps.sps_list[h->ps.pps->sps_id]) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"non-existing SPS %u referenced\\n\",\n\n               h->ps.pps->sps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (h->ps.sps != (const SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data) {\n\n        h->ps.sps = (SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data;\n\n\n\n        if (h->bit_depth_luma    != h->ps.sps->bit_depth_luma ||\n\n            h->chroma_format_idc != h->ps.sps->chroma_format_idc)\n\n            needs_reinit         = 1;\n\n    }\n\n\n\n    pps = h->ps.pps;\n\n    sps = h->ps.sps;\n\n\n\n    if (!h->setup_finished) {\n\n        h->avctx->profile = ff_h264_get_profile(sps);\n\n        h->avctx->level   = sps->level_idc;\n\n        h->avctx->refs    = sps->ref_frame_count;\n\n\n\n        if (h->mb_width  != sps->mb_width ||\n\n            h->mb_height != sps->mb_height * (2 - sps->frame_mbs_only_flag))\n\n            needs_reinit = 1;\n\n\n\n        h->mb_width  = sps->mb_width;\n\n        h->mb_height = sps->mb_height * (2 - sps->frame_mbs_only_flag);\n\n        h->mb_num    = h->mb_width * h->mb_height;\n\n        h->mb_stride = h->mb_width + 1;\n\n\n\n        h->b_stride = h->mb_width * 4;\n\n\n\n        h->chroma_y_shift = sps->chroma_format_idc <= 1; // 400 uses yuv420p\n\n\n\n        h->width  = 16 * h->mb_width;\n\n        h->height = 16 * h->mb_height;\n\n\n\n        ret = init_dimensions(h);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        if (sps->video_signal_type_present_flag) {\n\n            h->avctx->color_range = sps->full_range ? AVCOL_RANGE_JPEG\n\n                : AVCOL_RANGE_MPEG;\n\n            if (sps->colour_description_present_flag) {\n\n                if (h->avctx->colorspace != sps->colorspace)\n\n                    needs_reinit = 1;\n\n                h->avctx->color_primaries = sps->color_primaries;\n\n                h->avctx->color_trc       = sps->color_trc;\n\n                h->avctx->colorspace      = sps->colorspace;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (h->context_initialized && needs_reinit) {\n\n        h->context_initialized = 0;\n\n        if (sl != h->slice_ctx) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"changing width %d -> %d / height %d -> %d on \"\n\n                   \"slice %d\\n\",\n\n                   h->width, h->avctx->coded_width,\n\n                   h->height, h->avctx->coded_height,\n\n                   h->current_slice + 1);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        ff_h264_flush_change(h);\n\n\n\n        if ((ret = get_pixel_format(h)) < 0)\n\n            return ret;\n\n        h->avctx->pix_fmt = ret;\n\n\n\n        av_log(h->avctx, AV_LOG_INFO, \"Reinit context to %dx%d, \"\n\n               \"pix_fmt: %d\\n\", h->width, h->height, h->avctx->pix_fmt);\n\n\n\n        if ((ret = h264_slice_header_init(h)) < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"h264_slice_header_init() failed\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n    if (!h->context_initialized) {\n\n        if (sl != h->slice_ctx) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Cannot (re-)initialize context during parallel decoding.\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n\n\n        if ((ret = get_pixel_format(h)) < 0)\n\n            return ret;\n\n        h->avctx->pix_fmt = ret;\n\n\n\n        if ((ret = h264_slice_header_init(h)) < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"h264_slice_header_init() failed\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    frame_num = get_bits(&sl->gb, sps->log2_max_frame_num);\n\n    if (!h->setup_finished)\n\n        h->poc.frame_num = frame_num;\n\n\n\n    sl->mb_mbaff       = 0;\n\n\n\n    last_pic_structure = h->picture_structure;\n\n    last_pic_droppable = h->droppable;\n\n\n\n    droppable = h->nal_ref_idc == 0;\n\n    if (sps->frame_mbs_only_flag) {\n\n        picture_structure = PICT_FRAME;\n\n    } else {\n\n        field_pic_flag = get_bits1(&sl->gb);\n\n        if (field_pic_flag) {\n\n            bottom_field_flag = get_bits1(&sl->gb);\n\n            picture_structure = PICT_TOP_FIELD + bottom_field_flag;\n\n        } else {\n\n            picture_structure = PICT_FRAME;\n\n            mb_aff_frame      = sps->mb_aff;\n\n        }\n\n    }\n\n    if (!h->setup_finished) {\n\n        h->droppable         = droppable;\n\n        h->picture_structure = picture_structure;\n\n        h->mb_aff_frame      = mb_aff_frame;\n\n    }\n\n    sl->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;\n\n\n\n    if (h->current_slice != 0) {\n\n        if (last_pic_structure != picture_structure ||\n\n            last_pic_droppable != droppable) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Changing field mode (%d -> %d) between slices is not allowed\\n\",\n\n                   last_pic_structure, h->picture_structure);\n\n            return AVERROR_INVALIDDATA;\n\n        } else if (!h->cur_pic_ptr) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"unset cur_pic_ptr on slice %d\\n\",\n\n                   h->current_slice + 1);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else {\n\n        /* Shorten frame num gaps so we don't have to allocate reference\n\n         * frames just to throw them away */\n\n        if (h->poc.frame_num != h->poc.prev_frame_num) {\n\n            int unwrap_prev_frame_num = h->poc.prev_frame_num;\n\n            int max_frame_num         = 1 << sps->log2_max_frame_num;\n\n\n\n            if (unwrap_prev_frame_num > h->poc.frame_num)\n\n                unwrap_prev_frame_num -= max_frame_num;\n\n\n\n            if ((h->poc.frame_num - unwrap_prev_frame_num) > sps->ref_frame_count) {\n\n                unwrap_prev_frame_num = (h->poc.frame_num - sps->ref_frame_count) - 1;\n\n                if (unwrap_prev_frame_num < 0)\n\n                    unwrap_prev_frame_num += max_frame_num;\n\n\n\n                h->poc.prev_frame_num = unwrap_prev_frame_num;\n\n            }\n\n        }\n\n\n\n        /* See if we have a decoded first field looking for a pair...\n\n         * Here, we're using that to see if we should mark previously\n\n         * decode frames as \"finished\".\n\n         * We have to do that before the \"dummy\" in-between frame allocation,\n\n         * since that can modify s->current_picture_ptr. */\n\n        if (h->first_field) {\n\n            assert(h->cur_pic_ptr);\n\n            assert(h->cur_pic_ptr->f->buf[0]);\n\n            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);\n\n\n\n            /* figure out if we have a complementary field pair */\n\n            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n\n                /* Previous field is unmatched. Don't display it, but let it\n\n                 * remain for reference if marked as such. */\n\n                if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {\n\n                    ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                              last_pic_structure == PICT_TOP_FIELD);\n\n                }\n\n            } else {\n\n                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {\n\n                    /* This and previous field were reference, but had\n\n                     * different frame_nums. Consider this field first in\n\n                     * pair. Throw away previous field except for reference\n\n                     * purposes. */\n\n                    if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {\n\n                        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                                  last_pic_structure == PICT_TOP_FIELD);\n\n                    }\n\n                } else {\n\n                    /* Second field in complementary pair */\n\n                    if (!((last_pic_structure   == PICT_TOP_FIELD &&\n\n                           h->picture_structure == PICT_BOTTOM_FIELD) ||\n\n                          (last_pic_structure   == PICT_BOTTOM_FIELD &&\n\n                           h->picture_structure == PICT_TOP_FIELD))) {\n\n                        av_log(h->avctx, AV_LOG_ERROR,\n\n                               \"Invalid field mode combination %d/%d\\n\",\n\n                               last_pic_structure, h->picture_structure);\n\n                        h->picture_structure = last_pic_structure;\n\n                        h->droppable         = last_pic_droppable;\n\n                        return AVERROR_INVALIDDATA;\n\n                    } else if (last_pic_droppable != h->droppable) {\n\n                        avpriv_request_sample(h->avctx,\n\n                                              \"Found reference and non-reference fields in the same frame, which\");\n\n                        h->picture_structure = last_pic_structure;\n\n                        h->droppable         = last_pic_droppable;\n\n                        return AVERROR_PATCHWELCOME;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        while (h->poc.frame_num != h->poc.prev_frame_num &&\n\n               h->poc.frame_num != (h->poc.prev_frame_num + 1) % (1 << sps->log2_max_frame_num)) {\n\n            H264Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;\n\n            av_log(h->avctx, AV_LOG_DEBUG, \"Frame num gap %d %d\\n\",\n\n                   h->poc.frame_num, h->poc.prev_frame_num);\n\n            ret = initialize_cur_frame(h);\n\n            if (ret < 0) {\n\n                h->first_field = 0;\n\n                return ret;\n\n            }\n\n\n\n            h->poc.prev_frame_num++;\n\n            h->poc.prev_frame_num        %= 1 << sps->log2_max_frame_num;\n\n            h->cur_pic_ptr->frame_num = h->poc.prev_frame_num;\n\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);\n\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);\n\n            ret = ff_generate_sliding_window_mmcos(h, 1);\n\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n                return ret;\n\n            ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n                return ret;\n\n            /* Error concealment: If a ref is missing, copy the previous ref\n\n             * in its place.\n\n             * FIXME: Avoiding a memcpy would be nice, but ref handling makes\n\n             * many assumptions about there being no actual duplicates.\n\n             * FIXME: This does not copy padding for out-of-frame motion\n\n             * vectors.  Given we are concealing a lost frame, this probably\n\n             * is not noticeable by comparison, but it should be fixed. */\n\n            if (h->short_ref_count) {\n\n                if (prev &&\n\n                    h->short_ref[0]->f->width == prev->f->width &&\n\n                    h->short_ref[0]->f->height == prev->f->height &&\n\n                    h->short_ref[0]->f->format == prev->f->format) {\n\n                    av_image_copy(h->short_ref[0]->f->data,\n\n                                  h->short_ref[0]->f->linesize,\n\n                                  (const uint8_t **)prev->f->data,\n\n                                  prev->f->linesize,\n\n                                  prev->f->format,\n\n                                  h->mb_width  * 16,\n\n                                  h->mb_height * 16);\n\n                    h->short_ref[0]->poc = prev->poc + 2;\n\n                }\n\n                h->short_ref[0]->frame_num = h->poc.prev_frame_num;\n\n            }\n\n        }\n\n\n\n        /* See if we have a decoded first field looking for a pair...\n\n         * We're using that to see whether to continue decoding in that\n\n         * frame, or to allocate a new one. */\n\n        if (h->first_field) {\n\n            assert(h->cur_pic_ptr);\n\n            assert(h->cur_pic_ptr->f->buf[0]);\n\n            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);\n\n\n\n            /* figure out if we have a complementary field pair */\n\n            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n\n                /* Previous field is unmatched. Don't display it, but let it\n\n                 * remain for reference if marked as such. */\n\n                h->cur_pic_ptr = NULL;\n\n                h->first_field = FIELD_PICTURE(h);\n\n            } else {\n\n                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {\n\n                    /* This and the previous field had different frame_nums.\n\n                     * Consider this field first in pair. Throw away previous\n\n                     * one except for reference purposes. */\n\n                    h->first_field = 1;\n\n                    h->cur_pic_ptr = NULL;\n\n                } else {\n\n                    /* Second field in complementary pair */\n\n                    h->first_field = 0;\n\n                }\n\n            }\n\n        } else {\n\n            /* Frame or first field in a potentially complementary pair */\n\n            h->first_field = FIELD_PICTURE(h);\n\n        }\n\n\n\n        if (!FIELD_PICTURE(h) || h->first_field) {\n\n            if (h264_frame_start(h) < 0) {\n\n                h->first_field = 0;\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        } else {\n\n            release_unused_pictures(h, 0);\n\n        }\n\n    }\n\n\n\n    assert(h->mb_num == h->mb_width * h->mb_height);\n\n    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||\n\n        first_mb_in_slice >= h->mb_num) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"first_mb_in_slice overflow\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    sl->resync_mb_x = sl->mb_x =  first_mb_in_slice % h->mb_width;\n\n    sl->resync_mb_y = sl->mb_y = (first_mb_in_slice / h->mb_width) <<\n\n                                 FIELD_OR_MBAFF_PICTURE(h);\n\n    if (h->picture_structure == PICT_BOTTOM_FIELD)\n\n        sl->resync_mb_y = sl->mb_y = sl->mb_y + 1;\n\n    assert(sl->mb_y < h->mb_height);\n\n\n\n    if (h->picture_structure == PICT_FRAME) {\n\n        h->curr_pic_num = h->poc.frame_num;\n\n        h->max_pic_num  = 1 << sps->log2_max_frame_num;\n\n    } else {\n\n        h->curr_pic_num = 2 * h->poc.frame_num + 1;\n\n        h->max_pic_num  = 1 << (sps->log2_max_frame_num + 1);\n\n    }\n\n\n\n    if (h->nal_unit_type == NAL_IDR_SLICE)\n\n        get_ue_golomb(&sl->gb); /* idr_pic_id */\n\n\n\n    if (sps->poc_type == 0) {\n\n        int poc_lsb = get_bits(&sl->gb, sps->log2_max_poc_lsb);\n\n\n\n        if (!h->setup_finished)\n\n            h->poc.poc_lsb = poc_lsb;\n\n\n\n        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {\n\n            int delta_poc_bottom = get_se_golomb(&sl->gb);\n\n            if (!h->setup_finished)\n\n                h->poc.delta_poc_bottom = delta_poc_bottom;\n\n        }\n\n    }\n\n\n\n    if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) {\n\n        int delta_poc = get_se_golomb(&sl->gb);\n\n\n\n        if (!h->setup_finished)\n\n            h->poc.delta_poc[0] = delta_poc;\n\n\n\n        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {\n\n            delta_poc = get_se_golomb(&sl->gb);\n\n\n\n            if (!h->setup_finished)\n\n                h->poc.delta_poc[1] = delta_poc;\n\n        }\n\n    }\n\n\n\n    if (!h->setup_finished)\n\n        ff_h264_init_poc(h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc,\n\n                         sps, &h->poc, h->picture_structure, h->nal_ref_idc);\n\n\n\n    if (pps->redundant_pic_cnt_present)\n\n        sl->redundant_pic_count = get_ue_golomb(&sl->gb);\n\n\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B)\n\n        sl->direct_spatial_mv_pred = get_bits1(&sl->gb);\n\n\n\n    ret = ff_h264_parse_ref_count(&sl->list_count, sl->ref_count,\n\n                                  &sl->gb, pps, sl->slice_type_nos,\n\n                                  h->picture_structure);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (sl->slice_type_nos != AV_PICTURE_TYPE_I) {\n\n       ret = ff_h264_decode_ref_pic_list_reordering(h, sl);\n\n       if (ret < 0) {\n\n           sl->ref_count[1] = sl->ref_count[0] = 0;\n\n           return ret;\n\n       }\n\n    }\n\n\n\n    sl->pwt.use_weight = 0;\n\n    for (i = 0; i < 2; i++) {\n\n        sl->pwt.luma_weight_flag[i]   = 0;\n\n        sl->pwt.chroma_weight_flag[i] = 0;\n\n    }\n\n    if ((pps->weighted_pred && sl->slice_type_nos == AV_PICTURE_TYPE_P) ||\n\n        (pps->weighted_bipred_idc == 1 &&\n\n         sl->slice_type_nos == AV_PICTURE_TYPE_B))\n\n        ff_h264_pred_weight_table(&sl->gb, sps, sl->ref_count,\n\n                                  sl->slice_type_nos, &sl->pwt);\n\n\n\n    // If frame-mt is enabled, only update mmco tables for the first slice\n\n    // in a field. Subsequent slices can temporarily clobber h->mmco_index\n\n    // or h->mmco, which will cause ref list mix-ups and decoding errors\n\n    // further down the line. This may break decoding if the first slice is\n\n    // corrupt, thus we only do this if frame-mt is enabled.\n\n    if (h->nal_ref_idc) {\n\n        ret = ff_h264_decode_ref_pic_marking(h, &sl->gb,\n\n                                             !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||\n\n                                             h->current_slice == 0);\n\n        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (sl->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) {\n\n        tmp = get_ue_golomb_31(&sl->gb);\n\n        if (tmp > 2) {\n\n            av_log(h->avctx, AV_LOG_ERROR, \"cabac_init_idc %u overflow\\n\", tmp);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sl->cabac_init_idc = tmp;\n\n    }\n\n\n\n    sl->last_qscale_diff = 0;\n\n    tmp = pps->init_qp + get_se_golomb(&sl->gb);\n\n    if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"QP %u out of range\\n\", tmp);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    sl->qscale       = tmp;\n\n    sl->chroma_qp[0] = get_chroma_qp(h, 0, sl->qscale);\n\n    sl->chroma_qp[1] = get_chroma_qp(h, 1, sl->qscale);\n\n    // FIXME qscale / qp ... stuff\n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP)\n\n        get_bits1(&sl->gb); /* sp_for_switch_flag */\n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP ||\n\n        sl->slice_type == AV_PICTURE_TYPE_SI)\n\n        get_se_golomb(&sl->gb); /* slice_qs_delta */\n\n\n\n    sl->deblocking_filter     = 1;\n\n    sl->slice_alpha_c0_offset = 0;\n\n    sl->slice_beta_offset     = 0;\n\n    if (pps->deblocking_filter_parameters_present) {\n\n        tmp = get_ue_golomb_31(&sl->gb);\n\n        if (tmp > 2) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"deblocking_filter_idc %u out of range\\n\", tmp);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sl->deblocking_filter = tmp;\n\n        if (sl->deblocking_filter < 2)\n\n            sl->deblocking_filter ^= 1;  // 1<->0\n\n\n\n        if (sl->deblocking_filter) {\n\n            sl->slice_alpha_c0_offset = get_se_golomb(&sl->gb) * 2;\n\n            sl->slice_beta_offset     = get_se_golomb(&sl->gb) * 2;\n\n            if (sl->slice_alpha_c0_offset >  12 ||\n\n                sl->slice_alpha_c0_offset < -12 ||\n\n                sl->slice_beta_offset >  12     ||\n\n                sl->slice_beta_offset < -12) {\n\n                av_log(h->avctx, AV_LOG_ERROR,\n\n                       \"deblocking filter parameters %d %d out of range\\n\",\n\n                       sl->slice_alpha_c0_offset, sl->slice_beta_offset);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7716, "substitutes": {"h": ["ph", "hd", "hm", "kh", "p", "html", "host", "oh", "ih", "th", "ch", "bh", "el", "wh", "d", "l", "v", "H", "ctx", "ha", "hash", "hz", "q", "zh", "w", "hi", "rh", "cur", "k", "handle", "he", "j", "self", "always", "comm", "here", "each", "dh", "ssh", "history", "ht", "hs", "b", "ah", "info", "sh", "http", "g", "gh", "e", "m", "hal", "uh", "hw", "header", "x", "hh", "hp", "c", "HH", "s", "eh", "hl", "cache", "event"], "sl": ["ph", "la", "ptr", "sc", "li", "lit", "gro", "pkg", "syn", "el", "lp", "ln", "sel", "l", "sing", "sp", "vl", "lc", "ctx", "jl", "split", "spl", "ml", "serv", "stack", "zh", "coll", "loc", "spot", "cur", "rl", "style", "cl", "handle", "ell", "fl", "dl", "kl", "so", "profile", "sd", "ssl", "Sl", "slice", "sh", "scl", "bl", "shr", "sn", "sv", "acl", "lo", "pl", "desc", "SL", "sb", "phi", "c", "settings", "isl", "ls", "s", "sle", "hl", "sql", "nl", "sol", "gl", "skip", "se", "tl", "sw"], "sps": ["spl", "ppl", "ppps", " spr", "Spl", "spps", "Spr", "spr", "Spps", " spl", "Sps", " spps", "ppr"], "pps": ["pp", "ups", "bps", "ips", "mph", "ps", "balls", "vs", "mp", "ppa", "clips", "pes", "amps", "fps", "px", "pres", "psc", "ppers", "photos", "ops", "PP", "cpp", "parts", "ppo", "hands", "eps", "Ps", "dds", "PS"], "first_mb_in_slice": ["first_mb_in__slice", "first_mb_in_sample", "first_mb_inxslice", "first_mb_in_frame", "first_mb_in_ice", "first_mb_in__sample", "first_mb_in__ice", "first_mb_inxice", "first_mb_inxframe", "first_mb_in_sequence"], "pps_id": ["ppsacbase", "ppsegname", "ppsacname", "ppsacindex", "ops_id", "opsacindex", "opsacbase", "opsacid", "ops_index", "opsacname", "pps_name", "ops_base", "ppsegindex", "pps_index", "ops_name", "ppsegbase", "pps_base", "ppsacid", "ppsegid"], "ret": ["elt", "fi", "limit", "ll", "RET", "nt", "Ret", "Return", "rets", "val", "prop", "mem", "resp", "def", "result", "pret", "std", "ref", "status", "jp", "res", "rel", "flag", "alt", "rt"], "slice_type": ["sliceetunit", "slice_color", "sliceLEtest", "service_try", "shift_unit", " slice_ype", "sliceOtype", "slice\u05bclock", " slice_no", "sliceLEaddress", "shift_name", "sliceetytry", "slice_info", " slice_name", "sliceetyty", "sliceetyype", "sliceThetype", "styleetytest", "sliceetyType", " slice_index", "sliceetytype", "star_unit", "slice_try", "slice2info", "serviceetyname", "shiftettype", "shiftetunit", "serviceetytype", "star_address", "slice_pe", "node_ype", "slice_Type", " slice_types", "slice_value", "slice_TYPE", "sliceetyTYPE", "style_test", "staritytype", "sliceOname", "style_type", "sliceetydate", "service_date", "shift_type", "slice2Type", "styleetyTYPE", "styleetyType", "slice_name", "sliceLEcolor", "slice__types", "slice_address", "shiftetname", "shiftetinfo", "slice__name", "starityaddress", "sliceLETYPE", "sliceetname", "slice_link", "staritycolor", "slice_ty", "slice___Type", "slice_no", "sliceLEtype", "star_type", "sliceOtry", "sliceetinfo", "slice\u05bccode", "slice_index", "sliceityaddress", "node_ty", "shift_info", "sliceettype", "slice_date", "ice_code", "slice_code", "slice__type", "starityunit", "slice___type", "style_Type", "sliceTheType", " slice_info", "slice___ype", "ice_lock", " slice_pe", "slice__index", "sliceThevalue", "node_test", "serviceetytry", "nodeetytest", "sliceetyname", "style_TYPE", "slice___pe", "sliceetytest", "sliceitytype", "sliceLEunit", "sliceityunit", "slice_unit", "sliceLEType", "slice_types", "nodeetyype", "sliceitycolor", "nodeetyty", "slice_test", "slice2link", "slice_lock", "star_color", "slice_ype", " slice_Type", "service_type", "serviceetydate", " slice_unit", "slice2type", "styleetytype", "slice\u05bctype", "ice_type", "service_name", "node_type", " slice_link", "sliceOdate", " slice_value", "nodeetytype"], "tmp": ["ptr", "extra", "t", "tv", "td", "temp", "tt", "ind", "ii", "v", "sp", "nt", "mp", "png", "ip", "np", "mb", "ot", "cmp", "perm", "mm", "etc", "test", "snap", "src", "pos", "vt", "img"], "i": ["init", "t", "li", "p", "f", "id", "ind", "ii", "mi", "it", "si", "j", "di", "ip", "b", "index", "ir", "ti", "ci", "m", "iat", "pi", "im", "ni", "I", "c", "n"], "last_pic_structure": ["last_pic_stitute", "last_pic_instruction", "last_pic2constitute", "last_pic2structure", "last_pic_institute", "last_pic2struction", "last_pic2constrict", "last_pic2strict", "last_pic2stitute", "last_pic_instructure", "last_pic_construction", "last_pic2constructure", "last_pic_struction", "last_pic_constitute", "last_pic_constrict", "last_pic2construction", "last_pic_instrict", "last_pic_constructure", "last_pic_district", "last_pic_distructure", "last_pic_strict", "last_pic_distitute", "last_pic_distruction"], "last_pic_droppable": ["last_pic_croppability", "last_pic_croppable", "last_pic_droppedability", "last_pic_droposabe", "last_pic_dropletable", "last_pic_cropletable", "last_pic_droppedable", "last_pic_droppedble", "last_pic_cropletble", "last_pic_cropletability", "last_pic_droposable", "last_pic_droppabe", "last_pic_croppble", "last_pic_droposability", "last_pic_croppabe", "last_pic_dropletabe", "last_pic_dropletble", "last_pic_cropletabe", "last_pic_droposble", "last_pic_droppedabe", "last_pic_droppability", "last_pic_droppble", "last_pic_dropletability"], "field_pic_flag": ["field_picture_flags", "field_picricerror", "field_picricflags", "field_picture_error", "field_picricflag", "field_pic_num", "field_picricnum", "field_pic_error", "field_picityerror", "field_picture_num", "field_pic_flags", "field_picture_flag", "field_picitynum", "field_picityflag", "field_picityflags"], "bottom_field_flag": ["bottom_fields_flag", "bottom_field_flags", "bottom_field_no", "bottom_fields_no", "bottom_field_tag", "bottom_fields_flags", "bottom_fields_tag"], "frame_num": ["framemodnumber", " frame_ref", "frame_number", " frame_number", "framemodnum", " frame_id", "frame_ref", "frame_id", "framemodid", "framemodref"], "droppable": ["droploadable", "cropletable", "drooppatable", "drooppabe", "droppabe", "dropletible", "dropletabe", "cropletble", "droposworthy", "Dropletible", "droploadible", "droposble", "dropletble", "dropletworthy", "Droppible", "droploadworthy", "droppible", "croppble", "Droppatable", "droppble", "droposible", "droppworthy", "Dropletatable", "Dropletable", "croppible", "droposable", "drooppable", "Droppabe", "dropletable", "droploadble", "cropletworthy", "croppable", "droppatable", "drooppible", "cropletible", "droposatable", "Dropletabe", "dropletatable", "Droppable", "croppworthy", "droposabe"], "picture_structure": ["picture_sturation", "picture_constructure", "picture_estruction", "picture_struction", "picture_destitution", "picture_restructure", "picture_estructure", "picture_destructure", "picture_estitution", "picture_resturation", "picture_destruction", "picture_restruction", "picture_stitution", "picture_constype", "picture_stitute", "picture_strype", "picture_destitute", "picture_constitute", "picture_estitute", "picture_construction", "picture_stype", "picture_restype", "picture_struration", "picture_strructure", "picture_strruction", "picture_constitution", "picture_consturation"]}}
{"project": "FFmpeg", "commit_id": "be4dfbf7b71e44a53ca8da882a081e35ea134c83", "target": 0, "func": "int ffurl_shutdown(URLContext *h, int flags)\n\n{\n\n    if (!h->prot->url_shutdown)\n\n        return AVERROR(EINVAL);\n\n    return h->prot->url_shutdown(h, flags);\n\n}\n", "idx": 7729, "substitutes": {"h": ["ph", "hd", "hm", "pp", "kh", "p", "host", "oh", "ih", "th", "ch", "bh", "f", " inh", "H", "hash", "hz", "q", "rh", "handle", "he", "here", "j", "dh", "history", "hs", "ht", "hr", "ah", "sh", "has", "m", "hal", "uh", "help", "hw", "hh", "hp", "c", "ash", "eh", "hl", "z"], "flags": ["doms", "uts", "FO", "properties", "atts", "types", " Flags", "frames", "files", "locks", "options", "fps", "FLAG", "posts", "kind", "ensions", "Flags", "styles", "lag", "fee", "heads", "tags", "ids", "faces", "ops", "members", "vals", "bits", "flag", "features", "alf", "ants", "parts", "settings", "wcs", "pages", "ats", "acts", "weights", "ags"]}}
{"project": "qemu", "commit_id": "049a9f7b946fe1d3ff97127f8905881dbb78cb00", "target": 1, "func": "static void i82378_init(DeviceState *dev, I82378State *s)\n\n{\n\n    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, \"isa.0\"));\n\n    ISADevice *pit;\n\n    qemu_irq *out0_irq;\n\n\n\n    /* This device has:\n\n       2 82C59 (irq)\n\n       1 82C54 (pit)\n\n       2 82C37 (dma)\n\n       NMI\n\n       Utility Bus Support Registers\n\n\n\n       All devices accept byte access only, except timer\n\n     */\n\n\n\n    qdev_init_gpio_out(dev, s->out, 2);\n\n    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);\n\n\n\n    /* Workaround the fact that i8259 is not qdev'ified... */\n\n    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);\n\n\n\n    /* 2 82C59 (irq) */\n\n    s->i8259 = i8259_init(isabus, *out0_irq);\n\n    isa_bus_irqs(isabus, s->i8259);\n\n\n\n    /* 1 82C54 (pit) */\n\n    pit = pit_init(isabus, 0x40, 0, NULL);\n\n\n\n    /* speaker */\n\n    pcspk_init(isabus, pit);\n\n\n\n    /* 2 82C37 (dma) */\n\n    DMA_init(1, &s->out[1]);\n\n    isa_create_simple(isabus, \"i82374\");\n\n\n\n    /* timer */\n\n    isa_create_simple(isabus, \"mc146818rtc\");\n\n}\n", "idx": 7732, "substitutes": {"dev": ["t", "os", "util", "p", "de", "conn", "priv", "debug", "d", "v", "att", "data", "Device", "nt", "spec", "app", "Dev", "ad", "scan", "serv", "w", "pro", "ve", "o", "device", "pad", "bus", "adv", "sd", "mem", "proc", "def", "DEV", "ver", "g", "cam", "boot", "test", "hw", "dis", "tech", "des", "sw", "go", "ev", "av", "cmd", "dem"], "s": ["out", "states", "t", "os", "S", "p", "sand", "ds", "south", "is", "a", "d", "v", "sing", "r", "ps", "spec", "vs", "ss", "ports", "events", "aws", "o", "comm", "changes", "in", "bs", "i", "js", "ns", "sd", "ssl", "b", "sq", "g", "ses", "sts", "rs", "gs", "ts", "e", "stats", "fs", "its", "sv", "cs", "ims", "sb", "c", "settings", "ls", "n", "ats", "sys", "params", "eps", "sw", "services"], "isabus": [" isaws", "isalis", "issasar", "risab", "issalis", "risatis", "isabytes", "isasar", "isatis", "isabi", "misatus", "misews", " isabytes", "issabol", "risabi", " isorus", " isalis", "isorus", "itsabytes", " isabis", "issabytes", "isatus", " isews", "isews", " isab", "risabus", "itsasar", "itsaws", "risabis", "isab", "issab", "issaws", "misabis", "risabol", "risaws", " isatus", " isatis", "isaws", "risatus", "issabus", "risews", "risalis", "isabol", "risorus", "misabus", " isabi", "risasar", "issatis", "itsabus", "issorus", " isabol", "isabis", "issabi", " isasar"], "pit": ["pet", "pir", "vp", "pot", "p", "nat", "fi", "pert", " Pit", "lp", "pai", "ped", "rot", "pei", "pc", "it", "hat", "itch", "phy", "pa", "prot", "pt", "mat", "po", "press", "pocket", "pr", "tip", "jp", "pat", "pin", "pri", "pi", "trap", "pl", "jit", "rit", "kit", "pac", "cas", "kat"], "out0_irq": ["out0_iraqs", "out0_ireqi", "out0_prqs", "out0_mirqi", "out0_drqs", "out0_ireq", "out0_pirqu", "out0_iraqi", "out0__iraqs", "out0_pirz", "out0_pirue", "out0__iraq", "out0_drue", "out0_irequ", "out0_irQ", "out0_irqi", "out0__irqi", "out0_irqs", "out0_drq", "out0_prue", "out0_pirqs", "out0_mirqs", "out0_irue", "out0__iraqi", "out0__iraquest", "out0_iraq", "out0__irquest", "out0_irz", "out0_mirquest", "out0_mirqu", "out0_irquest", "out0_ireqs", "out0_prz", "out0_irequest", "out0__irqs", "out0_pirQ", "out0__irq", "out0_iraquest", "out0_drz", "out0_mirQ", "out0_ireQ", "out0_pirq", "out0_prq", "out0_mirq", "out0_irqu"]}}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void realview_init(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    qemu_irq *pic;\n\n    void *scsi_hba;\n\n    PCIBus *pci_bus;\n\n    NICInfo *nd;\n\n    int n;\n\n    int done_smc = 0;\n\n    qemu_irq cpu_irq[4];\n\n    int ncpu;\n\n    int index;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    /* FIXME: obey smp_cpus.  */\n\n    if (strcmp(cpu_model, \"arm11mpcore\") == 0) {\n\n        ncpu = 4;\n\n    } else {\n\n        ncpu = 1;\n\n    }\n\n\n\n    for (n = 0; n < ncpu; n++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        pic = arm_pic_init_cpu(env);\n\n        cpu_irq[n] = pic[ARM_PIC_CPU_IRQ];\n\n        if (n > 0) {\n\n            /* Set entry point for secondary CPUs.  This assumes we're using\n\n               the init code from arm_boot.c.  Real hardware resets all CPUs\n\n               the same.  */\n\n            env->regs[15] = 0x80000000;\n\n        }\n\n    }\n\n\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero.  */\n\n    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n\n\n\n    arm_sysctl_init(0x10000000, 0xc1400400);\n\n\n\n    if (ncpu == 1) {\n\n        /* ??? The documentation says GIC1 is nFIQ and either GIC2 or GIC3\n\n           is nIRQ (there are inconsistencies).  However Linux 2.6.17 expects\n\n           GIC1 to be nIRQ and ignores all the others, so do that for now.  */\n\n        pic = realview_gic_init(0x10040000, cpu_irq[0]);\n\n    } else {\n\n        pic = mpcore_irq_init(cpu_irq);\n\n    }\n\n\n\n    pl050_init(0x10006000, pic[20], 0);\n\n    pl050_init(0x10007000, pic[21], 1);\n\n\n\n    pl011_init(0x10009000, pic[12], serial_hds[0], PL011_ARM);\n\n    pl011_init(0x1000a000, pic[13], serial_hds[1], PL011_ARM);\n\n    pl011_init(0x1000b000, pic[14], serial_hds[2], PL011_ARM);\n\n    pl011_init(0x1000c000, pic[15], serial_hds[3], PL011_ARM);\n\n\n\n    /* DMA controller is optional, apparently.  */\n\n    pl080_init(0x10030000, pic[24], 2);\n\n\n\n    sp804_init(0x10011000, pic[4]);\n\n    sp804_init(0x10012000, pic[5]);\n\n\n\n    pl110_init(ds, 0x10020000, pic[23], 1);\n\n\n\n    index = drive_get_index(IF_SD, 0, 0);\n\n    if (index == -1) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital card\\n\");\n\n        exit(1);\n\n    }\n\n    pl181_init(0x10005000, drives_table[index].bdrv, pic[17], pic[18]);\n\n\n\n    pl031_init(0x10017000, pic[10]);\n\n\n\n    pci_bus = pci_vpb_init(pic, 48, 1);\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, 3, -1);\n\n    }\n\n    if (drive_get_max_bus(IF_SCSI) > 0) {\n\n        fprintf(stderr, \"qemu: too many SCSI bus\\n\");\n\n        exit(1);\n\n    }\n\n    scsi_hba = lsi_scsi_init(pci_bus, -1);\n\n    for (n = 0; n < LSI_MAX_DEVS; n++) {\n\n        index = drive_get_index(IF_SCSI, 0, n);\n\n        if (index == -1)\n\n            continue;\n\n        lsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n);\n\n    }\n\n    for(n = 0; n < nb_nics; n++) {\n\n        nd = &nd_table[n];\n\n        if (!nd->model)\n\n            nd->model = done_smc ? \"rtl8139\" : \"smc91c111\";\n\n        if (strcmp(nd->model, \"smc91c111\") == 0) {\n\n            smc91c111_init(nd, 0x4e000000, pic[28]);\n\n        } else {\n\n            pci_nic_init(pci_bus, nd, -1);\n\n        }\n\n    }\n\n\n\n    /* Memory map for RealView Emulation Baseboard:  */\n\n    /* 0x10000000 System registers.  */\n\n    /*  0x10001000 System controller.  */\n\n    /*  0x10002000 Two-Wire Serial Bus.  */\n\n    /* 0x10003000 Reserved.  */\n\n    /*  0x10004000 AACI.  */\n\n    /*  0x10005000 MCI.  */\n\n    /* 0x10006000 KMI0.  */\n\n    /* 0x10007000 KMI1.  */\n\n    /*  0x10008000 Character LCD.  */\n\n    /* 0x10009000 UART0.  */\n\n    /* 0x1000a000 UART1.  */\n\n    /* 0x1000b000 UART2.  */\n\n    /* 0x1000c000 UART3.  */\n\n    /*  0x1000d000 SSPI.  */\n\n    /*  0x1000e000 SCI.  */\n\n    /* 0x1000f000 Reserved.  */\n\n    /*  0x10010000 Watchdog.  */\n\n    /* 0x10011000 Timer 0+1.  */\n\n    /* 0x10012000 Timer 2+3.  */\n\n    /*  0x10013000 GPIO 0.  */\n\n    /*  0x10014000 GPIO 1.  */\n\n    /*  0x10015000 GPIO 2.  */\n\n    /* 0x10016000 Reserved.  */\n\n    /* 0x10017000 RTC.  */\n\n    /*  0x10018000 DMC.  */\n\n    /*  0x10019000 PCI controller config.  */\n\n    /*  0x10020000 CLCD.  */\n\n    /* 0x10030000 DMA Controller.  */\n\n    /* 0x10040000 GIC1.  */\n\n    /* 0x10050000 GIC2.  */\n\n    /* 0x10060000 GIC3.  */\n\n    /* 0x10070000 GIC4.  */\n\n    /*  0x10080000 SMC.  */\n\n    /*  0x40000000 NOR flash.  */\n\n    /*  0x44000000 DoC flash.  */\n\n    /*  0x48000000 SRAM.  */\n\n    /*  0x4c000000 Configuration flash.  */\n\n    /* 0x4e000000 Ethernet.  */\n\n    /*  0x4f000000 USB.  */\n\n    /*  0x50000000 PISMO.  */\n\n    /*  0x54000000 PISMO.  */\n\n    /*  0x58000000 PISMO.  */\n\n    /*  0x5c000000 PISMO.  */\n\n    /* 0x60000000 PCI.  */\n\n    /* 0x61000000 PCI Self Config.  */\n\n    /* 0x62000000 PCI Config.  */\n\n    /* 0x63000000 PCI IO.  */\n\n    /* 0x64000000 PCI mem 0.  */\n\n    /* 0x68000000 PCI mem 1.  */\n\n    /* 0x6c000000 PCI mem 2.  */\n\n\n\n    realview_binfo.ram_size = ram_size;\n\n    realview_binfo.kernel_filename = kernel_filename;\n\n    realview_binfo.kernel_cmdline = kernel_cmdline;\n\n    realview_binfo.initrd_filename = initrd_filename;\n\n    realview_binfo.nb_cpus = ncpu;\n\n    arm_load_kernel(first_cpu, &realview_binfo);\n\n\n\n    /* ??? Hack to map an additional page of ram for the secondary CPU\n\n       startup code.  I guess this works on real hardware because the\n\n       BootROM happens to be in ROM/flash or in memory that isn't clobbered\n\n       until after Linux boots the secondary CPUs.  */\n\n    cpu_register_physical_memory(0x80000000, 0x1000, IO_MEM_RAM + ram_size);\n\n}\n", "idx": 7749, "substitutes": {"ram_size": [" ram_name", "ram_group", "mem_group", "ram6name", "ram6size", "ram6addr", "mem_size", "ram_SIZE", "mem_addr", "ram_addr", "ram6group", "ram_name", "mem_name", " ram_SIZE"], "vga_ram_size": ["vga_ram_name", "vga_ram_SIZE", "vga_rom_size", "vga_rom_SIZE", "vga_rom_name"], "boot_device": ["cpu_dev", "bootdevdev", "cpu_serial", "cpu_device", "bootdevgroup", "boot_group", "bootdevserial", "bootdevdevice", "cpu_group", "boot_serial", "boot_dev"], "ds": ["dt", "de", "d", "vs", "ps", "dd", "eds", "ks", "Ds", "si", "di", "ys", "dh", "bs", "sd", "dat", "pers", "rs", "vd", "da", "du", "pd", "ck", "db", "cs", "des", "sys", "eps"], "kernel_filename": ["kernel__filename", "kernel__file", "kernel_fn", "proc_filename", "proc_fn", "proc__filename", "kernel___filename", "proc__fn", "kernel_file", "kernel___fn", "proc__file", "proc_file", "kernel__module", "proc__module", "kernel__fn", "kernel___file", "kernel___module", "kernel_module", "proc_module"], "kernel_cmdline": ["kernel_submode", "kernel_commandset", "kernel_commandmode", "kernel_cmdmode", "kernel_subset", "kernel_subline", "kernel_catmode", "kernel_catset", "kernel_cmdset", "kernel_catline", "kernel_commandline"], "initrd_filename": ["initrd_folder", "initrmmopfolder", "initrm_file", "initrmmopfilename", "initrdmopfilename", "initrdmopfolder", "initrmmopname", "initrd_name", "initrd_file", "initrdmopname", "initrm_filename", "initrdmopfile", "initrm_folder", "initrmmopfile", "initrm_name"], "cpu_model": ["cpu_value", " cpu_mode", "CPU_models", "cpu2mode", "pu_Model", "pu_mode", "cpu2Model", "CPU_brand", "pu_model", "cpu2model", "cpu_mode", " cpu_value", "cpu_option", "CPU_mode", "cpu_link", "CPU_type", "cpu_Model", "cpu_brand", "cpu_lock", "CPU_model", "cpu_models", "pu_link", "cpu_type", " cpu_option", "cpu2type", "CPU_Model", "pu_lock"], "env": ["py", "ptr", "eas", "sc", "vp", "ei", "et", "dev", "environment", "cv", "tmp", "conn", "eu", "esc", "ped", "v", "org", "sp", "ec", "vs", "ctx", "eric", "ps", "policy", "eg", "em", "vt", "obj", "server", "si", "en", "ew", "nv", "eng", "anc", "ee", "proc", "po", "ah", "manager", "buf", "net", "eni", "pb", "cap", "enc", "jp", "e", "cam", "db", "end", "esp", "pen", "window", "qt", "ef", "chart", "pe", "context", "shell", "er", "ev"], "pic": ["py", "sc", "pick", "pp", "doc", "phys", "p", "fn", "syn", "ig", "lp", "sac", "iac", "sp", "arr", "ps", "eric", "ctx", "pipe", "pc", "ic", "ping", "Pic", "ics", "txt", "wp", "str", "spr", "Picture", "pa", "pins", "png", "style", "icc", "rip", "fc", "anc", "proc", "pres", "par", "pn", "pol", "pb", "script", "pr", "cap", "xi", "jpg", "img", "jp", "capt", "cam", "pat", "pin", "res", "pse", "pen", "Pict", "pi", "parse", "pl", "ac", "fig", "shot", "nic", "magic", "pac", "virt", "picture", "tick", "pan", "lib", "pict"], "scsi_hba": ["scsi_bda", "scsi_lbd", "scsi_lbc", "scsi_lba", "scsi_bba", "scsi_hbc", "scsi_bbc", "scsi_pbd", "scsi_hda", "scsi_hbd", "scsi_pda", "scsi_bbd", "scsi_lda", "scsi_pbc", "scsi_pba"], "pci_bus": ["pci_us", "pci__Bus", "pio_bus", "pci_Bus", "pci_box", "pio_box", "pci__box", "pio_Bus", "pci__us", "pio_us", "pci__bus"], "nd": ["ng", "fn", "nb", "ped", "ind", "nn", " ni", "ini", "nt", "fd", "dd", "inn", "ld", "nv", "st", "ne", "dn", "ND", "ns", "wn", "md", "und", "vd", "sn", "ck", "na", "ni", " din", "inf"], "n": ["ng", "t", "p", "fn", "no", "el", "conn", "ln", "ll", "d", "l", "v", "nn", "nt", "r", "yn", "note", "con", "nor", "w", "node", "en", "k", "j", "ne", "cn", "o", "nm", "dn", "i", "ns", "nu", "nan", "np", "gn", "name", "an", "g", "nr", "mn", "network", "y", "len", "rn", "sn", "nw", "un", "m", "na", "e", "N", "all", "ni", "names", "num", "x", "count", "number", "c", "nl", "s", "z", "nb", "nc"], "cpu_irq": ["cpu_ireqs", "cpu_ibrues", "cpu_iraqs", "cpu_ibrch", "cpu__irq", "cpu__irues", "cpu_irQ", "cpu_pirch", "cpu__ireqs", "cpu_irues", "cpu_pirqs", "cpu_irqs", "cpu_mirqs", "cpu_ireq", "cpu_ibrQ", "cpu_irech", "cpu__ireues", "cpu_mirq", "cpu_ireues", "cpu_irque", "cpu_mirch", "cpu_pirque", "cpu__irqs", "cpu_ibrqq", "cpu__irequ", "cpu__ireq", "cpu_arqs", "cpu_mirQ", "cpu_arque", "cpu_irqq", "cpu_ireQ", "cpu_iraq", "cpu_pirq", "cpu_iraues", "cpu_ibrqu", "cpu_irch", "cpu_ireque", "cpu_irequ", "cpu_lrq", "cpu_arq", "cpu_pirqq", "cpu__irque", "cpu_ibrqs", "cpu__ireque", "cpu_iraqu", "cpu_lrch", "cpu_lrqs", "cpu_lrqq", "cpu__irqu", "cpu_ibrq", "cpu_irqu"], "ncpu": ["NCcpu", "cgpu", "nvpu", "cncp", "niccpu", "nicuda", "nccore", "NCpu", "npuda", "mcpy", "cnrow", "npcpu", "nccp", "cnPU", "cnpu", "nicPU", "nvcp", "gnrow", "gncpu", "cnpc", "cnuda", "cur", "ccore", "nccpu", "gncp", "ncPU", "nicpu", "NCuda", "nvcpu", "ncur", "cncore", "nvrow", "NCPU", "ccpu", "gnpu", "ncpc", "cuda", "cpu", "NCpc", "ncgpu", "ncrow", "NCgpu", "NCpy", "cncpu", "cnur", "cPU", "mcgpu", "NCcore", "cngpu", "ncuda", "ncpy", "mcuda", "nppu", "npPU", "cnpy", "mcur", "mcpu", "mcpc"], "index": ["order", "f", "id", "ind", "ii", "nn", "thread", "error", "ion", "si", "axis", "di", "cycle", "location", "size", "i", "link", "name", "type", "Index", "len", "loop", "num", "number", "count", "x", "pos", "total"]}}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "QString *qstring_from_substr(const char *str, int start, int end)\n\n{\n\n    QString *qstring;\n\n\n\n    qstring = g_malloc(sizeof(*qstring));\n\n\n\n    qstring->length = end - start + 1;\n\n    qstring->capacity = qstring->length;\n\n\n\n    qstring->string = g_malloc(qstring->capacity + 1);\n\n    memcpy(qstring->string, str + start, qstring->length);\n\n    qstring->string[qstring->length] = 0;\n\n\n\n    QOBJECT_INIT(qstring, &qstring_type);\n\n\n\n    return qstring;\n\n}\n", "idx": 7754, "substitutes": {"str": ["dr", "fr", "ring", "p", "Str", "ctr", "ind", "arr", "r", "sp", "ix", "obj", "w", "cur", "st", "j", "br", "i", "name", "begin", "buf", "g", "gap", "rest", "len", "enc", "e", "res", "star", "tr", "STR", "gr", "c", "from", "End", "s", "pos", "next", "add"], "start": ["get", "init", "entry", "starting", "p", "inter", "old", "art", "use", "origin", "ind", "id", "r", "length", "it", "pre", "offset", "ish", "req", "st", "pad", "starter", "in", "before", "size", "pointer", "stop", "index", "begin", "shift", "step", "range", "wind", "rest", "Start", "iter", "addr", "part", "first", "from", "pos", "n", "next", "started"], "end": ["pend", "bound", "max", "ended", "d", "id", "ind", "length", "to", "ad", "hend", "append", "send", "offset", "set", "en", "ff", "ue", "st", "pad", "eng", "size", "stop", "begin", "due", "rest", "mid", "e", "END", "ending", "ent", "num", "and", "nd", "End", "add", "ension", "last"], "qstring": ["quobject", " qobject", "sqdata", "qresource", "qualobject", "questarray", "sqsequence", "eqfile", "qString", "qfile", "sqarray", "qubuffer", "eqsite", "dqString", "qudriver", "eqstrings", "qring", "qsite", "qudata", "qunumber", "qqstring", "dqobject", "qsection", "sqstr", "qualString", "qufile", "eqsequence", "qarray", "qqdata", "qustr", " qstr", " qsystem", "qustring", "qqbuffer", "questring", "qsystem", "queststr", "qualstring", "eqresource", " qnumber", "sqstring", "eqnumber", "querserver", "eqservice", "questcomment", "sqString", "dqring", "qualnumber", "qobject", "requarray", "eqdriver", "qsequence", "dqstr", " qring", "qnumber", "qqnumber", "querfile", "qualstr", "dqnumber", "requnumber", "sqsection", "requsection", "requdata", " qcomment", "sqring", "qstr", "sqcomment", "querstring", "qucomment", "qqsequence", "requfilename", "questfilename", "sqobject", "aqdriver", "questsystem", "sqfile", " qbuffer", "eqcomment", "qustrings", "sqstrings", "sqfilename", "eqserver", "qservice", "requsequence", "quernumber", "qusite", "requcomment", "sqresource", "qdata", "questnumber", "quresource", "sqnumber", "sqsite", "requfile", "aqstring", "qbuffer", "sqsystem", "qdriver", "qstrings", "qserver", "qqcomment", "qqstrings", "dqcomment", "qualcomment", "requresource", "questdata", " qstrings", "qqobject", "queststring", "eqstring", "aqresource", "qusection", "dqstring", " qsequence", "qqstr", "requstring", "qfilename", "qualring", "aqservice", "qusequence", "quservice", "quserver", "qcomment"]}}
{"project": "qemu", "commit_id": "12d69ac03b45156356b240424623719f15d8143e", "target": 0, "func": "static void test_source_wait_event_notifier(void)\n\n{\n\n    EventNotifierTestData data = { .n = 0, .active = 1 };\n\n    event_notifier_init(&data.e, false);\n\n    aio_set_event_notifier(ctx, &data.e, event_ready_cb);\n\n    g_assert(g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 0);\n\n    g_assert_cmpint(data.active, ==, 1);\n\n\n\n    event_notifier_set(&data.e);\n\n    g_assert(g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    while (g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    aio_set_event_notifier(ctx, &data.e, NULL);\n\n    while (g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n\n\n    event_notifier_cleanup(&data.e);\n\n}\n", "idx": 7761, "substitutes": {}}
{"project": "qemu", "commit_id": "f9749f28b78be36471d3d0f5d4b6eed030f8942e", "target": 0, "func": "static int coroutine_fn is_allocated_base(BlockDriverState *top,\n\n                                          BlockDriverState *base,\n\n                                          int64_t sector_num,\n\n                                          int nb_sectors, int *pnum)\n\n{\n\n    BlockDriverState *intermediate;\n\n    int ret, n;\n\n\n\n    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);\n\n    if (ret) {\n\n        *pnum = n;\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * Is the unallocated chunk [sector_num, n] also\n\n     * unallocated between base and top?\n\n     */\n\n    intermediate = top->backing_hd;\n\n\n\n    while (intermediate != base) {\n\n        int pnum_inter;\n\n\n\n        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,\n\n                                   &pnum_inter);\n\n        if (ret < 0) {\n\n            return ret;\n\n        } else if (ret) {\n\n            *pnum = pnum_inter;\n\n            return 0;\n\n        }\n\n\n\n        /*\n\n         * [sector_num, nb_sectors] is unallocated on top but intermediate\n\n         * might have\n\n         *\n\n         * [sector_num+x, nr_sectors] allocated.\n\n         */\n\n        if (n > pnum_inter) {\n\n            n = pnum_inter;\n\n        }\n\n\n\n        intermediate = intermediate->backing_hd;\n\n    }\n\n\n\n    *pnum = n;\n\n    return 1;\n\n}\n", "idx": 7762, "substitutes": {"top": ["tools", "t", "master", "p", "primary", "Top", "th", "upper", "tmp", "origin", "python", "high", "to", "super", "parent", "prefix", "node", "most", "h", "soc", "tops", "root", "state", "TOP", "sys", "at", "onet", "highest", "best", "new", "tp", "las", "tor", "target", "prototype", "bottom", "bit", "table", "global", "test", "part", "title", "x", "first", "above", "localhost", "local", "bot", "template"], "base": ["init", "disabled", "reset", "bound", "balance", "tmp", "bt", "real", "to", "super", "bas", "check", "server", "iso", "b", "root", "buffer", "area", "Base", "based", "bottom", "local", "bit", "boot", "bare", "initial", "part", "shadow", "basic", "secondary", "back", "kit", "block", "start", "binding", "out", "bot"], "sector_num": ["sector2mon", " sector_snap", " sector_um", "sectorLnom", " sector_mon", "sector_prim", "sectorNamenum", "seat_prim", "sector7num", "sector7NUM", "sector_snap", "sectorNameum", "sector_NUM", "sector_nom", "sectorLmon", " sector_nom", "sectoritynum", "sectoritynu", "sectorLnum", "sector_mon", "sector7prim", "sector2um", "sectorNamemon", " sector_begin", "sectorityNUM", "sector_begin", "sector2num", "seat_nu", "seat_num", "sectorNamebegin", "sectorityprim", "sector_nu", "sector2begin", "seat_NUM", "sectorLsnap", "sector_um", "sector7nu"], "nb_sectors": ["nb_megments", "nb_seriers", "nb_esriers", "nb_seirs", "nb_bectors", "nb_teitors", "nb_vectors", "nb_seors", "nb_suctors", "nb_syurers", "nb_vegments", "nb_meors", "nb_sugments", "nb_seurers", "nb_seitors", "nb_bevers", "nb_suirs", "nb_beriers", "nb_syors", "nb_beors", "nb_tectors", "nb_veriers", "nb_veitors", "nb_esctors", "nb_severs", "nb_teors", "nb_veors", "nb_teurers", "nb_syctors", "nb_meirs", "nb_suors", "nb_esors", "nb_veirs", "nb_esvers", "nb_mectors", "nb_segments", "nb_veurers", "nb_syitors", "nb_vevers"], "pnum": ["penUM", "gnum", "pannum", "panum", "publicUM", "pennum", "kinom", "panenum", "nnnum", "pnUM", "kinUM", "pngnum", "kinnum", "gnnum", "wnnum", "nnenum", "nnumer", "wnum", "wnumn", "pnenum", "pngUM", "pnumn", "pnom", "penumn", "panUM", "penum", "panom", "pnumer", "pngum", "publicum", "kinumn", "publicnum", "publicmun", "gnumer", "kinum", "wnUM", "kinenum", "gnom", "pnnum", "gnenum", "pnmun", "nnum", "panumer", "panmun", "pngmun"], "intermediate": ["intceptor", "imior", "interceptor", "iterval", "innermediate", "trmediate", "innerceptor", "neior", "Intermediate", "nemedi", "innerior", "nemediate", "intval", "INTERceptor", "preval", "internalior", "interior", "interility", "trval", " interility", "immediate", "immedi", "Interval", "Intermedi", "preior", "itermediate", "intermedi", "trmedi", "INTERval", "INTERmediate", "premediate", "tramediate", "trility", "iterceptor", "itermedi", "premedi", "traior", "interval", " interceptor", "Interior", "INTERmedi", "internalmedi", "intmediate", "internalval", "internalmediate", "neceptor", "iterior", "iterility", "INTERior", "traceptor", "intmedi", "imval", " intermedi", " interval", "innermedi", "tramedi"], "ret": ["deg", "gt", "verified", "RET", "nt", "it", "txt", "ben", "ry", "rem", "gc", "pret", "iter", "det", "final", "rier", "cmd", "git", "inter", "success", "arg", "re", "j", "sat", "mt", "def", "zero", "ref", "len", "this", "try", "ert", "flag", "num", "backed", "ount", "reset", "nil", "f", "att", "ft", "rets", "ary", "rest", "repl", "print", " RET", "bool", "alt", "virt", "rt", "reg", "out", "t", "elt", "lit", "nat", "dt", "ll", "cat", "Ret", "red", "val", "false", "resp", "result", "rev", "status", "jp", "rect", "res", "utils", "tr", "ter", " Ret", "back"], "n": ["t", "p", "nat", "fn", "ln", "d", "l", "v", "nn", "nt", "r", "z", "nor", "en", "nv", "j", "h", "ne", "cn", "o", "dn", "nm", "i", "ns", "nu", "nan", "np", "ann", "nr", "g", "pn", "mn", "non", "len", "sn", "un", "m", "na", "N", "ni", "num", "number", "x", "nd", "c", "nl", "nb", "nc", "tn"], "pnum_inter": ["pnumer_ver", "pnumer_Inter", "pnenum_inst", "pnump_ref", "pnum_war", "pnum____iter", "pnum_val", "pnum_inner", "pnum__iter", "pnum___pair", "pnump_iter", "pnum__Inter", "pnum_con", "pnum___ref", "pnum_adr", "pnum2pair", "pnumer_inter", "pnenum_int", "pnum__inter", "pnump___inter", "pnhum_war", "pnum_Inter", "pnump___iter", "pnum2inter", "pnhum_iter", "pnumer_val", "pnum___iter", "pnhum_inter", "pnum_iter", "pnenum_inner", "pnum____adr", "pnum_pair", "pnumer_con", "pnum2ref", "pnump___ref", "pnump_inter", "pnum_int", "pnum____inter", "pnump_pair", "pnhum_adr", "pnum_ref", "pnum___inter", "pnumer_iter", "pnump___pair", "pnum_ver", "pnum_inst", "pnenum_inter", "pnum2iter", "pnum____war"]}}
{"project": "qemu", "commit_id": "c6bf0f7ffa90c720377eb6bddd27037041acbc5b", "target": 0, "func": "static DisplayType select_display(const char *p)\n\n{\n\n    Error *err = NULL;\n\n    const char *opts;\n\n    DisplayType display = DT_DEFAULT;\n\n\n\n    if (strstart(p, \"sdl\", &opts)) {\n\n#ifdef CONFIG_SDL\n\n        display = DT_SDL;\n\n        while (*opts) {\n\n            const char *nextopt;\n\n\n\n            if (strstart(opts, \",frame=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    no_frame = 0;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    no_frame = 1;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",alt_grab=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    alt_grab = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    alt_grab = 0;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",ctrl_grab=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    ctrl_grab = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    ctrl_grab = 0;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",window_close=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    no_quit = 0;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    no_quit = 1;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",gl=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    request_opengl = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    request_opengl = 0;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else {\n\n            invalid_sdl_args:\n\n                fprintf(stderr, \"Invalid SDL option string: %s\\n\", p);\n\n                exit(1);\n\n            }\n\n            opts = nextopt;\n\n        }\n\n#else\n\n        fprintf(stderr, \"SDL support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"vnc\", &opts)) {\n\n#ifdef CONFIG_VNC\n\n        if (*opts == '=') {\n\n            if (vnc_parse(opts + 1, &err) == NULL) {\n\n                error_report_err(err);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            fprintf(stderr, \"VNC requires a display argument vnc=<display>\\n\");\n\n            exit(1);\n\n        }\n\n#else\n\n        fprintf(stderr, \"VNC support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"curses\", &opts)) {\n\n#ifdef CONFIG_CURSES\n\n        display = DT_CURSES;\n\n#else\n\n        fprintf(stderr, \"Curses support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"gtk\", &opts)) {\n\n#ifdef CONFIG_GTK\n\n        display = DT_GTK;\n\n        while (*opts) {\n\n            const char *nextopt;\n\n\n\n            if (strstart(opts, \",grab_on_hover=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    grab_on_hover = true;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    grab_on_hover = false;\n\n                } else {\n\n                    goto invalid_gtk_args;\n\n                }\n\n            } else if (strstart(opts, \",gl=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    request_opengl = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    request_opengl = 0;\n\n                } else {\n\n                    goto invalid_gtk_args;\n\n                }\n\n            } else {\n\n            invalid_gtk_args:\n\n                fprintf(stderr, \"Invalid GTK option string: %s\\n\", p);\n\n                exit(1);\n\n            }\n\n            opts = nextopt;\n\n        }\n\n#else\n\n        fprintf(stderr, \"GTK support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"none\", &opts)) {\n\n        display = DT_NONE;\n\n    } else {\n\n        fprintf(stderr, \"Unknown display type: %s\\n\", p);\n\n        exit(1);\n\n    }\n\n\n\n    return display;\n\n}\n", "idx": 7766, "substitutes": {"p": ["vp", "pp", "t", "cp", "lp", "f", "d", "l", "v", "sp", "r", "ps", "pc", "q", "wp", "w", "pro", "i", "ap", "ip", "np", "b", "par", "g", "pb", "pr", "y", "fp", "jp", "pat", "m", "P", "bp", "c", "s", "n"], "err": ["Er", "conf", "ch", "kr", "arr", "r", "rr", "error", "msg", "txt", "cb", "obj", "str", "cur", "die", "cr", "rb", "proc", "usr", "buf", "cfg", "res", "cli", "Error", "aaa", "er", "ev", "cmd"], "opts": [" opats", "copters", "oppths", "opsrs", "opms", "opstions", "copbs", "optvals", "Oprets", " opods", "opter", "opste", "opsmits", "Opcs", "obt", "opsbs", "Opps", "opjs", " opps", " opters", "options", " opops", "opws", "opsws", "operjs", "optt", "argts", " opths", "expergs", "opgt", "opds", "opins", "opttes", "OPps", "opt", "OpTS", "imts", " oprs", "Opws", "optins", "coptx", "opsuts", "iopgs", "optrs", "operuts", "experts", "opsks", "experjs", "Oputs", "opsns", "initts", "opsms", "optters", "opsds", "opmits", " coptes", "opats", "coptes", "optuts", "opvals", "opsts", " opcs", "optts", "Options", "optte", " optgt", "operTS", "topgs", "argcs", " opjs", "ioptions", " optx", "imuts", "experats", "opscs", "initops", "opsvals", "cptes", "opsres", " optts", "opsTS", "opcs", "opster", "OPts", "copjs", " oprets", "cpps", "iopgt", "imds", " copts", "imws", "experws", "cpts", "copgs", "initths", "optps", "expervals", "Opts", "cpgt", " optes", "oputs", "opns", "copts", " opms", "iopins", "opsjs", "opte", " opres", "atTS", "opsgt", "iopcs", " oputs", "att", "iopps", "initTS", "opres", " opks", "opsats", "optats", " opsts", " optns", "Opsts", " opbs", "opks", "optTS", "coprs", "opths", "optws", "experuts", " opports", "optmits", "opops", "topts", "opods", " opgt", "obts", "topt", "argrets", "opports", "experrs", " opTS", "oprets", "opsports", "opters", "operts", "OPt", "opsods", "opergs", "opsters", " copns", "argsts", "copter", "optx", "ioptes", "copns", "oppTS", "atcs", "Optes", "oprs", " copports", "optter", "Opters", "experds", " opmits", "atts", "opgs", " opns", "obcs", "opstx", "OPTS", "topins", "opstes", "optgs", "obTS", "OPcs", "OPuts", "oppops", " opte", "experTS", "oppts", "ioputs", "operats", "opTS", "copms", "copks", "coputs", "iopts", "optes", "Opats", "copTS", "opps", " optods", "opbs", "iopres", "iopt", "iopats"], "nextopt": [" NEXTopted", "randvirt", "mycrit", "newopt", "nextopted", "invvert", "nextblock", "latestattr", "govpt", "futurept", "randopt", "invop", "latestoption", "maxjson", " nextblock", " nextpost", " nextstat", " nextkw", " nextoption", "Nextalt", "Nextpt", "Nextvirt", "nextaltern", "trueopt", "latestopt", " nextvert", "futurealt", "firstoption", "govopt", "tenop", " NEXTopt", " NEXTstat", "invopted", " nextcrit", "firstaltern", " NEXTjson", "ndoption", "newsoption", "maxopted", " NEXToption", "trueoption", " nextalt", "Nextoption", "newop", "nextevent", "newobj", "newsattr", "randop", "nexttimeout", "newskw", " nextmsg", "anyopt", "futurekw", "futureoption", " nextopted", "futurecrit", "nextprop", "tentimeout", "randoption", " nextop", "tenaltern", "firstprop", "newoption", "nextvert", "maxop", " nextvirt", "Nextopted", "Nextevent", "Nextprop", " NEXTop", " nextjson", "newoptions", "futureop", "appendoption", "nextoption", "nextjson", "maxopt", "ndopt", "ndblock", "anyop", "nextobj", "nextalt", "tenopt", "myopt", " NEXTevent", "govoption", "anyoption", "Nextstat", "nextop", "tenoption", " nextevent", " nextaltern", "appendopt", "nextoptions", "Nextvert", "appendopted", " nextobj", "nextcrit", "Nextpost", "nextkw", "invopt", "latestobj", "appendmsg", "anyopted", "futurepost", "futureopt", "tenattr", "futuremsg", "newprop", "firstopt", "nextpost", " nexttimeout", "Nextopt", "Nextoptions", "trueop", "nextpt", " nextprop", "newstimeout", "futureopted", "newspt", "newattr", "trueopted", "futurevert", " nextpt", "newsopt", "Nextop", "ndopted", "myopted", "nextvirt", "myoption", "tenblock", "tenoptions", "nextattr", "tenprop", "nextmsg", "tenopted", "govop", " nextattr", "nextstat"]}}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)\n\n{\n\n    int64_t start, size, last_size;\n\n    start= url_ftell(bc) - prefix_length;\n\n\n\n    if(start != nut->packet_start + nut->written_packet_size){\n\n        av_log(nut->avf, AV_LOG_ERROR, \"get_packetheader called at weird position\\n\");\n\n        return -1;\n\n    }\n\n    \n\n    if(calculate_checksum)\n\n        init_checksum(bc, update_adler32, 0);\n\n\n\n    size= get_v(bc);\n\n    last_size= get_v(bc);\n\n    if(nut->written_packet_size != last_size){\n\n        av_log(nut->avf, AV_LOG_ERROR, \"packet size missmatch %d != %lld at %lld\\n\", nut->written_packet_size, last_size, start);\n\n        return -1;\n\n    }\n\n\n\n    nut->last_packet_start = nut->packet_start;\n\n    nut->packet_start = start;\n\n    nut->written_packet_size= size;\n\n\n\n    return size;\n\n}\n", "idx": 7777, "substitutes": {"nut": ["fn", "art", "our", "nt", "rup", "nova", "nih", "wp", "ox", "oren", "cn", "none", "dn", "hog", "olf", "mn", "net", "ape", "knife", "na", "etc", "n", "nc", "cmd", "pot", "rot", "orn", "note", "nor", "pieces", "obj", "sat", "mom", "dig", "nuts", "ref", "tip", "ocr", "nw", "utt", "anon", "roy", "runner", "Nut", "core", "snap", "num", "stab", "config", "nil", "news", "org", "ut", "critical", "anova", "piece", "nv", "nm", "wn", "np", "tree", "dan", "addy", "rn", "exec", "that", "img", "fail", "aum", "nat", "form", "orb", "roo", "norm", "node", "gob", "nit", "lost", "nu", "cot", "ot", "utils", "desc", "hn", "pie"], "bc": ["tc", "bo", "sc", "gru", "cm", "bn", "jac", "bi", "bt", "vc", "ec", "lc", "pc", "ic", "dc", "cb", "cl", "arc", "cc", "chron", "comm", "cn", "gc", "fc", "bs", "bitcoin", "bb", "bec", "mac", "BC", "uc", "ba", "cf", "db", "bg", "xc", "exec", "bp", "cs", "c", "bf", "oc", "nc", "mc", "BBC"], "prefix_length": ["prefixinglength", " prefix_Length", "prefixingLength", " prefix_size", " prefix_len", "prefix_Length", "prefixinglen", "prefix_len", "prefixingsize", "prefix_size"], "calculate_checksum": ["calculate_cksum", "calculate_csums", "calculate_cksize", "calculate_statsate", "calculate_checksume", "calculate_statssum", "calculate_checksums", "calculate_statsize", "calculate_csum", "calculate_checksize", "calculate_cksate", "calculate_checksate", "calculate_statsum", "calculate_cssum", "calculate_cksume", "calculate_csume", "calculate_cksums", "calculate_ckssum", "calculate_checkssum"], "start": ["get", "top", "init", "entry", "starting", "key", "reset", "art", "use", "origin", "id", "length", "it", "error", "check", "need", "send", "offset", "set", "ish", "ist", "trans", "st", "pad", "read", "prep", "space", "before", "source", "i", "pointer", "state", "stop", "index", "begin", "shift", "step", "range", "seed", "store", "rest", "len", "Start", "iter", "end", "try", "addr", "base", "import", "first", "create", "from", "open", "skip", "pos", "add", "next", "pre", "seek"], "size": ["capacity", "small", "t", "p", "max", "speed", "Size", "loss", "south", "since", "l", "news", "v", "sum", "data", "SIZE", "length", "ize", "sent", " end", "send", "resolution", "equal", "set", "export", "city", "fit", "ne", "body", "empty", "space", "format", "bytes", "name", "ice", "fee", "height", "len", "area", "sn", "end", "code", "e", "content", "unknown", "scale", "storage", "zone", "number", "num", "count", "notice", "n", "shape", "year", "se", "grow"], "last_size": ["first___length", "last_Size", "first___message", "first_size", "last_length", "Last_speed", "last_loc", "last67Size", "last___name", "latest_loc", "latest_size", "last67SIZE", "last___size", "latest_term", "last___length", "latest_Size", "last___term", "first___size", "last_SIZE", "last67size", " last_SIZE", "last_speed", "first_message", "last_message", "first_name", "last_name", "first_length", "Last_size", "Last_Size", "last67speed", "Last_SIZE", "last_term", "first___name", "last___Size", "last___loc", " last_Size", "last___message"]}}
{"project": "qemu", "commit_id": "75f19f8c3006970632303b49043b075dc4fe922e", "target": 0, "func": "static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    PCIDevice *p = PCI_DEVICE(s);\n\n\n\n    pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);\n\n    cmd->frame = NULL;\n\n    cmd->pa = 0;\n\n    clear_bit(cmd->index, s->frame_map);\n\n}\n", "idx": 7779, "substitutes": {"s": ["t", "os", "S", "ds", "is", "a", "d", "sp", "r", "ps", "spec", "ctx", "q", "obj", "ss", "self", "h", "j", "comm", "st", "o", "i", "js", "ns", "state", "sq", "ses", "sts", "rs", "gs", "ts", "es", "e", "stats", "m", "service", "sv", "args", "cs", "c", "ls", "n", "qs", "sys", "out"], "cmd": ["cp", "ch", "cast", "pkg", "Cmd", "conn", "config", "ctr", "mk", "ind", "nt", "cont", "ctx", "msg", "call", "q", "cd", "send", "txt", "obj", "ext", "cc", "set", "req", "dq", "control", "kind", "build", "comm", "buff", "js", "def", "dx", "bind", "comp", "comment", "md", "term", "act", "range", "text", "command", "rest", "cmp", "now", "op", "cfg", "content", "unknown", "raw", "report", "job", "quit", "exec", "utils", "args", "ct", "desc", "and", "auth", "nd", "cli", "c", "seq", "kick", "cod", "tab", "batch"], "p": ["ph", "vp", "pp", "t", "cp", "pkg", "lp", "d", "v", "sp", "app", "pc", "q", "phy", "pm", "pa", "h", "j", "pt", "i", "ap", "proc", "np", "b", "g", "pers", "peer", "y", "tp", "jp", "op", "m", "up", "P", "bp", "pi", "part", "pl", "pid", "c", "n", "pre"]}}
{"project": "qemu", "commit_id": "02cb7f3a256517cbf3136caff2863fbafc57b540", "target": 0, "func": "int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,\n\n                  int flags, int mode)\n\n{\n\n    int err;\n\n    FsCred cred;\n\n\n\n    cred_init(&cred);\n\n    cred.fc_mode = mode & 07777;\n\n    cred.fc_uid = fidp->uid;\n\n    cred.fc_gid = gid;\n\n    v9fs_co_run_in_worker(\n\n        {\n\n            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);\n\n            err = 0;\n\n            if (fidp->fs.fd == -1) {\n\n                err = -errno;\n\n            }\n\n        });\n\n    if (!err) {\n\n        total_open_fd++;\n\n        if (total_open_fd > open_fd_hw) {\n\n            v9fs_reclaim_fd(s);\n\n        }\n\n    }\n\n    return err;\n\n}\n", "idx": 7780, "substitutes": {"s": ["t", "os", "p", "S", "ds", "f", "is", "a", "d", "v", "sp", "ps", "vs", "sam", "ss", "h", "aws", "j", "bs", "source", "js", "ns", "hs", "ssl", "b", "state", "sq", "ses", "sts", "rs", "gs", "ts", "e", "ops", "stats", "m", "xs", "fs", "its", "sv", "cs", "session", "ims", "sb", "c", "ls", "n", "qs", "sys"], "fidp": ["lfido", "fidspre", "vidphp", "fpidpa", "fitp", "fpidP", "fidphp", "vitpre", "fmtP", "fpidp", "fitpid", "fidsp", " fidP", "fstartp", "fstartP", "foidps", "fadps", "foidP", "fpidps", "fadpid", " fidpc", "fmtp", "fidsphp", "fmtphp", "fidscp", "foidpa", "vidp", "lfidP", "fitpre", "fado", "fidpc", "fidps", "lfoidp", "vitp", " fidps", " fpidphp", " fidphp", " fpidps", "fidpa", "fidcp", "fitP", "fadp", "vitphp", "fmtpc", " fpidpa", "fidP", "fidpre", "vidcp", "foidpid", "lfidpid", "vidpre", " fpidp", "fpidphp", "fitphp", "fito", "fadP", "foido", "fadpa", "fstartphp", " fpidpc", "lfidp", " fidpa", "lfoidP", "lfoido", "fido", "fidpid", "fitcp", " fpidP", "vitcp", "fpidpc", "lfoidpid", "fstartpc", "foidp"], "fullname": ["largeName", "localnam", "localname", "localName", "FullName", "longnam", "fullnam", "largename", "longfilename", "fullnamed", "fullpath", "fullfilename", "longname", "Fullname", " fullpath", " fullfilename", "localfilename", "fullName", "largepath", " fullnamed", " fullnam", "longName", " fullName", "largenamed", "Fullpath", "Fullnamed"], "gid": ["pgId", "GId", "egID", "vgid", "igID", "gno", "vgId", "GID", "vgdata", "pgdata", "Gno", "gdata", "pgid", "egid", "gID", "pgID", "egId", "igId", " gno", "gId", " gId", " gID", "egdata", "igno", "vgID", "Gid", "igid"], "flags": ["details", "properties", "times", "ms", "types", "frames", "links", " modes", "locks", "options", "fps", "missions", "kind", "posts", "levels", "Flags", "styles", "tags", "status", "faces", "ops", "lines", "comments", "bits", "vals", "flag", "features", "mask", "settings", "acts", "fields", "params", "ags"], "mode": ["MODE", "pose", "de", "ms", "id", "dim", "ode", "position", "force", "kind", "module", "time", "size", "format", "mt", "def", "dir", "role", "md", "type", "mid", "command", "status", "perm", "code", "cmp", "m", "te", "scale", "ase", "flag", "Mode", "mask", "tm", "mod", "pe", "cmd"], "err": ["fr", "gz", "conf", "conn", "id", "l", "arr", "error", "msg", "txt", "str", "ver", "iter", "coord", "esp", "count", "c", "n", "er", "score", "eas", "ptr", "ch", "erer", "ach", "r", "eric", "h", "i", "ner", "code", "try", "raw", "rc", "Er", "order", "eor", "f", "ind", "kr", "rr", "die", "br", "off", "fee", "rs", "rn", "e", "rel", "Error", "oe", "ev", "out", "dr", "elt", "cer", "inner", "fi", "lr", "ec", "cr", "attr", "fer", "result", "usr", "resp", "nr", "buf", "pr", "rev", "cmp", "res", "der", "expr", "timer"], "cred": ["dcred", "crc", "dcmem", "kred", "lcrib", "bcreed", "cded", " coded", "camde", "camreed", "gld", "uncred", "cmem", " ckered", "greed", "callreed", "conrib", "lcoded", "krib", "camkered", "callde", "bcred", "kmem", "callred", "gred", "acreed", "coded", "uncoded", "ckered", " creed", "carc", "lcreed", "cpred", "carib", " crc", " cde", "cared", "acred", "bcrib", " crib", "conreed", " cpred", "cld", "callkered", "dcld", "uncrib", "crib", " cded", "grib", "cald", "acrc", "acrib", "creed", " cld", "conoded", "conded", "lcred", "conred", "uncded", "cde", "dcrib", "bcoded", "dcreed", " cmem", "acld", "dcpred", "kpred", "camred"], "total_open_fd": ["total_open_fc", "total_openMFD", "total_Open_fd", "total_Open_fs", "total_Open_fa", "total_open_db", "total_open_fa", "total_open_df", "total_openMfa", "total_open_FD", "total_openMfs", "total_openMfd", "total_open_fs", "total_Open_FD"]}}
{"project": "qemu", "commit_id": "bbe2f399b222f1f2fcf5cd2ea78e4f5c9a66c64e", "target": 0, "func": "static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)\n\n{\n\n    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\n    static const uint8_t vlan[] = {0x81, 0x00};\n\n    uint8_t *ptr = (uint8_t *)buf;\n\n    int i;\n\n\n\n    if (n->promisc)\n\n        return 1;\n\n\n\n    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {\n\n        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;\n\n        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))\n\n            return 0;\n\n    }\n\n\n\n    if ((ptr[0] & 1) && n->allmulti)\n\n        return 1;\n\n\n\n    if (!memcmp(ptr, bcast, sizeof(bcast)))\n\n        return 1;\n\n\n\n    if (!memcmp(ptr, n->mac, ETH_ALEN))\n\n        return 1;\n\n\n\n    for (i = 0; i < n->mac_table.in_use; i++) {\n\n        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))\n\n            return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7782, "substitutes": {"n": ["nas", "bn", "p", "fn", "conn", "ln", "ll", "v", "nn", "nt", "norm", "nor", "note", "node", "en", "nv", "ne", "cn", "comm", "dn", "nm", "ns", "nu", "nan", "ann", "np", "nex", "wn", "gn", "name", "an", "g", "nr", "mn", "non", "sn", "rn", "nw", "un", "m", "na", "N", "names", "num", "c", "nl", "ren", "nb", "nc", "out", "tn"], "buf": ["rc", "doc", "p", "cast", "cv", "tmp", "v", "r", "ctx", "msg", "map", "cb", "Buffer", "w", "read", "buff", "Buff", "mem", "bytes", "b", "err", "pb", "ref", "buffer", "alloc", "late", "raw", "vec", "tr", "window", "uf", "bc", "queue", "bf", "block", "out", "cmd", "batch"], "size": ["Size", "id", "sp", "data", "length", "SIZE", "ize", "send", "address", "offset", "set", "si", "en", "empty", "mem", "name", "cap", "type", "seed", "len", "code", "e", "scale", "count", "c", "message", "start"], "bcast": ["bbcasts", " bcasts", "wbcast", "bbbox", "bgcatch", "bgbox", " bare", "bgcast", "bcasting", "obcast", "bmap", "vcatch", "vbox", "bbare", "fbcaster", "bcaster", "bbcatch", "vcast", "fbcasting", "wbcasting", "bbcaster", "wbcaster", "wbcmd", "bcasts", "fbcmd", "bbmap", "obmap", "vcaster", "bbcmd", "bbox", "obare", "bare", "bcmd", "bbcast", "bbcasting", " bmap", "bcatch", "bgcaster", "fbcast", "obcasts"], "vlan": ["plad", "tvLAN", " vordan", "evLAN", "tvlock", "vul", " vault", "plock", "invlad", "invlan", " vlv", "tvlan", "evlan", "vordan", "vLAN", "vlock", " vLAN", "tvld", "invld", "evordan", "tvlad", " vlock", "vault", "tvul", " vul", "vld", "tvault", "plan", "tvordan", "vlv", "tvlv", "invlv", " vld", "pul", "evault", " vlad", "vlad"], "ptr": ["deg", "dr", "pp", "rep", "t", "p", "rod", "pkg", "tmp", "ctr", "ind", "arr", "r", "nt", "ctx", "sp", "cont", "pointers", "obj", "loc", "offset", "inters", "cur", "str", "br", "pad", "vr", "pt", "adr", "buff", "dh", "xt", "attr", "js", "off", "proc", "pointer", "np", "mem", "shift", "Ptr", "pr", "ref", "buffer", "fp", "tp", "ts", "iter", "jp", "rect", "rel", "crop", "tr", "vec", "rd", "addr", "bp", "expr", "desc", "uf", "push", "grad", "pos", "rt", "cmd", "embed"], "i": ["init", "t", "li", "ei", "p", "sim", "ki", "bi", "id", "ind", "v", "ii", "ini", "mi", "ix", " bi", " pi", "it", "mu", "me", "MI", "ic", "gu", "\u0438", "hi", "si", "j", "di", "gi", "o", "ri", "ji", "ip", "index", "g", " v", "ui", "multi", "iu", "xi", "y", "zi", " ti", "ti", "ci", "m", "ami", "ai", "pi", " j", "ni", "im", "x", "I", "phi", "ims", "cli", "us", "qi", " ii"]}}
{"project": "FFmpeg", "commit_id": "4bb0b31f762c422ad15bee68da7bcf76940cc9fa", "target": 0, "func": "static int output_packet(InputStream *ist, int ist_index,\n\n                         OutputStream *ost_table, int nb_ostreams,\n\n                         const AVPacket *pkt)\n\n{\n\n    AVFormatContext *os;\n\n    OutputStream *ost;\n\n    int ret, i;\n\n    int got_output;\n\n    void *buffer_to_free = NULL;\n\n    static unsigned int samples_size= 0;\n\n    AVSubtitle subtitle, *subtitle_to_free;\n\n    int64_t pkt_pts = AV_NOPTS_VALUE;\n\n#if CONFIG_AVFILTER\n\n    int frame_available;\n\n#endif\n\n    float quality;\n\n\n\n    AVPacket avpkt;\n\n    int bps = av_get_bytes_per_sample(ist->st->codec->sample_fmt);\n\n\n\n    if(ist->next_pts == AV_NOPTS_VALUE)\n\n        ist->next_pts= ist->pts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if(pkt->dts != AV_NOPTS_VALUE)\n\n        ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n    if(pkt->pts != AV_NOPTS_VALUE)\n\n        pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    //while we have more to decode or while the decoder did output something on EOF\n\n    while (avpkt.size > 0 || (!pkt && got_output)) {\n\n        uint8_t *data_buf, *decoded_data_buf;\n\n        int data_size, decoded_data_size;\n\n        AVFrame *decoded_frame, *filtered_frame;\n\n    handle_eof:\n\n        ist->pts= ist->next_pts;\n\n\n\n        if(avpkt.size && avpkt.size != pkt->size)\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning=1;\n\n\n\n        /* decode the packet if needed */\n\n        decoded_frame    = filtered_frame = NULL;\n\n        decoded_data_buf = NULL; /* fail safe */\n\n        decoded_data_size= 0;\n\n        data_buf  = avpkt.data;\n\n        data_size = avpkt.size;\n\n        subtitle_to_free = NULL;\n\n        if (ist->decoding_needed) {\n\n            switch(ist->st->codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:{\n\n                if(pkt && samples_size < FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE)) {\n\n                    samples_size = FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE);\n\n                    av_free(samples);\n\n                    samples= av_malloc(samples_size);\n\n                }\n\n                decoded_data_size= samples_size;\n\n                    /* XXX: could avoid copy if PCM 16 bits with same\n\n                       endianness as CPU */\n\n                ret = avcodec_decode_audio3(ist->st->codec, samples, &decoded_data_size,\n\n                                            &avpkt);\n\n                if (ret < 0)\n\n                    return ret;\n\n                avpkt.data += ret;\n\n                avpkt.size -= ret;\n\n                data_size   = ret;\n\n                got_output  = decoded_data_size > 0;\n\n                /* Some bug in mpeg audio decoder gives */\n\n                /* decoded_data_size < 0, it seems they are overflows */\n\n                if (!got_output) {\n\n                    /* no audio frame */\n\n                    continue;\n\n                }\n\n                decoded_data_buf = (uint8_t *)samples;\n\n                ist->next_pts += ((int64_t)AV_TIME_BASE/bps * decoded_data_size) /\n\n                    (ist->st->codec->sample_rate * ist->st->codec->channels);\n\n                break;}\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                    decoded_data_size = (ist->st->codec->width * ist->st->codec->height * 3) / 2;\n\n                    if (!(decoded_frame = avcodec_alloc_frame()))\n\n                        return AVERROR(ENOMEM);\n\n                    avpkt.pts = pkt_pts;\n\n                    avpkt.dts = ist->pts;\n\n                    pkt_pts = AV_NOPTS_VALUE;\n\n\n\n                    ret = avcodec_decode_video2(ist->st->codec,\n\n                                                decoded_frame, &got_output, &avpkt);\n\n                    quality = same_quant ? decoded_frame->quality : 0;\n\n                    if (ret < 0)\n\n                        goto fail;\n\n                    if (!got_output) {\n\n                        /* no picture yet */\n\n                        av_freep(&decoded_frame);\n\n                        goto discard_packet;\n\n                    }\n\n                    ist->next_pts = ist->pts = guess_correct_pts(&ist->pts_ctx, decoded_frame->pkt_pts,\n\n                                                                 decoded_frame->pkt_dts);\n\n                    if (ist->st->codec->time_base.num != 0) {\n\n                        int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                        ist->next_pts += ((int64_t)AV_TIME_BASE *\n\n                                          ist->st->codec->time_base.num * ticks) /\n\n                            ist->st->codec->time_base.den;\n\n                    }\n\n                    avpkt.size = 0;\n\n                    buffer_to_free = NULL;\n\n                    pre_process_video_frame(ist, (AVPicture *)decoded_frame, &buffer_to_free);\n\n                    break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                ret = avcodec_decode_subtitle2(ist->st->codec,\n\n                                               &subtitle, &got_output, &avpkt);\n\n                if (ret < 0)\n\n                    return ret;\n\n                if (!got_output) {\n\n                    goto discard_packet;\n\n                }\n\n                subtitle_to_free = &subtitle;\n\n                avpkt.size = 0;\n\n                break;\n\n            default:\n\n                return -1;\n\n            }\n\n        } else {\n\n            switch(ist->st->codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                ist->next_pts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n\n                    ist->st->codec->sample_rate;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                if (ist->st->codec->time_base.num != 0) {\n\n                    int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                    ist->next_pts += ((int64_t)AV_TIME_BASE *\n\n                                      ist->st->codec->time_base.num * ticks) /\n\n                        ist->st->codec->time_base.den;\n\n                }\n\n                break;\n\n            }\n\n            avpkt.size = 0;\n\n        }\n\n\n\n        // preprocess audio (volume)\n\n        if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (audio_volume != 256) {\n\n                switch (ist->st->codec->sample_fmt) {\n\n                case AV_SAMPLE_FMT_U8:\n\n                {\n\n                    uint8_t *volp = samples;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        int v = (((*volp - 128) * audio_volume + 128) >> 8) + 128;\n\n                        *volp++ = av_clip_uint8(v);\n\n                    }\n\n                    break;\n\n                }\n\n                case AV_SAMPLE_FMT_S16:\n\n                {\n\n                short *volp;\n\n                volp = samples;\n\n                for(i=0;i<(decoded_data_size / sizeof(short));i++) {\n\n                    int v = ((*volp) * audio_volume + 128) >> 8;\n\n                    *volp++ = av_clip_int16(v);\n\n                }\n\n                break;\n\n                }\n\n                case AV_SAMPLE_FMT_S32:\n\n                {\n\n                    int32_t *volp = samples;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        int64_t v = (((int64_t)*volp * audio_volume + 128) >> 8);\n\n                        *volp++ = av_clipl_int32(v);\n\n                    }\n\n                    break;\n\n                }\n\n                case AV_SAMPLE_FMT_FLT:\n\n                {\n\n                    float *volp = samples;\n\n                    float scale = audio_volume / 256.f;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        *volp++ *= scale;\n\n                    }\n\n                    break;\n\n                }\n\n                case AV_SAMPLE_FMT_DBL:\n\n                {\n\n                    double *volp = samples;\n\n                    double scale = audio_volume / 256.;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        *volp++ *= scale;\n\n                    }\n\n                    break;\n\n                }\n\n                default:\n\n                    av_log(NULL, AV_LOG_FATAL,\n\n                           \"Audio volume adjustment on sample format %s is not supported.\\n\",\n\n                           av_get_sample_fmt_name(ist->st->codec->sample_fmt));\n\n                    exit_program(1);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* frame rate emulation */\n\n        if (input_files[ist->file_index].rate_emu) {\n\n            int64_t pts = av_rescale(ist->pts, 1000000, AV_TIME_BASE);\n\n            int64_t now = av_gettime() - ist->start;\n\n            if (pts > now)\n\n                usleep(pts - now);\n\n        }\n\n        /* if output time reached then transcode raw format,\n\n           encode packets and output them */\n\n        for (i = 0; i < nb_ostreams; i++) {\n\n            OutputFile *of = &output_files[ost_table[i].file_index];\n\n            int frame_size;\n\n\n\n            ost = &ost_table[i];\n\n            if (ost->source_index != ist_index)\n\n                continue;\n\n\n\n            if (of->start_time && ist->pts < of->start_time)\n\n                continue;\n\n\n\n            if (of->recording_time != INT64_MAX &&\n\n                av_compare_ts(ist->pts, AV_TIME_BASE_Q, of->recording_time + of->start_time,\n\n                              (AVRational){1, 1000000}) >= 0) {\n\n                ost->is_past_recording_time = 1;\n\n                continue;\n\n            }\n\n\n\n#if CONFIG_AVFILTER\n\n            if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n                ost->input_video_filter) {\n\n                AVRational sar;\n\n                if (ist->st->sample_aspect_ratio.num)\n\n                    sar = ist->st->sample_aspect_ratio;\n\n                else\n\n                    sar = ist->st->codec->sample_aspect_ratio;\n\n                av_vsrc_buffer_add_frame(ost->input_video_filter, decoded_frame, ist->pts, sar);\n\n                if (!(filtered_frame = avcodec_alloc_frame())) {\n\n                    ret = AVERROR(ENOMEM);\n\n                    goto fail;\n\n                }\n\n            }\n\n            frame_available = ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO ||\n\n                !ost->output_video_filter || avfilter_poll_frame(ost->output_video_filter->inputs[0]);\n\n            while (frame_available) {\n\n                AVRational ist_pts_tb;\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && ost->output_video_filter)\n\n                    get_filtered_video_frame(ost->output_video_filter, filtered_frame, &ost->picref, &ist_pts_tb);\n\n                if (ost->picref)\n\n                    ist->pts = av_rescale_q(ost->picref->pts, ist_pts_tb, AV_TIME_BASE_Q);\n\n#else\n\n                filtered_frame = decoded_frame;\n\n#endif\n\n                os = output_files[ost->file_index].ctx;\n\n\n\n                /* set the input output pts pairs */\n\n                //ost->sync_ipts = (double)(ist->pts + input_files[ist->file_index].ts_offset - start_time)/ AV_TIME_BASE;\n\n\n\n                if (ost->encoding_needed) {\n\n                    av_assert0(ist->decoding_needed);\n\n                    switch(ost->st->codec->codec_type) {\n\n                    case AVMEDIA_TYPE_AUDIO:\n\n                        do_audio_out(os, ost, ist, decoded_data_buf, decoded_data_size);\n\n                        break;\n\n                    case AVMEDIA_TYPE_VIDEO:\n\n#if CONFIG_AVFILTER\n\n                        if (ost->picref->video && !ost->frame_aspect_ratio)\n\n                            ost->st->codec->sample_aspect_ratio = ost->picref->video->pixel_aspect;\n\n#endif\n\n                        do_video_out(os, ost, ist, filtered_frame, &frame_size,\n\n                                     same_quant ? quality : ost->st->codec->global_quality);\n\n                        if (vstats_filename && frame_size)\n\n                            do_video_stats(os, ost, frame_size);\n\n                        break;\n\n                    case AVMEDIA_TYPE_SUBTITLE:\n\n                        do_subtitle_out(os, ost, ist, &subtitle,\n\n                                        pkt->pts);\n\n                        break;\n\n                    default:\n\n                        abort();\n\n                    }\n\n                } else {\n\n                    AVPacket opkt;\n\n                    int64_t ost_tb_start_time= av_rescale_q(of->start_time, AV_TIME_BASE_Q, ost->st->time_base);\n\n\n\n                    av_init_packet(&opkt);\n\n\n\n                    if ((!ost->frame_number && !(pkt->flags & AV_PKT_FLAG_KEY)) && !copy_initial_nonkeyframes)\n\n#if !CONFIG_AVFILTER\n\n                        continue;\n\n#else\n\n                        goto cont;\n\n#endif\n\n\n\n                    /* no reencoding needed : output the packet directly */\n\n                    /* force the input stream PTS */\n\n\n\n                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n\n                        audio_size += data_size;\n\n                    else if (ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                        video_size += data_size;\n\n                        ost->sync_opts++;\n\n                    }\n\n\n\n                    opkt.stream_index= ost->index;\n\n                    if(pkt->pts != AV_NOPTS_VALUE)\n\n                        opkt.pts= av_rescale_q(pkt->pts, ist->st->time_base, ost->st->time_base) - ost_tb_start_time;\n\n                    else\n\n                        opkt.pts= AV_NOPTS_VALUE;\n\n\n\n                    if (pkt->dts == AV_NOPTS_VALUE)\n\n                        opkt.dts = av_rescale_q(ist->pts, AV_TIME_BASE_Q, ost->st->time_base);\n\n                    else\n\n                        opkt.dts = av_rescale_q(pkt->dts, ist->st->time_base, ost->st->time_base);\n\n                    opkt.dts -= ost_tb_start_time;\n\n\n\n                    opkt.duration = av_rescale_q(pkt->duration, ist->st->time_base, ost->st->time_base);\n\n                    opkt.flags= pkt->flags;\n\n\n\n                    //FIXME remove the following 2 lines they shall be replaced by the bitstream filters\n\n                    if(   ost->st->codec->codec_id != CODEC_ID_H264\n\n                       && ost->st->codec->codec_id != CODEC_ID_MPEG1VIDEO\n\n                       && ost->st->codec->codec_id != CODEC_ID_MPEG2VIDEO\n\n                       ) {\n\n                        if(av_parser_change(ist->st->parser, ost->st->codec, &opkt.data, &opkt.size, data_buf, data_size, pkt->flags & AV_PKT_FLAG_KEY))\n\n                            opkt.destruct= av_destruct_packet;\n\n                    } else {\n\n                        opkt.data = data_buf;\n\n                        opkt.size = data_size;\n\n                    }\n\n\n\n                    write_frame(os, &opkt, ost->st->codec, ost->bitstream_filters);\n\n                    ost->st->codec->frame_number++;\n\n                    ost->frame_number++;\n\n                    av_free_packet(&opkt);\n\n                }\n\n#if CONFIG_AVFILTER\n\n                cont:\n\n                frame_available = (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) &&\n\n                                   ost->output_video_filter && avfilter_poll_frame(ost->output_video_filter->inputs[0]);\n\n                if (ost->picref)\n\n                    avfilter_unref_buffer(ost->picref);\n\n            }\n\n            av_freep(&filtered_frame);\n\n#endif\n\n            }\n\n\n\nfail:\n\n        av_free(buffer_to_free);\n\n        /* XXX: allocate the subtitles in the codec ? */\n\n        if (subtitle_to_free) {\n\n            avsubtitle_free(subtitle_to_free);\n\n            subtitle_to_free = NULL;\n\n        }\n\n        av_freep(&decoded_frame);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n discard_packet:\n\n\n\n    return 0;\n\n}\n", "idx": 7808, "substitutes": {"ist": ["art", "artist", "wikipedia", "it", "isted", "wp", "via", "each", "pt", "ister", "iter", "mit", "its", "ik", "hop", "ept", "irst", "htt", "dist", "list", "ic", "pas", "alist", "edit", "ief", "iste", "isi", "xt", "ht", "irc", "pect", "sts", "stat", "ort", "ert", "ush", "ict", "assert", "pir", "ia", "ift", "is", "ista", "ind", "istar", "elist", "exist", "ism", "pport", "ive", "ld", "istor", "dit", "ident", "est", "hist", "rank", "iat", "isting", "IST", "ust", "ists", "iana", "istant", "archive", "ont", "spect", "inst", "ire", "ast", "ilst", "usr", "lect", "il", "act", "ird", "ij", "wi", "erd", "xp"], "ist_index": ["ist_address", "ist_count", "ost_address", "istdbindex", "ost_index", "ost_id", "ist_id", "istdbaddress", "istdbid", "istdbcount", "ost_count"], "ost_table": ["ost_able", " ost_able", " ost_info", "ost_info", "ost_source", " ost_source"], "nb_ostreams": ["nb_istreams", "nb_oststreams", "nb_ostrowns", "nb_ostrown_", "nb_ostreamlist", "nb_ostream_", "nb_ost_size", "nb_ost__", "nb_ostrownlist", "nb_ostrownsize", "nb_iststreamlist", "nb_istreamlist", "nb_ost_list", "nb_oststreamlist", "nb_oststream_", "nb_ostreamsize", "nb_istream_", "nb_iststreamsize", "nb_ost_s", "nb_iststream_", "nb_istreamsize", "nb_oststreamsize", "nb_iststreams"], "pkt": ["patkt", "pdu", "pkg", "Packet", "apkat", "pct", "Pwk", "apacket", "compkt", "prck", "mkw", "dpkg", "expqt", " pkg", "pck", "prkt", "compmsg", "cpkt", "cpmsg", "vpkt", "dpnt", "vpacket", "cpkat", "cpwk", "pet", "pcnt", "podkl", "podkt", "apkt", "Pkg", "dpacket", "cpnt", "vpnt", "mmsg", "pcacket", "patkat", "cpacket", "pcwt", " pwt", "pckt", "dpwt", "patacket", " pqt", "pingacket", "prkat", "vpet", "pkat", " packet", "compacket", "pingkt", "prwk", "pingwd", "dpkt", "podkw", "pqt", "mkt", "mkl", "cpdu", " pkat", " pwd", "pnt", "expacket", "ppkat", " pwk", "pingkat", "expkt", "cpqt", "dpkat", "packet", " pet", "pkw", "apwk", "cpet", "podmsg", "pkl", "ppacket", "expdu", " pct", "Pkat", " pkw", "Pck", "Pct", " pnt", " pck", "patkg", "cpkg", "pwt", "pwd", "Pkt", "compct", "pwk", "compkg", "pmsg", "ppkt", " pkl", " pmsg", " pdu", "ppwd"], "os": ["oss", "ds", "oS", "ms", "Os", "ps", "ox", "ss", "o", "io", "bs", "ns", "ot", "es", "op", "ops", "res", "cs", "us", "OS", "s", "pos", "oc", "sys", "oses", "ol"], "ost": ["ust", "otype", "oss", "irst", "host", "tt", "od", "ott", "post", "ast", "est", "osp", "ird", "OST", "rest", "ot", "op", "ous", "ops", "ort", "yt", "hop", "oid", "oc", "oe"], "ret": ["af", "elt", "fi", "ll", "RET", "dim", "nt", "re", "Ret", "ft", "rets", "val", "mem", "resp", "result", "ref", "new", "status", "len", "rel", "res", "vals", "flag", "rin", "alt", "rt"], "i": ["li", "p", "fi", "bi", "f", "id", "ind", "v", "ii", "mi", "si", "j", "ip", "b", "index", "iu", "ij", "iter", "ci", "ti", "m", "iat", "pi", "im", "I", "c", "n"], "got_output": ["gotableresponse", "got_buffer", "got___out", "gotweboutput", "got_Output", "gotwebbuffer", "got_response", " got_response", "gotwebdata", "gotablenext", " got_out", " got_data", "gotableoutput", "gotwebout", "got___buffer", " got_Output", " got_next", "got_data", "got___output", "gotableOutput", "got_out", " got_buffer", "got___data", "got_next"], "buffer_to_free": ["buffer_to_available", "buffer_To_free", "buffer_to_FREE", "buffer_to_used", "buffer_To_available", "buffer_To_FREE", "buffer_To_used"], "subtitle": ["ubTitle", " subTitle", "Subformat", "ubtitle", "subTitle", "ubformat", "SubTitle", "subformat", " subformat", "Subtitle"], "subtitle_to_free": ["subtitle_from_Free", "subtitle_to_FREE", "subtitle_to_buffer", "subtitle_from_free", "subtitle_from_buffer", "subtitle_to_Free", "subtitle_from_FREE"], "frame_available": [" frame_changed", "frame_changed", " frame_free", " frame_used", "frame_used", "frame_free"], "quality": ["flags", " load", "f", "func", "condition", " equality", " check", "check", " fps", "val", " compress", " cast", " af", " test", "cap", "type", "ref", "alloc", " cap", " pointer", " freeze", "value"], "avpkt": ["averpaacket", "aveppacket", "ajpkg", "aveppkg", "avdpkt", "avcachekat", "averpakt", "avmdt", "avdpelt", "avwpacket", "avpervc", "avmkt", "auxpacket", "avpcht", "avcpth", "averpaqt", "avwpdu", "avepet", "avpbkg", "avnpdt", "avpcmd", "auxpaacket", " avpth", "avmmsg", "averpkt", "avpcdu", "avewpelt", "averpakg", "avwpcmd", "aveppet", "avepelt", "avewpkg", "avwpqt", "auxpakg", "avpelt", "avewpcmd", "avpdt", "avpecht", "avrespacket", "avpakt", "avpidkat", "avpekg", "avapkt", " avcpct", "avppelt", "aveppkt", "avcpdu", "avpekat", "avperkg", "avpakg", "avPkt", "ajpidkt", "avppet", "avPacket", "avapkg", " avcpmsg", "avpbcmd", "avdpct", "avpcelt", "avepacket", "avpdu", "avpvc", "avpekt", "avcachekg", "avewpacket", " avcpth", "auxpkt", "avapqt", "avpkg", "avewpvc", "auxpakt", " avcpet", "avcachecht", "avpct", "avrespqt", "ajpkt", "ajpidkg", "avapacket", "avpbvc", "auxpaqt", "avpaqt", "ajpidkat", "auxpqt", "avepkt", "avPqt", "avapet", "avppkt", "avcpacket", "avnpmsg", "avewpkt", "avepcmd", "avpkat", " avcpelt", "ajpcht", "averpkg", "avcpet", "avppct", "avepdu", " avpelt", " avpet", "avcpct", "avppacket", "averpacket", "avppth", "averpqt", "avnpkt", "avPkg", "avwpkg", "avpmsg", "avppkg", " avpmsg", "avpacket", "avwpvc", "avepkg", "avpercmd", "avewpdu", "avPet", "ajpkat", "avpckt", "avpaacket", "avcpelt", "avpidkg", " avcpdt", "avpidcht", "avpcacket", "avmet", " avpdt", "avrespkt", "avnpet", "avcpmsg", "auxpkg", "avcpdt", "avcachekt", "avcpkt", " avcpkt", "avwpkt", "avwpelt", " avpct", "ajpidcht", "avdpth", "avpth", "avrespkg", "avpqt", "avpidkt", "avperkt", "avepvc", "avpbkt", "avpet"], "data_buf": ["data2buf", "data2buffer", "data___cur", " data_buff", "data2buff", " data_buffer", "data_buffer", "data___buff", "data___buffer", "data___buf", "data_buff", " data_cur", "data2cur", "data_cur"], "decoded_data_buf": ["decoded_data_tmp", "decoded_window_tmp", "decoded_window_buffer", "decoded_datalybuf", "decoded_data_buffer", "decoded_datalytmp", "decoded_datalybuffer", "decoded_data_buff", "decoded_window_buff", "decoded_window_buf", "decoded_datalybuff"], "data_size": ["data_SIZE", "data_length", "data2size", "data2len", " data_SIZE", " data_len", " data_length", "data2SIZE", "data2length", "data_len"], "decoded_data_size": ["decoded_frame_len", "decoded_frame_length", "decoded_data_SIZE", "decoded_data_len", "decoded_data_length", "decoded_frame_size", "decoded_frame_SIZE"], "decoded_frame": ["decoded___data", "decoded___frames", "decoded___frame", "decode_face", "decode_data", "decode_frames", "decoded___face", "decode_frame", "decoded_frames", "decoded_data", "decoded_face"], "filtered_frame": ["filtered_data", "filted_frame", "filtered____frame", "filtered_frames", "filted_frames", "filtered____frames", "filtered_msg", "filtered____msg", "filtered____data", "filted_msg", "filted_data"], "st": ["ST", "ust", "stage", "sc", "co", "cast", "sec", "dist", "ctx", "sta", "stack", "obj", "cl", "str", "cc", "set", "ste", "state", "est", "stop", "step", "std", "sts", "interface", "store", "rest", "status", "stat", "service", "storage", "stream", "desc", "nd", "sty", "St", "src", "start", "stru", "se"], "codec": ["coderer", "rendEC", "rendec", "rendef", "indef", "Codec", "Codef", "codEC", "Coderer", "codef", "renderer", "inderer", "indEC", "indec", "CodEC"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_tlbsx_440(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    t0 = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, t0);\n\n    gen_helper_440_tlbsx(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);\n\n    tcg_temp_free(t0);\n\n    if (Rc(ctx->opcode)) {\n\n        int l1 = gen_new_label();\n\n        tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so);\n\n        tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr[rD(ctx->opcode)], -1, l1);\n\n        tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 0x02);\n\n        gen_set_label(l1);\n\n    }\n\n#endif\n\n}\n", "idx": 7814, "substitutes": {"ctx": ["tc", "sc", "gz", "cm", "cp", "p", "co", "jac", "gt", "ork", "pkg", "cu", "github", "work", "conn", "ctr", "ind", "wx", "nt", "pc", "prefix", "obj", "cb", "txt", "cl", "cc", "crit", "cur", "abc", "kt", "req", "setup", "comm", "gc", "kl", "anc", "ann", "history", "resp", "np", "today", "act", "scl", "cmp", "jp", "ck", "cf", "cfg", "xs", "nw", "stat", "xc", "ca", "hw", "ct", "ac", "x", "desc", "tx", "qt", "c", "wcs", "cmd", "aux", "kw", "push", "xp", "context", "urg", "ctl", "nc", "bc"], "t0": [" t00", " t000", "wt0", "to0", "dt050", "tempZero", "to1", "tr000", " t1", "t000", "dt1", "T1", "ts0", "T000", "wt1", "dt0", "t050", "tZero", "dtZero", "t1", "tr0", "dt00", "T00", "tr1", "ts050", "t00", "temp050", "tsZero", "temp0", "T0"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "GSource *iohandler_get_g_source(void)\n\n{\n\n    iohandler_init();\n\n    return aio_get_g_source(iohandler_ctx);\n\n}\n", "idx": 7828, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "a4c7a5ea27050a28625eabf1ba98cfef9ac6620d", "target": 0, "func": "int ff_mpeg1_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size)\n\n{\n\n    int i;\n\n    uint32_t state= pc->state;\n\n\n\n    /* EOF considered as end of frame */\n\n    if (buf_size == 0)\n\n        return 0;\n\n\n\n/*\n\n 0  frame start         -> 1/4\n\n 1  first_SEQEXT        -> 0/2\n\n 2  first field start   -> 3/0\n\n 3  second_SEQEXT       -> 2/0\n\n 4  searching end\n\n*/\n\n\n\n    for(i=0; i<buf_size; i++){\n\n        assert(pc->frame_start_found>=0 && pc->frame_start_found<=4);\n\n        if(pc->frame_start_found&1){\n\n            if(state == EXT_START_CODE && (buf[i]&0xF0) != 0x80)\n\n                pc->frame_start_found--;\n\n            else if(state == EXT_START_CODE+2){\n\n                if((buf[i]&3) == 3) pc->frame_start_found= 0;\n\n                else                pc->frame_start_found= (pc->frame_start_found+1)&3;\n\n            }\n\n            state++;\n\n        }else{\n\n            i= ff_find_start_code(buf+i, buf+buf_size, &state) - buf - 1;\n\n            if(pc->frame_start_found==0 && state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE){\n\n                i++;\n\n                pc->frame_start_found=4;\n\n            }\n\n            if(state == SEQ_END_CODE){\n\n                pc->state=-1;\n\n                return i+1;\n\n            }\n\n            if(pc->frame_start_found==2 && state == SEQ_START_CODE)\n\n                pc->frame_start_found= 0;\n\n            if(pc->frame_start_found<4 && state == EXT_START_CODE)\n\n                pc->frame_start_found++;\n\n            if(pc->frame_start_found == 4 && (state&0xFFFFFF00) == 0x100){\n\n                if(state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE){\n\n                    pc->frame_start_found=0;\n\n                    pc->state=-1;\n\n                    return i-3;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    pc->state= state;\n\n    return END_NOT_FOUND;\n\n}\n", "idx": 7834, "substitutes": {"pc": ["tc", "pp", "isc", "p", "pkg", "conn", "vc", "iac", "roc", "wp", "amp", "phrase", "pt", "gc", "etc", "bp", "pl", "c", "oc", "nc", "pan", "mc", "sc", "cp", "pic", "ctx", "put", "chron", "arc", "icc", "soc", "proc", "pointer", "po", "PC", "pb", "enc", "pd", "ck", "acl", "disc", "pi", "patch", "pod", "tk", "pac", "ack", "sys", "rc", "cu", "lp", "controller", "func", "lc", "mp", "dc", "amps", "pa", "pad", "fc", "peer", "cam", "conv", "cs", "vp", "doc", "unc", "ec", "ping", "pg", "sync", "cc", "pm", "px", "anc", "cell", "resp", "pr", "tp", "cmp", "ca", "ac", "client", "cod", "xp", "bc"], "buf": ["ptr", "init", "p", "pkg", "cv", "bh", "tmp", "v", "data", "length", "ctx", "xff", "fb", "msg", "bar", "map", "cb", "Buffer", "aka", "cur", "loc", "offset", "h", "br", "read", "buff", "Buff", "bs", "history", "bytes", "b", "bb", "proc", "err", "begin", "que", "pb", "cap", "ref", "buffer", "len", "iter", "um", "cam", "late", "db", "wav", "raw", "vec", "conv", "etc", "bp", "uf", "seq", "queue", "bf", "cmd", "bin", "block", "pos", "n", "cache", "rb", "bag", "img", "bc", "batch"], "buf_size": ["buf_number", "buf_count", " buf_limit", "buf_SIZE", "buf_body", "buf_Size", "buf_range", "bufLenrange", "buf_limit", "ref_size", "ref_len", "uf_number", "buf_length", "buffer_size", "ref_length", " buf_body", "uf_count", "ref_range", "uf_Size", "buf_len", "bufLenlength", "uf_size", "bufLensize", "bufLenlen", "buffer_SIZE", "buffer_Size"], "i": ["p", "id", "l", "ii", "ini", "it", "q", "ish", "di", "gi", "y", "iter", "ci", "ami", "ims", "c", "cli", "n", " ii", "json", "ei", "inter", "r", "ix", "list", "ic", "any", "si", "oi", "j", "ji", "pointer", "b", "index", "zi", "iri", "pi", "x", "phi", "us", "limit", "is", "f", "ind", "mi", "port", "io", "ri", "ip", "ex", "multi", "print", "ti", "m", "ai", "im", " mi", "I", "go", "u", "init", "li", "sim", " iter", "ki", "bi", "ms", "v", "to", " bi", "me", " x", "uri", "o", "in", "info", "ui", "iu", "xi", "ir", "ij", "status", "err", "batch"], "frame_start_found": ["frame_reseterdone", "frame_end_Found", "frame_start_tested", "frame_startxfind", "frame_start_field", "frame_start_Found", "frame_startedfounded", "frame_start_based", "frame_start_loaded", "frame_end_bound", "frame_starterloaded", "frame_reset_done", "frame_startxFound", "frame_art_Found", "frame_end_count", "frame_start_defined", "frame_source_found", "frame_end_find", "frame_end_pos", "frame_startxfailed", "frame_startxfield", "frame_art_tested", "frame_end_to", "frame_start_fl", "frame_start___Found", "frame_reset_Found", "frame_end_err", "frame_start___pos", "frame_offset_found", "frame_start_founded", "frame_source_started", "frame_startxstarted", "frame_startedFound", "frame_start_allowed", "frame_reseterFound", "frame_end_fd", "frame_startfultop", "frame_offset_Found", "frame_start__find", "frame_starterfound", "frame_start__Found", "frame_end_tested", "frame_start___tested", "frame_offset_based", "frame_end_top", "frame_startxfound", "frame_starterfounded", "frame_start___fl", "frame_startedloaded", "frame_source_Found", "frame_start___found", "frame_start_count", "frame_end_founded", "frame_end_found", "frame_reseterfound", "frame_start_fd", "frame_reset_allowed", "frame_starterFound", "frame_start_started", "frame_source_defined", "frame_starterallowed", "frame_end_rest", "frame_starterdone", "frame_start_err", "frame_startfulrest", "frame_start___bound", "frame_reset_found", "frame_startfulfinder", "frame_start_rest", "frame_start_done", "frame_startedfound", "frame_start_to", "frame_end_loaded", "frame_end_field", "frame_end_fl", "frame_startfulfound", "frame_start_bound", "frame_start_finder", "frame_startxtested", "frame_startxdefined", "frame_start_find", "frame_start_failed", "frame_start___find", "frame_reseterallowed", "frame_start_top", "frame_start__finder", "frame_art_found", "frame_art_failed", "frame_end_finder", "frame_end_based", "frame_start__found", "frame_start_pos"], "state": ["commit", "key", "p", "id", "error", "msg", "STATE", "self", "handle", "reason", "where", "current", "range", "powered", "remote", "now", "area", "stats", "loop", "count", "message", "n", "start", "event", "be", "ch", "no", "there", "progress", "resource", "terror", "list", "post", "scope", "note", "rule", "or", "st", "power", "output", "mt", "pointer", "po", "State", "name", "index", "color", "comment", "timeout", "code", "stat", "used", "what", "ate", "priority", "part", "mode", "block", "action", "states", "monitor", "config", "controller", "debug", "ind", "component", "policy", "version", "port", "effect", "depth", "ne", "size", "we", "point", "level", "type", "print", "e", "can", "te", "unit", "sequence", "fire", "topic", "s", "local", "oe", "program", "out", "close", "function", "init", "max", "length", "to", "spec", "hash", "cor", "position", "parent", "offset", "style", "release", "in", "result", "info", "memory", "g", "trace", "class", "store", "tag", "status", "job", "test", "zone", "al", "cache", "see", "next", "value", "err"]}}
{"project": "FFmpeg", "commit_id": "0f8d3d8a462c0152ac489dbb013f6df027edd6c4", "target": 0, "func": "static av_cold int encode_init(AVCodecContext *avctx)\n\n{\n\n    FFV1Context *s = avctx->priv_data;\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    int i, j, k, m, ret;\n\n\n\n    if ((ret = ff_ffv1_common_init(avctx)) < 0)\n\n        return ret;\n\n\n\n    s->version = 0;\n\n\n\n    if ((avctx->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) ||\n\n        avctx->slices > 1)\n\n        s->version = FFMAX(s->version, 2);\n\n\n\n    // Unspecified level & slices, we choose version 1.2+ to ensure multithreaded decodability\n\n    if (avctx->slices == 0 && avctx->level < 0 && avctx->width * avctx->height > 720*576)\n\n        s->version = FFMAX(s->version, 2);\n\n\n\n    if (avctx->level <= 0 && s->version == 2) {\n\n        s->version = 3;\n\n    }\n\n    if (avctx->level >= 0 && avctx->level <= 4) {\n\n        if (avctx->level < s->version) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Version %d needed for requested features but %d requested\\n\", s->version, avctx->level);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        s->version = avctx->level;\n\n    }\n\n\n\n    if (s->ec < 0) {\n\n        s->ec = (s->version >= 3);\n\n    }\n\n\n\n    if ((s->version == 2 || s->version>3) && avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Version 2 needed for requested features but version 2 is experimental and not enabled\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n#if FF_API_CODER_TYPE\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (avctx->coder_type != -1)\n\n        s->ac = avctx->coder_type > 0 ? AC_RANGE_CUSTOM_TAB : AC_GOLOMB_RICE;\n\n    else\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    if (s->ac == 1) // Compatbility with common command line usage\n\n        s->ac = AC_RANGE_CUSTOM_TAB;\n\n    else if (s->ac == AC_RANGE_DEFAULT_TAB_FORCE)\n\n        s->ac = AC_RANGE_DEFAULT_TAB;\n\n\n\n    s->plane_count = 3;\n\n    switch(avctx->pix_fmt) {\n\n    case AV_PIX_FMT_YUV444P9:\n\n    case AV_PIX_FMT_YUV422P9:\n\n    case AV_PIX_FMT_YUV420P9:\n\n    case AV_PIX_FMT_YUVA444P9:\n\n    case AV_PIX_FMT_YUVA422P9:\n\n    case AV_PIX_FMT_YUVA420P9:\n\n        if (!avctx->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 9;\n\n    case AV_PIX_FMT_GRAY10:\n\n    case AV_PIX_FMT_YUV444P10:\n\n    case AV_PIX_FMT_YUV420P10:\n\n    case AV_PIX_FMT_YUV422P10:\n\n    case AV_PIX_FMT_YUVA444P10:\n\n    case AV_PIX_FMT_YUVA422P10:\n\n    case AV_PIX_FMT_YUVA420P10:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 10;\n\n    case AV_PIX_FMT_GRAY12:\n\n    case AV_PIX_FMT_YUV444P12:\n\n    case AV_PIX_FMT_YUV420P12:\n\n    case AV_PIX_FMT_YUV422P12:\n\n        s->packed_at_lsb = 1;\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 12;\n\n    case AV_PIX_FMT_GRAY16:\n\n    case AV_PIX_FMT_YUV444P16:\n\n    case AV_PIX_FMT_YUV422P16:\n\n    case AV_PIX_FMT_YUV420P16:\n\n    case AV_PIX_FMT_YUVA444P16:\n\n    case AV_PIX_FMT_YUVA422P16:\n\n    case AV_PIX_FMT_YUVA420P16:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample) {\n\n            s->bits_per_raw_sample = 16;\n\n        } else if (!s->bits_per_raw_sample) {\n\n            s->bits_per_raw_sample = avctx->bits_per_raw_sample;\n\n        }\n\n        if (s->bits_per_raw_sample <= 8) {\n\n            av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample invalid\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        s->version = FFMAX(s->version, 1);\n\n    case AV_PIX_FMT_GRAY8:\n\n    case AV_PIX_FMT_YA8:\n\n    case AV_PIX_FMT_YUV444P:\n\n    case AV_PIX_FMT_YUV440P:\n\n    case AV_PIX_FMT_YUV422P:\n\n    case AV_PIX_FMT_YUV420P:\n\n    case AV_PIX_FMT_YUV411P:\n\n    case AV_PIX_FMT_YUV410P:\n\n    case AV_PIX_FMT_YUVA444P:\n\n    case AV_PIX_FMT_YUVA422P:\n\n    case AV_PIX_FMT_YUVA420P:\n\n        s->chroma_planes = desc->nb_components < 3 ? 0 : 1;\n\n        s->colorspace = 0;\n\n        s->transparency = desc->nb_components == 4 || desc->nb_components == 2;\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 8;\n\n        else if (!s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 8;\n\n        break;\n\n    case AV_PIX_FMT_RGB32:\n\n        s->colorspace = 1;\n\n        s->transparency = 1;\n\n        s->chroma_planes = 1;\n\n        s->bits_per_raw_sample = 8;\n\n        break;\n\n    case AV_PIX_FMT_RGB48:\n\n        s->colorspace = 1;\n\n        s->chroma_planes = 1;\n\n        s->bits_per_raw_sample = 16;\n\n        s->use32bit = 1;\n\n        s->version = FFMAX(s->version, 1);\n\n        if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n\n            av_log(avctx, AV_LOG_ERROR, \"16bit RGB is experimental and under development, only use it for experiments\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        break;\n\n    case AV_PIX_FMT_0RGB32:\n\n        s->colorspace = 1;\n\n        s->chroma_planes = 1;\n\n        s->bits_per_raw_sample = 8;\n\n        break;\n\n    case AV_PIX_FMT_GBRP9:\n\n        if (!avctx->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 9;\n\n    case AV_PIX_FMT_GBRP10:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 10;\n\n    case AV_PIX_FMT_GBRP12:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 12;\n\n    case AV_PIX_FMT_GBRP14:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 14;\n\n    case AV_PIX_FMT_GBRP16:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 16;\n\n        else if (!s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = avctx->bits_per_raw_sample;\n\n        s->colorspace = 1;\n\n        s->chroma_planes = 1;\n\n        if (s->bits_per_raw_sample >= 16) {\n\n            s->use32bit = 1;\n\n            if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n\n                av_log(avctx, AV_LOG_ERROR, \"16bit RGB is experimental and under development, only use it for experiments\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n        s->version = FFMAX(s->version, 1);\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"format not supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n    av_assert0(s->bits_per_raw_sample >= 8);\n\n\n\n    if (s->bits_per_raw_sample > 8) {\n\n        if (s->ac == AC_GOLOMB_RICE) {\n\n            av_log(avctx, AV_LOG_INFO,\n\n                    \"bits_per_raw_sample > 8, forcing range coder\\n\");\n\n            s->ac = AC_RANGE_CUSTOM_TAB;\n\n        }\n\n    }\n\n    if (s->transparency) {\n\n        av_log(avctx, AV_LOG_WARNING, \"Storing alpha plane, this will require a recent FFV1 decoder to playback!\\n\");\n\n    }\n\n#if FF_API_PRIVATE_OPT\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (avctx->context_model)\n\n        s->context_model = avctx->context_model;\n\n    if (avctx->context_model > 1U) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid context model %d, valid values are 0 and 1\\n\", avctx->context_model);\n\n        return AVERROR(EINVAL);\n\n    }\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    if (s->ac == AC_RANGE_CUSTOM_TAB) {\n\n        for (i = 1; i < 256; i++)\n\n            s->state_transition[i] = ver2_state[i];\n\n    } else {\n\n        RangeCoder c;\n\n        ff_build_rac_states(&c, 0.05 * (1LL << 32), 256 - 8);\n\n        for (i = 1; i < 256; i++)\n\n            s->state_transition[i] = c.one_state[i];\n\n    }\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        s->quant_table_count = 2;\n\n        if (s->bits_per_raw_sample <= 8) {\n\n            s->quant_tables[0][0][i]=           quant11[i];\n\n            s->quant_tables[0][1][i]=        11*quant11[i];\n\n            s->quant_tables[0][2][i]=     11*11*quant11[i];\n\n            s->quant_tables[1][0][i]=           quant11[i];\n\n            s->quant_tables[1][1][i]=        11*quant11[i];\n\n            s->quant_tables[1][2][i]=     11*11*quant5 [i];\n\n            s->quant_tables[1][3][i]=   5*11*11*quant5 [i];\n\n            s->quant_tables[1][4][i]= 5*5*11*11*quant5 [i];\n\n        } else {\n\n            s->quant_tables[0][0][i]=           quant9_10bit[i];\n\n            s->quant_tables[0][1][i]=        11*quant9_10bit[i];\n\n            s->quant_tables[0][2][i]=     11*11*quant9_10bit[i];\n\n            s->quant_tables[1][0][i]=           quant9_10bit[i];\n\n            s->quant_tables[1][1][i]=        11*quant9_10bit[i];\n\n            s->quant_tables[1][2][i]=     11*11*quant5_10bit[i];\n\n            s->quant_tables[1][3][i]=   5*11*11*quant5_10bit[i];\n\n            s->quant_tables[1][4][i]= 5*5*11*11*quant5_10bit[i];\n\n        }\n\n    }\n\n    s->context_count[0] = (11 * 11 * 11        + 1) / 2;\n\n    s->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2;\n\n    memcpy(s->quant_table, s->quant_tables[s->context_model],\n\n           sizeof(s->quant_table));\n\n\n\n    for (i = 0; i < s->plane_count; i++) {\n\n        PlaneContext *const p = &s->plane[i];\n\n\n\n        memcpy(p->quant_table, s->quant_table, sizeof(p->quant_table));\n\n        p->quant_table_index = s->context_model;\n\n        p->context_count     = s->context_count[p->quant_table_index];\n\n    }\n\n\n\n    if ((ret = ff_ffv1_allocate_initial_states(s)) < 0)\n\n        return ret;\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    if (!s->transparency)\n\n        s->plane_count = 2;\n\n    if (!s->chroma_planes && s->version > 3)\n\n        s->plane_count--;\n\n\n\n    avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_h_shift, &s->chroma_v_shift);\n\n    s->picture_number = 0;\n\n\n\n    if (avctx->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) {\n\n        for (i = 0; i < s->quant_table_count; i++) {\n\n            s->rc_stat2[i] = av_mallocz(s->context_count[i] *\n\n                                        sizeof(*s->rc_stat2[i]));\n\n            if (!s->rc_stat2[i])\n\n                return AVERROR(ENOMEM);\n\n        }\n\n    }\n\n    if (avctx->stats_in) {\n\n        char *p = avctx->stats_in;\n\n        uint8_t (*best_state)[256] = av_malloc_array(256, 256);\n\n        int gob_count = 0;\n\n        char *next;\n\n        if (!best_state)\n\n            return AVERROR(ENOMEM);\n\n\n\n        av_assert0(s->version >= 2);\n\n\n\n        for (;;) {\n\n            for (j = 0; j < 256; j++)\n\n                for (i = 0; i < 2; i++) {\n\n                    s->rc_stat[j][i] = strtol(p, &next, 0);\n\n                    if (next == p) {\n\n                        av_log(avctx, AV_LOG_ERROR,\n\n                               \"2Pass file invalid at %d %d [%s]\\n\", j, i, p);\n\n                        av_freep(&best_state);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    p = next;\n\n                }\n\n            for (i = 0; i < s->quant_table_count; i++)\n\n                for (j = 0; j < s->context_count[i]; j++) {\n\n                    for (k = 0; k < 32; k++)\n\n                        for (m = 0; m < 2; m++) {\n\n                            s->rc_stat2[i][j][k][m] = strtol(p, &next, 0);\n\n                            if (next == p) {\n\n                                av_log(avctx, AV_LOG_ERROR,\n\n                                       \"2Pass file invalid at %d %d %d %d [%s]\\n\",\n\n                                       i, j, k, m, p);\n\n                                av_freep(&best_state);\n\n                                return AVERROR_INVALIDDATA;\n\n                            }\n\n                            p = next;\n\n                        }\n\n                }\n\n            gob_count = strtol(p, &next, 0);\n\n            if (next == p || gob_count <= 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"2Pass file invalid\\n\");\n\n                av_freep(&best_state);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            p = next;\n\n            while (*p == '\\n' || *p == ' ')\n\n                p++;\n\n            if (p[0] == 0)\n\n                break;\n\n        }\n\n        if (s->ac == AC_RANGE_CUSTOM_TAB)\n\n            sort_stt(s, s->state_transition);\n\n\n\n        find_best_state(best_state, s->state_transition);\n\n\n\n        for (i = 0; i < s->quant_table_count; i++) {\n\n            for (k = 0; k < 32; k++) {\n\n                double a=0, b=0;\n\n                int jp = 0;\n\n                for (j = 0; j < s->context_count[i]; j++) {\n\n                    double p = 128;\n\n                    if (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1] > 200 && j || a+b > 200) {\n\n                        if (a+b)\n\n                            p = 256.0 * b / (a + b);\n\n                        s->initial_states[i][jp][k] =\n\n                            best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)];\n\n                        for(jp++; jp<j; jp++)\n\n                            s->initial_states[i][jp][k] = s->initial_states[i][jp-1][k];\n\n                        a=b=0;\n\n                    }\n\n                    a += s->rc_stat2[i][j][k][0];\n\n                    b += s->rc_stat2[i][j][k][1];\n\n                    if (a+b) {\n\n                        p = 256.0 * b / (a + b);\n\n                    }\n\n                    s->initial_states[i][j][k] =\n\n                        best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)];\n\n                }\n\n            }\n\n        }\n\n        av_freep(&best_state);\n\n    }\n\n\n\n    if (s->version > 1) {\n\n        int plane_count = 1 + 2*s->chroma_planes + s->transparency;\n\n        s->num_v_slices = (avctx->width > 352 || avctx->height > 288 || !avctx->slices) ? 2 : 1;\n\n\n\n        if (avctx->height < 5)\n\n            s->num_v_slices = 1;\n\n\n\n        for (; s->num_v_slices < 32; s->num_v_slices++) {\n\n            for (s->num_h_slices = s->num_v_slices; s->num_h_slices < 2*s->num_v_slices; s->num_h_slices++) {\n\n                int maxw = (avctx->width  + s->num_h_slices - 1) / s->num_h_slices;\n\n                int maxh = (avctx->height + s->num_v_slices - 1) / s->num_v_slices;\n\n                if (s->num_h_slices > avctx->width || s->num_v_slices > avctx->height)\n\n                    continue;\n\n                if (maxw * maxh * (int64_t)(s->bits_per_raw_sample+1) * plane_count > 8<<24)\n\n                    continue;\n\n                if (avctx->slices == s->num_h_slices * s->num_v_slices && avctx->slices <= MAX_SLICES || !avctx->slices)\n\n                    goto slices_ok;\n\n            }\n\n        }\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unsupported number %d of slices requested, please specify a \"\n\n               \"supported number with -slices (ex:4,6,9,12,16, ...)\\n\",\n\n               avctx->slices);\n\n        return AVERROR(ENOSYS);\n\nslices_ok:\n\n        if ((ret = write_extradata(s)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    if ((ret = ff_ffv1_init_slice_contexts(s)) < 0)\n\n        return ret;\n\n    s->slice_count = s->max_slice_count;\n\n    if ((ret = ff_ffv1_init_slices_state(s)) < 0)\n\n        return ret;\n\n\n\n#define STATS_OUT_SIZE 1024 * 1024 * 6\n\n    if (avctx->flags & AV_CODEC_FLAG_PASS1) {\n\n        avctx->stats_out = av_mallocz(STATS_OUT_SIZE);\n\n        if (!avctx->stats_out)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < s->quant_table_count; i++)\n\n            for (j = 0; j < s->max_slice_count; j++) {\n\n                FFV1Context *sf = s->slice_context[j];\n\n                av_assert0(!sf->rc_stat2[i]);\n\n                sf->rc_stat2[i] = av_mallocz(s->context_count[i] *\n\n                                             sizeof(*sf->rc_stat2[i]));\n\n                if (!sf->rc_stat2[i])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7852, "substitutes": {"avctx": [" avcontext", "averreq", "wavctx", "ajpkg", "averconn", " avhandle", "ajctl", "afcmd", "avercv", "varkt", "abtmp", "abctx", "avcv", "avecrit", "avcmd", "ajkw", "navtx", "avectx", "averkt", " avcv", "avepy", "avhandle", "avectl", "wavcmd", "avekl", "avecu", "avercu", "ajnp", "avertmp", "averkl", "vrjp", "navcfg", "avernp", "averhandle", "avpid", " avcmp", "varcfg", "abcontext", "savcontext", "ajjp", "ajcmd", " avreq", "vrctx", "vertx", "navkt", "avcu", "afctx", "varctx", "navctx", "avsys", "savtmp", "savctx", "abtx", "avnp", "avetx", "averkw", " avkt", " avctl", " avjac", "ajkl", "avejp", "ajcfg", " avtx", "avcrit", "avercmp", "navcrit", "afpy", "afcu", "avctl", "averjac", "avcp", "avetmp", "avpkg", "navcp", "navcu", "avercontext", "ajtx", "avcontext", "ajobj", "avtmp", "averctx", "averobj", "avekt", "ajjac", "ajctx", " avjp", "avercmd", "verctl", "ajreq", "navcmd", "navpid", "avkt", "vrcmp", "averpy", "navpy", "navnp", "vrcontext", "avesys", "averpkg", "avercfg", "avjac", "avcfg", "navkl", "avecp", "ajcu", "ajkt", "avjp", "avecv", "navpkg", "wavkt", "navobj", "averjp", "avconn", "avobj", "ajcontext", "varjac", " avcu", "avecontext", "afkl", "avreq", " avcp", "afconn", "ajsys", "avertx", "avkw", "afcontext", "wavpy", " avtmp", "ajcrit", "vercfg", "varpid", "avepid", "varcrit", "avcmp", "aftx", "aversys", "avkl", "aveconn", "avejac", "avercp", "avekw", "navjac", " avcfg", "avpy", "avereq", "avtx", "verctx", "avehandle", "ajcp", "savcu"], "s": ["sc", "tests", "t", "os", "S", "sports", "ds", "details", "is", "ms", "bes", "v", "vs", "ps", "ins", "spec", "sets", "sm", "gets", "less", "set", "ss", "ports", "aws", "h", "tes", "changes", "bs", "js", "ns", "ows", "b", "hs", "mods", "sq", "g", "ses", "sts", "rs", "gs", "y", "tags", "ts", "es", "ops", "stats", "results", "utils", "fs", "its", "sv", "cs", "ims", "sb", "des", "as", "ls", "als", "ats", "qs", "params", "eps", "sw", "services"], "desc": ["sc", "doc", "ds", "esc", "ec", "col", " des", "msg", "dc", "sub", "txt", "ext", "asc", "description", "mem", "def", "dir", "buf", "enc", "cmp", "rec", "Desc", "disc", "meta", "des", "cmd"], "i": ["li", "bi", "v", "ii", "r", "mi", "it", "ic", "si", "h", "o", "b", "ij", "y", "ci", "ik", "pi", " mi", "x", "I", "n", " ii"], "j": ["dj", "jj", "v", "l", "ii", "jl", "q", "jc", "aj", "size", "ji", "js", "jump", "b", "index", "g", "ij", "kj", "uj", "ja", "J", "pos", "n", "z"], "k": ["ka", "key", "kh", "ke", "K", "ki", "sk", "kn", "mk", "kk", "kr", "v", "kid", "q", "ks", "km", "kind", "kl", "kj", "ck", "ko", "ik", "ek", "kg", "ak", "tk", "z"], "m": ["gm", "bm", "ms", "l", "rm", "v", "mi", "em", "sm", "q", "msg", "km", "h", "o", "nm", "mem", "mt", "mn", "M", "mb", "vm", "mm", "mo", "tm", "n", "mc"], "ret": ["out", "t", "reset", "gt", "fi", "el", "details", "success", "ll", "RET", "rm", "att", "nt", "re", "mi", "cont", "Ret", "ft", "rets", "cert", "val", "fun", "ry", "rem", "gc", "mem", "mt", "result", "ref", "len", "status", "print", "res", "det", "try", "tr", "ter", "reg", "lo", " RET", "alt", "rt", "err"], "coder_type": ["coding_name", "coderetyfamily", "coding_typ", "coderityerror", "coder_typ", "coderitytypes", "coding_error", "coderityfamily", "coder_error", "coderitytyp", "coder_family", "coderitytype", "coding_class", "coderityname", "coder_name", "coder_class", "coder_types", "coderetytyp", "coderetyname", "coding_family", "coding_type", "coderityclass", "coding_types", "coderetytype"], "FF_ENABLE_DEPRECATION_WARNINGS": ["FF_ENABLE_DEPRECATION_WARNINGIES", "FF_ENABLE_DEPRECATION_WARNs", "FF_ENABLE_DEPRECATION_WARIES", "FF_ENABLE_DEPRECATION_WARNIES", "FF_ENABLE_DEPRECATION_ERRORs", "FF_ENABLE_DEPRECATION_WARs", "FF_ENABLE_DEPRECATION_ERRORIES", "FF_ENABLE_DEPRECATION_WARNINGs", "FF_ENABLE_DEPRECATION_ERRORS", "FF_ENABLE_DEPRECATION_WARS", "FF_ENABLE_DEPRECATION_WARNS"]}}
{"project": "FFmpeg", "commit_id": "d85aa76115214183e7e3b7d65e950da61474959a", "target": 0, "func": "static int hls_slice_data_wpp(HEVCContext *s, const HEVCNAL *nal)\n\n{\n\n    const uint8_t *data = nal->data;\n\n    int length          = nal->size;\n\n    HEVCLocalContext *lc = s->HEVClc;\n\n    int *ret = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));\n\n    int *arg = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));\n\n    int64_t offset;\n\n    int startheader, cmpt = 0;\n\n    int i, j, res = 0;\n\n\n\n    if (!ret || !arg) {\n\n        av_free(ret);\n\n        av_free(arg);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n\n\n    if (!s->sList[1]) {\n\n        ff_alloc_entries(s->avctx, s->sh.num_entry_point_offsets + 1);\n\n\n\n\n\n        for (i = 1; i < s->threads_number; i++) {\n\n            s->sList[i] = av_malloc(sizeof(HEVCContext));\n\n            memcpy(s->sList[i], s, sizeof(HEVCContext));\n\n            s->HEVClcList[i] = av_mallocz(sizeof(HEVCLocalContext));\n\n            s->sList[i]->HEVClc = s->HEVClcList[i];\n\n        }\n\n    }\n\n\n\n    offset = (lc->gb.index >> 3);\n\n\n\n    for (j = 0, cmpt = 0, startheader = offset + s->sh.entry_point_offset[0]; j < nal->skipped_bytes; j++) {\n\n        if (nal->skipped_bytes_pos[j] >= offset && nal->skipped_bytes_pos[j] < startheader) {\n\n            startheader--;\n\n            cmpt++;\n\n        }\n\n    }\n\n\n\n    for (i = 1; i < s->sh.num_entry_point_offsets; i++) {\n\n        offset += (s->sh.entry_point_offset[i - 1] - cmpt);\n\n        for (j = 0, cmpt = 0, startheader = offset\n\n             + s->sh.entry_point_offset[i]; j < nal->skipped_bytes; j++) {\n\n            if (nal->skipped_bytes_pos[j] >= offset && nal->skipped_bytes_pos[j] < startheader) {\n\n                startheader--;\n\n                cmpt++;\n\n            }\n\n        }\n\n        s->sh.size[i - 1] = s->sh.entry_point_offset[i] - cmpt;\n\n        s->sh.offset[i - 1] = offset;\n\n\n\n    }\n\n    if (s->sh.num_entry_point_offsets != 0) {\n\n        offset += s->sh.entry_point_offset[s->sh.num_entry_point_offsets - 1] - cmpt;\n\n        if (length < offset) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"entry_point_offset table is corrupted\\n\");\n\n            res = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n        s->sh.size[s->sh.num_entry_point_offsets - 1] = length - offset;\n\n        s->sh.offset[s->sh.num_entry_point_offsets - 1] = offset;\n\n\n\n    }\n\n    s->data = data;\n\n\n\n    for (i = 1; i < s->threads_number; i++) {\n\n        s->sList[i]->HEVClc->first_qp_group = 1;\n\n        s->sList[i]->HEVClc->qp_y = s->sList[0]->HEVClc->qp_y;\n\n        memcpy(s->sList[i], s, sizeof(HEVCContext));\n\n        s->sList[i]->HEVClc = s->HEVClcList[i];\n\n    }\n\n\n\n    avpriv_atomic_int_set(&s->wpp_err, 0);\n\n    ff_reset_entries(s->avctx);\n\n\n\n    for (i = 0; i <= s->sh.num_entry_point_offsets; i++) {\n\n        arg[i] = i;\n\n        ret[i] = 0;\n\n    }\n\n\n\n    if (s->ps.pps->entropy_coding_sync_enabled_flag)\n\n        s->avctx->execute2(s->avctx, hls_decode_entry_wpp, arg, ret, s->sh.num_entry_point_offsets + 1);\n\n\n\n    for (i = 0; i <= s->sh.num_entry_point_offsets; i++)\n\n        res += ret[i];\n\nerror:\n\n    av_free(ret);\n\n    av_free(arg);\n\n    return res;\n\n}\n", "idx": 7854, "substitutes": {"s": ["p", "https", "times", "l", "gets", "self", "ns", "sq", "ses", "gs", "stats", "xs", "its", "ims", "c", "n", "qs", "services", "S", "a", "r", "vs", "ps", "ins", "w", "less", "ss", "h", "tes", "changes", "js", "b", "sts", "ts", "ops", "bits", "fs", "csv", "sb", "src", "ats", "sys", "tests", "sports", "details", "is", "f", "ports", "aws", "so", "views", "bs", "sh", "scl", "sg", "rs", "ids", "m", "acs", "bis", "cs", "as", "ls", "os", "ds", "south", "ms", "v", "spec", "comm", "o", "hs", "ssl", "g", "status", "es", "sv", "parts", "sql", "sw"], "nal": ["gnAL", "nale", " nali", "anAL", "annalid", "nally", " nale", "gnally", "nals", " nAL", "nanalid", "gnali", "nanal", "Nal", "annAL", "annali", "nAL", " nals", "norAL", "Nalid", "Nald", " nald", "norald", "anals", "nali", "anally", "analer", "nanaler", "Naler", "norals", "Nals", "naler", "analid", "nanAL", "gnalid", "nald", "anal", "anale", "noral", "annal", "nalid", "gnale", "NAL", " nally", "gnal", " nalid", " naler"], "data": ["rew", "extra", "t", "p", "f", "d", "length", "mu", "DATA", "map", "Data", "empty", "dat", "size", "mem", "bytes", "def", "buf", "type", "ref", "buffer", "ata", "len", "area", "sample", "m", "res", "content", "bits", "table", "values", "base", "window", "block", "array", "input", "value", "cache", "batch"], "lc": ["tc", "rc", "sc", "lb", "lu", "lf", "lp", "ln", "ll", "vc", "l", "tl", "ec", "ctx", "lr", "pc", "ic", "dc", "rl", "cl", "cc", "dl", "kl", "fc", "LC", "wl", "ly", "las", "xc", "acl", "cs", "lv", "bc", "c", "cli", "lic", "ls", "mc"], "ret": ["out", "t", "reset", "elt", "gt", "tmp", "success", "ll", "nil", "RET", "arr", "r", "re", "nt", "Ret", "ft", "rets", "red", "val", "fun", "req", "rem", "rex", "mem", "mt", "result", "def", "resp", "rev", "ref", "buffer", "repl", "res", "tr", "final", "aux", "back", "alt", "rt", "reg"], "arg": ["Arg", "doc", "ring", "ray", "ig", "argument", "arr", "pg", "call", "ag", "arc", "val", "aj", "ax", "attr", "arp", "cell", "mem", "ary", "par", "mac", "g", "ref", "ma", "target", "ar", "len", "op", "tag", "res", "local", "args", "au", "var", "num", "ac", "aux", "param", "ob", "vol", "arm", "ack", "reg", "cmd", "event"], "offset": ["ptr", "af", "rc", "et", "p", "reset", "bound", "f", "origin", "length", "ow", "ut", "error", "position", "prefix", "padding", "address", "set", "onto", "alias", "o", "option", "pad", "location", "size", " overhead", "off", "mem", "pointer", "mt", "index", "slot", "point", "info", "shift", "trace", "timeout", "scroll", "range", "ref", "buffer", "row", "zero", "area", "oot", "end", "coord", "flag", "addr", "base", "offs", "table", "ta", "Offset", "start", "next", "seek"], "startheader": [" startheaders", "beginheader", "beginhead", "startHeader", "endheaders", "openheaders", "Startheader", "startpadding", "Startpadding", "endHeader", "arttable", "maxtable", " startpadding", "startoffset", "startingpadding", "endheading", "beginheading", "firstHeader", "startframe", "maxheader", " starttable", "artheader", "firstheaders", "firstheader", "starttimer", "StartHeader", "starthead", "maxhead", " startheading", "opentimer", " startoffset", "endheader", "endhead", "stopHeader", "stopheaders", " startframe", "openpadding", "stoppadding", "arthead", "artframe", " starttimer", "startheading", "stopheader", "firstpadding", "beginoffset", "endoffset", "startheaders", "maxframe", " starthead", "Startheaders", "endpadding", "startingtimer", "startingheader", "openheader", "starttable", "startingheaders", " startHeader"], "i": ["p", "id", "l", "ii", "ini", "it", "hi", "ish", "di", "gi", "iq", "ie", "y", "remote", "ci", "ami", "ims", "qi", "c", "n", "start", " ii", "a", "MI", "ix", "ic", "si", "oi", "ji", "index", "name", "zi", "instance", "pi", "x", "phi", "ia", "is", "f", "ind", "mi", "ri", "io", "chain", "ip", "ex", "point", "multi", "e", "ti", "m", "ai", "im", "I", "by", "dr", "init", "li", "sim", "ki", "bi", "v", "to", "me", "\u0438", "uri", "in", "info", "g", "ui", "iu", "ij", "xi", "status", "batch"], "j": ["json", "fr", "dj", "p", "bj", "bi", "f", "ind", "v", "jj", "l", "d", "jl", "it", "q", "note", "jc", "obj", "str", "aj", "k", "jo", "h", "br", "o", "pt", "bs", "ji", "js", "jump", "b", "index", "oj", "adj", "g", "pr", "ij", "kj", "y", "jp", "uj", "m", "ja", "job", "im", "jit", "x", "je", "J", "n", "pos", "z", "ev"], "cmpt": ["sempt", "cmpty", " cmpc", " cmbd", "cmply", "cmpl", "mrct", "fmpt", "gcpty", "cmpc", "fmdr", "mcpl", "cmptr", "kmpty", " cmpty", " cmpr", "commpc", "gcpc", "semptr", "commptr", "rompr", "kmpt", "kmpr", "cmbd", " cmps", "fmpl", "mrpl", "gcpt", "commpos", "mrpt", "fmct", "cmpr", " cmptr", "sempr", "mcpt", "commpty", " cmpos", "sembd", "rompos", "rompty", "cmps", "commpr", "kmply", "commbd", "commply", "mcdr", "cmpos", "mrdr", "rompt", " cmply", "commps", "kmps", "mcct", "commpt", "kmpos", "cmdr", "gcps", "cmct"]}}
{"project": "qemu", "commit_id": "c1076c3e13a86140cc2ba29866512df8460cc7c2", "target": 0, "func": "static void pxa2xx_lcdc_dma0_redraw_rot0(PXA2xxLCDState *s,\n\n                hwaddr addr, int *miny, int *maxy)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int src_width, dest_width;\n\n    drawfn fn = NULL;\n\n    if (s->dest_width)\n\n        fn = s->line_fn[s->transp][s->bpp];\n\n    if (!fn)\n\n        return;\n\n\n\n    src_width = (s->xres + 3) & ~3;     /* Pad to a 4 pixels multiple */\n\n    if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp)\n\n        src_width *= 3;\n\n    else if (s->bpp > pxa_lcdc_16bpp)\n\n        src_width *= 4;\n\n    else if (s->bpp > pxa_lcdc_8bpp)\n\n        src_width *= 2;\n\n\n\n    dest_width = s->xres * s->dest_width;\n\n    *miny = 0;\n\n    framebuffer_update_display(surface, s->sysmem,\n\n                               addr, s->xres, s->yres,\n\n                               src_width, dest_width, s->dest_width,\n\n                               s->invalidated,\n\n                               fn, s->dma_ch[0].palette, miny, maxy);\n\n}\n", "idx": 7866, "substitutes": {"s": ["p", "conf", "l", "sl", "ns", "sq", "ses", "gs", "sym", "stats", "xs", "results", "comments", "its", "ims", "c", "settings", "des", "n", "qs", "eps", "S", "a", "ps", "vs", "ins", "obj", "less", "ss", "h", "changes", "mods", "js", "b", "sts", "ts", "ops", "bits", "fs", "sis", "args", "sb", "als", "series", "ats", "sys", "states", "sports", "details", "is", "ports", "events", "aws", "so", "views", "bs", "ex", "rs", "m", "conv", "cs", "as", "ls", "ags", "t", "grades", "ds", "ms", "v", "spec", "ies", "se", "comm", "hs", "g", "status", "es", "sv", "aunts", "parts", "params", "sw"], "addr": ["ptr", "rc", "dr", " err", "inter", "a", " plat", "id", "r", " mac", "ix", "ctx", "ad", " add", "address", "ag", "offset", "amp", " work", "or", "alias", "handle", "pad", "adr", "arp", "ip", " af", "mt", " loc", "usr", " address", " pad", "act", " ka", "at", "rs", "ar", "ord", "rn", "coord", "hw", "Address", "src", "nl", "add", "err", " act"], "miny": [" minx", "mnY", "minny", "Minny", "smallY", " minsy", "minsyy", " minY", "minsny", "mnny", "Miny", "minyt", "minicy", "minty", " minny", "mnx", "minx", "smallcy", "minyy", "mnyt", "mncy", "smally", "mincy", "mnsy", "minsy", "minticy", "minsicy", "mny", "smallx", "Minyt", "Minyy", "Minicy", "mintny", " mincy", "minY", "mintyy", "Minsy", " minyt"], "maxy": ["maniley", "manaxy", "lery", "gmaxy", "lury", "manoy", "moy", " maj", "mery", "laxy", "manny", " mury", " mery", "hiley", "maj", "mny", "laj", " mny", "hoy", " moy", " miley", "gmury", "haxy", "miley", "hny", "gmery", "mury", "gmaj"], "surface": ["tty", "view", "screen", "sc", "vp", "form", "f", "fac", "v", "draw", "fd", "con", "map", " surf", "h", "pad", "profile", "source", "cell", "proc", "np", "result", "console", "sheet", "interface", "plane", "buffer", "um", "display", "face", "bridge", "tile", " surfaces", "window", "uf", "sb", "tain", "glass", "sur", "wrapper"], "src_width": ["src2strength", "src2weight", "src_strength", "src_driver", "srclensize", "config_width", "srclenplatform", " src_weight", "src_size", "config_size", "dest_strength", "src_platform", "src_Width", "dest_driver", "src_height", "src2height", "src2radius", " src_height", "src7size", "config_length", "src64strength", "configlenwidth", "dest_radius", " src_loss", "configlenplatform", "src_radius", "src64radius", "src_weight", "dest_height", "dest_length", "configlensize", "src2Width", "src7driver", "srclenlength", "src64width", "config_platform", "src_length", "src7length", "srclenwidth", "configlenlength", "src2width", "src7width", " src_length", "src2length", "src64length", "src_loss", "dest_size", " src_Width"], "dest_width": ["dest___height", "src_Width", "src_height", "dest_weight", "dest_Width", "dest___max", "dest_radius", "orig_max", "src_depth", "orig_width", "src_weight", "dest_height", "dest_length", " dest_radius", "orig_height", "dest___size", "dest___width", "src_length", " dest_weight", "orig_size", "dest_max", " dest_height", "dest_depth", "dest_size", " dest_Width"]}}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_dmar_q35(GArray *table_data, GArray *linker)\n\n{\n\n    int dmar_start = table_data->len;\n\n\n\n    AcpiTableDmar *dmar;\n\n    AcpiDmarHardwareUnit *drhd;\n\n\n\n    dmar = acpi_data_push(table_data, sizeof(*dmar));\n\n    dmar->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1;\n\n    dmar->flags = 0;    /* No intr_remap for now */\n\n\n\n    /* DMAR Remapping Hardware Unit Definition structure */\n\n    drhd = acpi_data_push(table_data, sizeof(*drhd));\n\n    drhd->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT);\n\n    drhd->length = cpu_to_le16(sizeof(*drhd));   /* No device scope now */\n\n    drhd->flags = ACPI_DMAR_INCLUDE_PCI_ALL;\n\n    drhd->pci_segment = cpu_to_le16(0);\n\n    drhd->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR);\n\n\n\n    build_header(linker, table_data, (void *)(table_data->data + dmar_start),\n\n                 \"DMAR\", table_data->len - dmar_start, 1, NULL);\n\n}\n", "idx": 7869, "substitutes": {"dmar": ["pdmar", "ddtar", "pdmad", "dgar", "ddmad", " dcor", "dramber", "drmad", "dogar", "drover", "ddmar", "drtar", "dmad", "dotar", " dma", "Dtar", "dover", "domad", "drmar", "pdma", "damar", "dacor", " dover", "daamber", "Dgar", "dtar", "damber", "drcor", " dvar", "ddvar", "Dma", "dvar", " dgar", "dcor", "daover", "Dmar", "domar", "doma", "dma", " damber", "pdtar", "drvar", " dmad", "Dmad", " dtar"], "drhd": ["grhd", "drmHD", "ardh", " drHD", "derkb", "vrHD", "drhs", "Drhs", "drhim", "hrht", "Drht", "rsht", "drha", "mrkb", "mrsd", "drhl", "srdh", "prht", " drsd", "drht", "drkb", "ptrld", "ptrHD", "ptrdd", "drmhd", "mrhim", " drpd", "grdh", "srpd", "prhl", "rsdh", "adrHD", "drder", " drkb", "ptrhim", " drht", "hrhd", "derha", "drds", "ptrstd", "ardhd", "drpd", "rshd", "drdh", " drhim", " drhl", "drmhs", " drdh", "Drhd", "Drdh", "drmht", "vrld", "mrhd", " drstd", "grhl", "drstd", "arpd", "ardpd", "drdd", "adrpd", "rshs", "drld", "drmder", "srhd", "prdh", "adrdh", "prhd", "hrpd", "srder", "ardhs", "drHD", "mrha", "hrhs", " drds", "mrstd", " drdd", "mrdd", "dersd", " drld", "arhd", "arhs", "grht", "ptrds", " drhs", "ptrhd", "vrhd", "hrdh", "drmdh", "vrds", "drsd", "derhd", "arddh", " drha", "adrhd", "adrder", "adrhs", "adrht", "drmpd"]}}
{"project": "qemu", "commit_id": "db1da1f2b5f3a2383030438553988f0734a97dbe", "target": 0, "func": "static GtkWidget *gd_create_menu_machine(GtkDisplayState *s, GtkAccelGroup *accel_group)\n\n{\n\n    GtkWidget *machine_menu;\n\n    GtkWidget *separator;\n\n\n\n    machine_menu = gtk_menu_new();\n\n    gtk_menu_set_accel_group(GTK_MENU(machine_menu), accel_group);\n\n\n\n    s->pause_item = gtk_check_menu_item_new_with_mnemonic(_(\"_Pause\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->pause_item);\n\n\n\n    separator = gtk_separator_menu_item_new();\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);\n\n\n\n    s->reset_item = gtk_menu_item_new_with_mnemonic(_(\"_Reset\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->reset_item);\n\n\n\n    s->powerdown_item = gtk_menu_item_new_with_mnemonic(_(\"Power _Down\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->powerdown_item);\n\n\n\n    separator = gtk_separator_menu_item_new();\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);\n\n\n\n    s->quit_item = gtk_menu_item_new_with_mnemonic(_(\"_Quit\"));\n\n    gtk_menu_item_set_accel_path(GTK_MENU_ITEM(s->quit_item),\n\n                                 \"<QEMU>/Machine/Quit\");\n\n    gtk_accel_map_add_entry(\"<QEMU>/Machine/Quit\",\n\n                            GDK_KEY_q, GDK_CONTROL_MASK);\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->quit_item);\n\n\n\n    return machine_menu;\n\n}\n", "idx": 7873, "substitutes": {"s": ["states", "tests", "t", "os", "S", "p", "conf", "ds", "details", "d", "r", "ps", "vs", "ins", "ies", "sets", "sm", "sl", "gets", "ss", "ports", "events", "aws", "comm", "dates", "changes", "views", "bs", "styles", "js", "ns", "hs", "sq", "ries", "g", "ses", "sts", "pers", "rs", "gs", "plays", "ts", "e", "ops", "stats", "m", "comments", "its", "fs", "sv", "sis", "cs", "ims", "sb", "c", "as", "parts", "ls", "als", "series", "n", "ats", "qs", "ers", "se", "services"], "accel_group": ["accelablefunction", "acceler_groups", "accelggroup", "acceler_data", "accelablecontext", "accel_groups", "accel_data", "acceler_function", "accelablegroups", "acceler_group", "accelablegroup", "accel_function", "accelguser", "acceler_user", "accelggroups", "accel_user", "acceler_context", "accel_context", "accelgdata"], "machine_menu": ["machineetdirectory", "createdThemenu", "server_origin", "sessioningdocument", "machine_block", "machine_context", " machine_item", "machine_label", "machineJmenu", "machineedcontext", "createdTheblock", "mobile_menu", "mobileetmenu", "machine8current", "mobile_label", "mobileetcurrent", " machine_module", "machine64mi", "machineetlabel", "machineingdocument", "machine_module", "machineThemenu", "machineixmenu", "machineedmenu", "target_menu", " machine_global", "server8origin", "machineixdisplay", "machine_queue", "createdThegroup", "machineedcurrent", "targetJtable", "createdTheui", "targetJmain", "sessioningmenu", "human_current", "target_main", "machine_current", "machineingloader", "machine_group", "human_loader", "mobileetlabel", "machine___module", "created_block", "server8site", "machineetmenu", "machine___panel", "machine_loader", "machineingdatabase", "machine12directory", "machine_item", "machine_directory", "session_database", " machine_display", "server8directory", "machine_panel", "machineJorigin", "targetJmenu", "mobileetdirectory", "created_group", "humaningloader", "session_document", "machine8loader", "mobile_directory", "created_menu", "session_menu", "machineedglobal", "machineTheblock", "machine_mi", "machineingcurrent", "machine64menu", "server_site", "machine12menu", "humaningmenu", "targetJdirectory", "machine_category", "machine64category", "machineTheui", "machine_document", "humaningcurrent", "target_directory", " machine_document", "machineeddisplay", "machineJtable", "machine12table", "machine_table", "machine8origin", "machine_ui", "server_menu", "machine___ui", "mobile_current", "humaningcontext", " machine_queue", "human_context", "server8menu", "machineingmenu", "machine_origin", "machine_display", "machineJsite", "machineingcontext", "sessioningdatabase", " machine_category", "machineJmain", " machine_mi", "machine_main", "machine12main", "server_directory", "machine_database", "machine8menu", "machine8context", "machine_site", "machine_global", "machineThegroup", "created_ui", "sessioningui", "machineJdirectory", "session_ui", "machine___group", "target_table", "machine8label", "machine___block", "machine8site", "machine8directory", "machineingui", "machineixglobal", " machine_panel", "human_menu", "machineedloader", "machine___menu", "machineetcurrent"], "separator": ["participator", "alternATOR", "generATOR", "separater", "parinator", "genercer", "severinator", "alternager", "separinator", " separoder", "alterner", "separATOR", "perATOR", "geroder", "participer", "participinator", "variator", "separoder", "severator", "celerner", "separant", " separner", "gerant", "terminer", "separner", "terminATOR", "gerator", "parator", " separater", "perator", "varioder", "celerator", "parner", "celeroder", "perater", "terminator", "severant", "variinator", "percer", "terminager", " separager", " separinator", "paroder", "termininator", "gerinator", "generater", "generator", "variant", "separer", " separer", "participATOR", "celerinator", "separager", "severoder", " separATOR", "alternator", "separcer", " separcer"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,\n\n                                     uint64_t value, unsigned size)\n\n{\n\n    mv88w8618_flashcfg_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_FLASHCFG_CFGR0:\n\n        s->cfgr0 = value;\n\n        break;\n\n    }\n\n}\n", "idx": 7874, "substitutes": {"opaque": ["opificate", "iopificate", "iopa", " opane", "obacity", "iopaque", "oificate", "opa", "oaque", " opulus", "oplacity", "oplulus", "oplificate", "iopac", "oplane", "oplaque", "obaque", "obulus", "oplac", "obane", "opulus", "oac", "opane", "opla", "opacity", " opacity", "opac", "oa"], "offset": ["top", "key", "id", "length", "position", "prefix", "tz", "padding", "address", "set", "style", "alias", "o", "attribute", "location", "off", "pointer", "slot", "index", "point", "shift", "trace", "usage", "type", "buffer", "command", "alloc", "area", "op", "len", "flag", "addr", "priority", "window", "owner", "mask", "Offset", "ta", "count", "oid", "start", "pos", "cmd", "seek"], "value": ["key", "json", "weight", "v", "data", "length", "field", "position", "address", "val", "set", "ue", "package", "attribute", "vector", "state", "index", "name", " Value", "buf", "memory", "type", "buffer", "text", "ay", "scale", "unit", "values", "operator", "byte", "Value", "VALUE", "number", "expression", "message", "total", "input"], "size": ["Size", "weight", "sum", "sp", "data", "SIZE", "length", "ize", "address", "h", "mem", "bytes", "name", "shift", "cap", "type", "command", "len", "e", "num", "count", "message", "n", "z", "cmd"], "s": ["t", "S", "p", "ds", "a", "v", "sp", "r", "ps", "q", "sl", "w", "ss", "j", "h", "o", "bs", "i", "ns", "hs", "b", "sq", "an", "g", "socket", "sts", "rs", "gs", "ts", "es", "e", "stats", "m", "fs", "sb", "c", "ls", "n", "qs"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_get_fd(void *opaque)\n\n{\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n\n\n    return rdma->comp_channel->fd;\n\n}\n", "idx": 7881, "substitutes": {"opaque": ["ocoster", "ompaques", "ocaque", "opaques", "OPaque", "poposit", "opsaque", "popaque", "opsacity", "obaque", "opsaques", "ompque", "opque", "oposit", "obque", "ompaque", "OPoster", "obosit", "ocaques", "oposter", "popque", "popaques", "ocacity", "opacity", "opsoster", "obaques", "OPaques", "OPacity", "omposit"], "rfile": ["rarFile", "rlog", "rfiles", "srobject", "Rfiles", "rFILE", "robject", " rFile", " robject", "rarfile", "rdlog", "srFile", " rfiles", "Rfile", "rarFILE", "srFILE", " rFILE", "Rlog", "rarobject", "rdfile", "rFile", "srfile", "rdfiles", " rlog"], "rdma": ["rrla", "rtmas", "rnmu", "rtma", "rdna", "rrMA", "rtm", "drma", "hrma", "rdca", "ldMA", "rdla", "rdwa", "ldca", "rdmas", "drwa", "rtwa", "drm", "drla", "ldna", "rnla", "rnge", "rrma", "hrm", "rdm", "hrwa", "rnca", "rnna", "drmu", "rnMA", "rrge", "ldma", "rrna", "hrmas", "drmas", "rdMA", "rrmu", "rrca", "rdge", "rnma", "drge", "rdmu"]}}
{"project": "qemu", "commit_id": "323ad19bcc601d3ec9cb6f0f5b4d67b602fc519e", "target": 1, "func": "static void dump_ppc_insns (CPUPPCState *env)\n\n{\n\n    opc_handler_t **table, *handler;\n\n    const char *p, *q;\n\n    uint8_t opc1, opc2, opc3;\n\n\n\n    printf(\"Instructions set:\\n\");\n\n    /* opc1 is 6 bits long */\n\n    for (opc1 = 0x00; opc1 < PPC_CPU_OPCODES_LEN; opc1++) {\n\n        table = env->opcodes;\n\n        handler = table[opc1];\n\n        if (is_indirect_opcode(handler)) {\n\n            /* opc2 is 5 bits long */\n\n            for (opc2 = 0; opc2 < PPC_CPU_INDIRECT_OPCODES_LEN; opc2++) {\n\n                table = env->opcodes;\n\n                handler = env->opcodes[opc1];\n\n                table = ind_table(handler);\n\n                handler = table[opc2];\n\n                if (is_indirect_opcode(handler)) {\n\n                    table = ind_table(handler);\n\n                    /* opc3 is 5 bits long */\n\n                    for (opc3 = 0; opc3 < PPC_CPU_INDIRECT_OPCODES_LEN;\n\n                            opc3++) {\n\n                        handler = table[opc3];\n\n                        if (handler->handler != &gen_invalid) {\n\n                            /* Special hack to properly dump SPE insns */\n\n                            p = strchr(handler->oname, '_');\n\n                            if (p == NULL) {\n\n                                printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                       \"%s\\n\",\n\n                                       opc1, opc2, opc3, opc1,\n\n                                       (opc3 << 5) | opc2,\n\n                                       handler->oname);\n\n                            } else {\n\n                                q = \"speundef\";\n\n                                if ((p - handler->oname) != strlen(q) ||\n\n                                    memcmp(handler->oname, q, strlen(q)) != 0) {\n\n                                    /* First instruction */\n\n                                    printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                           \"%.*s\\n\",\n\n                                           opc1, opc2 << 1, opc3, opc1,\n\n                                           (opc3 << 6) | (opc2 << 1),\n\n                                           (int)(p - handler->oname),\n\n                                           handler->oname);\n\n                                }\n\n                                if (strcmp(p + 1, q) != 0) {\n\n                                    /* Second instruction */\n\n                                    printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                           \"%s\\n\",\n\n                                           opc1, (opc2 << 1) | 1, opc3, opc1,\n\n                                           (opc3 << 6) | (opc2 << 1) | 1,\n\n                                           p + 1);\n\n                                }\n\n                            }\n\n                        }\n\n                    }\n\n                } else {\n\n                    if (handler->handler != &gen_invalid) {\n\n                        printf(\"INSN: %02x %02x -- (%02d %04d) : %s\\n\",\n\n                               opc1, opc2, opc1, opc2, handler->oname);\n\n                    }\n\n                }\n\n            }\n\n        } else {\n\n            if (handler->handler != &gen_invalid) {\n\n                printf(\"INSN: %02x -- -- (%02d ----) : %s\\n\",\n\n                       opc1, opc1, handler->oname);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 7882, "substitutes": {"env": ["ptr", "vp", "conf", "dev", "environment", "pkg", "config", "conn", "esc", "v", "org", "vs", "ctx", "worker", "policy", "scope", "inv", "obj", "w", "server", "setup", "ew", "en", "req", "h", "here", "gate", "attr", "def", "manager", "ah", "ten", "store", "vm", "e", "end", "db", "engine", "global", "sv", "operator", "addr", "window", "desc", "eh", "context", "er", "ev", "viron", "err"], "table": ["master", "entity", "filter", "file", "handle", "package", "body", "root", "interface", "row", "db", "page", "count", "journal", "binary", "database", "data", "list", "stack", "dict", "index", "buffer", "try", "header", "csv", "context", "total", "shape", "tab", "entry", "collection", "order", "tf", "label", "policy", "address", "map", "port", "Table", "chain", "state", "point", "level", "tree", "type", "peer", "pool", "summary", "able", "t", "td", "tmp", "qualified", "stable", "bar", "TABLE", "offset", "set", "module", "attribute", "history", "store", "variable", "container", "domain", "tr", "service", "base", "window", "angle", "array", "cache", "batch"], "handler": ["key", "host", "application", "filter", "file", "error", "field", "connection", "alias", "handle", "parser", "layer", "root", "interface", "target", "tx", "loader", "message", "er", "Handler", "event", "hand", "json", "dev", "database", "way", "data", "worker", "ctx", "ler", "rule", "folder", "or", "h", "profile", "driver", "pointer", "index", "usage", "http", "buffer", "handled", "holder", "storage", "session", "header", "behavior", "priority", "magic", "lambda", "finder", "context", "man", "entry", "controller", "high", "policy", "address", "reader", "location", "when", "manager", "definition", "type", "command", "older", "owner", "and", "writer", "callback", "lib", "function", "html", "hander", "actor", "processor", "node", "server", "style", "method", " handlers", "attribute", "history", "metadata", "result", "info", "store", "help", "job", "test", "trap", "window", "client", "then", "player", "wrapper", "stream"], "p": ["pp", "pkg", "l", "pc", "wp", "k", "pro", "pt", "ap", "par", "fp", "bp", "c", "er", "pre", "cmd", "ph", "cp", "sp", "r", "ps", "ctx", "h", "j", "php", "i", "b", "def", "pb", "new", "dp", "op", "part", "x", "impl", "lp", "f", "d", "func", "pa", "pad", "ip", "np", "peer", "pat", "m", "pe", "u", "vp", "t", "rep", "v", "ping", "pg", "o", "g", "per", "pr", "tp", "cmp", "jp", "P", "parse", "pos"], "q": ["pp", "query", "qual", "ch", "pkg", "qq", "f", "d", "l", "v", "r", "question", "it", "quant", "Q", "qv", "ping", "mp", "w", "k", "dq", "h", "ue", "qu", "o", "j", "req", "iq", "i", "quote", "ip", "eq", "b", "sq", "que", "g", "y", "fp", " Q", "e", "quest", "P", "aq", "qa", "qi", "qt", "c", "queue", "quick", "qs", "n", "z", "u"], "opc1": [" opac2", "optcOne", "opcol81", "opac101", "oplc0", "opfc8", "optc001", "oppc10", " opc001", " opc4", "opfc3", "opcol1", "opptcOne", "opcu17", "opc9", "oppc71", "alpcOne", "opC2", "opcOne", " opac001", "opsco1", "OPc1", "opc01", "opce41", "oppc0", "opptc0", "opcol71", "opc10", "hopc1", "opci101", "opcol17", "oppc14", "OPc2", "optc0", "opco14", "opco3", " opl3", "hopc01", "opc001", "opcache71", "oprc1", "alpc1", "opco01", "oprc2", "opl01", "hopc3", "opl1", "optc2", " opac41", " opl2", " opac25", "hoppc14", " oplc1", "opac8", "opc4", "opac9", "opC1", " opc17", "opfc2", "oplc2", "opptc1", "opc0", "opc14", "opco001", "optc9", "opce1", "opci1", "opci001", "opsc1", "opco41", "opce0", "opcp1", "opl3", " opc8", "oppc101", "oprc001", "OPac101", "opcu71", "oppc01", "opciOne", "hoppc01", " opac0", "opco1", " opc9", "opc17", "OPac1", " opac9", " oplc2", "opac001", "opc25", "opsco101", "OPc001", " opC1", "hoppc3", "opsc101", " oplc4", "OPc101", "opac2", "opfc1", "opc71", "opl8", " opc25", "opptc9", " opc0", "oppcOne", "oppcol1", "opC17", "opcu81", "oppc25", "opac3", "opac0", "optc1", " opl1", "oprc101", "opac25", "OPac2", "oplc1", "alc001", "oplc4", "alcOne", " opC2", " opl8", "opac41", "opco25", "alc1", "opcache81", "oprcOne", "opcp9", " oplc0", "opco0", "opl14", "oppc9", "opco2", "opci17", " opC17", "oppcol71", "oppc2", "oprc10", "opcode2", " opac1", "oppc17", "alc10", "oppc81", "opco9", "opsco001", "oppc001", "oppcol17", "opc101", "alpc10", "opcu1", "hoppc1", "OPac001", "oppc1", "opsc001", "opcpOne", "opcache1", "oppc4", "opci10", "opcache17", "opc8", "opc41", "opacOne", "opac4", "opc81", "opcp0", "oppcol81", "opac1", "opcode1", "opcode17", "alpc001", "opce2", "opco101", "opci2", " opc41", "oppc3", "opl2", "hopc14"], "opc2": ["hotc1", "opce4", "opct02", "operatorcow72", "optpc1", "opk4", "opca2", " opc4", "OPc002", "opfc6", "opconf5", "opCTwo", "opC2", "opk02", "opfc02", "OPca2", "extci05", "hopc6", "optc14", "opcp6", "operatorcow4", "oprc43", "OPc2", "opco14", "opsec4", "optcTwo", "opco82", "opac05", "oprc1", "optc82", "opci05", "optpc4", "oprc2", "oppc6", "opcitwo", "opcat72", "ope1", "optc2", "opk3", "operatorc4", "opjc0002", "opc4", "extc4", "hoppc02", "opsec72", "opC1", "opfTwo", "hotcatTwo", "opfc43", "OPc02", "opcat1", "opfc2", "extc05", "opcatTwo", "opjc14", "coppc62", "operatorcow2", "hotc72", "opvc02", "ope2", "coppc2", "opcTwo", "opc14", "extc3", "opeTwo", "opce1", "ipac2", "opcp2", "opconf2", "opsec2", "hotcTwo", "opl4", "opct2", "opz2", "optc0002", "opc002", "opca02", "hopc2", "opl3", "optz14", "opcow72", "opcptwo", "opz14", "ipc1", "opct4", "optc4", "opcp4", "oppc62", "opc82", "ipac43", "opjc82", "extci3", "optpcTwo", "opvctwo", "opl72", "optpc2", "opct72", "hoppc2", " opct3", "opcow2", "opctTwo", "hotcat2", " opct02", "opci3", "opac43", "opf2", "opf4", "coppc5", " opct4", "copc62", "opac2", "opfc1", "opc5", "opceTwo", "operatorc022", "opC72", "opcp02", "opac3", "opgc5", "OPca002", "opci4", "hoppctwo", "optc1", "hotcat1", "copc5", "ipc43", "opc022", "opc05", "opgc62", "copc72", "hoppc6", "oppctwo", "opgc72", "OPcatwo", "opz82", "opca002", "ipc02", "opct3", "opctwo", "ope4", "opsec022", "opco2", "opconf72", "opl022", "oprc02", "opcpTwo", "oppc2", "oppc02", "opl05", "optz2", "extci2", "operatorcow022", "operatorc2", "opc72", "hopc02", "opc02", "opconf62", "opc0002", "extci4", "opc43", "opct1", "hopctwo", "oppc1", "oppc4", " opcTwo", "opvc2", "opk2", " opc02", "opgc2", "operatorc72", "extc2", "opfctwo", "opc6", "opz0002", "opac4", "OPca02", "OPctwo", "copc2", "opvc002", "opc62", "opac1", "opcatwo", "opco0002", "opjc2", " opct2", "coppc72", "oppc5", "optz0002", "opce2", "oppc72", "ipac1", "hotc2", "opcow4", "opcow022", " opctTwo", "optz82", "opcat2", "ipc2", "hotcat72", "ipac02", "opac02", "opci2", "opci02", "opci002", "oppcTwo", "opl2"], "opc3": ["apc15", "hopjc53", "opct343", "ioppcthree", "oppciii", "opco128", "opc93", "oprc128", "optc128", "opfc3", "opspc43", "opcThree", "opce43", "opunc53", "hopjc13", "opc15", "apc03", "opercThree", "opacThree", "opc21", "opsc03", "oparcthree", "opcat15", "opoc343", "opfc03", "hopc53", "hopc128", "iopc15", "optco2", "opca23", "operc3", "opk03", "opc003", "opco3", "operec1", "opci15", "Opc3", "oprc03", "opciii", "oprc2", "opacthree", "hopc3", "hopjc128", "optc2", "optc21", "opk3", "opoc15", "operecThree", "opceThree", "uppc3", "oppc03", "oprc3", "opc83", "opfc43", "opccthree", "operec3", "oppc15", "opspc003", " opc83", "upc03", "opcc3", "opunc13", "OppcThree", "apc343", "opac83", "opci003", "opac03", " opcThree", "oplc3", "opce1", " opac3", "iopc23", "opcthree", "iopc3", "opspc3", "opc23", " opac03", "opcc15", "opcatthree", "optci93", "oppcThree", "opci21", "optc3", "opca1", "apcat03", "opcat03", "uppc03", "opkThree", "opc343", " opc23", "opunc3", "opcat3", "opoc03", "opct15", " opc03", "opac23", "opk1", "opc33", "oppc21", "optci21", "opce003", "hopjc3", "opcs3", "apc3", "opec1", "oppc83", "opci3", "opcc03", "opct03", "opcatiii", " opac23", "upciii", "opac2", "opoc3", "opcc23", "optc93", "opc13", "oppc43", "opac128", "oparc15", "uppciii", "opjc53", "ioppc3", "oppc93", " opac83", "oppc23", "opac3", "opc03", "iopcthree", "operc03", "opjc93", "opcc1", "opcs23", "opec03", "opciThree", "opce3", "Opc003", "optci3", "Opc33", "oprc53", "optco3", "upc3", "OpcThree", "opci93", "opct3", "operc1", "ioppc15", "opci33", "opcat343", "opspc03", "opcsThree", "opco2", "oplc33", " opac1", "apcat3", "Oppc003", "opco03", "oparc23", "uppcthree", "upcthree", "opfc003", "oplc003", "oplcThree", "opaciii", "opcaThree", "opcc83", "ioppc23", "oprc13", "opjc15", "opce03", "opc43", "oppc1", "optci15", "opunc128", "opecThree", "opsc43", "optc03", "opjc3", "opc128", "opjc128", "oppc003", "optco128", "Oppc3", "operec03", "apcat15", "opc53", "opac1", "hopc13", "oppcthree", "oppc33", " opacThree", "opec3", "optc15", "opsc003", "Oppc33", "opcs1", "apcat343", "opsc3", "opjc13", "opca3", "optco03", "oparc3", "oppc3", "opjc21"]}}
{"project": "FFmpeg", "commit_id": "bf2cba453244a74331238a472fe0e309f116f4d9", "target": 1, "func": "yuv2rgb_2_c_template(SwsContext *c, const int16_t *buf[2],\n\n                     const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n                     const int16_t *abuf[2], uint8_t *dest, int dstW,\n\n                     int yalpha, int uvalpha, int y,\n\n                     enum PixelFormat target, int hasAlpha)\n\n{\n\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],\n\n                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],\n\n                  *abuf0 = abuf[0], *abuf1 = abuf[1];\n\n    int  yalpha1 = 4095 - yalpha;\n\n    int uvalpha1 = 4095 - uvalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < (dstW >> 1); i++) {\n\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;\n\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;\n\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;\n\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;\n\n        int A1, A2;\n\n        const void *r =  c->table_rV[V],\n\n                   *g = (c->table_gU[U] + c->table_gV[V]),\n\n                   *b =  c->table_bU[U];\n\n\n\n        if (hasAlpha) {\n\n            A1 = (abuf0[i * 2    ] * yalpha1 + abuf1[i * 2    ] * yalpha) >> 19;\n\n            A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19;\n\n        }\n\n\n\n        yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                      r, g, b, y, target, hasAlpha);\n\n    }\n\n}\n", "idx": 7885, "substitutes": {"buf0": ["aka1", "buff1", "buff000", "uf0", "uf2", "buf047", "uf000", "buff047", "buffer2", "aka0", "brace0", "buff2", "aka2", "buff0", "brace1", "buf2", "buf000", "uf047", "uf1", "buffer0", "aka000", "brace047", "buffer1"], "buf1": ["buffer01", "buff1", "uf0", "uf2", "buf4", "queue4", "buf01", "queue0", "buf3", "buffer2", " buf2", "uf01", "buff0", "buf2", "uf1", "queue1", "buff3", "buff4", "uf4", "uf3", "buffer0", " buf01", "queue3", "buffer1"], "ubuf0": ["abbuf0", "ubuffi", "ubbuff0", "ubufi", "ubbo10", "ubdj8", "abuf4", "ubbuff1", "ubbuf8", "ubbo1", "ubuf8", "ubuff1", "ubbuf4", "abbuf4", "ubbuff10", "ubdji", "ubuff8", "ubuf10", "ubbuf10", "ubuff0", "ubbo0", "abufi", "ubbo4", "abuf8", "ubbuf0", "abbuf10", "abuf10", "ubbuf1", "ubuf4", "ubbufi", "abbuf1", "ubdj0", "ubdj1", "abbufi", "abbuf8", "ubbuff4"], "ubuf1": ["ubbuf2", "abbuf0", "abuf01", "ubbuff0", "ubbuff2", "ubundle01", "ubuff30", "ubbuff1", "ubuf01", "ubuff2", "ubuf30", "ubuff1", "abuf2", "abbuf30", "ubuff01", "abbuf01", "ubuff0", "abbuf2", "ubuf2", "ubbuf0", "ubbuf1", "ubundle0", "ubbuf01", "abbuf1", "abuf30", "ubundle1", "ubbuf30", "ubundle30"], "vbuf0": ["vbuff047", "verbuf3", "verbuf1", "avbuf0", "vbuf047", "vcv0", "vcv3", "vseq0", "vcv1", "veruf7", "vbuff3", "veruf3", "veruf0", "vuf047", "vseq047", "vuf3", "verbuf0", "vbuf7", "avbuf047", "vseq1", "avbuf1", "vcv7", "vuf0", "vuf7", "vbuff1", "avuf1", "vbuff0", "avuf0", "verbuf7", "vuf1", "vbuf3", "veruf1", "vbuff7", "avuf047"], "vbuf1": ["vuf2", "vbuffer0", "vpkg3", "Vbuf2", "vcmd2", "vbuf100", "vbuffer100", " vbuf100", " vbuf3", "Vbuf1", "vcmd1", "vbuff3", "vbuf11", "Vuf2", "vbuff2", "Vbuf3", "vuf11", "vuf3", " vpkg0", "vcmd3", "vbuffer3", " vpkg100", "Vuf1", "vbuff100", "vbuf2", "vbuffer1", "vcmd11", "vpkg0", "Vuf3", "Vbuf11", "vbuff11", "Vuf11", "vbuff0", "vuf1", "vbuf3", " vpkg1", " vpkg3", "vpkg100", "vbuff1", "vpkg1"], "abuf0": ["labbuf0", "abbuf0", "absbuf0", "abbuff1", "abuff2", "abff0", "abutf1", "abuff3", "labbuf1", "abimg2", "abutf25", "absuf2", "abbuf3", "absbuf25", "absbuf1", "abimg1", "labuf10", "abuf3", "labuf2", "labbuf10", "abutf0", "abuff0", "abimg10", "abuf2", "abuff25", "absuf3", "abimg0", "abuf25", "labbuf2", "abff2", "abbuf2", "labuf0", "abutf2", "absuf0", "abuff1", "absbuf3", "abbuff2", "abbuf10", "abuf10", "abbuff0", "absuf1", "abff1", "abff10", "abbuf1", "absbuf2", "labuf1", "abbuf25", "abbuff3", "absuf25"], "abuf1": ["abuff100", "abbuf0", "abuf01", "absufOne", "absbuf0", "abuff2", "abuffy100", "abimg2", "absuf2", "abuffy2", "abuffy1", "absbuf1", "abufOne", "abuffy0", "abufferOne", "abimg1", "abbuf100", "absuff100", "absuff2", "abuff01", "absuf01", "abuffOne", "absbuf01", "abuff0", "absuf100", "abuf2", "abbuf01", "abuffer1", "abimg0", "abbuf2", "abuffer0", "absuf0", "abuff1", "absuf1", "abuf100", "abbuf1", "absbuf2", "absuff0", "abuffer2", "absuff1", "abimg01", "abbufOne", "absbufOne"], "i": ["key", "p", "ori", "id", "l", "ii", "ini", "it", "asi", "hi", "di", "gi", "y", "iter", "ci", "ami", "ik", " j", "ims", "qi", "c", "cli", "n", "start", " ii", "ei", "a", "ix", "ic", "si", "oi", "j", "ji", "index", "name", "zi", "this", "try", "iri", "pi", "x", "phi", "item", "Ti", "ia", "is", "ind", "mi", "span", "ri", "io", "ip", "point", "multi", " ti", "ti", "e", "m", "ai", "im", "I", "go", "init", "t", "li", "sim", "ki", "bi", "me", "\u0438", "uri", "o", "in", "info", "ui", "iu", "xi", "ij", "status", "batch"], "A1": ["AM3", "BOne", " A3", " A12", "B2", "AA1", "R2", "AOne", "R1", "AA11", "ROne", "A12", " AOne", "AM12", "R3", "AM11", "AM1", "AA12", "B1", "AA3", "A3", "B3", " A11", "A11"], "A2": ["AM6", "AM5", "AM02", "A4", "ABTwo", "AA6", "ATwo", "AB2", "aTwo", "AB4", "AA2", "A02", "a5", "AB5", "AA02", " A5", "a4", " A02", "AA5", " ATwo", "A5", " A6", "A6", "AM2", " A4", "a2"], "r": ["rc", "dr", "p", "f", "d", "v", "re", "R", "q", "w", "h", "vr", "sr", "o", "cr", "rb", "rg", "rs", "ar", "e", "m", "c", "ro", "n", "er", "err"], "g": ["fg", "p", "gt", "f", "d", "l", "v", "q", "w", "k", "h", "j", "rg", "G", "gb", "y", "bg", "m", "gp", "gg", "c", "gr", "n", "go", "u", "reg"], "b": ["t", "p", "bi", "f", "a", "d", "l", "v", "fb", "w", "j", "h", "o", "B", "bb", "ba", "y", "e", "bg", "m", "c", "n", "rb", "u", "bc", "be"]}}
{"project": "FFmpeg", "commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "target": 1, "func": "static int minimum_frame_bits(VC2EncContext *s)\n\n{\n\n    int slice_x, slice_y, bits = 0;\n\n    s->size_scaler = 64;\n\n    for (slice_y = 0; slice_y < s->num_y; slice_y++) {\n\n        for (slice_x = 0; slice_x < s->num_x; slice_x++) {\n\n            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);\n\n        }\n\n    }\n\n    return bits;\n\n}\n", "idx": 7892, "substitutes": {"s": ["t", "os", "S", "p", "conf", "ds", "is", "a", "ms", "l", "v", "r", "ps", "spec", "ins", "vs", "sets", "less", "ss", "aws", "comm", "ains", "bs", "space", "js", "ns", "hs", "sq", "g", "ses", "sts", "sg", "rs", "gs", "ts", "es", "e", "ops", "stats", "m", "fs", "sv", "cs", "ims", "x", "sb", "c", "parts", "ls", "ats", "n", "sys", "qs", "eps", "sw"], "slice_x": ["slice_xf", "slot____xi", "sliceleti", "slot_race", "slice_ey", "slice__i", "sliceletxf", "slice__x", "slot____x", "slot____ex", " slice_lat", "slice09lat", "ice_x", "ice_ex", "slice_xs", " slice_i", "ice_ey", "slice____x", "slice_ex", "slice__y", "slice_i", "sliceletex", "slice09x", "ice_xs", "slice____xi", "sliceablex", "slice____ex", "slice____inx", "slice_race", "slot_inx", "slot____inx", "slice_inx", " slice_ex", "sliceableex", "slice09y", "slice_xx", "slice_lat", "slot_x", "sliceablexx", "slice____i", "slice09i", " slice_xf", "slot_xi", "slice____xf", "sliceablerace", "slice__lat", "slice_xi", "slot_xx", "sliceletx", "slot_ex"], "slice_y": ["slice_ya", "single_yo", "sliceixx", " slice_yy", "sliceingly", "sliceptyy", "slice_ny", "slice___yo", "ice_x", "sliceixya", "slice___y", "sliceingxy", "slice_vy", "sliceingyo", "sliceixy", "slice_ly", "ice_y", "slice___ly", "species_ly", "sliceixvy", "single_ya", "slice_yy", "single_y", "sliceNameasy", "sliceNameyo", "sliceableyy", "sliceablex", "sliceptny", "species_yo", "slice___xy", "ice_ya", "slice_xy", "species_y", "single_asy", "ice_vy", "sliceptx", "sliceingy", "sliceNameya", "sliceabley", " slice_ny", "slicepty", "slice_asy", "species_xy", "slice_yo", "sliceNamey", "sliceableny"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void fd_coroutine_enter(void *opaque)\n\n{\n\n    FDYieldUntilData *data = opaque;\n\n    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);\n\n    qemu_coroutine_enter(data->co, NULL);\n\n}\n", "idx": 7893, "substitutes": {"opaque": ["compaques", "replaque", "replacity", "opaques", "OPaque", "oaques", "oaque", "opacement", "oppaque", "oracity", "oraques", "opula", "orula", "replacement", "replaques", "compacity", "oacity", "oppaques", "oacement", "opacity", "compula", "oppula", "compaque", "OPaques", "OPacity", "oppacity", "oraque", "OPacement"], "data": ["entry", "extra", " some", "no", "d", "join", "id", "done", " junk", "ad", "aw", "hash", "DATA", "reader", "str", "di", "valid", "Data", "o", " garbage", "empty", "dat", " whoever", "size", "def", " possibly", "name", "info", "step", " who", "store", "zero", "da", "ata", "row", "area", "command", " dummy", "defined", "roy", " missing", " DATA", "rel", "table", "missing", "ta", " unused", "who", "ATA", "by", "block", "message", "next", "value", "batch"]}}
{"project": "qemu", "commit_id": "e976c6a1e40ad74d616a186d3b48b0ad8f5eb970", "target": 1, "func": "static void qcow_aio_write_cb(void *opaque, int ret)\n\n{\n\n    QCowAIOCB *acb = opaque;\n\n    BlockDriverState *bs = acb->common.bs;\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    uint64_t cluster_offset;\n\n    const uint8_t *src_buf;\n\n    int n_end;\n\n\n\n    acb->hd_aiocb = NULL;\n\n\n\n    if (ret < 0) {\n\n    fail:\n\n        acb->common.cb(acb->common.opaque, ret);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->nb_sectors -= acb->n;\n\n    acb->sector_num += acb->n;\n\n    acb->buf += acb->n * 512;\n\n\n\n    if (acb->nb_sectors == 0) {\n\n        /* request completed */\n\n        acb->common.cb(acb->common.opaque, 0);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);\n\n    n_end = index_in_cluster + acb->nb_sectors;\n\n    if (s->crypt_method &&\n\n        n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors)\n\n        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n\n\n    cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9,\n\n                                          index_in_cluster,\n\n                                          n_end, &acb->n);\n\n    if (!cluster_offset || (cluster_offset & 511) != 0) {\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    if (s->crypt_method) {\n\n        if (!acb->cluster_data) {\n\n            acb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                             s->cluster_size);\n\n            if (!acb->cluster_data) {\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n        }\n\n        encrypt_sectors(s, acb->sector_num, acb->cluster_data, acb->buf,\n\n                        acb->n, 1, &s->aes_encrypt_key);\n\n        src_buf = acb->cluster_data;\n\n    } else {\n\n        src_buf = acb->buf;\n\n    }\n\n    acb->hd_aiocb = bdrv_aio_write(s->hd,\n\n                                   (cluster_offset >> 9) + index_in_cluster,\n\n                                   src_buf, acb->n,\n\n                                   qcow_aio_write_cb, acb);\n\n    if (acb->hd_aiocb == NULL)\n\n        goto fail;\n\n}\n", "idx": 7916, "substitutes": {"opaque": ["compaques", "operortal", "bitaque", "ipacity", "oportal", "ipaque", "obacity", "obula", "opaques", "OPaque", "OPatile", "operque", "compatile", "obatile", " opaques", "popatile", "OPortal", "opula", "bitacity", "OPula", "popaque", "obaque", "opatile", "obque", " opatile", "opque", "popula", "compacity", "ipque", "ipker", " Opque", "OPker", "operaque", "ipatile", "ipaques", "bitque", "popacity", "popaques", "opker", "opacity", " Opaque", "bitatile", "obaques", "compaque", "OPque", "OPaques", " opker", " Oportal"], "ret": ["deg", "out", "t", "elt", "lit", "gt", "reset", "inter", "tf", "eth", "sec", "dt", "ll", "RET", "arg", "rot", "rm", "att", "nt", "re", "Ret", "hash", "ft", "rets", "pas", "txt", "red", "ext", "val", "vet", "ry", "rem", "mt", "result", "resp", "def", "pret", "nz", "rev", "ref", "status", "len", "print", "res", "after", "try", "tr", "ter", "flag", "der", "desc", "tech", "alt", "reply", "rt", "vt", "err", "cmd"], "acb": ["pacmb", "racwb", "Acb", "sacb", "acbd", "acbi", "aicbr", "Acbb", "actsb", "icbar", "racrb", "pacwb", "rcb", "sacnb", "ancpb", "macbl", "sacn", "aclbr", "ecrb", "aconsb", "accrb", "racba", "accbd", "facba", "rcob", "aconr", "aconbe", "acwb", "acn", " lacf", "acln", " acbd", "ccpb", "acnb", "abbr", "Acfb", "acx", "ccob", "aconb", "accnb", "facb", "accgb", "aclnb", "acrb", "ecb", "accfb", "aclb", "facr", "acab", "acbe", " acgb", "ocsb", "aicbi", "aconab", "acsb", "macb", "acbl", " aczb", "iacy", " lacb", "facsb", "aconl", "pacba", "rcpb", "accbm", "aconbd", "pacb", "iacsb", "aclgb", "aconbm", "acong", "ancbar", " acsb", "accab", "iacx", "icbr", "pacbe", "icgb", "accbr", "achzb", "accn", "ainb", "ancb", " acba", " acmb", "accl", "acbar", "acp", "macsb", "ccb", "aicmb", "acly", "pacrb", " acl", "macbb", "facab", "macbe", "sacdb", "aczb", "acmb", "macbd", "macrb", "ccfb", "acl", "actbr", "iacnb", "rcnb", "aconob", "acba", "racb", "Acbl", "acfb", "pacfb", "accsb", "facgb", "ainrb", "ocnb", "macgb", "iacfb", "aclbd", "ccbe", "achwb", "icrb", "ancnb", "ecdb", "Acbe", "sacbr", "iacb", "aconf", " lacrb", "pacbar", "Acsb", "sacbb", "ccnb", "icbd", "accbb", "icnb", "iacr", " lacba", "aicb", "aclbb", "absb", " acbb", "acbm", "abb", "pacsb", "accbar", "aconbb", "ainbb", "accob", "ancob", "aclrb", "acy", " acob", "ocbb", "aclmb", " acdb", "Acbd", "sacba", "pacgb", "sacsb", "acgb", "aconba", "ecsb", "aconfb", "acdb", "ainbm", "aclbar", "ocb", "icb", " acbe", "accb", "acob", "actb", "accr", "accp", " acp", "aicl", "Acbr", "aclr", "iacbr", "accg", "pacbr", " acwb", "ancba", "aclbl", "aql", "aicgb", "achb", "aclp", "acpb", "aclbi", "acg", "ancbd", "actnb", "Acnb", "acbb", "acbr", "actrb", "actzb", "achrb", "pacbd", "accba", "pacbi", "aqb", "aqgb", "accy", "abba", " acrb", "aconrb", "accmb", "macba", "accx", "aclx", "aconnb", "iacbar", "acr", "actwb", "pacbb", "sacrb", "racf", "facg", "sacgb", "acf"], "bs": ["os", "ubs", "bn", "bos", "bps", "ds", "bh", "bi", "is", "bm", "bes", "aus", "vs", "bas", "ks", "cb", "ss", "bles", "outs", "js", "ns", "bytes", "b", "bb", "BS", "blocks", "bl", "rs", "gs", "ts", "obs", "ops", "bg", "lbs", "ubis", "bits", "fs", "its", "bis", "cs", "sb", "us", "ls", "qs", "sys", "bc", "zb"], "s": ["t", "os", "S", "p", "sports", "ds", "details", "is", "a", "bes", "ms", "v", "ps", "spec", "ies", "sets", "sl", "w", "less", "ss", "irs", "uploads", "h", "aws", "ys", "tes", "changes", "js", "ns", "hs", "b", "g", "ses", "sts", "rs", "gs", "tags", "abilities", "ts", "sn", "stats", "xs", "bits", "its", "fs", "sv", "orders", "cs", "args", "bis", "ims", "sb", "c", "parts", "als", "ls", "series", "qs", "ats", "sys", "params"], "index_in_cluster": ["index_in_gloser", "index_in_scust", "index_in_scusters", "index_in_Closer", "index_in_clusters", "index_in_glust", "index_in_scoser", "index_in_closer", "index_in_plusters", "index_in_plust", "index_in_flause", "index_in_glusters", "index_in_Clause", "index_in_chust", "index_in_chuster", "index_in_ploser", "index_in_gluster", "index_in_flust", "index_in_Clusters", "index_in_plause", "index_in_fluster", "index_in_clust", "index_in_Clust", "index_in_clause", "index_in_flusters", "index_in_chusters", "index_in_Cluster", "index_in_pluster", "index_in_scuster"], "cluster_offset": ["clust_id", "clusterableid", "cluster____style", "cluster_length", "cluster_id", "clusterableoff", "clocation____style", "cluster_info", "clust_info", "clust_loc", "clocation_offset", "cluster____metadata", "cluster_location", "cluster____onet", "clusterabledata", "clocation____onet", "clocation_metadata", "clusteringonet", "clust_length", "cluster_loc", "clust_data", "clocation_onet", "clust_location", "cluster_metadata", "clusteringmetadata", "clusteringstyle", "cluster_onet", "cluster_off", "cluster____offset", "clusteringoffset", "clocation_style", "clocation____metadata", "clocation____offset", "clust_offset", "clusterableoffset", "cluster_style", "clust_off", "cluster_data"], "src_buf": ["source_buff", "source_mem", "src_mem", "source_buf", "src_buff", "source_data", "src_data"], "n_end": ["n2end", "n2nd", " n_END", "sn_ended", "N_End", "n__end", "n_nd", "n__END", "n_tail", "N_end", "n_END", " n_nd", "n_ended", "N_stop", "ln_eng", "sn_END", "sn__END", "sn__end", "n_End", "ln_end", "n_stop", "n__ended", "sn_max", "n_eng", "n_max", "n__max", "N_END", "sn_end", "N_tail", "ln_ended", "n__nd", "sn__ended", "sn__max", "n2END"]}}
{"project": "FFmpeg", "commit_id": "08d2cee49c323715b66df0e4ff45ec0e07aaea7b", "target": 0, "func": "static int opt_input_file(const char *opt, const char *filename)\n\n{\n\n    AVFormatContext *ic;\n\n    AVInputFormat *file_iformat = NULL;\n\n    int err, i, ret, rfps, rfps_base;\n\n    int64_t timestamp;\n\n    uint8_t buf[128];\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;                     // number of streams before avformat_find_stream_info\n\n\n\n    if (last_asked_format) {\n\n        if (!(file_iformat = av_find_input_format(last_asked_format))) {\n\n            fprintf(stderr, \"Unknown input format: '%s'\\n\", last_asked_format);\n\n            ffmpeg_exit(1);\n\n        }\n\n        last_asked_format = NULL;\n\n    }\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    using_stdin |= !strncmp(filename, \"pipe:\", 5) ||\n\n                    !strcmp(filename, \"/dev/stdin\");\n\n\n\n    /* get default parameters from command line */\n\n    ic = avformat_alloc_context();\n\n    if (!ic) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        ffmpeg_exit(1);\n\n    }\n\n    if (audio_sample_rate) {\n\n        snprintf(buf, sizeof(buf), \"%d\", audio_sample_rate);\n\n        av_dict_set(&format_opts, \"sample_rate\", buf, 0);\n\n    }\n\n    if (audio_channels) {\n\n        snprintf(buf, sizeof(buf), \"%d\", audio_channels);\n\n        av_dict_set(&format_opts, \"channels\", buf, 0);\n\n    }\n\n    if (frame_rate.num) {\n\n        snprintf(buf, sizeof(buf), \"%d/%d\", frame_rate.num, frame_rate.den);\n\n        av_dict_set(&format_opts, \"framerate\", buf, 0);\n\n    }\n\n    if (frame_width && frame_height) {\n\n        snprintf(buf, sizeof(buf), \"%dx%d\", frame_width, frame_height);\n\n        av_dict_set(&format_opts, \"video_size\", buf, 0);\n\n    }\n\n    if (frame_pix_fmt != PIX_FMT_NONE)\n\n        av_dict_set(&format_opts, \"pixel_format\", av_get_pix_fmt_name(frame_pix_fmt), 0);\n\n\n\n    ic->video_codec_id   =\n\n        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0);\n\n    ic->audio_codec_id   =\n\n        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0);\n\n    ic->subtitle_codec_id=\n\n        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0);\n\n    ic->flags |= AVFMT_FLAG_NONBLOCK;\n\n\n\n    /* open the input file with generic libav function */\n\n    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(filename, err);\n\n        ffmpeg_exit(1);\n\n    }\n\n    assert_avoptions(format_opts);\n\n\n\n    if(opt_programid) {\n\n        int i, j;\n\n        int found=0;\n\n        for(i=0; i<ic->nb_streams; i++){\n\n            ic->streams[i]->discard= AVDISCARD_ALL;\n\n        }\n\n        for(i=0; i<ic->nb_programs; i++){\n\n            AVProgram *p= ic->programs[i];\n\n            if(p->id != opt_programid){\n\n                p->discard = AVDISCARD_ALL;\n\n            }else{\n\n                found=1;\n\n                for(j=0; j<p->nb_stream_indexes; j++){\n\n                    ic->streams[p->stream_index[j]]->discard= AVDISCARD_DEFAULT;\n\n                }\n\n            }\n\n        }\n\n        if(!found){\n\n            fprintf(stderr, \"Specified program id not found\\n\");\n\n            ffmpeg_exit(1);\n\n        }\n\n        opt_programid=0;\n\n    }\n\n\n\n    if (loop_input) {\n\n        av_log(NULL, AV_LOG_WARNING, \"-loop_input is deprecated, use -loop 1\\n\");\n\n        ic->loop_input = loop_input;\n\n    }\n\n\n\n    /* Set AVCodecContext options for avformat_find_stream_info */\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    /* If not enough info to get the stream parameters, we decode the\n\n       first frames to get it. (used in mpeg case for example) */\n\n    ret = avformat_find_stream_info(ic, opts);\n\n    if (ret < 0 && verbose >= 0) {\n\n        fprintf(stderr, \"%s: could not find codec parameters\\n\", filename);\n\n        av_close_input_file(ic);\n\n        ffmpeg_exit(1);\n\n    }\n\n\n\n    timestamp = start_time;\n\n    /* add the stream start time */\n\n    if (ic->start_time != AV_NOPTS_VALUE)\n\n        timestamp += ic->start_time;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (start_time != 0) {\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"%s: could not seek to position %0.3f\\n\",\n\n                    filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n        /* reset seek info */\n\n        start_time = 0;\n\n    }\n\n\n\n    /* update the current parameters so that they match the one of the input stream */\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        AVStream *st = ic->streams[i];\n\n        AVCodecContext *dec = st->codec;\n\n        InputStream *ist;\n\n\n\n        dec->thread_count = thread_count;\n\n\n\n        input_streams = grow_array(input_streams, sizeof(*input_streams), &nb_input_streams, nb_input_streams + 1);\n\n        ist = &input_streams[nb_input_streams - 1];\n\n        ist->st = st;\n\n        ist->file_index = nb_input_files;\n\n        ist->discard = 1;\n\n        ist->opts = filter_codec_opts(codec_opts, ist->st->codec->codec_id, 0);\n\n\n\n        if (i < nb_ts_scale)\n\n            ist->ts_scale = ts_scale[i];\n\n\n\n        switch (dec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->dec = avcodec_find_decoder_by_name(audio_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            if(audio_disable)\n\n                st->discard= AVDISCARD_ALL;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ist->dec= avcodec_find_decoder_by_name(video_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            rfps      = ic->streams[i]->r_frame_rate.num;\n\n            rfps_base = ic->streams[i]->r_frame_rate.den;\n\n            if (dec->lowres) {\n\n                dec->flags |= CODEC_FLAG_EMU_EDGE;\n\n            }\n\n            if(me_threshold)\n\n                dec->debug |= FF_DEBUG_MV;\n\n\n\n            if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) {\n\n\n\n                if (verbose >= 0)\n\n                    fprintf(stderr,\"\\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\\n\",\n\n                            i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num,\n\n\n\n                    (float)rfps / rfps_base, rfps, rfps_base);\n\n            }\n\n\n\n            if(video_disable)\n\n                st->discard= AVDISCARD_ALL;\n\n            else if(video_discard)\n\n                st->discard= video_discard;\n\n            break;\n\n        case AVMEDIA_TYPE_DATA:\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ist->dec = avcodec_find_decoder_by_name(subtitle_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            if(subtitle_disable)\n\n                st->discard = AVDISCARD_ALL;\n\n            break;\n\n        case AVMEDIA_TYPE_ATTACHMENT:\n\n        case AVMEDIA_TYPE_UNKNOWN:\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n    }\n\n\n\n    /* dump the file content */\n\n    if (verbose >= 0)\n\n        av_dump_format(ic, nb_input_files, filename, 0);\n\n\n\n    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);\n\n    input_files[nb_input_files - 1].ctx        = ic;\n\n    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;\n\n    input_files[nb_input_files - 1].ts_offset  = input_ts_offset - (copy_ts ? 0 : timestamp);\n\n\n\n    top_field_first = -1;\n\n    frame_rate    = (AVRational){0, 0};\n\n    frame_pix_fmt = PIX_FMT_NONE;\n\n    frame_height = 0;\n\n    frame_width  = 0;\n\n    audio_sample_rate = 0;\n\n    audio_channels    = 0;\n\n    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;\n\n    av_freep(&ts_scale);\n\n    nb_ts_scale = 0;\n\n\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n    av_freep(&video_codec_name);\n\n    av_freep(&audio_codec_name);\n\n    av_freep(&subtitle_codec_name);\n\n    uninit_opts();\n\n    init_opts();\n\n    return 0;\n\n}\n", "idx": 7925, "substitutes": {"opt": ["init", "Opt", "tmp", "temp", "config", "oop", "ctx", "nom", "it", "txt", "cb", "w", "options", "prop", "ff", "req", "option", "attr", "off", "info", "timeout", "ref", "op", "env", "bin", "kw", "seek"], "filename": ["tif", "fil", "json", "rather", "mpeg", "unc", "fn", "ame", "config", "f", "dest", "nil", "length", "joined", "FN", "upload", "path", "url", "file", "fd", "prefix", "files", "bas", "typ", "program", "txt", "w", "username", "aka", "other", "png", "fps", "FIL", "kl", "output", "none", "nm", "ames", "source", "format", "root", "name", "dir", "brace", "jpg", "text", "fp", "kj", "rn", "buffer", "wav", "ename", "title", "names", "final", "src", "null", "ren", "n", "video", "til", "Filename"], "ic": ["mc", "tc", "ia", "rc", "cu", "ici", "pic", "vc", " nic", "iac", "ec", "eric", "wic", "it", "pc", "onic", "icing", "dc", "ics", "aic", "cc", "icc", "ican", "fc", "anc", "ip", " ac", "ci", "ric", "tic", "ik", "pi", "ct", "ac", "c", "lic", "nic", "oc", "voc", "IC", "bc", "mic", "ico"], "file_iformat": ["file_instat", "file_ikkiat", "file_mediiat", "file_icolat", "file_icolati", "file_iformati", "file_ikkait", "file_iformait", "file_ikkati", "file_ikkata", "file_ivati", "file_instata", "file_mediat", "file_ikkat", "file_ivait", "file_ivata", "file_iformats", "file_iformiat", "file_ikkats", "file_icolata", "file_iformata", "file_instats", "file_mediats", "file_instiat", "file_icolait", "file_mediata", "file_ivat"], "err": ["order", "conf", "r", "race", "rr", "error", "cb", "str", "req", "fer", "attr", "cr", "proc", "resp", "usr", "fee", "len", "iter", "code", "e", "stat", "coord", "test", "Error", "er", "ev"], "i": ["t", "fi", "f", "l", "ii", "r", "mi", "it", "si", "io", "ip", "b", "g", "iu", "ib", "ij", "ir", "m", "iat", "ik", "pi", "im", "I", "c", "n"], "ret": ["reset", "elt", "progress", "RET", "rm", "nt", "re", "Ret", "fd", "val", "fun", "gc", "mem", "result", "status", "len", "jp", "rel", "na", "res", "conv", "flag", "back", "alt", "cmd"], "rfps": [" rframes", "mbps", "fbps", "mframes", "rframes", " rrates", "mrates", "fframes", " rbps", "rrates", "ffps", "mfps", "frates", "rbps"], "rfps_base": ["rhz_base", "rhz_scale", "rfps_scale", "rfps_info", "rhz_info", "rhz_offset", "rfps_offset"], "timestamp": ["imestamp", "timeeline", "frametime", "timeetime", "frameline", "framtime", "timtime", "imetime", "timeestamp", "timeline", "imeline", "imtime", "timetime", "framestamp"], "buf": ["pkg", "bt", "bed", "arr", "filter", "msg", "txt", "str", "cur", "Buff", "text", "db", "wav", "vec", "loop", "bp", "uf", "count", "tx", "queue", "kw", "box", "cmd", "progress", "data", "ctx", "mu", "obj", "aka", "buff", "empty", "mem", "proc", "boxes", "pb", "buffer", "code", "raw", "uffy", "seq", "pause", "block", "func", "fb", "cb", "Buffer", "br", "read", "bs", "cap", "mb", "pool", "conv", "foo", "var", "bag", "img", "doc", "cv", "tmp", "bar", "prop", "ff", "req", "kl", "bytes", "result", "usr", "tr", "window", "desc", "cache", "rb", "stream", "bc", "batch"], "opts": [" opcs", "optts", "opttions", "opcs", " options", " opopt", "optcs", "vets", "opopt", "options", "optopt", "vecs", "veopt", "vetions"], "orig_nb_streams": ["orig_nb2pathd", "orig_nb_reamd", "orig_nb2pathls", "orig_nb_recs", "orig_nb_recd", "orig_nb2pathers", "orig_nb_pathers", "orig_nb_streamls", "orig_nb_streamers", "orig_nb_pathls", "orig_nb2streamers", "orig_nb2streamd", "orig_nb2streamls", "orig_nb_reamls", "orig_nb2paths", "orig_nb2streams", "orig_nb_paths", "orig_nb_pathd", "orig_nb_streamd", "orig_nb_recers", "orig_nb_recls", "orig_nb_reams", "orig_nb_reamers"]}}
{"project": "qemu", "commit_id": "3393bc105d58e1f4a27d9a8e7062da9cef260cc3", "target": 0, "func": "static int usb_hub_handle_control(USBDevice *dev, USBPacket *p,\n\n               int request, int value, int index, int length, uint8_t *data)\n\n{\n\n    USBHubState *s = (USBHubState *)dev;\n\n    int ret;\n\n\n\n    ret = usb_desc_handle_control(dev, p, request, value, index, length, data);\n\n    if (ret >= 0) {\n\n        return ret;\n\n    }\n\n\n\n    switch(request) {\n\n    case EndpointOutRequest | USB_REQ_CLEAR_FEATURE:\n\n        if (value == 0 && index != 0x81) { /* clear ep halt */\n\n            goto fail;\n\n        }\n\n        ret = 0;\n\n        break;\n\n    case DeviceRequest | USB_REQ_GET_INTERFACE:\n\n        data[0] = 0;\n\n        ret = 1;\n\n        break;\n\n    case DeviceOutRequest | USB_REQ_SET_INTERFACE:\n\n        ret = 0;\n\n        break;\n\n        /* usb specific requests */\n\n    case GetHubStatus:\n\n        data[0] = 0;\n\n        data[1] = 0;\n\n        data[2] = 0;\n\n        data[3] = 0;\n\n        ret = 4;\n\n        break;\n\n    case GetPortStatus:\n\n        {\n\n            unsigned int n = index - 1;\n\n            USBHubPort *port;\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            data[0] = port->wPortStatus;\n\n            data[1] = port->wPortStatus >> 8;\n\n            data[2] = port->wPortChange;\n\n            data[3] = port->wPortChange >> 8;\n\n            ret = 4;\n\n        }\n\n        break;\n\n    case SetHubFeature:\n\n    case ClearHubFeature:\n\n        if (value == 0 || value == 1) {\n\n        } else {\n\n            goto fail;\n\n        }\n\n        ret = 0;\n\n        break;\n\n    case SetPortFeature:\n\n        {\n\n            unsigned int n = index - 1;\n\n            USBHubPort *port;\n\n            USBDevice *dev;\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            dev = port->port.dev;\n\n            switch(value) {\n\n            case PORT_SUSPEND:\n\n                port->wPortStatus |= PORT_STAT_SUSPEND;\n\n                break;\n\n            case PORT_RESET:\n\n                if (dev) {\n\n                    usb_send_msg(dev, USB_MSG_RESET);\n\n                    port->wPortChange |= PORT_STAT_C_RESET;\n\n                    /* set enable bit */\n\n                    port->wPortStatus |= PORT_STAT_ENABLE;\n\n                }\n\n                break;\n\n            case PORT_POWER:\n\n                break;\n\n            default:\n\n                goto fail;\n\n            }\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case ClearPortFeature:\n\n        {\n\n            unsigned int n = index - 1;\n\n            USBHubPort *port;\n\n\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            switch(value) {\n\n            case PORT_ENABLE:\n\n                port->wPortStatus &= ~PORT_STAT_ENABLE;\n\n                break;\n\n            case PORT_C_ENABLE:\n\n                port->wPortChange &= ~PORT_STAT_C_ENABLE;\n\n                break;\n\n            case PORT_SUSPEND:\n\n                port->wPortStatus &= ~PORT_STAT_SUSPEND;\n\n                break;\n\n            case PORT_C_SUSPEND:\n\n                port->wPortChange &= ~PORT_STAT_C_SUSPEND;\n\n                break;\n\n            case PORT_C_CONNECTION:\n\n                port->wPortChange &= ~PORT_STAT_C_CONNECTION;\n\n                break;\n\n            case PORT_C_OVERCURRENT:\n\n                port->wPortChange &= ~PORT_STAT_C_OVERCURRENT;\n\n                break;\n\n            case PORT_C_RESET:\n\n                port->wPortChange &= ~PORT_STAT_C_RESET;\n\n                break;\n\n            default:\n\n                goto fail;\n\n            }\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case GetHubDescriptor:\n\n        {\n\n            unsigned int n, limit, var_hub_size = 0;\n\n            memcpy(data, qemu_hub_hub_descriptor,\n\n                   sizeof(qemu_hub_hub_descriptor));\n\n            data[2] = NUM_PORTS;\n\n\n\n            /* fill DeviceRemovable bits */\n\n            limit = ((NUM_PORTS + 1 + 7) / 8) + 7;\n\n            for (n = 7; n < limit; n++) {\n\n                data[n] = 0x00;\n\n                var_hub_size++;\n\n            }\n\n\n\n            /* fill PortPwrCtrlMask bits */\n\n            limit = limit + ((NUM_PORTS + 7) / 8);\n\n            for (;n < limit; n++) {\n\n                data[n] = 0xff;\n\n                var_hub_size++;\n\n            }\n\n\n\n            ret = sizeof(qemu_hub_hub_descriptor) + var_hub_size;\n\n            data[0] = ret;\n\n            break;\n\n        }\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 7936, "substitutes": {"dev": ["conn", "nt", "hid", "devices", "loc", "watch", "pro", "development", "av", "pt", "dn", "DEV", "wd", "ver", "md", "develop", "db", "det", "des", "de", "app", "ctx", "normal", "dd", "obj", "w", "any", " Dev", "ve", "adv", "device", "sd", "mem", "proc", "def", "usb", "stick", "serial", "buffer", "raw", "on", "mode", "sys", "disabled", "pub", "den", "priv", "debug", "d", " device", "van", "att", "private", "Device", "Dev", "ad", "gu", "pad", "off", "end", "cam", "home", "var", "go", "ev", "out", "dem", "doc", "v", "stable", "server", "buf", "tr", "test", "hw", "window", "tech", "dep"], "p": ["vp", "t", "pp", "cp", "pkg", "f", "d", "v", "sp", "r", "pc", "ping", "q", "wp", "w", "pa", "pro", "h", "pt", "ap", "np", "b", "par", "press", "g", "pb", "tp", "jp", "pat", "m", "P", "part", "c", "pe"], "request": ["access", "query", "primary", "QUEST", "task", "common", "argument", "direction", "condition", "position", "change", "select", "call", "address", " Request", "version", "set", "req", "method", "object", "each", "package", "attribute", "reason", "vector", "requ", "begin", "point", "feature", "type", "interface", "operation", "command", "Request", "forward", "variable", "quest", "report", "service", "reference", "mode", "param", "have", "item", "push", "message", "create", "cmd", "event", "seek"], "value": ["function", "hello", "VAL", "key", "max", "v", "direction", "condition", "ceive", "position", "change", "rule", "address", "val", "version", "wise", "set", "ue", "valid", "ve", "description", "false", "attribute", "size", "vector", "format", "result", "state", "name", "feature", "allow", "password", "timeout", "type", "response", "buffer", "new", "status", "command", "ay", "end", "flow", "document", "content", "variable", "server", "raw", "unit", "scale", "values", "initial", "test", "Value", "VALUE", "number", "expression", "message", "total", "see", "input", "event", "action"], "index": ["key", "order", "id", "ind", "path", "condition", "scan", "error", "position", "note", "address", "connection", "offset", "val", "ion", "set", "si", "axis", "object", "device", "attribute", "reason", "location", "action", "i", "vector", "slot", "point", "connect", "timeout", "response", "zero", "interface", "operation", "row", "command", "Index", "len", "code", "end", "find", "document", "instance", "number", "x", "num", "count", "message", "pos", "start", "input", "context", "seek"], "length": ["ptr", "capacity", "t", "ENGTH", "idth", "full", "enth", "l", "join", "ize", "padding", "duration", "address", "offset", "partial", "en", "ength", "time", "size", "available", "type", "buffer", "len", "end", " len", "sequence", "count", "total", "shape", "load", "lib", "Length"], "data": ["rew", "button", "join", "filter", "it", "str", "di", "valid", "reason", "ns", "response", "text", " DATA", "results", "final", "ta", "tx", "des", "json", "lu", "no", "a", "sp", "r", "done", "mu", "list", "dd", "obj", "w", "device", "output", "dat", "mem", "def", "at", "zero", "buffer", "mid", "len", "ops", "raw", "args", "all", "apps", "block", "last", "details", "api", "d", "att", "aw", " Data", "params", "Data", "size", "fa", "format", "off", "ata", "m", "rel", "table", "add", "out", "t", "dt", "td", "ds", "to", "DATA", "set", "prop", "attr", "bytes", "info", "buf", "step", "trace", "da", "actions", "window", "bin", "then", "next", "cache", "batch"], "s": ["t", "os", "S", "syn", "ds", "is", "a", "d", "v", "ps", "spec", "serv", "w", "sam", "set", "ss", "self", "ports", "j", "h", "bs", "sd", "js", "ns", "b", "state", "sq", "g", "ses", "sts", "pers", "rs", "gs", "ts", "m", "fs", "sv", "cs", "sb", "c", "settings", "sys", "services"], "ret": ["deg", "get", "gt", "full", "RET", "nt", "it", "txt", "ry", "rem", "gc", "db", "det", "final", "url", "cmd", "sort", "arg", "r", "re", "note", "obj", "fun", "j", "mem", "mt", "def", "ref", "len", "ts", "try", "report", "last", "tn", "reset", "details", "att", "ft", "rets", "ext", "format", "mb", "detail", "rest", "print", "end", "rel", "summary", " RET", "alt", "rt", "out", "t", "elt", "dt", "ll", "v", "cat", "Ret", "val", "prop", "result", "resp", "rev", "status", "res", "tr", "ter", " Ret", "back", "err"], "port": ["key", "pp", "host", "pkg", "pc", "it", "file", "connection", "pro", "handle", "pt", "net", "interface", "row", "mit", "page", "bridge", "project", "queue", "pan", "be", "ptr", "cp", "way", "serv", "seat", "phy", "Port", "export", "ve", "device", "profile", "driver", "po", "def", "termin", "proxy", "timeout", "member", "tip", "ort", "report", "pi", "import", "pod", " sport", "plugin", "component", "policy", "version", "pport", "ports", "eport", "state", "manager", "point", "feature", "type", "peer", "pool", "end", "table", "var", "pid", "go", "public", "vp", "t", "ported", "form", "v", "pipe", "channel", "ping", "select", "server", "prop", "trace", "per", "pr", "status", "pin", "gp", "tr", "service", "PORT", "test", "client", "mate", "player", "boat"], "n": ["ng", "t", "fn", "ln", "f", "d", "l", "v", "nn", "r", "nt", "nor", "note", "any", "ion", "en", "ation", "j", "ne", "cn", "o", "dn", "nm", "i", "ns", "size", "nan", "ex", "np", "gn", "nr", "g", "an", "mn", "ner", "new", "sn", "un", "m", "na", "N", "all", "names", "num", "number", "x", "on", "c", "ren", "z", "nb", "nc", "tn"]}}
{"project": "FFmpeg", "commit_id": "7684a36113fa12c88ba80b5498f05849a6b58632", "target": 0, "func": "static int mxf_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st = s->streams[pkt->stream_index];\n\n    MXFStreamContext *sc = st->priv_data;\n\n    MXFIndexEntry ie = {0};\n\n\n\n    if (!mxf->edit_unit_byte_count && !(mxf->edit_units_count % EDIT_UNITS_PER_BODY)) {\n\n        mxf->index_entries = av_realloc(mxf->index_entries,\n\n            (mxf->edit_units_count + EDIT_UNITS_PER_BODY)*sizeof(*mxf->index_entries));\n\n        if (!mxf->index_entries) {\n\n            av_log(s, AV_LOG_ERROR, \"could not allocate index entries\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (st->codec->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n        if (!mxf_parse_mpeg2_frame(s, st, pkt, &ie)) {\n\n            av_log(s, AV_LOG_ERROR, \"could not get mpeg2 profile and level\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (!mxf->header_written) {\n\n        if (mxf->edit_unit_byte_count) {\n\n            mxf_write_partition(s, 1, 2, header_open_partition_key, 1);\n\n            mxf_write_klv_fill(s);\n\n            mxf_write_index_table_segment(s);\n\n        } else {\n\n            mxf_write_partition(s, 0, 0, header_open_partition_key, 1);\n\n        }\n\n        mxf->header_written = 1;\n\n    }\n\n\n\n    if (st->index == 0) {\n\n        if (!mxf->edit_unit_byte_count &&\n\n            (!mxf->edit_units_count || mxf->edit_units_count > EDIT_UNITS_PER_BODY) &&\n\n            !(ie.flags & 0x33)) { // I frame, Gop start\n\n            mxf_write_klv_fill(s);\n\n            mxf_write_partition(s, 1, 2, body_partition_key, 0);\n\n\n\n            mxf_write_klv_fill(s);\n\n            mxf_write_index_table_segment(s);\n\n        }\n\n\n\n        mxf_write_klv_fill(s);\n\n        mxf_write_system_item(s);\n\n\n\n        if (!mxf->edit_unit_byte_count) {\n\n            mxf->index_entries[mxf->edit_units_count].offset = mxf->body_offset;\n\n            mxf->index_entries[mxf->edit_units_count].flags = ie.flags;\n\n            mxf->index_entries[mxf->edit_units_count].temporal_ref = ie.temporal_ref;\n\n            mxf->body_offset += KAG_SIZE; // size of system element\n\n        }\n\n        mxf->edit_units_count++;\n\n    } else if (!mxf->edit_unit_byte_count && st->index == 1) {\n\n        mxf->index_entries[mxf->edit_units_count-1].slice_offset =\n\n            mxf->body_offset - mxf->index_entries[mxf->edit_units_count-1].offset;\n\n    }\n\n\n\n    mxf_write_klv_fill(s);\n\n    avio_write(pb, sc->track_essence_element_key, 16); // write key\n\n    if (s->oformat == &ff_mxf_d10_muxer) {\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            mxf_write_d10_video_packet(s, st, pkt);\n\n        else\n\n            mxf_write_d10_audio_packet(s, st, pkt);\n\n    } else {\n\n        klv_encode_ber4_length(pb, pkt->size); // write length\n\n        avio_write(pb, pkt->data, pkt->size);\n\n        mxf->body_offset += 16+4+pkt->size + klv_fill_size(16+4+pkt->size);\n\n    }\n\n\n\n    avio_flush(pb);\n\n\n\n    return 0;\n\n}\n", "idx": 7967, "substitutes": {"s": ["t", "os", "S", "p", "sports", "conf", "ans", "ds", "south", "is", "a", "ms", "l", "v", "sp", "ps", "ctx", "ins", "vs", "spec", "z", "w", "ss", "h", "aws", "comm", "ast", "changes", "bs", "i", "js", "ns", "hs", "b", "sq", "g", "ses", "sts", "scl", "sg", "rs", "gs", "status", "ts", "es", "stats", "m", "xs", "acs", "local", "fs", "its", "cs", "ims", "as", "c", "sb", "us", "ls", "sql", "ats", "n", "sys", "qs"], "pkt": ["pet", "wpct", "ppct", " pct", "dct", "Packet", "pct", "Pct", "Pet", "ckt", "cacket", "ppet", "cct", "dKT", "pKT", " pKT", "Pkt", "wpkt", "dkt", "dacket", "packet", "ppkt", "cet", " pet", "wpacket", "wpKT", "ppacket", " packet"], "mxf": ["modulefe", " mffe", "vmxf", "meancf", "Mfe", "adexff", " moxy", "mprintf", "meanxf", "mfx", "imcf", "amxc", "meanfx", " mlf", "vmfe", " mprintf", "rmeph", "imlf", " mfi", "meanprintf", "mcf", "Mxc", "mlf", " mfw", "mfif", "amxff", "gmxf", "gmfe", "adexf", "gmfo", "amfe", "cmxff", "adexc", "mfi", " mxd", "vmcf", "cmfx", "imprintf", "vmoxy", " mxe", "Mxe", "imxff", " mfo", "gxf", " mfx", "cmlf", "gcf", "cmcf", "vxc", "meanxff", "rmxc", "meanffe", "gmcf", "cmxf", "modulexf", "gxd", "imfx", "tmxff", "mxff", "mxd", "cmffe", "rmcf", "tmcf", "amxf", "modulecf", "hxf", "tmeph", "mffe", "rmxf", "vcf", "Mxf", "mxe", "tmxc", "hfe", "adefif", "hcf", "amoxy", "imxc", "imfif", "imxf", "modulefi", "Mfw", " mxff", "moxy", "vxf", "mfo", "mfe", " mcf", " mxc", "hfo", " mfe", "rmfw", "rmxe", "vfe", "tmxf", "amcf", "mfw", "gxe", "Mxff", "amlf", " meph", "mxc", "gmfi", "meph", "Mxd", " mfif", "Mcf"], "pb": ["tc", "vp", "pp", "cp", "p", "phys", "pkg", "cv", "bj", "lp", "PB", "sp", "ps", "ctx", "pc", "mp", "pg", "dc", "typ", "cb", "ub", "pa", "bs", "proc", "np", "b", "buf", "pr", "fp", "tp", "jp", "db", "gp", "bp", "pl", "uf", "sb", "pid", "ob", "tk", "rb", "wb"], "st": ["ST", "stage", "t", "p", "th", "td", "l", "v", "sp", "nt", "ctx", "it", "ost", "ft", "sm", "sta", "z", "sl", "obj", "str", "ss", "ist", "kt", "ra", "ast", "pt", "so", "bs", "mt", "ste", "est", "std", "sts", "store", "ts", "sn", "stat", "te", "tr", "sv", "stream", "sb", "sty", "St", "nd", "tx", "src", "c", "start", "rt", "stru", "se", "sw"], "sc": ["tc", "rc", "co", "cv", "SC", "esc", "sp", "ec", "ctx", "pc", "dc", "cl", "cc", "ss", "sci", "cr", "anc", "soc", "sq", "scl", "uc", "ca", "sv", "cs", "ac", "bc", "mc", "sw"], "edit_units_count": ["edit_unitsitycount", "edit_unit_length", "edit_units_carry", "edit_unit_nb", "edit_unitsingcount", "edit_units_current", "edit_units\u05bccarry", "edit_units_multi", "edit_unitsingcounter", "edit_unit_counter", "edit_units_length", "edit_unitsitymulti", "edit_unit_handle", "edit_units\u05bccount", "edit_unit_multi", "edit_unit_current", "edit_units\u05bcchild", "edit_unit_carry", "edit_units_child", "edit_unitsityhandle", "edit_units_handle", "edit_unit_count", "edit_units_counter", "edit_unitsingcurrent", "edit_unit_child", "edit_units_nb"]}}
{"project": "qemu", "commit_id": "3ad493fc5ea38c005670adc5933058a28ccabdd4", "target": 0, "func": "int cpu_arm_handle_mmu_fault (CPUState *env, target_ulong address,\n\n                              int access_type, int mmu_idx, int is_softmmu)\n\n{\n\n    uint32_t phys_addr;\n\n    target_ulong page_size;\n\n    int prot;\n\n    int ret, is_user;\n\n\n\n    is_user = mmu_idx == MMU_USER_IDX;\n\n    ret = get_phys_addr(env, address, access_type, is_user, &phys_addr, &prot,\n\n                        &page_size);\n\n    if (ret == 0) {\n\n        /* Map a single [sub]page.  */\n\n        phys_addr &= ~(uint32_t)0x3ff;\n\n        address &= ~(uint32_t)0x3ff;\n\n        tlb_set_page (env, address, phys_addr, prot | PAGE_EXEC, mmu_idx,\n\n                      page_size);\n\n        return 0;\n\n    }\n\n\n\n    if (access_type == 2) {\n\n        env->cp15.c5_insn = ret;\n\n        env->cp15.c6_insn = address;\n\n        env->exception_index = EXCP_PREFETCH_ABORT;\n\n    } else {\n\n        env->cp15.c5_data = ret;\n\n        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))\n\n            env->cp15.c5_data |= (1 << 11);\n\n        env->cp15.c6_data = address;\n\n        env->exception_index = EXCP_DATA_ABORT;\n\n    }\n\n    return 1;\n\n}\n", "idx": 7972, "substitutes": {"env": ["commit", "et", "conf", "estate", "conn", "em", "msg", "txt", "dh", "dn", "forge", "ah", "esi", "response", "vm", "db", "operator", "queue", "message", "er", "viron", "cmd", "event", "uv", "ptr", "ei", "equ", "query", "gear", "dev", "environment", "vs", "ctx", "worker", "inv", "obj", "ew", "en", "ve", "esm", "eng", "ner", "buffer", "answer", "code", "kernel", "sb", "context", "shell", "rb", "esc", "cb", "nv", "era", "here", "outer", " environment", "manager", "command", "e", "end", "te", "engine", "editor", "ov", "Environment", "ef", "eh", "oe", "vt", "ev", "init", "vp", "doc", "actor", "cv", "v", "ec", "enter", "server", "ee", "console", "erd", "sv", "hw", "window", "desc", "chart", "see", "err"], "address": ["search", "ptr", "request", "ace", "order", "host", "eth", "a", "resource", "id", "argument", "data", "length", "path", "ad", "position", "enter", "account", "alias", "object", "port", "description", "phrase", "device", "attribute", "adr", "location", "history", "ip", "pointer", "event", "index", "name", "memory", "comment", "mac", "point", "password", "type", "network", "interface", "buffer", "command", "target", "record", "holder", "instance", "domain", "table", "service", "addr", "Address", "number", "reference", "route", "region", "ash", "email", "message", "block", "context", "add", "array", "reply", "execute", "dress", "action"], "access_type": ["accessureType", "index_Type", "access___typ", "access_level", "index___policy", "access_operator", "auth_Type", "access___id", " access_id", "accessityType", "authityType", "index_policy", "accessityoperator", "accessaccesstyp", "access___type", "index_type", "accessaccessType", "access_policy", "index___typ", "authitytype", "access_spec", "index___Type", " access_spec", "auth_ype", "access_id", "accessitytype", "accessurelevel", "index_typ", " access_kind", "auth_type", "auth_operator", "access_ype", " access_Type", "accessityype", "authityoperator", "accessuretype", "access_kind", "access_Type", "access_typ", "access___spec", " access_level", "accessurekind", "accessaccesspolicy", "access___policy", "accessaccesstype", "index___type", "access___Type", "authityype"], "mmu_idx": ["mmu_ridx", "mmu_idxf", "mmu_idexf", "mmu_idey", "mmu_ridn", "mmu_idex", "mmu_Idxf", "mmu_ridxc", "mmu__idxf", "mmu_Idx", "mmu__idn", "mmu_idy", "mmu_idX", "mmu_ridX", "mmu_Idxc", "mmu_Idn", "mmu_Idy", "mmu__idx", "mmu_idn", "mmu_idexc", "mmu_idxc", "mmu_IdX", "mmu__idxc", "mmu_iden"], "is_softmmu": ["is_hardmemus", "is_softmmux", "is_softmemux", "is_hardmmu", "is_softmaus", "is_softmemus", "is_softumux", "is_hardmemux", "is_softumcu", "is_hardmmux", "is_softmmus", "is_softmemu", "is_hardmemcu", "is_softmau", "is_hardmemu", "is_softmmcu", "is_softmemcu", "is_softmaux", "is_softumus", "is_hardmmus", "is_softmacu", "is_softumu", "is_hardmmcu"], "phys_addr": ["phys_ptr", " phys_conn", "phys_add", "phys_map", "physical_addr", "phy_address", "phys__addr", "phys__ref", "physical_ref", "physongconn", "phy_addr", "phys_address", " phys_src", " phys__ref", "physongref", " phys_map", " phys__addr", "phy_attr", " phys_add", "physongaddr", "physical_ptr", "physical_address", "phy_info", "phys_ref", " phys__map", "phys_conn", "phys__map", "phys_attr", " phys_ref", " phys__conn", "physongmap", "phys_info", "phys_src", "phys__conn"], "page_size": ["pageingindex", "pagemodsize", " page_count", "page_height", "window_length", "pageLSIZE", "pagemodcount", "page_length", "page2count", "pageLspeed", "page_speed", "page_SIZE", "page_index", "pageingSIZE", "window_index", "page_state", "page2size", "pageLsize", "pool_SIZE", "pageLstate", "page_count", "pagemodheight", " page_height", "pool_state", "window_size", "window_SIZE", "pool_size", "page2height", "pageinglength", "pool_speed", "pageingsize"], "prot": ["tif", "ptr", "phys", "eth", "pkg", "tf", "rot", "ocol", "col", "pc", "policy", "virtual", "prefix", "mult", "typ", "chron", "ext", "phy", "platform", "version", "prop", "Prot", "pro", "port", "kind", "method", "size", "format", "ht", " PROT", "password", "net", "type", "gap", "status", "tp", "crypt", "jp", "stat", "pat", "pattern", "seq", "tech", "pos", "cmd"], "ret": ["ptr", "deg", "out", "t", "reset", "inter", "gt", "lit", "elt", "eth", "pert", "RET", "rm", "arg", "att", "nt", "re", "cont", "Ret", "ft", "cor", "Return", "rets", "txt", "val", "fun", "ne", "rem", "vector", "mem", "mt", "result", "def", "resp", "response", "rev", "ref", "len", "print", "jp", "res", "det", "bit", "tr", "ter", "ert", "addr", "reg", "try", "aux", "rt", "back", "alt", "reply", "encrypted", "err", "cmd"], "is_user": ["is___User", "is__user", "is_usr", "is_User", "is__username", "is_device", "is_username", " is_User", "isThedevice", "is___user", "isTheuser", "is__User", " is_username", " is_device", "is___usr", " is_usr", "isTheUser"]}}
{"project": "FFmpeg", "commit_id": "082cf97106e2e94a969877d4f8c05c1e526acf54", "target": 0, "func": "static inline int get_chroma_qp(H264Context *h, int t, int qscale){\n\n    return h->pps.chroma_qp_table[t][qscale];\n\n}\n", "idx": 7977, "substitutes": {"h": ["ph", "hm", "pp", "p", "host", "oh", "ih", "ch", "bh", "f", "d", "l", "v", "H", "ctx", "q", "obj", "w", "cc", "k", "he", "j", "o", "comm", "in", "dh", "i", "hs", "ht", "b", "mem", "ah", "g", "sh", "m", "hw", "ac", "c", "hp", "n", "context"], "t": ["tc", "p", "task", "dt", "td", "tt", "ty", "f", "a", "d", "l", "it", "q", "vt", "typ", "str", "k", "j", "pt", "wt", "time", "i", "at", "type", "tip", "tp", "ts", "ti", "te", "m", "tr", "title", "ct", "ta", "qt", "c", "s", "n", "rt", "T"], "qscale": ["qualScale", "dqscale", " qshape", "dqsc", "qwarn", " Qscale", "qsc", "chstatus", "qualshape", "qstatus", "dqcale", "psc", "chcale", "qcale", " qScale", "qScale", " Qshape", "qualwarn", "chsc", " Qwarn", "qualscale", " QScale", "pstatus", "qshape", " qwarn", "pcale", "pscale", "dqstatus", "chscale"]}}
{"project": "FFmpeg", "commit_id": "fd92dafaff8844b5fedf94679b93d953939a7f7b", "target": 0, "func": "static int binkb_decode_plane(BinkContext *c, AVFrame *frame, BitstreamContext *bc,\n\n                              int plane_idx, int is_key, int is_chroma)\n\n{\n\n    int blk, ret;\n\n    int i, j, bx, by;\n\n    uint8_t *dst, *ref, *ref_start, *ref_end;\n\n    int v, col[2];\n\n    const uint8_t *scan;\n\n    int xoff, yoff;\n\n    LOCAL_ALIGNED_16(int16_t, block, [64]);\n\n    LOCAL_ALIGNED_16(int32_t, dctblock, [64]);\n\n    int coordmap[64];\n\n    int ybias = is_key ? -15 : 0;\n\n    int qp;\n\n\n\n    const int stride = frame->linesize[plane_idx];\n\n    int bw = is_chroma ? (c->avctx->width  + 15) >> 4 : (c->avctx->width  + 7) >> 3;\n\n    int bh = is_chroma ? (c->avctx->height + 15) >> 4 : (c->avctx->height + 7) >> 3;\n\n\n\n    binkb_init_bundles(c);\n\n    ref_start = frame->data[plane_idx];\n\n    ref_end   = frame->data[plane_idx] + (bh * frame->linesize[plane_idx] + bw) * 8;\n\n\n\n    for (i = 0; i < 64; i++)\n\n        coordmap[i] = (i & 7) + (i >> 3) * stride;\n\n\n\n    for (by = 0; by < bh; by++) {\n\n        for (i = 0; i < BINKB_NB_SRC; i++) {\n\n            if ((ret = binkb_read_bundle(c, bc, i)) < 0)\n\n                return ret;\n\n        }\n\n\n\n        dst  = frame->data[plane_idx]  + 8*by*stride;\n\n        for (bx = 0; bx < bw; bx++, dst += 8) {\n\n            blk = binkb_get_value(c, BINKB_SRC_BLOCK_TYPES);\n\n            switch (blk) {\n\n            case 0:\n\n                break;\n\n            case 1:\n\n                scan = bink_patterns[bitstream_read(bc, 4)];\n\n                i = 0;\n\n                do {\n\n                    int mode = bitstream_read_bit(bc);\n\n                    int run  = bitstream_read(bc, binkb_runbits[i]) + 1;\n\n\n\n                    i += run;\n\n                    if (i > 64) {\n\n                        av_log(c->avctx, AV_LOG_ERROR, \"Run went out of bounds\\n\");\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    if (mode) {\n\n                        v = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                        for (j = 0; j < run; j++)\n\n                            dst[coordmap[*scan++]] = v;\n\n                    } else {\n\n                        for (j = 0; j < run; j++)\n\n                            dst[coordmap[*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                    }\n\n                } while (i < 63);\n\n                if (i == 63)\n\n                    dst[coordmap[*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                break;\n\n            case 2:\n\n                memset(dctblock, 0, sizeof(*dctblock) * 64);\n\n                dctblock[0] = binkb_get_value(c, BINKB_SRC_INTRA_DC);\n\n                qp = binkb_get_value(c, BINKB_SRC_INTRA_Q);\n\n                read_dct_coeffs(bc, dctblock, bink_scan, binkb_intra_quant, qp);\n\n                c->binkdsp.idct_put(dst, stride, dctblock);\n\n                break;\n\n            case 3:\n\n                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);\n\n                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;\n\n                ref = dst + xoff + yoff * stride;\n\n                if (ref < ref_start || ref + 8*stride > ref_end) {\n\n                    av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\");\n\n                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {\n\n                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);\n\n                } else {\n\n                    put_pixels8x8_overlapped(dst, ref, stride);\n\n                }\n\n                c->bdsp.clear_block(block);\n\n                v = binkb_get_value(c, BINKB_SRC_INTER_COEFS);\n\n                read_residue(bc, block, v);\n\n                c->binkdsp.add_pixels8(dst, block, stride);\n\n                break;\n\n            case 4:\n\n                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);\n\n                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;\n\n                ref = dst + xoff + yoff * stride;\n\n                if (ref < ref_start || ref + 8 * stride > ref_end) {\n\n                    av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\");\n\n                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {\n\n                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);\n\n                } else {\n\n                    put_pixels8x8_overlapped(dst, ref, stride);\n\n                }\n\n                memset(dctblock, 0, sizeof(*dctblock) * 64);\n\n                dctblock[0] = binkb_get_value(c, BINKB_SRC_INTER_DC);\n\n                qp = binkb_get_value(c, BINKB_SRC_INTER_Q);\n\n                read_dct_coeffs(bc, dctblock, bink_scan, binkb_inter_quant, qp);\n\n                c->binkdsp.idct_add(dst, stride, dctblock);\n\n                break;\n\n            case 5:\n\n                v = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                c->bdsp.fill_block_tab[1](dst, v, stride, 8);\n\n                break;\n\n            case 6:\n\n                for (i = 0; i < 2; i++)\n\n                    col[i] = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                for (i = 0; i < 8; i++) {\n\n                    v = binkb_get_value(c, BINKB_SRC_PATTERN);\n\n                    for (j = 0; j < 8; j++, v >>= 1)\n\n                        dst[i*stride + j] = col[v & 1];\n\n                }\n\n                break;\n\n            case 7:\n\n                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);\n\n                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;\n\n                ref = dst + xoff + yoff * stride;\n\n                if (ref < ref_start || ref + 8 * stride > ref_end) {\n\n                    av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\");\n\n                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {\n\n                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);\n\n                } else {\n\n                    put_pixels8x8_overlapped(dst, ref, stride);\n\n                }\n\n                break;\n\n            case 8:\n\n                for (i = 0; i < 8; i++)\n\n                    memcpy(dst + i*stride, c->bundle[BINKB_SRC_COLORS].cur_ptr + i*8, 8);\n\n                c->bundle[BINKB_SRC_COLORS].cur_ptr += 64;\n\n                break;\n\n            default:\n\n                av_log(c->avctx, AV_LOG_ERROR, \"Unknown block type %d\\n\", blk);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n    if (bitstream_tell(bc) & 0x1F) // next plane data starts at 32-bit boundary\n\n        bitstream_skip(bc, 32 - (bitstream_tell(bc) & 0x1F));\n\n\n\n    return 0;\n\n}\n", "idx": 7980, "substitutes": {"c": ["mc", "tc", "rc", "sc", "t", "cm", "cp", "p", "cu", "conf", "co", "com", "cv", "config", "f", "d", "l", "vc", "ec", "lc", "ctx", "cont", "r", "cor", "dc", "call", "C", "con", "cd", "cb", "w", "cl", "cc", "abc", "h", "cn", "gc", "cr", "fc", "chain", "b", "comp", "g", "cf", "e", "ci", "cam", "m", "content", "ca", "xc", "ce", "cs", "ct", "ac", "n", "context", "nc", "cache"], "frame": ["function", "fr", "scene", "t", "request", "p", "f", "fram", "iframe", "data", "channel", "component", "me", "image", "file", "error", "condition", "frames", "call", "force", "version", "object", "show", "module", "fc", "profile", "chain", "b", "state", "rig", "feature", "point", "role", "range", "Frame", "buffer", "remote", "command", "process", "code", "e", "face", "flow", "framework", "m", "movie", "cf", "page", "ce", "zone", "sequence", "window", "core", "user", "video", "block", "box", "context", "picture", "ence", "rame", "event", "close"], "bc": ["mc", "bo", "tc", "sc", "bi", "bt", "bm", "vc", "ec", "lc", "ctx", "pc", "ic", "dc", "cb", "arc", "cc", "gc", "bs", "fc", "b", "bb", "BC", "uc", "ba", "cf", "ck", "bg", "ca", "xc", "bp", "cs", "sb", "bf", "nc", "bd"], "plane_idx": ["plane_itp", "plane_idh", "plane_Idxc", "plane_idxc", "plane_tryf", "plane_identz", "plane_indy", "plane_infoix", "plane_IDp", "plane_indh", "plane_idexc", "plane_Idy", "plane_inz", "plane_itix", "plane_Idze", "plane_midf", "plane__idp", "plane_tryh", "plane_tryx", "plane_idf", "plane_idX", "plane_IDz", "plane_uidy", "plane_identx", "plane_itx", "plane_tryp", "plane__idX", "plane_Idx", "plane__inz", "plane_ndice", "plane_indxc", "plane_identze", "plane_midix", "plane_tryix", "plane__inp", "plane_tryw", "plane_inp", "plane_idix", "plane_ndz", "plane__idx", "plane_tryy", "plane_idze", "plane__inX", "plane_uidix", "plane_idp", "plane_infox", "plane_idz", "plane_itf", "plane_idice", "plane__idz", "plane_midz", "plane_infof", "plane_indx", "plane_uidx", "plane_Idice", "plane_Idz", "plane_IDx", "plane_idy", "plane_indf", "plane_ndze", "plane__inx", "plane_IDX", "plane_idex", "plane_infoz", "plane_idey", "plane_uidw", "plane_ith", "plane_inx", "plane_inX", "plane_ndx", "plane_identice", "plane_itz", "plane_indp", "plane_idw", "plane_midx"], "is_key": [" is_char", "is_keys", " is_keys", "is_root", " is_row", " is_root", " is_Key", "is__key", "is__Key", "is__root", "is_row", "is__keys", "is_Key", "is_char"], "is_chroma": ["is_chanai", "is_chromu", "is_chanan", "is_chromara", "is_archA", "is_genA", "is_chanu", "is_chroman", "is_chromia", "is_chinan", "is_chinai", "is_roma", "is_geno", "is_china", "is_chana", "is_romu", "is_chromA", "is_archara", "is_chinu", "is_romA", "is_romo", "is_chromai", "is_genia", "is_romia", "is_archo", "is_romai", "is_roman", "is_archa", "is_romara", "is_gena", "is_chromo"], "blk": ["brak", "Blk", "Blark", "blark", "blek", "BLak", "blsk", "bmak", "brock", " blj", "blak", "BLck", "Blak", "brck", "Blsk", "blesk", "bmck", "Blck", "BLk", "brk", "selk", "bleck", "selak", "selck", "brok", "BLtk", "broark", "bleark", "selj", "bmtk", "bltk", "bmk", "blj", " blak", "Blj", " blck", "brosk", "brtk", "blck"], "ret": ["reset", "gt", "dt", "ll", "RET", "rm", "cat", "nt", "re", "r", "cont", "not", "Ret", "it", "rets", "txt", "val", "ry", "rem", "mem", "mt", "resp", "def", "result", "err", "over", "nz", "net", "rev", "tail", "rest", "ber", "print", "res", "rel", "det", "report", "tr", "try", "summary", " RET", " Ret", "alt", "rt", "out"], "i": ["ia", "ei", "li", "t", "p", "sim", "ki", "bi", "is", "f", "id", "l", "ii", "ind", "ini", "r", "mi", "ix", "me", "it", "ic", "parent", "\u0438", "hi", "si", "k", "oi", "h", "di", "gi", "o", "io", "ri", "iq", "ie", "ip", "chain", "b", "index", "info", "g", "ui", "iu", "multi", "ij", "ir", "y", "zi", "xi", "iter", "ci", "ti", "m", "ami", "ai", "pi", "im", "x", "I", "qi", "phi", "cli", "n"], "j": ["json", "dj", "jac", "bi", "l", "jj", "jl", "q", "jc", "aj", "si", "lock", "ji", "js", "jump", "g", "ij", "kj", "ot", "jp", "uj", "m", "rel", "job", "J", "n", "pos", "z"], "bx": ["bw", "bbx", "nbw", "bix", "dbxx", "bex", "lix", "bbw", "bbix", "biw", "bixe", "dz", "dbx", "blix", "biix", "dbix", "blx", "bz", "lw", "dx", "abix", " bix", "dix", "dxe", " bxx", "nbx", "lx", "nbix", "abw", "bxx", "dw", "dbw", "bxe", "blex", " bw", "nbxe", "dbz", " bex", "abz", "abx", "blxx", "dbex"], "by": ["key", "out", "byn", "os", "sim", "ch", "no", "be", "bi", "is", "re", "to", "some", "it", "my", "stable", "serv", "BY", "ger", "pro", "or", "ry", "with", "br", "di", "via", "where", "io", "each", "bs", "b", "when", "index", "how", "nr", "at", "range", "type", "ber", "y", "ly", "db", "browser", "try", "unit", "bys", "that", "By", "sv", "jit", "as", "us", "user", "bin", "from", "then", "on", "s", "sys", "using", "reg", "yes", "just"], "dst": ["diffnd", "Dnet", "bdsts", "vst", "dbST", "bdset", "vnd", "dnd", "dest", "dend", " dnet", "dbst", " dsts", "dsest", "bend", "dsst", "dssts", "Dx", "vST", "Dst", " dend", " dset", "dST", "dset", "dx", " dx", "diffut", "bst", "Dend", "vut", "dut", "diffst", "bdest", "bnet", "bdst", "dbut", "dnet", "diffST", "dsset", " dest", "dbnd", "dsts"], "ref": ["f", "id", "ind", "re", "loc", "offset", "val", "rem", "mem", "def", "index", "range", "rev", "img", "rec", "rel", "local", "base", "Ref", "reference", "ef", "ob", "vis", "pos", "reg"], "ref_start": ["port_end", "reference_start", "ref_part", "ref_inter", "ref_len", "port_part", "port_start", "reference_len", "reference_end", "ref_st", "port_inter", "reference_st"], "ref_end": ["ref_target", "ref_nd", "reference_start", "Ref_start", "Ref_end", "refdbend", "ref_ended", "refdbended", "refdbtarget", "reference_target", "reference_ended", "Ref_nd", "refdbstart", "reference_end"], "v": ["t", "p", "ch", "cv", "f", "vc", "l", "r", "vert", "q", "vt", "val", "k", "b", "g", "iv", "m", "conv", "vec", "sv", "var", "vis", "n", "V", "uv"], "col": ["fil", "key", "cp", "co", "ch", "Col", "rot", "cat", "sect", "channel", "cor", "serv", "con", "loc", "val", "fl", "cell", "def", "dir", "il", "act", "icon", "row", "column", "ct", "num", "param", "pos", "cmd"], "scan": ["search", "sc", "Scan", "query", "cp", "conf", "ch", "cat", "filter", "ignore", "path", "cor", "sync", "check", "select", "map", "watch", "k", "read", "chain", "ann", "feature", "an", "range", "ner", "row", "match", "can", "stat", "scale", "parse", "mask", "bin", "sky", "vis", "skip", "sys", "batch"], "xoff": ["exoffset", "dxoffs", "xoffs", "exoff", "xoffset", "dxoff", " xoffset", " xoffs", "exoffs", "dxoffset"], "yoff": ["yyoffs", " yoffset", "xOff", "yyoffset", "xoffs", "yyoff", "xoffset", "yOff", "yyOff", " yoffs", "yoffset", " yOff", "yoffs"], "coordmap": ["xymap", "pixelmap", "charmaps", "ordMap", "ordmap", "dimset", "coordMap", " coordmaps", "pixelmaps", "xymaps", "dimMap", "dimmap", "xyMap", "charMap", " coordset", "charset", " coordMap", "pixelMap", "ordmaps", "xyset", "charmap", "dimmaps", "ordset", "coordset", "pixelset", "coordmaps"], "qp": [" qpa", "QP", "Qpa", "qP", " qP", "qqpa", "Qpc", "qqp", "qqP", "Qp", "qpc", "qqpc", "qpa", " qpc"]}}
{"project": "qemu", "commit_id": "f8c88bbcda76d5674e4bb125471371b41d330df8", "target": 1, "func": "static int get_cpsr(QEMUFile *f, void *opaque, size_t size)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    CPUARMState *env = &cpu->env;\n\n    uint32_t val = qemu_get_be32(f);\n\n\n\n    env->aarch64 = ((val & PSTATE_nRW) == 0);\n\n\n\n    if (is_a64(env)) {\n\n        pstate_write(env, val);\n\n        return 0;\n\n    }\n\n\n\n    /* Avoid mode switch when restoring CPSR */\n\n    env->uncached_cpsr = val & CPSR_M;\n\n    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);\n\n    return 0;\n\n}\n", "idx": 7982, "substitutes": {"f": ["af", "fr", "t", "p", "fn", "fi", "tf", "lf", "d", "l", "fac", "v", "r", "fb", "file", "fd", "q", "sf", "h", "xf", "fc", "fa", "b", "F", "fed", "rf", "fe", "fp", "cf", "e", "fo", "fs", "ile", "uf", "c", "ef", "bf", "inf", "fx"], "opaque": ["oplaques", "boaques", "ipaque", "Opacity", "oppin", "opaques", "iparam", "oppaque", "oplque", "Opaque", "Opaco", "boque", "boaram", "oplaque", "opin", " opaco", "oppaco", "opaco", "opque", "ipque", "oplaram", "ipaques", "oparam", "Opin", " opin", "opacity", " opacity", "oppacity", "boaque"], "size": ["Size", "dim", "data", "length", "SIZE", "ize", "w", " Size", "h", "st", "empty", "space", "mem", "name", "type", "len", "alloc", "code", "scale", "args", "count", "iz", "shape", "value", "err"], "cpu": ["ka", "cu", "cp", "p", "util", "phys", "ork", "conn", "aco", "processor", "ec", "ctx", "mu", "pc", "prof", "gpu", "obj", " proc", "node", "chip", "uu", "upt", "gc", "anc", "mem", "proc", "np", "clock", "arch", "CPU", "alloc", "process", "stat", "boot", "runner", "pu", "rom", "core", "ram", "hw", "num", "c", "pod", "nic"], "env": ["et", "kh", "estate", "pkg", "conn", "ea", "txt", "cur", "vr", "dh", "dn", "ey", "ah", "db", "hl", "er", "nc", "viron", "cmd", "uv", "eas", "ei", "ote", "equ", "dev", "environment", "el", "vs", "ctx", "eg", "scope", "serv", "obj", "ew", "en", "export", "ve", "eng", "enc", "ent", "context", "entry", "den", "priv", "eu", "esc", "cb", "ext", "nv", "here", "eq", "eni", "e", "end", "ov", "var", "ef", "eh", "oe", "ev", "vt", "vp", "cv", "v", "ec", "enter", "bar", "vv", "val", "server", "attr", "buf", "erd", "addr", "window", "desc", "next", "err"]}}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_handle_byte(int ch)\n\n{\n\n    switch(term_esc_state) {\n\n    case IS_NORM:\n\n        switch(ch) {\n\n        case 1:\n\n            term_bol();\n\n            break;\n\n        case 4:\n\n            term_delete_char();\n\n            break;\n\n        case 5:\n\n            term_eol();\n\n            break;\n\n        case 9:\n\n            term_completion();\n\n            break;\n\n        case 10:\n\n        case 13:\n\n            term_cmd_buf[term_cmd_buf_size] = '\\0';\n\n\t    term_hist_add(term_cmd_buf);\n\n            term_printf(\"\\n\");\n\n            term_handle_command(term_cmd_buf);\n\n            term_show_prompt();\n\n            break;\n\n        case 27:\n\n            term_esc_state = IS_ESC;\n\n            break;\n\n        case 127:\n\n        case 8:\n\n            term_backspace();\n\n            break;\n\n\tcase 155:\n\n            term_esc_state = IS_CSI;\n\n\t    break;\n\n        default:\n\n            if (ch >= 32) {\n\n                term_insert_char(ch);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n    case IS_ESC:\n\n        if (ch == '[') {\n\n            term_esc_state = IS_CSI;\n\n            term_esc_param = 0;\n\n        } else {\n\n            term_esc_state = IS_NORM;\n\n        }\n\n        break;\n\n    case IS_CSI:\n\n        switch(ch) {\n\n\tcase 'A':\n\n\tcase 'F':\n\n\t    term_up_char();\n\n\t    break;\n\n\tcase 'B':\n\n\tcase 'E':\n\n\t    term_down_char();\n\n\t    break;\n\n        case 'D':\n\n            term_backward_char();\n\n            break;\n\n        case 'C':\n\n            term_forward_char();\n\n            break;\n\n        case '0' ... '9':\n\n            term_esc_param = term_esc_param * 10 + (ch - '0');\n\n            goto the_end;\n\n        case '~':\n\n            switch(term_esc_param) {\n\n            case 1:\n\n                term_bol();\n\n                break;\n\n            case 3:\n\n                term_delete_char();\n\n                break;\n\n            case 4:\n\n                term_eol();\n\n                break;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        term_esc_state = IS_NORM;\n\n    the_end:\n\n        break;\n\n    }\n\n    term_update();\n\n}\n", "idx": 7992, "substitutes": {"ch": ["ph", "key", "sc", "cp", "p", "gt", "th", "wh", "com", "ech", " Ch", "ach", "vc", "v", "cho", "ctr", "sp", "col", "channel", "och", "tch", "ic", "q", "change", "zh", "cl", "str", "cur", "k", "h", "j", "ok", "qu", "CH", "br", "che", "i", "b", "shift", "comp", "g", "Ch", "chrom", "sh", "character", "y", "code", "ich", "quit", "chan", "x", "c", "z", "cmd"]}}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "struct omap_l4_s *omap_l4_init(target_phys_addr_t base, int ta_num)\n\n{\n\n    struct omap_l4_s *bus = g_malloc0(\n\n                    sizeof(*bus) + ta_num * sizeof(*bus->ta));\n\n\n\n    bus->ta_num = ta_num;\n\n    bus->base = base;\n\n\n\n#ifdef L4_MUX_HACK\n\n    omap_l4_io_entries = 1;\n\n    omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry));\n\n\n\n    omap_cpu_io_entry =\n\n            cpu_register_io_memory(omap_l4_io_readfn,\n\n                            omap_l4_io_writefn, bus, DEVICE_NATIVE_ENDIAN);\n\n# define L4_PAGES\t(0xb4000 / TARGET_PAGE_SIZE)\n\n    omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES);\n\n#endif\n\n\n\n    return bus;\n\n}\n", "idx": 8010, "substitutes": {"base": ["phys", "p", "ases", "balance", "bi", "temp", "a", "bm", "origin", "id", "bid", "data", "prefix", "bas", "address", "offset", "pa", "size", "i", "bal", "source", "ip", "b", "state", "root", "index", "beta", "mb", "type", "ref", "buffer", "ma", "ba", "area", "db", "Base", "eta", "based", "m", "boot", "ase", "scale", "bp", "pi", "ta", "bin", "bf", "bu", "block", "pos", "start", "se", "ada"], "ta_num": ["tu67snap", "tu67num", " ta_mon", "ta_NUM", " ta_NUM", " ta2NUM", "ta67snap", "ta67mon", "ta2um", "ta_snap", "tu_snap", "tu_num", "ta_um", "ta_ver", "eta_sum", "ta_max", "ta__mon", "TA_Num", "TA_ver", "ta__NUM", " ta2mon", "TA_um", "ta67num", "eta_mon", "ta_str", "ta2num", "ta2ver", " ta2num", "ta67max", "tu_max", "ta2NUM", "ta2mon", "tu67max", "ta__num", "ta_Num", "TA_num", "ta_mon", "ta__str", "eta_num", "ta2Num", "tu_mon", "eta_um", "ta_sum", "ta2str", " ta2str", " ta_str", "tu67mon"], "bus": ["out", "init", "phys", "p", "util", "host", "dev", "disk", "cast", "os", "config", "full", "controller", "data", "ctx", "board", " BUS", "Bus", "handle", "port", "h", "gate", "build", "lock", "device", "o", "in", "bs", "chain", "driver", "proc", "b", "state", "gen", "buf", "http", "usb", "serial", "interface", " buses", "buffer", "di", " Bus", "boot", "used", "local", "volt", "bridge", "loop", "ac", "book", "us", "c", "mot", "back", "vol", "block", "box", "pos", "sys", "BUS", "al", "cache", "lib", "hand"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void qbus_list_bus(DeviceState *dev, char *dest, int len)\n\n{\n\n    BusState *child;\n\n    const char *sep = \" \";\n\n    int pos = 0;\n\n\n\n    pos += snprintf(dest+pos, len-pos,\"child busses at \\\"%s\\\":\",\n\n                    dev->id ? dev->id : dev->info->name);\n\n    LIST_FOREACH(child, &dev->child_bus, sibling) {\n\n        pos += snprintf(dest+pos, len-pos, \"%s\\\"%s\\\"\", sep, child->name);\n\n        sep = \", \";\n\n    }\n\n}\n", "idx": 8018, "substitutes": {"dev": ["conf", "den", "de", "ch", "th", "conn", "priv", "od", "debug", "d", "ind", "v", " device", "att", "nt", "Device", "app", "Dev", "ad", "dd", "serv", "any", "watch", "pro", "die", "av", "build", "pad", "device", "ve", "bus", "sd", "off", "proc", "def", "wd", "DEV", "ver", "sys", "info", "md", "develop", " def", "det", "unknown", "exec", "oy", "test", "hw", "var", "dis", "tech", "des", "del", "add", "ev", "dep", "cmd", "dem"], "dest": ["ptr", "deg", "master", "lit", "max", "tmp", "priv", "origin", "d", "dist", "cat", "sp", "nt", "nom", "dc", "pas", "transform", "w", "loc", "str", "trans", "prop", "port", "st", "gate", "dat", "source", "usr", "gen", "ident", "est", "orig", "buf", "decl", "rest", "target", "new", "iter", "end", "this", "coord", "addr", "desc", "num", "seq", "src", "Dest", "pos", "out", "cmd"], "len": [" el", "t", " l", "lim", "elt", "compl", "el", "lf", "ln", "ll", "full", "Len", "l", "le", " disp", "nt", "length", "fin", "mult", "coll", "mun", " le", "str", "offset", "en", "fl", " Len", "size", "bytes", "resp", " bl", "cmp", "wid", "enc", " seq", "end", " size", "line", " lengths", "vec", " length", "num", "seq", " lang", " en", "ls", "del", "lan", "nl", "n", "pos", " count"], "child": ["ch", "syn", "sec", "f", "sel", "ach", "v", "att", "nt", "data", "col", "fd", "parent", "q", "dd", "sync", "sub", "obj", "w", "node", "other", "unk", "self", "handle", "j", "h", "bus", "ibling", "cell", "proc", "b", "root", "Child", "children", "ib", "row", "new", "uncle", "local", "job", "win", "all", "c", "block", "shell", "se", "last", "batch", "close"], "sep": ["seper", "sedper", "SEg", "separ", "seep", "seg", "sedep", "separgment", "pseep", " seper", "cegment", "separpar", " sem", "spem", "cep", "SEper", "pseg", "sem", "sedp", "psem", "speep", "SEp", "psep", "speg", "ceg", "separp", "spep", " seep", " seg", "separg", "sedg", " separ", "segment", "cepar", "SEep", " segment"]}}
{"project": "qemu", "commit_id": "6817efea3a0d1bf87be815970cdb014c5a64b628", "target": 1, "func": "static int read_directory(BDRVVVFATState* s, int mapping_index)\n\n{\n\n    mapping_t* mapping = array_get(&(s->mapping), mapping_index);\n\n    direntry_t* direntry;\n\n    const char* dirname = mapping->path;\n\n    int first_cluster = mapping->begin;\n\n    int parent_index = mapping->info.dir.parent_mapping_index;\n\n    mapping_t* parent_mapping = (mapping_t*)\n\n        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);\n\n    int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -1;\n\n\n\n    DIR* dir=opendir(dirname);\n\n    struct dirent* entry;\n\n    int i;\n\n\n\n    assert(mapping->mode & MODE_DIRECTORY);\n\n\n\n    if(!dir) {\n\n        mapping->end = mapping->begin;\n\n        return -1;\n\n    }\n\n\n\n    i = mapping->info.dir.first_dir_index =\n\n            first_cluster == 0 ? 0 : s->directory.next;\n\n\n\n    if (first_cluster != 0) {\n\n        /* create the top entries of a subdirectory */\n\n        (void)create_short_and_long_name(s, i, \".\", 1);\n\n        (void)create_short_and_long_name(s, i, \"..\", 1);\n\n    }\n\n\n\n    /* actually read the directory, and allocate the mappings */\n\n    while((entry=readdir(dir))) {\n\n        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);\n\n        char* buffer;\n\n        direntry_t* direntry;\n\n        struct stat st;\n\n        int is_dot=!strcmp(entry->d_name,\".\");\n\n        int is_dotdot=!strcmp(entry->d_name,\"..\");\n\n\n\n        if(first_cluster == 0 && (is_dotdot || is_dot))\n\n            continue;\n\n\n\n        buffer = g_malloc(length);\n\n        snprintf(buffer,length,\"%s/%s\",dirname,entry->d_name);\n\n\n\n        if(stat(buffer,&st)<0) {\n\n            g_free(buffer);\n\n            continue;\n\n        }\n\n\n\n        /* create directory entry for this file */\n\n        if (!is_dot && !is_dotdot) {\n\n            direntry = create_short_and_long_name(s, i, entry->d_name, 0);\n\n        } else {\n\n            direntry = array_get(&(s->directory), is_dot ? i : i + 1);\n\n        }\n\n        direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20);\n\n        direntry->reserved[0]=direntry->reserved[1]=0;\n\n        direntry->ctime=fat_datetime(st.st_ctime,1);\n\n        direntry->cdate=fat_datetime(st.st_ctime,0);\n\n        direntry->adate=fat_datetime(st.st_atime,0);\n\n        direntry->begin_hi=0;\n\n        direntry->mtime=fat_datetime(st.st_mtime,1);\n\n        direntry->mdate=fat_datetime(st.st_mtime,0);\n\n        if(is_dotdot)\n\n            set_begin_of_direntry(direntry, first_cluster_of_parent);\n\n        else if(is_dot)\n\n            set_begin_of_direntry(direntry, first_cluster);\n\n        else\n\n            direntry->begin=0; /* do that later */\n\n        if (st.st_size > 0x7fffffff) {\n\n            fprintf(stderr, \"File %s is larger than 2GB\\n\", buffer);\n\n            g_free(buffer);\n\n            closedir(dir);\n\n            return -2;\n\n        }\n\n        direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size);\n\n\n\n        /* create mapping for this file */\n\n        if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) {\n\n            s->current_mapping = array_get_next(&(s->mapping));\n\n            s->current_mapping->begin=0;\n\n            s->current_mapping->end=st.st_size;\n\n            /*\n\n             * we get the direntry of the most recent direntry, which\n\n             * contains the short name and all the relevant information.\n\n             */\n\n            s->current_mapping->dir_index=s->directory.next-1;\n\n            s->current_mapping->first_mapping_index = -1;\n\n            if (S_ISDIR(st.st_mode)) {\n\n                s->current_mapping->mode = MODE_DIRECTORY;\n\n                s->current_mapping->info.dir.parent_mapping_index =\n\n                    mapping_index;\n\n            } else {\n\n                s->current_mapping->mode = MODE_UNDEFINED;\n\n                s->current_mapping->info.file.offset = 0;\n\n            }\n\n            s->current_mapping->path=buffer;\n\n            s->current_mapping->read_only =\n\n                (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;\n\n        } else {\n\n            g_free(buffer);\n\n        }\n\n    }\n\n    closedir(dir);\n\n\n\n    /* fill with zeroes up to the end of the cluster */\n\n    while(s->directory.next%(0x10*s->sectors_per_cluster)) {\n\n        direntry_t* direntry=array_get_next(&(s->directory));\n\n        memset(direntry,0,sizeof(direntry_t));\n\n    }\n\n\n\n/* TODO: if there are more entries, bootsector has to be adjusted! */\n\n#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)\n\n    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {\n\n        /* root directory */\n\n        int cur = s->directory.next;\n\n        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);\n\n        s->directory.next = ROOT_ENTRIES;\n\n        memset(array_get(&(s->directory), cur), 0,\n\n                (ROOT_ENTRIES - cur) * sizeof(direntry_t));\n\n    }\n\n\n\n    /* re-get the mapping, since s->mapping was possibly realloc()ed */\n\n    mapping = array_get(&(s->mapping), mapping_index);\n\n    first_cluster += (s->directory.next - mapping->info.dir.first_dir_index)\n\n        * 0x20 / s->cluster_size;\n\n    mapping->end = first_cluster;\n\n\n\n    direntry = array_get(&(s->directory), mapping->dir_index);\n\n    set_begin_of_direntry(direntry, mapping->begin);\n\n\n\n    return 0;\n\n}\n", "idx": 8021, "substitutes": {"s": ["t", "os", "S", "p", "ds", "south", "is", "a", "d", "l", "v", "sp", "r", "ps", "spec", "sl", "sam", "w", "less", "str", "set", "ss", "single", "self", "si", "h", "aws", "comm", "j", "span", "bs", "source", "ns", "js", "hs", "b", "space", "state", "sq", "g", "ses", "sts", "sg", "rs", "gs", "y", "ts", "es", "e", "stats", "m", "simple", "fs", "service", "sv", "csv", "sb", "c", "src", "qs", "sys"], "mapping_index": ["mapping2index", "mapper_type", "mapper_index", "mapping_ind", "mapping_position", "mapping_address", "mapping2ind", "mapper2index", "mapper2address", "mapper_position", "mapper_ind", "mapping2position", "mapper2position", "mapper2ind", "mapping2address", "mapping_type", "mapper_address"], "mapping": ["omapping", "matching", "lappings", " mapper", "mappings", "immap", "minding", "dapping", "mmap", "Mapper", "tapper", "tutation", "Map", "omap", "manapping", "smapping", "congo", "smap", "mmbinding", "manutation", " maching", "imapper", "nmapping", "manaping", "mapper", "Mapping", "nmapper", "capped", " maping", "tmaching", "imapping", "cmapping", "remapper", "mbinding", "mmapper", " mbinding", "capper", "Mappings", "maching", "laping", "lapped", "lapper", "mmapped", "Mmap", "remapping", "dmap", "lutation", "iminding", "taching", "maping", "taping", "cmapper", "Mutation", "map", "Minding", "dapper", " mappings", " mapped", "Mongo", "smapper", "manapper", "tapping", "remapped", "omapper", "cmatching", "Matching", "Maping", "dutation", "lapping", "mapped", "smapped", "omapped", "dinding", "mongo", "mmapping", "capping", "Mapped", "dapped", "nmapped", "remongo", "tmapper", "tapped", "cmapped", "tmapped", "nmatching", "mutation", "tmapping", "ombinding"], "direntry": ["direnttry", "durenotry", "dererentries", "derentries", "derententry", "direnary", "direndry", "direnry", "dirntentry", "direnr", "direnentry", "direrenttry", "durenotary", "direncentry", "direentry", "direvententry", "direrentries", "dererentEntry", "direnctry", "direncr", "durententry", "derentry", "dirntr", "durentary", "direenttry", "direventries", "direrentary", "dirncry", "dererentry", "durentry", "direnotentry", "direentr", "dirntry", "durenotr", "dererententry", "direncry", "direrententry", "direndries", "dirncr", "direrentr", "direnotary", "direententry", "direntary", "dirnttry", "direntEntry", "direrentEntry", "derentEntry", "direndEntry", "direntr", "direnotr", "direndentry", "dirententry", "dirnctry", "direrentry", "dirncentry", "direnotry", "direventEntry", "direventry", "durenotentry", "direntries", "durentr"], "dirname": ["folderstring", "filen", "dirn", "dirNAME", " dirName", "dircurrent", "pathn", "dirame", "directoryname", "foldername", "dName", "pathame", "pathNAME", "directoryn", "dirName", " directoryadmin", " directoryName", "pathname", "filename", " directorypath", "diskpath", "dn", " dircurrent", "dirpath", "fileame", " diradmin", "folderNAME", "dadmin", "pathpath", "directorycurrent", " dirpath", " dirame", "dpath", "dirstring", "dNAME", " dirn", "diskn", "diskcurrent", "dstring", "directorypath", "diskname", "foldern", " directoryname", "diradmin", "filepath", "pathstring", "dname"], "parent_mapping": ["parent_dapper", "parent_smapper", "parent_Mapped", "parent_lappings", "parent_dappings", "parent_Mapper", "parent_Mappings", "parent_mapper", "parent_smap", "parent_map", "parent_Mapping", "parent_papped", "parent_pap", "parent_mapped", "parent_mappings", "parent_papper", "parent_lapping", "parent_smapped", "parent_dapped", "parent_lapped", "parent_lapper", "parent_dapping", "parent_Map", "parent_papping", "parent_smapping"], "dir": ["ptr", "dr", "doc", "disk", "ds", "tmp", "full", "d", "dist", "ind", "dim", "sp", "data", "direction", "path", "file", "fd", "dd", "tar", "map", "Dir", "w", "str", "loc", "set", " directory", "folder", "node", "di", "irs", "module", "DIR", "in", "dict", "direct", "def", "name", "wd", "md", "zip", "ir", "iter", "rec", "db", "record", "m", "rect", "rel", "local", "window", "desc", "dis", "mod", "open", "pos", "directory", "add", "lib"], "entry": ["search", "key", "ace", "doc", "inter", "element", "data", "nt", "r", "entity", "it", "image", "error", "dd", "check", "connection", "obj", "ry", "option", "attribute", "ie", "word", "cell", "ror", "ary", "result", "def", "section", "name", "link", "info", "comment", "index", "member", "ner", "row", "Entry", "command", "match", "e", "record", "instance", "pair", "try", "child", "existent", "byte", "part", "ent", "import", "item", "escape", "RY", "directory", "see", "se", "event"], "i": ["ia", "init", "li", "fi", "limit", "bi", "is", "id", "ind", "ii", "ini", "mi", "ix", "it", "ic", "inv", "uri", "si", "oi", "di", "j", "ri", "io", "in", "ip", "index", "info", "ui", "iu", "xi", "ir", "ij", "y", "iter", "ci", "ti", "m", "iri", "bis", "ai", "pi", "im", "qi", "I", "phi", "x", "c", "n"], "buffer": ["screen", "copy", "limit", "temp", "binary", "v", "data", "length", "channel", "position", "stack", "address", "Buffer", "phrase", "device", "output", "buff", "empty", "size", "source", "mem", "bytes", "pointer", "clear", "result", "memory", "comment", "buf", "mb", "text", "row", "command", "iter", "code", "document", "raw", "page", "table", "base", "byte", "sequence", "window", "stream", "header", "queue", "block", "message", "shell", "cache", "batch", "template"], "st": ["ST", " dst", "ust", "sc", " ST", "fr", "ch", " est", "d", "sp", "r", "ost", " ss", "stack", "stable", "inst", "sm", "obj", " status", " et", "str", " St", "set", "sth", "mt", "ste", " step", "est", "step", "std", "sts", "rest", "status", "stat", "ct", "nd", "St", "start", " sc", "se"]}}
{"project": "FFmpeg", "commit_id": "dc5d1515681b57a257443ba72bb81fb3e6e6621b", "target": 0, "func": "static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)\n\n{\n\n    const char *p;\n\n    char *q, buf1[20], c;\n\n    int nd, len, addchar_count;\n\n    int found_count = 0;\n\n\n\n    q = buf;\n\n    p = filename;\n\n    for (;;) {\n\n        c = *p;\n\n        if (c == '\\0')\n\n            break;\n\n        if (c == '%' && *(p+1) == '%')  // %%\n\n            addchar_count = 2;\n\n        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {\n\n            nd = 0;\n\n            addchar_count = 1;\n\n            while (av_isdigit(*(p + addchar_count))) {\n\n                nd = nd * 10 + *(p + addchar_count) - '0';\n\n                addchar_count++;\n\n            }\n\n\n\n            if (*(p + addchar_count) == placeholder) {\n\n                len = snprintf(buf1, sizeof(buf1), \"%0*\"PRId64, (number < 0) ? nd : nd++, number);\n\n                if (len < 1)  // returned error or empty buf1\n\n                    goto fail;\n\n                if ((q - buf + len) > buf_size - 1)\n\n                    goto fail;\n\n                memcpy(q, buf1, len);\n\n                q += len;\n\n                p += (addchar_count + 1);\n\n                addchar_count = 0;\n\n                found_count++;\n\n            }\n\n\n\n        } else\n\n            addchar_count = 1;\n\n\n\n        while (addchar_count--)\n\n            if ((q - buf) < buf_size - 1)\n\n                *q++ = *p++;\n\n            else\n\n                goto fail;\n\n    }\n\n    *q = '\\0';\n\n    return found_count;\n\nfail:\n\n    *q = '\\0';\n\n    return -1;\n\n}\n", "idx": 8046, "substitutes": {"buf": ["rc", "out", "bn", "cp", "pkg", "cv", "tmp", "v", "data", "ctx", "xff", "file", "msg", "txt", "cb", "loc", "Buffer", "cur", "ff", "h", "br", "read", "buff", "mem", "bytes", "b", "err", "orig", "que", "brace", "bl", "pb", "cap", "ref", "buffer", "iter", "db", "used", "uf", "var", "seq", "queue", "bin", "bu", "bf", "cmd", "ob", "box", "rb", "next", "cache", "bc", "wb", "batch"], "buf_size": ["buf8size", "buf_Size", " buf_Size", "buffer_name", "buf2size", "buf1name", "buf1size", "buf8ize", "buf_name", "buf_start", "buf2Size", "buf8name", "buf2name", " buf_SIZE", "buffer_size", "buf_ize", " buf_ize", "buf8SIZE", "buf2SIZE", "buffer_SIZE", "buf1Size", "buffer_Size", " buf_start", "buf_SIZE", "buf1SIZE", " buf_name"], "filename": ["fil", "json", "bn", "fn", "pkg", "nil", "f", "v", "FN", "length", "path", "file", "files", "prefix", "txt", "username", "uri", "buff", "nm", "nu", "b", "name", "socket", "brace", "buffer", "fp", "vo", "conv", "pen", "lua", "names", "println", "ren", "writer", "nl", "n", "Filename"], "placeholder": ["placeholders", "pleasehold", "placefield", "placeolder", "replacezero", " placeolder", "placesolder", " placeholders", " placezero", "Placezero", "replacehold", "replacefield", "pleaseholder", "Placeholders", "placezero", "placeshold", "pleaseolder", "placesfield", "placesholder", " placehold", "placehold", "pleasefield", "Placeolder", "replaceolder", "Placeholder", "replaceholders", "Placehold", "replaceholder"], "number": [" numer", "NUM", " parameter", "total", " numbering", "no", " document", "umber", "data", "length", "token", " configuration", "file", "language", "error", " num", "note", "integer", "node", "other", "version", "object", " error", " integer", "time", " argument", "size", "result", "Number", "comment", "nr", " numeric", "password", "new", "document", "record", "BER", "unknown", "byte", " length", "num", "count", "x", "null", " Number", "message", "n"], "p": ["vp", "pp", "t", "cp", "pkg", "progress", "f", "a", "lp", "d", "l", "v", "k", "sp", "r", "pipe", "ps", "ctx", "pc", "post", "ping", "pg", "wp", "pm", "pa", "pro", "j", "port", "self", "o", "php", "pt", "br", "power", "span", "i", "ap", "b", "np", "par", "point", "pn", "g", "info", "pb", "per", "pr", "y", "fp", "tp", "perm", "jp", "op", "ar", "pat", "m", "P", "bp", "pi", "part", "pid", "s", "pe", "n", "pos", "u", "pre"], "q": ["gz", "query", "cp", "qual", "ch", "pkg", "qq", "cv", "f", "d", "l", "v", "r", "question", "it", "quant", "Q", "qv", "check", "w", "k", "dq", "ue", "j", "qu", "h", "quer", "iq", "eq", "quote", "i", "b", "sq", "que", "g", "comment", "fp", "ck", "m", "quest", "aq", "ql", "quit", "qa", "uf", "qi", "qt", "queue", "n", "qs", "z", "u"], "buf1": ["buff1", "uf0", "buf0", "uf2", "buf3", "buffer2", " buf2", " buf3", "buff2", "buff0", " buf0", "buf2", "uf1", "buff3", "buffer3", "uf3", "buffer0", "buffer1"], "c": ["tc", "rc", "t", "cu", "cp", "co", "unc", "ch", "com", "f", "l", "v", "r", "lc", "col", "cont", "dc", "C", "con", "cd", "cl", "cc", "cur", "k", "cn", "gc", "cr", "fc", "chain", "b", "comp", "g", "cap", "cmp", "e", "can", "ca", "conv", "ce", "cs", "ct", "ac", "count", "cod", "n", "go", "u", "nc", "cache", "bc"], "nd": ["ng", "max", "td", "ds", "ln", "gov", "d", "ind", " ne", "nn", "nt", " ND", " sd", "fd", "dd", "cd", "ld", "dk", " st", "st", " dd", "ne", "dl", "wo", "rid", "dn", "sd", "ND", "ns", "wn", "np", "gd", "gn", "ond", "std", "mn", "md", "und", "vd", "wind", "mid", "rn", "sn", "end", "pd", "rd", "nl", "n", "nb", "nc"], "len": ["li", "lim", "compl", "elt", "qual", "fn", "el", "lp", "ln", "ll", "lf", "Len", "l", "le", "nn", "v", "nt", "length", "vl", "fin", "ml", "sl", "loc", "val", "ld", "en", "lon", "ell", "fl", "dl", "kl", "size", "ret", "mem", "resp", "lin", "lt", "gn", "il", "mil", "sn", "end", "rel", "line", "pl", "num", "L", "ls", "lan", "nl", "n", "hl", "pos", "gl", "nc", "Length"], "addchar_count": ["addchar_history", "addword_cache", "addchar_len", "addcharvalpart", "addcarityCount", "addchar_Count", "addchar_cache", "addcharitychild", "addchar2Count", "addcharitylen", "addChar_count", "addchar32counter", "addChar_counter", "addcharacter_count", "addmethodaxyhistory", "addcar_count", "addcaritylen", "addchar_cont", "addcharvalname", "addmethodaxycount", "addcharacter_c", "addchar_part", "addchar_code", "addcharacter2count", "addchar_info", "addchar_name", "addcharacter_counter", "addcar_len", "addcar_child", "addcharacter_length", "addword_c", "addcharvalcount", "addconst_count", "addchar_size", "addchar2length", "addchar_1", "addchar32c", "addchar_c", "addcaritycount", "addchar_tag", "addchar2count", "addconst_info", "addChar_tag", "addconst_length", "addchar32count", "addcaritychild", "addcharacter2length", "addcar_Count", "addcharaxyname", "addmethod_count", "addcharitycount", "addchar_child", "addcharaxycount", "addChar_Count", "addcharaxypart", "addChar_length", "addcharitycounter", "addcharacter_Count", "addmethod_part", "addcharityc", "addcharacter2Count", "addmethod_history", "addconst_1", "addmethodaxypart", "addmethod_name", "addmethodaxyname", "addword_count", "addword_code", "addcharaxyhistory", "addchar_length", "addcharvalhistory", "addcharityCount", "addchar_counter"], "found_count": ["founditycount", "foundYCount", "Found_Count", "Found_status", " found_stat", "found_num", "foundYval", "Found_count", "found_stat", " found_val", " found_Count", "found_Count", "found_val", "foundnessstatus", "foundYstat", "foundnesscount", "foundYcount", "founditynum", "found_status", "foundityCount", "Found_num", "foundnessCount"]}}
{"project": "qemu", "commit_id": "db7dfd4c7e4450b10048a53ce67bcac6305ad383", "target": 0, "func": "static void cubieboard_init(QEMUMachineInitArgs *args)\n\n{\n\n    CubieBoardState *s = g_new(CubieBoardState, 1);\n\n    Error *err = NULL;\n\n\n\n    s->a10 = AW_A10(object_new(TYPE_AW_A10));\n\n    object_property_set_bool(OBJECT(s->a10), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        error_report(\"Couldn't realize Allwinner A10: %s\\n\",\n\n                error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_ram(&s->sdram, NULL, \"cubieboard.ram\", args->ram_size);\n\n    vmstate_register_ram_global(&s->sdram);\n\n    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,\n\n                                &s->sdram);\n\n\n\n    cubieboard_binfo.ram_size = args->ram_size;\n\n    cubieboard_binfo.kernel_filename = args->kernel_filename;\n\n    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;\n\n    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);\n\n}\n", "idx": 8049, "substitutes": {"args": ["flags", "icks", "css", "ras", "atts", "arg", "roots", "arr", "yes", "arms", "GS", "words", "txt", "amps", "fields", "aws", "comm", "units", "points", "changes", "GV", "js", "md", "ians", "limits", "gs", "ids", "ars", "Args", "ts", "xs", "results", "actions", "vals", "bits", "fs", "values", "orders", "uments", "names", "ams", "ims", "ants", "apps", "parts", "aux", "terms", "settings", "addons", "aps", "qs", "ags", "params", "cmd"], "s": ["states", "t", "S", "p", "ds", "temp", "is", "d", "l", "v", "sp", "ps", "sm", "serv", "sl", "w", "set", "ss", "iss", "self", "h", "j", "comm", "bs", "source", "js", "ns", "i", "hs", "b", "sq", "sh", "ses", "sts", "sg", "rs", "store", "gs", "y", "su", "sa", "ts", "es", "stats", "m", "fs", "sis", "sv", "cs", "ims", "sb", "parts", "ls", "n", "qs", "sys", "se", "sw", "services"], "err": ["eas", "fr", " er", "Er", "order", "gz", "conf", "elt", "eor", "ch", "cer", "conn", "priv", "kr", "arr", "er", "r", "rr", "norm", "error", "msg", "ger", "obj", "txt", "or", "die", "br", "cr", "attr", "rb", "resp", "usr", "exc", "erb", "fee", "buf", "rs", "rn", "e", "erd", "cfg", "res", "coord", "der", "try", "esp", "DERR", "gr", "riot", "aaa", "n", "notice", "oe", "ev", "mr"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void esp_init(target_phys_addr_t espaddr, int it_shift,\n\n              ESPDMAMemoryReadWriteFunc dma_memory_read,\n\n              ESPDMAMemoryReadWriteFunc dma_memory_write,\n\n              void *dma_opaque, qemu_irq irq, qemu_irq *reset,\n\n              qemu_irq *dma_enable)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    SysBusESPState *sysbus;\n\n    ESPState *esp;\n\n\n\n    dev = qdev_create(NULL, \"esp\");\n\n    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);\n\n    esp = &sysbus->esp;\n\n    esp->dma_memory_read = dma_memory_read;\n\n    esp->dma_memory_write = dma_memory_write;\n\n    esp->dma_opaque = dma_opaque;\n\n    sysbus->it_shift = it_shift;\n\n    /* XXX for now until rc4030 has been changed to use DMA enable signal */\n\n    esp->dma_enabled = 1;\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, espaddr);\n\n    *reset = qdev_get_gpio_in(dev, 0);\n\n    *dma_enable = qdev_get_gpio_in(dev, 1);\n\n}\n", "idx": 8071, "substitutes": {"espaddr": ["htmladdr", "ispaddr", "ispid", "htmladr", " espaddress", "espaddress", "evaddress", "htmlconn", "epaddr", "espconn", "evadr", "ispname", " espadr", "espadr", "ispaddress", "epid", "epname", " espconn", "evaddr", "espid", "htmladdress", " espname", "epaddress", "espname", "evconn", " espid"], "it_shift": ["it_offset", "its_drop", "its_offset", "iter_shift", "itposhift", "its_shift", "iter_align", "it_sort", "it_hash", "it_push", "itTimeoffset", "itpopush", "it_drop", "IT_shift", "itpohash", "it_hift", "itTimeshift", "itTimedrop", "IT_offset", "itpoalign", "its_sort", "itTimesort", "iter_hash", "IT_hift", "iter_push", "it_align"], "dma_memory_read": ["dma_memoryistquery", "dma_memory__read", "dma_media_write", "dma_memory_reader", "dma_memory__write", "dma_memoryistwrite", "dma_memoryistreader", "dma_memory__reader", "dma_memoryistread", "dma_media_read", "dma_memory_query", "dma_media_reader", "dma_media_query"], "dma_memory_write": ["dma_mem_write", "dma_mem_writ", "dma_processor_order", "dma_memory_order", "dma_memory_writ", "dma_memory_writer", "dma_processor_write", "dma_processor_writ", "dma_management_post", "dma_management_write", "dma_management_writ", "dma_memory_post", "dma_memory_set", "dma_mem_writer", "dma_processor_put", "dma_management_set", "dma_memory_put", "dma_mem_store", "dma_memory_store"], "dma_opaque": ["dma_okaques", "dma____opiera", "dma____opacement", "dma_ipatile", "dma_opsatile", "dma_operplex", "dma_okacement", "dma_okaque", "dma_opatile", "dma_opsacity", "dma_opsaque", "dma_opsity", "dma_poriera", "dma_opaques", "dma____okaque", "dma_opity", "dma_opiera", "dma_ipiera", "dma____okacement", "dma_preaques", "dma_poraque", "dma_ipaques", "dma_okiera", "dma_opacement", "dma_opacity", "dma____opaque", "dma_ipacity", "dma____opaques", "dma____okaques", "dma_poraques", "dma_operity", "dma_preplex", "dma_ipplex", "dma_preatile", "dma_operatile", "dma_operaques", "dma_opplex", "dma_ipity", "dma_ipacement", "dma_preaque", "dma_ipaque", "dma_operaque", "dma_operacity", "dma_poracement", "dma____okiera"], "irq": ["IRq", "irqu", " irqu", "mirv", " irp", "mirq", "irf", "irqs", "mirqs", "IRqs", " irqs", " irv", "mirQ", "IRQ", " virqu", "irv", "irQ", " drqu", " drp", " virf", " irQ", "irp", " virp", " irf", " drf", " virq", "IRv", " drq"], "reset": ["init", "rep", "et", "hard", "quiet", "delete", "rm", "re", "ping", "enter", "prefix", "check", "destroy", "force", "error", "address", "offset", "set", "setup", "empty", "ret", "ET", "clear", "state", "def", "zero", "ref", "command", "end", "establish", "res", "addr", "rompt", "kill", "mode", "push", "start", "cmd", "seek"], "dma_enable": ["dna_enable", "dma_display", "dna_display", "dma_enabled", "dna_disable", "dma_disable", "dma_activate", "dna_enabled", "dna_activate"], "dev": ["ptr", "os", "p", "den", "de", "disk", "dt", "ds", "conn", "dem", "priv", "d", "v", "att", "data", "nt", "Device", "spec", "hid", "Dev", "ad", "dd", "serv", "obj", "w", "val", "h", "development", "ve", "pad", "device", "adv", "dn", "sd", "js", "driver", "mem", "def", "DEV", "buf", "stick", "DE", "cam", "db", "res", "det", "der", "tr", "raw", "disc", "addr", "hw", "window", "desc", "env", "dis", "des", "sys", "go", "ev", "out", "cmd", "sw"], "s": ["t", "os", "S", "p", "ds", "is", "v", "sp", "r", "ps", "ss", "sat", "bs", "i", "ns", "js", "ssl", "b", "socket", "sts", "rs", "gs", "ts", "es", "stats", "fs", "its", "sv", "cs", "sb", "c", "als", "us", "ls", "n", "ats", "sys", "sol", "qs"], "sysbus": [" sysBUS", " sysbox", "systembus", "ysus", "sysus", " sysspace", "SysBus", " sysblock", "systemus", "systemspace", " sysBus", "Sysbus", "yslock", "ysBus", " sysboard", "sysboard", "sysBus", "ysBUS", "systemlock", "sysBUS", "sysspace", "ysspace", "systemblock", " sysus", "ysbox", "Sysboard", "ysboard", "ysbus", "sysblock", "Sysbox", "ysblock", " syslock", "syslock", "systemBus", "sysbox", "SysBUS"], "esp": ["eas", "vp", "ei", "et", "p", "ess", "asp", "sports", "estate", "html", "elt", "el", "https", "ech", "esc", "v", "sp", "er", "ps", "rss", "eg", "serv", "eds", "ep", "less", "ss", "ell", "sat", "esm", "ez", "eve", "ssh", "bs", "js", "soc", "asm", "resp", "ssl", "eph", "elf", "esi", "alg", "sg", "established", "rev", "es", "jp", "e", "res", "rel", "pse", "eb", "isp", "expr", "env", "ef", "secondary", "cli", "isol", "xp", "sys", "sol", "ev", "eps", "sw"]}}
{"project": "FFmpeg", "commit_id": "aa6aa2ef091818c2669c48051286ce361401f31b", "target": 0, "func": "static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)\n\n{\n\n    WMACodecContext *s = avctx->priv_data;\n\n    float **audio      = (float **) frame->extended_data;\n\n    int len            = frame->nb_samples;\n\n    int window_index   = s->frame_len_bits - s->block_len_bits;\n\n    FFTContext *mdct   = &s->mdct_ctx[window_index];\n\n    int ch;\n\n    const float *win   = s->windows[window_index];\n\n    int window_len     = 1 << s->block_len_bits;\n\n    float n            = 2.0 * 32768.0 / window_len;\n\n\n\n    for (ch = 0; ch < avctx->channels; ch++) {\n\n        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));\n\n        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);\n\n        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],\n\n                                    win, len);\n\n        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);\n\n        mdct->mdct_calc(mdct, s->coefs[ch], s->output);\n\n    }\n\n}\n", "idx": 8085, "substitutes": {"avctx": [" avcontext", "wavctx", "afcontext", "afctl", "wavcontext", "afctx", "avconfig", "wavctl", "avetx", " avctl", "aftx", "aveconfig", " avtx", "ajconn", "avectx", "apconn", "avctl", "wavtx", "apcp", "avcp", " avconn", " avconfig", "AVconfig", "AVcontext", "avconn", "apctx", "ajcontext", "avcontext", "avtx", "apcontext", "ajcp", "avecontext", "AVtx", "AVctx", "ajctx", " avcp"], "frame": ["request", "scene", "hello", "t", "fr", "iframe", "f", "fram", "v", "data", "channel", "image", "file", "frames", "fb", "call", "fw", "version", "show", "time", "next", "profile", "word", "feature", "point", "info", "response", "Frame", "range", "sample", "movie", "face", "framework", "e", "flow", "zone", "sequence", "window", "header", "feat", "video", "block", "message", "ence", "rame", "event"], "s": ["p", "conf", "sl", "self", "ns", "sq", "ses", "gs", "y", "stats", "ims", "ants", "c", "settings", "qs", "n", "z", "eps", "services", "sc", "S", "scripts", "a", "sp", "ps", "ctx", "ins", "vs", "w", "less", "ss", "sf", "h", "i", "js", "b", "http", "sts", "ts", "ops", "fs", "sb", "als", "ats", "sys", "sa", "details", "is", "f", "ports", "aws", "so", "bs", "space", "state", "rs", "acs", "bis", "cs", "ls", "os", "ess", "ds", "ms", "v", "spec", "comm", "hs", "ssl", "es", "service", "sv", "parts", "se", "sw"], "audio": ["mpeg", "hello", "config", "api", "a", "archive", "binary", "volume", "speech", "data", "image", "media", "xml", "opus", "phy", "voice", "about", "audi", "metadata", "Audio", "ogram", "http", "buffer", "text", "sound", "sample", "wav", "basic", "ac", "aux", "music", "video", " Audio", "picture", "array", "input", "av", "ada"], "mdct": ["dmnt", "dmct", "mduct", "cmdpt", " mdCT", "mmct", "cmdcc", "mtnt", "mtCT", "cduct", "mdpt", " mduct", "mtuct", "cdCT", "mmpt", "mmict", "mdict", "mmcc", "dmCT", "mdCT", "cmdict", "cdcc", "dmpt", "cdct", " mdnt", "dmuct", " mdcc", "cmdct", "mdcc", "mdnt", "dmict", "mtct", "dmcc"], "ch": ["cha", "kh", "sch", " cho", "bt", "sk", " th", "chat", "q", "uch", "pt", " y", "Ch", "y", "pl", "c", " sch", "hl", "z", " count", "ph", "cp", " err", "el", "ach", "w", "chron", "anch", "h", "j", "CH", "i", "ht", "arch", "chn", " col", "ek", "chan", " c", "x", "atch", " chip", "th", "kr", "tch", "zh", "cl", "unk", "br", "qu", "chain", "sh", " chunk", "cht", " k", "go", "wh", "bat", "chu", "ech", " Ch", "cho", "ble", "v", "col", "channel", "och", "quant", " channel", "chip", "cell", "hr", "chrom", "ich", " sc", "gl", "batch"], "win": ["lim", "fn", "conn", "ll", "ln", "id", "wx", "nt", "draw", "wal", "won", "wp", "w", "en", "png", "wt", "in", "size", "ns", "wn", "gen", "gn", "Win", "mn", "len", "wid", "wl", "windows", "end", "nw", "local", "pen", "reg", "snap", "window", "num", "on", "bin", "n", "pos", "man", "out", "cmd"]}}
{"project": "FFmpeg", "commit_id": "3932ccc472ad4f4d370dcfc1c2f574b0f3acb88c", "target": 1, "func": "static void diff_pixels_altivec(int16_t *restrict block, const uint8_t *s1,\n\n                                const uint8_t *s2, int stride)\n\n{\n\n    int i;\n\n    vec_u8 perm1 = vec_lvsl(0, s1);\n\n    vec_u8 perm2 = vec_lvsl(0, s2);\n\n    const vec_u8 zero = (const vec_u8)vec_splat_u8(0);\n\n    vec_s16 shorts1, shorts2;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        /* Read potentially unaligned pixels.\n\n         * We're reading 16 pixels, and actually only want 8,\n\n         * but we simply ignore the extras. */\n\n        vec_u8 pixl  = vec_ld(0,  s1);\n\n        vec_u8 pixr  = vec_ld(15, s1);\n\n        vec_u8 bytes = vec_perm(pixl, pixr, perm1);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts1 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the same for the second block of pixels.\n\n        pixl  = vec_ld(0,  s2);\n\n        pixr  = vec_ld(15, s2);\n\n        bytes = vec_perm(pixl, pixr, perm2);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts2 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the subtraction.\n\n        shorts1 = vec_sub(shorts1, shorts2);\n\n\n\n        // Save the data to the block, we assume the block is 16-byte aligned.\n\n        vec_st(shorts1, 0, (vec_s16 *)block);\n\n\n\n        s1    += stride;\n\n        s2    += stride;\n\n        block += 8;\n\n\n\n        /* The code below is a copy of the code above...\n\n         * This is a manual unroll. */\n\n\n\n        /* Read potentially unaligned pixels.\n\n         * We're reading 16 pixels, and actually only want 8,\n\n         * but we simply ignore the extras. */\n\n        pixl  = vec_ld(0,  s1);\n\n        pixr  = vec_ld(15, s1);\n\n        bytes = vec_perm(pixl, pixr, perm1);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts1 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the same for the second block of pixels.\n\n        pixl  = vec_ld(0,  s2);\n\n        pixr  = vec_ld(15, s2);\n\n        bytes = vec_perm(pixl, pixr, perm2);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts2 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the subtraction.\n\n        shorts1 = vec_sub(shorts1, shorts2);\n\n\n\n        // Save the data to the block, we assume the block is 16-byte aligned.\n\n        vec_st(shorts1, 0, (vec_s16 *)block);\n\n\n\n        s1    += stride;\n\n        s2    += stride;\n\n        block += 8;\n\n    }\n\n}\n", "idx": 8103, "substitutes": {"block": ["pack", "limit", "sp", "length", "board", "Block", "label", "list", "hash", "file", "image", "field", "scope", "sync", "check", "parent", "blocking", "position", "error", "offset", "prefix", "set", "version", "axis", "lock", "device", "none", "empty", "size", "chain", "space", "group", "word", "link", "stop", "index", "blocks", "bl", "type", "range", "zero", "buffer", "row", "rest", "instance", "line", "table", "loop", "base", "repeat", "part", "window", "header", "mask", "number", "byte", "start", "box", "load", "frame", "out", "batch"], "s1": ["s03", "Sone", "js01", " s01", "pass1", "js1", "osone", "ts1", "qs2", " sName", "sts2", "pass5", "stsIP", "stsFirst", "s01", "s5", "ns1", "ns5", "ts3", "qs01", "ins2", "ts2", "nsName", "jsFirst", " s03", "qs1", "ins03", "c01", "S1", "js2", "cone", "qsone", "S01", "S0", " s3", "os1", "os2", "ns2", "js03", "s0", "ins01", "sIP", "jsIP", "S2", "sName", "S3", "ts01", "os01", " sone", "sone", "c1", "s3", "sts1", " s0", "SIP", " s5", "sFirst", "SFirst", "ins1", "stsName", "pass2", "c2"], "s2": ["s4", "qs2", " s_", "S120", "rs6", "s02", "gs2", "S1", "S4", "a6", "qs0002", "os2", "is2", "s_", "os3", " s0", " scont", "os120", "iscont", " sblock", "atwo", "stwo", "its2", " stwo", "t2", "S0", "rstwo", " sBlock", "t1", "its62", "t02", "mcont", "scont", "a2", "s0002", "e3", "mBlock", "qs3", "Stwo", "gs62", "sSecond", " s120", "osSplit", "isBlock", "itsSecond", "mblock", "isSecond", " s6", "m_", "s0", "e0", "gsSecond", "a1", "is_", " s0002", "sBlock", "s6", "e2", " sSplit", "qsSplit", "s120", "rs1", "S02", " s4", "os0002", "sSplit", " s3", "rs2", "os1", " s02", "S2", "S3", "ttwo", "s62", "sblock", "s3", "isblock", "e1", "is62"], "stride": ["strend", "stides", " strIDE", "stIDE", "stringend", "STRIDE", "strime", "tride", "slider", " strime", "STRide", "slide", "slride", "STRride", "STRides", "divope", "divime", "strides", "STRider", " strider", "strope", "trider", " strope", "stringride", "trend", "strride", "trride", "divride", "stringide", "stringope", "stide", "slime", " strides", "strider", " strride", "stringider", "strIDE", "divide", "divider", "STRend"], "i": [" m", " I", "init", "li", " err", " multi", "p", " iter", "sim", "inter", "bi", "progress", "is", "id", "ind", "ii", "ini", "abi", "mi", " pos", " bi", " pi", "it", "ix", "me", "ic", "q", " x", "counter", " e", "set", "si", "j", "di", "o", "lock", "in", "iq", "ip", " s", "ex", "index", "mac", "g", " v", "multi", "ui", "xi", "y", "status", "print", " ti", "ci", "ti", "m", "ai", "pi", " index", " j", "im", "x", "I", " k", "qi", "by", " t", "out", " ii", "batch", " self"], "shorts1": ["sheorts001", "shorts91", "thops1", " shorts9", "thops3", "shifts91", "shitches1", "shops91", "shorter3", "supportsL", "shartsOne", "shatsOne", "Shouts1", "shorts9", "shroups1", "shrots1", " shorts001", "ShoutsOne", " short01", "shorts1001", "short1", "ShortsOne", "whributes1", "shrots01", "shouts001", "shints3", "sharts1", "shributes001", "thopsone", "shrets2", "ushorts1001", " shops91", "thortsone", "shroups001", "shopsOne", "shrots2", "shortersOne", "shortL", "suppitches2", "whorts1", "shuls3", "shouts3", "sharts001", "ushorts1", "shorters001", "shortsOne", "shopsone", "Shorts2", "shifts5", "shors1", "shortsone", "sheorts3", "sherets1", "shorterone", "whributes3", "shorters1", "ushorts001", "whorts3", "shorts01", "shrets3", "supports001", "ushartsOne", "shops2", "shouts01", "shops3", "shouts9", " shorts5", "short01", "short2", "short9", " shops1", "sheorts2", " shorts91", " shops2", "shintsOne", "shops5", "Shorts1", "supports2", "shints1", "Shouts2", "shorts3", "sherets2", "shorsL", "shors001", "shrots9", " shouts2", " short001", "shroups01", "shuls1", "thorts3", "shorter1", "sharts1001", "thortsOne", "shorter001", " shouts01", "suppitches1", "suppitches001", "shitches001", "shats2", "short91", "shifts2", "Shouts3", "shorters3", "sheorts1", "shintsone", "shitches2", "shitchesL", "shrots3", "shoutsOne", "shops1", "shrots001", "thorts1", "supports1", "short5", "shorters2", "shats3", "shouts2", "suppitchesL", "shorter01", "shouts1", "usharts1", "shats1", "shrets1", " short1", " shorts01", "thopsOne", "shorters1001", "shifts1", "shortsL", "shrets001", "shorts5", " shops5", "whorts001", "shorterOne", "ushortsOne", "whributes001", "sherets3", "shorts001", "shuls001", "sherets001", " shouts9", "short001", "shors2", "shributes3", " shouts1", "usharts1001", "Shorts3", "usharts001", "shributes1"], "shorts2": [" shorter1", " shorts4", "shiffs2", "shouts6", " shorts02", "shorts6", "shports2", "shorts256", "shonds256", "shapes12", " shorter4", "shresses256", "shrots1", " shapes12", "shbits42", "thortersTwo", "shouts12", "ashorts2", "ashortstwo", "ashonds2", "shorts12", "shrots2", "shorters0", "shportstwo", "shorts4", "shiffs42", "shorter6", " shorts42", "shressestwo", "shports256", " shorters2", "shops4", " shorters42", " shorts12", " shorts6", "shresses1", "shorters1", "thortsTwo", "shports12", "thorters2", "shops2", "thorters1", "shorter4", "shorts0", " shapes1", "shorts42", "shortstwo", "shapes2", "shouts4", "thorts0", "shonds2", "shops6", "shorter1", "shats2", "shats0", "ashondstwo", "shrotsTwo", "ashorts12", "ashonds256", "shresses12", "shops1", "shrots0", "thorts1", "shorters02", "shorters2", "thorts2", "shouts2", "shbits2", "shatsTwo", "shortsTwo", "shouts1", "ashonds12", "shorts02", "shats1", "shresses2", " shorter2", "shapes1", "shorter2", "thorters0", "ashorts256", " shorters02", "shonds12", " shapes2", "shondstwo", "shiffs02", "shbits02", " shorter6", "shortersTwo", "shorters42"]}}
{"project": "FFmpeg", "commit_id": "199d4478de102ca7987adb97f2e66a1820a98ebd", "target": 1, "func": "int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f)\n\n{\n\n    PerThreadContext *p = avctx->thread_opaque;\n\n    int *progress, err;\n\n\n\n    f->owner = avctx;\n\n\n\n    ff_init_buffer_info(avctx, f);\n\n\n\n    if (!(avctx->active_thread_type&FF_THREAD_FRAME)) {\n\n        f->thread_opaque = NULL;\n\n        return avctx->get_buffer(avctx, f);\n\n    }\n\n\n\n    if (p->state != STATE_SETTING_UP &&\n\n        (avctx->codec->update_thread_context || (!avctx->thread_safe_callbacks &&\n\n                avctx->get_buffer != avcodec_default_get_buffer))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() cannot be called after ff_thread_finish_setup()\\n\");\n\n        return -1;\n\n    }\n\n\n\n    pthread_mutex_lock(&p->parent->buffer_mutex);\n\n    f->thread_opaque = progress = allocate_progress(p);\n\n\n\n    if (!progress) {\n\n        pthread_mutex_unlock(&p->parent->buffer_mutex);\n\n        return -1;\n\n    }\n\n\n\n    progress[0] =\n\n    progress[1] = -1;\n\n\n\n    if (avctx->thread_safe_callbacks ||\n\n        avctx->get_buffer == avcodec_default_get_buffer) {\n\n        err = avctx->get_buffer(avctx, f);\n\n    } else {\n\n        p->requested_frame = f;\n\n        p->state = STATE_GET_BUFFER;\n\n        pthread_mutex_lock(&p->progress_mutex);\n\n        pthread_cond_signal(&p->progress_cond);\n\n\n\n        while (p->state != STATE_SETTING_UP)\n\n            pthread_cond_wait(&p->progress_cond, &p->progress_mutex);\n\n\n\n        err = p->result;\n\n\n\n        pthread_mutex_unlock(&p->progress_mutex);\n\n\n\n        if (!avctx->codec->update_thread_context)\n\n            ff_thread_finish_setup(avctx);\n\n    }\n\n\n\n    pthread_mutex_unlock(&p->parent->buffer_mutex);\n\n\n\n    return err;\n\n}\n", "idx": 8105, "substitutes": {"avctx": [" avcontext", "avclient", "wavctx", "ajpkg", "averconn", "abctx", "avcmd", " avaddr", "avaddr", "afcp", " avcmd", "wavconn", "avectx", "wavtx", "averkt", "versys", "avwcs", "navcomp", "ajwcs", "awctx", "averpt", "averctl", "wavcmd", "avetc", "avecu", "avercu", "avertmp", "iverctx", " avsys", "avtimeout", "averca", "abcontext", "avemsg", "ivercu", "awcu", "avcu", "wavcontext", "afctx", "navctx", "wavcp", "avconfig", "avsys", "averwcs", "aveaddr", "avervoc", "abtx", "avnp", "avetx", "averhistory", "wavconfig", " avctl", "wavclient", "aveconfig", " avjac", "avejp", " avtx", "avecmp", "avercmp", "avevoc", "avctl", "aveclient", "iverca", "averjac", "avcp", "avertc", "avetmp", "wavcmp", "ajtmp", "avpkg", "navcu", "avercontext", "avcontext", "avetimeout", "avtc", "avhost", "averctx", "avtmp", "aveca", "avekt", "iverheight", "ajctx", "avercmd", " avjp", " avhistory", "avheight", "ivertimeout", "averhost", "avkt", "avept", " avca", "navnp", "avesys", "avmsg", "avercfg", "avenp", "avjac", "avcfg", "avercomp", "abctl", "wavpt", "avecp", "evcp", "ajkt", "evkt", "evgp", "avjp", "navjp", "avehost", "avecomp", "awconn", "verconn", "avegp", "avca", "avhistory", "averjp", "avecfg", "avconn", "averconfig", " avcu", "avecontext", "avermsg", "verjp", "afwcs", " avcp", "avertimeout", "avepkg", "afcmp", "avpt", "wavnp", "avertx", "evctx", "avergp", "aveheight", "ajaddr", "avgp", "averclient", "navtc", " avpkg", "wavsys", "wavcu", "avcmp", "aversys", "aveconn", "avejac", "avercp", "avvoc", "wavwcs", "wavcfg", "avcomp", "avewcs", " avcfg", "ivermsg", "ivervoc", "averheight", "avtx", "verctx", "ajcp", "awhost", "navconn", "avehistory"], "f": ["df", "fr", "t", "conf", "fn", "fi", "tf", "form", "lf", "foreign", "far", "d", "v", "fm", "fac", "r", "fb", "fd", "file", "field", "ft", "fw", "w", "ff", "sf", "j", "h", "fl", "o", "xf", "fer", "fc", "i", "fa", "b", "F", "elf", "g", "fff", "rf", "fe", "fp", "cf", "e", "fo", "fs", "uf", "c", "ef", "bf", "feat", "z", "frame", "fx"], "p": ["pp", "pkg", "l", "pc", "q", "wp", "pro", "pt", "ap", "current", "y", "fp", "bp", "pl", "c", "n", "er", "pre", "cp", "sp", "r", "ps", "ctx", "post", "j", "h", "power", "i", "proc", "b", "at", "pb", "admin", "op", "pi", "part", "patch", "primary", "lp", "debug", "d", "policy", "mp", "pa", "np", "command", "process", "perm", "e", "m", "pid", "pe", "local", "vp", "t", "rep", "tmp", "v", "ping", "parent", "pm", "resp", "g", "per", "pers", "tp", "jp", "P", "parse", "cache"], "progress": ["ptr", "dr", "order", "rep", "max", "pkg", "details", "success", "percent", "debug", "properties", "dist", "poll", "dim", "arr", "r", "data", "done", "wait", "pc", "bar", "grade", "pro", "req", "depth", "good", "complete", "comm", "recent", "Progress", "history", "sofar", "mem", "proc", "resp", "result", "par", "step", "term", "roll", "pr", "range", " Progress", "tip", "rest", "status", "iter", "rank", "res", "gp", "coord", "tr", "scale", "summary", "priority", "desc", "distance", "count", "gr", "skip", "xp", "reg"], "err": ["ptr", "fr", "gz", "rc", "dr", "elt", "conf", "eor", "warn", "inner", "l", "kr", "arr", "r", "lr", "race", "rr", "norm", "oe", "error", "msg", "txt", "obj", "cb", "str", "errors", "or", "die", "br", "cr", "attr", "ERROR", "asm", "off", "result", "exc", "resp", "usr", "state", "fee", "buf", "pr", "ner", "ir", "fp", "iter", "code", "res", "try", "raw", "count", "c", "Error", "n", "er", "ev", "timer", "mr"]}}
{"project": "qemu", "commit_id": "80fb34eda099e7cc519a91e9701ab3c0262717b3", "target": 1, "func": "bool qio_task_propagate_error(QIOTask *task,\n\n                              Error **errp)\n\n{\n\n    if (task->err) {\n\n        error_propagate(errp, task->err);\n\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}", "idx": 8111, "substitutes": {"task": ["tc", "commit", "t", "master", "activity", "journal", "dev", "cast", "form", "work", "func", "nt", "worker", "future", "thread", "component", "bolt", "sync", "piece", "call", "ask", "check", "transform", "trigger", "setup", "req", "release", "complete", "chain", "link", "problem", "Task", "maybe", "command", "process", "unknown", "raw", "exec", "grid", "job", "project", "missing", "test", "table", "that", "run", "rake", "associated", "tx", "think", "block", "start", "load", "asks", "cmd"], "errp": ["errorpo", "diebp", "errpo", "errorpb", "iterpa", "ererbp", "errpa", "diepb", "errorbp", "errbp", "ererpa", "iterbp", "ererpb", " errpa", "errpb", "errorp", "diep", "diepo", "iterp", " errbp", "ererpo", "ererp"]}}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static void hds_free(AVFormatContext *s)\n\n{\n\n    HDSContext *c = s->priv_data;\n\n    int i, j;\n\n    if (!c->streams)\n\n        return;\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        OutputStream *os = &c->streams[i];\n\n        if (os->out)\n\n            avio_close(os->out);\n\n        os->out = NULL;\n\n        if (os->ctx && os->ctx_inited)\n\n            av_write_trailer(os->ctx);\n\n        if (os->ctx && os->ctx->pb)\n\n            av_free(os->ctx->pb);\n\n        if (os->ctx)\n\n            avformat_free_context(os->ctx);\n\n        av_free(os->metadata);\n\n        for (j = 0; j < os->nb_extra_packets; j++)\n\n            av_free(os->extra_packets[j]);\n\n        for (j = 0; j < os->nb_fragments; j++)\n\n            av_free(os->fragments[j]);\n\n        av_free(os->fragments);\n\n    }\n\n    av_freep(&c->streams);\n\n}\n", "idx": 8112, "substitutes": {"s": ["t", "S", "p", "ds", "is", "a", "f", "ms", "d", "v", "ps", "ins", "eds", "w", "less", "ss", "h", "aws", "bs", "ns", "js", "hs", "b", "ses", "sts", "rs", "gs", "ts", "stats", "has", "m", "fs", "its", "cs", "as", "parts", "ls", "ats", "qs"], "c": ["mc", "tc", "t", "cm", "cu", "co", "cp", "conf", "p", "com", "cv", "f", "d", "l", "v", "ec", "lc", "ctx", "r", "cont", "dc", "C", "con", "coll", "cd", "cb", "w", "cc", "o", "cn", "gc", "comm", "b", "g", "enc", "cf", "cam", "e", "m", "xc", "conv", "comments", "ce", "cs", "ct", "ac", "wcs", "n", "nc", "cache", "bc"], "i": ["ei", "li", "ori", "sim", "ki", "fi", "bi", "is", "l", "ii", " ni", "ini", "ind", "ms", "mi", "ix", " bi", "me", "it", "ic", "my", "si", "oi", "di", "gi", "o", "ri", "in", "id", "ie", "ip", "ex", "chain", " li", "index", "ui", "multi", "iu", "xi", "y", "ij", "zi", "iter", "print", "ci", "ti", " ki", "ami", "ai", "pi", "im", "ims", " mi", "x", "I", "phi", "qi", "n", " ii", "batch"], "j": ["bo", "json", "key", "ng", "dj", "p", "el", "bj", "jj", "v", "l", "ind", "att", "jl", "ix", "it", "kid", "q", "msg", "jc", "obj", "str", "aj", "ax", "k", "jo", "di", "br", "o", "pt", "ji", "js", "jump", "ie", "b", "ju", "oj", "adj", "g", "pr", "axy", "ij", "kj", "y", "jp", "uj", "m", "jas", "try", "tr", "job", "ja", "jit", "x", "je", "J", "jack", "pos", "z", "er", "ev"], "os": ["et", "ori", "nos", "vers", "ones", "ks", "ox", "ns", "windows", "oids", "boot", "oes", "ims", "ants", "mot", "des", "OS", "oa", "eps", "dos", "uts", "css", "oS", "mes", "ps", "vs", "obj", "rots", "ose", "or", "tes", "js", "ows", "oos", "ts", "op", "ops", "bits", "fs", "us", "sys", "osa", "oses", "ions", "bos", "ans", "ors", "is", "ow", "aos", "ost", "ros", "ok", "io", "bs", "otes", "ls", "out", "oss", "ds", "Os", "ols", "mos", "o", "bytes", "ui", "los", "oops", "ot", "es", "obs", "osi", "oid", "pos", "yes"]}}
{"project": "FFmpeg", "commit_id": "ab80d3fb3a7595db44fc143c80f8c2a3480fe28d", "target": 1, "func": "yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],\n\n            const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n            const int16_t *abuf[2], uint8_t *dest, int dstW,\n\n            int yalpha, int uvalpha, int y)\n\n{\n\n    int hasAlpha = abuf[0] && abuf[1];\n\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *abuf0 = hasAlpha ? abuf[0] : NULL,\n\n                  *abuf1 = hasAlpha ? abuf[1] : NULL;\n\n    int  yalpha1 = 4096 - yalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < dstW; i++) {\n\n        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;\n\n        int A;\n\n\n\n        Y = av_clip_uint8(Y);\n\n\n\n        if (hasAlpha) {\n\n            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;\n\n            A = av_clip_uint8(A);\n\n        }\n\n\n\n        dest[i * 2    ] = Y;\n\n        dest[i * 2 + 1] = hasAlpha ? A : 255;\n\n    }\n\n}\n", "idx": 8124, "substitutes": {"buf0": ["buff1", "uf0", "uf2", "bag1", "uf12", "buffer2", "bag2", "bag12", "buffer12", "buff2", "buff0", "buf2", "uf1", "buffer0", "buf12", "bag0", "buffer1"], "buf1": ["buff1", "uf0", "uf2", "buffern", "buf3", "buffer2", " buf2", "ufn", "buff2", "buff0", "buf2", "uf1", "buff3", " bufn", "buffer3", "uf3", "buffer0", "bufn", "buffer1"], "abuf0": ["labbuf0", "abbuf0", "abuc1", "abuc3", "abuff2", "abff0", "abuff3", "labbuf1", "abbuf3", "abuc2", "abuf3", "labuff0", "abuc0", "labuf2", "labbuf3", "abuff0", "abuf2", "labbuf2", "abff2", "abbuf2", "labuf0", "abff3", "abuff1", "labuff1", "abff1", "abbuf1", "labuf1", "labuf3", "labuff3", "labuff2"], "abuf1": ["abbuf0", "abbuff1", "obbuf2", "abuff2", "acbuf3", "abff0", "acbuf0", "acbuf2", "abbf1", "acbuf1", "abbuf3", "obbuf4", "abuf4", "acuf2", "obuf1", "abuf3", "abuff4", "acuf1", "obuf4", "obbuf1", "abuff0", "abuf2", "abbuf4", "acuf3", "abbf2", "acuf0", "abff2", "abbuf2", "abbf3", "abff3", "abuff1", "abbuff2", "abbuff4", "obuf2", "abbuff0", "abff1", "abbuf1", "abbf0", "obuf0", "obbuf0"], "i": ["key", "init", "t", "li", "ei", "p", "sim", "ki", "fi", "bi", "is", "id", "l", "ii", "v", "ini", "ind", "sp", "mi", "ix", "me", "it", "ic", "q", "\u0438", "si", "j", "di", "o", "gi", "span", "ri", "in", "chain", "ip", "ji", "index", "name", "info", "point", "g", "slice", "ui", "multi", "iu", "xi", "y", "ij", "zi", "Index", "status", "e", "ci", "ti", "m", "this", "ami", "ai", "pi", "im", "ims", "x", "I", "qi", "cli", "n", "Ti", "go", "batch"], "A": ["Ar", "BA", "AR", "S", "AU", "K", "IA", "a", "At", "AE", "AN", "API", "C", "AI", "Alpha", "BY", "PA", "GA", "CA", "Area", "SA", "AS", "D", "AB", "B", "Array", "As", "AV", "F", "Y", "W", "AF", "An", "M", "G", "AM", "AH", "EA", "HA", "What", "AC", "LA", "JA", "P", "ACC", "AA", "L", "AL", "AAA", "I", "ACT", "AP", "TA", "ATA", "AT", "V", "U"]}}
{"project": "qemu", "commit_id": "f7b879e072ae6839b1b1d1312f48fa7f256397e2", "target": 1, "func": "static void device_unparent(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    BusState *bus;\n\n\n\n    if (dev->realized) {\n\n        object_property_set_bool(obj, false, \"realized\", NULL);\n\n    }\n\n    while (dev->num_child_bus) {\n\n        bus = QLIST_FIRST(&dev->child_bus);\n\n        object_unparent(OBJECT(bus));\n\n    }\n\n    if (dev->parent_bus) {\n\n        bus_remove_child(dev->parent_bus, dev);\n\n        object_unref(OBJECT(dev->parent_bus));\n\n        dev->parent_bus = NULL;\n\n    }\n\n\n\n    /* Only send event if the device had been completely realized */\n\n    if (dev->pending_deleted_event) {\n\n        g_assert(dev->canonical_path);\n\n\n\n        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,\n\n                                       &error_abort);\n\n        g_free(dev->canonical_path);\n\n        dev->canonical_path = NULL;\n\n    }\n\n}\n", "idx": 8130, "substitutes": {"obj": ["bo", "t", "os", "pkg", "tmp", "bj", "bh", "conn", "mk", "id", "org", "nt", "ctx", "cont", "serv", "txt", "cb", "str", "object", "j", "o", "comm", "attr", "bs", "js", "resp", "buf", "act", "stick", "onet", "ref", "ot", "cmp", "xy", "obs", "ck", "addr", "hw", "Obj", "ob", "obo", "tk", "oid", "rt", "pos", "sys", "go", "objects", "cmd"], "dev": ["conf", "conn", "nt", "scan", "watch", "pro", "rem", "jump", "wd", "DEV", "ver", "prov", "develop", "fo", " def", "unknown", "det", "oy", "des", "cmd", "roller", "dj", "de", "draw", "data", "normal", "app", "inv", "serv", "w", " Dev", "ve", "build", "device", "eng", "adv", "sd", "mem", "def", "err", "comment", "stick", "serial", "enc", "attach", "patch", "vol", "ack", "den", "priv", "debug", "d", " device", "van", "att", "ow", "Device", "Dev", "gu", "die", "off", "cam", "end", "exec", "var", "del", "go", "ev", "dem", "dr", "fail", "doc", "warn", "cast", "cho", "v", "spec", "stable", "prof", "val", "prop", "req", "info", "buf", " devs", "res", "tr", "addr", "test", "hw", "desc", "tech", "kick", "av"], "bus": ["os", "util", "host", "vc", "join", "way", "cat", "bur", "board", " BUS", "bolt", "bug", "sync", "bar", "loc", "Bus", "mount", "hold", "port", "gate", "lock", "buff", "bs", "chain", "driver", "bal", "buf", "stick", "zip", "store", "buffer", "pool", "ck", "boot", "used", "loop", "bridge", "base", "us", "tx", "queue", "back", "block", "box", "pos", "ack", "BUS", "cache", "bc", "hand"]}}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "QBool *qbool_from_bool(bool value)\n\n{\n\n    QBool *qb;\n\n\n\n    qb = g_malloc(sizeof(*qb));\n\n    qb->value = value;\n\n    QOBJECT_INIT(qb, &qbool_type);\n\n\n\n    return qb;\n\n}\n", "idx": 8134, "substitutes": {"value": ["function", "key", "hello", "p", "active", "python", "v", "database", "data", "label", "image", "field", "position", "parent", "w", "node", "val", "version", "ue", "object", "power", "always", "attribute", "output", "vector", "source", "b", "state", "result", "name", "index", " Value", "feature", "current", "property", "type", "status", "variable", "instance", "unknown", "bit", "unit", "values", "operator", "initial", "Value", "VALUE", "sequence", "expression", "update", "total", "input", "widget"], "qb": ["qba", " qbe", "qqbb", "aqbb", " qbi", "qurb", "qubi", " qsb", "iqa", "qbo", "dqb", "queb", "sqcb", "sqbo", "qeb", "qusb", "oxb", " qbb", "sqrb", "iqbb", "sqb", "quba", "dqeb", "dqbe", " qbo", "qbb", "oxeb", "qrb", "oxbe", "aqa", "qbi", "qcb", "qubo", "aqrb", "qub", "qucb", "oxbb", " qa", "iqrb", "aqb", "dqbb", " qba", "qbe", "qqbi", "qa", "qsb", "sqbb", "qube", "aqbe", "qqb", "qubb", "qqsb", " qcb", "iqb", " qrb", "sqba"]}}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_rt_frame(int usig, struct emulated_sigaction *ka, \n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUState *env)\n\n{\n\n\tstruct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));\n\n\tint err = 0;\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))\n\n            return 1;\n\n#endif\n\n\t__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);\n\n\t__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);\n\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n\t/* Clear all the bits of the ucontext we don't use.  */\n\n\terr |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));\n\n\n\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, /*&frame->fpstate,*/\n\n\t\t\t\tenv, set->sig[0]);\n\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\n\n\tif (err == 0)\n\n\t\terr = setup_return(env, ka, &frame->retcode, frame, usig);\n\n\n\n\tif (err == 0) {\n\n\t\t/*\n\n\t\t * For realtime signals we must also set the second and third\n\n\t\t * arguments for the signal handler.\n\n\t\t *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06\n\n\t\t */\n\n            env->regs[1] = (target_ulong)frame->pinfo;\n\n            env->regs[2] = (target_ulong)frame->puc;\n\n\t}\n\n\n\n        //\treturn err;\n\n}\n", "idx": 8145, "substitutes": {"usig": ["useseg", "usag", "usigma", "usesigma", "usiss", "ruseg", " usag", "usesigs", " usigs", "cusigs", "cusag", "usesag", "usesiss", "useg", " usigma", " useg", "usesig", "rusiss", "cusigma", "cusig", "usigs", "rusig", " usiss", "rusigs"], "ka": ["ski", "ke", "ki", "sk", "kk", "arma", "kr", "ctx", "ha", "ks", "aka", "ku", "k", "kt", "ica", "km", "kl", "ket", "ma", "ck", "ker", "te", "eta", "ko", "ca", "ami", "ema", "ja", "gha", "Ka", "KA", "qa", "ta", "ak", "tk", "kas", "kat", "sa"], "info": ["tif", "py", "json", "init", "rc", "doc", "conf", "inter", " fi", "ki", "fi", "f", "priv", "is", "id", "ii", "data", "mi", "ctx", "check", "prof", "txt", "hi", "loc", "si", "ist", "iso", "recent", "about", "i", "history", "ip", "mem", "dict", "metadata", "def", "name", "http", " inf", "ui", "information", "text", "now", "iter", "fo", "ci", "ti", "stat", "INFO", "afi", "auth", "aux", "meta", "rt", "ro", "user", "local", "inf", "Info"], "set": ["get", "sc", "init", "t", "util", "et", "p", "reset", "pack", "mark", "ch", "use", "data", "spec", "ctx", "to", "ut", "list", "error", "msg", "check", "call", "con", "map", "equal", "setup", "en", "st", "se", "setting", "size", "eq", "Set", "sett", "site", "result", "clear", "ex", "section", "state", "sh", "act", "step", "store", "end", "SET", "un", "m", "ce", "test", "session", "sche", "c", "push", "block", "start", "context", "add", "out"], "env": ["ptr", "init", "sc", "vp", "ote", "et", "ei", "gear", "dev", "den", "environment", "cv", "conn", "priv", "esc", "v", "org", "ec", "vs", "ctx", "worker", "enter", "msg", "stack", "ev", "obj", "cb", "server", "ew", "en", "self", "nv", "here", "esm", "eng", "mem", "proc", "ten", "buf", "neck", "ner", "store", "buffer", "enc", "e", "end", "erd", "te", "db", "exec", "addr", "ov", "hw", "window", "Environment", "message", "context", "er", "vt", "viron", "err", "cmd", "sw"], "frame": ["commit", "fr", "join", "frames", "file", "error", "condition", "call", "one", "reason", "none", "term", "response", "row", "remote", "iter", "za", "AME", "user", "queue", "cause", "message", "tick", "ence", "rame", "cmd", "event", "ace", "wall", "draw", "data", "ctx", "rule", "profile", "word", "dict", "def", "zero", "ref", "new", "code", "flow", "ce", "session", "header", "shot", "feat", "block", "context", "load", "request", "reset", "f", "iframe", "thread", "component", "image", "fb", "version", "lock", "chain", "state", "feature", "point", "type", "fe", "command", "process", "e", " Frame", "framework", "sequence", "function", "init", "scene", "doc", "cast", "fi", "processor", "ze", "me", "channel", "force", "node", "style", "req", "object", "module", "time", "role", "trace", "step", "Frame", "cf", "face", "line", "base", "zone", "window", "next", "err"]}}
{"project": "qemu", "commit_id": "25e6a11832bcd0715068f0cc24fb46ec03de676e", "target": 1, "func": "static void spapr_phb_placement(sPAPRMachineState *spapr, uint32_t index,\n\n                                uint64_t *buid, hwaddr *pio,\n\n                                hwaddr *mmio32, hwaddr *mmio64,\n\n                                unsigned n_dma, uint32_t *liobns, Error **errp)\n\n{\n\n    /*\n\n     * New-style PHB window placement.\n\n     *\n\n     * Goals: Gives large (1TiB), naturally aligned 64-bit MMIO window\n\n     * for each PHB, in addition to 2GiB 32-bit MMIO and 64kiB PIO\n\n     * windows.\n\n     *\n\n     * Some guest kernels can't work with MMIO windows above 1<<46\n\n     * (64TiB), so we place up to 31 PHBs in the area 32TiB..64TiB\n\n     *\n\n     * 32TiB..(33TiB+1984kiB) contains the 64kiB PIO windows for each\n\n     * PHB stacked together.  (32TiB+2GiB)..(32TiB+64GiB) contains the\n\n     * 2GiB 32-bit MMIO windows for each PHB.  Then 33..64TiB has the\n\n     * 1TiB 64-bit MMIO windows for each PHB.\n\n     */\n\n    const uint64_t base_buid = 0x800000020000000ULL;\n\n    const int max_phbs =\n\n        (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;\n\n    int i;\n\n\n\n    /* Sanity check natural alignments */\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_BASE % SPAPR_PCI_MEM64_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_LIMIT % SPAPR_PCI_MEM64_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM64_WIN_SIZE % SPAPR_PCI_MEM32_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM32_WIN_SIZE % SPAPR_PCI_IO_WIN_SIZE) != 0);\n\n    /* Sanity check bounds */\n\n    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_IO_WIN_SIZE) > SPAPR_PCI_MEM32_WIN_SIZE);\n\n    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_MEM32_WIN_SIZE) > SPAPR_PCI_MEM64_WIN_SIZE);\n\n\n\n    if (index >= max_phbs) {\n\n        error_setg(errp, \"\\\"index\\\" for PAPR PHB is too large (max %u)\",\n\n                   max_phbs - 1);\n\n        return;\n\n    }\n\n\n\n    *buid = base_buid + index;\n\n    for (i = 0; i < n_dma; ++i) {\n\n        liobns[i] = SPAPR_PCI_LIOBN(index, i);\n\n    }\n\n\n\n    *pio = SPAPR_PCI_BASE + index * SPAPR_PCI_IO_WIN_SIZE;\n\n    *mmio32 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM32_WIN_SIZE;\n\n    *mmio64 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM64_WIN_SIZE;\n\n}\n", "idx": 8154, "substitutes": {"spapr": [" spipR", "spmapcr", "spapsar", "spmapr", "spapcr", "spipR", "spipcr", "spapar", "spapscr", "spipr", "spapsR", " spapcr", "spapR", "spmapR", " spipcr", " spapar", "spapsr", " spipr", " spapR", "spipar", "spmapar", " spipar"], "index": ["key", "capacity", "doc", "active", "max", "config", "id", "ind", "length", "path", "scan", "error", "position", "prefix", "address", "connection", "loc", "offset", "version", "si", "style", "axis", "handle", "IND", "j", "lock", "device", "cycle", "in", "location", "size", "link", "pointer", "info", "slice", "connect", "level", "point", "timeout", "type", "buffer", "row", "height", "Index", "iter", "status", "document", "find", "instance", "page", "loop", "test", "num", "number", "count", "negative", "x", "open", "block", "pos", "context", "n", "input", "value", "batch"], "buid": ["guid", "bopid", "uupid", "uuid", "buids", "uuId", "uuit", "bapid", "bufid", "buID", "uuID", "guID", "buit", "bufids", "bufId", "baid", "guids", "boit", "buId", "uuids", "bufID", "guId", "boid", "bait", "bupid"], "pio": ["lpios", "jpio", "pios", "pIO", "lpIO", "jpiol", "apiop", "piol", "jpiop", "Pio", "apIO", " pIO", "cpico", "lpico", "jpIO", " piop", "Pios", "pico", "cpio", "PIO", "apiol", "cpios", "apio", "lpio", "cpIO", "piop", " piol", "Pico"], "mmio32": ["mmIO64", " mmios4", " mmios256", "mmios256", "mmi4", " mmio256", "mmIO4", "mmi32", "mmi64", " mmios32", "mmio256", " mmios64", " mmio4", "mmi256", "mmio4", "mmios32", "mmios4", "mmIO256", "mmIO32", "mmios64"], "mmio64": ["mmorg64", "mmIO64", "mio32", "mi64", "mio63", "mi63", "mio64", "mmio63", "mmorg63", "mmi32", "mmi64", "mmIO63", "mmi63", "mmorg32", "mi32", "mmIO32"], "n_dma": ["n_dMA", "n_mna", "n_mmas", "n_dms", "n_mms", "n__dms", "n__dma", "n_fmad", "n_dmas", "n__mma", "n__dmad", "n_fMA", "n_dama", "n_damas", "n_mMA", "n_didmad", "n_didmas", "n__mmad", "n__dmas", "n_fms", "n__mms", "n_dna", "n_dmad", "n_daMA", "n_dana", "n__mmas", "n_fma", "n_didms", "n_fna", "n_fmas", "n_mmad", "n_didma", "n_mma"], "liobns": ["Liobns", "Liobses", "liobvs", "liabns", "Liobbcs", "Liabnos", "liombnos", "lioblds", "Liobbns", "Liabns", "Liobcs", "liobnos", "liobbnos", "liobbcs", "Liobds", "liabds", "Liobbses", "liobsnos", "liobsses", "liobses", "lioblns", "Liobvs", "lioblvs", "liabvs", "Liobbnos", "liobbses", "Liobnos", "liombses", "liombcs", "Liabvs", "liogds", "lioblnos", "Liabds", "liobsns", "liobds", "liogvs", "liobcs", "liombns", "liognos", "liobbns", "liabnos", "liobscs", "liogns"], "errp": ["derp", "derpa", "Erp", "rrp", "derpc", "errpa", "erP", "rrpc", " errm", "rrpa", "Erm", "derP", "erpc", "rrP", "erpa", " errr", "errpc", "erp", "errr", "erm", "errP", "errm", "err", "Err"], "i": [" m", " I", "li", "yi", "p", "sim", " iter", "bi", "is", "ms", "ind", "ii", "id", "ini", "l", "mi", "ix", " bi", " pos", " n", "it", " ind", "ic", "gu", "\u0438", " x", "hi", "si", "j", "di", "port", "gi", "ri", "in", "ip", "info", "ui", "multi", "iu", "ij", "y", "xi", "Index", "zi", "iter", " ti", "ci", "ti", "m", "ami", "ai", "pi", " j", "im", "x", "I", " k", "qi", "ims", "phi", "n", " ii", "ico"]}}
{"project": "qemu", "commit_id": "fb6971c110387cf597b58c411658e3d15cc6c6fb", "target": 1, "func": "static void ppc405ep_compute_clocks (ppc405ep_cpc_t *cpc)\n\n{\n\n    uint32_t CPU_clk, PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk;\n\n    uint32_t UART0_clk, UART1_clk;\n\n    uint64_t VCO_out, PLL_out;\n\n    int M, D;\n\n\n\n    VCO_out = 0;\n\n    if ((cpc->pllmr[1] & 0x80000000) && !(cpc->pllmr[1] & 0x40000000)) {\n\n        M = (((cpc->pllmr[1] >> 20) - 1) & 0xF) + 1; /* FBMUL */\n\n#ifdef DEBUG_CLOCKS_LL\n\n        printf(\"FBMUL %01\" PRIx32 \" %d\\n\", (cpc->pllmr[1] >> 20) & 0xF, M);\n\n#endif\n\n        D = 8 - ((cpc->pllmr[1] >> 16) & 0x7); /* FWDA */\n\n#ifdef DEBUG_CLOCKS_LL\n\n        printf(\"FWDA %01\" PRIx32 \" %d\\n\", (cpc->pllmr[1] >> 16) & 0x7, D);\n\n#endif\n\n        VCO_out = cpc->sysclk * M * D;\n\n        if (VCO_out < 500000000UL || VCO_out > 1000000000UL) {\n\n            /* Error - unlock the PLL */\n\n            printf(\"VCO out of range %\" PRIu64 \"\\n\", VCO_out);\n\n#if 0\n\n            cpc->pllmr[1] &= ~0x80000000;\n\n            goto pll_bypass;\n\n#endif\n\n        }\n\n        PLL_out = VCO_out / D;\n\n        /* Pretend the PLL is locked */\n\n        cpc->boot |= 0x00000001;\n\n    } else {\n\n#if 0\n\n    pll_bypass:\n\n#endif\n\n        PLL_out = cpc->sysclk;\n\n        if (cpc->pllmr[1] & 0x40000000) {\n\n            /* Pretend the PLL is not locked */\n\n            cpc->boot &= ~0x00000001;\n\n        }\n\n    }\n\n    /* Now, compute all other clocks */\n\n    D = ((cpc->pllmr[0] >> 20) & 0x3) + 1; /* CCDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"CCDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 20) & 0x3, D);\n\n#endif\n\n    CPU_clk = PLL_out / D;\n\n    D = ((cpc->pllmr[0] >> 16) & 0x3) + 1; /* CBDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"CBDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 16) & 0x3, D);\n\n#endif\n\n    PLB_clk = CPU_clk / D;\n\n    D = ((cpc->pllmr[0] >> 12) & 0x3) + 1; /* OPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"OPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 12) & 0x3, D);\n\n#endif\n\n    OPB_clk = PLB_clk / D;\n\n    D = ((cpc->pllmr[0] >> 8) & 0x3) + 2; /* EPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"EPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 8) & 0x3, D);\n\n#endif\n\n    EBC_clk = PLB_clk / D;\n\n    D = ((cpc->pllmr[0] >> 4) & 0x3) + 1; /* MPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"MPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 4) & 0x3, D);\n\n#endif\n\n    MAL_clk = PLB_clk / D;\n\n    D = (cpc->pllmr[0] & 0x3) + 1; /* PPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"PPDV %01\" PRIx32 \" %d\\n\", cpc->pllmr[0] & 0x3, D);\n\n#endif\n\n    PCI_clk = PLB_clk / D;\n\n    D = ((cpc->ucr - 1) & 0x7F) + 1; /* U0DIV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"U0DIV %01\" PRIx32 \" %d\\n\", cpc->ucr & 0x7F, D);\n\n#endif\n\n    UART0_clk = PLL_out / D;\n\n    D = (((cpc->ucr >> 8) - 1) & 0x7F) + 1; /* U1DIV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"U1DIV %01\" PRIx32 \" %d\\n\", (cpc->ucr >> 8) & 0x7F, D);\n\n#endif\n\n    UART1_clk = PLL_out / D;\n\n#ifdef DEBUG_CLOCKS\n\n    printf(\"Setup PPC405EP clocks - sysclk %\" PRIu32 \" VCO %\" PRIu64\n\n           \" PLL out %\" PRIu64 \" Hz\\n\", cpc->sysclk, VCO_out, PLL_out);\n\n    printf(\"CPU %\" PRIu32 \" PLB %\" PRIu32 \" OPB %\" PRIu32 \" EBC %\" PRIu32\n\n           \" MAL %\" PRIu32 \" PCI %\" PRIu32 \" UART0 %\" PRIu32\n\n           \" UART1 %\" PRIu32 \"\\n\",\n\n           CPU_clk, PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk,\n\n           UART0_clk, UART1_clk);\n\n#endif\n\n    /* Setup CPU clocks */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_CPU_CLK], CPU_clk);\n\n    /* Setup PLB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_PLB_CLK], PLB_clk);\n\n    /* Setup OPB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_OPB_CLK], OPB_clk);\n\n    /* Setup external clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_EBC_CLK], EBC_clk);\n\n    /* Setup MAL clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_MAL_CLK], MAL_clk);\n\n    /* Setup PCI clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_PCI_CLK], PCI_clk);\n\n    /* Setup UART0 clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_UART0_CLK], UART0_clk);\n\n    /* Setup UART1 clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_UART1_CLK], UART1_clk);\n\n}\n", "idx": 8155, "substitutes": {"cpc": ["copc", "pcc", "cpun", "cmpfc", "podcin", "cpucl", " cpn", "pirct", "pc", " cpnc", "phpac", "pxrc", "pcache", "ppcu", " cpcs", "cpfc", "pt", "pccu", "cvf", "cpf", "cmpn", "cpac", "podc", "cpsc", "httpcall", "cmpcache", "httpac", " cpcin", "ypcs", "pcs", "cmpx", "cpcon", "cmpcu", "cpcc", "copcin", "copac", "codcall", "pcu", "pxcin", "cmpf", "portunc", "codc", "cpcache", "pxcache", " cpcache", "ypca", "copfc", " cpcall", "ppcs", "cpx", "cprc", "ippcon", "cmpt", "copcall", "cmpac", " cpu", "codcin", "copf", "pxc", "podfc", "cpn", "pccs", "ippc", "cppsc", "coprc", "cpu", "cpct", "pirc", "ippcat", "cpunc", "codcc", "portc", "privc", "ypu", "cppc", "podcl", "privfc", "gpc", "cpca", "pxcall", " cpce", " cprc", "copx", "cmpcin", "cpuce", "pxnc", " cpt", "portcon", "gpunc", "cmpc", "cpcin", "phpu", "httpc", "cmpcs", "ppc", "cppf", "cpucu", " cpcc", "cmpsc", "httpcu", "cvcu", "cmpcat", "copn", " cpx", "phpcu", "httpcin", " cpca", "privcat", "httpcc", "cpcat", "cvc", "ippunc", "gpcat", "copce", "cmpct", "cpufc", "cmprc", "pxct", "copcat", "cpt", "cppct", "ypc", "privrc", "cppcu", "gpcon", "pcca", "cvcat", "pxcu", "phpc", "cmpu", "pccc", "cpce", "cpcl", "copct", "cpcs", "ppcc", "copcache", " cpcu", "pxac", "copcu", "cpuc", "cpcall", "cpucin", "pircache", "cppac", "pircall", "portcat", "cpnc", "cpcu", "cmpce", "copsc", "cppu", "cmpnc", "cmpcl"], "CPU_clk": ["CPU_blan", "CPU_clck", "CPU_toolks", "CPU_clks", "CPU2blan", "CPU2blks", "CPU2clck", "CPU2clk", "CPU_blks", "CPU2blck", "CPU_toolck", "CPU2clks", "CPU_blk", "CPU2blk", "CPU_toolan", "CPU_clan", "CPU2clan", "CPU_toolk", "CPU_blck"], "PLB_clk": ["PLB_hlk", "PLB_seqk", "PLB_clkr", "PLB_blka", "PLB_blck", "PLB_blk", "PLB_clka", "PLB_hlck", "PLB_seqkr", "PLB_seqck", "PLB_clck", "PLB_blkr", "PLB_hlka", "PLB_seqka", "PLB_hlkr"], "OPB_clk": ["OPB_clark", "OPB_plk", "OPB_colck", "OPB_clck", "OPB_clks", "OPB_blck", "OPB_colks", "OPB_blks", "OPB_plck", "OPB_colk", "OPB_colark", "OPB_blark", "OPB_plks", "OPB_blk", "OPB_plark"], "EBC_clk": ["EBC_llck", "EBC_llK", "EBC_chak", "EBC_clK", "EBC_blck", "EBC_chk", "EBC_clak", "EBC_llk", "EBC_blK", "EBC_chK", "EBC_llak", "EBC_blk", "EBC_clck", "EBC_blak", "EBC_chck"], "MAL_clk": ["MAL_llkg", "MAL_blk", "MAL_llck", "MAL_flkk", "MAL_flck", "MAL_blkk", "MAL_clkk", "MAL_clck", "MAL_llkk", "MAL_flkg", "MAL_blck", "MAL_clkg", "MAL_llk", "MAL_flk", "MAL_blkg"], "PCI_clk": ["PCI_plkk", "PCI_Clik", "PCI_slk", "PCI_pltk", "PCI_sltk", "PCI_slkk", "PCI_Cltk", "PCI_Clk", "PCI_clik", "PCI_plk", "PCI_slik", "PCI_clkk", "PCI_plik", "PCI_cltk", "PCI_Clkk"], "UART0_clk": ["UART0_plks", "UART0_clck", "UART0_blck", "UART0_glck", "UART0_plc", "UART0_glks", "UART0_blks", "UART0_blk", "UART0_blc", "UART0_plk", "UART0_glk", "UART0_plck", "UART0_clks", "UART0_clc", "UART0_glc"], "UART1_clk": ["UART1_shck", "UART1_shkt", "UART1_clck", "UART1_shk", "UART1_blkt", "UART1_clkt", "UART1_blk", "UART1_blck"], "VCO_out": ["VLC_err", "VCO2output", "VCo_out", "VCO_new", "VCO1in", "VCo_output", "VCO_handle", "VCo_gen", "VCo_handle", "Vco_in", "Vco_out", "VCO_gen", "VCOvalin", "VLC_output", "VLC_co", "VCO_Out", "VCOvaloutput", "VCO_err", "VCOvalout", "VCOJco", "VCOvalhandle", "VCO1output", "VCO_co", "Vco_off", "VCOxoff", "VCO_in", "VCO_output", "VCOxnew", "VCO_msg", "VCO1out", "VCO2out", "VCO2in", "VCO2co", "VLC_OUT", "VCO1handle", "VLC_in", "VCo_in", "VCO_OUT", "VCO_int", "VCOJoutput", "VCO_off", "Vco_new", "VLC_out", "VCo_OUT", "VCOJout", "VCOJin", "Vco_int", "VCOxin", "VCOxout"], "PLL_out": ["Pll_cmd", "Pll_output", "Pll___output", "Pll_err", "Pll___cmd", "Pll_Out", "PLL_in", "PLL_cmd", "Pll___out", "Pll_in", "PLL_err", "Pll_out", "PLL___output", "PLL_output", "PLL___cmd", "PLL___out", "PLL_Out"], "M": ["MO", "S", "LM", "MU", "K", "T", "DM", "MN", "MI", "R", "H", "MC", "C", "MT", "Met", "MD", "MER", "MAT", "MA", "MS", "B", "F", "O", "MIT", "MAN", "AM", "TM", "RM", "CM", "MED", "E", "MX", "m", "N", "P", "ALL", "L", "MM", "I", "J", "V", "U", "NM"], "D": ["S", "K", "DIV", "T", "DM", "d", "H", "R", "AND", "FD", "Q", "DL", "C", "Dir", "MD", "PD", "DS", "Ds", "DP", "DF", "DIR", "DR", "DO", "B", "DB", "A", "F", "Y", "O", "W", "Z", "Do", "LD", "DX", "G", "DE", "Den", "E", "DN", "N", "P", "DD", "DC", "DA", "L", "I", "DI", "And", "V", "DT", "U"]}}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "func": "av_cold void ff_wmv2_common_init(Wmv2Context * w){\n\n    MpegEncContext * const s= &w->s;\n\n\n\n    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);\n\n    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);\n\n}\n", "idx": 8157, "substitutes": {"w": ["rew", "t", "p", "CW", "wh", "config", "temp", "a", "d", "v", "rw", "wx", "man", "r", "wal", "aw", "wa", "words", "wp", "fw", "lang", "wo", "wt", "word", "ex", "mem", "we", "tw", "wd", "wu", "W", "wi", "wl", "nw", "m", "wr", "hw", "window", "c", "wcs", "kw", "WC", "writer", "wine", "z", "wb", "sw"], "s": [" ts", "t", "os", "S", "ess", "p", "conf", "oss", "ds", "south", "is", "a", "d", "ms", "v", "r", "spec", "ins", "serv", "sam", "ss", "self", "h", "aws", "o", "comm", "span", "i", "ns", "js", "hs", "b", "ex", "sq", "g", "ses", "sts", "rs", "gs", "ts", "e", "stats", "m", "res", "acs", "fs", "sv", "cs", "session", "ims", "sb", "c", "wcs", "ls", "n", "ats", "sys", " inputs", "u", "qs", "sa"]}}
{"project": "qemu", "commit_id": "2e50326c44c802ca9b9d591341085e49208927be", "target": 1, "func": "void tap_fd_set_offload(int fd, int csum, int tso4,\n                        int tso6, int ecn, int ufo)\n{\n    unsigned int offload = 0;\n    if (csum) {\n        offload |= TUN_F_CSUM;\n        if (tso4)\n            offload |= TUN_F_TSO4;\n        if (tso6)\n            offload |= TUN_F_TSO6;\n        if ((tso4 || tso6) && ecn)\n            offload |= TUN_F_TSO_ECN;\n        if (ufo)\n            offload |= TUN_F_UFO;\n    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n        offload &= ~TUN_F_UFO;\n        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n            fprintf(stderr, \"TUNSETOFFLOAD ioctl() failed: %s\\n\",\n                    strerror(errno));", "idx": 8158, "substitutes": {"fd": ["df", "ffff", "fr", "hd", "ptr", "ino", "dev", "fn", "disk", "dt", "fi", "ds", "lf", "f", "d", "ind", "id", "ix", "ctx", "fin", "fb", "file", "dd", "cd", "ld", "ff", "ock", "handle", "ud", "io", "dat", "fc", "sd", "gd", "link", "ctl", "dir", "wind", "fp", "cf", "db", "fs", "pid", "bf", "FD", "bd"], "csum": ["cksnum", "cusumer", "dsum", "ckssum", "lssum", "lsul", "cussum", "csnum", "cusul", "lsumer", "cksul", "cksumer", "lsumm", "cssum", "lsum", "cksum", "lsnum", "cksumm", "dsnum", "dsumm", "csumm", "csul", "csumer", "dssum", "cusum"], "tso4": ["tsso8", "tsuFour", "tso42", "tso44", "tcofour", "tsp42", "tco1", "toto04", "tsofour", "tso1", "tssofour", "tsco04", "tico4", "tso04", "tsp1", "tico44", "Tco4", "toto8", "tco8", "tsco8", "tbo04", "tco6", "tbo8", "tsco4", "tscofour", "temso6", "temsocFour", "totofour", "Tso42", "tco4", "Tco1", "tsoFour", "tsp44", "tico42", "tsp4", "tco44", "tsso4", "tsocFour", "temsoc6", "tsu6", "tsso04", "tcoFour", "tsu4", "tsoc6", "Tso1", "toto4", "temsoc4", "tso8", "Tco44", "Tco42", "tbofour", "tsoc4", "temsoFour", "tco42", "temso4", "tbo4", "tico1", "Tso4", "tco04", "Tso44"], "tso6": [" tso16", "tiso16", "sso8", "tmo6", " tno5", "tsu16", "tso5", "sco8", "tiso6", "tsp16", "tco5", "tsi6", "tno5", "tsi2", "tsu5", "tco8", "tno2", "tco16", "tmo16", "tco6", "sco16", "tso2", " tco16", "tmo5", " tso5", "tco4", " tno6", " tco6", "tsp8", "tsi16", "tsi5", " tco5", "sso6", "tsp6", "tco2", " tso2", "tsu4", "tmo4", "tso16", " tco4", "tiso8", " tno2", "tso8", "sco6", " tno16", "tno16", "sso16", "tno6", "tsu6"], "ecn": ["epn", "epc", "ccn", "acne", "ecns", " ecN", "escns", "eco", "rcc", "rcN", "rcne", "escN", "acn", "ecN", "epN", "ecc", "cco", "esco", "rcn", "acc", " eco", "escn", "acN", " ecns", "ccns", "ecne", "epne", "ccN"], "ufo": ["ufode", "fonton", "\u00fcn", "lipode", "fuo", "fuol", "ufon", "fonto", "lipo", "\u00fcon", "ufn", "ufoa", "lipol", "fifol", "dfon", "dfoa", "lipor", "fontn", "\u00fco", "fuor", "\u00fcoa", "ufor", "ufol", "fifor", "fuode", "fontoa", "dfn", "fifo", "fifode", "dfo"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void ff_mpeg1_encode_init(MpegEncContext *s)\n\n{\n\n    static int done=0;\n\n\n\n    common_init(s);\n\n\n\n    if(!done){\n\n        int f_code;\n\n        int mv;\n\n\tint i;\n\n\n\n        done=1;\n\n        init_rl(&rl_mpeg1);\n\n\n\n\tfor(i=0; i<64; i++)\n\n\t{\n\n\t\tmpeg1_max_level[0][i]= rl_mpeg1.max_level[0][i];\n\n\t\tmpeg1_index_run[0][i]= rl_mpeg1.index_run[0][i];\n\n\t}\n\n        \n\n        init_uni_ac_vlc(&rl_mpeg1, uni_mpeg1_ac_vlc_bits, uni_mpeg1_ac_vlc_len);\n\n\n\n\t/* build unified dc encoding tables */\n\n\tfor(i=-255; i<256; i++)\n\n\t{\n\n\t\tint adiff, index;\n\n\t\tint bits, code;\n\n\t\tint diff=i;\n\n\n\n\t\tadiff = ABS(diff);\n\n\t\tif(diff<0) diff--;\n\n\t\tindex = av_log2(2*adiff);\n\n\n\n\t\tbits= vlc_dc_lum_bits[index] + index;\n\n\t\tcode= (vlc_dc_lum_code[index]<<index) + (diff & ((1 << index) - 1));\n\n\t\tmpeg1_lum_dc_uni[i+255]= bits + (code<<8);\n\n\t\t\n\n\t\tbits= vlc_dc_chroma_bits[index] + index;\n\n\t\tcode= (vlc_dc_chroma_code[index]<<index) + (diff & ((1 << index) - 1));\n\n\t\tmpeg1_chr_dc_uni[i+255]= bits + (code<<8);\n\n\t}\n\n\n\n        mv_penalty= av_mallocz( sizeof(uint8_t)*(MAX_FCODE+1)*(2*MAX_MV+1) );\n\n\n\n        for(f_code=1; f_code<=MAX_FCODE; f_code++){\n\n            for(mv=-MAX_MV; mv<=MAX_MV; mv++){\n\n                int len;\n\n\n\n                if(mv==0) len= mbMotionVectorTable[0][1];\n\n                else{\n\n                    int val, bit_size, range, code;\n\n\n\n                    bit_size = f_code - 1;\n\n                    range = 1 << bit_size;\n\n\n\n                    val=mv;\n\n                    if (val < 0) \n\n                        val = -val;\n\n                    val--;\n\n                    code = (val >> bit_size) + 1;\n\n                    if(code<17){\n\n                        len= mbMotionVectorTable[code][1] + 1 + bit_size;\n\n                    }else{\n\n                        len= mbMotionVectorTable[16][1] + 2 + bit_size;\n\n                    }\n\n                }\n\n\n\n                mv_penalty[f_code][mv+MAX_MV]= len;\n\n            }\n\n        }\n\n        \n\n\n\n        for(f_code=MAX_FCODE; f_code>0; f_code--){\n\n            for(mv=-(8<<f_code); mv<(8<<f_code); mv++){\n\n                fcode_tab[mv+MAX_MV]= f_code;\n\n            }\n\n        }\n\n    }\n\n    s->me.mv_penalty= mv_penalty;\n\n    s->fcode_tab= fcode_tab;\n\n    if(s->codec_id == CODEC_ID_MPEG1VIDEO){\n\n        s->min_qcoeff=-255;\n\n        s->max_qcoeff= 255;\n\n    }else{\n\n        s->min_qcoeff=-2047;\n\n        s->max_qcoeff= 2047;\n\n    }\n\n    s->intra_ac_vlc_length=\n\n    s->inter_ac_vlc_length=\n\n    s->intra_ac_vlc_last_length=\n\n    s->inter_ac_vlc_last_length= uni_mpeg1_ac_vlc_len;\n\n}\n", "idx": 8169, "substitutes": {"s": ["sc", "S", "p", "ds", "a", "v", "ps", "ctx", "ss", "o", "bs", "ns", "js", "b", "sq", "ses", "sts", "sg", "rs", "gs", "ts", "es", "e", "m", "fs", "sv", "cs", "ims", "sb", "c", "as", "ats", "n"], "f_code": ["fbewno", "fewcd", "f_ode", "fbewcd", "f_cd", " f_coe", "fmyode", "fewno", "fbewcode", "f_length", "fb_cd", "fb_code", "f2code", "f_desc", " f2codes", "f_codes", "f__code", "fmyno", "f_no", "f_coe", "f__cd", "fewcod", "fb_cod", "fmydesc", " f_desc", " f_codes", "fb_no", " f_length", "faccode", " f2code", " f2cod", "fewcode", "f__no", "faccod", " f_cod", "fmycode", "f2cod", "f_cod", "fbewcod", " f_no", " f_ode", "f2codes", "f__cod", "faccodes"], "mv": ["mtva", "mtf", " mf", "dmV", "vmv", "mtv", "mf", "mtvi", "mvi", "bv", "bvi", "rmV", "rmov", "dmva", "dmx", "vv", "Mvc", "nV", "rmf", "vx", "nv", " mV", "mva", "nvc", "vmvi", "vmf", "bV", "rmvi", "mx", "MV", "Mx", "vmva", "dmvi", "dmv", "rmvc", "Mv", "vva", "mvc", "rmv", "rmx", "dmov", "bf", " mvi", "dmvc", " mvc", " mx", "vvi", "mV", "mov", " mva", "nov"], "i": ["p", "id", "l", "ii", "ini", "it", "q", "hi", "mount", "di", "gi", "ie", "slice", "y", "PI", "ci", "cli", "c", "n", "ei", "ix", "list", "ic", "si", "j", "ji", "name", "zi", "record", "this", "pi", "x", "phi", "us", "series", "is", "f", "ind", "mi", "axis", "io", "ri", "chain", "ip", "point", "multi", "print", "ti", "m", "ai", "im", "I", "out", "dr", "t", "li", "sim", "ki", "fi", "bi", "v", "to", "me", "uri", "time", "in", "info", "g", "ui", "iu", "xi", "ij", "status", "batch"], "adiff": ["dddiff", "artelta", " adIFF", "ddial", " adDiff", "adial", "madIFF", "adddiff", "adDiff", "ddelta", "dDiff", "adIFF", "dIFF", " adison", "edial", "edelta", "artifference", "artif", "odelta", "ddiff", "adelta", "difference", "addial", "addiff", "dison", "adifference", "adison", "eddiff", "adif", "dif", "ediff", "madison", "addelta", "madDiff", "odif", "delta", "madiff", "odifference", "odiff", "artiff"], "index": ["key", "active", "present", "host", "full", "id", "path", "condition", "error", "loc", "iso", "available", "root", "slice", "date", "seed", "interface", "row", "height", "Index", "cond", "page", "loop", "operator", "n", "query", "success", "ix", "ctx", "list", "strength", "empty", "timeout", "example", "zero", "new", "find", "instance", "raw", "all", "num", "x", "open", "shape", "request", "config", "is", "ind", "address", "ion", "axis", "lock", "read", "location", "chain", "outer", "point", "level", "table", "local", "create", "out", "init", "inner", "length", "position", "prefix", "parent", "offset", "style", "method", "time", "vector", "link", "result", "info", "status", "bit", "test", "update", "route", "localhost", "pos", "input", "value", "second"], "bits": ["flags", "bots", "ions", "items", "jobs", "bps", "members", "details", "codes", "plugins", "ins", "chains", "nets", "files", "issues", "locks", "pieces", "rots", "fps", "pins", "outs", "points", "units", "changes", "bs", "js", "ints", "bytes", "maps", "blocks", "boxes", "heads", "keys", "tags", "gs", "faces", "stats", "boot", "checks", "lines", "actions", "bit", "its", "bugs", "values", "bis", "cs", "bys", "parts", "bin", "terms", "ls", "cod", "settings", "ats", "cells", "odes", "weights", "fields", "cats", "bands"], "code": ["key", "co", "id", "ode", "cont", "condition", "str", "description", "reason", "body", "coe", "text", "ci", "Code", "c", "message", "cmd", "be", "ch", "copy", "data", "list", "check", "note", "def", "name", "comment", "new", "try", "ce", "core", "header", "xx", "mode", "magic", "block", "entry", "change", "type", "zip", "te", "cs", "sequence", "_", "create", "go", "add", "function", "scene", "force", "cd", "cc", "coded", "link", "result", "info", "rice", "cmp", "bit", "xxx", "test", "zone", "desc", "cod", "value", "cache"], "diff": ["deg", "df", "commit", "fail", "extra", "conf", "inter", "dev", "config", "work", "delete", "d", "dist", "Delta", "sum", "Diff", "length", "dust", "split", "error", "fd", "different", "change", " difference", "equal", "delay", "description", "dirty", "dl", "changes", "mix", "fix", "none", "history", "added", "result", "def", "exc", "dx", "shift", "slice", "step", "comp", "comment", "level", "eff", "ref", " differences", "new", " Diff", "cmp", "changed", "cond", "missing", "disc", "test", "part", "distance", "dis", "patch", "del", "pos", "iff", "add", "value"], "len": ["t", "lim", "li", "elt", "max", "el", "limit", "ll", "ln", "lf", "Len", "l", "lp", "dim", "length", "z", "en", "lon", "size", "mem", "resp", "il", "slice", "bl", "iter", "vec", "var", "num", "ls", "lan", "nl", "n", "pos", "Length"], "val": ["VAL", "ch", "sec", "eval", "sel", "v", "col", "ctx", "label", "loc", "valid", "bal", "b", "est", "point", "pol", "vals", "bit", "base", "var", "item", "start", "value", "Val"], "bit_size": ["bit2length", " bit_count", "bit2len", "bit_length", "bit_count", " bit_length", "bit_len", "bit2count", " bit_len", "bit2size"], "range": ["bound", "r", "spec", "channel", "ange", "label", "prefix", "loc", "axis", "pad", "chain", "slice", "ref", "row", "rank", "Range", "scale", "base", "part", "window", "mask", "region", "bin", "angle", "block", "pos", "shape", "frame"]}}
{"project": "FFmpeg", "commit_id": "c9f6eab184cac379c7a44d5899979165798d45d4", "target": 1, "func": "static av_cold int ac3_decode_init(AVCodecContext *avctx)\n\n{\n\n    AC3DecodeContext *s = avctx->priv_data;\n\n    s->avctx = avctx;\n\n\n\n    ff_ac3_common_init();\n\n    ac3_tables_init();\n\n    ff_mdct_init(&s->imdct_256, 8, 1, 1.0);\n\n    ff_mdct_init(&s->imdct_512, 9, 1, 1.0);\n\n    ff_kbd_window_init(s->window, 5.0, 256);\n\n    dsputil_init(&s->dsp, avctx);\n\n    ff_fmt_convert_init(&s->fmt_conv, avctx);\n\n    av_lfg_init(&s->dith_state, 0);\n\n\n\n    /* set scale value for float to int16 conversion */\n\n    s->mul_bias = 32767.0f;\n\n\n\n    /* allow downmixing to stereo or mono */\n\n    if (avctx->channels > 0 && avctx->request_channels > 0 &&\n\n            avctx->request_channels < avctx->channels &&\n\n            avctx->request_channels <= 2) {\n\n        avctx->channels = avctx->request_channels;\n\n    }\n\n    s->downmixed = 1;\n\n\n\n    /* allocate context input buffer */\n\n    if (avctx->error_recognition >= FF_ER_CAREFUL) {\n\n        s->input_buffer = av_mallocz(AC3_FRAME_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!s->input_buffer)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n    return 0;\n\n}\n", "idx": 8171, "substitutes": {"avctx": [" avcontext", "wavctx", "avedocument", "vrtx", "varkt", "vanctx", " avaddr", "avcmd", "avaddr", "navdocument", "navtx", "afcp", " avcmd", "avgc", "wavtx", "avectx", "averkt", "wavcmd", "devcontext", "vancontext", "avecu", "avercu", "avtimeout", "avpid", "afkw", "vrjac", "vrctx", "avcu", "wavcontext", "afctx", "varctx", "navctx", "wavjac", "avdocument", "avetx", "afcam", "avergc", " avcookie", " avjac", "afdocument", "ajcfg", " avtx", "afcu", " avkw", "avctrl", "avcp", "navcam", "afgc", "avpkg", "avercontext", "vtx", "avcontext", "avetimeout", "ajtx", "averctx", "vctx", "wavctrl", "AVtx", "ajctx", "navcontext", "avkt", "avcam", "vrcontext", "avercfg", "vantx", "avjac", "avcfg", "devctx", " avdocument", "ajcu", "ajkt", "avcookie", "devctrl", "vancomp", " avconn", "afcfg", "AVconn", "AVcontext", "avecfg", "avconn", "AVaddr", "ajcontext", "averpid", " avcomp", "avecontext", " avcu", "AVctx", "afconn", "avertimeout", "avepkg", "devtx", "avkw", "avertx", "avercam", "ajpid", "afcontext", "ajaddr", "averdocument", "wavpkg", "aftimeout", "avectrl", "varpid", "vcomp", " avpkg", "vcontext", "wavcu", "aftx", "avejac", "avercp", "avekw", "varcu", "avcomp", "avecmd", "afcookie", "avtx", "navcookie", "ajcp", "avegc"], "s": ["flags", "t", "os", "S", "p", "sports", "ds", "is", "ms", "l", "v", "vs", "spec", "ps", "sm", "serv", "sl", "sam", "obj", "less", "cl", "set", "ss", "ports", "j", "aws", "comm", "h", "bs", "sd", "js", "source", "ns", "hs", "b", "i", "sq", "g", "sts", "rs", "gs", "y", "ts", "es", "stats", "m", "bits", "fs", "its", "sv", "service", "cs", "sb", "c", "ls", "ats", "qs", "sys", "n", "se", "sw", "services"]}}
