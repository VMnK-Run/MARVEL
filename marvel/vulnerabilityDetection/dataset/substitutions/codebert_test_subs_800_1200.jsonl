{"project": "FFmpeg", "commit_id": "08a747afb98c11da48b89339c2f1c5fdc56ced7e", "target": 0, "func": "static void count_frame_bits_fixed(AC3EncodeContext *s)\n\n{\n\n    static const int frame_bits_inc[8] = { 0, 0, 2, 2, 2, 4, 2, 4 };\n\n    int blk;\n\n    int frame_bits;\n\n\n\n    /* assumptions:\n\n     *   no dynamic range codes\n\n     *   bit allocation parameters do not change between blocks\n\n     *   no delta bit allocation\n\n     *   no skipped data\n\n     *   no auxilliary data\n\n     *   no E-AC-3 metadata\n\n     */\n\n\n\n    /* header */\n\n    frame_bits = 16; /* sync info */\n\n    if (s->eac3) {\n\n        /* bitstream info header */\n\n        frame_bits += 35;\n\n        frame_bits += 1 + 1 + 1;\n\n        /* audio frame header */\n\n        frame_bits += 2;\n\n        frame_bits += 10;\n\n        /* exponent strategy */\n\n        for (blk = 0; blk < AC3_MAX_BLOCKS; blk++)\n\n            frame_bits += 2 * s->fbw_channels + s->lfe_on;\n\n        /* converter exponent strategy */\n\n        frame_bits += s->fbw_channels * 5;\n\n        /* snr offsets */\n\n        frame_bits += 10;\n\n        /* block start info */\n\n        frame_bits++;\n\n    } else {\n\n        frame_bits += 49;\n\n        frame_bits += frame_bits_inc[s->channel_mode];\n\n    }\n\n\n\n    /* audio blocks */\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        if (!s->eac3) {\n\n            /* block switch flags */\n\n            frame_bits += s->fbw_channels;\n\n\n\n            /* dither flags */\n\n            frame_bits += s->fbw_channels;\n\n        }\n\n\n\n        /* dynamic range */\n\n        frame_bits++;\n\n\n\n        /* spectral extension */\n\n        if (s->eac3)\n\n            frame_bits++;\n\n\n\n        if (!s->eac3) {\n\n            /* exponent strategy */\n\n            frame_bits += 2 * s->fbw_channels;\n\n            if (s->lfe_on)\n\n                frame_bits++;\n\n\n\n            /* bit allocation params */\n\n            frame_bits++;\n\n            if (!blk)\n\n                frame_bits += 2 + 2 + 2 + 2 + 3;\n\n        }\n\n\n\n        /* converter snr offset */\n\n        if (s->eac3)\n\n            frame_bits++;\n\n\n\n        if (!s->eac3) {\n\n            /* delta bit allocation */\n\n            frame_bits++;\n\n\n\n            /* skipped data */\n\n            frame_bits++;\n\n        }\n\n    }\n\n\n\n    /* auxiliary data */\n\n    frame_bits++;\n\n\n\n    /* CRC */\n\n    frame_bits += 1 + 16;\n\n\n\n    s->frame_bits_fixed = frame_bits;\n\n}\n", "idx": 8181, "substitutes": {"s": ["server", "sym", "service", "cs", "self", "c", "a", "i", "d", "b", "hs", "sites", "gs", "as", "e", "comments", "rs", "js", "os", "bis", "site", "its", "ls", "ss", "sq", "sb", "h", "same", "S", "ds", "session", "fs", "ssl", "ic", "ans", "o", "qs", "ses", "the", "f", "sf", "xs", "y", "an", "services", "sg", "in", "v", "ps", "l", "sync", "u", "south", "sys", "su", "x", "features", "g", "side", "states", "is", "sup", "small", "comm", "es", "new", "p", "ts", "si", "full", "sis", "ns", "less", "spec", "us", "t", "your", "m", "conf", "n", "sets", "this", "stats", "data"], "frame_bits_inc": ["frame_bits_ins", "frame_bit_rec", "frame_bits2dec", "frame_bit_ins", "frame_bit_in", "frame_bits_rec", "frame_bits_enc", "frame_bits_dec", "frame_bits_in", "frame_bit_inc", "frame_bit_dec", "frame_bits2ins", "frame_bits2inc", "frame_bit_enc", "frame_bits2in"], "blk": [" blks", "blku", " blck", "belb", "BLk", "plkt", " blok", "blok", "ylck", "blK", "flck", "blc", " blc", "blmk", "Blck", "slk", "belk", "BLq", "clk", "clok", " blb", "Blk", "plb", "blb", "Blks", " blmk", "Blq", "ylks", "BLck", "plks", "clK", "belck", "slb", "flk", "plc", "blq", "Blmk", "ylk", "plku", "BLok", " blq", "blck", "BLK", "slc", "slq", "slks", "plok", "blkt", "clck", "flb", " blkt", "flku", "BLc", "blks", "ylmk", "plk", "slok", "slkt", "plq", "belku", " blK", "plck"], "frame_bits": ["frame64mins", " frame_ints", "frame_effects", "scene_effects", "frame_overs", "framexbugs", "frame_nos", " frame_mins", "framexbits", "frame_pins", "frame___planes", "sequence_checks", "frame_lins", "frame_checks", " frame_bugs", "frame67its", "image_parts", "frame33lins", "fram67bits", "motion_bits", "frame67pins", "fram_lins", " frame_lines", " frame_abs", "frame_its", "frame_details", "fram_bits", "frame67locks", "frame_dates", "fram_planes", " frame_pieces", " frame_details", "motion_flags", " frame_locks", " frame_hours", "frame_parts", "frame67parts", " frame_bytes", " frame_dates", "frame67lins", "frame64lines", "frame_bugs", "frame_holes", "image_nos", " frame_pins", "scene_lins", "fram_locks", "fram67lins", " frame_bars", "frame_bytes", "frame_pieces", "frame_ints", "sequence_bugs", " frame_fixes", " frame_holes", " frame_parts", "frame_abs", "scene_bits", "frame33effects", "frame___bits", "frame_lines", " frame_bit", "fram67locks", "frame___bugs", "frame_bars", " frame_tops", "motion_planes", "frame_locks", "frame_tops", "frame64bits", "frame_hours", "frame_bit", " frame_overs", "frame33bits", "frame67pieces", "framexbytes", "framexovers", " frame_nos", "frame_mins", "frame_flags", "frame64bytes", "frame___pieces", "frame67tops", "frame_fits", "image_bits", "frame67bits", " frame_its", "motion_hours", "frame_fixes", "sequence_bits", "frame_planes", " frame_planes", " frame_fits"]}}
{"project": "FFmpeg", "commit_id": "0c32e19d584ba6ddbc27f0a796260404daaf4b6a", "target": 0, "func": "static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {\n\n    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]];\n\n        tc[1] = tc0_table[index_a][bS[1]];\n\n        tc[2] = tc0_table[index_a][bS[2]];\n\n        tc[3] = tc0_table[index_a][bS[3]];\n\n        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 8197, "substitutes": {"pix": ["Pix", " pixel", "cix", "Pip", " prc", " pip", "mixels", "cixels", "pixel", "fip", "prc", "mip", "fixels", "pixels", "fixel", "frc", " pixels", "mrc", "crc", "Pixel", "pip", "fix", "Pixels", "cixel", "mix", "mixel"], "stride": ["driding", " strice", "strade", "strides", " strade", "erriding", "drider", "brpe", " strides", "bride", "errider", "dride", "strice", " strane", "drided", "Strpe", "Strided", " strider", "erride", "Stride", "drides", "strpe", "strided", "drane", "drade", "brice", " striding", " strided", "brides", "striding", "errade", "strane", "brided", " strpe", "strider", "Strice", "brane"], "bS": [" bV", " bEs", "bSl", "lSu", "bIS", " bSc", "pP", "basDS", " bAs", "bV", "fSc", "fIS", "basS", "baseS", " bSC", " bSS", "abCS", "bSS", " bCS", "baseEs", "BSC", "fS", "basCS", "lS", "abS", "pWS", "abAs", "aS", "bSu", "bC", "BSl", "baseD", " bC", " bDS", " bD", "fP", " bParts", "bSc", " bWS", "pS", "lEs", "basAs", "BS", " bP", "bP", " bIS", "abDS", "bWS", "bSC", " bSl", "fSS", "pParts", "bCS", "bDS", "abSl", "aP", "BC", "abC", "bEs", " bSu", "bD", "bParts", "aV", "baseSu", "lD", "bAs", "fV", "abSC"], "qp": ["Qpm", "qutp", "caln", "QP", "Qps", "sqc", "sqlp", "sqt", "quc", "sqtp", "calp", "qut", "qP", " QP", "qt", "qps", "callp", "quP", "eqc", "qpm", "qtp", " Qp", "sqn", "qulp", "eqtp", "eqp", "qupm", "qn", "Qp", "sqp", "qup", "qlp", "calc", "eqt", " Qps", " Qpm", "qc", "qups", "qun"], "h": ["g", "ph", "hw", "H", "hd", "ctx", "f", "hr", "api", "php", "host", "self", "oh", "hess", "c", "d", "p", "ha", "uh", "http", "gh", "sh", "b", "ah", "bh", "hp", "zh", "hh", "ht", "html", "hi", "v", "hs", "hub", "ch", "header", "t", "r", "ih", "l", "q", "u", "conn", "hl", "he", "w", "m", "dh", "e", "eh", "rh", "s", "han", "history", "hm"], "tc": ["cas", "binary", "cases", "tf", "ctx", "type", "tu", "cum", "xc", "cs", "nc", "gam", "bc", "icc", "ul", "c", "pb", "pc", "ca", "uca", "cache", "beta", "rc", "config", "term", "tm", "temp", "ace", "cb", "tk", "loc", "toc", "ic", "cu", "ctrl", "gb", "cc", "fc", "dc", "ac", "css", "tmp", "Beta", "bb", "t", "ui", " TC", "ci", "sc", "index", "cus", "acc", "ta", "tx", "tt", "lc", "ec", "mc", "uc", "margin", "contract", "asc", "TC"]}}
{"project": "FFmpeg", "commit_id": "ac66834c759b7130fb5be51f63cb6dff9b294cba", "target": 0, "func": "int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,\n\n                         int *frame_size_ptr,\n\n                         uint8_t *buf, int buf_size)\n\n{\n\n    int ret;\n\n\n\n    *frame_size_ptr= 0;\n\n    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){\n\n        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,\n\n                                buf, buf_size);\n\n        avctx->frame_number++;\n\n    }else\n\n        ret= 0;\n\n    return ret;\n\n}\n", "idx": 8199, "substitutes": {"avctx": ["avconfig", "afca", "avcmp", " avsc", "avcontext", "afcci", "avcci", "aphctx", "AVctx", "afsc", "avectx", "afconfig", "avcf", "avegpu", " avcci", "aphcontext", "avbc", " avcontext", "avloc", "aphcf", " avcmp", "afgpu", "afbc", "AVloc", "afcf", "avgpu", "avca", "AVcf", "avebc", " avconfig", "afloc", "aveca", "aveconfig", "awcontext", " avbc", "avecontext", " avgpu", "awca", "avsc", "avecmp", "AVcontext", "awctx", "awbc", "avecci", "afctx", "avesc", "afcmp", "afcontext", "aphloc"], "samples": ["ssamples", "sesannels", "nources", "sources", " samps", "sample", "Samps", " sources", "nample", " sample", "sesample", "Sample", "sesources", "namples", " sannels", "samps", "sannels", "sesamples", "ssample", "Samples", "ssources", "Sources", "ssamps", "nannels"], "frame_size_ptr": ["frame_size_size", "frame_size_offset", "frame_size_pointer", "frame_size_inter", "frame_size_32", "frame_size_addr", "frame_size_ref"], "buf": ["ctx", "pool", "f", "src", "vec", "bc", "bag", "seq", "pb", "config", "bytes", "cb", "loc", "b", "blocks", "fb", "queue", "lim", "rb", "bd", "tmp", "cv", "bb", "alloc", "uf", "cf", "buff", "wav", "buffer", "port", "wb", "fd", "uc", "batch", "bf", "data"], "buf_size": ["vec_body", "bufdnumber", "bufdoffset", "windowdoffset", "veclexsize", "border_iz", "vec_sized", "bufdsize", "buf_sum", "buflexbody", "window_number", "buflencapacity", "border_size", "window_size", "border_adjust", "veclexbody", "border_capacity", "buf64adjust", "buflexsized", "buf_offset", "buf_adjust", "window_offset", "buf_capacity", "buf_number", "bufroffset", "borderamcapacity", "borderamsize", "vec_sum", "buflensize", "borderamiz", "bufleniz", "bufrnumber", "bufamiz", "buf64size", "windowdnumber", "borderamadjust", "vec_size", "buflexsize", "bufamcapacity", "veclexsized", "buf64iz", "bufamsize", "buf_body", "bufamadjust", "buflexsum", "veclexsum", "buflenadjust", "buflensum", "buf_iz", "buflenbody", "buf_sized", "windowdsize", "bufrsize", "buflensized", "buf64capacity"], "ret": ["valid", "rets", "f", "rt", "match", "att", "resp", "re", "RET", "ref", "rev", "ft", "result", "addr", "success", "len", "al", "art", "afe", " Ret", "sb", "cat", "rc", "back", "offset", "arr", "lit", "fun", "flag", "bit", "ext", "mt", "code", "active", "num", "val", "det", "def", "arg", "reply", "xt", "res", "nt", "reg", "fin", "alt", "Ret", "bf", "data"], "frame_number": ["frame_index", "seq_number", "seq_index", "seqingno", "seq_Number", "frameingnumber", "frame_Number", "seqingindex", "seqingnumber", "frameingno", "frame_no", "seq_no", "seqingNumber", "frameingindex", "frameingNumber"]}}
{"project": "FFmpeg", "commit_id": "fed92adbb3fc6cbf735e3df9a2f7d0a2917fcfbd", "target": 1, "func": "void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb,\n\n                    int mb_x, int mb_y, int layout)\n\n{\n\n    VP8Macroblock *mb_edge[3] = { 0      /* top */,\n\n                                  mb - 1 /* left */,\n\n                                  0      /* top-left */ };\n\n    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };\n\n    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };\n\n    int idx = CNT_ZERO;\n\n    int cur_sign_bias = s->sign_bias[mb->ref_frame];\n\n    int8_t *sign_bias = s->sign_bias;\n\n    VP56mv near_mv[4];\n\n    uint8_t cnt[4] = { 0 };\n\n    VP56RangeCoder *c = &s->c;\n\n\n\n    if (!layout) { // layout is inlined (s->mb_layout is not)\n\n        mb_edge[0] = mb + 2;\n\n        mb_edge[2] = mb + 1;\n\n    } else {\n\n        mb_edge[0] = mb - s->mb_width - 1;\n\n        mb_edge[2] = mb - s->mb_width - 2;\n\n    }\n\n\n\n    AV_ZERO32(&near_mv[0]);\n\n    AV_ZERO32(&near_mv[1]);\n\n    AV_ZERO32(&near_mv[2]);\n\n\n\n    /* Process MB on top, left and top-left */\n\n#define MV_EDGE_CHECK(n)                                                      \\\n\n    {                                                                         \\\n\n        VP8Macroblock *edge = mb_edge[n];                                     \\\n\n        int edge_ref = edge->ref_frame;                                       \\\n\n        if (edge_ref != VP56_FRAME_CURRENT) {                                 \\\n\n            uint32_t mv = AV_RN32A(&edge->mv);                                \\\n\n            if (mv) {                                                         \\\n\n                if (cur_sign_bias != sign_bias[edge_ref]) {                   \\\n\n                    /* SWAR negate of the values in mv. */                    \\\n\n                    mv = ~mv;                                                 \\\n\n                    mv = ((mv & 0x7fff7fff) +                                 \\\n\n                          0x00010001) ^ (mv & 0x80008000);                    \\\n\n                }                                                             \\\n\n                if (!n || mv != AV_RN32A(&near_mv[idx]))                      \\\n\n                    AV_WN32A(&near_mv[++idx], mv);                            \\\n\n                cnt[idx] += 1 + (n != 2);                                     \\\n\n            } else                                                            \\\n\n                cnt[CNT_ZERO] += 1 + (n != 2);                                \\\n\n        }                                                                     \\\n\n    }\n\n\n\n    MV_EDGE_CHECK(0)\n\n    MV_EDGE_CHECK(1)\n\n    MV_EDGE_CHECK(2)\n\n\n\n    mb->partitioning = VP8_SPLITMVMODE_NONE;\n\n    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {\n\n        mb->mode = VP8_MVMODE_MV;\n\n\n\n        /* If we have three distinct MVs, merge first and last if they're the same */\n\n        if (cnt[CNT_SPLITMV] &&\n\n            AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT]))\n\n            cnt[CNT_NEAREST] += 1;\n\n\n\n        /* Swap near and nearest if necessary */\n\n        if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {\n\n            FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);\n\n            FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);\n\n        }\n\n\n\n        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {\n\n            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {\n\n                /* Choose the best mv out of 0,0 and the nearest mv */\n\n                clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);\n\n                cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +\n\n                                    (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +\n\n                                    (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);\n\n\n\n                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {\n\n                    mb->mode = VP8_MVMODE_SPLIT;\n\n                    mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1];\n\n                } else {\n\n                    mb->mv.y  += vp8_read_mv_component(c, s->prob->mvc[0]);\n\n                    mb->mv.x  += vp8_read_mv_component(c, s->prob->mvc[1]);\n\n                    mb->bmv[0] = mb->mv;\n\n                }\n\n            } else {\n\n                clamp_mv(s, &mb->mv, &near_mv[CNT_NEAR]);\n\n                mb->bmv[0] = mb->mv;\n\n            }\n\n        } else {\n\n            clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]);\n\n            mb->bmv[0] = mb->mv;\n\n        }\n\n    } else {\n\n        mb->mode = VP8_MVMODE_ZERO;\n\n        AV_ZERO32(&mb->mv);\n\n        mb->bmv[0] = mb->mv;\n\n    }\n\n}\n", "idx": 8208, "substitutes": {"s": ["server", "g", "support", "size", "f", "service", "cs", "state", "sf", "ss", "side", "y", "sq", "single", "a", "is", "i", "services", "d", "sb", "h", "p", "sci", "si", "iss", "S", "session", "b", "sg", "fs", "ssl", "sie", "ds", "settings", "shell", "se", "sl", "sim", "ns", "v", "spec", "client", "o", "t", "ses", "l", "sc", "sync", "gs", "w", "m", "south", "e", "n", "sa", "space", "js", "x"], "mb": ["big", "ph", "pg", "em", "mode", "pm", "ref", "mph", "meg", "MB", "um", "mi", "mp", "GB", "nb", "bc", "byte", "md", "pb", "media", "db", "lb", "eb", "sb", "mod", "kb", "ib", "loc", "b", "MP", "cm", "fb", "bound", "url", "gb", "mt", "rb", "machine", "ms", "image", "vm", "bb", "mac", "cmd", "ym", "m", "om", "mop", "emb", "mm", "base", "ob", "mc", "large", "meta", "bp", "wb", "bf", "mag", "mn", " MB", "mx", "nm"], "mb_x": ["MB_x", "MB_width", "mb_width", "MB_y", "MB_index", "mb_index"], "mb_y": ["MB_z", "MB_x", "mb_z", "MB_y"], "layout": ["np", "adj", "block", "f", "mode", "id", "local", "nc", "sq", "design", "draw", "config", "h", "cb", "offset", "loc", "qa", "cell", "orient", "shape", "nd", "style", "nl", "position", "flat", "center", "scale", "loop", "z", "fc", "dc", "num", "layer", "scroll", "cl", "def", "l", "sync", "form", "nn", "Layout", "lc"], "mb_edge": ["bb_edge", "bb_connection", "mb_scale", "MB_connection", "MB_ge", "bb_scale", "bb_ide", "bb_close", "MB_edge", "bb_gate", "mb_close", "mb_connection", "mb_ide", "mb_ge", "mp_edge", "mb_line", "mb_slice", "mp_ide", "bb_pad", "mp_line", "bb_slice", "mb_gate", "mp_slice", "MB_ide", "mb_pad"], "sign_bias": ["sign_base", "sign_blius", "sign_gias", "sign_bases", "sign_gases", "sign_abase", "sign_biary", "sign_abary", "sign_gase", "sign_cias", "sign_abare", "sign_Bias", "sign_blases", "sign_bature", "sign_blinding", "sign_biature", "sign_bius", "sign_burinding", "sign_gare", "sign_cary", "sign_cases", "sign_cature", "sign_abias", "sign_biias", "sign_biases", "sign_binding", "sign_abius", "sign_abature", "sign_bare", "sign_Bare", "sign_bary", "sign_Base", "sign_burius", "sign_blias", "sign_abinding", "sign_abases", "sign_Bases", "sign_burias", "sign_burases"], "near_mv": ["near_mmvm", "near_vmV", "near_vmj", "near_pver", "near_tv", "near_mmvg", "near_mq", "near_Mv", "near_mmv", "near_rh", "near_pb", "near_vmvg", "near_bv", "near_mV", "near_pv", "near_cmvm", "near_bV", "near_rq", "near_Mb", "near_tx", "near_mmx", "near_cmv", "near_mmV", "near_Mver", "near_mmvs", "near_mvs", "near_cmx", "near_rx", "near_cmvs", "near_mmb", "near_vmv", "near_Mf", "near_mb", "near_pf", "near_mj", "near_tvs", "near_cmh", "near_bvg", "near_rv", "near_bj", "near_mx", "near_mmj", "near_mf", "near_mmf", "near_mver", "near_mh", "near_mvm", "near_mvg", "near_cmq", "near_tvm", "near_mmver"], "cnt": ["acrt", "brt", "acct", "bnc", "acnt", "lcrt", "crt", "lcct", "bct", "acnc", "cnc", "lcnt", "cct", "bnt", "lcnc"], "c": ["g", "chain", "f", "xc", "cs", "nc", "cil", "connection", "bc", "ca", "a", "d", "h", "p", "arc", "b", "cell", "cy", "cm", "cu", "con", "cc", "C", "dc", "ch", "cv", "r", "t", "channel", "l", "cf", "conn", "ci", "sc", "u", "w", "m", "e", "n", "cn", "mc", "lc", "uc", "jc"]}}
{"project": "qemu", "commit_id": "29851ee7c8bd3fb8542e21cd0270c73132590350", "target": 1, "func": "int main()\n\n{\n\n    int rd, rt, dsp;\n\n    int result, resultdsp;\n\n\n\n    rt        = 0x12345678;\n\n    result    = 0xA000C000;\n\n    resultdsp = 1;\n\n\n\n    __asm\n\n        (\"shll.ph %0, %2, 0x0B\\n\\t\"\n\n         \"rddsp %1\\n\\t\"\n\n         : \"=r\"(rd), \"=r\"(dsp)\n\n         : \"r\"(rt)\n\n        );\n\n    dsp = (dsp >> 22) & 0x01;\n\n    assert(dsp == resultdsp);\n\n    assert(rd  == result);\n\n\n\n    return 0;\n\n}\n", "idx": 8209, "substitutes": {"rd": ["rect", "rw", "src", "hr", "RD", "ref", "RM", "xd", "td", "rg", "mr", "erd", "RT", "dr", "ru", "rss", "lr", "rc", "rl", "rf", "ds", "rn", "nd", "ld", "rod", "rb", "dd", "rx", "r", "std", "cr", "RR", "rm", " dr", "rid", "rs", "rr", "rh", "fd", "dra", "RF"], "rt": ["rect", "tr", "dat", "fr", "src", "ptr", "vt", "err", "RD", "ref", "th", "rat", "td", "RT", "dist", "art", "dr", "rc", "ru", "ri", "pr", "rl", "rf", "rn", "ct", "vr", "test", "rb", "gt", "rx", "r", "ret", "std", "attr", "error", "RR", "rm", "rs", "rid", "rr", "rh", "nt"], "dsp": ["adsp", "adSp", "dsc", "ldsc", "Dst", "fdst", "dst", "dp", "adsl", "ldst", "fdsc", "Dsl", "ndp", "dSp", "rsp", "rst", "ldSp", "ldsp", "dSP", "dsh", "adst", " dsh", "rSP", "ndsp", "ndSP", " dSP", "fdsh", "Dsp", "adsh", "fdsp", "adsc", "dsl", " dsc", " dst", "adp", "ldp", "ndst", "rp", " dsl", "Dp", " dp", " dSp", "Dsc"], "result": ["rect", "tr", "match", "Result", "err", "success", "ver", "score", "db", "round", "sr", "feature", "ru", "rc", "ri", "response", "order", "rf", "der", "results", "range", "runner", "replace", "test", "rule", "rb", "array", "record", "parent", "rx", "r", "df", "error", "resource", "ret", "cr", "desc", "report", "rh", "rr", "root", "rest", "var", "res", "rar", "data"], "resultdsp": ["matchdsp", "resultDsr", "matchDpe", " resultfst", "resultDsp", "resultdsh", "matchdpe", "matchDsp", " resultDisp", "resultDsh", "resultdst", "matchDsr", "resultdsc", " resultdsc", "resultpdisp", "resultadst", " resultdst", "resultadisp", "resultDpe", "resultdisp", "resultDsl", "resultfsl", "resultadsl", "resultpdsp", "resultDisp", " resultfsl", "matchdsh", " resultDsc", "resultDsc", "matchDsh", " resultDsp", " resultfsp", "resultfst", "resultidsr", "matchdsr", "resultadsc", " resultdsl", " resultDsl", "resultpdsl", "resultdsl", "resultfsp", "resultidsh", "resultpdsc", "resultidsp", "resultidpe", "resultdpe", "resultdsr", " resultdisp", "resultadsp"]}}
{"project": "FFmpeg", "commit_id": "eb24fd64589b7eea91fa752861f0c6f07e5a48a8", "target": 0, "func": "int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)\n\n{\n\n    int count, x;\n\n    uint8_t *out;\n\n\n\n    out = outbuf;\n\n\n\n\n\n        for(x = 0; x < w; x += count) {\n\n            /* see if we can encode the next set of pixels with RLE */\n\n            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {\n\n                if(out + bpp + 1 > outbuf + out_size) return -1;\n\n                *out++ = (count ^ xor) + add;\n\n                memcpy(out, ptr, bpp);\n\n                out += bpp;\n\n            } else {\n\n                /* fall back on uncompressed */\n\n                count = count_pixels(ptr, w-x, bpp, 0);\n\n                *out++ = count - 1;\n\n\n\n                if(out + bpp*count > outbuf + out_size) return -1;\n\n                memcpy(out, ptr, bpp * count);\n\n                out += bpp * count;\n\n        }\n\n\n\n        ptr += count * bpp;\n\n    }\n\n\n\n    return out - outbuf;\n\n}\n", "idx": 8211, "substitutes": {"outbuf": ["Outbuffer", "outerbuf", "Outqueue", "outputbuffer", " outfile", " outcb", "offcb", "tempbuf", "Outuf", "againbuffer", " outuf", "offuf", "bitbuffer", "inbuffer", "outfile", "outputbuff", " outbuffer", " outfac", "upcb", " outqueue", "tempqueue", "againcb", "outbuffer", "offbuffer", "Outbuf", "tempuf", "outerfile", "inbuff", "inbuf", "bitbuf", "infile", "upfac", "tempbuffer", " outbuff", "incb", "outuf", "againbuf", "outerbuff", "outputbuf", "outfac", "bitcb", "offbuf", "outputcb", "upbuffer", "outbuff", "bitfac", "againuf", "outcb", "outerbuffer", "upbuf", "outqueue"], "out_size": ["in_shape", "out64shape", "outlogsize", "image_space", "in_size", "image_length", "out_uri", "image_scale", "in_address", "out__max", "out64address", "image_size", "out_length", "outlogshape", "out__scale", "out_shape", "out_space", "out__length", "image_max", "out__space", "out_scale", "image_uri", "out_max", "out64size", "out_address", "outlogaddress", "out__uri", "out__size"], "ptr": ["tr", "shift", "pos", "ctr", "rw", "up", "ctx", "pointer", "Ptr", "src", "mount", "buf", "ref", "err", "proc", "addr", "depth", "pc", "cmp", "patch", "dr", "rc", "pr", "p", "per", "cur", "temp", "offset", "sh", "loc", "plug", "pair", "ext", "pt", "pre", "address", "code", "fp", "tmp", "trace", "ch", "ind", "alloc", "length", "r", "attr", "br", "later", "req", "tty", "inter", "pp", "buffer", "pad", "port", "xp", "pty", "inst", "slice", "str"], "bpp": ["lmp", "bpper", " bpar", "sbppa", "lbpar", "bpc", "lbpc", "cpp", "fpl", "npl", "bsp", "bact", "wbpps", "bep", "rep", "lbcp", "sbact", "lpper", "ppp", " bpo", "lpp", "cupp", "brpped", "abcp", "rppa", "lupp", "pep", "pact", " bpc", "fupp", "sbpp", " bact", "hep", "lbpo", "hpl", "ppped", "rpp", "abpped", "bppa", "nsp", "barpp", "bapo", "brupp", "pppa", "wbupp", "nppa", "dbpp", "bapc", " bsp", "bbep", "bmp", " bupp", "brpp", "rpl", "bbpp", " bppa", "psp", "barppa", " bpps", "dbupp", "sbsp", "dbpo", "bapp", "bcp", "bbmp", "bbpper", "bpo", "abpar", "brppa", "wbpp", "wbppa", " bpped", "abpp", "lpped", "bpps", "fpo", "dbpl", "bpl", "hpp", "pupp", "lep", "lbpp", "brpper", "npp", "cep", "hppa", "lbpped", "ppl", " bpl", "bpar", "bupp", "barpps", "bpped", "barupp", "bapped", "brmp", " bcp", "fpp", "brep", "cpped"], "w": ["g", "wal", "wd", "hw", "f", "we", "max", "sw", "wx", "o", "y", "c", "a", "d", "h", "p", "temp", "b", "work", "kw", "wl", "z", "v", "ww", "r", "t", "aw", "wp", "win", "l", "wu", "q", "ew", "u", "wt", "wa", "ow", "m", "n", "fw", "iw", "wb", "s", "window", "W"], "add": ["shift", "pos", "append", "ack", "att", "added", "diff", "max", "ADD", "plus", "comp", "addr", "c", "len", "en", "d", "mod", "arr", "app", "load", "Add", "end", "address", "ac", "push", "inc", "ind", "read", "apply", "call", "start", "pad", "last", "mult", "init", "ad", "each", "extra", "mix", "sum"], "xor": ["xors", "Xnor", "xore", "yor", "XOR", "exors", "xr", "xtr", " xOR", " xore", "exore", "exr", "exor", "xnor", "yOR", "Xor", " xors", "xtore", "Xors", "ynor", "xOR", "xtor", " xnor", "xtors", " xr", "yors"], "count": ["max", "ref", "Count", "c", "i", "d", "b", "con", "missing", "cc", "key", "ch", "all", "time", "q", "e", "child", "ount", "depth", "sum", "size", "id", "weight", "h", "cat", "z", "code", "coll", "parent", "num", "length", "call", "base", "list", "f", "y", "len", "part", "v", "ind", "l", "start", "index", "cond", "current", "name", "number", "find", "cast", "type", "match", "found", "p", "offset", "ct", "act", "ac", "filter", "scroll", "val", "col", "n", "process", "cd", "counter", "check", "cache"], "x": ["ax", "ctx", "f", "on", "id", "xc", "sw", "xes", "plus", "wx", "xs", "y", "min", "c", "X", "ex", "i", "en", "d", "h", "p", "content", "b", "px", "j", "ct", "pair", "bit", "z", "v", "code", "xi", "pe", "ww", "in", "rx", "t", "r", "el", "val", "call", "u", "index", "xx", "dx", "m", "wa", "fx", "tx", "xt", "n", "e", "xp", "s", "ix"], "out": ["at", "max", "err", "connection", "byte", "c", "ex", "a", "b", "cmd", "word", "init", "child", "page", "extra", "sum", "line", "up", " in", "OUT", "update", "result", "user", "off", "doc", "code", "op", "parent", "copy", "o", "error", "bin", "call", "conn", "base", "prefix", "block", "att", "diff", "again", "part", "in", "v", "r", "req", "point", "sync", "index", "name", "g", "no", "pool", "output", "wx", "co", "cache", "new", "p", "temp", "work", "ext", "bit", "tmp", "ac", "image", "client", "inc", "t", "buffer", "obj", "n", "data", "Out"]}}
{"project": "FFmpeg", "commit_id": "cbbb2067341d7c2d98f560f81c6fb103af33a490", "target": 1, "func": "static int vdpau_frames_init(AVHWFramesContext *ctx)\n\n{\n\n    VDPAUDeviceContext *device_priv = ctx->device_ctx->internal->priv;\n\n    VDPAUFramesContext        *priv = ctx->internal->priv;\n\n\n\n    int i;\n\n\n\n    switch (ctx->sw_format) {\n\n    case AV_PIX_FMT_YUV420P: priv->chroma_type = VDP_CHROMA_TYPE_420; break;\n\n    case AV_PIX_FMT_YUV422P: priv->chroma_type = VDP_CHROMA_TYPE_422; break;\n\n    case AV_PIX_FMT_YUV444P: priv->chroma_type = VDP_CHROMA_TYPE_444; break;\n\n    default:\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported data layout: %s\\n\",\n\n               av_get_pix_fmt_name(ctx->sw_format));\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(vdpau_pix_fmts); i++) {\n\n        if (vdpau_pix_fmts[i].chroma_type == priv->chroma_type) {\n\n            priv->chroma_idx  = i;\n\n            priv->pix_fmts    = device_priv->pix_fmts[i];\n\n            priv->nb_pix_fmts = device_priv->nb_pix_fmts[i];\n\n            break;\n\n        }\n\n    }\n\n    if (!priv->pix_fmts) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported chroma type: %d\\n\", priv->chroma_type);\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (!ctx->pool) {\n\n        ctx->internal->pool_internal = av_buffer_pool_init2(sizeof(VdpVideoSurface), ctx,\n\n                                                            vdpau_pool_alloc, NULL);\n\n        if (!ctx->internal->pool_internal)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    priv->get_data = device_priv->get_data;\n\n    priv->put_data = device_priv->put_data;\n\n\n\n    return 0;\n\n}\n", "idx": 8217, "substitutes": {"ctx": ["cas", "ga", "hw", "ocr", "Context", "xc", "anc", "cs", "nc", "cdn", "cz", "voc", "bc", "wcs", "vc", "ce", "c", "cci", "media", "pc", "ca", "cmp", "auc", "concept", "conv", "co", "config", "cb", "kb", "ck", "sci", "pkg", "loc", "qa", "cm", "cp", "cu", "ct", "ctrl", "kw", "context", " context", "cc", "cli", "act", "coll", "cv", "cms", "client", "parent", "mac", "cmd", "ci", "cf", "conn", "sc", "cus", "sync", "cam", "conf", "tx", "crit", "cn", "tc", "sys", "lc", "cca", "gc", "exec", "acl"], "device_priv": ["devicePpub", "devicealpriv", "deviceJprivate", "device_neg", "device_public", " device_public", "package_private", "device_pub", " device_access", " device_data", "deviceingpub", "deviceingpublic", " device_riv", "package_neg", "device_access", "device_private", "deviceJcert", "device_cert", "device_riv", "deviceJneg", "devicealpub", "deviceCprivate", "devicealsize", "devicealdat", " device_pub", "deviceCpublic", " device_size", " device_dat", "deviceJpriv", "deviceingpriv", "devicePpriv", "deviceCaccess", " device_private", "package_cert", "deviceCpriv", "device_size", "deviceingriv", "devicePdata", "package_priv", "devicePprivate", "device_dat", "device_data"], "priv": ["rw", "comment", "err", "cs", "rc", "fee", "gb", "neg", "Priv", "aud", "ch", "ci", "buff", "gr", "org", "info", "or", "rib", "txt", "consumer", "prop", "pub", "pro", "api", "voc", "raf", "public", "por", "sta", "fac", "impl", "coll", "alloc", "attr", "conn", "allow", "progress", "sec", "pred", "rate", "exec", "prem", "tr", "ptr", "vt", "typ", "vc", "pb", "ki", "stat", "ca", "config", "auth", "usa", "kw", "cfg", "prof", "ee", "req", "util", "sk", "mini", "ocr", "anc", "state", "fam", "proc", "private", "auc", "cb", "p", "temp", "cy", "pri", "pi", "cp", "inner", "soc", "access", "client", "prep", "roc", "reader", "cer", "dev", "conf", "ty", "tx", "storage", "uc", "riv", "cert", "data", "cache"], "i": ["ii", "idi", "li", "uri", "hi", "block", "f", "type", "id", "phi", "I", "diff", "k", "mu", "api", "ip", "oi", "mi", "fi", "chi", "adi", "y", "c", "yi", "iu", "ini", "d", "multi", "ri", "p", "slice", "temp", "ji", "si", "b", "pi", "io", "j", "gi", "ie", "cli", "di", "ti", "v", "in", "bi", "code", "ind", "t", "ui", "xi", "qi", "o", "l", "ci", "esi", "zi", "index", "u", "start", "m", "e", "n", "info", "ai", "lc", "s", "count", "x", "it"]}}
{"project": "qemu", "commit_id": "74892d2468b9f0c56b915ce94848d6f7fac39740", "target": 1, "func": "int vm_stop(RunState state)\n\n{\n\n    if (qemu_in_vcpu_thread()) {\n\n\n        qemu_system_vmstop_request(state);\n\n        /*\n\n         * FIXME: should not return to device code in case\n\n         * vm_stop() has been requested.\n\n         */\n\n        cpu_stop_current();\n\n        return 0;\n\n    }\n\n\n\n    return do_vm_stop(state);\n\n}", "idx": 8221, "substitutes": {"state": ["parse", "type", "f", "id", "request", "self", "class", "states", "STATE", "c", "al", "instance", "i", "cache", "config", "p", "ace", "si", "scope", "session", "use", "j", "style", "part", "State", "rule", "se", "address", "code", "parent", "resource", "l", "call", "start", "m", "e", "this", "info", "er", "port", "statement", "s", "name", "status", "grade", "data", "slice", "str"]}}
{"project": "FFmpeg", "commit_id": "801c39e1e3058fc4ba822bfb5d8612d777111e32", "target": 0, "func": "static int dca_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    AVFrame *frame     = data;\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n\n\n    int lfe_samples;\n\n    int num_core_channels = 0;\n\n    int i, ret;\n\n    float  **samples_flt;\n\n    DCAContext *s = avctx->priv_data;\n\n    int channels, full_channels;\n\n    int core_ss_end;\n\n\n\n\n\n    s->xch_present = 0;\n\n\n\n    s->dca_buffer_size = ff_dca_convert_bitstream(buf, buf_size, s->dca_buffer,\n\n                                                  DCA_MAX_FRAME_SIZE + DCA_MAX_EXSS_HEADER_SIZE);\n\n    if (s->dca_buffer_size == AVERROR_INVALIDDATA) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Not a valid DCA frame\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    init_get_bits(&s->gb, s->dca_buffer, s->dca_buffer_size * 8);\n\n    if ((ret = dca_parse_frame_header(s)) < 0) {\n\n        //seems like the frame is corrupt, try with the next one\n\n        return ret;\n\n    }\n\n    //set AVCodec values with parsed data\n\n    avctx->sample_rate = s->sample_rate;\n\n    avctx->bit_rate    = s->bit_rate;\n\n\n\n    s->profile = FF_PROFILE_DTS;\n\n\n\n    for (i = 0; i < (s->sample_blocks / 8); i++) {\n\n        if ((ret = dca_decode_block(s, 0, i))) {\n\n            av_log(avctx, AV_LOG_ERROR, \"error decoding block\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* record number of core channels incase less than max channels are requested */\n\n    num_core_channels = s->prim_channels;\n\n\n\n    if (s->ext_coding)\n\n        s->core_ext_mask = dca_ext_audio_descr_mask[s->ext_descr];\n\n    else\n\n        s->core_ext_mask = 0;\n\n\n\n    core_ss_end = FFMIN(s->frame_size, s->dca_buffer_size) * 8;\n\n\n\n    /* only scan for extensions if ext_descr was unknown or indicated a\n\n     * supported XCh extension */\n\n    if (s->core_ext_mask < 0 || s->core_ext_mask & DCA_EXT_XCH) {\n\n\n\n        /* if ext_descr was unknown, clear s->core_ext_mask so that the\n\n         * extensions scan can fill it up */\n\n        s->core_ext_mask = FFMAX(s->core_ext_mask, 0);\n\n\n\n        /* extensions start at 32-bit boundaries into bitstream */\n\n        skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31);\n\n\n\n        while (core_ss_end - get_bits_count(&s->gb) >= 32) {\n\n            uint32_t bits = get_bits_long(&s->gb, 32);\n\n\n\n            switch (bits) {\n\n            case 0x5a5a5a5a: {\n\n                int ext_amode, xch_fsize;\n\n\n\n                s->xch_base_channel = s->prim_channels;\n\n\n\n                /* validate sync word using XCHFSIZE field */\n\n                xch_fsize = show_bits(&s->gb, 10);\n\n                if ((s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize) &&\n\n                    (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize + 1))\n\n                    continue;\n\n\n\n                /* skip length-to-end-of-frame field for the moment */\n\n                skip_bits(&s->gb, 10);\n\n\n\n                s->core_ext_mask |= DCA_EXT_XCH;\n\n\n\n                /* extension amode(number of channels in extension) should be 1 */\n\n                /* AFAIK XCh is not used for more channels */\n\n                if ((ext_amode = get_bits(&s->gb, 4)) != 1) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"XCh extension amode %d not\"\n\n                           \" supported!\\n\", ext_amode);\n\n                    continue;\n\n                }\n\n\n\n                /* much like core primary audio coding header */\n\n                dca_parse_audio_coding_header(s, s->xch_base_channel);\n\n\n\n                for (i = 0; i < (s->sample_blocks / 8); i++)\n\n                    if ((ret = dca_decode_block(s, s->xch_base_channel, i))) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"error decoding XCh extension\\n\");\n\n                        continue;\n\n                    }\n\n\n\n                s->xch_present = 1;\n\n                break;\n\n            }\n\n            case 0x47004a03:\n\n                /* XXCh: extended channels */\n\n                /* usually found either in core or HD part in DTS-HD HRA streams,\n\n                 * but not in DTS-ES which contains XCh extensions instead */\n\n                s->core_ext_mask |= DCA_EXT_XXCH;\n\n                break;\n\n\n\n            case 0x1d95f262: {\n\n                int fsize96 = show_bits(&s->gb, 12) + 1;\n\n                if (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + fsize96)\n\n                    continue;\n\n\n\n                av_log(avctx, AV_LOG_DEBUG, \"X96 extension found at %d bits\\n\",\n\n                       get_bits_count(&s->gb));\n\n                skip_bits(&s->gb, 12);\n\n                av_log(avctx, AV_LOG_DEBUG, \"FSIZE96 = %d bytes\\n\", fsize96);\n\n                av_log(avctx, AV_LOG_DEBUG, \"REVNO = %d\\n\", get_bits(&s->gb, 4));\n\n\n\n                s->core_ext_mask |= DCA_EXT_X96;\n\n                break;\n\n            }\n\n            }\n\n\n\n            skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31);\n\n        }\n\n    } else {\n\n        /* no supported extensions, skip the rest of the core substream */\n\n        skip_bits_long(&s->gb, core_ss_end - get_bits_count(&s->gb));\n\n    }\n\n\n\n    if (s->core_ext_mask & DCA_EXT_X96)\n\n        s->profile = FF_PROFILE_DTS_96_24;\n\n    else if (s->core_ext_mask & (DCA_EXT_XCH | DCA_EXT_XXCH))\n\n        s->profile = FF_PROFILE_DTS_ES;\n\n\n\n    /* check for ExSS (HD part) */\n\n    if (s->dca_buffer_size - s->frame_size > 32 &&\n\n        get_bits_long(&s->gb, 32) == DCA_HD_MARKER)\n\n        dca_exss_parse_header(s);\n\n\n\n    avctx->profile = s->profile;\n\n\n\n    full_channels = channels = s->prim_channels + !!s->lfe;\n\n\n\n    if (s->amode < 16) {\n\n        avctx->channel_layout = dca_core_channel_layout[s->amode];\n\n\n\n        if (s->prim_channels + !!s->lfe > 2 &&\n\n            avctx->request_channel_layout == AV_CH_LAYOUT_STEREO) {\n\n            /*\n\n             * Neither the core's auxiliary data nor our default tables contain\n\n             * downmix coefficients for the additional channel coded in the XCh\n\n             * extension, so when we're doing a Stereo downmix, don't decode it.\n\n             */\n\n            s->xch_disable = 1;\n\n        }\n\n\n\n#if FF_API_REQUEST_CHANNELS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n        if (s->xch_present && !s->xch_disable &&\n\n            (!avctx->request_channels ||\n\n             avctx->request_channels > num_core_channels + !!s->lfe)) {\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#else\n\n        if (s->xch_present && !s->xch_disable) {\n\n#endif\n\n            avctx->channel_layout |= AV_CH_BACK_CENTER;\n\n            if (s->lfe) {\n\n                avctx->channel_layout |= AV_CH_LOW_FREQUENCY;\n\n                s->channel_order_tab = dca_channel_reorder_lfe_xch[s->amode];\n\n            } else {\n\n                s->channel_order_tab = dca_channel_reorder_nolfe_xch[s->amode];\n\n            }\n\n        } else {\n\n            channels = num_core_channels + !!s->lfe;\n\n            s->xch_present = 0; /* disable further xch processing */\n\n            if (s->lfe) {\n\n                avctx->channel_layout |= AV_CH_LOW_FREQUENCY;\n\n                s->channel_order_tab = dca_channel_reorder_lfe[s->amode];\n\n            } else\n\n                s->channel_order_tab = dca_channel_reorder_nolfe[s->amode];\n\n        }\n\n\n\n        if (channels > !!s->lfe &&\n\n            s->channel_order_tab[channels - 1 - !!s->lfe] < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if (s->prim_channels + !!s->lfe > 2 &&\n\n            avctx->request_channel_layout == AV_CH_LAYOUT_STEREO) {\n\n            channels = 2;\n\n            s->output = s->prim_channels == 2 ? s->amode : DCA_STEREO;\n\n            avctx->channel_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n            /* Stereo downmix coefficients\n\n             *\n\n             * The decoder can only downmix to 2-channel, so we need to ensure\n\n             * embedded downmix coefficients are actually targeting 2-channel.\n\n             */\n\n            if (s->core_downmix && (s->core_downmix_amode == DCA_STEREO ||\n\n                                    s->core_downmix_amode == DCA_STEREO_TOTAL)) {\n\n                int sign, code;\n\n                for (i = 0; i < s->prim_channels + !!s->lfe; i++) {\n\n                    sign = s->core_downmix_codes[i][0] & 0x100 ? 1 : -1;\n\n                    code = s->core_downmix_codes[i][0] & 0x0FF;\n\n                    s->downmix_coef[i][0] = (!code ? 0.0f :\n\n                                             sign * dca_dmixtable[code - 1]);\n\n                    sign = s->core_downmix_codes[i][1] & 0x100 ? 1 : -1;\n\n                    code = s->core_downmix_codes[i][1] & 0x0FF;\n\n                    s->downmix_coef[i][1] = (!code ? 0.0f :\n\n                                             sign * dca_dmixtable[code - 1]);\n\n                }\n\n                s->output = s->core_downmix_amode;\n\n            } else {\n\n                int am = s->amode & DCA_CHANNEL_MASK;\n\n                if (am >= FF_ARRAY_ELEMS(dca_default_coeffs)) {\n\n                    av_log(s->avctx, AV_LOG_ERROR,\n\n                           \"Invalid channel mode %d\\n\", am);\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                if (s->prim_channels + !!s->lfe >\n\n                    FF_ARRAY_ELEMS(dca_default_coeffs[0])) {\n\n                    avpriv_request_sample(s->avctx, \"Downmixing %d channels\",\n\n                                          s->prim_channels + !!s->lfe);\n\n                    return AVERROR_PATCHWELCOME;\n\n                }\n\n                for (i = 0; i < s->prim_channels + !!s->lfe; i++) {\n\n                    s->downmix_coef[i][0] = dca_default_coeffs[am][i][0];\n\n                    s->downmix_coef[i][1] = dca_default_coeffs[am][i][1];\n\n                }\n\n            }\n\n            av_dlog(s->avctx, \"Stereo downmix coeffs:\\n\");\n\n            for (i = 0; i < s->prim_channels + !!s->lfe; i++) {\n\n                av_dlog(s->avctx, \"L, input channel %d = %f\\n\", i,\n\n                        s->downmix_coef[i][0]);\n\n                av_dlog(s->avctx, \"R, input channel %d = %f\\n\", i,\n\n                        s->downmix_coef[i][1]);\n\n            }\n\n            av_dlog(s->avctx, \"\\n\");\n\n        }\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"Non standard configuration %d !\\n\", s->amode);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avctx->channels = channels;\n\n\n\n    /* get output buffer */\n\n    frame->nb_samples = 256 * (s->sample_blocks / 8);\n\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n    samples_flt = (float **)frame->extended_data;\n\n\n\n    /* allocate buffer for extra channels if downmixing */\n\n    if (avctx->channels < full_channels) {\n\n        ret = av_samples_get_buffer_size(NULL, full_channels - channels,\n\n                                         frame->nb_samples,\n\n                                         avctx->sample_fmt, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        av_fast_malloc(&s->extra_channels_buffer,\n\n                       &s->extra_channels_buffer_size, ret);\n\n        if (!s->extra_channels_buffer)\n\n            return AVERROR(ENOMEM);\n\n\n\n        ret = av_samples_fill_arrays((uint8_t **)s->extra_channels, NULL,\n\n                                     s->extra_channels_buffer,\n\n                                     full_channels - channels,\n\n                                     frame->nb_samples, avctx->sample_fmt, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    /* filter to get final output */\n\n    for (i = 0; i < (s->sample_blocks / 8); i++) {\n\n        int ch;\n\n\n\n        for (ch = 0; ch < channels; ch++)\n\n            s->samples_chanptr[ch] = samples_flt[ch] + i * 256;\n\n        for (; ch < full_channels; ch++)\n\n            s->samples_chanptr[ch] = s->extra_channels[ch - channels] + i * 256;\n\n\n\n        dca_filter_channels(s, i);\n\n\n\n        /* If this was marked as a DTS-ES stream we need to subtract back- */\n\n        /* channel from SL & SR to remove matrixed back-channel signal */\n\n        if ((s->source_pcm_res & 1) && s->xch_present) {\n\n            float *back_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel]];\n\n            float *lt_chan   = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 2]];\n\n            float *rt_chan   = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 1]];\n\n            s->fdsp.vector_fmac_scalar(lt_chan, back_chan, -M_SQRT1_2, 256);\n\n            s->fdsp.vector_fmac_scalar(rt_chan, back_chan, -M_SQRT1_2, 256);\n\n        }\n\n    }\n\n\n\n    /* update lfe history */\n\n    lfe_samples = 2 * s->lfe * (s->sample_blocks / 8);\n\n    for (i = 0; i < 2 * s->lfe * 4; i++)\n\n        s->lfe_data[i] = s->lfe_data[i + lfe_samples];\n\n\n\n    /* AVMatrixEncoding\n\n     *\n\n     * DCA_STEREO_TOTAL (Lt/Rt) is equivalent to Dolby Surround */\n\n    ret = ff_side_data_update_matrix_encoding(frame,\n\n                                              (s->output & ~DCA_LFE) == DCA_STEREO_TOTAL ?\n\n                                              AV_MATRIX_ENCODING_DOLBY : AV_MATRIX_ENCODING_NONE);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    *got_frame_ptr = 1;\n\n\n\n    return buf_size;\n\n}\n", "idx": 8241, "substitutes": {"avctx": ["avconfig", "avcontext", " avxc", "evctx", "AVctx", "avsci", "avectx", "aircontext", "avcas", "afconfig", "ajctrl", "airsq", "Avctx", "AVxc", "ajcontext", "awcas", "ajcas", "AVlc", "Avxc", "varcontext", "AVcp", "afcas", "avecp", "avecu", " avcontext", "Avcontext", "avlc", "afcp", "avcu", "evconfig", "afconn", "awctrl", "ajctx", "afsci", "avsq", "varctx", "Avconn", "varsci", "aflc", " avconn", "awcontext", "aveconfig", "AVconn", "evcu", "evcontext", "avecontext", "avxc", "afcu", "varsq", "AVcontext", "awctx", "airsci", "avelc", "avctrl", "aveconn", "afsq", "avconn", "evconn", "afctrl", "afctx", "airctx", "afcontext", "avcp"], "data": ["padding", "dat", "pos", "message", "block", "empty", "size", "f", "sample", "device", "Data", "audio", "media", "a", "d", "DATA", "bytes", "p", "content", "input", "primary", "database", "queue", "feed", "open", "array", "memory", "record", "image", "parent", "header", "reader", "o", "da", "length", "start", "next", "buff", "as", "buffer", "body", "pad", "base", "raw", "batch", "ad", "window", "video", "object", "cache"], "got_frame_ptr": ["got_frame2size", "got_frames_pointer", "got_frame64pointer", "got_frame32addr", "got_frames2pointer", "got_frame2ptr", "got_frame_pointer", "got_frame32pointer", "got_frames2ptr", "got_frames2size", "got_frames_ptr", "got_frames2addr", "got_frames_size", "got_frame2pointer", "got_frame64size", "got_frame_addr", "got_frame32size", "got_frame2addr", "got_frame64addr", "got_frame64ptr", "got_frame_size", "got_frame32ptr", "got_frames_addr"], "avpkt": ["avcpct", " avcpkt", "avbct", "avbkt", "affke", "avpacket", "affacket", "avbpka", " avcpct", "avPft", "afpct", "avput", "avpke", "avpKT", "afcpKT", "avcpKT", " avcpft", "avfka", " avpft", "avspkt", "afcpkt", "avfke", "avbpct", "avpft", "avcpke", "avbpkt", " avcpke", "avfacket", "avpka", "afput", "avpct", "avPkt", "afcpct", "afcput", "avspka", "avPut", "avPke", "afpke", "affka", "avcpkt", " avpct", "affkt", "avPKT", "avcpft", " avpke", "avspacket", "afpka", "afpkt", "avbpft", "avPct", "avbpacket", "avbut", "avspke", "afpKT", "afpacket", "avbKT", "avbpke", "avcput", "avfkt"], "frame": ["fr", "block", "setup", "board", "f", "flow", "seq", "config", "iframe", "p", "session", "b", "fb", "object", "image", "row", "def", "frames", "cf", "series", "buffer", "body", "m", "e", "Frame", "window", "slice"], "buf": ["block", "pool", "f", "vec", "bm", "src", "ref", "bc", "bag", "seq", "pb", "conv", "cb", "p", "b", "fb", "queue", "img", "rb", "array", "fp", "cv", "alloc", "br", "uf", "cmd", "buff", "map", "buffer", "pad", "uc", "fd", "batch", "window"], "lfe_samples": [" exe_gones", " exe_nample", " exe_gample", " exe_sannels", " exe_namples", " exe_seannels", " exe_seamples", " exe_seones", " exe_sample", " exe_gamples", " exe_nones", " exe_samples", " exe_nannels", " exe_sones", " exe_seample", " exe_gannels"], "i": ["ii", "idi", "ni", "abi", "li", "uri", "f", "id", "phi", "I", "k", "mu", "ip", "oi", "mi", "fi", "chi", "c", "yi", "ki", "iu", "is", "ini", "multi", "p", "si", "z", "split", "b", "pi", "io", "j", "gi", "part", "di", "v", "ti", "xi", "bi", "zi", "qi", "hi", "ui", "t", "ci", "start", "index", "u", "dim", "base", "n", "info", "ai", "mini", "eni", "uni", "x", "ix", "it"], "ret": ["valid", "pass", "rets", "rt", "f", "att", "match", "resp", "re", "RET", "ref", "err", "rev", "ft", "result", "success", "len", "en", "fab", "sb", "cat", "back", "reset", "arr", "rf", "fun", "lit", "quiet", "flag", "bit", "url", "red", "bot", "mem", "fail", "error", "val", "det", "r", "def", "arg", "reply", "obj", "info", "value", "res", "nt", "reg", "alt", "Ret", "status", "bad", "let"], "samples_flt": ["samples_rfinite", "samples_Flt", "samples_rfls", "samples_finite", "samples_sflt", "samples_sfls", "samples_fls", "samples_Finite", "samples_rfmt", "samples_Fls", "samples_sfmt", "samples_Fmt", "samples_rflt", "samples_sfinite", "samples_fmt"], "s": ["sym", "ctx", "service", "cs", "self", "c", "a", "ks", "d", "sv", "settings", "b", "hs", "css", "gs", "as", "e", "info", "comments", "rs", "js", "vs", "os", "bis", "site", "its", "ls", "ss", "sq", "ins", "params", "sb", "h", "nas", "http", "S", "ds", "session", "fs", "ssl", "ses", "qs", "set", "f", "parts", "sf", "xs", "stat", "services", "sg", "details", "secondary", "sl", "v", "r", "ps", "l", "sync", "sys", "su", "rates", "features", "g", "args", "uns", "is", "new", "es", "p", "ts", "si", "se", "ns", "spec", "us", "t", "plugins", "m", "conf", "n", "sets", "this", "storage", "sa", "ops", "aws"], "channels": ["Chores", "ichords", "Channels", "Chapters", "shapters", "ichores", "chapters", "shores", "ichapters", "chords", "ichannels", "Chords", "shannels", "shords", "chores"], "full_channels": ["full_chategories", "full_Chunks", "full_zannels", "full_hannels", "full_zars", "full_chunks", "full_zategories", "full_hategories", "full_Chategories", "full_Channels", "full_hunks", "full_hars", "full_chars", "full_Chars", "full_zunks"], "core_ss_end": ["core_ssgend", "core_ssgends", "core_ssmnd", "core_ss_nd", "core_rss_nd", "core_rss_ends", "core_rss_end", "core_ss_pend", "core_ss_ends", "core_ssmends", "core_ssmend", "core_ssgpend", "core_rss_pend"]}}
{"project": "qemu", "commit_id": "f74990a5d019751c545e9800a3376b6336e77d38", "target": 0, "func": "static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    const unsigned long *features = cpu->model->features;\n\n    unsigned max_bit = 0;\n\n    S390Feat feat;\n\n\n\n    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);\n\n\n\n    if (test_bit(S390_FEAT_ZARCH, features)) {\n\n        /* z/Architecture is always active if around */\n\n        words[0] = 1ull << (63 - 2);\n\n    }\n\n\n\n    for (feat = find_first_bit(features, S390_FEAT_MAX);\n\n         feat < S390_FEAT_MAX;\n\n         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {\n\n        const S390FeatDef *def = s390_feat_def(feat);\n\n        if (def->type == S390_FEAT_TYPE_STFL) {\n\n            unsigned bit = def->bit;\n\n            if (bit > max_bit) {\n\n                max_bit = bit;\n\n            }\n\n            assert(bit / 64 < MAX_STFL_WORDS);\n\n            words[bit / 64] |= 1ULL << (63 - bit % 64);\n\n        }\n\n    }\n\n\n\n    return max_bit / 64;\n\n}\n", "idx": 8247, "substitutes": {"env": ["fen", "loader", "ctx", "anc", "eng", "ea", "exc", "proc", "engine", "en", "ex", "eu", "qt", "config", "ev", "enc", "net", "queue", "ext", "context", "core", "viron", "environment", "que", "gui", "conn", "forest", "virt", "conf", "e", "init", "ec", "estate", "eni", "manager", "exe", "esp", "cache"], "words": ["cards", "writer", "terms", "cycles", "airs", "devices", "weights", "prev", "wcs", "items", "fields", "games", "rows", "works", "bytes", "cats", "names", "windows", "lines", "blocks", "kw", "pages", "doc", "files", "rules", "wei", "codes", "ms", "css", " keywords", "pieces", "maps", "mac", "wp", "word", "images", "frames", "WOR", "w", "ints", "wh", "Words", "aws", "workers", "docs", "tags", "bits", "strings", "lists", "packs", "comments", "raw", "vs", "W"], "cpu": ["np", "linux", "hw", "ctx", "pool", "nic", "cow", "fi", "proc", "pc", "intel", "pu", "node", "config", "cat", "CPU", "clock", "net", "cp", "core", "fat", "fc", "mem", "mx", "vm", "roc", "platform", "mac", "bench", "gpu", "conn", "cam", "uci", "lu", "lc", "gc", "processor", "performance", "cache"], "features": ["flags", "tests", "cas", "cases", "fn", "faces", "bugs", "format", "events", " Features", "devices", "weights", "values", "fi", "attacks", "items", "fields", "wcs", "games", "feature", "properties", "config", "bytes", "cats", "flows", "ants", "names", "details", "facts", "blocks", "settings", "results", "fs", "reports", "files", "classes", "types", "fc", "spec", "pieces", "Features", "products", "images", "eatures", "frames", "plugins", "pins", "boxes", "workers", "bits", "effects", "nets", "issues", "packs", "stats", "ports", "ops"], "feat": ["ann", "rt", "seq", "mat", "fe", "art", "ant", "category", "wit", "nat", "word", "win", "form", "fw", "info", "nt", "month", "mot", "cas", "prop", "fn", "feature", "cat", "lit", "doc", "test", "butt", " feature", "miss", "flags", "ctr", "man", "f", "format", "apt", "lat", "concept", "config", "step", "part", "fc", "aug", "cept", "fit", "crit", "lc", "bug", "type", "vec", "proc", "fi", "hit", "ft", "tag", "ct", "bit", "feed", "piece", "fat", "act", "gt", "spec", "af", "val", "opt", "eat", "col", "func", "circ", "fd", "data", "fact"], "def": ["de", "f", "vec", "diff", "ref", "fam", "fi", "aux", "dom", "raf", "ra", "feature", "eval", "fun", "definition", "lit", "gen", "doc", "feed", "part", "act", "spec", "dc", "Def", "DEF", "df", "da", "val", "cl", "ret", "req", "cf", "af", "dev", "form", "cond", "defined", "desc", "conf", "decl", "define", "ef"]}}
{"project": "qemu", "commit_id": "185b43386ad999c80bdc58e41b87f05e5b3e8463", "target": 0, "func": "static int nbd_establish_connection(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    int sock;\n\n    int ret;\n\n    off_t size;\n\n    size_t blocksize;\n\n\n\n    if (s->host_spec[0] == '/') {\n\n        sock = unix_socket_outgoing(s->host_spec);\n\n    } else {\n\n        sock = tcp_socket_outgoing_spec(s->host_spec);\n\n    }\n\n\n\n    /* Failed to establish connection */\n\n    if (sock < 0) {\n\n        logout(\"Failed to establish connection to NBD server\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    /* NBD handshake */\n\n    ret = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size,\n\n                                &blocksize);\n\n    if (ret < 0) {\n\n        logout(\"Failed to negotiate with the NBD server\\n\");\n\n        closesocket(sock);\n\n        return -errno;\n\n    }\n\n\n\n    /* Now that we're connected, set the socket to be non-blocking and\n\n     * kick the reply mechanism.  */\n\n    socket_set_nonblock(sock);\n\n    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,\n\n                            nbd_have_request, NULL, s);\n\n\n\n    s->sock = sock;\n\n    s->size = size;\n\n    s->blocksize = blocksize;\n\n\n\n    logout(\"Established connection with NBD server\\n\");\n\n    return 0;\n\n}\n", "idx": 8254, "substitutes": {"bs": ["os", "bos", "cs", "ls", "state", "ss", "bc", "BS", "pb", "is", "Bs", "lb", "ks", "ins", "sb", "es", "ts", "cb", "iss", "ds", "b", "blocks", "fs", "bh", "gb", "ns", "ms", "bi", "bb", "ps", "ses", "gs", "as", "rs", "obs", "sa", "vs", "aws"], "s": ["server", "g", "os", "sym", "f", "args", "site", "service", "its", "cs", "ls", "state", "sf", "ss", "states", "xs", "c", "sq", "is", "i", "ks", "ins", "sv", "services", "sb", "params", "es", "new", "p", "ts", "sg", "si", "S", "session", "b", "settings", "ds", "ssl", "http", "fs", "socket", "sl", "ns", "v", "spec", "t", "o", "ps", "ses", "qs", "l", "sync", "plugins", "gs", "w", "m", "conf", "e", "n", "sets", "sys", "rs", "storage", "sa", "js", "stats", "aws"], "sock": ["sidock", "mysocket", "hsocket", "nsocket", "sidix", "mysock", "jscp", "sslink", "nsess", "inock", "insockets", "jsocket", "setsocket", "wsocks", "setsix", "SOCK", "seth", "csocked", "setsock", "mysink", "insocket", "sidocket", "wscp", "opensock", "sslock", "pink", "opensocked", "seseth", "pocked", "Sink", "pocket", "sslsocket", "nsink", "sockets", "hsock", "bsock", "opensocks", "jsocks", "insock", "sOCK", "sess", "ssocket", "scp", "dsockets", "Socket", "sesock", "pocks", " sink", "dsock", "sslocket", "csocket", "insink", "socket", "focket", "wsocket", "nsock", "bsocket", "sink", "bsockets", "opensocket", "myseth", "six", "jsock", "hsocks", "csock", "hsink", "sidocked", "sesocks", "sesink", "Sock", "bsink", "dsocket", "inocket", "wsock", "socks", " socket", "wsink", "fock", "dsink", "sesocket", "fess", "inssocket", " sess", "wsOCK", "csocks", " socks", "socked", "setsocked", "inink", "pock", "fink"], "ret": ["ne", "sur", "usr", "no", "rets", "rt", "att", "nr", "resp", "re", "RET", "ref", "err", "rev", "result", "success", "len", "en", "sr", " Ret", "rc", "cat", "back", "ner", "fun", "flag", "bit", "mt", "rb", "code", "mem", "num", "opt", "val", "det", "def", "conn", "bf", "arg", "reply", "obj", "res", "nt", "out", "reg", "alt", "Ret", "status", "str"], "size": ["server", "sized", "timeout", "message", "SIZE", "capacity", "empty", "args", "mode", "sent", "izes", "len", "close", "en", "small", "bytes", "offset", "password", "fee", "si", "loc", "extra", "use", "shape", "position", "core", "scale", "ize", "address", "code", "Size", "length", "export", "complete", "sync", "body", "sn", "iz", "speed", "security", "storage", "large", "six", "name", "stream", "grade", "send", "data", "count", "number"], "blocksize": ["blockssize", "framesized", "blocksizer", "bitsizing", "locksize", "framesize", "locksizing", "locksizes", "lockssize", "bsizer", "quartersize", "outsized", "outsize", "minsizer", "blocksiz", "filessize", "blockize", "blocksizes", "bitsizer", "blocksized", " blocksizer", "filesizes", "bsiz", "minsization", "outsization", "blockiz", "filesizing", "bitssize", "minsize", "framesization", "locksization", "filesize", "quarterssize", "blockizer", "bitsized", "bitsize", "quartersization", " blocksiz", "bsize", "quartersized", "bitsizes", "outsizer", "minsized", " blockssize", "locksized", "blocksization", "bitsization", "framessize", "blocksizing", "bssize"]}}
{"project": "FFmpeg", "commit_id": "b52b398c30a729dda38c0dd5a0cdeef160c4ca54", "target": 0, "func": "static av_cold int vc2_encode_init(AVCodecContext *avctx)\n\n{\n\n    Plane *p;\n\n    SubBand *b;\n\n    int i, j, level, o, shift;\n\n    const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    const int depth = fmt->comp[0].depth;\n\n    VC2EncContext *s = avctx->priv_data;\n\n\n\n    s->picture_number = 0;\n\n\n\n    /* Total allowed quantization range */\n\n    s->q_ceil    = DIRAC_MAX_QUANT_INDEX;\n\n\n\n    s->ver.major = 2;\n\n    s->ver.minor = 0;\n\n    s->profile   = 3;\n\n    s->level     = 3;\n\n\n\n    s->base_vf   = -1;\n\n    s->strict_compliance = 1;\n\n\n\n    s->q_avg = 0;\n\n    s->slice_max_bytes = 0;\n\n    s->slice_min_bytes = 0;\n\n\n\n    /* Mark unknown as progressive */\n\n    s->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) ||\n\n                      (avctx->field_order == AV_FIELD_PROGRESSIVE));\n\n\n\n    for (i = 0; i < base_video_fmts_len; i++) {\n\n        const VC2BaseVideoFormat *fmt = &base_video_fmts[i];\n\n        if (avctx->pix_fmt != fmt->pix_fmt)\n\n            continue;\n\n        if (avctx->time_base.num != fmt->time_base.num)\n\n            continue;\n\n        if (avctx->time_base.den != fmt->time_base.den)\n\n            continue;\n\n        if (avctx->width != fmt->width)\n\n            continue;\n\n        if (avctx->height != fmt->height)\n\n            continue;\n\n        if (s->interlaced != fmt->interlaced)\n\n            continue;\n\n        s->base_vf = i;\n\n        s->level   = base_video_fmts[i].level;\n\n        break;\n\n    }\n\n\n\n    if (s->interlaced)\n\n        av_log(avctx, AV_LOG_WARNING, \"Interlacing enabled!\\n\");\n\n\n\n    if ((s->slice_width  & (s->slice_width  - 1)) ||\n\n        (s->slice_height & (s->slice_height - 1))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is not a power of two!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if ((s->slice_width > avctx->width) ||\n\n        (s->slice_height > avctx->height)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is bigger than the image!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (s->base_vf <= 0) {\n\n        if (avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n\n            s->strict_compliance = s->base_vf = 0;\n\n            av_log(avctx, AV_LOG_WARNING, \"Disabling strict compliance\\n\");\n\n        } else {\n\n            av_log(avctx, AV_LOG_WARNING, \"Given format does not strictly comply with \"\n\n                   \"the specifications, please add a -strict -1 flag to use it\\n\");\n\n            return AVERROR_UNKNOWN;\n\n        }\n\n    } else {\n\n        av_log(avctx, AV_LOG_INFO, \"Selected base video format = %i (%s)\\n\",\n\n               s->base_vf, base_video_fmts[s->base_vf].name);\n\n    }\n\n\n\n    /* Chroma subsampling */\n\n    avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift);\n\n\n\n    /* Bit depth and color range index */\n\n    if (depth == 8 && avctx->color_range == AVCOL_RANGE_JPEG) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 1;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 8 && (avctx->color_range == AVCOL_RANGE_MPEG ||\n\n               avctx->color_range == AVCOL_RANGE_UNSPECIFIED)) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 2;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 10) {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 3;\n\n        s->diff_offset = 512;\n\n    } else {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 4;\n\n        s->diff_offset = 2048;\n\n    }\n\n\n\n    /* Planes initialization */\n\n    for (i = 0; i < 3; i++) {\n\n        int w, h;\n\n        p = &s->plane[i];\n\n        p->width      = avctx->width  >> (i ? s->chroma_x_shift : 0);\n\n        p->height     = avctx->height >> (i ? s->chroma_y_shift : 0);\n\n        if (s->interlaced)\n\n            p->height >>= 1;\n\n        p->dwt_width  = w = FFALIGN(p->width,  (1 << s->wavelet_depth));\n\n        p->dwt_height = h = FFALIGN(p->height, (1 << s->wavelet_depth));\n\n        p->coef_stride = FFALIGN(p->dwt_width, 32);\n\n        p->coef_buf = av_malloc(p->coef_stride*p->dwt_height*sizeof(dwtcoef));\n\n        if (!p->coef_buf)\n\n            goto alloc_fail;\n\n        for (level = s->wavelet_depth-1; level >= 0; level--) {\n\n            w = w >> 1;\n\n            h = h >> 1;\n\n            for (o = 0; o < 4; o++) {\n\n                b = &p->band[level][o];\n\n                b->width  = w;\n\n                b->height = h;\n\n                b->stride = p->coef_stride;\n\n                shift = (o > 1)*b->height*b->stride + (o & 1)*b->width;\n\n                b->buf = p->coef_buf + shift;\n\n            }\n\n        }\n\n\n\n        /* DWT init */\n\n        if (ff_vc2enc_init_transforms(&s->transform_args[i].t,\n\n                                      s->plane[i].coef_stride,\n\n                                      s->plane[i].dwt_height))\n\n            goto alloc_fail;\n\n    }\n\n\n\n    /* Slices */\n\n    s->num_x = s->plane[0].dwt_width/s->slice_width;\n\n    s->num_y = s->plane[0].dwt_height/s->slice_height;\n\n\n\n    s->slice_args = av_calloc(s->num_x*s->num_y, sizeof(SliceArgs));\n\n    if (!s->slice_args)\n\n        goto alloc_fail;\n\n\n\n    /* Lookup tables */\n\n    s->coef_lut_len = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_len));\n\n    if (!s->coef_lut_len)\n\n        goto alloc_fail;\n\n\n\n    s->coef_lut_val = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_val));\n\n    if (!s->coef_lut_val)\n\n        goto alloc_fail;\n\n\n\n    for (i = 0; i < s->q_ceil; i++) {\n\n        uint8_t  *len_lut = &s->coef_lut_len[i*COEF_LUT_TAB];\n\n        uint32_t *val_lut = &s->coef_lut_val[i*COEF_LUT_TAB];\n\n        for (j = 0; j < COEF_LUT_TAB; j++) {\n\n            get_vc2_ue_uint(QUANT(j, ff_dirac_qscale_tab[i]),\n\n                            &len_lut[j], &val_lut[j]);\n\n            if (len_lut[j] != 1) {\n\n                len_lut[j] += 1;\n\n                val_lut[j] <<= 1;\n\n            } else {\n\n                val_lut[j] = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nalloc_fail:\n\n    vc2_encode_end(avctx);\n\n    av_log(avctx, AV_LOG_ERROR, \"Unable to allocate memory!\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 8271, "substitutes": {"avctx": ["navctx", "avalnp", "aircontext", "akbc", "aveloc", "avalloc", "afpkg", "AVbc", "avbc", "avnp", "avalconn", "svbc", "aucmp", "avalwcs", "avkb", "afcli", "AVnp", "evcu", "airwcs", "auctx", "avcca", "afcu", "avepkg", "AVcms", "auconn", "akctx", "svcontext", "avcv", "AVcu", "airlc", "avectx", "aptctx", "akcontext", "navpkg", "navcontext", "afcms", "AVcli", "avsync", "svconn", "aucu", "airsync", "avalcontext", "aptcms", "aflc", "avenp", "AVconn", "avecontext", "avecms", "akcli", "AVcontext", "avelc", "afcv", "svctx", "akcmp", "aptcu", "avconn", "evconn", "afcontext", "AVctx", "aptcontext", "aircv", "AVkb", "avalcms", "avlc", "aucontext", "avloc", "afcca", "avpkg", "aircms", "AVloc", "AVcmp", "afconn", "avekb", "airpkg", "akconn", "avalcv", "afctx", "airctx", "afcmp", "avalsync", "avalcli", "avcmp", "avcontext", "evctx", "avalctx", "afsync", "avecu", "avecli", "avcu", "navkb", "avcms", "avwcs", "afloc", "avcli", "evloc", "evcca", "aveconn", "aucca", "AVpkg", "evcontext", "afwcs"], "p": ["np", "tp", "pb", "c", "pc", "jp", "pu", "lp", "pi", "cp", "hp", "P", "pre", "op", "pe", "t", "gp", "wp", "q", "ap", "pp", "u", "m", "e", "pa", "n", "bp"], "b": ["binary", "f", "nb", "y", "c", "a", "lb", "bar", "cb", "ib", "boot", "gb", "bs", "bd", "rb", "B", "v", "bb", "br", "bin", "l", "ab", "buffer", "base", "bp"], "i": ["ii", "g", "ni", "abi", "li", "uri", "f", "id", "phi", "I", "k", "ip", "oi", "mi", "fi", "chi", "y", "c", "yi", "ki", "iu", "is", "ini", "d", "multi", "ri", "ji", "si", "pi", "io", "inner", "gi", "ie", "part", "in", "z", "zi", "bi", "di", "xi", "qi", "ti", "ui", "ind", "v", "t", "l", "ci", "start", "index", "dim", "m", "e", "n", "info", "ai", "eni", "mini", "name", "depth", "x", "ix", "it"], "j": ["ii", "g", "pos", "li", "k", "note", "uj", "len", "jp", "ji", "jl", "key", "z", "v", "op", "J", "ind", "rel", "l", "q", "m", "ij", "n", "pop", "js", "it"], "level": ["version", "where", "block", "size", "type", "mode", "file", "local", "limit", "weight", "path", "quality", "tag", "low", "len", "vel", "temp", "stage", "order", "loc", "scope", "fl", "full", "style", "position", "scale", "key", "hi", "code", "pe", "levels", "parent", "inc", "layer", "length", "cl", "val", "rel", "time", "count", "sc", "q", "index", "nn", "priority", "height", "col", "lock", "delay", "base", "unit", "profile", "value", "line", "lvl", "name", "role", "grade", "volume", "depth", "str"], "o": ["ii", "oa", "os", "no", "f", "mode", "k", "oo", "oi", "O", "c", "lo", "ol", "offset", "range", "io", "oid", "op", "l", "index", "m", "e", "n"], "shift": ["ii", "ctr", "pos", "size", "src", "ff", "ul", "sup", "jp", "off", "rc", "offset", "cp", "bh", "scale", "P", "op", "ch", "push", "length", "cl", "br", "sort", "col", "top", "depth"], "fmt": ["frwt", "frmn", " fret", " fformat", "lmn", "mMT", " fkt", "forMT", "hilt", " fnt", "frmm", " ftt", "infmt", "Fatt", "formnt", "Fret", "formmt", "Fmm", "frmd", "fret", "infret", "ctm", "frMT", " fmn", "fornm", " fMT", "fmn", "ptm", " fmm", "infatt", "fwt", "formprintf", "Flt", "lwt", "mformat", "frkt", " fwt", "Ftm", "fmd", "fatt", "mprintf", "Fprintf", "pkt", "fnt", "flt", "fnm", "fformat", " flt", "mmt", " fmd", "lformat", "cmt", " fatt", "hrt", "prt", "ftt", "FMT", "frt", "pmt", "htt", "fmm", "lmt", "pilt", "formkt", "filt", "frnt", "infMT", "clt", "hmt", "forformat", "formt", "Fnm", "frprintf", "ptt", "fkt", "Fmd", " frt", "fMT", " fnm", "frformat", "Fmt", "frmt", " filt", "Fkt", "cMT", "pMT", "ftm", "forprintf", " ftm", "Fformat"], "s": ["server", "ctx", "sym", "service", "cs", "self", "c", "a", "ks", "sv", "d", "lines", "settings", "hs", "sites", "gs", "e", "comments", "rs", "strings", "js", "os", "groups", "site", "its", "ls", "ss", "sq", "params", "sb", "S", "ds", "session", "fs", "ssl", "ses", "qs", "f", "parts", "sf", "xs", "services", "sg", "details", "secondary", "v", "r", "ps", "l", "u", "sync", "sys", "su", "features", "g", "sup", "is", "new", "es", "ts", "si", "full", "ns", "spec", "us", "t", "m", "conf", "n", "sets", "storage", "sa", "stats", "data", "ops"]}}
{"project": "FFmpeg", "commit_id": "ebbcdc9ac0ea190748a1605bda86ce84466c8b4e", "target": 0, "func": "void ff_fix_long_b_mvs(MpegEncContext * s, int16_t (*mv_table)[2], int f_code, int type)\n\n{\n\n    int y;\n\n    uint8_t * fcode_tab= s->fcode_tab;\n\n\n\n    // RAL: 8 in MPEG-1, 16 in MPEG-4\n\n    int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code);\n\n\n\n    /* clip / convert to intra 16x16 type MVs */\n\n    for(y=0; y<s->mb_height; y++){\n\n        int x;\n\n        int xy= (y+1)* (s->mb_width+2)+1;\n\n        int i= y*s->mb_width;\n\n        for(x=0; x<s->mb_width; x++)\n\n            {\n\n            if (s->mb_type[i] & type)    // RAL: \"type\" test added...\n\n                {\n\n                if (fcode_tab[mv_table[xy][0] + MAX_MV] > f_code || fcode_tab[mv_table[xy][0] + MAX_MV] == 0)\n\n                    {\n\n                    if(mv_table[xy][0]>0) \n\n                        mv_table[xy][0]=  range-1;\n\n                    else\n\n                        mv_table[xy][0]= -range;\n\n                    }\n\n                if (fcode_tab[mv_table[xy][1] + MAX_MV] > f_code || fcode_tab[mv_table[xy][1] + MAX_MV] == 0)\n\n                    {\n\n                    if(mv_table[xy][1]>0) \n\n                        mv_table[xy][1]=  range-1;\n\n                    else                  \n\n                        mv_table[xy][1]= -range;\n\n            }\n\n            }\n\n            xy++;\n\n            i++;\n\n        }\n\n    }\n\n}\n", "idx": 8273, "substitutes": {"s": ["server", "g", "sym", "f", "bis", "site", "service", "cs", "ls", "self", "sf", "ss", "serv", "sports", "c", "sq", "is", "a", "ks", "services", "d", "sb", "sv", "es", "h", "p", "ts", "sci", "sg", "si", "S", "sie", "b", "ds", "session", "ssl", "http", "se", "sl", "sim", "ns", "less", "spec", "v", "sy", "t", "o", "r", "ses", "qs", "l", "sync", "u", "gs", "w", "m", "conf", "south", "e", "n", "sys", "sets", "su", "sa", "space", "js", "stats"], "mv_table": ["mf_tab", "mvselement", "mvDtable", "mvpbuffer", "mb_key", "mvalltable", "mv_code", "mb_table", "mv_tab", "mv8buffer", "mv2code", "mv__tab", "mv_body", "mv25table", "mb_tab", "mvptab", "mb_header", "mw_cache", "mv__header", "mvvtable", "mf_body", "mv8total", "mb_file", "mv_db", "mv__key", "mf_table", "mw_table", "mb_code", "mv8list", "mv5session", "mvalltab", "mvallfile", "mvallheader", "mv_store", "mv_total", "mf_file", "mv_key", "mv_session", "mv2table", "mv_element", "mv5tab", "mf_db", "mvvtab", "mv25cache", "mw_code", "mv_buffer", "mv2cache", "mb_cache", "mvpcode", "mv25tab", "mvstable", "mvDstore", "mf_element", "mvvcode", "mv_machine", "mf_total", "mb_group", "mf_store", "mvpcache", "mv5table", "mvalllist", "mvsstore", "mw_tab", "mv8machine", "mv_cache", "mf_list", "mb_stable", "mvDtab", "mvDelement", "mvalltotal", "mv25stable", "mf_machine", "mv_header", "mv2tab", "mv_file", "mv5file", "mvptable", "mv_list", "mvpmachine", "mv_stable", "mvstab", "mf_buffer", "mv__table", "mv_group", "mb_session", "mv8table", "mvallkey", "mv8tab", "mv8file", "mvvgroup"], "f_code": ["f_count", " f_length", "c_cell", " f_call", "xianmode", "f_order", " f_order", "fianentry", "f__entry", "f_call", "f_type", "fxorder", "f_codes", "fptype", "x_code", "f_cell", "f__mode", "fpcall", "f__code", "f_address", "f_mode", "fpaddress", "c_code", "fiancode", " f_address", "f_length", "fsyscell", "fpcode", "fxcode", "f__call", "f__type", "fiancase", "c_codes", "fsyscode", "fsyscodes", "fsysbody", "c_body", " f_count", "x_mode", "xianentry", "f__address", "x_entry", "fianmode", "fxlength", " f_type", "xiancase", "f_case", "fxcount", "f_entry", "f_body", "x_case", "xiancode", "f__case"], "type": ["prop", "version", "block", "f", "id", "format", "match", "comment", "ref", "class", "method", "slice", "p", "offset", "Type", "range", "shape", "style", "domain", "TYPE", "key", "code", "target", "length", "t", "time", "kind", "count", "error", "index", "unit", "value", "ype", "name", "role", "typ", "types"], "y": ["zy", "ey", "yy", "f", "yo", "iy", "ky", "ny", "ys", "ya", "c", "yi", "d", "h", "p", "dy", "hy", "vy", "cy", "b", "gy", "j", "yr", "z", "code", "ye", "ay", "ch", "sy", "t", "o", "l", "u", "ym", "sky", "ady", "ry", "height", "m", "w", "ty", "e", "yt", "Y", "py", "oy"], "fcode_tab": ["fcode__tab", "fcod_session", "fcodeettab", "fcode__table", "fcodes_tab", "fcode_table", "fcodevaltab", "fcode_cat", "fcod_cell", "fcod_lab", "fcod_ab", "fcodeOgroup", "fcode_lab", "fcodefbuff", "fcodes_buff", "fcodeettable", "fcodeetcontainer", "fcodeOtable", "fcodeftrack", "fcodeetsession", "fcodeftable", "fcod_cat", "fcod_tab", "fcod_container", "fcod_buff", "fbr_tab", "fcode_session", "fcodes_track", "fcode_group", "fcode_cell", "fcode_col", "fbr_col", "fcodes_table", "fcode_container", "fcod_table", "fcode_track", "fcodeOcat", "fcodeftab", "fcode_ab", "fcodeOtab", "fcod_group", "fcodevalcontainer", "fcodevalsession", "fbr_table", "fcode__cell", "fcodevaltable", "fcode__buff", "fcode_db", "fbr_db", "fcode_buff"], "x": ["ii", "g", "ax", "yx", "f", "on", "id", "c", "X", "ex", "d", "h", "p", "dy", "xxx", "b", "px", "j", "z", "code", "zi", "image", "v", "o", "t", "time", "l", "u", "index", "xx", "dx", "w", "m", "tx", "e", "n", "ix"], "xy": ["zy", "ctx", "yo", "zip", "mi", "note", "oxy", "byte", "ei", "d", "bo", "px", "zh", "gb", "html", "json", "key", "rx", "ui", "time", "xx", "dx", "two", "e", "yt", "info", "txt", "coord", "ii", "live", "wy", "id", "phi", "home", "iter", "h", "xxx", "j", "flat", "ie", "z", "xi", "hi", "code", "parent", "xb", "xxxx", "dt", "yx", "yy", "xf", "f", "lat", "XY", "qa", "xxxxxxxx", "di", "source", "fo", "index", "my", "xp", "py", "phy", "no", "wx", "nb", "quad", "ji", "dy", "temp", "loc", "gy", "vy", "io", "pie", "try", "dj", "axy", "data"], "i": ["ii", "li", "code", "f", "id", "I", "ip", "c", "yi", "iu", "d", "h", "ji", "p", "ri", "si", "b", "pi", "io", "j", "gi", "ie", "key", "z", "hi", "xi", "bi", "zi", "v", "qi", "o", "ui", "ti", "r", "l", "ci", "u", "index", "m", "e", "n", "my", "in", "ix"]}}
{"project": "qemu", "commit_id": "524d18d8bd463431b120eeb5f9f3d1064a1c19e4", "target": 0, "func": "S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)\n\n{\n\n    S390CPU *cpu;\n\n    Error *err = NULL;\n\n\n\n    cpu = cpu_s390x_create(cpu_model, &err);\n\n    if (err != NULL) {\n\n        goto out;\n\n    }\n\n\n\n    object_property_set_int(OBJECT(cpu), core_id, \"core-id\", &err);\n\n    if (err != NULL) {\n\n        goto out;\n\n    }\n\n    object_property_set_bool(OBJECT(cpu), true, \"realized\", &err);\n\n\n\nout:\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        object_unref(OBJECT(cpu));\n\n        cpu = NULL;\n\n    }\n\n    return cpu;\n\n}\n", "idx": 8291, "substitutes": {"cpu_model": ["cpu_base", "core_base", "cpu_models", "cpu_id", "gpu_models", "gpu_id", "core_Model", "core_model", "core_models", "gpu_model", "gpu_Model", "cpu_Model"], "core_id": ["corelicname", " core_ident", " core_name", "coreliccode", "core_type", "corelicid", " core_path", "core_path", " core_code", " core_type", "core_name", "corelictype", "core_code", "core_ident"], "errp": ["rP", "erfp", "errP", "errr", "errfp", "errorfp", "errorp", "erp", "errorP", " errr", " errfp", "errorr", " errP", "erP", "rr", "rp"], "cpu": ["colo", "phy", "np", "hw", "linux", "los", "fork", "ctx", "loader", "nic", " cp", "cow", "nc", "proc", "GPU", "c", "pc", "instance", "lb", "computer", "jp", "pu", "node", "lp", "config", "uca", "cpp", "kernel", "fps", "console", "CPU", "clock", "ck", "boot", "px", "cp", "runner", "frame", "foo", "core", "cli", " CPU", "fp", "fc", "css", "vm", "parent", "roc", "platform", "mac", "gp", "gpu", "conn", "proxy", "lib", "ci", "cmp", "obj", "uci", "cn", "process", "lc", "null", "gc", "python", "uno", "data", "processor", "performance", "cache"], "err": ["ref", "exc", "orer", "mr", "ver", "fe", "rc", "lr", "fee", "orig", "ar", "arm", "rx", "cr", "rm", "org", "gr", "e", "msg", "rs", "ec", "aster", "result", "iter", "norm", "raise", "rn", "doc", "cor", "ise", "error", "acer", "oe", "er", "progress", "out", "rag", "str", "ok", "Error", "resp", "far", "Er", "erer", "ler", "cfg", "r", "br", "req", "ir", "lib", "oller", "sys", "rr", "rh", "orr", "rar", "lc", "bug", "g", "phy", "fr", "fi", "bare", "dr", "erg", "cb", "ner", "order", "arr", "runner", "core", "rb", "inc", "tx", "rage", "cache"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "aio_compute_timeout(AioContext *ctx)\n\n{\n\n    int64_t deadline;\n\n    int timeout = -1;\n\n    QEMUBH *bh;\n\n\n\n    for (bh = atomic_rcu_read(&ctx->first_bh); bh;\n\n         bh = atomic_rcu_read(&bh->next)) {\n\n        if (bh->scheduled) {\n\n            if (bh->idle) {\n\n                /* idle bottom halves will be polled at least\n\n                 * every 10ms */\n\n                timeout = 10000000;\n\n            } else {\n\n                /* non-idle bottom halves will be executed\n\n                 * immediately */\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    deadline = timerlistgroup_deadline_ns(&ctx->tlg);\n\n    if (deadline == 0) {\n\n        return 0;\n\n    } else {\n\n        return qemu_soonest_timeout(timeout, deadline);\n\n    }\n\n}\n", "idx": 8296, "substitutes": {"deadline": ["midlined", "timelin", "deadlining", "DeadLINE", " deadlin", "hotle", "hotline", "midlin", "timeliner", "hotzone", "deadLINE", "timeLINE", "hotliner", "deadlin", "midline", "timezone", "waitliner", "Deadline", "goldline", "waitzone", "timeline", " deadbase", "cmdlin", "costlining", "Deadbase", "costlin", "Deadlined", "deadliner", "midliner", "timebase", "goldliner", "waitline", "costline", "Deadliner", "goldlining", "goldlin", "deadbase", "Deadlin", "deadle", "cmdlined", "cmdliner", "deadlined", "costliner", "timele", "Deadlining", "waitle", " deadLINE", "cmdline", "deadzone"], "bh": ["ph", "timeout", "adh", "ctx", "bm", "src", "ref", "eth", "behavior", "nb", "bc", "pb", "lb", "HB", "sb", "bl", "h", "lr", "cb", "ib", "hab", "bo", "ha", "uh", "BT", "sh", "gh", "b", "hm", "fb", "work", "bg", "bt", "hp", "zh", "hh", "ht", "ah", "hap", "plug", "rb", "bs", "hi", "fp", "hub", "ch", "bi", "bb", "br", "af", "ih", "abb", "conn", "sync", "hl", "body", "dh", "aph", "rh", "bp", "batch", "bf", "kh", "bang", "acl"]}}
{"project": "FFmpeg", "commit_id": "3beb9cbad35218ed1fb3473eeb3cfc97a931bff4", "target": 0, "func": "static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)\n\n{\n\n    int n=0, x, y, i;\n\n\n\n    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));\n\n\n\n    /* Map to the ROQ quadtree order */\n\n    for (y=0; y<enc->height; y+=16)\n\n        for (x=0; x<enc->width; x+=16)\n\n            for(i=0; i<4; i++) {\n\n                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;\n\n                tempData->cel_evals[n++].sourceY = y + (i&2)*4;\n\n            }\n\n}\n", "idx": 8313, "substitutes": {"enc": ["ctr", "orc", "ctx", "xc", "anc", "eng", "nc", "cs", "cdn", "voc", "self", "nec", "vc", "ou", "c", "pc", "en", "ant", "rc", "config", "cur", "temp", "ent", "input", "cy", "ic", "ct", "equ", "context", "env", "iv", "fc", "ac", "dc", "code", "environment", "inc", "coll", "nv", "win", "ENC", "conn", "cel", "ci", "u", "acc", "cod", "current", "emb", "oc", "init", "cn", "ec", "lc", "Enc", "nt"], "tempData": ["writerData", "privateDat", "fakedata", " tempDat", "tempModule", "celModule", " tempInfo", " tempdata", "stableData", "stableDat", "Tempdata", "tempBu", "TempModule", "TempInfo", "celdata", "tempInfo", "celBu", "stabledata", "stableInfo", "tempDat", "fakeData", "privateData", "fakeDat", "celData", "tempdata", "privatedata", "TempData", "TempDat", "writerInfo", "writerDat", " tempBu", "fakeInfo", " tempModule", "writerdata", "TempBu"], "x": ["ax", "yx", "wy", "f", "id", "k", "xs", "ya", "c", "X", "yi", "a", "xy", "ex", "d", "h", "p", "b", "px", "j", "z", "v", "zi", "xi", "hi", "rx", "o", "t", "time", "l", "ci", "q", "u", "index", "xx", "dx", "w", "m", "fx", "tx", "e", "n", "s", "data", "ix"], "y": ["ii", "zy", "ey", "yx", "wy", "yy", "f", "type", "yo", "id", "iy", "ky", "ny", "ys", "ya", "c", "yi", "a", "xy", "d", "h", "p", "dy", "b", "vy", "cy", "ish", "gy", "year", "j", "yr", "z", "v", "ye", "ay", "sy", "o", "t", "l", "u", "ym", "xx", "ry", "w", "ty", "yt", "n", "yl", "Y", "py", "oy"], "i": ["ii", "ni", "li", "uri", "f", "id", "phi", "I", "api", "mu", "ip", "oi", "mi", "fi", "chi", "c", "yi", "iu", "ini", "d", "multi", "ji", "p", "ri", "si", "b", "pi", "io", "j", "ori", "gi", "ie", "cli", "key", "z", "v", "ti", "xi", "zi", "di", "qi", "bi", "ui", "ali", "l", "ci", "u", "index", "m", "e", "n", "info", "ai", "s", "eni", "ix", "it"]}}
{"project": "FFmpeg", "commit_id": "273e6af47b38391f2bcc157cca0423fe7fcbf55c", "target": 0, "func": "static int ea_read_packet(AVFormatContext *s,\n\n                          AVPacket *pkt)\n\n{\n\n    EaDemuxContext *ea = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int ret = 0;\n\n    int packet_read = 0;\n\n    unsigned int chunk_type, chunk_size;\n\n    int key = 0;\n\n    int av_uninit(num_samples);\n\n\n\n    while (!packet_read) {\n\n        chunk_type = avio_rl32(pb);\n\n        chunk_size = (ea->big_endian ? avio_rb32(pb) : avio_rl32(pb)) - 8;\n\n\n\n        switch (chunk_type) {\n\n        /* audio data */\n\n        case ISNh_TAG:\n\n            /* header chunk also contains data; skip over the header portion*/\n\n            avio_skip(pb, 32);\n\n            chunk_size -= 32;\n\n        case ISNd_TAG:\n\n        case SCDl_TAG:\n\n        case SNDC_TAG:\n\n        case SDEN_TAG:\n\n            if (!ea->audio_codec) {\n\n                avio_skip(pb, chunk_size);\n\n                break;\n\n            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR ||\n\n                       ea->audio_codec == CODEC_ID_MP3) {\n\n                num_samples = avio_rl32(pb);\n\n                avio_skip(pb, 8);\n\n                chunk_size -= 12;\n\n            }\n\n            ret = av_get_packet(pb, pkt, chunk_size);\n\n            if (ret < 0)\n\n                return ret;\n\n            pkt->stream_index = ea->audio_stream_index;\n\n\n\n            switch (ea->audio_codec) {\n\n            case CODEC_ID_ADPCM_EA:\n\n            case CODEC_ID_ADPCM_EA_R1:\n\n            case CODEC_ID_ADPCM_EA_R2:\n\n            case CODEC_ID_ADPCM_IMA_EA_EACS:\n\n                pkt->duration = AV_RL32(pkt->data);\n\n                break;\n\n            case CODEC_ID_ADPCM_EA_R3:\n\n                pkt->duration = AV_RB32(pkt->data);\n\n                break;\n\n            case CODEC_ID_ADPCM_IMA_EA_SEAD:\n\n                pkt->duration = ret * 2 / ea->num_channels;\n\n                break;\n\n            case CODEC_ID_PCM_S16LE_PLANAR:\n\n            case CODEC_ID_MP3:\n\n                pkt->duration = num_samples;\n\n                break;\n\n            default:\n\n                pkt->duration = chunk_size / (ea->bytes * ea->num_channels);\n\n            }\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        /* ending tag */\n\n        case 0:\n\n        case ISNe_TAG:\n\n        case SCEl_TAG:\n\n        case SEND_TAG:\n\n        case SEEN_TAG:\n\n            ret = AVERROR(EIO);\n\n            packet_read = 1;\n\n            break;\n\n\n\n        case MVIh_TAG:\n\n        case kVGT_TAG:\n\n        case pQGT_TAG:\n\n        case TGQs_TAG:\n\n        case MADk_TAG:\n\n            key = AV_PKT_FLAG_KEY;\n\n        case MVIf_TAG:\n\n        case fVGT_TAG:\n\n        case MADm_TAG:\n\n        case MADe_TAG:\n\n            avio_seek(pb, -8, SEEK_CUR);     // include chunk preamble\n\n            chunk_size += 8;\n\n            goto get_video_packet;\n\n\n\n        case mTCD_TAG:\n\n            avio_skip(pb, 8);  // skip ea dct header\n\n            chunk_size -= 8;\n\n            goto get_video_packet;\n\n\n\n        case MV0K_TAG:\n\n        case MPCh_TAG:\n\n        case pIQT_TAG:\n\n            key = AV_PKT_FLAG_KEY;\n\n        case MV0F_TAG:\n\nget_video_packet:\n\n            ret = av_get_packet(pb, pkt, chunk_size);\n\n            if (ret < 0)\n\n                return ret;\n\n            pkt->stream_index = ea->video_stream_index;\n\n            pkt->flags |= key;\n\n            packet_read = 1;\n\n            break;\n\n\n\n        default:\n\n            avio_skip(pb, chunk_size);\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 8340, "substitutes": {"s": ["g", "os", "scl", "sd", "sed", "f", "cs", "self", "sf", "ss", "c", "sq", "a", "ks", "i", "an", "sv", "services", "sb", "es", "p", "sg", "si", "sie", "b", "ds", "ssl", "sis", "sl", "se", "v", "spec", "t", "ses", "sc", "sync", "e", "n", "su", "sk", "sa", "space"], "pkt": [" packet", " peth", "copct", "pct", "facket", "cpk", "pk", "packet", "Pct", "fct", "apkt", "Peth", "payct", "copacket", "fkt", " pelt", " pk", "pKT", "Pkg", "Pkt", "spkg", "spacket", " pka", "Packet", "cpkt", " pcht", "pka", "pkg", "lpkt", "cpct", "lpacket", "apacket", " pct", "pcht", " pkg", "cpkg", "PKT", "Pnt", "Pet", "peth", "pnt", " pKT", "pelt", " pnt", "pet", "fet", " pet", "apnt", "payeth", "cpacket", "lpct", "copkt", "lpka", "payacket", "spkt", "Pk", "spelt", "Pcht", "paykt", "copcht", "apKT", "Pka", "Pelt", "cpet"], "ea": ["lda", "ema", "ga", "ata", "ape", "oa", "ni", "aka", "aaaa", "va", "eca", "EA", "anza", "na", "oga", "ra", "za", "ma", "ca", "a", "eva", "au", "ae", "aea", "oda", "aa", "uca", "eu", "ECA", "eb", "SEA", "ace", "ha", "fee", "usa", "sem", "qa", "iana", "nea", "enda", "fa", "di", "ia", "ee", "coe", "da", "esa", "area", "ATA", "ette", "gae", "ica", "oe", "ta", "wa", "ega", "e", "pa", "ena", "ec", "eas", "sa", "eni", "apa", "cca", "sea", "data", "aria", "ba"], "pb": ["plugin", "prop", "np", "pit", "phrase", "pg", "bm", "dp", "pm", "api", "ref", "pl", "typ", "mp", "proc", "ppa", "bc", "rob", "bps", "db", "pc", "jp", "lb", "eb", "lab", "sb", "lp", "pd", "amp", "cpp", "p", "cb", "ib", "pkg", "asm", "b", "plug", "fb", "cp", "mb", "bh", "ub", "gb", "rb", "bs", "kt", "fp", "summary", "hub", "fc", "prot", "tmp", "bb", "xb", "platform", "wp", "uf", "pp", "vp", "ab", "tab", "job", "pa", "ob", "wb", "bp", "bf", "PB", "bot"], "chunk_type": ["chword_length", "chart_length", "chunklentag", "chword_types", "chunkworklength", "chunkerlevel", "chunkerlength", "chunkworkcode", "chunk_number", "chunk_code", "chunklentype", "chunkertype", "chunk_types", "chunkworksize", "chart_size", "chet_number", "chunkertypes", "chart_type", "chunk_level", "chword_type", "chet_size", "chunkertag", "chunk_length", "chet_type", "chword_level", "chart_code", "chunklennumber", "chunk_tag", "chunkersize", "chet_tag", "chunkernumber", "chunklensize", "chunkworktype"], "chunk_size": ["chunk\u00b7number", "chunk_fee", "chunk_sum", "chunkedsize", "chunk_name", "chump6eng", "chunkstype", "chunklextype", "chunks_time", "chgroup_load", "chunk_number", "chunk\u00b7load", "chunklexsize", "chgroup_type", "chunk_no", "chunk_len", "chump_eng", "chgroup_number", "chunk_load", "chump_count", "chet_size", "chunks_size", "chunklexload", "chump_size", "chait_size", "chgroup64number", "chgroup64type", "chunkedweight", "chetsname", "chgroup64load", "chunk6size", "chunknshape", "chgroup64size", "chump_shape", "chet_type", "chump6size", "chunknsize", "chgroup_size", "chunk_channel", "chunk64load", "chunk_shape", "chetstype", "chunks_SIZE", "chunkssize", "chunk_weight", "chunklexnumber", "chunk2size", "chait_sum", "chunk2channel", "chunk_eng", "chunk_SIZE", "chunk2weight", "chunk\u00b7type", "chunks_len", "chunk_data", "chgroup_weight", "chunk\u00b7size", "chet_fee", "chump6shape", "chait_no", "chunk64type", "chunkeddata", "chunk_time", "chunksfee", "chunkneng", "chetssize", "chunk6count", "chunkncount", "chunkedchannel", "chgroup_data", "chgroup_channel", "chunksname", "chunk2data", "chetsfee", "chump6count", "chunk64size", "chet_name", "chait_name", "chunk_count", "chunk64number", "chunk6eng", "chunk6shape"]}}
{"project": "qemu", "commit_id": "b061dc41f62048acd4a34c6570c0ea396cd9d0b4", "target": 1, "func": "static void type_initialize_interface(TypeImpl *ti, const char *parent)\n\n{\n\n    InterfaceClass *new_iface;\n\n    TypeInfo info = { };\n\n    TypeImpl *iface_impl;\n\n\n\n    info.parent = parent;\n\n    info.name = g_strdup_printf(\"%s::%s\", ti->name, info.parent);\n\n    info.abstract = true;\n\n\n\n    iface_impl = type_register(&info);\n\n    type_initialize(iface_impl);\n\n    g_free((char *)info.name);\n\n\n\n    new_iface = (InterfaceClass *)iface_impl->class;\n\n    new_iface->concrete_class = ti->class;\n\n\n\n    ti->class->interfaces = g_slist_append(ti->class->interfaces,\n\n                                           iface_impl->class);\n\n}\n", "idx": 8357, "substitutes": {"ti": ["ii", "ni", "li", "uri", "ati", "tu", "phi", "tif", "oi", "mi", "fi", "ski", "chi", "ki", "shi", "i", "ini", "tm", "tk", "isi", "si", "sci", "osi", "pi", "wi", "ami", "cli", "di", "bi", "tti", "qi", "ui", "ci", "iti", "ita", "te", "ta", "ty", "tis", "info", "ai", "tta", "TI", "iri", "txt", "tin"], "parent": ["container", "gap", "owner", "pos", "prefix", "size", "type", "Parent", "pointer", "pool", "id", "comment", "path", "ref", "mother", "self", "fi", "class", "connection", "pc", "instance", "i", "parents", "method", "new", "p", "function", "content", "si", "scope", "member", "pi", "shape", "context", "family", "father", "fat", "memory", "key", "address", "source", "level", "reference", "current", "pa", "child", "port", "info", "value", "holder", "null", "root", "name", "depth", "location", "cache"], "new_iface": ["new_ifclass", "new_switchlace", "new_invfe", "new_iffe", "new_efce", "new_iflace", "new_affacer", "new_invace", "new_ifce", "new_invclass", "new_efclass", "new_fclass", "new_ifacer", "new_faces", "new_effe", "new_ifaces", "new_switchace", "new_fce", "new_afface", "new_ffe", "new_eface", "new_efacer", "new_invce", "new_eflace", "new_afflace", "new_switchacer", "new_face", "new_facer", "new_switchce", "new_affce", "new_efaces"], "iface_impl": ["iface_Impl", "ifac__pp", "ifac__impl", "ifacepinfo", "ifaceadinf", "iface__impl", "ifaceppl", "ifacepinf", "iface_repl", "iflass_kl", "ifaceadinfo", "ifce_pl", "ifaceadimpl", "iface__expl", "iface_expl", "ifac__pl", "ifac_pl", "ifacepimpl", "ifce_inf", "ifac__expl", "iface_kl", "ifac_expl", "iface__repl", "iface__plug", "iface_pp", "ifac_pp", "iflass_expl", "ifac_cl", "ifac__repl", "ifac_repl", "ifaceadpl", "iface_plug", "iflass_impl", "ifce_info", "ifac_plug", "ifce_impl", "iface__pl", "iface_cl", "iface_pl", "ifac_impl", "iface__pp", "iface_inf", "iface_info", "ifac__plug", "iflass_Impl"]}}
{"project": "FFmpeg", "commit_id": "c97f54020d5d55511e28622551f13233bd8ceb56", "target": 0, "func": "static int video_open(VideoState *is){\n\n    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;\n\n    int w,h;\n\n\n\n    if(is_full_screen) flags |= SDL_FULLSCREEN;\n\n    else               flags |= SDL_RESIZABLE;\n\n\n\n    if (is_full_screen && fs_screen_width) {\n\n        w = fs_screen_width;\n\n        h = fs_screen_height;\n\n    } else if(!is_full_screen && screen_width){\n\n        w = screen_width;\n\n        h = screen_height;\n\n    }else if (is->video_st && is->video_st->codec->width){\n\n        w = is->video_st->codec->width;\n\n        h = is->video_st->codec->height;\n\n    } else {\n\n        w = 640;\n\n        h = 480;\n\n    }\n\n#ifndef SYS_DARWIN\n\n    screen = SDL_SetVideoMode(w, h, 0, flags);\n\n#else\n\n    /* setting bits_per_pixel = 0 or 32 causes blank video on OS X */\n\n    screen = SDL_SetVideoMode(w, h, 24, flags);\n\n#endif\n\n    if (!screen) {\n\n        fprintf(stderr, \"SDL: could not set video mode - exiting\\n\");\n\n        return -1;\n\n    }\n\n    SDL_WM_SetCaption(\"FFplay\", \"FFplay\");\n\n\n\n    is->width = screen->w;\n\n    is->height = screen->h;\n\n\n\n    return 0;\n\n}\n", "idx": 8370, "substitutes": {"is": ["isl", "im", "iso", "cs", "ip", "i", "isa", "ri", "iss", "any", "ar", "isu", "address", "css", "IS", "esi", "as", "init", "info", "or", "vs", "isc", "ii", "it", "os", "like", "bis", "id", "its", "api", "ls", "ss", "Is", "ais", "serv", "can", "ins", "mis", "iris", "ic", "are", "ie", "ris", "ms", "get", "ses", "was", "the", "s", "plays", "nis", "app", "pic", "bs", "cms", "ps", "index", "las", "sys", "kit", "ics", "has", "oss", "es", "isi", "si", "lis", "sis", "us", "does", "show", "ops", "object"], "w": ["wal", "hw", "wd", " W", "rw", "wan", "f", "we", "wall", "max", "weight", "sw", "wx", "y", "c", "wo", "a", "i", "d", "p", "sh", "b", "work", "wrap", "wl", "end", "z", "v", "ww", "widget", "o", "t", "aw", "r", "wp", "win", "l", "q", "ew", "u", "wt", "wh", "wa", "ow", "m", "n", "fw", "height", "iw", "wb", "s", "window", "W", "x"], "h": ["g", "ph", "hd", "H", "hw", "f", " H", "hr", "host", "th", "oh", "home", "y", "c", "en", "help", "d", "kh", "p", "ha", "uh", "sh", "gh", "b", "ah", "enh", "hp", "zh", "bh", "hh", "ht", "hi", "v", "z", "hs", "ch", "t", "o", "length", "ih", "r", "l", "q", "u", "hl", "m", "height", "wa", "dh", "wh", "n", "eh", "rh", "x", "hm"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    struct nand_state_t *s = opaque;\n\n    uint32_t r;\n\n    int rdy;\n\n\n\n    r = nand_getio(s->nand);\n\n    nand_getpins(s->nand, &rdy);\n\n    s->rdy = rdy;\n\n\n\n    DNAND(printf(\"%s addr=%x r=%x\\n\", __func__, addr, r));\n\n    return r;\n\n}\n", "idx": 8380, "substitutes": {"opaque": ["OPac", "ipopaque", "phpity", "ipopaques", " opaco", "ropac", " opac", "phpaques", "opity", "ropaco", "OPaques", "OPaco", "opac", "opaco", "ropaque", "opaques", "phpifice", " opifice", "OPaque", " opaques", "opifice", "ropaques", "phpaque", "ipopity", "ipopifice", " opity"], "addr": ["server", " instr", "adding", "pointer", "src", "mode", "nr", "ptr", "ada", "ref", "ip", "host", " p", "adr", "pc", "adder", "d", "dr", "aque", "p", "offset", "ace", "grad", "ar", "address", "code", " e", " address", " pointer", "rx", "mac", "attr", "point", "arity", "amd", "pad", " dst", "port", "Address", "ad", "data", "alias", "x"], "size": ["SIZE", " bytes", " length", "len", "i", "rc", " offset", "bytes", "p", "offset", " rc", "ize", " sizes", " e", "Size", "length", " w", "w", "e", "n", " len", "or", "large", "data", "x"], "s": ["g", "sym", "f", "args", "service", "ls", "self", "sf", "ss", "states", "c", "sq", "a", "i", "d", "services", "sb", "rows", "es", "p", "sg", "si", "S", "session", "b", "ds", "fs", "ssl", "settings", "scope", "core", "sl", "ns", "v", "spec", "o", "t", "ps", "ses", "l", "your", "sync", "u", "gs", "w", "m", "e", "n", "su", "comments", "sa", "js", "ops"], "r": ["rw", "fr", "rt", "nr", "re", "hr", "err", "result", "rg", "c", "mr", "i", "sr", "d", "dr", "rc", "h", "lr", "p", "pr", "ri", "rd", "ner", "rl", "rf", "b", "ror", "vr", "R", "ar", "rb", "v", "rx", "reader", "t", "o", "error", "l", "cr", "m", "e", "er", "rs", "rr", "rar", "res", "var", "rh", "or", "str"], "rdy": ["ldw", "ldY", "rtye", "rtd", "ndx", "riddy", "rti", "ddyd", "radi", "raidyd", "rdye", "ddyn", "dddy", "raidw", "ordY", "ldyn", "redi", "redd", "rddy", "rdx", "ordy", "rdyd", "raidx", "nddy", "redye", "ddy", "rdY", "rady", "radd", "ridy", "ldy", "rdyn", "rdd", "ridY", "redy", "ordyn", "ddY", "ddw", "ldx", "ldyd", "raidy", "ndy", "rdi", "rdw", "ordx", "ndY", "ridx", "radye", "ddx", "rty"]}}
{"project": "qemu", "commit_id": "442773cef15092b5927851237850760345d2cf16", "target": 0, "func": "void qmp_migrate_set_speed(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s;\n\n\n\n    if (value < 0) {\n\n        value = 0;\n\n    }\n\n\n\n    s = migrate_get_current();\n\n    s->bandwidth_limit = value;\n\n    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);\n\n}\n", "idx": 8409, "substitutes": {"value": ["VALUE", "timeout", "message", "size", "type", "id", "format", "flow", "max", "weight", "limit", "update", "values", "min", "media", "score", "property", "p", "function", "offset", "create", "change", "fee", "total", "test", "end", "scale", "key", "v", "age", "image", "num", "length", "complete", "val", "try", "start", "index", "current", "Value", "unit", "set", "window", "name", "grade", "rate", "data", "count", "number"], "errp": [" errlp", "nerp", "erp", "errlp", "erpc", " errpc", " errr", "err", "errpc", "erlp", "nerpc", "nerlp", "errr", "nerr"], "s": ["g", "os", "sym", "f", "args", "service", "cs", "ls", "state", "self", "sf", "ss", "states", "c", "i", "services", "params", "sb", "new", "es", "ts", "p", "sg", "si", "S", "session", "ds", "settings", "fs", "ssl", "ips", "sl", "ns", "o", "ps", "ses", "qs", "your", "l", "sync", "u", "gs", "m", "conf", "e", "sys", "sets", "su", "rs", "status", "js", "stats", "rates", "ops", "aws"]}}
{"project": "qemu", "commit_id": "3d5d319e1221082974711af1d09d82f0755c1698", "target": 1, "func": "void block_job_resume_all(void)\n\n{\n\n    BlockJob *job = NULL;\n\n    while ((job = block_job_next(job))) {\n\n        AioContext *aio_context = blk_get_aio_context(job->blk);\n\n\n\n        aio_context_acquire(aio_context);\n\n        block_job_resume(job);\n\n        aio_context_release(aio_context);\n\n    }\n\n}\n", "idx": 8412, "substitutes": {"job": ["plugin", "live", "up", "block", "pool", "f", "flow", "ip", "jo", "connection", "result", "sub", "user", "db", "route", "library", "event", "patch", "node", "config", "model", "p", "function", "slot", "cb", "session", "b", "work", "worker", "runner", "account", "j", "url", "queue", "project", "feed", "run", "part", "address", "hub", "image", "pause", "parent", "Job", "resource", "lib", "sync", "next", "jobs", "lock", "base", "child", "ob", "section", "name", "py", "manager", "bug", "batch", "exec", "object"], "aio_context": ["aio__ctx", "aio_resource", "aiojcontext", "aios_connection", "aios_instance", "aios_cost", "aios_config", "aio__config", "aio_connection", "aio2context", "aio__connection", "aioPctx", "aiojctx", "aiojresource", "aios_resource", "aios_sc", "aios_context", "aio__context", "aio2resource", "aioPsc", "aios_ctx", "aioPcontext", "aio_ctx", "aiojcost", "aioPinstance", "aio_instance", "aio_sc", "aio2ctx", "aio2cost", "aio_cost", "aio_config"]}}
{"project": "FFmpeg", "commit_id": "b1306823d0b3ae998c8e10ad832004eb13bdd93e", "target": 0, "func": "static int write_option(void *optctx, const OptionDef *po, const char *opt,\n\n                        const char *arg)\n\n{\n\n    /* new-style options contain an offset into optctx, old-style address of\n\n     * a global var*/\n\n    void *dst = po->flags & (OPT_OFFSET | OPT_SPEC) ?\n\n                (uint8_t *)optctx + po->u.off : po->u.dst_ptr;\n\n    int *dstcount;\n\n\n\n    if (po->flags & OPT_SPEC) {\n\n        SpecifierOpt **so = dst;\n\n        char *p = strchr(opt, ':');\n\n\n\n        dstcount = (int *)(so + 1);\n\n        *so = grow_array(*so, sizeof(**so), dstcount, *dstcount + 1);\n\n        (*so)[*dstcount - 1].specifier = av_strdup(p ? p + 1 : \"\");\n\n        dst = &(*so)[*dstcount - 1].u;\n\n    }\n\n\n\n    if (po->flags & OPT_STRING) {\n\n        char *str;\n\n        str = av_strdup(arg);\n\n        av_freep(dst);\n\n        *(char **)dst = str;\n\n    } else if (po->flags & OPT_BOOL || po->flags & OPT_INT) {\n\n        *(int *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX);\n\n    } else if (po->flags & OPT_INT64) {\n\n        *(int64_t *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT64_MIN, INT64_MAX);\n\n    } else if (po->flags & OPT_TIME) {\n\n        *(int64_t *)dst = parse_time_or_die(opt, arg, 1);\n\n    } else if (po->flags & OPT_FLOAT) {\n\n        *(float *)dst = parse_number_or_die(opt, arg, OPT_FLOAT, -INFINITY, INFINITY);\n\n    } else if (po->flags & OPT_DOUBLE) {\n\n        *(double *)dst = parse_number_or_die(opt, arg, OPT_DOUBLE, -INFINITY, INFINITY);\n\n    } else if (po->u.func_arg) {\n\n        int ret = po->u.func_arg(optctx, opt, arg);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR,\n\n                   \"Failed to set value '%s' for option '%s'\\n\", arg, opt);\n\n            return ret;\n\n        }\n\n    }\n\n    if (po->flags & OPT_EXIT)\n\n        exit_program(0);\n\n\n\n    return 0;\n\n}\n", "idx": 8425, "substitutes": {"optctx": ["optionlib", "opbuf", "opcontext", "usrcontext", "optcontext", " optlib", " optcfg", "optionctx", "optioncfg", "optioncf", " optbuf", "oplib", "optioncontext", " optcontext", " optcf", "optionbuf", "usrcf", "usrcfg", "optlib", "optbuf", "optcfg", "optcf", "opctx", "usrctx"], "po": ["oa", "pos", "to", "np", "ote", "vo", "tp", "no", "yo", "pro", "va", "oo", "O", "mp", "flo", "obo", "ppa", "plate", "apo", "pb", "PO", "ppo", "pc", "jp", "poke", "co", "aco", "oda", "pd", "lo", "pr", "bo", "ako", "pi", "gro", "ko", "pre", "go", "pe", "op", "ono", "elo", "o", "oto", "da", "pp", "fo", "mo", "Po", "oe", "ta", "post", "obj", "pa", "ao", "cro", "cho", "py", "bp", "zone"], "opt": ["ok", "prop", "timeout", "pos", "text", "prefix", "fn", "dest", "usr", "aut", "path", "Opt", "err", "pl", "proc", "inf", "oss", "tag", "option", "stat", "off", "dr", "config", "cat", "pr", "lo", "expr", "options", "sp", "loc", "ord", "lit", "orig", "ext", "open", "neg", "sl", "go", "pot", "iv", "op", "spec", "prot", "o", "cl", "attr", "ret", "optim", "fo", "sn", "obj", "init", "info", "crit", "cho", "name", "alt", "feat"], "arg": ["param", "g", "ax", "parse", "ig", "args", "other", "path", "err", "tag", "option", "Arg", "help", "dr", "config", "cat", "enc", "arc", "ang", "arr", "loc", "use", "doc", "ag", "flag", "gen", "ar", "neg", "any", "go", "par", "op", "ac", "image", "num", "inc", "r", "ret", "val", "argument", "mac", "all", "call", "inter", "next", "as", "star", "util", "reg", "or", "var", "name", "none", "ad", "target"], "dst": ["Dste", "ldsc", "dest", "edst", "nsc", " dest", "ldst", "rdst", "idsts", "Dstal", "sdost", " dstal", "iddest", "insts", "idstd", "dstd", "sdste", " ddest", "ldST", " dste", "sdest", "fST", "idste", "dST", " dost", "adste", "DST", "adrest", "dedsc", "iddr", "inst", " dsp", " dST", " dstd", "dedst", "sdrest", "dedsts", "nST", "adst", " dsts", "eddr", "nsp", "dsp", "fste", "dsts", "Dstd", "rdsts", "instal", "rdST", "adest", "nst", "Dst", "ddest", "adST", "sdsc", "adsts", "dost", "Dsts", "adost", " ddr", "edsc", "dedste", "idst", "dsc", "fst", "sdST", "dste", "inste", "idsc", "drest", " drest", "ldsp", "rdsc", "sdsts", "sdst", "dstal", "ddr", "eddest", " dsc", "fsc", "Dsc"], "dstcount": [" dstc", "dSTlast", "drestlength", " destCount", " dSTcount", "drestcount", "destid", "dstlast", "dstc", "dstweight", "dftCount", "destlast", " dstid", " destlast", "dputlast", "dputlength", "dostid", " dputcount", "ndstcount", "destlength", "ndputlength", "dSTsize", "dSTc", "dostlimit", "drestlimit", "dputCount", "destcount", " destcount", "dstslength", "drestid", "dSTweight", " destlimit", " dstlength", " dstCount", "dSTlength", "dSTCount", " dSTlast", "ndstCount", "dstssize", " destlength", " dSTweight", " dstweight", "dftcount", "dstsize", " dstlimit", "dSTcount", "dstlength", " dputc", "dstscount", "dputcount", "dstslast", "dostCount", "dftweight", "dstsweight", "ndstlength", " dputCount", " dstlast", "dstCount", "dstsCount", "dostc", "dostlength", " dSTCount", " destid", "destCount", "dstlimit", "dputc", "dftsize", "dstid", " dstsize", "ndputCount", " dSTsize", "ndputcount", "destlimit", "dostcount"], "so": ["ne", "la", "os", "to", "li", "tp", "pg", "sth", "zip", "sm", "sw", "cs", "sf", "oh", "flo", "ski", "osp", "ce", "sq", "osa", "pc", "shi", "co", "lo", "bo", "si", "sp", "sh", "osi", "st", "px", "ste", "le", "cu", "ld", "ie", "se", "go", "cli", "sl", "pe", "So", "o", "ci", "sc", "fo", "SO", "sync", "mo", "ly", "sn", "te", "obj", "asi", "su", "sk", "s", "sa", "py"], "p": ["g", "np", "tp", "pg", "f", "api", "php", "pb", "c", "pc", "i", "jp", "d", "lp", "h", "pr", "sp", "b", "pi", "cp", "j", "hp", "P", "pre", "v", "pe", "op", "fp", "o", "r", "t", "wp", "l", "q", "u", "pp", "vp", "m", "e", "pa", "n", "s", "bp", "py"], "str": ["tr", "text", "fr", "type", "f", "hr", "sw", "err", "iter", "sr", "bl", "dr", "pr", "wr", "enc", "arr", "sp", "doc", "style", "stri", "sl", "v", "spec", "r", "br", "kr", "sc", "u", "strike", "cr", "STR", "rs", "strings", "s", "data", "Str"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint8(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    qemu_put_8s(f, v);\n\n}\n", "idx": 8431, "substitutes": {"f": ["F", "g", "fr", "tf", "file", "k", "ref", "ff", "fi", "c", "i", "fe", "d", "h", "p", "rf", "b", "fs", "j", "fat", "fa", "fp", "o", "df", "af", "t", "l", "fx", "fo", "m", "conf", "e", "obj", "fw", "info", "fd", "lf", "x"], "pv": [" pb", "PV", "psv", "pf", "pV", "Pf", "pb", "pvt", "vpvs", "vpf", " pvs", "psvt", " pV", "vpv", "vpV", "psb", "psf", "Pvt", " pvt", "Pv", "Pb", "pvs", " pf", "Pvs"], "size": ["g", "SIZE", "k", "len", "c", "i", "fe", "d", "small", "h", "shape", "ize", " sizes", "iv", "Size", "z", "length", "val", "l", "w", "e", "fff", "large", "data", "x"], "v": ["ii", "g", "k", "vt", "c", "i", "sv", "d", "h", "p", "b", "j", "uv", "iv", "lv", "t", "o", "val", "l", "V", "q", "u", "vp", "w", "m", "e", "n", "tv", "value", "s", "vv", "vi", "ve", "data", "vs"]}}
{"project": "qemu", "commit_id": "61a36c9b5a12889994e6c45f4a175efcd63936db", "target": 1, "func": "static RemoveResult remove_hpte(PowerPCCPU *cpu, target_ulong ptex,\n\n                                target_ulong avpn,\n\n                                target_ulong flags,\n\n                                target_ulong *vp, target_ulong *rp)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    uint64_t token;\n\n    target_ulong v, r, rb;\n\n\n\n    if (!valid_pte_index(env, ptex)) {\n\n        return REMOVE_PARM;\n\n    }\n\n\n\n    token = ppc_hash64_start_access(cpu, ptex);\n\n    v = ppc_hash64_load_hpte0(cpu, token, 0);\n\n    r = ppc_hash64_load_hpte1(cpu, token, 0);\n\n    ppc_hash64_stop_access(token);\n\n\n\n    if ((v & HPTE64_V_VALID) == 0 ||\n\n        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) ||\n\n        ((flags & H_ANDCOND) && (v & avpn) != 0)) {\n\n        return REMOVE_NOT_FOUND;\n\n    }\n\n    *vp = v;\n\n    *rp = r;\n\n    ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, 0);\n\n    rb = compute_tlbie_rb(v, r, ptex);\n\n    ppc_tlb_invalidate_one(env, rb);\n\n    return REMOVE_SUCCESS;\n\n}\n", "idx": 8435, "substitutes": {"cpu": ["server", "phy", "np", "linux", "prefix", "loader", "ctx", "pool", "pai", "device", "nic", "proc", "GPU", "c", "pc", "auc", "cmp", "pu", "node", "config", "cpp", "console", "CPU", "clock", "chip", "boot", "px", "cp", "net", "socket", "hp", "core", "cli", "vm", "roc", "platform", "gp", "bench", "gpu", "conn", "component", "uci", "login", "cn", "process", "CP", "lc", "eni", "gc", "processor", "pid", "consumer", "cache"], "ptex": ["pt1", "ctEx", "ptonexec", "PTicket", "ctext", "ptext", "ptEX", "ktlex", "ptEx", "ptlex", "iptel", "PTEx", "ctEX", "pitex", "ct1", "ktEX", "epticket", "ptexec", "ctec", "PTex", "portEX", "ntick", "ctick", "etEx", "iptexec", "PT1", "ptonEx", "ntex", "pitext", "ept1", "ktick", "portex", "portext", "eptext", "ntlex", "iptex", "portEx", "pticket", "portec", "ptick", "ctlex", "etEX", "ptec", " ptel", "PTax", "ctex", "pitEx", "ptonel", "ptonex", "etax", "iptEx", "etex", "portax", "PText", " ptEx", "ntEX", "PTEX", "ktex", "ptel", "pitec", "eptex", "cticket", "ptax", " ptexec"], "avpn": ["afn", "akpn", "appc", "akc", "vpc", "avpi", "apn", "ajpi", "vc", "akpc", "afpn", "akp", "appn", "amp", "avc", "avpc", "app", "ajpc", "akn", "ampn", "afpi", "ajn", "avp", "ajpn", "akpi", "avn", "amn", "afp", "ampc", "vpn", "afpc", "apc"], "flags": ["vl", "lag", "linux", "args", "f", "rets", "ats", "vals", "devices", "ls", "ff", "sf", "values", "services", "ants", "options", "settings", "ips", "ds", "fs", "fl", "pages", "flag", "files", "alls", "rules", "ns", "fc", "native", "lv", "mask", "words", "ports", "versions", "bits", "rs", "xp", "Flags", "s", "tags", "fd", "lists", "status", "stats", "types", "vs", "ops", "features"], "vp": ["vl", "np", "tp", "VS", "vt", "ov", "vc", "pb", "VPN", "sv", "username", "lp", "VP", "p", "vg", "RP", "vP", "sp", "GV", "cp", "vr", "uv", "fp", "cv", "lv", "vm", "nv", "attr", "wp", "qv", "xp", "vv", "erv", "vs", "ipes"], "rp": ["rpc", "rdvp", "crb", "crp", " rvp", " rpc", "rsp", "slpc", "rdps", "rvp", "rsps", "slp", "rsv", "slm", "rdp", "rv", " rps", "rdv", "slb", "rps", "rsvp", "rm", "crpc", "crm", " rm", " rv"], "env": ["fen", "np", "loader", "args", "ctx", "buf", "eng", "state", "edge", "exc", "proc", "ea", "fi", "engine", "skin", "bc", "c", "db", "en", "ini", "eu", "cache", "config", "ev", "enc", "cb", "console", "agent", "settings", "scope", "Environment", "net", "worker", "queue", "session", "equ", "runner", "style", "context", "core", "cfg", "cli", "viron", "environment", "vm", "export", "que", "conn", "policy", "stack", "conf", "inet", "e", "obj", "profile", " environment", "ec", "fg", "eni", "estate", "erv", "energy", "pect", "enable"], "token": ["ok", "prefix", "uri", "fn", "text", "setup", "pass", "loader", "id", "oken", "callback", "service", "request", "api", "vt", "tool", "fi", "tag", "byte", "KEN", "len", "module", "stop", "user", "track", "timer", "Token", "node", "username", "config", "auth", "function", "offset", "response", "reset", "temp", "password", "settings", "session", "scope", "sid", "socket", "account", "secret", "ticket", "url", "tick", "context", "rule", "key", "fp", "code", "header", "t", "channel", "o", "val", "resource", "conn", "start", "sync", "wt", "buffer", "processor", "cookie", "not", "login", "info", "fd", "fin", "target", "number"], "v": ["vl", "g", "version", "f", "va", "k", "vt", "ov", "vc", "c", "ver", "a", "i", "sv", "d", "h", "ev", "p", "vg", "vid", "b", "j", "vr", "uv", "av", "iv", "cv", "lv", "vm", "vert", "t", "nv", "val", "o", "l", "V", "q", "u", "qv", "w", "m", "vu", "n", "e", "value", "tv", "s", "var", "vv", "vi", "ve", "vs", "x"], "r": ["rw", "rt", "f", "nr", "re", "hr", "ur", "rg", "c", "mr", "sr", "ru", "rc", "h", "pr", "p", "rss", "lr", "ri", "rl", "rf", "b", "range", "rn", "vr", "R", "rx", "br", "l", "u", "rm", "m", "e", "er", "rs", "rr", "rar", "s", "rh"], "rb": ["rw", "rt", "nr", "src", "raf", "rg", "rob", "pb", "route", "lb", "sr", "sb", "ru", "rc", "rss", "lr", "ri", "rd", "rl", "rf", "b", "rn", "vr", "gb", "ruby", "tmp", "RB", "rx", "bb", "kr", "reb", "erb", "rm", "rs", "rr", "rh", "rar", "bf"]}}
{"project": "qemu", "commit_id": "33848ceed79679b5c9e558b768447af2614b8db2", "target": 1, "func": "int pcie_aer_init(PCIDevice *dev, uint16_t offset, uint16_t size)\n\n{\n\n    PCIExpressDevice *exp;\n\n\n\n    pcie_add_capability(dev, PCI_EXT_CAP_ID_ERR, PCI_ERR_VER,\n\n                        offset, size);\n\n    exp = &dev->exp;\n\n    exp->aer_cap = offset;\n\n\n\n    /* log_max is property */\n\n    if (dev->exp.aer_log.log_max == PCIE_AER_LOG_MAX_UNSET) {\n\n        dev->exp.aer_log.log_max = PCIE_AER_LOG_MAX_DEFAULT;\n\n    }\n\n    /* clip down the value to avoid unreasobale memory usage */\n\n    if (dev->exp.aer_log.log_max > PCIE_AER_LOG_MAX_LIMIT) {\n\n        return -EINVAL;\n\n    }\n\n    dev->exp.aer_log.log = g_malloc0(sizeof dev->exp.aer_log.log[0] *\n\n                                        dev->exp.aer_log.log_max);\n\n\n\n    pci_set_long(dev->w1cmask + offset + PCI_ERR_UNCOR_STATUS,\n\n                 PCI_ERR_UNC_SUPPORTED);\n\n\n\n    pci_set_long(dev->config + offset + PCI_ERR_UNCOR_SEVER,\n\n                 PCI_ERR_UNC_SEVERITY_DEFAULT);\n\n    pci_set_long(dev->wmask + offset + PCI_ERR_UNCOR_SEVER,\n\n                 PCI_ERR_UNC_SUPPORTED);\n\n\n\n    pci_long_test_and_set_mask(dev->w1cmask + offset + PCI_ERR_COR_STATUS,\n\n                               PCI_ERR_COR_SUPPORTED);\n\n\n\n    pci_set_long(dev->config + offset + PCI_ERR_COR_MASK,\n\n                 PCI_ERR_COR_MASK_DEFAULT);\n\n    pci_set_long(dev->wmask + offset + PCI_ERR_COR_MASK,\n\n                 PCI_ERR_COR_SUPPORTED);\n\n\n\n    /* capabilities and control. multiple header logging is supported */\n\n    if (dev->exp.aer_log.log_max > 0) {\n\n        pci_set_long(dev->config + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC |\n\n                     PCI_ERR_CAP_MHRC);\n\n        pci_set_long(dev->wmask + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE |\n\n                     PCI_ERR_CAP_MHRE);\n\n    } else {\n\n        pci_set_long(dev->config + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC);\n\n        pci_set_long(dev->wmask + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE);\n\n    }\n\n\n\n    switch (pcie_cap_get_type(dev)) {\n\n    case PCI_EXP_TYPE_ROOT_PORT:\n\n        /* this case will be set by pcie_aer_root_init() */\n\n        /* fallthrough */\n\n    case PCI_EXP_TYPE_DOWNSTREAM:\n\n    case PCI_EXP_TYPE_UPSTREAM:\n\n        pci_word_test_and_set_mask(dev->wmask + PCI_BRIDGE_CONTROL,\n\n                                   PCI_BRIDGE_CTL_SERR);\n\n        pci_long_test_and_set_mask(dev->w1cmask + PCI_STATUS,\n\n                                   PCI_SEC_STATUS_RCV_SYSTEM_ERROR);\n\n        break;\n\n    default:\n\n        /* nothing */\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 8447, "substitutes": {"dev": ["debug", "dem", "server", "g", "valid", "wd", "die", "sd", "pub", "loader", "block", "device", "diff", "pro", "comment", "dom", "serial", "rad", "DEV", "gu", "adv", "ver", "gd", "user", "game", "d", "feature", "off", "pack", "ev", "mod", "cur", "enc", "config", "gh", "plug", "app", "img", "doc", "Dev", "grad", "test", "prom", "end", "prof", "di", "spec", "dd", "ch", "client", "error", "req", "def", "conn", "dim", "od", "cam", "w", "ow", "conf", "ve", "info", "reg", "sk", "var", "priv", "ad", "data", "bug"], "offset": ["hop", "server", "shift", "pos", "timeout", "padding", "prefix", "version", "append", "gap", "pointer", "type", "offer", "attribute", "format", "limit", "ptr", "api", "addr", "seq", "len", "art", "off", "amp", "config", "reset", "slot", "order", "loc", "annot", "exclusive", "range", "queue", "enabled", "url", "style", "position", "end", "Offset", "scale", "part", "begin", "address", "entry", "phase", "layer", "length", "scroll", "error", "attr", "item", "start", "index", "pad", "lock", "delay", "base", "origin", "port", "info", "set", "root", "alt", "optional", "count", "alias", "location", "align", "enable"], "size": ["sized", "timeout", "SIZE", "pos", "capacity", "empty", "max", "cs", "len", "small", "si", "sh", "loc", "fee", "shape", "end", "scale", "ize", "address", "Size", "length", "ui", "complete", "unit", "set", "storage", "large", "s", "sec", "sum"]}}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "static void qemu_tcg_init_vcpu(CPUState *cpu)\n\n{\n\n    char thread_name[VCPU_THREAD_NAME_SIZE];\n\n    static QemuCond *tcg_halt_cond;\n\n    static QemuThread *tcg_cpu_thread;\n\n\n\n    /* share a single thread for all cpus with TCG */\n\n    if (!tcg_cpu_thread) {\n\n        cpu->thread = g_malloc0(sizeof(QemuThread));\n\n        cpu->halt_cond = g_malloc0(sizeof(QemuCond));\n\n        qemu_cond_init(cpu->halt_cond);\n\n        tcg_halt_cond = cpu->halt_cond;\n\n        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, \"CPU %d/TCG\",\n\n                 cpu->cpu_index);\n\n        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,\n\n                           cpu, QEMU_THREAD_JOINABLE);\n\n#ifdef _WIN32\n\n        cpu->hThread = qemu_thread_get_handle(cpu->thread);\n\n#endif\n\n        while (!cpu->created) {\n\n            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n\n        }\n\n        tcg_cpu_thread = cpu->thread;\n\n    } else {\n\n        cpu->thread = tcg_cpu_thread;\n\n        cpu->halt_cond = tcg_halt_cond;\n\n    }\n\n}\n", "idx": 8457, "substitutes": {"cpu": ["linux", "loader", "ctx", "pai", "nc", "pc", "uca", "cpp", "fps", "kernel", "winner", "console", "clock", "px", "queue", "css", "bench", "cus", "cn", "eni", "gc", "performance", "consumer", "colo", "np", "gnu", "home", "intel", "lb", "pu", "frame", "thread", " CPU", "fp", "vm", "platform", "conn", "mc", "processor", "gru", "hw", "computer", "config", "CPU", "boot", "qa", "cu", "cube", "fc", "que", "gp", "mac", "gpu", "uci", "lc", "null", "name", "userc", "phy", "nic", "cdn", "proc", "GPU", "auc", "instance", "cmp", "node", "chip", "net", "cp", "core", "cli", "roc", "component", "custom", "process", "python", "uno", "cache"], "thread_name": ["threadsname", "thread_names", "threadalindex", " thread_NAME", "threadstype", "thread_type", "connection_size", "cond_number", " thread_names", "connection_name", "condalname", "cond_name", "thread_NAME", "condalindex", "thread_len", "thread_index", "cond_index", "threadalname", "thread2name", "thread2names", "condalnumber", "thread_size", "threadalsize", "threadslen", "connection_type", "connection_len", "threadssize", "condalsize", "cond_size", "thread_number", "threadalnumber", "thread2NAME"], "tcg_halt_cond": ["tcg_hort_reason", "tcg_halt__cond", "tcg_hort_condition", "tcg_halt_connection", "tcg_hort2code", "tcg_hait_cmd", "tcg_halt_reason", "tcg_halt__reason", "tcg_halturecond", "tcg_halt_Cond", "tcg_hort2reason", "tcg_hal_connection", "tcg_halturecondition", "tcg_haltingcondition", "tcg_halturecmd", "tcg_haltingcond", "tcg_halt2code", "tcg_halt_code", "tcg_hal_condition", "tcg_hort_cond", "tcg_halt__condition", "tcg_halt__code", "tcg_hal_Cond", "tcg_hort2cond", "tcg_hait_cond", "tcg_hal_cond", "tcg_halt2reason", "tcg_halt_condition", "tcg_hort2condition", "tcg_hort_code", "tcg_hait_Cond", "tcg_haltingconnection", "tcg_halt2condition", "tcg_hait_condition", "tcg_halt2cond", "tcg_haltingCond", "tcg_halt_cmd", "tcg_haltureCond"], "tcg_cpu_thread": ["tcg_cpu2loop", "tcg_gpu_cond", "tcg_cpu2thread", "tcg_cpu__process", "tcg_gpu_method", "tcg_cpu2connection", "tcg_cpu_method", "tcg_cpu__loop", "tcg_cpu2cond", "tcg_cpu_cond", "tcg_cpu2process", "tcg_gpu_connection", "tcg_gpu_worker", "tcg_cpu_worker", "tcg_cpu_connection", "tcg_gpu_process", "tcg_cpu_loop", "tcg_gpu_loop", "tcg_cpu__method", "tcg_cpu__thread", "tcg_gpu_thread", "tcg_cpu_process", "tcg_cpu2method"]}}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)\n\n{\n\n    ssize_t ret;\n\n#ifdef CONFIG_VNC_TLS\n\n    if (vs->tls.session) {\n\n        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);\n\n    } else {\n\n#endif /* CONFIG_VNC_TLS */\n\n        ret = send(vs->csock, (const void *)data, datalen, 0);\n\n#ifdef CONFIG_VNC_TLS\n\n    }\n\n#endif /* CONFIG_VNC_TLS */\n\n    VNC_DEBUG(\"Wrote wire %p %zd -> %ld\\n\", data, datalen, ret);\n\n    return vnc_client_io_error(vs, ret, socket_error());\n\n}\n", "idx": 8466, "substitutes": {"vs": ["server", "os", "args", "VS", "ils", "vers", "vals", "va", "cs", "ov", "state", "ls", "ss", "ys", "xs", "vc", "uses", "ks", "sv", "services", "es", "fps", "ts", "http", "iss", "ds", "fs", "sts", "vr", "alls", "env", "bs", "ns", "v", "ms", "css", "vm", "lv", "ps", "ses", "qs", "proxy", "vp", "gs", "sys", "rs", "obs", "s", "sk", "stats", "ops"], "data": ["dat", "timeout", "message", "empty", "size", "args", "id", "Data", "api", "buf", "ada", "result", "addr", "len", "a", "d", "DATA", "config", "bytes", "str", "response", "input", "content", "session", "results", "done", "open", "missing", "key", "address", "da", "def", "start", "next", "buffer", "body", "base", "info", "raw", "batch", "none", "window", "exec", "name", "keys", "cache"], "datalen": [" davalen", "davalen", "dallun", " datalan", "datalens", "dallsan", "dallan", "idatalens", "daleden", "davalener", "idotalens", "dotalan", "dallsten", "davalun", "datalan", "davalan", " datalener", "dillingen", " dallsen", "dallsength", "datalsten", "idatalsten", " davalun", "datalener", " dallsan", " datalength", "idotalen", "davalenum", "dallsen", "dillingan", "dallength", " davalan", " datalun", "idatalan", "dillingens", "dotalens", "daledan", " dallsength", "dallsener", "dallen", "dallenum", "datalun", "daledenum", "davalength", "idotalsten", "idatalen", "dallens", "dillingsten", " davalenum", "datalength", "idotalan", "datalenum", "dotalsten", "dotalen", " datalenum", "dallener", "daledun", " dallsener"], "ret": ["et", "valid", "rets", "rt", "f", "att", "resp", "re", "RET", "ref", "err", "rev", "result", "success", "len", "db", "en", " Ret", "cat", "rc", "back", "temp", "fun", "lit", "done", "bit", "flag", "part", "ut", "code", "mem", "fail", "r", "val", "get", "_", "all", "def", "det", "try", "pet", "rec", "job", "arg", "reply", "obj", "res", "nt", "reg", "status", "Ret", "alt", "str"]}}
{"project": "FFmpeg", "commit_id": "6f1ec38ce2193d3d4cacd87edb452c6d7ba751ec", "target": 0, "func": "static av_cold int decode_init(AVCodecContext * avctx)\n\n{\n\n    MPADecodeContext *s = avctx->priv_data;\n\n    static int init=0;\n\n    int i, j, k;\n\n\n\n    s->avctx = avctx;\n\n\n\n    ff_mpadsp_init(&s->mpadsp);\n\n\n\n    avctx->sample_fmt= OUT_FMT;\n\n    s->error_recognition= avctx->error_recognition;\n\n\n\n    if (!init && !avctx->parse_only) {\n\n        int offset;\n\n\n\n        /* scale factors table for layer 1/2 */\n\n        for(i=0;i<64;i++) {\n\n            int shift, mod;\n\n            /* 1.0 (i = 3) is normalized to 2 ^ FRAC_BITS */\n\n            shift = (i / 3);\n\n            mod = i % 3;\n\n            scale_factor_modshift[i] = mod | (shift << 2);\n\n        }\n\n\n\n        /* scale factor multiply for layer 1 */\n\n        for(i=0;i<15;i++) {\n\n            int n, norm;\n\n            n = i + 2;\n\n            norm = ((INT64_C(1) << n) * FRAC_ONE) / ((1 << n) - 1);\n\n            scale_factor_mult[i][0] = MULLx(norm, FIXR(1.0          * 2.0), FRAC_BITS);\n\n            scale_factor_mult[i][1] = MULLx(norm, FIXR(0.7937005259 * 2.0), FRAC_BITS);\n\n            scale_factor_mult[i][2] = MULLx(norm, FIXR(0.6299605249 * 2.0), FRAC_BITS);\n\n            av_dlog(avctx, \"%d: norm=%x s=%x %x %x\\n\",\n\n                    i, norm,\n\n                    scale_factor_mult[i][0],\n\n                    scale_factor_mult[i][1],\n\n                    scale_factor_mult[i][2]);\n\n        }\n\n\n\n        RENAME(ff_mpa_synth_init)(RENAME(ff_mpa_synth_window));\n\n\n\n        /* huffman decode tables */\n\n        offset = 0;\n\n        for(i=1;i<16;i++) {\n\n            const HuffTable *h = &mpa_huff_tables[i];\n\n            int xsize, x, y;\n\n            uint8_t  tmp_bits [512];\n\n            uint16_t tmp_codes[512];\n\n\n\n            memset(tmp_bits , 0, sizeof(tmp_bits ));\n\n            memset(tmp_codes, 0, sizeof(tmp_codes));\n\n\n\n            xsize = h->xsize;\n\n\n\n            j = 0;\n\n            for(x=0;x<xsize;x++) {\n\n                for(y=0;y<xsize;y++){\n\n                    tmp_bits [(x << 5) | y | ((x&&y)<<4)]= h->bits [j  ];\n\n                    tmp_codes[(x << 5) | y | ((x&&y)<<4)]= h->codes[j++];\n\n                }\n\n            }\n\n\n\n            /* XXX: fail test */\n\n            huff_vlc[i].table = huff_vlc_tables+offset;\n\n            huff_vlc[i].table_allocated = huff_vlc_tables_sizes[i];\n\n            init_vlc(&huff_vlc[i], 7, 512,\n\n                     tmp_bits, 1, 1, tmp_codes, 2, 2,\n\n                     INIT_VLC_USE_NEW_STATIC);\n\n            offset += huff_vlc_tables_sizes[i];\n\n        }\n\n        assert(offset == FF_ARRAY_ELEMS(huff_vlc_tables));\n\n\n\n        offset = 0;\n\n        for(i=0;i<2;i++) {\n\n            huff_quad_vlc[i].table = huff_quad_vlc_tables+offset;\n\n            huff_quad_vlc[i].table_allocated = huff_quad_vlc_tables_sizes[i];\n\n            init_vlc(&huff_quad_vlc[i], i == 0 ? 7 : 4, 16,\n\n                     mpa_quad_bits[i], 1, 1, mpa_quad_codes[i], 1, 1,\n\n                     INIT_VLC_USE_NEW_STATIC);\n\n            offset += huff_quad_vlc_tables_sizes[i];\n\n        }\n\n        assert(offset == FF_ARRAY_ELEMS(huff_quad_vlc_tables));\n\n\n\n        for(i=0;i<9;i++) {\n\n            k = 0;\n\n            for(j=0;j<22;j++) {\n\n                band_index_long[i][j] = k;\n\n                k += band_size_long[i][j];\n\n            }\n\n            band_index_long[i][22] = k;\n\n        }\n\n\n\n        /* compute n ^ (4/3) and store it in mantissa/exp format */\n\n\n\n        int_pow_init();\n\n        mpegaudio_tableinit();\n\n\n\n        for (i = 0; i < 4; i++)\n\n            if (ff_mpa_quant_bits[i] < 0)\n\n                for (j = 0; j < (1<<(-ff_mpa_quant_bits[i]+1)); j++) {\n\n                    int val1, val2, val3, steps;\n\n                    int val = j;\n\n                    steps  = ff_mpa_quant_steps[i];\n\n                    val1 = val % steps;\n\n                    val /= steps;\n\n                    val2 = val % steps;\n\n                    val3 = val / steps;\n\n                    division_tabs[i][j] = val1 + (val2 << 4) + (val3 << 8);\n\n                }\n\n\n\n\n\n        for(i=0;i<7;i++) {\n\n            float f;\n\n            INTFLOAT v;\n\n            if (i != 6) {\n\n                f = tan((double)i * M_PI / 12.0);\n\n                v = FIXR(f / (1.0 + f));\n\n            } else {\n\n                v = FIXR(1.0);\n\n            }\n\n            is_table[0][i] = v;\n\n            is_table[1][6 - i] = v;\n\n        }\n\n        /* invalid values */\n\n        for(i=7;i<16;i++)\n\n            is_table[0][i] = is_table[1][i] = 0.0;\n\n\n\n        for(i=0;i<16;i++) {\n\n            double f;\n\n            int e, k;\n\n\n\n            for(j=0;j<2;j++) {\n\n                e = -(j + 1) * ((i + 1) >> 1);\n\n                f = pow(2.0, e / 4.0);\n\n                k = i & 1;\n\n                is_table_lsf[j][k ^ 1][i] = FIXR(f);\n\n                is_table_lsf[j][k][i] = FIXR(1.0);\n\n                av_dlog(avctx, \"is_table_lsf %d %d: %x %x\\n\",\n\n                        i, j, is_table_lsf[j][0][i], is_table_lsf[j][1][i]);\n\n            }\n\n        }\n\n\n\n        for(i=0;i<8;i++) {\n\n            float ci, cs, ca;\n\n            ci = ci_table[i];\n\n            cs = 1.0 / sqrt(1.0 + ci * ci);\n\n            ca = cs * ci;\n\n            csa_table[i][0] = FIXHR(cs/4);\n\n            csa_table[i][1] = FIXHR(ca/4);\n\n            csa_table[i][2] = FIXHR(ca/4) + FIXHR(cs/4);\n\n            csa_table[i][3] = FIXHR(ca/4) - FIXHR(cs/4);\n\n            csa_table_float[i][0] = cs;\n\n            csa_table_float[i][1] = ca;\n\n            csa_table_float[i][2] = ca + cs;\n\n            csa_table_float[i][3] = ca - cs;\n\n        }\n\n\n\n        /* compute mdct windows */\n\n        for(i=0;i<36;i++) {\n\n            for(j=0; j<4; j++){\n\n                double d;\n\n\n\n                if(j==2 && i%3 != 1)\n\n                    continue;\n\n\n\n                d= sin(M_PI * (i + 0.5) / 36.0);\n\n                if(j==1){\n\n                    if     (i>=30) d= 0;\n\n                    else if(i>=24) d= sin(M_PI * (i - 18 + 0.5) / 12.0);\n\n                    else if(i>=18) d= 1;\n\n                }else if(j==3){\n\n                    if     (i<  6) d= 0;\n\n                    else if(i< 12) d= sin(M_PI * (i -  6 + 0.5) / 12.0);\n\n                    else if(i< 18) d= 1;\n\n                }\n\n                //merge last stage of imdct into the window coefficients\n\n                d*= 0.5 / cos(M_PI*(2*i + 19)/72);\n\n\n\n                if(j==2)\n\n                    mdct_win[j][i/3] = FIXHR((d / (1<<5)));\n\n                else\n\n                    mdct_win[j][i  ] = FIXHR((d / (1<<5)));\n\n            }\n\n        }\n\n\n\n        /* NOTE: we do frequency inversion adter the MDCT by changing\n\n           the sign of the right window coefs */\n\n        for(j=0;j<4;j++) {\n\n            for(i=0;i<36;i+=2) {\n\n                mdct_win[j + 4][i] = mdct_win[j][i];\n\n                mdct_win[j + 4][i + 1] = -mdct_win[j][i + 1];\n\n            }\n\n        }\n\n\n\n        init = 1;\n\n    }\n\n\n\n    if (avctx->codec_id == CODEC_ID_MP3ADU)\n\n        s->adu_mode = 1;\n\n    return 0;\n\n}\n", "idx": 8482, "substitutes": {"avctx": ["navctx", "avconfig", "avcmp", "avcontext", " avctl", "AVctx", "avconf", "avectx", " avtx", "afconfig", "akcontext", "navcontext", "ajctrl", "afconsole", "ajcontext", "avtx", "AVconfig", "AVcli", " avctrl", "abcontext", "mpcontext", "akctl", " avcontext", "ajtx", "mpcu", "mpctx", "avcu", "avconsole", "mptx", "navtx", "abctx", "afconf", "ajcli", "aftx", "abcu", "afconn", "AVcmp", "ajctx", "akconsole", " avcli", "akconf", "ajctl", "ajcam", "navcam", "avcli", " avconn", "afcli", "AVconn", "navcli", "mpconn", "abconfig", "avecontext", " avconsole", "afcu", "avcam", "aveconf", "akctx", "akcli", "AVcontext", "AVcam", "avctrl", "avectl", "navctrl", "afctl", "avconn", "afctx", "AVcu", "mpcmp", "avctl", "afcmp", "afcontext", "navctl"], "s": ["server", "utils", "ctx", "service", "ls", "sf", "ss", "c", "sq", "services", "sv", "sb", "p", "sg", "si", "S", "session", "ds", "b", "fs", "ssl", "se", "ns", "spec", "t", "o", "qs", "ses", "sc", "sync", "gs", "m", "sys", "init", "su", "rs", "shared", "sk", "sec", "sa", "js", "space", "so", "data", "aws"], "i": ["li", "mu", "ip", "mi", "chi", "c", "ei", "b", "bi", "ui", "q", "init", "info", "ai", "eni", "line", "ii", "it", "ni", "isin", "id", "site", "phi", "api", "oi", "uli", "ie", "hi", "z", "xi", "zi", "qi", "o", "abi", "yi", "gi", "in", "di", "ti", "l", "u", "index", "lc", "mini", "ix", "g", "uri", "I", "fi", "iu", "is", "ini", "sup", "multi", "p", "si", "isi", "pi", "io", "inner", "cli", "iv", "m", "vi", "slice"], "j": ["ii", "g", "pos", "c", "jp", "ji", "p", "b", "kj", "z", "J", "o", "t", "r", "l", "q", "m", "ij", "obj", "jj"], "k": ["g", "id", "max", "K", "c", "ks", "p", "b", "key", "mk", "z", "num", "o", "r", "ik", "q", "w", "m", "sk"], "offset": ["padding", "transform", "pos", "timeout", "iso", "id", "ptr", "ip", "skip", "len", "off", "p", "reset", "slot", "loc", "split", "seed", "position", "Offset", "rot", "parent", "entry", "o", "error", "start", "index", "ffff", "pad", "base", "info", "origin", "port", "set", "data", "alias", "align", "slice"], "shift": ["transform", "version", "size", "id", "diff", "ptr", " shifts", "Shift", "dist", "sup", "patch", "pack", "hift", "p", "step", "change", "sh", "seed", "range", "load", " shifted", "position", "scale", "push", "vert", "length", "mix", "ress", "form", "power", "pad", "data", "init", "delay", "set", "fix", "pop", "pull", "depth", "slice", "ix", "sum"], "mod": ["tr", "transform", "pos", "MOD", "mode", "diff", "max", "mu", "modified", "comp", "roll", "sub", "min", "sign", "module", "multipl", "c", "dist", "sup", "pack", "lex", "mods", "step", "range", "rem", "cm", "scale", "row", "inc", "ind", "length", "du", "mac", "dim", "form", "m", "lock", "mult", "Mod", "pull", "comb", "mix"], "n": ["ii", "ne", "g", "ni", "nor", "adj", "pn", "nc", "nb", "c", "len", "network", "en", "N", "p", "ner", "b", "net", "nu", "ns", "z", "num", "dn", "r", "o", "t", "spin", "l", "u", "nn", "m", "sn", "body", "init", "eni", "mn"], "norm": ["ii", "transform", "axis", "fine", "version", "valid", " Norm", "nor", "size", "global", "known", "vec", "diff", "format", "nc", "front", "orm", "low", "len", "dist", "Norm", "draw", "small", "term", "function", "normal", "orig", "loc", "nom", "fun", "range", "ord", "orbit", "rn", "doc", "cm", "center", "flat", "core", "scale", "cube", "coll", "dc", "carry", "num", "chrom", "color", "sc", "common", "sync", "index", "form", "m", "desc", "init", "unit", "custom", "rom", "lc", "uni", "raw", "complex", "feat", "mn", "mx"], "h": ["g", "ph", "H", "path", "host", "c", "help", "p", "ha", "hm", "b", "ht", "hs", "code", "ch", "header", "t", "r", "q", "u", "w", "m", "rh", "hash", "cache"], "xsize": ["xxscale", "xxSize", "wsize", "xbytes", "ySize", "xxbytes", "wscale", "ysize", "xscale", "ybytes", "wbytes", "xxsize", "xSize", "wSize", "yscale"], "x": ["id", "max", "c", "X", "ex", "p", "bit", "key", "z", "num", "rx", "t", "l", "u", "index", "dx", "w", "m", "height", "data", "ix"], "y": ["pos", "type", "ip", "c", "p", "dy", "temp", "b", "vy", "z", "ch", "t", "o", "l", "w", "m", "height", "col", "Y"], "tmp_bits": ["tmp2bits", "tmpWbytes", "prev_bits", "mp_bits", "prev_bytes", "mp_bit", "prevWwindows", "prevWchanges", "tmp_blocks", "tmp2bytes", "prev_windows", "tmp67bits", "tmpWbits", "tmp___bits", " tmp_bytes", " tmp_blocks", "prev_changes", "tmp_bit", "tmpWchanges", "tmp_windows", "tmp67codes", "tmp___changes", "prevWbits", "mp_codes", "tmp67bit", "tmp67batch", "tmp___windows", "tmp__bits", "tmp_batch", "tmp__bytes", "tmp2blocks", "tmp__blocks", "mp_batch", "prevWbytes", "tmp__codes", "tmp2codes", "tmp_bytes", "tmp___bytes", "tmp_changes", "tmpWwindows"], "tmp_codes": ["tmp_maps", "tmp86code", "tmp_code", "tmp86codes", "nb_code", "nb_maps", "nb_bits", "nb86maps", "tmp86bits", "nb86bits", "nb_codes", "tmp86maps", "nb86code", "nb86codes"]}}
{"project": "FFmpeg", "commit_id": "480324e7ca0b87105fd7ee168292a0d5692af128", "target": 0, "func": "static int libgsm_decode_frame(AVCodecContext *avctx,\n\n                               void *data, int *data_size,\n\n                               AVPacket *avpkt) {\n\n    uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);\n\n\n\n    if (*data_size < out_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Output buffer is too small\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (buf_size < avctx->block_align) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch(avctx->codec_id) {\n\n    case CODEC_ID_GSM:\n\n        if(gsm_decode(avctx->priv_data,buf,data)) return -1;\n\n        break;\n\n    case CODEC_ID_GSM_MS:\n\n        if(gsm_decode(avctx->priv_data,buf,data) ||\n\n           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;\n\n    }\n\n\n\n    *data_size = out_size;\n\n    return avctx->block_align;\n\n}\n", "idx": 8487, "substitutes": {"avctx": ["navctx", " avxc", "avsci", "aircontext", "avcf", "navcmp", "aircup", "afpkg", "avesci", "avecup", "ajconf", "avkb", "auctx", "avcca", "afcb", "afcu", "avepkg", "auconn", "aukb", "ajcn", "avectx", " avcu", "navcontext", "ajcontext", "avsync", " avcontext", "avexc", " avcmp", "avcup", "afsci", " avcca", "aflc", "avecontext", "AVcontext", "vercf", "avelc", "avconn", "afcn", "afcontext", "ajcmp", "AVctx", "AVcca", "avconf", "afkb", "vercontext", "avecb", "ausync", "avlc", "aucontext", "afcca", "avpkg", "afconf", "afconn", "AVcmp", "ajctx", "aircf", " avsync", "avecn", "ajpkg", "AVcb", " avcf", "avecca", "afctx", "airctx", "afcmp", " avkb", "afcup", "avcmp", "avcontext", "evctx", "evcmp", "avecf", "avcb", "AVlc", "afsync", "avecu", "avcu", "navcca", "afcf", "evconf", "AVcf", "afxc", " avconn", "verctx", "ausci", "avxc", "vercmp", "avcn", "aveconn", "vercca", "evcontext"], "data": ["la", "message", "empty", "alpha", "a", "bytes", "response", "queue", "done", "open", "memory", "address", "package", "ui", "next", "pad", "raw", "dat", "size", "id", "api", "result", "au", "DATA", "xxx", "frame", "parent", "header", "length", "frames", "base", "bus", "shift", "valid", "block", "Data", "bc", "len", "config", "content", "array", "start", "index", "body", "null", "window", "count", "pos", "ata", "sample", "ada", "bu", "media", "p", "offset", "input", "image", "da", "val", "buffer", "uc", "zero", "batch", "none", "slice", "cache"], "data_size": ["ata_form", "data___size", "data_count", " data_code", " data_slice", "data___count", "data_body", "buf_unit", "data_scale", "data_slice", "dataqscale", "dataqslice", "data_form", "data___body", "dataqcode", "data_code", "data_sized", "buf_num", "ata_count", "ata_size", "dataqsize", "buf_size", "data_unit", "data_num", "buf_sized", "ata_body", " data_scale", "data___form"], "avpkt": ["avcpct", "avnsth", "avfpck", "afpck", "avcpacket", "avpacket", "affacket", "abpki", "avppkt", "abpacket", "AVPkg", "affkg", "avvpck", "abcpacket", "abpkt", "avvpacket", "avcpki", "affck", "avpck", "afpkg", "avfki", "avnkt", "avppct", "abcpkt", "avfpkg", "avfct", "avpki", "avpkg", "avfacket", "avppsth", "avpct", "avPkt", "avPkg", "AVpsth", "avlpkt", "avnct", "avvpkg", "abpct", "avvpkt", "avfpkt", "avlpct", "affkt", "avcpkt", "avpsth", "avlpacket", "abcpct", "AVpkt", "abcpki", "AVPct", "avPsth", "avnkg", "AVPkt", "avPct", "AVPsth", "afpkt", "avfpacket", "avlpki", "avfck", "AVpkg", "afpacket", "avfkg", "avppkg", "avfkt", "AVpct"], "buf": ["la", "pos", "prop", "text", "ctx", "vec", "src", "ff", "bu", "bc", "bag", "seq", "box", "len", "config", "cb", "offset", "cur", "ha", "b", "fb", "queue", "img", "feed", "rb", "array", "fp", "code", "cv", "num", "header", "alloc", "br", "length", "Buffer", "uf", "req", "cf", "buff", "map", "ab", "buffer", "pad", "func", "wa", "port", "wb", "cap", "fd", "uc", "batch", "window", "cache"]}}
{"project": "qemu", "commit_id": "e1622f4b15391bd44eb0f99a244fdf19a20fd981", "target": 1, "func": "static int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr)\n\n{\n\n    unsigned access_size_min = mr->ops->impl.min_access_size;\n\n    unsigned access_size_max = mr->ops->impl.max_access_size;\n\n\n\n    /* Regions are assumed to support 1-4 byte accesses unless\n\n       otherwise specified.  */\n\n    if (access_size_min == 0) {\n\n        access_size_min = 1;\n\n    }\n\n    if (access_size_max == 0) {\n\n        access_size_max = 4;\n\n    }\n\n\n\n    /* Bound the maximum access by the alignment of the address.  */\n\n    if (!mr->ops->impl.unaligned) {\n\n        unsigned align_size_max = addr & -addr;\n\n        if (align_size_max != 0 && align_size_max < access_size_max) {\n\n            access_size_max = align_size_max;\n\n        }\n\n    }\n\n\n\n    /* Don't attempt accesses larger than the maximum.  */\n\n    if (l > access_size_max) {\n\n        l = access_size_max;\n\n    }\n\n    /* ??? The users of this function are wrong, not supporting minimums larger\n\n       than the remaining length.  C.f. memory.c:access_with_adjusted_size.  */\n\n    assert(l >= access_size_min);\n\n\n\n    return l;\n\n}\n", "idx": 8518, "substitutes": {"mr": ["ocr", "rt", "igr", "bm", "nr", "Mr", "wk", "ur", "rg", "adr", "md", "MR", "sr", "dr", "rc", "lr", "tm", "rl", "rf", "fm", "cm", "vr", "gb", "mt", "rb", "yr", "mk", "r", "kr", "km", "rm", "m", "gr", "dm", "ml", "er", "las", "rs", "mc", "rh", "rr", "manager", "bf", "mn", "hm"], "l": ["la", "g", "li", "f", "ll", "ls", "ul", "lt", "len", "c", "al", "i", "lb", "d", "lp", "lo", "lr", "p", "ol", "ell", "rl", "loc", "b", "le", "fl", "j", "nl", "sl", "kl", "z", "v", "il", "lv", "lin", "el", "o", "r", "length", "u", "ly", "e", "ml", "n", "ln", "er", " L", "base", "lc", "s", "L", "dl", "x"], "addr": ["hop", "oa", "rt", "pointer", "size", "mode", "nr", "src", "ptr", "ada", "ref", "host", "adr", "len", "route", "cmp", "a", "node", "dr", "rc", "ace", "offset", "nil", "loc", "asm", "arr", "ange", "orig", "ar", "part", "address", "add", "ac", "dd", "rx", "r", "layer", "mac", "amd", "nn", "base", "lan", "rs", "Address", "name", "ad", "data", "align", "x"]}}
{"project": "qemu", "commit_id": "d6b6abc51dda79a97f2c7bd6652c1940c068f1ec", "target": 1, "func": "void fw_cfg_add_file_callback(FWCfgState *s,  const char *filename,\n\n                              FWCfgCallback select_cb,\n\n                              FWCfgWriteCallback write_cb,\n\n                              void *callback_opaque,\n\n                              void *data, size_t len, bool read_only)\n\n{\n\n    int i, index, count;\n\n    size_t dsize;\n\n    MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine());\n\n    int order = 0;\n\n\n\n    if (!s->files) {\n\n        dsize = sizeof(uint32_t) + sizeof(FWCfgFile) * fw_cfg_file_slots(s);\n\n        s->files = g_malloc0(dsize);\n\n        fw_cfg_add_bytes(s, FW_CFG_FILE_DIR, s->files, dsize);\n\n    }\n\n\n\n    count = be32_to_cpu(s->files->count);\n\n    assert(count < fw_cfg_file_slots(s));\n\n\n\n    /* Find the insertion point. */\n\n    if (mc->legacy_fw_cfg_order) {\n\n        /*\n\n         * Sort by order. For files with the same order, we keep them\n\n         * in the sequence in which they were added.\n\n         */\n\n        order = get_fw_cfg_order(s, filename);\n\n        for (index = count;\n\n             index > 0 && order < s->entry_order[index - 1];\n\n             index--);\n\n    } else {\n\n        /* Sort by file name. */\n\n        for (index = count;\n\n             index > 0 && strcmp(filename, s->files->f[index - 1].name) < 0;\n\n             index--);\n\n    }\n\n\n\n    /*\n\n     * Move all the entries from the index point and after down one\n\n     * to create a slot for the new entry.  Because calculations are\n\n     * being done with the index, make it so that \"i\" is the current\n\n     * index and \"i - 1\" is the one being copied from, thus the\n\n     * unusual start and end in the for statement.\n\n     */\n\n    for (i = count + 1; i > index; i--) {\n\n        s->files->f[i] = s->files->f[i - 1];\n\n        s->files->f[i].select = cpu_to_be16(FW_CFG_FILE_FIRST + i);\n\n        s->entries[0][FW_CFG_FILE_FIRST + i] =\n\n            s->entries[0][FW_CFG_FILE_FIRST + i - 1];\n\n        s->entry_order[i] = s->entry_order[i - 1];\n\n    }\n\n\n\n    memset(&s->files->f[index], 0, sizeof(FWCfgFile));\n\n    memset(&s->entries[0][FW_CFG_FILE_FIRST + index], 0, sizeof(FWCfgEntry));\n\n\n\n    pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename);\n\n    for (i = 0; i <= count; i++) {\n\n        if (i != index &&\n\n            strcmp(s->files->f[index].name, s->files->f[i].name) == 0) {\n\n            error_report(\"duplicate fw_cfg file name: %s\",\n\n                         s->files->f[index].name);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    fw_cfg_add_bytes_callback(s, FW_CFG_FILE_FIRST + index,\n\n                              select_cb, write_cb,\n\n                              callback_opaque, data, len,\n\n                              read_only);\n\n\n\n    s->files->f[index].size   = cpu_to_be32(len);\n\n    s->files->f[index].select = cpu_to_be16(FW_CFG_FILE_FIRST + index);\n\n    s->entry_order[index] = order;\n\n    trace_fw_cfg_add_file(s, index, s->files->f[index].name, len);\n\n\n\n    s->files->count = cpu_to_be32(count+1);\n\n}\n", "idx": 8522, "substitutes": {"s": ["server", "sym", "service", "cs", "self", "c", "a", "ks", "sv", "d", "settings", "b", "hs", "sites", "gs", "w", "as", "e", "comments", "rs", "strings", "js", "os", "groups", "site", "its", "ls", "ss", "sq", "uses", "ins", "sb", "h", "http", "S", "session", "ds", "fs", "ssl", "ans", "o", "qs", "ses", "tests", "f", "sf", "xs", "y", "times", "services", "sg", "hm", "secondary", "sl", "bs", "in", "r", "ps", "l", "sync", "u", "sys", "g", "args", "request", "events", "state", "states", "uns", "ys", "is", "new", "es", "p", "ts", "si", "se", "ns", "spec", "us", "t", "your", "m", "conf", "n", "sets", "this", "stats", "ops", "aws"], "filename": ["binary", "prefix", "fn", "uri", "size", "file", "f", "unc", "directory", "callback", "path", "sf", "x", "connection", "kn", "username", "config", "xxx", "password", "rl", "nil", "dll", "fs", "gz", "url", "files", "kl", "fp", "il", "original", "Filename", "length", "word", "tty", "which", "buffer", "fil", "fd", "name", "txt", "slice"], "select_cb": ["connect_cv", "connect_cb", "select_pc", "select_cv", "select_rb", "connect_rb", "connect_pc"], "write_cb": [" write_buff", "write_func", "write_callback", " write_func", " write_callback", "write_buff"], "callback_opaque": ["callback_pec", "callback_ospec", "callback__copec", "callback_paque", "callback_copacity", "callback_copid", "callback_copaque", "callback_ospacity", "callback__opec", "callback_opid", "callback__copid", "callback_opacity", "callback__opacity", "callback_ospaque", "callback__opaque", "callback_opec", "callback_copec", "callback_ospid", "callback__copacity", "callback__opid", "callback__copaque", "callback_pid", "callback_pacity"], "data": ["binary", "dat", "message", "block", "callback", "Data", "buf", "connection", "result", "media", "write", "d", "DATA", "config", "bytes", "response", "session", "memory", "record", "image", "source", "bin", "call", "buffer", "body", "batch", "window", "cache"], "len": ["flags", "pos", "block", "args", "type", "limit", "ls", "byte", "seq", "en", "cmp", "bl", "cb", "loc", "Len", "open", "code", "mem", "length", "bin", "val", "all", "lib", "cap", "str"], "read_only": ["write_wait", "write_Only", "read_Only", "readvalonly", "readvalall", "read_wait", "readvalOnly", "write_all", "readvalwait", "write_only", "read_all"], "i": ["ii", "ni", "abi", "li", "uri", "list", "size", "f", "type", "id", "phi", "I", "ip", "mi", "fi", "y", "c", "yi", "iu", "is", "ini", "ei", "a", "multi", "slice", "p", "ri", "si", "b", "pi", "inner", "io", "j", "gi", "ie", "part", "in", "di", "code", "bi", "xi", "ti", "ind", "qi", "ui", "o", "v", "l", "ci", "u", "m", "e", "n", "init", "my", "ai", "mini", "eni", "name", "x", "ix", "it"], "index": ["comment", "connection", "alpha", "option", "success", "c", "key", "address", "ui", "all", "old", "ci", "e", "info", "page", "ii", "size", "pointer", "id", "weight", "search", "xxx", "member", "connect", "j", "end", "ie", "thread", "coll", "xi", "parent", "active", "num", "qi", "length", "sort", "call", "column", "list", "action", "block", "f", "diff", "date", "config", "in", "expression", "di", "ind", "insert", "sync", "start", "current", "value", "name", "number", "x", "ix", "pos", "version", "uri", "find", "Index", "type", "match", "path", "other", "ini", "instance", "offset", "condition", "input", "si", "order", "loc", "full", "position", "loop", "original", "image", "inc", "level", "val", "ih", "initial", "n", "none", "zero", "element", "slice", "cache"], "count": ["find", "first", "size", "f", "type", "id", "file", "cast", "pool", "max", "weight", "path", "limit", "class", "connection", "Count", "low", "c", "found", "close", "cycle", "p", "order", "loc", "b", "catch", "use", "load", "con", "core", "cc", "loop", "key", "code", "coll", "ch", "num", "length", "ind", "time", "select", "force", "l", "call", "cond", "sum", "start", "last", "col", "base", "n", "child", "process", "large", "name", "group", "depth", "number", "counter", "list", "cache"], "dsize": ["dcount", "fdbytes", "dscale", "Dize", " dbytes", "sdsize", " dpack", "Dcount", "sdpack", "liz", " dize", " dlen", "Diz", "dname", "Dsize", "mcount", " dscale", " diz", "Dname", "dpack", " dname", "lscale", "dbytes", "dlsize", "dlpack", "mname", "Dscale", "lbytes", " dcount", "sdscale", "dlscale", "lsize", "msize", "lize", "dlen", "dllen", "diz", "fdscale", "fdiz", "fdsize", "dize", "sdlen"], "mc": ["MC", "cow", "nc", "mi", "mp", "bc", "rg", "ma", "md", "c", "mr", "pc", "ca", "co", "Mc", "cy", "cm", "mic", "cfg", "cc", "dc", "ms", "ac", "vm", "cms", "mac", " MC", "cus", "m", "mm", "ml", "tc", "uc", "gc", "mot", "mn", "mx"]}}
{"project": "qemu", "commit_id": "2e1198672759eda6e122ff38fcf6df06f27e0fe2", "target": 1, "func": "static void stellaris_enet_save(QEMUFile *f, void *opaque)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n    int i;\n\n\n\n    qemu_put_be32(f, s->ris);\n\n    qemu_put_be32(f, s->im);\n\n    qemu_put_be32(f, s->rctl);\n\n    qemu_put_be32(f, s->tctl);\n\n    qemu_put_be32(f, s->thr);\n\n    qemu_put_be32(f, s->mctl);\n\n    qemu_put_be32(f, s->mdv);\n\n    qemu_put_be32(f, s->mtxd);\n\n    qemu_put_be32(f, s->mrxd);\n\n    qemu_put_be32(f, s->np);\n\n    qemu_put_be32(f, s->tx_fifo_len);\n\n    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n\n    for (i = 0; i < 31; i++) {\n\n        qemu_put_be32(f, s->rx[i].len);\n\n        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n\n\n\n    }\n\n    qemu_put_be32(f, s->next_packet);\n\n    qemu_put_be32(f, s->rx_fifo_offset);\n\n}\n", "idx": 8526, "substitutes": {"f": ["F", "fen", "ph", "fr", "fn", "tf", "file", "k", "ff", "sf", "fi", "inf", "ft", "c", "elf", "fe", "fu", "d", "p", "rf", "b", "fm", "fb", "fs", "fun", "feed", "fa", "fp", "fal", "v", "fc", "t", "df", "r", "af", "uf", "l", "cf", "q", "fo", "u", "form", "fx", "def", "w", "m", "conf", "func", "e", "n", "fw", "info", "fd", "bf", "x"], "opaque": [" oprique", "opacity", " opasso", "hopasso", " opac", "opasso", "iopac", " opacity", "pacity", "hoprique", "opac", "ioprique", "hopaque", "iopaque", "paques", "paque", "opaques", "operaques", "operaque", " opaques", "operacity", "iopasso", "hopac", "oprique"], "s": ["sym", "service", "err", "cs", "c", "a", "ks", "d", "settings", "b", "ar", "sites", "gs", "as", "e", "strings", "js", "sum", "os", "site", "its", "ls", "ss", "sq", "sb", "rows", "h", "S", "session", "ds", "fs", "ssl", "j", "ms", "o", "ses", "qs", "sc", "er", "sf", "y", "en", "an", "services", "sg", "sl", "in", "v", "ions", "r", "ps", "l", "u", "sync", "south", "sys", "su", "g", "ess", "args", "states", "ys", "is", "new", "es", "ser", "p", "ts", "si", "se", "ns", "spec", "us", "sy", "t", "m", "conf", "n", "sets", "ops", "aws"], "i": ["ii", "ni", "abi", "li", "uri", "hi", "id", "phi", "I", "limit", "iv", "mu", "ip", "oi", "mi", "fi", "chi", "adi", "y", "c", "yi", "ki", "iu", "a", "ini", "d", "multi", "dr", "ji", "p", "ri", "si", "b", "pi", "io", "j", "gi", "ie", "ami", "loop", "di", "xi", "v", "bi", "zi", "ti", "layer", "o", "ui", "qi", "l", "ci", "start", "index", "u", "m", "e", "n", "info", "init", "ai", "eni", "vi", "x", "ix", "line"]}}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "static void exit_program(void)\n\n{\n\n    int i, j;\n\n\n\n    for (i = 0; i < nb_filtergraphs; i++) {\n\n        avfilter_graph_free(&filtergraphs[i]->graph);\n\n        for (j = 0; j < filtergraphs[i]->nb_inputs; j++) {\n\n            av_freep(&filtergraphs[i]->inputs[j]->name);\n\n            av_freep(&filtergraphs[i]->inputs[j]);\n\n        }\n\n        av_freep(&filtergraphs[i]->inputs);\n\n        for (j = 0; j < filtergraphs[i]->nb_outputs; j++) {\n\n            av_freep(&filtergraphs[i]->outputs[j]->name);\n\n            av_freep(&filtergraphs[i]->outputs[j]);\n\n        }\n\n        av_freep(&filtergraphs[i]->outputs);\n\n        av_freep(&filtergraphs[i]->graph_desc);\n\n        av_freep(&filtergraphs[i]);\n\n    }\n\n    av_freep(&filtergraphs);\n\n\n\n    /* close files */\n\n    for (i = 0; i < nb_output_files; i++) {\n\n        AVFormatContext *s = output_files[i]->ctx;\n\n        if (!(s->oformat->flags & AVFMT_NOFILE) && s->pb)\n\n            avio_close(s->pb);\n\n        avformat_free_context(s);\n\n        av_dict_free(&output_files[i]->opts);\n\n        av_freep(&output_files[i]);\n\n    }\n\n    for (i = 0; i < nb_output_streams; i++) {\n\n        AVBitStreamFilterContext *bsfc = output_streams[i]->bitstream_filters;\n\n        while (bsfc) {\n\n            AVBitStreamFilterContext *next = bsfc->next;\n\n            av_bitstream_filter_close(bsfc);\n\n            bsfc = next;\n\n        }\n\n        output_streams[i]->bitstream_filters = NULL;\n\n        avcodec_free_frame(&output_streams[i]->filtered_frame);\n\n\n\n        av_freep(&output_streams[i]->forced_keyframes);\n\n        av_freep(&output_streams[i]->avfilter);\n\n        av_freep(&output_streams[i]->logfile_prefix);\n\n        av_freep(&output_streams[i]);\n\n    }\n\n    for (i = 0; i < nb_input_files; i++) {\n\n        avformat_close_input(&input_files[i]->ctx);\n\n        av_freep(&input_files[i]);\n\n    }\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        av_frame_free(&input_streams[i]->decoded_frame);\n\n        av_frame_free(&input_streams[i]->filter_frame);\n\n        av_dict_free(&input_streams[i]->opts);\n\n        av_freep(&input_streams[i]->filters);\n\n        av_freep(&input_streams[i]);\n\n    }\n\n\n\n    if (vstats_file)\n\n        fclose(vstats_file);\n\n    av_free(vstats_filename);\n\n\n\n    av_freep(&input_streams);\n\n    av_freep(&input_files);\n\n    av_freep(&output_streams);\n\n    av_freep(&output_files);\n\n\n\n    uninit_opts();\n\n\n\n    avfilter_uninit();\n\n    avformat_network_deinit();\n\n\n\n    if (received_sigterm) {\n\n        av_log(NULL, AV_LOG_INFO, \"Received signal %d: terminating.\\n\",\n\n               (int) received_sigterm);\n\n        exit (255);\n\n    }\n\n}\n", "idx": 8534, "substitutes": {"i": ["ii", "g", "ni", "li", "uri", "im", "f", "iq", "id", "phi", "I", "api", "ip", "oi", "mi", "fi", "y", "module", "yi", "ki", "iu", "ini", "is", "a", "d", "ei", "multi", "ri", "p", "si", "isi", "b", "pi", "ic", "io", "ori", "inner", "gi", "interface", "ie", "cli", "di", "xi", "zi", "bi", "iv", "ti", "ind", "qi", "ui", "ik", "ih", "l", "ci", "u", "index", "start", "m", "ij", "e", "n", "info", "my", "init", "ai", "eni", "in", "x", "ix", "it"], "j": ["ii", "g", "li", "im", "fr", "adj", "f", "other", "k", "je", "jo", "x", "jet", "y", "uj", "jp", "ja", "d", "h", "ji", "p", "pr", "ani", "jen", "gh", "b", "kj", "jl", "ie", "key", "z", "v", "xi", "J", "qi", "jam", "o", "ih", "ui", "oj", "l", "el", "q", "u", "w", "m", "ij", "e", "n", "jj", "ju", "dj", "eni", "js", "aj", "jc", "ix", "it"], "s": ["g", "os", "sym", "f", "service", "ls", "sf", "ss", "c", "sq", "a", "is", "sup", "d", "sv", "sb", "services", "es", "p", "sg", "si", "S", "session", "ds", "http", "b", "ssl", "secondary", "sl", "ns", "v", "spec", "hs", "us", "r", "t", "o", "ses", "your", "sync", "u", "gs", "m", "e", "n", "sys", "comments", "storage", "js"], "bsfc": ["basfc", "oscf", "ssfp", "outsfd", "outscf", "issfc", "nscf", "psbc", "bsfd", "ksci", "basfe", "osfn", "wsfc", "csfb", "usfn", "isscf", "vsci", "BSfp", "bscf", "bescf", "bsfp", "ssfn", "nsfn", "csbc", "uscf", "usfd", "bsci", "vscf", "BSfc", "bascf", "ksfc", "wsfp", "osfd", "usfc", "bsbc", "outsfc", "dsfc", "pspc", "cspc", "bsfb", "basfd", "ksfp", "issfp", "wsfn", "BSfn", "psfc", "dsbc", "bsfn", "besfc", "wslc", "besfd", "psfb", "csfc", "ssfc", "nsfc", "kscf", "bslc", "dspc", "bsfe", "outsfe", "dsfb", "bspc", "osfc", "besfe", "vsfp", "BSlc", "sslc", "vsfc", "nsfd", "issci"], "next": ["valid", "first", "future", "latest", "global", "children", "other", "max", "ptr", "path", "prev", "self", "proc", "now", "seq", "second", "network", "sequence", "close", "cmp", "new", "cur", "primary", "iss", "again", "secondary", "open", "key", "code", "parent", "sen", "cv", "coll", "alloc", "client", "group", "later", "dot", "head", " Next", "last", "current", "follow", "child", "this", "another", "sec", "root", "page", "Next", "data"]}}
{"project": "qemu", "commit_id": "091b1108ca6d6e3bfaea5f095f219bf5ea8c316b", "target": 1, "func": "static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *num_same)\n\n{\n\n    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;\n\n    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;\n\n    uint8_t bitmap[BDRV_SECTOR_SIZE];\n\n    int ret;\n\n    int changed;\n\n\n\n    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    bitnum &= BITS_PER_BITMAP_SECTOR - 1;\n\n    changed = cow_test_bit(bitnum, bitmap);\n\n    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);\n\n    return changed;\n\n}\n", "idx": 8543, "substitutes": {"bs": ["bus", "bos", "bis", "ils", "cs", "ls", "bc", "BS", "pb", "bps", "ks", "ins", "sb", "fps", "cb", "iss", "ds", "b", "boot", "fs", "fb", "outs", "rb", "ns", "css", "us", "bi", "ps", "ses", "ab", "gs", "ros", "base", "ubs", "bits", "ob", "bas", "obs", "js", "bid", "vs"], "sector_num": ["sectorvalsum", "sectorvalname", " sector_name", "section_off", "sector_su", "section_number", " sector_number", "sector_number", " sector_su", "sectorvalsu", "sector_sum", "sectorvaloff", "section_sum", "section_num", "sectorvalnum", "sectorvalnumber", "sector_name", "sector_off"], "nb_sectors": ["nb_psegments", "nb_veores", "nb_pseores", "nb_pecs", "nb_vegments", "nb_specs", "nb_vecs", "nb_tecs", "nb_peors", "nb_tegments", "nb_veors", "nb_spectors", "nb_segments", "nb_spegments", "nb_seors", "nb_seores", "nb_pectors", "nb_speors", "nb_teores", "nb_psecs", "nb_secs", "nb_tectors", "nb_pegments", "nb_vectors", "nb_psectors"], "num_same": [" num_missing", " num_repeat", "num\u00b7same", " num_shared", "num\u00b7two", "num_shared", "numemtwo", "numemshared", " num_two", "numemrepeat", "numemsame", "num\u00b7shared", "num_two", "num_share", "num_repeat", "num\u00b7repeat", " num_share", "num_missing"], "bitmap": ["bugMap", "bitsMap", "bugblock", " bitnumber", "tagmap", "bitsmaps", "bitMAP", "bitsaddress", " bitmask", "bugmask", "byteaddress", "hitwise", "BITblock", " bitload", "binMap", "tagcache", "byteMap", "bytemap", "hitmap", "bitblock", "bitmask", "bitload", "hitmaps", "bitsmap", "bytecache", " bitwise", "bitcache", " bitmaps", "binaddress", "bitmaps", "BITmap", "bootblock", " bitMap", "binblock", "bitnumber", " bitcache", "binmaps", "bootmask", "bytenumber", "tagnumber", "binmap", "bitwise", "binwise", "byteblock", "hitload", "bootmap", "BITMap", "bitMap", "tagmaps", "binload", "bytemaps", "bugmap", "bootMap", " bitblock", "binMAP", "bitaddress", "byteMAP", "BITMAP"], "ret": ["valid", " sent", "rt", "f", "rets", " updated", "att", "re", "RET", "ref", "err", "repl", "ception", "update", "result", "success", "len", "found", "art", " RET", "new", "rc", "expected", "back", "cat", "reset", "change", "rl", " result", "lit", "replace", "flag", "bit", "end", "part", "rb", "mt", "code", "rot", "active", "num", "r", "error", "val", "det", "br", "rep", "fail", "hard", "reply", "pat", "set", "res", "nt", "reg", "alt", "Ret", "bf", "data"], "changed": ["g", "valid", "changes", "received", " updated", "aligned", "diff", "added", "loaded", "weight", "ref", "err", "update", "modified", "changing", "anged", "confirmed", "protected", "found", "fe", "new", "config", "expected", "updated", "temp", "change", "written", "packed", "stable", " written", "checked", " unchanged", "rot", "initialized", " altered", "handled", "broken", "error", "val", "used", "locked", "current", "unit", "value", "bug", "data", "edited", "Changed"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n", "idx": 8565, "substitutes": {"timer_list": ["timerxpair", "later_add", "meterappconfig", "timerkcount", "meterapplist", "timerAcount", "theme0list", "lateridleft", "theme_detail", "timerllist", "meterapplog", "er_record", "timer0list", "timer_table", "timerallconfig", "timerdpair", "timer2config", "timer0detail", "timeridadd", "timerlistget", "timerapplog", "timeralllist", "ticklistqueue", "meter_list", "timer2log", "theme0test", "timerkdiff", "timer6list", "timer0test", "timerxList", "timer5stack", "timerlisttest", "timer_record", "timer_stack", "timer_lock", "timerappstack", "theme_LIST", "timeridleft", "meter_config", "timerklist", "timer2list", "tick_tree", "timer6stack", "theme6LIST", "theme0detail", "timerAlist", "ticklistlist", "timerAtable", "timer_tree", "theme_test", "lateridbatch", "theme_get", " timer_diff", "meterappget", "timerlistlist", "lateridadd", "timer_pair", "timerdrecord", "theme6get", "timer_batch", "timer_count", "timer5get", " timer_count", "er_lock", "ticklisttree", "timer_type", "theme0get", "timeridlist", "theme6stack", "er_pair", "timer5list", "timeridbatch", "er_type", "theme6list", "timer_log", "theme_list", "tick_List", "timerktable", "meter_get", "later_left", "timer6LIST", "later_batch", "timer_test", "later_list", "timerxlist", "timer_config", "timerappconfig", "tick_list", "timerallget", "timerdlist", "timer_detail", "timerlistqueue", "timer_add", "timerdList", "er_List", "timerlqueue", "timer5LIST", "timer0get", "timerlistList", "lateridlist", "timerAdiff", "er_batch", "timer_get", "theme_stack", "timerapplist", "timer_left", "tick_queue", "timerxrecord", "timer6get", "er_list", " timer_table", "timerltree", "timer_diff", "timerlisttree", "timer_LIST", "timerappget", "timerlistdetail", "timerappLIST", "timer_queue", "timer2get", "timer_List", "meter_log", "timerlList", "timeralllog", "ticklistList"], "expire_time": ["expirextime", "expire64timeout", "expire64start", "exake___start", "expire64money", "expire_money", "exake_time", "expirexmode", "expire64hour", "expire64count", "exire_time", "expire_timeout", "expire_Time", "exake_hour", "expiration_timeout", "expire___hour", "exire_Time", "expirefmoney", "expire64time", "exake_start", "expireftime", "exake_count", "expire_start", "exake___time", "expiration_time", "expirefmode", "expireystart", "expire__timeout", "expire_hour", "expireycount", "expire_mode", "exake___hour", "expiration_money", "expireytime", "exake___count", "exire_money", "exire_count", "expire___time", "expire__money", "expire___count", "expire___start", "exire_mode", "expireyhour", "expirexmoney", "expire__time", "expire_count"]}}
{"project": "qemu", "commit_id": "e97fc193e1c65deb51643d5251e98affe07c59ca", "target": 0, "func": "static void check_refcounts(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t size;\n\n    int nb_clusters, refcount1, refcount2, i;\n\n    QCowSnapshot *sn;\n\n    uint16_t *refcount_table;\n\n\n\n    size = bdrv_getlength(s->hd);\n\n    nb_clusters = size_to_clusters(s, size);\n\n    refcount_table = qemu_mallocz(nb_clusters * sizeof(uint16_t));\n\n\n\n    /* header */\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  0, s->cluster_size);\n\n\n\n    check_refcounts_l1(bs, refcount_table, nb_clusters,\n\n                       s->l1_table_offset, s->l1_size, 1);\n\n\n\n    /* snapshots */\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        check_refcounts_l1(bs, refcount_table, nb_clusters,\n\n                           sn->l1_table_offset, sn->l1_size, 0);\n\n    }\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  s->snapshots_offset, s->snapshots_size);\n\n\n\n    /* refcount data */\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  s->refcount_table_offset,\n\n                  s->refcount_table_size * sizeof(uint64_t));\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        int64_t offset;\n\n        offset = s->refcount_table[i];\n\n        if (offset != 0) {\n\n            inc_refcounts(bs, refcount_table, nb_clusters,\n\n                          offset, s->cluster_size);\n\n        }\n\n    }\n\n\n\n    /* compare ref counts */\n\n    for(i = 0; i < nb_clusters; i++) {\n\n        refcount1 = get_refcount(bs, i);\n\n        refcount2 = refcount_table[i];\n\n        if (refcount1 != refcount2)\n\n            fprintf(stderr, \"ERROR cluster %d refcount=%d reference=%d\\n\",\n\n                   i, refcount1, refcount2);\n\n    }\n\n\n\n    qemu_free(refcount_table);\n\n}\n", "idx": 8568, "substitutes": {"bs": ["os", "bos", "bis", "src", "cs", "ls", "state", "bn", "ss", "bc", "xs", "BS", "pb", "bps", "is", "ks", "lb", "ins", "eb", "sb", "bl", "rss", "cb", "fps", "iss", "ds", "b", "bes", "fs", "fb", "bh", "gb", "ns", "css", "bi", "us", "bb", "ps", "ses", "sync", "plugins", "gs", "org", "banks", "ros", "base", "obj", "sys", "ob", "las", "rs", "lbs", "obs", "sa", "js", "bits", "stats", "vs"], "s": ["sym", "service", "cs", "self", "c", "a", "ks", "d", "settings", "b", "css", "sites", "gs", "w", "e", "rs", "js", "vs", "os", "bis", "site", "its", "ls", "ss", "ins", "params", "sb", "S", "session", "ds", "fs", "ssl", "ms", "o", "ses", "qs", "f", "xs", "services", "sg", "secondary", "sl", "v", "r", "ps", "l", "sync", "south", "sys", "su", "g", "ess", "args", "state", "states", "is", "p", "ts", "si", "full", "sis", "ns", "spec", "us", "t", "m", "n", "sets", "sa", "stats", "aws"], "size": ["g", "sized", "timeout", "SIZE", "capacity", "empty", "type", "max", "weight", "len", "c", "en", "small", "ice", "si", "fee", "loc", "shape", "core", "scale", "ize", "address", "code", "Size", "length", "complete", "time", "sc", "iz", "e", "unit", "n", "storage", "large", "sec", "six", "name", "count", "ix", "sum"], "nb_clusters": ["nb_helluster", "nb_CLurs", "nb_clicas", "nb_hellases", "nb_CLoses", "nb_custer", "nb_splusters", "nb_sclayers", "nbJcluster", "nb_elusters", "nb_clocations", "nb_llards", "nbOfsliffs", "nb_cliffs", "nb_clayers", "nb_splurs", "nb_sclows", "nb_plicas", "nb_cliques", "nb_labases", "nbOfslores", "nbJclusters", "nb_colusters", "nb_colores", "nb_plust", "nb_cores", "nb_slows", "nb_sclroups", "nb_clambers", "nb_CLusters", "nb_elocations", "nb_CLores", "nb_glusters", "nb_licusters", "nb_shusters", "nb_plusters", "nbJlabuster", "nbJclurs", "nb_coliffs", "nb_custers", "nb_aclows", "nb_shurs", "nb_critusters", "nb_closures", "nb_licambers", "nb_slurs", "nbJlabunks", "nb_kliffs", "nb_hellusters", "nb_aclushes", "nb_labunks", "nb_klambers", "nb_clards", "nb_CLunks", "nb_plocations", "nb_laows", "nb_sliffs", "nb_clurs", "nb_sluster", "nb_clunks", "nb_CLases", "nbOfslusters", "nbOfcliffs", "nbOfclusters", "nb_aclusters", "nb_blusters", "nbOfclores", "nb_llosures", "nb_acliffs", "nb_laroups", "nbJlaburs", "nb_klurs", "nbJclunks", "nb_lausters", "nb_blust", "nb_clust", "nb_aclroups", "nbJlabusters", "nb_splows", "nb_CLiffs", "nb_spliffs", "nb_clases", "nb_aclurs", "nb_elicas", "nb_cocations", "nb_blocations", "nb_clows", "nb_glunks", "nb_helloses", "nb_critosures", "nb_closes", "nb_slocations", "nb_elust", "nb_lliques", "nb_cluster", "nb_slroups", "nb_slores", "nb_galliques", "nb_licurs", "nbOfcluster", "nb_critards", "nb_laburs", "nb_gluster", "nb_gallusters", "nb_gallosures", "nb_coluster", "nb_liciffs", "nb_CLocations", "nb_gallards", "nb_clroups", "nbOfsluster", "nb_llusters", "nb_critiques", "nb_slambers", "nb_clushes", "nb_laayers", "nb_labusters", "nb_slushes", "nb_shushes", "nb_shroups", "nb_klusters", "nb_sclusters", "nb_blicas", "nb_clores", "nb_CLuster", "nb_slayers", "nb_slusters", "nb_labuster", "nb_laboses", "nb_glurs"], "refcount1": ["refcheckOne", " refCount1", "refprocess1", " refcount9", "relount4", "referencecount2", "referenceount2", "relount1", "refCount4", "refcount9", "refprocess9", "refount2", "relcountOne", " refCountOne", " refCount9", "refprocess4", "refsum4", "refcount01", "refCount01", "refountOne", "refprocesss", " refcounts", "refcheck4", "refcheck1", "refcountOne", "refsum1", "relcount4", "refsumOne", " refCount01", "referenceount1", "referenceountOne", "refprocess01", " refcount01", "refCount9", " refcount4", "refCountOne", "refount4", "referencecount1", "referencecountOne", "refount1", "relcount1", "refount01", "refcount4", "refCounts", "referencecount4", "refounts", "refprocessOne", "refsum2", "refCount1", "relountOne", " refcountOne", "referenceount4", "refcounts", " refCounts", "refcheck9", " refCount4"], "refcount2": ["refloadTwo", "relcount3", "refcache1", "referenceount2", "referencecount2", "relount1", "refCount4", "relcount2", "refount22", "refcode2", "refcount02", "refount2", "refsum4", "refcount42", "refc2", "relount2", "refountTwo", "referenceount02", "relcountTwo", "refcount3", "refount02", "refload42", "refcodeTwo", "refload2", "refc42", "refCount2", "referenceount22", "referenceount1", "referencecount02", "relcount42", "refsum02", "relountTwo", "referencecountTwo", "refount4", "refcountTwo", "refcache3", "relount3", "referencecount1", "relc2", "refount1", "refc1", "relcount1", "refcount4", "referencecount4", "relc1", "referencecount22", "refcTwo", "refcode1", "refsum2", "refcode22", "refount3", "referenceountTwo", "relcTwo", "referenceount4", "refload1", "refcache2", "refcacheTwo", "relc42", "refcount22", "refCount02"], "i": ["li", "mu", "ip", "mi", "chi", "c", "d", "ri", "b", "ami", "key", "bi", "ui", "ci", "init", "e", "info", "ai", "eni", "it", "ii", "ni", "isin", "id", "phi", "oi", "ski", "j", "ie", "hi", "zi", "xi", "z", "qi", "o", "uni", "f", "y", "yi", "ki", "step", "gi", "part", "di", "ti", "v", "in", "r", "ik", "l", "u", "index", "start", "name", "x", "ix", "g", "uri", "I", "fi", "iu", "ini", "multi", "ji", "p", "si", "pi", "io", "inner", "ori", "cli", "m", "n", "vi", "data", "slice"], "sn": ["ii", "ni", "li", "scl", "sd", "sam", "Sn", "fn", "nr", "sm", "sw", "ls", "sf", "bn", "ny", "SN", "ski", "ss", "chi", "nb", "kn", "ki", "sr", "sv", "sb", "si", "sp", "span", "sh", "ssl", "nu", "nw", "sl", "ns", "ti", "zi", "bi", "cl", "ci", "sc", "conn", "sync", "nn", "n", "cn", "su", "sk", "lc", "sa", "vi", "syn", "jc"], "refcount_table": ["refcountNarray", "reftime_tab", "refsum_table", "refcountJelement", "refcount2session", "refcountJstate", "refqueue_section", "refprocess2Table", "refcountParray", "refqueueedarray", "refcountOtree", "refname_center", "refcountNerror", "refcount_file", "reftime_cache", "refcountrelement", "refname_buffer", "refqueue_error", "refcount_Table", "refcount2tree", "refcode_state", "referror_element", "refcount_tree", "refcountxresource", "refsum_service", "referrorJelement", "refcountingmachine", "refcountrtable", "refcountingtask", "refcountOcache", "reftimeOtab", "refcountDstable", "refcountstree", "refcount24machine", "referrorJmachine", "refcount_array", "refprocess_Table", "refqueueedsection", "refcount_machine", "refcount_service", "refcount67batch", "refcountedtotal", "refcountPsection", "refnameingmachine", "refcount_cache", "reftimeOtree", "referrorJtable", "refcountJcache", "refnameingresource", "refcountrstable", "refcount2Table", "refcount_database", "refcount_buffer", "refcountingTable", "refcount67stable", "refcountJstable", "refcountedservice", "refcount24table", "refcountstable", "refcountNsection", "referror_stable", "refcountedarray", "refcountDtab", "refcount_stable", "refcount_center", "refcountOtab", "refcountstab", "refnameedtotal", "refcheck_tab", "refount_table", "refcheck_table", "refsum_Table", "refprocess2session", "refcount_state", "refcountPerror", "referror_table", "refount_Table", "refcountxtask", "refount_database", "refname_table", "refcountPtable", "refcount_section", "refcount2table", "refcount_TABLE", "refcountedcenter", "refprocess_tree", "refcount_resource", "refcountscache", "refcountNtable", "refnameedcenter", "refsum_TABLE", "refcount_batch", "refnameingtable", "refcountingdatabase", "refcount_task", "refcountxmachine", "refcode_cache", "referror_machine", "reftimeOcache", "refname_task", "refprocess2table", "refcountOtable", "refcountedtable", "refqueueedtable", "refcode_file", "referrorJstable", "refprocess2tree", "refprocess_session", "refcheck_stable", "refcheck_batch", "refcount24task", "refsum_file", "refcount_session", "refcount67tab", "refname_resource", "reftime_tree", "refcountedTABLE", "refcountJmachine", "refcount_tab", "refcountDbatch", "refcountingtable", "refcountedbuffer", "refprocess_table", "refcountJfile", "refcountingresource", "refname_machine", "refqueue_array", "refqueue_table", "refcountJtable", "refcountederror", "refcountxtable", "refnameedbuffer", "reftimeOtable", "refqueueederror", "reftime_table", "refcount24resource", "refcount_element", "refnameedtable", "refnameingtask", "refcountDtable", "refcount67table", "refcountedTable", "refname_total", "refcountrmachine", "refcount_total", "refcode_table", "refcountedsection", "refcount_error"], "offset": ["ii", "padding", "snap", "pos", "timeout", "shift", "pointer", "type", "id", "attribute", "activation", "api", "ref", "ip", "aff", "ski", "skip", "addr", "alpha", "len", "off", "new", "slice", "p", "reset", "slot", "ace", "notation", "loc", "range", "position", "end", "part", "Offset", "key", "address", "image", "entry", "num", "o", "error", "attr", "start", "index", "next", "base", "set", "alt", "optional", "number", "location", "align", "object"]}}
{"project": "qemu", "commit_id": "456d60692310e7ac25cf822cc1e98192ad636ece", "target": 1, "func": "static int ipoctal_init(IPackDevice *ip)\n\n{\n\n    IPOctalState *s = IPOCTAL(ip);\n\n    unsigned i;\n\n\n\n    for (i = 0; i < N_CHANNELS; i++) {\n\n        SCC2698Channel *ch = &s->ch[i];\n\n        ch->ipoctal = s;\n\n\n\n        /* Redirect IP-Octal channels to host character devices */\n\n        if (ch->devpath) {\n\n            const char chr_name[] = \"ipoctal\";\n\n            char label[ARRAY_SIZE(chr_name) + 2];\n\n            static int index;\n\n\n\n            snprintf(label, sizeof(label), \"%s%d\", chr_name, index);\n\n\n\n            ch->dev = qemu_chr_new(label, ch->devpath, NULL);\n\n\n\n            if (ch->dev) {\n\n                index++;\n\n\n                qemu_chr_add_handlers(ch->dev, hostdev_can_receive,\n\n                                      hostdev_receive, hostdev_event, ch);\n\n                DPRINTF(\"Redirecting channel %u to %s (%s)\\n\",\n\n                        i, ch->devpath, label);\n\n            } else {\n\n                DPRINTF(\"Could not redirect channel %u to %s\\n\",\n\n                        i, ch->devpath);\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 8577, "substitutes": {"ip": ["arp", "im", "id", "device", "zip", "api", "host", "mp", "proc", "jp", "p", "ep", "chip", "sp", "ips", "cp", "io", "interface", "address", "iv", "op", "image", "fp", "machine", "gp", "pp", "vp", "ipp", "inet", "port", "inst", "IP", "ipe", "ix"], "s": ["g", "sam", "f", "service", "cs", "state", "ss", "y", "c", "sq", "is", "d", "sv", "services", "sb", "p", "sg", "sp", "S", "ds", "b", "si", "sh", "ssl", "socket", "sl", "ns", "v", "spec", "o", "ps", "ses", "sc", "gs", "m", "south", "e", "n", "sys", "storage", "sa", "stats", "ops"], "i": ["ii", "ti", "axis", "ni", "abi", "li", "uri", "f", "id", "phi", "I", "k", "address", "oi", "mi", "fi", "y", "c", "yi", "iu", "ini", "d", "multi", "slice", "p", "ri", "si", "b", "pi", "xi", "io", "j", "inner", "gi", "ie", "z", "v", "zi", "bi", "di", "hi", "ind", "r", "ui", "qi", " ii", "l", "ci", "u", "m", "e", "n", "ai", "eni", "uni", "x", "ix"], "ch": ["ph", "hw", "ctx", "chart", "kick", "k", "cs", "th", "chn", "cand", "cham", "chi", "ce", "chan", "cht", "c", "vc", "exec", "ech", "cmp", "arch", "patch", "config", "h", "p", "enc", "cb", "chip", "sh", "change", "cy", "cp", "bh", "zh", "cor", "core", "cha", "code", "ich", "client", "che", "el", "cl", "channel", "ach", "her", "cf", "conn", "q", "sc", "dev", "ci", "form", "conf", "col", "e", "CH", "child", "sk", "cho", "inst", "Ch", "ench", "cher", "sch", "cache"], "chr_name": ["chdr_name", "chrb_number", "chrb_key", "char_name", "chr_number", "chrb2name", "char_key", "char_id", "chr_label", "chr_id", "chrb2number", "chrb2type", "chr2key", "chr2number", "chr2type", "chdr_label", "char_Name", "chr_type", "chrb_type", "chrb2key", "chr_Name", "chdr_Name", "chr_key", "chrb_name", "chr2name"], "label": ["binary", "message", "text", "abel", "block", "prefix", "layout", "id", "comment", "path", "description", "ref", " Label", "hide", "bean", "byte", "bel", "route", "lab", "eb", "bl", "display", "model", "config", "str", "ell", "loc", "fb", "title", "frame", "url", "align", "key", "address", "summary", "ind", "el", "channel", "error", "val", "br", "l", "ab", "pad", "desc", "col", " labels", "base", "unit", "info", "msg", "unknown", "null", "name", "dl", "data", "bad", "alias", "field", "Label", "list", "line"], "index": ["axis", "pos", "prefix", "block", "Index", "pointer", "type", "id", "weight", "connection", "alpha", "len", "ini", "instance", "new", "slice", "offset", "condition", "loc", "j", "position", "end", "array", "key", "address", "loop", "num", "ind", "length", "inc", "error", "point", "start", "col", "value", "section", "fix", "name", "page", "data", "count", "x", "ix", "str"]}}
{"project": "qemu", "commit_id": "8417cebfda193c7f9ca70be5e308eaa92cf84b94", "target": 1, "func": "static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)\n\n{\n\n    uint64_t start = MAX(r1.start, r2.start);\n\n    /* off-by-one arithmetic to prevent overflow */\n\n    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);\n\n    return addrrange_make(start, end - start + 1);\n\n}\n", "idx": 8592, "substitutes": {"r1": ["range1", "eOne", " r01", "range2", "r5", "sr5", "sr2", "e2", "rOne", "e01", "e1", " r3", "rsOne", "sr1", "rs3", "r3", "rs1", "R01", "R1", "range5", "R2", "ROne", "rs2", "sr01", "range01", "R3", "R5", " rOne", "r01", "rangeOne"], "r2": ["rb1", "rtwo", "rrtwo", " r6", "rr6", "rt182", "R182", "r182", "rttwo", "ar2", "rr2", "arSecond", " rtwo", "rcII", "rb6", "rr1", "RII", " rSecond", "R1", "rc1", "R2", "rb2", "rtII", "rII", "rt1", "rc182", "ar1", "artwo", "rtSecond", "rSecond", "rt2", "rc2", "rbtwo", "r6"]}}
{"project": "FFmpeg", "commit_id": "7fffc879798bbbad647ad2b1b30f26855bf2abda", "target": 0, "func": "static int wc3_read_header(AVFormatContext *s,\n\n                           AVFormatParameters *ap)\n\n{\n\n    Wc3DemuxContext *wc3 = s->priv_data;\n\n    ByteIOContext *pb = s->pb;\n\n    unsigned int fourcc_tag;\n\n    unsigned int size;\n\n    AVStream *st;\n\n    unsigned char preamble[WC3_PREAMBLE_SIZE];\n\n    int ret = 0;\n\n    int current_palette = 0;\n\n    int bytes_to_read;\n\n    int i;\n\n    unsigned char rotate;\n\n\n\n    /* default context members */\n\n    wc3->width = WC3_DEFAULT_WIDTH;\n\n    wc3->height = WC3_DEFAULT_HEIGHT;\n\n    wc3->palettes = NULL;\n\n    wc3->palette_count = 0;\n\n    wc3->pts = 0;\n\n    wc3->video_stream_index = wc3->audio_stream_index = 0;\n\n\n\n    /* skip the first 3 32-bit numbers */\n\n    url_fseek(pb, 12, SEEK_CUR);\n\n\n\n    /* traverse through the chunks and load the header information before\n\n     * the first BRCH tag */\n\n    if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) !=\n\n        WC3_PREAMBLE_SIZE)\n\n        return AVERROR(EIO);\n\n    fourcc_tag = AV_RL32(&preamble[0]);\n\n    size = (AV_RB32(&preamble[4]) + 1) & (~1);\n\n\n\n    do {\n\n        switch (fourcc_tag) {\n\n\n\n        case SOND_TAG:\n\n        case INDX_TAG:\n\n            /* SOND unknown, INDX unnecessary; ignore both */\n\n            url_fseek(pb, size, SEEK_CUR);\n\n            break;\n\n\n\n        case _PC__TAG:\n\n            /* need the number of palettes */\n\n            url_fseek(pb, 8, SEEK_CUR);\n\n            if ((ret = get_buffer(pb, preamble, 4)) != 4)\n\n                return AVERROR(EIO);\n\n            wc3->palette_count = AV_RL32(&preamble[0]);\n\n            if((unsigned)wc3->palette_count >= UINT_MAX / PALETTE_SIZE){\n\n                wc3->palette_count= 0;\n\n                return -1;\n\n            }\n\n            wc3->palettes = av_malloc(wc3->palette_count * PALETTE_SIZE);\n\n            break;\n\n\n\n        case BNAM_TAG:\n\n            /* load up the name */\n\n            if ((unsigned)size < 512)\n\n                bytes_to_read = size;\n\n            else\n\n                bytes_to_read = 512;\n\n            if ((ret = get_buffer(pb, s->title, bytes_to_read)) != bytes_to_read)\n\n                return AVERROR(EIO);\n\n            break;\n\n\n\n        case SIZE_TAG:\n\n            /* video resolution override */\n\n            if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) !=\n\n                WC3_PREAMBLE_SIZE)\n\n                return AVERROR(EIO);\n\n            wc3->width = AV_RL32(&preamble[0]);\n\n            wc3->height = AV_RL32(&preamble[4]);\n\n            break;\n\n\n\n        case PALT_TAG:\n\n            /* one of several palettes */\n\n            if ((unsigned)current_palette >= wc3->palette_count)\n\n                return AVERROR_INVALIDDATA;\n\n            if ((ret = get_buffer(pb,\n\n                &wc3->palettes[current_palette * PALETTE_SIZE],\n\n                PALETTE_SIZE)) != PALETTE_SIZE)\n\n                return AVERROR(EIO);\n\n\n\n            /* transform the current palette in place */\n\n            for (i = current_palette * PALETTE_SIZE;\n\n                 i < (current_palette + 1) * PALETTE_SIZE; i++) {\n\n                /* rotate each palette component left by 2 and use the result\n\n                 * as an index into the color component table */\n\n                rotate = ((wc3->palettes[i] << 2) & 0xFF) |\n\n                         ((wc3->palettes[i] >> 6) & 0xFF);\n\n                wc3->palettes[i] = wc3_pal_lookup[rotate];\n\n            }\n\n            current_palette++;\n\n            break;\n\n\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"  unrecognized WC3 chunk: %c%c%c%c (0x%02X%02X%02X%02X)\\n\",\n\n                preamble[0], preamble[1], preamble[2], preamble[3],\n\n                preamble[0], preamble[1], preamble[2], preamble[3]);\n\n            return AVERROR_INVALIDDATA;\n\n            break;\n\n        }\n\n\n\n        if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) !=\n\n            WC3_PREAMBLE_SIZE)\n\n            return AVERROR(EIO);\n\n        fourcc_tag = AV_RL32(&preamble[0]);\n\n        /* chunk sizes are 16-bit aligned */\n\n        size = (AV_RB32(&preamble[4]) + 1) & (~1);\n\n\n\n    } while (fourcc_tag != BRCH_TAG);\n\n\n\n    /* initialize the decoder streams */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    wc3->video_stream_index = st->index;\n\n    st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_XAN_WC3;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n    st->codec->width = wc3->width;\n\n    st->codec->height = wc3->height;\n\n\n\n    /* palette considerations */\n\n    st->codec->palctrl = &wc3->palette_control;\n\n\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    wc3->audio_stream_index = st->index;\n\n    st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n    st->codec->codec_id = CODEC_ID_PCM_S16LE;\n\n    st->codec->codec_tag = 1;\n\n    st->codec->channels = WC3_AUDIO_CHANNELS;\n\n    st->codec->bits_per_sample = WC3_AUDIO_BITS;\n\n    st->codec->sample_rate = WC3_SAMPLE_RATE;\n\n    st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n        st->codec->bits_per_sample;\n\n    st->codec->block_align = WC3_AUDIO_BITS * WC3_AUDIO_CHANNELS;\n\n\n\n    return 0;\n\n}\n", "idx": 8617, "substitutes": {"s": ["support", "g", "os", "f", "service", "its", "cs", "ls", "sf", "ss", "c", "sq", "sup", "an", "services", "sv", "sb", "p", "ts", "sci", "sg", "si", "S", "ds", "b", "fs", "ssl", "sis", "sl", "se", "ns", "v", "spec", "t", "ps", "ses", "sc", "gs", "m", "e", "n", "sys", "su", "sa", "aws"], "ap": ["arp", "np", "tp", "att", "api", " p", "pl", "mp", "al", "jp", "au", "p", "aps", "sp", "pi", "cp", "ar", "pac", "op", "ac", "attr", "wp", "am", "pp", "ab", "pa", "AP", "cap", "bp"], "wc3": [" wdc03", "twlc53", "wc53", "wenc03", "hwrcthree", "wcgent", "ewc2", "wtc03", "wcf3", "wec13", "wcathree", "wrc3", "wmc03", "wfc23", "wacthree", "wc6", "wlc15", "Wac3", "wincpthree", "wenc53", "hwc03", "twc93", "wslc03", "wpc3", "wslc15", "ewdc5", "wc2", "wpc1", "wpc2", "wac03", "welc03", "wec23", "wdc23", "Wc3", "wrc4", "wdcry", "wdc03", "wtc53", "ewfc03", "ewdc3", "wc03", "wslc1", "wvc53", "twlc03", "wac3", " wdc1", "wcry", "Wcthree", "ewc2003", "wsc13", "wlcgent", "wcp3", "wtc1", "wvc5", "winc03", "wpc15", "wlc6", "wencthree", "wvc2003", "twlc93", "wvcgent", "wca03", "wdc5", "wcs15", "wdc3", "wlc93", "wf03", "winc3", "twlc15", "wec2003", "twc3", "wedc03", "wfc93", "wcdef", "wsc53", "ewc53", "welc13", "wdc6", "wec53", "wfc3", "wrcthree", "wtc93", "hwrc03", "welcdef", "ewfc2", "ewdc2003", "wcfgent", "wincthree", "wcs03", "twcgent", "wedc53", "wfc2", "wc93", "wdc1", "wfc03", "wdc2003", "wvc15", "wdc53", "wfcthree", "wac53", "wcthree", "ewfc3", "wcp03", "ewc5", "wcpgent", "wc5", "wc15", "hwrc4", "wdc2", "ewc03", "wcs1", "twc15", "wpc53", "wc13", "wec5", "wsc15", "ewfc53", "wcf03", "wfc4", "wincgent", "wlc3", "wlc03", "welc3", "wcpthree", "wdcdef", "ewdc03", "wfthree", "wlcdef", "wtcry", "wslc3", "wpc03", "wsc03", "wedc6", "wmc53", "wincp3", "wdc13", "wincp03", "twc03", "ewc3", "wsc3", "wmc23", "wec6", "wf3", "Wc53", "wfgent", "wvcdef", "wmc3", "twc53", "wlc53", "wca3", "Wc03", "welc53", "wcfthree", "Wac53", "wca4", " wdc3", "wvc3", "wtc3", "wec3", "wcs3", "wlcthree", "hwc4", "wedc3", " wc03", "Wac03", "wvc03", "wincpgent", "wcf15", "wc4", "Wacthree", "hwcthree", "wc1", "twlc3", " wdcry", "wec03", " wc1", "wlc13", "hwc3", "wecdef", " wcry", "wsc1", "wedc23", "wc2003", "hwrc3", "wec1", "wlc1", "wecry", "wenc3", "twlcgent", "wrc03", "wc23", "wfc53"], "pb": ["param", "plugin", "prop", "bos", "np", "tp", "pg", "abc", "ctx", "dp", "bm", "pm", "api", "pl", "proc", "ppa", "bc", "rob", "bps", "db", "pc", "lb", "eb", "jp", "params", "sb", "lp", "pd", "cpp", "p", "cb", "ib", "pkg", "asm", "b", "fb", "cp", "bh", "ub", "gb", "pt", "rb", "fp", "summary", "hub", "fc", "prot", "bb", "xb", "platform", "vp", "ab", "buffer", "pa", "ob", "wb", "bp", "py", "dl", "bf", "PB", "ba"], "fourcc_tag": ["fourcc_option", "fourCC_bug", "fourkk_tag", "fourCC_tag", "fourcc_TAG", "fourcc_num", "fourCC_option", "fourcc_bug", "fourkk_TAG", "fourCC_type", "fourcc_type", "fourCC_num", "fourkk_type"], "size": ["big", "timeout", "SIZE", "capacity", "max", "len", "c", "en", "small", "p", "offset", "si", "fee", "loc", "extra", "use", "shape", "style", "scale", "ize", "address", "code", "Size", "length", "l", "iz", "e", "unit", "n", "storage", "large", "sec", "mini", "six", "name", "page", "data", "x", "sum"], "st": ["sth", " ss", "src", "ss", "ft", "art", "bl", "rss", "ts", "sta", "ste", "ST", "sts", "nd", "ct", "sl", "ut", "std", "sc", "ast", "St", "storage", "rest", "sa", "inst", "str"], "preamble": ["Preamette", "pREAMble", "Prambler", "pramBLE", "Praml", "pounle", "pREAMbles", "pREAMl", "preamll", "pramble", "prambles", "prumbled", "poonle", " Prumbled", "pirmette", "PREAMbled", "PREAMle", "pipherle", "pramle", " Prumill", " Preambled", "pirmble", "pREAMette", "prambled", "praml", "parenle", "prumill", "pREAMBLE", "pREAMler", "parenill", " Preamle", "preambler", "pirmler", "pREAMbled", "preambles", "Preambler", "pepble", "pipherette", "preamler", "prumble", "pepbled", "pipherback", "Preamle", "Preamll", "Pramble", "Prambles", "peple", "pipherbler", "Pramette", "pramll", "pipherll", "Preamble", "Preaml", " Preamble", "PreamBLE", "parenble", "preamle", "pounll", "pounette", "pirmle", "Pramll", "PREAMl", "prumle", "Preambles", "Pramle", "poonbler", "preamback", "PREAMble", "pramback", "pepl", "pounble", "pramette", "parenbled", " Prumle", "pirml", " Preamill", "preaml", "pepill", "pREAMle", "pipherble", "preamBLE", "PramBLE", "preamill", "Preamback", "prambler", "pirmbles", "Preambled", "pramler", "Pramler", "Preamler", "Pramback", "pirmBLE", " Prumble", "poonble", "preamette", "preambled", "poonback"], "bytes_to_read": ["bytes_to_load", "bytes_per_load", "bytes_to_write", "bytes_per_read", "bytes_per_length", "bytes_per_write", "bytes_to_length"], "i": ["ii", "ni", "f", "id", "I", "limit", "ip", "x", "len", "iter", "p", "offset", "si", "pi", "io", "j", "in", "ti", "di", "ui", "start", "index", "n", "info", "ai", "uni", "slice", "it"], "rotate": ["otate", "rotation", "orientation", "Rotant", "rotant", "otant", "orientate", "Rotation", "orientant", "orientated", "otation", "Rotate", "otated", "rotated", "Rotated"], "current_palette": ["current_opaless", "current_pixelettes", "current_aless", "current_alette", "current_alettes", "current_opalettes", "current_palignment", "current_palettes", "current_paless", "current_pixelignment", "current_opalette", "current_alignment", "current_pixeless", "current_pixelette", "current_opalignment"]}}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static int64_t do_strtosz(const char *nptr, char **end,\n\n                          const char default_suffix, int64_t unit)\n\n{\n\n    int64_t retval;\n\n    char *endptr;\n\n    unsigned char c;\n\n    int mul_required = 0;\n\n    double val, mul, integral, fraction;\n\n\n\n    errno = 0;\n\n    val = strtod(nptr, &endptr);\n\n    if (isnan(val) || endptr == nptr || errno != 0) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    fraction = modf(val, &integral);\n\n    if (fraction != 0) {\n\n        mul_required = 1;\n\n    }\n\n    c = *endptr;\n\n    mul = suffix_mul(c, unit);\n\n    if (mul >= 0) {\n\n        endptr++;\n\n    } else {\n\n        mul = suffix_mul(default_suffix, unit);\n\n        assert(mul >= 0);\n\n    }\n\n    if (mul == 1 && mul_required) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    if ((val * mul >= INT64_MAX) || val < 0) {\n\n        retval = -ERANGE;\n\n        goto out;\n\n    }\n\n    retval = val * mul;\n\n\n\nout:\n\n    if (end) {\n\n        *end = endptr;\n\n    } else if (*endptr) {\n\n        retval = -EINVAL;\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 8673, "substitutes": {"nptr": ["endpointer", "endPtr", "entr", "NPtr", "enptr", "npointer", "neptr", "startPtr", "startpt", "Npointer", "ntpointer", "startptr", "ntptr", "enpt", "ntPtr", "netr", " npointer", "enpointer", "ntpt", "npt", "startpointer", " npt", "ntr", " nPtr", "nPtr", "nepointer", "Ntr", "Npt", "Nptr", "endpt", "nept"], "end": ["ension", "pos", "append", "id", "max", "api", "update", "edge", "ended", "pend", "en", "close", "enable", "enc", "after", "offset", "END", "ent", "ep", "change", "End", "and", "use", "ending", "open", "est", "begin", "z", "add", "address", "entry", "vert", "ind", "all", "start", "index", "last", "desc", "e", "obj", "set", "ad", "send", "stop", "post"], "default_suffix": ["default_suffprefix", "default_sfix", "default_protfix", "default_protix", "default_sffix", "default_prefixrix", "default_appendprefix", "default_deffix", "default_suffixed", "default_prefixprefix", "default_appendfix", "default_defix", "default_prefixix", "default_suffence", "default_defence", "default_prefixixed", "default_protprefix", "default_sfence", "default_prefixfix", "default_sufffix", "default_protrix", "default_prefixence", "default_defixed", "default_appendrix", "default_suffrix", "default_sfixed", "default_appendix"], "unit": ["axis", "version", "text", "prefix", "type", "un", "format", "attribute", "class", "byte", "option", "module", "method", "config", "unct", "term", "temp", "normal", "Unit", "category", "currency", "units", "position", "domain", "fc", "parent", " units", "dim", "u", "component", "dimension", "base", "init", "crit", "custom", "lc", "null", "name", "uni", "element", "data", "number"], "retval": ["RETval", " reteval", "RETcall", "rtv", "Retval", " retvalid", "Retvalid", "retvalid", "RETobj", "exitvalue", "pretval", "defval", " retvals", "returnvalue", "retcall", "pretvalue", "retVAL", "returnVal", "rtobj", "altval", " retcall", "returnvals", "retVal", "retvals", "returnval", "Retvalue", " retVal", "exitVAL", "rtVAL", "altvalue", " retsel", "altVal", "retv", "Retv", "altvals", "rteval", "pretsel", "reteval", "exitval", "rtvalid", "altVAL", "pretvalid", "defeval", "returnVAL", "altsel", "retsel", "Reteval", "exiteval", "RETVAL", "altvalid", " retvalue", "rtval", "RETvalue", "defvalid", "returneval", "exitobj", "retvalue", "RETeval", "rtvalue", "exitvalid", "alteval", "defv", "rtcall", "retobj"], "endptr": ["endpointer", "endPtr", "startpointers", "startpoint", "endedpoint", "npointer", "endedPtr", "endpt", "starttr", "offsetpointer", "idproc", "estproc", "startpt", "endaddr", "startptr", "endedpointer", " endpointer", " endpointers", "endpointers", "endedtr", "endtr", "offsettr", "offsetaddr", "startaddr", " endproc", "ndpointer", " endpoint", "ndptr", "ndfp", "endedptr", "endedproc", "endedfp", "endproc", "idpointer", " endpt", "startpointer", "estpointers", "nPtr", "nfp", " endaddr", "startproc", "estpointer", "ndPtr", "estptr", "offsetptr", "idptr", "endpoint", "idpt", "endedaddr", "endfp"], "c": ["chain", "ctx", "f", "unc", "abc", "k", "xc", "cs", "nc", "bc", "pc", "cmp", "i", "d", "cat", "p", "cur", "b", "cy", "cm", "cu", "ct", "con", " rc", "cc", "v", "fc", "C", "ac", "dc", "t", "r", "o", "l", "ci", "cf", "u", "cr", "m", "col", "e", "n", "cn", "lc", "mc", "ec", "count", "x", "cache"], "val": ["vol", "valid", "li", "abc", "f", "vec", "vals", "err", "elt", "ref", "update", "flo", "serv", "sel", "min", "ul", "bc", "len", "vel", "al", "au", "d", "eval", "bl", "pr", "p", "ol", "fee", "b", "Val", "fl", "fb", "ct", "cal", "grad", "pt", "VAL", "sl", "pre", "rule", "v", "ee", "fc", "bal", "rot", "ac", "ind", "el", "r", "rel", "_", "l", "def", "cond", "cel", "lib", "m", "ve", "e", "base", "aval", "value", "il", "py", "bf", "data", "exec", "x"], "mul": ["Mlu", "tmUL", "pult", "umule", "mall", "cmal", "hmul", "mUL", "mmul", "Mull", "manulus", "vula", " muli", "amUL", "vul", "vull", "amil", "manall", "mmulus", "mlu", "mal", " mlu", "tmal", " mult", "muli", "mulator", "amlu", "hmulator", " mUL", " mulator", "mulus", "hmoul", " mulo", "vule", "cmull", "mulo", "mult", "imuli", " mulus", "imula", "mull", "mule", "amull", "pulus", "cmil", "Mul", "moul", "mula", "hmuli", " mall", "cmUL", "mil", "cmulo", "mmull", "MUL", "Mulo", "pul", "amul", "manuli", "pull", "umula", " moul", "umull", "umoul", "cmul", "mmult", "umul", "imul", "manul", "imule", "umuli", " mull", "umulator", "tmul", "Mil", "imall", "tmull", "Mal", "imulus", "imull"], "integral": ["integeral", "Integrier", "extrals", " integraction", "citrals", "extrier", "infric", "integrier", "Integral", "Integraction", "citral", "Integrals", " integric", "incric", "citrier", "infral", "extral", "integrals", "integric", "infraction", " integeral", "extraction", "incraction", "integraction", "inferal", "incral", "inceral", "citraction"], "fraction": ["extault", "fractions", "infract", " fancy", "dault", "extancy", "influx", "fract", "rflux", "infletcher", " fault", "fletcher", "Fraction", "Flux", "extletcher", "rfraction", "extract", "infractions", "infancy", "fault", "rfractions", "Fract", "dletcher", "fancy", "flux", "dract", "infraction", "infault", "extraction", " fract", "rfract", "Fractions", "draction"]}}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int check_refcounts_l1(BlockDriverState *bs,\n\n                              BdrvCheckResult *res,\n\n                              uint16_t **refcount_table,\n\n                              int64_t *refcount_table_size,\n\n                              int64_t l1_table_offset, int l1_size,\n\n                              int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table = NULL, l2_offset, l1_size2;\n\n    int i, ret;\n\n\n\n    l1_size2 = l1_size * sizeof(uint64_t);\n\n\n\n    /* Mark L1 table as used */\n\n    ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                        l1_table_offset, l1_size2);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Read L1 table entries from disk */\n\n    if (l1_size2 > 0) {\n\n        l1_table = g_try_malloc(l1_size2);\n\n        if (l1_table == NULL) {\n\n            ret = -ENOMEM;\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        ret = bdrv_pread(bs->file, l1_table_offset, l1_table, l1_size2);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        for(i = 0;i < l1_size; i++)\n\n            be64_to_cpus(&l1_table[i]);\n\n    }\n\n\n\n    /* Do the actual checks */\n\n    for(i = 0; i < l1_size; i++) {\n\n        l2_offset = l1_table[i];\n\n        if (l2_offset) {\n\n            /* Mark L2 table as used */\n\n            l2_offset &= L1E_OFFSET_MASK;\n\n            ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                                l2_offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            /* L2 tables are cluster aligned */\n\n            if (offset_into_cluster(s, l2_offset)) {\n\n                fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"\n\n                    \"cluster aligned; L1 entry corrupted\\n\", l2_offset);\n\n                res->corruptions++;\n\n            }\n\n\n\n            /* Process and check L2 entries */\n\n            ret = check_refcounts_l2(bs, res, refcount_table,\n\n                                     refcount_table_size, l2_offset, flags);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n    g_free(l1_table);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(l1_table);\n\n    return ret;\n\n}\n", "idx": 8707, "substitutes": {"bs": ["bos", "als", "os", "bis", "cs", "ls", "ss", "bc", "BS", "pb", "bps", "db", "ks", "lb", "ins", "bl", "sb", "rss", "bytes", "fps", "http", "iss", "ds", "b", "bes", "fs", "fb", "outs", "bh", "gb", "ns", "ms", "css", "bi", "us", "bb", "ras", "bing", "ses", "gs", "org", "ros", "ubs", "base", "las", "bits", "sys", "rs", "bas", "obs", "lbs", "js", "ec", "vs"], "res": ["rus", "Resp", "bis", "resp", "re", "vals", "err", "resolution", "rev", "proc", "result", "rez", "mr", "ver", "ex", "sr", "RES", "rc", "rss", "des", "response", "reset", "details", "Rs", "results", "rem", "gen", "RS", "pres", "spec", "ms", "ras", "rx", "r", "rel", "resource", "val", "req", "def", "rep", "resources", "ress", "Res", "ry", "gr", "conf", "ros", "obj", "sys", "rs", "reg", "rh", "rest", "js", "rates"], "refcount_table": ["refcount__cache", "refcountableTABLE", "refcountingtree", "refcount_tree", "refcacheingdirectory", "refcount_address", "refcache_directory", "refount_db", "refcountjdatabase", "refprocessingtree", "refcountPservice", "refcount_array", "refount_count", "refcount_service", "refcount__table", "refcountingaddress", "refcount_cache", "refcountPsession", "refprocessingtable", "refcount_database", "refcountingdb", "refcount_directory", "refcacheingarray", "refprocessingTABLE", "refcountPdatabase", "refcountjtable", "refcountingsession", "refprocess_address", "refount_table", "refcountingdirectory", "refcountjdirectory", "refcache_table", "refcount_count", "refcount_TABLE", "refcountPtable", "refprocess_tree", "refcount__db", "refcountabletable", "refcacheingtable", "refount_cache", "refcountingdatabase", "refcacheingdatabase", "refcache_database", "refcount__count", "refcountableaddress", "refprocess_TABLE", "refcount_session", "refcache_array", "refcountjaddress", "refcount_db", "refcountingtable", "refprocess_table", "refcountingarray", "refcountjtree", "refcountjarray", "refcountingcount", "refcountjTABLE", "refprocessingaddress", "refcountabletree", "refcountingservice", "refcountingTABLE", "refcountingcache"], "refcount_table_size": ["refcount_cache_size", "rel\n", "refcount_table_SIZE", "reference\n", " ref\n", "refcount_table_address", "refcount_table_name", "refcount_database_scale", "refcount_cache_SIZE", "refcount_cache_sum", "refcount_database_name", "refcount_table_sum", "refcount_table_scale", "refcount_database_size", "refcount_database_address", "refcount_cache_name", "ref\n", "refcount_table_offset", "refcount_cache_scale", "refcount_cache_offset"], "l1_table_offset": ["l1_table_sort", "l1_cache_offset", "l1_table\u00b7sort", "l1_cache_address", "l1_cache_start", "l1_table2offset", "l1_table_adjust", "l1_cache_sort", "l1_table_start", "l1_table_address", "l1_table2sort", "l1_file_size", "l1_cache_slot", "l1_table_slot", "l1_file_adjust", "l1_table\u00b7offset", "l1_table2slot", "l1_table\u00b7slot", "l1_file_start", "l1_cache_size", "l1_file_offset", "l1_table_size", "l1_table2size", "l1_table\u00b7size"], "l1_size": ["l1ntimeout", "l1nsize", "l0nmode", "l1noffset", "l1_si", "l0_mode", "l1_mode", "l0noffset", "l4_si", "l0_scale", "l1nscale", "l4_scale", "l1_scale", "l0_size", "l1Fsize", "l1Fcapacity", "l0_offset", "l4_offset", "l0nsize", "l4_size", "l0_set", "l4_capacity", "l1_timeout", "l1_set", "l1_offset", "l1Fsi", "l1_capacity", "l4_timeout", "l1nmode", "l1Fscale"], "flags": ["debug", "lag", "rets", "args", "file", "len", " flag", "rc", " fs", "options", "fun", "fs", "flag", "files", "bit", "rep", "mask", " bits", "bits", "util", "reg", "Flags", "status", "stats", "ops", "features"], "s": ["server", "g", "os", "f", "bis", "service", "its", "cs", "state", "ls", "self", "ss", "states", "c", "is", "services", "p", "ts", "si", "http", "S", "ds", "b", "settings", "fs", "ssl", "session", "details", "scope", "sl", "ns", "spec", "r", "ps", "ses", "qs", "gs", "sys", "sets", "su", "rs", "sa", "js", "status", "stats", "vs"], "l1_table": ["l1___tree", "l2_table", "l1ntable", "l8_size", "l1_server", "lOne_server", "l3_cache", "l8_cache", "lOne_tree", "l4_header", "l1___server", "l1_body", "lfirst_body", "lfirst_comment", "l1___template", "l1Jcache", "l1___table", "l4_table", "l1Jtable", "l8_table", "l1Jbody", "l1___length", "lfirst_column", "l2_size", "l1_tree", "l1_TABLE", "l1nbody", "lfirst_table", "l4_size", "lOne_table", "l3_body", "l1ncolumn", "l1___header", "l1_comment", "l1_template", "l1___size", "l1_offset", "l4_length", "l3_TABLE", "l1_header", "l2_cache", "l1_column", "lOne_template", "l1JTABLE", "l1_cache", "l8_file", "l1_length", "l3_table", "l1ncomment", "l1_file"], "l2_offset": ["l2foffset", "l2fsize", "l3_offset", "l2_address", "l2__address", "l2__slot", "l0__offset", "l1_address", "l2fslot", "l2_left", "l0fsize", "l1_Offset", "l2xloc", "l1_shift", "l2_error", "l3_size", "l0_slot", "l3_id", "l2faddress", "l0foffset", "l3_left", "l2Foffset", "l1_error", "l0__address", "l2xaddress", "l0faddress", "l2xOffset", "l2Fleft", "l0__error", "l0_error", "l2_Offset", "l0_size", "l3_error", "l2_loc", "l2_size", "l2_origin", "l2xoffset", "l2xshift", "l0fslot", "l0_offset", "l2__error", "l2serror", "l0_point", "l2saddress", "l2_id", "l2Fsize", "l2__size", "l2xsize", "l2_point", "l2Fid", "l2_shift", "l1_offset", "l3_origin", "l2__offset", "l2xslot", "l2_slot", "l0_address", "l1_loc", "l0__point", "l2soffset", "l2spoint", "l2__point"], "l1_size2": ["l1_width2", "l1_scale4", "l1_sizeALL", "l1_value132", "l1_size12", "l1_size5", "l1_size132", "l1_capacity2", "l1_size4", "l1_width1", "l1_scale1", "l1Psize2", "l1_count02", "l1_length2", "l1_group2", "l1Pvalueless", "l1_length12", "l1_countless", "l1Psize132", "l1_length1", "l1Pvalue02", "l1_count132", "l1_capacity1", "l1_length02", "l1_sized5", "l1_valueless", "l1_sized2", "l1_size1", "l1_sizeii", "l1_length4", "l1_scale2", "l1_capacity02", "l1_sizedii", "l1_scale132", "l1_count2", "l1Psize02", "l1_contentii", "l1Psizeless", "l1Pvalue132", "l1_value2", "l1_size02", "l1_scale12", "l1_groupii", "l1Pvalue2", "l1_sizedALL", "l1_scaleless", "l1_group5", "l1_scale02", "l1_sizeless", "l1_content5", "l1_contentALL", "l1_groupALL", "l1_content2", "l1_value02"], "i": ["ii", "ni", "li", "uri", "hi", "f", "type", "at", "id", "phi", "I", "mu", "ip", "mi", "fi", "result", "y", "len", "yi", "c", "iu", "en", "ini", "sup", "ki", "multi", "h", "slice", "p", "ri", "si", "z", "split", "b", "pi", "io", "j", "gi", "ie", "key", "di", "code", "zi", "ti", "bi", "xi", "qi", "t", "r", "ui", "ind", "l", "ci", "u", "index", "m", "e", "n", "info", "ai", "out", "mini", "eni", "x", "ix"], "ret": ["sur", "usr", "valid", "pass", "rets", "rt", "att", "match", "resp", "re", "RET", "feat", "ref", "err", "rev", "ft", "result", "success", "lt", "len", "en", "art", "ben", " Ret", "bl", "cat", "back", "fun", "lit", "flag", "bit", "pt", "ext", "mt", "red", "rb", "ut", "gt", "part", "rot", "fail", "opt", "val", "det", "rep", "def", "pet", "conn", "bin", "job", "arg", "reply", "fit", "obj", "reg", "nt", "alt", "Ret", "bf", "count", "let"], "check_errors": ["get_details", "checkingerrors", "check_changes", "checkingdetails", "check_rors", "call_rors", "getingfiles", "call_changes", "call_times", "get_errors", "check_details", "checkingfiles", "check_files", "checkingcodes", "get_codes", "getingdetails", "get_files", "getingcodes", "getingerrors", "check_codes", "call_errors", "check_times"], "corruptions": ["corruption", "corrotion", "corrition", "corrogions", "corrotips", "corriture", "corrogion", "corrupture", "morrupture", "morruptions", "corruptips", "corrogure", "morrition", "morritions", "corrogips", "morritips", "corrotions", "corritips", "corroture", "morruption", "morruptips", "corritions", "morriture"]}}
{"project": "qemu", "commit_id": "5a1972c8472fafd519a68b689fdcaf33ec857945", "target": 1, "func": "static uint32_t dcr_read_pob (void *opaque, int dcrn)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n    uint32_t ret;\n\n\n\n    pob = opaque;\n\n    switch (dcrn) {\n\n    case POB0_BEAR:\n\n        ret = pob->bear;\n\n        break;\n\n    case POB0_BESR0:\n\n    case POB0_BESR1:\n\n        ret = pob->besr[dcrn - POB0_BESR0];\n\n        break;\n\n    default:\n\n        /* Avoid gcc warning */\n\n        ret = 0;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 8720, "substitutes": {"opaque": ["depacity", "ipopaque", "spaque", "opacity", "ipopaques", "oaque", "pophole", "ipopque", "depaque", "ipacity", "ipopacity", "popacle", "spacity", "oacity", "ohole", "sphole", "popacity", "ipaque", "ophole", "ipque", "depque", "oacle", "ipaques", "opaques", "opque", "opacle", "popaque", "spacle", "depaques"], "dcrn": [" dcrns", "drcN", "drcl", "drcns", "dCRb", " dcrnt", "dCrn", " dctrn", " dctrnc", "DcrN", "Dcrl", "dCrl", "dhrb", " dctrb", "Drcns", "dCRnc", "dcrb", "dcrens", "Dcrns", "dcrel", " dcrN", "Dcrn", "dcrnt", "dctrnc", " dctrnt", "drcn", "Drcn", "dcrl", "dcren", " dcrb", "dhrnt", "dCRnt", "dcrenn", "dctrn", " dcrnn", "dCRn", "dhrnc", "dctrb", "Drcl", "dhrn", " dcrnc", "dcrnn", "dCrN", "dcrN", "dcrns", "dcreN", "dCrnn", "dcrnc", "dctrnt", "DrcN", "dCrns"], "pob": [" pub", "Pib", "pobb", "apob", "apoy", "bob", "pub", "cpoc", "boby", "Pobb", "tib", " pib", "poy", "Poby", "cpob", "opobb", "pib", "Poc", "cpab", "bab", "boy", "Poy", "poc", "Pob", " pab", "POB", "pOB", "tOB", "Pub", " pOB", "opOB", "tab", "opob", "Pab", "apoby", " poc", "cpub", "pab", " pobb", "opab", "poby", "tob", "apab"], "ret": ["valid", "pass", "rets", "rt", "match", "re", "RET", "ref", "rev", "ft", "result", "success", "len", " Ret", " RET", "cat", "back", "fun", "lit", "flag", "bit", "ext", "ut", "key", "code", "gt", "mem", "val", "det", "pet", "def", "force", "hard", "bf", "arg", "reply", "base", "pat", "info", "value", "res", "out", "reg", "nt", "alt", "Ret", "status", "data", "feat"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_erase(OneNANDState *s, int sec, int num)\n\n{\n\n    uint8_t *blankbuf, *tmpbuf;\n\n    blankbuf = g_malloc(512);\n\n    if (!blankbuf) {\n\n        return 1;\n\n    }\n\n    tmpbuf = g_malloc(512);\n\n    if (!tmpbuf) {\n\n        g_free(blankbuf);\n\n        return 1;\n\n    }\n\n    memset(blankbuf, 0xff, 512);\n\n    for (; num > 0; num--, sec++) {\n\n        if (s->bdrv_cur) {\n\n            int erasesec = s->secs_cur + (sec >> 5);\n\n            if (bdrv_write(s->bdrv_cur, sec, blankbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n            if (bdrv_read(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n            memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4);\n\n            if (bdrv_write(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n        } else {\n\n            if (sec + 1 > s->secs_cur) {\n\n                goto fail;\n\n            }\n\n            memcpy(s->current + (sec << 9), blankbuf, 512);\n\n            memcpy(s->current + (s->secs_cur << 9) + (sec << 4),\n\n                   blankbuf, 1 << 4);\n\n        }\n\n    }\n\n\n\n    g_free(tmpbuf);\n\n    g_free(blankbuf);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(tmpbuf);\n\n    g_free(blankbuf);\n\n    return 1;\n\n}\n", "idx": 8755, "substitutes": {"s": ["server", "g", "tests", "os", "sym", "f", "site", "service", "its", "state", "ls", "self", "ss", "states", "uns", "private", "xs", "y", "c", "sq", "is", "ins", "services", "d", "sb", "new", "es", "p", "ts", "sg", "si", "S", "sie", "b", "ds", "session", "ssl", "http", "full", "fs", "se", "sl", "ns", "spec", "us", "o", "t", "r", "ps", "sites", "ses", "l", "your", "qs", "sync", "gs", "m", "conf", "as", "south", "e", "sets", "sys", "comments", "rs", "obs", "sa", "js", "stats", "ops"], "sec": ["ctr", "size", "f", "src", "proc", "comp", "Sec", "bc", "sub", "seq", "SEC", "c", "second", "sq", "exec", "ex", "sic", "config", "esc", "enc", "offset", "cur", "loc", "session", "lit", "seed", "year", "secret", "con", "ct", "secondary", "sect", "ext", "j", "se", "sector", "day", "code", "spec", "inc", "sy", "scroll", "length", "req", "win", "sc", "sync", "lib", "next", "rec", "acc", "desc", "conf", "col", "security", "sys", "secure", "crit", "section", "nt", "ec", "reg", "six", "isec", "feat", "seconds"], "num": ["ctr", "fn", "no", "un", "NUM", "on", "f", "nb", "bc", "seq", "ul", "len", "en", "off", "multi", "mod", "loc", "nom", "lit", "b", "ord", "nu", "con", "gen", "ng", "sim", "umi", "number", "mem", "inc", "lib", "sum", "common", "rec", "sn", "desc", "conf", "n", "unit", "su", "Num", "nt", "reg", "uni", "um", "nm"], "blankbuf": [" blankport", "blankcmd", "blankimg", " blankfd", "frontbuffer", "openbuff", "blankba", "blankBuffer", "kkbuff", "blankbc", " blankBuffer", "kkuf", "whiteuf", "blankoff", "tmpbc", "frontbuff", "openbuffer", "tmpoff", "blogbuf", "validbuffer", "spbytes", "frontbuf", "blankbytes", "blankbuff", "frontbc", "whitebuff", "blankuf", "nullbuff", "whitedb", "ankcf", "tmpbuff", "tmpuf", "frontcmd", "whitebuf", "ankdb", "ankcmd", " blankbuff", "blankport", " blankoff", "tmpbuffer", "ankBuffer", "nullfd", "whiteblock", "validbuf", "blogbuff", " blankalloc", "blogbc", " blankimg", "ankbuff", "ankba", "emptybuff", "nullbuffer", "tmpport", "blankdb", "nullbuf", " blankcmd", "openpath", " blankuf", "frontuf", " blankba", "emptybuf", "tmpcur", "frontcf", "blankalloc", "validbytes", "nulluf", "nullblock", "blogbuffer", "frontcur", "openblock", "blankblock", "spbuffer", "openbuf", "emptybuffer", "whiteba", " blankbuffer", "blankcur", "kkbuf", "spbuf", "validalloc", "tmpimg", "nullbc", "nullvec", "nullimg", " blankcur", "emptyuf", "nulldb", "whitebuffer", " blankcf", " blankbc", " blankpath", "ankbuf", "kkbuffer", "blankcf", "whitevec", "whitefd", "blankpath", "nulloff", "blankvec", "blankfd", " blankblock", "ankvec", "spalloc", "openuf", "frontport", "nullpath", " blankbytes", "whiteBuffer", "blankbuffer"], "tmpbuf": ["ownbuff", "frontuf", "mpbuffer", " tmpbuff", "blankcb", "tempbuf", "fakebuf", "fakebuff", "mpcb", " tmpbuffer", "frontbuffer", "fbcb", "blankuf", "flatbuf", "fbbuf", "tmpbuff", "tmpuf", "tempbuff", "frontwb", "tmpbag", "blankbag", "ownuf", "tempuf", "tmpbuffer", " tmpwb", "ownbuf", "ownwb", "fbwb", "blankwb", "frontbag", "mpbuf", " tmpcb", " tmpbag", "tmpcb", "frontbuff", "frontcb", "flatbuff", "fbbuff", "tempbuffer", "fbuf", "tmpwb", " tmpuf", "flatbuffer", "fakebuffer", "mpbuff", "fakeuf", "frontbuf", "blankbuff", "blankbuffer"]}}
{"project": "qemu", "commit_id": "ff74f33c310892c90c4439d963a6ce67f47ce18c", "target": 1, "func": "static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n\n                              const char *desc_file_path, Error **errp)\n\n{\n\n    int ret;\n\n    char access[11];\n\n    char type[11];\n\n    char fname[512];\n\n    const char *p = desc;\n\n    int64_t sectors = 0;\n\n    int64_t flat_offset;\n\n    char extent_path[PATH_MAX];\n\n    BlockDriverState *extent_file;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    VmdkExtent *extent;\n\n\n\n    while (*p) {\n\n        /* parse extent line:\n\n         * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET\n\n         * or\n\n         * RW [size in sectors] SPARSE \"file-name.vmdk\"\n\n         */\n\n        flat_offset = -1;\n\n        ret = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64,\n\n                access, &sectors, type, fname, &flat_offset);\n\n        if (ret < 4 || strcmp(access, \"RW\")) {\n\n            goto next_line;\n\n        } else if (!strcmp(type, \"FLAT\")) {\n\n            if (ret != 5 || flat_offset < 0) {\n\n                error_setg(errp, \"Invalid extent lines: \\n%s\", p);\n\n                return -EINVAL;\n\n            }\n\n        } else if (!strcmp(type, \"VMFS\")) {\n\n            if (ret == 4) {\n\n                flat_offset = 0;\n\n            } else {\n\n                error_setg(errp, \"Invalid extent lines:\\n%s\", p);\n\n                return -EINVAL;\n\n            }\n\n        } else if (ret != 4) {\n\n            error_setg(errp, \"Invalid extent lines:\\n%s\", p);\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (sectors <= 0 ||\n\n            (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&\n\n             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||\n\n            (strcmp(access, \"RW\"))) {\n\n            goto next_line;\n\n        }\n\n\n\n        path_combine(extent_path, sizeof(extent_path),\n\n                desc_file_path, fname);\n\n        extent_file = NULL;\n\n        ret = bdrv_open(&extent_file, extent_path, NULL, NULL,\n\n                        bs->open_flags | BDRV_O_PROTOCOL, NULL, errp);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        /* save to extents array */\n\n        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {\n\n            /* FLAT extent */\n\n\n\n            ret = vmdk_add_extent(bs, extent_file, true, sectors,\n\n                            0, 0, 0, 0, 0, &extent, errp);\n\n            if (ret < 0) {\n\n\n                return ret;\n\n            }\n\n            extent->flat_start_offset = flat_offset << 9;\n\n        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {\n\n            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/\n\n            char *buf = vmdk_read_desc(extent_file, 0, errp);\n\n            if (!buf) {\n\n                ret = -EINVAL;\n\n            } else {\n\n                ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, buf, errp);\n\n            }\n\n            if (ret) {\n\n                g_free(buf);\n\n\n                return ret;\n\n            }\n\n            extent = &s->extents[s->num_extents - 1];\n\n        } else {\n\n            error_setg(errp, \"Unsupported extent type '%s'\", type);\n\n\n            return -ENOTSUP;\n\n        }\n\n        extent->type = g_strdup(type);\n\nnext_line:\n\n        /* move to next line */\n\n        while (*p) {\n\n            if (*p == '\\n') {\n\n                p++;\n\n                break;\n\n            }\n\n            p++;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 8793, "substitutes": {"desc": ["text", "phrase", "dest", "src", "path", "description", "DES", "ref", "sub", "Description", "dist", "d", "esc", "config", "des", "rc", "Desc", "password", " description", "doc", "ext", "code", "dc", "attr", "def", "sc", "rec", "dep", "info", "lc", "sec", "meta", "uc", "name", "asc", "data", "priv", "dir"], "bs": ["bos", "os", "bis", "cs", "ls", "ss", "bc", "BS", "pb", "bps", "lb", "ins", "sb", "bl", "cb", "ds", "b", "bes", "fs", "fb", "bh", "gb", "rb", "ns", "bi", "us", "css", "bb", "ps", "ses", "ab", "gs", "base", "las", "bas", "rs", "obs", "js", "vs"], "desc_file_path": ["desc_file__name", "desc_file_url", "desc_full_url", "desc_file__patch", "desc_file_name", "desc_file___location", "desc_full_name", "desc_file_patch", "desc_file___name", "desc_file__path", "desc_file_location", "desc_file_pointer", "desc_file___url", "desc_full_path", "desc_file___path", "desc_full_patch", "desc_file__pointer", "desc_full_location", "desc_full_pointer"], "errp": ["rrp", "strr", "reqc", "erpre", "errc", "strp", "erpc", "reqg", "Erc", "strc", "rrg", "err", "erfp", "errorpc", " errpatch", "errP", "errorc", "ErP", "errr", " errc", "errorg", "errfp", "errpre", "erg", "errorfp", "errpatch", "reqfp", "errorp", "strg", "errg", "erp", "errorP", " errpc", "Erpre", " errr", "orderpatch", " errfp", "rrfp", "rrc", "errpc", "orderr", "errorr", "orderp", "erpatch", "erc", "errorpre", " errg", "erP", "orderfp", "Erp", "reqp"], "ret": ["rt", "re", "RET", "ref", "success", "lt", "art", " Ret", "rc", "orig", "mem", "arg", "pat", "info", "nt", "alt", "Ret", "status", "feat", "pass", "pub", "rets", "rev", "result", "cat", "back", "lit", "flag", "mt", "code", "num", "fail", "det", "base", "res", "reg", "str", "sur", "usr", "valid", "att", "len", " RET", "cur", "fun", "part", "reply", "fit", "count", "post", "match", "final", "ft", "al", "arr", "url", "ext", "bit", "gt", "t", "opt", "val", "try", "def", "obj", "bf", "data", "bot", "let"], "access": ["ga", "pass", "empty", "cast", "request", "mode", "id", "att", "src", "path", "view", "ref", "na", "class", "alpha", "option", "public", "a", "cache", "config", "esc", "auth", "ace", "condition", "input", "password", "expr", "qa", "connect", "use", "shape", "url", "test", "open", "array", "key", "address", "image", "ac", "parent", "length", "Access", "attr", "area", "error", "ACC", "source", "sc", "resource", "index", "select", "acc", "escape", "buffer", "reference", "ast", "accessible", "security", "secure", "ec", "sa", "uc", "name", "asc", "object", "acl"], "type": ["comment", "ref", "class", "option", "pre", "key", "address", "time", "area", "info", "token", "ype", "root", "status", "alias", "param", "size", "api", "user", "track", "non", "session", "Type", "shape", "test", "TYPE", "code", "pe", "op", "parent", "o", "length", "platform", "error", "attr", "sort", "call", "action", "block", "format", "y", "route", "by", "app", "total", "family", "source", "index", "value", "null", "name", "py", "post", "version", "path", "flow", "media", "label", "temp", "order", "full", "url", "style", "position", "domain", "share", "t", "level", "rel", "ty", "security", "python", "typ", "types", "field"], "fname": [" fName", "fcname", "FName", "Fname", "cname", "Fkey", "sfnames", "fcpath", " fpath", "cpath", "fcName", "Fnames", "fnames", "fprefix", "Fpath", "cnames", "fcprefix", " fnames", "fName", " fprefix", "sfname", "fkey", " fkey", "Fprefix", "fpath", "sfkey"], "p": ["g", "np", "tp", "f", "pointer", "path", "ip", "pl", "pb", "c", "pc", "a", "i", "jp", "d", "lp", "h", "pr", "sp", "b", "pi", "cp", "part", "P", "pre", "fp", "pe", "op", "v", "parent", "t", "r", "o", "error", "l", "q", "point", "vp", "pp", "ap", "m", "e", "n", "pa", "port", "bp", "python", "data"], "flat_offset": ["flat00Offset", "flat_alias", "flat_port", "flat00width", "flat___pos", "flat_Offset", "fixed64Offset", "slice_slot", "flat00offset", "fixed_Offset", "fixed_width", "plain_bit", "flat64size", " flat_start", "flat___size", "fixed_offset", "flat\u00b7port", "flat64alias", " flat_range", "flat___bit", "flat64offset", " flat_port", "flat_bit", "slice_offset", "flat64width", "flat___alias", "flat___position", "flat\u00b7range", "flat_left", "flat_width", "flat___offset", "fixed_position", "slice_off", "plain_pos", "slice_left", "flat_size", "flat\u00b7offset", "flat_range", "plain_alias", "flat___length", "flat\u00b7start", "flat_start", "flat00position", "fixed64position", "fixed64offset", "flat_length", "plain___pos", "flat_off", "fixed64width", "plain___bit", "plain___offset", "flat_pos", "flat_slot", "flat_position", "flat64position", "plain_length", "flat64Offset", "plain___length", "plain_size", "plain_position", "plain_offset"], "extent_path": ["extent__dir", "extension_dir", "extant_data", "extant_name", "extent_method", "extent__file", "extant_dir", "extant_path", "extension_method", "extent__path", "extension_path", "extent_dir", "extension_file", "extent_case", "extent__method", "extant_case", "extent_name", "extant_file", "extent_data"], "extent_file": ["extent2path", "extents_filename", "extant_data", "extent_files", "extrent_files", "extrent_filename", "extant_path", "extrent_path", "extents_file", "extent2files", "extent2file", "extent_filename", "extents_path", "extents_name", "extent2data", "extent_name", "extrent_file", "extant_file", "extent_data", "extant_files"], "s": ["server", "os", "sym", "site", "service", "cs", "ls", "state", "ss", "xs", "ies", "y", "is", "services", "rows", "comm", "es", "ims", "ts", "sp", "S", "settings", "session", "b", "fs", "ssl", "blocks", "ips", "ds", "se", "sl", "ns", "ms", "us", "ps", "ses", "words", "sync", "gs", "sys", "sets", "su", "safe", "storage", "sa", "js", "stats", "ops", "x", "ches"], "extent": ["EXTend", "Extent", "contend", "extend", "Extant", "EXTENT", "EXTent", "contENT", "contant", "EXTant", "content", "extENT", "extant", "Extend", "ExtENT"]}}
{"project": "FFmpeg", "commit_id": "a04c2c707de2ce850f79870e84ac9d7ec7aa9143", "target": 1, "func": "static int default_lockmgr_cb(void **arg, enum AVLockOp op)\n\n{\n\n    void * volatile * mutex = arg;\n\n    int err;\n\n\n\n    switch (op) {\n\n    case AV_LOCK_CREATE:\n\n        return 0;\n\n    case AV_LOCK_OBTAIN:\n\n        if (!*mutex) {\n\n            pthread_mutex_t *tmp = av_malloc(sizeof(pthread_mutex_t));\n\n            if (!tmp)\n\n                return AVERROR(ENOMEM);\n\n            if ((err = pthread_mutex_init(tmp, NULL))) {\n\n                av_free(tmp);\n\n                return AVERROR(err);\n\n            }\n\n            if (avpriv_atomic_ptr_cas(mutex, NULL, tmp)) {\n\n                pthread_mutex_destroy(tmp);\n\n                av_free(tmp);\n\n            }\n\n        }\n\n\n\n        if ((err = pthread_mutex_lock(*mutex)))\n\n            return AVERROR(err);\n\n\n\n        return 0;\n\n    case AV_LOCK_RELEASE:\n\n        if ((err = pthread_mutex_unlock(*mutex)))\n\n            return AVERROR(err);\n\n\n\n        return 0;\n\n    case AV_LOCK_DESTROY:\n\n        if (*mutex)\n\n            pthread_mutex_destroy(*mutex);\n\n        av_free(*mutex);\n\n        avpriv_atomic_ptr_cas(mutex, *mutex, NULL);\n\n        return 0;\n\n    }\n\n    return 1;\n\n}\n", "idx": 8794, "substitutes": {"arg": ["param", "g", "ann", "ax", "args", "abc", "local", "ref", "result", "pc", "Arg", "amp", "rc", "ace", "arc", "ang", "enc", "input", "slot", "arr", "loc", "p", "load", "ag", "ar", "par", "ac", "entry", "arm", "inc", "val", "argument", "mac", "call", "inter", "emb", "aph", "AR", "var", "ig", "exec", " argument"], "op": ["ok", "hop", "prop", "type", "ip", "mp", "oop", "proc", "comp", "Op", "option", "cmp", "node", "cat", "p", "expr", "loc", "operation", "use", "plan", "operator", "bit", "open", "oid", "act", "ac", "oper", "opt", "OP", "val", "o", "def", "lock", "oc", "obj", "init", "info", "set", "or", "pop", "name", "ops"], "mutex": ["metlex", "mutEx", "putact", "rotex", "Mutix", " mutlex", "rotexternal", "putEX", " mutix", "utaux", "Mutact", " mutexternal", " mutrex", "utex", "putec", "rotext", "metex", "mutesc", "putus", " mutEX", "rotact", "MutEx", "putix", "putesc", "putaux", "utEX", " mutaux", "utact", "putext", "mutexternal", "utilrex", "mutlex", "putEx", "litex", "Mutex", "mutEX", " mutesc", "utilec", "putrex", " mutEx", "mutaux", "litEX", "motus", "putex", "altext", "Mutaux", "motEX", "mutact", "utilix", "utix", "putlex", "mutec", "motex", "altact", "mutext", "utus", "utext", "mutix", " mutec", "metesc", " mutus", " mutact", "motix", "utilex", "metEX", " mutext", "mutus", "litact", "litix", "altex", "utEx", "MutEX", "altexternal", "mutrex"], "err": ["nor", "ref", "c", "ver", "mr", "i", "fe", "rc", "ev", "lr", "nil", "fee", "orig", "ar", "yr", "arm", "all", "cr", "e", "or", "aster", "nr", "hr", " error", "result", "iter", "sr", "ace", "rn", "cor", "ie", "end", "code", "error", "attr", "kr", "call", "ry", "oe", "er", "var", "rag", "str", "Error", "usr", "ctr", "resp", "good", "Er", "pr", "ah", "ler", "icer", "ind", "r", "br", "req", "ir", "rr", "rh", "rar", "bug", "x", "type", "dr", "cb", "ner", "order", "arr", "loc", " result", "der", "inner", "ext", " rc", "rb", "ac", "cer", "dev", "n"], "tmp": ["dest", "tf", "ctx", "rt", "src", "c", "cpp", "fb", "tty", "buff", "stuff", "nt", "slave", "txt", "np", "tp", "pointer", "api", "mp", "result", "own", "db", "sb", "img", "Temp", "test", "thread", "fp", "vm", "copy", "handler", "attr", "cro", "var", "ph", "ptr", "buf", "vt", "ff", "now", "pb", "TB", "config", "pkg", "boot", "kk", "part", "v", "emp", "current", "null", "py", "nb", "private", "cmp", "amp", "property", "p", "temp", "fake", "cp", "bt", "tem", "rb", "t", "obj", "tt", "tc", "storage", "pty", "cache"]}}
{"project": "FFmpeg", "commit_id": "aacc6615f8e3863cd930d3a1ab2cd28d9838f0f5", "target": 1, "func": "static inline int check_input_motion(MpegEncContext * s, int mb_x, int mb_y, int p_type){\n\n    MotionEstContext * const c= &s->me;\n\n    Picture *p= s->current_picture_ptr;\n\n    int mb_xy= mb_x + mb_y*s->mb_stride;\n\n    int xy= 2*mb_x + 2*mb_y*s->b8_stride;\n\n    int mb_type= s->current_picture.mb_type[mb_xy];\n\n    int flags= c->flags;\n\n    int shift= (flags&FLAG_QPEL) + 1;\n\n    int mask= (1<<shift)-1;\n\n    int x, y, i;\n\n    int d=0;\n\n    me_cmp_func cmpf= s->dsp.sse[0];\n\n    me_cmp_func chroma_cmpf= s->dsp.sse[1];\n\n    \n\n    assert(p_type==0 || !USES_LIST(mb_type, 1));\n\n    assert(IS_INTRA(mb_type) || USES_LIST(mb_type,0) || USES_LIST(mb_type,1));\n\n    \n\n    if(IS_INTERLACED(mb_type)){\n\n        int xy2= xy  + s->b8_stride;\n\n        s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTRA;\n\n        c->stride<<=1;\n\n        c->uvstride<<=1;\n\n        init_interlaced_ref(s, 2);\n\n        \n\n        assert(s->flags & CODEC_FLAG_INTERLACED_ME);\n\n\n\n        if(USES_LIST(mb_type, 0)){\n\n            int field_select0= p->ref_index[0][xy ];\n\n            int field_select1= p->ref_index[0][xy2];\n\n            assert(field_select0==0 ||field_select0==1);\n\n            assert(field_select1==0 ||field_select1==1);\n\n            if(p_type){\n\n                s->p_field_select_table[0][mb_xy]= field_select0;\n\n                s->p_field_select_table[1][mb_xy]= field_select1;\n\n                *(uint32_t*)s->p_field_mv_table[0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[0][xy ];\n\n                *(uint32_t*)s->p_field_mv_table[1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[0][xy2];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER_I;\n\n            }else{\n\n                s->b_field_select_table[0][0][mb_xy]= field_select0;\n\n                s->b_field_select_table[0][1][mb_xy]= field_select1;\n\n                *(uint32_t*)s->b_field_mv_table[0][0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[0][xy ];\n\n                *(uint32_t*)s->b_field_mv_table[0][1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[0][xy2];\n\n                s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_FORWARD_I;\n\n            }\n\n\n\n            x= p->motion_val[0][xy ][0]; \n\n            y= p->motion_val[0][xy ][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select0, 0, cmpf, chroma_cmpf, flags);\n\n            x= p->motion_val[0][xy2][0]; \n\n            y= p->motion_val[0][xy2][1];\n\n            d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select1, 1, cmpf, chroma_cmpf, flags);\n\n        }\n\n        if(USES_LIST(mb_type, 1)){\n\n            int field_select0= p->ref_index[1][xy ];\n\n            int field_select1= p->ref_index[1][xy2];\n\n            assert(field_select0==0 ||field_select0==1);\n\n            assert(field_select1==0 ||field_select1==1);\n\n            s->b_field_select_table[1][0][mb_xy]= field_select0;\n\n            s->b_field_select_table[1][1][mb_xy]= field_select1;\n\n            *(uint32_t*)s->b_field_mv_table[1][0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[1][xy ];\n\n            *(uint32_t*)s->b_field_mv_table[1][1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[1][xy2];\n\n            if(USES_LIST(mb_type, 0)){\n\n                s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_BIDIR_I;\n\n            }else{\n\n                s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_BACKWARD_I;\n\n            }\n\n\n\n            x= p->motion_val[1][xy ][0]; \n\n            y= p->motion_val[1][xy ][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select0+2, 0, cmpf, chroma_cmpf, flags);\n\n            x= p->motion_val[1][xy2][0]; \n\n            y= p->motion_val[1][xy2][1];\n\n            d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select1+2, 1, cmpf, chroma_cmpf, flags);\n\n            //FIXME bidir scores\n\n        }\n\n        c->stride>>=1;\n\n        c->uvstride>>=1;\n\n    }else if(IS_8X8(mb_type)){\n\n\n        cmpf= s->dsp.sse[1];\n\n        chroma_cmpf= s->dsp.sse[1];\n\n        init_mv4_ref(s);\n\n        for(i=0; i<4; i++){\n\n            xy= s->block_index[i];\n\n            x= p->motion_val[0][xy][0]; \n\n            y= p->motion_val[0][xy][1];\n\n            d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 1, 8, i, i, cmpf, chroma_cmpf, flags);\n\n        }\n\n        s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER4V;\n\n    }else{\n\n        if(USES_LIST(mb_type, 0)){\n\n            if(p_type){\n\n                *(uint32_t*)s->p_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER;\n\n            }else if(USES_LIST(mb_type, 1)){\n\n                *(uint32_t*)s->b_bidir_forw_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy];\n\n                *(uint32_t*)s->b_bidir_back_mv_table[mb_xy]= *(uint32_t*)p->motion_val[1][xy];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_BIDIR;\n\n            }else{\n\n                *(uint32_t*)s->b_forw_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_FORWARD;\n\n            }\n\n            x= p->motion_val[0][xy][0]; \n\n            y= p->motion_val[0][xy][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 0, 0, cmpf, chroma_cmpf, flags);\n\n        }else if(USES_LIST(mb_type, 1)){\n\n            *(uint32_t*)s->b_back_mv_table[mb_xy]= *(uint32_t*)p->motion_val[1][xy];\n\n            s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_BACKWARD;\n\n           \n\n            x= p->motion_val[1][xy][0]; \n\n            y= p->motion_val[1][xy][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 2, 0, cmpf, chroma_cmpf, flags);\n\n        }else\n\n            s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTRA;\n\n    }\n\n    return d;\n\n}", "idx": 8815, "substitutes": {"s": ["sym", "service", "cs", "self", "a", "ks", "sv", "lines", "settings", "b", "words", "gs", "w", "com", "e", "comments", "rs", "strings", "js", "os", "bis", "site", "ls", "ss", "sq", "sb", "h", "http", "S", "ds", "session", "sie", "fs", "ssl", "o", "ses", "qs", "sc", "f", "parts", "sf", "xs", "services", "sg", "details", "sim", "v", "r", "ps", "l", "sync", "u", "south", "sys", "su", "support", "g", "request", "sports", "is", "sup", "es", "ts", "si", "sis", "se", "ns", "spec", "client", "t", "your", "m", "conf", "n", "sets", "storage", "sa", "ops"], "mb_x": ["MB_x", "mp_type", "mp_pick", "mbIdxy", "mb_pick", "mb_type", "MB_my", "mp_y", "mp_x", "mbIdx", "MB_y", "MB_lon", "MB_xy", "mbIdy", "mb_my", "mb_xy", "mbIdmy", "mb_lon"], "mb_y": ["MB_yan", "mb00type", "MB_x", "mb_yan", "mb_year", "mp_lon", "MB_type", "mb00vy", "MB_vy", "mb6yan", "mb_type", "mp_y", "mb_vy", "mb6y", "mp_x", "mb00x", "mb67vy", "mb67x", "mbiplon", "mb00y", "MB_y", "mp_year", "mbipx", "mbipyear", "mbipy", "mb67type", "mb6x", "mb67y", "mb_lon", "mb6vy"], "p_type": ["p_role", "fp_val", "pktype", " p_name", "fp_types", "p__type", "pkgval", " p_types", " p_y", "p_val", "m_parent", "pkrole", "p__y", "pkval", "pkgtype", "pkgrole", "pkgtypes", "p__name", "p_types", "pktypes", "p_y", "p_parent", "m_ty", "fp_role", "p__types", "p_ty", "m_name", "fp_type", "m_type", "p_name"], "c": ["g", "ctx", "f", "k", "cs", "bc", "ce", "pc", "ca", "co", "rc", "config", "h", "enc", "cop", "b", "cy", "ic", "cm", "cp", "cu", "ct", "con", "cal", "cc", "v", "C", "dc", "ch", "ac", "t", "l", "ci", "cf", "sc", "u", "cr", "m", "conf", "e", "n", "mc", "lc", "ec"], "p": ["g", "np", "tp", "f", "pal", "pro", "api", "ip", "media", "pb", "pc", "a", "lp", "cop", "per", "http", "sp", "b", "pi", "cp", "j", "P", "pre", "po", "v", "pe", "op", "t", "ps", "wp", "l", "pp", "vp", "ap", "m", "e", "pa", "n", "bp", "py", "post"], "x": ["pos", "f", "id", "pixel", "X", "ex", "xy", "d", "h", "b", "px", "z", "v", "pe", "in", "o", "l", "index", "dx", "w", "m", "e", "n", "ix"], "y": ["ey", "yy", "type", "f", "ya", "xy", "d", "h", "dy", "b", "vy", "cy", "j", "z", "t", "o", "l", "ym", "w", "m", "e", "yt", "Y"], "i": ["ii", "li", "f", "phi", "I", "k", "mi", "d", "h", "si", "b", "pi", "j", "z", "v", "ti", "r", "ci", "u", "index", "w", "m", "e", "n"]}}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "void ff_estimate_p_frame_motion(MpegEncContext * s,\n\n                                int mb_x, int mb_y)\n\n{\n\n    UINT8 *pix, *ppix;\n\n    int sum, varc, vard, mx, my, range, dmin, xx, yy;\n\n    int xmin, ymin, xmax, ymax;\n\n    int rel_xmin, rel_ymin, rel_xmax, rel_ymax;\n\n    int pred_x=0, pred_y=0;\n\n    int P[6][2];\n\n    const int shift= 1+s->quarter_sample;\n\n    int mb_type=0;\n\n    uint8_t *ref_picture= s->last_picture[0];\n\n\n\n    get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, s->f_code);\n\n\n\n    switch(s->me_method) {\n\n    case ME_ZERO:\n\n    default:\n\n\tno_motion_search(s, &mx, &my);\n\n        dmin = 0;\n\n        break;\n\n    case ME_FULL:\n\n\tdmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_LOG:\n\n\tdmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_PHODS:\n\n\tdmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_X1:\n\n    case ME_EPZS:\n\n       {\n\n            const int mot_stride = s->block_wrap[0];\n\n            const int mot_xy = s->block_index[0];\n\n\n\n            rel_xmin= xmin - mb_x*16;\n\n            rel_xmax= xmax - mb_x*16;\n\n            rel_ymin= ymin - mb_y*16;\n\n            rel_ymax= ymax - mb_y*16;\n\n\n\n            P[0][0] = s->motion_val[mot_xy    ][0];\n\n            P[0][1] = s->motion_val[mot_xy    ][1];\n\n            P[1][0] = s->motion_val[mot_xy - 1][0];\n\n            P[1][1] = s->motion_val[mot_xy - 1][1];\n\n            if(P[1][0] > (rel_xmax<<shift)) P[1][0]= (rel_xmax<<shift);\n\n\n\n            /* special case for first line */\n\n            if ((mb_y == 0 || s->first_slice_line || s->first_gob_line)) {\n\n                P[4][0] = P[1][0];\n\n                P[4][1] = P[1][1];\n\n            } else {\n\n                P[2][0] = s->motion_val[mot_xy - mot_stride             ][0];\n\n                P[2][1] = s->motion_val[mot_xy - mot_stride             ][1];\n\n                P[3][0] = s->motion_val[mot_xy - mot_stride + 2         ][0];\n\n                P[3][1] = s->motion_val[mot_xy - mot_stride + 2         ][1];\n\n                if(P[2][1] > (rel_ymax<<shift)) P[2][1]= (rel_ymax<<shift);\n\n                if(P[3][0] < (rel_xmin<<shift)) P[3][0]= (rel_xmin<<shift);\n\n                if(P[3][1] > (rel_ymax<<shift)) P[3][1]= (rel_ymax<<shift);\n\n        \n\n                P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]);\n\n                P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]);\n\n            }\n\n            if(s->out_format == FMT_H263){\n\n                pred_x = P[4][0];\n\n                pred_y = P[4][1];\n\n            }else { /* mpeg1 at least */\n\n                pred_x= P[1][0];\n\n                pred_y= P[1][1];\n\n            }\n\n        }\n\n        dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture);\n\n \n\n        mx+= mb_x*16;\n\n        my+= mb_y*16;\n\n        break;\n\n    }\n\n    \n\n    if(s->flags&CODEC_FLAG_4MV){\n\n        int block;\n\n\n\n        mb_type|= MB_TYPE_INTER4V;\n\n\n\n        for(block=0; block<4; block++){\n\n            int mx4, my4;\n\n            int pred_x4, pred_y4;\n\n            int dmin4;\n\n            static const int off[4]= {2, 1, 1, -1};\n\n            const int mot_stride = s->block_wrap[0];\n\n            const int mot_xy = s->block_index[block];\n\n            const int block_x= mb_x*2 + (block&1);\n\n            const int block_y= mb_y*2 + (block>>1);\n\n\n\n            const int rel_xmin4= xmin - block_x*8;\n\n            const int rel_xmax4= xmax - block_x*8 + 8;\n\n            const int rel_ymin4= ymin - block_y*8;\n\n            const int rel_ymax4= ymax - block_y*8 + 8;\n\n\n\n            P[0][0] = s->motion_val[mot_xy    ][0];\n\n            P[0][1] = s->motion_val[mot_xy    ][1];\n\n            P[1][0] = s->motion_val[mot_xy - 1][0];\n\n            P[1][1] = s->motion_val[mot_xy - 1][1];\n\n            if(P[1][0] > (rel_xmax4<<shift)) P[1][0]= (rel_xmax4<<shift);\n\n\n\n            /* special case for first line */\n\n            if ((mb_y == 0 || s->first_slice_line || s->first_gob_line) && block<2) {\n\n                P[4][0] = P[1][0];\n\n                P[4][1] = P[1][1];\n\n            } else {\n\n                P[2][0] = s->motion_val[mot_xy - mot_stride             ][0];\n\n                P[2][1] = s->motion_val[mot_xy - mot_stride             ][1];\n\n                P[3][0] = s->motion_val[mot_xy - mot_stride + off[block]][0];\n\n                P[3][1] = s->motion_val[mot_xy - mot_stride + off[block]][1];\n\n                if(P[2][1] > (rel_ymax4<<shift)) P[2][1]= (rel_ymax4<<shift);\n\n                if(P[3][0] < (rel_xmin4<<shift)) P[3][0]= (rel_xmin4<<shift);\n\n                if(P[3][0] > (rel_xmax4<<shift)) P[3][0]= (rel_xmax4<<shift);\n\n                if(P[3][1] > (rel_ymax4<<shift)) P[3][1]= (rel_ymax4<<shift);\n\n        \n\n                P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]);\n\n                P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]);\n\n            }\n\n            if(s->out_format == FMT_H263){\n\n                pred_x4 = P[4][0];\n\n                pred_y4 = P[4][1];\n\n            }else { /* mpeg1 at least */\n\n                pred_x4= P[1][0];\n\n                pred_y4= P[1][1];\n\n            }\n\n            P[5][0]= mx - mb_x*16;\n\n            P[5][1]= my - mb_y*16;\n\n\n\n            dmin4 = epzs_motion_search4(s, block, &mx4, &my4, P, pred_x4, pred_y4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, ref_picture);\n\n\n\n            halfpel_motion_search4(s, &mx4, &my4, dmin4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, \n\n                                   pred_x4, pred_y4, block_x, block_y, ref_picture);\n\n     \n\n            s->motion_val[ s->block_index[block] ][0]= mx4;\n\n            s->motion_val[ s->block_index[block] ][1]= my4;\n\n        }\n\n    }\n\n\n\n    /* intra / predictive decision */\n\n    xx = mb_x * 16;\n\n    yy = mb_y * 16;\n\n\n\n    pix = s->new_picture[0] + (yy * s->linesize) + xx;\n\n    /* At this point (mx,my) are full-pell and the absolute displacement */\n\n    ppix = ref_picture + (my * s->linesize) + mx;\n\n    \n\n    sum = pix_sum(pix, s->linesize);\n\n#if 0\n\n    varc = pix_dev(pix, s->linesize, (sum+128)>>8) + INTER_BIAS;\n\n    vard = pix_abs16x16(pix, ppix, s->linesize);\n\n#else\n\n    sum= (sum+8)>>4;\n\n    varc = ((pix_norm1(pix, s->linesize) - sum*sum + 128 + 500)>>8);\n\n    vard = (pix_norm(pix, ppix, s->linesize)+128)>>8;\n\n#endif\n\n\n\n    s->mb_var[s->mb_width * mb_y + mb_x] = varc;\n\n    s->avg_mb_var+= varc;\n\n    s->mc_mb_var += vard;\n\n\n\n    \n\n#if 0\n\n    printf(\"varc=%4d avg_var=%4d (sum=%4d) vard=%4d mx=%2d my=%2d\\n\",\n\n\t   varc, s->avg_mb_var, sum, vard, mx - xx, my - yy);\n\n#endif\n\n    if(s->flags&CODEC_FLAG_HQ){\n\n        if (vard*2 + 200 > varc)\n\n            mb_type|= MB_TYPE_INTRA;\n\n        if (varc*2 + 200 > vard){\n\n            mb_type|= MB_TYPE_INTER;\n\n            halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);\n\n        }else{\n\n            mx = mx*2 - mb_x*32;\n\n            my = my*2 - mb_y*32;\n\n        }\n\n    }else{\n\n        if (vard <= 64 || vard < varc) {\n\n            mb_type|= MB_TYPE_INTER;\n\n            if (s->me_method != ME_ZERO) {\n\n                halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);\n\n            } else {\n\n                mx -= 16 * mb_x;\n\n                my -= 16 * mb_y;\n\n            }\n\n#if 0\n\n            if (vard < 10) {\n\n                skip++;\n\n                fprintf(stderr,\"\\nEarly skip: %d vard: %2d varc: %5d dmin: %d\", \n\n                                skip, vard, varc, dmin);\n\n            }\n\n#endif\n\n        }else{\n\n            mb_type|= MB_TYPE_INTRA;\n\n            mx = 0;//mx*2 - 32 * mb_x;\n\n            my = 0;//my*2 - 32 * mb_y;\n\n        }\n\n    }\n\n\n\n    s->mb_type[mb_y*s->mb_width + mb_x]= mb_type;\n\n    set_p_mv_tables(s, mx, my);\n\n}\n", "idx": 8825, "substitutes": {"s": ["server", "sym", "service", "cs", "c", "a", "i", "ks", "sv", "lines", "settings", "b", "sites", "gs", "series", "e", "comments", "rs", "strings", "js", "phys", "os", "bis", "site", "its", "ls", "ss", "sq", "ins", "sb", "http", "S", "session", "ds", "fs", "ssl", "ms", "qs", "ses", "f", "sf", "xs", "stat", "an", "services", "sg", "details", "secondary", "sim", "in", "ions", "ps", "sync", "u", "south", "sys", "su", "rates", "features", "support", "g", "states", "private", "sports", "single", "is", "es", "p", "ts", "si", "sis", "se", "ns", "spec", "client", "us", "t", "your", "plugins", "m", "conf", "n", "sets", "this", "storage", "stats", "ops", "hm"], "mb_x": ["mb01Y", "MB_x", "mm_y", "mb68ey", "MB_size", "mb_xs", "mb01x", "mb24ya", "MB_X", "mb54ey", "mm_time", "mb54time", "vm_ya", "mb24Y", "vm_Y", "mb54y", "mm_ey", "mb24xs", "mb24x", "vm_x", "vm_xs", "mb_size", "mb_rx", "mb_ey", "mb_time", "mb68y", "mb01ya", "mb_X", "mm_x", "mb_ya", "mb_Y", "MB_rx", "mb01xs", "mb54x", "mb68time", "mb68x"], "mb_y": ["mm_y", "mb001yl", "mp_yt", "mb25ys", "mm_ys", "mb101x", "mp_ady", "mb00ys", "mb_yl", "mb101y", "mb_ys", "mb_yt", "mb__ady", "mp_y", "mb00oy", "mb001ym", "mp_x", "mb25x", "mb00x", "mb25y", "mb00y", "mb_ym", "mb_ady", "mb__y", "mm_yl", "mb101yl", "mm_ym", "mb001x", "mb_oy", "mm_x", "mb__x", "mb__yt", "mb001y", "mb101ym", "mb25oy", "mm_oy"], "pix": ["pox", "gpix", " pik", "gpixels", "pik", " pox", "ppox", "ppik", " pixels", "ppixels", "gpik", "pixels", "gpox"], "ppix": ["cpixel", "dpixel", "cpius", "ppius", "dpix", "wpixel", "wpix", "ppixel", "dpius", "ppIX", "wpIX", "dpIX", "wpius", "cpix", "cpIX"], "sum": ["vol", "pos", "mean", "diff", "um", "gram", "depth", "stat", "norm", "pack", "loss", "total", "doc", "scale", "sim", "Sum", "summary", "mem", "num", "bin", "dev", "conf", "mass", "quant", "count", "miss", "cost", "mix"], "varc": ["mrec", "flc", "vlc", "vrec", "frec", "fpc", "nvarc", "marc", "mpc", "nvrec", "nvpc", "mlc", "vpc", "farc", "nvlc"], "vard": ["src", "nc", "rev", "voc", "ss", "nb", "pixel", "low", "vc", "sq", "by", "au", "rc", "cat", "cur", "cb", "ck", "ct", "img", "gb", "cc", "cv", "lv", "ch", "num", "nv", "win", "sky", "dev", "feat"], "mx": ["hop", "zx", "yx", "wy", "bm", "pm", "max", "mu", "xml", "mi", "mp", "wx", "mes", "min", "md", "y", "wm", "mr", "module", "xy", "nas", "mis", "mos", "fm", "px", "cm", "memory", "mus", "ms", "me", "vm", "rx", "mine", "mag", "mem", "km", "dim", "ym", "rm", "m", "dm", "mm", "xp", "mc", "py", "MX", "target", "mn", "x", "nm"], "my": ["MY", "phy", "live", "sym", "yo", "mode", "pm", "max", "mi", "gray", "self", "metadata", "My", "mid", "x", "ya", "y", "md", "ma", "mr", "min", "i", "mys", "dy", "mis", "gy", "cy", "mos", "yahoo", "mic", "test", "ng", "memory", "ms", "me", "bi", "mem", "rx", "mine", "your", "am", "mon", "mie", "m", "mm", "mc", "meta", "ram", "py", "mn", "nm"], "range": ["gap", "remote", "fr", "chain", "size", "f", "mode", "sample", "nr", "max", "view", "ref", "err", "edge", "resolution", "radius", "mid", "spread", "low", "Range", "route", "feature", "cache", "term", "scan", "theme", "offset", "loc", "ange", "use", "release", "lim", "frame", "year", "domain", "end", "run", "scale", "array", "target", "row", "r", "channel", "error", "resource", "area", "store", "angle", "force", "m", "query", "base", "origin", "ge", "random", "broad", "ram", "repeat", "role", "grade", "rate", "bug", "rage", "slice", "line"], "dmin": ["Dmain", "dhMIN", " dMIN", "dypos", "dfree", "dpMin", "dmax", "dmiss", "sdmiss", "dpos", "dyMIN", "xdmiss", "dhmin", "xdMIN", "dyinit", "dmain", " dMin", "dhmain", "pmax", "dymax", "dminimum", "dymain", " dmain", "xdfree", "dymin", "Dmin", "dpmin", "sdmin", " dfree", "xdmin", "dMin", "dhMin", "Dmax", "pmin", "DMin", "DMIN", "pMIN", " dpos", "dinit", "sdMIN", "dMIN", " dminimum", "yinit", " dinit", " dmiss", "dpMIN", "dpminimum", "sdfree", "pmain", "Dminimum", "ypos"], "xx": ["pos", "nc", "na", "ss", "wx", "xs", "dist", "xy", "aa", "xxx", "ck", "px", "nd", "foo", "test", "act", "ns", "code", "inc", "rx", "pp", "nn", "mm", "fix"], "yy": ["ii", "fy", "zx", "zy", "mid", "YY", "y", "xy", "aa", "bar", "XX", "dy", "xxx", "cy", "gy", "year", "hh", "foo", "dd", "ym", "nn", "mm", "delay", "py", "oy"], "xmin": ["xymax", "exmin", "ymini", " xdiff", "xMin", " xMin", "ysize", "xymin", "Xmin", "dmax", " xstart", "xymini", "X0", "ydiff", "exmax", "XMin", " x0", "yMin", "Xstart", "Xmax", "Xsize", "dsize", "xsize", "ystart", " xmini", "xydiff", "xdiff", "exMin", "y0", "xmini", "x0", "exmini", "dMin", "xstart"], "ymin": [" ystart", "xMin", "Ymax", "Ymin", "xna", "xmon", "eyra", "xskip", "ymins", "yymin", "ylen", "xmins", "yymax", " yna", "yymon", "ystat", "nymax", "ydiff", "sylen", "xlen", "mymax", "syra", "eystart", "yMin", " ylen", "yna", "mystat", "ymind", " ystat", " ymins", "xstat", "ystart", "symin", "yskip", "nymon", " yskip", "yra", "eyskip", "xdiff", "YMin", "xmind", "mymin", "ymon", "xra", "systart", " yMin", "nymin", "nymind", "eymax", "Yna", "yymind", " ydiff", "symax", "symins", "eymin", "mydiff", "xstart"], "xmax": ["rxmax", "yaz", "Xend", "XMax", "Xaz", "wmin", "wstart", " xdiff", "wmax", "Xmin", "mxpress", "dmax", "xend", "eydiff", "wend", "eyMax", "yax", "yend", "xMax", "xaz", "Xmax", "rxend", "mxmin", "dend", "yMax", "mxmax", "xax", "ystart", "xstart", "ypress", "zmin", " xMax", " xaz", "zMax", "dstart", "xdiff", "Xdiff", " xend", "zend", "xpress", " xpress", "eymax", "rxmin", "zmax", " xax", "mxax", "eymin"], "ymax": ["nmase", "ymmAX", "tmant", "mmax", "ymag", "ymmmax", "max", "ypake", "ymant", "ymase", "ymask", "tmase", "ypmax", "maj", "ymmake", "symag", "ypaze", "min", "pmmax", "yrmax", "yanax", "yanAX", "ymake", "ymmant", "ypase", "ymmase", "pmax", "yanaze", "symant", "ymatch", "yrag", "ymaj", "ymark", "yraj", "tmag", "humase", "nmax", "symax", "tmark", "ymaze", "tmake", "pmin", "yanatch", "ypatch", "humark", "humake", "yrin", "ypAX", "ymAX", "humax", "ypark", "tmax", "ymmask", "yrax", "ymmag", "pmatch", "nmag", "yrask", "ymmax", "pmaj", "nmask", "pmake", "ypax", "ymmatch", "yrase", "symake", "ymmaze"], "rel_xmin": ["rel_exmin", "rel_gmax", "rel_ystart", "rel_hmid", "rel_exMin", "rel_glim", "rel_gMin", "rel_xstart", "rel_ymid", "rel_exmax", "rel_tmin", "rel_exlim", "rel_hmax", "rel_gmin", "rel_tmid", "rel_ylim", "rel_tmax", "rel_xlim", "rel_yMin", "rel_hmin", "rel_tstart", "rel_xMin", "rel_xmid", "rel_hstart"], "rel_ymin": ["rel_yna", "rel_ymean", "rel_yfrom", "rel_eyna", "rel_eymax", "rel_yrmid", "rel_mmid", "rel_ymid", "rel_yrmean", "rel_mmax", "rel_xfrom", "rel_eyfrom", "rel_mmean", "rel_yrmin", "rel_mmin", "rel_xna", "rel_xmean", "rel_yrna", "rel_eymin", "rel_yrfrom", "rel_yrmax", "rel_xmid"], "rel_xmax": ["rel_Xpad", "rel_yplus", "rel_dxMax", "rel_xxmax", "rel_xpad", "rel_Xmin", "rel_xplus", "rel_yMax", "rel_Xmax", "rel_ypad", "rel_dxmax", "rel_nmax", "rel_nmin", "rel_npad", "rel_xMax", "rel_xxplus", "rel_dxmin", "rel_xxMax", "rel_xxmin", "rel_dxplus"], "rel_ymax": ["rel_ymmax", "rel_mmad", "rel_yad", "rel_mmmax", "rel_cmmax", "rel_cmad", "rel_mmax", "rel_yaz", "rel_yax", "rel_tmax", "rel_tmaz", "rel_ymmin", "rel_cmax", "rel_ymaz", "rel_tmmin", "rel_ymad", "rel_mmmin", "rel_mmaz", "rel_tmmax"], "P": ["F", "POS", "H", "T", " E", "I", " p", "O", "D", " M", "K", "Py", "U", "PIN", "Part", "X", "PO", "N", "p", "E", "G", "S", "PT", "PS", "Point", "PUT", "R", "A", "Q", "B", "C", "PRE", "J", "Position", "BP", "V", "PA", " V", " N", "Y", "M", "AP", "NP", "API", "L", "IP", "W"], "ref_picture": ["reference_picture", "ref_video", " ref_video", "refalstudy", "refaysummary", " ref_study", "Ref_pic", "Ref_details", "Ref_image", "reference_video", "ref_image", "refalpic", "reflexdetails", "ref_details", "refalpicture", "reference_profile", "Ref_picture", "refaypic", "reflexpicture", "ref_pic", "ref_study", " ref_pic", "ref_summary", "ref_database", "ref_profile", "refalvideo", "reference_database", "reflexpic", "refaypicture", "refleximage", " ref_summary"]}}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext *ctx = avctx->priv_data;\n\n    VAAPIEncodePicture *pic, *next;\n\n\n\n    for (pic = ctx->pic_start; pic; pic = next) {\n\n        next = pic->next;\n\n        vaapi_encode_free(avctx, pic);\n\n    }\n\n\n\n    if (ctx->va_context != VA_INVALID_ID) {\n\n        vaDestroyContext(ctx->hwctx->display, ctx->va_context);\n\n        ctx->va_context = VA_INVALID_ID;\n\n    }\n\n\n\n    if (ctx->va_config != VA_INVALID_ID) {\n\n        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);\n\n        ctx->va_config = VA_INVALID_ID;\n\n    }\n\n\n\n    if (ctx->codec->close)\n\n        ctx->codec->close(avctx);\n\n\n\n    av_buffer_pool_uninit(&ctx->output_buffer_pool);\n\n\n\n    av_freep(&ctx->codec_sequence_params);\n\n    av_freep(&ctx->codec_picture_params);\n\n\n\n    av_buffer_unref(&ctx->recon_frames_ref);\n\n    av_buffer_unref(&ctx->input_frames_ref);\n\n    av_buffer_unref(&ctx->device_ref);\n\n\n\n    av_freep(&ctx->priv_data);\n\n\n\n    return 0;\n\n}\n", "idx": 8835, "substitutes": {"avctx": ["avcmp", "avcontext", "ascmd", "asctx", "AVctx", "avectx", "avcas", "afcms", "avcf", "avecf", "ovcms", "avcmd", "ovctx", "afcmd", "vercontext", "vercas", "AVcmd", "ovcu", "afcas", "avecu", " avcmp", " avcontext", "avcu", "ascmp", "avcms", "AVcmp", "afcf", "AVcn", " avcn", "ascontext", "verctx", "avecontext", "avecms", "afcu", "AVcontext", "vercf", "avcn", "ovcontext", "afcn", "afctx", "avecas", "afcmp", "afcontext"], "ctx": ["la", "ann", "src", "pai", "cs", "nc", "connection", "cci", "chan", "c", "pc", "sci", "cm", "cc", "css", "cmd", "ci", "cus", "cn", "cca", "gc", "txt", "cas", "xc", "voc", "sq", "conv", "ck", "fp", "coll", "coe", "conn", "sc", "exec", "hw", "bc", "wcs", "vc", "ca", "concept", "config", "pkg", "qa", "cu", "kw", "cfg", "fc", "cms", "que", "cf", "sync", "crit", "lc", "wx", "cmp", "instance", "co", "cb", "kb", "loc", "cp", "ct", "ctrl", "context", "cli", "cv", "client", "cam", "component", "col", "conf", "tx", "obj", "tc", "uc", "data", "cache"], "pic": ["plugin", "pse", "li", "pointer", "chat", "file", "nic", "study", "prev", "lic", "seq", "c", "cycle", "pen", "pc", "jp", "feature", "config", "lot", "p", "cat", "pack", "ic", "pict", "Pic", "doc", "fig", "tick", "piece", "Picture", "pre", "fat", "pot", "key", "fc", "cha", "image", "bi", "kin", "pin", "txt", "picture", "point", "pins", "cus", "capt", "col", "lock", "pa", "photo", "lc", "eni", "page", "fin", "ig", "pid", "cache"], "next": ["big", "owner", "prefix", "first", "future", "latest", "pointer", "nic", "feat", "prev", "fi", "seq", "c", "sequence", "second", "cycle", "pc", "new", "config", "ana", "pack", "p", "enc", "after", "step", "full", "queue", "frame", "doc", "piece", "more", "soc", "open", "key", "code", "image", "parent", "inc", "complete", "picture", "nice", "conn", "start", "head", "last", "current", "reply", "init", "follow", "info", "child", "desc", "value", "sec", "eni", "space", "name", "page", "Next", "company", "data", "fin", "blog", "pid", "line"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static ssize_t socket_read(int sockfd, void *buff, size_t size)\n\n{\n\n    ssize_t retval, total = 0;\n\n\n\n    while (size) {\n\n        retval = read(sockfd, buff, size);\n\n        if (retval == 0) {\n\n            return -EIO;\n\n        }\n\n        if (retval < 0) {\n\n            if (errno == EINTR) {\n\n                continue;\n\n            }\n\n            return -errno;\n\n        }\n\n        size -= retval;\n\n        buff += retval;\n\n        total += retval;\n\n    }\n\n    return total;\n\n}\n", "idx": 8846, "substitutes": {"sockfd": ["sockhandler", "sesockf", "socketfd", "sesinkfp", " sockFD", "sinkfd", "sesinkfd", "socksfp", " sockhandler", "sinkf", "sinkFD", "socketsfp", "sinkfp", "sockethandler", " sockshandler", "sesockfp", "sesinkhandler", "sockflo", "socketsfd", "socksFD", "sockf", "sinkhandler", "sesockfd", "socketshandler", "sesockhandler", "socksflo", "socksf", "sinkflo", "sockfp", "socksfd", " socksfd", "socketFD", " sockflo", "socketflo", "sesinkf", "sockFD", " socksflo", "socketsf", "sockshandler", " socksFD"], "buff": ["text", "ctx", "f", "local", "ptr", "buf", "ff", "quit", "nb", "bag", "pb", "eb", "sb", "cb", "back", "temp", "b", "Buff", "fb", "cp", "bound", "total", "nd", "gb", "feed", "flat", "rb", "bd", "tmp", "mem", "ch", "num", "bb", "length", "uf", "abb", "old", "fo", "tab", "buffer", "cod", "body", "info", "ob", "wb", "zero", "batch", "txt", "data", "count"], "size": ["g", "timeout", "SIZE", "capacity", "empty", "args", "clean", "max", "err", "class", "handle", "success", "len", "c", "exec", "close", "small", "bytes", "function", "offset", "temp", "si", "fee", "loc", "total", "shape", "done", "full", "end", "scale", "fat", "ize", "address", "code", "Size", "z", "ee", "length", "complete", "error", "area", "sync", "sum", "body", "buffer", "iz", "data", "e", "speed", "storage", "six", "sec", "name", "zero", "send", "extra", "count", "page", "cache"], "retval": ["memeval", "memvals", "RETval", " reteval", "finval", "rtv", "refvalue", "Retval", "inteval", "intvals", " retvalid", "retvalid", "ntval", "RetVAL", " retvals", "rtVal", "retVAL", "memval", "refv", "altval", "finv", "refeval", "ntvals", "memVal", "finvalid", "intval", "retVal", "Retvalue", "retvals", " retVal", "fineval", "altvalue", "rtVAL", "RETVal", "nteval", "altVal", "retv", "altv", "rtvals", "rteval", "reteval", " retv", "Retvals", "ntvalue", "Reteval", "RETVAL", " retvalue", "altvalid", "rtval", "RETvalue", "refval", "RetVal", "retvalue", "rtvalue", "intVal", "alteval"]}}
{"project": "qemu", "commit_id": "4981bdec0d9b3ddd3e1474de5aa9918f120b54f7", "target": 0, "func": "AioContext *blk_get_aio_context(BlockBackend *blk)\n\n{\n\n    return bdrv_get_aio_context(blk->bs);\n\n}\n", "idx": 8855, "substitutes": {"blk": [" blks", " blck", "clks", "plkt", "Blck", "clk", "Blk", "Blks", "plks", "clkt", "blck", "Blkt", "blkt", "clck", " blkt", "blks", "plk", "plck"]}}
{"project": "qemu", "commit_id": "6f864e6ec8812d5a5525a7861ca599c6bcabdebe", "target": 0, "func": "static int vfio_load_rom(VFIODevice *vdev)\n\n{\n\n    uint64_t size = vdev->rom_size;\n\n    char name[32];\n\n    off_t off = 0, voff = vdev->rom_offset;\n\n    ssize_t bytes;\n\n    void *ptr;\n\n\n\n    /* If loading ROM from file, pci handles it */\n\n    if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) {\n\n        return 0;\n\n    }\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", __func__, vdev->host.domain,\n\n            vdev->host.bus, vdev->host.slot, vdev->host.function);\n\n\n\n    snprintf(name, sizeof(name), \"vfio[%04x:%02x:%02x.%x].rom\",\n\n             vdev->host.domain, vdev->host.bus, vdev->host.slot,\n\n             vdev->host.function);\n\n    memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size);\n\n    ptr = memory_region_get_ram_ptr(&vdev->pdev.rom);\n\n    memset(ptr, 0xff, size);\n\n\n\n    while (size) {\n\n        bytes = pread(vdev->fd, ptr + off, size, voff + off);\n\n        if (bytes == 0) {\n\n            break; /* expect that we could get back less than the ROM BAR */\n\n        } else if (bytes > 0) {\n\n            off += bytes;\n\n            size -= bytes;\n\n        } else {\n\n            if (errno == EINTR || errno == EAGAIN) {\n\n                continue;\n\n            }\n\n            error_report(\"vfio: Error reading device ROM: %m\");\n\n            memory_region_destroy(&vdev->pdev.rom);\n\n            return -errno;\n\n        }\n\n    }\n\n\n\n    pci_register_bar(&vdev->pdev, PCI_ROM_SLOT, 0, &vdev->pdev.rom);\n\n    vdev->pdev.has_rom = true;\n\n    return 0;\n\n}\n", "idx": 8858, "substitutes": {"vdev": ["pde", "lev", "vdef", "evgu", "evang", "wev", "vserror", "svconf", "svang", "ovdevice", "svadv", "vvar", "kdc", "pdef", "ovdef", "gdd", "ldc", "evdev", "vconf", "ovgu", "pconf", " vconf", "pdiv", "vmdev", "evdc", "cconn", "hev", " verror", "lang", "vgu", "vsdev", "padv", "pdev", "voltdev", "lcam", "uconn", "svev", "vself", "ovdev", " vdiv", " vconn", "udiv", "Vconf", "jev", "vDev", "pvar", "vDEV", "vcam", "ovev", " vflow", "gev", " vdef", "vev", "pself", "wdef", "verror", "vsdc", "svconn", "svprof", "ovdiv", "lflow", "jdi", "vmgu", " vdevice", "vconn", " vvar", "fdevice", "ld", "vadv", " vdd", "pdc", "pdevice", "udev", "VDev", "lgu", "vdi", "Vdevice", "wprof", " vself", "vflow", "kdi", "evconn", "Vdom", "pev", "Vdd", "evflow", "vsdevice", "ovDEV", " vgu", "vang", "jdev", "nvev", "vdc", "kev", "fgu", "svdd", "pdi", "wdom", " vdc", "pdd", "vdom", "Vprof", "nvdev", "nvvar", "evd", "jconf", " vcam", "voltself", "vmdevice", "ldef", "svdiv", "svdc", "vprof", "wdev", "hdev", "vdiv", "svdom", "fdev", "vmcam", "pDEV", "wdiv", "ovvar", " vd", "voltadv", "hDEV", " vde", "Vdiv", "kdev", "svself", " vev", "hdevice", "jdc", "fev", "evconf", "vdd", "lconn", "evdiv", "vde", "wDev", "ovdd", "vd", "svde", "gde", "Vdev", "gdev", "everror", "svdevice", "voltdevice", "udd", "Vvar", "cdiv", "jde", "cdev", "evdevice", "vdevice", "nvdd", "ldevice", "svdev", "svDev", "ldev", "evev", "lconf", "cdd", "Vev"], "name": ["param", "pos", "version", "prefix", "block", "no", "size", "type", "id", "comment", "device", "NAME", "path", "ref", "max", "ip", "Name", "host", "self", "connection", "byte", "addr", "len", "a", "node", "new", "function", "str", "names", "filename", "url", "part", "cpu", "memory", "address", "key", "code", "mem", "image", "parent", "num", "time", "val", "word", "start", "buffer", "alias", "base", "n", "info", "ame", "null", "cap", "space", "none", "data", "nam", "number", "x", "list", "cache"], "bytes": ["breaks", "zip", "cs", "byte", "fee", "lines", "steps", "icks", "blocks", "runs", "outs", "settings", "forces", "loads", "css", "all", "ops", "vs", "os", "eps", "size", "les", "groups", "ls", "ies", "bps", "rows", "allows", "days", "pages", "limits", "rules", "charges", "tes", "ms", "amples", "codes", "pieces", "reads", "odes", "gets", "out", "abytes", "parts", "values", "len", "annels", "boot", "ips", "ones", "units", "bs", "ps", "errors", "ipes", "pos", "args", "cycles", "items", "es", "flows", "io", "nos", "files", "cells", "ns", "Bytes", "bits", "data", "seconds", "videos"], "ptr": ["tr", "shift", "pos", "ctr", "size", "pointer", "args", "src", "Ptr", "rt", "ctx", "buf", "pointers", "addr", "len", "pc", "off", "patch", "dr", "rc", "p", "offset", "ep", "sp", "loc", "plug", "cp", "ext", "pt", "pre", "trace", "address", "tmp", "fp", "push", "prot", "length", "alloc", "br", "r", "call", "tty", "index", "start", "pad", "buffer", "tx", "port", "nt", "fd", "py", "data", "exec", "slice", "cache"]}}
{"project": "qemu", "commit_id": "9c5ce8db2e5c2769ed2fd3d91928dd1853b5ce7c", "target": 0, "func": "UuidInfo *qmp_query_uuid(Error **errp)\n\n{\n\n    UuidInfo *info = g_malloc0(sizeof(*info));\n\n    char uuid[64];\n\n\n\n    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],\n\n                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],\n\n                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],\n\n                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],\n\n                   qemu_uuid[14], qemu_uuid[15]);\n\n\n\n    info->UUID = g_strdup(uuid);\n\n    return info;\n\n}\n", "idx": 8866, "substitutes": {"errp": ["errf", "erp", "errps", "gramps", "gramp", "excf", "erps", "erf", "excps", "errb", "gramb", "excb", "excp", "erb", "gramf"], "info": ["before", "parse", "up", "tf", "type", "f", "id", "comment", "api", "hand", "update", "now", "ignore", "fi", "inf", "result", "Info", "success", "a", "i", "help", "config", "bar", "back", "options", "http", "order", "si", "extra", "inner", "it", "url", "gi", "feed", "end", "INFO", "in", "op", "image", "source", "error", "opt", "ret", "def", "q", "fo", "start", "index", "conf", "obj", "report", "value", "name", "py", "bug", "txt", "data", "alias", "check", "cache"], "uuid": ["runame", "buide", "buids", "uccname", "ruuid", "guida", "duida", "uuids", "duid", "duide", "iqID", "cuip", "iqider", "UUuid", "uuuid", "ouid", "uip", "uuID", "buid", "cuid", "ouids", "uuida", "iqids", "buID", "buider", "guide", "buip", "buq", "ouID", "UUid", "uccid", "cuuid", "guid", "uccID", "uuname", "buuid", "uuq", "UUID", "UUname", "ouider", "ruid", "ruID", "uid", "iqid", "buida", "uccuid", "guq", "uuip", "duq", "uuide", "uuider"]}}
{"project": "FFmpeg", "commit_id": "d7eabd50425a61b31e90c763a0c3e4316a725404", "target": 0, "func": "static int mpc7_decode_frame(AVCodecContext * avctx, void *data,\n\n                             int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size;\n\n    MPCContext *c = avctx->priv_data;\n\n    GetBitContext gb;\n\n    int i, ch;\n\n    int mb = -1;\n\n    Band *bands = c->bands;\n\n    int off, ret, last_frame, skip;\n\n    int bits_used, bits_avail;\n\n\n\n    memset(bands, 0, sizeof(*bands) * (c->maxbands + 1));\n\n\n\n    buf_size = avpkt->size & ~3;\n\n    if (buf_size <= 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"packet size is too small (%i bytes)\\n\",\n\n               avpkt->size);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (buf_size != avpkt->size) {\n\n        av_log(avctx, AV_LOG_WARNING, \"packet size is not a multiple of 4. \"\n\n               \"extra bytes at the end will be skipped.\\n\");\n\n    }\n\n\n\n    skip       = buf[0];\n\n    last_frame = buf[1];\n\n    buf       += 4;\n\n    buf_size  -= 4;\n\n\n\n    /* get output buffer */\n\n    c->frame.nb_samples = last_frame ? c->lastframelen : MPC_FRAME_SIZE;\n\n    if ((ret = avctx->get_buffer(avctx, &c->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    av_fast_padded_malloc(&c->bits, &c->buf_size, buf_size);\n\n    if (!c->bits)\n\n        return AVERROR(ENOMEM);\n\n    c->dsp.bswap_buf((uint32_t *)c->bits, (const uint32_t *)buf, buf_size >> 2);\n\n    init_get_bits(&gb, c->bits, buf_size * 8);\n\n    skip_bits_long(&gb, skip);\n\n\n\n    /* read subband indexes */\n\n    for(i = 0; i <= c->maxbands; i++){\n\n        for(ch = 0; ch < 2; ch++){\n\n            int t = 4;\n\n            if(i) t = get_vlc2(&gb, hdr_vlc.table, MPC7_HDR_BITS, 1) - 5;\n\n            if(t == 4) bands[i].res[ch] = get_bits(&gb, 4);\n\n            else bands[i].res[ch] = bands[i-1].res[ch] + t;\n\n        }\n\n\n\n        if(bands[i].res[0] || bands[i].res[1]){\n\n            mb = i;\n\n            if(c->MSS) bands[i].msf = get_bits1(&gb);\n\n        }\n\n    }\n\n    /* get scale indexes coding method */\n\n    for(i = 0; i <= mb; i++)\n\n        for(ch = 0; ch < 2; ch++)\n\n            if(bands[i].res[ch]) bands[i].scfi[ch] = get_vlc2(&gb, scfi_vlc.table, MPC7_SCFI_BITS, 1);\n\n    /* get scale indexes */\n\n    for(i = 0; i <= mb; i++){\n\n        for(ch = 0; ch < 2; ch++){\n\n            if(bands[i].res[ch]){\n\n                bands[i].scf_idx[ch][2] = c->oldDSCF[ch][i];\n\n                bands[i].scf_idx[ch][0] = get_scale_idx(&gb, bands[i].scf_idx[ch][2]);\n\n                switch(bands[i].scfi[ch]){\n\n                case 0:\n\n                    bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]);\n\n                    bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]);\n\n                    break;\n\n                case 1:\n\n                    bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]);\n\n                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1];\n\n                    break;\n\n                case 2:\n\n                    bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];\n\n                    bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]);\n\n                    break;\n\n                case 3:\n\n                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];\n\n                    break;\n\n                }\n\n                c->oldDSCF[ch][i] = bands[i].scf_idx[ch][2];\n\n            }\n\n        }\n\n    }\n\n    /* get quantizers */\n\n    memset(c->Q, 0, sizeof(c->Q));\n\n    off = 0;\n\n    for(i = 0; i < BANDS; i++, off += SAMPLES_PER_BAND)\n\n        for(ch = 0; ch < 2; ch++)\n\n            idx_to_quant(c, &gb, bands[i].res[ch], c->Q[ch] + off);\n\n\n\n    ff_mpc_dequantize_and_synth(c, mb, c->frame.data[0], 2);\n\n\n\n    bits_used = get_bits_count(&gb);\n\n    bits_avail = buf_size * 8;\n\n    if (!last_frame && ((bits_avail < bits_used) || (bits_used + 32 <= bits_avail))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error decoding frame: used %i of %i bits\\n\", bits_used, bits_avail);\n\n        return -1;\n\n    }\n\n    if(c->frames_to_skip){\n\n        c->frames_to_skip--;\n\n        *got_frame_ptr = 0;\n\n        return avpkt->size;\n\n    }\n\n\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = c->frame;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 8878, "substitutes": {"avctx": ["navctx", "avcmp", "vercu", "avcontext", "afcci", "avcci", "aphctx", "AVctx", "AVmac", "avectx", "aircontext", "avcas", "navcontext", "avcf", "avmac", "Avctx", "avecf", " avcci", "vercontext", "aphcontext", "abcontext", "vercas", "avercu", "avsync", "aphctl", "afsync", "afmac", " avcmp", "Avcontext", " avcontext", "navsync", "averctx", "avcu", "afcas", "abctx", "airctl", "abcu", "avercontext", "afconn", "AVcmp", "afcf", "airsync", "Avcmp", "Avconn", "aphcu", " avconn", "avesync", "verctx", "avecontext", "afcu", "avercas", "AVcontext", " avmac", "avectl", "abctl", "afctl", " avcf", "avecci", "avconn", "afctx", "avctl", "airctx", "afcmp", "afcontext", "navctl"], "data": ["bus", "dat", "pos", "ata", "message", "block", "board", "f", "device", "Data", "api", "connection", "result", "media", "module", "d", "DATA", "config", "bytes", "p", "content", "input", "queue", "frame", "end", "memory", "v", "code", "image", "parent", "mem", "reader", "length", "da", "bin", "next", "buff", "m", "buffer", "body", "base", "batch", "window", "cache"], "got_frame_ptr": ["got_frames_pointer", "got_frame2buffer", "got_frames2pointers", "got_frame2pointers", "got_frames2pointer", "got_frame2ptr", "got_frame_pointer", "got_frames2ptr", "got_frames_ptr", "got_frame2pointer", "got_frames_buffer", "got_frame_pointers", "got_frame_buffer", "got_frames_pointers", "got_frames2buffer"], "avpkt": ["avprkt", "avebkt", "affkg", "AVpKT", "avvpct", "afpkg", "avfct", "avfKT", "avpct", "avpafd", "afpeter", "avepkt", "avbpkh", "avebct", "avpkh", "avpnn", "avbpacket", "afpkt", "AVpct", "avPacket", "avebcht", "affacket", "abpfd", "abpkt", "avvpKT", "avPkh", "avbpkt", "avPkt", "AVpacket", "avvpkt", "avpeter", "AVpkt", "avccht", "avPct", "abcfd", "avppKT", "afpacket", "avpaeter", "abcct", "avfkt", "avmacket", "avbct", "avbkt", "abpacket", "avpcht", "avbnn", "avepnn", "avbpct", "avpkg", "avfacket", "AVppkg", "avcnn", "avvpkg", "AVppct", "avmkg", "avepct", "avprct", "avpfd", "avpakg", "abcacket", "avbcht", "AVppkt", "AVPct", "AVPkt", "avpaacket", "avepcht", "avebnn", "avfkg", "AVpkh", "avcct", "abckt", "avckt", "affeter", "avpacket", "avppkt", "avpKT", "avppct", "avpact", "avprnn", "avfkh", "avmeter", "avffd", "avfeter", "AVPkh", "abpct", "avcacket", "AVPacket", "avcfd", "affkt", "AVppKT", "avmkt", "AVpkg", "avpakt", "avppkg", "avprcht"], "buf": ["cas", "bus", "utf", "block", "vec", "src", "ref", "ff", "home", "grab", "proc", "bu", "bc", "bag", "seq", "pb", "box", "len", "fab", "sb", "rc", "bytes", "config", "cb", "cur", "loc", "b", "fb", "queue", "lim", "img", "context", "feed", "rb", "array", "bd", "v", "cv", "mem", "num", "bb", "alloc", "br", "que", "uf", "cmd", "cf", "buff", "map", "ab", "bf", "buffer", "func", "port", "wb", "uc", "raw", "batch", "av", "feat"], "buf_size": [" buf_sec", "block_sized", "bglexscale", "block_width", "buflexsec", "buf2source", "bag_storage", "buf_width", "bg_count", "buf_capacity", "buf_scale", "buflensize", " buf_Size", "buflenshape", " buf_len", "buflexsize", "buflexloc", " buf_ize", " buf_width", "buf2scale", "bg_size", "bag_size", "buf2size", "buf2ize", "buflexstorage", "buf64len", "buflexwidth", "block_capacity", "buf_ize", "buflexsized", "buf_source", " buf_scale", "buf_color", "bg_color", "buflexscale", "bag_set", "bg_loc", "bg_start", "buf_storage", "block_size", " buf_shape", "buf_shape", "buf_start", "bag_sec", "buflexset", "buf__width", "buf_set", "buf__scale", "buf_len", "buf_Size", " buf_sized", "bg_scale", "block_scale", "bglexsize", "block_shape", "buf_loc", "buf_count", "bglexcolor", "bglexloc", "buflexcolor", "buf64size", "buf64shape", "buflenlen", "buf_sec", "buf__size", " buf_source", "buf__sized", "buf_sized"], "c": ["ctx", "f", "unc", "k", "xc", "cs", "nc", "self", "icc", "bc", "vc", "ce", "pc", "ca", "cmp", "co", "a", "d", "config", "cat", "h", "p", "enc", "cb", "rc", "b", "cy", "ic", "cm", "cp", "cu", "con", "ct", "context", "core", "cc", "coll", "C", "dc", "ac", "v", "fc", "t", "cv", "r", "cl", "cmd", "l", "cf", "ci", "u", "sc", "conn", "w", "m", "e", "n", "this", "cn", "tc", "lc", "ec", "s", "uc", "cca", "mc", "sec", "exec", "cd", "cache"], "gb": ["g", "ga", " eg", "ctx", "bm", " conf", "cs", " pci", " GC", "gam", " co", "GB", "gram", "gm", "bc", "rg", "gg", "gu", "ki", "pc", "db", "gd", "usb", " gcc", "sb", "cb", "kb", "tg", "tm", " img", "gl", "gy", " db", "cm", "bg", "gio", "gi", "cfg", " kb", " rc", "cc", "rb", "di", "sl", "bb", "bin", "gp", "gin", "cf", "ci", "gpu", "lib", "git", "gs", "nn", " cm", " ic", " gl", " bi", "mc", "py", "gc", "bf"], "i": ["ii", "ti", "ni", "li", "im", "f", "id", "phi", "I", "k", "ip", "mi", "fi", "chi", "y", "ki", "is", "ini", "sup", "d", "multi", "h", "p", "ani", "si", "b", "di", "pi", "io", "j", "gi", "ie", "in", "v", "zi", "bi", "xi", "ind", "r", "ui", "qi", "ik", "ih", "t", "l", "ci", "u", "index", "m", "n", "info", "ai", "eni", "count", "x", "ix", "it"], "ch": ["g", "ph", "f", "k", "th", "chi", "y", "chan", "ver", "cht", "arch", "h", "cb", "cur", "chip", "sh", "gh", "b", "cy", "cp", "cm", "bh", "zh", "j", "cor", "z", "code", "cha", "ich", "che", "channel", "cl", "ach", "ci", "sc", "u", "q", "conn", "conf", "col", "qu", "sk", "cho", "batch", "tch", "mot", "count", "x", "sch"], "bands": ["bass", "cards", "planes", "cycles", "groups", "devices", "rings", "audio", "rooms", "bps", "tones", "points", "ks", "ands", "cats", "annels", "bytes", "lines", "girls", "steps", "blocks", "tracks", "fb", "ds", "hops", "pages", "classes", "files", "objects", "cells", "units", "chains", "limits", "codes", "levels", "pieces", "frames", "plugins", "pins", "buff", "boxes", "banks", "versions", "bits", "heads", "tags", "nets", "boards", "band", "locks", "features"], "off": ["pos", "Off", " def", "on", "type", "mode", "ip", "ff", " dev", " num", " af", " on", " offset", "offset", "offs", "loop", "op", "num", "o", "opt", "def", "dev", "info", "out", "ef", "ops"], "ret": ["tr", "valid", "utf", "rt", "rets", "f", "att", "match", "re", "RET", "ref", "ft", "result", "bc", "success", "len", "dist", "iter", "ben", "dr", "rc", "back", "nil", "arr", "lit", "fun", "ext", "bit", "mem", "active", "fail", "val", "det", "def", "bad", "arg", "reply", "obj", "info", "progress", "value", "res", "nt", "reg", "fin", "alt", "Ret", "status", "feat", "miss"], "last_frame": ["last_frames", "lastNewframe", "last__frame", "lastNewfram", " last_frames", "first_element", "last_element", "last_fram", "lastSubframe", "lastSubframes", "last_line", "lastNewelement", "first_fram", "last__frames", "next_frame", " last_line", "last__pixel", "first_frame", "last_pixel", "lastSubpixel", "next_frames", "next_pixel"], "skip": ["pos", "pass", "no", "wait", "ip", "prev", "hide", "proc", "addr", "min", "seq", "len", "track", "cmp", "sleep", "scan", "offset", "loss", "slot", "step", "vis", "sp", "seed", "ips", "sid", "total", "feed", "missing", "Skip", "cpu", "loop", "op", "mem", "copy", "num", "error", "opt", "count", "def", "ops", "mask", "next", "fast", "rec", "strip", "delay", "speed", "progress", "jump", "sk", "status", "send", "extra", "stop", "miss", "slice"], "bits_used": [" bits_needed", "bits_sent", "bits_needed", " bits_available", " bits_sent", "bits_available"], "bits_avail": ["bits_attadded", "bits_abailed", "bits_avanged", "bits_availed", "bits_attanged", "bits_capailed", "bits_avadded", "bits_capadded", "bits_capanged", "bits_abanged", "bits_attail", "bits_attailed", "bits_abadded", "bits_abail", "bits_capail"]}}
{"project": "FFmpeg", "commit_id": "35cb6854bb76b4a5b6f2aea2dce81e18d7ab61cd", "target": 1, "func": "static int rle_unpack(const unsigned char *src, int src_len, int src_count,\n\n                      unsigned char *dest, int dest_len)\n\n{\n\n    const unsigned char *ps;\n\n    const unsigned char *ps_end;\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n\n\n    ps = src;\n\n    ps_end = src + src_len;\n\n    pd = dest;\n\n    if (src_count & 1) {\n\n        if (ps_end - ps < 1)\n\n            return 0;\n\n        *pd++ = *ps++;\n\n    }\n\n\n\n    src_count >>= 1;\n\n    i = 0;\n\n    do {\n\n        if (ps_end - ps < 1)\n\n            break;\n\n        l = *ps++;\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (pd + l > dest_end || ps_end - ps < l)\n\n                return ps - src;\n\n            memcpy(pd, ps, l);\n\n            ps += l;\n\n            pd += l;\n\n        } else {\n\n            if (pd + i > dest_end || ps_end - ps < 2)\n\n                return ps - src;\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = ps[0];\n\n                *pd++ = ps[1];\n\n            }\n\n            ps += 2;\n\n        }\n\n        i += l;\n\n    } while (i < src_count);\n\n\n\n    return ps - src;\n\n}\n", "idx": 8900, "substitutes": {"src": ["la", "pos", "setup", "ctx", "size", "ptr", "buf", "ls", "repl", "pl", "proc", "comp", "supp", "inf", "sel", "sub", "seq", "low", "sq", "dist", "cmp", "sup", "ins", "master", "sr", "sb", "rc", "config", "rss", "cur", "cb", "pack", "loc", "st", "lit", "ssl", "bg", "load", "img", "url", "gb", "rb", "sl", "ruby", "fc", "spec", "push", "rx", "length", "source", "r", "req", "sort", "sc", "sync", "proxy", "start", "rec", "desc", "rs", "lc", "uc", "sec", "raw", "rib", "inst", "target"], "src_len": ["rc_count", "rc_len", "source_length", "src_length", "source_len", "rc_line", "src_l", "rc_length", "source_line", "source_l", "src_line"], "src_count": ["src__size", "srcMlen", "src_end", "srcMcount", "srcJcount", "srcJend", "src_c", "src__len", "dest_c", "src_length", "srcMend", "dest_count", "srcJlength", " src_size", "src__end", "src_size", " src_length", "dest_size", " src_end", "src__count", "srcJsize"], "dest": ["usr", "prop", "de", "wd", "pipe", " destination", "pos", "id", "diff", "path", "ptr", "cdn", "home", "destroy", "route", "dist", "sup", "d", "master", "node", "Dest", "des", "loc", "ds", "ssl", "cp", "gen", "cont", "go", "tmp", "dc", "push", "source", "sort", "wp", "sync", "delete", "desc", "dep", "trans", "wb", "rest", "priv", "name", "rib", "txt", "data", "target", "dir", "slice"], "dest_len": ["comb_count", "comb01length", "comb_length", "dest01len", "comb01count", "dest01line", "dest_limit", " dest_limit", " dest_length", "dest_count", "comb01len", "comb_len", "dest_length", "dest01length", " dest_line", "dest01count", "comb_line", "comb01line", "dest_line"], "ps": ["pse", "cs", "ppa", "lines", "sp", "itions", "pre", "par", "hs", "css", "ets", "pp", "gs", "rs", " posts", "js", "Ps", "vs", "eps", "os", "pass", "posts", "its", "ls", "ups", "ss", "powers", "bps", "ins", "params", "lp", " pops", "aps", "ep", "ds", "amps", "fs", "pages", "pt", "rules", "pe", "ms", "ans", "qs", "pins", "s", "ports", "als", "cases", "changes", "pg", "pm", "parts", "php", "pl", "points", "times", "pr", "ips", "PS", "bs", " props", "pa", "py", "pos", "local", "ys", "pps", "es", "p", "ts", "pi", "cp", "ars", "files", "po", "ns", "pes", "ops"], "ps_end": ["ps_len", "ps___start", "ps_ad", "ds_vert", "ds_END", "eps_ends", "eps_enter", "ps_enable", "ds_start", "ps_enter", "ds_enable", "eps_ad", "ds_dev", "eps_END", "ps_dev", "ps_ends", "eps_ending", "ds_len", "eps_start", "ps_ending", "ps_END", "ps___dev", "ds_add", "eps_end", "ds_end", "ps___end", "ps___len", "ps_start", "ps_vert", "ps_add"], "pd": ["la", "np", "ph", "li", "hd", "wd", "pg", "sd", "tp", "sth", "pn", "dp", "pse", "pm", "phi", "php", "ls", "pl", "xd", "ppa", "td", "parser", "pb", "pc", "d", "pu", "lp", "pex", "pr", "p", "ds", "pi", "cp", "ld", "pt", "vd", "po", "bd", "pe", "dd", "lv", "da", "wp", "PD", "pp", "sync", "od", "dep", "pat", "pa", "ln", "yd", "lc", "fd", "py", "dl", "ad", "dt", "pid", "pod"], "i": ["ii", "ni", "li", "uri", "f", "id", "phi", "I", "api", "ip", "mi", "fi", "y", "c", "yi", "iu", "is", "ini", "d", "lp", "ri", "p", "ji", "si", "anti", "b", "pi", "uli", "io", "j", "gi", "ie", "ami", "cli", "di", "v", "xi", "zi", "bi", "ind", "o", "ui", "qi", "t", "ci", "q", "u", "index", "m", "e", "n", "ai", "lc", "dl", "vi", "x", "ix", "it"], "l": ["la", "li", "f", "ll", "ls", "pl", "ul", "y", "len", "c", "lb", "d", "lp", "p", "ol", "b", "lit", "le", "fl", "j", "nl", "wl", "sl", "kl", "v", "il", "lv", "lin", "el", "r", "o", "t", "length", "u", "m", "e", "n", "ln", "lu", "lc", "s", "L", "dl", "lf"], "dest_end": ["path_end", " dest_fail", " dest_ended", "destrictfail", "pathamend", "dest_start", "destamcount", "pathamended", "dest__ends", "pathamcount", "destamend", "destnetend", "dest_count", "destnetstart", "path_count", " dest_start", "dest_ended", "destnetfail", "dest__ended", " dest_ends", "destrictend", "destrictcount", "dest_ends", "dest_fail", "path_ended", "destamended", " dest_count", "dest__start", "destrictstart", "destnetcount", "destamstart", "path_start", "pathamstart", "dest__end"]}}
{"project": "FFmpeg", "commit_id": "4f00519d9508e07aac58a00a9b514dae8ad95723", "target": 1, "func": "int vc1_decode_sequence_header(AVCodecContext *avctx, VC1Context *v, GetBitContext *gb)\n\n{\n\n    av_log(avctx, AV_LOG_DEBUG, \"Header: %0X\\n\", show_bits(gb, 32));\n\n    v->profile = get_bits(gb, 2);\n\n    if (v->profile == PROFILE_COMPLEX)\n\n    {\n\n        av_log(avctx, AV_LOG_WARNING, \"WMV3 Complex Profile is not fully supported\\n\");\n\n    }\n\n\n\n    if (v->profile == PROFILE_ADVANCED)\n\n    {\n\n        v->zz_8x4 = ff_vc1_adv_progressive_8x4_zz;\n\n        v->zz_4x8 = ff_vc1_adv_progressive_4x8_zz;\n\n        return decode_sequence_header_adv(v, gb);\n\n    }\n\n    else\n\n    {\n\n        v->zz_8x4 = wmv2_scantableA;\n\n        v->zz_4x8 = wmv2_scantableB;\n\n        v->res_y411   = get_bits1(gb);\n\n        v->res_sprite = get_bits1(gb);\n\n        if (v->res_y411)\n\n        {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Old interlaced mode is not supported\\n\");\n\n            return -1;\n\n        }\n\n        if (v->res_sprite) {\n\n            av_log(avctx, AV_LOG_ERROR, \"WMVP is not fully supported\\n\");\n\n        }\n\n    }\n\n\n\n    // (fps-2)/4 (->30)\n\n    v->frmrtq_postproc = get_bits(gb, 3); //common\n\n    // (bitrate-32kbps)/64kbps\n\n    v->bitrtq_postproc = get_bits(gb, 5); //common\n\n    v->s.loop_filter = get_bits1(gb); //common\n\n    if(v->s.loop_filter == 1 && v->profile == PROFILE_SIMPLE)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"LOOPFILTER shall not be enabled in Simple Profile\\n\");\n\n    }\n\n    if(v->s.avctx->skip_loop_filter >= AVDISCARD_ALL)\n\n        v->s.loop_filter = 0;\n\n\n\n    v->res_x8 = get_bits1(gb); //reserved\n\n    v->multires = get_bits1(gb);\n\n    v->res_fasttx = get_bits1(gb);\n\n    if (!v->res_fasttx)\n\n    {\n\n        v->vc1dsp.vc1_inv_trans_8x8 = ff_simple_idct_8;\n\n        v->vc1dsp.vc1_inv_trans_8x4 = ff_simple_idct84_add;\n\n        v->vc1dsp.vc1_inv_trans_4x8 = ff_simple_idct48_add;\n\n        v->vc1dsp.vc1_inv_trans_4x4 = ff_simple_idct44_add;\n\n        v->vc1dsp.vc1_inv_trans_8x8_dc = ff_simple_idct_add_8;\n\n        v->vc1dsp.vc1_inv_trans_8x4_dc = ff_simple_idct84_add;\n\n        v->vc1dsp.vc1_inv_trans_4x8_dc = ff_simple_idct48_add;\n\n        v->vc1dsp.vc1_inv_trans_4x4_dc = ff_simple_idct44_add;\n\n    }\n\n\n\n    v->fastuvmc =  get_bits1(gb); //common\n\n    if (!v->profile && !v->fastuvmc)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"FASTUVMC unavailable in Simple Profile\\n\");\n\n        return -1;\n\n    }\n\n    v->extended_mv =  get_bits1(gb); //common\n\n    if (!v->profile && v->extended_mv)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Extended MVs unavailable in Simple Profile\\n\");\n\n        return -1;\n\n    }\n\n    v->dquant =  get_bits(gb, 2); //common\n\n    v->vstransform =  get_bits1(gb); //common\n\n\n\n    v->res_transtab = get_bits1(gb);\n\n    if (v->res_transtab)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"1 for reserved RES_TRANSTAB is forbidden\\n\");\n\n        return -1;\n\n    }\n\n\n\n    v->overlap = get_bits1(gb); //common\n\n\n\n    v->s.resync_marker = get_bits1(gb);\n\n    v->rangered = get_bits1(gb);\n\n    if (v->rangered && v->profile == PROFILE_SIMPLE)\n\n    {\n\n        av_log(avctx, AV_LOG_INFO,\n\n               \"RANGERED should be set to 0 in Simple Profile\\n\");\n\n    }\n\n\n\n    v->s.max_b_frames = avctx->max_b_frames = get_bits(gb, 3); //common\n\n    v->quantizer_mode = get_bits(gb, 2); //common\n\n\n\n    v->finterpflag = get_bits1(gb); //common\n\n\n\n    if (v->res_sprite) {\n\n        v->s.avctx->width  = v->s.avctx->coded_width  = get_bits(gb, 11);\n\n        v->s.avctx->height = v->s.avctx->coded_height = get_bits(gb, 11);\n\n        skip_bits(gb, 5); //frame rate\n\n        v->res_x8 = get_bits1(gb);\n\n        if (get_bits1(gb)) { // something to do with DC VLC selection\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported sprite feature\\n\");\n\n            return -1;\n\n        }\n\n        skip_bits(gb, 3); //slice code\n\n        v->res_rtm_flag = 0;\n\n    } else {\n\n        v->res_rtm_flag = get_bits1(gb); //reserved\n\n    }\n\n    if (!v->res_rtm_flag)\n\n    {\n\n//            av_log(avctx, AV_LOG_ERROR,\n\n//                   \"0 for reserved RES_RTM_FLAG is forbidden\\n\");\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Old WMV3 version detected, some frames may be decoded incorrectly\\n\");\n\n        //return -1;\n\n    }\n\n    //TODO: figure out what they mean (always 0x402F)\n\n    if(!v->res_fasttx) skip_bits(gb, 16);\n\n    av_log(avctx, AV_LOG_DEBUG,\n\n               \"Profile %i:\\nfrmrtq_postproc=%i, bitrtq_postproc=%i\\n\"\n\n               \"LoopFilter=%i, MultiRes=%i, FastUVMC=%i, Extended MV=%i\\n\"\n\n               \"Rangered=%i, VSTransform=%i, Overlap=%i, SyncMarker=%i\\n\"\n\n               \"DQuant=%i, Quantizer mode=%i, Max B frames=%i\\n\",\n\n               v->profile, v->frmrtq_postproc, v->bitrtq_postproc,\n\n               v->s.loop_filter, v->multires, v->fastuvmc, v->extended_mv,\n\n               v->rangered, v->vstransform, v->overlap, v->s.resync_marker,\n\n               v->dquant, v->quantizer_mode, avctx->max_b_frames\n\n               );\n\n    return 0;\n\n}\n", "idx": 8901, "substitutes": {"avctx": ["navctx", "avcmp", "avconfig", " avsc", "avcontext", "vctx", "vercb", "afsc", "AVctx", "avectx", "vcmp", "AVsync", "abcmp", " avcu", "navcontext", "afconfig", "cvconfig", "AVctl", "AVsc", "avcb", "AVlc", "verlc", "afpkg", "AVconfig", "vercontext", "cvcontext", "abcontext", "navlc", "avsync", "vcontext", " avcmp", " avcontext", "navsync", "avlc", "abconn", "avcu", "avpkg", "verconn", "abctx", "abcu", "AVcmp", "AVcn", "cvctx", "avesync", "AVconn", "navcn", "verctx", "avecontext", "avsc", "avecn", "AVcb", "AVcontext", "avcn", "navcb", "cvctl", "afctl", "avconn", "AVpkg", "afctx", "vpkg", "AVcu", "navconn", "avctl", "afcmp", "afcontext", "ablc"], "v": ["ii", "g", "vol", "version", "f", "va", "k", "vt", "api", "view", "ov", "rev", "vc", "gu", "c", "conv", "ver", "i", "sv", "d", "vim", "ev", "h", "p", "vg", "b", "j", "vr", "vd", "uv", "nav", "av", "iv", "cv", "vin", "lv", "vm", "vert", "z", "t", "nv", "val", "inv", "l", "V", "q", "u", "vp", "dev", "qv", "m", "e", "n", "tv", "value", "s", "var", "vv", "video", "vi", "ve", "vs", "x", "volt"], "gb": ["Gb", "ga", "g", "phy", "hd", "bm", "gnu", "bn", "gam", "GB", "gram", "gm", "nb", "rg", "bc", "gg", "ged", "gom", "db", "gd", "pc", "game", "lb", "eb", "usb", "xy", "sb", "cgi", "gow", "cb", "kb", "bo", "gh", "gy", "mb", "gate", "b", "bg", "ub", "kw", "cfg", "rb", "bd", "ko", "cli", "gal", "hub", "ch", "bb", "ui", "gp", "abb", "gin", "gpu", "agg", "lib", "git", "gs", "ge", "storage", "bf", "gru", "hm"]}}
{"project": "qemu", "commit_id": "5b456438f5bb395ed6b1eec95e18ce7a7a884a0a", "target": 1, "func": "static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)\n\n{\n\n    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));\n\n    if (qdev_init(vdev) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    object_property_set_link(OBJECT(dev),\n\n                             OBJECT(dev->vdev.conf.default_backend), \"rng\",\n\n                             NULL);\n\n\n\n    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));\n\n}\n", "idx": 8903, "substitutes": {"s390_dev": ["solar_conf", "s170_device", "s180_dev", "solar_de", "s170_def", "s390_priv", "solar_debug", "s390xconf", "s390_debug", "solar_dev", "s390xdebug", "s380_priv", "s390_def", "s180_ev", "s170_ev", "s380_device", "s390xde", "s390xdev", "s390_ev", "s380_ev", "s180_def", "s390_de", "s390_device", "s180_device", "s380_dev", "s170_dev", "s390_conf"], "dev": ["debug", "dem", "bus", "de", "wd", "hw", "sd", "device", "diff", " priv", "dom", "rad", "td", "DEV", "adv", "gu", "md", "gd", "ver", "user", "d", "ev", "mod", "development", "temp", "der", "app", "driver", "Dev", "grad", "di", "v", "dc", "dd", "client", "prov", "error", "def", "conn", "cam", "conf", "dm", "obj", "info", "var", "fin", "priv", "ad", "data", "dt", "bug"], "vdev": ["qdef", "uvdb", "vDev", "vbus", "cbus", "vdef", "wdiv", "tvbus", " vdef", "qdevice", "pdef", "pDev", "qconn", "qDev", "vver", " vdb", " vver", " vdevice", "qdev", "vconn", " vdi", "wdevice", "uvdev", "uvrad", "uvdiv", "cconn", "cdevice", " vbus", "lrad", "ldb", "qdi", "cver", "pdev", "pdevice", "vdi", "tvdevice", "cdev", "tvver", "vdevice", "ldevice", "ldef", "vrad", "qdiv", "qdb", "tvdev", " vDev", "ldev", "wrad", " vdiv", "wdev", " vconn", "cdi", "vdiv", " vrad", "vdb", "qrad"]}}
{"project": "qemu", "commit_id": "0fbfbb59a9766247be20023b17eb7872e7b29323", "target": 0, "func": "static void apic_update_irq(APICState *s)\n\n{\n\n    int irrv, ppr;\n\n    if (!(s->spurious_vec & APIC_SV_ENABLE))\n\n        return;\n\n    irrv = get_highest_priority_int(s->irr);\n\n    if (irrv < 0)\n\n        return;\n\n    ppr = apic_get_ppr(s);\n\n    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))\n\n        return;\n\n    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);\n\n}\n", "idx": 8927, "substitutes": {"s": ["g", "os", "sym", "args", "f", "service", "parts", "cs", "ls", "state", "sf", "ss", "states", "c", "is", "ks", "i", "services", "d", "sb", "params", "es", "p", "ts", "sg", "si", "S", "ds", "details", "ssl", "ns", "spec", "t", "o", "ps", "ses", "qs", "sync", "gs", "m", "south", "e", "sets", "sys", "sec", "js"], "irrv": [" irerv", "irrcf", "irrrva", " irerf", "irrdb", "irrrve", "irtrrv", "irtrve", "irprq", "rrrva", "rrva", "irrva", "irrdv", "irrarf", "irrf", "irrrvu", "irtrq", "irtrv", "irrdve", "rrrv", "rrp", "irprv", "irtrrb", "irrrq", "irrarva", "mirrcf", "irrx", "irrcp", "irrcv", "mirrcva", "irtrb", "irrp", "irerv", "irdrf", "rrx", "irerq", "irdrv", "irrcq", "rrrp", "irdrk", "irprve", " irrk", "irrdva", "irrarv", "mirrv", "rrv", "irrq", "irtrrq", "irtrrve", "rrrx", "irrcva", "irrb", "mirrvu", " irrf", "irerk", "irrrf", "irrdq", "irrrb", "irrrp", "mirrf", " irerk", "mirrcv", "irrvu", "mirrva", "irerf", " irerq", "irrarvu", "irrk", "irrdp", " irrq", "irrrv", "irrck", "irrve", "irprb", "irdrq", "irrrx", "irrcx", "mirrcvu", "irrcvu", "irrdx"], "ppr": ["prv", "ipr", "mphr", "mpr", "ptr", "ppv", "ippr", "ippp", "ppnr", "upphr", "prnr", "ypr", "ipnr", "ptp", "ampr", "uppp", "pphr", "eprt", "yprt", "ypri", "mpv", "upppr", "mpp", "ipppr", "iphr", "epr", "ptri", "ipri", "prpr", "ptpr", "ipv", "ipp", "amprt", "amppr", "yppr", "ppp", "mppr", "ppri", "mpnr", "pppr", "uppr", "eppr", "prr", "ippri", "ampri", "pprt", "epri"]}}
{"project": "qemu", "commit_id": "41ecc72ba5932381208e151bf2d2149a0342beff", "target": 0, "func": "setup_sigcontext(struct target_sigcontext *sc, struct target_fpstate *fpstate,\n\n\t\t CPUX86State *env, abi_ulong mask, abi_ulong fpstate_addr)\n\n{\n\n    CPUState *cs = CPU(x86_env_get_cpu(env));\n\n    int err = 0;\n\n    uint16_t magic;\n\n\n\n\t/* already locked in setup_frame() */\n\n    __put_user(env->segs[R_GS].selector, (unsigned int *)&sc->gs);\n\n    __put_user(env->segs[R_FS].selector, (unsigned int *)&sc->fs);\n\n    __put_user(env->segs[R_ES].selector, (unsigned int *)&sc->es);\n\n    __put_user(env->segs[R_DS].selector, (unsigned int *)&sc->ds);\n\n    __put_user(env->regs[R_EDI], &sc->edi);\n\n    __put_user(env->regs[R_ESI], &sc->esi);\n\n    __put_user(env->regs[R_EBP], &sc->ebp);\n\n    __put_user(env->regs[R_ESP], &sc->esp);\n\n    __put_user(env->regs[R_EBX], &sc->ebx);\n\n    __put_user(env->regs[R_EDX], &sc->edx);\n\n    __put_user(env->regs[R_ECX], &sc->ecx);\n\n    __put_user(env->regs[R_EAX], &sc->eax);\n\n    __put_user(cs->exception_index, &sc->trapno);\n\n    __put_user(env->error_code, &sc->err);\n\n    __put_user(env->eip, &sc->eip);\n\n    __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs);\n\n    __put_user(env->eflags, &sc->eflags);\n\n    __put_user(env->regs[R_ESP], &sc->esp_at_signal);\n\n    __put_user(env->segs[R_SS].selector, (unsigned int *)&sc->ss);\n\n\n\n        cpu_x86_fsave(env, fpstate_addr, 1);\n\n        fpstate->status = fpstate->sw;\n\n        magic = 0xffff;\n\n    __put_user(magic, &fpstate->magic);\n\n    __put_user(fpstate_addr, &sc->fpstate);\n\n\n\n\t/* non-iBCS2 extensions.. */\n\n    __put_user(mask, &sc->oldmask);\n\n    __put_user(env->cr[2], &sc->cr2);\n\n\treturn err;\n\n}\n", "idx": 8931, "substitutes": {"sc": ["la", "ga", "de", "scl", "ctx", "src", "usc", "sw", "nc", "sche", "pl", "bc", "ka", "can", "c", "sq", "squ", "pc", "ca", "sr", "esc", "rc", "config", "enc", "scan", "cgi", "cur", "sci", "sp", "scope", "con", "context", "cc", "osc", "go", "fc", "cv", "spec", "dc", "pac", "SC", "inc", "row", "cl", "Sc", "ci", "sync", "cus", "cr", "acc", "capt", "com", "desc", "cle", "crit", "ec", "lc", "uc", "mc", "sec", "asc", "contract", "hel", "exec", "sch", "isc"], "cs": ["cas", "ics", "cases", "ctx", "args", "its", "ls", "nc", "ss", "checks", "bc", "wcs", "c", "pc", "ks", "ins", "rc", "es", "rss", "ts", "nas", "ds", "scope", "outs", "fs", "cp", "ips", "cal", "CS", "csv", "cc", "ns", "spec", "codes", "css", "ras", "ps", "qs", "cf", "conn", "cer", "cus", "sync", "gs", "pec", "sys", "rs", "sk", "ec", "s", "vs", "ops", "Cs"], "magic": ["ok", "Error", "ctr", "ALL", "max", "result", " ERROR", " success", "ERROR", "work", "done", " alloc", "oid", " done", "alloc", "error", "start", " len", "MAX"]}}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)\n\n{\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n\n\n    /* Free resources */\n\n    qemu_iovec_destroy(&acb->cur_qiov);\n\n    qed_unref_l2_cache_entry(acb->request.l2_table);\n\n\n\n    /* Free the buffer we may have allocated for zero writes */\n\n    if (acb->flags & QED_AIOCB_ZERO) {\n\n        qemu_vfree(acb->qiov->iov[0].iov_base);\n\n        acb->qiov->iov[0].iov_base = NULL;\n\n    }\n\n\n\n    /* Start next allocating write request waiting behind this one.  Note that\n\n     * requests enqueue themselves when they first hit an unallocated cluster\n\n     * but they wait until the entire request is finished before waking up the\n\n     * next request in the queue.  This ensures that we don't cycle through\n\n     * requests multiple times but rather finish one at a time completely.\n\n     */\n\n    if (acb == s->allocating_acb) {\n\n        s->allocating_acb = NULL;\n\n        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {\n\n            qemu_co_enter_next(&s->allocating_write_reqs);\n\n        } else if (s->header.features & QED_F_NEED_CHECK) {\n\n            qed_start_need_check_timer(s);\n\n        }\n\n    }\n\n}\n", "idx": 8946, "substitutes": {"acb": ["acv", "dcbb", "ucB", "ecw", "axv", "ecu", "ACbb", "accbr", "accB", "achbh", "agb", "agbs", "aitbh", "macbb", "ocB", "accu", "ancbr", "agB", "achb", "acu", " acB", "ack", "ACb", "ancb", "ecv", "ecbb", "ecf", "ACbase", "ecB", "ecsb", "acbase", "ecbs", "acbi", "acbb", "achbase", "ACf", " acw", "acf", "accbase", "agbb", "ocbase", "axb", " acf", " acbr", "accv", "macbi", "ACsb", "ucb", " acbi", "ecb", "acw", "ocbb", "accf", "ACw", "ucbr", "ocb", "acbh", " acsb", "acsb", "accb", " acbb", "acB", "acbr", "macb", "accbb", "axu", "achbb", "aitbase", "dcsb", "accbh", "dcbase", "mack", "aitb", "dcb", " ack", "ancbb", "ecbi", "acbs", "aitbb", "ocsb", " acv", "ancv", "eck", "ucf", "axf", "ocbs"], "s": ["g", "os", "changes", "sym", "f", "args", "service", "cs", "ls", "state", "ss", "states", "c", "is", "a", "ks", "an", "services", "params", "sb", "rows", "es", "d", "p", "ts", "sg", "si", "S", "ds", "b", "scope", "fs", "ssl", "secondary", "sl", "ns", "in", "hs", "spec", "r", "t", "o", "ps", "ses", "l", "your", "sync", "u", "gs", "submit", "m", "south", "e", "n", "sys", "sets", "su", "rs", "comments", "storage", "sa", "info", "js", "stats", "data", "status", "aws"]}}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus,\n\n                                   uint8_t devfn, hwaddr addr, bool is_write,\n\n                                   IOMMUTLBEntry *entry)\n\n{\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    VTDContextEntry ce;\n\n    uint8_t bus_num = pci_bus_num(bus);\n\n    VTDContextCacheEntry *cc_entry = &vtd_as->context_cache_entry;\n\n    uint64_t slpte, page_mask;\n\n    uint32_t level;\n\n    uint16_t source_id = vtd_make_source_id(bus_num, devfn);\n\n    int ret_fr;\n\n    bool is_fpd_set = false;\n\n    bool reads = true;\n\n    bool writes = true;\n\n    uint8_t access_flags;\n\n    VTDIOTLBEntry *iotlb_entry;\n\n\n\n    /*\n\n     * We have standalone memory region for interrupt addresses, we\n\n     * should never receive translation requests in this region.\n\n     */\n\n    assert(!vtd_is_interrupt_addr(addr));\n\n\n\n    /* Try to fetch slpte form IOTLB */\n\n    iotlb_entry = vtd_lookup_iotlb(s, source_id, addr);\n\n    if (iotlb_entry) {\n\n        trace_vtd_iotlb_page_hit(source_id, addr, iotlb_entry->slpte,\n\n                                 iotlb_entry->domain_id);\n\n        slpte = iotlb_entry->slpte;\n\n        access_flags = iotlb_entry->access_flags;\n\n        page_mask = iotlb_entry->mask;\n\n        goto out;\n\n    }\n\n\n\n    /* Try to fetch context-entry from cache first */\n\n    if (cc_entry->context_cache_gen == s->context_cache_gen) {\n\n        trace_vtd_iotlb_cc_hit(bus_num, devfn, cc_entry->context_entry.hi,\n\n                               cc_entry->context_entry.lo,\n\n                               cc_entry->context_cache_gen);\n\n        ce = cc_entry->context_entry;\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n    } else {\n\n        ret_fr = vtd_dev_to_context_entry(s, bus_num, devfn, &ce);\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n        if (ret_fr) {\n\n            ret_fr = -ret_fr;\n\n            if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n                trace_vtd_fault_disabled();\n\n            } else {\n\n                vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n            }\n\n            goto error;\n\n        }\n\n        /* Update context-cache */\n\n        trace_vtd_iotlb_cc_update(bus_num, devfn, ce.hi, ce.lo,\n\n                                  cc_entry->context_cache_gen,\n\n                                  s->context_cache_gen);\n\n        cc_entry->context_entry = ce;\n\n        cc_entry->context_cache_gen = s->context_cache_gen;\n\n    }\n\n\n\n    /*\n\n     * We don't need to translate for pass-through context entries.\n\n     * Also, let's ignore IOTLB caching as well for PT devices.\n\n     */\n\n    if (vtd_ce_get_type(&ce) == VTD_CONTEXT_TT_PASS_THROUGH) {\n\n        entry->iova = addr & VTD_PAGE_MASK_4K;\n\n        entry->translated_addr = entry->iova;\n\n        entry->addr_mask = ~VTD_PAGE_MASK_4K;\n\n        entry->perm = IOMMU_RW;\n\n        trace_vtd_translate_pt(source_id, entry->iova);\n\n\n\n        /*\n\n         * When this happens, it means firstly caching-mode is not\n\n         * enabled, and this is the first passthrough translation for\n\n         * the device. Let's enable the fast path for passthrough.\n\n         *\n\n         * When passthrough is disabled again for the device, we can\n\n         * capture it via the context entry invalidation, then the\n\n         * IOMMU region can be swapped back.\n\n         */\n\n        vtd_pt_enable_fast_path(s, source_id);\n\n\n\n        return true;\n\n    }\n\n\n\n    ret_fr = vtd_iova_to_slpte(&ce, addr, is_write, &slpte, &level,\n\n                               &reads, &writes);\n\n    if (ret_fr) {\n\n        ret_fr = -ret_fr;\n\n        if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n            trace_vtd_fault_disabled();\n\n        } else {\n\n            vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n        }\n\n        goto error;\n\n    }\n\n\n\n    page_mask = vtd_slpt_level_page_mask(level);\n\n    access_flags = IOMMU_ACCESS_FLAG(reads, writes);\n\n    vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, slpte,\n\n                     access_flags, level);\n\nout:\n\n    entry->iova = addr & page_mask;\n\n    entry->translated_addr = vtd_get_slpte_addr(slpte) & page_mask;\n\n    entry->addr_mask = ~page_mask;\n\n    entry->perm = access_flags;\n\n    return true;\n\n\n\nerror:\n\n    entry->iova = 0;\n\n    entry->translated_addr = 0;\n\n    entry->addr_mask = 0;\n\n    entry->perm = IOMMU_NONE;\n\n    return false;\n\n}\n", "idx": 8949, "substitutes": {"vtd_as": ["vdd2as", "vpd_ras", "vpd__as", "vdd2AS", "vTD_in", "vtd_AS", "vtd__as", "vTD__as", "vtdokas", "vtd2as", "vdd2master", "vTD_ras", "vpd_as", "vtdappas", "vtd_ras", "vtd__ras", "vtd2master", "vdd_session", "vtdokAS", "vdd_as", "vtd_in", "vtd__is", "vTD__ras", "vtd2session", "vdd_AS", "vtd_is", "vtdoksession", "vtdokmaster", "vtd__session", "vtd_master", "vpd_is", "vTD__in", "vtd_asu", "vtd__master", "vpd_asu", "vpd__asu", "vtd_session", "vdd_master", "vdd2session", "vtd__AS", "vtd__in", "vTD_as", "vTD_is", "vtd2AS", "vpd__ras", "vpd__is", "vTD__is", "vtd__asu", "vtdappras", "vtdappasu", "vtdappis"], "bus": ["plugin", "os", "uri", "board", "mount", "service", "buf", "state", "host", "drive", "BUS", "proc", "serial", "bc", "ux", "usb", "config", "http", "bridge", "boot", "use", "driver", "loop", "address", "Bus", "us", "uss", "sync", "used", "lock", "base", "port", "nt", "name", "cache"], "devfn": ["devicename", "domln", "diffkn", "domfn", "divn", "divfun", "domfp", "divfn", "diffdn", "evname", "evfp", "diskfun", "devfp", "switchln", "diskname", "evkn", "difffn", "devname", "devdn", " devln", "diffn", "switchfn", "devfun", " devkn", "bugn", "devn", "switchn", "bugdn", "switchfp", " devn", "devln", " devdn", "evfn", "devkn", "bugfn", "evdn", "diskfp", "domn", "evfun", "devicefp", "diskfn", "divdn", "devicefun", " devfun", "evn", "bugfun", "devicefn", " devfp"], "addr": ["hop", "server", "ann", "pos", "oa", "wd", "uri", "ack", "rt", "nr", "id", "ptr", "ref", "ip", "eth", "host", "adr", "md", "len", "route", "adder", "afi", "node", "dr", "config", "amp", "rss", "ace", "offset", "rc", "ha", "arr", "bridge", "sta", "b", "pkg", "asm", "loc", "url", "ag", "vr", "part", "kt", "act", "address", "ac", "dc", "dd", "rx", "layer", "val", "attr", "area", "mac", "conn", "amd", "base", "info", "rs", "rr", "name", "ad", "x"], "is_write": ["is__writing", "is__written", "is_read", "is2write", "is__read", "is2written", "in_writing", "is2read", "is__write", "in_written", "in_read", "is2writing", "in_write", "is_writing", "is_written"], "entry": ["server", "service", "je", "event", "ries", "ant", "rc", "ace", "Entry", "ent", "session", "ident", "cell", "enter", "ie", "address", "ee", "record", "row", "spec", "insert", "ry", "data", "e", "ge", "import"], "s": ["server", "g", "os", "f", "bis", "site", "request", "service", "parts", "cs", "state", "self", "ss", "c", "sq", "is", "i", "ks", "ins", "services", "a", "sb", "es", "p", "ts", "sg", "si", "S", "session", "settings", "b", "http", "ssl", "sis", "sl", "ns", "spec", "us", "r", "o", "source", "ps", "t", "ses", "sc", "sync", "gs", "m", "south", "e", "sys", "this", "storage", "sa", "space", "js", "stats", "ops"], "ce": ["cs", "ke", "edge", "c", "fe", "ant", " ace", "cc", "ced", "ci", "e", "ve", "ne", "cat", "ace", "use", " pe", "ie", "code", "pe", "coe", "force", "oe", "te", " ke", " je", " exce", "ze", "gu", "ca", "ae", "SE", "ice", "cur", "cell", "catch", "le", "cu", "cal", " ge", "ense", "ee", "cf", "he", "cel", " ie", "ge", "ide", "cast", " CE", "ine", "ue", "co", "dr", "ade", "ance", "see", "cy", "ct", "se", "client", "che", " ent", " ne", "cer", "CE", "component", "cle", "cue", "ces", "ate", "let"], "cc_entry": ["cnallresult", "cnallevent", "cc_event", "CC_entry", "ccallevent", "ccappentry", "ccallentry", "ccappelement", "cc___inc", "cc_rance", "rc_server", "ccappenter", "ccappstart", " cc_inc", "cc_result", "cn_result", "cn_event", "cn_entry", "cc_archive", "ctx_entry", "ctx_import", "cn_enter", "CC_enter", "cc_start", " cc_index", "ccallenter", "cnallentry", "cf_enter", "cc_reader", "CC_archive", "cc___entry", "cc_index", "cc___path", "cf_start", "cc_element", "cnallenter", "CC_import", "ctx_reader", "cf_element", "ccappresult", "cc_inc", "ctx_element", "ccappevent", "cf_entry", "rc_inc", "ccappimport", "cc___server", "cc_import", "cc_path", "cc_enter", "ccapparchive", "rc_path", "cc_server", " cc_rance", "rc_entry", "ccallresult"], "slpte": ["slptf", "slntype", "islpetec", "slpetn", "sliptey", "islptea", "slpetie", "sluptec", "islpte", "sliptd", "celptes", "slpointa", "islpetie", "slftea", " slntype", "nlptey", "slptpe", "slptn", "slftec", "slpta", "slptea", "slftie", "slinte", "nlupte", "slptd", "sluptey", " slptf", " slnta", "slppea", "slportey", "slnte", "slpete", "slppype", " slpta", "slpetec", "slporte", "slpointype", " slnte", "sliptec", "slppes", "islpete", "slppec", "celppe", "slptec", "slnta", "slupte", " slntf", "slppie", "islpetea", "slfte", "slptype", "slppe", "islptie", "slportd", "nlptd", "slipte", "nlpte", "nluptec", "slptes", "slintn", "nluptey", "celptn", "slpetpe", "nlptec", "celpte", " slptype", "sluptd", "slptie", "islptec", "celppes", "slintpe", "slppn", "celptpe", "slntf", "slptey", "slpointf", "celppn", "slpetes", "slintes", "slppa", "slpetea", "celpppe", "slpppe", "slppf", "slpointe", "slportec", "nluptd"], "page_mask": ["page___length", "page___ask", "page___flags", "page___mask", "page___limit", "page___max", " page_limit", "page_length", "page_max", " page_flags", " page_length", " page_max", "page_limit", "page_ask", "page_flags", " page_ask"], "level": ["lev", "pass", "type", "mode", "local", "limit", "weight", "zip", "low", "vel", "loc", "scope", "pattern", "bit", "scale", "loop", "code", "levels", "parent", "inc", "layer", "index", "priority", "delay", "base", "lvl", "depth"], "ret_fr": ["Ret_tr", "ret_pr", "write", "d", "ret24br", "retregdr", "ret24fr", "retregwrite", "ret_cache", "Ret_dr", "ret_tr", " ret_tr", "ret_frac", " ret_cache", " ret_dr", "Ret_pull", "ctr", "ret_dr", "retregtr", "ret_write", "Ret_write", "retregfr", "r", "_", "Ret_fr", "ret24pull", "x", " ret_frac", "g", "Ret_br", "ret_br", " ret_pr", "this", "ret_pull"], "access_flags": ["access___rights", " access_count", " access_bits", " access_limits", "access___flags", "accesssmask", " access_rights", "access___bits", "access_bits", "accessalmask", "access_parts", "accesssflags", " access_rules", "accesssparts", " access_parts", " access_mask", "accessallimits", "access_count", "access_flag", " access_flag", "access_rules", "accessslimits", "accessalparts", "accessalflags", "access_limits", "access_mask", "access___count", "access_rights"], "iotlb_entry": ["iotlb__entry", "iotlab_inc", "iotzb_entry", "iotlb00view", "iotlb_server", "iotla_entry", "iotlab_view", "iotlb_way", "iotlb_index", "iotbl_import", "iotbl_post", "iotlab_entry", "iotml_entry", "iotlb_enter", "iotlb_ry", "iotla_index", "iotla_enter", "iotlbappimport", "iotlb_reader", "iotlb_view", "iotbl_cell", "iotb_way", "iotlb00enter", "iotb_entry", "iotbl__import", "iotlb_ent", "iotbl__cell", "iotlab_exit", "iotlb__cell", "iotlb_id", "iotb_ry", "iotzb_id", "iotlb__import", "iotlb__post", "iotlb00ent", "iotbl_entry", "iotlb_exit", "iotlab_try", "iotbl__entry", "iotzb_see", "iotlb_element", "iotlb00entry", "iotlab_ent", "iotlbappentry", "iotlb_post", "iotb_element", "iotbl__post", "iotml_reader", "iotlab_enter", "iotlb_inc", "iotlb_cell", "iotlbappcell", "iotlb_try", "iotla_server", "iotlb_import", "iotlb_see", "iotlbapppost", "iotml_exit"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int load_multiboot(void *fw_cfg,\n\n                   FILE *f,\n\n                   const char *kernel_filename,\n\n                   const char *initrd_filename,\n\n                   const char *kernel_cmdline,\n\n                   int kernel_file_size,\n\n                   uint8_t *header)\n\n{\n\n    int i, is_multiboot = 0;\n\n    uint32_t flags = 0;\n\n    uint32_t mh_entry_addr;\n\n    uint32_t mh_load_addr;\n\n    uint32_t mb_kernel_size;\n\n    MultibootState mbs;\n\n    uint8_t bootinfo[MBI_SIZE];\n\n    uint8_t *mb_bootinfo_data;\n\n\n\n    /* Ok, let's see if it is a multiboot image.\n\n       The header is 12x32bit long, so the latest entry may be 8192 - 48. */\n\n    for (i = 0; i < (8192 - 48); i += 4) {\n\n        if (ldl_p(header+i) == 0x1BADB002) {\n\n            uint32_t checksum = ldl_p(header+i+8);\n\n            flags = ldl_p(header+i+4);\n\n            checksum += flags;\n\n            checksum += (uint32_t)0x1BADB002;\n\n            if (!checksum) {\n\n                is_multiboot = 1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!is_multiboot)\n\n        return 0; /* no multiboot */\n\n\n\n    mb_debug(\"qemu: I believe we found a multiboot image!\\n\");\n\n    memset(bootinfo, 0, sizeof(bootinfo));\n\n    memset(&mbs, 0, sizeof(mbs));\n\n\n\n    if (flags & 0x00000004) { /* MULTIBOOT_HEADER_HAS_VBE */\n\n        fprintf(stderr, \"qemu: multiboot knows VBE. we don't.\\n\");\n\n    }\n\n    if (!(flags & 0x00010000)) { /* MULTIBOOT_HEADER_HAS_ADDR */\n\n        uint64_t elf_entry;\n\n        uint64_t elf_low, elf_high;\n\n        int kernel_size;\n\n        fclose(f);\n\n\n\n        if (((struct elf64_hdr*)header)->e_machine == EM_X86_64) {\n\n            fprintf(stderr, \"Cannot load x86-64 image, give a 32bit one.\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                               &elf_low, &elf_high, 0, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"Error while loading elf kernel\\n\");\n\n            exit(1);\n\n        }\n\n        mh_load_addr = elf_low;\n\n        mb_kernel_size = elf_high - elf_low;\n\n        mh_entry_addr = elf_entry;\n\n\n\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n\n        if (rom_copy(mbs.mb_buf, mh_load_addr, mb_kernel_size) != mb_kernel_size) {\n\n            fprintf(stderr, \"Error while fetching elf kernel from rom\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        mb_debug(\"qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\\n\",\n\n                  mb_kernel_size, (size_t)mh_entry_addr);\n\n    } else {\n\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_ADDR. */\n\n        uint32_t mh_header_addr = ldl_p(header+i+12);\n\n        uint32_t mh_load_end_addr = ldl_p(header+i+20);\n\n        uint32_t mh_bss_end_addr = ldl_p(header+i+24);\n\n        mh_load_addr = ldl_p(header+i+16);\n\n        uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr);\n\n        uint32_t mb_load_size = 0;\n\n        mh_entry_addr = ldl_p(header+i+28);\n\n\n\n        if (mh_load_end_addr) {\n\n            mb_kernel_size = mh_bss_end_addr - mh_load_addr;\n\n            mb_load_size = mh_load_end_addr - mh_load_addr;\n\n        } else {\n\n            mb_kernel_size = kernel_file_size - mb_kernel_text_offset;\n\n            mb_load_size = mb_kernel_size;\n\n        }\n\n\n\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_VBE.\n\n        uint32_t mh_mode_type = ldl_p(header+i+32);\n\n        uint32_t mh_width = ldl_p(header+i+36);\n\n        uint32_t mh_height = ldl_p(header+i+40);\n\n        uint32_t mh_depth = ldl_p(header+i+44); */\n\n\n\n        mb_debug(\"multiboot: mh_header_addr = %#x\\n\", mh_header_addr);\n\n        mb_debug(\"multiboot: mh_load_addr = %#x\\n\", mh_load_addr);\n\n        mb_debug(\"multiboot: mh_load_end_addr = %#x\\n\", mh_load_end_addr);\n\n        mb_debug(\"multiboot: mh_bss_end_addr = %#x\\n\", mh_bss_end_addr);\n\n        mb_debug(\"qemu: loading multiboot kernel (%#x bytes) at %#x\\n\",\n\n                 mb_load_size, mh_load_addr);\n\n\n\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n\n        fseek(f, mb_kernel_text_offset, SEEK_SET);\n\n        if (fread(mbs.mb_buf, 1, mb_load_size, f) != mb_load_size) {\n\n            fprintf(stderr, \"fread() failed\\n\");\n\n            exit(1);\n\n        }\n\n        memset(mbs.mb_buf + mb_load_size, 0, mb_kernel_size - mb_load_size);\n\n        fclose(f);\n\n    }\n\n\n\n    mbs.mb_buf_phys = mh_load_addr;\n\n\n\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_kernel_size);\n\n    mbs.offset_mbinfo = mbs.mb_buf_size;\n\n\n\n    /* Calculate space for cmdlines and mb_mods */\n\n    mbs.mb_buf_size += strlen(kernel_filename) + 1;\n\n    mbs.mb_buf_size += strlen(kernel_cmdline) + 1;\n\n    if (initrd_filename) {\n\n        const char *r = initrd_filename;\n\n        mbs.mb_buf_size += strlen(r) + 1;\n\n        mbs.mb_mods_avail = 1;\n\n        while (*(r = get_opt_value(NULL, 0, r))) {\n\n           mbs.mb_mods_avail++;\n\n           r++;\n\n        }\n\n        mbs.mb_buf_size += MB_MOD_SIZE * mbs.mb_mods_avail;\n\n    }\n\n\n\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mbs.mb_buf_size);\n\n\n\n    /* enlarge mb_buf to hold cmdlines and mb-info structs */\n\n    mbs.mb_buf          = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n\n    mbs.offset_cmdlines = mbs.offset_mbinfo + mbs.mb_mods_avail * MB_MOD_SIZE;\n\n\n\n    if (initrd_filename) {\n\n        char *next_initrd, not_last;\n\n\n\n        mbs.offset_mods = mbs.mb_buf_size;\n\n\n\n        do {\n\n            char *next_space;\n\n            int mb_mod_length;\n\n            uint32_t offs = mbs.mb_buf_size;\n\n\n\n            next_initrd = (char *)get_opt_value(NULL, 0, initrd_filename);\n\n            not_last = *next_initrd;\n\n            *next_initrd = '\\0';\n\n            /* if a space comes after the module filename, treat everything\n\n               after that as parameters */\n\n            target_phys_addr_t c = mb_add_cmdline(&mbs, initrd_filename);\n\n            if ((next_space = strchr(initrd_filename, ' ')))\n\n                *next_space = '\\0';\n\n            mb_debug(\"multiboot loading module: %s\\n\", initrd_filename);\n\n            mb_mod_length = get_image_size(initrd_filename);\n\n            if (mb_mod_length < 0) {\n\n                fprintf(stderr, \"Failed to open file '%s'\\n\", initrd_filename);\n\n                exit(1);\n\n            }\n\n\n\n            mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_mod_length + mbs.mb_buf_size);\n\n            mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n\n\n\n            load_image(initrd_filename, (unsigned char *)mbs.mb_buf + offs);\n\n            mb_add_mod(&mbs, mbs.mb_buf_phys + offs,\n\n                       mbs.mb_buf_phys + offs + mb_mod_length, c);\n\n\n\n            mb_debug(\"mod_start: %p\\nmod_end:   %p\\n  cmdline: \"TARGET_FMT_plx\"\\n\",\n\n                     (char *)mbs.mb_buf + offs,\n\n                     (char *)mbs.mb_buf + offs + mb_mod_length, c);\n\n            initrd_filename = next_initrd+1;\n\n        } while (not_last);\n\n    }\n\n\n\n    /* Commandline support */\n\n    char kcmdline[strlen(kernel_filename) + strlen(kernel_cmdline) + 2];\n\n    snprintf(kcmdline, sizeof(kcmdline), \"%s %s\",\n\n             kernel_filename, kernel_cmdline);\n\n    stl_p(bootinfo + MBI_CMDLINE, mb_add_cmdline(&mbs, kcmdline));\n\n\n\n    stl_p(bootinfo + MBI_MODS_ADDR,  mbs.mb_buf_phys + mbs.offset_mbinfo);\n\n    stl_p(bootinfo + MBI_MODS_COUNT, mbs.mb_mods_count); /* mods_count */\n\n\n\n    /* the kernel is where we want it to be now */\n\n    stl_p(bootinfo + MBI_FLAGS, MULTIBOOT_FLAGS_MEMORY\n\n                                | MULTIBOOT_FLAGS_BOOT_DEVICE\n\n                                | MULTIBOOT_FLAGS_CMDLINE\n\n                                | MULTIBOOT_FLAGS_MODULES\n\n                                | MULTIBOOT_FLAGS_MMAP);\n\n    stl_p(bootinfo + MBI_MEM_LOWER,   640);\n\n    stl_p(bootinfo + MBI_MEM_UPPER,   (ram_size / 1024) - 1024);\n\n    stl_p(bootinfo + MBI_BOOT_DEVICE, 0x8000ffff); /* XXX: use the -boot switch? */\n\n    stl_p(bootinfo + MBI_MMAP_ADDR,   ADDR_E820_MAP);\n\n\n\n    mb_debug(\"multiboot: mh_entry_addr = %#x\\n\", mh_entry_addr);\n\n    mb_debug(\"           mb_buf_phys   = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys);\n\n    mb_debug(\"           mod_start     = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys + mbs.offset_mods);\n\n    mb_debug(\"           mb_mods_count = %d\\n\", mbs.mb_mods_count);\n\n\n\n    /* save bootinfo off the stack */\n\n    mb_bootinfo_data = g_malloc(sizeof(bootinfo));\n\n    memcpy(mb_bootinfo_data, bootinfo, sizeof(bootinfo));\n\n\n\n    /* Pass variables to option rom */\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ENTRY, mh_entry_addr);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_load_addr);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mbs.mb_buf_size);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA,\n\n                     mbs.mb_buf, mbs.mb_buf_size);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, ADDR_MBI);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, sizeof(bootinfo));\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data,\n\n                     sizeof(bootinfo));\n\n\n\n    option_rom[nb_option_roms].name = \"multiboot.bin\";\n\n    option_rom[nb_option_roms].bootindex = 0;\n\n    nb_option_roms++;\n\n\n\n    return 1; /* yes, we are multiboot */\n\n}\n", "idx": 8955, "substitutes": {"fw_cfg": ["fw_conf", "FW_conf", "fw_config", "FW_fs", "FW_config", "FW_cfg", "fw_fs"], "f": ["F", "g", "fen", "fr", "fn", "tf", "file", "sf", "proc", "fore", "c", "fu", "d", "fab", "h", "p", "rf", "b", "fb", "fs", "frame", "feed", "v", "fp", "framework", "t", "df", "l", "fo", "w", "m", "e", "fw", "s", "fd", "fin"], "kernel_filename": ["kernel_directory", "kernel_fp", "kernel_file", "linux_file", "kernel_name", "linux_filename", "kernel2directory", "linux_name", "kernel2name", "kernel2filename", "elf_fp", "kernel2file", "elf_file", "linux_directory", "elf_filename"], "initrd_filename": ["crddfile", "cline_mode", "cline_fp", "crddmode", "crddfp", "crddfilename", "cline_filename", "cline_file", "crd_mode", "crd_fp", "crd_file", "crd_filename"], "kernel_cmdline": ["kernel_commandname", "kernel_paramload", "kernel_commandload", "kernel_reqline", "kernel_reqspace", "kernel_paramline", "kernel_commandspace", "kernel_reqload", "kernel_cmdload", "kernel_cmdname", "kernel_paramspace", "kernel_cmdspace", "kernel_commandline", "kernel_paramname", "kernel_reqname"], "kernel_file_size": ["kernel_file_count", "kernel_file_SIZE", "kernel_data_SIZE", "kernel_data_count", "kernel_data_size"], "header": ["flags", "padding", "server", "version", "message", "prefix", "request", "directory", "comment", "date", "buf", "host", "metadata", "table", "connection", "master", "event", "feature", "dr", "config", "h", "kernel", "document", "offset", "content", "bridge", "headers", "definition", "filename", "driver", "queue", "frame", "center", "begin", "Header", "carry", "parent", "prot", "layer", "channel", "later", "four", "mask", "border", "index", "head", "forward", "cover", "buffer", "body", "cookie", "component", "fw", "meta", "name", "data", "target", "counter", "consumer", "writer"], "i": ["ii", "abi", "ni", "li", "uri", "hi", "phi", "I", "mu", "ip", "mi", "fi", "y", "c", "len", "iu", "ini", "iii", "d", "multi", "ji", "p", "ri", "slice", "si", "z", "b", "pi", "io", "j", "gi", "ie", "cli", "di", "xi", "v", "zi", "bi", "qi", "t", "ui", "ti", "l", "ci", "start", "index", "u", "m", "n", "child", "ai", "mini", "eni", "count", "counter", "x", "ix", "it"], "mh_entry_addr": ["g", "ctr", "linux", "mh_entry_offset", "addr", "mh_load_ref", "dll", "mh_load_address", "all", "_", "mh_entry_ref", "buffer", "mh_entry_address", "this", "s", "mh_load_offset"], "mh_load_addr": ["mh_load64add", "mh_loader_size", "mh_load___ref", "mh_load_add", "mh_loader_add", "mh_load_ref", "mh_loader_addr", "mh_loader_ref", "mh_load64addr", "mh_load___add", "mh_load_address", "mh_load___address", "mh_load_size", "mh_loader_address", "mh_load___addr", "mh_load64size"], "mb_kernel_size": ["mb_file_size", "mb_kernel_length", "mb_kernel___scale", "mb_linux_scale", "mb_kernel32data", "mb_linux_speed", "mb_file_scale", "mb_kernel_data", "mb_kernel_speed", "mb_kernel_scale", "mb_kernel___size", "mb_linux_data", "mb_kernel___length", "mb_kernel32scale", "mb_kernel32speed", "mb_kernel32size", "mb_linux_size", "mb_file_length"], "mbs": ["MBS", "amgs", "mbles", "tmbles", "miBS", "Mboxes", "embs", " mcs", "tmgs", "ambs", "dmcs", "mbers", "emcs", "ambles", "mibers", " mps", "pmBS", "tmps", "mps", "pmboxes", "dmbles", "amcs", "mcs", "dmbs", "pmbs", "embc", "dmgs", "mibs", "mBS", "mgs", "tmbs", "Mbers", "tmcs", "mboxes", "pmbers", "miboxes", "tmbc", " mbc", "emps", "mbc", "Mbs"], "bootinfo": ["bytearchive", "loadinfo", "buildarchive", "bootInfo", "memarchive", " bootarchive", "busid", "memInfo", "lockinfo", "buildinfo", "lockid", "businfo", "meminfo", "byteid", "busInfo", "loadarchive", "loadstart", " bootInfo", " bootstart", " bootid", "byteInfo", "buildInfo", "lockInfo", "loadInfo", "memid", "bootid", "bootarchive", "bootstart", "byteinfo", "buildstart"], "mb_bootinfo_data": ["mb_bootINFO_info", "mb_bootINFO_buffer", "mb_bootinfo_bytes", "mb_bootINFO_data", "mb_bootinfo_buffer", "mb_bootinfo_info", "mb_bootINFO_bytes"], "elf_entry": ["elf__image", "elf_inc", "lf_inc", "elfslow", "elfsentry", "elf__id", "lf_low", "elfsid", "ilo_image", "elfsimage", "elf_image", "lf_entry", "ilo_low", "elf__low", "elf_id", "elf_rc", "elf__entry", "lf_rc", "ilo_entry", "ilo_id"], "elf_low": ["elf10low", "elf_base", "elfAlow", "elfPlow", "lf_low", "egg_old", "elf00size", "elf_offset", "egg_high", "ELF_low", "elf_old", "elfJlimit", "elfJhigh", "ELF_base", "hlaclimit", "elf10source", "lf_old", "hlacoffset", "elf_la", "elfacoffset", "lf_la", "ELF_source", "elf_limit", "elfJoffset", "elfPbase", "hl_offset", "elf_size", "elf_source", "elfAold", "elfaclow", "hl_limit", "elfachigh", "hl_low", "ELF_high", "egg_low", "hlachigh", "hlaclow", "elfPsource", "elfJlow", "elf10base", "elf00old", "elfAla", "elf00low", "elf10high", "egg_little", "elfPhigh", "hl_high", "elfaclimit", "lf_size", "elf00la", "elfAsize", "elf_little"], "elf_high": ["elf00low", "elf_pop", "el_low", "ELF_index", "elf00index", "elf67high", "elf67low", "elf_hi", "el_hi", "elf67hi", "elf67last", "elf00high", "ELF_high", "el_last", "ELF_low", "elf_index", "elf_last", "ELF_pop", "el_high", "elf_large", "ELF_hi", "ELF_large", "elf00large"], "kernel_size": ["kernelacsize", "work_number", "kernel67len", "work64number", "work_rate", "kernel_len", "kernelacweight", "kernel_weight", "kernel64size", " kernel_sum", "kernel6size", "work64len", " kernel_weight", "kernel67rate", "kernel64number", "kernel67size", "work_len", "work64size", "kernel6rate", "kernelacsource", " kernel_source", "kernel_pos", "kernel64rate", "kernel6len", "work64rate", "kernel_source", "kernel_sum", "kernel6number", "kernel67number", " kernel_pos", "work_size", "kernel64len", "kernel_rate", "kernel_number"]}}
{"project": "FFmpeg", "commit_id": "73bb8f61d48dbf7237df2e9cacd037f12b84b00a", "target": 0, "func": "static void FUNC(hevc_h_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,\n\n                                          int *beta, int *tc, uint8_t *no_p,\n\n                                          uint8_t *no_q)\n\n{\n\n    FUNC(hevc_loop_filter_luma)(pix, stride, sizeof(pixel),\n\n                                beta, tc, no_p, no_q);\n\n}\n", "idx": 8963, "substitutes": {"pix": ["Pix", " pixel", "cpik", "dpixels", "cpix", "pixel", "cpixel", "dpix", " pick", "pixels", "apixel", "pik", "dpico", "apik", " pixels", " pico", "pico", "pick", "Pico", " pik", "Pixel", "apick", "cpick", "Pixels", "dpixel", "apix"], "stride": ["stite", "stided", "stider", "sprided", "sprider", "spand", "Strided", "strite", " strider", "strider", "Strand", "Stride", "stide", "strided", "spided", "strand", " strite", "spride", " strided", "sprite", "spide", "Strider", "spider", " strand"], "beta": ["lambda", "padding", "abi", "timeout", "\u03b2", "bis", "phi", "gam", "bc", "alpha", "pb", "gradient", "uca", "cb", "offset", " alpha", "fee", "si", "mega", "b", "fb", "scale", "Beta", "bi", "ui", "ta", "buffer", "lc", "margin", "meta", "bot", "ba"], "tc": ["cas", "ctx", "xc", "bc", "icc", "pb", "c", "pc", "ca", "cache", "rc", "term", "temp", "loc", "toc", "cp", "cm", "cu", "cc", "cli", "tmp", "fc", "ac", "dc", "t", "ci", "sc", "acc", "ta", "mc", "lc", "uc", "TC"], "no_p": ["no_e", "no__n", "no__cp", " no_e", "no_cp", " no_cp", "no__p", " no_c", "no_n", " no_n", "no__q", "no_c"], "no_q": [" no_eq", "No_c", "no7q", "noParp", "noLeq", "no7c", "No_p", "No_q", "noParq", "No_qs", " no_qs", "noPareq", "no_eq", "no7qs", "no7p", "noParqs", "no_qs", "no_c", "noLq", "noLp", "noLqs"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a,\n\n                           TCGArg b, bool b_const, TCGLabel *l)\n\n{\n\n    intptr_t offset;\n\n    bool need_cmp;\n\n\n\n    if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) {\n\n        need_cmp = false;\n\n    } else {\n\n        need_cmp = true;\n\n        tcg_out_cmp(s, ext, a, b, b_const);\n\n    }\n\n\n\n    if (!l->has_value) {\n\n        tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0);\n\n        offset = tcg_in32(s) >> 5;\n\n    } else {\n\n        offset = l->u.value_ptr - s->code_ptr;\n\n        assert(offset == sextract64(offset, 0, 19));\n\n    }\n\n\n\n    if (need_cmp) {\n\n        tcg_out_insn(s, 3202, B_C, c, offset);\n\n    } else if (c == TCG_COND_EQ) {\n\n        tcg_out_insn(s, 3201, CBZ, ext, a, offset);\n\n    } else {\n\n        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);\n\n    }\n\n}\n", "idx": 8970, "substitutes": {"s": ["ctx", "sym", "service", "cs", "self", "i", "ks", "d", "settings", "native", "w", "e", "comments", "rs", "strings", "js", "os", "opens", "groups", "site", "its", "ls", "sq", "uses", "ins", "sb", "rows", "http", "S", "session", "ds", "sie", "fs", "ssl", "ows", "o", "ses", "qs", "sc", "sec", "tests", "f", "sf", "xs", "times", "services", "sg", "sl", "v", "ions", "r", "u", "sync", "south", "sys", "x", "g", "states", "is", "es", "p", "ts", "si", "context", "se", "ns", "spec", "us", "t", "plugins", "m", "n", "sets", "sa", "ges", "ops", "ches"], "ext": ["text", "ctx", "f", "abc", "att", "self", "aux", "proc", "external", " Ext", "ex", "al", "fab", "config", "cpp", "p", "EXT", "temp", "ace", "h", "cur", "cb", "app", "test", "cont", "cfg", "ut", "z", "fc", "Ext", "t", "req", "sc", "next", "ab", "desc", "current", "xt", "tx", "e", "xp", "lc", "sa", "txt", "data", "exec", "x", "str"], "c": ["g", "chain", "f", "unc", "k", "cs", "nc", "ce", "y", "vc", "i", "ca", "d", "h", "p", "arc", "enc", "cb", "cy", "ic", "cu", "cc", "z", "v", "dc", "ac", "code", "C", "coll", "ch", "r", "t", "o", "call", "ci", "u", "cr", "m", "col", "init", "n", "e", "lc", "mc", "uc", "name", "or", "ec", "count", "x", "cache"], "a": ["f", "at", "va", "api", "aux", "na", "alpha", "ka", "ma", "y", "ca", "i", "an", "ae", "aa", "d", "off", "p", "ar", "A", "address", "ac", "t", "area", "am", "u", "ap", "ab", "w", "as", "current", "ast", "n", "e", "ai", "sa", "ad", "aaa", "x", "ba"], "b": ["g", "f", "bis", "k", "nb", "y", "pb", "i", "lb", "d", "sb", "bar", "p", "ib", "split", "mb", "fb", "rb", "bs", "B", "v", "bb", "r", "abb", "u", "ab", "w", "emb", "e", "n", "base", "ob", "null", "bp", "wb", "x", "ba"], "b_const": [" b_free", " b__const", " b__vert", " b_int", "b_int", " b_con", " b_struct", "b_free", "bxint", "bxfree", " b_Const", "b__free", "b__vert", "B_ctr", "B_cmp", "b__const", "b_ctr", "b_struct", " b__int", "b_cmp", "B_const", "b_con", " b__free", "b_Const", "b__int", "B_vert", "bxvert", "b_vert", "bxconst", " b_vert"], "l": ["g", "li", "f", "ll", "ls", "pl", "al", "i", "lb", "d", "lp", "lo", "lr", "p", "ell", "rl", "loc", "le", "fl", "nl", "sl", "kl", "v", "il", "el", "r", "t", "o", "u", "w", "m", "e", "n", "ln", "lu", "lc", "L", "dl"], "offset": ["padding", "shift", "pos", "et", "uple", "append", "size", "pointer", "type", "unc", "attribute", "limit", "ptr", "ref", "online", "skip", "output", "pc", "off", "p", "function", "slot", "reset", "fee", "ace", "loc", "adjust", "operation", "exclusive", "url", "position", "end", "Offset", "part", "array", "missing", "address", "fp", "layer", "alloc", "o", "error", "aw", "length", "initial", "start", "index", "sum", "column", "pad", "alias", "base", "info", "set", "value", "margin", "adjusted", "number", "location", "align", "slice", "cache"], "need_cmp": ["needed_mp", "needed_comp", "needJeq", "needJcmp", "need_eq", "need_comp", " need_mp", " need_comp", "needed_coll", " need_eq", "needJcod", " need_conv", "need_coll", "needfulcont", "need_mp", "needJcomp", " need_cont", "need_cont", "needfulcmp", "need_cod", "needed_cmp", "needfulcomp", "need_conv", " need_cod", "needfulmp"]}}
{"project": "qemu", "commit_id": "3736cc5be31f0399999e37d8b28ca9a3ed0b4ccb", "target": 0, "func": "static int nbd_negotiate_options(NBDClient *client, Error **errp)\n\n{\n\n    uint32_t flags;\n\n    bool fixedNewstyle = false;\n\n\n\n    /* Client sends:\n\n        [ 0 ..   3]   client flags\n\n\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n\n        [ 8 ..  11]   NBD option\n\n        [12 ..  15]   Data length\n\n        ...           Rest of request\n\n\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n\n        [ 8 ..  11]   Second NBD option\n\n        [12 ..  15]   Data length\n\n        ...           Rest of request\n\n    */\n\n\n\n    if (nbd_read(client->ioc, &flags, sizeof(flags), errp) < 0) {\n\n        error_prepend(errp, \"read failed: \");\n\n        return -EIO;\n\n    }\n\n    trace_nbd_negotiate_options_flags();\n\n    be32_to_cpus(&flags);\n\n    if (flags & NBD_FLAG_C_FIXED_NEWSTYLE) {\n\n        trace_nbd_negotiate_options_newstyle();\n\n        fixedNewstyle = true;\n\n        flags &= ~NBD_FLAG_C_FIXED_NEWSTYLE;\n\n    }\n\n    if (flags & NBD_FLAG_C_NO_ZEROES) {\n\n        trace_nbd_negotiate_options_no_zeroes();\n\n        client->no_zeroes = true;\n\n        flags &= ~NBD_FLAG_C_NO_ZEROES;\n\n    }\n\n    if (flags != 0) {\n\n        error_setg(errp, \"Unknown client flags 0x%\" PRIx32 \" received\", flags);\n\n        return -EIO;\n\n    }\n\n\n\n    while (1) {\n\n        int ret;\n\n        uint32_t option, length;\n\n        uint64_t magic;\n\n\n\n        if (nbd_read(client->ioc, &magic, sizeof(magic), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        magic = be64_to_cpu(magic);\n\n        trace_nbd_negotiate_options_check_magic(magic);\n\n        if (magic != NBD_OPTS_MAGIC) {\n\n            error_setg(errp, \"Bad magic received\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (nbd_read(client->ioc, &option,\n\n                     sizeof(option), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        option = be32_to_cpu(option);\n\n\n\n        if (nbd_read(client->ioc, &length, sizeof(length), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        length = be32_to_cpu(length);\n\n\n\n        trace_nbd_negotiate_options_check_option(option);\n\n        if (client->tlscreds &&\n\n            client->ioc == (QIOChannel *)client->sioc) {\n\n            QIOChannel *tioc;\n\n            if (!fixedNewstyle) {\n\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n\n                return -EINVAL;\n\n            }\n\n            switch (option) {\n\n            case NBD_OPT_STARTTLS:\n\n                tioc = nbd_negotiate_handle_starttls(client, length, errp);\n\n                if (!tioc) {\n\n                    return -EIO;\n\n                }\n\n                object_unref(OBJECT(client->ioc));\n\n                client->ioc = QIO_CHANNEL(tioc);\n\n                break;\n\n\n\n            case NBD_OPT_EXPORT_NAME:\n\n                /* No way to return an error to client, so drop connection */\n\n                error_setg(errp, \"Option 0x%x not permitted before TLS\",\n\n                           option);\n\n                return -EINVAL;\n\n\n\n            default:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                 NBD_REP_ERR_TLS_REQD,\n\n                                                 option, errp,\n\n                                                 \"Option 0x%\" PRIx32\n\n                                                 \"not permitted before TLS\",\n\n                                                 option);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                /* Let the client keep trying, unless they asked to\n\n                 * quit. In this mode, we've already sent an error, so\n\n                 * we can't ack the abort.  */\n\n                if (option == NBD_OPT_ABORT) {\n\n                    return 1;\n\n                }\n\n                break;\n\n            }\n\n        } else if (fixedNewstyle) {\n\n            switch (option) {\n\n            case NBD_OPT_LIST:\n\n                ret = nbd_negotiate_handle_list(client, length, errp);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n\n\n            case NBD_OPT_ABORT:\n\n                /* NBD spec says we must try to reply before\n\n                 * disconnecting, but that we must also tolerate\n\n                 * guests that don't wait for our reply. */\n\n                nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, option, NULL);\n\n                return 1;\n\n\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client, length, errp);\n\n\n\n            case NBD_OPT_STARTTLS:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                if (client->tlscreds) {\n\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                     NBD_REP_ERR_INVALID,\n\n                                                     option, errp,\n\n                                                     \"TLS already enabled\");\n\n                } else {\n\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                     NBD_REP_ERR_POLICY,\n\n                                                     option, errp,\n\n                                                     \"TLS not configured\");\n\n                }\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n            default:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                 NBD_REP_ERR_UNSUP,\n\n                                                 option, errp,\n\n                                                 \"Unsupported option 0x%\"\n\n                                                 PRIx32,\n\n                                                 option);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n            }\n\n        } else {\n\n            /*\n\n             * If broken new-style we should drop the connection\n\n             * for anything except NBD_OPT_EXPORT_NAME\n\n             */\n\n            switch (option) {\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client, length, errp);\n\n\n\n            default:\n\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n\n                return -EINVAL;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 8988, "substitutes": {"client": ["product", "server", "plugin", "remote", "container", "man", "clean", "request", "service", "local", "api", "cdn", "ip", "host", "self", "connection", "output", "ce", "c", "user", "pc", "public", "co", "Client", "patch", "cart", "config", "response", "input", "http", "connect", "cell", "net", "app", "worker", "socket", "queue", "con", "project", "pattern", "open", "cli", "image", "parent", "resource", "cmd", "get", "command", "call", "conn", "bird", "chrome", "cod", "current", "port", "custom", "google", "manager", "cache"], "errp": ["rrpre", "asterP", "Errorp", "erpre", "yrp", "arrpe", "derf", "orderP", "aerps", "reqf", " errpre", "herpath", "serverb", "serverapi", "ferp", "eorp", "herp", "eorP", "eerfp", "errb", " errf", "herps", "irpi", "drp", " errpp", " errapi", " errback", "orderp", "errorpre", "errorapi", "asterf", "drproc", "innerping", "asterpo", "rrp", "errpo", "herping", "Errorf", "ErrorP", "eorf", "herepa", "interpre", "errorping", "errP", "errpost", "derp", "orderpi", "Errorback", "reqpe", "errback", "eerpo", "yrpost", "reqpp", "rrfp", " errb", "arrp", "arrpp", "aerp", "bugpost", "interfp", "orderfp", "drfp", "errping", "eerp", "ferping", "errapi", "irfp", "erpi", "innerpath", "asterpc", "errfp", "herepost", "errps", "errpre", "erpa", "errpa", "errorp", "aerping", "erp", " errpc", "interp", "errpc", "erproc", "ererp", "eorback", "ererproc", "serverf", "erP", "ererfp", "rrsp", "errpe", "aerpath", "errproc", " errping", "innerps", "derpc", "ersp", "drpre", "errsp", "serverp", "herepe", "erfp", "arrf", "ferf", "errf", "eerpa", "bugpe", "asterfp", "yrpe", "asterpa", "herep", "errorf", "erpo", "yrpa", "ererpre", " errP", " errpe", "ferpre", "errpp", "errpath", "irp", "irP", "errorb", "asterp", "intersp", "bugp", "derP", "bugpa", "reqp", "innerp", "errpi"], "flags": ["lag", "requires", "utils", "planes", "styles", "args", "f", "groups", "ils", "events", "bugs", "vals", "feat", "xml", "values", "FLAG", "states", "items", "fields", "services", "properties", "config", "bytes", "fps", "ants", "options", "fee", "details", "settings", "ips", "ds", "fs", "filename", "reports", "ssl", "allows", "flag", "files", "includes", "caps", "alls", "atts", "rules", "codes", " Flags", "ags", "errors", "mask", "plugins", "ints", "links", "tools", "versions", "bits", "heads", "comments", "strings", "Flags", "lists", "members", "fd", "lins", "status", "locks", "stats", "types", "ports", "ops", "features"], "ret": ["RET", "result", "success", "al", " flag", " resp", " success", " Ret", " RET", " num", "rc", " r", " result", " res", "flag", " rc", "num", " count", "val", "rep", "ry", "res", "nt", "Ret", "count"], "option": ["timeout", "version", "prefix", "put", "block", "global", "type", "other", "weight", "update", "example", "connection", "single", "route", "search", "event", "feature", "config", "term", "function", "offset", "options", "Option", "loc", "session", "operation", "ban", "object", "pair", "position", "open", "array", "key", "package", "op", "image", "entry", "ption", "opt", "error", "color", "pin", "item", "optim", "index", "lock", "value", "section", "large", "cho", "name", "element", "optional", "number", "ion"], "length": ["padding", "version", "text", "block", "size", "type", "mount", "id", "character", "limit", "weight", "zip", "max", "view", "serial", "tag", "len", "sequence", "library", "label", "available", "patch", "duration", "config", "model", "function", "options", "loc", "filename", "range", "total", "full", "url", "style", "position", "family", "partial", "Length", "level", "error", "select", "lock", "delay", "child", "value", "section", "pull", "element", "data", "count", "number", "tail", "slice", "list", "build"], "magic": ["big", "padding", "binary", "plugin", "action", "version", "prefix", "Magic", "iso", "size", "type", "format", "money", "example", "dom", "serial", "special", "module", "stat", "patch", "config", "model", "xxx", "agent", "temp", "http", "agic", "math", "year", "secret", "mic", "currency", "style", "missing", "memory", "bot", "spec", "image", "complex", "inc", "icon", "time", "git", "power", "lock", "cookie", "data", "base", "unknown", "security", "progress", "custom", "token", "tech", "init", "mini", "meta", "script", "status", "bug", "extra", "mag", "number", "generic", "ix", "cache"]}}
{"project": "qemu", "commit_id": "f21126df5f81797486eb3bd628da8e2ad5fae12e", "target": 1, "func": "static void pl181_fifo_run(pl181_state *s)\n\n{\n\n    uint32_t bits;\n\n    uint32_t value;\n\n    int n;\n\n    int is_read;\n\n\n\n    is_read = (s->datactrl & PL181_DATA_DIRECTION) != 0;\n\n    if (s->datacnt != 0 && (!is_read || sd_data_ready(s->card))\n\n            && !s->linux_hack) {\n\n        if (is_read) {\n\n            n = 0;\n\n            value = 0;\n\n            while (s->datacnt && s->fifo_len < PL181_FIFO_LEN) {\n\n                value |= (uint32_t)sd_read_data(s->card) << (n * 8);\n\n                s->datacnt--;\n\n                n++;\n\n                if (n == 4) {\n\n                    pl181_fifo_push(s, value);\n\n                    n = 0;\n\n                    value = 0;\n\n                }\n\n            }\n\n            if (n != 0) {\n\n                pl181_fifo_push(s, value);\n\n            }\n\n        } else { /* write */\n\n            n = 0;\n\n            while (s->datacnt > 0 && (s->fifo_len > 0 || n > 0)) {\n\n                if (n == 0) {\n\n                    value = pl181_fifo_pop(s);\n\n                    n = 4;\n\n                }\n\n                n--;\n\n                s->datacnt--;\n\n                sd_write_data(s->card, value & 0xff);\n\n                value >>= 8;\n\n            }\n\n        }\n\n    }\n\n    s->status &= ~(PL181_STATUS_RX_FIFO | PL181_STATUS_TX_FIFO);\n\n    if (s->datacnt == 0) {\n\n        s->status |= PL181_STATUS_DATAEND;\n\n        /* HACK: */\n\n        s->status |= PL181_STATUS_DATABLOCKEND;\n\n        DPRINTF(\"Transfer Complete\\n\");\n\n    }\n\n    if (s->datacnt == 0 && s->fifo_len == 0) {\n\n        s->datactrl &= ~PL181_DATA_ENABLE;\n\n        DPRINTF(\"Data engine idle\\n\");\n\n    } else {\n\n        /* Update FIFO bits.  */\n\n        bits = PL181_STATUS_TXACTIVE | PL181_STATUS_RXACTIVE;\n\n        if (s->fifo_len == 0) {\n\n            bits |= PL181_STATUS_TXFIFOEMPTY;\n\n            bits |= PL181_STATUS_RXFIFOEMPTY;\n\n        } else {\n\n            bits |= PL181_STATUS_TXDATAAVLBL;\n\n            bits |= PL181_STATUS_RXDATAAVLBL;\n\n        }\n\n        if (s->fifo_len == 16) {\n\n            bits |= PL181_STATUS_TXFIFOFULL;\n\n            bits |= PL181_STATUS_RXFIFOFULL;\n\n        }\n\n        if (s->fifo_len <= 8) {\n\n            bits |= PL181_STATUS_TXFIFOHALFEMPTY;\n\n        }\n\n        if (s->fifo_len >= 8) {\n\n            bits |= PL181_STATUS_RXFIFOHALFFULL;\n\n        }\n\n        if (s->datactrl & PL181_DATA_DIRECTION) {\n\n            bits &= PL181_STATUS_RX_FIFO;\n\n        } else {\n\n            bits &= PL181_STATUS_TX_FIFO;\n\n        }\n\n        s->status |= bits;\n\n    }\n\n}\n", "idx": 9025, "substitutes": {"s": ["server", "sym", "service", "cs", "self", "c", "a", "ks", "i", "sv", "d", "settings", "b", "hs", "native", "gs", "as", "e", "comments", "rs", "js", "status", "os", "site", "its", "ls", "ss", "serv", "ins", "params", "sb", "h", "http", "S", "sie", "ds", "session", "fs", "ssl", "scope", "o", "ses", "qs", "set", "the", "tests", "f", "parts", "sf", "xs", "y", "an", "services", "sg", "bs", "ions", "r", "ps", "l", "sync", "u", "south", "sys", "su", "g", "args", "request", "state", "side", "states", "uns", "is", "new", "es", "p", "ts", "si", "full", "se", "ns", "less", "spec", "us", "t", "your", "m", "conf", "sets", "stats", "ops", "aws"], "bits": ["flags", "planes", "cycles", "bugs", "parts", "vals", "its", "values", "checks", "states", "ids", "fields", " bugs", "ins", "bytes", "fps", "BIT", "options", "details", "settings", "blocks", "outs", "ips", "steps", "runs", "boot", "nos", "bit", "limits", "alls", "dates", "bands", "bs", "codes", "pieces", "gets", "hours", "mask", "pins", "plugins", "ints", "acts", "lock", "notes", "nets", "lins", "status", "locks", "stats", "ports", "ops", "features"], "value": ["server", "message", "max", "byte", "option", "write", "fe", "d", "fee", "b", "json", "key", "address", "resource", "w", "sn", "e", "child", "ion", "size", "id", "result", "xxx", "end", "num", "length", "o", "error", "ava", "wa", "valid", "format", "xml", "values", "content", "total", "nu", "gi", "scale", "v", "expression", "index", "null", "name", "number", "x", "VALUE", "version", "no", "type", "device", "flow", "node", "function", "offset", "p", "temp", "position", "image", "entry", "val", "store", "Value", "unit", "none", "vi", "element", "data", "object"], "n": ["ne", "g", "ni", "adj", "fn", "no", "size", "f", "un", "pn", "k", "nc", "inn", "na", "ny", "nb", "y", "len", "c", "network", "en", "i", "N", "d", "node", "non", "p", "span", "b", "net", "inner", "nu", "j", "nw", "don", "nl", "ng", "ns", "z", "nat", "v", "nan", "nit", "num", "dn", "t", "o", "length", "l", "conn", "nn", "m", "sn", "not", "e", "cn", "nt", "name", "number", "x"], "is_read": [" is_ok", "is__read", "is__Read", "is__add", " is_ready", "is__write", "is_add", " is_write", "is__ready", "is_write", " is_add", "is_Read", "is_current", " is_Read", "is_ok", "is_ready", " is_current"], "datacnt": ["datAcount", "datAcnc", "dataclct", " datacct", "datAcnt", "DatACount", "datACnc", " datcct", "datacourse", " datcnc", " Datacnc", "datcct", "dataccent", "datascct", " datacount", " Dataccount", "dataccant", "Dataccent", "datAcNT", "DatACct", " datACount", " Dataccnc", "datacount", "daticount", "datacNT", "datACct", "dataccnt", "datACound", "dataclcent", " datacnc", "datascant", "datcount", "datACant", " Datacount", " datacourse", "datecount", "datecct", " Datacnt", "Datacnt", " Dataccnt", "datancnet", "datACount", "datancnt", "datcnc", " datcnt", "daticnc", "dataccound", "Datacnc", "dataccNT", "datAcct", "datcnt", " datacant", " Dataccct", " datacNT", "datacccent", "datACnt", "datacnet", "daticct", "DatACnc", "datACNT", "datACourse", "datACnet", "daticnt", "dataccourse", "datascnt", "Datacound", "datacct", " datACnc", "datancount", "datecnc", "DatACnt", "dataclnt", "dataccct", "Datacount", " datacnet", "dataclound", "dataccnc", " datACnet", "datacnc", "datascourse", "datacant", " datcount", "dataccount", " Datacct", "datAcnet", "DatACcent", "datancNT", "Datacct", " datACourse", "datACcent", "datacound", " datACNT", " datACct", " datACant", " datACnt", "datecnt", "DatACound"]}}
{"project": "FFmpeg", "commit_id": "93c04e095dc37ebdab22174e88cfa91e24940866", "target": 0, "func": "static int flv_read_metabody(AVFormatContext *s, int64_t next_pos)\n\n{\n\n    AMFDataType type;\n\n    AVStream *stream, *astream, *vstream;\n\n    AVIOContext *ioc;\n\n    int i;\n\n    // only needs to hold the string \"onMetaData\".\n\n    // Anything longer is something we don't want.\n\n    char buffer[11];\n\n\n\n    astream = NULL;\n\n    vstream = NULL;\n\n    ioc     = s->pb;\n\n\n\n    // first object needs to be \"onMetaData\" string\n\n    type = avio_r8(ioc);\n\n    if (type != AMF_DATA_TYPE_STRING ||\n\n        amf_get_string(ioc, buffer, sizeof(buffer)) < 0)\n\n        return -1;\n\n\n\n    if (!strcmp(buffer, \"onTextData\"))\n\n        return 1;\n\n\n\n    if (strcmp(buffer, \"onMetaData\"))\n\n        return -1;\n\n\n\n    // find the streams now so that amf_parse_object doesn't need to do\n\n    // the lookup every time it is called.\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        stream = s->streams[i];\n\n        if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n\n            astream = stream;\n\n        else if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            vstream = stream;\n\n    }\n\n\n\n    // parse the second object (we want a mixed array)\n\n    if (amf_parse_object(s, astream, vstream, buffer, next_pos, 0) < 0)\n\n        return -1;\n\n\n\n    return 0;\n\n}\n", "idx": 9036, "substitutes": {"s": ["server", "g", "os", "ctx", "f", "bis", "service", "cs", "ls", "self", "sf", "ss", "parser", "xs", "c", "sq", "a", "is", "services", "sv", "sb", "es", "cpp", "p", "ts", "sg", "si", "S", "ds", "settings", "b", "fs", "ssl", "session", "sim", "sl", "ns", "v", "spec", "us", "t", "ps", "qs", "ses", "l", "sc", "u", "sync", "gs", "m", "e", "n", "sets", "sys", "su", "rs", "storage", "comments", "this", "space", "js", "stats"], "next_pos": ["next_position", "nextnpos", "next2position", "nextppos", "nextpposition", "next2line", " next_line", " next_Pos", "nextnposition", "next_line", "nextxline", "nextpPos", " next_position", "next2pos", " next_offset", "nextxoffset", "nextpoffset", "nextnPos", "next_Pos", "nextxpos", "next2offset", "nextxposition", "next_offset", "nextnoffset"], "type": ["version", "block", "tp", "id", "format", "state", "pl", "typ", "class", "y", "instance", "method", "model", "p", "bo", "http", "Type", "style", "test", "TYPE", "pre", "key", "code", "pe", "record", "op", "t", "o", "r", "error", "resource", "link", "rel", "call", "form", "ty", "current", "e", "info", "port", "value", "ype", "name", "py", "data", "types", "x"], "stream": ["server", "transform", "dest", "file", "host", "sub", "draw", "model", "channel", "time", "ream", "resource", "form", "rec", "w", "speed", "child", "raw", "view", "through", "user", "track", "Stream", "public", "hook", "enc", "stage", "ssl", "cont", "impl", "thread", "coll", "length", "cl", "trans", "port", "video", "valid", "steam", "sw", "engine", "document", "load", "sl", "row", "source", "sync", "pool", "path", "draft", "audio", "instance", "upload", "node", "input", "object", "interface", "context", "feed", "iv", "image", "client", "entry", "filter", "reader", "rog", "stack", "wrapper", "uc", "slice"], "astream": ["pastream", "astsogg", "astsstream", " aststream", "pastchannel", "astogg", "ASTchannel", " astram", "adaptource", "aststream", " astraw", "adaptREAM", "pastogg", "astchannel", "adaptstream", "astREAM", "ASTREAM", "astsource", "ASTream", "aspreen", "ASTram", "astschannel", "aspream", " astreen", "ASTraw", "astsrom", "paststream", "astreen", "mastram", "mastraw", "astrom", "ASTstream", "astource", "asprom", "astsreen", "mastream", "astram", "ASTource", " astrom", "adaptream", "ASTogg", "astsREAM", "aspstream", "maststream", "astraw", "astsream"], "vstream": ["lvStream", "vvview", "lvchannel", "hview", "vpcloud", " vdraft", "vvstream", "Vream", " vsw", "Vstream", "Vfile", " vream", "svprogress", "VStream", "avstream", "hchannel", "vpcoll", "svchannel", "avStream", "vview", " vStream", "vcloud", " vfile", "svview", "svream", "vcoll", "lvdraft", "vdraft", "vfile", "avchannel", "vchannel", "vStream", "avdraft", "svstream", "lvstream", "vvchannel", "vpsw", "hprogress", "svcoll", " vcoll", "vsw", "svsw", "vprogress", "vream", "svcloud", "svStream", " vcloud", "vpstream", "svfile", "hstream", "vvprogress", " vchannel"], "ioc": ["ioci", "piic", "pioci", "tiOC", "xiroc", "atioc", "iOC", "iniocl", "uoci", "atiocl", "iroc", "uoc", "xioc", "inog", "tiocl", "tiog", "atiog", "iic", "inic", "uroc", "atiroc", "iocl", "iniroc", "iniog", "pioc", " iog", "inioc", "piisc", "inOC", "uocl", " iisc", "xioci", " iic", "piOC", "iisc", "tiisc", "antioc", "inoc", "antiroc", " ioci", "tiroc", "antiocl", "piog", "xiocl", "iog", "tioc", " iOC", "antioci", "tioci"], "i": ["ii", "ni", "pos", "li", "abi", "uri", "f", "id", "phi", "I", "mu", "ip", "oi", "mi", "fi", "chi", "adi", "y", "c", "iu", "ini", "d", "multi", "ri", "p", "si", "b", "pi", "inner", "uli", "j", "gi", "part", "key", "di", "ti", "xi", "v", "zi", "hi", "qi", "o", "ui", "l", "ci", "u", "index", "m", "e", "n", "info", "ai", "eni", "count", "slice", "ix", "it"], "buffer": ["binary", "padding", "server", "timeout", "message", "phrase", "text", "block", "prefix", "append", "texture", "request", "comment", "buf", "table", "audio", "byte", "uffer", "bc", "transfer", "iter", "document", "bar", "slice", "bytes", "input", "seed", "b", "seek", "paste", "fb", "shape", "queue", "frame", "url", "position", "feed", "memory", "address", "loop", "fp", "pause", "layer", "reader", "header", "bin", "Buffer", "source", "bb", "FFER", "wave", "length", "uf", "channel", "buff", "stack", "reference", "base", "null", "raw", "batch", "window", "data", "repeat", "read", "cache"]}}
{"project": "qemu", "commit_id": "2e2aa31674444b61e79536a90d63a90572e695c8", "target": 0, "func": "static void mptsas_scsi_init(PCIDevice *dev, Error **errp)\n\n{\n\n    DeviceState *d = DEVICE(dev);\n\n    MPTSASState *s = MPT_SAS(dev);\n\n    Error *err = NULL;\n\n    int ret;\n\n\n\n    dev->config[PCI_LATENCY_TIMER] = 0;\n\n    dev->config[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    if (s->msi != ON_OFF_AUTO_OFF) {\n\n        ret = msi_init(dev, 0, 1, true, false, &err);\n\n        /* Any error other than -ENOTSUP(board's MSI support is broken)\n\n         * is a programming error */\n\n        assert(!ret || ret == -ENOTSUP);\n\n        if (ret && s->msi == ON_OFF_AUTO_ON) {\n\n            /* Can't satisfy user's explicit msi=on request, fail */\n\n            error_append_hint(&err, \"You have to use msi=auto (default) or \"\n\n                    \"msi=off with this machine type.\\n\");\n\n            error_propagate(errp, err);\n\n            s->msi_in_use = false;\n\n            return;\n\n        } else if (ret) {\n\n            /* With msi=auto, we fall back to MSI off silently */\n\n            error_free(err);\n\n            s->msi_in_use = false;\n\n        } else {\n\n            s->msi_in_use = true;\n\n        }\n\n    }\n\n\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n\n                          \"mptsas-mmio\", 0x4000);\n\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n\n                          \"mptsas-io\", 256);\n\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n\n                          \"mptsas-diag\", 0x10000);\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n\n\n    if (!s->sas_addr) {\n\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n\n    }\n\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n\n\n    QTAILQ_INIT(&s->pending);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n\n    }\n\n}\n", "idx": 9038, "substitutes": {"dev": ["debug", "dem", "g", "ga", "vol", "valid", "hw", "die", "de", "loader", "block", "f", "device", "pro", "comment", "diff", "devices", "self", "DC", "home", "dom", "serial", "serv", "rad", "engine", "md", "gu", "DEV", "ver", "gd", "user", "config", "ev", "mod", "p", "development", "ds", "driver", "img", "Dev", "grad", "prom", "prof", "di", "v", "spec", "dc", "ch", "dd", "error", "req", "def", "conn", "dim", "od", "w", "cam", "conf", "dm", "info", "reg", "google", "var", "ad", "bug", "data"], "errp": ["rP", "erfp", "errP", "errr", "errfp", "errf", "errb", " errf", "errorp", "rfp", "erp", "errorf", " errr", " errfp", " errb", "erf", "errorr", " errP", "erb", "errorb", "erP", "rr", "rp"], "d": ["g", "sd", "f", "D", "c", "gd", "db", " dd", "i", "pd", "p", "ds", "b", "driver", "v", "dc", "dd", "t", "Ds", "w", "m", "dh", "dm", "e", "ad", "data", "dt", "cd"], "s": ["server", "sym", "service", "cs", "self", "c", "i", "sv", "sp", "settings", "b", "native", "gs", "com", "e", "secure", "rs", "comments", "js", "status", "os", "sd", "site", "ls", "ss", "serv", "sq", "params", "sb", "options", "http", "S", "ds", "session", "fs", "ssl", "o", "ses", "tests", "f", "parts", "sf", "y", "an", "services", "sg", "details", "app", "sl", "v", "r", "ps", "l", "sync", "south", "sys", "su", "sk", "x", "g", "args", "device", "side", "addr", "is", "es", "p", "ts", "si", "se", "ns", "less", "spec", "us", "t", "your", "m", "conf", "this", "sets", "stats", "aws"], "err": ["g", "Error", "irm", "fr", "die", "resp", "re", "ref", "fi", "rev", " error", "result", "mr", "ver", "Er", "iter", "sr", "dr", "lr", "p", "ner", "arr", "der", "ler", "ar", "arm", "ind", "r", "error", " er", "kr", "req", "br", "eor", "acer", "ir", "cr", "ry", "gr", "conf", "e", "er", "sys", "msg", "rs", "rr", "res", "rh", "bug", "str"], "ret": ["et", "valid", "sil", "rt", "f", "rets", "att", "match", "re", "RET", "ref", "rev", "ft", "result", "success", "len", "ver", "al", "en", "art", "ben", " Ret", " RET", "rc", "cat", "lit", "j", "flag", "mt", "red", "ut", "part", "code", "prot", "num", "t", "r", "val", "det", "_", "error", "fail", "ry", "reply", "pat", "res", "nt", "reg", "alt", "Ret", " arg", "x"]}}
{"project": "qemu", "commit_id": "1da41cc1c6c3efbe2ed47228068bd80dbdc49d0e", "target": 0, "func": "static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)\n\n{\n\n    int i;\n\n    GICState *s = KVM_ARM_GIC(dev);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);\n\n\n\n    kgc->parent_realize(dev, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n\n\n    i = s->num_irq - GIC_INTERNAL;\n\n    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.\n\n     * GPIO array layout is thus:\n\n     *  [0..N-1] SPIs\n\n     *  [N..N+31] PPIs for CPU 0\n\n     *  [N+32..N+63] PPIs for CPU 1\n\n     *   ...\n\n     */\n\n    i += (GIC_INTERNAL * s->num_cpu);\n\n    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);\n\n    /* We never use our outbound IRQ lines but provide them so that\n\n     * we maintain the same interface as the non-KVM GIC.\n\n     */\n\n    for (i = 0; i < s->num_cpu; i++) {\n\n        sysbus_init_irq(sbd, &s->parent_irq[i]);\n\n    }\n\n    /* Distributor */\n\n    memory_region_init_reservation(&s->iomem, OBJECT(s),\n\n                                   \"kvm-gic_dist\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    kvm_arm_register_device(&s->iomem,\n\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n\n                            | KVM_VGIC_V2_ADDR_TYPE_DIST);\n\n    /* CPU interface for current core. Unlike arm_gic, we don't\n\n     * provide the \"interface for core #N\" memory regions, because\n\n     * cores with a VGIC don't have those.\n\n     */\n\n    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s),\n\n                                   \"kvm-gic_cpu\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->cpuiomem[0]);\n\n    kvm_arm_register_device(&s->cpuiomem[0],\n\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n\n                            | KVM_VGIC_V2_ADDR_TYPE_CPU);\n\n}\n", "idx": 9039, "substitutes": {"dev": ["tr", "dem", "debug", "bus", "de", "hw", "die", "mode", "device", "diff", "pro", "self", "dom", "serial", "rad", "md", "gu", "ver", "gd", "d", "ev", "mod", "development", "p", "temp", "der", "ds", "driver", "Dev", "grad", "test", "prom", "di", "spec", "ch", "req", "def", "conn", "w", "cam", "conf", "dm", "info", "priv", "ad", "data"], "errp": ["rrp", "corlp", "errc", "erpc", "erpi", "rrpc", "Erc", "err", "erlp", "errP", " errc", "errr", "ErP", "corp", "Erpc", "Err", "corP", "erp", "corpc", "errlp", " errr", "rrc", "errpc", "rrlp", "rrP", "erc", "Erpi", "erP", "Erp", " errpi", "errpi"], "i": ["ii", "ni", "abi", "li", "uri", "hi", "f", "id", "phi", "I", "k", "mu", "ip", "oi", "mi", "fi", "adi", "y", "c", "yi", "iu", "a", "ini", "udi", "d", "multi", "ri", "p", "si", "anti", "b", "pi", "xi", "io", "j", "gi", "ami", "in", "ti", "di", "z", "bi", "v", "qi", "t", "ui", "o", "l", "ci", "zi", "start", "index", "u", "m", "init", "n", "info", "e", "ai", "lc", "mini", "eni", "x", "ix", "it"], "s": ["server", "sym", "service", "cs", "self", "c", "a", "ks", "d", "sv", "sh", "settings", "b", "gs", "w", "as", "e", "rs", "js", "os", "sd", "site", "its", "ls", "ss", "sb", "h", "http", "S", "session", "ds", "fs", "ssl", "j", "o", "ses", "qs", "f", "parts", "k", "xs", "y", "services", "sg", "sl", "v", "r", "ps", "l", "u", "sync", "south", "sys", "su", "sk", "g", "args", "state", "is", "new", "es", "p", "ts", "si", "ns", "less", "spec", "us", "t", "m", "n", "this", "sa", "none"], "sbd": ["sdb", "wsmd", "wsfd", " sda", "asld", "csBD", "sld", "Sbt", "smd", " sfd", " sBD", "psBD", "Sda", " sdb", "psbd", "Sbd", "wsbd", "asbot", "sgd", "psfd", " sbot", "sbt", "sfd", "wsdb", " sld", "csmd", "sbot", "csbd", "wsbot", "wsld", " sgd", " sbt", "asBD", "sda", "Sgd", " smd", "sBD", "wsBD", "asbd", "csfd", "psdb"], "kgc": ["kgl", "dkcc", "kgb", "pkgcc", "ggd", "skc", "pkgl", "kgd", "pkgb", "pkgc", "ggc", "dkpc", " gccpc", "kgcc", "ggb", "skl", "skb", " gccc", "kgpc", "ggl", " gccl", "skd", " gcccc", "dkl", "pkgpc", "pkgd", "dkc"]}}
{"project": "FFmpeg", "commit_id": "ebea370dc3909aa182bae4c728b83516a904beca", "target": 0, "func": "static int write_fragments(struct Tracks *tracks, int start_index,\n\n                           AVIOContext *in)\n\n{\n\n    char dirname[100], filename[500];\n\n    int i, j;\n\n\n\n    for (i = start_index; i < tracks->nb_tracks; i++) {\n\n        struct Track *track = tracks->tracks[i];\n\n        const char *type    = track->is_video ? \"video\" : \"audio\";\n\n        snprintf(dirname, sizeof(dirname), \"QualityLevels(%d)\", track->bitrate);\n\n        mkdir(dirname, 0777);\n\n        for (j = 0; j < track->chunks; j++) {\n\n            snprintf(filename, sizeof(filename), \"%s/Fragments(%s=%\"PRId64\")\",\n\n                     dirname, type, track->offsets[j].time);\n\n            avio_seek(in, track->offsets[j].offset, SEEK_SET);\n\n            write_fragment(filename, in);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 9047, "substitutes": {"tracks": ["tests", "cases", "projects", "setup", " Tracks", "styles", "groups", "events", "plays", "shows", "path", "xml", "cs", "metadata", "checks", "thumbnails", "xs", "fields", "acks", "pps", "tones", "ks", "music", "times", "grades", "services", "rows", "archives", "flows", "mods", "settings", "tracking", "steps", "runs", "reports", "hops", "files", "roots", "reads", "clips", "errors", "frames", "plugins", "links", "notes", "docs", "tags", "rs", "forms", "effects", "history", "videos", "features"], "start_index": [" start_initial", "start_address", "start_offset", "work_Index", "work_address", " start_offset", "start_Index", "work_index", "start_initial"], "in": ["nin", "g", "ctx", "f", "src", "inn", "connection", "min", "c", "ini", "a", "ins", "In", "config", "input", "again", "b", "ic", "socket", "con", "url", "impl", "fc", "ac", "image", "IN", "inc", "lin", "r", "source", "bin", "reader", "resource", "gin", "t", "ci", "conn", "stack", "m", "buffer", "login", "n", "out", "exec", "read", "str"], "dirname": [" dirdir", "directoryfile", "filepath", "foldernam", "directionsize", " directoryfile", "pathsync", "filenam", "directorynum", "dirstart", "foldername", "filenames", "dirpath", "pathnum", "directorysize", " dirnames", "dirnam", " dirpath", "directoryName", "dirsize", " directoryname", "pathstart", "pathsize", "folderpath", "dirfile", "folderName", "dirsync", "pathdir", "directorynam", "directiondir", "pathname", "dirnames", "directoryname", "directionstart", "fileName", "directorynames", "directionname", "directionsync", "dirdir", " directorysize", " dirsync", " dirsize", " dirfile", "directorypath", "dirName", "dirnum", "directionnum", "directorystart"], "filename": ["binary", "jpg", "ename", "prefix", "fn", "phrase", "bj", "file", "fax", "f", "directory", "final", "path", "journal", "sf", "metadata", "sql", "output", "folder", "write", "username", "document", "nil", "rl", "dll", "title", "println", "download", "database", "url", "jl", "json", "kl", "summary", "fp", "il", "Filename", "lace", "length", "sheet", "word", "mpeg", "buffer", "token", "lvl", "wb", "fd", "name", "txt", "uri", "nm"], "i": ["ii", "ti", "ni", "li", "f", "id", "I", "k", "ip", "oi", "mi", "fi", "adi", "y", "c", "yi", "ki", "iu", "is", "ini", "d", "h", "ri", "p", "ji", "si", "z", "b", "pi", "io", "ori", "gi", "ie", "ami", "v", "zi", "xi", "bi", "di", "ind", "o", "ui", "r", "qi", "l", "ci", "u", "index", "start", "m", "e", "n", "ai", "eni", "name", "x", "ix", "it"], "j": ["ii", "g", "li", "fr", "adj", "f", "k", "jam", "je", "jo", "rev", "x", "jet", "y", "uj", "c", "jit", "jp", "ja", "h", "ji", "p", "jen", "b", "kj", "jl", "ld", "ie", "key", "z", "v", "xi", "J", "ind", "o", "r", "t", "br", "oj", "l", "ci", "el", "u", "req", "m", "job", "arg", "ij", "obj", "n", "e", "jj", "jump", "dj", "js", "aj", "jc"], "track": ["tr", "transform", "gap", "song", "ack", "trip", "match", "mode", "path", "date", "Track", "ride", "note", "metadata", "skip", "tag", "rack", "audio", "task", "round", "event", "trial", "play", "tm", "step", "order", "stage", "tracking", "seek", "work", "pair", "project", "test", "gro", "rule", "scale", "sound", "trace", "coll", "record", "layer", "time", "sort", "complete", "artist", "call", "index", "rec", "progress", "token", "rank", "jump", "name", "grade", "toggle", "group", "field", "check"], "type": ["version", "block", "file", "id", "format", "path", "date", "y", "len", "single", "label", "p", "Type", "year", "url", "style", "TYPE", "rule", "key", "types", "code", "t", "source", "time", "sort", "attr", "rel", "link", "length", "ty", "data", "info", "value", "ype", "name", "typ", "target", "number", "dir"]}}
{"project": "qemu", "commit_id": "31783203c3b74c11015b20194d57dada559940cf", "target": 0, "func": "char *qemu_find_file(int type, const char *name)\n\n{\n\n    int len;\n\n    const char *subdir;\n\n    char *buf;\n\n\n\n    /* If name contains path separators then try it as a straight path.  */\n\n    if ((strchr(name, '/') || strchr(name, '\\\\'))\n\n        && access(name, R_OK) == 0) {\n\n        return g_strdup(name);\n\n    }\n\n    switch (type) {\n\n    case QEMU_FILE_TYPE_BIOS:\n\n        subdir = \"\";\n\n        break;\n\n    case QEMU_FILE_TYPE_KEYMAP:\n\n        subdir = \"keymaps/\";\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    len = strlen(data_dir) + strlen(name) + strlen(subdir) + 2;\n\n    buf = g_malloc0(len);\n\n    snprintf(buf, len, \"%s/%s%s\", data_dir, subdir, name);\n\n    if (access(buf, R_OK)) {\n\n        g_free(buf);\n\n        return NULL;\n\n    }\n\n    return buf;\n\n}\n", "idx": 9049, "substitutes": {"type": ["pos", "like", "block", "size", "file", "id", "format", "path", "class", "y", "off", "event", "p", "Type", "pretty", "ct", "url", "style", "ext", "TYPE", "part", "pre", "key", "code", "parent", "t", "time", "link", "call", "start", "base", "info", "port", "ype", "var", "py", "typ", "types", "dir"], "name": ["version", "prefix", "up", "no", "size", "file", "id", "NAME", "path", "other", "Name", "self", "home", "connection", "label", "a", "non", "new", "names", "filename", "url", "ext", "part", "missing", "key", "address", "code", "package", "image", "parent", "num", "o", "time", "all", "word", "old", "call", "start", "common", "base", "n", "info", "ame", "one", "null", "space", "none", "nice", "data", "dir", "x", "named", "str"], "len": ["la", "pos", "li", " pos", " lang", "size", "ll", "vec", "err", "ls", "elt", " length", "seq", "en", "lp", "dy", "offset", "loc", "Len", "lit", "le", "fl", "fun", "lim", "url", "ler", "ie", "sl", "length", "el", "val", "l", "base", "n", "lon", "ln", "line", "lc", "fd", "fin", "dl", "data", "count", "lf", "str"], "subdir": ["newdir", "subcoll", "Subdirection", "ubdirection", "suburi", "subdirectory", "regdirectory", "ubdirectory", "Subfolder", "Subcoll", " subDIR", "secdirectory", " subfolder", "regdirection", " subcoll", "secDIR", "ubdir", "Suburi", "secdirection", "Subdirectory", "regfolder", "subDIR", "uburi", "subdirection", " subdirectory", "secdir", "regdir", "newdirectory", "newDIR", "subfolder", "ubDir", " subdirection", "subDir", "SubDIR", "SubDir", "Subdir", " subDir", " suburi", "ubcoll", "newdirection"], "buf": ["cas", "la", "abi", "text", "block", "ctx", "f", "pool", "vec", "path", "ptr", "ref", "ff", "fam", "result", "bc", "bag", "seq", "addr", "box", "db", "rc", "config", "cb", "cur", "bytes", "loc", "b", "fun", "fb", "bed", "bg", "queue", "runner", "bh", "doc", "url", "feed", "rb", "bd", "fp", "cv", "alloc", "br", "bin", "Buffer", "uf", "cmd", "val", "cf", "r", "buff", "ab", "buffer", "func", "base", "msg", "wb", "uc", "fd", "cap", "null", "raw", "data", "str"]}}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "void term_flush(void)\n\n{\n\n}\n", "idx": 9055, "substitutes": {}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    PICCommonState *s = opaque;\n\n    return s->elcr;\n\n}\n", "idx": 9067, "substitutes": {"opaque": ["opacity", "Opsa", " opsa", " opac", "ipsa", "opcs", "appaques", "appac", "Opcs", " opacity", "ipcs", "opac", " opops", "ipaque", "appaque", "ipops", "Opaque", "appacity", "opops", "Opops", "opaques", "opsa", "operaques", "operaque", " opaques", "operacity", "operac", " opcs"], "addr": ["oa", "pos", "type", "pointer", "nr", "src", "args", "ptr", "ada", "byte", "len", "ace", "arr", "ord", "asm", "part", "address", "arm", "arity", "pad", "base", "Address", "cap", "ad", "data", "x"], "size": ["timeout", "SIZE", "capacity", "empty", "type", "args", "class", " Size", " length", "len", "small", "bytes", "shape", "ize", " sizes", "from", "Size", "address", "length", "desc", "unit", "or", "large", "name", "data"], "s": ["g", "als", "args", "request", "service", "cs", "ls", "ss", "states", "sq", "c", "is", "instance", "i", "ks", "services", "params", "rows", "es", "p", "ts", "si", "S", "session", "ips", "outs", "ssl", "socket", "ows", "ns", "in", "hs", "ans", "r", "ps", "ses", "qs", "sync", "gs", "m", "e", "ubs", "rs", "slave", "rates", "ops"]}}
{"project": "qemu", "commit_id": "641bb63cd6b003ab0ca2e312a014449037d71647", "target": 0, "func": "static int inc_refcounts(BlockDriverState *bs,\n\n                         BdrvCheckResult *res,\n\n                         uint16_t *refcount_table,\n\n                         int64_t refcount_table_size,\n\n                         int64_t offset, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k;\n\n\n\n    if (size <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= refcount_table_size) {\n\n            fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \"\n\n                \"the end of the image file, can't properly check refcounts.\\n\",\n\n                cluster_offset);\n\n            res->check_errors++;\n\n        } else {\n\n            if (++refcount_table[k] == 0) {\n\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9072, "substitutes": {"bs": ["os", "bos", "bis", "src", "cs", "ls", "ss", "bc", "BS", "pb", "ins", "sb", "bl", "es", "ts", "fps", "cb", "iss", "ds", "b", "blocks", "fs", "outs", "bh", "gb", "rb", "ns", "ms", "css", "bb", "ps", "qs", "ses", "sync", "gs", "bits", "rs", "js", "vs"], "res": ["rus", "pers", "args", "resp", "re", "vals", "err", "cs", "resolution", "rev", "ons", "result", "rez", "ex", "RES", "params", "rc", "rss", "des", "response", "arr", "details", "Rs", "results", "rem", "nos", "RS", "pres", "spec", "ms", "ch", "ras", "r", "ret", "val", "ps", "req", "def", "ress", "Res", "gr", "ros", "obj", "sys", "rs", "reg", "rh", "js"], "refcount_table": ["refcount_type", "refcountPtype", "refcount_tab", "refcompPmap", "refcountPcache", "refcount2cache", "refcache_table", "refcountstype", "refcache2table", "refcounttmap", "refcomp_type", "refcountsmap", "refcountttable", "refcount_cache", "refcompPcache", "refcountPtable", "refcountscache", "refcache_tab", "refcount2table", "refcountttype", "refcountslist", "refcount_map", "refcounttcache", "refcount_list", "refcache2cache", "refcache_cache", "refcountstable", "refcompPtype", "refcomp_table", "refcount2list", "refcountPmap", "refcache2tab", "refcountstab", "refcomp_cache", "refcache2list", "refcache_list", "refcount2tab", "refcomp_map", "refcompPtable"], "refcount_table_size": ["refcount_table2size", "refcount_cache_scale", "refcount_table2small", "refcount_cache_size", "refcount_table_num", "refcount_tab_size", "refcount_tab_small", "refcount_cache_small", "refcount_tab_num", "refcount_table2num", "refcount_table_scale", "refcount_table_small"], "offset": ["padding", "shift", "pos", "gap", "prefix", "first", "pointer", "activity", "limit", "online", "ref", "edge", "addr", "transfer", "i", "off", "p", "reset", "slot", "adjust", "loc", "iterator", "position", "end", "Offset", "part", "address", "entry", "tail", "length", "ui", "error", "initial", "index", "next", "reference", "base", "origin", "set", "starting", "zero", "element", "optional", "alias", "location", "align", "slice"], "size": ["shift", "sized", "timeout", "SIZE", "ey", "capacity", "empty", "max", "cs", "c", "len", "score", "needed", "small", "fee", "loc", "ish", "cm", "range", "use", "end", "scale", "se", "ize", "address", "code", "Size", "length", "ci", "sc", "sync", "form", "e", "unit", "n", "set", "storage", "six", "sec", "name", "send", "count", "cache"], "s": ["g", "os", "sym", "f", "args", "site", "its", "cs", "state", "ls", "ss", "states", "c", "sq", "is", "a", "i", "d", "services", "sb", "es", "p", "ts", "si", "http", "S", "ds", "b", "settings", "outs", "ssl", "se", "sl", "ns", "less", "spec", "ions", "o", "t", "r", "ps", "ses", "qs", "l", "sync", "gs", "south", "e", "sys", "sets", "rs", "sa", "js", "stats"], "start": ["before", "shift", "pos", "first", "type", "id", "max", "started", "state", "min", "art", "off", "cur", "ace", "back", "step", "st", "work", "range", "ish", "end", "ie", "part", "scale", "se", "open", "from", "address", "Start", "ind", "error", "get", "count", "next", "index", "init", "base", "info", "set", "starting", "ad", "grade", "stop", "skip", "check"], "last": ["before", "first", "latest", "empty", "final", "max", "prev", "Last", "low", "cycle", "close", "needed", "cur", "after", "p", "loc", "scope", "st", "range", "total", "full", "j", "use", "nd", "end", "ending", "se", "est", "from", "parent", "since", "length", "later", "old", "next", "ast", "base", "so", "count"], "cluster_offset": ["clance_route", "cluster__route", "cluster8off", "cluster_object", "cluster__off", "cluster67offset", "clance_limit", "clandra_error", "clance_address", "clusterPoff", "clructure_limit", "clandra_offset", "clructure_index", "clance67limit", "cluster_prefix", "clust_start", "clusterPoffset", "cluster_size", "clancePaddress", "clust_size", "clust_object", "clandra_size", "clust_pos", "cluster8route", "clancePoff", "cluster67size", "cluster67off", "cluster_address", "cluster_entry", "clance_offset", "clanceProute", "cluster_optional", "cluster8offset", "cluster_option", "cluster_off", "clance_off", "cluster_error", "cluster__address", "clust_entry", "cluster_limit", "clust_optional", "cluster_pos", "clructure_size", "cluster8address", "clusterProute", "clance_size", "clust_option", "cluster_index", "cluster67limit", "clance67offset", "clusterPaddress", "clust_position", "clandra_prefix", "cluster_start", "clance67size", "clancePoffset", "cluster_route", "clructure_offset", "cluster_position", "cluster__offset", "clance67off", "clust_offset"], "k": ["ok", "g", "ask", "f", "kat", "id", "ky", "kick", "max", "ke", "K", "kid", "y", "ka", "c", "kn", "ki", "unk", "i", "ks", "ak", "d", "uk", "p", "ck", "b", "kk", "range", "work", "j", "kw", "ku", "end", "ko", "key", "ch", "r", "o", "ik", "length", "q", "u", "w", "ek", "e", "n", "sk", "count", "number", "x"], "check_errors": ["update_error", "update_dates", "update__error", "check_error", "check_dates", "update__results", "update__dates", "check__dates", "check__error", "update_results", "update__errors", "update_errors", "check_results", "check__errors", "check__results"], "corruptions": ["corruptients", "corruptances", "coremptances", "disrictes", "disruptances", "disrictients", "corrictions", "disruptients", "coremptients", "correges", "disrictions", "corrictances", "corrictients", "coremptions", "coremptes", "corrictes", "corregions", "disruptes", "disrictances", "corregances", "corruptes", "corregients", "disruptions"]}}
{"project": "qemu", "commit_id": "f140e3000371e67ff4e00df3213e2d576d9c91be", "target": 1, "func": "static int nbd_co_request(BlockDriverState *bs,\n\n                          NBDRequest *request,\n\n                          QEMUIOVector *qiov)\n\n{\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n    int ret;\n\n\n\n    if (qiov) {\n\n        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);\n\n        assert(request->len == iov_size(qiov->iov, qiov->niov));\n\n    } else {\n\n        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);\n\n    }\n\n    ret = nbd_co_send_request(bs, request,\n\n                              request->type == NBD_CMD_WRITE ? qiov : NULL);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nbd_co_receive_reply(client, request->handle,\n\n                                request->type == NBD_CMD_READ ? qiov : NULL);\n\n}\n", "idx": 9087, "substitutes": {"bs": ["bos", "os", "cases", "bis", "cs", "ls", "ss", "bc", "BS", "pb", "db", "is", "lb", "ins", "sb", "ib", "iss", "ds", "b", "bes", "fs", "fb", "blocks", "bh", "gb", "rb", "ns", "cms", "css", "us", "bi", "bb", "ps", "ses", "gs", "base", "ubs", "ob", "bas", "lbs", "rs", "s", "js", "bid"], "request": ["server", "message", "accept", "claim", "model", "response", "worker", "queue", "press", "resource", "q", "next", "form", "query", "child", "info", "view", "user", "ru", "quest", "create", "http", "hello", "use", "frame", "pair", "record", "parent", "apply", "get", "call", "demand", "rate", "read", "list", "callback", "xml", "Request", "transfer", "route", "method", "event", "config", "load", "begin", "push", "insert", "complete", "req", "command", "current", "QUEST", "report", "name", "requ", "post", "type", "subject", "instance", "condition", "input", "ready", "order", "require", "enter", "friend", "access", "initial", "head", "save", "reference", "buffer", "object"], "qiov": ["qilo", " qliv", "viov", "sqodi", "qiop", "qurolet", "sqiop", "quiop", "qiev", "quio", "quliv", " qrolet", "sqivo", "qilib", "nliv", "quivo", "qu\u00ef", "q\u00ef", "quiev", "quiii", "qliv", "qiol", "questliv", "viev", "sqicho", " qiop", " qiol", "sqilib", "Q\u00ef", " qicho", " qivo", "qiii", " qio", "quiol", "quilo", " qilo", "sqilo", " qodi", "questio", "questiov", "quiov", "Qilo", "niii", "qrolet", "qivo", "qicho", "quicho", "questiol", " qiii", "Qrolet", "qio", "sqiev", " q\u00ef", "qodi", "vicho", "quodi", "nrolet", "vilib", "niov", "Qiov", "quilib", "sqiov"], "client": ["server", "plugin", "man", "uri", "clean", "web", "service", "api", "connection", "pc", "public", "Client", "config", "http", "bridge", "session", "connect", "cell", "cm", "socket", "con", "url", "sim", "cli", "handler", "resource", "bird", "conn", "proxy", "q", "admin", "circ", "child", "google", "manager", "cache"], "ret": ["pass", "rt", "rets", "f", "att", "resp", "re", "RET", "ref", "err", "rev", "result", "success", "len", "ver", "en", "iter", "art", "sr", "rc", "cat", "back", "order", "fun", "Len", "lit", "flag", "test", "ext", "run", "mt", "part", "rb", "code", "mem", "tmp", "num", "r", "fail", "val", "get", "req", "_", "pet", "conn", "rep", "error", "complete", "ry", "job", "arg", "reply", "obj", "res", "nt", "reg", "alt", "Ret", "bf", "count", "read"]}}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,\n\n                            const DisasInsn *di)\n\n{\n\n    unsigned r2 = extract32(insn, 21, 5);\n\n    unsigned r1 = extract32(insn, 16, 5);\n\n    unsigned cf = extract32(insn, 12, 4);\n\n    unsigned rt = extract32(insn,  0, 5);\n\n    TCGv tcg_r1, tcg_r2;\n\n    ExitStatus ret;\n\n\n\n    if (cf) {\n\n        nullify_over(ctx);\n\n    }\n\n    tcg_r1 = load_gpr(ctx, r1);\n\n    tcg_r2 = load_gpr(ctx, r2);\n\n    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);\n\n    return nullify_end(ctx, ret);\n\n}\n", "idx": 9091, "substitutes": {"ctx": ["cas", "ga", "ctr", "hw", "src", "Context", "xc", "anc", "cs", "nc", "voc", "connection", "bc", "xs", "vc", "cci", "c", "sq", "gd", "pc", "ca", "cmp", "conv", "jp", "config", "rc", "cb", "kb", "nas", "sci", "loc", "pkg", "qa", "scope", "cm", "cp", "cu", "kw", "context", "cfg", "cli", "fp", "cv", "rx", "que", "cmd", "req", "ci", "conn", "cf", "sync", "cus", "tx", "uci", "obj", "tc", "cn", "lc", "cca", "exec", "jc", "gru"], "insn": ["vinc", "vinN", "isinnt", " insN", "linsne", " insnl", "inp", "inne", "insner", "insb", "inn", "asp", "insnl", "insne", "insc", "vinp", "risne", "atsnl", "linsner", "inner", "incn", "innt", "inN", "risner", "linsn", "inssn", "insN", "atsp", "incp", "outsn", "outsnt", "inc", "insns", "asn", "isinn", "vinn", "rissn", "risn", "atsn", "incns", "insnt", "asns", "incb", "isinsn", "asb", "innl", "isinc", "outsc", "linssn", " insb", "outssn", " insp", " insns", "insp", "atsc", "atsN"], "di": ["ii", "idi", "dat", "ni", "uri", "Di", "mi", "andi", "adi", "gu", "ki", "ini", "ei", "i", "db", "ri", "ani", "DI", "si", "ds", "pi", "gi", "vd", "cfg", "cli", "ti", "zi", "xi", "bi", "dc", "tti", "ui", "da", "du", "ci", "oci", "uci", "ai", "iri"], "tcg_r1": ["tcg_m2", "tcg_sr2", "tcg_R1", "tcg_sr1", "tcg_m1", "tcg_Rb", "tcg_g0", "tcg_m0", "tcg_g2", "tcg_lr2", "tcg_srv", "tcg_r11", "tcg_rb", "tcg_R11", "tcg_rv", "tcg_Rv", "tcg_lr11", "tcg_g11", "tcg_lr0", "tcg_lr1", "tcg_R0", "tcg_g1", "tcg_srb", "tcg_R2", "tcg_r0"], "tcg_r2": ["tcg_R8", "tcg_er1", "tcg_hr1", "tcg_sr82", "tcg_sr2", "tcg_rr1", "tcg_r02", "tcg_R4", "tcg_rr02", "tcg_R1", "tcg_r82", "tcg_sr1", "tcg_hr82", "tcg_hr2", "tcg_Rb", "tcg_sr8", "tcg_r8", "tcg_R82", "tcg_rb", "tcg_hr8", "tcg_er4", "tcg_R02", "tcg_rr2", "tcg_erb", "tcg_r4", "tcg_R2", "tcg_er2"], "ret": ["tr", "rets", "rt", "ait", "match", "resp", "re", "RET", "final", "ref", "rev", "fi", "ft", "result", "success", "len", " Ret", " RET", "rc", "cat", "temp", "lit", "fun", "mt", "ut", "gt", "mem", "rel", "val", "det", "def", "rec", "ry", "bf", "reply", "obj", "base", "sys", "res", "nt", "reg", "gc", "Ret", "status", "alt"]}}
{"project": "FFmpeg", "commit_id": "f27b22b4974c740f4c7b4140a793cac196179266", "target": 0, "func": "static av_always_inline void xchg_mb_border(H264Context *h, uint8_t *src_y,\n\n                                            uint8_t *src_cb, uint8_t *src_cr,\n\n                                            int linesize, int uvlinesize,\n\n                                            int xchg, int chroma444,\n\n                                            int simple, int pixel_shift)\n\n{\n\n    int deblock_topleft;\n\n    int deblock_top;\n\n    int top_idx = 1;\n\n    uint8_t *top_border_m1;\n\n    uint8_t *top_border;\n\n\n\n    if (!simple && FRAME_MBAFF(h)) {\n\n        if (h->mb_y & 1) {\n\n            if (!MB_MBAFF(h))\n\n                return;\n\n        } else {\n\n            top_idx = MB_MBAFF(h) ? 0 : 1;\n\n        }\n\n    }\n\n\n\n    if (h->deblocking_filter == 2) {\n\n        deblock_topleft = h->slice_table[h->mb_xy - 1 - h->mb_stride] == h->slice_num;\n\n        deblock_top     = h->top_type;\n\n    } else {\n\n        deblock_topleft = (h->mb_x > 0);\n\n        deblock_top     = (h->mb_y > !!MB_FIELD(h));\n\n    }\n\n\n\n    src_y  -= linesize   + 1 + pixel_shift;\n\n    src_cb -= uvlinesize + 1 + pixel_shift;\n\n    src_cr -= uvlinesize + 1 + pixel_shift;\n\n\n\n    top_border_m1 = h->top_borders[top_idx][h->mb_x - 1];\n\n    top_border    = h->top_borders[top_idx][h->mb_x];\n\n\n\n#define XCHG(a, b, xchg)                        \\\n\n    if (pixel_shift) {                          \\\n\n        if (xchg) {                             \\\n\n            AV_SWAP64(b + 0, a + 0);            \\\n\n            AV_SWAP64(b + 8, a + 8);            \\\n\n        } else {                                \\\n\n            AV_COPY128(b, a);                   \\\n\n        }                                       \\\n\n    } else if (xchg)                            \\\n\n        AV_SWAP64(b, a);                        \\\n\n    else                                        \\\n\n        AV_COPY64(b, a);\n\n\n\n    if (deblock_top) {\n\n        if (deblock_topleft) {\n\n            XCHG(top_border_m1 + (8 << pixel_shift),\n\n                 src_y - (7 << pixel_shift), 1);\n\n        }\n\n        XCHG(top_border + (0 << pixel_shift), src_y + (1 << pixel_shift), xchg);\n\n        XCHG(top_border + (8 << pixel_shift), src_y + (9 << pixel_shift), 1);\n\n        if (h->mb_x + 1 < h->mb_width) {\n\n            XCHG(h->top_borders[top_idx][h->mb_x + 1],\n\n                 src_y + (17 << pixel_shift), 1);\n\n        }\n\n    }\n\n    if (simple || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) {\n\n        if (chroma444) {\n\n            if (deblock_topleft) {\n\n                XCHG(top_border_m1 + (24 << pixel_shift), src_cb - (7 << pixel_shift), 1);\n\n                XCHG(top_border_m1 + (40 << pixel_shift), src_cr - (7 << pixel_shift), 1);\n\n            }\n\n            XCHG(top_border + (16 << pixel_shift), src_cb + (1 << pixel_shift), xchg);\n\n            XCHG(top_border + (24 << pixel_shift), src_cb + (9 << pixel_shift), 1);\n\n            XCHG(top_border + (32 << pixel_shift), src_cr + (1 << pixel_shift), xchg);\n\n            XCHG(top_border + (40 << pixel_shift), src_cr + (9 << pixel_shift), 1);\n\n            if (h->mb_x + 1 < h->mb_width) {\n\n                XCHG(h->top_borders[top_idx][h->mb_x + 1] + (16 << pixel_shift), src_cb + (17 << pixel_shift), 1);\n\n                XCHG(h->top_borders[top_idx][h->mb_x + 1] + (32 << pixel_shift), src_cr + (17 << pixel_shift), 1);\n\n            }\n\n        } else {\n\n            if (deblock_top) {\n\n                if (deblock_topleft) {\n\n                    XCHG(top_border_m1 + (16 << pixel_shift), src_cb - (7 << pixel_shift), 1);\n\n                    XCHG(top_border_m1 + (24 << pixel_shift), src_cr - (7 << pixel_shift), 1);\n\n                }\n\n                XCHG(top_border + (16 << pixel_shift), src_cb + 1 + pixel_shift, 1);\n\n                XCHG(top_border + (24 << pixel_shift), src_cr + 1 + pixel_shift, 1);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 9094, "substitutes": {"h": ["g", "ph", "adh", "hd", "H", "hw", "hist", "ctx", "f", "hr", "host", "th", "oh", "home", "c", "help", "d", "p", "ha", "http", "sh", "gh", "uh", "b", "work", "ah", "bh", "hp", "hh", "ht", "context", "him", "hi", "v", "hs", "z", "ch", "image", "header", "t", "r", "o", "ih", "l", "he", "u", "hl", "q", "w", "m", "dh", "e", "n", "this", "eh", "rh", "s", "hash", "history", "x", "hm"], "src_y": ["src_ys", "srcPys", "src_py", "src_m", " src_py", "src_dy", " src_dy", " src_vy", " src_ys", "srcPy", "srcPpy", "srcPdy", " src_m", "src_vy"], "src_cb": ["src67buf", " src_crop", "src67cb", "src_crop", "src_rb", " src_wb", "src67fb", "src_buf", "src67rb", " src_buf", "src_fb", "src_wb", "src\u00b7rb", " src_fb", " src_rb", "src\u00b7cb", "src\u00b7wb", "src\u00b7crop"], "src_cr": ["source_sr", "source_cp", "src_cp", "src_rb", " src_cat", "src_sr", "source_cr", "src_cat", " src_rb", "source_rb"], "linesize": [" linesiz", "lightsization", "ipsized", "ipssize", "pagesization", "lightssize", "lightsize", " linesizes", "linsizes", "linsize", "ipsization", " linesization", "linesization", "linesizes", "linsization", "pagesiz", "linesized", "pagesize", "pagesizes", "lightsized", "linessize", " linessize", "linesiz", " linesized", "ipsize", "linsiz"], "uvlinesize": ["nvlinesIZE", "uvblocksizing", "uvlinesizing", "uvlesize", "uvlinksizer", "uvlineIZE", "uvlineizes", "uvlinesizer", "ovlinesized", "uvpagespace", "nvblocksizing", "nvlinesizes", "uvpagesized", "uvlinespace", "uvlinspace", "uvblocksize", "uvlinesizes", "nvlinesizing", "uvlineizing", "nvblocksization", "uvlinesized", "nvblocksizes", "nvlinesizer", "ovlinksizer", "nvinsizer", "uvpagesize", "nvinsIZE", "uvlinsize", "uvinsize", "uvlesizing", "uvpagesizer", "uvlineization", "ovlinkspace", "uvpagesization", "ovlinespace", "nvlinesization", "ovlinesizer", "uvlinesization", "ovlinksize", "uvlinsized", "uvlesIZE", "uvinsIZE", "ovlinksized", "uvinsizing", "uvlesizer", "uvlinksize", "uvlinesIZE", "uvlineizer", "uvblocksizes", "nvlinesize", "uvlinkspace", "uvlineize", "uvpagesizes", "ovlinesize", "nvblocksize", "uvpagesizing", "uvinsizer", "nvinsizing", "uvblocksization", "uvlinsizer", "uvlinksized", "nvinsize"], "xchg": ["xichgs", " xchgs", " xChgs", "xichga", " xChga", "xachrg", "xschm", " xchgen", "xschrg", "xcheg", " xchgc", "xchgen", "xarchgc", " xchga", " xChgen", "xchgc", " xachm", "xChga", "xchegen", " xChg", "xChgen", "xchgs", " xachg", "xchga", "xschg", "xChgs", "xichgen", " xachgc", "xachg", "xChg", "xichg", "xchega", " xchrg", "xachm", "xchm", "xarchm", " xachrg", "xchegs", "xschgc", "xarchg", "xchrg", "xachgc", " xchm", "xarchrg"], "chroma444": ["aquca1", "aqua1", "aquea44", "chromea144", "aquea144", "aquca144", "chromea1", "chromea44", "aquca44", "aqua144", "chroma44", "aqua444", "aquaa44", "chroma1", "aquaa444", "aquca444", "aquea1", "chromea444", "chroma144", "aquaa144", "aquea444", "aqua44", "aquaa1"], "simple": ["binary", "parse", "unique", "file", "local", "plain", "special", "single", "material", "label", "little", "small", "normal", "details", "quiet", "style", "linear", "packed", "sim", "partial", "less", "spec", "summary", "client", "active", "complete", "broken", "channel", "spin", "sync", "Simple", "basic", "multiple", "util", "custom", "repeat", "complex", "generic", "classic", "enable"], "pixel_shift": ["pixel2switch", "pixel2size", " pixel_low", " pixel_switch", "pixel_switch", "pixel_Shift", " pixel_edge", " pixel_sleep", " pixel_change", "pixel2scale", "pixel_edge", "pixel_sleep", "pixel_scale", "pixel_size", " pixel_offset", "pixel_change", "pixel_offset", " pixel_Shift", "pixel_low", "pixel2shift", " pixel_scale", " pixel_size"], "deblock_topleft": ["deblock_tOPLEvel", "deblock_tpleft", "deblock_tollock", "deblock_pplept", "deblock_ppleth", "deblock_Toulft", "deblock_trouth", "deblock_tollpt", "deblock_popleft", "deblock_tplevel", "deblock_tOPLEpt", "deblock_pplevel", "deblock_ppleft", "deblock_Topleth", "deblock_strouvel", "deblock_tollft", "deblock_toulft", "deblock_tollovel", "deblock_toulck", "deblock_Topleft", "deblock_poplept", "deblock_poplevel", "deblock_Toulth", "deblock_Toulck", "deblock_Toulvel", "deblock_toulvel", "deblock_strouth", "deblock_strouft", "deblock_stoplevel", "deblock_popleth", "deblock_tollvel", "deblock_tpleth", "deblock_stopleth", "deblock_troupt", "deblock_toplevel", "deblock_topleck", "deblock_tpleck", "deblock_tOPLEth", "deblock_Toplevel", "deblock_stopleft", "deblock_topleth", "deblock_toulth", "deblock_tolloft", "deblock_trouft", "deblock_Topleck", "deblock_stoplept", "deblock_tplept", "deblock_toplept", "deblock_tollth", "deblock_tolloth", "deblock_stroupt", "deblock_tOPLEft", "deblock_trouvel"], "deblock_top": ["deblock__bot", "deblock__best", "deblock0top", "deblock_bot", "deblocking_bot", "deblock2tops", "deblock_best", "deblock0TOP", "deblocking__top", "deblocking__bottom", "debblock__best", "deblock0bottom", "deblock__bottom", "debblock_top", "deblock__tops", "deblock_tops", "deblocking_best", "debblock__bottom", "debblock_bottom", "deblock__top", "deblock2top", "deblock__high", "deblocking_TOP", "deblocking__high", "debblock__top", "deblock_bottom", "deblocking__TOP", "deblock0high", "deblock_TOP", "debblock__tops", "deblocking_high", "deblock_high", "deblocking_bottom", "debblock_best", "deblock__TOP", "deblock2bottom", "debblock_tops", "deblocking_top", "deblock2best"], "top_border_m1": ["top_border_f2", "top_border_v1", "top_border_tf", "top_border_vn", "top_border_mn", "top_border_v4", "top_border_m4", "top_border_tn", "top_border_mf", "top_border_cn", "top_border_c1", "top_border_M2", "top_border_fn", "top_border_Mn", "top_border_Mf", "top_border_c2", "top_border_v2", "top_border_c4", "top_border_ff", "top_border_f1", "top_border_M1", "top_border_t1", "top_border_m2", "top_border_t2", "top_border_M4"], "top_border": [" top__extra", " top_section", " top_channel", " top_buffer", "top__border", "top_conn", "top__section", "top__buffer", " top__conn", "top__channel", "top__conn", "top_channel", "top_buffer", " top_extra", " top__section", "top__extra", "top__margin", " top__border", " top_conn", "top_margin", " top_margin", "top_section", "top_extra"]}}
{"project": "FFmpeg", "commit_id": "c56e71309ec1a585ed4d4dc11ae0ba3ca7d19618", "target": 1, "func": "static int gif_image_write_image(AVCodecContext *avctx,\n\n                                 uint8_t **bytestream, uint8_t *end,\n\n                                 const uint8_t *buf, int linesize)\n\n{\n\n    GIFContext *s = avctx->priv_data;\n\n    int len, height;\n\n    const uint8_t *ptr;\n\n    /* image block */\n\n\n\n    bytestream_put_byte(bytestream, 0x2c);\n\n    bytestream_put_le16(bytestream, 0);\n\n    bytestream_put_le16(bytestream, 0);\n\n    bytestream_put_le16(bytestream, avctx->width);\n\n    bytestream_put_le16(bytestream, avctx->height);\n\n    bytestream_put_byte(bytestream, 0x00); /* flags */\n\n    /* no local clut */\n\n\n\n    bytestream_put_byte(bytestream, 0x08);\n\n\n\n    ff_lzw_encode_init(s->lzw, s->buf, avctx->width*avctx->height,\n\n                       12, FF_LZW_GIF, put_bits);\n\n\n\n    ptr = buf;\n\n    for (height = avctx->height; height--;) {\n\n        len += ff_lzw_encode(s->lzw, ptr, avctx->width);\n\n        ptr += linesize;\n\n    }\n\n    len += ff_lzw_encode_flush(s->lzw, flush_put_bits);\n\n\n\n    ptr = s->buf;\n\n    while (len > 0) {\n\n        int size = FFMIN(255, len);\n\n        bytestream_put_byte(bytestream, size);\n\n        if (end - *bytestream < size)\n\n            return -1;\n\n        bytestream_put_buffer(bytestream, ptr, size);\n\n        ptr += size;\n\n        len -= size;\n\n    }\n\n    bytestream_put_byte(bytestream, 0x00); /* end of image block */\n\n    bytestream_put_byte(bytestream, 0x3b);\n\n    return 0;\n\n}\n", "idx": 9095, "substitutes": {"avctx": ["avcmp", "ajcmp", "afcc", "avcontext", "AVctx", "avectx", "AVsync", " avcc", "AVctl", "ajcontext", "avsync", "afsync", "aucontext", " avcmp", " avcontext", "AVproc", "AVcmp", "AVcv", "afconn", "aveqa", "aucmp", "ajctx", "afproc", " avconn", "AVconn", "auctl", " avsync", "avqa", "auctx", "avecontext", "afqa", "avecmp", "AVcontext", " avcv", "afcv", "aveconn", "ajproc", "afctl", "avcv", "avcc", "avconn", "AVcc", "afctx", "AVqa", "avctl", "avproc", "afcmp", "afcontext"], "bytestream": ["byteenREAM", " bygestruction", "Byestram", "byestram", "bythisrum", "Byeststream", "bylastagram", "bypastamera", "bygestREAM", "bypertram", " bytestram", "BYpastamera", "bycestorage", "Byestream", "bygestear", "bycestream", "BYtestamera", "bytrum", "bygestreen", "byterrum", "bycodeream", " bytestruction", "liketestingair", "byeststream", "viatestallow", "bycoderum", "bythisream", "byestallow", "byteenrom", "byinstamera", "byrestreen", "bypertruction", "bythisamera", "bylastamera", "andtestream", "Byestamera", "forestorage", "byvestamera", " bygestram", "byastREAM", "byinstream", "liketestair", "viainstagram", "viaestagram", "byteststream", "fromestream", "fortestream", "bytestruction", "forestered", " bygestrom", "Bytestamera", "bytestamera", "byestamera", " bytestagram", "byconstalk", "byinstREAM", "andtestram", "byestchannel", "viatestream", "fromtestchannel", "fortestered", "byvestream", "byinstrum", "bytestingair", "byveybroad", "byterram", "viatestagram", "byscriptagram", "bytestand", "bytestingamera", " bytestreen", "byterream", "bygestrum", "fortestrum", "byestream", "viatestbroad", "Bytestram", "bycodeair", "bytestingREAM", "bytruction", "byconstram", "byscriptream", "liketestingruction", "ByestREAM", "bypastand", "bythisand", "fromestchannel", " bytestrom", "BYtestand", "forestrum", "byserverram", "bytestingruction", "bylastbroad", " bytestamera", "bypastream", "Bytestream", "bygestair", "byconstear", "bytestalk", "bycestered", "byestorage", "bytestered", "byteenream", "bytestchannel", "bytram", "byscriptram", "bytestREAM", "byastram", "byinstagram", "bytestingand", "liketestram", "bypertream", "byinstchannel", "bypastrum", "liketestream", "andcodeair", "bytestrom", "bypertair", "byconstreen", "bytestear", "byscriptalk", "viatestamera", "liketestingram", "byveyream", "byestered", "fromtestrum", "bygestrom", "bygestchannel", "bytallow", "Bytestruction", "forestream", "fromestREAM", "BYpastream", "viaestream", "byserverruction", "byestrum", "bytagram", "bytestingrum", " bygestalk", "Byteststream", "byinstbroad", "andtestair", "byvestruction", "viainstbroad", "byestREAM", "bytream", "BytestREAM", " bygestagram", "byrestream", "BYtestream", "fromtestream", "viatestrum", "BYpastrum", "byterair", "bylastream", " bytestalk", "bytestram", "viainstamera", "andtestrum", "bygestamera", "byrestREAM", "byconstREAM", "byestruction", "viainstream", "bythisagram", "bytestbroad", "fortestorage", "liketestingream", "bygestream", "byteenamera", " bytestREAM", "viaestrum", "byserverream", "byconstrom", " bytestear", "byconstream", "byveyagram", "byastream", " bygestREAM", "bygeststream", "bytestrum", " bygestream", " bygestamera", "bytestingram", "andcoderum", "andcoderam", "BYpastand", "byconstamera", "bytestingorage", " bygestreen", "bythisallow", "fromtestREAM", "bytestagram", "bygestalk", "byconstagram", "byestagram", "bygestruction", "bytestreen", "andcodeream", "byveyamera", "byserveramera", "liketestruction", "bytestallow", "bygestagram", "Byestruction", "bycestrum", "bytamera", "viaestallow", "byaststream", "fromestrum", "bytestingream", "bytestorage", "bygestram", "byrestear", "BYtestrum", "byvestREAM", "bytestingered", " bygestear", "bytestair", "bycoderam"], "end": ["pos", "append", "id", "path", "max", "limit", "edge", "ended", "mid", "c", "en", "h", "enc", "after", "offset", "END", "End", "range", "use", "ending", "open", "env", "est", "begin", "address", "z", "length", "start", "index", "dev", "last", "e", "set", "send", "stop", "line"], "buf": ["cas", "prop", "block", "ctx", "pool", "src", "vec", "ref", "aux", "home", "proc", "fi", "bu", "bc", "bag", "seq", "pb", "box", "conv", "rc", "config", "cb", "offset", "p", "loc", "b", "fb", "queue", "uu", "context", "rb", "address", "fp", "cv", "mem", "tmp", "code", "v", "header", "alloc", "length", "br", "uf", "cf", "background", "border", "buff", "map", "buffer", "func", "port", "wb", "cap", "fd", "uc", "raw", "data"], "linesize": [" linesiz", "linesIZE", " linesizing", "codesiz", " linesizer", "linesizing", "linsize", "codesize", " linesIZE", "odesize", "codesIZE", "linsizer", "odesiz", "codesizing", "linsIZE", "odesizing", "linesizer", "odesIZE", "linesiz", "codesizer", "linsiz"], "s": ["g", "ctx", "f", "sym", "args", "bis", "service", "its", "cs", "ls", "ss", "uns", "xs", "c", "sq", "a", "i", "ks", "ins", "d", "sv", "services", "is", "sb", "es", "p", "ts", "sg", "S", "ds", "b", "session", "fs", "ssl", "bs", "ns", "v", "spec", "hs", "ions", "us", "t", "r", "ps", "ses", "qs", "sync", "gs", "w", "m", "as", "conf", "e", "n", "sys", "sets", "rs", "js", "stats", "data", "ops", "aws"], "len": ["pos", "fen", "li", "size", "zen", "ll", "limit", "elt", "rev", "min", "seq", "lt", "en", "den", "lp", "dy", "span", "loc", "Len", "fun", "fl", "lim", "ler", "url", "le", "ld", "sl", "pre", "z", "code", "lang", "lit", "num", "lin", "length", "el", "bin", "val", "win", "l", "count", "lib", "hl", "n", "lon", "ln", "lan", "lc", "cap", "fin", "name", "dl", "data", "lf", "line"], "height": ["padding", "gap", "wall", "thin", "host", "alpha", "i", "d", "hei", "definition", "zh", "html", "memory", "channel", "win", "ady", "w", "fw", "depth", "fen", "layout", "size", "arrow", "id", "weight", "view", "resolution", "rows", "h", "ha", "shape", "img", "wrap", "hi", "num", "header", "length", "crop", "dim", "hl", "port", "rank", "lvl", "capacity", "huge", "diff", "lat", "y", "duration", "step", "qa", "kw", "direction", "wide", "density", "row", "source", "name", "window", "han", "dir", "x", "container", "type", "flow", "quality", "png", "dy", "input", "gy", "sid", "style", "context", "bottom", "image", "level", "head", "buffer", "volume", "room", "Height", "wid", "slice"], "ptr": ["tr", "shift", "ctr", "pos", "dest", "pointer", "Ptr", "src", "mount", "ref", "err", "fi", "proc", "pointers", "addr", "pend", "pb", "fe", "dr", "rc", "p", "offset", "cb", "cur", "sh", "loc", "plug", "sp", "pair", "ext", "pt", "context", "rb", "address", "fp", "tmp", "code", " pointer", "push", "trace", "rot", "alloc", "length", "pe", "attr", "uf", "req", "dim", "index", "buff", "inter", "start", "buffer", "pad", "obj", "port", "slave", "fd", "inst", "lf", "coord", "slice", "str"]}}
{"project": "FFmpeg", "commit_id": "da048c6d24729d3bab6ccb0ac340ea129e3e88d5", "target": 1, "func": "static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"stbl\");\n\n    mov_write_stsd_tag(pb, track);\n\n    mov_write_stts_tag(pb, track);\n\n    if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||\n\n         track->enc->codec_tag == MKTAG('r','t','p',' ')) &&\n\n        track->has_keyframes && track->has_keyframes < track->entry)\n\n        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);\n\n    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)\n\n        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);\n\n    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n        track->flags & MOV_TRACK_CTTS && track->entry)\n\n        mov_write_ctts_tag(pb, track);\n\n    mov_write_stsc_tag(pb, track);\n\n    mov_write_stsz_tag(pb, track);\n\n    mov_write_stco_tag(pb, track);\n\n    return update_size(pb, pos);\n\n}\n", "idx": 9101, "substitutes": {"pb": ["plugin", "bos", "np", "pg", "tp", "ctx", "sth", "pool", "dp", "bm", "pm", "pro", "api", "pl", "mp", "proc", "ppa", "nb", "bc", "bps", "db", "pc", "lb", "jp", "eb", "lab", "sb", "lp", "pd", "cpp", "p", "ib", "cb", "pkg", "b", "fm", "fb", "cp", "bh", "hp", "pt", "gb", "mt", "prof", "rb", "fp", "fc", "summary", "tmp", "prot", "bb", "xb", "platform", "uf", "wp", "pp", "vp", "ab", "buff", "bf", "pa", "ob", "lc", "wb", "uc", "bp", "py", "txt", "PB", "um"], "track": ["transform", "comment", "note", "trial", "model", "sound", "press", "word", "form", "rm", "token", "toggle", "ack", "view", "Track", "module", "task", "round", "tm", "stage", "session", "tracking", "test", "run", "thread", "coll", "record", "sort", "call", "allow", "port", "progress", "rank", "tr", "hop", "mode", "metadata", "roll", "gg", "route", "event", "patch", "config", "cur", "step", "tracks", "tick", "gro", "trace", "add", "row", "complete", "sync", "report", "train", "rr", "lc", "post", "type", "match", "tag", "rack", "audio", "cmp", "node", "play", "order", "seek", "work", "project", "tab", "follow", "tt", "skip", "check"]}}
{"project": "qemu", "commit_id": "80ee15a6b274dfcedb0ad7db8c9e7d392210d6a1", "target": 1, "func": "uint64_t qcow2_get_cluster_offset(BlockDriverState *bs, uint64_t offset,\n\n    int *num)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l1_index, l2_index;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int l1_bits, c;\n\n    int index_in_cluster, nb_available, nb_needed, nb_clusters;\n\n\n\n    index_in_cluster = (offset >> 9) & (s->cluster_sectors - 1);\n\n    nb_needed = *num + index_in_cluster;\n\n\n\n    l1_bits = s->l2_bits + s->cluster_bits;\n\n\n\n    /* compute how many bytes there are between the offset and\n\n     * the end of the l1 entry\n\n     */\n\n\n\n    nb_available = (1 << l1_bits) - (offset & ((1 << l1_bits) - 1));\n\n\n\n    /* compute the number of available sectors */\n\n\n\n    nb_available = (nb_available >> 9) + index_in_cluster;\n\n\n\n    if (nb_needed > nb_available) {\n\n        nb_needed = nb_available;\n\n    }\n\n\n\n    cluster_offset = 0;\n\n\n\n    /* seek the the l2 offset in the l1 table */\n\n\n\n    l1_index = offset >> l1_bits;\n\n    if (l1_index >= s->l1_size)\n\n        goto out;\n\n\n\n    l2_offset = s->l1_table[l1_index];\n\n\n\n    /* seek the l2 table of the given l2 offset */\n\n\n\n    if (!l2_offset)\n\n        goto out;\n\n\n\n    /* load the l2 table in memory */\n\n\n\n    l2_offset &= ~QCOW_OFLAG_COPIED;\n\n    l2_table = l2_load(bs, l2_offset);\n\n    if (l2_table == NULL)\n\n        return 0;\n\n\n\n    /* find the cluster offset for the given disk offset */\n\n\n\n    l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n    nb_clusters = size_to_clusters(s, nb_needed << 9);\n\n\n\n    if (!cluster_offset) {\n\n        /* how many empty clusters ? */\n\n        c = count_contiguous_free_clusters(nb_clusters, &l2_table[l2_index]);\n\n    } else {\n\n        /* how many allocated clusters ? */\n\n        c = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, QCOW_OFLAG_COPIED);\n\n    }\n\n\n\n   nb_available = (c * s->cluster_sectors);\n\nout:\n\n    if (nb_available > nb_needed)\n\n        nb_available = nb_needed;\n\n\n\n    *num = nb_available - index_in_cluster;\n\n\n\n    return cluster_offset & ~QCOW_OFLAG_COPIED;\n\n}\n", "idx": 9106, "substitutes": {"bs": ["os", "bos", "utils", "bis", "its", "cs", "ls", "ss", "bc", "BS", "pb", "bps", "db", "ks", "lb", "ins", "sb", "bl", "es", "ts", "iss", "ds", "b", "outs", "fs", "fb", "bes", "bh", "gb", "ns", "css", "us", "ps", "ses", "plugins", "gs", "banks", "bits", "rs", "obs", "sa", "js", "vs", "aws"], "offset": ["padding", "shift", "pos", "timeout", "prefix", "size", "pointer", "type", "id", "aligned", "attribute", "limit", "online", "addr", "alpha", "seq", "option", "len", "i", "off", "node", "reset", "slot", "fee", "aware", "loc", "seed", "range", "url", "bit", "position", "Offset", "part", "address", "fp", "entry", "alloc", "length", "af", "error", "initial", "o", "conn", "start", "index", "buffer", "alias", "base", "origin", "set", "alt", "adjusted", "number", "location", "align", "slice"], "num": ["pos", "valid", "fn", "NUM", "unc", "um", "len", "node", "multi", "norm", "loc", "nom", "nu", "lim", "con", "gen", "numbered", "umi", "loop", "begin", "inc", "bin", "dim", "mon", "common", "nn", "m", "om", "mult", "nm", "init", "n", "Num", "uni", "batch", "count", "number", "coord", "sum"], "s": ["server", "g", "os", "sym", "f", "bis", "site", "service", "its", "cs", "state", "ls", "self", "ss", "states", "xs", "sq", "is", "ks", "ins", "services", "sb", "es", "ims", "p", "ts", "si", "S", "ds", "b", "settings", "session", "ssl", "details", "fs", "sl", "ns", "sim", "v", "spec", "us", "t", "ps", "ses", "words", "your", "qs", "sync", "gs", "conf", "south", "e", "n", "sys", "sets", "su", "rs", "obs", "sa", "space", "js", "stats", "rates", "aws"], "l1_index": ["l11__offset", "l4_prefix", "l11__bits", "l1Foffset", "l51_type", "l1__size", "l51Ftype", "l1_size", "l61_index", "l1_num", "l4_index", "l1Ftype", "l1xlength", "l51Fnum", "l11_offset", "l11__index", "l11_index", "l11_bits", "l1_sync", "l1xlock", "l1_prefix", "l1Fnum", "l1xprefix", "l1__offset", "l4_offset", "l51_index", "l1xindex", "l1Findex", "l1_type", "l51Findex", "l1xoffset", "l1xind", "l11__size", "l61_ind", "l1_offset", "l4_length", "l1__index", "l1xsync", "l61_lock", "l1__bits", "l1_ind", "l51_offset", "l11_size", "l51_num", "l51Foffset", "l1_lock", "l1_length", "l61_sync"], "l2_index": ["lii_table", "l2foffset", "l10_weight", "l82_index", "l2Mindex", "l2Mweight", "l82findex", "l2fslot", "l6_position", "l2ampointer", "l2Xelement", "l6_index", "l21_element", "l2Dtable", "l2acindex", "l2acpointer", "l82foffset", "l21amindex", "l2_thread", "l21amthread", "l2_element", "l2amindex", "l2Xindex", "lii_offset", "l21_index", "l2_size", "l2_loc", "l2_bin", "l2_position", "l82fslot", "l2Doffset", "l2acelement", "lii_output", "l82_slot", "l21_thread", "l21ampointer", "l10_option", "l6_bin", "l6_size", "l2_pointer", "l2Xthread", "l2_output", "l10_index", "l2amelement", "l2__size", "l82floc", "l2Doutput", "l2acthread", "l2__position", "l2Dindex", "l82_offset", "l2_slot", "l21_pointer", "l2amthread", "l82_loc", "l2__bin", "l21amelement", "l10_len", "l2_weight", "l2__index", "l2_len", "l2Moption", "l2findex", "l2floc", "l2_option", "lii_index", "l2Xpointer", "l2Mlen"], "l2_offset": ["l2acerror", "l2foffset", "l2ferror", "ltwo_reset", "l1_table", "l1_tile", "l2acreset", "l1_size", "l1_slot", "l2_error", "ltwofreset", "ltwoferror", "l2acoffset", "ltwo_offset", "l2acskip", "l2_size", "l2_position", "l1_addr", "l2_addr", "l1_position", "ltwo_skip", "l2_source", "l2Psource", "l2Poffset", "l2Pindex", "l1_location", "l2freset", "l2Ptable", "l2_skip", "l1_offset", "l2_tile", "l2_slot", "ltwofoffset", "l2_location", "l1_source", "ltwo_error", "ltwofskip", "l2fskip", "l2_reset"], "l2_table": ["lIItheunion", "lIIthetable", "l2Mrequired", "l2Mcache", "l2Droot", "l2Dservice", "l2thedatabase", "l2xbody", "l53_database", "l6_module", "l6_database", "l1_table", "l2Fstore", "l2Fdatabase", "l2relement", "l2_required", "l53_table", "l2Xstore", "l2Xtable", "l2xtable", "lone_cache", "l2thestore", "l02_table", "l2Mbody", "l2Dtable", "l02_page", "lone_body", "l2_union", "l02_service", "l2Fmachine", "l2_database", "l2_element", "l2rtable", "l53_store", "lIIthestore", "l2rmodule", "l53Xdatabase", "l2_body", "l2themodule", "l2Xdatabase", "lone_table", "l2xstore", "lone_required", "lII_union", "l2_root", "lII_body", "l2allstore", "l2theunion", "lII_table", "loneMcache", "l2Mtable", "l2theelement", "l53Xtable", "l2_source", "l2Dpage", "l2Ftable", "l2_store", "lIIthebody", "l2thebody", "l2rdatabase", "l53Xstore", "l53_machine", "l53Xmachine", "l02_root", "l2_module", "l1_offset", "l2allmachine", "l2_machine", "l2_cache", "lII_store", "l2alldatabase", "l2xunion", "l6_element", "l2Xmachine", "l2xpage", "l1_source", "l2_service", "l2xservice", "l2xroot", "loneMrequired", "l6_table", "l1_cache", "l2_page", "l2alltable", "loneMtable", "loneMbody", "l2thetable"], "cluster_offset": ["cluster1shift", "cluster_cache", "closen2part", "cluster2slot", "clayer_info", "closen_part", "cluster__size", "cluster__part", "cluster2part", "closen_slot", "cluster2cache", "cluster2position", "clayer_offset", "clusteracaddress", "clayeracoffset", "cluster7address", "cluster1offset", "clayer_shift", "cluster__start", "cluster2info", "cluster1address", "clayer_position", "clust_start", "cluster_size", "clust_size", "clayeracshift", "cluster0part", "closen_offset", "cluster_address", "cluster7shift", "cluster_info", "cluster2off", "cluster_optional", "cluster_shift", "cluster_off", "cluster_slot", "clusteracoffset", "clayer_address", "clayeracoptional", "clayer_off", "closen2slot", "clayeracaddress", "closen_cache", "cluster0slot", "cluster__slot", "closen2cache", "closen2offset", "cluster_part", "cluster2offset", "clust_index", "cluster_index", "cluster7offset", "cluster1optional", "cluster__cache", "clusteracoptional", "cluster_start", "cluster0cache", "clusteracshift", "cluster7optional", "clayer_optional", "cluster0offset", "cluster_position", "cluster__offset", "cluster__index", "clust_offset"], "l1_bits": ["l1vbit", "l1_bytes", "l1_locks", "l1vblocks", "l1_blocks", "l1_pieces", "lub_bits", "l1_its", "l1_abs", "l1lexbands", "l1lexabs", "l51_abs", "l51_length", "l1__bit", "l1lexmins", "l51_bits", "l2_codes", "l1lexbits", "lub_mins", "l1lexlocks", "l1vbits", "l2_its", "l2_blocks", "l1__its", "lub_bands", "l1_bands", "l2_bits", "l1_mins", "l1lexlength", "l2_bit", "lub_locks", "l1_codes", "l1__bits", "l1vbytes", "l51_codes", "l2_bytes", "l2_pieces", "l1_bit", "l1lexcodes", "l1__pieces", "l1_length"], "c": ["g", "abc", "f", "unc", "max", "k", "limit", "cs", "ce", "bc", "y", "i", "d", "h", "p", "cb", "b", "cy", "total", "cc", "z", "code", "C", "ac", "dc", "v", "r", "t", "o", "cl", "l", "cf", "ci", "call", "u", "w", "m", "col", "e", "n", "ec", "count", "x", "cache"], "index_in_cluster": ["index_in_lusters", "index_in_Clorer", "index_in_chue", "index_in_chure", "index_in_clusters", "index_in_Cluster", "index_in_loser", "index_in_clure", "index_in_slone", "index_in_scust", "index_in_Clusters", "index_in_sclorer", "index_in_scluster", "index_in_sclusters", "index_in_scuster", "index_in_clue", "index_in_clust", "index_in_licusters", "index_in_scusters", "index_in_licuster", "index_in_sloser", "index_in_chust", "index_in_licust", "index_in_clone", "index_in_licue", "index_in_Clure", "index_in_Closer", "index_in_scure", "index_in_sclone", "index_in_Clue", "index_in_sluster", "index_in_slust", "index_in_lust", "index_in_slorer", "index_in_luster", "index_in_closer", "index_in_clorer", "index_in_chusters", "index_in_Clust", "index_in_slusters", "index_in_chuster", "index_in_Clone"], "nb_available": ["nb_allowed", "pblexexternal", "ni67available", "nb67required", "ni_availability", "nbPprovided", "ni_allowed", "pb_external", "nb64availability", "nb_external", "nbPavailability", "nbPopened", "nb_announced", "cb_needed", "ni67availability", "nb_availability", "nblexneeded", "pb_availability", "nb67expected", "nob_available", "nbPavailable", "ni_expected", "ni67required", "nb___availability", "nblexavailable", "pb_needed", "nob_provided", "pblexavailability", "pb_available", "nb64announced", "nb___provided", "nb_expected", "cb_required", "nob_allowed", "nb67available", "nb__availability", "nb_required", "nb67availability", "nb64available", "ni67expected", "ni_required", "nb_provided", "nb___opened", "cb_used", "nb64allowed", "nblexexternal", "nob_availability", "nb__available", "nb_used", "cb_available", "ni_available", "ni_announced", "nblexavailability", "nob_needed", "nb__required", "nb_opened", "pblexneeded", "nb__expected", "nob_opened", "nb___available", "pblexavailable"], "nb_needed": ["len67needs", "nb__needed", "fee_needed", "len67used", "sync_needed", "sync67needs", "sync67needed", "nn_used", "nb___found", "nb_found", "nn_required", "len_used", "len_needs", "fee___found", "len67needed", "nn_initialized", "nn_needed", "nbMneeded", "fee_needs", "nb__contained", "nbMbalanced", "fee___needs", "nn_necessary", "nn_available", "nb67needs", "fee_necessary", "nb___needed", "sync67contained", "nb___needs", "nb_contained", "len_need", "nb_required", "fee___necessary", "sync_contained", "nb67need", "nb_balanced", "sync_needs", "nb_necessary", "nb__balanced", "nb___necessary", "nbMneeds", "sync67balanced", "len_needed", "nb67contained", "nb67balanced", "fee___needed", "nb_initialized", "nb67used", "nb_used", "sync_balanced", "nb_need", "len67need", "fee_found", "nb__needs", "nbMcontained", "nb_needs", "nb67needed"], "nb_clusters": ["nb_collusters", "nb_clicas", "nb_licas", "nb2collusters", "nb2clodes", "nb2collores", "nb_Clitions", "nb_scunks", "nb__litions", "nb2collodes", "nb2colluts", "nb00sclists", "nb_scores", "nb_clists", "nb__lusters", "nb_plusters", "nb00clunks", "nb2clusters", "nb_clodes", "nb__cluster", "nb_cleores", "nb_scists", "nb00clancers", "nb__clitions", "nb_sclists", "nb_scancers", "nb_clients", "nb2clores", "nb_kluster", "nb00clusters", "nb__licas", "nb_Cluster", "nb_clancers", "nb00sclunks", "nb_cluts", "nb_cleodes", "nb_blients", "nb_lusters", "nb_scuts", "nb_clunks", "nb_scusters", "nb_cleusters", "nb_sclunks", "nb2cluts", "nb_blusters", "nb_scodes", "nb_flunks", "nb_sclancers", "nb_slients", "nb__clusters", "nb_collodes", "nb_Clicas", "nb00sclancers", "nb_colluts", "nb_clitions", "nb__luster", "nb_klitions", "nb_cluster", "nb_plodes", "nb_Clusters", "nb_slores", "nb_collores", "nb_cleuts", "nb_flancers", "nb_plients", "nb_luster", "nb_blores", "nb_flusters", "nb_flists", "nb00sclusters", "nb_plores", "nb_klicas", "nb_klusters", "nb_sclusters", "nb_blodes", "nb00clists", "nb_clores", "nb_litions", "nb_slusters", "nb__clicas", "nb_slodes"]}}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "static inline int RENAME(yuv420_rgb16)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dst[], int dstStride[]){\n\n    int y, h_size;\n\n\n\n    if(c->srcFormat == PIX_FMT_YUV422P){\n\n\tsrcStride[1] *= 2;\n\n\tsrcStride[2] *= 2;\n\n    }\n\n\n\n    h_size= (c->dstW+7)&~7;\n\n    if(h_size*2 > FFABS(dstStride[0])) h_size-=8;\n\n\n\n    __asm__ __volatile__ (\"pxor %mm4, %mm4;\" /* zero mm4 */ );\n\n//printf(\"%X %X %X %X %X %X %X %X %X %X\\n\", (int)&c->redDither, (int)&b5Dither, (int)src[0], (int)src[1], (int)src[2], (int)dst[0],\n\n//srcStride[0],srcStride[1],srcStride[2],dstStride[0]);\n\n    for (y= 0; y<srcSliceH; y++ ) {\n\n\tuint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0];\n\n\tuint8_t *_py = src[0] + y*srcStride[0];\n\n\tuint8_t *_pu = src[1] + (y>>1)*srcStride[1];\n\n\tuint8_t *_pv = src[2] + (y>>1)*srcStride[2];\n\n\tlong index= -h_size/2;\n\n\n\n\tb5Dither= dither8[y&1];\n\n\tg6Dither= dither4[y&1];\n\n\tg5Dither= dither8[y&1];\n\n\tr5Dither= dither8[(y+1)&1];\n\n\t    /* this mmx assembly code deals with SINGLE scan line at a time, it convert 8\n\n\t       pixels in each iteration */\n\n\t    __asm__ __volatile__ (\n\n\t/* load data for start of next scan line */\n\n\t\t     \"movd (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\t\t     \"movd (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\t\t     \"movq (%5, %0, 2), %%mm6;\" /* Load 8  Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n//\t\t    \".balign 16\t\t\t\\n\\t\"\n\n\t\t    \"1:\t\t\t\t\\n\\t\"\n\n/* no speed diference on my p3@500 with prefetch,\n\n * if it is faster for anyone with -benchmark then tell me\n\n\t\t\tPREFETCH\" 64(%0) \\n\\t\"\n\n\t\t\tPREFETCH\" 64(%1) \\n\\t\"\n\n\t\t\tPREFETCH\" 64(%2) \\n\\t\"\n\n*/\n\nYUV2RGB\n\n\n\n#ifdef DITHER1XBPP\n\n\t\t\t\"paddusb \"MANGLE(b5Dither)\", %%mm0;\"\n\n\t\t\t\"paddusb \"MANGLE(g6Dither)\", %%mm2;\"\n\n\t\t\t\"paddusb \"MANGLE(r5Dither)\", %%mm1;\"\n\n#endif\n\n\t\t     /* mask unneeded bits off */\n\n\t\t     \"pand \"MANGLE(mmx_redmask)\", %%mm0;\" /* b7b6b5b4 b3_0_0_0 b7b6b5b4 b3_0_0_0 */\n\n\t\t     \"pand \"MANGLE(mmx_grnmask)\", %%mm2;\" /* g7g6g5g4 g3g2_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"pand \"MANGLE(mmx_redmask)\", %%mm1;\" /* r7r6r5r4 r3_0_0_0 r7r6r5r4 r3_0_0_0 */\n\n\n\n\t\t     \"psrlw $3,%%mm0;\" /* 0_0_0_b7 b6b5b4b3 0_0_0_b7 b6b5b4b3 */\n\n\t\t     \"pxor %%mm4, %%mm4;\" /* zero mm4 */\n\n\n\n\t\t     \"movq %%mm0, %%mm5;\" /* Copy B7-B0 */\n\n\t\t     \"movq %%mm2, %%mm7;\" /* Copy G7-G0 */\n\n\n\n\t\t     /* convert rgb24 plane to rgb16 pack for pixel 0-3 */\n\n\t\t     \"punpcklbw %%mm4, %%mm2;\" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"punpcklbw %%mm1, %%mm0;\" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */\n\n\n\n\t\t     \"psllw $3, %%mm2;\" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */\n\n\t\t     \"por %%mm2, %%mm0;\" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */\n\n\n\n\t\t     \"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n\t\t     MOVNTQ \" %%mm0, (%1);\" /* store pixel 0-3 */\n\n\n\n\t\t     /* convert rgb24 plane to rgb16 pack for pixel 0-3 */\n\n\t\t     \"punpckhbw %%mm4, %%mm7;\" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"punpckhbw %%mm1, %%mm5;\" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */\n\n\n\n\t\t     \"psllw $3, %%mm7;\" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */\n\n\t\t     \"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\n\n\t\t     \"por %%mm7, %%mm5;\" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */\n\n\t\t     \"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\n\n\t\t     MOVNTQ \" %%mm5, 8 (%1);\" /* store pixel 4-7 */\n\n\n\n\t\t     \"add $16, %1\t\t\t\\n\\t\"\n\n\t\t     \"add $4, %0\t\t\t\\n\\t\"\n\n\t\t     \" js 1b\t\t\t\t\\n\\t\"\n\n\n\n\t\t     : \"+r\" (index), \"+r\" (_image)\n\n\t\t     : \"r\" (_pu - index), \"r\" (_pv - index), \"r\"(&c->redDither), \"r\" (_py - 2*index)\n\n\t\t     );\n\n    }\n\n\n\n    __asm__ __volatile__ (EMMS);\n\n\n\n    return srcSliceH;\n\n}\n", "idx": 9109, "substitutes": {"c": ["g", "ctx", "f", "xc", "k", "cs", "nc", "comp", "ce", "vc", "pc", "ca", "d", "rc", "h", "p", "cur", "enc", "b", "cp", "cm", "cu", "con", "ct", "cal", "ctrl", "cc", "C", "ac", "cv", "dc", "ch", "t", "l", "ci", "conn", "u", "w", "m", "cam", "conf", "oc", "e", "n", "tc", "cn", "lc", "s", "mc", "ec"], "src": ["rect", "sur", "support", "usr", "text", "scl", "dest", "ctx", "scenes", "proc", "sel", "sub", "rob", "seq", "sq", "conv", "sup", "sr", "sb", "rc", "config", "ources", "rss", "http", "gl", "loc", "st", "b", "ssl", "url", "sl", "rb", "bs", "iv", "cv", "spec", "source", "attr", "sc", "lib", "secure", "scene", "sec", "uc", "inst"], "srcStride": ["srcShroute", " srcStide", "srcEstide", "srcStause", "srcSlride", "srcScrite", "srcSlrite", "srcSTri", "srcSlroy", "supportStride", "rcStride", "rcEstide", "srcStope", "srcSTide", "srcSlerve", "srcShroy", "srcSlide", "srcSTrue", "srcShrite", "srcDause", "srcSluse", "srcSlri", "stClrite", "supportSTide", "srcConstroute", "srcClructure", "supportSTride", "srcScause", "rcShroute", "srcEstride", "srcStandrite", "srcStandide", "rcStrue", "srcShide", " srcStcase", "rcEstri", "srcSTuse", "stClause", "srcShri", "srcDride", "srcConstroy", "srcEstrite", "srcStuse", "srcShride", "supportStope", "srcStri", "rcStri", "srcEstope", " srcSterve", "srcScructure", "rcEstrue", "srcClrite", "srcConstri", "srcScri", "srcStandcase", "srcStroy", "rcShride", "rcEstride", "srcSTride", "supportSTope", "srcStide", "srcEstri", "srcStrite", "supportStide", "srcClause", "supportStuse", "srcEstrue", "srcScide", "srcScride", "srcSterve", "rcStroy", "stStrite", "srcStructure", "stStride", "srcScrue", "srcEstuse", "srcSlroute", "srcStandride", "srcConstride", "stClructure", "stStause", "rcStide", "srcStrue", "srcClride", "stStructure", "srcDructure", "srcStcase", "supportSTuse", "stClride", " srcStrite", "srcEsterve", "rcShri", "srcShcase", "rcShroy", "srcStroute", "srcDrite", "srcSTope", "rcStroute", "srcSlope"], "srcSliceY": ["srcFlaseW", "srcSlideH", "srcSlideX", "srcFlaseY", "srcSlaceM", "srcSliceM", "srcFliceH", "srcFlICEW", "srcFliceW", "srcSlideW", "srcSlICEW", "srcFliceX", "srcSlaceY", "srcFliceY", "srcSlICEM", "srcSlideM", "srcSliceW", "srcSlaseW", "srcSlaseH", "srcSlaceW", "srcSlaceH", "srcSlaceX", "srcSlaseX", "srcFlICEX", "srcSlICEX", "srcFlICEM", "srcSliceX", "srcFlICEY", "srcFliceM", "srcSlideY", "srcSlICEY", "srcFlaseX", "srcSlaseY", "srcFlaseH"], "srcSliceH": ["srcSlideH", "srcFliceH", "srcFlICEH", "srcSlICEHT", "srcSlaceF", "srcFlICEW", "srcFliceW", "srcSliceHT", "srcSlsliceH", "srcSlideW", "srcSlICEW", "srcSlICEH", "srcFliceX", "srcSlaceY", "srcFliceY", "srcSliceW", "srcSlICEF", "srcFlICEHT", "srcSlideF", "srcSlaceW", "srcSlaceH", "srcSlaceX", "srcFlICEF", "srcSlsliceHT", "srcSlICEX", "srcFlICEX", "srcSliceF", "srcSliceX", "srcSlsliceX", "srcFlICEY", "srcFliceHT", "srcSlideY", "srcFliceF", "srcSlICEY", "srcSlaceHT", "srcSlsliceY"], "dst": ["nsrc", "Dste", "Dst", "dste", " drc", "gsrc", "nste", "Dsts", " dsts", "dsrc", " dste", "drc", " dsrc", "gst", "dsts", "gsts", "nsts", "Drc", "Dsrc", "grc", "nst"], "dstStride": ["dstaStro", "dstScrite", "dstTro", "dstaStend", "dscStri", "dsrcStube", "dstStro", "dstTri", "dstStend", "dstCend", "dstStrro", "dscTri", "dsrcStrite", "dstTride", "dstaStrend", "dstScri", "dscTrip", "dstCri", "dstCrite", "dststube", "dstTide", "dststrip", "dststride", "dstStube", "dstStri", "dstTend", "dstCrip", "dstStrube", "dscTride", "dstScride", "dsrcstube", "dstStide", "dstaStide", "dstTrip", "dstStrri", "dstCride", "dststri", "dstTrite", "dscStrite", "dsrcstrite", "dstStrite", "dsrcstride", "dstCro", "dscTrite", "dstStrride", "dstaStride", "dstStrend", "dsrcStri", "dstaStrride", "dstaStrro", "dstStrip", "dsrcStride", "dststrite", "dscStride", "dstStrrite", "dsrcstri", "dstCide", "dstScube", "dscStrip"], "y": ["zy", "ey", "yd", "yy", "type", "yo", "uy", "iy", "ky", "ny", " x", "ys", "ya", "yi", "i", "d", "yan", "h", "yang", "p", "dy", "hy", "vy", "b", "cy", "gy", "year", "j", "yr", "z", "ye", "ay", "sy", "t", "say", "sky", "ym", "ady", "ry", "w", "m", "ty", "yt", "n", "yl", "Y", "my", "isy", "yu", " Y", "py", "count", "oy", "x"], "h_size": ["hxsize", "h_loc", "h__sum", " hxize", "h_sum", "h__scale", "h__length", "h2loc", "hxloc", "h2scale", "H__size", "h_length", "hxscale", "hxize", "h2ize", "h_SIZE", " hxscale", "h__size", "H_len", "h_len", " h_scale", " h_address", "H__len", " h_loc", "h1len", "h2size", " h_width", "H_sum", "H__Size", "h__Size", "h1length", " h_SIZE", "H__scale", " hxloc", " h_sum", "h_scale", "h__len", "h_Size", "h1loc", "H__loc", "H_size", "H_Size", "h1size", "h_ize", " h_ize", "h_width", "H__sum", " hxsize", "h__loc", "h_address", "H_loc", "H__length", "H_scale", "H_length"], "_image": ["timg", "_img", "toriginal", "_original", "tpng", "_png", "timage"], "_py": ["wpic", "_dim", "hxy", "_xy", "hpic", "_pic", " _pic", "hpy", "hdim", "wpy", " _dim", " _xy", "wxy", "wdim"], "_pu": ["__lu", "__gpu", "__pu", "_ui", "_gpu", "__ui", "_lu"], "_pv": ["_ppu", "_Pv", "_Pvi", "_pvi", "_Pu", "_gv", "_gu", "_Pf", "_gvi", "_ppf", "_ppvi", "_ppv", "_gf", "_pf"]}}
{"project": "qemu", "commit_id": "b8aecea23aaccf39da54c77ef248f5fa50dcfbc1", "target": 1, "func": "void memory_region_add_eventfd(MemoryRegion *mr,\n\n                               hwaddr addr,\n\n                               unsigned size,\n\n                               bool match_data,\n\n                               uint64_t data,\n\n                               EventNotifier *e)\n\n{\n\n    MemoryRegionIoeventfd mrfd = {\n\n        .addr.start = int128_make64(addr),\n\n        .addr.size = int128_make64(size),\n\n        .match_data = match_data,\n\n        .data = data,\n\n        .e = e,\n\n    };\n\n    unsigned i;\n\n\n\n    adjust_endianness(mr, &mrfd.data, size);\n\n    memory_region_transaction_begin();\n\n    for (i = 0; i < mr->ioeventfd_nb; ++i) {\n\n        if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) {\n\n            break;\n\n        }\n\n    }\n\n    ++mr->ioeventfd_nb;\n\n    mr->ioeventfds = g_realloc(mr->ioeventfds,\n\n                                  sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);\n\n    memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],\n\n            sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));\n\n    mr->ioeventfds[i] = mrfd;\n\n    ioeventfd_update_pending |= mr->enabled;\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 9122, "substitutes": {"mr": ["tr", "plugin", "usr", "fr", "rt", "mer", "bm", "nr", "pm", "Mr", "hr", "rpm", "err", "wk", "mid", "rg", "adr", "wm", "module", "wire", "MR", "sr", "eu", "dr", "ru", "lr", "tm", "theme", "wr", "rl", "bridge", "rf", "fm", "cm", "drm", "bh", "vr", "eer", "gb", "gro", "mt", "rb", "yr", "github", "rx", "r", "br", "kr", "shr", "km", "req", "rm", "m", "gr", "eri", "nm", "dm", "mm", "ml", "er", "bro", "rs", "mor", "rr", "mc", "rh", "lc", "rar", "mmm", "manager", "mn", "mx", "hm"], "addr": ["hop", "oa", "owner", "np", "uri", "prefix", "rt", "pointer", "src", "mode", "nr", "ctx", "id", "ptr", "ref", "state", "ip", "host", "adr", "len", "route", "dist", "node", "dr", "config", "amp", "rc", "ace", "offset", "osi", "bridge", "loc", "ord", "extra", "inst", "work", "range", "rn", "frame", "act", "address", "dc", "layer", "length", "mac", "attr", "area", "conn", "ino", "proxy", "start", "index", "arity", "amd", "pad", "base", "rr", "eni", "name", "ad", "alias", "location", "align"], "size": ["empty", "activity", "max", "mi", " Size", "c", "fee", "settings", "address", "Size", "channel", "area", "speed", "sized", "SIZE", "weight", "grow", "second", "ity", "range", "shape", "end", "z", "code", "length", "ise", "sec", "send", "capacity", "mode", "len", "en", "year", "scale", "ize", "l", "sync", "six", "large", "mini", "name", "count", "number", "pos", "timeout", "izes", "nick", "cycle", "is", "small", "es", "izer", "offset", "si", "loc", "core", "export", "iz", "unit", "storage", "cap"], "match_data": ["match___data", "match_value", "Match2Data", "matchedkeys", "match64pos", "matchingval", " match_all", "match_style", "matched_keys", "match2data", "matchableData", "Match_Data", "Match2data", "matchableval", "match_keys", "matchingData", "match_all", "matchningdata", "matchedvalue", "matchabledata", "match_val", "match_Data", " match_pos", "matchingdata", "match___keys", "match2Data", "matchningall", "match64data", "match___style", "matcheddata", "matched_value", "match_pos", "matched_style", "matched_data", "matchningpos", "match2val", "Match_data", "Match_val", "match64all", "match___value", "matchedstyle", "Match2val"], "data": ["bus", "dat", "action", "ata", "timeout", "message", "append", "empty", "id", "format", "device", "callback", "Data", "api", "buf", "devices", "state", "ea", "connection", "result", "alpha", "media", "cache", "aa", "DATA", "d", "bytes", "function", "response", "content", "input", "results", "load", "done", "open", "partial", "array", "di", "address", "memory", "image", "reader", "ui", "handler", "da", "error", "source", "length", "def", "bin", "next", "buffer", "body", "pad", "delay", "progress", "value", "oder", "batch", "window", "ad", "read", "writer"], "e": ["ne", "de", "ey", "eve", "f", "ue", "edge", "ea", "ce", "engine", "c", "en", "fe", "eu", "d", "ae", "es", "ev", "p", "ed", "E", "b", "ede", "ie", "end", "se", "ee", "o", "t", "error", "r", "l", "esi", "u", "oe", "m", "n", "er", "eur", "entity", "ec", "s", "none", "element", "energy"], "i": ["ii", "ti", "ni", "li", "uri", "f", "id", "phi", "I", "iv", "api", "mu", "ip", "oi", "mi", "fi", "y", "c", "yi", "iu", "is", "a", "ini", "d", "ri", "p", "si", "b", "pi", "j", "gi", "ie", "cli", "address", "in", "z", "xi", "bi", "di", "qi", "o", "r", "ui", "length", "v", "l", "ci", "zi", "u", "index", "m", "ij", "n", "info", "ai", "eni", "x", "ix", "it"], "ioeventfd_nb": ["ioeventfdPloop", "ioeventfd_cb", "ioeventfd2num", "ioeventf_cb", "ioeventf_b", "ioeventfdPnb", "ioeventfd2base", "ioeventFD_nb", "ioeventfd2nb", "ioeventfn_base", "ioeventfdPnum", "ioeventFD_rb", "ioeventFD_nr", "ioeventfd_nr", "ioeventfd_base", "ioeventf_nb", "ioeventfd_rb", "ioeventf_note", "ioeventfn_loop", "ioeventfd_loop", "ioeventfn_nb", "ioeventfn_num", "ioeventFD_cb", "ioeventfd_b", "ioeventfdPbase", "ioeventFD_bm", "ioeventfd_num", "ioeventfd2loop", "ioeventfd_note", "ioeventfd_bm"]}}
{"project": "FFmpeg", "commit_id": "c3778df2d4c05e76d28d77a2d740e435393046c9", "target": 0, "func": "enum AVPixelFormat choose_pixel_fmt(AVStream *st, AVCodec *codec, enum AVPixelFormat target)\n\n{\n\n    if (codec && codec->pix_fmts) {\n\n        const enum AVPixelFormat *p = codec->pix_fmts;\n\n        int has_alpha= av_pix_fmt_desc_get(target)->nb_components % 2 == 0;\n\n        enum AVPixelFormat best= AV_PIX_FMT_NONE;\n\n        if (st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n\n            if (st->codec->codec_id == AV_CODEC_ID_MJPEG) {\n\n                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE };\n\n            } else if (st->codec->codec_id == AV_CODEC_ID_LJPEG) {\n\n                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV420P,\n\n                                                 AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE };\n\n            }\n\n        }\n\n        for (; *p != AV_PIX_FMT_NONE; p++) {\n\n            best= avcodec_find_best_pix_fmt_of_2(best, *p, target, has_alpha, NULL);\n\n            if (*p == target)\n\n                break;\n\n        }\n\n        if (*p == AV_PIX_FMT_NONE) {\n\n            if (target != AV_PIX_FMT_NONE)\n\n                av_log(NULL, AV_LOG_WARNING,\n\n                       \"Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\\n\",\n\n                       av_get_pix_fmt_name(target),\n\n                       codec->name,\n\n                       av_get_pix_fmt_name(best));\n\n            return best;\n\n        }\n\n    }\n\n    return target;\n\n}\n", "idx": 9134, "substitutes": {"st": ["stim", "fr", "steam", "ess", "sth", "src", "ost", "ist", "ft", "td", "sb", "dr", "spect", "stage", "sta", "ste", "ST", "sts", "nd", "end", "se", "sl", "est", "osc", "kt", "ut", "client", "t", "cl", "std", "ust", "sc", "start", "stack", "sn", "ast", "St", "nt", "rest", "stream", "inst", "stop", "str"], "codec": ["cedef", "compeca", "codeesc", "coderer", "labdc", "cheenc", "pedenc", "codeEC", "compEC", "codef", " codenc", "ode", "Coderer", "aquEC", "labenc", "coderec", "compesc", "labef", " codrec", "odeca", "Codeca", "codeca", " codeca", "codesc", "odoc", "codack", "code", "compoc", "labec", "codEC", "Codac", " codep", "Codrec", "cheac", "compenc", "aquec", "odenc", "compeco", "CodEC", "codeack", "odesc", "Codef", "codeerer", "codeco", "cedec", " codEC", "compac", "aquect", "codep", "codeec", "Codec", " coderer", "coddc", " code", "cedeca", "pedec", "cheec", " coddc", "Codenc", "pedef", "Codep", "codeenc", "odEC", "cedep", "peddc", "codrec", " codack", "cheeco", "compec", "odec", "aquack", "codenc", " codect", "codeect", "codoc", " codef", "codeoc", "codect", "compe", "codac", "Codeco"], "target": ["transform", "support", "gap", "arget", "valid", "dest", "compatible", "global", "type", "src", "format", "match", "localhost", "path", "blank", "host", "self", "class", "output", "result", "external", "instance", "method", "master", "new", "config", "largest", "input", "options", "pattern", "any", "end", "best", "array", "parent", "client", "t", "source", "opt", "platform", "peer", "next", "component", "arg", "current", "last", "obj", "goal", "this", "value", "Target", "nt", "null", "root", "top", "large", "window", "object"], "p": ["param", "g", "prop", "np", "tp", "pg", "f", "at", "dp", "pn", "pm", "k", "y", "pb", "c", "pc", "a", "i", "jp", "d", "lp", "h", "per", "after", "back", "ep", "sp", "b", "pi", "cp", "j", "hp", "best", "P", "po", "pre", "fp", "op", "v", "pe", "parent", "code", "t", "o", "ps", "wp", "l", "point", "q", "pp", "u", "w", "m", "e", "n", "pa", "progress", "port", "s", "bp", "data", "x", "pect", "post"]}}
{"project": "qemu", "commit_id": "2531088f6c1ce1f620f8d5a545f0af95598e69fc", "target": 1, "func": "static void gic_set_irq(void *opaque, int irq, int level)\n\n{\n\n    /* Meaning of the 'irq' parameter:\n\n     *  [0..N-1] : external interrupts\n\n     *  [N..N+31] : PPI (internal) interrupts for CPU 0\n\n     *  [N+32..N+63] : PPI (internal interrupts for CPU 1\n\n     *  ...\n\n     */\n\n    GICState *s = (GICState *)opaque;\n\n    int cm, target;\n\n    if (irq < (s->num_irq - GIC_INTERNAL)) {\n\n        /* The first external input line is internal interrupt 32.  */\n\n        cm = ALL_CPU_MASK;\n\n        irq += GIC_INTERNAL;\n\n        target = GIC_TARGET(irq);\n\n    } else {\n\n        int cpu;\n\n        irq -= (s->num_irq - GIC_INTERNAL);\n\n        cpu = irq / GIC_INTERNAL;\n\n        irq %= GIC_INTERNAL;\n\n        cm = 1 << cpu;\n\n        target = cm;\n\n    }\n\n\n\n    assert(irq >= GIC_NR_SGIS);\n\n\n\n    if (level == GIC_TEST_LEVEL(irq, cm)) {\n\n        return;\n\n    }\n\n\n\n    if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n        gic_set_irq_11mpcore(s, irq, level, cm, target);\n\n    } else {\n\n        gic_set_irq_generic(s, irq, level, cm, target);\n\n    }\n\n\n\n\n    gic_update(s);\n\n}", "idx": 9150, "substitutes": {"opaque": ["opedac", "opacity", " opaco", "opusher", " opac", "openaques", "opedaco", "opedusher", "iopaco", " opusher", "iopac", " opacity", "opac", "opaco", "iopaque", "iopusher", "opaques", "operaques", "operaque", " opaques", "operacity", "openaque", "openacity", "opedaque"], "irq": ["riQ", " irqu", "lrq", "irqq", "IRQ", "ierquest", "iraqual", "iraqq", "ireq", "ireqa", "ierqi", "iraQ", "rich", "irech", "lrQ", "irequ", "IRq", "yrquest", "irqual", "ierqa", "iriquest", "irireq", "irtq", "ierQ", "yrqu", "rique", "mirQ", "irg", "mirque", "ierreq", "iraq", "irqa", "iriq", "Irquest", "irreq", "iraquery", "IRqa", "riquery", "IRquest", "riq", "yrQ", "riqs", "mirquest", "irtquest", "irtqi", "irtQ", "Irg", "IRqi", "irqs", "ironq", "irtqu", "ierq", "mirq", "ireQ", "irtqual", " irquest", "irtquery", "ierqu", "irtqq", "irtque", "Irqu", "iraque", "iraqu", "pirq", "ironQ", "irtreq", "Irq", "irch", "lrqu", "iriqu", "irque", "irquery", "ironqs", "riqq", "irQ", "yrque", "pirqs", "irqu", "irqi", "ierg", "riqual", "ironqu", "ireqq", "IRque", "irquest", "ierque", "iraquest", "lrque", " irg", "pirQ", "irtch", "IRqu", "riqu", "pirqu", "yrq", "riquest"], "level": ["size", "type", "Level", "mode", "high", "local", "limit", "path", "ul", "len", "sequence", "vel", "module", "c", "co", "model", "enc", "content", "stage", "loc", "scope", "pri", "fl", "con", "url", "wl", "scale", "rule", "key", "hi", "code", "coll", "levels", "parent", "pe", "inc", "layer", "length", "cl", "el", "l", "sc", "index", "m", "col", "cle", "lc", "lvl", "ec", "depth", "line"], "s": ["server", "g", "os", "sym", "f", "site", "service", "cs", "state", "self", "sf", "ss", "states", "private", "xs", "y", "c", "sq", "is", "sup", "i", "ks", "d", "services", "sb", "a", "es", "p", "ts", "sg", "si", "S", "session", "b", "http", "sie", "ssl", "ds", "secondary", "sis", "sl", "ns", "spec", "us", "o", "t", "r", "ses", "l", "sync", "u", "gs", "m", "conf", "south", "e", "n", "sys", "this", "su", "rs", "storage", "sk", "sets", "js", "status"], "cm": ["param", "im", "chain", "ctx", "bm", "mode", "pm", "cut", "dom", "gm", "module", "c", "mr", "pc", "wm", "ca", "uca", "course", "cache", "comm", "config", "chip", "fm", "cy", "cp", "ctrl", "url", "center", "core", "cc", "fp", "dc", "vm", "cl", "cmd", "km", "ci", "cf", "dim", "ym", "cr", "rm", "CM", "m", "com", "component", "mm", "dm", "crit", "cn", "mc", "lc", "um", "mx", "nm"], "target": ["transform", "remote", "timeout", "arget", "compatible", "ctx", "pointer", "match", "site", "format", "limit", "path", "cut", "output", "module", "task", "master", "term", "config", "offset", "content", "scope", "member", "net", "range", "session", "center", "secondary", "core", "trace", "address", "gt", "client", "parent", "tail", "t", "source", "platform", "resource", "force", "conn", "forward", "component", "unit", "goal", "cn", "token", "value", "Target", "large", "null", "top", "manager", "location", "object"], "cpu": ["np", "hw", "pool", "pm", "nic", "nc", "appa", "proc", "GPU", "pixel", "pc", "instance", "cmp", "computer", "lb", "pu", "master", "node", "rc", "uca", "fps", "prem", "CPU", "chip", "boot", "net", "cp", "PC", "core", " CPU", "fp", "thread", "vm", "num", "roc", "platform", "gp", "program", "bench", "gpu", "conn", "component", "processor", "unit", "cn", "process", "CP", "lc", "gc", "performance", "cache"]}}
{"project": "FFmpeg", "commit_id": "366ac22ea5a8bab63c7f46cdad2ddb2ff22cdbed", "target": 1, "func": "static int decode_mb_info(IVI5DecContext *ctx, IVIBandDesc *band,\n                          IVITile *tile, AVCodecContext *avctx)\n{\n    int         x, y, mv_x, mv_y, mv_delta, offs, mb_offset,\n                mv_scale, blks_per_mb;\n    IVIMbInfo   *mb, *ref_mb;\n    int         row_offset = band->mb_size * band->pitch;\n    mb     = tile->mbs;\n    ref_mb = tile->ref_mbs;\n    offs   = tile->ypos * band->pitch + tile->xpos;\n    /* scale factor for motion vectors */\n    mv_scale = (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3);\n    mv_x = mv_y = 0;\n    for (y = tile->ypos; y < (tile->ypos + tile->height); y += band->mb_size) {\n        mb_offset = offs;\n        for (x = tile->xpos; x < (tile->xpos + tile->width); x += band->mb_size) {\n            mb->xpos     = x;\n            mb->ypos     = y;\n            mb->buf_offs = mb_offset;\n            if (get_bits1(&ctx->gb)) {\n                if (ctx->frame_type == FRAMETYPE_INTRA) {\n                    av_log(avctx, AV_LOG_ERROR, \"Empty macroblock in an INTRA picture!\\n\");\n                    return -1;\n                }\n                mb->type = 1; /* empty macroblocks are always INTER */\n                mb->cbp  = 0; /* all blocks are empty */\n                mb->q_delta = 0;\n                if (!band->plane && !band->band_num && (ctx->frame_flags & 8)) {\n                    mb->q_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                           IVI_VLC_BITS, 1);\n                    mb->q_delta = IVI_TOSIGNED(mb->q_delta);\n                }\n                mb->mv_x = mb->mv_y = 0; /* no motion vector coded */\n                if (band->inherit_mv){\n                    /* motion vector inheritance */\n                    if (mv_scale) {\n                        mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);\n                        mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale);\n                    } else {\n                        mb->mv_x = ref_mb->mv_x;\n                        mb->mv_y = ref_mb->mv_y;\n                    }\n                }\n            } else {\n                if (band->inherit_mv) {\n                    mb->type = ref_mb->type; /* copy mb_type from corresponding reference mb */\n                } else if (ctx->frame_type == FRAMETYPE_INTRA) {\n                    mb->type = 0; /* mb_type is always INTRA for intra-frames */\n                } else {\n                    mb->type = get_bits1(&ctx->gb);\n                }\n                blks_per_mb = band->mb_size != band->blk_size ? 4 : 1;\n                mb->cbp = get_bits(&ctx->gb, blks_per_mb);\n                mb->q_delta = 0;\n                if (band->qdelta_present) {\n                    if (band->inherit_qdelta) {\n                        if (ref_mb) mb->q_delta = ref_mb->q_delta;\n                    } else if (mb->cbp || (!band->plane && !band->band_num &&\n                                           (ctx->frame_flags & 8))) {\n                        mb->q_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                               IVI_VLC_BITS, 1);\n                        mb->q_delta = IVI_TOSIGNED(mb->q_delta);\n                    }\n                }\n                if (!mb->type) {\n                    mb->mv_x = mb->mv_y = 0; /* there is no motion vector in intra-macroblocks */\n                } else {\n                    if (band->inherit_mv){\n                        /* motion vector inheritance */\n                        if (mv_scale) {\n                            mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);\n                            mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale);\n                        } else {\n                            mb->mv_x = ref_mb->mv_x;\n                            mb->mv_y = ref_mb->mv_y;\n                        }\n                    } else {\n                        /* decode motion vector deltas */\n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                            IVI_VLC_BITS, 1);\n                        mv_y += IVI_TOSIGNED(mv_delta);\n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                            IVI_VLC_BITS, 1);\n                        mv_x += IVI_TOSIGNED(mv_delta);\n                        mb->mv_x = mv_x;\n                        mb->mv_y = mv_y;\n                    }\n                }\n            }\n            mb++;\n            if (ref_mb)\n                ref_mb++;\n            mb_offset += band->mb_size;\n        }\n        offs += row_offset;\n    }\n    align_get_bits(&ctx->gb);\n    return 0;\n}", "idx": 9162, "substitutes": {"ctx": ["cas", "la", "utils", "hw", "Context", "xc", "anc", "cs", "nc", "voc", "connection", "wx", "bc", "wcs", "vc", "c", "conv", "ca", "cmp", "rc", "config", "cb", "kb", "sci", "ck", "loc", "pkg", "qa", "scope", "cm", "cp", "ct", "ctrl", "cal", "context", "cfg", " context", "cc", "cli", "kt", "coll", "cv", "cms", "hub", "client", "cl", "cmd", "cf", "conn", "ci", "sc", "sync", "cam", "conf", "tx", "fw", "cn", "qq", "lc", "cca", "gc"], "band": ["board", "service", "connection", "ground", "bo", "bound", "plane", "gb", "bd", "kt", "key", "bb", "channel", "cmd", "word", "wave", "dB", "broad", "line", "plugin", "prop", "db", "feature", "card", "usb", "back", "stage", "range", "frame", "flag", "bin", "link", "brand", "station", "car", "port", "bus", "song", "mode", "unk", "boot", "cell", "direction", "part", "bands", "phase", "layer", "leg", "group", "product", "cast", "match", "device", "flow", "Band", "tool", "tag", "co", "play", "bridge", "nd", "style", "bit", "piece", "core", "rule", "image", "brid", "unit", "batch", "lf", "slice", "zone"], "tile": ["gap", "li", "tf", "tu", "file", "service", "zip", "tif", "flo", "byte", "pixel", "kernel", "plane", "ht", "kt", "grid", "txt", "target", "line", "plugin", "live", "texture", "site", "bm", "plate", "ski", "module", "feature", "ace", "img", "flat", "ie", "mt", "coll", "header", "link", "bin", "det", "sheet", "conn", "ele", "oe", "lite", "port", "uni", "dt", "pod", "hop", "mode", "metadata", "table", "boot", "Tile", "scale", "cube", "ti", "layer", "cf", "fo", "sky", "fit", "ge", "sk", "ilo", "phy", "uri", "device", "tool", "mage", "tag", "nb", "game", "co", "node", "dr", "ile", "theme", "chip", "bridge", "loc", "interface", "project", "ite", "uv", "rule", "core", "cli", "image", "entry", "mask", "tab", "nn", "component", "col", "so", "slice"], "avctx": ["avconfig", "avcontext", "AVctx", "avectx", "Avctx", "avcm", "avecm", "AVconfig", " avctrl", " avcontext", "Avcontext", "AVcm", "Avconfig", " avcm", "devconfig", "devcontext", "avecontext", "devctrl", "Avctrl", "avectrl", "AVcontext", "devctx", "avctrl", "AVctrl"], "x": ["pos", "ph", "zx", "yx", "ax", "f", "on", "id", "xc", "sw", "php", "wx", "ya", "c", "X", "ex", "i", "xy", "en", "d", "by", "off", "h", "p", "xxx", "b", "gy", "px", "z", "v", "code", "image", "xi", "hi", "num", "rx", "t", "el", "time", "win", "fx", "index", "xx", "dx", "ady", "w", "m", "wa", "tx", "e", "n", "my", "xp", "name", "ix"], "y": ["zy", "ey", "yd", "wy", "yy", "yx", "type", "f", "yo", "id", "ky", "iy", "ny", "ys", "ya", "asy", "yi", "a", "i", "xy", "d", "h", "p", "dy", "hy", "vy", "b", "cy", "gy", "ish", "year", "yr", "z", "ye", "ay", "sy", "o", "t", "sky", "ym", "ady", "ry", "w", "m", "height", "ty", "yt", "yl", "n", "Y", "lon", "py", "oy"], "mv_x": ["mf_xx", "mw_y", "mv_h", "mvIde", "mv8xx", "mv_e", "mf_x", "mvIdx", "mvIdd", "mb_ex", "mf_scale", "mb_x", "mf_rx", "mf_z", "mvIdrx", "mf_y", "mv8scale", "mf_e", "mw_xy", "mv8y", "mvIdz", "mv_rx", "mv_xx", "mv_ex", "mb_y", "mvIdy", "mv_d", "mv_z", "mf_d", "mb_h", "mv_xy", "mw_z", "mv8x", "mw_x"], "mv_y": ["mm_y", "mm_ty", "mv2ty", "mf_py", "mv2cy", "mh_x", "mh_p", "mf_z", "mv_cy", "mm_ny", "mm2ny", "mh_i", "mf_y", "mf_x", "mm2cy", "mv2ny", "mv_i", "mm2ty", "mm2y", "mv_py", "mm_cy", "mv2y", "mv_p", "mv_ty", "mh_y", "mv_z", "mv_ny"], "mv_delta": ["mv_delt", "mv__ddbase", "mv_ddbase", "mv_ddelta", "mv_Dbase", "mv_ddiff", "mv_Delt", "mv_pelt", "mv_diff", "mv__ddelt", "mv_pbase", "mv_Diff", "mv_pelta", "mv__dbase", "mv_ddelt", "mv__delta", "mv__ddiff", "mv_dbase", "mv_Delta", "mv__diff", "mv__delt", "mv__ddelta", "mv_piff"], "offs": ["oa", "pos", "utils", "eps", "OFF", "args", "ff", "aux", "ups", "ons", "powers", " offsets", "points", "ks", "times", "off", "rows", "flows", "ands", "bytes", "offset", "windows", "aps", "lines", "options", "ds", "blocks", "outs", "ones", "xff", " off", "nos", "ows", "Offset", "bands", "ns", "ms", "ans", "pieces", "errors", "frames", "sets", "bits", "heads", "s", "ops", "tips"], "mb_offset": ["mx_slot", "lim_location", "mb67adjust", "mc67Offset", "mb_position", "lim67off", "mc_offset", "mc_adjust", "mbPoffset", "mc67offset", "mc_Offset", "mb67off", "mb67position", "mc_position", "mc67adjust", "mb67delay", "mb_Offset", "lim_delay", "mb67offset", "mbPoff", "lim67offset", "mbPdelay", "mx_count", "lim_off", "lim_offset", "mbPlocation", "mb67Offset", "mb_off", "mb_slot", "mb_delay", "mb67location", "mx_offset", "lim67delay", "mb_count", "mb_location", "mx_off", "lim67location", "mb_adjust", "mc67position"], "mv_scale": ["mw_scale", "mv_center", "mv\u00b7init", "mf_grade", "mv_slice", "mb_scale", "mv_margin", "mf_size", "mf_scale", "mf_slice", "mv_init", "mv__size", "mb_size", "mv__center", "mv\u00b7scale", "mb_gap", "mf_cale", "mv\u00b7margin", "mw_init", "mv_rate", "mv__scale", "mf_center", "mv_cale", "mb_rate", "mw_margin", "mw_slice", "mv_grade", "mv_size", "mv_gap", "mv\u00b7slice", "mv__grade"], "blks_per_mb": ["blks_Per_kb", "blks_per_kb", "blks_per_mm", "blks_per_MB", "blks_Per_mm", "blks_Per_MB", "blks_Per_mb"], "mb": ["ph", "pg", "em", "bm", "sm", "ref", "meg", "MB", "fam", "mp", "GB", "nb", "bc", "byte", "md", "ma", "pb", "gg", "db", "BM", "library", "lb", "eb", "sb", "bl", "amp", "mod", "kb", "ib", "b", "fm", "cm", "bg", "fb", "lim", "app", "orb", "gb", "mt", "rb", "bd", "ms", "mem", "vm", "bb", "xb", "bin", "cmd", "ym", "m", "job", "amb", "om", "mm", "emb", "base", "org", "ob", "mor", "mc", "bp", "bf", "mag", "mn", " MB", "mx", "nm"], "ref_mb": [" ref_bb", "ref_kb", "reference_mm", "ref_MB", "ref__mm", "ref__mb", "ref_mp", "reference_ym", "refvalkb", "reference_mb", "rel_mp", "refvalmm", "ref_mm", "refvalym", "ref_ym", "ref_bb", "rel_gb", "ref__ym", "ref__emb", "refvalmb", "ref__kb", "ref__gb", "ref_emb", " ref_mm", " ref_MB", "rel_emb", "ref__mp", "ref_gb", "reference_kb", "rel_mb"]}}
{"project": "qemu", "commit_id": "0f888bfaddfc5f55b0d82cde2e1164658a672375", "target": 1, "func": "VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)\n{\n    VIOsPAPRDevice *sdev;\n    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);\n    if (!sdev && reg == 0) {\n        /* Hack for kernel early debug, which always specifies reg==0.\n         * We search all VIO devices, and grab the vty with the lowest\n         * reg.  This attempts to mimic existing PowerVM behaviour\n         * (early debug does work there, despite having no vty with\n         * reg==0. */\n        return spapr_vty_get_default(spapr->vio_bus);\n    return sdev;", "idx": 9172, "substitutes": {"vty_lookup": ["vty_lookdown", "vty_finddown", "vty_signup", "vty_findUp", "vty_signdown", "vty_findup", "vty_lookUp", "vty_signUp"], "sPAPRMachineState": ["sPAPRMounterstate", "sPAPRMachinestate", "sPAPREMobileConfig", "sPAPRMounterState", "sPAPREMachineState", "sPAPRMounterService", "sPAPREMobileService", "sPAPRMounterConfig", "sPAPREMachineService", "sPAPRMouseService", "sPAPRMachineConfig", "sPAPRMachineService", "sPAPREMobilestate", "sPAPRMobilestate", "sPAPRMouseConfig", "sPAPRMobileService", "sPAPRMobileState", "sPAPREMachinestate", "sPAPRMouseState", "sPAPREMobileState", "sPAPREMachineConfig", "sPAPRMobileConfig", "sPAPRMousestate"], "spapr": ["spaprator", "spapprar", "scapra", "sprapra", "spapsr", "spaprs", "sprapr", "spappr", " spapsrc", " spapsra", "spapsrc", "scapprb", "papsrs", "spapsrar", "spappra", "spapprc", "spampr", "spapar", "spopar", "scappra", " spaprc", "sparprar", "papar", "spraprb", "spaprb", "scappar", "spopra", "papsar", " spaprar", "spaprc", "spapsar", "spamprator", "spraprator", "spapra", "papsrator", "spapsrs", "spraprs", "spappar", "paprator", "sparprc", "papr", "sparpra", "spapprb", "scaprb", " spapsr", "spamprs", " spapsrar", "spopr", "scappr", "spapsrator", "sparpr", "scapar", "scapr", "spaprar", "sprapar", "spapsra", "papsr", "spampar", " spapra", "spoprb", "paprs"], "target_ulong": ["target_uint_", "target_ullong", "target_ul_", "target_uint32", "target_ul32", "target_us_", "target_u32", "target_uintlong", "target_uintong", "target_uong", "target_usong", "target_u_", "target_us32", "target_uslong"], "reg": ["g", "ann", "im", "Reg", "match", "re", "eng", " Reg", "serial", "dis", "tag", "addr", "rg", "min", "stat", "eg", "dist", "arch", "bl", "rc", "mod", "config", "scan", "arc", "loc", "net", "rem", "ag", "memory", "spec", "mem", "num", "dev", "REG", "rec", "gr", "org", "col", "region", "port", "res", "sec", "rest", "name", "ig", "data", "feat"], "sdev": ["sdiv", "Sev", "wsDev", "sev", "sesdevice", "dsev", "sportsdiv", "csdev", "sesdev", "smod", " smod", " spred", "sdevice", "Spred", "sportsdev", "wsdev", "Sdevice", "sportsDev", "spred", "csmod", "SDev", "gerror", "dsDev", " sev", "wsdiv", "gmod", "sespred", " sdevice", "gdev", "dsdev", "Sdev", "sesev", "cserror", "sportsvar", "gdevice", "dsdevice", "csdevice", " sDev", " serror", "svar", "sDev", "wsvar", "serror"]}}
{"project": "qemu", "commit_id": "356f59b8757f47c0aca3e2e4e51d6010f64cade1", "target": 1, "func": "void coroutine_fn block_job_pause_point(BlockJob *job)\n\n{\n\n    assert(job && block_job_started(job));\n\n\n\n    if (!block_job_should_pause(job)) {\n\n        return;\n\n    }\n\n    if (block_job_is_cancelled(job)) {\n\n        return;\n\n    }\n\n\n\n    if (job->driver->pause) {\n\n        job->driver->pause(job);\n\n    }\n\n\n\n    if (block_job_should_pause(job) && !block_job_is_cancelled(job)) {\n\n        job->paused = true;\n\n        job->busy = false;\n\n        qemu_coroutine_yield(); /* wait for block_job_resume() */\n\n        job->busy = true;\n\n        job->paused = false;\n\n    }\n\n\n\n    if (job->driver->resume) {\n\n        job->driver->resume(job);\n\n    }\n\n}\n", "idx": 9174, "substitutes": {"job": ["server", "message", "self", "connection", "sub", "model", "b", "worker", "queue", "pause", "cmd", "lock", "child", "page", "status", "build", "line", "plugin", "live", "up", "id", "api", "home", "result", "module", "user", "db", "task", "lb", "session", "member", "j", "run", "code", "hub", "parent", "handler", "error", "base", "er", "section", "manager", "exec", "block", "f", "hide", "poll", "route", "event", "config", "fun", "fire", "ah", "part", "layer", "lib", "sync", "jobs", "ob", "name", "py", "bug", "blog", "pool", "match", "flow", "jo", "output", "node", "bar", "function", "cb", "order", "work", "url", "project", "loop", "image", "Job", "process", "bot", "object"]}}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_pread(BlockDriverState *bs, int64_t offset,\n               void *buf1, int count1)\n{\n    BlockDriver *drv = bs->drv;\n    if (!drv)\n        return -ENOMEDIUM;\n    if (!drv->bdrv_pread)\n        return bdrv_pread_em(bs, offset, buf1, count1);\n    return drv->bdrv_pread(bs, offset, buf1, count1);\n}", "idx": 9176, "substitutes": {"bs": ["bos", "os", "bis", "src", "cs", "ls", "ss", "bc", "BS", "pb", "bps", "ks", "lb", "ins", "sb", "bl", "bytes", "cb", "fps", "iss", "ds", "b", "bes", "fb", "blocks", "fs", "rb", "ns", "css", "ras", "ps", "ses", "gs", "as", "banks", "boxes", "ubs", "obj", "las", "bits", "base", "bas", "rs", "lbs", "obs", "s", "bid", "vs"], "offset": ["padding", "absolute", "pos", "timeout", "et", "prefix", "loader", "size", "pointer", "type", "online", "ptr", "ref", "addr", "seq", "off", "config", "reset", "slot", "order", "loc", "boot", "bound", "url", "position", "Offset", "part", "address", "fp", "image", "layer", "length", "o", "attr", "area", "initial", "start", "index", "reference", "buffer", "inet", "base", "origin", "port", "set", "data", "count", "location", "align"], "buf1": ["uf0", "buffer2", "buf3", "bufferp", "buff0", " buf3", "buff1", " buf4", "buffer3", " buf2", "bag1", "uf2", "bag2", "buffer4", "bag4", "bagone", "buf4", "buf2", "buff2", "uf1", "bufferone", "bufp", " buf0", "buffp", "buffer0", "bufone", "buffer1", " bufone", " bufp", "buf0", "uf3"], "count1": ["part2", "count8", "partone", "len1", "cond2", "lenOne", " countone", " count8", "countone", " countOne", "sumOne", "countOne", "partOne", " count2", "cond1", "part8", "sum2", "lenone", "call1", "callone", "count2", "len2", "sum1", "call8", "call2", "part1", "condone", "sumone", "condOne"], "drv": ["drvs", " drb", "hrV", "drvc", "rdf", "adrver", " drf", "DRvr", " drvc", "hrb", "driv", "DRV", "Drf", "drver", "drvr", "rdvr", "DRv", "DRvs", "driver", " drver", "DrV", "rdv", "hrv", "adrf", "drib", "adrvc", "drp", "drV", "rdvs", " drvs", "irv", " drV", "drb", " drvr", "Drv", "irvc", "Drp", "hrf", "drf", "DRp", "adrv", " drp", "Drb", "drif", "irver", "Drver", "irf", "DRf"]}}
{"project": "FFmpeg", "commit_id": "44ac13eed49593f4f8efdb72ab0d5b48e05aa305", "target": 1, "func": "int avpriv_dca_convert_bitstream(const uint8_t *src, int src_size, uint8_t *dst,\n\n                             int max_size)\n\n{\n\n    uint32_t mrk;\n\n    int i, tmp;\n\n    const uint16_t *ssrc = (const uint16_t *) src;\n\n    uint16_t *sdst = (uint16_t *) dst;\n\n    PutBitContext pb;\n\n\n\n    if ((unsigned) src_size > (unsigned) max_size)\n\n        src_size = max_size;\n\n\n\n    mrk = AV_RB32(src);\n\n    switch (mrk) {\n\n    case DCA_SYNCWORD_CORE_BE:\n\n        memcpy(dst, src, src_size);\n\n        return src_size;\n\n    case DCA_SYNCWORD_CORE_LE:\n\n        for (i = 0; i < (src_size + 1) >> 1; i++)\n\n            *sdst++ = av_bswap16(*ssrc++);\n\n        return src_size;\n\n    case DCA_SYNCWORD_CORE_14B_BE:\n\n    case DCA_SYNCWORD_CORE_14B_LE:\n\n        init_put_bits(&pb, dst, max_size);\n\n        for (i = 0; i < (src_size + 1) >> 1; i++, src += 2) {\n\n            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;\n\n            put_bits(&pb, 14, tmp);\n\n        }\n\n        flush_put_bits(&pb);\n\n        return (put_bits_count(&pb) + 7) >> 3;\n\n    default:\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n}\n", "idx": 9178, "substitutes": {"src": ["sur", "ctr", "uri", "scl", "dest", "ource", "buf", "proc", "comp", "supp", "sel", "sub", "rob", "seq", "sq", "low", "dist", "sup", "sit", "sr", "cmp", "sb", "rc", "config", "cur", "cb", "loc", "st", "split", "b", "ssl", "obl", "img", "url", "gb", "rb", "sl", "iv", "spec", "code", "length", "source", "rel", "chrom", "attr", "req", "sc", "start", "sync", "sn", "desc", "RC", "secure", "lower", "rest", "uc", "sec", "s", "rib", "inst", "slice"], "src_size": [" src_loc", "rc_time", "src_name", " src_scale", "secure_size", " src_ize", "rc_engine", "srcsloc", "secure_sum", "rc_address", "rc_scale", "rss_sized", "srcqSIZE", "src_sum", "rc_capacity", "src_loc", "rss_size", "src_capacity", "src_SIZE", " src_length", "rc_ize", "src_count", "rc_SIZE", "src_small", "rc_size", "rc_name", "src_scale", " src_count", "srcqscale", "srcssize", "rss_scale", "src_address", "src_sized", "src_ize", "secure_SIZE", "srcslength", "srcqengine", "src_length", "srcsize", "srcqsize", "src_engine", "src_time", "secure_small"], "dst": ["dsc", "dest", "Dst", " dest", "dedst", " drc", "dedest", "Dsl", "dssc", "dedsts", "sdsc", "dedbl", "sdsts", "Dest", "dsst", "Dsts", "pdsrc", " dsts", "dsrc", "pdsl", "sdest", "drc", "pdsc", "sdrc", " dsrc", "dbl", "dsts", "dedrc", "dsl", "dssts", " dsc", "pdst", " dbl", "dedsc", " dsl", "Dsrc", "dsbl", "Dsc"], "max_size": ["max64storage", "maxlexoffset", "maxLoffset", " max64size", " max_len", " max_time", "maxfullname", "max_len", "max64name", " max64capacity", "max64capacity", "max_storage", "max24count", "max_cap", "maxLsize", " max64storage", "maxlexlen", " max64name", "maxlexsize", "maxaccount", "max24cap", "max_name", "max_offset", " max_count", "max64size", " max_name", "maxfullcapacity", "max33depth", "max33offset", "maxacsize", "max24size", "max_depth", " max_capacity", " max_depth", "max_count", "maxlexcapacity", "max_capacity", " max_cap", "maxaccap", "max24time", " max_storage", "maxfullsize", "maxfullstorage", "max33size", "maxactime", "maxLdepth", " max_offset", "max_time"], "mrk": ["vrks", "drke", "MRok", "mrkg", "lrkg", "rrK", "MRkk", "krkk", "Mrks", "rrke", "MRK", " hrke", "MRks", "vrk", "krk", "lrke", "lrk", "Mrke", "mrok", "rrks", "mrkk", "Mrk", "mrK", "MRk", "rrk", " hrk", "Mrok", " hrkg", "drks", "krks", "drk", "lrK", "MRke", "mrke", "MRkg", "drok", "vrkk", "lrks", "mrks", "vrK", "krK", " hrK"], "i": ["ii", "pos", "ni", "li", "im", "uri", "f", "type", "id", "phi", "I", "k", "mu", "ip", "oi", "mi", "fi", "chi", "image", "c", "iu", "ini", "multi", "rc", "ji", "p", "ri", "si", "di", "pi", "io", "pri", "j", "gi", "end", "ie", "in", "ti", "bi", "xi", "z", "hi", "r", "ui", "source", "v", "qi", "ind", "ci", "zi", "start", "index", "u", "init", "info", "ai", "mini", "uni", "x", "ix", "it"], "tmp": ["np", "tf", "yy", "diff", "phi", "ptr", "buf", "vt", "ff", "mp", "proc", "nb", "result", "db", "cmp", "jp", "sb", "TB", "rc", "amp", "cpp", "cb", "temp", "cur", "sp", "fb", "cp", "kk", "img", "Temp", "uv", "part", "rb", "fp", "bb", "source", "abb", "pp", "buff", "bf", "obj", "tc", "stuff", "wb", "meta", "bp", "txt", "data"], "ssrc": ["yslc", "sRC", "dslc", "ssri", "dssrc", "SSRC", "dsri", "yssrc", "ysrc", "SSsrc", "ssrs", "vslc", "dsrc", "vssrc", "vsrc", "vsri", "SSrc", "dsRC", "ysri", "SSrs", "sssrc", "dsrs", "sslc", "ssRC", "srs"], "sdst": [" sdnd", "ddft", "dsc", "tdst", "SDst", " sdost", "ddst", "SDft", "sdsc", "sdost", "tdft", "ddsc", "tdsp", "hdnd", "dost", "sdft", "SDsc", "tdsc", "dnd", "sdnd", "SDsp", " sdsc", "hdost", "ddsp", "sdsp", "hdsc", "hdst"], "pb": ["bj", "tp", "pg", "dp", "bm", "pm", "api", "pl", "sf", "mp", " eb", "nb", "bc", "rob", "bps", "db", "pc", "lb", "jp", "eb", " PB", "sb", "lp", "pd", "lab", "cb", "p", "ib", "b", "mb", "fb", "cp", "bh", "bt", "ub", "gb", "obb", "rb", "bsp", "fp", "fc", "hub", "vm", "bb", "xb", "wp", "pp", "vp", "pa", "tc", "ob", "wb", "bp", "bf", "PB", "bot"]}}
{"project": "qemu", "commit_id": "b21da4e504fbdb907543a918b190783dc896d8e1", "target": 1, "func": "static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,\n                               unsigned int epid)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    int i;\n    trace_usb_xhci_ep_disable(slotid, epid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n    slot = &xhci->slots[slotid-1];\n    if (!slot->eps[epid-1]) {\n        DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid);\n        return CC_SUCCESS;\n    xhci_ep_nuke_xfers(xhci, slotid, epid);\n    epctx = slot->eps[epid-1];\n    if (epctx->nr_pstreams) {\n        xhci_free_streams(epctx);\n    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);\n    timer_free(epctx->kick_timer);\n    g_free(epctx);\n    slot->eps[epid-1] = NULL;\n    return CC_SUCCESS;", "idx": 9189, "substitutes": {"xhci": ["sexhlci", "xhtca", "xwco", "xhtci", "Xhcci", "xhrsci", "xhtcu", "xihcm", "xhhcci", "xwsci", "sexhcu", "sexhlcu", "xwci", "xehdc", "xbhii", "xhhri", "xehcm", "xhdc", " xphcm", "workhsci", "xhcu", "xhlcin", "Xhci", "xphco", "xhsci", "xhcit", "xhrco", "xphcm", " xhsci", " xphci", "xhlcu", "xehcci", "xhlri", "xehri", "xrhii", "xehsci", "xwca", "workhsri", "sexhci", "Xhcin", "Xehcin", " xhco", "Xehri", "Xehci", "xrhcu", "workhcu", " xhcm", "xrhci", "Xhri", "xehco", "xhhcin", "xhii", "xhca", "workhsca", "sexhlcit", "xhco", " xhcci", "xhsca", "xbhci", "xwri", "xhtri", "xehcin", "xhlcit", "xbhcu", " xphco", "xhcci", "xwcci", "xhrci", "xhsri", "xhlii", "workhca", "xehci", "xhcm", "xwcu", "xhri", " xphdc", "workhci", "xhlcci", "Xehcci", "xhhci", "xihco", "xhscu", "xphdc", "xihdc", "sexhcit", "workhri", " xwco", "xphci", " xwcci", "xrhcit", " xwsci", "xbhcit", "sexhii", "xhrcci", "xihci", " xhdc", "workhscu", " xwci", "sexhlii", "xhlci", "xhcin"], "slotid": ["slotId", "slotinfo", "lotide", "socketname", "socketid", "lotId", "spotno", " slotname", "lotno", "spotId", "socketide", " slotno", "socketno", "slotide", "slotname", "spotid", "lotid", "lotname", "spotide", "spotname", " slotinfo", "spotinfo", " slotId", "slotno", "lotinfo"], "epid": ["ypaid", " epi", "ekpath", "espit", "eknum", "epit", " epit", "ppaid", "yppid", "ampaid", "ep1", "ypx", "opx", "yppath", "apkid", "taskkid", "ppID", " epID", "amppid", "ip1", "epsit", "epi", "epsid", "lipip", "ipId", "epids", "ppid", "evid", "apid", "ewkid", " epip", "epspid", "epID", "epId", "evId", "evit", "ipID", " epaid", "ipit", "ypids", "ampip", "epsaid", "ypip", "espid", " epkid", "ppit", "epip", "espID", "tasknum", "ekkid", " epnum", "lipnum", "apId", "opids", "epsId", "ypID", "ppi", " epin", "epsip", "epsi", "taskId", "ekids", "evi", "epin", "ewId", "opid", "ipkid", "ypi", "apin", "ekid", "epkid", "epsID", "lipid", " ep1", "ampid", "epnum", "ekx", "taskid", "epx", "ekId", "epaid", "lip1", "ppId", "eppath", "ewin", "ypit", "oppath", "espip", "eppid", "ipid", " epId", "ipnum", "ewid", "ipip", "ypid"], "slot": ["server", "plugin", "timeout", "li", "pit", "layout", "rol", "pool", "service", "tz", "Slot", "table", "connection", "serv", "option", "module", "ion", "game", "sit", "trial", "lot", "shot", "kernel", "cat", "offset", "loc", "session", "cell", "boot", "socket", "account", "shell", "sl", "loop", "pot", "entry", "rot", "channel", "pin", "bin", "lib", "tab", "hole", "job", "lock", "profile", "section", "lc", "slave", "margin", "blog", "role", "pty", "target", "spot", "slice", "zone"], "epctx": ["pctx", "pcmp", "epcor", "ypcor", "eploc", "ipcmp", "mpcm", "ypcm", "ewloc", "mpcb", "epcontext", "ewcontext", "ekctrl", "ekcontext", "eptx", "iploc", "pptx", "Epctx", "ipctx", "ecctx", "ypcontext", "ecconn", "EPcontext", "ekcmp", "ppcf", "mpcontext", "epcmd", "mploc", "ypcb", "ekconn", "EPctx", "mpctrl", "yploc", "mpctx", "mptx", "ypcf", "Eploc", "epcf", "mpcor", "Epcmp", "epconn", "ewctx", "yptx", "ipcmd", "ppcontext", "ekcmd", "ypconn", "epctrl", " epconn", "EPcmp", "ewcm", "eccf", "ptx", "mpconn", "Epcmd", "eccontext", "ekctx", "epcm", " epcontext", "EPtx", "eccb", "pcontext", "ppctx", "ppcor", "ypctx", " epctrl", "mpcmp", "ekloc", "epcmp", "ppconn", "epcb"], "i": [" I", "f", "id", "I", "k", "ip", "c", "is", "a", "d", "h", "ri", "p", "b", "ic", "pi", "io", "j", "in", "o", "r", "l", "e", "n", "ai", "or", "it"]}}
{"project": "qemu", "commit_id": "bc3e6a0d6c8ab6cd7cd4b576ed567756f1dcabd2", "target": 1, "func": "int pvpanic_init(ISABus *bus)\n\n{\n\n    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);\n\n    return 0;\n\n}\n", "idx": 9193, "substitutes": {"bus": ["plugin", "os", "pass", "board", "mount", "stick", "BUS", "serial", "connection", "tag", "controller", "usb", "config", "http", "bridge", "plug", "boot", "session", "scope", "use", "io", "driver", "address", "Bus", "hub", "us", "brand", "sync", "base", "las", "port", "book", "bank", "bug", "cache"]}}
{"project": "qemu", "commit_id": "679aa175e84f5f80b32b307fce5a6b92729e0e61", "target": 0, "func": "static uint32_t gic_dist_readb(void *opaque, hwaddr offset, MemTxAttrs attrs)\n\n{\n\n    GICState *s = (GICState *)opaque;\n\n    uint32_t res;\n\n    int irq;\n\n    int i;\n\n    int cpu;\n\n    int cm;\n\n    int mask;\n\n\n\n    cpu = gic_get_current_cpu(s);\n\n    cm = 1 << cpu;\n\n    if (offset < 0x100) {\n\n        if (offset == 0)\n\n            return s->enabled;\n\n        if (offset == 4)\n\n            /* Interrupt Controller Type Register */\n\n            return ((s->num_irq / 32) - 1)\n\n                    | ((NUM_CPU(s) - 1) << 5)\n\n                    | (s->security_extn << 10);\n\n        if (offset < 0x08)\n\n            return 0;\n\n        if (offset >= 0x80) {\n\n            /* Interrupt Group Registers: these RAZ/WI if this is an NS\n\n             * access to a GIC with the security extensions, or if the GIC\n\n             * doesn't have groups at all.\n\n             */\n\n            res = 0;\n\n            if (!(s->security_extn && !attrs.secure) && gic_has_groups(s)) {\n\n                /* Every byte offset holds 8 group status bits */\n\n                irq = (offset - 0x080) * 8 + GIC_BASE_IRQ;\n\n                if (irq >= s->num_irq) {\n\n                    goto bad_reg;\n\n                }\n\n                for (i = 0; i < 8; i++) {\n\n                    if (GIC_TEST_GROUP(irq + i, cm)) {\n\n                        res |= (1 << i);\n\n                    }\n\n                }\n\n            }\n\n            return res;\n\n        }\n\n        goto bad_reg;\n\n    } else if (offset < 0x200) {\n\n        /* Interrupt Set/Clear Enable.  */\n\n        if (offset < 0x180)\n\n            irq = (offset - 0x100) * 8;\n\n        else\n\n            irq = (offset - 0x180) * 8;\n\n        irq += GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_ENABLED(irq + i, cm)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x300) {\n\n        /* Interrupt Set/Clear Pending.  */\n\n        if (offset < 0x280)\n\n            irq = (offset - 0x200) * 8;\n\n        else\n\n            irq = (offset - 0x280) * 8;\n\n        irq += GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;\n\n        for (i = 0; i < 8; i++) {\n\n            if (gic_test_pending(s, irq + i, mask)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x400) {\n\n        /* Interrupt Active.  */\n\n        irq = (offset - 0x300) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_ACTIVE(irq + i, mask)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x800) {\n\n        /* Interrupt Priority.  */\n\n        irq = (offset - 0x400) + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = GIC_GET_PRIORITY(irq, cpu);\n\n    } else if (offset < 0xc00) {\n\n        /* Interrupt CPU Target.  */\n\n        if (s->num_cpu == 1 && s->revision != REV_11MPCORE) {\n\n            /* For uniprocessor GICs these RAZ/WI */\n\n            res = 0;\n\n        } else {\n\n            irq = (offset - 0x800) + GIC_BASE_IRQ;\n\n            if (irq >= s->num_irq) {\n\n                goto bad_reg;\n\n            }\n\n            if (irq >= 29 && irq <= 31) {\n\n                res = cm;\n\n            } else {\n\n                res = GIC_TARGET(irq);\n\n            }\n\n        }\n\n    } else if (offset < 0xf00) {\n\n        /* Interrupt Configuration.  */\n\n        irq = (offset - 0xc00) * 4 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        for (i = 0; i < 4; i++) {\n\n            if (GIC_TEST_MODEL(irq + i))\n\n                res |= (1 << (i * 2));\n\n            if (GIC_TEST_EDGE_TRIGGER(irq + i))\n\n                res |= (2 << (i * 2));\n\n        }\n\n    } else if (offset < 0xf10) {\n\n        goto bad_reg;\n\n    } else if (offset < 0xf30) {\n\n        if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n            goto bad_reg;\n\n        }\n\n\n\n        if (offset < 0xf20) {\n\n            /* GICD_CPENDSGIRn */\n\n            irq = (offset - 0xf10);\n\n        } else {\n\n            irq = (offset - 0xf20);\n\n            /* GICD_SPENDSGIRn */\n\n        }\n\n\n\n        res = s->sgi_pending[irq][cpu];\n\n    } else if (offset < 0xfe0) {\n\n        goto bad_reg;\n\n    } else /* offset >= 0xfe0 */ {\n\n        if (offset & 3) {\n\n            res = 0;\n\n        } else {\n\n            res = gic_id[(offset - 0xfe0) >> 2];\n\n        }\n\n    }\n\n    return res;\n\nbad_reg:\n\n    qemu_log_mask(LOG_GUEST_ERROR,\n\n                  \"gic_dist_readb: Bad offset %x\\n\", (int)offset);\n\n    return 0;\n\n}\n", "idx": 9210, "substitutes": {"opaque": ["OPac", "Opquire", "OPque", "opbuffer", "opacity", " opbuffer", "OPquire", "Opac", "opquire", " opacity", "ipac", "opac", "ipaque", "Opaque", "ipque", "ipquire", "OPaque", "OPbuffer", "opque", "operaque", "operacity", "OPacity", "Opque", "operbuffer"], "offset": ["padding", "server", "et", "iso", "online", "ref", "ip", "option", "sequence", "bytes", "reset", "slot", "clock", "fee", "queue", "missing", "Offset", "address", "ui", "esi", "inet", "info", "alias", "location", "line", "size", "pointer", "activation", "id", "attribute", "limit", "api", "off", "operation", "range", "end", "fp", "length", "o", "error", "delay", "base", "port", "set", "energy", "align", "esp", "shift", "utils", "prefix", "ptr", "len", "part", "phase", "frequency", "start", "index", "sync", "onto", "tile", "pos", "timeout", "type", "path", "addr", "p", "loc", "url", "style", "position", "image", "entry", "initial", "reference", "data", "starting", "optional", "skip", "slice"], "attrs": ["attributes", "attrrs", "addros", " attributes", "ttros", "addributes", "attrps", "attps", "attrls", "ttrs", "ttributes", "ttps", "Attros", " attls", "Attps", "addrs", "attls", "attrributes", "attros", "Attributes", " attps", "addps", "Attrs", "Attls"], "s": ["server", "sym", "service", "cs", "self", "c", " services", "a", "d", "settings", "b", "hs", "sites", "gs", "w", "e", "js", "os", "site", "ls", "ss", "sq", "sb", "http", "S", "session", "ds", "sie", "ssl", "o", "ses", " requests", "f", "sf", "xs", "times", "services", "sg", "secondary", "sl", " settings", "r", "ps", "l", "u", "sync", "south", "sys", "sk", "g", "local", "state", "states", "is", " os", "es", "p", "ts", "si", "results", "se", "ns", "less", "spec", "t", "m", "conf", "n", "sets", "storage", "sa", "stats", "ops"], "res": ["rus", "os", "utils", "rys", "features", "args", "match", "resp", "vals", "re", "max", "cs", "err", "resolution", "result", "fields", "powers", "ores", "mr", "cmp", "RES", "ries", "rows", "rc", "rss", "bytes", "response", "reset", "arr", "details", "scope", "blocks", "Rs", "results", "rem", "runs", "pre", "pres", "ris", "ms", "row", "ras", "r", "ret", "val", "ress", "Res", "clear", "gr", "ros", "bits", "rs", "reg", "out", "rest", "js", "rh", "cons", "resh", "cache"], "irq": ["ironqt", "iraflow", "ironqual", "riQ", "ironce", "irqq", "arque", "incct", "IRQ", "urq", "ierquest", "urquery", "pirque", "irz", "ireq", "ironquest", "ierqt", "ireqa", "earque", "incque", "ironz", "IRq", "irqual", "ierqa", "rinqu", "incflow", "irec", " irque", "irekg", "arche", "earQ", "rilqual", "irtq", "arf", "irct", "virct", "incq", "rique", "earqu", "virQ", "irqt", "pirqa", "arkg", "iraq", "irqa", "irequest", "irc", "iraquery", "irche", "IRqa", " irz", "irece", "riq", "riqa", " irc", "arq", "irtquest", "earquest", "ireque", "earcharge", "irtQ", "earqq", "ironqq", "virflow", "irqs", "IRqs", "ironq", "ierq", "pirz", "irflow", "pirce", "iracharge", "virque", "ireQ", "iract", " irce", "irtque", "iraque", "pirq", "urQ", "ironque", "urque", "urcharge", "ierquery", "arc", "irque", "irquery", "rilqt", " irqa", "irQ", " irQ", "rinquest", "virq", "earq", "rinQ", "urqa", "iercharge", "irqu", " irche", "rilq", "irkg", "irf", "arQ", "ironqa", "urqs", "rilqa", "ireqq", "rinq", "ircharge", "irquest", "ierque", "iraquest", "urquest", "pirQ", "ironcharge", " irf", "irecharge", "earce", "ierqual", " irkg", "virche", "irce", "riqu", "ireqs", "riquest", "iref"], "i": ["ii", "ni", "li", "uri", "hi", "f", "id", "phi", "I", "mu", "ip", "oi", "mi", "fi", "chi", "y", "c", "yi", "ki", "iu", "is", "ini", "ei", "d", "multi", "ri", "p", "ji", "ani", "si", "z", "pi", "io", "j", "ori", "gi", "end", "ie", "ami", "cli", "in", "ti", "xi", "zi", "di", "bi", "qi", "v", "ui", "image", "o", "t", "l", "ci", "start", "index", "u", "my", "e", "info", "n", "init", "ai", "eni", "vi", "x", "ix", "it"], "cpu": ["np", "linux", "prefix", "pool", "pm", "nic", "nc", "proc", "pixel", "c", "len", "pc", "cmp", "pu", "p", "fps", "CPU", "sci", "chip", "clock", "ips", "net", "cp", "rem", "core", "cli", " CPU", "mem", "image", "vm", "num", "roc", "cl", "gp", "gpu", "ci", "conn", "nn", "component", "current", "process", "lc", "gc", "cache"], "cm": ["dem", "form", "im", "bm", "pm", "cum", "cut", "gm", "c", "wm", "module", "mr", "comm", "chip", "sem", "qa", "fm", "rem", "cp", "drm", "hm", "core", "cc", "umi", "cli", "vm", "num", "cl", "req", "cf", "q", "ci", "dim", "km", "cr", "ym", "rm", "m", "CM", "iam", "mult", "mm", "dm", "nm", "cn", "om", "lc", "mc", "mx", "cache"], "mask": ["flags", "ask", "weight", "result", "rows", "rc", "kernel", "ace", "windows", "blocks", "ips", "net", "rem", "qa", "bit", "cc", "ms", "ch", "row", "conn", "ress", "gr", "bits", "sk", "resh", "cost", "cache"]}}
{"project": "qemu", "commit_id": "36778660d7fd0748a6129916e47ecedd67bdb758", "target": 0, "func": "static inline int get_segment_6xx_tlb(CPUPPCState *env, mmu_ctx_t *ctx,\n\n                                      target_ulong eaddr, int rw, int type)\n\n{\n\n    hwaddr hash;\n\n    target_ulong vsid;\n\n    int ds, pr, target_page_bits;\n\n    int ret;\n\n    target_ulong sr, pgidx;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n\n\n    sr = env->sr[eaddr >> 28];\n\n    ctx->key = (((sr & 0x20000000) && (pr != 0)) ||\n\n                ((sr & 0x40000000) && (pr == 0))) ? 1 : 0;\n\n    ds = sr & 0x80000000 ? 1 : 0;\n\n    ctx->nx = sr & 0x10000000 ? 1 : 0;\n\n    vsid = sr & 0x00FFFFFF;\n\n    target_page_bits = TARGET_PAGE_BITS;\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n            \"Check segment v=\" TARGET_FMT_lx \" %d \" TARGET_FMT_lx\n\n            \" nip=\" TARGET_FMT_lx \" lr=\" TARGET_FMT_lx\n\n            \" ir=%d dr=%d pr=%d %d t=%d\\n\",\n\n            eaddr, (int)(eaddr >> 28), sr, env->nip, env->lr, (int)msr_ir,\n\n            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);\n\n    pgidx = (eaddr & ~SEGMENT_MASK_256M) >> target_page_bits;\n\n    hash = vsid ^ pgidx;\n\n    ctx->ptem = (vsid << 7) | (pgidx >> 10);\n\n\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n            \"pte segment: key=%d ds %d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ds, ctx->nx, vsid);\n\n    ret = -1;\n\n    if (!ds) {\n\n        /* Check if instruction fetch is allowed, if needed */\n\n        if (type != ACCESS_CODE || ctx->nx == 0) {\n\n            /* Page address translation */\n\n            qemu_log_mask(CPU_LOG_MMU, \"htab_base \" TARGET_FMT_plx\n\n                    \" htab_mask \" TARGET_FMT_plx\n\n                    \" hash \" TARGET_FMT_plx \"\\n\",\n\n                    env->htab_base, env->htab_mask, hash);\n\n            ctx->hash[0] = hash;\n\n            ctx->hash[1] = ~hash;\n\n\n\n            /* Initialize real address with an invalid value */\n\n            ctx->raddr = (hwaddr)-1ULL;\n\n            /* Software TLB search */\n\n            ret = ppc6xx_tlb_check(env, ctx, eaddr, rw, type);\n\n#if defined(DUMP_PAGE_TABLES)\n\n            if (qemu_loglevel_mask(CPU_LOG_MMU)) {\n\n                CPUState *cs = ENV_GET_CPU(env);\n\n                hwaddr curaddr;\n\n                uint32_t a0, a1, a2, a3;\n\n\n\n                qemu_log(\"Page table: \" TARGET_FMT_plx \" len \" TARGET_FMT_plx\n\n                         \"\\n\", env->htab_base, env->htab_mask + 0x80);\n\n                for (curaddr = env->htab_base;\n\n                     curaddr < (env->htab_base + env->htab_mask + 0x80);\n\n                     curaddr += 16) {\n\n                    a0 = ldl_phys(cs->as, curaddr);\n\n                    a1 = ldl_phys(cs->as, curaddr + 4);\n\n                    a2 = ldl_phys(cs->as, curaddr + 8);\n\n                    a3 = ldl_phys(cs->as, curaddr + 12);\n\n                    if (a0 != 0 || a1 != 0 || a2 != 0 || a3 != 0) {\n\n                        qemu_log(TARGET_FMT_plx \": %08x %08x %08x %08x\\n\",\n\n                                 curaddr, a0, a1, a2, a3);\n\n                    }\n\n                }\n\n            }\n\n#endif\n\n        } else {\n\n            qemu_log_mask(CPU_LOG_MMU, \"No access allowed\\n\");\n\n            ret = -3;\n\n        }\n\n    } else {\n\n        target_ulong sr;\n\n\n\n        qemu_log_mask(CPU_LOG_MMU, \"direct store...\\n\");\n\n        /* Direct-store segment : absolutely *BUGGY* for now */\n\n\n\n        /* Direct-store implies a 32-bit MMU.\n\n         * Check the Segment Register's bus unit ID (BUID).\n\n         */\n\n        sr = env->sr[eaddr >> 28];\n\n        if ((sr & 0x1FF00000) >> 20 == 0x07f) {\n\n            /* Memory-forced I/O controller interface access */\n\n            /* If T=1 and BUID=x'07F', the 601 performs a memory access\n\n             * to SR[28-31] LA[4-31], bypassing all protection mechanisms.\n\n             */\n\n            ctx->raddr = ((sr & 0xF) << 28) | (eaddr & 0x0FFFFFFF);\n\n            ctx->prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n            return 0;\n\n        }\n\n\n\n        switch (type) {\n\n        case ACCESS_INT:\n\n            /* Integer load/store : only access allowed */\n\n            break;\n\n        case ACCESS_CODE:\n\n            /* No code fetch is allowed in direct-store areas */\n\n            return -4;\n\n        case ACCESS_FLOAT:\n\n            /* Floating point load/store */\n\n            return -4;\n\n        case ACCESS_RES:\n\n            /* lwarx, ldarx or srwcx. */\n\n            return -4;\n\n        case ACCESS_CACHE:\n\n            /* dcba, dcbt, dcbtst, dcbf, dcbi, dcbst, dcbz, or icbi */\n\n            /* Should make the instruction do no-op.\n\n             * As it already do no-op, it's quite easy :-)\n\n             */\n\n            ctx->raddr = eaddr;\n\n            return 0;\n\n        case ACCESS_EXT:\n\n            /* eciwx or ecowx */\n\n            return -4;\n\n        default:\n\n            qemu_log_mask(CPU_LOG_MMU, \"ERROR: instruction should not need \"\n\n                          \"address translation\\n\");\n\n            return -4;\n\n        }\n\n        if ((rw == 1 || ctx->key != 1) && (rw == 0 || ctx->key != 0)) {\n\n            ctx->raddr = eaddr;\n\n            ret = 2;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 9215, "substitutes": {"env": ["ne", "server", "et", "np", "dict", "utils", "site", "cdn", "eng", "nc", "ea", "exc", "bc", "engine", "exec", "db", "en", "ini", "eu", "qt", "config", "ev", "enc", "console", "Environment", "scope", "qa", "settings", "net", "cal", "context", "end", "cfg", "cli", "viron", "cv", "client", "environment", "que", "gui", "inv", "her", "req", "cf", "conn", "esi", "dev", "conf", "e", "obj", "init", "ec", "fg", "eni", "uni", "manager", "txt", "inst", "dt"], "ctx": ["cas", "general", "utils", "hw", "scl", "fn", "prefix", "local", "xc", "nc", "exc", "connection", "bc", "wcs", "vc", "chan", "c", "conv", "sq", "ca", "cmp", "jp", "qt", "event", "rc", "config", "anon", "cb", "kb", "console", "ck", "sci", "loc", "pkg", "qa", "scope", "ssl", "cm", "cp", "ctrl", "grad", "context", "cfg", "cli", "act", "cc", "fp", "cv", "client", "cl", "cmd", "wp", "ci", "conn", "sc", "cf", "git", "sync", "conf", "tx", "obj", "fw", "cn", "sys", "qq", "lc", "exec", "acl"], "eaddr": ["egdr", "egder", "oadstr", "awhr", "effdu", "efDR", "eedstr", "eadder", "eeddr", "eadDr", "eddrr", "abbr", "edddr", "awDr", "egDr", "eedbr", "egDR", "avdr", "ecder", "oadder", "designdr", "ecstr", "efhr", "eadstr", "avder", "oaddr", "eadcur", "eddhr", "eldr", "eadrr", "efdr", "eedder", "avstr", "eadmot", "execcur", "designcur", "ecdr", "effder", "execmot", "designder", "designmot", "eedhr", "ecrr", "eadbr", "eadDR", "awDR", "eddstr", "effhr", "abdr", "abder", "eadhr", "eldu", "egstr", "elhr", "edddu", "effcur", "effmot", "egrr", "execdr", "efDr", "efder", "avbr", "awstr", "effdr", "awder", "abstr", "awdr", "execder", "oadhr", "eddder", "elder", "eaddu", "elDR"], "rw": ["usr", "hw", "wd", "rt", "nr", "src", "resp", "sw", "wk", "wx", "rg", "rack", "ru", "rc", "rss", "wr", "wn", "rf", "RW", "nw", "vr", "wl", "tw", "rb", "ww", "rx", "wp", "w", "nn", "wh", "rs", "rh", "rr", "wb"], "type": ["action", "like", "tp", "block", "size", "id", "format", "other", "ref", "state", "class", " typ", "y", "user", "method", "p", "Type", "shape", "year", "style", "test", "pt", "TYPE", "rule", "pre", "key", "code", "op", "parent", "t", "time", "kind", "attr", "rel", "error", "col", "ty", "unit", "port", "token", "null", "ype", "var", "name", " ty", "py", "typ", "types", "none", "role", "ping", "str"], "hash": ["tr", "version", "Hash", "block", "id", "format", "match", "ref", "rev", "handle", "tag", "addr", "user", "db", "search", "cache", "h", "auth", "str", "ha", "chip", "sh", "session", "total", "hh", "ash", "array", "key", "memory", "sha", "num", "header", "copy", "bin", "attr", "br", "mask", "index", "dev", "map", "height", "base", "msg", "rh", "alg", "name", "depth", "number", "kh", "sum"], "vsid": ["rskid", "lshide", "VSId", "lsinfo", "lsid", "lsId", "fsids", "vsname", "VSid", "dsinfo", "dskid", "fsid", "rsd", "psid", "vsmid", "dsname", "bsid", "vsinfo", "cskid", "csids", "fskid", "bsmid", " vskid", "wsname", "rsmid", "vsip", "bskid", "wsids", "dsip", "vsd", "lsend", " vsId", "vshide", "lsids", "lsip", "dsids", "vskid", "vsend", "wsinfo", "lsname", "csend", "VSkid", "fsip", "wsid", "rsid", "pskid", "psd", "vsId", "csid", "VShide", "bsd", " vsids", " vshide", "dsid", "vsids", "lskid", " vsend", "psmid"], "ds": ["os", "eps", "dds", "sd", "pg", "dp", "vals", "ls", "ss", "sql", "ys", "xs", "db", "ks", "d", "sv", "dr", "auth", "dy", "des", "der", "DS", "sid", "sts", "bs", "ns", "di", "hs", "dc", "dd", "std", "ps", "da", "Ds", "sync", "dim", "dev", "cr", "gs", "conn", "virt", "dh", "tx", "sys", "rs", "sk", "s", "dl", "data", "dt", "vs", "ops", "str"], "pr": ["tr", "pos", "fr", "pg", "nr", "pm", "pro", "hr", "ptr", "pl", "rev", "mr", "jp", "sv", "dr", "rss", "p", "lr", "per", "spr", "wr", "sp", "pi", "pir", "vr", "pt", "pre", "po", "sl", "rx", "r", "br", "rel", "ps", "kr", "attr", "cr", "sn", "pa", "Pr", "rs", "rr", "PR", "pol", "pid", "por"], "target_page_bits": ["target_page64mins", "target_page_details", "target_page_mins", "target_Page_bits", "target_pageallbits", "target_page_bytes", "target_pageallparts", "target_pg_locks", "target_pg_parts", "target_pg_bytes", "target_Page_mins", "target_page_locks", "target_page64bytes", "target_page_points", "target_page_flags", "target_pagealllocks", "target_Page_bytes", "target_page64bits", "target_page_parts", "target_page64flags", "target_pg_points", "target_pg_details", "target_Page_flags", "target_pageallpoints", "target_pg_bits"], "ret": ["rets", "match", "resp", "RET", "ref", "rev", "ft", "result", "seq", "len", "ben", " Ret", " RET", "cat", "arr", "lit", "fun", "total", "bit", "mt", "gt", "num", "val", "all", "det", "get", "arg", "last", "nt", "res", "reg", "fin", "alt", "Ret", "data", "feat"], "sr": ["tr", "sur", "ctr", "usr", "fr", "mir", "rt", "nr", "src", "hr", "sw", "radius", "sf", "serv", "ra", "rg", "sv", "sb", "dr", "ser", "rss", "lr", "ru", "spr", "rd", "rl", "rf", "ssl", "vr", "rb", "yr", "sl", "cv", "rx", "r", "br", "kr", "ir", "cr", "RR", "rin", "gr", "SR", "er", "rs", "rr", "rar", "rh"], "pgidx": ["pgidX", " pgidz", "pgaidc", "gIdX", "pgpidb", "pgridx", "pgIdx", "pgidb", "pgidsX", "pgIdct", "pgnameex", "pgIdX", "pgidv", "pgnamex", " pgidX", "gIdz", "pgridex", "pgidxes", " pgIdx", "pgIdb", "pgIdz", " pgIdxes", "pgIdc", "pgridct", "pgaidx", " pgIdX", "gidx", "pgidex", "gidc", "gidct", " pgidxes", "pgidct", "pgnameX", "gIdc", "pgpidv", "gidex", " pgpidX", " pgIdz", " pgpidv", " pgidb", "pgaidv", "pgidsx", "pgidc", "pgpidX", "gidz", "pgaidX", "pgnamect", "pgIdex", "gIdex", "pgaidb", "pgaidz", "pgidsxes", "pgIdxes", "pgidsz", "gIdx", "pgridX", " pgidv", "pgpidx", "gIdct", "pgidz", " pgpidx", " pgpidb", "gidX", "pgIdv"]}}
{"project": "qemu", "commit_id": "df3c286c53ac51e7267f2761c7a0c62e11b6e815", "target": 0, "func": "static void slirp_socket_save(QEMUFile *f, struct socket *so)\n\n{\n\n    qemu_put_be32(f, so->so_urgc);\n\n    qemu_put_be16(f, so->so_ffamily);\n\n    switch (so->so_ffamily) {\n\n    case AF_INET:\n\n        qemu_put_be32(f, so->so_faddr.s_addr);\n\n        qemu_put_be16(f, so->so_fport);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to save so_faddr and so_fport\\n\");\n\n    }\n\n    qemu_put_be16(f, so->so_lfamily);\n\n    switch (so->so_lfamily) {\n\n    case AF_INET:\n\n        qemu_put_be32(f, so->so_laddr.s_addr);\n\n        qemu_put_be16(f, so->so_lport);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to save so_laddr and so_lport\\n\");\n\n    }\n\n    qemu_put_byte(f, so->so_iptos);\n\n    qemu_put_byte(f, so->so_emu);\n\n    qemu_put_byte(f, so->so_type);\n\n    qemu_put_be32(f, so->so_state);\n\n    slirp_sbuf_save(f, &so->so_rcv);\n\n    slirp_sbuf_save(f, &so->so_snd);\n\n    slirp_tcp_save(f, so->so_tcpcb);\n\n}\n", "idx": 9225, "substitutes": {"f": ["F", "fen", "g", "fr", "fn", "tf", "xf", "file", "k", "ff", "self", "sf", "fi", "inf", "fore", "c", "i", "fe", "d", "p", "rf", "b", "fm", "fb", "fs", "fun", "full", "j", "fac", "feed", "fa", "fp", "v", "fc", "t", "df", "af", "o", "uf", "l", "cf", "def", "fo", "fx", "u", "form", "q", "w", "m", "conf", "func", "e", "fw", "info", "fed", "s", "fd", "of", "bf", "lf"], "so": ["ne", "oa", "ico", "os", "to", "de", "la", "iso", "no", "vo", "pro", "sm", "oco", "sf", "plus", "flo", "ski", "za", "ce", "ou", "osa", "ki", "shi", "i", "co", "lo", "ri", "p", "bo", "osi", "si", "sp", "sh", "zo", "isi", "le", "ku", "tw", "ie", "ho", "se", "sl", "ko", "from", "po", "go", "cli", "So", "coe", "oso", "o", "oto", "fo", "SO", "sync", "u", "oe", "te", "mo", "tto", "e", "olo", "this", "ge", "su", "ao", "sk", "sa", "thro", "ve", "kee"]}}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "void object_property_allow_set_link(Object *obj, const char *name,\n\n                                    Object *val, Error **errp)\n\n{\n\n    /* Allow the link to be set, always */\n\n}\n", "idx": 9231, "substitutes": {"obj": ["prefix", "ctx", "type", "id", "ref", "class", "Obj", "module", "node", "mod", "cb", "arr", "objects", "po", "code", "o", "rel", "attr", "opt", "otype", "func", "data", "ob", "js", "inst", "object"], "name": ["prefix", "fn", "block", "no", "type", "on", "id", "comment", "NAME", "path", "ref", "Name", "self", "class", "names", "end", "part", "key", "parent", "rel", "def", "old", "func", "n", "child", "value", "alias", "named"], "val": ["prop", "live", "valid", "vals", " value", "ref", "sel", "Obj", "eval", "Val", "doc", "VAL", "key", "v", "el", "ret", "rel", "def", "old", "func", "Value", "base", "value", "var", "data", "exec"], "errp": [" errP", "rrp", "rrP", "erp", "rrr", " errr", "erP", "err", "errP", "errr"]}}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)\n\n{\n\n    int i;\n\n    float (*output)[256] = ctx->audio_block.block_output;\n\n\n\n    for (i = 0; i < 256; i++)\n\n        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);\n\n    memset(output[2], 0, sizeof(output[2]));\n\n    memset(output[3], 0, sizeof(output[3]));\n\n    memset(output[4], 0, sizeof(output[4]));\n\n}\n", "idx": 9238, "substitutes": {"ctx": ["cas", "text", "src", "Context", "anc", "cs", "bc", "ce", "c", "conv", "pc", "ca", "cmp", "config", "rc", "cpp", "kb", "ck", "loc", "cm", "cp", "ctrl", "context", "cc", "fp", "cv", "cms", "ci", "sc", "conn", "cf", "cam", "component", "conf", "tx", "cn", "tc", "mc", "lc", "cca", "exec"], "i": ["ii", "ni", "li", "uri", "hi", "code", "f", "type", "id", "I", "k", "mu", "oi", "y", "c", "yi", "iu", "a", "ini", "d", "multi", "h", "ji", "p", "slice", "si", "b", "pi", "io", "j", "gi", "ie", "di", "v", "zi", "xi", "bi", "ti", "qi", "length", "ui", "t", "o", "l", "ci", "u", "index", "m", "e", "n", "info", "ai", "count", "x", "it"], "output": ["byte", "option", "write", "draw", "display", "model", "response", "console", "queue", "memory", "address", "summary", "oper", "resource", "word", "page", "hidden", "target", "fn", "size", "update", "result", "external", "module", "eff", "application", "after", "operation", "average", "code", "sort", "region", "out", "video", "block", "Output", "event", "config", "document", "content", "layer", "source", "complete", "generated", "forward", "current", "value", "null", "number", "put", "version", "flow", "function", "software", "input", "written", "full", "position", "core", "image", "filter", "four", "control", "reference", "unit", "grade", "data", "object"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(nv21ToUV)(uint8_t *dstU, uint8_t *dstV,\n\n                                    const uint8_t *src1, const uint8_t *src2,\n\n                                    long width, uint32_t *unused)\n\n{\n\n    RENAME(nvXXtoUV)(dstV, dstU, src1, width);\n\n}\n", "idx": 9246, "substitutes": {"dstU": ["dstUV", "DSTU", "DstV", "dscUV", "DestU", "dscU", "destUV", "DSTV", "dostV", "drcU", "dSTUV", "drcV", "DstP", "dscP", "drcUV", "dstP", "dSTP", "destV", "dostP", "DstUV", "destP", "DestV", "DSTP", "dSTU", "dostUV", "dscV", "dostU", "dSTV", "DestUV", "drcP", "DSTUV", "DestP", "DstU", "destU"], "dstV": ["dsrcUV", "dstUV", "ddrW", "dconstUV", "DSTU", "DstV", "ddrUV", "DSTV", "dsrcI", "ddrV", "dSTW", "dconstU", "ddrU", "dSTUV", "adstU", "adSTW", "adstV", "adstUV", "dstW", "dconstV", "drdI", "dconstW", "dsrcV", "adSTV", "DSTI", "DstUV", "adSTU", "dstI", "dSTI", "dSTU", "drdU", "drdUV", "dSTV", "dsrcU", "drdV", "DSTUV", "DstU", "adstW", "DstI", "adSTUV"], "src1": [" src01", "reflect1", " src7", "rib0", "rc01", "reflect7", "rib2", "reflect0", "src7", "reflect2", "rc1", "rc0", "src01", "src0", "rc7", "rib01", "rib1", "rc2", " src0"], "src2": ["rc3", "src3", "src4", "dest4", "dest3", "rc2", "dest1", "rc4", "rc1", " src3", " src4", "dest2"], "unused": ["unsprotected", "unalinitialized", "uncprotected", "unalwritten", "unwritten", "uncinitialized", "unalprotected", "unsinitialized", "unswritten", "unalused", "unprotected", "uncwritten", "unsused", "uninitialized", "uncused"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t lan9118_readl(void *opaque, target_phys_addr_t offset,\n\n                              unsigned size)\n\n{\n\n    lan9118_state *s = (lan9118_state *)opaque;\n\n\n\n    //DPRINTF(\"Read reg 0x%02x\\n\", (int)offset);\n\n    if (offset < 0x20) {\n\n        /* RX FIFO */\n\n        return rx_fifo_pop(s);\n\n    }\n\n    switch (offset) {\n\n    case 0x40:\n\n        return rx_status_fifo_pop(s);\n\n    case 0x44:\n\n        return s->rx_status_fifo[s->tx_status_fifo_head];\n\n    case 0x48:\n\n        return tx_status_fifo_pop(s);\n\n    case 0x4c:\n\n        return s->tx_status_fifo[s->tx_status_fifo_head];\n\n    case CSR_ID_REV:\n\n        return 0x01180001;\n\n    case CSR_IRQ_CFG:\n\n        return s->irq_cfg;\n\n    case CSR_INT_STS:\n\n        return s->int_sts;\n\n    case CSR_INT_EN:\n\n        return s->int_en;\n\n    case CSR_BYTE_TEST:\n\n        return 0x87654321;\n\n    case CSR_FIFO_INT:\n\n        return s->fifo_int;\n\n    case CSR_RX_CFG:\n\n        return s->rx_cfg;\n\n    case CSR_TX_CFG:\n\n        return s->tx_cfg;\n\n    case CSR_HW_CFG:\n\n        return s->hw_cfg;\n\n    case CSR_RX_DP_CTRL:\n\n        return 0;\n\n    case CSR_RX_FIFO_INF:\n\n        return (s->rx_status_fifo_used << 16) | (s->rx_fifo_used << 2);\n\n    case CSR_TX_FIFO_INF:\n\n        return (s->tx_status_fifo_used << 16)\n\n               | (s->tx_fifo_size - s->txp->fifo_used);\n\n    case CSR_PMT_CTRL:\n\n        return s->pmt_ctrl;\n\n    case CSR_GPIO_CFG:\n\n        return s->gpio_cfg;\n\n    case CSR_GPT_CFG:\n\n        return s->gpt_cfg;\n\n    case CSR_GPT_CNT:\n\n        return ptimer_get_count(s->timer);\n\n    case CSR_WORD_SWAP:\n\n        return s->word_swap;\n\n    case CSR_FREE_RUN:\n\n        return (qemu_get_clock_ns(vm_clock) / 40) - s->free_timer_start;\n\n    case CSR_RX_DROP:\n\n        /* TODO: Implement dropped frames counter.  */\n\n        return 0;\n\n    case CSR_MAC_CSR_CMD:\n\n        return s->mac_cmd;\n\n    case CSR_MAC_CSR_DATA:\n\n        return s->mac_data;\n\n    case CSR_AFC_CFG:\n\n        return s->afc_cfg;\n\n    case CSR_E2P_CMD:\n\n        return s->e2p_cmd;\n\n    case CSR_E2P_DATA:\n\n        return s->e2p_data;\n\n    }\n\n    hw_error(\"lan9118_read: Bad reg 0x%x\\n\", (int)offset);\n\n    return 0;\n\n}\n", "idx": 9255, "substitutes": {"opaque": ["obaque", "opacity", "operatile", " opsa", " opac", "ipacity", "obacity", " opacity", "opac", "ipaque", "obac", " opatile", "ipaques", "opaques", "obsa", "ipatile", "opsa", "operaques", "operaque", " opaques", "operacity", "opersa", "opatile", "operac"], "offset": ["padding", "shift", "pos", "timeout", "axis", "empty", "pointer", "type", "args", "format", "aligned", "buf", "ip", "skip", "addr", "seq", "len", "i", "afi", "off", "bytes", "p", "reset", "slot", "seed", "operation", "range", "bit", "position", "Offset", "sector", "address", "fp", "parent", "phase", "length", "alloc", "o", "initial", "start", "index", "buffer", "pad", "delay", "base", "origin", "set", "null", "data", "number", "location", "align", "slice"], "size": ["flags", "padding", "SIZE", " flags", " bytes", " error", " length", " offsets", "len", "a", " padding", " unused", "bytes", "ize", " sizes", "Size", " address", "length", "o", " data", "e", "data", "ops"], "s": ["server", "sym", "ctx", "src", "service", "cs", "self", "ments", "c", "a", "ks", "i", "d", "ings", "ims", "settings", "b", "outs", "erences", "address", "hs", "sites", "gs", "e", "comments", "rs", "or", "status", "js", "ists", "sum", "os", "site", "its", "ls", "ss", "ers", "ies", "sq", "ins", "sb", "rows", "S", "scope", "session", "ds", "fs", "ssl", "ows", "o", "ses", "qs", "er", "set", "ports", "tests", "als", "f", "ing", "parts", "sf", "xs", "an", "services", "sg", "ips", "socket", "secondary", "sl", "ches", "in", "ions", "r", "complete", "ps", "l", "sync", "u", "south", "sys", "g", "request", "local", "side", "states", "is", "small", "new", "es", "p", "ts", "ed", "temp", "si", "results", "ns", "spec", "t", "ools", "your", "plugins", "m", "conf", "sets", "this", "storage", "stats", "seconds", "aws"]}}
{"project": "FFmpeg", "commit_id": "c94d551ea7b39c4e467e146cd347c407e8eb38ee", "target": 0, "func": "static int read_low_coeffs(AVCodecContext *avctx, int16_t *dst, int size, int width, ptrdiff_t stride)\n\n{\n\n    PixletContext *ctx = avctx->priv_data;\n\n    GetBitContext *b = &ctx->gbit;\n\n    unsigned cnt1, nbits, k, j = 0, i = 0;\n\n    int64_t value, state = 3;\n\n    int rlen, escape, flag = 0;\n\n\n\n    while (i < size) {\n\n        nbits = FFMIN(ff_clz((state >> 8) + 3) ^ 0x1F, 14);\n\n\n\n        cnt1 = get_unary(b, 0, 8);\n\n        if (cnt1 < 8) {\n\n            value = show_bits(b, nbits);\n\n            if (value <= 1) {\n\n                skip_bits(b, nbits - 1);\n\n                escape = ((1 << nbits) - 1) * cnt1;\n\n            } else {\n\n                skip_bits(b, nbits);\n\n                escape = value + ((1 << nbits) - 1) * cnt1 - 1;\n\n            }\n\n        } else {\n\n            escape = get_bits(b, 16);\n\n        }\n\n\n\n        value = -((escape + flag) & 1) | 1;\n\n        dst[j++] = value * ((escape + flag + 1) >> 1);\n\n        i++;\n\n        if (j == width) {\n\n            j = 0;\n\n            dst += stride;\n\n        }\n\n        state = 120 * (escape + flag) + state - (120 * state >> 8);\n\n        flag = 0;\n\n\n\n        if (state * 4 > 0xFF || i >= size)\n\n            continue;\n\n\n\n        nbits = ((state + 8) >> 5) + (state ? ff_clz(state) : 32) - 24;\n\n        escape = av_mod_uintp2(16383, nbits);\n\n        cnt1 = get_unary(b, 0, 8);\n\n        if (cnt1 > 7) {\n\n            rlen = get_bits(b, 16);\n\n        } else {\n\n            value = show_bits(b, nbits);\n\n            if (value > 1) {\n\n                skip_bits(b, nbits);\n\n                rlen = value + escape * cnt1 - 1;\n\n            } else {\n\n                skip_bits(b, nbits - 1);\n\n                rlen = escape * cnt1;\n\n            }\n\n        }\n\n\n\n        if (i + rlen > size)\n\n            return AVERROR_INVALIDDATA;\n\n        i += rlen;\n\n\n\n        for (k = 0; k < rlen; k++) {\n\n            dst[j++] = 0;\n\n            if (j == width) {\n\n                j = 0;\n\n                dst += stride;\n\n            }\n\n        }\n\n\n\n        state = 0;\n\n        flag = rlen < 0xFFFF ? 1 : 0;\n\n    }\n\n\n\n    align_get_bits(b);\n\n    return get_bits_count(b) >> 3;\n\n}\n", "idx": 9258, "substitutes": {"avctx": ["avcontext", " avxc", "AVctx", "AVcca", "Avctx", "AVxc", "ajcontext", "Avcoll", "AVcoll", "ajcoll", "Avxc", "AVbc", "avbc", "Avbc", "ajbc", " avcontext", "Avcontext", "avcoll", "ajctx", " avcca", "avcca", "avxc", "AVcontext", "Avcca"], "dst": ["defput", "dnst", " dST", "defst", "Dst", "ssts", "dedstream", "dedst", "Dbl", "dptr", "ndbl", "dedsts", "dnstream", "sst", "adst", "adsts", " dput", "Dsts", "dnptr", " dsts", "defST", "ndsts", "dedptr", "sST", "adstream", "dput", "adptr", "dnsts", "dST", "dbl", "dsts", "dstream", " dbl", "DST", "sput", "ndst", "ndST", "defsts"], "size": ["g", "sized", "SIZE", "len", "en", "small", "si", "loc", "shape", "core", "scale", "address", "ize", "z", "Size", "code", "length", "ci", "ffff", "six", "s", "sec", "name"], "stride": ["stid", "strides", "STRid", " strine", " strides", "STRine", "strine", "dride", " strid", "stides", "STRide", "brange", "drange", "hride", "stide", "drides", "hrIDE", "brIDE", "brides", "stine", "strid", "hrides", "STRides", "strIDE", "drIDE", "strange", "bride", "hrange"], "ctx": ["cas", "utils", "hw", "xc", "anc", "ref", "bc", "c", "pc", "ca", "cmp", "rc", "cb", "kb", "p", "loc", "pkg", "cm", "cp", "ct", "ctrl", "context", " context", "cc", "cv", "dc", "cl", "cf", "conn", "ci", "sc", "buff", "cam", "conf", "tx", "obj", "pa", "lc", "cca"], "b": ["g", "fr", "f", "bis", "comp", "nb", "bc", "pb", "c", "db", "a", "lb", "eb", "d", "usb", "sb", "bl", "bar", "p", "ib", "cb", "http", "boot", "fb", "orb", "bh", "bt", "gb", "rb", "bd", "bs", "B", "v", "machine", "ch", "bi", "bb", "o", "br", "xb", "bin", "abb", "l", "lib", "ab", "w", "m", "body", "buffer", "func", "emb", "base", "e", "obj", "ob", "be", "wb", "bf", "ba"], "cnt1": ["pcntn", "cntFirst", "centN", "acntOne", "centX", "crt2", "CntX", "cNT5", "cct11", "cannot1", "CNTOnce", "centOne", "cNTOne", " cct1", "CntN", "CNTOne", "cct2", "Cnt5", "cct3", "cntOnce", "cctOnce", "CNTX", "cctn", "acntn", "count3", "cct1", " cct2", "contn", "acntOnce", "Cnt1", " cnt2", "crt1", "acrt1", "CrtOne", "centOnce", "cnt5", "cont31", "cannotOnce", "cNT1", "cntX", "cent1", "contOnce", "Crt2", "s", "CntOnce", "cNTn", "cotFirst", "count11", "cctN", "cont1", "acnt1", "CNTN", "cent2", "cntn", "cNTFirst", "CNT1", "pcctn", "pcct1", "cctOne", "cnt2", " cnt11", "count2", "r", "cent5", "acrtn", "pcntOne", "_", "Cnt31", "pcctOne", "cannot5", "cotOne", "Crt31", "g", "countn", "CntFirst", "cot1", "cNT2", "cannot2", "cct5", "cctX", "crtOnce", "counter3", "crtn", "CNT5", " cct3", "Crt1", "CNTFirst", "crt31", "cNTN", "pcnt1", "Cnt2", "contOne", "countOne", "crtFirst", "CNT2", "count1", "cnt3", "cNTX", "cnt31", "counter11", "cct31", "cntN", "cnt11", "cNTOnce", "cont2", "crtOne", " cnt3", "counter1", "counter2", "cntOne", " cct11", "CntOne", "acrtOnce", "acrtOne"], "nbits": ["ynkeys", "unnbits", "npoints", "Npieces", "cbytes", "numframes", "jits", "cbit", "unlines", "jbytes", "onlocks", "mnpoints", "numparts", "numlines", " nbugs", " nframes", " nbytes", "mnboot", "nboot", "unnfits", "nparts", "nbugs", "onplanes", "Nbytes", "nkeys", " nhours", "nfits", "Nfits", " npieces", "Nits", " nits", "unkeys", "nbands", "Nhours", "ynints", "infeatures", "jbits", "Nbits", "cbits", "Nparts", " nbands", "unnparts", "Nlines", "nbytes", "nlines", " nints", "numbits", "ynbytes", "nfeatures", "ynfeatures", "jbit", "netblocks", "Nints", "netlines", "ynboot", "unpoints", "ynparts", "numbugs", " nfeatures", "ynbits", "unnits", "Nfeatures", "numbit", "onbits", "nbit", "numints", "Nlocks", "units", " nlines", "onhours", "unboot", "inpieces", "netits", " nplanes", "numbands", " nblocks", "numbytes", "numits", "inparts", "nlocks", "unblocks", "netbits", "nplanes", "jints", "mnkeys", "nhours", "jfeatures", " nbit", " nlocks", "inbits", "nframes", "unbugs", "ynbands", "nints", "nits", "numplanes", "Nbit", "Nplanes", "ynpoints", "nblocks", " nfits", "npieces", "jlines", "mnbits", "jframes", "unbits", " nparts", "jlocks"], "k": ["g", "f", "id", "K", "y", "ki", "d", "p", "loss", "qa", "kw", "end", "ie", "key", "z", "v", "code", "row", "o", "r", "mask", "q", "w", "e", "n", "cost", "it"], "value": ["gap", "message", "character", "comment", "va", "max", "serial", "fee", "open", "key", "native", "wave", "area", "w", "job", "random", "child", "slave", "ba", "ract", "attribute", "view", "update", "ault", "ha", "range", "end", "parent", "num", "length", "ava", "wa", "delay", "reg", "one", "shift", "valid", "block", "format", "buf", "values", "now", "event", "content", "total", "gi", "scale", "array", "v", "expression", "complete", "start", "index", "map", "current", "large", "null", "name", "number", "always", "cost", "VALUE", "version", "kill", "type", "we", "flow", "state", "media", "function", "offset", "p", "style", "partial", "iv", "image", "entry", "val", "dev", "buffer", "Value", "unit", "variable", "volume", "element", "data", "python"], "rlen": ["nrli", " rbl", "rbl", "rln", "hlin", "dLen", "flen", "drel", " rLen", "nrlen", "nrbl", " rln", "dlength", "rrel", "rli", "rrbl", "fden", "rlength", "arden", "rdl", "hlen", "irlen", "nrLen", "irLen", "arln", "krLen", "fln", "rrlen", "rlin", "rden", "arlen", "drln", " rli", " rrel", "flin", "hden", "rLen", " rlength", "dlen", "drlen", "rrLen", "drLen", " rdl", "rrli", "hln", "krlength", "krrel", "drdl", "arlin", "irdl", "krlen", "irln"], "escape": ["la", "character", "cape", "comment", "ea", "alpha", "write", "guard", "adjust", "open", "address", "CAP", "cookie", "speed", "e", "child", "secure", "ec", "slave", "alias", "layout", "attribute", "view", "update", "sq", "close", "eval", "ace", "archive", "shape", "wrap", "charge", "code", "length", "error", "attr", "effect", "race", "strip", "delay", "script", "exec", "shift", "wait", "event", "scape", "expr", "qa", "scale", "expression", "ee", "complete", "command", "reason", "parse", "match", "quote", "ride", "ce", "esc", "offset", "style", "shell", "rule", "access", "entry", "control", "buffer", "safe", "variable", "element", "rage", "slice"], "i": ["ii", "ni", "li", "uri", "f", "id", "phi", "I", "mi", "fi", "y", "c", "ki", "iu", "ini", "d", "ji", "p", "ri", "slice", "si", "pi", "io", "j", "gi", "z", "v", "ti", "bi", "di", "xi", "qi", "o", "ui", "ind", "l", "ci", "index", "m", "e", "n", "info", "ai", "mini", "x", "ix", "it"]}}
{"project": "qemu", "commit_id": "fc19f8a02e45c4d8ad24dd7eb374330b03dfc28e", "target": 0, "func": "static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov,\n\n                          int offset)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n\n\n    request.type = NBD_CMD_READ;\n\n    request.from = sector_num * 512;\n\n    request.len = nb_sectors * 512;\n\n\n\n    nbd_coroutine_start(s, &request);\n\n    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {\n\n        reply.error = errno;\n\n    } else {\n\n        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);\n\n    }\n\n    nbd_coroutine_end(s, &request);\n\n    return -reply.error;\n\n\n\n}\n", "idx": 9260, "substitutes": {"bs": ["bos", "os", "bis", "cs", "ls", "ss", "bc", "BS", "pb", "db", "ins", "sb", "bl", "nas", "iss", "ds", "b", "bes", "fs", "fb", "blocks", "bh", "gb", "ns", "bi", "ses", "ab", "base", "las", "ob", "bits", "bas", "lbs", "sa", "js", "bid", "vs"], "sector_num": ["section_no", " sector_name", "sector6count", "section_count", "sector2name", "section_number", "sector2number", " sector_number", "sector_count", "sector6no", "sector_number", "sector2no", " sector_no", "sector6number", "sector2num", "section_num", "sector6num", "sector_name", "sector_no"], "nb_sectors": ["nb_gections", "nb_gectors", "nb_gellers", "nb_secctors", "nb_vegments", "nb_secctor", "nb_vellers", "nb_vecs", "nb_seccs", "nb_sector", "nb_kegments", "nb_vector", "nb_gegments", "nb_segments", "nb_kectors", "nb_vections", "nb_secs", "nb_secgments", "nb_sellers", "nb_kellers", "nb_vectors", "nb_sections", "nb_kections"], "qiov": [" qliv", "zliv", "sqodi", " qilib", "qiev", "quliv", "quilib", "zoyer", "qilib", "qliv", "Qoyer", "ziev", "qoyer", " qiev", " qodi", "Qiev", "quiov", "Qliv", " qoyer", "sqliv", "qodi", "quodi", "ziov", "Qiov", "sqilib", "sqiov"], "offset": ["padding", "server", "pos", "timeout", "shift", "prefix", "size", "type", "pointer", "online", "ref", "addr", "len", "i", "off", "slot", "reset", "seek", "range", "position", "Offset", "array", "address", "fp", "from", "phase", "length", "o", "error", "start", "index", "reference", "inet", "set", "null", "optional", "number", "location", "align"], "s": ["g", "os", "sym", "f", "bis", "src", "service", "state", "ss", "states", "private", "c", "sq", "stat", "is", "i", "sup", "an", "d", "sb", "h", "p", "si", "http", "S", "ds", "session", "b", "sie", "ssl", "socket", "secondary", "sl", "ns", "spec", "us", "o", "t", "ses", "ops", "sync", "u", "gs", "south", "e", "n", "sys", "su", "storage", "js", "status", "stats", "spot"], "request": ["server", "message", "type", "id", "re", "xml", "Request", "have", "result", "user", "transfer", "route", "event", "config", "quest", "response", "input", "create", "order", "rf", "error", "session", "hello", "use", "work", "queue", "worker", "frame", "pair", "friend", "address", "record", "parent", "push", "client", "rx", "insert", "complete", "resource", "req", "read", "call", "q", "demand", "get", "command", "next", "ry", "allow", "buffer", "reference", "query", "base", "report", "QUEST", "child", "er", "name", "repeat", "send", "object", "post"], "reply": ["server", "relation", "parse", "prefix", "maybe", "notice", "flash", "match", "respond", "resp", "re", "comment", "service", "callback", "repl", "ignore", "route", "transfer", " response", "write", "sup", "lex", "back", "response", "order", "queue", "replace", "Reply", "related", "address", "entry", "ret", "link", "apply", "answer", "sync", "proxy", "ry", "buffer", "query", "echo", "report", "sys", "reason", "base", "rr", "ping", "send", "bot", "repair", "read", "post"]}}
{"project": "FFmpeg", "commit_id": "dd5d61795690e339ae271692e7ab9df66b5eb153", "target": 0, "func": "static int request_frame(AVFilterLink *link)\n\n{\n\n    AVFilterContext *ctx = link->src;\n\n    IDETContext *idet = ctx->priv;\n\n\n\n    do {\n\n        int ret;\n\n\n\n        if (idet->eof)\n\n            return AVERROR_EOF;\n\n\n\n        ret = ff_request_frame(link->src->inputs[0]);\n\n\n\n        if (ret == AVERROR_EOF && idet->cur) {\n\n            AVFrame *next = av_frame_clone(idet->next);\n\n\n\n            if (!next)\n\n                return AVERROR(ENOMEM);\n\n\n\n            filter_frame(link->src->inputs[0], next);\n\n            idet->eof = 1;\n\n        } else if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } while (!idet->cur);\n\n\n\n    return 0;\n\n}\n", "idx": 9282, "substitutes": {"link": ["plugin", "li", "parse", "block", "ack", "kick", "ink", "path", "comment", "ref", "service", "local", "tag", "sel", "cmp", "co", "pack", "lex", "ace", "hip", "ck", "http", "loc", "cell", "linked", "load", "frame", "url", "ld", "style", "feed", "friend", "lang", "l", "call", "conn", "ci", "sync", "links", "lock", "post", "base", "join", "info", "Link", "lc", "pull", "bug", "lf", "light", "slice", "line"], "ctx": ["cas", "container", "hw", "src", "ref", "cs", "self", "bc", "vc", "c", "pc", "ca", "instance", "config", "rc", "cb", "ck", "loc", "pkg", "cp", "cm", "ct", "ctrl", "context", "cc", "fc", "cv", "cmd", "ci", "cf", "conn", "sc", "conf", "tx", "tc", "cn", "mc", "lc", "cca", "exec", "cache"], "idet": ["idety", "hdet", "Idetic", "iden", "aidot", "sdoint", "idot", "ipen", "intpt", "Idot", "dset", "intetic", "intot", "ipot", "idspt", " idetic", "idset", "idsen", "Idel", "idest", " idel", "aidset", "id\u00e9t", "aidET", "hdart", "idsot", "sd\u00e9t", " idET", " ideting", "Idoint", "dET", "ideting", "ipet", "hdoint", "idetic", "sdet", "ipeting", " idest", "dpt", "Id\u00e9t", "idseting", " idset", "indot", "indet", "Idart", "intet", "hd\u00e9t", "aidetic", " idpt", "aidest", " idot", "idET", "aidet", "indel", "det", " iden", "idsetic", "Idety", "idart", "Idet", " idety", "Idest", "sdart", "idel", "idpt", "aidpt", "indety", "idoint"], "ret": ["rt", "rets", "pub", "match", "att", "resp", "re", "RET", "id", "ref", "rev", "ft", "result", "success", "len", "art", "sr", " Ret", " RET", "cat", "rc", "fun", "lit", "flag", "bit", "ext", "mt", "part", "code", "gt", "active", "num", "fail", "error", "val", "det", "pet", "def", "bad", "arg", "reply", "pat", "value", "res", "nt", "reg", "alt", "Ret", "data", "feat", "str"], "next": ["big", "shift", "li", "first", "future", "latest", "chain", "flow", "other", "self", "now", "prev", "rev", "front", "result", "success", "low", "seq", "second", "own", "new", "cur", "primary", "again", "fb", "frame", "foo", "open", "more", "end", "missing", "ng", "code", "tmp", "parent", "later", "dot", "conn", "start", "head", " Next", "forward", "job", "last", "current", "follow", "reply", "desc", "child", "obj", "this", "nt", "ec", "sec", "name", "page", "Next", "business", "data", "target"]}}
{"project": "FFmpeg", "commit_id": "a2085a7e9d83d99aca58bfb385f6db1afa5673dd", "target": 1, "func": "static int dpcm_decode_frame(AVCodecContext *avctx,\n                             void *data, int *data_size,\n                             uint8_t *buf, int buf_size)\n{\n    DPCMContext *s = avctx->priv_data;\n    int in, out = 0;\n    int predictor[2];\n    int channel_number = 0;\n    short *output_samples = data;\n    int shift[2];\n    unsigned char byte;\n    short diff;\n    if (!buf_size)\n        return 0;\n    switch(avctx->codec->id) {\n    case CODEC_ID_ROQ_DPCM:\n        if (s->channels == 1)\n            predictor[0] = AV_RL16(&buf[6]);\n        else {\n            predictor[0] = buf[7] << 8;\n            predictor[1] = buf[6] << 8;\n        }\n        SE_16BIT(predictor[0]);\n        SE_16BIT(predictor[1]);\n        /* decode the samples */\n        for (in = 8, out = 0; in < buf_size; in++, out++) {\n            predictor[channel_number] += s->roq_square_array[buf[in]];\n            predictor[channel_number] = av_clip_int16(predictor[channel_number]);\n            output_samples[out] = predictor[channel_number];\n            /* toggle channel */\n            channel_number ^= s->channels - 1;\n        }\n        break;\n    case CODEC_ID_INTERPLAY_DPCM:\n        in = 6;  /* skip over the stream mask and stream length */\n        predictor[0] = AV_RL16(&buf[in]);\n        in += 2;\n        SE_16BIT(predictor[0])\n        output_samples[out++] = predictor[0];\n        if (s->channels == 2) {\n            predictor[1] = AV_RL16(&buf[in]);\n            in += 2;\n            SE_16BIT(predictor[1])\n            output_samples[out++] = predictor[1];\n        }\n        while (in < buf_size) {\n            predictor[channel_number] += interplay_delta_table[buf[in++]];\n            predictor[channel_number] = av_clip_int16(predictor[channel_number]);\n            output_samples[out++] = predictor[channel_number];\n            /* toggle channel */\n            channel_number ^= s->channels - 1;\n        }\n        break;\n    case CODEC_ID_XAN_DPCM:\n        in = 0;\n        shift[0] = shift[1] = 4;\n        predictor[0] = AV_RL16(&buf[in]);\n        in += 2;\n        SE_16BIT(predictor[0]);\n        if (s->channels == 2) {\n            predictor[1] = AV_RL16(&buf[in]);\n            in += 2;\n            SE_16BIT(predictor[1]);\n        }\n        while (in < buf_size) {\n            byte = buf[in++];\n            diff = (byte & 0xFC) << 8;\n            if ((byte & 0x03) == 3)\n                shift[channel_number]++;\n            else\n                shift[channel_number] -= (2 * (byte & 3));\n            /* saturate the shifter to a lower limit of 0 */\n            if (shift[channel_number] < 0)\n                shift[channel_number] = 0;\n            diff >>= shift[channel_number];\n            predictor[channel_number] += diff;\n            predictor[channel_number] = av_clip_int16(predictor[channel_number]);\n            output_samples[out++] = predictor[channel_number];\n            /* toggle channel */\n            channel_number ^= s->channels - 1;\n        }\n        break;\n    case CODEC_ID_SOL_DPCM:\n        in = 0;\n        if (avctx->codec_tag != 3) {\n            if(*data_size/4 < buf_size)\n            while (in < buf_size) {\n                int n1, n2;\n                n1 = (buf[in] >> 4) & 0xF;\n                n2 = buf[in++] & 0xF;\n                s->sample[0] += s->sol_table[n1];\n                 if (s->sample[0] < 0) s->sample[0] = 0;\n                if (s->sample[0] > 255) s->sample[0] = 255;\n                output_samples[out++] = (s->sample[0] - 128) << 8;\n                s->sample[s->channels - 1] += s->sol_table[n2];\n                if (s->sample[s->channels - 1] < 0) s->sample[s->channels - 1] = 0;\n                if (s->sample[s->channels - 1] > 255) s->sample[s->channels - 1] = 255;\n                output_samples[out++] = (s->sample[s->channels - 1] - 128) << 8;\n            }\n        } else {\n            while (in < buf_size) {\n                int n;\n                n = buf[in++];\n                if (n & 0x80) s->sample[channel_number] -= s->sol_table[n & 0x7F];\n                else s->sample[channel_number] += s->sol_table[n & 0x7F];\n                s->sample[channel_number] = av_clip_int16(s->sample[channel_number]);\n                output_samples[out++] = s->sample[channel_number];\n                /* toggle channel */\n                channel_number ^= s->channels - 1;\n            }\n        }\n        break;\n    }\n    *data_size = out * sizeof(short);\n    return buf_size;\n}", "idx": 9283, "substitutes": {"avctx": ["avcmp", "avcontext", "evctx", "AVctx", "avectx", "afcontext", "aircontext", "avcas", "avalctx", "afcoll", "aircas", "afcas", " avcontext", "avcup", "AVcas", "aircmp", "avcoll", "afconn", "AVcmp", "avalconn", "avalcontext", "avecup", " avcoll", " avconn", "AVcup", "AVconn", "avecontext", "AVcontext", "aveconn", "evcoll", "avalcup", "avconn", "evconn", "afctx", "airctx", "afcmp", "evcontext"], "data": ["dat", "block", "size", "sample", "device", "Data", "result", "media", "len", "a", "d", "DATA", "multi", "config", "p", "offset", "input", "b", "database", "array", "memory", "tmp", "image", "reader", "da", "bin", "start", "next", "buff", "map", "buffer", "body", "pad", "base", "raw", "batch", "window", "cache"], "data_size": ["queue_size", "queue_source", "queue_strength", "data_source", "data_capacity", "queue_capacity", "data_strength"], "buf": ["text", "ctx", "src", "ref", "seq", "b", "fb", "queue", "bd", "mem", "bb", "Buffer", "wave", "cmd", "uf", "area", "border", "buff", "msg", "feat", "coord", "ba", "cas", "home", "bag", "box", "conv", "db", "frame", "img", "num", "header", "alloc", "bin", "ab", "port", "block", "aux", "bc", "pb", "ux", "config", "cur", "bh", "array", "br", "que", "mac", "cf", "map", "wav", "window", "comb", "pool", "vec", "flow", "fam", "grab", "bu", "cb", "input", "Buff", "context", "uv", "rb", "cv", "tab", "buffer", "func", "wb", "uc", "band", "cap", "batch"], "buf_size": ["buflexpos", "bufalldepth", "buff_empty", "buf_length", "buf_depth", "uf_pos", "buflexSize", "buf_scale", "buf_empty", "buflexsize", "buff_loc", "uf_number", "buflexnumber", "buffer_scale", "buf_address", "buf_pos", "bufalllength", "bufallsized", "uf_size", "uf_Size", "uf_length", "buf_Size", "uf_sized", "buffer_number", "uf_depth", "buff_size", "buf_loc", "buf_number", "buffer_size", "buff_length", "bufallsize", "buffer_address", "buf_sized"], "s": ["g", "os", "args", "f", "sym", "site", "service", "cs", "ls", "self", "ss", "xs", "y", "c", "sq", "a", "i", "is", "ks", "d", "services", "sb", "es", "p", "ts", "sg", "si", "S", "session", "b", "ssl", "j", "bs", "ns", "v", "spec", "r", "t", "o", "ps", "ses", "qs", "l", "sc", "u", "gs", "m", "e", "sys", "sets", "su", "sa", "space", "js"], "in": ["nin", "err", "inn", "connection", "min", "c", "a", "i", "ex", "d", "con", "key", "vin", "lin", "channel", "all", "resource", "win", "old", "rec", "query", "init", "login", "token", "it", "line", "isin", "pass", "like", "size", "id", "update", "ins", "off", "copy", "pin", "bin", "call", "rin", "din", "read", "str", "f", "len", "en", "config", "again", "qa", "part", "IN", "ind", "source", "inside", "l", "start", "index", "name", "pull", "pid", "x", "pos", "version", "ini", "In", "new", "input", "net", "inner", "url", "image", "inc", "try", "gin", "m", "tin"], "predictor": ["pveyori", "ppredor", "ppredors", "ppredon", "psredictor", "pjector", " ppredior", "pctors", "ppredory", "preacherori", "predictory", "positour", "predictible", "ptesttor", "pripttor", "Predictorer", "pributor", "preredicter", "predictrator", "ppredee", "padapter", "propributour", " pcession", "ppectider", "pllectore", "pjectlor", "ppecto", "ppredler", "pvaror", "predictori", "priptori", " prediction", "perredictrator", "Ppector", "pvicter", "pjectrator", "propredictator", "prepectore", "propredictors", "pacheror", " ppecter", "previcter", "pcessori", "epredictener", "predicton", "pveyore", "ppredion", "pcriptener", "ppectior", "pcesslor", "predictour", " predictler", "pcessior", "pcessor", "pributator", "pllectol", "pcorrection", "epositour", "precorrectutor", "pconstructer", "pcorrectore", "ppectors", "pctator", "perjectrator", "pcessar", "positor", "padaptor", "prepector", "pvictors", "pcesser", "pller", " predictar", "Ppecto", "preredictors", "epredicttor", "pctor", "predictOR", "propributator", "pcorrecttor", "prentori", "pvictori", "pveyor", " predictoring", "epredictor", "pacherori", "pcorrectors", "predictior", "ppectee", "propributor", "pcriptor", "predictore", " pcessor", " pcessable", "ppectol", "previctor", " pcessator", "perredictlor", "pveyOR", "precorrectori", "pepredor", "pllector", " ppectoring", " predicter", "predictator", "previctori", "ppredorer", "Predictor", " ppredion", " pcessori", "plector", "ppector", "predictutor", "ppredore", "pitnessor", "ppectlor", "predictable", "pributors", "predictoder", "pjectoder", "pepredori", "pcorrecter", "plredictlor", " ppector", " ppredors", "ppectorer", "plredictore", "preredictar", "pcessator", "preredictider", "ppredible", "predictorer", "picttor", "ptestor", "pllectlor", "pvictlor", "ppredo", " ppectori", "psributor", "priptrator", "plectlor", "perjectlor", "predictol", "pjectori", "predicto", "peredictar", "preacherore", "pictrator", "perjecttor", "predictoring", " pcessior", "pvarori", "prentor", " predictori", "preredictori", " predictrator", "propributors", "plredictor", "pitnessori", "psributory", "ppredori", " pcesser", " predictable", "ppredator", "priptlor", "pcriptour", "pjectable", "peredictori", "perredictor", " pcessoder", "preredictore", "predictener", "pictoder", "pllar", "plectore", "pvictor", "pvictour", "epositor", "Predictori", " pcessore", " predictior", "prepectar", "pictore", "pcessoder", "pvictator", "preredicton", "pcorrectutor", "pllor", "preredictor", "pcesson", "predictler", "peredictlor", "pcorrectrator", "pconstructour", "plredictol", "posittor", " predictors", "pictor", "pcripttor", "pvictore", "predictlor", "epositener", "propredictour", "positener", "pconstructier", "ptestore", "pcorrectlor", "psributee", "pvarors", "pributour", "ppectator", "pcorrector", "epredictour", "predictors", "psributore", "predicter", "psredictore", "precorrectors", "pctour", "ppectutor", "pconstructtor", "psredictee", "ppecton", "prediction", "Predicto", "pjecttor", "plloring", "predicttor", "ppectori", "peredictor", "pconstructori", "pributore", "ppectier", "pcorrectior", " predicttor", "padaptar", "ppectible", "ppectler", "ppecter", " predictator", "ppredar", "pributory", "propredictor", "predictar", "ppredior", "pacherider", " ppredor", "predictier", "preredictutor", "pvictol", "priptor", "ppredider", "perredicttor", "eposittor", " ppectible", " predictoder", "pictable", "pacherar", "pcessable", "pcession", "pcorrectori", "pepredlor", "pvictier", "priptorer", "predictee", "pcessore", "pitnessOR", " ppectar", "prentler", "ppection", "perjector", "ppectory", "preacheror", "pacherore", "pvarutor", "ppectar", "padaptoring", "pacherOR", "Ppectorer", "pitnessore", "pconstructener", "psredictory", "predictider", "prepectider", "prepecton", "Ppectori", "prepectori", "preacherOR", "pepredar", "ppectoring", "ppectore", "precorrector", "prentible", "ptestrator", "ppredlor", " ppectler", "previctier", "preredictier", "pconstructor", " predictible", "pributee", "pictori", "plectol", "pripto", " predictore", "preredictOR"], "output_samples": ["output_setsonents", "output_damps", "output_specamples", "output_dores", "output_Sores", "output_tonents", "output_seriesamples", "output_tamples", "output_sannels", "output_sigs", "output_samps", "output_seriesributes", "output_timesams", "output_seriesamps", "output_specams", "output_bamples", "output_bamps", "output_framesamps", "output_pannels", "output_setsamps", "output_bages", "output_bributes", "output_pamps", "output_digs", "output_framesamples", "output_specigs", "output_setsannels", "output_setsributes", "output_pamples", "output_framesigs", "output_timesigs", "output_framesores", "output_damples", "output_ponents", "output_sams", "output_setsamples", "output_specamps", "output_setsages", "output_seriesages", "output_sributes", "output_Sigs", "output_sores", "output_Samps", "output_tams", "output_tamps", "output_timesamples", "output_Samples", "output_sonents", "output_tannels", "output_timesamps", "output_sages", "output_tigs"], "shift": ["padding", "pos", "max", " shifts", "transfer", "master", "pack", "config", "offset", "chip", "seed", "worker", "shape", "total", "scale", "image", "push", "mask", "pad", "workers", "raw", "pull", "batch", "extra", "count", "align", "slice"], "byte": ["binary", "block", "pointer", "ip", "bytes", "Byte", "b", "bit", "piece", "image", "bb", "channel", "bin", "val", "word", "buffer", "unit", "null", "letter", "slice"], "diff": [" extra", " dup", "id", " remaining", " bias", " error", " distance", " label", "len", " change", " unused", " padding", " temp", " gain", " unknown", " split", " beta", " align", " stride", " boundary", "channel", " difference", " delta", " len", " rank", " mismatch"], "out": ["server", "pos", "timeout", "to", "version", "no", "pool", "at", "id", "max", "OUT", "err", "output", "connection", "min", "c", "user", "ex", "i", "off", "outer", "In", "new", "p", "input", "again", "outs", "extra", "net", "inner", "io", "con", "bit", "part", "key", "ac", "image", "IN", "client", "inc", "num", "o", "channel", "bin", "parent", "error", "req", "win", "call", "conn", "sync", "index", "all", "cmd", "arg", "not", "query", "init", "post", "null", "name", "x", "Out"], "channel_number": ["channelernb", "channelOno", " channel_class", "channelPmajor", "messagexmaximum", "channelIdclass", "channelingmajor", "channelptoken", "variable_number", " channel_size", "channel_num", "channelpsize", "channelPnumber", "channelOnumber", "message_name", "channelxname", "chan_number", " channel_\n", "channel_group", "channel_document", "channelerexpression", "channelingnumber", "channelxmaximum", "channelxstate", "gap_expression", "channelxnumber", "chan_token", "channelingnb", "variable_major", "channelalnumber", "channelernumber", "channel_major", "channelingfunction", " channel_document", "variable_class", "channelalgroup", "channel_duration", "channelingno", "message_maximum", "channelIdmajor", "channel_expression", "channel_numbered", "channel_class", "channelpnumber", "channelOnum", "channel_state", "gapernb", "channelIdnumber", " channel_num", " channel_no", " channel_collection", "channel_maximum", "messagexnumber", "channelingname", "gapername", "variable_function", "channel_token", " channel_numbered", "channel_function", "channel\u00a0\n", "channelPfunction", "messagexname", "channelingmaximum", " channel_nb", "channelJnb", "channel_collection", "variableingmajor", "channelingdocument", "channelingstate", "channel_size", "message_state", "channelJnumber", "channelJname", "gap_number", "channel_\n", "channelername", "messagexstate", "chan_size", "chan_numbered", "channelPclass", "channelIdfunction", "gap_name", "channel_nb", "gap_nb", "variableingfunction", "channel_no", "message_number", "channelJexpression", "channelpnumbered", "channelalnumbered", "gapernumber", "channelOduration", "channelingclass", " channel_group", "gaperexpression", "variableingclass", " channel_duration", "variableingnumber", "channel_name", "channelalcollection"]}}
{"project": "FFmpeg", "commit_id": "03abf55f252945c70f4a79eaf4d609cee4d98710", "target": 1, "func": "int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb,\n\n                              AVStream *st, RMStream *rst,\n\n                              unsigned int codec_data_size, const uint8_t *mime)\n\n{\n\n    unsigned int v;\n\n    int size;\n\n    int64_t codec_pos;\n\n    int ret;\n\n\n\n    if (codec_data_size > INT_MAX)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000);\n\n    codec_pos = avio_tell(pb);\n\n    v = avio_rb32(pb);\n\n\n\n    if (v == MKBETAG('M', 'L', 'T', 'I')) {\n\n        int number_of_streams = avio_rb16(pb);\n\n        int number_of_mdpr;\n\n        int i;\n\n        for (i = 0; i<number_of_streams; i++)\n\n            avio_rb16(pb);\n\n        number_of_mdpr = avio_rb16(pb);\n\n        if (number_of_mdpr != 1) {\n\n            avpriv_request_sample(s, \"MLTI with multiple MDPR\");\n\n        }\n\n        avio_rb32(pb);\n\n        v = avio_rb32(pb);\n\n    }\n\n\n\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n\n        /* ra type header */\n\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n\n            return -1;\n\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n\n        avio_seek(pb, -4, SEEK_CUR);\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)\n\n            return ret;\n\n\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n\n                                                st->codec->codec_tag);\n\n    } else if(mime && !strcmp(mime, \"logical-fileinfo\")){\n\n        int stream_count, rule_count, property_count, i;\n\n        ff_free_stream(s, st);\n\n        if (avio_rb16(pb) != 0) {\n\n            av_log(s, AV_LOG_WARNING, \"Unsupported version\\n\");\n\n            goto skip;\n\n        }\n\n        stream_count = avio_rb16(pb);\n\n        avio_skip(pb, 6*stream_count);\n\n        rule_count = avio_rb16(pb);\n\n        avio_skip(pb, 2*rule_count);\n\n        property_count = avio_rb16(pb);\n\n        for(i=0; i<property_count; i++){\n\n            uint8_t name[128], val[128];\n\n            avio_rb32(pb);\n\n            if (avio_rb16(pb) != 0) {\n\n                av_log(s, AV_LOG_WARNING, \"Unsupported Name value property version\\n\");\n\n                goto skip; //FIXME skip just this one\n\n            }\n\n            get_str8(pb, name, sizeof(name));\n\n            switch(avio_rb32(pb)) {\n\n            case 2: get_strl(pb, val, sizeof(val), avio_rb16(pb));\n\n                av_dict_set(&s->metadata, name, val, 0);\n\n                break;\n\n            default: avio_skip(pb, avio_rb16(pb));\n\n            }\n\n        }\n\n    } else {\n\n        int fps;\n\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n\n        fail1:\n\n            av_log(s, AV_LOG_WARNING, \"Unsupported stream type %08x\\n\", v);\n\n            goto skip;\n\n        }\n\n        st->codec->codec_tag = avio_rl32(pb);\n\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n\n                                               st->codec->codec_tag);\n\n        av_dlog(s, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n\n        if (st->codec->codec_id == AV_CODEC_ID_NONE)\n\n            goto fail1;\n\n        st->codec->width  = avio_rb16(pb);\n\n        st->codec->height = avio_rb16(pb);\n\n        avio_skip(pb, 2); // looks like bits per sample\n\n        avio_skip(pb, 4); // always zero?\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n\n        fps = avio_rb32(pb);\n\n\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n\n            return ret;\n\n\n\n        if (fps > 0) {\n\n            av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num,\n\n                      0x10000, fps, (1 << 30) - 1);\n\n#if FF_API_R_FRAME_RATE\n\n            st->r_frame_rate = st->avg_frame_rate;\n\n#endif\n\n        } else if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR, \"Invalid framerate\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\nskip:\n\n    /* skip codec info */\n\n    size = avio_tell(pb) - codec_pos;\n\n    avio_skip(pb, codec_data_size - size);\n\n\n\n    return 0;\n\n}\n", "idx": 9301, "substitutes": {"s": ["g", "utils", "os", "scl", "f", "bis", "src", "service", "cs", "ls", "sf", "c", "sq", "services", "sv", "sb", "es", "p", "sci", "si", "sp", "sg", "ds", "settings", "fs", "ssl", "b", "sie", "sts", "sl", "bs", "ns", "spec", "client", "r", "t", "ps", "ses", "sc", "plugins", "gs", "sys", "storage", "sa", "types", "ops"], "pb": ["plugin", "bos", "phrase", "pg", "tp", "ctx", "dp", "bm", "pm", "pro", "api", "pl", "typ", "bc", "parser", "rob", "bps", "db", "pc", "lb", "eb", "jp", "lab", "sb", "lp", "pd", "cpp", "p", "cb", "pkg", "asm", "b", "fb", "bh", "bt", "gb", "pt", "rb", "bs", "fp", "hub", "fc", "prot", "bb", "xb", "platform", "txt", "wp", "uf", "pp", "vp", "ab", "pa", "ob", "wb", "bp", "py", "dl", "bf", "PB"], "st": ["et", "put", "fr", "sd", "sth", "f", "src", "ost", "ist", "sw", "elt", "state", "sf", "ss", "ft", "td", "pc", "art", "d", "sv", "sb", "ts", "p", "str", "stage", "sp", "sta", "ste", "ST", "ds", "bt", "sts", "ct", "ld", "nd", "pt", "end", "mt", "sl", "kt", "est", "ut", "t", "std", "l", "ust", "sc", "start", "stack", "sn", "post", "ast", "obj", "St", "set", "nt", "rest", "sa", "stream", "ad", "inst", "stop", "stab"], "rst": ["ertd", "Rsts", "rtd", "srsc", "Rstream", "srst", " rsc", "erST", "ersc", " rtd", "rsts", "erst", "rgST", "rgst", "Rst", "Rsc", "rST", "rgtd", "srstream", " rstream", "rgsc", "rstream", " rsts", "rsc", " rST", "srsts"], "codec_data_size": ["codec_window_length", "codec_data_format", "codec_window_size", "codec_data_length", "codec_window_scale", "codec_dat_format", "codec_data_scale", "codec_data_capacity", "codec_data_width", "codec_dat_size", "codec_dat_capacity"], "mime": [" mimes", "tmIME", "amime", "amimes", "Mime", "Mile", " mame", " mile", "tmime", "tmimes", "mapped", "Mimes", "mimes", "tmile", "MIME", "Mapped", "mile", "Mame", "amapped", " mapped", "amame", "mIME", "mame", "amIME", " mIME"], "v": ["g", "vol", "f", "format", "limit", "k", "vt", "ov", "rev", "c", "conv", "ver", "en", "sv", "d", "ant", "ev", "h", "p", "vid", "b", "j", "vr", "uv", "iv", "cv", "lv", "vert", "t", "r", "nv", "l", "V", "q", "u", "vp", "m", "e", "n", "value", "tv", "vv", "vi", "ve", "vs", "x", "volt"], "size": ["pos", "SIZE", "sent", "f", "len", "c", "en", "small", "p", "enc", "si", "loc", "ize", "code", "Size", "l", "desc", "e", "n", "unit", "x"], "codec_pos": ["codef_pos", "codec_loc", "codecslen", "codef_start", "codoc_pos", "codef_position", "codoc_position", "codec_len", "codec_start", "codef_loc", "codoc_len", "codecsposition", "codec_position", "codecspos"], "ret": ["rt", "rets", "id", "match", "resp", "re", "RET", "att", "ref", "rev", "result", "success", "len", "rc", "cat", "back", "fun", "lit", "flag", "mt", "red", "code", "mem", "fail", "error", "det", "rep", "def", "pet", "lib", "arg", "reply", "res", "reg", "nt", "out", "alt", "Ret", "status", "data", "bad"], "number_of_mdpr": ["number_of_ndrs", "number_of_ddPR", "number_of_mmr", "number_of_mondPr", "number_of_ndPR", "number_of_mdrx", "number_of_ndr", "number_of_ndPr", "number_of_amdPR", "number_of_mmpr", "number_of_mdPr", "number_of_ddrs", "number_of_mmrx", "number_of_ndrx", "number_of_amdpr", "number_of_amdPr", "number_of_mdr", "number_of_MDPr", "number_of_MDpr", "number_of_MDrs", "number_of_ndpr", "number_of_ddPr", "number_of_mmrs", "number_of_MDPR", "number_of_mdPR", "number_of_amdrs", "number_of_ddpr", "number_of_mmPR", "number_of_mmPr", "number_of_mondrx", "number_of_mondpr", "number_of_mdrs", "number_of_mondr"], "i": ["ii", "pos", "ni", "li", "abi", "f", "phi", "I", "mu", "ip", "oi", "mi", "fi", "chi", "c", "iu", "ini", "d", "multi", "ri", "p", "ji", "si", "b", "pi", "inner", "uli", "j", "gi", "ie", "in", "xi", "ti", "di", "hi", "qi", "ui", "l", "ci", "q", "index", "m", "e", "n", "ai", "eni", "count", "x", "ix", "it"]}}
{"project": "qemu", "commit_id": "abda1f37eed86f3501db2e5439c1a7b97171ea22", "target": 1, "func": "int sd_do_command(SDState *sd, SDRequest *req,\n\n                  uint8_t *response) {\n\n    uint32_t last_status = sd->card_status;\n\n    sd_rsp_type_t rtype;\n\n    int rsplen;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {\n\n        return 0;\n\n    }\n\n\n\n    if (sd_req_crc_validate(req)) {\n\n        sd->card_status &= ~COM_CRC_ERROR;\n\n        return 0;\n\n    }\n\n\n\n    sd->card_status &= ~CARD_STATUS_B;\n\n    sd_set_status(sd);\n\n\n\n    if (last_status & CARD_IS_LOCKED) {\n\n        if (!cmd_valid_while_locked(sd, req)) {\n\n            sd->card_status |= ILLEGAL_COMMAND;\n\n            fprintf(stderr, \"SD: Card is locked\\n\");\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    if (last_status & APP_CMD) {\n\n        rtype = sd_app_command(sd, *req);\n\n        sd->card_status &= ~APP_CMD;\n\n    } else\n\n        rtype = sd_normal_command(sd, *req);\n\n\n\n    sd->current_cmd = req->cmd;\n\n\n\n    switch (rtype) {\n\n    case sd_r1:\n\n    case sd_r1b:\n\n        sd_response_r1_make(sd, response, last_status);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r2_i:\n\n        memcpy(response, sd->cid, sizeof(sd->cid));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r2_s:\n\n        memcpy(response, sd->csd, sizeof(sd->csd));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r3:\n\n        sd_response_r3_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r6:\n\n        sd_response_r6_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r7:\n\n        sd_response_r7_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r0:\n\n    default:\n\n        rsplen = 0;\n\n        break;\n\n    }\n\n\n\n    if (sd->card_status & ILLEGAL_COMMAND)\n\n        rsplen = 0;\n\n\n\n#ifdef DEBUG_SD\n\n    if (rsplen) {\n\n        int i;\n\n        DPRINTF(\"Response:\");\n\n        for (i = 0; i < rsplen; i++)\n\n            printf(\" %02x\", response[i]);\n\n        printf(\" state %d\\n\", sd->state);\n\n    } else {\n\n        DPRINTF(\"No response %d\\n\", sd->state);\n\n    }\n\n#endif\n\n\n\n    return rsplen;\n\n}\n", "idx": 9330, "substitutes": {"sd": ["li", "hd", "sed", "sth", "service", "dis", "d", "sv", "model", "sh", "sp", "cm", "gb", "bd", "df", "ui", "ci", "esi", "sn", "dat", "os", "site", "api", "dist", "sb", "pd", "sie", "ds", "sta", "sem", "ic", "ld", "ses", "sc", "conn", "cod", "s", "dl", "ad", "dt", "SD", "sf", "td", "vc", "config", "des", "sg", "dk", "sl", "sim", "di", "dd", "dn", "ind", "std", "lib", "sync", "south", "report", "su", "sk", "lc", "wd", "fr", "sam", "md", "gd", "ed", "si", "nd", "vd", "se", "sy", "dev", "od", "dm", "sa", "fd", "cd"], "req": ["ctr", "required", "fr", "uri", "ctx", "rt", "request", "src", "f", "resp", "ref", "err", "Request", "proc", "serv", "result", "rg", "ra", "seq", "sq", "dist", "sr", "ru", "config", "quest", "ri", "ro", "cb", "http", "rf", "sem", "require", "release", "dq", "rb", "spec", "client", "rx", "r", "reader", "resource", " request", "def", "cmd", "q", "ir", "rec", "org", "gr", "desc", "query", "conf", "report", "progress", "reg", "res", "rh", "rr", "exec", "requ"], "response": ["server", "onse", "message", "uri", "Resp", "f", "request", "site", "respond", "resp", "respons", "service", "view", "description", "err", "state", "sw", "api", "example", "subject", "serv", "result", "connection", "output", "success", "en", " resp", "application", "es", "model", "des", "document", "sp", "session", "json", "v", "image", "r", "ret", "error", "resource", "df", "def", "given", "esi", "answer", "Response", "reply", "e", "report", "su", "res", "status", "data", "object", "cache"], "rtype": ["rval", "rarref", "rrType", "cty", "rrvar", " rby", "rType", "rcclass", "rrref", "cclass", "cTYPE", "rrid", "rcty", "rref", "arclass", "arty", "srid", "pval", "rarid", "rvar", " rType", "rclass", "rname", "srtype", "srstat", "rstat", "rarType", "rTYPE", "pname", " rid", "rby", "pstat", "artype", "srvar", "rcstat", "rcTYPE", "ctype", "arTYPE", " rvar", "rartype", "rrby", "rctype", "rcval", "srname", "rcname", "srby", "rid", "rrtype", "srval", " rref", "ptype", "rty"], "rsplen": ["rsphun", "raspaloen", "rasslens", "raspeened", "arssllen", "rsppeng", "rsfonen", "rasplenn", "rsfilen", "lspleng", "rspeatten", "lslens", "rsselon", "rsoploen", "rsfilreen", "rsplonen", "rsphened", "rslen", "rasslened", "rssellen", "rsselun", "rspalenc", "rsselen", "raspeatten", "arsplien", "rasslreen", "rasslun", "arspllen", "rsplreen", "rsppenc", " rsplenn", "rsspleng", "rsplon", "rsfened", "rsplatten", "rsplfen", "rspalens", "rsplened", "rasplens", "raspeonen", " rsselon", "lsplens", "arsslen", "rssllen", "rsoplfen", "rsPLon", "rsPLn", "rassllen", "rsPLen", "rsselened", "rspaconen", "raspalfen", "rasslon", "rasplon", "arspleng", "rsselens", "rssplenn", "rsllen", "raspeen", "rspalenn", "rasploen", "rsblien", "raspalenn", "rsplien", "rslien", "rsseln", "rslens", " rspln", "arsplen", "rspllen", "rsproen", "rsspln", "rspeen", "rsslon", "raspalen", "raspllen", "rspacen", "rasplatten", "rsblon", "rspacatten", "rspln", "rsbleng", "rasplun", "rsploen", "rasplen", "rsslien", "rsblen", "rasplonen", "rspren", "rsslens", "rspleng", "rslenc", "rsppens", "lsleng", "rspalfen", " rsselen", "rsplenc", "rsseleng", "rsselreen", "rssleng", "lsplenc", "rsoplen", "rsplenn", "rsleng", "rsfatten", "rsplun", "rssplon", "rspeonen", " rsplon", "rsPLenn", "rasplreen", "arsslien", "rsfen", "rspeened", "rsfilens", "rsoplenn", "rasslen", "rspaloen", "rsprenn", "arssleng", "rsfillen", "rsslun", "lslenc", " rsseln", "rsslen", " rsselenn", "rspaleng", "rsselenn", "rsspllen", "rassleng", "rspheng", "rssplen", "rsplens", "lsplen", "lslen", "rsbllen", "rsphen", "rsslreen", "rsppen", "raspleng", "rsslened", "rspalen", "rasplfen", "rspacened", "rsprfen", "rasplened"]}}
{"project": "FFmpeg", "commit_id": "76db17dc7d4f19f9a03bdd6de79c2ea37b76888f", "target": 0, "func": "static int dpcm_decode_frame(AVCodecContext *avctx,\n\n                             void *data, int *data_size,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    DPCMContext *s = avctx->priv_data;\n\n    int in, out = 0;\n\n    int predictor[2];\n\n    int ch = 0;\n\n    int stereo = s->channels - 1;\n\n    short *output_samples = data;\n\n    int shift[2];\n\n    unsigned char byte;\n\n    short diff;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    // almost every DPCM variant expands one byte of data into two\n\n    if(*data_size/2 < buf_size)\n\n        return -1;\n\n\n\n    switch(avctx->codec->id) {\n\n\n\n    case CODEC_ID_ROQ_DPCM:\n\n        if (stereo) {\n\n            predictor[0] = buf[7] << 8;\n\n            predictor[1] = buf[6] << 8;\n\n        } else {\n\n            predictor[0] = AV_RL16(&buf[6]);\n\n        }\n\n        SE_16BIT(predictor[0]);\n\n        SE_16BIT(predictor[1]);\n\n\n\n        /* decode the samples */\n\n        for (in = 8, out = 0; in < buf_size; in++, out++) {\n\n            predictor[ch] += s->roq_square_array[buf[in]];\n\n            predictor[ch] = av_clip_int16(predictor[ch]);\n\n            output_samples[out] = predictor[ch];\n\n\n\n            /* toggle channel */\n\n            ch ^= stereo;\n\n        }\n\n        break;\n\n\n\n    case CODEC_ID_INTERPLAY_DPCM:\n\n        in = 6;  /* skip over the stream mask and stream length */\n\n        predictor[0] = AV_RL16(&buf[in]);\n\n        in += 2;\n\n        SE_16BIT(predictor[0])\n\n        output_samples[out++] = predictor[0];\n\n        if (stereo) {\n\n            predictor[1] = AV_RL16(&buf[in]);\n\n            in += 2;\n\n            SE_16BIT(predictor[1])\n\n            output_samples[out++] = predictor[1];\n\n        }\n\n\n\n        while (in < buf_size) {\n\n            predictor[ch] += interplay_delta_table[buf[in++]];\n\n            predictor[ch] = av_clip_int16(predictor[ch]);\n\n            output_samples[out++] = predictor[ch];\n\n\n\n            /* toggle channel */\n\n            ch ^= stereo;\n\n        }\n\n\n\n        break;\n\n\n\n    case CODEC_ID_XAN_DPCM:\n\n        in = 0;\n\n        shift[0] = shift[1] = 4;\n\n        predictor[0] = AV_RL16(&buf[in]);\n\n        in += 2;\n\n        SE_16BIT(predictor[0]);\n\n        if (stereo) {\n\n            predictor[1] = AV_RL16(&buf[in]);\n\n            in += 2;\n\n            SE_16BIT(predictor[1]);\n\n        }\n\n\n\n        while (in < buf_size) {\n\n            byte = buf[in++];\n\n            diff = (byte & 0xFC) << 8;\n\n            if ((byte & 0x03) == 3)\n\n                shift[ch]++;\n\n            else\n\n                shift[ch] -= (2 * (byte & 3));\n\n            /* saturate the shifter to a lower limit of 0 */\n\n            if (shift[ch] < 0)\n\n                shift[ch] = 0;\n\n\n\n            diff >>= shift[ch];\n\n            predictor[ch] += diff;\n\n\n\n            predictor[ch] = av_clip_int16(predictor[ch]);\n\n            output_samples[out++] = predictor[ch];\n\n\n\n            /* toggle channel */\n\n            ch ^= stereo;\n\n        }\n\n        break;\n\n    case CODEC_ID_SOL_DPCM:\n\n        in = 0;\n\n        if (avctx->codec_tag != 3) {\n\n            if(*data_size/4 < buf_size)\n\n                return -1;\n\n            while (in < buf_size) {\n\n                int n1, n2;\n\n                n1 = (buf[in] >> 4) & 0xF;\n\n                n2 = buf[in++] & 0xF;\n\n                s->sample[0] += s->sol_table[n1];\n\n                if (s->sample[0] < 0)   s->sample[0] = 0;\n\n                if (s->sample[0] > 255) s->sample[0] = 255;\n\n                output_samples[out++] = (s->sample[0] - 128) << 8;\n\n                s->sample[stereo] += s->sol_table[n2];\n\n                if (s->sample[stereo] < 0)   s->sample[stereo] = 0;\n\n                if (s->sample[stereo] > 255) s->sample[stereo] = 255;\n\n                output_samples[out++] = (s->sample[stereo] - 128) << 8;\n\n            }\n\n        } else {\n\n            while (in < buf_size) {\n\n                int n;\n\n                n = buf[in++];\n\n                if (n & 0x80) s->sample[ch] -= s->sol_table[n & 0x7F];\n\n                else s->sample[ch] += s->sol_table[n & 0x7F];\n\n                s->sample[ch] = av_clip_int16(s->sample[ch]);\n\n                output_samples[out++] = s->sample[ch];\n\n                /* toggle channel */\n\n                ch ^= stereo;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\n    *data_size = out * sizeof(short);\n\n    return buf_size;\n\n}\n", "idx": 9343, "substitutes": {"avctx": ["afcup", "avcmp", "avcontext", "avsci", "AVctx", "avectx", "afcontext", " avcup", "ajqa", "ajcontext", " avhw", "ajsci", " avcontext", "apcontext", "avcup", "afconn", "AVcmp", "apctx", "aveqa", "ajctx", "avesci", "afsci", "avecup", "apconn", "AVconn", "afqa", "avqa", "avhw", "avecontext", "apcmp", "AVcontext", "afhw", "avconn", "afctx", "afcmp", "avehw"], "data": ["dat", "pos", "message", "block", "empty", "size", "sample", "Data", "connection", "result", "audio", "media", "output", "len", "a", "d", "DATA", "multi", "config", "p", "content", "input", "database", "queue", "frame", "array", "memory", "address", "tmp", "image", "client", "reader", "channel", "da", "val", "length", "frames", "start", "next", "buff", "buffer", "pad", "body", "base", "value", "raw", "video", "batch", "window", "slice", "cache"], "data_size": ["data\u00b7scale", "buffer_width", "data_depth", "buffer_form", "window_size", "data_width", "data_scale", "buffer_scale", "buffer_size", "data_form", "data\u00b7depth", "window_depth", "data\u00b7size", "data_capacity", "window_capacity", "window_scale", "data\u00b7capacity"], "avpkt": ["avcpct", "avPacket", "avcpka", "avcpacket", "avPunch", "avpacket", "affacket", "affct", "afcpacket", "avppkt", "affunch", "afpct", "avcpk", "afpkg", "avppct", "avppk", "afcpkt", "avfka", "avtct", "afPkt", "avfct", "afPacket", "afcpka", "avpkg", "avfacket", "avpka", "avpct", "avPkt", "afcpct", "avpk", "afpunch", "afPk", "avtacket", "avPk", "avpunch", "avcpkt", "affkt", "afpk", "avtunch", "afpka", "afpkt", "avtkt", "avPct", "afPkg", "avppacket", "avfunch", "afpacket", "avppka", "avcpkg", "avppkg", "avfkt", "avPkg"], "buf": ["usr", "np", "text", "block", "ctx", "pool", "vec", "src", "aux", "fam", "proc", "grab", "home", "result", "bu", "bag", "seq", "bc", "box", "conv", "c", "auc", "brace", "fab", "config", "bytes", "cb", "cur", "arr", "loc", "b", "Buff", "fb", "queue", "img", "context", "gb", "uv", "array", "bd", "v", "cv", "bb", "alloc", "br", "que", "bin", "uf", "cmd", "abb", "cf", "border", "buff", "ab", "tab", "wav", "buffer", "pad", "port", "window", "cap", "uc", "uber", "batch", "band", "av", "feat", "coord"], "s": ["is", "g", "os", "ctx", "f", "bis", "sym", "cs", "ss", "c", "sq", "a", "i", "ks", "sup", "sv", "d", "sb", "services", "comm", "p", "sg", "si", "S", "b", "ssl", "context", "soc", "sl", "ns", "v", "spec", "client", "t", "o", "r", "ps", "ses", "sc", "u", "sync", "gs", "m", "conf", "south", "e", "sys", "su", "rs", "storage", "sa", "space", "ops"], "in": ["nin", "before", "ax", "inn", "connection", "min", "c", "a", "i", "d", "trial", "b", "con", "key", "vin", "lin", "all", "resource", "win", "old", "rec", "init", "login", "token", "margin", "it", "line", "isin", "pass", "like", "size", "id", "update", "ins", "gen", "record", "num", "cl", "bin", "pin", "call", "rin", "din", "str", "f", "k", "len", "en", "again", "part", "v", "IN", "ind", "r", "source", "inside", "l", "start", "index", "name", "pull", "count", "x", "pos", "version", "ini", "In", "p", "input", "inner", "ac", "image", "inc", "try", "gin", "head", "tin"], "predictor": ["pritore", "predicttor", "presentore", "ppredcer", "ppredor", "priptio", "paredictio", "ppredors", "ppectori", "practori", " pruptior", " pruptor", "pensore", "promredictore", "predictation", "fpredors", "fpectore", "paitnessor", "presentuser", " predictorn", "pruptior", "presentter", "pceptor", "fpredorb", "tpription", "previctar", "ppredoder", "appictedractor", "pacherlor", "fredictore", "pvictori", "pjector", "appredictier", "ppreduser", " predictori", "pjectter", "ppectorn", " penser", "pcorrectior", "preredictori", "pconstructlor", "pcriptore", " ppectors", "pacherori", "tpripttor", "ppectler", "ppecter", "promributlor", "ppredar", " predictator", "Pvictation", "pcripter", "pcorrectors", "penser", "ppredori", " pcesser", "predictior", "ppredator", "pripttor", "predictar", "pictedier", "priptlor", "paitnesscer", "ppredior", " ppectore", "pributor", "pcriptor", "pceptore", "Pvicter", "paredictlor", "predictore", "ppectorb", "predictier", "pconstructcer", "tpredicttor", " pcessor", "appredictractor", "pcisionori", "promredictor", "pvictation", "ppredtor", "fredictors", "predictitor", " practore", "previctor", "pictedcer", "priptator", " ppectior", "promredictter", "Predictors", "predictuser", "ppredier", "priptor", "preredictore", "prepectlor", "fpredor", "precorrectori", " pcession", "pcorrectcer", "presentor", "pitnesscer", "pributuser", "pceptitor", "pritior", " predicter", "fpector", "pictedor", "pruptori", "pcession", "predictator", "pcorrectori", "predictractor", "fredictori", "previctori", "pvictor", "predictori", "priptcer", "pcriptler", "pcessore", " predictior", "Pvictor", "priptori", "practitor", "promredictlor", " prediction", " pruptorn", "Predictor", "preredictcer", " pcessori", "ppection", "paredictcer", "pacheruser", "ppector", "predictutor", "Predicter", "pacherore", "ppredore", "pitnessor", "promributior", "ppectar", " practori", "tpriptor", "pvicter", "priptation", "ppectlor", "paitnessio", "preredictor", "pruptcer", "predictler", "appredictor", "priptier", "prepectore", "predictoder", "predictorn", "pvictar", " pensler", "appictedier", "pacheror", "pributior", "pensor", "promjectuser", "pcessori", "pconstructio", "pensler", "pjectore", " pensore", "postertor", " practitor", "prepectori", " predictors", "promjectter", "fpectutor", "appictedor", "posterion", "pictedractor", "fpredator", "posteror", "ppectore", "precorrector", "precorrectcer", "predictorb", "pvictore", "fredictorb", "predictlor", "ppredion", "promjectore", " ppector", "ppectior", "pruptor", "paredictor", "pcisionor", "practor", " predictler", "ppredlor", "fpectori", "pcessior", "pcessor", "promjector", "promributuser", "posteroder", "practore", "Pvictors", "promredictior", "pruptore", "pceptori", "predictio", "fredictator", "priptors", "pconstructor", "pacherior", "pcorrector", " pensor", "ppectator", "preredictar", " predictitor", "ppredorb", "pription", "appictedcer", "pcessator", " ppectator", "pributlor", "tpredictoder", "ppreder", "pcessors", "priptore", "pcisionutor", " practor", "predictors", "appredictcer", "priptoder", "pitnessio", "predictcer", "tpriptoder", "tpredictor", "pcisionore", "predicter", "Predictation", "pripter", "tprediction", "precorrectore", "promributor", "predictter", "pruptorn", "pcorrectore", "ppectors", "fredictor", "ppectutor", "pritor", "paitnesslor", "pvictors", " predictore", "pvictitor", "fredictutor", "priptorb", "priptractor", " pruptore", "pjectuser", "pritorn", " ppectori", "previctore", "prepector", "preredictlor", "ppredractor", "promredictuser", "prediction", "pitnesslor", "pcesser"], "output_samples": ["output_linesributes", "output_linesolutions", "output_seriesamples", "output_tamples", "output_sannels", "output_samps", "output_typesamps", "output_Sannels", "output_seriesamps", "output_bamples", "output_bamps", "output_insannels", "output_pannels", "output_linesamps", "output_typesolutions", "output_pamps", "output_bributes", "output_seriesannels", "output_sides", "output_dipes", "output_pamples", "output_sords", "output_palls", "output_pides", "output_typesributes", "output_pipes", "output_bolutions", "output_damples", "output_insamples", "output_tipes", "output_typesamples", "output_Sords", "output_sributes", "output_dides", "output_insamps", "output_bannels", "output_dalls", "output_insords", "output_Samps", "output_salls", "output_polutions", "output_talls", "output_tamps", "output_tords", "output_sipes", "output_Samples", "output_linesamples", "output_solutions", "output_tannels", "output_seriesolutions", "output_tides"], "shift": ["ctr", "err", "cut", "transfer", "pack", "hift", "config", "offset", "chip", "sh", "seed", "extra", "range", "shape", "img", "scale", "push", "mask", "form", "pad", " chunk", "set", "cap", "pull", "batch", "align", "slice"], "byte": ["binary", "block", "ip", "bytes", "Byte", "bit", "piece", "image", "copy", "bb", "channel", "bin", " channel", "word", "val", "buffer", " chunk", "unit", "null", "letter", "slice"], "diff": [" dup", " dist", "err", " bias", " error", " phase", " dev", " shape", " distance", " label", " unused", " temp", " mask", " gap", " digest", " exponent", " align", " differences", " boundary", "channel", " ecc", " difference", " contrast", " mismatch", " disp"], "out": ["server", "pos", "timeout", "version", "pass", "no", "size", "on", "at", "id", "OUT", "err", "output", "connection", "min", "c", "user", "ex", "i", "off", "new", "p", "input", "again", "outs", "b", "net", "inner", "io", "j", "all", "bit", "part", "key", "v", "client", "inc", "ind", "o", "channel", "bin", "pin", "error", "req", "cmd", "call", "conn", "sync", "index", "q", "w", "parent", "IN", "arg", "not", "post", "init", "line", "null", "name", "x", "Out"], "ch": ["ph", "fr", "Ch", "f", "ky", "kick", "cs", "err", "th", "chn", "chi", "chan", "y", "c", "cht", "ver", "i", "h", "p", "cur", "chip", "sh", "gh", "change", "och", "cy", "app", "cp", "cell", "bh", "zh", "j", "cor", "cha", "code", "ich", "client", "che", "chrom", "channel", "cl", "ach", "ci", "q", "conn", "conf", "col", "chu", "qu", "CH", "sk", "cho", "batch", "inst", "count", "cher", "sch"]}}
{"project": "FFmpeg", "commit_id": "0f34c0789f855f04dce518ffc93a01bb943ba1aa", "target": 1, "func": "static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,\n\n                      int *x, int *y, int *plane, int bits_per_plane)\n\n{\n\n    uint8_t *d;\n\n    int shift = *plane * bits_per_plane;\n\n    unsigned mask  = ((1 << bits_per_plane) - 1) << shift;\n\n    value   <<= shift;\n\n\n\n    while (run > 0) {\n\n        int j;\n\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n\n            d = frame->data[0] + *y * frame->linesize[0];\n\n            d[*x] |= (value >> j) & mask;\n\n            *x += 1;\n\n            if (*x == s->width) {\n\n                *y -= 1;\n\n                *x = 0;\n\n                if (*y < 0) {\n\n                   *y = s->height - 1;\n\n                   *plane += 1;\n\n                   if (*plane >= s->nb_planes)\n\n                       return;\n\n                   value <<= bits_per_plane;\n\n                   mask  <<= bits_per_plane;\n\n                }\n\n            }\n\n        }\n\n        run--;\n\n    }\n\n}\n", "idx": 9347, "substitutes": {"s": ["g", "os", "setup", "sym", "f", "bis", "site", "service", "parts", "cs", "ls", "sche", "self", "ss", "sq", "c", "is", "ks", "i", "ins", "services", "sv", "comm", "es", "cpp", "ts", "p", "sg", "si", "S", "settings", "scope", "ds", "fs", "ssl", "gb", "se", "sim", "cli", "ns", "v", "spec", "share", "t", "ps", "ses", "qs", "your", "frames", "l", "sync", "u", "gs", "m", "series", "e", "sets", "sys", "rs", "space", "js", "vs", "ops"], "frame": ["element", "pse", "setup", "file", "f", "panel", "flow", "state", "fi", "sequence", "game", "fe", "feature", "draw", "document", "iframe", "dy", "p", "flower", "fl", "object", "scale", "coll", "image", "motion", "o", "fram", "frames", "cf", "series", "m", "e", "figure", "rame", "process", "scene", "Frame", "window", "data", "slice", "line"], "value": ["VALUE", "shift", "action", "message", "version", "size", "format", "flow", "view", "weight", "limit", "update", "values", "result", "media", "write", "method", "feature", "model", "function", "offset", "content", "p", "change", "b", "bit", "position", "rule", "scale", "array", "memory", "z", "v", "record", "image", "charge", "parent", "val", "wave", "mask", "u", "m", "buffer", "w", "current", "Value", "one", "rate", "data", "depth", "number", "cost"], "run": ["g", "version", "pass", "man", "block", "un", "f", "id", "flow", "weight", "max", "k", "ride", "min", "len", "cycle", "c", "write", "round", "trial", "config", "Run", "step", "orig", "fun", "runs", "use", "con", "bit", "loop", "thread", "day", "image", "row", "num", "r", "spin", "win", "force", "race", "sync", "index", "q", "plot", "head", "nn", "running", "lock", "unit", "rate"], "x": ["axis", "pos", "ax", "size", "f", "pixel", "c", "X", "ex", "i", "xy", "a", "h", "p", "dy", "b", "px", "bit", "key", "z", "v", "image", "layer", "t", "l", "q", "u", "index", "xx", "dx", "w", "m", "e", "n", "page", "data", "ix", "line"], "y": ["g", "zy", "ey", "yy", "f", "type", "yo", "ky", "iy", "k", "ny", "ya", "c", "i", "xy", "yn", "h", "p", "dy", "b", "vy", "cy", "pi", "ish", "gy", "z", "v", "xi", "ye", "ay", "sy", "t", "o", "l", "sky", "u", "w", "m", "col", "ty", "e", "n", "Y", "py", "oy"], "plane": ["axis", "g", "planes", "board", "f", "size", "mode", "limit", "flow", "weight", "k", "fly", "drop", "c", "module", "pen", "p", "lane", "ane", "order", "orient", "fl", "plan", "direction", "flat", "position", "core", "se", "scale", "charge", "key", "z", "xi", "age", "image", "row", "pe", "day", "o", "pin", "level", "rot", "force", "mask", "q", "u", "plot", "m", "e", "unit", "port", "zone", "page", "rate", "group", "slice", "line"], "bits_per_plane": ["bits_per_day", "bits_per_layer", "bits_perPageline", "bits_permmane", "bits_perPageplane", "bits_per_ane", "bits_permmplane", "bits_perPagelayer", "bits_per_planes", "bits_per_line", "bits_per_plan", "bits_per_lane", "bits_per_flight", "bits_perPagelane", "bits_permmlane", "bits_permmline"], "d": ["g", "dat", "dict", "sd", "f", "dp", "diff", "k", "D", "md", "c", "i", "h", "dy", "p", "ds", "b", "z", "di", "dc", "dd", "v", "dn", "ind", "df", "o", "t", "l", "q", "dim", "u", "dx", "w", "m", "dh", "e", "n", "fd", "dl", "ad", "data", "dt"], "j": ["ne", "g", "ni", "li", "adj", "fr", "f", "k", "jo", "jet", "jit", "uj", "i", "jp", "ja", "xy", "h", "ji", "p", "dy", "b", "io", "jl", "ie", "part", "z", "xi", " i", "v", "J", "el", "o", "ind", "l", "u", "start", "dim", "m", "job", "lock", "ij", "e", "n", "child", "jj", "obj", "dj", "section", "py", "js", "aj"]}}
{"project": "FFmpeg", "commit_id": "aaf78e4d14b4875e4cff30e979421a1087337b9f", "target": 1, "func": "mp_image_t* vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, int mp_imgflag, int w, int h){\n\n    MPContext *m= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, next_vf));\n\n  mp_image_t* mpi=NULL;\n\n  int w2;\n\n  int number = mp_imgtype >> 16;\n\n\n\n  av_assert0(vf->next == NULL); // all existing filters call this just on next\n\n\n\n  //vf_dint needs these as it calls vf_get_image() before configuring the output\n\n  if(vf->w==0 && w>0) vf->w=w;\n\n  if(vf->h==0 && h>0) vf->h=h;\n\n\n\n  av_assert0(w == -1 || w >= vf->w);\n\n  av_assert0(h == -1 || h >= vf->h);\n\n  av_assert0(vf->w > 0);\n\n  av_assert0(vf->h > 0);\n\n\n\n  av_log(m->avfctx, AV_LOG_DEBUG, \"get_image: %d:%d, vf: %d:%d\\n\", w,h,vf->w,vf->h);\n\n\n\n  if (w == -1) w = vf->w;\n\n  if (h == -1) h = vf->h;\n\n\n\n  w2=(mp_imgflag&MP_IMGFLAG_ACCEPT_ALIGNED_STRIDE)?((w+15)&(~15)):w;\n\n\n\n  // Note: we should call libvo first to check if it supports direct rendering\n\n  // and if not, then fallback to software buffers:\n\n  switch(mp_imgtype & 0xff){\n\n  case MP_IMGTYPE_EXPORT:\n\n    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.export_images[0];\n\n    break;\n\n  case MP_IMGTYPE_STATIC:\n\n    if(!vf->imgctx.static_images[0]) vf->imgctx.static_images[0]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.static_images[0];\n\n    break;\n\n  case MP_IMGTYPE_TEMP:\n\n    if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.temp_images[0];\n\n    break;\n\n  case MP_IMGTYPE_IPB:\n\n    if(!(mp_imgflag&MP_IMGFLAG_READABLE)){ // B frame:\n\n      if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h);\n\n      mpi=vf->imgctx.temp_images[0];\n\n      break;\n\n    }\n\n  case MP_IMGTYPE_IP:\n\n    if(!vf->imgctx.static_images[vf->imgctx.static_idx]) vf->imgctx.static_images[vf->imgctx.static_idx]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.static_images[vf->imgctx.static_idx];\n\n    vf->imgctx.static_idx^=1;\n\n    break;\n\n  case MP_IMGTYPE_NUMBERED:\n\n    if (number == -1) {\n\n      int i;\n\n      for (i = 0; i < NUM_NUMBERED_MPI; i++)\n\n        if (!vf->imgctx.numbered_images[i] || !vf->imgctx.numbered_images[i]->usage_count)\n\n          break;\n\n      number = i;\n\n    }\n\n    if (number < 0 || number >= NUM_NUMBERED_MPI) return NULL;\n\n    if (!vf->imgctx.numbered_images[number]) vf->imgctx.numbered_images[number] = new_mp_image(w2,h);\n\n    mpi = vf->imgctx.numbered_images[number];\n\n    mpi->number = number;\n\n    break;\n\n  }\n\n  if(mpi){\n\n    mpi->type=mp_imgtype;\n\n    mpi->w=vf->w; mpi->h=vf->h;\n\n    // keep buffer allocation status & color flags only:\n\n//    mpi->flags&=~(MP_IMGFLAG_PRESERVE|MP_IMGFLAG_READABLE|MP_IMGFLAG_DIRECT);\n\n    mpi->flags&=MP_IMGFLAG_ALLOCATED|MP_IMGFLAG_TYPE_DISPLAYED|MP_IMGFLAGMASK_COLORS;\n\n    // accept restrictions, draw_slice and palette flags only:\n\n    mpi->flags|=mp_imgflag&(MP_IMGFLAGMASK_RESTRICTIONS|MP_IMGFLAG_DRAW_CALLBACK|MP_IMGFLAG_RGB_PALETTE);\n\n    if(!vf->draw_slice) mpi->flags&=~MP_IMGFLAG_DRAW_CALLBACK;\n\n    if(mpi->width!=w2 || mpi->height!=h){\n\n//      printf(\"vf.c: MPI parameters changed!  %dx%d -> %dx%d   \\n\", mpi->width,mpi->height,w2,h);\n\n        if(mpi->flags&MP_IMGFLAG_ALLOCATED){\n\n            if(mpi->width<w2 || mpi->height<h){\n\n                // need to re-allocate buffer memory:\n\n                av_free(mpi->planes[0]);\n\n                mpi->flags&=~MP_IMGFLAG_ALLOCATED;\n\n                mp_msg(MSGT_VFILTER,MSGL_V,\"vf.c: have to REALLOCATE buffer memory :(\\n\");\n\n            }\n\n//      } else {\n\n        } {\n\n            mpi->width=w2; mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;\n\n            mpi->height=h; mpi->chroma_height=(h + (1<<mpi->chroma_y_shift) - 1)>>mpi->chroma_y_shift;\n\n        }\n\n    }\n\n    if(!mpi->bpp) mp_image_setfmt(mpi,outfmt);\n\n    if(!(mpi->flags&MP_IMGFLAG_ALLOCATED) && mpi->type>MP_IMGTYPE_EXPORT){\n\n\n\n        av_assert0(!vf->get_image);\n\n        // check libvo first!\n\n        if(vf->get_image) vf->get_image(vf,mpi);\n\n\n\n        if(!(mpi->flags&MP_IMGFLAG_DIRECT)){\n\n          // non-direct and not yet allocated image. allocate it!\n\n          if (!mpi->bpp) { // no way we can allocate this\n\n              mp_msg(MSGT_DECVIDEO, MSGL_FATAL,\n\n                     \"vf_get_image: Tried to allocate a format that can not be allocated!\\n\");\n\n              return NULL;\n\n          }\n\n\n\n          // check if codec prefer aligned stride:\n\n          if(mp_imgflag&MP_IMGFLAG_PREFER_ALIGNED_STRIDE){\n\n              int align=(mpi->flags&MP_IMGFLAG_PLANAR &&\n\n                         mpi->flags&MP_IMGFLAG_YUV) ?\n\n                         (8<<mpi->chroma_x_shift)-1 : 15; // -- maybe FIXME\n\n              w2=((w+align)&(~align));\n\n              if(mpi->width!=w2){\n\n#if 0\n\n                  // we have to change width... check if we CAN co it:\n\n                  int flags=vf->query_format(vf,outfmt); // should not fail\n\n                  if(!(flags&3)) mp_msg(MSGT_DECVIDEO,MSGL_WARN,\"??? vf_get_image{vf->query_format(outfmt)} failed!\\n\");\n\n//                printf(\"query -> 0x%X    \\n\",flags);\n\n                  if(flags&VFCAP_ACCEPT_STRIDE){\n\n#endif\n\n                      mpi->width=w2;\n\n                      mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;\n\n//                  }\n\n              }\n\n          }\n\n\n\n          mp_image_alloc_planes(mpi);\n\n//        printf(\"clearing img!\\n\");\n\n          vf_mpi_clear(mpi,0,0,mpi->width,mpi->height);\n\n        }\n\n    }\n\n    av_assert0(!vf->start_slice);\n\n    if(mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)\n\n        if(vf->start_slice) vf->start_slice(vf,mpi);\n\n    if(!(mpi->flags&MP_IMGFLAG_TYPE_DISPLAYED)){\n\n            mp_msg(MSGT_DECVIDEO,MSGL_V,\"*** [%s] %s%s mp_image_t, %dx%dx%dbpp %s %s, %d bytes\\n\",\n\n                  \"NULL\"/*vf->info->name*/,\n\n                  (mpi->type==MP_IMGTYPE_EXPORT)?\"Exporting\":\n\n                  ((mpi->flags&MP_IMGFLAG_DIRECT)?\"Direct Rendering\":\"Allocating\"),\n\n                  (mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)?\" (slices)\":\"\",\n\n                  mpi->width,mpi->height,mpi->bpp,\n\n                  (mpi->flags&MP_IMGFLAG_YUV)?\"YUV\":((mpi->flags&MP_IMGFLAG_SWAPPED)?\"BGR\":\"RGB\"),\n\n                  (mpi->flags&MP_IMGFLAG_PLANAR)?\"planar\":\"packed\",\n\n                  mpi->bpp*mpi->width*mpi->height/8);\n\n            mp_msg(MSGT_DECVIDEO,MSGL_DBG2,\"(imgfmt: %x, planes: %p,%p,%p strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\\n\",\n\n                mpi->imgfmt, mpi->planes[0], mpi->planes[1], mpi->planes[2],\n\n                mpi->stride[0], mpi->stride[1], mpi->stride[2],\n\n                mpi->chroma_width, mpi->chroma_height, mpi->chroma_x_shift, mpi->chroma_y_shift);\n\n            mpi->flags|=MP_IMGFLAG_TYPE_DISPLAYED;\n\n    }\n\n\n\n  mpi->qscale = NULL;\n\n  }\n\n  mpi->usage_count++;\n\n//    printf(\"\\rVF_MPI: %p %p %p %d %d %d    \\n\",\n\n//      mpi->planes[0],mpi->planes[1],mpi->planes[2],\n\n//      mpi->stride[0],mpi->stride[1],mpi->stride[2]);\n\n  return mpi;\n\n}\n", "idx": 9349, "substitutes": {"vf": ["convcf", " vfen", "ovconf", " vfor", "avcf", " vp", "svconf", "udp", "ivf", "vorfer", "wfb", "avrf", "wcf", "vconf", "evfs", " vconf", "svfi", "Vfs", "svfo", "fb", "vvcf", "svrf", "udfile", "ivcf", "vfile", "evcf", "vorrf", "nvrf", "svfs", "convf", "svf", "vrf", "ervrf", "nvf", "vrfs", " vrf", " vfer", "antcf", "vfs", "verfs", "vfc", "svfc", "evfen", "wf", " vfi", "verfo", "vorcf", "ffb", "nvfile", "vb", "avfs", " vfe", "vcf", "navf", "vvfer", " vcf", " vfile", " vc", "vorf", "Vcf", "volf", "verf", "svfer", "evrf", "avfen", "vercf", " vfb", "svc", "vvf", "ovcf", "svfile", "fcf", "svfe", "antf", "ivfs", "ff", "nvcf", "avf", "vrfe", "evf", "vc", "evfc", "vrcf", "volfor", "antfs", "svfor", "convfo", "vfor", " vb", "vfe", "convfs", "vvrf", "avfer", "evb", "verrf", "navfen", " vfs", "Vc", "avp", "ffs", "vfa", "vp", "ovf", "Vf", "navfa", "ivfen", "antfi", "vfen", "vfi", "ervfen", "vfer", "avfile", "vfb", "volfs", "vfo", "ervf", "avc", "wfs", "volrf", "wrf", "svfa", "ervcf", " vfc", "svcf", "udf", "udcf", "ovfa", "svfen", "ovrf", "navcf", "wb", "svb", "ovfen"], "outfmt": ["outdefmt", "outfnc", " outFns", "outFMT", "outfunns", "outdefns", "outdefMT", " outFnc", " outfnc", " outfns", "outFns", "outfMT", " outFMT", " outfMT", "outfunMT", "outFnc", "outfns", " outFmt", "outfunnc", "outdefnc", "outfunmt", "outFmt"], "mp_imgtype": ["mp__imagtype", "mp_exttype", "mp_imaginfo", "mp_imgype", "mp_imgstyle", "mp_bgtype", "mp_extype", "mp_imtype", "mp_imageype", "mp_imagetype", "mp_imagestyle", "mp_imageinfo", "mp_imgType", "mp_imagstyle", "mp_iminfo", "mp__imaginfo", "mp_bgType", "mp_ngstyle", "mp__imgstyle", "mp__imginfo", "mp__imgcount", "mp_imageType", "mp_imagtype", "mp__imgtype", "mp_extType", "mp_imype", "mp_imagecount", "mp_bgstyle", "mp_imstyle", "mp_imagcount", "mp__imagcount", "mp_bgype", "mp_ngype", "mp__imagstyle", "mp_imType", "mp_imgcount", "mp_imginfo", "mp_ngType", "mp_extstyle", "mp_imcount", "mp_ngtype"], "mp_imgflag": ["mp_exttype", "mp_imgstyle", "mp_bgtype", "mp_alignstyle", "mp_bgflag", "mp_alignstring", "mp_imagstyle", "mp_imagetype", "mp_ngflags", "mp_alignflag", "mp_imgflags", "mp_imageflags", "mp_imagebit", "mp_aligntype", "mp_ngbit", "mp_imagtype", "mp_imagstring", "mp_extstring", "mp_bgflags", "mp_ngflag", "mp_bgbit", "mp_imgstring", "mp_imageflag", "mp_extflag", "mp_imgbit", "mp_imagflag", "mp_extstyle", "mp_ngtype"], "w": ["g", "wal", "wd", "rw", "hw", "wy", "wall", "we", "f", "wan", "wed", "weight", "sw", "wid", "wx", "y", "c", "wo", "d", "p", "wn", "sh", "b", "work", "kw", "nw", "wl", "tw", "wi", "way", "z", "v", "ww", "t", "aw", "wp", "win", "l", "wave", "word", "u", "ew", "q", "wt", "wa", "wh", "ow", "n", "fw", "wb", "window", "W", "x"], "h": ["his", "g", "ph", "hw", "H", "hd", "f", "hr", "k", "th", "home", "host", "oh", "y", "how", "c", "ul", "d", "kh", "p", "ha", "uh", "sh", "gh", "b", "hat", "work", "ah", "bh", "j", "hh", "ht", "hi", "z", "v", "hs", "ch", "hz", "t", "o", "r", "ih", "length", "l", "q", "u", "hl", "he", "wh", "wa", "height", "e", "n", "rh", "s", "history", "x", "hm"], "m": ["g", "mut", "man", "f", "bm", "sm", "mi", "mp", "gm", "md", "c", "module", "d", "mod", "p", "tm", "b", "cm", "j", "mt", "v", "machine", "ms", "vm", "r", "t", "o", "mac", "l", "u", "mm", "dm", "n", "e", "M", "manager", "mn"], "mpi": ["mmid", "MPid", "MPf", "mmi", "MPci", "mbi", "mpii", "epf", "epi", " mpf", "epit", "epiu", "epii", "mmI", "mpit", "MPit", "epc", "mpc", "mpiu", " mpid", " mpc", " mpiu", "MPi", "mpf", "mpci", "epI", " mpit", " mpI", " mpci", "mpid", "mbiu", " mpii", "mpI", "mbii", "mbc", "MPI", "mmci"], "w2": ["ws2", "w1", "wTwo", "swTwo", "h2", " w6", "W1", "sw1", "hTwo", "wb0", "wb1", "ww2", "w0", "wa4", " w0", "ws1", "sw2", "ww1", "h1", "waTwo", "W2", "h3", "w6", "h0", "wb2", "W4", "wa6", " w1", "ws4", "ww6", " wTwo", "wa3", "w3", "sw3", "wa1", "w4", "wbTwo", "wa2"]}}
{"project": "FFmpeg", "commit_id": "e630ca5111077fa8adc972fe8a3d7e2b3e8dc91f", "target": 1, "func": "static int parse_MP4SLDescrTag(MP4DescrParseContext *d, int64_t off, int len)\n\n{\n\n    Mp4Descr *descr = d->active_descr;\n\n    int predefined;\n\n    if (!descr)\n\n        return -1;\n\n\n\n    predefined = avio_r8(&d->pb);\n\n    if (!predefined) {\n\n        int lengths;\n\n        int flags = avio_r8(&d->pb);\n\n        descr->sl.use_au_start       = !!(flags & 0x80);\n\n        descr->sl.use_au_end         = !!(flags & 0x40);\n\n        descr->sl.use_rand_acc_pt    = !!(flags & 0x20);\n\n        descr->sl.use_padding        = !!(flags & 0x08);\n\n        descr->sl.use_timestamps     = !!(flags & 0x04);\n\n        descr->sl.use_idle           = !!(flags & 0x02);\n\n        descr->sl.timestamp_res      = avio_rb32(&d->pb);\n\n                                       avio_rb32(&d->pb);\n\n        descr->sl.timestamp_len      = avio_r8(&d->pb);\n\n\n\n\n\n\n        descr->sl.ocr_len            = avio_r8(&d->pb);\n\n        descr->sl.au_len             = avio_r8(&d->pb);\n\n        descr->sl.inst_bitrate_len   = avio_r8(&d->pb);\n\n        lengths                      = avio_rb16(&d->pb);\n\n        descr->sl.degr_prior_len     = lengths >> 12;\n\n        descr->sl.au_seq_num_len     = (lengths >> 7) & 0x1f;\n\n        descr->sl.packet_seq_num_len = (lengths >> 2) & 0x1f;\n\n    } else {\n\n        avpriv_report_missing_feature(d->s, \"Predefined SLConfigDescriptor\");\n\n\n    return 0;\n", "idx": 9351, "substitutes": {"d": ["dat", "g", "dict", "sd", "f", "id", "did", "k", "del", "D", "xd", "dom", "td", "md", "c", "db", "gd", "i", "mad", "dr", "pd", "h", "mod", "p", "dos", "dy", "ds", "b", "j", "nd", "ld", "grad", "vd", "bd", "z", "in", "dc", "dd", "di", "dn", "ind", "t", "du", "r", "da", "o", "l", "u", "ded", "od", "w", "m", "dh", "dm", "e", "n", "s", "fd", "ad", "dl", "data", "dt", "cd", "dad"], "off": ["Off", " pos", " def", " clen", " Off", " OFF", "ff", " feat", " offsets", " ins", " fo", " mode", " on", " unused", " offset", "offset", " output", " cap", "offs", " op", " lo", " coff", " family", " bits", "ops", " buff"], "len": ["pos", "fn", "size", "vec", " clen", " Len", "min", "seq", " length", "en", "fun", "Len", "gen", "spec", "mem", "length", "el", "val", "all", "def", "n", "ln", "name", "alt"], "descr": ["escr", "Descre", "declrs", "docrator", "structr", "descer", "desru", " descrc", " descru", "desar", "catpr", "hypsr", "distrn", "docr", "escnr", " descrn", "wardru", "descra", "declorr", "escrator", "descru", "catrs", "wardre", "distrb", "reqro", " descra", "reqr", "wardsr", "accr", " descro", "escrr", " descnr", "declrf", "accsr", "escrs", "hypr", "descrs", "suprs", "declr", "scr", "distrs", "accra", "descrr", "constru", "descpr", " descsr", "escer", "escrf", "declro", " descar", "desre", " descorr", "descro", "diffr", "constrs", "constrator", "desr", "decrs", "Descr", " descer", " descrr", "decr", "descre", "hyprs", "diffro", "descorr", "declnr", "declar", "Descrs", "dessr", "desrb", "descor", "criptr", "Descer", "accrs", "escro", "desro", "distr", "deser", "docrs", "descsr", "escru", "diffrator", "escn", "scra", "decor", "escsr", "catr", "suprator", "descrb", " descrf", " descn", "diffre", "descrf", "descrator", "descrn", "scrs", "reqrs", "docre", "structrr", "descar", "reqsr", "structnr", "Descrb", " descrator", "decpr", "Descsr", "Descrn", "constre", "supre", "criptre", " descre", "wardr", "cripter", "supr", "diffn", "constr", "decler", "descn", "escrc", "constrc", "diffrs", " descrs", "hyprator", "structrs", " descpr", "escrb", " descrb", "desrs", "cator", "scsr", "descnr", "descrc", " descor", "escorr", "criptsr"], "predefined": ["redetermined", "condefined", "Predefined", "reddefined", "redicated", "pedefined", "Predetermined", "peddefined", "redefined", "prediscovered", " predef", "redef", " preddefined", "pedetermined", " prediscovered", " predicated", "pedicated", "condicated", " predetermined", "condetermined", "preddefined", "Prediscovered", "predef", "predicated", "Predef", "predetermined", "rediscovered", "Predicated", "condef"], "lengths": ["Lengthches", "lengthches", "thports", "feeds", "Lengthen", "lengthp", "feedes", "Lengthstyles", "widthp", "ths", "lengthl", "controlits", "Lengthits", "lengthstyles", "Lengthports", "thes", " lengthi", "ravelches", "lengthports", "widthes", "ohes", "lengthits", "lengthi", "engths", "widthls", "engthi", "engthen", " lengthports", "lengthes", "controls", "ravelits", "feedl", " lengthp", "feedp", "ohl", " lengthes", "lengthls", "controlches", "controlstyles", " lengthls", "lengthen", "engthes", "ravels", "Lengthi", "Lengthes", "Lengths", "ravelstyles", "widthl", "ohs", "feedls", "widths", " lengthen"]}}
{"project": "qemu", "commit_id": "85d604af5f96c32734af9974ec6ddb625b6716a2", "target": 1, "func": "target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,\n\n                             target_ulong r2)\n\n{\n\n    int64_t t1 = extract64(r1, 0, 32);\n\n    int64_t t2 = extract64(r2, 0, 32);\n\n    int64_t result = t1 * t2;\n\n\n\n    return suov32(env, result);\n\n}\n", "idx": 9352, "substitutes": {"env": ["server", "et", "np", "dict", "loader", "global", "err", "eng", "state", "exc", "db", "en", "qt", "eu", "config", "enc", "console", "ep", "Environment", "enh", "ah", "ext", "shell", "viron", "here", "v", "environment", "gui", "her", "esi", "conn", "dev", "conf", "emb", "e", "obj", "eur", "profile", "eni", "priv", "erv", "txt", "manager", "target"], "r1": ["R4", "ar4", "t01", "ar2", " r4", "t3", " r3", "b01", "r4", "t1", "r3", "result1", "ar3", "R1", "R2", "ar1", "R3", "b3", "r01", "b1", "result01", "result3"], "r2": ["R4", "l4", "RSecond", "l2", "rtwo", "Rtwo", " rii", " rtwo", " r4", "array2", "R0", "r4", "rii", "arraytwo", "r0", "Rii", " rSecond", "R1", "R2", " r0", "l0", "rSecond", "arrayii", "arraySecond", "l1"]}}
{"project": "FFmpeg", "commit_id": "ec79b1fc88b2cc6a9ab6cd953efcdbaebedde233", "target": 1, "func": "static int parse_chunks(AVFormatContext *s, int mode, int64_t seekts, int *len_ptr)\n\n{\n\n    WtvContext *wtv = s->priv_data;\n\n    AVIOContext *pb = wtv->pb;\n\n    while (!url_feof(pb)) {\n\n        ff_asf_guid g;\n\n        int len, sid, consumed;\n\n\n\n        ff_get_guid(pb, &g);\n\n        len = avio_rl32(pb);\n\n        if (len < 32)\n\n            break;\n\n        sid = avio_rl32(pb) & 0x7FFF;\n\n        avio_skip(pb, 8);\n\n        consumed = 32;\n\n\n\n        if (!ff_guidcmp(g, ff_SBE2_STREAM_DESC_EVENT)) {\n\n            if (ff_find_stream_index(s, sid) < 0) {\n\n                ff_asf_guid mediatype, subtype, formattype;\n\n                int size;\n\n                avio_skip(pb, 28);\n\n                ff_get_guid(pb, &mediatype);\n\n                ff_get_guid(pb, &subtype);\n\n                avio_skip(pb, 12);\n\n                ff_get_guid(pb, &formattype);\n\n                size = avio_rl32(pb);\n\n                parse_media_type(s, 0, sid, mediatype, subtype, formattype, size);\n\n                consumed += 92 + size;\n\n            }\n\n        } else if (!ff_guidcmp(g, ff_stream2_guid)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0 && !((WtvStream*)s->streams[stream_index]->priv_data)->seen_data) {\n\n                ff_asf_guid mediatype, subtype, formattype;\n\n                int size;\n\n                avio_skip(pb, 12);\n\n                ff_get_guid(pb, &mediatype);\n\n                ff_get_guid(pb, &subtype);\n\n                avio_skip(pb, 12);\n\n                ff_get_guid(pb, &formattype);\n\n                size = avio_rl32(pb);\n\n                parse_media_type(s, s->streams[stream_index], sid, mediatype, subtype, formattype, size);\n\n                consumed += 76 + size;\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_AudioDescriptorSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_StreamIDSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_SubtitleSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_TeletextSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                AVStream *st = s->streams[stream_index];\n\n                uint8_t buf[258];\n\n                const uint8_t *pbuf = buf;\n\n                int buf_size;\n\n\n\n                avio_skip(pb, 8);\n\n                consumed += 8;\n\n                if (!ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) ||\n\n                    !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent)) {\n\n                    avio_skip(pb, 6);\n\n                    consumed += 6;\n\n                }\n\n\n\n                buf_size = FFMIN(len - consumed, sizeof(buf));\n\n                avio_read(pb, buf, buf_size);\n\n                consumed += buf_size;\n\n                ff_parse_mpeg2_descriptor(s, st, 0, &pbuf, buf + buf_size, NULL, 0, 0, NULL);\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_AudioTypeSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                AVStream *st = s->streams[stream_index];\n\n                int audio_type;\n\n                avio_skip(pb, 8);\n\n                audio_type = avio_r8(pb);\n\n                if (audio_type == 2)\n\n                    st->disposition |= AV_DISPOSITION_HEARING_IMPAIRED;\n\n                else if (audio_type == 3)\n\n                    st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED;\n\n                consumed += 9;\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_DVBScramblingControlSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                avio_skip(pb, 12);\n\n                if (avio_rl32(pb))\n\n                    av_log(s, AV_LOG_WARNING, \"DVB scrambled stream detected (st:%d), decoding will likely fail\\n\", stream_index);\n\n                consumed += 16;\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_LanguageSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                AVStream *st = s->streams[stream_index];\n\n                uint8_t language[4];\n\n                avio_skip(pb, 12);\n\n                avio_read(pb, language, 3);\n\n                if (language[0]) {\n\n                    language[3] = 0;\n\n                    av_dict_set(&st->metadata, \"language\", language, 0);\n\n                    if (!strcmp(language, \"nar\") || !strcmp(language, \"NAR\"))\n\n                        st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED;\n\n                }\n\n                consumed += 15;\n\n            }\n\n        } else if (!ff_guidcmp(g, ff_timestamp_guid)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                avio_skip(pb, 8);\n\n                wtv->pts = avio_rl64(pb);\n\n                consumed += 16;\n\n                if (wtv->pts == -1)\n\n                    wtv->pts = AV_NOPTS_VALUE;\n\n                else {\n\n                    wtv->last_valid_pts = wtv->pts;\n\n                    if (wtv->epoch == AV_NOPTS_VALUE || wtv->pts < wtv->epoch)\n\n                        wtv->epoch = wtv->pts;\n\n                if (mode == SEEK_TO_PTS && wtv->pts >= seekts) {\n\n                    avio_skip(pb, WTV_PAD8(len) - consumed);\n\n                    return 0;\n\n                }\n\n                }\n\n            }\n\n        } else if (!ff_guidcmp(g, ff_data_guid)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (mode == SEEK_TO_DATA && stream_index >= 0 && len > 32 && s->streams[stream_index]->priv_data) {\n\n                WtvStream *wst = s->streams[stream_index]->priv_data;\n\n                wst->seen_data = 1;\n\n                if (len_ptr) {\n\n                    *len_ptr = len;\n\n                }\n\n                return stream_index;\n\n            }\n\n        } else if (!ff_guidcmp(g, /* DSATTRIB_WMDRMProtectionInfo */ (const ff_asf_guid){0x83,0x95,0x74,0x40,0x9D,0x6B,0xEC,0x4E,0xB4,0x3C,0x67,0xA1,0x80,0x1E,0x1A,0x9B})) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0)\n\n                av_log(s, AV_LOG_WARNING, \"encrypted stream detected (st:%d), decoding will likely fail\\n\", stream_index);\n\n        } else if (\n\n            !ff_guidcmp(g, /* DSATTRIB_CAPTURE_STREAMTIME */ (const ff_asf_guid){0x14,0x56,0x1A,0x0C,0xCD,0x30,0x40,0x4F,0xBC,0xBF,0xD0,0x3E,0x52,0x30,0x62,0x07}) ||\n\n            !ff_guidcmp(g, /* DSATTRIB_PBDATAG_ATTRIBUTE */ (const ff_asf_guid){0x79,0x66,0xB5,0xE0,0xB9,0x12,0xCC,0x43,0xB7,0xDF,0x57,0x8C,0xAA,0x5A,0x7B,0x63}) ||\n\n            !ff_guidcmp(g, /* DSATTRIB_PicSampleSeq */ (const ff_asf_guid){0x02,0xAE,0x5B,0x2F,0x8F,0x7B,0x60,0x4F,0x82,0xD6,0xE4,0xEA,0x2F,0x1F,0x4C,0x99}) ||\n\n            !ff_guidcmp(g, /* DSATTRIB_TRANSPORT_PROPERTIES */ ff_DSATTRIB_TRANSPORT_PROPERTIES) ||\n\n            !ff_guidcmp(g, /* dvr_ms_vid_frame_rep_data */ (const ff_asf_guid){0xCC,0x32,0x64,0xDD,0x29,0xE2,0xDB,0x40,0x80,0xF6,0xD2,0x63,0x28,0xD2,0x76,0x1F}) ||\n\n            !ff_guidcmp(g, /* EVENTID_ChannelChangeSpanningEvent */ (const ff_asf_guid){0xE5,0xC5,0x67,0x90,0x5C,0x4C,0x05,0x42,0x86,0xC8,0x7A,0xFE,0x20,0xFE,0x1E,0xFA}) ||\n\n            !ff_guidcmp(g, /* EVENTID_ChannelInfoSpanningEvent */ (const ff_asf_guid){0x80,0x6D,0xF3,0x41,0x32,0x41,0xC2,0x4C,0xB1,0x21,0x01,0xA4,0x32,0x19,0xD8,0x1B}) ||\n\n            !ff_guidcmp(g, /* EVENTID_ChannelTypeSpanningEvent */ (const ff_asf_guid){0x51,0x1D,0xAB,0x72,0xD2,0x87,0x9B,0x48,0xBA,0x11,0x0E,0x08,0xDC,0x21,0x02,0x43}) ||\n\n            !ff_guidcmp(g, /* EVENTID_PIDListSpanningEvent */ (const ff_asf_guid){0x65,0x8F,0xFC,0x47,0xBB,0xE2,0x34,0x46,0x9C,0xEF,0xFD,0xBF,0xE6,0x26,0x1D,0x5C}) ||\n\n            !ff_guidcmp(g, /* EVENTID_SignalAndServiceStatusSpanningEvent */ (const ff_asf_guid){0xCB,0xC5,0x68,0x80,0x04,0x3C,0x2B,0x49,0xB4,0x7D,0x03,0x08,0x82,0x0D,0xCE,0x51}) ||\n\n            !ff_guidcmp(g, /* EVENTID_StreamTypeSpanningEvent */ (const ff_asf_guid){0xBC,0x2E,0xAF,0x82,0xA6,0x30,0x64,0x42,0xA8,0x0B,0xAD,0x2E,0x13,0x72,0xAC,0x60}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x1E,0xBE,0xC3,0xC5,0x43,0x92,0xDC,0x11,0x85,0xE5,0x00,0x12,0x3F,0x6F,0x73,0xB9}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x3B,0x86,0xA2,0xB1,0xEB,0x1E,0xC3,0x44,0x8C,0x88,0x1C,0xA3,0xFF,0xE3,0xE7,0x6A}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x4E,0x7F,0x4C,0x5B,0xC4,0xD0,0x38,0x4B,0xA8,0x3E,0x21,0x7F,0x7B,0xBF,0x52,0xE7}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x63,0x36,0xEB,0xFE,0xA1,0x7E,0xD9,0x11,0x83,0x08,0x00,0x07,0xE9,0x5E,0xAD,0x8D}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x70,0xE9,0xF1,0xF8,0x89,0xA4,0x4C,0x4D,0x83,0x73,0xB8,0x12,0xE0,0xD5,0xF8,0x1E}) ||\n\n            !ff_guidcmp(g, ff_index_guid) ||\n\n            !ff_guidcmp(g, ff_sync_guid) ||\n\n            !ff_guidcmp(g, ff_stream1_guid) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0xF7,0x10,0x02,0xB9,0xEE,0x7C,0xED,0x4E,0xBD,0x7F,0x05,0x40,0x35,0x86,0x18,0xA1})) {\n\n            //ignore known guids\n\n        } else\n\n            av_log(s, AV_LOG_WARNING, \"unsupported chunk:\"FF_PRI_GUID\"\\n\", FF_ARG_GUID(g));\n\n\n\n        avio_skip(pb, WTV_PAD8(len) - consumed);\n\n    }\n\n    return AVERROR_EOF;\n\n}\n", "idx": 9366, "substitutes": {"s": ["server", "setup", "ctx", "sym", "fts", "service", "cs", "self", "c", "a", "ks", "sv", "d", "sci", "sp", "b", "sites", "gs", "sn", "e", "comments", "rs", "os", "bis", "ls", "ss", "parser", "sq", "ins", "sb", "S", "ds", "session", "fs", "ssl", "ses", "qs", "sc", "f", "sf", "xs", "services", "sg", "secondary", "sl", "sim", "bs", "in", "v", "r", "ps", "l", "sync", "u", "sys", "su", "support", "sup", "is", "es", "p", "ts", "si", "ns", "spec", "client", "us", "t", "plugins", "m", "n", "sets", "sa", "data", "types", "ops"], "mode": [" flags", "format", " modes", " mem", " p", "c", " prog", "mod", "perm", "Mode", "gen", "scale", "MODE", "mem", "r", "mask", "dim", " perm", " bits", "m", " type", " m", "name"], "seekts": [" exte", "acttd", " extes", "actte", "actta", " exta", "wptd", "acttes", "wptes", "wpta", " extd", "wpte"], "len_ptr": [" len_tr", "len2pointer", "len2ptr", "len_pointer", "len2pt", "len2tr", " len_pt", "len64pointer", " len_pointer", "len64ptr", " len64tr", " len64pt", "len_tr", " len64pointer", "len64tr", " len64ptr", "len_pt", "len64pt"], "wtv": ["swcv", "wsv", "Wtv", "swv", "wvt", "Wcv", " wvt", "wwvt", "iwvt", "Wdev", "iwtv", " wv", "Wv", "iwdev", "wwdev", "iwsv", "wv", " wcv", "wwsv", "swtv", " wsv", "wcv", "wdev", " wdev", "wwtv", "swdev"], "pb": ["plugin", "bos", "phrase", "pg", "tp", "ctx", "bm", "dp", "pm", "api", "pl", "typ", "mp", "proc", "ppa", "bc", "parser", "rob", "bps", "db", "pc", "lb", "eb", "jp", "fe", "sb", "lp", "pd", "lab", "cpp", "p", "cb", "ib", "kb", "pkg", "asm", "b", "fm", "fb", "cp", "mb", "bh", "ub", "gb", "rb", "bs", "fp", "fc", "summary", "hub", "prot", "bb", "xb", "platform", "uf", "wp", "abb", "pp", "vp", "ab", "pa", "ob", "wb", "bp", "dl", "bf", "PB"], "g": ["ga", " eg", "f", " pg", "groups", "gram", "gm", "rg", "gu", "gg", "c", " prog", " msg", "gd", "game", "eg", "yg", " generator", "h", "p", "vg", "G", "tg", "sg", "gl", "gn", "gz", "ic", "bg", "generation", " mg", "gen", "gi", "og", "gb", "cfg", "go", "lang", "t", "gain", "r", "gp", "gin", "conn", " group", "gs", "m", "gat", " G", "msg", "gener", "reg", " gen", "alg", "gc", "ig", "group"], "len": ["la", "pos", "ann", "li", "sil", "fn", "lif", "ll", "id", "ls", "seq", "en", "bl", "split", "loc", "Len", "lit", "gl", "fl", "lim", "sl", "code", "num", "lin", "length", "el", "bin", "val", "l", "hl", "n", "lon", "ln", "lan", "syn", "lc", "fd", "fin", "dl", "data", "count", "lf"], "sid": ["gap", "sil", "sym", "src", "mid", "skin", "seq", "c", "pack", "chrom", "channel", "sn", "desc", "msg", "token", "syn", "sd", "id", "sit", "sb", "ity", "ds", "scope", "uin", "session", "end", "conn", "dim", "cod", "uid", "uni", "kid", "vid", "socket", "sl", "source", "oin", "_", "start", "su", "sk", "name", "pid", "x", "oa", "pos", "uri", "sam", "sample", "side", "addr", "offset", "si", "seed", "ident", "feed", "spec", "buffer", "data", "n", "sa", "typ"], "consumed": ["nsumption", "consipped", "continume", "persipped", "unsumed", "presumption", "unsipped", "consessed", "presumed", " unconsuming", "continuming", "consuming", "persumed", "continumed", "consumes", " consipped", "nsume", "nsuming", "unsessed", "nsumed", "cosumed", " consended", " unconsumed", "presuming", " unconsumes", "cosipped", " unconsended", "cosumes", " unconsessed", "presume", "consumption", "unsuming", " unconsipped", "cosended", " consumes", "consended", "consume", "persessed", "persuming", "continumption"], "mediatype": ["datatype", "medialyp", "mediatyp", "mediaattype", "mediadtype", "medietypes", "mediaantopic", "mediaratid", "datatid", "mediaetid", "mediastype", "metasime", "mediatime", "mediaype", "mediatopic", "medialopic", "servatingype", "mediaime", "servatotype", "mediaatopic", "mediantype", "mediaantype", "mediarattype", "servatingyp", "mediadype", "mediaatype", "mediatingopic", "mediatingotype", "mediaatid", "metatime", "datatypes", "medialotype", "mediasypes", "servatingotype", "servatingopic", "mediaopic", "mediaatyp", "datadid", "mediaettype", "mediartype", "mediasiyp", "mediartyp", "mediatypes", "mediadid", "mediape", "metasopic", "servatype", "mediasype", "mediatingyp", "mediasiype", "mediantpe", "mediadypes", "mediartid", "metaspe", "mediayp", "metatopic", "mediasime", "medietype", "medietyp", "mediatpe", "datadype", "datadypes", "mediarttype", "mediasopic", "mediaatypes", "mediaantypes", "datadtype", "mediasiotype", "medietid", "mediaetyp", "metasype", "medialype", "metatpe", "mediantopic", "mediaid", "mediasiopic", "mediaanttype", "medianttype", "mediatotype", "servatyp", "mediantypes", "servatopic", "mediaspe", "mediaypes", "datattype", "mediaratype", "mediatingype", "mediantime", "mediettype", "metatype", "mediaetype", "mediattype", "mediatid", "mediaratypes"], "subtype": ["Subype", "shortype", " subid", "broadype", "formatparent", "formatid", "texttype", "Subtype", "formatname", "singname", "subid", "ubname", "formid", "broadtype", "formattypes", "formblock", "parttype", "partype", "subname", "Subid", "singtype", "singid", "formtype", "ubid", "ubtype", "parttypes", "textparent", "Subname", "singtypes", "broadtypes", "exttype", "shortid", "extblock", "extid", "subype", "textname", " subtypes", "formatblock", " subype", "shorttype", "formatype", "subparent", "formype", "ubtypes", "textype", "subtypes", "subblock", "shortname", "extype", " subname", " subparent"], "formattype": ["cattype", "typetype", "partformat", "formatid", "titlename", "formatname", " formatname", " formatblock", "titlefamily", "versionType", "subid", "versionname", "unitype", "formid", "unitid", "subType", "parttype", " formatfamily", "partype", "catstyle", "unitname", " formatype", "formatType", "titletype", "unittype", "subname", "formType", "typeblock", "formtype", "partstyle", "formatformat", "catformat", "subformat", "subype", "formatblock", "substyle", "formatype", "typefamily", " formatid", "formype", " formatType", "typeype", "formatstyle", "catype", "formname", "typeid", "typename", "formatfamily", "titleblock", "versionype", "versiontype"], "size": ["sized", "timeout", "SIZE", "message", "capacity", "empty", "type", "id", "weight", "class", "external", "engine", "white", "small", "bytes", "esc", "offset", "content", "fee", "member", "loc", "gn", "shape", "style", "hh", "shell", "scale", "ize", "address", "code", "Size", " sizes", "length", "ui", "area", "time", "sync", "body", "iz", "data", "speed", "unit", "value", "storage", "large", "sec", "mini", "name", "grade", "send", "extra", "count", "align", "sum"]}}
{"project": "qemu", "commit_id": "db12451decf7dfe0f083564183e135f2095228b9", "target": 1, "func": "static void virtio_rng_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n\n\n    dc->props = virtio_rng_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    vdc->realize = virtio_rng_device_realize;\n\n    vdc->unrealize = virtio_rng_device_unrealize;\n\n    vdc->get_features = get_features;\n\n    vdc->load = virtio_rng_load_device;\n\n}\n", "idx": 9399, "substitutes": {"klass": [" kcl", "kazz", "skcl", "skazz", "Kazz", "Kclass", "Klass", " kclass", "kclass", "sklass", "skclass", " klasses", "klasses", "sklasses", "kcl", "Kcl", "Klasses", " kazz"], "data": ["dat", "ata", "loader", "device", "Data", "api", "result", "i", "d", "params", "DATA", "config", "cb", "after", "input", "options", "ds", "array", "di", "dd", "parent", "reader", "da", "def", "info", "cache"], "dc": ["dat", "ga", "abc", "cdn", "nc", "DC", "bc", "vc", "cci", "c", "db", "ca", "pc", "design", "d", "disc", "cb", "ds", "cm", "director", "cu", "ct", "enter", "cc", "di", "fc", "ac", "df", "da", "cf", "conn", "sc", "cr", "tc", "mc", "ec", "lc", " DC", "cca", "gc", "dt", "cd"], "vdc": ["gdi", " vcd", "vfc", "gfc", "Vdk", "gdc", "gmc", "nvcd", "fdc", "pcc", "Vcd", "ffc", "lvdi", "vc", "lvdc", "VDC", "Vdc", "Vdi", "pcd", "vcf", "Vmc", " vmc", "nvcc", " vcc", "vsdc", "vsdk", " vdi", " vc", "dDC", "ddc", "vnc", "pmc", "Vcf", "dcd", "vDC", "lvcf", "pdc", "fc", "fdi", " vfc", "vdk", "Vc", "vdi", "gcf", "vsDC", "vmc", " vnc", "vcd", "nvmc", "gnc", "ddk", "lvmc", "gc", "vcc", "vscd", "nvdc", "Vnc"]}}
{"project": "qemu", "commit_id": "f65ed4c1529f29a7d62d6733eaa50bed24a4b2ed", "target": 1, "func": "int kvm_init(int smp_cpus)\n{\n    KVMState *s;\n    int ret;\n    int i;\n    if (smp_cpus > 1)\n        return -EINVAL;\n    s = qemu_mallocz(sizeof(KVMState));\n    if (s == NULL)\n        return -ENOMEM;\n    for (i = 0; i < ARRAY_SIZE(s->slots); i++)\n        s->slots[i].slot = i;\n    s->vmfd = -1;\n    s->fd = open(\"/dev/kvm\", O_RDWR);\n    if (s->fd == -1) {\n        fprintf(stderr, \"Could not access KVM kernel module: %m\\n\");\n        ret = -errno;\n        goto err;\n    }\n    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);\n    if (ret < KVM_API_VERSION) {\n            ret = -EINVAL;\n        fprintf(stderr, \"kvm version too old\\n\");\n        goto err;\n    }\n    if (ret > KVM_API_VERSION) {\n        ret = -EINVAL;\n        fprintf(stderr, \"kvm version not supported\\n\");\n        goto err;\n    }\n    s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0);\n    if (s->vmfd < 0)\n        goto err;\n    /* initially, KVM allocated its own memory and we had to jump through\n     * hooks to make phys_ram_base point to this.  Modern versions of KVM\n     * just use a user allocated buffer so we can use phys_ram_base\n     * unmodified.  Make sure we have a sufficiently modern version of KVM.\n     */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, KVM_CAP_USER_MEMORY);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr, \"kvm does not support KVM_CAP_USER_MEMORY\\n\");\n        goto err;\n    }\n    /* There was a nasty bug in < kvm-80 that prevents memory slots from being\n     * destroyed properly.  Since we rely on this capability, refuse to work\n     * with any kernel without this capability. */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION,\n                    KVM_CAP_DESTROY_MEMORY_REGION_WORKS);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr,\n                \"KVM kernel module broken (DESTROY_MEMORY_REGION)\\n\"\n                \"Please upgrade to at least kvm-81.\\n\");\n        goto err;\n    }\n    ret = kvm_arch_init(s, smp_cpus);\n    if (ret < 0)\n        goto err;\n    kvm_state = s;\n    return 0;\nerr:\n    if (s) {\n        if (s->vmfd != -1)\n            close(s->vmfd);\n        if (s->fd != -1)\n            close(s->fd);\n    }\n    qemu_free(s);\n    return ret;\n}", "idx": 9418, "substitutes": {"smp_cpus": ["smp_mpis", "smp_gpus", "smp_cpis", "smp_pis", "smp_mpu", "smp_gpul", "smp_gpuses", "smp_cpu", "smp_ipus", "smp_ipis", "smp_gpis", "smp_mpus", "smp_pus", "smp_pul", "smp_cpul", "smp_ipu", "smp_mpuses", "smp_gpu", "smp_ipuses", "smp_cpuses", "smp_puses", "smp_mpul"], "s": ["server", "sym", "service", "cs", "self", "c", "d", "settings", "b", "native", "gs", "w", "as", "e", "secure", "rs", "js", "status", "os", "groups", "site", "bis", "ls", "ss", "sq", "sb", "h", "http", "S", "session", "ds", "scope", "fs", "ssl", "j", "o", "ses", "qs", "set", "sec", "tests", "f", "k", "sf", "xs", "y", "stat", "services", "sg", "socket", "secondary", "sl", "in", "v", "r", "ps", "l", "sync", "current", "south", "sys", "su", "sk", "x", "g", "args", "state", "states", "is", "sup", "new", "es", "ts", "p", "si", "se", "ns", "spec", "client", "us", "t", "your", "m", "conf", "n", "sets", "storage", "sa", "aws"], "ret": ["rt", "re", "RET", "ref", "err", "success", "lt", "art", " Ret", "rc", "red", "key", "mem", "pet", "job", "arg", "pat", "info", "nt", "true", "alt", "Ret", "status", "hash", "feat", "pass", "rets", "id", "rev", "result", "db", "cat", "back", "rl", "lit", "j", "flag", "pt", "end", "mt", "ut", "code", "num", "fail", "error", "det", "conn", "res", "reg", "str", "sur", "valid", "att", "resp", "len", " RET", "fun", "part", "req", "reply", "fit", "bad", "post", "no", "match", "ft", "nb", "al", "cb", "arr", "sat", "url", "bit", "rb", "gt", "opt", "val", "af", "def", "not", "bf", "bot", "let"], "i": ["ii", "ni", "abi", "li", "uri", "f", "id", "phi", "I", "k", "mu", "err", "ip", "oi", "mi", "fi", "y", "c", "ki", "iu", "ini", "d", "multi", "slice", "p", "ri", "si", "sp", "b", "pi", "io", "uli", "j", "gi", "ie", "part", "key", "di", "xi", "zi", "bi", "ti", "qi", "t", "ui", "ind", "o", "l", "ci", "u", "index", "dim", "m", "init", "e", "base", "n", "ai", "eni", "uni", "x", "ix", "it"]}}
{"project": "qemu", "commit_id": "7c24384b3b984f0256ba10eb26d877ec28985019", "target": 1, "func": "static int64_t nfs_client_open(NFSClient *client, const char *filename,\n\n                               int flags, Error **errp)\n\n{\n\n    int ret = -EINVAL, i;\n\n    struct stat st;\n\n    URI *uri;\n\n    QueryParams *qp = NULL;\n\n    char *file = NULL, *strp = NULL;\n\n\n\n    uri = uri_parse(filename);\n\n    if (!uri) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    if (!uri->server) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    strp = strrchr(uri->path, '/');\n\n    if (strp == NULL) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    file = g_strdup(strp);\n\n    *strp = 0;\n\n\n\n    client->context = nfs_init_context();\n\n    if (client->context == NULL) {\n\n        error_setg(errp, \"Failed to init NFS context\");\n\n        goto fail;\n\n    }\n\n\n\n    qp = query_params_parse(uri->query);\n\n    for (i = 0; i < qp->n; i++) {\n\n        if (!qp->p[i].value) {\n\n            error_setg(errp, \"Value for NFS parameter expected: %s\",\n\n                       qp->p[i].name);\n\n            goto fail;\n\n        }\n\n        if (!strncmp(qp->p[i].name, \"uid\", 3)) {\n\n            nfs_set_uid(client->context, atoi(qp->p[i].value));\n\n        } else if (!strncmp(qp->p[i].name, \"gid\", 3)) {\n\n            nfs_set_gid(client->context, atoi(qp->p[i].value));\n\n        } else if (!strncmp(qp->p[i].name, \"tcp-syncnt\", 10)) {\n\n            nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value));\n\n        } else {\n\n            error_setg(errp, \"Unknown NFS parameter name: %s\",\n\n                       qp->p[i].name);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_mount(client->context, uri->server, uri->path);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to mount nfs share: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    if (flags & O_CREAT) {\n\n        ret = nfs_creat(client->context, file, 0600, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to create file: %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    } else {\n\n        ret = nfs_open(client->context, file, flags, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to open file : %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_fstat(client->context, client->fh, &st);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to fstat file: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE);\n\n    client->has_zero_init = S_ISREG(st.st_mode);\n\n    goto out;\n\nfail:\n\n    nfs_client_close(client);\n\nout:\n\n    if (qp) {\n\n        query_params_free(qp);\n\n    }\n\n    uri_free(uri);\n\n    g_free(file);\n\n    return ret;\n\n}\n", "idx": 9434, "substitutes": {"client": ["container", "server", "plugin", "remote", "prefix", "ctx", "request", "service", "local", "api", "host", "https", "connection", "private", "ce", "c", "user", "single", "public", "Client", "event", "config", "http", "session", "app", "cell", "ssl", "worker", "socket", "queue", "con", "project", "context", "open", "cli", "package", "image", "entry", "reader", "handler", "gui", "get", "command", "call", "conn", "chrome", "cod", "wrapper", "current", "child", "util", "custom", "storage", "google", "manager", "consumer", "cache"], "filename": ["binary", "prefix", "fn", "phrase", "f", "loader", "directory", "utf", "path", "buf", "connection", "folder", "username", "content", "password", "rl", "dll", "title", "database", "url", "files", "kl", "il", "fp", "Filename", "source", "tty", "which", "bf", "buffer", "fil", "fd", "name", "txt", "slice", "acl"], "flags": ["lag", "args", "mode", "format", "FLAG", " flag", "bytes", "options", "ips", "fun", "fs", "gen", "flag", "files", "bit", " Flags", "rep", "mask", "errors", " bits", "bits", "util", "Flags", "s", "status", "stats", "ops", "features"], "errp": ["rrpre", "rarp", "erpre", "finderp", "yrp", "lerfp", "err", "errorpc", "rarpa", "acerpi", "errpr", "acerpr", " errpre", "asterlp", "ferp", "arrpa", "errb", "finderfp", "finderping", "rrp", "errpo", "errorping", "errP", "lerlp", "rarsp", "armp", " errfp", "arrpo", "arrp", "yrb", "erping", "arrfp", "errping", "asterpr", "lerp", "erpr", "ferlp", "armfp", "armsp", "argpe", "armpa", "errr", "errfp", "lerpc", "errpre", "errorfp", "errpa", "armpo", "errorp", " errlp", "erp", " errpc", "armpr", "errpc", "rarpo", "ferfp", "rrr", "erP", "errpe", "argp", "ferpi", "finderpc", "erpc", "errorpe", "errsp", "erfp", "yrpe", "errlp", "asterpi", " errr", "erpo", "yrpa", "errorpa", "argb", " errP", "acerp", "rrP", "errorb", "arrsp", "ferpc", "asterp", "arrpr", "ferpr", "argpa", "errpi", "acerlp"], "i": ["li", "mu", "err", "ip", "mi", "chi", "c", "d", "ri", "b", "bi", "ui", "ci", "init", "e", "info", "ai", "eni", "status", "line", "ii", "idi", "ni", "id", "phi", "oi", "result", "adi", "jit", "j", "ie", "z", "xi", "hi", "qi", "o", "ret", "abi", "f", "y", "gu", "yi", "gi", "di", "ti", "v", "in", "r", "source", "l", "u", "index", "start", "lc", "x", "ix", "g", "type", "I", "fi", "iu", "ini", "is", "multi", "dr", "ji", "p", "si", "isi", "pi", "io", "inner", "ori", "cli", "iv", "t", "m", "n", "slice"], "st": ["et", "istic", "no", "sth", "f", "ost", "ist", "fi", " sc", "fe", "ST", "ct", "ld", "est", "code", "v", "r", "std", "l", "sc", "func", "obj", "nt", "stream", "x", "str"], "uri": ["server", "plugin", "binary", "directory", "service", "attribute", "path", "api", "mi", "metadata", "connection", "folder", "adi", "parser", "URI", "ini", "route", "transfer", "username", "multi", "config", "term", "ri", "document", "doi", "http", "si", "pi", "io", "database", "ori", "archive", "url", "gi", " URI", "cli", "umi", "address", "package", "di", "qi", "reader", "ui", "source", "resource", "handler", "gui", "ci", "ir", "git", "component", "query", "unit", "storage", "eni", "iri", "uni", "manager", "processor", "location", "slice"], "qp": ["requl", "requpre", "qpr", "sqpr", "qpc", " qb", " qf", "sqm", "pgh", "pgpr", "pgp", " qm", "qm", "qf", "ppp", "sqps", "qupc", "qnp", "qpart", " qr", "questp", "idpc", "idp", " qn", "ppps", "sqc", "sqP", "quv", "queste", "quc", "sqtp", " qfp", "sqop", "quz", "qe", "qop", "questpoint", "sqq", "Qp", "questl", "qup", "qi", "Qi", "qs", "qv", "qub", "sqs", "qq", "qc", "qpoint", "reqop", "sqnp", "QP", "Qps", "qufp", "sqpre", "sqf", "questq", "sqz", "sqi", "qunp", "sqr", "quq", "qP", "pgb", "reqnp", "sqe", "sqfp", "questv", "sqpoint", "ppP", "questpart", "qul", "qz", "sqn", "ppi", "questh", "qn", "sqp", "idv", "que", "Qs", " qs", "quop", "sqh", "quh", "qun", "qupr", "qutp", "sqpc", "ql", "questz", "sqb", "sql", "qfp", "qupoint", "requp", "sqv", "reql", "questf", "qps", "sqpart", "idh", "qupre", "qtp", "requh", "qupart", " qtp", "qum", " qc", "Qr", "Qc", "qpre", "quf", "qr", "qh", "qb", "reqp"], "file": ["live", "pipe", "f", "format", "comment", "local", "path", "ignore", "folder", "File", "ile", "offset", "http", "io", "queue", "full", "files", "pic", "flag", "feed", "rule", "part", "fat", "il", "image", "parent", "source", "resource", "get", "buffer", "current", "base", "unit", "info", "line", "root", "name", "data", "dir", "cache"], "strp": ["rrp", " strn", "strn", "Strp", "yrp", "arrpe", " strP", "stripc", "drlp", "trn", "arrpc", " strpc", "trP", "Strfp", "yrlp", "Strpa", "nerpi", "strpi", "StrP", "nerp", "trpe", "strpatch", "drpc", "strb", " strpr", "Strpc", "arrlp", "Strpr", "irpa", "rrpatch", "strifp", "strib", "yrpe", "Strn", "strpe", " strpatch", "strpc", "strpr", "irpi", "nerpa", " strb", "drp", "strlp", "yrpc", "trp", "Strpatch", "arrp", "strfp", "nerP", "strP", "rrP", "strip", " strfp", "irp", "irP", "strpa", "Strb", "rrpr", "Strpi", " strpe", "Strpe", "drpe"]}}
{"project": "FFmpeg", "commit_id": "6f7f2396049575fcf2054b4dafa19ca01381638e", "target": 1, "func": "static int nut_read_header(AVFormatContext * avf, AVFormatParameters * ap) {\n\n    NUTContext * priv = avf->priv_data;\n\n    AVIOContext * bc = avf->pb;\n\n    nut_demuxer_opts_tt dopts = {\n\n        .input = {\n\n            .priv = bc,\n\n            .seek = av_seek,\n\n            .read = av_read,\n\n            .eof = NULL,\n\n            .file_pos = 0,\n\n        },\n\n        .alloc = { av_malloc, av_realloc, av_free },\n\n        .read_index = 1,\n\n        .cache_syncpoints = 1,\n\n    };\n\n    nut_context_tt * nut = priv->nut = nut_demuxer_init(&dopts);\n\n    nut_stream_header_tt * s;\n\n    int ret, i;\n\n\n\n    if ((ret = nut_read_headers(nut, &s, NULL))) {\n\n        av_log(avf, AV_LOG_ERROR, \" NUT error: %s\\n\", nut_error(ret));\n\n\n        return -1;\n\n\n\n\n    priv->s = s;\n\n\n\n    for (i = 0; s[i].type != -1 && i < 2; i++) {\n\n        AVStream * st = avformat_new_stream(avf, NULL);\n\n        int j;\n\n\n\n        for (j = 0; j < s[i].fourcc_len && j < 8; j++) st->codec->codec_tag |= s[i].fourcc[j]<<(j*8);\n\n\n\n        st->codec->has_b_frames = s[i].decode_delay;\n\n\n\n        st->codec->extradata_size = s[i].codec_specific_len;\n\n        if (st->codec->extradata_size) {\n\n            st->codec->extradata = av_mallocz(st->codec->extradata_size);\n\n\n\n\n\n            memcpy(st->codec->extradata, s[i].codec_specific, st->codec->extradata_size);\n\n\n\n\n        avpriv_set_pts_info(avf->streams[i], 60, s[i].time_base.num, s[i].time_base.den);\n\n        st->start_time = 0;\n\n        st->duration = s[i].max_pts;\n\n\n\n        st->codec->codec_id = ff_codec_get_id(nut_tags, st->codec->codec_tag);\n\n\n\n        switch(s[i].type) {\n\n        case NUT_AUDIO_CLASS:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_wav_tags, st->codec->codec_tag);\n\n\n\n            st->codec->channels = s[i].channel_count;\n\n            st->codec->sample_rate = s[i].samplerate_num / s[i].samplerate_denom;\n\n            break;\n\n        case NUT_VIDEO_CLASS:\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_bmp_tags, st->codec->codec_tag);\n\n\n\n            st->codec->width = s[i].width;\n\n            st->codec->height = s[i].height;\n\n            st->sample_aspect_ratio.num = s[i].sample_width;\n\n            st->sample_aspect_ratio.den = s[i].sample_height;\n\n            break;\n\n\n        if (st->codec->codec_id == CODEC_ID_NONE) av_log(avf, AV_LOG_ERROR, \"Unknown codec?!\\n\");\n\n\n\n\n    return 0;\n", "idx": 9435, "substitutes": {"avf": ["apfs", "ajF", "afsf", " avc", "avcf", "umF", "affac", "avm", "auF", "avF", "aff", "afc", "avlf", "evf", "umcf", "evfac", "avfp", "avfs", "auc", "avd", "ajlf", "absf", "AVsf", "evfs", "avc", "avfac", " avj", "afd", "abcf", "afj", "afcf", "affp", "umf", "aufp", " avfs", "AVcf", " avfac", "apF", "awm", "evlf", "ajf", "awf", "aud", "AVfs", "avfe", "auf", "affe", "abfs", "umfp", "avj", "avsf", "affs", " avF", "AVf", "afF", "abf", "aucf", "aum", "awd", "evF", "auj", "aufe", "afm", "awfe", "aplf", "apf", "ajfs"], "ap": ["prop", "arp", "np", "tp", "att", "apt", "api", "au", "aps", "arr", "sp", "cp", "ar", "array", "ac", "op", "attr", "mac", "wp", "am", "ab", "map", "oc", "AP", "cap", "ams", "ad", "av"], "priv": ["tr", "oca", "np", "ocr", "pub", "ctx", "tu", "pro", "ptr", "anc", "vt", "aux", "proc", "raf", "private", "sub", "pb", "pc", "cmp", "sb", "config", "rc", "auth", "cb", "ib", "temp", "p", "pri", "pi", "cp", "gb", "cfg", "Priv", "soc", "iv", "tmp", "access", "fp", "prep", "roc", "txt", "store", "ci", "conn", "dev", "org", "ty", "trust", "tx", "obj", "info", "storage", "mc", "sec", "uc", "riv", "cert", "rib", "sa", "data", "pid", "cache"], "bc": ["BC", "ctx", "nc", "c", "pc", "ca", "rc", "cb", "ib", "cm", "BBC", "cp", "ct", "context", "soc", "cc", "fc", "dc", "cms", "ac", "fp", "cl", "cf", "sc", "ci", "cus", "tc", "lc", "uc", "mc", "CBC", "ec", "bf", "isc"], "nut": ["ctr", "nuts", "np", "timeout", "fn", "ocr", "rt", "ott", "cit", "cut", "ou", "utt", "art", "cart", "config", "cb", "ot", "boot", "annot", "orb", "ct", "ut", "fat", "nit", "aft", "nat", "tmp", "rot", "bd", "pot", "orn", "cf", "conn", "cot", "obj", "n", "cue", "nt", "cro", "tun", "dt", "tube", "stab"], "s": ["server", "setup", "service", "cs", "c", "a", "ks", "sv", "d", "lines", "sp", "settings", "b", "sts", "summary", "native", "sites", "gs", "series", "sn", "e", "comments", "strings", "status", "js", "os", "groups", "its", "ls", "ss", "sq", "sb", "h", "S", "ds", "sie", "student", "ssl", "fs", "ms", "o", "ses", "qs", "tests", "f", "parts", "sf", "xs", "times", "services", "sg", "details", "socket", "secondary", "sl", "v", "source", "ps", "l", "sync", "sys", "su", "rates", "apps", "g", "args", "events", "states", "is", "es", "p", "ts", "si", "ns", "spec", "t", "n", "sets", "storage", "sa", "stats"], "ret": ["tr", "valid", "rt", "rets", "id", "att", "resp", "re", "RET", "ref", "err", "repl", "ft", "result", "len", "iter", "art", " RET", "rc", "cat", "cur", "temp", "back", "sp", "lit", "fun", "flag", "mt", "red", "fat", "mem", "num", "fail", "r", "val", "det", "rep", "pet", "def", "reply", "xt", "obj", "isf", "res", "nt", "out", "reg", "sec", "alt", "Ret", "bad", "str"], "i": ["li", "ip", "mi", "chi", "c", "d", "ri", "b", "bi", "ui", "ci", "init", "e", "info", "ai", "eni", "it", "ii", "ni", "id", "phi", "api", "oi", "jit", "module", "h", "ib", "ie", "hi", "zi", "xi", "qi", "f", "y", "yi", "cell", "ish", "gi", "part", "di", "ti", "v", "source", "ik", "l", "u", "index", "ij", "lc", "mini", "x", "ix", "g", "uri", "type", "I", "fi", "iu", "ini", "sup", "ji", "p", "si", "isi", "pi", "inner", "io", "ori", "interface", "cli", "iv", "m", "n"], "st": ["put", "fr", "sd", "rt", "sth", "src", "ost", "ist", "elt", "ss", "ft", "td", "lt", "art", "sr", "d", "sb", "bl", "p", "ts", "spect", "rd", "stage", "sp", "sta", "ste", "ST", "sh", "ct", "nd", "ld", "sts", "pt", "end", "mt", "se", "sl", "est", "ut", "kt", "tmp", "t", "r", "std", "ust", "sc", "start", "sn", "dt", "post", "ast", "trans", "St", "set", "nt", "rest", "sa", "stream", "inst", "stop", "str"], "j": ["ii", "g", "ni", "bj", "adj", "li", "im", "fr", "size", "f", "other", "k", "note", "jo", "je", "x", "jet", "jit", "uj", "y", "jp", "ja", "d", "h", "ji", "p", "ib", "pr", "dy", "jen", "b", "kj", "jl", "ie", "json", "key", "z", "v", "J", "o", "br", "ind", "length", "oj", "l", "q", "job", "ij", "obj", "n", "child", "jj", "e", "dj", "js", "name", "aj", "syn", "jc", "it"]}}
{"project": "qemu", "commit_id": "41264b385c2b324fea026204e5de9bef980733b1", "target": 1, "func": "static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)\n{\n    CPUState *cs = CPU(dev);\n    PowerPCCPU *cpu = POWERPC_CPU(dev);\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);\n    Error *local_err = NULL;\n#if !defined(CONFIG_USER_ONLY)\n    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;\n#endif\n#if !defined(CONFIG_USER_ONLY)\n    if (smp_threads > max_smt) {\n        error_setg(errp, \"Cannot support more than %d threads on PPC with %s\",\n                   max_smt, kvm_enabled() ? \"KVM\" : \"TCG\");\n    if (!is_power_of_2(smp_threads)) {\n        error_setg(errp, \"Cannot support %d threads on PPC with %s, \"\n                   \"threads count must be a power of 2.\",\n                   smp_threads, kvm_enabled() ? \"KVM\" : \"TCG\");\n#endif\n    cpu_exec_init(cs, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n#if !defined(CONFIG_USER_ONLY)\n    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt\n        + (cs->cpu_index % smp_threads);\n#endif\n    if (tcg_enabled()) {\n        if (ppc_fixup_cpu(cpu) != 0) {\n            error_setg(errp, \"Unable to emulate selected CPU with TCG\");\n#if defined(TARGET_PPCEMB)\n    if (!ppc_cpu_is_valid(pcc)) {\n        error_setg(errp, \"CPU does not possess a BookE or 4xx MMU. \"\n                   \"Please use qemu-system-ppc or qemu-system-ppc64 instead \"\n                   \"or choose another CPU model.\");\n#endif\n    create_ppc_opcodes(cpu, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n    init_ppc_proc(cpu);\n    if (pcc->insns_flags & PPC_FLOAT) {\n        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,\n                                 33, \"power-fpu.xml\", 0);\n    if (pcc->insns_flags & PPC_ALTIVEC) {\n        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,\n                                 34, \"power-altivec.xml\", 0);\n    if (pcc->insns_flags & PPC_SPE) {\n        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,\n                                 34, \"power-spe.xml\", 0);\n    if (pcc->insns_flags2 & PPC2_VSX) {\n        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,\n                                 32, \"power-vsx.xml\", 0);\n    qemu_init_vcpu(cs);\n    pcc->parent_realize(dev, errp);\n#if defined(PPC_DUMP_CPU)\n    {\n        CPUPPCState *env = &cpu->env;\n        const char *mmu_model, *excp_model, *bus_model;\n        switch (env->mmu_model) {\n        case POWERPC_MMU_32B:\n            mmu_model = \"PowerPC 32\";\n            break;\n        case POWERPC_MMU_SOFT_6xx:\n            mmu_model = \"PowerPC 6xx/7xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_74xx:\n            mmu_model = \"PowerPC 74xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_4xx:\n            mmu_model = \"PowerPC 4xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_4xx_Z:\n            mmu_model = \"PowerPC 4xx with software driven TLBs \"\n                \"and zones protections\";\n            break;\n        case POWERPC_MMU_REAL:\n            mmu_model = \"PowerPC real mode only\";\n            break;\n        case POWERPC_MMU_MPC8xx:\n            mmu_model = \"PowerPC MPC8xx\";\n            break;\n        case POWERPC_MMU_BOOKE:\n            mmu_model = \"PowerPC BookE\";\n            break;\n        case POWERPC_MMU_BOOKE206:\n            mmu_model = \"PowerPC BookE 2.06\";\n            break;\n        case POWERPC_MMU_601:\n            mmu_model = \"PowerPC 601\";\n            break;\n#if defined (TARGET_PPC64)\n        case POWERPC_MMU_64B:\n            mmu_model = \"PowerPC 64\";\n            break;\n#endif\n        default:\n            mmu_model = \"Unknown or invalid\";\n            break;\n        switch (env->excp_model) {\n        case POWERPC_EXCP_STD:\n            excp_model = \"PowerPC\";\n            break;\n        case POWERPC_EXCP_40x:\n            excp_model = \"PowerPC 40x\";\n            break;\n        case POWERPC_EXCP_601:\n            excp_model = \"PowerPC 601\";\n            break;\n        case POWERPC_EXCP_602:\n            excp_model = \"PowerPC 602\";\n            break;\n        case POWERPC_EXCP_603:\n            excp_model = \"PowerPC 603\";\n            break;\n        case POWERPC_EXCP_603E:\n            excp_model = \"PowerPC 603e\";\n            break;\n        case POWERPC_EXCP_604:\n            excp_model = \"PowerPC 604\";\n            break;\n        case POWERPC_EXCP_7x0:\n            excp_model = \"PowerPC 740/750\";\n            break;\n        case POWERPC_EXCP_7x5:\n            excp_model = \"PowerPC 745/755\";\n            break;\n        case POWERPC_EXCP_74xx:\n            excp_model = \"PowerPC 74xx\";\n            break;\n        case POWERPC_EXCP_BOOKE:\n            excp_model = \"PowerPC BookE\";\n            break;\n#if defined (TARGET_PPC64)\n        case POWERPC_EXCP_970:\n            excp_model = \"PowerPC 970\";\n            break;\n#endif\n        default:\n            excp_model = \"Unknown or invalid\";\n            break;\n        switch (env->bus_model) {\n        case PPC_FLAGS_INPUT_6xx:\n            bus_model = \"PowerPC 6xx\";\n            break;\n        case PPC_FLAGS_INPUT_BookE:\n            bus_model = \"PowerPC BookE\";\n            break;\n        case PPC_FLAGS_INPUT_405:\n            bus_model = \"PowerPC 405\";\n            break;\n        case PPC_FLAGS_INPUT_401:\n            bus_model = \"PowerPC 401/403\";\n            break;\n        case PPC_FLAGS_INPUT_RCPU:\n            bus_model = \"RCPU / MPC8xx\";\n            break;\n#if defined (TARGET_PPC64)\n        case PPC_FLAGS_INPUT_970:\n            bus_model = \"PowerPC 970\";\n            break;\n#endif\n        default:\n            bus_model = \"Unknown or invalid\";\n            break;\n        printf(\"PowerPC %-12s : PVR %08x MSR %016\" PRIx64 \"\\n\"\n               \"    MMU model        : %s\\n\",\n               object_class_get_name(OBJECT_CLASS(pcc)),\n               pcc->pvr, pcc->msr_mask, mmu_model);\n#if !defined(CONFIG_USER_ONLY)\n        if (env->tlb.tlb6) {\n            printf(\"                       %d %s TLB in %d ways\\n\",\n                   env->nb_tlb, env->id_tlbs ? \"splitted\" : \"merged\",\n                   env->nb_ways);\n#endif\n        printf(\"    Exceptions model : %s\\n\"\n               \"    Bus model        : %s\\n\",\n               excp_model, bus_model);\n        printf(\"    MSR features     :\\n\");\n        if (env->flags & POWERPC_FLAG_SPE)\n            printf(\"                        signal processing engine enable\"\n                   \"\\n\");\n        else if (env->flags & POWERPC_FLAG_VRE)\n            printf(\"                        vector processor enable\\n\");\n        if (env->flags & POWERPC_FLAG_TGPR)\n            printf(\"                        temporary GPRs\\n\");\n        else if (env->flags & POWERPC_FLAG_CE)\n            printf(\"                        critical input enable\\n\");\n        if (env->flags & POWERPC_FLAG_SE)\n            printf(\"                        single-step trace mode\\n\");\n        else if (env->flags & POWERPC_FLAG_DWE)\n            printf(\"                        debug wait enable\\n\");\n        else if (env->flags & POWERPC_FLAG_UBLE)\n            printf(\"                        user BTB lock enable\\n\");\n        if (env->flags & POWERPC_FLAG_BE)\n            printf(\"                        branch-step trace mode\\n\");\n        else if (env->flags & POWERPC_FLAG_DE)\n            printf(\"                        debug interrupt enable\\n\");\n        if (env->flags & POWERPC_FLAG_PX)\n            printf(\"                        inclusive protection\\n\");\n        else if (env->flags & POWERPC_FLAG_PMM)\n            printf(\"                        performance monitor mark\\n\");\n        if (env->flags == POWERPC_FLAG_NONE)\n            printf(\"                        none\\n\");\n        printf(\"    Time-base/decrementer clock source: %s\\n\",\n               env->flags & POWERPC_FLAG_RTC_CLK ? \"RTC clock\" : \"bus clock\");\n        dump_ppc_insns(env);\n        dump_ppc_sprs(env);\n        fflush(stdout);\n#endif", "idx": 9437, "substitutes": {"dev": ["debug", "dem", "bus", "tr", "de", "hw", "sd", "pub", "loader", "device", "pro", "devices", "cow", "proc", "comp", "dom", "serial", "rad", "ver", "user", "d", "pu", "node", "pack", "ev", "mod", "Dev", "test", "grad", "prof", "spec", "prov", "ch", "mac", "req", "def", "conn", "cam", "conf", "priv", "data", "cache"], "errp": ["rrp", " errping", "erpre", "errc", " erb", "arrpe", "Erc", "rrb", "err", "errsp", "erfp", " errt", "errP", " errc", "errr", "arrf", "ErP", "errfp", " errpre", "errf", "Err", "errpre", " errsp", "derp", "derc", "rrf", "callp", "derr", "errorfp", "errb", " errf", "errorp", "rrpe", "erp", "errorP", " erf", "errorf", "errt", " erp", " errr", "callc", " errfp", "rrfp", "rrc", " errb", "erf", "arrp", " ert", " errP", "callsp", " errpe", "rrP", "erc", "errorpre", "arrc", "callf", "errorb", "erP", "erping", "rrsp", " err", " erping", "Erp", "errpe", "derP", "errping", "errort"], "cs": ["cas", "tests", "utils", "os", "ctx", "args", "ls", "nc", "checks", "wcs", "c", "pc", "ca", "ks", "ins", "rc", "ck", "vs", "ds", "fs", "cp", "acs", "CS", "core", "bs", "cc", "ns", "cells", "spec", "cms", "css", "ras", "ps", "qs", "cf", "sc", "conn", "sync", "cus", "gs", "cing", "sys", "cn", "rs", "lc", "cons", "sk", "s", "cache"], "cpu": ["utils", "np", "linux", "hw", "os", "ctx", "cum", "device", "nic", "nc", "cow", "proc", "bc", "c", "pc", "hu", "cmp", "computer", "pu", "node", "rc", "config", "kernel", "fps", "cpp", "console", "CPU", "clock", "chip", "p", "boot", "px", "cp", "cm", "cu", "PU", "uu", "core", "cfg", "cli", "fc", "dc", "spec", "css", "vm", "mac", "gpu", "conn", "ci", "sync", "cam", "uci", "lan", "cn", "sys", "process", "lc", "gc", "uno", "processor", "cache"], "pcc": [" pac", "percc", "pCC", "ppac", " pcci", " pci", "cpac", "Pck", "ppCC", "Pci", "Pcf", "ppci", "cpci", " pCC", "Pcc", "ppcc", " pcf", "perck", "pck", " pck", "ppck", "pci", "pcf", "pac", "cpCC", "cpcc", "Pcci", "percci", "PCC", "pcci", "percf"], "local_err": ["Local_res", "locallybug", "local67doc", "Local_doc", " local_msg", "local_gr", "local_rr", "local67err", "localofrr", "localallerror", "internal_err", "Local_err", "localallerr", "localIPcore", "local_error", "localIPerr", "localoferr", "local_er", "local_res", "locallyerr", "local67er", "localIPerror", " local_core", "local_orr", "local_ok", "internal_norm", "local_norm", "Local_gr", "localofnorm", "local_core", "internal_orr", "local67gr", "local_msg", "localallcore", "localallok", "local_doc", " local_ok", "locallymsg", "locallyerror", "localIPok", " local_bug", "Local_er", "localoforr", "Local_rr", "internal_rr", "local_bug", " local_error"]}}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    RamDevice *d;\n\n\n\n    /* allocate RAM */\n\n    dev = qdev_create(NULL, \"memory\");\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    d = FROM_SYSBUS(RamDevice, s);\n\n    d->size = RAM_size;\n\n    qdev_init(dev);\n\n\n\n    sysbus_mmio_map(s, 0, addr);\n\n}\n", "idx": 9443, "substitutes": {"addr": ["pos", "rt", "pointer", "f", "src", "localhost", "device", "ptr", "nc", "ip", "host", "adr", "md", "a", "i", "afi", "node", "dr", "p", "offset", "b", "ange", "part", "array", "address", "add", "v", "dd", " address", "arm", "rx", "r", "attr", "mac", "inter", "amd", "m", "pad", "e", " dst", "n", "Address", "ad", "data", "target", "x"], "RAM_size": ["ram_SIZE", "ram_Size", "RAMLogbytes", "RAM_capacity", "ram_size", "RAMLogcapacity", "RAM_bytes", "RAMLogsize", "ram_capacity", "RAM_SIZE", "RAM_Size", "RAMLogSIZE", "ram_bytes"], "dev": ["debug", "g", "sd", "f", "device", "pro", "err", "serial", "rad", " Dev", "DEV", "md", "adv", "ver", "db", "gd", "ev", "mod", "p", "temp", "sh", "der", "ds", "app", "driver", "Dev", "grad", "di", "v", "dc", "dd", "ch", "r", "o", "error", "def", "u", "od", "w", "m", "conf", "dm", "e", "n", "er", "priv", "raw", "ad", "ve", "data"], "s": ["g", "os", "sd", "f", "src", "device", "k", "cs", "self", "ss", "sq", "c", "a", "i", "sv", "sb", "services", "h", "p", "sg", "si", "S", "ds", "b", "sh", "ssl", "se", "sl", "ns", "v", "spec", "t", "r", "o", "ps", "l", "u", "sync", "gs", "w", "m", "south", "e", "n", "rs", "sa", "js", "ad"], "d": ["g", "dat", "sd", "f", "device", "k", "D", "md", "c", " dd", "gd", "db", "i", "dr", "p", "dy", "ds", "b", "driver", "di", "z", "dc", "dd", "v", "o", "t", "da", "r", "l", "u", "w", "m", "dh", "e", "n", "fd", "ad", "data", "dt", "cd"]}}
{"project": "qemu", "commit_id": "49aa4058ac6dd0081aaa45776f07c98df397ca5e", "target": 1, "func": "QemuOpts *qemu_chr_parse_compat(const char *label, const char *filename)\n\n{\n\n    char host[65], port[33], width[8], height[8];\n\n    int pos;\n\n    const char *p;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n\n\n    opts = qemu_opts_create(qemu_find_opts(\"chardev\"), label, 1, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        return NULL;\n\n    }\n\n\n\n    if (strstart(filename, \"mon:\", &p)) {\n\n        filename = p;\n\n        qemu_opt_set(opts, \"mux\", \"on\");\n\n        if (strcmp(filename, \"stdio\") == 0) {\n\n            /* Monitor is muxed to stdio: do not exit on Ctrl+C by default\n\n             * but pass it to the guest.  Handle this only for compat syntax,\n\n             * for -chardev syntax we have special option for this.\n\n             * This is what -nographic did, redirecting+muxing serial+monitor\n\n             * to stdio causing Ctrl+C to be passed to guest. */\n\n            qemu_opt_set(opts, \"signal\", \"off\");\n\n        }\n\n    }\n\n\n\n    if (strcmp(filename, \"null\")    == 0 ||\n\n        strcmp(filename, \"pty\")     == 0 ||\n\n        strcmp(filename, \"msmouse\") == 0 ||\n\n        strcmp(filename, \"braille\") == 0 ||\n\n        strcmp(filename, \"stdio\")   == 0) {\n\n        qemu_opt_set(opts, \"backend\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"vc\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"vc\");\n\n        if (*p == ':') {\n\n            if (sscanf(p+1, \"%8[0-9]x%8[0-9]\", width, height) == 2) {\n\n                /* pixels */\n\n                qemu_opt_set(opts, \"width\", width);\n\n                qemu_opt_set(opts, \"height\", height);\n\n            } else if (sscanf(p+1, \"%8[0-9]Cx%8[0-9]C\", width, height) == 2) {\n\n                /* chars */\n\n                qemu_opt_set(opts, \"cols\", width);\n\n                qemu_opt_set(opts, \"rows\", height);\n\n            } else {\n\n                goto fail;\n\n            }\n\n        }\n\n        return opts;\n\n    }\n\n    if (strcmp(filename, \"con:\") == 0) {\n\n        qemu_opt_set(opts, \"backend\", \"console\");\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"COM\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"serial\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"file:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"file\");\n\n        qemu_opt_set(opts, \"path\", p);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"pipe:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"pipe\");\n\n        qemu_opt_set(opts, \"path\", p);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"tcp:\", &p) ||\n\n        strstart(filename, \"telnet:\", &p)) {\n\n        if (sscanf(p, \"%64[^:]:%32[^,]%n\", host, port, &pos) < 2) {\n\n            host[0] = 0;\n\n            if (sscanf(p, \":%32[^,]%n\", port, &pos) < 1)\n\n                goto fail;\n\n        }\n\n        qemu_opt_set(opts, \"backend\", \"socket\");\n\n        qemu_opt_set(opts, \"host\", host);\n\n        qemu_opt_set(opts, \"port\", port);\n\n        if (p[pos] == ',') {\n\n            if (qemu_opts_do_parse(opts, p+pos+1, NULL) != 0)\n\n                goto fail;\n\n        }\n\n        if (strstart(filename, \"telnet:\", &p))\n\n            qemu_opt_set(opts, \"telnet\", \"on\");\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"udp:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"udp\");\n\n        if (sscanf(p, \"%64[^:]:%32[^@,]%n\", host, port, &pos) < 2) {\n\n            host[0] = 0;\n\n            if (sscanf(p, \":%32[^@,]%n\", port, &pos) < 1) {\n\n                goto fail;\n\n            }\n\n        }\n\n        qemu_opt_set(opts, \"host\", host);\n\n        qemu_opt_set(opts, \"port\", port);\n\n        if (p[pos] == '@') {\n\n            p += pos + 1;\n\n            if (sscanf(p, \"%64[^:]:%32[^,]%n\", host, port, &pos) < 2) {\n\n                host[0] = 0;\n\n                if (sscanf(p, \":%32[^,]%n\", port, &pos) < 1) {\n\n                    goto fail;\n\n                }\n\n            }\n\n            qemu_opt_set(opts, \"localaddr\", host);\n\n            qemu_opt_set(opts, \"localport\", port);\n\n        }\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"unix:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"socket\");\n\n        if (qemu_opts_do_parse(opts, p, \"path\") != 0)\n\n            goto fail;\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"/dev/parport\", NULL) ||\n\n        strstart(filename, \"/dev/ppi\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"parport\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"/dev/\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"tty\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n\n\nfail:\n\n    qemu_opts_del(opts);\n\n    return NULL;\n\n}\n", "idx": 9445, "substitutes": {"label": ["message", "prefix", "text", "block", "abel", "layout", "file", "format", "local", "path", "description", "tag", "pixel", "seq", "route", "lab", "bl", "display", "config", "loc", "cell", "title", "url", "position", "key", "address", "code", "image", "length", "channel", "error", "el", "desc", "base", "value", "name", "alias", "align", "Label", "line"], "filename": ["jpg", "message", "text", "loader", "file", "src", "gender", "description", "ppa", "nil", "database", "download", "json", "sound", "package", "Filename", "txt", "location", "fn", "tp", "directory", "kn", "application", "params", "username", "doi", "dll", "ssl", "nuclear", "kl", "fp", "length", "attr", "sheet", "mpeg", "video", "binary", "prefix", "f", "fax", "appy", "buf", "sf", "metadata", "folder", "duration", "document", "content", "maximum", "password", "il", "lace", "source", "fil", "large", "name", "microsoft", "uri", "phrase", "final", "path", "other", "output", "single", "title", "println", "url", "files", "position", "image", "initial", "license", "buffer", "lua", "python"], "host": ["server", "param", "prefix", "file", "path", "ip", "class", "addr", " addr", "master", "config", "h", "bind", "loc", "url", "pair", "address", " address", "link", "def", "Host", "map", "base", "name", " ip", "data"], "port": ["server", "timeout", "uri", "prefix", "file", "type", "service", "path", "ref", "ip", "table", "output", "phone", "user", "route", "offset", "cp", "interface", "url", "key", "address", "channel", "index", "data", "ports", "slice", "post"], "height": ["padding", "gap", "dir", "hold", "pass", "up", "layout", "size", "thin", "arrow", "huge", "high", "id", "view", "ip", "resolution", "th", "grow", "lat", "upper", "alpha", "y", "times", "duration", "rows", "above", "h", "definition", "total", "shape", "driver", "img", "direction", "style", "bottom", "missing", "gravity", "image", "density", "crop", "length", "level", "deep", "images", "angle", "dim", "w", "buffer", "rank", "holes", "pull", "volume", "window", "stroke", "depth", "Height", "inches", "build"], "pos": [" loc", "padding", "os", "POS", "Pos", "size", "type", "src", " start", "pixel", " index", "len", "i", " offset", "offset", "loc", "position", "opt", "val", "start", " position", " location", "col", "unit", "name", " disp", "line"], "p": ["param", "g", "np", "pipe", "tp", "f", "file", "pn", "format", "type", "dp", "path", "ip", "pixel", "parser", "pb", "c", "y", "pc", "a", "i", "jp", "d", "params", "lp", "h", "pr", "per", "sp", "pkg", "b", "pi", "cp", "j", "pair", "pt", "P", "pre", "fp", "v", "pe", "op", "t", "o", "r", "ps", "l", "q", "u", "vp", "point", "pp", "ap", "w", "m", "e", "n", "pa", "s", "bp", "python", "x"], "opts": [" opms", " opters", "OPps", "OPuts", "optouts", " opouts", "opttips", "opments", " optcs", "OPrets", "oputs", "ot", "optt", "ots", "ipcs", " opttips", "opms", "otts", "operters", "popt", " opls", "optes", " optstr", "itcs", "opertes", "itouts", "otcs", " opcs", "optms", "OPments", "Opt", "opercs", "opcs", "optts", "itts", " opps", "Opts", " opments", "Optes", " oputs", "Opcs", "OPouts", "oprets", " opstr", "oters", "ipls", "ipts", "operuts", " optrets", "optls", "opttes", "OPtes", "OPts", "opstr", " optments", "OPstr", "optments", "popts", "opters", "opouts", "OPcs", "Opments", "optcs", "optps", "opps", "opert", " optms", "operouts", "optips", " optes", "ipments", "popters", " opttt", " optps", "Opters", "operts", "otters", " optters", "optters", "Oprets", "ottips", "itt", "opt", "poptt", " optts", "OPters", "Opouts", "OPt", "opls", " opt", "ops", " optt"], "local_err": ["global_err", "checklyer", "baseamer", "local__ver", "localpyrr", "local_finder", "local_rr", "local_errors", "checklyfinder", "local__er", "local_user", "localamer", "localpyerr", "local_attr", "baseamerrors", " local_er", "localamver", "local_ver", "local__err", "local7err", "local__errors", "check_er", "base_er", "local_error", "global_error", "localpyerror", "local7er", "local_er", "locallyerr", "check_err", "base_errors", " local_rr", "locallyer", "baseamerr", "base_err", "localpyuser", "base_ver", "local7finder", "global_rr", "locallyfinder", "localamerr", "checklyattr", "global_user", "baseamver", "localamerrors", " local_error", "check_finder", "local7attr", "check_attr", "checklyerr", "locallyattr"]}}
{"project": "qemu", "commit_id": "c73860803f8f8f56ee01b6e796507bfb4ea073ec", "target": 1, "func": "POWERPC_FAMILY(POWER8)(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n\n\n    dc->fw_name = \"PowerPC,POWER8\";\n\n    dc->desc = \"POWER8\";\n\n    pcc->pvr = CPU_POWERPC_POWER8_BASE;\n\n    pcc->pvr_mask = CPU_POWERPC_POWER8_MASK;\n\n    pcc->init_proc = init_proc_POWER7;\n\n    pcc->check_pow = check_pow_nocheck;\n\n    pcc->insns_flags = PPC_INSNS_BASE | PPC_STRING | PPC_MFTB |\n\n                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |\n\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n\n                       PPC_FLOAT_STFIWX |\n\n\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n\n                       PPC_64B | PPC_ALTIVEC |\n\n                       PPC_SEGMENT_64B | PPC_SLBI |\n\n                       PPC_POPCNTB | PPC_POPCNTWD;\n\n    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |\n\n                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |\n\n                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206;\n\n    pcc->msr_mask = 0x800000000284FF36ULL;\n\n    pcc->mmu_model = POWERPC_MMU_2_06;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc_hash64_handle_mmu_fault;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_POWER7;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n\n                 POWERPC_FLAG_VSX;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x8000;\n\n}", "idx": 9457, "substitutes": {"oc": ["ok", "oca", "ocr", "unc", "anc", "nc", "oco", "DC", "voc", "bc", "c", "pc", "co", "rc", "config", "loc", "toc", "ucc", "doc", "soc", "cc", "oid", "fc", "ac", "roc", "alloc", "oper", "o", "mac", "cf", "OC", "oci", "org", "ec", "mc", "uc", "cca", "exec", "isc"], "data": ["bus", "dat", "block", "device", "Data", "output", "bc", "d", "DATA", "new", "config", "input", "fee", "ds", "load", "di", "ac", "dd", "parent", "da", "def", "ci", "dev", "raw", "cache"], "dc": ["dat", "ga", "cdn", "nc", "DC", "bc", "vc", "c", "design", "ca", "d", "disc", "rc", "VC", "ds", "cm", "director", "doc", "cc", "di", "fc", "ac", "df", "da", "mac", "cf", "conn", "sc", "acc", "desc", "tc", "mc", "ec", "lc", "uc", "cca", "dt", "cd", "jc"], "pcc": ["Pcs", "Pcca", "pe\n", " pCC", " pcf", "pck", "PC", "ppck", "pcf", "cpCC", "fcc", " pacc", "ppacc", "pcca", "cpacc", "pacc", "pct", "fCC", " pcs", "tCC", " prc", "Pck", " pdd", "ppCC", "prc", " p\n", "prcc", "ppcc", "Pacc", "prdd", "frc", "P\n", "lpcci", "pcci", "fcf", "tcf", "lpCC", "fcca", "tcs", "pC", "pcs", "Pcc", "pdd", "cpct", " pck", "Prc", "tcc", "lpcc", "cpcca", "PCC", "prCC", "cpck", "lpcca", "p\n", "pCC", "cpcf", " pcci", "Pct", " pcca", " pC", "Pcf", "lpcf", " pct", "cpcc", "peC", "Pcci", "prck", "ppcca", "cpcci", "Pdd"]}}
{"project": "FFmpeg", "commit_id": "842e98b4d83d8cf297e2bc2761f1f47eb89e49e4", "target": 0, "func": "static int parse_object_segment(AVCodecContext *avctx,\n\n                                  const uint8_t *buf, int buf_size)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n    PGSSubObject *object;\n\n\n\n    uint8_t sequence_desc;\n\n    unsigned int rle_bitmap_len, width, height;\n\n    int id;\n\n\n\n    if (buf_size <= 4)\n\n        return AVERROR_INVALIDDATA;\n\n    buf_size -= 4;\n\n\n\n    id = bytestream_get_be16(&buf);\n\n    object = find_object(id, &ctx->objects);\n\n    if (!object) {\n\n        if (ctx->objects.count >= MAX_EPOCH_OBJECTS) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Too many objects in epoch\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        object = &ctx->objects.object[ctx->objects.count++];\n\n        object->id = id;\n\n    }\n\n\n\n    /* skip object version number */\n\n    buf += 1;\n\n\n\n    /* Read the Sequence Description to determine if start of RLE data or appended to previous RLE */\n\n    sequence_desc = bytestream_get_byte(&buf);\n\n\n\n    if (!(sequence_desc & 0x80)) {\n\n        /* Additional RLE data */\n\n        if (buf_size > object->rle_remaining_len)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        memcpy(object->rle + object->rle_data_len, buf, buf_size);\n\n        object->rle_data_len += buf_size;\n\n        object->rle_remaining_len -= buf_size;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (buf_size <= 7)\n\n        return AVERROR_INVALIDDATA;\n\n    buf_size -= 7;\n\n\n\n    /* Decode rle bitmap length, stored size includes width/height data */\n\n    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n\n\n\n    if (buf_size > rle_bitmap_len) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Buffer dimension %d larger than the expected RLE data %d\\n\",\n\n               buf_size, rle_bitmap_len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* Get bitmap dimensions from data */\n\n    width  = bytestream_get_be16(&buf);\n\n    height = bytestream_get_be16(&buf);\n\n\n\n    /* Make sure the bitmap is not too large */\n\n    if (avctx->width < width || avctx->height < height || !width || !height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitmap dimensions (%dx%d) invalid.\\n\", width, height);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    object->w = width;\n\n    object->h = height;\n\n\n\n    av_fast_padded_malloc(&object->rle, &object->rle_buffer_size, rle_bitmap_len);\n\n\n\n    if (!object->rle)\n\n        return AVERROR(ENOMEM);\n\n\n\n    memcpy(object->rle, buf, buf_size);\n\n    object->rle_data_len = buf_size;\n\n    object->rle_remaining_len = rle_bitmap_len - buf_size;\n\n\n\n    return 0;\n\n}\n", "idx": 9482, "substitutes": {"avctx": ["avconfig", "navctx", "verkb", "avcontext", "evctx", "navcu", "AVctx", "avectx", "aircontext", "AVsync", "avcas", "afconfig", "avcf", "afcontext", "versync", "avecf", "ajcontext", "awcas", "aveloc", "avcmd", "vercontext", "navlib", "AVkb", "abcontext", "AVcmd", "avsync", "aircas", "aircmd", "avecu", "aflib", "avlib", "avloc", "ajconv", "AVcas", "avcu", "verconn", "abctx", "avconv", "abcf", "afcf", "verloc", "AVloc", "avekb", "ajctx", "AVcf", "evsync", "awcmd", "AVconv", "awcontext", "avkb", "aveconfig", "AVconn", "verctx", "abconfig", "avecontext", "afcu", "avelib", "AVcontext", "awctx", "vercf", "avconn", "evconn", "afctx", "AVcu", "aveconv", "airctx", "navconfig", "evcontext", "ajcu"], "buf": ["bus", "pos", "ctr", "block", "mount", "loader", "vec", "src", "callback", "flow", "feat", "ff", "fam", "home", "proc", "grab", "byte", "bag", "seq", "pb", "box", "bc", "conv", "len", "off", "rc", "config", "cat", "cb", "cur", "b", "fb", "filename", "queue", "runner", "img", "context", "rb", "loop", "begin", "fp", "cv", "comb", "row", "num", "header", "alloc", "length", "br", "uf", "cmd", "cf", "buff", "buffer", "pad", "func", "obj", "port", "wb", "uc", "fd", "uber", "batch", "root", "window", "count", "coord"], "buf_size": ["buf_clean", "buf_send", "buffstrength", "buf67size", "bufflexsized", "buf_width", "buf67count", " buf_address", "buff_sized", "cb_content", " buf_capacity", "buf_capacity", "cb64content", "uf_capacity", "buff_width", "buf_scale", "cb64count", "buf_speed", "raw_send", " buf_len", "buflexsize", "bufflexstrength", " buf_ize", "buflexstrength", "bag_speed", "raw_capacity", "cb_count", "buf64side", "buffsize", "bufnform", "buf_term", "buf128count", "bag_size", "buffer_ize", "buf64term", "buflexterm", "buf_ize", "buflexsized", "buf67content", "buf___size", "raw_SIZE", "bag_Size", "buf_SIZE", "buffer_scale", "buf_address", " buf_small", "bufnsize", "buf128side", "buf_rate", " buf_clean", "buf_global", "buf___clean", "fb_global", "bufnscale", "fb_size", "buf64content", "buffsized", "uf_scale", "cb_size", "buff_speed", "bufflexterm", "fb_form", "uf_size", "cb64size", "bufflexsize", "buf_len", "buf_small", "buf_Size", "buf64sized", "buf___capacity", "buf64count", "bag_sized", "fb_scale", "buf_strength", "raw_size", "buffer_len", "buf_form", "uf_sized", "buff_term", "cb_side", "buf64strength", " buf_rate", "buf_side", "buf_content", "buff_size", "buf128size", "buf_count", "bufnglobal", "buffer_size", "buf64size", "buffterm", "cb64side", "buf67side", "buff_scale", "buff_strength", "buf_sized", "buf128content"], "ctx": ["cas", "hw", "prefix", "abc", "xc", "anc", "cdn", "nc", "aux", "bc", "wcs", "cci", "vc", "c", "cycle", "ca", "instance", "concept", "rc", "config", "cb", "kb", "ck", "sci", "loc", "pkg", "qa", "cm", "cp", "cu", "kw", "ctrl", "context", "cc", "act", "coll", "cv", "cms", "client", "fc", "alloc", "que", "cmd", "wp", "cf", "conn", "sync", "ci", "git", "cus", "cam", "conf", "tx", "obj", "cn", "lc", "gc", "cca", "exec", "acl"], "object": ["et", "empty", "service", "comment", "host", "class", "connection", "ant", "model", "objects", "open", "key", "address", "package", "Object", "lock", "target", "attribute", "external", "public", "end", "oid", "coll", "op", "parent", "active", "o", "error", "tree", "block", "en", "an", "event", "document", "orb", "part", "actor", "source", "article", "lib", "index", "body", "ob", "entity", "value", "null", "name", "number", "post", "pos", "ject", "no", "type", "subject", "output", "private", "instance", "node", "function", "offset", "inner", "full", "interface", "project", "style", "bit", "position", "core", "po", "act", "image", "entry", "item", "not", "obj", "unit", "n", "zero", "python", "element", "bot", "cache"], "sequence_desc": ["seq_desc", "sequencePstr", "sequencePdescription", "sequencePdesc", "sequence__des", "seq_description", " sequence_description", "sequence__description", "seq_sec", "sequence_length", " sequence_des", "seq_Desc", "sequencePdes", " sequence_str", "sequenceElength", "sequence_Desc", "seq_des", "sequenceEdescription", "sequence__str", "sequence_str", "sequenceEdesc", "sequence_sec", "sequence__desc", "sequence_des", "seq_length", "sequenceEDesc", "sequence_description"], "rle_bitmap_len": ["rle_bitmap64len", "rle_bitmap_lic", "rle_bitcap_Len", "rle_bitmap2l", "rle_bitcap_len", "rle_bitmap_length", "rle_bitmap_val", "rle_bitmap2val", "rle_bitmap_l", "rle_bitmap_Len", "rle_bitmap_name", "rle_bitmap64val", "rle_bitmask_len", "rle_bitcap_l", "rle_bitmask_name", "rle_bitmask_lic", "rle_bitcap_length", "rle_bitmask_val", "rle_bitmap2len", "rle_bitmap64length", "rle_bitmap64l", "rle_bitcap_val", "rle_bitmap2length"], "height": ["container", "padding", "gap", "hold", "wall", "layout", "size", "thin", "huge", "high", "diff", "flow", "weight", "th", "resolution", "east", "alpha", "y", "png", "third", "dist", "stroke", "duration", "rows", "above", "h", "inches", "gh", "work", "han", "shape", "ows", "img", "direction", "ht", "bottom", "family", "missing", "gravity", "image", "density", "row", "crop", "length", "images", "he", "border", "index", "dim", "thirds", "w", "ty", "hang", "rank", "fw", "pull", "volume", "window", "data", "depth", "Height", "x", " heights", "build"], "id": ["aid", "version", "uri", "no", "board", "f", "type", "file", "path", "ref", "ip", "class", "edit", "ids", "Id", "x", "kid", "tag", "i", "d", "event", "node", "p", "offset", "vid", "ident", "sid", "url", "gen", "bit", "end", "oid", "address", "code", "number", "image", "parent", "key", "num", "length", "source", "error", "count", "mask", " ID", "index", "head", "start", "pad", "ID", "uid", "base", "obj", "info", "value", "fd", "name", "bid", "ad", "data", " fid", "alias", "ide", "pid"]}}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "static int qemu_rdma_register_and_get_keys(RDMAContext *rdma,\n\n        RDMALocalBlock *block, uintptr_t host_addr,\n\n        uint32_t *lkey, uint32_t *rkey, int chunk,\n\n        uint8_t *chunk_start, uint8_t *chunk_end)\n\n{\n\n    if (block->mr) {\n\n        if (lkey) {\n\n            *lkey = block->mr->lkey;\n\n        }\n\n        if (rkey) {\n\n            *rkey = block->mr->rkey;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    /* allocate memory to store chunk MRs */\n\n    if (!block->pmr) {\n\n        block->pmr = g_malloc0(block->nb_chunks * sizeof(struct ibv_mr *));\n\n    }\n\n\n\n    /*\n\n     * If 'rkey', then we're the destination, so grant access to the source.\n\n     *\n\n     * If 'lkey', then we're the source VM, so grant access only to ourselves.\n\n     */\n\n    if (!block->pmr[chunk]) {\n\n        uint64_t len = chunk_end - chunk_start;\n\n\n\n        trace_qemu_rdma_register_and_get_keys(len, chunk_start);\n\n\n\n        block->pmr[chunk] = ibv_reg_mr(rdma->pd,\n\n                chunk_start, len,\n\n                (rkey ? (IBV_ACCESS_LOCAL_WRITE |\n\n                        IBV_ACCESS_REMOTE_WRITE) : 0));\n\n\n\n        if (!block->pmr[chunk]) {\n\n            perror(\"Failed to register chunk!\");\n\n            fprintf(stderr, \"Chunk details: block: %d chunk index %d\"\n\n                            \" start %\" PRIuPTR \" end %\" PRIuPTR\n\n                            \" host %\" PRIuPTR\n\n                            \" local %\" PRIuPTR \" registrations: %d\\n\",\n\n                            block->index, chunk, (uintptr_t)chunk_start,\n\n                            (uintptr_t)chunk_end, host_addr,\n\n                            (uintptr_t)block->local_host_addr,\n\n                            rdma->total_registrations);\n\n            return -1;\n\n        }\n\n        rdma->total_registrations++;\n\n    }\n\n\n\n    if (lkey) {\n\n        *lkey = block->pmr[chunk]->lkey;\n\n    }\n\n    if (rkey) {\n\n        *rkey = block->pmr[chunk]->rkey;\n\n    }\n\n    return 0;\n\n}\n", "idx": 9508, "substitutes": {"rdma": ["rdMA", "rtca", "djma", "rtma", "rcmas", "rgmas", "pdda", "rcango", "rdm", "erdma", "xdda", "rtm", "djda", "djca", "rbma", "rdmas", "erdmas", "rbMA", "rcda", "xdmas", "pdma", "xdma", "rdca", "erdca", "rdfa", "rgma", "ldango", "ldca", "rcMA", "ldmas", "ldda", "rcfa", "xdango", "rcma", "rgMA", "ldm", "ldma", "rtmas", "djm", "pdca", "rgfa", "erdm", "rbfa", "rbmas", "rdango", "pdm", "rdda"], "block": ["wall", "un", "panel", "comment", "ref", "byte", "bl", "pack", "clock", "blocks", "address", "channel", "lock", "random", "join", "info", "BL", "line", "build", "plugin", "ack", "view", "update", "box", "user", "module", "off", "session", "ban", "frame", "run", "coll", "record", "num", "header", "link", "error", "call", "base", "section", "exec", "list", "Block", "event", "config", "part", "commit", "row", "inv", "point", "sync", "map", "check", "name", "group", "number", "pos", "chain", "type", "flow", "tag", "node", "condition", "work", "full", "position", "rule", "image", "def", "unit", "none", "batch", "contract", "object", "cache"], "host_addr": ["host_address", "host_start", "server_name", "host_name", "server_addr", "server_start", "host_no", "server_no", "server_address"], "lkey": ["llowner", "ylcheck", "pcheck", "ylkey", "pkey", "slkey", " lkeys", "uowner", "Llock", "lkeys", " lmac", "lrow", "rvalue", " lrow", "olchar", " lask", "lbkey", "slmac", " lise", "rlvalue", " lvalue", "llkey", "llrow", "lcheck", "lise", "lask", "Lvalue", "elkeys", "slrow", "llchar", "pfix", "slfix", "lmatch", " llock", "lbmatch", "uchar", "rchar", "olrow", "olise", "lowner", "LKey", "rlKey", "rkeys", "olkey", "lbfix", "ylask", "Lkey", "urow", "elvalue", " lfix", "pask", "plock", "pkeys", "rrow", "lbvalue", "lbkeys", "rllock", "pmatch", "lchar", "lfix", "lbmac", " lcheck", "llock", "slvalue", "elkey", "elrow", "rise", "lvalue", "rlkey", " lowner", " lKey", " lchar", "lKey", "ukey", "lblock", "ylfix", " lmatch", "slkeys", "lmac"], "rkey": ["hrlock", "crget", "nrchange", "rchange", "hrkey", "hcall", "crkey", "prmatch", "pkey", "umatch", "lrule", "crcheck", "larg", "arno", "RKey", "hKey", "srcheck", "lrow", "rcheck", "rKey", "trmatch", "hmatch", "prlock", "Rkey", "trlock", "hkey", "Rload", "nkey", "lmatch", "prKey", "rno", "srmatch", "arkey", "srno", "mlock", "rararg", "hrrow", "prget", "rload", "pKey", "hrfix", "rsum", " rrule", "rrow", "srsum", "srchange", "nrget", "nrrow", "nlock", "rarkey", " rload", " rcall", "trget", "nrkey", "rfix", "srkey", "nrcheck", "usum", "rget", "pmatch", "lfix", "mmatch", "rarrule", "mget", "trkey", "puse", "luse", " rrow", "prkey", "pruse", " rarg", "mkey", "llock", "nrKey", "Rrow", "rarcall", "nfix", "armatch", "rrule", " rmatch", "ruse", "rarg", " rKey", "arsum", "rmatch", "lKey", "lcall", "rcall", "ukey", "rlock", "srget", "crchange", "nrload", "nrow", "uno"], "chunk": [" chack", "chanch", " chunker", "ahunker", "cheunker", "chunks", "chadu", "chuk", "archunk", "schork", "chaken", "schunk", "chdu", "cheanne", "enchanch", "shunk", "unchaken", "achack", "hork", "ahunk", " chk", "ichork", "ahk", " chault", "unchanne", "achard", "querunk", " chork", "channe", "hunk", "hck", "ichck", "cheunk", "cyunk", "chaunk", "archanne", "shunks", "cheaken", "shuk", "chck", "ichunks", "querault", "shard", "chank", "chack", "shanch", "chault", "shank", "querunker", "ahdu", " chard", "enchank", "chork", "archaken", " chdu", " chck", "chunker", "cyanch", "shack", "cyuk", "cheork", "chk", "ichault", "ichunker", "enchuk", "chaunker", "cyank", "chak", "enchunk", "achunks", "hunker", "querunks", "achunk", "unchunk", "schunker", " chunks", "chard", "ichunk"], "chunk_start": ["chunk_name", "chow_begin", "chrow_start", "chrow_offset", "chunk0end", "chork_part", "chunk_begin", "chunk64start", "chork_start", "chow_end", "chunk_old", "chanch_old", "chunk_part", "chork_end", "chanch_index", "chork0name", "chunk64index", "chunk_offset", "chrow_end", "chunk_data", "chunk64end", "chow_start", "chunk_stop", "chork0start", "chrow_data", "chunk_from", "chunk64old", "chunk0start", "chanch_end", "chork0part", "chunk_pos", "chork0end", "chunk0part", "chanch_start", "chunk0name", "chork_name", "chunk_index", "chow_stop"], "chunk_end": ["chunk_size", "chunk1start", "chunks_nd", "chunks_start", "chunks_id", "chunk_nd", "chunks_ends", "chunks_end", "chunk_ends", "chunk_id", "chunk1size", "chunk1end"], "total_registrations": ["total_rdistrators", "total_ristries", "total_registiculations", "total_regustors", "total_registentries", "total_registentrations", "total_registrators", "total_registentrators", "total_ristrators", "total_rdistries", "total_registicries", "total_gdistrators", "total_regdistries", "total_registicrations", "total_registicrators", "total_regiftrators", "total_regdistrators", "total_regiftors", "total_gdistries", "total_regdistors", "total_registentulations", "total_gdistors", "total_regustries", "total_gistrators", "total_regdistrations", "total_rdistulations", "total_regiftries", "total_ristrations", "total_regdistulations", "total_rdistrations", "total_gistors", "total_gistrations", "total_registors", "total_gdistrations", "total_regustrations", "total_registries", "total_registulations", "total_regustrators", "total_ristulations", "total_gistries", "total_regiftrations"]}}
{"project": "qemu", "commit_id": "e3697092228770c3b23d0bf524e18b508b109932", "target": 1, "func": "static void vga_draw_graphic(VGAState *s, int full_update)\n\n{\n\n    int y1, y, update, page_min, page_max, linesize, y_start, double_scan, mask, depth;\n\n    int width, height, shift_control, line_offset, page0, page1, bwidth, bits;\n\n    int disp_width, multi_scan, multi_run;\n\n    uint8_t *d;\n\n    uint32_t v, addr1, addr;\n\n    vga_draw_line_func *vga_draw_line;\n\n\n\n    full_update |= update_basic_params(s);\n\n\n\n    if (!full_update)\n\n        vga_sync_dirty_bitmap(s);\n\n\n\n    s->get_resolution(s, &width, &height);\n\n    disp_width = width;\n\n\n\n    shift_control = (s->gr[0x05] >> 5) & 3;\n\n    double_scan = (s->cr[0x09] >> 7);\n\n    if (shift_control != 1) {\n\n        multi_scan = (((s->cr[0x09] & 0x1f) + 1) << double_scan) - 1;\n\n    } else {\n\n        /* in CGA modes, multi_scan is ignored */\n\n        /* XXX: is it correct ? */\n\n        multi_scan = double_scan;\n\n    }\n\n    multi_run = multi_scan;\n\n    if (shift_control != s->shift_control ||\n\n        double_scan != s->double_scan) {\n\n        full_update = 1;\n\n        s->shift_control = shift_control;\n\n        s->double_scan = double_scan;\n\n    }\n\n\n\n    if (shift_control == 0) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[0x01] & 8) {\n\n            v = VGA_DRAW_LINE4D2;\n\n            disp_width <<= 1;\n\n        } else {\n\n            v = VGA_DRAW_LINE4;\n\n        }\n\n        bits = 4;\n\n    } else if (shift_control == 1) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[0x01] & 8) {\n\n            v = VGA_DRAW_LINE2D2;\n\n            disp_width <<= 1;\n\n        } else {\n\n            v = VGA_DRAW_LINE2;\n\n        }\n\n        bits = 4;\n\n    } else {\n\n        switch(s->get_bpp(s)) {\n\n        default:\n\n        case 0:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8D2;\n\n            bits = 4;\n\n            break;\n\n        case 8:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8;\n\n            bits = 8;\n\n            break;\n\n        case 15:\n\n            v = VGA_DRAW_LINE15;\n\n            bits = 16;\n\n            break;\n\n        case 16:\n\n            v = VGA_DRAW_LINE16;\n\n            bits = 16;\n\n            break;\n\n        case 24:\n\n            v = VGA_DRAW_LINE24;\n\n            bits = 24;\n\n            break;\n\n        case 32:\n\n            v = VGA_DRAW_LINE32;\n\n            bits = 32;\n\n            break;\n\n        }\n\n    }\n\n    vga_draw_line = vga_draw_line_table[v * NB_DEPTHS + get_depth_index(s->ds)];\n\n\n\n    depth = s->get_bpp(s);\n\n    if (s->line_offset != s->last_line_offset ||\n\n        disp_width != s->last_width ||\n\n        height != s->last_height ||\n\n        s->last_depth != depth) {\n\n        if (depth == 16 || depth == 32) {\n\n            if (is_graphic_console()) {\n\n                qemu_free_displaysurface(s->ds->surface);\n\n                s->ds->surface = qemu_create_displaysurface_from(disp_width, height, depth,\n\n                                                               s->line_offset,\n\n                                                               s->vram_ptr + (s->start_addr * 4));\n\n                dpy_resize(s->ds);\n\n            } else {\n\n                qemu_console_resize(s->ds, disp_width, height);\n\n            }\n\n        } else {\n\n            qemu_console_resize(s->ds, disp_width, height);\n\n        }\n\n        s->last_scr_width = disp_width;\n\n        s->last_scr_height = height;\n\n        s->last_width = disp_width;\n\n        s->last_height = height;\n\n        s->last_line_offset = s->line_offset;\n\n        s->last_depth = depth;\n\n        full_update = 1;\n\n    } else if (is_graphic_console() && is_buffer_shared(s->ds->surface) &&\n\n               (full_update || s->ds->surface->data != s->vram_ptr + (s->start_addr * 4))) {\n\n        s->ds->surface->data = s->vram_ptr + (s->start_addr * 4);\n\n        dpy_setdata(s->ds);\n\n    }\n\n\n\n    s->rgb_to_pixel =\n\n        rgb_to_pixel_dup_table[get_depth_index(s->ds)];\n\n\n\n    if (!is_buffer_shared(s->ds->surface) && s->cursor_invalidate)\n\n        s->cursor_invalidate(s);\n\n\n\n    line_offset = s->line_offset;\n\n#if 0\n\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n\n           width, height, v, line_offset, s->cr[9], s->cr[0x17], s->line_compare, s->sr[0x01]);\n\n#endif\n\n    addr1 = (s->start_addr * 4);\n\n    bwidth = (width * bits + 7) / 8;\n\n    y_start = -1;\n\n    page_min = 0x7fffffff;\n\n    page_max = -1;\n\n    d = ds_get_data(s->ds);\n\n    linesize = ds_get_linesize(s->ds);\n\n    y1 = 0;\n\n    for(y = 0; y < height; y++) {\n\n        addr = addr1;\n\n        if (!(s->cr[0x17] & 1)) {\n\n            int shift;\n\n            /* CGA compatibility handling */\n\n            shift = 14 + ((s->cr[0x17] >> 6) & 1);\n\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n\n        }\n\n        if (!(s->cr[0x17] & 2)) {\n\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n\n        }\n\n        page0 = s->vram_offset + (addr & TARGET_PAGE_MASK);\n\n        page1 = s->vram_offset + ((addr + bwidth - 1) & TARGET_PAGE_MASK);\n\n        update = full_update |\n\n            cpu_physical_memory_get_dirty(page0, VGA_DIRTY_FLAG) |\n\n            cpu_physical_memory_get_dirty(page1, VGA_DIRTY_FLAG);\n\n        if ((page1 - page0) > TARGET_PAGE_SIZE) {\n\n            /* if wide line, can use another page */\n\n            update |= cpu_physical_memory_get_dirty(page0 + TARGET_PAGE_SIZE,\n\n                                                    VGA_DIRTY_FLAG);\n\n        }\n\n        /* explicit invalidation for the hardware cursor */\n\n        update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1;\n\n        if (update) {\n\n            if (y_start < 0)\n\n                y_start = y;\n\n            if (page0 < page_min)\n\n                page_min = page0;\n\n            if (page1 > page_max)\n\n                page_max = page1;\n\n            if (!(is_buffer_shared(s->ds->surface))) {\n\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n\n                if (s->cursor_draw_line)\n\n                    s->cursor_draw_line(s, d, y);\n\n            }\n\n        } else {\n\n            if (y_start >= 0) {\n\n                /* flush to display */\n\n                dpy_update(s->ds, 0, y_start,\n\n                           disp_width, y - y_start);\n\n                y_start = -1;\n\n            }\n\n        }\n\n        if (!multi_run) {\n\n            mask = (s->cr[0x17] & 3) ^ 3;\n\n            if ((y1 & mask) == mask)\n\n                addr1 += line_offset;\n\n            y1++;\n\n            multi_run = multi_scan;\n\n        } else {\n\n            multi_run--;\n\n        }\n\n        /* line compare acts on the displayed lines */\n\n        if (y == s->line_compare)\n\n            addr1 = 0;\n\n        d += linesize;\n\n    }\n\n    if (y_start >= 0) {\n\n        /* flush to display */\n\n        dpy_update(s->ds, 0, y_start,\n\n                   disp_width, y - y_start);\n\n    }\n\n    /* reset modified pages */\n\n    if (page_max != -1) {\n\n        cpu_physical_memory_reset_dirty(page_min, page_max + TARGET_PAGE_SIZE,\n\n                                        VGA_DIRTY_FLAG);\n\n    }\n\n    memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4);\n\n}\n", "idx": 9509, "substitutes": {"s": ["server", "sym", "service", "cs", "self", "c", "a", "ks", "i", "grades", "settings", "b", "sites", "gs", "series", "e", "rs", "or", "js", "status", "os", "bis", "site", "its", "ls", "ss", "sq", "ins", "params", "sb", "same", "http", "S", "sie", "ds", "session", "fs", "ssl", "o", "ses", "qs", "f", "parts", "sf", "xs", "services", "sg", "secondary", "sl", "in", "ions", "r", "ps", "south", "sys", "su", "features", "g", "request", "state", "states", "sports", "is", "new", "es", "p", "ts", "si", "sis", "ns", "spec", "us", "t", "your", "plugins", "m", "conf", "sets", "this", "stats", "ges", "ops"], "full_update": ["full_load", "fulleget", "fullerupdate", "fullureupdate", "full_end", "fullOsave", "half_event", " full_\n", "fullOversion", "full_save", "full_init", " full_init", "full_apply", "full_report", "fullOview", "fullworkwrite", " full_write", "full_event", "fullworkget", "fullOwrite", "full_range", "fulleupdate", " full_version", "fulllexwidth", "fullOupdate", "half_Update", "fullOwidth", "fullCwrite", "full_\n", "fullurewrite", "fullCrange", "full_write", "fullCupdate", "fullerUpdate", " full_release", "fulleload", "fullworkload", "halferUpdate", " full_view", "halferupdate", "fulllexupdate", "fullerapply", "fullOinit", "fulllexinit", "complete_get", " full_end", "full_width", "full_view", "complete_update", "fullurereport", "complete_write", "full_get", "halferevent", "fullewrite", " full_save", " full_width", "fullerevent", "full_Update", "complete_range", "fullworkupdate", "full_version", "half_update", "complete_load", "half_apply", "fullurerelease", "halferapply", "fulllexsave", " full_report", "full_release"], "y1": ["Y01", "ya1", "ya01", " y01", "y01", "Y1"], "y": ["g", "pos", "ey", "yy", "f", "ip", "c", "i", "xy", "yn", "h", "p", "dy", "b", "vy", "cy", "z", "image", "t", "o", "q", "w", "m", "e", "n", "Y", "x"], "update": ["version", "layout", "wait", "id", "date", "edit", "write", "draw", "node", "updated", "position", "scale", "image", "num", "o", "q", "sync", "index", "u", "m", "current", "delay", "e", "status", "check", "enable"], "page_min": ["pagexlimit", "pagexsize", " page_limit", "pagexmin", "pagexmax", "page_limit", " page_size", "page_size"], "page_max": [" page_range", "page_range", " page_start", "page_start"], "linesize": ["pagesizer", "linsizer", "linsiz", "linesizing", "pagesiz", "linsize", "pagesize", "imagesize", "linesizer", "imagesizing", "linsizing", "pagesizing", "imagesizer", "linesiz", "imagesiz"], "y_start": ["y_range", "y_end", "line_end", "line_min", "line_range", "y2start", "y_min", "y2range", "y2min", "line_start", "y2end"], "double_scan": ["double_search", "doublelyerror", "doublelysearch", "double\u30dfrun", "multi_rate", "doublelymatch", "multi_query", "double_control", "double\u00b7scan", "multi_read", "double_skip", "Double_search", "full_match", "double_error", "double\u00b7search", "full_scan", "multi_plan", "multi_copy", "double_copy", "multi_sc", "doublelybatch", "double_batch", "doublelycopy", "multi_control", "double\u30dfread", "double_match", "doublelyplan", "double_fill", "double_run", "double\u00b7run", "double_query", "double\u30dfskip", "multi_skip", "double\u30dfscan", "doublelyrun", "Double_run", "double_read", "double_plan", "multi_fill", "double_rate", "Double_scan", "doublelyfill", "Double_control", "full_batch", "doublelyscan", "double_sc", "double\u00b7query", "doublelysc", "multi_error", "multi_search"], "mask": ["flags", "ask", "cost", "mode", "weight", "black", "dr", "details", "qa", "quiet", "flag", "bit", "scale", "image", "counter", "clear", "dark", "pad", "lock", "delay", "random", "sk", "batch", "window", "count", "skip", "cache"], "depth": ["debug", "padding", "mode", "id", "max", "weight", "len", "dist", "dr", "seed", "direction", "grad", "scale", "dc", "length", "level", "deep", "count", "dim", "pad", "delay", "progress", "repeat", "rate", "grade", "dir", "slice", "features"], "height": ["padding", "gap", "layout", "size", "thin", "id", "max", "quality", "resolution", "rows", "h", "slice", "input", "shape", "direction", "style", "wrap", "bottom", "image", "density", "row", "length", "dim", "w", "rank", "window", "Height", "x", "inches"], "shift_control": ["push_update", "carry_align", "shiftaccorrect", "shift_correct", "transfer_controller", "carry_limit", " shift_correct", "shift_scale", "transfer_control", "shift_controlled", "shift_run", "shiftpcontrol", "shiftlexaddress", "shift_controller", "shiftlexcontroller", "shiftallcontrol", "secondary_correct", "shiftpignore", "shiftxcontrol", "shiftacalign", "shiftaccontrol", "shift\u00b7scan", "secondaryxcorrect", " shift_controlled", "shiftlexscale", " shift_ignore", "push_controlled", "shiftingrun", "secondaryxcontrolled", "shift\u00b7update", "shift_limit", " shift_edit", " shift_forward", "shift_width", "shift_address", "push_scan", "shift_forward", "shiftingforward", "shiftalladdress", "shiftingcontrolled", "secondary_controller", "shift_ignore", "shiftaccontroller", "shiftxcontrolled", "shift_update", "shift_edit", "shift\u00b7length", "carry_control", "secondaryxcontrol", "force_release", "secondary_control", "shiftpcontrolled", " shift_controller", "transfer_address", "secondaryxcontroller", "carry_controlled", "shiftallcontroller", "shiftaccontrolled", "push_width", "shiftacrun", "push_length", "shift_align", "shiftingcontrol", "shiftxcorrect", "force_controller", "shiftaclimit", "shiftlexcontrol", "transfer_scale", "force_correct", "secondary_controlled", "push_control", "shiftxrun", "shift_release", " shift_run", "shift_length", "shiftallscale", "shiftxcontroller", "shift\u00b7control", "force_control", "shift_scan", "shiftpedit"], "line_offset": ["inline_start", "inline_index", "line2slot", "line___index", "inline_offset", "line2index", "line___slot", "line_index", "line2start", "inline_slot", "line_slot", "line___start", "line___offset", "line_start", "line2offset"], "page0": ["line2", "line0", " page2", "page2", "row0", " page50", "row4", "page4", "line4", "row50", "line50", "page50", " page4", "row2"], "page1": ["line2", "line1", " page2", "page01", "limit2", "page2", "limit01", "line01", "limit1", " page01"], "bwidth": ["dweight", "dvalue", "dWidth", " bWidth", " bvalue", "nvalue", "nWidth", "nwidth", "bWidth", "bweight", "nweight", "dwidth", " bweight", "bvalue"], "bits": ["flags", "planes", "breaks", "cycles", "bugs", "bis", "parts", "vals", "fixes", "its", "checks", "items", "bps", "points", "ins", "rows", "bytes", "cats", "fps", "BIT", "lines", "details", "steps", "ips", "blocks", "bit", "units", "limits", "bands", "bs", "levels", "pieces", "bin", "gets", "frames", "pins", "plugins", "ints", "notes", "bles", "lins", "issues", "batch", "locks", "ports", "dates", "features"], "disp_width": ["dispatch_speed", "disp_speed", "disp_line", "disp_left", "disp_weight", "disping_level", "disping64value", "disp64level", "disping_width", "disp64value", "dispatch_width", "disping64size", "disc_size", "disping_value", "disp64width", "disp_length", "disc_weight", "disping64level", "disc_line", "disp_level", "disp64size", "disping64width", "dispatch_left", "disp_value", "disping_size", "dispatch_size", "disp_size", "disc_width", "dispatch_length"], "multi_scan": ["multilexrun", "double_cat", "multi_walk", "multi67cat", "multi_keep", "multilexkeep", "multijscan", "single_scan", "multi_cat", "single_keep", "multiFrun", "double_run", "multiacskip", "multiFkeep", "multiacrun", "single_run", "multi_move", "multi_watch", "multi_skip", "multi67scan", "double_watch", "multilexscan", "multiacscan", "multi_apply", "multijapply", "multijkeep", "multi67run", "double_keep", "multi67watch", "double_skip", "single_apply", "double_move", "multiFapply", "multijrun", "double_walk", "multilexskip", "multiFscan", "multiackeep"], "multi_run": ["multiPrun", "multi___run", "multi___update", "single_scan", "multi___min", "multi_loop", "single_update", "single_run", "multiPloop", "multiPscan", "multiPupdate", "single_loop", "multi_update", "multi___loop", "single_min", "multi_min"], "d": ["f", "dp", "diff", "D", "xd", "c", "dist", "i", "p", "ds", "b", "direction", "dc", "l", "dim", "dx", "w", "m", "dh", "e", "n", "dl", "ad", "data", "dt", "dir", "x"], "v": ["ii", "g", "pos", "vol", "version", "vo", "f", "va", "vals", "k", "view", "ov", "rev", "values", "c", "ver", "conv", "i", "sv", "h", "ev", "p", "b", "fl", "j", "end", "uv", "av", "z", "code", "iv", "cv", "vert", "t", "r", "val", "o", "V", "l", "q", "u", "vp", "qv", "w", "m", "e", "n", "value", "var", "vv", "vi", "ve", "vs", "x", "volt"], "addr1": [" addr0", "dist01", "ptr1", "ptr0", "addr0", "addr01", " addr01", "dist0", "dist1", "ptr01"], "addr": ["pos", "dp", "mode", "src", "ptr", "ip", "nc", "md", "len", "dist", "iii", "aa", "dr", "arr", "direction", "nd", "grad", "address", "add", "layer", "da", "mac", "amd", "nn", "pad", "delay", "xp", "align"], "vga_draw_line": ["vga_draw2line", "vga_draw2lines", "vga_draw_inline", "vga_create_inline", "vga_create_point", "vga_draw2inline", "vga_draw_point", "vga_draw2point", "vga_create_line", "vga_create_lines", "vga_draw_lines"]}}
{"project": "qemu", "commit_id": "9e472e101f37233f4e32d181d2fee29014c1cf2f", "target": 1, "func": "static int qemu_signalfd_compat(const sigset_t *mask)\n\n{\n\n    pthread_attr_t attr;\n\n    pthread_t tid;\n\n    struct sigfd_compat_info *info;\n\n    int fds[2];\n\n\n\n    info = malloc(sizeof(*info));\n\n    if (info == NULL) {\n\n        errno = ENOMEM;\n\n        return -1;\n\n    }\n\n\n\n    if (pipe(fds) == -1) {\n\n        free(info);\n\n        return -1;\n\n    }\n\n\n\n    memcpy(&info->mask, mask, sizeof(*mask));\n\n    info->fd = fds[1];\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n\n\n    pthread_create(&tid, &attr, sigwait_compat, info);\n\n\n\n    pthread_attr_destroy(&attr);\n\n\n\n    return fds[0];\n\n}\n", "idx": 9510, "substitutes": {"mask": ["flags", "ask", "block", "wait", "type", "mount", "mode", "id", "diff", "size", "comment", "weight", "result", "addr", "depth", "user", "patch", "config", "pack", "mod", "auth", "offset", "arr", "mark", "shape", "secret", "flag", "bit", "scale", "key", "address", "code", "trace", "image", "filter", "header", "Mask", "sum", "buff", "map", "dev", "allow", "buffer", "conf", "lock", "mm", "delay", "pad", "bits", "reg", "sk", "fix", "data", "count", "alias", "check", "cache"], "attr": ["ii", "mut", "prop", "ann", "rt", "type", "f", "att", "attribute", "match", "api", "ptr", "ref", "err", "fi", "class", "rad", "addr", "adr", "stat", "cmp", "method", "config", "cb", "offset", "si", "arr", "app", "perm", "ctrl", "fac", "atts", "rb", "address", "spec", "access", "ac", "layer", "r", "ind", "opt", "error", "rel", "conn", "sync", "attach", "acc", "func", "ai", "rs", "rr", "py", "alt", "typ", "alias", "cache"], "tid": ["noid", "tone", "nid", "Tid", " tone", " tids", "nname", "fid", "Toid", "fids", "fip", "pone", " tip", "tip", "untname", "tname", "untids", "Tids", "toid", "nids", "tids", "untid", "pids", "Tname", "pip", "fone", "pid", "untoid"], "info": ["ii", "thin", "args", "f", "type", "id", "att", "diff", "comment", "api", "hand", "update", "self", "fi", "ignore", "handle", "now", "inf", "result", "raf", "Info", "is", "i", "help", "afi", "config", "offset", "ret", "options", "si", "order", "http", "extra", "fs", "inner", "gi", "ext", "part", "INFO", "trace", "hi", "ami", "op", "image", "ui", "error", "link", "source", "def", "conn", "fo", "start", "handler", "buff", "inter", "index", "conf", "lock", "init", "obj", "fw", "py", "name", "bug", "txt", "data", "alias", "cache"], "fds": ["fdes", "ofdds", "sfdd", "pds", "afds", "afdds", "sfdds", "tfdds", "afDS", " fd", "dfd", "rfmails", "fords", "fDS", "ofns", " fdd", "ofds", "sfdes", " fords", "fdd", " fdds", "tfdes", "ifdds", "ofords", " fmails", "fmails", "rfd", "fdds", "rfdds", "pDS", "dfds", "afns", "tfdd", "pdds", "dfmails", "rfds", " fDS", "fns", "tfds", "dfdds", "ifds", " fns", "fd", "pns", "ifords", "sfds", " fdes", "ifns"]}}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    uint32_t startlen = read_u32(data, 0);\n\n    VNC_DEBUG(\"Got client start len %d\\n\", startlen);\n\n    if (startlen > SASL_DATA_MAX_LEN) {\n\n        VNC_DEBUG(\"Too much SASL data %d\\n\", startlen);\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n\n\n    if (startlen == 0)\n\n        return protocol_client_auth_sasl_start(vs, NULL, 0);\n\n\n\n    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);\n\n    return 0;\n\n}\n", "idx": 9516, "substitutes": {"vs": ["os", "eps", "VS", "ils", "src", "vers", "va", "vals", "vt", "cs", "ls", "state", "ov", "ss", "xs", "pps", "uses", "ks", "ins", "sv", "services", "es", "otes", "fps", "http", "iss", "ds", "outs", "fs", "cp", "sts", "vr", "alls", "env", "bs", "ns", "v", "hs", "ms", "ps", "qs", "ses", "vp", "gs", "vas", "ports", "las", "rs", "obs", "sk", "stats"], "data": ["dat", "pos", "valid", "text", "empty", "size", "sample", "events", "id", "Data", "api", "buf", "ada", "values", "result", "media", "seq", "i", "d", "DATA", "bytes", "p", "offset", "response", "input", "open", "end", "feed", "v", "client", "reader", "da", "start", "map", "buffer", "body", "pad", "base", "batch", "ad", "window", "cache"], "len": ["pos", "block", "size", "type", "limit", "ls", "rev", " length", "seq", "min", "db", "en", "Len", "el", "length", "val", "count", "all", "l", "start", "lib", "base", "lf", "str"]}}
{"project": "FFmpeg", "commit_id": "a0e5f7f363555d2befafb1c9e1579dbe0a2fbca7", "target": 1, "func": "static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,\n\n                                  cavs_vector *col_mv)\n\n{\n\n    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;\n\n    int den = h->direct_den[col_mv->ref];\n\n    int m = FF_SIGNBIT(col_mv->x);\n\n\n\n    pmv_fw->dist = h->dist[1];\n\n    pmv_bw->dist = h->dist[0];\n\n    pmv_fw->ref = 1;\n\n    pmv_bw->ref = 0;\n\n    /* scale the co-located motion vector according to its temporal span */\n\n    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n\n    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n\n    m = FF_SIGNBIT(col_mv->y);\n\n    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n\n    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n\n}\n", "idx": 9528, "substitutes": {"h": ["g", "ph", "H", "f", "hr", "beh", "host", "self", "oh", "y", "c", "i", "d", "p", "ha", "http", "sh", "uh", "ah", "hp", "hh", "ht", "context", "hi", "v", "hs", "z", "t", "r", "o", "ih", "l", "q", "u", "hl", "w", "m", "e", "n", "eh", "rh", "s", "x", "hm"], "pmv_fw": ["pmv__hw", "pmv__wcs", "pmov__nw", "pmv_wk", "pmf_fw", "pmv__wd", "pmm_hw", "pmov__wd", "pmf_hw", "pmov_wcs", "pmov__fw", "pmf_fo", "pmf_nw", "pmv__w", "pmv_wd", "pmov_fw", "pmc_fw", "pmv_fo", "pmv_wy", "pmv_wu", "pmf_w", "pmv_wcs", "pmc_hw", "pmc_wd", "pmv_feat", "pmm__fw", "pmf_feat", "pmv__wk", "pmm_fw", "pmm_wk", "pmf_wy", "pmm__wk", "pmov_nw", "pmf_wu", "pmov__wcs", "pmov_wd", "pmc_nw", "pmm__w", "pmv__nw", "pmm__hw", "pmv__fw", "pmv_w", "pmc_kw", "pmc_w", "pmv_nw", "pmv_hw", "pmv_kw", "pmm_w"], "col_mv": ["col_cmc", "col_emb", "col2mf", "col_mm", "col_dmb", "col_Mb", "col_Mk", "col_Mver", "col_mmb", "col_Mc", "col_mmk", "col_cmk", "col_emver", "col_ymf", "col_nc", "col_cmov", "col_ymv", "col_emf", "col_mb", "col_cmb", "col_dmv", "col2mb", "col_nv", "col_cmver", "col2mc", "col_nb", "col_Mv", "col_Mov", "col2Mv", "col_vb", "col_dmf", "col_mmv", "col2mv", "col_Mf", "col_mver", "col_dmm", "col_nf", "col_mov", "col_emv", "col_ymb", "col_cmf", "col_cmm", "col_vver", "col2Mc", "col_mx", "col_Mx", "col_nver", "col_mf", "col_ymov", "col_cmv", "col_mmf", "col_vf", "col_nx", "col_cmx", "col_mc", "col_mk", "col2Mf", "col_Mm", "col_vv", "col2Mb"], "pmv_bw": ["pmv_pwal", "pmv_rbrw", "pmv_dwd", "pmv_bwal", "pmv_lsw", "pmv_bway", "pmv_bwd", "pmv_vtw", "pmv_bwa", "pmv_bbw", "pmv_bws", "pmv8ubwd", "pmv_bbwa", "pmv5bwk", "pmv_faw", "pmv_rbwd", "pmv_btwal", "pmv_lbtw", "pmv_fwer", "pmv_bW", "pmv_bsw", "pmv5lbwk", "pmv_lws", "pmv_eway", "pmv_ubwer", "pmv_bbtw", "pmv_btw", "pmv_bews", "pmv_adway", "pmv_fwt", "pmv_barrw", "pmv_pws", "pmv_brw", "pmv_barw", "pmv8ubw", "pmv_barwd", "pmv_ubaw", "pmv_bwk", "pmv5bw", "pmv8ubaw", "pmv_ew", "pmv_vwa", "pmv_daw", "pmv_ewal", "pmv_rbwk", "pmv8bwer", "pmv_pw", "pmv_lbwk", "pmv_fws", "pmv_psw", "pmv_lbw", "pmv_adwa", "pmv_dwer", "pmv5lbtw", "pmv8ubwer", "pmv_dw", "pmv_vw", "pmv__bwt", "pmv_lbwa", "pmv_ewa", "pmv_dwk", "pmv_bew", "pmv8bw", "pmv5lbw", "pmv_vwk", "pmv_bbwal", "pmv__bW", "pmv_btwt", "pmv5bwa", "pmv_bwer", "pmv_btW", "pmv5lbwa", "pmv_adwal", "pmv5btw", "pmv8bwd", "pmv__bw", "pmv_lwt", "pmv_fwd", "pmv_fsw", "pmv_barwk", "pmv8baw", "pmv_bbway", "pmv_adw", "pmv_fwal", "pmv_drw", "pmv_lw", "pmv_bbwk", "pmv_pW", "pmv_bwt", "pmv_ubw", "pmv_besw", "pmv__bwal", "pmv_baw", "pmv_ubwd", "pmv_bewal", "pmv_pwt", "pmv_rbw"]}}
{"project": "FFmpeg", "commit_id": "22fa38f0c85fb31cddbb0bc22a2df5953c702b95", "target": 0, "func": "static inline void h264_deblock_q1(register vector unsigned char p0,\n\n                                                   register vector unsigned char p1,\n\n                                                   register vector unsigned char p2,\n\n                                                   register vector unsigned char q0,\n\n                                                   register vector unsigned char tc0) {\n\n\n\n    register vector unsigned char average = vec_avg(p0, q0);\n\n    register vector unsigned char temp;\n\n    register vector unsigned char uncliped;\n\n    register vector unsigned char ones;\n\n    register vector unsigned char max;\n\n    register vector unsigned char min;\n\n\n\n    temp = vec_xor(average, p2);\n\n    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */\n\n    ones = vec_splat_u8(1);\n\n    temp = vec_and(temp, ones);         /*(p2^avg(p0, q0)) & 1 */\n\n    uncliped = vec_subs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */\n\n    max = vec_adds(p1, tc0);\n\n    min = vec_subs(p1, tc0);\n\n    p1 = vec_max(min, uncliped);\n\n    p1 = vec_min(max, p1);\n\n}\n", "idx": 9533, "substitutes": {"temp": ["cases", "valid", "clean", "empty", "wait", "pool", "api", "now", "output", "c", "eff", "single", "iter", "a", "non", "new", "multi", "amp", "p", "input", "order", "fake", "total", "average", "Temp", "wrap", "test", "flat", "pt", "tem", "pre", "partial", "tmp", "copy", "crop", "t", "wave", "area", "adapt", "cel", "common", "warm", "emp", "buffer", "current", "fit", "base", "unit", "tim", "tc", "one", "mini", "null", "cash", "zero", "none", "comb", "out", "mag", "mix", "cache"], "uncliped": ["unpamented", "uncuted", "unapeed", "unclipsled", " unclipable", "unpaed", "uncapable", " uncapable", "uninpad", "unscriptned", "unscripteded", "unclipmented", "unclipsened", "uninclipmented", " unclipseded", "unclipsned", " unclipeded", "unclipled", " unclipsed", "unpaeds", "unapeED", "unscriptened", "uncuteds", "unclipseded", "unapeled", "unclipsmented", "unclipsd", " unclipsned", "uncaped", "unscripted", "uncapED", "uninpaeds", "unclipeded", "unclipseds", "uninclipeds", "unpad", "uninclipd", "uncutd", "unclipsable", " uncaped", " unclipled", "unclipsed", "unclipED", "unclipd", " unclipened", "unclipsED", " uncapled", "unincliped", "uninpamented", "uncuteded", "unclipened", " uncapED", "uncutned", " unclipsened", "uncutmented", "uninpaed", " unclipED", "uncapled", "unclipeds", "unclipable", "unapeable", "unclipned", " unclipned", "uncutened"], "ones": ["pos", "os", "cases", "faces", "size", "cycles", "les", "sample", "oned", "vals", "ases", "ls", "values", "na", "plus", "alpha", " clones", "tones", "points", "ks", "eros", "ins", "parents", "rows", "ays", "names", "aps", "lines", "ips", "blocks", "outs", "steps", "amps", "clone", "cells", "offs", "less", "original", "ms", "ans", "ps", "frames", "common", "bits", "custom", "one", "s", "null", "packs", "none", "zero", "ops", "keys"], "max": ["ax", "first", "size", "id", "diff", "final", "frac", "anc", "ox", "self", "now", "plus", "alpha", "cycle", "ca", "co", "mad", "mod", "step", "only", "range", "full", "wrap", "end", "scale", "est", "act", "z", "from", "parent", "crop", "std", "old", "sum", "az", "w", "height", "pad", "last", "conf", "init", "n", "none", "ad", "count", "x", "Max", "cache"], "min": ["pos", "ax", "Min", "prefix", "minus", "version", "size", "mean", "limit", "na", "seq", "sign", "len", "is", "small", "non", "mod", "p", "span", "only", "ng", "part", "pre", "partial", "act", "in", "po", "ms", "mine", "ps", "area", "mins", "start", "index", "m", "init", "n", "s", "mini", "none", "null", "skip", "x", "sum"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,\n\n                                target_ulong pc2, TCGv r_cond)\n\n{\n\n    int l1;\n\n\n\n    l1 = gen_new_label();\n\n\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);\n\n\n\n    gen_goto_tb(dc, 0, pc2, pc1);\n\n\n\n    gen_set_label(l1);\n\n    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);\n\n}\n", "idx": 9546, "substitutes": {"dc": ["CC", "abc", "ctx", "dp", "cdn", "nc", "DC", "bc", "vc", "c", "db", "pc", "ca", "design", "d", "disc", "rc", "config", "input", "toc", "director", "context", "cc", "fc", "ac", "da", "cf", "sc", "desc", "dm", "oc", "circ", "tc", "lc", "ec", "mc", "uc", " DC", "cca", "dt", "cd", "jc"], "pc1": ["fc1", "PC1", "PC3", "fcone", "pc3", "arc2", "mcb", "pcb", "arc1", "PCone", "PC2", "lc1", "mc2", "fc2", "PCb", "arcb", "lcone", "lc3", "fc3", "lc2", "pcone", "mc1"], "pc2": ["fc1", "PC1", "PC4", "PC3", "c8", "c0", "pc4", "PC02", "pc3", "arc2", "arc1", "PC2", "pc0", "lc8", "arc3", "fc8", "lc4", "pc02", "c1", "c2", "PC8", "lc1", "rc4", "fc2", "rc1", "pc8", "rc0", "rc8", "rc3", "PC0", "arc02", "rc2", "rc02", "fc4", "lc2"], "r_cond": ["raccond", "rxCond", "rbcond", "R_condition", "rbsec", "rbcondition", "r_sec", "R_Cond", "r2cond", "rxpre", " r_condition", "rxcond", " r2condition", "R_pre", "rbCond", "r_condition", " r2cond", "r_pre", "raccondition", " r_sec", "r2condition", "r2Cond", "r_Cond", "r2sec", "racsec", "R_cond", " r2sec", " r2Cond", " r_Cond", "rxcondition", "racCond"], "l1": ["r8", "v2", "lc31", "l2", " l9", "v1", "lcn", "v0", "r1", "pln", "pl1", "l31", "l8", "L9", " l8", "L3", "r2", " l2", "r3", "l9", " l0", "lc1", " ln", "pl31", " l31", "L8", "Ln", "L2", "l0", "ln", " l3", "pl2", "v9", "L1", "l3", "L0", "lc2", "lc3"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,\n\n                                    uint64_t offset,\n\n                                    int n_start, int n_end,\n\n                                    int *num, QCowL2Meta *m)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int nb_clusters, i = 0;\n\n    QCowL2Meta *old_alloc;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);\n\n    if (ret == 0)\n\n        return 0;\n\n\n\n    nb_clusters = size_to_clusters(s, n_end << 9);\n\n\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    /* We keep all QCOW_OFLAG_COPIED clusters */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COPIED) {\n\n        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, 0);\n\n\n\n        cluster_offset &= ~QCOW_OFLAG_COPIED;\n\n        m->nb_clusters = 0;\n\n\n\n        goto out;\n\n    }\n\n\n\n    /* for the moment, multiple compressed clusters are not managed */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COMPRESSED)\n\n        nb_clusters = 1;\n\n\n\n    /* how many available clusters ? */\n\n\n\n    while (i < nb_clusters) {\n\n        i += count_contiguous_clusters(nb_clusters - i, s->cluster_size,\n\n                &l2_table[l2_index], i, 0);\n\n\n\n        if(be64_to_cpu(l2_table[l2_index + i]))\n\n            break;\n\n\n\n        i += count_contiguous_free_clusters(nb_clusters - i,\n\n                &l2_table[l2_index + i]);\n\n\n\n        cluster_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        if ((cluster_offset & QCOW_OFLAG_COPIED) ||\n\n                (cluster_offset & QCOW_OFLAG_COMPRESSED))\n\n            break;\n\n    }\n\n    nb_clusters = i;\n\n\n\n    /*\n\n     * Check if there already is an AIO write request in flight which allocates\n\n     * the same cluster. In this case we need to wait until the previous\n\n     * request has completed and updated the L2 table accordingly.\n\n     */\n\n    LIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {\n\n\n\n        uint64_t end_offset = offset + nb_clusters * s->cluster_size;\n\n        uint64_t old_offset = old_alloc->offset;\n\n        uint64_t old_end_offset = old_alloc->offset +\n\n            old_alloc->nb_clusters * s->cluster_size;\n\n\n\n        if (end_offset < old_offset || offset > old_end_offset) {\n\n            /* No intersection */\n\n        } else {\n\n            if (offset < old_offset) {\n\n                /* Stop at the start of a running allocation */\n\n                nb_clusters = (old_offset - offset) >> s->cluster_bits;\n\n            } else {\n\n                nb_clusters = 0;\n\n            }\n\n\n\n            if (nb_clusters == 0) {\n\n                /* Set dependency and wait for a callback */\n\n                m->depends_on = old_alloc;\n\n                m->nb_clusters = 0;\n\n                *num = 0;\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!nb_clusters) {\n\n        abort();\n\n    }\n\n\n\n    LIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);\n\n\n\n    /* allocate a new cluster */\n\n\n\n    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size);\n\n\n\n    /* save info needed for meta data update */\n\n    m->offset = offset;\n\n    m->n_start = n_start;\n\n    m->nb_clusters = nb_clusters;\n\n\n\nout:\n\n    m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end);\n\n\n\n    *num = m->nb_available - n_start;\n\n\n\n    return cluster_offset;\n\n}\n", "idx": 9548, "substitutes": {"bs": ["bos", "os", "bm", "cs", "ls", "ss", "bc", "BS", "pb", "bps", "ks", "lb", "sb", "bl", "es", "cb", "iss", "ds", "b", "fs", "bh", "gb", "ns", "ms", "bi", "us", "css", "bb", "ps", "ses", "base", "bits", "ob", "bas", "rs", "obs", "sa", "js", "vs"], "offset": ["shift", "pos", "timeout", "prefix", "size", "type", "id", "ref", "nb", "addr", "seq", "len", "off", "config", "reset", "slot", "fee", "loc", "url", "position", "end", "Offset", "part", "address", "fp", "alloc", "o", "error", "initial", "conn", "start", "index", "base", "ron", "set", "meta", "count", "location", "slice", "acl"], "n_start": ["n_last", " n_last", "nunlast", "nFstart", "n_base", "nunend", "nFend", "nFbase", "nunbase", " n_base", "nunstart", "nFlast"], "n_end": [" n_info", " n_range", "n__start", " n_all", " n_stop", " n2start", "n__end", " n2all", "nunrange", "n2end", " n2end", "nunend", "n_range", "n__info", "n_stop", "n_all", "nunstart", "n2start", "n2all", "n__all", " n2info", "nunstop", "n2info", "n_info"], "num": ["ctr", "fn", "NUM", "f", "id", "max", "mid", "seq", "len", "off", "node", "multi", "orig", "split", "con", "number", "mem", "dim", "index", "mult", "init", "Num", "uni", "batch", "alt", "count", "um"], "m": ["g", "man", "f", "bm", "pm", "sm", "mi", "mp", "metadata", "gm", "md", "c", "mr", "i", "d", "h", "p", "tm", "b", "fm", "cm", "mt", "machine", "v", "ms", "mem", "r", "o", "t", "rm", "dm", "e", "n", "mm", "M", "mc", "meta", "manager"], "s": ["g", "os", "sym", "f", "its", "cs", "state", "ls", "ss", "states", "xs", "y", "sq", "c", "stat", "is", "ks", "ins", "sv", "services", "sb", "p", "ts", "si", "sg", "S", "ds", "b", "settings", "fs", "se", "sl", "ns", "sim", "v", "spec", "ms", "t", "ps", "sites", "ses", "qs", "sync", "gs", "sn", "e", "sys", "sets", "su", "rs", "storage", "sa", "js", "stats", "vs", "ops"], "l2_index": ["l2Cvalue", "l2acposition", "l22dindex", "lapping_label", "l52_path", "l2fheader", "l2_slice", "l22dini", "l2Jlabel", "l2Mindex", "l22_ini", "l2hpath", "l22_element", "l2_label", "l2klabel", "l2Cposition", "l2_width", "l2kindex", "l1_size", "l96Jdimension", "l2dini", "l96_dimension", "l96Jlock", "lappingJlabel", "l2xinfo", "l4_index", "l2acindex", "l22_index", "laoamindex", "l2Hindex", "lapping_length", "l2Celement", "l2vregion", "l2delement", "l2_header", "l2_thread", "l2_element", "l2Mdimension", "l2Jindex", "l2amindex", "l4_info", "l2vkey", "ltwo_value", "lapping_index", "l22delement", "l52Jpath", "l2Mwidth", "l2flength", "l2_size", "l2acvalue", "l96_index", "l2dslice", "lappingJlength", "l2_position", "l2Jthread", "l2acelement", "l96_width", "laoamshape", "l96_lock", "l22_slice", "l2klength", "l2_key", "l4_slice", "l2hmodule", "l2vIndex", "l2amshape", "l2kheader", "l2Jheader", "l2xslice", "l2Cindex", "l2hindex", "l4_size", "l2hthread", "l2_Index", "l1_slice", "lao_index", "laoamcount", "l2Hwidth", "l2Jdimension", "l2_ini", "l1_index", "l2Jlength", "l2Hdimension", "l96Jwidth", "lapping_header", "l2_shape", "l2Jmodule", "l96Jindex", "lappingJheader", "l2xsize", "l4_key", "l2dindex", "l22dslice", "l2_lock", "l2_module", "ltwo_position", "l2ammodule", "l2Jpath", "l52_index", "laoammodule", "l52_module", "l2xindex", "l2_info", "l2_path", "l4_Index", "lao_count", "l52Jindex", "l2Jlock", "l2_dimension", "lao_module", "l2Jwidth", "l2_count", "l2flabel", "l2_value", "ltwo_element", "l2amcount", "l52_thread", "l52Jthread", "l52Jmodule", "l2findex", "l2vindex", "l2Hlock", "l4_region", "l2_region", "l1_length", "l2Mlock", "l2_length", "lappingJindex", "ltwo_index", "l2xlength", "lao_shape"], "ret": ["g", "rets", "rt", "f", "match", "att", "re", "RET", "ref", "mi", "fi", "rev", "ur", "result", "success", "len", "al", "iter", "i", "en", "back", "arr", "b", "fun", "rem", "j", "ext", "r", "opt", "val", "det", "conn", "bf", "obj", "info", "res", "reg", "nt", "status", "Ret", "alt", "hash", "count", "ber"], "l2_offset": ["l1_start", "l4_type", "l4_index", "l2xstart", "l4_offset", "l4_size", "l2_type", "l2xOffset", "l2_start", "l2_Offset", "l1_size", "l2xsize", "l2_size", "l1_Offset", "l1_offset", "l2xoffset"], "l2_table": ["l2_config", "l2thecontainer", "l2_feature", "lserver_offset", "l6_time", "l2_file", "l2_time", "l3_cache", "l2thepage", "l6_module", "ltwo_body", "l6_config", "l2spage", "l2xcontainer", "lserver_cache", "lserversoffset", "ltwostable", "l2xtable", "l02_stable", "lserver_type", "l2scontainer", "l02_table", "l6_index", "l3_size", "l2Jtable", "l2_block", "l02_page", "l6_stable", "l02_container", "l2stable", "l2dtree", "l6_body", "ltwosbody", "l2xstable", "l2stype", "l2_tree", "l2Jfeature", "l2thestable", "l2xmodule", "l2Pconfig", "l6_cache", "l2_tab", "l2_container", "l6_package", "l2_body", "l6_tab", "ltwosfeature", "l2tcache", "l2_size", "l2_view", "l2sview", "l2dtable", "l2_package", "l02spage", "lserverstype", "l2dfile", "ltwosview", "l2sbody", "l2Jview", "ltwo_feature", "l2jpackage", "l6_tree", "l02stable", "l2_stable", "l2xblock", "l2xpackage", "l2Ptab", "l2_type", "lserver_table", "ltwo_view", "l2Pindex", "l2Ptable", "lserverscache", "l2ttable", "l2jblock", "l6_file", "l02sstable", "l2_module", "l3_tree", "l2scache", "l2_cache", "l2jtable", "l2jmodule", "lserverstable", "l2sstable", "l2soffset", "l2xpage", "l6_block", "l2dtime", "l6_table", "l2tbody", "l2sfeature", "l2_page", "l3_table", "l2tstable", "l2thetable", "ltwo_table", "l2Jbody", "l02scontainer"], "cluster_offset": ["clusterPattribute", "clusterPstart", "clrome_position", "clinical_Offset", "cluster67offset", "clider_offset", "clause_end", "clause_area", "clard_offset", "clrome67offset", "cluster_padding", "clause_Offset", "clrome67url", "clancPoffset", "clusterFattribute", "clrome67position", "clusterLattribute", "clusterPpadding", "clusterLpadding", "cluster67format", "cluster_Offset", "clution_end", "clinical_limit", "clusterPoffset", "cluster_url", "clinical_option", "clusteracOffset", "clusterLoffset", "clusterFend", "cluster_size", "clancPOffset", "clard_start", "clanc_offset", "clause_addr", "clusteraclimit", "clider_size", "cluster67url", "cluster_area", "cluster_addr", "cluster67shift", "clanc_Offset", "clusterPend", "clancPleft", "cluster_entry", "cluster67Offset", "cluster_shift", "clusterPleft", "cluster_option", "cluster_off", "clusteracoffset", "clutionFend", "clusterLend", "cluster_set", "clusterPOffset", "cluster_ref", "clanc_format", "clancPformat", "clusteracoption", "clusterPformat", "cluster_limit", "clution_padding", "cluster_attribute", "clause_set", "clause_offset", "clider_ref", "clrome67shift", "clrome_url", "clrome_offset", "clutionFpadding", "clanc_left", "clause_off", "clinical_offset", "clider_count", "cluster67position", "clutionFoffset", "cluster_end", "cluster_start", "cluster_count", "clusterPentry", "clusterFpadding", "cluster_left", "clutionFattribute", "clution_offset", "cluster_position", "cluster_format", "cluster67left", "clard_entry", "clution_attribute", "clrome_shift", "clusterFoffset"], "nb_clusters": ["nb_zust", "nb_collusters", "nb_declust", "nb_declusters", "nb_scluster", "nb_lcust", "nb_contords", "nb_clicas", "nb__clodes", "nb_compusters", "nb00sclocations", "nb_splusters", "nb00clust", "nb_clappers", "nb_clocations", "nb_collicas", "nb_compores", "nb_slunks", "nb_clayers", "nb_llodes", "nb_cancers", "nb_glocations", "nb00sclorders", "nb_declappers", "nb_plicas", "nb67decayers", "nb_lcappers", "nb_chusters", "nb00clocations", "nb_chuster", "nb2chitors", "nb_clorders", "nb_clitors", "nb67decusters", "nb_plroups", "nb_clances", "nb_decunks", "nb_plashes", "nb_lcusters", "nb_filubes", "nb_combonents", "nb00flust", "nb_lcicas", "nb00clappers", "nb_decients", "nb_compashes", "nb_clists", "nb_glusters", "nb_licusters", "nb_plusters", "nb00clunks", "nb2clusters", "nb_tust", "nb_clodes", "nb_explubes", "nb__chords", "nb_decusters", "nb_chodes", "nb_custers", "nb67clusters", "nb_splurations", "nb_clashes", "nb_filunks", "nb_filists", "nb_clonents", "nb_combicas", "nb00sclodes", "nb00clorders", "nb_glorders", "nb_sclorders", "nb_chances", "nb00explusters", "nb00flappers", "nb_slorders", "nb_zusters", "nb_chores", "nb_lcroups", "nb_chroups", "nb_collords", "nb00flusters", "nb_flroups", "nb_splubes", "nb_clurations", "nb_clients", "nb2clores", "nb_clords", "nb2chients", "nb_decancers", "nb00flroups", "nb_blitors", "nb_filusters", "nb_glodes", "nb_licroups", "nb_declroups", "nb00clusters", "nb_cients", "nb2chores", "nb_splists", "nb_chicas", "nb_clancers", "nb_blancers", "nb_explunks", "nb_blients", "nb_combroups", "nb_ciders", "nb_tusters", "nb_declayers", "nb_condients", "nb00clodes", "nb_turations", "nb_clunks", "nb_chients", "nb_tappers", "nb_zurations", "nb00explunks", "nb_lconents", "nb_splappers", "nb_blusters", "nb_cliders", "nb_combusters", "nb_clust", "nb_sclodes", "nb_flust", "nb_bluster", "nb2clients", "nb__chodes", "nb_splust", "nb_flappers", "nb__clusters", "nb_sclashes", "nb_plonents", "nb_explists", "nb_explusters", "nb_collodes", "nb_contusters", "nb67decunks", "nb_declunks", "nb2chusters", "nb_decorders", "nb__chicas", "nb_llorders", "nb_cluster", "nb_condusters", "nb_deciders", "nb_bliders", "nb00clubes", "nb00explubes", "nb_zappers", "nb_llocations", "nb67clorders", "nb_blances", "nb_splunks", "nb_sclores", "nb_licances", "nb_clubes", "nb_chords", "nb_decayers", "nb_compuster", "nb2clitors", "nb_blroups", "nb_declorders", "nb67clayers", "nb__chusters", "nb_pluster", "nb_clroups", "nb_licuster", "nb_llusters", "nb_blores", "nb_flusters", "nb00clroups", "nb_chitors", "nb00sclusters", "nb_condores", "nb_conditors", "nb_sclocations", "nb00explists", "nb_plores", "nb_sclusters", "nb00clists", "nb_contodes", "nb_clores", "nb_slayers", "nb_slusters", "nb__clicas", "nb67clunks", "nb__clords", "nb_conticas", "nb67decorders"], "old_alloc": [" old_meta", " old_aux", "old__aux", "old_stat", "old2alloc", "old_meta", "old__alloc", " old_stat", "old2stat", "old2aux", "old__stat", "old_aux", "old__meta", "old2meta"]}}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "static int tx_consume(Rocker *r, DescInfo *info)\n\n{\n\n    PCIDevice *dev = PCI_DEVICE(r);\n\n    char *buf = desc_get_buf(info, true);\n\n    RockerTlv *tlv_frag;\n\n    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];\n\n    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };\n\n    uint32_t pport;\n\n    uint32_t port;\n\n    uint16_t tx_offload = ROCKER_TX_OFFLOAD_NONE;\n\n    uint16_t tx_l3_csum_off = 0;\n\n    uint16_t tx_tso_mss = 0;\n\n    uint16_t tx_tso_hdr_len = 0;\n\n    int iovcnt = 0;\n\n    int err = ROCKER_OK;\n\n    int rem;\n\n    int i;\n\n\n\n    if (!buf) {\n\n        return -ROCKER_ENXIO;\n\n    }\n\n\n\n    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));\n\n\n\n    if (!tlvs[ROCKER_TLV_TX_FRAGS]) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));\n\n    if (!fp_port_from_pport(pport, &port)) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_OFFLOAD]) {\n\n        tx_offload = rocker_tlv_get_u8(tlvs[ROCKER_TLV_TX_OFFLOAD]);\n\n    }\n\n\n\n    switch (tx_offload) {\n\n    case ROCKER_TX_OFFLOAD_L3_CSUM:\n\n        if (!tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) {\n\n            return -ROCKER_EINVAL;\n\n        }\n\n        break;\n\n    case ROCKER_TX_OFFLOAD_TSO:\n\n        if (!tlvs[ROCKER_TLV_TX_TSO_MSS] ||\n\n            !tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) {\n\n            return -ROCKER_EINVAL;\n\n        }\n\n        break;\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) {\n\n        tx_l3_csum_off = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]);\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_TSO_MSS]) {\n\n        tx_tso_mss = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_MSS]);\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) {\n\n        tx_tso_hdr_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]);\n\n    }\n\n\n\n    rocker_tlv_for_each_nested(tlv_frag, tlvs[ROCKER_TLV_TX_FRAGS], rem) {\n\n        hwaddr frag_addr;\n\n        uint16_t frag_len;\n\n\n\n        if (rocker_tlv_type(tlv_frag) != ROCKER_TLV_TX_FRAG) {\n\n            err = -ROCKER_EINVAL;\n\n            goto err_bad_attr;\n\n        }\n\n\n\n        rocker_tlv_parse_nested(tlvs, ROCKER_TLV_TX_FRAG_ATTR_MAX, tlv_frag);\n\n\n\n        if (!tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR] ||\n\n            !tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]) {\n\n            err = -ROCKER_EINVAL;\n\n            goto err_bad_attr;\n\n        }\n\n\n\n        frag_addr = rocker_tlv_get_le64(tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR]);\n\n        frag_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]);\n\n\n\n        iov[iovcnt].iov_len = frag_len;\n\n        iov[iovcnt].iov_base = g_malloc(frag_len);\n\n        if (!iov[iovcnt].iov_base) {\n\n            err = -ROCKER_ENOMEM;\n\n            goto err_no_mem;\n\n        }\n\n\n\n        if (pci_dma_read(dev, frag_addr, iov[iovcnt].iov_base,\n\n                     iov[iovcnt].iov_len)) {\n\n            err = -ROCKER_ENXIO;\n\n            goto err_bad_io;\n\n        }\n\n\n\n        if (++iovcnt > ROCKER_TX_FRAGS_MAX) {\n\n            goto err_too_many_frags;\n\n        }\n\n    }\n\n\n\n    if (iovcnt) {\n\n        /* XXX perform Tx offloads */\n\n        /* XXX   silence compiler for now */\n\n        tx_l3_csum_off += tx_tso_mss = tx_tso_hdr_len = 0;\n\n    }\n\n\n\n    err = fp_port_eg(r->fp_port[port], iov, iovcnt);\n\n\n\nerr_too_many_frags:\n\nerr_bad_io:\n\nerr_no_mem:\n\nerr_bad_attr:\n\n    for (i = 0; i < ROCKER_TX_FRAGS_MAX; i++) {\n\n        if (iov[i].iov_base) {\n\n            g_free(iov[i].iov_base);\n\n        }\n\n    }\n\n\n\n    return err;\n\n}\n", "idx": 9574, "substitutes": {"r": ["g", "rw", "rt", "f", "re", "self", "ra", "rg", "rob", "c", "mr", "sr", "d", "dr", "rc", "ru", "ro", "p", "lr", "rss", "rl", "rf", "b", "R", "rb", "v", "rx", "reader", "br", "t", "o", "kr", "w", "m", "e", "er", "rs", "rar", "rr", "rh", "s"], "info": ["linux", "text", "iso", "thin", "rt", "type", "f", "id", "bis", "diff", "ctx", "description", "api", "fi", "now", "inf", "Info", "user", "afi", "off", "d", "config", "rc", "auth", "p", "options", "si", "rf", "extra", "fs", "io", "inner", "end", "prof", "INFO", "entry", "source", "error", "txt", "req", "def", "fo", "buff", "conf", "init", "about", "fw", "information", "manager", "data"], "dev": ["debug", "tr", "device", "pro", "proc", "ra", "raf", "ver", "pack", "ev", "ro", "rc", "Dev", "end", "prof", "di", "dd", "def", "conn", "lib", "rec", "w", "conf", "reg", "res", "fin", "data"], "buf": ["cas", "prop", "text", "block", "ctx", "f", "src", "vec", "callback", "path", "aux", "fi", "proc", "result", "bc", "bag", "seq", "pb", "box", "conv", "rc", "config", "bytes", "cb", "pack", "b", "fb", "queue", "doc", "context", "feed", "v", "cv", "fp", "header", "alloc", "br", "bin", "Buffer", "uf", "cf", "buff", "buffer", "desc", "func", "obj", "msg", "fw", "uc", "fd", "data"], "tlv_frag": ["tlvsbrags", "tlv_flanch", "tlv_franch", "tlv_fragged", "tlv_flags", "tlvsfranch", "tlv_brag", "tlvsbranch", "tlvsbrag", "tlvsfragged", "tlv_frags", "tlvsfrag", "tlv_bragged", "tlv_flagged", "tlvsbragged", "tlv_branch", "tlv_brags", "tlvsfrags", "tlv_flag"], "tlvs": ["intlve", "tlvstates", "glve", "intjecte", "telld", "tlfe", "tlvns", "Tlvd", "tservs", "Tlvns", "taggs", "tlegi", "tlle", "Tlevns", "tcfs", "tlls", "tlvn", "tdepn", "tlfs", "tlve", "twlu", "tcfn", "tlfns", "tcpn", "intlvu", "tLVs", "untlvs", "tcps", "tells", "tlevb", "tservu", "tllns", "tLVS", "tcfabs", "tlegs", "tlvabs", "intjects", "itllabs", "untlvstates", "attlvS", "tLVids", "trellstates", "tlvb", "itlvabs", "untrellstates", "tlevd", "tLVn", "Tlevb", "tjectu", "trelld", "tlevu", "tlfb", "attlvn", "Tlvs", "tservd", "itlvn", "Tlvb", "tlln", "tlege", "tllS", "tlvu", "tlvd", "tlfi", "tdeps", "trells", "itlvs", "tlvS", "taggu", "glegi", "untrelld", "tlld", "tdepS", "attdeps", "attdepS", "tlevstates", "tellstates", "attlvs", "glvs", "attdepids", "Tlevu", "tlfd", "attlvids", "tagge", "tjects", "glege", "tllb", "glvi", "tleve", "Tlvu", "tdepids", "tcpabs", "tlvi", "Tlevs", "itlls", "tlevi", "tjecte", "tlevs", "tllu", "tlvids", "intjectu", "itlln", "intlvs", "twls", "attdepn", "tllids", "twld", "Tlevd", "tllabs", "untrells", "untlvd", "tlevns", "glegs"], "ROCKER_TLV_TX_MAX": ["ROCKER_TLV_TEXT_Max", "ROCKER_TLV_TXIDMAX", "ROCKER_TLV_TXPMAX", "ROCKER_TLV_TXIDMax", "ROCKER_TLV_TEXT_MAX", "ROCKER_TLV_TXIDSIZE", "ROCKER_TLV_TXPSIZE", "ROCKER_TLV_TX_Max", "ROCKER_TLV_TEXT_SIZE", "ROCKER_TLV_TXPMax", "ROCKER_TLV_TX_SIZE"], "iov": ["vl", "ctr", "redits", "nr", "vec", "NT", "nc", "ov", "fi", "argo", "seq", "ores", "urses", "ounters", "ources", "net", "io", "umers", "mem", "ret", "nv", "rowd", "nn", "uda", "sn", "obj", "ounter", "ibl", "uments"], "pport": ["cas", "support", "mut", "ann", "plugin", "voice", "prop", "la", "PORT", "pit", "iff", "ctx", "quart", "service", "fi", "voc", "imet", "supp", "serv", " sport", "regon", "aim", "vc", "claim", "ault", "config", "fund", "lex", "ort", "nil", "iss", "loc", "vision", "Support", "shape", "fl", "ct", "pair", "pt", "sex", "fc", "cv", "pe", "lv", "prot", "nat", "opt", "val", "pet", "pp", "rog", "upp", "rest", "pull", "mot", "typ", "feat", "choice", "pid", "itness", "mitt"], "port": ["hop", "prop", "pos", "version", "pass", "PORT", "type", "pn", "match", "service", "path", "ptr", "ip", "host", "Port", "claim", "ORT", "config", "pr", "p", "per", "ort", "loc", "protect", "pir", "orts", "cp", "pt", "position", "address", "rot", "header", "length", "val", "priority", "component", "reg", "porter", "import", "target", "ports"], "rem": ["ok", "Rem", " pri", "resp", "ptr", "err", "ip", "REM", "rc", "ort", " res", "mem", "num", "rx", "error", " ii", "rec", "m", "rom", "res", "out", " err", "rib"], "i": ["ii", "li", "f", "id", "I", "ip", "c", "is", "iter", "d", "h", "p", "lit", "pi", "j", "z", "l", "start", "index", "m", "e", "n", "init", "eni", "x", "it"], "iovcnt": ["iovlcnt", "iolcnc", "iovuncnc", "iovcnc", "iovlcpy", "iovscnt", "iolcsec", "iovuncsec", "iovcsec", "iovscsec", "iocnt", "iovscpy", "iovscnc", "iovlcsec", "iolcpy", "iovuncnt", "iocsec", "iovuncpy", "iolcnt", "iovlcnc", "iocpy", "iovcpy", "iocnc"]}}
{"project": "FFmpeg", "commit_id": "bd8ae4885b905415f0e86d4e348c4b72be81e6e6", "target": 0, "func": "AVFilterFormats *avfilter_all_colorspaces(void)\n\n{\n\n    return avfilter_make_format_list(35,\n\n                PIX_FMT_YUV444P,  PIX_FMT_YUV422P,  PIX_FMT_YUV420P,\n\n                PIX_FMT_YUV411P,  PIX_FMT_YUV410P,\n\n                PIX_FMT_YUYV422,  PIX_FMT_UYVY422,  PIX_FMT_UYYVYY411,\n\n                PIX_FMT_YUVJ444P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ420P,\n\n                PIX_FMT_YUV440P,  PIX_FMT_YUVJ440P,\n\n                PIX_FMT_RGB32,    PIX_FMT_BGR32,\n\n                PIX_FMT_RGB32_1,  PIX_FMT_BGR32_1,\n\n                PIX_FMT_RGB24,    PIX_FMT_BGR24,\n\n                PIX_FMT_RGB565,   PIX_FMT_BGR565,\n\n                PIX_FMT_RGB555,   PIX_FMT_BGR555,\n\n                PIX_FMT_RGB8,     PIX_FMT_BGR8,\n\n                PIX_FMT_RGB4_BYTE,PIX_FMT_BGR4_BYTE,\n\n                PIX_FMT_GRAY16BE, PIX_FMT_GRAY16LE,\n\n                PIX_FMT_GRAY8,    PIX_FMT_PAL8,\n\n                PIX_FMT_MONOWHITE,PIX_FMT_MONOBLACK\n\n                PIX_FMT_NV12,     PIX_FMT_NV21);\n\n}\n", "idx": 9576, "substitutes": {}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,\n\n              CharDriverState *chrA, CharDriverState *chrB,\n\n              int clock, int it_shift)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    SerialState *d;\n\n\n\n    dev = qdev_create(NULL, \"escc\");\n\n    qdev_prop_set_uint32(dev, \"disabled\", 0);\n\n    qdev_prop_set_uint32(dev, \"frequency\", clock);\n\n    qdev_prop_set_uint32(dev, \"it_shift\", it_shift);\n\n    qdev_prop_set_chr(dev, \"chrB\", chrB);\n\n    qdev_prop_set_chr(dev, \"chrA\", chrA);\n\n    qdev_prop_set_uint32(dev, \"chnBtype\", ser);\n\n    qdev_prop_set_uint32(dev, \"chnAtype\", ser);\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irqB);\n\n    sysbus_connect_irq(s, 1, irqA);\n\n    if (base) {\n\n        sysbus_mmio_map(s, 0, base);\n\n    }\n\n\n\n    d = FROM_SYSBUS(SerialState, s);\n\n    return &d->mmio;\n\n}\n", "idx": 9584, "substitutes": {"base": ["weak", "server", "prefix", "block", "f", "id", "build", "local", "other", "k", "ada", "ip", "byte", "addr", "seq", "c", "db", "i", "ached", "rc", "p", "reset", "http", "boot", "b", "extra", "cp", "use", "io", "range", "full", "gb", "core", "scale", "bi", "br", "bin", "area", "force", "l", "sync", "buffer", "pad", "unit", "info", "set", "bas", "out", "null", "root", "ase", "name", "slave", "bf", "data", "Base", "ix", "cache"], "irqA": ["irchB", "irchN", "irqN", "ariqueN", "irpB", "irqueN", "ircingA", "irqP", "irqArch", "irchArch", "irqRA", "irqsRA", "ariqArch", "ariqA", "ircingB", "irqueA", "irchRA", "irqsArch", " irqBA", "irpBA", "ariqRA", "ariqueA", "irqsN", "irpA", "irqueArch", "ariqueArch", "irpP", "irqBA", "ariqN", "ariqueRA", " ircingB", "irchA", "irchP", " ircingP", "ircingP", " irqP", "irchBA", " ircingA", " ircingBA", "irqueRA", "ircingBA", "irqsA"], "irqB": ["irchB", "irqBs", "irqGB", "irchGB", "irceI", "irqI", "irfBI", "irpB", "irceBs", "irchD", "irqD", "irquGB", "virqGB", "virquBI", "virquGB", "IRpI", "IRpB", "irquB", "irpBs", "virqB", "irqueA", "irchBI", "irfB", "irqBI", "IRqBs", "irpA", "IRpBs", "irqueBs", "irquBI", "IRqB", "irqueI", "irquD", "irqueB", "IRqA", "irpI", "irceA", "IRpA", "irceB", "IRqI", "virqBI", "virquB", "virquD", "irfD", "irfGB", "virqD"], "chrA": ["charAR", " chrAPI", "ChrG", "CharG", "chrcC", "ChrA", "chdrG", "chrcB", "charA", "chrcAPI", "chrC", "charG", "charmB", "charAPI", "chrfC", "charmA", "chrG", "chdrAR", "chrfAPI", " chrfB", "chdrA", "charmAR", " chrfC", " chrfAPI", "charmG", "CharAR", "chrfA", "chrAPI", "chrfB", "CharB", "chrAR", "ChrB", "chrcA", "chdrB", "CharA", "charB", " chrfA", " chrC", "ChrAR", "charC"], "chrB": ["ChrC", "chrUB", "ChrBB", "ChrUB", "ChrA", "chlA", "charW", "chrtDB", "charA", "chrfBB", "chlB", "chrtC", "chrC", "charBB", "chrW", "chlW", "chrtBB", "chrfDB", "chrfUB", "chrtUB", "chrBB", "CharUB", "chrtB", "CharBB", "ChrDB", "charDB", "chrtW", "charUB", "chrDB", "chrfB", "CharB", "ChrB", "chlC", "ChrW", "CharA", "charB", "CharW", "CharC", "charC", "chrtA", "CharDB"], "clock": ["server", "axis", "shift", "block", " clocks", "chron", "serial", "poll", "seq", "sq", "c", "timer", "sleep", "config", "offset", "si", "seed", "watch", "year", "tick", "loop", "spec", "ac", "rot", "time", "sync", "lock", "sys", "ctl", "set", "lc", "sec", "root", "hour", "Clock", "counter", "align"], "it_shift": ["it_size", "ip_size", "it_count", "lit_size", "lit_scale", "it_offset", "it_scale", "lit_shift", "ip_shift", "lit_offset", "ip_push", "it_push", "ip_count"], "dev": ["die", "self", "serial", "adv", "c", "ver", "ev", "sh", "driver", "ch", "w", "ow", "e", "info", "ve", "dat", "prop", "pub", "pro", "api", "user", "db", "off", "mod", "enc", "grad", "test", "error", "conn", "var", "ad", "dt", "debug", "de", "valid", "block", "f", "diff", "dom", "rad", "DEV", "gu", "app", "di", "v", "r", "req", "priv", "bug", "g", "wd", "device", "md", "gd", "p", "dy", "temp", "der", "Dev", "dc", "spec", "t", "def", "od", "cam", "conf", "n", "data", "cd"], "s": ["server", "g", "os", "f", "cs", "state", "self", "ss", "c", "is", "i", "a", "services", "sb", "new", "h", "p", "sg", "sp", "S", "session", "ds", "b", "sh", "ssl", "fs", "http", "se", "sl", "ns", "v", "spec", "si", "t", "r", "o", "ps", "l", "u", "sync", "gs", "w", "m", "south", "e", "n", "sys", "su", "sk", "js", "stats"], "d": ["g", "dat", "sd", "f", "did", "state", "D", "md", "c", "gd", "db", " dd", "i", "pd", "p", "dy", "ds", "b", "driver", "j", "nd", "ld", "bd", "z", "di", "dc", "dd", "v", "ind", "t", "o", "r", "std", "l", "u", "dx", "od", "w", "m", "dh", "e", "n", "fd", "ad", "dl", "data", "dt", "cd", "dad"]}}
{"project": "FFmpeg", "commit_id": "a744064c4155bde063b9e8a47699542be3b8e5eb", "target": 1, "func": "static void free_geotags(TiffContext *const s)\n\n{\n\n    int i;\n\n    for (i = 0; i < s->geotag_count; i++) {\n\n        if (s->geotags[i].val)\n\n            av_freep(&s->geotags[i].val);\n\n    }\n\n    av_freep(&s->geotags);\n\n\n}", "idx": 9598, "substitutes": {"s": ["styles", "sym", "f", "request", "args", "parts", "cs", "ls", "self", "sf", "ss", "xs", "c", "sq", "a", "sup", "services", "params", "sb", "d", "es", "p", "options", "sg", "si", "S", "ds", "settings", "fs", "ssl", "sts", "ns", "hs", "css", "ans", "o", "t", "qs", "ses", "your", "sync", "gs", "conf", "sets", "sys", "comments", "rs", "shared", "cons", "js", "stats", "ops", "features"], "i": ["ii", "abi", "li", "uri", "hi", "f", "id", "phi", "I", "mu", "oi", "fi", "c", "yi", "iu", "a", "jp", "ini", "d", "multi", "ji", "p", "ri", "slice", "si", "b", "di", "pi", "io", "uli", "j", "gi", "ie", "part", "key", "in", "v", "ti", "xi", "zi", "bi", "qi", "r", "length", "ui", "o", "l", "ci", "u", "index", "start", "m", "e", "init", "info", "ai", "lc", "eni", "count", "x", "ix"]}}
{"project": "FFmpeg", "commit_id": "c3afa4db913668e50ac8ffc0bc66621664adc1f4", "target": 1, "func": "void ff_bink_idct_c(DCTELEM *block)\n\n{\n\n    int i;\n\n    DCTELEM temp[64];\n\n\n\n    for (i = 0; i < 8; i++)\n\n        bink_idct_col(&temp[i], &block[i]);\n\n    for (i = 0; i < 8; i++) {\n\n        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );\n\n    }\n\n}\n", "idx": 9607, "substitutes": {"block": ["chain", "clean", "type", "flow", "view", "k", "ip", "Block", "table", "byte", "box", "off", "bl", "new", "condition", "blocks", "cell", "inner", "object", "frame", "tick", "end", "pre", "address", "coll", "record", "row", "parent", "filter", "cl", "time", "call", "point", "index", "buffer", "lock", "col", "data", "tx", "unit", "base", "out", "name", "batch", "none", "element", "group", "check", "line"], "i": ["ii", "ti", "abi", "ni", "li", "uri", "hi", "f", "id", "phi", "I", "k", "ip", "oi", "mi", "fi", "y", "c", "ini", "is", "a", "d", "iu", "multi", "ri", "p", "si", "b", "pi", "io", "j", "gi", "ie", "key", "z", "v", "xi", "bi", "zi", "di", "qi", "o", "ui", "r", "length", "l", "ci", "u", "index", "m", "e", "init", "info", "ai", "line", "lc", "eni", "vi", "x", "ix", "it"], "temp": ["size", "type", "args", "flow", "zip", "table", "output", "c", "template", "iter", "params", "config", "offset", "input", "order", "b", "blocks", "fake", "cell", "app", "Temp", "test", "context", "tem", "pre", "partial", "tmp", "v", "row", "inv", "level", "store", "index", "emp", "buffer", "col", "lock", "tx", "base", "unit", "out", "null", "var", "data", "exec", "cache"]}}
{"project": "qemu", "commit_id": "603987488c61ca02ee99890d07cdaecdb118a659", "target": 1, "func": "PCIBus *pci_pmac_init(qemu_irq *pic)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    UNINState *d;\n\n\n\n    /* Use values found on a real PowerMac */\n\n    /* Uninorth main bus */\n\n    dev = qdev_create(NULL, \"Uni-north main\");\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    d = FROM_SYSBUS(UNINState, s);\n\n    d->host_state.bus = pci_register_bus(&d->busdev.qdev, \"pci\",\n\n                                         pci_unin_set_irq, pci_unin_map_irq,\n\n                                         pic, 11 << 3, 4);\n\n\n\n    pci_create_simple(d->host_state.bus, 11 << 3, \"Uni-north main\");\n\n\n\n    sysbus_mmio_map(s, 0, 0xf2800000);\n\n    sysbus_mmio_map(s, 1, 0xf2c00000);\n\n\n\n    /* DEC 21154 bridge */\n\n#if 0\n\n    /* XXX: not activated as PPC BIOS doesn't handle multiple buses properly */\n\n    pci_create_simple(d->host_state.bus, 12 << 3, \"DEC 21154\");\n\n#endif\n\n\n\n    /* Uninorth AGP bus */\n\n    pci_create_simple(d->host_state.bus, 13 << 3, \"Uni-north AGP\");\n\n\n\n    /* Uninorth internal bus */\n\n#if 0\n\n    /* XXX: not needed for now */\n\n    pci_create_simple(d->host_state.bus, 14 << 3, \"Uni-north internal\");\n\n#endif\n\n\n\n    return d->host_state.bus;\n\n}\n", "idx": 9616, "substitutes": {"pic": ["bus", "pass", "file", "nic", "ip", "fi", "proc", "bc", "cci", "c", "pc", "i", "jp", "config", "p", "pi", "ic", "fs", "Pic", "pres", "fc", "ac", "xi", "fp", "pin", "mac", "pick", "lib", "pins", "cus", "sync", "oc", "pa", "sys", "lc", "ig", "pid"], "dev": ["bus", "dem", "g", "de", "sd", "f", "device", "diff", "err", "dom", "serial", "rad", "adv", "DEV", "c", "ver", "gd", "ev", "p", "dy", "sh", "der", "ds", "b", "driver", "Dev", "di", "v", "dc", "dd", "ch", "spec", "dn", "r", "da", "def", "conn", "w", "m", "conf", "dm", "e", "n", "info", "priv", "ad", "ve", "data", "bug", "cd"], "s": ["g", "os", "sd", "f", "src", "k", "sw", "cs", "state", "self", "ss", "c", "sq", "sup", "i", "is", "a", "sv", "sb", "services", "h", "p", "ts", "si", "sh", "S", "ds", "b", "session", "fs", "ssl", "settings", "scope", "se", "sl", "ns", "v", "spec", "us", "t", "r", "o", "ps", "ses", "l", "sc", "sync", "gs", "w", "m", "sn", "south", "e", "n", "sys", "su", "rs", "secure", "js"], "d": ["g", "dat", "de", "dict", "wd", "sd", "hd", "f", "id", "device", "did", "self", "D", "xd", "dom", "td", "md", "c", "db", "gd", "ud", "i", "mad", "pd", "dr", "p", "dy", "ed", "rd", "ds", "b", "driver", "j", "done", "nd", "ld", "vd", "bd", "di", "v", "dc", "dd", "z", "dn", "t", "o", "r", "da", "ind", "l", "u", "ded", "dx", "w", "m", "dh", "e", "n", "fd", "dl", "ad", "data", "dt", "cd"]}}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static void json_message_process_token(JSONLexer *lexer, GString *input,\n\n                                       JSONTokenType type, int x, int y)\n\n{\n\n    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);\n\n    QDict *dict;\n\n\n\n    switch (type) {\n\n    case JSON_LCURLY:\n\n        parser->brace_count++;\n\n        break;\n\n    case JSON_RCURLY:\n\n        parser->brace_count--;\n\n        break;\n\n    case JSON_LSQUARE:\n\n        parser->bracket_count++;\n\n        break;\n\n    case JSON_RSQUARE:\n\n        parser->bracket_count--;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    dict = qdict_new();\n\n    qdict_put(dict, \"type\", qint_from_int(type));\n\n    qdict_put(dict, \"token\", qstring_from_str(input->str));\n\n    qdict_put(dict, \"x\", qint_from_int(x));\n\n    qdict_put(dict, \"y\", qint_from_int(y));\n\n\n\n    parser->token_size += input->len;\n\n\n\n    g_queue_push_tail(parser->tokens, dict);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               parser->bracket_count + parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit_bad;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /*\n\n     * Clear out token list and tell the parser to emit an error\n\n     * indication by passing it a NULL list\n\n     */\n\n    json_message_free_tokens(parser);\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    /* parser->emit takes ownership of parser->tokens.  */\n\n    parser->emit(parser, parser->tokens);\n\n    parser->tokens = g_queue_new();\n\n    parser->token_size = 0;\n\n}\n", "idx": 9619, "substitutes": {"lexer": ["visione", "visioner", "licer", " lexe", "Lexera", "lice", " lexeder", "visionator", "loge", "ntaxer", "cler", "Lexer", "lexers", "ntaxker", "lexker", "Lexers", "loger", "Lexoder", "Lexker", "lexator", "logker", "ntaxe", "lexeder", "visionoder", "Lexeder", "cloder", "lexoder", "liceder", "logera", "clator", " lexers", "cle", "licers", "lexe", "Lexe", "lexera", "Lexator", "ntaxera"], "input": ["text", "ctx", "request", "format", "view", "xml", "state", "inf", "output", "instance", "config", "document", "model", "temp", "expr", "session", "qa", "inner", "context", "array", "expression", "op", "image", "magic", "inc", "reader", "source", "select", "resource", "argument", "form", "buffer", "query", "data", "current", "token", "storage", "raw", "element", "import", "field", "list", "Input"], "type": ["action", "version", "like", "block", "size", "id", "format", "state", "typ", "class", "i", "by", "method", "p", "Type", "shape", "year", "direction", "style", "TYPE", "part", "pre", "key", "code", "pe", "spec", "op", "parent", "t", "length", "handler", "error", "sort", "kind", "level", "time", "o", "call", "ty", "post", "info", "token", "value", "set", "ype", "name", "py", "python", "ping", "data", "types", "number", "field", "str"], "x": ["size", "f", "on", "id", "xs", "c", "X", "ex", "i", "d", "h", "p", "xxx", "b", "key", "z", "v", "code", "in", "t", "length", "l", "index", "xx", "w", "m", "xt", "e", "n", "name", "data", "number", "ix"], "y": ["zy", "ey", "yy", "yo", "id", "iy", "ny", "ys", "ya", "yi", "i", "p", "dy", "xxx", "vy", "gy", "cy", "year", "j", "key", "z", "ye", "ay", "sy", "t", "o", "length", "ery", "sky", "ym", "xx", "ady", "ry", "w", "n", "sys", "Y", "py", "oy"], "parser": ["server", "before", "message", "loader", "arser", "file", "comment", "self", "master", "pack", "lex", "winner", "worker", "missing", "json", "init", "join", "token", "root", "paragraph", "txt", "plugin", "pass", "player", "ger", "lp", "http", "builder", "test", "code", "parent", "copy", "handler", "tree", "star", "er", "ring", "holder", "s", "script", "manager", "processor", "pillar", "list", "man", "block", "xml", "php", "upper", "gg", "super", "config", "document", "part", "jack", "layer", "argument", "wp", "command", "sys", "lower", "value", "book", "post", "writer", "g", "general", "parse", "author", "args", "pool", "local", "private", "instance", "node", "above", "p", "der", "seed", "ars", "inner", "operator", "enter", "rule", "magic", "spec", "entry", "reader", "Parser", "buffer", "this", "storage", "python", "data", "slice"], "dict": ["parse", "clean", "file", "diff", "comment", "state", "ict", "table", "result", "module", "db", "d", "cache", "patch", "dr", "config", "model", "document", "auth", "dog", "response", "cat", "slice", "arr", "der", "session", "pkg", "database", "doc", "pair", "json", "array", "di", "coll", "record", "dd", "code", "package", "copy", "reader", "df", "dot", "def", "sum", "tree", "map", "conf", "init", "obj", "info", "fix", "bug", "hash", "data", "dir", "pillar", "list", "str"], "brace_count": ["brace\u00b7size", "option_amount", "brace_index", "option_offset", "line_index", "brace\u00b7depth", "plate_count", "braceancecount", "line_len", "line_const", "plate\u00b7part", "line_length", "line_depth", "brace_offset", "brace\u00b7part", "plate_left", "plate\u00b7count", "brace_length", "brace\u00b7cast", "line_count", "brace_part", "plate\u00b7cast", "brace_const", "braceaccount", "braceancecast", "brace_len", "brace_amount", "plate\u00b7left", "braceacdepth", "line_size", "option_length", "line_min", "brace\u00b7count", "braceanceleft", "brace_min", "brace_cell", "brace_catch", "brace_size", "brace\u00b7min", "braceacoffset", "braceacmin", "plate_part", "brace_left", "plate_cast", "brace_cast", "line_catch", "line_cell", "brace_depth", "brace\u00b7left", "braceancepart", "braceacamount", "braceaclength", "option_count", "braceacsize"], "bracket_count": ["bracket_code", "bracket_weight", "bracket9length", "brace_weight", "bracket_length", "bracket_age", "brace_length", "brace_len", "bracket9weight", "bracketersize", "bracket9order", "bracketercount", "brace_size", "brace_age", "bracket_order", "bracket_size", "bracket9count", "bracketerdepth", "bracket_depth", "bracket_len", "brace_order", "brace_depth", "brace_code"]}}
{"project": "qemu", "commit_id": "041d95f42e39ed1d3a029332cab9966889f0aeb3", "target": 0, "func": "static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,\n\n                                              target_ulong eaddr, uint32_t pid)\n\n{\n\n#if !defined(FLUSH_ALL_TLBS)\n\n    CPUState *cs = CPU(ppc_env_get_cpu(env));\n\n    ppcemb_tlb_t *tlb;\n\n    hwaddr raddr;\n\n    target_ulong page, end;\n\n    int i;\n\n\n\n    for (i = 0; i < env->nb_tlb; i++) {\n\n        tlb = &env->tlb.tlbe[i];\n\n        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {\n\n            end = tlb->EPN + tlb->size;\n\n            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {\n\n                tlb_flush_page(cs, page);\n\n            }\n\n            tlb->prot &= ~PAGE_VALID;\n\n            break;\n\n        }\n\n    }\n\n#else\n\n    ppc4xx_tlb_invalidate_all(env);\n\n#endif\n\n}\n", "idx": 9629, "substitutes": {"env": ["server", "dat", "fen", "et", "np", "dict", "pg", "eve", "ctx", "args", "site", "cdn", "eng", "err", "nc", "ea", "exc", "anc", "ce", "c", "db", "exec", "en", "qt", "eu", "config", "ev", "enc", "cur", "console", "ep", "iss", "Environment", "net", "enh", "ah", "doc", "ext", "context", "icer", "core", "osc", "act", "viron", "cv", "v", "code", "environment", "here", "el", "txt", "que", "her", "req", "gui", "cf", "conn", "org", "pec", "conf", "e", "init", "er", "n", "ec", "eni", "erv", "ef", "inst", "dt", "vs", "cache"], "eaddr": ["evDR", "efDR", "adrs", "eadder", "ellrr", "ellDR", "evrs", "addr", "adder", "evder", "ellrs", "efdr", "eadrr", "ellder", "eadDR", "efrr", "efder", "elldr", "eadrs", "adrr", "evdr", "evrr"], "pid": ["pos", "prop", "np", "pipe", "pg", "pointer", "id", "pm", "path", "ip", "mi", "pl", "proc", "mid", "pb", "pc", "pu", "pd", "p", "ep", "vid", "pri", "pi", "pt", "cpu", "po", "phase", "pin", "ino", "pins", "pp", "od", "priority", "uid", "pa", "port", "py", "pty", "ping", "pod"], "cs": ["cas", "ics", "nc", "ls", "ss", "bc", "wcs", "c", "pc", "ca", "ks", "co", "ins", "vs", "ds", "settings", "fs", "acs", "CS", "core", "cks", "cc", "ns", "spec", "cms", "css", "ch", "ps", "qs", "cf", "sc", "ci", "sync", "cus", "sys", "cn", "rs", "sk", "ec", "lc", "ces", "Cs"], "tlb": ["tlu", "tflu", "ttbl", "blu", "plb", "ktlb", "pbl", "flp", " trl", "rtlab", "ptlu", "trl", "plab", "fbl", "tbl", "tfilo", "ntbl", "tflb", " tacl", "templp", "tlab", "lrl", "ptlb", "templab", "untla", "tla", "tilo", "Trl", "Tld", "tacl", "Tl", "flab", "Tlb", "rtlp", "tld", "ptilo", "rtbl", " tld", "tfacl", " tlr", " tlu", "ptacl", "bbl", "ktlu", "tempdl", "ttb", " tl", "tl", "untbl", "Tbl", "ntbf", "etlab", "blb", " tb", "ntlb", "tb", "bbf", "plp", "fdl", "etlp", "lbl", "llb", "Tb", "templb", " tlp", "ktbl", " tlab", " tilo", "ntlu", "etbl", "ll", "tdl", "ttla", "untlr", "untlb", "tlr", "tbf", "ttld", "ttlb", "rtlb", "ttlr", " tdl", "etlb", "flb", " tbl", "ktbf", "tlp", " tla"], "raddr": ["rbdr", "rbaddress", "ipaddress", "rdr", "waddr", " rptr", " raddress", "rwdb", " rdr", "wdr", "wptr", "rdb", "wdb", "rptr", "ipaddr", "rbptr", "rbaddr", "waddress", "rwaddr", "raddress", "rwaddress", "ipdb"], "page": ["server", "gap", "ph", "block", "pg", "Page", "pointer", "size", "site", "id", "wait", "limit", "eng", "ip", "pl", "edge", "proc", "result", "byte", "ver", "stop", "pc", "aa", "pack", "p", "offset", "per", "step", "order", "total", "pages", "key", "address", "age", "image", "row", "entry", "inc", "num", "pe", "area", "pp", "next", "ew", "start", "buffer", "current", "e", "n", "port", "month", "name", "count", "number", "line"], "end": ["pos", "append", "size", "type", "f", "id", "limit", "max", "ip", "edge", "ended", "pend", "c", "en", "d", "enc", "offset", "p", "END", "ep", "after", "ent", "End", "nd", "ending", "address", "z", "inc", "start", "index", "u", "head", "w", "post", "e", "n", "set", "name", "ad", "send", "stop", "tail", "x", "line"], "i": ["ii", "ni", "abi", "li", "uri", "f", "id", "phi", "I", "limit", "k", "mu", "api", "ip", "oi", "mi", "fi", "c", "yi", "iu", "a", "ini", "d", "multi", "ri", "p", "si", "b", "pi", "io", "uli", "j", "gi", "ami", "di", "xi", "zi", "ti", "v", "qi", "r", "ui", "t", "l", "ci", "u", "index", "start", "m", "e", "n", "info", "ai", "eni", "x", "it"]}}
{"project": "qemu", "commit_id": "9cd1e97a7ae2856ec00b5682db0dea17f42fc734", "target": 0, "func": "void pci_bridge_initfn(PCIDevice *dev, const char *typename)\n\n{\n\n    PCIBus *parent = dev->bus;\n\n    PCIBridge *br = PCI_BRIDGE(dev);\n\n    PCIBus *sec_bus = &br->sec_bus;\n\n\n\n    pci_word_test_and_set_mask(dev->config + PCI_STATUS,\n\n                               PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n\n\n    /*\n\n     * TODO: We implement VGA Enable in the Bridge Control Register\n\n     * therefore per the PCI to PCI bridge spec we must also implement\n\n     * VGA Palette Snooping.  When done, set this bit writable:\n\n     *\n\n     * pci_word_test_and_set_mask(dev->wmask + PCI_COMMAND,\n\n     *                            PCI_COMMAND_VGA_PALETTE);\n\n     */\n\n\n\n    pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI);\n\n    dev->config[PCI_HEADER_TYPE] =\n\n        (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n    pci_set_word(dev->config + PCI_SEC_STATUS,\n\n                 PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n\n\n    /*\n\n     * If we don't specify the name, the bus will be addressed as <id>.0, where\n\n     * id is the device id.\n\n     * Since PCI Bridge devices have a single bus each, we don't need the index:\n\n     * let users address the bus using the device name.\n\n     */\n\n    if (!br->bus_name && dev->qdev.id && *dev->qdev.id) {\n\n\t    br->bus_name = dev->qdev.id;\n\n    }\n\n\n\n    qbus_create_inplace(sec_bus, sizeof(br->sec_bus), typename, DEVICE(dev),\n\n                        br->bus_name);\n\n    sec_bus->parent_dev = dev;\n\n    sec_bus->map_irq = br->map_irq ? br->map_irq : pci_swizzle_map_irq_fn;\n\n    sec_bus->address_space_mem = &br->address_space_mem;\n\n    memory_region_init(&br->address_space_mem, OBJECT(br), \"pci_bridge_pci\", UINT64_MAX);\n\n    sec_bus->address_space_io = &br->address_space_io;\n\n    memory_region_init(&br->address_space_io, OBJECT(br), \"pci_bridge_io\", 65536);\n\n    br->windows = pci_bridge_region_init(br);\n\n    QLIST_INIT(&sec_bus->child);\n\n    QLIST_INSERT_HEAD(&parent->child, sec_bus, sibling);\n\n}\n", "idx": 9630, "substitutes": {"dev": ["bus", "dem", "debug", "vol", "de", "fr", "valid", "block", "die", "pub", "device", "diff", "comment", "pro", "err", "self", "dom", "rad", "private", "gu", "DEV", "adv", "ver", "user", "dist", "d", "feature", "node", "config", "ev", "mod", "development", "enc", "p", "der", "app", "driver", "img", "Dev", "test", "grad", "end", "v", "dc", "dd", "client", "error", "req", "def", "conn", "w", "conf", "dm", "child", "info", "nt", "google", "root", "var", "priv", "bug", "data", "dt"], "typename": ["tylename", "tyrenname", "Typenature", "typerame", "typlenename", "Typenname", "tyrename", "typpenAME", "typarename", "typerature", "tylenature", "tylenname", "typerAME", "typpenname", "Typenename", "typenename", "typarenature", "typlenname", "Typename", "tyrenename", "typlename", "tylenAME", "typerename", "typenAME", "Tylenature", "typarenname", "typenature", "typenname", "tylenename", "Tylenname", "Tylename", "typarenename", "typpename", "typlenAME", "typpenename", "typername", "tyrenAME", "Tylenename"], "parent": ["g", "block", "ctx", "pool", "Parent", "comment", "device", "ref", "self", "host", "prev", "gu", "c", "dist", "instance", "by", "node", "new", "p", "str", "bridge", "test", "pt", "fat", "par", "op", "r", "opt", "def", "conn", "component", "current", "unit", "child", "port", "reg", "root", "var", "name", "ram", "data", "cache"], "br": ["nor", "ref", "err", "mr", "ver", "bl", "ev", "lr", "plug", "b", "bed", "pre", "bd", "ch", "shr", "cr", "gr", "bro", "browser", "broad", "or", "root", "bm", "pro", "hr", "ov", "ger", "off", "ru", "bg", "j", "img", "vr", "coll", "el", "kr", "base", "be", "res", "var", "av", "str", "tr", "bus", "ctr", "block", "Br", "buf", "pl", "bc", "config", "pr", "wr", "boot", "bh", "ler", "bolt", "bs", "BR", "bal", "r", "fr", "global", "tag", "adr", "dr", "bar", "p", "bridge", "arr", "loc", "rb", "rel", "brid", "obj", "n", "bas", "bf", "ber"], "sec_bus": ["sec_boot", "security_driver", "sec_bridge", "sec_port", "cy_boot", "esc_us", " sec_def", "esc_bus", "securebridge", "secure_boot", "cy_bus", "sec_mount", "secjbus", "sec_BUS", "Sec_bridge", " sec_boot", "sec_service", "Sec_def", "security_bridge", "secure_bridge", "secpBUS", "secpcar", " sec_us", "secjdef", "security_bus", " sec_mount", "secpbus", "Sec_driver", "Sec_bus", "esc_boot", "secure_bus", "sec_usb", "secJdriver", " sec_block", "esc_usb", "Sec_car", "sec_car", "security_machine", "secpbridge", "securedriver", "cy_service", "securemachine", "cy_usb", "Sec_BUS", "Sec_port", "sec_def", "secure_BUS", " sec_usb", "secJbus", "Sec_dev", "secjport", "securebus", "secjBUS", "secJdev", "sec_machine", "secJBUS", "sec_us", "sec_block", "sec_dev", "sec_driver"]}}
{"project": "qemu", "commit_id": "bc210eb163b162ff2e94e5c8f4307715731257f8", "target": 0, "func": "void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,\n\n                              int width, int y)\n\n{\n\n    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,\n\n                           0, y, 0, 0, 0, 0, width, 1);\n\n}\n", "idx": 9639, "substitutes": {"linebuf": [" linebuffer", "linvec", "linkbc", "linequeue", "linkbuffer", "linbc", "linevec", "linkbuf", "linbuffer", " linebc", "linebuffer", "linuf", " lineuf", "lineuf", "lockvec", "lockbuffer", "linkuf", "linqueue", "linebc", "lockbuf", "linkqueue", "linkvec", "linbuf", "lockqueue"], "fb": ["facebook", "abc", "f", "src", "buf", "fi", "pb", "fe", "eb", "lb", "fab", "sb", "cb", "abl", "rf", "b", "bg", "img", "rb", "fa", "fc", "fp", "tmp", "bb", "xb", "cf", "fx", "border", "buff", "ab", "fw", "ob", "fg", "eddy", "FB", "fd", "bf"], "y": ["ii", "padding", "yy", "f", "type", "ny", "ys", "ya", "c", "yi", "i", "xy", "d", "p", "dy", "b", "gy", "cy", "vy", "px", "io", "z", "sy", "t", "area", "l", "start", "height", "m", "w", "col", "yt", "e", "n", "Y", "py", " Y", "kit", "x"]}}
{"project": "qemu", "commit_id": "30b8b68eb574fd68060eebcc4da790fdfe18d668", "target": 0, "func": "static inline abi_long target_to_host_cmsg(struct msghdr *msgh,\n\n                                           struct target_msghdr *target_msgh)\n\n{\n\n    struct cmsghdr *cmsg = CMSG_FIRSTHDR(msgh);\n\n    abi_long msg_controllen;\n\n    abi_ulong target_cmsg_addr;\n\n    struct target_cmsghdr *target_cmsg;\n\n    socklen_t space = 0;\n\n    \n\n    msg_controllen = tswapal(target_msgh->msg_controllen);\n\n    if (msg_controllen < sizeof (struct target_cmsghdr)) \n\n        goto the_end;\n\n    target_cmsg_addr = tswapal(target_msgh->msg_control);\n\n    target_cmsg = lock_user(VERIFY_READ, target_cmsg_addr, msg_controllen, 1);\n\n    if (!target_cmsg)\n\n        return -TARGET_EFAULT;\n\n\n\n    while (cmsg && target_cmsg) {\n\n        void *data = CMSG_DATA(cmsg);\n\n        void *target_data = TARGET_CMSG_DATA(target_cmsg);\n\n\n\n        int len = tswapal(target_cmsg->cmsg_len)\n\n                  - TARGET_CMSG_ALIGN(sizeof (struct target_cmsghdr));\n\n\n\n        space += CMSG_SPACE(len);\n\n        if (space > msgh->msg_controllen) {\n\n            space -= CMSG_SPACE(len);\n\n            gemu_log(\"Host cmsg overflow\\n\");\n\n            break;\n\n        }\n\n\n\n        if (tswap32(target_cmsg->cmsg_level) == TARGET_SOL_SOCKET) {\n\n            cmsg->cmsg_level = SOL_SOCKET;\n\n        } else {\n\n            cmsg->cmsg_level = tswap32(target_cmsg->cmsg_level);\n\n        }\n\n        cmsg->cmsg_type = tswap32(target_cmsg->cmsg_type);\n\n        cmsg->cmsg_len = CMSG_LEN(len);\n\n\n\n        if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) {\n\n            gemu_log(\"Unsupported ancillary data: %d/%d\\n\", cmsg->cmsg_level, cmsg->cmsg_type);\n\n            memcpy(data, target_data, len);\n\n        } else {\n\n            int *fd = (int *)data;\n\n            int *target_fd = (int *)target_data;\n\n            int i, numfds = len / sizeof(int);\n\n\n\n            for (i = 0; i < numfds; i++)\n\n                fd[i] = tswap32(target_fd[i]);\n\n        }\n\n\n\n        cmsg = CMSG_NXTHDR(msgh, cmsg);\n\n        target_cmsg = TARGET_CMSG_NXTHDR(target_msgh, target_cmsg);\n\n    }\n\n    unlock_user(target_cmsg, target_cmsg_addr, 0);\n\n the_end:\n\n    msgh->msg_controllen = space;\n\n    return 0;\n\n}\n", "idx": 9643, "substitutes": {"msgh": ["mswh", "cmsgy", "MSwh", "msGH", "tsgh", "mesgor", "mesche", "mosgh", "MSgh", "MSGH", "masgg", "cmsche", " msky", "tsky", "msche", "msgy", "msgg", "mesgh", "mesht", "tswh", "cmsgh", "mosgg", "msgor", "vsgy", "vsgh", "masgor", "msht", "vsgg", "mesgg", " mswh", "mesgy", "msky", "MSky", "vsche", "tsGH", " msGH", "cmsgg", "mosht", "masgh", "mosgor", "masht"], "target_msgh": ["target_qsyg", "target_mesgg", "target_kesgg", "target_msoug", "target_mszh", "target_msgg", "target_szh", "target_sht", "target_lsgg", "target_mesgs", "target_lsht", "target_mesoug", "target_qsgh", "target_kesoug", "target_mrzh", "target_mesht", "target_kesgh", "target_sgg", "target_lsgh", "target_qsgg", "target_meszh", "target_msyg", "target_kesyg", "target_mesgh", "target_sgs", "target_mrht", "target_mesyg", "target_qsoug", "target_msht", "target_mrgg", "target_sgh", "target_msgs", "target_lsgs", "target_mrgh"], "cmsg": ["fcmn", "acset", "rcmn", "fdoc", "farg", " ccmd", "ncmap", "ucmodule", "rmessage", "qdoc", "rmap", "fcmessage", " cdoc", "acmsg", "cwd", "ucmessage", "acdoc", "ncarg", "pccmd", " cmn", "ucdoc", "xcmessage", "bcmsg", "rcmsg", "vcdoc", "rdoc", "vcmsg", "vcmn", "bccmd", "fcmap", "uccmd", "acmessage", "cmap", "cload", "ucload", "fmessage", "cget", "ncmessage", "bcmessage", " cwd", "cmodule", "Cmodule", "vcmessage", "arcmessage", "Cdoc", "fmsg", "bcarg", "ucmsg", "accmd", "dgen", "rmsg", "Cget", "ncdoc", "xcwd", "cmn", "conmsg", "conmn", "rcdoc", "bcget", "qcmd", "cdoc", "conwd", "pcmsg", "xcmsg", " cmessage", "bcmodule", "pcmessage", "arcmsg", "acmn", "rcmessage", "ncmsg", "coset", "xcmn", "carg", "comsg", "bcdoc", "fcdoc", "arcdoc", "comessage", "dmessage", "arcmn", "bcload", "fcmsg", "cset", " cset", "fccmd", "ucget", "cgen", "ccmd", " cgen", "pcload", "qmessage", "conmessage", "Cmsg", "codoc", "dcmd", "acgen", "cmessage", "dmsg", "qmsg"], "msg_controllen": ["msg_controlleden", "msg_restrollinger", "msg_controllingon", "msg_contcoller", "msg_contcolle", "msg_contentallen", "msg_controlleder", "msg_restrollens", "msg_contentrolllen", "msg_restrollingens", "msg_controlen", "msg_controlledlen", "msg_controllening", "msg_constrollen", "msg_contcollen", "msg_constrollener", "msg_constrolen", "msg_contentcoller", "msg_controllener", "msg_controllede", "msg_controler", "msg_restrollon", "msg_controlledon", "msg_controllingen", "msg_constrolener", "msg_contcolllen", "msg_contcollener", "msg_contallens", "msg_contentcolllen", "msg_controller", "msg_controlledening", "msg_controllinglen", "msg_controllon", "msg_controllens", "msg_contillening", "msg_contillen", "msg_contracten", "msg_contcollens", "msg_constroler", "msg_contentcollen", "msg_contentrollon", "msg_contentallon", "msg_contillener", "msg_controlledener", "msg_contentallener", "msg_controlens", "msg_contentrollens", "msg_contentrollener", "msg_contracter", "msg_controlening", "msg_constroller", "msg_controlledens", "msg_controlle", "msg_restroller", "msg_controlon", "msg_controllingener", "msg_constrolening", "msg_restrollingon", "msg_constrollening", "msg_contracton", "msg_contallon", "msg_restrollen", "msg_controlllen", "msg_controllinge", "msg_contiller", "msg_restrollingen", "msg_contentallens", "msg_contallener", "msg_controllinger", "msg_contentrollen", "msg_contentrolle", "msg_controlener", "msg_controllingens", "msg_contentroller", "msg_controle", "msg_contentcolle", "msg_contcollon", "msg_contractens", "msg_contallen"], "target_cmsg_addr": ["target_cmessage_adr", "target_cmsg__addr", "target_cmsg__nr", "target_cmessage_addr", "target_cmessage_nr", "target_cmsg_nr", "target_cmsg_ord", "target_cmsg_host", "target_cmessage_ord", "target_cmsg_address", "target_cmessage_address", "target_cmessage_pos", "target_cmessage_host", "target_cmsg_adr", "target_cmsg__adr", "target_cmsg__address", "target_cmsg_pos"], "target_cmsg": ["target_cg", "target_acmessage", "target_lcmsg", "target_bdef", "target_pcmsg", "target_pcmg", "target_bog", "target_cfsend", "target_rcmsg", "target_verg", "target_vmsg", "target_pcframe", "target_rcdr", "target_cmn", "target_iccmd", "target_cfipher", "target_cdoc", "target_mmsg", "target_acog", "target_rccmd", "target_mml", "target_cudr", "target_cdef", "target_bipher", "target_rcmessage", "target_icmsg", "target_csdef", "target_cfdef", "target_icmg", "target_rcgen", "target_rcmg", "target_cumsg", "target_cmessage", "target_fdr", "target_bdoc", "target_lcdoc", "target_cmg", "target_mgen", "target_bmsg", "target_acmsg", "target_icmessage", "target_lcmg", "target_pcmp", "target_acdoc", "target_acg", "target_ccmsg", "target_ucog", "target_acmn", "target_ccmd", "target_csend", "target_ucdr", "target_cog", "target_acmp", "target_cglobal", "target_cframe", "target_cml", "target_lcog", "target_cuglobal", "target_csmsg", "target_ccmn", "target_lcglobal", "target_lcg", "target_bmg", "target_cgen", "target_merg", "target_lcmessage", "target_yml", "target_fmessage", "target_cumg", "target_lcmp", "target_cfframe", "target_pcgen", "target_vgen", "target_rcframe", "target_ucmsg", "target_ygen", "target_cdr", "target_ymsg", "target_cerg", "target_fmsg", "target_cipher", "target_cfmp", "target_lcdr", "target_lcmn", "target_cmp", "target_pcg", "target_cssend", "target_vml", "target_acmg", "target_csipher", "target_cfgen", "target_rcmp", "target_lccmd", "target_bsend", "target_rcglobal", "target_cfmsg", "target_pcmessage", "target_ccmp", "target_yerg", "target_ucmessage", "target_fog"], "data": ["dat", "message", "text", "size", "Data", "result", "media", "DATA", "response", "session", "doc", "part", "key", "di", "parent", "entry", "reader", "channel", "source", "resource", "next", "body", "pad", "base", "meta", "space", "batch", "window"], "target_data": ["target__conn", "target__data", " target_addr", "target_conn", "target__addr", "target_addr", " target_conn"]}}
{"project": "qemu", "commit_id": "9d6f1b73f83a02fb28438fa9a487f5c7d245e4af", "target": 0, "func": "static bool ga_open_pidfile(const char *pidfile)\n\n{\n\n    int pidfd;\n\n    char pidstr[32];\n\n\n\n    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);\n\n    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {\n\n        g_critical(\"Cannot lock pid file, %s\", strerror(errno));\n\n        if (pidfd != -1) {\n\n            close(pidfd);\n\n        }\n\n        return false;\n\n    }\n\n\n\n    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {\n\n        g_critical(\"Failed to truncate pid file\");\n\n        goto fail;\n\n    }\n\n    sprintf(pidstr, \"%d\", getpid());\n\n    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {\n\n        g_critical(\"Failed to write pid file\");\n\n        goto fail;\n\n    }\n\n\n\n    return true;\n\n\n\nfail:\n\n    unlink(pidfile);\n\n    return false;\n\n}\n", "idx": 9647, "substitutes": {"pidfile": ["pinfile", "pidfp", "pf", "payfiles", "pingfp", "pidf", "pinfd", "pingstr", "pindir", "payf", "podfd", "cpfile", "payfd", "pingfd", "pinfiles", "pinf", "podfile", "pidfiles", "cpFile", "podfp", "payfile", "pcfp", "pinFile", "pcfd", "pcfile", "cpdir", "pingfile", "pcstr", "podstr", "pfiles", "cpf", "pidFile", "pFile", "pdir", "pfile", "pfd", "piddir"], "pidfd": ["pluginfp", "pidfn", "fdfx", "podcond", "podfd", "pcd", "pidstream", "mpFD", "pcfi", "pitfd", "fddc", "poddir", "podfp", "pidflo", "codfp", "idfin", "pcf", "panfi", "pingfx", "podFD", "podfx", "piddf", "pingf", " pidfp", "idfd", "pinfn", "pingdc", "pluginfd", "pidf", "pidfin", "pinfd", "cpfx", "pindf", "pingfd", "pingflo", "podf", "cpFD", "pinFD", "piddc", "pitfp", "podhandler", "cpfd", "codfd", "pand", "pcond", "pinfp", "fdfn", "pfd", "pidfp", "pinfi", "pingfc", "idflo", "codFD", "pitfx", "pitFD", "pFD", "idf", "mpfp", "fdfc", "pinf", "pidfx", "mpf", " pidFD", "panf", "podfn", "pidhandler", "iddc", "fdfd", "pinstream", "pingfin", "idfc", "mpfd", "plugindf", "pcstream", "pind", "pidfi", "pidd", "pidfc", "podstream", "piddir", "pinfile", "pf", "phandler", "coddf", "pluginFD", "pinflo", "pidcond", "pindir", "pidFD", "fdfile", "pinfin", "podfile", "pincond", "pcfd", "cpfp", "fdFD", " pidf", "pcdir", "pfp", "panfd", "idfx", "pinhandler", "pfile"], "pidstr": ["pstr", "pinfile", "prdr", "pingdr", "pidst", " piddata", "pidletter", " pidst", " pidStr", "pingst", "pitstr", "pinstring", "prstr", "pingbr", "pingstr", "pinletter", "piddr", "pidstring", "pitbr", " pidstri", "pidStr", "pinstr", "pitstring", "pingStr", "pidbr", "pitbytes", "pstri", "pidbytes", "pindata", "pStr", "iddata", "pinst", "pingbytes", " pidbr", "idbr", "pinbytes", "pingfile", "idstr", "pindr", "prfile", "pingstring", "pingletter", "idstring", " pidstring", "pingstri", "piddata", " pidletter", "pinbr", "pidstri", "prstring"]}}
{"project": "qemu", "commit_id": "3d3efba020da1de57a715e2087cf761ed0ad0904", "target": 1, "func": "static void handle_pending_signal(CPUArchState *cpu_env, int sig)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(cpu_env);\n\n    abi_ulong handler;\n\n    sigset_t set, old_set;\n\n    target_sigset_t target_old_set;\n\n    struct target_sigaction *sa;\n\n    struct sigqueue *q;\n\n    TaskState *ts = cpu->opaque;\n\n    struct emulated_sigtable *k = &ts->sigtab[sig - 1];\n\n\n\n    trace_user_handle_signal(cpu_env, sig);\n\n    /* dequeue signal */\n\n    q = k->first;\n\n    k->first = q->next;\n\n    if (!k->first)\n\n        k->pending = 0;\n\n\n\n    sig = gdb_handlesig(cpu, sig);\n\n    if (!sig) {\n\n        sa = NULL;\n\n        handler = TARGET_SIG_IGN;\n\n    } else {\n\n        sa = &sigact_table[sig - 1];\n\n        handler = sa->_sa_handler;\n\n    }\n\n\n\n    if (ts->sigsegv_blocked && sig == TARGET_SIGSEGV) {\n\n        /* Guest has blocked SIGSEGV but we got one anyway. Assume this\n\n         * is a forced SIGSEGV (ie one the kernel handles via force_sig_info\n\n         * because it got a real MMU fault), and treat as if default handler.\n\n         */\n\n        handler = TARGET_SIG_DFL;\n\n    }\n\n\n\n    if (handler == TARGET_SIG_DFL) {\n\n        /* default handler : ignore some signal. The other are job control or fatal */\n\n        if (sig == TARGET_SIGTSTP || sig == TARGET_SIGTTIN || sig == TARGET_SIGTTOU) {\n\n            kill(getpid(),SIGSTOP);\n\n        } else if (sig != TARGET_SIGCHLD &&\n\n                   sig != TARGET_SIGURG &&\n\n                   sig != TARGET_SIGWINCH &&\n\n                   sig != TARGET_SIGCONT) {\n\n            force_sig(sig);\n\n        }\n\n    } else if (handler == TARGET_SIG_IGN) {\n\n        /* ignore sig */\n\n    } else if (handler == TARGET_SIG_ERR) {\n\n        force_sig(sig);\n\n    } else {\n\n        /* compute the blocked signals during the handler execution */\n\n        target_to_host_sigset(&set, &sa->sa_mask);\n\n        /* SA_NODEFER indicates that the current signal should not be\n\n           blocked during the handler */\n\n        if (!(sa->sa_flags & TARGET_SA_NODEFER))\n\n            sigaddset(&set, target_to_host_signal(sig));\n\n\n\n        /* block signals in the handler using Linux */\n\n        do_sigprocmask(SIG_BLOCK, &set, &old_set);\n\n        /* save the previous blocked signal state to restore it at the\n\n           end of the signal execution (see do_sigreturn) */\n\n        host_to_target_sigset_internal(&target_old_set, &old_set);\n\n\n\n        /* if the CPU is in VM86 mode, we restore the 32 bit values */\n\n#if defined(TARGET_I386) && !defined(TARGET_X86_64)\n\n        {\n\n            CPUX86State *env = cpu_env;\n\n            if (env->eflags & VM_MASK)\n\n                save_v86_state(env);\n\n        }\n\n#endif\n\n        /* prepare the stack frame of the virtual CPU */\n\n#if defined(TARGET_ABI_MIPSN32) || defined(TARGET_ABI_MIPSN64) \\\n\n    || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX)\n\n        /* These targets do not have traditional signals.  */\n\n        setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env);\n\n#else\n\n        if (sa->sa_flags & TARGET_SA_SIGINFO)\n\n            setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env);\n\n        else\n\n            setup_frame(sig, sa, &target_old_set, cpu_env);\n\n#endif\n\n        if (sa->sa_flags & TARGET_SA_RESETHAND) {\n\n            sa->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n    }\n\n    if (q != &k->info)\n\n        free_sigqueue(cpu_env, q);\n\n}\n", "idx": 9650, "substitutes": {"cpu_env": ["cpu6en", "cpu_dir", "gpu_eni", "cpu_state", "cpu_eye", "cpu_environment", "proc__state", "cpu_en", "cpu__en", "pu_env", "proc_state", "gpu_dir", "cpu__state", "cpu6eye", "cpu__env", "proc_env", "cpu6environment", "pu_environment", "proc__en", "proc_en", "gpu_environment", "proc__env", "cpu_eni", "pu_en", "cpu6env", "pu_eye", "gpu_env"], "sig": ["asigma", "essiger", "piger", "pature", "wsIG", "symigma", "wigma", "tIG", "digma", "Sigs", "lig", "nsIG", "figer", "gature", " sian", "fig", "srig", "Sib", "sigi", "wiger", "tigs", "giger", "osIG", "asib", "asIG", "tig", "pigma", " sature", " sigi", " sib", "wsigma", "wig", "ssig", "physag", " swig", "ligma", "asiger", "essature", "swig", "symigs", "ssige", "dIG", "dib", "gig", "symige", "sIG", "figma", "wsian", "sigma", " sigs", "tigma", "Siger", " sag", "sian", "osiger", "wsiger", "wigs", "gIG", "psig", "psIG", "psib", "psigma", "pig", "sag", "asig", "SIG", "Sig", "sige", "fwig", "tiger", "psiger", "essig", "asature", "physige", " sige", "physature", "nsig", "Sag", " sIG", "tigi", "dig", "Sigi", "Sigma", "osig", "liger", "ssigma", "tag", " siger", "argsig", "sib", "ssIG", "ssib", "sature", "nsiger", "wsig", "gigma", " srig", "argsag", "argsige", "osature", " sigma", "siger", "symig", "physig", "argsature", "Srig", "sigs", "essIG", "diger", "nsigs", "lature", "ssigs"], "cpu": ["linux", "fork", "tp", "hw", "ctx", "device", "nic", "cs", "nc", "fi", "proc", "c", "pc", "uca", "jp", "pu", "node", "config", "cat", "p", "CPU", "clock", "chip", "px", "cm", "cp", "queue", "cu", "pt", "core", "cfg", "cli", "css", "vm", "client", "t", "que", "gp", "mac", "gpu", "conn", "ci", "cr", "sys", "cn", "process", "mc", "lc", "uc", "gc", "pty", "processor", "pid", "cache"], "handler": ["server", "message", "ctx", "service", "err", "host", "connection", "byte", "master", "guard", "response", "slot", "nil", "definition", "worker", "driver", "channel", "time", "child", "slave", "location", "lambda", "pointer", "api", "ignore", "player", "parser", "library", "application", "off", "ha", "stage", "end", "hi", "code", "handled", "parent", "widget", "error", "Handler", "manager", "processor", "exec", "cher", "action", "ph", "man", "format", "callback", "sche", "handle", "route", "event", "password", "catch", "ssh", "command", "lib", "name", "writer", "parse", "no", "type", "match", "hand", "controller", "al", "new", "function", "loop", "magic", "client", "reader", "wrapper", "func", "data", "slice"], "set": ["Set", "server", "shift", "mut", "et", "parse", "dat", "setup", "cast", "match", "update", "cut", "sign", "write", "ex", "new", "mod", "reset", "create", "SET", "change", "ha", "nil", "session", "connect", "net", "use", "settings", "end", "open", "run", "add", "nat", "client", "push", "export", "get", "sort", "store", "sc", "start", "sync", "clear", "save", "base", "init", "sets", "util", "send", "check"], "old_set": ["old_sync", "old_reset", " old_reset", " old_sc", " old_sync", "old_sc"], "target_old_set": ["target_new_sync", "target_old_lock", "target_new_set", "target_new_lock", "target_old_sync"], "sa": ["la", "action", "ga", "pse", "sd", "sam", "va", "sm", "api", "sche", "na", "za", "ma", "ka", "osa", "pc", "ca", "a", "au", "aa", "sb", "si", "sp", "sg", "sta", "sh", "sie", "SA", "asa", "se", "sl", "asu", "sha", "ia", "ama", "da", "sc", "Sa", "as", "ta", "sn", "wa", "pa", "asi", "security", "su", "ai", "storage", "sk", "so", "s", "sea", "ba"], "q": ["g", "pg", "ctx", "iq", "f", "state", "self", "sq", "c", "qt", "d", "h", "p", "qa", "queue", "dq", "context", "Q", "z", "v", "ch", "client", "qi", "t", "cl", "que", "r", "qs", "req", "l", "u", "conn", "w", "m", "conf", "query", "qu", "n", "qq", "sk", "s"], "ts": ["ics", "tr", "tp", "tf", "tu", "ats", "tz", "tl", "cs", "ls", "ss", "states", "td", "pc", "ks", "Ts", "temp", "uts", "tm", "tk", "ds", "fs", "acs", "test", "pt", "bs", "ns", "us", "t", "ps", "qs", "gs", "te", "ta", "tx", "TS", "tt", "tc", "sys", "rs", "s", "cons", "stats", "ops"], "k": ["ok", "g", "fork", "f", "kick", "ky", "cs", "ke", "self", "K", "ka", "y", "c", "ak", "ks", "unk", "d", "uk", "p", "tk", "ck", "b", "kk", "work", "j", "kw", "ku", "dk", "ko", "mk", "v", "z", "ch", "kin", "t", "o", "ik", "kr", "u", "n", "sk", "s"]}}
{"project": "qemu", "commit_id": "d659d94013390238961fac741572306c95496bf5", "target": 1, "func": "static void pcie_pci_bridge_write_config(PCIDevice *d,\n\n        uint32_t address, uint32_t val, int len)\n\n{\n\n    pci_bridge_write_config(d, address, val, len);\n\n    msi_write_config(d, address, val, len);\n\n    shpc_cap_write_config(d, address, val, len);\n\n}\n", "idx": 9651, "substitutes": {"d": ["dat", "g", "sd", "f", "id", "did", "D", "xd", "dom", "md", "c", "db", "gd", "a", "i", "p", "dos", "ds", "b", "done", "ct", "nd", "ld", "grad", "bd", "v", "dc", "dd", "ind", "t", "r", "da", "ded", "od", "dx", "m", "dh", "e", "fd", "dl", "ad", "dt", "cd", "x", "dad"], "address": ["message", "uri", "size", "pointer", "id", "attribute", "device", "date", "ip", "host", "addr", "c", "adder", "en", "event", "node", "config", "ace", "offset", "order", "ord", "b", "shape", "interface", "pair", "end", "enter", "est", "add", "image", "entry", "ind", "length", "r", "channel", "start", "index", "m", "e", "base", "value", "Address", "name", "grade", "element", "ad", "target", "object", "enable"], "val": ["pos", "vol", "valid", "li", "vals", "ref", "addr", "sel", "byte", "seq", "db", "al", "eval", "bl", "slot", "arr", "b", "Val", "fl", "ld", "grad", "end", "VAL", "sl", "part", "v", "ee", "el", "length", "rel", "item", "lib", "index", "base", "aval", "value", "var", "alt", "element", "count", "x", "line"], "len": ["pos", "ann", "li", "valid", "fn", "fen", "size", "type", "f", "id", "err", "ls", "rev", " length", "seq", "en", "enc", "str", "Len", "fun", "lit", "fl", "le", "ld", "end", "part", "z", "num", "lin", "length", "el", "bin", "ind", "l", "lib", "base", "n", "lon", "ln", "lan", "lc", "cap", "name", "fin", "data", "count", "lf", "line"]}}
{"project": "qemu", "commit_id": "62be4e3a5041e84304aa23637da623a205c53ecc", "target": 0, "func": "static ram_addr_t find_ram_offset(ram_addr_t size)\n\n{\n\n    RAMBlock *block, *next_block;\n\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n\n\n\n    assert(size != 0); /* it would hand out same offset multiple times */\n\n\n\n    if (QTAILQ_EMPTY(&ram_list.blocks))\n\n        return 0;\n\n\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        ram_addr_t end, next = RAM_ADDR_MAX;\n\n\n\n        end = block->offset + block->length;\n\n\n\n        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {\n\n            if (next_block->offset >= end) {\n\n                next = MIN(next, next_block->offset);\n\n            }\n\n        }\n\n        if (next - end >= size && next - end < mingap) {\n\n            offset = end;\n\n            mingap = next - end;\n\n        }\n\n    }\n\n\n\n    if (offset == RAM_ADDR_MAX) {\n\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n\n                (uint64_t)size);\n\n        abort();\n\n    }\n\n\n\n    return offset;\n\n}\n", "idx": 9670, "substitutes": {"size": ["shift", "pos", "sized", "SIZE", "timeout", "capacity", "empty", "args", "limit", "max", "ip", "skip", "len", "small", "new", "bytes", "p", "offset", "after", "adjust", "fee", "si", "loc", "content", "shape", "position", "se", "scale", "array", "ize", "address", "code", "Size", "from", "length", "alloc", "start", "next", "sync", "sum", "body", "last", "base", "e", "set", "section", "six", "large", "sec", "send", "data", "count", "cache"], "block": ["container", "before", "plugin", "chain", "type", "flow", "ref", "ip", "prev", "Block", "byte", "box", "network", "label", "off", "node", "bl", "pack", "new", "slice", "clock", "loc", "blocks", "range", "work", "frame", "pre", "address", "image", "row", "down", "layer", "channel", "link", "error", "initial", "point", "start", "sync", "next", "buffer", "lock", "job", "unit", "section", "name", "batch", "page", "none", "group", "number", "object", "line"], "next_block": ["next__block", " next_lock", " next_line", "next__point", "next_layer", "next_box", " next_blocks", "next_page", "next_blocks", "next_group", " next_point", "next_lock", "front_unit", "front_box", " next_page", " next_row", "next__row", "next__page", "next_row", "front_block", "next_point", "next_line", "next_unit", " next_layer", "front_group"], "end": ["append", "id", "max", "limit", "update", "edge", "prev", "ff", "ended", "mid", "pend", "len", "eff", "close", "en", "an", "off", "event", "new", "enable", "enc", "offset", "after", "END", "ed", "ent", "End", "until", "range", "inner", "use", "nd", "ext", "ending", "open", "enter", "est", "begin", "ize", "address", "se", " next", "z", "add", "day", "length", "start", "next", "index", "last", "post", "each", "e", "set", "ad", "send", "stop", "line"]}}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n    qemu_mutex_init(&chr->chr_write_lock);\n\n    return chr;\n\n}\n", "idx": 9683, "substitutes": {"chr": ["phri", " chre", "CHlr", "echr", "chrc", " chri", "phrc", "echR", "ichrb", "echlr", "chrr", "ichre", " chrb", "ichr", "chlr", "chri", "phr", "CHrr", " chrar", "Chrar", " chlr", "ichri", "chrar", "ichrar", " chrc", "chre", "Chr", "Chrc", " chrr", "Chrb", "chR", "phre", "chrb", "ichrc", " chR", "echrr", "CHR", "CHr"]}}
{"project": "qemu", "commit_id": "fdaef06917100d97782df550c1807a1da054e27e", "target": 0, "func": "static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n\n{\n\n    SCSIRequest *req = &r->req;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    int buflen = 0;\n\n    int ret;\n\n\n\n    switch (req->cmd.buf[0]) {\n\n    case TEST_UNIT_READY:\n\n        if (!bdrv_is_inserted(s->bs))\n\n            goto not_ready;\n\n        break;\n\n    case REQUEST_SENSE:\n\n        if (req->cmd.xfer < 4)\n\n            goto illegal_request;\n\n        buflen = scsi_device_get_sense(&s->qdev, outbuf, req->cmd.xfer,\n\n                                       (req->cmd.buf[1] & 1) == 0);\n\n        break;\n\n    case INQUIRY:\n\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n\n        if (buflen < 0)\n\n            goto illegal_request;\n\n        break;\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n        buflen = scsi_disk_emulate_mode_sense(req, outbuf);\n\n        if (buflen < 0)\n\n            goto illegal_request;\n\n        break;\n\n    case READ_TOC:\n\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n\n        if (buflen < 0)\n\n            goto illegal_request;\n\n        break;\n\n    case RESERVE:\n\n        if (req->cmd.buf[1] & 1)\n\n            goto illegal_request;\n\n        break;\n\n    case RESERVE_10:\n\n        if (req->cmd.buf[1] & 3)\n\n            goto illegal_request;\n\n        break;\n\n    case RELEASE:\n\n        if (req->cmd.buf[1] & 1)\n\n            goto illegal_request;\n\n        break;\n\n    case RELEASE_10:\n\n        if (req->cmd.buf[1] & 3)\n\n            goto illegal_request;\n\n        break;\n\n    case START_STOP:\n\n        if (s->qdev.type == TYPE_ROM && (req->cmd.buf[4] & 2)) {\n\n            /* load/eject medium */\n\n            bdrv_eject(s->bs, !(req->cmd.buf[4] & 1));\n\n        }\n\n        break;\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n        bdrv_set_locked(s->bs, req->cmd.buf[4] & 1);\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        /* The normal LEN field for this command is zero.  */\n\n        memset(outbuf, 0, 8);\n\n        bdrv_get_geometry(s->bs, &nb_sectors);\n\n        if (!nb_sectors)\n\n            goto not_ready;\n\n        nb_sectors /= s->cluster_size;\n\n        /* Returned value is the address of the last sector.  */\n\n        nb_sectors--;\n\n        /* Remember the new size for read/write sanity checking. */\n\n        s->max_lba = nb_sectors;\n\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n\n        if (nb_sectors > UINT32_MAX)\n\n            nb_sectors = UINT32_MAX;\n\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n\n        outbuf[3] = nb_sectors & 0xff;\n\n        outbuf[4] = 0;\n\n        outbuf[5] = 0;\n\n        outbuf[6] = s->cluster_size * 2;\n\n        outbuf[7] = 0;\n\n        buflen = 8;\n\n        break;\n\n    case SYNCHRONIZE_CACHE:\n\n        ret = bdrv_flush(s->bs);\n\n        if (ret < 0) {\n\n            if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_FLUSH)) {\n\n                return -1;\n\n            }\n\n        }\n\n        break;\n\n    case GET_CONFIGURATION:\n\n        memset(outbuf, 0, 8);\n\n        /* ??? This should probably return much more information.  For now\n\n           just return the basic header indicating the CD-ROM profile.  */\n\n        outbuf[7] = 8; // CD-ROM\n\n        buflen = 8;\n\n        break;\n\n    case SERVICE_ACTION_IN:\n\n        /* Service Action In subcommands. */\n\n        if ((req->cmd.buf[1] & 31) == 0x10) {\n\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n\n            memset(outbuf, 0, req->cmd.xfer);\n\n            bdrv_get_geometry(s->bs, &nb_sectors);\n\n            if (!nb_sectors)\n\n                goto not_ready;\n\n            nb_sectors /= s->cluster_size;\n\n            /* Returned value is the address of the last sector.  */\n\n            nb_sectors--;\n\n            /* Remember the new size for read/write sanity checking. */\n\n            s->max_lba = nb_sectors;\n\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n\n            outbuf[7] = nb_sectors & 0xff;\n\n            outbuf[8] = 0;\n\n            outbuf[9] = 0;\n\n            outbuf[10] = s->cluster_size * 2;\n\n            outbuf[11] = 0;\n\n            outbuf[12] = 0;\n\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n\n\n            /* set TPE bit if the format supports discard */\n\n            if (s->qdev.conf.discard_granularity) {\n\n                outbuf[14] = 0x80;\n\n            }\n\n\n\n            /* Protection, exponent and lowest lba field left blank. */\n\n            buflen = req->cmd.xfer;\n\n            break;\n\n        }\n\n        DPRINTF(\"Unsupported Service Action In\\n\");\n\n        goto illegal_request;\n\n    case REPORT_LUNS:\n\n        if (req->cmd.xfer < 16)\n\n            goto illegal_request;\n\n        memset(outbuf, 0, 16);\n\n        outbuf[3] = 8;\n\n        buflen = 16;\n\n        break;\n\n    case VERIFY_10:\n\n        break;\n\n    default:\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n\n        return -1;\n\n    }\n\n    return buflen;\n\n\n\nnot_ready:\n\n    if (!bdrv_is_inserted(s->bs)) {\n\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n\n    } else {\n\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n    }\n\n    return -1;\n\n\n\nillegal_request:\n\n    scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n\n    return -1;\n\n}\n", "idx": 9706, "substitutes": {"r": ["fr", "request", "re", "hr", "rev", "ur", "rg", "c", "mr", "i", "sr", "d", "ru", "rc", "rss", "p", "rf", "b", "j", "R", "ar", "rb", "v", "q", "cr", "w", "m", "e", "n", "er", "rs", "rr", "rh", "res", "rar", "x"], "outbuf": ["Outbuffer", "Outcb", "OUTbuf", " outcb", "OUTuf", "newuf", "Outuf", "opbuffer", "opbuf", " outuf", "opuf", "inbuffer", " outbuffer", "OUTcb", "OUTbuff", "newcv", "outbuffer", "Outbuf", "outcv", "newbuf", " outcv", "OUTcv", "inbuff", "inbuf", "OUTbuffer", " outbuff", "Outbuff", "incb", "outuf", "opbuff", "inuf", "newbuffer", "outbuff", "outcb"], "req": ["rt", "ctx", "src", "ref", "err", "comp", "ra", "seq", "c", "ver", "d", "queue", "ch", "resource", "cmd", "q", "form", "rec", "w", "gr", "org", "desc", "query", "e", "rs", "pro", "serv", "sq", "sr", "ru", "h", "http", "rf", "sem", "j", "grad", "z", "get", "call", "conn", "wa", "er", "qq", "reg", "res", "sec", "exec", "str", "tr", "ctr", "required", "f", "resp", "low", "config", "ro", "cur", "pkg", "app", "load", "dq", "row", "ir", "crit", "rr", "rh", "pull", "requ", "g", "fr", "request", "state", "proc", "md", "qt", "tar", "p", "cb", "input", "require", "spec", "def", "dev", "conf", "this", "data", "cache"], "s": ["g", "os", "sym", "f", "service", "cs", "ls", "ss", "states", "serv", "uns", "y", "c", "sq", "sup", "is", "services", "d", "p", "ts", "sg", "http", "S", "session", "b", "ds", "fs", "ssl", "j", "sis", "ns", "v", "spec", "hs", "ray", "t", "ps", "ses", "q", "sync", "gs", "w", "conf", "sys", "su", "rs", "res", "sec", "js", "ops"], "nb_sectors": ["nb_pefs", "nb_gectors", "nb_pecs", "nb_gefs", "nb_sefs", "nb_vegments", "nb_vefs", "nb_vecs", "nb_gecs", "nb_segments", "nb_gegments", "nb_pectors", "nb_secs", "nb_pegments", "nb_vectors"], "ret": ["no", "rets", "match", "resp", "re", "RET", "result", "success", " resp", " success", " Ret", " RET", "rc", "back", "fun", "red", "mem", "val", "def", "reg", "res", "Num", "alt", "Ret"]}}
{"project": "qemu", "commit_id": "376692b9dc6f02303ee07a4146d08d8727d79c0c", "target": 0, "func": "static void flush_queued_work(CPUState *cpu)\n\n{\n\n    struct qemu_work_item *wi;\n\n\n\n    if (cpu->queued_work_first == NULL) {\n\n        return;\n\n    }\n\n\n\n    while ((wi = cpu->queued_work_first)) {\n\n        cpu->queued_work_first = wi->next;\n\n        wi->func(wi->data);\n\n        wi->done = true;\n\n        if (wi->free) {\n\n            g_free(wi);\n\n        }\n\n    }\n\n    cpu->queued_work_last = NULL;\n\n    qemu_cond_broadcast(&qemu_work_cond);\n\n}\n", "idx": 9707, "substitutes": {"cpu": ["colo", "np", "hw", "ocr", "fork", "loader", "ctx", "linux", "pai", "nic", "cow", "cs", "nc", "fi", "proc", "GPU", "bc", "c", "pc", "auc", "instance", "lb", "uca", "pu", "kernel", "prem", "winner", "CPU", "clock", "boot", "cp", "cu", "core", "cfg", "cli", "fc", "css", "vm", "roc", "bench", "gpu", "conn", "ci", "cf", "cus", "chu", "uci", "unit", "cn", "custom", "lu", "process", "lc", "eni", "gc", "processor", "consumer", "cache"], "wi": ["ii", "ni", "wal", "wan", "wiki", "mu", "mi", "fi", "wk", "ski", "chi", "wic", "wm", "yi", "ki", "wo", "ini", "i", "ei", "wine", "hei", "ani", "sci", "si", "fee", "worker", "Wi", "wit", "cu", "gi", "wl", "wei", "di", "ti", "hi", "xi", "bi", "ee", "qi", "ui", "gui", "wu", "wp", "ci", "w", "wa", "fw", "wife", "iw", "eni", "iri", "WI", "data", "wid"]}}
{"project": "qemu", "commit_id": "e568f9df086965813a318ff0558782ba90e59c33", "target": 0, "func": "static int validate_guest_space(unsigned long guest_base,\n\n                                unsigned long guest_size)\n\n{\n\n    unsigned long real_start, test_page_addr;\n\n\n\n    /* We need to check that we can force a fault on access to the\n\n     * commpage at 0xffff0fxx\n\n     */\n\n    test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask);\n\n\n\n    /* If the commpage lies within the already allocated guest space,\n\n     * then there is no way we can allocate it.\n\n     */\n\n    if (test_page_addr >= guest_base\n\n        && test_page_addr <= (guest_base + guest_size)) {\n\n        return -1;\n\n    }\n\n\n\n    /* Note it needs to be writeable to let us initialise it */\n\n    real_start = (unsigned long)\n\n                 mmap((void *)test_page_addr, qemu_host_page_size,\n\n                     PROT_READ | PROT_WRITE,\n\n                     MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\n\n    /* If we can't map it then try another address */\n\n    if (real_start == -1ul) {\n\n        return 0;\n\n    }\n\n\n\n    if (real_start != test_page_addr) {\n\n        /* OS didn't put the page where we asked - unmap and reject */\n\n        munmap((void *)real_start, qemu_host_page_size);\n\n        return 0;\n\n    }\n\n\n\n    /* Leave the page mapped\n\n     * Populate it (mmap should have left it all 0'd)\n\n     */\n\n\n\n    /* Kernel helper versions */\n\n    __put_user(5, (uint32_t *)g2h(0xffff0ffcul));\n\n\n\n    /* Now it's populated make it RO */\n\n    if (mprotect((void *)test_page_addr, qemu_host_page_size, PROT_READ)) {\n\n        perror(\"Protecting guest commpage\");\n\n        exit(-1);\n\n    }\n\n\n\n    return 1; /* All good */\n\n}\n", "idx": 9709, "substitutes": {"guest_base": ["guess_start", "guess_base", "guest_based", "guest67base", "guester_bare", "guest67size", "guester_bas", "guest67area", "guester_area", "guest_area", "guest67based", "guest_bas", "guester_size", "guess_area", "guess_based", "guester_base", "guess_size", "guest_start", "guest_bare"], "guest_size": ["guested_base", "guest64sec", "guested_size", "guested_address", "guest64address", "guested64address", "guest_offset", "guest64base", "guested64sec", "guester_size", "guester_offset", "guested64size", "guest_sec", "guested64base", "guest_address", "guester_base", "guest64size", "guested_sec"], "real_start": ["realpend", "realacsearch", "real64start", "realamstart", "real67shift", "real_offset", "realpstart", " real_search", "real_pad", "real_set", " real_cost", "complex_art", " real_pad", "re_start", "real_art", " real_stack", "real64end", "realacaddr", "realamend", "real_address", " real_end", "re_shift", "real67start", "real67end", "complex_end", "realacsize", "complex_offset", "real_stack", "real64cost", "realacstart", "realamset", "realpoffset", "real_shift", "real_cost", " real_size", " real_addr", "complex_start", "re_end", "real_search", "real64set", "real67address", "realpart", " real_set", "real_addr", "real_size", "real_end", "re_address", "realamcost"], "test_page_addr": ["test_pageacaddr", "test_page_size", "test_server_address", "test_page_ord", "test_page_dist", "test_page64addr", "test_page_ext", "test_page_address", "test_pagexext", "test_server_ext", "test_site_ad", "test_pagexaddress", "test_site_addr", "test_pageacaddress", "test_pagexaddr", "test_page_ad", "test_site_address", "test_page_adr", "test_page64offset", "test_page64address", "test_pageacsize", "test_server_size", "test_pagexsize", "test_server_addr", "test_page_offset", "test_site_offset", "test_page64size", "test_pageacord", "test_site_adr", "test_server_offset", "test_site_size", "test_site_dist", "test_site_ord"]}}
{"project": "qemu", "commit_id": "f5f601afcec6c1081128fe5a0f831788ca9f56ed", "target": 1, "func": "long do_sigreturn(CPUCRISState *env)\n\n{\n\n\tstruct target_signal_frame *frame;\n\n\tabi_ulong frame_addr;\n\n\ttarget_sigset_t target_set;\n\n\tsigset_t set;\n\n\tint i;\n\n\n\n\tframe_addr = env->regs[R_SP];\n\n\t/* Make sure the guest isn't playing games.  */\n\n\tif (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))\n\n\t\tgoto badframe;\n\n\n\n\t/* Restore blocked signals */\n\n\tif (__get_user(target_set.sig[0], &frame->sc.oldmask))\n\n\t\tgoto badframe;\n\n\tfor(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n\t\tif (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n\t\t\tgoto badframe;\n\n\t}\n\n\ttarget_to_host_sigset_internal(&set, &target_set);\n\n        do_sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n\trestore_sigcontext(&frame->sc, env);\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\treturn env->regs[10];\n\n  badframe:\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\tforce_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 9721, "substitutes": {"env": ["ne", "et", "np", "dict", "loader", "ctx", "site", "eng", "nc", "ea", "exc", "edge", "chal", "ce", "engine", "db", "en", "eu", "qt", "event", "config", "ev", "enc", "agent", "console", "ep", "iss", "Environment", "scope", "net", "equ", "context", "cfg", "core", "osc", "iv", "viron", "code", "v", "environment", "vm", "el", "que", "her", "conn", "dev", "stack", "conf", "e", "obj", " environment", "ec", "eni", "priv", "manager", "txt", "ef", "dir"], "frame": ["ne", "message", "fr", "up", "setup", "version", "parse", "f", "file", "block", "flow", "feat", "date", "state", "host", "fi", "ea", "flo", "ze", "connection", "module", "sequence", "game", "jp", "fe", "feature", "event", "node", "config", "iframe", "slice", "ace", "chip", "boot", "scope", "fb", "interface", "tick", " Frame", "cfg", "cpu", "position", "thread", "framework", "code", "image", "environment", "vert", "ind", "que", "fram", "def", "frames", "point", "cf", "component", "processor", "e", "base", "profile", "window", "scene", "face", "Frame", "role", "element", "target", "object", "line"], "frame_addr": ["frame_ptr", " frame_offset", "frame64oa", " frame_address", "frameIPaddress", "frame_offset", "frameIPoffset", "frame_oa", "frame_nz", "frame64addr", " frame_ord", " frame_ptr", " frame_slice", "frameIPnz", "frame_address", "frame64adr", "frame_ord", " frame_nz", "frame64address", "frame_adr", "sample_adr", "sample_addr", "sample_address", "frame_slice", "frameIPaddr", "sample_oa"], "target_set": ["user_spec", "target_sign", "useracspec", " target_store", "user_set", "user_export", "targetWsystem", "target_type", " target_system", "targetWexport", "targetFsystem", "targetFcut", "useracset", "targetacexport", "target_sc", "arget_type", " target_sc", "targetacsystem", " target_sign", "targetFset", "user_system", "useracsystem", "targetFsign", "targetacspec", "target_store", "arget_set", "targetWset", "useracexport", "target_cut", "targetWspec", "arget_sc", "target_spec", " target_cut", "target_system", "target_export", "targetacset"], "set": ["Set", "ne", "mut", "et", "parse", "setup", "cast", "match", "site", "update", "cut", "setting", "seq", "sign", "exec", "write", "en", "pack", "reset", "create", "SET", "change", "nil", "scope", "st", "net", "ct", "gen", "open", "se", "scale", "key", "code", "client", "ind", "get", "store", "call", "sc", "sync", "start", "clear", "init", "base", "section", "sa", "send", "target", "read"], "i": ["ii", "ni", "abi", "li", "uri", "code", "f", "id", "phi", "I", "diff", "k", "mu", "ip", "oi", "fi", "ski", "y", "c", "yi", "iu", "ini", "d", "multi", "h", "slice", "p", "ri", "si", "split", "b", "pi", "io", "j", "gi", "cli", "key", "di", "ti", "xi", "v", "in", "bi", "qi", "t", "ui", "zi", "o", "l", "ci", "u", "index", "start", "m", "e", "n", "ai", "lc", "s", "name", "page", "x", "ix"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_interrupt_packet(void *priv, uint32_t id,\n\n    struct usb_redir_interrupt_packet_header *interrupt_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = interrupt_packet->endpoint;\n\n\n\n    DPRINTF(\"interrupt-in status %d ep %02X len %d id %u\\n\",\n\n            interrupt_packet->status, ep, data_len, id);\n\n\n\n    if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) {\n\n        ERROR(\"received int packet for non interrupt endpoint %02X\\n\", ep);\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (ep & USB_DIR_IN) {\n\n        if (dev->endpoint[EP2I(ep)].interrupt_started == 0) {\n\n            DPRINTF(\"received int packet while not started ep %02X\\n\", ep);\n\n            free(data);\n\n            return;\n\n        }\n\n\n\n        /* bufp_alloc also adds the packet to the ep queue */\n\n        bufp_alloc(dev, data, data_len, interrupt_packet->status, ep);\n\n    } else {\n\n        int len = interrupt_packet->length;\n\n\n\n        AsyncURB *aurb = async_find(dev, id);\n\n        if (!aurb) {\n\n            return;\n\n        }\n\n\n\n        if (aurb->interrupt_packet.endpoint != interrupt_packet->endpoint) {\n\n            ERROR(\"return int packet mismatch, please report this!\\n\");\n\n            len = USB_RET_NAK;\n\n        }\n\n\n\n        if (aurb->packet) {\n\n            aurb->packet->len = usbredir_handle_status(dev,\n\n                                               interrupt_packet->status, len);\n\n            usb_packet_complete(&dev->dev, aurb->packet);\n\n        }\n\n        async_free(dev, aurb);\n\n    }\n\n}\n", "idx": 9722, "substitutes": {"priv": ["prop", "deb", "pub", "device", "pro", "ptr", "api", "eth", "pl", "proc", "raf", "private", "pb", "pc", "pack", "ev", "rc", "p", "temp", "pri", "pi", "cp", "prom", "Priv", "impl", "tmp", "attr", "conn", "tty", "pad", "info", "port", "sk", "pred", "pid"], "id": ["aid", "type", "path", "ptr", "ref", "ip", "ids", "Id", "mid", "kid", "is", "i", "d", "event", "rc", "p", "ep", "ident", "sid", "end", "ider", "oid", "address", "code", "in", "entry", "parent", "channel", "error", "ida", "start", "od", "pad", "ID", "uid", "e", "info", "init", "one", "fd", "name", "ad", "cd", "ide", "pid"], "interrupt_packet": ["interrupt_compet", "interrupt_exacket", "interrupt_viewets", "interrupt_sexeting", "interrupt_encET", "interrupt_processeting", "interrupt_requestetting", "interrupt_signET", "interrupt_paramail", "interrupt_paramET", "interrupt_paramception", "interrupt_packET", "interrupt_packacket", "interrupt_paramacket", "interrupt_viewET", "interrupt_parametting", "interrupt_packail", "interrupt_packetting", "interrupt_processacket", "interrupt_pacacket", "interrupt_pacets", "interrupt_packageets", "interrupt_promets", "interrupt_exet", "interrupt_packets", "interrupt_sexacket", "interrupt_exET", "interrupt_packeting", "interrupt_pacET", "interrupt_streameting", "interrupt_paramet", "interrupt_paramant", "interrupt_processet", "interrupt_signception", "interrupt_viewette", "interrupt_compacket", "interrupt_parameting", "interrupt_requestacket", "interrupt_promacket", "interrupt_packageacket", "interrupt_promET", "interrupt_paramette", "interrupt_sexception", "interrupt_paramets", "interrupt_packageet", "interrupt_compant", "interrupt_streamail", "interrupt_compets", "interrupt_viewet", "interrupt_packant", "interrupt_signacket", "interrupt_packette", "interrupt_packception", "interrupt_sexetting", "interrupt_requestET", "interrupt_processail", "interrupt_sexET", "interrupt_requestet", "interrupt_sexets", "interrupt_encets", "interrupt_packageET", "interrupt_signet", "interrupt_streamacket", "interrupt_exeting", "interrupt_encette", "interrupt_encet", "interrupt_sexant", "interrupt_streamet", "interrupt_promet", "interrupt_sexet", "interrupt_pacet"], "data": ["dat", "message", "valid", "up", "empty", "size", "type", "device", "Data", "api", "ada", "ip", "result", "len", "a", "d", "event", "DATA", "new", "pack", "bytes", "p", "str", "response", "input", "done", "feed", "missing", "memory", "address", "package", "record", "image", "entry", "parent", "reader", "complete", "da", "error", "def", "next", "rec", "buffer", "pad", "last", "delay", "info", "progress", "raw", "video", "window", "cache"], "data_len": ["data_limit", "data_Len", "datasln", "dataslen", "data_ln", "data64limit", "byteslen", "byte_Len", "bytesLen", "data_l", "data_pos", "bytesln", "dataslimit", "byte_len", "Data_Len", "data64len", "byte_limit", " data_length", "byte_ln", "data64ln", " data_Len", "Data_length", "Data_l", "data_length", " data_pos", "data64Len", "byteslimit", "Data_len", "datasLen"], "dev": ["debug", "dem", "prop", "de", "deb", "valid", "block", "pub", "die", "hw", "loader", "device", "pro", "diff", "comment", "ip", "self", "home", "proc", "dom", "serial", "rad", "engine", "DEV", "adv", "gu", "ver", "user", "private", "game", "d", "ev", "mod", "p", "h", "temp", "ep", "app", "Dev", "grad", "test", "end", "prom", "prof", "di", "v", "dc", "dd", "ch", "mem", "df", "error", "link", "req", "def", "conn", "w", "cam", "ow", "conf", "dm", "dep", "info", "reg", "sk", "var", "ad", "bug"], "aurb": ["aurab", "rarp", "rara", "rrb", "rumB", "urb", "vrib", "urk", "turk", "aurf", "aup", "igrb", "vrab", "rarb", "urB", "lrB", "rumab", "urf", "orgab", "eara", "rarab", "ergb", "lrb", "tura", "rrp", "aurob", "turb", "birdib", "urp", "rumf", "earp", "aubis", "orgib", "urab", "rra", "aua", "aurp", "urc", "ergc", "vrb", "ergr", "vrob", "rrB", "ergbis", "aurk", "lrab", "aurl", "igrab", "turp", "vra", "orgb", "urr", "aur", "aurbis", "ura", "rumb", "aul", "orgob", "igrib", "aurc", "aurB", "igrob", "lrf", "birdl", "vrk", "aurr", "aura", "earb", "auc", "urbis", "birdb", "aurib", "aub", "url", "vrp", "earB", "birdc", "auib", "urib", "auab"]}}
{"project": "FFmpeg", "commit_id": "461cd5bfb5c38e48a81b4a9a5912dfd65da1ba3d", "target": 0, "func": "void mpeg1_encode_mb(MpegEncContext *s,\n\n                     DCTELEM block[6][64],\n\n                     int motion_x, int motion_y)\n\n{\n\n    int i, cbp;\n\n    const int mb_x = s->mb_x;\n\n    const int mb_y = s->mb_y;\n\n    const int first_mb= mb_x == s->resync_mb_x && mb_y == s->resync_mb_y;\n\n\n\n    /* compute cbp */\n\n    cbp = 0;\n\n    for(i=0;i<6;i++) {\n\n        if (s->block_last_index[i] >= 0)\n\n            cbp |= 1 << (5 - i);\n\n    }\n\n    \n\n    if (cbp == 0 && !first_mb && (mb_x != s->mb_width - 1 || (mb_y != s->mb_height - 1 && s->codec_id == CODEC_ID_MPEG1VIDEO)) && \n\n        ((s->pict_type == P_TYPE && s->mv_type == MV_TYPE_16X16 && (motion_x | motion_y) == 0) ||\n\n        (s->pict_type == B_TYPE && s->mv_dir == s->last_mv_dir && (((s->mv_dir & MV_DIR_FORWARD) ? ((s->mv[0][0][0] - s->last_mv[0][0][0])|(s->mv[0][0][1] - s->last_mv[0][0][1])) : 0) |\n\n        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {\n\n        s->mb_skip_run++;\n\n        s->qscale -= s->dquant;\n\n        s->skip_count++;\n\n        s->misc_bits++;\n\n        s->last_bits++;\n\n        if(s->pict_type == P_TYPE){\n\n            s->last_mv[0][1][0]= s->last_mv[0][0][0]= \n\n            s->last_mv[0][1][1]= s->last_mv[0][0][1]= 0;\n\n        }\n\n    } else {\n\n        if(first_mb){\n\n            assert(s->mb_skip_run == 0);\n\n            encode_mb_skip_run(s, s->mb_x);\n\n        }else{\n\n            encode_mb_skip_run(s, s->mb_skip_run);\n\n        }\n\n        \n\n        if (s->pict_type == I_TYPE) {\n\n            if(s->dquant && cbp){\n\n                put_mb_modes(s, 2, 1, 0, 0); /* macroblock_type : macroblock_quant = 1 */\n\n                put_bits(&s->pb, 5, s->qscale);\n\n            }else{\n\n                put_mb_modes(s, 1, 1, 0, 0); /* macroblock_type : macroblock_quant = 0 */\n\n                s->qscale -= s->dquant;\n\n            }\n\n            s->misc_bits+= get_bits_diff(s);\n\n            s->i_count++;\n\n        } else if (s->mb_intra) {\n\n            if(s->dquant && cbp){\n\n                put_mb_modes(s, 6, 0x01, 0, 0);\n\n                put_bits(&s->pb, 5, s->qscale);\n\n            }else{\n\n                put_mb_modes(s, 5, 0x03, 0, 0);\n\n                s->qscale -= s->dquant;\n\n            }\n\n            s->misc_bits+= get_bits_diff(s);\n\n            s->i_count++;\n\n            memset(s->last_mv, 0, sizeof(s->last_mv));\n\n        } else if (s->pict_type == P_TYPE) { \n\n            if(s->mv_type == MV_TYPE_16X16){\n\n                if (cbp != 0) {\n\n                    if ((motion_x|motion_y) == 0) {\n\n                        if(s->dquant){\n\n                            put_mb_modes(s, 5, 1, 0, 0); /* macroblock_pattern & quant */\n\n                            put_bits(&s->pb, 5, s->qscale);\n\n                        }else{\n\n                            put_mb_modes(s, 2, 1, 0, 0); /* macroblock_pattern only */\n\n                        }\n\n                        s->misc_bits+= get_bits_diff(s);\n\n                    } else {\n\n                        if(s->dquant){\n\n                            put_mb_modes(s, 5, 2, 1, 0); /* motion + cbp */\n\n                            put_bits(&s->pb, 5, s->qscale);\n\n                        }else{\n\n                            put_mb_modes(s, 1, 1, 1, 0); /* motion + cbp */\n\n                        }\n\n                        s->misc_bits+= get_bits_diff(s);\n\n                        mpeg1_encode_motion(s, motion_x - s->last_mv[0][0][0], s->f_code);    // RAL: f_code parameter added\n\n                        mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code);    // RAL: f_code parameter added\n\n                        s->mv_bits+= get_bits_diff(s);\n\n                    }\n\n                } else {\n\n                    put_bits(&s->pb, 3, 1); /* motion only */\n\n                    if (!s->frame_pred_frame_dct)\n\n                        put_bits(&s->pb, 2, 2); /* motion_type: frame */\n\n                    s->misc_bits+= get_bits_diff(s);\n\n                    mpeg1_encode_motion(s, motion_x - s->last_mv[0][0][0], s->f_code);    // RAL: f_code parameter added\n\n                    mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code);    // RAL: f_code parameter added\n\n                    s->qscale -= s->dquant;\n\n                    s->mv_bits+= get_bits_diff(s);\n\n                }\n\n                s->last_mv[0][1][0]= s->last_mv[0][0][0]= motion_x;\n\n                s->last_mv[0][1][1]= s->last_mv[0][0][1]= motion_y;\n\n            }else{\n\n                assert(!s->frame_pred_frame_dct && s->mv_type == MV_TYPE_FIELD);\n\n\n\n                if (cbp) {\n\n                    if(s->dquant){\n\n                        put_mb_modes(s, 5, 2, 1, 1); /* motion + cbp */\n\n                        put_bits(&s->pb, 5, s->qscale);\n\n                    }else{\n\n                        put_mb_modes(s, 1, 1, 1, 1); /* motion + cbp */\n\n                    }\n\n                } else {\n\n                    put_bits(&s->pb, 3, 1); /* motion only */\n\n                    put_bits(&s->pb, 2, 1); /* motion_type: field */\n\n                    s->qscale -= s->dquant;\n\n                }\n\n                s->misc_bits+= get_bits_diff(s);\n\n                for(i=0; i<2; i++){\n\n                    put_bits(&s->pb, 1, s->field_select[0][i]);\n\n                    mpeg1_encode_motion(s, s->mv[0][i][0] -  s->last_mv[0][i][0]    , s->f_code);\n\n                    mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code);\n\n                    s->last_mv[0][i][0]=   s->mv[0][i][0];\n\n                    s->last_mv[0][i][1]= 2*s->mv[0][i][1];\n\n                }\n\n                s->mv_bits+= get_bits_diff(s);\n\n            }\n\n            if(cbp)\n\n                put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]);\n\n            s->f_count++;\n\n        } else{  \n\n            static const int mb_type_len[4]={0,3,4,2}; //bak,for,bi\n\n\n\n            if(s->mv_type == MV_TYPE_16X16){\n\n                if (cbp){    // With coded bloc pattern\n\n                    if (s->dquant) {\n\n                        if(s->mv_dir == MV_DIR_FORWARD)\n\n                            put_mb_modes(s, 6, 3, 1, 0);\n\n                        else\n\n                            put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 0);\n\n                        put_bits(&s->pb, 5, s->qscale);\n\n                    } else {\n\n                        put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 0);\n\n                    }\n\n                }else{    // No coded bloc pattern\n\n                    put_bits(&s->pb, mb_type_len[s->mv_dir], 2);\n\n                    if (!s->frame_pred_frame_dct)\n\n                        put_bits(&s->pb, 2, 2); /* motion_type: frame */\n\n                    s->qscale -= s->dquant;\n\n                }\n\n                s->misc_bits += get_bits_diff(s);\n\n                if (s->mv_dir&MV_DIR_FORWARD){\n\n                    mpeg1_encode_motion(s, s->mv[0][0][0] - s->last_mv[0][0][0], s->f_code); \n\n                    mpeg1_encode_motion(s, s->mv[0][0][1] - s->last_mv[0][0][1], s->f_code); \n\n                    s->last_mv[0][0][0]=s->last_mv[0][1][0]= s->mv[0][0][0];\n\n                    s->last_mv[0][0][1]=s->last_mv[0][1][1]= s->mv[0][0][1];\n\n                    s->f_count++;\n\n                }\n\n                if (s->mv_dir&MV_DIR_BACKWARD){\n\n                    mpeg1_encode_motion(s, s->mv[1][0][0] - s->last_mv[1][0][0], s->b_code); \n\n                    mpeg1_encode_motion(s, s->mv[1][0][1] - s->last_mv[1][0][1], s->b_code); \n\n                    s->last_mv[1][0][0]=s->last_mv[1][1][0]= s->mv[1][0][0];\n\n                    s->last_mv[1][0][1]=s->last_mv[1][1][1]= s->mv[1][0][1];\n\n                    s->b_count++;\n\n                }\n\n            }else{\n\n                assert(s->mv_type == MV_TYPE_FIELD);\n\n                assert(!s->frame_pred_frame_dct);\n\n                if (cbp){    // With coded bloc pattern\n\n                    if (s->dquant) {\n\n                        if(s->mv_dir == MV_DIR_FORWARD)\n\n                            put_mb_modes(s, 6, 3, 1, 1);\n\n                        else\n\n                            put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 1);\n\n                        put_bits(&s->pb, 5, s->qscale);\n\n                    } else {\n\n                        put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 1);\n\n                    }\n\n                }else{    // No coded bloc pattern\n\n                    put_bits(&s->pb, mb_type_len[s->mv_dir], 2);\n\n                    put_bits(&s->pb, 2, 1); /* motion_type: field */\n\n                    s->qscale -= s->dquant;\n\n                }\n\n                s->misc_bits += get_bits_diff(s);\n\n                if (s->mv_dir&MV_DIR_FORWARD){\n\n                    for(i=0; i<2; i++){\n\n                        put_bits(&s->pb, 1, s->field_select[0][i]);\n\n                        mpeg1_encode_motion(s, s->mv[0][i][0] -  s->last_mv[0][i][0]    , s->f_code);\n\n                        mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code);\n\n                        s->last_mv[0][i][0]=   s->mv[0][i][0];\n\n                        s->last_mv[0][i][1]= 2*s->mv[0][i][1];\n\n                    }\n\n                    s->f_count++;\n\n                }\n\n                if (s->mv_dir&MV_DIR_BACKWARD){\n\n                    for(i=0; i<2; i++){\n\n                        put_bits(&s->pb, 1, s->field_select[1][i]);\n\n                        mpeg1_encode_motion(s, s->mv[1][i][0] -  s->last_mv[1][i][0]    , s->b_code);\n\n                        mpeg1_encode_motion(s, s->mv[1][i][1] - (s->last_mv[1][i][1]>>1), s->b_code);\n\n                        s->last_mv[1][i][0]=   s->mv[1][i][0];\n\n                        s->last_mv[1][i][1]= 2*s->mv[1][i][1];\n\n                    }\n\n                    s->b_count++;\n\n                }\n\n            }\n\n            s->mv_bits += get_bits_diff(s);\n\n            if(cbp)\n\n                put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]);\n\n        }\n\n        for(i=0;i<6;i++) {\n\n            if (cbp & (1 << (5 - i))) {\n\n                mpeg1_encode_block(s, block[i], i);\n\n            }\n\n        }\n\n        s->mb_skip_run = 0;\n\n        if(s->mb_intra)\n\n            s->i_tex_bits+= get_bits_diff(s);\n\n        else\n\n            s->p_tex_bits+= get_bits_diff(s);\n\n    }\n\n}\n", "idx": 9727, "substitutes": {"s": ["sym", "service", "cs", "self", "c", "a", "ks", "d", "sv", "settings", "b", "css", "gs", "w", "series", "e", "comments", "rs", "js", "sum", "os", "bis", "site", "its", "ls", "ss", "sq", "ins", "sb", "http", "S", "ds", "session", "fs", "ssl", "ans", "ses", "qs", "f", "xs", "y", "en", "an", "services", "sg", "details", "sl", "bs", "in", "v", "r", "ps", "l", "sync", "sys", "su", "features", "g", "states", "ys", "sports", "is", "sup", "new", "es", "ts", "p", "si", "full", "se", "ns", "less", "spec", "client", "us", "t", "m", "conf", "n", "sets", "this", "stats", "ops", "aws"], "block": [" blocks", "size", "type", "ctx", "mode", "device", "Block", "output", "audio", "bc", "byte", "stat", "config", "enc", "input", "blocks", "record", "image", "w", "buffer", "e", "info", "script", "video", "window", "data", "object", "cache"], "motion_x": ["rup_x", "motion___dx", "move_cross", "move_y", "motion___index", "motion___x", "rup_dx", "motionIdy", "motionIdname", "motionIdx", "motion_name", "motion___y", "motionIdcross", "motion_index", "rup_index", "move_x", "move_name", "motion_dx", "motion_cross", "rup_y"], "motion_y": ["move_y", "motion11height", "move_height", "eye_height", "motion11x", "motion11py", "motion_ya", "move_x", "eye_y", "motion11y", "eye_x", "motion_py", "move_py", "motion_height", "eye_ya"], "i": ["ii", "ni", "abi", "li", "uri", "hi", "f", "phi", "I", "k", "mu", "api", "ip", "oi", "mi", "fi", "chi", "y", "c", "yi", "ki", "iu", "ini", "d", "h", "ri", "p", "ji", "si", "b", "pi", "io", "j", "ori", "gi", "ami", "key", "in", "v", "xi", "bi", "zi", "di", "ind", "qi", "ui", "ti", "r", "l", "ci", "u", "index", "m", "e", "n", "info", "ai", "lc", "eni", "x", "ix"], "cbp": ["abbps", "ggps", "abbc", "rbc", "ggP", "cbP", "cbpi", "abbP", "rbpc", "abbpc", "ggpi", "cbps", "cbpc", "bbP", "cfp", "CBp", "rbpi", "cfP", "CBc", "CBP", "CBps", "CBpc", "rbps", "cfpc", "ggp", "cbc", "rbP", "bcps", "abbp", "bbpi", "bbps", "bbp", "cfps", "bcp", "rbp", "bbpc", "bcP", "bcpc"], "mb_skip_run": ["mb_skip_bit", "mb_skip_count", "mb_num_run", "mb_skip_unit", "mb_num_count", "mb_num_unit", "mb_num_bit"], "skip_count": ["skip_code", "skipalcode", "skipalcount", "skipalcounter", "miss_file", "skip_file", "miss_count", "skipalfile", "skip_counter", "miss_counter", "miss_code"], "misc_bits": ["skipvelbands", "everyvelbits", "every_runs", "skipveldates", "skipvelruns", "skipumbands", "skipvelbits", "skip_runs", "everyvelruns", "every_dates", "skip_bands", "skipumdates", "skipumbits", "every_bits", "everyveldates", "skip_bits", "skipumruns", "every_bands", "everyvelbands", "skip_dates"], "last_bits": ["max_cycles", "max_locks", "lastalllocks", "lastallbit", "last128locks", "lastallcycles", "last128cycles", "lastallbits", "max_bit", "last128bits", "last_bit", "last_locks", "last128bit", "last_cycles", "max_bits"]}}
{"project": "qemu", "commit_id": "fb846a094fdee7bb6a88b48aeed0d97a8080a20d", "target": 0, "func": "static void virtio_ccw_device_realize(VirtioCcwDevice *dev, Error **errp)\n\n{\n\n    unsigned int cssid = 0;\n\n    unsigned int ssid = 0;\n\n    unsigned int schid;\n\n    unsigned int devno;\n\n    bool have_devno = false;\n\n    bool found = false;\n\n    SubchDev *sch;\n\n    int num;\n\n    DeviceState *parent = DEVICE(dev);\n\n    Error *err = NULL;\n\n    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);\n\n    VirtIODevice *vdev;\n\n\n\n    sch = g_malloc0(sizeof(SubchDev));\n\n\n\n    sch->driver_data = dev;\n\n    dev->sch = sch;\n\n\n\n    dev->indicators = NULL;\n\n\n\n    /* Initialize subchannel structure. */\n\n    sch->channel_prog = 0x0;\n\n    sch->last_cmd_valid = false;\n\n    sch->thinint_active = false;\n\n    /*\n\n     * Use a device number if provided. Otherwise, fall back to subchannel\n\n     * number.\n\n     */\n\n    if (dev->bus_id) {\n\n        num = sscanf(dev->bus_id, \"%x.%x.%04x\", &cssid, &ssid, &devno);\n\n        if (num == 3) {\n\n            if ((cssid > MAX_CSSID) || (ssid > MAX_SSID)) {\n\n                error_setg(errp, \"Invalid cssid or ssid: cssid %x, ssid %x\",\n\n                           cssid, ssid);\n\n                goto out_err;\n\n            }\n\n            /* Enforce use of virtual cssid. */\n\n            if (cssid != VIRTUAL_CSSID) {\n\n                error_setg(errp, \"cssid %x not valid for virtio devices\",\n\n                           cssid);\n\n                goto out_err;\n\n            }\n\n            if (css_devno_used(cssid, ssid, devno)) {\n\n                error_setg(errp, \"Device %x.%x.%04x already exists\",\n\n                           cssid, ssid, devno);\n\n                goto out_err;\n\n            }\n\n            sch->cssid = cssid;\n\n            sch->ssid = ssid;\n\n            sch->devno = devno;\n\n            have_devno = true;\n\n        } else {\n\n            error_setg(errp, \"Malformed devno parameter '%s'\", dev->bus_id);\n\n            goto out_err;\n\n        }\n\n    }\n\n\n\n    /* Find the next free id. */\n\n    if (have_devno) {\n\n        for (schid = 0; schid <= MAX_SCHID; schid++) {\n\n            if (!css_find_subch(1, cssid, ssid, schid)) {\n\n                sch->schid = schid;\n\n                css_subch_assign(cssid, ssid, schid, devno, sch);\n\n                found = true;\n\n                break;\n\n            }\n\n        }\n\n        if (!found) {\n\n            error_setg(errp, \"No free subchannel found for %x.%x.%04x\",\n\n                       cssid, ssid, devno);\n\n            goto out_err;\n\n        }\n\n        trace_virtio_ccw_new_device(cssid, ssid, schid, devno,\n\n                                    \"user-configured\");\n\n    } else {\n\n        cssid = VIRTUAL_CSSID;\n\n        for (ssid = 0; ssid <= MAX_SSID; ssid++) {\n\n            for (schid = 0; schid <= MAX_SCHID; schid++) {\n\n                if (!css_find_subch(1, cssid, ssid, schid)) {\n\n                    sch->cssid = cssid;\n\n                    sch->ssid = ssid;\n\n                    sch->schid = schid;\n\n                    devno = schid;\n\n                    /*\n\n                     * If the devno is already taken, look further in this\n\n                     * subchannel set.\n\n                     */\n\n                    while (css_devno_used(cssid, ssid, devno)) {\n\n                        if (devno == MAX_SCHID) {\n\n                            devno = 0;\n\n                        } else if (devno == schid - 1) {\n\n                            error_setg(errp, \"No free devno found\");\n\n                            goto out_err;\n\n                        } else {\n\n                            devno++;\n\n                        }\n\n                    }\n\n                    sch->devno = devno;\n\n                    css_subch_assign(cssid, ssid, schid, devno, sch);\n\n                    found = true;\n\n                    break;\n\n                }\n\n            }\n\n            if (found) {\n\n                break;\n\n            }\n\n        }\n\n        if (!found) {\n\n            error_setg(errp, \"Virtual channel subsystem is full!\");\n\n            goto out_err;\n\n        }\n\n        trace_virtio_ccw_new_device(cssid, ssid, schid, devno,\n\n                                    \"auto-configured\");\n\n    }\n\n\n\n    /* Build initial schib. */\n\n    css_sch_build_virtual_schib(sch, 0, VIRTIO_CCW_CHPID_TYPE);\n\n\n\n    sch->ccw_cb = virtio_ccw_cb;\n\n\n\n    /* Build senseid data. */\n\n    memset(&sch->id, 0, sizeof(SenseId));\n\n    sch->id.reserved = 0xff;\n\n    sch->id.cu_type = VIRTIO_CCW_CU_TYPE;\n\n\n\n    if (k->realize) {\n\n        k->realize(dev, &err);\n\n    }\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        css_subch_assign(cssid, ssid, schid, devno, NULL);\n\n        goto out_err;\n\n    }\n\n\n\n    /* device_id is only set after vdev has been realized */\n\n    vdev = virtio_ccw_get_vdev(sch);\n\n    sch->id.cu_model = vdev->device_id;\n\n\n\n    /* Only the first 32 feature bits are used. */\n\n    dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,\n\n                                                         dev->host_features[0]);\n\n\n\n    virtio_add_feature(&dev->host_features[0], VIRTIO_F_NOTIFY_ON_EMPTY);\n\n    virtio_add_feature(&dev->host_features[0], VIRTIO_F_BAD_FEATURE);\n\n\n\n    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,\n\n                          parent->hotplugged, 1);\n\n    return;\n\n\n\nout_err:\n\n    dev->sch = NULL;\n\n    g_free(sch);\n\n}\n", "idx": 9744, "substitutes": {"dev": ["bus", "dem", "debug", "de", "wd", "die", "block", "pub", "valid", "sd", "device", "diff", "comment", "api", "self", "cand", "dom", "serial", "rad", "md", "adv", "gu", "ver", "db", "DEV", "dist", "user", "d", "nov", "pack", "ev", "mod", "config", "sh", "der", "plug", "app", "driver", "img", "doc", "Dev", "grad", "test", "di", "v", "dc", "dd", "ch", "mem", "df", "req", "def", "conn", "dim", "w", "cam", "ow", "conf", "dm", "info", "this", "sk", "root", "priv", "var", "ad", "data", "cache"], "errp": ["rrp", "lerp", "lerb", "nerpe", "finderp", "finderpc", "strp", "reqg", "mrpr", "rrg", "errorpc", "finderps", "finderP", "errP", "lerps", "errorps", "errpr", "eorb", "nerp", "iterg", "reqcp", "errps", "eorp", "iterP", "lerP", "eorP", "reqn", "errcp", "mrp", "bugpe", "errb", "mrP", "errorp", " errps", "strpc", "iterpc", "eorps", "errg", "itercp", "nerpr", "errorP", " errpc", " errb", "errn", "rrcp", "errpc", "bugpr", "bugP", "mrpe", " errP", "nerP", "itern", "rrn", "strps", "iterps", "bugp", "errpe", "reqp", "iterp"], "schid": ["sshide", "schID", "schehide", "skaid", "sskid", "scid", "ssname", "schename", "chno", "slname", "scID", "csshide", "skid", "schId", "schite", "sckid", "scheno", "scheId", "scheid", "schhide", "scheids", "slId", "chId", "schkid", "skkid", "schids", "skids", "slid", "scno", "servid", "chid", "ch\n", "ssId", "skId", "slkid", "schit", "chkid", "cssid", " schID", "skit", "schno", "ssids", "scids", "sk\n", "scname", "khite", "chID", " schit", "schip", "skno", "schaid", "servname", "skite", "chaid", "khname", "skname", " schno", "khip", "khid", "cssids", "chip", "servID", "cssname", "schname", "chids", "chite", "skID", "chname", "servaid", "scit", "skip"], "devno": ["debugyes", "devnone", "advnone", "privnos", "evNo", "appyes", " devnos", "varNo", "debugNo", "varno", " devdo", "privn", "varnos", "advn", " devyes", "evnos", "appn", "divNo", "divno", "divdo", "derno", "evyes", "debugno", " devyo", "appNo", " devlo", "evlo", "devn", "varyo", "deryes", "errNo", "errnone", " devn", "evno", "appno", "errn", "devlo", "devNo", "privNo", "privno", "divyes", "devdo", "errno", "divlo", "deryo", "divnos", "advno", " devNo", "devnos", "devyo", "vardo", " devnone", "devyes", "advNo", "evn", "debugn", "varyes"], "sch": ["school", "ctx", "src", "service", "cs", "chi", "inch", "sp", "sh", "gh", "plug", "cm", "zh", "chy", "gb", "ch", "css", "channel", "ci", "cr", "gr", "sn", "shop", "inst", "osh", "sd", "th", "ss", "serv", "sr", "usb", "sb", "enc", "http", "scope", "ssl", "kr", "conn", "sc", "mc", "s", "cho", "cher", "ctr", "ph", "ky", "sm", "sw", "sche", "chn", "cht", "app", "bh", "ssh", "cfg", "sl", "sys", "sk", "rh", "kh", "g", "chain", "Sch", "arch", "si", "chip", "loc", "cp", "soc", "se", "spec", "ich", "ach", "cer", "git", "conf"], "num": ["fn", "no", "NUM", "un", "id", "nr", "max", "nc", "um", "nb", "result", "ul", "len", "node", "offset", "orig", "loc", "span", "nom", "nu", "con", "gen", "umi", "loop", "number", "code", "inc", "du", "count", "index", "col", "om", "unit", "n", "nob", "su", "Num", "uni", "name", "nam", "miss", "coord", "sum"], "parent": ["ctx", "f", "Parent", "src", "cow", "state", "self", "class", "c", "instance", "cmp", "i", "arch", "cur", "scope", "cfg", "channel", "def", "conn", "conf", "data", "CH", "child", "mc", "root", "inst", "cache"], "err": ["resp", "phi", "exc", "proc", "fi", "mr", "Er", "dr", "ev", "cb", "arr", "der", "ah", "cfg", "ise", "error", "req", "acer", "gr", "conf", "er", "sys", "msg", "rr", "rh", "res", "ec"], "k": ["ctx", "ky", "wk", "K", "kid", "c", "ki", "ks", "uk", "kernel", "tk", " sk", "ck", "kk", "kw", "dk", "mk", "v", "spec", "ik", "kind", "kr", "conn", "m", "conf", "n", "sk", "mc"], "vdev": ["Vdiv", "fdevice", "vdevice", "Vdevice", "vddev", "vddiv", "Vdev", "fdiv", "vddevice", "vdiv", "fdev"], "ssid": ["hesslit", "schID", "lessid", "rssname", "nsid", "csID", "sskid", "hesside", "ssname", "csname", "sside", "csslit", "grosslit", "rssid", "hessi", "rssin", "nskid", "dsid", "nslike", "skid", "grossi", "rssids", "grossid", "rsslike", "schids", "rssID", "ssi", "hesslike", "sslit", "pskid", "wside", "ssID", "dsin", "csskid", "ssin", "schide", "rsside", "dsID", "hesskid", "schit", "cssid", "dskid", "psid", "csit", "cskid", "dsit", "schlike", "ssids", "grossname", "cside", "dsids", "cslike", "wsid", "hessaid", "nsaid", "nsids", "wslike", "ssaid", "csside", "cssi", "ssit", "skname", "csslike", "csids", "nsID", "hessname", "cssids", "pside", "wsids", "dside", "cssID", "cssname", "skide", "rsskid", "cssaid", "lessname", "sslike", "psin", "lessID", "skID", "csid", "lesskid", "hessids", "hessid"]}}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void op_cp1_registers(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {\n\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 9754, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(rgb24tobgr24)(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tunsigned i;\n\n#ifdef HAVE_MMX\n\n\tlong mmx_size= 23 - src_size;\n\n\tasm volatile (\n\n\t\t\"test %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\"jns 2f\t\t\t\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24r)\", %%mm5\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24g)\", %%mm6\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24b)\", %%mm7\t\\n\\t\"\n\n\t\tASMALIGN(4)\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\tPREFETCH\" 32(%1, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movq   (%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // BGR BGR BG\n\n\t\t\"movq   (%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // BGR BGR BG\n\n\t\t\"movq  2(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // R BGR BGR B\n\n\t\t\"psllq $16, %%mm0\t\t\\n\\t\" // 00 BGR BGR\n\n\t\t\"pand %%mm5, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm6, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\t\"movq  6(%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // BGR BGR BG\n\n\t\tMOVNTQ\" %%mm1,   (%2, %%\"REG_a\")\\n\\t\" // RGB RGB RG\n\n\t\t\"movq  8(%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // R BGR BGR B\n\n\t\t\"movq 10(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // GR BGR BGR\n\n\t\t\"pand %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm5, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\t\"movq 14(%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // R BGR BGR B\n\n\t\tMOVNTQ\" %%mm1,  8(%2, %%\"REG_a\")\\n\\t\" // B RGB RGB R\n\n\t\t\"movq 16(%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // GR BGR BGR\n\n\t\t\"movq 18(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // BGR BGR BG\n\n\t\t\"pand %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm5, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\tMOVNTQ\" %%mm1, 16(%2, %%\"REG_a\")\\n\\t\"\n\n\t\t\"add $24, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t\"2:\t\t\t\t\\n\\t\"\n\n\t\t: \"+a\" (mmx_size)\n\n\t\t: \"r\" (src-mmx_size), \"r\"(dst-mmx_size)\n\n\t);\n\n\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n\n\n\tif(mmx_size==23) return; //finihsed, was multiple of 8\n\n\n\n\tsrc+= src_size;\n\n\tdst+= src_size;\n\n\tsrc_size= 23-mmx_size;\n\n\tsrc-= src_size;\n\n\tdst-= src_size;\n\n#endif\n\n\tfor(i=0; i<src_size; i+=3)\n\n\t{\n\n\t\tregister uint8_t x;\n\n\t\tx          = src[i + 2];\n\n\t\tdst[i + 1] = src[i + 1];\n\n\t\tdst[i + 2] = src[i + 0];\n\n\t\tdst[i + 0] = x;\n\n\t}\n\n}\n", "idx": 9761, "substitutes": {"src": ["rect", "sur", "support", "transform", "server", "scl", "dest", "tif", "reverse", "reflect", "proc", "comp", "sel", "sub", "rob", "sq", "conv", "dist", "sup", "sr", "sb", "rc", "config", "ser", "cb", "cur", "slice", "sci", "loc", "b", "st", "ssl", "url", "grad", "gb", "sl", "rb", "ruby", "cv", "share", "spec", "r", "source", "sort", "sc", "sync", "stack", "sn", "sys", "RC", "secure", "rs", "syn", "s", "rest", "uc", "sec", "stream", "send", "inst"], "dst": ["hdest", "dsc", "nsrc", "ldsc", "nsc", " dST", "Dst", "ddest", "ssts", "fst", "ldst", "rdst", "frest", "ldconst", "drest", "hst", " drest", "hsp", "ldr", "sst", "Dconst", "adst", "adconst", "adsts", " ddest", "Dsts", "lsts", " dsts", "dconst", " dsp", "sST", "lst", "ddr", " ddr", "dsrc", "rddest", "sdest", "Ddest", "lsp", "nrest", " dsrc", "ldest", "fsts", "dsp", "dST", "fsrc", "hsts", "dsts", "adsc", "ldsts", " dsc", " dconst", "Ddr", "rdsts", "fconst", "rdST", "fsc", "nst", "Dsc"], "src_size": [" src_loc", "src_name", "src96scale", "source_length", "src128scale", " src_scale", "src_width", "src96size", "rc_address", "source_scale", "rc_scale", "src_loc", "src_capacity", " src_capacity", "rc_size", "rc_name", "src96capacity", "src_scale", "rc_shape", "src96cycle", "src_cycle", " src_cycle", "source_size", "src_address", "src_offset", " src_offset", "src_model", "src128length", " src_speed", "src128size", "src_length", "src_shape", "rc_model", " src_width", "src96address", "src96model", "src_time", "src_speed", " src_time"], "i": ["ii", "ti", "g", "ni", "li", "uri", "hi", "f", "id", "phi", "I", "api", "mu", "oi", "mi", "fi", "y", "c", "iu", "a", "ini", "d", "multi", "h", "ji", "p", "slice", "si", "anti", "b", "di", "pi", "io", "inner", "j", "gi", "bit", "ami", "cli", "z", "v", "in", "bi", "zi", "xi", "qi", "r", "ui", "t", "source", "l", "ci", "esi", "u", "index", "m", "e", "n", "info", "init", "my", "ai", "eni", "name", "page", "ix", "it"], "memory": ["binary", "message", "global", "texture", "Memory", "byte", "media", "java", "module", "material", "application", "master", "function", "session", "asm", "math", "database", "array", "address", "machine", "record", "mem", "image", "vm", "program", "gpu", "m", "buffer", "reference", "storage", "ram", "manager", "complex", "cache"], "x": ["ax", "xf", "f", "xc", "xes", "xs", "y", "c", "X", "ux", "ex", "d", "h", "p", "b", "ic", "px", "ct", "z", "xi", "v", "rx", "t", "xb", "val", " xx", "index", "xx", "dx", "w", "m", "tx", "e", "xp", "ix"]}}
{"project": "FFmpeg", "commit_id": "ffd7fd79441f97f1edb25181af0603ff6ea9b342", "target": 1, "func": "static int vda_h264_end_frame(AVCodecContext *avctx)\n{\n    H264Context *h                      = avctx->priv_data;\n    struct vda_context *vda_ctx         = avctx->hwaccel_context;\n    AVFrame *frame                      = &h->cur_pic_ptr->f;\n    struct vda_buffer *context;\n    AVBufferRef *buffer;\n    int status;\n    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)\n    status = vda_sync_decode(vda_ctx);\n    frame->data[3] = (void*)vda_ctx->cv_buffer;\n    if (status)\n        av_log(avctx, AV_LOG_ERROR, \"Failed to decode frame (%d)\\n\", status);", "idx": 9772, "substitutes": {"avctx": ["avcontext", "AVctx", "avectx", "avcas", "avcf", "avecf", "ajcontext", "avcb", "ajkb", "svctrl", " avcas", "AVkb", " avctrl", "avcs", " avcb", "svconn", " avcontext", "AVcas", "avekb", "ajctx", "ajcb", "AVcf", "afcs", " avconn", "avkb", "AVconn", "avecontext", "ajconn", "AVcb", "AVcontext", "svctx", "avctrl", "svcontext", "svcs", "avconn", " avcs", "svcas", "afctrl", "afctx", "ajcf", "afcontext"], "h": ["g", "ph", "hd", "H", "hw", "ctx", "f", "hr", "host", "self", "c", "d", "auth", "p", "ha", "http", "sh", "gh", "ah", "hp", "ht", "v", "ch", "header", "t", "o", "handler", "ih", "cf", "q", "he", "w", "m", "e", "n", "rh", "ec", "data", "hm"], "vda_ctx": ["vda_ci", "vDA_context", "vda2context", "vla_cmp", "vda_conn", "vda_cu", "vda_lc", "vda_cmp", "vda_context", "vDA_coll", "vla_ctx", "vDA_ci", "vda__context", "vda2ctx", "vdc_sync", "vla_tx", "vDA_ctx", "vda_sync", "vdc_ctx", "vda__cmp", "vla_context", "vda__conn", "vda_ca", "vdc_conn", "vda_coll", "vDa_cu", "vda__lc", "vDa_rt", "vdc_context", "vda__ctx", "vdc_ca", "vda__tx", "vda2coll", "vda_tx", "vdc_lc", "vda2ci", "vDa_context", "vda_rt", "vDa_ctx"], "frame": ["element", "message", "block", "ctx", "f", "file", "board", "request", "flow", "view", "c", "game", "event", "draw", "document", "iframe", "p", "trace", "thread", "image", "row", "header", "source", "channel", "fram", "call", "cf", "frames", "stack", "base", "Frame", "video", "window", "data", "object", "line"], "context": ["container", "ctx", "board", "flow", "buf", "instance", "event", "config", "document", "content", "scope", "definition", "shape", "center", "thread", "image", "parent", "header", "source", "channel", "cf", "stack", "component", "base", "stream", "data"], "buffer": ["container", "message", "writer", "block", "board", "flow", "view", "buf", "result", "transfer", "event", "document", "iframe", "record", "image", "header", "source", "channel", "buff", "stack", "reference", "batch", "window", "data", "cache"], "status": ["flags", "debug", "received", "prefix", "message", "wait", "standard", "size", "args", "comment", "service", "err", "state", "update", "result", "success", "stat", "score", "uses", "fps", "content", "stage", "ity", "settings", "session", "details", "full", "style", "missing", "magic", "spec", "code", "fail", "source", "error", "complete", "level", "errors", "sync", "index", "used", "speed", "e", "security", "msg", "progress", "reason", "line", "s", "null", " Status", "name", "grade", "stats", "gc", "rate", "Status", "skip", "str"]}}
{"project": "FFmpeg", "commit_id": "fbaf75b166cd067cf383a75ffcccb1e2b370bf6d", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx, void *data,\n\n                        int *got_frame, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    H264Context *h     = avctx->priv_data;\n\n    AVFrame *pict      = data;\n\n    int buf_index      = 0;\n\n    Picture *out;\n\n    int i, out_idx;\n\n    int ret;\n\n\n\n    h->flags  = avctx->flags;\n\n\n\n    /* end of stream, output what is still in the buffers */\n\n    if (buf_size == 0) {\n\n out:\n\n\n\n        h->cur_pic_ptr = NULL;\n\n        h->first_field = 0;\n\n\n\n        // FIXME factorize this with the output code below\n\n        out     = h->delayed_pic[0];\n\n        out_idx = 0;\n\n        for (i = 1;\n\n             h->delayed_pic[i] &&\n\n             !h->delayed_pic[i]->f.key_frame &&\n\n             !h->delayed_pic[i]->mmco_reset;\n\n             i++)\n\n            if (h->delayed_pic[i]->poc < out->poc) {\n\n                out     = h->delayed_pic[i];\n\n                out_idx = i;\n\n            }\n\n\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n\n\n        if (out) {\n\n            out->reference &= ~DELAYED_PIC_REF;\n\n            ret = output_frame(h, pict, &out->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n\n\n        return buf_index;\n\n    }\n\n    if(h->is_avc && buf_size >= 9 && buf[0]==1 && buf[2]==0 && (buf[4]&0xFC)==0xFC && (buf[5]&0x1F) && buf[8]==0x67){\n\n        int cnt= buf[5]&0x1f;\n\n        const uint8_t *p= buf+6;\n\n        while(cnt--){\n\n            int nalsize= AV_RB16(p) + 2;\n\n            if(nalsize > buf_size - (p-buf) || p[2]!=0x67)\n\n                goto not_extra;\n\n            p += nalsize;\n\n        }\n\n        cnt = *(p++);\n\n        if(!cnt)\n\n            goto not_extra;\n\n        while(cnt--){\n\n            int nalsize= AV_RB16(p) + 2;\n\n            if(nalsize > buf_size - (p-buf) || p[2]!=0x68)\n\n                goto not_extra;\n\n            p += nalsize;\n\n        }\n\n\n\n        return ff_h264_decode_extradata(h, buf, buf_size);\n\n    }\n\nnot_extra:\n\n\n\n    buf_index = decode_nal_units(h, buf, buf_size, 0);\n\n    if (buf_index < 0)\n\n        return -1;\n\n\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n\n        av_assert0(buf_index <= buf_size);\n\n        goto out;\n\n    }\n\n\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF ||\n\n            buf_size >= 4 && !memcmp(\"Q264\", buf, 4))\n\n            return buf_size;\n\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) ||\n\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n\n        if (avctx->flags2 & CODEC_FLAG2_CHUNKS)\n\n            decode_postinit(h, 1);\n\n\n\n        field_end(h, 0);\n\n\n\n        /* Wait for second field. */\n\n        *got_frame = 0;\n\n        if (h->next_output_pic && (h->next_output_pic->sync || h->sync>1)) {\n\n            ret = output_frame(h, pict, &h->next_output_pic->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n            if (CONFIG_MPEGVIDEO) {\n\n                ff_print_debug_info2(h->avctx, h->next_output_pic, pict, h->er.mbskip_table,\n\n                                    &h->low_delay,\n\n                                    h->mb_width, h->mb_height, h->mb_stride, 1);\n\n            }\n\n        }\n\n    }\n\n\n\n    assert(pict->data[0] || !*got_frame);\n\n\n\n    return get_consumed_bytes(buf_index, buf_size);\n\n}\n", "idx": 9781, "substitutes": {"avctx": ["avcontext", " avcu", "aircontext", "avcas", " avcas", "afpkg", " avloc", "abci", "afci", "abcontext", "avci", "awloc", "aircas", "afcas", "avloc", " avcontext", "avcu", "afcam", "avpkg", "abctx", "abcu", "afloc", "awcontext", "airpkg", " avcam", "awcam", "afcu", "avcam", "awctx", " avci", "afctx", " avpkg", "airctx", "afcontext"], "data": ["dat", "pos", "message", "empty", "size", "f", "sample", "device", "Data", "proc", "connection", "result", "media", "module", "a", "DATA", "config", "response", "input", "content", "database", "frame", "feed", "memory", "code", "package", "image", "parent", "client", "header", "reader", "channel", "da", "val", "length", "picture", "start", "next", "buff", "capt", "buffer", "body", "value", "video", "window", "batch", "cache"], "got_frame": ["got_iframe", "gotqpoint", "gotacframe", "gone_frame", "gotqvalue", "got_value", "gotacpoint", " got_line", "gotallline", "gotqframe", "got___point", "got_frames", "got__frame", "gotacvalue", "got_trace", "gone_value", "got__trace", "gotaciframe", "gone_iframe", "got___value", " got_trace", "goneacpoint", "got_line", "goneaciframe", "got__frames", "got___iframe", "gone_point", "got__line", "gotallframes", "gotallframe", "goneacframe", "goneacvalue", "gotqiframe", "got_point", "got___frame", " got_frames", "gotalltrace"], "avpkt": ["avlpft", "avPacket", "evfkk", "avspct", "evfkt", "avfkk", "awprki", "avpacket", "evpck", "awprft", "avPck", "avppkt", "avprkt", "avspcht", "avpcht", "awpkt", "avPft", "awprkt", "avpck", "awprect", "avpakk", "awpft", "avpkk", "avppct", "avspkt", " avspkt", "avfkt", " avspnt", "avpft", "avpki", "avfacket", "evpkk", "avpct", "avPkt", "avprft", " avpnt", " avpcht", "avlpect", "awpki", "avlpkt", "avPcht", "avspnt", "avprect", "avPki", "evfck", "awpect", " avpct", " avspct", "avprki", "avPnt", "avpack", "avpect", "avPct", " avspcht", "avpaacket", "avppnt", "evpkt", "avlpki", "avppcht", "avfck", "avpnt", "evfacket", "avpakt", "avPect", "avPkk", "evpacket"], "buf": ["text", "ctx", "src", "seq", "c", "rc", "orig", "b", "fb", "queue", "mem", "uf", "cmd", "buff", "msg", "feat", "cas", "home", "bag", "box", "conv", "off", "img", "frame", "num", "header", "alloc", "bin", "ab", "port", "bp", "bus", "shift", "usr", "block", "f", "ff", "aux", "bc", "pb", "brace", "config", "cur", "begin", "v", "r", "br", "cf", "comb", "font", "vec", "path", "fi", "proc", "grab", "bu", "cb", "offset", "loc", "Buff", "xff", "cp", "bt", "context", "uv", "rb", "cv", "ffff", "capt", "buffer", "wb", "uc", "batch", "cache"], "h": ["g", "ph", "adh", "hd", "H", "hw", "ctx", "f", "hr", "um", "host", "th", "oh", "home", "self", "c", "help", "d", "cache", "ha", "http", "sh", "gh", "uh", "b", "hy", "ah", "bh", "hp", "zh", "it", "hh", "ht", "context", "hi", "hs", "v", "ich", "ch", "header", "o", "t", "handler", "ih", "r", "l", "he", "q", "hl", "u", "w", "m", "dh", "e", "eh", "rh", "han", "kh", "hm"], "pict": ["ctx", "path", "pl", "fi", "proc", "wx", "seq", "mat", "stat", " pic", "config", "cat", "xxx", " img", "dq", "img", "ct", "fig", "pic", "doc", "fat", "tmp", "image", "ch", "txt", "gui", "picture", "conn", "buff", "capt", "cam", "obj", "init", "photo", "nt", "fin", "pty", "mot", "feat", "pid"], "out": ["at", "comment", "ref", "err", "option", "c", "trial", "reset", "b", "cmd", "dot", "hard", "next", "w", "init", "hidden", "line", "OUT", "result", "conv", "user", "off", "cat", "img", "doc", "flat", "op", "parent", "copy", "o", "bin", "error", "conn", "prefix", "block", "f", "diff", "plain", "config", "again", "qa", "part", "in", "v", "picture", "sync", "u", "lib", "null", "g", "timeout", "no", "proc", "output", "Out", "outer", "new", "temp", "input", "inner", "io", "ext", "bit", "yout", "image", "client", "inc", "t", "opt", "m", "obj", "n", "cache"], "i": ["ii", "g", "ni", "abi", "li", "uri", "hi", "f", "id", "phi", "iv", "I", "api", "ip", "oi", "mi", "fi", "chi", "y", "c", "yi", "ki", "iu", "is", "ini", "a", "d", "module", "multi", "ri", "ji", "slice", "si", "b", "pi", "io", "inner", "j", "ori", "gi", "ie", "cli", "in", "xi", "di", "bi", "ti", "v", "qi", "o", "ui", "zi", "t", "l", "ci", "u", "index", "m", "e", "n", "info", "my", "ai", "mini", "eni", "lc", "x", "ix", "it"], "out_idx": ["out_midis", "out__midxc", "out_IDis", "out_IDx", "out_idxs", "out_dxs", "out_midx", "out_indx", "out__midx", "out__midxb", "out_idxb", "out_midxs", "out_midz", "out_idX", "out_idsx", "out_idsX", "out_inxs", "out_midxb", "out_inz", "out_indis", "out_Idz", "out_midX", "out_idv", "out_indz", "out_idxc", "out_idsxc", "out_Idc", "out__idx", "out_idxe", "out_idsxb", "out_ridx", "out_indxe", "out_idc", "out_indv", "out_Idxe", "out_IDxs", "out_ridxs", "out_Idx", "out__midX", "out_idis", "out__idxb", "out_dx", "out_ridz", "out_ridc", "out_Idv", "out_inc", "out__idX", "out_dxe", "out__idxc", "out_dv", "out_Idxs", "out_IDz", "out_inx", "out_midxc", "out_idz", "out_indxs"], "ret": ["usr", "pass", "no", "rt", "rets", "match", "att", "resp", "re", "RET", "feat", "ref", "id", "rev", "proc", "ft", "result", "success", "len", "sr", "rc", "cat", "back", "fun", "lit", "flag", "bit", "nz", "mt", "ext", "code", "gt", "mem", "num", "opt", "val", "det", "pet", "def", "arg", "reply", "xt", "obj", "nt", "reg", "res", "fin", "alt", "Ret", "pret", "status", "bot"], "p": ["padding", "g", "np", "tp", "f", "at", "dp", "api", "proc", "pb", "c", "pc", "a", "jp", "d", "patch", "lp", "per", "sp", "b", "pi", "cp", "j", "pair", "part", "P", "pre", "po", "v", "fp", "pe", "t", "r", "o", "ps", "wp", "l", "q", "pp", "u", "vp", "ap", "m", "e", "n", "pa", "xp", "s", "bp", "py", "pid"], "cnt": ["cNT", "ecno", "cno", "C0", "c\n", "bnt", "lc0", "c0", "Cno", "Count", "CNT", " c\n", "C\n", "bnn", "ecount", " cno", "lc\n", "cnn", "Cnn", "bount", "bNT", " cnn", "ecnt", "ecNT", " c0", " count", " cNT", "Cnt", "count"]}}
{"project": "qemu", "commit_id": "e853ea1cc68716c3d9c22d04578020c6dd743306", "target": 1, "func": "GIOStatus ga_channel_write_all(GAChannel *c, const char *buf, size_t size)\n\n{\n\n    GIOStatus status = G_IO_STATUS_NORMAL;\n\n    size_t count;\n\n\n\n    while (size) {\n\n        status = ga_channel_write(c, buf, size, &count);\n\n        if (status == G_IO_STATUS_NORMAL) {\n\n            size -= count;\n\n            buf += count;\n\n        } else if (status != G_IO_STATUS_AGAIN) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    return status;\n\n}\n", "idx": 9787, "substitutes": {"c": ["g", "ctx", "f", "xc", "k", "cs", "self", "vc", "ca", "a", "d", "h", "p", "enc", "b", "cu", "ct", "ctrl", "cc", "C", "dc", "ch", "ac", "t", "channel", "cl", "r", "l", "ci", "u", "cr", "w", "m", "e", "n", "tc", "ec", "lc", "mc", "s", "cd"], "buf": ["cas", "shift", "block", "ctx", "f", "pool", "src", "vec", "ff", "bc", "bag", "seq", "pb", "len", "rc", "cb", "p", "cur", "offset", "loc", "b", "fb", "cp", "queue", "bh", "gb", "feed", "rb", "fp", "cv", "num", "alloc", "br", "que", "Buffer", "uf", "cf", "buff", "buffer", "col", "tc", "cap", "fd", "uc", "batch"], "size": ["g", "shift", "timeout", "SIZE", "capacity", "empty", "args", "max", "limit", "handle", "success", "len", "small", "esc", "bytes", "offset", "content", "fee", "si", "loc", "cm", "use", "shape", "scale", "ize", "address", "code", "Size", "z", "num", "length", "source", "complete", "export", "start", "sync", "sum", "e", "speed", "n", "large", "sec", "name", "status", "cache"], "count": ["empty", "f", "type", "id", "limit", "max", "weight", "Count", "low", "depth", "len", "found", "i", "cache", "small", "new", "cat", "offset", "temp", "content", "loc", "b", "flag", "feed", "code", "parent", "num", "length", "val", "all", "call", "cond", "index", "start", "allow", "last", "col", "current", "base", "child", "name", "check", "sum"]}}
{"project": "FFmpeg", "commit_id": "22ecfcd4c79cdf812fdf406525ddf0fd1f7114e4", "target": 1, "func": "static int channelmap_query_formats(AVFilterContext *ctx)\n\n{\n\n    ChannelMapContext *s = ctx->priv;\n\n\n\n    ff_set_common_formats(ctx, ff_planar_sample_fmts());\n\n    ff_set_common_samplerates(ctx, ff_all_samplerates());\n\n    ff_channel_layouts_ref(ff_all_channel_layouts(), &ctx->inputs[0]->out_channel_layouts);\n\n    ff_channel_layouts_ref(s->channel_layouts,       &ctx->outputs[0]->in_channel_layouts);\n\n\n\n    return 0;\n\n}\n", "idx": 9789, "substitutes": {"ctx": ["cas", "hw", "Context", "k", "anc", "cs", "nc", "bc", "wcs", "vc", "c", "sq", "conv", "pc", "ca", "cmp", "jp", "config", "rc", "cpp", "cb", "p", "kb", "ck", "sci", "pkg", "loc", "qa", "kk", "cp", "cm", "acs", "cu", "ct", "ctrl", "kw", "grad", "context", "cc", "kt", "cli", "fc", "cv", "cms", "client", "cl", "std", "mac", "cmd", "qs", "cf", "conn", "sc", "ci", "cus", "cam", "tx", "fw", "tc", "cn", "mc", "lc", "sk", "cca", "gc"], "s": ["os", "utils", "args", "f", "service", "cs", "ls", "ss", "c", "sq", "i", "ks", "sv", "services", "sb", "params", "es", "p", "si", "sg", "S", "settings", "b", "ds", "fs", "ssl", "acs", "sl", "ans", "o", "ps", "qs", "ses", "sc", "sync", "gs", "w", "e", "n", "sets", "storage", "sa", "js", "ops"]}}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "static void flush_queued_work(CPUState *env)\n\n{\n\n    struct qemu_work_item *wi;\n\n\n\n    if (!env->queued_work_first)\n\n        return;\n\n\n\n    while ((wi = env->queued_work_first)) {\n\n        env->queued_work_first = wi->next;\n\n        wi->func(wi->data);\n\n        wi->done = true;\n\n    }\n\n    env->queued_work_last = NULL;\n\n    qemu_cond_broadcast(&qemu_work_cond);\n\n}\n", "idx": 9805, "substitutes": {"env": ["server", "dat", "ne", "dict", "args", "global", "eng", "state", "nc", "ea", "exc", "wk", "output", "db", "network", "en", "ini", "qt", "eu", "eva", "config", "ev", "wordpress", "enc", "enable", "console", "ani", "stage", "Environment", "net", "queue", "ass", "style", "context", "icer", "core", "viron", "code", "cv", "environment", "vm", "export", "que", "her", "conn", "esi", "dev", "next", "ench", "conf", "e", "init", "zone", "ec", "eni", "erv", "manager", "exec", "vs", "cache"], "wi": ["ii", "ni", "wal", "rw", "wan", "wiki", "iki", "mu", "mi", "wk", "fi", "ski", "wx", "wic", "wm", "yi", "ki", "wo", "ini", "ei", "wine", "hei", "sci", "si", "fee", "worker", "Wi", "nw", "kw", "gi", "wl", "wit", "wei", "cli", "di", "ti", "hi", "ye", "bi", "ee", "qi", "widget", "ui", "wu", "wp", "ci", "wt", "w", "wa", "fw", "wife", "iw", "wb", "eni", "bp", "iri", "WI", "data", "wig", "wid"]}}
{"project": "qemu", "commit_id": "477830727821e4bc337f4ac1fd222ffe0b900e1a", "target": 0, "func": "static int coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req,\n\n                           struct iovec *iov, int niov, bool create,\n\n                           enum AIOCBState aiocb_type)\n\n{\n\n    int nr_copies = s->inode.nr_copies;\n\n    SheepdogObjReq hdr;\n\n    unsigned int wlen;\n\n    int ret;\n\n    uint64_t oid = aio_req->oid;\n\n    unsigned int datalen = aio_req->data_len;\n\n    uint64_t offset = aio_req->offset;\n\n    uint8_t flags = aio_req->flags;\n\n    uint64_t old_oid = aio_req->base_oid;\n\n\n\n    if (!nr_copies) {\n\n        error_report(\"bug\");\n\n    }\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n\n\n    if (aiocb_type == AIOCB_READ_UDATA) {\n\n        wlen = 0;\n\n        hdr.opcode = SD_OP_READ_OBJ;\n\n        hdr.flags = flags;\n\n    } else if (create) {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    } else {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    }\n\n\n\n    if (s->cache_flags) {\n\n        hdr.flags |= s->cache_flags;\n\n    }\n\n\n\n    hdr.oid = oid;\n\n    hdr.cow_oid = old_oid;\n\n    hdr.copies = s->inode.nr_copies;\n\n\n\n    hdr.data_length = datalen;\n\n    hdr.offset = offset;\n\n\n\n    hdr.id = aio_req->id;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    s->co_send = qemu_coroutine_self();\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, co_write_request,\n\n                            aio_flush_request, s);\n\n    socket_set_cork(s->fd, 1);\n\n\n\n    /* send a header */\n\n    ret = qemu_co_send(s->fd, &hdr, sizeof(hdr));\n\n    if (ret < 0) {\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        error_report(\"failed to send a req, %s\", strerror(errno));\n\n        return -errno;\n\n    }\n\n\n\n    if (wlen) {\n\n        ret = qemu_co_sendv(s->fd, iov, niov, aio_req->iov_offset, wlen);\n\n        if (ret < 0) {\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            error_report(\"failed to send a data, %s\", strerror(errno));\n\n            return -errno;\n\n        }\n\n    }\n\n\n\n    socket_set_cork(s->fd, 0);\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, NULL,\n\n                            aio_flush_request, s);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    return 0;\n\n}\n", "idx": 9817, "substitutes": {"s": ["server", "sym", "service", "cs", "self", "c", "i", "d", "sci", "settings", "b", "gs", "e", "js", "os", "ls", "ss", "sq", "sb", "http", "S", "session", "sie", "ds", "fs", "ssl", "scope", "o", "ses", "qs", "submit", "f", "xs", "services", "sg", "details", "socket", "secondary", "sl", "sim", "r", "ps", "l", "sync", "south", "sys", "su", "g", "state", "states", "uns", "sports", "is", "new", "es", "p", "ts", "si", "full", "sis", "se", "ns", "spec", "us", "t", "your", "m", "conf", "n", "sets", "this", "storage", "sa", "stats", "aws"], "aio_req": ["aio0ref", "ao_grab", "aiofdesc", "aietMcall", "aio2req", "aios_comp", "aio_crit", "aioMreq", "aio_err", "aios_rx", "aioMtar", "aietMreq", "aiet_call", "aios_req", "aios_def", "aios_ref", "aio_comp", "aios_crit", "aiet_requ", "aiet_req", "aioMrequ", "aiofrequest", "ao_req", "aioMcall", "aietMrequ", "ao_request", "aio2err", "aio0request", "aio_rec", "aio_call", "aio_request", "aio0rx", "aio_rx", "aio2rs", "aio_ver", "aio2request", "aiofcrit", "aio_grab", "aios_desc", "aio0req", "aios_ver", "aietMtar", "ao_ref", "aiet_tar", "aios_rec", "aio_ref", "aio_desc", "aio_rs", "aio_requ", "aios_request", "aio_def", "aio_tar", "aiofreq"], "iov": ["ii", "ico", "ocr", "unc", "rio", "rob", "ou", "igi", "iii", "eu", "uh", "uo", "io", "uu", "iv", "roc", "icon", "ih", "ir", "oci", "om", "iop", "cons", "uno", "um", "ilo", "mx", " ov"], "niov": ["eiot", " niovo", "ciov", "niot", "eiove", "eiov", "ciove", "niovo", "niove", "eiovo", " niot", "ciovo", " niove", "ciot"], "create": ["message", "future", "unique", "wait", "type", "build", "creation", "execute", "update", "make", "destroy", "Create", "present", "drop", "write", "raise", "new", "creator", "change", "primary", "fee", "use", "replace", "when", "open", "clone", "code", "add", "native", "construct", "copy", "insert", "complete", "created", "initial", "clear", "save", "delete", "init", "none", "name", "check", "enable"], "aiocb_type": ["aiocb__code", "aiocsb_type", "aiocb__name", "aiocsb_name", "aiocb_code", "aiocb_name", "aiocb__Type", "aiocb_state", "aiocb_Type", "aiocb__type", "aiocb__style", "aiocb__state", "aiocsb_code", "aiocsb_style", "aiocsb_state", "aiocsb_Type", "aiocb_style"], "hdr": ["shld", "ghdr", "khvar", "harr", "handdr", " hDr", "thdr", "pharr", "Hdr", "shDR", "khdr", "hrc", " hrid", "thDR", "ehdi", "bhDR", "ahtr", "ghhr", "hldr", "hdi", "thhr", "hrr", "ahhr", " hr", "Hrec", "rhhr", "histdr", "hlld", " hrr", "chhr", "rhr", "hirid", "hr", "rhsr", "hld", "hrid", " hrec", "hastr", "thrid", "phrc", "hDr", "rhrec", "rhtr", "hhr", "phdr", "shtr", "ghtr", "ehrid", "hadr", " htr", "hstr", "thld", "ohDR", "histDr", "ehDr", "Htr", "hsr", "hDR", "hidr", "histrid", "eharr", " hDR", "shrr", "ehdr", "handrr", "ohrec", "ahstr", "bhrc", " Hdr", "hvar", "phsr", "shver", " hrs", " Hrr", "bhdr", "ahdr", "ghrec", "HDR", "thver", " hdi", "shdr", "rhrc", "Hrs", "ghstr", "bhstr", "rhDR", " hsr", "khrid", " Htr", "phDR", "rhdr", "shstr", "chdr", "hivar", "hatr", "hahr", "phstr", "hrs", "handrid", "shsr", "herid", "shrc", " hvar", " hrc", "phdi", "htr", "hrec", "khrc", "chrid", " hhr", "phr", "hlDR", "hver", "ohdr", "hirc", " hstr", "rhrs", "hlver", " harr", "herr", "hedr"], "wlen": ["wwlength", "ewoln", "ewlim", "wlength", "ewdl", "winlength", "wdl", "kwlength", "xlon", "wen", "wLen", "worddl", " wen", "walen", "wlim", "waoln", "xlen", "kwen", "woln", "wwlen", "ewlength", "ewen", "xlim", "wlon", "wwln", "winlen", "Wlength", "walength", "xlength", "rwlen", "Wlen", "kwlen", "wln", "wwLen", "rwln", "wadl", "ewlen", "winlim", "winlon", "ewlon", " wlength", "wordoln", "ewlf", "rwLen", "wlf", "rwlength", "kwlf", "wordlen", "WLen", "wordlength", " wlf", "Wln"], "ret": ["rets", "RET", " clen", "result", "success", "fields", " success", "off", "rows", " unused", "options", " result", "fun", "bit", " Flags", "val", "all", "def", " bits", "used", "bits", "nt", "Flags", "Ret", "ops"]}}
{"project": "FFmpeg", "commit_id": "5b0ad91b996506632708dcefc22d2835d04a4dba", "target": 1, "func": "static int img_write_packet(AVFormatContext *s, int stream_index,\n\n                            UINT8 *buf, int size)\n\n{\n\n    VideoData *img = s->priv_data;\n\n    AVStream *st = s->streams[stream_index];\n\n    ByteIOContext pb1, *pb;\n\n    AVPicture picture;\n\n    int width, height, ret, size1;\n\n    char filename[1024];\n\n\n\n    width = st->codec.width;\n\n    height = st->codec.height;\n\n\n\n    switch(st->codec.pix_fmt) {\n\n    case PIX_FMT_YUV420P:\n\n        size1 = (width * height * 3) / 2;\n\n        if (size != size1)\n\n            return -EIO;\n\n        \n\n        picture.data[0] = buf;\n\n        picture.data[1] = picture.data[0] + width * height;\n\n        picture.data[2] = picture.data[1] + (width * height) / 4;\n\n        picture.linesize[0] = width;\n\n        picture.linesize[1] = width >> 1; \n\n        picture.linesize[2] = width >> 1;\n\n        break;\n\n    case PIX_FMT_RGB24:\n\n        size1 = (width * height * 3);\n\n        if (size != size1)\n\n            return -EIO;\n\n        picture.data[0] = buf;\n\n        picture.linesize[0] = width * 3;\n\n        break;\n\n    default:\n\n        return -EIO;\n\n    }\n\n    \n\n    if (get_frame_filename(filename, sizeof(filename), \n\n                           img->path, img->img_number) < 0)\n\n        return -EIO;\n\n\n\n    if (!img->is_pipe) {\n\n        pb = &pb1;\n\n        if (url_fopen(pb, filename, URL_WRONLY) < 0)\n\n            return -EIO;\n\n    } else {\n\n        pb = &s->pb;\n\n    }\n\n    switch(img->img_fmt) {\n\n    case IMGFMT_PGMYUV:\n\n        ret = pgm_save(&picture, width, height, pb, 1);\n\n        break;\n\n    case IMGFMT_PGM:\n\n        ret = pgm_save(&picture, width, height, pb, 0);\n\n        break;\n\n    case IMGFMT_YUV:\n\n        ret = yuv_save(&picture, width, height, filename);\n\n        break;\n\n    case IMGFMT_PPM:\n\n        ret = ppm_save(&picture, width, height, pb);\n\n        break;\n\n    }\n\n    if (!img->is_pipe) {\n\n        url_fclose(pb);\n\n    }\n\n\n\n    img->img_number++;\n\n    return 0;\n\n}\n", "idx": 9842, "substitutes": {"s": ["g", "sam", "sym", "f", "src", "service", "api", "cs", "ls", "self", "sf", "ss", "serv", "xs", "c", "sq", "a", "sr", "sv", "services", "sb", "p", "ts", "sci", "sg", "si", "S", "ds", "sie", "fs", "ssl", "b", "http", "session", "se", "sl", "ns", "v", "spec", "summary", "op", "t", "r", "ps", "ses", "sc", "gs", "m", "su", "storage", "sa", "space"], "stream_index": ["feed_index", "stream_Index", "stream_design", "feed_pointer", "streamernum", "feed_num", "feed_Index", " stream_Index", "stream__index", "streamsIndex", "streamsindex", "stream__num", "streamsdesign", "stream_pointer", "stream_num", " stream_design", "stream__pointer", "streamerindex", "streamerIndex", "streamerpointer", "stream__Index"], "buf": ["padding", "text", "prefix", "dest", "ctx", "vec", "src", "home", "bc", "seq", "box", "rc", "config", "cb", "pkg", "loc", "b", "fb", "queue", "foo", "rb", "fp", "cv", "mem", "tmp", "alloc", "bin", "Buffer", "cmd", "uf", "border", "buff", "buffer", "pad", "func", "desc", "msg", "wb", "uc", "fd", "batch", "data", "feat"], "size": ["g", "SIZE", "capacity", "weight", "len", "small", "rc", "enc", "offset", "content", "si", "loc", "shape", "align", "style", "scale", "ize", " sizes", "code", "Size", "z", "image", "crop", "length", "source", "area", "buffer", "desc", "sn", "body", "speed", "unit", "storage", "large", "sec", "cap", "name", "video", "data", "count"], "img": ["big", "jpg", "im", "movie", "f", "src", "gif", "eng", "fi", "dom", "audio", "media", "gd", "i", "upload", "bl", "amp", "config", "rc", "iframe", "cb", "enc", "p", "input", "ani", "plug", "inst", "fb", "cm", "bg", "pict", "url", "fig", "ext", "gb", "pic", "ie", "ng", "og", "html", "iv", "tmp", "image", "aug", "icon", "br", "embed", "imag", "obj", "emb", "info", "data", "imp"], "st": ["fr", "steam", "sd", "sam", "rt", "sth", "src", "ost", "sm", "ss", "ft", "td", "stat", "gd", "stan", "fe", "d", "sb", "stage", "si", "sp", "sh", "ds", "ste", "ST", "sta", "sts", "nd", "ct", "pt", "se", "sl", "ut", "sim", "cv", "std", "sc", "sn", "sty", "ast", "obj", "St", "storage", "nt", "sa", "rest", "inst", "str"], "pb1": ["PB2", "p4", "refone", "p3", "PB3", "db3", "pb3", "db2", "ref1", "PB4", "ref4", "db1", "p2", "ref2", "PB1", "buf4", "buf2", "p1", "bufone", "buf1", "db4", "pb2", "PBone", "pb4", "pbone"], "pb": ["plugin", "np", "phrase", "pg", "ctx", "bm", "dp", "pm", "api", "pl", "typ", "mp", "ppa", "nb", "bc", "rob", "bps", "db", "pc", "lb", "jp", "eb", "lab", "sb", "lp", "bl", "pr", "p", "ib", "cb", "bridge", "pkg", "b", "fb", "cp", "bh", "gb", "pt", "avi", "rb", "bs", "fp", "tmp", "summary", "fc", "prot", "cv", "bb", "platform", "uf", "wp", "pp", "vp", "ab", "cod", "obj", "pa", "ob", "profile", "wb", "bp", "dl", "bf", "PB", "bot", "python"], "picture": ["fine", "li", "ctx", "file", "character", "comment", "service", "imgur", "pixel", "jp", "definition", "fb", "database", "pict", "imi", "ami", "summary", "package", "bi", "query", "info", "photos", "feat", "plugin", "movie", "gif", "api", "study", "library", "feature", "username", "ana", "brush", "kl", "fp", "widget", "error", "profile", "video", "manager", "detail", "statement", "history", "man", "config", "password", "pic", "family", "avi", "gallery", "phot", "photo", "large", "mini", "lc", "bank", "import", "uri", "money", "fi", "audio", "media", "game", "wikipedia", "guide", "cb", "io", "style", "piece", "Picture", "cli", "fat", "image", "entry", "gui", "buffer", "obj", "storage", "data", "slice"], "height": ["padding", "gap", "wall", "ctx", "max", "stroke", "windows", "gh", "definition", "time", "shr", "w", "pad", "margin", "depth", "feat", "location", "hold", "layout", "arrow", "id", "high", "view", "weight", "through", "resolution", "grow", "dist", "gold", "rows", "h", "shape", "crop", "length", "dim", "rank", "history", "huge", "lat", "y", "third", "duration", "paste", "total", "kw", "direction", "center", "density", "gain", "std", "three", "command", "gpu", "dark", "pull", "window", "tight", "device", "square", "flow", "quality", "png", "upload", "above", "input", "style", "bottom", "image", "level", "deep", "head", "buffer", "ty", "volume", "data", "Height", "slice"], "ret": ["pass", "rets", "rt", "id", "match", "final", "re", "RET", "att", "ref", "ft", "result", "output", "len", "rc", "cat", "back", "temp", "content", "rl", "split", "lit", "full", "url", "ext", "bit", "flat", "flag", "part", "ut", "gt", "mem", "std", "val", "bin", "det", "def", "count", "pet", "arg", "reply", "nt", "res", "alt", "status", "Ret", "feat", "let", "str"], "size1": ["shape0", "shape1", "width4", " size3", " sizeone", "any3", "SIZE4", " size0", "shapeone", "izPre", "size2", " sizeOne", "size0", "sizePre", "sizeone", "Size2", "SIZEone", " size01", "width1", "size01", "Size1", "shape2", "width2", " size2", "shape3", "Size0", " sizePre", "SIZE1", "widthone", "size4", "iz01", "iz1", "shapeOne", "iz2", "Sizeone", "size3", "width01", " size4", "sizeOne", "any1", "ize1", "widthPre", "ize0", "anyOne"], "filename": ["binary", "jpg", "prefix", "fn", "phrase", "utf", "file", "f", "src", "directory", "uri", "path", "tif", "byte", "seq", "png", "username", "config", "bytes", "document", "p", "content", "nil", "loc", "dll", "b", "fb", "title", "shape", "ssl", "url", "files", "family", "kl", "fp", "original", "image", "Filename", "il", "length", "wp", "word", "l", "buffer", "fil", "login", "n", "out", "root", "fd", "name", "txt", "data", "location", "slice", "nm"], "img_number": ["imgnumnum", "image_index", "img_num", "image_num", "image_number", "imgnumheader", "img_header", "img_index", "imgblocknumber", "image_header", "imgblockindex", "imgblocknum", "imgblockheader", "imgnumnumber", "imgnumindex"]}}
{"project": "qemu", "commit_id": "f51074cdc6e750daa3b6df727d83449a7e42b391", "target": 1, "func": "int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)\n\n{\n\n    /* On non-x86 we don't do PCI hotplug */\n\n    monitor_printf(mon, \"Can't hot-add drive to type %d\\n\", dinfo->type);\n\n    return -1;\n\n}\n", "idx": 9845, "substitutes": {"mon": ["Monitor", "ann", "mut", "monitor", "man", "sym", "mu", "chron", "mid", "min", "mand", "own", "module", "master", "emon", "Mon", "mos", "con", "don", "mic", "mun", "atom", "mont", "kin", "MON", "channel", "pin", "bin", "mo", "meter", "mm", "amon", "my", " monitor", "mons", "mor", "mc", "mot", "mag", "pid"], "qdict": ["qdef", " qdot", "eqdef", "qdot", "eqdict", "Qdot", "Qdef", " qdef", "Qdict", "eqdot"], "dinfo": ["rdfo", "dfo", "bdentry", "dInfo", "dentry", "bdInfo", "DInfo", "Dentry", "Dinfo", "bdinf", " dfo", "bdinfo", " dinf", "rdinfo", "Dfo", "dinf", "Dinf", " dentry", " dInfo", "rdinf"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n     int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) {\n\n  uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY;\n\n  // yv12toyuy2( src[0],src[1],src[2],dst,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] );\n\n  uint8_t *ysrc = src[0];\n\n  uint8_t *usrc = src[1];\n\n  uint8_t *vsrc = src[2];\n\n  const int width = c->srcW;\n\n  const int height = srcSliceH;\n\n  const int lumStride = srcStride[0];\n\n  const int chromStride = srcStride[1];\n\n  const int dstStride = dstStride_a[0];\n\n  const vector unsigned char yperm = vec_lvsl(0, ysrc);\n\n  const int vertLumPerChroma = 2;\n\n  register unsigned int y;\n\n\n\n  if(width&15){\n\n    yv12toyuy2( ysrc, usrc, vsrc, dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride);\n\n    return srcSliceH;\n\n  }\n\n\n\n  /* this code assume:\n\n\n\n  1) dst is 16 bytes-aligned\n\n  2) dstStride is a multiple of 16\n\n  3) width is a multiple of 16\n\n  4) lum&chrom stride are multiple of 8\n\n  */\n\n\n\n  for(y=0; y<height; y++)\n\n    {\n\n      int i;\n\n      for (i = 0; i < width - 31; i+= 32) {\n\n\tconst unsigned int j = i >> 1;\n\n\tvector unsigned char v_yA = vec_ld(i, ysrc);\n\n\tvector unsigned char v_yB = vec_ld(i + 16, ysrc);\n\n\tvector unsigned char v_yC = vec_ld(i + 32, ysrc);\n\n\tvector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm);\n\n\tvector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm);\n\n\tvector unsigned char v_uA = vec_ld(j, usrc);\n\n\tvector unsigned char v_uB = vec_ld(j + 16, usrc);\n\n\tvector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc));\n\n\tvector unsigned char v_vA = vec_ld(j, vsrc);\n\n\tvector unsigned char v_vB = vec_ld(j + 16, vsrc);\n\n\tvector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, vsrc));\n\n\tvector unsigned char v_uv_a = vec_mergeh(v_u, v_v);\n\n\tvector unsigned char v_uv_b = vec_mergel(v_u, v_v);\n\n\tvector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b);\n\n\tvector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b);\n\n\tvec_st(v_yuy2_0, (i << 1), dst);\n\n\tvec_st(v_yuy2_1, (i << 1) + 16, dst);\n\n\tvec_st(v_yuy2_2, (i << 1) + 32, dst);\n\n\tvec_st(v_yuy2_3, (i << 1) + 48, dst);\n\n      }\n\n      if (i < width) {\n\n\tconst unsigned int j = i >> 1;\n\n\tvector unsigned char v_y1 = vec_ld(i, ysrc);\n\n\tvector unsigned char v_u = vec_ld(j, usrc);\n\n\tvector unsigned char v_v = vec_ld(j, vsrc);\n\n\tvector unsigned char v_uv_a = vec_mergeh(v_u, v_v);\n\n\tvector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);\n\n\tvec_st(v_yuy2_0, (i << 1), dst);\n\n\tvec_st(v_yuy2_1, (i << 1) + 16, dst);\n\n      }\n\n      if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) )\n\n\t{\n\n\t  usrc += chromStride;\n\n\t  vsrc += chromStride;\n\n\t}\n\n      ysrc += lumStride;\n\n      dst += dstStride;\n\n    }\n\n\n\n  return srcSliceH;\n\n}\n", "idx": 9846, "substitutes": {"c": ["g", "ctx", "f", "cit", "xc", "k", "cs", "nc", "ce", "vc", "ca", "d", "p", "b", "cy", "cp", "cm", "cu", "ct", "con", "ctrl", "cc", "C", "dc", "ch", "ac", "t", "l", "ci", "cf", "sc", "conn", "cr", "w", "m", "oc", "e", "n", "cn", "lc", "mc", "s", "cd"], "src": ["rect", "sur", "support", "scl", "dest", "ctx", "usc", "buf", "sel", "sub", "rob", "sq", "conv", "sup", "sit", "sr", "sb", "rc", "config", "rss", "cur", "input", "http", "loc", "split", "st", "ssl", "filename", "url", "sl", "rb", "impl", "iv", "cv", "chrom", "source", "attr", "req", "sc", "sn", "secure", "scene", "uc", "rib", "inst", "stab"], "srcStride": ["srcRestri", "srcStOverride", "srcScro", " srcstro", " srcstride", "srcScride", "sourceRestride", " srcStide", "srcstrip", "srcStyOverride", "srcstride", " srcRestrip", "srcScrip", "srcStrip", "srcCuride", " srcRestOverride", "srcStrid", "sourceStide", "srcstro", "srcShride", "srcStri", "sourceStride", " srcstri", " srcStOverride", "srcRestro", "srcRestOverride", "sourceRestide", "srcScri", " srcStro", "srcRestide", " srcstrip", "srcCurride", "srcStyride", "srcStyide", " srcStri", "srcCurrip", "srcCurrid", " srcRestride", "srcRestrip", " srcRestide", "srcShrip", "srcStide", "sourceRestrid", "srcStro", " srcStrip", "srcShOverride", "srcShide", "sourceStrip", "srcRestride", "srcstri", "sourceRestrip", "sourceStrid", "srcRestrid", "srcStyrip"], "srcSliceY": ["srcSlueW", "srcSlueH", "srcPlaceX", "srcPlICEY", "srcPlICEW", "srcPlaceY", "srcSlineW", "srcSliceB", "srcPlaceH", "srcSlueY", "srcSlICEW", "srcSlICEH", "srcSlaceY", "srcSliceW", "srcPliceB", "srcSlueB", "srcSlineH", "srcSlaceB", "srcSlineY", "srcPliceH", "srcPlICEB", "srcSlineX", "srcSlaceW", "srcSlaceH", "srcPlICEH", "srcSlaceX", "srcSlICEB", "srcSlICEX", "srcPliceY", "srcSliceX", "srcPlaceW", "srcPliceW", "srcSlICEY", "srcPliceX"], "srcSliceH": ["srcSlueW", "srcSlueH", "srcSliceN", "srcPlaceX", "srcSlenseY", "srcSlineW", "srcPlaceY", "srcPlICEW", "srcSlueN", "srcPlaceH", "srcSlICEh", "srcPlICEN", "srcSliceh", "srcPlaceh", "srcSlICEW", "srcSlICEH", "srcPliceh", "srcSlaceh", "srcSlaceY", "srcSlICEN", "srcSliceW", "srcPlICEh", "srcSlenseh", "srcSlineH", "srcSlaseW", "srcSlineY", "srcSlaseH", "srcPliceH", "srcSlineX", "srcSlaceW", "srcSlaceH", "srcSlaceX", "srcSlaceN", "srcPlICEH", "srcSlueh", "srcSlICEX", "srcPliceY", "srcSliceX", "srcPliceN", "srcSlenseH", "srcPlaceW", "srcPliceW", "srcSlICEY", "srcPliceX", "srcSlaseY", "srcSlenseW", "srcSlaseN"], "dstParam": ["DscMode", "dspPar", "dscParameter", "instPar", "dscPar", "inblParameter", "inblMode", "destParameter", "DstParameter", "dscMode", "dspParameter", "destParam", "inblPar", "dspParam", "DscPar", "dblMode", "dblParam", "DstParam", "dblParameter", "DstMode", "dspMode", "dstMode", "inblParam", "DscParameter", "destPar", "dstPar", "instParam", "dstParameter", "dscParam", "instParameter", "instMode", "DstPar", "dblPar", "DscParam", "destMode"], "dstStride_a": ["dstStrite_o", "dstStri_m", "dstStrideJp", "dstStrite2A", "dstStride_A", "dstStride_e", "dstStrite_p", "dstStrite2a", "dstStrite2o", "dstStrite_c", "dstStrideJc", "dstStrideJe", "dstStride2o", "dstStride_p", "dstStride4p", "dstStride2A", "dstStride_c", "dstStri_e", "dstStrite_e", "dstStride2p", "dstStride2a", "dstStride_o", "dstStride_m", "dstStriteJa", "dstStrite2p", "dstStrite_A", "dstStride4o", "dstStrideJa", "dstStri_a", "dstStride4a", "dstStride4A", "dstStrite_a", "dstStriteJe", "dstStriteJc", "dstStriteJp"], "dst": ["dsc", "Dst", " dST", "adcr", "adST", "adst", " dcr", "dcr", "lst", "dsrc", " dsrc", "lcr", "lsrc", "dST", "adsc", " dsc", "lsc", "DST", "adsrc", "Dsrc", "Dsc"], "ysrc": ["yslc", "sRC", "ssrc", "iessrc", "ysRC", "ysource", "dslc", "iesusc", "rysrc", "ynsrc", "ynconfig", "ysconfig", "gesource", "ysroc", "dssrc", "sysrc", "lsRC", "yssrc", "ryslc", "ryssrc", "dsource", "lsource", "ansrec", "sysource", "yspc", "iesource", "anssrc", "pssrc", "rysusc", "dsrc", "pspc", "ansrc", "gessrc", "ynource", "rsRC", "sysroc", "source", "ysrec", "lsrc", "anspc", "iesconfig", "iesrc", "dsRC", "gesrc", "ieslc", "dspc", "syssrc", "geslc", "dsusc", "psrc", "lssrc", "sysconfig", "rsrc", "ynrc", "dsroc", "sysRC", "rssrc", "dsrec", "psrec", "ysusc", "rsroc"], "usrc": ["usRC", "USlc", "usr", "USrb", "russrc", "sRC", "ssrc", "msloc", "srt", "unsrc", "rusrc", "uslc", "msrc", "unsrb", "ssource", "rusdc", "usrt", " ussrc", "assrc", " usfc", "mssrc", "USrt", "unslc", " usr", "ssdc", "sfc", "asource", "usfc", " usdc", "ussrc", "usource", "msfc", "usrb", "srb", "source", "rusr", "unsrt", "sloc", "asRC", "slc", " usloc", "USrc", "ssr", "sssrc", "usloc", "asrc", "ssRC", "usdc"], "vsrc": ["hdest", "ssrc", "ddest", "ssource", " vconst", "hconst", "lconst", "vconst", "vsource", "dsource", "lloc", " vdest", "hsrc", "dsrc", "sdest", "drc", "vrc", "vdest", "ldest", "lsrc", "svrc", "vloc", "svdest", "svsrc", "hloc", "svsource", " vloc"], "y": ["zy", "ey", "yd", "yy", "type", "yo", "iy", "ky", "ny", "ya", "asy", "ies", "yi", "h", "p", "dy", "hy", "vy", "gy", "cy", "b", "year", "j", "yr", "z", " cy", "ye", "ay", "sy", "t", "o", "sky", "ym", "ady", "ry", "w", "m", "ty", "yt", "n", "Y", " Y", "py", "oy", "x"], "i": ["ii", "ni", "li", "uri", "f", "id", "phi", "I", "k", "ip", "mi", "fi", "yi", "iu", "ini", "multi", "h", "ji", "p", "ri", "ani", "si", "b", "pi", "io", "uli", "j", "gi", "ie", "ami", "di", "v", "xi", "bi", "zi", "z", "qi", "ti", "ui", "ik", "o", "l", "ci", "ia", "u", "index", "start", "m", "e", "n", "init", "ai", "iw", "mini", "eni", "vi", "in", "x", "ix", "it"]}}
{"project": "qemu", "commit_id": "338c858c946017cd3ec8c2be06d817e001d94bc3", "target": 0, "func": "void cpu_loop(CPUAlphaState *env)\n\n{\n\n    CPUState *cs = CPU(alpha_env_get_cpu(env));\n\n    int trapnr;\n\n    target_siginfo_t info;\n\n    abi_long sysret;\n\n\n\n    while (1) {\n\n        cpu_exec_start(cs);\n\n        trapnr = cpu_alpha_exec(cs);\n\n        cpu_exec_end(cs);\n\n\n\n        /* All of the traps imply a transition through PALcode, which\n\n           implies an REI instruction has been executed.  Which means\n\n           that the intr_flag should be cleared.  */\n\n        env->intr_flag = 0;\n\n\n\n        switch (trapnr) {\n\n        case EXCP_RESET:\n\n            fprintf(stderr, \"Reset requested. Exit\\n\");\n\n            exit(EXIT_FAILURE);\n\n            break;\n\n        case EXCP_MCHK:\n\n            fprintf(stderr, \"Machine check exception. Exit\\n\");\n\n            exit(EXIT_FAILURE);\n\n            break;\n\n        case EXCP_SMP_INTERRUPT:\n\n        case EXCP_CLK_INTERRUPT:\n\n        case EXCP_DEV_INTERRUPT:\n\n            fprintf(stderr, \"External interrupt. Exit\\n\");\n\n            exit(EXIT_FAILURE);\n\n            break;\n\n        case EXCP_MMFAULT:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGSEGV;\n\n            info.si_errno = 0;\n\n            info.si_code = (page_get_flags(env->trap_arg0) & PAGE_VALID\n\n                            ? TARGET_SEGV_ACCERR : TARGET_SEGV_MAPERR);\n\n            info._sifields._sigfault._addr = env->trap_arg0;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_UNALIGN:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGBUS;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_BUS_ADRALN;\n\n            info._sifields._sigfault._addr = env->trap_arg0;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_OPCDEC:\n\n        do_sigill:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_ILL_ILLOPC;\n\n            info._sifields._sigfault._addr = env->pc;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_ARITH:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGFPE;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_FPE_FLTINV;\n\n            info._sifields._sigfault._addr = env->pc;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_FEN:\n\n            /* No-op.  Linux simply re-enables the FPU.  */\n\n            break;\n\n        case EXCP_CALL_PAL:\n\n            env->lock_addr = -1;\n\n            switch (env->error_code) {\n\n            case 0x80:\n\n                /* BPT */\n\n                info.si_signo = TARGET_SIGTRAP;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_TRAP_BRKPT;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            case 0x81:\n\n                /* BUGCHK */\n\n                info.si_signo = TARGET_SIGTRAP;\n\n                info.si_errno = 0;\n\n                info.si_code = 0;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            case 0x83:\n\n                /* CALLSYS */\n\n                trapnr = env->ir[IR_V0];\n\n                sysret = do_syscall(env, trapnr,\n\n                                    env->ir[IR_A0], env->ir[IR_A1],\n\n                                    env->ir[IR_A2], env->ir[IR_A3],\n\n                                    env->ir[IR_A4], env->ir[IR_A5],\n\n                                    0, 0);\n\n                if (trapnr == TARGET_NR_sigreturn\n\n                    || trapnr == TARGET_NR_rt_sigreturn) {\n\n                    break;\n\n                }\n\n                /* Syscall writes 0 to V0 to bypass error check, similar\n\n                   to how this is handled internal to Linux kernel.\n\n                   (Ab)use trapnr temporarily as boolean indicating error.  */\n\n                trapnr = (env->ir[IR_V0] != 0 && sysret < 0);\n\n                env->ir[IR_V0] = (trapnr ? -sysret : sysret);\n\n                env->ir[IR_A3] = trapnr;\n\n                break;\n\n            case 0x86:\n\n                /* IMB */\n\n                /* ??? We can probably elide the code using page_unprotect\n\n                   that is checking for self-modifying code.  Instead we\n\n                   could simply call tb_flush here.  Until we work out the\n\n                   changes required to turn off the extra write protection,\n\n                   this can be a no-op.  */\n\n                break;\n\n            case 0x9E:\n\n                /* RDUNIQUE */\n\n                /* Handled in the translator for usermode.  */\n\n                abort();\n\n            case 0x9F:\n\n                /* WRUNIQUE */\n\n                /* Handled in the translator for usermode.  */\n\n                abort();\n\n            case 0xAA:\n\n                /* GENTRAP */\n\n                info.si_signo = TARGET_SIGFPE;\n\n                switch (env->ir[IR_A0]) {\n\n                case TARGET_GEN_INTOVF:\n\n                    info.si_code = TARGET_FPE_INTOVF;\n\n                    break;\n\n                case TARGET_GEN_INTDIV:\n\n                    info.si_code = TARGET_FPE_INTDIV;\n\n                    break;\n\n                case TARGET_GEN_FLTOVF:\n\n                    info.si_code = TARGET_FPE_FLTOVF;\n\n                    break;\n\n                case TARGET_GEN_FLTUND:\n\n                    info.si_code = TARGET_FPE_FLTUND;\n\n                    break;\n\n                case TARGET_GEN_FLTINV:\n\n                    info.si_code = TARGET_FPE_FLTINV;\n\n                    break;\n\n                case TARGET_GEN_FLTINE:\n\n                    info.si_code = TARGET_FPE_FLTRES;\n\n                    break;\n\n                case TARGET_GEN_ROPRAND:\n\n                    info.si_code = 0;\n\n                    break;\n\n                default:\n\n                    info.si_signo = TARGET_SIGTRAP;\n\n                    info.si_code = 0;\n\n                    break;\n\n                }\n\n                info.si_errno = 0;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            default:\n\n                goto do_sigill;\n\n            }\n\n            break;\n\n        case EXCP_DEBUG:\n\n            info.si_signo = gdb_handlesig(cs, TARGET_SIGTRAP);\n\n            if (info.si_signo) {\n\n                env->lock_addr = -1;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_TRAP_BRKPT;\n\n                queue_signal(env, info.si_signo, &info);\n\n            }\n\n            break;\n\n        case EXCP_STL_C:\n\n        case EXCP_STQ_C:\n\n            do_store_exclusive(env, env->error_code, trapnr - EXCP_STL_C);\n\n            break;\n\n        case EXCP_INTERRUPT:\n\n            /* Just indicate that signals should be handled asap.  */\n\n            break;\n\n        default:\n\n            printf (\"Unhandled trap: 0x%x\\n\", trapnr);\n\n            cpu_dump_state(cs, stderr, fprintf, 0);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n        process_pending_signals (env);\n\n    }\n\n}\n", "idx": 9864, "substitutes": {"env": ["server", "et", "keeper", "loader", "nc", "ea", "exc", "ev", "console", "iss", "settings", "here", "environment", "esi", "forge", "org", "cookie", "inet", "e", "init", "ec", "eni", "extra", "vs", "dat", "fen", "np", "site", "api", "db", "enc", "ace", "img", "end", "viron", "icon", "conn", "manager", "energy", "dict", "eve", "inf", "engine", "en", "event", "config", "cfg", "v", "que", "inv", "her", "cf", "py", "erv", "exe", "oa", "args", "eng", "output", "ce", "ini", "eu", "qt", "cb", "net", "ext", "context", "core", "cv", "entry", "gui", "conf", "obj", "fg", "cache"], "cs": ["cas", "ctx", "args", "ls", "nc", "bc", "ys", "c", "pc", "ks", "ins", "rc", "vs", "ck", "ds", "fs", "cp", "acs", "CS", "core", "cks", "bs", "cc", "ns", "spec", "ac", "css", "ras", "ced", "dc", "qs", "ci", "conn", "sc", "cf", "cus", "sync", "gs", "sys", "cn", "rs", "lc", "ec", "sk", "ces", "js", "Cs"], "trapnr": ["rapnl", "rapNR", "rrnl", " trapNR", "rrnw", "tapnos", "tapradius", " trapnw", "trapradius", "trapnl", "impradius", " trapradius", "trapnos", "rrnr", "triprf", "traprf", "trapnw", "trapNR", "rapnw", "tapnl", "tapNR", "tripnos", "taprf", "impnr", "rrNR", "tripnr", " traprf", "impNR", " trapnl", "impnl", "rapnr", "tapnr", "tripNR", " trapnos"], "info": ["die", "iso", "thin", "tf", "service", "comment", "success", "i", "ami", "ui", "init", "join", "fw", "txt", "extra", "alias", "ii", "id", "api", "update", "home", "ignore", "result", "off", "http", "fs", "frame", "end", "hi", "op", "error", "link", "conn", "information", "manager", "ok", "utils", "notice", "f", "diff", "now", "inf", "how", "afi", "event", "config", "app", "gi", "source", "fo", "index", "start", "util", "py", "bug", "where", "args", "type", "hand", "state", "fi", "Info", "is", "help", "new", "si", "inner", "INFO", "image", "entry", "opt", "def", "conf", "follow", "obj", "show", "data", "check"], "sysret": ["sysRet", "_exit", "_Ret", "systemexit", "systemresult", "Sysret", "systemret", "SysRet", "Sysresult", "Sysexit", "systemRet", "_ret", "_result", "sysresult", "sysexit"]}}
{"project": "qemu", "commit_id": "e70377dfa4bbc2e101066ca35675bed4129c5a8c", "target": 0, "func": "static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)\n\n{\n\n    int i;\n\n    S390PCIBusDevice *pbdev;\n\n    S390pciState *s = s390_get_phb();\n\n\n\n    if (!target) {\n\n        return NULL;\n\n    }\n\n\n\n    for (i = 0; i < PCI_SLOT_MAX; i++) {\n\n        pbdev = s->pbdev[i];\n\n        if (!pbdev) {\n\n            continue;\n\n        }\n\n\n\n        if (!strcmp(pbdev->target, target)) {\n\n            return pbdev;\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 9870, "substitutes": {"target": ["transform", "remote", "support", "to", "arget", "version", "timeout", "required", "compatible", "prefix", "type", "owner", "match", "format", "id", "device", "path", "weight", "blank", "ip", "host", "tag", "module", "template", "route", "method", "patch", "expected", "offset", "content", "boot", "scope", "range", "direction", "project", "flat", "domain", "core", "address", "parent", "client", "t", "source", "platform", "resource", "peer", "brand", "component", "current", "base", "goal", "port", "unit", "token", "value", "Target", "nt", "root", "name", "window", "tail", "object", "it"], "i": ["ii", "ni", "li", "uri", "hi", "id", "phi", "I", "k", "mu", "ip", "oi", "y", "c", "yi", "iu", "ini", "d", "multi", "ri", "p", "si", "z", "b", "pi", "io", "xi", "j", "ori", "inner", "gi", "key", "in", "v", "di", "ti", "bi", "zi", "qi", "t", "ui", "o", "l", "ci", "u", "index", "m", "e", "n", "info", "ai", "lc", "eni", "x", "ix"], "pbdev": ["bpver", "bdi", "pdef", "bdev", "pconf", "lpdevice", "lpdiff", "rbdef", "bhpriv", "rbdevice", "cbdev", "pcdef", "mpdevice", "pdev", "lppriv", "pbadv", "lpver", "lpdiv", "bhdev", "bpdef", "lpdev", "bbev", "bbDev", "lpadv", "cbapp", "bpdevice", "bpconf", "lpDev", "pdevice", "bpdev", "bbdev", "bpdiff", "bver", "pbpriv", "lbdevice", "ppver", "bpapp", "pcdev", "lpev", "bdiv", "ppdiv", "wbdev", "ppdi", "lpdi", "wbdevice", "cbver", "pbver", "lbdef", "wbdef", "pbapp", "pbDev", "pbdiv", "pbdata", "rbdev", "bhdiff", "mpapp", "mpver", "pbdef", "bpev", "pbev", "pbconf", "pbdi", "lbdata", "lbdev", "pbdevice", "pcdevice", "bpDev", "rbdata", "pcconf", "cbdevice", "bppriv", "mpdev", "bhdevice", "bbadv", "wbdata", "ppdev", "bpadv", "pbdiff"], "s": ["g", "f", "ls", "ss", "states", "sq", "c", "is", "a", "ins", "d", "services", "p", "si", "S", "ds", "b", "ssl", "sis", "sl", "ns", "v", "spec", "o", "t", "ps", "ses", "u", "gs", "w", "m", "south", "e", "sys", "rs", "sa", "stats"]}}
{"project": "FFmpeg", "commit_id": "c95fefa0420be9cc0f09a95041acf11114aaacd0", "target": 0, "func": "static void cin_decode_lzss(const unsigned char *src, int src_size, unsigned char *dst, int dst_size)\n\n{\n\n    uint16_t cmd;\n\n    int i, sz, offset, code;\n\n    unsigned char *dst_end = dst + dst_size;\n\n    const unsigned char *src_end = src + src_size;\n\n\n\n    while (src < src_end && dst < dst_end) {\n\n        code = *src++;\n\n        for (i = 0; i < 8 && src < src_end && dst < dst_end; ++i) {\n\n            if (code & (1 << i)) {\n\n                *dst++ = *src++;\n\n            } else {\n\n                cmd = AV_RL16(src); src += 2;\n\n                offset = cmd >> 4;\n\n                sz = (cmd & 0xF) + 2;\n\n                /* don't use memcpy/memmove here as the decoding routine (ab)uses */\n\n                /* buffer overlappings to repeat bytes in the destination */\n\n                sz = FFMIN(sz, dst_end - dst);\n\n                while (sz--) {\n\n                    *dst = *(dst - offset - 1);\n\n                    ++dst;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 9896, "substitutes": {"src": ["sur", "ctr", "prop", "uri", "dest", "setup", "ctx", "mode", "ource", "buf", "proc", "comp", "supp", "inf", "sel", "sub", "rob", "seq", "sq", "conv", "stat", "bc", "sup", "dist", "cmp", "sr", "sb", "rc", "config", "ser", "cur", "cb", "loc", "seed", "st", "ssl", "filename", "img", "url", "gb", "rb", "sl", "iv", "ruby", "spec", "address", "ch", "tmp", "length", "source", "chrom", "req", "attr", "sc", "start", "sync", "desc", "cod", "sys", "rs", "lc", "uc", "rest", "sec", "rib", "send", "inst", "slice"], "src_size": ["src_scale", "rc_scale", " src_start", " src_scale", "src_start", "rc_ize", "rc_end", "rc_size", "src_ize"], "dst": ["dsc", "ndrc", "dest", "Dst", "fst", " dST", "ddest", " dest", "dedst", "dedest", "idsc", " drc", "Drest", "idsts", "drest", "ddst", "ndest", "idest", " drest", "dssc", "dedsts", "edST", "ndsc", "adst", "fsc", "ddsc", "madrest", "Dest", "adrc", "madst", "dost", "Dsts", "dsst", " dsts", "adost", "edst", "madest", "pdest", "drc", "fST", "pdsc", "madsts", "edost", "pdrc", "fsts", "dST", "dsts", " dost", "adsc", "edsc", "dssts", " dsc", "pdst", "DST", "ndst", "dsest", "ddrc", "dedsc", "Drc", "Dost", "adest", "idst", "idost", "Dsc"], "dst_size": ["dsts_end", "dsts_size", "dsc_size", "dsc_start", "dst_scale", "dst_min", "dsts_start", "dsc_scale", "dst_start", "dsts_min", "dsc_end"], "cmd": ["ctr", "dict", "ack", "ctx", "mode", "id", "buf", "comp", "dom", "seq", "md", "c", "cmp", "node", "config", "cat", "cb", "cur", "ck", "gz", "cp", "cm", "ct", "ctrl", "gen", "grad", "cfg", "cc", "dc", "op", "ind", "opt", "mac", "command", "req", "head", "acc", "cod", "func", "oc", "cookie", "init", "child", "msg", "ctl", "Cmd", "uc", "count", "cd", "acl"], "i": ["ii", "ti", "pos", "li", "f", "at", "I", "k", "ip", "oi", "adi", "c", "iu", "a", "ini", "udi", "d", "ei", "h", "ji", "p", "ri", "si", "b", "di", "pi", "xi", "j", "ori", "gi", "end", "ie", "z", "v", "in", "zi", "bi", "ind", "r", "ui", "qi", "o", "t", "l", "ci", "start", "index", "u", "m", "e", "n", "info", "ai", "s", "eni", "count", "x"], "sz": ["szi", "gsz", " sx", "Szn", "aszi", "aszip", "Sce", "psz", "gszen", "Sz", "Szi", " szip", "szn", "sq", "Sx", "sze", "psx", " szi", "gsx", "dsz", "pszen", "wszn", "asz", " szen", "wszen", "sx", "dsx", "sce", "wsz", "pszip", "aszen", " szn", "gszip", "Sze", " sce", "asce", "dsq", "asze", "Sq", "wsze", " sq", "Szen", "dsze", "szip", "Szip", "szen", " sze", "aszn"], "offset": ["padding", "shift", "pos", "size", "mode", "limit", "ref", "addr", "seq", "len", "c", "off", "field", "slot", "order", "loc", "range", "ext", "position", "end", "Offset", "part", "entry", "length", "o", "error", "start", "index", "pad", "origin", "port", "nt", "alt", "count", "alias", "align", "slice", "line"], "code": ["ack", "mode", "id", "comment", "zip", "nc", "fi", "comp", "addr", "seq", "c", "Code", "cmp", "co", "rage", "config", "cat", "cb", "content", "ck", "loc", "range", "gen", "rule", "cc", "charge", "ac", "codes", "length", "error", "call", "coded", "sync", "ci", "control", "acc", "cf", "conn", "cod", "func", "ec", "sec", "count", "cd", "check"], "dst_end": ["dstMstart", "dsc_ended", "dsts_end", "dstMend", "dST_End", "dsc_start", "dst_ended", "dST_END", "dst_End", "dst_END", "dsts_line", "dst0ends", "dsts_ends", "dsts_start", "dst0line", "dST_end", "dstMEND", "dst0start", "dsc_id", "dst0end", "dstMEnd", "dst_ends", "dst_start", "dst_id", "dst_line", "dsc_end", "dST_start"], "src_end": [" src_edge", " src_stop", "src00edge", "src0size", "rc_ends", " src_start", "src0ends", "src_edge", "src_start", "src_End", "src0start", "src0end", "rc_start", "src_ends", "rc_end", "src_stop", "src00stop", " src_End", "rc_size", "src00start", "src00end"]}}
{"project": "FFmpeg", "commit_id": "84f0aba18dc8815c5cd408238909e4dc8b60684f", "target": 1, "func": "ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,\n\n                  void *priv_data, RTPDynamicProtocolHandler *handler)\n\n{\n\n    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->ic = ic;\n\n    s->streams = &ic->streams[first_stream_of_set_idx];\n\n    do {\n\n        s->n_streams++;\n\n    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&\n\n             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);\n\n    s->prev_set_id    = -1;\n\n    s->prev_stream_id = -1;\n\n    s->prev_timestamp = -1;\n\n    s->parse_packet = handler->parse_packet;\n\n    s->dynamic_protocol_context = priv_data;\n\n\n\n    return s;\n\n}\n", "idx": 9913, "substitutes": {"s": ["ctx", "sym", "service", "cs", "self", "c", "i", "ks", "d", "settings", "b", "erences", "hs", "css", "gs", "w", "sn", "e", "comments", "rs", "js", "os", "its", "ls", "ss", "ies", "sq", "ins", "sb", "rows", "http", "S", "session", "ds", "ic", "ssl", "fs", "ms", "o", "ses", "qs", "sc", "er", "f", "xs", "y", "an", "sg", "sl", "bs", "in", "r", "ps", "l", "u", "sync", "sys", "su", "sk", "x", "ics", "g", "ess", "events", "sports", "is", "new", "es", "p", "ts", "si", "full", "ns", "spec", "us", "t", "ures", "conf", "n", "sets", "ops", "aws"], "n_streams": ["n_feedd", "n__streaming", "n_threadviews", "n_threadings", "n_hosts", "n_threaded", "n_feedflows", "n_swls", "n_streamings", "n__threaded", "n__threading", "n_feeds", "n_swflows", "n_lengths", "n__streams", "n_streamed", "n__streamed", "n_streaming", "n_threading", "n_hostings", "n_hosted", "n_lengthed", "n_streamviews", "n_hostd", "n_lengthing", "n__streamviews", "n_structing", "n_feedls", "n_streamls", "n_streamflows", "n_lengthflows", "n_streamd", "n__threads", "n_structs", "n_threadd", "n_threads", "n_structviews", "n__threadviews", "n_swd", "n__streamings", "n_lengthviews", "n_sws", "n__threadings", "n_lengthings", "n__streamd", "n__threadd", "n_lengthls", "n_structd", "n_lengthd"]}}
{"project": "qemu", "commit_id": "ab0997e0afdcb272fd04784a280b2df46b0c759f", "target": 1, "func": "static int qcow2_co_writev(BlockDriverState *bs,\n\n                           int64_t sector_num,\n\n                           int remaining_sectors,\n\n                           QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int n_end;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    QCowL2Meta l2meta;\n\n    uint64_t cluster_offset;\n\n    QEMUIOVector hd_qiov;\n\n    uint64_t bytes_done = 0;\n\n    uint8_t *cluster_data = NULL;\n\n\n\n    l2meta.nb_clusters = 0;\n\n    qemu_co_queue_init(&l2meta.dependent_requests);\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n_end = index_in_cluster + remaining_sectors;\n\n        if (s->crypt_method &&\n\n            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {\n\n            n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_offset(bs, sector_num << 9,\n\n            index_in_cluster, n_end, &cur_nr_sectors, &l2meta);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        cluster_offset = l2meta.cluster_offset;\n\n        assert((cluster_offset & 511) == 0);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (s->crypt_method) {\n\n            if (!cluster_data) {\n\n                cluster_data = g_malloc0(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                                 s->cluster_size);\n\n            }\n\n\n\n            assert(hd_qiov.size <=\n\n                   QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            qemu_iovec_to_buffer(&hd_qiov, cluster_data);\n\n\n\n            qcow2_encrypt_sectors(s, sector_num, cluster_data,\n\n                cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key);\n\n\n\n            qemu_iovec_reset(&hd_qiov);\n\n            qemu_iovec_add(&hd_qiov, cluster_data,\n\n                cur_nr_sectors * 512);\n\n        }\n\n\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             cur_nr_sectors, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_link_l2(bs, &l2meta);\n\n\n\n        run_dependent_requests(s, &l2meta);\n\n\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n\n\n\n    return ret;\n\n}", "idx": 9922, "substitutes": {"bs": ["bos", "os", "bis", "its", "cs", "ls", "ss", "bc", "BS", "pb", "is", "ks", "lb", "ins", "sb", "bl", "iss", "ds", "b", "bes", "fs", "fb", "outs", "bh", "gb", "ns", "bi", "us", "bb", "ps", "qs", "ses", "ab", "banks", "base", "bas", "lbs", "obs", "sa", "js", "vs"], "sector_num": ["section_count", "sectoralnum", "sectoralnumber", "section_name", "section_number", " sector_number", "sector_count", "sector_number", " sector_begin", "sectoralname", "sector_offset", "sector_dest", "section_offset", " sector_dest", "section_num", "sector_name", "sectoralcount", "sector_begin"], "remaining_sectors": ["remaining_keimeters", "remaining_seclements", "remaining_sesgment", "remaining_tegments", "remaining_sesges", "remaining_secges", "remaining_gections", "remaining_secctions", "remaining_teges", "remaining_secwards", "remaining_sections", "remaining_secimeters", "remaining_secgment", "remaining_gegments", "remaining_kewards", "remaining_segment", "remaining_sesgments", "remaining_SEgments", "remaining_gelements", "remaining_kegments", "remaining_secctors", "remaining_seimeters", "remaining_seges", "remaining_kectors", "remaining_Sewards", "remaining_tegment", "remaining_segments", "remaining_tectors", "remaining_SElements", "remaining_SEctions", "remaining_SEctors", "remaining_selements", "remaining_Segments", "remaining_gectors", "remaining_Sectors", "remaining_sewards", "remaining_secgments", "remaining_Seimeters", "remaining_sesctors"], "qiov": ["viewiol", "qtiov", "qiop", "quiop", "quios", " qimoto", "viewios", "quimoto", "quno", "qiol", "qtimoto", " qiop", " qoren", " qiol", "qimoto", "qtuno", " qdyl", " qios", "qunox", "quiol", "sqnox", "sqimoto", "viewiop", "quiov", " qnox", "quuno", "qdyl", "qios", "qudyl", "viewiov", "sqdyl", " quno", "qtoren", "qoren", "qnox", "quoren", "sqiov"], "s": ["sym", "service", "cs", "c", "d", "lines", "settings", "b", "sites", "words", "gs", "e", "comments", "js", "os", "bis", "site", "its", "ls", "ss", "params", "sb", "http", "S", "ds", "sie", "session", "fs", "ssl", "o", "ses", "qs", "submit", "set", "tests", "f", "parts", "uploads", "stat", "services", "sg", "secondary", "sl", "in", "r", "ps", "l", "sync", "admin", "sys", "su", "rates", "features", "g", "args", "state", "side", "states", "is", "multi", "comm", "es", "p", "ts", "si", "results", "full", "modules", "sis", "ns", "less", "spec", "t", "plugins", "m", "conf", "sets", "storage", "sa", "stats", "aws"], "index_in_cluster": ["index_in_plust", "index_in_laborum", "index_in_labuster", "index_in_chue", "index_in_clusters", "index_in_Clorum", "index_in_Cluration", "index_in_Cluster", "index_in_queue", "index_in_cliton", "index_in_Cliton", "index_in_acluration", "index_in_labure", "index_in_sclure", "index_in_clure", "index_in_acluster", "index_in_Clusters", "index_in_scluster", "index_in_sclusters", "index_in_queusters", "index_in_pluster", "index_in_clue", "index_in_sclust", "index_in_pluration", "index_in_clust", "index_in_sclorum", "index_in_labusters", "index_in_Clure", "index_in_queuster", "index_in_chorum", "index_in_acliton", "index_in_Clue", "index_in_plusters", "index_in_cluration", "index_in_queorum", "index_in_scluration", "index_in_pliton", "index_in_aclusters", "index_in_clorum", "index_in_chusters", "index_in_Clust", "index_in_chuster"], "n_end": ["namtail", "sn00end", "N_ended", "n__end", "in_offset", "in_after", "n_ended", "n_after", "ntherun", "ntheEND", "n_run", "sn_enter", " n_begin", "n_ends", "nambegin", "n__run", "sn2enter", "nappend", "sn_END", "n__ended", "nPend", "nappEND", "n00END", "in_end", " n_tail", "ntheend", "n_begin", "n__END", "n_END", "n_offset", "sn_post", "sn_max", "sn00END", "sn_ends", "sn00post", " n_END", "sn2ends", "nappbegin", "n2enter", "n00end", "n_tail", "n_max", "sn2end", "n00post", "nacoffset", "N_end", "N_END", "ntheended", "n2ends", "n_post", "namend", "namEND", "nPenter", "nPends", "sn_end", "napptail", "sn00max", "n2end", "nacafter", "n_enter", "nacend", "N_run", "n00max"], "ret": ["valid", "pass", "rets", "rt", "mer", "att", "match", "re", "RET", "ref", "rev", "ft", "result", "success", "seq", "len", "rc", "back", "fun", "lit", "j", "flag", "bit", "ext", "gt", "code", "prot", "num", "opt", "val", "det", "count", "conn", "hard", "arg", "fit", "nt", "res", "reg", "fin", "alt", "Ret", "hash", "bot", "let"], "cur_nr_sectors": ["cur_nr_peonents", "cur_nr_pections", "cur_nr_tecs", "cur_nr_pecs", "cur_nr_secctions", "cur_nr_vectors", "cur_nr_seccs", "cur_nr_pegments", "cur_nr_secgments", "cur_nr_seonents", "cur_nr_sections", "cur_nr_teonents", "cur_nr_tectors", "cur_nr_secs", "cur_nr_tegments", "cur_nr_vegments", "cur_nr_secctors", "cur_nr_vections", "cur_nr_vecs", "cur_nr_veonents", "cur_nr_pectors", "cur_nr_segments"], "l2meta": ["l1meta", "L2eta", "l4meta", "lc4metadata", "l4eta", "d1Meta", "l6Meta", "l2Meta", "l2data", "l1metadata", " l3Meta", "L1la", "l1eta", "l2la", "l3mo", "l1Meta", " l2Meta", "L1meta", "el4mo", "d1mini", " l3meta", "el2metadata", "l7meta", "l3meta", "lc4mo", "lc4meta", "l6mo", "l2mo", "lc4eta", "el4meta", "l2mini", "l_la", "l4mo", "L1Meta", "l1mo", "l6meta", " l3data", "L2Meta", "l3metadata", "l3eta", "d1meta", "d2mini", " l3metadata", "l1mini", "l7metadata", "l6metadata", "l4data", "lc2metadata", "el2mo", "l3mini", "l_Meta", "el2Meta", "l7mo", "d1metadata", "lc2mo", "l1la", "el4Meta", "l3Meta", "el4metadata", "l2metadata", "l4Meta", "L1eta", "l4metadata", " l2data", "l2eta", "L2la", "l_meta", "lc2eta", "l3data", " l2metadata", "l3la", "l1data", "d2Meta", "l_eta", "lc2meta", "d2metadata", "el2meta", "L2meta", "l7eta", "d2meta"], "cluster_offset": ["clayer_loc", "clard_prefix", "cluster_location", "clusterFnum", "clard_offset", "clayer_offset", "clusterEoffset", "cluster__data", "clorer_data", "clayer_location", "cluster_loc", "cluster_prefix", "clusterFalt", "clard__position", "cluster\u00b7offset", "cluster\u00b7prefix", "clorer_offset", "clusterFdata", "clayer_data", "cluster_length", "clard_num", "cluster_num", "clard_alt", "clard_data", "clusterFoffset", "clard__prefix", "clard_position", "clusterEloc", "clorer_length", "cluster_alt", "clard__data", "cluster\u00b7position", "cluster__position", "cluster__prefix", "cluster_position", "cluster__offset", "clusterEdata", "clard__offset", "cluster\u00b7data", "clusterElocation"], "hd_qiov": ["hd_questouri", "hd_uiov", "hd_sqiris", "hd_questiov", "hd_pushnox", "hd_quiris", "hd_qu\u00ef", "hd_viewiov", "hd_qliv", "hd_viewilo", "hd_qqirin", "hd_qilo", "hd_qimoto", "hd_quiov", "hd_qouri", "hd_qveh", "hd_qaimoto", "hd_qauin", "hd_sqimoto", "hd_Qimoto", "hd_q\u00ef", "hd_sqouri", "hd_pushirin", "hd_qqiov", "hd_questilo", "hd_Qliv", "hd_pushiov", "hd_sqnox", "hd_qirin", "hd_Quin", "hd_sqiov", "hd_sqirin", "hd_questveh", "hd_sqliv", "hd_questiris", "hd_questirin", "hd_qq\u00ef", "hd_viewiris", "hd_viewouri", "hd_sqilo", "hd_qaiov", "hd_qnox", "hd_u\u00ef", "hd_pushveh", "hd_qaliv", "hd_qqiris", "hd_qiris", "hd_squin", "hd_Qiov", "hd_quirin", "hd_quin", "hd_questnox", "hd_uiris", "hd_uirin", "hd_sqveh"], "cluster_data": ["cluster_sum", "clusteraclength", "clusters_results", "cluster2name", "clusterfoffset", "clusteracoffset", "cluster___results", "cluster_name", "clusteringdata", "cluster_DATA", "clusterflength", "clusters_DATA", "clancer_length", "clusterfDATA", "cluster2data", "cluster_size", "clancer_DATA", "clust_results", "clust_size", "clust_sum", "clusteringsum", "clusterfdata", "clusters_data", "clancer_offset", "cluster_results", "cluster___data", "clust_data", "cluster2results", "clusteracDATA", "clancer_data", "cluster_length", "cluster___name", "cluster2DATA", "clusters_name", "clusteringresults", "clusteringsize", "cluster___DATA", "clusteracdata"]}}
{"project": "qemu", "commit_id": "1e7398a140f7a6bd9f5a438e7ad0f1ef50990e25", "target": 1, "func": "int vhost_dev_init(struct vhost_dev *hdev, void *opaque,\n\n                   VhostBackendType backend_type, bool force)\n\n{\n\n    uint64_t features;\n\n    int i, r;\n\n\n\n    if (vhost_set_backend_type(hdev, backend_type) < 0) {\n\n        close((uintptr_t)opaque);\n\n        return -1;\n\n    }\n\n\n\n    if (hdev->vhost_ops->vhost_backend_init(hdev, opaque) < 0) {\n\n        close((uintptr_t)opaque);\n\n        return -errno;\n\n    }\n\n\n\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_OWNER, NULL);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_GET_FEATURES, &features);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < hdev->nvqs; ++i) {\n\n        r = vhost_virtqueue_init(hdev, hdev->vqs + i, i);\n\n        if (r < 0) {\n\n            goto fail_vq;\n\n        }\n\n    }\n\n    hdev->features = features;\n\n\n\n    hdev->memory_listener = (MemoryListener) {\n\n        .begin = vhost_begin,\n\n        .commit = vhost_commit,\n\n        .region_add = vhost_region_add,\n\n        .region_del = vhost_region_del,\n\n        .region_nop = vhost_region_nop,\n\n        .log_start = vhost_log_start,\n\n        .log_stop = vhost_log_stop,\n\n        .log_sync = vhost_log_sync,\n\n        .log_global_start = vhost_log_global_start,\n\n        .log_global_stop = vhost_log_global_stop,\n\n        .eventfd_add = vhost_eventfd_add,\n\n        .eventfd_del = vhost_eventfd_del,\n\n        .priority = 10\n\n    };\n\n    hdev->migration_blocker = NULL;\n\n    if (!(hdev->features & (0x1ULL << VHOST_F_LOG_ALL))) {\n\n        error_setg(&hdev->migration_blocker,\n\n                   \"Migration disabled: vhost lacks VHOST_F_LOG_ALL feature.\");\n\n        migrate_add_blocker(hdev->migration_blocker);\n\n    }\n\n    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));\n\n    hdev->n_mem_sections = 0;\n\n    hdev->mem_sections = NULL;\n\n    hdev->log = NULL;\n\n    hdev->log_size = 0;\n\n    hdev->log_enabled = false;\n\n    hdev->started = false;\n\n    hdev->memory_changed = false;\n\n    memory_listener_register(&hdev->memory_listener, &address_space_memory);\n\n    hdev->force = force;\n\n    return 0;\n\nfail_vq:\n\n    while (--i >= 0) {\n\n        vhost_virtqueue_cleanup(hdev->vqs + i);\n\n    }\n\nfail:\n\n    r = -errno;\n\n    hdev->vhost_ops->vhost_backend_cleanup(hdev);\n\n    return r;\n\n}\n", "idx": 9929, "substitutes": {"hdev": ["hconn", "capp", "ihdev", " hhost", "vhost", "hdevelopment", "rhhost", "pdef", " hpad", "hdd", "rhdevice", "pcomment", "ghdev", "rhserial", "hev", "hdc", "hdi", " hdriver", " hdom", "pdev", "ghdiv", "workdriver", "shdd", " hdd", " hde", "uhdevice", "hhhost", "hwdata", "ihdevelopment", "hwrad", " happ", "hhost", "hdiv", "hrdevice", "khdc", "hrev", "rhdevelopment", " hdc", "hdebug", "vserial", "vev", "hdie", " hdevelopment", "vpad", "ghapp", "uhhost", "ohdebug", "khdev", "shdev", "hserial", "vdevelopment", "hmhost", "hpad", "hmdev", "happ", "ohhost", "shdc", "vconn", "fdevice", "cdevice", "rhdev", "rhdiv", "hrga", " hdef", "ihdiv", "pdevice", "vdi", "hdom", "hhdev", " hdiv", "hrdiv", "hlod", "lapp", " hev", " hga", "workdiv", "ghdevelopment", "hga", "khdi", "vdev", "fdef", "vdc", " hrad", "ohcomment", "rhdef", " hdi", "hcomment", "workdi", "shod", "rhdriver", "vdie", "zhdev", "hod", "hdata", "workdev", "cdef", "hhdevice", " hdevice", "ldef", "rhdom", "hwod", "hlrad", "fga", "fdev", "ihapp", "zhde", "hdef", "ohdef", "zhpad", "ohdevelopment", "shev", "hldev", "shconn", "hde", " hdata", " hcomment", " hserial", " hconn", "hrdev", "hrhost", "hdevice", "hrad", "fev", "rhdi", "vde", "rhdd", " hdebug", "hhdiv", "ohdie", "shdom", "hldata", "ohdev", "rhev", "khhost", "ohdevice", "zhdevice", "hwdev", "uhdev", "rhdc", "cdev", "vdevice", "hdriver", "ldevice", "fapp", "rhdie", "uhdebug", " hod", "ldev", "rhapp", "vod", "hmod"], "opaque": ["operaco", "cataque", "ospaco", "ospaque", "opacity", "opbuffer", " opbuffer", " opaco", "ospaques", " opec", " opatinum", "catacity", "ipacity", "ompaques", "ompacity", " opacity", "catacle", "ompaque", "Opaco", "Opacity", "ospacity", "ipaque", " oponymous", "Opaque", "ipbuffer", "opaco", "operacle", "osponymous", "opaques", "iponymous", "ompaco", "catec", "Opatinum", "operatinum", "opatinum", "operaques", "operaque", "operacity", "opacle", "ospbuffer", "operec", "oponymous", " opacle", "opec"], "backend_type": ["backender_name", "backend_name", "backender_types", "backend_size", "backender_class", "backender_size", "backend_class", "backender_type", "backend_types"], "force": ["flags", "mode", "ce", "Force", " erase", "write", "cache", " mode", "p", " allow", " alpha", "use", "driver", " ignore", "native", "op", " implicit", "forced", "allow", " forced", "secure", "util", "slave", "gc", "depth", "ops", "enable"], "features": ["rt", "c", "properties", "settings", "Features", "rx", "ints", "rs", "feat", "performance", "requires", "os", "fn", "fixes", "result", "feature", "params", "rows", "options", " f", "reports", "classes", "rules", "tags", "nets", "s", "issues", "forms", "ports", "flags", "tests", "ATURES", "bugs", "format", "fields", "afi", "services", "config", "ants", "details", "ips", "fc", "mac", "products", "eatures", "errors", "lib", "g", "faces", "args", "events", "devices", "fi", "items", "new", "facts", "results", "protection", "files", "includes", "modules", "ac", "models", "ffff", "plugins", "resources", "license", "n", "versions", "bits", "effects", "stats", "types", "ops"], "i": ["ii", "ni", "li", "uri", "im", "type", "f", "id", "iq", "phi", "I", "k", "err", "ip", "mi", "fi", "y", "c", "yi", "iu", "ini", "d", "ri", "p", "si", "z", "b", "pi", "io", "j", "gi", "ie", "di", "v", "ti", "bi", "zi", "xi", "qi", "t", "o", "ui", "l", "ci", "u", "index", "start", "m", "e", "n", "ai", "eni", "x", "ix", "it"], "r": ["g", "fr", "nor", "rt", "f", "nr", "re", "hr", "k", "err", "ur", "result", "rg", "c", "mr", "sr", "d", "ru", "rc", "h", "lr", "p", "dr", "pr", "rd", "ner", "rl", "arr", "rf", "b", "function", "R", "ar", "run", "rb", "v", "t", "o", "kr", "br", "l", "q", "ir", "u", "rec", "cr", "m", "e", "n", "er", "rs", "rr", "rh", "or", "rar"]}}
{"project": "FFmpeg", "commit_id": "2fed05f53a881b64a02de7a324d67d8c029c6cf1", "target": 1, "func": "int ff_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        int r, g, b;\n\n\n\n        switch (pix_fmt) {\n\n        case AV_PIX_FMT_RGB8:\n\n            r = (i>>5    )*36;\n\n            g = ((i>>2)&7)*36;\n\n            b = (i&3     )*85;\n\n            break;\n\n        case AV_PIX_FMT_BGR8:\n\n            b = (i>>6    )*85;\n\n            g = ((i>>3)&7)*36;\n\n            r = (i&7     )*36;\n\n            break;\n\n        case AV_PIX_FMT_RGB4_BYTE:\n\n            r = (i>>3    )*255;\n\n            g = ((i>>1)&3)*85;\n\n            b = (i&1     )*255;\n\n            break;\n\n        case AV_PIX_FMT_BGR4_BYTE:\n\n            b = (i>>3    )*255;\n\n            g = ((i>>1)&3)*85;\n\n            r = (i&1     )*255;\n\n            break;\n\n        case AV_PIX_FMT_GRAY8:\n\n            r = b = g = i;\n\n            break;\n\n        default:\n\n            return AVERROR(EINVAL);\n\n        }\n\n        pal[i] = b + (g<<8) + (r<<16) + (0xFF<<24);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9934, "substitutes": {"pal": ["font", "ph", "li", "panel", "pro", "pl", "phil", "pixel", "al", "ace", "cb", "Pal", "span", "app", "cell", "cal", "style", "scale", "in", "ee", "ch", "el", "pin", "bin", "val", "area", "all", "mask", "ette", "ap", "cel", "pp", "pel", "pad", "conf", "data", "base", "face", "py", "group", "align", "pod", "sum"], "pix_fmt": ["pix_fnt", "pix_frmt", "pix_formlt", "pix_Fformat", "pix_Fmt", "pix_formmt", "pix_fformat", "pix_flt", "pix_frMT", "pix_lnt", "pix_lmt", "pix_lMT", "pix_FMT", "pix_formformat", "pix_llt", "pix_frformat", "pix_frlt", "pix_formMT", "pix_formnt", "pix_Fnt", "pix_fMT", "pix_Flt"], "i": ["li", "mu", "ip", "mi", "chi", "c", "ri", "ami", "bi", "ui", "ci", "esi", "e", "info", "ai", "eni", "it", "ii", "idi", "ni", "id", "phi", "api", "oi", "adi", "anti", "ic", "j", "ie", "hi", "z", "xi", "zi", "qi", "o", "s", "abi", "f", "k", "y", "yi", "gi", "di", "v", "ti", "in", "ik", "l", "u", "index", "my", "mini", "x", "ix", "uri", "I", "fi", "iu", "ini", "is", "multi", "p", "si", "isi", "pi", "io", "ori", "cli", "t", "m", "n", "slice"], "r": ["fr", "f", "nr", "re", "hr", "k", "err", "ur", "ra", "rg", "rad", "y", "c", "a", "sr", "d", "ru", "rc", "h", "ri", "p", "lr", "bar", "ro", "rl", "range", "j", "gb", "R", "ar", "rb", "v", "o", "br", "l", "q", "u", "cr", "w", "m", "gr", "e", "n", "er", "rs", "reg", "or", "rr", "s", "rh", "x"], "g": ["ga", "pg", "f", "k", "err", "gm", "rg", "mg", "y", "gg", "c", "gu", "gd", "d", "h", "p", "ang", "vg", "G", "sg", "gh", "gy", "bg", "gen", "gi", "og", "gb", "ng", "go", "z", "v", "gp", "l", "q", "u", "gs", "w", "m", "gr", "e", "n", "ge", "reg", "s", "ig", "group", "x"], "b": ["ga", "f", "k", "ur", "bc", "y", "c", "a", "lb", "eb", "d", "bl", "sb", "bar", "p", "ib", "cb", "mb", "fb", "bh", "j", "gb", "rb", "bs", "bd", "B", "v", "z", "bi", "bb", "o", "t", "xb", "bin", "reb", "l", "abb", "br", "u", "ab", "w", "m", "e", "n", "base", "ob", "be", "wb", "s", "bp", "ad", "x", "ba"]}}
{"project": "qemu", "commit_id": "6a8f9661dc3c088ed0d2f5b41d940190407cbdc5", "target": 0, "func": "void qmp_transaction(TransactionActionList *dev_list, Error **errp)\n\n{\n\n    TransactionActionList *dev_entry = dev_list;\n\n    BlkTransactionState *state, *next;\n\n    Error *local_err = NULL;\n\n\n\n    QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states;\n\n    QSIMPLEQ_INIT(&snap_bdrv_states);\n\n\n\n    /* drain all i/o before any operations */\n\n    bdrv_drain_all();\n\n\n\n    /* We don't do anything in this loop that commits us to the operations */\n\n    while (NULL != dev_entry) {\n\n        TransactionAction *dev_info = NULL;\n\n        const BdrvActionOps *ops;\n\n\n\n        dev_info = dev_entry->value;\n\n        dev_entry = dev_entry->next;\n\n\n\n        assert(dev_info->kind < ARRAY_SIZE(actions));\n\n\n\n        ops = &actions[dev_info->kind];\n\n        assert(ops->instance_size > 0);\n\n\n\n        state = g_malloc0(ops->instance_size);\n\n        state->ops = ops;\n\n        state->action = dev_info;\n\n        QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry);\n\n\n\n        state->ops->prepare(state, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            goto delete_and_fail;\n\n        }\n\n    }\n\n\n\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n\n        if (state->ops->commit) {\n\n            state->ops->commit(state);\n\n        }\n\n    }\n\n\n\n    /* success */\n\n    goto exit;\n\n\n\ndelete_and_fail:\n\n    /* failure, and it is all-or-none; roll back all operations */\n\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n\n        if (state->ops->abort) {\n\n            state->ops->abort(state);\n\n        }\n\n    }\n\nexit:\n\n    QSIMPLEQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) {\n\n        if (state->ops->clean) {\n\n            state->ops->clean(state);\n\n        }\n\n        g_free(state);\n\n    }\n\n}\n", "idx": 9943, "substitutes": {"dev_list": ["dev__list", "devaycont", " dev_cont", "ev_entry", "dev__entry", "ev_cont", "dev__cont", "devaylist", "ev_code", "dev_code", "devayentry", "devaycode", "dev__info", "ev_list", "dev_cont"], "errp": ["ertp", "rrp", "ierp", "rrpy", "errtp", "errorpe", "err", " errtp", "ierpe", "errr", "errorps", "errps", "ierpy", "errorlp", "errorp", "rrpe", " errps", "erp", "errlp", " errr", "errortp", "erps", "rrlp", "errorr", "errorpy", "ierlp", "errpe", "errpy"], "dev_entry": ["devFalias", "devFentry", "devamEntry", "dem_alias", "demFentry", "dev5list", "demFalias", "dev_parse", "demFevent", " dev_enter", "dev_element", "deramEntry", "dev_alias", " dev_ry", "dem_list", "devamentry", "devFevent", "devamelement", "deramentry", " dev_parse", "der_element", " dev_element", " dev_iterator", "der_Entry", "dev5event", "dev5entry", "dem_event", "deramelement", "demFlist", "dev_event", "dev_enter", "der_entry", "dev5alias", "devFlist", "dem_entry", "dev_ry", "dev_Entry", "dev_iterator"], "state": ["message", "comment", "err", "self", "class", "STATE", "connection", "key", "address", "down", "oper", "resource", "all", "form", "e", "info", "child", "or", "root", "os", "size", "id", "view", "update", "module", "user", "public", "back", "session", "scope", "use", "j", "test", "ie", "run", "State", "code", "op", "parent", "o", "error", "call", "conn", "ry", "trans", "er", "port", "set", "out", "s", "manager", "statement", "print", "str", "action", "k", "now", "stat", "patch", "event", "config", "cur", "step", "load", "part", "r", "point", "start", "sync", "body", "name", "post", "g", "parse", "type", "local", "states", "tag", "private", "al", "game", "instance", "node", "p", "ner", "order", "seed", "st", "inner", "style", "feed", "core", "rule", "se", "go", "entry", "head", "m", "obj", "this", "none", "grade", "data", "slice", "cache"], "next": ["action", "owner", "future", "first", "chain", "other", "path", "prev", "now", "proc", "self", "vious", "front", "seq", "success", "cycle", "sequence", "second", "close", "off", "new", "back", "after", "response", "step", "ner", "again", "iterator", "done", "gen", "end", "open", "loop", "key", "code", "entry", "parent", "link", "error", "start", "head", "forward", "last", "current", "child", "set", "sec", "name", "Next", "data", "post"], "local_err": ["foreign_notice", "remote_error", "foreign_err", "foreign___err", "foreign_order", "local_order", "local_iter", "foreign_er", " local_iter", "local_cry", "local_error", "local_er", "remote_er", "local___err", "remote_err", "local___order", "foreign___order", "foreign___er", "local___notice", "local_notice", "local___er", " local_req", "local_req", " local_error", " local_cry", "foreign___notice"], "dev_info": ["ev_Info", "deveninfo", " dev_alias", "dev_next", "dev__entry", "devenspec", "devacinf", "devjentry", "devlicInfo", "dev_spec", "devjnext", "devlicentry", "devlicinfo", "dev_alias", " dev_inf", " dev_spec", "devacalias", "devliccheck", "dev_family", "dev_id", "dev_data", "ev_family", "devsinf", "devacfamily", "devsinfo", "dev_check", "devacinfo", "dev_inf", "dev__info", " dev_next", " dev_id", "devjid", "ev_entry", "devjinfo", "ev_info", "ev_check", "dev__id", "devenid", "devacdata", "devsalias", "dev_Info", "dev__next", "ev_data"], "ops": ["ils", "cs", "ip", "checks", "ims", "uts", "settings", "outs", "steps", "forces", "oper", "OP", "oops", "lock", "info", "rs", "opp", "acl", "os", "eps", "opens", "groups", "posts", "actions", "its", "ss", "ups", "OPS", "uses", "ins", "aps", "options", "operation", "alls", "op", "ms", "active", "maps", "o", "pieces", "effect", " operations", "pins", "oe", "opus", "trans", "asts", "locks", "opers", "flags", "hop", "owner", "utils", "als", "changes", "aux", "xs", "afi", "times", "arts", "cop", "step", "ips", "app", "acs", "ps", "sync", "oc", "orders", "obs", "apps", "oa", "oop", "states", "pps", "co", "works", "ands", "ts", "io", "operator", "Ops", "loop", "ns", "opt", "tx", "obj", "stats"]}}
{"project": "qemu", "commit_id": "d15fda639ba356148fc7161bba863866fd2797ef", "target": 0, "func": "static int intel_hda_init(PCIDevice *pci)\n\n{\n\n    IntelHDAState *d = DO_UPCAST(IntelHDAState, pci, pci);\n\n    uint8_t *conf = d->pci.config;\n\n\n\n    d->name = d->pci.qdev.info->name;\n\n\n\n    pci_config_set_vendor_id(conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(conf, 0x2668);\n\n    pci_config_set_revision(conf, 1);\n\n    pci_config_set_class(conf, PCI_CLASS_MULTIMEDIA_HD_AUDIO);\n\n    pci_config_set_interrupt_pin(conf, 1);\n\n\n\n    /* HDCTL off 0x40 bit 0 selects signaling mode (1-HDA, 0 - Ac97) 18.1.19 */\n\n    conf[0x40] = 0x01;\n\n\n\n    d->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read,\n\n                                          intel_hda_mmio_write, d,\n\n                                          DEVICE_NATIVE_ENDIAN);\n\n    pci_register_bar_simple(&d->pci, 0, 0x4000, 0, d->mmio_addr);\n\n    if (d->msi) {\n\n        msi_init(&d->pci, 0x50, 1, true, false);\n\n    }\n\n\n\n    hda_codec_bus_init(&d->pci.qdev, &d->codecs,\n\n                       intel_hda_response, intel_hda_xfer);\n\n\n\n    return 0;\n\n}\n", "idx": 9956, "substitutes": {"pci": ["mki", "Pcod", "hct", "mmi", "cmi", "pct", "pki", "qki", " pmi", "bii", "hii", "Pct", "cii", "hki", "pmi", "bca", "cci", "mii", "Pci", "Pcm", "qci", "pcm", "qii", "hca", "pdi", " pdi", "bci", "mci", "jpci", "hci", "hcgi", " pct", "mcm", " pcm", " pcgi", "jpdi", "Pmi", "hdi", "qdi", " pcod", "bki", "jpii", "pca", "pcod", "pcgi", "mcgi", "mdi", "Pdi", "jpki", "pii", "hcod", "cki", " pki", "Pii", "cca", "cdi", "ccm", "Pki", " pii"], "d": ["dat", "g", "dict", "wd", "sd", "die", "f", "id", "did", "diff", "state", "D", "dom", "td", "md", "c", "db", "gd", "i", "pd", "config", "h", "dr", "p", "dy", "rd", "ds", "b", "j", "con", "nd", "ld", "done", "vd", "bd", "z", "di", "dc", "dd", "client", "v", "dn", "t", "r", "da", "ind", "cmd", "l", "dev", "ded", "od", "w", "m", "defined", "dh", "dm", "e", "n", "s", "fd", "ad", "dl", "data", "dt", "cd"], "conf": ["dict", "fr", "deb", "ctx", "f", "abc", "comment", "ref", "fi", "aff", "dom", "inf", "confirmed", "c", "conv", "ca", "ini", "fab", "config", "rc", "h", "cb", "p", "b", "app", "cm", "con", "cal", "img", "cfg", "core", "rb", "v", "spec", "dc", "Conf", "ch", "client", "cl", "cmd", "req", "def", "cf", "conn", "dev", "cr", "com", "init", "info", "cn", "lc", "sec", "uc", "bug", "comb", "exec", "cd", "cache"]}}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (qemu_paio_write(&acb->aiocb) < 0) {\n\n        raw_aio_remove(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n", "idx": 9961, "substitutes": {"bs": ["bos", "os", "bis", "cs", "ls", "bc", "BS", "pb", "db", "lb", "eb", "sb", "bytes", "b", "bes", "fs", "fb", "gb", "rb", "ns", "bi", "bb", "ps", "qs", "as", "base", "obj", "las", "ob", "bits", "bas", "obs", "s", "bid", "vs", "ba"], "sector_num": [" sector_name", " sector_sn", "section_name", "section_number", "sector2name", "sector2number", "sector_index", " sector_number", "sector_number", "sector2num", "section_index", "section_num", "sector2index", "sector_name", "sector_sn"], "qiov": ["sqiu", "quoyer", "sqiov", "quio", " qrolet", "Qoyer", "quiu", "questiu", "qoyer", "sqio", "sqieri", "quieri", "qunox", "questiov", "qiu", "questio", "questieri", "quiov", " qnox", "qrolet", "qieri", "Qrolet", " qoyer", "qio", "qnox", "Qnox", "Qiov", "qurolet"], "nb_sectors": ["nb_veivers", "nb_serctions", "nb_pecs", "nb_vegments", "nb_parseivers", "nb_scs", "nb_sercs", "nb_sivers", "nb_vekers", "nb_sekers", "nb_sctors", "nb_serivers", "nb_segments", "nb_pectors", "nb_sergments", "nb_serctors", "nb_parsectors", "nb_peivers", "nb_secs", "nb_parsegments", "nb_parsekers", "nb_pections", "nb_vectors", "nb_sctions", "nb_sections", "nb_seivers", "nb_serkers"], "cb": ["fn", "ctx", "abc", "unc", "callback", "bc", "pb", "c", "db", "pc", "lb", "eb", "sb", "function", "fee", "b", "fb", "orb", "ctrl", "gb", "rb", "cc", "fp", "fc", "cv", "dc", "bb", "cf", "buff", "func", "ob", "lc", "CB", "bf"], "opaque": ["operaco", "oclaque", "oclaco", "opacity", " opaco", " opque", "octec", "octaque", " opec", "octque", "operque", "octacity", " opacity", "oclacity", "opaco", "oclque", "opque", "operaque", "operacity", "operec", "opec"], "acb": [" acba", "accb", " acbb", "aku", "acu", "akk", "oca", "ack", " acB", "ACb", "ainf", "acB", "akf", "accl", " aca", "ACba", "acba", "accbb", "ACa", "ACl", "accba", " acf", "ecf", "acca", "ecu", "ACbb", "ACbd", "accB", "ACsb", "aink", "ainu", "aca", "ecb", "acbb", "ocsb", "ocbb", "acbd", "accf", "accsb", "ocB", "akb", "ocb", "accbd", "ACf", " acsb", "eck", " acbd", " acl", "acf", "acsb", "ainb", "acl"]}}
{"project": "FFmpeg", "commit_id": "3622988f2162e502727da476a70f5e4f48cd19c5", "target": 0, "func": "static inline void pred_direct_motion(H264Context * const h, int *mb_type){\n\n    MpegEncContext * const s = &h->s;\n\n    const int mb_xy =   s->mb_x +   s->mb_y*s->mb_stride;\n\n    const int b8_xy = 2*s->mb_x + 2*s->mb_y*h->b8_stride;\n\n    const int b4_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride;\n\n    const int mb_type_col = h->ref_list[1][0].mb_type[mb_xy];\n\n    const int16_t (*l1mv0)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[0][b4_xy];\n\n    const int8_t *l1ref0 = &h->ref_list[1][0].ref_index[0][b8_xy];\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    int sub_mb_type;\n\n    int i8, i4;\n\n\n\n    if(IS_8X8(mb_type_col) && !h->sps.direct_8x8_inference_flag){\n\n        /* FIXME save sub mb types from previous frames (or derive from MVs)\n\n         * so we know exactly what block size to use */\n\n        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_4x4 */\n\n        *mb_type =    MB_TYPE_8x8;\n\n    }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_16x16 */\n\n    }else{\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_8x8;\n\n    }\n\n    if(!is_b8x8)\n\n        *mb_type |= MB_TYPE_DIRECT2;\n\n\n\n    tprintf(\"mb_type = %08x, sub_mb_type = %08x, is_b8x8 = %d, mb_type_col = %08x\\n\", *mb_type, sub_mb_type, is_b8x8, mb_type_col);\n\n    \n\n    if(h->direct_spatial_mv_pred){\n\n        int ref[2];\n\n        int mv[2][2];\n\n        int list;\n\n\n\n        /* ref = min(neighbors) */\n\n        for(list=0; list<2; list++){\n\n            int refa = h->ref_cache[list][scan8[0] - 1];\n\n            int refb = h->ref_cache[list][scan8[0] - 8];\n\n            int refc = h->ref_cache[list][scan8[0] - 8 + 4];\n\n            if(refc == -2)\n\n                refc = h->ref_cache[list][scan8[0] - 8 - 1];\n\n            ref[list] = refa;\n\n            if(ref[list] < 0 || (refb < ref[list] && refb >= 0))\n\n                ref[list] = refb;\n\n            if(ref[list] < 0 || (refc < ref[list] && refc >= 0))\n\n                ref[list] = refc;\n\n            if(ref[list] < 0)\n\n                ref[list] = -1;\n\n        }\n\n\n\n        if(ref[0] < 0 && ref[1] < 0){\n\n            ref[0] = ref[1] = 0;\n\n            mv[0][0] = mv[0][1] =\n\n            mv[1][0] = mv[1][1] = 0;\n\n        }else{\n\n            for(list=0; list<2; list++){\n\n                if(ref[list] >= 0)\n\n                    pred_motion(h, 0, 4, list, ref[list], &mv[list][0], &mv[list][1]);\n\n                else\n\n                    mv[list][0] = mv[list][1] = 0;\n\n            }\n\n        }\n\n\n\n        if(ref[1] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L1;\n\n            sub_mb_type &= ~MB_TYPE_P0L1;\n\n        }else if(ref[0] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L0;\n\n            sub_mb_type &= ~MB_TYPE_P0L0;\n\n        }\n\n\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref[0], 1);\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, ref[1], 1);\n\n            if(!IS_INTRA(mb_type_col) && l1ref0[0] == 0 &&\n\n                ABS(l1mv0[0][0]) <= 1 && ABS(l1mv0[0][1]) <= 1){\n\n                if(ref[0] > 0)\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                if(ref[1] > 0)\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n    \n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n    \n\n                fill_rectangle(&h->mv_cache[0][scan8[i8*4]], 2, 2, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[i8*4]], 2, 2, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref[0], 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, ref[1], 1);\n\n    \n\n                /* col_zero_flag */\n\n                if(!IS_INTRA(mb_type_col) && l1ref0[x8 + y8*h->b8_stride] == 0){\n\n                    for(i4=0; i4<4; i4++){\n\n                        const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                        if(ABS(mv_col[0]) <= 1 && ABS(mv_col[1]) <= 1){\n\n                            if(ref[0] == 0)\n\n                                *(uint32_t*)h->mv_cache[0][scan8[i8*4+i4]] = 0;\n\n                            if(ref[1] == 0)\n\n                                *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] = 0;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }else{ /* direct temporal mv pred */\n\n        /* FIXME assumes that L1ref0 used the same ref lists as current frame */\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1);\n\n            if(IS_INTRA(mb_type_col)){\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, 0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                const int ref0 = l1ref0[0];\n\n                const int dist_scale_factor = h->dist_scale_factor[ref0];\n\n                const int16_t *mv_col = l1mv0[0];\n\n                int mv_l0[2];\n\n                mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0],mv_l0[1]), 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n                int ref0, dist_scale_factor;\n\n    \n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n                if(IS_INTRA(mb_type_col)){\n\n                    fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h-> mv_cache[0][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    fill_rectangle(&h-> mv_cache[1][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    continue;\n\n                }\n\n    \n\n                ref0 = l1ref0[x8 + y8*h->b8_stride];\n\n                dist_scale_factor = h->dist_scale_factor[ref0];\n\n    \n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref0, 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                for(i4=0; i4<4; i4++){\n\n                    const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                    int16_t *mv_l0 = h->mv_cache[0][scan8[i8*4+i4]];\n\n                    mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                    mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                    *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] =\n\n                        pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 9977, "substitutes": {"h": ["g", "ph", "hw", "H", "f", " H", "path", "hr", "k", "host", "th", "oh", "y", "c", "d", "p", "ha", "http", "sh", "gh", "b", "ah", "bh", "hp", "hh", "ht", "hi", "hs", "v", "z", "ch", "image", "r", "t", "o", "ih", "l", "q", "u", "he", "hl", "w", "m", "dh", "e", "n", "eh", "rh", "x", "hm"], "mb_type": ["MB_size", "pg_type", "MB_type", "bg_split", "mb_length", "bg_format", "mb_col", "mp_id", "mb_TYPE", "mp_length", "mb_format", "pg_col", "MB_name", "mb__TYPE", "mb_size", "mb_types", "mbftype", "mb__format", "mbftyp", "mb__type", "mp_type", "MB_types", "mb_name", "mballength", "mbaltype", "mbaltyp", "mbaltypes", "mb_id", "mbflength", "bg_type", "pg_typ", "mp_name", "mb_typ", "pg_TYPE", "mbftypes", "mb_split", "bg_TYPE", "mp_typ", "mb__split", "mp_types"], "s": ["support", "g", "server", "os", "sym", "f", "k", "ls", "ss", "y", "c", "sq", "a", "i", "is", "an", "d", "services", "sb", "es", "p", "ts", "si", "sh", "S", "ds", "b", "settings", "fs", "session", "j", "sl", "ns", "in", "v", "ions", "spec", "client", "hs", "us", "ages", "o", "r", "t", "ps", "qs", "l", "ses", "u", "gs", "w", "m", "conf", "e", "n", "rs", "storage", "rh", "js", "location", "x"], "l1mv0": ["l1mc2", "l1mmf0", "l1mf6", "l1mv1", "l1mh6", "l1mv6", "l1mf2", "l1mh1", "l1mmf1", "l1mc1", "l1mmv2", "l1mmv0", "l1mmf6", "l1mc0", "l1mf0", "l1mmv1", "l1mf1", "l1mv2", "l1mc6", "l1mh0", "l1mmv6", "l1mh2", "l1mmf2"], "l1ref0": ["l1f0", "l1mem0", "l1r1", "l1r50", "l1f1", "l1mem50", "l1ref1", "l1mem1", "l_f0", "l_f50", "l_ref0", "l1r0", "l_ref1", "l1ref50", "l1f50", "l_ref50", "l_f1"], "sub_mb_type": ["sub_mb_state", "sub_mb_Type", "sub_mb_key", "sub_MB_types", "sub_mb_ver", "sub_mbjType", "sub_MB_type", "sub_mb_types", "sub_mp_type", "sub_mb_comp", "sub_mb_id", "sub_bb_id", "sub_bb_type", "sub_ym_type", "sub_ym_num", "sub_ym_ver", "sub_mp_comp", "sub_mbjkey", "sub_ym_state", "sub_MB_tag", "sub_mb_num", "sub_mb_tag", "sub_bb_typ", "sub_mbjcomp", "sub_mb_typ", "sub_mp_Type", "sub_mp_key", "sub_mbjtype"], "i8": ["ui64", " i64", "p6", " i88", "ui88", "i88", " i6", "i6", "p88", "ui6", "i64", "ui8", "p8", "p64"], "i4": ["p4", " i2", "p3", "pi3", "pi2", "p2", "p8", "i3", "pi4", "i2", "pi8", " i3"]}}
{"project": "qemu", "commit_id": "e3af7c788b73a6495eb9d94992ef11f6ad6f3c56", "target": 0, "func": "static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)\n\n{\n\n    uint32_t ret;\n\n\n\n    switch (ot) {\n\n    case MO_8:\n\n        ret = cpu_ldub_code(env, s->pc);\n\n        s->pc++;\n\n        break;\n\n    case MO_16:\n\n        ret = cpu_lduw_code(env, s->pc);\n\n        s->pc += 2;\n\n        break;\n\n    case MO_32:\n\n#ifdef TARGET_X86_64\n\n    case MO_64:\n\n#endif\n\n        ret = cpu_ldl_code(env, s->pc);\n\n        s->pc += 4;\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n    return ret;\n\n}\n", "idx": 10000, "substitutes": {"env": ["ne", "fen", "np", "eve", "ctx", "f", "esm", "err", "state", "eng", "nc", "ea", "proc", "engine", "ou", "c", "en", "eu", "d", "config", "ev", "es", "enc", "console", "iss", "net", "ah", "energy", "enh", "shell", "sl", "osc", "iv", "viron", "v", "environment", "vm", "que", "her", "conn", "esi", "ench", "enos", "dh", "inet", "e", "er", "ec", "fg", "eni", "txt", "ens", "vs", "esp"], "s": ["server", "os", "ess", "ctx", "sym", "f", "site", "args", "its", "cs", "ls", "ss", "states", "c", "sq", "en", "is", "a", "ins", "sv", "services", "sb", "es", "h", "p", "enc", "ts", "si", "iss", "S", "settings", "session", "ds", "fs", "ssl", "sg", "b", "sl", "ns", "spec", "us", "t", "o", "ps", "sites", "ses", "qs", "gs", "conf", "e", "n", "sys", "sets", "su", "rs", "sec", "js", "ens", "vs", "ops"], "ot": ["et", "os", "ocr", " rot", "ott", "rt", " tot", " t", " robot", "c", "ocol", " os", "ant", "lot", "p", "ol", "ort", "OT", " quot", "boot", "ic", "ocl", "ots", "pt", " dot", "mot", " pot", "ut", "pot", "osc", "gt", "op", "ch", " o", "rot", "t", "r", "oto", "o", "cot", "oc", "sys", " bot", "or", "nt", " OT", "root", "iot", " opt", " ov"], "ret": ["rt", "rets", "f", "id", "match", "resp", "re", "RET", "final", "ref", "repl", "rev", "result", "addr", "success", "len", "al", "art", "eval", "rc", "back", "fun", "lit", "url", "flag", "bit", "ext", "mt", "part", "ut", "red", "code", "v", "mem", "gt", "val", "det", "def", "arg", "reply", "fit", "obj", "xt", "res", "out", "nt", "reg", "alt", "Ret", "bf", "data", "str"], "pc": ["tp", "pub", "pointer", "pm", "xc", "anc", "cs", "nc", "proc", "lic", "isc", "bc", "vc", "pb", "c", "can", "auc", "pu", "lp", "rc", "cur", "arc", "enc", "clock", "con", "mic", "ct", "PC", "pt", "cpu", "cc", "loop", "fc", "cms", "ac", "pac", "inc", "roc", "ci", "micro", "sync", "sc", "post", "sys", "cent", "lc", "mc", "uc", "ec", "gc", "asc", "pod", "cache"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void bdrv_throttle_write_timer_cb(void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    qemu_co_enter_next(&bs->throttled_reqs[1]);\n\n}\n", "idx": 10026, "substitutes": {"opaque": ["OPque", "OPac", "opacity", "compque", " opac", "compaque", "ipacity", "OPaques", "copaque", " opacity", "copaques", "opac", "copac", "ipaque", "compacity", "ipque", "opaques", "ipaques", "compaques", "OPaque", "opque", " opaques", "copacity", "OPacity"], "bs": ["bos", "als", "ums", "os", "abc", "cs", "ls", "ss", "bc", "BS", "pb", "bps", "ks", "lb", "ins", "bl", "sb", "bytes", "fps", "cb", "iss", "ds", "b", "bes", "fb", "fs", "bh", "ns", "ras", "bec", "bb", "ps", "ab", "gs", "ros", "las", "bits", "bas", "rs", "obs", "vs", "ops", "ba"]}}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "static int find_pte32(CPUPPCState *env, mmu_ctx_t *ctx, int h,\n\n                      int rw, int type, int target_page_bits)\n\n{\n\n    hwaddr pteg_off;\n\n    target_ulong pte0, pte1;\n\n    int i, good = -1;\n\n    int ret, r;\n\n\n\n    ret = -1; /* No entry found */\n\n    pteg_off = get_pteg_offset(env, ctx->hash[h], HASH_PTE_SIZE_32);\n\n    for (i = 0; i < 8; i++) {\n\n        if (env->external_htab) {\n\n            pte0 = ldl_p(env->external_htab + pteg_off + (i * 8));\n\n            pte1 = ldl_p(env->external_htab + pteg_off + (i * 8) + 4);\n\n        } else {\n\n            pte0 = ldl_phys(env->htab_base + pteg_off + (i * 8));\n\n            pte1 = ldl_phys(env->htab_base + pteg_off + (i * 8) + 4);\n\n        }\n\n        r = pte_check_hash32(ctx, pte0, pte1, h, rw, type);\n\n        LOG_MMU(\"Load pte from %08\" HWADDR_PRIx \" => \" TARGET_FMT_lx \" \"\n\n                TARGET_FMT_lx \" %d %d %d \" TARGET_FMT_lx \"\\n\",\n\n                pteg_off + (i * 8), pte0, pte1, (int)(pte0 >> 31), h,\n\n                (int)((pte0 >> 6) & 1), ctx->ptem);\n\n        switch (r) {\n\n        case -3:\n\n            /* PTE inconsistency */\n\n            return -1;\n\n        case -2:\n\n            /* Access violation */\n\n            ret = -2;\n\n            good = i;\n\n            break;\n\n        case -1:\n\n        default:\n\n            /* No PTE match */\n\n            break;\n\n        case 0:\n\n            /* access granted */\n\n            /* XXX: we should go on looping to check all PTEs consistency\n\n             *      but if we can speed-up the whole thing as the\n\n             *      result would be undefined if PTEs are not consistent.\n\n             */\n\n            ret = 0;\n\n            good = i;\n\n            goto done;\n\n        }\n\n    }\n\n    if (good != -1) {\n\n    done:\n\n        LOG_MMU(\"found PTE at addr %08\" HWADDR_PRIx \" prot=%01x ret=%d\\n\",\n\n                ctx->raddr, ctx->prot, ret);\n\n        /* Update page flags */\n\n        pte1 = ctx->raddr;\n\n        if (pte_update_flags(ctx, &pte1, ret, rw) == 1) {\n\n            if (env->external_htab) {\n\n                stl_p(env->external_htab + pteg_off + (good * 8) + 4,\n\n                      pte1);\n\n            } else {\n\n                stl_phys_notdirty(env->htab_base + pteg_off +\n\n                                  (good * 8) + 4, pte1);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* We have a TLB that saves 4K pages, so let's\n\n     * split a huge page to 4k chunks */\n\n    if (target_page_bits != TARGET_PAGE_BITS) {\n\n        ctx->raddr |= (ctx->eaddr & ((1 << target_page_bits) - 1))\n\n                      & TARGET_PAGE_MASK;\n\n    }\n\n    return ret;\n\n}\n", "idx": 10049, "substitutes": {"env": ["ne", "oa", "np", "dict", "ocr", "loader", "site", "eng", "nc", "ea", "exc", "fi", "chal", "bc", "engine", "ou", "db", "en", "ini", "qt", "eu", "jp", "event", "config", "ev", "enc", "console", "Environment", "qa", "net", "ah", "equ", "cal", "ext", "context", "cfg", "cli", "osc", "act", "viron", "cv", "environment", "vm", "que", "inv", "cf", "conn", "esi", "qv", "cot", "org", "dt", "conf", "e", "eh", "ec", "eni", "txt", "energy", "exec", "cache"], "ctx": ["cas", "utils", "hw", "ocr", "rt", "src", "Context", "service", "xc", "anc", "nc", "exc", "na", "connection", "bc", "wcs", "vc", "c", "conv", "sq", "ca", "cmp", "qt", "config", "rc", "cgi", "kb", "console", "sci", "ck", "loc", "settings", "qa", "pkg", "cp", "cm", "cu", "ct", "ctrl", "cal", "grad", "context", "cli", "cc", "kt", "fp", "cv", "client", "que", "cmd", "ci", "conn", "cf", "sc", "git", "sync", "dt", "component", "tx", "obj", "fw", "cn", "qq", "lc", "exec", "acl"], "h": ["g", "ph", "hw", "H", "hd", "f", "id", "host", "oh", "c", "en", "p", "ha", "uh", "sh", "gh", "b", "bh", "hp", "hh", "ht", "end", "hi", "v", "hs", "ch", "header", "t", "ih", "l", "q", "u", "hl", "w", "m", "dh", "n", "rh", "hash", "x", "hm"], "rw": ["usr", "hw", "wd", "nr", "sw", "wk", "wx", "rack", "rg", "rew", "wo", "ru", "rc", "rss", "lr", "wr", "wn", "rl", "rf", "RW", "rn", "kw", "nw", "wl", "tw", "rb", "ww", "rx", "ih", "wu", "wp", " w", "w", "wh", "wt", "fw", "rs", "rh", "wb", "iw", "raw", "writer"], "type": ["prop", "thin", "id", "format", "resp", "re", "path", "weight", "ref", "ptr", "y", "pb", "method", "rc", "p", "temp", "cur", "Type", "shape", "style", "TYPE", "rule", "tmp", "op", "pe", "t", "o", "time", "error", "kind", "attr", "rec", "ty", "unit", "sys", "info", "ype", "name", "py", "ping", "typ", "types"], "target_page_bits": ["target_page64config", "target_page_bytes", "target_width64bytes", "target_width_config", "target_page_config", "target_width64bit", "target_page64bytes", "target_width_bit", "target_pagenumbits", "target_width64config", "target_pagenumbytes", "target_width64bits", "target_page_bit", "target_page64bits", "target_page64bit", "target_width_bits", "target_pagenumbit", "target_width_bytes", "target_pagenumconfig"], "pteg_off": ["pteg00off", "ptigh00off", "ptrig_not", "pteg0open", "pteg_Off", "pteg0ref", "ptrig55Off", "pteg67open", "pteg00fail", "ptigh_fail", "ptig_num", "ptpeglenoffset", "pteg_OFF", "ptreg_on", "pteg_ON", "ptrig_off", "ptig_off", "ptigh00alt", "pteg67ref", "pteg00on", "pteg0off", "pteg67off", "pteg_num", "pteg55on", "ptpeglenoff", "pteg67not", "ptig_Off", "pteg00alt", "pteg67orig", "pteg_on", "pteg67Off", "pteg_ref", "pteg_fail", "ptigh00fail", "pteglenoff", "ptpeg_offset", "ptpeg_ON", "ptpeg_on", "pteg55Off", "ptreg_opp", "ptigh00on", "ptreg_OFF", "pteg55orig", "pteglenON", "ptpeg_off", "pteg_orig", "ptreg_set", "ptigh_on", "ptigh_off", "ptrig55not", "ptrig55orig", "pteglenoffset", "pteg_open", "pteg55fail", "ptigh_alt", "ptig_open", "pteg_offs", "ptrig55off", "pteg_not", "pteg67num", "pteg55not", "ptpeglenON", "ptreg_offs", "pteg_alt", "ptreg_off", "pteglenon", "ptrig_Off", "pteg_opp", "ptig_ref", "ptrig_orig", "pteg_offset", "ptpeglenon", "pteg55off", "pteg_set", "pteg55alt"], "pte0": ["ptea192", "ptse00", "ptee5", "ptoe1", "ctee150", "PTE5", "pte180", "pte4", "PTE0", "upte0", "ptee4", "ptae4", " pteio", "upti180", "ptoe25", "ctee25", "upti4", "ptE029", "PTE029", "ptee25", "ptee029", "ptee100", "pte00", "ptE5", "cte100", "cte150", "ptee8", "ptae0", "upti050", "cte0", "cte192", "ptee18", "ptE1", "ptse25", "ptedge029", "ptsio", "ptae00", "ptee192", "ptedge5", "pte5", "ctee192", "PTe029", "ptea1", "pte8", " pts0", "ptea150", "pts0", "pte050", "ptoe192", "ptae050", "pti4", "pts8", "ptee150", "ctee18", "ptoe4", " pts8", "ptea0", "ptee2", "ptte1", "cte25", "ctee4", "ptn0", "pti180", "ptae180", "pte25", "upti0", "ptte0", "pteio", "ptse18", "pte2", "ptedge0", "ptedge2", "ctee0", "pte029", "upte4", "PTe5", "ptn8", "ptte100", "pte100", "pte192", "ctee00", "upte180", "cte00", "ptee0", "PTE2", "ptte25", "pte18", "cte4", "ptoe180", "cte18", "ptE0", "pti050", "ptE4", "pte150", "ptoe150", "ptoe0", "ctee1", "ptae1", "ptee1", "PTe2", "ptoe050", "ptse0", "pti0", "ctee100", " ptsio", "pteeio", " pte8", "PTe0", "ptnio", "ptE25", "ptE2", "upte050", "ptee00", "ptae18", "cte1", "ptse1", "ptse100"], "pte1": ["pte81", "ptae3", "pteone", "ptee5", "ptei3", "pte11", "ptoe1", "ptoe81", "ptea3", "postoe0", "cten", "cteeone", "ctee2", "ptoeone", "ptee9", "pten", "ptfe3", "ptl1", "ctee5", "ptfe0", "poste81", "cte11", "ptee8", "cteone", "cte0", "ctee8", "ptae0", "ptl81", "cte3", "ptfe1", "ptei5", "ptedone", "ctee11", "postoe81", "ptoe9", "pte5", "ptle5", "poste1", "ptea1", "pteOne", "pte8", "ptfeOne", "cteen", "pteeOne", "cteeOne", "cte9", "pteen", "ctee3", "ptea0", "ptee2", "ptei2", "cte8", "ptoeOne", "postoeOne", "ptei1", "ptl0", "pte9", "pted5", "pteione", "pte2", "ptle9", "cteOne", "ctee0", "pteiOne", "poste0", "ptoen", "postoe1", "ptaen", "ptle1", "ptoe11", "cte5", "ptee3", "ptee0", "pte3", "ptoe5", "pteeone", "ptee81", "ptoe3", "ptlOne", "ptee11", "ptse8", "ptoe0", "ctee1", "posteOne", "ptae1", "ptee1", "ptse0", "ctee9", "ptle0", "ptoe8", "pted2", "ptseone", "ptei0", "pted1", "cte1", "ptse1", "ptea11", "cte2"], "i": ["ii", "ti", "ni", "abi", "li", "uri", "f", "id", "phi", "I", "mu", "ip", "oi", "mi", "fi", "t", "chi", "adi", "y", "c", "yi", "iu", "ini", "is", "d", "multi", "ji", "p", "ri", "slice", "si", "b", "pi", "io", "j", "gi", "ie", "cli", "in", "xi", "zi", "bi", "di", "hi", "qi", "ui", "v", "o", "l", "ci", "ind", "u", "index", "e", "n", "info", "my", "ai", "mini", "eni", "x", "ix"], "ret": ["big", "debug", "valid", "pass", "like", "rt", "rets", "f", "id", "resp", "re", "RET", "ref", "err", "fi", "result", "good", "success", "len", "db", " success", "rc", "cat", "back", " good", " result", "lit", "fun", "done", "flag", "stable", "bit", "best", "gt", "mem", "num", "rx", "ind", "val", "get", "req", "def", "fail", "arg", "fit", "last", "data", "reg", "res", "nt", "rr", "fin", "Ret", "ig", "bug", "bad"], "r": ["g", "rt", "f", "nr", "re", "hr", "err", "ur", "result", "rg", "c", "mr", "sr", "d", "dr", "rc", "ru", "ri", "p", "lr", "rl", "rf", "b", "R", "ar", "end", "rb", "v", "error", "br", "kr", "t", "ir", "ry", "m", "e", "er", "rs", "rr", "rh", "res", "s"]}}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "static int kvm_put_xcrs(CPUState *env)\n\n{\n\n#ifdef KVM_CAP_XCRS\n\n    struct kvm_xcrs xcrs;\n\n\n\n    if (!kvm_has_xcrs())\n\n        return 0;\n\n\n\n    xcrs.nr_xcrs = 1;\n\n    xcrs.flags = 0;\n\n    xcrs.xcrs[0].xcr = 0;\n\n    xcrs.xcrs[0].value = env->xcr0;\n\n    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);\n\n#else\n\n    return 0;\n\n#endif\n\n}\n", "idx": 10055, "substitutes": {"env": ["server", "et", "np", "dict", "chev", "args", "f", "ctx", "loader", "eng", "ea", "exc", "fi", "chal", "ou", "c", "db", "network", "en", "eu", "config", "ev", "esc", "enc", "ep", "iss", "scope", "net", "ah", "context", "enter", "end", "iv", "viron", "cv", "code", "client", "environment", "machine", "vm", "el", "v", "que", "entry", "conn", "conf", "e", "obj", "ec", "eye", "eni", "manager", "ef", "cache"], "xcrs": ["xdrs", "lcrics", "lcps", "lcRS", "xcars", "lcars", "etcars", "xdri", "xfars", "ucps", "xfras", "xccs", "xeRS", "xdr", "xers", "xeras", "xaras", "xacs", "ctxars", "xcrics", "xbRS", "xfri", "lcrd", "xcRS", "xaRS", "etcRS", "xdrors", "xdps", "xfdr", "xfrd", "xdcs", "ctxrs", "xdRS", "xarics", "xbrs", "xdars", "etcrors", "ucrs", "xar", "xbri", "etcrs", "xcdr", "xfrs", "xdrd", "xcrys", "xfps", "xcr", "ctxps", "xcps", "lcr", "xfr", "xcras", "xbras", "xddr", "lcras", "xer", "ucrys", "ucars", "xars", "lcrys", "xfcs", "xcrors", "xcrd", "xdrics", "xfrors", "ctxdr", "xdras", "lcrs", "xdrys", "xfRS", "xcri"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond cond,\n\n                                     TCGv cmp, int32_t disp)\n\n{\n\n    uint64_t dest = ctx->pc + (disp << 2);\n\n    int lab_true = gen_new_label();\n\n\n\n    if (use_goto_tb(ctx, dest)) {\n\n        tcg_gen_brcondi_i64(cond, cmp, 0, lab_true);\n\n\n\n        tcg_gen_goto_tb(0);\n\n        tcg_gen_movi_i64(cpu_pc, ctx->pc);\n\n        tcg_gen_exit_tb((uintptr_t)ctx->tb);\n\n\n\n        gen_set_label(lab_true);\n\n        tcg_gen_goto_tb(1);\n\n        tcg_gen_movi_i64(cpu_pc, dest);\n\n        tcg_gen_exit_tb((uintptr_t)ctx->tb + 1);\n\n\n\n        return EXIT_GOTO_TB;\n\n    } else {\n\n        TCGv_i64 z = tcg_const_i64(0);\n\n        TCGv_i64 d = tcg_const_i64(dest);\n\n        TCGv_i64 p = tcg_const_i64(ctx->pc);\n\n\n\n        tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p);\n\n\n\n        tcg_temp_free_i64(z);\n\n        tcg_temp_free_i64(d);\n\n        tcg_temp_free_i64(p);\n\n        return EXIT_PC_UPDATED;\n\n    }\n\n}\n", "idx": 10064, "substitutes": {"ctx": ["cas", "np", "hw", "parse", "Context", "xc", "anc", "cs", "nc", "cdn", "wx", "connection", "bc", "wcs", "vc", "c", "conv", "pc", "ca", "config", "rc", "cpp", "cb", "kb", "wordpress", "sci", "ck", "pkg", "loc", "qa", "cp", "cm", "cu", "ctrl", "grad", "context", "cfg", "cpu", "cli", "cc", "fc", "cv", "fp", "client", "cms", "cmd", "wp", "cf", "conn", "ci", "sc", "cus", "sync", "cam", "git", "tx", "tc", "cn", "qq", "mc", "lc", "cca", "txt", "exec"], "cond": ["cas", "pos", "prop", " Cond", "diff", "resp", "xc", "proc", "comp", "bc", "c", "conv", "config", "cb", "temp", "condition", "loc", "pkg", "cell", "cp", "red", "pre", "code", "fc", "prep", "fail", "df", "cl", "cmd", "def", "cf", "com", "desc", "func", "cod", "obj", "unit", "crit", "reason", "conf", "lock", "reg", "lc", "sec", "comb", "exec", "Cond"], "cmp": ["cas", "prop", "pos", "np", "cup", "diff", "resp", "mom", "pro", "proc", "comp", "mp", "bc", "seq", "c", "conv", "jp", "co", "comm", "config", "cpp", "cb", "cop", "pkg", "loc", "cp", "ctrl", "gen", "cor", "omp", "cpu", "coll", "fp", "tmp", "prep", "Compare", "Comp", "op", "cmd", "rep", "agg", "clip", "com", "component", "desc", "conf", "crit", "upp", "lc", "cho", "imp"], "disp": ["DISp", "demlp", "desbp", " DisP", "disbp", "DisP", " dislp", "DIScp", "desp", " disbp", "dembp", "dispp", "Disps", "disps", "DISps", "demp", "despp", " dispp", "DISP", "discp", "dempp", "Disp", "deslp", " Disp", " Disps", " Discp", "disP", "Discp", "dislp"]}}
{"project": "qemu", "commit_id": "1931e26054fdf2b1b84091f0b9662979eb6931ec", "target": 0, "func": "static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)\n\n{\n\n    uint32_t val = pci_default_read_config(d, address, len);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n    return val;\n\n}\n", "idx": 10081, "substitutes": {"d": ["dat", "sd", "f", "id", "D", "md", "c", "gd", "db", "a", "i", "pd", "p", "dos", "ds", "b", "ld", "bd", "v", "dc", "dd", "ind", "t", "da", "ded", "od", "m", "dh", "dm", "e", "fd", "dl", "ad", "data", "dt", "cd", "x", "dad"], "address": ["message", "pointer", "type", "attribute", "device", "ip", "addr", "instance", " Address", "config", "ace", "p", "offset", "driver", "shape", "interface", "pair", "array", "image", "dd", "length", "channel", "argument", "dim", "index", "m", "inet", "e", "port", "ai", "Address", "ad", "data", "target", "number", "object"], "len": ["pos", "valid", "block", "size", "f", "limit", "seq", "en", "enc", "offset", "loc", "split", "Len", "fl", "lim", "part", "z", "in", "num", "length", "el", "bin", "val", "l", "base", "n", "ln", "lc", "fd", "data", "count", "lf", "line"]}}
{"project": "qemu", "commit_id": "bbade20633a6b4ed7333e03a76038eda98950946", "target": 1, "func": "static void rtas_get_time_of_day(PowerPCCPU *cpu, sPAPREnvironment *spapr,\n\n                                 uint32_t token, uint32_t nargs,\n\n                                 target_ulong args,\n\n                                 uint32_t nret, target_ulong rets)\n\n{\n\n    struct tm tm;\n\n\n\n    if (nret != 8) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    qemu_get_timedate(&tm, spapr->rtc_offset);\n\n\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, tm.tm_year + 1900);\n\n    rtas_st(rets, 2, tm.tm_mon + 1);\n\n    rtas_st(rets, 3, tm.tm_mday);\n\n    rtas_st(rets, 4, tm.tm_hour);\n\n    rtas_st(rets, 5, tm.tm_min);\n\n    rtas_st(rets, 6, tm.tm_sec);\n\n    rtas_st(rets, 7, 0); /* we don't do nanoseconds */\n\n}\n", "idx": 10104, "substitutes": {"cpu": ["linux", "loader", "proc", "pc", "cmp", "pu", "CPU", "clock", "boot", "px", "cp", "worker", "core", "prof", "cli", "thread", "mem", "vm", "roc", "mac", "gp", "gpu", "conn", "process", "mc", "processor", "mx", "cache"], "spapr": [" spapnr", "SPapr", "spapprs", "SPaprc", " spaprs", "spaprs", "spappr", "SPapeR", "spapR", "SPaprb", "SPapR", "spapprc", "spepR", "SPaper", "spAPrb", "spepnr", "spaprb", "spapnr", "spAPnr", "spAPR", "spaprc", " spappnr", "spepr", "spappnr", "spAPr", "spaperb", "spaper", "spaperc", " spapR", "speprs", "spapprb", "SPaperc", "spAPrc", "spAPrs", " spappr", " spappR", " spapprs", "SPaperb", "spappR", "spapeR"], "token": ["flags", "timeout", "ctx", "match", "resp", "RET", "ea", "result", "len", "des", "cb", "urn", "fun", "total", "acs", "rule", "tn", "nat", "mem", "conn", "wt", "reply", "cookie", "ern", "su", "Ret", "cost"], "nargs": ["lrets", "carg", "ntarg", "lseq", "cargs", "nseq", "largs", "cseq", "narg", "nrets", "ntargs", "crets", "larg", "ntseq", "ntrets"], "args": ["flags", "parse", "ait", "resp", "vals", "cs", "addr", "len", "ae", "params", "ts", "arr", "alls", "ns", "aus", "ms", "ret", "call", "ints", "arg", "func", "reply", "ai", "Args", "data", "uments"], "nret": [" nmatch", "nRet", "dret", " nRET", "natmatch", "nreturn", "ncrets", "ncreturn", " nreturn", "dRET", "crets", "natreturn", "dmatch", "natret", "natRET", "dreturn", "nRET", " nRet", "cRet", "cret", "ncret", "creturn", "nrets", "nmatch", "ncRet", " nrets"], "rets": ["fts", "ats", "vals", "RET", "fits", "uds", "checks", "bytes", "uts", "ves", "lines", "outs", "runs", "ents", "ets", "ints", "rs", "strings", "alt", "uments", "uries", "nuts", "opens", "nir", "groups", "ls", "rows", "verts", "nas", "ds", "fs", "ret", "reads", "qs", "books", "nets", "res", "flags", "tests", "utils", "vers", "ards", "aux", "fields", "ails", "archives", "des", "details", "ips", "tracks", "acs", "errors", "reply", "sys", "urs", "features", "events", "proc", " secrets", "acks", "ts", "ults", "results", "secret", "files", "ns", "store", "def", "ures", "buffer", "bits", "tta", "ops"], "tm": ["server", "text", "tf", "sym", "tu", " mem", " t", "mi", "tri", "gm", "mr", "timer", " ts", "fm", "htm", "cm", "imi", "him", " tmp", "tre", "mem", "ui", "ym", "om", "txt", "um", "wm", "norm", " tre", "tk", "lim", "mt", "tn", "dim", "te", " ret", "mc", "TM", "dt", "tr", "mode", "sm", "utm", "metadata", "td", "imm", " tc", " te", "nom", "cu", "ku", "tw", "sim", "acqu", "ti", "ta", " m", "nm", " TM", "em", "anim", " template", "gam", "ten", "md", "template", "multi", "term", "ts", "temp", "project", "tem", "cli", "tmp", "t", "tom", "m", "mm", "tim", "dm", "tt", "tc", "typ", "hm"]}}
{"project": "qemu", "commit_id": "3d948cdf3760b52238038626a7ffa7d30913060b", "target": 0, "func": "void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)\n\n{\n\n    BlockJob *job = find_block_job(device);\n\n\n\n    if (!job) {\n\n        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);\n\n        return;\n\n    }\n\n\n\n    block_job_set_speed(job, speed, errp);\n\n}\n", "idx": 10128, "substitutes": {"device": ["product", "phy", "block", "mount", "type", "mode", "attribute", "devices", "path", "ip", "serial", "connection", "engine", "task", "network", "mobile", "feature", "node", "model", "scope", "driver", "direction", "project", "address", "machine", "android", "image", "parent", "mac", "gpu", "conn", "dev", "disk", "component", "buffer", "unit", "port", "Device", "slave", "name", "data", "target"], "speed": ["pass", "slow", "size", "peed", "mode", "path", "weight", "screen", "state", "ss", "score", "strength", "step", "si", "fee", "settings", "seed", "scale", "spec", "image", "length", "source", "level", "error", "scroll", "gain", "sync", "start", "Speed", "power", "unit", "port", "rank", "set", "disable", "status", "rate", "grade", "send", "cost", "performance"], "errp": ["corlp", "erpc", "corr", "err", "erlp", "errP", "ryps", "errr", "corp", "errf", "acerf", "rypc", "errps", "ryP", "corP", "ryp", " errf", " errps", " errlp", "erp", "errlp", " errpc", " errr", "erps", "erf", "errpc", " errP", "acerp", "erP", "acerP", "acerps"], "job": ["plugin", "server", "up", "block", "f", "pm", "flow", "api", "home", "jo", "output", "result", "sub", "module", "db", "route", "lb", "jp", "node", "config", "cb", "session", "b", "fun", "member", "work", "worker", "queue", "j", "runner", "full", "run", "address", "hub", "image", "parent", "layer", "Job", "error", "lib", "sync", "jobs", "lock", "child", "ob", "process", "name", "status", "manager", "py", "bug", "object", "build"]}}
{"project": "FFmpeg", "commit_id": "e8c4db0d4d07738fed716b1d2f20c85aac944641", "target": 0, "func": "static int create_stream(AVFormatContext *s)\n\n{\n\n    XCBGrabContext *c = s->priv_data;\n\n    AVStream *st      = avformat_new_stream(s, NULL);\n\n    xcb_get_geometry_cookie_t gc;\n\n    xcb_get_geometry_reply_t *geo;\n\n    int ret;\n\n\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ret = av_parse_video_size(&c->width, &c->height, c->video_size);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000000);\n\n\n\n    gc  = xcb_get_geometry(c->conn, c->screen->root);\n\n    geo = xcb_get_geometry_reply(c->conn, gc, NULL);\n\n\n\n    c->width      = FFMIN(geo->width, c->width);\n\n    c->height     = FFMIN(geo->height, c->height);\n\n    c->time_base  = (AVRational){ st->avg_frame_rate.den,\n\n                                  st->avg_frame_rate.num };\n\n    c->time_frame = av_gettime();\n\n\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id   = AV_CODEC_ID_RAWVIDEO;\n\n    st->codec->width      = c->width;\n\n    st->codec->height     = c->height;\n\n    st->codec->time_base  = c->time_base;\n\n\n\n    ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt);\n\n\n\n    free(geo);\n\n\n\n    return ret;\n\n}\n", "idx": 10161, "substitutes": {"s": ["g", "os", "f", "service", "cs", "sf", "ss", "xs", "sq", "is", "i", "ks", "d", "services", "sb", "sv", "es", "p", "si", "sg", "S", "ds", "b", "session", "ssl", "fs", "sl", "ns", "v", "spec", "t", "r", "o", "ses", "sc", "sync", "gs", "w", "m", "sn", "as", "e", "sets", "sys", "su", "sa", "js", "ops"], "c": ["g", "chain", "ctx", "f", "k", "anc", "cs", "nc", "ce", "bc", "vc", "pc", "ca", "i", "co", "d", "config", "h", "p", "cb", "enc", "cur", "cy", "b", "ic", "cm", "cp", "cu", "con", "ctrl", "ct", "cc", "z", "fc", "C", "dc", "ac", "v", "coll", "ch", "o", "cl", "t", "r", "jc", "l", "ci", "conn", "sc", "u", "cf", "q", "cr", "w", "m", "com", "col", "cus", "oc", "e", "n", "this", "tc", "ec", "lc", "mc", "uc", "sec", "cd", "x", "cache"], "st": ["et", "rt", "sth", "src", "cs", "fe", "art", "spect", "sp", "sh", "sts", "cc", "irst", "ust", "cr", "sn", "ast", "e", "nt", "inst", "sd", "ss", "sr", "sb", "ace", "stage", "sta", "ld", "pt", "mt", "est", "ut", "cl", "sc", "sty", "St", "set", "ad", "dt", "stop", "str", "f", "ost", "ist", "sle", "td", "bc", "stat", "cur", "rd", "ste", "ST", "sl", "std", "l", "sync", "start", "sk", "lc", "post", "put", "ess", "ft", "ce", "ts", "ct", "nd", "se", "osc", "tmp", "dc", "t", "obj", "tt", "storage", "rest", "sa", "uc"], "gc": ["g", "ga", "wd", "pg", "gas", "ctx", " ss", " func", "cdn", "nc", "gm", "rg", "bc", "gg", "gu", "gd", " mc", "pc", " proc", "sb", "rc", " cc", "vg", "ha", "sg", "gz", "ic", "bg", "cm", "GC", "kw", "ag", " sn", "gb", " ec", "grad", "cc", "gt", "dc", "ac", "bb", "gp", "conn", " da", "sync", "cr", " g", " cm", " ac", " acc", "mc", "lc", " bc", "reg", "cca", "ig", "jc", "cache"], "geo": [" geod", "seos", "geos", "geol", "neos", "neo", "seo", " Geot", "gateo", "gateos", "gei", "seu", "geot", "ceos", "demi", "cheos", "ceo", "cheology", "genology", "genometry", "genos", " gebo", "Geol", "demos", "geometry", "demu", "gateot", " geology", " geometry", "geu", "demo", "Gei", "geonet", "gebo", " Geo", "gateonet", "neu", "Geo", "nebo", " geos", " Geol", " Geos", "gateod", "cheo", "Geoa", "Geot", "ceod", " geoa", " geot", " geonet", "geoa", "gateoa", "geno", "sei", "Geos", "Gebo", "geology", " geol", "cheometry", "ceonet", "nei", " gei", "geod"], "ret": ["et", "rt", "re", "RET", "ref", "err", "success", "lt", "art", "rc", "reset", "nat", "pet", "hard", "arg", "pat", "info", "nt", "true", "alt", "Ret", "status", "feat", "pass", "rets", "id", "rev", "result", "off", "cat", "back", "rf", "lit", "flag", "test", "run", "mt", "end", "ut", "code", "over", "active", "fail", "error", "det", "base", "res", "reg", "f", "att", "len", "en", "fun", "fin", "bad", "x", "ft", "al", "ner", "arr", "net", "url", "ext", "gt", "t", "af", "val", "def", "bf", "data", "let"]}}
{"project": "FFmpeg", "commit_id": "02055b6d40d0cff867a9e41cad48edcaf6e10f2f", "target": 0, "func": "static int vorbis_parse_setup_hdr_codebooks(vorbis_context *vc)\n\n{\n\n    unsigned cb;\n\n    uint8_t  *tmp_vlc_bits;\n\n    uint32_t *tmp_vlc_codes;\n\n    GetBitContext *gb = &vc->gb;\n\n    uint16_t *codebook_multiplicands;\n\n    int ret = 0;\n\n\n\n    vc->codebook_count = get_bits(gb, 8) + 1;\n\n\n\n    av_dlog(NULL, \" Codebooks: %d \\n\", vc->codebook_count);\n\n\n\n    vc->codebooks = av_mallocz(vc->codebook_count * sizeof(*vc->codebooks));\n\n    tmp_vlc_bits  = av_mallocz(V_MAX_VLCS * sizeof(*tmp_vlc_bits));\n\n    tmp_vlc_codes = av_mallocz(V_MAX_VLCS * sizeof(*tmp_vlc_codes));\n\n    codebook_multiplicands = av_malloc(V_MAX_VLCS * sizeof(*codebook_multiplicands));\n\n\n\n    for (cb = 0; cb < vc->codebook_count; ++cb) {\n\n        vorbis_codebook *codebook_setup = &vc->codebooks[cb];\n\n        unsigned ordered, t, entries, used_entries = 0;\n\n\n\n        av_dlog(NULL, \" %u. Codebook\\n\", cb);\n\n\n\n        if (get_bits(gb, 24) != 0x564342) {\n\n            av_log(vc->avctx, AV_LOG_ERROR,\n\n                   \" %u. Codebook setup data corrupt.\\n\", cb);\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n\n\n        codebook_setup->dimensions=get_bits(gb, 16);\n\n        if (codebook_setup->dimensions > 16 || codebook_setup->dimensions == 0) {\n\n            av_log(vc->avctx, AV_LOG_ERROR,\n\n                   \" %u. Codebook's dimension is invalid (%d).\\n\",\n\n                   cb, codebook_setup->dimensions);\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n        entries = get_bits(gb, 24);\n\n        if (entries > V_MAX_VLCS) {\n\n            av_log(vc->avctx, AV_LOG_ERROR,\n\n                   \" %u. Codebook has too many entries (%u).\\n\",\n\n                   cb, entries);\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n\n\n        ordered = get_bits1(gb);\n\n\n\n        av_dlog(NULL, \" codebook_dimensions %d, codebook_entries %u\\n\",\n\n                codebook_setup->dimensions, entries);\n\n\n\n        if (!ordered) {\n\n            unsigned ce, flag;\n\n            unsigned sparse = get_bits1(gb);\n\n\n\n            av_dlog(NULL, \" not ordered \\n\");\n\n\n\n            if (sparse) {\n\n                av_dlog(NULL, \" sparse \\n\");\n\n\n\n                used_entries = 0;\n\n                for (ce = 0; ce < entries; ++ce) {\n\n                    flag = get_bits1(gb);\n\n                    if (flag) {\n\n                        tmp_vlc_bits[ce] = get_bits(gb, 5) + 1;\n\n                        ++used_entries;\n\n                    } else\n\n                        tmp_vlc_bits[ce] = 0;\n\n                }\n\n            } else {\n\n                av_dlog(NULL, \" not sparse \\n\");\n\n\n\n                used_entries = entries;\n\n                for (ce = 0; ce < entries; ++ce)\n\n                    tmp_vlc_bits[ce] = get_bits(gb, 5) + 1;\n\n            }\n\n        } else {\n\n            unsigned current_entry  = 0;\n\n            unsigned current_length = get_bits(gb, 5) + 1;\n\n\n\n            av_dlog(NULL, \" ordered, current length: %u\\n\", current_length);  //FIXME\n\n\n\n            used_entries = entries;\n\n            for (; current_entry < used_entries && current_length <= 32; ++current_length) {\n\n                unsigned i, number;\n\n\n\n                av_dlog(NULL, \" number bits: %u \", ilog(entries - current_entry));\n\n\n\n                number = get_bits(gb, ilog(entries - current_entry));\n\n\n\n                av_dlog(NULL, \" number: %u\\n\", number);\n\n\n\n                for (i = current_entry; i < number+current_entry; ++i)\n\n                    if (i < used_entries)\n\n                        tmp_vlc_bits[i] = current_length;\n\n\n\n                current_entry+=number;\n\n            }\n\n            if (current_entry>used_entries) {\n\n                av_log(vc->avctx, AV_LOG_ERROR, \" More codelengths than codes in codebook. \\n\");\n\n                ret = AVERROR_INVALIDDATA;\n\n                goto error;\n\n            }\n\n        }\n\n\n\n        codebook_setup->lookup_type = get_bits(gb, 4);\n\n\n\n        av_dlog(NULL, \" lookup type: %d : %s \\n\", codebook_setup->lookup_type,\n\n                codebook_setup->lookup_type ? \"vq\" : \"no lookup\");\n\n\n\n// If the codebook is used for (inverse) VQ, calculate codevectors.\n\n\n\n        if (codebook_setup->lookup_type == 1) {\n\n            unsigned i, j, k;\n\n            unsigned codebook_lookup_values = ff_vorbis_nth_root(entries, codebook_setup->dimensions);\n\n\n\n            float codebook_minimum_value = vorbisfloat2float(get_bits_long(gb, 32));\n\n            float codebook_delta_value   = vorbisfloat2float(get_bits_long(gb, 32));\n\n            unsigned codebook_value_bits = get_bits(gb, 4) + 1;\n\n            unsigned codebook_sequence_p = get_bits1(gb);\n\n\n\n            av_dlog(NULL, \" We expect %d numbers for building the codevectors. \\n\",\n\n                    codebook_lookup_values);\n\n            av_dlog(NULL, \"  delta %f minmum %f \\n\",\n\n                    codebook_delta_value, codebook_minimum_value);\n\n\n\n            for (i = 0; i < codebook_lookup_values; ++i) {\n\n                codebook_multiplicands[i] = get_bits(gb, codebook_value_bits);\n\n\n\n                av_dlog(NULL, \" multiplicands*delta+minmum : %e \\n\",\n\n                        (float)codebook_multiplicands[i] * codebook_delta_value + codebook_minimum_value);\n\n                av_dlog(NULL, \" multiplicand %u\\n\", codebook_multiplicands[i]);\n\n            }\n\n\n\n// Weed out unused vlcs and build codevector vector\n\n            codebook_setup->codevectors = used_entries ? av_mallocz(used_entries *\n\n                                                                    codebook_setup->dimensions *\n\n                                                                    sizeof(*codebook_setup->codevectors))\n\n                                                       : NULL;\n\n            for (j = 0, i = 0; i < entries; ++i) {\n\n                unsigned dim = codebook_setup->dimensions;\n\n\n\n                if (tmp_vlc_bits[i]) {\n\n                    float last = 0.0;\n\n                    unsigned lookup_offset = i;\n\n\n\n                    av_dlog(vc->avctx, \"Lookup offset %u ,\", i);\n\n\n\n                    for (k = 0; k < dim; ++k) {\n\n                        unsigned multiplicand_offset = lookup_offset % codebook_lookup_values;\n\n                        codebook_setup->codevectors[j * dim + k] = codebook_multiplicands[multiplicand_offset] * codebook_delta_value + codebook_minimum_value + last;\n\n                        if (codebook_sequence_p)\n\n                            last = codebook_setup->codevectors[j * dim + k];\n\n                        lookup_offset/=codebook_lookup_values;\n\n                    }\n\n                    tmp_vlc_bits[j] = tmp_vlc_bits[i];\n\n\n\n                    av_dlog(vc->avctx, \"real lookup offset %u, vector: \", j);\n\n                    for (k = 0; k < dim; ++k)\n\n                        av_dlog(vc->avctx, \" %f \",\n\n                                codebook_setup->codevectors[j * dim + k]);\n\n                    av_dlog(vc->avctx, \"\\n\");\n\n\n\n                    ++j;\n\n                }\n\n            }\n\n            if (j != used_entries) {\n\n                av_log(vc->avctx, AV_LOG_ERROR, \"Bug in codevector vector building code. \\n\");\n\n                ret = AVERROR_INVALIDDATA;\n\n                goto error;\n\n            }\n\n            entries = used_entries;\n\n        } else if (codebook_setup->lookup_type >= 2) {\n\n            av_log(vc->avctx, AV_LOG_ERROR, \"Codebook lookup type not supported. \\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n\n\n// Initialize VLC table\n\n        if (ff_vorbis_len2vlc(tmp_vlc_bits, tmp_vlc_codes, entries)) {\n\n            av_log(vc->avctx, AV_LOG_ERROR, \" Invalid code lengths while generating vlcs. \\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n        codebook_setup->maxdepth = 0;\n\n        for (t = 0; t < entries; ++t)\n\n            if (tmp_vlc_bits[t] >= codebook_setup->maxdepth)\n\n                codebook_setup->maxdepth = tmp_vlc_bits[t];\n\n\n\n        if (codebook_setup->maxdepth > 3 * V_NB_BITS)\n\n            codebook_setup->nb_bits = V_NB_BITS2;\n\n        else\n\n            codebook_setup->nb_bits = V_NB_BITS;\n\n\n\n        codebook_setup->maxdepth = (codebook_setup->maxdepth+codebook_setup->nb_bits - 1) / codebook_setup->nb_bits;\n\n\n\n        if ((ret = init_vlc(&codebook_setup->vlc, codebook_setup->nb_bits,\n\n                            entries, tmp_vlc_bits, sizeof(*tmp_vlc_bits),\n\n                            sizeof(*tmp_vlc_bits), tmp_vlc_codes,\n\n                            sizeof(*tmp_vlc_codes), sizeof(*tmp_vlc_codes),\n\n                            INIT_VLC_LE))) {\n\n            av_log(vc->avctx, AV_LOG_ERROR, \" Error generating vlc tables. \\n\");\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    av_free(tmp_vlc_bits);\n\n    av_free(tmp_vlc_codes);\n\n    av_free(codebook_multiplicands);\n\n    return 0;\n\n\n\n// Error:\n\nerror:\n\n    av_free(tmp_vlc_bits);\n\n    av_free(tmp_vlc_codes);\n\n    av_free(codebook_multiplicands);\n\n    return ret;\n\n}\n", "idx": 10175, "substitutes": {"vc": ["plugin", "hw", "wd", "ctx", "rt", "ll", "service", "xc", "vt", "cs", "nc", "api", "cdn", "voc", "wx", "serv", "bc", "wcs", "cci", "c", "gg", "db", "qt", "sv", "ant", "rc", "cat", "VC", "vg", "input", "cy", "ic", "cu", "ctrl", "vr", "wl", "ht", "vd", "uv", "dk", "cc", "cli", "iv", "fc", "dc", "cv", "lv", "vm", "v", "bb", "client", "nv", "cmd", "ci", "cf", "vp", "fw", "sys", "util", "lc", "nt", "vv", "data", "cache"], "cb": ["abi", "ctr", "abc", "callback", "buf", "nc", "ff", "tell", "nb", "bc", "confirmed", "gg", "seq", "c", "pb", "db", "cmp", "lb", "eb", "sb", "node", "rc", "config", "cgi", "kb", "cur", "loc", "b", "cell", "fb", "cm", "kk", "cp", "kw", "ctrl", "cor", "hh", "obb", "uv", " rc", "rb", "url", "code", "cv", "dc", "client", "hub", "bb", " callback", "abb", "cmd", "cf", "lib", "sync", "buff", "cod", "func", "CV", "tc", "ob", "cn", "lc", " bc", "wb", "CB", "uc", "batch", "gc", "bf", "dt", "cd"], "tmp_vlc_bits": ["tmp_vlc_pieces", "tmp_vlci_pieces", "tmp_vlc__codes", "tmp_vllc_bits", "tmp_vlci_codes", "tmp_vllc_locks", "tmp_vllc__bits", "tmp_vlc2bits", "tmp_vllc_codes", "tmp_vlc__pieces", "tmp_vlci_bits", "tmp_vllc__pieces", "tmp_vlc_locks", "tmp_vlc__bits", "tmp_vllc__codes", "tmp_vlci_locks", "tmp_vlc2locks", "tmp_vlc2pieces", "tmp_vllc__locks", "tmp_vlc2codes", "tmp_vlc__locks", "tmp_vllc_pieces"], "tmp_vlc_codes": ["tmp_vlc2odes", "tmp_vlci_lines", "tmp_vllc_code", "tmp_vlc__code", "tmp_vlc_code", "tmp_vlci_code", "tmp_vlc__codes", "tmp_vlc__flags", "tmp_vlci_odes", "tmp_vllc_bits", "tmp_vlci_codes", "tmp_vlc2flags", "tmp_vlc2bits", "tmp_vlci_flags", "tmp_vlc__odes", "tmp_vllc_odes", "tmp_vllc_codes", "tmp_vlci_bits", "tmp_vlc_flags", "tmp_vlc2code", "tmp_vlc_lines", "tmp_vlc_odes", "tmp_vlc2codes"], "gb": ["Gb", "ga", "hw", "hd", "ctx", "bm", "gnu", "bn", "gam", "GB", "gram", "gm", "nb", "rg", "bc", "gg", "gu", "pb", "gd", "pc", "db", "lb", "eb", "usb", "gold", "sb", "yg", "cgi", "kb", "vg", "sg", "gy", "mb", "gz", "cm", "bg", "cfg", "uv", "rb", "gt", "cv", "hub", "fc", "bb", "ui", "gp", "abb", "gin", "gpu", "ci", "agg", "lib", "buff", "gs", "storage", "wb", "py", "gc", "bf"], "codebook_multiplicands": ["codebook_multipliscAND", "codebook_multiplicand", "codebook_multiplacand", "codebook_multiplicants", "codebook_multiplicityants", "codebook_multiplocanders", "codebook_multipliccides", "codebook_multiplicads", "codebook_multiplacides", "codebook_multicants", "codebook_multicityants", "codebook_multiplocand", "codebook_multiplicityand", "codebook_multiplificand", "codebook_multiplicAND", "codebook_multacand", "codebook_multiplificads", "codebook_multacads", "codebook_multicanders", "codebook_multipliscand", "codebook_multiplicides", "codebook_multiplacAND", "codebook_multacanders", "codebook_multicityAND", "codebook_multiplocads", "codebook_multacands", "codebook_multicityands", "codebook_multipliccands", "codebook_multicands", "codebook_multicAND", "codebook_multicityand", "codebook_multiplificanders", "codebook_multiplicityAND", "codebook_multipliscands", "codebook_multicand", "codebook_multiplicityides", "codebook_multiplacads", "codebook_multipliccand", "codebook_multiplificands", "codebook_multiplacands", "codebook_multiplacants", "codebook_multiplocands", "codebook_multiplacanders", "codebook_multiplicityands", "codebook_multipliccAND", "codebook_multicads", "codebook_multipliscants", "codebook_multiplicanders"], "codebook_setup": ["codebook_reset", "codeblock_set", "codebooks_sett", "codebookallset", "codebook_select", "codebook___sett", "codebook_ctx", "codebook_config", "codebookallselect", "codebook_construct", "codebookPconstruct", "codebooks_Setup", "codeblock_init", "codebook_sett", "codebook___Setup", "codebookPset", "codebookFSetup", "codebook_Setup", "codeblock_boot", "codebooks_construct", "codebooks_config", "codebookallsetup", "codebooks_setup", "codebooks_select", "codebooks_set", "codebookFsetup", "codebooks_reset", "codeblock_setup", "codebookFctx", "codebookallconstruct", "codebook_boot", "codebookPsetup", "codebook_init", "codebook_set", "codebookPselect", "codebook___setup"], "ordered": [" rec", "g", " ref", "id", "bc", "gg", " row", "seq", " dc", " resp", "rc", "cat", "bg", " rc", "rb", "cv", " rg", "row", "bb", " callback", "val", " rows", "bf", " acc", " bc", "CB", "py", " arr", " tid"], "t": ["g", "T", "f", "type", "att", "c", "len", "trial", "ts", "p", "back", "b", "total", "ext", "tn", "v", "ti", "r", "wt", "m", "e", "n", "tt", "port", " ret", "s", "dt"], "entries": ["gestrys", "detensions", "countries", "entures", "detresses", " entresses", "counties", "Enties", "countrys", "renties", "antensions", "gestensions", "intures", "inties", "enties", "Entures", "ntrys", "rentries", "rentensions", " entrys", "gestrations", "detries", "entensions", " entensions", "rentures", "entresses", "ntensions", "antried", "anties", "Entresses", "intensions", "ntries", "Entries", "antrys", "ntrations", "antrations", "entried", "intries", "gestries", "Entrys", "countried", "Entried", "entrations", "detrys", "entrys", "antries", "Entensions"], "used_entries": ["used_gestions", "used_rentrows", "used_entions", "used_ties", "used_gestries", "used_entrows", "used_trows", "used_enties", "used_rentries", "used_rentions", "used_renties", "used_tries", "used_tions", "used_gestrows", "used_gesties"]}}
{"project": "qemu", "commit_id": "338c25b6929b5436a42aaa106c7e9136cf1ff4dc", "target": 1, "func": "static int htab_save_later_pass(QEMUFile *f, sPAPREnvironment *spapr,\n\n                                int64_t max_ns)\n\n{\n\n    bool final = max_ns < 0;\n\n    int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64;\n\n    int examined = 0, sent = 0;\n\n    int index = spapr->htab_save_index;\n\n    int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n\n\n    assert(!spapr->htab_first_pass);\n\n\n\n    do {\n\n        int chunkstart, invalidstart;\n\n\n\n        /* Consume non-dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && !HPTE_DIRTY(HPTE(spapr->htab, index))) {\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        chunkstart = index;\n\n        /* Consume valid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        invalidstart = index;\n\n        /* Consume invalid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && !HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        if (index > chunkstart) {\n\n            int n_valid = invalidstart - chunkstart;\n\n            int n_invalid = index - invalidstart;\n\n\n\n            qemu_put_be32(f, chunkstart);\n\n            qemu_put_be16(f, n_valid);\n\n            qemu_put_be16(f, n_invalid);\n\n            qemu_put_buffer(f, HPTE(spapr->htab, chunkstart),\n\n                            HASH_PTE_SIZE_64 * n_valid);\n\n            sent += index - chunkstart;\n\n\n\n            if (!final && (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) {\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (examined >= htabslots) {\n\n            break;\n\n        }\n\n\n\n        if (index >= htabslots) {\n\n            assert(index == htabslots);\n\n            index = 0;\n\n        }\n\n    } while ((examined < htabslots) && (!qemu_file_rate_limit(f) || final));\n\n\n\n    if (index >= htabslots) {\n\n        assert(index == htabslots);\n\n        index = 0;\n\n    }\n\n\n\n    spapr->htab_save_index = index;\n\n\n\n    return (examined >= htabslots) && (sent == 0) ? 1 : 0;\n\n}\n", "idx": 10180, "substitutes": {"f": ["F", "fen", "g", "fr", "fn", "tf", "xf", "file", "ff", "fi", "sf", "c", "elf", "i", "fe", "d", "p", "rf", "b", "fm", "fs", "fb", "files", "feed", "fp", "v", "framework", "fc", "t", "df", "r", "af", "uf", "l", "cf", "fo", "form", "w", "m", "conf", "func", "e", "fw", "this", "s", "fd", "bf", "exec"], "spapr": ["slapr", "chapar", "sppplr", "spafr", "Spapsran", "chopr", "spappr", "Spapr", "yparprar", "ypaprar", "spamprin", "asphapri", "spakrb", "Spaper", "spafra", "spappri", "sparprar", "asphapru", "spampran", "spAPrb", "spapril", "spippr", "spapplr", "spaperrb", "spapener", "spepru", "spapran", "sessionapr", "scapsR", "spAPr", "sparprc", "spajr", "spapprb", "spaptrar", "scapsrc", "spopr", "spaperR", "scappr", "spAPrc", "scapr", "sphapri", "aspapri", "spaprar", "sparpner", "pAPrb", "scapR", "spacril", "spaptr", "scaprg", "spaprin", "spavrc", "spaperc", "slarprc", "sessionaplr", "spapsr", "spaprs", "spappner", "ypaprc", "spapR", "sppprs", "ypapra", "spaperr", "chaprar", "speplr", "sessionppr", "spppr", "spapersr", "sparprg", "spakrn", "spashrar", "spafrc", "scappru", "spaprb", "spapprg", "spashrn", "spAPR", "spavrb", "asphapr", "spapra", "pAPR", "chopril", "Spapener", "sessionpprs", "asphaprs", "spacrar", "spapsran", "sphapr", "aspapru", "scaprb", "spappsr", "spaprn", "spakrc", "aspaprs", "scaprn", "spapru", "Spaprb", "spakr", "spaptar", "Spaprc", "spacr", "spaptril", "sphaprs", "sessionppru", "Spapsr", "spapner", "papsr", "scapprg", "spAPrn", "paprb", "scapra", "spapprs", "spajrar", "spavr", "ypapner", "ypapr", "slaprc", "spppru", "scapprb", "spipprin", "spampr", "spapprc", "scapprn", "scapprc", "spopar", "spaptri", "Spaperc", "pAPsr", "spafR", "spapri", "scapru", "spaprc", "spapsri", "scapsra", "spepr", "sparprn", "slapri", "spaperb", "spacar", "speprs", "chapril", "sparpra", "spavner", "spippran", "sppprg", "sparpru", "pAPr", "spashra", "papR", "spaplr", "spaptru", "yparpra", "sppprc", "spapsR", "choprar", "spashr", "spajrn", "spoprar", "Spapsrin", "ypaprn", "spapsrc", "spappra", "spapar", "spajra", "spapprn", "spacrc", "spappru", "spacra", "yparprn", "spacner", "spaptrs", "yparpr", "aspapr", "spopril", "scaprc", "slarpr", "Spaprin", "yparprc", "chopar", "spaper", "papr", "scapsr", "spaprg", "sessionaprs", "spAPra", "spapsrin", "sessionapru", "Spapner", "sparpr", "sparpri", "slarpri", "yparpner", "sphapru", "chapr", "Spaperb", "spAPsr", "spapsra", "sessionpplr", "Spapran", "spappR"], "max_ns": ["maxFns", "maxFls", "max_bs", "max_mins", "max_rss", "max_nas", "maxFnas", " max_bs", " max_mins", " max_rss", " max_ls", "max__rss", "max__ls", "max_ls", " max_nas", "maxFbs", "max__mins", "max__ns"], "chunkstart": ["hunkstart", "Chunksend", "chiffstarting", "chanstop", "chiffstart", "Chunkset", " Chanstart", "chiffstop", "chashstop", "chaultstarting", "Chunksstart", "chackst", " chorkpad", "chunkst", "chunkpad", "chorkstop", "shunkst", "chacketstart", "chacketend", "chunksize", "chunksset", "hunkset", "shankStart", "chacketpad", "chacketStart", " chaultstarting", " chaultstop", "chankset", " Chanstop", "chorkstyle", "chunksstart", "chipstart", " chunkstyle", "hacketset", "ChunksStart", "chunkinit", " Chunkstop", "hacketend", "shunkstart", "chipend", "chacketset", "chorkstart", " chunkstarting", "Chunkstart", "chipset", "chackstart", " chunkinit", "Chunkend", "chacketinit", "chorkstarting", "shankst", "chacketstop", " chorkinit", "chackStart", "chunksend", "chiffstyle", " chaultstyle", "Chunksset", "chunkssize", "chipStart", "hacketstart", "chacksize", "chankst", "shunkend", "chankend", "shankend", " chorkstop", "chaultstart", "chacketsize", " chorkstart", "chunkend", "chunksStart", " chaultstart", "chunkStart", "chankStart", "chanend", "shankstart", " chunkstop", "hacketStart", "chackend", "chorkpad", "Chunksize", "chanstart", "chaultstop", "chunksstop", "chashpad", "shunkStart", "chunkstop", "chashstart", "chunkstarting", "chashinit", "Chunkssize", "chankstart", "hunkStart", "chaultstyle", "chackset", "chunkset", " ChunkStart", "chunkstyle", " chunkpad", " Chanend", "hunkend", "chanStart", " Chunkend", " Chunkstart", " ChanStart", "chorkinit", "ChunkStart"], "invalidstart": ["nvalidstart", "inlegalset", " invalidStart", "Incompletestar", "infreshstart", "incompleteset", "inlegalStart", "inbadindex", "incompleteend", "insecurestart", "Invalidstar", "Invalidstart", "incompatiblestarted", "inbrokenoffset", "inregularset", "INvalidoffset", "INcompatiblestart", " invalidindex", "inbrokenset", "invalidend", "nvalend", "inbrokenStart", "nvalidstop", "INcompatibleoffset", "incompatibleoffset", "inasticoffset", "inbrokenindex", "INcompatibleindex", "invalidindex", "invalend", "INvalidstart", " inbrokenstart", "invalidset", "Invalidset", "invalidStart", "nvalidend", " inbrokenStart", "inregularend", "invalidstarted", "inasticend", " inbrokenset", "Invalidend", "Incompleteset", "Incompletestart", "invalidoffset", "insecureend", "invaloffset", "inasticstop", "INvalidstarted", "inbadset", "inregularstar", "incompleteoffset", "inbrokenstarted", "INcompatiblestarted", "invalidstar", "INvalidindex", "nvaloffset", "inlegalindex", " invalidset", "nvalstart", "inbadstart", "invalstop", "insecureset", "inlegalstart", "nvalstop", "nvalidoffset", "invalidstop", "Incompleteend", "incompletestart", "inbrokenstart", "insecurestar", "inbadStart", "incompletestop", "inregularstart", "infreshstarted", "incompatiblestart", "incompatibleindex", "inasticstart", "incompletestar", "invalstart", " inbrokenindex", "infreshindex", "infreshoffset"], "index": ["axis", "online", "example", "connection", "alpha", "option", "available", "i", "open", "key", "address", "opened", "old", "form", "root", "page", "id", "weight", "view", "update", "second", "search", "connect", "end", "run", "thread", "active", "num", "length", "error", "dim", "column", "set", "section", "list", "action", "connected", "de", "block", "diff", "date", "engine", "len", "route", "config", "document", "updated", "total", "socket", "ticket", "part", "expression", "add", "ind", "insert", "point", "start", "sync", "body", "current", "value", "name", "count", "x", "ix", "pos", "version", "find", "Index", "type", "request", "match", "path", "output", "found", "ini", "temp", "offset", "input", "condition", "si", "loc", "pattern", "position", "context", "original", "inc", "initial", "unit", "n", "fix", "element", "localhost", "slice", "cache"], "examined": ["exasmined", " examritten", "exambmented", "ExAMined", "exameined", " exambmented", "examinining", "exameided", " exumine", "exambining", "exambided", "Examine", "examided", "examinine", "exasminated", " examinated", "exAMritten", " exammented", "xambinated", "exummented", " examine", "exambined", "exambritten", " exambinated", "exambored", "xamined", "exasmritten", "exammented", "exAMined", "xambided", "Examored", " exambined", " exummented", "exAMided", "xamine", "examine", "examinined", "examritten", "examining", "xamided", "xaminated", "Examined", "xambined", "exambinated", "examinated", "exAMmented", "exAMine", "exumine", "exuminated", "exAMinated", "examored", "ExAMine", " exuminated", "exameine", "exameinated", "exambine", "exasmmented", "xambine", "examinored", "exumined", " exambritten", "ExAMining", " exumined", "exAMored", "exAMining", "Examining", "ExAMored"]}}
{"project": "qemu", "commit_id": "6c5b5645ae0b73c052df962e18e48d87bb7385e0", "target": 0, "func": "static abi_long do_socket(int domain, int type, int protocol)\n\n{\n\n    int target_type = type;\n\n    int ret;\n\n\n\n    ret = target_to_host_sock_type(&type);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (domain == PF_NETLINK)\n\n        return -TARGET_EAFNOSUPPORT;\n\n\n\n    if (domain == AF_PACKET ||\n\n        (domain == AF_INET && type == SOCK_PACKET)) {\n\n        protocol = tswap16(protocol);\n\n    }\n\n\n\n    ret = get_errno(socket(domain, type, protocol));\n\n    if (ret >= 0) {\n\n        ret = sock_flags_fixup(ret, target_type);\n\n        if (type == SOCK_PACKET) {\n\n            /* Manage an obsolete case :\n\n             * if socket type is SOCK_PACKET, bind by name\n\n             */\n\n            fd_trans_register(ret, &target_packet_trans);\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 10190, "substitutes": {"domain": ["server", "plugin", "version", "uri", "prefix", "file", "mode", "format", "site", "id", "host", "example", "class", "dom", "table", "mid", "controller", "module", "db", "feature", "cart", "model", "category", "net", "range", "title", "Domain", "flag", "core", "country", "rule", "key", "address", "code", "magic", "bot", "parent", "dn", "channel", "handler", "cmd", "command", "force", "brand", "count", "component", "conf", "base", "unit", "origin", "cn", "ype", "root", "name", "role", "target", "dir"], "type": ["server", "plugin", "like", "version", "file", "id", "format", "site", "api", "ref", "state", "host", "typ", "class", "table", "y", "module", "method", "p", "Type", "url", "style", "test", "TYPE", "rule", "part", "key", "address", "pe", "op", "target", "parent", "client", "t", "o", "platform", "kind", "link", "ty", "base", "unit", "port", "info", "value", "null", "ype", "name", "role", "py", "ping", "none", "types", "field"], "protocol": ["Protect", "inetocol", "pathect", "ocolurl", "topport", "lifport", "typeotype", "statocol", " protose", "pathotype", "statotype", "ocolotype", "platformport", "protport", "proticle", "platformocol", "protect", "lifose", "pathocol", "Proticle", "typeect", "topicle", " prototype", "Protocol", "topocol", "protose", "proturl", "typeocol", "Protose", "inetect", " protport", "staturl", "ocolocol", "inetotype", " protect", "Protport", " proturl", "lifect", "platformicle", "lifocol", "prototype"], "ret": ["rt", "re", "RET", "ref", "err", "success", "art", "rc", "sp", "nat", "mem", "pet", "rep", "job", "arg", "pat", "info", "nt", "alt", "Ret", "status", "pass", "rets", "repl", "rev", "result", "db", "sr", "sb", "cat", "back", "lit", "flag", "run", "mt", "code", "active", "det", "base", "res", "reg", "str", "sur", "valid", "f", "att", "format", "resp", "len", "en", "fab", "fun", "fire", "part", "std", "reply", "fit", "sys", "value", "py", "match", "fi", "bare", "ft", "addr", "al", "net", "url", "ext", "bit", "gt", "opt", "val", "def", "obj", "pret", "bf", "data"]}}
{"project": "qemu", "commit_id": "1a61a9ae61cdf7b7d24c3eb711fe772c196c235e", "target": 0, "func": "int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t *hc = (uint32_t*)buf;\n\n\n\n    struct kvm_ppc_pvinfo pvinfo;\n\n\n\n    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&\n\n        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {\n\n        memcpy(buf, pvinfo.hcall, buf_len);\n\n\n\n        return 0;\n\n    }\n\n\n\n    /*\n\n     * Fallback to always fail hypercalls:\n\n     *\n\n     *     li r3, -1\n\n     *     nop\n\n     *     nop\n\n     *     nop\n\n     */\n\n\n\n    hc[0] = 0x3860ffff;\n\n    hc[1] = 0x60000000;\n\n    hc[2] = 0x60000000;\n\n    hc[3] = 0x60000000;\n\n\n\n    return 0;\n\n}\n", "idx": 10192, "substitutes": {"env": ["server", "np", "dict", "loader", "args", "eve", "anc", "eng", "err", "ea", "exc", "proc", "serv", "en", "eu", "config", "ev", "enc", "ace", "visor", "fs", "runner", "ext", "context", "core", "cfg", "cli", "viron", "environment", "que", "req", "conn", "virt", "conf", "obj", "init", "e", "ec", "eni", "priv", "exec", "exe", "esp", "cache"], "buf": ["cas", "ctx", "pool", "vec", "ref", "ff", "fi", "bc", "bag", "seq", "pb", "len", "rc", "config", "cb", "b", "blocks", "fb", "cp", "Buff", "queue", "feed", "rb", "bd", "array", "cv", "mem", "alloc", "br", "que", "Buffer", "cmd", "uf", "mac", "cf", "buff", "buffer", "func", "base", "msg", "uc", "fd", "raw", "batch", "data"], "buf_len": [" buf_val", "bufssize", "bufspos", "bufslength", "bufsval", "buf_val", " buf_pos", "buf_length", "bufsdl", " buf_dl", "buflendl", "bufslen", "buflenlength", "buflenlen", "buflenpos", "buf_pos", "buf_size", "buf_dl", " buf_length", " buf_size"], "cpu": ["np", "linux", "hw", "ctx", "pai", " cp", "nc", "cow", "proc", "bc", "c", "pc", "instance", "computer", "pu", "rc", "cpp", "CPU", "px", "cp", "cu", "core", "css", "vm", "bench", "gpu", "cf", "conn", "cus", "uci", "cn", "lc", "mc", "cca", "processor", "pid", "cache"], "cs": ["ics", "utils", "os", "ctx", "ls", "nc", "bc", "vc", "c", "pc", "ca", "ks", "co", "ck", "ds", "fs", "cp", "acs", "CS", "bs", "cc", "ns", "cms", "spec", "css", "ps", "qs", "cf", "conn", "sc", "sync", "ci", "cus", "gs", "sys", "cn", "lc", "mc", "cons", "sk", "ec", "vs", "Cs"], "hc": ["ohc", "rhc", "hardcf", "rhcu", "whcu", "Hcs", "ohcu", "hpc", "hv", "hcall", "hardpc", "Hc", "hcf", "hhcs", "whc", "hcs", "whec", " hrc", "hardcu", " hcf", "hf", "hec", "ohpc", " hcu", "hhcall", "hrc", "rhrc", " hcs", "khcu", " hec", " hv", " hpc", "ohv", "hlc", " hf", "hardc", " hcall", "Hpc", "khec", "qcu", "qf", "khf", "khc", "qrc", " hlc", "whf", "Hv", "hcu", "Hlc", "qc", "hhc", "ohlc", "hhpc", "ohcf", "rhf", "Hcall"], "pvinfo": [" pwinfi", "pvinf", "pdenf", " pinfo", "pvinco", " pvinfi", " pvinf", "pinfo", "pvinfam", "pevinbo", " pvininfo", "pwinf", " pevinfo", " pininfo", "pvinfi", "pdenfam", "pdenfi", "pininfo", "pvininfo", "pinf", "pevinfo", "pevinf", "pcinfo", "pevininfo", "pcinf", " pevinco", "pcinbo", "pdenfo", "pwinfo", " pwinfam", " pwinf", "pcinco", "pwininfo", " pevininfo", "pwinco", " pevinf", "pvinbo", " pinf", "pevinfam", " pvinfam", "pevinfi", "pinbo", "pevinco", " pvinbo", "pwinfam", " pinbo", " pvinco", "pwinfi", " pwinfo", "pcininfo"]}}
{"project": "qemu", "commit_id": "1bcef683bf840a928d633755031ac572d5fdb851", "target": 0, "func": "void process_incoming_migration(QEMUFile *f)\n\n{\n\n    if (qemu_loadvm_state(f) < 0) {\n\n        fprintf(stderr, \"load of migration failed\\n\");\n\n        exit(0);\n\n    }\n\n    qemu_announce_self();\n\n    DPRINTF(\"successfully loaded vm state\\n\");\n\n\n\n    incoming_expected = false;\n\n\n\n    if (autostart) {\n\n        vm_start();\n\n    } else {\n\n        runstate_set(RSTATE_PRE_LAUNCH);\n\n    }\n\n}\n", "idx": 10194, "substitutes": {"f": ["F", "fen", "g", "fr", "fn", "tf", "file", "ref", "ff", "fi", "sf", "proc", "inf", "c", "i", "p", "rf", "b", "fm", "fb", "fs", "files", "feed", "fa", "fp", "fc", "v", "t", "df", "af", "l", "fo", "m", "e", "fw", "info", "fd", "exec"]}}
{"project": "FFmpeg", "commit_id": "979bea13003ef489d95d2538ac2fb1c26c6f103b", "target": 0, "func": "static int rv40_decode_mb_info(RV34DecContext *r)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    GetBitContext *gb = &s->gb;\n\n    int q, i;\n\n    int prev_type = 0;\n\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n\n    int blocks[RV34_MB_TYPES] = {0};\n\n    int count = 0;\n\n\n\n    if(!r->s.mb_skip_run)\n\n        r->s.mb_skip_run = svq3_get_ue_golomb(gb) + 1;\n\n\n\n    if(--r->s.mb_skip_run)\n\n         return RV34_MB_SKIP;\n\n\n\n    if(r->avail_cache[6-1])\n\n        blocks[r->mb_type[mb_pos - 1]]++;\n\n    if(r->avail_cache[6-4]){\n\n        blocks[r->mb_type[mb_pos - s->mb_stride]]++;\n\n        if(r->avail_cache[6-2])\n\n            blocks[r->mb_type[mb_pos - s->mb_stride + 1]]++;\n\n        if(r->avail_cache[6-5])\n\n            blocks[r->mb_type[mb_pos - s->mb_stride - 1]]++;\n\n    }\n\n\n\n    for(i = 0; i < RV34_MB_TYPES; i++){\n\n        if(blocks[i] > count){\n\n            count = blocks[i];\n\n            prev_type = i;\n\n        }\n\n    }\n\n    if(s->pict_type == AV_PICTURE_TYPE_P){\n\n        prev_type = block_num_to_ptype_vlc_num[prev_type];\n\n        q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1);\n\n        if(q < PBTYPE_ESCAPE)\n\n            return q;\n\n        q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1);\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Dquant for P-frame\\n\");\n\n    }else{\n\n        prev_type = block_num_to_btype_vlc_num[prev_type];\n\n        q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1);\n\n        if(q < PBTYPE_ESCAPE)\n\n            return q;\n\n        q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1);\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Dquant for B-frame\\n\");\n\n    }\n\n    return 0;\n\n}\n", "idx": 10213, "substitutes": {"r": ["tr", "g", "usr", "fr", "nor", "rt", "f", "nr", "re", "hr", "err", "self", "ur", "result", "rg", "ra", "c", "mr", "sr", "d", "dr", "rc", "rss", "pr", "p", "wr", "ru", "rd", "h", "per", "lr", "rf", "b", "R", "ar", "rb", "v", "br", "t", "kr", "o", "l", "ir", "cr", "w", "m", "gr", "e", "er", "rs", "rr", "res", "rh", "rar", "or", "str"], "s": ["server", "sym", "service", "cs", "self", "c", "a", "ks", "d", "settings", "b", "down", "gs", "w", "e", "rs", "js", "os", "site", "ls", "ss", "sq", "sr", "params", "sb", "rows", "h", "http", "S", "session", "ds", "fs", "ssl", "z", "o", "ses", "sc", "submit", "er", "port", "res", "sec", "f", "sf", "inf", "y", "en", "an", "services", "sg", "secondary", "sl", "v", "ps", "l", "u", "sync", "south", "sing", "sys", "su", "rates", "support", "g", "args", "side", "is", "sup", "es", "p", "ts", "ed", "si", "se", "ns", "less", "spec", "share", "us", "sy", "t", "m", "conf", "n", "storage", "stats", "ops"], "gb": ["binary", "g", "ga", "pg", "ctx", "bm", "gam", "GB", "gram", "gm", "nb", "rg", "bc", "gg", "pb", "gd", "db", "pc", "eb", "usb", "sb", "rc", "cb", "kb", "vg", "tm", "sg", "bridge", "gl", "gy", "mb", "cm", "bg", "ub", "cfg", "rb", "cv", "hub", "vm", "bb", "ui", "gp", "abb", "gin", "gpu", "sc", "git", "gs", "buffer", "ge", "storage", "mc", "bp", "gc", "bf", "gru", "hm"], "q": ["g", "f", "type", "id", "iq", "comment", "max", "k", "ue", " p", "quality", "ce", "y", "c", "sq", "qt", "d", "config", "h", "p", "cur", "offset", "b", "qa", "queue", "dq", "ct", "bit", "question", "Q", "z", " query", "v", "code", "ch", "qi", "t", "o", "que", "eq", "qs", "l", "cl", "u", "req", "w", "query", "qu", "e", "n", "ime", "qq", "value", "quant", "bug", "count"], "i": ["ii", "g", "ni", "li", "hi", "type", "f", "id", "phi", "I", "diff", "k", "ip", "oi", "mi", "fi", "chi", "y", "c", "iu", "ini", "d", "multi", "p", "si", "b", "pi", "io", "j", "gi", "ie", "part", "di", "v", "zi", "bi", "xi", "ti", "qi", "ui", "t", "o", "l", "ci", "u", "index", "start", "m", "e", "n", "info", "init", "ai", "mini", "eni", "count", "x", "ix", "it"], "blocks": ["block", "cycles", "groups", "waves", "shows", "views", "bars", "values", "checks", "breakers", "rooms", "items", "ins", "times", "rows", "flows", "bytes", "works", "cb", "girls", "lines", "outs", "runs", "results", "guards", "nos", "pages", "files", "objects", "units", "balls", "limits", "rules", "bands", "bs", "types", "loads", "ions", "sections", "stores", "maps", "images", "bags", "errors", "stars", "frames", "jobs", "plugins", "words", "boxes", "bits", "books", "ocks", "lbs", "heads", "Blocks", "holes", "locks", "stats", "BL", "builders"], "mb_skip_run": ["mb_run_unit", "mb_run_runs", "mb_skip_pos", "mb_skip_runs", "mb_skippnum", "mb_run_pos", "mb_skip_unit", "mb_skipppos", "mb_skip_type", "mb_skip_min", "mb_run_type", "mb_skipactunit", "mb_skip_start", "mb_skipayrun", "mb_skip_num", "mb_run_min", "mb_skipactrun", "mb_skipaystart", "mb_skipacttype", "mb_skip_runner", "mb_run_runner", "mb_skipayruns", "mb_skipprun", "mb_run_run", "mb_skippruns", "mb_skipactrunner", "mb_run_start", "mb_run_num", "mb_skipaymin"], "mb_type": ["phrase_type", "mbpptype", "mbplshape", "mb_style", "mbpltotal", "mbjfamily", "mb_shape", "ym_pos", "ambjtype", "mbppnumber", "amb_number", "ambjnumber", "mbjtype", "mp_cache", "mbppshape", "mbpltype", "phrasepltype", "amb_types", "ambjtypes", "mbpptotal", "mbpnumber", "mb_total", "mbpshape", "mb_types", "mbuchpos", "ym_type", "mb_model", "phraseplshape", "ym_model", "mb_number", "ambjfamily", "mb_cache", "mp_type", "mbptype", "mbppcache", "phrase_number", "mbjnumber", "amb_family", "mbuchtype", "phrasepltotal", "phrase_total", "ym_position", "mbuchposition", "mb_family", "mbjtypes", "mb_position", "mbptotal", "phraseplnumber", "amb_type", "phrase_shape", "mbuchmodel", "mbplnumber", "mbppstyle", "mp_shape", "mp_style"], "mb_pos": ["MB_position", "mbJsin", "mb_unit", "bb_unit", "mbjloc", "bgJpos", "bg_pos", "bb_size", "mbjpos", "mb_offset", "MB_neg", "mbjoffset", "mb_po", "MB_loc", "mb_loc", "bb_len", "mb_neg", "bg_part", "mb_size", "bb_pos", "bb_offset", "bgJlen", "mb_val", "bb_po", "bg_sin", "bg_len", "mb2pos", "bb_loc", "mbJpart", "bgJsin", "mb2val", "mb2offset", "bgJpart", "mbJlen", "mbjval", "mb_sin", "mbJunit", "mbJpos", "bb_pad", "mb_position", "bb_position", "mb_len", "MB_pos", "bb_val", "mb_part", "mb2loc", "mb_pad", "mbJpad"], "mb_stride": ["mb_brade", "mb_strade", "mb_brider", "mb_strride", "mb_blide", "mb_blided", "mb_brision", "mb_distided", "mb_trided", "mb_brage", "mb_brided", "mb_striade", "mb_striided", "mb_brase", "mb_shride", "mb_splage", "mb_splride", "mb_distade", "mb_brid", "mb_strision", "mb_slride", "mb_shrision", "mb_slide", "mb_distase", "mb_splider", "mb_trides", "mb_distide", "mb_trision", "mb_shrid", "mb_tride", "mb_slider", "mb_strides", "mb_brides", "mb_trIDE", "mb_shrided", "mb_striide", "mb_strid", "mb_slage", "mb_striase", "mb_blIDE", "mb_brIDE", "mb_bride", "mb_strage", "mb_strase", "mb_brride", "mb_splide", "mb_strided", "mb_strIDE", "mb_trid", "mb_strider", "mb_blides"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yvu9_to_yuy2)(const uint8_t *src1, const uint8_t *src2, const uint8_t *src3,\n\n                                        uint8_t *dst,\n\n                                        long width, long height,\n\n                                        long srcStride1, long srcStride2,\n\n                                        long srcStride3, long dstStride)\n\n{\n\n    x86_reg x;\n\n    long y,w,h;\n\n    w=width/2; h=height;\n\n    for (y=0;y<h;y++) {\n\n        const uint8_t* yp=src1+srcStride1*y;\n\n        const uint8_t* up=src2+srcStride2*(y>>2);\n\n        const uint8_t* vp=src3+srcStride3*(y>>2);\n\n        uint8_t* d=dst+dstStride*y;\n\n        x=0;\n\n#if COMPILE_TEMPLATE_MMX\n\n        for (;x<w-7;x+=8) {\n\n            __asm__ volatile(\n\n                PREFETCH\"   32(%1, %0)          \\n\\t\"\n\n                PREFETCH\"   32(%2, %0)          \\n\\t\"\n\n                PREFETCH\"   32(%3, %0)          \\n\\t\"\n\n                \"movq      (%1, %0, 4), %%mm0   \\n\\t\" /* Y0Y1Y2Y3Y4Y5Y6Y7 */\n\n                \"movq         (%2, %0), %%mm1   \\n\\t\" /* U0U1U2U3U4U5U6U7 */\n\n                \"movq         (%3, %0), %%mm2   \\n\\t\" /* V0V1V2V3V4V5V6V7 */\n\n                \"movq            %%mm0, %%mm3   \\n\\t\" /* Y0Y1Y2Y3Y4Y5Y6Y7 */\n\n                \"movq            %%mm1, %%mm4   \\n\\t\" /* U0U1U2U3U4U5U6U7 */\n\n                \"movq            %%mm2, %%mm5   \\n\\t\" /* V0V1V2V3V4V5V6V7 */\n\n                \"punpcklbw       %%mm1, %%mm1   \\n\\t\" /* U0U0 U1U1 U2U2 U3U3 */\n\n                \"punpcklbw       %%mm2, %%mm2   \\n\\t\" /* V0V0 V1V1 V2V2 V3V3 */\n\n                \"punpckhbw       %%mm4, %%mm4   \\n\\t\" /* U4U4 U5U5 U6U6 U7U7 */\n\n                \"punpckhbw       %%mm5, %%mm5   \\n\\t\" /* V4V4 V5V5 V6V6 V7V7 */\n\n\n\n                \"movq            %%mm1, %%mm6   \\n\\t\"\n\n                \"punpcklbw       %%mm2, %%mm1   \\n\\t\" /* U0V0 U0V0 U1V1 U1V1*/\n\n                \"punpcklbw       %%mm1, %%mm0   \\n\\t\" /* Y0U0 Y1V0 Y2U0 Y3V0*/\n\n                \"punpckhbw       %%mm1, %%mm3   \\n\\t\" /* Y4U1 Y5V1 Y6U1 Y7V1*/\n\n                MOVNTQ\"          %%mm0,  (%4, %0, 8)    \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 8(%4, %0, 8)    \\n\\t\"\n\n\n\n                \"punpckhbw       %%mm2, %%mm6   \\n\\t\" /* U2V2 U2V2 U3V3 U3V3*/\n\n                \"movq     8(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm6, %%mm0   \\n\\t\" /* Y U2 Y V2 Y U2 Y V2*/\n\n                \"punpckhbw       %%mm6, %%mm3   \\n\\t\" /* Y U3 Y V3 Y U3 Y V3*/\n\n                MOVNTQ\"          %%mm0, 16(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 24(%4, %0, 8)   \\n\\t\"\n\n\n\n                \"movq            %%mm4, %%mm6   \\n\\t\"\n\n                \"movq    16(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm5, %%mm4   \\n\\t\"\n\n                \"punpcklbw       %%mm4, %%mm0   \\n\\t\" /* Y U4 Y V4 Y U4 Y V4*/\n\n                \"punpckhbw       %%mm4, %%mm3   \\n\\t\" /* Y U5 Y V5 Y U5 Y V5*/\n\n                MOVNTQ\"          %%mm0, 32(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 40(%4, %0, 8)   \\n\\t\"\n\n\n\n                \"punpckhbw       %%mm5, %%mm6   \\n\\t\"\n\n                \"movq    24(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm6, %%mm0   \\n\\t\" /* Y U6 Y V6 Y U6 Y V6*/\n\n                \"punpckhbw       %%mm6, %%mm3   \\n\\t\" /* Y U7 Y V7 Y U7 Y V7*/\n\n                MOVNTQ\"          %%mm0, 48(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 56(%4, %0, 8)   \\n\\t\"\n\n\n\n                : \"+r\" (x)\n\n                : \"r\"(yp), \"r\" (up), \"r\"(vp), \"r\"(d)\n\n                :\"memory\");\n\n        }\n\n#endif\n\n        for (; x<w; x++) {\n\n            const long x2 = x<<2;\n\n            d[8*x+0] = yp[x2];\n\n            d[8*x+1] = up[x];\n\n            d[8*x+2] = yp[x2+1];\n\n            d[8*x+3] = vp[x];\n\n            d[8*x+4] = yp[x2+2];\n\n            d[8*x+5] = up[x];\n\n            d[8*x+6] = yp[x2+3];\n\n            d[8*x+7] = vp[x];\n\n        }\n\n    }\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__(\n\n            EMMS\"       \\n\\t\"\n\n            SFENCE\"     \\n\\t\"\n\n            ::: \"memory\"\n\n        );\n\n#endif\n\n}\n", "idx": 10233, "substitutes": {"src1": [" src01", "loc3", "stA", " srcA", "st01", "source01", "source3", "srcA", "loc2", "source1", "st1", "rc1", "loc1", "st3", "src01", "rc3", "sourceA", "rc2"], "src2": ["source02", "sort2", "sort02", "src02", "constTwo", "sort0", "const2", " src02", "const02", " srcTwo", "rc0", "srcTwo", "src0", "rc2", "rc02", "source2", "sourceTwo", " src0"], "src3": ["rc53", "source53", "src53", "rc5", " src53", "source3", "source5", "source1", "rc1", "rc3", "src5", "rc2", "source2", " src5"], "dst": ["pdost", "dsc", "Dst", " dST", "rdst", "rdsc", "Dconst", "pdST", "Dsts", "rdconst", "dost", " dsts", "dconst", "pdsc", "dST", "dsts", " dost", " dsc", " dconst", "rdsts", "pdst", "Dsc"], "height": ["padding", "hold", "hd", "thin", "size", "layout", "max", "th", "resolution", "dy", "input", "sh", "work", "shape", "img", "direction", "style", "gravity", "z", "v", "image", "density", "crop", "length", "dim", "ty", "fw", "rank", "window", "stroke", "depth", "Height", "inches"], "srcStride1": ["srcScride3", "srcShrideOne", "srcStrueOne", "srcStrip3", "srcStrip1", "srcShrue2", "srcScrite3", "srcStri1", "srcScrite2", "srcShrue3", "srcStrue3", "srcStrue2", "srcStrite3", "srcShride2", "srcStideOne", "srcStrip2", "srcStide2", "srcStri3", "srcScrite1", "srcScride1", "srcStide1", "srcStrite2", "srcShride1", "srcStrite1", "srcShride3", "srcScride2", "srcShrueOne", "srcStrue1", "srcStide3", "srcShrue1", "srcStrideOne", "srcStriteOne", "srcStri2"], "srcStride2": ["srcStrite52", "srcStrid52", "srcStriteTwo", "srcSTrideTwo", "srcStideTwo", "srcStrip1", "srcSTrate8", "srcSTride2", "srcStrateTwo", "srcStrip4", "srcScrite2", "srcSTrateTwo", "srcStrate1", "srcScrite4", "srcStride52", "srcScrite52", "srcSTrate2", "srcStide8", "srcStrid1", "srcStide2", "srcStrip2", "srcStride8", "srcStrite4", "srcStrid2", "srcScrite1", "srcScride1", "srcStride4", "srcStide1", "srcStrite2", "srcSTride8", "srcStrite1", "srcStrideTwo", "srcScride52", "srcScride4", "srcStrite8", "srcScride2", "srcStrate8", "srcStrid4", "srcSTrate1", "srcStrip52", "srcStrate2", "srcSTride1"], "srcStride3": ["srcSterve2", "srcStriN", "srcStri7", "srcScrite3", "srcScrite2", "srcScrite7", "srcstride1", "srcStride7", "srcStrl7", "srcStrl2", "srcstride2", "srcStrlN", "srcStrl3", "srcStrideN", "srcsterve2", "srcStrite3", "srcStideThree", "srcsterve1", "srcStrideThree", "srcStriteN", "srcsterveThree", "srcStide2", "srcStri3", "srcSterve3", "srcStide1", "srcStrite2", "srcsterve3", "srcStrite1", "srcstrideThree", "srcSterveThree", "srcStrite7", "srcScride7", "srcScriteN", "srcSterve1", "srcScride2", "srcStide3", "srcstride3", "srcScrideN", "srcStriteThree", "srcScride3", "srcStri2"], "dstStride": ["dndStrate", "dstStrib", "drdSTrate", "dndstride", "dstRestride", "dndStrite", "drdSTide", "dstShride", "drdStride", "dststrate", "dststride", "drdStrb", "dndstrib", "dstShrate", "dstStide", "drdStide", "dndStrib", "drdSTride", "dstSTide", "dstSTrate", "dstShrite", "dstSTrib", "dndStride", "dstSTride", "dstRestrb", "dstSTrb", "dstStrite", "drdStrate", "dndstrate", "dststide", "drdSTrb", "dstRestrate", "dststrite", "dstShrib", "dstStrate", "dstSTrite", "dststrib", "dstRestide", "dndstrite", "dststrb", "dstStrb"], "x": ["g", "zx", "ax", "yx", "ctx", "f", "on", "id", "xc", "k", "wx", "xs", "c", "X", "ex", "xy", "i", "p", "xxx", "step", "b", "px", "work", "j", "ct", "con", "cross", "sex", "key", "z", "v", "code", "image", "xi", "ww", "rx", "t", "time", "l", "q", "fx", "index", "xx", "dx", "m", "u", "ady", "tx", "e", "n", "my", "xp", "s", "sync", "status", "python", "ix"], "y": ["g", "yer", "zy", "ey", "yd", "wy", "yy", "f", "yo", "ky", "iy", "ny", "lat", "ys", "ya", "ies", "c", "yi", "i", "yn", "yan", "yang", "p", "dy", "hy", "ity", "vy", "b", "cy", "gy", "year", "j", "yr", "z", "ye", "ay", "sy", "t", "sky", "ym", "ady", "ry", "yah", "ty", "e", "n", "yl", "Y", "yt", "yu", "py", "iny", "oy"], "w": ["g", "wd", "hw", "we", "weight", "sw", "W", "wx", "c", "p", "wn", "b", "kw", "wl", "z", "v", "ww", "r", "t", "aw", "wp", "win", "l", "q", "u", "ew", "wt", "wh", "wa", "m", "n", "fw", "e", "wb", "s", "wid"], "h": ["g", "ph", "hw", "H", "f", "c", "i", "p", "uh", "sh", "b", "hh", "ht", "hi", "z", "v", "hs", "ch", "t", "r", "l", "q", "u", "m", "wa", "e", "n", "rh", "s", "W", "hm"], "yp": ["eps", "np", "yd", "tp", "pg", "yy", "dp", "pm", "ip", "mp", "ys", "pb", "yn", "jp", "lp", "dr", "pr", "ep", "sp", "cy", "px", "cp", "pt", "omp", "fp", "pe", "op", "ps", "wp", "pp", "ym", "xt", "yt", "dep", "xp", "iw", "wb", "yu", "py", "typ"], "up": ["upt", "mp", "ups", "ul", "sup", "uph", "sp", "cp", "img", "url", "pt", "uv", "in", "op", "down", "ch", "ui", "aw", "ps", "wp", "uf", "pp", "u", "cr", "xp", "upp", "out", "uc", "um"], "vp": ["vl", "eps", "np", "tp", "pn", "dp", "pm", "vt", "mp", "vc", "pb", "jp", "sv", "pu", "lp", "pd", "vg", "sp", "dq", "vr", "uv", "fp", "lv", "gp", "wp", "pp", "xp", "vv", "vs"], "d": ["g", "dat", "yd", "sd", "f", "dp", "D", "md", "c", "db", "dist", "pd", "p", "dy", "ds", "b", "ld", "bd", "z", "di", "dc", "dd", "v", "dn", "t", "dim", "dx", "m", "dh", "dm", "e", "n", "dl", "data", "dt", "cd"]}}
{"project": "FFmpeg", "commit_id": "381e195b46d080aee1d9b05ef2b6b140e9463519", "target": 0, "func": "static int pcm_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    PCMDecode *s = avctx->priv_data;\n\n    int sample_size, c, n, i;\n\n    uint8_t *samples;\n\n    const uint8_t *src, *src8, *src2[MAX_CHANNELS];\n\n    int32_t *dst_int32_t;\n\n\n\n    samples = data;\n\n    src = buf;\n\n\n\n    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample_fmt\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){\n\n        av_log(avctx, AV_LOG_ERROR, \"PCM channels out of bounds\\n\");\n\n        return -1;\n\n    }\n\n\n\n    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;\n\n\n\n    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */\n\n    if (CODEC_ID_PCM_DVD == avctx->codec_id)\n\n        /* 2 samples are interleaved per block in PCM_DVD */\n\n        sample_size = avctx->bits_per_coded_sample * 2 / 8;\n\n    else if (avctx->codec_id == CODEC_ID_PCM_LXF)\n\n        /* we process 40-bit blocks per channel for LXF */\n\n        sample_size = 5;\n\n\n\n    if (sample_size == 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid sample_size\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    n = avctx->channels * sample_size;\n\n\n\n    if(n && buf_size % n){\n\n        if (buf_size < n) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCM packet\\n\");\n\n            return -1;\n\n        }else\n\n            buf_size -= buf_size % n;\n\n    }\n\n\n\n    buf_size= FFMIN(buf_size, *data_size/2);\n\n\n\n    n = buf_size/sample_size;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_U32LE:\n\n        DECODE(32, le32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_U32BE:\n\n        DECODE(32, be32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_S24LE:\n\n        DECODE(32, le24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S24BE:\n\n        DECODE(32, be24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_U24LE:\n\n        DECODE(32, le24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_U24BE:\n\n        DECODE(32, be24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_S24DAUD:\n\n        for(;n>0;n--) {\n\n          uint32_t v = bytestream_get_be24(&src);\n\n          v >>= 4; // sync flags are here\n\n          AV_WN16A(samples, av_reverse[(v >> 8) & 0xff] +\n\n                           (av_reverse[v & 0xff] << 8));\n\n          samples += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S16LE_PLANAR:\n\n        n /= avctx->channels;\n\n        for(c=0;c<avctx->channels;c++)\n\n            src2[c] = &src[c*n*2];\n\n        for(;n>0;n--)\n\n            for(c=0;c<avctx->channels;c++) {\n\n                AV_WN16A(samples, bytestream_get_le16(&src2[c]));\n\n                samples += 2;\n\n            }\n\n        src = src2[avctx->channels-1];\n\n        break;\n\n    case CODEC_ID_PCM_U16LE:\n\n        DECODE(16, le16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_U16BE:\n\n        DECODE(16, be16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_S8:\n\n        for(;n>0;n--) {\n\n            *samples++ = *src++ + 128;\n\n        }\n\n        break;\n\n#if HAVE_BIGENDIAN\n\n    case CODEC_ID_PCM_F64LE:\n\n        DECODE(64, le64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n        DECODE(32, le32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16LE:\n\n        DECODE(16, le16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64BE:\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n    case CODEC_ID_PCM_S16BE:\n\n#else\n\n    case CODEC_ID_PCM_F64BE:\n\n        DECODE(64, be64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n        DECODE(32, be32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16BE:\n\n        DECODE(16, be16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_S16LE:\n\n#endif /* HAVE_BIGENDIAN */\n\n    case CODEC_ID_PCM_U8:\n\n        memcpy(samples, src, n*sample_size);\n\n        src += n*sample_size;\n\n        samples += n * sample_size;\n\n        break;\n\n    case CODEC_ID_PCM_ZORK:\n\n        for(;n>0;n--) {\n\n            int x= *src++;\n\n            if(x&128) x-= 128;\n\n            else      x = -x;\n\n            AV_WN16A(samples, x << 8);\n\n            samples += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_ALAW:\n\n    case CODEC_ID_PCM_MULAW:\n\n        for(;n>0;n--) {\n\n            AV_WN16A(samples, s->table[*src++]);\n\n            samples += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_DVD:\n\n        dst_int32_t = data;\n\n        n /= avctx->channels;\n\n        switch (avctx->bits_per_coded_sample) {\n\n        case 20:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        case 24:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n\n            return -1;\n\n        }\n\n        samples = (uint8_t *) dst_int32_t;\n\n        break;\n\n    case CODEC_ID_PCM_LXF:\n\n        dst_int32_t = data;\n\n        n /= avctx->channels;\n\n        //unpack and de-planerize\n\n        for (i = 0; i < n; i++) {\n\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n\n                //extract low 20 bits and expand to 32 bits\n\n                *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) |\n\n                                 ((src8[2] & 0xF) << 8) | src8[1];\n\n            }\n\n\n\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n\n                //extract high 20 bits and expand to 32 bits\n\n                *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) |\n\n                                 ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4);\n\n            }\n\n        }\n\n        src += n * avctx->channels * 5;\n\n        samples = (uint8_t *) dst_int32_t;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = samples - (uint8_t *)data;\n\n    return src - buf;\n\n}\n", "idx": 10244, "substitutes": {"avctx": ["navctx", "AVmac", "afconfig", "avcf", "avallc", "aveloc", "afci", "attconfig", "AVci", "aftx", "afexc", "apconn", "navmac", "evcf", "evcu", "afconnection", "auctx", "afcu", "avcv", "afctrl", "avectx", "navcontext", "evctl", "rafctx", "avci", " avcontext", "avexc", "apcontext", "aucu", "attctx", "attcontext", "avalcontext", "aflc", "AVconn", "atttx", "avecontext", "AVcontext", "vercf", "abcm", "avelc", "afcv", "avctrl", "avconn", "evconn", "avctl", "afcontext", "ablc", "avconfig", "rafctl", "AVctx", "abcmp", "evcv", "avmac", "avtx", "AVconfig", "vercontext", "aveconnection", "abcontext", "avlc", "aucontext", "avloc", "afconn", " avcv", "avectrl", " avcf", "afctl", "afcm", "afctx", "avconnection", "afcmp", "avcmp", "avcontext", "auconnection", "evctx", " avc", "aveci", "evcmp", "avalexc", "AVexc", "avecf", "avalctx", "rafcontext", "AVlc", "avcm", "afc", "avecm", "vermac", "rafcf", "avecu", "abconn", "avc", "avcu", "abctx", "afcf", "apctx", "AVcf", "afloc", "evloc", " avconn", "verctx", "apcmp", "AVc", "aveconn", "navcf", "abctrl", "AVtx", "evcontext"], "data": ["dat", "pos", "message", "block", "size", "f", "sample", "Data", "result", "media", "seq", "len", "a", "d", "DATA", "multi", "config", "bytes", "p", "xxx", "response", "input", "content", "r", "b", "load", "queue", "frame", "array", "tmp", "image", "parent", "reader", "channel", "da", "val", "bin", "source", "length", "frames", "start", "next", "buff", "map", "buffer", "body", "video", "stream", "window", "batch", "slice", "cache"], "data_size": [" data_shape", "data\u00b7scale", "data_count", "data\u00b7shape", "doc_fee", "data_scale", "data_address", "data_shape", "data\u00b7size", "doc_shape", " data_address", "doc_count", "data\u00b7address", "data_fee", "doc_size", " data_scale"], "avpkt": ["avfcf", "avckt", "avcet", "avcpct", "affcf", "affacket", "avpacket", " avckt", "avwpkt", "avppkt", " avcck", "avvpck", "avpud", "avcpet", "avvpnt", "avvpct", "avpck", "AVcpct", "avpcf", "avppct", "avnpck", "avnpud", "avfacket", "avfud", "avpet", "avpkg", "AVpet", "avpct", " avcct", "avcpkg", " avpnt", "avnpnt", "avckg", "AVcpkg", " avpck", "avnpkt", "avvpkt", "affud", "afpcf", "avwpud", "affkt", " avpct", "afpud", "avnpacket", "avcnt", "avcpkt", "AVpkt", "avwpcf", "avnpcf", "afpkt", "avcck", "avppet", "avwpacket", " avcnt", "AVcpet", "avpnt", "AVpkg", "afpacket", "AVcpkt", "avnpct", "avppkg", "avcct", "avfkt", "AVpct"], "buf": ["cas", "block", "dest", "f", "vec", "ref", "bc", "bag", "seq", "pb", "len", "box", "config", "cb", "offset", "loc", "b", "fb", "queue", "img", "rb", "array", "bd", "fp", "cv", "tmp", "alloc", "uf", "cf", "buff", "buffer", "pad", "port", "wb", "uc", "cap", "batch"], "s": ["g", "f", "ss", "sq", "a", "sv", "d", "sb", "p", "S", "session", "b", "ssl", "ns", "v", "r", "o", "ses", "sc", "sync", "w", "m", "e", "sys", "rs", "sa", "stats"], "sample_size": ["mean_mini", " sample_scale", "sample8start", " sample_sum", "sample67handle", "ample_size", "ample_limit", "ample8code", "mean67handle", "scale_rate", "ample8limit", "sample_sum", "sample8code", "sample___code", "sample64scale", "scale_sized", "ample_start", "sample_shape", "scale_scale", "sample_sized", "mean67size", "ample8size", "ample_scale", "sample8limit", "sample_code", "site_strength", "mean67shape", "sample64rate", "ample_range", "sample67shape", "sample_mini", "ample_sum", "sample_handle", "site_size", "sample_rate", "mean67mini", "mean_size", "sample_name", "scale_size", "sample_limit", "sample67size", "site_type", "sample_address", "sample8size", "sample64sized", "mean_shape", "sample64size", "sample___start", "ample_code", "sample___size", "sample_scale", " sample_name", "sample_type", " sample_sized", "mean_handle", " sample_address", "sample67mini", "site_name", "sample_strength", "sample_start", "sample___limit", "ample8start", "sample_range"], "c": ["g", "f", "k", "cs", "nc", "en", "d", "h", "p", "b", "cm", "con", "ct", "cc", "z", "v", "C", "dc", "r", "l", "ci", "u", "w", "m", "e", "cn", "count", "x"], "n": ["ne", "g", "pos", "nor", "size", "f", "un", "pn", "k", "nc", "na", "nb", "y", "len", "network", "en", "N", "co", "d", "norm", "node", "h", "p", "b", "net", "Ns", "j", "nw", "don", "rn", "ns", "v", "z", "num", "dn", "o", "r", "t", "all", "l", "conn", "u", "w", "m", "sn", "nn", "e", "cn", "ln", "nt", "number", "x"], "i": ["ii", "ni", "li", "f", "I", "k", "ip", "y", "ini", "d", "p", "si", "b", "pi", "j", "di", "v", "ti", "ind", "o", "l", "ci", "u", "index", "m", "e", "x"], "samples": ["ssamples", "insources", "insample", "sources", " samps", "sample", "unsample", "Samps", " sources", "namesizes", " sample", "namesources", "insamples", " sannels", "Sizes", "samps", "sannels", "unsamples", "insamps", "Samples", "unsamps", "Sources", "insizes", "namesamples", "sizes", "ssannels", "Sannels", "unsources", "ssamps"], "src": ["sur", "dest", "ctx", "ptr", "proc", "sel", "sub", "seq", "bc", "sq", "sup", "ins", "params", "sb", "rc", "config", "cb", "input", "loc", "split", "b", "inst", "gz", "ssl", "fl", "img", "url", "gb", "rb", "sl", "tmp", "cv", "fc", "source", "bin", "sc", "lib", "sync", "sn", "RC", "rs", "uc", "stream", "SOURCE", "slice"], "src8": ["rc8", " src6", "rc16", "src4", "source16", "src16", " src16", "source6", "src6", "rc6", "rc4", "source4", " src4", "source8"], "src2": [" src1", "rc3", "src3", "src4", "source1", "rc2", "rc4", "source4", "source2", " src3", " src4", "source3", "rc1", "src1"], "MAX_CHANNELS": ["MAX_CHANEL", "MAX_CHANGDS", "MAX_CHANNETS", "MAX_CHOANNETS", "MAX_CHOANGETS", "MAX_CHANGELS", "MAX_CLANNDS", "MAX_CHANNERS", "MAX_CHINEL", "MAX_CLANES", "MAX_CHINERS", "MAX_CHANNDS", "MAX_CHOANGERS", "MAX_CLANETS", "MAX_CHOUNETS", "MAX_CHANNES", "MAX_CHINETS", "MAX_CHANGES", "MAX_CHOUNES", "MAX_CHANGEL", "MAX_CHANNEL", "MAX_CHOANGEL", "MAX_CHANES", "MAX_CLANNETS", "MAX_CLANNELS", "MAX_CHOUNDS", "MAX_CHOANNELS", "MAX_CHANELS", "MAX_CHANGETS", "MAX_CHOANNEL", "MAX_CHOANGELS", "MAX_CLANNES", "MAX_CHINELS", "MAX_CHANERS", "MAX_CLANELS", "MAX_CLANDS", "MAX_CHOUNELS", "MAX_CHOANNERS", "MAX_CHANETS", "MAX_CHANDS", "MAX_CHANGERS"], "dst_int32_t": ["dst_int16_int", "dst_int32_type", "dst_int32_int", "dst_int32_T", "dst_int16_t", "dst_int16_type", "dst_int16_T"]}}
{"project": "FFmpeg", "commit_id": "253d0be6a1ecc343d29ff8e1df0ddf961ab9c772", "target": 0, "func": "static int parse_presentation_segment(AVCodecContext *avctx,\n\n                                      const uint8_t *buf, int buf_size,\n\n                                      int64_t pts)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n\n\n    int x, y, ret;\n\n\n\n    int w = bytestream_get_be16(&buf);\n\n    int h = bytestream_get_be16(&buf);\n\n\n\n    ctx->presentation.pts = pts;\n\n\n\n    av_dlog(avctx, \"Video Dimensions %dx%d\\n\",\n\n            w, h);\n\n    ret = ff_set_dimensions(avctx, w, h);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Skip 1 bytes of unknown, frame rate? */\n\n    buf++;\n\n\n\n    ctx->presentation.id_number = bytestream_get_be16(&buf);\n\n\n\n    /*\n\n     * Skip 3 bytes of unknown:\n\n     *     state\n\n     *     palette_update_flag (0x80),\n\n     *     palette_id_to_use,\n\n     */\n\n    buf += 3;\n\n\n\n    ctx->presentation.object_number = bytestream_get_byte(&buf);\n\n    ctx->presentation.composition_flag = 0;\n\n    if (!ctx->presentation.object_number)\n\n        return 0;\n\n\n\n    /*\n\n     * Skip 3 bytes of unknown:\n\n     *     object_id_ref (2 bytes),\n\n     *     window_id_ref,\n\n     */\n\n    buf += 3;\n\n    ctx->presentation.composition_flag = bytestream_get_byte(&buf);\n\n\n\n    x = bytestream_get_be16(&buf);\n\n    y = bytestream_get_be16(&buf);\n\n\n\n    /* TODO If cropping, cropping_x, cropping_y, cropping_width, cropping_height (all 2 bytes).*/\n\n\n\n    av_dlog(avctx, \"Subtitle Placement x=%d, y=%d\\n\", x, y);\n\n\n\n    if (x > avctx->width || y > avctx->height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\\n\",\n\n               x, y, avctx->width, avctx->height);\n\n        x = 0; y = 0;\n\n    }\n\n\n\n    /* Fill in dimensions */\n\n    ctx->presentation.x = x;\n\n    ctx->presentation.y = y;\n\n\n\n    return 0;\n\n}\n", "idx": 10253, "substitutes": {"avctx": ["avconfig", "avcmp", "ajcmp", "avcontext", "alconv", "evctx", "AVctx", "avectx", "avcas", "vercmd", "afconfig", "ajctrl", "avcf", "avecf", "ajcontext", "alcca", "AVlc", "afpkg", "avcmd", "vercontext", "afcmd", "AVconfig", "AVcmd", "afcas", "avecu", "alcas", "aucontext", "avlc", "avcu", "afcca", "avpkg", "verconfig", "avconv", "afcf", "AVcmp", "afconn", "afconv", "ajctx", "AVcf", "alpkg", "aflc", "evcf", "aveconfig", "AVconn", "verctx", "evcontext", "alctx", "ajcmd", "avecontext", "auctx", "avcca", "aucas", "avecmp", "avepkg", "afcu", "AVcontext", "avelc", "alcontext", "avctrl", "aveconn", "aucca", "AVctrl", "avconn", "evconn", "afctx", "afctrl", "aveconv", "AVcu", "AVpkg", "afcmp", "afcontext"], "buf": ["cas", "ph", "text", "pool", "mount", "src", "vec", "uint", "ref", "fam", "aux", "proc", "exc", "home", "bu", "bc", "bag", "seq", "pb", "box", "conv", "brace", "auc", "rc", "config", "h", "cb", "cur", "ha", "uh", "pkg", "b", "Buff", "fb", "bound", "queue", "bh", "runner", "img", "uu", "context", "gb", "rb", "loop", "begin", "fp", "cv", "row", "alloc", "br", "af", "cmd", "uf", "req", "cf", "buff", "ab", "buffer", "wa", "func", "fw", "port", "wb", "uc", "fd", "batch", "data", "feat", "font"], "buf_size": ["buf2size", " buffer_name", " buffer_length", "buf_length", "buf_SIZE", " buffer_SIZE", "buf_name", "buf2name", " buffer_size", "buf2SIZE", "buf2length"], "pts": ["portgs", "aptc", " ptts", "prg", "ntgs", "pxns", "ctns", " ptsd", "ctc", "ptgs", "ctd", "cts", " ptsts", "portg", "ntts", "pxc", "aptd", "ptns", " ptd", "portd", "nts", "prs", "ntd", "ntps", " ptsps", "prd", " ptps", "ptts", "ntg", "pxd", "apts", "pxs", "ptps", "ptd", " ptss", "aptns", "ptc", "ports", "ptg", "prgs"], "ctx": ["cas", "hw", "xc", "cs", "nc", "aux", "comp", "bc", "ce", "vc", "wcs", "c", "conv", "pc", "ca", "cmp", "co", "config", "cpp", "cb", "p", "kb", "ck", "sci", "pkg", "loc", "qa", "cp", "cm", "cu", "ctrl", "context", "cfg", "cc", "cli", "fc", "cv", "cms", "coll", "css", "client", "cmd", "cf", "conn", "ci", "sc", "cus", "cam", "conf", "tx", "fw", "cn", "tc", "lc", "mc", "cca", "gc", "data", "exec"], "x": ["xe", "ax", "host", "c", "X", "ex", "i", "a", "d", "b", "px", "sex", "key", "address", "rx", "time", "q", "xx", "dx", "w", "height", "e", "location", "coord", "id", "xc", "view", "h", "xxx", "shape", "z", "code", "xi", "hi", "pe", "o", "length", "fx", "wa", "port", "f", "k", "pl", "xs", "en", "in", "v", "r", "l", "u", "index", "xp", "value", "name", "ix", "path", "wx", "xy", "p", "work", "position", "image", "ww", "t", "val", "m", "tx", "n", "data"], "y": ["ii", "zy", "ey", "wy", "yy", "type", "yo", "id", "f", "iy", "ky", "ny", "ys", "ya", "ies", "yi", "i", "yn", "xy", "d", "yan", "h", "bar", "p", "dy", "hy", "vy", "b", "cy", "ish", "gy", "j", "pt", "z", "v", "hi", "ye", "ay", "image", "sy", "t", "o", "length", "area", "ery", "l", "q", "ym", "index", "ady", "ry", "w", "m", "wa", "ty", "height", "yt", "n", "yl", "Y", "lon", "value", "s", "isy", "py", "name", "acy", "oy"], "ret": ["f", "rets", "rt", "wait", "id", "att", "resp", "re", "RET", "match", "ref", "err", "rev", "fi", "ft", "result", "md", "success", "len", "en", "art", "ben", "rc", "back", "rf", "lit", "fun", "flag", "pt", "run", "mt", "rb", "red", "end", "code", "num", "rx", "r", "val", "det", "def", "ry", "last", "reply", "obj", "res", "nt", "reg", "alt", "Ret", "bf", "feat", "read", "str"]}}
{"project": "qemu", "commit_id": "39a7a362e16bb27e98738d63f24d1ab5811e26a8", "target": 0, "func": "void qemu_coroutine_delete(Coroutine *co_)\n\n{\n\n    CoroutineThreadState *s = coroutine_get_thread_state();\n\n    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);\n\n\n\n    if (s->pool_size < POOL_MAX_SIZE) {\n\n        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);\n\n        co->base.caller = NULL;\n\n        s->pool_size++;\n\n        return;\n\n    }\n\n\n\n    g_free(co->stack);\n\n    g_free(co);\n\n}\n", "idx": 10266, "substitutes": {"co_": ["aco_", "co__", " co__", "ci__", "Co__", "Co_", "mo_", "ci_", "CO_"], "s": ["os", "f", "local", "cs", "state", "ls", "sf", "ss", "xs", "sq", "c", "stat", "is", "sup", "ks", "ins", "services", "sb", "es", "p", "ts", "sg", "si", "S", "ds", "http", "b", "fs", "ssl", "se", "sl", "bs", "ns", "hs", "r", "o", "ps", "ses", "l", "u", "sync", "gs", "m", "conf", "e", "sys", "su", "rs", "js", "status", "stats"], "co": ["ico", "CC", "code", "ctx", "oo", "flo", "bc", "can", "c", "pc", "ca", "aco", "coord", "CO", "ck", "loc", "cu", "con", "cross", "core", "ko", "po", "cc", "coll", "op", "Co", "fc", "coe", "go", "che", "isco", "o", "oper", "que", "parent", "ci", "cf", "fo", "call", "oe", "com", "mo", "col", "oc", "mc", "so", "lc", "company", "cost", "x", "cache"], "pool_size": ["queue_size", "pool_weight", "pool_max", "queue_count", "pool__length", "pool_count", "pool__size", "pool_length", "pool_capacity", "poolalllength", "thread_length", "poolallcapacity", "poolallsize", "thread_size", "queue_max", "poolallweight", "thread_capacity", "pool__weight", "thread_weight", "pool__capacity"]}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "int float64_eq_signaling( float64 a, float64 b STATUS_PARAM )\n\n{\n\n\n\n    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )\n\n         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )\n\n       ) {\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n        return 0;\n\n    }\n\n    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );\n\n\n\n}\n", "idx": 10268, "substitutes": {"a": ["la", "ga", "f", "at", "va", "ea", "self", "aux", "alpha", "ma", "y", "c", "ca", "i", "an", "ae", "aa", "art", "au", "d", "p", "b", "ar", "A", "fa", "ia", "ac", "o", "da", "af", "area", "l", "am", "u", "ap", "ab", "as", "m", "ast", "e", "n", "pa", "ai", "s", "sa", "ad", "aj", "x", "ba"], "STATUS_PARAM": ["STATUS_PARam", "STATUS_ARAME", "STATUS_PARA", "STATUS_ARam", "STATUS_PA", "STATUS_PAME", "STATUS_ARA", "STATUS_ARAM", "STATUS_PAM", "STATUS_PARAME", "STATUS_Pam"]}}
{"project": "qemu", "commit_id": "92dcc234ec1f266fb5d59bed77d66320c2c75965", "target": 0, "func": "static int tpm_passthrough_unix_tx_bufs(int tpm_fd,\n\n                                        const uint8_t *in, uint32_t in_len,\n\n                                        uint8_t *out, uint32_t out_len)\n\n{\n\n    int ret;\n\n\n\n    ret = tpm_passthrough_unix_write(tpm_fd, in, in_len);\n\n    if (ret != in_len) {\n\n        error_report(\"tpm_passthrough: error while transmitting data \"\n\n                     \"to TPM: %s (%i)\\n\",\n\n                     strerror(errno), errno);\n\n        goto err_exit;\n\n    }\n\n\n\n    ret = tpm_passthrough_unix_read(tpm_fd, out, out_len);\n\n    if (ret < 0) {\n\n        error_report(\"tpm_passthrough: error while reading data from \"\n\n                     \"TPM: %s (%i)\\n\",\n\n                     strerror(errno), errno);\n\n    } else if (ret < sizeof(struct tpm_resp_hdr) ||\n\n               tpm_passthrough_get_size_from_buffer(out) != ret) {\n\n        ret = -1;\n\n        error_report(\"tpm_passthrough: received invalid response \"\n\n                     \"packet from TPM\\n\");\n\n    }\n\n\n\nerr_exit:\n\n    if (ret < 0) {\n\n        tpm_write_fatal_error_response(out, out_len);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 10269, "substitutes": {"tpm_fd": ["tpm_handler", "tpm_flo", "tdem_flo", "tPM_d", "tpm__d", "tcm_fd", "tcm_writer", "tpm__writer", "tPM_context", "tcm_handler", "tpm_d", "tpm_FD", "tpm_dir", "tpm_writer", "tpm67fd", "tpm__fd", "tPM_fd", "tpm67dir", "tPM_FD", "tdem_dir", "tdem_handler", "tcm_d", "tpm67flo", "tpm__handler", "tpm67handler", "tdem_fd", "tpm_context"], "in": ["nin", "isin", "id", "diff", "update", "inn", "x", "min", "c", "into", "ini", "ex", "ins", "In", "new", "input", "again", "work", "inner", "con", "ac", "image", "IN", "inc", "r", "source", "bin", "all", "pin", "win", "index", "rin", "m", "init", "login", "s", "data", "din", "read"], "in_len": ["in00len", "in00en", "in00lan", "inxlength", "in_en", "out_l", "out_lf", "in_length", "inxLen", "inxsize", " in_Len", "in_size", "in00length", "out_en", "in_l", "out_length", "in_lf", "in_lan", " in_length", "inxlen", "in_Len", " in_size", "out_lan"], "out": ["server", "timeout", "prefix", "block", "size", "file", "at", "comment", "OUT", "err", "update", "output", "result", "connection", "wx", "c", "exec", "write", "ex", "off", "cache", "new", "after", "temp", "input", "response", "again", "outs", "b", "net", "work", "io", "full", "doc", "ext", "bit", "part", "image", "client", "inc", "o", "cmd", "req", "call", "conn", "w", "buffer", "reply", "init", "n", "obj", "line", "name", "window", "data", "target", "Out"], "out_len": ["outvsize", "out_line", "again_line", "outalllin", "out0len", "out_lon", "out_lf", "in_length", "out0length", "out_size", "out0pos", "outvlen", "out_limit", "outvline", "again_size", "in_pos", "again_len", "outvln", "out_length", "out_lin", " out_lin", "outalllen", "in_limit", "out0limit", "out_ln", "out_pos", "again_ln", " out_lon", "outalllon", "outalllf", " out_lf"], "ret": ["rt", "rets", "match", "att", "resp", "re", "RET", "id", "ref", "final", "rev", "ft", "result", "success", "lt", "len", "db", "al", "en", "art", "sr", "rc", "cat", "back", "rl", "arr", "fun", "lit", "sp", "j", "flag", "bit", "ext", "part", "mt", "code", "gt", "mem", "num", "std", "val", "det", "rep", "def", "opt", "dt", "arg", "reply", "fit", "pat", "desc", "obj", "res", "reg", "nt", "fin", "alt", "Ret", "bf", "data", "feat", "pret", "status", "let", "str"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,\n\n                        uint8_t *buf, int len, int is_write)\n\n{\n\n    int l;\n\n    target_phys_addr_t phys_addr;\n\n    target_ulong page;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        phys_addr = cpu_get_phys_page_debug(env, page);\n\n        /* if no physical page mapped, return an error */\n\n        if (phys_addr == -1)\n\n            return -1;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        phys_addr += (addr & ~TARGET_PAGE_MASK);\n\n        if (is_write)\n\n            cpu_physical_memory_write_rom(phys_addr, buf, l);\n\n        else\n\n            cpu_physical_memory_rw(phys_addr, buf, l, is_write);\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n    return 0;\n\n}\n", "idx": 10278, "substitutes": {"env": ["oa", "et", "np", "zen", "vt", "eng", "ea", "exc", "fi", "en", "qt", "eu", "config", "ev", "enc", "Environment", "runner", "ext", "impl", "viron", "environment", "que", "inv", "her", "esi", "forge", "emb", "e", "ec", "eni", "priv", "ens", "erv", "txt", "energy", "ef", "exe"], "addr": ["la", "src", "ref", "ip", "host", "edge", "ea", "seq", "rc", "lr", "ell", "memory", "address", "mem", "pad", "e", "rs", "eni", "alt", "alias", "coord", "ack", "size", "pointer", "nr", "id", "ls", "lb", "lp", "ace", "ord", "ld", "alloc", "el", "conn", "hl", "stall", "lan", "ad", "dl", "align", "hop", "ptr", "en", "route", "afi", "pkg", "asm", "socket", "sl", "add", "layer", "r", "start", "lc", "x", "oa", "pos", "device", "adr", "aa", "node", "dr", "p", "offset", "order", "bridge", "loc", "work", "url", "cpu", "fd", "data"], "buf": ["cas", "ctx", "pool", "src", "vec", "path", "ff", "fi", "proc", "home", "result", "bag", "seq", "pb", "bc", "lb", "rc", "config", "cb", "offset", "b", "fb", "queue", "runner", "url", "feed", "rb", "array", "fp", "cv", "mem", "alloc", "br", "que", "cmd", "uf", "buff", "buffer", "port", "wb", "uc", "fd", "batch", "data"], "len": ["la", "pos", "li", "ll", "limit", "ls", "pl", "min", "seq", "low", "en", "i", "lb", "den", "bl", "lp", "non", "ell", "loc", "Len", "lit", "le", "fl", "lim", "url", "ler", "sl", "in", "il", "lang", "lv", "lin", "el", "length", "val", "hl", "lock", "base", "n", "lon", "ln", "lan", "lc", "nt", "L", "fin", "dl", " el", "lf", "line"], "is_write": ["is_call", "has_written", "is_read", "isaycall", "islandwriter", "isp_write", "has_sync", "has_write", "is_writ", " is_call", "isp_writer", "isplandwriter", " is_writ", "has_flow", "isp_read", "is_sync", "is_flow", "is_writer", "isaywrite", "isaywrit", "isplandwrite", "islandcreate", "islandread", "islandwrite", "isplandread", "isplandcreate", "is_create", "isp_create", "is_written"], "l": ["la", "li", "ll", "limit", "ls", "pl", "ul", "y", "en", "i", "lb", "d", "bl", "lp", "p", "ol", "ell", "rl", "loc", "b", "lit", "le", "fl", "jl", "url", "nl", "ld", "sl", "kl", "z", "v", "il", "lang", "lin", "el", "r", "length", "o", "u", "hl", "e", "n", "ln", " L", "lu", "lc", "L", "dl", "lf", "line"], "phys_addr": ["cpu_ord", "physical_pointer", "cpu_ref", "phys_address", "phys_ref", "phys_align", "phys2ace", "phys___address", "physkalign", "physical_address", "physical_addr", "phys_ace", "phys__adr", "phys2rt", "physkdr", "phys2addr", "cpu_address", "phys_adr", "phys__addr", "phy_address", "las_align", "las_addr", "phys_az", "las_address", "phy_addr", "phys___pointer", "phys__address", "phys_pointer", "phy_oa", "physkaddr", "cpu_addr", "physkaddress", "phys_dr", "phys_oa", " phys_ord", "las_az", "phy_adder", "phys_rt", "phys_adder", "phys__pointer", "physical_adr", "phys_ord", "phys2ord", " phys_ace", " phys_rt", "phys___adr", "phys___addr", "las_dr"], "page": ["hop", "padding", "server", "pos", "fr", "pg", "Page", "pointer", "size", "site", "id", "limit", "ref", "ip", "pl", "byte", "c", "ver", "pc", "en", "stop", "cache", "aa", "node", "lp", "p", "offset", "loc", "net", "pages", "url", "end", "sl", "array", "memory", "address", "age", "pe", "row", "inc", "num", "el", "area", "pp", "next", "buffer", "e", "n", "name", "data", "count", "number", "pid", "x", "line"]}}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,\n\n                target_phys_addr_t base,\n\n                qemu_irq *irq, qemu_irq dma, omap_clk clk)\n\n{\n\n    struct omap_uwire_s *s = (struct omap_uwire_s *)\n\n            g_malloc0(sizeof(struct omap_uwire_s));\n\n\n\n    s->txirq = irq[0];\n\n    s->rxirq = irq[1];\n\n    s->txdrq = dma;\n\n    omap_uwire_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_uwire_ops, s, \"omap-uwire\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 10282, "substitutes": {"system_memory": ["System_memory", " system_media", "System_mem", " system_metadata", "system_media", "system_region", "System_region", "System_reference", "system_metadata", "system_reference", " system_mem", "system_mem"], "base": ["la", "aga", "server", "os", "block", "f", "id", "ases", "ip", "addr", "ma", "c", "ca", "i", "a", "is", "p", "ace", "b", "mb", "cp", "use", "frame", "gb", "address", "ia", "v", "bi", "r", "ui", "mac", "area", "resource", "l", "u", "m", "buffer", "as", "e", "info", "ase", "bas", "storage", "name", "bf", "Base", "x", "ix"], "irq": ["irqi", "IRdq", "nirqi", "srq", "nirque", "srqs", " irdq", "nird", "ireq", "iredq", " irqi", "irch", "irew", "irech", "irw", "irque", " ird", "nirq", "irtqi", " irw", "IRq", "irtch", "irequ", "IRch", " irque", " irch", "irtd", "irqs", "irtqu", "irtqs", "srch", "irqu", "irtq", "ireqs", "IRw", "ird", "irdq", "irtque", "srqu"], "dma": ["vdga", "vdca", "duma", "duga", "duca", "sga", "zga", "duMA", "dmas", "vdma", " dca", "dMA", "zma", "smas", "zmas", " dga", " dmas", "dga", "sma", "zMA", "sMA", "vdMA", " dMA", "dca"], "clk": ["slk", "blke", "slb", "slwork", "plb", "blb", "blwork", "clb", "clke", "plwork", "plk", "blk", "plke", "slke", "clwork"], "s": ["cs", "self", "c", "a", "i", "d", " shares", "ings", "settings", "b", "erences", "gs", "w", "e", "rs", "js", "os", " scales", "opens", "its", "ls", "ss", "sb", "rows", "S", "session", "ds", "scope", "fs", "ssl", "ows", "o", "ses", "als", "f", "an", "services", "sg", "ips", "secondary", "v", "ions", "r", "ps", "l", "u", "south", "sys", "g", "args", "izes", "states", "is", "new", "es", "p", "ts", "si", "ns", "us", "t", "m", "ures", "n", "sets", "aws", "sa", "ops", "ches"]}}
{"project": "qemu", "commit_id": "66668d197fa40747e835e15617eda2f1bc80982f", "target": 0, "func": "static int send_sub_rect(VncState *vs, int x, int y, int w, int h)\n\n{\n\n    VncPalette *palette = &color_count_palette;\n\n    uint32_t bg = 0, fg = 0;\n\n    int colors;\n\n    int ret = 0;\n\n#ifdef CONFIG_VNC_JPEG\n\n    bool force_jpeg = false;\n\n    bool allow_jpeg = true;\n\n#endif\n\n\n\n    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);\n\n\n\n    vnc_tight_start(vs);\n\n    vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n\n    vnc_tight_stop(vs);\n\n\n\n#ifdef CONFIG_VNC_JPEG\n\n    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) {\n\n        double freq = vnc_update_freq(vs, x, y, w, h);\n\n\n\n        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {\n\n            allow_jpeg = false;\n\n        }\n\n        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {\n\n            force_jpeg = true;\n\n            vnc_sent_lossy_rect(vs, x, y, w, h);\n\n        }\n\n    }\n\n#endif\n\n\n\n    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette);\n\n\n\n#ifdef CONFIG_VNC_JPEG\n\n    if (allow_jpeg && vs->tight.quality != (uint8_t)-1) {\n\n        ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette,\n\n                                 force_jpeg);\n\n    } else {\n\n        ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n\n    }\n\n#else\n\n    ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 10291, "substitutes": {"vs": ["eps", "ums", "pg", "styles", "args", "VS", "ils", "posts", "vers", "vals", "va", "cs", "ls", "ov", "views", "state", "ss", "serv", "ys", "xs", "ver", "pps", "ks", "ins", "sv", "params", "es", "verts", "otes", "ves", "ts", "lines", "iss", "http", "ds", "settings", "fs", "px", "sts", "pages", "vr", "nav", "alls", "env", "bs", "ns", "v", "cv", "ms", "css", "assets", "ps", "wp", "qs", "vp", "plugins", "gs", "as", "vas", "versions", "ports", "Vs", "rs", "lbs", "sk", "s", "obs", "js", "stats", "ops"], "x": ["pos", "ph", "up", "wy", "on", "f", "id", "k", "wx", "xs", "min", "c", "X", "ex", "i", "xy", "en", "d", "a", "p", "b", "px", "work", "ic", "z", "v", "pe", "image", "rx", "t", "o", "val", "win", "l", "q", "u", "index", "fx", "dx", "xx", "m", "wa", "tx", "e", "n", "xt", "my", "name", "ix"], "y": ["ey", "wy", "yy", "on", "f", "yo", "id", "yp", "ny", "ys", "ya", "ies", "c", "yi", "i", "yn", "xy", "d", "yes", "yan", "dy", "p", "b", "vy", "cy", "ish", "gy", "j", "yr", "z", "v", "ye", "ch", "sy", "t", "l", "q", "ym", "ry", "m", "col", "ty", "yt", "yl", "n", "Y", "s", "py"], "w": ["g", "wal", "wd", "hw", "wy", "wan", "rw", "we", "f", "k", "sw", "wx", "ya", "c", "d", "p", "wn", "temp", "sh", "b", "kw", "nw", "wl", "tw", "way", "z", "v", "hi", "ww", "t", "aw", "wp", "win", "l", "wu", "q", "ew", "height", "wa", "wh", "wt", "ow", "n", "fw", "m", "iw", "wb", "W"], "h": ["g", "ph", "hd", "H", "hw", "f", "id", "k", "um", "th", "home", "oh", "ul", "c", "en", "d", "kh", "p", "temp", "ha", "uh", "sh", "gh", "b", "ah", "bh", "zh", "hh", "ht", "hi", "z", "v", "hs", "ch", "hz", "t", "cl", "ih", "l", "q", "he", "u", "hl", "m", "body", "height", "wa", "dh", "wh", "n", "eh", "rh", "hm"], "palette": ["gamote", "pallete", "collette", "Palote", "gamette", "collete", "Palte", "calette", " palte", "calade", "calote", "allette", "callete", "callette", "colette", "Palet", " pallette", "Palettes", "gamlette", "palote", "palade", "Palette", "palettes", "colet", "alette", "Pallette", "alet", "Pallete", "Palade", "pallette", " palet", "gamlete", "colade", "colettes", " palettes", "alettes", "alte", "palte", "palet"], "colors": ["colorour", "colorters", "palors", "Colors", " collections", "icolors", "icolor", "pallections", " colons", "colores", "colorors", "valour", "colons", "palor", "COLores", " colals", "colorores", " colters", "palters", "colters", "collections", "colorons", "coloror", "valors", "icolals", "icollections", "colour", "icolters", "valores", "color", "icolores", "COLors", "palals", "colals", "colorlections", "Colores", " color", "palores", "COLor", "Color", "vallections", "icolons", "palour"]}}
{"project": "qemu", "commit_id": "5238c88657d751e3acf3e953a9b11f5f24262f75", "target": 0, "func": "static ExitStatus translate_one(DisasContext *ctx, uint32_t insn)\n\n{\n\n    uint32_t palcode;\n\n    int32_t disp21, disp16;\n\n#ifndef CONFIG_USER_ONLY\n\n    int32_t disp12;\n\n#endif\n\n    uint16_t fn11;\n\n    uint8_t opc, ra, rb, rc, fpfn, fn7, islit, real_islit;\n\n    uint8_t lit;\n\n    ExitStatus ret;\n\n\n\n    /* Decode all instruction fields */\n\n    opc = insn >> 26;\n\n    ra = (insn >> 21) & 0x1F;\n\n    rb = (insn >> 16) & 0x1F;\n\n    rc = insn & 0x1F;\n\n    real_islit = islit = (insn >> 12) & 1;\n\n    if (rb == 31 && !islit) {\n\n        islit = 1;\n\n        lit = 0;\n\n    } else\n\n        lit = (insn >> 13) & 0xFF;\n\n    palcode = insn & 0x03FFFFFF;\n\n    disp21 = ((int32_t)((insn & 0x001FFFFF) << 11)) >> 11;\n\n    disp16 = (int16_t)(insn & 0x0000FFFF);\n\n#ifndef CONFIG_USER_ONLY\n\n    disp12 = (int32_t)((insn & 0x00000FFF) << 20) >> 20;\n\n#endif\n\n    fn11 = (insn >> 5) & 0x000007FF;\n\n    fpfn = fn11 & 0x3F;\n\n    fn7 = (insn >> 5) & 0x0000007F;\n\n    LOG_DISAS(\"opc %02x ra %2d rb %2d rc %2d disp16 %6d\\n\",\n\n              opc, ra, rb, rc, disp16);\n\n\n\n    ret = NO_EXIT;\n\n    switch (opc) {\n\n    case 0x00:\n\n        /* CALL_PAL */\n\n        ret = gen_call_pal(ctx, palcode);\n\n        break;\n\n    case 0x01:\n\n        /* OPC01 */\n\n        goto invalid_opc;\n\n    case 0x02:\n\n        /* OPC02 */\n\n        goto invalid_opc;\n\n    case 0x03:\n\n        /* OPC03 */\n\n        goto invalid_opc;\n\n    case 0x04:\n\n        /* OPC04 */\n\n        goto invalid_opc;\n\n    case 0x05:\n\n        /* OPC05 */\n\n        goto invalid_opc;\n\n    case 0x06:\n\n        /* OPC06 */\n\n        goto invalid_opc;\n\n    case 0x07:\n\n        /* OPC07 */\n\n        goto invalid_opc;\n\n    case 0x08:\n\n        /* LDA */\n\n        if (likely(ra != 31)) {\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(cpu_ir[ra], cpu_ir[rb], disp16);\n\n            } else {\n\n                tcg_gen_movi_i64(cpu_ir[ra], disp16);\n\n            }\n\n        }\n\n        break;\n\n    case 0x09:\n\n        /* LDAH */\n\n        if (likely(ra != 31)) {\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(cpu_ir[ra], cpu_ir[rb], disp16 << 16);\n\n            } else {\n\n                tcg_gen_movi_i64(cpu_ir[ra], disp16 << 16);\n\n            }\n\n        }\n\n        break;\n\n    case 0x0A:\n\n        /* LDBU */\n\n        if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) {\n\n            gen_load_mem(ctx, &tcg_gen_qemu_ld8u, ra, rb, disp16, 0, 0);\n\n            break;\n\n        }\n\n        goto invalid_opc;\n\n    case 0x0B:\n\n        /* LDQ_U */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 1);\n\n        break;\n\n    case 0x0C:\n\n        /* LDWU */\n\n        if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) {\n\n            gen_load_mem(ctx, &tcg_gen_qemu_ld16u, ra, rb, disp16, 0, 0);\n\n            break;\n\n        }\n\n        goto invalid_opc;\n\n    case 0x0D:\n\n        /* STW */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st16, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0E:\n\n        /* STB */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st8, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0F:\n\n        /* STQ_U */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 1);\n\n        break;\n\n    case 0x10:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* ADDL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x02:\n\n            /* S4ADDL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x09:\n\n            /* SUBL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x0B:\n\n            /* S4SUBL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x0F:\n\n            /* CMPBGE */\n\n            gen_cmpbge(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x12:\n\n            /* S8ADDL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x1B:\n\n            /* S8SUBL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                       tcg_gen_sub_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x1D:\n\n            /* CMPULT */\n\n            gen_cmp(TCG_COND_LTU, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x20:\n\n            /* ADDQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x22:\n\n            /* S4ADDQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x29:\n\n            /* SUBQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x2B:\n\n            /* S4SUBQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x2D:\n\n            /* CMPEQ */\n\n            gen_cmp(TCG_COND_EQ, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x32:\n\n            /* S8ADDQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x3B:\n\n            /* S8SUBQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x3D:\n\n            /* CMPULE */\n\n            gen_cmp(TCG_COND_LEU, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x40:\n\n            /* ADDL/V */\n\n            gen_addlv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x49:\n\n            /* SUBL/V */\n\n            gen_sublv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x4D:\n\n            /* CMPLT */\n\n            gen_cmp(TCG_COND_LT, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x60:\n\n            /* ADDQ/V */\n\n            gen_addqv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x69:\n\n            /* SUBQ/V */\n\n            gen_subqv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x6D:\n\n            /* CMPLE */\n\n            gen_cmp(TCG_COND_LE, ra, rb, rc, islit, lit);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x11:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* AND */\n\n            if (likely(rc != 31)) {\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                } else if (islit) {\n\n                    tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                } else {\n\n                    tcg_gen_and_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x08:\n\n            /* BIC */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[ra], ~lit);\n\n                    } else {\n\n                        tcg_gen_andc_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x14:\n\n            /* CMOVLBS */\n\n            gen_cmov(TCG_COND_NE, ra, rb, rc, islit, lit, 1);\n\n            break;\n\n        case 0x16:\n\n            /* CMOVLBC */\n\n            gen_cmov(TCG_COND_EQ, ra, rb, rc, islit, lit, 1);\n\n            break;\n\n        case 0x20:\n\n            /* BIS */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_ori_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_or_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x24:\n\n            /* CMOVEQ */\n\n            gen_cmov(TCG_COND_EQ, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x26:\n\n            /* CMOVNE */\n\n            gen_cmov(TCG_COND_NE, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x28:\n\n            /* ORNOT */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_ori_i64(cpu_ir[rc], cpu_ir[ra], ~lit);\n\n                    } else {\n\n                        tcg_gen_orc_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ~lit);\n\n                    } else {\n\n                        tcg_gen_not_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x40:\n\n            /* XOR */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_xori_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_xor_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x44:\n\n            /* CMOVLT */\n\n            gen_cmov(TCG_COND_LT, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x46:\n\n            /* CMOVGE */\n\n            gen_cmov(TCG_COND_GE, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x48:\n\n            /* EQV */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_xori_i64(cpu_ir[rc], cpu_ir[ra], ~lit);\n\n                    } else {\n\n                        tcg_gen_eqv_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ~lit);\n\n                    } else {\n\n                        tcg_gen_not_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x61:\n\n            /* AMASK */\n\n            if (likely(rc != 31)) {\n\n                uint64_t amask = ctx->tb->flags >> TB_FLAGS_AMASK_SHIFT;\n\n\n\n                if (islit) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], lit & ~amask);\n\n                } else {\n\n                    tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[rb], ~amask);\n\n                }\n\n            }\n\n            break;\n\n        case 0x64:\n\n            /* CMOVLE */\n\n            gen_cmov(TCG_COND_LE, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x66:\n\n            /* CMOVGT */\n\n            gen_cmov(TCG_COND_GT, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x6C:\n\n            /* IMPLVER */\n\n            if (rc != 31) {\n\n                tcg_gen_movi_i64(cpu_ir[rc], ctx->implver);\n\n            }\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x12:\n\n        switch (fn7) {\n\n        case 0x02:\n\n            /* MSKBL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0x01);\n\n            break;\n\n        case 0x06:\n\n            /* EXTBL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0x01);\n\n            break;\n\n        case 0x0B:\n\n            /* INSBL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0x01);\n\n            break;\n\n        case 0x12:\n\n            /* MSKWL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x16:\n\n            /* EXTWL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x1B:\n\n            /* INSWL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x22:\n\n            /* MSKLL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x26:\n\n            /* EXTLL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x2B:\n\n            /* INSLL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x30:\n\n            /* ZAP */\n\n            gen_zap(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x31:\n\n            /* ZAPNOT */\n\n            gen_zapnot(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x32:\n\n            /* MSKQL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x34:\n\n            /* SRL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_shri_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f);\n\n                    } else {\n\n                        TCGv shift = tcg_temp_new();\n\n                        tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f);\n\n                        tcg_gen_shr_i64(cpu_ir[rc], cpu_ir[ra], shift);\n\n                        tcg_temp_free(shift);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x36:\n\n            /* EXTQL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x39:\n\n            /* SLL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f);\n\n                    } else {\n\n                        TCGv shift = tcg_temp_new();\n\n                        tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f);\n\n                        tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], shift);\n\n                        tcg_temp_free(shift);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x3B:\n\n            /* INSQL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x3C:\n\n            /* SRA */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_sari_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f);\n\n                    } else {\n\n                        TCGv shift = tcg_temp_new();\n\n                        tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f);\n\n                        tcg_gen_sar_i64(cpu_ir[rc], cpu_ir[ra], shift);\n\n                        tcg_temp_free(shift);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x52:\n\n            /* MSKWH */\n\n            gen_msk_h(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x57:\n\n            /* INSWH */\n\n            gen_ins_h(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x5A:\n\n            /* EXTWH */\n\n            gen_ext_h(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x62:\n\n            /* MSKLH */\n\n            gen_msk_h(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x67:\n\n            /* INSLH */\n\n            gen_ins_h(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x6A:\n\n            /* EXTLH */\n\n            gen_ext_h(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x72:\n\n            /* MSKQH */\n\n            gen_msk_h(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x77:\n\n            /* INSQH */\n\n            gen_ins_h(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x7A:\n\n            /* EXTQH */\n\n            gen_ext_h(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x13:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* MULL */\n\n            if (likely(rc != 31)) {\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_muli_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_mul_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x20:\n\n            /* MULQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                } else if (islit) {\n\n                    tcg_gen_muli_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                } else {\n\n                    tcg_gen_mul_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x30:\n\n            /* UMULH */\n\n            {\n\n                TCGv low;\n\n                if (unlikely(rc == 31)){\n\n                    break;\n\n                }\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                    break;\n\n                }\n\n                low = tcg_temp_new();\n\n                if (islit) {\n\n                    tcg_gen_movi_tl(low, lit);\n\n                    tcg_gen_mulu2_i64(low, cpu_ir[rc], cpu_ir[ra], low);\n\n                } else {\n\n                    tcg_gen_mulu2_i64(low, cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                }\n\n                tcg_temp_free(low);\n\n            }\n\n            break;\n\n        case 0x40:\n\n            /* MULL/V */\n\n            gen_mullv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x60:\n\n            /* MULQ/V */\n\n            gen_mulqv(ra, rb, rc, islit, lit);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x14:\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x04:\n\n            /* ITOFS */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_trunc_i64_i32(tmp, cpu_ir[ra]);\n\n                    gen_helper_memory_to_s(cpu_fir[rc], tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x0A:\n\n            /* SQRTF */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrtf(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x0B:\n\n            /* SQRTS */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrts(ctx, rb, rc, fn11);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x14:\n\n            /* ITOFF */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_trunc_i64_i32(tmp, cpu_ir[ra]);\n\n                    gen_helper_memory_to_f(cpu_fir[rc], tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x24:\n\n            /* ITOFT */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    tcg_gen_mov_i64(cpu_fir[rc], cpu_ir[ra]);\n\n                } else {\n\n                    tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n                }\n\n            }\n\n            break;\n\n        case 0x2A:\n\n            /* SQRTG */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrtg(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x02B:\n\n            /* SQRTT */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrtt(ctx, rb, rc, fn11);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x15:\n\n        /* VAX floating point */\n\n        /* XXX: rounding mode and trap are ignored (!) */\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x00:\n\n            /* ADDF */\n\n            gen_faddf(ra, rb, rc);\n\n            break;\n\n        case 0x01:\n\n            /* SUBF */\n\n            gen_fsubf(ra, rb, rc);\n\n            break;\n\n        case 0x02:\n\n            /* MULF */\n\n            gen_fmulf(ra, rb, rc);\n\n            break;\n\n        case 0x03:\n\n            /* DIVF */\n\n            gen_fdivf(ra, rb, rc);\n\n            break;\n\n        case 0x1E:\n\n            /* CVTDG */\n\n#if 0 // TODO\n\n            gen_fcvtdg(rb, rc);\n\n#else\n\n            goto invalid_opc;\n\n#endif\n\n            break;\n\n        case 0x20:\n\n            /* ADDG */\n\n            gen_faddg(ra, rb, rc);\n\n            break;\n\n        case 0x21:\n\n            /* SUBG */\n\n            gen_fsubg(ra, rb, rc);\n\n            break;\n\n        case 0x22:\n\n            /* MULG */\n\n            gen_fmulg(ra, rb, rc);\n\n            break;\n\n        case 0x23:\n\n            /* DIVG */\n\n            gen_fdivg(ra, rb, rc);\n\n            break;\n\n        case 0x25:\n\n            /* CMPGEQ */\n\n            gen_fcmpgeq(ra, rb, rc);\n\n            break;\n\n        case 0x26:\n\n            /* CMPGLT */\n\n            gen_fcmpglt(ra, rb, rc);\n\n            break;\n\n        case 0x27:\n\n            /* CMPGLE */\n\n            gen_fcmpgle(ra, rb, rc);\n\n            break;\n\n        case 0x2C:\n\n            /* CVTGF */\n\n            gen_fcvtgf(rb, rc);\n\n            break;\n\n        case 0x2D:\n\n            /* CVTGD */\n\n#if 0 // TODO\n\n            gen_fcvtgd(rb, rc);\n\n#else\n\n            goto invalid_opc;\n\n#endif\n\n            break;\n\n        case 0x2F:\n\n            /* CVTGQ */\n\n            gen_fcvtgq(rb, rc);\n\n            break;\n\n        case 0x3C:\n\n            /* CVTQF */\n\n            gen_fcvtqf(rb, rc);\n\n            break;\n\n        case 0x3E:\n\n            /* CVTQG */\n\n            gen_fcvtqg(rb, rc);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x16:\n\n        /* IEEE floating-point */\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x00:\n\n            /* ADDS */\n\n            gen_fadds(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x01:\n\n            /* SUBS */\n\n            gen_fsubs(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x02:\n\n            /* MULS */\n\n            gen_fmuls(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x03:\n\n            /* DIVS */\n\n            gen_fdivs(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x20:\n\n            /* ADDT */\n\n            gen_faddt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x21:\n\n            /* SUBT */\n\n            gen_fsubt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x22:\n\n            /* MULT */\n\n            gen_fmult(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x23:\n\n            /* DIVT */\n\n            gen_fdivt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x24:\n\n            /* CMPTUN */\n\n            gen_fcmptun(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x25:\n\n            /* CMPTEQ */\n\n            gen_fcmpteq(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x26:\n\n            /* CMPTLT */\n\n            gen_fcmptlt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x27:\n\n            /* CMPTLE */\n\n            gen_fcmptle(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x2C:\n\n            if (fn11 == 0x2AC || fn11 == 0x6AC) {\n\n                /* CVTST */\n\n                gen_fcvtst(ctx, rb, rc, fn11);\n\n            } else {\n\n                /* CVTTS */\n\n                gen_fcvtts(ctx, rb, rc, fn11);\n\n            }\n\n            break;\n\n        case 0x2F:\n\n            /* CVTTQ */\n\n            gen_fcvttq(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x3C:\n\n            /* CVTQS */\n\n            gen_fcvtqs(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x3E:\n\n            /* CVTQT */\n\n            gen_fcvtqt(ctx, rb, rc, fn11);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x17:\n\n        switch (fn11) {\n\n        case 0x010:\n\n            /* CVTLQ */\n\n            gen_fcvtlq(rb, rc);\n\n            break;\n\n        case 0x020:\n\n            if (likely(rc != 31)) {\n\n                if (ra == rb) {\n\n                    /* FMOV */\n\n                    if (ra == 31) {\n\n                        tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_fir[rc], cpu_fir[ra]);\n\n                    }\n\n                } else {\n\n                    /* CPYS */\n\n                    gen_fcpys(ra, rb, rc);\n\n                }\n\n            }\n\n            break;\n\n        case 0x021:\n\n            /* CPYSN */\n\n            gen_fcpysn(ra, rb, rc);\n\n            break;\n\n        case 0x022:\n\n            /* CPYSE */\n\n            gen_fcpyse(ra, rb, rc);\n\n            break;\n\n        case 0x024:\n\n            /* MT_FPCR */\n\n            if (likely(ra != 31)) {\n\n                gen_helper_store_fpcr(cpu_env, cpu_fir[ra]);\n\n            } else {\n\n                TCGv tmp = tcg_const_i64(0);\n\n                gen_helper_store_fpcr(cpu_env, tmp);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n        case 0x025:\n\n            /* MF_FPCR */\n\n            if (likely(ra != 31)) {\n\n                gen_helper_load_fpcr(cpu_fir[ra], cpu_env);\n\n            }\n\n            break;\n\n        case 0x02A:\n\n            /* FCMOVEQ */\n\n            gen_fcmov(TCG_COND_EQ, ra, rb, rc);\n\n            break;\n\n        case 0x02B:\n\n            /* FCMOVNE */\n\n            gen_fcmov(TCG_COND_NE, ra, rb, rc);\n\n            break;\n\n        case 0x02C:\n\n            /* FCMOVLT */\n\n            gen_fcmov(TCG_COND_LT, ra, rb, rc);\n\n            break;\n\n        case 0x02D:\n\n            /* FCMOVGE */\n\n            gen_fcmov(TCG_COND_GE, ra, rb, rc);\n\n            break;\n\n        case 0x02E:\n\n            /* FCMOVLE */\n\n            gen_fcmov(TCG_COND_LE, ra, rb, rc);\n\n            break;\n\n        case 0x02F:\n\n            /* FCMOVGT */\n\n            gen_fcmov(TCG_COND_GT, ra, rb, rc);\n\n            break;\n\n        case 0x030:\n\n            /* CVTQL */\n\n            gen_fcvtql(rb, rc);\n\n            break;\n\n        case 0x130:\n\n            /* CVTQL/V */\n\n        case 0x530:\n\n            /* CVTQL/SV */\n\n            /* ??? I'm pretty sure there's nothing that /sv needs to do that\n\n               /v doesn't do.  The only thing I can think is that /sv is a\n\n               valid instruction merely for completeness in the ISA.  */\n\n            gen_fcvtql_v(ctx, rb, rc);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x18:\n\n        switch ((uint16_t)disp16) {\n\n        case 0x0000:\n\n            /* TRAPB */\n\n            /* No-op.  */\n\n            break;\n\n        case 0x0400:\n\n            /* EXCB */\n\n            /* No-op.  */\n\n            break;\n\n        case 0x4000:\n\n            /* MB */\n\n            /* No-op */\n\n            break;\n\n        case 0x4400:\n\n            /* WMB */\n\n            /* No-op */\n\n            break;\n\n        case 0x8000:\n\n            /* FETCH */\n\n            /* No-op */\n\n            break;\n\n        case 0xA000:\n\n            /* FETCH_M */\n\n            /* No-op */\n\n            break;\n\n        case 0xC000:\n\n            /* RPCC */\n\n            if (ra != 31) {\n\n                if (use_icount) {\n\n                    gen_io_start();\n\n                    gen_helper_load_pcc(cpu_ir[ra], cpu_env);\n\n                    gen_io_end();\n\n                    ret = EXIT_PC_STALE;\n\n                } else {\n\n                    gen_helper_load_pcc(cpu_ir[ra], cpu_env);\n\n                }\n\n            }\n\n            break;\n\n        case 0xE000:\n\n            /* RC */\n\n            gen_rx(ra, 0);\n\n            break;\n\n        case 0xE800:\n\n            /* ECB */\n\n            break;\n\n        case 0xF000:\n\n            /* RS */\n\n            gen_rx(ra, 1);\n\n            break;\n\n        case 0xF800:\n\n            /* WH64 */\n\n            /* No-op */\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x19:\n\n        /* HW_MFPR (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            return gen_mfpr(ra, insn & 0xffff);\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1A:\n\n        /* JMP, JSR, RET, JSR_COROUTINE.  These only differ by the branch\n\n           prediction stack action, which of course we don't implement.  */\n\n        if (rb != 31) {\n\n            tcg_gen_andi_i64(cpu_pc, cpu_ir[rb], ~3);\n\n        } else {\n\n            tcg_gen_movi_i64(cpu_pc, 0);\n\n        }\n\n        if (ra != 31) {\n\n            tcg_gen_movi_i64(cpu_ir[ra], ctx->pc);\n\n        }\n\n        ret = EXIT_PC_UPDATED;\n\n        break;\n\n    case 0x1B:\n\n        /* HW_LD (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            TCGv addr;\n\n\n\n            if (ra == 31) {\n\n                break;\n\n            }\n\n\n\n            addr = tcg_temp_new();\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(addr, cpu_ir[rb], disp12);\n\n            } else {\n\n                tcg_gen_movi_i64(addr, disp12);\n\n            }\n\n            switch ((insn >> 12) & 0xF) {\n\n            case 0x0:\n\n                /* Longword physical access (hw_ldl/p) */\n\n                gen_helper_ldl_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x1:\n\n                /* Quadword physical access (hw_ldq/p) */\n\n                gen_helper_ldq_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x2:\n\n                /* Longword physical access with lock (hw_ldl_l/p) */\n\n                gen_helper_ldl_l_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x3:\n\n                /* Quadword physical access with lock (hw_ldq_l/p) */\n\n                gen_helper_ldq_l_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x4:\n\n                /* Longword virtual PTE fetch (hw_ldl/v) */\n\n                goto invalid_opc;\n\n            case 0x5:\n\n                /* Quadword virtual PTE fetch (hw_ldq/v) */\n\n                goto invalid_opc;\n\n                break;\n\n            case 0x6:\n\n                /* Incpu_ir[ra]id */\n\n                goto invalid_opc;\n\n            case 0x7:\n\n                /* Incpu_ir[ra]id */\n\n                goto invalid_opc;\n\n            case 0x8:\n\n                /* Longword virtual access (hw_ldl) */\n\n                goto invalid_opc;\n\n            case 0x9:\n\n                /* Quadword virtual access (hw_ldq) */\n\n                goto invalid_opc;\n\n            case 0xA:\n\n                /* Longword virtual access with protection check (hw_ldl/w) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_KERNEL_IDX, MO_LESL);\n\n                break;\n\n            case 0xB:\n\n                /* Quadword virtual access with protection check (hw_ldq/w) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_KERNEL_IDX, MO_LEQ);\n\n                break;\n\n            case 0xC:\n\n                /* Longword virtual access with alt access mode (hw_ldl/a)*/\n\n                goto invalid_opc;\n\n            case 0xD:\n\n                /* Quadword virtual access with alt access mode (hw_ldq/a) */\n\n                goto invalid_opc;\n\n            case 0xE:\n\n                /* Longword virtual access with alternate access mode and\n\n                   protection checks (hw_ldl/wa) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_USER_IDX, MO_LESL);\n\n                break;\n\n            case 0xF:\n\n                /* Quadword virtual access with alternate access mode and\n\n                   protection checks (hw_ldq/wa) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_USER_IDX, MO_LEQ);\n\n                break;\n\n            }\n\n            tcg_temp_free(addr);\n\n            break;\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1C:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* SEXTB */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_BWX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (islit) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], (int64_t)((int8_t)lit));\n\n                } else {\n\n                    tcg_gen_ext8s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x01:\n\n            /* SEXTW */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], (int64_t)((int16_t)lit));\n\n                    } else {\n\n                        tcg_gen_ext16s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x30:\n\n            /* CTPOP */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ctpop64(lit));\n\n                    } else {\n\n                        gen_helper_ctpop(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x31:\n\n            /* PERR */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_perr(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x32:\n\n            /* CTLZ */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], clz64(lit));\n\n                    } else {\n\n                        gen_helper_ctlz(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x33:\n\n            /* CTTZ */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ctz64(lit));\n\n                    } else {\n\n                        gen_helper_cttz(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x34:\n\n            /* UNPKBW */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_unpkbw(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x35:\n\n            /* UNPKBL */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_unpkbl(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x36:\n\n            /* PKWB */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_pkwb(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x37:\n\n            /* PKLB */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_pklb(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x38:\n\n            /* MINSB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minsb8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x39:\n\n            /* MINSW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minsw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3A:\n\n            /* MINUB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minub8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3B:\n\n            /* MINUW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minuw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3C:\n\n            /* MAXUB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxub8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3D:\n\n            /* MAXUW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxuw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3E:\n\n            /* MAXSB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxsb8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3F:\n\n            /* MAXSW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxsw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x70:\n\n            /* FTOIT */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    tcg_gen_mov_i64(cpu_ir[rc], cpu_fir[ra]);\n\n                } else {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                }\n\n            }\n\n            break;\n\n        case 0x78:\n\n            /* FTOIS */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (rc != 31) {\n\n                TCGv_i32 tmp1 = tcg_temp_new_i32();\n\n                if (ra != 31) {\n\n                    gen_helper_s_to_memory(tmp1, cpu_fir[ra]);\n\n                } else {\n\n                    TCGv tmp2 = tcg_const_i64(0);\n\n                    gen_helper_s_to_memory(tmp1, tmp2);\n\n                    tcg_temp_free(tmp2);\n\n                }\n\n                tcg_gen_ext_i32_i64(cpu_ir[rc], tmp1);\n\n                tcg_temp_free_i32(tmp1);\n\n            }\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x1D:\n\n        /* HW_MTPR (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            return gen_mtpr(ctx, rb, insn & 0xffff);\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1E:\n\n        /* HW_RET (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            if (rb == 31) {\n\n                /* Pre-EV6 CPUs interpreted this as HW_REI, loading the return\n\n                   address from EXC_ADDR.  This turns out to be useful for our\n\n                   emulation PALcode, so continue to accept it.  */\n\n                TCGv tmp = tcg_temp_new();\n\n                tcg_gen_ld_i64(tmp, cpu_env, offsetof(CPUAlphaState, exc_addr));\n\n                gen_helper_hw_ret(cpu_env, tmp);\n\n                tcg_temp_free(tmp);\n\n            } else {\n\n                gen_helper_hw_ret(cpu_env, cpu_ir[rb]);\n\n            }\n\n            ret = EXIT_PC_UPDATED;\n\n            break;\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1F:\n\n        /* HW_ST (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            TCGv addr, val;\n\n            addr = tcg_temp_new();\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(addr, cpu_ir[rb], disp12);\n\n            } else {\n\n                tcg_gen_movi_i64(addr, disp12);\n\n            }\n\n            if (ra != 31) {\n\n                val = cpu_ir[ra];\n\n            } else {\n\n                val = tcg_temp_new();\n\n                tcg_gen_movi_i64(val, 0);\n\n            }\n\n            switch ((insn >> 12) & 0xF) {\n\n            case 0x0:\n\n                /* Longword physical access */\n\n                gen_helper_stl_phys(cpu_env, addr, val);\n\n                break;\n\n            case 0x1:\n\n                /* Quadword physical access */\n\n                gen_helper_stq_phys(cpu_env, addr, val);\n\n                break;\n\n            case 0x2:\n\n                /* Longword physical access with lock */\n\n                gen_helper_stl_c_phys(val, cpu_env, addr, val);\n\n                break;\n\n            case 0x3:\n\n                /* Quadword physical access with lock */\n\n                gen_helper_stq_c_phys(val, cpu_env, addr, val);\n\n                break;\n\n            case 0x4:\n\n                /* Longword virtual access */\n\n                goto invalid_opc;\n\n            case 0x5:\n\n                /* Quadword virtual access */\n\n                goto invalid_opc;\n\n            case 0x6:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x7:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x8:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x9:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xA:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xB:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xC:\n\n                /* Longword virtual access with alternate access mode */\n\n                goto invalid_opc;\n\n            case 0xD:\n\n                /* Quadword virtual access with alternate access mode */\n\n                goto invalid_opc;\n\n            case 0xE:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xF:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            }\n\n            if (ra == 31) {\n\n                tcg_temp_free(val);\n\n            }\n\n            tcg_temp_free(addr);\n\n            break;\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x20:\n\n        /* LDF */\n\n        gen_load_mem(ctx, &gen_qemu_ldf, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x21:\n\n        /* LDG */\n\n        gen_load_mem(ctx, &gen_qemu_ldg, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x22:\n\n        /* LDS */\n\n        gen_load_mem(ctx, &gen_qemu_lds, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x23:\n\n        /* LDT */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x24:\n\n        /* STF */\n\n        gen_store_mem(ctx, &gen_qemu_stf, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x25:\n\n        /* STG */\n\n        gen_store_mem(ctx, &gen_qemu_stg, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x26:\n\n        /* STS */\n\n        gen_store_mem(ctx, &gen_qemu_sts, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x27:\n\n        /* STT */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x28:\n\n        /* LDL */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld32s, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x29:\n\n        /* LDQ */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2A:\n\n        /* LDL_L */\n\n        gen_load_mem(ctx, &gen_qemu_ldl_l, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2B:\n\n        /* LDQ_L */\n\n        gen_load_mem(ctx, &gen_qemu_ldq_l, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2C:\n\n        /* STL */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st32, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2D:\n\n        /* STQ */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2E:\n\n        /* STL_C */\n\n        ret = gen_store_conditional(ctx, ra, rb, disp16, 0);\n\n        break;\n\n    case 0x2F:\n\n        /* STQ_C */\n\n        ret = gen_store_conditional(ctx, ra, rb, disp16, 1);\n\n        break;\n\n    case 0x30:\n\n        /* BR */\n\n        ret = gen_bdirect(ctx, ra, disp21);\n\n        break;\n\n    case 0x31: /* FBEQ */\n\n        ret = gen_fbcond(ctx, TCG_COND_EQ, ra, disp21);\n\n        break;\n\n    case 0x32: /* FBLT */\n\n        ret = gen_fbcond(ctx, TCG_COND_LT, ra, disp21);\n\n        break;\n\n    case 0x33: /* FBLE */\n\n        ret = gen_fbcond(ctx, TCG_COND_LE, ra, disp21);\n\n        break;\n\n    case 0x34:\n\n        /* BSR */\n\n        ret = gen_bdirect(ctx, ra, disp21);\n\n        break;\n\n    case 0x35: /* FBNE */\n\n        ret = gen_fbcond(ctx, TCG_COND_NE, ra, disp21);\n\n        break;\n\n    case 0x36: /* FBGE */\n\n        ret = gen_fbcond(ctx, TCG_COND_GE, ra, disp21);\n\n        break;\n\n    case 0x37: /* FBGT */\n\n        ret = gen_fbcond(ctx, TCG_COND_GT, ra, disp21);\n\n        break;\n\n    case 0x38:\n\n        /* BLBC */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 1);\n\n        break;\n\n    case 0x39:\n\n        /* BEQ */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 0);\n\n        break;\n\n    case 0x3A:\n\n        /* BLT */\n\n        ret = gen_bcond(ctx, TCG_COND_LT, ra, disp21, 0);\n\n        break;\n\n    case 0x3B:\n\n        /* BLE */\n\n        ret = gen_bcond(ctx, TCG_COND_LE, ra, disp21, 0);\n\n        break;\n\n    case 0x3C:\n\n        /* BLBS */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 1);\n\n        break;\n\n    case 0x3D:\n\n        /* BNE */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 0);\n\n        break;\n\n    case 0x3E:\n\n        /* BGE */\n\n        ret = gen_bcond(ctx, TCG_COND_GE, ra, disp21, 0);\n\n        break;\n\n    case 0x3F:\n\n        /* BGT */\n\n        ret = gen_bcond(ctx, TCG_COND_GT, ra, disp21, 0);\n\n        break;\n\n    invalid_opc:\n\n        ret = gen_invalid(ctx);\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 10295, "substitutes": {"ctx": ["cas", "utils", "hw", "scl", "xc", "anc", "buf", "irc", "proc", "bc", "xs", "c", "conv", "ca", "jp", "qt", "config", "cgi", "cb", "kb", "lex", "sci", " cx", "loc", "cm", "cp", "ctrl", "grad", "context", " context", "cc", "cv", "ci", "conn", "cf", "sc", "tx", "obj", "tc", "lc", " c", "gc", "cca", "txt", "exec"], "insn": ["insnor", "incv", "tsne", "opensn", "dsm", "incnan", "risna", "lsne", "openssn", " insm", "insd", "intsN", "gesn", "lsn", "inn", " insp", "itsg", "opensna", " insna", "tssn", "issn", "minsg", "issp", "rulesyn", " insd", "minsnan", "inns", "inpn", "incn", "lsg", "gesnan", "gesnor", "inssn", "itsconn", "incd", "INSn", "allsc", "insv", "gesna", "incns", "dsd", "kinsner", "outsnn", "dsn", "isspn", "itsn", "INSzn", "risn", "rulesn", " insns", "incpn", "INSdn", "lssn", "rsm", "inp", "incN", " insc", "minsyn", " insconn", "allsn", "insconn", "rsn", " insne", "intsyn", "allsne", "opensnor", "rsyn", " insdn", "gesg", "rulesne", "tsn", "gesyn", "issd", "inna", " inssn", "lsconn", " insN", "outszn", "insg", "alsn", "INSsn", "rsd", "outsne", "insne", "INSna", "intsv", "alsN", "alsv", "kinsn", "lsnan", "inN", "insN", "incg", "incp", "outsn", "insnan", "ind", "opensd", "kinsna", "alsyn", "itsc", "insm", "tsyn", "allsnn", "insyn", "insna", "outsc", "inspn", "INSnor", "outssn", "inszn", "outsdn", "gessn", "insner", "outsna", "insdn", "dsyn", "itsne", "minsn", "rulessn", "itssn", "INSc", "outsd", " inszn", "risc", "inner", "risner", "gesne", "inc", "insns", "intsn", "itsnn", "insnn", "incyn", "itsnan", "incsn", "kinsc", " insyn", "insc", "insp"], "palcode": ["opCode", "plcod", "opcodes", "opaldesc", " palCode", "palCode", "binCode", "calstr", "palmode", "pelCode", "palcodes", "opstr", "caldesc", "opalcodes", "opalcode", "palcod", "calcodes", "bincod", "bincode", "plcode", "pelmode", "palstr", "pelcodes", "calmode", "calCode", "paldesc", "opalmode", " palstr", "peldesc", "opcode", "bincodes", "plcodes", "plCode", "pelcode", "pelcod", " palcodes", "calcode"], "disp21": ["disp211", " disop26", "disP61", " disop14", " disop21", " disp22", " dispatch61", "dispp211", "dispatch21", "disop14", "dispc26", "dispr22", "dispc21", "disop21", " disp61", "disp14", "disop22", "dispr26", "disop26", " disp14", "dispatch61", " disp211", "dispp21", "disp61", "dispr14", "dispr21", "dispatch211", "dispp61", " dispatch21", "disP21", " dispatch211", "disp26", "disp22", "dispc22", "dispc14", " disop22", " disp26", "disP211"], "disp16": ["dispr6", "disnp22", "interpp6", "unp18", "interpp8", "interp16", "dispp18", "disnp16", "rispr06", "disjp8", "rispr16", "disfp6", "interp21", "disvp16", "dispp60", "risp6", "disjp16", "unp31", "risp06", "unpp16", "dispr06", "disp06", "interp6", "unpp22", "disnp6", "disp31", "disnp60", "disp60", "disp18", "rispr6", "disnp06", "disjp6", "interp8", "disvp18", "risp60", "disp8", "disvp22", "dispp21", "risp16", "dispp8", "unpp18", "disfp8", "unp16", "rispr60", "dispp6", "disvp31", "interpp21", "dispr60", "dispp06", "dispp22", "dispp16", "dispr16", "disp6", "disnp31", "disfp16", "disjp21", "unpp31", "disfp21", "disp22", "disnp18", "unp22", "interpp16", "dispp31"], "disp12": ["disq32", "dispend40", "Discp02", "discp32", "discp12", "disps12", "rep32", "disf16", "ref32", "Disp16", "dispend02", "disq16", "disps02", "disp32", "dispend16", "discp16", "disp14", "disps40", "Disp02", "Discp40", "discp40", "ref16", "disp02", "ref12", "ref14", "disps16", "rep14", "dispend12", "rep16", "discp02", "Discp12", "rep12", "disq12", "disq14", "disf12", "Disp40", "Disp12", "disf14", "discp14", "disf32", "Discp16", "disp40"], "fn11": ["fc1", "fc7", " fn12", "ln11", "fp12", "fc12", " fn1", "fn13", "fp1", "fp7", "FN13", "fd14", "ln14", "FN11", "fd1", "fp11", "fd11", "FN12", "fn14", " fn13", "fn12", " fn14", "fp13", "fn1", "ln1", "FN1", "fc11", "fd12", "ln12"], "opc": ["iopc", "roplc", " opf", "opf", "Opcd", "ropcn", " opct", " opcn", "opercs", "Opci", "operci", "ropcs", "opcs", "oppc", "operc", "iopf", "Opc", " opC", " opci", " oplc", "Opcn", "ropcd", "yppc", "optc", "ypc", "oplc", "Opcs", "optn", "ypct", "ioppc", " opn", "opcd", "ropci", "opn", "ropc", "opC", "optcs", "opct", "iopct", "Oplc", "ypf", "ropC", "OpC", "opci", "optci", " opcd", "opcn", " oppc", " opcs", "opern"], "ra": ["la", "rt", "tra", "src", "va", "ria", "ref", "na", "rg", "rad", "ma", "min", "alpha", "a", "ca", "sr", "ru", "ro", "ri", "rd", "ha", "loc", "range", "asa", "ran", "ar", "RA", "sha", "ras", "r", "da", "area", "ara", "cr", "as", "ta", "wa", "Ra", "RC", "rs", "era", "rar", "rr", "sa", "aria", "role", "dra", "ba"], "rb": ["usr", "rt", "abc", "src", "nr", "ref", "rab", "arb", "raf", "rg", "adr", "pb", "rob", "nb", "db", "lb", "sr", "sb", "ru", "ri", "lr", "cb", "rd", "rl", "rf", "b", "fb", "rn", "vr", "gb", "ruby", "RB", "bb", "r", "xb", "reb", "erb", "ab", "cr", "RR", "rid", "rar", "rr", "wb", "rh", "bf"], "rc": ["rw", "rt", "src", "ref", "irc", "rg", "c", "pc", "sr", "ru", "config", "ri", "cur", "rl", "rf", "loc", "rn", "vr", "gb", "ruby", "fc", "ac", "ras", "roc", "r", "rx", "reb", "sc", "rec", "cr", "rin", "RC", "rs", "rar", "rr", "uc", "rh"], "fpfn": ["rffat", "vpfat", "fpfilename", "fwfile", "fwfunc", "tffilename", "vpfn", "tffat", "rffile", "vpfile", "vpfilename", "fpfunc", "lpfile", "tffn", "fwfp", "rffn", "fnfp", "fnfunc", "fpfile", "lpfp", "fwfn", "fnfile", "fpfp", "fpfat", "tffile", "rffilename", "lpfunc", "lpfn", "fnfn"], "fn7": ["rn701", "fn701", "fp701", "fp7", "hn9", "hn8", "fp77", "rn7", " fn9", "fn8", "rn8", "fn9", "fp9", "hn7", "hn77", "rn9", "fp8", " fn701", " fn77", "fn77", " fn8"], "islit": ["islitting", "idelits", "oblited", "ilits", "implit", "nlitor", "ielitting", "chalitable", "implits", "islits", "ilite", "islitable", "islat", "isalitor", "ielit", "ielitt", "unicitable", "islited", "idelitting", "ilitted", "idelit", "ilitable", "isalitted", "implitable", "ilitting", "isalit", "islitted", "llited", "oplat", "llitt", "llitting", "nlitted", "unicit", "idelitable", "oblit", "islitt", "oblitting", "chalat", "isalite", "ilit", "ilitor", "chalit", "ielited", "unicat", "chalitting", "oblitt", "nlite", "islite", "unicitting", "oplitting", "nlit", "llit", "oplitable", "implitting", "islitor", "oplit"], "real_islit": ["real_splitic", "real_islitted", "real_islite", "real_slitted", "real_splite", "real_slit", "real_ilite", "real_sli", "real_blite", "real_splitting", "real_split", "real_ielite", "real_ili", "real_bli", "real_islitting", "real_ilitting", "real_ilitted", "real_ilit", "real_islitic", "real_slite", "real_ielit", "real_ilitic", "real_ielitting", "real_blit", "real_ielitic", "real_isli", "real_blitted"], "lit": ["la", "abi", "sil", "pit", "text", "lif", "rt", "rets", "pl", "proc", "sel", "lt", "stat", "al", "iter", "eval", "cat", "slot", "expr", "loc", "split", "ident", " lib", "lim", "bit", "ie", "sl", "fat", "il", "lang", "op", "rot", "num", "lin", "rel", "opt", "mit", "l", "def", "lib", "ab", "lite", "fit", "info", "util", "lc", "sec", "nt", "or", "wat", "alt", "typ", "let", "it"], "ret": ["pass", "rets", "type", "rt", "match", "resp", "re", "RET", "final", "ref", "repl", "rev", "class", "fi", "result", "success", "eval", " RET", "cat", "back", "rl", "fun", "ut", "gt", "mem", "rel", "det", "rep", "def", "lib", "job", "arg", "reply", "obj", "sys", "util", "res", "reg", "status", "Ret", "alt", "feat", "let"]}}
{"project": "FFmpeg", "commit_id": "53e5462040f6f7273fb6b0d7592eea1f5d26829f", "target": 0, "func": "inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, long dstWidth, const uint8_t *src1, const uint8_t *src2,\n\n                                   int srcW, int xInc, int flags, const int16_t *hChrFilter,\n\n                                   const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                   int srcFormat, uint8_t *formatConvBuffer,\n\n                                   uint32_t *pal)\n\n{\n\n    int32_t av_unused *mmx2FilterPos = c->chrMmx2FilterPos;\n\n    int16_t av_unused *mmx2Filter    = c->chrMmx2Filter;\n\n    int     av_unused canMMX2BeUsed  = c->canMMX2BeUsed;\n\n    void    av_unused *mmx2FilterCode= c->chrMmx2FilterCode;\n\n\n\n    if (isGray(srcFormat) || srcFormat==PIX_FMT_MONOBLACK || srcFormat==PIX_FMT_MONOWHITE)\n\n        return;\n\n\n\n    if (srcFormat==PIX_FMT_RGB32_1 || srcFormat==PIX_FMT_BGR32_1) {\n\n        src1 += ALT32_CORR;\n\n        src2 += ALT32_CORR;\n\n    }\n\n\n\n    if (srcFormat==PIX_FMT_RGB48LE) {\n\n        src1++;\n\n        src2++;\n\n    }\n\n\n\n    if (c->hcscale_internal) {\n\n        c->hcscale_internal(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= formatConvBuffer+VOFW;\n\n    }\n\n\n\n#if COMPILE_TEMPLATE_MMX\n\n    // Use the new MMX scaler if the MMX2 one can't be used (it is faster than the x86 ASM one).\n\n    if (!(flags&SWS_FAST_BILINEAR) || (!canMMX2BeUsed))\n\n#else\n\n    if (!(flags&SWS_FAST_BILINEAR))\n\n#endif\n\n    {\n\n        c->hScale(dst     , dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n#if ARCH_X86 && CONFIG_GPL\n\n#if COMPILE_TEMPLATE_MMX2\n\n        int i;\n\n#if defined(PIC)\n\n        DECLARE_ALIGNED(8, uint64_t, ebxsave);\n\n#endif\n\n        if (canMMX2BeUsed) {\n\n            __asm__ volatile(\n\n#if defined(PIC)\n\n                \"mov          %%\"REG_b\", %6         \\n\\t\"\n\n#endif\n\n                \"pxor             %%mm7, %%mm7      \\n\\t\"\n\n                \"mov                 %0, %%\"REG_c\"  \\n\\t\"\n\n                \"mov                 %1, %%\"REG_D\"  \\n\\t\"\n\n                \"mov                 %2, %%\"REG_d\"  \\n\\t\"\n\n                \"mov                 %3, %%\"REG_b\"  \\n\\t\"\n\n                \"xor          %%\"REG_a\", %%\"REG_a\"  \\n\\t\" // i\n\n                PREFETCH\"   (%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 32(%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 64(%%\"REG_c\")             \\n\\t\"\n\n\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                \"xor          %%\"REG_a\", %%\"REG_a\"  \\n\\t\" // i\n\n                \"mov                 %5, %%\"REG_c\"  \\n\\t\" // src\n\n                \"mov                 %1, %%\"REG_D\"  \\n\\t\" // buf1\n\n                \"add              $\"AV_STRINGIFY(VOF)\", %%\"REG_D\"  \\n\\t\"\n\n                PREFETCH\"   (%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 32(%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 64(%%\"REG_c\")             \\n\\t\"\n\n\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n\n\n#if defined(PIC)\n\n                \"mov %6, %%\"REG_b\"    \\n\\t\"\n\n#endif\n\n                :: \"m\" (src1), \"m\" (dst), \"m\" (mmx2Filter), \"m\" (mmx2FilterPos),\n\n                \"m\" (mmx2FilterCode), \"m\" (src2)\n\n#if defined(PIC)\n\n                ,\"m\" (ebxsave)\n\n#endif\n\n                : \"%\"REG_a, \"%\"REG_c, \"%\"REG_d, \"%\"REG_S, \"%\"REG_D\n\n#if !defined(PIC)\n\n                ,\"%\"REG_b\n\n#endif\n\n            );\n\n            for (i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) {\n\n                //printf(\"%d %d %d\\n\", dstWidth, i, srcW);\n\n                dst[i] = src1[srcW-1]*128;\n\n                dst[i+VOFW] = src2[srcW-1]*128;\n\n            }\n\n        } else {\n\n#endif /* COMPILE_TEMPLATE_MMX2 */\n\n            x86_reg xInc_shr16 = (x86_reg) (xInc >> 16);\n\n            uint16_t xInc_mask = xInc & 0xffff;\n\n            __asm__ volatile(\n\n                \"xor %%\"REG_a\", %%\"REG_a\"               \\n\\t\" // i\n\n                \"xor %%\"REG_d\", %%\"REG_d\"               \\n\\t\" // xx\n\n                \"xorl    %%ecx, %%ecx                   \\n\\t\" // xalpha\n\n                ASMALIGN(4)\n\n                \"1:                                     \\n\\t\"\n\n                \"mov        %0, %%\"REG_S\"               \\n\\t\"\n\n                \"movzbl  (%%\"REG_S\", %%\"REG_d\"), %%edi  \\n\\t\" //src[xx]\n\n                \"movzbl 1(%%\"REG_S\", %%\"REG_d\"), %%esi  \\n\\t\" //src[xx+1]\n\n                FAST_BILINEAR_X86\n\n                \"movw     %%si, (%%\"REG_D\", %%\"REG_a\", 2)   \\n\\t\"\n\n\n\n                \"movzbl    (%5, %%\"REG_d\"), %%edi       \\n\\t\" //src[xx]\n\n                \"movzbl   1(%5, %%\"REG_d\"), %%esi       \\n\\t\" //src[xx+1]\n\n                FAST_BILINEAR_X86\n\n                \"movw     %%si, \"AV_STRINGIFY(VOF)\"(%%\"REG_D\", %%\"REG_a\", 2)   \\n\\t\"\n\n\n\n                \"addw       %4, %%cx                    \\n\\t\" //xalpha += xInc&0xFFFF\n\n                \"adc        %3, %%\"REG_d\"               \\n\\t\" //xx+= xInc>>16 + carry\n\n                \"add        $1, %%\"REG_a\"               \\n\\t\"\n\n                \"cmp        %2, %%\"REG_a\"               \\n\\t\"\n\n                \" jb        1b                          \\n\\t\"\n\n\n\n/* GCC 3.3 makes MPlayer crash on IA-32 machines when using \"g\" operand here,\n\n   which is needed to support GCC 4.0. */\n\n#if ARCH_X86_64 && ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))\n\n                :: \"m\" (src1), \"m\" (dst), \"g\" (dstWidth), \"m\" (xInc_shr16), \"m\" (xInc_mask),\n\n#else\n\n                :: \"m\" (src1), \"m\" (dst), \"m\" (dstWidth), \"m\" (xInc_shr16), \"m\" (xInc_mask),\n\n#endif\n\n                \"r\" (src2)\n\n                : \"%\"REG_a, \"%\"REG_d, \"%ecx\", \"%\"REG_D, \"%esi\"\n\n            );\n\n#if COMPILE_TEMPLATE_MMX2\n\n        } //if MMX2 can't be used\n\n#endif\n\n#else\n\n        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);\n\n#endif /* ARCH_X86 */\n\n    }\n\n    if(c->srcRange != c->dstRange && !(isRGB(c->dstFormat) || isBGR(c->dstFormat))) {\n\n        int i;\n\n        //FIXME all pal and rgb srcFormats could do this convertion as well\n\n        //FIXME all scalers more complex than bilinear could do half of this transform\n\n        if(c->srcRange) {\n\n            for (i=0; i<dstWidth; i++) {\n\n                dst[i     ]= (dst[i     ]*1799 + 4081085)>>11; //1469\n\n                dst[i+VOFW]= (dst[i+VOFW]*1799 + 4081085)>>11; //1469\n\n            }\n\n        } else {\n\n            for (i=0; i<dstWidth; i++) {\n\n                dst[i     ]= (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264\n\n                dst[i+VOFW]= (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 10308, "substitutes": {"c": ["g", "f", "xc", "k", "cs", "nc", "ce", "vc", "ca", "cmp", "co", "d", "config", "h", "rc", "p", "enc", "cur", "b", "cy", "cp", "cm", "cu", "con", "ct", "ctrl", "center", "cont", "cal", "cc", "coll", "C", "dc", "ch", "ac", "cv", "client", "t", "l", "ci", "sc", "u", "cf", "conn", "m", "conf", "e", "n", "this", "cn", "lc", "s", "ec", "uc", "mc"], "dst": ["pddest", "dest", "Dst", " dST", "ddest", "wdsts", " dest", "pdsts", "wdst", "wdsrc", "sdsts", "sdst", "pdST", "Dest", "Dsts", " ddest", " dsts", "dsrc", "sdest", "wdST", "Ddest", " dsrc", "dST", "dsts", "pdst", "DST", "sdsrc", "Dsrc"], "dstWidth": ["dSTwidth", "dSTCut", "destWeight", "dstMaximum", "dStWidth", "destHeight", " dstWeight", " dstMaximum", "drcCut", "drcWidth", " dstHeight", "drestWidth", "drcwidth", " dstwidth", "dstCut", "dSTWidth", "ddestCut", " dSTHeight", " dstsWidth", "ddestHeight", "drcHeight", " dstsHeight", "dstwidth", "destwidth", "drestwidth", "destWidth", "dStHeight", " dstCut", "dStWeight", "dstswidth", "dstsHeight", "dSTHeight", "drestHeight", "ddestwidth", " dstswidth", " dSTWidth", "dStwidth", "dSTMaximum", "ddestWidth", "dstHeight", " dSTwidth", " dstsMaximum", "dstWeight", "dSTWeight", " dSTWeight", " dSTCut", "dstsMaximum", "dstsWidth", "drestMaximum"], "src1": [" src01", " src8", "src81", "srcone", "sourceone", "configone", "config01", " src4", "inst81", "suppOne", " srcone", "rcW", "rc01", "src8", " srcOne", "srcOne", "source4", "source01", "uintOne", "uint1", "rc81", "uintW", "rcone", "source1", "inst1", "inst2", "config1", "rc1", "rcOne", "supp8", "rc4", "instone", "src01", "sourceOne", "rc8", " src81", "src4", "inst01", "config2", "instOne", "rc2", "source2", "supp1", "uint2"], "src2": ["dest0", "config4", "destB", " src4", "src02", "img2", "inst02", " src02", "destTwo", "dest2", " srcB", "imgTwo", "configTwo", "srcB", "rcTwo", "scTwo", "inst2", "instTwo", " srcTwo", "rc4", "source4", "config1", "rc1", "rc0", "srcTwo", "src0", "instB", "src4", "img02", "sc02", "rcB", "config2", "rc2", "rc02", "source2", "sourceTwo", "img4", "sc2", " src0"], "srcW": ["sourceN", "destN", "rcL", "destW", "srcV", "srcL", "rcV", "sourceW", "srcw", "rcW", "destw", " srcWidth", " srcw", "destWidth", "rcw", "configw", "destV", "sourceWidth", "configW", "srcWidth", " srcL", " srcV", "sourcew", "rcWidth", "configN", " srcN", "rcN", "configL", "srcN"], "xInc": [" xinc", " xSec", " xEnc", "dxinc", "rxIncre", "xMin", " xMin", "XInv", "timeInv", "timeInc", "ixEnc", "XIncre", "xIncre", "timeinc", "dxSec", "ixMin", "rxInv", "timeIncre", "xSec", "XMin", "XEnc", "rxInc", "ixInc", "dxIncre", "xEnc", "rxinc", "xinc", "dxInc", " xIncre", "Xinc", "XInc", "XSec", "ixIncre", "xInv"], "flags": ["requires", "lag", "planes", "styles", "faces", "f", "opens", "args", "ats", "vals", "fires", "sf", "FLAG", "states", "powers", "tones", "fps", "ants", "options", "details", "settings", "ips", "fs", "orts", "reports", "fl", "ISS", "allows", "pages", "flag", "files", "atts", "forces", "alls", "rules", " Flags", "ags", "mask", "frames", "plugins", "ints", "versions", "bits", "lights", "Flags", "s", "lins", "lists", "stats", "types", "ports", "ops", "Flag", "features"], "hChrFilter": ["hChcrMask", "g", "hcharFilter", "hchrMask", "hchrF", "hChlFilter", "hChrMask", "hCharFactor", "hChcrFilter", "hcharLayer", "hCharF", "hChrConfig", "hcharMask", "hCharFilter", "hChrF", "hChrLayer", "hChcFactor", "hChlConfig", "hCharConfig", "hChcFilter", "hcharConfig", "hchrConfig", "hCharLayer", "bytes", "hChrFactor", "G", "hcharF", "hChcLayer", "hChcrFactor", "hChcrConfig", "hchrFilter", "hchrLayer", "hCharMask", "hchrFactor", "hChlLayer", "hChlMask", "color", "hChlF", "hcharFactor", "_", "all", "hChcF", "hChlFactor"], "hChrFilterPos": ["hChrFileType", "hChrListenerSize", "hChrListenerPos", "hChrFactorEx", "hChrFactorBase", "hChlFilePos", "hChrListenerNum", "hChrFilePos", "hChrtFilterPos", "hChrRuleBase", "hChlFileSize", "hChrFeatureDef", "hChrFileSize", "hChrRulePos", "hChrFilterDef", "hChrHelperNum", "hChrFilterNum", "hChrFeaturePos", "hChrHelperSize", "hChlFilterPos", "hChrtFilterEx", "hChrFilterBase", "hChrtFilterDef", "hChrtFactorPos", "hChrHelperType", "hChrFactorPos", "hChlFileType", "hChrHelperPos", "hChrFilterType", "hChrRuleDef", "hChrtFactorEx", "hChlFilterNum", "hChrRuleEx", "hChrtFilterBase", "hChrtFactorBase", "hChlFilterSize", "hChlFileNum", "hChrFeatureEx", "hChrFilterEx", "hChrFactorDef", "hChrtFactorDef", "hChrListenerType", "hChrFeatureBase", "hChlFilterType", "hChrFileNum"], "hChrFilterSize": ["hChnFactorLength", "hChrFLength", "hChrFlSize", "hChrFlPos", "hChrFPos", "hChrcFilterSize", "hChrcFilterOffset", "hChrFactorSize", "hChrBufferCode", "hChnFilterPos", "hChrRuleOffset", "hChrBufferSize", "hChrRuleSize", "hChnFactorPos", "hChrFilterCode", "hChrBufferPos", "hChrFactorLength", "hChrcFlLength", "hChrFSize", "hChrRulePos", "hChrcFlOffset", "hChnFilterCode", "hChrFactorCode", "hChnFactorSize", "hChrFlLength", "hChnFilterLength", "hChrFactorPos", "hChrFlOffset", "hChrFOffset", "hChrcFilterPos", "hChrFilterLength", "hChrFCode", "hChnFactorCode", "hChrcFlPos", "hChnFilterSize", "hChrRuleLength", "hChrBufferLength", "hChrFilterOffset", "hChrcFilterLength", "hChrcFlSize"], "srcFormat": ["sourceSize", "srcMT", "srcFile", "distForm", "srcUnit", " srcFunction", "rcMT", "srcOffset", "rcType", "distformat", "distFormat", "urlFormat", "srcFunction", " srcUnit", "instFormat", "srcSize", "srcPattern", "instUnit", "sourceFormat", "sourceOffset", "rcForm", " srcType", "urlMT", " srcWidth", "instPattern", "rcOffset", "rcFormat", "distType", "rcformat", "rcPattern", "sourceformat", "rcFile", " srcFile", " srcOffset", "sourceWidth", "srcForm", "sourceType", "rcSize", "sourceFunction", "urlFile", "instType", "srcWidth", "srcformat", "urlUnit", "rcWidth", "sourceUnit", "sourceForm", " srcMT", "rcFunction", "sourcePattern", "srcType", " srcSize", "rcUnit"], "formatConvBuffer": ["formatConvvFilter", "formatConfContainer", "formatConvArray", "formatEnfBuff", "formatConvvContainer", "formatConvrBuff", "formatConfFilter", "formatEnvReader", "formatConvFile", "formatConvrBuffer", "formatEnfReader", "formatConvtPtr", "formatConcFile", "formatConcBuff", "formatConvtBuffer", "formatEnvFile", "formatConveBuffer", "formatConveLine", "formatConcArray", "formatConcReader", "formatConchBuffer", "formatConVBuff", "formatConvtLine", "formatEnvArray", "formatConVFile", "formatConvvBuffer", "formatEnfFilter", "formatConventionFilter", "formatConveBuff", "formatConfLine", "formatAnvPtr", "formatConvFilter", "formatConvrArray", "formatConfFile", "formatConchBuff", "formatEnfContainer", "formatAnvBuff", "formatConvtBuff", "formatConvBuff", "formatEnfPtr", "formatConventionContainer", "formatEnvFilter", "formatConchFile", "formatEnvLine", "formatAnfPtr", "formatConvtFile", "formatConfBuffer", "formatAnfFile", "formatEnfArray", "formatConfArray", "formatConvvBuff", "formatConfReader", "formatConventionBuff", "formatEnfLine", "formatConvPtr", "formatAnvFile", "formatAnfBuffer", "formatConvLine", "formatConvrFile", "formatConcBuffer", "formatConVBuffer", "formatConvContainer", "formatConfBuff", "formatEnvContainer", "formatEnvPtr", "formatAnvBuffer", "formatEnvBuff", "formatConvReader", "formatEnfFile", "formatConventionBuffer", "formatConVPtr", "formatEnvBuffer", "formatConvePtr", "formatAnfBuff", "formatEnfBuffer", "formatConchReader", "formatConfPtr"], "pal": ["abi", "panel", "real", "vals", "local", "pl", "pixel", "alpha", "al", "pack", "ale", "cb", "p", "what", "pi", "ass", "cal", "nl", "fac", "ar", "scale", "v", "isal", "color", "el", "bin", "val", "rel", "mask", "AL", "cale", "as", "conf", "align"], "mmx2FilterPos": ["mmx2FeaturePos", "mmx1FilterBase", "mmx1FPosition", "mmx2FPosition", "mmx2FeatureBase", "mmx1FPos", "mmx1FilterPos", "mmx2FilterBase", "mmx2HeaderPos", "mmx1FBase", "mmx1FilterInfo", "mmx2FilterPosition", "mmx2FeaturePosition", "mmx1FilterPosition", "mmx2HeaderPosition", "mmx2FInfo", "mmx2FeatureInfo", "mmx2FPos", "mmx2FBase", "mmx1FInfo", "mmx2FilterInfo", "mmx2HeaderInfo", "mmx2HeaderBase"], "mmx2Filter": ["mmxTwoHeader", "mmX1Factor", "mmx42Factor", "mmx2Profile", "mmx42Filter", "mmx2Factor", "mmx1Filter", "mmX1Filter", "mmx42Header", "mmx1Profile", "mmx42Profile", "mmX1Profile", "mmx2Header", "mmX2Header", "mmxTwoFilter", "mmx1Header", "mmx1Factor", "mmX1Header", "mmX2Filter", "mmxTwoProfile", "mmX2Factor", "mmX2Profile", "mmxTwoFactor"], "mmx2FilterCode": ["mmx1FCount", "mmx2LayerNumber", "mmx2FSize", "mmx1FNumber", "mmx2filterSize", "mmx2LayerSize", "mmx1FCode", "mmx2LayerCount", "mmx1FSize", "mmx2filterCode", "mmx2FCount", "mmx2FilterNumber", "mmx1FilterSize", "mmx2filterCount", "mmx2FNumber", "mmx1FilterCode", "mmx2FilterSize", "mmx2filterNumber", "mmx1FilterNumber", "mmx2LayerCode", "mmx2FCode", "mmx1FilterCount", "mmx2FilterCount"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER(ucf64_abss)(float32 a)\n\n{\n\n    return float32_abs(a);\n\n}\n", "idx": 10316, "substitutes": {"a": ["la", "ga", "ata", "abc", "f", "at", "va", "ea", "aux", "addr", "alpha", "c", "i", "an", "ae", "aa", "au", "d", "h", "p", "offset", "b", "A", "ac", "area", "u", "ab", "as", "m", "pa", "n", "e", "value", "sa", "window", "data", "x", "ba"]}}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "int qemu_thread_equal(QemuThread *thread1, QemuThread *thread2)\n\n{\n\n   return pthread_equal(thread1->thread, thread2->thread);\n\n}\n", "idx": 10322, "substitutes": {"thread1": ["thread0", "method1", " threadone", "taskOne", "task2", "Threadb", "methodb", "process0", "Thread1", "thread3", "threadOne", "methodone", "Thread3", " threadb", "threadb", "process2", "ThreadOne", "method3", "processOne", "process1", "Thread0", "task1", "Threadone", "task0", " thread3", "Thread2", "threadone"], "thread2": ["member1", "method1", "elementtwo", "membertwo", "methodb", "processsecond", "methodtwo", "method2", "membersecond", " threadsecond", "threadtwo", " threadb", "threadb", " threadtwo", "process2", "member2", "process1", "element1", "element2", "elementb", "threadsecond", "processtwo"]}}
{"project": "qemu", "commit_id": "1b27d7a1e8609b2eeb6238f2c629eb82217523f6", "target": 0, "func": "static void ivshmem_io_writel(void *opaque, target_phys_addr_t addr,\n\n                                                            uint32_t val)\n\n{\n\n    IVShmemState *s = opaque;\n\n\n\n    uint64_t write_one = 1;\n\n    uint16_t dest = val >> 16;\n\n    uint16_t vector = val & 0xff;\n\n\n\n    addr &= 0xfc;\n\n\n\n    IVSHMEM_DPRINTF(\"writing to addr \" TARGET_FMT_plx \"\\n\", addr);\n\n    switch (addr)\n\n    {\n\n        case INTRMASK:\n\n            ivshmem_IntrMask_write(s, val);\n\n            break;\n\n\n\n        case INTRSTATUS:\n\n            ivshmem_IntrStatus_write(s, val);\n\n            break;\n\n\n\n        case DOORBELL:\n\n            /* check that dest VM ID is reasonable */\n\n            if ((dest < 0) || (dest > s->max_peer)) {\n\n                IVSHMEM_DPRINTF(\"Invalid destination VM ID (%d)\\n\", dest);\n\n                break;\n\n            }\n\n\n\n            /* check doorbell range */\n\n            if ((vector >= 0) && (vector < s->peers[dest].nb_eventfds)) {\n\n                IVSHMEM_DPRINTF(\"Writing %\" PRId64 \" to VM %d on vector %d\\n\",\n\n                                                    write_one, dest, vector);\n\n                if (write(s->peers[dest].eventfds[vector],\n\n                                                    &(write_one), 8) != 8) {\n\n                    IVSHMEM_DPRINTF(\"error writing to eventfd\\n\");\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            IVSHMEM_DPRINTF(\"Invalid VM Doorbell VM %d\\n\", dest);\n\n    }\n\n}\n", "idx": 10327, "substitutes": {"opaque": ["ipopaque", "ospaque", "ospifice", "opacity", "ipopaques", "ipopaca", "ipc", "opaca", "ospaques", "operc", "ipacity", " opc", " opacity", "ipaque", " opaca", "opaques", "ospaca", " opifice", " opaques", "operaque", "operacity", "opifice", "opc", "ipopifice"], "addr": ["hop", "pos", "prefix", "dest", "pointer", "src", "mode", "ptr", "ref", "ip", "host", "adr", "seq", "alpha", "len", "db", "route", "cmp", "node", "dr", "config", "amp", "sb", "ace", "offset", "p", "ord", "asm", "sta", "loc", "sid", "driver", "interface", "align", "mt", "part", "address", "code", "v", "prot", "layer", "r", "channel", "attr", "cmd", "mac", "point", "index", "amd", "pad", "base", "port", "ad", "data", "alias", "coord", "x"], "val": ["vol", "pos", "valid", "ctx", "vec", "pal", "vals", "elt", "ref", "buf", "fi", "serv", "sel", "len", "db", "al", "stat", "eval", "bl", "config", "p", "xxx", "slot", "arr", "loc", "b", "lit", "test", "pt", "VAL", "sl", "ival", "pre", "iv", "v", "mem", "rot", "el", "ret", "all", "index", "buffer", "arg", "base", "unit", "aval", "value", "py", "data", "x"], "s": ["g", "os", "sym", "f", "ctx", "site", "service", "state", "ls", "self", "sf", "ss", "states", "private", "c", "sq", "a", "is", "ks", "an", "d", "services", "sb", "sv", "es", "p", "ts", "S", "session", "b", "sie", "fs", "ssl", "settings", "ds", "sl", "rb", "ns", "v", "hs", "spec", "us", "r", "o", "t", "ps", "sites", "ses", "l", "qs", "sync", "gs", "w", "m", "conf", "south", "e", "n", "sys", "this", "rs", "js", "ops", "slice", "aws"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static inline void gen_outs(DisasContext *s, TCGMemOp ot)\n\n{\n\n    if (use_icount)\n\n        gen_io_start();\n\n    gen_string_movl_A0_ESI(s);\n\n    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);\n\n\n\n    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);\n\n    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n\n    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);\n\n    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n\n\n    gen_op_movl_T0_Dshift(ot);\n\n    gen_op_add_reg_T0(s->aflag, R_ESI);\n\n    if (use_icount)\n\n        gen_io_end();\n\n}\n", "idx": 10333, "substitutes": {"s": ["g", "os", "src", "its", "cs", "self", "ss", "c", "sq", "is", "a", "ks", "an", "d", "sv", "sb", "i", "es", "p", "ts", "sg", "sp", "scope", "b", "ds", "session", "ssl", "ots", "sl", "ns", "spec", "us", "t", "o", "r", "ps", "ses", "qs", "sc", "u", "gs", "w", "e", "n", "sys", "sets", "init", "set", "sk", "sa", "js", "ops"], "ot": ["et", "os", "ocr", "ott", "rt", "ox", "oi", "O", "y", "ou", "c", " os", "ant", "otes", "p", "ol", "cop", "OT", " quot", "ic", "ots", "oti", "j", "ct", "og", "pt", "mot", "bs", "ut", "pot", "oid", "gt", "op", "ac", "rot", "t", "o", "dot", "cot", "sn", "oci", "oc", "obj", "ow", "sys", "e", "set", "nt", "or", "so", "iot", "bot", "it"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "void test_fcmp(double a, double b)\n\n{\n\n    long eflags, fpus;\n\n\n\n    fpu_clear_exceptions();\n\n    asm(\"fcom %2\\n\"\n\n        \"fstsw %%ax\\n\"\n\n        : \"=a\" (fpus)\n\n        : \"t\" (a), \"u\" (b));\n\n    printf(\"fcom(%f %f)=%04lx \\n\",\n\n           a, b, fpus & (0x4500 | FPUS_EMASK));\n\n    fpu_clear_exceptions();\n\n    asm(\"fucom %2\\n\"\n\n        \"fstsw %%ax\\n\"\n\n        : \"=a\" (fpus)\n\n        : \"t\" (a), \"u\" (b));\n\n    printf(\"fucom(%f %f)=%04lx\\n\",\n\n           a, b, fpus & (0x4500 | FPUS_EMASK));\n\n    if (TEST_FCOMI) {\n\n        /* test f(u)comi instruction */\n\n        fpu_clear_exceptions();\n\n        asm(\"fcomi %3, %2\\n\"\n\n            \"fstsw %%ax\\n\"\n\n            \"pushf\\n\"\n\n            \"pop %0\\n\"\n\n            : \"=r\" (eflags), \"=a\" (fpus)\n\n            : \"t\" (a), \"u\" (b));\n\n        printf(\"fcomi(%f %f)=%04lx %02lx\\n\",\n\n               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n\n        fpu_clear_exceptions();\n\n        asm(\"fucomi %3, %2\\n\"\n\n            \"fstsw %%ax\\n\"\n\n            \"pushf\\n\"\n\n            \"pop %0\\n\"\n\n            : \"=r\" (eflags), \"=a\" (fpus)\n\n            : \"t\" (a), \"u\" (b));\n\n        printf(\"fucomi(%f %f)=%04lx %02lx\\n\",\n\n               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n\n    }\n\n    fpu_clear_exceptions();\n\n    asm volatile(\"fxam\\n\"\n\n                 \"fstsw %%ax\\n\"\n\n                 : \"=a\" (fpus)\n\n                 : \"t\" (a));\n\n    printf(\"fxam(%f)=%04lx\\n\", a, fpus & 0x4700);\n\n    fpu_clear_exceptions();\n\n}\n", "idx": 10338, "substitutes": {"a": ["la", "oa", "ga", "ata", "f", "at", "va", "api", "ea", "self", "na", "home", "alpha", "y", "ma", "c", "ak", "ca", "an", "d", "aa", "ae", "au", "ana", "p", "sta", "app", "asa", "j", "ar", "part", "A", "fa", "ia", "ac", "access", "ama", "r", "o", "da", "aw", "area", "af", "l", "am", "u", "ab", "w", "m", "as", "ast", "pa", "n", "e", "er", "ai", "s", "sa", "name", "ad", "aaa", "x", "ba"], "b": ["big", "g", "abc", "f", "bis", "k", "home", "nb", "bc", "y", "pb", "c", "i", "lb", "eb", "d", "aa", "sb", "h", "bar", "p", "ib", "cb", "bo", "mb", "fb", "bt", "j", "bh", "part", "bs", "bd", "B", "z", "v", "hub", "bi", "bb", "r", "o", "xb", "t", "abb", "bin", "l", "lib", "bad", "ab", "u", "w", "m", "emb", "e", "n", "base", "ob", "obj", "be", "wb", "bp", "ad", "bf", "bot", "ba"], "eflags": ["eflaps", "efrlushes", "efLags", "eflages", "efdlagged", "eflpars", "ffLages", "eflag", "efbags", "evlcag", "supplagg", "suppdlags", "supplagged", " deflpags", "efrlaga", "eflaga", "eflcagg", "efragging", "efrages", "eflsaps", "eflars", "efdlaps", "eflsars", "eflagging", "efdlars", "efLugs", "efLagged", "efrugs", "efrlags", "ffLagged", "eflpags", "fflugs", "efdlugs", "evlcags", "eflsaga", "efdlushes", "efklags", "suppdlasses", "efbasses", "eflcag", " deflpars", "efLages", "fflagged", "efrag", "efrlugs", "efragged", "eflagged", "evlaga", "eflsags", "efdlags", "efklagging", "eflushes", "eflcushes", "evlagging", "eflasses", "efklugs", "eflcasses", "evlcagging", "eflpaga", "evlugs", " deflpaps", "efbagged", "efbagg", "eflcaga", "eflugs", "evlag", "eflpaps", "ffLags", "suppdlagg", "fflags", " deflpaga", "eflcags", "efdlagg", "evlags", "evlcaga", "efklag", "eflcagging", "efdlaga", " deflags", " deflaps", "efrags", "eflcages", "ffLugs", "evlcugs", "supplags", " deflaga", "eflcagged", "suppdlagged", "eflcugs", "evlcushes", "eflagg", " deflars", "supplasses", "fflages", "evlushes", "efdlasses"], "fpus": ["bpusal", "sfus", "ulpus", "cpuses", "FPums", "cpio", "FPu", "vpcus", "bpu", "mpUS", "fnis", "tpuss", "mpus", "cpus", "phpaus", "tpums", "fpusal", "fpuse", "FPaus", "sfuses", "hpusal", "fpush", "gpis", "lpos", "lpUS", "gpush", "lpus", "tpu", "FPos", "phpums", "FPus", "FPuss", "tpsec", "lpis", "tpUS", "hpus", "tpuses", "ulpusal", "gpio", "vpis", "sfUS", "mpu", "mpuses", "FPUS", "fpaus", "npuses", "fnus", "fnUS", "fpio", "ulpu", "lpcus", "bpus", "fpUS", "tpush", "fpis", "FPsec", "fnu", "hpuse", "fpuss", "cpcus", "vpush", "fnush", "hpu", "fpos", "tpus", "FPush", "fpu", "tpaus", "gpu", "printfus", "ulpuse", "sfos", "fncus", "vpus", "FPis", "FPio", "vpuses", "gpuses", "npus", "printfu", "fpums", "vpu", "FPcus", "printfsec", "gpcus", "bpuse", "npUS", "FPuses", "fpcus", "phpus", "fpuses", "phpuss", "lpuses", "printfUS", "gpus", "lpu", "npu", "fpsec"]}}
{"project": "qemu", "commit_id": "b0706b716769494f321a0d2bfd9fa9893992f995", "target": 1, "func": "void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,\n\n                             hwaddr paddr, MemTxAttrs attrs, int prot,\n\n                             int mmu_idx, target_ulong size)\n\n{\n\n    CPUArchState *env = cpu->env_ptr;\n\n    MemoryRegionSection *section;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    uintptr_t addend;\n\n    CPUTLBEntry *te;\n\n    hwaddr iotlb, xlat, sz;\n\n    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;\n\n    int asidx = cpu_asidx_from_attrs(cpu, attrs);\n\n\n\n    assert_cpu_is_self(cpu);\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n\n\n    sz = size;\n\n    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);\n\n    assert(sz >= TARGET_PAGE_SIZE);\n\n\n\n    tlb_debug(\"vaddr=\" TARGET_FMT_lx \" paddr=0x\" TARGET_FMT_plx\n\n              \" prot=%x idx=%d\\n\",\n\n              vaddr, paddr, prot, mmu_idx);\n\n\n\n    address = vaddr;\n\n    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {\n\n        /* IO memory case */\n\n        address |= TLB_MMIO;\n\n        addend = 0;\n\n    } else {\n\n        /* TLB_MMIO for rom/romd handled below */\n\n        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;\n\n    }\n\n\n\n    code_address = address;\n\n    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,\n\n                                            prot, &address);\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    te = &env->tlb_table[mmu_idx][index];\n\n\n\n    /* do not discard the translation in te, evict it into a victim tlb */\n\n    env->tlb_v_table[mmu_idx][vidx] = *te;\n\n    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];\n\n\n\n    /* refill the tlb */\n\n    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;\n\n    env->iotlb[mmu_idx][index].attrs = attrs;\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((memory_region_is_ram(section->mr) && section->readonly)\n\n            || memory_region_is_romd(section->mr)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if (memory_region_is_ram(section->mr)\n\n                   && cpu_physical_memory_is_clean(\n\n                        memory_region_get_ram_addr(section->mr) + xlat)) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 10351, "substitutes": {"cpu": ["np", "linux", "hw", "capacity", "loader", "ctx", "pai", "ea", "fi", "proc", "c", "pc", "intel", "cmp", "lb", "eu", "pu", "node", "config", "cpp", "p", "CPU", "clock", "chip", "pkg", "boot", "net", "cp", "hp", "frame", "core", "cli", " CPU", "fp", "cv", "fc", "vm", "environment", "roc", "platform", "gp", "bench", "program", "gpu", "conn", "component", "uci", "sys", "cn", "process", "lc", "eni", "processor", "pid", "gru", "cache"], "vaddr": ["vendor", "cvaddr", "cvaddress", "waddr", "vvaddress", " vconfig", " vendor", "vhost", "frf", "whost", "fnode", "pconfig", " vaddress", "vpart", "vvadr", "vnode", "uptr", "uaddr", "fdr", "fadr", "pendor", "prf", "vvaddr", "uaddress", "phost", " vhost", "avendor", "hconfig", "vadr", "vpaddress", "faddress", "faddr", "vvnode", "fendor", "avaddr", "wpart", "vpnode", "cvendor", "avptr", "paddress", "vptr", "vpadr", "vconfig", "fhost", "vrf", "pptr", "waddress", "vpaddr", " vrf", "vaddress", " vdr", " vpart", "uendor", "haddr", "hhost", "vdr", "ppart", "avaddress", "cvdr", "haddress"], "paddr": [" pptr", "pnm", "wadd", "waddr", "vpad", "vad", "laddr", "qaddress", "jpaddr", "padr", " padr", "jpad", "vpaddress", "laddress", " pnm", " pad", " paddress", "jpptr", "ladd", "paddress", "wad", "jpnm", "qaddr", "vpadr", "qnm", "pad", "pptr", "waddress", "jpaddress", "vaddress", "vadd", "jpadr", " padd", "vpaddr", "padd", "qptr"], "attrs": ["attributes", "attrrs", " attributes", "addros", "attrr", "attrls", "ttrs", "ttributes", "addr", "attrros", "Attars", " attls", "ttr", " attr", "addrs", "attls", "addls", "attr", " attars", "Attr", " attros", "ttars", "attros", "Attributes", "Attrs", "attars"], "prot": [" proto", "prop", "pos", "phy", "uri", "prefix", "sil", "fen", "pool", "pointer", "src", "format", "type", "pro", "path", "crypt", " protocol", "plain", "addr", "seq", "len", "ocol", "stat", "config", "lo", "model", "reset", "chip", "rf", "lit", "io", "Prot", "ext", "pattern", "cli", "rot", "header", "channel", "platform", "ret", "conn", "dim", "rin", "col", "inet", "port", "eni", "txt", "data", "dt", "prototype"], "mmu_idx": ["mmu_Idb", "mmu_lastc", "mmu_idei", "mmu_idst", "mmu_midb", "mmu_idec", "mmu_idew", "mmu_itst", "mmu_idsx", "mmu_midx", "mmu_idsb", "all", "mmu__idX", "mmu_itx", "mmu_pidb", "mmu_Idx", "mmu_idn", "mmu_IdX", "mmu__idb", "mmu_Idst", "mmu_idz", "mmu__itx", "mmu_lastw", "mmu_lasti", "mmu_ideb", "mmu_midX", "mmu_idb", "mmu_vidc", "mmu__idz", "mmu_lastx", "mmu_vidx", "mmu_idez", "mmu2idb", "mmu_pidX", "mmu_idsz", "mmu__ideb", "mmu_idX", "mmu__iden", "mmu2idx", "mmu_itX", "mmu_idc", "mmu__idn", "mmu_idex", "r", "mmu__idez", "_", "mmu__itX", "mmu_vidi", "mmu__idst", "mmu_idw", "mmu__itst", "mmu_midw", "mmu_pidx", "pos", "g", "mmu_vidw", "mmu2idw", "mmu_idi", "mmu_pidw", "mmu__itb", "mmu_itb", "mmu__idex", "mmu__idx", "mmu_iden", "mmu2idX", "mmu_idsn"], "size": ["g", "sized", "SIZE", "capacity", "empty", "mode", "max", "eng", "engine", "external", "len", "en", "small", "esc", "bytes", "offset", "password", "si", "fee", "member", "loc", "gz", "shape", "full", "style", "core", "scale", "ize", "code", "Size", "length", "complete", "sc", "sum", "sn", "desc", "iz", "last", "unit", "security", "storage", "large", "sec", "six", "name", "zero", "cache"], "env": ["ne", "oa", "server", "fen", "np", "et", "loader", "anc", "eng", "nc", "err", "ea", "exc", "cdn", "edge", "engine", "kn", "en", "ini", "eu", "eval", "config", "ev", "enable", "enc", "kernel", "console", "Environment", "session", "net", "scope", "enh", "ass", "worker", "equ", "ext", "context", "core", "viron", "v", "ee", "environment", "el", "assets", "que", "gui", "her", "export", "conn", "org", "conf", "inet", "e", "init", "zone", "profile", " environment", "ec", "eni", "python", "energy", "exec", "cache"], "section": ["container", "server", "plugin", "version", "core", "ctx", "shadow", "abc", "site", "service", "comment", "ect", "ception", "connection", "option", "setting", "sq", "sub", "config", "esc", "function", "offset", "division", "loc", "session", "definition", "settings", "cell", "vision", "protection", "ext", "sect", "ssh", "context", "part", "sector", "array", "se", "Section", "package", "sections", "entry", "environment", "length", "area", "component", "region", "security", "port", "set", "lc", "sec", "storage", "ion"], "index": ["axis", "action", "pos", "version", "prefix", "append", "Index", "type", "pointer", "match", "weight", "update", "include", "x", " Index", " length", "len", "ion", "i", "small", "config", "ace", "offset", "input", "fee", "bridge", "loc", "shape", "ticket", "position", "sect", "key", "access", "image", "inc", "ind", "length", "error", "val", "level", "xxxx", "column", "unit", "value", "fix", " indexes", "element", "inst", "count", "align", "slice", "ix"], "address": ["message", "prefix", "block", "capacity", "type", "match", "attribute", "ip", "host", "output", "addr", "byte", "alpha", "network", "route", "node", "ace", "offset", "password", "order", "bridge", "account", "shape", "interface", "pair", "position", "enter", "contact", "end", "array", "trace", "code", "package", "image", "length", "resource", "area", "point", "answer", "ress", "reference", "alias", "region", "port", "balance", "value", "Address", "name", "grade", "element", "target", "number", "location", "align"], "code_address": ["code_index", " code2index", "code_location", " code_index", " code_location", "code__addr", " code_number", "code2addr", "code_number", " code_account", " code2address", " code_addr", "code_account", "code__location", "code__address", "code2index", "code_addr", "code2address", " code2addr", "code__account", " code2number", "code2number"], "addend": ["adden", "addset", "AddEND", "addest", "extend", " addstart", "addends", " addset", " adden", "attest", "adduse", " addended", "atten", "Addend", "callend", "callset", " addEND", "Addends", "extuse", "attend", "extset", "addEND", "addstart", "Addstart", " adduse", "calluse", "addended", "Adden", "Addended", " addends", " addest", "attends", "pushend", "pushstart", "pushEND", "Addest", "pushended"], "te": ["ne", "de", "TE", "ptr", "elt", "Te", "ue", "edge", "ke", "je", "ze", "ce", "ten", "lt", "fe", "ae", "ts", "tm", "ice", "st", "ste", "le", "let", "tw", "ite", "ie", "se", "scale", "code", "ti", "pe", "tes", "tre", "ee", "t", "ffe", "ele", "oe", "ta", "e", "ge", "be", "tta", "ve", "tile"], "iotlb": ["ietlt", "ietlb", "iollt", "otlr", "iotlr", "ietlab", "iotlt", "iotlas", "iollab", "etlr", "ietl", "otlb", "ietlas", "etlas", "ioll", "ietlr", "iotl", "iollb", "iotlab", "otlas", "otlt", "otlab", "etlb", "otl", "etl"], "xlat": ["wxlit", "ixhi", "xcat", "ixcat", "ixlat", " xsat", "xxlit", " xdat", " xlit", "Xdat", "xxlag", "xla", "xdat", "xLat", " xla", "ixflat", "ixla", "xlit", "xxsat", "xxlat", "yla", "ycat", " xhi", "xxdat", "wxsat", "xxcat", "ylat", "xxLat", " xflat", "xxflat", " xcat", " xlag", "xhi", "wxlat", "xlag", "Xlat", "yhi", "XLat", "xsat", "ixlag", " xLat", "xflat"], "sz": ["szi", "sesze", "wsZ", "psz", "szl", "Szi", "Sz", "szn", "tsze", "tszn", "psZ", "sze", "seszen", " sZ", "pszen", "seszi", " szl", "tszi", "blockszi", "blockszl", "tsz", "wszi", " szen", "sZ", "wsz", "sesz", "lsz", "lszn", "Sze", "pszn", "Szl", "pszi", "blocksz", "wsze", "psze", "lsze", "blocksze", "lszi", " szi", "szen", " sze"], "vtlb_index": ["vtrl_address", "vtlb_address", "vtrl_index", "vtlb_ind", "vtrl_position", "vtrl_ind", "vtlb_position"]}}
{"project": "qemu", "commit_id": "3a661f1eabf7e8db66e28489884d9b54aacb94ea", "target": 1, "func": "static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,\n\n                                       const uint8_t *key, size_t nkey,\n\n                                       Error **errp)\n\n{\n\n    QCryptoCipherBuiltin *ctxt;\n\n\n\n    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {\n\n        error_setg(errp, \"Unsupported cipher mode %d\", cipher->mode);\n\n        return -1;\n\n    }\n\n\n\n    ctxt = g_new0(QCryptoCipherBuiltin, 1);\n\n\n\n    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);\n\n    memcpy(ctxt->state.desrfb.key, key, nkey);\n\n    ctxt->state.desrfb.nkey = nkey;\n\n\n\n\n    ctxt->free = qcrypto_cipher_free_des_rfb;\n\n    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;\n\n    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;\n\n    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;\n\n\n\n    cipher->opaque = ctxt;\n\n\n\n    return 0;\n\n}", "idx": 10355, "substitutes": {"cipher": ["Crypt", "acairo", "acortex", "crypt", " crypt", "scursor", "encoder", "Cipher", " cryption", "encursor", "scoder", "encortex", "cursor", "encipher", "scipher", "Coder", "scairo", "cortex", "encryption", "scrypt", "chipher", "acursor", "cryption", "encrypt", "acoder", "acipher", "chrypt", " cortex", "cairo", "chursor", "coder", "chairo", "scortex", "scryption", "Cursor", "encairo", "acrypt", "Cairo"], "key": ["server", "message", "phrase", "version", "block", "pub", "size", "type", "ey", "id", "text", "k", "weight", "ip", "state", "connection", "x", "min", "sign", "transfer", "close", "write", "temp", "KEY", "change", "fee", "order", "seed", "net", "Key", "secret", "pair", "open", "rule", "iv", "code", "ee", "row", "client", "copy", "length", "source", "index", "lock", "base", "init", "value", "name", "cert", "hash", "data", "read"], "nkey": ["nsec", "networkbase", "networkip", "nvalue", "norder", "nce", "Nsec", "nmKey", "dce", "dnorder", " nKey", "llarge", " nsecret", "dnkeys", "pblock", "lnkeys", "nip", "Nkey", "dKey", "dblock", "nmkey", "pkey", "pce", "Nblock", " nsec", "snkey", "NKey", "networkorder", "nmsec", "nblock", "porder", "lkey", "networkkey", "dnbase", " nkeys", "lvalue", "dnsecret", "nkeys", "nlarge", "snvalue", "lnblock", " nblock", "nsecret", "lnkey", "dnip", "nbase", " nce", " nvalue", "dkey", "snlarge", "dnblock", "nKey", "pbase", "lnsecret", "pip", "dnkey", " nlarge", "pKey", "nmblock"], "errp": ["derfp", "errap", " errcp", "erfp", " errvp", "errfp", "errf", "erap", "armcp", "derp", " errap", " errbp", "errcp", "ervp", "errorbp", "armbp", "armp", " errf", "errorp", "armf", "erp", "dervp", "errorf", " errfp", "derap", "errorcp", "errbp", "errvp"], "ctxt": ["ectext", "ctkt", "ectert", "ctert", "ctext", "ptext", "nttxt", "cxt", "ecttxt", "cXT", "ectkt", "CText", "actxt", "actkt", "cirt", "acttxt", "actirt", "ntert", "CTtxt", "ptert", "ectfi", "ntxt", "CTirt", "pttxt", "qtxt", "ctirt", "ctXT", "ctlect", "ntext", "CTlect", "ctfi", "qtkt", "qtXT", "octext", "CTrust", "antlect", "ectrt", "actrust", "actext", "octxt", "ctrust", "antxt", "cttxt", "ectlect", "ptkt", "ptrust", "CTrt", "CTxt", "ptfi", "ctrt", "antrt", "ectxt", "CTfi", "octert", "cext", "ptxt", "qtext", "antext", "octtxt", "CTXT", "actXT", "CTkt", "CTert"]}}
{"project": "qemu", "commit_id": "f57ba05823b7c444133f0862077b45824a6a89b5", "target": 0, "func": "static int virtio_ccw_handle_set_vq(SubchDev *sch, CCW1 ccw, bool check_len,\n\n                                    bool is_legacy)\n\n{\n\n    int ret;\n\n    VqInfoBlock info;\n\n    VqInfoBlockLegacy linfo;\n\n    size_t info_len = is_legacy ? sizeof(linfo) : sizeof(info);\n\n\n\n    if (check_len) {\n\n        if (ccw.count != info_len) {\n\n            return -EINVAL;\n\n        }\n\n    } else if (ccw.count < info_len) {\n\n        /* Can't execute command. */\n\n        return -EINVAL;\n\n    }\n\n    if (!ccw.cda) {\n\n        return -EFAULT;\n\n    }\n\n    if (is_legacy) {\n\n        linfo.queue = address_space_ldq_be(&address_space_memory, ccw.cda,\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        linfo.align = address_space_ldl_be(&address_space_memory,\n\n                                           ccw.cda + sizeof(linfo.queue),\n\n                                           MEMTXATTRS_UNSPECIFIED,\n\n                                           NULL);\n\n        linfo.index = address_space_lduw_be(&address_space_memory,\n\n                                            ccw.cda + sizeof(linfo.queue)\n\n                                            + sizeof(linfo.align),\n\n                                            MEMTXATTRS_UNSPECIFIED,\n\n                                            NULL);\n\n        linfo.num = address_space_lduw_be(&address_space_memory,\n\n                                          ccw.cda + sizeof(linfo.queue)\n\n                                          + sizeof(linfo.align)\n\n                                          + sizeof(linfo.index),\n\n                                          MEMTXATTRS_UNSPECIFIED,\n\n                                          NULL);\n\n        ret = virtio_ccw_set_vqs(sch, NULL, &linfo);\n\n    } else {\n\n        info.desc = address_space_ldq_be(&address_space_memory, ccw.cda,\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.index = address_space_lduw_be(&address_space_memory,\n\n                                           ccw.cda + sizeof(info.desc)\n\n                                           + sizeof(info.res0),\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.num = address_space_lduw_be(&address_space_memory,\n\n                                         ccw.cda + sizeof(info.desc)\n\n                                         + sizeof(info.res0)\n\n                                         + sizeof(info.index),\n\n                                         MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.avail = address_space_ldq_be(&address_space_memory,\n\n                                          ccw.cda + sizeof(info.desc)\n\n                                          + sizeof(info.res0)\n\n                                          + sizeof(info.index)\n\n                                          + sizeof(info.num),\n\n                                          MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.used = address_space_ldq_be(&address_space_memory,\n\n                                         ccw.cda + sizeof(info.desc)\n\n                                         + sizeof(info.res0)\n\n                                         + sizeof(info.index)\n\n                                         + sizeof(info.num)\n\n                                         + sizeof(info.avail),\n\n                                         MEMTXATTRS_UNSPECIFIED, NULL);\n\n        ret = virtio_ccw_set_vqs(sch, &info, NULL);\n\n    }\n\n    sch->curr_status.scsw.count = 0;\n\n    return ret;\n\n}\n", "idx": 10364, "substitutes": {"sch": ["ocr", "sd", "src", "sw", "cs", "sche", "chn", "Sch", "chi", "wic", "squ", "cht", "ech", "sr", "usb", "sb", "inch", "sac", "chip", "sh", "gh", "sp", "ssl", "chy", "ssh", "soc", "sl", "spec", "ich", "ch", "igh", "channel", "ses", "sc", "sky", "chid", "conf", "CH", "shop", "sk", "kh", "isc"], "ccw": ["ccow", " ccl", "ncW", "ghwall", "ccW", " ccW", "ecw", "rcl", "accW", "cchw", "acws", "ghw", "cfwa", "acwe", "rcwa", "cwd", "cw", "CChw", "accow", "llwa", "CCn", "CCow", "uccws", "cfow", "ccwd", "cfW", "ccwe", "ccf", "ncwe", " ccwa", "cff", " cchw", "CCwa", "ecy", " ccwd", "CCws", "ccwal", "ccws", "uccwork", "accw", "lll", "rcws", " ccws", "ccn", "ccy", "cwal", "ucwa", "ucfw", "rcW", " ccwan", " ccwal", "ccfw", "ccwork", "llw", "acw", "uccwall", "accfw", "CCf", "accf", "ucws", "ccwall", "ucW", "ghwork", "acW", "ccl", "ghws", "ncw", "ecwal", "CCwe", "llwan", "ecwd", "uccw", "ucwork", "cy", "ucw", "rcw", "cfn", "ccwan", "CCfw", " ccn", "cfw", "uchw", "CCW", "ucwall", "ncws", "cfws", "accwa", " ccy", "ccwa", "CCw", "rcwan"], "check_len": ["checkercount", "check32len", "checkablelen", "blockingcount", "check64length", " check_count", "checkerlength", "checkablecount", "check_num", "checkingnum", "check32length", "check32count", "checkingcount", "blockingnum", "check64len", " checkerlength", "check_count", " checkercount", "block_len", " checkerlen", "check64num", "checkinglength", "blockinglen", "block_num", "block_count", "checkerlen", "check64count", "checkinglen", "checkablelength", " check_length", "check_length", "blockinglength", "block_length"], "is_legacy": ["is_Legastic", "is_levACY", "is_legastic", "is_regACY", "is_regace", "is_lowACY", "is_levacy", "is_legimental", "is_lowimental", "is_levimental", "is_regimental", "is_legace", "is_lowacy", "is_Legace", "is_regazy", "is_regastic", "is_Legantic", "is_regacy", "is_ledastic", "is_ledace", "is_Legacy", "is_legazy", "is_legantic", "is_lowace", "is_ledacy", "is_levace", "is_regantic", "is_Legazy", "is_ledazy", "is_levantic", "is_legACY"], "ret": ["valid", "rets", "match", "att", "resp", "re", "RET", "ref", "eth", "aux", "rev", "result", "success", " Ret", " RET", "rc", "cat", "arr", "fun", "lit", "bit", "mt", "red", "ut", "opt", "val", "det", "get", "def", "arg", "reply", "res", "nt", "reg", "fin", "alt", "Ret", "gc", "data", "hash"], "info": ["iso", "thin", "comment", "service", "zip", "success", "i", "orig", "json", "ui", "buff", "job", "init", "fw", "txt", "extra", "alias", "ii", "id", "api", "update", "ignore", "result", "off", "http", "archive", "frame", "end", "hi", "op", "error", "base", "information", "block", "f", "diff", "now", "inf", "afi", "config", "app", "part", "di", "fo", "index", "start", "util", "name", "py", "bug", "where", "type", "hand", "fi", "wx", "Info", "help", "cb", "offset", "si", "loc", "work", "inner", "ext", "INFO", "image", "opt", "def", "conf", "obj", "about", "data", "check", "cache"], "linfo": [" Linf", "lanco", "ilfo", "lango", "lenfo", "lineph", "elinzo", " lingo", "lufo", "lenzo", "laneno", "linema", "linfi", "synzo", "synfo", " linzo", " linjo", "vinph", "luzo", "linzo", "Linjo", "synso", "linefo", "lince", "synbo", "vinbo", " linbo", " Linjo", "ilph", "lanato", "Linbo", "elinf", " lineno", " linf", "linf", " linco", "lancf", "linego", "elinfo", "linso", "lnfi", " lintto", " Linbo", "lanbo", "alinfo", "vinzo", "lenf", "Linf", "lanph", "synco", "linef", "alingo", "linece", "lnjo", "lnbo", "lenbo", "lincf", "lnph", "elinco", " linma", "alinbo", "Lintto", "linetto", "ilzo", "Linph", "lintto", "lnco", "linco", "vinco", "linato", " linso", "syneno", "lanf", "Lingo", "lanfi", "alincf", "lnzo", "synato", "lenco", "luso", "lineno", "linbo", "lnf", "Lincf", "linma", "elinjo", "lneno", "ilbo", "lenph", "elinfi", "vinjo", "lingo", "Linma", " Linfo", "linjo", "leneno", "ilco", "vinfo", "ilf", "lubo", "elinbo", "synce", "lanfo", " linato", "lanzo", "synf", "synph", "Linfo", "lnfo", "vinf", "linph", "lance"]}}
{"project": "qemu", "commit_id": "ddf21908961073199f3d186204da4810f2ea150b", "target": 0, "func": "static void vnc_client_cache_addr(VncState *client)\n\n{\n\n    Error *err = NULL;\n\n\n\n    client->info = g_malloc0(sizeof(*client->info));\n\n    client->info->base = g_malloc0(sizeof(*client->info->base));\n\n    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,\n\n                                         &err);\n\n    if (err) {\n\n        qapi_free_VncClientInfo(client->info);\n\n        client->info = NULL;\n\n        error_free(err);\n\n    }\n\n}\n", "idx": 10370, "substitutes": {"client": ["server", "service", "comment", "host", "connection", "c", "pc", "i", "cm", "con", "open", "address", "resource", "win", "ci", "child", "secure", "build", "plugin", "api", "update", "user", "close", "public", "Client", "cat", "ace", "http", "session", "connect", "use", "end", "code", "parent", "get", "call", "conn", "cod", "port", "manager", "prefix", "clean", "callback", "gu", "config", "content", "app", "cell", "sim", "command", "start", "current", "my", "util", "name", "container", "remote", "request", "local", "private", "ce", "game", "co", "help", "new", "project", "core", "cli", "friend", "gui", "common", "custom", "contract", "data", "cache"], "err": ["Error", "aster", "fy", "fr", "resp", "fi", "orer", "result", "mr", "found", "ver", "Er", "i", "finder", "sr", "dr", "lr", "cb", "ace", "fee", "arr", "der", "order", "runner", "erer", "ler", "cor", "ar", "cfg", "here", "ind", "r", "ise", "error", "kr", "rx", "req", "acer", "conn", "ir", "dev", "cer", "cr", "gr", "conf", "e", "n", "er", "msg", "sys", "rs", "rr", "rh", "var", "rar", "res", "bug", "rage", "str"]}}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)\n\n{\n\n    return kvm_irqchip_assign_irqfd(s, fd, virq, true);\n\n}\n", "idx": 10374, "substitutes": {"s": ["sym", "f", "k", "state", "self", "sf", "side", "states", "ss", "c", "a", "i", "services", "d", "sb", "es", "p", "ds", "ips", "scope", "fs", "ssl", "session", "b", "secondary", "ssh", "spec", "o", "t", "ses", "u", "w", "m", "south", "e", "sys", "sets", "status", "js", "ops"], "fd": ["fn", "sd", "xf", "f", "id", "diff", "flow", " fid", "sf", "xd", "md", "d", "pd", "rd", "nil", "fee", "ds", " f", "fb", "FD", "fl", "nd", "ld", "bd", "fa", "fc", "fp", "dc", "dd", "dn", "ind", "df", "std", " FD", "handler", "cf", "fx", "ecd", "fin", "dl", "lf", "cd", "dir", "pid"], "virq": ["riverke", "irance", "virtq", "varik", "variq", "virtce", "virtance", "irq", "riverq", "virtQ", "irQ", " virance", " virQ", "irce", " virke", "virce", "virance", "virk", "virke", "varike", "riverQ", " virk", "variQ", " virce", "riverk", "virQ"]}}
{"project": "qemu", "commit_id": "cdbf6e165988ab9d7c01da03b9e27bb8ac0c76aa", "target": 0, "func": "static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    NetCharDriver *s = chr->opaque;\n\n    gsize bytes_read = 0;\n\n    GIOStatus status;\n\n\n\n    if (s->max_size == 0)\n\n        return FALSE;\n\n    status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf),\n\n                                     &bytes_read, NULL);\n\n    s->bufcnt = bytes_read;\n\n    s->bufptr = s->bufcnt;\n\n    if (status != G_IO_STATUS_NORMAL) {\n\n        return FALSE;\n\n    }\n\n\n\n    s->bufptr = 0;\n\n    while (s->max_size > 0 && s->bufptr < s->bufcnt) {\n\n        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);\n\n        s->bufptr++;\n\n        s->max_size = qemu_chr_be_can_write(chr);\n\n    }\n\n\n\n    return TRUE;\n\n}\n", "idx": 10385, "substitutes": {"chan": ["cas", "Channel", "ann", "block", "ctx", "path", "buf", "cow", "proc", "home", "serv", "bc", "can", "c", "conv", "ca", "close", "an", "rc", "cat", "scan", "cur", "sac", "cp", "con", "gen", "cor", "ch", "alloc", "channel", "opt", "Chan", "cmd", "conn", "dev", "rec", "cot", "circ", "sys", "cn", "cap", "cho", "comb"], "cond": [" code", " pos", " whence", "proc", "comp", " error", " co", " parent", " comp", "bc", "c", " cas", " flag", "d", " condition", "condition", " latch", " cis", "code", "ac", "parent", "cl", " interrupt", " conditional", " err", " signal", "Cond", " exec"], "opaque": ["operacs", "iopace", " opacs", "opsacity", "opacs", "obaque", "opacity", "opsaque", "obesc", " opec", "ipesc", "ipacity", "opane", "obacity", "OPaques", "obace", "OPacity", "obec", " opacity", "ipaque", "OPacs", "iopaque", "obane", "opaques", "OPaque", "opesc", "operaques", "operaque", " opaques", "operacity", "iopacity", "opsesc", " opace", "opace", "opec", "opsane", "ipane", "iopec"], "chr": ["Chrl", "Chrs", "achre", "CHrb", " chre", "ichlr", "ichrr", " chcr", " chm", "CHrs", " chdr", " chnr", "cherre", "shre", "chrs", "CHro", "shnr", "cherrr", "chrr", "ichre", "shdr", " chrl", " chrb", "chcr", "chlr", "ichr", "CHm", "achr", "Chcr", "chm", " chrs", " chlr", "cherr", "shr", "chre", "Chr", "CHrl", "Chrb", "chro", "Chro", "cherlr", " chrr", "achdr", "chrb", "Chm", "achnr", " chro", "chrl", "chnr", "CHcr", "CHr", "chdr"], "s": ["server", "sym", "service", "cs", "self", "c", "a", "i", "ks", "d", "settings", "b", "gs", "w", "as", "e", "comments", "rs", "js", "os", "site", "its", "ls", "ss", "sq", "ins", "sb", "rows", "h", "http", "S", "ds", "session", "fs", "ssl", "ms", "o", "ses", "qs", "f", "parts", "sf", "xs", "services", "sg", "secondary", "sl", "r", "ps", "l", "u", "sync", "sys", "su", "g", "args", "uns", "is", "new", "es", "p", "ts", "si", "results", "full", "se", "ns", "spec", "us", "t", "your", "m", "conf", "n", "sets", "sa", "ops", "aws"], "status": ["flags", "server", "g", "ess", "wait", "f", "id", "comment", "sw", "err", "state", "update", "xml", "class", "ss", "plus", "result", "success", "stat", "uses", "ex", "i", "score", "str", "response", "temp", "stage", "si", "sp", "step", "settings", "session", "ssl", "style", "flag", "sl", "pre", "magic", "code", "spec", "parent", "active", "complete", "error", "source", "sync", "wrapper", "STAT", "e", "this", "msg", "progress", "security", " Status", "name", "stats", "Status", "cache"], "bufptr": ["bufctr", "buffaddr", "ufdr", "ufptr", "bufaddr", "ufctr", "bufPtr", "bufferctr", " bufPtr", "bufferpointer", " bufpointer", "buffPtr", "cbptr", "cbpointer", " bufaddr", "buffptr", "ufPtr", "ufaddr", "bufferPtr", "cbaddr", "ufpointer", "bufpointer", "bufferptr", "buffdr", " bufdr", "buffpointer", "buffctr", "cbdr", "bufdr"]}}
{"project": "qemu", "commit_id": "a01d8cadadf4c0dad8fc5157ee56aea8ec323982", "target": 1, "func": "PCIBus *pci_prep_init(qemu_irq *pic)\n\n{\n\n    PREPPCIState *s;\n\n    PCIDevice *d;\n\n    int PPC_io_memory;\n\n\n\n    s = qemu_mallocz(sizeof(PREPPCIState));\n\n    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);\n\n\n\n    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);\n\n    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);\n\n\n\n    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);\n\n    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);\n\n    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);\n\n    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);\n\n    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);\n\n    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);\n\n\n\n    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read,\n\n                                           PPC_PCIIO_write, s);\n\n    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);\n\n\n\n    /* PCI host bridge */\n\n    d = pci_register_device(s->bus, \"PREP Host Bridge - Motorola Raven\",\n\n                            sizeof(PCIDevice), 0, NULL, NULL);\n\n    d->config[0x00] = 0x57; // vendor_id : Motorola\n\n    d->config[0x01] = 0x10;\n\n    d->config[0x02] = 0x01; // device_id : Raven\n\n    d->config[0x03] = 0x48;\n\n    d->config[0x08] = 0x00; // revision\n\n    d->config[0x0A] = 0x00; // class_sub = pci host\n\n    d->config[0x0B] = 0x06; // class_base = PCI_bridge\n\n    d->config[0x0C] = 0x08; // cache_line_size\n\n    d->config[0x0D] = 0x10; // latency_timer\n\n    d->config[0x0E] = 0x00; // header_type\n\n    d->config[0x34] = 0x00; // capabilities_pointer\n\n\n\n    return s->bus;\n\n}\n", "idx": 10406, "substitutes": {"pic": ["ics", "file", "vec", "nic", "anc", "fi", "lic", "bc", "cci", "c", "pc", "i", "jp", "config", "p", "ic", "pict", "Pic", "soc", "cli", "pot", "fc", "ac", "xi", "fp", "pin", "sc", "lib", "pins", "cus", "oc", "lc", "mc", "ec", "ig", "pid", "jc"], "s": ["server", "sym", "service", "cs", "self", "c", "a", "i", "sv", "lines", "settings", "b", "sites", "gs", "w", "e", "rs", "js", "status", "os", "sd", "groups", "site", "ls", "ss", "sq", "sb", "S", "session", "ds", "fs", "ssl", "j", "z", "o", "ses", "qs", "f", "sf", "y", "services", "socket", "secondary", "sl", "v", "r", "ps", "l", "u", "sync", "south", "sys", "su", "null", "features", "g", "request", "state", "states", "is", "new", "es", "ts", "p", "si", "ns", "less", "spec", "t", "your", "m", "n", "storage", "sa"], "d": ["g", "dat", "de", "dict", "sd", "f", "id", "device", "did", "diff", "k", "D", "dom", "md", "c", "db", "i", "pd", "config", "dr", "p", "dy", "dos", "ds", "b", "session", "and", "j", "ct", "nd", "ld", "di", "z", "dc", "dd", "dn", "t", "o", "da", "l", "q", "dim", "ded", "sync", "w", "m", "dh", "dm", "e", "n", "dl", "ad", "data", "dt", "cd"], "PPC_io_memory": ["PPC_IO_mem", "PPC_io_buffer", "PPC_io_address", "PPC_iogmemory", "PPC_ioambuffer", "PPC_auto_buffer", "PPC_io_mem", "PPC_iogmem", "PPC_IO_memory", "PPC_io_device", "PPC_auto_mem", "PPC_auto_memory", "PPC_ioamdevice", "PPC_iogaddress", "PPC_ioammemory", "PPC_IO_address", "PPC_ioammem", "PPC_auto_device", "PPC_io_Memory", "PPC_iogMemory", "PPC_IO_Memory"]}}
{"project": "FFmpeg", "commit_id": "6d24231e504f71a76a8fabe87c8d7cfa826da75a", "target": 0, "func": "static int raw_init_encoder(AVCodecContext *avctx)\n\n{\n\n    avctx->coded_frame = (AVFrame *)avctx->priv_data;\n\n    avctx->coded_frame->pict_type = FF_I_TYPE;\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->codec_tag = findFourCC(avctx->pix_fmt);\n\n    return 0;\n\n}\n", "idx": 10410, "substitutes": {"avctx": ["afca", "avcmp", "avconfig", "avcontext", "avalcf", "AVctx", "avectx", "afconfig", "akcontext", "avcf", "ajctrl", "avecf", "avalctx", "ajcontext", "AVlc", "afobj", "AVca", "appcu", "avecp", "avecu", "aucontext", "avlc", "aucu", "afcp", "avcu", "afcf", "AVcmp", "avca", "ajctx", "avalcontext", "aveqa", "ajconfig", "appcontext", "avalobj", "aveobj", "aflc", "aveconfig", "avdc", "ajdc", "afqa", "avqa", "auctx", "avecontext", "appctx", "afcu", "avobj", "akctx", "AVcontext", "avectrl", "avelc", "avedc", "avctrl", "akcmp", "aucp", "afdc", "afctx", "akca", "afctrl", "AVqa", "ajcf", "afcmp", "afcontext", "avcp", "appqa"]}}
{"project": "FFmpeg", "commit_id": "14f3f3a1ad9aca7599bdaa399cdb8680c52dc696", "target": 1, "func": "static int decode_sequence_header_adv(VC1Context *v, GetBitContext *gb)\n\n{\n\n    v->res_rtm_flag = 1;\n\n    v->level = get_bits(gb, 3);\n\n    if(v->level >= 5)\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Reserved LEVEL %i\\n\",v->level);\n\n    }\n\n    v->chromaformat = get_bits(gb, 2);\n\n    if (v->chromaformat != 1)\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_ERROR,\n\n               \"Only 4:2:0 chroma format supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    // (fps-2)/4 (->30)\n\n    v->frmrtq_postproc = get_bits(gb, 3); //common\n\n    // (bitrate-32kbps)/64kbps\n\n    v->bitrtq_postproc = get_bits(gb, 5); //common\n\n    v->postprocflag = get_bits(gb, 1); //common\n\n\n\n    v->s.avctx->coded_width = (get_bits(gb, 12) + 1) << 1;\n\n    v->s.avctx->coded_height = (get_bits(gb, 12) + 1) << 1;\n\n    v->broadcast = get_bits1(gb);\n\n    v->interlace = get_bits1(gb);\n\n    if(v->interlace){\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Interlaced mode not supported (yet)\\n\");\n\n        return -1;\n\n    }\n\n    v->tfcntrflag = get_bits1(gb);\n\n    v->finterpflag = get_bits1(gb);\n\n    get_bits1(gb); // reserved\n\n    v->psf = get_bits1(gb);\n\n    if(v->psf) { //PsF, 6.1.13\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Progressive Segmented Frame mode: not supported (yet)\\n\");\n\n        return -1;\n\n    }\n\n    if(get_bits1(gb)) { //Display Info - decoding is not affected by it\n\n        int w, h, ar = 0;\n\n        av_log(v->s.avctx, AV_LOG_INFO, \"Display extended info:\\n\");\n\n        w = get_bits(gb, 14);\n\n        h = get_bits(gb, 14);\n\n        av_log(v->s.avctx, AV_LOG_INFO, \"Display dimensions: %ix%i\\n\", w, h);\n\n        //TODO: store aspect ratio in AVCodecContext\n\n        if(get_bits1(gb))\n\n            ar = get_bits(gb, 4);\n\n        if(ar == 15) {\n\n            w = get_bits(gb, 8);\n\n            h = get_bits(gb, 8);\n\n        }\n\n\n\n        if(get_bits1(gb)){ //framerate stuff\n\n            if(get_bits1(gb)) {\n\n                get_bits(gb, 16);\n\n            } else {\n\n                get_bits(gb, 8);\n\n                get_bits(gb, 4);\n\n            }\n\n        }\n\n\n\n        if(get_bits1(gb)){\n\n            v->color_prim = get_bits(gb, 8);\n\n            v->transfer_char = get_bits(gb, 8);\n\n            v->matrix_coef = get_bits(gb, 8);\n\n        }\n\n    }\n\n\n\n    v->hrd_param_flag = get_bits1(gb);\n\n    if(v->hrd_param_flag) {\n\n        int i;\n\n        v->hrd_num_leaky_buckets = get_bits(gb, 5);\n\n        get_bits(gb, 4); //bitrate exponent\n\n        get_bits(gb, 4); //buffer size exponent\n\n        for(i = 0; i < v->hrd_num_leaky_buckets; i++) {\n\n            get_bits(gb, 16); //hrd_rate[n]\n\n            get_bits(gb, 16); //hrd_buffer[n]\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 10414, "substitutes": {"v": ["ii", "g", "vol", "version", "hw", "f", "va", "k", "vt", "api", "ov", "rev", "vc", "c", "ver", "conv", "sv", "d", "vim", "ev", "p", "temp", "vg", "b", "j", "vr", "vd", "uv", "av", "iv", "cv", "lv", "vm", "ch", "t", "o", "nv", "val", "inv", "l", "V", "q", "u", "vp", "dev", "qv", "m", "e", "n", "vic", "tv", "value", "s", "var", "vv", "video", "vi", "ve", "vs", "x"], "gb": ["binary", "g", "ga", "phy", "Gb", "bm", "gnu", "gam", "GB", "gram", "gm", "ged", "rg", "bc", "gg", "gu", "gom", "db", "gd", "game", "lb", "eb", "usb", "gold", "sb", "yg", "cgi", "gow", "kb", "sg", "gl", "gh", "gy", "mb", "b", "gz", "bg", "boot", "range", "gio", "kw", "gi", "rb", "ko", "cli", "go", "fc", "hub", "gal", "bb", "ui", "du", "gp", "gui", "gin", "lib", "gem", "buff", "git", "gs", "cod", "ge", "storage", "lc", "google", "gc", "bf", "gru"], "w": ["g", "wal", "wd", "wan", "we", "f", "max", "weight", "sw", "k", "wx", "y", "c", "wo", "a", "d", "wn", "p", "b", "work", "kw", "wl", "z", "ww", "t", "r", "aw", "wp", "win", "l", "q", "ew", "u", "wt", "wa", "wh", "ow", "m", "n", "fw", "wb", "s", "wig", "W", "x"], "h": ["g", "ph", "hd", "H", "f", "hr", "k", "th", "oh", "y", "c", "en", "d", "kh", "p", "ha", "uh", "sh", "gh", "b", "ah", "hh", "ht", "end", "z", "hi", "hs", "r", "t", "o", "l", "q", "u", "he", "hl", "m", "e", "n", "rh", "x", "hm"]}}
{"project": "qemu", "commit_id": "d02532f08e207419e412ea7cd4eb8b36f04f426d", "target": 1, "func": "int page_unprotect(target_ulong address, uintptr_t pc, void *puc)\n\n{\n\n    unsigned int prot;\n\n    PageDesc *p;\n\n    target_ulong host_start, host_end, addr;\n\n\n\n    /* Technically this isn't safe inside a signal handler.  However we\n\n       know this only ever happens in a synchronous SEGV handler, so in\n\n       practice it seems to be ok.  */\n\n    mmap_lock();\n\n\n\n    p = page_find(address >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        mmap_unlock();\n\n        return 0;\n\n    }\n\n\n\n    /* if the page was really writable, then we change its\n\n       protection back to writable */\n\n    if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) {\n\n        host_start = address & qemu_host_page_mask;\n\n        host_end = host_start + qemu_host_page_size;\n\n\n\n        prot = 0;\n\n        for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) {\n\n            p = page_find(addr >> TARGET_PAGE_BITS);\n\n            p->flags |= PAGE_WRITE;\n\n            prot |= p->flags;\n\n\n\n            /* and since the content will be modified, we must invalidate\n\n               the corresponding translated code. */\n\n            tb_invalidate_phys_page(addr, pc, puc);\n\n#ifdef DEBUG_TB_CHECK\n\n            tb_invalidate_check(addr);\n\n#endif\n\n        }\n\n        mprotect((void *)g2h(host_start), qemu_host_page_size,\n\n                 prot & PAGE_BITS);\n\n\n\n        mmap_unlock();\n\n        return 1;\n\n    }\n\n    mmap_unlock();\n\n    return 0;\n\n}\n", "idx": 10416, "substitutes": {"address": ["server", "padding", "uri", "prefix", "pointer", "type", "localhost", "ip", "host", "adr", "network", "route", "en", "node", "config", "ace", "offset", "order", "socket", "shape", "pair", "position", "end", "enter", "array", "memory", "add", "code", "image", "dc", "length", "resource", "point", "start", "index", "pad", "component", "reference", "alias", "port", "set", "holder", "Address", "name", "data", "target", "number", "location", "object"], "pc": ["pos", "pg", "pointer", "type", "pn", "pm", "xc", "ota", "ptr", "nc", "ref", "pl", "lic", "bc", "pb", "c", "ocol", "amp", "rc", "arc", "con", "PC", "pt", "gb", "cpu", "po", "cc", "fc", "code", "dc", "ac", "client", "inc", "point", "port", "tc", "mc", "lc", "uc", "py", "ping", "pid"], "puc": ["tbc", " pbc", "Pbc", "pcc", " pcc", "ppucc", " pream", "lpuc", "Pcc", "pream", "ppcc", " pUC", "tUC", "tuc", "tcc", "pbc", "lpcc", "lpucc", "lpream", "pucc", "Puc", "PUC", "ppuc", " pucc", "ppream", "pUC"], "prot": [" proto", "padding", "prop", "gap", "prefix", "server", "pg", "utf", "size", " Proto", "pointer", "pool", "att", "sil", "pro", " clen", "ptr", "ref", "eth", " protocol", " Protocol", "bc", "seq", "ocol", "len", " PROT", " Prot", "stat", "en", "lo", "offset", "reset", "primary", "lead", "fl", "Prot", "io", "ext", "pt", "pre", "cli", "code", "fp", "nat", "rot", "dat", "rect", "header", "platform", "opt", "ret", "rep", "flags", "rog", " pref", "col", "inet", "port", "bits", " len", "pos", "status", "txt", "typ", " protocols"], "p": ["np", "tp", "pg", "f", "dp", "api", "proc", "pb", "c", "i", "jp", "d", "patch", "lp", "pr", "per", "ep", "sp", "pkg", "b", "pi", "cp", "j", "hp", "part", "P", "pre", "po", "fp", "pe", "op", "parent", "v", "t", "o", "ps", "wp", "gp", "l", "point", "pp", "ap", "vp", "u", "w", "m", "e", "n", "pa", "progress", "s", "bp", "page", "py", "post"], "host_start": ["server_starting", "server_end", "host_stop", "server_se", "hostlexstart", "hostlexend", "node_end", "host_starting", "server_pos", "node_id", "server_start", "host_pad", "server_stop", "host_set", "server_set", " host_id", "host_size", "node_pad", "host_pos", "host_se", "host_id", "hostlexstarting", " host_size", "hostlexpos", "node_start"], "host_end": ["server_end", "hostsmax", "server_ended", "host_END", "server_line", "host_ends", "host_max", "server_END", " host_send", "host_ended", "server_start", "server_max", "host_line", "hostlexstart", "hostsstart", "hostlexend", "host_send", " host_ends", "hostlexends", "hostlexsend", "hostsend", "hostsEND"], "addr": ["rt", "src", "ref", "ip", "host", "seq", "rc", "cmd", "ady", "pad", "ast", "inst", "alias", "coord", "ack", "size", "pointer", "nr", "id", "adder", "ace", "ord", "sta", "vr", "grad", "code", "error", "attr", "conn", "fx", "amd", "ad", "align", "hop", "adj", "ptr", "len", "en", "route", "part", "add", "dd", "layer", "r", "mac", "start", "index", "origin", "xp", "rr", "name", "x", "oa", "pos", "wd", "eth", "adr", "md", "arch", "amp", "dr", "offset", "order", "arr", "loc", "work", "url", "ext", "position", "enter", "act", "ac", "od", "nn", "obj", "Address"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);\n\n}\n", "idx": 10429, "substitutes": {"dst": ["dnst", " dST", "sdST", " drc", "drrc", "sdst", "dstr", "drST", "drst", "dnST", "dsrc", " dstr", "cdst", "drc", "sdrc", " dsrc", "dnstr", "drstr", "dST", "cdrc", "cdsrc", "dnrc", "sdsrc", "cdST"], "src": ["sur", "dest", "bis", "buf", "sel", "bc", "rob", "low", "dist", "sup", "i", "sr", "d", "sb", "rc", "config", "cb", "rl", "loc", "st", "b", "use", "bg", "img", "url", "grad", "gb", "rb", "sl", "iv", "source", "sc", "ffff", "rs", "sec", "s", "rate", "inst", "slice"], "stride": ["STRider", "ptided", "ptone", "strade", " strade", "strend", " strine", "drend", "drider", " strip", "STRine", "yrider", "strine", "strone", "arrade", "dride", "ptider", "drided", "arride", " strider", "STRide", "drone", "shrine", "arrided", "strided", "arrend", "drade", "yride", "shride", "STRip", "shrider", "yrided", "shrip", " strided", "yrend", " strone", "strip", " strend", "ptide", "strider"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int film_probe(AVProbeData *p)\n\n{\n\n    if (p->buf_size < 4)\n\n        return 0;\n\n\n\n    if (AV_RB32(&p->buf[0]) != FILM_TAG)\n\n        return 0;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n", "idx": 10449, "substitutes": {"p": ["np", "tp", "f", "pointer", "api", "k", "ip", "proc", "pb", "c", "pc", "a", "i", "jp", "d", "lp", "sp", "b", "j", "P", "pre", "v", "op", "fp", "t", "o", "ps", "gp", "l", "ap", "pp", "u", "m", "e", "pa", "n", "bp", "data"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,\n\n                       unsigned int size, int mem_index)\n\n{\n\n    int l1 = gen_new_label();\n\n    TCGv taddr = tcg_temp_local_new();\n\n    TCGv tval = tcg_temp_local_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    dc->postinc = 0;\n\n    cris_evaluate_flags(dc);\n\n\n\n    tcg_gen_mov_tl(taddr, addr);\n\n    tcg_gen_mov_tl(tval, val);\n\n\n\n    /* Store only if F flag isn't set */\n\n    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n    if (size == 1) {\n\n        tcg_gen_qemu_st8(tval, taddr, mem_index);\n\n    } else if (size == 2) {\n\n        tcg_gen_qemu_st16(tval, taddr, mem_index);\n\n    } else {\n\n        tcg_gen_qemu_st32(tval, taddr, mem_index);\n\n    }\n\n    gen_set_label(l1);\n\n    tcg_gen_shri_tl(t1, t1, 1);  /* shift F to P position */\n\n    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1); /*P=F*/\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(tval);\n\n    tcg_temp_free(taddr);\n\n}\n", "idx": 10478, "substitutes": {"dc": ["ga", "ctx", "xc", "cdn", "anc", "nc", "cow", "DC", "bc", "vc", "c", "db", "pc", "d", "rc", "cb", "cu", "ct", "ctrl", "doc", "context", "cfg", "cc", "di", "fc", "ac", "df", "da", "gui", "cf", "sc", "conn", "cr", "cot", "oc", "dm", "tc", "mc", "ec", "uc", "fd", " DC", "cca", "dt", "cd", "jc"], "addr": ["ne", "oa", "hw", "rt", "ctx", "src", "nr", "orde", "endor", "ptr", "tz", "ip", "host", "home", "adr", "md", "iii", "cmp", "au", "node", "amp", "rc", "ace", "cb", "offset", "ha", "ord", "sta", "loc", "kk", "rn", "ext", "kt", "address", "add", "layer", "rx", "attr", "conn", "amd", "az", "nn", "func", "ast", "obj", "tch", "align"], "val": ["la", "vol", "live", "valid", "pos", "vals", "local", "ref", "sel", "byte", "seq", "len", "db", "pc", "stat", "fe", "eval", "bl", "slot", "fee", "loc", "b", "Val", "grad", "pt", "VAL", "sl", "v", "mem", "alloc", "el", "all", "def", "dev", "buffer", "arg", "tx", "base", "lan", "value", "name", "alt", "data", "exec"], "size": ["g", "sized", "shift", "SIZE", "general", "capacity", "empty", "ctx", "li", "ny", "len", "c", "en", "needed", "small", "rc", "enc", "function", "fee", "si", "loc", "sh", "scale", "ize", "address", "code", "Size", "v", "z", "here", "sy", "length", "ui", "ci", "sc", "sync", "sn", "unit", "security", "value", "six", "ec", "sec", "eni", "uni", "send", "sum"], "mem_index": ["memingloc", "memory_level", " mem_width", " mem_loc", "memory_length", " mem_address", "mem_address", "memplacewidth", "memory_index", "mem_level", "memenloc", "memplaceindex", "memblockwidth", "memenindex", "memplaceaddress", "memingaddress", "mem_width", "memingindex", "memblockindex", "memblockaddress", "mem_loc", "memenaddress", "mem_size", "mem_length", "meminglevel", "memory_size", "memory_loc"]}}
{"project": "qemu", "commit_id": "947858b0ba97f4ec097de667e45eff99212867c3", "target": 0, "func": "static void ide_trim_bh_cb(void *opaque)\n\n{\n\n    TrimAIOCB *iocb = opaque;\n\n\n\n    iocb->common.cb(iocb->common.opaque, iocb->ret);\n\n\n\n    qemu_bh_delete(iocb->bh);\n\n    iocb->bh = NULL;\n\n    qemu_aio_unref(iocb);\n\n}\n", "idx": 10480, "substitutes": {"opaque": [" opairo", "OPque", "ipca", "iopca", "obaque", "opacity", "Opaques", "opairo", " opque", "iopque", "compaque", "iopairo", "ipacity", "obacity", " opca", " opacity", "OPca", "Opacity", "ipac", "opac", "ipaque", "compacity", "Opaque", "iopaque", "opca", "obca", "obac", "opaques", "compac", "Opca", "ipaques", "OPaque", "opque", " opaques", "OPairo", "compca"], "iocb": [" iocbi", "iecpb", "iocba", "iocbo", "iocbc", "icocgb", "ioadbo", "iorgk", "iopb", "iocombc", "iomab", " iocabi", "iocationgb", "ioadb", "iopf", "uiecob", "uiecbb", "iocab", " iocadb", "uiecf", "iocomob", "ioadbe", "iomb", "iocationpb", "uock", "iocibo", "iocib", "uiocf", " ioca", "uocbb", "iOCa", "iogbb", " iocab", "iocolob", "iorgbb", "icogbb", "iocationbb", "icocpb", "iOCub", "uiocob", "iocadb", "aiocbc", "iocbi", " iocaba", " iocub", "aioadbc", "ioclob", "aioadbe", "iocf", "ioca", "iOCab", "uecm", "toclb", "iocationdb", "iocibe", "toclbb", "iocibb", "iecob", "iorga", "iogpb", "iocpb", "iocm", "icocb", "iocibr", "iocalba", "iorgab", "uecb", "ueck", "tocbb", "iOCb", "iocomb", "iocbe", "toclbr", "iorgb", "iocdb", "tocob", "iocalbi", "iomub", " iomab", "iecf", " iomb", "iocolf", "iocob", "ioclb", "ioclm", " iocba", "iogb", "uecbb", "iocibc", "iocationbi", " iocdb", "icogb", "iocombr", "uiocb", "iecgb", "ioadbc", "iocombe", "aiocb", "iocaldb", "iecbb", " ioma", "iock", "icogpb", "iociob", "ieck", "iorgm", "iocolbb", "iocationba", "iocombo", "iopob", "aiocbo", "iocub", "ioggb", "iecm", "uocb", "tocbr", "iocbb", "icocbb", " iomub", "uocm", "iocalb", "iocationb", "iocombb", "uiocbb", "iocaba", "aioadb", "aioadbo", "iecb", "toclob", "ioclk", "iopbb", "uiecb", "iocgb", "ioclbr", "iocabi", "aiocbe", "iorgub", "tocb", "ioma", "iocolb", "iocbr", "ioclbb", "icoggb"]}}
{"project": "qemu", "commit_id": "ad11ad77748bdd8016370db210751683dc038dd6", "target": 0, "func": "static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd,\n\n                            abi_long cmd, abi_long arg)\n\n{\n\n    void *argptr;\n\n    struct dm_ioctl *host_dm;\n\n    abi_long guest_data;\n\n    uint32_t guest_data_size;\n\n    int target_size;\n\n    const argtype *arg_type = ie->arg_type;\n\n    abi_long ret;\n\n    void *big_buf = NULL;\n\n    char *host_data;\n\n\n\n    arg_type++;\n\n    target_size = thunk_type_size(arg_type, 0);\n\n    argptr = lock_user(VERIFY_READ, arg, target_size, 1);\n\n    if (!argptr) {\n\n        ret = -TARGET_EFAULT;\n\n        goto out;\n\n    }\n\n    thunk_convert(buf_temp, argptr, arg_type, THUNK_HOST);\n\n    unlock_user(argptr, arg, 0);\n\n\n\n    /* buf_temp is too small, so fetch things into a bigger buffer */\n\n    big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2);\n\n    memcpy(big_buf, buf_temp, target_size);\n\n    buf_temp = big_buf;\n\n    host_dm = big_buf;\n\n\n\n    guest_data = arg + host_dm->data_start;\n\n    if ((guest_data - arg) < 0) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n    guest_data_size = host_dm->data_size - host_dm->data_start;\n\n    host_data = (char*)host_dm + host_dm->data_start;\n\n\n\n    argptr = lock_user(VERIFY_READ, guest_data, guest_data_size, 1);\n\n    switch (ie->host_cmd) {\n\n    case DM_REMOVE_ALL:\n\n    case DM_LIST_DEVICES:\n\n    case DM_DEV_CREATE:\n\n    case DM_DEV_REMOVE:\n\n    case DM_DEV_SUSPEND:\n\n    case DM_DEV_STATUS:\n\n    case DM_DEV_WAIT:\n\n    case DM_TABLE_STATUS:\n\n    case DM_TABLE_CLEAR:\n\n    case DM_TABLE_DEPS:\n\n    case DM_LIST_VERSIONS:\n\n        /* no input data */\n\n        break;\n\n    case DM_DEV_RENAME:\n\n    case DM_DEV_SET_GEOMETRY:\n\n        /* data contains only strings */\n\n        memcpy(host_data, argptr, guest_data_size);\n\n        break;\n\n    case DM_TARGET_MSG:\n\n        memcpy(host_data, argptr, guest_data_size);\n\n        *(uint64_t*)host_data = tswap64(*(uint64_t*)argptr);\n\n        break;\n\n    case DM_TABLE_LOAD:\n\n    {\n\n        void *gspec = argptr;\n\n        void *cur_data = host_data;\n\n        const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };\n\n        int spec_size = thunk_type_size(arg_type, 0);\n\n        int i;\n\n\n\n        for (i = 0; i < host_dm->target_count; i++) {\n\n            struct dm_target_spec *spec = cur_data;\n\n            uint32_t next;\n\n            int slen;\n\n\n\n            thunk_convert(spec, gspec, arg_type, THUNK_HOST);\n\n            slen = strlen((char*)gspec + spec_size) + 1;\n\n            next = spec->next;\n\n            spec->next = sizeof(*spec) + slen;\n\n            strcpy((char*)&spec[1], gspec + spec_size);\n\n            gspec += next;\n\n            cur_data += spec->next;\n\n        }\n\n        break;\n\n    }\n\n    default:\n\n        ret = -TARGET_EINVAL;\n\n        goto out;\n\n    }\n\n    unlock_user(argptr, guest_data, 0);\n\n\n\n    ret = get_errno(ioctl(fd, ie->host_cmd, buf_temp));\n\n    if (!is_error(ret)) {\n\n        guest_data = arg + host_dm->data_start;\n\n        guest_data_size = host_dm->data_size - host_dm->data_start;\n\n        argptr = lock_user(VERIFY_WRITE, guest_data, guest_data_size, 0);\n\n        switch (ie->host_cmd) {\n\n        case DM_REMOVE_ALL:\n\n        case DM_DEV_CREATE:\n\n        case DM_DEV_REMOVE:\n\n        case DM_DEV_RENAME:\n\n        case DM_DEV_SUSPEND:\n\n        case DM_DEV_STATUS:\n\n        case DM_TABLE_LOAD:\n\n        case DM_TABLE_CLEAR:\n\n        case DM_TARGET_MSG:\n\n        case DM_DEV_SET_GEOMETRY:\n\n            /* no return data */\n\n            break;\n\n        case DM_LIST_DEVICES:\n\n        {\n\n            struct dm_name_list *nl = (void*)host_dm + host_dm->data_start;\n\n            uint32_t remaining_data = guest_data_size;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_name_list) };\n\n            int nl_size = 12; /* can't use thunk_size due to alignment */\n\n\n\n            while (1) {\n\n                uint32_t next = nl->next;\n\n                if (next) {\n\n                    nl->next = nl_size + (strlen(nl->name) + 1);\n\n                }\n\n                if (remaining_data < nl->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, nl, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + nl_size, nl->name);\n\n                cur_data += nl->next;\n\n                remaining_data -= nl->next;\n\n                if (!next) {\n\n                    break;\n\n                }\n\n                nl = (void*)nl + next;\n\n            }\n\n            break;\n\n        }\n\n        case DM_DEV_WAIT:\n\n        case DM_TABLE_STATUS:\n\n        {\n\n            struct dm_target_spec *spec = (void*)host_dm + host_dm->data_start;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };\n\n            int spec_size = thunk_type_size(arg_type, 0);\n\n            int i;\n\n\n\n            for (i = 0; i < host_dm->target_count; i++) {\n\n                uint32_t next = spec->next;\n\n                int slen = strlen((char*)&spec[1]) + 1;\n\n                spec->next = (cur_data - argptr) + spec_size + slen;\n\n                if (guest_data_size < spec->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, spec, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + spec_size, (char*)&spec[1]);\n\n                cur_data = argptr + spec->next;\n\n                spec = (void*)host_dm + host_dm->data_start + next;\n\n            }\n\n            break;\n\n        }\n\n        case DM_TABLE_DEPS:\n\n        {\n\n            void *hdata = (void*)host_dm + host_dm->data_start;\n\n            int count = *(uint32_t*)hdata;\n\n            uint64_t *hdev = hdata + 8;\n\n            uint64_t *gdev = argptr + 8;\n\n            int i;\n\n\n\n            *(uint32_t*)argptr = tswap32(count);\n\n            for (i = 0; i < count; i++) {\n\n                *gdev = tswap64(*hdev);\n\n                gdev++;\n\n                hdev++;\n\n            }\n\n            break;\n\n        }\n\n        case DM_LIST_VERSIONS:\n\n        {\n\n            struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start;\n\n            uint32_t remaining_data = guest_data_size;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_versions) };\n\n            int vers_size = thunk_type_size(arg_type, 0);\n\n\n\n            while (1) {\n\n                uint32_t next = vers->next;\n\n                if (next) {\n\n                    vers->next = vers_size + (strlen(vers->name) + 1);\n\n                }\n\n                if (remaining_data < vers->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, vers, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + vers_size, vers->name);\n\n                cur_data += vers->next;\n\n                remaining_data -= vers->next;\n\n                if (!next) {\n\n                    break;\n\n                }\n\n                vers = (void*)vers + next;\n\n            }\n\n            break;\n\n        }\n\n        default:\n\n            ret = -TARGET_EINVAL;\n\n            goto out;\n\n        }\n\n        unlock_user(argptr, guest_data, guest_data_size);\n\n\n\n        argptr = lock_user(VERIFY_WRITE, arg, target_size, 0);\n\n        if (!argptr) {\n\n            ret = -TARGET_EFAULT;\n\n            goto out;\n\n        }\n\n        thunk_convert(argptr, buf_temp, arg_type, THUNK_TARGET);\n\n        unlock_user(argptr, arg, target_size);\n\n    }\n\nout:\n\n    if (big_buf) {\n\n        free(big_buf);\n\n    }\n\n    return ret;\n\n}\n", "idx": 10485, "substitutes": {"ie": ["ii", "ne", "ni", "li", "IE", "die", "zip", "ine", "ip", "edge", "irc", "je", "ze", "ce", "eg", "iu", "ei", "ini", "eb", "tie", "qt", "intel", "ice", "ace", "lex", "ani", "isi", "sie", "lit", "ife", "plug", "le", "img", "ext", "ite", "cli", "lie", "ee", "nat", "pie", "nice", "ci", "oe", "oci", "job", "fit", "e", "ime", "ge", "ec", "eni", "ig", "ide", "exe"], "buf_temp": ["uf_tem", "buff_porary", " buf_tmp", " buf_current", " buf_tem", "buf_base", "buff_orig", "buf1temp", "uf_num", "uf_buffer", " buf_cache", "buflextemp", " buf_test", "buf_cache", "buf_buffer", "buf1tem", "bufjtem", "buff_cache", "buflextem", "buf_porary", "buf_current", "buf_orig", "bufjtemp", "buf_test", "bufjorig", "buf_tmp", "bufjporary", "buff_temp", "buf_tem", "buff_tem", "buflexcurrent", "buflextest", "buff_base", "buf1num", "uf_temp", "buf1buffer", "buf_num"], "fd": [" def", "iff", "f", "file", "nc", "fi", " dc", "Arg", "fe", "d", "rc", "enc", " fs", " f", "ds", "FD", "fc", "dc", "df", "std", " FD", "win", "def", "ffff", "fff", "fin", " fid"], "cmd": ["ctr", "mode", "buf", "md", "seq", "gd", "cmp", "method", "config", "cat", "cb", "bind", "gen", "cfg", "cli", "dc", "client", "header", "opt", "mac", "command", "def", "conn", "desc", "msg", "ctl", "Cmd", "alg", "window"], "arg": ["param", "g", "prop", "parse", "args", "ref", "result", "addr", "nick", "byte", "len", "exec", "Arg", "amp", "dr", "cat", "enc", "ang", "ace", "input", "slot", "arc", "arr", "loc", "use", "load", "gen", "flag", "bit", "doc", "ar", "ag", "ext", "end", "gt", "mem", "entry", "inc", "num", "mac", "argument", "win", "val", "call", "inter", "amd", "index", "pad", "init", "star", "msg", "reg", "nt", "sec", "var", "ad", "ig", "target", "str"], "argptr": ["argumentPtr", "argspointer", "argpointer", " argpointers", " argfp", "arrot", "parambf", "argumentpointer", "inpointer", "ackptr", "argPtr", "Argrot", "argbf", "argpt", "inpointers", "ArgPtr", "paramfp", "parpointer", "argfp", "docpointer", "argpad", " argpointer", "arPtr", "parPtr", "ackpointer", "inptr", "argumentptr", "argumentbf", " argPtr", "docptr", "paramptr", " argrot", "Argptr", "argrot", "arptr", "docPtr", " argpt", "arpt", " argbf", "parpointers", "argsPtr", "argpointers", "ackPtr", "argumentrot", "parptr", "argumentfp", "arpointer", " argpad", "docpt", "inPtr", "paramPtr", "Argpad", "ackrot", "argsptr", "Argpointer", "argspad"], "host_dm": ["host__fm", "hostalldt", "server_dm", "host_nm", "host_db", "host_dn", "hard_fm", "host_dim", "host_metadata", "host_dt", "client_dm", "hard_module", "Host_dt", "server_fm", "hard_dim", "host_fm", "host__data", "host__dm", "Host_dm", "host_dl", "client_metadata", "hostalldm", "hard_dm", "hostingmetadata", "hostalldata", "host_md", "hostPoolbm", "port_dm", "host__dim", "hostacdm", "hostallfm", "hostacdl", "hostingdn", "hostPooldb", "client_dn", "hostacdn", "hostingdm", "hostingdl", "port_dim", "host_dom", "client_dl", " host_db", "port_md", "host_module", "port_dc", "host_bm", "Host_cm", " host_dom", "Host_fm", " host_nm", "server_dt", "host__dt", "host_dc", "host_cm", " host_bm", " host_fm", "hostacmetadata", " host_dt", "hostPooldm", "host__module", "server_data", "hostPooldom"], "guest_data": ["guestingiondi", "guestiondat", "guestiondi", "guest__dat", "guest__data", "guesta_dat", "guestinglength", "guesting_data", "guester_data", "guestingiondef", "guest2buf", "guesta_alpha", "guestfulldat", "guest_length", "guest2dat", "guest__Data", "guesta_length", "guest_def", "guesting_dat", "guester_size", "guestingdata", "guest_dat", "guestingiondat", "guestiondata", "guest2Data", "guestingiondata", "guestiondef", "guest_size", "guesting_di", "guestfulldata", "guestingData", "guestingbuf", "guest_buf", "guester_buf", "guest_di", "guest__size", "guestingdat", "guester_Data", "guestfulldi", "guest_Data", "guester_dat", "guestingalpha", "guest_alpha", "guesting_def", "guesta_data", "guestfulldef", "guest2data"], "guest_data_size": ["guest_data_form", "guest_action_pos", "guest_data_pos", "guest_action_capacity", "guest_data_address", "guest_data_length", "guest_action_form", "guest_action_size", "guest_data_capacity", "guest_Data_scale", "guest_Data_length", "guest_data_scale", "guest_data_start", "guest_Data_address", "guest_Data_size", "guest_Data_start"], "target_size": ["target_capacity", "arget_len", "target64sized", "targetedname", "target64size", "arget_size", "target_sn", " target_start", "targetedstart", "target64capacity", "arget_capacity", " target_name", "target_name", "arget_sized", "target_start", "target_SIZE", "arget_name", "target_len", "target_sized", "targetedsize", "target64len", " target_SIZE", " target_sn", "arget_start"], "arg_type": ["argxsize", "argargrole", "arg_typ", "argargtype", "argargtypes", "cat_name", "cat_spec", " arg_name", "arg_spec", "errlentype", " arg_format", "argrtype", "int_order", "cat_type", "arg_role", "errlentyp", "arg_name", "err_typ", " arg_size", "arg_order", "int_types", "argfformat", "arglexrole", "arg_size", "int_type", "arglentyp", "int_role", "argrsize", "argftype", " arg_num", "err_name", "argvwidth", "argxtype", "argrnum", "argargorder", "arglenname", "arg_types", "argxname", "arglexorder", "arg_num", "argvspec", "arglextype", "argvtype", "arg_format", "argrname", "arglentype", "argxnum", "argvname", "errlenname", "err_type", "arglextypes", "argfname", "arg_width", "cat_width"], "ret": ["debug", "usr", "rets", "rt", "att", "match", "resp", "re", "RET", "ref", "rev", "output", "result", "ft", "seq", "success", "len", "eval", "rc", "cat", "back", "lit", "fun", "flag", "bit", "mt", "ut", "gt", "mem", "num", "opt", "val", "det", "def", "buffer", "job", "reply", "pat", "reg", "sec", "res", "nt", "alt", "Ret", "gc", "hash", "feat", "let"], "big_buf": ["real___buf", " big_uf", "big__buff", " big_vec", "big__buf", "real_buffer", "big_uf", "big___bu", "big54buf", "big54buffer", "real___batch", "big___buf", "big__buffer", "big_tmp", "big_vec", " big_buffer", "big___buffer", "real_buff", "big54tmp", "home54uf", " big_bu", "big___batch", "big_batch", "big_bu", "home54buffer", "home_tmp", "big54uf", "big54vec", "real_buf", "home54tmp", "home_uf", " big_tmp", "big54bu", "big__uf", "big___buff", "big_buff", "big_buffer", "home_buf", "home54buf", "real___buffer", "bigxuf", "real___buff", "bigxtmp", "bigxbuff", "real_batch", "big___vec", " big_buff", "big54buff", "home_buffer", "bigxbuf"], "host_data": ["hostsdata", " host_dat", "host_addr", "master_data", "hostsdat", " host_slice", "host_dat", "hostacdm", "master_dat", "master_addr", "master_size", "hostacdata", "hostacdat", "hostssize", "hostacslice", "host_slice", "host_size", "hostsaddr"]}}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)\n\n{\n\n    InputStream        *ist = s->opaque;\n\n    DXVA2Context       *ctx = ist->hwaccel_ctx;\n\n    int                ret;\n\n\n\n    ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = av_frame_copy_props(ctx->tmp_frame, frame);\n\n    if (ret < 0) {\n\n        av_frame_unref(ctx->tmp_frame);\n\n        return ret;\n\n    }\n\n\n\n    av_frame_unref(frame);\n\n    av_frame_move_ref(frame, ctx->tmp_frame);\n\n\n\n    return 0;\n\n}\n", "idx": 10498, "substitutes": {"s": ["support", "os", "sd", "sed", "f", "src", "service", "cs", "ls", "self", "sf", "ss", "c", "sq", "is", "ks", "sv", "sb", "es", "lex", "sg", "iss", "si", "ds", "st", "fs", "ssl", "sts", "sl", "ns", "spec", "source", "ps", "ses", "sc", "gs", "as", "sys", "storage", "sec", "sa", "so"], "frame": ["phy", "pse", "fr", "setup", "f", "file", "flow", "view", "host", "fi", "ze", "za", "ce", "fe", "feature", "dr", "document", "iframe", "config", "ace", "fake", "fb", "object", "interface", " Frame", "cfg", "cpu", "part", "kt", "thread", "framework", "code", "image", "fc", "coe", "source", "fram", "cf", "point", "fx", "frames", "rame", "e", "base", "info", "scene", "Frame", "video", "none", "data", "feat", "slice", "fact"], "ist": ["ista", "et", "sd", "ess", "rt", "ost", "aci", "alist", "ict", "asp", "imet", "ais", "adr", "dist", "isi", "osi", "isd", "iss", "st", "sta", "esp", "ism", "ld", "pt", "est", "kt", "IST", "irst", "ind", "wp", "ir", "iste", "ast", "nt", "ists", "ad", "inst", "ird", "ide", "pect", "isc"], "ctx": ["cas", "Context", "xc", "anc", "cs", "nc", "comp", "wx", "ce", "wcs", "vc", "c", "sq", "cycle", "pc", "ca", "cmp", "qt", "config", "sci", "ck", "pkg", "loc", "cy", "cp", "cm", "cu", "ct", "ctrl", "cor", "context", "cfg", " context", "cc", "kt", "cli", "fc", "coll", "cv", "css", "que", "mac", "cmd", "wp", "cf", "conn", "ci", "sync", "cus", "cr", "sc", "cam", "tx", "fw", "cn", "ec", "lc", "cca"], "ret": ["usr", "rt", "rets", "att", "id", "re", "RET", "ref", "rev", "ft", "result", "success", "len", "en", "art", "fab", "rc", "cat", "back", "fun", "rf", "j", "flag", "bit", "pt", "run", "mt", "ext", "rb", "end", "code", "gt", "mem", "t", "r", "val", "det", "req", "pet", "def", "opt", "ry", "arg", "base", "pat", "obj", "res", "nt", "reg", "or", "fin", "alt", "Ret", "bf", "data", "bad"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "void decode_mb_mode(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y,\n\n                    uint8_t *segment, uint8_t *ref, int layout)\n\n{\n\n    VP56RangeCoder *c = &s->c;\n\n\n\n    if (s->segmentation.update_map)\n\n        *segment = vp8_rac_get_tree(c, vp8_segmentid_tree, s->prob->segmentid);\n\n    else if (s->segmentation.enabled)\n\n        *segment = ref ? *ref : *segment;\n\n    mb->segment = *segment;\n\n\n\n    mb->skip = s->mbskip_enabled ? vp56_rac_get_prob(c, s->prob->mbskip) : 0;\n\n\n\n    if (s->keyframe) {\n\n        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra,\n\n                                    vp8_pred16x16_prob_intra);\n\n\n\n        if (mb->mode == MODE_I4x4) {\n\n            decode_intra4x4_modes(s, c, mb, mb_x, 1, layout);\n\n        } else {\n\n            const uint32_t modes = vp8_pred4x4_mode[mb->mode] * 0x01010101u;\n\n            if (s->mb_layout == 1)\n\n                AV_WN32A(mb->intra4x4_pred_mode_top, modes);\n\n            else\n\n                AV_WN32A(s->intra4x4_pred_mode_top + 4 * mb_x, modes);\n\n            AV_WN32A(s->intra4x4_pred_mode_left, modes);\n\n        }\n\n\n\n        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,\n\n                                                vp8_pred8x8c_prob_intra);\n\n        mb->ref_frame        = VP56_FRAME_CURRENT;\n\n    } else if (vp56_rac_get_prob_branchy(c, s->prob->intra)) {\n\n        // inter MB, 16.2\n\n        if (vp56_rac_get_prob_branchy(c, s->prob->last))\n\n            mb->ref_frame =\n\n                vp56_rac_get_prob(c, s->prob->golden) ? VP56_FRAME_GOLDEN2 /* altref */\n\n                                                      : VP56_FRAME_GOLDEN;\n\n        else\n\n            mb->ref_frame = VP56_FRAME_PREVIOUS;\n\n        s->ref_count[mb->ref_frame - 1]++;\n\n\n\n        // motion vectors, 16.3\n\n        decode_mvs(s, mb, mb_x, mb_y, layout);\n\n    } else {\n\n        // intra MB, 16.1\n\n        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s->prob->pred16x16);\n\n\n\n        if (mb->mode == MODE_I4x4)\n\n            decode_intra4x4_modes(s, c, mb, mb_x, 0, layout);\n\n\n\n        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,\n\n                                                s->prob->pred8x8c);\n\n        mb->ref_frame        = VP56_FRAME_CURRENT;\n\n        mb->partitioning     = VP8_SPLITMVMODE_NONE;\n\n        AV_ZERO32(&mb->bmv[0]);\n\n    }\n\n}\n", "idx": 10502, "substitutes": {"s": ["g", "os", "sym", "f", "service", "cs", "ls", "self", "sf", "ss", "sq", "is", "ks", "sv", "services", "sb", "d", "es", "h", "p", "ts", "sg", "si", "S", "ds", "b", "session", "fs", "ssl", "j", "se", "sl", "sis", "ns", "bs", "sim", "spec", "v", "cli", "us", "ch", "r", "t", "o", "ps", "ses", "qs", "l", "sc", "sync", "gs", "w", "m", "com", "conf", "e", "n", "sys", "sets", "su", "rs", "storage", "sec", "js", "aws"], "mb": ["ph", "pg", "em", "bm", "mode", "sm", "k", "MB", "mp", "nb", "bc", "byte", "md", "pb", "gg", "db", "lb", "eb", "usb", "sb", "bl", "mod", "p", "ib", "kb", "b", "fm", "cm", "bg", "fb", "cp", "gb", "cfg", "mt", "bs", "rb", "bd", "v", "ms", "mem", "vm", "bb", "xb", "mac", "ym", "ab", "gs", "m", "job", "amb", "emb", "mm", "base", "e", "ob", "mor", "mc", "bp", "bf", "mn"], "mb_x": ["MB_x", "mb_i", "mb_ex", "bb_y", "MB_name", "bb_x", "mb_type", "mb_name", "mp_y", "mb_width", "mp_x", "bb_ex", "bb_type", "MB_y", "MB_xy", "mp_width", "mp_i", "mb_xy"], "mb_y": ["MB_i", "MB_x", "mb_i", "MB_Y", "mb1x", "mb1i", "MB_y", "mb1y", "mb1Y", "mb_Y"], "segment": ["SEgement", "algment", "psegments", "alment", "sement", "aseignment", "asegment", "gegment", "gegments", " segments", "pegment", "psegment", "SEignment", " segement", "persement", "mement", "asegments", "psegement", "SEment", "alignment", "gement", "semission", "pegments", "asement", "gegement", "seignment", "pemission", "megment", "SEgments", "megement", "megments", "algement", "SEgment", " semission", "psement", "pegement", "persegment", "persemission", "segments", "segement", " sement", "asegement", "pement", "persegments"], "ref": ["absolute", "pos", "remote", "prefix", "fr", "block", "f", "type", "mode", "id", "diff", "local", "re", "include", "comp", "href", "seq", "route", "REF", "config", "offset", "Ref", "primary", "loc", "rf", "range", "url", "part", "pre", "image", " reference", "parent", "num", "rel", "af", "def", "index", "ab", "reference", "conf", "base", "info", "relative", "raw", "alt", "bf", "count", "location"], "layout": ["la", "board", "mount", "mode", "id", "diff", "flow", "view", "xml", "route", "config", "model", "offset", "slot", "loc", "qa", "cell", "shape", "lim", "position", "shell", "loop", "fc", "lang", "parent", "num", "layer", "cl", "scroll", "def", "lay", "delay", "unit", "Layout", "lc", "repeat", "bf", "location"], "c": ["g", "ctx", "f", "xc", "k", "cs", "nc", "ce", "bc", "vc", "pc", "ca", "d", "config", "h", "rc", "p", "arc", "cur", "b", "cy", "cm", "cu", "con", "ct", "center", "cc", "v", "C", "dc", "ch", "ac", "code", "cms", "o", "t", "r", "cl", "cmd", "channel", "l", "cf", "ci", "u", "sc", "cus", "conn", "w", "m", "com", "oc", "e", "n", "mc", "lc", "uc", "ec", "jc", "cache"], "ref_frame": ["ref_thread", "ref_model", "refbmode", "refpreframe", "refbmodel", "reference_frame", "refpremodel", "reference_mode", "reference_thread", "ref_mode", "refbframe", "reference_model", "refbthread", "refprethread", "refpremode"]}}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "static int decode_micromips_opc (CPUMIPSState *env, DisasContext *ctx, int *is_branch)\n\n{\n\n    uint32_t op;\n\n\n\n    /* make sure instructions are on a halfword boundary */\n\n    if (ctx->pc & 0x1) {\n\n        env->CP0_BadVAddr = ctx->pc;\n\n        generate_exception(ctx, EXCP_AdEL);\n\n        ctx->bstate = BS_STOP;\n\n        return 2;\n\n    }\n\n\n\n    op = (ctx->opcode >> 10) & 0x3f;\n\n    /* Enforce properly-sized instructions in a delay slot */\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        int bits = ctx->hflags & MIPS_HFLAG_BMASK_EXT;\n\n\n\n        switch (op) {\n\n        case POOL32A:\n\n        case POOL32B:\n\n        case POOL32I:\n\n        case POOL32C:\n\n        case ADDI32:\n\n        case ADDIU32:\n\n        case ORI32:\n\n        case XORI32:\n\n        case SLTI32:\n\n        case SLTIU32:\n\n        case ANDI32:\n\n        case JALX32:\n\n        case LBU32:\n\n        case LHU32:\n\n        case POOL32F:\n\n        case JALS32:\n\n        case BEQ32:\n\n        case BNE32:\n\n        case J32:\n\n        case JAL32:\n\n        case SB32:\n\n        case SH32:\n\n        case POOL32S:\n\n        case ADDIUPC:\n\n        case SWC132:\n\n        case SDC132:\n\n        case SD32:\n\n        case SW32:\n\n        case LB32:\n\n        case LH32:\n\n        case DADDIU32:\n\n        case LWC132:\n\n        case LDC132:\n\n        case LD32:\n\n        case LW32:\n\n            if (bits & MIPS_HFLAG_BDS16) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                /* Just stop translation; the user is confused.  */\n\n                ctx->bstate = BS_STOP;\n\n                return 2;\n\n            }\n\n            break;\n\n        case POOL16A:\n\n        case POOL16B:\n\n        case POOL16C:\n\n        case LWGP16:\n\n        case POOL16F:\n\n        case LBU16:\n\n        case LHU16:\n\n        case LWSP16:\n\n        case LW16:\n\n        case SB16:\n\n        case SH16:\n\n        case SWSP16:\n\n        case SW16:\n\n        case MOVE16:\n\n        case ANDI16:\n\n        case POOL16D:\n\n        case POOL16E:\n\n        case BEQZ16:\n\n        case BNEZ16:\n\n        case B16:\n\n        case LI16:\n\n            if (bits & MIPS_HFLAG_BDS32) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                /* Just stop translation; the user is confused.  */\n\n                ctx->bstate = BS_STOP;\n\n                return 2;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    switch (op) {\n\n    case POOL16A:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rs1 = mmreg(uMIPS_RS1(ctx->opcode));\n\n            int rs2 = mmreg(uMIPS_RS2(ctx->opcode));\n\n            uint32_t opc = 0;\n\n\n\n            switch (ctx->opcode & 0x1) {\n\n            case ADDU16:\n\n                opc = OPC_ADDU;\n\n                break;\n\n            case SUBU16:\n\n                opc = OPC_SUBU;\n\n                break;\n\n            }\n\n\n\n            gen_arith(ctx, opc, rd, rs1, rs2);\n\n        }\n\n        break;\n\n    case POOL16B:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rs = mmreg(uMIPS_RS(ctx->opcode));\n\n            int amount = (ctx->opcode >> 1) & 0x7;\n\n            uint32_t opc = 0;\n\n            amount = amount == 0 ? 8 : amount;\n\n\n\n            switch (ctx->opcode & 0x1) {\n\n            case SLL16:\n\n                opc = OPC_SLL;\n\n                break;\n\n            case SRL16:\n\n                opc = OPC_SRL;\n\n                break;\n\n            }\n\n\n\n            gen_shift_imm(ctx, opc, rd, rs, amount);\n\n        }\n\n        break;\n\n    case POOL16C:\n\n        gen_pool16c_insn(ctx, is_branch);\n\n        break;\n\n    case LWGP16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = 28;            /* GP */\n\n            int16_t offset = SIMM(ctx->opcode, 0, 7) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case POOL16F:\n\n        if (ctx->opcode & 1) {\n\n            generate_exception(ctx, EXCP_RI);\n\n        } else {\n\n            /* MOVEP */\n\n            int enc_dest = uMIPS_RD(ctx->opcode);\n\n            int enc_rt = uMIPS_RS2(ctx->opcode);\n\n            int enc_rs = uMIPS_RS1(ctx->opcode);\n\n            int rd, rs, re, rt;\n\n            static const int rd_enc[] = { 5, 5, 6, 4, 4, 4, 4, 4 };\n\n            static const int re_enc[] = { 6, 7, 7, 21, 22, 5, 6, 7 };\n\n            static const int rs_rt_enc[] = { 0, 17, 2, 3, 16, 18, 19, 20 };\n\n\n\n            rd = rd_enc[enc_dest];\n\n            re = re_enc[enc_dest];\n\n            rs = rs_rt_enc[enc_rs];\n\n            rt = rs_rt_enc[enc_rt];\n\n\n\n            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);\n\n            gen_arith_imm(ctx, OPC_ADDIU, re, rt, 0);\n\n        }\n\n        break;\n\n    case LBU16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4);\n\n            offset = (offset == 0xf ? -1 : offset);\n\n\n\n            gen_ld(ctx, OPC_LBU, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LHU16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;\n\n\n\n            gen_ld(ctx, OPC_LHU, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LWSP16:\n\n        {\n\n            int rd = (ctx->opcode >> 5) & 0x1f;\n\n            int rb = 29;            /* SP */\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LW16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SB16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_st(ctx, OPC_SB, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SH16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;\n\n\n\n            gen_st(ctx, OPC_SH, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SWSP16:\n\n        {\n\n            int rd = (ctx->opcode >> 5) & 0x1f;\n\n            int rb = 29;            /* SP */\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;\n\n\n\n            gen_st(ctx, OPC_SW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SW16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;\n\n\n\n            gen_st(ctx, OPC_SW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case MOVE16:\n\n        {\n\n            int rd = uMIPS_RD5(ctx->opcode);\n\n            int rs = uMIPS_RS5(ctx->opcode);\n\n\n\n            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);\n\n        }\n\n        break;\n\n    case ANDI16:\n\n        gen_andi16(ctx);\n\n        break;\n\n    case POOL16D:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUS5:\n\n            gen_addius5(ctx);\n\n            break;\n\n        case ADDIUSP:\n\n            gen_addiusp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case POOL16E:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUR2:\n\n            gen_addiur2(ctx);\n\n            break;\n\n        case ADDIUR1SP:\n\n            gen_addiur1sp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case B16:\n\n        gen_compute_branch(ctx, OPC_BEQ, 2, 0, 0,\n\n                           SIMM(ctx->opcode, 0, 10) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case BNEZ16:\n\n    case BEQZ16:\n\n        gen_compute_branch(ctx, op == BNEZ16 ? OPC_BNE : OPC_BEQ, 2,\n\n                           mmreg(uMIPS_RD(ctx->opcode)),\n\n                           0, SIMM(ctx->opcode, 0, 7) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case LI16:\n\n        {\n\n            int reg = mmreg(uMIPS_RD(ctx->opcode));\n\n            int imm = ZIMM(ctx->opcode, 0, 7);\n\n\n\n            imm = (imm == 0x7f ? -1 : imm);\n\n            tcg_gen_movi_tl(cpu_gpr[reg], imm);\n\n        }\n\n        break;\n\n    case RES_20:\n\n    case RES_28:\n\n    case RES_29:\n\n    case RES_30:\n\n    case RES_31:\n\n    case RES_38:\n\n    case RES_39:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    default:\n\n        decode_micromips32_opc (env, ctx, op, is_branch);\n\n        return 4;\n\n    }\n\n\n\n    return 2;\n\n}\n", "idx": 10504, "substitutes": {"env": ["oa", "np", "cdn", "err", "ea", "fi", "exc", "chal", "db", "en", "eu", "qt", "ev", "enc", "cb", "pkg", "Environment", "inst", "qa", "scope", "equ", "cal", "context", "cfg", "iv", "viron", "cv", "environment", "que", "her", "conn", "dev", "cot", "org", "conf", "pec", "e", "info", "ec", "fg", "priv", "erv", "txt", "manager", "esp"], "ctx": ["linux", "src", "cs", "nc", "comp", "c", "pc", "jp", "rc", "cpp", "console", "sci", "settings", "cm", "cc", "kt", "rx", "cmd", "ci", "gs", "fw", "cn", "cca", "gc", "txt", "cas", "np", "fn", "xc", "sq", "conv", "ck", "grad", "sc", "conn", "progress", "qq", "exec", "utils", "prefix", "hw", "bc", "wcs", "vc", "ca", "concept", "config", "pkg", "qa", "kw", "ku", "fc", "std", "cf", "sync", "lib", "util", "lc", "support", "ga", "Context", "anc", "na", "wx", "cmp", "cb", "kb", "loc", "cp", "ct", "ctrl", "context", "cli", "cv", "client", "git", "tx"], "is_branch": ["is_refaged", "is_baged", "is_balaged", "is_buster", "is_refacket", "is_bruster", "is_refanch", "is_baluster", "is_backet", "is_braged", "is_balanch", "is_balacket", "is_banch", "is_refuster", "is_bracket"], "op": ["hop", "prop", "prefix", "type", "mode", "rop", "tool", "ip", "prev", "oop", "lic", "proc", "addr", "Op", "option", "ver", "off", "ant", "dr", "cat", "mod", "p", "cop", "expr", "ep", "sp", "operation", "ext", "bit", "operator", "omp", " Op", "vert", "oper", "opt", "OP", "cmd", "ap", "opus", "ipop", "lock", "oc", "msg", "opp", "pop", "top", "name", "bug", " ip", "pol", "ops", "it"]}}
{"project": "FFmpeg", "commit_id": "ccb76ad91f2b97009b06c22ae1b2e0234dbf26ca", "target": 0, "func": "static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)\n\n{\n\n    int i;\n\n    int vlc    = get_bits1(&q->gb);\n\n    int start  = cplband[p->js_subband_start];\n\n    int end    = cplband[p->subbands - 1];\n\n    int length = end - start + 1;\n\n\n\n    if (start > end)\n\n        return;\n\n\n\n    if (vlc)\n\n        for (i = 0; i < length; i++)\n\n            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);\n\n    else\n\n        for (i = 0; i < length; i++)\n\n            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);\n\n}\n", "idx": 10513, "substitutes": {"q": ["g", "pg", "ctx", "iq", "f", "id", "local", "k", "xml", "view", "comp", "c", "sq", "qt", "d", "rc", "config", "quest", "cur", "h", "sh", "qa", "app", "queue", "dq", "j", "ct", "context", "core", "question", "charge", "Q", "z", "v", "ch", "qi", "t", "cl", "que", "req", "qs", "cf", "u", "w", "m", "query", "qu", "e", "qq", "mail", "cache"], "p": ["param", "plugin", "np", "parse", "tp", "f", "pm", "api", "k", "ip", "parser", "pb", "c", "pc", "d", "params", "lp", "pr", "per", "cop", "sp", "pkg", "b", "pi", "cp", "j", "part", "P", "po", "pre", "v", "op", "press", "t", "o", "ps", "wp", "l", "ap", "pp", "u", "vp", "w", "m", "e", "pa", "n", "s", "bp", "py", "post"], "decouple_tab": ["decouple__tab", "decouplethebag", "decourage_tmp", "decouple_tag", "decourage_tab", "decouple__table", "decouple2window", "decouple__ab", "decouple_window", "decouplethetmp", "decourage_lab", "decouplethetab", "decourage_window", "decouple__tag", "decouple_lab", "decouple_ab", "decourage_tag", "decouple__bag", "decouple2tab", "decouplethetable", "decouple_bag", "decouple2tag", "decourage_bag", "decourage_table", "decouple__lab", "decouple_table", "decouple2ab", "decouple__window", "decourage_ab", "decouple_tmp"], "i": ["ii", "ti", "g", "ni", "abi", "li", "uri", "f", "id", "phi", "I", "k", "ip", "oi", "fi", "adi", "c", "yi", "iu", "ini", "a", "ei", "d", "multi", "h", "ri", "ji", "si", "b", "pi", "xi", "io", "j", "gi", "end", "ie", "z", "v", "in", "di", "bi", "zi", "ind", "qi", "ui", "t", "length", "o", "l", "ci", "u", "start", "m", "e", "n", "info", "ai", "lc", "eni", "x", "ix", "it"]}}
{"project": "FFmpeg", "commit_id": "d1f3e475f9807b445ba37ff2fd23f71c4645de79", "target": 1, "func": "static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)\n\n{\n\n    int ret;\n\n    FailingMuxerPacketData *data = av_malloc(sizeof(*data));\n\n\n\n\n    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));\n\n    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));\n\n\n\n    pkt->pts = pkt->dts = pts;\n\n    pkt->duration = 1;\n\n\n\n    return ret;\n", "idx": 10520, "substitutes": {"pkt": ["backet", " packet", "ppct", "mkg", " peth", "pct", "ppkt", "packet", "Pct", "bnt", "hnt", "mkt", "macket", "Pkt", "het", "Packet", "cpkt", " pcht", "pkg", "cpnt", "cpct", " pct", "hacket", "bet", "pcht", "ppcht", "meth", " pkg", "cpkg", "Pnt", "Pet", "peth", "pnt", " pnt", "pet", " pet", "hkt", "cpeth", "bkt", "cpacket", "ppacket", "Pcht", "cpet"], "pkt_data": ["packet_memory", "pkt_memory", "packet_buffer", "pkt_buffer", "pkt_parts", "packet_cache", "packet_parts", "packet_data", "pkt_cache"], "pts": ["portds", "ointss", "ctts", "ctds", " ptssets", "pulls", "periods", "cts", "ntds", "pullts", "portts", "periodts", "ptments", "ptsets", "ptds", "ntts", " ptsstats", "periodd", "ctments", "nts", "portments", "ointstats", "ntd", "ptts", " ptsss", "ptstats", "ntments", "oints", " ptstats", " ptss", "ptd", "pulld", "ptss", "ports", " ptsets", "ointsets"], "ret": ["et", "valid", "rt", "f", "rets", "match", "att", "re", "RET", "eth", "rev", "fi", "ft", "result", "success", "len", "al", "en", "art", "cat", "back", "lit", "fun", "flag", "ext", "flat", "mt", "part", "code", "num", "t", "val", "det", "pet", "def", "reply", "obj", "base", "res", "nt", "out", "fin", "alt", "Ret", "bf", "status"], "data": ["bus", "dat", "ata", "message", "valid", "size", "parts", "Data", "api", "buf", "ada", "connection", "result", "addr", "media", "alpha", "a", "d", "DATA", "new", "config", "bytes", "p", "content", "input", "arr", "results", "load", "done", "missing", "part", "array", "memory", "di", "package", "record", "image", "dd", "parent", "address", "partial", "reader", "code", "da", "resource", "bin", "start", "map", "buffer", "pad", "body", "current", "base", "zero", "batch", "ad", "window", "raw", "slice", "cache"]}}
{"project": "FFmpeg", "commit_id": "54b2d317ed99622efa07b10aca217e1a083105d9", "target": 0, "func": "static void find_best_state(uint8_t best_state[256][256], const uint8_t one_state[256]){\n\n    int i,j,k,m;\n\n    double l2tab[256];\n\n\n\n    for(i=1; i<256; i++)\n\n        l2tab[i]= log2(i/256.0);\n\n\n\n    for(i=0; i<256; i++){\n\n        double best_len[256];\n\n        double p= i/256.0;\n\n\n\n        for(j=0; j<256; j++)\n\n            best_len[j]= 1<<30;\n\n\n\n        for(j=FFMAX(i-10,1); j<FFMIN(i+11,256); j++){\n\n            double occ[256]={0};\n\n            double len=0;\n\n            occ[j]=1.0;\n\n            for(k=0; k<256; k++){\n\n                double newocc[256]={0};\n\n                for(m=0; m<256; m++){\n\n                    if(occ[m]){\n\n                        len -=occ[m]*(     p *l2tab[    m]\n\n                                      + (1-p)*l2tab[256-m]);\n\n                    }\n\n                }\n\n                if(len < best_len[k]){\n\n                    best_len[k]= len;\n\n                    best_state[i][k]= j;\n\n                }\n\n                for(m=0; m<256; m++){\n\n                    if(occ[m]){\n\n                        newocc[    one_state[    m]] += occ[m]*   p ;\n\n                        newocc[256-one_state[256-m]] += occ[m]*(1-p);\n\n                    }\n\n                }\n\n                memcpy(occ, newocc, sizeof(occ));\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 10539, "substitutes": {"best_state": ["bestalorder", " best_order", "onesstring", "best_cell", "one_config", "oneegerconfig", "oneegerstring", "oneegercell", "bestalloc", "one_cell", "oneegerstate", " best_reg", "bestalreg", " best_loc", "one_string", "best_string", "best_order", "bestalstate", "onescell", "best_loc", "best_config", "onesconfig", "onesstate", "best_reg"], "one_state": ["one_scale", " one_string", " one_type", "one_part", "one_area", "one_type", "one_string", "one_slice", "one_system", "one_states"], "i": ["ii", "ni", "li", "im", "uri", "f", "id", "I", "api", "ip", "oi", "mi", "fi", "y", "c", "yi", "ki", "iu", "ini", "is", "multi", "ji", "p", "ri", "si", "b", "pi", "io", "gi", "ie", "ami", "z", "v", "zi", "bi", "xi", "di", "qi", "o", "ui", "ik", "l", "ci", "q", "u", "e", "n", "my", "ai", "mini", "eni", "in", "x", "ix", "it"], "j": ["ii", "g", "ni", "li", "f", "je", "jo", "jet", "y", "uj", "c", "jp", "ja", "d", "h", "ji", "p", "jen", "b", "kj", "jl", "ie", "key", "z", "v", "ch", "J", "o", "r", "qi", "t", "jc", "oj", "l", "ui", "q", "u", "start", "w", "job", "ij", "e", "n", "jj", "dj", "s", "js", "aj", "x", "it"], "k": ["ok", "g", "ph", "f", "ky", "ke", "wk", "K", "y", "c", "kn", "ki", "ak", "ks", "d", "uk", "h", "p", "ck", "b", "kk", "kw", "ko", "key", "z", "v", "ch", "kin", "o", "r", "ik", "l", "km", "q", "u", "w", "ek", "mm", "e", "n", "sk", "s", "x"], "m": ["g", "im", "man", "f", "em", "bm", "pm", "sm", "mu", "um", "mi", "gm", "ma", "md", "c", "y", "mr", "module", "a", "an", "d", "h", "p", "b", "fm", "cm", "z", "v", "o", "r", "t", "l", "km", "q", "u", "ym", "am", "w", "om", "mm", "e", "n", "dm", "M", "mc", "s", "mn", "x", "hm"], "l2tab": ["l4Tab", "l4lab", " l4tab", "l62tab", " l4lab", "l2loc", "l2ab", "l_mem", " l4loc", " l4mem", "l2buff", " l1buff", " l2Tab", "r3ab", "l1Tab", "r3loc", "l_tab", "l2lab", "l_loc", "l3tab", "l1loc", "l5loc", "l3ab", "l62loc", " l2buff", " l1lab", "l4loc", "l5tab", "l3mem", "l1buff", "l2mem", " l2ab", "l4tab", " l1loc", " l4Tab", "l62buff", "r2lab", "l4mem", "l3loc", " l2lab", "l62lab", "l5Tab", "l1tab", "r3lab", "r2ab", "r2loc", "l_ab", " l2mem", " l1tab", "l3buff", " l2loc", "l_lab", "l5lab", "l1ab", " l4ab", "l2Tab", "l4ab", "r2tab", "r3tab", "l3lab", "l1lab"], "best_len": ["best_lon", " best_lit", "best_val", "bestParlen", " best_lon", "best_pos", "best___lon", "better_len", " best_id", "best_id", " best_norm", "bestenlabel", "best2val", "best___len", " best_pos", "better_val", "bestensum", "better_pos", "bestParlabel", "best2norm", "best_label", "better_lin", "best_norm", "best_Len", "bestParpos", " best_val", "best2lon", "best_lin", " best_Len", " best_sum", "bestParsum", "best_sum", "bestenlen", "bestenpos", " best_label", "best___norm", "best___val", "best_lit", "best2len"], "occ": [" rec", "dat", "abc", "events", "resp", "mu", "err", "nc", "address", "pl", " circ", "exc", "anc", "frac", "inf", "result", "bc", "seq", "cci", "eff", "auc", "fe", "ae", "bl", "config", "cur", "enc", "arr", "loc", "app", "toc", "pha", "ah", "cont", "feed", "cc", "charges", "z", "fc", "ac", "coll", "charge", "aug", "inc", "bec", "ind", "cl", "ffe", "oper", "roc", "Occ", "cf", "index", "form", "rec", "acc", "org", "oci", "com", "mult", "circ", "oc", "ec", "cons", "uc", "rh", "comb", "feat", "coord"], "newocc": ["Newexc", "Newacc", "updateocc", "neweff", "Newloc", "NEWloc", " newcirc", "updateexc", "updateOcc", "nextacc", "nextocc", "Newocc", "NEWacc", "updateacc", "newloc", "newacc", " newOcc", "newexc", " newexc", " neweff", "nextOcc", "NEWocc", "nexteff", " newloc", "NEWOcc", "newOcc", "Newcirc", "newcirc", " newacc", "NewOcc", "Neweff"]}}
{"project": "FFmpeg", "commit_id": "ff486c0f7f6b2ace3f0238660bc06cc35b389676", "target": 0, "func": "static int get_pcm(HEVCContext *s, int x, int y)\n\n{\n\n    int log2_min_pu_size = s->sps->log2_min_pu_size;\n\n    int x_pu             = x >> log2_min_pu_size;\n\n    int y_pu             = y >> log2_min_pu_size;\n\n\n\n    if (x < 0 || x_pu >= s->sps->min_pu_width ||\n\n        y < 0 || y_pu >= s->sps->min_pu_height)\n\n        return 2;\n\n    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];\n\n}\n", "idx": 10547, "substitutes": {"s": ["g", "sym", "f", "site", "service", "cs", "ls", "self", "sf", "ss", "side", "xs", "c", "sq", "is", "i", "sv", "services", "sb", "es", "p", "ts", "sg", "http", "S", "ds", "si", "b", "session", "ssl", "settings", "fs", "context", "se", "sim", "ns", "spec", "t", "o", "ps", "ses", "qs", "sky", "sync", "u", "gs", "w", "m", "e", "n", "sets", "sys", "su", "storage", "space", "js", "aws"], "x": ["ax", "size", "f", "id", "max", "xs", "c", "X", "ex", "i", "xy", "d", "h", "p", "b", "px", "z", "v", "xi", "image", "pe", "rx", "t", "l", "u", "index", "xx", "dx", "fx", "w", "height", "m", "tx", "e", "n", "ix"], "y": ["zy", "ey", "yy", "yo", "iy", "ny", "ys", "ya", "ies", "yi", "yn", "i", "p", "dy", "vy", "b", "cy", "j", "yr", "z", "ay", "sy", "t", "ery", "u", "ym", "sky", "ady", "ry", "w", "height", "ty", "yt", "Y", "py", "oy"]}}
{"project": "FFmpeg", "commit_id": "5c2fb561d94fc51d76ab21d6f7cc5b6cc3aa599c", "target": 0, "func": "static int h264_decode_frame(AVCodecContext *avctx, void *data,\n\n                             int *got_frame, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    H264Context *h     = avctx->priv_data;\n\n    AVFrame *pict      = data;\n\n    int buf_index      = 0;\n\n    int ret;\n\n    const uint8_t *new_extradata;\n\n    int new_extradata_size;\n\n\n\n    h->flags = avctx->flags;\n\n    h->setup_finished = 0;\n\n\n\n    /* end of stream, output what is still in the buffers */\n\nout:\n\n    if (buf_size == 0) {\n\n        H264Picture *out;\n\n        int i, out_idx;\n\n\n\n        h->cur_pic_ptr = NULL;\n\n\n\n        // FIXME factorize this with the output code below\n\n        out     = h->delayed_pic[0];\n\n        out_idx = 0;\n\n        for (i = 1;\n\n             h->delayed_pic[i] &&\n\n             !h->delayed_pic[i]->f->key_frame &&\n\n             !h->delayed_pic[i]->mmco_reset;\n\n             i++)\n\n            if (h->delayed_pic[i]->poc < out->poc) {\n\n                out     = h->delayed_pic[i];\n\n                out_idx = i;\n\n            }\n\n\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n\n\n        if (out) {\n\n            ret = output_frame(h, pict, out->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n\n\n        return buf_index;\n\n    }\n\n\n\n    new_extradata_size = 0;\n\n    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,\n\n                                            &new_extradata_size);\n\n    if (new_extradata_size > 0 && new_extradata) {\n\n        ret = ff_h264_decode_extradata(new_extradata, new_extradata_size,\n\n                                       &h->ps, &h->is_avc, &h->nal_length_size,\n\n                                       avctx->err_recognition, avctx);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    buf_index = decode_nal_units(h, buf, buf_size);\n\n    if (buf_index < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n\n        buf_size = 0;\n\n        goto out;\n\n    }\n\n\n\n    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF)\n\n            return 0;\n\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) ||\n\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n\n        if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)\n\n            decode_postinit(h, 1);\n\n\n\n        ff_h264_field_end(h, &h->slice_ctx[0], 0);\n\n\n\n        *got_frame = 0;\n\n        if (h->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) ||\n\n                                   h->next_output_pic->recovered)) {\n\n            if (!h->next_output_pic->recovered)\n\n                h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT;\n\n\n\n            ret = output_frame(h, pict, h->next_output_pic->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n    }\n\n\n\n    assert(pict->buf[0] || !*got_frame);\n\n\n\n    return get_consumed_bytes(buf_index, buf_size);\n\n}\n", "idx": 10554, "substitutes": {"avctx": ["avcontext", " avctl", "evctx", "avsci", "AVctx", "avectx", "avcf", "awcu", "avecf", "aveloc", " avloc", "AVcfg", " avcontext", "avloc", "avcu", "afcf", "afconn", "avesci", "afsci", "AVcn", "afloc", "awcontext", "evcf", " avconn", "evcontext", "avecontext", " avsci", "afcu", "afcfg", "awcn", "awctx", "AVcontext", "awcfg", "avcn", "avectl", " avcf", "afctl", "avconn", "evconn", "afctx", "afcn", "AVcu", "avctl", "avcfg", "afcontext"], "data": ["dat", "message", "block", "empty", "size", "f", "Data", "api", "proc", "connection", "result", "media", "a", "DATA", "new", "config", "p", "response", "input", "content", "qa", "load", "img", "frame", "context", "feed", "fat", "memory", "in", "tmp", "code", "image", "parent", "client", "header", "reader", "channel", "da", "val", "picture", "next", "buff", "head", "capt", "buffer", "body", "video", "batch", "window", "slice", "cache"], "got_frame": ["got_iframe", "gotoffsample", "getting__frame", "getting_iframe", "getting__frames", "got___sample", "got_value", "getting_sample", "gotqframe", "getting__iframe", "got__sample", "got_frames", "got__frame", "gotqsample", "get_value", "get_frame", "got___frames", "got_sample", "got___value", "getting_frame", "gotqframes", "get_frames", "got__frames", "gotoffframes", "got__iframe", "gotoffvalue", "gotoffframe", "getting__sample", "get_sample", "gotqiframe", "got___frame", "getting_frames"], "avpkt": ["avpeacket", "avcpacket", "avjpkt", " avpait", "abpsth", "avnput", "avfkn", "avfput", " avfpait", "avpct", "avpekt", "navpecht", "avcpkt", "avtpait", "avcpcht", "afpkt", "avjpsth", "afcelt", "avjpacket", "avtpet", "avnpelt", "avspelt", " avpet", "avspct", "avwpsth", "navpeacket", "avfpet", "abpkt", "avput", "avcpk", "avspkt", "navpacket", "avfpait", "abfkt", "afcct", "avnpkt", "avfsth", "avccht", " avfput", "avnpet", "avpait", "navpek", "avfkt", "abfsth", "avnpait", "abfacket", "abpacket", "avpcht", " avfpkt", "abpkn", "afpelt", "avfacket", "avck", "avnpdt", "avcelt", "avfpkt", "afpdt", "avpsth", "avpecht", "avnpct", "avcct", " avput", "avckt", "avpacket", "avwpkt", "avspdt", "afpct", "afcdt", "abfkn", "navpcht", "navpk", "avtpkt", "avpet", "avjpkn", "avpk", "navpekt", "afckt", "avcacket", "navpkt", "avpelt", "avpek", "avwpacket", "avwpkn", "avtput", " avfpet", "avpdt", "avpkn", "avcdt"], "buf": ["cas", "ph", "block", "pool", "proc", "seq", "box", "conv", "config", "cat", "cb", "fb", "queue", "img", "rb", "fp", "cv", "tmp", "alloc", "Buffer", "uf", "cmd", "cf", "buff", "buffer", "uc", "batch", "cache"], "h": ["g", "ph", "adh", "hd", "H", "hw", "ctx", "f", "hr", "beh", "um", "host", "th", "oh", "home", "self", "y", "c", "hu", "en", "help", "d", "auth", "p", "ha", "http", "sh", "gh", "uh", "b", "hy", "work", "ah", "bh", "hp", "zh", "j", "hh", "ht", "him", "hi", "hs", "v", "image", "ch", "ich", "hub", "header", "t", "handler", "ih", "l", "he", "q", "hl", "u", "w", "m", "dh", "n", "this", "eh", "rh", "hash", "hal", "han", "kh", "hm"], "pict": ["ctx", "pai", "path", "fi", "proc", "mat", "stat", " pic", "config", "cat", "p", "qa", "dq", "img", "doc", "fig", "pic", "ct", "mot", "avi", "fat", "fa", "cli", "tmp", "fp", "image", "ch", "gui", "picture", "def", "conn", "buff", "capt", "obj", "init", "fw", "photo", "fin", "pty", "txt", "feat", "pid"], "ret": ["rt", "re", "RET", "ref", "class", "success", "rc", "red", "mem", "pet", "arg", "msg", "nt", "alt", "Ret", "feat", "pass", "rets", "id", "rev", "result", "db", "sr", "cat", "back", "rl", "rf", "lit", "flag", "run", "mt", "code", "active", "num", "fail", "bin", "error", "det", "base", "reg", "res", "usr", "att", "resp", "len", "en", " RET", "fun", "part", "std", "last", "reply", "value", "fin", "count", "post", "no", "match", "ft", "nb", "url", "bit", "rb", "gt", "val", "def", "obj", "pret", "bf", "let"], "new_extradata": ["new_extradade", "new_extradATA", "new_externalradATA", "new_extratata", "new_extrafata", "new_extadta", "new_extpartata", "new_extrastta", "new_externaladaton", "new_extvardica", "new_externalradica", "new_extracata", "new_extradoint", "new_extracica", "new_externaladada", "new_externalpartada", "new_extarcATA", "new_extrafta", "new_extvardaton", "new_extratada", "new_extradta", "new_extpartATA", "new_extvardada", "new_extadATA", "new_extadata", "new_extracaton", "new_externalradada", "new_externaladata", "new_externaladade", "new_extradada", "new_extadada", "new_extadade", "new_externalradade", "new_extradaton", "new_extadoint", "new_extrataton", "new_extarcoint", "new_extrastada", "new_externalradata", "new_extarcada", "new_externalpartata", "new_extrafade", "new_externalradaton", "new_externalradta", "new_extrafada", "new_externaladica", "new_extarcata", "new_externaladta", "new_extpartada", "new_extrastata", "new_externalpartATA", "new_extrastaton", "new_externalradoint", "new_extracada", "new_extvardata", "new_extadica", "new_extpartoint", "new_extadaton", "new_extrafaton", "new_externalpartoint", "new_extratade", "new_extradica"], "new_extradata_size": ["new_extradada_small", "new_extradata_number", "new_extradada_capacity", "new_extradata_small", "new_extradada_Size", "new_extradada_address", "new_extradata_Size", "new_extradada_scale", "new_extradada_number", "new_extradada_name", "new_extradata_capacity", "new_extradada_size", "new_extradata_name", "new_extradata_address", "new_extradata_scale"], "out": ["at", "err", "connection", "option", "c", "write", "a", "b", "cmd", "dot", "hard", "w", "init", "raw", " in", "OUT", "update", "home", "conv", "user", "off", "cat", "after", "img", "test", "flat", "parent", "copy", "o", "error", "call", "conn", "str", "prefix", "f", "format", "plain", "config", "step", "again", "qa", "part", "in", "v", "picture", "point", "sync", "u", "lib", "name", "x", "g", "timeout", "path", "proc", "output", "wx", "cache", "outer", "new", "cgi", "p", "input", "net", "inner", "io", "ext", "yout", "loop", "tmp", "image", "client", "inc", "opt", "m", "obj", "n", "batch", "Out"], "i": ["ii", "idi", "g", "ni", "abi", "li", "uri", "hi", "f", "id", "phi", "I", "api", "ip", "oi", "mi", "fi", "chi", "y", "c", "yi", "ki", "iu", "a", "ini", "d", "multi", "ji", "p", "ri", "slice", "si", "pi", "io", "inner", "j", "ori", "gi", "ie", "cli", "in", "xi", "di", "bi", "zi", "ti", "qi", "o", "ui", "l", "ci", "u", "index", "e", "init", "info", "my", "ai", "lc", "eni", "mini", "name", "x", "ix", "it"], "out_idx": ["out__idex", "out_inb", "outxindb", "out_indx", "out_indw", "out_ideX", "out_indc", "out_idX", "out_idr", "outxidp", "out_indb", "out_idv", "out_idxc", "out_ridxe", "out__idc", "outxidx", "out_idp", "outxindx", "out_idw", "out__inv", "out_inxc", "out__idx", "out_inp", "out__inx", "out_ider", "out_idxe", "out_idex", "out_ridx", "out_endy", "outxidxc", "out_idc", "out__inc", "out_indv", "out_endx", "outxindp", "out_endX", "out_endxe", "out_ridex", "out_idew", "outxidb", "out__idv", "out_indX", "out_idy", "out_idb", "out_ridc", "out_ridy", "out_inex", "out_ridX", "out_inc", "out_indp", "out_inx", "out_ridv", "out_inv", "out_index", "out_indr", "out_indxc", "outxindxc", "out__inex"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline int16_t calc_lowcomp(int16_t a, int16_t b0, int16_t b1, uint8_t bin)\n\n{\n\n    if (bin < 7) {\n\n        if ((b0 + 256) == b1)\n\n            a = 384;\n\n        else if (b0 > b1)\n\n            a = FFMAX(0, a - 64);\n\n    }\n\n    else if (bin < 20) {\n\n        if ((b0 + 256) == b1)\n\n            a = 320;\n\n        else if (b0 > b1)\n\n            a = FFMAX(0, a - 64);\n\n    }\n\n    else {\n\n        a = FFMAX(0, a - 128);\n\n    }\n\n\n\n    return a;\n\n}\n", "idx": 10556, "substitutes": {"a": ["la", "ga", "ata", "valid", "f", "va", "api", "ada", "acha", "aux", "ea", "na", "audio", "alpha", "ma", "y", "c", "ca", "xa", "au", "ae", "aa", "an", "sup", "d", "i", "p", "ha", "sta", "b", "qa", "asa", "ar", "missing", "A", "array", "fa", "address", "ia", "ac", "sha", "z", "active", "ama", "access", "aw", "af", "area", "da", "l", "am", "mac", "u", "index", "ab", "as", "wa", "pa", "e", "ai", "tta", "sa", "ad", "aaa", "data", "aj", "x", "ba"], "b0": ["f00", "b2", "body1", "body2", "sb1", "base2", "v93", "f90", "v1", "p00", " b00", "f80", "base0", "base80", "v0", "bc90", "bodydb", "b6", " bale", "v00", "bcale", "f0", "base1", "b93", " b90", "p2", " b6", "B00", "b90", "bc0", "fale", "sb0", "bc1", "f2", "p1", "p80", "f93", "fdb", "b80", "body0", "B6", "bdb", "pdb", "p6", "f1", "sb93", "B2", "bale", "p0", " b2", "sb00", "b00", "B0"], "b1": ["body1", "b2", "b8", "a7", "body7", " b100", "l2", "f6", "l11", " b7", " b8", " bb", "b7", "b6", "f0", "body100", "a0", "l8", "a1", "a8", " b6", "f8", "f2", "b11", "f11", "a100", "f100", "bb", "a2", " b2", "b100", "ab", "bodyb", "f1", "l0", "a6", " b11", "l1"], "bin": ["binary", "g", "abi", "big", "version", "gap", "block", "abc", "bis", "bn", "bool", "bc", "byte", "len", "c", "pc", "i", "ben", "off", "bar", "scan", "b", "ban", "gen", "bit", "part", "in", "bot", "ac", "bi", "nan", "num", "magic", "pin", "count", "spin", "win", "lib", "index", "border", "nn", "base", "bits", "bas", "batch", "ping", "data", "depth", "ix"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,\n\n                                      long width, long height,\n\n                                      long lumStride, long chromStride, long srcStride)\n\n{\n\n    long y;\n\n    const x86_reg chromWidth= width>>1;\n\n    for (y=0; y<height; y+=2) {\n\n#if COMPILE_TEMPLATE_MMX\n\n        __asm__ volatile(\n\n            \"xor                 %%\"REG_a\", %%\"REG_a\"   \\n\\t\"\n\n            \"pcmpeqw                 %%mm7, %%mm7       \\n\\t\"\n\n            \"psrlw                      $8, %%mm7       \\n\\t\" // FF,00,FF,00...\n\n            \".p2align                    4              \\n\\t\"\n\n            \"1:                \\n\\t\"\n\n            PREFETCH\" 64(%0, %%\"REG_a\", 4)              \\n\\t\"\n\n            \"movq       (%0, %%\"REG_a\", 4), %%mm0       \\n\\t\" // YUYV YUYV(0)\n\n            \"movq      8(%0, %%\"REG_a\", 4), %%mm1       \\n\\t\" // YUYV YUYV(4)\n\n            \"movq                    %%mm0, %%mm2       \\n\\t\" // YUYV YUYV(0)\n\n            \"movq                    %%mm1, %%mm3       \\n\\t\" // YUYV YUYV(4)\n\n            \"psrlw                      $8, %%mm0       \\n\\t\" // U0V0 U0V0(0)\n\n            \"psrlw                      $8, %%mm1       \\n\\t\" // U0V0 U0V0(4)\n\n            \"pand                    %%mm7, %%mm2       \\n\\t\" // Y0Y0 Y0Y0(0)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // Y0Y0 Y0Y0(4)\n\n            \"packuswb                %%mm1, %%mm0       \\n\\t\" // UVUV UVUV(0)\n\n            \"packuswb                %%mm3, %%mm2       \\n\\t\" // YYYY YYYY(0)\n\n\n\n            MOVNTQ\"                  %%mm2, (%1, %%\"REG_a\", 2)  \\n\\t\"\n\n\n\n            \"movq     16(%0, %%\"REG_a\", 4), %%mm1       \\n\\t\" // YUYV YUYV(8)\n\n            \"movq     24(%0, %%\"REG_a\", 4), %%mm2       \\n\\t\" // YUYV YUYV(12)\n\n            \"movq                    %%mm1, %%mm3       \\n\\t\" // YUYV YUYV(8)\n\n            \"movq                    %%mm2, %%mm4       \\n\\t\" // YUYV YUYV(12)\n\n            \"psrlw                      $8, %%mm1       \\n\\t\" // U0V0 U0V0(8)\n\n            \"psrlw                      $8, %%mm2       \\n\\t\" // U0V0 U0V0(12)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // Y0Y0 Y0Y0(8)\n\n            \"pand                    %%mm7, %%mm4       \\n\\t\" // Y0Y0 Y0Y0(12)\n\n            \"packuswb                %%mm2, %%mm1       \\n\\t\" // UVUV UVUV(8)\n\n            \"packuswb                %%mm4, %%mm3       \\n\\t\" // YYYY YYYY(8)\n\n\n\n            MOVNTQ\"                  %%mm3, 8(%1, %%\"REG_a\", 2) \\n\\t\"\n\n\n\n            \"movq                    %%mm0, %%mm2       \\n\\t\" // UVUV UVUV(0)\n\n            \"movq                    %%mm1, %%mm3       \\n\\t\" // UVUV UVUV(8)\n\n            \"psrlw                      $8, %%mm0       \\n\\t\" // V0V0 V0V0(0)\n\n            \"psrlw                      $8, %%mm1       \\n\\t\" // V0V0 V0V0(8)\n\n            \"pand                    %%mm7, %%mm2       \\n\\t\" // U0U0 U0U0(0)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // U0U0 U0U0(8)\n\n            \"packuswb                %%mm1, %%mm0       \\n\\t\" // VVVV VVVV(0)\n\n            \"packuswb                %%mm3, %%mm2       \\n\\t\" // UUUU UUUU(0)\n\n\n\n            MOVNTQ\"                  %%mm0, (%3, %%\"REG_a\")     \\n\\t\"\n\n            MOVNTQ\"                  %%mm2, (%2, %%\"REG_a\")     \\n\\t\"\n\n\n\n            \"add                        $8, %%\"REG_a\"   \\n\\t\"\n\n            \"cmp                        %4, %%\"REG_a\"   \\n\\t\"\n\n            \" jb                        1b              \\n\\t\"\n\n            ::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" (chromWidth)\n\n            : \"memory\", \"%\"REG_a\n\n        );\n\n\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n\n\n        __asm__ volatile(\n\n            \"xor                 %%\"REG_a\", %%\"REG_a\"   \\n\\t\"\n\n            \".p2align                    4              \\n\\t\"\n\n            \"1:                                         \\n\\t\"\n\n            PREFETCH\" 64(%0, %%\"REG_a\", 4)              \\n\\t\"\n\n            \"movq       (%0, %%\"REG_a\", 4), %%mm0       \\n\\t\" // YUYV YUYV(0)\n\n            \"movq      8(%0, %%\"REG_a\", 4), %%mm1       \\n\\t\" // YUYV YUYV(4)\n\n            \"movq     16(%0, %%\"REG_a\", 4), %%mm2       \\n\\t\" // YUYV YUYV(8)\n\n            \"movq     24(%0, %%\"REG_a\", 4), %%mm3       \\n\\t\" // YUYV YUYV(12)\n\n            \"pand                    %%mm7, %%mm0       \\n\\t\" // Y0Y0 Y0Y0(0)\n\n            \"pand                    %%mm7, %%mm1       \\n\\t\" // Y0Y0 Y0Y0(4)\n\n            \"pand                    %%mm7, %%mm2       \\n\\t\" // Y0Y0 Y0Y0(8)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // Y0Y0 Y0Y0(12)\n\n            \"packuswb                %%mm1, %%mm0       \\n\\t\" // YYYY YYYY(0)\n\n            \"packuswb                %%mm3, %%mm2       \\n\\t\" // YYYY YYYY(8)\n\n\n\n            MOVNTQ\"                  %%mm0,  (%1, %%\"REG_a\", 2) \\n\\t\"\n\n            MOVNTQ\"                  %%mm2, 8(%1, %%\"REG_a\", 2) \\n\\t\"\n\n\n\n            \"add                        $8, %%\"REG_a\"   \\n\\t\"\n\n            \"cmp                        %4, %%\"REG_a\"   \\n\\t\"\n\n            \" jb                        1b              \\n\\t\"\n\n\n\n            ::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" (chromWidth)\n\n            : \"memory\", \"%\"REG_a\n\n        );\n\n#else\n\n        long i;\n\n        for (i=0; i<chromWidth; i++) {\n\n            ydst[2*i+0]     = src[4*i+0];\n\n            udst[i]     = src[4*i+1];\n\n            ydst[2*i+1]     = src[4*i+2];\n\n            vdst[i]     = src[4*i+3];\n\n        }\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n\n\n        for (i=0; i<chromWidth; i++) {\n\n            ydst[2*i+0]     = src[4*i+0];\n\n            ydst[2*i+1]     = src[4*i+2];\n\n        }\n\n#endif\n\n        udst += chromStride;\n\n        vdst += chromStride;\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n    }\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(EMMS\"       \\n\\t\"\n\n                     SFENCE\"     \\n\\t\"\n\n                     :::\"memory\");\n\n#endif\n\n}\n", "idx": 10564, "substitutes": {"src": ["rect", "sur", "jpg", "sil", "scl", "dest", "ctx", "cdn", "href", "wx", "sel", "rob", "sq", "stat", "dist", "sr", "sb", "rc", "config", "cur", "sci", "rl", "loc", "gl", "gz", "ssl", "obl", "filename", "img", "url", "gb", "sl", "rb", "sound", "iv", "ruby", "gal", "tmp", "chrom", "source", "sc", "sync", "lib", "sys", "rs", "sec", "lore", "stream", "rib", "inst"], "ydst": ["dyast", "ydST", "isdSt", "hdest", "hdirst", "isdest", "iddSt", "dycr", "hdast", "isdst", "ydste", "hdcr", "ydost", "isdste", "ydest", "dyest", "ydSt", "ydenSt", "ydenstr", "isdstr", "iddstr", "isdST", "dyirst", "isdcr", "iddST", "dxirst", "ydcr", "dyst", "dxst", "dxost", "ydenst", "ydirst", "dxast", "hdste", "dyste", "hdost", "ydenST", "ydstr", "iddst", "dyost", "ydast", "hdst"], "udst": ["ddost", "uddST", "UDst", "ddest", "ddST", "ddst", "udstr", "uddst", "uddost", "ddstr", "udest", "UDest", "UDST", "udost", "udST", "ddend", "vdest", "vdost", "vdST", "vdstr", "uddstr", "udend", "UDend", "vdend"], "vdst": ["hdest", "fdst", "xdost", "xdst", "udstr", "udest", "fdstr", "udost", "udST", "vdest", "vdost", "vdST", "xdest", "hdstr", "vdstr", "hdost", "fdest", "xdST", "fdost", "hdST", "hdst"], "height": ["padding", "gap", "thin", "layout", "max", "th", "quality", "resolution", "alpha", "png", "d", "above", "h", "dy", "shape", "bottom", "density", "crop", "length", "level", "deep", "def", "dim", "w", "ty", "hang", "fw", "top", "pull", "window", "depth", "Height", "x", "build"], "lumStride": ["lUMConstride", "lumStoreride", "lUMStro", "lumSTrue", "lumStide", "lumStorerue", "lumRestread", "lumScrue", "lumbStide", "lumScride", "lumSTride", "lumstread", "lumbScride", "lumConstrict", "lUMStrict", "lumSTube", "lumStoreube", "lumstrict", "lumSTide", "lumRestro", "lumstride", "lUMConstro", "lUMConstread", "lumbStrue", "lumStrue", "lumConstride", "lumStrict", "lumbScrue", "lumConstread", "lumbStride", "lumConstro", "lUMConstrict", "lumRestride", "lumbStube", "lumStube", "lumStread", "lUMStride", "lumbScube", "lUMStread", "lumStoreide", "lumRestrict", "lumStro", "lumbScide", "lumScube", "lumScide", "lumstro"], "chromStride": ["romSterve", "chromEsterve", "romRestrue", "chromResterve", "chromRestrue", "chromDisterve", "chromRestride", "chromStrub", "romResterve", "chromStrue", "chromEstride", "chromRestrub", "chromEstrue", "chromDistride", "chromEstrub", "romStrub", "romRestride", "romStride", "romRestrub", "chromDistrub", "chromSterve", "chromDistrue", "romStrue"], "srcStride": ["srcSterve", "usrStsync", "srcDesclock", "usrEstri", "usrStlock", "usrStri", "srcStrerve", "srcStackride", "srcStrrite", "sourceStride", "srcStri", "srcStsync", "srcDescsync", "srcStrride", "srcStackrite", "srcSTri", "srcStlock", "srcEstlock", "srcEstride", "srcStackipe", "usrEstlock", "usrEstsync", "srcSTride", "usrEstride", "srcStackerve", "srcDescride", "srcEstsync", "srcEstri", "srcDescri", "sourceSterve", "srcStrite", "srcStripe", "srcSTlock", "srcStipe", "sourceStipe", "usrStride", "srcSTsync", "sourceStrite"], "y": ["zy", "ey", "yd", "wy", "yy", "yo", "ky", "ny", "ys", "ya", "c", "yi", "xy", "yn", "d", "h", "dy", "p", "hy", "vy", "cy", "year", "j", "yr", "z", "ye", "ay", "sy", "t", "ym", "ady", "ry", "w", "ty", "col", "yt", "yl", "n", "Y", "lon", "py", "oy", "x"]}}
{"project": "qemu", "commit_id": "2119882c7eb7e2c612b24fc0c8d86f5887d6f1c3", "target": 0, "func": "static BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *node,\n\n                                                  const char *name,\n\n                                                  BlockDriverState **pbs,\n\n                                                  AioContext **paio,\n\n                                                  Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BdrvDirtyBitmap *bitmap;\n\n    AioContext *aio_context;\n\n\n\n    if (!node) {\n\n        error_setg(errp, \"Node cannot be NULL\");\n\n        return NULL;\n\n    }\n\n    if (!name) {\n\n        error_setg(errp, \"Bitmap name cannot be NULL\");\n\n        return NULL;\n\n    }\n\n    bs = bdrv_lookup_bs(node, node, NULL);\n\n    if (!bs) {\n\n        error_setg(errp, \"Node '%s' not found\", node);\n\n        return NULL;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    bitmap = bdrv_find_dirty_bitmap(bs, name);\n\n    if (!bitmap) {\n\n        error_setg(errp, \"Dirty bitmap '%s' not found\", name);\n\n        goto fail;\n\n    }\n\n\n\n    if (pbs) {\n\n        *pbs = bs;\n\n    }\n\n    if (paio) {\n\n        *paio = aio_context;\n\n    } else {\n\n        aio_context_release(aio_context);\n\n    }\n\n\n\n    return bitmap;\n\n\n\n fail:\n\n    aio_context_release(aio_context);\n\n    return NULL;\n\n}\n", "idx": 10583, "substitutes": {"node": ["remote", "message", "uri", "fn", "block", "no", "ctx", "prefix", "empty", "id", "src", "callback", "local", "path", "NAME", "cdn", "file", "ip", "comment", "host", "anc", "Node", "network", "route", "instance", "master", "new", "config", "document", "content", "nil", "primary", "loc", "core", "address", "android", "package", "native", "image", "parent", "num", "source", "odes", "word", "od", "nn", "ast", "n", "child", "one", "null", "root", "none", "object", "cache"], "name": ["ni", "prefix", "text", "block", "no", "size", "type", "fn", "file", "on", "comment", "NAME", "path", "Name", "self", "na", "label", "new", "names", "create", "filename", "title", "part", "missing", "key", "address", "code", "package", "image", "parent", "client", "time", "word", "call", "common", "sn", "alias", "base", "n", "child", "unknown", "one", "s", "root", "none", "python", "nam", "number", "x", "named", "nm"], "pbs": ["PBS", "pbes", "Pbs", "pds", "pasts", " pbc", " pcs", "cds", " pgb", "mbs", "Pbc", "Pcs", "bbs", "pps", "bps", "pcs", "pgb", "mds", " pbl", "Pps", " pds", " pBS", "pbl", " pasts", "Pbes", "bbes", "cbl", "cbs", "pBS", " pbes", "casts", "cbc", "pbc", " pps", "mbl", "masts", "cBS", "bgb", "Pgb", "ccs"], "paio": ["colo", "orc", "apache", "ione", "arin", "amba", "pai", "ocobo", "vale", "iott", "oga", "ppa", "ello", "ski", "smart", "oji", "aic", "ppo", "maxwell", "aco", "olulu", "aaa", "dog", "cone", "lli", "doctor", "qua", "ori", "aho", "police", "pic", "ampa", "tmp", "tti", "enforcement", "abba", "apple", " Arpaio", "abo", "rog", "acc", "ardo", "arf", "iov", "dogs", "jj", "tta", "cro", "cca", "inos", "uno", "opa"], "errp": ["rrp", "erpr", " erb", "nerb", "rrb", "err", "armb", "erfp", "iterfp", "errP", "ErP", "errr", "errpr", "nerg", "errfp", "nerp", "errf", "Err", "armg", "iterb", "errb", "rf", "armp", " errf", "errg", " erpr", "armf", "erp", "rb", " erp", " errr", "Erb", " errfp", "nerf", " errb", "erf", "iterr", " errP", "erb", " errg", "rrr", "erP", "rr", " err", "Erp", "rrpr", "rp", "iterp"], "bs": ["bos", "als", "os", "cases", "ctx", "bis", "src", "its", "cs", "ls", "ss", "bc", "BS", "pb", "bps", "lb", "eb", "ins", "sb", "rss", "bytes", "cb", "nas", "iss", "ds", "b", "bes", "fb", "outs", "blocks", "fs", "gb", "ns", "css", "bb", "bing", "ps", "ses", "gs", "boxes", "banks", "ros", "ubs", "base", "las", "bits", "obj", "bas", "rs", "obs", "s", "null", "bid", "vs", "ba"], "bitmap": ["bitMAP", " bitmask", "bincache", "taskmask", "binMap", "byteMap", "bytemap", "bitmask", "BITmaps", "bootcache", "bootmaps", "BitMap", "bytecache", "bitcache", "bitmaps", "BITmap", " bitMap", "taskcache", " bitcache", "binmaps", "bootmask", "BitMAP", "Bitmaps", "binmap", "Bitmap", "taskmaps", "bootmap", "BITMap", "bitMap", "bytemaps", "taskmap", " bitMAP", " bitmaps", "BITMAP"], "aio_context": ["aios_config", "aio_connection", "aio2context", "aio_support", "aio2graph", "aio_graph", "aio_config", "aio_scope", "aios_graph", "aio_queue", "aio_ctx", "aio_instance", "aios_instance", "aios_scope", "aios_client", "aios_context", "aios_ctx", "aios_connection", "aio_client", "aios_support", "aio2support", "aio2instance"]}}
{"project": "qemu", "commit_id": "446f16a6906e9d05aa9ce0dde727d4f731a89298", "target": 1, "func": "void ppce500_init(MachineState *machine, PPCE500Params *params)\n\n{\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    PCIBus *pci_bus;\n\n    CPUPPCState *env = NULL;\n\n    uint64_t loadaddr;\n\n    hwaddr kernel_base = -1LL;\n\n    int kernel_size = 0;\n\n    hwaddr dt_base = 0;\n\n    hwaddr initrd_base = 0;\n\n    int initrd_size = 0;\n\n    hwaddr cur_base = 0;\n\n    char *filename;\n\n    hwaddr bios_entry = 0;\n\n    target_long bios_size;\n\n    struct boot_info *boot_info;\n\n    int dt_size;\n\n    int i;\n\n    /* irq num for pin INTA, INTB, INTC and INTD is 1, 2, 3 and\n\n     * 4 respectively */\n\n    unsigned int pci_irq_nrs[PCI_NUM_PINS] = {1, 2, 3, 4};\n\n    qemu_irq **irqs, *mpic;\n\n    DeviceState *dev;\n\n    CPUPPCState *firstenv = NULL;\n\n    MemoryRegion *ccsr_addr_space;\n\n    SysBusDevice *s;\n\n    PPCE500CCSRState *ccsr;\n\n\n\n    /* Setup CPUs */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = \"e500v2_v30\";\n\n    }\n\n\n\n    irqs = g_malloc0(smp_cpus * sizeof(qemu_irq *));\n\n    irqs[0] = g_malloc0(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        PowerPCCPU *cpu;\n\n        CPUState *cs;\n\n        qemu_irq *input;\n\n\n\n        cpu = cpu_ppc_init(machine->cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n        cs = CPU(cpu);\n\n\n\n        if (!firstenv) {\n\n            firstenv = env;\n\n        }\n\n\n\n        irqs[i] = irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n        input = (qemu_irq *)env->irq_inputs;\n\n        irqs[i][OPENPIC_OUTPUT_INT] = input[PPCE500_INPUT_INT];\n\n        irqs[i][OPENPIC_OUTPUT_CINT] = input[PPCE500_INPUT_CINT];\n\n        env->spr_cb[SPR_BOOKE_PIR].default_value = cs->cpu_index = i;\n\n        env->mpic_iack = params->ccsrbar_base +\n\n                         MPC8544_MPIC_REGS_OFFSET + 0xa0;\n\n\n\n        ppc_booke_timers_init(cpu, 400000000, PPC_TIMER_E500);\n\n\n\n        /* Register reset handler */\n\n        if (!i) {\n\n            /* Primary CPU */\n\n            struct boot_info *boot_info;\n\n            boot_info = g_malloc0(sizeof(struct boot_info));\n\n            qemu_register_reset(ppce500_cpu_reset, cpu);\n\n            env->load_info = boot_info;\n\n        } else {\n\n            /* Secondary CPUs */\n\n            qemu_register_reset(ppce500_cpu_reset_sec, cpu);\n\n        }\n\n    }\n\n\n\n    env = firstenv;\n\n\n\n    /* Fixup Memory size on a alignment boundary */\n\n    ram_size &= ~(RAM_SIZES_ALIGN - 1);\n\n    machine->ram_size = ram_size;\n\n\n\n    /* Register Memory */\n\n    memory_region_allocate_system_memory(ram, NULL, \"mpc8544ds.ram\", ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n\n\n    dev = qdev_create(NULL, \"e500-ccsr\");\n\n    object_property_add_child(qdev_get_machine(), \"e500-ccsr\",\n\n                              OBJECT(dev), NULL);\n\n    qdev_init_nofail(dev);\n\n    ccsr = CCSR(dev);\n\n    ccsr_addr_space = &ccsr->ccsr_space;\n\n    memory_region_add_subregion(address_space_mem, params->ccsrbar_base,\n\n                                ccsr_addr_space);\n\n\n\n    mpic = ppce500_init_mpic(params, ccsr_addr_space, irqs);\n\n\n\n    /* Serial */\n\n    if (serial_hds[0]) {\n\n        serial_mm_init(ccsr_addr_space, MPC8544_SERIAL0_REGS_OFFSET,\n\n                       0, mpic[42], 399193,\n\n                       serial_hds[0], DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    if (serial_hds[1]) {\n\n        serial_mm_init(ccsr_addr_space, MPC8544_SERIAL1_REGS_OFFSET,\n\n                       0, mpic[42], 399193,\n\n                       serial_hds[1], DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    /* General Utility device */\n\n    dev = qdev_create(NULL, \"mpc8544-guts\");\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    memory_region_add_subregion(ccsr_addr_space, MPC8544_UTIL_OFFSET,\n\n                                sysbus_mmio_get_region(s, 0));\n\n\n\n    /* PCI */\n\n    dev = qdev_create(NULL, \"e500-pcihost\");\n\n    qdev_prop_set_uint32(dev, \"first_slot\", params->pci_first_slot);\n\n    qdev_prop_set_uint32(dev, \"first_pin_irq\", pci_irq_nrs[0]);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    for (i = 0; i < PCI_NUM_PINS; i++) {\n\n        sysbus_connect_irq(s, i, mpic[pci_irq_nrs[i]]);\n\n    }\n\n\n\n    memory_region_add_subregion(ccsr_addr_space, MPC8544_PCI_REGS_OFFSET,\n\n                                sysbus_mmio_get_region(s, 0));\n\n\n\n    pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (!pci_bus)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    if (pci_bus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            pci_nic_init_nofail(&nd_table[i], pci_bus, \"virtio\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Register spinning region */\n\n    sysbus_create_simple(\"e500-spin\", params->spin_base, NULL);\n\n\n\n    if (cur_base < (32 * 1024 * 1024)) {\n\n        /* u-boot occupies memory up to 32MB, so load blobs above */\n\n        cur_base = (32 * 1024 * 1024);\n\n    }\n\n\n\n    if (params->has_mpc8xxx_gpio) {\n\n        qemu_irq poweroff_irq;\n\n\n\n        dev = qdev_create(NULL, \"mpc8xxx_gpio\");\n\n        s = SYS_BUS_DEVICE(dev);\n\n        qdev_init_nofail(dev);\n\n        sysbus_connect_irq(s, 0, mpic[MPC8XXX_GPIO_IRQ]);\n\n        memory_region_add_subregion(ccsr_addr_space, MPC8XXX_GPIO_OFFSET,\n\n                                    sysbus_mmio_get_region(s, 0));\n\n\n\n        /* Power Off GPIO at Pin 0 */\n\n        poweroff_irq = qemu_allocate_irq(ppce500_power_off, NULL, 0);\n\n        qdev_connect_gpio_out(dev, 0, poweroff_irq);\n\n    }\n\n\n\n    /* Platform Bus Device */\n\n    if (params->has_platform_bus) {\n\n        dev = qdev_create(NULL, TYPE_PLATFORM_BUS_DEVICE);\n\n        dev->id = TYPE_PLATFORM_BUS_DEVICE;\n\n        qdev_prop_set_uint32(dev, \"num_irqs\", params->platform_bus_num_irqs);\n\n        qdev_prop_set_uint32(dev, \"mmio_size\", params->platform_bus_size);\n\n        qdev_init_nofail(dev);\n\n        s = SYS_BUS_DEVICE(dev);\n\n\n\n        for (i = 0; i < params->platform_bus_num_irqs; i++) {\n\n            int irqn = params->platform_bus_first_irq + i;\n\n            sysbus_connect_irq(s, i, mpic[irqn]);\n\n        }\n\n\n\n        memory_region_add_subregion(address_space_mem,\n\n                                    params->platform_bus_base,\n\n                                    sysbus_mmio_get_region(s, 0));\n\n    }\n\n\n\n    /* Load kernel. */\n\n    if (machine->kernel_filename) {\n\n        kernel_base = cur_base;\n\n        kernel_size = load_image_targphys(machine->kernel_filename,\n\n                                          cur_base,\n\n                                          ram_size - cur_base);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    machine->kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        cur_base += kernel_size;\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (machine->initrd_filename) {\n\n        initrd_base = (cur_base + INITRD_LOAD_PAD) & ~INITRD_PAD_MASK;\n\n        initrd_size = load_image_targphys(machine->initrd_filename, initrd_base,\n\n                                          ram_size - initrd_base);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    machine->initrd_filename);\n\n            exit(1);\n\n        }\n\n\n\n        cur_base = initrd_base + initrd_size;\n\n    }\n\n\n\n    /*\n\n     * Smart firmware defaults ahead!\n\n     *\n\n     * We follow the following table to select which payload we execute.\n\n     *\n\n     *  -kernel | -bios | payload\n\n     * ---------+-------+---------\n\n     *     N    |   Y   | u-boot\n\n     *     N    |   N   | u-boot\n\n     *     Y    |   Y   | u-boot\n\n     *     Y    |   N   | kernel\n\n     *\n\n     * This ensures backwards compatibility with how we used to expose\n\n     * -kernel to users but allows them to run through u-boot as well.\n\n     */\n\n    if (bios_name == NULL) {\n\n        if (machine->kernel_filename) {\n\n            bios_name = machine->kernel_filename;\n\n        } else {\n\n            bios_name = \"u-boot.e500\";\n\n        }\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    bios_size = load_elf(filename, NULL, NULL, &bios_entry, &loadaddr, NULL,\n\n                         1, ELF_MACHINE, 0);\n\n    if (bios_size < 0) {\n\n        /*\n\n         * Hrm. No ELF image? Try a uImage, maybe someone is giving us an\n\n         * ePAPR compliant kernel\n\n         */\n\n        kernel_size = load_uimage(filename, &bios_entry, &loadaddr, NULL,\n\n                                  NULL, NULL);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load firmware '%s'\\n\", filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Reserve space for dtb */\n\n    dt_base = (loadaddr + bios_size + DTC_LOAD_PAD) & ~DTC_PAD_MASK;\n\n\n\n    dt_size = ppce500_prep_device_tree(machine, params, dt_base,\n\n                                       initrd_base, initrd_size,\n\n                                       kernel_base, kernel_size);\n\n    if (dt_size < 0) {\n\n        fprintf(stderr, \"couldn't load device tree\\n\");\n\n        exit(1);\n\n    }\n\n    assert(dt_size < DTB_MAX_SIZE);\n\n\n\n    boot_info = env->load_info;\n\n    boot_info->entry = bios_entry;\n\n    boot_info->dt_base = dt_base;\n\n    boot_info->dt_size = dt_size;\n\n\n\n    if (kvm_enabled()) {\n\n        kvmppc_init();\n\n    }\n\n}\n", "idx": 10594, "substitutes": {"machine": ["container", "server", "plugin", "message", "loader", "mount", "mode", "device", "service", "state", "host", "proc", "mp", "connection", "engine", "controller", "module", "template", "user", "game", "instance", "computer", "node", "config", "model", "p", "Machine", "session", "boot", "database", "shell", "core", "part", "memory", "mem", "image", "vm", "motion", "mac", "m", "base", "process", "M", "mc", "manager", "processor", "object", "cache"], "params": ["param", "server", "loader", "args", "global", "pro", "proc", "master", "config", "options", "pi", "Par", "par", "image", "vm", "attr", "mac", "conn", "lib", "cam", "conf", "mm", "ams", "manager", "pty", "processor", "phys"], "address_space_mem": ["address_space_space", "address_space_memory", "address_sp_memory", "address_sp_space", "address_sp_mem"], "ram": ["RAM", "rw", "im", "mode", "path", "max", "AM", "cow", "gam", "gram", "rg", "network", "Ram", "instance", "ro", "sh", "net", "img", "cal", "gb", "image", "mem", "am", "sc", "iam", "disk", "w", "mm", "reg"], "pci_bus": ["pdi_boot", "pci_boot", "pci_BUS", "pdi_bus", "pci_def", "pdi_def", "pdi_BUS"], "env": ["oa", "et", "np", "dict", "loader", "args", "global", "ctx", "path", "anc", "err", "nc", "eng", "ea", "exc", "engine", "skin", "network", "db", "en", "vel", "qt", "eu", "node", "config", "ev", "enc", "agent", "password", "si", "iss", "vs", "scope", "Environment", "session", "net", "ah", "NV", "equ", "ext", "context", "core", "cfg", "act", "iv", "code", "viron", "v", "environment", "vm", "export", "opt", "attr", "gui", "que", "cf", "conn", "conf", "e", "profile", " environment", "ec", "eni", "energy", "ef", "dir", "exe", "pect", "cache"], "loadaddr": [" loadattr", "rollAddress", "loadmem", "loadAddress", "readmem", "readattr", "readAddress", " loadAddress", "rollmem", "rollattr", "loadattr", "readaddr", "rolladdr", " loadmem"], "filename": ["binary", "prefix", "fn", "linux", "file", "f", "src", "mode", "path", "tif", "buf", "seq", "enc", "nil", "dll", "files", "fp", "length", "word", "tty", "amd", "buffer", "unknown", "fd", "name"], "bios_size": ["bio_size", "bios__size", "bios_count", "bios__number", "bio_count", "bio_ize", "bios__ize", "bios_ize", "bios_number", "bio_number", "bios__count"], "boot_info": ["bootloginfo", "boot_system", "bootnetcount", "kernel_info", "boot_family", "kernel_limit", " boot_group", "bootnetgroup", "bootlenlimit", " boot_id", "kernellogsystem", "kernellogfamily", "bootvallimit", "boot_limit", "bootvalfamily", "bootlensystem", "bootnetid", "kernelloglimit", " boot_count", "bootlogfamily", "bootleninfo", "bootlogsystem", "kernel_system", "bootnetinfo", "kernel_family", "bootvalinfo", "boot_id", "bootvalsystem", "bootlenfamily", "boot_count", "boot_group", "bootloglimit", "kernelloginfo"], "dt_size": ["boot_sum", "boot_size", "dtlensum", "boot_length", "dtlensize", "dt_length", "boot_len", "dtlenlength", "dtlenlen", "dt_len", "dt_sum"], "i": ["ii", "ni", "li", "uri", "size", "f", "type", "id", "phi", "I", "mu", "ip", "oi", "mi", "fi", "ski", "chi", "adi", "gu", "y", "c", "yi", "ki", "iu", "is", "a", "ini", "d", "ei", "multi", "ri", "p", "si", "b", "pi", "uli", "j", "gi", "ie", "ami", "z", "in", "ti", "zi", "xi", "di", "qi", "r", "ui", "t", "v", "bi", "l", "gpu", "ci", "u", "index", "start", "ij", "e", "n", "info", "ai", "mini", "eni", "vi", "count", "x", "ix", "it"], "pci_irq_nrs": ["pci_irq_ynrs", "pci_irq_codes", "pci_irq_ynrc", "pci_irq_crc", "pci_irq_ynodes", "pci_irq_numbers", "pci_irq_cumbers", "pci_irq_crs", "pci_irq_ynumbers", "pci_irq_nrc", "pci_irq_nodes"], "irqs": ["irqi", "irsches", "rinques", "irsdq", " irches", "irqa", "irches", "Irches", "ironces", "Irquest", "rinq", "IRcles", "errq", "irquest", "IRques", " irdq", "errqu", "mirqi", "Irq", "errqi", "mirqa", "irsces", "ireq", "IRquest", "Irqs", " irq", "mirqs", "rinqs", "iperches", "irq", "Irques", "iperqs", "ironqs", "irques", "IRches", "errqs", "IRq", "mirques", "irequ", "mircles", "irondq", "irsqs", "IRprints", " irqa", "ironches", "Ircles", "mirqu", "iperq", "rincles", "IRqs", "ircles", "Irqa", " ircles", "irces", "irqu", " irprints", "ireqs", "rinprints", " irces", " irques", "mirq", "iperquest", "irprints", "ireqi", "irdq"], "mpic": ["ipia", "ipac", "mpac", "ppia", "ipic", "MPic", "MPac", "ppics", "MPia", "ppac", "MPics", "mpics", "ppic", "ipics", "mpia"], "dev": ["de", "hw", "global", "device", "ip", "ov", "gu", "ver", "pu", "node", "ev", "enc", "app", "net", "Dev", "iv", "dd", "ch", "def", "conn", "disk", "w", "conf", "data", "inst", "cache"], "firstenv": ["seconddir", "lastenv", "firstenvironment", " firstdir", " firstconfig", "secondenvironment", "Firstconfig", "firstenc", "secondconfig", "lastexc", "firstconfig", "lastenc", "secondev", " firstenvironment", "secondenc", "Firstexc", " firstexc", "secondenv", " firstev", "firstev", "Firstenv", "lastev", " firstenc", "firstdir", "secondexc", "lastenvironment", "firstexc", "Firstdir"], "ccsr_addr_space": ["ccsr_address_sp", "ccsr_addr_block", "ccsr_addrnrange", "ccsr_addr_sp", "ccsr_addr_range", "ccsr_address_space", "ccsr_address_range", "ccsr_addrnspace", "ccsr_addrnsp", "ccsr_addrnblock", "ccsr_address_block"], "s": ["server", "sym", "c", "a", "services", "d", "p", "sh", "S", "session", "scope", "fs", "ssl", "ssh", "v", "spec", "o", "ses", "sc", "sync", "w", "m", "e", "n", "port", "sa", "ops"], "ccsr": ["sctr", "ccsi", "scvr", "cftr", " ccsi", "ccvr", " ccvr", "cctr", "cfsi", "scsr", "scsi", " cctr", "cfvr", "cfsr"], "cpu": ["np", "hw", "linux", "loader", "ctx", "pai", "nic", "cow", "nc", "proc", "GPU", "c", "pc", "hu", "cmp", "computer", "instance", "pu", "node", "auc", "jp", "cgi", "kernel", "fps", "CPU", "chip", "px", "cp", "net", "runner", "hp", "cu", "uu", "core", "cli", " CPU", "mem", "vm", "que", "bench", "gpu", "conn", "pp", "ci", "chu", "uci", "cn", "process", "lc", "mc", "eni", "gc", "uno", "processor", "ilo", "performance"], "cs": ["ics", "utils", "os", "ctx", "ls", "nc", "bc", "wcs", "c", "pc", "ca", "ks", "co", "ins", "rc", "ts", "vs", "ck", "ds", "fs", "cp", "acs", "CS", "core", "cc", "ns", "spec", "css", "ras", "ps", "cf", "conn", "sc", "rs", "sk", "cons", "ec", "js", "ix", "cache"], "input": ["version", "text", "block", "ack", "request", "device", "flow", "ip", "output", "Input", "c", "instance", "cache", "config", "rc", "enc", "temp", "session", "qa", "img", "cc", "act", "in", "cli", "dc", "image", "active", "inc", "cl", "bin", "call", "q", "conn", "sum", "conf", "current", "unit", "child", " inputs", "pull", "data", "exec", "ix", "str"]}}
{"project": "FFmpeg", "commit_id": "a026a3efaeb9c2026668dccbbda339a21ab3206b", "target": 1, "func": "static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param)\n\n{\n\n    int prefix = 0;\n\n    int suffix = 0;\n\n    int last_coeff_abs_level_remaining;\n\n    int i;\n\n\n\n    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc))\n\n        prefix++;\n\n\n\n    if (prefix < 3) {\n\n        for (i = 0; i < rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix;\n\n    } else {\n\n        int prefix_minus3 = prefix - 3;\n\n\n\n        if (prefix == CABAC_MAX_BIN) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"CABAC_MAX_BIN : %d\\n\", prefix);\n\n            return 0;\n\n        }\n\n\n\n        for (i = 0; i < prefix_minus3 + rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1)\n\n                                              << rc_rice_param) + suffix;\n\n    }\n\n    return last_coeff_abs_level_remaining;\n\n}\n", "idx": 10609, "substitutes": {"s": ["g", "os", "ctx", "f", "sym", "site", "service", "cs", "ls", "self", "sf", "ss", "serv", "c", "sq", "a", "is", "services", "d", "sb", "es", "p", "ts", "si", "sg", "S", "ds", "b", "session", "fs", "ssl", "scope", "sl", "ns", "spec", "t", "o", "ses", "qs", "sync", "u", "gs", "m", "e", "sys", "su", "js", "ops"], "rc_rice_param": ["rc_square_rm", "rc_riceingnum", "rc_ruby_param", "rc_ricefullname", "rc_cost_num", "rc_ruby_type", "rc_riceaccm", "rc_rice_num", "rc_single_ram", "rc_square_mode", "rc_ricefullparam", "rc_single_param", "rc_cost_par", "rc_ruby_cm", "rc_rice2params", "rc_square_param", "rc_riceacnum", "rc_rice2cm", "rc_rice2ram", "rc_riceingparam", "rc_riceingmode", "rc_single_cm", "rc_rice_program", "rc_cost_param", "rc_rice_rm", "rc_rice_mode", "rc_rice_type", "rc_rice_ram", "rc_riceacparam", "rc_ricefullcm", "rc_rice2param", "rc_cost_cm", "rc_square_cm", "rc_single_params", "rc_ruby_name", "rc_riceingprogram", "rc_square_num", "rc_square_program", "rc_riceacpar", "rc_rice_name", "rc_rice_par", "rc_ricefulltype", "rc_rice_params", "rc_rice_cm"], "last_coeff_abs_level_remaining": ["last_coeff_abs_level_Remain", "last_coeff_abs_level_Remained", "last_coeff_abs_level_reain", "last_coeff_abs_level_regained", "last_coeff_abs_level_rain", "last_coeff_abs_level_mapping", "last_coeff_abs_level_regaining", "last_coeff_abs_level_remapping", "last_coeff_abs_level_resaining", "last_coeff_abs_level_Remapping", "last_coeff_abs_level_reapping", "last_coeff_abs_level_reaining", "last_coeff_abs_level_rapping", "last_coeff_abs_level_rained", "last_coeff_abs_level_reained", "last_coeff_abs_level_Remaining", "last_coeff_abs_level_remained", "last_coeff_abs_level_raining", "last_coeff_abs_level_regain", "last_coeff_abs_level_main", "last_coeff_abs_level_regapping", "last_coeff_abs_level_resapping", "last_coeff_abs_level_remain", "last_coeff_abs_level_resain", "last_coeff_abs_level_resained", "last_coeff_abs_level_maining", "last_coeff_abs_level_mained"], "i": ["ii", "padding", "abi", "ni", "li", "uri", "f", "id", "phi", "I", "mu", "ip", "oi", "fi", "adi", "c", "iu", "ini", "jp", "multi", "ji", "p", "ri", "si", "b", "pi", "io", "inner", "j", "gi", "ie", "pre", "di", "xi", "fp", "bi", "ti", "v", "qi", "t", "ui", "zi", "image", "ci", "u", "index", "pad", "base", "e", "info", "ai", "mini", "eni", "x", "ix", "it"], "prefix": ["hop", "padding", "gap", "pass", "append", "adding", "phrase", "pointer", "mode", "diff", "path", "prev", "radius", "ski", "module", "sequence", "len", "patch", "master", "cache", "p", "offset", "reset", "xxx", "password", "order", "temp", "queue", "pre", "scale", "address", "fp", "magic", "partial", "phase", "num", "length", "wp", "frequency", "start", "index", "next", "priority", "pad", "wrapper", "delay", "base", "init", "token", "fix", "root", "bp", "zero", "batch", "status", "name", "number", "skip", "mix", "ix", "post"]}}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int segment_hls_window(AVFormatContext *s, int last)\n\n{\n\n    SegmentContext *seg = s->priv_data;\n\n    int i, ret = 0;\n\n    char buf[1024];\n\n\n\n    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,\n\n                              &s->interrupt_callback, NULL)) < 0)\n\n        goto fail;\n\n\n\n    avio_printf(seg->pb, \"#EXTM3U\\n\");\n\n    avio_printf(seg->pb, \"#EXT-X-VERSION:3\\n\");\n\n    avio_printf(seg->pb, \"#EXT-X-TARGETDURATION:%d\\n\", (int)seg->time);\n\n    avio_printf(seg->pb, \"#EXT-X-MEDIA-SEQUENCE:%d\\n\",\n\n                FFMAX(0, seg->number - seg->size));\n\n\n\n    av_log(s, AV_LOG_VERBOSE, \"EXT-X-MEDIA-SEQUENCE:%d\\n\",\n\n           FFMAX(0, seg->number - seg->size));\n\n\n\n    for (i = FFMAX(0, seg->number - seg->size);\n\n         i < seg->number; i++) {\n\n        avio_printf(seg->pb, \"#EXTINF:%d,\\n\", (int)seg->time);\n\n        if (seg->entry_prefix) {\n\n            avio_printf(seg->pb, \"%s\", seg->entry_prefix);\n\n        }\n\n        ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i);\n\n        if (ret < 0) {\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        avio_printf(seg->pb, \"%s\\n\", buf);\n\n    }\n\n\n\n    if (last)\n\n        avio_printf(seg->pb, \"#EXT-X-ENDLIST\\n\");\n\nfail:\n\n    avio_closep(&seg->pb);\n\n    return ret;\n\n}\n", "idx": 10620, "substitutes": {"s": ["server", "g", "args", "f", "src", "site", "service", "ls", "self", "sf", "ss", "serv", "xs", "c", "sq", "a", "sr", "services", "sv", "sb", "comm", "es", "h", "p", "ts", "si", "sg", "sie", "b", "session", "scope", "ssl", "core", "soc", "sl", "se", "ns", "v", "spec", "client", "us", "t", "o", "qs", "ses", "sc", "sync", "u", "gs", "m", "conf", "south", "e", "n", "sys", "su", "rs", "storage", "sa", "js", "stats", "aws"], "last": ["lag", "timeout", "li", "first", "latest", "size", "final", "max", "state", "prev", "Last", "result", "second", "event", "eval", "lo", "after", "loc", "use", "total", "full", "style", "end", "se", "cli", "code", "parent", "length", "error", "later", "l", "old", "start", "next", "reply", "info", "show", "sec", "count"], "seg": ["tege", "keleg", "parsep", "serig", "SEig", "scheg", "cega", "tegen", "inege", "seep", "gegen", "sergen", "inego", "gee", "nego", "gege", "persego", "parseg", "kep", " segn", "neg", "sega", "beg", "bep", "kegg", "perseb", "adeg", "adegg", "nep", "neG", "gel", "seeg", "begm", "psep", "kec", "begg", "seb", "tegn", "parsegen", "peig", "kego", "zek", "seleg", "kegn", "pep", "speg", "segment", "serge", "teig", "segs", "geG", "perseg", "neig", "sego", "kega", "gegs", "selge", "kege", " sego", "speb", "begs", " sega", "SEga", "tego", " sep", "SEgo", "suga", "tee", "adeleg", "gegn", "selga", "pec", "tega", "zege", "ineg", "sec", "nega", "begen", "zega", "selgn", "SEg", "segn", "ceg", "cegen", "SEp", "SEc", "seegm", "zego", "gegm", "adep", "SEb", "psega", "spego", "parsegn", "beleg", "peg", " segm", "gep", "serg", "pseg", "zep", "schega", "lec", "kegen", "psegn", "spegen", " segen", "sep", "geg", " sec", "bega", "inega", "schege", "pegen", "pega", "seegs", "geig", "segg", "legen", "lel", "leg", "segm", "kel", "seG", "sugn", "selk", " see", "negen", " sege", "zeg", "keig", "gec", "persegen", "schegn", "schegment", "elega", "pege", " sek", "sug", "gegment", "eleig", "sel", "keG", "keg", "segen", "sugment", "schegg", "see", "SEgn", "sek", "selgg", "SEge", "teg", "SEgen", "gega", "selg", "schego", "gego", "tegm", "elege", "psegen", "cege", "sege", "eleg", "seig"], "i": ["ii", "ni", "abi", "li", "uri", "f", "type", "id", "phi", "I", "limit", "ip", "oi", "mi", "fi", "ski", "c", "iu", "ini", "iter", "multi", "ri", "p", "si", "b", "pi", "xi", "j", "gi", "ie", "in", "z", "di", "bi", "ti", "zi", "ind", "r", "ui", "qi", "l", "ci", "start", "index", "e", "n", "info", "base", "ai", "line", "eni", "name", "slice", "ix", "it"], "buf": ["text", "block", "ctx", "f", "pool", "src", "callback", "vec", " b", "ff", "exc", "fi", "home", " buffer", "result", "bc", "bag", "seq", "pb", "box", "rc", "bytes", "h", "cb", " bu", "config", "loc", "bed", "b", "fb", "queue", "bh", "img", "rb", "bd", "fp", "cv", "tmp", "mem", "alloc", "br", "ret", "Buffer", "uf", "cmd", "buff", "buffer", "pad", "func", "msg", "wb", "uc", "fd", "null", "raw", " arr", "data", " buff", "ba"]}}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int cris_addc_pi_m(int a, int **b)\n\n{\n\n\tasm volatile (\"addc [%1+], %0\\n\" : \"+r\" (a), \"+b\" (*b));\n\n\treturn a;\n\n}\n", "idx": 10640, "substitutes": {"a": ["la", "ga", "f", "va", "ada", "ea", "na", "alpha", "ma", "c", "ca", "i", "an", "ae", "aa", "au", "p", "ha", "A", "fa", "ia", "ac", "parent", "ama", "da", "area", "l", "am", "ab", "as", "pa", "e", "sa", "name", "ad", "aaa", "x", "ba"], "b": ["abc", "f", "bis", "k", "nb", "y", "pb", "c", "db", "i", "lb", "sb", "bar", "cb", "ib", "fb", "bs", "bd", "rb", "B", "v", "bb", "xb", "abb", "l", "ab", "m", "zb", "emb", "base", "e", "ob", "be", "wb", "bf", "x", "ba"]}}
{"project": "qemu", "commit_id": "4871b51b9241b10f4fd8e04bbb21577886795e25", "target": 1, "func": "static void vmgenid_query_monitor_test(void)\n\n{\n\n    QemuUUID expected, measured;\n\n    gchar *cmd;\n\n\n\n    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=tcg -device vmgenid,id=testvgid,\"\n\n                          \"guid=%s\", VGID_GUID);\n\n    qtest_start(cmd);\n\n\n\n    /* Read the GUID via the monitor */\n\n    read_guid_from_monitor(&measured);\n\n    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);\n\n\n\n    qtest_quit(global_qtest);\n\n    g_free(cmd);\n\n}\n", "idx": 10648, "substitutes": {"expected": ["valid", " unexpected", "required", "received", "id", "view", "err", "started", "failed", "result", "confirmed", "sequence", "nexpected", "found", " expecting", "actual", " expectation", "event", " expects", "new", "config", "updated", "managed", "ev", " actual", "anticipated", "fake", "seen", "allowed", "pattern", "test", "supported", "est", "code", "handled", "me", "asured", "handler", "created", " event", "force", "generated", "claimed", "old", "served", "forced", " expect", "e", "announced", "pected", " observed", "name", "element", "data", "ordered", "pect", "str"], "measured": ["easure", " meessed", "measure", "seasure", "Measuring", "measuring", "easures", " measure", "Meessed", "peessed", "Measured", "mesasure", "peasured", "mesessed", "peasures", "omeasured", "feasuring", "seessed", "feessed", "omeasuring", "peasure", "measures", "easuring", "feasured", "seasuring", "meessed", "peasuring", "omeessed", "Measure", "mesasured", "mesasuring", "omeasure", " measuring", "seasured", "feasure", "Measures", "easured"], "cmd": ["ctr", "pipe", "clean", "ctx", "args", "id", "mode", "buf", "md", "seq", "c", "module", "cmp", "help", "method", "comm", "config", "cat", "cb", "bind", "ck", "pkg", "gn", "gz", "cp", "ct", "ctrl", "grad", "cfg", "core", "cli", "cc", "code", "client", "mac", "command", "req", "cf", "conn", "control", "cod", "func", "cookie", "init", "msg", "cn", "Cmd", "data", "cd"]}}
{"project": "FFmpeg", "commit_id": "b4886795108e319a5b3a88370e90207d9c15a01e", "target": 1, "func": "static int decode_frame_byterun1(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    IffContext *s = avctx->priv_data;\n\n    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;\n\n    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;\n\n    const uint8_t *buf_end = buf+buf_size;\n\n    int y, plane, res;\n\n\n\n    if ((res = extract_header(avctx, avpkt)) < 0)\n\n        return res;\n\n    if (s->init) {\n\n        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n            return res;\n\n        }\n\n    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return res;\n\n    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {\n\n        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)\n\n            return res;\n\n    }\n\n    s->init = 1;\n\n\n\n    if (avctx->codec_tag == MKTAG('I','L','B','M')) { //interleaved\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height ; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(row, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane8(row, s->planebuf, s->planesize, plane);\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height ; y++) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(s->ham_buf, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane8(s->ham_buf, s->planebuf, s->planesize, plane);\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else { //PIX_FMT_BGR32\n\n            for(y = 0; y < avctx->height ; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(row, 0, avctx->width << 2);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane32((uint32_t *) row, s->planebuf, s->planesize, plane);\n\n                }\n\n            }\n\n        }\n\n    } else if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { // IFF-PBM\n\n        for(y = 0; y < avctx->height ; y++ ) {\n\n            uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n            buf += decode_byterun(row, avctx->width, buf, buf_end);\n\n        }\n\n    } else { // IFF-PBM: HAM to PIX_FMT_BGR32\n\n        for (y = 0; y < avctx->height ; y++) {\n\n            uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n            buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end);\n\n            decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, avctx->width);\n\n        }\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n    return buf_size;\n\n}\n", "idx": 10665, "substitutes": {"avctx": ["navctx", "afca", "avsci", "aircontext", "afconfig", "avcf", "avnc", "avalloc", "afpkg", "afcmd", "navxc", "avalkit", "abkb", "navtx", "aftx", "avalconn", "alca", "avkb", "avalcmd", "alctx", "avhw", "afcu", "ajsys", "akctx", "aksc", "airsci", "avectx", " avcu", "akcontext", "avvoc", "navcontext", "afcms", "ajcontext", "afnc", "alhw", " avloc", "avcmd", "afcor", " avcontext", "verconn", "Avsci", "avca", "avkit", "avalcontext", "afsci", "aflc", "afsys", "avecontext", " avsci", "AVcontext", "avelc", "alcontext", "avconn", "afcomponent", " avpkg", "ajcf", "afcontext", "aktx", "ablc", "avconfig", "afsc", "AVctx", "afkb", "Avctx", "avtx", "AVconfig", "vercontext", "abcontext", "ajcomponent", "avlc", "avloc", "avpkg", "afconn", "AVcmp", "avalconfig", "avekb", "avcomponent", "ajctx", "avevoc", "avsys", "aveconfig", "airpkg", " avcm", "afvoc", "avsc", "avecmp", "afhw", " avnc", "akcms", "navcms", "afcm", "afctx", "airctx", "verkit", "navconn", "afcmp", "avehw", "avcmp", "avcontext", "ajnc", "navsys", "avecf", "avalctx", " avcor", "ajxc", "avcm", "ajsci", "avecm", "ajcor", "avecu", "ajtx", "Avtx", "Avcontext", "avcu", "abctx", "afcf", "avcms", "avecmd", "afloc", "afxc", " avconn", "aveca", "verctx", " avvoc", "avxc", "afkit", "akcf", "avecomponent", "aveconn", "avcor", "navcf", "avesc"], "data": ["message", "first", "empty", "alpha", "write", "a", "d", "draw", "bytes", "split", "blocks", "done", "open", "memory", "address", "ui", "next", "buff", "w", "series", "pad", "dat", "layout", "size", "id", "result", "module", "DATA", "frame", "end", "code", "parent", "header", "length", "bin", "delay", "base", "one", "align", "read", "action", "shift", "block", "format", "Data", "table", "len", "content", "load", "scale", "source", "start", "index", "map", "body", "last", "value", "name", "window", "x", "ata", "sample", "devices", "output", "media", "p", "offset", "input", "image", "da", "head", "m", "buffer", "bits", "zero", "batch", "slice", "cache"], "data_size": ["flow_end", "flow6size", "data_len", "flow_len", "data_scale", "flow_size", "flow6end", "flow6len", "data6end", "flow6scale", "data6len", "flow_scale", "data6size", "data6scale", "data_end"], "avpkt": ["avpeacket", "avcpacket", "avkkt", "avperkn", "avvpacket", "avvpct", "avpke", "avfqt", "avfkn", "affuto", "avpft", "avfct", "avpyth", "avpka", "avpct", "avpsyth", "avnpnt", "avpekt", "avpsacket", " avipacket", "avbpkh", "avcpkt", "avnpacket", "avpkh", "afpkt", "avbpacket", "afputo", "avppka", "avfuto", "afpqt", "avipct", " avipft", "affacket", "avperkt", "abpkt", "afpnt", "avpskt", "avfka", "avfke", "abpcht", "affcht", "avkke", "avbpkt", "abfkt", "avnpkt", "avvpkt", "affka", "avfpk", "avnpcht", "avcpft", " avipct", "avfk", "avccht", " avpacket", "avppacket", "avtpelt", "affk", "afpacket", "avpaka", "avfkt", "affnt", "avfft", "avipkt", "avfnt", "abfacket", "abpacket", "avpqt", "avfpnt", "avpcht", "avputo", "avbpcht", "afpelt", "avfelt", "avkqt", "avnpkn", "avfacket", "avpercht", "affqt", "avpauto", "avfpkt", "avfyth", "avtpyth", "afpkh", "avpecht", "avpaacket", "affkh", "avvpcht", "affyth", "avpputo", "avcct", "avcpct", "avckt", "affkn", "affke", "avpacket", "avtpacket", "avppkt", " avpft", "afpkn", "avfkh", "avtpkt", "avipft", "avperacket", "avfcht", "avnpk", "avpk", "avkacket", "afpke", "abpct", "avcacket", "avpelt", "affkt", " avpct", "afpk", "afpcht", "afpka", "avpekh", "avfpacket", "avcke", "afpyth", " avipkt", "affelt", "avipacket", "abfcht", "abfct", "avpnt", "avpakt", "avpkn", "avpselt", "avcqt"], "s": ["g", "os", "args", "f", "sym", "service", "its", "cs", "ls", "ss", "xs", "c", "sq", "a", "i", "is", "sup", "d", "services", "sb", "sv", "es", "ks", "p", "ts", "sg", "si", "S", "session", "ds", "b", "fs", "ssl", "settings", "http", "bs", "ns", "v", "spec", "css", "r", "t", "o", "ps", "ses", "qs", "l", "sc", "sync", "gs", "as", "m", "conf", "e", "n", "sys", "sets", "su", "rs", "sk", "js", "stats", "ops", "aws"], "buf": ["cas", "pos", "text", "empty", "block", "vec", "limit", "ff", "home", "bc", "bag", "seq", "len", "box", "rc", "cb", "cur", "loc", "cp", "queue", "lim", "rb", "cv", "mem", "header", "alloc", "length", "br", "Buffer", "uf", "cmd", "val", "cf", "buff", "map", "ab", "buffer", "col", "base", "wb", "cap", "uc", "fin", "batch", "zero", "window", "cache"], "buf_end": ["buf_stop", "queue_stop", "queue_size", "buf_start", "queue_start", "queue_end", "buf_size"], "y": ["hop", "ii", "idy", "zy", "ey", "wy", "yy", "type", "yo", "iy", "ky", "ip", "ny", "ya", "c", "yi", "yn", "xy", "i", "h", "dy", "p", "hy", "cy", "gy", "vy", "year", "j", "yr", "key", "z", "ye", "ay", "sy", "ch", "t", "area", "ym", "ady", "height", "w", "m", "col", "n", "lon", "Y", "yl", "py", "kit", "oy", "x"], "plane": ["axis", "pos", "pass", "planes", "board", "f", "file", "mode", "period", "flow", "weight", "limit", "pl", "plate", "class", "flo", "fly", "jet", "drop", "pen", "den", "cat", "p", "lane", "fle", "ane", "span", "gate", "cp", "fl", "plan", "con", "direction", "core", "scale", "charge", "key", "z", "cube", "pe", "age", "rot", "level", "mo", "w", "col", "n", "port", "ge", "zone", "pose", "unit", "cap", "page", "sea", "slice", "line"], "res": ["rus", "os", "breaks", "args", "id", "rates", "resp", "re", "vals", "err", "rev", "resolution", "result", "min", "success", "ver", "RES", "rc", "rss", "des", "response", "reset", "content", "arr", "details", "results", "rem", "range", "nos", "gen", "bs", "pres", "ris", "sol", "ms", "press", "ras", "css", "rx", "r", "ret", "error", "val", "ps", "req", "errors", "ress", "Res", "cr", "ry", "rec", "gr", "ros", "conf", "obj", "msg", "rs", "reg", "rh", "cons", "root", "js", "rex", "resh", "ber", "rap", "cache"], "row": ["tr", "pos", "pass", "block", "ack", "board", "flow", "view", "low", "box", "user", "rows", "per", "cell", "range", "fl", "feed", "scale", "array", "Row", "key", "image", "entry", "r", "item", "index", "column", "col", "post", "port", "value", "month", "batch", "bug", "slice", "line"]}}
{"project": "FFmpeg", "commit_id": "29d2dc59f973f9495c703b4cab17ded5c24ab3e8", "target": 1, "func": "int alloc_picture(MpegEncContext *s, Picture *pic, int shared){\n\n    const int big_mb_num= s->mb_stride*(s->mb_height+1) + 1; //the +1 is needed so memset(,,stride*height) does not sig11\n\n    const int mb_array_size= s->mb_stride*s->mb_height;\n\n    const int b8_array_size= s->b8_stride*s->mb_height*2;\n\n    const int b4_array_size= s->b4_stride*s->mb_height*4;\n\n    int i;\n\n\n\n    if(shared){\n\n        assert(pic->data[0]);\n\n        assert(pic->type == 0 || pic->type == FF_BUFFER_TYPE_SHARED);\n\n        pic->type= FF_BUFFER_TYPE_SHARED;\n\n    }else{\n\n        int r;\n\n\n\n        assert(!pic->data[0]);\n\n\n\n        r= s->avctx->get_buffer(s->avctx, (AVFrame*)pic);\n\n\n\n        if(r<0 || !pic->age || !pic->type || !pic->data[0]){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (%d %d %d %p)\\n\", r, pic->age, pic->type, pic->data[0]);\n\n            return -1;\n\n        }\n\n\n\n        if(s->linesize && (s->linesize != pic->linesize[0] || s->uvlinesize != pic->linesize[1])){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (stride changed)\\n\");\n\n            return -1;\n\n        }\n\n\n\n        if(pic->linesize[1] != pic->linesize[2]){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (uv stride mismatch)\\n\");\n\n            return -1;\n\n        }\n\n\n\n        s->linesize  = pic->linesize[0];\n\n        s->uvlinesize= pic->linesize[1];\n\n    }\n\n\n\n    if(pic->qscale_table==NULL){\n\n        if (s->encoding) {\n\n            CHECKED_ALLOCZ(pic->mb_var   , mb_array_size * sizeof(int16_t))\n\n            CHECKED_ALLOCZ(pic->mc_mb_var, mb_array_size * sizeof(int16_t))\n\n            CHECKED_ALLOCZ(pic->mb_mean  , mb_array_size * sizeof(int8_t))\n\n        }\n\n\n\n        CHECKED_ALLOCZ(pic->mbskip_table , mb_array_size * sizeof(uint8_t)+2) //the +2 is for the slice end check\n\n        CHECKED_ALLOCZ(pic->qscale_table , mb_array_size * sizeof(uint8_t))\n\n        CHECKED_ALLOCZ(pic->mb_type_base , big_mb_num    * sizeof(uint32_t))\n\n        pic->mb_type= pic->mb_type_base + s->mb_stride+1;\n\n        if(s->out_format == FMT_H264){\n\n            for(i=0; i<2; i++){\n\n                CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b4_array_size+4)  * sizeof(int16_t))\n\n                pic->motion_val[i]= pic->motion_val_base[i]+4;\n\n                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))\n\n            }\n\n            pic->motion_subsample_log2= 2;\n\n        }else if(s->out_format == FMT_H263 || s->encoding || (s->avctx->debug&FF_DEBUG_MV) || (s->avctx->debug_mv)){\n\n            for(i=0; i<2; i++){\n\n                CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b8_array_size+4) * sizeof(int16_t))\n\n                pic->motion_val[i]= pic->motion_val_base[i]+4;\n\n                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))\n\n            }\n\n            pic->motion_subsample_log2= 3;\n\n        }\n\n        if(s->avctx->debug&FF_DEBUG_DCT_COEFF) {\n\n            CHECKED_ALLOCZ(pic->dct_coeff, 64 * mb_array_size * sizeof(DCTELEM)*6)\n\n        }\n\n        pic->qstride= s->mb_stride;\n\n        CHECKED_ALLOCZ(pic->pan_scan , 1 * sizeof(AVPanScan))\n\n    }\n\n\n\n    /* It might be nicer if the application would keep track of these\n\n     * but it would require an API change. */\n\n    memmove(s->prev_pict_types+1, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE-1);\n\n    s->prev_pict_types[0]= s->pict_type;\n\n    if(pic->age < PREV_PICT_TYPES_BUFFER_SIZE && s->prev_pict_types[pic->age] == B_TYPE)\n\n        pic->age= INT_MAX; // Skipped MBs in B-frames are quite rare in MPEG-1/2 and it is a bit tricky to skip them anyway.\n\n\n\n    return 0;\n\nfail: //for the CHECKED_ALLOCZ macro\n\n    return -1;\n\n}\n", "idx": 10670, "substitutes": {"s": ["ctx", "sym", "service", "cs", "self", "c", "a", "ks", "settings", "b", "hs", "sites", "gs", "w", "as", "ubs", "e", "rs", "js", "syn", "phys", "os", "bis", "site", "its", "ls", "ss", "sq", "sit", "ins", "sb", "http", "S", "sie", "ds", "session", "fs", "ssl", "ms", "bin", "ses", "qs", "sec", "f", "parts", "xs", "y", "services", "sg", "ps", "l", "sync", "current", "sys", "lc", "space", "features", "g", "parse", "side", "sports", "is", "sup", "es", "p", "ts", "si", "full", "sis", "ns", "spec", "share", "us", "t", "your", "m", "conf", "sets", "storage", "sa", "stats", "ops", "aws"], "pic": ["pse", "file", "chat", "comment", "c", "pc", "jp", "model", "sci", "fb", "pict", "pres", "bi", "pick", "cus", "sn", "eni", "ig", "syn", "txt", "feat", "plugin", "fn", "study", "module", "sit", "feature", "sie", "ic", "frame", "doc", "xi", "fp", "kin", "icon", "pin", "bin", "pins", "mc", "sec", "jc", "str", "typ", "bc", "vc", "config", "cop", "mic", "tick", "icer", "avi", "pot", "fc", "jack", "phot", "mac", "picture", "sync", "lib", "pa", "sys", "photo", "lc", "mini", "py", "ics", "parse", "nic", "fi", "p", "si", "cy", "Pic", "style", "piece", "Picture", "cha", "iv", "spec", "image", "ac", "capt", "sa", "data", "cache"], "shared": ["parse", "compatible", "global", "loaded", "local", "balanced", "bare", "private", "acked", "sq", "encrypted", "public", "managed", "sharp", "same", "aware", "ared", "sh", "exclusive", "shape", "load", "packed", "sharing", "part", "par", "share", "parent", "broken", "sc", "lib", "sync", "stack", "used", "buffer", "locked", "storage", "sec", "raw", "held", "owned", "read", "aws"], "i": ["ii", "li", "f", "I", "ip", "c", "a", "p", "si", "b", "pi", "io", "j", "in", "v", "image", "ti", "l", "ci", "index", "m", "e", "n", "ai", "mini", "counter", "x", "it"], "r": ["fr", "rt", "f", "nr", "re", "hr", "err", "result", "rg", "ra", "c", "mr", "sr", "d", "ru", "rc", "dr", "pr", "lr", "p", "h", "rd", "rl", "rf", "b", "range", "vr", "R", "ar", "rb", "v", "br", "kr", "attr", "l", "ir", "cr", "m", "e", "n", "er", "rs", "rr", "rh", "rar", "res", "rate"]}}
{"project": "FFmpeg", "commit_id": "fa5dacce143f3fbe8eac14d5a99e926b2787e9e6", "target": 1, "func": "static int decode_pic_hdr(IVI5DecContext *ctx, AVCodecContext *avctx)\n{\n    if (get_bits(&ctx->gb, 5) != 0x1F) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid picture start code!\\n\");\n        return -1;\n    ctx->prev_frame_type = ctx->frame_type;\n    ctx->frame_type      = get_bits(&ctx->gb, 3);\n    if (ctx->frame_type >= 5) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid frame type: %d \\n\", ctx->frame_type);\n        return -1;\n    ctx->frame_num = get_bits(&ctx->gb, 8);\n    if (ctx->frame_type == FRAMETYPE_INTRA) {\n        ctx->gop_invalid = 1;\n        if (decode_gop_header(ctx, avctx))\n            return -1;\n        ctx->gop_invalid = 0;\n    if (ctx->frame_type != FRAMETYPE_NULL) {\n        ctx->frame_flags = get_bits(&ctx->gb, 8);\n        ctx->pic_hdr_size = (ctx->frame_flags & 1) ? get_bits_long(&ctx->gb, 24) : 0;\n        ctx->checksum = (ctx->frame_flags & 0x10) ? get_bits(&ctx->gb, 16) : 0;\n        /* skip unknown extension if any */\n        if (ctx->frame_flags & 0x20)\n            skip_hdr_extension(&ctx->gb); /* XXX: untested */\n        /* decode macroblock huffman codebook */\n        if (ff_ivi_dec_huff_desc(&ctx->gb, ctx->frame_flags & 0x40, IVI_MB_HUFF, &ctx->mb_vlc, avctx))\n            return -1;\n        skip_bits(&ctx->gb, 3); /* FIXME: unknown meaning! */\n    align_get_bits(&ctx->gb);\n    return 0;", "idx": 10671, "substitutes": {"ctx": ["la", "cs", "nc", "exc", "comp", "connection", "c", "pc", "console", "sci", "cm", "cc", "css", "cmd", "ci", "cus", "fw", "cn", "msg", "cca", "gc", "cas", "np", "xc", "conv", "ck", "scope", "fp", "coll", "cl", "conn", "sc", "mc", "exec", "gru", "ctr", "utils", "hw", "bc", "wcs", "vc", "ca", "concept", "config", "pkg", "qa", "cu", "kw", "cfg", "fc", "cms", "req", "cf", "lib", "sync", "crit", "sys", "lc", "support", "ga", "Context", "anc", "na", "ce", "cmp", "co", "cb", "kb", "loc", "cp", "ctrl", "context", "cli", "cv", "dc", "client", "git", "cam", "component", "conf", "tx", "obj", "tc"], "avctx": ["avconfig", "avcmp", "navctx", "abcam", "avcontext", "antctx", "Avchan", "AVctx", "aircontext", "abcmp", "afconfig", "afconsole", "navcontext", "Avctx", "navcmp", "AVconfig", "abcontext", "avercmp", "averctx", "Avcontext", "avconsole", "abctx", "aircmp", "AVconsole", "ivctx", "avercontext", "AVcmp", "AVwcs", "ivchan", "airconfig", "navwcs", "avwcs", "avchan", "antcam", "antcontext", "Avcam", "AVchan", "ivcam", "averconsole", "avcam", "AVcontext", "ivcontext", "antcmp", "AVcam", "abwcs", "afctx", "airctx", "afcmp", "afcontext"]}}
{"project": "FFmpeg", "commit_id": "64f7db554ee83846f207e82a08946a6a5a6acfe2", "target": 1, "func": "static int mpegts_write_header(AVFormatContext *s)\n\n{\n\n    MpegTSWrite *ts = s->priv_data;\n\n    MpegTSWriteStream *ts_st;\n\n    MpegTSService *service;\n\n    AVStream *st, *pcr_st = NULL;\n\n    AVDictionaryEntry *title, *provider;\n\n    int i, j;\n\n    const char *service_name;\n\n    const char *provider_name;\n\n    int *pids;\n\n    int ret;\n\n\n\n    if (s->max_delay < 0) /* Not set by the caller */\n\n        s->max_delay = 0;\n\n\n\n    // round up to a whole number of TS packets\n\n    ts->pes_payload_size = (ts->pes_payload_size + 14 + 183) / 184 * 184 - 14;\n\n\n\n    ts->tsid = ts->transport_stream_id;\n\n    ts->onid = ts->original_network_id;\n\n    /* allocate a single DVB service */\n\n    title = av_dict_get(s->metadata, \"service_name\", NULL, 0);\n\n    if (!title)\n\n        title = av_dict_get(s->metadata, \"title\", NULL, 0);\n\n    service_name  = title ? title->value : DEFAULT_SERVICE_NAME;\n\n    provider      = av_dict_get(s->metadata, \"service_provider\", NULL, 0);\n\n    provider_name = provider ? provider->value : DEFAULT_PROVIDER_NAME;\n\n    service       = mpegts_add_service(ts, ts->service_id,\n\n                                       provider_name, service_name);\n\n\n\n    if (!service)\n\n        return AVERROR(ENOMEM);\n\n\n\n    service->pmt.write_packet = section_write_packet;\n\n    service->pmt.opaque       = s;\n\n    service->pmt.cc           = 15;\n\n\n\n    ts->pat.pid          = PAT_PID;\n\n    /* Initialize at 15 so that it wraps and is equal to 0 for the\n\n     * first packet we write. */\n\n    ts->pat.cc           = 15;\n\n    ts->pat.write_packet = section_write_packet;\n\n    ts->pat.opaque       = s;\n\n\n\n    ts->sdt.pid          = SDT_PID;\n\n    ts->sdt.cc           = 15;\n\n    ts->sdt.write_packet = section_write_packet;\n\n    ts->sdt.opaque       = s;\n\n\n\n    pids = av_malloc_array(s->nb_streams, sizeof(*pids));\n\n    if (!pids) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    /* assign pids to each stream */\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        st = s->streams[i];\n\n\n\n        ts_st = av_mallocz(sizeof(MpegTSWriteStream));\n\n        if (!ts_st) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        st->priv_data = ts_st;\n\n\n\n        ts_st->user_tb = st->time_base;\n\n        avpriv_set_pts_info(st, 33, 1, 90000);\n\n\n\n        ts_st->payload = av_mallocz(ts->pes_payload_size);\n\n        if (!ts_st->payload) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        ts_st->service = service;\n\n        /* MPEG pid values < 16 are reserved. Applications which set st->id in\n\n         * this range are assigned a calculated pid. */\n\n        if (st->id < 16) {\n\n            ts_st->pid = ts->start_pid + i;\n\n        } else if (st->id < 0x1FFF) {\n\n            ts_st->pid = st->id;\n\n        } else {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Invalid stream id %d, must be less than 8191\\n\", st->id);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        if (ts_st->pid == service->pmt.pid) {\n\n            av_log(s, AV_LOG_ERROR, \"Duplicate stream id %d\\n\", ts_st->pid);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        for (j = 0; j < i; j++) {\n\n            if (pids[j] == ts_st->pid) {\n\n                av_log(s, AV_LOG_ERROR, \"Duplicate stream id %d\\n\", ts_st->pid);\n\n                ret = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n        }\n\n        pids[i]                = ts_st->pid;\n\n        ts_st->payload_pts     = AV_NOPTS_VALUE;\n\n        ts_st->payload_dts     = AV_NOPTS_VALUE;\n\n        ts_st->first_pts_check = 1;\n\n        ts_st->cc              = 15;\n\n        /* update PCR pid by using the first video stream */\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n            service->pcr_pid == 0x1fff) {\n\n            service->pcr_pid = ts_st->pid;\n\n            pcr_st           = st;\n\n        }\n\n        if (st->codec->codec_id == AV_CODEC_ID_AAC &&\n\n            st->codec->extradata_size > 0) {\n\n            AVStream *ast;\n\n            ts_st->amux = avformat_alloc_context();\n\n            if (!ts_st->amux) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            ts_st->amux->oformat =\n\n                av_guess_format((ts->flags & MPEGTS_FLAG_AAC_LATM) ? \"latm\" : \"adts\",\n\n                                NULL, NULL);\n\n            if (!ts_st->amux->oformat) {\n\n                ret = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            if (!(ast = avformat_new_stream(ts_st->amux, NULL))) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            ret = avcodec_copy_context(ast->codec, st->codec);\n\n            if (ret != 0)\n\n                goto fail;\n\n            ast->time_base = st->time_base;\n\n            ret = avformat_write_header(ts_st->amux, NULL);\n\n            if (ret < 0)\n\n                goto fail;\n\n        }\n\n        if (st->codec->codec_id == AV_CODEC_ID_OPUS) {\n\n            ts_st->opus_pending_trim_start = st->codec->initial_padding * 48000 / st->codec->sample_rate;\n\n        }\n\n    }\n\n\n\n    av_freep(&pids);\n\n\n\n    /* if no video stream, use the first stream as PCR */\n\n    if (service->pcr_pid == 0x1fff && s->nb_streams > 0) {\n\n        pcr_st           = s->streams[0];\n\n        ts_st            = pcr_st->priv_data;\n\n        service->pcr_pid = ts_st->pid;\n\n    } else\n\n        ts_st = pcr_st->priv_data;\n\n\n\n    if (ts->mux_rate > 1) {\n\n        service->pcr_packet_period = (ts->mux_rate * ts->pcr_period) /\n\n                                     (TS_PACKET_SIZE * 8 * 1000);\n\n        ts->sdt_packet_period      = (ts->mux_rate * SDT_RETRANS_TIME) /\n\n                                     (TS_PACKET_SIZE * 8 * 1000);\n\n        ts->pat_packet_period      = (ts->mux_rate * PAT_RETRANS_TIME) /\n\n                                     (TS_PACKET_SIZE * 8 * 1000);\n\n\n\n        if (ts->copyts < 1)\n\n            ts->first_pcr = av_rescale(s->max_delay, PCR_TIME_BASE, AV_TIME_BASE);\n\n    } else {\n\n        /* Arbitrary values, PAT/PMT will also be written on video key frames */\n\n        ts->sdt_packet_period = 200;\n\n        ts->pat_packet_period = 40;\n\n        if (pcr_st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (!pcr_st->codec->frame_size) {\n\n                av_log(s, AV_LOG_WARNING, \"frame size not set\\n\");\n\n                service->pcr_packet_period =\n\n                    pcr_st->codec->sample_rate / (10 * 512);\n\n            } else {\n\n                service->pcr_packet_period =\n\n                    pcr_st->codec->sample_rate / (10 * pcr_st->codec->frame_size);\n\n            }\n\n        } else {\n\n            // max delta PCR 0.1s\n\n            // TODO: should be avg_frame_rate\n\n            service->pcr_packet_period =\n\n                ts_st->user_tb.den / (10 * ts_st->user_tb.num);\n\n        }\n\n        if (!service->pcr_packet_period)\n\n            service->pcr_packet_period = 1;\n\n    }\n\n\n\n    ts->last_pat_ts = AV_NOPTS_VALUE;\n\n    ts->last_sdt_ts = AV_NOPTS_VALUE;\n\n    // The user specified a period, use only it\n\n    if (ts->pat_period < INT_MAX/2) {\n\n        ts->pat_packet_period = INT_MAX;\n\n    }\n\n    if (ts->sdt_period < INT_MAX/2) {\n\n        ts->sdt_packet_period = INT_MAX;\n\n    }\n\n\n\n    // output a PCR as soon as possible\n\n    service->pcr_packet_count = service->pcr_packet_period;\n\n    ts->pat_packet_count      = ts->pat_packet_period - 1;\n\n    ts->sdt_packet_count      = ts->sdt_packet_period - 1;\n\n\n\n    if (ts->mux_rate == 1)\n\n        av_log(s, AV_LOG_VERBOSE, \"muxrate VBR, \");\n\n    else\n\n        av_log(s, AV_LOG_VERBOSE, \"muxrate %d, \", ts->mux_rate);\n\n    av_log(s, AV_LOG_VERBOSE,\n\n           \"pcr every %d pkts, sdt every %d, pat/pmt every %d pkts\\n\",\n\n           service->pcr_packet_period,\n\n           ts->sdt_packet_period, ts->pat_packet_period);\n\n\n\n    if (ts->m2ts_mode == -1) {\n\n        if (av_match_ext(s->filename, \"m2ts\")) {\n\n            ts->m2ts_mode = 1;\n\n        } else {\n\n            ts->m2ts_mode = 0;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_freep(&pids);\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        st    = s->streams[i];\n\n        ts_st = st->priv_data;\n\n        if (ts_st) {\n\n            av_freep(&ts_st->payload);\n\n            if (ts_st->amux) {\n\n                avformat_free_context(ts_st->amux);\n\n                ts_st->amux = NULL;\n\n            }\n\n        }\n\n        av_freep(&st->priv_data);\n\n    }\n\n\n\n    for (i = 0; i < ts->nb_services; i++) {\n\n        service = ts->services[i];\n\n        av_freep(&service->provider_name);\n\n        av_freep(&service->name);\n\n        av_freep(&service);\n\n    }\n\n    av_freep(&ts->services);\n\n    return ret;\n\n}\n", "idx": 10672, "substitutes": {"s": ["sym", "cs", "c", "a", "ks", "d", "sv", "settings", "b", "hs", "sites", "gs", "as", "e", "comments", "rs", "js", "status", "site", "its", "ls", "ss", "sq", "ins", "sr", "sb", "h", "http", "S", "ds", "session", "fs", "ssl", "z", "tes", "o", "ses", "qs", "submit", "set", "tests", "f", "parts", "sf", "xs", "y", "services", "sg", "details", "secondary", "ches", "v", "ions", "r", "ps", "l", "sync", "u", "south", "sys", "su", "space", "g", "args", "local", "single", "is", "es", "p", "si", "ns", "less", "spec", "client", "us", "t", "m", "conf", "n", "sets", "sa", "none", "stats", "ops", "aws"], "ts": ["tf", "ats", "cs", "ments", " services", "ks", "Ts", "ims", "uts", "settings", "outs", "sts", "ets", "gs", "rs", "js", "vs", "os", "tp", "rets", "its", "ls", "ss", "ins", "tm", "options", "ds", "fs", "test", "alls", "tes", "ms", "qs", "te", "ters", "trans", "tags", "lets", "ports", "tr", "tests", "utils", "als", "parts", "td", "xs", "points", "times", "services", "mods", "details", "acs", "bs", "ps", "ta", "TS", "cons", "tips", "ics", "events", "es", "files", "ns", "t", "wt", "tis", "tx", "tim", "tt", "tc", "stats", "types", "ops", "tin"], "ts_st": ["ats_st", "ats_St", "ts_sth", "ts_St", "ts_ST", "ats_ST", "ats_sth"], "service": ["server", "plugin", "support", "text", "match", "site", "id", "device", "cs", "ss", "serv", "connection", "vc", "y", "module", " services", "is", "services", "event", "sv", "ice", "si", "sp", "skill", "scope", "session", "cy", "ds", "use", "http", "project", "Service", "ie", "se", "sl", "ns", "v", "spec", "image", "entry", "t", "source", "resource", "command", "sync", "license", "proxy", "git", "start", "series", "component", "tt", "port", "info", "security", "section", "storage", "sk", "space", "company", "py", "sys", "object", "it"], "st": ["sth", "src", "typ", "td", "sv", "sb", "stage", "sp", "sta", "ST", "sid", "sts", "ct", "test", "pt", "sl", "t", "std", "sc", "sn", "tt", "sa", "rest", "inst", "str"], "pcr_st": ["pcrsrest", "pct_ST", "pcr_rest", "pcrsst", "pcr2ST", "pcr_str", "pct_st", "pcr2st", "pcrsST", "pct_str", "pct_rest", "pcrsstr", "pcr2rest", "pcr2str", "pcr_ST"], "title": ["message", "text", "prefix", "itles", "author", "phrase", "type", "id", "format", "itle", "comment", "subject", "description", "journal", "note", "metadata", "front", "tag", "alpha", "phone", "media", "template", "label", "application", "Title", "username", "term", "tip", "theme", "doi", "primary", "details", "scope", " titles", "filename", "doc", "project", "test", "html", "shell", "part", "key", "summary", "detail", "header", "resource", "article", "license", "head", "body", "yt", "unit", "profile", "ame", "meta", "name", "role", "company", "data", "alias"], "provider": ["configider", "PROVison", "produider", "authorider", "PROVider", "genericator", "produicator", "proser", "pride", "authorator", "promce", "divoker", "PROVoker", "divison", "provator", "divide", "generide", "provide", "produoser", "PROVide", "authoride", "authoricator", "generison", "provce", "generoker", "divider", "providers", "promider", "promiders", "provison", "configce", "configiders", "proker", "generoser", "produiders", "produide", "produator", "generider", "provicator", "generator", "provoker", "produoker", "prider", "provoser", "produce"], "i": ["ii", "li", "f", "type", "id", "phi", "I", "ip", "mi", "fi", "chi", "c", "ki", "iu", "ini", "jp", "d", "ji", "p", "ri", "si", "b", "pi", "gi", "end", "ie", "di", "v", "ti", "bi", "zi", "xi", "qi", "ui", "l", "ci", "start", "index", "u", "e", "n", "ai", "eni", "depth", "x", "ix"], "j": ["ok", "pos", "att", "k", "je", "note", "rev", "jet", "jp", "ji", "p", "slot", "vision", "ie", "z", "v", "op", "J", "r", "l", "sync", "job", "ij", "obj", "sec", "aj", "jc", "it"], "service_name": ["plugin_name", "servicealnam", "servicefnam", "servicealname", "server_nam", "serviceOanc", "plugin_secret", "serviceOsize", "serviceOname", "plugin_anc", "serviceOsecret", "servicealtype", "server_name", "serviceFanc", "servicefulldesc", "servicefullname", "service_nam", "service_secret", "servicefname", "service_desc", "servicealtitle", "service_title", "serviceftype", "serviceftitle", "serviceFsecret", "service_anc", "server_title", "service_size", " service_title", "servicefulltitle", "server_type", "serviceFname", "service_type", "plugin_size", " service_desc", "serviceFsize"], "provider_name": ["proviser1name", "provifieracbase", "provifieracnumber", "provider_names", "providerscode", "proviser_names", "provideraccode", "provifier_name", "provifier_number", "provifier_base", "proviser_description", "providersid", "provider1name", "provider_number", "proviser1description", "providerUbase", "provideracnumber", "proviser_name", "providers_id", "provifieraccode", "provider1names", "provideracbase", "providerUcode", "provider_description", "provider_base", "providersname", "providerUname", "provider1description", "provider_code", "providers_code", "providers_name", "provider_id", "provider_named", "providersnamed", "providers_named", "provideracname", "providerUnumber", "provifier_code", "proviser1names", "provifieracname"], "pids": ["picks", "pods", "Pods", "pipes", "Picks", "Pips", "ppids", " pipes", "ppid", " pases", "cpips", " pips", " picks", "pases", "cpids", "Pipes", "bicks", "bips", " pods", "cpods", "Pids", "ppods", "Pid", "Pases", "ppases", "bids", "ppips", " pid", "bid", "ppipes", "cpid", "pid", "pips"], "ret": ["rets", "rt", "match", "att", "re", "RET", "vt", "ft", "result", "success", "seq", "len", " Ret", " RET", "cat", "back", "arr", "fun", "lit", "secret", "url", "ut", "gt", "mem", "r", "get", "val", "pet", "det", "reply", "util", "res", "sec", "alt", "Ret", "status", "str"]}}
{"project": "FFmpeg", "commit_id": "15ccaa344c4f645ae791aafecdef3d886e196127", "target": 1, "func": "void dct32(INTFLOAT *out, const INTFLOAT *tab)\n\n{\n\n    INTFLOAT tmp0, tmp1;\n\n\n\n    INTFLOAT val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 ,\n\n             val8 , val9 , val10, val11, val12, val13, val14, val15,\n\n             val16, val17, val18, val19, val20, val21, val22, val23,\n\n             val24, val25, val26, val27, val28, val29, val30, val31;\n\n\n\n    /* pass 1 */\n\n    BF0( 0, 31, COS0_0 , 1);\n\n    BF0(15, 16, COS0_15, 5);\n\n    /* pass 2 */\n\n    BF( 0, 15, COS1_0 , 1);\n\n    BF(16, 31,-COS1_0 , 1);\n\n    /* pass 1 */\n\n    BF0( 7, 24, COS0_7 , 1);\n\n    BF0( 8, 23, COS0_8 , 1);\n\n    /* pass 2 */\n\n    BF( 7,  8, COS1_7 , 4);\n\n    BF(23, 24,-COS1_7 , 4);\n\n    /* pass 3 */\n\n    BF( 0,  7, COS2_0 , 1);\n\n    BF( 8, 15,-COS2_0 , 1);\n\n    BF(16, 23, COS2_0 , 1);\n\n    BF(24, 31,-COS2_0 , 1);\n\n    /* pass 1 */\n\n    BF0( 3, 28, COS0_3 , 1);\n\n    BF0(12, 19, COS0_12, 2);\n\n    /* pass 2 */\n\n    BF( 3, 12, COS1_3 , 1);\n\n    BF(19, 28,-COS1_3 , 1);\n\n    /* pass 1 */\n\n    BF0( 4, 27, COS0_4 , 1);\n\n    BF0(11, 20, COS0_11, 2);\n\n    /* pass 2 */\n\n    BF( 4, 11, COS1_4 , 1);\n\n    BF(20, 27,-COS1_4 , 1);\n\n    /* pass 3 */\n\n    BF( 3,  4, COS2_3 , 3);\n\n    BF(11, 12,-COS2_3 , 3);\n\n    BF(19, 20, COS2_3 , 3);\n\n    BF(27, 28,-COS2_3 , 3);\n\n    /* pass 4 */\n\n    BF( 0,  3, COS3_0 , 1);\n\n    BF( 4,  7,-COS3_0 , 1);\n\n    BF( 8, 11, COS3_0 , 1);\n\n    BF(12, 15,-COS3_0 , 1);\n\n    BF(16, 19, COS3_0 , 1);\n\n    BF(20, 23,-COS3_0 , 1);\n\n    BF(24, 27, COS3_0 , 1);\n\n    BF(28, 31,-COS3_0 , 1);\n\n\n\n\n\n\n\n    /* pass 1 */\n\n    BF0( 1, 30, COS0_1 , 1);\n\n    BF0(14, 17, COS0_14, 3);\n\n    /* pass 2 */\n\n    BF( 1, 14, COS1_1 , 1);\n\n    BF(17, 30,-COS1_1 , 1);\n\n    /* pass 1 */\n\n    BF0( 6, 25, COS0_6 , 1);\n\n    BF0( 9, 22, COS0_9 , 1);\n\n    /* pass 2 */\n\n    BF( 6,  9, COS1_6 , 2);\n\n    BF(22, 25,-COS1_6 , 2);\n\n    /* pass 3 */\n\n    BF( 1,  6, COS2_1 , 1);\n\n    BF( 9, 14,-COS2_1 , 1);\n\n    BF(17, 22, COS2_1 , 1);\n\n    BF(25, 30,-COS2_1 , 1);\n\n\n\n    /* pass 1 */\n\n    BF0( 2, 29, COS0_2 , 1);\n\n    BF0(13, 18, COS0_13, 3);\n\n    /* pass 2 */\n\n    BF( 2, 13, COS1_2 , 1);\n\n    BF(18, 29,-COS1_2 , 1);\n\n    /* pass 1 */\n\n    BF0( 5, 26, COS0_5 , 1);\n\n    BF0(10, 21, COS0_10, 1);\n\n    /* pass 2 */\n\n    BF( 5, 10, COS1_5 , 2);\n\n    BF(21, 26,-COS1_5 , 2);\n\n    /* pass 3 */\n\n    BF( 2,  5, COS2_2 , 1);\n\n    BF(10, 13,-COS2_2 , 1);\n\n    BF(18, 21, COS2_2 , 1);\n\n    BF(26, 29,-COS2_2 , 1);\n\n    /* pass 4 */\n\n    BF( 1,  2, COS3_1 , 2);\n\n    BF( 5,  6,-COS3_1 , 2);\n\n    BF( 9, 10, COS3_1 , 2);\n\n    BF(13, 14,-COS3_1 , 2);\n\n    BF(17, 18, COS3_1 , 2);\n\n    BF(21, 22,-COS3_1 , 2);\n\n    BF(25, 26, COS3_1 , 2);\n\n    BF(29, 30,-COS3_1 , 2);\n\n\n\n    /* pass 5 */\n\n    BF1( 0,  1,  2,  3);\n\n    BF2( 4,  5,  6,  7);\n\n    BF1( 8,  9, 10, 11);\n\n    BF2(12, 13, 14, 15);\n\n    BF1(16, 17, 18, 19);\n\n    BF2(20, 21, 22, 23);\n\n    BF1(24, 25, 26, 27);\n\n    BF2(28, 29, 30, 31);\n\n\n\n    /* pass 6 */\n\n\n\n    ADD( 8, 12);\n\n    ADD(12, 10);\n\n    ADD(10, 14);\n\n    ADD(14,  9);\n\n    ADD( 9, 13);\n\n    ADD(13, 11);\n\n    ADD(11, 15);\n\n\n\n    out[ 0] = val0;\n\n    out[16] = val1;\n\n    out[ 8] = val2;\n\n    out[24] = val3;\n\n    out[ 4] = val4;\n\n    out[20] = val5;\n\n    out[12] = val6;\n\n    out[28] = val7;\n\n    out[ 2] = val8;\n\n    out[18] = val9;\n\n    out[10] = val10;\n\n    out[26] = val11;\n\n    out[ 6] = val12;\n\n    out[22] = val13;\n\n    out[14] = val14;\n\n    out[30] = val15;\n\n\n\n    ADD(24, 28);\n\n    ADD(28, 26);\n\n    ADD(26, 30);\n\n    ADD(30, 25);\n\n    ADD(25, 29);\n\n    ADD(29, 27);\n\n    ADD(27, 31);\n\n\n\n    out[ 1] = val16 + val24;\n\n    out[17] = val17 + val25;\n\n    out[ 9] = val18 + val26;\n\n    out[25] = val19 + val27;\n\n    out[ 5] = val20 + val28;\n\n    out[21] = val21 + val29;\n\n    out[13] = val22 + val30;\n\n    out[29] = val23 + val31;\n\n    out[ 3] = val24 + val20;\n\n    out[19] = val25 + val21;\n\n    out[11] = val26 + val22;\n\n    out[27] = val27 + val23;\n\n    out[ 7] = val28 + val18;\n\n    out[23] = val29 + val19;\n\n    out[15] = val30 + val17;\n\n    out[31] = val31;\n\n}\n", "idx": 10699, "substitutes": {"out": ["up", "file", " in", "OUT", "err", "table", "output", "user", "ex", "In", "new", "trial", "temp", "input", "orig", "outs", "io", "doc", "in", "image", "ch", "copy", "opt", "cmd", "obj", "raw", "data", "Out"], "tab": ["ctr", "buf", "table", "pb", "db", "track", "lab", "trial", "sb", "term", "bar", "cb", "temp", "cell", "doc", "test", "ac", "mem", "bb", "ray", "bin", "ab", "buff", "acc", "col", "tx", "reg", "window"], "tmp0": ["tmp6", " buf1", " proc1", " proc6", " buf5", " tmp6", " proc0", " buf0", "tmp5", " buf6", " proc5", " tmp5"], "tmp1": ["temp1", "tmp7", "temp3", "temp01", "tmp01", "j7", "cv3", "j3", "tmp3", "cv1", "cv7", "cv01", "temp7", "j01", "j1"], "val0": ["f00", " val00", "f0", "value2", "f2", "val00", "value00", "value0"], "val1": ["al1", "Val11", "al01", "eval5", "eval11", "al5", "al11", "Val1", "eval01", "Val5", "eval1", "val01", "Val01"], "val2": ["doc2", "eval5", "eval2", "doc4", "el5", "el2", "doc5", "doc22", "el22", "eval4", "el4", "eval22"], "val3": ["val33", "value03", "val03", "eval33", "value33", "value4", " val03", "value3", " val33", "eval4", "eval3", "eval03"], "val4": ["Val4", "Val8", "eval5", "eval6", "Val5", "Val6", "eval4", "eval8"], "val5": ["eval55", "value55", "eval5", "value4", " val55", "val55", "value8", "eval4", "value5", "eval8"], "val6": ["value6", "eval5", "eval6", "al5", "eval16", "value16", "al6", "al16", "value8", "al8", "value5", "eval8"], "val7": ["el8", "vals8", "eval5", "eval17", "vals5", "el5", "el7", "vals7", "eval7", "el17", "eval8", "vals17"], "val8": ["value6", "eval5", "eval6", "eval11", "value8", "value11", "value5", "eval8"], "val9": ["Val11", "Val8", "eval11", "Val9", "Val10", "eval8", "eval10", "eval9"], "val10": ["Val11", "Val8", "al12", "eval12", "eval11", "al11", "Val10", "al10", "Val12", "al8", "eval10", "eval8"], "val11": ["el14", "eval13", "aval13", "eval11", "el13", "aval20", "aval14", "aval11", "eval20", "eval14", "el20", "el11"], "val12": ["eval12", "eval11", "el12", "eval18", "el18", "eval4", "el4", "el11"], "val13": ["eval13", "eval27", "eval16", "valid27", "valid16", "valid10", "eval10", "valid13"], "val14": ["el14", "el16", "eval11", "eval10", "eval16", "el10", "value10", "value16", "value14", "eval14", "value11", "el11"], "val15": ["el15", "el14", "val03", "eval17", "eval15", " val03", "el03", "el17", "eval14", "eval03"], "val16": ["val33", "eval33", "value33", "eval17", " val33", "eval16", "value16", "value8", "value17", "eval8"], "val17": ["al17", "value19", "value10", "value16", "al10", "al16", "al19", "value17"], "val18": ["vals19", "eval11", "eval15", "eval19", "eval18", "vals11", "vals15", "vals18"], "val19": ["eval17", "valid19", "eval19", "eval26", "valid17", "valid25", "valid26", "eval25"], "val20": ["eval13", "vals14", "eval15", "vals13", "value15", "value13", "value20", "vals20", "eval20", "eval14", "value14", "vals15"], "val21": ["el14", "el21", "eval27", "eval21", "eval14", "el23", "el27", "eval23"], "val22": ["el24", "el14", "el32", "valid32", "eval24", "eval32", "eval22", "val32", "eval14", "el22", "valid22", "valid14", "valid24"], "val23": ["value21", "el24", "el21", "value23", "eval23", "value24", "eval24", "el25", "eval25", "eval21", "el23", "value25"], "val24": ["eval27", "eval16", "vals24", "eval24", "al16", "vals16", "vals27", "eval25", "al25", "vals25", "al24", "al27"], "val25": ["el24", "eval15", "eval24", "el25", "eval25", "el26", "eval26", "el15"], "val26": ["eval13", "eval27", "el26", "eval26", "eval18", "el18", "el13", "el27"], "val27": ["value28", "value26", "eval27", "arg28", "value27", "value22", "eval28", "eval22", "arg22", "eval26", "arg27", "arg26"], "val28": ["eval27", "vals23", "eval23", "eval28", "vals27", "eval25", "vals28", "vals25"], "val29": ["al22", "eval24", "eval29", "eval22", "eval14", "al29", "al24", "al14"], "val30": ["eval27", "eval15", "aval30", "eval29", "aval15", "eval30", "aval29", "aval27"], "val31": ["val33", "eval33", "Val31", "Val32", "eval31", "eval32", " val32", "Val21", "Val33", "val32", "eval21", " val33"]}}
{"project": "qemu", "commit_id": "3558f8055f37a34762b7a2a0f02687e6eeab893d", "target": 0, "func": "static inline void gen_op_movl_seg_T0_vm(int seg_reg)\n\n{\n\n    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);\n\n    tcg_gen_st32_tl(cpu_T[0], cpu_env, \n\n                    offsetof(CPUX86State,segs[seg_reg].selector));\n\n    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);\n\n    tcg_gen_st_tl(cpu_T[0], cpu_env, \n\n                  offsetof(CPUX86State,segs[seg_reg].base));\n\n}\n", "idx": 10721, "substitutes": {"seg_reg": ["segm_region", "seg2reg", "seg2REG", "seg1rec", "segm_tag", "seg1tag", "seg1reg", "seG_Reg", "segm_reg", "seg_rec", "seg_REG", "seG_num", "seG_tag", "seg_num", "seg_tag", "seG_rec", "seg_region", "seg2num", "segm_stat", "seG_REG", "seG_reg", "seg2rec", "seg_stat", "seg_Reg", "seg2Reg", "seg1num", "seg2tag"]}}
{"project": "FFmpeg", "commit_id": "5a446bc88e49cc6400d0c646ca1eb540a727c9de", "target": 1, "func": "static void vc1_v_overlap_c(uint8_t* src, int stride)\n\n{\n\n    int i;\n\n    int a, b, c, d;\n\n    int d1, d2;\n\n    int rnd = 1;\n\n    for(i = 0; i < 8; i++) {\n\n        a = src[-2*stride];\n\n        b = src[-stride];\n\n        c = src[0];\n\n        d = src[stride];\n\n        d1 = (a - d + 3 + rnd) >> 3;\n\n        d2 = (a - d + b - c + 4 - rnd) >> 3;\n\n\n\n        src[-2*stride] = a - d1;\n\n        src[-stride] = b - d2;\n\n        src[0] = c + d2;\n\n        src[stride] = d + d1;\n\n        src++;\n\n        rnd = !rnd;\n\n    }\n\n}\n", "idx": 10723, "substitutes": {"src": ["text", "dest", "ctx", "reverse", "host", "comp", "sub", "rc", "split", "gz", "gb", "cc", "sn", "secure", "inst", "target", "ack", "size", "scenes", "supp", "rob", "sq", "conv", "dist", "sr", "sb", "rss", "http", "gl", "ssl", "obl", "img", "grad", "sort", "sc", "sec", "send", "sur", "shift", "usr", "ctr", "buf", "front", "bc", "low", "stat", "config", "cur", "load", "sl", "bs", "fc", "source", "req", "start", "sync", "lib", "u", "support", "scl", "sel", "sup", "cmp", "upload", "cb", "input", "loc", "seed", "st", "url", "core", "uv", "rb", "go", "iv", "spec", "cv", "share", "stack", "scene", "uc", "stream", "data", "slice"], "stride": ["briden", "frside", "stridable", "pridable", "strides", "strside", "trider", "frides", "Striding", "instiding", "instided", "striider", " strides", "instide", "instision", "fride", "arrange", "divided", "intider", "pride", "striode", "frider", "instode", "spidable", " striden", "spider", "arride", "striision", "Strided", " strider", "tride", "hride", "instider", "trside", "Stride", "divide", "intiding", "trides", " strange", "strided", "arrided", "Stridable", "spided", "prider", "Strision", " strision", "hrision", "divider", " striding", "intided", " strside", " strided", "hrided", "striding", "hriding", "Strange", " strode", "prided", "striden", "striide", "strode", "dividen", "arrider", "spide", "Strider", "brided", "strider", "brider", "strange", "strision", "bride", "intide", "briding"], "i": ["ii", "ni", "li", "f", "id", "I", "k", "ip", "oi", "mi", "y", "iu", "is", "ini", "multi", "ri", "p", "si", "pi", "io", "j", "ori", "gi", "ie", "ami", "di", "v", "zi", "bi", "xi", "ti", "qi", "o", "ui", "l", "ci", "u", "index", "m", "e", "n", "info", "ai", "x", "it"], "a": ["ga", "f", "at", "alpha", "ma", "y", "ak", "ca", "an", "ae", "aa", "au", "aaa", "art", "p", "asa", "ar", "A", "fa", "ia", "ac", "r", "da", "af", "aw", "l", "am", "u", "ab", "w", "as", "m", "ast", "e", "n", "pa", "ai", "sa", "ad", "aj", "x", "ba"], "b": ["g", "f", "k", "bc", "y", "db", "lb", "eb", "ca", "sb", "aa", "h", "p", "cb", "bt", "rb", "bs", "bd", "B", "v", "bi", "bb", "r", "o", "l", "u", "ab", "w", "e", "base", "n", "bas", "be", "wb", "s", "ad", "x", "ba"], "c": ["g", "f", "k", "cs", "ce", "y", "ca", "rc", "h", "p", "cy", "cu", "ct", "cc", "z", "v", "C", "ac", "dc", "ch", "r", "o", "l", "cf", "ci", "u", "ab", "w", "m", "e", "n", "cn", "lc", "s", "ad", "cd", "x"], "d": ["g", "f", "k", "D", "y", "md", "db", "ca", "h", "dy", "p", "ds", "ld", "bd", "z", "v", "dd", "dc", "di", "dn", "t", "o", "da", "r", "du", "l", "u", "dx", "w", "m", "e", "n", "s", "ad", "dt", "cd", "x", "dad"], "d1": ["b2", " d81", "c5", "sd1", "d5", "bOne", "fOne", "D1", "d3", "t2", "t3", "f3", "sd3", "t1", "b5", "cone", "done", "t81", "dOne", "f2", "c1", "c2", " done", "D3", "D81", "D2", "c3", " d5", "f1", "sd2", "sdOne", "b3", " d3", "d81", "b1", "f5", "bone"], "d2": ["b2", "l4", " d0", "b0", "l2", "l12", "d0", " d4", "ndtwo", "dd02", "dd2", "Db", "db", " d02", " dtwo", "dd8", "f0", " d8", "d8", "p2", "cb", "b12", " db", "c02", "d02", "D4", "nd2", "f2", "d4", "p1", "c2", " d10", "nd02", "D2", "d10", "f1", "l0", "f10", "p10", "b4", "dtwo", "nd8", "d12", " d12", "c4", "p0", "D02", "ddtwo"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,\n\n                                        QGuestAllocator *alloc, uint16_t entry)\n\n{\n\n    uint16_t vector;\n\n    uint32_t control;\n\n    void *addr;\n\n\n\n    g_assert(d->pdev->msix_enabled);\n\n    addr = d->pdev->msix_table + (entry * 16);\n\n\n\n    g_assert_cmpint(entry, >=, 0);\n\n    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));\n\n    d->config_msix_entry = entry;\n\n\n\n    d->config_msix_data = 0x12345678;\n\n    d->config_msix_addr = guest_alloc(alloc, 4);\n\n\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,\n\n                                                    d->config_msix_addr & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,\n\n                                            (d->config_msix_addr >> 32) & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);\n\n\n\n    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,\n\n                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);\n\n\n\n    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);\n\n    vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);\n\n    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);\n\n}\n", "idx": 10727, "substitutes": {"d": ["g", "dat", "plugin", "de", "dict", "wd", "sd", "f", "id", "k", "D", "xd", "dom", "td", "md", "c", "db", "gd", "ud", "i", "mad", "dr", "pd", "h", "mod", "p", "dos", "der", "ds", "b", "done", "j", "nd", "ld", "ct", "vd", "bd", "z", "di", "dc", "dd", "in", "dn", "t", "df", "da", "du", "l", "old", "q", "od", "m", "dh", "dm", "e", "n", "dj", "s", "fd", "dl", "ad", "data", "dt", "cd", "dad"], "alloc": ["vol", "oca", "hw", "block", "ack", "abc", "loader", "ctx", "src", "ptr", "anc", "buf", "aux", "pl", "ea", "c", "pack", "rc", "config", "arc", "offset", "slot", "loc", "gate", "use", "doc", "access", "ac", "roc", "mac", "val", "win", "sc", "rec", "acc", "org", "oci", "oc", "init", "util", "ec", "sec", "nt", "exec", "rac"], "entry": ["server", "parse", "uri", "prefix", "version", "size", "id", "attribute", "import", "byte", "option", "module", "route", "card", "event", "dr", "config", "rc", "Entry", "offset", "input", "seed", "cell", "ident", "driver", "pair", "ctrl", "enter", "feed", "end", "array", "ie", "address", "code", "record", "image", "row", "inc", "add", "reader", "insert", "length", "r", "command", "error", "start", "index", "ry", "pad", "e", "info", "port", "value", "section", "nt", "sec", "or", "zero", "element", "data", "count", "number", "letter", "slice"], "vector": ["server", "timeout", "version", "uri", "block", "shadow", "vec", "character", "device", "uration", "buf", "letter", "volt", "serial", "output", "connection", "controller", "sequence", "ion", "ault", "config", "document", "collection", "password", "io", "driver", "direction", "position", "array", "address", "v", "header", "reader", "length", "command", "point", "index", "buffer", "Vector", "port", "token", "value", "variable", "zero", "manager", "element", "volume", "number", "counter", "object", "writer"], "control": ["support", "timeout", "block", "rol", "board", "ack", "character", "comment", "state", "update", "ride", "edit", "handle", "output", "roll", "sub", "controller", "sequence", "protected", "ion", "event", "card", "guard", "config", "per", "cell", "io", "driver", "ctrl", "feed", "contact", "rule", "address", "add", "trl", "reader", "oper", "error", "command", "sc", "lib", "form", "forward", "current", "info", "Control", "port", "safe", "controlled", "holder", "variable", "pull", "bug", "data", "object"], "addr": ["hop", "oa", "usr", "ack", "size", "pointer", "rt", "nr", "src", "act", "ptr", "ip", "nc", "host", "eth", "edge", "adr", "md", "module", "adder", "route", "art", "node", "dr", "coord", "ace", "offset", "ort", "order", "ord", "loc", "pkg", "ard", "work", "direction", "vr", "url", "grad", "enter", "ar", "env", "part", "kt", "pair", "address", "end", "dc", "dd", "arm", "add", "layer", "attr", "val", "call", "index", "amd", "od", "nn", "org", "pad", "oc", "nt", "rr", "eni", "Address", "alt", "ad", "hash", "udder", "alias", "align", "x"]}}
{"project": "qemu", "commit_id": "d279279e2b5cd40dbcc863fb66a695990f304077", "target": 1, "func": "static void gen_rdhwr(DisasContext *ctx, int rt, int rd)\n\n{\n\n    TCGv t0;\n\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* The Linux kernel will emulate rdhwr if it's not supported natively.\n\n       Therefore only check the ISA in system mode.  */\n\n    check_insn(ctx, ISA_MIPS32R2);\n\n#endif\n\n    t0 = tcg_temp_new();\n\n\n\n    switch (rd) {\n\n    case 0:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_cpunum(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 1:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_synci_step(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 2:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_cc(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 3:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_ccres(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 29:\n\n#if defined(CONFIG_USER_ONLY)\n\n        tcg_gen_ld_tl(t0, cpu_env, offsetof(CPUMIPSState, tls_value));\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n#else\n\n        /* XXX: Some CPUs implement this in hardware.\n\n           Not supported yet. */\n\n#endif\n\n    default:            /* Invalid */\n\n        MIPS_INVAL(\"rdhwr\");\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 10730, "substitutes": {"ctx": ["cas", "la", "ga", "hw", "linux", "src", "Context", "xc", "anc", "cs", "nc", "connection", "bc", "wcs", "vc", "cci", "c", "sq", "xs", "conv", "ca", "cmp", "jp", "config", "rc", "kb", "sci", "ck", "loc", "pkg", "qa", "cm", "cp", "cu", "ct", "ctrl", "context", "cfg", " context", "kt", "cli", "cc", "coll", "cv", "ch", "cmd", "cf", "conn", "ci", "sc", "sync", "cam", "tx", "obj", "crit", "tc", "cn", "qq", "progress", "lc", "cca", "txt", "exec", "history"], "rt": ["rect", "ann", "format", "ptr", "vt", "RD", "ird", "rat", "ft", "adr", "vc", "RT", "art", "round", "dr", "rc", "ru", "cat", "ort", "rf", "boot", "irt", "rn", "ct", "vr", "pt", "flat", "mt", "rb", "ut", "gt", "rot", "vert", "rx", "r", "br", "ry", "rm", "fit", "xt", "yt", "tt", "rid", "rr", "nt", "rh", "root", "dt", "it"], "rd": ["rw", "respond", "hr", "RD", "RM", "xd", "td", "rg", "addr", "d", "dr", "ru", "rc", "ri", "rl", "ord", "ds", "rn", "RS", "ld", "nd", "rod", "red", "rb", "dc", "dd", "rx", "attr", "dim", "sync", "RR", "rm", "rs", "rid", "rr", "rh", "fd", "dra", "ird", "cd", " RD", "RF"], "t0": ["pt1", " t8", "t100", "p53", "p00", "te00", "at200", "ot5", "T6", "t2", "tt0", "pt00", "t250", "p2", "ten250", "ot1", "ty1", "th0", "kt100", "ty93", "at25", "pNG", "tt00", "temp0", "xNG", "tNG", " t250", "te0", "kt1", "tt1", "ot200", "p93", "attNG", " tNG", "kt255", "t53", "f0", "TNG", " t200", "tt6", "t93", " t00", "p8", " t192", "t050", "T2", "t25", "f250", "T5", "dt0", "at0", "f200", "ot00", " t5", "at53", "kt050", "ten0", "x255", "ten8", "t62", "kt0", "f00", " t25", "T0", "T1", "ot0", "p255", "t8", "at050", " t62", "ty0", "t00", "ktNG", "x1", "th250", "p050", "t1", "ty8", "at00", " t2", "T00", "att1", "temp8", "kt53", " t255", "ot6", "f1", "dt1", "dt8", "th1", "te2", "ptNG", "t200", "f5", " t100", "t192", "at62", "t6", "temp192", "at1", "p62", "t255", "p100", " t1", "te1", "pt2", "att5", "th00", "att0", "p25", "p1", "pt250", "p200", "dt93", "t5", "x0", "p0", "pt0", "ten192", "temp250"]}}
{"project": "qemu", "commit_id": "af01492755b82ccaf0d15014477b34ba3ea643fc", "target": 1, "func": "static void usb_msd_realize_bot(USBDevice *dev, Error **errp)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n\n\n    usb_desc_create_serial(dev);\n\n    usb_desc_init(dev);\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),\n\n                 &usb_msd_scsi_info_bot, NULL);\n\n    s->bus.qbus.allow_hotplug = 0;\n\n    usb_msd_handle_reset(dev);\n\n}\n", "idx": 10735, "substitutes": {"dev": ["debug", "dem", "bus", "prop", "de", "DE", "die", "sd", "pub", "device", "diff", "pro", "self", "dom", "serial", "rad", " Dev", "DEV", "gu", "md", "ver", "gd", "adv", "d", "nov", "new", "ev", "mod", "p", "cur", "development", "plug", "app", "inst", "driver", "Dev", "grad", "prom", "di", "v", "dc", "spec", "dd", "error", "kind", "req", "def", "conn", "od", "cam", "w", "conf", "desc", "ve", "unknown", "init", "info", "obj", "Device", "sk", "priv", "raw", "ad", "bug", "data"], "errp": [" errP", "erp", "rpc", "erpc", " errpc", " errr", "erP", "rr", "rp", "err", "rP", "errpc", "errP", "errr"], "s": ["g", "os", "sym", "f", "args", "src", "service", "cs", "ls", "sf", "side", "ss", "uns", "sq", "c", "is", "i", "sv", "services", "sb", "new", "ts", "p", "sg", "sh", "S", "session", "ds", "fs", "ssl", "sl", "ns", "spec", "us", "o", "ps", "ses", "u", "sync", "gs", "m", "conf", "e", "sys", "su", "rs", "js", "ops", "aws"]}}
{"project": "FFmpeg", "commit_id": "4bb1070c154e49d35805fbcdac9c9e92f702ef96", "target": 0, "func": "static int decode_slice_header(FFV1Context *f, FFV1Context *fs)\n\n{\n\n    RangeCoder *c = &fs->c;\n\n    uint8_t state[CONTEXT_SIZE];\n\n    unsigned ps, i, context_count;\n\n    memset(state, 128, sizeof(state));\n\n\n\n    if (fs->ac > 1) {\n\n        for (i = 1; i < 256; i++) {\n\n            fs->c.one_state[i]        = f->state_transition[i];\n\n            fs->c.zero_state[256 - i] = 256 - fs->c.one_state[i];\n\n        }\n\n    }\n\n\n\n    fs->slice_x      = get_symbol(c, state, 0) * f->width;\n\n    fs->slice_y      = get_symbol(c, state, 0) * f->height;\n\n    fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width + fs->slice_x;\n\n    fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n\n\n\n    fs->slice_x     /= f->num_h_slices;\n\n    fs->slice_y     /= f->num_v_slices;\n\n    fs->slice_width  = fs->slice_width / f->num_h_slices - fs->slice_x;\n\n    fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;\n\n    if ((unsigned)fs->slice_width  > f->width ||\n\n        (unsigned)fs->slice_height > f->height)\n\n        return AVERROR_INVALIDDATA;\n\n    if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width ||\n\n        (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    for (i = 0; i < f->plane_count; i++) {\n\n        PlaneContext *const p = &fs->plane[i];\n\n        int idx               = get_symbol(c, state, 0);\n\n        if (idx > (unsigned)f->quant_table_count) {\n\n            av_log(f->avctx, AV_LOG_ERROR, \"quant_table_index out of range\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        p->quant_table_index = idx;\n\n        memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table));\n\n        context_count = f->context_count[idx];\n\n\n\n        if (p->context_count < context_count) {\n\n            av_freep(&p->state);\n\n            av_freep(&p->vlc_state);\n\n        }\n\n        p->context_count = context_count;\n\n    }\n\n\n\n    ps = get_symbol(c, state, 0);\n\n    if (ps == 1) {\n\n        f->cur->interlaced_frame = 1;\n\n        f->cur->top_field_first  = 1;\n\n    } else if (ps == 2) {\n\n        f->cur->interlaced_frame = 1;\n\n        f->cur->top_field_first  = 0;\n\n    } else if (ps == 3) {\n\n        f->cur->interlaced_frame = 0;\n\n    }\n\n    f->cur->sample_aspect_ratio.num = get_symbol(c, state, 0);\n\n    f->cur->sample_aspect_ratio.den = get_symbol(c, state, 0);\n\n\n\n    if (av_image_check_sar(f->width, f->height,\n\n                           f->cur->sample_aspect_ratio) < 0) {\n\n        av_log(f->avctx, AV_LOG_WARNING, \"ignoring invalid SAR: %u/%u\\n\",\n\n               f->cur->sample_aspect_ratio.num,\n\n               f->cur->sample_aspect_ratio.den);\n\n        f->cur->sample_aspect_ratio = (AVRational){ 0, 1 };\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10738, "substitutes": {"f": ["tf", "file", "ref", "self", "fe", "d", "b", "fm", "fb", "fl", "df", "uf", "form", "e", "fw", "fed", "fen", "fn", "id", "raf", "feature", "h", "http", "rf", "fac", "flat", "fa", "fp", "fx", "s", "of", "flags", "xf", "ff", "sf", "now", "aff", "inf", "y", "ul", "fab", "config", "fc", "v", "r", "_", "l", "cf", "u", "fo", "count", "x", "F", "g", "pos", "fr", "flow", "fi", "new", "function", "full", "feed", "t", "af", "m", "conf", "func", "this", "fd", "bf", "lf"], "fs": ["linux", "tf", "ils", "fts", "vals", "fits", "cs", "ks", "fe", "fps", "ves", "fee", "fm", "fb", "fl", "css", "df", "uf", "gs", "FS", "e", "fw", "rs", "vs", "os", "fn", "ls", "ss", "raf", "uses", "rows", "h", "options", "http", "rf", "ds", "ows", "fp", "ms", "qs", "frames", "fx", "res", "s", "of", "flags", "utils", "xf", "ff", "aux", "sf", "bc", "wcs", "fields", "bs", "fc", "v", "cf", "fo", "sys", "obs", "x", "features", "fr", "faces", "fi", "states", "flows", "es", "ts", "Fs", "full", "files", "feed", "ns", "af", "func", "fd", "bf", "lf", "ops", "cache"], "c": ["g", "chain", "code", "ctx", "abc", "xc", "k", "cs", "nc", "x", "bc", "ce", "vc", "controller", "cycle", "can", "pc", "ca", "y", "co", "d", "config", "h", "arc", "b", "cy", "ic", "cm", "cp", "cu", "ct", "con", "center", "cc", "z", "fc", "C", "dc", "ac", "coll", "cv", "ch", "t", "r", "cl", "v", "l", "cf", "ci", "sc", "conn", "u", "cr", "cus", "q", "m", "com", "conf", "col", "e", "n", "this", "cn", "lc", "mc", "ec", "uc", "s", "cd", "jc", "cache"], "state": ["STATE", "memory", "address", "key", "resource", "area", "form", "e", "size", "pointer", "id", "public", "h", "options", "session", "use", "j", "State", "code", "parent", "length", "conn", "port", "s", "str", "y", "stat", "config", "v", "r", "source", "start", "sync", "u", "body", "current", "null", "name", "count", "version", "type", "local", "states", "private", "instance", "input", "loc", "seed", "st", "object", "style", "context", "core", "rule", "t", "m", "buffer", "component", "this", "data", "slice", "cache"], "ps": [" pos", " flags", " func", " val", " base", " parent", " out", " function", " col", " block", " cache", " cc", " config", " mask", " output", " res", " self", "State", " source", " callback", " frame", " props", " bits", " _", " bc", " q", " code"], "i": ["ii", "axis", "ni", "abi", "li", "uri", "isin", "hi", "id", "phi", "I", "diff", "mu", "ip", "oi", "mi", "fi", "x", "min", "jit", "y", "yi", "iu", "ini", "is", "ei", "multi", "ji", "ri", "ani", "si", "z", "b", "di", "pi", "range", "io", "inner", "j", "gi", "ie", "ami", "key", "in", "ti", "zi", "bi", "xi", "v", "ind", "qi", "ui", "o", "l", "ci", "esi", "u", "index", "m", "ij", "e", "n", "info", "ai", "mini", "eni", "slice", "ix", "it"], "context_count": ["context1counter", "path_len", "context_counter", "path2counter", "context_len", "path_count", "context2len", "path_name", "path2name", "context1len", "path_counter", "context_name", "context2counter", "context2name", "path2len", "context2count", "path2count", "context1name", "context1count"], "p": ["g", "np", "pc", "a", "b", "pi", "cp", "j", "pt", "P", "z", "v", "op", "pe", "r", "o", "l", "q", "pp", "vp", "u", "m", "e", "port", "py"]}}
{"project": "qemu", "commit_id": "b60fae32ff33cbaab76d14cc5f55b979cf58516d", "target": 1, "func": "int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)\n\n{\n\n\n\n    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,\n\n                            sizeof(diag_501), 0) ||\n\n        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,\n\n                            sizeof(diag_501), 1)) {\n\n        return -EINVAL;\n\n    }\n\n    return 0;\n\n}\n", "idx": 10741, "substitutes": {"cs": ["ics", "ctx", "anc", "ls", "nc", "bc", "ce", "wcs", "c", "pc", "ca", "ks", "sb", "rc", "ck", "ds", "cy", "fs", "cp", "cm", "acs", "ct", "CS", "cks", "bs", "cc", "ns", "cms", "ms", "css", "ps", "qs", "cf", "sc", "conn", "ci", "cus", "sync", "cing", "sys", "cn", "lc", "ec", "mc", "sk"], "bp": ["arp", "np", "adj", "tp", "pg", "ctx", "mp", "nb", "bc", "pb", "GP", "bps", "pc", "jp", "eb", "lb", "usb", "sb", "lp", "pd", "config", "cpp", "p", "kb", "sp", "bridge", "b", "fb", "cp", "bg", "bh", "hp", "esp", "gb", "bd", "bsp", "fp", "bb", "br", "gp", "BP", "conn", "pp", "vp", "pa", "bf", "PB", "ba"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,\n\n                                       uint64_t i)\n\n{\n\n    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)\n\n                                    + (i << RDMA_REG_CHUNK_SHIFT));\n\n}\n", "idx": 10744, "substitutes": {"rdma_ram_block": ["rdma_ramxBlock", "rdma_mem_device", "rdma_ramxdevice", "rdma_mem_Block", "rdma_ramxblock", "rdma_ram_device", "rdma_ram_Block", "rdma_ram_type", "rdma_ram_lock", "rdma_mem_lock", "rdma_ramxlock", "rdma_mem_type", "rdma_mem_block"], "i": ["ii", "g", "uri", "f", "phi", "I", "ip", "fi", "x", "c", "iu", "is", "a", "d", "multi", "h", "p", "si", "b", "pi", "io", "j", "gi", "memory", "ti", "v", "bi", "qi", "r", "ui", "l", "ci", "index", "m", "buffer", "e", "ai", "mini", "data", "slice", "ix"]}}
{"project": "FFmpeg", "commit_id": "a1e093a6fb324612266d40e3168a14f58adab265", "target": 0, "func": "static int decode_element(AVCodecContext *avctx, void *data, int ch_index,\n\n                          int channels)\n\n{\n\n    ALACContext *alac = avctx->priv_data;\n\n    int has_size, bps, is_compressed, decorr_shift, decorr_left_weight, ret;\n\n    uint32_t output_samples;\n\n    int i, ch;\n\n\n\n    skip_bits(&alac->gb, 4);  /* element instance tag */\n\n    skip_bits(&alac->gb, 12); /* unused header bits */\n\n\n\n    /* the number of output samples is stored in the frame */\n\n    has_size = get_bits1(&alac->gb);\n\n\n\n    alac->extra_bits = get_bits(&alac->gb, 2) << 3;\n\n    bps = alac->sample_size - alac->extra_bits + channels - 1;\n\n    if (bps > 32) {\n\n        av_log(avctx, AV_LOG_ERROR, \"bps is unsupported: %d\\n\", bps);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    /* whether the frame is compressed */\n\n    is_compressed = !get_bits1(&alac->gb);\n\n\n\n    if (has_size)\n\n        output_samples = get_bits_long(&alac->gb, 32);\n\n    else\n\n        output_samples = alac->max_samples_per_frame;\n\n    if (!output_samples || output_samples > alac->max_samples_per_frame) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid samples per frame: %d\\n\",\n\n               output_samples);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!alac->nb_samples) {\n\n        /* get output buffer */\n\n        alac->frame.nb_samples = output_samples;\n\n        if ((ret = avctx->get_buffer(avctx, &alac->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return ret;\n\n        }\n\n    } else if (output_samples != alac->nb_samples) {\n\n        av_log(avctx, AV_LOG_ERROR, \"sample count mismatch: %u != %d\\n\",\n\n               output_samples, alac->nb_samples);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    alac->nb_samples = output_samples;\n\n    if (alac->direct_output) {\n\n        for (ch = 0; ch < channels; ch++)\n\n            alac->output_samples_buffer[ch] = (int32_t *)alac->frame.extended_data[ch_index + ch];\n\n    }\n\n\n\n    if (is_compressed) {\n\n        int16_t lpc_coefs[2][32];\n\n        int lpc_order[2];\n\n        int prediction_type[2];\n\n        int lpc_quant[2];\n\n        int rice_history_mult[2];\n\n\n\n        decorr_shift       = get_bits(&alac->gb, 8);\n\n        decorr_left_weight = get_bits(&alac->gb, 8);\n\n\n\n        for (ch = 0; ch < channels; ch++) {\n\n            prediction_type[ch]   = get_bits(&alac->gb, 4);\n\n            lpc_quant[ch]         = get_bits(&alac->gb, 4);\n\n            rice_history_mult[ch] = get_bits(&alac->gb, 3);\n\n            lpc_order[ch]         = get_bits(&alac->gb, 5);\n\n\n\n            /* read the predictor table */\n\n            for (i = lpc_order[ch] - 1; i >= 0; i--)\n\n                lpc_coefs[ch][i] = get_sbits(&alac->gb, 16);\n\n        }\n\n\n\n        if (alac->extra_bits) {\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                if(get_bits_left(&alac->gb) <= 0)\n\n                    return -1;\n\n                for (ch = 0; ch < channels; ch++)\n\n                    alac->extra_bits_buffer[ch][i] = get_bits(&alac->gb, alac->extra_bits);\n\n            }\n\n        }\n\n        for (ch = 0; ch < channels; ch++) {\n\n            int ret=rice_decompress(alac, alac->predict_error_buffer[ch],\n\n                            alac->nb_samples, bps,\n\n                            rice_history_mult[ch] * alac->rice_history_mult / 4);\n\n            if(ret<0)\n\n                return ret;\n\n\n\n            /* adaptive FIR filter */\n\n            if (prediction_type[ch] == 15) {\n\n                /* Prediction type 15 runs the adaptive FIR twice.\n\n                 * The first pass uses the special-case coef_num = 31, while\n\n                 * the second pass uses the coefs from the bitstream.\n\n                 *\n\n                 * However, this prediction type is not currently used by the\n\n                 * reference encoder.\n\n                 */\n\n                lpc_prediction(alac->predict_error_buffer[ch],\n\n                               alac->predict_error_buffer[ch],\n\n                               alac->nb_samples, bps, NULL, 31, 0);\n\n            } else if (prediction_type[ch] > 0) {\n\n                av_log(avctx, AV_LOG_WARNING, \"unknown prediction type: %i\\n\",\n\n                       prediction_type[ch]);\n\n            }\n\n            lpc_prediction(alac->predict_error_buffer[ch],\n\n                           alac->output_samples_buffer[ch], alac->nb_samples,\n\n                           bps, lpc_coefs[ch], lpc_order[ch], lpc_quant[ch]);\n\n        }\n\n    } else {\n\n        /* not compressed, easy case */\n\n        for (i = 0; i < alac->nb_samples; i++) {\n\n            if(get_bits_left(&alac->gb) <= 0)\n\n                return -1;\n\n            for (ch = 0; ch < channels; ch++) {\n\n                alac->output_samples_buffer[ch][i] =\n\n                         get_sbits_long(&alac->gb, alac->sample_size);\n\n            }\n\n        }\n\n        alac->extra_bits   = 0;\n\n        decorr_shift       = 0;\n\n        decorr_left_weight = 0;\n\n    }\n\n\n\n    if (channels == 2 && decorr_left_weight) {\n\n        decorrelate_stereo(alac->output_samples_buffer, alac->nb_samples,\n\n                           decorr_shift, decorr_left_weight);\n\n    }\n\n\n\n    if (alac->extra_bits) {\n\n        append_extra_bits(alac->output_samples_buffer, alac->extra_bits_buffer,\n\n                          alac->extra_bits, channels, alac->nb_samples);\n\n    }\n\n\n\n    if(av_sample_fmt_is_planar(avctx->sample_fmt)) {\n\n    switch(alac->sample_size) {\n\n    case 16: {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            int16_t *outbuffer = (int16_t *)alac->frame.extended_data[ch_index + ch];\n\n            for (i = 0; i < alac->nb_samples; i++)\n\n                *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n        }}\n\n        break;\n\n    case 24: {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            for (i = 0; i < alac->nb_samples; i++)\n\n                alac->output_samples_buffer[ch][i] <<= 8;\n\n        }}\n\n        break;\n\n    }\n\n    }else{\n\n        switch(alac->sample_size) {\n\n        case 16: {\n\n            int16_t *outbuffer = ((int16_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        case 24: {\n\n            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i] << 8;\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        case 32: {\n\n            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10750, "substitutes": {"avctx": ["navctx", "afca", "afcup", "avcontext", "Avcf", "AVctx", "avectx", "avcf", "navcontext", "avmac", "Avctx", "AVctl", "avecf", "avalctx", "alconn", " avca", " avdc", "AVlc", "avalbc", "afpkg", "verlc", "vercontext", "avbc", "afmac", " avcontext", "Avcontext", "avlc", "avcup", "verconn", "avpkg", "afbc", "afcf", "afconn", "avalconn", "avca", "AVcf", "avebc", "avalcontext", "avecup", "avemac", "alpkg", "aflc", "navcup", "aveca", "avdc", "verpkg", "AVconn", "verctx", "alctx", "avecontext", "Avctl", "verctl", "AVcontext", "alctl", "avedc", "alcontext", "aveconn", " avmac", " avcf", "navcf", "afctl", "avconn", "afdc", "afctx", "avctl", "navconn", "afcontext", "navctl"], "data": ["dat", "ata", "Data", "api", "connection", "result", "audio", "media", "d", "DATA", "config", "input", "database", "frame", "context", "array", "memory", "image", "parent", "reader", "source", "da", "buffer", "body", "base", "batch", "window", "cache"], "ch_index": ["ch_slice", "ch_level", "chsindex", "ach_slice", "chslevel", "chsIndex", "chsslice", "ach_level", "ach_index", "ch_Index", "chklevel", "chkslice", "chkindex", "chkIndex", "ach_Index"], "channels": ["cords", "Chanes", "tchunks", "cunks", "chanes", "shars", "CHannel", "CHannels", "chunks", "Chars", "compords", "chords", "chars", "shanes", "companes", "compannels", "CHunks", "Chunks", "shunks", "compunks", "cannels", "cars", "shannels", "channel", " channel", "CHapters", " chapters", "Channels", "tchapters", "Chords", "chapters", "tchannel", " chunks", "shords", "tchannels"], "alac": ["alas", "alec", "allanc", "chalacs", "realanc", "balact", "aljac", " alacer", "isalacer", "isalacc", "ralact", "malac", "challas", "alsac", "calac", " alacl", "ellas", "isalAC", "isalacl", "llax", "isaloc", " alacs", " alec", "alsmac", "palacc", " alacc", "alsacc", "elac", "alsacl", "aliac", "alacl", "placc", "chalanc", "isaljac", "aliiac", "balac", "planc", "alax", " aljac", "chalas", "pelax", " alAC", "plac", "unalacc", "isalanc", "alioc", "isalac", "eloc", "calAC", "realac", "elact", "plAC", "calax", "ilac", "ellacc", "alsacs", "alacs", "balmac", "ellac", "eljac", "pelacc", "alacc", "aliacs", "palac", "alianc", "llacc", "elacc", "realacc", " alact", "elmac", "calacs", "llact", "elas", "alanc", "ALAC", " almac", "belacs", "placs", "challacc", "allac", "llac", "baloc", "malacc", "allas", "ralac", "balas", " aloc", "pelac", "balacc", "palacs", "elAC", "challac", "ALac", "allacc", "alsiac", "aliacl", "alsec", "llas", "belacc", "chalac", "caliac", "elanc", "chalacc", " alanc", "plax", "unalax", "calas", "calacc", "aloc", "alsoc", "llanc", "unalmac", "palanc", "pelAC", "alacer", "chalacl", "realacs", "calanc", "calacer", "ralacc", "ALacc", "ralanc", "alact", "ilacc", "belac", "balanc", "ilas", " alax", "aliacc", "challax", "elacs", "almac", "ilanc", "alAC", " alas", "ALacs", "eliac", "calec", "unalac", "ellmac", "calmac", "malmac", "belacl", "maliac"], "has_size": [" has_time", "is_width", "has_count", "has_width", "has67size", "hasRsize", "full_size", "is_size", "has_group", "full_sized", "is_count", "has_sized", " has_group", "has_speed", "hasRwidth", "has_time", "full_speed", "is_sized", "hasRcount", "hasRsized", "has67speed", "has67sized"], "bps": ["apps", "eps", "cases", "prefix", "planes", "bis", "posts", "parts", "bys", "ls", "nb", "items", "pb", "pps", "points", "params", "sb", "lp", "bytes", "fps", "aps", "vs", "lines", "details", "steps", "ips", "blocks", "hops", "allows", "objects", "limits", "bs", "rb", "offs", "bands", "fp", "codes", "prot", "bb", "pieces", "ps", "jobs", "pins", "plugins", "bits", "nets", "lbs", "strings", "bp", "stats", "abytes", "rates", "ops", "tips", "ipes"], "is_compressed": ["is_cressed", "is_Compression", "is_Composed", "is_omposed", "is_compured", "is_ompressed", "is_ompress", "is_compress", "is_compression", "is_cured", "is_supposed", "is_suppured", "is_ompression", "is_suppressed", "is_cress", "is_Compressed", "is_cression", "is_Compress", "is_suppression", "is_suppress", "is_Compured", "is_composed"], "decorr_shift": ["decoris_shift", "decoris_power", "decorr_offset", "decorr\u00b7left", "decorr_power", "decoris_offset", "decorr\u00b7offset", "decoris_left", "decorr_left", "decorr\u00b7shift", "decorr\u00b7power"], "decorr_left_weight": ["decorr_shift_weights", "decorr_left_weights", "decorr_left2weights", "decorr_shift_weight", "decorr_left2weight", "decorr_left2shift", "decorr_shift_shift", "decorr_left2count", "decorr_left_shift", "decorr_shift_count", "decorr_left_count"], "ret": ["valid", "utf", "rets", "ait", "bis", "att", "match", "resp", "re", "rt", "RET", "ref", "format", "rev", "ft", "result", "bc", "success", "len", "mat", "ben", "rc", "cb", "temp", "back", "cur", "arr", "fun", "lit", "ext", "bit", "rb", "mem", "val", "det", "rep", "req", "pet", "def", "get", "buffer", "reply", "fit", "obj", "value", "res", "nt", "reg", "out", "fin", "alt", "Ret", "txt"], "output_samples": ["output_servicesamps", "output_lannels", "output_suffamples", "output_sannels", "output_vamps", "output_tales", "output_Sills", "output_nacks", "output\u00b7servicesamples", "output_outsiles", "output\u00b7samp", "output\u00b7sases", "output_lones", "output_pores", "output_sales", "output_Sessions", "output_damples", "output_asamples", "output_sacks", "output_siles", "output_seample", "output_servicesamples", "output_suamps", "output_Samps", "output\u00b7sonents", "output_tamps", "output_pample", "output_sills", "output_spects", "output_asannels", "output_lacks", "output_sances", "output_lamps", "output_tamples", "output_samps", "output_setsances", "output_assamples", "output_requones", "output_setsamps", "output_pamps", "output_sizes", "output_suffipes", "output_sones", "output\u00b7servicesamps", "output_Sonents", "output_sesamp", "output_setsamples", "output_outsamps", "output_nips", "output_assamps", "output\u00b7samps", "output\u00b7servicesases", "output_nonents", "output_sores", "output_sportsamples", "output_sipes", "output_sonents", "output_sips", "output_servicesessions", "output_sases", "output_requamples", "output_vips", "output_seores", "output\u00b7linesills", "output_vamples", "output_dums", "output_requacks", "output_esases", "output_nances", "output_samp", "output_npects", "output_outsamples", "output_servicesamp", "output\u00b7linesamples", "output_linesonents", "output_requamps", "output_sesances", "output_namp", "output_sesamps", "output_nales", "output_pamples", "output_dipes", "output_lums", "output_lamples", "output_assizes", "output_sample", "output_sportsamps", "output_suample", "output_setsamp", "output_dannels", "output_namps", "output_esamps", "output_nases", "output_sessions", "output_Samples", "output_suamples", "output_suffums", "output_tannels", "output\u00b7linesonents", "output_namples", "output_asales", "output_linesills", "output\u00b7sills", "output_asamps", "output_niles", "output_nizes", "output_suores", "output_vizes", "output_lipes", "output_seamps", "output\u00b7samples", "output_outspects", "output_nones", "output_sportspects", "output_esamp", "output_esamples", "output\u00b7servicesamp", "output_assips", "output_nannels", "output_sums", "output_linesamples", "output_servicesases", "output_sesamples", "output_seamples", "output_suffannels", "output_nills", "output_sportsiles"], "i": ["ii", "f", "I", "k", "ip", "chi", "c", "d", "p", "b", "pi", "io", "j", "z", "v", "bi", "num", "channel", "l", "ci", "e", "n", "base", "ai", "count", "x", "it"], "ch": ["anch", "ph", "Ch", "ctx", "f", "th", "comp", "chi", "length", "chan", "cht", "c", "ver", "cmp", "ech", "arch", "h", "cb", "p", "chip", "sh", "loc", "change", "och", "gh", "app", "cp", "b", "bh", "zh", "j", "cor", "cha", "code", "ich", "ind", "chrom", "channel", "che", "cl", "ach", "cmd", "ci", "q", "conn", "cf", "dev", "l", "col", "conf", "qu", "CH", "child", "sk", "cho", "batch", "mot", "count", "oy", "sch", "cher"]}}
{"project": "FFmpeg", "commit_id": "57cc1ad35fd488c7a879661498f6f3508038d5a9", "target": 0, "func": "static av_always_inline float quantize_and_encode_band_cost_template(\n\n                                struct AACEncContext *s,\n\n                                PutBitContext *pb, const float *in,\n\n                                const float *scaled, int size, int scale_idx,\n\n                                int cb, const float lambda, const float uplim,\n\n                                int *bits, int BT_ZERO, int BT_UNSIGNED,\n\n                                int BT_PAIR, int BT_ESC)\n\n{\n\n    const float IQ = ff_aac_pow2sf_tab[200 + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    const float  Q = ff_aac_pow2sf_tab[200 - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float CLIPPED_ESCAPE = 165140.0f*IQ;\n\n    int i, j, k;\n\n    float cost = 0;\n\n    const int dim = BT_PAIR ? 2 : 4;\n\n    int resbits = 0;\n\n    const float  Q34 = sqrtf(Q * sqrtf(Q));\n\n    const int range  = aac_cb_range[cb];\n\n    const int maxval = aac_cb_maxval[cb];\n\n    int off;\n\n\n\n    if (BT_ZERO) {\n\n        for (i = 0; i < size; i++)\n\n            cost += in[i]*in[i];\n\n        if (bits)\n\n            *bits = 0;\n\n        return cost * lambda;\n\n    }\n\n    if (!scaled) {\n\n        abs_pow34_v(s->scoefs, in, size);\n\n        scaled = s->scoefs;\n\n    }\n\n    quantize_bands(s->qcoefs, in, scaled, size, Q34, !BT_UNSIGNED, maxval);\n\n    if (BT_UNSIGNED) {\n\n        off = 0;\n\n    } else {\n\n        off = maxval;\n\n    }\n\n    for (i = 0; i < size; i += dim) {\n\n        const float *vec;\n\n        int *quants = s->qcoefs + i;\n\n        int curidx = 0;\n\n        int curbits;\n\n        float rd = 0.0f;\n\n        for (j = 0; j < dim; j++) {\n\n            curidx *= range;\n\n            curidx += quants[j] + off;\n\n        }\n\n        curbits =  ff_aac_spectral_bits[cb-1][curidx];\n\n        vec     = &ff_aac_codebook_vectors[cb-1][curidx*dim];\n\n        if (BT_UNSIGNED) {\n\n            for (k = 0; k < dim; k++) {\n\n                float t = fabsf(in[i+k]);\n\n                float di;\n\n                if (BT_ESC && vec[k] == 64.0f) { //FIXME: slow\n\n                    if (t >= CLIPPED_ESCAPE) {\n\n                        di = t - CLIPPED_ESCAPE;\n\n                        curbits += 21;\n\n                    } else {\n\n                        int c = av_clip(quant(t, Q), 0, 8191);\n\n                        di = t - c*cbrtf(c)*IQ;\n\n                        curbits += av_log2(c)*2 - 4 + 1;\n\n                    }\n\n                } else {\n\n                    di = t - vec[k]*IQ;\n\n                }\n\n                if (vec[k] != 0.0f)\n\n                    curbits++;\n\n                rd += di*di;\n\n            }\n\n        } else {\n\n            for (k = 0; k < dim; k++) {\n\n                float di = in[i+k] - vec[k]*IQ;\n\n                rd += di*di;\n\n            }\n\n        }\n\n        cost    += rd * lambda + curbits;\n\n        resbits += curbits;\n\n        if (cost >= uplim)\n\n            return uplim;\n\n        if (pb) {\n\n            put_bits(pb, ff_aac_spectral_bits[cb-1][curidx], ff_aac_spectral_codes[cb-1][curidx]);\n\n            if (BT_UNSIGNED)\n\n                for (j = 0; j < dim; j++)\n\n                    if (ff_aac_codebook_vectors[cb-1][curidx*dim+j] != 0.0f)\n\n                        put_bits(pb, 1, in[i+j] < 0.0f);\n\n            if (BT_ESC) {\n\n                for (j = 0; j < 2; j++) {\n\n                    if (ff_aac_codebook_vectors[cb-1][curidx*2+j] == 64.0f) {\n\n                        int coef = av_clip(quant(fabsf(in[i+j]), Q), 0, 8191);\n\n                        int len = av_log2(coef);\n\n\n\n                        put_bits(pb, len - 4 + 1, (1 << (len - 4 + 1)) - 2);\n\n                        put_bits(pb, len, coef & ((1 << len) - 1));\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (bits)\n\n        *bits = resbits;\n\n    return cost;\n\n}\n", "idx": 10765, "substitutes": {"s": ["g", "os", "utils", "sym", "f", "bis", "service", "parts", "cs", "ls", "self", "ss", "states", "uns", "xs", "c", "a", "ins", "services", "sv", "sb", "p", "ts", "sci", "S", "settings", "session", "outs", "ssl", "sis", "sl", "ns", "hs", "spec", "t", "ps", "sites", "qs", "ses", "sc", "sync", "gs", "conf", "south", "e", "sets", "sys", "comments", "rs", "storage", "strings", "sa", "js", "rates", "ops"], "pb": ["abc", "bm", "pm", "pl", "proc", "mp", "bc", "bps", "pc", "lb", "sb", "lp", "pd", "cpp", "p", "ib", "fb", "cp", "ub", "gb", "rb", "fp", "prot", "wp", "pp", "vp", "ab", "bp", "PB"], "in": ["nin", "binary", "isin", "pass", "f", "id", "err", "inn", "include", "inf", "x", "min", "c", "ini", "a", "quad", "ins", "is", "In", "config", "input", "orig", "arr", "again", "ic", "inner", "con", "v", "image", "IN", "inc", "lin", "source", "bin", "pin", "win", "gin", "q", "index", "rec", "ints", "m", "rin", "query", "circ", "init", "login", "e", "out", "margin", "data", "din", "slice", "str"], "scaled": ["secalled", "SCaling", " scalled", "SCale", "decaling", "oscaled", "escalled", "oscaped", "oscased", "scased", " scided", "Scalled", "oscaling", "secaled", " scaling", "SCaled", "Scaled", "SCalled", "escale", "escaled", "Scased", "escaling", "scided", "scale", "scaling", "secaped", "Scaling", "secaling", "decalled", "Scaped", "scaped", "decaled", "Scale", "oscalled", "decided", "secased", "scalled", "SCided"], "size": ["shift", "pos", "sized", "SIZE", "empty", "global", "mode", "max", "engine", "len", "sq", "c", "small", "si", "sh", "loc", "range", "inner", "shape", "core", "scale", "ize", "code", "z", "Size", "time", "sc", "dim", "sync", "iz", "unit", "six", "sec", "mini", "grade", "sum"], "scale_idx": ["scale_nameci", "scale_idw", "scale_idp", "scale6nameci", "scale6idci", "scale_idsw", "scale_idz", "scale_ridp", "scale_sidz", "scale_idsp", "scale6idx", "scale_sidX", "scale_indx", "scale_midX", "scale_IDn", "scale6idi", "scale_ridw", "scale_sidx", "scale_ridxes", "scale_idci", "scale_idi", "scale_ridi", "scale_IDw", "scale6namexes", "scale_namex", "scale_midz", "scale_ridx", "scale_indi", "scale6idxes", "scale_idc", "scale_IDp", "scale_sidc", "scale_namexes", "scale_midx", "scale_idn", "scale_namei", "scale_idsx", "scale_IDx", "scale_idsn", "scale6namei", "scale_ridci", "scale_indci", "scale_ridn", "scale_idxes", "scale_idX", "scale6namex", "scale_midc", "scale_indxes"], "cb": ["binary", "ctr", "phy", "ctx", "src", "nr", "callback", "nc", "ff", "aff", "nb", "bc", "confirmed", "seq", "len", "c", "db", "cmp", "co", "cgi", "kb", "loc", "b", "fb", "cp", "kk", "ctrl", "cor", "gb", "core", "cfg", "rb", "uv", "code", "cv", "dc", "bb", "abb", "cmd", "cf", "conn", "sync", "buff", "conf", "func", "ob", "cn", "CB", "batch", "bf", "count", "cd", "coord"], "lambda": ["la", "abi", "fn", "abc", "lam", "phi", "mu", "aux", "LA", "appa", "alpha", "seq", "sq", "quad", "xy", "beta", "function", "qa", "fun", " beta", "lim", "boost", "partial", "kl", "z", "bb", "cl", "da", "std", "wave", "wa", "func", " gamma", "dB", "data", "igma", "slice", "acl"], "uplim": ["uPLime", "uiplime", " uplime", "uPlime", " uplims", " uplength", "uPLength", "uiplim", "uplims", "uPLim", "uplength", "uPlength", " uPLim", "uiplims", "uplime", " uPLims", "uiplength", "uPLims", " uPLime", "uPlims", "uPlim", " uPLength"], "bits": ["flags", "utils", "planes", "cycles", "bugs", "groups", "parts", "its", "weights", "checks", "ids", "items", "ins", "rows", "flows", "bytes", "works", "fps", "steps", "ips", "blocks", "bit", "limits", "forces", "bands", "bs", "pieces", "reads", "hours", "frames", "jobs", "plugins", "pins", "ints", "lbs", "lins", "holes", "ops", "features"], "BT_ZERO": ["BT_ZEERO", "BT_ZEAME", "BT_READIVE", "BT_AZONE", "BT_ZONE", "BT_ZEIVE", "BT_ZOK", "BT_CCOK", "BT_CCONE", "BT_READAME", "BT_ZIVE", "BT_CCOW", "BT_AZOK", "BT_ZOW", "BT_READONE", "BT_ZAME", "BT_READERO", "BT_AZOW", "BT_AZERO", "BT_CCERO", "BT_ZEONE"], "BT_UNSIGNED": ["BT_UNSIGNLED", "BT_UNFEED", "BT_UNFEed", "BT_UNFINING", "BT_UNSIGNRED", "BT_OUTSIGNED", "BT_OUTCCMED", "BT_UNSignED", "BT_OUTSIGNLED", "BT_UNSignITED", "BT_OUTCCLED", "BT_UNCEPTRED", "BT_UNCCLED", "BT_UNCEPTED", "BT_UNSIGNITED", "BT_UNSignAL", "BT_UNSIGNed", "BT_UNFORMRED", "BT_UNFORMMED", "BT_UNSIGNING", "BT_OUTSIGNRED", "BT_OUTCCRED", "BT_OUTCCED", "BT_UNSignING", "BT_UNCCRED", "BT_UNFEAL", "BT_UNSIGNAL", "BT_UNFEITED", "BT_UNCEPTMED", "BT_UNFINed", "BT_UNFORMED", "BT_UNSIGNMED", "BT_UNSIGNIFIED", "BT_UNSignIFIED", "BT_UNCEPTLED", "BT_UNFORMLED", "BT_UNFINED", "BT_OUTSIGNMED", "BT_UNCCMED", "BT_UNCCED", "BT_UNFINIFIED", "BT_UNSigned"], "BT_PAIR": ["BT_PIX", "BT_PAVEL", "BT_PAAR", "BT_MAAR", "BT_BAUSE", "BT_PIR", "BTTIMEPAUSE", "BTTIMEWAIR", "BTTIMEPAIR", "BT_PAUSE", "BT_MAIX", "BTTIMEPAULL", "BT_PAULL", "BT_BAVEL", "BT_FAULL", "BT_CAIR", "BT_WAULL", "BT_FAIX", "BT_FAIR", "BT_WAVEL", "BT_FAAR", "BT_PAR", "BT_CAUSE", "BT_MAIR", "BT_MAULL", "BTTIMEWAUSE", "BT_WAUSE", "BTTIMEWAULL", "BT_PULL", "BT_BAULL", "BT_CAVEL", "BT_WAIR", "BT_CAULL", "BT_BAIR", "BTTIMEWAVEL", "BT_PAIX", "BTTIMEPAVEL"], "BT_ESC": ["BT_ESCC", "BT_ESCENT", "BT_USC", "BT_ESCI", "BT_EXC", "BT_DESCC", "BT_USCC", "BT_EXCC", "BT_DESC", "BT_USCI", "BT_DESCENT", "BT_EXCENT", "BT_USCENT", "BT_DESCI", "BT_EXCI"], "i": ["ii", "ni", "pos", "li", "uri", "im", "f", "id", "phi", "I", "ip", "oi", "mi", "fi", "chi", "y", "c", "yi", "ki", "iu", "ini", "d", "multi", "h", "ji", "p", "ri", "slice", "ani", "si", "b", "pi", "io", "inner", "ori", "uli", "gi", "ie", "z", "zi", "xi", "bi", "qi", "ti", "ui", "ik", "ind", "v", "o", "l", "ci", "q", "dim", "index", "u", "m", "my", "n", "info", "e", "ai", "eni", "x", "ix", "it"], "j": ["ii", "g", "pos", "li", "fr", "adj", "other", "err", "je", "jo", "x", "jet", "y", "jit", "uj", "jp", "ja", "d", "h", "ji", "p", "ani", "b", "rem", "kj", "jl", "ld", "pt", "part", "key", "z", "v", "ch", "num", "J", "o", "r", "br", "rel", "qi", "ind", "l", "old", "q", "m", "ij", "e", "n", "obj", "jj", "dj", "js", "aj", "syn", "jc"], "k": ["ok", "g", "f", "max", "ke", "K", "y", "ki", "p", "b", "kk", "key", "z", "v", "o", "r", "ik", "km", "q", "u", "w", "m", "e", "n", "sk", "x"], "off": ["shift", "pos", "Off", "block", "no", "OFF", "on", "offer", "mode", "id", "flow", "online", "ref", "err", "ff", "ov", "now", "low", "eff", "function", "loss", "offset", "order", "orig", "ord", "fun", "and", "load", "bit", "end", "offs", "loop", "op", "over", "down", "o", "opt", "error", "cmd", "def", "dev", "info", "out", "raw", "none", "of", "alt", "cost"], "vec": ["buf", "fi", "seq", "vc", "len", "cycle", "vel", "xy", "expr", "arr", "factor", "flat", "cube", "vector", "spec", "cv", "rx", "opt", "def", "vp", "func", "init", "xp", "var", "vv", "window", "feat"], "quants": [" quANT", "acquands", "aquands", "acquant", "quats", "aquANT", "aquats", "acquants", "QUands", "aquants", "acquats", " quant", "quANT", "aquant", "QUants", "quands", " quats", "quant", "QUANT", "QUant", " quands"], "curbits": [" curits", "culpits", "cuspals", "curbals", "curit", " curbit", "curbites", "cuspits", "cuspites", "cuspit", "culpit", "cubit", "cubits", " curites", "scurbites", " curbites", " curit", "culpals", "culpites", "cubites", "curits", "cubals", " curals", "sculpals", "sculpit", "curals", "sculpites", "scurbit", "curbit", " curbals", "sculpits", "scurbits", "curites", "scurbals"]}}
{"project": "FFmpeg", "commit_id": "ba571f6b4d15a998d6fde387509cd84177fccd96", "target": 0, "func": "static void event_loop(VideoState *cur_stream)\n\n{\n\n    SDL_Event event;\n\n    double incr, pos, frac;\n\n\n\n    for(;;) {\n\n        double x;\n\n        SDL_WaitEvent(&event);\n\n        switch(event.type) {\n\n        case SDL_KEYDOWN:\n\n            if (exit_on_keydown) {\n\n                do_exit(cur_stream);\n\n                break;\n\n            }\n\n            switch(event.key.keysym.sym) {\n\n            case SDLK_ESCAPE:\n\n            case SDLK_q:\n\n                do_exit(cur_stream);\n\n                break;\n\n            case SDLK_f:\n\n                toggle_full_screen(cur_stream);\n\n                break;\n\n            case SDLK_p:\n\n            case SDLK_SPACE:\n\n                if (cur_stream)\n\n                    toggle_pause(cur_stream);\n\n                break;\n\n            case SDLK_s: //S: Step to next frame\n\n                if (cur_stream)\n\n                    step_to_next_frame(cur_stream);\n\n                break;\n\n            case SDLK_a:\n\n                if (cur_stream)\n\n                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_AUDIO);\n\n                break;\n\n            case SDLK_v:\n\n                if (cur_stream)\n\n                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_VIDEO);\n\n                break;\n\n            case SDLK_t:\n\n                if (cur_stream)\n\n                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_SUBTITLE);\n\n                break;\n\n            case SDLK_w:\n\n                if (cur_stream)\n\n                    toggle_audio_display(cur_stream);\n\n                break;\n\n            case SDLK_LEFT:\n\n                incr = -10.0;\n\n                goto do_seek;\n\n            case SDLK_RIGHT:\n\n                incr = 10.0;\n\n                goto do_seek;\n\n            case SDLK_UP:\n\n                incr = 60.0;\n\n                goto do_seek;\n\n            case SDLK_DOWN:\n\n                incr = -60.0;\n\n            do_seek:\n\n                if (cur_stream) {\n\n                    if (seek_by_bytes) {\n\n                        if (cur_stream->video_stream >= 0 && cur_stream->video_current_pos>=0){\n\n                            pos= cur_stream->video_current_pos;\n\n                        }else if(cur_stream->audio_stream >= 0 && cur_stream->audio_pkt.pos>=0){\n\n                            pos= cur_stream->audio_pkt.pos;\n\n                        }else\n\n                            pos = avio_tell(cur_stream->ic->pb);\n\n                        if (cur_stream->ic->bit_rate)\n\n                            incr *= cur_stream->ic->bit_rate / 8.0;\n\n                        else\n\n                            incr *= 180000.0;\n\n                        pos += incr;\n\n                        stream_seek(cur_stream, pos, incr, 1);\n\n                    } else {\n\n                        pos = get_master_clock(cur_stream);\n\n                        pos += incr;\n\n                        stream_seek(cur_stream, (int64_t)(pos * AV_TIME_BASE), (int64_t)(incr * AV_TIME_BASE), 0);\n\n                    }\n\n                }\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n            break;\n\n        case SDL_MOUSEBUTTONDOWN:\n\n            if (exit_on_mousedown) {\n\n                do_exit(cur_stream);\n\n                break;\n\n            }\n\n        case SDL_MOUSEMOTION:\n\n            if(event.type ==SDL_MOUSEBUTTONDOWN){\n\n                x= event.button.x;\n\n            }else{\n\n                if(event.motion.state != SDL_PRESSED)\n\n                    break;\n\n                x= event.motion.x;\n\n            }\n\n            if (cur_stream) {\n\n                if(seek_by_bytes || cur_stream->ic->duration<=0){\n\n                    uint64_t size=  avio_size(cur_stream->ic->pb);\n\n                    stream_seek(cur_stream, size*x/cur_stream->width, 0, 1);\n\n                }else{\n\n                    int64_t ts;\n\n                    int ns, hh, mm, ss;\n\n                    int tns, thh, tmm, tss;\n\n                    tns = cur_stream->ic->duration/1000000LL;\n\n                    thh = tns/3600;\n\n                    tmm = (tns%3600)/60;\n\n                    tss = (tns%60);\n\n                    frac = x/cur_stream->width;\n\n                    ns = frac*tns;\n\n                    hh = ns/3600;\n\n                    mm = (ns%3600)/60;\n\n                    ss = (ns%60);\n\n                    fprintf(stderr, \"Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d)       \\n\", frac*100,\n\n                            hh, mm, ss, thh, tmm, tss);\n\n                    ts = frac*cur_stream->ic->duration;\n\n                    if (cur_stream->ic->start_time != AV_NOPTS_VALUE)\n\n                        ts += cur_stream->ic->start_time;\n\n                    stream_seek(cur_stream, ts, 0, 0);\n\n                }\n\n            }\n\n            break;\n\n        case SDL_VIDEORESIZE:\n\n            if (cur_stream) {\n\n                screen = SDL_SetVideoMode(event.resize.w, event.resize.h, 0,\n\n                                          SDL_HWSURFACE|SDL_RESIZABLE|SDL_ASYNCBLIT|SDL_HWACCEL);\n\n                screen_width = cur_stream->width = event.resize.w;\n\n                screen_height= cur_stream->height= event.resize.h;\n\n            }\n\n            break;\n\n        case SDL_QUIT:\n\n        case FF_QUIT_EVENT:\n\n            do_exit(cur_stream);\n\n            break;\n\n        case FF_ALLOC_EVENT:\n\n            video_open(event.user.data1);\n\n            alloc_picture(event.user.data1);\n\n            break;\n\n        case FF_REFRESH_EVENT:\n\n            video_refresh(event.user.data1);\n\n            cur_stream->refresh=0;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 10767, "substitutes": {"cur_stream": ["curplesource", "prev_object", " cur_steam", "ur_sample", "curvalstream", "cour_surface", "curxform", "courUstick", "curthesteam", "currsample", "Cur_transform", "cur1stream", "cur_model", "curgsurface", "cour_thread", "cur__form", " cur_speed", "Cur_model", "cur_transform", "cour_design", "curacsteam", "cur_host", "cur_engine", "tur1source", "pr_surface", "courUsurface", "public_stream", "ser_thread", "curvalsurface", "curvalsteam", "rah_stream", "prev_stream", "courUstream", "curplesteam", "pr_steam", "cursthread", "ser_stream", "curalthread", "cour_stream", "cour_stick", "cur_sound", "cur1form", "ser_speed", "pull_system", "curUstick", "cur_row", "pr_stream", "cur_cloud", " cur_thread", "curplestream", "cur1source", "pullUsurface", "currsw", "cur__stream", "curxtrack", "pullUsteam", "cur_form", "public_steam", "pullUstream", "prev_track", "cour_source", "currstream", " cur_track", "curappclean", "cur_sw", "curaldesign", "publictheenc", "curfsurface", "prev_thread", "cur_slice", "cur_stick", "cur_client", "cour_cloud", "tur1sound", "curtheform", "currform", "cur__steam", "curacstream", "curkthread", " cur_stem", "curxstream", "cour_form", "curappform", "tur_stream", "curksurface", "curssteam", "Cur_cloud", "curacmodel", "tur_source", "cursstream", "curUsurface", "curfsteam", "courUengine", "curksteam", "cur1sound", "prvalsurface", "curksystem", "curalstream", "curxstem", "curappcloud", "prvalstream", "curplesound", "cur_speed", "curthestream", "cour_client", "curkspeed", "pull_thread", "Cur_stream", "cur_thread", "pull_sound", "pull_sw", "ser_system", "publicthestream", "curtheenc", "pullUsystem", "public_enc", "cur_surface", "public_form", "curacsurface", "cour_system", "curssource", "pull_stream", "cur_steam", "curUstream", "curacsystem", "curvalslice", "curappstream", "pull_steam", "Cur_form", "rah_form", " cur_clean", "Cur_clean", "curfstream", "rah_row", "tur_sound", " cur_form", "curgstick", "curkstream", "ur_sw", "curUsystem", "curgstream", "publicthesteam", "cur_enc", "cur_track", "cur_source", "curUsteam", "cur_clean", "curgengine", " cur_source", "cur_system", "cour_host", "curfslice", "pr_slice", "cursform", "cur1thread", "curacform", "curUengine", "ur_stream", "tur1stream", "cur__speed", "cur_sample", "cur_stem", "cur_object", "cour_engine", "pull_source", "pull_surface", "prvalsteam", "ur_form", "publictheform", "curactransform", "cur_design", "curalhost", "prvalslice", "rah_sample"], "event": ["g", "message", "text", "empty", "type", "f", "events", "comment", "vent", "view", "xml", "ception", "update", "self", "exc", "result", "ce", "c", "instance", "an", "feature", "node", "esc", "ev", "condition", "ent", "input", "change", "advert", "load", "style", "test", "end", "key", "in", "address", "ee", "image", "press", "pe", "entry", "t", "error", "val", "handler", "command", "call", "form", "e", "ge", "entity", "ec", " Event", "name", "bug", "element", "data", "exec", "object", "Event"], "incr": ["accr", "infrl", " incrb", "indrum", "accl", "integrs", "discra", "Incre", "Incr", "encra", "Incerr", "inderr", "integr", "incl", " incrs", "integerr", "accra", "intr", " incre", "encl", "encp", "accp", "infpr", "Incrb", "imprs", "infr", "intre", " incp", "incrb", "indrs", "imperr", "incra", "incp", "imprum", "discpr", "incpr", "incrl", "incrs", " incra", "intrs", "incerr", "discrl", "encr", "encrl", "integre", " incrum", "impr", "encerr", "encpr", "incre", "encrb", "interr", " incl", "encre", "discr", "incrum", " incerr", "indr", "infra"], "pos": ["axis", "os", "POS", "pass", "Pos", "block", "prop", "pointer", "type", "resp", "diff", "limit", "ref", "pl", "len", "pc", "cache", "patch", "config", "pr", "p", "offset", "slice", "slot", "sp", "loc", "style", "position", "pt", "end", "part", "po", "fat", "pres", "spec", "rot", "push", "ind", "rel", "val", "all", "area", "def", "start", "index", "cond", "sum", "next", "vol", "conf", "col", "unit", "port", "space", "fin", "feat", "location", "pid", "str"], "frac": ["abc", "format", "callback", "ref", "exc", "cut", " circ", "alpha", "rc", "fre", "qa", "fun", "bit", "fc", "ac", " fraction", "count", "win", "angle", " delta", "circ", "unit", "sec", "cap", "repeat", "window", "feat"], "x": ["xe", "xf", "f", " tx", "xc", "wx", "y", "c", "X", "ex", "xa", "xy", "d", " cx", "b", "ct", " X", "z", "rx", "index", "xx", "w", "m", "xp", " dx"]}}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "static int sox_read_packet(AVFormatContext *s,\n\n                           AVPacket *pkt)\n\n{\n\n    int ret, size;\n\n\n\n    if (url_feof(s->pb))\n\n        return AVERROR_EOF;\n\n\n\n    size = SOX_SAMPLES*s->streams[0]->codec->block_align;\n\n    ret = av_get_packet(s->pb, pkt, size);\n\n    if (ret < 0)\n\n        return AVERROR(EIO);\n\n\n    pkt->stream_index = 0;\n\n    pkt->size = ret;\n\n\n\n    return 0;\n\n}", "idx": 10772, "substitutes": {"s": ["g", "os", "sym", "f", "service", "cs", "ls", "self", "sf", "ss", "xs", "c", "sq", "is", "ks", "a", "services", "sv", "sb", "es", "p", "ts", "http", "si", "S", "ds", "b", "settings", "ssl", "sl", "ns", "less", "v", "spec", "us", "o", "t", "qs", "ses", "sc", "sync", "gs", "m", "south", "e", "sets", "sys", "js", "stats", "ops", "aws"], "pkt": ["ppct", " packet", " peth", "pct", "ppkt", "ppeth", "Pct", "packet", "Peth", "Pkt", "spacket", "Packet", "ppnt", " pct", "Pnt", "Pet", "peth", "pnt", "pet", " pnt", "spet", "spct", " pet", "ppacket", "spkt"], "ret": ["sur", "g", "rt", "rets", "f", "id", "format", "re", "RET", "ft", "result", "success", " reply", "len", "en", "sr", "sb", "rc", "offset", "ner", " result", "lit", "fun", "ext", "flag", "nl", "mt", "bit", "fat", "code", "mem", "num", "t", "el", "val", "r", "_", "get", "length", "def", "bf", "reply", "xt", "obj", " len", "value", "res", "nt", "reg", "fin", "alt", "Ret", "status", "data", "count", "number", "read"], "size": ["big", "SIZE", "version", "capacity", "empty", "sent", "f", "args", "file", "max", "weight", "handle", "len", "write", "en", "small", "esc", "bytes", "enc", "offset", "content", "si", "fee", "loc", "full", "shape", "style", "ext", "scale", "fat", "ize", "address", "code", "Size", "num", "el", "val", "length", "channel", "sn", "body", "fit", "iz", "e", "unit", "large", "sec", "name", "send", "data", "count", "x", "sum"]}}
{"project": "FFmpeg", "commit_id": "d094052c8e8a036666ac02bfc52bf221ad39e4c8", "target": 1, "func": "static av_cold int svq1_encode_init(AVCodecContext *avctx)\n\n{\n\n    SVQ1Context * const s = avctx->priv_data;\n\n\n\n    dsputil_init(&s->dsp, avctx);\n\n    avctx->coded_frame= (AVFrame*)&s->picture;\n\n\n\n    s->frame_width = avctx->width;\n\n    s->frame_height = avctx->height;\n\n\n\n    s->y_block_width = (s->frame_width + 15) / 16;\n\n    s->y_block_height = (s->frame_height + 15) / 16;\n\n\n\n    s->c_block_width = (s->frame_width / 4 + 15) / 16;\n\n    s->c_block_height = (s->frame_height / 4 + 15) / 16;\n\n\n\n    s->avctx= avctx;\n\n    s->m.avctx= avctx;\n\n\n    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));\n\n    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));\n\n    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));\n\n    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));\n\n    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));\n\n    h263_encode_init(&s->m); //mv_penalty\n\n\n\n    return 0;\n\n}", "idx": 10773, "substitutes": {"avctx": ["avcas", "avcf", "ajcas", "afpkg", "avecfg", "avecv", "aucmp", "svcu", "avqa", "auctx", "afcb", "afcu", "avepkg", "afcfg", "svcontext", "avectl", "avcv", "averctrl", "AVcu", "avecas", "ajcp", "avectx", " avcu", "ajcontext", "avcmd", "avercmp", "avercv", "averctx", " avcmp", "afcp", "avalcontext", "ajcfg", "avecontext", "avalcb", "AVcontext", "svctx", "avctrl", "avalctrl", "avercmd", "avctl", "ajcf", "avcfg", "afcontext", "svctl", "ajcmp", "AVctx", "AVctl", "averlc", "avecp", "avlc", "aucv", "aucontext", "avpkg", "avercontext", "AVcmp", "ajctx", "aucmd", "avecmp", "ajpkg", " avcf", "afctx", "afcmp", "avcp", "ajcu", "aucb", "avcmp", "avcontext", "avecf", "avalctx", "avcb", "AVlc", "afcas", "avecu", "avalqa", "avcu", "auqa", "afcf", "AVcf", "avecmd", "afqa", "AVctrl", "avallc"], "s": ["sym", "service", "ats", "cs", "self", "c", "a", "i", "ks", "d", "lines", "erences", "b", "settings", "hs", "sites", "gs", "w", "com", "as", "e", "rs", "strings", "js", "vs", "sum", "os", "site", "its", "ls", "ss", "uses", "ins", "rows", "h", "S", "session", "ds", "fs", "ssl", "ms", "ans", "o", "ses", "qs", "changes", "f", "parts", "xs", "y", "an", "services", "sg", "details", "bs", "v", "ions", "r", "ps", "l", "sync", "u", "sys", "su", "features", "g", "args", "side", "states", "uns", "is", "comm", "es", "p", "ts", "si", "ns", "spec", "us", "t", "your", "m", "conf", "n", "sets", "storage", "sa", "ops", "aws"]}}
{"project": "qemu", "commit_id": "d02f8adc6d2a178bcbf77d0413f9a96fdbed53f0", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n\n{\n\n    AHCICmdHdr *cmd = ad->cur_cmd;\n\n    uint32_t opts = le32_to_cpu(cmd->opts);\n\n    uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;\n\n    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;\n\n    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    int sum = 0;\n\n    int off_idx = -1;\n\n    int off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    if (!sglist_alloc_hint) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (sglist_alloc_hint > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);\n\n            if (offset <= (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %d\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (sglist_alloc_hint - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos),\n\n                        le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);\n\n\n\n        for (i = off_idx + 1; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            le32_to_cpu(tbl[i].flags_size) + 1);\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 10801, "substitutes": {"ad": ["dat", "adh", "wd", "at", "att", "id", "api", "ada", "aed", "rad", "addr", "md", "ud", "al", "a", "pc", "art", "mad", "d", "db", "quad", "an", "ade", "p", "ace", "ed", "ang", "http", "ass", "ag", "ld", "end", "bd", "ads", "add", "ac", "dc", "ay", "client", "dd", "aud", "bb", "ap", "jad", "ab", "ady", "admin", "od", "edd", "pad", "dev", "AD", "Ad", "exec", "pod", "post"], "sglist": [" sGLIST", "sgelst", "sGList", "sgnister", "sgnIST", "sgelist", " sGLister", " sglister", "sgnst", " sglst", "sGLister", "sgelister", " sglIST", "sgelIST", "sGLst", "sglister", "sGLIST", "sglst", " sGList", "sglIST", "sgnist", " sGLst"], "offset": ["padding", "pos", "timeout", "prefix", "size", "type", "f", "attribute", "limit", "ref", "addr", "alpha", "len", "off", "config", "p", "slot", "reset", "si", "loc", "range", "align", "position", "end", "Offset", "part", "address", "entry", "num", "length", "o", "r", "start", "index", "pad", "delay", "origin", "set", "data", "amount", "number", "location", "skip", "sum"], "cmd": ["MD", "ctx", "proc", "rad", "addr", "md", "c", "cmp", "d", "node", "comm", "config", "cat", "mod", "dr", "cb", "pkg", "cp", "ctrl", "grad", "ht", "cfg", "code", "op", "dc", "client", "cl", "mac", "command", "req", "def", "conn", "head", "od", "pad", "cod", "ctl", "Cmd", "cd", "dad"], "prdt": ["PRds", "PRdt", "prds", "prtd", "prta", "brds", " prds", "brtd", "prDT", "prodt", "PrDT", "prt", "protd", "Prt", "brdt", "PRtd", "PRqt", "Prqt", "Prta", " prta", "frta", "prqt", "proDT", "prot", " prt", "frtd", " prqt", "Prdt", "brqt", "Prtd", " prDT", "frdt", "frqt", " prtd"], "i": ["ii", "pos", "ni", "li", "uri", "abi", "hi", "f", "phi", "I", "k", "mu", "ip", "oi", "mi", "fi", "chi", "y", "len", "c", "ki", "iu", "ini", "yi", "d", "multi", "ri", "p", "si", "b", "pi", "io", "j", "gi", "ie", "ami", "z", "v", "xi", "bi", "di", "ti", "qi", "r", "o", "ui", "t", "ind", "l", "ci", "u", "index", "m", "e", "n", "info", "ai", "mini", "eni", "x", "ix", "it"], "tbl_entry_size": ["tbl_Entry_sum", "tbl_offset_size", "tbl_Entry_size", "tbl_entry_count", "tbl_offset_count", "tbl_row_len", "tbl_entry_len", "tbl_offset_len", "tbl_entry_sum", "tbl_Entry_len", "tbl_entry_pos", "tbl_row_pos", "tbl_row_size"], "bus": ["pos", "pass", "block", "board", "type", " buses", "service", "state", "BUS", "class", "proc", "serial", "connection", "bc", "vc", "c", "ux", "route", "usb", "pu", "config", "cat", "p", "bridge", "boot", "b", "plug", "io", "feed", "Bus", "hub", "us", "proxy", "dev", "brid", "used", "base", "las", "port", "bug", "cache"], "qbus": ["Qboot", "sqboot", "Qdi", "dqbus", "dqBus", "qboot", "dqboot", "qdi", "QBus", "sqbus", "Qbus", "dqdi", "sqdi", "qBus", "sqBus"], "tbl": ["rbl", "bcol", " tcol", "fBL", "TBL", "itBL", "tuple", "Tbl", " till", "tcol", "till", "itcol", "fuple", "bBL", "fpl", "Tpl", "rpl", "Tuple", " tBL", "bill", "rBL", "fbl", "bbl", "itill", "ruple", "itbl", "tBL", "tpl"]}}
{"project": "FFmpeg", "commit_id": "9b6aafba6c06ef62783dd5e9c5ed668f3a095128", "target": 1, "func": "static av_always_inline void mpeg_motion_lowres(MpegEncContext *s,\n\n                                                uint8_t *dest_y,\n\n                                                uint8_t *dest_cb,\n\n                                                uint8_t *dest_cr,\n\n                                                int field_based,\n\n                                                int bottom_field,\n\n                                                int field_select,\n\n                                                uint8_t **ref_picture,\n\n                                                h264_chroma_mc_func *pix_op,\n\n                                                int motion_x, int motion_y,\n\n                                                int h, int mb_y)\n\n{\n\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n\n    int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, uvlinesize, linesize, sx, sy,\n\n        uvsx, uvsy;\n\n    const int lowres     = s->avctx->lowres;\n\n    const int op_index   = FFMIN(lowres, 2);\n\n    const int block_s    = 8>>lowres;\n\n    const int s_mask     = (2 << lowres) - 1;\n\n    const int h_edge_pos = s->h_edge_pos >> lowres;\n\n    const int v_edge_pos = s->v_edge_pos >> lowres;\n\n    linesize   = s->current_picture.f.linesize[0] << field_based;\n\n    uvlinesize = s->current_picture.f.linesize[1] << field_based;\n\n\n\n    // FIXME obviously not perfect but qpel will not work in lowres anyway\n\n    if (s->quarter_sample) {\n\n        motion_x /= 2;\n\n        motion_y /= 2;\n\n    }\n\n\n\n    if (field_based) {\n\n        motion_y += (bottom_field - field_select) * (1 << lowres - 1);\n\n    }\n\n\n\n    sx = motion_x & s_mask;\n\n    sy = motion_y & s_mask;\n\n    src_x = s->mb_x * 2 * block_s + (motion_x >> lowres + 1);\n\n    src_y = (mb_y * 2 * block_s >> field_based) + (motion_y >> lowres + 1);\n\n\n\n    if (s->out_format == FMT_H263) {\n\n        uvsx    = ((motion_x >> 1) & s_mask) | (sx & 1);\n\n        uvsy    = ((motion_y >> 1) & s_mask) | (sy & 1);\n\n        uvsrc_x = src_x >> 1;\n\n        uvsrc_y = src_y >> 1;\n\n    } else if (s->out_format == FMT_H261) {\n\n        // even chroma mv's are full pel in H261\n\n        mx      = motion_x / 4;\n\n        my      = motion_y / 4;\n\n        uvsx    = (2 * mx) & s_mask;\n\n        uvsy    = (2 * my) & s_mask;\n\n        uvsrc_x = s->mb_x * block_s + (mx >> lowres);\n\n        uvsrc_y =    mb_y * block_s + (my >> lowres);\n\n    } else {\n\n        mx      = motion_x / 2;\n\n        my      = motion_y / 2;\n\n        uvsx    = mx & s_mask;\n\n        uvsy    = my & s_mask;\n\n        uvsrc_x = s->mb_x * block_s                 + (mx >> lowres + 1);\n\n        uvsrc_y =   (mb_y * block_s >> field_based) + (my >> lowres + 1);\n\n    }\n\n\n\n    ptr_y  = ref_picture[0] + src_y   * linesize   + src_x;\n\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n\n\n    if ((unsigned) src_x >  h_edge_pos - (!!sx) - 2 * block_s ||\n\n        (unsigned) src_y > (v_edge_pos >> field_based) - (!!sy) - h) {\n\n        s->dsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y,\n\n                                s->linesize, 17, 17 + field_based,\n\n                                src_x, src_y << field_based, h_edge_pos,\n\n                                v_edge_pos);\n\n        ptr_y = s->edge_emu_buffer;\n\n        if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {\n\n            uint8_t *uvbuf = s->edge_emu_buffer + 18 * s->linesize;\n\n            s->dsp.emulated_edge_mc(uvbuf , ptr_cb, s->uvlinesize, 9,\n\n                                    9 + field_based,\n\n                                    uvsrc_x, uvsrc_y << field_based,\n\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n\n            s->dsp.emulated_edge_mc(uvbuf + 16, ptr_cr, s->uvlinesize, 9,\n\n                                    9 + field_based,\n\n                                    uvsrc_x, uvsrc_y << field_based,\n\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n\n            ptr_cb = uvbuf;\n\n            ptr_cr = uvbuf + 16;\n\n        }\n\n    }\n\n\n\n    // FIXME use this for field pix too instead of the obnoxious hack which changes picture.f.data\n\n    if (bottom_field) {\n\n        dest_y  += s->linesize;\n\n        dest_cb += s->uvlinesize;\n\n        dest_cr += s->uvlinesize;\n\n    }\n\n\n\n    if (field_select) {\n\n        ptr_y   += s->linesize;\n\n        ptr_cb  += s->uvlinesize;\n\n        ptr_cr  += s->uvlinesize;\n\n    }\n\n\n\n    sx = (sx << 2) >> lowres;\n\n    sy = (sy << 2) >> lowres;\n\n    pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy);\n\n\n\n    if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {\n\n        uvsx = (uvsx << 2) >> lowres;\n\n        uvsy = (uvsy << 2) >> lowres;\n\n        pix_op[op_index](dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift,\n\n                         uvsx, uvsy);\n\n        pix_op[op_index](dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift,\n\n                         uvsx, uvsy);\n\n    }\n\n    // FIXME h261 lowres loop filter\n\n}\n", "idx": 10836, "substitutes": {"s": ["sym", "service", "cs", "self", "c", "i", "ks", "sv", "settings", "b", "gs", "e", "comments", "rs", "strings", "js", "os", "opens", "bis", "site", "ls", "ss", "sq", "params", "sb", "S", "session", "ds", "ssl", "ms", "o", "qs", "ses", "f", "sf", "xs", "services", "sg", "secondary", "sim", "sl", "v", "ions", "source", "ps", "sync", "u", "south", "sys", "su", "space", "rates", "g", "ess", "sports", "is", "es", "p", "ts", "si", "sis", "se", "ns", "spec", "t", "m", "conf", "n", "sets", "storage", "sa", "stats", "ops", "aws"], "dest_y": ["dest__x", "dest_x", "Dest_y", "dest_py", "dest__py", "Dest_x", "Dest_py", "dest__y", "dest_vy", "dest__vy", "Dest_vy"], "dest_cb": ["Dest_rb", "dest_hub", "Dest_cb", "Dest_hub", "Dest_bb", "dest_rb", "dest_bb"], "dest_cr": ["Dest_rb", "Dest_cb", "dest__cr", "dest__CR", "dest__cb", "Dest_CR", "dest__rb", "Dest_cr", "dest_rb", "dest_CR"], "field_based": ["fielderbased", " field_ed", "field_like", "fieldPtotal", " field_fixed", "field_base", "fieldPbound", "field___received", "field_ed", " field_count", " field_Based", " field_set", "field67base", "field_fixed", " field_total", " field_related", "field6count", "field_count", "field67based", "field67like", "fielderrelated", " field_like", " field_received", "fieldPvalid", "field_valid", "field___fixed", "field___bound", " field_valid", "field_Based", "field6base", "field_total", "fieldacfixed", "field6based", "fielderset", " field_bound", "field_bound", "fieldacreceived", " field_base", "field6Based", "field_related", "field_set", "fieldacbound", "fieldacbased", "field_received", "field___based", "field67ed", "fieldPbased"], "bottom_field": ["last_fields", "bottom_fields", "bottom54fields", " bottom_FIELD", "bottom4sample", "bottom_sample", "bottom_size", "bottom54field", "bottom__field", "last_size", "bottom_slice", "bottom54FIELD", "bottom__slice", "bottom_FIELD", "bottom4fields", "bottom__fields", " bottom_slice", "last_field", "bottom4size", "bottom24fields", "bottom24sample", "bottom54slice", "bottom4field", "last_sample", "bottom24field", " bottom_fields", "bottom__FIELD", "bottom24size"], "field_select": ["field8select", " field_elect", "field8patch", " field_count", "fieldalpatch", "fieldalelect", " field_reverse", " field_patch", "field8reverse", "field___count", "field___selected", "field8elect", "field___sel", "field___select", " field_selected", "field_patch", " field_sel", "field_count", "fieldalselect", "fieldalreverse", "field_sel", "field_selected", "field_elect", "field_reverse"], "ref_picture": ["reference_picture", "refsimage", "referencesimg", "refsprofile", "reference_img", "ref_image", "refsimg", "reference_image", "referencesimage", "ref_img", "reference_profile", "referencespicture", "ref_profile", "refspicture", "referencesprofile"], "pix_op": ["png_op", "png_offset", "pix2image", "png_oper", "pix_image", "pix2oper", "pixallimage", "pix2offset", "pix_offset", "pixalloper", "pix2op", "pixalloffset", "pix_oper", "png_image", "pixallop"], "motion_x": ["motion_no", "camera67ix", "error_ey", "error44x", "motion_name", "camera67xy", "motion67xy", "motion___xs", "motion_ys", "error44ys", "error44ey", "motion33y", "motionalxy", "motionPxy", "error_xs", "camera67ya", "motion_ix", "motion33xy", "motion_xs", "motionalx", "motion67x", "motion_ey", "motionPix", "motion67ya", " motion_xy", " motion_name", "motion33no", "motion_ya", "motion44ey", "motion___ey", "motionalwidth", "motion67name", "error_x", "camera_ix", "motionaly", "motion_width", "camera_x", "motion44x", "motion___x", "motionPya", "camera67x", "camera_ya", "error_ys", "motion_xy", "error44xs", "motion67y", "motion44ys", " motion_no", "motion44xs", "motionPx", "motion33x", "motion___ys", " motion_width", "camera_xy", "motion67ix"], "motion_y": ["camera_yah", "motionFilex", "motionLogY", "motion_ady", "moving67y", "motionJy", "motion_vy", "moving_ady", "motionLogyah", "moving_ny", "cameraLogyah", "motionFiley", "moving_Y", "motionLogy", "cameraLogY", "motionLogyd", "motion_ys", "location_y", "motion_Y", "motion_sy", "location_sy", "camera_yd", "motionFilesy", "locationLogx", "camera_y", "motionJyt", " motion_yt", "cameraLogy", "motion67ady", "motion2dy", "motion_ny", "motion64ny", "location_w", "motion2y", "cameraLogyd", "motion67Y", " motion_ys", "locationLogy", "motionJya", "location_x", "motion_yt", "motion_dy", "motion64ys", " motion_ny", "motionLogw", "motion_ya", "motionJvy", "locationLogw", "motion_yah", "motionJx", " motion_vy", "motionFilew", "motion_w", "motionLogx", "motion2ys", "motion67ny", "motionJny", "motion64vy", "moving_y", "moving67Y", "motion2x", " motion_ya", "moving67ady", "locationLogsy", "motion67y", "motionJys", "motion64y", "motion_yd", "motionLogsy", "moving67ny", " motion_dy", "camera_Y"], "h": ["g", "ph", "H", "f", "k", "y", "c", "i", "d", "p", "b", "bh", "z", "v", "hs", "image", "ch", "r", "o", "l", "q", "u", "w", "m", "e", "n", "x"], "mb_y": ["mb_ery", "mbjcy", "mbjsize", "machine_yl", "mb_x", "mb_yl", "mbjx", "mp_size", "mp_y", "mb_vy", "mp_x", "mb_size", "machine_ery", "machine_y", "machine_vy", "mp_cy", "mb_cy", "mbjy"], "ptr_y": ["src_ya", "src_yd", "ptr__vy", "ptr__y", "ptr_vy", "ptr__ya", "ptr__yd", "ptr_ya", "ptr_yd", "src_vy"], "ptr_cb": ["dest_b", "ptr_rb", "ptr__b", "dest_hub", "ptr__hub", "ptr_hub", "ptr__cb", "ptr__rb", "ptr_b", "dest_rb"], "ptr_cr": ["ptr_rb", "ptr_sr", "src_rb", "src_cr", "src_cb", "src_sr"], "mx": ["hop", "mode", "max", "host", "mi", "wx", "sq", "mr", " mc", "vis", "loc", "cp", "shape", "nz", "ns", "ms", "mem", "rx", "wave", "area", "mm", "tx", "base", "xp", " m", "large", "mc", "mag", "mn"], "my": ["fy", "MY", "ey", "sam", "yy", "sym", "ky", "pm", "mi", "ny", "My", "mid", "md", "asy", "sup", "by", "mys", "mis", "gy", "ms", "ery", "sky", "mon", "custom", "ram", "py", "mn"], "src_x": ["loc_w", "src_X", "src_id", "src_z", "loc_x", "source_w", "source_z", "source_x", "loc_xy", "loc_y", "source_id", "source_X", "src_w", "source_y", "src_xy"], "src_y": ["src2ys", "src_ys", "src_ya", " src_ya", "src_z", "src2x", "src__y", "src2dy", "src__ys", "src2y", "src_dy", "src__dy", " src_ys", " src_dy", " src_z", "src__x"], "uvsrc_x": ["uvsrcsz", "uvsrc2xx", "uvsrc_z", "uvsrcsx", "uvsrc_xx", "uvsrcsy", "uvsrc2z", "uvsrc_w", "uvsrcsxx", "uvsrc2x", "uvsrc2y"], "uvsrc_y": ["uvsrc_ya", "uvsource_i", "uvsource_ya", "uvsource_x", "uvsource_y", "uvsrc_i"], "uvlinesize": ["uvcodesrate", "uvlinrate", "uvlesize", "uvlinesizer", "uvlinizes", "uvlsizer", "uvlesizes", "ujlesize", "uvlinesizes", "uvcodesization", "ujlesrate", "ujlesizes", "ujlinesization", "uvlinize", "uvinesiz", "ujlinesrate", "uvlsizes", "uvinesizes", "uvlinesiz", "vlinesizes", "vlinesiz", "uvlinesrate", "uvlinesization", "uvcodesize", "uvlinization", "ujlesization", "uvinesizer", "ujlinesize", "uvinesize", "uvlesrate", "ujlinesizes", "uvlsize", "uvlesization", "vlinesizer", "vlinesize", "uvlsiz", "uvcodesizes"], "linesize": ["relationssize", " linesiz", "inesizing", "facesizes", "relationsiz", "onessize", " linesizing", "stringsizer", " linesizer", " linesizes", "linesizing", "linsize", "onesizer", " linesization", "stringsizing", "linesization", "codesize", "codesization", "facesization", "linesizes", "ballsize", "linsization", "ballsizer", "ballsization", "inesize", "inesiz", "stringsize", "codessize", "stringsiz", "linessize", "relationsize", " linessize", "ballssize", "linesizer", "linesiz", "linssize", "relationsization", "linsiz", "facessize", "onesize", "inesizer", "onesization", "codesizes", "facesize"], "sx": ["Sxx", " sxx", "sX", "Sy", "SX", " sxc", "nsxc", "ssxx", "Sx", "Sxc", "sxx", "pxx", "px", "ssx", "ssy", "pX", " sX", "sxc", "nsX", "ssX", "nsx", "py", "nsy"], "sy": ["fy", "idy", "ony", "zy", "ey", "phy", "wy", "yy", "sym", "size", "ky", "ny", "ys", "sub", "y", "asy", "sq", "dist", "dy", "hy", "si", "loc", "cy", "gy", "sid", "ie", "ship", "ay", "SY", "area", "sky", "ym", "sync", "ady", "ry", "ly", "ty", "south", "sys", "sa", "py", "syn"], "uvsx": ["ucsy", "uvsxx", "uVSX", "uvesx", "ucsh", "uversy", "uVSx", "uvesxx", "Ucsy", " uvsh", "uvesy", "ubsxx", " uvsxx", " ubsx", "ubsh", " ubsh", "UvsX", "Uvsx", "uversx", "uvsX", " ubsy", "uversX", " ubsxx", "uvesh", "ucsxx", "ucsX", "Uvsy", "ucsx", "UcsX", "uvsh", "uVSy", "ubsx", "Ucsx", "ubsy"], "uvsy": ["nvdy", "uzny", "vpdy", "usbsync", "uzsy", "usbny", "nvfy", "uvpy", "usbsy", "nvdist", "uzpy", "cvdy", "vpdist", "cvny", "cvfy", "usbpy", "uvdy", "cvdist", "uvny", "uvfy", "nvsy", "vpfy", "uvdist", "cvpy", "cvsy", "vpsy", "uzsync", "uvsync", "cvsync"]}}
{"project": "FFmpeg", "commit_id": "1178868683d25c0f358b0364eb55f69b563b24f3", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data,\n\n                        int *got_frame,\n\n                        AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf      = avpkt->data;\n\n    unsigned int   buf_size = avpkt->size;\n\n    const uint8_t *buf_end  = buf + buf_size;\n\n\n\n    const AVPixFmtDescriptor *desc;\n\n    EXRContext *const s = avctx->priv_data;\n\n    AVFrame *picture  = data;\n\n    AVFrame *const p = &s->picture;\n\n    uint8_t *ptr;\n\n\n\n    int i, x, y, stride, magic_number, version, flags, ret;\n\n    int w = 0;\n\n    int h = 0;\n\n    unsigned int xmin   = ~0;\n\n    unsigned int xmax   = ~0;\n\n    unsigned int ymin   = ~0;\n\n    unsigned int ymax   = ~0;\n\n    unsigned int xdelta = ~0;\n\n\n\n    int out_line_size;\n\n    int bxmin, axmax;\n\n    int scan_lines_per_block;\n\n    unsigned long scan_line_size;\n\n    unsigned long uncompressed_size;\n\n\n\n    unsigned int current_channel_offset = 0;\n\n\n\n    s->channel_offsets[0] = -1;\n\n    s->channel_offsets[1] = -1;\n\n    s->channel_offsets[2] = -1;\n\n    s->channel_offsets[3] = -1;\n\n    s->bits_per_color_id = -1;\n\n    s->compr = -1;\n\n\n\n    if (buf_size < 10) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Too short header to parse\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    magic_number = bytestream_get_le32(&buf);\n\n    if (magic_number != 20000630) { // As per documentation of OpenEXR it's supposed to be int 20000630 little-endian\n\n        av_log(avctx, AV_LOG_ERROR, \"Wrong magic number %d\\n\", magic_number);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    version = bytestream_get_byte(&buf);\n\n    if (version != 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported version %d\\n\", version);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    flags = bytestream_get_le24(&buf);\n\n    if (flags & 0x2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Tile based images are not supported\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    // Parse the header\n\n    while (buf < buf_end && buf[0]) {\n\n        unsigned int variable_buffer_data_size;\n\n        // Process the channel list\n\n        if (check_header_variable(avctx, &buf, buf_end, \"channels\", \"chlist\", 38, &variable_buffer_data_size) >= 0) {\n\n            const uint8_t *channel_list_end;\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            channel_list_end = buf + variable_buffer_data_size;\n\n            while (channel_list_end - buf >= 19) {\n\n                int current_bits_per_color_id = -1;\n\n                int channel_index = -1;\n\n\n\n                if (!strcmp(buf, \"R\"))\n\n                    channel_index = 0;\n\n                else if (!strcmp(buf, \"G\"))\n\n                    channel_index = 1;\n\n                else if (!strcmp(buf, \"B\"))\n\n                    channel_index = 2;\n\n                else if (!strcmp(buf, \"A\"))\n\n                    channel_index = 3;\n\n                else\n\n                    av_log(avctx, AV_LOG_WARNING, \"Unsupported channel %.256s\\n\", buf);\n\n\n\n                while (bytestream_get_byte(&buf) && buf < channel_list_end)\n\n                    continue; /* skip */\n\n\n\n                if (channel_list_end - * &buf < 4) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                current_bits_per_color_id = bytestream_get_le32(&buf);\n\n                if (current_bits_per_color_id > 2) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"Unknown color format\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                if (channel_index >= 0) {\n\n                    if (s->bits_per_color_id != -1 && s->bits_per_color_id != current_bits_per_color_id) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"RGB channels not of the same depth\\n\");\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    s->bits_per_color_id  = current_bits_per_color_id;\n\n                    s->channel_offsets[channel_index] = current_channel_offset;\n\n                }\n\n\n\n                current_channel_offset += 1 << current_bits_per_color_id;\n\n                buf += 12;\n\n            }\n\n\n\n            /* Check if all channels are set with an offset or if the channels\n\n             * are causing an overflow  */\n\n\n\n            if (FFMIN3(s->channel_offsets[0],\n\n                       s->channel_offsets[1],\n\n                       s->channel_offsets[2]) < 0) {\n\n                if (s->channel_offsets[0] < 0)\n\n                    av_log(avctx, AV_LOG_ERROR, \"Missing red channel\\n\");\n\n                if (s->channel_offsets[1] < 0)\n\n                    av_log(avctx, AV_LOG_ERROR, \"Missing green channel\\n\");\n\n                if (s->channel_offsets[2] < 0)\n\n                    av_log(avctx, AV_LOG_ERROR, \"Missing blue channel\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            buf = channel_list_end;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"dataWindow\", \"box2i\", 31, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            xmin = AV_RL32(buf);\n\n            ymin = AV_RL32(buf + 4);\n\n            xmax = AV_RL32(buf + 8);\n\n            ymax = AV_RL32(buf + 12);\n\n            xdelta = (xmax-xmin) + 1;\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"displayWindow\", \"box2i\", 34, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            w = AV_RL32(buf + 8) + 1;\n\n            h = AV_RL32(buf + 12) + 1;\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"lineOrder\", \"lineOrder\", 25, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if (*buf) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Doesn't support this line order : %d\\n\", *buf);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"pixelAspectRatio\", \"float\", 31, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            avctx->sample_aspect_ratio = av_d2q(av_int2float(AV_RL32(buf)), 255);\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"compression\", \"compression\", 29, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if (s->compr == -1)\n\n                s->compr = *buf;\n\n            else\n\n                av_log(avctx, AV_LOG_WARNING, \"Found more than one compression attribute\\n\");\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        }\n\n\n\n        // Check if there is enough bytes for a header\n\n        if (buf_end - buf <= 9) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        // Process unknown variables\n\n        for (i = 0; i < 2; i++) {\n\n            // Skip variable name/type\n\n            while (++buf < buf_end)\n\n                if (buf[0] == 0x0)\n\n                    break;\n\n        }\n\n        buf++;\n\n        // Skip variable length\n\n        if (buf_end - buf >= 5) {\n\n            variable_buffer_data_size = get_header_variable_length(&buf, buf_end);\n\n            if (!variable_buffer_data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            buf += variable_buffer_data_size;\n\n        }\n\n    }\n\n\n\n    if (s->compr == -1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Missing compression attribute\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (buf >= buf_end) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Incomplete frame\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    buf++;\n\n\n\n    switch (s->bits_per_color_id) {\n\n    case 2: // 32-bit\n\n    case 1: // 16-bit\n\n        if (s->channel_offsets[3] >= 0)\n\n            avctx->pix_fmt = AV_PIX_FMT_RGBA64;\n\n        else\n\n            avctx->pix_fmt = AV_PIX_FMT_RGB48;\n\n        break;\n\n    // 8-bit\n\n    case 0:\n\n        av_log_missing_feature(avctx, \"8-bit OpenEXR\", 1);\n\n        return AVERROR_PATCHWELCOME;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown color format : %d\\n\", s->bits_per_color_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch (s->compr) {\n\n    case EXR_RAW:\n\n    case EXR_RLE:\n\n    case EXR_ZIP1:\n\n        scan_lines_per_block = 1;\n\n        break;\n\n    case EXR_ZIP16:\n\n        scan_lines_per_block = 16;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Compression type %d is not supported\\n\", s->compr);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    if (s->picture.data[0])\n\n        ff_thread_release_buffer(avctx, &s->picture);\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    // Verify the xmin, xmax, ymin, ymax and xdelta before setting the actual image size\n\n    if (xmin > xmax || ymin > ymax || xdelta != xmax - xmin + 1 || xmax >= w || ymax >= h) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Wrong sizing or missing size information\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (w != avctx->width || h != avctx->height) {\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    }\n\n\n\n    desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    bxmin = xmin * 2 * desc->nb_components;\n\n    axmax = (avctx->width - (xmax + 1)) * 2 * desc->nb_components;\n\n    out_line_size = avctx->width * 2 * desc->nb_components;\n\n    scan_line_size = xdelta * current_channel_offset;\n\n    uncompressed_size = scan_line_size * scan_lines_per_block;\n\n\n\n    if (s->compr != EXR_RAW) {\n\n        av_fast_padded_malloc(&s->uncompressed_data, &s->uncompressed_size, uncompressed_size);\n\n        av_fast_padded_malloc(&s->tmp, &s->tmp_size, uncompressed_size);\n\n        if (!s->uncompressed_data || !s->tmp)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    if ((ret = ff_thread_get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    // Zero out the start if ymin is not 0\n\n    for (y = 0; y < ymin; y++) {\n\n        memset(ptr, 0, out_line_size);\n\n        ptr += stride;\n\n    }\n\n\n\n    // Process the actual scan line blocks\n\n    for (y = ymin; y <= ymax; y += scan_lines_per_block) {\n\n        uint16_t *ptr_x = (uint16_t *)ptr;\n\n        if (buf_end - buf > 8) {\n\n            /* Read the lineoffset from the line offset table and add 8 bytes\n\n               to skip the coordinates and data size fields */\n\n            const uint64_t line_offset = bytestream_get_le64(&buf) + 8;\n\n            int32_t data_size;\n\n\n\n            // Check if the buffer has the required bytes needed from the offset\n\n            if ((line_offset > buf_size) ||\n\n                (s->compr == EXR_RAW && line_offset > avpkt->size - xdelta * current_channel_offset) ||\n\n                (s->compr != EXR_RAW && line_offset > buf_size - (data_size = AV_RL32(avpkt->data + line_offset - 4)))) {\n\n                // Line offset is probably wrong and not inside the buffer\n\n                av_log(avctx, AV_LOG_WARNING, \"Line offset for line %d is out of reach setting it to black\\n\", y);\n\n                for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) {\n\n                    ptr_x = (uint16_t *)ptr;\n\n                    memset(ptr_x, 0, out_line_size);\n\n                }\n\n            } else {\n\n                const uint8_t *red_channel_buffer, *green_channel_buffer, *blue_channel_buffer, *alpha_channel_buffer = 0;\n\n\n\n                if (scan_lines_per_block > 1)\n\n                    uncompressed_size = scan_line_size * FFMIN(scan_lines_per_block, ymax - y + 1);\n\n                if ((s->compr == EXR_ZIP1 || s->compr == EXR_ZIP16) && data_size < uncompressed_size) {\n\n                    unsigned long dest_len = uncompressed_size;\n\n\n\n                    if (uncompress(s->tmp, &dest_len, avpkt->data + line_offset, data_size) != Z_OK ||\n\n                        dest_len != uncompressed_size) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"error during zlib decompression\\n\");\n\n                        return AVERROR(EINVAL);\n\n                    }\n\n                } else if (s->compr == EXR_RLE && data_size < uncompressed_size) {\n\n                    if (rle_uncompress(avpkt->data + line_offset, data_size, s->tmp, uncompressed_size)) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"error during rle decompression\\n\");\n\n                        return AVERROR(EINVAL);\n\n                    }\n\n                }\n\n\n\n                if (s->compr != EXR_RAW && data_size < uncompressed_size) {\n\n                    predictor(s->tmp, uncompressed_size);\n\n                    reorder_pixels(s->tmp, s->uncompressed_data, uncompressed_size);\n\n\n\n                    red_channel_buffer   = s->uncompressed_data + xdelta * s->channel_offsets[0];\n\n                    green_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[1];\n\n                    blue_channel_buffer  = s->uncompressed_data + xdelta * s->channel_offsets[2];\n\n                    if (s->channel_offsets[3] >= 0)\n\n                        alpha_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[3];\n\n                } else {\n\n                    red_channel_buffer   = avpkt->data + line_offset + xdelta * s->channel_offsets[0];\n\n                    green_channel_buffer = avpkt->data + line_offset + xdelta * s->channel_offsets[1];\n\n                    blue_channel_buffer  = avpkt->data + line_offset + xdelta * s->channel_offsets[2];\n\n                    if (s->channel_offsets[3] >= 0)\n\n                        alpha_channel_buffer = avpkt->data + line_offset + xdelta * s->channel_offsets[3];\n\n                }\n\n\n\n                for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) {\n\n                    const uint8_t *r, *g, *b, *a;\n\n\n\n                    r = red_channel_buffer;\n\n                    g = green_channel_buffer;\n\n                    b = blue_channel_buffer;\n\n                    if (alpha_channel_buffer)\n\n                        a = alpha_channel_buffer;\n\n\n\n                    ptr_x = (uint16_t *)ptr;\n\n\n\n                    // Zero out the start if xmin is not 0\n\n                    memset(ptr_x, 0, bxmin);\n\n                    ptr_x += xmin * desc->nb_components;\n\n                    if (s->bits_per_color_id == 2) {\n\n                        // 32-bit\n\n                        for (x = 0; x < xdelta; x++) {\n\n                            *ptr_x++ = exr_flt2uint(bytestream_get_le32(&r));\n\n                            *ptr_x++ = exr_flt2uint(bytestream_get_le32(&g));\n\n                            *ptr_x++ = exr_flt2uint(bytestream_get_le32(&b));\n\n                            if (alpha_channel_buffer)\n\n                                *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a));\n\n                        }\n\n                    } else {\n\n                        // 16-bit\n\n                        for (x = 0; x < xdelta; x++) {\n\n                            *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&r));\n\n                            *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&g));\n\n                            *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&b));\n\n                            if (alpha_channel_buffer)\n\n                                *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&a));\n\n                        }\n\n                    }\n\n\n\n                    // Zero out the end if xmax+1 is not w\n\n                    memset(ptr_x, 0, axmax);\n\n\n\n                    red_channel_buffer   += scan_line_size;\n\n                    green_channel_buffer += scan_line_size;\n\n                    blue_channel_buffer  += scan_line_size;\n\n                    if (alpha_channel_buffer)\n\n                        alpha_channel_buffer += scan_line_size;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    // Zero out the end if ymax+1 is not h\n\n    for (y = ymax + 1; y < avctx->height; y++) {\n\n        memset(ptr, 0, out_line_size);\n\n        ptr += stride;\n\n    }\n\n\n\n    *picture   = s->picture;\n\n    *got_frame = 1;\n\n\n\n    return buf_size;\n\n}\n", "idx": 10842, "substitutes": {"avctx": ["navctx", "avcmp", "afsrc", "avcontext", " avctl", " avxc", "aphctx", "AVctx", "avectx", "navcontext", "avalnas", "Avctx", "avalctx", "navcmp", "afnas", "afpkg", "afci", "aphcontext", "aphxc", "avci", "AVci", "avenas", " avcontext", "apcontext", "avexc", "Avcontext", "apxc", "Avci", "avpkg", "AVcmp", "afconn", "apctx", "avalconn", "AVcv", "Avcmp", "avalcontext", "afxc", "avnas", "afcmp", "navsrc", "AVsrc", "AVconn", "avecontext", "apcmp", "avxc", "avecmp", "avepkg", "avalcv", "AVcontext", "afcv", "avsrc", "afctl", "avcv", "avconn", "afctx", "avalpkg", "avctl", "aphctl", "afcontext"], "data": ["padding", "dat", "pos", "message", "text", "block", "size", "f", "sample", "mode", "device", "Data", "connection", "result", "media", "c", "d", "DATA", "config", "bytes", "content", "input", "database", "queue", "frame", "doc", "open", "memory", "address", "package", "record", "image", "parent", "reader", "channel", "da", "length", "command", "o", "start", "next", "buffer", "body", "pad", "base", "meta", "video", "stream", "window", "align", "read", "cache"], "got_frame": ["buflogframe", "orig_frame", "orig_scale", "orig_position", "bufiptrace", "buflogposition", "buf_trace", "buf_scale", "bufipposition", "bufipscale", "buf_frame", "orig_trace", "buf_position", "buflogtrace", "bufipframe", "buflogscale"], "avpkt": [" avcpsth", "avckt", "avcpct", " avcpkt", "avfft", " avcpnt", "avcpacket", "avpacket", " avpsth", "abfacket", "abpki", "avppkt", "abpacket", "avbpka", "afcpacket", "avcpsth", "abpkt", "afpct", "avpKT", "avfki", "avppct", "avcpKT", "afcpkt", "avfka", "abfka", "abpka", "avpft", "avppki", "avpki", "avfct", "avfacket", "avbpkt", " avcpKT", "avppsth", "avpka", "avpct", "afcpct", " avpnt", "abfkt", "afpft", "abfki", "avcsth", "avbpki", "avcpkt", "avcnt", "avpsth", "avcpft", " avpKT", "avbpacket", "afcpft", "afpkt", "avcKT", "avppnt", "avppacket", "avpnt", "avppKT", "avppka", "afpacket", "avppft", "avcpnt", "avfkt"], "buf": ["bus", "cas", "text", "block", "pub", "pool", "vec", "src", "ctx", "ff", "aux", "home", "exc", "bc", "bag", "seq", "len", "box", "brace", "usb", "config", "rc", "cb", "cur", "Buff", "fb", "cp", "queue", "runner", "img", "gb", "context", "rb", "loop", "fp", "cv", "comb", "num", "header", "alloc", "br", "cmd", "uf", "cf", "buff", "map", "ab", "buffer", "pad", "port", "wb", "uc", "fd", "cap", "batch", "window", "cache"], "buf_end": ["buf__len", "buf__ended", "buf__end", "buf2start", "buf_start", "buf2ended", "queue_len", "queue_start", "buf_len", "buf__start", "buf_ended", "buf2end", "queue_ended", "queue_end", "buf2len"], "desc": ["text", " def", "path", "description", "proc", "sub", "esc", "des", "enc", "Desc", " d", " description", "doc", "ext", "summary", "dc", "def", "sc", "rec", "acc", "sec", "meta", "name", "asc", "feat", "dir"], "s": ["server", "os", "sym", "f", "service", "parts", "its", "cs", "ls", "ss", "c", "sq", "is", "an", "d", "services", "sb", "es", "h", "ts", "si", "sg", "S", "ds", "session", "fs", "ssl", "http", "settings", "details", "sl", "ns", "v", "spec", "ms", "client", "t", "o", "ps", "ses", "l", "sync", "gs", "as", "m", "conf", "e", "n", "sys", "sets", "su", "rs", "sa", "sec", "js", "stats", "ops"], "picture": ["plugin", "fine", "ctx", "file", "description", "fi", "conference", "media", "library", "feature", "config", "guide", "slot", "details", "definition", "filename", "pict", "frame", "img", "pic", "piece", "Picture", "family", "summary", "package", "image", "share", "icon", "base", "info", "photo", "profile", "photos", "meta", "video", "detail", "feat"], "p": ["pg", "tp", "f", "mp", "pb", "c", "pc", "jp", "d", "pd", "pi", "P", "v", "op", "fp", "t", "ps", "l", "ap", "vp", "m", "e", "n", "py"], "ptr": ["jpg", "ctr", "prop", "np", "pos", "pointer", "vec", "src", "pl", "fi", "proc", "pb", "dr", "sh", "img", "pic", "pt", "tmp", "fp", "alloc", "br", "attr", "buffer", "obj", "fd", "inst"], "i": ["ii", "f", "id", "I", "ip", "c", "d", "pi", "io", "j", "z", "v", "xi", "bi", "t", "ci", "u", "index", "start", "m", "e", "n", "info", "it"], "x": ["f", "pointer", "id", "xs", "pixel", "c", "X", "ex", "xy", "d", "h", "shape", "z", "image", "rx", "t", "fx", "index", "xx", "dx", "w", "m", "tx"], "y": ["yy", "f", "type", "id", "c", "xy", "d", "h", "sp", "vy", "cy", "j", "z", "o", "t", "l", "ym", "w", "m", "height", "e", "n", "Y", "py"], "stride": ["frider", "frope", "shrope", "frite", "shride", "shrider", "brope", "brite", "strite", "strope", "fride", "shrite", "strider", "brider", "bride"], "magic_number": [" magic_counter", "magic_no", "magic_notation", " magic_note", "magicurenumber", " magic_total", " magic_no", "magic_total", "magic_counter", "magic_digit", " magic_value", " magic_notation", " magic_digit", "magic_text", "magicuretotal", " magic_text", "magicurenotation", "magic_note", "magic_value", "magicureno"], "version": ["product", "latest", "size", "type", "mode", "format", "diff", "vers", "description", "date", "update", "tag", "option", "depth", "ver", "VERSION", "feature", "patch", "beta", "Version", "software", "stage", "flower", "until", "release", "vision", "generation", "driver", "secret", "direction", "position", "major", "scale", "package", "v", "parent", "vert", "num", "length", "pin", "platform", "level", "channel", "brand", "versions", "value", "section", "name", "bug", "python", "target", "number", "build"], "flags": ["missions", "utils", "planes", "styles", "args", "groups", "ils", "format", "parts", "vals", "feat", "actions", "quality", "FLAG", "states", "fields", "len", "properties", "bytes", "fps", "mods", "ants", "options", "details", "settings", "filename", "reports", "flag", "files", "atts", "caps", "alls", "rules", "magic", "ages", "ags", "hours", "mask", "frames", "plugins", "ints", " bits", "versions", "bits", "members", "Flags", "lists", "status", "locks", "stats", "types", "ports", "dates", "features"], "ret": ["rets", "resp", "RET", "rev", "result", "success", "seq", "len", "rc", "back", "orig", "fun", "quiet", "flag", "ext", "mem", "complete", "val", "def", "reply", "info", "res", "alt", "status"], "out_line_size": ["out_line_count", "out_lines_count", "out_line_speed", "out_lines_size", "out_line_sum", "out_lines_speed", "out_lines_sum"], "bxmin": ["btxmin", "bxstart", " bxmax", "btxmax", "btxpos", " bxpos", "bxpos", "bxmax", "bxxmax", "bxxstart", " bxstart", "bxxpos", "bxxmin", "btxstart"], "axmax": ["exmax", "exmin", "axrange", "axmin", "exrange", "oxmax", "xrange", "xmax", "oxrange", "oxmin", "xmin"], "scan_lines_per_block": ["scan_lines_per_row", "scan_lines_per_byte", "scan_lines_per_channel"], "scan_line_size": ["scan_lines_scale", "scan_line_sum", "scan_lines_count", "scan_lines_sum", "scan_lines_size", "scan_line_count", "scan_line_scale"], "uncompressed_size": ["uncompressedlicize", "uncomplied_size", "uncompressedlennum", "uncompressedlicnum", "uncompressed_ize", "uncompressedlicspeed", "uncomplied_speed", "uncompressed_num", "uncompressedlicsize", "uncompressedlenize", "uncompressedlensize", "uncompressed_speed", "uncomplied_ize", "uncomplied_num", "uncompressedlenspeed"]}}
{"project": "qemu", "commit_id": "141af038dd1e73ed32e473046adeb822537c1152", "target": 1, "func": "static void csrhci_reset(struct csrhci_s *s)\n\n{\n\n    s->out_len = 0;\n\n    s->out_size = FIFO_LEN;\n\n    s->in_len = 0;\n\n    s->baud_delay = NANOSECONDS_PER_SECOND;\n\n    s->enable = 0;\n\n    s->in_hdr = INT_MAX;\n\n    s->in_data = INT_MAX;\n\n\n\n    s->modem_state = 0;\n\n    /* After a while... (but sooner than 10ms) */\n\n    s->modem_state |= CHR_TIOCM_CTS;\n\n\n\n    memset(&s->bd_addr, 0, sizeof(bdaddr_t));\n\n}\n", "idx": 10847, "substitutes": {"s": ["server", "g", "os", "sym", "f", "request", "args", "service", "cs", "ls", "ss", "states", "c", "sq", "is", "i", "an", "services", "d", "sb", "es", "ts", "p", "sg", "si", "S", "settings", "ds", "session", "fs", "ssl", "http", "b", "core", "ns", "t", "o", "r", "ps", "ses", "l", "sync", "plugins", "gs", "m", "conf", "e", "n", "sets", "sys", "rs", "js", "status", "stats", "send", "ops", "features"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)\n\n{\n\n\tunsigned i;\n\n\tunsigned num_pixels = src_size >> 1;\n\n\t\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint16_t rgb;\n\n\t    rgb = src[2*i];\n\n\t    r = rgb&0x1F;\n\n\t    g = (rgb&0x3E0)>>5;\n\n\t    b = (rgb&0x7C00)>>10;\n\n\t    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);\n\n\t}\n\n}\n", "idx": 10849, "substitutes": {"src": ["rect", "sur", "dest", "sth", "buf", "comp", "sel", "sub", "rob", "sq", "dist", "sup", "sb", "rc", "config", "cur", "cb", "input", "http", "loc", "gl", "st", "ssl", "img", "url", "gb", "sl", "rb", "source", "req", "sc", "sync", "start", "stack", "rs", "rest", "inst", "slice"], "dst": ["Dst", "ddest", "ssts", "sst", "dsst", "lsts", "dost", "Dsts", " ddest", " dsts", "lst", "sbl", "dsrc", "lrc", "pdest", "drc", "Ddest", "lbl", "dbl", "dsts", " dost", "psts", "dssts", "pst", "Dost", "dsbl", "post"], "src_size": [" src_shape", "srcblockscale", "src_scale", "srcblocksize", "source_scale", "src_range", " src_scale", "src_shape", "source_size", "src_address", "srcblockrange", "source_range", " src_address"], "i": ["ii", "ni", "abi", "li", "uri", "f", "phi", "I", "k", "mu", "ip", "oi", "mi", "adi", "c", "iu", "ini", "is", "d", "multi", "ji", "p", "ri", "ani", "si", "pi", "io", "j", "ori", "gi", "ie", "ami", "di", "v", "zi", "bi", "xi", "ti", "qi", "ui", "l", "ci", "u", "index", "m", "e", "n", "init", "info", "ai", "mini", "eni", "ix", "it"], "b": ["f", "k", "y", "c", "db", "a", "d", "sb", "p", "ib", "bg", "gb", "rb", "B", "v", "bi", "bb", "o", "t", "br", "abb", "l", "u", "ab", "w", "m", "e", "n", "base", "wb", "s", "bf", "x"], "g": ["big", "ga", "pg", "f", "k", "gm", "rg", "mg", "gg", "y", "c", "a", "d", "h", "p", "vg", "G", "sg", "gh", "gn", "bg", "gi", "gb", "v", "o", "gp", "l", "q", "u", "w", "m", "gr", "e", "n", "ge", "s", "group", "x"], "r": ["f", "nr", "re", "k", "ra", "rg", "c", "a", "sr", "d", "rc", "h", "pr", "p", "wr", "ro", "G", "rl", "range", "j", "R", "ar", "rb", "sl", "v", "t", "o", "br", "l", "q", "u", "w", "m", "gr", "e", "n", "er", "rs", "rr", "s", "x"], "rgb": ["Rbg", "cbb", "lgb", "brgb", "rbo", "brbb", "rbg", "urbb", "brbo", "rbb", " rgray", "Rba", "drgb", "rg", "rbba", "drgg", "brgg", "rbbo", "rgg", "urbo", "drbg", "rgd", "rbbb", "Rgg", "argg", " rba", "cgray", "lgg", "drbb", " rg", "Rgb", " rgg", " rbb", "urgg", "argd", "lgray", "argb", "rbgd", " rgd", "rba", "urgb", "rgbb", "lbb", "arg", "rbbg", "rgbg", "cgg", "rbgb", "rggb", "rbgg", "rggg", "cgb", "lbg", "rgray", " rbg"]}}
{"project": "qemu", "commit_id": "0a73336d96397c80881219d080518fac6f1ecacb", "target": 1, "func": "int net_init_vhost_user(const Netdev *netdev, const char *name,\n\n                        NetClientState *peer, Error **errp)\n\n{\n\n    int queues;\n\n    const NetdevVhostUserOptions *vhost_user_opts;\n\n    CharDriverState *chr;\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_VHOST_USER);\n\n    vhost_user_opts = &netdev->u.vhost_user;\n\n\n\n    chr = net_vhost_parse_chardev(vhost_user_opts, errp);\n\n    if (!chr) {\n\n        return -1;\n\n    }\n\n\n\n    /* verify net frontend */\n\n    if (qemu_opts_foreach(qemu_find_opts(\"device\"), net_vhost_check_net,\n\n                          (char *)name, errp)) {\n\n        return -1;\n\n    }\n\n\n\n    queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1;\n\n    if (queues < 1 || queues > MAX_QUEUE_NUM) {\n\n        error_setg(errp,\n\n                   \"vhost-user number of queues must be in range [1, %d]\",\n\n                   MAX_QUEUE_NUM);\n\n        return -1;\n\n    }\n\n\n\n    return net_vhost_user_init(peer, \"vhost_user\", name, chr, queues);\n\n}\n", "idx": 10857, "substitutes": {"netdev": ["etdef", " netdriver", " netdiv", "networkpad", "netdriver", "netconn", "networkdiv", "natdevice", "netconf", "netdef", "natpad", "etdriver", " netdef", "natdev", "etdevice", "etconn", " netconn", "networkdev", "matdriver", "networkdevice", "netdiv", "matconn", " netconf", "netdevice", "matdevice", "natconf", "networkdef", "etdiv", " netdevice", "matdev", "netpad", " netpad", "networkconf", "etdev"], "name": ["ni", "version", "prefix", "up", "size", "type", "id", "NAME", "path", "anc", "ip", "Name", "host", "connection", "addr", "user", "network", "label", "username", "names", "hello", "filename", "family", "part", "key", "address", "image", "client", "parent", "word", "am", "old", "base", "n", "info", "ame", "cap", "space", "sea", "data", "nam", "alias", "x"], "peer": ["server", "remote", "owner", "chain", "block", "pool", "request", "device", "pro", "ptr", "ip", "host", "proc", "connection", "addr", "instance", "node", "enc", "cur", "scope", "seed", "ssl", "worker", "socket", "inner", "address", "pe", "actor", "parent", "client", "channel", "attr", "req", "conn", "next", "cot", "buffer", "er", "slave", "cert"], "errp": ["rrp", "errc", "erpc", "derpc", "rrpc", "ersp", " errper", "errsp", "err", "erfp", "iterfp", " errc", "errr", "errfp", "errps", "derp", " errsp", "derr", "rrper", " errps", "erp", " errpc", " errr", "rrc", " errfp", "erps", "errpc", "iterr", "erc", "errper", "rrr", "iterps", "erper", "dersp", "iterp"], "queues": ["qasks", "fluges", "requues", "quesue", "Queends", "queueacks", "requures", "Queue", "quue", "quesues", "queueue", "Queasks", "fluues", "qacks", "qations", "quries", "Queures", "queends", "quures", "queueues", "quients", "Queums", " queures", "Queances", "quues", "qends", "queueures", " queances", "quums", "queences", "quences", "queueances", "queures", "requums", "Queries", "quesges", "queue", "queries", "clasks", "ques", "quesures", "clues", "queges", "queueries", "clries", "quges", "que", "queums", "queueations", "queances", " queue", "Queients", "queients", "qries", "queueums", "clends", "fluures", "fluences", "quesences", "Queues", "quesacks", "queations", "quesations", "queasks", "requients", "queacks"], "vhost_user_opts": ["vhost_user_optte", "vhost_user_prets", "vhost_user_opters", "vhost_user_opty", "vhost_user_operms", "vhost_user_operps", "vhost_user_kts", "vhost_user_verps", "vhost_user_opents", "vhost_user_procs", "vhost_user_verts", "vhost_user_adts", "vhost_user_OPps", "vhost_user_verty", "vhost_user_OPter", "vhost_user_opms", "vhost_user_OPty", "vhost_user_OPms", "vhost_user_optts", "vhost_user_OPts", "vhost_user_pros", "vhost_user_vert", "vhost_user_opente", "vhost_user_OPt", "vhost_user_ops", "vhost_user_pret", "vhost_user_proters", "vhost_user_adt", "vhost_user_prote", "vhost_user_kters", "vhost_user_proter", "vhost_user_openps", "vhost_user_opert", "vhost_user_opcs", "vhost_user_adms", "vhost_user_opt", "vhost_user_opens", "vhost_user_props", "vhost_user_optcs", "vhost_user_opte", "vhost_user_prot", "vhost_user_kt", "vhost_user_OPcs", "vhost_user_operts", "vhost_user_preps", "vhost_user_prety", "vhost_user_OPters", "vhost_user_optt", "vhost_user_adps", "vhost_user_kter", "vhost_user_opter", "vhost_user_prots", "vhost_user_optps", "vhost_user_opps"], "chr": ["qro", "Chrs", "schri", " chcr", "echr", "chrc", "cherrg", "Chsr", " chrg", "chrs", "echrg", "echrs", "cherrb", "shrc", "chsr", " chri", "ichsr", "schr", "CHrg", "echsr", "shrg", "chcr", "ichr", "chri", "schro", " chsr", "Chcr", "cherrc", "CHrc", "qsr", "qri", "cherr", " chrc", "shr", "Chr", "Chrc", "chro", "Chrb", "ichrs", "ichrg", "chrb", "qr", "shrb", "Chrg", "chrg", " chro", "CHcr", "schsr", "CHr"]}}
{"project": "FFmpeg", "commit_id": "35dcc8a0405788de392ed116dd628aef2772003d", "target": 1, "func": "static int lag_decode_prob(GetBitContext *gb, uint32_t *value)\n\n{\n\n    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };\n\n    int i;\n\n    int bit     = 0;\n\n    int bits    = 0;\n\n    int prevbit = 0;\n\n    unsigned val;\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (prevbit && bit)\n\n            break;\n\n        prevbit = bit;\n\n        bit = get_bits1(gb);\n\n        if (bit && !prevbit)\n\n            bits += series[i];\n\n    }\n\n    bits--;\n\n    if (bits < 0 || bits > 31) {\n\n        *value = 0;\n\n        return -1;\n\n    } else if (bits == 0) {\n\n        *value = 0;\n\n        return 0;\n\n    }\n\n\n\n    val  = get_bits_long(gb, bits);\n\n    val |= 1 << bits;\n\n\n\n    *value = val - 1;\n\n\n\n    return 0;\n\n}\n", "idx": 10868, "substitutes": {"gb": ["g", "ga", "abi", "ctx", "bm", "gnu", "gam", "GB", "gm", "nb", "rg", "bc", "gg", "gd", "db", "game", "pc", "xy", "eb", "usb", "sb", "cb", "kb", "vg", "boot", "gy", "b", "gio", "gi", "vd", "cfg", "rb", "hub", "bb", "ui", "bin", "gui", "gp", "gin", "abb", "gpu", "gs", "bf", "ge", "storage", "py", "gc", "ig", "slice"], "value": ["VALUE", "server", "version", "valid", "message", "size", "type", "format", "service", "comment", "view", "description", "weight", "values", "result", "db", "write", "feature", "sv", "model", "function", "response", "member", "range", "end", "scale", "memory", "iv", "v", "code", "image", "parent", "key", "time", "get", "store", "index", "buffer", "reference", "query", "component", "Value", "unit", "child", "process", "variable", "video", "volume", "ve", "data", "name", "number", "object"], "series": ["axis", "chain", "groups", "events", "parts", "vals", "service", "proc", "serial", "seconds", "sequence", "params", "config", "bytes", "options", "si", "details", "seed", "ds", "frame", "IES", "scale", "sector", "array", "stores", "channel", "source", "store", "frames", "pins", "ints", "data", " Series", "eries", "slice", "Series"], "i": ["ii", "ni", "pos", "li", "uri", "f", "id", "I", "k", "ip", "oi", "fi", "jit", "is", "ini", "multi", "ri", "p", "si", "z", "b", "pi", "io", "j", "ori", "gi", "bit", "ie", "part", "in", "xi", "di", "bi", "ti", "v", "ind", "qi", "ui", "bin", "o", "l", "ci", "u", "index", "col", "e", "n", "info", "ai", "x", "ix", "it"], "val": [" eval", "la", "abi", "pos", "valid", "vol", "pass", "block", "f", "vec", "vals", "ref", "update", "sel", "bc", "seq", "len", "al", "fe", "eval", "bl", "p", " slot", " v", "b", "Val", "bit", "pt", "VAL", "pre", "sl", "part", "v", "bal", " bit", "el", "ret", "bin", "rel", "l", "dim", "cond", "col", "base", "unit", " ret", "data", "count", "x", "sum"], "bits": ["flags", "pos", "changes", "planes", "cycles", "places", "bugs", "bis", "rots", "parts", "ats", "vals", "its", "cs", "ids", "items", " bugs", "points", "ins", "cuts", "rows", "bytes", "cats", "fps", "works", "lines", "details", "boot", "blocks", "ips", "steps", "b", "runs", "settings", "files", "bit", "units", "alls", "dates", "bs", "part", "limits", "bands", "forces", "ns", "codes", "pieces", "reads", "bin", "ps", "gets", "hours", "words", "frames", "jobs", "pins", "ints", "ubs", "base", "versions", "lins", "s", "bug", "count", "ports", "ops", "features"]}}
{"project": "FFmpeg", "commit_id": "09ce5519f3b44873ac242e9a2f89db7d459de532", "target": 1, "func": "static void check_add_res(HEVCDSPContext h, int bit_depth)\n\n{\n\n    int i;\n\n    LOCAL_ALIGNED_32(int16_t, res0, [32 * 32]);\n\n    LOCAL_ALIGNED_32(int16_t, res1, [32 * 32]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst0, [32 * 32 * 2]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst1, [32 * 32 * 2]);\n\n\n\n    for (i = 2; i <= 5; i++) {\n\n        int block_size = 1 << i;\n\n        int size = block_size * block_size;\n\n        ptrdiff_t stride = block_size << (bit_depth > 8);\n\n        declare_func_emms(AV_CPU_FLAG_MMX, void, uint8_t *dst, int16_t *res, ptrdiff_t stride);\n\n\n\n        randomize_buffers(res0, size);\n\n        randomize_buffers2(dst0, size);\n\n        memcpy(res1, res0, sizeof(*res0) * size);\n\n        memcpy(dst1, dst0, size);\n\n\n\n        if (check_func(h.add_residual[i - 2], \"add_res_%dx%d_%d\", block_size, block_size, bit_depth)) {\n\n            call_ref(dst0, res0, stride);\n\n            call_new(dst1, res1, stride);\n\n            if (memcmp(dst0, dst1, size))\n\n                fail();\n\n            bench_new(dst1, res1, stride);\n\n        }\n\n    }\n\n}\n", "idx": 10869, "substitutes": {"h": ["FH", "g", "hw", "H", "hd", "f", "hr", "host", "self", "oh", "c", "help", "cache", "cpp", "p", "ha", "http", "sh", "b", "work", "bh", "hp", "hh", "ht", "him", "v", "hub", "hs", "ch", "header", "t", "r", "handler", "ih", "l", "he", "hl", "w", "m", "dh", "e", "eh", "rh", "hist", "hm"], "bit_depth": [" bit_strength", "bit2deep", "block_depth", "bit_Depth", "bit2depth", "bit_height", "bitfheight", "bit64depth", "bitftype", " bit_deep", "bit2rate", " bit_Depth", "bit_rate", "bit_deep", "bitfdepth", "bit32height", "bit32type", "bit_size", " bit_rate", "bit_type", "bit32depth", "bitfsize", "bit64deep", "bit32size", "bit2strength", " bit_size", "block_type", "bit64rate", "bit64strength", "block_height", "bit_strength", "block_size"], "i": ["ii", "ni", "abi", "li", "uri", "size", "f", "phi", "I", "k", "ip", "mi", "fi", "y", "depth", "c", "iu", "ini", "d", "multi", "ri", "p", "si", "b", "pi", "io", "j", "gi", "ie", "di", "v", "ti", "bi", "z", "zi", "qi", "t", "ui", "xi", "l", "ci", "u", "index", "m", "e", "n", "ai", "mini", "eni", "count", "x", "ix", "it"]}}
{"project": "qemu", "commit_id": "0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae", "target": 0, "func": "static void test_validate_fail_union_flat(TestInputVisitorData *data,\n\n                                          const void *unused)\n\n{\n\n    UserDefFlatUnion *tmp = NULL;\n\n    Error *errp = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string': 'c', 'integer': 41, 'boolean': true }\");\n\n\n\n    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);\n\n    g_assert(error_is_set(&errp));\n\n    qapi_free_UserDefFlatUnion(tmp);\n\n}\n", "idx": 10875, "substitutes": {"data": ["dat", "valid", "empty", "f", "format", "Data", "api", "buf", "self", "result", "media", "parser", "c", "i", "d", "DATA", "config", "p", "temp", "xxx", "input", "fake", "iterator", "database", "done", "style", "test", "array", "record", "parent", "reader", "t", "da", "call", "u", "m", "buffer", "init", "base", "this", "video"], "unused": ["unus", "Unused", "untus", "Unus", "Unchecked", "untused", " unus", " unchecked", "unchecked", "unuse", "Unuse", "untuse", " unuse", "untchecked"], "tmp": ["np", "tp", "tf", "dest", "f", "api", "vt", "buf", "self", "mp", "metadata", "front", "pb", "c", "conv", "verb", "cmp", "sb", "amp", "config", "cpp", "p", "temp", "b", "fake", "kk", "j", "Temp", "test", "uv", "rb", "array", "fp", "lv", "vm", "copy", "t", "uf", "vp", "obj", "tc", "tv", "wb", "var", "vv", "py", "video", "txt"], "errp": ["lerp", "erpr", "rarp", "herf", "erlp", "errP", "errpr", "ErP", "aerpc", "rarpe", " erP", "lerpc", "errf", "Erf", "aerpy", "herp", " erpe", "rarpr", "iterpr", "herP", "iterpc", "aerpr", " erpr", "lerpy", "erp", "errlp", " erp", "iterpy", "erf", "errpc", "lerpr", "herlp", "aerp", "erP", "erpe", "Erp", "errpe", "Erlp", "iterp", "rarP", "errpy"], "v": ["g", "f", "k", "vt", "api", "c", "i", "sv", "d", "h", "p", "temp", "j", "test", "vd", "uv", "z", "iv", "lv", "vm", "cv", "o", "t", "nv", "val", "l", "V", "q", "u", "vp", "w", "m", "e", "n", "obj", "value", "tv", "s", "vv", "vi", "vs"]}}
{"project": "qemu", "commit_id": "a9321a4d49d65d29c2926a51aedc5b91a01f3591", "target": 0, "func": "void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)\n\n{\n\n#if defined(DEBUG_MMU)\n\n    printf(\"CR4 update: CR4=%08x\\n\", (uint32_t)env->cr[4]);\n\n#endif\n\n    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=\n\n        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {\n\n        tlb_flush(env, 1);\n\n    }\n\n    /* SSE handling */\n\n    if (!(env->cpuid_features & CPUID_SSE))\n\n        new_cr4 &= ~CR4_OSFXSR_MASK;\n\n    if (new_cr4 & CR4_OSFXSR_MASK)\n\n        env->hflags |= HF_OSFXSR_MASK;\n\n    else\n\n        env->hflags &= ~HF_OSFXSR_MASK;\n\n\n\n    env->cr[4] = new_cr4;\n\n}\n", "idx": 10877, "substitutes": {"env": ["ne", "dat", "server", "np", "dict", "loader", "args", "ctx", "global", "eng", "err", "nc", "ea", "exc", "state", "chal", "engine", "db", "en", "eu", "event", "cache", "config", "ev", "enc", "console", "tern", "stage", "ep", "vs", "Environment", "scope", "net", "inst", "extra", "ass", "ext", "style", "context", "end", "enter", "viron", "code", "cv", "here", "environment", "v", "el", "export", "que", "her", "conn", "esi", "erb", "dev", "conf", "inet", "obj", "e", "er", "profile", "ec", "fg", "py", "manager", "txt", "energy", "exec", "ef", "enable"], "new_cr4": ["new_CR2", "new_corefour", "new_CR8", "new_rc8", "new_CRfour", "new_Cr40", "new_rc1", "new_rc4", "new_cm04", "new_Cr8", "new_core1", "new_CR40", "new_cm8", "new_CR04", "new_crfour", "new_cm1", "new_cr1", "new_cr04", "new_cr40", "new_cr2", "new_rc40", "new_core4", "new_Cr4", "new_core2", "new_Cr04", "new_rc2", "new_cm4", "new_Crfour", "new_rcfour", "new_Cr1", "new_CR4", "new_cr8", "new_CR1", "new_cm2", "new_cmfour", "new_Cr2"]}}
{"project": "qemu", "commit_id": "ffad4116b96e29e0fbe892806f97c0a6c903d30d", "target": 0, "func": "int drive_init(struct drive_opt *arg, int snapshot, void *opaque)\n\n{\n\n    char buf[128];\n\n    char file[1024];\n\n    char devname[128];\n\n    char serial[21];\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int bdrv_flags, onerror;\n\n    int drives_table_idx;\n\n    char *str = arg->opt;\n\n    static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\",\n\n                                           \"cyls\", \"heads\", \"secs\", \"trans\",\n\n                                           \"media\", \"snapshot\", \"file\",\n\n                                           \"cache\", \"format\", \"serial\", \"werror\",\n\n                                           NULL };\n\n\n\n    if (check_params(buf, sizeof(buf), params, str) < 0) {\n\n         fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\",\n\n                         buf, str);\n\n         return -1;\n\n    }\n\n\n\n    file[0] = 0;\n\n    cyls = heads = secs = 0;\n\n    bus_id = 0;\n\n    unit_id = -1;\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    index = -1;\n\n    cache = 3;\n\n\n\n    if (machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"bus\", str)) {\n\n        bus_id = strtol(buf, NULL, 0);\n\n\tif (bus_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"unit\", str)) {\n\n        unit_id = strtol(buf, NULL, 0);\n\n\tif (unit_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", str)) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf);\n\n            return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"index\", str)) {\n\n        index = strtol(buf, NULL, 0);\n\n\tif (index < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid index\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cyls\", str)) {\n\n        cyls = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"heads\", str)) {\n\n        heads = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"secs\", str)) {\n\n        secs = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"trans\", str)) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    str);\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"media\", str)) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", str);\n\n\t        return -1;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"snapshot\", str)) {\n\n        if (!strcmp(buf, \"on\"))\n\n\t    snapshot = 1;\n\n        else if (!strcmp(buf, \"off\"))\n\n\t    snapshot = 0;\n\n\telse {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cache\", str)) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return -1;\n\n        }\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"format\", str)) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return -1;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (arg->file == NULL)\n\n        get_param_value(file, sizeof(file), \"file\", str);\n\n    else\n\n        pstrcpy(file, sizeof(file), arg->file);\n\n\n\n    if (!get_param_value(serial, sizeof(serial), \"serial\", str))\n\n\t    memset(serial, 0,  sizeof(serial));\n\n\n\n    onerror = BLOCK_ERR_STOP_ENOSPC;\n\n    if (get_param_value(buf, sizeof(serial), \"werror\", str)) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' index cannot be used with bus and unit\\n\", str);\n\n            return -1;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get_index(type, bus_id, unit_id) != -1) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\",\n\n                        str, unit_id, max_devs - 1);\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get_index(type, bus_id, unit_id) != -1)\n\n        return -2;\n\n\n\n    /* init */\n\n\n\n    if (type == IF_IDE || type == IF_SCSI)\n\n        mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n    if (max_devs)\n\n        snprintf(buf, sizeof(buf), \"%s%i%s%i\",\n\n                 devname, bus_id, mediastr, unit_id);\n\n    else\n\n        snprintf(buf, sizeof(buf), \"%s%s%i\",\n\n                 devname, mediastr, unit_id);\n\n    bdrv = bdrv_new(buf);\n\n    drives_table_idx = drive_get_free_idx();\n\n    drives_table[drives_table_idx].bdrv = bdrv;\n\n    drives_table[drives_table_idx].type = type;\n\n    drives_table[drives_table_idx].bus = bus_id;\n\n    drives_table[drives_table_idx].unit = unit_id;\n\n    drives_table[drives_table_idx].onerror = onerror;\n\n    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[nb_drives].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    }\n\n    if (!file[0])\n\n        return -2;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    if (bdrv_key_required(bdrv))\n\n        autostart = 0;\n\n    return drives_table_idx;\n\n}\n", "idx": 10899, "substitutes": {"arg": ["param", "g", "parse", "pg", "args", "match", "ref", "tag", "rg", "pc", "Arg", "amp", "enc", "arc", "ace", "ang", "slot", "input", "arr", "gen", "ag", "flag", "doc", "ar", "par", "op", "ac", "inc", "val", "argument", "mac", "call", "oc", "mor", "reg", "ad", "ig", "exec"], "snapshot": ["preshot", "snapprint", "snapview", "imageview", "imageprint", "picshot", "picvision", "imageshot", "preprint", "preview", "snapvision", "prevision", "picview", "picprint", "imagevision"], "opaque": ["ospcam", "ospaque", "opacity", "iopcam", " opac", "pc", "operc", " opc", "iopac", "opcam", " opacity", "pacity", "opac", "ospacity", "pac", "iopaque", "paque", "ospac", "operaque", "operacity", "iopacity", "opercam", "opc", "operac"], "buf": ["bus", "cas", "ctr", "usr", "text", "block", "loader", "ctx", "pool", "vec", "src", "uint", "path", "args", "ref", "exc", "proc", "grab", "result", "bc", "bag", "seq", "box", "ru", "config", "rc", "cb", "cur", "input", "arr", "loc", "bridge", "b", "fb", "filename", "queue", "runner", "img", "doc", "bt", "context", "rb", "array", "begin", "code", "cv", "nat", "num", "header", "br", "uf", "cmd", "cf", "buff", "buffer", "desc", "pad", "func", "port", "msg", "fw", "holder", "wb", "cap", "fd", "uc"], "file": ["bus", "binary", "uri", "block", "f", "id", "comment", "path", "class", "byte", "File", "db", "model", "input", "filename", "queue", "files", "part", "cpu", "array", "image", "channel", "source", "resource", "buffer", "body", "base", "unit", "port", "profile", "line", "book", "name", "stream", "data", "object"], "devname": ["devicename", " devno", "buspath", "divname", "modnames", "modno", "devicepath", "busName", "modName", "defName", "devicenames", "evname", "devsize", " devName", "evpath", "deviceno", "devnames", " devnames", "divName", "divno", "devno", "devpath", "defnames", "divsize", "devName", "deviceName", "evno", "defno", "devicesize", "busno", " devpath", "modname", "busname", "modsize", "defname"], "serial": ["version", "pass", "uri", "prefix", "mount", "mode", "comment", "device", "proc", "tag", "controller", "cmp", "master", "pack", "model", "loc", "toc", "spec", "lang", "parent", "mask", "dev", "series", "desc", "util", " bus", "status"], "mediastr": ["mediastrb", "generustr", "generustry", "mediastsr", "mediastsrb", "mediastrs", "mediestry", "generastr", "generustrs", "mediestrb", "generastrb", "generastrs", "mediastry", "mediustrb", "mediustr", "mediestrs", "generastry", "mediustrs", "mediestr", "mediustry", "generustrb", "mediastsry", "mediastsrs"], "type": ["like", "block", " TYPE", "id", "format", "comment", "view", "state", "class", "tag", "y", "pb", "user", "label", "instance", "by", "method", "config", "model", "p", "Type", "full", "style", "position", "family", "TYPE", "rule", "part", "key", "code", "pe", "image", "parent", "t", "o", "link", "time", "rel", "command", "error", "resource", "source", "ty", "data", "base", "unit", "info", "ype", "name", "role", "typ", "types"], "media": ["language", "mode", "format", "device", "connection", "audio", "ma", "java", "medium", "music", "library", "i", "document", "model", "pi", "interface", "style", "memory", "Media", "package", "record", "image", "medi", "vm", "source", "resource", "command", "m", "port", "shared", "storage", "ype", "script", "manager", "volume", "data"], "bus_id": ["BUS_ids", "bus_head", " bus_num", "us_id", "us__num", "us__id", "BUS_kid", "bus_name", "busPid", "busuuid", "bus_num", "bus_ids", "bus_kid", "us__name", "us_name", "us_num", "BUS_id", "bus__num", "us_ids", "busuuname", "busPname", "bus_Id", "unit_Id", "us__ids", "bus__id", "busuuhead", "bus_info", "bus__ids", "bus__name", " bus_head", "BUS_info", "busPnum", "unit_ids", "busuunum", " bus_name", "unit_name", "busPhead"], "unit_id": ["bus_name", "unit_ident", "block_id", "block_kid", " unit_sid", "unit_sid", "unit__name", "unit__ident", "bus_ident", " unit_num", "block_name", "unit_num", "unit_name", " unit_name", "unit_kid", "unit__id"], "cyls": ["gyles", " cyll", "cyils", "tyils", "cyvs", "cryls", "chels", "crylf", "tyles", "cylf", "cryils", "cyll", "gyll", "tylf", "cheles", "cyles", "copils", "gyls", "tyls", "copls", "cryles", "gyvs", "chell", "coples", "coplf", " cyvs", " cyles", "chevs"], "heads": ["flags", "tests", "devices", "scenes", "views", "checks", "ids", "times", "HEAD", "rows", "lines", "blocks", "headers", "pages", "files", "tails", "modules", "offs", "loads", "shots", "sections", "reads", "stars", "frames", "jobs", "plugins", "head", "links", "workers", "docs", "comments", "obs", "issues", "pull", "locks", "types", "drivers"], "secs": ["ECds", "SEClocks", "isecr", "ECs", " secS", "isecS", "sectr", "secS", "isecls", "SECs", "secr", "secds", "sects", " secls", "iseclocks", "sectS", "SECS", "isecds", "ECr", "sectds", "secls", " seclocks", "isecs", "seclocks", "ECS", "SECls"], "translation": ["language", "padding", "la", "pos", "utils", "version", "prefix", "text", "message", "layout", "activation", "comment", "description", "master", " translations", "offset", "options", "loc", "settings", "qa", "position", "lang", "rot", "length", "source", "val", "border", "conf", "base", "trans", "info", "Translation", "late", "comments", "port", "name", "ping", "alias", "seconds"], "bdrv": ["BDrp", "bDrp", "bdrw", "BDrf", "bDrw", "bdrf", "Bdrw", "BDrv", "bdrif", "bDrf", "Bdrf", "bdrp", "bDrv", "bdrip", "bdriw", "Bdrv", "BDrw", "bdriv", "Bdrp"], "drv": ["DrV", " drb", " drV", "Drp", "drp", "drV", "Drb", "srb", " drp", "drb", "srV", "srv", "srp", "Drv"], "machine": ["bus", "mount", "mode", "device", "service", "proc", "connection", "engine", "ma", "controller", "template", "instance", "computer", "node", "config", "model", "Machine", "bridge", "boot", "driver", "interface", "memory", "mob", "image", "vm", "mac", "m", "buffer", "unit", "info", "process", "storage", "mc", "slave", "meta", "manager", "target"], "max_devs": ["max_devp", "max_depp", "max_pubS", "max_pubi", "max_depn", "max_libns", "max_depi", "max_devns", "max_evn", "max_evi", "max_pubps", "max_devicei", "max_devn", "max_libs", "max_deviceges", "max_deps", "max_deviceS", "max_devS", "max_evps", "max_devicens", "max_devi", "max_libi", "max_evs", "max_evges", "max_libges", "max_devicen", "max_pubs", "max_evns", "max_evS", "max_deviceps", "max_evp", "max_devices", "max_devps", "max_devicep", "max_devges"], "index": ["axis", "action", "pos", "version", "prefix", "Index", "pointer", "id", "diff", "weight", "view", "connection", "x", "config", "scan", "offset", "condition", "input", "loc", "toc", "ticket", "position", "loop", "key", "image", "parent", "inc", "num", "length", "ind", "level", "error", "proxy", "head", "priority", "speed", "unit", "info", "page", "depth", "miss", "slice"], "cache": ["timeout", "prefix", "capacity", "block", "global", "pool", "pointer", "comment", "frac", "ref", "ache", "result", "tag", "c", "pc", "cmp", "master", "config", "cat", "rc", "scan", "temp", "pack", "slot", "session", "toc", "pre", "loop", "ac", "parent", "race", "sync", "Cache", "buffer", "lock", "conf", "base", "delay", "child", "lc", "batch", "count", "miss", "read", "acl"], "bdrv_flags": ["bdrf_flags", "bdrv_bits", "bdrf_ops", "bdrf_flag", "bdrf_bits", "bdrv_ops", "bdrv_flag"], "onerror": ["rerride", "onerception", "rerrors", "onerrors", "overrors", "onerride", "rerror", "overception", "overror", "error", "override", "erception", "rerception", "errors", "erride"], "drives_table_idx": ["drives_table_dx", "drives_table_sidxs", "drives_table_dv", "drives_table_sidv", "drives_table_sidxc", "drives_table_idv", "drives_table_dxc", "drives_table_idxc", "drives_table_idxs", "drives_table_sidx", "drives_table_dxs"], "str": ["tr", "ctr", "text", "dict", "fr", "empty", "pass", "ocr", "vec", "format", "err", "cs", "proc", "bc", "seq", "c", "iter", "dr", "config", "cat", "enc", "expr", "arr", "sp", "st", "lit", "url", "doc", "part", "sl", "par", "spec", "r", "br", "req", "String", "cf", "sync", "cr", "strip", "STR", "obj", "msg", "rs", "strings", "lc", "name", "inst", "exec", "Str"], "params": ["param", "prop", "pos", "block", "args", "ctx", " parameters", "vals", "description", "proc", " param", "afi", "config", " args", "p", "names", "options", "arr", "details", "settings", "url", "rb", "array", "par", "spec", "css", "r", "attr", "ps", "req", "mac", "Parameters", "desc", "conf", "obj", "info", "rs", "ams", "data", "types", "vs", "acl"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void unix_wait_for_connect(int fd, Error *err, void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n\n\n    if (fd < 0) {\n\n        DPRINTF(\"migrate connect error: %s\\n\", error_get_pretty(err));\n\n        s->file = NULL;\n\n        migrate_fd_error(s);\n\n    } else {\n\n        DPRINTF(\"migrate connect success\\n\");\n\n        s->file = qemu_fopen_socket(fd, \"wb\");\n\n        migrate_fd_connect(s);\n\n    }\n\n}\n", "idx": 10914, "substitutes": {"fd": ["timeout", "pipe", "fn", "sd", "hd", "f", "pointer", "file", "buf", "draft", "ff", "sf", "fi", "handle", "flo", "td", "addr", "md", "exec", "fe", "d", "pd", "fee", "ds", "fb", "FD", "io", "socket", "nd", "bd", "fa", "fat", "fp", "fc", "dd", "dc", "ind", "df", "handler", " FD", "cmd", "conn", "ffff", "fx", "cond", "tty", "fw", "fed", "dl", "ad", " fid", "cd", "dir", "pid"], "err": ["server", "fr", "exc", "fi", "result", "y", "iter", "Er", "finder", "sr", "dr", "ser", "ev", "ace", "p", "der", "ror", "ie", "ar", "rb", "r", "ise", "error", "eor", "later", "req", "reader", "acer", "ir", "cer", "cr", "gr", "e", "er", "sys", "rs", "rr", "res", "status"], "opaque": ["OPque", "opacity", " opque", "ipacity", "boacity", " opacity", "pacity", "Opacity", "ipaque", "Opaque", "Opatile", "ipque", "pque", "boque", "OPatile", "paques", "paque", "boaques", "opaques", "ipaques", " opatile", "OPaque", "opque", "OPacity", "opatile", "Opque", "boaque"], "s": ["server", "g", "sym", "f", "request", "service", "ls", "sf", "ss", "y", "sq", "c", "stat", "is", "i", "a", "an", "services", "sb", "es", "h", "p", "ts", "sg", "si", "S", "ds", "http", "settings", "session", "ssl", "b", "sl", "ns", "hs", "spec", "us", "o", "r", "t", "ps", "ses", "sync", "gs", "m", "conf", "south", "sys", "su", "rs", "js", "stats", "status"]}}
{"project": "FFmpeg", "commit_id": "2862b63783b5556f7f3fb2d097629bc6879f833a", "target": 0, "func": "static int ljpeg_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n\n                              const AVFrame *pict, int *got_packet)\n\n{\n\n    LJpegEncContext *s = avctx->priv_data;\n\n    PutBitContext pb;\n\n    const int width  = avctx->width;\n\n    const int height = avctx->height;\n\n    const int mb_width  = (width  + s->hsample[0] - 1) / s->hsample[0];\n\n    const int mb_height = (height + s->vsample[0] - 1) / s->vsample[0];\n\n    int max_pkt_size = AV_INPUT_BUFFER_MIN_SIZE;\n\n    int ret, header_bits;\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_BGR24)\n\n        max_pkt_size += width * height * 3 * 3;\n\n    else {\n\n        max_pkt_size += mb_width * mb_height * 3 * 4\n\n                        * s->hsample[0] * s->vsample[0];\n\n    }\n\n    if ((ret = ff_alloc_packet(pkt, max_pkt_size)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet of size %d.\\n\", max_pkt_size);\n\n        return ret;\n\n    }\n\n\n\n    init_put_bits(&pb, pkt->data, pkt->size);\n\n\n\n    ff_mjpeg_encode_picture_header(avctx, &pb, &s->scantable,\n\n                                   s->matrix);\n\n\n\n    header_bits = put_bits_count(&pb);\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_BGR24)\n\n        ret = ljpeg_encode_bgr(avctx, &pb, pict);\n\n    else\n\n        ret = ljpeg_encode_yuv(avctx, &pb, pict);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    emms_c();\n\n\n\n    ff_mjpeg_encode_picture_trailer(&pb, header_bits);\n\n\n\n    flush_put_bits(&pb);\n\n    pkt->size   = put_bits_ptr(&pb) - pb.buf;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 10950, "substitutes": {"avctx": ["navctx", "avsci", "aircontext", "maccontext", "avcas", "navcmp", " avcci", "aircb", "navxc", "raftcontext", "macctx", "navtx", "aftx", "apkb", "AVsci", "apconn", "avkb", "afcb", "macconn", "avcv", "avectx", "AVsync", "avvoc", "navcontext", "ajcontext", " avcas", "avsync", " avcontext", "apcontext", "avexc", "afsci", "airconn", "avecontext", "ajconn", "aircci", "AVcontext", "afcv", "avconn", "afcontext", "ajcmp", "avcci", "AVctx", "aircv", "afkb", "avtx", "ajvoc", "raftcas", "avecb", "AVkb", "navsync", "afconn", "AVcmp", "avekb", "ajctx", "afvoc", "avecmp", " avcv", "evkb", "afctx", "airctx", "navconn", "afcmp", "macvoc", " avkb", "avcmp", "avcontext", "afcci", "evctx", "evcmp", "raftvoc", "raftctx", "avcb", "ajsci", "avetx", "afcas", "afsync", "navkb", "apctx", "afxc", " avconn", " avvoc", "avxc", "aveconn", "evcontext"], "pkt": [" packet", "facket", "pct", "mct", "pwk", "cpqt", "packet", "Pct", "opacket", "tct", "mkt", "macket", "Pck", "fkt", " pwk", "Pkg", "Pkt", "Pqt", " pqt", "Packet", "cpkt", "pcp", "pkg", "fwk", "cpct", "Pcp", " pct", "hkg", "hacket", "pck", " pck", "opet", " pkg", "cpkg", "Pet", "hwk", "pet", "tkt", "mcp", " pet", "opct", " pcp", "hkt", "cpacket", "fkg", "tacket", "pqt", "opkt", "tck"], "pict": ["jpg", "mut", "chat", "bis", "pai", "fi", "proc", "plain", "private", "png", "sq", "stat", " pic", "config", "cat", "xxx", "sci", " img", "pas", "Pic", "img", "fig", "pic", " picture", "fat", "pot", "cli", "image", "client", "ch", "phot", "gui", "Pict", "picture", "mac", "conn", "capt", "cam", "cot", "imag", "photo", "qq", "sec", "photos", "quant", "pty", "mot", "feat"], "got_packet": ["got_capant", "got_packed\n", "got_sexant", "got_packed_", "got_packacket", "got_packs\n", "got_sexets", "got_packedx", "got_packsx", "got_sexet", "got_Pack_", "got_paramacket", "got_capet", "got_capacket", "got_packx", "got_Pack\n", "got_paramet", "got_pack_", "got_pack\n", "got_packets", "got_paramant", "got_packs_", "got_capets", "got_sexacket", "got_Packx", "got_packant", "got_paramets"], "s": ["sym", "service", "cs", "self", "c", "a", "i", "sv", "d", "sci", "settings", "b", "gs", "w", "sn", "e", "rs", "js", "os", "bis", "site", "ls", "ss", "sq", "params", "sb", "h", "S", "session", "ds", "fs", "ssl", "o", "ses", "qs", "sc", "f", "sf", "y", "services", "sg", "sl", "in", "v", "r", "ps", "l", "sync", "u", "sys", "su", "g", "args", "side", "sup", "is", "es", "p", "si", "ns", "spec", "us", "t", "m", "conf", "n", "sets", "storage", "sa", "data", "ops", "aws"], "pb": [" gp", " ssh", "plugin", "pg", "tp", "ctx", "dp", "bm", "pm", " conf", "buf", "api", "pl", "typ", " SCP", " eb", "ss", "nb", "bc", "rob", "bps", "db", "pc", " subp", "lb", "eb", "jp", "lab", "sb", "lp", "pd", "cpp", "cb", "p", "kb", " fs", "pkg", "b", "fm", " db", " ns", "fb", "bh", "cp", "ub", "gb", " rc", "rb", "fp", "fc", "tmp", "hub", "prot", "bb", "xb", "platform", "gp", "uf", "sc", " sd", "vp", "tx", "pa", "wb", "sa", "bp", " pc", "dl", "bf", "PB", "bot", "kB"], "ret": ["sur", "valid", "pass", "rets", "rt", "f", "match", "id", "resp", "re", "RET", "att", "ref", "feat", "ft", "result", "success", "lt", "len", "en", "ben", "art", "back", "cur", "fun", "lit", "flag", "ext", "run", "ut", "gt", "aud", "code", "rot", "active", "num", "fail", "opt", "val", "det", "rep", "def", "arg", "reply", "fit", "obj", "base", "pat", "value", "res", "reg", "nt", "fin", "alt", "Ret", "bf", "status", "bot", "let", "str"], "header_bits": ["head_pieces", " header_parts", "header_bytes", "head_parts", "head_length", " header_bytes", "header96count", "header_count", " header_count", "header96bits", "header96parts", "header_length", "head_bits", "header_parts", "header96bytes", "header_pieces"]}}
{"project": "FFmpeg", "commit_id": "27bcf55f459e038e81f09c17e72e6d44898b9015", "target": 1, "func": "int av_vsrc_buffer_add_video_buffer_ref(AVFilterContext *buffer_filter, AVFilterBufferRef *picref)\n\n{\n\n    BufferSourceContext *c = buffer_filter->priv;\n\n    AVFilterLink *outlink = buffer_filter->outputs[0];\n\n    int ret;\n\n\n\n    if (c->picref) {\n\n        av_log(buffer_filter, AV_LOG_ERROR,\n\n               \"Buffering several frames is not supported. \"\n\n               \"Please consume all available frames before adding a new one.\\n\"\n\n            );\n\n        //return -1;\n\n    }\n\n\n\n    if (picref->video->w != c->w || picref->video->h != c->h || picref->format != c->pix_fmt) {\n\n        AVFilterContext *scale = buffer_filter->outputs[0]->dst;\n\n        AVFilterLink *link;\n\n        char scale_param[1024];\n\n\n\n        av_log(buffer_filter, AV_LOG_INFO,\n\n               \"Buffer video input changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",\n\n               c->w, c->h, av_pix_fmt_descriptors[c->pix_fmt].name,\n\n               picref->video->w, picref->video->h, av_pix_fmt_descriptors[picref->format].name);\n\n\n\n        if (!scale || strcmp(scale->filter->name, \"scale\")) {\n\n            AVFilter *f = avfilter_get_by_name(\"scale\");\n\n\n\n            av_log(buffer_filter, AV_LOG_INFO, \"Inserting scaler filter\\n\");\n\n            if ((ret = avfilter_open(&scale, f, \"Input equalizer\")) < 0)\n\n                return ret;\n\n\n\n            snprintf(scale_param, sizeof(scale_param)-1, \"%d:%d:%s\", c->w, c->h, c->sws_param);\n\n            if ((ret = avfilter_init_filter(scale, scale_param, NULL)) < 0) {\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n\n\n            if ((ret = avfilter_insert_filter(buffer_filter->outputs[0], scale, 0, 0)) < 0) {\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n            scale->outputs[0]->time_base = scale->inputs[0]->time_base;\n\n\n\n            scale->outputs[0]->format= c->pix_fmt;\n\n        } else if (!strcmp(scale->filter->name, \"scale\")) {\n\n            snprintf(scale_param, sizeof(scale_param)-1, \"%d:%d:%s\",\n\n                     scale->outputs[0]->w, scale->outputs[0]->h, c->sws_param);\n\n            scale->filter->init(scale, scale_param, NULL);\n\n        }\n\n\n\n        c->pix_fmt = scale->inputs[0]->format = picref->format;\n\n        c->w       = scale->inputs[0]->w      = picref->video->w;\n\n        c->h       = scale->inputs[0]->h      = picref->video->h;\n\n\n\n        link = scale->outputs[0];\n\n        if ((ret =  link->srcpad->config_props(link)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    c->picref = avfilter_get_video_buffer(outlink, AV_PERM_WRITE,\n\n                                          picref->video->w, picref->video->h);\n\n    av_image_copy(c->picref->data, c->picref->linesize,\n\n                  picref->data, picref->linesize,\n\n                  picref->format, picref->video->w, picref->video->h);\n\n    avfilter_copy_buffer_ref_props(c->picref, picref);\n\n\n\n    return 0;\n\n}\n", "idx": 10962, "substitutes": {"buffer_filter": ["input_filter", "input_fl", "buffer64filter", "buffer64sort", "texture_filter", "layer_model", "layer_sort", "bufferkhandle", "filter_filter", "reference_filter", "filteracfilter", "filter_fil", "bufferacfilter", "buffer_flush", "filteracmanager", "buffer_part", "bufferkfilter", " buffer_layer", "buffer_handle", "input_info", "bufferwfilter", "buffer_info", "bufferablecontrol", "request_fill", " buffer_search", "buffer_fat", "bufferablefill", "inputingfat", "bufferacfil", "bufferacmodel", "bufferinginfo", "buffer_context", "inputinginfo", "bufferkpart", "bufferqflush", "request64control", "bufferablefilter", "request64filter", "buffer64control", "buffer_fil", "request_filter", "bufferacsort", "bufferwheader", "bufferappfat", "bufferinghandle", "media_control", "request_control", "bufferingfil", "request64fill", "bufferappcontrol", "layer_filter", "bufferingfat", "filteracfil", "bufferacsearch", "bufferappfill", "media_fill", "bufferableflush", "inputingfl", "bufferacheader", "buffer_layer", "buffer_header", "bufferwmanager", "buffer_fill", "filter_header", "filter_manager", "filteracheader", " buffer_flush", "input_fat", "buffer64layer", "buffer_fl", "texture_fil", "bufferwfil", "buffer64fill", "texture_handle", "reference_context", "buffer_model", "bufferacmanager", "media_fil", "bufferqsearch", "buffer_sort", "texture_part", "buffer64search", "bufferappfl", "layer_search", "bufferingfl", "bufferingfilter", "bufferappfilter", "inputingfilter", "reference_info", "bufferingpart", "bufferappfil", "buffer_manager", "bufferappinfo", "bufferqfilter", "buffer_control", "bufferkfil", "bufferqlayer", "buffer64flush", "buffer64model", "buffer_search", "request64flush", "reference_sort", "media_filter", "request_flush"], "picref": ["pinid", "mcinfo", "fatref", "Picdef", " picRef", "macnum", "fcid", "pcinfo", "Picinf", "pcdef", "nickrel", "picinf", "chatreference", "chataff", "chatRef", "sysrel", "Picreference", "sysreference", "pic1", "chatref", "macRef", "fcRef", "Picnum", "nickref", "pinRef", "pinref", "PicRef", "fcreference", "picRef", "macreference", "pcref", "picinfo", "picrel", "nicref", "picdef", " picrel", "payref", "Picref", "synaff", " pic1", " picreference", "nicconf", "fatreference", "fatinf", "nicreference", "Picconf", "mcRef", "fatRef", "payRef", "pictnum", "sysconf", "sysref", "pictreference", "picreference", "picaff", "nicRef", "mcref", "nickreference", "macref", "fcref", "pindef", "picnum", "payreference", "payinf", "pictRef", "pinreference", "synref", "picid", "sysRef", "pininfo", "Picinfo", "synreference", "sys1", "Picaff", "macid", " picinfo", "synRef", "picconf", "nick1", "pictref", "mcreference", "pcreference"], "c": ["g", "chain", "ctx", "chart", "xc", "k", "cs", "bc", "ce", "y", "vc", "pc", "ca", "i", "co", "course", "d", "a", "config", "h", "p", "arc", "z", "b", "cm", "cp", "cu", "con", "ctrl", "center", "context", "cc", "in", "v", "C", "dc", "ac", "client", "coll", "parent", "t", "cl", "o", "r", "channel", "l", "cf", "sc", "ci", "conn", "u", "cr", "call", "w", "m", "com", "rec", "oc", "e", "n", "this", "cn", "tc", "lc", "mc", "s", "ec", "uc", "cache"], "outlink": ["inlinks", "inlink", "outlinks", "inloader", "imagelinks", "imageLink", "imagelink", "newlink", "newlinks", "outLink", "newLink", "outloader", "newloader", "inLink", "imageloader"], "ret": ["rt", "re", "RET", "ref", "err", "success", "replace", "mem", "rep", "job", "arg", "pat", "info", "nt", "alt", "Ret", "status", "prop", "pass", "rets", "id", "result", "cat", "back", "lit", "flag", "run", "code", "num", "fail", "error", "det", "get", "base", "reg", "res", "str", "debug", "usr", "valid", "att", "resp", "bc", "len", " RET", "fun", "part", "reply", "fit", "value", "bug", "bad", "count", "match", "final", "ft", "url", "bit", "rb", "gt", "val", "def", "obj", "bf", "data", "bot", "let"], "scale": ["transform", "server", "setup", "service", "alpha", "pixel", "score", "network", "draw", "fee", "settings", "replace", "channel", "area", "form", "w", "series", "e", "info", "margin", "root", "complex", "alias", "ii", "size", "update", "user", "scan", "stage", "scope", "range", "shape", "coll", "code", "crop", "sort", "error", "call", "sc", "te", "base", "lan", "late", "set", "video", "rate", "mode", "config", " scaling", "total", "cal", "center", "sl", "source", "gp", "cf", "cale", "ge", "large", "Scale", "g", "ga", "parse", "flow", "gam", "ce", "label", "co", "cache", "ale", "rating", "p", "order", "si", "seed", "fake", "url", "rule", "se", "spec", "image", "filter", "mask", "save", "cam", "unit", "grade", "data", "slice", "zone"], "link": ["li", "parse", "file", "service", "ink", "path", "pixel", "model", "bridge", "loc", "load", "url", "plane", "feed", "image", "copy", "layer", "channel", "call", "proxy", "sync", "links", "lan", "Link", "location", "slice", "line"], "scale_param": ["scale_return", "scale_block", "scale___nm", "scale_name", "scale___num", "scale_num", "filteracname", "scaleerparam", "scaleingterm", "scale2param", "data_conn", "filteracpar", "data_size", "pixel_nm", "scaleacblock", "scaleFterm", "scaleFreturn", "data_return", "scaleingparam", "filter_name", "scale_par", "scaleingreturn", "dataerparam", "scale___par", "pixel_par", "scale2num", "filteracparam", "data_term", "scale_conn", "scale2size", "filter_param", "filter_block", "dataerconn", "scale___param", "scale2params", "scale_nm", "filteracblock", "dataerterm", "scale_size", "scaleacpar", "scale_params", "scaleingconn", "data_params", "pixel_num", "scaleerreturn", "dataerreturn", "pixel_param", "scaleFparam", "scaleFconn", "scaleacparam", "scaleacname", "scale_term", "scaleerterm", "filter_par", "scaleerconn", "data_param", "data_num"], "f": ["F", "g", "fr", "tf", "file", "flow", "sf", "fi", "i", "fe", "d", "h", "p", "b", "fm", "fs", "fb", "fl", "j", "fa", "v", "fp", "fc", "filter", "t", "r", "o", "l", "cf", "u", "fx", "w", "m", "cale", "fit", "e", "info", "fg", "s"]}}
{"project": "FFmpeg", "commit_id": "9568b2e425f127031ddc91dd78cb9b9f2cae206d", "target": 1, "func": "int ff_h264_decode_picture_parameter_set(GetBitContext *gb, AVCodecContext *avctx,\n                                         H264ParamSets *ps, int bit_length)\n{\n    AVBufferRef *pps_buf;\n    const SPS *sps;\n    unsigned int pps_id = get_ue_golomb(gb);\n    PPS *pps;\n    int qp_bd_offset;\n    int bits_left;\n    int ret;\n    if (pps_id >= MAX_PPS_COUNT) {\n        av_log(avctx, AV_LOG_ERROR, \"pps_id %u out of range\\n\", pps_id);\n        return AVERROR_INVALIDDATA;\n    pps_buf = av_buffer_allocz(sizeof(*pps));\n    if (!pps_buf)\n        return AVERROR(ENOMEM);\n    pps = (PPS*)pps_buf->data;\n    pps->data_size = gb->buffer_end - gb->buffer;\n    if (pps->data_size > sizeof(pps->data)) {\n        av_log(avctx, AV_LOG_WARNING, \"Truncating likely oversized PPS \"\n               \"(%\"SIZE_SPECIFIER\" > %\"SIZE_SPECIFIER\")\\n\",\n               pps->data_size, sizeof(pps->data));\n        pps->data_size = sizeof(pps->data);\n    memcpy(pps->data, gb->buffer, pps->data_size);\n    pps->sps_id = get_ue_golomb_31(gb);\n    if ((unsigned)pps->sps_id >= MAX_SPS_COUNT ||\n        !ps->sps_list[pps->sps_id]) {\n        av_log(avctx, AV_LOG_ERROR, \"sps_id %u out of range\\n\", pps->sps_id);\n    sps = (const SPS*)ps->sps_list[pps->sps_id]->data;\n    if (sps->bit_depth_luma > 14) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Invalid luma bit depth=%d\\n\",\n               sps->bit_depth_luma);\n    } else if (sps->bit_depth_luma == 11 || sps->bit_depth_luma == 13) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Unimplemented luma bit depth=%d\\n\",\n               sps->bit_depth_luma);\n        ret = AVERROR_PATCHWELCOME;\n    pps->cabac             = get_bits1(gb);\n    pps->pic_order_present = get_bits1(gb);\n    pps->slice_group_count = get_ue_golomb(gb) + 1;\n    if (pps->slice_group_count > 1) {\n        pps->mb_slice_group_map_type = get_ue_golomb(gb);\n        av_log(avctx, AV_LOG_ERROR, \"FMO not supported\\n\");\n        switch (pps->mb_slice_group_map_type) {\n        case 0:\n#if 0\n    |       for (i = 0; i <= num_slice_groups_minus1; i++)  |   |      |\n    |           run_length[i]                               |1  |ue(v) |\n#endif\n            break;\n        case 2:\n#if 0\n    |       for (i = 0; i < num_slice_groups_minus1; i++) { |   |      |\n    |           top_left_mb[i]                              |1  |ue(v) |\n    |           bottom_right_mb[i]                          |1  |ue(v) |\n    |       }                                               |   |      |\n#endif\n            break;\n        case 3:\n        case 4:\n        case 5:\n#if 0\n    |       slice_group_change_direction_flag               |1  |u(1)  |\n    |       slice_group_change_rate_minus1                  |1  |ue(v) |\n#endif\n            break;\n        case 6:\n#if 0\n    |       slice_group_id_cnt_minus1                       |1  |ue(v) |\n    |       for (i = 0; i <= slice_group_id_cnt_minus1; i++)|   |      |\n    |           slice_group_id[i]                           |1  |u(v)  |\n#endif\n            break;\n    pps->ref_count[0] = get_ue_golomb(gb) + 1;\n    pps->ref_count[1] = get_ue_golomb(gb) + 1;\n    if (pps->ref_count[0] - 1 > 32 - 1 || pps->ref_count[1] - 1 > 32 - 1) {\n        av_log(avctx, AV_LOG_ERROR, \"reference overflow (pps)\\n\");\n    qp_bd_offset = 6 * (sps->bit_depth_luma - 8);\n    pps->weighted_pred                        = get_bits1(gb);\n    pps->weighted_bipred_idc                  = get_bits(gb, 2);\n    pps->init_qp                              = get_se_golomb(gb) + 26 + qp_bd_offset;\n    pps->init_qs                              = get_se_golomb(gb) + 26 + qp_bd_offset;\n    pps->chroma_qp_index_offset[0]            = get_se_golomb(gb);\n    pps->deblocking_filter_parameters_present = get_bits1(gb);\n    pps->constrained_intra_pred               = get_bits1(gb);\n    pps->redundant_pic_cnt_present            = get_bits1(gb);\n    pps->transform_8x8_mode = 0;\n    memcpy(pps->scaling_matrix4, sps->scaling_matrix4,\n           sizeof(pps->scaling_matrix4));\n    memcpy(pps->scaling_matrix8, sps->scaling_matrix8,\n           sizeof(pps->scaling_matrix8));\n    bits_left = bit_length - get_bits_count(gb);\n    if (bits_left > 0 && more_rbsp_data_in_pps(sps, avctx)) {\n        pps->transform_8x8_mode = get_bits1(gb);\n        decode_scaling_matrices(gb, sps, pps, 0,\n                                pps->scaling_matrix4, pps->scaling_matrix8);\n        // second_chroma_qp_index_offset\n        pps->chroma_qp_index_offset[1] = get_se_golomb(gb);\n        if (pps->chroma_qp_index_offset[1] < -12 || pps->chroma_qp_index_offset[1] > 12) {\n    } else {\n        pps->chroma_qp_index_offset[1] = pps->chroma_qp_index_offset[0];\n    build_qp_table(pps, 0, pps->chroma_qp_index_offset[0],\n                   sps->bit_depth_luma);\n    build_qp_table(pps, 1, pps->chroma_qp_index_offset[1],\n                   sps->bit_depth_luma);\n    init_dequant_tables(pps, sps);\n    if (pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1])\n        pps->chroma_qp_diff = 1;\n    if (avctx->debug & FF_DEBUG_PICT_INFO) {\n        av_log(avctx, AV_LOG_DEBUG,\n               \"pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\\n\",\n               pps_id, pps->sps_id,\n               pps->cabac ? \"CABAC\" : \"CAVLC\",\n               pps->slice_group_count,\n               pps->ref_count[0], pps->ref_count[1],\n               pps->weighted_pred ? \"weighted\" : \"\",\n               pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1],\n               pps->deblocking_filter_parameters_present ? \"LPAR\" : \"\",\n               pps->constrained_intra_pred ? \"CONSTR\" : \"\",\n               pps->redundant_pic_cnt_present ? \"REDU\" : \"\",\n               pps->transform_8x8_mode ? \"8x8DCT\" : \"\");\n    remove_pps(ps, pps_id);\n    ps->pps_list[pps_id] = pps_buf;\n    return 0;\nfail:\n    av_buffer_unref(&pps_buf);\n    return ret;", "idx": 10971, "substitutes": {"gb": ["g", "ga", "pg", "ctx", "bm", "bn", "gam", "GB", "gom", "gm", "nb", "rg", "bc", "gg", "pb", "bps", "gd", "db", "pc", "lb", "eb", "usb", "sb", "cb", "kb", "tm", "tg", "sg", "gh", "gy", "mb", "bg", "cfg", "rb", "bd", "gt", "hub", "vm", "bb", "gp", "abb", "gin", "buff", "gs", "wb", "bp", "py", "gc", "bf", "hm"], "avctx": ["navctx", "avcmp", "avcontext", "AVctx", "AVvoc", "avectx", "avsci", "avvoc", "navcontext", "afkb", "Avctx", "avalctx", "avalsci", "aveloc", "vercontext", "ivconn", "AVkb", "avci", "AVci", "navvoc", " avcontext", "Avcontext", "avloc", "Avci", "verconn", "AVloc", "vervoc", "ivctx", "AVcmp", "avekb", "avalcontext", "afsci", "AVsci", "afloc", "avkb", "AVconn", "verctx", "avecontext", "avecmp", "AVcontext", "ivcontext", "avalcmp", "Avkb", " avci", "avconn", "afctx", "navconn", "afcmp", "afcontext", " avkb", "ivvoc"], "ps": ["eps", "pse", "pers", "changes", "pg", "posts", "ples", "cs", "ls", "pl", "mp", "ss", "ups", "ppa", "ys", "xs", "bps", "points", "ks", "params", "pr", "p", "fps", "aps", "sp", "details", "ds", "ips", "icks", "amps", "px", "PS", "pt", "alls", "po", "ypes", "hs", "pe", "ms", "pp", "gs", "acts", "pa", "pes", "rs", "s", "ams", "Ps", "ports", "ops"], "bit_length": ["imagelenlen", "bitlenlen", "image_angle", "imagelensize", "bitpangle", "bit_angle", "bit_len", "image_length", "image_len", "bitplength", "image_size", "bit_size", "bitpsize", "bitlenlength", "imagelenangle", "bitlenangle", "bitlensize", "bitplen", "imagelenlength"], "pps_buf": ["pps_buff", "pps_fd", "ppa_buff", "pps_uf", "pps_vec", "pps2uf", "pps_bag", "ppa_bag", "pps2bag", "ppa_fd", "ppa_uf", "pps2buf", "ppa_buf", "ppa_vec", "pps2buff", "pps2buffer", "ppa_buffer", "pps_buffer"], "sps": ["Sips", "SPS", "ppps", "sips", "insups", "yourips", "ppe", "jspped", " spp", " sper", "jsPS", "gips", "cpps", "spped", "Spped", "syspped", " spe", "sper", "sports", "spp", "Spps", "spes", "cps", "insps", "Sps", "inspes", "jsps", "osps", "sples", "gps", "Sbs", " spped", " sips", "yourps", "spe", "Spe", "osples", "ospps", "cples", " spes", "yourPS", " sups", "pper", " sports", "jsports", "osips", "ppp", "sups", "gpe", "spps", "cips", "sysps", "inspps", " sPS", "sbs", "sysports", "pples", "yourpped", " spps", "gPS", "sysPS", "sPS", " sbs", "pips"], "pps": ["opers", "apps", "eps", "changes", "dds", "pg", "sels", "ppe", "posts", "shows", "ils", "php", "mph", "ls", "rpm", "pl", "mp", "ups", "ppa", "xs", "drops", "bps", "ppy", "ppo", "ks", "pkg", "services", "params", "lp", "works", "cpp", "fps", "lines", "details", "ds", "ips", "icks", "amps", "kk", "px", "PS", "hops", "hp", "pages", "tracks", "hh", "includes", "forces", "alls", "phones", "ypes", "hs", "dd", "pieces", "oper", "clips", "pp", "pins", "plugins", "acts", "ppers", "pes", "docs", "upp", "opp", "packs", " pp", "pull", "asts", "types", "vs", "ops", "ipes"], "qp_bd_offset": [" qp_bdwoffset", " qp_bd_index", " qp_bd2index", " qp_data_index", " qp_bd2offset", " qp_data_offset", " qp_bd2address", " qp_data_off", " qp_bd_off", " qp_bd_address", " qp_bdwaddress", " qp_bd2off", " qp_bdwoff", " qp_bdwindex", " qp_data_address"], "bits_left": ["its_needed", "bits_needed", "its_right", "its_left", "bits_right"], "ret": ["pass", "resp", "RET", "eth", "proc", "result", "success", " resp", " success", " RET", "rc", "back", "arr", " result", "fun", "results", "rem", "error", "rep", "def", "rs", "res", "alt", "Ret"]}}
{"project": "qemu", "commit_id": "a52b2cbf218d52f9e357961acb271a98a2bdff71", "target": 1, "func": "static void qxl_spice_monitors_config_async(PCIQXLDevice *qxl, int replay)\n\n{\n\n    trace_qxl_spice_monitors_config(qxl->id);\n\n    if (replay) {\n\n        /*\n\n         * don't use QXL_COOKIE_TYPE_IO:\n\n         *  - we are not running yet (post_load), we will assert\n\n         *    in send_events\n\n         *  - this is not a guest io, but a reply, so async_io isn't set.\n\n         */\n\n        spice_qxl_monitors_config_async(&qxl->ssd.qxl,\n\n                qxl->guest_monitors_config,\n\n                MEMSLOT_GROUP_GUEST,\n\n                (uintptr_t)qxl_cookie_new(\n\n                    QXL_COOKIE_TYPE_POST_LOAD_MONITORS_CONFIG,\n\n                    0));\n\n    } else {\n\n#if SPICE_SERVER_VERSION >= 0x000c06 /* release 0.12.6 */\n\n        if (qxl->max_outputs) {\n\n            spice_qxl_set_monitors_config_limit(&qxl->ssd.qxl,\n\n                                                qxl->max_outputs);\n\n        }\n\n#endif\n\n        qxl->guest_monitors_config = qxl->ram->monitors_config;\n\n        spice_qxl_monitors_config_async(&qxl->ssd.qxl,\n\n                qxl->ram->monitors_config,\n\n                MEMSLOT_GROUP_GUEST,\n\n                (uintptr_t)qxl_cookie_new(QXL_COOKIE_TYPE_IO,\n\n                                          QXL_IO_MONITORS_CONFIG_ASYNC));\n\n    }\n\n}\n", "idx": 10974, "substitutes": {"qxl": ["queryrxll", "qxsle", "Qtxlc", "qexlc", "questionxll", "qoxlc", " qxls", "qfxli", "qxp", "qexli", "questionexpsl", "qexlin", "qaxli", "qxplp", "qrxel", "uxxl", "qxtsl", "qrxl", "qxmll", " qxla", "qqfxsl", "Qtxl", "qxxsl", "pxxli", "qexel", "Qtxn", " qexla", "qxcel", "qfxl", "qtxl", "qxlp", "qqxl", "questionexplc", "qXlc", "sqxcl", "questionexpll", "qxn", "qxpl", "sqxclc", "qtxla", "iqxsl", "quxla", "qexpsl", "qwxl", "qxls", "qtxli", "qexle", "qtlin", " qrxlp", "iqxs", "qtxlc", "quxpl", "qwxls", "iqxp", "Qxli", " qrxel", "qaxls", "qyl", "quxplp", "Qxn", "qxcL", "qxtp", "qXl", "queryxlb", "qxmlly", "qrxlb", "qexs", "sqxcL", "Qxlc", " qrxli", "iqexl", "qqxsl", " qxlin", "qxtls", " qxel", "pxxlc", "qxxl", "pxxl", " qexl", " qrxl", "qtxsl", "qexL", "qxflc", "qxle", "qxlc", "qaxlc", "qxmlls", "quxll", "qylc", "iqxlc", "qxcl", "uxxli", "sqxlc", "qXL", "qexla", " qxlp", "qqli", "qxsll", "iqexs", "iqexli", "qaxsl", "qqfxls", "quxls", "quxl", "qwxel", " qrxlc", "qxmlll", "qxxlp", "qxesp", "qxll", "qqxls", "qrxlp", "qfxls", "qxxlc", "qqxli", "iqxli", "qxxli", "quxpla", "qexp", "qrxle", "Qtxli", "qurxl", "qexly", "sqxL", "qaxl", "qxfll", "questionxsl", "qoxla", "iqxl", "sqxcel", "qxxla", "qxL", "sqxl", "qxxle", "qxfsl", "quxlp", "qxlin", "qxlb", "qexpll", "pxl", "sqxel", "qqfxl", "qexls", "queryrxle", "qqlc", "qrxls", "qexll", " qrxls", "qxs", "qxpla", "qqfxli", "questionxl", "qxesl", "qxfl", "qxesls", "qexpl", "qxly", "qxslb", "uxlc", "iqexlc", "qxli", "queryrxlb", "uxxlc", "qurxly", "qxclc", "qfxsl", "qxla", "qurxll", "qoxl", "qexn", "quxs", "pxli", "qexplc", "qtla", "qrxly", "qql", "qtxlp", "qxsl", "qxel", "qxtl", "iqexp", "qaxn", "qoxlin", "queryxl", "qtxn", "qxplc", "qrxlc", "queryxll", "qXel", "questionxlc", " qxlc", "uxli", "qexl", "qylp", "qurxls", "qexsl", "uxl", " qrxle", "uxle", "quxli", " qxle", "queryxle", "qqsl", "questionexpl", "qtl", "qyli", "iqexls", "qxxs", "qxessl", "pxxsl", "quxlc", "qtlc", "qrxli", "pxlc", "quxplc", "pxsl", " qexlin", "iqxls", " qxli", "Qxl", " qexlc", "iqexsl", "qwxle", "uxxle", "qaxle", "queryrxl", "quxly", "qrxll", "qtxll"], "replay": ["reload", "ereplay", " reload", "relplays", "ereplays", "preplay", " replays", "REpeat", "relresh", "erepeat", "ereresh", "REplay", "relplay", "relpeat", "preload", "replays", "REload", "REresh", "reresh", "preplays", "replaying", "REplaying", " replaying", "repeat", "preplaying", "REplays"]}}
{"project": "qemu", "commit_id": "086abc1ccd0fa5103345adda819e6c6436949579", "target": 0, "func": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n    int queues = n->multiqueue ? n->max_queues : 1;\n\n\n\n    if (!get_vhost_net(nc->peer)) {\n\n        return;\n\n    }\n\n\n\n    if (!!n->vhost_started ==\n\n        (virtio_net_started(n, status) && !nc->peer->link_down)) {\n\n        return;\n\n    }\n\n    if (!n->vhost_started) {\n\n        int r;\n\n        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {\n\n            return;\n\n        }\n\n        n->vhost_started = 1;\n\n        r = vhost_net_start(vdev, n->nic->ncs, queues);\n\n        if (r < 0) {\n\n            error_report(\"unable to start vhost net: %d: \"\n\n                         \"falling back on userspace virtio\", -r);\n\n            n->vhost_started = 0;\n\n        }\n\n    } else {\n\n        vhost_net_stop(vdev, n->nic->ncs, queues);\n\n        n->vhost_started = 0;\n\n    }\n\n}\n", "idx": 10982, "substitutes": {"n": ["ne", "g", "np", "nor", "fn", "adj", "pn", "f", "un", "on", "nic", "k", "self", "na", "nb", "c", "network", "en", "i", "N", "an", "d", "yn", "node", "nov", "new", "anon", "p", "enc", "gn", "b", "net", "ic", "nu", "j", "rn", "nl", "ns", "v", "nit", "z", "num", "dn", "o", "t", "l", "conn", "u", "nn", "m", "sn", "w", "not", "e", "cn", "ln", "nt", "s", "syn", "mn", "hn", "nm"], "status": ["ok", "server", "remote", "version", "np", "size", "resp", "state", "ss", "result", "stat", "network", "uses", "node", "config", "rss", "nil", "details", "cli", "code", "spec", "nat", "active", "std", "conn", "sync", "sc", "current", "sys", "progress", "out", "s", "name", "stats", "data", "Status", "str"], "vdev": ["vDev", "vtr", "vev", "wev", "pserv", "vserv", " vserv", "svver", "svtr", "Vdiv", " vev", "vver", " vver", "hdevice", "Vserv", "ltr", "htr", " vdevice", "wdevice", "pdiv", "lver", "wDev", "svswitch", "Vdev", "svdevice", "pdev", "pdevice", "VDev", " vswitch", "vdevice", "ldevice", "Vdevice", "svdev", " vDev", " vdiv", "ldev", "hdev", "wdev", "svdiv", "vdiv", "hdiv", "vswitch", "Vev", "lswitch"], "nc": ["ne", "ni", "np", "ctx", "nr", "nic", "cdn", "cs", "bn", "nec", "bc", "c", "pc", "qt", "rc", "enc", "cb", "ck", "gn", "net", "rn", "nw", "ct", "ng", "cc", "ns", "fc", "dc", "cv", "dn", "roc", "nv", "ci", "conn", "nn", "sn", "NC", "cn", "nt", "mc", "lc", "ec", "mn", "jc", "nm"], "r": ["g", "rw", "f", "nr", "re", "hr", "k", "err", "result", "rg", "ra", "c", "mr", "a", "i", "sr", "d", "ru", "rc", "pr", "lr", "p", "rd", "rl", "arr", "rf", "b", "R", "ar", "rb", "z", "v", "row", "rx", "o", "br", "attr", "t", "kr", "l", "error", "u", "cr", "w", "m", "e", "er", "rs", "rr", "rh", "rar", "or", "str"]}}
{"project": "qemu", "commit_id": "7ebaf7955603cc50988e0eafd5e6074320fefc70", "target": 0, "func": "static void spapr_cpu_core_host_initfn(Object *obj)\n\n{\n\n    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);\n\n    char *name = g_strdup_printf(\"%s-\" TYPE_POWERPC_CPU, \"host\");\n\n    ObjectClass *oc = object_class_by_name(name);\n\n\n\n    g_assert(oc);\n\n    g_free((void *)name);\n\n    core->cpu_class = oc;\n\n}\n", "idx": 10984, "substitutes": {"obj": ["server", "os", "ctx", "args", "src", "api", "host", "self", "Obj", "instance", "node", "orb", "j", "objects", "gb", "po", "rb", "oid", "code", "parent", "o", "alloc", "conn", "Object", "org", "n", "ob", "so", "bot", "object", "cache"], "core": ["ocr", "clean", "anc", "cs", "ce", "bc", "can", "c", "pc", "ca", "Core", "ore", "rc", "ro", "ace", "enc", "arc", "cur", "ck", "cy", "cp", "runner", "rn", "con", "cpu", "fc", "ac", "roc", "cf", "conn", "cer", "cr", "org", "base", "sys", "ob", "custom", "ec", "lc", "gc", "object"], "name": ["prefix", "no", "size", "type", "known", "id", "comment", "NAME", "path", "anc", "Name", "class", "c", "label", "search", "instance", "new", "names", "span", "loc", "url", "ext", "part", "key", "code", "ac", "num", "o", "word", "call", "sn", "desc", "n", "info", "ame", "s", "null", "var", "none", "data", "nam", "alias", "named", "str"], "oc": ["hop", "os", "oca", "unc", "anc", "oco", "voc", "class", "bc", "ou", "c", "pc", "auc", "instance", "aco", "co", "rc", "enc", "loc", "ic", "soc", "cc", "oid", "fc", "ac", "dc", "roc", "alloc", "o", "OC", "oci", "org", "ob", "ec", "mc", "uc", "object", "isc"]}}
{"project": "FFmpeg", "commit_id": "892fc83e88a20f9543c6c5be3626712be7a2e6f2", "target": 0, "func": "static void init_block_mapping(Vp3DecodeContext *s) \n\n{\n\n    int i, j;\n\n    signed int hilbert_walk_y[16];\n\n    signed int hilbert_walk_c[16];\n\n    signed int hilbert_walk_mb[4];\n\n\n\n    int current_fragment = 0;\n\n    int current_width = 0;\n\n    int current_height = 0;\n\n    int right_edge = 0;\n\n    int bottom_edge = 0;\n\n    int superblock_row_inc = 0;\n\n    int *hilbert = NULL;\n\n    int mapping_index = 0;\n\n\n\n    int current_macroblock;\n\n    int c_fragment;\n\n\n\n    signed char travel_width[16] = {\n\n         1,  1,  0, -1, \n\n         0,  0,  1,  0,\n\n         1,  0,  1,  0,\n\n         0, -1,  0,  1\n\n    };\n\n\n\n    signed char travel_height[16] = {\n\n         0,  0,  1,  0,\n\n         1,  1,  0, -1,\n\n         0,  1,  0, -1,\n\n        -1,  0, -1,  0\n\n    };\n\n\n\n    signed char travel_width_mb[4] = {\n\n         1,  0,  1,  0\n\n    };\n\n\n\n    signed char travel_height_mb[4] = {\n\n         0,  1,  0, -1\n\n    };\n\n\n\n    debug_vp3(\"  vp3: initialize block mapping tables\\n\");\n\n\n\n    /* figure out hilbert pattern per these frame dimensions */\n\n    hilbert_walk_y[0]  = 1;\n\n    hilbert_walk_y[1]  = 1;\n\n    hilbert_walk_y[2]  = s->fragment_width;\n\n    hilbert_walk_y[3]  = -1;\n\n    hilbert_walk_y[4]  = s->fragment_width;\n\n    hilbert_walk_y[5]  = s->fragment_width;\n\n    hilbert_walk_y[6]  = 1;\n\n    hilbert_walk_y[7]  = -s->fragment_width;\n\n    hilbert_walk_y[8]  = 1;\n\n    hilbert_walk_y[9]  = s->fragment_width;\n\n    hilbert_walk_y[10]  = 1;\n\n    hilbert_walk_y[11] = -s->fragment_width;\n\n    hilbert_walk_y[12] = -s->fragment_width;\n\n    hilbert_walk_y[13] = -1;\n\n    hilbert_walk_y[14] = -s->fragment_width;\n\n    hilbert_walk_y[15] = 1;\n\n\n\n    hilbert_walk_c[0]  = 1;\n\n    hilbert_walk_c[1]  = 1;\n\n    hilbert_walk_c[2]  = s->fragment_width / 2;\n\n    hilbert_walk_c[3]  = -1;\n\n    hilbert_walk_c[4]  = s->fragment_width / 2;\n\n    hilbert_walk_c[5]  = s->fragment_width / 2;\n\n    hilbert_walk_c[6]  = 1;\n\n    hilbert_walk_c[7]  = -s->fragment_width / 2;\n\n    hilbert_walk_c[8]  = 1;\n\n    hilbert_walk_c[9]  = s->fragment_width / 2;\n\n    hilbert_walk_c[10]  = 1;\n\n    hilbert_walk_c[11] = -s->fragment_width / 2;\n\n    hilbert_walk_c[12] = -s->fragment_width / 2;\n\n    hilbert_walk_c[13] = -1;\n\n    hilbert_walk_c[14] = -s->fragment_width / 2;\n\n    hilbert_walk_c[15] = 1;\n\n\n\n    hilbert_walk_mb[0] = 1;\n\n    hilbert_walk_mb[1] = s->macroblock_width;\n\n    hilbert_walk_mb[2] = 1;\n\n    hilbert_walk_mb[3] = -s->macroblock_width;\n\n\n\n    /* iterate through each superblock (all planes) and map the fragments */\n\n    for (i = 0; i < s->superblock_count; i++) {\n\n        debug_init(\"    superblock %d (u starts @ %d, v starts @ %d)\\n\",\n\n            i, s->u_superblock_start, s->v_superblock_start);\n\n\n\n        /* time to re-assign the limits? */\n\n        if (i == 0) {\n\n\n\n            /* start of Y superblocks */\n\n            right_edge = s->fragment_width;\n\n            bottom_edge = s->fragment_height;\n\n            current_width = 0;\n\n            current_height = 0;\n\n            superblock_row_inc = 3 * s->fragment_width;\n\n            hilbert = hilbert_walk_y;\n\n\n\n            /* the first operation for this variable is to advance by 1 */\n\n            current_fragment = -1;\n\n\n\n        } else if (i == s->u_superblock_start) {\n\n\n\n            /* start of U superblocks */\n\n            right_edge = s->fragment_width / 2;\n\n            bottom_edge = s->fragment_height / 2;\n\n            current_width = 0;\n\n            current_height = 0;\n\n            superblock_row_inc = 3 * (s->fragment_width / 2);\n\n            hilbert = hilbert_walk_c;\n\n\n\n            /* the first operation for this variable is to advance by 1 */\n\n            current_fragment = s->u_fragment_start - 1;\n\n\n\n        } else if (i == s->v_superblock_start) {\n\n\n\n            /* start of V superblocks */\n\n            right_edge = s->fragment_width / 2;\n\n            bottom_edge = s->fragment_height / 2;\n\n            current_width = 0;\n\n            current_height = 0;\n\n            superblock_row_inc = 3 * (s->fragment_width / 2);\n\n            hilbert = hilbert_walk_c;\n\n\n\n            /* the first operation for this variable is to advance by 1 */\n\n            current_fragment = s->v_fragment_start - 1;\n\n\n\n        }\n\n\n\n        if (current_width >= right_edge) {\n\n            /* reset width and move to next superblock row */\n\n            current_width = 0;\n\n            current_height += 4;\n\n\n\n            /* fragment is now at the start of a new superblock row */\n\n            current_fragment += superblock_row_inc;\n\n        }\n\n\n\n        /* iterate through all 16 fragments in a superblock */\n\n        for (j = 0; j < 16; j++) {\n\n            current_fragment += hilbert[j];\n\n            current_height += travel_height[j];\n\n\n\n            /* check if the fragment is in bounds */\n\n            if ((current_width <= right_edge) &&\n\n                (current_height < bottom_edge)) {\n\n                s->superblock_fragments[mapping_index] = current_fragment;\n\n                debug_init(\"    mapping fragment %d to superblock %d, position %d\\n\", \n\n                    s->superblock_fragments[mapping_index], i, j);\n\n            } else {\n\n                s->superblock_fragments[mapping_index] = -1;\n\n                debug_init(\"    superblock %d, position %d has no fragment\\n\", \n\n                    i, j);\n\n            }\n\n\n\n            current_width += travel_width[j];\n\n            mapping_index++;\n\n        }\n\n    }\n\n\n\n    /* initialize the superblock <-> macroblock mapping; iterate through\n\n     * all of the Y plane superblocks to build this mapping */\n\n    right_edge = s->macroblock_width;\n\n    bottom_edge = s->macroblock_height;\n\n    current_width = 0;\n\n    current_height = 0;\n\n    superblock_row_inc = s->macroblock_width;\n\n    hilbert = hilbert_walk_mb;\n\n    mapping_index = 0;\n\n    current_macroblock = -1;\n\n    for (i = 0; i < s->u_superblock_start; i++) {\n\n\n\n        if (current_width >= right_edge) {\n\n            /* reset width and move to next superblock row */\n\n            current_width = 0;\n\n            current_height += 2;\n\n\n\n            /* macroblock is now at the start of a new superblock row */\n\n            current_macroblock += superblock_row_inc;\n\n        }\n\n\n\n        /* iterate through each potential macroblock in the superblock */\n\n        for (j = 0; j < 4; j++) {\n\n            current_macroblock += hilbert_walk_mb[j];\n\n            current_height += travel_height_mb[j];\n\n\n\n            /* check if the macroblock is in bounds */\n\n            if ((current_width <= right_edge) &&\n\n                (current_height < bottom_edge)) {\n\n                s->superblock_macroblocks[mapping_index] = current_macroblock;\n\n                debug_init(\"    mapping macroblock %d to superblock %d, position %d\\n\",\n\n                    s->superblock_macroblocks[mapping_index], i, j);\n\n            } else {\n\n                s->superblock_macroblocks[mapping_index] = -1;\n\n                debug_init(\"    superblock %d, position %d has no macroblock\\n\",\n\n                    i, j);\n\n            }\n\n\n\n            current_width += travel_width_mb[j];\n\n            mapping_index++;\n\n        }\n\n    }\n\n\n\n    /* initialize the macroblock <-> fragment mapping */\n\n    current_fragment = 0;\n\n    current_macroblock = 0;\n\n    mapping_index = 0;\n\n    for (i = 0; i < s->fragment_height; i += 2) {\n\n\n\n        for (j = 0; j < s->fragment_width; j += 2) {\n\n\n\n            debug_init(\"    macroblock %d contains fragments: \", current_macroblock);\n\n            s->all_fragments[current_fragment].macroblock = current_macroblock;\n\n            s->macroblock_fragments[mapping_index++] = current_fragment;\n\n            debug_init(\"%d \", current_fragment);\n\n\n\n            if (j + 1 < s->fragment_width) {\n\n                s->all_fragments[current_fragment + 1].macroblock = current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = current_fragment + 1;\n\n                debug_init(\"%d \", current_fragment + 1);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            if (i + 1 < s->fragment_height) {\n\n                s->all_fragments[current_fragment + s->fragment_width].macroblock = \n\n                    current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = \n\n                    current_fragment + s->fragment_width;\n\n                debug_init(\"%d \", current_fragment + s->fragment_width);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            if ((j + 1 < s->fragment_width) && (i + 1 < s->fragment_height)) {\n\n                s->all_fragments[current_fragment + s->fragment_width + 1].macroblock = \n\n                    current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = \n\n                    current_fragment + s->fragment_width + 1;\n\n                debug_init(\"%d \", current_fragment + s->fragment_width + 1);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            /* C planes */\n\n            c_fragment = s->u_fragment_start + \n\n                (i * s->fragment_width / 4) + (j / 2);\n\n        s->all_fragments[c_fragment].macroblock = s->macroblock_count;\n\n            s->macroblock_fragments[mapping_index++] = c_fragment;\n\n            debug_init(\"%d \", c_fragment);\n\n\n\n            c_fragment = s->v_fragment_start + \n\n                (i * s->fragment_width / 4) + (j / 2);\n\n        s->all_fragments[c_fragment].macroblock = s->macroblock_count;\n\n            s->macroblock_fragments[mapping_index++] = c_fragment;\n\n            debug_init(\"%d \", c_fragment);\n\n\n\n            debug_init(\"\\n\");\n\n\n\n            if (j + 2 <= s->fragment_width)\n\n                current_fragment += 2;\n\n            else \n\n                current_fragment++;\n\n            current_macroblock++;\n\n        }\n\n\n\n        current_fragment += s->fragment_width;\n\n    }\n\n}\n", "idx": 10992, "substitutes": {"s": ["g", "os", "sym", "f", "bis", "site", "en", "service", "cs", "ls", "self", "ss", "inf", "y", "c", "sq", "sup", "is", "a", "services", "sv", "sb", "small", "es", "h", "p", "ts", "si", "sg", "S", "session", "b", "fs", "ssl", "ds", "full", "secondary", "an", "se", "ns", "v", "spec", "us", "sy", "t", "r", "ps", "qs", "ses", "l", "sc", "u", "gs", "m", "conf", "south", "e", "n", "sys", "sets", "su", "rs", "sec", "space", "js", "ops"], "i": ["ii", "li", "f", "I", "k", "mi", "y", "c", "a", "d", "p", "b", "in", "v", "ind", "r", "ui", "l", "ci", "u", "index", "m", "e", "n", "x", "it"], "j": ["ii", "pos", "k", "je", "jo", "java", "ak", "jp", "ji", "p", "offset", "b", "key", "z", "J", "o", "r", "l", "m", "job", "ij", "obj", "n", "jj", "js", "aj", "jc"], "hilbert_walk_y": ["hilbert_path_y", "hilbert_move_ry", "hilbert_wait_ya", "hilbert_hop_y", "hilbert_walk_ye", "hilbert_walkPyt", "hilbert_walk_ym", "hilbert_walk_ey", "hilbert_step_ya", "hilbert_walkPY", "hilbert_walk_iy", "hilbert_walk___x", "hilbert_walk_x", "hilbert_indexureoy", "hilbert_index_ya", "hilbert_move_iy", "hilbert_hop_x", "hilbert_walk_cy", "hilbert_index_x", "hilbert_walkPiy", "hilbert_walk___y", "hilbert_walk_type", "hilbert_walkFyn", "hilbert_indexureya", "hilbert_move_x", "hilbert_walk_oy", "hilbert_move_cy", "hilbert_walkFy", "hilbert_walkFx", "hilbert_move_xy", "hilbert_walk_xy", "hilbert_walkFya", "hilbert_walkurey", "hilbert_view_ya", "hilbert_move_Y", "hilbert_view_x", "hilbert_walk_ny", "hilbert_step_ye", "hilbert_path_ey", "hilbert_wait_ym", "hilbert_hop_ey", "hilbert_walk_ry", "hilbert_move_yt", "hilbert_path_cy", "hilbert_view_y", "hilbert_path_x", "hilbert_walk_Y", "hilbert_move_y", "hilbert_index_oy", "hilbert_wait_y", "hilbert_walk___ya", "hilbert_hop_vy", "hilbert_walk_vy", "hilbert_walkurex", "hilbert_walkureya", "hilbert_walk_ya", "hilbert_hop_ya", "hilbert_step_yt", "hilbert_move_type", "hilbert_index_y", "hilbert_wait_ye", "hilbert_move_ya", "hilbert_view_yn", "hilbert_walk___type", "hilbert_step_y", "hilbert_indexurex", "hilbert_walkPy", "hilbert_walk_yt", "hilbert_walk_yn", "hilbert_indexurey", "hilbert_walkureoy"], "hilbert_walk_c": ["hilbert_walker_c", "hilbert_walker_cy", "hilbert_walk_cy", "hilbert_walk_ci", "hilbert_walker_y", "hilbert_walker_ci"], "hilbert_walk_mb": ["hilbert_walker_mb", "hilbert_walker_b", "hilbert_walk_xb", "hilbert_walker_mm", "hilbert_walk_mm", "hilbert_walk_b", "hilbert_walker_xb"], "hilbert": ["hailbolt", "hillbert", "hilcox", "Hilbert", "Hailbert", "hillbolt", "Hilcox", "hillbl", "Hailbolt", "halbolt", "Hilbolt", "halbl", "hailbl", "Hilbl", "hilbolt", "halcox", "Hailbl", "halbert", "hailbert", "hillcox", "hailcox", "hilbl", "Hailcox"], "current_macroblock": ["current_microblocks", "current_macronrow", "current_mac_blocks", "current_macrocondition", "current_maclassblock", "current_microrow", "current_mac_row", "current_mac_condition", "current_maclassblocks", "current_macronblocks", "current_microblock", "current_macrorow", "current_macroncondition", "current_macronblock", "current_macroblocks", "current_mic_block", "current_mic_row", "current_mic_blocks", "current_maclasscondition", "current_mac_block", "current_microcondition", "current_maclassrow", "current_mic_condition"], "c_fragment": ["current_fagme", "current_fragement", "current_frangment", "current_fragments", "current_frragments", "current_frragme", "current_frangement", "current_frragement", "current_frasurements", "current_fagments", "current_frasureme", "current_frangments", "current_fagment", "current_frasureement", "current_frangme", "current_frragment", "current_fragme", "current_fagement", "current_frasurement"], "travel_width": [" travel_layout", "travel_shape", "travel___layout", "travelableweight", "travel___width", "travel___shape", "travel_weight", "travel___weight", "travelablelayout", "travel_layout", "travelablewidth", " travel_weight", "travelableshape", " travel_shape"], "travel_height": ["travel_distance", " travel_padding", "travelacpadding", "travelacwidth", "travelacdistance", " travel_distance", "travelacheight", "travel_padding"], "travel_width_mb": ["travel_width_mm", "travel_weight_mp", "travel_weight_mm", "travel_weight_bb", "travel_weight_mb", "travel_width_mp", "travel_width_bb"], "travel_height_mb": ["travel_data_bb", "travel_height_mm", "travel_height_mp", "travel_data_mp", "travel_data_mm", "travel_data_mb", "travel_height_bb"], "mapping_index": ["mapping_ind", "mapping_depth", "mapped_depth", "mapped_id", "mapped_index", "mapped_ind", "mapping_id"], "current_fragment": ["current_fragement", "current_dragement", "current_frangment", "current_frigments", "current_frigement", "current_frangmented", "current_dragment", "current_frigment", "current_drigment", "current_fragments", "current_fraggmented", "current_dragmented", "current_dragments", "current_drigement", "current_drigments", "current_frangement", "current_drigmented", "current_frangments", "current_frigmented", "current_fraggement", "current_fraggments", "current_fragmented", "current_fraggment"]}}
{"project": "qemu", "commit_id": "9a78eead0c74333a394c0f7bbfc4423ac746fcd5", "target": 0, "func": "void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; m68k_cpu_defs[i].name; i++) {\n\n        (*cpu_fprintf)(f, \"%s\\n\", m68k_cpu_defs[i].name);\n\n    }\n\n}\n", "idx": 10999, "substitutes": {"f": ["F", "g", "fen", "fr", "fn", "tf", "xf", "file", "ref", "fi", "proc", "sf", "c", "d", "h", "p", "rf", "b", "fs", "j", "fac", "feed", "fa", "v", "fp", "fc", "t", "r", "o", "df", "l", "cf", "form", "w", "m", "e", "n", "fff", "s", "fd", "name", "exec", "x"], "cpu_fprintf": ["cpu_fcmp", "cpu_formt", "cpu_forwrite", "cpu_Fflush", "cpu_Fcmp", "cpu_fwrite", "cpu_cfcmp", "cpu_Fprintf", "cpu_fdformat", "cpu_fprint", "cpu_forprintf", "cpu_cfprintf", "cpu_forprint", "cpu_fdprintf", "cpu_cfflush", "cpu_Fwrite", "cpu_Fmt", "cpu_fflush", "cpu_fformat", "cpu_fmt", "cpu_Fprint", "cpu_Fformat", "cpu_fdcmp", "cpu_cfformat", "cpu_fdflush"], "i": ["ii", "ni", "abi", "li", "uri", "hi", "block", "id", "phi", "I", "k", "mu", "oi", "fi", "c", "iu", "ini", "d", "multi", "ji", "p", "ri", "slice", "si", "b", "pi", "io", "j", "gi", "ie", "z", "v", "code", "bi", "di", "zi", "xi", "o", "ui", "t", "qi", "attr", "l", "ci", "u", "index", "start", "m", "e", "init", "info", "ai", "lc", "name", "x", "ix", "it"]}}
{"project": "qemu", "commit_id": "5a2223ca26b1a34e131b5b9a63599d9426d2c25c", "target": 0, "func": "int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,\n\n                              PCIHotplugState state)\n\n{\n\n    int slot = PCI_SLOT(dev->devfn);\n\n    int bsel = acpi_pcihp_get_bsel(dev->bus);\n\n    if (bsel < 0) {\n\n        return -1;\n\n    }\n\n\n\n    /* Don't send event when device is enabled during qemu machine creation:\n\n     * it is present on boot, no hotplug event is necessary. We do send an\n\n     * event when the device is disabled later. */\n\n    if (state == PCI_COLDPLUG_ENABLED) {\n\n        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);\n\n        return 0;\n\n    }\n\n\n\n    if (state == PCI_HOTPLUG_ENABLED) {\n\n        enable_device(s, bsel, slot);\n\n    } else {\n\n        disable_device(s, bsel, slot);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11016, "substitutes": {"s": ["server", "g", "os", "sym", "f", "service", "cs", "self", "ss", "states", "sq", "c", "is", "i", "a", "ks", "services", "d", "sv", "sb", "es", "an", "p", "http", "sg", "S", "session", "ds", "b", "fs", "ssl", "si", "sl", "ns", "spec", "ions", "us", "r", "o", "t", "ps", "ses", "u", "sync", "gs", "m", "south", "e", "sys", "info", "su", "rs", "js", "ops"], "dev": ["bus", "dem", "debug", "de", "wd", "die", "sd", "block", "device", "diff", "comment", "serial", "rad", "engine", "md", "adv", " device", "ver", "game", "d", "ev", "development", "der", "app", "driver", "Dev", "grad", "prom", "end", "v", "dc", "dd", "cmd", "def", "od", "w", "info", "priv", "ad", "bug", "data"], "state": ["shadow", "type", "un", "mode", " states", "err", "self", "ignore", "ss", "states", "STATE", "handle", "tag", "stat", "instance", "d", "config", "p", "ace", "cur", "see", "settings", "session", "st", "scope", "use", "driver", "seed", " self", "style", "se", "State", "sl", "rule", "part", "key", "spec", "parent", "t", "resource", "start", "sync", "head", "lock", "e", "port", "set", " State", "name", "status", "role", "statement"]}}
{"project": "FFmpeg", "commit_id": "af8aa846fa5b9f2c7dcde451c872426528b8b561", "target": 0, "func": "static void frame_start(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    int i;\n\n\n\n    MPV_frame_start(s, s->avctx);\n\n    ff_er_frame_start(s);\n\n\n\n    assert(s->linesize && s->uvlinesize);\n\n\n\n    for(i=0; i<16; i++){\n\n        h->block_offset[i]= 4*((scan8[i] - scan8[0])&7) + 4*s->linesize*((scan8[i] - scan8[0])>>3);\n\n        h->block_offset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->linesize*((scan8[i] - scan8[0])>>3);\n\n    }\n\n    for(i=0; i<4; i++){\n\n        h->block_offset[16+i]=\n\n        h->block_offset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*s->uvlinesize*((scan8[i] - scan8[0])>>3);\n\n        h->block_offset[24+16+i]=\n\n        h->block_offset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->uvlinesize*((scan8[i] - scan8[0])>>3);\n\n    }\n\n\n\n    /* can't be in alloc_tables because linesize isn't known there.\n\n     * FIXME: redo bipred weight to not require extra buffer? */\n\n    if(!s->obmc_scratchpad)\n\n        s->obmc_scratchpad = av_malloc(16*s->linesize + 2*8*s->uvlinesize);\n\n\n\n//    s->decode= (s->flags&CODEC_FLAG_PSNR) || !s->encoding || s->current_picture.reference /*|| h->contains_intra*/ || 1;\n\n}\n", "idx": 11026, "substitutes": {"h": ["g", "ph", "hd", "H", "hw", "ctx", "f", "hhh", "hr", "self", "host", "oh", "th", "home", "y", "c", "p", "ha", "http", "sh", "gh", "uh", "b", "ah", "bh", "hp", "hh", "ht", "hi", "hs", "v", "image", "ch", "header", "t", "o", "ih", "l", "he", "q", "hl", "w", "m", "e", "n", "this", "eh", "rh", "hash", "history", "x", "hm"], "s": ["server", "setup", "ctx", "sym", "ats", "cs", "self", "hes", "c", "a", "ks", "d", "sh", "settings", "b", "hs", "sites", "gs", "w", "e", "comments", "rs", "strings", "js", "ls", "ss", "sq", "params", "sb", "http", "S", "session", "ds", "fs", "ssl", "o", "qs", "ses", "sc", "sec", "f", "sw", "sf", "xs", "y", "services", "sg", "ssh", "sl", "v", "ions", "r", "ps", "l", "sync", "u", "sys", "support", "g", "args", "request", "side", "ys", "sports", "is", "es", "ts", "p", "si", "full", "se", "ns", "spec", "t", "m", "conf", "n", "this", "aws", "sets", "stats", "ops", "hm"], "i": ["li", "im", "mu", "ip", "mi", "chi", "c", "a", "ei", "d", "ri", "b", "ami", "bi", "ui", "ci", "esi", "e", "info", "ai", "eni", "it", "ii", "ni", "id", "phi", "api", "oi", "anti", "ic", "j", "ie", "hi", "xi", "zi", "ia", "qi", "o", "abi", "f", "y", "yi", "ki", "ish", "gi", "di", "ti", "v", "in", "ik", "l", "start", "index", "u", "x", "ix", "uri", "I", "fi", "iu", "is", "ini", "multi", "ji", "p", "si", "isi", "pi", "io", "ori", "cli", "iv", "t", "m", "n", "vi", "slice"]}}
{"project": "qemu", "commit_id": "f5aa4bdc766190b95d18be27d5cdf4d80c35b33c", "target": 1, "func": "static void test_flush_nodev(void)\n\n{\n\n    QPCIDevice *dev;\n\n    QPCIBar bmdma_bar, ide_bar;\n\n\n\n    ide_test_start(\"\");\n\n\n\n    dev = get_pci_device(&bmdma_bar, &ide_bar);\n\n\n\n    /* FLUSH CACHE command on device 0*/\n\n    qpci_io_writeb(dev, ide_bar, reg_device, 0);\n\n    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);\n\n\n\n    /* Just testing that qemu doesn't crash... */\n\n\n\n\n    ide_test_quit();\n\n}", "idx": 11046, "substitutes": {"dev": ["debug", "dem", "bus", "de", "hw", "die", "block", "sd", "valid", "device", "pro", "diff", "home", "dom", "serial", "rad", "DEV", "gu", "adv", "ver", "db", "dist", "d", "mod", "ev", "development", "der", "app", "driver", "Dev", "grad", "test", "prom", "end", "dc", "dd", "ch", "error", "da", "def", "conn", "od", "cam", "w", "pad", "conf", "dep", "info", "var", "priv", "ad", "ve", "data", "bug", "cd"], "bmdma_bar": ["bmdda_car", "bmdma_var", "bmdma__car", "bmdma_home", "bmdma__var", "bmdma_car", "bmdda_app", "bmdda_browser", "bmdma__bar", "bmdda_var", "bmdda_home", "bmdma_browser", "bmdda_bar", "bmdma_app", "bmdma__home"], "ide_bar": ["ideptab", "idejhome", "side_bars", "side_bar", "ide_loader", "ide_bars", "ine_car", "ideboardbar", "idejloader", "idepbar", "IDE_buffer", "side_tab", "idepgroup", "IDExbuffer", "IDExbars", "idexbar", "ide_group", "IDE_bar", "side_loader", "idexbuffer", "ide_show", "IDE_var", "ide_car", "ideboardhome", "idexbars", "ideboardgroup", "IDExvar", "idexvar", "ideboardtab", "ine_bar", "idejbars", "idejbar", "ide_home", "side_home", "ide_buffer", "ine_bars", "IDExbar", "IDE_bars", "ide_var", "ine_show", "idephome", "side_group", "ide_tab"]}}
{"project": "qemu", "commit_id": "895b00f62a7e86724dc7352d67c7808d37366130", "target": 1, "func": "void qmp_guest_file_flush(int64_t handle, Error **errp)\n\n{\n\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n\n    FILE *fh;\n\n    int ret;\n\n\n\n    if (!gfh) {\n\n        return;\n\n    }\n\n\n\n    fh = gfh->fh;\n\n    ret = fflush(fh);\n\n    if (ret == EOF) {\n\n        error_setg_errno(errp, errno, \"failed to flush file\");\n\n\n\n    }\n\n}", "idx": 11070, "substitutes": {"handle": ["phy", "ctx", "pointer", "pool", "device", "ptr", "hand", "host", "proc", "ignore", "connection", "addr", "write", "close", "help", "draw", "h", "bind", "use", "object", "wrap", "end", "open", "handled", "share", "fail", "handler", "resource", "call", "conn", "wrapper", "Handle", "child", "process", "fd", "hash", "data", "alias", "ipe"], "errp": ["rrp", "errpo", "err", "errP", "armP", "errr", " ern", " erpo", " errbp", "armbp", " errn", "armr", "armp", "errorp", "erp", "errorpo", " erp", " errr", "erpo", "errn", "errorr", " errP", " errpo", "ern", "rrn", "rrr", "erP", "errbp", "errorn", " err", "rrpo", "erbp"], "gfh": ["Gcfbh", "gufw", "gfbh", "gfw", "glfbh", " gfxp", "gfsrh", "gcfbh", "gfxw", " gfoh", "Gcfsh", "gfsh", "gcfrh", " gfp", "gfbhs", "gfhs", "gfxh", "gfoh", "gfrh", "gsfsh", "gfboh", "glfp", "glfsh", " gfxch", "glfh", "Gfrh", " gfhs", "gcfh", " gsfoh", "Gfsh", " gsfhs", " gfch", "gfssh", "gfsbh", " gfsh", " gsfh", "gsfhs", " gfxw", " gfxh", "glfch", "gufp", "Gcfrh", "gsfoh", "Gfbh", "gfbsh", "gsfh", "gfp", "gcfsh", "gfxch", "glfw", " gfw", "gufch", "Gfh", " gsfsh", "gfch", "gfxp", "gufh", "glfrh", "Gcfh"], "fh": ["ph", "hbh", " fbh", "fph", "dp", "fH", "afh", "ffc", "Fz", "gsh", " fhs", "fdz", " fp", "Fbh", "fhs", "ffhs", "afH", "Fh", "gh", " fH", "fz", " fz", "hp", "hh", "fp", "fc", "ghs", " fsh", "pH", "ffsh", "ffh", "pp", " fc", "hph", "fbh", " fph", "afp", "dh", "psh", "fdbh", "fdh", "fsh", "fdp", "gc", "Fp", "afsh", "dbh", "dph"], "ret": ["rets", "rt", "match", "att", "resp", "re", "RET", "ref", "err", "ft", "result", "success", "len", "sr", "rc", "rl", "arr", "fun", "lit", "ct", "flag", "mt", "rb", "fat", "code", "mem", "num", "std", "val", "det", "pet", "lock", "reply", "arg", "pat", "xt", "res", "nt", "reg", "fin", "alt", "Ret", "data"]}}
{"project": "FFmpeg", "commit_id": "c9aab8a123c0bcf6adeab390db1ec783326456ca", "target": 0, "func": "static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){\n\n    MpegEncContext * const s = &h->s;\n\n    Picture * const ref1 = &h->ref_list[1][0];\n\n    int j, old_ref, rfield;\n\n    int start= mbafi ? 16                      : 0;\n\n    int end  = mbafi ? 16+2*h->ref_count[0]    : h->ref_count[0];\n\n    int interl= mbafi || s->picture_structure != PICT_FRAME;\n\n\n\n    /* bogus; fills in for missing frames */\n\n    memset(map[list], 0, sizeof(map[list]));\n\n\n\n    for(rfield=0; rfield<2; rfield++){\n\n        for(old_ref=0; old_ref<ref1->ref_count[colfield][list]; old_ref++){\n\n            int poc = ref1->ref_poc[colfield][list][old_ref];\n\n\n\n            if     (!interl)\n\n                poc |= 3;\n\n            else if( interl && (poc&3) == 3) //FIXME store all MBAFF references so this isnt needed\n\n                poc= (poc&~3) + rfield + 1;\n\n\n\n            for(j=start; j<end; j++){\n\n                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {\n\n                    int cur_ref= mbafi ? (j-16)^field : j;\n\n                    map[list][2*old_ref + (rfield^field) + 16] = cur_ref;\n\n                    if(rfield == field || !interl)\n\n                        map[list][old_ref] = cur_ref;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 11080, "substitutes": {"h": ["g", "ph", "hd", "H", "hw", "f", "hr", "ref", "host", "self", "oh", "c", "i", "d", "p", "ha", "http", "sh", "gh", "uh", "b", "ah", "bh", "hp", "hh", "ht", "html", "z", "v", "hs", "image", "ch", "header", "t", "o", "ih", "l", "he", "q", "hl", "u", "w", "m", "e", "n", "eh", "rh", "hm"], "map": ["dict", "up", "block", "file", "pool", "match", "max", "table", "min", "module", "db", "en", "cmp", "master", "bl", "config", "model", "pack", "per", "create", "change", "arr", "scope", "app", "use", "shape", "pair", "open", "pre", "scale", "array", "address", "code", "mem", "down", "share", "copy", "maps", "image", "parent", "ap", "m", "buffer", "conf", "lock", "data", "ge", "MAP", "set", "msg", "cap", "meta", "hash", "group", "Map", "cache"], "list": ["server", "max", "err", "self", "c", "write", "queue", "pre", "key", "all", "old", "com", "List", "feat", "view", "can", "range", "test", "flat", "cont", "code", "record", "coll", "parent", "header", "cl", "base", "set", "out", "lists", "str", "block", "diff", "ist", "table", "low", "len", "config", "load", "source", "l", "listed", "lc", "null", "name", "count", "x", "g", "chain", "pool", "type", "local", "path", "wx", "p", "arr", "st", "LIST", "full", "cli", "act", "val", "head", "m", "none", "batch", "data", "cache"], "field": ["message", "ref", "c", "i", "fe", "d", "key", "old", "query", "line", "size", "off", "change", "range", "ld", "end", "record", "length", "force", "shift", "f", "diff", "ff", "low", "fields", "len", "load", "v", "layer", "source", "start", "Field", "value", "lc", "group", "count", "number", "x", "ix", "g", "fr", "type", "match", "cmp", "co", "play", "p", "offset", "input", "FIELD", "rule", "level", "component", "fix"], "colfield": ["colorder", "colref", "rollabel", "refrule", "catfield", "collfield", "textindex", "colrow", "textfield", "reflabel", "colfix", "catgroup", "colrule", "collloader", "colindex", "rolloader", "textgroup", "catindex", "actrow", " colorder", "colloader", "actloader", "reffield", "rolrow", "catfix", "rolfield", " colindex", "collrow", "actfield", "textfix", " colrule", " collabel", "colgroup", "collabel", "rolorder", "reforder", "rolrule", "actref", " colfix", " colgroup", "rolref", "collref"], "mbafi": ["kbaf", "macabi", "nobfi", "nobaf", "embafa", "mbiera", "ombabi", "mdifa", "mciera", "mpfi", " MBabi", " MBifi", "mbaf", " MBafi", "mpafi", "kbfi", "macafi", "maciana", "mnafi", "mcafa", "mdafa", "kbafa", " MBiana", "maciera", "mcafi", "nobafa", "MBfi", "mdabi", " MBfi", "kbafi", "mpafa", "ombifa", "mnaf", "nobafi", "MBafi", "mcabi", "mdafi", " MBafa", " MBiera", "embaf", "mnabi", "mbifi", "mbifa", "mbabi", "mpifi", "MBifi", "embafi", "ombafa", "ombafi", "mciana", "mpaf", "mnafa", "embfi", "mcaf", "mbafa", "mpifa", "MBafa", "mbfi", "mpabi", "mbiana"], "s": ["server", "g", "als", "os", "f", "cs", "ls", "ss", "y", "c", "is", "i", "a", "services", "params", "sb", "es", "p", "si", "sg", "S", "settings", "b", "session", "fs", "ssl", "scope", "sh", "sl", "ns", "v", "ions", "ances", "spec", "ages", "r", "o", "t", "ps", "ses", "l", "sc", "sync", "u", "gs", "w", "m", "ures", "e", "n", "sys", "rs", "ops"], "ref1": ["referenceOne", "col2", " Ref1", "range1", "resp2", "reference1", "range2", "respOne", "Ref0", "colOne", "Ref2", "reference01", "reference2", "resp1", "col0", " Ref0", " ref2", "resp01", "ref2", " Ref2", "col1", "ref01", "Ref1", "ref0", "range01", " refOne", "refOne", "rangeOne"], "j": ["g", "pos", "li", "bj", "adj", "fr", "f", "k", "ref", "je", "jo", "note", "x", "jet", "y", "jit", "c", "uj", "jan", "length", "i", "jp", "d", "ja", "bl", "ji", "p", "offset", "jen", "b", "it", "jl", "ie", "part", "key", "z", "v", "code", "ch", "num", "J", "r", "jam", "el", "all", "o", "oj", "l", "br", "ind", "start", "index", "u", "m", "job", "col", "ij", "obj", "n", "child", "jj", "e", "reg", "dj", "section", "js", "aj", "syn", "jc", "str"], "old_ref": ["old67pre", "old_fe", "oldJreference", "oldlexref", "old67ext", "old_cmp", "old_vis", " old_ext", "old67vis", "oldlexfe", "old5ref", "oldJpointer", "older_reference", "older_cmp", "oldJref", "old_remote", "old_Ref", "olderlexreference", " old_pointer", " old_pre", "old_pre", "oldJdiff", "old67Ref", " old_remote", "old_reference", "old5reference", "old5cmp", "older_val", "old5rec", "old67ref", " old_Ref", "olderlexref", "old67diff", "old_rec", "old67remote", "olderlexfe", "old67fe", "old_diff", " old_reference", "olderlexval", "old_val", "old_ext", "oldJRef", "oldlexreference", "old67reference", " old_fe", "older_fe", " old_diff", "older_ref", "oldlexval", "older_rec", " old_vis", "old_pointer"], "rfield": ["Rslice", "rref", "rdslice", "rslice", "nrslice", " rfields", "jfield", "rtref", "rforce", "rfun", "relfield", "relchar", "rdiff", "rokey", "drslice", "bcomp", "reldiff", " rref", "roslice", "jlabel", " rf", " rfun", "rolabel", " rlabel", "lfield", "srfields", " rforce", "rchar", "Rcomp", "rf", "rfc", "roref", "rdkey", "rFIELD", "rarfield", "lfc", "nrforce", " rkey", "rfields", "rofc", "nrFIELD", "rtfield", "nrfield", "relkey", "rtkey", "rcomp", " rFIELD", "rddiff", "rarkey", "rkey", "rdchar", "nrkey", "relslice", "rfix", "relfix", "rlabel", " rfix", "nrchar", "drfield", "rtfun", "rofield", "srforce", "rarref", "Rfield", "rarfun", " rslice", "lslice", " rfc", "jref", "bslice", "nrfields", "srfield", "rdfield", " rdiff", "lkey", "srFIELD", "rof", "rdfix", "jf", "rdref", "relref", "bfield", "drcomp"]}}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static void compute_frame_duration(int *pnum, int *pden,\n\n                                   AVFormatContext *s, AVStream *st, \n\n                                   AVCodecParserContext *pc, AVPacket *pkt)\n\n{\n\n    int frame_size;\n\n\n\n    *pnum = 0;\n\n    *pden = 0;\n\n    switch(st->codec.codec_type) {\n\n    case CODEC_TYPE_VIDEO:\n\n        *pnum = st->codec.frame_rate_base;\n\n        *pden = st->codec.frame_rate;\n\n        if (pc && pc->repeat_pict) {\n\n            *pden *= 2;\n\n            *pnum = (*pnum) * (2 + pc->repeat_pict);\n\n        }\n\n        break;\n\n    case CODEC_TYPE_AUDIO:\n\n        frame_size = get_audio_frame_size(&st->codec, pkt->size);\n\n        if (frame_size < 0)\n\n            break;\n\n        *pnum = frame_size;\n\n        *pden = st->codec.sample_rate;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 11084, "substitutes": {"pnum": ["rnui", "bnume", "ennui", "gnuma", "PNumb", "snumer", "nnum", "bnumber", "pnenum", "pnuma", "snumb", "rnam", "ynumb", "ynumer", "snum", "ennum", "pnumer", "ennummer", "atanum", "PNumer", "PNam", "atanummer", "rnuma", "rnumer", "ennuma", "rnum", "pnumber", "pnummer", "rnummer", "ennume", "pnumm", "atanenum", "nnenum", "rnume", "gnum", "bnui", "snumm", "ennenum", "pnumb", "nnumm", "ynum", "bnum", "pnume", "ennumb", "pronumber", "ennumber", "nnumer", "pronum", "PNumm", "rnumber", "gnumb", "hnumm", "pnui", "hnuma", "snam", "ynumm", "gnumm", "rnumb", "hnum", "nnumb", "PNuma", "atanuma", "pronumb", "pnam", "pronenum", "hnumb", "nnumber", "PNum", "rnenum"], "pden": ["cdan", "Pne", "prden", "pdan", "pronder", "nDen", "pDen", " pzen", "piden", "nzen", " ponder", "spden", " piden", "pzen", "prdon", "ciden", "Pden", "prdan", "spdan", "Plen", "plen", "ndan", "przen", " pne", " pDen", "spne", "clen", "prlen", " pdon", "nden", "pdon", "Pzen", "cDen", "ponder", "priden", "cden", " pdan", "cdon", "Pdan", " plen", "pne", "Ponder", "splen", "czen"], "s": ["g", "cs", "ss", "parser", "c", "sq", "is", "ts", "p", "fs", "ssl", "v", "spec", "ms", "us", "t", "r", "ps", "ses", "qs", "sync", "w", "as", "m", "e", "sys", "ops"], "st": ["fr", "sd", "sth", "src", "ost", "ist", "stress", "cs", "th", "ss", "ft", "td", "c", "sb", "ts", "cur", "stage", "sta", "ste", "ST", "sts", "ct", "ld", "nd", "pt", "mt", "sl", "est", "ut", "t", "r", "std", "ust", "sc", "start", "sn", "sty", "ast", "St", "nt", "sec", "rest", "sa", "inst", "str"], "pc": ["pg", "ctx", "pn", "pm", "anc", "cs", "nc", "pl", "mp", "proc", "cz", "td", "bc", "icc", "vc", "pb", "c", "co", "lp", "rc", "pd", "pr", "p", "amp", "arc", "enc", "px", "cp", "ct", "con", "PC", "pt", "cc", "fc", "pac", "ac", "spec", "inc", "cl", "ps", "sc", "pp", "func", "pat", "pa", "tc", "mc", "lc", "ec", "uc", "cca", "asc"], "pkt": [" packet", "pct", "ppkt", "Pct", "packet", " ptk", "Pett", "ppkg", "ptk", "Pkg", "lptk", "Pkt", "Packet", "Ptk", "pkg", "lpkt", "lpacket", " pct", " pkg", " pett", "lpct", "ppacket", "ppett", "pett"], "frame_size": ["frame_description", "fram_count", " frame_count", " frame_len", "file_loc", "file_description", "file_rate", "frame_sized", " frame_name", " frame_sized", "frame___rate", "frame___size", "frame_count", "frame___loc", "fram_sized", "frame_loc", "fram_size", "frame_len", "file_size", "fram_rate", "frame_name", "frame_rate", "frame___description"]}}
{"project": "qemu", "commit_id": "ecbddbb106114f90008024b4e6c3ba1c38d7ca0e", "target": 1, "func": "static int os_host_main_loop_wait(int64_t timeout)\n{\n    GMainContext *context = g_main_context_default();\n    GPollFD poll_fds[1024 * 2]; /* this is probably overkill */\n    int select_ret = 0;\n    int g_poll_ret, ret, i, n_poll_fds;\n    PollingEntry *pe;\n    WaitObjects *w = &wait_objects;\n    gint poll_timeout;\n    int64_t poll_timeout_ns;\n    static struct timeval tv0;\n    fd_set rfds, wfds, xfds;\n    int nfds;\n    /* XXX: need to suppress polling by better using win32 events */\n    ret = 0;\n    for (pe = first_polling_entry; pe != NULL; pe = pe->next) {\n        ret |= pe->func(pe->opaque);\n    }\n    if (ret != 0) {\n        return ret;\n    }\n    FD_ZERO(&rfds);\n    FD_ZERO(&wfds);\n    FD_ZERO(&xfds);\n    nfds = pollfds_fill(gpollfds, &rfds, &wfds, &xfds);\n    if (nfds >= 0) {\n        select_ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv0);\n        if (select_ret != 0) {\n            timeout = 0;\n        }\n        if (select_ret > 0) {\n            pollfds_poll(gpollfds, nfds, &rfds, &wfds, &xfds);\n        }\n    }\n    g_main_context_prepare(context, &max_priority);\n    n_poll_fds = g_main_context_query(context, max_priority, &poll_timeout,\n                                      poll_fds, ARRAY_SIZE(poll_fds));\n    g_assert(n_poll_fds <= ARRAY_SIZE(poll_fds));\n    for (i = 0; i < w->num; i++) {\n        poll_fds[n_poll_fds + i].fd = (DWORD_PTR)w->events[i];\n        poll_fds[n_poll_fds + i].events = G_IO_IN;\n    }\n    if (poll_timeout < 0) {\n        poll_timeout_ns = -1;\n    } else {\n        poll_timeout_ns = (int64_t)poll_timeout * (int64_t)SCALE_MS;\n    }\n    poll_timeout_ns = qemu_soonest_timeout(poll_timeout_ns, timeout);\n    qemu_mutex_unlock_iothread();\n    g_poll_ret = qemu_poll_ns(poll_fds, n_poll_fds + w->num, poll_timeout_ns);\n    qemu_mutex_lock_iothread();\n    if (g_poll_ret > 0) {\n        for (i = 0; i < w->num; i++) {\n            w->revents[i] = poll_fds[n_poll_fds + i].revents;\n        }\n        for (i = 0; i < w->num; i++) {\n            if (w->revents[i] && w->func[i]) {\n                w->func[i](w->opaque[i]);\n            }\n        }\n    }\n    if (g_main_context_check(context, max_priority, poll_fds, n_poll_fds)) {\n        g_main_context_dispatch(context);\n    }\n    return select_ret || g_poll_ret;\n}", "idx": 11113, "substitutes": {"timeout": ["server", "version", "Timeout", "size", "no", "pool", "limit", "max", "connection", "option", "stop", "exec", "event", "duration", "trial", "sleep", "offset", "temp", "response", "options", "outs", "ssl", "io", "url", "v", "t", "time", "opt", "conn", "start", "cookie", "delay", "random", "ime", "unit", "window", "out", "sec", "nt", "alt", "rain", "count", "number", "seconds", "cache"], "context": ["cas", "support", "server", "ctx", "request", "Context", "service", "local", "xml", "host", "connection", "ce", "bc", "java", "c", "network", "instance", "concept", "event", "document", "config", "temp", "input", "work", "driver", "queue", "thread", "package", "parent", "graph", "channel", "resource", "handler", "cf", "sc", "proxy", "stack", "component", "wrapper", "current", "tx", "buffer", "tc", "null", "none", "window", "cache"], "poll_fds": ["poll_tfds", "poll_dfld", "poll_funns", "poll_funcs", "poll_rfsts", "poll_rfld", "poll_fslers", "poll_rfks", "pollingfd", "poll_fundds", "poll_rfdat", "poll_rfns", "poll_fdes", "pollingrfdes", "poll_rfd", "poll_tfdes", "poll_ddds", "poll_rfds", "poll_fsdds", "poll_fcdds", "poll_Fd", "poll_fdds", "poll_sfds", "poll_rfts", "poll_fsts", "poll_rfcs", "poll_fsks", "poll_rfcks", "poll_fns", "poll_fys", "poll_funts", "poll_sfDS", "poll_dfd", "poll_funds", "poll_funDS", "poll_fccks", "poll_fcs", "poll_sfcs", "poll_dfdes", "poll_Fds", "poll_fld", "poll_Fld", "poll_fdat", "poll_sfdds", "poll_fcks", "poll_xdds", "poll_fcds", "poll_xds", "pollingrfd", "pollingrfld", "poll_fcys", "poll_rfdds", "pollingfld", "poll_fcts", "pollingfds", "poll_xdat", "poll_dsts", "poll_fks", "poll_fts", "poll_funks", "pollingrfds", "poll_rfys", "poll_fcdat", "poll_dfds", "poll_rfdes", "poll_dds", "poll_xys", "pollingfdes", "poll_fsds", "poll_rfDS", "poll_fd", "poll_fDS", "poll_tfsts", "poll_Fdes", "poll_funlers", "poll_tfdds", "poll_rflers", "poll_ddes", "poll_funcks", "poll_fcns", "poll_flers"], "g_poll_ret": ["g_exec_ret", "g_exec_result", "g_poll_result", "g_exec_rets", "g_poll_return", "g_exec_return", "g_poll_rets"], "ret": ["server", "live", "valid", "no", "rets", "rt", "wait", "att", "resp", "re", "RET", "ref", "err", "fi", "ft", "result", "success", "seq", "len", "iter", "trial", "sb", "back", "temp", "offset", "reset", "fun", "url", "flag", "bit", "run", "part", "active", "num", "r", "opt", "val", "det", "req", "pet", "complete", "get", "sync", "ry", "job", "reply", "delay", "obj", "info", "value", "nt", "res", "alt", "status", "Ret", "feat"], "i": ["ii", "ni", "li", "uri", "f", "id", "phi", "I", "mu", "ip", "mi", "fi", "chi", "y", "gu", "c", "yi", "ki", "iu", "ini", "iter", "d", "multi", "p", "ani", "si", "pi", "io", "j", "gi", "ie", "ami", "part", "di", "ti", "xi", "bi", "image", "v", "qi", "o", "ui", "ind", "inc", "l", "ci", "start", "index", "u", "m", "e", "n", "info", "my", "ai", "eni", "x", "ix", "it"], "n_poll_fds": ["n_poll_forys", "n_poll_forcs", "n_poll_rfds", "n_poll_nys", "n_poll_infss", "n_poll_infds", "n_polledinfns", "n_pollsfcs", "n_poll_rfsts", "n_poll67fdr", "n_poll_Fds", "n_poll67ndr", "n_poll_fieldns", "n_poll67fys", "n_poll_funrd", "n_poll_infcons", "n_poll_infns", "n_poll_rfks", "n_pollscfds", "n_polledfns", "n_polledfcons", "n_poll67fcs", "n_poll67nds", "n_polledinfds", "n_poll_ncs", "n_poll_cfds", "n_poll_tcs", "n_poll_Fls", "n_pollscfks", "n_poll_fsts", "n_poll_rfrd", "n_pollsfdds", "n_polledfds", "n_poll67nys", "n_poll_fns", "n_poll_frd", "n_poll_fieldss", "n_poll_rfls", "n_poll_rfcons", "n_poll_fys", "n_poll_fss", "n_poll_fd", "n_poll_fls", "n_poll_funds", "n_poll_fdds", "n_poll_fundds", "n_poll_fords", "n_pollscfdds", "n_poll_rfd", "n_poll_fcons", "n_poll_cfcs", "n_poll_Fsts", "n_poll_nds", "n_poll_ofds", "n_poll_ndr", "n_poll_cfks", "n_poll_rfss", "n_pollsfks", "n_poll_rfns", "n_poll_fieldds", "n_poll_fks", "n_poll_tds", "n_poll_funcs", "n_poll_Fns", "n_poll_fdr", "n_poll_fieldcons", "n_poll67ncs", "n_poll_fcs", "n_poll_fund", "n_polledinfcons", "n_pollsfds", "n_poll_rfdds", "n_poll_ofls", "n_poll_cfdds", "n_poll_ofsts", "n_poll_fordr", "n_poll_tdr", "n_poll_funks", "n_poll_tys", "n_poll67fds", "n_poll_ofns", "n_poll_rfcs", "n_polledinfss", "n_pollscfcs", "n_polledfss"], "pe": ["ape", "ph", "pse", "de", "xe", "PE", "pei", "ue", "pl", "je", "ke", "ze", "ce", "pen", "pc", "fe", "poke", "ae", "pex", "ale", "p", "per", "ple", "ep", "qa", "pri", "ope", "ste", "le", "spe", "ite", "se", "po", "enter", "ee", "me", "Pe", "coe", "cl", "que", "ps", "ffe", "peer", "he", "pp", "oe", "te", "wa", "e", "pa", "peak", "ge", "pes", "ase", "one", "py", "ve"], "w": ["g", "wal", "web", "hw", "wan", "rw", "wait", "we", "wall", "wd", " W", "sw", "wk", "wx", "c", "d", "h", "p", "work", "kw", "wl", "v", "ww", "widget", "r", "aw", "wp", "wu", "win", "wave", "q", "ew", "wt", "wa", "ow", "e", "n", "fw", "iw", "wb", "W"], "poll_timeout": ["polllslot", "run__frequency", "poll_time", "run__limit", "pollltimeout", "poll67delay", "poll_slot", "run_timeout", "poll_token", "vote_slot", "poll__frequency", "poll_frequency", "run_frequency", "poll__timeout", "poll_delay", " poll_delay", "run__delay", "poll67timeout", "run_delay", "run__timeout", "poll67frequency", "poll__limit", "poll__delay", "poll_limit", " poll_time", "run_limit", "vote_timeout", "vote_token", "pollltoken", "poll67limit"], "poll_timeout_ns": ["poll_time_ls", "poll_timeout_NS", "poll_delay_ls", "poll_delay_ns", "poll_time_ns", "poll_delay_sec", "poll_timeout_ls", "poll_timeout_sec", "poll_time_ds", "poll_time_NS", "poll_delay_ms", "poll_timeout_ds", "poll_timeout_ms"], "tv0": ["vi2", "cv0", "timeout0", "tv6", "cvng", "vi00", "TV00", "timeoutng", "vt00", "tvng", "vt2", " tvng", "tv2", "TV0", "TV2", "cv6", "tv00", "vt0", "timeout2", "timeout6", " tv2", " tv6", "vi0", "cv2"], "rfds": ["fdes", "sfns", "fbdd", "fbDS", "fbda", "sfys", "fbcs", "RFDS", "RFys", "rfDS", "sfdds", "xfns", "RFd", "rfys", "fDS", "rfdd", "rfns", "sfdes", "fdd", "RFDs", "sfd", "xfda", "xfdds", "lfys", "sfcs", "fds", "rfcs", "rfd", "RFds", "lfDS", "fDs", "rfDs", "rfdds", "sfDs", "fbdds", "rbds", "rbns", "rfda", "fbd", "RFdes", "lfda", "RFda", "lfds", "sfDS", "rbdds", "rfdes", "xfcs", "fbds", "fd", "rbda", "sfds", "RFdd", "sfda"], "wfds": ["Wfsys", "wrfsts", "swcfks", "wfrd", "wfacrd", "swcfdds", "wlfrd", " wvcs", "wxfsts", "wffds", "wcfths", "wcfdds", "wfxds", "wxfdds", "wfys", "wfda", " wfys", "kwfuds", "wlfys", "Wfys", " wvds", "kwfsts", "Wfsld", "winfdb", "Wfsds", "kwrfsts", "wfacnas", "wfld", "kwrfds", "Wfld", "wfdds", "wcfys", "wcfcs", "wffld", "wfxths", "walfrd", "swfds", "winfld", " wvda", "wrfdds", "wvds", "wcfks", "wfsuds", "wfacds", "wfsda", "swfks", "wfsths", "wlfnas", "swcfds", "kwfdds", "wfsts", "winfys", "wfuds", "wfssts", "wfths", "wfcs", "kwrfdds", "wlfds", "swfdds", "wafys", " wfda", " wvys", "wfxdds", " wfcs", "walfds", "wfsks", "wfdb", "wvys", "kwrfuds", "wrfds", "wfsdb", "wrfuds", "wfsds", "wafds", "wfks", "wfscs", "wffdb", "Wfdb", "wfacys", "Wfds", "kwfds", "wxfuds", "wvda", "wfsdds", "wfsrd", "wafnas", "wcfda", "walfnas", "wfxks", "wfsys", "winfds", "swcfths", "swfths", "wffys", "wxfds", "wvcs", "wfsld", "wafrd", "Wfsdb", "wcfds", "wfsnas", "walfys", "wfnas"], "xfds": ["fxdd", "fxths", "fxds", "cfds", "xfns", "fifda", "cfdd", "lfths", "cfdb", "xfths", "xfdb", "cfths", "fifd", "cfdds", "fifths", "rfdd", "xfrd", "fxrd", "fxda", "xfda", "sfd", "tfdb", "xfdds", "fifds", "fcdds", "fxns", "tfd", "rfd", "xfd", "cfda", "rfrd", "tfda", "fxd", "fcd", "rfdds", "cfd", "cfrd", "fcdd", "rfdb", "xfdd", "tfds", "rfda", "fcds", "cfns", "lfds", "lfd", "lfns", "sfds", "sfths", "sfda"], "nfds": ["nrfd", "nfrs", "ncfrs", "nrfdes", "naffds", "nfmds", " nrfdds", " nfdes", " ncfdy", "nfbdes", "naffdy", "nfbdy", "nfDS", "naffdes", "nrfDS", " nrfds", "ntfds", "ntfd", "nfld", "naffdds", " ncfld", " ncfdds", "nFdds", "ncfDS", " nfdds", "nfd", "nfdds", " nrfd", "nfdy", " nfrs", " nrfDS", " ncfds", "nrfrs", "ntfda", "nfbda", " nfda", " ncfd", " nfd", "ncfdy", "nfmld", "ncfld", "nrfda", "nfmdds", "ncfda", "ntfdes", "nfbdds", " nrfdy", " ncfda", "ncfdds", "nFDS", "ncfdes", " nrfda", "nfdes", "nrfdds", "nfmrs", "nrfld", " nfld", "nfbds", " nfDS", " nfdy", "nFds", "ncfds", "nrfdy", "nfda", " ncfdes", " ncfrs", "nrfds", "nFd", "ncfd"]}}
{"project": "qemu", "commit_id": "a89d89d3e65800fa4a8e00de7af0ea8272bef779", "target": 1, "func": "int bdrv_snapshot_delete(BlockDriverState *bs, const char *snapshot_id)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (drv->bdrv_snapshot_delete) {\n\n        return drv->bdrv_snapshot_delete(bs, snapshot_id);\n\n    }\n\n    if (bs->file) {\n\n        return bdrv_snapshot_delete(bs->file, snapshot_id);\n\n    }\n\n    return -ENOTSUP;\n\n}\n", "idx": 11117, "substitutes": {"bs": ["abi", "bos", "os", "abc", "ctx", "bis", "cs", "ls", "ss", "bu", "bc", "BS", "pb", "bps", "lb", "sb", "bl", "bytes", "cb", "iss", "ds", "b", "bes", "fb", "blocks", "fs", "bh", "ub", "rb", "ns", "css", "us", "bi", "bb", "bing", "ses", "qs", "ab", "gs", "banks", "ubs", "base", "las", "bits", "bas", "rs", "obs", "lbs", "js", "blog", "bid", "bot", "vs", "ba"], "snapshot_id": ["snapshot_name", "snapaction_id", "snapshot_path", "snapshot_type", "snapaction_path", "snapaction_type", "snapshot_ids", "snapaction_name", "snapshot_Id"], "drv": [" drb", "rtv", "rtb", " drc", " drf", "Drw", "hrb", "rtf", " drsv", " drw", "drsv", "parw", "parsv", "Drf", "srf", "parf", "DRv", "hrc", "drw", "hrv", "drc", "hrp", "drp", "hrw", "drb", "Drv", "srv", "Drp", "rtc", "srw", "hrf", "drf", "srsv", "DRp", "parv", " drp", "Drb", "DRb", "DRf"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)\n\n{\n\n    uint32_t val;\n\n\n\n    val = bswap32(cpu_inl(addr & IOPORTS_MASK));\n\n    return val;\n\n}\n", "idx": 11126, "substitutes": {"opaque": ["optacity", "opad", " opec", "optec", "operaque", "operacity", " opad", "operec", "opacity", "operad", "optaque", "opec", "optad", " opacity"], "addr": ["oa", "pos", "prefix", "rt", "pointer", "args", "device", "ptr", "ref", "host", "proc", "adr", "pc", "adder", "node", "dr", "config", "amp", "rc", "ace", "offset", "p", "slot", "cb", "ord", "grad", "kt", "address", "code", "dc", "dd", "layer", "mac", "point", "amd", "pad", "arg", "obj", "Address", "fd", "ad", "data", "x"], "val": ["la", "ann", "valid", "pass", "rt", "f", "vals", "elt", "ref", "fi", "sel", "bc", "len", "pc", "al", "eval", "bl", "p", "slot", "rl", "lit", "Val", "fl", "j", "pt", "VAL", "sl", "pre", "key", "v", "ee", "il", "ind", "el", "ret", "all", "cond", "arg", "obj", "base", "value", "py", "alt", "data", "x"]}}
{"project": "qemu", "commit_id": "5dafc53f1fb091d242f2179ffcb43bb28af36d1e", "target": 0, "func": "static void qemu_fill_buffer(QEMUFile *f)\n\n{\n\n    int len;\n\n\n\n    if (f->is_writable)\n\n        return;\n\n    if (f->is_file) {\n\n        fseek(f->outfile, f->buf_offset, SEEK_SET);\n\n        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);\n\n        if (len < 0)\n\n            len = 0;\n\n    } else {\n\n        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,\n\n                         f->buf, IO_BUF_SIZE);\n\n        if (len < 0)\n\n            len = 0;\n\n    }\n\n    f->buf_index = 0;\n\n    f->buf_size = len;\n\n    f->buf_offset += len;\n\n}\n", "idx": 11127, "substitutes": {"f": ["F", "fen", "fr", "fn", "tf", "file", "flow", "k", "ref", "ff", "fi", "sf", "inf", "c", "elf", "i", "fe", "d", "new", "h", "p", "function", "b", "fun", "fs", "fb", "fl", "full", "feed", "fa", "fp", "v", "fc", "t", "df", "af", "o", "uf", "l", "cf", "def", "fx", "u", "form", "fo", "old", "m", "conf", "e", "this", "info", "fd", "of", "bf", "data", "lf", "x"], "len": ["la", "li", "del", "err", "min", "seq", "lt", "span", "fl", "lang", "lin", "js", "line", "size", "id", "limit", "ls", "rev", "non", "lp", "lit", "lim", "gen", "doc", "ld", "ie", "end", "z", "num", "length", "el", "conn", "hl", "base", "lan", "ln", "lon", "dl", "list", "str", "buf", " length", "low", "en", "Len", "fun", "le", "ler", "part", "sl", "l", "index", "body", "lc", "fin", "name", "count", "pos", " lang", "ll", "dy", "url", "style", "fat", "val", "n", "led", "data", "lf"]}}
{"project": "qemu", "commit_id": "8297be80f7cf71e09617669a8bd8b2836dcfd4c3", "target": 0, "func": "void net_hub_check_clients(void)\n\n{\n\n    NetHub *hub;\n\n    NetHubPort *port;\n\n    NetClientState *peer;\n\n\n\n    QLIST_FOREACH(hub, &hubs, next) {\n\n        int has_nic = 0, has_host_dev = 0;\n\n\n\n        QLIST_FOREACH(port, &hub->ports, next) {\n\n            peer = port->nc.peer;\n\n            if (!peer) {\n\n                fprintf(stderr, \"Warning: hub port %s has no peer\\n\",\n\n                        port->nc.name);\n\n                continue;\n\n            }\n\n\n\n            switch (peer->info->type) {\n\n            case NET_CLIENT_DRIVER_NIC:\n\n                has_nic = 1;\n\n                break;\n\n            case NET_CLIENT_DRIVER_USER:\n\n            case NET_CLIENT_DRIVER_TAP:\n\n            case NET_CLIENT_DRIVER_SOCKET:\n\n            case NET_CLIENT_DRIVER_VDE:\n\n            case NET_CLIENT_DRIVER_VHOST_USER:\n\n                has_host_dev = 1;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n        if (has_host_dev && !has_nic) {\n\n            warn_report(\"vlan %d with no nics\", hub->id);\n\n        }\n\n        if (has_nic && !has_host_dev) {\n\n            fprintf(stderr,\n\n                    \"Warning: vlan %d is not connected to host network\\n\",\n\n                    hub->id);\n\n        }\n\n    }\n\n}\n", "idx": 11128, "substitutes": {"hub": ["hop", "server", "bus", "plugin", "pub", "pool", "club", "src", "host", "home", "Hub", "connection", "sub", "pb", "box", "db", "pc", "library", "route", "lab", "node", "config", "mod", "cb", "ib", "http", "plug", "driver", "builder", "ub", "project", "interface", "url", "gb", "feed", "image", "client", "mob", "bb", "conn", "proxy", "lib", "git", "hole", "job", "trap", "ob", "month", "blog", "grid", "bug", "bot", "tube"], "port": ["hop", "server", "tr", "pos", "plugin", "PORT", "pub", "type", "pool", "service", "pm", "device", "state", "ip", "host", "Port", "proc", "serv", "adr", "pb", "pc", "transfer", "patch", "p", "ort", "http", "bridge", "cp", "project", "pair", "pt", "end", "address", "iv", "parent", "client", "bb", "oper", "pin", "gp", "point", "proxy", "porter", "manager", "target", "ports", "pid", "pod"], "peer": ["hop", "server", "plugin", "owner", "remote", "chain", "tp", "pub", "type", "pool", "device", "pro", "ref", "state", "ip", "host", "edge", "player", "connection", "addr", "pb", "ker", "pc", "transfer", "instance", "master", "node", "p", "per", "enc", "http", "bridge", "scope", "ssl", "worker", "socket", "driver", "interface", "vr", "address", "pe", "prov", "client", "parent", "target", "reader", "source", "channel", "rel", "conn", "pp", "cer", "point", "proxy", "dev", "buffer", "er", "info", "entity", "origin", "slave", "root", "manager", "iper", "pod"]}}
{"project": "FFmpeg", "commit_id": "c4e554701ec27b31b1b6396130b8bb2aaa0d4ad0", "target": 0, "func": "DVDemuxContext* dv_init_demux(AVFormatContext *s)\n\n{\n\n    DVDemuxContext *c;\n\n\n\n    c = av_mallocz(sizeof(DVDemuxContext));\n\n    if (!c)\n\n        return NULL;\n\n\n\n    c->vst = av_new_stream(s, 0);\n\n    c->ast[0] = av_new_stream(s, 0);\n\n    if (!c->vst || !c->ast[0])\n\n        goto fail;\n\n    av_set_pts_info(c->vst, 64, 1, 30000);\n\n    av_set_pts_info(c->ast[0], 64, 1, 30000);\n\n\n\n    c->fctx = s;\n\n    c->ast[1] = NULL;\n\n    c->ach = 0;\n\n    c->frames = 0;\n\n    c->abytes = 0;\n\n    c->audio_pkt[0].size = 0;\n\n    c->audio_pkt[1].size = 0;\n\n    \n\n    c->vst->codec.codec_type = CODEC_TYPE_VIDEO;\n\n    c->vst->codec.codec_id = CODEC_ID_DVVIDEO;\n\n    c->vst->codec.bit_rate = 25000000;\n\n    \n\n    c->ast[0]->codec.codec_type = CODEC_TYPE_AUDIO;\n\n    c->ast[0]->codec.codec_id = CODEC_ID_PCM_S16LE;\n\n   \n\n    s->ctx_flags |= AVFMTCTX_NOHEADER; \n\n    \n\n    return c;\n\n    \n\nfail:\n\n    if (c->vst)\n\n        av_free(c->vst);\n\n    if (c->ast[0])\n\n        av_free(c->ast[0]);\n\n    av_free(c);\n\n    return NULL;\n\n}\n", "idx": 11140, "substitutes": {"s": ["server", "g", "os", "ctx", "f", "src", "service", "cs", "ls", "self", "ss", "xs", "sq", "a", "i", "ks", "is", "d", "services", "sb", "params", "es", "p", "ts", "input", "options", "si", "S", "settings", "b", "ds", "fs", "se", "sl", "ns", "in", "v", "spec", "css", "r", "t", "o", "ps", "ses", "l", "sc", "u", "w", "m", "gs", "conf", "south", "e", "n", "sets", "sys", "rs", "storage", "sec", "x"], "c": ["ctx", "cs", "nc", "pc", "i", "d", "rc", "b", "cm", "con", "cc", "ch", "ci", "q", "cr", "rec", "w", "com", "e", "CV", "cn", "ec", "unc", "xc", "cat", "h", "enc", "ic", "coll", "code", "cl", "call", "conn", "sc", "mc", "f", "k", "bc", "vc", "ca", "config", "cur", "arc", "cu", "v", "fc", "l", "cf", "u", "current", "oc", "lc", "x", "g", "anc", "ce", "cmp", "co", "p", "cb", "cy", "cp", "ct", "C", "dc", "ac", "cv", "t", "col", "n", "this", "tc", "uc", "cd", "cache"]}}
{"project": "qemu", "commit_id": "cb2e28780c7080af489e72227683fe374f05022d", "target": 0, "func": "static int coroutine_fn bdrv_co_do_pwrite_zeroes(BlockDriverState *bs,\n\n    int64_t offset, int bytes, BdrvRequestFlags flags)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    QEMUIOVector qiov;\n\n    struct iovec iov = {0};\n\n    int ret = 0;\n\n    bool need_flush = false;\n\n    int head = 0;\n\n    int tail = 0;\n\n\n\n    int max_write_zeroes = MIN_NON_ZERO(bs->bl.max_pwrite_zeroes, INT_MAX);\n\n    int alignment = MAX(bs->bl.pwrite_zeroes_alignment,\n\n                        bs->bl.request_alignment);\n\n    int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n\n                                    MAX_WRITE_ZEROES_BOUNCE_BUFFER);\n\n\n\n    assert(alignment % bs->bl.request_alignment == 0);\n\n    head = offset % alignment;\n\n    tail = (offset + bytes) % alignment;\n\n    max_write_zeroes = QEMU_ALIGN_DOWN(max_write_zeroes, alignment);\n\n    assert(max_write_zeroes >= bs->bl.request_alignment);\n\n\n\n    while (bytes > 0 && !ret) {\n\n        int num = bytes;\n\n\n\n        /* Align request.  Block drivers can expect the \"bulk\" of the request\n\n         * to be aligned, and that unaligned requests do not cross cluster\n\n         * boundaries.\n\n         */\n\n        if (head) {\n\n            /* Make a small request up to the first aligned sector. For\n\n             * convenience, limit this request to max_transfer even if\n\n             * we don't need to fall back to writes.  */\n\n            num = MIN(MIN(bytes, max_transfer), alignment - head);\n\n            head = (head + num) % alignment;\n\n            assert(num < max_write_zeroes);\n\n        } else if (tail && num > alignment) {\n\n            /* Shorten the request to the last aligned sector.  */\n\n            num -= tail;\n\n        }\n\n\n\n        /* limit request size */\n\n        if (num > max_write_zeroes) {\n\n            num = max_write_zeroes;\n\n        }\n\n\n\n        ret = -ENOTSUP;\n\n        /* First try the efficient write zeroes operation */\n\n        if (drv->bdrv_co_pwrite_zeroes) {\n\n            ret = drv->bdrv_co_pwrite_zeroes(bs, offset, num,\n\n                                             flags & bs->supported_zero_flags);\n\n            if (ret != -ENOTSUP && (flags & BDRV_REQ_FUA) &&\n\n                !(bs->supported_zero_flags & BDRV_REQ_FUA)) {\n\n                need_flush = true;\n\n            }\n\n        } else {\n\n            assert(!bs->supported_zero_flags);\n\n        }\n\n\n\n        if (ret == -ENOTSUP) {\n\n            /* Fall back to bounce buffer if write zeroes is unsupported */\n\n            BdrvRequestFlags write_flags = flags & ~BDRV_REQ_ZERO_WRITE;\n\n\n\n            if ((flags & BDRV_REQ_FUA) &&\n\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n\n                /* No need for bdrv_driver_pwrite() to do a fallback\n\n                 * flush on each chunk; use just one at the end */\n\n                write_flags &= ~BDRV_REQ_FUA;\n\n                need_flush = true;\n\n            }\n\n            num = MIN(num, max_transfer);\n\n            iov.iov_len = num;\n\n            if (iov.iov_base == NULL) {\n\n                iov.iov_base = qemu_try_blockalign(bs, num);\n\n                if (iov.iov_base == NULL) {\n\n                    ret = -ENOMEM;\n\n                    goto fail;\n\n                }\n\n                memset(iov.iov_base, 0, num);\n\n            }\n\n            qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n            ret = bdrv_driver_pwritev(bs, offset, num, &qiov, write_flags);\n\n\n\n            /* Keep bounce buffer around if it is big enough for all\n\n             * all future requests.\n\n             */\n\n            if (num < max_transfer) {\n\n                qemu_vfree(iov.iov_base);\n\n                iov.iov_base = NULL;\n\n            }\n\n        }\n\n\n\n        offset += num;\n\n        bytes -= num;\n\n    }\n\n\n\nfail:\n\n    if (ret == 0 && need_flush) {\n\n        ret = bdrv_co_flush(bs);\n\n    }\n\n    qemu_vfree(iov.iov_base);\n\n    return ret;\n\n}\n", "idx": 11141, "substitutes": {"bs": ["abi", "bos", "pos", "utils", "bis", "vals", "its", "cs", "ls", "ss", "bc", "bel", "BS", "pb", "bps", "db", "is", "ks", "lb", "eb", "ins", "bl", "sb", "fps", "ib", "cb", "http", "iss", "ds", "b", "bes", "fb", "fs", "blocks", "bt", "bh", "outs", "gb", "ns", "bi", "css", "ras", "bb", "us", "bing", "ps", "ses", "ubis", "sync", "plugins", "ab", "gs", "banks", "ros", "base", "ubs", "las", "bits", "ob", "bas", "rs", "obs", "lbs", "cons", "obj", "js", "bid", "asts", "bot", "vs"], "offset": ["padding", "shift", "pos", "timeout", "prefix", "size", "type", "limit", "online", "ref", "seq", "len", "i", "off", "config", "reset", "slot", "order", "loc", "boot", "range", "url", "position", "end", "abyte", "Offset", "part", "address", "fp", "oid", "offs", "parent", "from", "tail", "header", "length", "alloc", "o", "num", "error", "start", "index", "head", "inet", "base", "unit", "info", "origin", "set", "root", "name", "data", "alias", "location", "align", "slice"], "bytes": ["pos", "size", "rets", "args", "parts", "zip", "devices", "ls", "seconds", "byte", "seq", "len", "bps", "rows", "es", "lines", "fee", "steps", "outs", "blocks", "boot", "ips", "ones", "total", "pages", "files", "units", "limits", "cells", "ns", "tes", "pieces", "length", "reads", "words", "errors", "used", "body", "Bytes", "bits", "nets", "locks", "data", "count", "ops"], "flags": ["lag", "utils", "utf", "planes", "args", "f", "rets", "ils", "fts", "vals", "feat", "weights", "sf", "FLAG", "fields", "ts", "fps", "mods", "ants", "options", "fee", "details", "settings", "fun", "ips", "fs", "fl", "flag", "bit", "files", "atts", "alls", "rules", " Flags", "ret", "ags", "mask", "plugins", "versions", "bits", "util", "comments", "strings", "Flags", "s", "fd", "locks", "stats", "types", "ops", "features"], "drv": [" drb", "rtv", "drav", "derf", "dervin", " drf", "yrver", "yrv", "hrb", " drvin", "rtvin", "rtf", "derv", "derp", "DRV", "hrav", "yrav", "Drf", "drver", "srf", "DRv", "srV", "rdb", "DrV", "rdv", "hrv", "hrver", "drV", "drp", "srb", " drV", "drb", "srv", "Drv", "rdver", "drf", "yrb", " drp", "Drb", "rtp", "DRb", "drvin", "rdav", "DRf"], "qiov": [" Quno", " qliv", " Qiov", " quno", "qtovi", "quno", "qliv", " Qovi", "qtiov", " Qliv", "qtuno", "qovi", " qovi", "qtliv"]}}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)\n\n        qemu_put_be32s(f, &q->queue[i]);\n\n\n\n    qemu_put_sbe32s(f, &q->next);\n\n    qemu_put_sbe32s(f, &q->priority);\n\n}\n", "idx": 11142, "substitutes": {"f": ["F", "fen", "g", "fr", "tf", "file", "k", "ref", "ff", "self", "sf", "c", "elf", "fe", "d", "p", "rf", "b", "fb", "fs", "j", "feed", "fc", "fp", "t", "df", "r", "o", "af", "l", "cf", "fx", "u", "buff", "fo", "form", "w", "m", "e", "n", "fw", "info", "fd", "bf", "lf", "x"], "q": ["g", "iq", "id", "flow", "k", "view", "plus", "sq", "c", "qt", "d", "quest", "p", "quick", "qa", "work", "queue", "dq", "j", "question", "Q", "v", "r", "cl", "que", "qs", "req", "l", "u", "cf", "sync", "w", "conf", "query", "qu", "e", "info", "qq", "s", "check", "x"], "i": ["ii", "ni", "li", "uri", "hi", "id", "phi", "I", "k", "mu", "ip", "fi", "c", "yi", "iu", "ini", "d", "multi", "h", "ri", "p", "ji", "si", "b", "pi", "io", "j", "gi", "ie", "key", "di", "ti", "v", "xi", "bi", "zi", "qi", "o", "t", "ui", "l", "ci", "u", "index", "start", "e", "n", "info", "jj", "ai", "mini", "x", "ix"]}}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static EHCIQueue *ehci_state_fetchqh(EHCIState *ehci, int async)\n\n{\n\n    uint32_t entry;\n\n    EHCIQueue *q;\n\n    int reload;\n\n\n\n    entry = ehci_get_fetch_addr(ehci, async);\n\n    q = ehci_find_queue_by_qh(ehci, entry);\n\n    if (NULL == q) {\n\n        q = ehci_alloc_queue(ehci, async);\n\n    }\n\n    q->qhaddr = entry;\n\n    q->seen++;\n\n\n\n    if (q->seen > 1) {\n\n        /* we are going in circles -- stop processing */\n\n        ehci_set_state(ehci, async, EST_ACTIVE);\n\n        q = NULL;\n\n        goto out;\n\n    }\n\n\n\n    get_dwords(NLPTR_GET(q->qhaddr), (uint32_t *) &q->qh, sizeof(EHCIqh) >> 2);\n\n    ehci_trace_qh(q, NLPTR_GET(q->qhaddr), &q->qh);\n\n\n\n    if (q->async == EHCI_ASYNC_INFLIGHT) {\n\n        /* I/O still in progress -- skip queue */\n\n        ehci_set_state(ehci, async, EST_HORIZONTALQH);\n\n        goto out;\n\n    }\n\n    if (q->async == EHCI_ASYNC_FINISHED) {\n\n        /* I/O finished -- continue processing queue */\n\n        trace_usb_ehci_queue_action(q, \"resume\");\n\n        ehci_set_state(ehci, async, EST_EXECUTING);\n\n        goto out;\n\n    }\n\n\n\n    if (async && (q->qh.epchar & QH_EPCHAR_H)) {\n\n\n\n        /*  EHCI spec version 1.0 Section 4.8.3 & 4.10.1 */\n\n        if (ehci->usbsts & USBSTS_REC) {\n\n            ehci_clear_usbsts(ehci, USBSTS_REC);\n\n        } else {\n\n            DPRINTF(\"FETCHQH:  QH 0x%08x. H-bit set, reclamation status reset\"\n\n                       \" - done processing\\n\", q->qhaddr);\n\n            ehci_set_state(ehci, async, EST_ACTIVE);\n\n            q = NULL;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n#if EHCI_DEBUG\n\n    if (q->qhaddr != q->qh.next) {\n\n    DPRINTF(\"FETCHQH:  QH 0x%08x (h %x halt %x active %x) next 0x%08x\\n\",\n\n               q->qhaddr,\n\n               q->qh.epchar & QH_EPCHAR_H,\n\n               q->qh.token & QTD_TOKEN_HALT,\n\n               q->qh.token & QTD_TOKEN_ACTIVE,\n\n               q->qh.next);\n\n    }\n\n#endif\n\n\n\n    reload = get_field(q->qh.epchar, QH_EPCHAR_RL);\n\n    if (reload) {\n\n        set_field(&q->qh.altnext_qtd, reload, QH_ALTNEXT_NAKCNT);\n\n    }\n\n\n\n    if (q->qh.token & QTD_TOKEN_HALT) {\n\n        ehci_set_state(ehci, async, EST_HORIZONTALQH);\n\n\n\n    } else if ((q->qh.token & QTD_TOKEN_ACTIVE) && (q->qh.current_qtd > 0x1000)) {\n\n        q->qtdaddr = q->qh.current_qtd;\n\n        ehci_set_state(ehci, async, EST_FETCHQTD);\n\n\n\n    } else {\n\n        /*  EHCI spec version 1.0 Section 4.10.2 */\n\n        ehci_set_state(ehci, async, EST_ADVANCEQUEUE);\n\n    }\n\n\n\nout:\n\n    return q;\n\n}\n", "idx": 11143, "substitutes": {"ehci": ["helmcit", "helmci", "hesski", "hansci", "ahcin", "ahcit", "evcit", "ehcin", "hesssci", "ghci", "ethersci", "ahco", "khcu", "helmdi", "hlii", "ehdi", "ohii", "ghcci", "phercit", "hesscu", "ahcci", "ohsci", "etherii", "ahcu", "hessdi", "enguci", "khcin", "ehCI", "pherci", "ghdi", "ehcu", "ahCI", "ethdi", "hessCI", "ohdi", "ghcu", "helmcin", "hlcci", "ahsci", "ekii", "ethercit", "ehsci", "ohki", "hancit", "ahci", "hanii", "ohcci", "khii", "ohci", "hanci", "engdi", "ehki", "ekuci", "khdi", "ahii", "engci", "hlsci", "evcci", "ehcci", "ehii", "ahki", "ethcin", "ethci", "ekdi", "ahuci", "hlcu", "hlki", "ehcit", "ohcu", "hessci", "ekci", "engii", "ehuci", "ohcin", "hlci", "ahdi", "evii", "phercci", "khco", "evci", "hldi", "hesscci", "khci", "khki", "etherci", "ehco", "hlCI", "pherii", "ethco", "ohcit"], "async": ["ascel", " asynchron", "asssync", "inasynchronous", "asyn", "rasnc", "ASyn", "inasyn", "assync", "rasynchronous", " asyn", "rassync", " asynchronous", "inascel", "assynchronous", "acyn", "Async", "rasync", "ASync", " asnc", "acynchronous", "inasync", "asnc", "ASnc", "rasynchron", "againynchronous", "Assync", " ascel", "Asynchronous", "againync", "assyn", "acsync", "rasyn", "asynchron", "againyn", "asynchronous", "ASynchron", "assnc", "againcel", "Asynchron", "acync", "ASsync", "Asyn", " assync", "ASynchronous", "assynchron"], "entry": ["server", "la", "ga", "parse", "f", "id", "match", "service", "ue", "connection", "route", "d", "event", "card", "rc", "ace", "Entry", "offset", "input", "ent", "cur", "qa", "cell", "ident", "queue", "enter", "ie", "feed", "se", "Q", "address", "key", "record", "image", "row", "inc", "insert", "reader", "channel", "source", "her", "l", "index", "next", "ry", "query", "e", "qu", "ge", "lc", "nt", "element", "data", "cache"], "q": ["g", "parse", "pg", "ack", "iq", "request", "f", "id", "comment", "get", "k", "view", "ue", "update", "quit", "ce", "sq", "c", "i", "qt", "event", "d", "config", "h", "quest", "p", "cur", "input", "ck", "sh", "quick", "qa", "queue", "dq", "question", "cli", "Q", "z", "v", "pe", "charge", "ch", "client", "qi", "t", "eq", "que", "cl", "cmd", "qs", "req", "cf", "u", "l", "sync", "command", "qv", "w", "query", "requ", "qu", "e", "post", "qq", "bug", "check", "cache"], "reload": ["REloads", "Reload", " reloads", "Reresh", "REload", " reloaded", "REresh", "reloaded", "reloads", "reresh", "REloaded", " reresh", "Reloaded", "Reloads"], "seen": ["received", "heard", "known", "sent", "view", "kept", "started", "failed", "ended", "confirmed", "second", "saw", "registered", "expected", "visible", "see", "changed", "session", "sem", "written", "matched", "done", "sex", "opened", "since", "killed", "served", "selected", "given", "shown", "finished", "shared", "eye", "hidden", "ordered"]}}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static void omap_rtc_reset(struct omap_rtc_s *s)\n\n{\n\n    struct tm tm;\n\n\n\n    s->interrupts = 0;\n\n    s->comp_reg = 0;\n\n    s->running = 0;\n\n    s->pm_am = 0;\n\n    s->auto_comp = 0;\n\n    s->round = 0;\n\n    s->tick = qemu_get_clock(rt_clock);\n\n    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));\n\n    s->alarm_tm.tm_mday = 0x01;\n\n    s->status = 1 << 7;\n\n    qemu_get_timedate(&tm, 0);\n\n    s->ti = mktimegm(&tm);\n\n\n\n    omap_rtc_alarm_update(s);\n\n    omap_rtc_tick(s);\n\n}\n", "idx": 11167, "substitutes": {"s": ["server", "g", "tests", "os", "changes", "sym", "f", "request", "service", "its", "cs", "ls", "ss", "states", "xs", "sq", "c", "is", "i", "ks", "a", "services", "d", "sb", "es", "ims", "p", "ts", "si", "sg", "S", "ds", "settings", "b", "fs", "ssl", "sie", "details", "se", "ches", "ns", "hs", "ms", "r", "t", "o", "ps", "qs", "ses", "l", "sync", "u", "gs", "m", "conf", "e", "n", "sys", "sets", "comments", "rs", "su", "info", "js", "stats", "rates", "ops", "features"], "tm": ["tr", "irm", "text", "tp", "rt", "em", "sm", "tz", " mem", " t", "mi", "tri", "metadata", "gm", "md", "mr", "timer", "track", "mod", "ts", "temp", "tk", "fm", "htm", "math", "tick", "mt", "tem", "sim", "trace", "tmp", "ac", "mem", "ti", "t", "ui", "time", "ta", "tom", "ym", "rm", "m", "te", "om", "tis", "mm", "tim", "dt", "tt", "tc", "M", "tx", " m", "dm", "TM", "ram", "nam", "hm"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void tosa_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    PXA2xxState *mpu;\n\n    TC6393xbState *tmio;\n\n    DeviceState *scp0, *scp1;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa255\";\n\n\n\n    mpu = pxa255_init(address_space_mem, tosa_binfo.ram_size);\n\n\n\n    memory_region_init_ram(rom, NULL, \"tosa.rom\", TOSA_ROM, &error_abort);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n    tmio = tc6393xb_init(address_space_mem, 0x10000000,\n\n            qdev_get_gpio_in(mpu->gpio, TOSA_GPIO_TC6393XB_INT));\n\n\n\n    scp0 = sysbus_create_simple(\"scoop\", 0x08800000, NULL);\n\n    scp1 = sysbus_create_simple(\"scoop\", 0x14800040, NULL);\n\n\n\n    tosa_gpio_setup(mpu, scp0, scp1, tmio);\n\n\n\n    tosa_microdrive_attach(mpu);\n\n\n\n    tosa_tg_init(mpu);\n\n\n\n    tosa_binfo.kernel_filename = kernel_filename;\n\n    tosa_binfo.kernel_cmdline = kernel_cmdline;\n\n    tosa_binfo.initrd_filename = initrd_filename;\n\n    tosa_binfo.board_id = 0x208;\n\n    arm_load_kernel(mpu->cpu, &tosa_binfo);\n\n    sl_bootparam_write(SL_PXA_PARAM_BASE);\n\n}\n", "idx": 11193, "substitutes": {"machine": ["server", "message", "linux", "loader", "mode", "service", "comment", "mom", "state", "host", "self", "connection", "controller", "module", "template", "user", "instance", "computer", "node", "config", "model", "normal", "Machine", "boot", "app", "database", "inner", "project", "part", "sim", "address", "image", "arm", "motion", "link", "mac", "hard", "m", "base", "info", "M", "process", "mc", "slave", "space", "manager", "bug", "data", "object", "cache"], "cpu_model": ["memory_model", "cpu_parent", "cpubookmachine", "cpufsource", "cpu_processor", "gpu_scale", "cpu0memory", "cpu0model", "memory_source", "gpu_machine", "gpu_device", "cpu_scale", "cpu_module", "gpu_processor", "gpu_module", "cpu_source", "cpufparent", "memory0model", "cpu_device", "cpufmodel", "memory_memory", "cpubookmodule", "cpubookprocessor", "gpu_mode", "memory0memory", "memory0parent", "cpu0source", "cpu_mode", "cpu_memory", "cpubookmodel", "cpubookscale", "cpu0parent", "memory_parent", "cpu_machine", "cpu_manager", "gpu_manager", "cpubookmode", "memory0source", "gpu_model", "cpufmemory"], "kernel_filename": ["kernel___source", "kernel___metadata", "processoringfilename", "linux_file", "kernelacmetadata", "kernelingfilename", "kernelacfile", "linux_directory", "kernel_document", "processor_document", "kernel___filename", "kernel_name", "linux_filename", "kernel_maximum", "network_filename", "kernelingname", "system_source", "network_sheet", "kernel_source", "kernel___file", "system_file", "kernel_sheet", "processoringname", "processor_maximum", "kernelacfilename", "kernel_file", "kernelingdocument", "network_location", "network_directory", "kernel_fn", "kernel_location", "processoringmaximum", "kernelingmaximum", "kernel_metadata", "processor_name", "processoringdocument", "kernel_directory", "linux_fn", "system_metadata", "kernelacsource", "system_filename", "processor_filename"], "kernel_cmdline": ["kernel_deadment", "kernel_mdline", "kernel_mdLine", "kernel_commanden", "kernel_commandment", "kernel_callLine", "kernel_deadline", "kernel_configside", "kernel_callline", "kernel_cmdl", "kernel_cmdside", "kernel_cmdfile", "kernel_mdl", "kernel_commandlin", "kernel_mden", "kernel_macen", "kernel_commandfile", "kernel_cmdlin", "kernel_pathline", "kernel_cmdment", "kernel_commandLine", "kernel_commandl", "kernel_cmdLine", "kernel_commandline", "kernel_configfile", "kernel_commandside", "kernel_mdlin", "kernel_macline", "kernel_pathside", "kernel_pathfile", "kernel_deadfile", "kernel_macl", "kernel_deadLine", "kernel_maclin", "kernel_callment", "kernel_cmden", "kernel_configline", "kernel_callfile"], "initrd_filename": ["initrd___filename", "initrdjname", "initattr_filename", "initrd2memory", "initattrjusername", "initrd_memory", "initrd___package", "initrt_filename", "initrd_location", "initrdjfilename", "initattrjname", "initrt_package", "initattr_name", "initrd___file", "initrd_username", "initrdjplatform", "initattr_platform", "initrd_package", "initrt_location", "initrd_file", "initrd_files", "initattrjfilename", "initrt_name", "initrd_platform", "initattrjplatform", "initrd2name", "initrd___location", "initrd_name", "initrdjusername", "initrd_sequence", "initrt_memory", "initrt_sequence", "initrt_files", "initattr_username", "initrt_file", "initrd2filename", "initrd2file"], "address_space_mem": ["address_spacemmview", "address_space_min", "address_space33name", "address_pace_name", "address_space2mem", "address_space67memory", "address_network_sum", "address_space2mm", "address_space2Mem", "address_spacemmmem", "address_space33view", "address_spacemmname", "address_space67mem", "address_space_memory", "address_space_view", "address_space_Mem", "address_space2memory", "address_service_mm", "address_pace_view", "address_space_ram", "address_service_mem", "address_network67memory", "address_space_sum", "address_pace_mem", "address_space_name", "address_space_mm", "address_space2min", "address_network67mem", "address_space33mem", "address_network67sum", "address_space67sum", "address_service_ram", "address_network_memory", "address_network_mem", "address_service_Mem", "address_space2ram"], "rom": ["container", "param", "dem", "sam", "mode", "ROM", "crypt", "pro", "gram", "serv", "rg", "rob", "REM", "norm", "ro", "aram", "rim", "gra", "rem", "drm", "cm", "rome", "prom", "ran", "sim", "core", "memory", "cpu", "coll", "mem", "arm", "vm", "rx", "chrom", "ray", "graph", "resource", "cmd", "roc", "r", "cr", "rm", "com", "roma", "ros", "region", "rum", "mor", "rar", "ram", "reg", "roy"], "mpu": ["capu", "ppou", "mpou", " mpus", "mmi", "ppc", "mpi", "ippo", "mpui", "ppus", "mmou", "cpcu", "copcu", " mpo", "mmo", "copus", "mpU", "ppo", "mmus", "mmcu", "mmu", "mpc", "MPU", "capU", "mpcu", "capo", "mpus", " mpc", "MPu", " mpi", "cpus", "mmc", "ppi", "ppl", "ippu", "ipcu", "cpu", "ipo", "mpl", "cpui", "mpo", "cpo", "MPus", " mpou", "ipu", "ppui", "MPcu", "MPo", "mml", " mpl", "ippus", "copu", "ipus", "ppcu", "capus", "copo", "ippui", "ppu", "ppU"], "tmio": ["mmio", "smri", "memius", "smio", "txios", "smrio", "gpiol", "termius", "txIO", "mpios", "smiol", "mpIO", "tmIO", "tgrio", "tgiol", "tmius", "tgio", "gprio", "txio", "tmrio", "mmIO", "tmri", "memro", "tmiol", "mpio", "termro", "gpio", "tmios", "memios", "gpios", "memio", "tmro", "gpius", "mmiol", "gpri", "txiol", "mmios", "mpiol", "termios", "gpro", "tgri", "termio"], "scp0": [" scP2", "scmp13", "ScP2", " scp2", "scppor", "scapor", "Scp3", "scpc2", "scpp2", "scmp1", "ScP0", "scp2", "scap0", "scpp50", "scpor", " scPor", "scp10", "scpc0", "scpp10", "ScP3", "scP2", " scp13", "ScP1", "scpc1", "scap2", "scP0", "scp50", "scP1", "scPor", "scmp10", " scpor", " scp10", "scP3", "scpc3", "scpp1", "Scp2", "Scp0", "scpp0", " scP0", "scmp0", "scpp13", "scP50", " scP50", "scp13", "scp3", "Scp1", " scp50", "scap50"], "scp1": ["scb4", "scv2", " scp2", "scm61", "sct61", " scap1", "scP4", "scm2", "scb2", "sccp7", "scb0", "scm1", "scp2", " scm2", "scap0", "sct0", "scv4", "sct1", "scap1", "scv1", " scp4", "scP7", "scP2", "scap2", "scP0", " scm1", "scP1", "sccp1", "scb1", "scv0", "scp4", " scv2", "scap7", "sct2", " scv4", "scp61", "scm0", " scv0", "scv61", " scap0", " scap2", " scm0", "sccp0", "scp7", " scp7", " scm61", "sccp2", " scap7", " scp61", " scv1"]}}
{"project": "qemu", "commit_id": "73d60fa5fae60c8e07e1f295d8c7fd5d04320160", "target": 1, "func": "static void get_sensor_evt_enable(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);\n\n}\n", "idx": 11202, "substitutes": {"ibs": ["iwis", "ibsys", "gifsys", "ribS", "bbis", "ipS", "ibis", "bbs", "ibg", "ibS", "ribs", "bbS", " ibS", "ibss", "ips", "iwS", "iwsys", " ibis", " ibss", "iws", "obg", "gifS", "iwss", "hwS", "hws", "bbss", "ipg", "obs", "obS", "ribg", "gifs", "hwsys"], "cmd": ["dict", "pipe", "ctx", "mode", "id", "path", "buf", "dom", "md", "seq", "c", "chan", "module", "route", "comm", "config", "cat", "mod", "cb", "bind", "input", "ck", "pkg", "gn", "cp", "nd", "ctrl", "grad", "gen", "cfg", "cc", "kg", "code", "dc", "op", "client", "ind", "cl", "mac", "command", "req", "conn", "force", "head", "call", "cod", "crit", "msg", "Cmd", "count", "cd", "check"], "cmd_len": [" cmd_Len", " cmdslength", " cmdsLen", "cmd_length", "cmdsval", "cmdsLen", "cmd_val", " cmdslen", "cmdslen", " cmd_val", " cmd_length", "cmdslength", " cmdsval", "cmd_Len"], "rsp": ["rrp", "rSp", "rrserv", " rserv", "resp", " rsc", "Rsp", "Rp", "rdsc", " resp", "rdesp", "rdsp", "rresp", "Rserv", "Rsc", "rrsc", "rserv", "rrSp", " rp", "rdSp", "rrsp", "rp", " rSp", "rsc"], "rsp_len": ["rsp2limit", "rsp2length", "rsc_limit", "rsp_limit", "rsp2Len", "rsp2len", "rsp_length", "rsc_len", "rsc_Len", "rsc_length", "rsp_Len"], "max_rsp_len": ["max_rsp_length", "max_rsp_l", "max_rsc_l", "max_rsc_len", "max_rsc_length", "max_rsp_val", "max_rsc_val"], "sens": ["gENS", "dENS", "Sened", "sensing", "gened", "statensor", "statents", "fensor", "Sents", "fents", "Sensor", "cents", " sENS", "gractor", "fenses", "cens", "statENS", "censing", "pensor", " sents", "dents", "gensor", " sensor", " sened", "fENS", "Sets", "sensor", "pens", "sened", "gens", "dens", " sensing", "Sens", "sENS", "gets", "Sractor", "senses", "fens", "statens", " sets", "sents", "sractor", "censes", "sets", "fensing", " senses", "SENS", "gents", "densor", "practor", "pENS"]}}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "struct omap_uart_s *omap_uart_init(hwaddr base,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk,\n\n                qemu_irq txdma, qemu_irq rxdma,\n\n                const char *label, CharDriverState *chr)\n\n{\n\n    struct omap_uart_s *s = (struct omap_uart_s *)\n\n            g_malloc0(sizeof(struct omap_uart_s));\n\n\n\n    s->base = base;\n\n    s->fclk = fclk;\n\n    s->irq = irq;\n\n    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,\n\n                               omap_clk_getrate(fclk)/16,\n\n                               chr ?: qemu_chr_new(label, \"null\", NULL),\n\n                               DEVICE_NATIVE_ENDIAN);\n\n    return s;\n\n}\n", "idx": 11235, "substitutes": {"base": ["server", "padding", "prefix", "size", "file", "type", "f", "mode", "site", "id", "local", "api", "ip", "bare", "addr", "ma", "c", "db", "i", "model", "p", "normal", "offset", "b", "fake", "core", "scale", "pre", "address", "kit", "source", "area", "force", "proxy", "hard", "index", "start", "buffer", "pad", "basic", "pa", "info", "unit", "bas", "ase", "out", "root", "space", "name", "data", "count", "Base", "x", "cache"], "irq": ["irqi", "arqi", "rk", "dirq", "iriqual", "ironqi", "arinquire", " irqu", "ierquire", "arinqual", "iriquire", "irk", "arinqu", "arinq", "iriq", "dirqs", "rinque", "rinq", "dirqu", " irk", "rq", "ironk", "rinqs", " irqi", "riq", "iriqu", "riqs", "ariq", "irque", "ironqs", "arq", "dirque", "irtqi", "irqual", "rinqu", "irquire", "rqi", "ierqual", "ariqu", "irqs", "ark", "ironq", "ariqs", "ierq", "arqu", "irtqu", "irtk", "irqu", "irtq", "rqs", "arique", "ierqu", "riqi", "rik"], "fclk": ["fplq", "fclks", "fCLks", "fpln", "fslf", "cclq", "Fclok", "fclp", "fclf", "fslk", "faclK", "fClk", "fCLk", "cplf", "fclK", "fClks", "Fplq", "Fplok", "cplq", "fclq", "Fplk", "cplp", "fCLK", "fplok", "Fclf", "Fplks", "fflk", "fClq", "Fpln", "fcln", "Fcln", "Fclq", "fCLf", "fflK", "flicks", "faclok", "fflq", "cclf", "cplk", "fCLq", "fflp", "Fclks", "flick", "cclp", "FclK", "facln", "flicf", "flicq", "fplf", "fplk", "Fclk", "ffln", "cclk", "fflok", "FplK", "faclk", "fClK", "fplp", "fflf", "fclok", "fslp", "fplks", "fplK", "fslq"], "iclk": ["icelq", "icdlq", "iclp", "iclka", "icilk", "isclq", "icilp", "icdlka", "iscelk", "isclk", "isclka", "iscelq", "isclp", "icilq", "icelp", "icilka", "icelk", "iclq", "icdlp", "iscelp", "icdlk", "iscelka", "icelka"], "txdma": ["rxfla", "txdlma", "txdlmas", "txdla", "rxfca", "rxdca", "txfla", "txfca", "txnla", "txfma", "txdmas", "txdlca", "txnca", "txnma", "rxdmas", "rxdla", "rxfma", "txnmas", "txfmas", "rxfmas", "txdca", "txdlla"], "rxdma": ["rxena", "rxdna", "nrxena", "rxdda", "rxema", "rxfca", "nrxdma", "rxdca", "rxcma", "rxfda", "nrxdca", "nrxema", "rxcna", "rxcda", "nrxeda", "rxfma", "rxeca", "nrxdna", "nrxeca", "nrxdda", "rxfna", "rxeda", "rxcca"], "label": ["message", "text", "abel", "block", "prefix", "comment", "description", "err", "hide", "route", "lab", "eval", "bl", "field", "input", "loc", "cell", "scale", "charge", "key", "address", "el", "error", "l", "ab", "desc", "col", "unknown", "unit", "reason", "msg", "nob", "name", "uni", "dl", "data", "target", "alias", "align", "Label"], "chr": ["CHrt", "Chrs", "echr", "chrc", "chrs", "echrs", "ichR", " chri", "chrt", " chrt", " chrb", "chri", "ichr", "ichrt", "echrc", " chrs", "ichri", " chrc", "echrb", "Chr", "Chrc", "Chrb", "CHri", "chR", "chrb", " chR", "CHR", "CHr"], "s": ["g", "os", "als", "sym", "f", "its", "cs", "ls", "ss", "c", "sq", "single", "a", "i", "is", "d", "services", "sb", "rows", "es", "ings", "p", "ts", "ves", " shares", "si", "sg", "S", "session", "b", "settings", "ds", "ssl", "fs", "socket", "ips", "ows", "lines", "sl", "ns", "v", "spec", "o", "t", "ses", "l", "u", "sync", "gs", "w", "m", "ures", "e", "n", "sys", "sets", "su", "rs", "sa", "js", "ops", "ches"]}}
{"project": "qemu", "commit_id": "fef6070eff233400015cede968b0afe46c80bb0f", "target": 0, "func": "static int create_dynamic_disk(int fd, uint8_t *buf, int64_t total_sectors)\n\n{\n\n    VHDDynDiskHeader *dyndisk_header =\n\n        (VHDDynDiskHeader *) buf;\n\n    size_t block_size, num_bat_entries;\n\n    int i;\n\n    int ret = -EIO;\n\n\n\n    // Write the footer (twice: at the beginning and at the end)\n\n    block_size = 0x200000;\n\n    num_bat_entries = (total_sectors + block_size / 512) / (block_size / 512);\n\n\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    if (lseek(fd, 1536 + ((num_bat_entries * 4 + 511) & ~511), SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    // Write the initial BAT\n\n    if (lseek(fd, 3 * 512, SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    memset(buf, 0xFF, 512);\n\n    for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++) {\n\n        if (write(fd, buf, 512) != 512) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    // Prepare the Dynamic Disk Header\n\n    memset(buf, 0, 1024);\n\n\n\n    memcpy(dyndisk_header->magic, \"cxsparse\", 8);\n\n\n\n    /*\n\n     * Note: The spec is actually wrong here for data_offset, it says\n\n     * 0xFFFFFFFF, but MS tools expect all 64 bits to be set.\n\n     */\n\n    dyndisk_header->data_offset = be64_to_cpu(0xFFFFFFFFFFFFFFFFULL);\n\n    dyndisk_header->table_offset = be64_to_cpu(3 * 512);\n\n    dyndisk_header->version = be32_to_cpu(0x00010000);\n\n    dyndisk_header->block_size = be32_to_cpu(block_size);\n\n    dyndisk_header->max_table_entries = be32_to_cpu(num_bat_entries);\n\n\n\n    dyndisk_header->checksum = be32_to_cpu(vpc_checksum(buf, 1024));\n\n\n\n    // Write the header\n\n    if (lseek(fd, 512, SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    if (write(fd, buf, 1024) != 1024) {\n\n        goto fail;\n\n    }\n\n    ret = 0;\n\n\n\n fail:\n\n    return ret;\n\n}\n", "idx": 11268, "substitutes": {"fd": ["deck", "FH", "wd", "fn", "die", "f", "file", "cdn", "draft", "fi", "sf", "flo", "ft", "raf", "db", "gd", "d", "cb", " f", "fm", "fb", "FD", "fl", "driver", "fs", "grad", "feed", "rb", "bd", "fat", "fc", "fp", "dc", "dd", "reader", "df", "handler", "af", "uf", "cond", "fx", "buff", "buffer", "func", "fw", "fed", "wb", "dra", "bf", "dl", " fid", "dir", "lf", "writer"], "buf": ["ctx", "src", "exc", "seq", "c", "rc", "b", "fb", "filename", "queue", "done", "bd", "Buffer", "cmd", "uf", "buff", "pad", "fw", "true", "raw", "feat", "cas", "fn", "raf", "bag", "db", "usb", "sb", "ru", "fa", "fp", "alloc", "handler", "fx", "bus", "f", "ptr", "ff", "bc", "pb", "fab", "config", "pkg", "bh", "fc", "br", "cf", "wav", "null", "fin", "vec", "fi", "proc", "cb", "loc", "xff", "Buff", "cp", "bt", "feed", "rb", "tmp", "cv", "dc", "reader", "tab", "buffer", "wb", "uc", "batch", "bf", "data"], "total_sectors": ["total_belements", "total_bectors", "total_psectors", "total_sergments", "total_gegment", "total_begments", "total_pselements", "total_serrets", "total_pectors", "total_segment", "total_gectors", "total_gegments", "total_pserets", "total_psegment", "total_selements", "total_pelements", "total_serctors", "total_serets", "total_segments", "total_bections", "total_sections", "total_psections", "total_pections", "total_psegments", "total_gerets", "total_pegments", "total_sergment"], "dyndisk_header": ["dyndisk_size", "dyndisc_server", "dyndraw_version", "dyndink_size", "dyndisk_headers", "dyndisk_player", "dyndisk__layer", "dyndisk_metadata", "dyndiskxback", "dyndise_handler", "dyndisk_writer", "dyndisk_message", "dyndiskxmetadata", "dyndisk_back", "dyndiskOheader", "dyndiskOreference", "dyndisksxheader", "dyndisksxback", "dyndise_writer", "dyndink_buffer", "dyndisksxlayer", "dyndiskOwriter", "dyndiskdlayer", "dyndise_message", "dyndisks_back", "dyndisc_header", "dyndisktheplayer", "dyndise_server", "dyndiskfmetadata", "dyndraw_player", "dyndisktheversion", "dyndisk_buffer", "dyndisk_server", "dyndiskdheader", "dyndisktheheader", "dyndise_dr", "dyndisk_error", "dyndiskfheader", "dyndiskdmetadata", "dyndiskfoffset", "dyndisc_offset", "dyndise_headers", "dyndise_layer", "dyndiskxlayer", "dyndink_header", "dyndink_layer", "dyndisk_layer", "dyndraw_error", "dyndisk_version", "dyndisk__writer", "dyndise_reference", "dyndisc_layer", "dyndisk_offset", "dyndrawtheversion", "dyndisk__dr", "dyndise_header", "dyndrawtheheader", "dyndiskfserver", "dyndisktheerror", "dyndraw_header", "dyndisks_layer", "dyndrawtheplayer", "dyndisk__header", "dyndiskxheader", "dyndink_metadata", "dyndisks_header", "dyndisks_metadata", "dyndisk_handler", "dyndisk_reference", "dyndink_writer", "dyndisk_dr", "dyndiskfback", "dyndrawtheerror", "dyndink_headers", "dyndisksxmetadata", "dyndiskflayer", "dyndiskOheaders", "dyndiskdheaders"], "block_size": ["block_sized", "block_group", "block_content", "block___content", "device_type", "server_speed", "serveralsize", " block_time", "serveralspeed", "block_fee", "block_offset", "blockalsize", "serveralweight", "block64limit", " block_limit", "block_limit", "device_length", " block_offset", "block_speed", "server_size", "block64weight", "cache_strength", "blockalstorage", "blockalweight", "block_storage", "block64storage", "group_length", "block64time", "block_type", "block_mini", "cache_mini", "serveralstorage", "blockalspeed", "server_weight", " block_sized", "group_fee", "block_time", "block_scale", "block_length", "block64size", "block___offset", "device_scale", "group_size", " block_content", "block___size", "block_weight", "block64speed", "device_size", "group_group", "cache_size", "server_storage", "cache_scale", "block_strength", "block64sized"], "num_bat_entries": ["num_bat_Entrying", "num_bat_ntries", "num_bat_addances", "num_bat_ntrows", "num_bat_entues", "num_bat_entrying", "num_bat_centues", "num_bat_ntry", "num_bat_ctries", "num_bat_centry", "num_bat_incrows", "num_bat_addries", "num_bat_ntories", "num_bat_entrys", "num_bat_ntrs", "num_bat_ctrys", "num_bat_incrs", "num_bat_ctry", "num_bat_ntances", "num_bat_centrys", "num_bat_Entry", "num_bat_ctrs", "num_bat_ntues", "num_bat_addry", "num_bat_incry", "num_bat_entry", "num_bat_contries", "num_bat_entories", "num_bat_centances", "num_bat_ntrys", "num_bat_entrs", "num_bat_centrs", "num_bat_contrying", "num_bat_entances", "num_bat_contrys", "num_bat_addories", "num_bat_centories", "num_bat_entrows", "num_bat_Entries", "num_bat_ntrying", "num_bat_contry", "num_bat_centrows", "num_bat_incues", "num_bat_centries", "num_bat_incries", "num_bat_Entrys"], "i": ["ii", "g", "ni", "li", "uri", "id", "phi", "I", "mu", "ip", "oi", "mi", "fi", "chi", "y", "c", "yi", "iu", "ini", "d", "multi", "ji", "p", "ri", "si", "split", "b", "pi", "inner", "j", "gi", "ami", "in", "ti", "zi", "bi", "xi", "di", "qi", "hi", "ui", "o", "l", "ci", "start", "index", "u", "m", "e", "n", "base", "info", "ai", "mini", "eni", "count", "it"]}}
{"project": "qemu", "commit_id": "b9c532903fa528891c0eceb34ea40a0c47bfb5db", "target": 0, "func": "static int qemu_rbd_snap_list(BlockDriverState *bs,\n\n                              QEMUSnapshotInfo **psn_tab)\n\n{\n\n    BDRVRBDState *s = bs->opaque;\n\n    QEMUSnapshotInfo *sn_info, *sn_tab = NULL;\n\n    int i, snap_count;\n\n    rbd_snap_info_t *snaps;\n\n    int max_snaps = RBD_MAX_SNAPS;\n\n\n\n    do {\n\n        snaps = g_malloc(sizeof(*snaps) * max_snaps);\n\n        snap_count = rbd_snap_list(s->image, snaps, &max_snaps);\n\n        if (snap_count < 0) {\n\n            g_free(snaps);\n\n        }\n\n    } while (snap_count == -ERANGE);\n\n\n\n    if (snap_count <= 0) {\n\n        return snap_count;\n\n    }\n\n\n\n    sn_tab = g_malloc0(snap_count * sizeof(QEMUSnapshotInfo));\n\n\n\n    for (i = 0; i < snap_count; i++) {\n\n        const char *snap_name = snaps[i].name;\n\n\n\n        sn_info = sn_tab + i;\n\n        pstrcpy(sn_info->id_str, sizeof(sn_info->id_str), snap_name);\n\n        pstrcpy(sn_info->name, sizeof(sn_info->name), snap_name);\n\n\n\n        sn_info->vm_state_size = snaps[i].size;\n\n        sn_info->date_sec = 0;\n\n        sn_info->date_nsec = 0;\n\n        sn_info->vm_clock_nsec = 0;\n\n    }\n\n    rbd_snap_list_end(snaps);\n\n\n\n    *psn_tab = sn_tab;\n\n    return snap_count;\n\n}\n", "idx": 11303, "substitutes": {"bs": ["bos", "os", "cs", "ls", "state", "ss", "bc", "BS", "pb", "lb", "ins", "sb", "bl", "ts", "iss", "ds", "b", "outs", "fs", "fb", "bh", "gb", "ns", "us", "bb", "ps", "ses", "qs", "gs", "rs", "obs", "bp", "js", "vs", "aws"], "psn_tab": ["pssn_buf", "psn2ab", "pssn_tab", "psrn_tab", "psn2tab", "pssn_tmp", "psn2Tab", "psrn_loop", "psn_Tab", "psn_tmp", "psn_buf", "psrn_Tab", "psn_loop", "psn2loop", "psn_ab", "psrn_ab", "pssn_ab"], "s": ["g", "os", "sym", "f", "bis", "service", "cs", "ls", "state", "ss", "states", "c", "is", "sup", "services", "sb", "p", "S", "session", "ds", "b", "settings", "ssl", "sl", "ns", "spec", "o", "ps", "ses", "m", "sn", "conf", "south", "e", "sys", "storage", "sa", "js", "ops", "aws"], "sn_info": ["snalldata", "snameinf", "snpfo", "snapJdata", "snappid", "sl_INFO", "snPstart", "nn_data", "snap_Info", "nsJinfo", "snererror", "ns_comment", "snapacinf", "sn_field", "nsJfo", "snJdata", "swPid", "nn_hand", "sn_inf", "ns_info", "snapJinfo", "snap_inf", "snapappinfo", "snJinit", "snap_info", "sl_error", " sn_manager", "wn_error", "snPpart", "snapappname", "snnmanager", "sw_start", "snallinfo", "nsJinner", "snJfo", "snJerror", "ns_fo", "ns_open", "sn_part", "snacinf", "sn_name", "snJinf", "snerINFO", "snap_init", "ns_error", "snJinner", "sn_start", "sn__info", "sn__manager", "wn_info", " sn_inf", "wn_field", "sn_inner", "snapJinf", "snactab", "sl_private", "sn__tab", "snappInfo", "snJinfo", "swPstart", "snap_start", "ns_manager", "sn_error", "snappstart", "snapacdata", "snappinfo", "sn_hand", "snapactab", "sn_Info", "snperror", "sn_init", "snapacinfo", "snap_tab", "wn_id", "nn_info", "snerinfo", "snninfo", "snacinfo", "sn_manager", "sn_open", "sn_data", "ns_inner", "snap_data", "snappfield", "sn_INFO", "swPpart", "snpinfo", "sw_id", "snallhand", "snerprivate", "snacdata", "snametab", "sn__inf", "snapJinit", "sl_info", "snapappstart", "snPinfo", "swPinfo", "snameinfo", "sw_info", "sn_id", "sn_private", "snpinner", "sn_comment", "sw_part", "sn_fo", "snamedata", "snnopen", "snappname", "nsJerror", "snncomment", "snapappInfo", "snPid", "snapperror"], "sn_tab": ["snncount", "pn_info", "sw_loc", "nn_app", "sn_space", "sw_account", "nn_count", "sw_ab", "sn_count", "sn_ab", "nn_tab", "snPtab", "pn_space", "sn__info", "sn_app", "swPtab", "snnapp", "sn__account", "sn__tab", "snPab", "pn_tab", "snPaccount", "sn_loc", "swPaccount", "snnaccount", "snntab", "sw_tab", "sn_account", "snPinfo", "swPinfo", "pn_lab", "sw_info", "sn__ab", "sn_lab", "swPab", "nn_account"], "i": ["ii", "ni", "abi", "li", "uri", "isin", "hi", "f", "pointer", "id", "phi", "I", "k", "mu", "ip", "oi", "mi", "fi", "gu", "y", "c", "yi", "iu", "ini", "d", "multi", "h", "ji", "p", "ri", "slice", "si", "b", "pi", "io", "j", "gi", "ie", "ami", "z", "v", "ti", "xi", "zi", "di", "qi", "r", "ui", "bi", "o", "l", "ci", "u", "index", "start", "m", "ij", "e", "n", "info", "ai", "iw", "eni", "name", "x", "ix", "it"], "snap_count": ["snapFtotal", "snapPweight", "snapNcheck", " snap_len", "capt_loop", "snapNloop", "recordfaddress", "snap_address", "recordfindex", "snap67address", "record_address", "snap64size", "snapfaddress", "snap_check", "sn_count", "spotxtotal", "snapxcount", "snapNcount", "spot_count", " snap_weight", "snapPcount", "gap_size", "snapNhandle", "gap_check", "snapfsize", "snap_limit", "recordfsize", "snapFtime", "snapxtotal", "snap_force", "snap_weight", " snap_cast", "snapPlimit", "snapJcheck", "capt_count", "snap67size", "snap67index", "snap67count", "snap_time", "snap_index", "snap_cast", "snap64force", "snapJcast", " snap_check", "capt_handle", "spot_time", "snapencount", "snapfindex", " snap_depth", " snap_size", "record_size", "snapPloop", "record_count", "snap_total", "capt_check", "spotxtime", "snap64count", "snapfcount", "snap_depth", "record_index", "snap64check", "snapPhandle", "snapencheck", "snapFcount", "snapxtime", "snapPcheck", "snapJcount", "sn_cast", "spot_total", " snap_number", "spotxcount", "snapencast", "snap_len", "snap_size", "gap_force", " snap_limit", "gap_count", "snap_handle", "snap_number", "snap_loop", "recordfcount", "sn_number"], "snaps": ["snap", "napes", "swaps", "synapses", "knabs", " snats", "knips", "swats", "synapes", "slops", "swips", "knops", "naps", "nips", "nasts", "swops", "knapping", "slps", "nap", "napps", "snapes", "sliffs", "slap", "swapses", "slabs", "snats", " snapping", "synps", "snabs", " snops", "swapes", "swap", "spapps", "synaps", "knapses", "sniffs", "snips", "swabs", "slapps", "slasts", "knapps", " snapps", "snps", "clabs", " snips", "spaps", "knapes", "nps", "spasts", "knats", "clips", "slapses", "cliffs", "claps", "slaps", "snapps", "knaps", "spps", "snapping", " snabs", "slips", "snapses", "slapping", "swps", "swiffs", "slapes", "snops", "snasts"], "snap_name": ["snap64key", "snap64id", "snapfname", "pg_str", "gap_id", "snap_anc", "snapJanc", "snap_key", "snapJsize", "pg_name", "snap___size", "switch_name", "snap_source", "snap64name", "switch_source", "snappcount", "pg_count", "snapJalias", "snap_ni", "snapfalias", "pgfalias", "gap_ni", "gap_name", "snapJcount", "snap_id", "snap___name", "switch_anc", "snap_alias", "pgfcount", "pg_alias", "snap___anc", "snapJstr", "snap_size", "snapfstr", "snapJname", "snappstr", "snap___source", "snapfcount", "snappname", "pgfstr", "snapJsource", "pgfname", "snap64ni", "snap_str", "gap_key", "snappalias", "switch_size"]}}
{"project": "qemu", "commit_id": "62c58ee0b24eafb44c06402fe059fbd7972eb409", "target": 0, "func": "static bool get_phys_addr_pmsav8(CPUARMState *env, uint32_t address,\n\n                                 MMUAccessType access_type, ARMMMUIdx mmu_idx,\n\n                                 hwaddr *phys_ptr, int *prot, uint32_t *fsr)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    bool is_user = regime_is_user(env, mmu_idx);\n\n    int n;\n\n    int matchregion = -1;\n\n    bool hit = false;\n\n\n\n    *phys_ptr = address;\n\n    *prot = 0;\n\n\n\n    /* Unlike the ARM ARM pseudocode, we don't need to check whether this\n\n     * was an exception vector read from the vector table (which is always\n\n     * done using the default system address map), because those accesses\n\n     * are done in arm_v7m_load_vector(), which always does a direct\n\n     * read using address_space_ldl(), rather than going via this function.\n\n     */\n\n    if (regime_translation_disabled(env, mmu_idx)) { /* MPU disabled */\n\n        hit = true;\n\n    } else if (m_is_ppb_region(env, address)) {\n\n        hit = true;\n\n    } else if (pmsav7_use_background_region(cpu, mmu_idx, is_user)) {\n\n        hit = true;\n\n    } else {\n\n        for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) {\n\n            /* region search */\n\n            /* Note that the base address is bits [31:5] from the register\n\n             * with bits [4:0] all zeroes, but the limit address is bits\n\n             * [31:5] from the register with bits [4:0] all ones.\n\n             */\n\n            uint32_t base = env->pmsav8.rbar[n] & ~0x1f;\n\n            uint32_t limit = env->pmsav8.rlar[n] | 0x1f;\n\n\n\n            if (!(env->pmsav8.rlar[n] & 0x1)) {\n\n                /* Region disabled */\n\n                continue;\n\n            }\n\n\n\n            if (address < base || address > limit) {\n\n                continue;\n\n            }\n\n\n\n            if (hit) {\n\n                /* Multiple regions match -- always a failure (unlike\n\n                 * PMSAv7 where highest-numbered-region wins)\n\n                 */\n\n                *fsr = 0x00d; /* permission fault */\n\n                return true;\n\n            }\n\n\n\n            matchregion = n;\n\n            hit = true;\n\n\n\n            if (base & ~TARGET_PAGE_MASK) {\n\n                qemu_log_mask(LOG_UNIMP,\n\n                              \"MPU_RBAR[%d]: No support for MPU region base\"\n\n                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"\n\n                              \"%d\\n\",\n\n                              n, base, TARGET_PAGE_BITS);\n\n                continue;\n\n            }\n\n            if ((limit + 1) & ~TARGET_PAGE_MASK) {\n\n                qemu_log_mask(LOG_UNIMP,\n\n                              \"MPU_RBAR[%d]: No support for MPU region limit\"\n\n                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"\n\n                              \"%d\\n\",\n\n                              n, limit, TARGET_PAGE_BITS);\n\n                continue;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!hit) {\n\n        /* background fault */\n\n        *fsr = 0;\n\n        return true;\n\n    }\n\n\n\n    if (matchregion == -1) {\n\n        /* hit using the background region */\n\n        get_phys_addr_pmsav7_default(env, mmu_idx, address, prot);\n\n    } else {\n\n        uint32_t ap = extract32(env->pmsav8.rbar[matchregion], 1, 2);\n\n        uint32_t xn = extract32(env->pmsav8.rbar[matchregion], 0, 1);\n\n\n\n        if (m_is_system_region(env, address)) {\n\n            /* System space is always execute never */\n\n            xn = 1;\n\n        }\n\n\n\n        *prot = simple_ap_to_rw_prot(env, mmu_idx, ap);\n\n        if (*prot && !xn) {\n\n            *prot |= PAGE_EXEC;\n\n        }\n\n        /* We don't need to look the attribute up in the MAIR0/MAIR1\n\n         * registers because that only tells us about cacheability.\n\n         */\n\n    }\n\n\n\n    *fsr = 0x00d; /* Permission fault */\n\n    return !(*prot & (1 << access_type));\n\n}\n", "idx": 11316, "substitutes": {"env": ["ne", "oa", "fen", "np", "eve", "loader", "args", "ctx", "esm", "site", "online", "eng", "state", "err", "ea", "exc", "chn", "example", "output", "engine", "skin", "kn", "db", "en", "qt", "eu", "config", "ev", "enc", "console", "stage", "Environment", "visor", "net", "queue", "ext", "context", "core", "him", "ut", "osc", "cli", "viron", "po", "environment", "que", "her", "req", "conn", "virt", "dt", "conf", "inet", "e", "obj", "init", "er", "profile", "ec", "estate", "eni", "txt", "energy", "exec", "ef", "exe", "esp"], "address": ["server", "padding", "abi", "message", "uri", "prefix", "capacity", "site", "size", "pointer", "type", "localhost", "attribute", "device", "service", "path", "api", "date", "limit", "state", "ip", "host", "class", "output", "addr", "network", "route", "en", "instance", "config", "ace", "offset", "password", "order", "settings", "range", "account", "shape", "interface", "url", "center", "context", "position", "core", "enter", "code", "image", "length", "channel", "email", "resource", "area", "source", "conn", "point", "index", "reference", "alias", "buffer", "region", "base", "port", "balance", "Address", "eni", "name", "repeat", "grade", "target", "number", "location", "enable"], "access_type": [" access2type", " access_name", "access2type", " access2id", "access2id", " access_id", "access_info", " access2name", "access_name", " access_info", "access2name", "access2info", " access2info", "access_id"], "mmu_idx": ["mmu_Idb", "mmu_IDv", "mmu_midb", "mmu_inc", "mmu_midxe", "mmu_Idn", "mmu_idxc", "mmu_idsx", "mmu_midx", "mmu_idsX", "mmu_adx", "mmu_Idx", "mmu_IDc", "mmu_idn", "mmu_IDx", "mmu_IdX", "mmu_idg", "mmu_idexc", "mmu_ideb", "mmu_midX", "mmu_idb", "mmu_adc", "mmu_IDX", "mmu_Idg", "mmu_midxc", "mmu_midg", "mmu_adv", "mmu_idX", "mmu_idsv", "mmu_idsc", "mmu_adn", "mmu_idc", "mmu_idv", "mmu_inx", "mmu_idex", "mmu_midn", "mmu_IDn", "mmu_inn", "mmu_Idxe", "mmu_idxe", "mmu_inv", "mmu_IDg", "mmu_Idxc", "mmu_idexe"], "phys_ptr": ["phy_ref", "phys_tr", "phys_pointer", " phys_tr", "phy_pointer", " phys_addr", "phys_addr", "phys_ref", "phy_addr", " phys_port", "phys_port", "phy_ptr"], "prot": ["server", "pos", "abi", "np", "uri", "prefix", "sil", "prop", "type", "src", "format", "att", "pro", "chron", "addr", "seq", "ocol", "transfer", "afi", "config", "model", "p", "offset", "reset", "slot", "lit", "io", "Prot", "protection", "ext", "cli", "nat", "rot", "channel", "platform", "conn", "dim", "rin", "pat", "port", "status", "target", "phys"], "fsr": [" fsR", "fsrr", "fxp", "psR", "FSr", "fxR", "fxr", "FSrr", "atsr", "FSR", " fsp", "fsrf", "psrb", "fsrs", " fsrr", "ssp", "psrs", " fsrb", "ssR", "fxrf", "FSrs", "psr", "ssrf", "fsrb", "FSrb", "fsp", "ssr", " fsrf", "atsrs", "atsR", " fsrs", "fsR", "atsrr"], "cpu": ["os", "np", "hw", "linux", "ctx", "pool", "device", "nic", "cow", "proc", "c", "pc", "cmp", "lb", "jp", "cache", "pu", "node", "computer", "kernel", "p", "CPU", "chip", "boot", "net", "cp", "cm", "px", "hp", "core", "cli", "machine", "mem", "vm", "roc", "platform", "gp", "bench", "gpu", "conn", "uci", "cn", "lc", "gc", "processor", "vidia", "mx", "prem"], "n": ["nin", "ne", "g", "ni", "np", "fn", "no", "un", "pn", "nr", "f", "limit", "k", "nc", "na", "nb", "y", "c", "len", "network", "en", "i", "N", "d", "node", "p", "span", "b", "net", "nu", "j", "nw", "nl", "ng", "ns", "z", "nat", "v", "in", "number", "num", "dn", "t", "o", "r", "l", "nit", "conn", "u", "index", "nn", "m", "sn", "w", "e", "base", "cn", "nt", "s", "name", "syn", "count", "mn", "x", "nm"]}}
{"project": "qemu", "commit_id": "7e55d65c56a03dcd2c5d7c49d37c5a74b55d4bd6", "target": 1, "func": "static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n\n                           uint64_t off, uint32_t max_count)\n\n{\n\n    ssize_t err;\n\n    size_t offset = 7;\n\n    int read_count;\n\n    int64_t xattr_len;\n\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n\n    VirtQueueElement *elem = v->elems[pdu->idx];\n\n\n\n    xattr_len = fidp->fs.xattr.len;\n\n    read_count = xattr_len - off;\n\n    if (read_count > max_count) {\n\n        read_count = max_count;\n\n    } else if (read_count < 0) {\n\n        /*\n\n         * read beyond XATTR value\n\n         */\n\n        read_count = 0;\n\n    }\n\n    err = pdu_marshal(pdu, offset, \"d\", read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n\n\n    err = v9fs_pack(elem->in_sg, elem->in_num, offset,\n\n                    ((char *)fidp->fs.xattr.value) + off,\n\n                    read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n    return offset;\n\n}\n", "idx": 11328, "substitutes": {"s": ["server", "os", "f", "service", "state", "self", "ss", "states", "serv", "c", "sq", "is", "instance", "services", "sb", "p", "si", "S", "session", "scope", "b", "fs", "ssl", "se", "State", "sl", "t", "r", "ses", "m", "south", "e", "n", "sys", "su", "storage", "status"], "pdu": [" puu", "puda", "Pou", " psu", "Ptu", "psu", "Pdu", " pou", "Pud", "puu", "Pda", "pou", "pcu", "pptu", "wpdu", "ppda", "Puu", "ptu", "spuda", "spsu", "pda", " puda", "wpuu", "spcu", "wpou", " pda", "pud", "ppuda", "ppsu", "ppcu", " pcu", "spdu", "ppdu", "wptu", "ppud", " pud", " ptu"], "fidp": ["cidr", "fixr", "fixp", "faidp", "pidg", "poidf", "foide", "fidee", "fiddl", "faidP", "cidP", "foidf", "fixP", "fpidl", "pidp", "faidl", "pidf", "poide", "fidper", "fpidp", " fidl", "fiddper", "faidr", "fadp", "fidP", "fiddc", "fpidper", " fidc", "fiddp", "fadr", " fidper", "cidf", "cidp", "fidef", "faidper", "foidp", "fidep", " fiddl", "caidP", "fipp", " fiddp", "fadf", "fipg", "fidf", "poidp", " fiddper", "fixf", "foidg", "caidf", "fide", "fadP", "poidg", "fidc", "fideg", "fidr", "pide", "faidc", "fpidc", "caidp", "faidf", " fiddc", "fidl", "fipe", "fidg", "caidr", "fipf"], "off": ["shift", "pos", "Off", "up", "block", "OFF", "on", "offer", "mode", "flow", "buf", "ref", "ip", "ff", "now", "addr", "low", "own", "len", "art", "non", "new", "offset", "reset", "ord", "load", "open", "end", "offs", "less", "over", "down", "num", "length", "o", "opt", "def", "buff", "pad", "info", "set", "out", "raw", "alt", "none", "data"], "max_count": ["max67length", "max67count", " max_child", "max_length", "maxitycount", "max_child", " max_handle", "maxxchild", "maxxlen", "max_handle", "maxersize", "max_weight", "max67weight", "max67handle", " max_len", "maxityweight", " max_length", "maxercount", "max_size", "maxxcount", "maxerlen", "maxitylength", "maxxsize", "max_len", " max_weight", "maxerchild", "maxityhandle", " max_size"], "err": ["nor", "ref", "min", "seq", "ver", "mr", "master", "rc", "lr", "orig", "ar", "yr", "arm", "cr", "gr", "org", "init", "e", "msg", "or", "idy", "aster", "nr", " error", "result", "fer", "iter", "sr", "range", "rn", "code", "header", "error", "attr", "later", "er", "ln", "out", "var", "rag", "str", "shift", "Error", "ctr", "resp", "good", "len", "Er", "ah", "load", "ler", "more", "trace", "ee", "ind", "r", "br", "req", "errors", "ir", "map", "body", "rr", "rh", "rar", "bug", "count", "fr", "type", "addr", "dr", "dy", "cb", "offset", "ner", "order", "arr", "der", "loc", "style", "go", "act", "magic", "reader", "try", "dev", " Err", "fg", "data", "rage", "cache"], "read_count": ["read\u00b7count", "read___size", "readedcount", "read\u00b7len", "reader_len", "read\u00b732", "readed32", " read_size", "readaccounter", "reader_total", "readeralrange", "readerlsize", "readerabletotal", "readeralcounter", "read64count", "reader_range", "read6total", "reader_width", "reader_size", "read_limit", "readalrange", "read_32", "read_size", "readacnum", "readerlen", "write_len", "readeralcount", "readlrange", "write_count", "read_max", "readerablecount", "read_width", "readerlcount", "readerablewidth", "readalcounter", "write_32", "readlcounter", "readercount", "read6width", "reader_counter", "readerlrange", " read_length", "read_cost", "readalcount", "readlcount", "read6count", "readalnum", "readlsize", "read_counter", "readablecount", "read_num", "read___cost", "readerwidth", "readertotal", "read_path", "readerablelen", "readeralnum", "readaccount", "read_length", "read___count", "reader_count", "read_number", "readacsize", "readablelen", "read64limit", "read_group", "readlnum", " read_number", "readacrange", "readacnumber", "read6len", " read_cost", "read64group", "read_len", " read_group", " read_max", "read_total", "read_range", "reader_num", "readablewidth", "readabletotal", " read_path", " read_limit", "readedlen"], "xattr_len": ["xattr__num", "xattr_length", "xattr_val", "xrr__len", "xrr__num", "xrr_Len", "xattr2len", "xattr2count", "xattr__Len", "xatt_val", "xrr__length", "xattr_count", "xrr_num", "xatt_Len", "xattr__length", "xrr_len", "xatt_count", "xattr2val", "xattr__len", "xatt_len", "xattr_Len", "xrr__Len", "xattribute_Len", "xattribute_len", "xattribute_val", "xattr2Len", "xrr_length", "xattr_num"], "v": ["g", "version", "f", "service", "k", "vt", "state", "c", "i", "sv", "d", "p", "b", "fs", "j", "vd", "uv", "env", "lv", "vm", "vert", "o", "t", "l", "V", "u", "vp", "w", "m", "e", "n", "ve", "vs", "volt"], "elem": ["belev", "beaser", "selee", "meject", "elee", "pelement", "peler", "eelem", "elelee", "elelement", " eler", "selem", "eeler", "easer", "pelem", "eleject", "selement", " element", " elements", "elements", "melem", " easer", "eelement", "eelev", "eeaser", "belem", "elev", "melee", "pelements", "eelements", "seject", "eject", "belement", "eler", " elev", "elelem", "element", "melement"]}}
{"project": "qemu", "commit_id": "cdeaf1f15909e2e8af38f45aea7cfa467a729c52", "target": 1, "func": "static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,\n\n                                      const uint8_t *buf, int nb_sectors)\n\n{\n\n    int ret;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = vmdk_write(bs, sector_num, buf, nb_sectors);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    return ret;\n\n}\n", "idx": 11334, "substitutes": {"bs": ["bos", "os", "bis", "cs", "ls", "ss", "bc", "BS", "pb", "lb", "sb", "bl", "es", "iss", "ds", "b", "bes", "fs", "fb", "blocks", "bh", "gb", "ns", "css", "us", "bi", "ps", "ses", "as", "base", "ubs", "las", "bas", "lbs", "obs", "sa", "js", "bid", "vs", "ba"], "sector_num": [" sector_name", "sector_fn", "sectorIdcount", " sector_count", "sector_count", " sector_number", "sector_number", "sectorIdfn", "sectorIdnum", "sectoridfn", "sector_nom", " sector_nom", "sectoridcount", " sector_fn", "sectorIdnumber", "sectoridnum", "sector_name", "sectoridnumber"], "buf": ["block", "ctx", "pool", "src", "vec", "ref", "ff", "fi", "result", "bc", "bag", "seq", "pb", "bytes", "cb", "loc", "b", "fb", "queue", "rb", "array", "fp", "v", "cv", "num", "alloc", "Buffer", "uf", "buff", "buffer", "port", "fd", "batch", "bf", "data"], "nb_sectors": ["nb_speitors", "nb_pecs", "nb_secars", "nb_secctors", "nb_vegments", "nb_suctors", "nb_specs", "nb_sucs", "nb_vecs", "nb_surcs", "nb_seccs", "nb_peitors", "nb_seitors", "nb_severs", "nb_suvers", "nb_surars", "nb_veitors", "nb_suars", "nb_spectors", "nb_segments", "nb_spegments", "nb_pectors", "nb_sears", "nb_secs", "nb_surctors", "nb_secvers", "nb_pegments", "nb_vectors", "nb_survers"], "ret": ["pass", "rt", "f", "rets", "id", "match", "att", "re", "RET", "final", "ref", "rev", "fi", "ft", "result", "len", "en", "art", "ben", " Ret", "cat", "back", "fun", "j", "flag", "bit", "code", "tmp", "num", "val", "det", "arg", "reply", "pat", "obj", "info", "base", "nt", "res", "reg", "fin", "alt", "Ret", "bf", "data", "py", "x"], "s": ["server", "g", "sym", "f", "args", "site", "service", "cs", "ss", "side", "sq", "c", "is", "d", "h", "p", "ts", "si", "iss", "S", "ds", "b", "session", "fs", "ssl", "settings", "j", "sl", "ns", "o", "r", "t", "ps", "opt", "ses", "l", "sync", "gs", "w", "conf", "e", "n", "sys", "rs", "sa", "js"]}}
{"project": "qemu", "commit_id": "968fc24d843c9e9b24231ca1960b47ef2fc724ea", "target": 1, "func": "int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen,\n\n                         uint8_t *dst, int dlen)\n\n{\n\n    uint32_t zrun_len = 0, nzrun_len = 0;\n\n    int d = 0, i = 0;\n\n    long res, xor;\n\n    uint8_t *nzrun_start = NULL;\n\n\n\n    g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) %\n\n               sizeof(long)));\n\n\n\n    while (i < slen) {\n\n        /* overflow */\n\n        if (d + 2 > dlen) {\n\n            return -1;\n\n        }\n\n\n\n        /* not aligned to sizeof(long) */\n\n        res = (slen - i) % sizeof(long);\n\n        while (res && old_buf[i] == new_buf[i]) {\n\n            zrun_len++;\n\n            i++;\n\n            res--;\n\n        }\n\n\n\n        /* word at a time for speed */\n\n        if (!res) {\n\n            while (i < slen &&\n\n                   (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) {\n\n                i += sizeof(long);\n\n                zrun_len += sizeof(long);\n\n            }\n\n\n\n            /* go over the rest */\n\n            while (i < slen && old_buf[i] == new_buf[i]) {\n\n                zrun_len++;\n\n                i++;\n\n            }\n\n        }\n\n\n\n        /* buffer unchanged */\n\n        if (zrun_len == slen) {\n\n            return 0;\n\n        }\n\n\n\n        /* skip last zero run */\n\n        if (i == slen) {\n\n            return d;\n\n        }\n\n\n\n        d += uleb128_encode_small(dst + d, zrun_len);\n\n\n\n        zrun_len = 0;\n\n        nzrun_start = new_buf + i;\n\n\n\n        /* overflow */\n\n        if (d + 2 > dlen) {\n\n            return -1;\n\n        }\n\n        /* not aligned to sizeof(long) */\n\n        res = (slen - i) % sizeof(long);\n\n        while (res && old_buf[i] != new_buf[i]) {\n\n            i++;\n\n            nzrun_len++;\n\n            res--;\n\n        }\n\n\n\n        /* word at a time for speed, use of 32-bit long okay */\n\n        if (!res) {\n\n            /* truncation to 32-bit long okay */\n\n            long mask = (long)0x0101010101010101ULL;\n\n            while (i < slen) {\n\n                xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i);\n\n                if ((xor - mask) & ~xor & (mask << 7)) {\n\n                    /* found the end of an nzrun within the current long */\n\n                    while (old_buf[i] != new_buf[i]) {\n\n                        nzrun_len++;\n\n                        i++;\n\n                    }\n\n                    break;\n\n                } else {\n\n                    i += sizeof(long);\n\n                    nzrun_len += sizeof(long);\n\n                }\n\n            }\n\n        }\n\n\n\n        d += uleb128_encode_small(dst + d, nzrun_len);\n\n        /* overflow */\n\n        if (d + nzrun_len > dlen) {\n\n            return -1;\n\n        }\n\n        memcpy(dst + d, nzrun_start, nzrun_len);\n\n        d += nzrun_len;\n\n        nzrun_len = 0;\n\n    }\n\n\n\n    return d;\n\n}\n", "idx": 11359, "substitutes": {"old_buf": ["oldfbuffer", "byte", "new_queue", "old67socket", "oldqbuff", "b", "old_uf", "oldfbox", "oldqbuf", "new_box", "old_uc", "new_buffer", "oldfbuf", "old_band", "id", "old__buffer", "new_fab", "new_uc", "oldfbuff", "old_box", "old_queue", "s", "new_socket", "old8uc", "oldqband", "old__buff", "new_buff", "old67uf", "old_socket", "old8buff", "add", "old_buff", "r", "new_uf", "_", "old8buffer", "g", "old67buf", "old8buf", "oldqbuffer", "old_fab", "old67queue", "old__queue", "old__buf", "old_buffer", "new_band"], "new_buf": ["old_fb", "new_cv", "new_fd", "new_queue", "old_cb", "new_fat", "new_head", "old_uf", "old_head", "new5buffer", "newJbuffer", "new5buf", "old_fat", "new__fd", "old_cv", "new_buffer", "new_font", "newalbuff", "newJbuff", "new__uf", "newalbuf", "new__buf", "newalcv", "newAllfb", "newAllbuf", "new__buffer", "old_queue", "new5buff", "newJbus", "new_buff", "old_bus", "new__queue", "old_font", "old_buff", "newJbuf", "new_uf", "new_bus", "newAllbuff", "old_fd", "new_fb", "newAllqueue", "new_cb", "new5font", "newalhead", "old_buffer", "new__buff"], "slen": ["glenc", "pleng", " slenn", "llen", "shen", "hleni", "sslense", "slon", "shien", "llang", "slend", "plen", " slend", "llens", "slens", "glen", "gloren", "slig", "dllen", "sheni", "llien", "islense", "sslien", "plun", "slenc", "plang", "shened", "sleng", " slatten", " slened", "slenn", "selens", "lloren", "plenn", "islenn", " sleni", "blien", "plien", "hlen", "sellen", "plan", "slah", "hlien", "blenn", "slened", "selien", "dlun", "llun", "bleng", "selen", "llatten", "lleng", "glens", "selun", " slenum", "slun", "hlened", " sllen", "plenum", "plon", "sloren", " slig", "sslen", " slense", "llenc", "islon", "islun", " slan", "slien", " slah", "slan", "islig", "sslenn", "llenn", "sslang", "sslun", " slens", "clen", "clah", "islens", "clun", "selenn", "clan", "sslatten", "plend", "blen", "plah", "slatten", "islen", "islenum", " slon", "slense", "sleni", "sllen", " sloren", " slenc", "islend", " slun", "selig", "slang", "slenum", " slien", "dlien"], "dst": ["fstal", "dsc", "sdstal", "nsc", "fst", "sdST", " drc", "nstal", "nST", "idsrc", "sdsc", "sdst", "inrc", "idst", "dstal", "dsrc", "idrc", "drc", "inbl", "fST", " dsrc", "dST", "dbl", " dbl", "insrc", "inst", "fsc", "idbl", "nst"], "dlen": ["idLen", "qlen", "rdlen", "dLen", "udLen", "dlon", "idlen", "qlog", "xlen", "qlimit", "dlength", "xLen", " dlin", " dlon", "udlin", " dlength", "qLen", "xlength", "dysl", "rdlon", " dlog", "dval", "dyval", "dylon", "dylen", "idlog", " dlimit", " dLen", "udlen", "dlimit", "idlimit", "dlog", "dsl", "rdsl", "rdval", "dlin", " dval", "udlength", " dsl", "xlin"], "res": ["re", "vals", "err", "cs", "ids", "min", " Res", "mr", "rc", "reset", "response", "runs", "red", "pre", "pres", "css", "press", "rep", "Res", "rec", "gr", "ros", "rs", "js", "ares", "os", "rys", "rets", "id", "rev", "resolution", "result", "RES", "rows", "params", "rss", "rem", "reed", "j", "ris", "ms", "ras", "ret", "error", "ress", "reg", "script", "resp", "rez", "des", "details", "r", "ps", "req", "errors", "rh", "cons", "rar", "resh", "x", "rus", "args", "final", "ons", "results", "nos", "sol", "def", "func", "bits", "rest", "data"], "xor": ["xors", "Xori", "factors", "rxop", "txor", " xop", "Xore", "xod", "xore", "yor", "factnor", "xori", "XOR", "rxors", "rxnor", "xop", " xori", "exod", "factor", "rxor", " xOR", "xnor", "yOR", " xore", "Xor", "rxOR", "yori", "exore", "exor", " xors", "txOR", "rxore", "factop", "Xors", "xOR", " xod", "txod", " xnor", "exOR", "txore", "yors"], "nzrun_start": ["nzrun__start", "nzrunMstart", "nzRun_max", "nzRun_type", "nzRun_offset", "nzrun1len", "nzrun__len", "nzRun_space", "nzrunMspace", "nzrunMmax", "nzrun1max", "nzrun_max", "nzrun__offset", "nzrun_space", "nzRun_start", "nzrun__type", "nzrun_type", "nzrunMlen", "nzrun_offset", "nzrun1space", "nzRun_len", "nzrun1start"], "i": ["ii", "g", "ni", "li", "uri", "hi", "block", "f", "id", "phi", "I", "iv", "api", "err", "ip", "oi", "mi", "fi", "y", "c", "yi", "iu", "ini", "ei", "is", "d", "multi", "h", "ri", "p", "slice", "si", "isi", "anti", "b", "pi", "io", "j", "ori", "gi", "ie", "z", "ti", "zi", "di", "xi", "v", "qi", "ind", "ui", "bi", "o", "source", "t", "l", "ci", "u", "index", "start", "m", "e", "n", "info", "ai", "s", "eni", "mini", "name", "vi", "in", "x", "ix", "it"], "zrun_len": ["zunslen", "zrunsel", "zrun__el", "zun_lon", "zrun_val", "zrunslon", "zrun__val", "zrun__len", "zrun7limit", "zrun6fail", "zupdate_limit", "zRun_num", "zupdate7num", "zupdate_len", "zrun__limit", "zrun_Len", "zrun_line", "zrun2len", "zrun_lon", "zcall6len", "zrun6len", "zun_len", "zrun__line", "zrun6pos", "zcall6fin", "zupdate7line", "zrun__lon", "zrunner_len", "zrun6fin", "zrun__fail", "zrun_fail", "zrunner_Len", "zrunner_val", "zun_pos", "zrun2el", "zrunning_Len", "zrunspos", "zrun_limit", "zrunning_l", "zrun7len", "zrun7line", "zunspos", "zunslon", "zRun_val", "zrun7num", "zrun__pos", "zrunner_l", "zcall_fail", "zrunning_el", "zupdate_num", "zrun__num", "zupdate7len", "zunsel", "zRun_pos", "zupdate7limit", "zupdate_line", "zRun_len", "zrun_fin", "zcall6fail", "zrunning_len", "zrun_num", "zrun_el", "zcall_len", "zrunslen", "zcall_fin", "zrun2l", "zrun2Len", "zcall_pos", "zrun_pos", "zun_el", "zrun_l", "zcall6pos", "zrun__fin"], "nzrun_len": ["nzru_fin", "zrun2len", "zrun__l", "zrunning_l", "nzru_start", "zrunning_len", "zrunning2len", "nzrun_fin", "zrun2pos", "zrunning2lf", "zrun__lf", "zrun__pos", "nzru_Len", "zrun2l", "zrunning_pos", "zrun__len", "zrun_pos", "nzrun_Len", "zrunning2pos", "zrun_l", "nzru_len", "zrunning2l", "zrun_lf", "zrun2lf", "zrunning_lf"]}}
{"project": "FFmpeg", "commit_id": "a28cccf6d62dc770757491510c248ed632a836ce", "target": 1, "func": "static av_cold void init_atrac3_transforms(ATRAC3Context *q) {\n\n    float enc_window[256];\n\n    int i;\n\n\n\n    /* Generate the mdct window, for details see\n\n     * http://wiki.multimedia.cx/index.php?title=RealAudio_atrc#Windows */\n\n    for (i=0 ; i<256; i++)\n\n        enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;\n\n\n\n    if (!mdct_window[0])\n\n        for (i=0 ; i<256; i++) {\n\n            mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]);\n\n            mdct_window[511-i] = mdct_window[i];\n\n        }\n\n\n\n    /* Initialize the MDCT transform. */\n\n    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);\n\n}\n", "idx": 11361, "substitutes": {"q": ["g", "text", "iq", "f", "k", "sq", "c", "quad", "qt", "p", "cb", "qa", "queue", "dq", "context", "question", "Q", "qi", "req", "qs", "lib", "w", "query", "qu", "e", "qq", "py"], "enc_window": ["dec_flow", "Enc_stream", "enc_box", "dec_windows", "enc67window", "Enc_container", "enc67windows", "Enc_frame", "enc2win", "dec_win", "enc67flow", "enc2windows", "dec_box", "enc_windows", "enc2box", "enc2window", "enc_stream", "enc_win", "enc_container", "enc_flow", "dec_window", "Enc_win", "Enc_windows", "Enc_window", "enc_frame", "enc67win"], "i": ["ii", "g", "ni", "abi", "li", "uri", "f", "id", "phi", "I", "k", "api", "ip", "oi", "mi", "fi", "adi", "y", "c", "yi", "ki", "iu", "ini", "ei", "d", "a", "multi", "ji", "p", "ri", "si", "z", "anti", "b", "pi", "io", "j", "gi", "ie", "cli", "di", "ti", "xi", "bi", "zi", "v", "qi", "o", "ui", "t", "l", "ci", "u", "index", "w", "m", "e", "n", "info", "ai", "s", "eni", "x", "ix", "it"]}}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void gd_resize(DisplayChangeListener *dcl,\n\n                      DisplayState *ds)\n\n{\n\n    GtkDisplayState *s = ds->opaque;\n\n    cairo_format_t kind;\n\n    int stride;\n\n\n\n    DPRINTF(\"resize(width=%d, height=%d)\\n\",\n\n            ds_get_width(ds), ds_get_height(ds));\n\n\n\n    if (s->surface) {\n\n        cairo_surface_destroy(s->surface);\n\n    }\n\n\n\n    switch (ds->surface->pf.bits_per_pixel) {\n\n    case 8:\n\n        kind = CAIRO_FORMAT_A8;\n\n        break;\n\n    case 16:\n\n        kind = CAIRO_FORMAT_RGB16_565;\n\n        break;\n\n    case 32:\n\n        kind = CAIRO_FORMAT_RGB24;\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n        break;\n\n    }\n\n\n\n    stride = cairo_format_stride_for_width(kind, ds_get_width(ds));\n\n    g_assert(ds_get_linesize(ds) == stride);\n\n\n\n    s->surface = cairo_image_surface_create_for_data(ds_get_data(ds),\n\n                                                     kind,\n\n                                                     ds_get_width(ds),\n\n                                                     ds_get_height(ds),\n\n                                                     ds_get_linesize(ds));\n\n\n\n    if (!s->full_screen) {\n\n        GtkRequisition req;\n\n        double sx, sy;\n\n\n\n        if (s->free_scale) {\n\n            sx = s->scale_x;\n\n            sy = s->scale_y;\n\n\n\n            s->scale_y = 1.0;\n\n            s->scale_x = 1.0;\n\n        } else {\n\n            sx = 1.0;\n\n            sy = 1.0;\n\n        }\n\n\n\n        gtk_widget_set_size_request(s->drawing_area,\n\n                                    ds_get_width(ds) * s->scale_x,\n\n                                    ds_get_height(ds) * s->scale_y);\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n        gtk_widget_get_preferred_size(s->vbox, NULL, &req);\n\n#else\n\n        gtk_widget_size_request(s->vbox, &req);\n\n#endif\n\n\n\n        gtk_window_resize(GTK_WINDOW(s->window),\n\n                          req.width * sx, req.height * sy);\n\n    }\n\n}\n", "idx": 11368, "substitutes": {"dcl": ["ddCl", "dCL", "dfl", " dfl", " dCl", "ddCL", "dCl", " dCL", "ddfl", "ddcl", "dsCl", "dscl", "dsCL", "dsfl"], "ds": ["dat", "os", "dds", "sd", "die", "parts", "did", "cdn", "uds", "cs", "ls", "del", "ss", "dom", "ys", "xs", "md", "db", "gd", "dist", "ks", "d", "dal", "pd", "dr", "des", "ts", "dos", "nas", "der", "DS", "session", "fs", "settings", "sem", "sts", "ld", "vd", "bs", "ns", "ads", "dc", "dd", "ms", "ans", "df", "da", "du", "ps", "ses", "Ds", "sync", "ded", "dx", "gs", "od", "dh", "dm", "sys", "rs", "js", "dl", "data", "dt", "vs"], "s": ["sym", "service", "cs", "self", "c", "a", "ks", "i", "d", "sv", "iss", "b", "sts", "hs", "gs", "as", "e", "rs", "js", "vs", "os", "site", "its", "ls", "ss", "sq", "ins", "params", "sb", "h", "S", "session", "fs", "ssl", "o", "ses", "qs", "f", "parts", "xs", "y", "services", "sg", "secondary", "sl", "bs", "r", "ps", "l", "sync", "u", "sys", "g", "args", "state", "states", "is", "new", "es", "p", "ts", "si", "sis", "ns", "spec", "us", "t", "your", "m", "conf", "n", "sets", "sa", "stats", "ops", "aws"], "kind": ["text", "die", "args", "type", "id", "mode", "mean", "path", "k", "ke", "actory", "class", "mid", "kid", "engine", "good", "depth", "instance", "concept", "method", "stroke", "draw", "Kind", "need", "xxx", "ck", "vid", "lit", "sid", "inner", "shape", "nd", "style", "ld", "context", "ie", "part", "ko", "impl", "kt", "kg", "code", "spec", "lang", "key", "parent", "ind", "std", "def", "brand", "start", "dev", "head", "desc", "gen", " kinds", "init", "child", "rank", "info", "nt", "name", "data", "feat", "cost", "str"], "stride": ["driding", "Striding", "striider", "trider", "triding", "drider", "dride", "drided", "Strided", " strider", "striiding", "tride", "Stride", "strided", " striding", " strided", "striding", "trided", "striide", "Strider", "brided", "strider", "striided", "brider", "bride", "briding"], "req": ["rw", "ctx", "ref", "err", "Requ", "ur", "ra", "seq", "ver", "a", "jp", "war", "sp", "rx", "q", "rec", "org", "gr", "query", "e", "js", "serv", " requirements", "sq", "dist", " requ", "ru", "rf", "sem", "j", "grad", " reg", "ret", "get", "conn", "ry", "wa", "progress", "qq", "reg", "res", "sec", "exec", "str", "ctr", "f", "resp", "compl", "pr", "cur", "urg", "app", "dq", "r", "lib", "crit", "util", "rr", "pull", "requ", "g", "fr", "request", "proc", "wx", "cmp", "qt", "tar", "p", "require", "spec", "client", " requisite", "conf", "tx", "iw", "cache"], "sx": ["sX", "ssxe", "Sy", "Spx", "sw", "sct", "spph", " smy", "sfx", "ppx", "SX", "dfx", "Sx", "smy", " sfx", "dy", " sxe", " spx", "ssw", " sph", "sxe", "px", "sph", "ssx", "ssy", "pX", "ssct", "ssph", "dw", " sX", "spxe", " sct", "spy", "dx", "ssfx", "spx", "py", "ssmy"], "sy": ["fy", "idy", "phy", "zy", "ey", "wy", "yy", "sym", "size", "Sy", "thin", "ky", "ny", "lat", "ys", "y", "asy", "sq", "len", "yn", "dy", "hy", "si", "ity", "sat", "cy", "gy", "fun", "Ty", "hi", "ay", "ch", "rx", "SY", "sky", "ady", "ry", "ty", "south", "lon", "sys", "sa", "py", "syn"]}}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)\n\n{\n\n    LM32JuartState *s = LM32_JUART(d);\n\n    unsigned char ch = jtx & 0xff;\n\n\n\n    trace_lm32_juart_set_jtx(s->jtx);\n\n\n\n    s->jtx = jtx;\n\n    if (s->chr) {\n\n\n\n        qemu_chr_fe_write_all(s->chr, &ch, 1);\n\n    }\n\n}", "idx": 11381, "substitutes": {"d": ["dat", "g", "sd", "f", "state", "self", "D", "md", "c", "gd", "i", "pd", "p", "ds", "b", "j", "ld", "z", "dc", "dd", "t", "o", "da", "r", "l", "u", "m", "dh", "dm", "e", "dj", "fd", "dl", "ad", "data", "dt", "cd"], "jtx": ["ojx", "jptm", "qtm", "djctx", "jx", "dtx", "ujtest", "jtxt", "jhea", "ojcf", "dta", "jptx", "jta", "ujx", " jhea", "jpx", "Jtx", "ujtx", "jphea", "jpcf", "jobtxt", "jptxt", " jx", "jpta", "jobta", "Jx", "Jhea", "qta", " jtest", "qtxt", "jobtx", "jtest", "jctx", "dtm", " jta", "djtxt", "ujta", "dtxt", "djtx", "jptest", "Jta", " jtxt", " jcf", "jobctx", "ojctx", "jpctx", "jtm", " jctx", "Jtest", "jcf", "qtx", "djta", "ojtx"], "s": ["g", "sym", "f", "service", "parts", "sw", "cs", "ls", "state", "self", "sf", "ss", "states", "xs", "sq", "c", "is", "i", "ks", "sv", "services", "sb", "es", "ts", "p", "si", "sh", "S", "session", "ds", "settings", "fs", "ssl", "b", "se", "sl", "ns", "hs", "spec", "o", "r", "ps", "ses", "l", "sync", "gs", "m", "south", "e", "sys", "sets", "su", "rs", "sa", "js", "stats", "ops"]}}
{"project": "FFmpeg", "commit_id": "3df2be9fa7365646f22a93cfde1e4097467f498e", "target": 1, "func": "static void matroska_fix_ass_packet(MatroskaDemuxContext *matroska,\n\n                                    AVPacket *pkt, uint64_t display_duration)\n\n{\n\n    char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size;\n\n    for (; *ptr!=',' && ptr<end-1; ptr++);\n\n    if (*ptr == ',')\n\n        layer = ++ptr;\n\n    for (; *ptr!=',' && ptr<end-1; ptr++);\n\n    if (*ptr == ',') {\n\n        int64_t end_pts = pkt->pts + display_duration;\n\n        int sc = matroska->time_scale * pkt->pts / 10000000;\n\n        int ec = matroska->time_scale * end_pts  / 10000000;\n\n        int sh, sm, ss, eh, em, es, len;\n\n        sh = sc/360000;  sc -= 360000*sh;\n\n        sm = sc/  6000;  sc -=   6000*sm;\n\n        ss = sc/   100;  sc -=    100*ss;\n\n        eh = ec/360000;  ec -= 360000*eh;\n\n        em = ec/  6000;  ec -=   6000*em;\n\n        es = ec/   100;  ec -=    100*es;\n\n        *ptr++ = '\\0';\n\n        len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE;\n\n        if (!(line = av_malloc(len)))\n\n            return;\n\n        snprintf(line,len,\"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s\",\n\n                 layer, sh, sm, ss, sc, eh, em, es, ec, ptr);\n\n        av_free(pkt->data);\n\n        pkt->data = line;\n\n        pkt->size = strlen(line);\n\n    }\n\n}\n", "idx": 11383, "substitutes": {"matroska": ["matrisla", "mrisku", "matroki", "Matriska", "mroska", "matronsku", "matrsla", "matrisku", "Matrisla", "matrska", "macroska", "mrosku", "macroki", "matriskee", "matronski", "Matroski", "matrola", "macroku", "matriski", "matroski", "mriski", "matrokee", "Matroska", "matronska", "matrsku", "matroneskee", "Matriski", "matrosku", "macrosku", "Matriskee", "macrola", "matrski", "macrosla", "Matroskee", "mrisla", "mriska", "matroskee", "matronesla", "matroneski", "matriska", "matrosla", "matroku", "Matrosla", "mroski", "matroneska", "macroski", "matronsla", "mrosla", "matroka", "macroka"], "pkt": [" packet", "mkg", "peter", "facket", "pct", "tpct", "Punt", "Pct", "packet", "opacket", "apkt", "mkt", "macket", "melt", "opkg", "fkt", "opnt", "Pkg", "npqt", "pait", "Pkt", "apeter", "npet", "apunt", "Pqt", " pqt", "Packet", "npkt", "feter", "apkg", " punt", "pkg", "jpnt", "opeter", "jpkt", " pct", "apacket", "tpkt", " pkg", "npacket", "Pet", "Pnt", "opelt", "tpacket", "pelt", "pnt", "fet", "pet", " pnt", "Pait", " pet", "apnt", " pait", "fnt", "fkg", "pqt", "punt", "opkt", "tpqt", "jpait", "jpacket", "Pelt"], "display_duration": ["displayartduration", "time_duration", "timeationlength", "displayationduration", "display_policy", "report_version", "displayationDuration", "display_component", "displayartpolicy", "displayartcost", "time_length", "display_version", "time_component", "time_Duration", "report_duration", "display_cost", "timeationduration", "timeationDuration", "displayationcomponent", "report_policy", "timeationcomponent", "displayationlength", "report_cost", "display_length", "display_Duration", "displayartversion"], "line": ["pos", "li", "LINE", "block", "parse", "pass", "file", "limit", "zip", "ine", "byte", "lined", "db", "pin", "lp", "el", "offset", "lines", "loc", "liner", "cell", "le", "frame", "url", "nl", "part", "code", "pe", "record", "row", "entry", "Line", "lin", "length", "level", "header", "link", "l", "source", "val", "error", "point", "item", "word", "buffer", "base", "unit", "e", "lc", "out", "name", "page", "data", "lf", "number", "slice"], "layer": ["la", "ctx", "file", "ll", "src", "device", "wk", "byte", "addr", "bc", "patch", "lp", "Layer", "lr", "offset", "loc", "seed", "fl", "queue", "url", "pair", "wl", "position", "sl", "kl", "address", "coll", "pe", "phase", "parent", "lv", "header", "channel", "level", "length", "cl", "l", "lay", "hl", "stack", "nn", "buffer", "lf", "base", "lc", "lvl", "data", "depth", "slice"], "ptr": ["sth", "src", "mount", "file", "ref", "err", "seq", "fe", "lr", "address", "time", "peer", "pad", "desc", "inst", "depth", "coord", "pointer", "Ptr", "id", "eger", "dist", "iter", "stage", "ep", "pair", "vr", "pt", "code", "pe", "fp", "header", "length", "attr", "dim", "port", "str", "tr", "shift", "ctr", "diff", "pl", "transfer", "patch", "pr", "cur", "rd", "step", "part", "trace", "prot", "push", "br", "req", "start", "leg", "pull", "pos", "ect", "proc", "ft", "addr", "pend", "dr", "tip", "p", "offset", "loc", "url", "ext", "enter", "entry", "pert", "buffer", "fd", "data", "slice"], "end": ["pos", "append", "size", "id", "max", "edge", "ended", "mid", "pend", "en", "event", "enc", "after", "p", "END", "ent", "ep", "End", "use", "nd", "ending", "enter", "est", "begin", "in", "add", "z", "push", "ind", "length", "all", "start", "index", "head", "pad", "last", "e", "n", "set", "sec", "ad", "send", "stop", "tail", "x", "post"], "sh": [" ssh", "ph", "osh", "hw", "size", "ctx", "src", "sw", "cs", "ff", "esh", "how", "sq", " sc", "en", " square", "Sh", "small", "h", "SH", " size", "ity", "loc", "ish", "cp", "zh", "ssh", "ship", "se", "sl", "ize", " sl", "ch", "ksh", "ush", "cl", "ih", "l", "sc", "hl", "wh", "qu", "sk", "hel", "sea", "sch"], "sm": ["ph", "scl", "sam", "size", "ess", "sw", "cs", "md", "sq", "en", "sr", "sv", "h", "sci", "si", "sp", "sem", "loc", "cp", "ism", "spe", "se", "sl", "sim", "spec", "ms", "me", "mem", "sy", "ch", "css", "cl", "sc", "ym", "sum", "m", "sn", "wh", "mm", "su", "sk", "s", "sea", "hem", "sch", "hm"], "ss": ["SS", "ph", "ess", "ese", "sw", "cs", "ys", "seq", "sq", "en", "ks", "ems", "sr", "sv", "rss", "h", "si", "sp", "sem", "iss", "ds", "settings", "ssl", "ah", "ssh", "se", "sl", "ns", "spec", "pe", "css", "me", "us", "ans", "ush", "ms", "ps", "uss", "ses", "sc", "sn", "e", "su", "rs", "ec", "s", "ens", "vs", "sch"], "eh": ["ph", "eah", "ess", "ctx", "ear", "ect", "eng", "eth", "exc", "oh", "esh", "mes", "kn", "eff", "en", "ems", "ex", "eb", "hed", "arch", "esc", "ev", "enc", "h", "ep", "sem", "ah", "env", "se", "est", "pe", "me", "ch", "el", "ih", "ach", "he", "esi", "hl", "emp", "oe", "ek", "tx", "e", "er", "ec", "eas", "ens", "ef", "kh", "sch"], "em": ["emin", "ema", "ph", "im", "ess", "pm", "sw", "eng", "x", "mes", "Em", "emi", "eff", "eg", "en", "ems", "ex", "eb", "ae", "eu", "ees", "emer", "ev", "ell", "sem", "cm", "sl", "est", "ee", "mem", "me", "el", "time", "ach", "cel", "emp", "m", "ek", "om", "mm", "e", "lem", "er", "ec", "eme", "hem"], "es": ["eps", "ess", "ese", "cs", "ls", "xes", "ES", "eng", "Es", "hes", "eks", "mes", "ys", "en", "ems", "ees", "ex", "ae", "esc", "ed", "vs", "ep", "lines", " ec", "ices", "se", "est", "ee", "el", "ps", "ses", "qs", "ets", "esi", "oe", "els", "ek", "lems", "e", "pes", "ec", "s", "ces", "ens", "ef", "x", "esp"], "len": ["la", "pos", "fen", "li", "size", "ll", "limit", "elt", "min", "seq", "lt", "en", "den", "bl", "lp", "dy", "offset", "ell", "sp", "loc", "Len", "le", "fl", "lim", "ler", "ld", "part", "sl", "zi", "lin", "length", "el", "val", "count", "l", "cel", "lib", "start", "base", "n", "lon", "ln", "lan", "lc", "fin", "dl", "data", "lf", "ix"]}}
{"project": "qemu", "commit_id": "2a0c46da967e5dc8cfe73b1b6fe7a1600c04f461", "target": 0, "func": "send_msg(\n\n    VSCMsgType type,\n\n    uint32_t reader_id,\n\n    const void *msg,\n\n    unsigned int length\n\n) {\n\n    VSCMsgHeader mhHeader;\n\n\n\n    qemu_mutex_lock(&socket_to_send_lock);\n\n\n\n    if (verbose > 10) {\n\n        printf(\"sending type=%d id=%u, len =%u (0x%x)\\n\",\n\n               type, reader_id, length, length);\n\n    }\n\n\n\n    mhHeader.type = htonl(type);\n\n    mhHeader.reader_id = 0;\n\n    mhHeader.length = htonl(length);\n\n    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));\n\n    g_byte_array_append(socket_to_send, (guint8 *)msg, length);\n\n    g_idle_add(socket_prepare_sending, NULL);\n\n\n\n    qemu_mutex_unlock(&socket_to_send_lock);\n\n\n\n    return 0;\n\n}\n", "idx": 11400, "substitutes": {"type": ["action", "version", "message", "prefix", "block", "size", "id", "format", "mode", "comment", "state", "typ", "class", "connection", "method", "config", "p", "Type", "total", "year", "shape", "style", "test", "position", "family", "TYPE", "part", "key", "address", "code", "pe", "parent", "client", "copy", "header", "length", "t", "time", "kind", "error", "level", "count", "channel", "source", "index", "ty", "lock", "e", "unit", "info", "base", "value", "port", "month", "ype", "name", "status", "ping", "data", "types"], "reader_id": ["readeracid", "readerusername", "reader__ids", " reader_root", "readeruserid", "readeruserroot", "reader__id", "writer_id", "writer_name", "readeracsize", " reader_name", "reader__name", "reader__size", "reader_name", "reader_root", "writer_ids", "readeracname", "readerusertype", "reader_type", "writer_type", "readeracids", "reader_ids", "writer_size", "reader_size", " reader_type"], "msg": ["g", "message", "pub", "size", "args", "id", "sent", "buf", "gram", "result", "addr", "md", "seq", "len", "mess", "game", "comm", "Msg", "enc", "pkg", "queue", "frame", "gen", "doc", "lang", "op", "ms", "length", "cmd", "word", "command", "req", "gs", "m", "body", "obj", "name", "mail", "send", "data"], "mhHeader": ["mhlheader", "mbhWriter", "mhlBuffer", " mchWriter", "mhrConn", " mghBuffer", "mphReader", "mghheader", "meshheader", "mghServer", "mahServer", "MwHeader", "mvHead", " mchHead", "mhClient", "mrhHead", "MwHead", "mahHeader", "mhConn", "MhHead", "meshLast", " mghLast", " mhLast", "mghClient", "mbhHeader", "mwHead", "meshWriter", " mphHeader", " mhClient", "methHeader", "mphHeader", " mchHeader", "mhrReader", "meshPart", "mchBuffer", "mhrWriter", " mhConn", "mwServer", " mphClient", " mghheader", "mbhConn", " mhrWriter", "mhlHeader", " mchBuffer", "mhReader", "mhrHeader", " mhPart", "methBuffer", "methWriter", "mchWriter", " mvWriter", "mchHeader", " mhrHeader", "mwHeader", "mhServer", "mwWriter", " mhrConn", "mhWriter", " mhheader", "meshHeader", " mvPart", "MwClient", " mghHeader", "MhHeader", "mhrheader", "meshHead", "mhLast", "mhHead", "mvPart", "mhPart", "mphClient", "mghHead", "mghHeader", "methHead", "mghConn", "mghBuffer", "mbhPart", "mrhClient", " mphReader", "mwClient", "mahClient", " mhReader", "MhServer", "mghWriter", "mchHead", "mbhHead", "mahHead", " mvHead", "mghLast", "mbhheader", "mphHead", " mphHead", "mhrClient", "mhheader", "MhClient", " mhBuffer", "meshBuffer", "mvHeader", "mrhReader", "mhrHead", "mrhHeader", "mhlLast", " mhWriter", " mvHeader", "mvWriter", " mhHead", "mwBuffer", "mhBuffer", " mhrheader", "MwServer"]}}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){\n\n    int i, j;\n\n    int dc = (((dctcoef*)block)[0] + 32) >> 6;\n\n    pixel *dst = (pixel*)_dst;\n\n    stride >>= sizeof(pixel)-1;\n\n    for( j = 0; j < 4; j++ )\n\n    {\n\n        for( i = 0; i < 4; i++ )\n\n            dst[i] = av_clip_pixel( dst[i] + dc );\n\n        dst += stride;\n\n    }\n\n}\n", "idx": 11423, "substitutes": {"_dst": ["_dconst", "_Dst", "_dset", " _adst", " _dconst", "_idST", "_dsts", " _dost", " _dsts", " _dST", "_fost", "_adST", " _Dost", "_Dsts", "_Dost", " _Dconst", " _dset", " _adput", " _Dst", "_lset", "_lst", "_Dconst", "_fst", " _adST", "_adset", "_fconst", "_idput", "_adput", "_lput", "_adst", " _dput", "_idset", "_dost", "_idst", "_dput", "_dST", " _adset", "_fsts", " _Dsts", "_lST"], "block": ["padding", "chain", "clean", "type", "device", "comment", "ip", "Block", "pixel", "label", "bl", "enc", "clock", "blocks", "frame", "bit", "end", "record", "image", "row", "num", "layer", "header", "channel", "bin", "cl", "word", "mask", "sync", "disk", "buffer", "lock", "unit", "name", "batch", "page", "none", "line"], "stride": ["strade", "incride", " strade", "trider", "trive", "trip", "decider", " strip", "incider", "slide", "strride", "stider", "decision", "slone", "strone", "brone", " strride", " strider", "decride", "tride", "strive", "incide", "stide", " strision", "strided", "brade", "slade", " strided", " strive", "stip", "decide", " strone", "incision", "stive", "strip", "slided", "brided", "strider", "strision", "bride"], "i": ["ii", "ni", "li", "uri", "f", "phi", "I", "k", "mu", "ip", "oi", "mi", "fi", "c", "iu", "a", "ini", "jp", "d", "h", "ji", "p", "ri", "si", "z", "b", "pi", "io", "uli", "gi", "di", "v", "zi", "bi", "xi", "ti", "qi", "o", "ui", "r", "l", "ci", "u", "disk", "m", "e", "n", "init", "info", "ai", "x", "ix", "it"], "j": ["ii", "g", "li", "f", "I", "k", "jo", "y", "jit", "c", "uj", "is", "jp", "ja", "d", "ji", "p", "si", "b", "jl", "ie", "z", "v", "xi", "J", "o", "r", "ui", "qi", "jc", "l", "ci", "q", "u", "w", "m", "ij", "e", "n", "obj", "jj", "init", "dj", "js", "aj", "x", "it"], "dst": ["adsp", "dsc", "Dste", " dsp", "dest", "dedstream", "Dst", " dest", "dedst", "dste", "idsc", "idsts", "adstr", "ndest", "vdconst", "ndste", "dedsts", "vdst", "dstr", "adst", "Dest", "adconst", "adsts", "Dsts", " dsts", "dconst", "ndsts", "adstream", " dstr", " dste", "idste", "vdstr", " dstream", "dsp", "dbl", "dsts", "dedste", "dstream", " dconst", " dsc", " dbl", "ndst", "vdsp", "dedsc", "adbl", "idst", "dedbl"]}}
{"project": "FFmpeg", "commit_id": "2862b63783b5556f7f3fb2d097629bc6879f833a", "target": 0, "func": "static int encode_picture_ls(AVCodecContext *avctx, AVPacket *pkt,\n\n                             const AVFrame *pict, int *got_packet)\n\n{\n\n    const AVFrame *const p = pict;\n\n    const int near         = avctx->prediction_method;\n\n    PutBitContext pb, pb2;\n\n    GetBitContext gb;\n\n    uint8_t *buf2 = NULL;\n\n    uint8_t *zero = NULL;\n\n    uint8_t *cur  = NULL;\n\n    uint8_t *last = NULL;\n\n    JLSState *state;\n\n    int i, size, ret;\n\n    int comps;\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_GRAY8 ||\n\n        avctx->pix_fmt == AV_PIX_FMT_GRAY16)\n\n        comps = 1;\n\n    else\n\n        comps = 3;\n\n\n\n    if ((ret = ff_alloc_packet(pkt, avctx->width * avctx->height * comps * 4 +\n\n                               AV_INPUT_BUFFER_MIN_SIZE)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet.\\n\");\n\n        return ret;\n\n    }\n\n\n\n    buf2 = av_malloc(pkt->size);\n\n    if (!buf2)\n\n        goto memfail;\n\n\n\n    init_put_bits(&pb, pkt->data, pkt->size);\n\n    init_put_bits(&pb2, buf2, pkt->size);\n\n\n\n    /* write our own JPEG header, can't use mjpeg_picture_header */\n\n    put_marker(&pb, SOI);\n\n    put_marker(&pb, SOF48);\n\n    put_bits(&pb, 16, 8 + comps * 3); // header size depends on components\n\n    put_bits(&pb, 8, (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8);  // bpp\n\n    put_bits(&pb, 16, avctx->height);\n\n    put_bits(&pb, 16, avctx->width);\n\n    put_bits(&pb, 8, comps);          // components\n\n    for (i = 1; i <= comps; i++) {\n\n        put_bits(&pb, 8, i);     // component ID\n\n        put_bits(&pb, 8, 0x11);  // subsampling: none\n\n        put_bits(&pb, 8, 0);     // Tiq, used by JPEG-LS ext\n\n    }\n\n\n\n    put_marker(&pb, SOS);\n\n    put_bits(&pb, 16, 6 + comps * 2);\n\n    put_bits(&pb, 8, comps);\n\n    for (i = 1; i <= comps; i++) {\n\n        put_bits(&pb, 8, i);   // component ID\n\n        put_bits(&pb, 8, 0);   // mapping index: none\n\n    }\n\n    put_bits(&pb, 8, near);\n\n    put_bits(&pb, 8, (comps > 1) ? 1 : 0);  // interleaving: 0 - plane, 1 - line\n\n    put_bits(&pb, 8, 0);  // point transform: none\n\n\n\n    state = av_mallocz(sizeof(JLSState));\n\n    if (!state)\n\n        goto memfail;\n\n\n\n    /* initialize JPEG-LS state from JPEG parameters */\n\n    state->near = near;\n\n    state->bpp  = (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8;\n\n    ff_jpegls_reset_coding_parameters(state, 0);\n\n    ff_jpegls_init_state(state);\n\n\n\n    ls_store_lse(state, &pb);\n\n\n\n    zero = last = av_mallocz(p->linesize[0]);\n\n    if (!zero)\n\n        goto memfail;\n\n\n\n    cur  = p->data[0];\n\n    if (avctx->pix_fmt == AV_PIX_FMT_GRAY8) {\n\n        int t = 0;\n\n\n\n        for (i = 0; i < avctx->height; i++) {\n\n            ls_encode_line(state, &pb2, last, cur, t, avctx->width, 1, 0, 8);\n\n            t    = last[0];\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    } else if (avctx->pix_fmt == AV_PIX_FMT_GRAY16) {\n\n        int t = 0;\n\n\n\n        for (i = 0; i < avctx->height; i++) {\n\n            ls_encode_line(state, &pb2, last, cur, t, avctx->width, 1, 0, 16);\n\n            t    = *((uint16_t *)last);\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    } else if (avctx->pix_fmt == AV_PIX_FMT_RGB24) {\n\n        int j, width;\n\n        int Rc[3] = { 0, 0, 0 };\n\n\n\n        width = avctx->width * 3;\n\n        for (i = 0; i < avctx->height; i++) {\n\n            for (j = 0; j < 3; j++) {\n\n                ls_encode_line(state, &pb2, last + j, cur + j, Rc[j],\n\n                               width, 3, j, 8);\n\n                Rc[j] = last[j];\n\n            }\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    } else if (avctx->pix_fmt == AV_PIX_FMT_BGR24) {\n\n        int j, width;\n\n        int Rc[3] = { 0, 0, 0 };\n\n\n\n        width = avctx->width * 3;\n\n        for (i = 0; i < avctx->height; i++) {\n\n            for (j = 2; j >= 0; j--) {\n\n                ls_encode_line(state, &pb2, last + j, cur + j, Rc[j],\n\n                               width, 3, j, 8);\n\n                Rc[j] = last[j];\n\n            }\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    }\n\n\n\n    av_freep(&zero);\n\n    av_freep(&state);\n\n\n\n    /* the specification says that after doing 0xff escaping unused bits in\n\n     * the last byte must be set to 0, so just append 7 \"optional\" zero-bits\n\n     * to avoid special-casing. */\n\n    put_bits(&pb2, 7, 0);\n\n    size = put_bits_count(&pb2);\n\n    flush_put_bits(&pb2);\n\n    /* do escape coding */\n\n    init_get_bits(&gb, buf2, size);\n\n    size -= 7;\n\n    while (get_bits_count(&gb) < size) {\n\n        int v;\n\n        v = get_bits(&gb, 8);\n\n        put_bits(&pb, 8, v);\n\n        if (v == 0xFF) {\n\n            v = get_bits(&gb, 7);\n\n            put_bits(&pb, 8, v);\n\n        }\n\n    }\n\n    avpriv_align_put_bits(&pb);\n\n    av_freep(&buf2);\n\n\n\n    /* End of image */\n\n    put_marker(&pb, EOI);\n\n    flush_put_bits(&pb);\n\n\n\n    emms_c();\n\n\n\n    pkt->size   = put_bits_count(&pb) >> 3;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n    return 0;\n\n\n\nmemfail:\n\n    av_packet_unref(pkt);\n\n    av_freep(&buf2);\n\n    av_freep(&state);\n\n    av_freep(&zero);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 11427, "substitutes": {"avctx": ["navctx", "avconfig", "afcc", "avcontext", "evctx", "AVctx", "avconf", "avectx", "AVcca", "afconfig", "avcas", "navcontext", "avcf", "afkb", "navpkg", " avcc", "avecf", "AVpkg", "ajcontext", "afpkg", "AVconfig", "abcontext", "avcit", "afcas", "AVcc", "abconn", " avcontext", "avecu", "abkb", "AVcas", "avcu", "avkw", "afcca", "avpkg", "abctx", "afconf", "afcf", "afconn", "avekb", "ajctx", "afcit", "ajconf", " avconn", "avkb", "evcf", "AVconn", "evcu", "evcontext", "abconfig", "avecontext", "avcca", "navcas", "afcu", "AVcontext", "afcv", "aveconn", " avcit", "avcv", "avcc", "avconn", "ajcv", "afctx", "navconf", "navcv", "avecca", "navconn", "afkw", "AVcit", "navconfig", "afcontext", "AVkw", "navkw"], "pkt": ["backet", " packet", "mkg", "pctx", "facket", "pct", "Pwk", "pwk", "cpqt", "Pct", "packet", "fct", "bnt", "Pkit", " pwk", "mkt", "fkt", "macket", "Pkg", "Pkt", "mwk", "fctx", "Pqt", " pqt", "Packet", "cpkt", "pkg", "cpnt", "fwk", "cpct", " pct", " pkg", "Pnt", "Pet", "pkit", "pnt", "mctx", " pnt", "pet", " pet", "bkt", "cpacket", "fkg", "pqt", "bwk", " pctx", " pkit", "mkit", "cpet"], "pict": ["pit", "ctx", "shit", "bis", "gif", "cit", "pai", "apt", "buf", "fi", "proc", "png", "stat", "sit", "jp", "config", "sci", "qa", "pas", "paste", "lit", "Pic", "img", "fig", "pic", "piece", "Picture", "fat", "image", "phot", "Pict", "picture", "buff", "cam", "capt", "cot", "init", "obj", "photo", "sec", "quant", "pty", "mot", "feat"], "got_packet": ["got_rawpoint", "got_packacket", "got_rawacket", "got_pluget", "got_plugpoint", "got_compet", "got2compacket", "got_compacket", "got_packpoint", "got2packacket", "got2packset", "got_rawset", "got_packset", "got_compset", "got_comppoint", "got2compet", "got2packpoint", "got_plugacket", "got2comppoint", "got_plugset", "got2packet", "got2compset", "got_rawet"], "p": ["g", "prop", "np", "f", "pn", "pl", "c", "pc", "a", "jp", "d", "pd", "pkg", "b", "pi", "cp", "pt", "P", "fp", "o", "t", "l", "q", "m", "e", "n", "port", "py"], "pb": [" proto", "la", "plugin", "prop", "bos", "np", "bj", "pg", "ctx", "abc", "dp", " buf", "bm", "pm", "api", "buf", "ref", "repl", "pl", "proc", " eb", "nb", "bc", "rob", "bps", "db", "pc", "jp", "eb", "lb", " PB", "sb", "lp", "TB", "lab", "SB", "cb", "kb", "pkg", " pu", "b", "loc", "fb", "bh", "ub", "ld", "rb", "bs", "fp", "fc", "PF", "hub", "summary", "cv", "bb", "xb", "platform", "attr", "BP", "vp", "las", "pa", "ob", "lc", "wb", "bp", "py", "dl", "bf", "PB", "bot"], "pb2": ["PB2", "bp6", "pb1", "fb0", "bp0", "pbtwo", "bufall", "fb2", "pb6", "bptwo", "pb0", "bpall", "bp1", "cb1", "fball", "fb6", "PB5", "PB1", "pball", "cb2", "PBtwo", "bp5", "buf0", "buf6", "cbtwo", "bp2", "pb5", "cb5"], "gb": ["CC", " support", " conf", " parent", " co", " comp", "bc", " prog", "pc", " mc", " sc", " gcc", "rc", " cc", " lib", " con", " ec", " ch", " rc", "cc", " client", " cm", " conv", " ic", "CV", " acc", " bc", " call", " sim", "TC"], "buf2": ["uf0", "buffer2", "buf3", "buf8", " buf3", "buffer8", "buff1", " buf4", "cb1", "uf2", "buffer4", "cb4", "buf4", "cb2", "buff2", "uf1", "uf8", "buff8", " buf0", "buf1", " buf1", "cb0", "buff4", "buff3", "buffer1", "buf0", "uf4", "uf3"], "zero": ["version", "prefix", "empty", "comment", "final", "serial", "byte", "negative", "nil", "fee", "total", "missing", "scale", "entry", "num", "mask", "initial", "sc", "used", "one", "none", "bug", "extra"], "cur": ["ctr", "final", "prev", "rev", "mid", "inf", "result", "seq", "cmp", "rc", "cb", "loc", "pri", "uu", "pre", "code", "num", "ind", "req", "ci", "current", "random", "child", "info", "count", "sum"], "last": ["first", "latest", "empty", "final", "max", "prev", "th", "self", "rev", "Last", "low", "seq", "cycle", "worst", "str", "st", "total", "nd", "style", "end", "code", "sync", "next", "used", "desc", "pop", "cost", "cache"], "state": ["param", "type", "states", "STATE", "tag", "result", "media", "instance", "master", "config", "session", "scope", "style", "State", "code", "spec", "resource", "val", "conn", "start", "sync", "data", "port", "progress", "status", "statement", "cache"], "i": ["ii", "idi", "g", "ni", "abi", "li", "hi", "f", "type", "id", "phi", "I", "k", "mu", "ip", "oi", "mi", "fi", "ski", "chi", "y", "c", "ki", "iu", "ini", "udi", "d", "multi", "ri", "ji", "ani", "si", "b", "pi", "io", "inner", "uli", "gi", "ami", "cli", "z", "code", "in", "zi", "di", "xi", "ind", "r", "ui", "ti", "bi", "qi", "l", "ci", "start", "index", "e", "n", "info", "ai", "eni", "it"], "size": ["g", "sized", "pos", "SIZE", "general", "capacity", "empty", "sent", "len", "c", "small", "bytes", "offset", "content", "si", "sp", "loc", "sh", "gz", "cm", "extra", "shape", "full", "scale", "fat", "sex", "ize", "code", "address", "Size", "z", "length", "channel", "sc", "dim", "form", "height", "sn", "body", "speed", "unit", "storage", "sec", "cap", "uni", "name", "send", "data", "count", "sum"], "ret": ["tr", "usr", "utf", "rets", "rt", "match", "att", "resp", "re", "RET", "ref", "err", "repl", "result", "success", "len", " Ret", "bl", "rc", "fun", "lit", "flag", "ext", "mt", "mem", "fail", "r", "val", "det", "rep", "def", "error", "bad", "ure", "reply", "fit", "value", "res", "reg", "nt", "fin", "alt", "Ret", "status", "feat"], "comps": ["ocompps", "commPS", "compPS", "COMips", "commps", "combps", "ocomps", "perms", "comases", "comops", "comppos", " compes", "perops", "quops", "COMple", "confples", "compips", "compes", "calips", "Comples", "compos", "compms", "COMps", "compops", "quups", " comops", "comple", "ocomips", "combs", "exples", "comms", " comPS", "comppps", "compps", "comppes", "Compes", "limops", " comples", "perups", " compos", " combs", "qums", "compples", "limbs", "calples", "limps", "limases", "compups", "combops", "perps", "commbs", "ocomple", " comases", "Comops", "comples", "exps", "confps", "compbs", "comPS", "compases", "calpes", "combpos", "compple", "confips", "combples", "calps", "Comps", "confpes", "expos", "comups", "commpos", "expes", "COMpps", "Compos", "comips", "qups"]}}
{"project": "FFmpeg", "commit_id": "577393321c389ad2973bec6168a8045c94a9e099", "target": 0, "func": "void ff_vc1_decode_blocks(VC1Context *v)\n\n{\n\n\n\n    v->s.esc3_level_length = 0;\n\n    if (v->x8_type) {\n\n        ff_intrax8_decode_picture(&v->x8, 2*v->pq + v->halfpq, v->pq * !v->pquantizer);\n\n\n\n        ff_er_add_slice(&v->s.er, 0, 0,\n\n                        (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1,\n\n                        ER_MB_END);\n\n    } else {\n\n        v->cur_blk_idx     =  0;\n\n        v->left_blk_idx    = -1;\n\n        v->topleft_blk_idx =  1;\n\n        v->top_blk_idx     =  2;\n\n        switch (v->s.pict_type) {\n\n        case AV_PICTURE_TYPE_I:\n\n            if (v->profile == PROFILE_ADVANCED)\n\n                vc1_decode_i_blocks_adv(v);\n\n            else\n\n                vc1_decode_i_blocks(v);\n\n            break;\n\n        case AV_PICTURE_TYPE_P:\n\n            if (v->p_frame_skipped)\n\n                vc1_decode_skip_blocks(v);\n\n            else\n\n                vc1_decode_p_blocks(v);\n\n            break;\n\n        case AV_PICTURE_TYPE_B:\n\n            if (v->bi_type) {\n\n                if (v->profile == PROFILE_ADVANCED)\n\n                    vc1_decode_i_blocks_adv(v);\n\n                else\n\n                    vc1_decode_i_blocks(v);\n\n            } else\n\n                vc1_decode_b_blocks(v);\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 11428, "substitutes": {"v": ["ii", "server", "g", "vol", "version", "f", "vers", "va", "k", "vt", "api", "view", "ov", "rev", "serv", "vc", "gu", "c", "conv", "ver", "i", "sv", "d", "vim", "ev", "model", "p", "b", "j", "vr", "vd", "uv", "iv", "z", "vin", "lv", "vm", "vert", "cv", "t", "o", "nv", "l", "V", "q", "u", "vp", "dev", "w", "m", "cover", "e", "n", "vu", "vic", "qu", "tv", "value", "or", "s", "var", "vv", "video", "vi", "ve", "vs", "x", "volt"]}}
{"project": "FFmpeg", "commit_id": "8ce803db51a28eb662b6271b2b223e0312bdb3d2", "target": 1, "func": "paint_mouse_pointer(XImage *image, struct x11_grab *s)\n\n{\n\n    int x_off = s->x_off;\n\n    int y_off = s->y_off;\n\n    int width = s->width;\n\n    int height = s->height;\n\n    Display *dpy = s->dpy;\n\n    XFixesCursorImage *xcim;\n\n    int x, y;\n\n    int line, column;\n\n    int to_line, to_column;\n\n    int image_addr, xcim_addr;\n\n\n\n    xcim = XFixesGetCursorImage(dpy);\n\n\n\n    x = xcim->x - xcim->xhot;\n\n    y = xcim->y - xcim->yhot;\n\n\n\n    to_line = FFMIN((y + xcim->height), (height + y_off));\n\n    to_column = FFMIN((x + xcim->width), (width + x_off));\n\n\n\n    for (line = FFMAX(y, y_off); line < to_line; line++) {\n\n        for (column = FFMAX(x, x_off); column < to_column; column++) {\n\n            xcim_addr = (line - y) * xcim->width + column - x;\n\n\n\n            if ((unsigned char)(xcim->pixels[xcim_addr] >> 24) != 0) { // skip fully transparent pixel\n\n                image_addr = ((line - y_off) * width + column - x_off) * 4;\n\n\n\n                image->data[image_addr] = (unsigned char)(xcim->pixels[xcim_addr] >> 0);\n\n                image->data[image_addr+1] = (unsigned char)(xcim->pixels[xcim_addr] >> 8);\n\n                image->data[image_addr+2] = (unsigned char)(xcim->pixels[xcim_addr] >> 16);\n\n            }\n\n        }\n\n    }\n\n\n\n    XFree(xcim);\n\n    xcim = NULL;\n\n}\n", "idx": 11433, "substitutes": {"dpy": ["dspe", "dpo", "bpy", "bpx", "dp", "Dpe", "Dpy", " dpe", " dpi", "dspo", " dpo", "vdpe", "ldpy", "dpi", "bphy", "dpe", "dpx", "dphy", "Dphy", "vdpy", "dpc", "Dpx", "Dpi", "ldpe", "vdpc", " dpc", " dphy", "dspy", "ldpi", "dspc", "ldp", "bp", " dpx", "Dp", " dp", "vdpo"], "xcim": ["ctxim", "xbIm", "uncima", "constcm", "lcima", "vcim", "centralim", "xbima", "xdim", "xaim", "recims", "iccimm", "xpif", "ccim", "cmpima", "encima", "contimal", "xdimal", "xpimm", "xfims", "zxim", "xdimm", "xpimal", "xcimal", "vcims", "bcim", "xcima", "vcima", "bcims", "bcimal", "xpimen", "recim", "xcimi", "xcimus", "xfima", "xpima", "xaimi", "encimm", "encimal", "constima", "abcima", "dcim", "vcimm", "xaIm", "vcam", "xbimm", "xdima", "confim", "xcIM", "xbimi", "confimal", "zximal", "uncim", "abcimm", "xbim", "zxif", "ctxima", "iccimal", "contima", "confimus", "acsimm", "xaima", "dcims", "ctximm", "cmpimal", "wximm", "xccm", "dcima", "centralimal", "xcif", "hostima", "ctxims", "acsim", "bcima", "xdem", "recem", "xdIM", "etcimal", "contim", "recimm", "xbIM", "etcim", "xdimus", "xcem", "xfimal", "xcimm", "iccimus", "recimal", "abcimal", "wximal", "etcims", "xcam", "cmpimi", "etcima", "iccim", "acsima", "hostimm", "dcimal", "wxim", "wximus", "xcimen", "xfam", "lcims", "ccimen", "cmpims", "vcimal", "recimi", "xcims", "xdcm", "acsIM", "abcim", "bcimm", "etcimi", "lcim", "centralimm", "uncimus", "xdims", "etcimm", "bcem", "centralima", "hostimal", "unccm", "cims", "recima", "confimm", "xcIm", "cim", "ccimal", "xdimi", "contimm", "cimal", "lcimal", "cmpim", "zximen", "cmpIm", "constimus", "cam", "xfim", "constim", "hostim", "encim", "ccif", "xpim", "xbimal"], "x": ["ax", "yx", "wy", "f", "on", "id", "weight", "xc", "ip", "host", "gray", "wx", "ya", "c", "X", "ex", "i", "xy", "en", "d", "h", "p", "ice", "content", "b", "px", "work", "shape", "j", "position", "cross", "z", "code", "xi", "image", "v", "rx", "el", "o", "time", "l", "fx", "index", "xx", "dx", "u", "w", "height", "col", "m", "base", "n", "e", "Y", "one", "page", "name", "video", "ix"], "y": ["zy", "ey", "yx", "wy", "yy", "type", "yo", "ky", "ny", "ys", "ya", "c", "yi", "i", "xy", "h", "dy", "p", "hy", "vy", "cy", "b", "gy", "j", "yr", "z", "image", "ye", "ay", "sy", "o", "t", "ery", "l", "sky", "ym", "xx", "ady", "ry", "w", "height", "ty", "col", "yt", "yl", "Y", "py", "oy"], "line": ["li", "block", "character", "office", "ine", "weight", "edge", "min", "len", "c", "cycle", "write", "label", "user", "i", "model", "slice", "dy", "step", "lines", "cell", "cy", "le", "year", "frame", "eline", "style", "position", "sl", "day", "code", "row", "Line", "lin", "layer", "length", "level", "link", "el", "entry", "l", "pin", "col", "lock", "base", "unit", "lon", "lc", "margin", "page", "name", "grid", "letter"], "column": ["block", "no", "pointer", "character", "arrow", "attribute", "file", "path", "weight", "Column", "letter", "byte", "pixel", "c", "second", "pen", "module", "method", "slice", "offset", "condition", "content", "cell", "year", "ct", "position", "day", "image", "row", "entry", "channel", "scroll", "platform", "word", "four", "point", "dim", "index", "height", "forward", "col", "dimension", "unit", "section", "margin", "page", "grid", "variable", "number", "align"], "to_line": ["toparmodule", "tockframe", "toparrow", "to_lin", "to_direction", " to_frame", "from_row", "from_line", "to_zone", " to_module", "to_module", "tockline", "to_frame", " to_direction", "from_lin", "tockdirection", " to_lin", "toparcolumn", "to_row", " to_row", "toparline", "tocklin", "from_zone"], "to_column": ["to_col", " to_cell", "to_character", "toamepixel", "toamerow", "toamecolumn", "TO_column", "toameline", "TO_cell", "to_pixel", "TO_col", "TO_line", "to_row", " to_row", "to_cell", " to_character", " to_pixel"], "image_addr": [" image_amd", "imageappoff", " image_ptr", "imageappaddr", "imageacadr", "video_amd", "image_loc", "pixel_loc", "image_address", "image_ady", " image_address", " image_ady", " image_oa", "video_addr", "video_nr", "imageaclvl", "image_off", "pixel_addr", "video_part", "imageappoa", "image_lvl", " image_pad", " image_off", "imageacloc", "image_part", "image_adr", "image_pad", "image_amd", "imageappaddress", "imageacaddr", "image_nr", "pixel_adr", "pixel_lvl", "image_ptr", "image_oa"], "xcim_addr": ["xcim_dr", "xcim_url", "xcimal_address", "xcima_dr", "xcim_player", "xcim67addr", "xcim__ord", "xcimal_ref", "xcim_ptr", "xcip_ord", "xcim67ord", "xcim__addr", "xcim_ord", "xcima_anne", "xcimen_ord", "xcim_off", "xcim__sta", "xcimal_layer", "xcimal_url", "xcim67url", "xcrim_addr", "xcip_player", "xcimal_addr", "xcimen_ad", "xcim67player", "xcrim_address", "xcrim_ptr", "xcimen_sta", "xcim_layer", "xcrim_ref", "xcip_url", "xcim_anne", "xcima_addr", "xcim_address", "xcima_address", "xcim__ad", "xcim_ad", "xcim_sta", "xcimen_addr", "xcim_ref", "xcimal_off", "xcip_addr"]}}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static uint64_t boston_platreg_read(void *opaque, hwaddr addr,\n\n                                    unsigned size)\n\n{\n\n    BostonState *s = opaque;\n\n    uint32_t gic_freq, val;\n\n\n\n    if (size != 4) {\n\n        qemu_log_mask(LOG_UNIMP, \"%uB platform register read\", size);\n\n        return 0;\n\n    }\n\n\n\n    switch (addr & 0xffff) {\n\n    case PLAT_FPGA_BUILD:\n\n    case PLAT_CORE_CL:\n\n    case PLAT_WRAPPER_CL:\n\n        return 0;\n\n    case PLAT_DDR3_STATUS:\n\n        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;\n\n    case PLAT_MMCM_DIV:\n\n        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;\n\n        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;\n\n        return val;\n\n    case PLAT_BUILD_CFG:\n\n        val = PLAT_BUILD_CFG_PCIE0_EN;\n\n        val |= PLAT_BUILD_CFG_PCIE1_EN;\n\n        val |= PLAT_BUILD_CFG_PCIE2_EN;\n\n        return val;\n\n    case PLAT_DDR_CFG:\n\n        val = s->mach->ram_size / G_BYTE;\n\n        assert(!(val & ~PLAT_DDR_CFG_SIZE));\n\n        val |= PLAT_DDR_CFG_MHZ;\n\n        return val;\n\n    default:\n\n        qemu_log_mask(LOG_UNIMP, \"Read platform register 0x%\" HWADDR_PRIx,\n\n                      addr & 0xffff);\n\n        return 0;\n\n    }\n\n}\n", "idx": 11439, "substitutes": {"opaque": ["operaya", " opaya", "popaca", "opedaya", "obaque", "opacity", "opaya", " opaco", "opaca", "popaques", "obaques", "popaco", " opacity", "obaco", " opaca", "opaco", "opaques", "operaques", "operaque", " opaques", "operacity", "opedaques", "popaque", "opedacity", "obaca", "opedaque"], "addr": ["hop", "oa", "pos", "prefix", "pointer", "args", "src", "mode", "id", "rt", "ptr", "ref", "ip", "eth", "host", "adr", "seq", "len", "adder", "node", "amp", "rc", "config", "slice", "p", "offset", "ace", "slot", "ord", "asm", "sid", "frame", "grad", "address", "layer", "r", "rx", "mac", "start", "index", "amd", "pad", "arg", "base", "port", "eni", "name", "ad", "hash", "data", "align", "x"], "size": ["g", "sized", "timeout", "SIZE", "pos", "capacity", "empty", "type", "args", "len", "c", "en", "small", "offset", "password", "fee", "loc", "shape", "scale", "ize", "code", "from", "Size", "address", "length", "sn", "iz", "e", "n", "security", "six", "sec", "name", "send", "data"], "s": ["server", "g", "sym", "f", "site", "service", "state", "sf", "ss", "c", "sq", "is", "services", "sv", "sb", "h", "p", "si", "S", "session", "settings", "b", "scope", "ssl", "sie", "socket", "ssh", "se", "sl", "ns", "spec", "t", "o", "ses", "sync", "w", "m", "conf", "south", "e", "sing", "sys", "n", "su", "sa", "stats"], "gic_freq": ["gic_freeq", "gic_fq", "gic6libqs", "gic_Freck", "gic_perqq", "gic_refq", "gic_freck", "gic_freeqs", "gic_libiq", "gic_Freq", "gic_Freqq", "gic_frece", "gic6freiq", "gic_freQ", "gic_libqs", "gic6libq", "gic_refqs", "gic6freq", "gic8refce", "gic_perQ", "gic_perck", "gic_fqs", "gic_freqq", "gic8refQ", "gic_refce", "gic6libz", "gic6frez", "gic8refq", "gic6libiq", "gic8freqs", "gic8frece", "gic_Frece", "gic_fz", "gic_perq", "gic8refqs", "gic8freq", "gic_freiq", "gic_frez", "gic_refQ", "gic_freeiq", "gic_libz", "gic_libq", "gic_freece", "gic_FreQ", "gic8freQ", "gic_freqs", "gic6freqs", "gic_fiq", "gic_freez", "gic_Freqs", "gic_freeQ"], "val": ["vals", "ref", "err", "elt", "fe", "bl", "ol", "slot", "split", "pre", "key", "mem", "rot", "win", "arg", "aval", "alt", "it", "sum", "vol", "live", "prop", "serv", "eval", "enc", "lit", "Val", "doc", "ld", "test", "pt", "end", "code", "num", "el", "ret", "call", "base", "reg", "sec", "var", "valid", "bc", "len", "config", "cal", "part", "sl", "scale", "v", "ee", "bal", "ind", "cond", "index", "util", "value", "count", "pol", "pid", "x", "pos", "type", "sel", "al", "play", "p", "loc", "VAL", "rule", "fat", "sol", "def", "Value", "unit", "data"]}}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "int avfilter_register(AVFilter *filter)\n\n{\n\n    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)\n\n        return -1;\n\n\n\n    registered_avfilters[next_registered_avfilter_idx++] = filter;\n\n    return 0;\n\n}\n", "idx": 11444, "substitutes": {"filter": ["plugin", "version", "block", "type", "f", "match", "attribute", "parser", "alpha", "user", "search", "feature", "event", "patch", "guard", "term", "config", "function", "offset", "b", "fl", "Filter", "rule", "v", "ac", "parent", "entry", "header", "handler", "sort", "apply", "cf", "query", "root", "name", "page", "object"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qmp_migrate_cancel(Error **errp)\n\n{\n\n    migrate_fd_cancel(migrate_get_current());\n\n}\n", "idx": 11449, "substitutes": {"errp": ["nerp", "Erpc", "Ertp", "nerpe", "nerpc", " errpc", "errtp", "Erp", " errtp", "errpe", "nertp", "errpc", "Erpe", " errpe"]}}
{"project": "qemu", "commit_id": "eefff991d059d299b917627d2a95bce34d2f97f3", "target": 1, "func": "int load_snapshot(const char *name, Error **errp)\n\n{\n\n    BlockDriverState *bs, *bs_vm_state;\n\n    QEMUSnapshotInfo sn;\n\n    QEMUFile *f;\n\n    int ret;\n\n    AioContext *aio_context;\n\n    MigrationIncomingState *mis = migration_incoming_get_current();\n\n\n\n    if (!bdrv_all_can_snapshot(&bs)) {\n\n        error_setg(errp,\n\n                   \"Device '%s' is writable but does not support snapshots\",\n\n                   bdrv_get_device_name(bs));\n\n        return -ENOTSUP;\n\n    }\n\n    ret = bdrv_all_find_snapshot(name, &bs);\n\n    if (ret < 0) {\n\n        error_setg(errp,\n\n                   \"Device '%s' does not have the requested snapshot '%s'\",\n\n                   bdrv_get_device_name(bs), name);\n\n        return ret;\n\n    }\n\n\n\n    bs_vm_state = bdrv_all_find_vmstate_bs();\n\n    if (!bs_vm_state) {\n\n        error_setg(errp, \"No block device supports snapshots\");\n\n        return -ENOTSUP;\n\n    }\n\n    aio_context = bdrv_get_aio_context(bs_vm_state);\n\n\n\n    /* Don't even try to load empty VM states */\n\n    aio_context_acquire(aio_context);\n\n    ret = bdrv_snapshot_find(bs_vm_state, &sn, name);\n\n    aio_context_release(aio_context);\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (sn.vm_state_size == 0) {\n\n        error_setg(errp, \"This is a disk-only snapshot. Revert to it \"\n\n                   \" offline using qemu-img\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Flush all IO requests so they don't interfere with the new state.  */\n\n    bdrv_drain_all();\n\n\n\n    ret = bdrv_all_goto_snapshot(name, &bs);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while activating snapshot '%s' on '%s'\",\n\n                     ret, name, bdrv_get_device_name(bs));\n\n        return ret;\n\n    }\n\n\n\n    /* restore the VM state */\n\n    f = qemu_fopen_bdrv(bs_vm_state, 0);\n\n    if (!f) {\n\n        error_setg(errp, \"Could not open VM state file\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_system_reset(SHUTDOWN_CAUSE_NONE);\n\n    mis->from_src_file = f;\n\n\n\n    aio_context_acquire(aio_context);\n\n    ret = qemu_loadvm_state(f);\n\n    qemu_fclose(f);\n\n    aio_context_release(aio_context);\n\n\n\n    migration_incoming_state_destroy();\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while loading VM state\", ret);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11455, "substitutes": {"name": ["g", "version", "prefix", "pass", "block", "no", "size", "type", "id", "on", "NAME", "path", "false", "Name", "c", "label", "a", "new", "names", "again", "b", "filename", "full", "j", "url", "part", "key", "ns", "code", "image", "parent", "el", "time", "resource", "all", "word", "error", "m", "desc", "wa", "base", "n", "ame", "out", "null", "true", "none", "alias", "x", "named", "nm"], "errp": ["ierp", "erpre", "yrp", "aert", "ErP", "errpr", "corp", "Erpatch", " erP", " errpre", "mrp", "oderpress", "argping", " errpp", "corpa", "errorpre", "errorapi", "opapi", "opp", "errpt", "ierpt", "mrpr", "errP", "ierwp", "errpatch", "ierpatch", "errg", "errorP", " erp", "ierpr", " errfp", "errpress", "arrp", "aerp", "erping", "Erp", "errping", "errorpt", "odert", "errapi", "yrpp", "aerpa", "Erwp", "cort", "errfp", "errpre", "aerpress", "oppt", "errorfp", "errpa", "argg", "corpp", "errorp", "mrapi", "ierP", "erp", " errpa", "errt", "ierapi", "oderpa", "opP", "mrpt", "erP", "argp", "arrpt", " erwp", "erfp", "arrapi", " erpatch", "erg", "corpress", "oderp", "yrpa", " errP", "errpp", "arrg", "errwp", "arrpr", "arrping"], "bs": ["bos", "os", "bis", "src", "site", "cs", "ls", "bn", "ss", "bc", "BS", "pb", "lb", "eb", "sb", "bl", "bytes", "cb", "ds", "b", "bes", "fb", "fs", "boot", "gb", "sl", "ns", "android", "hub", "css", "bi", "bb", "bing", "ps", "platform", "ses", "sync", "lib", "gs", "base", "las", "sys", "bits", "bas", "obs", "null", "s", "js", "bid", "bf", "bot", "vs", "ba"], "bs_vm_state": ["bs_vm_data", "bs_vmkstate", "bs_vmkkey", "bs_cm_state", "bs_vm_type", "bs_vmjkey", "bs_virtual_info", "bs_vm_size", "bs_virtual_state", "bs_mem_id", "bs_vm2start", "bs_vm6id", "bs_vm_info", "bs_vm2config", "bs_vm2info", "bs_vmksize", "bs_vmjsize", "bs_memjid", "bs_mx_state", "bs_vm6connection", "bs_memjsize", "bs_vm__state", "bs_vm__type", "bs_cm_data", "bs_vm2type", "bs_virtual_id", "bs_vm2name", "bs_vm__states", "bs_vmmtype", "bs_cm_config", "bs_mx_type", "bs_vmmstate", "bs_virtual_connection", "bs_mem_state", "bs_mx2state", "bs_mx2address", "bs_cm_name", "bs_vm_status", "bs_dmjstates", "bs_vm_id", "bs_vm_connection", "bs_vmjstate", "bs_vm2address", "bs_vmjstates", "bs_mem_key", "bs_vm__status", "bs_dmjstate", "bs_mx_address", "bs_vm6state", "bs_memjstate", "bs_mem_size", "bs_vm_key", "bs_vmkid", "bs_mx__state", "bs_dm_state", "bs_vm2data", "bs_dm_id", "bs_dmjid", "bs_memjkey", "bs_vm_config", "bs_vm__info", "bs_vm_start", "bs_vm__start", "bs_vm2status", "bs_vm2state", "bs_vm_address", "bs_mx2start", "bs_vmmaddress", "bs_vm__id", "bs_vm_states", "bs_mx_start", "bs_mx__info", "bs_vm6info", "bs_mx2type", "bs_mx__type", "bs_dm_states", "bs_vm_name", "bs_mx_info", "bs_vmjid", "bs_vm__address", "bs_vmmstart", "bs_mx_status", "bs_mx__status"], "sn": ["ann", "fn", "sd", "Sn", "sm", "sw", "cs", "ls", "nc", "sf", "bn", "SN", "ss", "ny", "ft", "nb", "ski", "vc", "kn", "sr", "sv", "sb", "SB", "si", "sh", "sp", "fl", "nu", "sl", "ns", "bi", "dn", "sc", "conn", "sync", " Sn", "nn", "n", "sys", "cn", "su", "sk", "sa", "vi", "syn"], "f": ["F", "fen", "fr", "fn", "tf", "file", "sf", "fi", "inf", "ft", "c", "fu", "fe", "d", "fab", "i", "h", "p", "cb", "rf", "b", "fm", "fs", "fb", "fl", "j", "feed", "fa", "z", "fp", "fc", "v", "framework", "t", "df", "r", "l", "fo", "form", "m", "conf", "fit", "func", "e", "n", "fw", "ln", "s", "fd", "fin", "bf", "lf"], "ret": ["ann", "rt", "re", "RET", "ref", "success", "ben", "art", " Ret", "reset", "red", "rep", "pet", "job", "arg", "info", "nt", "alt", "Ret", "status", "feat", "pass", "fn", "rets", "id", "repl", "rev", "result", "cat", "back", "after", "rl", "rf", "lit", "rem", "j", "flag", "run", "end", "mt", "code", "active", "num", "fail", "error", "det", "res", "reg", "out", "str", "sur", "usr", "att", "resp", "len", "en", " RET", "fun", "part", "r", "reply", "value", "fin", "py", "post", "match", "ft", "al", "ner", "arr", "url", "ext", "bit", "opt", "val", "def", "obj", "pret", "bf", "data", "let"], "aio_context": ["aio_cert", "aio_private", "aio_resource", "aio_session", "aioamconfig", "aios_config", "aioamcontext", "aiothecontext", "aios_cert", "aiotheresource", "aout_ctx", "aios_resource", "aout_context", "aios_context", "aioamconcept", "aout_pointer", "aios_concept", "aio_support", "aio_pointer", "aios_ctx", "aio_ctx", "aios_session", "aio_concept", "aioamsession", "aios_private", "aio_config", "aout_support", "aiothectx", "aiotheprivate"], "mis": ["cas", "os", "cs", "mi", "gm", "serv", "mes", "ma", "mr", "model", "ts", "vis", "nas", "si", "iss", "fm", "fs", "json", "sis", "ns", "spec", "ms", "me", "gp", "qs", "gs", "m", "oci", "mas", "tis", "mm", "sys", "rs", "dj", "mc", "res", "lu", "miss", "mn"]}}
{"project": "FFmpeg", "commit_id": "5bca5f87d1a32669e0357790e0d0ad8a5c9c998b", "target": 0, "func": "static av_noinline void emulated_edge_mc_sse(uint8_t *buf, const uint8_t *src,\n\n                                             ptrdiff_t buf_stride,\n\n                                             ptrdiff_t src_stride,\n\n                                             int block_w, int block_h,\n\n                                             int src_x, int src_y, int w, int h)\n\n{\n\n    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,\n\n                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,\n\n                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);\n\n}\n", "idx": 11468, "substitutes": {"buf": ["ctr", "ctx", "vec", "ptr", "ff", "aux", "proc", "bc", "seq", "pb", "conv", "cmp", "rc", "config", "cb", "cur", "bridge", "loc", "b", "fb", "cp", "bt", "queue", "img", "rb", "fp", "cv", "alloc", "br", "uf", "cf", "buff", "buffer", "port", "tc", "uc", "fd"], "src": ["sur", "usr", "ctr", "ptr", "ref", "sel", "sub", "seq", "pb", "rob", "conv", "sup", "sr", "sb", "rc", "config", "cb", "cur", "http", "loc", "b", "ssl", "img", "url", "sl", "rb", "fp", "tmp", "source", "attr", "sc", "rin", "RC", "secure", "uc", "rib", "slice"], "buf_stride": ["buf_strine", "buf_brine", "buf_brided", "buf_bride", "buf_arrine", "buf_stided", "buf_strides", "buf_stide", "buf_arrided", "buf_strided", "buf_striride", "buf_arride", "buf_trride", "buf_tride", "buf_trided", "buf_arrride", "buf_trides", "buf_brride", "buf_strride", "buf_stides", "buf_striine", "buf_striide", "buf_striided", "buf_brides"], "src_stride": ["src_strend", "src_striides", "src_brend", "src_shrend", "src_striend", "src_Strides", "src_striided", "src_Stride", "src_brride", "src_shrided", "src_trides", "src_shrides", "src_Strride", "src_strides", "src_trride", "src_strride", "src_brides", "src_Strided", "src_shride", "src_striide", "src_strided", "src_tride", "src_brided", "src_bride", "src_trided"], "block_w": [" block_x", "block67x", "block67w", "block67wx", "block67h", "block_wr", "block67wr", "block_x", " block_wr", "block67W", " block_W", "block_wx", "block_W", " block_wx"], "block_h": ["block00hs", "block8h", "block_hs", " block_ha", "block00oh", "block_hi", "block00w", " block_oh", "block67hi", "block_oh", " block_hi", "block67w", "block67h", "block8ha", "block_ha", "block8w", "block00h", "block8oh", "block00hi", "block67hs", " block_hs", "block00ha"], "src_x": ["src_asy", "src_i", " src_w", " src_i", "src_h", " src_asy", " src_h", "src_w"], "src_y": ["src_z", "src_h", " src_h", "src_iy", " src_iy", " src_z"], "w": ["g", "wal", "wd", "hw", "f", "k", "sw", "weight", "wx", "y", "c", "wo", "a", "d", "p", "b", "work", "wl", "z", "v", "o", "r", "aw", "win", "l", "u", "ew", "wt", "wa", "ow", "fw", "iw", "wb", "s", "W", "x"], "h": ["g", "ph", "hd", "H", "f", "k", "host", "oh", "y", "how", "c", "p", "ha", "uh", "gh", "b", "ah", "hp", "hh", "ht", "hi", "z", "v", "hs", "ch", "r", "ih", "l", "he", "u", "hl", "m", "dh", "e", "eh", "rh", "x", "hm"]}}
{"project": "FFmpeg", "commit_id": "a1a32fdb0ee63783d06c63b7d90bb382eea356ce", "target": 1, "func": "static int mov_text_tx3g(AVCodecContext *avctx, MovTextContext *m)\n\n{\n\n    char *tx3g_ptr = avctx->extradata;\n\n    int i, box_size, font_length;\n\n    int8_t v_align, h_align;\n\n    int style_fontID;\n\n    StyleBox s_default;\n\n\n\n    m->count_f = 0;\n\n    m->ftab_entries = 0;\n\n    box_size = BOX_SIZE_INITIAL; /* Size till ftab_entries */\n\n    if (avctx->extradata_size < box_size)\n\n        return -1;\n\n\n\n    // Display Flags\n\n    tx3g_ptr += 4;\n\n    // Alignment\n\n    h_align = *tx3g_ptr++;\n\n    v_align = *tx3g_ptr++;\n\n    if (h_align == 0) {\n\n        if (v_align == 0)\n\n            m->d.alignment = TOP_LEFT;\n\n        if (v_align == 1)\n\n            m->d.alignment = MIDDLE_LEFT;\n\n        if (v_align == -1)\n\n            m->d.alignment = BOTTOM_LEFT;\n\n    }\n\n    if (h_align == 1) {\n\n        if (v_align == 0)\n\n            m->d.alignment = TOP_CENTER;\n\n        if (v_align == 1)\n\n            m->d.alignment = MIDDLE_CENTER;\n\n        if (v_align == -1)\n\n            m->d.alignment = BOTTOM_CENTER;\n\n    }\n\n    if (h_align == -1) {\n\n        if (v_align == 0)\n\n            m->d.alignment = TOP_RIGHT;\n\n        if (v_align == 1)\n\n            m->d.alignment = MIDDLE_RIGHT;\n\n        if (v_align == -1)\n\n            m->d.alignment = BOTTOM_RIGHT;\n\n    }\n\n    // Background Color\n\n    m->d.back_color = AV_RB24(tx3g_ptr);\n\n    tx3g_ptr += 4;\n\n    // BoxRecord\n\n    tx3g_ptr += 8;\n\n    // StyleRecord\n\n    tx3g_ptr += 4;\n\n    // fontID\n\n    style_fontID = AV_RB16(tx3g_ptr);\n\n    tx3g_ptr += 2;\n\n    // face-style-flags\n\n    s_default.style_flag = *tx3g_ptr++;\n\n    m->d.bold = s_default.style_flag & STYLE_FLAG_BOLD;\n\n    m->d.italic = s_default.style_flag & STYLE_FLAG_ITALIC;\n\n    m->d.underline = s_default.style_flag & STYLE_FLAG_UNDERLINE;\n\n    // fontsize\n\n    m->d.fontsize = *tx3g_ptr++;\n\n    // Primary color\n\n    m->d.color = AV_RB24(tx3g_ptr);\n\n    tx3g_ptr += 4;\n\n    // FontRecord\n\n    // FontRecord Size\n\n    tx3g_ptr += 4;\n\n    // ftab\n\n    tx3g_ptr += 4;\n\n\n\n    m->ftab_entries = AV_RB16(tx3g_ptr);\n\n    tx3g_ptr += 2;\n\n\n\n    for (i = 0; i < m->ftab_entries; i++) {\n\n\n\n        box_size += 3;\n\n        if (avctx->extradata_size < box_size) {\n\n            mov_text_cleanup_ftab(m);\n\n            m->ftab_entries = 0;\n\n            return -1;\n\n        }\n\n        m->ftab_temp = av_malloc(sizeof(*m->ftab_temp));\n\n        if (!m->ftab_temp) {\n\n            mov_text_cleanup_ftab(m);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        m->ftab_temp->fontID = AV_RB16(tx3g_ptr);\n\n        tx3g_ptr += 2;\n\n        font_length = *tx3g_ptr++;\n\n\n\n        box_size = box_size + font_length;\n\n        if (avctx->extradata_size < box_size) {\n\n            mov_text_cleanup_ftab(m);\n\n            m->ftab_entries = 0;\n\n            return -1;\n\n        }\n\n        m->ftab_temp->font = av_malloc(font_length + 1);\n\n        if (!m->ftab_temp->font) {\n\n            mov_text_cleanup_ftab(m);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(m->ftab_temp->font, tx3g_ptr, font_length);\n\n        m->ftab_temp->font[font_length] = '\\0';\n\n        av_dynarray_add(&m->ftab, &m->count_f, m->ftab_temp);\n\n        if (!m->ftab) {\n\n            mov_text_cleanup_ftab(m);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        tx3g_ptr = tx3g_ptr + font_length;\n\n    }\n\n    for (i = 0; i < m->ftab_entries; i++) {\n\n        if (style_fontID == m->ftab[i]->fontID)\n\n            m->d.font = m->ftab[i]->font;\n\n    }\n\n    return 0;\n\n}\n", "idx": 11488, "substitutes": {"avctx": ["avconfig", "avcontext", "evctx", "AVctx", "ahconfig", "avectx", "afcontext", "ahctrl", "afconfig", "ahcontext", "ajcontext", "AVlc", "AVconfig", "evctrl", "avecu", "ajlc", "avlc", "avcu", "avpkg", "evconfig", "ajctx", "aveconfig", "avecontext", "ajpkg", "afcu", "avepkg", "ahctx", "AVcontext", "avelc", "avctrl", "AVctrl", "AVpkg", "afctx", "AVcu", "evcontext"], "m": ["g", "man", "im", "ctx", "f", "em", "bm", "pm", "sm", "k", "mu", "mi", "gm", "md", "y", "c", "mr", "module", "an", "d", "h", "mod", "p", "tm", "b", "fm", "cm", "j", "context", "z", "v", "machine", "ms", "me", "r", "t", "o", "l", "am", "km", "dim", "ym", "u", "q", "rm", "w", "om", "nm", "dm", "mm", "n", "e", "M", "mc", "s", "um", "mn", "hm"], "tx3g_ptr": ["tx3gFptr", "tx3d_offset", "tx3g_Ptr", "tx3d_dr", "tx3gs_cur", "tx3vgFptr", "tx3ga_dr", "tx3vgFPtr", "tx3gs_ptr", "tx3genJhandle", "tx3d_Ptr", "tx3ga_pointer", "tx3n_ctr", "tx3g__ptr", "tx3g_handle", "tx3d_pad", "tx3gu_pointer", "tx3g_pad", "tx3vgFinter", "tx3gUhandle", "tx3g_inter", "tx3gFPtr", "tx3g_ctr", "tx3g_dr", "tx3gs_pointer", "tx3genJsth", "tx3d_ptr", "tx3gJpointer", "tx3gen_pointer", "tx3gen_dr", "tx3g_dra", "tx3g_length", "tx3vgFcur", "tx3g__dr", "tx3gs_sth", "tx3genJpointer", "tx3vg_Ptr", "tx3g_pert", "tx3gFcur", "tx3g_sth", "tx3ga_pert", "tx3g_struct", "tx3d_length", "tx3genJptr", "tx3g_cur", "tx3n_addr", "tx3gJptr", "tx3n_Ptr", "tx3g__dra", "tx3gu_ptr", "tx3g_addr", "tx3gUpointer", "tx3g_pointer", "tx3vg_inter", "tx3gen_handle", "tx3ga_ptr", "tx3g__pert", "tx3g__handle", "tx3d_pointer", "tx3gen_dra", "tx3gUsth", "tx3gJsth", "tx3vg_ptr", "tx3g_offset", "tx3gu_cur", "tx3gu_addr", "tx3gJhandle", "tx3vg_cur", "tx3d_struct", "tx3g__pointer", "tx3gUptr", "tx3gen_ptr", "tx3n_ptr", "tx3gFinter", "tx3gen_sth"], "i": ["ii", "type", "id", "I", "ip", "c", "iu", "a", "d", "p", "b", "pi", "io", "j", "ie", "ti", "v", "length", "area", "ci", "e", "n", "ime", "ai", "name", "field"], "box_size": ["box_capacity", "boxssize", "box1data", "boxetlen", "boxlendata", "boxlensize", " box1type", " box_data", " box_capacity", "boxslen", "box2capacity", "line_range", " box1data", "font_count", "font_SIZE", "font2size", "line64len", "box2count", "boxsrange", "box1size", "boxetsize", "line64shape", "box64shape", " box1capacity", "box_count", "box2type", "box64limit", "box_data", "box_limit", "box64count", "box2data", "box2SIZE", "box_range", " box1size", "line_shape", "font2count", "box64range", "box64size", "box1type", "box_shape", "boxetshape", "boxetrange", "line64range", "box_len", "boxsshape", "font_size", "boxlencapacity", "font2limit", "line_len", " box_type", "box2limit", "box2size", "boxlentype", "box_type", "box_SIZE", "font2SIZE", "line_size", "font_limit", "box64SIZE", "box1capacity", "box64len", "line64size"], "font_length": ["box_length", "fontaclen", "fontacsize", "font_position", "font_len", "box_position", "box_len", "font_size", "fontaclength", "fontacposition"], "v_align": ["v_label", "v_drop", "v_inline", "v_aff", "v2alpha", "h_adjust", "h_aff", "h_margin", "v_aligned", " v_label", "v_balance", "h_lock", "h_fill", "vocalign", "h_inline", "v_repeat", "v___width", "v2align", "v_width", "h_label", "v_work", "h_work", "voccenter", "h_repeat", "v_fill", "vialinline", "v2width", "v_chain", " v_lead", "v_margin", "v___align", "voclead", "h_alias", "v_alpha", "voctail", "v2label", "v_lead", " v_width", "vialalign", "h_lead", "h_tail", "v_tail", " v_aligned", "h_chain", "h_balance", "v_center", "v___label", "h_drop", "h_aligned", "viallead", "h_center", "vialwork", "v___alpha", "vialmargin", "v_lock", "v_alias", " v_alias", "vialbalance", " v_alpha", "v_adjust"], "h_align": ["hamsquare", "h_equal", "h__align", "h_margin", "hamlead", "hacgap", "h__fill", "v_balance", "hacalign", "v_square", "h_fill", "h_dim", "v_dim", "hp_scale", "v_fill", "v_gap", "hpIPscale", "h__gap", "v_margin", "hamequal", "hp_align", "h__margin", "h_square", "hp_size", "v_lead", "v_equal", "hacdim", "hIPscale", "h_scale", "h_lead", "h_balance", "h__lead", "hamalign", "hIPsize", "h_aligned", "h_size", "hacbalance", "h__balance", "hp_aligned", "h_gap", "hpIPaligned", "hIPalign", "hpIPalign", "hpIPsize", "hIPaligned"], "style_fontID": ["style_textid", "style_textId", "style_styleID", "style_fontId", "style_textIDs", "style_fontName", "style_sheetID", "style_styleId", "style_sheetIDs", "style_styleIDs", "style_sheetName", "style_fontIDs", "style_fontid", "style_textName", "style_textID", "style_styleid"], "s_default": ["sOCKstandard", "sOCKbasic", "s_def", "s_Default", "s_basic", "s_best", "styles_standard", " s_password", "styles_def", " s_standard", "styles_default", " s_guide", " s_best", "sOCKdef", "sOCKdefault", " s_internal", "s_password", "s_guide", " s_Default", "s_standard", "s_internal", "styles_basic"]}}
{"project": "qemu", "commit_id": "9e14037f05e99ca3b8a33d8be9a2a636bbf09326", "target": 1, "func": "static void msmouse_chr_close (struct CharDriverState *chr)\n\n{\n\n    MouseState *mouse = chr->opaque;\n\n\n\n    qemu_input_handler_unregister(mouse->hs);\n\n    g_free(mouse);\n\n    g_free(chr);\n\n}\n", "idx": 11501, "substitutes": {"chr": ["chmr", " chre", " chmr", " chm", "Chsr", "Chra", "Chmr", "chsr", "ichsr", "cra", "ichre", "Chre", "csr", "ichm", "Char", "ichr", "ichmr", "chra", " chsr", " chra", "chm", "chre", "Chr", "cr", "car", "Chm"], "mouse": ["server", "remote", "phy", "voice", "ctx", "pointer", "sym", "state", "self", "mid", "nick", "controller", "close", "wire", "poke", "master", "event", "ae", "Mouse", "circle", "input", "bridge", "scope", "cm", "inner", "shape", "ctrl", "gro", "rule", "key", "address", "press", "parent", "copy", "me", "handler", "mac", "chrome", "click", "m", "move", "query", "cookie", "cue", "mc", "bug", "hover"]}}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "int qemu_init_main_loop(void)\n\n{\n\n    int ret;\n\n\n\n    ret = qemu_signal_init();\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_init_sigbus();\n\n\n\n    return qemu_event_init();\n\n}\n", "idx": 11516, "substitutes": {"ret": ["et", "live", "rt", "type", "id", "match", "re", "RET", "ref", "ft", "result", "len", "iter", "art", " RET", "cat", "back", "lit", "fun", "flag", "ext", "test", "run", "end", "bit", "key", "code", "active", "t", "val", "det", "pet", "def", "try", "get", "ry", "arg", "desc", "xt", "pat", "obj", "info", "out", "reg", "nt", "py", "alt", "Ret", "data", "feat"]}}
{"project": "qemu", "commit_id": "459db780be10f7adac723a5d3a4ffeac8ae6e768", "target": 1, "func": "envlist_parse(envlist_t *envlist, const char *env,\n\n    int (*callback)(envlist_t *, const char *))\n\n{\n\n\tchar *tmpenv, *envvar;\n\n\tchar *envsave = NULL;\n\n\n\n\tassert(callback != NULL);\n\n\n\n\tif ((envlist == NULL) || (env == NULL))\n\n\t\treturn (EINVAL);\n\n\n\n\t/*\n\n\t * We need to make temporary copy of the env string\n\n\t * as strtok_r(3) modifies it while it tokenizes.\n\n\t */\n\n\tif ((tmpenv = strdup(env)) == NULL)\n\n\t\treturn (errno);\n\n\n\n\tenvvar = strtok_r(tmpenv, \",\", &envsave);\n\n\twhile (envvar != NULL) {\n\n\t\tif ((*callback)(envlist, envvar) != 0) {\n\n\t\t\tfree(tmpenv);\n\n\t\t\treturn (errno);\n\n\t\t}\n\n\t\tenvvar = strtok_r(NULL, \",\", &envsave);\n\n\t}\n\n\n\n\tfree(tmpenv);\n\n\treturn (0);\n\n}\n", "idx": 11524, "substitutes": {"tmpenv": ["fakeenc", "nowenvironment", "tempen", "tmpenvironment", "tempconfig", "fakeen", " tmpen", "nowenv", "tempenc", " tmpviron", "testconfig", "tmpv", "ntviron", "tempenv", "tempv", "tmpenc", "tmpconfig", "fakeenvironment", "testenv", "tempenvironment", " tmpenc", "testv", "fakeenv", "tempviron", "ntenvironment", "nowviron", "testenvironment", " tmpv", "tmpen", " tmpconfig", "ntenv", "tmpviron", " tmpenvironment"], "envvar": ["environmentver", "enstack", "enccat", "environmentname", "encver", "environmentstack", "enbar", " envlist", "evname", " envbar", "environmentvar", " envVar", "envname", " envver", "senlist", "envvari", "envar", "envcat", "environmentbar", " envcat", "environmentVar", "evvari", "evVar", "envconst", "senvar", "environmentcat", "environmentconst", "encvari", "evvar", "envbar", "envstack", "environmentlist", " envconst", "enlist", "encvar", "senconst", "environmentvari", " envvari", " envstack", "envlist", "envver", "encVar", " envname", "envVar"], "envsave": ["enstsaved", " enssave", "envalsaves", "ennsaving", "envalsave", " enssaved", "envssave", "encsave", "enversave", "enversaves", "encsaved", "elvsaved", "enstsource", "envalsaving", "envsaving", "envave", " enversaves", "ennsaved", "enssaved", "envaved", " envssave", "elvsource", " envsaved", "elvsave", "envource", " enssaves", "elstsaving", "envsaves", "ennsource", " ensssave", " envsaves", " enversaver", "enstsave", "enversaving", "envsource", " enversave", "elstsaved", "ensssave", "encsaves", "enstsaving", "enversaver", "ennsaver", "enssaves", " envsaving", "elstsave", "elvsaving", "enssave", "elstsource", "ennssave", "ennsaves", " enversaving", " envsaver", "envsaver", "envaving", "encssave", "ennsave", "envalsaver", "envsaved"]}}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int avi_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    unsigned char tag[5];\n\n    unsigned int flags = 0;\n\n    const int stream_index = pkt->stream_index;\n\n    int size               = pkt->size;\n\n    AVIContext *avi     = s->priv_data;\n\n    AVIOContext *pb     = s->pb;\n\n    AVIStream *avist    = s->streams[stream_index]->priv_data;\n\n    AVCodecParameters *par = s->streams[stream_index]->codecpar;\n\n\n\n    while (par->block_align == 0 && pkt->dts != AV_NOPTS_VALUE &&\n\n           pkt->dts > avist->packet_count) {\n\n        AVPacket empty_packet;\n\n\n\n        av_init_packet(&empty_packet);\n\n        empty_packet.size         = 0;\n\n        empty_packet.data         = NULL;\n\n        empty_packet.stream_index = stream_index;\n\n        avi_write_packet(s, &empty_packet);\n\n    }\n\n    avist->packet_count++;\n\n\n\n    // Make sure to put an OpenDML chunk when the file size exceeds the limits\n\n    if (pb->seekable &&\n\n        (avio_tell(pb) - avi->riff_start > AVI_MAX_RIFF_SIZE)) {\n\n        avi_write_ix(s);\n\n        ff_end_tag(pb, avi->movi_list);\n\n\n\n        if (avi->riff_id == 1)\n\n            avi_write_idx1(s);\n\n\n\n        ff_end_tag(pb, avi->riff_start);\n\n        avi->movi_list = avi_start_new_riff(s, pb, \"AVIX\", \"movi\");\n\n    }\n\n\n\n    avi_stream2fourcc(tag, stream_index, par->codec_type);\n\n    if (pkt->flags & AV_PKT_FLAG_KEY)\n\n        flags = 0x10;\n\n    if (par->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        avist->audio_strm_length += size;\n\n\n\n    if (s->pb->seekable) {\n\n        int err;\n\n        AVIIndex *idx = &avist->indexes;\n\n        int cl = idx->entry / AVI_INDEX_CLUSTER_SIZE;\n\n        int id = idx->entry % AVI_INDEX_CLUSTER_SIZE;\n\n        if (idx->ents_allocated <= idx->entry) {\n\n            if ((err = av_reallocp(&idx->cluster,\n\n                                   (cl + 1) * sizeof(*idx->cluster))) < 0) {\n\n                idx->ents_allocated = 0;\n\n                idx->entry          = 0;\n\n                return err;\n\n            }\n\n            idx->cluster[cl] =\n\n                av_malloc(AVI_INDEX_CLUSTER_SIZE * sizeof(AVIIentry));\n\n            if (!idx->cluster[cl])\n\n                return -1;\n\n            idx->ents_allocated += AVI_INDEX_CLUSTER_SIZE;\n\n        }\n\n\n\n        idx->cluster[cl][id].flags = flags;\n\n        idx->cluster[cl][id].pos   = avio_tell(pb) - avi->movi_list;\n\n        idx->cluster[cl][id].len   = size;\n\n        idx->entry++;\n\n    }\n\n\n\n    avio_write(pb, tag, 4);\n\n    avio_wl32(pb, size);\n\n    avio_write(pb, pkt->data, size);\n\n    if (size & 1)\n\n        avio_w8(pb, 0);\n\n\n\n    return 0;\n\n}\n", "idx": 11527, "substitutes": {"s": ["sym", "src", "service", "cs", "self", "c", "pc", "a", "i", "sv", "d", "sci", "settings", "b", "gs", "sn", "e", "rs", "js", "os", "bis", "ls", "ss", "parser", "sq", "sb", "http", "S", "sie", "session", "ds", "fs", "ssl", "o", "ses", "qs", "tags", "f", "parts", "php", "sf", "xs", "uploads", "services", "sg", "sl", "bs", "v", "r", "ps", "sync", "south", "sys", "su", "g", "sam", "request", "single", "is", "small", "es", "p", "ts", "si", "ns", "spec", "us", "t", "plugins", "sets", "sa", "types", "slice", "aws"], "pkt": ["apqt", " packet", "pct", "Punt", "ukt", "cpk", "upacket", "unt", "Pct", "packet", "pk", "apkt", "mkt", "macket", " pelt", " pk", "Pkg", "Pkt", "rct", "pke", "Pke", "Pqt", " pqt", "Packet", "uct", "cpkt", "ppt", " punt", "pkg", "uke", "produelt", "upunt", " pct", "rkg", "mpt", "cppt", " pkg", "mk", "Pnt", "pnt", "pelt", "produacket", " pnt", "racket", "upkg", "produqt", "apnt", "rkt", "cpacket", "upkt", " pke", "pqt", "punt", "produkt", " ppt", "apct", "Pelt"], "tag": ["g", "pos", "block", "type", "at", "id", "bis", "ref", "buf", "pl", "class", "mp", "len", "peg", " Tag", "fe", "small", "rc", "cat", "rss", "enc", "loc", "img", "ag", " tags", "ar", "rb", "code", "ac", "image", "bb", "length", "wp", "sc", "Tag", "capt", "desc", "tc", "tags", "reg", "null", "root", "TAG", "uc", "bug", "data", "slice"], "avi": ["ii", "abi", "ave", "voice", "pai", "api", "oi", "mi", "fi", "mp", "metadata", "oga", "audio", "media", "adi", "avan", "aim", "music", "ini", "afi", "aaa", "wikipedia", "vim", "iva", "ani", "si", "addin", "anti", "omi", "archive", "director", "mic", "audi", "ori", "imi", "nav", "wi", "ami", "asu", "umi", "iv", "di", "ti", "liv", "bi", "avia", "jam", "attr", "picture", "ci", "vp", "abo", "ava", "opus", "photo", "ai", "sa", "eni", "video", "vi", "av"], "pb": ["prop", "abi", "np", "pit", "phrase", "pg", "tp", "ctx", "bos", "bm", "dp", "pm", "pai", "pro", "api", "pl", "typ", "mp", "proc", "ppa", "bc", "parser", "rob", "nb", "bps", "db", "pc", "jp", "lb", "lab", "sb", "lp", "pd", "amp", "cpp", "p", "cb", "b", "fb", "cp", "bh", "apy", "ub", "gb", "rb", "bs", "fp", "fc", "summary", "hub", "prot", "platform", "ps", "wp", "uf", "pp", "vp", "ab", "opus", "pa", "tc", "wb", "bp", "py", "PB"], "avist": ["aphism", "aphist", "apists", " avict", "AVists", "ivart", "apIST", "aimist", "avism", "aimists", "afists", "ajist", "aimIST", "ajict", " avart", "ivist", "akost", "afpect", "ajart", "avista", " avists", "akpect", " avista", "avost", "akist", "avinst", "avists", "apist", "affism", "ajinst", "AVart", "affert", "avert", " avism", "avict", "akists", "ajert", "AVist", "ivict", "ivism", " avost", "afista", "apost", "avpect", "avart", "akIST", "aimart", " avpect", "AVIST", "akista", "afist", "affist", " avIST", "avIST", "aphinst", "ajism", "aphert", "affinst"], "par": ["param", "prop", "arp", "parse", "pard", "fr", "dp", "pal", "pro", "api", "proc", "mp", "comp", "player", "serv", "parser", "adr", "particip", "pc", "cmp", "co", "params", "dr", "war", "cat", "pr", "p", "per", "rc", "sp", "pi", "ar", "part", "po", "pre", "pac", "spec", "prep", "r", "ps", "pp", "car", "as", "arg", "mm", "pa", "asi", "sk", "cap", "var", "py", "har"], "empty_packet": ["empty_octeter", "empty_Packet", "empty_packset", "empty_packageacket", "empty_processet", "empty_packets", "empty_packetter", "empty_Packel", "empty_kwacket", "empty_packen", "empty_complet", "empty_packetic", "empty_sexetic", "empty_packect", "empty_planetic", "empty_packette", "empty_compset", "empty_capeting", "empty_planacket", "empty_packel", "empty_Packacket", "empty_planen", "empty_capacket", "empty_kwet", "empty_buckset", "empty_sexet", "empty_octet", "empty_bucketer", "empty_competter", "empty_packageets", "empty_packsette", "empty_processetic", "empty_compect", "empty_paclet", "empty_pacet", "empty_sexacket", "empty_compet", "empty_sexeter", "empty_Packect", "empty_pacacket", "empty_processen", "empty_processacket", "empty_buckacket", "empty_paceting", "empty_packeting", "empty_packlet", "empty_capet", "empty_packsacket", "empty_octacket", "empty_bucket", "empty_packsets", "empty_sexetter", "empty_competing", "empty_packeter", "empty_kwect", "empty_planet", "empty_kwel", "empty_compel", "empty_sexen", "empty_packageette", "empty_compacket", "empty_bucketter", "empty_packacket", "empty_octetter", "empty_compets", "empty_packageet", "empty_caplet", "empty_compette"], "packet_count": ["packet_code", "packet__code", "packetxtotal", "packetfullcount", "packet_total", "packetxcount", "packacket_id", "packacket_code", "packacket_total", "packacket_pointer", "packacket_size", "packet__id", "packetfulltotal", "packacket_count", "packetxpointer", "packet_id", "packetfullpointer", "packet__size", "packet__count", "packet_pointer", "packet_size"], "err": ["file", "f", "resp", "pl", " error", "seq", "sign", "stat", "fe", "rc", "arr", "loc", "flag", "z", "code", "num", "r", "error", "all", "def", "l", "map", "col", "desc", "info", "var", "stats"], "idx": ["Idxs", "pos", "type", "src", "buf", " idxs", "seq", "write", "idex", "indx", "idc", " idxc", "indxc", "indz", "indc", "idz", "idxs", " idz", "Idx", "Idxc", " idex", "_", "Idex", "index", " idc", "idxc", "buffer", "obj", "this", "Idz", "indxs", "Idc"], "entry": ["no", "id", "import", "connection", "ries", "rc", "Entry", "offset", "ent", "orig", "session", "member", "ident", "archive", "enter", "end", "part", "way", "key", "image", "row", "inc", "reader", "insert", "error", "mission", "get", "try", "start", "index", "desc", "lock", "child", "set", "nt", "sec", "element", "data", "it"]}}
{"project": "FFmpeg", "commit_id": "0d021cc8b30a6f81c27fbeca7f99f1ee7a20acf8", "target": 0, "func": "static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)\n\n{\n\n    if (err != CUDA_SUCCESS) {\n\n        av_log(avctx, AV_LOG_FATAL, \">> %s - failed with error code 0x%x\\n\", func, err);\n\n        return 0;\n\n    }\n\n    return 1;\n\n}\n", "idx": 11529, "substitutes": {"avctx": ["capcontext", "avcontext", "AVctx", "Avctx", "afc", "Avpkg", "Avcit", "avcit", " avcontext", "Avcontext", "capcu", "avc", "avcu", "avpkg", "afcu", "capc", "capctx", "AVcontext", "AVc", " avcit", "AVpkg", "afctx", " avpkg", "AVcu", "AVcit", "afcontext"], "err": ["Error", "args", "type", "pointer", "unc", "resp", "exc", " error", "proc", "fi", "result", "c", "mr", "Er", "iter", "fe", "sr", "dr", "rc", "lr", "cb", "p", "ace", "fee", "arr", "fun", "inner", "runner", "doc", "ie", "code", "ac", "r", "error", "attr", "all", "req", "kr", "call", "bad", "cer", "next", "e", "er", "msg", "rs", "rr", "or", "var", "status", "bug", "data", "rage", "str"], "func": ["lambda", "ctx", "f", "unc", "args", "callback", "buf", "self", "proc", "addr", "seq", "pc", "function", "cb", "expr", "fee", "pkg", "Function", "fun", "doc", "context", "go", "cc", "package", "r", "error", "val", "attr", "cmd", "call", "cf", "stack", "wrapper", "ln", "name", "data", "exec"]}}
{"project": "FFmpeg", "commit_id": "e87190f5d20d380608f792ceb14d0def1d80e24b", "target": 0, "func": "static void show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, int in_program)\n\n{\n\n    AVStream *stream = fmt_ctx->streams[stream_idx];\n\n    AVCodecContext *dec_ctx;\n\n    const AVCodec *dec;\n\n    char val_str[128];\n\n    const char *s;\n\n    AVRational sar, dar;\n\n    AVBPrint pbuf;\n\n\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM);\n\n\n\n    print_int(\"index\", stream->index);\n\n\n\n    if ((dec_ctx = stream->codec)) {\n\n        const char *profile = NULL;\n\n        dec = dec_ctx->codec;\n\n        if (dec) {\n\n            print_str(\"codec_name\", dec->name);\n\n            if (!do_bitexact) {\n\n                if (dec->long_name) print_str    (\"codec_long_name\", dec->long_name);\n\n                else                print_str_opt(\"codec_long_name\", \"unknown\");\n\n            }\n\n        } else {\n\n            print_str_opt(\"codec_name\", \"unknown\");\n\n            if (!do_bitexact) {\n\n                print_str_opt(\"codec_long_name\", \"unknown\");\n\n            }\n\n        }\n\n\n\n        if (dec && (profile = av_get_profile_name(dec, dec_ctx->profile)))\n\n            print_str(\"profile\", profile);\n\n        else\n\n            print_str_opt(\"profile\", \"unknown\");\n\n\n\n        s = av_get_media_type_string(dec_ctx->codec_type);\n\n        if (s) print_str    (\"codec_type\", s);\n\n        else   print_str_opt(\"codec_type\", \"unknown\");\n\n        print_q(\"codec_time_base\", dec_ctx->time_base, '/');\n\n\n\n        /* print AVI/FourCC tag */\n\n        av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag);\n\n        print_str(\"codec_tag_string\",    val_str);\n\n        print_fmt(\"codec_tag\", \"0x%04x\", dec_ctx->codec_tag);\n\n\n\n        switch (dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            print_int(\"width\",        dec_ctx->width);\n\n            print_int(\"height\",       dec_ctx->height);\n\n            print_int(\"has_b_frames\", dec_ctx->has_b_frames);\n\n            sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL);\n\n            if (sar.den) {\n\n                print_q(\"sample_aspect_ratio\", sar, ':');\n\n                av_reduce(&dar.num, &dar.den,\n\n                          dec_ctx->width  * sar.num,\n\n                          dec_ctx->height * sar.den,\n\n                          1024*1024);\n\n                print_q(\"display_aspect_ratio\", dar, ':');\n\n            } else {\n\n                print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n\n                print_str_opt(\"display_aspect_ratio\", \"N/A\");\n\n            }\n\n            s = av_get_pix_fmt_name(dec_ctx->pix_fmt);\n\n            if (s) print_str    (\"pix_fmt\", s);\n\n            else   print_str_opt(\"pix_fmt\", \"unknown\");\n\n            print_int(\"level\",   dec_ctx->level);\n\n            if (dec_ctx->timecode_frame_start >= 0) {\n\n                char tcbuf[AV_TIMECODE_STR_SIZE];\n\n                av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start);\n\n                print_str(\"timecode\", tcbuf);\n\n            } else {\n\n                print_str_opt(\"timecode\", \"N/A\");\n\n            }\n\n            break;\n\n\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            s = av_get_sample_fmt_name(dec_ctx->sample_fmt);\n\n            if (s) print_str    (\"sample_fmt\", s);\n\n            else   print_str_opt(\"sample_fmt\", \"unknown\");\n\n            print_val(\"sample_rate\",     dec_ctx->sample_rate, unit_hertz_str);\n\n            print_int(\"channels\",        dec_ctx->channels);\n\n\n\n            if (dec_ctx->channel_layout) {\n\n                av_bprint_clear(&pbuf);\n\n                av_bprint_channel_layout(&pbuf, dec_ctx->channels, dec_ctx->channel_layout);\n\n                print_str    (\"channel_layout\", pbuf.str);\n\n            } else {\n\n                print_str_opt(\"channel_layout\", \"unknown\");\n\n            }\n\n\n\n            print_int(\"bits_per_sample\", av_get_bits_per_sample(dec_ctx->codec_id));\n\n            break;\n\n\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            if (dec_ctx->width)\n\n                print_int(\"width\",       dec_ctx->width);\n\n            else\n\n                print_str_opt(\"width\",   \"N/A\");\n\n            if (dec_ctx->height)\n\n                print_int(\"height\",      dec_ctx->height);\n\n            else\n\n                print_str_opt(\"height\",  \"N/A\");\n\n            break;\n\n        }\n\n    } else {\n\n        print_str_opt(\"codec_type\", \"unknown\");\n\n    }\n\n    if (dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) {\n\n        const AVOption *opt = NULL;\n\n        while (opt = av_opt_next(dec_ctx->priv_data,opt)) {\n\n            uint8_t *str;\n\n            if (opt->flags) continue;\n\n            if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) {\n\n                print_str(opt->name, str);\n\n                av_free(str);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt    (\"id\", \"0x%x\", stream->id);\n\n    else                                          print_str_opt(\"id\", \"N/A\");\n\n    print_q(\"r_frame_rate\",   stream->r_frame_rate,   '/');\n\n    print_q(\"avg_frame_rate\", stream->avg_frame_rate, '/');\n\n    print_q(\"time_base\",      stream->time_base,      '/');\n\n    print_ts  (\"start_pts\",   stream->start_time);\n\n    print_time(\"start_time\",  stream->start_time, &stream->time_base);\n\n    print_ts  (\"duration_ts\", stream->duration);\n\n    print_time(\"duration\",    stream->duration, &stream->time_base);\n\n    if (dec_ctx->bit_rate > 0) print_val    (\"bit_rate\", dec_ctx->bit_rate, unit_bit_per_second_str);\n\n    else                       print_str_opt(\"bit_rate\", \"N/A\");\n\n    if (stream->nb_frames) print_fmt    (\"nb_frames\", \"%\"PRId64, stream->nb_frames);\n\n    else                   print_str_opt(\"nb_frames\", \"N/A\");\n\n    if (nb_streams_frames[stream_idx])  print_fmt    (\"nb_read_frames\", \"%\"PRIu64, nb_streams_frames[stream_idx]);\n\n    else                                print_str_opt(\"nb_read_frames\", \"N/A\");\n\n    if (nb_streams_packets[stream_idx]) print_fmt    (\"nb_read_packets\", \"%\"PRIu64, nb_streams_packets[stream_idx]);\n\n    else                                print_str_opt(\"nb_read_packets\", \"N/A\");\n\n    if (do_show_data)\n\n        writer_print_data(w, \"extradata\", dec_ctx->extradata,\n\n                                          dec_ctx->extradata_size);\n\n\n\n    /* Print disposition information */\n\n#define PRINT_DISPOSITION(flagname, name) do {                                \\\n\n        print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \\\n\n    } while (0)\n\n\n\n    if (do_show_stream_disposition) {\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION);\n\n    PRINT_DISPOSITION(DEFAULT,          \"default\");\n\n    PRINT_DISPOSITION(DUB,              \"dub\");\n\n    PRINT_DISPOSITION(ORIGINAL,         \"original\");\n\n    PRINT_DISPOSITION(COMMENT,          \"comment\");\n\n    PRINT_DISPOSITION(LYRICS,           \"lyrics\");\n\n    PRINT_DISPOSITION(KARAOKE,          \"karaoke\");\n\n    PRINT_DISPOSITION(FORCED,           \"forced\");\n\n    PRINT_DISPOSITION(HEARING_IMPAIRED, \"hearing_impaired\");\n\n    PRINT_DISPOSITION(VISUAL_IMPAIRED,  \"visual_impaired\");\n\n    PRINT_DISPOSITION(CLEAN_EFFECTS,    \"clean_effects\");\n\n    PRINT_DISPOSITION(ATTACHED_PIC,     \"attached_pic\");\n\n    writer_print_section_footer(w);\n\n    }\n\n\n\n    show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS);\n\n\n\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n\n    fflush(stdout);\n\n}\n", "idx": 11535, "substitutes": {"w": ["wal", "rw", "hw", "we", "sw", "xml", "self", "wx", "wcs", "c", "wo", "world", "p", "wr", "kw", "tw", "wl", "r", "t", "writers", "reader", "wp", "wu", "q", "ew", "u", "wav", "ow", "m", "wa", "wt", "fw", "wb", "window", "W", "x", "writer"], "fmt_ctx": ["frt_cf", "fmt2ctx", "fnt2ctx", "fmtfcontext", "fmt_context", "fnt2context", "frt_ci", "fmt_cf", "fmtfci", "fmt2tx", "frt_context", "fnt_ctx", "fmt_lc", "frt_ctx", "fnt_lc", "fmtfctx", "fnt2lc", "fnt_context", "fnt2tx", "fmt2context", "fmtfcf", "fmt_ci", "fmt_tx", "fmt2lc", "fnt_tx"], "stream_idx": ["stream_midv", "stream_startr", "stream_infox", "stream_startxs", "stream_idsxs", "stream_idv", "stream_infoy", "stream_indxs", "stream_midx", "stream_idsy", "stream_infoxs", "stream_indx", "stream_idy", "stream_midr", "stream_indv", "stream_indr", "stream_midxs", "stream_infov", "stream_idxs", "stream_idr", "stream_startv", "stream_idsx", "stream_idsv", "stream_startx"], "in_program": ["in1program", "in_path", " in_command", "in1context", "in_context", " in_context", "inCcontext", "inCProgram", "inCsection", "in_command", "in_section", "in1Program", "inCprogram", " in_section", " in_Program", "in_Program", "in1section", " in_path"], "stream": ["transform", "fr", "ack", "pool", "src", "path", "view", "sw", "draft", "output", "tag", "track", "Stream", "draw", "document", "model", "cur", "input", "stage", "context", "feed", "sl", "coll", "row", "inc", "reader", "source", "channel", "ream", "wave", "resource", "length", "sc", "form", "rec", "m", "desc", "func", "uc", "data", "writer"], "dec_ctx": ["decklc", "dec_sys", "dec_jc", "dec_cm", "dev_loc", "genallctx", "gen_lc", "draw_loc", "Dec_ci", "rec_la", "rec_tx", "genalllc", "desc_sys", "decallcas", "enc_lc", "decacsys", "decPctx", "enc_jc", "rec_ctx", "genallcas", "rec2context", "decJctx", "decPhi", "dec_scope", "dec_ci", "draw_sys", "Dec_context", "dec_lc", "dec_sync", "rec_context", "dec_func", "dec_loc", "dec2context", "gen_qa", "decPsys", "enc_loc", "decaccm", "decLloc", "decLctx", "rec2tx", "decJfunc", "drawPhi", "dec_qa", "decJloc", "rec2ctx", "desc_cmp", "decacctx", "decpljc", "decplctx", "dev_ctx", "decallqa", "decJtx", "deckctx", "genallqa", "gen_ctx", "dev_func", "dec_la", "dec2la", "rec2la", "desc_cm", "decLsys", "drawPsys", "Dec_ctx", "dev_tx", "desc_ctx", "enc_sync", "draw_ctx", "dec2tx", "decLcontext", "deckcontext", "decallctx", "enc_context", "drawPloc", "decplloc", "decPloc", "enc_ctx", "decPwcs", "deckscope", "drawPctx", "Dec_wcs", " dec_context", "dec_wcs", "decaccmp", "decPcontext", "enc_scope", "dec_context", "decLwcs", "decPci", "decplsync", "draw_hi", " dec_tx", "dec2ctx", "dec_tx", "decalllc", "gen_cas", "decLci", " dec_cmp", "dec_cas", "decLhi", "dec_hi", "dec_cmp"], "val_str": ["len_string", "valingvec", "tagenname", "val_name", "valenname", "valnspec", "valingorig", "val2Str", "tag_div", "enc_vec", "tag_name", "valnstr", "valendiv", "val_vec", "enc_str", "tagendiv", "val_int", "tag_string", "tagenstr", "val_Str", " val_string", "tagenstring", "val_orig", "len_Str", "val_div", "encingspec", "encingvec", "valenstr", "val_string", "len_str", "valingspec", "tag_str", "encingorig", "val2name", "valingstr", " val_arr", " val_int", "enc_spec", "valnvec", "val_spec", "len_arr", "valnorig", "val_arr", "valenstring", "enc_orig", "val2arr", "val2str", "val2string", "encingstr", "val2div"], "s": ["g", "os", "args", "f", "type", "site", "service", "its", "ls", "ss", "sub", "c", "sq", "a", "i", "is", "sv", "services", "sb", "h", "p", "ts", "si", "sg", "S", "ds", "b", "session", "fs", "ssl", "iss", "se", "sl", "ns", "v", "spec", "r", "o", "t", "ses", "sc", "gs", "series", "sn", "m", "e", "n", "sys", "security", "su", "rs", "sa", "space", "types"], "sar": ["sAR", "BAR", "alsAR", "inAR"], "dar": ["rw", " true", "src", "err", " nil", "serial", "ARR", " sr", "SEC", " dc", "arc", " var", "arr", "ar", "row", "r", "sc", "desc", "AR", "sec", "var"], "pbuf": ["bbuff", "bbuf", "bpbn", "buf", "bpfp", "preuf", "prebuffer", "lpcv", " pfp", "lpbn", "puf", "pcv", "prebuf", " pbuffer", "lpbuf", "pbn", "pbuff", "prebuff", " pbn", "lpfp", " pbuff", " pcv", "pfp", "bbuffer", " puf", "bpcv", "bpbuf", "pbuffer"], "profile": ["ph", "phy", "person", "version", "pse", "thin", "shadow", "type", "character", "match", "gender", "file", "pal", "path", "description", "prime", "tag", "option", "phone", "user", "label", "mobile", "method", "feature", "beta", "username", "model", "pr", "p", "primary", "member", "community", "filename", "use", "account", "style", "Profile", "family", "prof", "sl", "fat", "key", "summary", "pe", "image", "parent", "header", "platform", "val", "program", "picture", "gor", "mo", "desc", "base", "unit", "photo", "su", "face", "name", "role", "alias"]}}
{"project": "FFmpeg", "commit_id": "8d857c543402911f46ad38b093ab9aaf5b9a9a18", "target": 1, "func": "static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,\n\n                            const uint32_t *quant) {\n\n    int coeff, i, n;\n\n    int8_t ac;\n\n    uint8_t dc = get_bits(gb, 8);\n\n\n\n    // block not coded\n\n    if (dc == 255)\n\n\n\n\n    // number of non-zero coefficients\n\n    coeff = get_bits(gb, 6);\n\n    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)\n\n\n\n\n    // normally we would only need to clear the (63 - coeff) last values,\n\n    // but since we do not know where they are we just clear the whole block\n\n    memset(block, 0, 64 * sizeof(DCTELEM));\n\n\n\n    // 2 bits per coefficient\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 2);\n\n        if (ac == -2)\n\n            break; // continue with more bits\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    // 4 bits per coefficient\n\n    ALIGN(4);\n\n\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 4);\n\n        if (ac == -8)\n\n            break; // continue with more bits\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    // 8 bits per coefficient\n\n    ALIGN(8);\n\n    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)\n\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 8);\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    PUT_COEFF(dc);\n\n    return 1;\n\n}", "idx": 11543, "substitutes": {"gb": ["binary", "g", "ga", "plugin", "phy", "pg", "ctx", "bm", "gam", "GB", "gm", "nb", "rg", "bc", "gg", "gu", "gd", "db", "pc", "game", "lb", "eb", "usb", "sb", "cgi", "kb", "vg", "bo", "bridge", "gh", "boot", "gy", "mb", "gate", "b", "bg", "gio", "gi", "cfg", "rb", "gt", "hub", "gal", "dc", "bb", "ui", "bin", "gp", "gin", "gpu", "agg", "gem", "lib", "sync", "git", "gs", "bf", "buff", "ge", "storage", "wb", "gc", "bug", "ig", "gru"], "block": ["bus", "plugin", "board", "ctx", "device", "self", "Block", "bc", "byte", "pixel", "db", "pc", "co", "bl", "node", "config", "ck", "bridge", "loc", "session", "b", "blocks", "gate", "range", "bit", "ko", "coll", "hub", "spec", "row", "bb", "channel", "bin", "buffer", "lock", "query", "tx", "unit", "line", "batch", "group", "cache"], "scan": ["parse", "unc", "src", "comment", "cs", "proc", "gam", "pc", "feature", "rc", "cat", "config", "enc", "gate", "doc", "scale", "spec", "gain", "bin", "mac", "sc", "sync", "dev", "acc", "query", "circ", "raw", "gc", "cache"], "quant": ["transform", "gap", "prefix", "wait", "comment", "frac", "gam", "comp", "quad", "draw", "vis", "input", "total", "doc", "spec", "num", "gain", "q", "acc", "pad", "query", "circ", "util", "fix", "raw", "complex", "depth", "cost", "cache"], "coeff": ["COff", "colef", "Coef", "goef", " coef", "coefficients", "Coeffect", " coefficients", "colleff", "collff", "koef", "ceffect", "goefficient", "coff", "Coefficients", "koefficient", "COeff", "collef", "collefficient", "colefficients", "cef", "koeffect", "COef", "coleff", "coefficient", "COeffect", " coeffect", "goeff", "koeff", "ceff", "Coeff", "colefficient", " coff", "coeffect", "COefficient", " coefficient", "Coff", "COefficients", "goefficients", "cefficient", "coef", "Coefficient"], "i": ["ii", "g", "f", "id", "I", "k", "ip", "mi", "c", "a", "d", "p", "si", "b", "pi", "ar", "in", "bi", "r", "ui", "ci", "index", "m", "ai", "it"], "n": ["g", "ni", "f", "nr", "k", "nc", "nb", "y", "c", "N", "an", "d", "p", "b", "ns", "nan", "num", "o", "r", "w", "m", "sn", "nn", "e", "name"], "ac": ["cas", "jac", "ga", "ack", "abc", "unc", "k", "anc", "cs", "nc", "comp", "bc", "alpha", "vc", "c", "pc", "ca", "auc", "ak", "a", "cache", "aa", "disc", "cat", "ace", "enc", "iac", "input", "sac", "loc", "ic", "acs", "cu", "mic", "fac", "cc", "act", "fc", "dc", "spec", "op", "inc", "mac", "am", "acc", "oc", "circ", "tc", "ai", "ec", "mc", "uc", "lc", "ad", "Ac", "AC", "rac", "fact", "acl"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_neon_trn_u16(TCGv t0, TCGv t1)\n\n{\n\n    TCGv rd, tmp;\n\n\n\n    rd = new_tmp();\n\n    tmp = new_tmp();\n\n\n\n    tcg_gen_shli_i32(rd, t0, 16);\n\n    tcg_gen_andi_i32(tmp, t1, 0xffff);\n\n    tcg_gen_or_i32(rd, rd, tmp);\n\n    tcg_gen_shri_i32(t1, t1, 16);\n\n    tcg_gen_andi_i32(tmp, t0, 0xffff0000);\n\n    tcg_gen_or_i32(t1, t1, tmp);\n\n    tcg_gen_mov_i32(t0, rd);\n\n\n\n    dead_tmp(tmp);\n\n    dead_tmp(rd);\n\n}\n", "idx": 11546, "substitutes": {"t0": ["p4", "pt1", "T0", "T1", " t4", "t100", "ct2", "pt100", "p100", "T10", "f0", "ct1", "t4", "t2", "pt2", "p2", " t10", "t10", "T2", " t2", "f2", "p1", "f100", "f4", "f1", "f10", "p10", "ct0", "p0", "pt0"], "t1": [" t9", "t6", "v2", "kt1", "p3", " t12", "kt2", "f6", "T0", "T1", "v1", "v01", "t01", "nt01", "T6", "f0", "f12", "t2", "t3", "nt1", " t3", "p2", "f3", "t12", "T3", "f01", "T2", " t2", "p1", "p9", "T9", "f2", "p01", "p12", "t9", "f1", " t6", " t01", "p0", "kt01", "nt2"], "rd": ["tr", "dat", "rw", "rt", "src", "diff", "hr", "ptr", "RD", "xd", "td", "rg", "adr", "ra", "md", "rob", "mr", "d", "dr", "ru", "rc", "lr", "wr", "rl", "ord", "rf", "ds", "rust", "rn", "nd", "ld", "vr", "rod", "red", "rb", "bd", "dc", "dd", "RB", "rx", "r", "std", "attr", "xx", "RR", "rm", "rs", "rr", "rh", "fd", "dra", "cd"], "tmp": ["rw", "rt", "src", "rc", "fb", "bb", "buff", "rm", "stuff", "nt", "eddy", "txt", "np", "tp", "mp", "rob", "etc", "db", "dist", "sb", "tm", "xxx", "rf", "img", "Temp", "vr", "test", "attr", "abb", "cro", "tr", "ptr", "vt", "buf", "ff", "now", "td", "pb", "TB", "config", "kk", "xxxxxxxx", "dd", "req", "py", "md", "cmp", "amp", "cb", "temp", "st", "cp", "bt", "rb", "tab", "xt", "mm", "tt", "tc", "wb", "fd"]}}
{"project": "FFmpeg", "commit_id": "6722e564a82bac471d92b02550b5017c09b539ba", "target": 0, "func": "static int parse_header(OutputStream *os, const uint8_t *buf, int buf_size)\n\n{\n\n    if (buf_size < 13)\n\n        return AVERROR_INVALIDDATA;\n\n    if (memcmp(buf, \"FLV\", 3))\n\n        return AVERROR_INVALIDDATA;\n\n    buf      += 13;\n\n    buf_size -= 13;\n\n    while (buf_size >= 11 + 4) {\n\n        int type = buf[0];\n\n        int size = AV_RB24(&buf[1]) + 11 + 4;\n\n        if (size > buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n        if (type == 8 || type == 9) {\n\n            if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extra_packets))\n\n                return AVERROR_INVALIDDATA;\n\n            os->extra_packet_sizes[os->nb_extra_packets] = size;\n\n            os->extra_packets[os->nb_extra_packets] = av_malloc(size);\n\n            if (!os->extra_packets[os->nb_extra_packets])\n\n                return AVERROR(ENOMEM);\n\n            memcpy(os->extra_packets[os->nb_extra_packets], buf, size);\n\n            os->nb_extra_packets++;\n\n        } else if (type == 0x12) {\n\n            if (os->metadata)\n\n                return AVERROR_INVALIDDATA;\n\n            os->metadata_size = size - 11 - 4;\n\n            os->metadata      = av_malloc(os->metadata_size);\n\n            if (!os->metadata)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(os->metadata, buf + 11, os->metadata_size);\n\n        }\n\n        buf      += size;\n\n        buf_size -= size;\n\n    }\n\n    if (!os->metadata)\n\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n\n}\n", "idx": 11553, "substitutes": {"os": ["ok", "oS", "pos", "bos", "los", "et", "oa", "iso", "bis", "OS", " bos", "ls", "oi", "ais", "oss", "uns", "xs", "ou", "oes", "is", "ks", "es", "rss", "des", "ois", "dos", "ants", "otes", "options", "osi", "ot", "ds", "ips", "mos", "fs", "boot", "io", "oos", "acs", "nos", "ots", "bs", "oid", "ns", "aos", "op", "ions", "css", "us", "o", "ets", "u", "od", "oses", "ow", "ros", "org", "oc", "obj", "as", "sys", "ob", "obs", "so", "of", "js", "mot", "ens", "ops", "object"], "buf": ["la", "text", "ctx", "src", "byte", "seq", "pack", "rc", "b", "fb", "queue", "uu", "bd", "mem", "bb", "cmd", "uf", "buff", "msg", "feat", "cas", "keep", "home", "raf", "result", "bag", "box", "cat", "img", "gen", "num", "header", "alloc", "length", "bin", "ab", "wa", "port", "bus", "aka", "block", "ff", "bc", "pb", "brace", "cur", "bh", "array", "begin", "row", "br", "que", "cf", "large", "pos", "vec", "bu", "cb", "loc", "Buff", "context", "feed", "rb", "cv", "us", "buffer", "func", "wb", "uc", "fd", "cap", "batch", "data", "cache"], "buf_size": ["buf64depth", "buf_depth", " buf_address", "buffside", " buf_capacity", "buf_capacity", "buf_scale", " buf_depth", "buf_speed", "buflexlen", " buf_len", "buflexsize", " buf_mode", "buf64side", "buffsize", "buf64capacity", "buf_SIZE", " buf_scale", "buf_address", " buf_si", "buff_len", "uf_SIZE", "buff_shape", "uf_scale", "buf_shape", "buff_speed", "uf_size", "buf_mode", "buf_len", " buf_side", "buf_side", "uf_shape", "buff_size", "buflexspeed", "buf64size", "buf_slice", "buf_si", "buffdepth", " buf_slice", "buffcapacity", "buflexshape"], "nb_extra_packets": ["nb_extra_packels", "nb_extra_comamples", "nb_extra_packhers", "nb_extra_pacet", "nb_extra_capets", "nb_extra_compets", "nb_extra_paramels", "nb_extra_paramhers", "nb_extra_apploads", "nb_extra_packsits", "nb_extra_comet", "nb_extra_appsets", "nb_extra_packses", "nb_extra_packals", "nb_extra_packsches", "nb_extra_compet", "nb_extra_capes", "nb_extra_compences", "nb_extra_pacences", "nb_extra_paramet", "nb_extra_flushences", "nb_extra_compes", "nb_extra_packssets", "nb_extra_flushets", "nb_extra_posloads", "nb_extra_pacets", "nb_extra_pacels", "nb_extra_capet", "nb_extra_pachers", "nb_extra_appals", "nb_extra_packloads", "nb_extra_packes", "nb_extra_appet", "nb_extra_poset", "nb_extra_packet", "nb_extra_flushet", "nb_extra_packamples", "nb_extra_packsloads", "nb_extra_comets", "nb_extra_posets", "nb_extra_compits", "nb_extra_possets", "nb_extra_packset", "nb_extra_flushls", "nb_extra_capits", "nb_extra_packshers", "nb_extra_packsamples", "nb_extra_packsets", "nb_extra_packls", "nb_extra_paces", "nb_extra_compls", "nb_extra_comals", "nb_extra_packits", "nb_extra_pacches", "nb_extra_packches", "nb_extra_pacls", "nb_extra_appets", "nb_extra_packsals", "nb_extra_appamples", "nb_extra_packences", "nb_extra_compches", "nb_extra_packsels", "nb_extra_paramets"]}}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "restore_sigcontext(CPUMIPSState *regs, struct target_sigcontext *sc)\n\n{\n\n    int err = 0;\n\n    int i;\n\n\n\n    __get_user(regs->CP0_EPC, &sc->sc_pc);\n\n\n\n    __get_user(regs->active_tc.HI[0], &sc->sc_mdhi);\n\n    __get_user(regs->active_tc.LO[0], &sc->sc_mdlo);\n\n\n\n    for (i = 1; i < 32; ++i) {\n\n        __get_user(regs->active_tc.gpr[i], &sc->sc_regs[i]);\n\n    }\n\n\n\n    __get_user(regs->active_tc.HI[1], &sc->sc_hi1);\n\n    __get_user(regs->active_tc.HI[2], &sc->sc_hi2);\n\n    __get_user(regs->active_tc.HI[3], &sc->sc_hi3);\n\n    __get_user(regs->active_tc.LO[1], &sc->sc_lo1);\n\n    __get_user(regs->active_tc.LO[2], &sc->sc_lo2);\n\n    __get_user(regs->active_tc.LO[3], &sc->sc_lo3);\n\n    {\n\n        uint32_t dsp;\n\n        __get_user(dsp, &sc->sc_dsp);\n\n        cpu_wrdsp(dsp, 0x3ff, regs);\n\n    }\n\n\n\n    for (i = 0; i < 32; ++i) {\n\n        __get_user(regs->active_fpu.fpr[i].d, &sc->sc_fpregs[i]);\n\n    }\n\n\n\n    return err;\n\n}\n", "idx": 11566, "substitutes": {"i": ["ii", "g", "ni", "abi", "li", "uri", "hi", "f", "id", "phi", "I", "diff", "api", "mu", "k", "ip", "oi", "mi", "fi", "adi", "y", "c", "yi", "iu", "a", "d", "multi", "ri", "p", "ji", "hei", "slice", "si", "z", "b", "pi", "io", "j", "gi", "ie", "part", "cli", "di", "ti", "xi", "bi", "zi", "v", "qi", "ind", "ui", "o", "l", "ci", "esi", "u", "index", "start", "m", "e", "n", "info", "init", "ai", "one", "eni", "name", "in", "x", "ix", "it"], "dsp": ["pdsh", "sdtp", "sdmp", "dbsp", "pdcap", "cdspace", "sdspace", "sdbsp", "bmp", "dtp", "cdsp", "pdspace", "dspace", "dsh", " dsh", "bbsp", "dcap", "Dsh", "pdsp", "pdisp", "bsp", "Dsp", "pdbsp", "btp", "sdcap", "Disp", "pdtp", "pdmp", "disp", "cdcap", "sdsp", "cdmp", "dmp", " disp"]}}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static void sdhci_write_block_to_card(SDHCIState *s)\n\n{\n\n    int index = 0;\n\n\n\n    if (s->prnsts & SDHC_SPACE_AVAILABLE) {\n\n        if (s->norintstsen & SDHC_NISEN_WBUFRDY) {\n\n            s->norintsts |= SDHC_NIS_WBUFRDY;\n\n        }\n\n        sdhci_update_irq(s);\n\n        return;\n\n    }\n\n\n\n    if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {\n\n        if (s->blkcnt == 0) {\n\n            return;\n\n        } else {\n\n            s->blkcnt--;\n\n        }\n\n    }\n\n\n\n    for (index = 0; index < (s->blksize & 0x0fff); index++) {\n\n        sd_write_data(s->card, s->fifo_buffer[index]);\n\n    }\n\n\n\n    /* Next data can be written through BUFFER DATORT register */\n\n    s->prnsts |= SDHC_SPACE_AVAILABLE;\n\n\n\n    /* Finish transfer if that was the last block of data */\n\n    if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||\n\n            ((s->trnmod & SDHC_TRNS_MULTI) &&\n\n            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {\n\n        SDHCI_GET_CLASS(s)->end_data_transfer(s);\n\n    } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) {\n\n        s->norintsts |= SDHC_NIS_WBUFRDY;\n\n    }\n\n\n\n    /* Generate Block Gap Event if requested and if not the last block */\n\n    if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) &&\n\n            s->blkcnt > 0) {\n\n        s->prnsts &= ~SDHC_DOING_WRITE;\n\n        if (s->norintstsen & SDHC_EISEN_BLKGAP) {\n\n            s->norintsts |= SDHC_EIS_BLKGAP;\n\n        }\n\n        SDHCI_GET_CLASS(s)->end_data_transfer(s);\n\n    }\n\n\n\n    sdhci_update_irq(s);\n\n}\n", "idx": 11592, "substitutes": {"s": ["server", "sym", "service", "cs", "self", "c", "a", "i", "ks", "d", "grades", "settings", "b", "sites", "gs", "e", "comments", "rs", "js", "status", "os", "site", "its", "ls", "ss", "uses", "ins", "rows", "sb", "http", "S", "ds", "session", "fs", "ssl", "o", "ses", "qs", "set", "tests", "changes", "f", "parts", "xs", "an", "services", "sg", "secondary", "in", "r", "ps", "l", "sync", "u", "south", "sys", "su", "features", "g", "args", "request", "state", "states", "uns", "sports", "is", "new", "es", "p", "ts", "si", "full", "sis", "se", "ns", "less", "spec", "us", "t", "your", "m", "conf", "sets", "this", "stats", "data", "ops"], "blkcnt": ["blKcno", "blkcnc", "blkcct", "blkCount", "blKcst", "blkscpt", "blkrcno", "blklcnt", "blqcant", "blKscount", "blkCpt", "blkCnt", "blkrcant", "blkscnt", "blKcnt", "blkacno", "blqdcnt", "blklcant", "blkacnt", "blkdcant", "blklcnc", "blkscno", "blqcnt", "blkrcnt", "blkcount", "blkcpt", "blKscct", "blKCount", "blKscno", "blKscnt", "blkdcct", "blklcno", "blkdcpt", "blKCst", "blklcount", "blkdcnt", "blkcant", "blkdcst", "blkdcno", "blkCnc", "blKcnc", "blkacct", "blkCct", "blkscant", "blkcno", "blKCno", "blqdcant", "blKcount", "blkscct", "blkCno", "blqdcct", "blqcct", "blKCnt", "blkscount", "blkrcnc", "blKcct", "blkdcount", "blqcpt", "blkcst", "blKCnc", "blKcant", "blkCst", "blqdcpt", "blKCant", "blkacount", "blklcst", "blkCant"], "index": ["action", "pos", "prefix", "block", "Index", "append", "pointer", "type", "match", "id", "diff", "size", "path", "weight", "date", "x", "connection", "option", "alpha", "ion", "search", "instance", "i", "fe", "offset", "condition", "si", "fee", "loc", "ticket", "position", "end", "key", "loop", "address", "in", "image", "row", "inc", "ind", "length", "insert", "level", "num", "val", "word", "old", "column", "body", "value", "section", "name", "page", "element", "data", "count", "number", "letter", "slice"]}}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static AHCIQState *ahci_boot(void)\n\n{\n\n    AHCIQState *s;\n\n    const char *cli;\n\n\n\n    s = g_malloc0(sizeof(AHCIQState));\n\n\n\n    cli = \"-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s\"\n\n        \",format=qcow2\"\n\n        \" -M q35 \"\n\n        \"-device ide-hd,drive=drive0 \"\n\n        \"-global ide-hd.ver=%s\";\n\n    s->parent = qtest_pc_boot(cli, tmp_path, \"testdisk\", \"version\");\n\n    alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT);\n\n\n\n    /* Verify that we have an AHCI device present. */\n\n    s->dev = get_ahci_device(&s->fingerprint);\n\n\n\n    return s;\n\n}\n", "idx": 11608, "substitutes": {"s": ["server", "g", "tests", "os", "args", "f", "sym", "service", "its", "cs", "state", "ls", " is", "sf", "ss", "states", "uns", "c", "sq", "is", "i", "a", "services", " shares", "sb", "d", "es", "p", "ts", "sg", "si", "S", "ds", "b", "fs", "ssl", "ows", "secondary", "sl", "ns", "client", "o", "t", "ps", "ses", "l", "your", "sync", "gs", "m", "sn", "south", "e", "n", "sys", "su", "rs", "or", "js", " ads", "aws"], "cli": ["binary", "CL", "li", "uri", "ctx", "GUI", "api", "ls", "seq", "mobile", "multi", "lo", "cgi", "cb", "sci", "rl", "http", "gz", "cm", "cu", "ctrl", "url", "shell", " CLI", "kl", "hi", "client", "prot", "cl", "ui", "gui", "cmd", "l", "ci", "conn", "sync", "lib", "util", "ln", "ctl", "lu", "lc", "cn", "cho", "exec", "acl"]}}
{"project": "qemu", "commit_id": "89ae337acbe4dba5b2481007aec1277252d2b86c", "target": 0, "func": "void address_space_destroy_dispatch(AddressSpace *as)\n\n{\n\n    AddressSpaceDispatch *d = as->dispatch;\n\n\n\n    memory_listener_unregister(&d->listener);\n\n    g_free(d);\n\n    as->dispatch = NULL;\n\n}\n", "idx": 11624, "substitutes": {"as": ["cas", "os", "parse", "at", "cs", "asp", "ss", "al", "a", "is", "instance", "an", "nas", "with", "asm", "b", "pas", "ident", "ars", "ass", "asha", "acs", "atts", "any", "ar", "ash", "bs", "asu", "ac", "ans", "ras", "As", "r", "ps", "am", "ap", "amd", "gs", "ast", "las", "this", "asse", "rs", "or", "s", "sa", "var", "asc", "ad", "AS", "x", "aws"], "d": ["g", "dat", "sd", "did", "del", "D", "md", "c", "gd", "db", "a", "mad", "patch", "pd", "p", "dos", "ds", "b", "driver", "nd", "ld", "bd", "z", "dc", "dd", "dn", "da", "l", "ded", "dx", "od", "m", "dh", "e", "dj", "s", "fd", "dl", "ad", "data", "dt", "cd"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "mst_fpga_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n\tmst_irq_state *s = (mst_irq_state *) opaque;\n\n\n\n\tswitch (addr) {\n\n\tcase MST_LEDDAT1:\n\n\t\treturn s->leddat1;\n\n\tcase MST_LEDDAT2:\n\n\t\treturn s->leddat2;\n\n\tcase MST_LEDCTRL:\n\n\t\treturn s->ledctrl;\n\n\tcase MST_GPSWR:\n\n\t\treturn s->gpswr;\n\n\tcase MST_MSCWR1:\n\n\t\treturn s->mscwr1;\n\n\tcase MST_MSCWR2:\n\n\t\treturn s->mscwr2;\n\n\tcase MST_MSCWR3:\n\n\t\treturn s->mscwr3;\n\n\tcase MST_MSCRD:\n\n\t\treturn s->mscrd;\n\n\tcase MST_INTMSKENA:\n\n\t\treturn s->intmskena;\n\n\tcase MST_INTSETCLR:\n\n\t\treturn s->intsetclr;\n\n\tcase MST_PCMCIA0:\n\n\t\treturn s->pcmcia0;\n\n\tcase MST_PCMCIA1:\n\n\t\treturn s->pcmcia1;\n\n\tdefault:\n\n\t\tprintf(\"Mainstone - mst_fpga_readb: Bad register offset \"\n\n\t\t\t\"0x\" TARGET_FMT_plx \" \\n\", addr);\n\n\t}\n\n\treturn 0;\n\n}\n", "idx": 11631, "substitutes": {"s": ["cs", "ments", "c", "a", "i", "ks", "d", "ings", "erences", "outs", "b", "itions", "native", "gs", "w", " values", "e", "rs", "or", "status", "ists", "js", "os", "its", "ls", " parts", "ers", "ies", "ins", "S", "scope", "session", "ds", "ows", "o", "ses", "qs", "submit", "er", "ports", " it", "als", "ums", "f", "ing", "y", "sg", "secondary", " defaults", " settings", "v", "ions", "ors", "r", "ps", "l", "sync", "sys", "irs", "g", " results", "states", "is", "instance", " statements", "new", "es", "ands", "p", "ts", "ed", "input", "t", "m", "sets", "ches"]}}
{"project": "qemu", "commit_id": "25f8e2f512d87f0a77fc5c0b367dd200a7834d21", "target": 0, "func": "static int pci_piix_ide_initfn(PCIIDEState *d)\n\n{\n\n    uint8_t *pci_conf = d->dev.config;\n\n\n\n    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode\n\n    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);\n\n\n\n    qemu_register_reset(piix3_reset, d);\n\n\n\n    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);\n\n\n\n    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);\n\n\n\n    pci_piix_init_ports(d);\n\n\n\n    return 0;\n\n}\n", "idx": 11635, "substitutes": {"d": ["dat", "dict", "sd", "f", "id", "did", "D", "dom", "td", "md", "c", "db", "gd", "i", "dr", "pd", "p", "dos", "ds", "b", "done", "nd", "ld", "vd", "bd", "v", "dc", "dd", "ind", "t", "o", "da", "l", "u", "dev", "od", "m", "dh", "dm", "e", "n", "dj", "s", "fd", "dl", "ad", "data", "dt", "cd"], "pci_conf": ["pki_conn", "pci__config", "pcm_spec", "pci_cfg", "pci_config", "pci_spec", "pci__conf", "pcm_config", "pki_conf", "pki_dev", "pcm_conn", "pci__dev", "pki_config", "pci_dev", "pcm_conf", "pci__conn", "pcm_cfg", "pci_conn"]}}
{"project": "qemu", "commit_id": "da3e8a23492dbc13c4b70d90b6ae42970624e63a", "target": 0, "func": "static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)\n\n{\n\n    DeviceState *qdev = DEVICE(vpci_dev);\n\n    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n\n\n    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);\n\n    virtio_net_set_netclient_name(&dev->vdev, qdev->id,\n\n                                  object_get_typename(OBJECT(qdev)));\n\n    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));\n\n    object_property_set_bool(OBJECT(vdev), true, \"realized\", errp);\n\n}\n", "idx": 11641, "substitutes": {"vpci_dev": ["vpio_div", "vpc_die", "vpcikdev", "vpci2debug", "vpci_serv", "vpci_device", "vpio_dev", "vpci_ver", "vpci2serv", "vpcu_dev", "vpcu2serv", "vpki_device", "vpci2ev", "vpcu_priv", "vpio_device", "vpci_priv", "vpci2device", "vpcu_debug", "vpci_div", "vpcu_device", "vpki_orig", "vpci2dev", "vpcu2dev", "vpc_dev", "vpci2ver", "vpcu2device", "vpki_dev", "vpci2die", "vpc_device", "vpci2priv", "vpcu_serv", "vpci_die", "vpci_ev", "vpcu2priv", "vpcikdebug", "vpc_ev", "vpcu_ver", "vpcikver", "vpcikev", "vpcu_ev", "vpci_orig", "vpci_debug"], "errp": ["errorpi", "rrp", "errorop", "err", "erfp", "errP", "errr", "errfp", "errf", "enerpi", "enerop", " errf", "errorp", " errop", "erp", "errorf", " errr", " errfp", "rrfp", "enerf", " errP", "rrP", "errop", "rrr", "erP", "enerp", " errpi", "errpi"], "qdev": ["qdef", "eqdev", "wdiv", "Qdiv", " qdata", "vdata", " qdevice", "dqdev", " qdef", "qdevice", "wdec", "qdec", " qdi", "wdevice", "pdiv", "Qdi", "qdi", "qdata", "eqdiv", "pdev", "pdevice", "pdec", "wdata", "dqdef", "eqdevice", "vdevice", "eqdec", " qdiv", "qdiv", "dqdiv", "Qdef", "wdev", "dqdi", "Qdev"], "dev": ["debug", "dem", "bus", "hw", "die", "block", " def", "wd", "id", "device", "diff", "host", "self", "serial", "develop", "rad", "private", "DEV", "adv", "gu", " Dev", "gd", "ver", "nov", "d", "ev", "mod", "development", "app", "driver", "Dev", "grad", "go", "di", "v", "dc", "dd", "ch", "req", "def", "conn", "od", "w", "conf", "info", "priv", "var", "ad", "data", "dt"], "vdev": ["qdef", "vDev", "vdef", "qudev", "Vdd", "wdef", "Vmod", "qdevice", "vmod", " vgu", "ndev", "vvar", "bdiv", "bdev", "qconn", "qDev", "fgu", "fvar", "qgu", "vvdevice", " vdevice", "lconn", "vdd", "vconn", "cDev", "cdevice", "fdevice", "vvgu", "qudevice", "qdd", " vdd", "bdd", "qmod", "Vdev", "vvdev", "ndiv", "vgu", "lgu", "ndevice", "cdiv", "wdd", "cdev", "vdevice", "ldevice", "qdiv", "ldev", " vdiv", "Vdef", "wdev", "bdevice", "vdiv", "wmod", " vconn", "nDev", "fdev", "quvar", "qvar"]}}
{"project": "qemu", "commit_id": "052495178821fdc97b4125a8677c1b68eb458db9", "target": 0, "func": "static void spapr_nvram_realize(VIOsPAPRDevice *dev, Error **errp)\n\n{\n\n    sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev);\n\n    int ret;\n\n\n\n    if (nvram->blk) {\n\n        nvram->size = blk_getlength(nvram->blk);\n\n\n\n        ret = blk_set_perm(nvram->blk,\n\n                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE,\n\n                           BLK_PERM_ALL, errp);\n\n        if (ret < 0) {\n\n            return;\n\n        }\n\n    } else {\n\n        nvram->size = DEFAULT_NVRAM_SIZE;\n\n    }\n\n\n\n    nvram->buf = g_malloc0(nvram->size);\n\n\n\n    if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {\n\n        error_setg(errp, \"spapr-nvram must be between %d and %d bytes in size\",\n\n                   MIN_NVRAM_SIZE, MAX_NVRAM_SIZE);\n\n        return;\n\n    }\n\n\n\n    if (nvram->blk) {\n\n        int alen = blk_pread(nvram->blk, 0, nvram->buf, nvram->size);\n\n\n\n        if (alen != nvram->size) {\n\n            error_setg(errp, \"can't read spapr-nvram contents\");\n\n            return;\n\n        }\n\n    } else if (nb_prom_envs > 0) {\n\n        /* Create a system partition to pass the -prom-env variables */\n\n        chrp_nvram_create_system_partition(nvram->buf, MIN_NVRAM_SIZE / 4);\n\n        chrp_nvram_create_free_partition(&nvram->buf[MIN_NVRAM_SIZE / 4],\n\n                                         nvram->size - MIN_NVRAM_SIZE / 4);\n\n    }\n\n\n\n    spapr_rtas_register(RTAS_NVRAM_FETCH, \"nvram-fetch\", rtas_nvram_fetch);\n\n    spapr_rtas_register(RTAS_NVRAM_STORE, \"nvram-store\", rtas_nvram_store);\n\n}\n", "idx": 11642, "substitutes": {"dev": ["tr", "dem", "phy", "device", "self", "proc", "dom", "serial", "serv", "rad", "DEV", "md", "gu", "ver", "gd", "ev", "mod", "plug", "app", "img", "Dev", "grad", "prom", "prof", "mem", "req", "def", "conn", "cam", "w", "conf", "dm", "obj", "fw", "data"], "errp": ["errc", "corr", "ersp", "Erc", " errcp", "err", "errsp", "erfp", "errP", " errc", "ErP", "errr", "corp", "errorg", "nerp", "errfp", "Err", " errsp", "erg", "errcp", "errb", "corsp", "ercp", "errorp", "errg", "corfp", "erp", " errr", " errfp", " errb", "errorr", " errP", "nerP", "erb", "erc", " errg", "nercp", "erP", "errorb", "Erp", "nerr"], "nvram": ["svcam", "vvpass", "nwcam", "vcdim", "navgam", "nwiam", "navram", "nvrom", "advmem", "lovram", "vcgram", "novlam", "nlcam", "nwream", "vvvm", "svream", "novgram", "nwgam", "navscan", "cvcam", "novram", "navrom", "nmgam", "advran", "vcgam", "nvgram", "svtm", "novcam", "lvram", "nmiam", "nvream", "nvirm", "cvgram", "navmem", "navapp", "ncmem", "cvvm", "vvrom", "novam", "nmgram", "NVram", "nwvm", "nllam", "ovapp", "ncgram", "nwram", "svgram", "lviam", "nwcom", "nwmem", "nvcamp", "ncgam", "NVapp", "nvcam", "advram", "ovgram", "nvam", "vvgam", "nmram", "lovcamp", "nvgam", "nlram", "nwlam", "lvgam", "nvran", "vvapp", "navcamp", "vciam", "nwam", "NVgram", "lvam", "naviam", "vvirm", "nwdim", "nwran", "nvpass", "nwtm", "nwpass", "nviam", "ncram", "NVrom", "navcam", "nvapp", "navgram", "svgam", "cvscan", "nvdim", "vvcom", "nwgram", "novmem", "nvtm", "nlmem", "ncdim", "svam", "lovgram", "nvcom", "nvlam", "vvram", "ovcam", "nvmem", "nmpass", "advgram", "lvgram", "cvcom", "nvvm", "vvlam", "cvcamp", "nvscan", "svram", "cvram", "vcran", "lvream", "nmlam", "vcram", "nlran", "vvcam", "vvgram", "cvmem", "svmem", "nccam", "vvtm", "sviam", "novran", "nwirm", "vcmem", "nlgram", "svirm", "ovram", "lovcam", "navlam", "svscan"], "ret": ["pass", "rets", "rt", "f", "att", "re", "RET", "ref", "ft", "result", "ur", "success", "len", "art", "sr", "rc", "cat", "back", "arr", "rf", "fun", "lit", "ct", "pt", "mt", "red", "t", "af", "val", "det", "pet", "def", "arg", "pat", "obj", "res", "nt", "reg", "fin", "alt", "Ret", "feat", "x"]}}
{"project": "qemu", "commit_id": "4b63a0df3bda8a2c278e45d9d94d9ba6d5791d8d", "target": 1, "func": "static void ehci_free_packet(EHCIPacket *p)\n\n{\n\n    trace_usb_ehci_packet_action(p->queue, p, \"free\");\n\n    if (p->async == EHCI_ASYNC_INFLIGHT) {\n\n        usb_cancel_packet(&p->packet);\n\n        usb_packet_unmap(&p->packet, &p->sgl);\n\n        qemu_sglist_destroy(&p->sgl);\n\n\n\n\n\n\n\n\n\n\n\n\n    QTAILQ_REMOVE(&p->queue->packets, p, next);\n\n    usb_packet_cleanup(&p->packet);\n\n    g_free(p);\n", "idx": 11646, "substitutes": {"p": ["g", "plugin", "np", "tp", "pointer", "f", "dp", "api", "k", "pl", "pb", "c", "pc", "a", "i", "jp", "d", "patch", "lp", "per", "sp", "pkg", "b", "pi", "cp", "queue", "j", "part", "P", "pre", "po", "fp", "pe", "op", "v", "press", "t", "o", "ps", "gp", "wp", "l", "q", "ap", "pp", "vp", "u", "point", "m", "e", "n", "pa", "pat", "s", "bp", "py", "ping", "data", "exec", "pid", "post"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(nv12ToUV)(uint8_t *dstU, uint8_t *dstV,\n\n                                    const uint8_t *src1, const uint8_t *src2,\n\n                                    long width, uint32_t *unused)\n\n{\n\n    RENAME(nvXXtoUV)(dstU, dstV, src1, width);\n\n}\n", "idx": 11662, "substitutes": {"dstU": ["dspI", "destY", "dvertU", " dSTP", "adstP", " dSTU", "dspP", "dSTY", "dspV", " dstY", "dvertP", "adSTI", "adstU", "adstV", "dstP", "destV", "dSTP", "adSTV", " dstP", "adSTU", "destP", "adSTP", " dSTV", "dstI", "dSTI", "dSTU", "destI", "dvertV", "adstI", "dspU", " dSTY", "dvertY", "dSTV", "dstY", "destU"], "dstV": [" dstF", " dSTU", "dSTF", "destv", "dstv", " dstI", "dSTv", " dSTI", "drcv", "dndv", "drcV", "dndI", " dSTF", "dndV", "destV", "dndU", " dSTV", "dstI", "dstF", "dSTI", "dSTU", " dSTv", "destI", "dSTV", "destF", "drcF", " dstv", "drcI", "destU"], "src1": ["dest0", " src8", "src8", "dest3", "dest1", "dest2", "st8", "src3", "st2", "st1", "rc1", "rc0", "src0", "rc8", " src3", "rc3", " srcN", "rcN", "stN", "rc2", "srcN", " src0"], "src2": ["rc3", "src3", "src4", "dest4", "dest3", "rc2", "dest1", "rc4", "rc1", " src3", " src4", "dest2"], "unused": ["unsprotected", "Unused", "uncprotected", "uncuse", "uncinitialized", "unsinitialized", "unsuse", "Uninitialized", "Unuse", "unprotected", "unuse", "Unprotected", "unsused", "uninitialized", "uncused"]}}
{"project": "FFmpeg", "commit_id": "30e256430eb88c6d4c382581b89bca171d79fbc0", "target": 0, "func": "int ff_thread_init(AVCodecContext *avctx)\n\n{\n\n    if (avctx->thread_opaque) {\n\n        av_log(avctx, AV_LOG_ERROR, \"avcodec_thread_init is ignored after avcodec_open\\n\");\n\n        return -1;\n\n    }\n\n\n\n#if HAVE_W32THREADS\n\n    w32thread_init();\n\n#endif\n\n\n\n    if (avctx->codec) {\n\n        validate_thread_parameters(avctx);\n\n\n\n        if (avctx->active_thread_type&FF_THREAD_SLICE)\n\n            return thread_init(avctx);\n\n        else if (avctx->active_thread_type&FF_THREAD_FRAME)\n\n            return frame_thread_init(avctx);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11665, "substitutes": {"avctx": ["apploc", " avtx", "avcf", "awcu", "AVcoll", "aveloc", "afci", "aftx", "awci", "avkb", "evcf", "afcb", "afcu", "Avctrl", "awctx", "averctrl", "afctrl", "ajcn", "avectx", "ajcontext", "afcoll", "ajcoll", "avci", "averctx", " avcontext", "awcontext", "AVconn", "avecontext", "appctx", "AVcontext", "avctrl", "avconn", "afcn", "ajcf", "afcontext", "AVctx", "afkb", "Avctx", "avtx", "avecb", "evcn", "avloc", "avercontext", "avcoll", "afconn", "ajctx", "appcontext", "AVcb", "avecmp", "afctx", "afcmp", " avkb", "avcmp", "avcontext", "evctx", "aveci", "avecoll", "avecf", "avcb", "ajkb", "afc", "appcmp", "avecu", "Avcontext", "Avtx", "ajtx", "avc", "avcu", "ajc", "afcf", "avertx", "AVcf", "afloc", "AVc", "avcn", "aveconn", "evcontext"]}}
{"project": "qemu", "commit_id": "a87f39543a9259f671c5413723311180ee2ad2a8", "target": 0, "func": "static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)\n\n{\n\n    if (memory_region_is_ram(mr)) {\n\n        return !(is_write && mr->readonly);\n\n    }\n\n    if (memory_region_is_romd(mr)) {\n\n        return !is_write;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 11674, "substitutes": {"mr": ["tr", "usr", "fr", "mir", "rt", "nr", "Mr", "hr", "mi", "wk", "mid", "ur", "rg", "adr", "MR", "sr", "eu", "dr", "rc", "lr", "pr", "tm", "rl", "rf", "fm", "vr", "mt", "rb", "yr", "mk", "r", "br", "kr", "attr", "shr", "ir", "rm", "m", "gr", "mm", "er", "rs", "rr", "mc", "rh", "mn"], "is_write": ["isPubleft", "is_read", "is_line", "any_write", "any_line", "is_left", "isPubread", "any_writing", "isPubwrite", "is_flow", " is_left", " is_written", "is_writing", " is_flow", "any_read", "is_written", " is_read"]}}
{"project": "qemu", "commit_id": "9db1c0f7a94c6382e2b3e1365566a9a8b8ae74c1", "target": 0, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, VirtIOBlkConf *blk)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!blk->conf.bs) {\n\n        error_report(\"drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(blk->conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!blk->serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(blk->conf.bs);\n\n        if (*dinfo->serial) {\n\n            blk->serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = blk->conf.bs;\n\n    s->conf = &blk->conf;\n\n    s->blk = blk;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, s->conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(s->conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 11685, "substitutes": {"dev": ["debug", "dem", "g", "vol", "bus", "de", "hw", "block", "device", "diff", "comment", "pro", "err", "dom", "DEV", "md", "gu", "ver", "gd", "user", "d", "ev", "development", "temp", "sh", "der", "Dev", "prof", "di", "v", "spec", "dd", "ch", "client", "error", "def", "conn", "sync", "w", "gr", "conf", "info", "ve", "data"], "blk": ["Blke", "elak", "Blak", "ilk", "ilsk", "plke", "blc", "slk", "Blk", "Blks", "blogkg", "plks", "belck", "belq", "llq", "slc", "brkg", " blks", " blck", "belk", "slck", "ilck", "brk", "blky", "blke", "flk", "plak", "plok", "elk", "blks", "belku", "slke", "blogk", "blok", "elck", "BLks", "ilak", "plsk", " blke", "BLke", "plc", "slak", "elke", "llk", "plku", " blq", "blck", "flks", "ilku", " blak", "brks", "plkg", "plq", "brsk", "plck", "blku", "BLk", " blok", "BLak", "ilok", " blky", "blkg", "llck", "flc", "flke", " blsk", "blq", " blku", "plky", "blogsk", "blsk", "slks", "llky", "blak", "blogks", "slok", "plk"], "s": ["server", "sym", "service", "cs", "self", "c", "a", "ks", "i", "d", "ves", "sh", "settings", "b", "hs", "gs", "w", "e", "init", "rs", "js", "sum", "os", "site", "its", "ls", "ss", "sq", "params", "sb", "h", "S", "ds", "session", "fs", "ssl", "o", "ses", "qs", "f", "sf", "an", "services", "sg", "ssh", "sl", "sim", "v", "r", "ps", "l", "sync", "u", "south", "sys", "su", "sk", "g", "args", "request", "state", "states", "uns", "is", "sup", "new", "es", "ts", "p", "si", "full", "ns", "spec", "us", "t", "m", "conf", "n", "sets", "sa"], "cylinders": ["yinders", "yishers", "kellishers", "ymishers", "ptyishers", "chambers", "cilishers", "kellambers", "yocks", "ptyinders", "kellinder", "cilocks", "cylambers", "ptyinder", "ymocks", "cylinder", "chinder", "chinders", "cilinder", "cylocks", "ptyambers", "yminder", "yminders", "cilinders", "cylishers", "chishers", "yinder", "kellinders"], "heads": ["tests", "opens", "shows", "devices", "scenes", "views", "checks", "ids", "ks", "HEAD", "rows", "mods", "blocks", "headers", "outs", "tops", "hops", "tails", "pages", "modules", "loads", "sections", "olds", "clips", "frames", "jobs", "plugins", "head", "height", "links", "bits", "obs", "holes", "locks", "depth", "ops", "drivers", "features"], "secs": ["regs", "regblocks", " sectests", "ecttests", "seces", "incs", "desces", "incsets", "ects", " secsets", "incports", "sectests", "Secondblocks", "descls", "Secondls", "secports", "secls", "regls", " secports", "ectsets", "descblocks", "inctests", "descs", "ectports", "secblocks", "secsets", "reges", "Seconds", "Secondes"], "virtio_blk_id": ["virtio_blks_id", "virtio_blck_name", "virtio_blk_type", "virtio_blck_info", "virtio_blk_info", "virtio_blks_type", "virtio_blck_root", "virtio_blck_id", "virtio_blk_f", "virtio_blk_root", "virtio_blks_name", "virtio_blks_f", "virtio_blk_name"], "dinfo": ["ldinfo", " did", " dvar", "ddata", "ldinf", "dsinfo", "did", "lderror", " derror", "dsinf", "pinfo", "dInfo", "linfo", "finfo", "lddata", "pinf", "fdinfo", "adinf", "fdInfo", "derror", "lid", "finit", "adinfo", "sdinf", "finf", "fdinit", "sdvar", "aderror", " dinf", "sdid", "fInfo", "dinit", "addata", " ddata", "dsvar", "dinf", " dinit", "dsid", "sdinfo", "lerror", " dInfo", "fdinf", "pid", "dvar", "linf"]}}
{"project": "FFmpeg", "commit_id": "e048a9cab10f1d41dca7b1ad9c8ecaceb3424d86", "target": 1, "func": "static int pcm_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    PCMDecode *s = avctx->priv_data;\n    int sample_size, c, n, i;\n    short *samples;\n    const uint8_t *src, *src8, *src2[MAX_CHANNELS];\n    uint8_t *dstu8;\n    int16_t *dst_int16_t;\n    int32_t *dst_int32_t;\n    int64_t *dst_int64_t;\n    uint16_t *dst_uint16_t;\n    uint32_t *dst_uint32_t;\n    samples = data;\n    src = buf;\n    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample_fmt\\n\");\n        return -1;\n    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){\n        av_log(avctx, AV_LOG_ERROR, \"PCM channels out of bounds\\n\");\n        return -1;\n    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;\n    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */\n    if (CODEC_ID_PCM_DVD == avctx->codec_id)\n        /* 2 samples are interleaved per block in PCM_DVD */\n        sample_size = avctx->bits_per_coded_sample * 2 / 8;\n    else if (avctx->codec_id == CODEC_ID_PCM_LXF)\n        /* we process 40-bit blocks per channel for LXF */\n        sample_size = 5;\n    n = avctx->channels * sample_size;\n    if(n && buf_size % n){\n        if (buf_size < n) {\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCM packet\\n\");\n            return -1;\n        }else\n            buf_size -= buf_size % n;\n    buf_size= FFMIN(buf_size, *data_size/2);\n    *data_size=0;\n    n = buf_size/sample_size;\n    switch(avctx->codec->id) {\n    case CODEC_ID_PCM_U32LE:\n        DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000)\n        break;\n    case CODEC_ID_PCM_U32BE:\n        DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000)\n        break;\n    case CODEC_ID_PCM_S24LE:\n        DECODE(int32_t, le24, src, samples, n, 8, 0)\n        break;\n    case CODEC_ID_PCM_S24BE:\n        DECODE(int32_t, be24, src, samples, n, 8, 0)\n        break;\n    case CODEC_ID_PCM_U24LE:\n        DECODE(uint32_t, le24, src, samples, n, 8, 0x800000)\n        break;\n    case CODEC_ID_PCM_U24BE:\n        DECODE(uint32_t, be24, src, samples, n, 8, 0x800000)\n        break;\n    case CODEC_ID_PCM_S24DAUD:\n        for(;n>0;n--) {\n          uint32_t v = bytestream_get_be24(&src);\n          v >>= 4; // sync flags are here\n          *samples++ = av_reverse[(v >> 8) & 0xff] +\n                       (av_reverse[v & 0xff] << 8);\n        break;\n    case CODEC_ID_PCM_S16LE_PLANAR:\n        n /= avctx->channels;\n        for(c=0;c<avctx->channels;c++)\n            src2[c] = &src[c*n*2];\n        for(;n>0;n--)\n            for(c=0;c<avctx->channels;c++)\n                *samples++ = bytestream_get_le16(&src2[c]);\n        src = src2[avctx->channels-1];\n        break;\n    case CODEC_ID_PCM_U16LE:\n        DECODE(uint16_t, le16, src, samples, n, 0, 0x8000)\n        break;\n    case CODEC_ID_PCM_U16BE:\n        DECODE(uint16_t, be16, src, samples, n, 0, 0x8000)\n        break;\n    case CODEC_ID_PCM_S8:\n        dstu8= (uint8_t*)samples;\n        for(;n>0;n--) {\n            *dstu8++ = *src++ + 128;\n        samples= (short*)dstu8;\n        break;\n#if HAVE_BIGENDIAN\n    case CODEC_ID_PCM_F64LE:\n        DECODE(int64_t, le64, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S32LE:\n    case CODEC_ID_PCM_F32LE:\n        DECODE(int32_t, le32, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S16LE:\n        DECODE(int16_t, le16, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F64BE:\n    case CODEC_ID_PCM_F32BE:\n    case CODEC_ID_PCM_S32BE:\n    case CODEC_ID_PCM_S16BE:\n#else\n    case CODEC_ID_PCM_F64BE:\n        DECODE(int64_t, be64, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F32BE:\n    case CODEC_ID_PCM_S32BE:\n        DECODE(int32_t, be32, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S16BE:\n        DECODE(int16_t, be16, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F64LE:\n    case CODEC_ID_PCM_F32LE:\n    case CODEC_ID_PCM_S32LE:\n    case CODEC_ID_PCM_S16LE:\n#endif /* HAVE_BIGENDIAN */\n    case CODEC_ID_PCM_U8:\n        memcpy(samples, src, n*sample_size);\n        src += n*sample_size;\n        samples = (short*)((uint8_t*)data + n*sample_size);\n        break;\n    case CODEC_ID_PCM_ZORK:\n        for(;n>0;n--) {\n            int x= *src++;\n            if(x&128) x-= 128;\n            else      x = -x;\n            *samples++ = x << 8;\n        break;\n    case CODEC_ID_PCM_ALAW:\n    case CODEC_ID_PCM_MULAW:\n        for(;n>0;n--) {\n            *samples++ = s->table[*src++];\n        break;\n    case CODEC_ID_PCM_DVD:\n        dst_int32_t = data;\n        n /= avctx->channels;\n        switch (avctx->bits_per_coded_sample) {\n        case 20:\n            while (n--) {\n                c = avctx->channels;\n                src8 = src + 4*c;\n                while (c--) {\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);\n                src = src8;\n            break;\n        case 24:\n            while (n--) {\n                c = avctx->channels;\n                src8 = src + 4*c;\n                while (c--) {\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n                src = src8;\n            break;\n        default:\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n            return -1;\n            break;\n        samples = (short *) dst_int32_t;\n        break;\n    case CODEC_ID_PCM_LXF:\n        dst_int32_t = data;\n        n /= avctx->channels;\n        //unpack and de-planerize\n        for (i = 0; i < n; i++) {\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n                //extract low 20 bits and expand to 32 bits\n                *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) |\n                                 ((src8[2] & 0xF) << 8) | src8[1];\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n                //extract high 20 bits and expand to 32 bits\n                *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) |\n                                 ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4);\n        src += n * avctx->channels * 5;\n        samples = (short *) dst_int32_t;\n        break;\n    default:\n        return -1;\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n    return src - buf;", "idx": 11712, "substitutes": {"avctx": ["afca", "navctx", "afconfig", "avcf", "navcmp", "aveloc", "afpkg", "afcmd", "avbc", "afclient", "navloc", "alca", " avcmd", "evcf", "aveclient", "alctx", "avcca", "afcb", "afcu", "avepkg", "akctx", "navconv", "attloc", "afctrl", "AVcu", "vercb", "verconv", "avectx", " avcu", "akcontext", "navcontext", "navpkg", "avcmd", "devcmp", " avcontext", "attctx", "verconn", "afconv", "avca", "abpkg", "attcontext", "evbc", "verpkg", "AVconn", "avclient", "avecontext", "AVcontext", "vercf", "alcontext", "akctrl", "avctrl", "navctrl", "avconn", "evconn", "afcontext", "avconfig", "AVctx", "abcmp", " avca", "AVconfig", "vercontext", "avecb", "abcontext", "avloc", "afcca", "avpkg", "avconv", "abcf", "afconn", "alcmd", " avbc", "aveconfig", " avclient", "devcontext", "akconn", "devctx", " avcf", "avecca", "afctx", "navconn", "afcmp", "avcmp", "avcontext", "evctx", " avc", "attcf", "devcf", "avecf", "avcb", "afc", "abconn", "avecu", "avc", "avcu", "afbc", "abctx", "navcca", "afcf", "afloc", "evloc", " avconn", "verctx", "AVc", "vercmp", "aveconn", "navcf", "abctrl", "evcontext"], "data": ["dat", "message", "block", "empty", "size", "f", "sample", "Data", "mu", "result", "media", "a", "d", "DATA", "config", "bytes", "p", "response", "input", "content", "arr", "b", "blocks", "results", "queue", "load", "frame", "array", "memory", "tmp", "image", "dd", "reader", "source", "da", "val", "channel", "r", "next", "buff", "buffer", "body", "raw", "video", "stream", "window", "batch", "slice", "cache"], "data_size": ["cap_content", "wave_size", "channel_offset", "cap_shape", "data_small", "wave_shape", "data_number", "data_scale", "cap_size", "wave_number", "cap_range", "data_shape", "data_content", "channel_small", "wave_scale", "data_sized", "data_offset", "channel_sized", "data_range", "channel_size"], "avpkt": ["avcpct", "avckt", "ajpacket", "avfnt", "ajpmt", "avnpconn", "AVvpconn", "avpacket", "avlpeth", "avvpconn", "avppkt", "AVpk", "navpeth", "navpkg", "navlpkt", "avvpct", "avfpconn", "avvpk", "navlpkg", "avpconn", "AVpconn", "ajpcmt", "navpct", "avfacket", "avpkg", "avpct", "avnpk", "avceth", "avcpkg", "avlpkg", "avpk", "avpeth", "avpcnt", "avpmt", "avckg", "avpcacket", "avcpeth", "avlpkt", "avnpkt", "avvpkt", "navpkt", "avfpkt", "avfpk", "ajpckt", "avlpct", "avcpkt", "navlpeth", "ajpcnt", "AVpkt", "avpcmt", "ajpcacket", "AVvpk", "avppnt", "AVvpkt", "ajpnt", "avppacket", "avpckt", "AVvpct", "ajpkt", "navlpct", "avpnt", "avfpct", "avppmt", "avfmt", "avnpct", "avcct", "avfkt", "AVpct"], "buf": ["cas", "block", "ctx", "f", "vec", "ff", "bc", "bag", "seq", "pb", "box", "config", "rc", "cb", "p", "b", "fb", "queue", "img", "rb", "array", "bd", "fp", "cv", "tmp", "v", "alloc", "Buffer", "uf", "cf", "buff", "map", "buffer", "pad", "port", "wb", "cap"], "s": ["g", "f", "ss", "a", "d", "sv", "sb", "p", "sg", "S", "session", "b", "ssl", "ns", "v", "spec", "r", "ses", "sc", "sync", "gs", "w", "m", "e", "sys", "sa", "stats"], "sample_size": ["ample_time", " sample_scale", "sample_mode", "samplelexuse", "slice_content", "sample2scale", "buf_scale", "ample_size", "sample67time", "sample2size", "sample_content", "mix_mode", "sample2speed", "samplelexshape", " sample_speed", "samplelexterm", "slice_size", "sample_shape", "ample_speed", "sample_sized", "sample67shape", "sample2sized", "ample_body", "samplelexscale", "ample_fee", "sample_use", "sample_time", "sample_body", "samplelexsize", "samplelexsized", "sample67size", "mix_scale", "ample_term", "mix_size", "sample_page", "slice_page", "sample_term", "ample_shape", "sample_fee", "sample_scale", "sample67term", " sample_sized", "mix_sized", "buf_use", "slice_sized", "sample_speed", "buf_size", "samplelextime", "buf_sized"], "c": ["g", "f", "k", "nc", "d", "h", "p", "b", "cm", "con", "cc", "z", "v", "C", "dc", "o", "r", "l", "ci", "cf", "u", "w", "m", "e", "cn", "count", "x"], "n": ["ne", "g", "ni", "np", "size", "f", "un", "pn", "k", "nc", "nb", "y", "len", "network", "en", "N", "d", "h", "p", "b", "net", "j", "ns", "v", "z", "C", "num", "nan", "o", "r", "t", "all", "l", "conn", "u", "w", "m", "nn", "sn", "e", "cn", "nt", "number", "x"], "i": ["ii", "ni", "li", "f", "I", "k", "ip", "mi", "y", "ini", "d", "p", "si", "b", "pi", "j", "di", "v", "o", "l", "ci", "u", "index", "m", "e", "x"], "samples": ["slamps", "nources", "sources", "dannels", "sample", "slources", "dources", "suffamples", "fample", "fources", "famples", "suffample", "slample", "namples", "samps", "sannels", "suffources", "Samples", "famps", "Sources", "slamples", "damples", "Sannels", "suffamps", "nannels"], "src": ["sur", "dest", "ctx", "ptr", "host", "comp", "result", "sel", "sub", "seq", "dist", "sb", "rc", "config", "cb", "input", "loc", "b", "inst", "ssl", "img", "url", "sl", "rb", "tmp", "cv", "source", "attr", "sc", "sync", "lib", "rec", "func", "RC", "rs", "stream", "slice"], "src8": ["rc8", "rc16", " src16", "src16", "dest16", "rc2", "dest8", "dest2"], "src2": ["src0", "src_", "source0", "rc_", "source1", "rc2", "source2", "rc1", "source_", " src1", "rc0", " src0", "src1", " src_"], "MAX_CHANNELS": ["MAX_CHANEL", "MAX_CHANCELS", "MAX_CHANNETS", "MAX_ChANCES", "MAX_CHANGELS", "MAX_CHANNERS", "MAX_CHANCES", "MAX_CHANCEL", "MAX_CHANNES", "MAX_ChANNES", "MAX_CHANGES", "MAX_CHANNEL", "MAX_CHANGEL", "MAX_CHANES", "MAX_ChANNERS", "MAX_CHANELS", "MAX_CHANGETS", "MAX_ChANCELS", "MAX_ChANCEL", "MAX_CHANERS", "MAX_CHANCETS", "MAX_ChANNELS", "MAX_CHANETS", "MAX_ChANCERS", "MAX_CHANCERS", "MAX_ChANNEL", "MAX_CHANGERS"], "dstu8": ["dstu2", "dstsui6", "dstU8", "dstuint8", "dstu32", "dstU32", "dstU2", "dstui6", "dstui2", "dstsu6", "dstsui32", "dstuint2", "dstsu2", "dstsui8", "dstsui2", "dstuint6", "dstui8", "dstU6", "dstsu32", "dstsu8", "dstuint32", "dstu6", "dstui32"], "dst_int16_t": ["dst_int16_s", "dst_int32_l", "dst_int32_T", "dst_int16_l", "dst_int32_s", "dst_int16_T"], "dst_int32_t": ["dst_int32Jf", "dst_int64_f", "dst_int32JT", "dst_int32_type", "dst_int32_f", "dst_int32_T", "dst_int32Jt", "dst_int64_type", "dst_int64_T", "dst_int32Jtype"], "dst_int64_t": ["dst_int64_d", "dst_int64JT", "dst_int16_s", "dst_int16_d", "dst_int64Jt", "dst_int64Jd", "dst_int64_s", "dst_int64_T", "dst_int16_T", "dst_int64Js"], "dst_uint16_t": ["dst_uint16_p", "dst_uint32_T", "dst_uint32_p", "dst_uint32_s", "dst_uint16_T", "dst_uint16_s"], "dst_uint32_t": ["dst_uint64_s", "dst_uint32_wt", "dst_uint64_T", "dst_uint32_T", "dst_uint64_wt", "dst_uint32_s", "dst_uint64_t"]}}
{"project": "qemu", "commit_id": "599d64f6dc10f267a45e7abebfcafd8e7626585b", "target": 1, "func": "static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                             uint64_t value)\n\n{\n\n    if (ri->crm > 8) {\n\n        return EXCP_UDEF;\n\n    }\n\n    env->cp15.c6_region[ri->crm] = value;\n\n    return 0;\n\n}\n", "idx": 11714, "substitutes": {"env": ["server", "ne", "ea", "chal", "engine", "db", "en", "eu", "eval", "config", "ev", "enable", "enc", "ace", "si", "iss", "scope", "net", "enh", "shell", "core", "iv", "viron", "code", "environment", "que", "txt", "her", "conn", "esi", "conf", "inet", "e", "eur", "ec", "eni", "erv", "manager", "exec", "esp", "cache"], "ri": ["ii", "ni", "abi", "li", "uri", "rt", "ati", "mi", "RI", "ari", "ski", "rio", "rg", "adr", "adi", "ki", "ini", "i", "udi", "sr", "ani", "si", "pi", "io", "ori", "gi", "rb", "stri", "ris", "di", "ti", "xi", "reci", "ci", "rin", "ai", "rid", "rs", "eni", "iri", "vi"], "value": ["VALUE", "server", "uri", "size", "type", "id", "format", "service", "state", "values", "result", "write", "i", "feature", "si", "fee", "end", "rule", "scale", "key", "address", "v", "record", "image", "entry", "val", "area", "resource", "index", "reference", "region", "Value", "info", "port", "name", "data", "number"]}}
{"project": "qemu", "commit_id": "036078475427f2562c8e505f6bb44dbf5d8cbd95", "target": 1, "func": "static int usb_host_open(USBHostDevice *dev, int bus_num,\n\n                         int addr, const char *port,\n\n                         const char *prod_name, int speed)\n\n{\n\n    int fd = -1, ret;\n\n\n\n    trace_usb_host_open_started(bus_num, addr);\n\n\n\n    if (dev->fd != -1) {\n\n        goto fail;\n\n    }\n\n\n\n    fd = usb_host_open_device(bus_num, addr);\n\n    if (fd < 0) {\n\n        goto fail;\n\n    }\n\n    DPRINTF(\"husb: opened %s\\n\", buf);\n\n\n\n    dev->bus_num = bus_num;\n\n    dev->addr = addr;\n\n    strcpy(dev->port, port);\n\n    dev->fd = fd;\n\n\n\n    /* read the device description */\n\n    dev->descr_len = read(fd, dev->descr, sizeof(dev->descr));\n\n    if (dev->descr_len <= 0) {\n\n        perror(\"husb: reading device data failed\");\n\n        goto fail;\n\n    }\n\n\n\n#ifdef DEBUG\n\n    {\n\n        int x;\n\n        printf(\"=== begin dumping device descriptor data ===\\n\");\n\n        for (x = 0; x < dev->descr_len; x++) {\n\n            printf(\"%02x \", dev->descr[x]);\n\n        }\n\n        printf(\"\\n=== end dumping device descriptor data ===\\n\");\n\n    }\n\n#endif\n\n\n\n\n\n    /* start unconfigured -- we'll wait for the guest to set a configuration */\n\n    if (!usb_host_claim_interfaces(dev, 0)) {\n\n        goto fail;\n\n    }\n\n\n\n    usb_ep_init(&dev->dev);\n\n    usb_linux_update_endp_table(dev);\n\n\n\n    if (speed == -1) {\n\n        struct usbdevfs_connectinfo ci;\n\n\n\n        ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);\n\n        if (ret < 0) {\n\n            perror(\"usb_host_device_open: USBDEVFS_CONNECTINFO\");\n\n            goto fail;\n\n        }\n\n\n\n        if (ci.slow) {\n\n            speed = USB_SPEED_LOW;\n\n        } else {\n\n            speed = USB_SPEED_HIGH;\n\n        }\n\n    }\n\n    dev->dev.speed = speed;\n\n    dev->dev.speedmask = (1 << speed);\n\n    if (dev->dev.speed == USB_SPEED_HIGH && usb_linux_full_speed_compat(dev)) {\n\n        dev->dev.speedmask |= USB_SPEED_MASK_FULL;\n\n    }\n\n\n\n    trace_usb_host_open_success(bus_num, addr);\n\n\n\n    if (!prod_name || prod_name[0] == '\\0') {\n\n        snprintf(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                 \"host:%d.%d\", bus_num, addr);\n\n    } else {\n\n        pstrcpy(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                prod_name);\n\n    }\n\n\n\n    ret = usb_device_attach(&dev->dev);\n\n    if (ret) {\n\n        goto fail;\n\n    }\n\n\n\n    /* USB devio uses 'write' flag to check for async completions */\n\n    qemu_set_fd_handler(dev->fd, NULL, async_complete, dev);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    trace_usb_host_open_failure(bus_num, addr);\n\n    if (dev->fd != -1) {\n\n        close(dev->fd);\n\n        dev->fd = -1;\n\n    }\n\n    return -1;\n\n}\n", "idx": 11742, "substitutes": {"dev": ["server", "dem", "die", "mount", "comment", "self", "serial", "adv", "ver", "d", "ev", "development", "sh", "gh", "driver", "mem", "ch", "cmd", "w", "ow", "info", "nt", "root", "ve", "inst", "sd", "pub", "id", "api", "serv", "result", "user", "dist", "off", "mod", "enc", "test", "grad", "end", "fail", "error", "link", "conn", "var", "ad", "av", "exec", "dt", "debug", "valid", "hw", "de", "block", "diff", "dom", "rad", "engine", "DEV", "gu", "cur", "boot", "app", "prof", "di", "v", "dd", "req", "start", "current", "priv", "bug", "group", "g", "wd", "device", "md", "gd", "node", "dr", "new", "temp", "der", "Dev", "vd", "go", "dc", "client", "val", "def", "od", "cam", "conf", "dm", "this", "data", "cache"], "bus_num": ["bus_nu", "bus2name", "bus2number", "bus_dim", "bus_orig", "bus_name", "busvalunit", "busvalname", "usb_number", "boot_nu", "bus__num", "boot_number", "usb_info", "bus__number", "boot_mu", "usb_orig", "bus_info", "bus__info", "bus2nu", "bus__name", "busvalorig", "boot_dim", "usb_num", "bus_unit", "usb_name", "bus_number", "boot_len", "usb_unit", "bus_len", "boot_name", "bus__nu", "bus2num", "bus_mu", "boot_num", "busvalnum"], "addr": ["hop", "server", "oa", "pos", "wd", "prefix", "ack", "rt", "args", "nr", "id", "mode", "device", "src", "ptr", "api", "ref", "ip", "eth", "host", "handle", "adr", "md", "route", "node", "amp", "dr", "coord", "rc", "p", "offset", "ace", "farm", "loc", "bridge", "ord", "pkg", "orig", "work", "url", "vr", "ext", "part", "address", "dc", "dd", "spec", "arm", "layer", "r", "attr", "cmd", "mac", "point", "conn", "amd", "od", "pad", "rr", "Address", "fd", "name", "alt", "ad", "alias", "align", "nm"], "port": ["server", "plugin", "pos", "prop", "version", "pipe", "pass", "PORT", "type", "mode", "id", "device", "format", "path", "ptr", "ip", "host", "Port", "route", "method", "duration", "config", "p", "ort", "driver", "socket", "url", "direction", "pt", "address", "prot", "num", "length", "source", "platform", "cmd", "conn", "proxy", "unit", "fd", "name", "tun", "target", "ports", "dir", "pid"], "prod_name": ["prod2name", "prod_Name", "prod2type", "prol_name", "prod__name", "prod__names", "prol_path", "prod__path", "prop_names", "prod2Name", "prodacname", "proc_type", "proc_name", "proc_number", "prod_names", "prod_number", "prodaccomment", "prod_type", "prol_names", "prod2names", "prol__path", "prop_type", "prop_Name", "proc_comment", "prol__names", "prodactype", "prol__name", "prop_name", "prod_comment", "prodacnumber", "prod_path"], "speed": ["slow", "peed", "service", "score", "write", "fee", "sp", "settings", "driver", "sex", "time", "power", "priority", "sn", "status", "performance", "size", "limit", "weight", "ss", "strength", "rss", "ssl", "shape", "length", "effect", "sort", "error", "force", "spin", "fast", "delay", "rank", "rate", "send", "stop", "capacity", "wait", "mode", "sw", "mph", "engine", "method", "step", "direction", "sl", "scale", "gain", "source", "sync", "start", "Speed", "powered", "sk", "name", "cost", "timeout", "type", "device", "state", "quality", "sign", "sleep", "dy", "lane", "order", "si", "seed", "style", "feed", "se", "spec", "scroll", "level", "unit", "fd", "stream", "grade", "skip", "slice"], "ret": ["pass", "rt", "f", "wait", "id", "rets", "resp", "re", "RET", "att", "ref", "match", "mer", "rev", "ft", "result", "bc", "success", "len", "db", "art", "rc", "back", "rl", "arr", "sat", "fun", "lit", "j", "flag", "pt", "red", "ash", "part", "rb", "rot", "fail", "val", "det", "def", "conn", "arg", "reply", "pat", "obj", "res", "reg", "nt", "out", "fin", "alt", "Ret", "data", "count", "let"], "x": ["pos", "ax", "ctx", "id", "xc", "sw", "k", "wx", "xs", "y", "c", "X", "ux", "ex", "i", "xy", "xa", "h", "p", "xxx", "lex", "px", "work", "j", "ext", "key", "z", "code", "xi", "v", "ww", "pe", "num", "rx", "t", "r", "val", "fx", "index", "xx", "dx", "u", "w", "wa", "tx", "e", "n", "xp", "ix"], "ci": ["ii", "ni", "li", "uri", "ati", "ctx", "mi", "fi", "ce", "cci", "c", "ki", "ini", "i", "co", "cgi", "sci", "si", "pi", "cm", "io", "cu", "ct", "ctrl", "interface", "ie", "cli", "di", "dc", "bi", "ui", "cf", "conn", "CI", "oci", "cod", "init", "uci", "info", "ai", "eni", "py", "bug", "vi"]}}
{"project": "qemu", "commit_id": "fa617181839741727d0067ea68807133f498f29b", "target": 1, "func": "static int esp_pci_scsi_init(PCIDevice *dev)\n\n{\n\n    PCIESPState *pci = PCI_ESP(dev);\n\n    DeviceState *d = DEVICE(dev);\n\n    ESPState *s = &pci->esp;\n\n    uint8_t *pci_conf;\n\n    Error *err = NULL;\n\n\n\n    pci_conf = dev->config;\n\n\n\n    /* Interrupt pin A */\n\n    pci_conf[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    s->dma_memory_read = esp_pci_dma_memory_read;\n\n    s->dma_memory_write = esp_pci_dma_memory_write;\n\n    s->dma_opaque = pci;\n\n    s->chip_id = TCHI_AM53C974;\n\n    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,\n\n                          \"esp-io\", 0x80);\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);\n\n    s->irq = pci_allocate_irq(dev);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, &err);\n\n        if (err != NULL) {\n\n\n            error_free(err);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 11748, "substitutes": {"dev": ["debug", "dem", "tr", "de", "hw", "die", "device", "diff", "pro", "devices", "comment", "self", "dom", "serial", "rad", "engine", "md", "DEV", "ver", "nov", "ev", "mod", "development", "temp", "sh", "app", "driver", "Dev", "grad", "vd", "prom", "prof", "di", "v", "dc", "spec", "ch", "req", "def", "conn", "dim", "od", "w", "cam", "conf", "dm", "info", "sk", "priv", "ad", "ve", "data", "bug"], "pci": ["vpcin", " pcin", "pki", "spcli", "spii", "epki", "pcm", "ppci", "cpci", " psi", "wpcin", "cpdi", "pcli", "apdi", "cppi", "eppi", "spcu", "ppcit", "wpci", "spsi", "bsi", "cpcin", "Pki", "upii", "cpcm", "apii", "Pcm", "bci", "lpcm", "epci", "cpsi", "bpi", "ppki", "pii", "cpii", " pcli", "pcci", " pki", "wpcm", "wpcci", "pcin", "pcit", "apci", "persi", "Pci", "spcin", "pcu", "pdi", "ppcm", "lpki", "lppi", "psi", "vpcli", "ppi", " pcm", "vpci", "bki", "epsi", "percu", "spki", "Pcit", "upci", "updi", " pii", "uppi", "cpcit", " pcci", "perci", "Ppi", " ppi", "lpci", "cpki", "perki", "vpii", "spci", " pcu", "appi", "cpcci"], "d": ["dat", "g", "dict", "sd", "f", "dp", "id", "device", "D", "dom", "md", "c", "db", "gd", "i", "dr", "config", "pd", "p", "ds", "b", "driver", "ld", "bd", "di", "dc", "dd", "dn", "o", "t", "cmd", "ded", "od", "w", "m", "dh", "dm", "e", "fd", "ad", "data", "dt", "cd", "dad"], "s": ["tests", "g", "os", "sd", "args", "f", "sym", "cs", "ls", "self", "ss", "uns", "c", "is", "i", "services", "sb", "new", "h", "p", "ts", "sg", "sp", "S", "ds", "b", "settings", "session", "ssl", "si", "fs", "sl", "bs", "ns", "v", "spec", "hs", "o", "r", "t", "ps", "ses", "l", "qs", "u", "sync", "gs", "w", "m", "e", "n", "sys", "su", "rs", "js", "data", "aws"], "pci_conf": ["pili__conf", "pci_con", "pci_info", "pdi_conf", "pili__cache", "pili_con", "pci__config", "pci_cfg", "pci_config", "pdi_conn", "pci__con", "pci__conf", "pci_cache", "pili_cache", "pki_conf", "pili__con", "pci__info", "pili__config", "pci_Conf", "pili_config", "pki_cfg", "pdi_config", "pci__cache", "pki_Conf", "pki_config", "pili_conf", "pci__conn", "pdi_info", "pci_conn"], "err": ["Error", "fr", "f", "pl", "fi", "rev", "result", "y", "mr", "Er", "cache", "dr", "rc", "ev", "cb", "ace", "order", "arr", "der", "orig", "cry", "ah", "rn", "done", "ler", "doc", "ar", "ie", "magic", "code", "ee", "ch", "arm", "ind", "r", "ise", "error", "br", "o", "req", "errors", "acer", "ir", "cr", "gr", "conf", "e", "er", "msg", "sys", "rs", "rr", "rh", "ec", "res", "rar", "bug", "aaa", "var", "rage", "str"]}}
{"project": "FFmpeg", "commit_id": "8bedbb82cee4463a43e60eb22674c8bf927280ef", "target": 1, "func": "static void copy_frame(Jpeg2000EncoderContext *s)\n\n{\n\n    int tileno, compno, i, y, x;\n\n    uint8_t *line;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++){\n\n        Jpeg2000Tile *tile = s->tile + tileno;\n\n        if (s->planar){\n\n            for (compno = 0; compno < s->ncomponents; compno++){\n\n                Jpeg2000Component *comp = tile->comp + compno;\n\n                int *dst = comp->data;\n\n                line = s->picture.data[compno]\n\n                       + comp->coord[1][0] * s->picture.linesize[compno]\n\n                       + comp->coord[0][0];\n\n                for (y = comp->coord[1][0]; y < comp->coord[1][1]; y++){\n\n                    uint8_t *ptr = line;\n\n                    for (x = comp->coord[0][0]; x < comp->coord[0][1]; x++)\n\n                        *dst++ = *ptr++ - (1 << 7);\n\n                    line += s->picture.linesize[compno];\n\n                }\n\n            }\n\n        } else{\n\n            line = s->picture.data[0] + tile->comp[0].coord[1][0] * s->picture.linesize[0]\n\n                   + tile->comp[0].coord[0][0] * s->ncomponents;\n\n\n\n            i = 0;\n\n            for (y = tile->comp[0].coord[1][0]; y < tile->comp[0].coord[1][1]; y++){\n\n                uint8_t *ptr = line;\n\n                for (x = tile->comp[0].coord[0][0]; x < tile->comp[0].coord[0][1]; x++, i++){\n\n                    for (compno = 0; compno < s->ncomponents; compno++){\n\n                        tile->comp[compno].data[i] = *ptr++  - (1 << 7);\n\n                    }\n\n                }\n\n                line += s->picture.linesize[0];\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 11749, "substitutes": {"s": ["sym", "service", "cs", "self", "c", "a", "ks", "sv", "sh", "settings", "b", "gs", "w", "e", "rs", "js", "os", "site", "ls", "ss", "sq", "sr", "sb", "http", "S", "ds", "sie", "session", "fs", "ssl", "z", "ses", "qs", "er", "f", "sf", "xs", "an", "services", "sg", "sl", "sim", "v", "r", "ps", "l", "sky", "sync", "u", "sys", "su", "g", "side", "single", "is", "es", "ts", "p", "si", "se", "ns", "spec", "t", "m", "n", "sets", "this", "ges", "ops", "slice", "aws"], "tileno": ["illena", "kileno", "silono", "tilena", "tiloa", "fileno", "kilino", "tainasso", "tilename", "kilnea", "turono", "tlono", "illename", "siloa", "ilename", "ilena", "tainono", "siloid", "tileni", "silino", "tilerno", "silento", "tainoid", "tunoid", "silena", "filono", "vileno", "tleno", "illoki", "tilosi", "silerno", "tilasso", "sileni", "siloki", "tunono", "vilino", "tunerno", "illeno", "kileni", "tilento", "sileno", "filosi", "silnea", "iloki", "tainoa", "tainento", "tilnea", "turasso", "fileni", "tilono", "tuneni", "taineno", "tiloki", "tunento", "tuneno", "tilino", "ileno", "vilnea", "silename", "tureno", "tunosi", "tlosi", "silasso", "tiloid", "tleni", "turoa", "tainerno", "vileni"], "compno": ["componentNO", "cellnode", "conddo", "comno", "compnone", "compnum", "comNO", "compname", "codeio", "cmpdo", "ompNo", "hostnumber", "macno", "codelo", "procno", "comdo", " compio", " compcho", "cmpna", "winnom", "combno", "seqcho", "componentsn", "comppos", "seqno", "macnos", " comppos", "macnone", "propno", "cmpname", " compname", " compsn", "expnos", "compgo", "cmpnone", "cmpNo", "compos", "componentnumber", "componentno", "componentlo", "propNo", "cmpno", "comnone", "seqmo", "seqpos", "cmpnom", "comnumber", "seqauto", "comname", "cellnom", "propgo", "condnumber", "compnode", "compna", "componentyes", "cmppos", "ompna", "componentname", "comna", "cmpyes", "comyes", "componentNo", "comgo", "compmo", " compmo", "expno", " compnone", "propyes", "compnon", "hostdo", "winno", "procnon", "cellnone", "ompnone", " compnum", "codenum", "compnumber", "compauto", " complo", "comNo", "winnone", " compindex", "macyes", "cmpmo", "compnos", "compdo", "expdo", "compsn", "codeno", "macNO", "macdo", "procyes", "combnone", "componentnum", "combauto", " compnos", "componentpos", "expnone", "cmpnumber", "compnom", "compNo", "combcho", "cellno", "ompno", "complo", "propnon", "procnode", "cmpsn", "compyes", "propnode", "condno", "hostname", " compdo", "cellyes", "hostno", "componentindex", " compauto", "compcho", "cmpcho", "cmpindex", "componentio", "seqnone", "cellnon", "cmpgo", "compio", "windo", "compindex", "macNo", "condname", "celldo", "compNO"], "i": ["ii", "li", "f", "type", "id", "I", "k", "ip", "mi", "fi", "c", "yi", "iu", "d", "h", "ji", "p", "si", "b", "pi", "io", "j", "ori", "gi", "ie", "key", "z", "in", "xi", "zi", "bi", "di", "ind", "qi", "ui", "v", "t", "o", "l", "ci", "start", "u", "index", "w", "m", "e", "n", "ai", "eni", "ix"], "y": ["g", "zy", "ey", "yx", "wy", "yy", "type", "f", "uy", "yo", "iy", "ky", "id", "ny", "ya", "asy", "c", "yi", "xy", "by", "d", "h", "p", "dy", "b", "vy", "gy", "cy", "io", "year", "j", "yr", "z", "xi", "v", "ye", "ay", "ch", "sy", "ind", "o", "l", "sky", "ym", "ady", "ry", "w", "m", "col", "ty", "yt", "e", "yl", "Y", "name", "py", "oy"], "x": ["g", "pos", "xe", "ax", "yx", "ey", "wy", "f", "on", "id", "xc", "php", "sw", "k", "wx", "xs", "ya", "c", "X", "ex", "xy", "d", "h", "p", "lex", "dy", "hy", "loc", "b", "gy", "px", "cy", "j", "cross", "sex", "key", "z", "v", "code", "xi", "pe", "image", "in", "rx", "el", "t", "o", "l", "q", "u", "index", "xx", "dx", "fx", "w", "m", "ady", "ty", "tx", "e", "n", "yl", "Y", "xp", "name", "py", "data", "ix"], "line": ["la", "pos", "ne", "li", "LINE", "block", "layout", "type", "file", "mean", "comment", "ine", "side", "byte", "lined", "len", "cycle", "write", "label", "stroke", "node", "lo", "model", "step", "lines", "cell", "liner", "le", "frame", "style", "end", "rule", "scale", "po", "key", "kl", "code", "pe", "row", "Line", "lin", "layer", "source", "link", "val", "pin", "el", "l", "o", "point", "lay", "sync", "cel", "word", "strip", "e", "base", "unit", "ge", "header", "lc", "out", "name", "page", "data", "lf", "letter"], "tile": ["server", "file", "service", "tif", "edge", "je", "pixel", "draw", "plane", "lin", "oper", "dot", "e", "js", "grid", "coord", "live", "texture", "site", "plate", "ski", "module", "feature", "ace", "flat", "ie", "coll", "pe", "coe", "o", "ele", "te", "oe", "tle", "port", "profile", "late", "stone", "pod", "hop", "surface", "f", "table", "transfer", "le", "Tile", "scale", "sim", "layer", "source", "complete", "sky", "ge", "tun", "py", "ole", "phy", "uri", "type", "sample", "match", "square", "ten", "ube", "single", "game", "co", "node", "p", "ile", "theme", "chip", "interface", "project", "style", "ite", "core", "rule", "cli", "image", "t", "oodle", "component", "so", "google", "slice", "tin"], "comp": ["ctx", "src", "comment", "ref", "ip", "host", "class", "seq", "c", "pack", "war", "con", "html", "cc", "par", "ch", "css", "chrom", "oper", "ci", "buff", "com", "e", "info", "coord", "prop", "pro", "supp", "serv", "module", "mod", "cat", "Component", "gl", "gen", "cor", "grad", "cont", "coll", "code", "op", "coe", "cl", "sc", "sec", "company", "cum", "dom", "config", "app", "cell", "prof", "sim", "Comp", "source", "mac", "cond", "lib", "clip", "crit", "lc", "comb", "group", "parse", "type", "vec", "proc", "quad", "cmp", "co", "lab", "comm", "play", "p", "loc", "cp", "ct", "project", "omp", "core", "loop", "spec", "ac", "prep", "component", "col", "unit", "cap", "imp", "cache"], "dst": ["dsts", "dsc", " dsc", "Dst", "lsc", " dST", "lST", "DST", "lsts", "Dsts", " dsts", "dST", "lst", "Dsc"], "ptr": ["tr", "ctr", "touch", "pos", "deg", "rt", "pointer", "Ptr", "ref", "ridge", "pointers", "ft", "td", "addr", "adr", "etr", "len", "dist", "dr", "ped", "pr", "wr", "offset", "lr", "tip", "span", "loc", "plug", "pair", "vr", "grad", "pt", "ext", "spl", "kl", "trace", "code", " pointer", "prot", "vert", "push", "br", "kr", "attr", "cel", "pad", "buffer", "pat", "trans", "butt", "dra", "data", "coord", "str"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    return telldir(fs->dir);\n\n}\n", "idx": 11781, "substitutes": {"ctx": ["cas", "Context", "xc", "cs", "exc", "bc", "vc", "c", "pc", "ca", "cmp", "rc", "kb", "sci", "pkg", "loc", "cp", "cm", "context", "cc", "cv", "alloc", "cf", "conn", "cam", "tx", "fw", "tc", "lc"], "fs": ["flags", "os", "f", "fts", "cs", "ls", "sf", "ss", "states", "xs", "wcs", "uses", "ks", "flows", "bytes", "fps", "ts", "Fs", "ds", "outs", "fb", "ows", "files", "feed", "bs", "ns", "fp", "fc", "less", "ms", "df", "ps", "gets", "FS", "fw", "sys", "bits", "rs", "fd", "stats", "vs"]}}
{"project": "FFmpeg", "commit_id": "4b5a12a2cb0252c4a08b6d099eaf69523e8c62e5", "target": 0, "func": "static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref)\n\n{\n\n    AResampleContext *aresample = inlink->dst->priv;\n\n    const int n_in  = insamplesref->audio->nb_samples;\n\n    int n_out       = FFMAX(n_in * aresample->ratio * 2, 1);\n\n    AVFilterLink *const outlink = inlink->dst->outputs[0];\n\n    AVFilterBufferRef *outsamplesref = ff_get_audio_buffer(outlink, AV_PERM_WRITE, n_out);\n\n    int ret;\n\n\n\n    if(!outsamplesref)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avfilter_copy_buffer_ref_props(outsamplesref, insamplesref);\n\n    outsamplesref->format                = outlink->format;\n\n    outsamplesref->audio->channel_layout = outlink->channel_layout;\n\n    outsamplesref->audio->sample_rate    = outlink->sample_rate;\n\n\n\n    if(insamplesref->pts != AV_NOPTS_VALUE) {\n\n        int64_t inpts = av_rescale(insamplesref->pts, inlink->time_base.num * (int64_t)outlink->sample_rate * inlink->sample_rate, inlink->time_base.den);\n\n        int64_t outpts= swr_next_pts(aresample->swr, inpts);\n\n        aresample->next_pts =\n\n        outsamplesref->pts  = (outpts + inlink->sample_rate/2) / inlink->sample_rate;\n\n    } else {\n\n        outsamplesref->pts  = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    n_out = swr_convert(aresample->swr, outsamplesref->extended_data, n_out,\n\n                                 (void *)insamplesref->extended_data, n_in);\n\n    if (n_out <= 0) {\n\n        avfilter_unref_buffer(outsamplesref);\n\n        avfilter_unref_buffer(insamplesref);\n\n        return 0;\n\n    }\n\n\n\n    outsamplesref->audio->nb_samples  = n_out;\n\n\n\n    ret = ff_filter_samples(outlink, outsamplesref);\n\n    aresample->req_fullfilled= 1;\n\n    avfilter_unref_buffer(insamplesref);\n\n    return ret;\n\n}\n", "idx": 11793, "substitutes": {"inlink": ["inlinks", "idplug", "incLink", "rinflow", "inclink", "outflow", "inmission", "insflow", "idline", "inbase", "inclinks", "outplug", "insmission", "inload", "exline", "incflow", "vinline", "outink", "incline", "incload", "outmission", "incblock", "insmachine", "inslock", "vinself", "outself", "inself", "inflow", " inlinks", "outmachine", "exmission", "outload", "inmachine", "rinlock", "Inline", "inslink", "outlock", "outline", " inblock", "insblock", "rinlink", "outbase", "inplug", " inload", "Inlink", "insink", "conself", " inlock", "vinmachine", "rinline", "inblock", "insself", "idink", "inLink", "inslinks", "insline", "outLink", "exink", "Inlock", "conlink", "conline", " inLink", " inflow", "idlink", "InLink", "inlock", "exlink", "inink", "vinlink", "conbase", "insbase", "insplug"], "insamplesref": ["insizesbf", "insgroupsREF", "inschangesbase", "nsourcesref", "insformsref", "insimentsbase", "insampsrel", "inschangesrec", "insourcesall", "consizesreference", "insamplesall", "inasappsrc", "outsamplesRef", "insizespre", "nsamplesrel", "consamplesREF", "insblocksall", "insampsREF", "insgroupsarc", "outsampsarc", "insamplesconfig", "insizesREF", "consizesarc", "insipsarc", "insampsbase", "insipsref", "inschangesref", "insimagesall", "insamplesrec", "outsamplesrel", "inspectsREF", "outsamplesbf", "insamplesRef", "insampleall", "insourcesconfig", "insgroupsref", "insamplesbase", "insimentsrel", "insourcesrel", "insampleref", "insipsREF", "consamplesreference", "insimagesconfig", "insamplespre", "insformsrel", "inasappsrel", "insourcespre", "outsampsRef", "insampsrec", "insizesrel", "insizesRef", "insampsref", "insappsrel", "outsampsall", "nschangesref", "insizesconfig", "insourcesref", "insblocksRef", "insamplesarc", "inasappsref", "insappsREF", "insizesref", "inspectsrel", "insamplesreference", "nsamplesconfig", "insampsall", "outsampsrel", "consamplesarc", "nsourcesconfig", "insformsbf", "insblocksarc", "insimagesref", "inasappsREF", "outsampsrec", "insizesall", "consizesref", "inasamplesref", "nsourcesall", "inasamplesrel", "insourcesRef", "inschangesrel", "nschangesbase", "insimentsref", "insappsref", "outsamplesrec", "insourcesrec", "nschangesrel", "insamplearc", "outsamplesarc", "outsampsref", "insampsbf", "insizesreference", "insamplesrc", "inspectsrc", "nsamplesref", "nsamplespre", "nsamplesall", "insizesarc", "insblocksref", "outsamplesall", "insgroupsreference", "consizesREF", "insampsRef", "insipsreference", "consamplesref", "inasamplesREF", "insamplesbf", "insampleRef", "insformsRef", "nsourcespre", "insappsrc", "inasamplesrc", "insimagespre", "inspectsref", "insamplesREF", "inschangesRef", "insamplesrel", "insampsrc", "insampsarc", "nsamplesbase", "outsampsbf"], "aresample": ["airsample", "aresamples", "rasamp", "rasuper", "aresammy", "oresample", "astersamples", "asterspling", "asterssample", "owersamples", "owerssample", "airsammy", "aresource", "oresuper", "owerspling", "astersource", "arespring", "arespling", "allowsamples", "arsample", "capsample", "aressample", "rasource", "alesample", "rasample", "arssample", "allowssample", "alessample", "oresource", "arsamples", "astersuper", "owersample", "astersamp", "oresamp", "astersample", "capsamp", "capsammy", "aresuper", "arspring", "nassample", "stssample", "nasample", "aresamp", "airspring", "alespring", "capssample", "allowspring", "nasamples", "arsammy", "allowsample", "airssample", "airsamp", "nasamp", "stspling", "alesuper", "arsamp", "asterspring", "airsuper", "stsamples", "stsample"], "outlink": ["inlinks", " outload", "Outlink", "uplock", "atdisk", "inpack", " outdisk", "offbase", "offmodel", "outdisk", "bootlink", "Outmachine", "upmachine", "outerdisk", " outpack", "outbase", "upfeed", "upload", "inmodel", "outerline", "outpack", "downmachine", "upline", "infeed", "inbase", "indisk", "outmachine", "downlink", "inload", "bootmachine", "offlink", "outload", "outfeed", "inmachine", "bootline", "inlock", " outlock", "downfeed", "Outdisk", " outline", "outerlock", "upmodel", "uplinks", "outlinks", "outline", "bootdisk", "atmachine", "Outline", "offline", "offlinks", "outlock", "outmodel", "upbase", "uplink", "outerlink", "atline", " outlinks", "atlink", "uppack", "downline"], "outsamplesref": ["outspluginsalt", "outsourcesref", "outamplesdef", "offsipesref", "insampsrel", "outsitesalt", "oversamplesRef", "outsannelsRef", "nosipesrel", "insamplesary", "outamplesreference", "oversappsrel", "outsamplesRef", "outsappsbf", "outsizespre", "outsamplesdef", "outsamplespre", "outsizesref", "outshipsrel", "outspluginsRef", "opensampsREF", "outsgroupsary", "outsampsdef", "outsannelsrel", "insamplesold", "oversamplesrel", "opensampsRef", "opensamplesreference", "outsgroupsref", "outampsreference", "flowsamplesref", "insamplesrec", "outsamplesrel", "offsamplesRef", "outsampsreference", "flowshipsrel", "outsubsRef", "insampsary", "outsamplesbf", "flowsamplesRef", "insamplesRef", "outsimagesreference", "flowsamplesrel", "oversannelsrel", "outsifiersbase", "outsizesrel", "outsipesRef", "flowsamplesreference", "outsfilesRef", "outsifiersref", "outamplesary", "outsampsREF", "nosipesref", "outsfilesref", "outsagesRef", "nosipesreference", "insamplespre", "outsamplesre", "outsubsreference", "offsipesRef", "flowshipsreference", "outsformsrec", "outsessionsbase", "opensamplesref", "outsampsRef", "outsizesre", "insampsrec", "insampsref", "outsappsREF", "oversamplesbf", "nosamplesref", "outseriesref", "opensampsref", "nosamplesreference", "outsampsbf", "oversappsbf", "insamplesreference", "outsipesreference", "outsagespre", "outsannelsref", "outsidesary", "outspluginsrel", "nosipesbase", "outsfilesbf", "outsimagesRef", "outsubsref", "outshipsRef", "outsampsrel", "outsamplesary", "insampspre", "outsformsary", "offsipesrel", "insamplesalt", "outsizesREF", "outampsref", "oversannelsref", "opensamplesREF", "outsamplesREF", "outsampsary", "outsampsrec", "oversannelsRef", "outsformsRef", "outsitesreference", "outsagesref", "outsfilesold", "insampsalt", "outsizesbf", "outsipesref", "outsgroupsRef", "outsizesreference", "offsamplesrel", "opensamplesRef", "outsifiersreference", "insampsold", "outsagesrel", "oversappsREF", "outsidesdef", "outsifiersrel", "outsamplesrec", "outseriesbf", "outsampsold", "outsitesrel", "outsitesref", "outampsdef", "oversappsref", "outsessionsreference", "insampsbf", "outsamplesbase", "outsidesref", "insampsreference", "outsourcesbf", "outsampsalt", "nosamplesrel", "outsgroupsrec", "offsipesre", "outsessionsref", "outseriesRef", "outsappsref", "outsizesdef", "outsidesreference", "offsamplesre", "offsamplesref", "outsourcesrel", "flowshipsref", "outsimagesref", "flowshipsRef", "outsampspre", "outsizesRef", "insampsRef", "outshipsreference", "insamplesbf", "outsimagesrel", "outsubsREF", "outsformsref", "outsessionsrel", "outsamplesold", "outspluginsref", "outamplesref", "outsizesary", "outsipesre", "outsamplesalt", "outampsary", "outsitesRef", "outsamplesreference", "insamplesrel", "outseriesold", "oversamplesREF", "outsappsrel", "opensampsreference", "outsagesreference", "nosamplesbase", "outsourcesREF", "oversamplesref", "outsipesrel", "outshipsref", "outsipesbase", "outsampsref"], "ret": ["ann", "rets", "rt", "match", "id", "att", "re", "RET", "result", "success", "len", "al", "art", " Ret", "rc", "back", "arr", "fun", "lit", "img", "url", "flag", "bit", "part", "code", "val", "det", "def", "arg", "set", "reg", "alt", "Ret", "data", "feat"]}}
{"project": "FFmpeg", "commit_id": "138568e9da0e3abfc818329ab12ea3fb667639fb", "target": 0, "func": "static int mov_read_ctts(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n\n{\n\n    AVStream *st = c->fc->streams[c->fc->nb_streams-1];\n\n    MOVStreamContext *sc = st->priv_data;\n\n    unsigned int i, entries;\n\n\n\n    get_byte(pb); /* version */\n\n    get_be24(pb); /* flags */\n\n    entries = get_be32(pb);\n\n    if(entries >= UINT_MAX / sizeof(MOV_stts_t))\n\n        return -1;\n\n\n\n    sc->ctts_count = entries;\n\n    sc->ctts_data = av_malloc(entries * sizeof(MOV_stts_t));\n\n    if (!sc->ctts_data)\n\n        return -1;\n\n    dprintf(c->fc, \"track[%i].ctts.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    for(i=0; i<entries; i++) {\n\n        int count    =get_be32(pb);\n\n        int duration =get_be32(pb);\n\n\n\n        if (duration < 0) {\n\n            av_log(c->fc, AV_LOG_ERROR, \"negative ctts, ignoring\\n\");\n\n            sc->ctts_count = 0;\n\n            url_fskip(pb, 8 * (entries - i - 1));\n\n            break;\n\n        }\n\n        sc->ctts_data[i].count   = count;\n\n        sc->ctts_data[i].duration= duration;\n\n\n\n        sc->time_rate= ff_gcd(sc->time_rate, duration);\n\n    }\n\n    return 0;\n\n}\n", "idx": 11795, "substitutes": {"c": ["g", "ctx", "f", "xc", "cs", "nc", "icc", "bc", "vc", "ce", "pc", "ca", "co", "d", "cpp", "p", "enc", "cur", "arc", "cy", "ic", "cp", "cm", "cu", "con", "ctrl", "cc", "fc", "C", "dc", "cv", "coll", "ch", "ac", "t", "cl", "l", "ci", "cf", "u", "cus", "cr", "w", "cod", "conf", "oc", "e", "tc", "lc", "mc", "uc", "s", "ec", "gc", "cd", "cache"], "pb": ["plugin", "phrase", "pg", "tp", "ctx", "dp", "bm", "pm", "pro", "api", "buf", "pl", "mp", "proc", "bc", "rob", "bps", "db", "pc", "lb", "eb", "jp", "lab", "sb", "lp", "pd", "cpp", "p", "cb", "b", "mb", "fb", "cp", "bh", "gb", "pt", "rb", "fp", "fc", "hub", "prot", "bb", "xb", "platform", "uf", "wp", "ab", "emb", "pa", "tc", "ob", "wb", "bp", "py", "bf", "PB"], "atom": [" atoms", " Atom", "abc", "OM", " symb", " mom", " org", " form", " app", " program", " orb", "AT", " param", " gate", " bom", "cm", "orb", " ab", " biom", " tab", "bb", "om", " dom", " slab", " om", " tom", " plat", " arr"], "st": ["sd", "sth", "src", "sf", "ss", "bc", "pc", "sb", "stage", "sp", "ds", "ste", "ST", "sts", "ct", "se", "sl", "fc", "t", "cl", "std", "l", "cr", "sn", "e", "St", "lc", "s", "sa", "sec", "ec", "contract", "uc", "inst", "str"], "sc": ["ocr", "ctx", "src", "usc", "sw", "cs", "sche", "ss", "comp", "bc", "sub", "sq", "pc", "ca", "auc", "sr", "sup", "rc", "esc", "config", "enc", "sci", "si", "sp", "loc", "scope", "cy", "sh", "cm", "context", "gb", "core", "soc", "sim", "cc", "osc", "go", "fc", "cv", "spec", "ch", "css", "SC", "inc", "cms", "cl", "Sc", "cf", "sync", "cer", "cus", "cr", "acc", "capt", "FC", "desc", "uci", "tc", "RC", "lc", "ec", "uc", "mc", "asc", "cca", "cd", "isc"], "i": ["ii", "ti", "ni", "abi", "li", "uri", "hi", "f", "type", "id", "phi", "I", "api", "mu", "ip", "oi", "mi", "fi", "x", "y", "iu", "ini", "ei", "d", "multi", "ri", "p", "si", "b", "pi", "io", "j", "gi", "ie", "ami", "cli", "key", "z", "code", "v", "zi", "di", "xi", "qi", "r", "ui", "length", "bi", "t", "l", "ci", "esi", "start", "u", "m", "ij", "e", "n", "info", "ai", "lc", "eni", "name", "count", "counter", "slice", "ix", "it"], "entries": ["endry", "countries", "intresses", "intrys", "enties", "ntencies", "countents", "estrations", "endries", "centriers", "enturies", "Entries", "intents", "centry", "idories", "idriers", "mentencies", "endrys", "Entrics", "nturies", "ientries", "mentrations", "mentries", "Entry", "estries", "entsries", "entents", "ntries", "entriers", "ntrations", "ntrants", "entsents", "sentrys", "attrys", "centrations", "Entrys", "entrys", "intry", "attresses", "menties", "centrys", "countrys", "esties", "sentents", "centories", "entsories", "entresses", "centents", "attrations", "antry", "ientrics", "idries", "intries", "entrations", "antries", "ntrics", "nties", "Enties", "ientrys", "idents", "attries", "entrants", "ntrys", "ientry", "endresses", "ienturies", "ntry", "entories", "attry", "centries", "entsriers", "sentries", "ientrants", "anturies", "country", "entry", "entrics", "estencies", "entencies", "antrants", "sentry", "endies"]}}
{"project": "FFmpeg", "commit_id": "8089b7fa8c5b5a48cc7101daa4be891d0ead5a5e", "target": 1, "func": "int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)\n\n{\n\n    int64_t intnum=1;\n\n    double num=1;\n\n    int den=1;\n\n\n\n    av_get_number(obj, name, o_out, &num, &den, &intnum);\n\n    return num*intnum/den;\n\n}\n", "idx": 11806, "substitutes": {"obj": ["oa", "pos", "os", "prefix", "adj", "ctx", "src", "buf", "ref", "nb", "Obj", "cb", "arr", "b", "orb", "io", "j", "img", "obb", "rb", "ut", "oid", "iv", "code", "po", "act", "o", "opt", "attr", "val", "ab", "emb", "n", "ob", "nt", "js", "inst", "object"], "name": ["ann", "prefix", "size", "type", "f", "id", "comment", "NAME", "path", "Name", "min", "option", "new", "names", "filename", "part", "key", "ns", "parent", "num", "o", "time", "val", "word", "w", "n", "info", "base", "ame", "cn", "out", "data", "nam", "alias", "object", "named"], "o_out": [" o_array", "o_OUT", " o_OUT", "o_array", "o__outs", "o_in", " o_in", "o__out", "o_outs", " o_outs", "o__in", "o__OUT"]}}
{"project": "qemu", "commit_id": "39a611a3e035e148257af314a522a6cd169c2d0e", "target": 1, "func": "void commit_active_start(BlockDriverState *bs, BlockDriverState *base,\n\n                         int64_t speed,\n\n                         BlockdevOnError on_error,\n\n                         BlockDriverCompletionFunc *cb,\n\n                         void *opaque, Error **errp)\n\n{\n\n    int64_t length, base_length;\n\n    int orig_base_flags;\n\n\n\n    orig_base_flags = bdrv_get_flags(base);\n\n\n\n    if (bdrv_reopen(base, bs->open_flags, errp)) {\n\n        return;\n\n    }\n\n\n\n    length = bdrv_getlength(bs);\n\n    if (length < 0) {\n\n        error_setg(errp, \"Unable to determine length of %s\", bs->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    base_length = bdrv_getlength(base);\n\n    if (base_length < 0) {\n\n        error_setg(errp, \"Unable to determine length of %s\", base->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    if (length > base_length) {\n\n        if (bdrv_truncate(base, length) < 0) {\n\n            error_setg(errp, \"Top image %s is larger than base image %s, and \"\n\n                             \"resize of base image failed\",\n\n                             bs->filename, base->filename);\n\n            goto error_restore_flags;\n\n        }\n\n    }\n\n\n\n    bdrv_ref(base);\n\n    mirror_start_job(bs, base, speed, 0, 0,\n\n                     on_error, on_error, cb, opaque, errp,\n\n                     &commit_active_job_driver, false, base);\n\n    if (error_is_set(errp)) {\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    return;\n\n\n\nerror_restore_flags:\n\n    /* ignore error and errp for bdrv_reopen, because we want to propagate\n\n     * the original error */\n\n    bdrv_reopen(base, orig_base_flags, NULL);\n\n    return;\n\n}\n", "idx": 11810, "substitutes": {"bs": ["abi", "os", "bos", "block", "bis", "src", "cs", "ls", "state", "bc", "BS", "pb", "bps", "db", "is", "lb", "eb", "ins", "sb", "es", "bytes", "http", "ds", "b", "blocks", "fb", "fs", "boot", "outs", "gb", "core", "ns", "css", "bi", "client", "bb", "ras", "bing", "ps", "bin", "ses", "sync", "proxy", "ab", "gs", "as", "obj", "bits", "ob", "bas", "rs", "obs", "null", "s", "js", "bid", "bf", "bot", "vs", "ops"], "base": ["server", "pse", "file", "bn", "c", "model", "orig", "b", "pre", "key", "address", "bi", "bb", "ui", "resource", "area", "job", "root", "status", "build", "line", "plugin", "os", "size", "bis", "id", "api", "view", "home", "db", "back", "create", "http", "use", "builder", "parent", "prefix", "block", "f", "real", "bc", "super", "based", "pb", "boot", "part", "source", "sync", "start", "body", "basic", "ase", "null", "name", "bank", "kit", "Base", "type", "local", "state", "bare", "bu", "is", "es", "p", "fake", "cp", "url", "position", "core", "se", "cli", "original", "client", "proxy", "buffer", "bas", "bid", "bf", "bot", "cache"], "speed": ["timeout", "slow", "size", "wait", "peed", "mode", "limit", "path", "state", "sf", "engine", "score", "sleep", "fps", "offset", "si", "settings", "seed", "driver", "url", "position", "scale", "time", "count", "command", "start", "fast", "Speed", "priority", "sn", "buffer", "delay", "security", "progress", "port", "set", "sk", "status", "rate", "grade", "stop", "send", "slice"], "on_error": ["on_start", "onfclose", "onallclose", "onfror", "onffailed", "ononstart", "onoffclose", " onallfailed", " on_start", " on_grade", "onallprogress", " onallerr", "onallfailed", " on_failed", "onofferror", " onallerror", "ononror", "on_layer", " onallclose", "on_grade", "onofflayer", "on_progress", "on_failed", "onferror", " onallgrade", "onoffstart", "onofffailed", "on_close", "onallror", "on_ror", " on_err", "onallerror", " on_close", "ononlayer", " on_layer", " on_progress", "on_err", "ononerror", " on_ror", " onallror", "onallgrade", " onallprogress", "onoffror", "onallerr"], "cb": ["fn", "ctx", "unc", "callback", "buf", "cs", "nc", "err", "bc", "pb", "c", "db", "cmp", "eb", "cgi", "function", "fun", "fb", "cp", "ctrl", "obb", "cfg", "rb", "cc", "fp", "cv", "bb", "handler", "cf", "call", "conn", "cr", "job", "cod", "func", "ob", "tc", "wb", "CB", "gc", "bf", "cd"], "opaque": ["copane", "Opaques", " opasso", "opsaque", "opasso", "copace", "opane", "oplaques", "copaque", "opsace", "Opasso", "oplasso", "Opaque", "oplaque", "opaques", " opaques", " opace", " opane", "opace", "opsane"], "errp": ["aerf", "ierp", "yrp", "errc", "strp", "ierpi", " errper", "orderP", "err", "errorpc", "aerps", " errf", "strpc", "rrc", "strsp", "orderp", "aerc", "yrcp", "erc", "yrP", "erpe", "idp", "rrp", "iersp", "reqpc", "errP", "ordersp", "errcp", "reqpe", "yrper", "armp", " errps", " errfp", "armps", "errv", "errper", "aerp", "reqP", "armfp", "idps", "errorc", "errr", "errfp", "errps", "yrpi", " errv", "rrf", "ierpc", "errorp", "ierper", "ierP", "erp", " errpc", "idv", "errpc", "errorr", "strP", "erP", "yrfp", "errpe", "orderpc", "idfp", "erpc", "errsp", " errcp", "erfp", " errc", "errf", "ercp", "yrpe", "rrps", "armv", " errr", " errP", " errpe", " errpi", "reqp", "errpi"], "length": ["ph", "live", "block", "capacity", "size", "mount", "type", "match", "path", "weight", "limit", "zip", "distance", "view", "len", "sequence", "library", "duration", "p", "offset", "loc", "work", "total", "shape", "load", "range", "url", "style", "full", "position", "core", "ength", "sl", "address", "code", "Length", "level", "time", "count", "angle", "l", "height", "job", "lock", "body", "delay", "port", "buffer", "child", "value", "section", "root", "name", "pull", "grade", "depth", "number", "cost", "slice", "build"], "base_length": ["based_depth", "layer_definition", "base_lock", " base_count", "baseCsequence", "based8width", "base_definition", "based_width", " base_len", "based8depth", "base48depth", "base_len", "base8depth", "based_length", "base_full", "baseCdepth", "layer_length", "baseClength", " base_type", "base48width", "base8length", "layer_lock", "baseCwidth", "base_type", "base8sequence", "base_depth", "base48type", "based8length", "base48length", " base_width", "base_sequence", "base_count", "based_sequence", "base_Length", "based8sequence", " base_Length", " base_depth", "layer_full", "base_width", "base8width"], "orig_base_flags": ["orig_base\u00b7flags", "orig_base\u00b7bytes", "orig_cache_types", "orig_base\u00b7vals", "orig_server_files", "orig_base_bytes", "orig_server_vals", "orig_server_flags", "orig_base_files", "orig_server_bytes", "orig_base_types", "orig_cache_flags", "orig_base_args", "orig_cache_args", "orig_base_vals", "orig_server_args"]}}
{"project": "FFmpeg", "commit_id": "4f90688b6e1d79d85ac2e065a2cf1e7e9bd665a7", "target": 1, "func": "static int matroska_decode_buffer(uint8_t** buf, int* buf_size,\n                                  MatroskaTrack *track)\n{\n    MatroskaTrackEncoding *encodings = track->encodings.elem;\n    uint8_t* data = *buf;\n    int isize = *buf_size;\n    uint8_t* pkt_data = NULL;\n    int pkt_size = isize;\n    int result = 0;\n    int olen;\n    switch (encodings[0].compression.algo) {\n    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:\n        return encodings[0].compression.settings.size;\n    case MATROSKA_TRACK_ENCODING_COMP_LZO:\n        do {\n            olen = pkt_size *= 3;\n            pkt_data = av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING);\n            result = av_lzo1x_decode(pkt_data, &olen, data, &isize);\n        } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000);\n        if (result)\n            goto failed;\n        pkt_size -= olen;\n        break;\n#if CONFIG_ZLIB\n    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {\n        z_stream zstream = {0};\n        if (inflateInit(&zstream) != Z_OK)\n        zstream.next_in = data;\n        zstream.avail_in = isize;\n        do {\n            pkt_size *= 3;\n            pkt_data = av_realloc(pkt_data, pkt_size);\n            zstream.avail_out = pkt_size - zstream.total_out;\n            zstream.next_out = pkt_data + zstream.total_out;\n            result = inflate(&zstream, Z_NO_FLUSH);\n        } while (result==Z_OK && pkt_size<10000000);\n        pkt_size = zstream.total_out;\n        inflateEnd(&zstream);\n        if (result != Z_STREAM_END)\n            goto failed;\n        break;\n    }\n#endif\n#if CONFIG_BZLIB\n    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n        bz_stream bzstream = {0};\n        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n        bzstream.next_in = data;\n        bzstream.avail_in = isize;\n        do {\n            pkt_size *= 3;\n            pkt_data = av_realloc(pkt_data, pkt_size);\n            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n            result = BZ2_bzDecompress(&bzstream);\n        } while (result==BZ_OK && pkt_size<10000000);\n        pkt_size = bzstream.total_out_lo32;\n        BZ2_bzDecompressEnd(&bzstream);\n        if (result != BZ_STREAM_END)\n            goto failed;\n        break;\n    }\n#endif\n    default:\n    }\n    *buf = pkt_data;\n    *buf_size = pkt_size;\n    return 0;\n failed:\n    av_free(pkt_data);\n}", "idx": 11813, "substitutes": {"buf": ["padding", "empty", "mount", "vec", "src", "result", "bc", "bag", "seq", "addr", "len", "rc", "config", "cb", "input", "b", "Buff", "fb", "queue", "array", "tmp", "alloc", "br", "Buffer", "uf", "cmd", "buff", "map", "buffer", "pad", "port", "cap", "batch"], "buf_size": ["pkg_shape", "pkg_size", "buf_shape", "buf_ize", "buflexdata", "buf_data", "buf_channel", "fblexsn", "buflexsn", "fb_channel", "buf_sn", "buflexsize", "buflexchannel", "buf_range", "pkg_ize", "fblexdata", "fb_sn", "fblexsize", "fblexchannel", "fb_data", "pkg_range", "fb_size"], "track": ["tr", "transform", "ack", "board", "trip", "match", "path", "Track", "metadata", "tag", "roll", "rack", "round", "dr", "config", "step", "order", "tracks", "tracking", "seek", "project", "test", "trace", "package", "record", "ACK", "row", "add", "r", "form", "car", " tracks", "port", "train", "stream"], "encodings": ["enoderings", "encodeding", "enoders", "ecodings", "enodings", "encodesions", "enoderers", "ecods", "ecodations", "encodeders", "encoderations", "enoderions", "encodedings", "encodeds", "eccodments", "encodering", "eccoders", "encodesing", "ecoders", "encODs", "encodesments", "enccodments", "encoders", "enccodings", "eccodings", "encoderers", "eccoding", "encodedments", "eccods", "enccodions", "enccods", "encods", "enodions", "ecodions", "encodments", "encODing", "ecodments", "eccodations", "enccoders", "encODers", "enoding", "encodesings", "encodions", "encoderions", "encODings", "ecoding", "encoding", "encodations", "enodering", "encoderings", "eccodions", "encODations", "encODions", "encodedions", "enccodations", "enccoding"], "data": ["la", "dat", "pos", "ata", "valid", "padding", "empty", "size", "sample", "format", "Data", "api", "devices", "zip", "result", "byte", "media", " DATA", "len", "DATA", "multi", "config", "bytes", "new", "temp", "response", "input", "str", "xxx", "arr", "after", "extra", "results", "database", "array", "memory", "di", "in", "record", "dd", "parent", "all", "start", "next", "buffer", "body", "pad", "base", "none", "batch", "raw", "window", "zero", "cache"], "pkt_data": ["pkg_size", "packet_body", "packet_dat", "pkg_scale", "pkt_dat", "pant_size", "pant_block", "pkt_start", "pkg_dat", "pkt2data", "packet_data", "pft_value", "pkt_body", "pkt_value", "pkt_shift", "pant_data", "pkt_size", "pkg_start", "petsk_size", "pkt_scale", "pft_dat", "pkg_data", "packet_start", "petsk_data", "packet_size", "pant_shift", "petsk_length", "pft_size", "pkt2dat", "pkt_length", "pkt_block", "pft_data", "pkt2size"], "olen": ["ole", "lov", "valid", "where", "aiden", "lif", "linger", "lah", "sle", "blank", "serv", "regon", "len", "oven", "kn", "ellen", "afi", "eno", "non", "little", "lo", "temp", "osen", "slot", "loss", "fee", "nil", "nom", "what", "le", "nar", " leftover", "foo", "orno", "numbered", "more", "ien", "legal", "liv", "sol", "broken", "oin", "ele", "nn", "eden", "won", "zie", "olo", "ln", "lan", "oren", "lins", "lvl", "eni", "lost", "fin", "uno", "skip", "oln"]}}
{"project": "qemu", "commit_id": "ba9c5de5f2d33d468a07a8794121472ea031a0b5", "target": 0, "func": "void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,\n\n                                 bool is_write, bool is_exec, int unused,\n\n                                 unsigned size)\n\n{\n\n    AlphaCPU *cpu = ALPHA_CPU(cs);\n\n    CPUAlphaState *env = &cpu->env;\n\n\n\n    env->trap_arg0 = addr;\n\n    env->trap_arg1 = is_write ? 1 : 0;\n\n    dynamic_excp(env, 0, EXCP_MCHK, 0);\n\n}\n", "idx": 11833, "substitutes": {"cs": ["cas", "ics", "ctx", "ls", "ce", "wcs", "c", "pc", "ca", "ks", "rc", "ace", "ds", "fs", "cp", "acs", "CS", "cc", "ns", "ac", "spec", "css", "cms", "ras", "ps", "qs", "cf", "sc", "ci", "sync", "cus", "sys", "cn", "ec", "lc", "cons", "Cs"], "addr": ["oa", "pos", "prefix", "setup", "args", "pointer", "ctx", "mode", "nr", "src", "ptr", "ref", "ip", "eth", "host", "proc", "len", "cmp", "node", "dr", "rc", "config", "ace", "offset", "pkg", "socket", "address", "alloc", "r", "mac", "val", "attr", "cmd", "conn", "proxy", "index", "pad", "base", "name", "ad", "alias", "x"], "is_write": ["is__writing", "is__written", "is_read", "is__read", " is_read", "is_writ", "is__write", " is_writ", " is_written", " is_writing", "is_writing", "is__writ", "is_written"], "is_exec": ["is_read", "is__read", "is__exec", " is__read", " is_read", "is_execute", "is___exec", "is___execute", "is__execute", "is___exclusive", "is__exclusive", "is___read", " is__execute", " is__exclusive", " is_exclusive", " is__exec", " is_execute", "is_exclusive"], "unused": ["unusable", " unusable", "onused", "nuse", " uninitialized", "unuse", "nused", "ninitialized", "onusable", " unuse", "oninitialized", "uninitialized", "nusable", "onuse"], "size": ["timeout", "SIZE", "capacity", "empty", "ctx", "mode", "max", " bytes", "len", "rc", "bytes", "offset", "blocks", "memory", "ize", "address", "Size", "mem", "length", "alloc", "unit", "sec", "cap", "s", "name", "data", "count"], "cpu": ["ne", "np", "ctx", " cp", "nc", "cow", "ea", "proc", "c", "pc", "uca", "cmp", "pu", "node", "cpp", "ace", "kernel", "console", "CPU", "clock", "net", "cp", "core", "cli", "fc", "ac", "parent", "vm", "bench", "gpu", "conn", "uci", "unit", "cn", "lc", "ec", "eni", "processor", "cache"], "env": ["ne", "oa", "et", "np", "loader", "ctx", "args", "global", "site", "err", "state", "nc", "ea", "exc", "edge", "engine", "skin", "network", "db", "en", "ini", "eu", "eval", "config", "ev", "enable", "enc", "ace", "console", "agent", "scope", "Environment", "settings", "extra", "nw", "style", "ext", "context", "core", "cfg", "act", "viron", "environment", "vm", "el", "export", "cf", "conn", "stack", "inet", "e", "init", "er", " environment", "ec", "estate", "eni", "eye", "energy", "vs", "pect", "cache"]}}
{"project": "qemu", "commit_id": "e75ccf2c033fb0503d6cb7ddd0fd1dfa0aa4fc16", "target": 0, "func": "static int virtio_serial_init_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n    VirtIODevice *vdev;\n\n\n\n    if (proxy->class_code != PCI_CLASS_COMMUNICATION_OTHER &&\n\n        proxy->class_code != PCI_CLASS_DISPLAY_OTHER && /* qemu 0.10 */\n\n        proxy->class_code != PCI_CLASS_OTHERS)          /* qemu-kvm  */\n\n        proxy->class_code = PCI_CLASS_COMMUNICATION_OTHER;\n\n\n\n    vdev = virtio_serial_init(&pci_dev->qdev, &proxy->serial);\n\n    if (!vdev) {\n\n        return -1;\n\n    }\n\n    vdev->nvectors = proxy->nvectors == DEV_NVECTORS_UNSPECIFIED\n\n                                        ? proxy->serial.max_virtserial_ports + 1\n\n                                        : proxy->nvectors;\n\n    virtio_init_pci(proxy, vdev,\n\n                    PCI_VENDOR_ID_REDHAT_QUMRANET,\n\n                    PCI_DEVICE_ID_VIRTIO_CONSOLE,\n\n                    proxy->class_code, 0x00);\n\n    proxy->nvectors = vdev->nvectors;\n\n    return 0;\n\n}\n", "idx": 11834, "substitutes": {"pci_dev": ["pci_ev", "pci0diff", "pci0serial", "pci_device", "pci_serial", "pci7device", "pcgi0div", "pci7dev", "pci2dev", "pci2serial", "pci0dev", "pki_serial", "pki_dev", "pcgi_serial", "pcu_dev", "pcu_ev", "pcu_data", "pci_data", "pcgi_div", "pci7serial", "pci7ev", "pcgi_dev", "pcu_serial", "pcgi_diff", "pcgi0serial", "pcgi0diff", "pcgi0dev", "pci2div", "pci_diff", "pcu_device", "pki_device", "pci_div", "pci0div", "pci2diff"], "proxy": ["server", "remote", "facebook", "plugin", "pse", "web", "linux", "loader", "shadow", "pool", "fax", "service", "pro", "zip", "callback", "reverse", "device", "serial", "connection", "ce", "engine", "super", "module", "route", "library", "instance", "xy", " proxies", "play", "config", "model", "ace", "cop", "XY", "docker", "response", "http", "bridge", "session", "use", "driver", "socket", "interface", "project", "PRO", "clone", "ruby", "pe", "image", "client", "parent", "copy", "share", "source", "resource", "force", "Proxy", "lib", "component", "wrapper", "alias", "base", "pa", "port", "child", "su", "profile", "slave", "null", "root", "manager", "roxy", "slice", "cache"], "vdev": ["vDev", "svvar", "vdef", "vvdi", "wdiv", "Vdd", "vvdd", "vev", " vdef", "vserial", " vdes", "nvDev", "vcserial", "svserial", "vvar", "pdef", "Vgd", " vdiff", "vdc", "nvdes", "Vdi", "Vdc", "evdev", "svdd", " vev", " vdc", "nvdiff", " vdevice", "wdevice", "vdiff", " vdi", "vdd", "evdc", " vvar", "vcvar", "nvdev", "vcdiff", "vvdev", " vdd", "Vdev", "vvgd", "ldd", "svdevice", "pdev", "pdevice", "VDev", "vgd", "svdiff", "tvdiff", "vdi", "wdd", "evdevice", "vdevice", "vcdev", "tvdes", " vgd", "ldevice", "Vdevice", "svdev", "tvdev", " vDev", "ldev", "Vdef", "pev", "tvDev", "evDev", "wdev", "vdes", "vdiv", "svdiv", "Vev", " vserial"]}}
{"project": "qemu", "commit_id": "130257dc443574a9da91dc293665be2cfc40245a", "target": 0, "func": "static CharDriverState *qmp_chardev_open_serial(const char *id,\n\n                                                ChardevBackend *backend,\n\n                                                ChardevReturn *ret,\n\n                                                Error **errp)\n\n{\n\n    ChardevHostdev *serial = backend->serial;\n\n    int fd;\n\n\n\n    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);\n\n    if (fd < 0) {\n\n        return NULL;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n    return qemu_chr_open_tty_fd(fd);\n\n}\n", "idx": 11840, "substitutes": {"id": ["did", "path", "ip", "proc", "handle", "mid", "ids", "Id", "kid", "connection", "cb", "ident", "sid", "oid", "parent", "start", "chid", "ID", "uid", "child", "rid", "root", "name", "data", "ide", "pid", "it"], "backend": ["backension", " backward", " backender", "frontender", "Backension", "frontended", "Backender", " backension", "Backended", "frontward", "Backend", "backended", "Backward", "backward", "frontension", "frontend", " backended", "backender"], "ret": ["linux", "rets", "resp", "RET", "buf", "eth", "fi", "proc", "result", "rc", "urn", "fun", "lit", "bd", "mem", "std", "val", "def", "conn", "desc", "nt", "res", "reg", "fin", "Ret", "data", "exec"], "errp": ["rrpre", "rrp", "rorp", "rorP", "err", "errP", "errr", "rorbp", " errpre", "errpre", " errv", " errbp", "rorpre", "erp", " errr", " errP", "errv", "rrP", "excv", "excP", "erP", "errbp", "excr", "erv", "excp", "rrbp"], "serial": ["bus", "binary", "product", "version", "linux", "hw", "pass", "no", "mount", "mode", "device", "local", "path", "devices", "host", "proc", "handle", "connection", "private", "phone", "smart", "public", "usb", "config", "model", "ser", "normal", "pocket", "boot", "lit", "ident", "driver", "feed", "array", "machine", "native", "reader", "select", "micro", "gpu", "tty", "dev", "proxy", "Serial", "series", "unknown", "random", "port", "mor", "custom", "raw", "erial"], "fd": ["F", "hd", "fn", "sd", "wd", "die", "f", "file", "buf", "draft", "ff", "sf", "fi", "handle", "md", "c", "db", "exec", "gd", "i", "fe", "d", "draw", "cb", "rd", "ds", " f", "fs", "FD", "fl", "fb", "done", "nd", "vd", "feed", "bd", "fa", "fp", "fc", "dd", "dc", "dn", "ind", "df", "handler", " FD", "af", "cf", "fx", "cond", "buff", "fw", "fed", "fin", "dl", "bf", "data", " fid", "cd", "pid", "lf"]}}
{"project": "qemu", "commit_id": "a369da5f31ddbdeb32a7f76622e480d3995fbb00", "target": 0, "func": "void alpha_pci_vga_setup(PCIBus *pci_bus)\n\n{\n\n    switch (vga_interface_type) {\n\n#ifdef CONFIG_SPICE\n\n    case VGA_QXL:\n\n        pci_create_simple(pci_bus, -1, \"qxl-vga\");\n\n        return;\n\n#endif\n\n    case VGA_CIRRUS:\n\n        pci_cirrus_vga_init(pci_bus);\n\n        return;\n\n    case VGA_VMWARE:\n\n        if (pci_vmsvga_init(pci_bus)) {\n\n            return;\n\n        }\n\n        break;\n\n    }\n\n    /* If VGA is enabled at all, and one of the above didn't work, then\n\n       fallback to Standard VGA.  */\n\n    if (vga_interface_type != VGA_NONE) {\n\n        pci_vga_init(pci_bus);\n\n    }\n\n}\n", "idx": 11843, "substitutes": {"pci_bus": ["pcu_boot", "pciAMusb", "pci__system", "pciADboot", "pciADconnection", "pciADusb", "pciAMinterface", "pciAMboot", "pci__bridge", "pdi_boot", "pcm_connection", "pci_boot", "pciAMbus", "pci_usb", "pci_system", "pcm_system", "pcu_usb", "pci_interface", "pki_boot", "pdi_bus", "pci__bus", "pci__boot", "pki_system", "pci_bridge", "pciADbus", "pki_bridge", "pci_connection", "pdi_us", "pcm_boot", "pcu_interface", "pcm_bus", "pci_us", "pki_bus", "pcu_bus", "pdi_usb", "pcm_usb"]}}
{"project": "qemu", "commit_id": "75554a3ca10a7ad295d2a3d2e14ee6ba90f94c8b", "target": 0, "func": "struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk,\n\n                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)\n\n{\n\n    target_phys_addr_t base = omap_l4_attach(ta, 0, 0);\n\n    struct omap_uart_s *s = omap_uart_init(base, irq,\n\n                    fclk, iclk, txdma, rxdma, chr);\n\n    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,\n\n                    omap_uart_writefn, s);\n\n\n\n    s->ta = ta;\n\n    s->base = base;\n\n\n\n    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);\n\n\n\n    return s;\n\n}\n", "idx": 11844, "substitutes": {"ta": ["oa", "ga", "ata", "aka", "tu", "va", "ada", "ea", "na", "ppa", "ra", "alpha", "ma", "ka", "a", "ca", "asia", "au", "beta", "tm", "ha", "si", "sta", "qa", "asa", "eta", "fa", "address", "sha", "ti", "asta", "ama", "t", "source", "da", "area", "wa", "ty", "base", "pa", "asi", "era", "tta", "sa", "meta", "sea", "TA", "ba"], "irq": ["arqq", "arqs", "irqq", "irk", " irqq", "ircq", "risqq", " irk", "risk", "ireq", "irch", "risqs", "irech", "risq", "ircch", "arq", "ircqs", " irf", " irch", "irqs", "ark", " irqs", "ireqs", "ircf", "irf", "iref"], "fclk": ["fplq", "cfplk", "fmlc", "cfplc", "fClke", "fclke", "fpla", "rfclq", "fmlq", "rfclke", "rfplk", "fslk", "fClk", "rfclk", "cfclc", "fmla", "fclq", "rfplke", "cfclk", "cfplq", "fClq", "cfplke", "fmlke", "cfclke", "fslke", "rfpla", "fmlk", "fClc", "fclc", "fplke", "fplk", "rfplq", "fsla", "cfclq", "fplc", "rfcla", "fcla", "fslq"], "iclk": ["icrlke", "iaclke", "iaclck", "icclk", "acclk", "icelks", "iclke", "iaclk", "aclK", "acclke", "iaclq", "icclks", "icelke", "aclk", "acclK", "aclke", "aclks", "iaclcq", "icrlk", "icclK", "icLke", "icclq", "iaclks", "iaclcks", "icrlK", "icelk", "iclK", "icrlks", "icLk", "iclcq", "iclks", "icelK", "acclks", "iaclcke", "iclq", "icclke", "iclcke", "icLks", "icLq", "iclck", "iclcks"], "txdma": ["txdwa", "txdswa", "txdga", "txmga", "rxdna", "rxlna", "txsdwa", "rxlga", "rxlma", "txlna", "txdsta", "txpdama", " txsdama", " txdwa", "txpdma", " txsdwa", "txmna", " txsdma", "txdsama", "txdsga", "txdna", "txdsma", "txsdma", "rxdsta", " txdta", "txlga", "txsdama", "rxlsta", "txmma", "rxdga", "txdssta", "txlma", "txdama", "txpdta", "txmsta", "txdta", " txdama", "txpdwa", " txsdta", "txlsta", "txsdta", "txdsna"], "rxdma": ["rhdda", "rgdga", "arddmas", " rxcka", "rfdma", "rgdka", " rxdka", "rxcmas", "rxcga", " rxdmas", "rxcwa", "rfdmas", "arxdda", "rxdda", "rfdka", "rxcma", "rhdma", "rddda", "rhdmas", "rfdga", "rhdwa", "rgdmas", " rxcma", "rgdma", "arddwa", "rddmas", "rxcda", "rxdwa", "rddwa", "rxdmas", "rddma", " rxcmas", " rxdga", "arxdwa", "rxcka", "arddda", "rxdga", "arxdma", " rxcga", "rxdka", "arxdmas", "arddma"], "chr": ["chp", "Chrs", "thrs", " chre", "Chp", "cherre", "chrs", "cherc", " chp", "chc", "schr", "schp", "cherrs", "schrs", "Char", "thc", " chrs", "cherr", "chre", "Chr", "schar", "thre", " chc", "thr"], "s": ["support", "g", "os", "als", "sym", "f", "site", "service", "its", "cs", "ls", " is", " parts", "ss", "c", "sq", "is", "a", "i", "sup", "services", "d", "sb", "es", "ings", "p", "ves", "sg", "si", "span", "session", "b", "S", "settings", "ssl", "ds", "ows", "secondary", "se", "sl", "ns", "spec", "o", "t", "r", "ps", "ses", "l", "sync", "u", " signs", "gs", "w", "m", "ures", "as", "south", "base", "e", "sys", "sets", "su", "rs", "sa", "js", "ches"]}}
{"project": "qemu", "commit_id": "6e6e55f5c2e5b520d6506c2716287ba3b5d1bbc8", "target": 0, "func": "static void QEMU_NORETURN help(void)\n\n{\n\n    const char *help_msg =\n\n           QEMU_IMG_VERSION\n\n           \"usage: qemu-img [standard options] command [command options]\\n\"\n\n           \"QEMU disk image utility\\n\"\n\n           \"\\n\"\n\n           \"    '-h', '--help'       display this help and exit\\n\"\n\n           \"    '-V', '--version'    output version information and exit\\n\"\n\n           \"    '-T', '--trace'      [[enable=]<pattern>][,events=<file>][,file=<file>]\\n\"\n\n           \"                         specify tracing options\\n\"\n\n           \"\\n\"\n\n           \"Command syntax:\\n\"\n\n#define DEF(option, callback, arg_string)        \\\n\n           \"  \" arg_string \"\\n\"\n\n#include \"qemu-img-cmds.h\"\n\n#undef DEF\n\n#undef GEN_DOCS\n\n           \"\\n\"\n\n           \"Command parameters:\\n\"\n\n           \"  'filename' is a disk image filename\\n\"\n\n           \"  'objectdef' is a QEMU user creatable object definition. See the qemu(1)\\n\"\n\n           \"    manual page for a description of the object properties. The most common\\n\"\n\n           \"    object type is a 'secret', which is used to supply passwords and/or\\n\"\n\n           \"    encryption keys.\\n\"\n\n           \"  'fmt' is the disk image format. It is guessed automatically in most cases\\n\"\n\n           \"  'cache' is the cache mode used to write the output disk image, the valid\\n\"\n\n           \"    options are: 'none', 'writeback' (default, except for convert), 'writethrough',\\n\"\n\n           \"    'directsync' and 'unsafe' (default for convert)\\n\"\n\n           \"  'src_cache' is the cache mode used to read input disk images, the valid\\n\"\n\n           \"    options are the same as for the 'cache' option\\n\"\n\n           \"  'size' is the disk image size in bytes. Optional suffixes\\n\"\n\n           \"    'k' or 'K' (kilobyte, 1024), 'M' (megabyte, 1024k), 'G' (gigabyte, 1024M),\\n\"\n\n           \"    'T' (terabyte, 1024G), 'P' (petabyte, 1024T) and 'E' (exabyte, 1024P)  are\\n\"\n\n           \"    supported. 'b' is ignored.\\n\"\n\n           \"  'output_filename' is the destination disk image filename\\n\"\n\n           \"  'output_fmt' is the destination format\\n\"\n\n           \"  'options' is a comma separated list of format specific options in a\\n\"\n\n           \"    name=value format. Use -o ? for an overview of the options supported by the\\n\"\n\n           \"    used format\\n\"\n\n           \"  'snapshot_param' is param used for internal snapshot, format\\n\"\n\n           \"    is 'snapshot.id=[ID],snapshot.name=[NAME]', or\\n\"\n\n           \"    '[ID_OR_NAME]'\\n\"\n\n           \"  'snapshot_id_or_name' is deprecated, use 'snapshot_param'\\n\"\n\n           \"    instead\\n\"\n\n           \"  '-c' indicates that target image must be compressed (qcow format only)\\n\"\n\n           \"  '-u' enables unsafe rebasing. It is assumed that old and new backing file\\n\"\n\n           \"       match exactly. The image doesn't need a working backing file before\\n\"\n\n           \"       rebasing in this case (useful for renaming the backing file)\\n\"\n\n           \"  '-h' with or without a command shows this help and lists the supported formats\\n\"\n\n           \"  '-p' show progress of command (only certain commands)\\n\"\n\n           \"  '-q' use Quiet mode - do not print any output (except errors)\\n\"\n\n           \"  '-S' indicates the consecutive number of bytes (defaults to 4k) that must\\n\"\n\n           \"       contain only zeros for qemu-img to create a sparse image during\\n\"\n\n           \"       conversion. If the number of bytes is 0, the source will not be scanned for\\n\"\n\n           \"       unallocated or zero sectors, and the destination image will always be\\n\"\n\n           \"       fully allocated\\n\"\n\n           \"  '--output' takes the format in which the output must be done (human or json)\\n\"\n\n           \"  '-n' skips the target volume creation (useful if the volume is created\\n\"\n\n           \"       prior to running qemu-img)\\n\"\n\n           \"\\n\"\n\n           \"Parameters to check subcommand:\\n\"\n\n           \"  '-r' tries to repair any inconsistencies that are found during the check.\\n\"\n\n           \"       '-r leaks' repairs only cluster leaks, whereas '-r all' fixes all\\n\"\n\n           \"       kinds of errors, with a higher risk of choosing the wrong fix or\\n\"\n\n           \"       hiding corruption that has already occurred.\\n\"\n\n           \"\\n\"\n\n           \"Parameters to convert subcommand:\\n\"\n\n           \"  '-m' specifies how many coroutines work in parallel during the convert\\n\"\n\n           \"       process (defaults to 8)\\n\"\n\n           \"  '-W' allow to write to the target out of order rather than sequential\\n\"\n\n           \"\\n\"\n\n           \"Parameters to snapshot subcommand:\\n\"\n\n           \"  'snapshot' is the name of the snapshot to create, apply or delete\\n\"\n\n           \"  '-a' applies a snapshot (revert disk to saved state)\\n\"\n\n           \"  '-c' creates a snapshot\\n\"\n\n           \"  '-d' deletes a snapshot\\n\"\n\n           \"  '-l' lists all snapshots in the given image\\n\"\n\n           \"\\n\"\n\n           \"Parameters to compare subcommand:\\n\"\n\n           \"  '-f' first image format\\n\"\n\n           \"  '-F' second image format\\n\"\n\n           \"  '-s' run in Strict mode - fail on different image size or sector allocation\\n\"\n\n           \"\\n\"\n\n           \"Parameters to dd subcommand:\\n\"\n\n           \"  'bs=BYTES' read and write up to BYTES bytes at a time \"\n\n           \"(default: 512)\\n\"\n\n           \"  'count=N' copy only N input blocks\\n\"\n\n           \"  'if=FILE' read from FILE\\n\"\n\n           \"  'of=FILE' write to FILE\\n\"\n\n           \"  'skip=N' skip N bs-sized blocks at the start of input\\n\";\n\n\n\n    printf(\"%s\\nSupported formats:\", help_msg);\n\n    bdrv_iterate_format(format_print, NULL);\n\n    printf(\"\\n\");\n\n    exit(EXIT_SUCCESS);\n\n}\n", "idx": 11852, "substitutes": {"QEMU_NORETURN": ["QEMU_OKETURN", "QEMU_NORETSEST", "QEMU_OKETurn", "QEMU_NOREOEST", "QEMU_NORETSURN", "QEMU_NOREORC", "QEMU_NORETRC", "QEMU_NOREOURN", "QEMU_NORETurn", "QEMU_NORTURN", "QEMU_NORTEST", "QEMU_NORTRC", "QEMU_OKEOURN", "QEMU_NOREOurn", "QEMU_NORETEST", "QEMU_NORETSRC", "QEMU_OKETRC", "QEMU_OKEOurn", "QEMU_OKEOEST", "QEMU_OKEORC", "QEMU_OKETEST", "QEMU_NORTurn", "QEMU_NORETSurn"], "help_msg": ["help__Msg", " help_wa", "version_req", "help_message", "help_wa", "help___message", "help_log", " help_Msg", "help_str", "help__msg", "help___log", "version_message", "help_Msg", "version_msg", "help__wa", "help___req", "help__str", " help_str", "help___msg", "help_req", "version_log"]}}
{"project": "qemu", "commit_id": "621ff94d5074d88253a5818c6b9c4db718fbfc65", "target": 0, "func": "static void coroutine_fn bdrv_create_co_entry(void *opaque)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    CreateCo *cco = opaque;\n\n    assert(cco->drv);\n\n\n\n    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);\n\n    if (local_err) {\n\n        error_propagate(&cco->err, local_err);\n\n    }\n\n    cco->ret = ret;\n\n}\n", "idx": 11853, "substitutes": {"opaque": ["compatile", "openasso", "obaque", "obasso", "opacity", "operasso", "oppaques", "operatile", "opasso", "compaque", "openaques", "ipacity", "obec", "oppacity", "ipaque", "oppasso", "compec", "ipasso", "oppaque", "opaques", "ipaques", "obatile", "operaque", "openaque", "compasso", "operec", "openacity", "opec", "opatile"], "local_err": ["local_error", "localayfr", "remote_fr", " local_dr", "local_er", "localayerror", "remote_error", "remote_err", "localayerr", " local_rr", " local_er", "local_fr", "local_gr", "local_dr", "local_rr", " local_error", " local_gr"], "ret": ["et", "valid", "pass", "block", "no", "rets", "f", "rt", "att", "resp", "re", "RET", "ref", "err", "rev", "fi", "ft", "result", "success", "len", "al", "en", "art", "sr", "sb", "rc", "rl", "arr", "fun", "lit", "ct", "url", "flag", "ext", "mt", "part", "code", "gt", "mem", "t", "fail", "val", "det", "_", "def", "job", "arg", "reply", "lock", "base", "info", "res", "nt", "reg", "alt", "Ret", "bf", "status"], "cco": ["ccako", "ccoco", "cclo", "uccone", " ccko", "econe", "cfo", "czoo", "czpo", "ccaoo", " ccto", "ccaoin", "ccO", "czopy", "CCko", " ccoco", "czo", "ccalo", "ccko", " ccode", "ccone", "cfoo", " ccO", "ccoo", "cfO", "ccaone", "cfoin", "ecoin", "CCone", "ccaoco", "cfpo", "cct", "ccao", "ecpo", "CCopy", "cfone", "ccpo", "ccto", "ccoin", "ccapo", "CClo", " ccone", "ccode", "ccaO", "CCoco", "CCpo", " cct", "CCo", " ccoo", "cione", " cclo", "ccopy", "cio", "uccto", "CCoo", "ciode", "cito", "eco", "uccode", "ecoo", "ccat", "CCt", "CCO", "ucco", "ecopy"]}}
{"project": "qemu", "commit_id": "9658e4c342e6ae0d775101f8f6bb6efb16789af1", "target": 0, "func": "void helper_mtc0_entryhi(CPUMIPSState *env, target_ulong arg1)\n\n{\n\n    target_ulong old, val, mask;\n\n    mask = (TARGET_PAGE_MASK << 1) | env->CP0_EntryHi_ASID_mask;\n\n    if (((env->CP0_Config4 >> CP0C4_IE) & 0x3) >= 2) {\n\n        mask |= 1 << CP0EnHi_EHINV;\n\n    }\n\n\n\n    /* 1k pages not implemented */\n\n#if defined(TARGET_MIPS64)\n\n    if (env->insn_flags & ISA_MIPS32R6) {\n\n        int entryhi_r = extract64(arg1, 62, 2);\n\n        int config0_at = extract32(env->CP0_Config0, 13, 2);\n\n        bool no_supervisor = (env->CP0_Status_rw_bitmask & 0x8) == 0;\n\n        if ((entryhi_r == 2) ||\n\n            (entryhi_r == 1 && (no_supervisor || config0_at == 1))) {\n\n            /* skip EntryHi.R field if new value is reserved */\n\n            mask &= ~(0x3ull << 62);\n\n        }\n\n    }\n\n    mask &= env->SEGMask;\n\n#endif\n\n    old = env->CP0_EntryHi;\n\n    val = (arg1 & mask) | (old & ~mask);\n\n    env->CP0_EntryHi = val;\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        sync_c0_entryhi(env, env->current_tc);\n\n    }\n\n    /* If the ASID changes, flush qemu's TLB.  */\n\n    if ((old & env->CP0_EntryHi_ASID_mask) !=\n\n        (val & env->CP0_EntryHi_ASID_mask)) {\n\n        cpu_mips_tlb_flush(env);\n\n    }\n\n}\n", "idx": 11854, "substitutes": {"env": ["server", "et", "chev", "err", "nc", "edge", "exc", "ea", "ou", "c", "ev", "console", "iss", "here", "environment", "next", "org", "inet", "e", "ec", "eni", "txt", "extra", "target", "ef", "vs", "enable", "ne", "dat", "fen", "np", "gear", "site", "serv", "chal", "db", "eval", "enc", "stage", "Environment", "NV", "scope", "equ", "end", "viron", "code", "vm", "el", "conn", "qv", "manager", "energy", "dt", "exec", "esp", "pg", "engine", "en", "eb", "event", "config", "enh", "cal", "v", "lv", "que", "her", "emb", "erv", "oa", "args", "global", "eng", "qt", "eu", "cb", "net", "ext", "context", "core", "cv", "export", "gui", "dev", "conf", "dep", "obj"], "arg1": ["mac2", "argument1", "argument0", " arg0", "argumentone", "valone", "argone", "macone", " argone", "param0", "args2", "param1", "val0", "args1", "arg0", "Argone", "param2", "Arg0", "val1", "mac0", " arg2", "Arg2", "mac1", "Arg1", "argument2", "val2", "args0", "arg2"], "old": ["la", "before", "valid", "where", "pass", "append", "Old", "f", "high", "diff", "update", "prev", "now", "low", "recent", "eval", "new", "lo", "expected", "after", "arr", "orig", "and", "OLD", "replace", "nd", "ld", "gen", "end", "missing", "pre", "key", "add", "original", "entry", "ind", "l", "def", "item", "allow", "older", "arg", "last", "lock", "obj", "current", "var", "alt", "pred", "data", "lf", "list", "post"], "val": ["vol", "prop", "valid", "pass", "mount", "pal", "vals", "local", "real", "update", "sel", "len", "al", "fe", "eval", "bl", "new", "ana", "p", "slot", "change", "arr", "Val", "bit", "VAL", "sl", "pre", "key", "ut", "v", "mem", "ind", "el", "ret", "count", "item", "cond", "index", "arg", "lock", "base", "unit", "balance", "value", "py", "alt", "data", "exec", "x"], "mask": ["flags", "ask", "ph", "valid", "ack", "f", "match", "mean", "diff", "max", "weight", "x", "result", "depth", "sign", "ver", "label", "cache", "patch", "pack", "config", "p", "scan", "mark", "qa", "ban", "work", "flag", "bit", "fac", "scale", "key", "code", "v", "parent", "filter", "header", "Mask", "mac", "map", "allow", "pad", "lock", "conf", "delay", "m", "value", "sk", "fix", "bug", "hash", "count", "miss", "check", "sum"]}}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static bool vmxnet3_verify_driver_magic(hwaddr dshmem)\n\n{\n\n    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);\n\n}\n", "idx": 11861, "substitutes": {"dshmem": ["dchmemory", "dhaccess", "dschaccess", " dshram", "dshiftmemory", "dshiftmem", "Dshimage", "Dshmemory", "dschram", "Dhimage", "dspram", " dschram", " dschmemory", "dhimage", "Dshmem", "dschmemory", " dshmemory", " dschmem", " dshaccess", " dschaccess", "dspmem", "Dhram", "dchram", "dshiftram", "dhmem", "dschmem", "dshram", "dshaccess", "dshimage", "dspaccess", "dchmem", "dhmemory", "dshmemory", "dspmemory", "dshiftimage", "Dhmem", "Dshram", "Dhmemory", "dhram", "dchimage"]}}
{"project": "qemu", "commit_id": "7443b43758ba5eeca8f81ca15fe9fced8983be26", "target": 1, "func": "ram_addr_t qemu_ram_addr_from_host_nofail(void *ptr)\n\n{\n\n    ram_addr_t ram_addr;\n\n\n\n    if (qemu_ram_addr_from_host(ptr, &ram_addr)) {\n\n        fprintf(stderr, \"Bad ram pointer %p\\n\", ptr);\n\n        abort();\n\n    }\n\n    return ram_addr;\n\n}\n", "idx": 11865, "substitutes": {"ptr": ["tr", "rect", "pos", "ctr", "rw", "ctx", "pointer", "Ptr", "src", "buf", "ref", "eth", "host", "proc", "pointers", "addr", "pc", "pr", "p", "tip", "offset", "temp", "loc", "pair", "test", "pt", "address", "fp", "code", "trace", " pointer", "tmp", "t", "br", "peer", "point", "tty", "inter", "buff", "pad", "buffer", "port", "fd", "inst", "slice"], "ram_addr": ["ram_ref", "ram2address", "gram_ref", "gram_dr", "rampaddress", "ramphost", "ram_address", "ram2host", "rampref", "ram2dr", "ram_host", "ram2addr", "rampdr", "gram_addr", "rampaddr", "gram_address", "gram_host", "ram_dr"]}}
{"project": "FFmpeg", "commit_id": "03acb035d1292685cc24a2be0f62dd8332711734", "target": 1, "func": "static int decode_format80(VqaContext *s, int src_size,\n\n    unsigned char *dest, int dest_size, int check_size) {\n\n\n\n    int dest_index = 0;\n\n    int count, opcode, start;\n\n    int src_pos;\n\n    unsigned char color;\n\n    int i;\n\n\n\n    start = bytestream2_tell(&s->gb);\n\n    while (bytestream2_tell(&s->gb) - start < src_size) {\n\n        opcode = bytestream2_get_byte(&s->gb);\n\n        av_dlog(s->avctx, \"opcode %02X: \", opcode);\n\n\n\n        /* 0x80 means that frame is finished */\n\n        if (opcode == 0x80)\n\n            break;\n\n\n\n        if (dest_index >= dest_size) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: dest_index (%d) exceeded dest_size (%d)\\n\",\n\n                dest_index, dest_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (opcode == 0xFF) {\n\n\n\n            count   = bytestream2_get_le16(&s->gb);\n\n            src_pos = bytestream2_get_le16(&s->gb);\n\n            av_dlog(s->avctx, \"(1) copy %X bytes from absolute pos %X\\n\", count, src_pos);\n\n            CHECK_COUNT();\n\n            CHECK_COPY(src_pos);\n\n            for (i = 0; i < count; i++)\n\n                dest[dest_index + i] = dest[src_pos + i];\n\n            dest_index += count;\n\n\n\n        } else if (opcode == 0xFE) {\n\n\n\n            count = bytestream2_get_le16(&s->gb);\n\n            color = bytestream2_get_byte(&s->gb);\n\n            av_dlog(s->avctx, \"(2) set %X bytes to %02X\\n\", count, color);\n\n            CHECK_COUNT();\n\n            memset(&dest[dest_index], color, count);\n\n            dest_index += count;\n\n\n\n        } else if ((opcode & 0xC0) == 0xC0) {\n\n\n\n            count = (opcode & 0x3F) + 3;\n\n            src_pos = bytestream2_get_le16(&s->gb);\n\n            av_dlog(s->avctx, \"(3) copy %X bytes from absolute pos %X\\n\", count, src_pos);\n\n            CHECK_COUNT();\n\n            CHECK_COPY(src_pos);\n\n            for (i = 0; i < count; i++)\n\n                dest[dest_index + i] = dest[src_pos + i];\n\n            dest_index += count;\n\n\n\n        } else if (opcode > 0x80) {\n\n\n\n            count = opcode & 0x3F;\n\n            av_dlog(s->avctx, \"(4) copy %X bytes from source to dest\\n\", count);\n\n            CHECK_COUNT();\n\n            bytestream2_get_buffer(&s->gb, &dest[dest_index], count);\n\n            dest_index += count;\n\n\n\n        } else {\n\n\n\n            count = ((opcode & 0x70) >> 4) + 3;\n\n            src_pos = bytestream2_get_byte(&s->gb) | ((opcode & 0x0F) << 8);\n\n            av_dlog(s->avctx, \"(5) copy %X bytes from relpos %X\\n\", count, src_pos);\n\n            CHECK_COUNT();\n\n            CHECK_COPY(dest_index - src_pos);\n\n            for (i = 0; i < count; i++)\n\n                dest[dest_index + i] = dest[dest_index - src_pos + i];\n\n            dest_index += count;\n\n        }\n\n    }\n\n\n\n    /* validate that the entire destination buffer was filled; this is\n\n     * important for decoding frame maps since each vector needs to have a\n\n     * codebook entry; it is not important for compressed codebooks because\n\n     * not every entry needs to be filled */\n\n    if (check_size)\n\n        if (dest_index < dest_size)\n\n            av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: decode finished with dest_index (%d) < dest_size (%d)\\n\",\n\n                dest_index, dest_size);\n\n\n\n    return 0; // let's display what we decoded anyway\n\n}\n", "idx": 11877, "substitutes": {"s": ["g", "f", "src", "site", "service", "parts", "its", "k", "cs", "ls", "sf", "ss", "side", "xs", "sports", "sq", "c", "is", "ks", "ins", "services", "sv", "sb", "es", "h", "ts", "p", "si", "sg", "S", "session", "b", "outs", "fs", "ssl", "settings", "ds", "iss", "se", "sl", "bs", "ns", "hs", "spec", "ms", "ans", "us", "t", "ps", "ses", "l", "qs", "sync", "gs", "m", "conf", "as", "e", "n", "sets", "sys", "su", "rs", "js", "stats", "aws"], "src_size": ["src_scale", "src2scale", "src2address", "source_len", "src_dim", " src_scale", "source_dim", "src_index", "source_index", "src_capacity", "src2size", "src_address", "source_size", "src2capacity", " src_capacity", " src_address", "src_len"], "dest": ["transform", "dat", "prop", "text", " destination", "append", "src", "match", "build", "path", "cdn", "buf", "home", "table", "output", "result", "route", "dist", "draw", "config", "Dest", "temp", "options", "loc", "done", "img", "test", "cont", "neg", "uv", "tmp", "dc", "source", "opt", "attr", "sort", "select", "dim", "buff", "delete", "desc", "trans", "info", "origin", "rest", "status", "txt", "data", "target", "coord", "sum"], "dest_size": ["class_loc", "dest_loc", "source_offset", "class2id", "class2pos", "dest2id", "class_pos", " dest_address", "dest_type", " dest_length", "class_id", "dest2size", "dest_id", "source_index", "source_pos", "class2loc", "dest_pos", "dest_offset", "dest_length", "dest_address", "dest_index", "dest2pos", "class2size", "source_size", " dest_type", "dest2loc", "class_size"], "check_size": ["flush67index", "destfsize", "flush_size", "flush_index", "dest67size", "destfindex", "destflength", "dest67length", "flush_length", "destacsize", "dest_pos", "destfpos", "dest_length", "dest67pos", "dest_index", "flush67pos", "flush_pos", "destacindex", "destaclength", "destacpos", "flush67length", "dest67index", "flush67size"], "count": ["text", "empty", "max", "ref", "err", "comp", "Count", "alpha", "c", "span", "b", "missing", "cc", "key", "time", "all", "child", "depth", "sum", "size", "id", "limit", "weight", "keep", "close", "cat", "use", "code", "coll", "parent", "num", "length", "error", "force", "call", "base", "multiple", "read", "print", "list", "f", "handle", "len", "content", "catch", "total", "part", "add", "ind", "l", "index", "cond", "current", "large", "name", "number", "cost", "find", "cast", "type", "match", "cycle", "found", "label", "p", "offset", "style", "core", "val", "col", "n", "process", "light", "check", "cache"], "opcode": ["opCode", "optype", " opgrade", "opaque", "OpCode", "opsCode", "popcodes", "Opstate", "opgrade", "optcodes", "copCode", "opttype", "Opcode", "ipopcod", " opname", "lockstate", "opcodes", " opstate", "popcode", "Opcod", "ipopgrade", "hopCode", "lockcode", " opcodes", "opercode", "operdesc", "errorcod", "opcod", "optdesc", "opername", "popgrade", "opstate", " opCode", "copcode", "OPcodes", "lockcod", "copstate", "errorcodes", "optCode", "opercodes", "OPdesc", "OPCode", "ipopcode", "hopcodes", "OPname", "coptype", "opscodes", "OPcode", "popcod", "optcode", "opsmode", "opmode", "opc", "opermode", "OPc", " optype", "optaque", " opcod", "hopcode", "operc", "operCode", " opmode", "optc", " opc", "opdesc", "opname", " opaque", "opscode", "hopcod", "optstate", "ipopcodes", "lockCode", "errorcode", "operaque", "errorCode"], "start": ["shift", "pos", "like", "size", "type", "id", "max", "started", "mid", "min", "len", "art", "p", "offset", "step", "stage", "sp", "st", "range", "use", "it", "ish", "end", "ie", "part", "scale", "key", "from", "in", "add", "Start", "ind", "length", "source", "sort", "get", "try", "index", "pad", "init", "set", "starting", "space", "ad", "send", "stop", "skip", "sum"], "src_pos": ["rc_pos", " src_loc", "srcpsize", "target_pos", "srcPsol", "src___size", " src_position", "src24limit", "distPsize", "rc_po", "src00pos", "http_count", "distPposition", "sort_limit", "sub_pos", "src_po", "src67loc", "srcpposition", "src67pos", " src_po", "src00flo", "dist_position", "src67offset", "srcploc", "srcsloc", "src_point", "srcPpo", "http_offset", "srcampos", " src_index", "srcPpoint", "src1pos", "sort_pos", "targetampoint", "srcPpos", "src00limit", "src_loc", "sub_count", "sort00pos", "http_pos", "src_index", " src_cos", "src___position", "dist_size", "src24offset", "srcamloc", "rc_point", "src_sol", "srcspo", "src_cos", "src1offset", "srcampoint", "src24flo", "src_count", "target_loc", "http_vis", "sub_loc", "srcPsize", "src0position", "srcsindex", "sort00flo", "srcpcount", "target_point", "rc_position", "src24pos", "src_flo", "targetamloc", "sort00offset", "distPpos", "src_offset", "src67po", "src_position", "src___pos", "src_limit", "sort_offset", "src67vis", "src0cos", "src67count", "src0pos", "src00offset", "distPsol", "src1vis", "sub_position", "srcpsol", "srcPposition", "srcspos", "src___sol", "dist_pos", "sort00limit", "src_vis", "targetampos", "srcppos", "src1count", "sort_flo", "src0po", "src67index", "dist_sol"], "color": ["type", "COLOR", "src", "colored", "id", "pal", "format", " colour", "black", "gray", "alpha", "white", "c", "cycle", " col", "rc", " cursor", "cat", " rgb", "bg", " Color", "url", "style", "colour", "gb", "cor", " rc", " red", "coll", " source", "ch", " background", "source", " channel", " border", "resource", "chrom", "background", "border", "attr", "col", "or", "channel", "Color", "name", "status", " colors", "blue", "raw", " coord", "light", "sum"], "i": ["li", "ip", "mi", "chi", "byte", "c", "d", "bytes", "b", "key", "bi", "ui", "all", "ci", "e", "info", "ai", "eni", "it", "ii", "ni", "id", "phi", "api", "oi", "j", "ie", "hi", "z", "code", "xi", "qi", "base", "f", "y", "len", "you", "gi", "di", "ti", "v", "ind", "_", "l", "index", "u", "mini", "name", "x", "ix", "g", "pos", "uri", "type", "I", "fi", "iu", "ini", "multi", "ji", "p", "offset", "si", "pi", "io", "ori", "t", "buffer", "col", "n", "slice"]}}
{"project": "FFmpeg", "commit_id": "d3b25383daffac154846daeb4e4fb46569e728db", "target": 1, "func": "static int zero12v_decode_frame(AVCodecContext *avctx, void *data,\n\n                                int *got_frame, AVPacket *avpkt)\n\n{\n\n    int line = 0, ret;\n\n    const int width = avctx->width;\n\n    AVFrame *pic = data;\n\n    uint16_t *y, *u, *v;\n\n    const uint8_t *line_end, *src = avpkt->data;\n\n    int stride = avctx->width * 8 / 3;\n\n\n\n    if (width == 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Width 1 not supported.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (   avctx->codec_tag == MKTAG('0', '1', '2', 'v')\n\n        && avpkt->size % avctx->height == 0\n\n        && avpkt->size / avctx->height * 3 >= width * 8)\n\n        stride = avpkt->size / avctx->height;\n\n\n\n    if (avpkt->size < avctx->height * stride) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small: %d instead of %d\\n\",\n\n               avpkt->size, avctx->height * stride);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n\n        return ret;\n\n\n\n    pic->pict_type = AV_PICTURE_TYPE_I;\n\n    pic->key_frame = 1;\n\n\n\n    y = (uint16_t *)pic->data[0];\n\n    u = (uint16_t *)pic->data[1];\n\n    v = (uint16_t *)pic->data[2];\n\n    line_end = avpkt->data + stride;\n\n\n\n    while (line++ < avctx->height) {\n\n        while (1) {\n\n            uint32_t t = AV_RL32(src);\n\n            src += 4;\n\n            *u++ = t <<  6 & 0xFFC0;\n\n            *y++ = t >>  4 & 0xFFC0;\n\n            *v++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 1) {\n\n                *y = 0x80;\n\n                src++;\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *y++ = t <<  6 & 0xFFC0;\n\n            *u++ = t >>  4 & 0xFFC0;\n\n            *y++ = t >> 14 & 0xFFC0;\n\n            if (src >= line_end - 2) {\n\n                if (!(width & 1)) {\n\n                    *y = 0x80;\n\n                    src += 2;\n\n                }\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *v++ = t <<  6 & 0xFFC0;\n\n            *y++ = t >>  4 & 0xFFC0;\n\n            *u++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 1) {\n\n                *y = 0x80;\n\n                src++;\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *y++ = t <<  6 & 0xFFC0;\n\n            *v++ = t >>  4 & 0xFFC0;\n\n            *y++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 2) {\n\n                if (width & 1) {\n\n                    *y = 0x80;\n\n                    src += 2;\n\n                }\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 11885, "substitutes": {"avctx": ["navctx", " avxc", "apcmd", "afconfig", "avcf", "aveloc", "afcmd", "navxc", "avalrx", "ajcot", "avalconn", "navloc", "avkb", "avalcu", "avalcmd", "avcca", "ajcs", "afcu", "AVcu", "apcu", "navctl", "ajcn", "avectx", "navcontext", "ajcontext", " avloc", "avcmd", " avcontext", "avexc", "apcontext", "avcup", "afcot", "avalcontext", "aflc", "afcdn", "AVconn", "avecot", "avecontext", "abcup", "AVcontext", "avelc", "averx", "avalcup", "avconn", "afcn", "avctl", "afcontext", "ajloc", "avconfig", "ajcmp", "AVctx", "afkb", "avcot", "abcontext", "avlc", "avloc", "afrx", "afcca", "abcu", "afconn", "avecdn", "ajctx", "ajctl", "avrx", "aveconfig", "avalcdn", "avecn", "avecmp", "avalcmp", "afctl", "avecca", "afctx", "navconn", "afcmp", " avkb", "avcdn", "avcmp", "afcup", "avcontext", "avecf", "avalctx", "ajkb", "ajxc", "avcs", "avecs", "ajlc", "avecu", "avcu", "abctx", "navcca", "afcf", "apctx", "afcs", "ajconfig", "afloc", "afxc", " avconn", "avxc", "avcn", "aveconn", "navcf"], "data": ["padding", "gap", "first", "empty", "alpha", "i", "d", "draw", "bytes", "open", "memory", "channel", "ui", "next", "height", "pad", "depth", "dat", "layout", "size", "id", "actions", "api", "result", "module", "off", "DATA", "frame", "img", "end", "code", "record", "parent", "header", "bin", "delay", "base", "video", "ad", "align", "read", "action", "shift", "Data", "date", "buf", "config", "content", "scale", "source", "picture", "start", "index", "body", "name", "window", "ata", "args", "sample", "device", "final", "devices", "addr", "media", "offset", "input", "results", "inner", "style", "image", "reader", "da", "val", "head", "capt", "buffer", "batch", "slice", "cache"], "got_frame": ["gotoutframe", " got_file", " got_length", "got__range", "got__frame", "got__length", "got_range", "got__file", "got_file", "gotoutlength", "gotoutfile", " got_range", "got_length", "gotoutrange"], "avpkt": ["avlnt", "avnsth", "avepnt", "ullpacket", "avpracket", "avcpacket", "AVcpacket", "awpck", "awbpkt", "avprkt", "avlutt", "avpke", "ullprunt", "awbpcht", "ullpkt", "awbpck", "AVcpcht", "avepacket", "avpett", "avpinch", "avpft", "avenpkt", "avepck", "AVpcht", "avenpeth", "avpct", "avpilot", "avninch", " avpnt", "avlpkt", "avnct", "avnpnt", "avspnt", "avenacket", "avepkt", "avpcft", "ovlpinch", "avcpkt", "avnpacket", "awpcht", "ullprilot", "avnpsth", "avcpcht", "afpkt", "avprke", "avpckt", "avpagesth", "avnnt", "AVpct", "ullprkt", "avPacket", "affacket", "avpunt", "avspcht", "avcunt", "avennt", "affck", "AVcpct", "avnkt", "avspkt", "avprunt", "avnpck", "affcht", "ullpracket", "avprnt", "avbpkt", "avPkt", "AVpacket", "avpeth", "avlke", "avcpeth", "avPcht", "avenpck", "avnpkt", "ovpinch", "ovpkt", " avprutt", "avnpcht", "avcpft", "avspacket", "AVpkt", "avprilot", "avfsth", "avensth", "avpailot", "avPct", "ovpnt", "avputt", "avfck", "afpacket", "avspett", "avfkt", " avprke", "avpaunt", "afpck", "avnpeth", "avfnt", " avputt", "awbpett", "avpagent", "avpcht", "ullpunt", "avpck", " avprnt", "avbpcht", "avepft", "avpceth", "ovpsth", "avfacket", "avncht", "avlpnt", "ovlpsth", "avnpft", "avnpett", "avpsth", "avcpck", " avprkt", "avpaacket", "avnacket", "avlpsth", "awpett", "avenkt", "avcpct", "avckt", "avbpck", "avenpft", "avpacket", "avpagekt", "avspck", "avepsth", "avbpett", "avpcck", "avlpinch", "avfcht", "ovlpkt", "avpacht", "avcacket", "ullpilot", "avsputt", "avepeth", "affkt", "avcilot", " avpke", "afpcht", "avpack", "avpageinch", "avspke", "avpnt", "avprutt", "avpakt", "AVcpkt", "avlkt", "ovlpnt", "awpkt"], "ret": ["tr", "no", "rt", "rets", "match", "re", "RET", "ref", "ft", "result", "success", "len", "ben", "back", "cur", "arr", "fun", "lit", "flag", "ext", "red", "code", "num", "r", "pin", "val", "det", "rep", "def", "fail", "error", "t", "job", "arg", "reply", "buffer", "res", "nt", "fin", "alt", "Ret", "bf", "status", "bot", "str"], "pic": ["bus", "plugin", "parse", "pse", "fn", "file", "chat", "vec", "study", "fi", "proc", "bc", "pixel", "seq", "vc", "c", "cci", "cycle", "pc", "quad", "jp", "module", "feature", "sit", "config", "cat", "p", "sci", "fake", "ic", "pi", "pict", "Pic", "img", "doc", "ctrl", "tick", "piece", "fat", "xi", "ac", "image", "fc", "bi", "spec", "pin", "bin", "pie", "mac", "picture", "dot", "pick", "sync", "pins", "cus", "git", "capt", "oc", "sys", "photo", "syn", "lc", "mini", "sec", "py", "ig", "typ", "feat", "cache"], "y": ["ey", "yd", "yy", "type", "f", "id", "yo", "ky", "iy", "k", "ip", "ny", "ys", "ya", "c", "yi", "i", "yn", "d", "h", "p", "dy", "vy", "b", "cy", "year", "j", "z", "hi", "ye", "ch", "sy", "t", "o", "l", "start", "sky", "ym", "ady", "w", "m", "height", "ty", "col", "yt", "n", "e", "Y", "s", "yu", "py", "oy", "x"], "u": ["up", "f", "tu", "un", "k", "ur", "U", "ou", "ul", "c", "iu", "a", "i", "d", "pu", "h", "p", "b", "nu", "cu", "uu", "uv", "z", "o", "ui", "t", "du", "r", "l", "q", "w", "m", "uid", "n", "su", "lu", "uni", "x"], "v": ["g", "f", "k", "vt", "c", "ver", "i", "sv", "d", "h", "p", "b", "vy", "j", "end", "uv", "z", "t", "r", "o", "val", "l", "V", "q", "vp", "w", "m", "e", "n", "value", "s", "vv", "vi", "ve", "vs", "x"], "line_end": ["line_End", " line_size", " line_name", " line_End", "line_start", "line_id", "lineacsize", "lineacstart", "lin_limit", " line_start", "line_length", "lineGend", "line_limit", "lineglength", "lin_shape", " line_length", "lineamshape", "linegsize", "line_shape", "line_name", "line_size", "lineGEnd", " line_id", "lineamend", "lineaclength", "lineacend", "linegstart", "lin_end", "linegend", "lineGname", "lineamlimit"], "src": ["rect", "sur", "uri", "sil", "dest", "text", "file", "path", "feat", "front", "lat", "vc", "ul", "c", "stat", "sup", "dist", "sit", "sr", "d", "i", "sb", "rc", "config", "cb", "cur", "dy", "rl", "split", "loc", "st", "lit", "sid", "filename", "img", "url", "gb", "uv", "sl", "rb", "iv", "fc", "spec", "image", "ch", "ind", "source", "channel", "sc", "start", "hl", "head", "gs", "sn", "desc", "origin", "s", "uc", "sec", "stream", "txt", "inst", "depth", "slice"], "line": ["ne", "pos", "li", "LINE", "block", "limit", "ine", "edge", "side", "byte", "len", "user", " lin", "d", "lo", "dy", "lines", "loc", "cell", "liner", "le", "range", "frame", "url", "nl", "sl", "day", "code", "pe", "row", "Line", "lin", "source", "link", "level", "force", "l", "start", "base", "n", "unit", "lc", "page", "name", "lf", "slice"]}}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static inline int test_bit(uint32_t *field, int bit)\n\n{\n\n    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;\n\n}\n", "idx": 11911, "substitutes": {"field": ["message", "block", "type", "f", "match", "class", "result", "fields", "round", "event", "patch", "card", "input", "seed", "FIELD", "inner", "fred", "object", "style", "flag", "end", "rule", "key", "address", "record", "entry", "filter", "layer", "group", "index", "form", "map", "buffer", "Field", "pad", "holder", "window", "data", "slice"], "bit": ["big", "text", "no", "f", "type", "Bit", "apt", "ip", "hit", "tag", "byte", "option", "quad", "i", "feature", "patch", "cat", "digit", "offset", "slot", "BIT", "b", "ct", "flag", "part", "key", "bot", "act", "op", "ac", "num", "bin", "opt", "word", "index", "arg", "col", "unit", "bits", "token", "value", "fix", "band", "bug", "feat", "number", "letter", "fact", "it"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_decimal(void)\n\n{\n\n    const char *str = \"0123\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 10, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n\n\n    str = \"123\";\n\n    res = 999;\n\n    endptr = &f;\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 11919, "substitutes": {"str": ["tr", "ctr", "fr", "text", "ocr", "empty", "f", "unc", "vec", "id", "hr", "frac", "prev", "x", "seq", "c", "exec", "iter", "sr", "dr", "pr", "cur", "enc", "expr", "arr", "sp", "orig", "st", "inner", "url", "ext", "doc", "stri", "code", "r", "br", "txt", "kr", "o", "sc", "u", "start", "form", "cr", "gr", "last", "STR", "e", "data", "er", "rs", "lc", "rr", "s", "name", "inst", "zero", "Str"], "endptr": ["endedctr", "endpointer", "adpert", "adproc", "endridge", "startpointers", "endingptr", "edptr", "endingeger", "starttr", "etpointer", "endingfd", "edpert", "etpt", "endingaddr", "endingpointer", "endingpert", "sendptr", "starteger", "startptr", "endaddr", "endedpointer", "entpointer", " endpointer", "entaddr", " endridge", "adpt", "endpert", "endpointers", " endpty", "endedtr", "endtr", "sendtr", " endproc", "entptr", "edpointer", "endeger", "entpty", "endedpert", " endpert", "endfd", "etptr", "entridge", "sendpointer", "adptr", "adpointer", "endedptr", "endedpointers", "endproc", "entfd", " endpt", "startpointer", "startfd", "edproc", "endingpty", "endingctr", "endingridge", "endpty", " endaddr", "sendpointers", "etproc", "adctr", "endctr", "endpt", "enteger"], "err": ["Error", "aster", "fr", "f", "resp", "fi", " error", "exc", "orer", "result", "fer", "ver", "mr", "Er", "iter", "finder", "ger", "dr", "ner", "order", "arr", " r", "der", "work", "runner", "erer", "ler", "ar", "rb", "yr", "code", "magic", "arm", "r", "ise", "error", "all", "count", "req", "attr", "eor", "acer", "kr", "ir", "cr", "gr", " Err", "er", "rr", "res", "ec", "rh", "fg", "grade", "bug", "rar", "rage"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void piix3_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    dc->desc        = \"ISA bridge\";\n\n    dc->vmsd        = &vmstate_piix3;\n\n    dc->no_user     = 1,\n\n    k->no_hotplug   = 1;\n\n    k->init         = piix3_initfn;\n\n    k->config_write = piix3_write_config;\n\n    k->vendor_id    = PCI_VENDOR_ID_INTEL;\n\n    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */\n\n    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;\n\n    k->class_id     = PCI_CLASS_BRIDGE_ISA;\n\n}\n", "idx": 11933, "substitutes": {"klass": [" kcl", "kazz", "skcl", "cklf", "skazz", "Kclass", " klf", " kclass", "kclass", "Kcl", "oklf", "sklass", "skclass", "sklf", " klasses", "klasses", "cklass", "cklasses", "okazz", "sklasses", "klf", "kcl", "Klass", "ckclass", "Klasses", "oklass", "okclass", " kazz"], "data": ["dat", "ata", "ctx", "device", "Data", "result", "module", "c", "d", "params", "DATA", "new", "config", "input", "ds", "load", "context", "di", "dd", "parent", "da", "def", "m", "info", "raw", "ad", "cache"], "dc": ["dat", "ga", "f", "device", "cdn", "cs", "nc", "DC", "vc", "c", "db", "design", "d", "disc", "dr", "rc", "config", "tk", "ck", "ds", "ct", "doc", "enter", "dk", "cc", "di", "ac", "dd", "df", "da", "cf", "sc", "conn", "u", "acc", "desc", "tc", "mc", "lc", "ec", "dt", "cd"], "k": ["ok", "g", "f", "kick", "ke", "self", "K", "wk", "kid", "c", "kn", "ki", "ak", "ks", "i", "d", "uk", "p", "tk", "ck", "kk", "work", "ijk", "kw", "ku", "dk", "ko", "kt", "key", "mk", "v", "spec", "ac", "kin", "o", "t", "ik", "kind", "q", "u", "sync", "w", "e", "n", "sk", "s", "ad"]}}
{"project": "qemu", "commit_id": "eefa3d8ef649f9055611361e2201cca49f8c3433", "target": 1, "func": "qio_channel_websock_source_dispatch(GSource *source,\n\n                                    GSourceFunc callback,\n\n                                    gpointer user_data)\n\n{\n\n    QIOChannelFunc func = (QIOChannelFunc)callback;\n\n    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;\n\n    GIOCondition cond = 0;\n\n\n\n    if (wsource->wioc->rawinput.offset) {\n\n        cond |= G_IO_IN;\n\n    }\n\n    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {\n\n        cond |= G_IO_OUT;\n\n    }\n\n\n\n    return (*func)(QIO_CHANNEL(wsource->wioc),\n\n                   (cond & wsource->condition),\n\n                   user_data);\n\n}\n", "idx": 11936, "substitutes": {"wsource": ["fwspec", "swsrc", "swource", "Wource", "kwsource", "wwsource", "rwspec", "Wspec", "wconfig", "gsrc", "rwsource", "kwource", "rwservice", "wresource", "wchannel", "waource", "Wsource", "wwsrc", "gource", " wsrc", "gsource", "rwchannel", "kwconfig", " wchannel", "kwsrc", "fwservice", "wsrc", " wconfig", "Wresource", "wasrc", "Wservice", "wwresource", "Wsrc", "gservice", "wservice", " wource", "wwource", "swsource", "waresource", "fwchannel", "Wconfig", "wource", " wservice", "swchannel", "wasource", "wspec", "Wchannel", "fwsource", "kwchannel"]}}
{"project": "qemu", "commit_id": "e40c3d2e7f4b58669a1b4e5dfb684e57c0bf62ce", "target": 0, "func": "static void acpi_dsdt_add_pci(Aml *scope, const MemMapEntry *memmap,\n\n                              uint32_t irq, bool use_highmem)\n\n{\n\n    Aml *method, *crs, *ifctx, *UUID, *ifctx1, *elsectx, *buf;\n\n    int i, bus_no;\n\n    hwaddr base_mmio = memmap[VIRT_PCIE_MMIO].base;\n\n    hwaddr size_mmio = memmap[VIRT_PCIE_MMIO].size;\n\n    hwaddr base_pio = memmap[VIRT_PCIE_PIO].base;\n\n    hwaddr size_pio = memmap[VIRT_PCIE_PIO].size;\n\n    hwaddr base_ecam = memmap[VIRT_PCIE_ECAM].base;\n\n    hwaddr size_ecam = memmap[VIRT_PCIE_ECAM].size;\n\n    int nr_pcie_buses = size_ecam / PCIE_MMCFG_SIZE_MIN;\n\n\n\n    Aml *dev = aml_device(\"%s\", \"PCI0\");\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A08\")));\n\n    aml_append(dev, aml_name_decl(\"_CID\", aml_string(\"PNP0A03\")));\n\n    aml_append(dev, aml_name_decl(\"_SEG\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"_BBN\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"PCI0\")));\n\n    aml_append(dev, aml_name_decl(\"_STR\", aml_unicode(\"PCIe 0 Device\")));\n\n    aml_append(dev, aml_name_decl(\"_CCA\", aml_int(1)));\n\n\n\n    /* Declare the PCI Routing Table. */\n\n    Aml *rt_pkg = aml_package(nr_pcie_buses * PCI_NUM_PINS);\n\n    for (bus_no = 0; bus_no < nr_pcie_buses; bus_no++) {\n\n        for (i = 0; i < PCI_NUM_PINS; i++) {\n\n            int gsi = (i + bus_no) % PCI_NUM_PINS;\n\n            Aml *pkg = aml_package(4);\n\n            aml_append(pkg, aml_int((bus_no << 16) | 0xFFFF));\n\n            aml_append(pkg, aml_int(i));\n\n            aml_append(pkg, aml_name(\"GSI%d\", gsi));\n\n            aml_append(pkg, aml_int(0));\n\n            aml_append(rt_pkg, pkg);\n\n        }\n\n    }\n\n    aml_append(dev, aml_name_decl(\"_PRT\", rt_pkg));\n\n\n\n    /* Create GSI link device */\n\n    for (i = 0; i < PCI_NUM_PINS; i++) {\n\n        uint32_t irqs =  irq + i;\n\n        Aml *dev_gsi = aml_device(\"GSI%d\", i);\n\n        aml_append(dev_gsi, aml_name_decl(\"_HID\", aml_string(\"PNP0C0F\")));\n\n        aml_append(dev_gsi, aml_name_decl(\"_UID\", aml_int(0)));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n                   aml_interrupt(AML_CONSUMER, AML_LEVEL, AML_ACTIVE_HIGH,\n\n                                 AML_EXCLUSIVE, &irqs, 1));\n\n        aml_append(dev_gsi, aml_name_decl(\"_PRS\", crs));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n                   aml_interrupt(AML_CONSUMER, AML_LEVEL, AML_ACTIVE_HIGH,\n\n                                 AML_EXCLUSIVE, &irqs, 1));\n\n        aml_append(dev_gsi, aml_name_decl(\"_CRS\", crs));\n\n        method = aml_method(\"_SRS\", 1, AML_NOTSERIALIZED);\n\n        aml_append(dev_gsi, method);\n\n        aml_append(dev, dev_gsi);\n\n    }\n\n\n\n    method = aml_method(\"_CBA\", 0, AML_NOTSERIALIZED);\n\n    aml_append(method, aml_return(aml_int(base_ecam)));\n\n    aml_append(dev, method);\n\n\n\n    method = aml_method(\"_CRS\", 0, AML_NOTSERIALIZED);\n\n    Aml *rbuf = aml_resource_template();\n\n    aml_append(rbuf,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0x0000, 0x0000, nr_pcie_buses - 1, 0x0000,\n\n                            nr_pcie_buses));\n\n    aml_append(rbuf,\n\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                         AML_NON_CACHEABLE, AML_READ_WRITE, 0x0000, base_mmio,\n\n                         base_mmio + size_mmio - 1, 0x0000, size_mmio));\n\n    aml_append(rbuf,\n\n        aml_dword_io(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                     AML_ENTIRE_RANGE, 0x0000, 0x0000, size_pio - 1, base_pio,\n\n                     size_pio));\n\n\n\n    if (use_highmem) {\n\n        hwaddr base_mmio_high = memmap[VIRT_PCIE_MMIO_HIGH].base;\n\n        hwaddr size_mmio_high = memmap[VIRT_PCIE_MMIO_HIGH].size;\n\n\n\n        aml_append(rbuf,\n\n            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_NON_CACHEABLE, AML_READ_WRITE, 0x0000,\n\n                             base_mmio_high, base_mmio_high, 0x0000,\n\n                             size_mmio_high));\n\n    }\n\n\n\n    aml_append(method, aml_name_decl(\"RBUF\", rbuf));\n\n    aml_append(method, aml_return(rbuf));\n\n    aml_append(dev, method);\n\n\n\n    /* Declare an _OSC (OS Control Handoff) method */\n\n    aml_append(dev, aml_name_decl(\"SUPP\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"CTRL\", aml_int(0)));\n\n    method = aml_method(\"_OSC\", 4, AML_NOTSERIALIZED);\n\n    aml_append(method,\n\n        aml_create_dword_field(aml_arg(3), aml_int(0), \"CDW1\"));\n\n\n\n    /* PCI Firmware Specification 3.0\n\n     * 4.5.1. _OSC Interface for PCI Host Bridge Devices\n\n     * The _OSC interface for a PCI/PCI-X/PCI Express hierarchy is\n\n     * identified by the Universal Unique IDentifier (UUID)\n\n     * 33DB4D5B-1FF7-401C-9657-7441C03DD766\n\n     */\n\n    UUID = aml_touuid(\"33DB4D5B-1FF7-401C-9657-7441C03DD766\");\n\n    ifctx = aml_if(aml_equal(aml_arg(0), UUID));\n\n    aml_append(ifctx,\n\n        aml_create_dword_field(aml_arg(3), aml_int(4), \"CDW2\"));\n\n    aml_append(ifctx,\n\n        aml_create_dword_field(aml_arg(3), aml_int(8), \"CDW3\"));\n\n    aml_append(ifctx, aml_store(aml_name(\"CDW2\"), aml_name(\"SUPP\")));\n\n    aml_append(ifctx, aml_store(aml_name(\"CDW3\"), aml_name(\"CTRL\")));\n\n    aml_append(ifctx, aml_store(aml_and(aml_name(\"CTRL\"), aml_int(0x1D), NULL),\n\n                                aml_name(\"CTRL\")));\n\n\n\n    ifctx1 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));\n\n    aml_append(ifctx1, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(0x08), NULL),\n\n                                 aml_name(\"CDW1\")));\n\n    aml_append(ifctx, ifctx1);\n\n\n\n    ifctx1 = aml_if(aml_lnot(aml_equal(aml_name(\"CDW3\"), aml_name(\"CTRL\"))));\n\n    aml_append(ifctx1, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(0x10), NULL),\n\n                                 aml_name(\"CDW1\")));\n\n    aml_append(ifctx, ifctx1);\n\n\n\n    aml_append(ifctx, aml_store(aml_name(\"CTRL\"), aml_name(\"CDW3\")));\n\n    aml_append(ifctx, aml_return(aml_arg(3)));\n\n    aml_append(method, ifctx);\n\n\n\n    elsectx = aml_else();\n\n    aml_append(elsectx, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(4), NULL),\n\n                                  aml_name(\"CDW1\")));\n\n    aml_append(elsectx, aml_return(aml_arg(3)));\n\n    aml_append(method, elsectx);\n\n    aml_append(dev, method);\n\n\n\n    method = aml_method(\"_DSM\", 4, AML_NOTSERIALIZED);\n\n\n\n    /* PCI Firmware Specification 3.0\n\n     * 4.6.1. _DSM for PCI Express Slot Information\n\n     * The UUID in _DSM in this context is\n\n     * {E5C937D0-3553-4D7A-9117-EA4D19C3434D}\n\n     */\n\n    UUID = aml_touuid(\"E5C937D0-3553-4D7A-9117-EA4D19C3434D\");\n\n    ifctx = aml_if(aml_equal(aml_arg(0), UUID));\n\n    ifctx1 = aml_if(aml_equal(aml_arg(2), aml_int(0)));\n\n    uint8_t byte_list[1] = {1};\n\n    buf = aml_buffer(1, byte_list);\n\n    aml_append(ifctx1, aml_return(buf));\n\n    aml_append(ifctx, ifctx1);\n\n    aml_append(method, ifctx);\n\n\n\n    byte_list[0] = 0;\n\n    buf = aml_buffer(1, byte_list);\n\n    aml_append(method, aml_return(buf));\n\n    aml_append(dev, method);\n\n\n\n    Aml *dev_rp0 = aml_device(\"%s\", \"RP0\");\n\n    aml_append(dev_rp0, aml_name_decl(\"_ADR\", aml_int(0)));\n\n    aml_append(dev, dev_rp0);\n\n    aml_append(scope, dev);\n\n}\n", "idx": 11957, "substitutes": {"scope": ["global", "args", "mode", "proc", "engine", "bc", "module", "instance", "node", "config", "mod", "app", "context", "core", "ms", "alloc", "mac", "resource", "req", "attr", "sc", "buffer", "func", "sys", "ram", "var", "window"], "memmap": ["limcache", " memmaps", "ramdata", "ramcache", "hwmap", "mmmap", "memper", "mmap", "memcap", "mmmaps", " mempad", "mmcap", "accessmaps", "rammap", "limmap", "memorymap", "memorycap", "Memmap", "memmem", "ramcap", "memorypad", "mempad", "memcache", "limmem", " memblock", "accessmap", "Memblock", "limcap", "accesscap", " memmem", "memdata", "Memcache", "hwcap", " memper", " memap", "memblock", "Memap", "accessap", "memoryblock", "memorydata", "hwpad", "memorycache", "hwper", "memorymem", " memcache", "memap", " memdata", " memcap", "memoryap", "memoryper", "memmaps"], "irq": ["ierq", "irque", "irtch", "ierce", "ierque", "irce", "irtq", "ierch", "rice", "rique", "irch", "rich", "riq", "irtce", "irtque"], "use_highmem": ["use_maxmm", "use_lowmem", "use_maxmem", "use_fullmemory", "use_maxmemory", "usefhighram", "use_lowram", "use_highmm", "use_lowmemory", "use_lowmm", "useflowram", "useflowmm", "useflowmem", "use_fullmm", "use_fullmem", "use_highram", "usefhighmemory", "use_maxram", "use_highmemory", "usefhighmem", "useflowmemory", "usefhighmm", "use_fullram"], "method": ["mode", "path", "ip", "class", "engine", "roll", "module", "instance", "mod", "METHOD", "function", "session", "app", "math", "ssl", "array", "package", "op", "coll", "mem", "attr", "cmd", "call", "func", "ram", "each"], "crs": ["xcRS", "Cros", "Crs", "acrs", "xcrs", "cRS", "acss", "CRS", "css", "Css", "acRS", "xcss", "acros", "cros", "xcros"], "ifctx": ["fcb", "fconfig", "ifconfig", "IFcontext", "IFcb", "fctx", "IFconfig", " ifcb", "fcontext", " ifconfig", "IFctx", "ifcontext", " ifcontext", "ifcb"], "UUID": ["uID", "GUID", "Uuid", "uUID", "CUID", "UID", "GID", "CInt", "Guid", "CID", "uInt", "uuid", "Cuid", "UInt", "GInt"], "ifctx1": ["ifconfig2", "Ifcontext2", "ifctx0", "Ifctx0", "Ifctx2", "ifctx2", "iflc0", "ifcontext1", "Ifctx1", "ifconfig0", "iflc2", "ifcontext2", "ifconfig1", "Ifcontext0", "ifcontext0", "iflc1", "Ifcontext1"], "elsectx": ["elapsedc", "elapsed8", "elifx", "elgl8", "neloady", "elgly", "nelify", "elapsedx", "eloadc", "neloadx", "neloadc", "elglx", "nelifc", "nelifx", "eloady", "eloadx", "elapsedy", "elifc", "elif8", "elglc", "eload8", "neload8", "elify", "nelif8"], "buf": ["block", "pool", "src", "callback", "ref", "bc", "seq", "box", "rc", "cb", "blocks", "queue", "img", "mem", "alloc", "br", "bin", "Buffer", "cmd", "uf", "buff", "buffer", "func", "port", "msg", "cap", "batch", "cache"], "i": ["ii", "ni", "li", "uri", "f", "id", "phi", "I", "k", "ip", "jit", "c", "iu", "a", "jp", "d", "multi", "ji", "p", "si", "b", "io", "j", "gi", "part", "cli", "di", "xi", "v", "bi", "ti", "num", "qi", "o", "ui", "ind", "t", "l", "ci", "start", "index", "u", "m", "e", "n", "lc", "name", "in", "ix", "it"], "bus_no": ["bisaystep", "pluginingmode", "busaystep", "bis_step", " bus_num", "plugin_nb", "bus64no", "busingNo", "busayno", " bus_No", "bus_bo", "bus64pos", "bus_num", "pluginingno", "bus_No", "BUS_la", "busingeno", "bus64mode", "pluginingnb", "bisaykey", "busianno", "plugin_no", "busingkey", "busayeno", "busaykey", "busingnb", "bis_no", "bus64nb", "BUS_no", "busianbo", "busingpos", "bus_pos", "pluginingpos", "busingnum", "bis_key", "bisayno", "plugin_pos", "busingno", "busingstep", "BUS_bo", "bus_eno", "bus_mode", "bus_key", "bus_step", "bisayeno", "bis_eno", "busianla", "bus_nb", "busingmode", "plugin_mode", "bus_la"], "dev": ["debug", "dem", "vol", "pos", "die", "block", "pub", "device", "diff", "comment", "stick", "err", "self", "home", "serial", "develop", "engine", "DEV", "gu", "module", "ver", "private", "adv", "dist", "d", "off", "node", "pack", "ev", "model", "development", "mod", "des", "cur", "app", "boot", "driver", "project", "Dev", "grad", "test", "prom", "prof", "package", "push", "fail", "error", "attr", "req", "def", "conn", "lib", "od", "pad", "conf", "info", "fw", "var", "priv", "bug", "data"], "rt_pkg": ["rt_packages", "rt_kg", "rt2kg", "rt2pkg", "rt2pack", "rt2packages", "nt_kg", "nt_pack", "nt_packages", "rt_pack", "nt_pkg"]}}
{"project": "qemu", "commit_id": "ae261c86aaed62e7acddafab8262a2bf286d40b7", "target": 0, "func": "static int vmdk_parent_open(BlockDriverState *bs)\n\n{\n\n    char *p_name;\n\n    char desc[DESC_SIZE + 1];\n\n    BDRVVmdkState *s = bs->opaque;\n\n\n\n    desc[DESC_SIZE] = '\\0';\n\n    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {\n\n        return -1;\n\n    }\n\n\n\n    if ((p_name = strstr(desc,\"parentFileNameHint\")) != NULL) {\n\n        char *end_name;\n\n\n\n        p_name += sizeof(\"parentFileNameHint\") + 1;\n\n        if ((end_name = strchr(p_name,'\\\"')) == NULL)\n\n            return -1;\n\n        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)\n\n            return -1;\n\n\n\n        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11958, "substitutes": {"bs": ["abi", "bos", "os", "als", "bis", "its", "cs", "ls", "state", "ss", "bc", "BS", "pb", "lb", "ins", "bl", "sb", "es", "bytes", "ts", "iss", "ds", "b", "blocks", "fs", "fb", "outs", "bh", "bes", "ns", "cms", "css", "us", "bi", "bb", "bing", "ps", "ses", "ubis", "plugins", "ab", "gs", "banks", "ros", "ubs", "las", "ob", "bits", "bas", "rs", "obs", "sa", "lbs", "js", "vs", "ba", "aws"], "p_name": ["p_no", "P_block", "p_on", " pflabel", "p_error", "powsize", "P_name", " p_key", " p_label", "pfname", "pftime", "end_Name", "pflabel", "powsession", "prev_no", "p8NAME", "lp_alias", " pftime", "P_size", "p2no", " p_Name", "p_start", "p_alias", " p_size", " powstart", " powName", "p_block", "p__size", "pameerror", "pfsize", "pameName", "powlabel", "p2path", "powtime", " pfname", "p2name", "end_NAME", "lp_name", "p_label", "pameNAME", "P_Name", "p__label", "p_path", "p_key", "powName", "p__time", "p_size", "p__name", " p_start", " p_num", "p_NAME", "p2size", "p8Name", "p_time", "powstart", "p_session", "prev_name", " p_session", "lp_on", "lp_key", "powname", "p8name", " powname", " powsession", "pamename", "p_Name", " p_time", "prev_size", "p8error", "prev_path", " pfsize", "end_error", "p_num"], "desc": ["text", "dest", "src", " describe", "comment", "path", "description", "DES", "buf", "Description", "sub", "seq", "dist", "esc", "config", "des", "rc", "Desc", "enc", "content", "loc", " description", "toc", "doc", "ext", "test", "cont", "feed", "summary", "dc", "code", "sort", "word", "def", "sc", "rec", "cod", "info", "su", "comments", "section", "lc", "sec", "name", "decl", "asc", "dir", "sum"], "s": ["os", "service", "cs", "ls", "ss", "states", "c", "is", "ins", "services", "es", "p", "ts", "si", "S", "session", "b", "settings", "sie", "ds", "ssl", "sl", "ns", "css", "us", "ps", "ses", "qs", "sync", "gs", "n", "sys", "sets", "sa", "js", "stats", "aws"], "end_name": ["end_value", "end__size", "ending_value", "end_call", "end_Name", "end_size", "endaynamed", "end_large", "end__time", "set_name", "endayame", "end_time", "end_named", "ending_name", "endfullname", "p_named", " end_time", "end__name", "endfullame", " end_size", "set_Name", "p_ame", "end_phase", "end_ame", "endfullnamed", "set_large", "ending_call", "endayname", "set_phase"]}}
{"project": "qemu", "commit_id": "bf55b7afce53718ef96f4e6616da62c0ccac37dd", "target": 0, "func": "static MemoryRegionSection address_space_do_translate(AddressSpace *as,\n\n                                                      hwaddr addr,\n\n                                                      hwaddr *xlat,\n\n                                                      hwaddr *plen,\n\n                                                      bool is_write,\n\n                                                      bool is_mmio)\n\n{\n\n    IOMMUTLBEntry iotlb;\n\n    MemoryRegionSection *section;\n\n    MemoryRegion *mr;\n\n\n\n    for (;;) {\n\n        AddressSpaceDispatch *d = atomic_rcu_read(&as->dispatch);\n\n        section = address_space_translate_internal(d, addr, &addr, plen, is_mmio);\n\n        mr = section->mr;\n\n\n\n        if (!mr->iommu_ops) {\n\n            break;\n\n        }\n\n\n\n        iotlb = mr->iommu_ops->translate(mr, addr, is_write);\n\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n\n                | (addr & iotlb.addr_mask));\n\n        *plen = MIN(*plen, (addr | iotlb.addr_mask) - addr + 1);\n\n        if (!(iotlb.perm & (1 << is_write))) {\n\n            goto translate_fail;\n\n        }\n\n\n\n        as = iotlb.target_as;\n\n    }\n\n\n\n    *xlat = addr;\n\n\n\n    return *section;\n\n\n\ntranslate_fail:\n\n    return (MemoryRegionSection) { .mr = &io_mem_unassigned };\n\n}\n", "idx": 11969, "substitutes": {"as": ["ares", "ask", "os", "at", "cs", "ais", "a", "is", "an", "rc", "ace", "asm", "pas", "ars", "acs", "asa", "ass", "ar", "se", "asu", "address", "ac", "ms", "ay", "ras", "As", "r", "aw", "attr", "ach", "am", "amd", "alias", "ast", "tx", "las", "sys", "er", "asi", "ai", "ase", "or", "s", "res", "sa", "var", "ad", "AS", "aws"], "addr": ["la", "rt", "at", "src", "ip", "host", "ea", "alpha", "a", "art", "rc", "orig", "ar", "address", "anne", "rx", "area", "az", "pad", "inet", "ast", "rs", "alt", "alias", "coord", "acl", "ack", "size", "id", "nr", "adder", "au", "ace", "enc", "ord", "vr", "grad", "pe", "attr", "amd", "base", "ad", "align", "hop", "owner", "prefix", "mode", "ptr", "len", "route", "afi", "config", "rd", "asm", "part", "dd", "layer", "r", "mac", "xp", "name", "x", "oa", "wd", "adr", "md", "dr", "amp", "p", "offset", "arr", "loc", "url", "enter", "ac", "proxy", "inter", "tx", "tta", "Address", "data"], "xlat": ["xloc", "xcat", "Xcat", "xlon", "mxlon", "xpcat", "xLat", "mxaddr", "Xlon", "xploc", " xaddr", "Xloc", "mxlat", " xcat", " xlon", "Xlat", "Xaddr", "XLat", "xplat", " xLat", "xaddr", " xloc", "xpLat"], "plen": ["pleng", " plEN", "PlEN", "Pllen", "coleng", "pln", "slen", "slon", "colen", "colening", "illlen", " pleng", "iplEN", "illen", "slan", "Plign", "Plen", "plan", "ipllen", "Plan", "ipln", "plon", "plEN", " plon", "pllen", "illeng", "plening", "sllen", "Pln", " plan", " pllen", " pln", "Plon", "plign", "Pleng", " plign", "collen", "Plening", "iplen", "illign", " plening"], "is_write": ["is__writing", "is_read", "is__read", "ispubflow", "is_external", "ispubwrite", "isfuncexternal", "isacwrite", "ispubread", "is__write", "is_binary", "ispubbinary", " is_network", "isfuncwrite", "isacwritten", "is_network", "is_flow", "isacexternal", " is_external", " is_written", " is_writing", "is_writing", "is__network", " is_binary", " is_flow", "isfuncwritten", "is_written", " is_read"], "is_mmio": ["is_mpnet", "is_syslo", "is_mmlo", "is_memlo", "is_mpio", "is_mxui", "is_memios", "is_vmios", "is_mplo", "is_sysro", "is_mmui", "is_mpios", "is_mmnet", "is_mpui", "is_memio", "is_mmios", "is_memnet", "is_sysio", "is_mxlo", "is_sysui", "is_mxio", "is_vmnet", "is_mxro", "is_mpro", "is_vmlo", "is_mmro", "is_vmio"], "iotlb": ["iotub", "ietlb", "ietb", "iotla", "otlr", "iotlr", "kylc", "kylb", "kyb", "iottbl", "iollp", "kybl", "iolb", "ietla", "iotb", "ietlp", "otub", "otlc", "otla", "ietl", "otb", "iottlc", "ottlb", "iolbl", "iollr", "ottl", "otlb", "ioll", "ottub", "ietlc", "ottla", "ietlr", "iollb", "iotbl", "iotl", "iottb", "iotsb", "iotlc", "otbl", "otsb", "iotlp", "otl", "ietub", "ottsb", "iottlb", "ottb", "iottlr", "iottlp", "iollc", "iottl", "ietbl", "ietsb"], "section": ["container", "server", "result", "assembled", "service", "description", "connection", "tag", "bc", "sub", "option", "module", "sq", "db", "route", "instance", "sb", "ru", "rc", "mod", "config", "ace", "function", "division", "rl", "loc", "session", "member", "vision", "cm", "pair", "sect", "part", "sector", "array", "se", "rb", "Section", "address", "sections", "entry", "layer", "r", "area", "cover", "component", "region", "join", "port", "lc", "sec", "root", "sa", "element", "group"], "mr": ["tr", "usr", "fr", "rw", "rt", "mer", "nr", "bm", "pm", "Mr", "hr", "wk", "mid", "rg", "adr", "md", "module", "MR", "sr", "au", "dr", "rc", "ru", "pr", "lr", "wr", "cb", "rd", "rl", "rf", "asm", "fm", "cm", "bh", "vr", "eer", "ar", "mt", "rb", "impl", "yr", "mk", "vm", "ras", "rx", "r", "br", "kr", "attr", "shr", "ir", "rm", "m", "cover", "gr", "nm", "dm", "mm", "bro", "er", "mor", "rs", "rr", "mc", "rh", "lc", "manager", "bf", "mn", "mx", "hm"], "d": ["dat", "dp", "D", "xd", "md", "c", " dd", "gd", "db", "a", "pd", "dr", "h", "p", "ds", "b", "j", "ld", "vd", "part", "bd", "di", "dc", "dd", "dn", "r", "da", "du", "m", "dh", "dm", "e", "fd", "ad", "dl", "dt", "cd"]}}
{"project": "qemu", "commit_id": "30de46db50d2f9f74c5f7ab1cc463b8dec026407", "target": 0, "func": "static void read_guest_mem(void)\n\n{\n\n    uint32_t *guest_mem;\n\n    gint64 end_time;\n\n    int i, j;\n\n    size_t size;\n\n\n\n    g_mutex_lock(data_mutex);\n\n\n\n    end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;\n\n    while (!fds_num) {\n\n        if (!_cond_wait_until(data_cond, data_mutex, end_time)) {\n\n            /* timeout has passed */\n\n            g_assert(fds_num);\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* check for sanity */\n\n    g_assert_cmpint(fds_num, >, 0);\n\n    g_assert_cmpint(fds_num, ==, memory.nregions);\n\n\n\n    /* iterate all regions */\n\n    for (i = 0; i < fds_num; i++) {\n\n\n\n        /* We'll check only the region statring at 0x0*/\n\n        if (memory.regions[i].guest_phys_addr != 0x0) {\n\n            continue;\n\n        }\n\n\n\n        g_assert_cmpint(memory.regions[i].memory_size, >, 1024);\n\n\n\n        size =  memory.regions[i].memory_size + memory.regions[i].mmap_offset;\n\n\n\n        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,\n\n                         MAP_SHARED, fds[i], 0);\n\n\n\n        g_assert(guest_mem != MAP_FAILED);\n\n        guest_mem += (memory.regions[i].mmap_offset / sizeof(*guest_mem));\n\n\n\n        for (j = 0; j < 256; j++) {\n\n            uint32_t a = readl(memory.regions[i].guest_phys_addr + j*4);\n\n            uint32_t b = guest_mem[j];\n\n\n\n            g_assert_cmpint(a, ==, b);\n\n        }\n\n\n\n        munmap(guest_mem, memory.regions[i].memory_size);\n\n    }\n\n\n\n    g_assert_cmpint(1, ==, 1);\n\n    g_mutex_unlock(data_mutex);\n\n}\n", "idx": 11975, "substitutes": {"guest_mem": ["guess_offset", "guest__lim", "guester_sum", "guist_mem", "guapestOlim", "guestablehome", "guest_reg", "guest_num", "guest__max", "guest_home", "guess_mod", "guestablememory", "guester_memory", "guess_home", "guess_mem", "guest__mem", "guest_Mem", "guestOprogram", "guest_memory", "guist_reg", "guapest_mi", "guapestOmi", "guest__num", "guest_lim", "guestOmi", "guest_program", "guest_mi", "guest_max", "guest_sum", "guess_num", "guess_memory", "guist_Mem", "guest_offset", "guapestOprogram", "guapestOmem", "guess_lim", "guester_lim", "guestablemem", "guapest_lim", "guapest_mem", "guapest_program", "guestOlim", "guestOmem", "guest_mod", "guess_max", "guestableoffset", "guester_reg", "guester_mem"], "end_time": ["END_Time", "end_times", "end_TIME", "END_times", " end_m", "endfullTIME", "end_hour", " end_times", "end_m", "endfulltime", "endfulltimes", "END_timer", "endfullm", "END_hour", "end_timer", "END_money", "endOftime", "endOfTime", "END_time", "endOfhour", "endOftimer", " end_TIME", "end_Time", "end_money"], "i": ["li", "mu", "ip", "mi", "c", "d", "ri", "b", "bi", "ui", "ci", "e", "init", "info", "ai", "eni", "it", "ii", "ni", "id", "site", "phi", "api", "oi", "module", "h", "end", "ie", "hi", "z", "zi", "xi", "code", "qi", "o", "f", "k", "y", "yi", "ki", "gi", "part", "di", "v", "ti", "ind", "l", "start", "index", "u", "ij", "lc", "x", "ix", "uri", "type", "I", "fi", "iu", "is", "ini", "multi", "ji", "p", "si", "pi", "io", "ori", "cli", "iv", "m", "n", "slice"], "j": ["ii", "g", "li", "adj", "f", "va", "k", "err", "je", "jo", "x", "y", "uj", "c", "a", "jp", "ja", "d", "off", "h", "ji", "p", "offset", "el", "si", "b", "range", "fl", "jl", "key", "z", "v", "ch", "num", "J", "o", "r", "br", "t", "length", "oj", "l", "jam", "area", "u", "w", "m", "job", "ij", "not", "e", "n", "obj", "jj", "child", "value", "dj", "out", "name", "aj", "jc", "it"], "size": ["ii", "g", "sized", "SIZE", "capacity", "max", "weight", "izes", "c", "len", "cache", "small", "pack", "bytes", "ice", "offset", "fee", "sh", "loc", "si", "cm", "shape", "scale", "address", "ize", "code", "Size", "z", "length", "ci", "iz", "n", "storage", "large", "name", "data", "x", "sum"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static uint64_t qemu_rdma_poll(RDMAContext *rdma, uint64_t *wr_id_out,\n\n                               uint32_t *byte_len)\n\n{\n\n    int ret;\n\n    struct ibv_wc wc;\n\n    uint64_t wr_id;\n\n\n\n    ret = ibv_poll_cq(rdma->cq, 1, &wc);\n\n\n\n    if (!ret) {\n\n        *wr_id_out = RDMA_WRID_NONE;\n\n        return 0;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ibv_poll_cq return %d!\\n\", ret);\n\n        return ret;\n\n    }\n\n\n\n    wr_id = wc.wr_id & RDMA_WRID_TYPE_MASK;\n\n\n\n    if (wc.status != IBV_WC_SUCCESS) {\n\n        fprintf(stderr, \"ibv_poll_cq wc.status=%d %s!\\n\",\n\n                        wc.status, ibv_wc_status_str(wc.status));\n\n        fprintf(stderr, \"ibv_poll_cq wrid=%s!\\n\", wrid_desc[wr_id]);\n\n\n\n        return -1;\n\n    }\n\n\n\n    if (rdma->control_ready_expected &&\n\n        (wr_id >= RDMA_WRID_RECV_CONTROL)) {\n\n        DDDPRINTF(\"completion %s #%\" PRId64 \" received (%\" PRId64 \")\"\n\n                  \" left %d\\n\", wrid_desc[RDMA_WRID_RECV_CONTROL],\n\n                  wr_id - RDMA_WRID_RECV_CONTROL, wr_id, rdma->nb_sent);\n\n        rdma->control_ready_expected = 0;\n\n    }\n\n\n\n    if (wr_id == RDMA_WRID_RDMA_WRITE) {\n\n        uint64_t chunk =\n\n            (wc.wr_id & RDMA_WRID_CHUNK_MASK) >> RDMA_WRID_CHUNK_SHIFT;\n\n        uint64_t index =\n\n            (wc.wr_id & RDMA_WRID_BLOCK_MASK) >> RDMA_WRID_BLOCK_SHIFT;\n\n        RDMALocalBlock *block = &(rdma->local_ram_blocks.block[index]);\n\n\n\n        DDDPRINTF(\"completions %s (%\" PRId64 \") left %d, \"\n\n                 \"block %\" PRIu64 \", chunk: %\" PRIu64 \" %p %p\\n\",\n\n                 print_wrid(wr_id), wr_id, rdma->nb_sent, index, chunk,\n\n                 block->local_host_addr, (void *)block->remote_host_addr);\n\n\n\n        clear_bit(chunk, block->transit_bitmap);\n\n\n\n        if (rdma->nb_sent > 0) {\n\n            rdma->nb_sent--;\n\n        }\n\n\n\n        if (!rdma->pin_all) {\n\n            /*\n\n             * FYI: If one wanted to signal a specific chunk to be unregistered\n\n             * using LRU or workload-specific information, this is the function\n\n             * you would call to do so. That chunk would then get asynchronously\n\n             * unregistered later.\n\n             */\n\n#ifdef RDMA_UNREGISTRATION_EXAMPLE\n\n            qemu_rdma_signal_unregister(rdma, index, chunk, wc.wr_id);\n\n#endif\n\n        }\n\n    } else {\n\n        DDDPRINTF(\"other completion %s (%\" PRId64 \") received left %d\\n\",\n\n            print_wrid(wr_id), wr_id, rdma->nb_sent);\n\n    }\n\n\n\n    *wr_id_out = wc.wr_id;\n\n    if (byte_len) {\n\n        *byte_len = wc.byte_len;\n\n    }\n\n\n\n    return  0;\n\n}\n", "idx": 11978, "substitutes": {"rdma": ["drda", "erdga", "rdMA", "rrMA", "rtma", "rtla", "xdta", "drMA", "rrama", "erdma", "rrga", "rhmas", "ldga", "ddmas", "rhla", "rrsha", "ndersha", "erdta", "rdmma", "rdmas", "drmas", "xdmas", "rdta", "ldama", "ldMA", "xdla", "rdla", "xdma", "rrmas", "ldmma", "rrma", "drsha", "ddmad", "nderpa", "ddma", "rdga", "ddda", "ddla", "drta", "drama", "rtda", "drpa", "rrmma", "ldmas", "nderta", "ldla", "ldma", "rdama", "rhmad", "rhma", "rtmas", "nderma", "drla", "drmad", "drma", "rdpa", "rtmad", "rrta", "rrpa", "erdmma", "ldta", "rdda", "rdmad", "rdsha"], "wr_id_out": ["wr_name_id", "wr_name_int", "wr_type_out", "wr_type_in", "wr_id_id", "wr_id_name", "wr_name_in", "wr_id_in", "wr_name_out", "wr_id_int", "wr_type_name", "wr_type_id"], "byte_len": ["byte_val", "bit_len", "bit_length", "bit_offset", "byte_length", "byte_offset", "bit_val"], "ret": ["pub", "rt", "rets", "f", "id", "att", "resp", "re", "RET", "match", "ref", "err", "repl", "rev", "no", "ft", "result", "success", "len", "art", "rc", "back", "reset", "orig", "arr", "b", "fun", "rf", "empty", "flag", "ext", "red", "mt", "part", "code", "gt", "detail", "num", "t", "r", "val", "det", "rep", "def", "fail", "error", "arg", "reply", "pat", "obj", "res", "out", "nt", "reg", "fin", "alt", "Ret", "bf", "status", "count", "str"], "wc": [" roc", "rwf", " wpc", "wf", "Wf", "ewvc", "ewc", " wmc", "ewlc", "Wbc", "ewp", "whc", " rodc", "ewmc", "rc", " wvc", "rwc", "Wpc", " ropc", " wdc", "rf", "wbc", "swmc", "ewf", "Wc", "wmc", "whdc", "swlc", "Wp", "Wdc", "rwmc", "wpc", " robc", "ewdc", "rwlc", "whlc", "Wlc", "wp", "whvc", " wp", "Wvc", "wdc", " wf", "swc", "wvc", "rwdc", "wlc", "swp", "rlc", " wbc", "rp", "rwvc", " wlc"], "wr_id": ["ptr_bid", "wr_vid", "wr_Id", "wr_ident", "wm_sid", "WR_type", "wrOpath", " wr_Id", "wm_type", "wm_count", "wrgtype", "wr_path", "wr_key", "rw_type", "wr_ref", "wrPtype", "ptr_ids", "wr_bid", "wrPref", "rw_name", "writer_type", "wr_type", "wrginfo", "wr_name", "wrSbid", "wrgid", "wrSids", "rw_target", "wm_ip", "rw_id", "writer_ref", "wr_ids", "wr_num", "wr_oid", " wr_num", "WR_name", "wrgtarget", "ptrOids", "rw_oid", "wr_info", "wrOinfo", " wr_ids", "ptr_path", "wr_target", "writer_id", "wrObid", "rw_key", "wm_id", "usr_form", "rw_info", "wrPid", "wr_sid", "wr_count", "WR_id", "ptrOpath", "wrPname", " wr_type", "wrOname", "wr_ip", "wrOids", "wr_no", "wrOform", "usr_info", "wr_form", "wm_name", " wr_vid", "writer_name", "rw_ident", "rw_no", "ptrOid", "WR_num", "ptrObid", "ptr_id", "wrSid", "wrSpath", "usr_id", "usr_name", "wrOid", "wm_info"], "block": ["chain", "type", "pool", "comment", "flow", "Block", "output", "result", "byte", "node", "bl", "condition", "input", "blocks", "frame", "bit", "rule", "record", "row", "entry", "group", "header", "channel", "error", "index", "control", "map", "buffer", "lock", "unit", "value", "section", "name", "data", "number", "object", "list", "line"], "nb_sent": ["nb_send", "nbgwritten", "num_send", "num_sent", "nb_written", "nbgsend", "nbgchanged", "nbgsent", "num_written", "num_changed", "nb_changed"]}}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    uint32_t minor_ver;\n\n    int comp_brand_size;\n\n    char minor_ver_str[11]; /* 32 bit integer -> 10 digits + null */\n\n    char* comp_brands_str;\n\n    uint8_t type[5] = {0};\n\n\n\n    avio_read(pb, type, 4);\n\n    if (strcmp(type, \"qt  \"))\n\n        c->isom = 1;\n\n    av_log(c->fc, AV_LOG_DEBUG, \"ISO: File Type Major Brand: %.4s\\n\",(char *)&type);\n\n    av_dict_set(&c->fc->metadata, \"major_brand\", type, 0);\n\n    minor_ver = avio_rb32(pb); /* minor version */\n\n    snprintf(minor_ver_str, sizeof(minor_ver_str), \"%\"PRIu32\"\", minor_ver);\n\n    av_dict_set(&c->fc->metadata, \"minor_version\", minor_ver_str, 0);\n\n\n\n    comp_brand_size = atom.size - 8;\n\n    if (comp_brand_size < 0)\n\n        return AVERROR_INVALIDDATA;\n\n    comp_brands_str = av_malloc(comp_brand_size + 1); /* Add null terminator */\n\n    if (!comp_brands_str)\n\n        return AVERROR(ENOMEM);\n\n    avio_read(pb, comp_brands_str, comp_brand_size);\n\n    comp_brands_str[comp_brand_size] = 0;\n\n    av_dict_set(&c->fc->metadata, \"compatible_brands\", comp_brands_str, 0);\n\n    av_freep(&comp_brands_str);\n\n\n\n    return 0;\n\n}\n", "idx": 11979, "substitutes": {"c": ["g", "ctx", "f", "xc", "k", "cs", "anc", "self", "icc", "bc", "vc", "ce", "pc", "ca", "co", "d", "config", "p", "cur", "b", "cy", "cm", "cp", "cu", "con", "ct", "cc", "coll", "C", "dc", "ch", "ac", "cv", "fc", "t", "v", "l", "cf", "sc", "ci", "u", "cr", "m", "conf", "oc", "e", "n", "tc", "cn", "ec", "lc", "mc", "uc", "gc", "s", "cd", "cache"], "pb": ["tp", "pg", "ctx", "dp", "bm", "api", "typ", "mp", "proc", "ppa", "nb", "bc", "rob", "bps", "db", "pc", "lb", "eb", "jp", "fab", "sb", "lp", "pd", "config", "cpp", "p", "cb", "b", "fb", "cp", "cm", "bh", "apy", "gb", "rb", "fp", "fc", "hub", "tmp", "prot", "xb", "platform", "uf", "pp", "ab", "pa", "bp", "py", "bf", "PB", "bot"], "atom": ["container", "param", "prop", " Atom", "abc", "mol", "at", "sym", "mom", "xml", "gom", "bc", "parser", "module", "instance", "arch", "node", "comm", "config", "tm", "app", "orb", "cm", "tmp", "atomic", "op", "num", "attr", "article", "tom", "item", "com", "m", "om", "component", "obj", "tc", "name", "typ", "object", "canon"], "minor_ver": ["miner_exp", "minori_ver", "minor64version", "minor_exp", "minori_version", "minor_range", "minor2vers", "minor_pack", "minori_vers", "miner_version", "minior_VER", "minor_VER", "minor__Ver", "minior_Ver", "minor_vers", "minor64ver", "minori_pack", "minor54version", "minor_Ver", "minior64Ver", "minor2version", "minior64VER", "minor__VER", "minor_version", "minor54ver", "minor64VER", "minor__version", "minor2ver", "miner_ver", "minor54exp", "minior_ver", "minior_version", "minor__ver", "minior64version", "miner_range", "minor64Ver", "minor54range", "minior64ver", "minor2pack"], "comp_brand_size": ["comp_package_sized", "comp_tag_scale", "comp_brandflength", "comp_brandopsize", "comp_versionsz", "comp_brand_sized", "comp_brandopwidth", "comp_version_length", "comp_domainopname", "comp_model_type", "comp_package_size", "comp_brandadtype", "comp_version_size", "comp_brand_loc", "comp_version_name", "comp_model_size", "comp_version_z", "comp_versionssize", "comp_brand_number", "comp_brand_length", "comp_versionsname", "comp_domain_ize", "comp_domainopize", "comp_tag_name", "comp_domain_name", "comp_domain_size", "comp_brandfsized", "comp_tag_number", "comp_brandopize", "comp_domain_width", "comp_brandopname", "comp_domainopwidth", "comp_brandadize", "comp_brand_type", "comp_brand_z", "comp_package_length", "comp_brand_ize", "comp_brandadsize", "comp_tag_size", "comp_brand_width", "comp_brandfsize", "comp_brand_name", "comp_model_ize", "comp_versionslength", "comp_tag_loc", "comp_brandsz", "comp_domainopsize", "comp_brandslength", "comp_brandsname", "comp_brandssize", "comp_brand_scale"], "minor_ver_str": ["minor_version_Str", "minor_ver_char", "minor_ver_br", "minor_ver_string", "minor_version_fr", "minor_version_str", "minor_version_st", "minor_version_char", "minor_version_div", "minor_ver_Str", "minor_version_arr", "minor_version_br", "minor_ver_st", "minor_ver_arr", "minor_ver_div", "minor_version_string", "minor_ver_fr"], "comp_brands_str": ["comp_brands2arr", "comp_brandsmsl", "comp_branches_name", "comp_brances_string", "comp_branches_str", "comp_branches_dr", "comp_brands_name", "comp_brandsmfr", "comp_bralls_exp", "comp_branches_fr", "comp_brandsmstr", "comp_bralls_string", "comp_branches_arr", "comp_brands_arr", "comp_brandsmdr", "comp_brands_fr", "comp_brands_exp", "comp_brands2string", "comp_bralls_r", "comp_brands_sl", "comp_brances_str", "comp_brances_arr", "comp_brands_st", "comp_brander_string", "comp_brands_war", "comp_brands_dr", "comp_bralls_st", "comp_brands2str", "comp_brands_iter", "comp_brander_war", "comp_brander_iter", "comp_branches_sl", "comp_bralls_iter", "comp_bralls_str", "comp_branches_Str", "comp_brances_st", "comp_brands_Str", "comp_brander_str", "comp_brands2st", "comp_brands_string", "comp_brands_r", "comp_bralls_arr"], "type": ["version", "prefix", "phrase", "block", "tp", "size", "id", "format", "match", "path", "ref", "ip", "class", "tag", "y", "ver", "label", "config", "cat", "p", "order", "Type", "year", "url", "style", "domain", "TYPE", "pre", "key", "address", "code", "pe", "op", "parent", "length", "t", "link", "error", "time", "val", "attr", "source", "kind", "o", "index", "ty", "col", "data", "base", "unit", "info", "port", "value", "ype", "var", "name", "meta", "py", "none", "typ", "types", "number", "root", "list", "str"]}}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    outw(0xcfc, value);\n\n}\n", "idx": 11980, "substitutes": {"bus": ["os", "pass", "board", "mount", "self", "BUS", "proc", "serial", "ux", "usb", "config", "USB", "http", "bridge", "plug", "boot", "BBC", "Bus", "us", "sync", "port", "bits", "bug", "cache"], "devfn": ["DevFN", "tempfd", " devfunction", "tempfn", "devfp", "Devfunction", "Devfp", "devicefunction", " devFN", "devicefile", "tempfp", "devfd", "Devfile", "devicefp", " devfd", " devfile", "Devfn", "devfunction", "devfile", "Devfd", "devicefn", "devFN", "tempFN", " devfp"], "offset": ["padding", "pos", "timeout", "prefix", "optional", "size", "pointer", "attribute", "format", "limit", "off", "function", "slot", "reset", "range", "style", "position", "end", "Offset", "address", "number", "parent", "o", "length", "error", "start", "index", "reference", "info", "set", "data", "alias", "location", "align"], "value": ["VALUE", "padding", "timeout", "message", "version", "type", "format", "flow", "values", "property", "function", "fee", "position", "array", "key", "address", "v", "image", "entry", "parent", "val", "start", "index", "w", "reference", "buffer", "current", "Value", "child", "slave", "paid", "name", "data", "amount", "number"]}}
{"project": "FFmpeg", "commit_id": "073811cdd29e365498b3455ee4e0eda4b957a957", "target": 0, "func": "static int decode_stream_header(NUTContext *nut){\n\n    AVFormatContext *s= nut->avf;\n\n    ByteIOContext *bc = &s->pb;\n\n    StreamContext *stc;\n\n    int class, stream_id;\n\n    uint64_t tmp, end;\n\n    AVStream *st;\n\n\n\n    end= get_packetheader(nut, bc, 1);\n\n    end += url_ftell(bc);\n\n\n\n    GET_V(stream_id, tmp < s->nb_streams && !nut->stream[tmp].time_base);\n\n    stc= &nut->stream[stream_id];\n\n\n\n    st = s->streams[stream_id];\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    class = get_v(bc);\n\n    tmp = get_fourcc(bc);\n\n    st->codec->codec_tag= tmp;\n\n    switch(class)\n\n    {\n\n        case 0:\n\n            st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n            st->codec->codec_id = codec_get_id(codec_bmp_tags, tmp);\n\n            if (st->codec->codec_id == CODEC_ID_NONE)\n\n                av_log(s, AV_LOG_ERROR, \"Unknown codec?!\\n\");\n\n            break;\n\n        case 1:\n\n            st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n            st->codec->codec_id = codec_get_id(codec_wav_tags, tmp);\n\n            if (st->codec->codec_id == CODEC_ID_NONE)\n\n                av_log(s, AV_LOG_ERROR, \"Unknown codec?!\\n\");\n\n            break;\n\n        case 2:\n\n//            st->codec->codec_type = CODEC_TYPE_TEXT;\n\n//            break;\n\n        case 3:\n\n            st->codec->codec_type = CODEC_TYPE_DATA;\n\n            break;\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"Unknown stream class (%d)\\n\", class);\n\n            return -1;\n\n    }\n\n    GET_V(stc->time_base_id    , tmp < nut->time_base_count);\n\n    GET_V(stc->msb_pts_shift   , tmp < 16);\n\n    stc->max_pts_distance= get_v(bc);\n\n    GET_V(stc->decode_delay    , tmp < 1000); //sanity limit, raise this if moors law is true\n\n    st->codec->has_b_frames= stc->decode_delay;\n\n    get_v(bc); //stream flags\n\n\n\n    GET_V(st->codec->extradata_size, tmp < (1<<30));\n\n    if(st->codec->extradata_size){\n\n        st->codec->extradata= av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        get_buffer(bc, st->codec->extradata, st->codec->extradata_size);\n\n    }\n\n\n\n    if (st->codec->codec_type == CODEC_TYPE_VIDEO){\n\n        GET_V(st->codec->width , tmp > 0)\n\n        GET_V(st->codec->height, tmp > 0)\n\n        st->codec->sample_aspect_ratio.num= get_v(bc);\n\n        st->codec->sample_aspect_ratio.den= get_v(bc);\n\n        if((!st->codec->sample_aspect_ratio.num) != (!st->codec->sample_aspect_ratio.den)){\n\n            av_log(s, AV_LOG_ERROR, \"invalid aspect ratio\\n\");\n\n            return -1;\n\n        }\n\n        get_v(bc); /* csp type */\n\n    }else if (st->codec->codec_type == CODEC_TYPE_AUDIO){\n\n        GET_V(st->codec->sample_rate , tmp > 0)\n\n        tmp= get_v(bc); // samplerate_den\n\n        if(tmp > st->codec->sample_rate){\n\n            av_log(s, AV_LOG_ERROR, \"bleh, libnut muxed this ;)\\n\");\n\n            st->codec->sample_rate= tmp;\n\n        }\n\n        GET_V(st->codec->channels, tmp > 0)\n\n    }\n\n    if(skip_reserved(bc, end) || get_checksum(bc)){\n\n        av_log(s, AV_LOG_ERROR, \"Stream header %d checksum mismatch\\n\", stream_id);\n\n        return -1;\n\n    }\n\n    stc->time_base= &nut->time_base[stc->time_base_id];\n\n    av_set_pts_info(s->streams[stream_id], 63, stc->time_base->num, stc->time_base->den);\n\n    return 0;\n\n}\n", "idx": 11983, "substitutes": {"nut": ["ctr", "nuts", "np", "text", "ocr", "utils", "rt", "cit", "anc", "cdn", "nc", "ox", "cut", "ft", "nb", "ou", "c", "utt", "qt", "art", "cart", "ore", "config", "uts", "cb", "temp", "sci", "ot", "boot", "annot", "sat", "orb", "cm", "bt", "ct", "nw", "UT", "Nut", "kt", "ut", "nit", "pot", "nat", "rot", "bd", "dc", "orn", "stone", "t", "nv", "cf", "gat", "cot", "org", "yt", "cue", "n", "cn", "oren", "storage", "nt", "cro", "tun", "uni", "ctor", "txt", "dt", "tube"], "s": ["server", "g", "utils", "nuts", "os", "sd", "ctx", "f", "sym", "site", "service", "its", "cs", "ls", "self", "sf", "ss", "xs", "c", "sq", "sup", "ks", "is", "an", "sv", "services", "sb", "es", "p", "ts", "sac", "sg", "si", "sp", "ds", "sci", "S", "b", "sat", "ssl", "session", "sts", "fs", "sl", "bs", "ns", "v", "spec", "us", "t", "o", "r", "ps", "ses", "sc", "sync", "gs", "sn", "south", "n", "sys", "rs", "storage", "set", "sa", "js", "stats", "ops", "aws"], "bc": ["web", "BC", "ctx", "bitcoin", "usc", "anc", "nc", "bn", "lic", "c", "db", "pc", "ca", "auc", "sb", "rc", "config", "cb", "fb", "cm", "BBC", "bt", "ucc", "ct", "gb", "soc", "bs", "cc", "bd", "rb", "fc", "dc", "cms", "ac", "cl", "cf", "sc", "lib", "cus", "cot", "com", "tc", "mc", "uc", "lc", "ec", "gc", "cca", "bf", "wb", "exec", "jc"], "stc": [" stci", "este", "estch", "stde", "Stct", "Stf", "Stci", "drxc", "STcs", "strpc", "sts", "ttlc", "ests", "ndb", "STc", "stpc", "stci", "drcf", "istf", "stcs", "estlc", "strch", "STb", " stct", "estb", "STdc", "drc", " sts", "estcf", "ostpc", "estci", "ndc", "ndcs", "Stc", "estxc", "strc", "nddc", "esti", "ostch", "estct", "stch", "estcs", "stxc", "ste", " stf", "stp", "dre", " sti", "stdcf", " stp", "stct", "istc", "estp", "stv", "stdxc", "ostc", "tts", "isti", "stf", "estc", " stv", "ostf", "stcf", "estf", "stb", " stlc", "stlc", "ttv", "ttc", "estv", "istp", "sti", "strf", "estdc", "stdc", "estpc"], "class": ["bus", "pos", "prop", "version", "text", "type", "file", "id", "max", "proc", "comp", "tag", "len", "c", "stop", "instance", "method", "event", "pack", "mod", "back", "loss", "stage", " Class", "step", "url", "CLASS", "classes", "test", "ext", "part", "loop", "code", "op", "pe", "parent", " CLASS", "num", "length", "cl", "time", "val", "lib", "bad", "Class", "acc", "func", "unit", "line", "section", "sec", "name", "count", "number", "object", "str"], "stream_id": ["streamslength", "streamertype", "thread_pid", "streamstype", "streamersid", "stream_type", "streamerid", "stream_sid", " stream_index", "stream_info", "streamxsid", "stream_name", "stream_ids", "thread_id", "channel_type", "channel_id", "stage_sid", "stage_bid", "streamsindex", "streamxbid", "channel_length", " streamsinfo", "stream_bid", "stage_id", " streamsindex", "stream_length", "streamerids", "streamsid", "streamerbid", "streamername", "stream_pid", "streamsinfo", "streamerpid", "stageerbid", "stageersid", "streamxname", "thread_type", "stageerid", "stage_name", "stageername", "streamxid", "stream_index", " streamsid", " stream_info", "streamsname", "thread_ids", "channel_name"], "tmp": ["ott", "src", "elt", "c", "jp", "cpp", "sp", "fb", "pre", "bb", "area", "pp", "next", "pad", "stuff", "nt", "meta", "page", "txt", "inst", "dat", "prop", "np", "tp", "api", "mp", "course", "sb", "img", "test", "cont", "fp", "vm", "attr", "acc", "oe", "base", "bp", "video", "stop", "dt", "pod", "yet", "appy", "buf", "vt", "ff", "now", "pb", "len", "duration", "config", "cur", "ock", "nom", "app", "kk", "part", "v", "source", "wp", "start", "body", "name", "post", "pos", "type", "cdn", "proc", "output", "nb", "sup", "cmp", "amp", "property", "cb", "temp", "offset", "loc", "fake", "cp", "nd", "ext", "uv", "rb", "opt", "tab", "obj", "tt", "tc", "storage", "wb", "uc", "data", "field", "slice", "cache"], "end": ["pos", "append", "size", "id", "max", "limit", "ff", "ended", "pend", "len", "en", "close", "event", "h", "enc", "offset", "after", "END", "ent", "order", "p", "End", "con", "run", "ending", "z", "code", "num", "length", "t", "all", "start", "w", "m", "last", "e", "port", "page", "ad", "send", "stop", "x", "post"], "st": ["et", "put", "fr", "sd", "sth", "f", "src", "ost", "ist", "sw", "ss", "ft", "td", "lt", "fe", "art", "sb", "amp", "ts", "spect", "stage", "sp", "sta", "ste", "ST", "sh", "sts", "ct", "ld", "nd", "stable", "pt", "mt", "sl", "est", "kt", "ut", "t", "cl", "std", "ust", "sc", "start", "cr", "stack", "sn", "ast", "trans", "St", "set", "nt", "rest", "sa", "stream", "inst", "stop", "str"]}}
{"project": "FFmpeg", "commit_id": "5127f465bd3e2cf9cbf66dea3cf7b481b522d266", "target": 1, "func": "static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len)\n\n{\n\n    const unsigned char *s;\n\n    unsigned char *d;\n\n    unsigned char *d_end;\n\n    unsigned char queue[QUEUE_SIZE];\n\n    unsigned int qpos;\n\n    unsigned int dataleft;\n\n    unsigned int chainofs;\n\n    unsigned int chainlen;\n\n    unsigned int speclen;\n\n    unsigned char tag;\n\n    unsigned int i, j;\n\n\n\n    s = src;\n\n    d = dest;\n\n    d_end = d + dest_len;\n\n    dataleft = AV_RL32(s);\n\n    s += 4;\n\n    memset(queue, 0x20, QUEUE_SIZE);\n\n    if (AV_RL32(s) == 0x56781234) {\n\n        s += 4;\n\n        qpos = 0x111;\n\n        speclen = 0xF + 3;\n\n    } else {\n\n        qpos = 0xFEE;\n\n        speclen = 100;  /* no speclen */\n\n    }\n\n\n\n    while (dataleft > 0) {\n\n        tag = *s++;\n\n        if ((tag == 0xFF) && (dataleft > 8)) {\n\n            if (d + 8 > d_end)\n\n                return;\n\n            for (i = 0; i < 8; i++) {\n\n                queue[qpos++] = *d++ = *s++;\n\n                qpos &= QUEUE_MASK;\n\n            }\n\n            dataleft -= 8;\n\n        } else {\n\n            for (i = 0; i < 8; i++) {\n\n                if (dataleft == 0)\n\n                    break;\n\n                if (tag & 0x01) {\n\n                    if (d + 1 > d_end)\n\n                        return;\n\n                    queue[qpos++] = *d++ = *s++;\n\n                    qpos &= QUEUE_MASK;\n\n                    dataleft--;\n\n                } else {\n\n                    chainofs = *s++;\n\n                    chainofs |= ((*s & 0xF0) << 4);\n\n                    chainlen = (*s++ & 0x0F) + 3;\n\n                    if (chainlen == speclen)\n\n                        chainlen = *s++ + 0xF + 3;\n\n                    if (d + chainlen > d_end)\n\n                        return;\n\n                    for (j = 0; j < chainlen; j++) {\n\n                        *d = queue[chainofs++ & QUEUE_MASK];\n\n                        queue[qpos++] = *d++;\n\n                        qpos &= QUEUE_MASK;\n\n                    }\n\n                    dataleft -= chainlen;\n\n                }\n\n                tag >>= 1;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 11985, "substitutes": {"src": ["buf", "ls", "sel", "sub", "sq", "c", "sr", "ins", "sb", "rc", "config", "cur", "input", "loc", "b", "filename", "load", "img", "url", "gb", "rb", "in", "image", "ch", "rx", "r", "source", "req", "sc", "start", "rin", "rs", "stream", "rib", "inst"], "dest": ["dat", "de", "text", " destination", "path", "del", "D", "destroy", "dom", "class", "output", "route", "dist", "master", "Dest", "des", "b", "done", "direction", "end", "address", "v", "dc", "source", "du", "dim", "dev", "delete", "desc", "dep", "wb", "rest", "name", "decl", "data", "target", "dir"], "dest_len": ["dest2Len", "Dest_size", " dest_Len", " dest_val", "dest2len", " dest_length", "dest00length", "dest00size", "Dest_len", "dest00len", "dest_pos", "dest_val", "dest_length", "dest_size", "dest2val", "dest_Len", "dest00pos", "dest2length", "Dest_length", "Dest_pos"], "s": ["server", "sym", "service", "cs", "self", "ids", "c", "a", "ks", "sv", "lines", "settings", "b", "hs", "q", "gs", "w", "as", "e", "js", "os", "size", "site", "its", "ls", "ss", "sq", "ins", "sb", "h", "http", "S", "session", "ds", "ssl", "o", "ses", "sc", "f", "k", "y", "services", "sg", "socket", "sl", "v", "r", "source", "ps", "l", "start", "u", "su", "x", "g", "args", "request", "events", "state", "side", "states", "is", "new", "es", "p", "ts", "si", "sid", "se", "ns", "spec", "client", "t", "m", "n", "sets", "slice"], "d": ["g", "dat", "de", "sd", "f", "id", "did", "del", "D", "dom", "md", "y", "c", "db", "dr", "h", "dy", "dos", "p", "ds", "b", "days", "direction", "nd", "ld", "end", "bd", "z", "v", "dc", "dd", "di", "ind", "t", "o", "da", "du", "r", "dn", "l", "u", "start", "dim", "dx", "ded", "w", "m", "dh", "e", "n", "fd", "ad", "data", "dt", "cd", "dir", "x", "dad"], "d_end": ["d_End", "sd__ent", " d_get", "sd_ent", "d_ent", "sd__End", "ld_edge", "d_ended", "d__End", "d__ent", "ld_end", "ld_offset", "d_start", "d_offset", "dd_end", "d_enter", "d_END", "ld_enter", "dd_ends", " d_ended", "d_ends", "sd_start", " d_start", "d_edge", "dd_END", "sd__start", "d__start", "d_get", " d_max", "sd_end", " d_offset", "sd_End", "d_max", "d__end", "sd__end"], "queue": ["server", "menu", "message", "pipe", "pool", "f", "Queue", "file", "view", "buf", "ue", "proc", "class", "table", "output", "result", "seq", "module", "sequence", "master", "config", "p", "console", "qa", "use", "fl", "context", "array", "Q", "loop", "fp", "code", "memory", "client", "header", "channel", "que", "complete", "select", "command", "store", "q", "proxy", "index", "forward", "stack", "buffer", "desc", "job", "port", "progress", "process", "null", "batch", "stream", "status", "list", "cache"], "qpos": ["quargs", "rypid", " qfat", "sqloc", "qpt", "rypos", "qbody", " qos", "qupose", "sqpo", "quos", "qloc", "kpos", " qbody", " qsize", "Qneg", "sqpos", "sqmin", "qucos", "rypt", " qpat", "qupos", "sqargs", "sqval", "qpo", "reqpos", "sqsize", "quposition", "qpid", "qupat", "questval", "sqpointer", "qval", "questpos", " qargs", " qval", "qufat", "qusize", "sqcos", " qpt", "qargs", "qos", " qneg", " qpid", "reqposition", "qpat", " qposition", " qpose", "sqpat", " qloc", "Qpos", "qupo", "rybody", "qfat", "qpointer", "sqbody", "qmin", "questfat", "qposition", "qupointer", "reqcos", "quloc", "sqpid", " qmin", "quval", "kos", "qpose", "kpose", "kpo", "quneg", "Qpo", "questpo", "sqpt", " qcos", "reqpointer", "qumin", "qupt", "reqpo", "qcos", "qneg", " qpo", "Qpt", "qsize"], "dataleft": ["dataneaft", "danewt", "datalewt", "dataaleaft", "dataalsefort", "Datalsefty", "dataalefts", "datarefts", "dataledaft", "daalekt", "datalekt", "data\n", "datareft", " dat\n", "databekt", "datateft", "dataalsefts", "databefts", "dataleFT", "DatalseFT", "datamefts", "dataledfts", "danefort", "datanefts", "Datalsefts", "datamefty", "datalsefts", "datALExt", "daneaft", "datalleaft", "daleft", "Dataleft", " datalesFT", "datadeaft", "dataneft", "dataledft", "daalefts", "datarefort", "Datalseft", " dataleaft", "datalsefort", "dataveft", "dalewt", "datadewt", "datallefts", "daaleaft", "datalefty", "danefts", "datvaleft", "datalseFT", "daatefts", "datalseaft", "datadefts", "datalleFT", " dataleff", "datvaleaft", "dataneff", "dalefort", "Datalefty", "dataalefort", "datateaft", "datalesFT", "daneft", "datalext", "dataveaft", "dataledkt", "Dat\n", "datanext", " datalesaft", "datanefort", "dataneFT", "datadefort", "datalesft", "datvalefts", "datalleft", "datalseft", "datalefort", "Datalefts", "dataaleft", "datALEff", "datalesfts", " datalefts", "dataalseft", "datALEFT", "datalesfty", "dat\n", "dalefts", "daleaft", " datalesfts", "datvalewt", " datalesxt", "datavefts", "datalefts", "datamefort", "daatekt", "datalesaft", "dataleaft", "datavefort", " datalesff", "dataalseaft", "datameFT", "datatefts", "datALEft", "datalsefty", "datanewt", "databeaft", "datadeft", " dataleFT", " datalesft", "daaleft", "datalesff", "daateaft", "dataleff", "databeft", "datadeFT", "datareaft", "daateft", "datameft", "DataleFT", "datatekt", "datameaft", "datalesxt", " datalext"], "chainofs": ["chaindefs", " chainofb", "chainOfn", "chainefs", " chainaccountn", "chainaccountn", "blockefe", "chainofsym", "chaindictabs", " chainofssl", "chainofb", "containereffn", "containereffs", " chainlibh", "chainowns", "chainfeedsync", "blockofsym", "chainofssl", "chaineffb", "chaineffsync", "chainownses", "chainofh", "chainofn", "chainfeedb", "chainaccounth", "chaindefses", "chainoffsync", "chainreturne", "containerofn", " chainaccounts", "blockefs", "chainaccountssl", "containerofb", "blockofs", "chainoffb", " chainaccountssl", "chainofses", " chainofh", "containerofsync", "chaindicts", "chainofe", "chainlibb", "chainOfssl", "containereffb", "chainfeeds", "chainofsync", "chainreturns", "chaindictsym", "chaindicte", "chaindefh", " chainlibses", "chainfors", "chaineffn", "chainfeedn", "chainlibs", " chainaccounth", "blockefsym", "blockefabs", "blockofe", "chainefe", "chainreturnsym", "chainownh", "chainaccounts", " chainlibb", "chainownb", "chainefabs", "chainoffn", "containerofs", "chainefsym", "chainreturnabs", "chainlibh", "chaindefb", "chainofabs", "chainforssl", "chainlibses", " chainofses", "chainOfs", "chainforh", "chaineffs", " chainlibs", " chainofn", "chainoffs", "blockofabs", "chainOfh", "chainforn", "containereffsync"], "chainlen": ["chainlon", "listcount", "rangelon", "blocklon", "ruleLen", "cyclelim", "rowlength", "groupgen", "groupfat", "grouplen", "pathcount", " chainlon", "cyclefat", "channelpos", "chainpos", "blocklength", "cycleLen", "channellen", "containerLen", "cyclelength", " chainpos", "chaincount", "groupLen", "chainfat", "chainLen", "channelLen", "blocklim", "rulelen", "rangeLen", "containerlen", " chainlength", "channellon", "blockpos", "rulelength", "listlon", "blocklen", "pathLen", "containerlim", "rulelon", "rowlon", "chainlim", "pathlen", "rowLen", "blockfat", "listLen", "blockgen", "cyclelen", "chaingen", "chainlength", "listlen", "blockcount", "rangelen", "containerlength", " chainLen", "rowlen", "blockLen", "pathlon", "rangelength", "cyclegen"], "speclen": ["speblun", "speccen", "speflent", "specclan", "seclenn", "speCLenn", "speClen", "specleng", "spellen", "speCLun", "speplenn", "specplent", "speflun", "speflan", "specleno", "speccenn", "speplun", "speCLeng", " speclens", " specleno", "specillen", "spelleno", "speceleno", " specllen", " specilens", "specclun", " specillen", "speplent", "sellen", "specline", "specilens", "speClens", "seclen", "specclent", "speclent", "speclan", "specelens", "speflen", "sellenn", "specilen", "specplan", "secline", " specilen", "spellens", "specplun", "spelllen", "speCLine", "speblent", "speclun", "specelen", "specclen", "spepleng", "seclun", " speplens", "spelline", "speCleng", "speccun", "speClenn", " spepleng", "speplen", "speclens", " speplenn", "speblen", " speplen", "specellen", "specileno", "speCLens", "selline", "speblan", "specllen", "speCLen", "speplan", " specileno", "speccine", "speplens", "spellenn", " speclenn", " specleng", "sellun", "speclenn", "specplen", "spellun"], "tag": ["big", "gap", "text", "block", "ack", "type", "match", "id", "comment", "date", "class", "sign", "feature", "config", "cat", "mod", "p", "loc", "category", "ban", "use", "ag", " tags", "style", "flag", "test", "bit", "key", "code", "op", "image", "word", "start", "head", "Tag", "token", "tags", "reg", "section", "month", "TAG", "name", "bug", "feat", "tail", "str"], "i": ["ii", "g", "ni", "li", "im", "f", "id", "phi", "I", "k", "ip", "mi", "fi", "y", "c", "yi", "iu", "is", "a", "ini", "multi", "ri", "p", "ji", "si", "z", "b", "pi", "io", "uli", "ori", "inner", "gi", "ie", "di", "v", "ti", "bi", "zi", "xi", "qi", "r", "ui", "ind", "l", "ci", "u", "index", "m", "e", "n", "my", "info", "ai", "eni", "mini", "in", "x", "ix", "it"], "j": ["ii", "g", "pos", "li", "adj", "f", "k", "je", "jo", "jet", "y", "jit", "jp", "ja", "ji", "p", "jen", "b", "kj", "jl", "z", "v", "J", "r", "o", "t", "jam", "el", "ind", "l", "q", "u", "w", "m", "job", "ij", "e", "n", "jj", "dj", "js", "aj", "syn", "x", "it"]}}
{"project": "qemu", "commit_id": "3daa41078aedf227ec98b0d1c9d56b77b6d20153", "target": 1, "func": "void scsi_req_cancel(SCSIRequest *req)\n\n{\n\n    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);\n\n    if (!req->enqueued) {\n\n        return;\n\n    }\n\n\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->io_canceled = true;\n\n    if (req->aiocb) {\n\n        blk_aio_cancel(req->aiocb);\n\n    } else {\n\n        scsi_req_cancel_complete(req);\n\n    }\n\n}", "idx": 11988, "substitutes": {"req": ["tr", "ctr", "required", "fr", "rw", "loader", "rt", "ctx", "request", "hr", "ref", "err", "self", "proc", "comp", "seq", "low", "mr", "task", "ver", "cmp", "qt", "jp", "tar", "dr", "config", "mod", "pr", "cur", "ro", "ru", "rd", "cb", "http", "rf", "sem", "pkg", "require", "dq", "ext", "grad", "spec", "rx", "r", "cmd", "def", "call", "q", "conn", "cf", "dev", "rec", "org", "wa", "desc", "arg", "dep", "obj", "gr", "crit", "progress", "conf", "res", "rr", "rh", "pull", "exec", "requ", "str"]}}
{"project": "qemu", "commit_id": "577bf808958d06497928c639efaa473bf8c5e099", "target": 1, "func": "static void gen_exception_return(DisasContext *s, TCGv_i32 pc)\n\n{\n\n    TCGv_i32 tmp;\n\n    store_reg(s, 15, pc);\n\n    tmp = load_cpu_field(spsr);\n\n    gen_set_cpsr(tmp, CPSR_ERET_MASK);\n\n    tcg_temp_free_i32(tmp);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n", "idx": 11998, "substitutes": {"s": ["server", "g", "ctx", "f", "api", "cs", "self", "sf", "ss", "xs", "c", "sq", "ks", "services", "d", "sb", "es", "p", "ts", "sg", "si", "S", "ds", "b", "app", "fs", "ssl", "sl", "ns", "v", "spec", "client", "t", "ps", "ses", "u", "gs", "m", "south", "e", "sys", "su", "sec", "sa", "js", "ops"], "pc": ["pointer", "pm", "api", "ptr", "cs", "nc", "proc", "mp", "bc", "pb", "c", "db", "amp", "rc", "p", "enc", "px", "ct", "PC", "gb", "pt", "cpu", "cc", "fc", "ac", "fp", "client", "ci", "rec", "m", "cod", "port", "tc", "lc", "mc", "bp", "py", "pid", "cache"], "tmp": ["np", "tp", "tf", "pointer", "src", "appy", "ptr", "buf", "vt", "now", "mp", "proc", "result", "nb", "pb", "c", "db", "cmp", "jp", "sb", "amp", "config", "cpp", "p", "temp", "cb", "kk", "cp", "bt", "Temp", "rb", "v", "fp", "vm", "t", "buff", "tab", "emp", "m", "obj", "stuff", "tc", "storage", "wb", "cro", "bp", "fd", "txt", "data", "cache"]}}
{"project": "qemu", "commit_id": "8dfd5f96515ca20c4eb109cb0ee28e2bb32fc505", "target": 0, "func": "static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,\n\n                                            uint16_t code, const char *reason)\n\n{\n\n    struct iovec iov;\n\n    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));\n\n    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =\n\n        cpu_to_be16(code);\n\n    ioc->rawoutput.offset += 2;\n\n    if (reason) {\n\n        buffer_append(&ioc->rawoutput, reason, strlen(reason));\n\n    }\n\n    iov.iov_base = ioc->rawoutput.buffer;\n\n    iov.iov_len = ioc->rawoutput.offset;\n\n    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,\n\n                               &iov, 1, iov.iov_len);\n\n    buffer_reset(&ioc->rawoutput);\n\n    qio_channel_websock_write_wire(ioc, NULL);\n\n    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);\n\n}\n", "idx": 12023, "substitutes": {"ioc": ["iuoc", "iooc", "idiorg", "riocom", "atiocl", "idioc", "inioy", " itoc", "itirc", "iniog", "iec", "cioc", "iuOC", "xioci", "iisc", "kiocom", " iocal", "atiisc", "aoc", "ciec", "abioci", " iirc", "ioocol", "iuocol", "xiocom", "ioci", "ioko", " iocl", "pioci", "kiocal", "iollo", "atioci", "uocol", "piocl", "iroc", "piorg", "uoc", "rioci", "cioca", "xioc", "ciocom", "aocol", "ioca", "riisc", " iocom", "pioc", "ooci", "xiocol", "rioc", "iocol", "uoca", "abioc", " ioci", "oroc", "ioec", "ciucc", "riroc", "iorg", "uiocom", "riOC", "idiocl", "iditoc", "kioc", "iuisc", "oocom", "iOC", "piucc", "pioko", "aocom", "iocon", "piocom", " iocol", "itog", "ciollo", "iucc", " ioy", "riocol", "uitoc", " iog", "inioc", "iuroc", "phioc", "ciocon", "phiollo", "piOC", "iooca", "ciocol", " iorg", "atiOC", "iocom", "phiocol", "xiocal", "ioy", "iniirc", "iog", "itoy", "piocol", "atioc", "uec", "ooc", "phiocon", "atoc", "itoc", "abiocom", "iirc", "atiroc", "iocl", "abiroc", "uioci", "rioko", "xiocon", "pitoc", "piroc", "xiOC", "kiocl", " iucc", "iuoko", "xiocl", "uiocol", "iocal", "xiollo", "uioc"], "code": ["message", "ack", "size", "type", "id", "src", "state", "ce", "c", "Code", "close", "cb", "function", "content", "condition", "loc", "frame", "ode", "core", "charge", "address", "codes", "header", "length", "error", "call", "buffer", "component", "cod", "cause", "e", "process", "value", "ec", "name", "status", "data", "count", "number"], "reason": ["message", "author", "type", "request", "id", "comment", "warn", "description", "money", "err", "hide", "exc", "ASON", "result", "byte", "connection", "music", "write", "method", "card", "raise", "loss", "condition", "content", "credit", "loc", "Reason", "category", "secret", "charge", "summary", "header", "source", "error", "effect", "asons", "argument", "req", "warning", "broken", "issue", "body", "why", "cause", "unknown", "report", "crit", "msg", "value", "desc", "unit", "none", "status", "name", "bid", "data", "raw"], "iov": ["userc", "lov", "voice", "club", "iola", "\u00ef", "respond", "buf", "orman", "oco", "girl", "inn", "obo", "output", "raud", "imedia", "dylib", "music", "iii", "omnia", "username", "inic", "vg", "ilib", "iris", "iro", "drm", "io", "gio", "liv", "yout", "ibr", "soc", "iol", "iago", "iv", "coll", "hovah", "rx", "roc", "nox", "ionic", "minecraft", "tnc", "airo", "oyer", "IO", "rolet", "wav", "iev", "ij", "oren", "iop", "vre", "anni", "ibl", "uno", "imir", "igroup", "ilo", "\u00ee"]}}
{"project": "qemu", "commit_id": "77af8a2b95b79699de650965d5228772743efe84", "target": 0, "func": "static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm)\n\n{\n\n    fadt->model = 1;\n\n    fadt->reserved1 = 0;\n\n    fadt->sci_int = cpu_to_le16(pm->sci_int);\n\n    fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD);\n\n    fadt->acpi_enable = pm->acpi_enable_cmd;\n\n    fadt->acpi_disable = pm->acpi_disable_cmd;\n\n    /* EVT, CNT, TMR offset matches hw/acpi/core.c */\n\n    fadt->pm1a_evt_blk = cpu_to_le32(pm->io_base);\n\n    fadt->pm1a_cnt_blk = cpu_to_le32(pm->io_base + 0x04);\n\n    fadt->pm_tmr_blk = cpu_to_le32(pm->io_base + 0x08);\n\n    fadt->gpe0_blk = cpu_to_le32(pm->gpe0_blk);\n\n    /* EVT, CNT, TMR length matches hw/acpi/core.c */\n\n    fadt->pm1_evt_len = 4;\n\n    fadt->pm1_cnt_len = 2;\n\n    fadt->pm_tmr_len = 4;\n\n    fadt->gpe0_blk_len = pm->gpe0_blk_len;\n\n    fadt->plvl2_lat = cpu_to_le16(0xfff); /* C2 state not supported */\n\n    fadt->plvl3_lat = cpu_to_le16(0xfff); /* C3 state not supported */\n\n    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |\n\n                              (1 << ACPI_FADT_F_PROC_C1) |\n\n                              (1 << ACPI_FADT_F_SLP_BUTTON) |\n\n                              (1 << ACPI_FADT_F_RTC_S4));\n\n    fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);\n\n    /* APIC destination mode (\"Flat Logical\") has an upper limit of 8 CPUs\n\n     * For more than 8 CPUs, \"Clustered Logical\" mode has to be used\n\n     */\n\n    if (max_cpus > 8) {\n\n        fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);\n\n    }\n\n    fadt->century = RTC_CENTURY;\n\n}\n", "idx": 12026, "substitutes": {"fadt": ["facht", "fadtm", " fagtie", "feadet", "fidt", "fpadwt", " fagto", "fdwt", "feadht", "fpadto", "faidt", "fodtor", "fodt", "fattg", "faddn", "faddtu", "yadht", "fddht", "fadyit", "fastadout", " fadtr", "fastadt", "lfadz", " fdtor", "fadhty", " fachit", " fadte", "feaidht", "fadyf", "fatt", "feaidt", "zpadc", "fpeadto", " fadth", "zadt", "fadtree", "afadtt", "fadytt", "fadhz", " fachto", "feadwt", "feddte", "fatz", "fulladter", "fADt", "yadhty", "fadts", "faft", "fadhout", "fidwt", " fadwt", "fadht", "confadtf", "fidtu", " faytm", "fadter", "fachit", "lfadt", " fayt", "fADc", " faddet", "confadt", "faudc", "fagte", "fachto", "faddto", " fadtie", "feaidwt", "fridt", "faddt", "fadtf", "fpadty", "faddwt", "fafty", "fadsx", "feadto", " fdth", "afaudto", "yadtg", " fdwt", "feddt", "feadout", "feddtree", " fadtm", " fadtu", "fulladtt", "fastpadts", "fpidt", "fodwt", "fddt", "fdtor", "fidter", "confadth", "Faddwt", "fadx", "faidwt", "fpadtu", "fadhtu", "confidt", "faidn", "feadtg", "fastadto", "fatout", "fADte", "fadty", "fadc", "fadwt", "fadtr", "zpadter", "lfadto", "fulladt", "fadyter", "afadto", " facht", "faytm", "fpadf", "fadth", "feaidtu", "fullaft", "feadx", "zadter", "fpeadt", "failout", "afaudc", "Fadto", "fidtt", "fastpadout", "fadet", "feadtie", "fayt", "fedtor", "feddto", " fadtree", "yadt", " fadet", "fadato", "feddty", "fadtt", "fafter", "fadytie", "fagtree", "zadc", "fpidtor", "fdt", "fastpadt", "afaudt", "faidx", "fadf", "fudto", "feddter", "fagf", "fradtt", "failt", "fadate", " fadto", "fullafty", "Faddt", " fagt", "fodte", "fastpadty", "fadhto", "fagtie", "fidty", "fudt", "fazit", "fullaftt", "fpadht", "fazto", "fayte", "fadd", "faddtor", "fpadtf", "fachtr", "fadett", "fadyty", " fadit", " faddt", "fridta", "faftt", "feadd", "afadc", "fidto", "fdtie", "lfadtu", "faidht", "fpadtr", "fedwt", "fatter", "fadat", "fADtm", "faudt", "fadout", "faidd", "confidtf", "fpidto", "fadtor", "fpadtor", "fadtie", "fedt", "fpadz", "faddtr", "fulladty", " fdtr", "afaudtt", "fpidwt", "fradc", "fastpadter", "fadst", "feadter", " fachtr", "feddf", "yadhout", "fpadc", "confidth", "fastadty", "fidth", "fadhts", "faidto", "fadtg", " fagf", "fagto", " fagtree", "failto", "fadto", "fagt", "fpadts", "fadeth", "faytu", "fagit", "fpeadx", "fastadz", "fazt", "feadtu", "lfadht", "fidta", "fpadx", "faidter", "feadc", "fullafter", "fadetf", "fidtf", "fastadter", "faudtt", "feadty", "zpadt", "fadeto", "lfadhtu", "fastpadz", " fadtor", "yadty", "fadz", "faidtu", "fadtu", "Faddte", "fadit", "feadn", "faddtie", "fadatree", "fudwt", "Fadt", "fidf", "fadn", "fastpadto", " faddd", "faddd", "fpadout", "fedth", "feddz", "fastadts", " fdt", "fddwt", "fpeadter", "faddet", "fADtu", "zadht", "fpadter", "fradt", "fidz", "fodto", "Fadte", "feddtie", "fadster", "faudto", "fADter", "fadsto", " faddn", "fadta", "fadhtg", "confadf", "fridit", "faddte", "feadtr", "fdth", "fidit", " fayte", "yadout", "afadt", "faidet", "yadhtg", "faztr", "fadyt", "fradto", "fradta", "fADht", " fadf", "fatty", " fadn", "lfadhz", "Fadwt", "feddit", "fpadth", "fudte", " fagit", "faddtm", "fadef", "fridto", "zpadht", "fddtu", "fidtor", " fagte", "fradit", "fadte", "lfadhto", "Faddto", "feadt", "failts", "fadec", "fpadit", " fadd", " fdtie", "fpadta", " faytu", "fpadt", "confidf", "fdtr"], "pm": ["dem", "param", "plugin", "im", "em", "bm", "service", "sm", "rpm", "mi", "mp", "gm", "imm", "md", "pb", "wm", "mr", "module", "pc", "pd", "vim", "mod", "model", "tm", "nom", "hm", "fm", "px", "cm", "pi", "member", "asm", "sem", "po", "vm", "gp", "km", "am", "mon", "ym", "gem", "dim", "iam", "rm", "m", "mo", "om", "PM", "dm", "nm", "pa", "mm", "ram", "um", "prem"]}}
{"project": "qemu", "commit_id": "da98c8eb4c35225049cad8cf767647eb39788b5d", "target": 0, "func": "void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)\n\n{\n\n    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);\n\n\n\n    if (val & ACPI_BITMASK_SLEEP_ENABLE) {\n\n        /* change suspend type */\n\n        uint16_t sus_typ = (val >> 10) & 7;\n\n        switch(sus_typ) {\n\n        case 0: /* soft power off */\n\n            qemu_system_shutdown_request();\n\n            break;\n\n        case 1:\n\n            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.\n\n               Pretend that resume was caused by power button */\n\n            ar->pm1.evt.sts |=\n\n                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);\n\n            qemu_system_reset_request();\n\n            qemu_irq_raise(ar->pm1.cnt.cmos_s3);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 12036, "substitutes": {"ar": ["arp", "Ar", "arin", "lar", "ear", "jar", "ari", "arb", "dar", "ur", "aer", "adr", "al", "ak", "art", "tar", "cart", "dr", "air", "war", "ace", "arc", "per", "ner", "arr", "ars", "nar", "alog", "ag", "ler", "aro", "yr", "par", "ac", "arm", "el", "ir", "ara", "car", "iar", "arg", "star", "er", "AR", "rar", "var", "har"], "val": ["vol", "als", "valid", "prop", "pal", "vals", "elt", "ref", "sel", "len", "al", "gold", "eval", "bl", "slot", "arr", "loc", "lit", "Val", "cal", "test", "pt", "bit", "VAL", "sl", "pre", "key", "sol", "v", "ee", "ay", "ind", "el", "ret", "opt", "all", "mit", "def", "cond", "index", "arg", "base", "aval", "value", "sec", "var", "pret", "py", "data", "exec", "x"]}}
{"project": "qemu", "commit_id": "0fdddf80a88ac2efe068990d1878f472bb6b95d9", "target": 0, "func": "static void win32_rearm_timer(struct qemu_alarm_timer *t)\n\n{\n\n    struct qemu_alarm_win32 *data = t->priv;\n\n    uint64_t nearest_delta_us;\n\n\n\n    if (!active_timers[QEMU_TIMER_REALTIME] &&\n\n                !active_timers[QEMU_TIMER_VIRTUAL])\n\n        return;\n\n\n\n    nearest_delta_us = qemu_next_deadline_dyntick();\n\n    nearest_delta_us /= 1000;\n\n\n\n    timeKillEvent(data->timerId);\n\n\n\n    data->timerId = timeSetEvent(1,\n\n                        data->period,\n\n                        host_alarm_handler,\n\n                        (DWORD)t,\n\n                        TIME_ONESHOT | TIME_PERIODIC);\n\n\n\n    if (!data->timerId) {\n\n        fprintf(stderr, \"Failed to re-arm win32 alarm timer %ld\\n\",\n\n                GetLastError());\n\n\n\n        timeEndPeriod(data->period);\n\n        exit(1);\n\n    }\n\n}\n", "idx": 12038, "substitutes": {"t": ["tr", "T", "tf", "tp", "f", "tu", "tz", "k", "td", "y", "c", "a", "timer", "i", "d", "trial", "p", "ts", "tm", "b", "tick", "ut", "z", "v", "ti", "o", "time", "r", "l", "tty", "u", "te", "m", "ta", "ty", "w", "e", "n", "tt", "tc", "tim", "nt", "out", "dt", "unt"], "data": ["debug", "dat", "action", "timeout", "message", "ata", "li", "size", "type", "id", "Data", "api", "date", "ada", "update", "connection", "result", "alpha", "module", "template", "a", "i", "d", "event", "DATA", "off", "config", "p", "temp", "after", "input", "change", "session", "extra", "database", "done", "style", "missing", "memory", "di", "key", "parent", "client", "reader", "time", "da", "error", "def", "ui", "start", "index", "u", "rec", "w", "m", "ta", "wa", "dt", "tx", "e", "er", "info", "ad", "window", "exec", "send", "cache"], "nearest_delta_us": ["nearest_deltaptau", "nearest_delta2aus", "nearest_delta2use", "nearest_delta_US", "nearest_deltaptuse", "nearest_delta_u", "nearest_deltaptus", "nearest_delta_au", "nearest_dota_us", "nearest_delt_u", "nearest_delt_use", "nearest_delta2us", "nearest_delta2US", "nearest_delta_used", "nearest_dota_US", "nearest_delt_US", "nearest_delt_used", "nearest_delt_au", "nearest_deltaptu", "nearest_delta_use", "nearest_delta_aus", "nearest_delt_us", "nearest_dota_aus", "nearest_dota_use"]}}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void qapi_dealloc_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QapiDeallocVisitor *qov = to_qov(v);\n\n    void **obj = qapi_dealloc_pop(qov);\n\n    if (obj) {\n\n        g_free(*obj);\n\n    }\n\n}\n", "idx": 12075, "substitutes": {"v": ["g", "version", "f", "k", "vt", "c", "i", "sv", "d", "p", "j", "uv", "env", "iv", "lv", "vm", "o", "t", "r", "val", "inv", "l", "V", "q", "u", "vp", "w", "m", "e", "tv", "vv", "vi", "vs", "x", "volt"], "errp": ["errpp", "nerp", "erp", "erpc", " errpc", " errr", "nerpp", "err", " errpp", "errpc", "erpp", "nerpc", "errr", "nerr"], "qov": ["dqoyer", "workoor", "quoor", "quove", "qoor", "quov", "qova", "Qoor", "workov", "qovo", "Qoyer", "qoyer", "dqove", "Qov", " qove", "Qove", "Qovo", "Qova", "workove", " qovo", "qove", "dqovo", "quova", "workova", " qoyer", "dqov"], "obj": ["g", "pos", "os", "bj", "oa", "fn", "adj", "args", "rt", "ctx", "ref", "elt", "self", "rev", "fi", "x", "nb", "Obj", "bl", "p", "cb", "arr", "b", "orb", "j", "objects", "pt", "obb", "po", "rb", "kl", "z", "tmp", "act", "ns", "num", "o", "t", "r", "cl", "br", "lib", "n", "ob", "out", "so", "js", "alt", "object", "str"]}}
{"project": "qemu", "commit_id": "c951d9a6751576a076ac80a5e5145ceb8d794d38", "target": 1, "func": "static void file_completion(const char *input)\n\n{\n\n    DIR *ffs;\n\n    struct dirent *d;\n\n    char path[1024];\n\n    char file[1024], file_prefix[1024];\n\n    int input_path_len;\n\n    const char *p;\n\n\n\n    p = strrchr(input, '/');\n\n    if (!p) {\n\n        input_path_len = 0;\n\n        pstrcpy(file_prefix, sizeof(file_prefix), input);\n\n        pstrcpy(path, sizeof(path), \".\");\n\n    } else {\n\n        input_path_len = p - input + 1;\n\n        memcpy(path, input, input_path_len);\n\n        if (input_path_len > sizeof(path) - 1)\n\n            input_path_len = sizeof(path) - 1;\n\n        path[input_path_len] = '\\0';\n\n        pstrcpy(file_prefix, sizeof(file_prefix), p + 1);\n\n    }\n\n#ifdef DEBUG_COMPLETION\n\n    monitor_printf(cur_mon, \"input='%s' path='%s' prefix='%s'\\n\",\n\n                   input, path, file_prefix);\n\n#endif\n\n    ffs = opendir(path);\n\n    if (!ffs)\n\n        return;\n\n    for(;;) {\n\n        struct stat sb;\n\n        d = readdir(ffs);\n\n        if (!d)\n\n            break;\n\n\n\n        if (strcmp(d->d_name, \".\") == 0 || strcmp(d->d_name, \"..\") == 0) {\n\n            continue;\n\n        }\n\n\n\n        if (strstart(d->d_name, file_prefix, NULL)) {\n\n            memcpy(file, input, input_path_len);\n\n            if (input_path_len < sizeof(file))\n\n                pstrcpy(file + input_path_len, sizeof(file) - input_path_len,\n\n                        d->d_name);\n\n            /* stat the file to find out if it's a directory.\n\n             * In that case add a slash to speed up typing long paths\n\n             */\n\n            stat(file, &sb);\n\n            if(S_ISDIR(sb.st_mode))\n\n                pstrcat(file, sizeof(file), \"/\");\n\n            readline_add_completion(cur_mon->rs, file);\n\n        }\n\n    }\n\n    closedir(ffs);\n\n}\n", "idx": 12079, "substitutes": {"input": ["param", "binary", "before", "text", "prefix", "padding", "empty", "request", "f", "id", "local", "accept", "xml", "view", "import", "include", "inf", "output", "c", "config", "temp", "enc", "password", "integer", "xxx", "qa", "inner", "img", "pattern", "P", "array", "in", "address", "dc", "image", "ahead", "inc", "source", "error", "bin", "wp", "command", "initial", "q", "u", "form", "buffer", "current", "init", "progress", "value", "null", "uc", "raw", "pull", "batch", "data", "field", "ix", "Input"], "ffs": ["affsd", " ffo", "ppds", "uffds", "FFS", "affds", "bufsd", "ffieldsd", "ffsi", "affsi", "cfds", " ffns", "uffs", "affsys", "ffieldns", " effo", "ffields", " effns", "bufs", "pps", " effs", "ffsys", " ffrows", " ffsd", " effsd", "bufouts", " ffsb", "ffo", "ffds", "ffrows", "FFs", "lfs", "bufsi", "fundsi", " ffS", "ffieldo", "ffsl", "ffsb", "affouts", "ufS", "ufsb", "cfsl", "ufs", "ffsd", "ppsys", "ffS", "lfsl", "uffsl", "ffns", "ffouts", "affs", "lfds", "FFsb", "fundsd", "cfs", "funds", "fundouts", "ufrows", "FFrows", "lfsys"], "d": ["dat", "g", "de", "dict", "sd", "f", "dp", "id", "did", "diff", "k", "D", "xd", "dom", "md", "c", "db", "ud", "i", "pd", "dr", "dos", "dy", "ds", "b", "j", "done", "nd", "ld", "vd", "end", "bd", "z", "dc", "dd", "dn", "r", "t", "du", "o", "da", "l", "u", "ded", "od", "w", "m", "dh", "dm", "e", "n", "s", "fd", "ad", "dl", "data", "cd", "dir", "dad"], "path": ["transform", "Path", "message", "text", "empty", "self", "c", "PATH", "key", "word", "form", "w", "child", "ath", "root", "raw", "txt", "location", "param", "pass", "pointer", "id", "directory", "view", "home", "user", "cat", "enc", "session", "code", "parent", "length", "call", "base", "port", "progress", "list", "binary", "prefix", "xml", "php", "folder", "route", "method", "config", "content", "password", "part", "array", "source", "sync", "index", "current", "value", "space", "name", "dir", "chain", "request", "local", "output", "temp", "work", "full", "url", "pattern", "context", "core", "po", "image", "process", "uc", "stream", "python", "data", "object", "cache"], "file": ["server", "message", "text", "un", "zip", "self", "connection", "c", "model", "b", "filename", "time", "resource", "word", "page", "mail", "line", "live", "id", "directory", "home", "File", "user", "db", "h", "http", "change", "rl", "session", "use", "run", "fp", "parent", "bin", "base", "port", "read", "binary", "block", "f", "php", "sf", "plain", "folder", "document", "le", "sl", "source", "l", "point", "lib", "name", "dir", "type", "local", "flow", "al", "play", "temp", "ile", "function", "work", "full", "files", "feed", "rule", "image", "fd", "bf", "data", "field", "object", "cache"], "file_prefix": ["filebookprefix", "filename___reset", "file_pointer", "file_context", "routebookradius", " file_pointer", "file_area", "routebookprefix", "file__context", "file___reset", "file_pad", "file_offset", " file_pad", "file___exclusive", "filename_name", "file64prefix", "file64radius", "filebookexclusive", "place_prefix", "route_exclusive", "input_prefix", "file64name", " file_offset", "file64reset", "filename_queue", "file___radius", "place_context", "file___queue", "file___directory", "file__prefix", "filename_reset", "route_radius", " file_post", "file_name", "file_exclusive", "route_prefix", "file_radius", "file64exclusive", " file_fix", "filebookradius", "routebookexclusive", "filename___prefix", "file64queue", "file_padding", "route_directory", "filename___name", "input_fix", "file___name", "file__area", "file__padding", "file_post", "file_reset", "money_prefix", "file_fix", "money_padding", "place_area", "money_zone", "file___prefix", "filename_prefix", "place_padding", "file_directory", "input_name", "file_runner", "filename___queue", "routebookdirectory", "money_runner", "file_zone", "file_queue", "filebookdirectory", "file64directory"], "input_path_len": ["input_path_Len", "input_path2line", "input_path0length", "input_prefix_le", "input_Path_Len", "input_pointer_pos", "input_path2val", "input_pathjlen", "input_path64size", "input_pathvLen", "input_path_line", "input_pathvlen", "input_path_le", "input_pathvsize", "input_length_lf", "input_text0length", "input_pointer_l", "input_length0val", "input_pathjleft", "input_path2length", "input_text_length", "input_text0l", "input_path_val", "input_path_part", "input_text0val", "input_depth_line", "input_path0val", "input_path_ln", "input_path_l", "input_path64val", "input_pointer_ln", "input_length_Len", "input_prefix_len", "input_pointer_length", "input_length_val", "input_pathjline", "input_pathvline", "input_path_left", "input_text_len", "input_path_start", "input_length_length", "input_prefix_l", "input_length_len", "input_length_size", "input_path0lf", "input_length_left", "input_Path_l", "input_Path_len", "input_length0len", "input_text0len", "input_prefix_length", "input_path64lf", "input_depth_start", "input_length_pos", "input_length_l", "input_path_length", "input_pointer_len", "input_length0lf", "input_path0size", "input_path2len", "input_text_val", "input_pointer_Len", "input_depth_len", "input_pathjLen", "input_path0l", "input_text_l", "input_path_pos", "input_path_lf", "input_Path_part", "input_length0size", "input_path_size", "input_length_line", "input_path64len", "input_depth_length", "input_path2l", "input_path0len"], "p": ["padding", "g", "np", "prefix", "up", "tp", "f", "pn", "dp", "api", "ip", "prev", "y", "c", "pc", "i", "jp", "patch", "lp", "pr", "primary", "sp", "b", "pi", "cp", "j", "P", "po", "pre", "fp", "pe", "op", "press", "v", "t", "r", "o", "ps", "wp", "l", "q", "pp", "ap", "u", "vp", "point", "start", "m", "pad", "e", "n", "pa", "progress", "port", "bp", "python", "x"], "sb": ["bj", "sd", "sth", "src", "sm", " b", "sf", " eb", "nb", "bc", "pb", "db", "stat", "lb", " s", "cb", "SB", "ib", "kb", "si", "sg", "split", "ds", "b", "sp", " db", "sh", "bg", "bt", "fb", "gb", "vd", "rb", "sl", "vm", "bb", "std", " ga", "abb", "sc", " sd", "sync", "sn", "obj", "info", "ob", "wb", "sa", "bp", "bf", "ba", "stab"]}}
{"project": "qemu", "commit_id": "6350b0904615cc0531cc3059ea34db5c009c88aa", "target": 1, "func": "static void set_int8(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    int8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    Error *local_err = NULL;\n\n    int64_t value;\n\n\n\n    if (dev->state != DEV_STATE_CREATED) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    visit_type_int(v, &value, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (value > prop->info->min && value <= prop->info->max) {\n\n        *ptr = value;\n\n    } else {\n\n        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,\n\n                  dev->id?:\"\", name, value, prop->info->min,\n\n                  prop->info->max);\n\n    }\n\n}\n", "idx": 12083, "substitutes": {"obj": ["pos", "os", "vol", "adj", "ctx", "att", "api", "buf", "rev", "serv", "Obj", "ev", "cb", "temp", "bo", "orb", "j", "pt", "env", "po", "iv", "op", "tmp", "coll", "o", "inv", "val", "attr", "Object", "fo", "org", "ob", "nt", "inst", "ops", "object"], "v": ["g", "f", "k", "vt", "ov", "self", "vc", "c", "i", "sv", "d", "vim", "ev", "p", "b", "j", "vd", "uv", "env", "o", "t", "r", "val", "l", "V", "q", "u", "vp", "w", "m", "vu", "e", "tv", "vv", "vs", "object", "volt"], "opaque": ["openec", "OPac", "opusacity", "opusaques", "opacity", "oppaques", "oaque", "openace", "oaques", "oppacity", "oacity", "opac", "opponymous", "oppaque", "opaques", "oonymous", "OPec", "OPaque", "opusonymous", "OPace", "operaque", "openaque", "operec", "oponymous", "opace", "opec", "operace", "operac", "openac", "opusaque"], "name": ["version", "prefix", "size", "type", "pointer", "id", "comment", "NAME", "description", "path", "Name", "min", "option", "label", "new", "property", "names", "filename", "part", "key", "address", "image", "parent", "time", "val", "error", "word", "attr", "resource", "dim", "desc", "n", "info", "space", "none", "var", "data", "nam", "alias", "field", "x"], "errp": ["rrp", "rorp", "erpc", " erb", "rrb", "err", "arrpc", "errorpc", "resultp", "erlp", "errP", "errpr", "errr", " erP", "errf", "resultP", "resultpr", "errorv", " errpr", "arrP", "errb", " errf", "errorp", " errlp", " erpr", "rorr", "erp", "errorP", " erp", "errlp", " errr", "resultb", " errb", "erf", "rorf", "errpc", "arrp", " errP", "errv", "rrP", "rorlp", "erP", "rrpr", "erv", "arrv"], "dev": ["debug", "dem", "de", "wd", "pub", "device", "pro", "diff", "proc", "dom", "rad", "private", "DEV", "md", "adv", "ver", "d", "node", "ev", "des", "development", "mod", "temp", "driver", "Dev", "grad", "prom", "env", "prof", "iv", "prov", "dc", "client", "val", "def", "conn", "fo", "od", "w", "ow", "conf", "dm", "info", "var", "priv", "bug", "data", "cd"], "prop": ["param", "plugin", "owner", "pos", " property", "ctx", "pointer", "type", "phi", "pro", "path", "api", "ref", "ip", "typ", "proc", "comp", "nb", "private", "option", "pb", "cmp", "properties", "config", "property", "pr", "p", "mod", "term", "pkg", "lit", "app", "cp", "j", "project", "doc", "cfg", "part", "prof", "key", "tmp", "op", "prot", "opt", "attr", "val", "def", " props", "lib", "Prop", "conf", "unit", "info", "priv", "pred", "data", "pod"], "ptr": ["tr", "pos", "size", "pointer", "type", "Ptr", "src", "diff", "buf", "err", "ref", "eth", "pointers", "addr", "len", "fe", "property", "pr", "offset", "arr", "loc", "pair", "vr", "pt", "address", "code", "trace", "tmp", " pointer", "pert", "length", "alloc", "attr", "val", "dim", "index", "pad", "priv", "var", "data", "depth"], "local_err": ["localedEr", "local_ref", "standardipref", "self_err", "localederr", "local_status", "localacref", " local_mr", "local_Er", "local_mr", "self_error", "local_rr", "local_exc", "self_rr", "localiperr", "standard_ref", "standard_err", "standardiperr", " local_er", "standard_try", "localiptry", "localeder", "standardiptry", "localipstatus", "localactry", "local_error", "local_er", "local_try", "localipref", "localacstatus", "localacerr", "standardipstatus", "standard_status", "localedexc", " local_exc", " local_Er"], "value": ["message", "src", "max", "ref", "min", "ver", "response", "fee", "key", "address", "resource", "w", "child", "target", "depth", "size", "pointer", "id", "attribute", "result", "feature", "range", "pair", "test", "end", "parent", "length", "balance", "port", "var", "valid", "format", "diff", "buf", " val", "values", "total", "price", "part", "scale", "_", "index", "current", "null", "number", "VALUE", "version", "type", "device", "flow", "money", "media", "property", "function", "temp", "offset", "p", " result", "position", "image", "val", "buffer", "reference", "Value", "unit", "volume", "data", "object"]}}
{"project": "qemu", "commit_id": "d7cd369402191814a1bb339a730f3af411e9682f", "target": 1, "func": "static void enter_migration_coroutine(void *opaque)\n\n{\n\n    Coroutine *co = opaque;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n", "idx": 12086, "substitutes": {"opaque": ["ppaques", "maque", "obaque", "ppac", "opacity", "compque", "ppacity", "compaque", "maques", "obaques", "obacity", "copaque", "copaques", "pacity", "opac", "copac", "compacity", "macity", "pque", "paques", "paque", "obac", "opaques", "compaques", "opque", "mque", "copacity", "ppaque"], "co": ["ico", "ctx", "oo", "flo", "ra", "bc", "c", "pc", "ca", "aco", "rc", "ro", "CO", "bo", "loc", "cm", "cu", "con", "ko", "po", "cc", "oid", "coll", "ac", "Co", "op", "coe", "fc", "oper", "o", "ci", "cf", "mo", "oc", "tc", "mc", "lc"]}}
{"project": "FFmpeg", "commit_id": "6a99310fce49f51773ab7d8ffa4f4748bbf58db9", "target": 1, "func": "static int decode_channel_residues(WmallDecodeCtx *s, int ch, int tile_size)\n\n{\n\n    int i = 0;\n\n    unsigned int ave_mean;\n\n    s->transient[ch] = get_bits1(&s->gb);\n\n    if (s->transient[ch]) {\n\n        s->transient_pos[ch] = get_bits(&s->gb, av_log2(tile_size));\n\n        if (s->transient_pos[ch])\n\n            s->transient[ch] = 0;\n\n        s->channel[ch].transient_counter =\n\n            FFMAX(s->channel[ch].transient_counter, s->samples_per_frame / 2);\n\n    } else if (s->channel[ch].transient_counter)\n\n        s->transient[ch] = 1;\n\n\n\n    if (s->seekable_tile) {\n\n        ave_mean = get_bits(&s->gb, s->bits_per_sample);\n\n        s->ave_sum[ch] = ave_mean << (s->movave_scaling + 1);\n\n    }\n\n\n\n    if (s->seekable_tile) {\n\n        if (s->do_inter_ch_decorr)\n\n            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample + 1);\n\n        else\n\n            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample);\n\n        i++;\n\n    }\n\n    for (; i < tile_size; i++) {\n\n        int quo = 0, rem, rem_bits, residue;\n\n        while(get_bits1(&s->gb)) {\n\n            quo++;\n\n            if (get_bits_left(&s->gb) <= 0)\n\n                return -1;\n\n        }\n\n        if (quo >= 32)\n\n            quo += get_bits_long(&s->gb, get_bits(&s->gb, 5) + 1);\n\n\n\n        ave_mean = (s->ave_sum[ch] + (1 << s->movave_scaling)) >> (s->movave_scaling + 1);\n\n        if (ave_mean <= 1)\n\n            residue = quo;\n\n        else {\n\n            rem_bits = av_ceil_log2(ave_mean);\n\n            rem      = rem_bits ? get_bits(&s->gb, rem_bits) : 0;\n\n            residue  = (quo << rem_bits) + rem;\n\n        }\n\n\n\n        s->ave_sum[ch] = residue + s->ave_sum[ch] -\n\n                         (s->ave_sum[ch] >> s->movave_scaling);\n\n\n\n        if (residue & 1)\n\n            residue = -(residue >> 1) - 1;\n\n        else\n\n            residue = residue >> 1;\n\n        s->channel_residues[ch][i] = residue;\n\n    }\n\n\n\n    return 0;\n\n\n\n}\n", "idx": 12095, "substitutes": {"s": ["server", "sym", "service", "cs", "self", "c", "a", "ks", "sv", "d", "ims", "settings", "b", "sites", "gs", "w", "as", "e", "rs", "js", "vs", "os", "site", "its", "ls", "ss", "sq", "ins", "sb", "h", "http", "S", "ds", "session", "fs", "ssl", "ms", "o", "ses", "qs", "set", "f", "parts", "sf", "xs", "services", "sg", "details", "sim", "v", "ps", "l", "sync", "u", "sys", "su", "rates", "features", "g", "has", "states", "uns", "ys", "is", "sup", "es", "ts", "p", "si", "full", "se", "ns", "less", "spec", "us", "t", "m", "conf", "n", "sets", "this", "aws", "stats", "ops", "ches"], "ch": ["chi", "chan", "c", "ver", "sh", "gh", "och", "b", "cm", "zh", "chy", "ht", "chrom", "channel", "ci", "q", "form", "gr", "sch", "chart", "th", "cham", "h", "cat", "change", "j", "img", "cor", "code", "coll", "cl", "conn", "CH", "cho", "cher", "ph", "f", "chn", "vc", "cht", "y", "ech", "cur", "cell", "bh", "v", "br", "l", "cf", "cel", "sk", "Ch", "g", "fr", "ce", "arch", "p", "cb", "chip", "cy", "cp", "work", "cha", "ich", "che", "ach", " chunk", "col", "conf", "chu", "ches"], "tile_size": ["tile6capacity", "layer_scale", "component64scale", "tile64length", "layer_capacity", "tile1size", "tile64scale", "tile64size", "tile1length", "component64length", "tile6scale", "component64sized", "component_length", "tile_length", "component_size", "tile64sized", "layer_count", "tile_capacity", "chip_scale", "component64size", "tile_count", "tile6size", "tile_scale", "tile6count", "component_sized", "layer_size", "component_scale", "tile1scale", "chip_length", "chip_size", "tile_sized"], "ave_mean": ["ave__mean", "ave__sum", "ave67mal", "ave2average", "save_sum", "ave67average", "ave_sum", "aving_average", "av_mal", "aving_mal", "av_sum", "ave\u00b7sum", "aving_mean", "ve_size", "avethemean", "av_mean", "ave\u00b7mean", "avetheaverage", "ave_mal", "ave67mean", "ave67sum", "ave2mean", "aves_mark", "avethemal", "avethemark", "aving_sum", "aves_average", "save_mid", "av__average", "ave\u00b7mid", "ave2sum", "ave_mid", "ve_sum", "av__mean", "ave2size", "save_mean", "ave__average", "save_average", "ave_size", "av__mal", "aves_mean", "ave_average", "ave\u00b7average", "ve_mean", "aves_mal", "aveXmark", "aveXaverage", "ave_mark", "aveXmal", "aveXmean", "av__sum", "ave__mal", "av_average", "ve_average"], "i": ["ii", "abi", "ni", "li", "uri", "im", "phi", "I", "ip", "mi", "fi", "ski", "chi", "c", "yi", "ki", "iu", "ini", "multi", "ri", "p", "ji", "si", "pi", "io", "j", "ori", "gi", "ie", "wei", "di", "ti", "xi", "bi", "zi", "qi", "ind", "ui", "o", "ci", "u", "ai", "mini", "uni", "slice", "it"], "rem": ["dem", "remote", "re", "keep", "ref", "ex", "REM", "comm", "temp", "change", "orig", "extra", "pri", "cm", "prom", "rub", "original", "ret", "br", "rec", "rm", "reg", "res", "pop", "rom", "pull"], "rem_bits": ["rem_locks", " rem_\n", " rem_s", "rem__locks", "rem_s", "rem__bytes", "rem_\n", " rem_locks", " rem_bytes", "rem__bits", "rem__runs", "rem_bytes", " rem_runs", "rem_runs"], "residue": ["residUE", "resiguum", "Resinuum", "residsues", " residience", "residsuum", "Residue", "residsience", "residsue", "Residance", "resyuer", "Residuum", "resinance", "residuum", "respicues", " residsue", "resigue", "ResinUE", " residues", "resigUE", "residance", " residsuer", "residuer", "respicuer", "resinuum", "residience", "residsance", "resinue", "residues", "resyues", "resyience", " residsues", "resigance", "respicue", "ResidUE", "resinUE", " residuer", "resyue", "residsUE", "residsuer", "respicience", "Resinance", "Resinue", " residsience"], "quo": ["quoa", "cloo", "Quoid", "quko", " qubo", "quebo", "queo", "aquo", "helo", "aquoi", "Quow", " qui", " quoo", "Qubo", "quoi", " quos", "heloo", "helko", "quei", "aquow", "queow", " quoa", "qo", "quoid", "qui", "aquos", " quoi", "Quoo", "clo", "queoo", "Quoi", "qoo", "queoid", "aquoid", "clbo", "aquoo", "quos", "aqubo", "aqui", "Quo", "qoa", "heloa", "queoi", "queos", "clos", "cloi", "qubo", "qko", "quoo", " quko", "quow"]}}
{"project": "FFmpeg", "commit_id": "405af431040a57c630716b3940d7240021e8b80c", "target": 0, "func": "static int cinaudio_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    CinAudioContext *cin = avctx->priv_data;\n\n    const uint8_t *src = buf;\n\n    int16_t *samples = data;\n\n    int delta;\n\n\n\n    buf_size = FFMIN(buf_size, *data_size/2);\n\n\n\n    delta = cin->delta;\n\n    if (cin->initial_decode_frame) {\n\n        cin->initial_decode_frame = 0;\n\n        delta = (int16_t)AV_RL16(src); src += 2;\n\n        *samples++ = delta;\n\n        buf_size -= 2;\n\n    }\n\n    while (buf_size > 0) {\n\n        delta += cinaudio_delta16_table[*src++];\n\n        delta = av_clip_int16(delta);\n\n        *samples++ = delta;\n\n        --buf_size;\n\n    }\n\n    cin->delta = delta;\n\n\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n\n\n    return src - buf;\n\n}\n", "idx": 12099, "substitutes": {"avctx": ["avcontext", "AVctx", "avcf", "ajcontext", "aucontext", "avcu", "afcf", "afconn", "auctrl", "ajctx", "AVcf", "AVconn", "auctx", "ajconn", "afcu", "AVcontext", "avctrl", "AVctrl", "avconn", "aucf", "afctx", "AVcu", "afctrl", "afcontext", "ajcu"], "data": ["la", "dat", "shift", "pos", "message", "ui", "block", "empty", "size", "sample", "diff", "Data", "mu", "connection", "result", "audio", "media", "alpha", "seq", "len", "a", "dist", "beta", "DATA", "config", "rc", "bytes", "cb", "after", "content", "input", "offset", "blocks", "load", "frame", "array", "memory", "address", "tmp", "image", "parent", "reader", "source", "da", "val", "channel", "length", "bin", "frames", "start", "next", "buff", "index", "buffer", "body", "pad", "base", "raw", "video", "batch", "window", "ops", "slice", "cache"], "data_size": ["image_offset", " data_strength", "data_scale", " data_start", "image_capacity", "data_speed", "dataqscale", "image_size", "image_speed", "dataqsized", " data_sized", "data_capacity", "data_sized", "data_offset", "dataqstart", "dataqsize", " data_range", "data_start", " data_scale", "data_range", "data_strength"], "avpkt": ["AVpcp", "avcpct", "avPacket", "avckt", "avcpacket", "avlpconn", "affacket", "affct", "avpacket", "avppkt", "afcpacket", "affkg", "afpct", "afpkg", "avgpkg", "afcpkt", "avpconn", "AVpconn", "avpcp", "avlpcp", "avgpconn", "avfct", "afcpkg", "avpkg", "avfacket", "AVppkg", "avpct", "avPkt", "avPkg", "avppconn", "avcpkg", "afcpct", "avlpkt", "avckg", "avcacket", "AVppconn", "affkt", "avcpkt", "avppcp", "AVpkt", "AVppkt", "afpkt", "avPct", "avgpcp", "AVpkg", "avgpkt", "afpacket", "avfkg", "AVppcp", "avppkg", "avcct", "avfkt", "avlpkg"], "buf": ["bus", "cas", "ctr", "block", "dest", "ctx", "vec", "ff", "fi", "proc", "home", "front", "bc", "seq", "len", "box", "rc", "config", "pack", "cb", "cur", "loc", "b", "fb", "queue", "img", "rb", "array", "tmp", "fp", "cv", "bb", "alloc", "bin", "uf", "cf", "buff", "buffer", "func", "wb", "uc", "cap", "batch", "cache"], "src": ["sur", "prop", "ctr", "uri", "dest", "ctx", "vec", " dest", "ptr", "proc", "comp", "supp", "sel", "sub", "seq", "bc", "low", "sup", "sit", "dist", "rc", "config", "ources", "cb", "rss", "cur", "pack", "loc", "split", "blocks", "inst", "seed", "b", "img", "url", "grad", "gb", "rb", "sl", "bs", "tmp", "code", "fc", "source", "channel", "attr", "sc", "sync", "desc", "func", "origin", "scene", "uc", "sec", "stream", "feat", "slice"], "samples": ["bamp", "upsamples", "sources", "dannels", "sample", "psannels", "sones", "Samps", " sources", " sones", "nample", "psample", " sample", "bages", "bources", "lample", "Sample", "psamples", "pamp", "upsources", "pages", "namples", "psamps", "samps", "namps", "pamples", "sannels", "Sones", "pources", "bamples", "Samples", "lamples", "sages", "upsamp", "Sources", "dample", "damples", "lones", "lources", "Sannels", "upsages", "damps", "nannels", "samp"], "delta": [" dvance", " dbase", "sdDelta", "indelta", "indota", "dta", "adency", " denna", "dynamic", "delt", "celta", "sdagger", "fenna", "celt", "felta", "adta", "dedDelta", "cta", "dDelta", "adelta", "fagger", "dvance", "indagger", "sdota", "fota", "dbase", "cynamic", " dency", " delt", "dota", "adota", "ddbase", " dDelta", " dota", "ddta", "dedota", "dency", " dynamic", "ddDelta", "ddenna", "advance", "felt", "ddota", "fta", "ddynamic", "sdelt", "adelt", "dagger", "indency", "sdelta", "ddelta", "dedelta", "denna", "DDelta", "sdta", "Dota", "ddelt", "dedelt", "indvance", "Delta", "dedbase", "Delt", " dta", "indelt"], "buf_size": ["buf_length", "buf__name", "buff_set", "buf_capacity", "seq_size", "buff_slice", "buf_weight", "queue_length", "buf_scale", "bufallslice", "bufallsec", "buffsize", "uf_number", "buff_sec", "seq_num", "buf_SIZE", "buffer_scale", "queue_scale", "buffer_set", "buffcache", "buf64weight", "buffer_sized", "buf_cache", "uf_scale", "uf_size", "queue_name", "seq_weight", "buf_set", "buf__scale", "uf_cache", "buf__length", "av_SIZE", "queue_size", "seq_number", "buff_size", "buffscale", "bufallset", "av_size", "buf_number", "av_scale", "buffer_size", "buf64size", "buf_sec", "bufallsize", "buf_slice", "buf__size", "buf_num", "buf_name", "buf64num", "buffnumber", "buf_sized", "av_capacity", "buf64number"]}}
{"project": "FFmpeg", "commit_id": "7104c23bd1a1dcb8a7d9e2c8838c7ce55c30a331", "target": 0, "func": "static void rv34_pred_mv_rv3(RV34DecContext *r, int block_type, int dir)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int A[2] = {0}, B[2], C[2];\n\n    int i, j, k;\n\n    int mx, my;\n\n    int avail_index = avail_indexes[0];\n\n\n\n    if(r->avail_cache[avail_index - 1]){\n\n        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][0];\n\n        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][1];\n\n    }\n\n    if(r->avail_cache[avail_index - 4]){\n\n        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][0];\n\n        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][1];\n\n    }else{\n\n        B[0] = A[0];\n\n        B[1] = A[1];\n\n    }\n\n    if(!r->avail_cache[avail_index - 4 + 2]){\n\n        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1])){\n\n            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];\n\n            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][1];\n\n        }else{\n\n            C[0] = A[0];\n\n            C[1] = A[1];\n\n        }\n\n    }else{\n\n        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][0];\n\n        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][1];\n\n    }\n\n    mx = mid_pred(A[0], B[0], C[0]);\n\n    my = mid_pred(A[1], B[1], C[1]);\n\n    mx += r->dmv[0][0];\n\n    my += r->dmv[0][1];\n\n    for(j = 0; j < 2; j++){\n\n        for(i = 0; i < 2; i++){\n\n            for(k = 0; k < 2; k++){\n\n                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][0] = mx;\n\n                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][1] = my;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 12106, "substitutes": {"r": ["tr", "fr", "nor", "rt", "f", "nr", "re", "hr", "err", "ur", "result", "rg", "c", "mr", "sr", "d", "dr", "rc", "rss", "pr", "p", "h", "ner", "b", "R", "ar", "rb", "v", "t", "br", "kr", "l", "ir", "w", "m", "gr", "e", "n", "er", "rs", "rr", "rh", "res"], "block_type": ["block_file", " block_types", " blocktypeheader", " blocktypetypes", "block_header", " blockblockheader", " blockblockfile", " blockblocktypes", " block_file", " blocktypetype", "block_types", " blocktypefile", " block_header", " blockblocktype"], "dir": ["ii", "file", "mode", "src", "path", "ref", "D", "round", "d", " direction", "order", "orient", "direction", "Dir", "ind", "sort", "def", "dim", "lib", "DIR", "rec", "w", "desc", "circ", "unit", "depth", "cache"], "s": ["server", "setup", "sym", "service", "self", "c", "a", "ks", "d", "sci", "settings", "b", "gs", "w", "e", "rs", "js", "os", "bis", "site", "ls", "ss", "sq", "sr", "sb", "h", "http", "S", "session", "ds", "fs", "ssl", "z", "o", "ses", "qs", "sc", "er", "sec", "f", "sf", "inf", "xs", "y", "en", "services", "sg", "secondary", "ship", "sl", "in", "v", "ps", "l", "u", "sky", "current", "sys", "su", "x", "g", "side", "sports", "single", "is", "sup", "multi", "es", "p", "ts", "si", "core", "se", "ns", "less", "spec", "share", "us", "sy", "t", "m", "conf", "n", "sets", "stats"], "A": ["F", "At", "Area", "Ca", "H", "T", "Ar", "HA", "An", "IA", "I", "Data", "NA", "AM", "LA", "AB", "D", "The", "U", "AN", "X", "BA", "a", "Am", "N", "AV", "AT", "Adam", "Java", "CA", "All", "Average", "AW", "E", "G", "S", "SA", "AU", "Alpha", "R", "GA", "P", "AA", "Auth", "mA", "Q", "As", "V", "AST", "MA", "Action", " a", "Array", "Y", "M", "AP", "API", "This", "AR", "AD", "L", "AC", "AS", "W", "And"], "B": ["F", "H", "T", "BC", "But", "NB", "I", "Br", "LB", "AB", "O", "D", "Block", "GB", "QB", "Bar", "U", "OB", "BD", "X", "BA", "BS", "Bs", "N", "DB", "EB", "G", "E", "S", "b", "Bl", "MN", "BE", "R", "P", "Q", "WB", "BB", "BR", "UB", "RB", "V", "BI", "Bo", "Z", "Y", "M", "BG", "FB", "L", "Both", "Base", "BF", "W"], "C": ["MC", "F", "CL", "Ca", "H", "T", "CC", "BC", "DC", "O", "K", "D", "EC", "U", "Count", "c", "X", "KC", "Code", "N", "CA", "VC", "G", "E", "CT", "S", "CW", "GC", "YC", "CS", "R", "Col", "P", "Q", "CU", "SC", "V", "Con", "Sc", "CE", "CI", "CNN", "Cache", "NC", "Cons", "CV", "Y", "M", "Cu", "Cl", "CP", "L", "Ch", "W"], "i": ["ii", "li", "f", "phi", "I", "ip", "mi", "c", "iu", "d", "h", "p", "b", "pi", "z", "ti", "ia", "bi", "ci", "m", "e", "n", "ai", "x", "it"], "j": ["ii", "g", "pos", "je", "y", "uj", "jp", "ja", "h", "ji", "p", "b", "kj", "jl", "z", "v", "J", "o", "l", "q", "w", "m", "ij", "n", "x"], "k": ["g", "f", "K", "y", "ki", "ak", "h", "p", "kk", "kw", "dk", "z", "v", "mk", "o", "ik", "kr", "q", "u", "w", "m", "e", "n", "sk", "x"], "mx": ["np", "yx", "nr", "mu", "mi", "ma", "wm", " mc", " mm", "mos", "px", "cm", "hh", "nz", "ng", "ms", "me", "rx", "ap", "m", "mm", "ml", "M", " m", "mc", "mmm", "mn", "nm"], "my": ["MY", "np", "yo", "pm", "mu", "mi", "My", "mid", "Mi", "md", "mr", "mys", "mis", "mos", "mic", "hh", "in", "ms", "me", "am", "mon", "mo", "mm", "mc", "mmm", "mn", "nm"]}}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "int qemu_paio_init(struct qemu_paioinit *aioinit)\n\n{\n\n    int ret;\n\n\n\n    ret = pthread_attr_init(&attr);\n\n    if (ret) die2(ret, \"pthread_attr_init\");\n\n\n\n    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n    if (ret) die2(ret, \"pthread_attr_setdetachstate\");\n\n\n\n    TAILQ_INIT(&request_list);\n\n\n\n    return 0;\n\n}\n", "idx": 12111, "substitutes": {"aioinit": ["aIOinitialized", "cioinit", "aIOInit", "aroinitialized", "aroinit", "cIOInit", "cioinitialized", "aIOi", "cIOi", "aioInit", "aioi", "cIOinitialized", "cioInit", "aioinitialized", "cioi", "aIOinit", "aroInit", "cIOinit", "aroi"], "ret": ["usr", "et", "pass", "pub", "rt", "type", "rets", "att", "match", "resp", "re", "RET", "id", "ref", "err", "comment", "class", "ft", "result", "success", "len", "art", " Ret", "fab", "rc", "cat", "back", "rl", "fun", "lit", "flag", "grad", "bit", "part", "pre", "bd", "key", "code", "gt", "mt", "num", "fail", "std", "val", "det", "pet", "try", "attr", "error", "br", "opt", "arg", "reply", "desc", "obj", "pat", "info", "res", "reg", "nt", "out", "py", "alt", "Ret", "bf", "data", "feat", "fin", "str"]}}
{"project": "qemu", "commit_id": "2c80e42395bfe0bf291c082f9399431e1ff9d758", "target": 0, "func": "dprint(int level, const char *fmt, ...)\n\n{\n\n    va_list args;\n\n\n\n    if (level <= debug) {\n\n        va_start(args, fmt);\n\n        vfprintf(stderr, fmt, args);\n\n        va_end(args);\n\n    }\n\n}\n", "idx": 12130, "substitutes": {"level": ["debug", "message", "where", "type", "Level", "mode", "format", "file", "id", "path", "limit", "local", "tag", "vel", "method", "function", "temp", "stage", "loc", "scope", "style", "context", "trace", "key", "code", "levels", "inc", "layer", "source", "time", "call", "index", "stack", "arg", "col", "lock", "info", "value", "lvl", "sec", "depth", "line"], "args": ["debug", "action", "flags", "ax", "stats", "parse", "empty", "type", "size", "groups", "format", "parts", "vals", "actions", "events", "err", "cs", " arguments", "parser", "len", "a", "help", "params", "config", "function", "str", "options", "lines", "arr", "fun", "extra", "ars", "atts", "missing", "alls", "array", "v", "spec", "active", "ras", "ages", "val", "argument", "cmd", "call", "gs", "stack", "arg", "func", "obj", "this", "members", "Args", "py", "ig", "data", "x", "line"]}}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "static void s390_pcihost_hot_plug(HotplugHandler *hotplug_dev,\n\n                                  DeviceState *dev, Error **errp)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n\n    S390PCIBusDevice *pbdev;\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(pci_device_root_bus(pci_dev)\n\n                                           ->qbus.parent);\n\n\n\n    pbdev = &s->pbdev[PCI_SLOT(pci_dev->devfn)];\n\n\n\n    pbdev->fid = s390_pci_get_pfid(pci_dev);\n\n    pbdev->pdev = pci_dev;\n\n    pbdev->configured = true;\n\n    pbdev->fh = s390_pci_get_pfh(pci_dev);\n\n\n\n    s390_pcihost_setup_msix(pbdev);\n\n\n\n    if (dev->hotplugged) {\n\n        s390_pci_generate_plug_event(HP_EVENT_RESERVED_TO_STANDBY,\n\n                                     pbdev->fh, pbdev->fid);\n\n        s390_pci_generate_plug_event(HP_EVENT_TO_CONFIGURED,\n\n                                     pbdev->fh, pbdev->fid);\n\n    }\n\n}\n", "idx": 12133, "substitutes": {"hotplug_dev": ["hotplugin_ev", "hotplug_def", "hotplug_device", "hotplugin_device", "hotplug_ev", "hotplugin_def", "hotplugin_dev"], "dev": ["debug", "dem", "server", "de", "die", "device", "diff", "comment", "pro", "err", "state", "dom", "rad", " Dev", "DEV", "adv", "gu", "ver", "md", "user", "engine", "d", "nov", "ev", "mod", "development", "app", "driver", "Dev", "grad", "prom", "di", "v", "spec", "dc", "error", "kind", "cmd", "def", "conn", "w", "conf", "info", "priv", "bug", "data"], "errp": ["ererror", "rrp", " errip", "erap", "erp", " errerror", "erip", "errap", "rrap", " errap", "rrerror", "rrip", "errip", "errerror"], "pci_dev": ["pci_ev", "pci__de", "pci00device", "pciOdevice", "pciOdev", "ppi_device", "pci_device", "pci_serial", "pciOhome", "pci_home", "ppi_def", "ppi_de", "pci__device", "pcu_def", "pci_mod", "pcu_dev", "pcu_ev", "pciOserial", "pdi_dev", "pcf_device", "pdi_mod", "pci_de", "pci__ev", "pci00server", "pci00dev", "pcu_server", "pci__def", "pdi_device", "pci_def", "pcf_dev", "ppi_dev", "pci00ev", "pcf_home", "pdi_div", "pdi_server", "pcf_serial", "pcu_device", "pci_div", "pci__dev", "pci_server"], "pbdev": ["pbbug", "PBapp", "cbserial", "PBdef", "pcdiff", "pgdef", "lbver", "lpdevice", "lpdiff", "pgdevice", "fbdevice", "cbdev", "PBdevelopment", "lbvar", "ebdev", "lpver", "sbdiv", "sbconn", "PBdev", "lpdiv", "PBdiff", "pcver", "fbdiff", "pcDEV", "lpdev", "pbDEV", "bpdiv", "labdev", "lbconf", "cbDEV", "ppDEV", "pgdev", "lpdebug", "lbdevelopment", "ppdevice", "wpbug", "labdiff", "labcomment", "bpconf", "labvalid", "sbdi", "pgtest", "lptest", "PBdi", "pbdevelopment", "pcdiv", "bpdev", "bpconn", "lbdiff", "bmerror", "pcdebug", "PBver", "bmdevelopment", "lbdevice", "bpdi", "pbdebug", "pcdev", "lpcomment", "lperror", "lpdevelopment", "pbserial", "lpdef", "PBdevice", "pgdevelopment", "PBdiv", "bpDEV", "lbbug", "fbdevelopment", "pberror", "bmdev", "pbver", "lbdef", "pbvalid", "ppserial", "pbapp", "pbcomment", "lpDEV", "wpvar", "ebbug", "pbdiv", "pbdata", "pcdevelopment", "fberror", "ebdevice", "lpapp", "pgcomment", "labtest", "pbconn", "lpdata", "lpserial", "pbdef", "labdevice", "pbconf", "pbdi", "bmdevice", "sbdebug", "pgver", "lbdata", "pgapp", "PBdata", "labdevelopment", "pbvar", "lbdev", "ebvar", "pbdevice", "PBconn", "pcdevice", "lbdiv", "pcconf", "cbdevice", "lbdebug", "fbdev", "lbDEV", "wpdev", "sbdevice", "wpdevice", "pbtest", "ppdev", "lpvalid", "pbdiff", "sbdev", "pgvalid", "bpdebug"], "s": ["server", "g", "f", "service", "ss", "side", "sq", "c", "a", "i", "services", "params", "d", "sb", "p", "sg", "S", "session", "b", "ds", "ssl", "sl", "ns", "v", "t", "r", "o", "resource", "start", "sync", "w", "m", "south", "e", "n"]}}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,\n\n                               unsigned size)\n\n{\n\n    PXA2xxState *s = (PXA2xxState *) opaque;\n\n\n\n    switch (addr) {\n\n    case MDCNFG ... SA1110:\n\n        if ((addr & 3) == 0)\n\n            return s->mm_regs[addr >> 2];\n\n\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12134, "substitutes": {"opaque": ["ospaque", "opacity", "oppaques", "opicit", "ospaques", "ospicit", "OPicit", "OPaques", "ospacity", "ophole", "oppaque", "opaques", " ophole", "OPaque", "operaques", "operaque", "opericit", "operacity", "oppace", " opaques", " opace", "opace", "opphole", "OPacity", "operace", "operhole"], "addr": ["hop", "flags", "oa", "pos", "padding", "pointer", "type", "nr", "mode", "src", "rt", "id", "ptr", "ref", "ip", "eth", "host", "adr", "seq", "len", "cmp", "sr", "sb", "dr", "rc", "config", "slice", "p", "offset", "enc", "slot", "cb", "ace", "amp", "ord", "asm", "loc", "sid", "ext", "mt", "part", "address", "code", "rx", "r", "layer", "val", "cmd", "mac", "conn", "start", "index", "nn", "pad", "lvl", "name", "ad", "data", "align", "x", "str"], "size": ["SIZE", "ctx", "mode", " bytes", "state", "ss", " length", "len", "c", "i", " mode", "rc", "bytes", "offset", "shape", "ize", " sizes", "address", "Size", "length", "val", "w", "e", " c", "data"], "s": ["g", "os", "f", "cs", "ls", "sf", "ss", "states", "c", "sq", "is", "sb", "es", "h", "p", "ts", "si", "S", "scope", "session", "ips", "b", "fs", "socket", "ns", "v", "r", "o", "ps", "ses", "gs", "w", "m", "conf", "e", "n", "sys", "rs", "stats", "ops"]}}
{"project": "qemu", "commit_id": "c471ad0e9bd46ca5f5c9c796e727230e043a091d", "target": 0, "func": "static int vhost_verify_ring_mappings(struct vhost_dev *dev,\n\n                                      uint64_t start_addr,\n\n                                      uint64_t size)\n\n{\n\n    int i, j;\n\n    int r = 0;\n\n    const char *part_name[] = {\n\n        \"descriptor table\",\n\n        \"available ring\",\n\n        \"used ring\"\n\n    };\n\n\n\n    for (i = 0; i < dev->nvqs; ++i) {\n\n        struct vhost_virtqueue *vq = dev->vqs + i;\n\n\n\n        j = 0;\n\n        r = vhost_verify_ring_part_mapping(vq->desc, vq->desc_phys,\n\n                                           vq->desc_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n\n\n        j++;\n\n        r = vhost_verify_ring_part_mapping(vq->avail, vq->avail_phys,\n\n                                           vq->avail_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n\n\n        j++;\n\n        r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys,\n\n                                           vq->used_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (r == -ENOMEM) {\n\n        error_report(\"Unable to map %s for ring %d\", part_name[j], i);\n\n    } else if (r == -EBUSY) {\n\n        error_report(\"%s relocated for ring %d\", part_name[j], i);\n\n    }\n\n    return r;\n\n}\n", "idx": 12142, "substitutes": {"dev": ["debug", "dem", "g", "de", "valid", "block", "device", "diff", "self", "serial", "mid", "rad", "gu", "adv", "DEV", "user", "game", "d", "patch", "ev", "mod", "enc", "p", "temp", "order", "gh", "app", "Dev", "prom", "end", "v", "ch", "client", "error", "def", "dim", "w", "conf", "ve", "info", "ad", "bug", "data", "exec"], "start_addr": ["startflayer", "start_address", "start64hop", "start_asm", "start_hop", "end_address", "startfaddress", "end_gru", "end_hop", "start_gru", "start_ord", "start64address", "start_layer", "start64asm", "end_adr", "start64addr", "startford", "end_ord", "start_adr", "end_layer", "startfaddr", "end_addr", "end_asm"], "size": ["shift", "sized", "timeout", "SIZE", "g", "capacity", "news", "empty", "max", "sw", "c", "score", "small", "esc", "ice", "si", "fee", "loc", "use", "cm", "shape", "any", "end", "se", "scale", "address", "ize", "z", "Size", "length", "ui", "time", "sync", "sn", "iz", "speed", "unit", "security", "e", "storage", "large", "s", "sec", "name", "send", "extra", "number", "sum"], "i": ["ii", "ni", "li", "im", "f", "id", "I", "k", "err", "ip", "y", "c", "yi", "iu", "a", "ini", "d", "ji", "p", "ri", "si", "b", "di", "pi", "io", "gi", "ie", "in", "v", "z", "zi", "ti", "xi", "qi", "r", "o", "ui", "bi", "ind", "l", "ci", "q", "u", "index", "start", "m", "e", "n", "ai", "s", "eni", "x", "it"], "j": ["ii", "pos", "ni", "bj", "adj", "fr", "li", "f", "rt", "k", "err", "je", "rev", "jo", "jet", "y", "uj", "c", "jit", "jp", "ja", "d", "h", "ji", "p", "dy", "b", "jl", "ie", "z", "v", "row", "ch", "J", "r", "o", "t", "br", "jc", "el", "l", "q", "u", "w", "m", "job", "ij", "e", "n", "er", "jj", "obj", "js", "aj", "x", "it"], "part_name": ["partfulldescription", "part_value", "part_description", "partPkey", "partCkey", "part_code", "Part_names", "Part_num", "part_key", " part_code", " part_key", "partCvalue", "partfullname", "partPcode", "part_names", "partPname", " part_value", "Part_name", "partCname", "partCcode", "partfullkey", "partPvalue", " part_description", "part_num"], "vq": ["vquery", "avquery", "gq", "vinq", "ovqu", "ervql", "verque", "evque", " vp", "svque", "lq", " vcharge", "avg", "svqa", "ovue", "fqs", "avque", "lch", "ovid", "vque", "vinph", " vql", "varq", "bqs", "ovqi", "lue", "zph", "lqa", "varquery", " vg", "ervix", "avcl", " vix", "sviq", "ovq", "ovg", "bq", "zqu", "vue", "vqu", "verdq", "evdq", "evq", " vqi", " vdq", " vch", "lqs", " vk", "svue", "eviq", "fq", "avq", "vqs", "vk", "gqa", " vqa", "svck", "vdq", "gqs", "lg", "varix", "zq", "vch", "gg", "ervk", "vincharge", "vinqu", " vph", "svq", "fck", "vid", "varql", "vix", "vql", "vph", "avqi", "svqs", "zp", " vqu", "vp", "ovque", "bqa", " vid", "ervq", "ovcharge", "vqa", "veriq", "svquery", "vck", "vark", " vue", "fqa", "vinp", "vg", "varcl", "svdq", "svcl", "verq", "vqi", "svch", "vcl", "varque", " vqs", "vcharge", "viq", "svid", "ovdq", " vque", "bck"]}}
{"project": "qemu", "commit_id": "3435f39513a104294b5e3bbf3612047028d25cfc", "target": 0, "func": "void qemu_ram_remap(ram_addr_t addr, ram_addr_t length)\n\n{\n\n    RAMBlock *block;\n\n    ram_addr_t offset;\n\n    int flags;\n\n    void *area, *vaddr;\n\n\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        offset = addr - block->offset;\n\n        if (offset < block->length) {\n\n            vaddr = block->host + offset;\n\n            if (block->flags & RAM_PREALLOC_MASK) {\n\n                ;\n\n            } else if (xen_enabled()) {\n\n                abort();\n\n            } else {\n\n                flags = MAP_FIXED;\n\n                munmap(vaddr, length);\n\n                if (mem_path) {\n\n#if defined(__linux__) && !defined(TARGET_S390X)\n\n                    if (block->fd) {\n\n#ifdef MAP_POPULATE\n\n                        flags |= mem_prealloc ? MAP_POPULATE | MAP_SHARED :\n\n                            MAP_PRIVATE;\n\n#else\n\n                        flags |= MAP_PRIVATE;\n\n#endif\n\n                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                    flags, block->fd, offset);\n\n                    } else {\n\n                        flags |= MAP_PRIVATE | MAP_ANONYMOUS;\n\n                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                    flags, -1, 0);\n\n                    }\n\n#else\n\n                    abort();\n\n#endif\n\n                } else {\n\n#if defined(TARGET_S390X) && defined(CONFIG_KVM)\n\n                    flags |= MAP_SHARED | MAP_ANONYMOUS;\n\n                    area = mmap(vaddr, length, PROT_EXEC|PROT_READ|PROT_WRITE,\n\n                                flags, -1, 0);\n\n#else\n\n                    flags |= MAP_PRIVATE | MAP_ANONYMOUS;\n\n                    area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                flags, -1, 0);\n\n#endif\n\n                }\n\n                if (area != vaddr) {\n\n                    fprintf(stderr, \"Could not remap addr: \"\n\n                            RAM_ADDR_FMT \"@\" RAM_ADDR_FMT \"\\n\",\n\n                            length, addr);\n\n                    exit(1);\n\n                }\n\n                memory_try_enable_merging(vaddr, length);\n\n                qemu_ram_setup_dump(vaddr, length);\n\n            }\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 12145, "substitutes": {"addr": ["padding", "remote", "pos", "oa", "prefix", "setup", "ack", "args", "pointer", "arrow", "src", "mode", "ptr", "ref", "ip", "state", "host", "adr", "seq", "len", "db", "route", "node", "dr", "rc", "amp", "ace", "ha", "order", "arr", "ord", "loc", "shape", "frame", "url", "align", "open", "array", "address", "code", "add", " address", "active", "layer", "attr", "amd", "buffer", "region", "base", "section", "Address", "name", "alt", "alias", "location", "coord", "slice"], "length": ["padding", "text", "host", "seq", "sequence", "available", "filename", "address", "form", "pad", "join", "child", "limited", "build", "line", "size", "limit", "range", "shape", "end", "code", "Length", "angle", "base", "port", "section", "L", "valid", "capacity", "format", "ptr", "len", "duration", "total", "load", "family", "part", "row", "layer", "l", "body", "large", "null", "name", "count", "number", "tail", "type", "match", "path", "distance", "collection", "loc", "url", "ext", "style", "position", "ength", "partial", "loop", "level", "slice"], "block": ["container", "plugin", "chain", "wall", "board", "type", "ack", "panel", "un", "comment", "device", "flow", "view", "ref", "ip", "blocking", "Block", "byte", "bc", "box", "network", "label", "cache", "event", "node", "bl", "config", "slice", "clock", "session", "blocks", "range", "work", "frame", "run", "pre", "address", "record", "image", "row", "down", "error", "link", "def", "point", "map", "buffer", "lock", "job", "base", "unit", "section", "space", "none", "name", "group", "exec", "number", "object", "list", "line"], "offset": ["padding", "gap", "pos", "timeout", "shift", "prefix", "layout", "size", "pointer", "type", "adding", "limit", "ptr", "ref", "host", "skip", "connection", "alpha", "seq", "len", "off", "adjust", "slot", "order", "fee", "loc", "range", "position", "part", "Offset", "array", "address", "phase", "entry", "layer", "alloc", "o", "initial", "count", "error", "start", "index", "next", "alias", "delay", "base", "info", "port", "origin", "target", "number", "location", "align", "slice"], "flags": ["padding", "ils", "ats", "vals", "FLAG", "properties", "bytes", "lines", "rights", "fee", "settings", "blocks", "fl", "forces", "ags", "comments", "strings", "feat", "lf", "size", "groups", "ases", "rows", "aps", "options", "fs", "allows", "pages", "flag", "alls", "rules", "offs", "codes", " Flags", "ages", "frames", "els", "tags", "s", "lists", "locks", "ports", "lag", "utils", "als", "planes", "styles", "f", "format", "parts", "xml", "sf", "fields", "len", "mods", "ants", "details", "tracks", "ips", "atts", "errors", "links", "shared", "count", "features", "args", "type", "faces", "events", "state", "states", "items", "relations", "files", "level", "mask", "plugins", "this", "bits", "Flags", "stats", "data", "types", "ops"], "area": ["la", "oa", "gap", "Area", "ata", "aster", "up", "size", "shadow", "mode", "va", "state", "radius", "ra", "media", "alpha", "a", "instance", "ca", "aaa", "aa", "ha", "usa", "loc", "qa", "range", "part", "AA", "array", "memory", "address", "scale", "access", "image", "layer", "ui", "handler", "ATA", "item", "az", "region", "base", "issa", " areas", "atter", "section", "storage", "aria", "space", "name", "apa", "sea", "volume", "data", "alias", "location", "object", "ba"], "vaddr": ["vmac", "wattr", "svaddr", " vserver", "waddr", "vhost", "venter", "wenter", "evhost", "svadr", " vhost", "foffset", " vattr", "vadr", "wmac", "evadd", " verror", "voffset", "Vaddress", "Verror", "vrf", "fhost", "wadr", " vrf", "fadd", "hhost", "varea", "eventer", " varea", "haddress", " vmac", "svaddress", " vnode", "Vserver", "verror", "lvoffset", "fmac", "Vhost", "evaddr", "svoffset", "lvaddr", "Varea", "woffset", "svattr", "Voffset", "svhost", "whost", "frf", " vaddress", "fadr", "videoaddress", "laddress", "videonode", "sventer", "faddress", "lvarea", "vattr", "lserver", "Vadd", "waddress", "hrf", "vserver", "evnode", "laddr", "vnode", "lvaddress", " voffset", "faddr", "evaddress", "Vaddr", "videoaddr", "vaddress", "vadd", "videoenter", "lerror", "haddr", " venter"]}}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "const char *object_get_typename(Object *obj)\n\n{\n\n    return obj->class->type->name;\n\n}\n", "idx": 12182, "substitutes": {"obj": ["oa", "pos", "args", "ctx", "type", "src", "id", "class", "Obj", "module", "instance", "art", "node", "mod", "cb", "inst", "ass", "j", "img", "pt", "po", "rb", "act", "ns", "oid", "tmp", "o", "std", "Object", "lib", "map", "func", "init", "so", "js", "alt", "name", "data", "object", "str"]}}
{"project": "FFmpeg", "commit_id": "1846a3eac854799fbffc9669dcf4de558b917957", "target": 0, "func": "static int vaapi_build_decoder_config(VAAPIDecoderContext *ctx,\n\n                                      AVCodecContext *avctx,\n\n                                      int fallback_allowed)\n\n{\n\n    AVVAAPIDeviceContext *hwctx = ctx->device->hwctx;\n\n    AVVAAPIHWConfig *hwconfig = NULL;\n\n    AVHWFramesConstraints *constraints = NULL;\n\n    VAStatus vas;\n\n    int err, i, j;\n\n    int loglevel = fallback_allowed ? AV_LOG_VERBOSE : AV_LOG_ERROR;\n\n    const AVCodecDescriptor *codec_desc;\n\n    const AVPixFmtDescriptor *pix_desc;\n\n    enum AVPixelFormat pix_fmt;\n\n    VAProfile profile, *profile_list = NULL;\n\n    int profile_count, exact_match, alt_profile;\n\n\n\n    codec_desc = avcodec_descriptor_get(avctx->codec_id);\n\n    if (!codec_desc) {\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    profile_count = vaMaxNumProfiles(hwctx->display);\n\n    profile_list = av_malloc(profile_count * sizeof(VAProfile));\n\n    if (!profile_list) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    vas = vaQueryConfigProfiles(hwctx->display,\n\n                                profile_list, &profile_count);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, loglevel, \"Failed to query profiles: %d (%s).\\n\",\n\n               vas, vaErrorStr(vas));\n\n        err = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n\n\n    profile = VAProfileNone;\n\n    exact_match = 0;\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(vaapi_profile_map); i++) {\n\n        int profile_match = 0;\n\n        if (avctx->codec_id != vaapi_profile_map[i].codec_id)\n\n            continue;\n\n        if (avctx->profile == vaapi_profile_map[i].codec_profile)\n\n            profile_match = 1;\n\n        profile = vaapi_profile_map[i].va_profile;\n\n        for (j = 0; j < profile_count; j++) {\n\n            if (profile == profile_list[j]) {\n\n                exact_match = profile_match;\n\n                break;\n\n            }\n\n        }\n\n        if (j < profile_count) {\n\n            if (exact_match)\n\n                break;\n\n            alt_profile = vaapi_profile_map[i].codec_profile;\n\n        }\n\n    }\n\n    av_freep(&profile_list);\n\n\n\n    if (profile == VAProfileNone) {\n\n        av_log(ctx, loglevel, \"No VAAPI support for codec %s.\\n\",\n\n               codec_desc->name);\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n    if (!exact_match) {\n\n        if (fallback_allowed || !hwaccel_lax_profile_check) {\n\n            av_log(ctx, loglevel, \"No VAAPI support for codec %s \"\n\n                   \"profile %d.\\n\", codec_desc->name, avctx->profile);\n\n            if (!fallback_allowed) {\n\n                av_log(ctx, AV_LOG_WARNING, \"If you want attempt decoding \"\n\n                       \"anyway with a possibly-incompatible profile, add \"\n\n                       \"the option -hwaccel_lax_profile_check.\\n\");\n\n            }\n\n            err = AVERROR(EINVAL);\n\n            goto fail;\n\n        } else {\n\n            av_log(ctx, AV_LOG_WARNING, \"No VAAPI support for codec %s \"\n\n                   \"profile %d: trying instead with profile %d.\\n\",\n\n                   codec_desc->name, avctx->profile, alt_profile);\n\n            av_log(ctx, AV_LOG_WARNING, \"This may fail or give \"\n\n                   \"incorrect results, depending on your hardware.\\n\");\n\n        }\n\n    }\n\n\n\n    ctx->va_profile = profile;\n\n    ctx->va_entrypoint = VAEntrypointVLD;\n\n\n\n    vas = vaCreateConfig(hwctx->display, ctx->va_profile,\n\n                         ctx->va_entrypoint, 0, 0, &ctx->va_config);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Failed to create decode pipeline \"\n\n               \"configuration: %d (%s).\\n\", vas, vaErrorStr(vas));\n\n        err = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n\n\n    hwconfig = av_hwdevice_hwconfig_alloc(ctx->device_ref);\n\n    if (!hwconfig) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    hwconfig->config_id = ctx->va_config;\n\n\n\n    constraints = av_hwdevice_get_hwframe_constraints(ctx->device_ref,\n\n                                                      hwconfig);\n\n    if (!constraints)\n\n        goto fail;\n\n\n\n    // Decide on the decoder target format.\n\n    // If the user specified something with -hwaccel_output_format then\n\n    // try to use that to minimise conversions later.\n\n    ctx->decode_format = AV_PIX_FMT_NONE;\n\n    if (ctx->output_format != AV_PIX_FMT_NONE &&\n\n        ctx->output_format != AV_PIX_FMT_VAAPI) {\n\n        for (i = 0; constraints->valid_sw_formats[i] != AV_PIX_FMT_NONE; i++) {\n\n            if (constraints->valid_sw_formats[i] == ctx->decode_format) {\n\n                ctx->decode_format = ctx->output_format;\n\n                av_log(ctx, AV_LOG_DEBUG, \"Using decode format %s (output \"\n\n                       \"format).\\n\", av_get_pix_fmt_name(ctx->decode_format));\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    // Otherwise, we would like to try to choose something which matches the\n\n    // decoder output, but there isn't enough information available here to\n\n    // do so.  Assume for now that we are always dealing with YUV 4:2:0, so\n\n    // pick a format which does that.\n\n    if (ctx->decode_format == AV_PIX_FMT_NONE) {\n\n        for (i = 0; constraints->valid_sw_formats[i] != AV_PIX_FMT_NONE; i++) {\n\n            pix_fmt  = constraints->valid_sw_formats[i];\n\n            pix_desc = av_pix_fmt_desc_get(pix_fmt);\n\n            if (pix_desc->nb_components == 3 &&\n\n                pix_desc->log2_chroma_w == 1 &&\n\n                pix_desc->log2_chroma_h == 1) {\n\n                ctx->decode_format = pix_fmt;\n\n                av_log(ctx, AV_LOG_DEBUG, \"Using decode format %s (format \"\n\n                       \"matched).\\n\", av_get_pix_fmt_name(ctx->decode_format));\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    // Otherwise pick the first in the list and hope for the best.\n\n    if (ctx->decode_format == AV_PIX_FMT_NONE) {\n\n        ctx->decode_format = constraints->valid_sw_formats[0];\n\n        av_log(ctx, AV_LOG_DEBUG, \"Using decode format %s (first in list).\\n\",\n\n               av_get_pix_fmt_name(ctx->decode_format));\n\n        if (i > 1) {\n\n            // There was a choice, and we picked randomly.  Warn the user\n\n            // that they might want to choose intelligently instead.\n\n            av_log(ctx, AV_LOG_WARNING, \"Using randomly chosen decode \"\n\n                   \"format %s.\\n\", av_get_pix_fmt_name(ctx->decode_format));\n\n        }\n\n    }\n\n\n\n    // Ensure the picture size is supported by the hardware.\n\n    ctx->decode_width  = avctx->coded_width;\n\n    ctx->decode_height = avctx->coded_height;\n\n    if (ctx->decode_width  < constraints->min_width  ||\n\n        ctx->decode_height < constraints->min_height ||\n\n        ctx->decode_width  > constraints->max_width  ||\n\n        ctx->decode_height >constraints->max_height) {\n\n        av_log(ctx, AV_LOG_ERROR, \"VAAPI hardware does not support image \"\n\n               \"size %dx%d (constraints: width %d-%d height %d-%d).\\n\",\n\n               ctx->decode_width, ctx->decode_height,\n\n               constraints->min_width,  constraints->max_width,\n\n               constraints->min_height, constraints->max_height);\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    av_hwframe_constraints_free(&constraints);\n\n    av_freep(&hwconfig);\n\n\n\n    // Decide how many reference frames we need.  This might be doable more\n\n    // nicely based on the codec and input stream?\n\n    ctx->decode_surfaces = DEFAULT_SURFACES;\n\n    // For frame-threaded decoding, one additional surfaces is needed for\n\n    // each thread.\n\n    if (avctx->active_thread_type & FF_THREAD_FRAME)\n\n        ctx->decode_surfaces += avctx->thread_count;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_hwframe_constraints_free(&constraints);\n\n    av_freep(&hwconfig);\n\n    vaDestroyConfig(hwctx->display, ctx->va_config);\n\n    av_freep(&profile_list);\n\n    return err;\n\n}\n", "idx": 12190, "substitutes": {"ctx": ["cas", "hw", "Context", "xc", "anc", "cs", "nc", "bc", "wcs", "vc", "c", "pc", "ca", "cmp", "config", "rc", "cb", "kb", "console", "ck", "loc", "cm", "cp", "ct", "ctrl", "kw", "context", "cc", "cli", "fc", "cv", "cms", "client", "cf", "sc", "conn", "ci", "cus", "sync", "cam", "component", "tx", "fw", "tc", "cn", "lc", "gc", "cca"], "avctx": ["avconfig", "navctx", "hwcontext", "avcontext", "AVctx", "avectx", " avtx", "afconfig", "avcf", "navcontext", "avtx", "AVconfig", "ovctx", "vercontext", "ovcu", "avecu", " avcontext", "avcu", "verconn", "aftx", "AVcf", "hwconn", " avconfig", "hwcf", "hwcu", "verctx", "AVconn", "avecontext", "ovconn", "AVcontext", "vercf", "aveconn", "ovcontext", "navcf", "avconn", "afctx", "navconn", "AVtx", "afcontext"], "fallback_allowed": ["fallback_allow", "fallback_allows", "fallback_expected"], "hwctx": ["hawconfig", "navctx", "hwcontext", "fwc", "navcontext", "hawconf", "rwctx", "fwcmp", "navcmp", "iwconf", "hwc", "hawconn", "fwcontext", "hwcmp", "iwcontext", "navloc", "hawloc", "hwconn", "fwcf", "hwcf", "hawctx", "fwconn", "wxconfig", "wxctx", "fwloc", "hawcontext", "rwcontext", "iwctx", "fwconfig", "fwconf", "hwconf", "rwcf", "hwloc", "navcf", "wxc", "iwconfig", "navconn", "fwctx", "rwcmp", "iwc", "wxcontext"], "hwconfig": ["hawconfig", "hwConfig", "fwconfig", "fwcontext", "hwcontext", "rwconfig", "fwConfig", "rwConfig", "hawConfig", "hawclient", "rwclient", "hawcontext", "hwclient", "fwclient", "rwcontext"], "constraints": ["Constraints", "concontaints", "constructaint", "conctants", "Conctures", "Conctaints", "Conctaint", "concontants", "Construres", "conctaint", "Constraint", "construres", "constructants", "constructures", "concontures", "Constrants", "constrants", "Conctants", "concontaint", "constraint", "conctures", "constructaints", "conctaints"], "vas": ["gap", "pse", "board", "va", "cs", "pc", "jp", "sv", "draw", " img", "iss", "pas", "sts", "fig", "Bus", " va", "css", "cus", "browser", "feat", "vs", "ba", "cas", "layout", "ss", "BA", "ja", "vis", "nas", "stage", "mis", "fs", "shape", "Stage", "opus", "av", " cs", "miss", "AS", "VR", "jas", "bus", "str", "aka", "buf", "wcs", " dc", " canvas", "usa", "qa", "catch", "cal", "pic", "hea", "di", "FIG", "wp", "cf", "ta", "las", " bus", "rus", "fi", "auc", "Va", " pic", " var", "isi", "bridge", "CS", "fal", "cv", "wt", "capt", "tx", "fg", " CS", "ops", "cache"], "err": ["Error", "fy", "aster", "fr", "resp", "feat", "hr", "hide", " error", "fi", "result", "mr", "ver", "Er", "dr", "pr", "wr", "str", "ner", "arr", "der", "ler", "style", "test", "ar", "act", "code", "header", "r", "ise", "error", "kr", "br", "req", "acer", "ir", "cr", "gr", "init", "er", "progress", "late", "msg", "line", "rr", "rh", "var", "bug", "grade", "status", "rage", "cache"], "i": ["ii", "g", "ni", "li", "uri", "f", "id", "phi", "I", "ip", "oi", "mi", "fi", "y", "c", "yi", "ki", "iu", "ini", "jp", "d", "multi", "h", "ri", "p", "ji", "si", "b", "pi", "io", "inner", "gi", "ie", "ami", "part", "in", "ti", "zi", "bi", "di", "xi", "qi", "z", "ui", "ik", "v", "source", "l", "ci", "u", "index", "start", "m", "e", "n", "info", "init", "ai", "lc", "eni", "slice", "ix", "it"], "j": ["li", "note", "je", "jp", "d", "bl", "b", "fl", "key", "J", "jam", "all", "q", "job", "e", "js", "ni", "jit", "ja", "h", "cat", "img", "z", "num", "o", "section", "s", "aj", "adj", "f", "k", "y", "uj", "v", "br", "_", "l", "u", "ij", "jj", "count", "g", "pos", "fr", "device", "other", "jo", "jet", "ji", "p", "jl", "m", "obj", "n", "this"], "codec_desc": ["codec2doc", "codecsdescription", "codef_def", "codac2desc", "codac_desc", "codec_def", "codec_doc", "codecsdec", "codac2doc", "codef_dec", "codec2des", "codef_doc", "codec2description", "codac2des", "codac_doc", "codac2description", "codec_Desc", "codef_description", "codec_des", "codac_description", "codec2desc", "codef_desc", "codecsdesc", "codec_dec", "codec_description", "codec2dec", "codef_Desc", "codecsDesc", "codac_des", "codec2Desc"], "pix_desc": ["pico2desc", "pix_description", "pix2description", "pico_Desc", "pico2def", "pix2Desc", "pix2desc", "pix_Desc", "pix2def", "pico_def", "pico_desc", "pico2description", "pico_description", "pix_def", "pico2Desc"], "pix_fmt": ["pix_gformat", "pix_fnt", "pix_sfformat", "pix_sfld", "pix_Fformat", "pix_gnt", "pix_sfmt", "pix_Fmt", "pix_fformat", "pix_gmt", "pix_fld", "pix_gld", "pix_Fnt", "pix_sfnt", "pix_Fld"], "profile": ["person", "pse", "thin", "shadow", "file", "character", "panel", "service", "class", "connection", "mobile", "ahi", "display", "model", "settings", "definition", "filename", "Profile", "summary", "environment", "job", "info", "page", "role", "alias", "line", "plugin", "np", "layout", "shield", "module", "user", "public", "username", "ana", "pocket", "member", "session", "pe", "header", "platform", "base", "port", "section", "facebook", "phone", "config", "details", "family", "prof", "picture", "knife", "name", "number", "choice", "type", "pool", "match", "template", "instance", "theme", "title", "account", "interface", "style", "image", "component", "figure", "face", "data", "object", "cache"], "profile_list": ["Profile_list", "character_list", "Profile_id", " profile_table", "profile2map", "profile_LIST", "profile_length", "profile2List", "profileingid", "character_set", "profile5map", "profile5list", "profileingcount", "photo_list", "photo_map", "profileingset", "profile_map", " profile_map", "profile__List", "profile5length", "photo_lists", "profile_List", "profile5lists", "profileinglist", "profile_id", "profileingtable", "profile_lists", "character_id", "profile__list", " profile_LIST", "profile2list", "Profile_len", " profile_List", "profileingLIST", "profile_len", "profile_table", "Profile_List", "profile__len", "profile_set", "profile__id", "photo_length"], "profile_count": ["character_sum", "theme16match", "theme16list", "profile64count", "profile_limit", "profile__count", "theme_count", "profile64limit", "profile_length", "profile_sum", "line_length", "line_state", "profile_array", "line_count", "character_count", "profileXlist", "profile16limit", "profile16match", "profile__match", "character_length", "theme_match", "theme_list", "theme16count", "profileXlength", "line_array", "line_list", "profile_match", "profile64match", "theme16limit", "profile_len", "phone_match", "profileXstate", "phone_len", "theme_limit", "phone_count", "profile__len", "profile_state", "profile16count", "profile16list", "profileXcount", "profile64list"], "exact_match": ["expect_count", "exact_cmp", "exet_count", "exact64sum", "exet_cmp", "expect_match", "expect_message", "exact_message", "expect_sum", "exact64match", "exact64count", "exet_match", "exact_group", "exact64message", "exact_count", "exet_group", "exact_sum"], "alt_profile": ["altregusername", "la_username", "altresusername", "altregsummary", "la_summary", "la_config", "altregprofile", "alt_summary", "altressummary", "alt_config", "altresprofile", "altresconfig", "altregconfig", "alt_username", "la_profile"]}}
{"project": "FFmpeg", "commit_id": "0065d2d520caab2321b35a7bec5d62564913238b", "target": 0, "func": "static int parse(AVCodecParserContext *ctx,\n\n                 AVCodecContext *avctx,\n\n                 const uint8_t **out_data, int *out_size,\n\n                 const uint8_t *data, int size)\n\n{\n\n    VP9ParseContext *s = ctx->priv_data;\n\n    int marker;\n\n\n\n    if (size <= 0) {\n\n        *out_size = 0;\n\n        *out_data = data;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (s->n_frames > 0) {\n\n        *out_data = data;\n\n        *out_size = s->size[--s->n_frames];\n\n        parse_frame(ctx, *out_data, *out_size);\n\n\n\n        return s->n_frames > 0 ? *out_size : size /* i.e. include idx tail */;\n\n    }\n\n\n\n    marker = data[size - 1];\n\n    if ((marker & 0xe0) == 0xc0) {\n\n        int nbytes = 1 + ((marker >> 3) & 0x3);\n\n        int n_frames = 1 + (marker & 0x7), idx_sz = 2 + n_frames * nbytes;\n\n\n\n        if (size >= idx_sz && data[size - idx_sz] == marker) {\n\n            const uint8_t *idx = data + size + 1 - idx_sz;\n\n            int first = 1;\n\n\n\n            switch (nbytes) {\n\n#define case_n(a, rd) \\\n\n            case a: \\\n\n                while (n_frames--) { \\\n\n                    int sz = rd; \\\n\n                    idx += a; \\\n\n                    if (sz > size) { \\\n\n                        s->n_frames = 0; \\\n\n                        av_log(avctx, AV_LOG_ERROR, \\\n\n                               \"Superframe packet size too big: %d > %d\\n\", \\\n\n                               sz, size); \\\n\n                        return AVERROR_INVALIDDATA; \\\n\n                    } \\\n\n                    if (first) { \\\n\n                        first = 0; \\\n\n                        *out_data = data; \\\n\n                        *out_size = sz; \\\n\n                        s->n_frames = n_frames; \\\n\n                    } else { \\\n\n                        s->size[n_frames] = sz; \\\n\n                    } \\\n\n                    data += sz; \\\n\n                    size -= sz; \\\n\n                } \\\n\n                parse_frame(ctx, *out_data, *out_size); \\\n\n                return *out_size\n\n\n\n                case_n(1, *idx);\n\n                case_n(2, AV_RL16(idx));\n\n                case_n(3, AV_RL24(idx));\n\n                case_n(4, AV_RL32(idx));\n\n            }\n\n        }\n\n    }\n\n\n\n    *out_data = data;\n\n    *out_size = size;\n\n    parse_frame(ctx, data, size);\n\n\n\n    return size;\n\n}\n", "idx": 12192, "substitutes": {"ctx": ["cas", "ga", "hw", "Context", "xc", "anc", "cs", "nc", "bc", "wcs", "vc", "c", "sq", "conv", "pc", "ca", "cmp", "jp", "config", "rc", "cb", "kb", "lex", "sci", "ck", "ha", "loc", "pkg", "cp", "cm", "cu", "cal", "ctrl", "grad", "context", "cc", "kt", "coll", "cv", "mac", "cmd", "cf", "sc", "conn", "sync", "cus", "cam", "tx", "crit", "tc", "lc", "cca", "exec"], "avctx": ["AVcontext", "awctx", "avcontext", "AVctx", "aircontext", "aircv", "avcv", "awcontext", "awscl", "airscl", "AVscl", "airctx", "avscl", "awcv", "AVcv"], "out_data": ["out_content", "out___data", "in_source", "out_window", "in_scale", "in_size", "out___size", "outingsample", "in_bytes", "out_sample", "out_scale", "out_resources", "outlexsize", "outingsize", "outingdata", "in_resources", "outPwindow", "outPsize", "outlexdata", "out_cache", "in_sample", "in_cache", "in_window", "outlexvalue", "outPdata", "in_data", "out_value", "out_bytes", "out___resources", "in_value", "outingbytes", "out___cache", "out_source", "outPscale", "outlexsource", "in_content"], "out_size": ["outlexrate", "out__storage", " out_width", "out_sum", "in_size", "out64number", "out_number", "out_length", "out__sum", "in_width", "out_scale", "outNsize", "outNdata", "outlexsize", "out_status", " out_sum", " out_length", "out64data", "outNsized", "out_storage", "out_capacity", "outlexscale", "outNnumber", "out_len", "out_width", " out_scale", "in_data", "out__scale", " out_capacity", "out64size", " out_storage", "out__size", " out_number", "out64sized", "out_rate", " out_rate", "out_sized", "in_status", " out_len", "outlexsum", " out_sized"], "data": ["message", "li", "first", "empty", "zip", "byte", "alpha", "a", "i", "d", "draw", "bytes", "response", "done", "missing", "memory", "address", "package", "resource", "area", "next", "pad", "meta", "raw", "dat", "result", "DATA", "change", "frame", "code", "record", "parent", "length", "one", "video", "Data", "date", "values", "config", "content", "load", "scale", "array", "dd", "source", "start", "index", "map", "body", "value", "window", "number", "timeout", "sample", "media", "ma", "multi", "new", "p", "offset", "input", "results", "image", "reader", "da", "buffer", "storage", "zero", "none", "batch", "slice", "cache"], "size": ["li", "message", "empty", "file", "max", "c", "i", "pack", "fee", "gz", "cm", "address", "Size", "channel", "time", "area", "word", "form", "sn", "e", "or", "page", "raw", "sum", "line", "sized", "SIZE", "id", "second", "enc", "member", "shape", "frame", "end", "z", "code", "length", "fail", "error", "column", "set", "sec", "send", "shift", "capacity", "mode", "false", "handle", "engine", "len", "en", "content", "again", "load", "scale", "ize", "row", "complete", "sync", "body", "value", "six", "large", "name", "group", "count", "number", "g", "pos", "timeout", "no", "type", "flow", "small", "new", "p", "offset", "si", "loc", "work", "position", "se", "go", "from", "image", "iz", "unit", "n", "storage", "grade", "slice"], "s": ["g", "os", "f", "sym", "site", "service", "parts", "cs", "ls", "sf", "ss", "xs", "y", "c", "sq", "a", "i", "ks", "sup", "sv", "d", "sb", "services", "is", "es", "p", "h", "ts", "sg", "si", "S", "ds", "b", "outs", "fs", "ssl", "context", "se", "ns", "in", "v", "spec", "client", "o", "t", "r", "ps", "ses", "l", "sc", "u", "sync", "gs", "w", "m", "conf", "e", "n", "sys", "rs", "sa", "space"], "marker": ["marksger", "markser", "signeter", "markener", "arker", " markiner", "marksorer", "Markoder", "Markoser", "Markner", "markner", " markger", " markener", " Markiner", "Markiner", "markoder", "markeders", "markoser", "marksoser", "Marketer", "marksener", " markoser", "arkiner", "Marker", "marketer", "markiner", " markoder", "signer", " marketer", "arkorer", "signoser", "Markers", "markedner", "caller", " markorer", "signener", "markedeter", "markeder", "markger", "markseter", "arketer", "markers", "Markger", " Marker", "marksiner", "signiner", " Markoder", "callener", " markers", " markner", "calleter", "markorer", "calloser", " Markger"], "idx": ["Idxs", "idexx", "idxp", "idct", "midz", "edxs", "idexs", "adn", "idez", "adz", " idxs", " idct", "indxp", "indX", "midx", "pidX", "midX", "pidz", "idex", "adx", "indx", "edz", "adxs", "idX", "pidx", " idX", "indz", "idxs", "idz", " idz", "Idx", "edx", "Idn", "adxes", "Idct", "ideX", " idxes", "pidxs", "idxes", "edxes", "Idxp", "IdX", "Idz", " idn", "indct", "midxx", "indxs", "idn", " idxx", "adX", "idexp", "idxx"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int ram_init1(SysBusDevice *dev)\n\n{\n\n    RamDevice *d = SUN4U_RAM(dev);\n\n\n\n    memory_region_init_ram(&d->ram, OBJECT(d), \"sun4u.ram\", d->size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&d->ram);\n\n    sysbus_init_mmio(dev, &d->ram);\n\n    return 0;\n\n}\n", "idx": 12200, "substitutes": {"dev": ["debug", "dem", "ga", "de", "hw", "wd", "device", "self", "dom", "serial", "rad", "md", "ver", "gd", "pu", "ev", "mod", "app", "driver", "Dev", "grad", "prom", "di", "dc", "mem", "ch", "link", "cmd", "def", "amd", "od", "cam", "w", "gr", "conf", "dm", "obj", "priv", "ad", "av", "data"], "d": ["dat", "sd", "f", "id", "did", "device", "D", "dom", "md", "c", " dd", "gd", "db", "i", "pd", "p", "dy", "rd", "ds", "b", "nd", "ld", "grad", "vd", "bd", "dc", "dd", "dn", "r", "t", "du", "da", "l", "u", "ded", "od", "w", "m", "dh", "dm", "e", "n", "dj", "fd", "ad", "data", "dt", "cd", "dad"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void stop_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val |= TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n", "idx": 12205, "substitutes": {"d": ["g", "dat", "plugin", "dict", "sd", "f", "id", "self", "D", "dom", "md", "c", "db", "gd", "draw", "dr", "pd", "mod", "p", "ds", "b", "nd", "ld", "grad", "bd", "di", "z", "dc", "dd", "ind", "dn", "df", "da", "t", "l", "dev", "ded", "od", "m", "dh", "e", "n", "s", "fd", "ad", "dl", "data", "dt", "cd", "dad"], "val": ["vol", "ann", "put", "valid", "f", "vals", "max", "ref", "sel", "len", "vel", "al", "eval", "p", "ol", "slot", "ot", "b", "Val", "fl", "fb", "cal", "pt", "VAL", "sl", "pre", "key", "v", "ee", "il", "ay", "bal", "rot", "ind", "el", "all", "_", "dev", "base", "unit", "aval", "value", "py", "alt", "data", "count", "pol", "x"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_put_be32(QEMUFile *f, unsigned int v)\n\n{\n\n    qemu_put_byte(f, v >> 24);\n\n    qemu_put_byte(f, v >> 16);\n\n    qemu_put_byte(f, v >> 8);\n\n    qemu_put_byte(f, v);\n\n}\n", "idx": 12215, "substitutes": {"f": ["F", "fen", "g", "fr", "tf", "file", "k", "self", "fi", "sf", "inf", "c", "elf", "a", "i", "fe", "d", "h", "p", "rf", "b", "fb", "fs", "fc", "fal", "t", "df", "af", "o", "uf", "l", "q", "fo", "fx", "u", "form", "m", "e", "fw", "s", "fd", "bf", "lf", "x"], "v": ["vol", "va", "k", "vt", "view", "y", "c", "conv", "i", "d", "sv", "ev", "h", "p", "b", "j", "vd", "uv", "iv", "cv", "lv", "o", "t", "val", "nv", "l", "V", "q", "u", "vp", "w", "m", "e", "n", "vu", "value", "s", "vv", "video", "vi", "ve", "data", "vs", "x", "volt"]}}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)\n\n{\n\n    int i, len, sz;\n\n    GetBitContext gb;\n\n    int code_table[64];\n\n\n\n    /* get the rle codes (at most 64 bytes) */\n\n    init_get_bits(&gb, src, 64 * 8);\n\n    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {\n\n        code_table[i] = get_sbits(&gb, 4);\n\n        sz += FFABS(code_table[i]);\n\n    }\n\n    src += (get_bits_count(&gb) + 7) / 8;\n\n\n\n    /* do the rle unpacking */\n\n    for (i = 0; i < 64 && dst_size > 0; i++) {\n\n        len = code_table[i];\n\n        if (len < 0) {\n\n            len = -len;\n\n            memset(dst, *src++, FFMIN(len, dst_size));\n\n        } else {\n\n            memcpy(dst, src, FFMIN(len, dst_size));\n\n            src += len;\n\n        }\n\n        dst += len;\n\n        dst_size -= len;\n\n    }\n\n    return src;\n\n}\n", "idx": 12216, "substitutes": {"src": ["text", "dest", "ctx", "sth", " dest", "comp", "byte", "sub", "seq", "rc", "b", "gz", "hh", "address", "secure", "rs", "inst", "supp", "sq", "conv", "dist", "sr", "sb", "rl", "gl", "lit", "ssl", "bg", "obl", "img", "grad", "code", "attr", "sc", "hl", "sur", "ctr", "ptr", "buf", "bc", "low", " addr", "config", "cur", "sl", "fc", " source", "source", "start", "sync", "lib", "RC", "uri", "sel", "addr", "sup", "cmp", "cb", "loc", "seed", "st", "url", "uv", " rc", "rb", "go", "rest", "uc", "stream", "slice"], "dst": ["adsp", "dsc", "lest", "sost", "ssrc", " dsp", "dest", "Dst", "ssts", " dest", "sst", "adst", "adsts", "dost", "Dsts", " dsts", "adost", "lst", "ssp", "dsrc", "lsp", " dsrc", "sest", "lsrc", "dsp", "dsts", " dost", "adsc", " dsc", "adsrc", "Dsrc", "Dost", "adest"], "dst_size": ["dst_capacity", "dst_width", "dstntime", "dest_scale", "dst_address", "dstnsize", "dst_length", "dsts_width", "dest_address", "dsc_time", "dst_line", "dsc_size", "dst_time", "dsts_length", "dsts_scale", "dest_size", "dsts_size", "dsc_line", "dost_scale", "dst_scale", "dest_time", "dost_address", "dest_capacity", "dstnline", "dost_size"], "i": ["ii", "pos", "ni", "li", "uri", "f", "id", "phi", "I", "iv", "diff", "ip", "oi", "mi", "fi", "adi", "y", "c", "iu", "en", "ini", "d", "multi", "rc", "h", "ri", "p", "si", "b", "xi", "io", "pi", "j", "inner", "gi", "ie", "cli", "z", "in", "code", "zi", "ti", "di", "ind", "r", "ui", "qi", "bi", "v", "attr", "l", "ci", "source", "u", "index", "e", "info", "ai", "eni", "x", "ix", "it"], "len": ["la", "pos", "li", "size", "f", "ll", "vec", "id", "limit", "elt", "err", "rev", "min", "seq", "lt", "low", "label", "en", "ul", "bl", "lp", "loc", "split", "Len", "lit", "fun", "le", "fl", "lim", "gen", "ler", "ld", "ie", "sl", "pre", "z", "lang", "lin", "length", "el", "bin", "val", "all", "l", "source", "lib", "hl", "n", "lon", "ln", "lan", "led", "lc", "L", "alt", "dl", "count", "lf", "line"], "sz": ["szi", "szz", "jsz", "geszi", "rszh", "gesz", "psz", "Sz", "Szi", "jszy", "jszz", "szh", "sq", " szy", "dszi", "sze", "rsze", "geszy", "dsz", "pszen", " szz", " szen", "rszi", "Sze", "geszen", "szen", "dsq", "szy", " szh", "pszi", "jszi", "Sq", "gesze", "pszh", " sq", "psze", "dsze", " szi", "rsz", " sze", "geszz"], "gb": ["Gb", "g", "ga", "pg", "bm", "gam", "GB", "gram", "gm", "nb", "bc", "rg", "gg", "gu", "db", "pc", "gd", "usb", " gcc", "sb", "yg", "cb", "kb", "sg", "gh", "gy", "mb", " rgb", " db", "bg", "gio", "cfg", " rc", "sl", "rb", " kb", "di", " rg", "hub", "bb", "ui", "gp", "abb", "gin", "ci", "gs", "nn", "gc", "bf"], "code_table": ["code_index", "code6table", " code_cache", "codeerconst", " code_const", "coderbinary", "dataaltable", "dataalfile", "codercache", "coderfile", " code_file", " code_TABLE", "codertable", "data_cache", " code_index", "code__table", "code6file", "code2tree", "codeercache", "code__file", "dataalbinary", " code_tree", "codealconst", "code2table", "code_binary", "code2cache", "codealfile", "code6TABLE", "data_table", "code6cache", "code_const", "data_file", "code_TABLE", "code__cache", "code_tree", "codeerindex", "codealindex", "codeertable", "dataalcache", "codealbinary", "code_file", "data_binary", "codealcache", "code__TABLE", "code_cache", "codealtable"]}}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "bool bdrv_is_first_non_filter(BlockDriverState *candidate)\n\n{\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    /* walk down the bs forest recursively */\n\n    while ((it = bdrv_next(it, &bs)) != NULL) {\n\n        bool perm;\n\n\n\n        /* try to recurse in this top level bs */\n\n        perm = bdrv_recurse_is_first_non_filter(bs, candidate);\n\n\n\n        /* candidate is the first non filter */\n\n        if (perm) {\n\n            return true;\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 12243, "substitutes": {"candidate": ["indidate", "coreidate", "candidated", "provenidated", "coreidation", "Candidated", "candidation", "indidates", "Candidates", "Candidation", "provenidation", " candidates", "provenidate", " candidation", "Candidate", "candidates", "coreidates", "indidated", "indidation", "provenidates"], "bs": ["os", "bos", "bis", "its", "cs", "ls", "ss", "bc", "BS", "pb", "db", "is", "lb", "ins", "sb", "bl", "ts", "loc", "ds", "blocks", "b", "fb", "bes", "fs", "bh", "bt", "ns", "ac", "bi", "bb", "ps", "ses", "banks", "base", "ubs", "bits", "bas", "rs", "s", "vs", "ops", "ba", "acl"], "it": ["abi", "pit", "ait", "bis", "its", "ip", "ble", "edit", "ul", "c", "stat", "iter", "i", "qt", "ant", "p", "ib", "ort", "si", "It", "you", "lit", "b", "ic", "j", "ct", "ite", "end", "act", "in", "iv", "ac", "op", "parent", "t", "mit", " It", "ci", "start", "iti", "ita", "not", "oc", "init", "itter", "n", "section", "IT", "exec"], "perm": ["lambda", "prefix", " permission", "f", "mode", "mp", "proc", "compl", "bc", "alpha", "len", "module", "pc", "cmp", "jp", "comm", "mod", "p", "per", "qa", "cm", "qua", "fac", "prom", "atom", "rule", "part", "partial", "fp", "op", "ms", "tmp", "ac", "inc", "spec", "filter", "mission", "apply", "attr", "command", "mask", "admin", "policy", "m", "pad", "lock", "func", "mm", "pa", "sk", "priv", "exec", "acl"]}}
{"project": "qemu", "commit_id": "f4bf56fb78ed0e9f60fa1ed656c14ff4c494da5a", "target": 1, "func": "static int vhost_user_set_mem_table(struct vhost_dev *dev,\n\n                                    struct vhost_memory *mem)\n\n{\n\n    int fds[VHOST_MEMORY_MAX_NREGIONS];\n\n    int i, fd;\n\n    size_t fd_num = 0;\n\n    bool reply_supported = virtio_has_feature(dev->protocol_features,\n\n                                              VHOST_USER_PROTOCOL_F_REPLY_ACK);\n\n\n\n    VhostUserMsg msg = {\n\n        .hdr.request = VHOST_USER_SET_MEM_TABLE,\n\n        .hdr.flags = VHOST_USER_VERSION,\n\n    };\n\n\n\n    if (reply_supported) {\n\n        msg.hdr.flags |= VHOST_USER_NEED_REPLY_MASK;\n\n    }\n\n\n\n    for (i = 0; i < dev->mem->nregions; ++i) {\n\n        struct vhost_memory_region *reg = dev->mem->regions + i;\n\n        ram_addr_t offset;\n\n        MemoryRegion *mr;\n\n\n\n        assert((uintptr_t)reg->userspace_addr == reg->userspace_addr);\n\n        mr = memory_region_from_host((void *)(uintptr_t)reg->userspace_addr,\n\n                                     &offset);\n\n        fd = memory_region_get_fd(mr);\n\n        if (fd > 0) {\n\n            msg.payload.memory.regions[fd_num].userspace_addr = reg->userspace_addr;\n\n            msg.payload.memory.regions[fd_num].memory_size  = reg->memory_size;\n\n            msg.payload.memory.regions[fd_num].guest_phys_addr = reg->guest_phys_addr;\n\n            msg.payload.memory.regions[fd_num].mmap_offset = offset;\n\n            assert(fd_num < VHOST_MEMORY_MAX_NREGIONS);\n\n            fds[fd_num++] = fd;\n\n        }\n\n    }\n\n\n\n    msg.payload.memory.nregions = fd_num;\n\n\n\n    if (!fd_num) {\n\n        error_report(\"Failed initializing vhost-user memory map, \"\n\n                     \"consider using -object memory-backend-file share=on\");\n\n        return -1;\n\n    }\n\n\n\n    msg.hdr.size = sizeof(msg.payload.memory.nregions);\n\n    msg.hdr.size += sizeof(msg.payload.memory.padding);\n\n    msg.hdr.size += fd_num * sizeof(VhostUserMemoryRegion);\n\n\n\n    if (vhost_user_write(dev, &msg, fds, fd_num) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (reply_supported) {\n\n        return process_message_reply(dev, &msg);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12245, "substitutes": {"dev": ["debug", "server", "dem", "de", "block", "pub", "mode", "device", "diff", "comment", "self", "proc", "dom", "mid", "serv", "serial", "gu", "md", "DEV", "user", "ver", "module", "game", "d", "feature", "node", "mod", "ev", "model", "temp", "app", "doc", "Dev", "prof", "dc", "client", "error", "cmd", "req", "def", "conn", "w", "conf", "init", "info", "msg", "var", "bug", "data", "cache"], "mem": ["server", "ann", "im", "mount", "mode", "pm", "device", "mi", "host", "gram", "serv", "mid", "connection", "user", "network", "disc", "mod", "tm", "loc", "rem", "use", "lim", "usage", "cpu", "memory", "machine", "image", "vm", "time", "program", "am", "conn", "mon", "dim", "gpu", "sum", "mo", "disk", "conf", "nm", "mm", "msg", "mor", "mc", "ram", "Mem", "um", "cache"], "fds": ["fdes", "Fdb", "Fannels", "hrs", "hds", " frs", "hdb", " fannels", "hannels", "fannels", "fcs", "Frs", "tfdes", "tfns", "Fcs", "frs", "fdb", "Fns", "tfcs", "fns", "tfds", "Fds", "Fdes", " fns", " fdb", " fdes", " fcs"], "i": ["ii", "ni", "li", "uri", "im", "f", "id", "phi", "I", "mu", "ip", "mi", "fi", "c", "iu", "ini", "d", "multi", "ri", "p", "ji", "si", "pi", "uli", "j", "gi", "ie", "part", "di", "ti", "in", "bi", "xi", "num", "ind", "r", "ui", "qi", "v", "ci", "start", "index", "u", "e", "n", "ai", "mini", "eni", "uni", "vi", "x", "ix", "it"], "fd": ["fr", "fn", "sd", "wd", "hd", "f", "buf", "nc", "ff", "draft", "fi", "sf", " fid", "md", "len", "fe", "d", "aa", "pd", "wr", "rd", "fee", "ds", "fm", "fb", "FD", "fl", "ld", "fat", "bd", "fa", "fp", "fc", "dc", "dd", "dn", "df", "handler", "cf", "fx", "fw", "ln", "fed", "dl", "bf", "dt", "dir", "lf", "nm"], "reg": ["debug", "tr", "g", "ga", "pg", "sam", "Reg", "re", "ref", "err", "serv", "tag", "rg", "sub", "addr", "db", "eg", "stat", "co", "registered", "disc", "rc", "mod", "config", "ro", "erg", "ru", "sg", "loc", "rem", "rule", "r", "ret", "ray", "attr", "greg", "req", "conn", "REG", "rec", "rm", "gr", "org", "region", "trans", "mor", "res", "sec", "ram", "rar", "rr", "ig", "mn"], "offset": ["pos", "timeout", "prefix", "optional", "no", "size", "pointer", "id", "format", "ptr", "ref", "api", "ip", "addr", "option", "len", "off", "slot", "loc", "range", "position", "end", "Offset", "part", "address", "fp", "num", "alloc", "o", "af", "area", "attr", "error", "start", "index", "inet", "fff", "set", "alt", "data", "location", "align", "nm"], "mr": ["tr", "usr", "fr", "nor", "rt", "mer", "nr", "bm", "hr", "mi", "rg", "adr", "wm", "MR", "sr", "dr", "ru", "lr", "wr", "pr", "rd", "rl", "rf", "fm", "cm", "vr", "mt", "rb", "yr", "r", "br", "kr", "attr", "shr", "km", "gor", "rm", "m", "gr", "er", "mor", "rr", "mc", "rh", "mn", "mx"]}}
{"project": "FFmpeg", "commit_id": "fa74cdc60d19798c951dcc242ca7273e6483f2b3", "target": 1, "func": "int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx,\n                     uint8_t **poutbuf, int *poutbuf_size,\n                     const uint8_t *buf, int buf_size,\n                     int64_t pts, int64_t dts, int64_t pos)\n{\n    int index, i;\n    uint8_t dummy_buf[AV_INPUT_BUFFER_PADDING_SIZE];\n    if (!(s->flags & PARSER_FLAG_FETCHED_OFFSET)) {\n        s->next_frame_offset =\n        s->cur_offset        = pos;\n        s->flags            |= PARSER_FLAG_FETCHED_OFFSET;\n    }\n    if (buf_size == 0) {\n        /* padding is always necessary even if EOF, so we add it here */\n        memset(dummy_buf, 0, sizeof(dummy_buf));\n        buf = dummy_buf;\n    } else if (s->cur_offset + buf_size != s->cur_frame_end[s->cur_frame_start_index]) { /* skip remainder packets */\n        /* add a new packet descriptor */\n        i = (s->cur_frame_start_index + 1) & (AV_PARSER_PTS_NB - 1);\n        s->cur_frame_start_index = i;\n        s->cur_frame_offset[i]   = s->cur_offset;\n        s->cur_frame_end[i]      = s->cur_offset + buf_size;\n        s->cur_frame_pts[i]      = pts;\n        s->cur_frame_dts[i]      = dts;\n        s->cur_frame_pos[i]      = pos;\n    }\n    if (s->fetch_timestamp) {\n        s->fetch_timestamp = 0;\n        s->last_pts        = s->pts;\n        s->last_dts        = s->dts;\n        s->last_pos        = s->pos;\n        ff_fetch_timestamp(s, 0, 0, 0);\n    }\n    /* WARNING: the returned index can be negative */\n    index = s->parser->parser_parse(s, avctx, (const uint8_t **) poutbuf,\n                                    poutbuf_size, buf, buf_size);\n    av_assert0(index > -0x20000000); // The API does not allow returning AVERROR codes\n    /* update the file pointer */\n    if (*poutbuf_size) {\n        /* fill the data for the current frame */\n        s->frame_offset = s->next_frame_offset;\n        /* offset of the next frame */\n        s->next_frame_offset = s->cur_offset + index;\n        s->fetch_timestamp   = 1;\n    }\n    if (index < 0)\n        index = 0;\n    s->cur_offset += index;\n    return index;\n}", "idx": 12255, "substitutes": {"s": ["server", "sym", "service", "cs", "self", "seq", "c", "a", "ks", "d", "settings", "b", "hs", "native", "css", "gs", "w", "as", "e", "comments", "rs", "strings", "js", "vs", "os", "site", "id", "its", "ls", "ss", "parser", "sq", "ins", "sb", "options", "http", "S", "ds", "session", "fs", "ssl", "ms", "ans", "o", "qs", "ses", "set", "f", "parts", "xs", "y", "services", "sg", "secondary", "bs", "v", "r", "ps", "_", "l", "sync", "u", "sys", "su", "g", "args", "request", "states", "uns", "single", "is", "new", "es", "p", "ts", "si", "full", "se", "ns", "less", "spec", "client", "us", "t", "your", "plugins", "m", "buffer", "conf", "func", "n", "sets", "this", "stats", "ops", "aws"], "avctx": ["avconfig", "avcmp", "avcontext", "AVctx", "abcmp", "afconfig", "AVconfig", "AVcli", "abcontext", "devcmp", "abctx", "AVcmp", "avcli", "afcli", "devcontext", "abconfig", "AVcontext", "devctx", "afctx", "devcli", "afcmp", "afcontext"], "poutbuf": [" pinbatch", " poutlen", "pnotqueue", "poutbuff", "pntbuf", "pinbuff", "puplen", "pdownsrc", "Poutbuf", "poutbatch", "Pinbuf", "poutsrc", "Poutsrc", "pnotbuf", " pinlen", "pdownqueue", " poutqueue", "pinqueue", "Poutbuff", "Pinsrc", " poutbatch", "pnotbatch", "pdownbuf", " pinqueue", "pntbuff", "pupqueue", "pnotlen", "poutlen", " pinbuf", "Pinbuff", "Pinqueue", "pupbatch", "poutqueue", "pdownbuff", "pinsrc", "pntqueue", "pinbuf", "pntsrc", "pupbuf", "pinbatch", "Poutqueue", "pinlen"], "poutbuf_size": ["poutbuffer_Size", "poutbuf1Size", "poutbuf_set", "poutbuf___size", "poutbuffer_start", "poutbuf_6", "poutbuffer_len", "poutbuf___start", "poutbuf___pos", "poutbuf___len", "poutbuf_pos", "poutqueue_set", "poutqueue_len", "poutbuf16", "poutbuffer_6", "poutbuf_len", "poutbuf_Size", "poutbuf1size", "poutqueue_size", "poutbuffer_pos", "poutbuf_start", "poutbuffer_size"], "buf": ["cas", "prop", "text", "ctx", "pool", "src", "vec", "result", "bc", "bag", "seq", "pb", "box", "config", "cb", "offset", "input", "b", "xff", "fb", "queue", "rb", "tmp", "cv", "num", "header", "alloc", "bb", "br", "Buffer", "uf", "cmd", "cf", "buff", "ab", "buffer", "port", "tc", "wb", "uc", "fd", "window", "data", "cache"], "buf_size": [" buffer__size", " buffer_Size", " buffer_fee", "window_Size", "buf_length", "buf_offset", "buf_capacity", "bufacnumber", "bufMcontent", "buf_fee", "windowMize", "img_offset", " buffer__number", " buffer_size", "window_size", "bufMsize", "buf_ize", " buffer__Size", "buf__fee", "buf_address", "buf__number", "bufacSize", "img_length", "bufMize", "window_ize", "uf_size", "windowMcontent", "uf_Size", "buf_Size", "windowMSize", " buffer_number", "img_sized", "window_content", "buf__Size", "windowMsize", "buffer_capacity", "buf_content", "bufacfee", " buffer__fee", "uf_ize", "img_size", "buf_number", "buffer_size", "buffer_address", "buf__size", "buf_name", "buffer_name", "buf_sized", "bufMSize", "bufacsize"], "pts": ["ptsb", "polys", "ntis", "ointns", "periodlines", "ntsb", "ptrsb", "periodses", "periods", "cts", "ntns", "ointis", "ptments", "periodls", "ptlines", "polylines", "iptlines", "iptd", "ptses", "ptns", "ctls", "ptris", "periodd", "ctments", "nts", "aptses", "ptrns", "periodments", "aptments", "ointsb", "oints", "ptls", "apts", "ipts", "ctses", "polyd", "ptd", "aptls", "ptrs", "ptis"], "dts": ["indths", " dds", "dds", "datts", "pds", "dths", "indts", "indtimes", "datats", "dats", "sdsts", "idts", "sdts", "pms", "dtimes", "adsts", " dats", "dcs", " dsts", "idcs", "sdps", "idths", "indcs", "idtimes", "ltimes", " dms", "dps", " dps", "adms", "adps", "adts", "dsts", "sdms", "lts", "datms", "pats", "lths", "lcs", "dms", "datds"], "pos": ["os", "POS", "to", "Pos", "block", "no", "pointer", "prop", "size", "pass", "type", "ref", "state", "x", "addr", "seq", "len", "pc", " positions", "p", "offset", "str", "slot", "sp", "loc", "nos", "doc", "position", "end", "neg", "pt", "po", "address", "z", "op", "length", "o", "time", "val", "all", "def", "start", "next", "cond", "body", "unit", "port", "n", "pose", "sec", "status", "depth", "pid", "slice", "cache"], "index": ["timeout", "version", "Index", "size", "f", "type", "id", "pointer", "match", "weight", "x", "connection", "alpha", "option", "len", "d", "config", "slice", "offset", "input", "si", "loc", "shape", "j", "object", "ticket", "position", "end", "partial", "array", "thread", "code", "num", "ind", "length", "insert", "error", "val", "argument", "all", "inc", "e", "n", "fff", "fix", "count", "ion"], "i": ["ii", "ni", "li", "uri", "f", "type", "phi", "I", "api", "ip", "mi", "fi", "y", "c", "len", "yi", "iu", "ini", "is", "ei", "multi", "ri", "p", "offset", "ji", "si", "b", "pi", "io", "uli", "j", "gi", "position", "ie", "cli", "di", "ti", "zi", "bi", "xi", "ind", "qi", "ui", "l", "ci", "start", "u", "e", "n", "info", "ai", "lc", "eni", "x", "ix", "it"], "dummy_buf": ["dummy_br", "ducky_buff", "dummies_buf", "doodle_fb", "ducky_queue", "dummyMbr", "ducky_buffer", "dummy67buf", "dummies_buff", "dummies_queue", "dummy_queue", "doodle_buff", "dummy_fb", "dummies_buffer", "dummy_buffer", "dummyMbuf", "dummies_br", "dummies_b", "doodle_buf", "dummyMbuff", "dummy_buff", "dummy67buffer", "dummy_b", "dummyMqueue", "dummy67buff", "doodle_buffer", "ducky_buf", "dummy67fb"]}}
{"project": "qemu", "commit_id": "b1b27b64262fdace45e5ab134c4438338076cb98", "target": 1, "func": "static int nbd_co_readv_1(NbdClientSession *client, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov,\n\n                          int offset)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    request.type = NBD_CMD_READ;\n\n    request.from = sector_num * 512;\n\n    request.len = nb_sectors * 512;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, qiov, offset);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n\n\n}\n", "idx": 12257, "substitutes": {"client": ["container", "server", "plugin", "uri", "clean", "ctx", "id", "api", "self", "front", "connection", "ce", "private", "c", "close", "public", "co", "method", "Client", "config", "ace", "http", "session", "connect", "cell", "ssl", "socket", "queue", "con", "simple", "project", "context", "open", "core", "cli", "parent", "gui", "resource", "ci", "conn", "chrome", "lib", "cod", "current", "child", "util", "custom", "cn", "manager", "complex", "cache"], "sector_num": [" sector_name", "section_name", "section_number", "sector64num", "sector1Num", "sector1num", "sector64index", " sector_number", "sector_index", "sector_number", "sector64number", "sector_Num", "sector1name", "section_index", "sector1number", "section_num", "sector_name", " sector_Num", "sector64name"], "nb_sectors": ["nb_psegments", "nb_psellers", "nb_veivers", "nb_secctors", "nb_vegments", "nb_secctor", "nb_teivers", "nb_pector", "nb_pseivers", "nb_vellers", "nb_tellers", "nb_tegments", "nb_vector", "nb_secctions", "nb_segments", "nb_pectors", "nb_vections", "nb_tectors", "nb_secgments", "nb_sellers", "nb_pegments", "nb_pections", "nb_vectors", "nb_sections", "nb_psectors", "nb_seivers", "nb_sector"], "qiov": ["wiev", "sqiii", "sqiu", "wiov", "qiev", "sqiov", "qovi", "sqovi", "quiev", "Qicho", "fiov", " qovi", "fiii", "fiu", "qiii", "qiu", "Qiev", "quiov", "wicho", " qiu", "qrolet", "qicho", "quicho", " qiii", "Qrolet", "fovi", "wrolet", "Qiov", "qurolet"], "offset": ["shift", "pos", "timeout", "et", "type", "format", "ref", "addr", "len", "i", "off", "reset", "slot", "loc", "range", "url", "position", "Offset", "part", "from", "fp", "address", "parent", "length", "o", "error", "start", "index", "reference", "base", "port", "set", "optional", "number", "location", "align"], "request": ["server", "message", "re", "claim", "art", "adjust", "response", "worker", "key", "address", "time", "resource", "q", "next", "move", "query", "join", "child", "id", "attribute", "result", "user", "search", "quest", "create", "hello", "session", "rf", "use", "frame", "pair", "record", "parent", "error", "get", "apply", "call", "demand", "allow", "er", "repeat", "send", "read", "xml", "Request", "have", "transfer", "route", "method", "event", "config", "push", "r", "insert", "complete", "req", "command", "QUEST", "report", "requ", "post", "type", "input", "order", "require", "work", "enter", "question", "friend", "save", "buffer", "reference", "data", "object"], "reply": ["server", "remote", "lag", "parse", "prefix", "flash", "id", "respond", "comment", "resp", "service", "callback", "match", "err", "repl", "rev", "ignore", "pb", "transfer", "write", " response", "back", "response", "order", "http", "fire", "replace", "Reply", "flag", "shell", "trade", "related", "address", "entry", "bill", "r", "link", "apply", "force", "sync", "proxy", "answer", "ry", "buffer", "query", "base", "report", "child", "sys", "info", "be", "rr", "send", "bot", "repair", "read", "post"], "ret": ["server", "et", "valid", "no", "rt", "f", "rets", "match", "format", "resp", "re", "RET", "att", "ref", "id", "rev", "ft", "result", "success", "len", "en", "iter", "art", "sr", "rc", "cat", "response", "order", "arr", "fun", "lit", "total", "url", "flag", "bit", "ext", "mt", "mem", "rot", "active", "r", "complete", "val", "get", "det", "af", "error", "arg", "last", "info", "er", "res", "reg", "nt", "out", "alt", "Ret", "bf", "data"]}}
