{"project": "FFmpeg", "commit_id": "83c285f88016b087c2f0f4b9ef356ad8ef12d947", "target": 1, "func": "static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *buf, int buf_size, const uint8_t *filename, int filename_size)\n\n{\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n    while(buf + 48 <= buf_end) {\n\n        int dir_length, name_size, first_sector, depth;\n\n        uint64_t file_length;\n\n        const uint8_t *name;\n\n        if (ff_guidcmp(buf, dir_entry_guid)) {\n\n            av_log(s, AV_LOG_ERROR, \"unknown guid \"FF_PRI_GUID\", expected dir_entry_guid; \"\n\n                   \"remaining directory entries ignored\\n\", FF_ARG_GUID(buf));\n\n            break;\n\n        }\n\n        dir_length  = AV_RL16(buf + 16);\n\n        file_length = AV_RL64(buf + 24);\n\n        name_size   = 2 * AV_RL32(buf + 32);\n\n        if (buf + 48 + name_size > buf_end) {\n\n            av_log(s, AV_LOG_ERROR, \"filename exceeds buffer size; remaining directory entries ignored\\n\");\n\n            break;\n\n        }\n\n        first_sector = AV_RL32(buf + 40 + name_size);\n\n        depth        = AV_RL32(buf + 44 + name_size);\n\n\n\n        /* compare file name; test optional null terminator */\n\n        name = buf + 40;\n\n        if (name_size >= filename_size &&\n\n            !memcmp(name, filename, filename_size) &&\n\n            (name_size < filename_size + 2 || !AV_RN16(name + filename_size)))\n\n            return wtvfile_open_sector(first_sector, file_length, depth, s);\n\n\n\n        buf += dir_length;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12273, "substitutes": {"s": ["ses", "aws", "south", "gs", "a", "S", "sw", "f", "serv", "socket", "p", "js", "n", "ex", "sq", "v", "t", "is", "sv", "sm", "spec", "sb", "sys", "ds", "ls", "r", "context", "obj", "acs", "ts", "self", "c", "sp", "stats", "ns", "b", "cs", "h", "ims", "es", "fs", "os", "se", "z", "sn", "w", "ss", "sts", "i", "rs", "ps"], "buf": ["vec", "shift", "orig", "cur", "ctx", "window", "raw", "pool", "port", "end", "loop", "ab", "word", "doc", "cb", "length", "emb", "uf", "queue", "pkg", "ait", "rc", "ptr", "ff", "data", "cmd", "aka", "n", "Buffer", "v", "next", "box", "read", "buff", "br", "obj", "fb", "que", "db", "cp", "pg", "tmp", "txt", "cf", "um", "ref", "seq", "wb", "proc", "batch", "ctr", "np", "rb", "offset", "buffer", "block", "cv", "bf", "bc", "iter", "uv", "err", "cast", "ob", "alloc", "bar", "bytes", "aw", "pb", "begin", "bt", "msg", "cache", "cap", "act", "cam", "desc", "xff", "r", "front", "off", "img", "b", "var", "gz", "prop", "bp"], "buf_size": ["buff8num", "buf__space", "buf__index", "buf8ize", "buff8ize", "bufipscale", "bufipspace", "buff8Size", "buf64size", "dir__space", "buf_num", "bufipsize", "buf__scale", "dir__index", "buf_space", "buf8Size", "buf8num", "dir_space", "buff_ize", "bufipindex", "dir_index", "buf_index", "buf_scale", "buf64num", "dir__scale", "buf_Size", "dir__size", "buf8size", "buff_Size", "buf64Size", "buff_num", "buf__size", "dir_size", "buff_size", "buf_ize", "dir_scale", "buff8size", "buf64ize"], "filename": ["ames", "path", "username", "metadata", "f", "png", "size", "uri", "Filename", "n", "vr", "nam", "v", "text", "title", "ename", "description", "println", "subject", "prefix", "Name", "buffer", "fp", "file", "fn", "bf", "folder", "tmp", "length", "nil", "ame", "package", "nm", "NAME", "txt", "nu"], "filename_size": ["filename5size", "name_length", "Filename_Size", "filename_max", " filename_space", "filename5space", "filename_offset", "username_size", "title_num", "filename_number", "filename5type", "filename_dimension", "username_length", "filenameptSize", " filename_type", "filenameablelength", "filenameptsize", "title_type", "filenameptdimension", " filename_offset", "filenameptunit", "filename_unit", "username_len", "filename_num", "filename_Size", "filename5offset", "filename_len", "name_weight", "Filename_size", "Filename_dimension", "name_max", "filenameablesize", "filenameablemax", "filename_space", "filename_type", "filename_length", "filename_weight", "title_number", "title_size", "Filename_unit", "username_Size", "filenameableweight"], "buf_end": ["buf_stop", "buf_END", "bufxest", "buf_ends", " buf_ends", "uf_end", "buf2END", "buff_stop", "buf_est", "bufxend", "buff_start", "buf_ended", "buff_END", "bufxended", "uf_END", "buf_start", " buf_ended", "buf2end", "bufxends", "buf2stop", " buf_est", "buf2start", "buff_end"], "dir_length": ["dir_long", "dir_position", "file_position", "diritysize", "file_size", "diritylength", "file_len", "dir_pad", " dir_len", "dir_loc", "dirityloc", " dir_long", "diritylong", " dir_size", "dir__size", " dir_loc", "dir_size", "dir__len", " dir_pad", "dir__length", "dir__position", "dir_len"], "name_size": ["name____size", " name_length", "file_size", "name_length", "name_error", "name_offset", "string____loss", "name____Size", " name_index", "nameaxylength", "nameitySize", " name_count", "NAME_Size", "name_body", " name_time", "name____loss", "name_Size", "name_ize", "name_count", "NAME_see", "string____Size", "name_index", "string_Size", "nameityoffset", "name_score", "name_SIZE", "NAME_offset", "file_body", "nameitysize", "nameaxyscore", "file_score", "name_time", "string_loss", "name_loss", "string____size", "nameaxybody", "name_spec", "NAME_error", "NAME_size", "title_ize", "string_size", " name_spec", "nameaxysize", "nameitylength", "title_length", "NAME_length", "title_size", "NAME_SIZE", "name_see"], "first_sector": ["First_ector", "initial_area", "first_component", "initialairowner", "initial_owner", " first_ector", " first_component", "First_reader", "firstairowner", " first_section", "first_ector", "initial_sector", "first_reader", "firstairsector", "firstairector", "firstairarea", "First_section", "initialairarea", "initial_ector", "first_owner", "First_sector", "initialairsector", "initialairector", "first_section", "first_area"], "depth": ["index", "path", "distance", "deep", "version", "ptr", "position", "push", "size", "scope", "mode", "window", "dir", "height", "rank", "offset", "dist", "Depth", "context", "time", "dim", "progress", "dq", " depths", "count", "debug", "volume", "scale", "der", "device", "DEP", "root", "dep", "direction", "trace", "max", "length", "history", "level", "fine", "driver", "priority"], "file_length": ["fileitystream", "fileitysize", " file_len", "dir_stream", " file_size", "file_size", "fileitylength", "fileityshape", "file_len", "name_length", "file_count", "name_location", "file_stream", " file_count", "file_location", "file_type", "name_type", "dir_size", "dir_shape", "file_shape"], "name": ["key", "path", "type", "mem", "version", "local", "orig", "size", "data", "n", "window", "nam", "names", "text", "len", "cache", "end", "cap", "title", "num", "word", "parent", "prefix", "Name", "comment", "buffer", "image", "file", "base", "all", "alias", "root", "id", "term", "label", "order", "var", "length", "max", "format", "ame", "w", "nm", "NAME", "str"]}}
{"project": "FFmpeg", "commit_id": "527f89e05922e840083ac6d49eeb838b1e350dd4", "target": 1, "func": "static void stereo_processing(PSContext *ps, INTFLOAT (*l)[32][2], INTFLOAT (*r)[32][2], int is34)\n\n{\n\n    int e, b, k;\n\n\n\n    INTFLOAT (*H11)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H11;\n\n    INTFLOAT (*H12)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H12;\n\n    INTFLOAT (*H21)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H21;\n\n    INTFLOAT (*H22)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H22;\n\n    int8_t *opd_hist = ps->opd_hist;\n\n    int8_t *ipd_hist = ps->ipd_hist;\n\n    int8_t iid_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t icc_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t ipd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t opd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t (*iid_mapped)[PS_MAX_NR_IIDICC] = iid_mapped_buf;\n\n    int8_t (*icc_mapped)[PS_MAX_NR_IIDICC] = icc_mapped_buf;\n\n    int8_t (*ipd_mapped)[PS_MAX_NR_IIDICC] = ipd_mapped_buf;\n\n    int8_t (*opd_mapped)[PS_MAX_NR_IIDICC] = opd_mapped_buf;\n\n    const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20;\n\n    TABLE_CONST INTFLOAT (*H_LUT)[8][4] = (PS_BASELINE || ps->icc_mode < 3) ? HA : HB;\n\n\n\n    //Remapping\n\n    if (ps->num_env_old) {\n\n        memcpy(H11[0][0], H11[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[0][0][0]));\n\n        memcpy(H11[1][0], H11[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[1][0][0]));\n\n        memcpy(H12[0][0], H12[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[0][0][0]));\n\n        memcpy(H12[1][0], H12[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[1][0][0]));\n\n        memcpy(H21[0][0], H21[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[0][0][0]));\n\n        memcpy(H21[1][0], H21[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[1][0][0]));\n\n        memcpy(H22[0][0], H22[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[0][0][0]));\n\n        memcpy(H22[1][0], H22[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[1][0][0]));\n\n    }\n\n\n\n    if (is34) {\n\n        remap34(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1);\n\n        remap34(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1);\n\n        if (ps->enable_ipdopd) {\n\n            remap34(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n            remap34(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n        }\n\n        if (!ps->is34bands_old) {\n\n            map_val_20_to_34(H11[0][0]);\n\n            map_val_20_to_34(H11[1][0]);\n\n            map_val_20_to_34(H12[0][0]);\n\n            map_val_20_to_34(H12[1][0]);\n\n            map_val_20_to_34(H21[0][0]);\n\n            map_val_20_to_34(H21[1][0]);\n\n            map_val_20_to_34(H22[0][0]);\n\n            map_val_20_to_34(H22[1][0]);\n\n            ipdopd_reset(ipd_hist, opd_hist);\n\n        }\n\n    } else {\n\n        remap20(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1);\n\n        remap20(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1);\n\n        if (ps->enable_ipdopd) {\n\n            remap20(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n            remap20(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n        }\n\n        if (ps->is34bands_old) {\n\n            map_val_34_to_20(H11[0][0]);\n\n            map_val_34_to_20(H11[1][0]);\n\n            map_val_34_to_20(H12[0][0]);\n\n            map_val_34_to_20(H12[1][0]);\n\n            map_val_34_to_20(H21[0][0]);\n\n            map_val_34_to_20(H21[1][0]);\n\n            map_val_34_to_20(H22[0][0]);\n\n            map_val_34_to_20(H22[1][0]);\n\n            ipdopd_reset(ipd_hist, opd_hist);\n\n        }\n\n    }\n\n\n\n    //Mixing\n\n    for (e = 0; e < ps->num_env; e++) {\n\n        for (b = 0; b < NR_PAR_BANDS[is34]; b++) {\n\n            INTFLOAT h11, h12, h21, h22;\n\n            h11 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][0];\n\n            h12 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][1];\n\n            h21 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][2];\n\n            h22 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][3];\n\n\n\n            if (!PS_BASELINE && ps->enable_ipdopd && b < NR_IPDOPD_BANDS[is34]) {\n\n                //The spec say says to only run this smoother when enable_ipdopd\n\n                //is set but the reference decoder appears to run it constantly\n\n                INTFLOAT h11i, h12i, h21i, h22i;\n\n                INTFLOAT ipd_adj_re, ipd_adj_im;\n\n                int opd_idx = opd_hist[b] * 8 + opd_mapped[e][b];\n\n                int ipd_idx = ipd_hist[b] * 8 + ipd_mapped[e][b];\n\n                INTFLOAT opd_re = pd_re_smooth[opd_idx];\n\n                INTFLOAT opd_im = pd_im_smooth[opd_idx];\n\n                INTFLOAT ipd_re = pd_re_smooth[ipd_idx];\n\n                INTFLOAT ipd_im = pd_im_smooth[ipd_idx];\n\n                opd_hist[b] = opd_idx & 0x3F;\n\n                ipd_hist[b] = ipd_idx & 0x3F;\n\n\n\n                ipd_adj_re = AAC_MADD30(opd_re, ipd_re, opd_im, ipd_im);\n\n                ipd_adj_im = AAC_MSUB30(opd_im, ipd_re, opd_re, ipd_im);\n\n                h11i = AAC_MUL30(h11,  opd_im);\n\n                h11  = AAC_MUL30(h11,  opd_re);\n\n                h12i = AAC_MUL30(h12,  ipd_adj_im);\n\n                h12  = AAC_MUL30(h12,  ipd_adj_re);\n\n                h21i = AAC_MUL30(h21,  opd_im);\n\n                h21  = AAC_MUL30(h21,  opd_re);\n\n                h22i = AAC_MUL30(h22,  ipd_adj_im);\n\n                h22  = AAC_MUL30(h22,  ipd_adj_re);\n\n                H11[1][e+1][b] = h11i;\n\n                H12[1][e+1][b] = h12i;\n\n                H21[1][e+1][b] = h21i;\n\n                H22[1][e+1][b] = h22i;\n\n            }\n\n            H11[0][e+1][b] = h11;\n\n            H12[0][e+1][b] = h12;\n\n            H21[0][e+1][b] = h21;\n\n            H22[0][e+1][b] = h22;\n\n        }\n\n        for (k = 0; k < NR_BANDS[is34]; k++) {\n\n            LOCAL_ALIGNED_16(INTFLOAT, h, [2], [4]);\n\n            LOCAL_ALIGNED_16(INTFLOAT, h_step, [2], [4]);\n\n            int start = ps->border_position[e];\n\n            int stop  = ps->border_position[e+1];\n\n            INTFLOAT width = Q30(1.f) / ((stop - start) ? (stop - start) : 1);\n\n#if USE_FIXED\n\n            width <<= 1;\n\n#endif\n\n            b = k_to_i[k];\n\n            h[0][0] = H11[0][e][b];\n\n            h[0][1] = H12[0][e][b];\n\n            h[0][2] = H21[0][e][b];\n\n            h[0][3] = H22[0][e][b];\n\n            if (!PS_BASELINE && ps->enable_ipdopd) {\n\n            //Is this necessary? ps_04_new seems unchanged\n\n            if ((is34 && k <= 13 && k >= 9) || (!is34 && k <= 1)) {\n\n                h[1][0] = -H11[1][e][b];\n\n                h[1][1] = -H12[1][e][b];\n\n                h[1][2] = -H21[1][e][b];\n\n                h[1][3] = -H22[1][e][b];\n\n            } else {\n\n                h[1][0] = H11[1][e][b];\n\n                h[1][1] = H12[1][e][b];\n\n                h[1][2] = H21[1][e][b];\n\n                h[1][3] = H22[1][e][b];\n\n            }\n\n            }\n\n            //Interpolation\n\n            h_step[0][0] = AAC_MSUB31_V3(H11[0][e+1][b], h[0][0], width);\n\n            h_step[0][1] = AAC_MSUB31_V3(H12[0][e+1][b], h[0][1], width);\n\n            h_step[0][2] = AAC_MSUB31_V3(H21[0][e+1][b], h[0][2], width);\n\n            h_step[0][3] = AAC_MSUB31_V3(H22[0][e+1][b], h[0][3], width);\n\n            if (!PS_BASELINE && ps->enable_ipdopd) {\n\n                h_step[1][0] = AAC_MSUB31_V3(H11[1][e+1][b], h[1][0], width);\n\n                h_step[1][1] = AAC_MSUB31_V3(H12[1][e+1][b], h[1][1], width);\n\n                h_step[1][2] = AAC_MSUB31_V3(H21[1][e+1][b], h[1][2], width);\n\n                h_step[1][3] = AAC_MSUB31_V3(H22[1][e+1][b], h[1][3], width);\n\n            }\n\n            ps->dsp.stereo_interpolate[!PS_BASELINE && ps->enable_ipdopd](\n\n                l[k] + start + 1, r[k] + start + 1,\n\n                h, h_step, stop - start);\n\n        }\n\n    }\n\n}\n", "idx": 12278, "substitutes": {"ps": ["jp", "gs", "bs", "Ps", "ports", "outs", "pr", "p", "js", "proc", "plays", "eps", "pt", "pp", "ping", "als", "pse", "points", "ds", "times", "s", "aps", "vals", "ips", "ts", "pps", "sp", "stats", "caps", "vs", "cp", "ops", "ns", "cs", "mp", "pers", "changes", "PS", "pre", "os", "posts", "parts", "px", "fps", "pkg", "ms", "checks", "pa"], "l": ["li", "f", "o", "ol", "ll", "lc", "j", "n", "p", "ln", "dl", "L", "v", "g", "sl", "el", "le", "loc", "ls", "m", "c", "lp", "lt", "kl", "z", "q", "lo", "pl", "i"], "r": ["rc", "cr", "n", "p", "v", "g", "ar", "rr", "t", "er", "rb", "m", "rt", "c", "ry", "h", "re", "rd", "d", "q", "rx", "w", "R", "x", "rn", "rs"], "is34": ["is36", "i33", "is3", "IS3", " IS3", "IS36", "IS24", "is33", " IS24", " IS36", "i3", " IS33", "IS33", "is24", "i36", "i24"], "e": ["be", "a", "f", "et", "o", "ei", "p", "n", "v", "g", "le", "t", "er", "E", "ea", "y", "ie", "c", "ec", "oe", "u", "d", "me", "w", "i", "pe"], "b": ["be", "a", "ba", "f", "bs", "j", "n", "p", "eb", "v", "g", "bi", "bt", "ab", "rb", "fb", "c", "cb", "db", "bf", "bc", "B", "bb", "nb", "bp", "i", "y"], "k": ["key", "o", "kh", "j", "km", "n", "p", "kid", "kk", "tk", "v", "g", "ik", "ke", "K", "m", "s", "ck", "c", "ak", "u", "z", "q", "i", "w", "y", "ka", "sk"], "opd_hist": ["opd_state", "opdo_graph", "opdo_history", "opd5history", "opd_pred", "opdo_pred", "opd_progress", "opdo_progress", "opdo_state", "opd_history", "opd_graph", "opd5graph", "opd5pred", "opd5hist", "opdo_hist"], "ipd_hist": ["ipn_hist", "ipd_high", "ipd__best", "ipd___hist", "ipdo_best", "ipd__history", "ipdo_history", "ipn_high", "ipd_history", "ipd_best", "ipdo_hist", "ipdo_txt", "ipd___hp", "ipd_txt", "ipd__hist", "ipd___high", "ipn_hp", "ipd___history", "ipn_history", "ipd_hp", "ipd__txt"], "iid_mapped_buf": ["iid_maped_desc", "iid_mapper_buf", "iid_maped_buf", "iid_mapped2buf", "iid_mapped_desc", "iid_mapped_buffer", "iid_mapped2buffer", "iid_mapper_buff", "iid_mapped_cv", "iid_mapped2cv", "iid_mapped_buff", "iid_maped_buffer", "iid_mapper_cv", "iid_mapped2buff", "iid_mapper_buffer"], "PS_MAX_NUM_ENV": ["PS_MAX_NUMINGENQ", "PS_MAX_NUM_EXTVs", "PS_MAX_NUM_ENVEL", "PS_MAX_NUM__INVS", "PS_MAX_NUM_ETv", "PS_MAX_NUM_ENGVs", "PS_MAX_NUM__ENVER", "PS_MAX_NUM_EXTv", "PS_MAX_NUM2ENV", "PS_MAX_NUM_INVC", "PS_MAX_NUM_INVs", "PS_MAX_NUM_INQ", "PS_MAX_NUM_PNVEL", "PS_MAX_NUM__ENIV", "PS_MAX_NUM_enV", "PS_MAX_NUM__EnH", "PS_MAX_NUM_env", "PS_MAX_NUM_ENIV", "PS_MAX_NUM_INF", "PS_MAX_NUM_enIV", "PS_MAX_NUM_enX", "PS_MAX_NUMINGENGVs", "PS_MAX_NUM2EnV", "PS_MAX_NUM_EXTVS", "PS_MAX_NUM_ENGV", "PS_MAX_NUM2ENVS", "PS_MAX_NUM_enVER", "PS_MAX_NUMINGENV", "PS_MAX_NUM__ENv", "PS_MAX_NUM_ENGQ", "PS_MAX_NUM_EXTV", "PS_MAX_NUM2EnVER", "PS_MAX_NUM_ENGVS", "PS_MAX_NUM2EnVS", "PS_MAX_NUM_EnVER", "PS_MAX_NUM2EnF", "PS_MAX_NUM_enVC", "PS_MAX_NUMINGENGQ", "PS_MAX_NUM__INVER", "PS_MAX_NUM_EnH", "PS_MAX_NUM_EnF", "PS_MAX_NUM_PNX", "PS_MAX_NUM_INV", "PS_MAX_NUM_ENX", "PS_MAX_NUM__INV", "PS_MAX_NUM__INv", "PS_MAX_NUM__ENVS", "PS_MAX_NUM__EnV", "PS_MAX_NUMINGENGV", "PS_MAX_NUM_PNVs", "PS_MAX_NUM__EnVS", "PS_MAX_NUM_INVER", "PS_MAX_NUM_enVEL", "PS_MAX_NUM__ENH", "PS_MAX_NUMINGENGVS", "PS_MAX_NUM_EnVs", "PS_MAX_NUM_INv", "PS_MAX_NUM_EnVS", "PS_MAX_NUM_INVS", "PS_MAX_NUM_ENv", "PS_MAX_NUM_ENVs", "PS_MAX_NUM_EnV", "PS_MAX_NUM2ENF", "PS_MAX_NUM_EnVC", "PS_MAX_NUM_ENQ", "PS_MAX_NUM_ENVER", "PS_MAX_NUM_EnQ", "PS_MAX_NUM_enH", "PS_MAX_NUM2ENVER", "PS_MAX_NUM_ETV", "PS_MAX_NUM_Env", "PS_MAX_NUMINGENVs", "PS_MAX_NUM_ENH", "PS_MAX_NUM_PNV", "PS_MAX_NUM_ETX", "PS_MAX_NUM__EnIV", "PS_MAX_NUM_ENVS", "PS_MAX_NUM_ENF", "PS_MAX_NUM_INH", "PS_MAX_NUM_enVS", "PS_MAX_NUM__ENV", "PS_MAX_NUM_PNVER", "PS_MAX_NUM_EnIV", "PS_MAX_NUM_ETVEL", "PS_MAX_NUM_ENVC", "PS_MAX_NUM_PNv", "PS_MAX_NUMINGENVS", "PS_MAX_NUM_PNVS"], "icc_mapped_buf": ["icc_mapped_buffer", "icc_maped_queue", "icc_mapping_window", "icc_mapped_buff", "icc_mapped_window", "icc_mapping_buff", "icc_mapping_buf", "icc_mapped__str", "icc_maped_str", "icc_mapped_queue", "icc_mapped__buf", "icc_mapped_str", "icc_mapped__queue", "icc_maped_buffer", "icc_mapping_buffer", "icc_mapped__buffer", "icc_maped_buf"], "ipd_mapped_buf": ["ipd_mapped2buf", "ipd_mapping_buf", "ipd_mappedlyuf", "ipd_mapped_img", "ipd_mapped__uf", "ipd_mapping_img", "ipd_mapped_buffer", "ipd_mapper_buff", "ipd_mapped2buffer", "ipd_mapped__buff", "ipd_mapping_buffer", "ipd_mappedlybuf", "ipd_mappedlyimg", "ipd_mapped__buffer", "ipd_mapper_buffer", "ipd_mapper_buf", "ipd_mapped__buf", "ipd_mapper_uf", "ipd_mapping_uf", "ipd_mapped2img", "ipd_mapped2uf", "ipd_mapped_uf", "ipd_mappedlybuffer", "ipd_mapped_buff"], "opd_mapped_buf": ["opd_mapper_buf", "opd_mapper_uf", "opd_mapped2buffer", "opd_mapped_buffer", "opd_mapper_buff", "opd_mapped2buf", "opd_mapped_uf", "opd_mapped2uf", "opd_mapper_buffer", "opd_mapped_buff", "opd_mapped2buff"], "iid_mapped": ["iid_mmuted", "iid_comapped", "iid_Muted", "iid_comuted", "iid_muted", "iid_mmapped", "iid_comapping", "iid_comaped", "iid_Maped", "iid_mmaped", "iid_Mapping", "iid_mapping", "iid_maped", "iid_mmapping", "iid_Mapped"], "icc_mapped": ["icc_memigrated", "icc_samigrated", "icc_memapped", "icc_mmapped", "icc_mmigrated", "icc_memmitted", "icc_mapping", "icc_mmmitted", "icc_samapping", "icc_sammitted", "icc_mmapping", "icc_mmitted", "icc_samapped", "icc_migrated", "icc_memapping"], "ipd_mapped": ["ipd_mapping", "ipd_mmocked", "ipd_mocked", "ipd_mmapping", "ipd_Mapper", "ipd_Mapping", "ipd_Mocked", "ipd_Mapped", "ipd_smocked", "ipd_mapper", "ipd_mmapped", "ipd_smapping", "ipd_smapped", "ipd_smapper", "ipd_mmapper"], "opd_mapped": ["opd_manned", "opd_canned", "opd_mrashed", "opd_mmashed", "opd_mrapped", "opd_cashed", "opd_mashed", "opd_capped", "opd_mapper", "opd_mrapper", "opd_mmapper", "opd_mmapped", "opd_capper", "opd_mranned", "opd_mmanned"], "INTFLOAT": ["INTFLOOATS", "INTFLONATT", "INTPLOAR", "INTPLOATER", "INTFLOBATT", "INTFROBATT", "INTFLoAR", "INTFLOLAT", "INTPLOATION", "INTFLOATS", "INTFLOBAT", "INTPLOAT", "INTFROOAR", "INTFLPOATER", "INTPLOOATT", "INTFLOBAR", "INTFLOLATT", "INTFLOLATS", "INTFLONANT", "INTFROOATT", "INTFLOAR", "INTFLOOATION", "INTFROBAT", "INTFLPOAT", "INTFLOBANT", "INTFLoAN", "INTFROATER", "INTPLOBAT", "INTFROAR", "INTPLOBANT", "INTPLOATT", "INTFLOATER", "INTPLOAN", "INTFLOBATER", "INTFLONATS", "INTPLONAN", "INTFROBATER", "INTFLOLATION", "INTFLPOAR", "INTPLOANT", "INTFROOAT", "INTPLOOAT", "INTFLONAN", "INTFLOATT", "INTFROATT", "INTFLOOANT", "INTFLOATION", "INTFLPOATT", "INTFROAT", "INTFLLOATS", "INTPLOOATION", "INTFLOBATS", "INTFLOANT", "INTFLOLANT", "INTPLONAT", "INTFLPOATS", "INTFLOLAR", "INTFLONAT", "INTPLOBATER", "INTFLOOAT", "INTFLoATS", "INTPLONANT", "INTFLLOAN", "INTFLOOAN", "INTFLoATT", "INTPLONATS", "INTFLOOAR", "INTFLLOAT", "INTFLOOATT", "INTFLoAT", "INTFLOLATER", "INTFLLOANT", "INTFROATS", "INTFLPOATION", "INTFLOAN", "INTFLOOATER", "INTPLOBAR", "INTPLOOATS", "INTFROBATS", "INTFROOATS", "INTPLOATS"]}}
{"project": "qemu", "commit_id": "04f8c053cca9c329eebb761f3a1ffef3d349b84c", "target": 1, "func": "static void handle_qmp_command(JSONMessageParser *parser, QList *tokens)\n\n{\n\n    int err;\n\n    QObject *obj;\n\n    QDict *input, *args;\n\n    const mon_cmd_t *cmd;\n\n    Monitor *mon = cur_mon;\n\n    const char *cmd_name, *info_item;\n\n\n\n    args = NULL;\n\n\n\n    obj = json_parser_parse(tokens, NULL);\n\n    if (!obj) {\n\n        // FIXME: should be triggered in json_parser_parse()\n\n        qerror_report(QERR_JSON_PARSING);\n\n        goto err_out;\n\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, \"object\");\n\n        qobject_decref(obj);\n\n        goto err_out;\n\n    }\n\n\n\n    input = qobject_to_qdict(obj);\n\n\n\n    mon->mc->id = qdict_get(input, \"id\");\n\n    qobject_incref(mon->mc->id);\n\n\n\n    obj = qdict_get(input, \"execute\");\n\n    if (!obj) {\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n\n    } else if (qobject_type(obj) != QTYPE_QSTRING) {\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\", \"string\");\n\n\n    }\n\n\n\n    cmd_name = qstring_get_str(qobject_to_qstring(obj));\n\n\n\n    if (invalid_qmp_mode(mon, cmd_name)) {\n\n        qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n    }\n\n\n\n    /*\n\n     * XXX: We need this special case until we get info handlers\n\n     * converted into 'query-' commands\n\n     */\n\n    if (compare_cmd(cmd_name, \"info\")) {\n\n        qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n    } else if (strstart(cmd_name, \"query-\", &info_item)) {\n\n        cmd = monitor_find_command(\"info\");\n\n        qdict_put_obj(input, \"arguments\",\n\n                      qobject_from_jsonf(\"{ 'item': %s }\", info_item));\n\n    } else {\n\n        cmd = monitor_find_command(cmd_name);\n\n        if (!cmd || !monitor_handler_ported(cmd)) {\n\n            qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n        }\n\n    }\n\n\n\n    obj = qdict_get(input, \"arguments\");\n\n    if (!obj) {\n\n        args = qdict_new();\n\n\n\n\n    } else {\n\n        args = qobject_to_qdict(obj);\n\n        QINCREF(args);\n\n    }\n\n\n\n    QDECREF(input);\n\n\n\n    err = monitor_check_qmp_args(cmd, args);\n\n    if (err < 0) {\n\n        goto err_out;\n\n    }\n\n\n\n    if (monitor_handler_is_async(cmd)) {\n\n        qmp_async_cmd_handler(mon, cmd, args);\n\n    } else {\n\n        monitor_call_handler(mon, cmd, args);\n\n    }\n\n    goto out;\n\n\n\nerr_input:\n\n    QDECREF(input);\n\nerr_out:\n\n    monitor_protocol_emitter(mon, NULL);\n\nout:\n\n    QDECREF(args);\n\n}", "idx": 12281, "substitutes": {"parser": ["manager", "loader", "ner", "p", "native", "sq", "pd", "arser", "builder", "ping", "er", "util", "policy", "command", "processor", "php", "part", "message", "reader", "parse", "handler", "document", "der", "pair", "inner", "Parser"], "tokens": ["tobings", "targelines", " topleings", "Targen", " topleENS", "tokENS", "Targens", "tobkens", "targings", "toyens", "topleENS", "Targkens", " tokkens", "Token", " tokings", "tobENS", "tocens", "toplekens", " tokENS", "Tokkens", "Targelines", "tobens", "Tokelines", " toplekens", "targENS", "Tokens", "tokelines", "targen", "tockens", "tocelines", "topleings", "toykens", "tocen", "targkens", " topleens", "token", "topleens", "tokings", "toyen", "toyelines", "targens", "tokkens"], "err": ["error", "type", "score", "erer", "out", "attr", " Err", "or", "val", "v", "rr", "er", " score", "buf", "m", "y", "Error", "r", "cb", "c", "count", "ach", "e", " len", "fer", "i", "str", "arr"], "obj": ["conn", "orig", "onet", "attr", "ctx", "expr", "cmp", "opt", "typ", "bj", "t", "nt", "att", "art", "po", "app", "it", "pkg", "cont", "arr", "def", "obs", "object", "ind", "j", "js", "comm", "buff", "og", "rect", "tmp", "con", "elt", "ex", "txt", "resp", "vo", "oc", "canon", "out", "ref", "tk", "obo", "ox", "bo", "np", "op", "snap", "ot", "nex", "Object", "objects", "str", "ob", "instance", "dict", "o", "utt", "ent", "Obj", "pt", "msg", "act", "ct", "oss", "ck", "opp", "oj", "img", "gm", "oid", "os", "inst", "adj"], "input": ["index", "def", "path", "amount", "view", "dict", "conn", "local", "output", "out", "ref", "orig", "head", "data", "hidden", "window", "raw", "storage", "text", "check", "Input", "source", "initial", "ahead", "select", "act", "in", "get", "context", "att", "json", " inputs", "doc", "qa", "update", "add", "info", "PUT", "buffer", "mm", "up", "image", "all", "base", "img", "import", "table", "start", "active", "tmp", "inner", "conf", "arg", "list", "from", "config", "valid", "q", "joined", "interface", "xml", "init", "str", "cont", "history", "form", "ip"], "args": ["types", "gs", "out", "tags", "attr", "data", "flags", "ctx", "js", "params", "keys", "names", "ams", "fields", "in", "json", "items", "extra", "atts", "headers", "vals", "qs", "ts", "pos", "ins", "ns", "cs", "Args", "ks", "arg", "parts", "options", "files", "actions", "rs", "arr"], "cmd": ["quit", "resp", "def", "dict", "cf", "conn", "ph", "cur", "cond", "ind", "ctx", "fun", "cn", "crit", "cmp", "pat", "call", "req", "mk", "cd", "cli", "ctr", "md", "nd", "comm", "msg", "command", "func", "cat", "ct", "nt", "act", "cfg", "cl", "cy", "norm", "phy", "quick", "ck", "dq", "c", "cb", "Cmd", "bind", "cp", "chan", "urg", "cont", "col", "qt", "pkg", "init", "exec", "txt", "ch"], "mon": ["mem", "conn", "manager", "serv", "local", "mi", "por", "onet", "admin", "stat", "man", "mint", "dir", "dm", "monitor", "sam", "mind", "comm", "mos", "den", "mont", "tem", "Mon", "util", "sm", "mate", "num", "m", "dom", " monitor", "ann", "MON", "mu", "self", "mm", "om", "mut", "demon", "mit", "mitter", "on", "mc", "mat", "master", "von", "rain", "my", "mt", "non", "conf", "monkey", "mons", "mn", "mun", "mx", "wat"], "cmd_name": [" cmd_id", "cmd23Name", "msg_name", "cmd_key", "cb_Name", "cmd_comment", "cmd_value", "cmp_data", "batch_value", "cmdptname", "procptno", "cmd_not", "cbLEname", "cmd_named", "cmd_id", "cmd23not", "cmd_item", "cb_local", "cmdNamedata", "cmdMvalue", "cmdNamename", "procptame", "cmd2Name", "cmdMcomment", "cmd_names", "cmdmynew", "cmdNamebase", "cmd_ame", "cmdmyname", "cmp_base", " cmd_item", " cmd_named", "cmd_local", "cmdNameitem", "cmdLEName", "cbLElocal", "cmdMname", "cb_names", "batch_name", "cmd_Name", "cmd23named", "cmdptno", "cmd_data", "cmdmyvalue", "msg_Name", " cmd_not", "cmp_name", "proc_no", "cmdLEname", "cmd23name", "batch_comment", "cmdMnew", "cbLEName", "msg_key", "cmd2name", "cbLEnames", "proc_ame", "cmd2no", "cmdLEnames", " cmd_no", "cmd_new", "cmp_item", "proc_name", "cmdmycomment", "batch_new", "cmd_base", "cb_name", "procptname", "cmd_no", "cmdLElocal", " cmd_Name", "msg_no", "cmdptame"], "info_item": ["infoablevalue", "info_items", "infomyid", "infoableid", " info_msg", "info2item", "infomyitem", " info_Item", "info_id", "info2items", "infoableitem", "info_Item", "infoableitems", " info_value", "info_msg", "infomyvalue", "infomyitems", " info_id", "info_value", " info_items", "info2Item"]}}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int idcin_decode_init(AVCodecContext *avctx)\n\n{\n\n    IdcinContext *s = avctx->priv_data;\n\n    int i, j, histogram_index = 0;\n\n    unsigned char *histograms;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = PIX_FMT_PAL8;\n\n    dsputil_init(&s->dsp, avctx);\n\n\n\n    /* make sure the Huffman tables make it */\n\n    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  Id CIN video: expected extradata size of %d\\n\", HUFFMAN_TABLE_SIZE);\n\n        return -1;\n\n    }\n\n\n\n    /* build the 256 Huffman decode trees */\n\n    histograms = (unsigned char *)s->avctx->extradata;\n\n    for (i = 0; i < 256; i++) {\n\n        for(j = 0; j < HUF_TOKENS; j++)\n\n            s->huff_nodes[i][j].count = histograms[histogram_index++];\n\n        huff_build_tree(s, i);\n\n    }\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 12305, "substitutes": {"avctx": ["avtx", "awtx", "avercmd", "vertx", "apctl", "vrctx", "Avcontext", "avercontext", "avpkg", "wavjac", "abcontext", "vercontext", "abjac", "aptx", "Avctx", "awcfg", " avcontext", "abconn", "avejp", "wavtx", "cvjac", " avctl", "avcfg", "wavctx", "vrcontext", "avcmp", "AVcontext", "awctx", "awcontext", "afctl", "avecontext", "aftx", "avetx", "verctx", " avcmp", "abctx", " avcfg", "averca", "cvctx", "verconn", "AVctx", "apctx", " avconn", "wavpkg", "afcontext", "apjp", "vrtx", "afcmd", "afctx", "Avtx", "averctx", "apcontext", " avca", "avcmd", "avjp", " avjac", "abpkg", "avconn", "avca", "avejac", "afcfg", "afca", "aveconn", "avjac", " avpkg", "avctl", "wavcontext", "avcontext", "cvcontext", " avcmd", "AVcmp", " avtx", "vrcfg", "wavjp", "apcfg", "Avcmp", "AVtx", "avectx", "abtx", "cvtx"], "s": ["comments", "aws", "ses", "gs", "S", "sw", "as", "bs", "less", "n", "js", "p", "sq", "ags", "v", "g", "sl", "details", "bes", "t", "source", "us", "is", "sb", "sv", "als", "comm", "hs", "sys", "ds", "ls", "ats", "ess", "aps", "acs", "sc", "qs", "ies", "ssl", "ts", "c", "stats", "ears", "ares", "vs", "ins", "states", "ns", "b", "cs", "tests", "ims", "sync", "set", "tes", "fs", "os", "its", "parts", "q", "sports", "scl", "ss", "sts", "ms", "rs", "w", "ps"], "i": ["status", "index", "ij", "li", "key", "by", "at", "iu", "o", "mi", "ii", "I", "pi", "ini", "ei", "ind", "p", "ki", "ex", "si", "n", "zi", "name", "v", "g", "bi", "us", "ui", "is", "iq", "di", "ik", "ami", "asi", "e", " ii", "ai", "m", "in", "k", "ie", "iy", "xi", "\u0438", "im", "iri", "ci", "ims", "id", "ti", "point", "u", "my", "ri", "from", "it", "multi", "gi", "ji", "me", "z", "q", "phi", "x", "y", "ic", "ix", "ip"], "j": ["ij", "jp", "index", "key", "kh", "jit", "ii", "ind", "l", "pr", "n", "js", "p", "aj", "kid", "jas", "bj", "v", "g", "ng", "bi", "pt", "uj", "bo", "job", "k", "m", "br", "att", "obj", "json", "ja", "c", "dj", "J", "oj", "mn", "jj", "no", "on", "b", "h", "jump", "jo", "fr", "jl", "jc", "ji", "it", "kj", "z", "q", "x", "y", "adj"], "histograms": ["memometers", "historyobs", "hograms", " histoids", "digores", "Histrices", "histobs", "histores", "memograms", "histometers", "hashograms", " histrices", " histensions", "hogram", "hashometers", "histories", "Histensions", "historyots", "histoids", "hashoids", "historyogram", "memoids", " histores", "hots", "digrices", "histrices", "Histograms", "Histores", "histensions", "histots", " histometers", " histobs", " histots", "digograms", "hobs", "histogram", "digensions", "historyograms", "hashories", " histogram", " histories", "memories"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static void find_best_solid_area(VncState *vs, int x, int y, int w, int h,\n\n                                 uint32_t color, int *w_ptr, int *h_ptr)\n\n{\n\n    int dx, dy, dw, dh;\n\n    int w_prev;\n\n    int w_best = 0, h_best = 0;\n\n\n\n    w_prev = w;\n\n\n\n    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {\n\n\n\n        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy);\n\n        dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev);\n\n\n\n        if (!check_solid_tile(vs, x, dy, dw, dh, &color, true)) {\n\n            break;\n\n        }\n\n\n\n        for (dx = x + dw; dx < x + w_prev;) {\n\n            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, x + w_prev - dx);\n\n\n\n            if (!check_solid_tile(vs, dx, dy, dw, dh, &color, true)) {\n\n                break;\n\n            }\n\n            dx += dw;\n\n        }\n\n\n\n        w_prev = dx - x;\n\n        if (w_prev * (dy + dh - y) > w_best * h_best) {\n\n            w_best = w_prev;\n\n            h_best = dy + dh - y;\n\n        }\n\n    }\n\n\n\n    *w_ptr = w_best;\n\n    *h_ptr = h_best;\n\n}\n", "idx": 12307, "substitutes": {"vs": ["ses", "ails", "gs", "court", "bs", "verts", "values", "js", "vr", "blogs", "vp", "v", "xs", "lists", "Vs", "vg", "sv", "hs", "sys", "iffs", "ds", "ls", "atts", "vals", "ts", "stats", "forces", "otes", "ils", "ins", "ns", "ops", "cs", "lbs", "fs", "os", "aunts", "views", "vc", "vt", "fps", "sts", "VS", "rs", "ps"], "x": ["tx", "index", "at", "axis", "sw", "wx", "ax", "l", "yx", "p", "row", "ex", "dr", "xxx", "dl", "X", "xd", "v", "xs", "xy", "el", "t", "ox", "xp", "fx", "m", "r", "xi", "c", "xc", "on", "xx", "wd", "d", "px", "xf", "z", "xa", "rx", "i", "xt", "ix"], "y": ["yy", "uy", "ty", "ly", "yt", "oy", "by", "asy", "py", "o", "ny", "ys", "yx", "j", "l", "sy", "p", "axy", "hy", "Y", "v", "yi", "height", "xy", "ya", "ay", "t", "ym", "yr", "er", "ye", "yd", "cy", "vy", "iy", "ies", "c", "yer", "ry", "b", "ish", "my", "sky", "wy", "z", "gy", "ey", "yl", "i", "ic", "ch"], "w": ["ww", "wh", "nw", "fw", "sw", "rw", "wx", "l", "hw", "p", "wb", "window", "wl", "v", "t", "wa", "wt", "ow", "wn", "m", "ew", "iw", "wp", "wd", "W", "wi", "wr", "weight", "d", "z", "i"], "h": ["wh", "ph", "kh", "hr", "l", "n", "p", "hm", "bh", "him", "v", "ha", "height", "t", "ih", "hs", "his", "k", "m", "ah", "th", "hi", "he", "s", "hei", "hd", "c", "count", "oh", "sh", "ht", "b", "H", "ish", "hl", "hash", "q", "hh", "zh", "ch", "hp"], "color": ["status", "kw", "actor", "olor", "light", "type", "colored", "background", "attr", "size", "or", "role", "pixel", "resource", "Color", "gb", "cell", "channel", "message", "category", "white", "parent", "comment", "colour", "c", "image", "function", "theme", "alpha", "red", "action", "term", "COLOR", "font", "draw", "fc", "state", "col", "var", "hash", "country", "style", "format", "cycle", "value", "blue"], "w_ptr": ["wa_best", "wmmptr", " w__ptr", "wa_map", " w_rel", "w__rel", "wmmbest", "wqbest", "w_best", "wqrel", "w__per", " w__per", " w_best", " w__rel", "wqper", " w__best", "wmmrel", "w_map", "w__best", "wqptr", "w_rel", "wa_ptr", "wmmper", " w_per", "w__ptr", "w_per", "wa_prop", "w_prop"], "h_ptr": ["h_____ptr", "hUptr", "hm_pad", "hm_expr", "h_expr", "hw_cur", "hoxexpr", "hw_rev", "h_pad", "hUrev", "hm_ptr", "hw_ptr", "h_push", "hoxpush", "h_cur", "hoxpad", "hUcur", "h_rev", "hUaddr", "hoxptr", "h_addr", "h_____push", "hm_push", "h_____expr", "h_____pad", "hw_addr"], "dx": ["tx", "index", " ax", "dial", "wx", "eddy", "ax", "yx", "addr", "ctx", "ex", "dr", "dl", "xd", "zi", "cd", "xs", "dt", "tex", "dp", "xy", "ay", "du", "DX", "ox", "xp", "ds", "fx", "dd", "xi", "iy", "dim", "ady", "dq", "dj", "lat", "wd", "xx", "zx", "coord", "draw", "d", "tp", "px", "wy", "qt", " xx", "did", "ix", "mx", "dra"], "dy": ["yy", "uy", "south", "ty", "dial", "des", "oy", "py", "ny", "ii", "ury", "dn", "yx", "ei", "sy", "axy", "dl", "dir", "dt", "yi", "dm", "height", "xy", "wed", "ay", "ym", "try", "aily", "di", "tile", "delay", "ds", "dd", "zy", "cy", "hi", "vy", "elly", "iy", "phy", "dim", "ady", "dq", "dj", "yer", "ry", "ht", "die", "idy", "my", "d", "ne", "wy", "gy", "ey", "phi", "dies", "did", "hh", "eddy", "yl", "dyl", "zh", "fy", "addy", " Dy"], "dw": ["adwe", "sdwa", "tdwa", "DW", "dwe", "indwt", " dl", "Dl", "idwd", "adw", "dwd", "Dws", "ddwe", "indew", "dnw", "adh", "idwa", "dwa", "sdw", "rdwt", "dnl", "Dy", " dms", "ddW", "ddh", "dnwp", "ddw", "dW", "djw", "sdW", "dsw", "indwidth", " dwe", "rdw", "rdwe", "djwt", "sdl", "ddew", "Dh", "tdwd", "idwh", "djsw", "dew", "dl", "ddms", "Dwe", " dew", "ddl", " dsw", "adW", " dws", "sdwd", "dwp", "ddws", "rdsw", "dnms", "djwe", "dws", "dwt", " dwt", "sdwh", "tdwh", "ddwp", " dwp", "indw", "dwh", "sdy", "ddwidth", "dwidth", " dwidth", "Dw", "idw", " dW", "tdw", "dms", "ddwt"], "dh": ["td", "olor", "dial", "ptr", "kh", "ouch", "ph", "dn", "addr", "hz", "hw", "hm", "dr", "dl", "bh", "vp", "cd", "dt", "dm", "dp", "pd", "yi", "him", "ih", "di", "hs", "ds", "eth", "hi", "health", "phy", "dim", "html", "ssl", "hd", "dq", "hor", "idth", "dj", "sh", "kl", "ht", "hhhh", "hl", "d", "harm", "DH", "wy", "phi", "hh", "vt", "sth", "dyl", "tp", "zh", "hp", " Dh"], "w_prev": ["w_rev", "wd_attr", "w_best", "kw_rev", "h__prev", "wp_iter", "wd_best", "wJattr", "wp_ptr", "w_last", "w00prev", "w00Prev", "w__cmp", "w_pred", "wd__ptr", "sw_prev", "fw_pre", "w___orig", "w00pred", "w__next", "fw_orig", "w__prev", "h_best", "wp_prev", "w_pre", "wJPrev", "w_attr", "wd_next", "wd__prev", "h_cmp", "w__best", "w2prev", "wp5iter", "h_rev", "h__cmp", "w___obj", "w2iter", "w5prev", "wd_pred", "wd_Prev", "w2best", "sw_best", "wp5ptr", "wd__next", "h__rev", "fw___prev", "h_pre", "wd__best", "w__last", "w___pre", "wp5prev", "wd_ptr", "fw___obj", "w_inv", "kw_prev", "w2next", "w__rev", "w__inv", "w_cmp", "wJprev", "w_orig", "w_Prev", "wp_best", "w_next", "fw_obj", "fw___pre", "w__ptr", "w_iter", "w5best", "h_prev", "kw_last", "fw___orig", "sw_inv", "w5iter", "wJpred", "w00attr", "sw_last", "wd_prev", "kw_best", "fw_prev", "w___prev", "w_obj", "wp5best", "h__best", "w2ptr", "w5ptr"]}}
{"project": "qemu", "commit_id": "43771539d4666cba16298fc6b0ea63867425277c", "target": 0, "func": "static RAMBlock *qemu_get_ram_block(ram_addr_t addr)\n\n{\n\n    RAMBlock *block;\n\n\n\n    /* The list is protected by the iothread lock here.  */\n\n    block = ram_list.mru_block;\n\n    if (block && addr - block->offset < block->max_length) {\n\n        goto found;\n\n    }\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        if (addr - block->offset < block->max_length) {\n\n            goto found;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Bad ram offset %\" PRIx64 \"\\n\", (uint64_t)addr);\n\n    abort();\n\n\n\nfound:\n\n    ram_list.mru_block = block;\n\n    return block;\n\n}\n", "idx": 12314, "substitutes": {"addr": ["tx", "node", "ress", "nl", "mem", "ptr", "ref", " addresses", "inter", " mac", "address", "attr", "cmd", "ctx", "hw", "size", "kt", "dr", "ord", "req", "adr", "len", "loc", "msg", "offset", "align", "act", " fmt", " tid", "eth", " tx", "obj", "url", "sha", "add", "prefix", "range", "art", "pos", "link", " add", " ip", "res", "ack", "start", "id", "active", " dst", "mt", "ad", "order", " x", "ace", "hash", "max", "to", " address", "dh", "net", "amp", "arg", " r", "err", "ip", " err", "name", "arr", "rs", "ix", "alloc", "Address", "arp"], "block": ["window", "raw", "check", "load", "field", "loop", "new", "lock", "line", "Block", "word", "blocking", "label", "length", "zero", "tx", "def", "type", "number", "object", "address", "data", "map", "mask", "group", "box", "space", "bus", "part", "obj", "open", "self", "null", "link", "sync", "set", "join", "BL", "x", "an", "ip", "node", "key", "record", "out", "ref", "row", "batch", "unit", "bo", "op", "in", "broad", "snap", "buffer", "empty", "file", "hash", "alloc", "bar", "instance", "local", "p", "chain", "cl", "condition", "blocks", "none", "prefix", "sp", "image", "event", "base", "byte", "b", "bl", "point", "list", "commit", "name"]}}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "static int usbnet_can_receive(VLANClientState *nc)\n\n{\n\n    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n\n\n    if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED)\n\n        return 1;\n\n\n\n    return !s->in_len;\n\n}\n", "idx": 12320, "substitutes": {"nc": ["isc", "nl", "nw", "unc", "oc", "cus", "cn", "ctx", "n", "cc", "psc", "ng", "nd", "dc", "np", "nz", "nr", "ct", "nt", "uc", "nec", "ck", "gn", "c", "cb", "cv", "ec", "gc", "ns", "nic", "cs", "bc", "mc", "pc", "NT", "ne", "nm", "rn", "anc", "nn", "NC"], "s": ["sis", "ses", "aws", "gs", "S", "sw", "bs", "has", "less", "j", "n", "js", "sq", "xs", "sl", "sol", "comm", "is", "sb", "sv", "als", "sys", "hs", "ds", "ls", "ats", "iss", "ess", "qs", "ts", "sp", "stats", "states", "ns", "cs", "h", "ims", "os", "z", "sports", "ss", "sts", "i", "rs", "ps"]}}
{"project": "qemu", "commit_id": "333d50fe3d9a1ff0a6a1a44ef42a0d3a2a7f2abe", "target": 0, "func": "static int scsi_disk_emulate_mode_sense(SCSIRequest *req, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    int page, dbd, buflen, page_control;\n\n    uint8_t *p;\n\n    uint8_t dev_specific_param;\n\n\n\n    dbd = req->cmd.buf[1]  & 0x8;\n\n    page = req->cmd.buf[2] & 0x3f;\n\n    page_control = (req->cmd.buf[2] & 0xc0) >> 6;\n\n    DPRINTF(\"Mode Sense(%d) (page %d, len %d, page_control %d)\\n\",\n\n        (req->cmd.buf[0] == MODE_SENSE) ? 6 : 10, page, len, page_control);\n\n    memset(outbuf, 0, req->cmd.xfer);\n\n    p = outbuf;\n\n\n\n    if (bdrv_is_read_only(s->bs)) {\n\n        dev_specific_param = 0x80; /* Readonly.  */\n\n    } else {\n\n        dev_specific_param = 0x00;\n\n    }\n\n\n\n    if (req->cmd.buf[0] == MODE_SENSE) {\n\n        p[1] = 0; /* Default media type.  */\n\n        p[2] = dev_specific_param;\n\n        p[3] = 0; /* Block descriptor length.  */\n\n        p += 4;\n\n    } else { /* MODE_SENSE_10 */\n\n        p[2] = 0; /* Default media type.  */\n\n        p[3] = dev_specific_param;\n\n        p[6] = p[7] = 0; /* Block descriptor length.  */\n\n        p += 8;\n\n    }\n\n\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n\n    if ((~dbd) & nb_sectors) {\n\n        if (req->cmd.buf[0] == MODE_SENSE) {\n\n            outbuf[3] = 8; /* Block descriptor length  */\n\n        } else { /* MODE_SENSE_10 */\n\n            outbuf[7] = 8; /* Block descriptor length  */\n\n        }\n\n        nb_sectors /= s->cluster_size;\n\n        if (nb_sectors > 0xffffff)\n\n            nb_sectors = 0;\n\n        p[0] = 0; /* media density code */\n\n        p[1] = (nb_sectors >> 16) & 0xff;\n\n        p[2] = (nb_sectors >> 8) & 0xff;\n\n        p[3] = nb_sectors & 0xff;\n\n        p[4] = 0; /* reserved */\n\n        p[5] = 0; /* bytes 5-7 are the sector size in bytes */\n\n        p[6] = s->cluster_size * 2;\n\n        p[7] = 0;\n\n        p += 8;\n\n    }\n\n\n\n    if (page_control == 3) { /* Saved Values */\n\n        return -1; /* ILLEGAL_REQUEST */\n\n    }\n\n\n\n    switch (page) {\n\n    case 0x04:\n\n    case 0x05:\n\n    case 0x08:\n\n    case 0x2a:\n\n        p += mode_sense_page(req, page, p, page_control);\n\n        break;\n\n    case 0x3f:\n\n        p += mode_sense_page(req, 0x08, p, page_control);\n\n        p += mode_sense_page(req, 0x2a, p, page_control);\n\n        break;\n\n    default:\n\n        return -1; /* ILLEGAL_REQUEST */\n\n    }\n\n\n\n    buflen = p - outbuf;\n\n    /*\n\n     * The mode data length field specifies the length in bytes of the\n\n     * following data that is available to be transferred. The mode data\n\n     * length does not include itself.\n\n     */\n\n    if (req->cmd.buf[0] == MODE_SENSE) {\n\n        outbuf[0] = buflen - 1;\n\n    } else { /* MODE_SENSE_10 */\n\n        outbuf[0] = ((buflen - 2) >> 8) & 0xff;\n\n        outbuf[1] = (buflen - 2) & 0xff;\n\n    }\n\n    if (buflen > req->cmd.xfer)\n\n        buflen = req->cmd.xfer;\n\n    return buflen;\n\n}\n", "idx": 12326, "substitutes": {"req": ["resp", "tx", "jp", "pro", "rpm", "request", "wx", "ref", "src", "usr", "good", "push", "attr", "ind", "seq", "cmd", "ctx", "j", "expr", "crit", "sq", "proc", "Request", "compl", "reg", "http", "eq", "md", "comm", "spec", "uj", "msg", "wcs", "desc", "r", "ux", "aux", "rs", "org", "prefix", "hawk", "dq", "range", "sim", "inv", "qs", "rh", "gr", "res", "dev", "rec", "fr", "urg", "Requ", "conf", "nil", "requ", "qt", "err", "rez", "q", "gz", "rx", "pkg", "esp", "quest", "rr", "qq"], "outbuf": ["outputbuffer", "outputbag", "outbuffer", " outbuffer", "outqueue", "outimg", "inbuffer", "outputbuf", "outbuff", "inqueue", "inbuf", "outputimg", "inbuff", "outputBuff", "inBuff", "inimg", "Outbuf", " outqueue", "outBuff", " outimg", "Outbuffer", "outbag", "outputbuff", " outbuff", "inbag", "Outbag", "outputqueue", "Outbuff", " outBuff"], "s": ["gs", "S", "bs", "query", "sq", "sam", "t", "m", "qs", "stats", "sr", "requ", "cont", "ps", "def", "ctl", "j", "n", "js", "v", "g", "spec", "ds", "conf", "i", "a", "sb", "er", "sys", "hs", "c", "fs", "d", "se", "ss", "session", "is", "ls", "r", "ts", "sp", "ns", "b", "bl", "h", "sd", "_", "q", "sts", "y", "rs"], "nb_sectors": ["nb_shctors", "nb_vevers", "nb_comxes", "nb_curlements", "nb_SEllers", "nb_curctors", "nb_SEvers", "nb_tevers", "nb_eleicas", "nb_secs", "nb_seicas", "nb_vecs", "nb_temctors", "nb_becs", "nb_secers", "nb_seels", "nb_eleors", "nb_comors", "nb_veels", "nb_persevers", "nb_veicas", "nb_sector", "nb_curels", "nb_vegments", "nb_bectors", "nb_begments", "nb_perseters", "nb_curors", "nb_gector", "nb_sexes", "nb_temvers", "nb_beors", "nb_spectors", "nb_tegments", "nb_geors", "nb_veters", "nb_comicas", "nb_spevers", "nb_segments", "nb_severs", "nb_persectors", "nb_gectors", "nb_comctors", "nb_seecs", "nb_beters", "nb_tectors", "nb_spegments", "nb_specs", "nb_nevers", "nb_shels", "nb_shors", "nb_vectors", "nb_seectors", "nb_sellers", "nb_electors", "nb_nectors", "nb_velements", "nb_seeors", "nb_vexes", "nb_selements", "nb_speors", "nb_temors", "nb_neors", "nb_seters", "nb_nellers", "nb_shlements", "nb_vector", "nb_teors", "nb_elexes", "nb_SEctors", "nb_vecers", "nb_seector", "nb_temcers", "nb_bevers", "nb_gecs", "nb_SEors", "nb_specers", "nb_vellers", "nb_perseors", "nb_seors", "nb_veors"], "page": ["node", "server", "index", "key", "number", "ref", "position", "pen", "size", "pi", "seq", "address", "row", "window", "proc", "pages", "next", "port", "field", "frame", "len", "pp", "loop", "offset", "num", "power", "line", "channel", "age", "sp", "block", "sel", "lp", "base", "db", "limit", "pos", "count", "table", "device", "pg", "order", " len", "pid", "length", "col", "Page", "net", "me", "pl", "i", "pointer"], "dbd": ["dbp", "dpbd", "bbd", "dpd", "bdd", " dbid", "DBn", "bdds", "DBd", " dbdim", "DBbd", "dpn", "ddbd", "dbdim", " dbdo", "bbp", "dbds", "bbid", " dbend", "bdid", "ddds", "bddim", "DBdo", " dbds", "bdbd", "bdp", " dbbd", "dpdo", " dbn", "bdend", "dddim", "dbid", "bbend", "ddd", " dbp", "dbdo", "dbend", "dbbd", "dbn"], "buflen": ["buplens", " buflens", "bullen", "buglength", " bullength", " buflength", "buflun", "buplen", "buglun", "buglen", "bullun", " bullen", "buglens", "buplun", "buflength", "buplength", "bullens", "bullength", " bullun", " buflun", " bullens", "buflens"], "page_control": ["pageflightctrl", " page_ctrl", "pageflightlength", " page_length", "page_controlled", "pageflightcontrol", "page_critical", "pageflightcritical", "page_controller", "page_ctrl", " page_controlled", " page_controller", " page_critical", "page_length"], "p": ["jp", "status", "a", "at", "f", "o", "out", "pi", "l", "pb", "j", "n", "pr", "x", "vp", "perm", "after", "v", "pm", "dp", "g", "pt", "port", "t", "pp", "ping", "cache", "np", "P", "m", "op", "r", "part", "power", "att", "php", "rep", "progress", "c", "sp", "lp", "fp", "up", "ap", "wp", "cp", "b", "post", "h", "mp", "pc", "e", "point", "u", "pre", "app", "pad", "it", "d", "pid", "q", "ip", "pkg", "i", "w", "tp", "pa", "pe", "ps"], "dev_specific_param": ["dev_general_const", "dev_general_config", "dev_dependent_conf", "dev_dependent_tag", "dev_general_param", "dev_specific_p", "dev_specific_comment", "dev_general_index", "dev_specific_info", "dev_specific_par", "dev_specific_tag", "dev_dependent_param", "dev_specific_conf", "dev_specific_num", "dev_specific_index", "dev_specific_config", "dev_specificitynum", "dev_general_par", "dev_specificityp", "dev_specificityparam", "dev_specificityconst", "dev_specificitypar", "dev_Specific_param", "dev_general_info", "dev_dependent_comment", "dev_Specific_par", "dev_Specific_p", "dev_specific_const", "dev_general_num"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "void tcg_add_target_add_op_defs(const TCGTargetOpDef *tdefs)\n\n{\n\n    TCGOpcode op;\n\n    TCGOpDef *def;\n\n    const char *ct_str;\n\n    int i, nb_args;\n\n\n\n    for(;;) {\n\n        if (tdefs->op == (TCGOpcode)-1)\n\n            break;\n\n        op = tdefs->op;\n\n        assert((unsigned)op < NB_OPS);\n\n        def = &tcg_op_defs[op];\n\n#if defined(CONFIG_DEBUG_TCG)\n\n        /* Duplicate entry in op definitions? */\n\n        assert(!def->used);\n\n        def->used = 1;\n\n#endif\n\n        nb_args = def->nb_iargs + def->nb_oargs;\n\n        for(i = 0; i < nb_args; i++) {\n\n            ct_str = tdefs->args_ct_str[i];\n\n            /* Incomplete TCGTargetOpDef entry? */\n\n            assert(ct_str != NULL);\n\n            tcg_regset_clear(def->args_ct[i].u.regs);\n\n            def->args_ct[i].ct = 0;\n\n            if (ct_str[0] >= '0' && ct_str[0] <= '9') {\n\n                int oarg;\n\n                oarg = ct_str[0] - '0';\n\n                assert(oarg < def->nb_oargs);\n\n                assert(def->args_ct[oarg].ct & TCG_CT_REG);\n\n                /* TCG_CT_ALIAS is for the output arguments. The input\n\n                   argument is tagged with TCG_CT_IALIAS. */\n\n                def->args_ct[i] = def->args_ct[oarg];\n\n                def->args_ct[oarg].ct = TCG_CT_ALIAS;\n\n                def->args_ct[oarg].alias_index = i;\n\n                def->args_ct[i].ct |= TCG_CT_IALIAS;\n\n                def->args_ct[i].alias_index = oarg;\n\n            } else {\n\n                for(;;) {\n\n                    if (*ct_str == '\\0')\n\n                        break;\n\n                    switch(*ct_str) {\n\n                    case 'i':\n\n                        def->args_ct[i].ct |= TCG_CT_CONST;\n\n                        ct_str++;\n\n                        break;\n\n                    default:\n\n                        if (target_parse_constraint(&def->args_ct[i], &ct_str) < 0) {\n\n                            fprintf(stderr, \"Invalid constraint '%s' for arg %d of operation '%s'\\n\",\n\n                                    ct_str, i, def->name);\n\n                            exit(1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        /* TCGTargetOpDef entry with too much information? */\n\n        assert(i == TCG_MAX_OP_ARGS || tdefs->args_ct_str[i] == NULL);\n\n\n\n        /* sort the constraints (XXX: this is just an heuristic) */\n\n        sort_constraints(def, 0, def->nb_oargs);\n\n        sort_constraints(def, def->nb_oargs, def->nb_iargs);\n\n\n\n#if 0\n\n        {\n\n            int i;\n\n\n\n            printf(\"%s: sorted=\", def->name);\n\n            for(i = 0; i < def->nb_oargs + def->nb_iargs; i++)\n\n                printf(\" %d\", def->sorted_args[i]);\n\n            printf(\"\\n\");\n\n        }\n\n#endif\n\n        tdefs++;\n\n    }\n\n\n\n#if defined(CONFIG_DEBUG_TCG)\n\n    i = 0;\n\n    for (op = 0; op < tcg_op_defs_max; op++) {\n\n        const TCGOpDef *def = &tcg_op_defs[op];\n\n        if (def->flags & TCG_OPF_NOT_PRESENT) {\n\n            /* Wrong entry in op definitions? */\n\n            if (def->used) {\n\n                fprintf(stderr, \"Invalid op definition for %s\\n\", def->name);\n\n                i = 1;\n\n            }\n\n        } else {\n\n            /* Missing entry in op definitions? */\n\n            if (!def->used) {\n\n                fprintf(stderr, \"Missing op definition for %s\\n\", def->name);\n\n                i = 1;\n\n            }\n\n        }\n\n    }\n\n    if (i == 1) {\n\n        tcg_abort();\n\n    }\n\n#endif\n\n}\n", "idx": 12329, "substitutes": {"tdefs": ["tdevls", "tsdefs", "tsdefares", "tdefineds", "mtdefaults", "tdefcs", "tconfcs", "tdefins", "tdefinedins", "tdefls", "wdefds", "wdeclls", "tdescacs", "vtconfcs", "tdfares", "tdfeds", "tdeclins", "vtconfs", "tsdfds", "tdesacs", "tconfinitions", "tdefares", "vtdefacs", "tdeveds", "tdeclls", "tdefaultins", "tdefaultls", "tdfds", "tdesinitions", "tservds", "tdesccs", "tdefinedds", "tdefds", "tdefinedls", "wdefls", "tdefinitions", "tdefacs", "tdevds", "tdfs", "mtdefins", "tdevs", "tconfacs", "tservs", "tserveds", "vtconfinitions", "tdefaults", "tconfs", "tservares", "vtdefcs", "tsdefeds", "tdefeds", "wdecls", "tdevares", "mtdefs", "tdess", "wdefs", "tsdefds", "vtdefinitions", "tsdfeds", "tdescinitions", "tsdfs", "wdeclds", "vtconfacs", "tdecls", "tsdfares", "mtdefls", "tdeclds", "mtdefaultins", "mtdefaultls", "tdescs", "vtdefs"], "op": ["bit", "Op", "cmp", "operator", "opt", "oop", " cop", "field", "loc", " prev", "omp", " Op", " dep", " comp", "top", "OP", "pre", "it", "type", "co", "cmd", "pop", "oper", " pos", "cop", "obj", "pos", " pat", " operator", "comp", "oe", "cp", " cp", " co", "arg", "x", "ip", "oc", "um", "cod", "operation", "info", " pop", " ip", "ops", "id", " fe", "ot", " clip", "ob", "iat", "jp", "o", " operation", "ok", "p", " expr", " chop", "gen", "pp", " hop", "ext", "num", "tag", "hop", "sp", "opp", "code", "ap", "mp", "pl", "init", "sc"], "def": ["tx", "pro", "vol", "Def", "vec", "Decl", "f", "and", "ref", "push", "det", "cond", "data", "cmd", "DE", "call", "lib", "dl", "req", "feat", "raw", "val", "task", "el", "du", "spec", "DEF", "eval", "pass", "diff", "buf", "ef", "func", "ds", "act", "desc", "nt", "definition", "da", "lit", "obj", "info", "range", "hd", "block", "decl", "db", "define", "df", "no", "die", "dev", "id", "feed", "dep", "de", "conf", "defined", "arg", "rel", "d", "list", "prop", "ma", "del", "init", "elf", "form"], "ct_str": ["ct_arr", "art_str", "ct___buf", "ct8stri", "het_STR", "ctolystr", "cent64syn", "artolystr", "ct7url", "ctvalstr", "ct7buf", "ctlpycur", "ct2Str", "ct7Str", "ct_char", "ct7str", "ct_enc", "ctmatn", "het_enc", "cent_syn", "CT_st", "het_n", "ct_coll", "captDef", "cent64str", "ctpystring", "ct_br", "ct_var", "het64string", "het_stream", "ct8syn", "ct_syn", "ctpyst", "het_string", "apt_tr", "ctolyurl", "ct64string", "ct7arr", "apt_string", "ct2arr", "artolyurl", "ctolyerr", "ct7err", "CT_str", "ct_st", "ctolycoll", "ct_tr", "het_part", "het_str", "actDef", "capt7buf", "ct___string", "ctl_string", "ct64stri", "ct_conv", "ctdef", "ctlpystring", "ct3string", "sectdef", "ct_stri", "ct2buf", "het7enc", "sectDef", "het64stream", "het_var", "CT_conv", "ct_STR", "ctpystr", "capt7str", "ctDef", "ctl_str", "artolyerr", "ctlpyst", "cent64string", "ct64str", "ct64syn", "capt_Str", "ct_n", "ct_seq", "CT_string", "CT_buf", "ct_part", "ct3buf", "ct3str", "ctvalstring", "ctvalst", "capt7Str", "art_err", "art_coll", "ctpycur", "capt_str", "actdef", "ct8string", "ct_cur", "ct_stream", "ctmatenc", "ct7enc", "het7str", "ct_url", "ct_buf", "ct___conv", "captdef", "het64str", "ct7n", "apt_str", "ct_err", "ct3conv", "ct64stream", "apt_exp", "ct7part", "capt7arr", "het64STR", "ct_string", "ct_Str", "cent_stri", "ct___str", "ct7coll", "capt_buf", "ct2str", "het7n", "ctl_cur", "cent64stri", "cent_str", "ctvalcur", "ctlpystr", "art_url", "CT_br", "ctmatstr", "artolycoll", "ct8str", "het_seq", "ctl_st", "ct_exp", "CT_char", "capt_arr", "ct64STR", "cent_string", "het7part", "ctmatpart"], "i": ["ij", "status", "index", "li", "go", "o", "iu", "ii", "mi", "I", "pi", "ini", "ind", "j", "ei", "n", "ki", "uri", "si", "ir", "zi", "p", "this", " ti", "cli", "v", "g", "bi", "batch", "io", "t", "is", "ui", "ik", "di", " ii", "ai", "m", "in", "hi", "s", "xi", "qi", "sim", "info", "im", "\u0438", "ci", "h", "ims", "id", "ti", "e", "point", "ri", "list", "it", "gi", "multi", "to", "me", "ji", "fi", "z", "phi", "x", "y", "ic", "ix", "ip"], "nb_args": ["nb_mus", "nb___args", "nb67arg", "nb_items", "nb_files", "NB2gs", "nb67items", "NB_arg", "nbJmus", "nb___items", "NB2files", "nb_gs", "nb_arg", "nb2arg", "NB_files", "nb2items", "no_items", "nbJitems", "no_mus", "NB_items", "nb___mus", "NB_args", "NB_gs", "no_args", "nb2files", "no_obs", "nb___obs", "nb_obs", "nb2args", "NB2arg", "nbJobs", "nbJargs", "nb2gs", "nb67args", "nb67gs", "NB2args"], "oarg": ["icoarn", "osargument", "aoarg", "autoass", "oaarr", "oiarg", "osref", "ovar", "offarg", "oedge", "boagg", "icoargument", "Oarg", "okey", "oskey", "oref", "icoarr", "oaarg", "osarg", "oargument", " oitem", "oarn", " oarm", "oarow", "poarg", "osarn", "osinc", "oavar", " oargument", "osedge", "aoinc", "offargument", " oArg", "oarm", "oivar", "pokey", "boarg", "Orow", " oarr", "osagg", " oag", "autoargument", "iarm", "Oargs", "oaedge", " oass", "oArg", "oainc", "oargs", "oakey", "aoref", "ooargument", "ooarc", "iarg", " ovar", "aoitem", "poargument", "ositem", "oinc", "osarr", "orow", "osArg", "oass", "oiarr", "oaag", "oaref", "boargument", "ooass", "osarm", "oag", "ooarg", " oarc", " orow", "boref", "poedge", "noarn", "noargument", "noarg", "oaargs", "icoarg", "iArg", "oitem", " oargs", "autoarc", "oaitem", "noarr", "offref", "autoarg", "oiitem", "oarr", "offagg", "oagg", "oaargument", "Oag", "iag", "oarc", "osag"]}}
{"project": "qemu", "commit_id": "06ac27f683c52890a6d174adba8c92354fa1eceb", "target": 1, "func": "void AUD_vlog (const char *cap, const char *fmt, va_list ap)\n\n{\n\n    if (conf.log_to_monitor) {\n\n        if (cap) {\n\n            monitor_printf(default_mon, \"%s: \", cap);\n\n        }\n\n\n\n        monitor_vprintf(default_mon, fmt, ap);\n\n    }\n\n    else {\n\n        if (cap) {\n\n            fprintf (stderr, \"%s: \", cap);\n\n        }\n\n\n\n        vfprintf (stderr, fmt, ap);\n\n    }\n\n}\n", "idx": 12347, "substitutes": {"cap": ["ce", "cu", "cf", "Cap", "co", "tc", "CAP", "attr", "cn", "map", "cmp", "cod", "feat", "card", "clip", "cas", "capt", "test", "sam", "can", "acc", "comm", "spec", "mac", "com", "cat", "cl", "ct", "cell", "broad", "snap", "rep", "sim", "ac", "ck", "sc", "san", "c", "caps", "pac", "car", "ctrl", "cp", "lat", "bc", "fac", "mp", "spe", "cont", "var", "ape", "lip", "shape", "pl", "ca", "pan", "tap", "ch"], "fmt": [" Ftm", "pprintf", "Firm", "vMT", "Fprintf", "pMT", "vmt", "fMT", "ftm", " Firm", "Fformat", " fMT", "vformat", "firm", " Fformat", " Fmt", " ftm", "Fmt", "pmt", "vtm", "fformat", "Ftm", "ptm", " fformat", " firm"], "ap": ["ipp", " map", "arp", "and", "array", "map", " sp", "p", "gap", "capt", "pool", "ar", " format", " app", "ab", " pc", " db", "op", "al", " heap", "snap", "att", "aps", "api", " op", "ac", "sp", "ep", "AP", "pac", " sap", "apt", " tap", " ab", " cp", "app", "list", "lip", " p", "ash", "ape", "ps", "bp", "hap", "pa", "tap", "rap", "ip"]}}
{"project": "FFmpeg", "commit_id": "59c6178a54c414fd19e064f0077d00b82a1eb812", "target": 0, "func": "static int ogg_build_flac_headers(const uint8_t *extradata, int extradata_size,\n\n                                  OGGStreamContext *oggstream, int bitexact)\n\n{\n\n    const char *vendor = bitexact ? \"ffmpeg\" : LIBAVFORMAT_IDENT;\n\n    uint8_t *p;\n\n    if (extradata_size != 34)\n\n        return -1;\n\n    oggstream->header_len[0] = 51;\n\n    oggstream->header[0] = av_mallocz(51); // per ogg flac specs\n\n    p = oggstream->header[0];\n\n    bytestream_put_byte(&p, 0x7F);\n\n    bytestream_put_buffer(&p, \"FLAC\", 4);\n\n    bytestream_put_byte(&p, 1); // major version\n\n    bytestream_put_byte(&p, 0); // minor version\n\n    bytestream_put_be16(&p, 1); // headers packets without this one\n\n    bytestream_put_buffer(&p, \"fLaC\", 4);\n\n    bytestream_put_byte(&p, 0x00); // streaminfo\n\n    bytestream_put_be24(&p, 34);\n\n    bytestream_put_buffer(&p, extradata, 34);\n\n    oggstream->header_len[1] = 1+3+4+strlen(vendor)+4;\n\n    oggstream->header[1] = av_mallocz(oggstream->header_len[1]);\n\n    p = oggstream->header[1];\n\n    bytestream_put_byte(&p, 0x84); // last metadata block and vorbis comment\n\n    bytestream_put_be24(&p, oggstream->header_len[1] - 4);\n\n    bytestream_put_le32(&p, strlen(vendor));\n\n    bytestream_put_buffer(&p, vendor, strlen(vendor));\n\n    bytestream_put_le32(&p, 0); // user comment list length\n\n    return 0;\n\n}\n", "idx": 12353, "substitutes": {"extradata": ["extredata", "extradova", "extradATA", "extrandatum", "extraratum", "xtracata", "extracata", "extravata", "extracada", "xtradata", "integradada", "extrandata", "integradatum", "integredATA", "extravATA", "integredata", "extrarova", "extravatum", "xtracova", "extredATA", "xtracATA", "extracatum", "integredatum", "integradATA", "extradada", "extredatum", "extracATA", "extrarATA", "extradatum", "xtradATA", "extravova", "xtradova", "xtradatum", "xtracatum", "extrandATA", "extredada", "integradata", "extracova", "extrandada", "integredada", "extrarata"], "extradata_size": ["extradata_Size", "extraddata_SIZE", "extraddata_Size", "extraddata_size", "extraddata_length", "extradata_SIZE", "extradata_length"], "oggstream": ["qusstream", "owwrapper", "owcontext", "voicestream", "ggproc", "awkstream", "oggconsole", "ogglog", "ggream", "qusream", "obbsystem", "awkcontext", "angdraw", "ggcollection", "qusdraw", "oggcontext", "livconsole", "angsystem", "obbstream", "obbwrapper", "ggload", "orbstream", "voicestyle", "livsocket", "qusStream", "bbdriver", "oglog", "ggconsole", "obbcollection", "ggstream", "voicesocket", "orbream", "ogstyle", "oggstyle", "anglog", "ggdriver", "gglog", "livstyle", "ogsocket", "ogstream", "obbdraw", "ggcontext", "bbcontext", "orbdraw", "oggproc", "oggwrapper", "aggstream", "awklog", "owstream", "obbcontext", "oggream", "bblog", "livstream", "angstream", "obbream", "ggStream", "ikStream", "voiceconsole", "ogcontext", "bbstream", "awkload", "oggsocket", "obblog", "ikream", "bbStream", "oggsystem", "agglog", "oggStream", "aggproc", "owream", "obbStream", "obbproc", "oggcollection", "oggdriver", "aggsystem", "ogload", "ggdraw", "oggdraw", "ogconsole", "obbdriver", "orbStream", "ggsystem", "ikstream", "bbconsole", "ikcollection", "oggload", "ggwrapper"], "bitexact": ["bitexACT", " bitexacts", "bitenexact", "biteexacts", "biteexact", "bitextACT", "bitextact", "bitexacts", "bitenexacts", "ibeexACT", " bitextACT", "ibeexacts", " bitexACT", "biteexACT", "ibexACT", "biterexract", "bitenexACT", "biterexacts", " bitexract", "biterexACT", "ibexacts", "bitextract", "biterexact", "bitextacts", "ibeexract", " bitextact", "ibexract", " bitextract", "bitexract", "ibexact", "ibeexact", "biteexract", " bitextacts", "bitenexract"], "vendor": ["vavor", "variavor", "invendor", "verendor", "invoter", "verender", "ivendor", "ivoter", "avian", "avender", "hendor", "vender", "envender", "ivocolate", "verirus", " virus", "avendor", "ivender", "variendor", "avoter", " vacio", "havor", "avirus", "veristor", " vian", "hacio", "ivian", "envendor", "invistor", "vistor", "vacio", "ivirus", "avistor", "vocolate", " vocolate", "vian", "voter", "ivistor", "variirus", "virus", "envistor", "variacio", "hirus", "avocolate", "invender", " vender", " vavor", "envirus"], "p": ["jp", "at", "f", "o", "pi", "l", "pb", "j", "n", "x", "pr", "params", "proc", "vp", "v", "dp", "g", "port", "pt", "t", "pp", "ping", "er", "np", "new", "P", "m", "php", "r", "br", "part", "rep", "parse", "progress", "self", "c", "up", "lp", "fp", "sp", "art", "pn", "ap", "wp", "cp", "b", "gp", "post", "h", "mp", "pc", "pers", "point", "pre", "pid", "it", "d", "prop", "ps", "q", "bp", "pkg", "i", "w", "tp", "y", "pa", "pe", "ip"]}}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void put_subframe(DCAEncContext *c, int subframe)\n\n{\n\n    int i, band, ss, ch;\n\n\n\n    /* Subsubframes count */\n\n    put_bits(&c->pb, 2, SUBSUBFRAMES -1);\n\n\n\n    /* Partial subsubframe sample count: dummy */\n\n    put_bits(&c->pb, 3, 0);\n\n\n\n    /* Prediction mode: no ADPCM, in each channel and subband */\n\n    for (ch = 0; ch < c->fullband_channels; ch++)\n\n        for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n            put_bits(&c->pb, 1, 0);\n\n\n\n    /* Prediction VQ address: not transmitted */\n\n    /* Bit allocation index */\n\n    for (ch = 0; ch < c->fullband_channels; ch++)\n\n        for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n            put_bits(&c->pb, 5, c->abits[band][ch]);\n\n\n\n    if (SUBSUBFRAMES > 1) {\n\n        /* Transition mode: none for each channel and subband */\n\n        for (ch = 0; ch < c->fullband_channels; ch++)\n\n            for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n                put_bits(&c->pb, 1, 0); /* codebook A4 */\n\n    }\n\n\n\n    /* Scale factors */\n\n    for (ch = 0; ch < c->fullband_channels; ch++)\n\n        for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n            put_bits(&c->pb, 7, c->scale_factor[band][ch]);\n\n\n\n    /* Joint subband scale factor codebook select: not transmitted */\n\n    /* Scale factors for joint subband coding: not transmitted */\n\n    /* Stereo down-mix coefficients: not transmitted */\n\n    /* Dynamic range coefficient: not transmitted */\n\n    /* Stde information CRC check word: not transmitted */\n\n    /* VQ encoded high frequency subbands: not transmitted */\n\n\n\n    /* LFE data: 8 samples and scalefactor */\n\n    if (c->lfe_channel) {\n\n        for (i = 0; i < DCA_LFE_SAMPLES; i++)\n\n            put_bits(&c->pb, 8, quantize_value(c->downsampled_lfe[i], c->lfe_quant) & 0xff);\n\n        put_bits(&c->pb, 8, c->lfe_scale_factor);\n\n    }\n\n\n\n    /* Audio data (subsubframes) */\n\n    for (ss = 0; ss < SUBSUBFRAMES ; ss++)\n\n        for (ch = 0; ch < c->fullband_channels; ch++)\n\n            for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n                    put_subframe_samples(c, ss, band, ch);\n\n\n\n    /* DSYNC */\n\n    put_bits(&c->pb, 16, 0xffff);\n\n}\n", "idx": 12357, "substitutes": {"c": ["rc", "cu", "ce", "cf", "co", "tc", "f", "oc", "cr", "cm", "cur", "cn", "lc", "ctx", "p", "this", "call", "cod", "cc", "cd", "conv", "v", "chain", "t", "comm", "ic", "com", "dc", "cache", "ct", "cl", "cam", "sc", "ac", "C", "self", "cb", "cv", "xc", "cal", "nc", "abc", "ci", "ec", "content", "comp", "cp", "gc", "mc", "cs", "bc", "etc", "pc", "fc", "rec", "e", "con", "conf", "enc", "d", "config", "err", "vc", "ca", "coll", "cont", "anc"], "subframe": ["firstFrame", "Subframes", "subframes", " subframes", "firstframe", "Subpixel", "subpixel", "firstframes", " subFrame", "SubFrame", "Subframe", " subpixel", "firstpixel", "subFrame"], "i": ["ij", "li", "ni", "iu", "o", "oi", "ii", " j", "I", "pi", "ind", "ini", "j", "mi", "p", "n", "ki", "si", "ei", "zi", "v", "cli", "chain", "io", "is", "iq", "ui", "di", "ami", " ii", "PI", "ai", "m", "in", "hi", "xi", "qi", "\u0438", "ci", "b", "ish", "ti", "e", "ri", "u", "multi", "gi", "it", "phi", "x", "y", "ic", "ix", "ip"], "band": ["bit", "path", "and", "display", "back", "low", "ng", "port", "field", "nd", "den", "st", "command", "line", "ann", "channel", "ud", "word", "lag", "ble", "bd", "mm", "art", "binary", "length", "net", "filter", "type", "by", "beam", "ind", "cmd", "j", "kt", "group", "sch", "bus", "br", "power", "dd", "part", "chrom", "iff", "db", "link", "bind", "slice", "chan", "pair", "gain", "x", "key", "be", "f", "rad", "boot", "batch", "bo", "bat", " Band", "di", "dom", "disk", "brand", "broad", "slot", "work", "bolt", "stage", "block", "uch", "plot", "bed", "d", "bound", "bar", "light", "cm", "mode", "cd", "chain", "io", "pp", "mid", "Band", "bin", "bart", "tag", "through", "range", "bridge", "lay", "sp", "bright", "no", "b", "point", "prop", "way"], "ss": ["tx", "ress", "sw", "serv", "bs", "socket", "ness", "rss", "ys", "tt", "si", "sq", "css", "ms", "ng", "nd", "ass", "sv", "st", "sys", "pse", "ds", "sch", "dd", "iss", "s", "ess", "oss", "mys", "ts", "sp", "mm", "stats", "sex", "ns", "cs", "ser", "sd", "se", "hess", "sat", "sn", "us", "sc", "rs", "SS", "ps"], "ch": ["bit", "cor", "cr", "conn", "et", "cht", "hr", "mk", "chip", "not", "tch", "command", "ich", "ann", "channel", "att", "ble", "arch", "cb", "sh", "ht", "client", "cho", "ka", "rem", "qu", "ph", "ind", "high", "j", "or", "yet", "chron", "CH", "sch", "br", "th", "chrom", "cp", "chan", "any", "hl", "vc", "cz", "chn", "zh", "history", "be", "wh", "kh", "ver", "strong", "cc", "che", "height", "batch", "ctr", "bat", "uch", "ci", "ech", "ach", "Ch", "ot", "err", "bal", "gh", "cm", "itch", "mot", "cd", "chain", "el", "atch", "ct", "cl", "through", "ck", "count", "cgi", "h", "och", "col", "sky", "watch", "q", "sc", "y", "can"]}}
{"project": "FFmpeg", "commit_id": "11b47038135442ec546dc348f2411e52e47549b8", "target": 0, "func": "static void decode_gray_bitstream(HYuvContext *s, int count)\n\n{\n\n    int i;\n\n\n\n    count/=2;\n\n\n\n    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {\n\n        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    } else {\n\n        for(i=0; i<count; i++){\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    }\n\n}\n", "idx": 12362, "substitutes": {"s": ["comments", "aws", "ses", "gs", "a", "S", "as", "bs", "less", "session", "p", "js", "n", "sq", "v", "g", "ms", "sam", "t", "comm", "is", "sb", "sv", "als", "hs", "sys", "ds", "ls", "ats", "times", "erences", "r", "ess", "qs", "ts", "c", "stats", "vs", "ins", "b", "ns", "cs", "h", "ims", "e", "changes", "events", "fs", "os", "bis", "aunts", "its", "parts", "ss", "w", "sts", "rs"], "count": ["index", "amount", "type", "scroll", "mount", "number", "size", "ind", "n", "body", "cc", "hold", "check", "counter", "batch", "ctr", "t", "len", "cache", "common", "result", "now", "num", "ct", "nt", "th", "ount", "current", "range", "empty", "c", "buffer", "page", "all", "code", "limit", "more", "b", "h", "found", "any", "conf", "max", "length", "total", "list", "nb", "z", "Count", "bound", "cast", "ch", "sum"], "i": ["index", "series", "cli", "t", " pi", "ami", "ai", "m", "php", "xi", "qi", "client", "docker", "ims", "my", "it", "ji", "li", "oi", "ind", "j", "n", "ki", "si", "zi", " ti", "v", "ui", "iq", " index", " bi", "im", "print", "ti", "x", "ri", "ic", "ix", "ip", "ij", "key", "at", "um", "ii", "mi", "I", "pi", "uni", "this", "batch", "di", " ii", "in", "sim", "c", "ci", "iter", "multi", "to", "me", "token", "status", "sql", "ni", "iu", "ski", " j", "ini", "ei", "l", "uri", "p", "chain", "bi", "hi", "\u0438", "page", "e", "point", "gi", " m", "phi", "init", "y"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static int start_auth_vencrypt_subauth(VncState *vs)\n\n{\n\n    switch (vs->vd->subauth) {\n\n    case VNC_AUTH_VENCRYPT_TLSNONE:\n\n    case VNC_AUTH_VENCRYPT_X509NONE:\n\n       VNC_DEBUG(\"Accept TLS auth none\\n\");\n\n       vnc_write_u32(vs, 0); /* Accept auth completion */\n\n       vnc_read_when(vs, protocol_client_init, 1);\n\n       break;\n\n\n\n    case VNC_AUTH_VENCRYPT_TLSVNC:\n\n    case VNC_AUTH_VENCRYPT_X509VNC:\n\n       VNC_DEBUG(\"Start TLS auth VNC\\n\");\n\n       return start_auth_vnc(vs);\n\n\n\n    default: /* Should not be possible, but just in case */\n\n       VNC_DEBUG(\"Reject auth %d\\n\", vs->vd->auth);\n\n       vnc_write_u8(vs, 1);\n\n       if (vs->minor >= 8) {\n\n           static const char err[] = \"Unsupported authentication type\";\n\n           vnc_write_u32(vs, sizeof(err));\n\n           vnc_write(vs, err, sizeof(err));\n\n       }\n\n       vnc_client_error(vs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12365, "substitutes": {"vs": ["ses", "vv", "gs", "obs", "bs", "ports", "outs", "lines", "ys", "values", "hz", "js", "bits", "vr", "mr", "vp", "blogs", "v", "xs", "lists", "eps", "nets", "Vs", "is", "sv", "wcs", "sys", "hs", "ds", "ls", "docs", "heads", "obj", "atts", "vm", "qs", "vals", "ads", "ts", "inv", "otes", "ins", "ns", "ops", "cs", "lv", "lbs", "ims", "es", "changes", "fs", "ks", "qv", "its", "vd", "views", "vc", "vt", "bp", "sts", "ss", "ms", "checks", "VS", "rs", "ps"], "err": ["resp", "errors", "rc", "error", "cr", "ptr", "out", "exc", "lr", "usr", "attr", "data", "pr", "cmd", "addr", "str", "mr", "body", "aaa", "ocr", "erd", "v", "t", "er", "msg", "result", "buf", "sys", "br", "Error", "r", "kr", "fee", "html", "lp", "res", "die", "der", "Er", "h", "fr", "e", "it", "gz", "rr", "txt", "ch", "arr"]}}
{"project": "qemu", "commit_id": "1dde716ed6719c341c1bfa427781f0715af90cbc", "target": 0, "func": "iscsi_unmap_cb(struct iscsi_context *iscsi, int status,\n\n                     void *command_data, void *opaque)\n\n{\n\n    IscsiAIOCB *acb = opaque;\n\n\n\n    if (acb->canceled != 0) {\n\n        return;\n\n    }\n\n\n\n    acb->status = 0;\n\n    if (status < 0) {\n\n        error_report(\"Failed to unmap data on iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        acb->status = -EIO;\n\n    }\n\n\n\n    iscsi_schedule_bh(acb);\n\n}\n", "idx": 12367, "substitutes": {"iscsi": ["isksi", "scdi", "scsc", "uscdi", "uscsim", "scsie", "isksie", "isksim", "ircsc", "uscsc", "iscsim", "uscsie", "uscsi", "ircsie", "ircsi", "iscdi", "iscsc", "ircdi", "scsi", "ircsim", "iscsie", "isksc"], "acb": [" acr", "rcb", " lacba", " accb", " cacb", "akba", "ocsb", "akbb", "ocb", "aksb", "ancsb", " acfb", "ambb", "accn", "abba", "saccb", "ancbb", "amb", "sacb", " acrb", "amrb", "ocba", "accfb", "acccb", "abb", " acbd", " cacbar", "ancba", "amfb", "ocbar", "ocbd", "acsb", " lacbar", "acrb", "acbb", " acsb", "acbar", "sacr", " laccb", "accr", " acn", "akb", "ocrb", "absb", "ancb", "acn", "accb", "sacn", "rcbd", " caccb", "accbb", "occb", " lacb", "rcrb", "acbd", "acr", "rcsb", "abbb", " acbb", "accrb", "acba", "acfb", " cacba"]}}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "static void virtio_notify(struct subchannel_id schid)\n\n{\n\n    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);\n\n}\n", "idx": 12376, "substitutes": {"schid": ["chId", " schname", "chpid", "Schname", "schpid", " schoid", "schname", "choid", "chname", "khname", "khoid", "SchId", "schId", "schoid", "Schoid", "khid", " schId", "Schid", "khpid", "chid", "Schpid"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)\n\n{\n\n    struct kvm_x86_mce mce = {\n\n        .bank = 9,\n\n        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN\n\n                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S\n\n                  | 0xc0,\n\n        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,\n\n        .addr = paddr,\n\n        .misc = (MCM_ADDR_PHYS << 6) | 0xc,\n\n    };\n\n\n\n    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);\n\n    kvm_mce_broadcast_rest(env);\n\n}\n", "idx": 12377, "substitutes": {"env": ["server", "ce", "nv", "conn", "environment", "scope", "ctx", "hw", "window", "erd", "proc", "req", "vp", "v", "esc", "engine", "er", "buf", "sv", "stack", "ef", "sb", "end", "m", "ah", "context", "ew", " environment", "obj", "shell", "vm", "buffer", "cv", "en", "ec", "vs", "dev", "h", "e", "conf", "entry", "enter", "uv", "ev", "vt", "w", "gear", "te", "viron", "gov", "pe"], "paddr": ["taddr", "tptr", "parp", " pptr", "pres", " Padd", "padd", "bparp", "paddress", " Pres", " paddress", "bpaddr", " pres", "bpptr", "bpattr", " parp", "pptr", "Padd", "pattr", "tarp", " padd", " Paddr", "Paddress", "Pres", "tattr", "Paddr", " Paddress", " pattr"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lm32_evr_init(QEMUMachineInitArgs *args)\n\n{\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    LM32CPU *cpu;\n\n    CPULM32State *env;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem =  get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq *cpu_irq, irq[32];\n\n    ResetInfo *reset_info;\n\n    int i;\n\n\n\n    /* memory map */\n\n    target_phys_addr_t flash_base  = 0x04000000;\n\n    size_t flash_sector_size       = 256 * 1024;\n\n    size_t flash_size              = 32 * 1024 * 1024;\n\n    target_phys_addr_t ram_base    = 0x08000000;\n\n    size_t ram_size                = 64 * 1024 * 1024;\n\n    target_phys_addr_t timer0_base = 0x80002000;\n\n    target_phys_addr_t uart0_base  = 0x80006000;\n\n    target_phys_addr_t timer1_base = 0x8000a000;\n\n    int uart0_irq                  = 0;\n\n    int timer0_irq                 = 1;\n\n    int timer1_irq                 = 3;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetInfo));\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"lm32-full\";\n\n    }\n\n    cpu = cpu_lm32_init(cpu_model);\n\n    env = &cpu->env;\n\n    reset_info->cpu = cpu;\n\n\n\n    reset_info->flash_base = flash_base;\n\n\n\n    memory_region_init_ram(phys_ram, \"lm32_evr.sdram\", ram_size);\n\n    vmstate_register_ram_global(phys_ram);\n\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    /* Spansion S29NS128P */\n\n    pflash_cfi02_register(flash_base, NULL, \"lm32_evr.flash\", flash_size,\n\n                          dinfo ? dinfo->bdrv : NULL, flash_sector_size,\n\n                          flash_size / flash_sector_size, 1, 2,\n\n                          0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    /* create irq lines */\n\n    cpu_irq = qemu_allocate_irqs(cpu_irq_handler, env, 1);\n\n    env->pic_state = lm32_pic_init(*cpu_irq);\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    sysbus_create_simple(\"lm32-uart\", uart0_base, irq[uart0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n\n\n    /* make sure juart isn't the first chardev */\n\n    env->juart_state = lm32_juart_init();\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, ELF_MACHINE, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n", "idx": 12378, "substitutes": {"args": ["aws", "gs", "roots", "settings", "units", "cmd", "ctx", "flags", "js", "bits", "params", "ags", "ams", "limits", "words", "authors", "arms", "comm", "apps", "points", "lang", "checks", "eds", "aps", "doc", "atts", "vals", "ts", "ars", "yes", "ians", "ns", "Args", "cs", "ras", "amps", "fs", "locks", "arg", "GS", "parts", "ants", "GV", "objects", "ms", "actions", "arr"], "cpu_model": ["pu_mode", "pu_model", "cpu_link", "cpu__model", "cpujdomain", "cpu_brand", "cpuptmode", "pu_type", "cpujmode", "cpu_domain", "cpu_mode", "processor_filename", "cpu_filename", "cpu_package", "processor_mode", "cpuptgrid", "cpu_grid", "processor_model", "cpu_type", "processor_package", "cpu_models", "cpu__type", "cpu_file", "pu_file", "pu_link", "cpu_name", "pu_models", "cpujmodel", "pu_move", "cpu__models", "pu_brand", "cpuptmodel", "pu_domain", "cpuptmove", "pu_name", "cpu__name", "cpu_move", "pu_grid", "cpujlink"], "kernel_filename": ["kernel___maximum", "kernelacmode", "kernelacfile", "networkacfilename", "kernel_package", "kernel___filename", "kernelpofilename", "networkacfile", "ernel_maximum", "network_name", "kernel_name", "networkacname", "kernel_mode", "kernelacfilename", "kernel___file", "kernelacname", "network_mode", "ernel_package", "network_file", "network_filename", "kernel_file", "kernelpomaximum", "kernel_maximum", "ernel_filename", "networkacmode", "kernelpopackage", "kernelpofile", "kernel___package", "ernel_file"], "cpu": ["node", "cu", "pu", "CPU", "mem", "conn", "phys", "cn", "hog", "core", "p", "ctx", "hw", "cmd", "linux", "proc", "stat", "cli", "boot", "chip", "frame", "aco", "mac", "cache", "np", "sys", "processor", "cam", "lock", "bench", "ota", "uu", "context", "memory", "obj", "pai", "vm", "mu", "physical", "arch", "cv", "base", "ka", "cum", "gc", "cp", "gp", "pc", "gpu", "os", "prof", "tp", "net", "target", "pkg", "home", "init", "process", "ce", "nu", "clock"], "env": ["server", "nv", "mem", "conn", "environment", "map", "ctx", "core", "window", "vert", "v", "except", "den", "er", "priv", "buf", "np", "em", "ef", "ext", "ework", "disk", "context", "ern", "vm", "org", "en", "ec", "vs", "egg", "dev", "e", "eas", "conf", "enc", "Environment", "state", "config", "eng", "net", "uv", "ve", "world", "ev", "vt", "iv", "gear", "init", "mn", "viron", "equ"], "dinfo": ["dInfo", "dnfo", " dfo", "rinformation", "dsinformation", "ddfo", "dsinfo", "dinformation", "linfo", "dbinformation", "dbfo", "dtype", "linformation", " dstate", "rinfo", "lfo", "dninfo", "dsinf", "dbinf", "bdinformation", "lInfo", "dnInfo", "dbinfo", " dtype", "bdinf", "dntype", " dinf", "rInfo", "dstate", "ddinformation", " dInfo", " dinformation", "dninformation", "dninf", "bdinfo", "rtype", "dsstate", "dfo", "ddinfo", "dinf", "bdstate", "ddInfo"], "address_space_mem": ["address_system_memory", "address_Space_memory", "address_space_ram", "address_system_ram", "address_space_memory", "address_Space_mem", "address_Space_ram", "address_system_mem"], "phys_ram": ["phy_ram", "phys_rb", "phys_rom", " phys_rom", "physical_cam", " phys_memory", "phys2ram", "phy_mem", "physical_ram", "phys_cam", "phys2gram", "phys_memory", "phys2memory", "physical_rom", "phy_gram", "phy_rb", " phys_mem", "phys_mem", "phys2mem", "physical_mem", "phys_gram", "phy_memory", "phy_rom"], "cpu_irq": ["cpu_iterqs", "cpu_irquire", "cpu_irequire", "cpu_ireqs", "cpu_pirq", "cpu_pirquire", "cpu_irqs", "cpu_pirqs", "cpu_iterq", "cpu_iterquire", "cpu_irQ", "cpu_ireQ", "cpu_iterQ", "cpu_pirQ", "cpu_ireq"], "irq": ["iriqs", "irqu", " irqs", "pirqu", " irqq", " irqu", "iriq", "irqs", "iriqq", "pirq", "pirqq", "irqq", "iriqu", "pirqs"], "reset_info": ["resetgrdata", "reset___event", "hardPrevent", "reset_data", "reset___data", "resetgrevent", "resetPrreport", "reset_Info", "reset_report", "resetallInfo", "resetPrinfo", "resetgrfo", "reset_event", "repair_information", "hardPrInfo", "report_info", "hardPrinfo", "repair_info", "report_event", "hardPrreport", "repair_init", "resetPrInfo", "resetgrinfo", "report___data", "reset_init", "resetallreport", "resetallevent", "reset___fo", "reset_information", "hard_event", "hard_report", "reset_type", "resettinit", " reset_information", "resettinformation", "report_fo", "report___info", "resetPrevent", "hard_Info", "report_data", "reset_fo", "resettinfo", "report___event", "report___fo", "hard_info", " reset_type", "reset___info", "resetallinfo"], "i": ["a", "f", "iu", "o", "ii", " j", "I", "ei", "j", "l", "p", "n", "si", "v", "io", "t", "ia", " ii", "m", "ie", " bi", " v", "id", "set", "e", "z", "ta", "ip"]}}
{"project": "qemu", "commit_id": "075a1fe788d36b271ec25507466c30b9a90b5d54", "target": 0, "func": "static void gen_msa_branch(CPUMIPSState *env, DisasContext *ctx, uint32_t op1)\n\n{\n\n    uint8_t df = (ctx->opcode >> 21) & 0x3;\n\n    uint8_t wt = (ctx->opcode >> 16) & 0x1f;\n\n    int64_t s16 = (int16_t)ctx->opcode;\n\n\n\n    check_msa_access(ctx);\n\n\n\n    if (ctx->insn_flags & ISA_MIPS32R6 && ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        generate_exception_end(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n    switch (op1) {\n\n    case OPC_BZ_V:\n\n    case OPC_BNZ_V:\n\n        {\n\n            TCGv_i64 t0 = tcg_temp_new_i64();\n\n            tcg_gen_or_i64(t0, msa_wr_d[wt<<1], msa_wr_d[(wt<<1)+1]);\n\n            tcg_gen_setcondi_i64((op1 == OPC_BZ_V) ?\n\n                    TCG_COND_EQ : TCG_COND_NE, t0, t0, 0);\n\n            tcg_gen_trunc_i64_tl(bcond, t0);\n\n            tcg_temp_free_i64(t0);\n\n        }\n\n        break;\n\n    case OPC_BZ_B:\n\n    case OPC_BZ_H:\n\n    case OPC_BZ_W:\n\n    case OPC_BZ_D:\n\n        gen_check_zero_element(bcond, df, wt);\n\n        break;\n\n    case OPC_BNZ_B:\n\n    case OPC_BNZ_H:\n\n    case OPC_BNZ_W:\n\n    case OPC_BNZ_D:\n\n        gen_check_zero_element(bcond, df, wt);\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, bcond, bcond, 0);\n\n        break;\n\n    }\n\n\n\n    ctx->btarget = ctx->pc + (s16 << 2) + 4;\n\n\n\n    ctx->hflags |= MIPS_HFLAG_BC;\n\n    ctx->hflags |= MIPS_HFLAG_BDS32;\n\n}\n", "idx": 12383, "substitutes": {"env": ["sw", "ptr", "environment", "cur", "setup", "ei", "map", "scope", "hw", "ee", "test", "st", "buf", "obj", "en", "ec", "sh", "dev", "tmp", "e", "ev", "pkg", "init", "sc", "te", "viron", "txt", "pe"], "ctx": ["index", "conn", "hw", "cmp", "cas", "loc", "nt", "context", "kb", "cb", "xc", "pkg", "exec", "ka", "tx", "kw", "ctl", "qu", "unc", "ptr", "wx", "setup", "lc", "addr", "cmd", "warn", "crit", "kt", "xp", "cfg", "obj", "nc", "cp", "gc", "mc", "ctrl", "Context", "tmp", "conf", "x", "ca", "txt", "resp", "cf", "asm", "utils", "this", "cc", "req", "tk", "xs", "sys", "np", "cpu", "ork", "work", "cv", "mom", "bc", "config", "px", "tm", "alloc", "iat", "jac", "jp", "cu", "tc", "cm", "util", "msg", "func", "ct", "act", "ck", "parse", "sp", "sc", "anc"], "op1": ["OP2", "hopOne", "OPOne", "op01", " opt0", "hop1", "oper7", "hop01", "oper2", "top1", " opt2", "oper0", "OP1", "OP7", "hop2", " opt1", "op7", "top2", "Op2", "top7", "op3", "Op3", "op0", "OP01", "top0", " op2", "OP0", "oper1", " opOne", "opOne", " op3", " op0", " opt3", " op01", "Op0", "Op1", "op2"]}}
{"project": "qemu", "commit_id": "65c0f1e9558c7c762cdb333406243fff1d687117", "target": 0, "func": "static QObject *parse_keyword(JSONParserContext *ctxt, QList **tokens)\n\n{\n\n    QObject *token, *ret;\n\n    QList *working = qlist_copy(*tokens);\n\n\n\n    token = qlist_pop(working);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(token) != JSON_KEYWORD) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_keyword(token, \"true\")) {\n\n        ret = QOBJECT(qbool_from_int(true));\n\n    } else if (token_is_keyword(token, \"false\")) {\n\n        ret = QOBJECT(qbool_from_int(false));\n\n    } else {\n\n        parse_error(ctxt, token, \"invalid keyword `%s'\", token_get_value(token));\n\n        goto out;\n\n    }\n\n\n\n    qobject_decref(token);\n\n    QDECREF(*tokens);\n\n    *tokens = working;\n\n\n\n    return ret;\n\n\n\nout: \n\n    qobject_decref(token);\n\n    QDECREF(working);\n\n\n\n    return NULL;\n\n}\n", "idx": 12384, "substitutes": {"ctxt": ["cttxt", "ctxtx", "ctxtxt", "ecttx", "curxt", "ecttxt", "ctert", "curert", "CTert", "curtxt", "ectert", "CTtx", "CTxt", "CTld", "curld", "ctxxt", "ectxt", "ctld", "ctxld", "CTtxt", "curtx", "cttx"], "tokens": ["topentials", "toyenes", "targened", "fokenotypes", "stokets", "wargets", "fokenens", "stokens", "stopentials", "stopkens", "fokenened", "wokets", "tokenotypes", "tocets", "wokens", "toyotypes", "stokentials", "wokened", "wokkens", "toyened", "toksenes", "fokenenes", "toyens", "fokenes", "stopets", "stokents", "wargens", "stopens", "stopened", "targets", "toksotypes", "targents", "topkens", "fokotypes", "tokenens", "tokkens", "topents", "toksened", "tocents", "todens", "fokened", "topened", "tokotypes", "tokenes", "tocened", "stopents", "tokenenes", "topens", "wargened", "fokens", "tockens", "todentials", "toksets", "toksens", "toksentials", "targkens", "tokentials", "stokkens", "tokenened", "tokents", "todkens", "tokened", "stokened", "tokskens", "targens", "wargkens", "todets", "tokets", "topets", "tocens"], "token": ["header", "operator", "typ", "field", "t", "oken", "KEN", "result", "processor", "context", "channel", "word", "attribute", "document", "start", "prototype", "character", "termin", "normal", "error", "type", "number", "object", "data", "training", "resource", "reset", "next", "initial", "spec", "note", "iterator", "forward", "tool", "null", "table", "term", "pair", "tar", "target", "span", "txt", "complete", "atom", "node", "key", "row", "temp", "tk", "trigger", "batch", "source", "parser", "scan", "operation", "json", "tower", "info", "buffer", "variable", "single", "language", "status", "o", "local", "ski", "session", "handle", "ok", "p", "rule", "statement", "Token", "tn", "item", "tree", "tag", "message", "none", "tf", "event", "twitter", "piece", "component", "final", "value", "false", "template"], "ret": ["jp", "rem", "def", "mem", "out", "ref", "pret", "bool", "ll", "det", " RET", "j", "cmd", "Ret", "tr", "rets", "RET", "val", "reg", "try", "t", "ert", "rm", "result", "cat", "nt", "rest", "r", "lit", "gt", "alt", "obj", "att", "rt", "unt", "rot", "lt", "ry", "res", "print", "flag", "re", "tmp", "mt", "rel", "repl", "ft", "it", "elt", "uf", "mb", "pas", " Ret", "txt", "arr"], "working": ["tx", "ordering", "border", "global", "ring", "starting", "ki", "getting", "ing", "depending", "existing", "pool", "going", "processing", "padding", "standing", "workers", "loading", "being", "changing", "ending", "packing", "based", "work", "including", "moving", "watching", "locking", "looking", "saving", "acting", "tmp", "worked", "opening", "works", "wild", "checking", "picking", "Working", "walking", "calling", "running", "using", "playing", "joining", "testing", "worker"]}}
{"project": "FFmpeg", "commit_id": "892bbbcdc171ff0d08d69636a240ffb95f54243c", "target": 0, "func": "static av_cold int vaapi_encode_config_attributes(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext *ctx = avctx->priv_data;\n\n    VAStatus vas;\n\n    int i, n, err;\n\n    VAProfile    *profiles    = NULL;\n\n    VAEntrypoint *entrypoints = NULL;\n\n    VAConfigAttrib attr[] = {\n\n        { VAConfigAttribRTFormat        },\n\n        { VAConfigAttribRateControl     },\n\n        { VAConfigAttribEncMaxRefFrames },\n\n    };\n\n\n\n    n = vaMaxNumProfiles(ctx->hwctx->display);\n\n    profiles = av_malloc_array(n, sizeof(VAProfile));\n\n    if (!profiles) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    vas = vaQueryConfigProfiles(ctx->hwctx->display, profiles, &n);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Failed to query profiles: %d (%s).\\n\",\n\n               vas, vaErrorStr(vas));\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n    for (i = 0; i < n; i++) {\n\n        if (profiles[i] == ctx->va_profile)\n\n            break;\n\n    }\n\n    if (i >= n) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Encoding profile not found (%d).\\n\",\n\n               ctx->va_profile);\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n\n\n    n = vaMaxNumEntrypoints(ctx->hwctx->display);\n\n    entrypoints = av_malloc_array(n, sizeof(VAEntrypoint));\n\n    if (!entrypoints) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    vas = vaQueryConfigEntrypoints(ctx->hwctx->display, ctx->va_profile,\n\n                                   entrypoints, &n);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Failed to query entrypoints for \"\n\n               \"profile %u: %d (%s).\\n\", ctx->va_profile,\n\n               vas, vaErrorStr(vas));\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n    for (i = 0; i < n; i++) {\n\n        if (entrypoints[i] == ctx->va_entrypoint)\n\n            break;\n\n    }\n\n    if (i >= n) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Encoding entrypoint not found \"\n\n               \"(%d / %d).\\n\", ctx->va_profile, ctx->va_entrypoint);\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n\n\n    vas = vaGetConfigAttributes(ctx->hwctx->display,\n\n                                ctx->va_profile, ctx->va_entrypoint,\n\n                                attr, FF_ARRAY_ELEMS(attr));\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to fetch config \"\n\n               \"attributes: %d (%s).\\n\", vas, vaErrorStr(vas));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(attr); i++) {\n\n        if (attr[i].value == VA_ATTRIB_NOT_SUPPORTED) {\n\n            // Unfortunately we have to treat this as \"don't know\" and hope\n\n            // for the best, because the Intel MJPEG encoder returns this\n\n            // for all the interesting attributes.\n\n            continue;\n\n        }\n\n        switch (attr[i].type) {\n\n        case VAConfigAttribRTFormat:\n\n            if (!(ctx->va_rt_format & attr[i].value)) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Surface RT format %#x \"\n\n                       \"is not supported (mask %#x).\\n\",\n\n                       ctx->va_rt_format, attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            ctx->config_attributes[ctx->nb_config_attributes++] =\n\n                (VAConfigAttrib) {\n\n                .type  = VAConfigAttribRTFormat,\n\n                .value = ctx->va_rt_format,\n\n            };\n\n            break;\n\n        case VAConfigAttribRateControl:\n\n            if (!(ctx->va_rc_mode & attr[i].value)) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Rate control mode %#x \"\n\n                       \"is not supported (mask: %#x).\\n\",\n\n                       ctx->va_rc_mode, attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            ctx->config_attributes[ctx->nb_config_attributes++] =\n\n                (VAConfigAttrib) {\n\n                .type  = VAConfigAttribRateControl,\n\n                .value = ctx->va_rc_mode,\n\n            };\n\n            break;\n\n        case VAConfigAttribEncMaxRefFrames:\n\n        {\n\n            unsigned int ref_l0 = attr[i].value & 0xffff;\n\n            unsigned int ref_l1 = (attr[i].value >> 16) & 0xffff;\n\n\n\n            if (avctx->gop_size > 1 && ref_l0 < 1) {\n\n                av_log(avctx, AV_LOG_ERROR, \"P frames are not \"\n\n                       \"supported (%#x).\\n\", attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            if (avctx->max_b_frames > 0 && ref_l1 < 1) {\n\n                av_log(avctx, AV_LOG_ERROR, \"B frames are not \"\n\n                       \"supported (%#x).\\n\", attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n        }\n\n        break;\n\n        default:\n\n            av_assert0(0 && \"Unexpected config attribute.\");\n\n        }\n\n    }\n\n\n\n    err = 0;\n\nfail:\n\n    av_freep(&profiles);\n\n    av_freep(&entrypoints);\n\n    return err;\n\n}\n", "idx": 12395, "substitutes": {"avctx": ["avtx", "avcmp", "vactx", "AVcontext", "AVctx", "avcontext", "avdc", "cvcontext", " avdc", "AVcmp", " avtx", "hwctx", "vadc", "hwcmp", "AVtx", "vacontext", "hwcontext", " avcmp", "vatx", " avcontext", "cvdc", "hwtx", "cvctx", "cvtx"], "ctx": ["td", "github", "conn", "cmp", "typ", "cas", "check", "nt", "context", "cb", "xc", "abc", "fn", "wordpress", "pkg", "ka", "tx", "kw", "ctl", "def", "unc", "wx", "lc", "addr", "cmd", "ind", "kt", "timeout", "conv", "comm", "xp", "wcs", "cfg", "obj", "cpp", "nc", "comp", "cp", "gc", "pg", "ppo", "tmp", " cp", "txt", "resp", "cf", "pause", " context", "cn", "cc", "req", "proc", "tk", "xs", "np", "fx", "qa", "work", " cx", "cv", "kl", "wd", "lex", "bc", "etc", "pc", "config", "px", "tm", "iat", "jac", "jp", "cu", "tc", "cm", "grad", "pt", "func", "ct", "act", "cl", "desc", "prefix", "ck", "that", "gz", "inst", "anc"], "vas": ["cats", "browser", "gs", "cape", " vis", "ports", " cu", "pres", "aaa", " vac", "cas", "vers", " canvas", "wiki", "caps", "mas", "vs", "van", "docker", "cs", "ims", "draw", "las", " tv", "us", "jpg", "ps", "cus", " oval", "js", "aka", " vantage", "conv", "css", "pages", "kit", "box", "vis", "wcs", " va", " cs", " vers", "boxes", "gc", "scale", "nas", "mouse", "VS", "txt", "nexus", "paste", " sav", "as", "um", "VA", "als", "aus", "buf", "uses", "vid", "ja", "vals", "stage", "va", "ras", " vo", "eas", "na", "jac", "jp", "cu", "quer", "roots", "rus", "png", "vre", "jas", " aval", "cache", "BA", "cam", "axe", " ans", "bridge", "ts", " cac", "ns", " canv", " Vas", "pas", "sts", " stats"], "i": ["index", "dr", "cli", "gu", "t", "ami", "ai", "m", " I", "xi", "qi", "ims", "it", "ji", "us", "li", "by", "oi", "ind", "j", "ki", "si", "zi", " ti", "v", "ori", "g", "ui", "iq", "iii", " bi", "im", "ti", "x", "ri", "ix", "ip", "ij", "ii", "mi", "I", "pi", "this", "di", " ii", "in", "ie", "sim", "info", "ci", " ni", "u", "multi", "to", "me", "ni", "iu", "ski", " j", "ini", "ei", "p", "bi", "io", "is", "eu", "hi", "\u0438", "cgi", "e", "gi", "q", "phi", "init", "y"], "n": ["nv", "nl", "ni", "nos", "nor", "conn", "number", "o", "out", "dn", "cn", "size", "ll", "ren", "l", "ln", "j", "p", "names", "v", "g", "ng", " N", "na", "len", "t", "nets", "np", "num", "nr", "nt", "m", "N", "y", "norm", "gn", "c", "all", "nc", "en", "mn", "fn", "pn", "pos", "no", "on", "ns", "un", "nas", "any", "non", "d", "to", "nb", "ne", "z", "nia", "net", "sn", "nan", "w", "nm", "rn", "an", "nu", "nn"], "err": ["resp", "notice", "error", "cr", "ptr", "erer", "late", "lr", "usr", "pr", "ei", "hz", "aaa", "mr", "dr", "req", "typ", "dt", "css", "cli", "try", "rr", "er", "msg", "buf", "rb", "br", "cfg", "kr", "r", "fee", "alt", "rs", "rev", "inv", "drm", "gr", "ns", "die", "der", "Er", "fr", "urg", "eas", "conf", "rel", "iter", "elt", "gz", "ev", "rn", "txt", "arr"], "profiles": ["philing", " profils", "profilers", "protiled", "facelines", "sequports", "prediles", "profports", "Profiles", "profilities", "faciled", "permiles", "profils", "protiling", "profileilies", "sequilities", "phensions", "protensions", "permilities", "Profilities", "profiled", "spilers", "profiling", "Profilers", "facensions", "propelines", "profels", "proferences", "protels", "sequils", "profileils", "facabilities", "spilities", "sperences", "permilers", "profileiles", "faciles", "propiles", "protiles", "predilers", "permerences", "Proferences", "predports", "profelines", "sequiles", "philes", "spiles", "profabilities", "predilities", "protelines", "facels", "propels", "predils", "Profils", "Profilies", " profports", "profilies", " profilities", "phabilities", "faciling", "protabilities", "profileilers", "predilies", "profensions", "propiled"], "entrypoints": ["ryfaces", "enterPoints", "ryPoints", "interfaces", "enterpointers", "terlines", " entrypages", "ryports", " entrypins", "checklines", "rypointers", " entrylines", "cellports", "enterparts", "terpages", "enterpoint", "checkpoints", "rylists", "enterpoints", "ryparts", "enterports", "rypoint", "entrypins", "enterlines", "rypins", " entrylists", "interports", "rypoints", " entryfaces", "entrypointers", "cellparts", "checkpoint", "rylines", "cellpointers", "entrylists", " entryports", "terpointers", "enterlists", "entryfaces", "cellpoints", "entrypages", " entrypointers", "entrypoint", "enterpages", "checkPoints", "entryPoints", "entryports", "terpoints", "interpins", "entryparts", "entrylines", "interpoints"], "attr": ["def", "type", "param", "Att", "ref", " att", "class", "req", "opt", "proc", "spec", "msg", "cache", "sys", "num", "desc", "r", "att", "obj", "attribute", "txt", "label", "rel", "prop", "format", "str", "tab", "rs"]}}
{"project": "FFmpeg", "commit_id": "be00ec832c519427cd92218abac77dafdc1d5487", "target": 0, "func": "static int targa_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n\n                              const AVFrame *p, int *got_packet)\n\n{\n\n    int bpp, picsize, datasize = -1, ret;\n\n    uint8_t *out;\n\n\n\n    if(avctx->width > 0xffff || avctx->height > 0xffff) {\n\n        av_log(avctx, AV_LOG_ERROR, \"image dimensions too large\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    picsize = av_image_get_buffer_size(avctx->pix_fmt,\n\n                                       avctx->width, avctx->height, 1);\n\n    if ((ret = ff_alloc_packet(pkt, picsize + 45)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* zero out the header and only set applicable fields */\n\n    memset(pkt->data, 0, 12);\n\n    AV_WL16(pkt->data+12, avctx->width);\n\n    AV_WL16(pkt->data+14, avctx->height);\n\n    /* image descriptor byte: origin is always top-left, bits 0-3 specify alpha */\n\n    pkt->data[17] = 0x20 | (avctx->pix_fmt == AV_PIX_FMT_BGRA ? 8 : 0);\n\n\n\n    switch(avctx->pix_fmt) {\n\n    case AV_PIX_FMT_GRAY8:\n\n        pkt->data[2]  = TGA_BW;     /* uncompressed grayscale image */\n\n        pkt->data[16] = 8;          /* bpp */\n\n        break;\n\n    case AV_PIX_FMT_RGB555LE:\n\n        pkt->data[2]  = TGA_RGB;    /* uncompresses true-color image */\n\n        pkt->data[16] = 16;         /* bpp */\n\n        break;\n\n    case AV_PIX_FMT_BGR24:\n\n        pkt->data[2]  = TGA_RGB;    /* uncompressed true-color image */\n\n        pkt->data[16] = 24;         /* bpp */\n\n        break;\n\n    case AV_PIX_FMT_BGRA:\n\n        pkt->data[2]  = TGA_RGB;    /* uncompressed true-color image */\n\n        pkt->data[16] = 32;         /* bpp */\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Pixel format '%s' not supported.\\n\",\n\n               av_get_pix_fmt_name(avctx->pix_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n    bpp = pkt->data[16] >> 3;\n\n\n\n    out = pkt->data + 18;  /* skip past the header we just output */\n\n\n\n    /* try RLE compression */\n\n    if (avctx->coder_type != FF_CODER_TYPE_RAW)\n\n        datasize = targa_encode_rle(out, picsize, p, bpp, avctx->width, avctx->height);\n\n\n\n    /* if that worked well, mark the picture as RLE compressed */\n\n    if(datasize >= 0)\n\n        pkt->data[2] |= 8;\n\n\n\n    /* if RLE didn't make it smaller, go back to no compression */\n\n    else datasize = targa_encode_normal(out, p, bpp, avctx->width, avctx->height);\n\n\n\n    out += datasize;\n\n\n\n    /* The standard recommends including this section, even if we don't use\n\n     * any of the features it affords. TODO: take advantage of the pixel\n\n     * aspect ratio and encoder ID fields available? */\n\n    memcpy(out, \"\\0\\0\\0\\0\\0\\0\\0\\0TRUEVISION-XFILE.\", 26);\n\n\n\n    pkt->size   = out + 26 - pkt->data;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 12402, "substitutes": {"avctx": ["avtx", "avercmd", "navcp", "avercfg", "navctx", "avercontext", "avereq", "avpkg", "averwcs", "wavsys", "avcpu", "avertx", "navsys", " avcontext", "wavtx", "avcfg", "navcmd", "savcmd", "wavctx", "avcmp", "AVcontext", "avsys", "avercpu", "averreq", "afctl", "savctx", "avecontext", " avconf", "aftx", "ajcp", "avetx", "ajconf", " avcp", "avewcs", "averctl", "wavwcs", " avcmp", " avcfg", "aversys", "avecfg", "savcfg", "ajcpu", " avreq", "navcfg", "AVctx", "wavcpu", "wavpkg", "averpkg", "ajcontext", "aveconf", "afconf", "savpkg", "avecmd", "avcp", "avecp", "wavcmd", "afctx", "avreq", "averctx", "wavcp", "ajjac", "avcmd", "avconf", "wavconf", " avjac", "avconn", "ajtx", "avecmp", "avejac", "wavconfig", "aveconn", "avconfig", "avjac", "avectl", " avpkg", "avctl", "wavcontext", "navtx", "avcontext", "avepkg", "savjac", "AVcfg", "averconf", "ajctx", " avcmd", "AVcmp", "aveconfig", " avtx", "navctl", " avconfig", "averconn", "savconn", "avectx", "ajconfig", "avwcs", "averconfig", "avercp", "averjac"], "pkt": ["opacket", " pwk", "wpacket", " pempt", "wkt", "repfeat", "phpkt", "opct", "pingacket", "patwd", "cpkt", " pkg", "repett", "wpwd", "promkt", "pingelt", " pett", "partkt", "persacket", "opet", " pelt", "Pct", "persixie", "formempt", "opkt", "repwk", "expkt", " pixie", "pet", "repempt", "pwk", "pkg", "formacket", "partwk", "pconn", "repitt", "dct", "phpett", "packet", "patkt", "patacket", " pwd", "spacket", "paycht", "spkt", "dacket", "cpct", "pux", "portkt", "pcht", "formkt", "paykt", "presett", "pingkg", "pman", " pnt", " pfeat", "pingconn", "portmit", "cpacket", "payelt", "pingkt", "payshot", "perskt", " poch", " pconn", "wet", "cpkg", "repvert", "presacket", "repmit", "pelt", " pcht", "expempt", " packet", "pfeat", "dnt", "promitt", "presempt", "pempt", "pwd", "repkt", " pet", "pshot", "poch", "payacket", "pixie", "promett", "promfeat", "repcat", "opconn", "pnt", "formux", "opmsg", "presitt", "presixie", "pct", "formvert", "patoch", " pman", "preskt", "expmit", "formitt", " pitt", "phpitt", " pmit", "expvert", "wacket", "cpconn", "persempt", "pmit", "presman", "pitt", "partitt", " pct", "Packet", " pux", "repacket", "paymsg", "persshot", "phpman", "formfeat", "Pnt", "opkg", "formmit", "paymit", "payconn", "persmit", "pcat", "dkt", "wmsg", "pingux", "persmsg", "partcat", " pcat", " pmsg", "spkg", "formkg", " pshot", "spct", "portacket", "paycat", "wpkt", "portcht", "wpoch", "pvert", "pmsg", "pingcat", "pett", "Pkt"], "p": ["jp", "f", "o", "pb", "j", "n", "v", "g", "pt", "t", "pp", "np", "P", "m", "r", "rep", "c", "fp", "cp", "b", "h", "pc", "d", "q", "w", "i", "tp", "pa"], "got_packet": ["got_pets", "got_presets", "got_presed", "got2packed", "got2packet", "got_ackacket", "got2pet", "got_preset", "got_packacket", "got_packed", "got_ackets", "got_acket", "got_packets", "got2ped", "got2packets", "got2packacket", "got_presacket", "got2pets", "got_ped", "got_acked", "got_pet"], "bpp": ["bpl", " bps", "ppp", "pmp", " bpl", "bbpe", "tps", "ppe", "abpps", "bpps", "abps", " bpps", "tpp", " bmp", "abpl", "bbpp", "abpp", "tpl", "bmp", "bps", "ppps", "bbmp", "bbpps", "bpe", "tpps", " bpe"], "picsize": ["pisiz", "picource", "picksized", "npicIZE", "npicsize", "pipsource", "npicsIZE", "Pickssize", "picksize", "pidisized", "picksource", "picsized", "picsource", "Picksource", "Picsource", "npiciz", "pisize", "Picsiz", "pidisize", "pisization", "pidisiz", "picsiz", "Picssize", "pidisIZE", "pissize", "picized", " picsiz", " piciz", "picksIZE", "picssize", "picization", "npicsiz", "Picksiz", "Picksize", "picsization", " picize", "picksization", "picize", " picsization", " picssize", "pipsize", "picsIZE", "picIZE", "picksiz", "pipssize", "pickssize", "npicsized", "npicize", " picization", "npicized", "piciz", "Picsize", "pipsiz"], "ret": ["resp", "rem", "def", "mem", "f", "ref", "det", "ll", "fun", "back", "j", "Ret", "reply", "rets", "after", "RET", "val", "reset", "dt", "fail", "reg", "t", "len", "result", "nt", "r", "gt", "alt", "last", "ern", "rt", "mel", "empty", "tf", "res", "re", "tmp", "mt", "rel", "ft", "fi", "err", " Ret", "value", "fin", "cont", "txt"], "out": ["f", "o", "output", "j", "n", "v", "conv", "g", "io", "t", "msg", "buf", "bin", "new", "in", "gt", "obj", "Out", "c", "res", "b", "tmp", "set", "OUT", "u", "w", "ch"]}}
{"project": "qemu", "commit_id": "7ef8cf9a0861b6f67f5e57428478c31bfd811651", "target": 1, "func": "static int scsi_req_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    cmd->xfer = scsi_cdb_length(buf);\n\n    switch (buf[0]) {\n\n    case TEST_UNIT_READY:\n\n    case REWIND:\n\n    case START_STOP:\n\n    case SET_CAPACITY:\n\n    case WRITE_FILEMARKS:\n\n    case WRITE_FILEMARKS_16:\n\n    case SPACE:\n\n    case RESERVE:\n\n    case RELEASE:\n\n    case ERASE:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case SEEK_10:\n\n    case SYNCHRONIZE_CACHE:\n\n    case SYNCHRONIZE_CACHE_16:\n\n    case LOCATE_16:\n\n    case LOCK_UNLOCK_CACHE:\n\n    case SET_CD_SPEED:\n\n    case SET_LIMITS:\n\n    case WRITE_LONG_10:\n\n    case UPDATE_BLOCK:\n\n    case RESERVE_TRACK:\n\n    case SET_READ_AHEAD:\n\n    case PRE_FETCH:\n\n    case PRE_FETCH_16:\n\n    case ALLOW_OVERWRITE:\n\n        cmd->xfer = 0;\n\n        break;\n\n    case VERIFY_10:\n\n    case VERIFY_12:\n\n    case VERIFY_16:\n\n        if ((buf[1] & 2) == 0) {\n\n            cmd->xfer = 0;\n\n        } else if ((buf[1] & 4) == 1) {\n\n            cmd->xfer = 1;\n\n        }\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case MODE_SENSE:\n\n        break;\n\n    case WRITE_SAME_10:\n\n    case WRITE_SAME_16:\n\n        cmd->xfer = dev->blocksize;\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        cmd->xfer = 8;\n\n        break;\n\n    case READ_BLOCK_LIMITS:\n\n        cmd->xfer = 6;\n\n        break;\n\n    case SEND_VOLUME_TAG:\n\n        /* GPCMD_SET_STREAMING from multimedia commands.  */\n\n        if (dev->type == TYPE_ROM) {\n\n            cmd->xfer = buf[10] | (buf[9] << 8);\n\n        } else {\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case WRITE_6:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case WRITE_10:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_12:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case READ_10:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case READ_12:\n\n    case READ_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case FORMAT_UNIT:\n\n        /* MMC mandates the parameter list to be 12-bytes long.  Parameters\n\n         * for block devices are restricted to the header right now.  */\n\n        if (dev->type == TYPE_ROM && (buf[1] & 16)) {\n\n            cmd->xfer = 12;\n\n        } else {\n\n            cmd->xfer = (buf[1] & 16) == 0 ? 0 : (buf[1] & 32 ? 8 : 4);\n\n        }\n\n        break;\n\n    case INQUIRY:\n\n    case RECEIVE_DIAGNOSTIC:\n\n    case SEND_DIAGNOSTIC:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    case READ_CD:\n\n    case READ_BUFFER:\n\n    case WRITE_BUFFER:\n\n    case SEND_CUE_SHEET:\n\n        cmd->xfer = buf[8] | (buf[7] << 8) | (buf[6] << 16);\n\n        break;\n\n    case PERSISTENT_RESERVE_OUT:\n\n        cmd->xfer = ldl_be_p(&buf[5]) & 0xffffffffULL;\n\n        break;\n\n    case ERASE_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* MMC command GET PERFORMANCE.  */\n\n            cmd->xfer = scsi_get_performance_length(buf[9] | (buf[8] << 8),\n\n                                                    buf[10], buf[1] & 0x1f);\n\n        }\n\n        break;\n\n    case MECHANISM_STATUS:\n\n    case READ_DVD_STRUCTURE:\n\n    case SEND_DVD_STRUCTURE:\n\n    case MAINTENANCE_OUT:\n\n    case MAINTENANCE_IN:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* BLANK command of MMC */\n\n            cmd->xfer = 0;\n\n        } else {\n\n            cmd->xfer = ata_passthrough_12_xfer_size(dev, buf);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_16:\n\n        cmd->xfer = ata_passthrough_16_xfer_size(dev, buf);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12409, "substitutes": {"cmd": ["quit", "resp", "def", "exec", "conn", "query", "handle", "det", "head", "good", "addr", "ctx", "ind", "crit", "cmp", "auth", "cod", "req", "opt", "mk", "call", "cli", "text", "check", "batch", "ctr", "md", "nd", "comm", "help", "msg", "controller", "rend", "command", "ext", "cat", "ct", "send", "desc", "cfg", "nt", "job", "act", "obj", "control", "add", "quick", "dq", "kick", "Cmd", "bind", "term", "urg", "dep", "host", "conf", "config", "del", "pkg", "news", "init", "cont", "txt", "ch", "form"], "dev": ["vol", "server", "nv", "def", "des", "mem", "conn", "DEV", "serv", "go", "ver", "det", "data", "addr", "ctx", "hw", "devices", "Dev", "proc", "Device", "v", "task", " device", "md", "spec", "priv", "sys", "scan", "cam", "nt", "env", "doc", "dem", "info", "db", "debug", "device", "adv", "serial", "ad", "develop", "dep", "conf", "app", "var", "de", "ve", "ev", "w"], "buf": ["Buff", "bytes", "vec", "mem", "go", "bs", "ref", "ff", "seq", "pb", "aka", "ctx", "window", "hz", "raw", "grad", "Buffer", "bh", "proc", "conv", "v", "deg", "batch", "box", "comm", "msg", "buff", "cap", "bin", "rb", "cache", "packed", "br", "cam", "desc", "bag", "aux", "doc", "buffer", "cb", "block", "cv", "db", "img", "b", "bl", "bc", "iter", "pad", "var", "config", "emb", "uf", "prop", "queue", "ev", "bp", "pkg", "dat", "lim", "str", "tab", "txt", "pack"]}}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "static void qdm2_init(QDM2Context *q) {\n\n    static int inited = 0;\n\n\n\n    if (inited != 0)\n\n        return;\n\n    inited = 1;\n\n\n\n    qdm2_init_vlc();\n\n    ff_mpa_synth_init(mpa_window);\n\n    softclip_table_init();\n\n    rnd_table_init();\n\n    init_noise_samples();\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"init done\\n\");\n\n}\n", "idx": 12412, "substitutes": {"q": ["tx", "qu", " c", "query", "ctx", "p", "sq", "cc", "v", " sq", "g", "t", "iq", "ct", "qa", "qi", "qs", "dq", "c", "cv", "qt", " qu", "z", "queue", "w", "Q", "qq", "ch"]}}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static int encode_frame(FlacEncodeContext *s)\n\n{\n\n    int ch, count;\n\n\n\n    count = count_frame_header(s);\n\n\n\n    for (ch = 0; ch < s->channels; ch++)\n\n        count += encode_residual_ch(s, ch);\n\n\n\n    count += (8 - (count & 7)) & 7; // byte alignment\n\n    count += 16;                    // CRC-16\n\n\n\n    return count >> 3;\n\n}\n", "idx": 12429, "substitutes": {"s": ["ses", "gs", "a", "S", "f", "bs", "less", "p", "js", "n", "sq", "t", "comm", "is", "sv", "sb", "als", "sys", "hs", "ds", "ats", "ls", "ess", "qs", "ts", "c", "ins", "b", "ns", "cs", "an", "ims", "es", "fs", "os", "bis", "its", "ss", "w", "sts", "rs", "ps"], "ch": ["bit", "qu", "wh", " c", "client", "go", "cht", "ph", "kh", "chu", "ind", "j", "ex", " chunk", "v", "g", "pt", "batch", "el", " Ch", "CH", "bt", "ih", "msg", "gb", "tch", "sch", "cell", "k", "br", "ich", "bot", "channel", "th", "att", "chrom", "ble", "ac", "c", "uch", "mut", "code", "sh", "ht", "b", "cp", "cs", "bc", "h", "chan", "ech", "och", "cho", "ach", "unk", "Ch", "col", "z", "q", "i", "x", "ca", "y", "chn", "zh", "sk"], "count": ["index", "mount", "and", "check", "counter", "port", "t", "len", "result", "command", "nt", "add", "limit", "trace", "length", "cont", "sum", "number", "ind", "cmd", "n", "th", "comment", "table", "report", "found", "total", "Count", "history", "a", "at", "scroll", "f", "hold", "now", "offset", "current", "buffer", "c", "more", "ach", "state", "hash", "d", "err", "cast", "force", "status", "amount", "size", "l", "p", "cache", "num", "ct", "message", "last", "time", "ount", "find", "base", "all", "code", "must", "h", "max", "list", "nb", "z", "q"]}}
{"project": "qemu", "commit_id": "7df9381b7aa56c897e344f3bfe43bf5848bbd3e0", "target": 0, "func": "static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos)\n\n{\n\n    PCIDevice *pdev = &vdev->pdev;\n\n    uint8_t cap_id, next, size;\n\n    int ret;\n\n\n\n    cap_id = pdev->config[pos];\n\n    next = pdev->config[pos + PCI_CAP_LIST_NEXT];\n\n\n\n    /*\n\n     * If it becomes important to configure capabilities to their actual\n\n     * size, use this as the default when it's something we don't recognize.\n\n     * Since QEMU doesn't actually handle many of the config accesses,\n\n     * exact size doesn't seem worthwhile.\n\n     */\n\n    size = vfio_std_cap_max_size(pdev, pos);\n\n\n\n    /*\n\n     * pci_add_capability always inserts the new capability at the head\n\n     * of the chain.  Therefore to end up with a chain that matches the\n\n     * physical device, we insert from the end by making this recursive.\n\n     * This is also why we pre-calculate size above as cached config space\n\n     * will be changed as we unwind the stack.\n\n     */\n\n    if (next) {\n\n        ret = vfio_add_std_cap(vdev, next);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    } else {\n\n        /* Begin the rebuild, use QEMU emulated list bits */\n\n        pdev->config[PCI_CAPABILITY_LIST] = 0;\n\n        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;\n\n        vdev->emulated_config_bits[PCI_STATUS] |= PCI_STATUS_CAP_LIST;\n\n    }\n\n\n\n    /* Use emulated next pointer to allow dropping caps */\n\n    pci_set_byte(vdev->emulated_config_bits + pos + PCI_CAP_LIST_NEXT, 0xff);\n\n\n\n    switch (cap_id) {\n\n    case PCI_CAP_ID_MSI:\n\n        ret = vfio_msi_setup(vdev, pos);\n\n        break;\n\n    case PCI_CAP_ID_EXP:\n\n        vfio_check_pcie_flr(vdev, pos);\n\n        ret = vfio_setup_pcie_cap(vdev, pos, size);\n\n        break;\n\n    case PCI_CAP_ID_MSIX:\n\n        ret = vfio_msix_setup(vdev, pos);\n\n        break;\n\n    case PCI_CAP_ID_PM:\n\n        vfio_check_pm_reset(vdev, pos);\n\n        vdev->pm_cap = pos;\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    case PCI_CAP_ID_AF:\n\n        vfio_check_af_flr(vdev, pos);\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    default:\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        error_report(\"vfio: %04x:%02x:%02x.%x Error adding PCI capability \"\n\n                     \"0x%x[0x%x]@0x%x: %d\", vdev->host.domain,\n\n                     vdev->host.bus, vdev->host.slot, vdev->host.function,\n\n                     cap_id, size, pos, ret);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12434, "substitutes": {"vdev": ["vmdevice", "vserial", "tdef", "hDev", "jdef", "svdev", "vcblock", " vdevice", " vstat", "svenv", "wdev", "uvpay", "jdev", "vmDev", "vstream", "vclink", "vpriv", " vcast", " vlink", "vcpay", "vdevice", "wdevice", "uvdevice", "vw", " vserial", "pstat", "vcobj", "pdevice", "hutil", " vstore", "vutil", "uvpriv", "pserver", "pdb", "vblock", " vstream", "svserial", "vcdev", "vcast", "vdes", "vpay", "voldevice", "volhost", "vmblock", "uvdev", "vcDev", "pvar", "vDev", "svself", "tdev", "vmobj", "vstore", "volpriv", "svstream", "ww", "vcutil", "hcam", "vlink", "hdev", "vccast", "pdes", "vvar", "vcdes", "penv", "pstore", "pobj", "tvar", "venv", "pserial", " vw", "uvutil", "ppay", " vpay", " venv", " vself", "vccam", "vstat", "pdef", "hpay", "ppriv", "pstream", "vmdes", "uvhost", "pDev", "hdevice", "vhost", "wDev", "svdb", " vcam", "pblock", "vself", "vcserver", "hcast", "vdb", "jdevice", "vmcam", "vcam", "phost", "vdef", "voldev", "vcdevice", "svstore", "vmdev", "pw", " vDev", "svdevice", "hstat", "plink", "vserver", "pcam", "vobj", "pself", " vserver", " vdb", "jvar", "tdevice"], "pos": ["bit", "index", "pres", "pool", "port", "len", "loc", "new", "nt", "doc", "neg", "parent", "top", "po", "client", "start", "pid", "pre", "length", "zero", "ps", "pro", "def", "type", "axis", "Pos", "ind", "params", "spec", "prot", "part", "tmp", "set", "form", "pose", "resp", "key", "at", "ref", "out", "cond", "pi", "pat", "row", "unit", "offset", "snap", "slot", "block", "trans", "pc", "POS", "state", "to", "init", "alloc", "o", "position", "p", "body", "pt", "gen", "num", "tag", "oss", "mut", "base", "rot", "no", "post", "point", "os", "col", "list", "max", "name", "pointer"], "pdev": ["hDev", "proDev", "PDev", "msys", "kDev", "cpdevice", "powerdiv", " pdata", "vdevice", "prodevice", "cpdev", " pdevice", "ppDev", "wpdev", "psys", "pdevice", "Pdevice", "pdo", "mDev", " papi", " pany", "predevice", "vapi", "pdiv", "papi", "pconn", "vDEV", "vdo", "pserver", "ppdev", " pserver", " pdiv", "preDev", "vconn", " pDEV", "pDEV", "ppdo", "ppany", "pev", "vev", "tconn", "vsys", "vDev", "mdev", "kev", " pDev", "tdev", "Pdev", "tDev", " pdef", "powerserver", "pany", "hdev", "predata", "Pdef", "kdevice", "powerdevice", "cpDev", " psys", " pdo", "pdef", "vdiv", "pdata", "pDev", "wpdef", "cpconn", "hdevice", "wpDEV", "hev", "prodef", "powerdev", "predev", "mdevice", "tapi", "vdef", "prodev", "kdev", "vserver", "vdata", "vany", "wpdevice", "tdevice"], "cap_id": ["cap0url", "capameaid", "cap___id", "clip_Id", "capityId", "capJid", "cap_url", "clip_sid", "capameID", "clip_id", " cap_try", "var_bid", "cap0info", "cap_def", "cap_len", "capxID", "capxtype", "cap_aid", "var_id", "var_type", "var___id", "capametype", "var___type", "capityid", "cap_type", "capJtry", "cap0Id", "cap___bid", "capxaid", "cap___mid", "cap_info", " cap_mid", "cap_ID", " cap_url", " cap_Id", "capitysid", "var___bid", " cap_ID", "cap_bid", "cap_sid", " cap_info", "cap___ide", "capameid", "cap2sid", "cap2id", "var_ide", "var___ide", "cap_Id", "cap_try", "capxid", " cap_def", "capJdef", " cap_type", "cap_mid", "cap2len", "clip_len", "cap___type", "cap0id", " cap_aid", "capJinfo", "cap_ide", "cap___Id", "capitylen", "cap2Id"], "next": ["status", "index", "jp", "path", "nl", "li", "key", "ptr", "prev", "primary", "ref", "Next", "success", "seq", "ner", "body", "then", "mk", "after", "chain", "ng", "big", "done", "gen", "nd", "len", "sec", "buf", "end", "new", "future", "last", "first", "current", "link", "more", "append", "gov", "start", "tmp", "set", "any", "entry", "list", "max", "config", "elt", "ne", "net", "sent", "txt"], "size": ["Size", "type", "mem", "sw", "l", "SIZE", "city", "body", "scope", "min", "g", "big", "box", "unit", "len", "spec", "ize", "msg", "space", "cap", "send", "zone", "fee", "s", "full", "dim", "empty", "sp", "large", "count", "loss", "limit", "sh", "scale", "grow", "set", "max", "length", "shape", "total", "format", "fit", "z", "form", "sym", "small", "sn", "news", "name", "sent", "sum"], "ret": ["pret", "fun", "back", "val", "t", "len", "rm", "result", "gb", "nt", "lit", "att", "rev", "Return", "backed", "summary", "repl", "it", "net", " Ret", "cont", "arr", "sum", "rem", "def", "mem", "ll", "tr", "after", "RET", "reset", "dt", "try", "box", "get", "rect", "res", "print", "flag", "mt", "arg", "elt", "mb", "xt", "ter", "full", "txt", "resp", "out", "ref", " alt", "bool", "Ret", "rets", "grain", "rest", "gt", "verified", "red", "jump", "iter", "ft", "hash", "err", "status", "success", "det", "reg", "details", "ext", "desc", "alt", "last", "rt", "re", "rel", "format"]}}
{"project": "qemu", "commit_id": "fb9fb692312a84ebc6e9c10da6f374c5871ff7b0", "target": 0, "func": "int cpu_exec(CPUState *env1)\n\n{\n\n#define DECLARE_HOST_REGS 1\n\n#include \"hostregs_helper.h\"\n\n    int ret, interrupt_request;\n\n    TranslationBlock *tb;\n\n    uint8_t *tc_ptr;\n\n    unsigned long next_tb;\n\n\n\n    if (cpu_halted(env1) == EXCP_HALTED)\n\n        return EXCP_HALTED;\n\n\n\n    cpu_single_env = env1;\n\n\n\n    /* first we save global registers */\n\n#define SAVE_HOST_REGS 1\n\n#include \"hostregs_helper.h\"\n\n    env = env1;\n\n\n\n#if defined(TARGET_I386)\n\n    /* put eflags in CPU temporary format */\n\n    CC_SRC = env->eflags & (CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n    DF = 1 - (2 * ((env->eflags >> 10) & 1));\n\n    CC_OP = CC_OP_EFLAGS;\n\n    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n#elif defined(TARGET_SPARC)\n\n#elif defined(TARGET_M68K)\n\n    env->cc_op = CC_OP_FLAGS;\n\n    env->cc_dest = env->sr & 0xf;\n\n    env->cc_x = (env->sr >> 4) & 1;\n\n#elif defined(TARGET_ALPHA)\n\n#elif defined(TARGET_ARM)\n\n#elif defined(TARGET_PPC)\n\n#elif defined(TARGET_MICROBLAZE)\n\n#elif defined(TARGET_MIPS)\n\n#elif defined(TARGET_SH4)\n\n#elif defined(TARGET_CRIS)\n\n#elif defined(TARGET_S390X)\n\n    /* XXXXX */\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n    env->exception_index = -1;\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    for(;;) {\n\n        if (setjmp(env->jmp_env) == 0) {\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n            /* if an exception is pending, we execute it here */\n\n            if (env->exception_index >= 0) {\n\n                if (env->exception_index >= EXCP_INTERRUPT) {\n\n                    /* exit request from the cpu execution loop */\n\n                    ret = env->exception_index;\n\n                    if (ret == EXCP_DEBUG)\n\n                        cpu_handle_debug_exception(env);\n\n                    break;\n\n                } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n                    /* if user mode only, we simulate a fake exception\n\n                       which will be handled outside the cpu execution\n\n                       loop */\n\n#if defined(TARGET_I386)\n\n                    do_interrupt_user(env->exception_index,\n\n                                      env->exception_is_int,\n\n                                      env->error_code,\n\n                                      env->exception_next_eip);\n\n                    /* successfully delivered */\n\n                    env->old_exception = -1;\n\n#endif\n\n                    ret = env->exception_index;\n\n                    break;\n\n#else\n\n#if defined(TARGET_I386)\n\n                    /* simulate a real cpu exception. On i386, it can\n\n                       trigger new exceptions, but we do not handle\n\n                       double or triple faults yet. */\n\n                    do_interrupt(env->exception_index,\n\n                                 env->exception_is_int,\n\n                                 env->error_code,\n\n                                 env->exception_next_eip, 0);\n\n                    /* successfully delivered */\n\n                    env->old_exception = -1;\n\n#elif defined(TARGET_PPC)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_MIPS)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_SPARC)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_ARM)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_SH4)\n\n\t\t    do_interrupt(env);\n\n#elif defined(TARGET_ALPHA)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_CRIS)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_M68K)\n\n                    do_interrupt(0);\n\n#endif\n\n                    env->exception_index = -1;\n\n#endif\n\n                }\n\n            }\n\n\n\n            if (kvm_enabled()) {\n\n                kvm_cpu_exec(env);\n\n                longjmp(env->jmp_env, 1);\n\n            }\n\n\n\n            next_tb = 0; /* force lookup of first TB */\n\n            for(;;) {\n\n                interrupt_request = env->interrupt_request;\n\n                if (unlikely(interrupt_request)) {\n\n                    if (unlikely(env->singlestep_enabled & SSTEP_NOIRQ)) {\n\n                        /* Mask out external interrupts for this step. */\n\n                        interrupt_request &= ~(CPU_INTERRUPT_HARD |\n\n                                               CPU_INTERRUPT_FIQ |\n\n                                               CPU_INTERRUPT_SMI |\n\n                                               CPU_INTERRUPT_NMI);\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_DEBUG) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_DEBUG;\n\n                        env->exception_index = EXCP_DEBUG;\n\n                        cpu_loop_exit();\n\n                    }\n\n#if defined(TARGET_ARM) || defined(TARGET_SPARC) || defined(TARGET_MIPS) || \\\n\n    defined(TARGET_PPC) || defined(TARGET_ALPHA) || defined(TARGET_CRIS) || \\\n\n    defined(TARGET_MICROBLAZE)\n\n                    if (interrupt_request & CPU_INTERRUPT_HALT) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_HALT;\n\n                        env->halted = 1;\n\n                        env->exception_index = EXCP_HLT;\n\n                        cpu_loop_exit();\n\n                    }\n\n#endif\n\n#if defined(TARGET_I386)\n\n                    if (interrupt_request & CPU_INTERRUPT_INIT) {\n\n                            svm_check_intercept(SVM_EXIT_INIT);\n\n                            do_cpu_init(env);\n\n                            env->exception_index = EXCP_HALTED;\n\n                            cpu_loop_exit();\n\n                    } else if (interrupt_request & CPU_INTERRUPT_SIPI) {\n\n                            do_cpu_sipi(env);\n\n                    } else if (env->hflags2 & HF2_GIF_MASK) {\n\n                        if ((interrupt_request & CPU_INTERRUPT_SMI) &&\n\n                            !(env->hflags & HF_SMM_MASK)) {\n\n                            svm_check_intercept(SVM_EXIT_SMI);\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_SMI;\n\n                            do_smm_enter();\n\n                            next_tb = 0;\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_NMI) &&\n\n                                   !(env->hflags2 & HF2_NMI_MASK)) {\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_NMI;\n\n                            env->hflags2 |= HF2_NMI_MASK;\n\n                            do_interrupt(EXCP02_NMI, 0, 0, 0, 1);\n\n                            next_tb = 0;\n\n\t\t\t} else if (interrupt_request & CPU_INTERRUPT_MCE) {\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_MCE;\n\n                            do_interrupt(EXCP12_MCHK, 0, 0, 0, 0);\n\n                            next_tb = 0;\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                                   (((env->hflags2 & HF2_VINTR_MASK) && \n\n                                     (env->hflags2 & HF2_HIF_MASK)) ||\n\n                                    (!(env->hflags2 & HF2_VINTR_MASK) && \n\n                                     (env->eflags & IF_MASK && \n\n                                      !(env->hflags & HF_INHIBIT_IRQ_MASK))))) {\n\n                            int intno;\n\n                            svm_check_intercept(SVM_EXIT_INTR);\n\n                            env->interrupt_request &= ~(CPU_INTERRUPT_HARD | CPU_INTERRUPT_VIRQ);\n\n                            intno = cpu_get_pic_interrupt(env);\n\n                            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"Servicing hardware INT=0x%02x\\n\", intno);\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n                            do_interrupt(intno, 0, 0, 0, 1);\n\n                            /* ensure that no TB jump will be modified as\n\n                               the program flow was changed */\n\n                            next_tb = 0;\n\n#if !defined(CONFIG_USER_ONLY)\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_VIRQ) &&\n\n                                   (env->eflags & IF_MASK) && \n\n                                   !(env->hflags & HF_INHIBIT_IRQ_MASK)) {\n\n                            int intno;\n\n                            /* FIXME: this should respect TPR */\n\n                            svm_check_intercept(SVM_EXIT_VINTR);\n\n                            intno = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.int_vector));\n\n                            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"Servicing virtual hardware INT=0x%02x\\n\", intno);\n\n                            do_interrupt(intno, 0, 0, 0, 1);\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_VIRQ;\n\n                            next_tb = 0;\n\n#endif\n\n                        }\n\n                    }\n\n#elif defined(TARGET_PPC)\n\n#if 0\n\n                    if ((interrupt_request & CPU_INTERRUPT_RESET)) {\n\n                        cpu_reset(env);\n\n                    }\n\n#endif\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        ppc_hw_interrupt(env);\n\n                        if (env->pending_interrupts == 0)\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_HARD;\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    if ((interrupt_request & CPU_INTERRUPT_HARD)\n\n                        && (env->sregs[SR_MSR] & MSR_IE)\n\n                        && !(env->sregs[SR_MSR] & (MSR_EIP | MSR_BIP))\n\n                        && !(env->iflags & (D_FLAG | IMM_FLAG))) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_MIPS)\n\n                    if ((interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                        (env->CP0_Status & env->CP0_Cause & CP0Ca_IP_mask) &&\n\n                        (env->CP0_Status & (1 << CP0St_IE)) &&\n\n                        !(env->CP0_Status & (1 << CP0St_EXL)) &&\n\n                        !(env->CP0_Status & (1 << CP0St_ERL)) &&\n\n                        !(env->hflags & MIPS_HFLAG_DM)) {\n\n                        /* Raise it */\n\n                        env->exception_index = EXCP_EXT_INTERRUPT;\n\n                        env->error_code = 0;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_SPARC)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        if (cpu_interrupts_enabled(env) &&\n\n                            env->interrupt_index > 0) {\n\n                            int pil = env->interrupt_index & 0xf;\n\n                            int type = env->interrupt_index & 0xf0;\n\n\n\n                            if (((type == TT_EXTINT) &&\n\n                                  cpu_pil_allowed(env, pil)) ||\n\n                                  type != TT_EXTINT) {\n\n                                env->exception_index = env->interrupt_index;\n\n                                do_interrupt(env);\n\n                                next_tb = 0;\n\n                            }\n\n                        }\n\n\t\t    } else if (interrupt_request & CPU_INTERRUPT_TIMER) {\n\n\t\t\t//do_interrupt(0, 0, 0, 0, 0);\n\n\t\t\tenv->interrupt_request &= ~CPU_INTERRUPT_TIMER;\n\n\t\t    }\n\n#elif defined(TARGET_ARM)\n\n                    if (interrupt_request & CPU_INTERRUPT_FIQ\n\n                        && !(env->uncached_cpsr & CPSR_F)) {\n\n                        env->exception_index = EXCP_FIQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n                    /* ARMv7-M interrupt return works by loading a magic value\n\n                       into the PC.  On real hardware the load causes the\n\n                       return to occur.  The qemu implementation performs the\n\n                       jump normally, then does the exception return when the\n\n                       CPU tries to execute code at the magic address.\n\n                       This will cause the magic PC value to be pushed to\n\n                       the stack if an interrupt occured at the wrong time.\n\n                       We avoid this by disabling interrupts when\n\n                       pc contains a magic address.  */\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && ((IS_M(env) && env->regs[15] < 0xfffffff0)\n\n                            || !(env->uncached_cpsr & CPSR_I))) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_SH4)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_ALPHA)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_CRIS)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && (env->pregs[PR_CCS] & I_FLAG)) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_NMI\n\n                        && (env->pregs[PR_CCS] & M_FLAG)) {\n\n                        env->exception_index = EXCP_NMI;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_M68K)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && ((env->sr & SR_I) >> SR_I_SHIFT)\n\n                            < env->pending_level) {\n\n                        /* Real hardware gets the interrupt vector via an\n\n                           IACK cycle at this point.  Current emulated\n\n                           hardware doesn't rely on this, so we\n\n                           provide/save the vector when the interrupt is\n\n                           first signalled.  */\n\n                        env->exception_index = env->pending_vector;\n\n                        do_interrupt(1);\n\n                        next_tb = 0;\n\n                    }\n\n#endif\n\n                   /* Don't use the cached interupt_request value,\n\n                      do_interrupt may have updated the EXITTB flag. */\n\n                    if (env->interrupt_request & CPU_INTERRUPT_EXITTB) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_EXITTB;\n\n                        /* ensure that no TB jump will be modified as\n\n                           the program flow was changed */\n\n                        next_tb = 0;\n\n                    }\n\n                }\n\n                if (unlikely(env->exit_request)) {\n\n                    env->exit_request = 0;\n\n                    env->exception_index = EXCP_INTERRUPT;\n\n                    cpu_loop_exit();\n\n                }\n\n#ifdef CONFIG_DEBUG_EXEC\n\n                if (qemu_loglevel_mask(CPU_LOG_TB_CPU)) {\n\n                    /* restore flags in standard format */\n\n#if defined(TARGET_I386)\n\n                    env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);\n\n                    log_cpu_state(env, X86_DUMP_CCOP);\n\n                    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n#elif defined(TARGET_ARM)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_SPARC)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_PPC)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_M68K)\n\n                    cpu_m68k_flush_flags(env, env->cc_op);\n\n                    env->cc_op = CC_OP_FLAGS;\n\n                    env->sr = (env->sr & 0xffe0)\n\n                              | env->cc_dest | (env->cc_x << 4);\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_MIPS)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_SH4)\n\n\t\t    log_cpu_state(env, 0);\n\n#elif defined(TARGET_ALPHA)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_CRIS)\n\n                    log_cpu_state(env, 0);\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n                }\n\n#endif\n\n                spin_lock(&tb_lock);\n\n                tb = tb_find_fast();\n\n                /* Note: we do it here to avoid a gcc bug on Mac OS X when\n\n                   doing it in tb_find_slow */\n\n                if (tb_invalidated_flag) {\n\n                    /* as some TB could have been invalidated because\n\n                       of memory exceptions while generating the code, we\n\n                       must recompute the hash index here */\n\n                    next_tb = 0;\n\n                    tb_invalidated_flag = 0;\n\n                }\n\n#ifdef CONFIG_DEBUG_EXEC\n\n                qemu_log_mask(CPU_LOG_EXEC, \"Trace 0x%08lx [\" TARGET_FMT_lx \"] %s\\n\",\n\n                             (long)tb->tc_ptr, tb->pc,\n\n                             lookup_symbol(tb->pc));\n\n#endif\n\n                /* see if we can patch the calling TB. When the TB\n\n                   spans two pages, we cannot safely do a direct\n\n                   jump. */\n\n                if (next_tb != 0 && tb->page_addr[1] == -1) {\n\n                    tb_add_jump((TranslationBlock *)(next_tb & ~3), next_tb & 3, tb);\n\n                }\n\n                spin_unlock(&tb_lock);\n\n\n\n                /* cpu_interrupt might be called while translating the\n\n                   TB, but before it is linked into a potentially\n\n                   infinite loop and becomes env->current_tb. Avoid\n\n                   starting execution if there is a pending interrupt. */\n\n                if (!unlikely (env->exit_request)) {\n\n                    env->current_tb = tb;\n\n                    tc_ptr = tb->tc_ptr;\n\n                /* execute the generated code */\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n                    next_tb = tcg_qemu_tb_exec(tc_ptr);\n\n                    env->current_tb = NULL;\n\n                    if ((next_tb & 3) == 2) {\n\n                        /* Instruction counter expired.  */\n\n                        int insns_left;\n\n                        tb = (TranslationBlock *)(long)(next_tb & ~3);\n\n                        /* Restore PC.  */\n\n                        cpu_pc_from_tb(env, tb);\n\n                        insns_left = env->icount_decr.u32;\n\n                        if (env->icount_extra && insns_left >= 0) {\n\n                            /* Refill decrementer and continue execution.  */\n\n                            env->icount_extra += insns_left;\n\n                            if (env->icount_extra > 0xffff) {\n\n                                insns_left = 0xffff;\n\n                            } else {\n\n                                insns_left = env->icount_extra;\n\n                            }\n\n                            env->icount_extra -= insns_left;\n\n                            env->icount_decr.u16.low = insns_left;\n\n                        } else {\n\n                            if (insns_left > 0) {\n\n                                /* Execute remaining instructions.  */\n\n                                cpu_exec_nocache(insns_left, tb);\n\n                            }\n\n                            env->exception_index = EXCP_INTERRUPT;\n\n                            next_tb = 0;\n\n                            cpu_loop_exit();\n\n                        }\n\n                    }\n\n                }\n\n                /* reset soft MMU for next block (it can currently\n\n                   only be set by a memory fault) */\n\n            } /* for(;;) */\n\n        }\n\n    } /* for(;;) */\n\n\n\n\n\n#if defined(TARGET_I386)\n\n    /* restore flags in standard format */\n\n    env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);\n\n#elif defined(TARGET_ARM)\n\n    /* XXX: Save/restore host fpu exception state?.  */\n\n#elif defined(TARGET_SPARC)\n\n#elif defined(TARGET_PPC)\n\n#elif defined(TARGET_M68K)\n\n    cpu_m68k_flush_flags(env, env->cc_op);\n\n    env->cc_op = CC_OP_FLAGS;\n\n    env->sr = (env->sr & 0xffe0)\n\n              | env->cc_dest | (env->cc_x << 4);\n\n#elif defined(TARGET_MICROBLAZE)\n\n#elif defined(TARGET_MIPS)\n\n#elif defined(TARGET_SH4)\n\n#elif defined(TARGET_ALPHA)\n\n#elif defined(TARGET_CRIS)\n\n#elif defined(TARGET_S390X)\n\n    /* XXXXX */\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n\n\n    /* restore global registers */\n\n#include \"hostregs_helper.h\"\n\n\n\n    /* fail safe : never use cpu_single_env outside cpu_exec() */\n\n    cpu_single_env = NULL;\n\n    return ret;\n\n}\n", "idx": 12451, "substitutes": {"env1": ["eve2", "ev2", " env3", "ev1", "v3", "eve6", "environment2", " env6", "eve1", "nv0", "v1", "v0", "eve001", "env001", "environment001", "env6", " env0", "v2", "en0", "en2", " env2", "nv1", "env0", "ev0", "en3", "nv2", " env001", "env2", "env3", "environment6", "ev3", "en1", "nv3", "environment1"], "ret": ["resp", "status", "def", "mem", "out", "inter", " RET", "det", "data", "tr", "Ret", "reply", "req", "RET", "val", "reset", "dt", "try", "el", "t", "len", "er", "result", "nt", "alt", "eth", "rt", "Return", "tf", "ter", "res", "flag", "re", "mt", "rel", "over", "ft", "arg", "elt", "xt", "txt"], "interrupt_request": ["interrupt_req", "interruptingrequest", "interruptingproc", "interruptingthread", "interror_thread", "interror_proc", "interrupt_thread", "interror_request", "interrupt_proc", "interruptingreq", "interror_req"], "tb": [" tbe", "trb", "ttbl", "trbe", "tbe", " tmb", " tbl", "ttmb", "ttb", "trmb", "trbl", "ttbe", "tbl", "tmb"], "tc_ptr": ["tc__ptr", "tc__pointer", "tc__tr", "TC_pointer", "tc_pointer", "tc_bp", "tc_tr", "TC_tr", "tc__bp", "TC_ptr", "TC_bp"], "next_tb": ["next_lb", "next_newb", "next_newib", "next_lib", "next_tbuf", "next_lbuf", "next_newbuf", "next_tib"]}}
{"project": "qemu", "commit_id": "42a6686b2f6199d086a58edd7731faeb2dbe7c14", "target": 0, "func": "void HELPER(v7m_msr)(CPUARMState *env, uint32_t maskreg, uint32_t val)\n\n{\n\n    /* We're passed bits [11..0] of the instruction; extract\n\n     * SYSm and the mask bits.\n\n     * Invalid combinations of SYSm and mask are UNPREDICTABLE;\n\n     * we choose to treat them as if the mask bits were valid.\n\n     * NB that the pseudocode 'mask' variable is bits [11..10],\n\n     * whereas ours is [11..8].\n\n     */\n\n    uint32_t mask = extract32(maskreg, 8, 4);\n\n    uint32_t reg = extract32(maskreg, 0, 8);\n\n\n\n    if (arm_current_el(env) == 0 && reg > 7) {\n\n        /* only xPSR sub-fields may be written by unprivileged */\n\n        return;\n\n    }\n\n\n\n    switch (reg) {\n\n    case 0 ... 7: /* xPSR sub-fields */\n\n        /* only APSR is actually writable */\n\n        if (!(reg & 4)) {\n\n            uint32_t apsrmask = 0;\n\n\n\n            if (mask & 8) {\n\n                apsrmask |= XPSR_NZCV | XPSR_Q;\n\n            }\n\n            if ((mask & 4) && arm_feature(env, ARM_FEATURE_THUMB_DSP)) {\n\n                apsrmask |= XPSR_GE;\n\n            }\n\n            xpsr_write(env, val, apsrmask);\n\n        }\n\n        break;\n\n    case 8: /* MSP */\n\n        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {\n\n            env->v7m.other_sp = val;\n\n        } else {\n\n            env->regs[13] = val;\n\n        }\n\n        break;\n\n    case 9: /* PSP */\n\n        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {\n\n            env->regs[13] = val;\n\n        } else {\n\n            env->v7m.other_sp = val;\n\n        }\n\n        break;\n\n    case 16: /* PRIMASK */\n\n        env->v7m.primask[env->v7m.secure] = val & 1;\n\n        break;\n\n    case 17: /* BASEPRI */\n\n        env->v7m.basepri[env->v7m.secure] = val & 0xff;\n\n        break;\n\n    case 18: /* BASEPRI_MAX */\n\n        val &= 0xff;\n\n        if (val != 0 && (val < env->v7m.basepri[env->v7m.secure]\n\n                         || env->v7m.basepri[env->v7m.secure] == 0)) {\n\n            env->v7m.basepri[env->v7m.secure] = val;\n\n        }\n\n        break;\n\n    case 19: /* FAULTMASK */\n\n        env->v7m.faultmask = val & 1;\n\n        break;\n\n    case 20: /* CONTROL */\n\n        /* Writing to the SPSEL bit only has an effect if we are in\n\n         * thread mode; other bits can be updated by any privileged code.\n\n         * switch_v7m_sp() deals with updating the SPSEL bit in\n\n         * env->v7m.control, so we only need update the others.\n\n         */\n\n        if (!arm_v7m_is_handler_mode(env)) {\n\n            switch_v7m_sp(env, (val & R_V7M_CONTROL_SPSEL_MASK) != 0);\n\n        }\n\n        env->v7m.control &= ~R_V7M_CONTROL_NPRIV_MASK;\n\n        env->v7m.control |= val & R_V7M_CONTROL_NPRIV_MASK;\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"Attempt to write unknown special\"\n\n                                       \" register %d\\n\", reg);\n\n        return;\n\n    }\n\n}\n", "idx": 12452, "substitutes": {"env": ["conn", "et", "manager", "query", "ctx", "hw", "window", "operator", "man", "port", "engine", "den", "end", "policy", "m", "timer", "context", "doc", "cb", "console", "en", "vs", "ped", "client", "app", "net", "queue", "gear", "te", "gov", "esm", "peer", "ptr", "sw", "exc", "environment", "addr", "cmd", "erd", "v", "menu", "obj", "extra", "eni", "self", "db", "pg", "tmp", "set", "conf", "enter", "eng", "iv", "esp", "txt", "equ", "server", "nv", "ner", "proc", "req", "vp", "erb", "sb", "er", "np", "rb", "ten", "era", "org", "info", "cv", "remote", "ec", "dev", "door", "enc", "state", "uv", "err", "eh", "ev", "vt", "ey", "tm", "serv", "estate", "ee", "ent", "esc", "msg", "cache", "em", "ext", "act", "desc", "ah", "ew", "gate", "vm", "runner", "image", "event", "code", "die", "h", "here", "e", "entry", "var", "ve", "w", "init", "worker"], "maskreg": ["missreg", "maskREG", "clearreg", "holdr", "mapr", "mapeng", "missREG", "askregister", "missregister", "mapreg", "holdregister", " maskReg", "maskReg", "mapReg", " maskr", "mapmem", " maskmem", "clearREG", "mapREG", "holdreg", "askmem", "maskeng", "maskr", "askeng", "clearReg", "askreg", "cleareng", "askReg", "maskregister", "missr", "askREG", "askr", "maskmem", "holdREG"], "val": ["vol", "bit", "index", "vec", "pret", "cur", "ctx", "m", "VAL", "it", "arr", "tx", "def", "mem", "ret", "data", "pr", "ind", "addr", "crit", "pol", "fail", "v", "try", "test", "Value", "obj", "pal", "pos", "res", "conf", "arg", "elt", "x", "resp", "key", "ref", "ver", "eval", "buf", "al", "slot", "vals", "buffer", "dev", "err", "ey", "vt", "str", "valid", "Val", "serv", "l", "values", "p", "reg", "pt", "el", "xy", "msg", "bin", "func", "num", "item", "tag", "alt", "sel", "cal", "bl", "rec", "var", "prop", "z", "value", "pl", "ch"]}}
{"project": "qemu", "commit_id": "d7651f150d61936344c4fab45eaeb0716c606af2", "target": 0, "func": "static bool migrate_caps_check(bool *cap_list,\n\n                               MigrationCapabilityStatusList *params,\n\n                               Error **errp)\n\n{\n\n    MigrationCapabilityStatusList *cap;\n\n    bool old_postcopy_cap;\n\n\n\n    old_postcopy_cap = cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM];\n\n\n\n    for (cap = params; cap; cap = cap->next) {\n\n        cap_list[cap->value->capability] = cap->value->state;\n\n    }\n\n\n\n#ifndef CONFIG_LIVE_BLOCK_MIGRATION\n\n    if (cap_list[MIGRATION_CAPABILITY_BLOCK]) {\n\n        error_setg(errp, \"QEMU compiled without old-style (blk/-b, inc/-i) \"\n\n                   \"block migration\");\n\n        error_append_hint(errp, \"Use drive_mirror+NBD instead.\\n\");\n\n        return false;\n\n    }\n\n#endif\n\n\n\n    if (cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]) {\n\n        if (cap_list[MIGRATION_CAPABILITY_COMPRESS]) {\n\n            /* The decompression threads asynchronously write into RAM\n\n             * rather than use the atomic copies needed to avoid\n\n             * userfaulting.  It should be possible to fix the decompression\n\n             * threads for compatibility in future.\n\n             */\n\n            error_setg(errp, \"Postcopy is not currently compatible \"\n\n                       \"with compression\");\n\n            return false;\n\n        }\n\n\n\n        /* This check is reasonably expensive, so only when it's being\n\n         * set the first time, also it's only the destination that needs\n\n         * special support.\n\n         */\n\n        if (!old_postcopy_cap && runstate_check(RUN_STATE_INMIGRATE) &&\n\n            !postcopy_ram_supported_by_host()) {\n\n            /* postcopy_ram_supported_by_host will have emitted a more\n\n             * detailed message\n\n             */\n\n            error_setg(errp, \"Postcopy is not supported\");\n\n            return false;\n\n        }\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 12470, "substitutes": {"cap_list": ["act_pair", "CAP_lists", "cap_LIST", "ip_list", "ip_List", "cap_collection", "cap__local", "cap2map", "cap_str", "cap_listed", "caps_list", "cap_lists", "cap8local", "cap_def", "caps_map", "cap__List", "conn_list", "caps_LIST", "cap0collection", "ip_lists", "caps_lists", "caps_local", "caps2list", "CAP_def", "caps_lower", "cap2List", "cap2local", "cap_local", "conn_out", "cap8list", "capixlower", "cap_lower", "ip_listed", "cap2list", "caps2map", "cap_map", "conn_chain", "caps_List", "CAP_list", "cap_pair", "cap_out", "cap0chain", "cap_chain", "cap8map", "cap_List", "caps2List", "capixlist", "act_listed", "cap0list", "capixlists", "cap8List", "act_list", "conn_collection", "cap0out", "caps2local", "cap__list", "cap__map", "capixLIST", "act_str"], "params": ["param", "phys", "ports", "attr", "pres", "ctx", "js", "cmp", "par", "names", "ams", "abilities", "pool", "spec", "sys", "pins", "scan", "cms", "aps", "headers", "sp", "stats", "caps", "mas", "cp", "args", "cs", "amps", "spe", "changes", "conf", "list", "parts", "pas", "users", "actions", "properties", "rs", "members", "ps"], "errp": ["corphp", " erp", "rrpre", "ierpm", "errpkg", "rrpa", "eorpkg", "timercp", "arrp", "errpat", "corpkg", "ierp", "derpat", "rerphp", "ererp", "ererpad", " errpa", "arrpre", "eorphp", "diepad", "errping", "errpb", " errP", " errpre", "attrpkg", " erpre", "arrping", "rrping", "diep", "rrphp", "rerp", "errP", "attrcp", "timerpkg", "derpkg", "arrphp", "errcp", "timerpat", "rerping", "corpm", "rerpre", "timerp", "dieP", "ererP", "ererpb", "derp", "rrp", "eorpm", "corp", "dercp", "errpad", "ierphp", "errpm", "ierpkg", "errpre", " erpa", " errpad", " errpb", "errphp", "attrp", "attrpat", "diepb", "eorp", "errpa"], "cap": ["cf", "Cap", "serv", "CAP", "save", "pen", "aw", "cmd", "map", "p", "ctx", "core", "cmp", "cod", "pack", "clip", "cas", "capt", "v", "port", "rip", "sam", "acc", "comm", "pp", "feature", "buf", "cat", "ct", "cl", "cam", "act", "cfg", "ann", "op", "snap", "aps", "sc", "ac", "ship", "bridge", "parse", "c", "sp", "cv", "caps", "ap", "lat", "cp", "ctrl", "bc", "fac", "mp", "ach", "var", "lip", "shape", "prop", "ps", "watch", "ip", "pl", "cast", "av", "ca", "pan", "can", "copy"], "old_postcopy_cap": ["old_postcopy__caps", "old_postcopy__cmp", "old_postcop_cap", "old_postcopyedcaps", "old_postcopy_port", "old_postcopy_CAP", "old_postcop_ip", "old_postcop_caps", "old_postcopy__port", "old_postcap_CAP", "old_postcopyedcap", "old_postcopy_cp", "old_postcopy2caps", "old_postcopy2CAP", "old_postcopyedport", "old_postcopy_ip", "old_postcap_caps", "old_postcop_cp", "old_postcopy__cap", "old_postcopyedcmp", "old_postcopy2ap", "old_postcopy_ap", "old_postcap_cap", "old_postcap_ap", "old_postcopy2cap", "old_postcopy_caps", "old_postcopy_cmp"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,\n\n    bool is_read)\n\n{\n\n    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);\n\n    VirtIOBlock *s = req->dev;\n\n\n\n    if (action == BLOCK_ERROR_ACTION_STOP) {\n\n        req->next = s->rq;\n\n        s->rq = req;\n\n    } else if (action == BLOCK_ERROR_ACTION_REPORT) {\n\n        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);\n\n        block_acct_done(bdrv_get_stats(s->bs), &req->acct);\n\n        virtio_blk_free_request(req);\n\n    }\n\n\n\n    bdrv_error_action(s->bs, action, is_read, error);\n\n    return action != BLOCK_ERROR_ACTION_IGNORE;\n\n}\n", "idx": 12477, "substitutes": {"req": ["resp", "tx", "pro", "jp", "index", "rem", "request", "cr", "ret", "prev", "query", "ref", "wx", "rss", "good", "rw", "ind", "seq", "cmd", "j", "ctx", "js", "crit", "p", "sq", "compl", "next", "reg", "md", "sol", "comm", "msg", "result", "ext", "desc", "r", "obj", "aux", "rs", "ck", "dq", "progress", "self", "inv", "decl", "txt", "gr", "comp", "res", "ack", "mp", "rec", "fr", "urg", "each", "Requ", "rd", "tmp", "requ", "err", "qt", "gz", "q", "rx", "pkg", "quest", "rr", "qq", "ps"], "error": ["status", "instance", "type", " Error", "success", "entity", " ERROR", "bug", "address", "mode", "timeout", "owner", "rage", "anger", "resource", "or", "ror", "er", "result", "command", "offset", "Error", "r", "danger", "exclusive", "comment", "attribute", "info", "iso", "terror", "ERROR", "change", "event", "code", "debug", "ack", "action", "re", "order", "state", "ion", "ity", "err", "style", "problem", "detail", "option", "failed"], "is_read": ["isTrueread", "isEfull", "is_required", "is_reading", "is__read", " is_reader", "is_reader", "isp_read", " is_write", "isTruefull", "isTruereading", "is_write", "isp_required", "isTruerequired", "ispErequired", "is_readable", "ispEreading", "is_reads", "isEread", "is__connect", " is_reads", "ispEfull", "is__write", "is_full", "is__readable", "isEreading", "isp_full", "isErequired", "ispEread", " is_readable", "isp_reading", "is_connect", " is_connect"], "s": ["gs", "S", "bs", "less", "j", "l", "p", "js", "bits", "sq", "v", "g", "sl", "t", "comm", "is", "sb", "sv", "spec", "sys", "hs", "ds", "ls", "m", "r", "ess", "ies", "qs", "gets", "ts", "self", "sp", "c", "vs", "ins", "res", "ns", "b", "cs", "h", "es", "conf", "os", "bis", "se", "q", "ss", "sts", "ms", "y", "rs", "sub", "ps"]}}
{"project": "FFmpeg", "commit_id": "45198477de19ccb00729b7eec07d81494f0353e0", "target": 1, "func": "static inline void FUNC(idctRowCondDC_extrashift)(int16_t *row, int extra_shift)\n\n#else\n\nstatic inline void FUNC(idctRowCondDC)(int16_t *row, int extra_shift)\n\n#endif\n\n{\n\n    int a0, a1, a2, a3, b0, b1, b2, b3;\n\n\n\n#if HAVE_FAST_64BIT\n\n#define ROW0_MASK (0xffffLL << 48 * HAVE_BIGENDIAN)\n\n    if (((AV_RN64A(row) & ~ROW0_MASK) | AV_RN64A(row+4)) == 0) {\n\n        uint64_t temp;\n\n        if (DC_SHIFT - extra_shift >= 0) {\n\n            temp = (row[0] * (1 << (DC_SHIFT - extra_shift))) & 0xffff;\n\n        } else {\n\n            temp = ((row[0] + (1<<(extra_shift - DC_SHIFT-1))) >> (extra_shift - DC_SHIFT)) & 0xffff;\n\n        }\n\n        temp += temp * (1 << 16);\n\n        temp += temp * ((uint64_t) 1 << 32);\n\n        AV_WN64A(row, temp);\n\n        AV_WN64A(row + 4, temp);\n\n        return;\n\n    }\n\n#else\n\n    if (!(AV_RN32A(row+2) |\n\n          AV_RN32A(row+4) |\n\n          AV_RN32A(row+6) |\n\n          row[1])) {\n\n        uint32_t temp;\n\n        if (DC_SHIFT - extra_shift >= 0) {\n\n            temp = (row[0] * (1 << (DC_SHIFT - extra_shift))) & 0xffff;\n\n        } else {\n\n            temp = ((row[0] + (1<<(extra_shift - DC_SHIFT-1))) >> (extra_shift - DC_SHIFT)) & 0xffff;\n\n        }\n\n        temp += temp * (1 << 16);\n\n        AV_WN32A(row, temp);\n\n        AV_WN32A(row+2, temp);\n\n        AV_WN32A(row+4, temp);\n\n        AV_WN32A(row+6, temp);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    a0 = (W4 * row[0]) + (1 << (ROW_SHIFT + extra_shift - 1));\n\n    a1 = a0;\n\n    a2 = a0;\n\n    a3 = a0;\n\n\n\n    a0 += W2 * row[2];\n\n    a1 += W6 * row[2];\n\n    a2 -= W6 * row[2];\n\n    a3 -= W2 * row[2];\n\n\n\n    b0 = MUL(W1, row[1]);\n\n    MAC(b0, W3, row[3]);\n\n    b1 = MUL(W3, row[1]);\n\n    MAC(b1, -W7, row[3]);\n\n    b2 = MUL(W5, row[1]);\n\n    MAC(b2, -W1, row[3]);\n\n    b3 = MUL(W7, row[1]);\n\n    MAC(b3, -W5, row[3]);\n\n\n\n    if (AV_RN64A(row + 4)) {\n\n        a0 +=   W4*row[4] + W6*row[6];\n\n        a1 += - W4*row[4] - W2*row[6];\n\n        a2 += - W4*row[4] + W2*row[6];\n\n        a3 +=   W4*row[4] - W6*row[6];\n\n\n\n        MAC(b0,  W5, row[5]);\n\n        MAC(b0,  W7, row[7]);\n\n\n\n        MAC(b1, -W1, row[5]);\n\n        MAC(b1, -W5, row[7]);\n\n\n\n        MAC(b2,  W7, row[5]);\n\n        MAC(b2,  W3, row[7]);\n\n\n\n        MAC(b3,  W3, row[5]);\n\n        MAC(b3, -W1, row[7]);\n\n    }\n\n\n\n    row[0] = (a0 + b0) >> (ROW_SHIFT + extra_shift);\n\n    row[7] = (a0 - b0) >> (ROW_SHIFT + extra_shift);\n\n    row[1] = (a1 + b1) >> (ROW_SHIFT + extra_shift);\n\n    row[6] = (a1 - b1) >> (ROW_SHIFT + extra_shift);\n\n    row[2] = (a2 + b2) >> (ROW_SHIFT + extra_shift);\n\n    row[5] = (a2 - b2) >> (ROW_SHIFT + extra_shift);\n\n    row[3] = (a3 + b3) >> (ROW_SHIFT + extra_shift);\n\n    row[4] = (a3 - b3) >> (ROW_SHIFT + extra_shift);\n\n}\n", "idx": 12493, "substitutes": {"row": ["index", "cur", "window", "dr", "sur", "raw", "check", "pool", "OW", "rank", "result", "loop", "lock", "line", "word", "ack", "ser", "draw", "zero", "lo", "rc", "error", "co", "ptr", "tr", "try", "spec", "ow", "cell", "job", "dd", "rect", "th", "obj", "pos", "link", "sync", "res", "table", "term", "each", "pair", "ows", "tab", "form", "copy", "node", "server", "scroll", "record", "ref", "rw", "req", "pixel", "proc", "rows", "user", "batch", "store", "ward", "bo", "scan", "rown", "uu", "buffer", "block", "ro", "ry", "iter", "ob", "wrapper", "roll", "bug", "ok", "cache", "item", "r", "prefix", "range", "page", "rot", "Row", "post", "re", "rec", "order", "entry", "mod", "list", "col", "var", "name", "sc", "rs"], "extra_shift": ["extreme_shift", "extra67shift", "extra00update", "extreme_gap", "extraTimepull", "dirty_magic", "extra67shr", "encrypted_shift", "extra7shift", "extra___hift", "dirtyptmagic", "Extra_pad", "total_since", "extraptshift", "extra_hift", "foreign11shock", "extrapthelp", "extra_help", "extraopmagic", "extra_batch", "expected_shift", "extreme___shift", "extreme_hift", "encrypted_batch", "expectedpttimeout", "Extra_switch", "extra_magic", "extra00switch", "extra67gap", "extra10transfer", "extra_shr", "foreign11transfer", "extra_switch", "extra00transform", "extra_pull", "adding67pull", "extra_transfer", "dirty_timeout", "extraptpart", "encryptedTimepull", "expected_pull", "extreme_magic", "foreign11shift", "extraTimeswitch", "extra67hift", "extra00shift", "extra___magic", "extra11transfer", "expected_timeout", "extra7switch", "foreign_shock", "extra67magic", "extra10shift", "adding_switch", "extra___shift", "extraTimeshift", "extreme___magic", "extraophelp", "extra_timeout", "expectedptshift", "extra67timeout", "extraptmagic", "encrypted_switch", "extraptpull", "extra_part", "extra67update", "extra10shock", "extra_pad", "extraoptimeout", "foreign_transfer", "extra11shift", "extreme___hift", "expectedptpart", "extra67transform", "extra___gap", "expected_part", "adding_pull", "Extra_shift", "adding67shr", "extra_transform", "dirty_shift", "extra_gap", "encryptedTimebatch", "extrajshift", "foreign_shift", "adding_shift", "encryptedTimeshift", "adding_shr", "extrajpull", "dirty_help", "extra00pad", "extra_since", "adding67shift", "total_hift", " extra_transform", "extra67pull", "extra11shock", "adding_shock", "expectedptpull", "encrypted_pull", "dirtypthelp", " extra_update", "extra7pull", "extra_set", "extra7batch", "total_shift", "extrajtimeout", "dirtyptshift", "Extra_hift", "extraopshift", "extra00hift", "extrapttimeout", "extra67part", "extreme___gap", "adding_set", "extra_update", "encryptedTimeswitch", "extraTimebatch", "extra_shock", "extrajpart", "dirtypttimeout"], "a0": ["a00", "aa2", "aa0", "aa1", "ea1", "aa00", "ea2", "ea00", "ea0", " a00"], "a1": ["A11", "a11", "b11", "A1", "A01", " a11", " a01", "A2", "a01", "b01"], "a2": ["A02", "an02", " a256", "a256", "an3", "A2", "an2", "an256", "A256", "a02", " a02", "A3"], "a3": [" a4", " athree", "a4", "A2", "an2", "an4", "anthree", "athree", "A4", "A3", "Athree", "an3"], "b0": ["bb2", "B1", "bb1", "bb0", "B3", "bb3", "B2", "B0"], "b1": ["bb2", "B1", "bb1", "bb0", "a01", "b01", "B01", "B2", "B0", "bb01"], "b2": ["bb2", "B1", "bb1", "B2", " b02", "B02", "b02", "bb02"], "b3": ["c2", " b03", "b03", "B3", "c03", "B03", "B2", "c3"], "temp": ["orig", "attr", "tt", "sequence", "storage", "mint", "pool", "t", "loop", "result", "delay", "timer", "mm", "fac", "trace", "pre", "length", "method", "stem", "emp", "ta", "sum", "thread", "wait", "rem", "type", "mem", "ptr", "ret", "tr", "timeout", " tmp", "v", "test", "cell", "memory", "unt", "cum", "term", "tmp", "Temperature", "tip", "total", "tim", "level", "txt", "copy", "porary", "perm", "unit", "tem", "now", "json", "current", "sim", "buffer", "variable", "phrase", "prime", "iter", "option", "tm", "dat", "status", "cu", "tc", "output", "perature", "EMP", "pt", "cache", "em", "tree", " temperature", "condition", "alt", "time", "prefix", "mp", "fake", "mod", "var", "format", "final", "Temp", "template"]}}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,\n\n                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],\n\n                omap_clk fclk, omap_clk iclk)\n\n{\n\n    struct omap_mmc_s *s = (struct omap_mmc_s *)\n\n            g_malloc0(sizeof(struct omap_mmc_s));\n\n\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->clk = fclk;\n\n    s->lines = 4;\n\n    s->rev = 2;\n\n\n\n    omap_mmc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, \"omap.mmc\",\n\n                          omap_l4_region_size(ta, 0));\n\n    omap_l4_attach(ta, 0, &s->iomem);\n\n\n\n    /* Instantiate the storage */\n\n    s->card = sd_init(bd, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n\n\n    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];\n\n    sd_set_cb(s->card, NULL, s->cdet);\n\n\n\n    return s;\n\n}\n", "idx": 12499, "substitutes": {"ta": ["tx", "ba", "tu", "mi", "ra", "tta", "tr", "ga", "ista", "t", "la", "wa", "eta", "TA", "ada", "pha", "da", "sa", "ota", "era", "oa", "ao", "ts", "ti", "mt", "ma", "ata", "tm", "Ta", "fa", "tp", "ca", "te", "pa", "tap", "ka", "dra"], "bd": ["td", "ba", "bs", "fd", "BD", "dis", "cd", "dt", "pd", "dm", "ded", "md", "bt", " BD", "gb", "dc", "ds", "br", "da", "dd", "kb", "gd", "hd", "bm", "db", "bf", "b", "bl", "bc", "sd", "d", "dh", "bb", "vd", "bg", "bp", "BT", "ld"], "irq": ["iraq", " irqs", "IrQ", " irqu", "arq", "iraQ", "irqu", "Irq", "iraqu", "irv", " irv", "mirqu", "pirqu", "pirv", "Irqq", "pirqq", "pirqs", "arv", "mirq", "pirQ", "arqs", "mirqs", "Irqu", "arqu", "irqs", "pirq", "iraqq", "irQ", "irqq", "mirv"], "dma": ["Dms", " dmas", "pmp", "mma", "mdpa", "mdmas", "mmm", "mmp", "Dma", "dmas", "Dmm", " dms", "dme", "Dmas", "pma", "dmp", "mpa", " dmp", "amdma", "dpa", "mdma", "dmm", "mdmp", "mmas", "ppa", "amdmas", "amdmp", " dpa", " dme", " dmm", "amdpa", "pme", "mme", "dms", "mms"], "fclk": ["fplq", "fplck", " fplk", " fclks", "fclck", "fclq", " fplks", "fcolks", " fclq", " fclck", "fclks", "fplks", "fflk", "fflks", " fclkg", "fflq", " fplkg", "fplk", "fflck", "fflkg", " fplck", "fclkg", "fplkg", "fcolck", "fcolk", "fcolkg"], "iclk": ["icplke", "icclkt", "icclck", " icclke", "icplk", "icplkt", "icplck", " icclkt", " icclck", "icllk", "icclke", "icclk", "icllkt", " iclke", "iclkt", "iclck", "icllck", "iclke", "icllke", " icclk", " iclck", " iclkt"], "s": ["ses", "gs", "S", "settings", "bs", "ports", "sq", "sl", "sam", "t", "m", "stats", "vs", "states", "cs", "tests", "ims", "pers", "its", "ps", "esm", "sw", "search", "j", "n", "js", "params", "v", "g", "comm", "spec", "space", "ds", "ats", "sa", "obj", " is", "services", "ies", "sc", "sync", "args", "uploads", "set", "conf", "ers", "i", "save", "a", "f", "as", "less", "bits", "store", "source", "als", "sb", "sys", "hs", "c", "es", "changes", "fs", "se", "sports", "ss", "status", "aws", "sort", "o", "has", "tags", "l", "p", "details", "is", "sv", "ls", "r", "gets", "ts", "ins", "b", "ns", "h", "e", "sd", "os", "w", "sts", "ms", "rs", "su"]}}
{"project": "qemu", "commit_id": "dca6eeed8c2a1c131d161139428dd18a35e58b03", "target": 0, "func": "static void calxeda_init(MachineState *machine, enum cxmachines machine_id)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    DeviceState *dev = NULL;\n\n    SysBusDevice *busdev;\n\n    qemu_irq pic[128];\n\n    int n;\n\n    qemu_irq cpu_irq[4];\n\n    qemu_irq cpu_fiq[4];\n\n    MemoryRegion *sysram;\n\n    MemoryRegion *dram;\n\n    MemoryRegion *sysmem;\n\n    char *sysboot_filename;\n\n\n\n    if (!cpu_model) {\n\n        switch (machine_id) {\n\n        case CALXEDA_HIGHBANK:\n\n            cpu_model = \"cortex-a9\";\n\n            break;\n\n        case CALXEDA_MIDWAY:\n\n            cpu_model = \"cortex-a15\";\n\n            break;\n\n        }\n\n    }\n\n\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        ObjectClass *oc = cpu_class_by_name(TYPE_ARM_CPU, cpu_model);\n\n        Object *cpuobj;\n\n        ARMCPU *cpu;\n\n        Error *err = NULL;\n\n\n\n        if (!oc) {\n\n            error_report(\"Unable to find CPU definition\");\n\n            exit(1);\n\n        }\n\n\n\n        cpuobj = object_new(object_class_get_name(oc));\n\n        cpu = ARM_CPU(cpuobj);\n\n\n\n        /* By default A9 and A15 CPUs have EL3 enabled.  This board does not\n\n         * currently support EL3 so the CPU EL3 property is disabled before\n\n         * realization.\n\n         */\n\n        if (object_property_find(cpuobj, \"has_el3\", NULL)) {\n\n            object_property_set_bool(cpuobj, false, \"has_el3\", &err);\n\n            if (err) {\n\n                error_report_err(err);\n\n                exit(1);\n\n            }\n\n        }\n\n\n\n        if (object_property_find(cpuobj, \"reset-cbar\", NULL)) {\n\n            object_property_set_int(cpuobj, MPCORE_PERIPHBASE,\n\n                                    \"reset-cbar\", &error_abort);\n\n        }\n\n        object_property_set_bool(cpuobj, true, \"realized\", &err);\n\n        if (err) {\n\n            error_report_err(err);\n\n            exit(1);\n\n        }\n\n        cpu_irq[n] = qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ);\n\n        cpu_fiq[n] = qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ);\n\n    }\n\n\n\n    sysmem = get_system_memory();\n\n    dram = g_new(MemoryRegion, 1);\n\n    memory_region_allocate_system_memory(dram, NULL, \"highbank.dram\", ram_size);\n\n    /* SDRAM at address zero.  */\n\n    memory_region_add_subregion(sysmem, 0, dram);\n\n\n\n    sysram = g_new(MemoryRegion, 1);\n\n    memory_region_init_ram(sysram, NULL, \"highbank.sysram\", 0x8000,\n\n                           &error_fatal);\n\n    memory_region_add_subregion(sysmem, 0xfff88000, sysram);\n\n    if (bios_name != NULL) {\n\n        sysboot_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (sysboot_filename != NULL) {\n\n            if (load_image_targphys(sysboot_filename, 0xfff88000, 0x8000) < 0) {\n\n                hw_error(\"Unable to load %s\\n\", bios_name);\n\n            }\n\n            g_free(sysboot_filename);\n\n        } else {\n\n           hw_error(\"Unable to find %s\\n\", bios_name);\n\n        }\n\n    }\n\n\n\n    switch (machine_id) {\n\n    case CALXEDA_HIGHBANK:\n\n        dev = qdev_create(NULL, \"l2x0\");\n\n        qdev_init_nofail(dev);\n\n        busdev = SYS_BUS_DEVICE(dev);\n\n        sysbus_mmio_map(busdev, 0, 0xfff12000);\n\n\n\n        dev = qdev_create(NULL, \"a9mpcore_priv\");\n\n        break;\n\n    case CALXEDA_MIDWAY:\n\n        dev = qdev_create(NULL, \"a15mpcore_priv\");\n\n        break;\n\n    }\n\n    qdev_prop_set_uint32(dev, \"num-cpu\", smp_cpus);\n\n    qdev_prop_set_uint32(dev, \"num-irq\", NIRQ_GIC);\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, MPCORE_PERIPHBASE);\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        sysbus_connect_irq(busdev, n, cpu_irq[n]);\n\n        sysbus_connect_irq(busdev, n + smp_cpus, cpu_fiq[n]);\n\n    }\n\n\n\n    for (n = 0; n < 128; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    dev = qdev_create(NULL, \"sp804\");\n\n    qdev_prop_set_uint32(dev, \"freq0\", 150000000);\n\n    qdev_prop_set_uint32(dev, \"freq1\", 150000000);\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, 0xfff34000);\n\n    sysbus_connect_irq(busdev, 0, pic[18]);\n\n    sysbus_create_simple(\"pl011\", 0xfff36000, pic[20]);\n\n\n\n    dev = qdev_create(NULL, \"highbank-regs\");\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, 0xfff3c000);\n\n\n\n    sysbus_create_simple(\"pl061\", 0xfff30000, pic[14]);\n\n    sysbus_create_simple(\"pl061\", 0xfff31000, pic[15]);\n\n    sysbus_create_simple(\"pl061\", 0xfff32000, pic[16]);\n\n    sysbus_create_simple(\"pl061\", 0xfff33000, pic[17]);\n\n    sysbus_create_simple(\"pl031\", 0xfff35000, pic[19]);\n\n    sysbus_create_simple(\"pl022\", 0xfff39000, pic[23]);\n\n\n\n    sysbus_create_simple(\"sysbus-ahci\", 0xffe08000, pic[83]);\n\n\n\n    if (nd_table[0].used) {\n\n        qemu_check_nic_model(&nd_table[0], \"xgmac\");\n\n        dev = qdev_create(NULL, \"xgmac\");\n\n        qdev_set_nic_properties(dev, &nd_table[0]);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff50000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[77]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[78]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[79]);\n\n\n\n        qemu_check_nic_model(&nd_table[1], \"xgmac\");\n\n        dev = qdev_create(NULL, \"xgmac\");\n\n        qdev_set_nic_properties(dev, &nd_table[1]);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff51000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[80]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[81]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[82]);\n\n    }\n\n\n\n    highbank_binfo.ram_size = ram_size;\n\n    highbank_binfo.kernel_filename = kernel_filename;\n\n    highbank_binfo.kernel_cmdline = kernel_cmdline;\n\n    highbank_binfo.initrd_filename = initrd_filename;\n\n    /* highbank requires a dtb in order to boot, and the dtb will override\n\n     * the board ID. The following value is ignored, so set it to -1 to be\n\n     * clear that the value is meaningless.\n\n     */\n\n    highbank_binfo.board_id = -1;\n\n    highbank_binfo.nb_cpus = smp_cpus;\n\n    highbank_binfo.loader_start = 0;\n\n    highbank_binfo.write_secondary_boot = hb_write_secondary;\n\n    highbank_binfo.secondary_cpu_reset_hook = hb_reset_secondary;\n\n    arm_load_kernel(ARM_CPU(first_cpu), &highbank_binfo);\n\n}\n", "idx": 12544, "substitutes": {"machine": ["node", "server", "instance", "view", "money", "manager", "hard", "mode", "series", "managed", "module", "linux", "smart", "model", "check", "monitor", "frame", "engine", "domain", "space", "command", "Machine", "connection", "m", "power", "zone", "menu", "vm", "sim", "iso", "handler", "one", "keeper", "link", "alias", "device", "mc", "host", "state", "achine", "history", "network", "process", "template", "normal", "computer"], "machine_id": ["node_name", "node_id", "machine_key", " machine_ids", " machine_pid", " machine_no", "machine_no", "node_key", "machine_pid", "machine_ip", "machine_ids", "machine_name", "node_ip"], "cpu_model": ["linuxtimemodel", "pu_mode", "gpu_label", "linux_model", "pu_model", "cputimemodel", "cpu_link", "cputimemode", "cpu_machine", "linux_mode", "cpu_brand", "cpu_config", "pu_type", "cpu_label", "cpu_mode", "cpu_method", "processor_mode", "gpu_Model", "processor_method", "pu_Model", "cpu_tag", "processor_model", "cpu_type", "cputimetag", "pu_controller", "processor_config", " cpu_brand", "gpu_model", "linuxtimetag", "pu_link", "cpu_controller", "gpu_type", "pu_brand", " cpu_machine", " cpu_type", "cpu_Model", "linuxtimemode", "linux_tag"], "kernel_filename": ["system_file", "kernelitydll", "kernel_source", "kernelitylicense", "proc_filename", "kernelityfile", "kernel_dll", "system_license", "kernel_directory", "proc_source", "kernelityfilename", "proc_files", "system_dll", "proc_directory", "kernel_file", "kernel_license", "system_filename", "kernel_files"], "kernel_cmdline": ["kernel_bindline", "kernel_bindlines", "kernel_deadlines", "kernel_commandLine", "kernel_commandpath", "kernel_commandline", "kernel_cmdLine", "kernel_cmdstring", "kernel_cmdlines", "kernel_commandlines", "kernel_payLine", "kernel_deadstring", "kernel_cmdpath", "kernel_commandstring", "kernel_bindLine", "kernel_deadline", "kernel_bindpath", "kernel_payline", "kernel_paypath", "kernel_bindstring"], "initrd_filename": ["initrd__location", "initrr_files", "initrd_Filename", "initrd_files", "initrd__Filename", "initrd__files", "initrd_file", "initrr_location", "initrr_filename", "initrd__filename", "initrb_file", "initrd_location", "initrb_files", "initrb_filename", "initrb_fn", "initrr_Filename", "initrd_fn"], "dev": ["def", "mem", "DEV", "conn", "serv", "cmd", "hw", "Dev", "proc", "priv", "di", "sys", "ds", "scan", "cam", "kr", "disk", "obj", "env", "device", "conf", "sd", "ev", "w", "av", "ch"], "busdev": ["blockDev", "busdevice", "bootdev", "blockinfo", "bootinfo", "busDev", "bootdevice", " businfo", "blockdev", "bootDev", " busDev", "businfo", "blockdevice", " busdevice"], "pic": ["mi", "sta", "mic", "lib", "si", "fif", "picture", "pin", "bi", "mac", "gb", "icc", "sa", "isi", " nic", "sp", "script", "Pic", "sync", "gc", "mc", "nic", "pc", "cow", "arc", "sc", "str", "ic"], "n": ["ni", " ns", " c", "nor", "nw", "o", "out", "number", " j", " fn", " iter", "cn", "dn", "j", " num", " nu", "ln", "p", "x", "names", " count", "v", " number", "g", "ng", " N", "na", "len", "t", " k", "np", "tn", "num", "nr", "nt", "m", "N", "wn", "k", "y", "gn", " i", "c", "count", "nc", "en", "no", "ns", "un", "h", "con", " len", " p", "d", "nb", " m", "ne", "z", "nia", " ng", "yn", "nan", "i", "sn", "mn", "w", "an", "nu", "nn"], "cpu_irq": ["cpu__irue", "cpu__irq", "cpu__rinz", "cpu_mirq", "cpu_ireqs", "cpu__irqs", "cpu__rinue", "cpu_irms", "cpu__irz", "cpu_irqs", "cpu_iraq", "cpu_iraQ", "cpu_irams", "cpu_mirqs", "cpu__rinq", "cpu_irp", "cpu_rinp", "cpu__rinms", "cpu_fiQ", "cpu_irQ", "cpu__rinqs", "cpu_irz", "cpu_rinQ", "cpu_irez", "cpu_rinqs", "cpu_rinq", "cpu__rinp", "cpu_rinue", "cpu_fiue", "cpu_mirz", "cpu__irms", "cpu_rinms", "cpu_irep", "cpu_irue", "cpu_rinz", "cpu_ireq", "cpu__irQ", "cpu_mirp", "cpu_fims", "cpu__rinQ", "cpu_iraue", "cpu__irp"], "cpu_fiq": ["cpu_tiqs", "cpu_tiq", "cpu_fiqs", "cpu_faq", "cpu_tiQ", "cpu_faqs", "cpu_irqs", "cpu_faue", "cpu_tiue", "cpu_fiQ", "cpu_irQ", "cpu_faQ", "cpu_fiue", "cpu_irue"], "sysram": ["Syscpu", "systemram", "yscpu", "sysgram", "ysram", "Sysram", "systemmem", "ysmem", "systemgram", "ysgram", "syscpu", "systemcpu", "Sysgram", "Sysmem"], "dram": ["ydgram", "ddgram", "ddram", "ydsam", "dgram", "dssam", "ddmem", "ydram", "ydmem", "dsmem", "ddsam", "dsgram", "dmem", "dsram", "dsam"], "sysmem": ["sysmi", "yscpu", "symem", "systemmi", "systemmem", "ysmem", "symi", "sycpu", "syscpu", "systemcpu", "ysmi"], "sysboot_filename": ["sysboot_location", "sysboot_file", "sysboot_files", "sysmem_filename", "sysmem_location", "sysboot__filename", "sysmem_file", "sysboot__location", "sysboot__file", "sysmem_files", "sysboot__files"], "oc": ["co", "unc", "o", "ock", "ico", "ok", "ocr", "or", "erc", "oop", "ong", "ocation", "orp", "aco", "oco", "toc", "voc", "ox", "dc", "oad", "OC", "og", "ac", "roc", "ost", "nc", "ec", "oci", "ocon", "nic", "oid", "soc", "osc", "pc", "AC", "ot", "os", "yo", "arc", "cot", "ic", "ob", "alloc"], "cpuobj": ["linuxarr", "cpObj", "linuxact", "puinst", "cpuctr", "puObj", "pixelbj", " cpuact", "linuxobj", "cpuObj", "cpuconn", "cuinst", "cutmp", "linuxct", "CPUjs", "nicobj", "cpuarr", " cpujs", "cpuct", "cuobj", "niccod", "uuinst", "cpctr", "puconn", "CPUobj", "cpucod", "nicobject", "linuxObj", "pixelObj", "puact", "uuconn", "gpuobj", " cpuctr", "uuobj", "pubj", "cpujs", "pixeltmp", "pixelobj", "coreobj", "cpuopt", "gpucod", "puopt", "gpuObj", "cpubj", "corejs", "cpobj", "linuxjs", "pucod", " cpubj", "cpuinst", "CPUarr", "cpuobject", "cuconn", "putmp", "puct", "linuxobject", " cpuobject", "pujs", "CPUObj", "nicObj", "cpobject", " cpuObj", "puarr", " cpuct", "linuxctr", " cpuopt", "pixelconn", "coreopt", "cpuact", "gpuobject", "puobj", "cubj", "uuObj", "puobject", "cputmp", "cuObj", " cpuconn", "corebj"], "cpu": ["pro", "cu", "pu", "CPU", "mem", "alloc", "cn", "ctx", "core", "hw", "cmp", "proc", "ilo", "aco", "util", "cache", "np", "processor", "uu", "memory", "obj", "vm", "mu", "ro", "cv", "cum", "po", "gc", "cp", "nic", "gp", "rom", "pc", "gpu", "prof", "process", "nu", "clock"], "err": ["resp", "erm", "rc", "notice", "errors", "error", "cr", "virt", "exc", "lr", "usr", "bug", "attr", "hz", "ner", "aaa", "mr", "ocr", "dr", "erd", "str", "req", "cli", "eor", "try", "test", "rr", "cer", "ger", "er", "msg", "buf", "priv", "br", "cfg", "r", "kr", "fee", "obj", "norm", "rs", "cb", "eric", "drm", "ec", "gr", "res", "der", "die", "Er", "term", "fr", "here", "inner", "eas", "iter", "order", "conf", "e", "gz", "ev", "rx", "rn", "txt", "arr", "later"]}}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "static int get_phys_addr_v5(CPUState *env, uint32_t address, int access_type,\n\n\t\t\t    int is_user, uint32_t *phys_ptr, int *prot)\n\n{\n\n    int code;\n\n    uint32_t table;\n\n    uint32_t desc;\n\n    int type;\n\n    int ap;\n\n    int domain;\n\n    uint32_t phys_addr;\n\n\n\n    /* Pagetable walk.  */\n\n    /* Lookup l1 descriptor.  */\n\n    table = get_level1_table_address(env, address);\n\n    desc = ldl_phys(table);\n\n    type = (desc & 3);\n\n    domain = (env->cp15.c3 >> ((desc >> 4) & 0x1e)) & 3;\n\n    if (type == 0) {\n\n        /* Section translation fault.  */\n\n        code = 5;\n\n        goto do_fault;\n\n    }\n\n    if (domain == 0 || domain == 2) {\n\n        if (type == 2)\n\n            code = 9; /* Section domain fault.  */\n\n        else\n\n            code = 11; /* Page domain fault.  */\n\n        goto do_fault;\n\n    }\n\n    if (type == 2) {\n\n        /* 1Mb section.  */\n\n        phys_addr = (desc & 0xfff00000) | (address & 0x000fffff);\n\n        ap = (desc >> 10) & 3;\n\n        code = 13;\n\n    } else {\n\n        /* Lookup l2 entry.  */\n\n\tif (type == 1) {\n\n\t    /* Coarse pagetable.  */\n\n\t    table = (desc & 0xfffffc00) | ((address >> 10) & 0x3fc);\n\n\t} else {\n\n\t    /* Fine pagetable.  */\n\n\t    table = (desc & 0xfffff000) | ((address >> 8) & 0xffc);\n\n\t}\n\n        desc = ldl_phys(table);\n\n        switch (desc & 3) {\n\n        case 0: /* Page translation fault.  */\n\n            code = 7;\n\n            goto do_fault;\n\n        case 1: /* 64k page.  */\n\n            phys_addr = (desc & 0xffff0000) | (address & 0xffff);\n\n            ap = (desc >> (4 + ((address >> 13) & 6))) & 3;\n\n            break;\n\n        case 2: /* 4k page.  */\n\n            phys_addr = (desc & 0xfffff000) | (address & 0xfff);\n\n            ap = (desc >> (4 + ((address >> 13) & 6))) & 3;\n\n            break;\n\n        case 3: /* 1k page.  */\n\n\t    if (type == 1) {\n\n\t\tif (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n\t\t    phys_addr = (desc & 0xfffff000) | (address & 0xfff);\n\n\t\t} else {\n\n\t\t    /* Page translation fault.  */\n\n\t\t    code = 7;\n\n\t\t    goto do_fault;\n\n\t\t}\n\n\t    } else {\n\n\t\tphys_addr = (desc & 0xfffffc00) | (address & 0x3ff);\n\n\t    }\n\n            ap = (desc >> 4) & 3;\n\n            break;\n\n        default:\n\n            /* Never happens, but compiler isn't smart enough to tell.  */\n\n            abort();\n\n        }\n\n        code = 15;\n\n    }\n\n    *prot = check_ap(env, ap, domain, access_type, is_user);\n\n    if (!*prot) {\n\n        /* Access permission fault.  */\n\n        goto do_fault;\n\n    }\n\n    *phys_ptr = phys_addr;\n\n    return 0;\n\ndo_fault:\n\n    return code | (domain << 4);\n\n}\n", "idx": 12545, "substitutes": {"env": ["server", "esm", "conn", "ptr", "manager", "exc", "environment", "cur", "estate", "cmd", "ctx", "hw", "email", "window", "erd", "vp", "v", "store", "esc", "sb", "er", "end", "shell", "context", "ah", "ew", "gate", "vm", "self", "sp", "en", "ec", "vs", "dev", "h", "set", "e", "conf", "entry", "enter", "config", "eng", "eh", "ev", "sc", "te", "pe", "equ"], "address": ["index", "port", "result", "command", "word", "attribute", "add", "document", "location", "property", "trace", " Address", "error", "ptr", "array", "number", "object", "addr", "email", "resource", "memory", "comment", "alias", "device", "term", "interface", "form", "ip", "network", "a", "record", "ref", "reference", "adr", "store", "service", "date", "offset", "operation", "description", "phrase", "Address", "application", "request", "route", "position", "entity", "size", "response", "chain", "act", "message", "gate", "image", "event", "base", "page", "password", "action", "host", "order", "point", "ace", "entry", "value", "controller", "pointer", "ase"], "access_type": ["accessuretype", "privuretype", "accessuremode", "accessuretypes", "priv_mode", "access_types", "accessoptypes", "access_typ", "priv_type", "privuretypes", "access_mode", "privuremode", "accessoptype", "privuretyp", "accessopmode", "accessuretyp", "priv_types", "accessoptyp", "priv_typ"], "is_user": ["is_used", "is_valid", " is_uid", " is_valid", "is_uid", " is_used"], "phys_ptr": ["phys2ptr", "phys2pad", "sys_pad", "phys_pad", "phys2obj", "phys_obj", "phys2addr", "sys_ptr", "sys_obj", "sys_addr"], "prot": ["pro", "td", " protocol", "ref", " port", "seq", "addr", "typ", "security", "next", "test", "port", "chain", "ping", "ocol", "Prot", "ef", "policy", "ext", " proto", "eth", "pos", "password", " seq", "net", "prop", "priority", "ip"], "code": ["index", "sequence", " count", "check", "close", "rate", "lock", "line", "fee", "change", "xc", "see", "Code", "ae", "rc", "error", "co", "try", "test", "next", "th", "comment", "use", "nc", "cycle", "ter", "out", "call", "cc", "store", "zone", "ie", "age", "c", "ci", "id", "pc", "scene", "state", "err", "se", "cast", "ode", "second", "force", "status", "go", "codes", "size", " error", "mode", "stay", "cd", "done", "frame", "cache", "message", "time", "count", "event", "page", "create", "content", "ice", "die", "reason", "e", "order", "entry", "component", "coe", "ne", "cause", "ce", "ch"], "table": ["index", "stable", "plain", "td", "dict", "record", "array", "ref", "translation", "section", "map", "scope", "body", "tr", "module", "where", "chain", "port", "batch", "store", "Table", "t", "cache", "able", "tree", "description", "comment", "container", "buffer", "block", "console", "db", "count", "page", "base", "file", "bl", "term", "binary", "tmp", "order", "database", "angle", "trace", "list", "ape", "point", "entry", "filter", "TABLE", "ca", "tab"], "desc": ["td", "attr", "ctx", "cmp", "typ", "loc", "result", "word", "doc", "disc", "en", "summary", "der", "label", "length", "cont", "rc", "def", "error", "des", "mem", "ptr", "addr", "cmd", "tr", "dt", "md", "dist", "obj", "comment", "dem", "dest", "deb", "flag", "term", "dep", "total", "tab", "txt", "sub", "resp", " Desc", "seq", "row", "cod", "req", "adr", "sec", "buf", "usc", "description", "info", "progress", "empty", "phrase", "ec", "dev", "config", "err", "str", "Desc", "asc", "sort", "dict", "size", "pb", "ord", "dir", "cd", "DES", "ript", "ent", "done", "esc", "msg", "dc", "diff", "ext", "tag", "message", "decl", "page", "password", "rec", "order", "entry", "col", "name", "sc", "adj"], "type": ["index", "types", "key", "error", "ty", "Type", "version", "ver", "size", "scope", "p", "class", "group", "role", "module", "operator", "typ", "dt", "try", "test", "port", "field", "t", "unit", "ping", "kind", "rank", "title", "currency", "op", "tag", "part", "status", "time", "magic", "range", "TYPE", "count", "day", "function", "flag", "color", "action", "ype", "id", "term", "order", "state", "length", "tp", "shape", "country", "style", "format", "level", "name", "pe"], "ap": ["arp", "at", "ptr", "attr", "addr", "map", "ag", "p", "apa", "or", "cod", "ar", "cap", "apped", "ab", "offset", "op", "att", "snap", "aps", "rep", "html", "ac", "api", "sp", "art", "db", "pos", "ep", "AP", "pac", "wp", "apt", "mp", "pc", "acl", "ach", "app", "pad", "ape", "af", "amp", "tp", "pa", "adj", "tap", "rap", "ip"], "domain": ["node", "server", "index", "status", "region", "virt", "conn", "addr", "scope", "depth", "module", "dir", "chain", "port", "field", "unit", "rate", "origin", "rank", "currency", "lang", "web", "dom", "zone", "description", "channel", "gate", "url", "org", "range", "prefix", "magic", "site", "db", "page", "base", "top", "flag", "root", "example", "id", "host", "order", "confirmed", "Domain", "tip", "d", "country", "net", "value", "angle"], "phys_addr": ["phys_store", "physicalegg", "phys__addr", "physacaddr", "phys_address", "physmladdress", "phys___adr", "phys2addr", "phys__ptr", "phys_egg", "phys2egg", "physicaladdr", "phys_attr", "Phys__adr", "physipaddress", "physical_ptr", "phys___ptr", " phys_address", "physical_store", "phys__store", "physmlstore", "physacadd", "phys_add", "phys2ptr", " phys_add", "phys__adr", "Phys__ptr", "phys__address", "physipaddr", "physacptr", "physacaddress", " phys_attr", "phys___addr", "Phys_adr", "Phys_ptr", "physipadd", "physmlptr", "physicalptr", "phys_adr", "physipptr", "physical_adr", "physmladdr", "physical_addr", " phys_egg", "Phys_addr", "Phys__addr", "physical_address"]}}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static void vmxnet3_update_mcast_filters(VMXNET3State *s)\n\n{\n\n    uint16_t list_bytes =\n\n        VMXNET3_READ_DRV_SHARED16(s->drv_shmem,\n\n                                  devRead.rxFilterConf.mfTableLen);\n\n\n\n    s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);\n\n\n\n    s->mcast_list = g_realloc(s->mcast_list, list_bytes);\n\n    if (!s->mcast_list) {\n\n        if (s->mcast_list_len == 0) {\n\n            VMW_CFPRN(\"Current multicast list is empty\");\n\n        } else {\n\n            VMW_ERPRN(\"Failed to allocate multicast list of %d elements\",\n\n                      s->mcast_list_len);\n\n        }\n\n        s->mcast_list_len = 0;\n\n    } else {\n\n        int i;\n\n        hwaddr mcast_list_pa =\n\n            VMXNET3_READ_DRV_SHARED64(s->drv_shmem,\n\n                                      devRead.rxFilterConf.mfTablePA);\n\n\n\n        pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, list_bytes);\n\n\n\n        VMW_CFPRN(\"Current multicast list len is %d:\", s->mcast_list_len);\n\n        for (i = 0; i < s->mcast_list_len; i++) {\n\n            VMW_CFPRN(\"\\t\" MAC_FMT, MAC_ARG(s->mcast_list[i].a));\n\n        }\n\n    }\n\n}\n", "idx": 12548, "substitutes": {"s": ["ses", "gs", "S", "settings", "bs", "ports", "sq", "stat", "sl", "t", "m", "qs", "stats", "vs", "states", "cs", "ims", "its", "https", "ps", "esm", "sw", "n", "js", "v", "http", "comm", "spec", "ds", "ats", "obj", "services", "ies", "so", "args", "set", "parts", "ex", "south", "less", "eps", "xs", "store", "source", "als", "sb", "hs", "sys", "ops", "es", "changes", "fs", "events", "d", "reads", "sports", "ss", "comments", "status", "aws", "serv", "o", "p", "details", "is", "sv", "ls", "r", "gets", "ts", "ns", "b", "h", "os", "w", "sts", "y", "rs"], "i": ["index", "key", "li", "a", "iu", "o", "oi", "mi", "ii", "I", "pi", "ind", "ini", "j", "ski", "ki", "ei", "uri", "si", "n", "zi", "cli", "g", "gu", "bi", "t", "us", "is", "ui", "di", "ami", "ai", "m", "in", "hi", "xi", "qi", "sim", "im", "\u0438", "ci", "ims", "ti", "ri", "u", "multi", "it", "gi", "err", "me", "MI", "phi", "init", "x", "y", "ic", "ix", "ip"]}}
{"project": "FFmpeg", "commit_id": "7546964f96168cd6ac819ef4c3212ee586619f1a", "target": 0, "func": "int ff_nvdec_decode_init(AVCodecContext *avctx, unsigned int dpb_size)\n\n{\n\n    NVDECContext *ctx = avctx->internal->hwaccel_priv_data;\n\n\n\n    NVDECFramePool      *pool;\n\n    AVHWFramesContext   *frames_ctx;\n\n    const AVPixFmtDescriptor *sw_desc;\n\n\n\n    CUVIDDECODECREATEINFO params = { 0 };\n\n\n\n    int cuvid_codec_type, cuvid_chroma_format;\n\n    int ret = 0;\n\n\n\n    sw_desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);\n\n    if (!sw_desc)\n\n        return AVERROR_BUG;\n\n\n\n    cuvid_codec_type = map_avcodec_id(avctx->codec_id);\n\n    if (cuvid_codec_type < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported codec ID\\n\");\n\n        return AVERROR_BUG;\n\n    }\n\n\n\n    cuvid_chroma_format = map_chroma_format(avctx->sw_pix_fmt);\n\n    if (cuvid_chroma_format < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported chroma format\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->thread_type & FF_THREAD_FRAME)\n\n        dpb_size += avctx->thread_count;\n\n\n\n    if (!avctx->hw_frames_ctx) {\n\n        AVHWFramesContext *frames_ctx;\n\n\n\n        if (!avctx->hw_device_ctx) {\n\n            av_log(avctx, AV_LOG_ERROR, \"A hardware device or frames context \"\n\n                   \"is required for CUVID decoding.\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);\n\n        if (!avctx->hw_frames_ctx)\n\n            return AVERROR(ENOMEM);\n\n        frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n\n\n        frames_ctx->format            = AV_PIX_FMT_CUDA;\n\n        frames_ctx->width             = avctx->coded_width;\n\n        frames_ctx->height            = avctx->coded_height;\n\n        frames_ctx->sw_format         = AV_PIX_FMT_NV12;\n\n        frames_ctx->sw_format         = sw_desc->comp[0].depth > 8 ?\n\n                                        AV_PIX_FMT_P010 : AV_PIX_FMT_NV12;\n\n        frames_ctx->initial_pool_size = dpb_size;\n\n\n\n        ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Error initializing internal frames context\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n    frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n\n\n    params.ulWidth             = avctx->coded_width;\n\n    params.ulHeight            = avctx->coded_height;\n\n    params.ulTargetWidth       = avctx->coded_width;\n\n    params.ulTargetHeight      = avctx->coded_height;\n\n    params.bitDepthMinus8      = sw_desc->comp[0].depth - 8;\n\n    params.OutputFormat        = params.bitDepthMinus8 ?\n\n                                 cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12;\n\n    params.CodecType           = cuvid_codec_type;\n\n    params.ChromaFormat        = cuvid_chroma_format;\n\n    params.ulNumDecodeSurfaces = dpb_size;\n\n    params.ulNumOutputSurfaces = 1;\n\n\n\n    ret = nvdec_decoder_create(&ctx->decoder_ref, frames_ctx->device_ref, &params, avctx);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    pool = av_mallocz(sizeof(*pool));\n\n    if (!pool) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    pool->dpb_size = dpb_size;\n\n\n\n    ctx->decoder_pool = av_buffer_pool_init2(sizeof(int), pool,\n\n                                             nvdec_decoder_frame_alloc, av_free);\n\n    if (!ctx->decoder_pool) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    return 0;\n\nfail:\n\n    ff_nvdec_decode_uninit(avctx);\n\n    return ret;\n\n}\n", "idx": 12556, "substitutes": {"avctx": ["avtx", "iverctx", "wavcmp", "vertx", "avercfg", "avmsg", "navctx", "avetmp", "ovtmp", "avercrit", "avercontext", "iverdoc", "ovcmp", "ovctl", "avpkg", "avhandle", "averwcs", "afcmp", "avtmp", "avecb", "varcontext", "vercontext", "afpkg", "ajkl", " avdocument", "devtx", "avertx", "wavhandle", " avcontext", "ajtxt", " avctl", "wavtx", "avejp", "afstat", "avcfg", "wavctx", "avermsg", "averkl", "aftmp", "wavcb", "avcmp", "wavcrit", " avobj", "ovctx", "awctx", "savdocument", " avtxt", "avkl", "varctx", "navkl", " avgc", "afctl", "savctx", "avecrit", "avcb", "awkl", "devctl", "avecontext", " avconf", "aftx", " avdoc", "avgc", "avetx", "avewcs", "averctl", "avergc", "verctx", "ajtmp", " avcfg", "averstat", "avertmp", "devcontext", "avekt", "ajcmp", "avtxt", "varjac", "ovstat", "averjp", "cvctx", "afjac", "ivertx", "avdocument", "savtx", " avconn", "awconn", "savcontext", "wavpkg", "averpkg", "afcontext", "ajcontext", "avekl", "devctx", "aveconf", "avstat", "verjac", "avertxt", "afctx", "averhandle", "averctx", "ajgc", "ajjac", "avjp", "avconf", " avjac", "cvctl", "vartx", " avstat", "avkt", "avconn", "wavstat", "avecmp", "afcfg", "aveconn", "afmsg", "avercb", "wavkl", "iverobj", "wavmsg", "avcrit", "avjac", "avobj", "awcrit", "ajwcs", "avctl", "wavcontext", "avcontext", "avepkg", "avegc", "aveobj", "navkt", "savjac", "cvcontext", " avhandle", "averconf", "ajctx", "ajconn", " avtx", "navtmp", "averconn", "avectx", "wavcfg", "ajkt", "ajstat", "avwcs", "avdoc", "wavconn", "ovjac", "wavdocument", " avjp", "averjac", "avedoc", "cvtx"], "dpb_size": ["dpB_Size", "dpb_count", "dpb_offset", "dpb8len", "dpb8Size", "dpw_Size", "dpb_Size", "dpb_SIZE", "dpB_offset", "dpw_len", "dpb8count", "dpw_size", "dpb8size", "dpw_count", "dpB_size", "dpb_len", "dpB_SIZE"], "ctx": ["tx", "kw", "cf", "tc", "conn", "cond", " context", "cmd", "hw", "cmp", "cc", "cas", "conv", "act", "ct", "cl", "cfg", "context", "obj", " cx", "cb", "xc", "cp", "tmp", "conf", "pkg", "txt", "jac"], "pool": ["tx", "mem", "conn", "socket", "ref", "p", "window", "timeout", " pools", "chain", "port", "batch", "box", "cache", "buf", "cpu", "policy", "cam", "Pool", "parent", "prefix", "buffer", "cp", " pooled", "col", "ool", "pkg"], "frames_ctx": ["thumbnails_exp", "framesetkt", "faces_tc", "frames_cu", "banks_cu", "flows_ctx", "framesETurg", "framesettmp", "frames_context", "frames_tc", "frames___cp", "frames_urg", "frames_tmp", "frames_kt", "framesettx", "frames_ctl", " frames_txt", "flows_cp", " frames_tmp", " frames_alloc", "faces_ctx", "frames_alloc", "faces_context", "Frames_tx", "faces_pkg", "framesETgrad", "frames___tx", "thumbnails_pkg", "frames_exp", "frames_txt", "frames_tx", "flows_kt", "frames_pkg", "framesetctx", "framesETctx", "framesETtx", "Frames_urg", "banks_tx", "frames___ctx", "frames\u05bccp", "frames\u05bcctx", "flows_tx", "thumbnails_cp", "frames_cp", "thumbnails_ctx", "banks_ctl", "Frames_grad", "frames\u05bcpkg", "banks_ctx", "frames\u05bcexp", " frames_tx", "frames___kt", "frames_grad", " frames_kt", "Frames_ctx"], "sw_desc": ["sw_tmp", "sw_decl", "sw_des", "swkttmp", "swktdecl", " Sw_desc", " sw_des", " sw_conn", "swktdesc", " Sw_tmp", "sw_conn", "sw2tmp", "sw2decl", " sw_cont", "sw_cont", "sw_Desc", " Sw_decl", " sw_Desc", "sw2desc", " sw_ds", "sw_ds"], "cuvid_codec_type": ["cuvid_codel_type", "cuvid_codix_id", "cuvid_codec__id", "cuvid_codec__Type", "cuvid_codel_id", "cuvid_codec_value", "cuvid_coddec_type", "cuvid_codec__type", "cuvid_codec_class", "cuvid_codec__class", "cuvid_codel_name", "cuvid_codec_kind", "cuvid_coddec_id", "cuvid_codix_type", "cuvid_codec__name", "cuvid_coddec_name", "cuvid_codec__value", "cuvid_codix_class", "cuvid_codel_kind", "cuvid_codix_value", "cuvid_codec_name", "cuvid_codec_id", "cuvid_codec_Type", "cuvid_coddec_Type"], "cuvid_chroma_format": ["cuvid_chroma_fact", "cuvid_chroma2format", "cuvid_chroma_form", "cuvid_chroma00format", "cuvid_chroma__format", "cuvid_chromA_style", "cuvid_chroma2unit", "cuvid_chromA_format", "cuvid_chromA_fact", "cuvid_chromA_type", "cuvid_chroma2form", "cuvid_chroma00form", "cuvid_chroma__style", "cuvid_chroma__form", "cuvid_chroma_type", "cuvid_chromA_form", "cuvid_chroma__type", "cuvid_chroma00fact", "cuvid_chroma2type", "cuvid_chroma_style", "cuvid_chromA_unit", "cuvid_chroma00type", "cuvid_chroma_unit"]}}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "void hmp_info_snapshots(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockDriverState *bs, *bs1;\n\n    QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s;\n\n    int nb_sns, i, ret, available;\n\n    int total;\n\n    int *available_snapshots;\n\n\n\n    bs = find_vmstate_bs();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No available block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n\n\n    nb_sns = bdrv_snapshot_list(bs, &sn_tab);\n\n    if (nb_sns < 0) {\n\n        monitor_printf(mon, \"bdrv_snapshot_list: error %d\\n\", nb_sns);\n\n        return;\n\n    }\n\n\n\n    if (nb_sns == 0) {\n\n        monitor_printf(mon, \"There is no snapshot available.\\n\");\n\n        return;\n\n    }\n\n\n\n    available_snapshots = g_malloc0(sizeof(int) * nb_sns);\n\n    total = 0;\n\n    for (i = 0; i < nb_sns; i++) {\n\n        sn = &sn_tab[i];\n\n        available = 1;\n\n        bs1 = NULL;\n\n\n\n        while ((bs1 = bdrv_next(bs1))) {\n\n            if (bdrv_can_snapshot(bs1) && bs1 != bs) {\n\n                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);\n\n                if (ret < 0) {\n\n                    available = 0;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (available) {\n\n            available_snapshots[total] = i;\n\n            total++;\n\n        }\n\n    }\n\n\n\n    if (total > 0) {\n\n        bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, NULL);\n\n        monitor_printf(mon, \"\\n\");\n\n        for (i = 0; i < total; i++) {\n\n            sn = &sn_tab[available_snapshots[i]];\n\n            bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, sn);\n\n            monitor_printf(mon, \"\\n\");\n\n        }\n\n    } else {\n\n        monitor_printf(mon, \"There is no suitable snapshot available\\n\");\n\n    }\n\n\n\n    g_free(sn_tab);\n\n    g_free(available_snapshots);\n\n\n\n}\n", "idx": 12558, "substitutes": {"mon": ["med", "plain", "annot", "meter", "mer", "conn", "ston", "mi", "pen", "onet", "det", "mic", "hog", "admin", "cmd", "ren", "man", "dis", "chron", "dm", "monitor", "unit", "comm", "den", "mont", "Mon", "tem", "util", "num", "cat", "m", "amon", " monitor", "ann", "dom", "gor", "sim", "MON", "san", "mu", "gun", "gran", "mm", "mut", "demon", "mas", "don", "met", "tom", "mat", "mt", "von", "rain", "my", "non", "con", "hon", "net", "monkey", "mons", "mn", "an", "mun", "mx", "form"], "qdict": ["qd", "sqdir", "Qd", " qdir", " qict", "Qdict", "sqict", "sqdict", "qdir", "Qdir", "sqd", "Qict", " qd", "qict"], "bs": ["gs", "ubs", "ists", "obs", "aos", "ys", "pb", "hz", "js", "bits", "bh", "bi", "bes", "sb", "sys", "cks", "ds", "ls", "bn", "obj", "BS", "bu", "ts", "bos", "bm", "cb", "stats", "base", "bas", "vs", "res", "b", "ns", "bl", "cs", "bc", "lbs", "bed", "bles", "fs", "bps", "os", "bis", "bb", "its", "ps"], "bs1": ["ns3", "bos0", "bsx", "bc0", "tsone", "bsnew", "BS9", "lbsone", "cs9", "cksx", "cks10", "bh1", "absnew", "cs1", "bps01", "js1", "cks11", "sb2", "lbsOne", "bos2", "bos1", "psOne", "bs5", "cs5", "ps3", "cks01", "bsOne", "jsOne", "bs01", "ts11", "bps11", "cs2", "cs01", "bc1", "bpsone", "BS1", "cks5", "bs2", "ts1", "ps11", "csOne", "cksone", "ts10", "bps1", "bs0", "cks2", "bs11", "psone", "ns9", "bpsnew", "bsone", "bhOne", "lbs1", "cks9", "bs3", "bos9", "sb5", "cs0", "cksnew", "ns1", "ns0", "bh01", "sb9", "abs01", "BS2", "ps1", "abs1", "bps10", "bpsx", "bh0", "ns2", "cs3", "jsone", "ps2", "cks1", "bs9", "absx", "bs10", "bc01", "bcOne", "sb1", "lbs11", "js11", "BS0", "ps0"], "sn_tab": ["n_Tab", "pn_bag", "sn_bed", "ns_ct", "pn_info", "sn__Tab", "sn__tmp", "sn__tab", "snpttab", "pn_tab", "SN_Tab", "ns__info", "SN_info", "snpttmp", "ns__tab", "pn_stab", "sn2info", "sn_ct", "sn_list", "ns__ct", "n_tab", "ns__Tab", "SN_list", "n__tab", "ns_info", "n__Tab", "ns_tab", "sn__info", "sn2list", "n_tmp", "sn2stab", "sn__ct", "sn2Tab", "SN_tab", "sn_bag", "snptTab", "sn_stab", "sn_Tab", "ns_Tab", "sn2bag", "SN_bed", "sn2tab", "n__tmp", "sn_tmp"], "sn": ["sql", "nl", "ni", "sw", "serv", "dn", "cn", "n", "p", "ln", "si", "stat", "sq", "sl", "Sn", "sam", "syn", "sb", "sv", "st", "SN", "tn", "np", "nr", "ls", "nt", "sa", "nat", "snap", "bn", "gn", "sp", "null", "fn", "sr", "pn", "sync", "ns", "bl", "sd", "nil", "nm", "sc", "txt", "nu", "nn", "sk"], "s": ["aws", "gs", "S", "n", "p", "js", "si", "sq", "v", "xs", "sl", "sam", "syn", "t", "sm", "sb", "sv", "st", "is", "sys", "ds", "m", "sa", "services", "ts", "sp", "c", "stats", "ns", "b", "h", "fs", "ss", "rs", "ps"], "sn_info": ["SN_fo", "sn_inf", "sn_Info", "sn_data", "sn__Info", "sn__info", "syn_inf", "syn_info", "sn_fo", "sn__stat", "syn_Info", "sn_stat", "SN_data", "sn__inf", "SN_info", "syn_stat", "SN_tab"], "nb_sns": ["nb_syns", "nb_nsts", "nb_sycs", "nb_Sms", "nbjsds", "nbjsnapocks", "nb2dns", "nbjscs", "nb2sxs", "nb_sqlts", "nb_scs", "nbjsns", "nb_Sicks", "nb_mcs", "nb_snapockets", "nb_nsites", "nb_micks", "nb_lns", "nb_sqns", "nb_ssbs", "nb_syites", "nbjsnapns", "nb2srees", "nb_Sqs", "nb_sites", "nb_ssizes", "nb_mbs", "nb2drees", "nb_sks", "nb_sizes", "nb_sinms", "nb_lbs", "nb_sprints", "nb_sqlks", "nb_sicks", "nb_socks", "nb_snapcs", "nb_syds", "nb_dcs", "nb_sqcs", "nb_sqlns", "nb_mizes", "nb_sms", "nb_syncs", "nb_mockets", "nb_Sns", "nb_dxs", "nb_mns", "nb_snapns", "nb_drees", "nb_nns", "nb_nscs", "nb_jsns", "nb_sqrees", "nb_sts", "nb_jsxs", "nb_nrees", "nb_nqs", "nb_nsks", "nb_nsns", "nb2sns", "nb2dcs", "nb_jsockets", "nb_sockets", "nb_sincs", "nb_Scs", "nbjsnapds", "nb_sinns", "nb_snapds", "nb_ssns", "nb_srees", "nb_sqs", "nb_Sockets", "nb_ncs", "nb_nsxs", "nb_mxs", "nb_snapicks", "nb_lprints", "nbjsocks", "nb_synds", "nb_sxs", "nb_nxs", "nb_dns", "nb_nsockets", "nb_nms", "nbjsnapcs", "nb_syocks", "nb_sds", "nb_synns", "nb_snapms", "nb_sbs", "nb_mms", "nb_jscs", "nb_sqlites", "nb_syts", "nb_snapocks", "nb2scs", "nb_syks", "nb_sqxs", "nb_mprints", "nb2dxs", "nb_ssprints", "nb_lizes", "nb_synocks", "nb_sinqs"], "i": ["index", "cli", "gu", "t", "ami", "ai", "m", " I", "xi", "qi", "ims", "it", "ji", "li", "oi", "ind", "j", "n", "ki", "si", "zi", "v", "ori", "ui", "im", "print", "ti", "fi", "x", "ri", "ic", "ix", "ip", "ij", "at", "f", "inter", "ii", "mi", "I", "pi", "batch", "er", "di", "in", "ie", "sim", "info", "c", "ci", "id", "multi", "me", "iu", "ini", "l", "ei", "uri", "p", "bi", "io", "is", "hi", "\u0438", "b", "e", "point", "gi", "phi", "init", "y"], "ret": ["resp", "rem", "rex", "mem", "ref", "out", "success", "fun", "back", "j", "cmd", "Ret", "rets", "RET", "val", "reg", "try", "t", "len", "rm", "result", "nz", "num", "nt", "nat", "true", "gt", "alt", "rt", "info", "backed", "count", "res", "flag", "red", "re", "found", "mt", "repl", "arg", "it", "elt", "ne", "net"], "available": ["stable", "annot", "allowed", "public", "accessible", "sofar", "installed", "important", "provided", "created", "initialized", "missing", "balanced", "enabled", "occupied", "eligible", "readable", "used", " unavailable", "util", "able", "authorized", "ful", "availability", "filled", "empty", "loaded", "checked", "volume", "verified", "published", "active", "found", "valid", "confirmed", "ready", "Available", "visible", "unique", "released", "selected", "usable", "required", "external", "played"], "total": ["stable", " done", "public", " complete", "local", "otal", "global", "size", "made", "list", "sequence", "created", "next", "details", "done", "t", "used", "Total", "eta", "note", "title", "result", "m", "menu", "last", "meta", "current", "parent", "count", "base", "all", "recent", "checked", "summary", "no", "volume", "table", "complete", " all", "active", "equal", "set", "collection", "trace", "max", "valid", "it", "unique", "net", "length", " tot", "final", "confirmed", "to", "ta", " TOTAL", "full", "database", "required", "sum", "played"], "available_snapshots": ["available_sots", "available_captocks", "available_synshots", "available_presots", "available_consshot", "available_snapaps", "available_dataots", "available_presicas", "available_dataposts", "available_snapposts", "available_synouts", "available_namesprints", "available_snapshot", "available_blocksicas", "available_newsouts", "available_namesshots", "available_snapots", "available_poolots", "available_captshot", "available_snapigs", "available_blocksreenshots", "available_spshot", "available_poolposts", "available_hotsigs", "available_dataprints", "available_snapprints", "available_namesots", "available_potshots", "available_synigs", "available_newsets", "available_poolprints", "available_presaps", "available_namesposts", "available_blocksshots", "available_potreenshots", "available_sshots", "available_presshot", "available_apocks", "available_consaps", "available_poticas", "available_hotsshots", "available_spets", "available_hotsets", "available_potots", "available_apets", "available_blocksots", "available_snapreenshots", "available_poolshots", "available_presreenshots", "available_snapouts", "available_snapets", "available_presshots", "available_consots", "available_newsshots", "available_sshot", "available_synets", "available_consshots", "available_captshots", "available_apshot", "available_snapocks", "available_saps", "available_apshots", "available_captets", "available_spocks", "available_snapicas", "available_newsigs", "available_spshots", "available_datashots", "available_hotsouts"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],\n\n                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],\n\n                        int i, int zero_nhood, int16_t qmul[2])\n\n{\n\n    uint8_t *token_prob = probs[i][zero_nhood];\n\n    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB\n\n        return 0;\n\n    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);\n\n}\n", "idx": 12585, "substitutes": {"c": ["rc", "cu", "cf", "co", "f", "cr", "tc", "cm", "lc", "l", "n", "p", "cmp", "cc", "cd", "v", "g", "t", "com", "dc", "ct", "cl", "m", "r", "s", "sc", "ac", "C", "cb", "ec", "cp", "b", "mc", "cs", "bc", "h", "gc", "fc", "e", "con", "d", "ca", "ce", "ch"], "block": ["node", "bit", "index", "type", "array", "out", "ref", "number", "object", "data", "map", "row", "chain", "model", "load", "pool", "field", "box", "frame", "bin", "bus", "cl", "lock", "channel", "blocks", "Block", "time", "word", "range", "buffer", "image", "board", "base", "pos", "byte", "bl", "bc", "label", "hash", "list", "config"], "probs": ["provs", " prob", "prgs", " probes", " Progs", "robs", " props", "Probs", "probes", "Provs", "Prob", " Provs", "prbes", " Prob", " Probs", "Progs", "progs", "rob", "prob", "Probes", "prps", "props", " progs", "rops", "robes", "prbs", " provs", "Props"], "i": ["ij", "index", "key", "li", "a", "f", "o", "oi", "ii", "mi", "I", "pi", "ind", "l", "j", "n", "ki", "p", "si", "zi", "v", "ori", "bi", "t", "di", "k", "m", "ai", "r", "xi", "iri", "ci", "b", "id", "ti", "e", "u", "it", "z", "x", "y", "ic"], "zero_nhood": ["zero_nigh", "zero_noh", "zero_snost", "zero_migh", "zero_snigh", "zero_nood", "zero_dhood", "zero_most", "zero_nost", "zero_dood", "zero_Nhood", "zero_mhood", "zero_snhood", "zero_moh", "zero_dith", "zero_Nood", "zero_nith", "zero_Nigh", "zero_snoh", "zero_Nost", "zero_Noh", "zero_Nith", "zero_digh"], "qmul": ["qMul", "qnmult", " qmult", "qmult", " qrmaj", "qnmul", " qrmul", "qmtaj", "qMult", "qrmul", "qcmUL", "qcmult", "qrmaj", "qrmuli", "qMuli", "qmtul", "qmaj", "qrmult", " qrmuli", "qcmul", " qmuli", " qmaj", "qmtUL", " qrmult", "qcmaj", "qnmuli", " qrmUL", " qmUL", "qrmUL", "qnmUL", "qMUL", "qmtult", "qmUL", "qmuli"], "token_prob": ["token_prebs", "token_probe", "token_prebe", "token_prog", "token_Prog", "token_prg", "token_pribs", "token_rop", "token_Probe", "token_probs", "token_preb", "token_prbe", "token_prib", "token_Prob", "token_Prop", "token2Probs", "token_priz", "token2prob", "token_rob", "token2probe", "token_prbs", "token_proz", "token_Proz", "token_preg", "token2Prog", "token2prog", "token_robs", "token2probs", "token_prb", "token_prop", "token_rog", "token_prig", "token_Probs", "token2Prob", "token2Probe"]}}
{"project": "qemu", "commit_id": "913a87885f589d263e682c2eb6637c6e14538061", "target": 1, "func": "static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)\n\n{\n\n    cirrus_fill_t rop_func;\n\n\n\n    if (blit_is_unsafe(s)) {\n\n        return 0;\n\n    }\n\n    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n\n    rop_func(s, s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\n             s->cirrus_blt_dstpitch,\n\n             s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n\t\t\t     s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n\t\t\t     s->cirrus_blt_height);\n\n    cirrus_bitblt_reset(s);\n\n    return 1;\n\n}\n", "idx": 12596, "substitutes": {"s": ["ses", "gs", "S", "bs", "ties", "ports", "sq", "ags", "t", "st", "m", "qs", "stats", "vs", "states", "cs", "ims", "aunts", "its", "ps", "sw", "n", "js", "v", "comm", "wcs", "ds", "ats", "ies", "args", "set", "conf", "ains", "parts", "i", "ex", "results", "south", "a", "as", "less", "bits", "eps", "als", "sb", "aus", "hs", "sys", "in", "c", "ops", "es", "changes", "fs", "events", "state", "bis", "se", "ss", "aws", "l", "p", "details", "is", "sv", "ls", "r", "mods", "ts", "ins", "ns", "h", "os", "z", "sts", "ms", "y", "rs"], "blt_rop": ["blrt_wp", "blrt__op", "blt__op", "blt__crop", "bltCro", "bltCrop", "blrt__rop", "blrt__ro", "blt_prop", "blt_crop", "blt__wp", "blrt_crop", "blt_op", "blrt_ro", "blt_ro", "blt__rop", "blrt_prop", "bltCop", "blrt__prop", "blt_wp", "blt__prop", "blrt_rop", "blt__ro", "bltCprop", "blrt_op"], "rop_func": ["rop_val", " crop_val", "grab2fc", "grab2unc", "rop2fc", "prop_fac", "grab2function", "rop2function", "grab_unc", "grab_function", "grab_fc", "grab_func", "prop_func", "rop_fun", "rop_unc", "prop_fun", " crop_imp", "rop_fc", "rop_imp", "grab2func", "rop2unc", "rop2func", "rop_function", " crop_func", "rop_fac"]}}
{"project": "FFmpeg", "commit_id": "f5be84cfbc9c132a867ae8a8c0e0de26ed1a4e88", "target": 1, "func": "static int load_ipmovie_packet(IPMVEContext *s, AVIOContext *pb,\n\n    AVPacket *pkt) {\n\n\n\n    int chunk_type;\n\n\n\n    if (s->audio_chunk_offset) {\n\n\n\n\n\n\n\n\n        /* adjust for PCM audio by skipping chunk header */\n\n        if (s->audio_type != CODEC_ID_INTERPLAY_DPCM) {\n\n            s->audio_chunk_offset += 6;\n\n            s->audio_chunk_size -= 6;\n\n\n\n\n        avio_seek(pb, s->audio_chunk_offset, SEEK_SET);\n\n        s->audio_chunk_offset = 0;\n\n\n\n        if (s->audio_chunk_size != av_get_packet(pb, pkt, s->audio_chunk_size))\n\n            return CHUNK_EOF;\n\n\n\n        pkt->stream_index = s->audio_stream_index;\n\n        pkt->pts = s->audio_frame_count;\n\n\n\n        /* audio frame maintenance */\n\n        if (s->audio_type != CODEC_ID_INTERPLAY_DPCM)\n\n            s->audio_frame_count +=\n\n            (s->audio_chunk_size / s->audio_channels / (s->audio_bits / 8));\n\n        else\n\n            s->audio_frame_count +=\n\n                (s->audio_chunk_size - 6) / s->audio_channels;\n\n\n\n        av_dlog(NULL, \"sending audio frame with pts %\"PRId64\" (%d audio frames)\\n\",\n\n                pkt->pts, s->audio_frame_count);\n\n\n\n        chunk_type = CHUNK_VIDEO;\n\n\n\n    } else if (s->decode_map_chunk_offset) {\n\n\n\n        /* send both the decode map and the video data together */\n\n\n\n        if (av_new_packet(pkt, s->decode_map_chunk_size + s->video_chunk_size))\n\n            return CHUNK_NOMEM;\n\n\n\n        if (s->has_palette) {\n\n            uint8_t *pal;\n\n\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n\n                                          AVPALETTE_SIZE);\n\n            if (pal) {\n\n                memcpy(pal, s->palette, AVPALETTE_SIZE);\n\n                s->has_palette = 0;\n\n\n\n\n\n        pkt->pos= s->decode_map_chunk_offset;\n\n        avio_seek(pb, s->decode_map_chunk_offset, SEEK_SET);\n\n        s->decode_map_chunk_offset = 0;\n\n\n\n        if (avio_read(pb, pkt->data, s->decode_map_chunk_size) !=\n\n            s->decode_map_chunk_size) {\n\n            av_free_packet(pkt);\n\n            return CHUNK_EOF;\n\n\n\n\n        avio_seek(pb, s->video_chunk_offset, SEEK_SET);\n\n        s->video_chunk_offset = 0;\n\n\n\n        if (avio_read(pb, pkt->data + s->decode_map_chunk_size,\n\n            s->video_chunk_size) != s->video_chunk_size) {\n\n            av_free_packet(pkt);\n\n            return CHUNK_EOF;\n\n\n\n\n        pkt->stream_index = s->video_stream_index;\n\n        pkt->pts = s->video_pts;\n\n\n\n        av_dlog(NULL, \"sending video frame with pts %\"PRId64\"\\n\", pkt->pts);\n\n\n\n        s->video_pts += s->frame_pts_inc;\n\n\n\n        chunk_type = CHUNK_VIDEO;\n\n\n\n    } else {\n\n\n\n        avio_seek(pb, s->next_chunk_offset, SEEK_SET);\n\n        chunk_type = CHUNK_DONE;\n\n\n\n\n\n\n    return chunk_type;\n", "idx": 12607, "substitutes": {"s": ["sis", "ses", "gs", "S", "bs", "ports", "series", "sq", "ags", "sl", "m", "qs", "stats", "vs", "cs", "ims", "tes", "its", "ants", "https", "ps", "ans", "esm", "sw", "ists", "n", "js", "v", "g", "http", "comm", "spec", "ds", "ats", "ies", "args", "uploads", "set", "conf", "parts", "i", "results", "south", "as", "less", "bits", "eps", "xs", "als", "sb", "hs", "sys", "ess", "c", "ops", "es", "changes", "fs", "events", "state", "bis", "se", "sports", "ss", "comments", "status", "aws", "l", "p", "details", "is", "sv", "ls", "mods", "ts", "ins", "ns", "h", "e", "os", "sets", "sts", "w", "ms", "y", "rs"], "pb": ["jp", "td", "dial", "tc", "phys", "patch", "bs", "asm", "ctx", "p", "wb", "cmd", "kt", "proc", "tk", "pan", "vp", "conv", "pool", "pt", "apy", "pp", "sb", "buf", "sys", "np", "lb", "func", "rb", "phy", "cb", "tf", "lp", "fp", "cv", "PB", "wp", "cp", "b", "pg", "mp", "pc", "bb", "uf", "px", "bp", "pkg", "pl", "tp", "pa"], "pkt": ["spgt", "wpacket", "packet", "pwt", " pct", "Packet", " punk", "spacket", "tpwt", "spkt", "prkt", " pet", " pwt", "pcmd", "paykt", "tpkt", "tpcmd", " ptx", "pckt", "pcacket", "prct", "payacket", "payunk", "pracket", " ptxt", " pck", "wpct", " pcmd", "payow", "pctxt", "pingacket", "pingfet", "paygt", "tpkg", "Ptx", "paykg", " pix", "pgt", " pkg", "ptxt", "pix", "pingtx", "payfet", "paywt", "pingkt", "paycmd", "pcow", "wpkg", "payct", "pct", "wpix", "pck", "punk", "pingct", "spow", "spct", "prkg", "spunk", "pfet", "ptx", "pinget", " pfet", "wptxt", "wpkt", "pet", "Pet", "pcgt", "pcix", "pkg", "pingck", "Pkt", " packet", "payck"], "chunk_type": ["chunkingset", "chunk_name", "chunk_tag", "chunks_style", "chunktypetype", "chunks_name", "chunk_style", "chunk_TYPE", "chunkingid", "chunktypename", "chunkingtype", "chunkingTYPE", "chunks_tag", "chunktypestyle", "chunks_type", "chunk_set", "chunktypetag", "chunk_id"], "pal": ["pro", "face", "mem", "pill", "py", "ph", "stal", "local", "dal", "data", "phil", "pat", "pillar", "p", "par", "pol", "pixel", "hal", "val", "wal", "el", "batch", " Pal", "pp", "ass", "buff", "bin", "cell", "cam", "al", "sal", "Pal", "phal", "mel", "isal", "cal", "ap", "kl", "ul", "cel", "mat", "fac", "font", "quant", "pard", "col", "pl", "dat", "ele", "qq", "color", "arr", "ps"]}}
{"project": "FFmpeg", "commit_id": "f21cf2b38365caaa8a130a32521c2648600c3f50", "target": 0, "func": "static int encode_hq_slice(AVCodecContext *avctx, void *arg)\n\n{\n\n    SliceArgs *slice_dat = arg;\n\n    VC2EncContext *s = slice_dat->ctx;\n\n    PutBitContext *pb = &slice_dat->pb;\n\n    const int slice_x = slice_dat->x;\n\n    const int slice_y = slice_dat->y;\n\n    const int quant_idx = slice_dat->quant_idx;\n\n    const int slice_bytes_max = slice_dat->bytes;\n\n    uint8_t quants[MAX_DWT_LEVELS][4];\n\n    int p, level, orientation;\n\n\n\n    avpriv_align_put_bits(pb);\n\n    skip_put_bytes(pb, s->prefix_bytes);\n\n    put_bits(pb, 8, quant_idx);\n\n\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n\n    for (level = 0; level < s->wavelet_depth; level++)\n\n        for (orientation = !!level; orientation < 4; orientation++)\n\n            quants[level][orientation] = FFMAX(quant_idx - s->quant[level][orientation], 0);\n\n\n\n    /* Luma + 2 Chroma planes */\n\n    for (p = 0; p < 3; p++) {\n\n        int bytes_start, bytes_len, pad_s, pad_c;\n\n        bytes_start = put_bits_count(pb) >> 3;\n\n        put_bits(pb, 8, 0);\n\n        for (level = 0; level < s->wavelet_depth; level++) {\n\n            for (orientation = !!level; orientation < 4; orientation++) {\n\n                encode_subband(s, pb, slice_x, slice_y,\n\n                               &s->plane[p].band[level][orientation],\n\n                               quants[level][orientation]);\n\n            }\n\n        }\n\n        avpriv_align_put_bits(pb);\n\n        bytes_len = (put_bits_count(pb) >> 3) - bytes_start - 1;\n\n        if (p == 2) {\n\n            int len_diff = slice_bytes_max - (put_bits_count(pb) >> 3);\n\n            pad_s = FFALIGN((bytes_len + len_diff), s->size_scaler)/s->size_scaler;\n\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n\n        } else {\n\n            pad_s = FFALIGN(bytes_len, s->size_scaler)/s->size_scaler;\n\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n\n        }\n\n        pb->buf[bytes_start] = pad_s;\n\n        flush_put_bits(pb);\n\n        skip_put_bytes(pb, pad_c);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12616, "substitutes": {"avctx": ["vrctl", " avcfg", "avctl", "savctl", " avcontext", " avctl", "vrctx", "savctx", "avcfg", "avcontext", "savcontext", "vrcfg", "savcfg", "vrcontext"], "arg": ["vol", "param", "conn", "ref", "ax", "attr", "cmd", "ag", "ctx", "call", "val", "v", "agg", "g", "ar", "ig", "ng", "ay", "reg", "cell", "og", "Arg", "gate", "doc", "event", "argument", "ang", "rg", "args", "slice", "ad", "ark", "ray", "ary", "arc", "anc", "arr", "arp"], "slice_dat": ["sliceobjgrad", "sliceaxypat", "sliceptdat", "angle_np", "angle_grad", "slice2dt", "slice_dates", "sliceptnote", "slice_def", " slice_rat", "sliceobjdat", "slice2ann", "tile2dt", "slice___iat", "tile2ann", "slice_at", "slice_nit", "tile_ann", "slice_reg", "slice_rat", "slicemmdata", "sliceGdates", "slice_nat", "slice_grad", "copy_pat", "tile_dat", "sliceGdata", "slice_iat", "slice_pat", " slice_nat", "sliceaxyann", "sliceobjdates", "sliceobjdec", " slice_data", "sliceaxyat", "slice_dec", "sliceablenp", "copy_dat", "copy_iat", "plot_nit", "sliceaxyiat", "slice___ann", "slice_note", "sliceablegrad", "slice___dates", "sliceobjdata", "sliceaxydat", "slicemydat", "slicemyat", " slice_dates", "plot_def", "plot_at", "slice2note", " slice_reg", "angle_dec", "sliceaxynit", "slicemmiat", "slice___dat", "sliceGdat", "slice_np", "slicemmreg", "copy_ann", " slice_iat", "tile_note", "slicemmdat", "sliceptdt", "slicemydef", "slice_dt", "slice___data", "angle_dat", "sliceGnat", "slice_data", "sliceabledec", "sliceaxydef", "slice___rat", "tile_dt", "slice_ann", "tile2note", "sliceabledat", "sliceobjnp", "sliceptann", "tile2dat", "slicemynit", "slice___pat", "slice2dat", "sliceobjrat", "plot_dat"], "s": ["sis", "ses", "aws", "gs", "a", "S", "f", "bs", "less", "l", "ctx", "js", "sq", "v", "g", "sl", "ms", "sam", "t", "comm", "is", "sb", "sv", "spec", "als", "sys", "hs", "ds", "ls", "ats", "m", "sa", "r", "obj", "ssl", "qs", "sc", "ts", "self", "sp", "c", "stats", "vs", "ins", "ns", "b", "cs", "h", "es", "ims", "fs", "sd", "sg", "os", "se", "i", "ss", "sts", "y", "rs", "ps"], "pb": ["resp", "jp", "td", "tg", "peer", "tc", "pause", "bs", "patch", "asm", "ctx", "wb", "cmd", "bh", "proc", "vp", "bj", "tk", "erb", "pd", "stab", "dp", "pool", "pt", "pm", "pp", "sb", "gb", "buf", "np", "lb", "rb", "func", "sys", "ub", "snap", "cpp", "fb", "vm", "buffer", "cb", "sp", "lp", "fp", "cv", "PB", "tf", "wp", "cp", "tab", "gp", "gc", "pg", "mp", "pc", "tmp", "bps", "emb", "nb", "uf", "bb", "ps", "px", "bp", "pkg", "pl", "vt", "tp", "pa", "pack"], "quants": ["quats", "equands", "equants", "quANT", "constants", "requats", "QUant", " quats", "constant", "QUents", " quANT", "squands", "quands", "requANT", " quant", "QUants", "constands", "constANT", "requands", "squents", "squants", "QUANT", "QUats", " quands", "requants", "quant", "requant", "requents", "squats", "quents", "equant", "QUands", "equANT"], "MAX_DWT_LEVELS": ["MAX_DWT_LOVELVS", "MAX_DWT_LELELS", "MAX_DWT_LEVELLS", "MAX_DWT_LEPEPS", "MAX_DWT_LEVELVS", "MAX_DWT_LELES", "MAX_DWT_LOVELS", "MAX_DWT_LELEVS", "MAX_DWT_LEPELS", "MAX_DWT_LOPEVS", "MAX_DWT_LEPES", "MAX_DWT_LEPEVS", "MAX_DWT_LELEPS", "MAX_DWT_LOPES", "MAX_DWT_LOPELS", "MAX_DWT_LOVELLS", "MAX_DWT_LEPSS", "MAX_DWT_LEPSVS", "MAX_DWT_LEPSLS", "MAX_DWT_LEPSPS", "MAX_DWT_LOPEPS", "MAX_DWT_LEVELPS", "MAX_DWT_LOVELPS"], "p": ["pro", "jp", "at", "f", "o", "local", "per", "pi", "ind", "l", "j", "pr", "n", "pat", "depth", "par", "vp", "perm", "v", "g", "port", "pt", "t", "pp", "ping", "P", "m", "k", "part", "r", "power", "press", "sp", "c", "lp", "pos", "ep", "pn", "ap", "po", "cp", "b", "post", "pg", "h", "pc", "pers", "e", "point", "pid", "pre", "d", "tp", "prop", "ps", "q", "pl", "pkg", "i", "x", "pa", "pe", "pod", "ip"], "level": ["vol", "index", "cost", "goal", "member", "scope", "depth", "window", "role", "half", "compl", "low", "layer", "val", "le", "loc", "ping", "loop", "ble", "location", "limit", "summary", "po", "label", "trace", "length", "zero", "lo", "ps", "thread", "pro", "Level", "type", "peer", "fall", "lc", "high", "family", "ind", "group", "what", "v", "padding", "VEL", "stack", "pal", "volume", "print", "scale", "tier", "vel", "coll", "pe", "priority", "impact", "key", "version", "f", "global", "cond", "row", "call", "where", "lvl", "op", "al", "zone", "broad", "stage", "variable", "kl", "pc", "state", "status", "go", "local", "per", "roll", "l", "mode", "L", "el", "pp", "diff", "fl", "tag", "condition", "lay", "count", "loss", "all", "pri", "no", "point", "rel", "levels", "col", "quality", "pl"], "orientation": ["orientity", "rientotation", "portication", "anchation", "projectation", "anchization", "roturation", "oriention", "horization", "directionication", "layoutization", "elongATION", "transformation", "orientization", "directionacion", "directionuration", "collation", "rotator", "rientification", "designification", "portacion", "rienturation", "rotacion", "layoutation", "designATION", "iterization", "directionization", "orienturation", "orientATION", "iteration", "elongaton", "rientational", "orientaton", " orientification", "designity", "transformration", "portaton", "collATION", "elongational", " orientATION", " orientacion", "projectication", "elongacion", "iterational", " orienturation", "designration", "designator", "portation", "rientization", "rotity", "transformotation", "elongization", "directionration", "designation", "iterATION", "directionation", "horotation", "designotation", "horation", "rotATION", "orientotation", "elongation", "riention", "anchATION", "orientacion", "layoutator", "transformization", "projectacion", "layoutotation", " orientication", "orientication", "orientration", " orientization", "transformication", " orientity", "rotication", "orientator", "designization", "horration", "collization", "rotization", "rientator", "elongration", "collion", "iterication", "rientication", "projectaton", "rotation", " orientator", "orientification", "orientational", "rientation", "rientity", "elongication", "anchion", "rientATION"], "bytes_start": ["bytes2len", "bytes5len", "bytes2first", "bytes2start", " bytesxend", "bytes__len", "bytes5begin", " bytes_end", "bytesxiter", "tes_len", "bits_begin", "bytes_first", " bytes_iter", " bytes_origin", "bytesxstart", "bytes2begin", "bits_iter", "bytes_begin", "bytes_origin", "bits_start", "bytes__start", "bytes__iter", "bytes_iter", " bytesxstart", "tes_start", "tes_begin", "bytesxend", "bytes_end", " bytesxiter", "bytes5first", "bits_len", "bytes5start", "bytes__begin", "tes_first", " bytesxorigin", "bytesxorigin"], "bytes_len": [" bytes64start", "bytes64start", " bytes_win", "bytes5lim", "bytes_", "bytes32diff", "bytes_del", "bytes64rel", "Bytes_len", "bytes5del", "bytes10len", "bytes32len", "bytes5len", " bytes_", " bytes_del", "bytes_lim", " bytes32len", " bytes32diff", "bytes10del", "bytes32win", " bytes64rel", "bytes5start", "cells_", "bytes5rel", " bytes32win", "bytes64Len", "bytes5win", "bytes_Len", " bytes_rel", "bytes10diff", "bytes64lim", "bytes_rel", "bytes2", "bytes10win", "bytes_lon", "bytes32del", "tes_", "Bytes_start", "bytes5diff", " bytes2", "cells2", "bytes64lon", " bytes32del", "bytes_diff", " bytes64len", " bytes64lim", " bytes_lim", "Bytes_lon", "bytes_win", "bytes64len", " bytes_diff", "Bytes_Len", "tes2"], "pad_s": ["padajrs", "pad_sam", "padpts", "pod_v", "padding_y", "padablers", "pen_sam", "pad_y", "pod_in", "pod_sl", "padptsl", "pad_sl", "penablesam", "padptv", "padptin", "penables", "pad_si", "pod_s", "penablesi", "penablers", "pen_rs", "pad___in", "pad_n", "pad_rs", "padajs", "pen_si", "pad___sl", "pad___s", "pad___v", "pad_in", "pad_v", "padajsam", "padding_c", "padding_n", "padding_s", "padablesam", "padajsi", "padables", "padablesi", "pen_s"], "pad_c": ["quote_cs", "pad_cs", "pod_pc", "padurecs", "padurec", "padurei", "quoteurec", "quoteurecs", "pad__pc", "pad_pc", "quote_i", "pad_mc", "pad__m", "pod67m", "pad_m", "pod_c", "quote_rc", "pod67c", "padMemmc", "padMemc", "quote_c", "pad__mc", "pod67pc", "pod_m", "pod_mc", "quoteurerc", "pad67m", "quoteurei", "pod67mc", "padMemm", "pad67mc", "pad_rc", "pad67pc", "padMempc", "padurerc", "pad_i", "pad__c", "pad67c"]}}
{"project": "qemu", "commit_id": "2e061a7c86d77c599676d89c3461f8efe9c275b1", "target": 0, "func": "static void do_info_commands(Monitor *mon, QObject **ret_data)\n\n{\n\n    QList *cmd_list;\n\n    const mon_cmd_t *cmd;\n\n\n\n    cmd_list = qlist_new();\n\n\n\n    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {\n\n        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&\n\n            !compare_cmd(cmd->name, \"info\")) {\n\n            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));\n\n        }\n\n    }\n\n\n\n    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {\n\n        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {\n\n            char buf[128];\n\n            snprintf(buf, sizeof(buf), \"query-%s\", cmd->name);\n\n            qlist_append_obj(cmd_list, get_cmd_dict(buf));\n\n        }\n\n    }\n\n\n\n    *ret_data = QOBJECT(cmd_list);\n\n}\n", "idx": 12624, "substitutes": {"mon": ["serv", "mi", "stat", "man", "dm", "monitor", "sam", "comm", "Mon", "tem", "bin", "num", "dom", "MON", "dem", "mu", "mm", "om", "mut", "fn", "met", "pers", "con", "my", "mons", "mx", "mun", "wat"], "ret_data": ["return_da", "ret2data", "ret_da", "ret_list", "retrowdata", "ret2list", "req_da", "req_cache", "req_data", "ret_cache", "retrowlist", "return_data", "req_DATA", "retrowda", "ret2da", "return_list", "ret_DATA"], "cmd_list": [" cmd_single", "comm_spec", "cmdllist", "commtcache", "cmd7li", " cmd_l", "cmd2table", "cmd_single", " cmd2list", "cmdlistcache", "Cmd_List", "commtspec", "cmdlsingle", "cmdlstatus", "cmd2list", "cmdtspec", "cmd_l", "cmd_block", "check_info", "commtlist", "check_li", "cmd2List", "cmdlistspec", "comm_list", "cmdlistlist", " cmd2List", "cmdtlist", "cmd2li", "Cmd_lists", "cmdtcache", "cmd2info", " cmd_status", " cmd_List", " cmd2l", "cmd_info", "cmd_spec", "Cmd_list", "cmdlList", "cmd2l", "Cmd_block", "check_table", "cmd_status", "cmd_cache", "check_list", "cmd7list", "cmd_List", "cmd_li", "cmd_lists", "cmd7info", "comm_cache", "cmd_table", "cmd7table"], "cmd": ["conn", "orig", "cur", "ctx", "miss", "cmp", "raw", "mk", "cli", "check", "nd", "help", "command", "send", "nt", "ann", "add", "cb", "kick", "Cmd", "coord", "urg", "method", "qt", "del", "pkg", "cont", "qq", "exec", "normal", "def", "ind", "addr", "crit", "kt", "md", "comm", "cat", "job", "cfg", "obj", "phy", "om", "bind", "cp", "ctrl", "dep", "mt", "txt", "form", "quit", "resp", "cf", "canon", "cond", "call", "cod", "req", "proc", "batch", "ctr", "sys", "op", "gt", "norm", "c", "unknown", "config", "go", "serv", "good", "cd", "name", "pt", "gen", "kind", "msg", "ext", "ct", "act", "desc", "dq", "col", "component", "prop", "nm", "init", "ch"], "buf": ["bytes", "Buff", "tx", "bar", "vec", "mem", "bs", "out", "ref", "cur", "ff", "data", "seq", "pb", "ctx", "window", "raw", "Buffer", "temp", "bh", "hold", "text", "batch", "box", "iq", "msg", "buff", "cap", "new", "rb", "result", "br", "xff", "obj", "fb", "buffer", "cb", "cv", "img", "burst", "cp", "b", "bc", "tmp", "iter", "var", "pad", "uf", "err", "queue", "str", "tab", "txt", "arr"]}}
{"project": "qemu", "commit_id": "f1c2dc7c866a939c39c14729290a21309a1c8a38", "target": 0, "func": "static void spapr_msi_write(void *opaque, hwaddr addr,\n\n                            uint64_t data, unsigned size)\n\n{\n\n    sPAPRPHBState *phb = opaque;\n\n    int ndev = addr >> 16;\n\n    int vec = ((addr & 0xFFFF) >> 2) | data;\n\n    uint32_t irq = phb->msi_table[ndev].irq + vec;\n\n\n\n    trace_spapr_pci_msi_write(addr, data, irq);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));\n\n}\n", "idx": 12635, "substitutes": {"opaque": [" opatile", " opaques", "ipaques", "boque", "OPen", "opane", "opa", "boa", " opane", "ipatile", "opsaque", "ropque", "opsatile", "opsane", "opaques", "opsaques", "open", "ropaque", "ipane", "boen", "ropen", "ipaque", "opatile", "OPa", "ropa", "opque", "OPaque", "boaque", "OPque"], "addr": ["tx", "rc", "arp", "at", "mem", "ptr", "src", "ref", "lr", "rn", "inter", "handle", "address", "cmd", "ctx", "hw", "attr", "x", "dr", "ord", "name", "adr", "len", "loc", "mac", "np", "offset", "align", "act", "r", "url", "obj", "hop", "off", "add", "inv", "pos", "trans", " ip", "res", "on", "ack", "coord", "id", "adv", " dst", "ad", "host", "seek", "mt", "pad", "hash", " address", "err", "rr", "rs", "ix", "arr", "ip"], "data": ["bytes", "tx", "def", "type", "mem", "out", "p", "n", " DATA", "window", "raw", "name", "text", "batch", "t", "len", "padding", "msg", "buf", "bin", "da", "al", "r", "mu", "buffer", "empty", "block", "pos", "Data", "res", "device", "action", "dev", "any", "ad", "pad", "length", "d", "hash", "to", "DATA", "ata", "format", "dat", "zero", "w", "str", " Data"], "size": ["Size", "type", "mem", "address", "SIZE", "cmd", "n", " count", "len", "ize", "offset", "num", "s", "count", "h", "id", " n", "e", " len", "weight", "length", "shape", "z", "w", "name", " length"], "phb": [" hab", "phc", " sshb", " haa", " sshp", "aphc", " hap", "mphb", "pha", " sshbb", "php", " ssha", "mphc", "mphwb", "aphwb", "aphb", " php", "phbb", " pha", "phwb", " phc", " phwb", " phbb", " habb"]}}
{"project": "qemu", "commit_id": "2a1639291bf9f3c88c62d10459fedaa677536ff5", "target": 0, "func": "static void pxa2xx_pm_write(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;\n\n    if (addr > s->pm_base + PCMD31) {\n\n        /* Special case: PWRI2C registers appear in the same range.  */\n\n        pxa2xx_i2c_write(s->i2c[1], addr, value);\n\n        return;\n\n    }\n\n    addr -= s->pm_base;\n\n\n\n    switch (addr) {\n\n    case PMCR:\n\n        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);\n\n        s->pm_regs[addr >> 2] |= value & 0x15;\n\n        break;\n\n\n\n    case PSSR:\t/* Read-clean registers */\n\n    case RCSR:\n\n    case PKSR:\n\n        s->pm_regs[addr >> 2] &= ~value;\n\n        break;\n\n\n\n    default:\t/* Read-write registers */\n\n        if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) {\n\n            s->pm_regs[addr >> 2] = value;\n\n            break;\n\n        }\n\n\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n}\n", "idx": 12642, "substitutes": {"opaque": [" opaques", "oopplex", "oopaque", "oopose", "opsplex", "roponymous", "oppaque", "opsolete", "opponymous", "opsaque", "ropaques", " oponymous", "opaques", "ropois", "opois", "oppplex", "ropaque", "opplex", "opsose", "oopsolete", "oppsolete", "opssolete", " opois", "oponymous", "oppose", "opose", "oppaques", "oppois"], "addr": ["index", "conn", "attr", "ctx", "hw", "expr", "dr", "cmp", "eq", "len", "loc", "rank", "add", "rev", "lat", "coord", "ack", "urg", "confirmed", "pkg", "usr", "arr", "tx", "nl", "mem", "ptr", "sw", "peer", "address", "cmd", "ag", "map", "tr", "kt", "dt", "ar", "md", "added", "align", "dd", "arity", "obj", "env", "sha", "rs", "db", "pos", "link", "res", "alias", "ad", "seek", "mt", "hl", "elt", "x", "ix", "atom", "ip", "a", "ref", "inter", "asm", "req", "adr", "np", "offset", "eth", "gt", "work", "id", "iter", "hash", "ash", " address", "dh", "err", "amp", "bound", "str", "alloc", "Address", "arp", "status", "handle", "grad", "ord", "arm", "msg", "act", "tag", "desc", "r", "gate", "alt", "off", "ac", "rt", "aro", "sp", "ak", "tz", "here", "host", "order", "ace", "pad", "ne", "z", "w", "nm", "adj"], "value": ["key", "index", "type", "version", " val", "number", "position", "address", "data", "size", "values", "p", "operator", "vp", "val", "v", "widget", "test", "field", "ay", "unit", "VALUE", "new", "tree", "tag", "Value", "memory", "fee", "message", "description", "json", "ue", "current", "attribute", "comment", "buffer", "variable", "function", "code", "property", "hello", "pair", "VAL", "weight", "state", " Value", "total", "length", "format", "style", "see", "vt", "w", "name"], "s": ["ses", "gs", "S", "bs", "ports", "sq", "sl", "sam", "acs", "ssl", "qs", "stats", "vs", "sh", "states", "ims", "ps", "sw", "j", "js", "params", "g", "http", "sol", "comm", "spec", "space", "ds", "ats", "sa", "services", "ies", "so", "self", "ears", "sync", "conf", "less", "utils", "bits", "eps", "store", "source", "sm", "sb", "als", "service", "hs", "sys", "c", "ares", "es", "fs", "bis", "se", "reads", "ss", "aws", "serv", "p", "details", "is", "sv", "ls", "ts", "sp", "ns", "b", "h", "sts", "ms", "y", "rs"]}}
{"project": "qemu", "commit_id": "9c605cb13547a5faa5cb1092e3e44ac8b0d0b841", "target": 0, "func": "CPUX86State *cpu_x86_init(void)\n\n{\n\n    CPUX86State *env;\n\n    int i;\n\n    static int inited;\n\n\n\n    cpu_x86_tblocks_init();\n\n\n\n    env = malloc(sizeof(CPUX86State));\n\n    if (!env)\n\n        return NULL;\n\n    memset(env, 0, sizeof(CPUX86State));\n\n    /* basic FPU init */\n\n    for(i = 0;i < 8; i++)\n\n        env->fptags[i] = 1;\n\n    env->fpuc = 0x37f;\n\n    /* flags setup */\n\n    env->eflags = 0;\n\n\n\n    /* init various static tables */\n\n    if (!inited) {\n\n        inited = 1;\n\n        optimize_flags_init();\n\n    }\n\n    return env;\n\n}\n", "idx": 12645, "substitutes": {"env": ["conn", "et", "manager", "cur", "ctx", "window", "port", "end", "policy", "context", "doc", "caps", "en", "vs", "ped", "ape", "emb", "gear", "forge", "rc", "def", "ptr", "environment", "data", "addr", "cmd", "map", "js", "erd", "v", "next", "obj", "inv", "db", "oe", "tmp", "hl", "EN", "txt", "server", "nv", "global", "proc", "er", "buf", "da", "era", "ja", "buffer", "up", "cv", "ec", "dev", "state", "uv", "err", "ev", "vt", "bar", "dict", "V", "ee", "ent", "el", "esc", "sv", "priv", "msg", "cap", "ef", "ext", "desc", "ah", "ew", "chart", "event", "code", "ov", "here", "e", "entry", "var", "ve", "export", "init", "viron", "worker"], "i": ["ij", "li", "f", "iu", "oi", "mi", "ii", "I", "pi", " j", "ind", "j", "ini", "n", "p", "ei", "ki", "si", "zi", " ti", "v", "chain", "cli", "bi", "ui", " k", "di", "asi", " ii", "PI", "ai", "m", "k", "in", " I", "hi", "ie", "qi", "xi", " bi", "sim", "im", "\u0438", "ci", " v", "client", "id", "ti", " x", "multi", "gi", "it", "fi", "me", "ji", "phi", "x", "y", "ic", "ix", "ip"], "inited": ["INated", "INended", " ininitialized", "initted", "INinitialized", "initialized", "intated", "Initialized", "innitted", " init", "INitialized", "intitted", "innited", " initted", "INit", "intended", "inended", "intited", "inated", "Inited", "Initted", "ininitialized", "INitted", "Ininitialized", "innated", "Init", "init", " initialized", "INited", "innended"]}}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "void readline_show_prompt(ReadLineState *rs)\n\n{\n\n    monitor_printf(rs->mon, \"%s\", rs->prompt);\n\n    monitor_flush(rs->mon);\n\n    rs->last_cmd_buf_index = 0;\n\n    rs->last_cmd_buf_size = 0;\n\n    rs->esc_state = IS_NORM;\n\n}\n", "idx": 12663, "substitutes": {"rs": ["rc", "rpm", "gs", "ubs", "as", "obs", "bs", "rw", "ths", "rss", "ys", "mr", "js", "dr", "rl", "rows", "xs", "rings", "ctr", "ros", "rm", "hs", "rb", "ds", "ats", "ls", "times", "r", "Rs", "qs", "rt", "ck", "ars", "rys", "ts", "rh", "sr", "vs", "res", "ry", "ins", "cs", "ns", "ras", "acks", "ims", "lbs", "rates", "cons", "ack", "rd", "ks", "its", "ics", "ris", "ss", "sts", "ms", "rr", "RS", "ps"]}}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int parallel_parse(const char *devname)\n\n{\n\n    static int index = 0;\n\n    char label[32];\n\n\n\n    if (strcmp(devname, \"none\") == 0)\n\n        return 0;\n\n    if (index == MAX_PARALLEL_PORTS) {\n\n        fprintf(stderr, \"qemu: too many parallel ports\\n\");\n\n        exit(1);\n\n    }\n\n    snprintf(label, sizeof(label), \"parallel%d\", index);\n\n    parallel_hds[index] = qemu_chr_new(label, devname, NULL);\n\n    if (!parallel_hds[index]) {\n\n        fprintf(stderr, \"qemu: could not connect parallel device\"\n\n                \" to character backend '%s'\\n\", devname);\n\n        return -1;\n\n    }\n\n    index++;\n\n    return 0;\n\n}\n", "idx": 12667, "substitutes": {"devname": ["devName", "DevName", " devnames", " devnam", "evno", "devnames", "camnam", "deviceno", "evnames", "devno", "deviceName", "devlen", "camName", "evName", "camname", "Devno", "evnam", "evlen", "devicename", "Devname", " devlen", "devicelen", "camnames", " devName", "devnam", "evname"], "label": ["node", "key", "type", "sort", "child", "local", "member", "bool", "data", "Label", "l", "mask", "ind", "group", "role", "dl", "leaf", "val", "el", " Label", "field", "len", "loc", "kind", "msg", "loop", "delay", "cell", "desc", "tag", "LAB", "line", "control", "slot", "prefix", "comment", "block", "layout", "base", "link", "summary", "alias", "id", "binary", "leader", "list", "style", "value", "name", "str", "tab", "abel", "color", "lab"], "index": ["thread", "status", "key", "instance", "scroll", "axis", "version", "mount", "number", "position", "success", "ax", "search", "size", "ind", "address", "j", "row", "n", "x", "timeout", "ex", "connected", "check", "port", "batch", "localhost", "loop", "Index", "offset", "connect", "num", "lock", "scan", "connection", "context", "IND", "current", "available", "find", "count", "capacity", "pos", "location", "image", "link", "page", "id", "collection", "set", "order", "iter", "point", "seek", "max", "state", "ion", "length", "total", "list", "value", "zero", "draw", "i", "level", "name", "process", "ix"]}}
{"project": "qemu", "commit_id": "a9e1c28ddaae5a48415fec1f336b5560eb85d3e1", "target": 0, "func": "START_TEST(qfloat_destroy_test)\n\n{\n\n    QFloat *qf = qfloat_from_double(0.0);\n\n    QDECREF(qf);\n\n}\n", "idx": 12668, "substitutes": {"qf": ["sqF", " queryt", "dqfr", "qrf", "qF", "queryrf", "qurf", " queryfr", "quF", "qut", "qufr", " queryfac", "dqt", "qfac", "sqrf", "quf", "qfr", "sqt", "queryF", "dqf", "queryt", "queryf", "qt", "qufac", "dqfac", " queryf", "sqf"]}}
{"project": "qemu", "commit_id": "b97400caef60ccfb0bc81c59f8bd824c43a0d6c8", "target": 0, "func": "static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)\n\n{\n\n    int err;\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    err =  lstat(rpath(fs_ctx, path, buffer), stbuf);\n\n    if (err) {\n\n        return err;\n\n    }\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        /* Actual credentials are part of extended attrs */\n\n        uid_t tmp_uid;\n\n        gid_t tmp_gid;\n\n        mode_t tmp_mode;\n\n        dev_t tmp_dev;\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.uid\", &tmp_uid,\n\n                    sizeof(uid_t)) > 0) {\n\n            stbuf->st_uid = tmp_uid;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.gid\", &tmp_gid,\n\n                    sizeof(gid_t)) > 0) {\n\n            stbuf->st_gid = tmp_gid;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.mode\",\n\n                    &tmp_mode, sizeof(mode_t)) > 0) {\n\n            stbuf->st_mode = tmp_mode;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.rdev\", &tmp_dev,\n\n                        sizeof(dev_t)) > 0) {\n\n                stbuf->st_rdev = tmp_dev;\n\n        }\n\n    }\n\n    return err;\n\n}\n", "idx": 12672, "substitutes": {"fs_ctx": ["ps__cur", "ps_ctx", "fsacctx", "fsaccontext", "fs_func", "fsgjp", "fsgctx", "ps__ct", "fs___desc", "ps__context", "fs_jp", "fw___ctx", "ns_context", "fsacct", "fs___jp", "ns_tx", "rets_conn", "fw___func", "fs_cur", "ps_context", "qs_ctx", "cs_cas", "fps_ctx", "fs__ct", "qs_ctl", "cs_ctx", "fps_hw", "ns_ctx", "ps__ctx", "fs__cur", "fs_ct", "fs__ca", "fs__ctx", "fs__context", "fsgfunc", "fps_tx", "fs_context", "fspttx", "cs_obj", "ps_cur", "fs___ctx", "fs___func", "qs_cmp", "fw___jp", "fw_jp", "fs_cc", "fsptconn", "fps_conn", "fw_ctx", "fs_obj", "fs_conn", "fs_ca", "fs__tx", "fs_cmp", "fs_hw", "fsptctx", "fw_func", "fs_desc", "rets_desc", "fw___desc", "fsgdesc", "fs_tx", "rets_cc", "rets_ctx", "fspthw", "qs_conn", "fsaccur", "fs_ctl", "fw_desc", "fs_cas", "ps_ct", "cs_tx", "ns_ca"], "fs_path": ["fs2Path", "cs_context", "fs2context", "fs_th", " fs_cont", "cs_ctx", "fs2ctx", "fs2path", " fs_th", "fs_cont", "cs_Path", " fs_pred", "cs_path", "fs_pred", "fs_Path", "fs_context"], "stbuf": ["estcb", "stBuff", " stbar", "ostBuff", "astcv", " stbuffer", "Stbuffer", " stcv", "lcv", "ostuf", "restuf", "stcb", "stbuff", "stuf", "restbuff", "stcv", "restbuf", "lbuf", "ostcv", "Stbuff", "ostbuf", "stdbuffer", " stcb", " stbuff", "stdbuff", "ostbr", "ostbuffer", "putbuffer", "estcv", "stdBuff", "restbuffer", "astbuf", "astbuff", "stbuffer", " stbr", "putbr", "restBuff", "Stbuf", "astbuffer", "stduf", "lcb", "estbuf", "Stbar", "restbar", "putbuf", "stdbr", "ostbuff", "stbr", "stdbuf", "putbuff", "stbar"], "err": ["notice", "cr", "attr", "aaa", "mr", " count", "cli", "result", "gb", "end", "Error", "timer", "fee", " ec", " resp", "cb", "coord", "der", " rc", "it", "usr", "arr", "rc", "error", "ptr", "pr", "warn", "cmd", "n", "or", "try", "test", "cer", "kr", "obj", " arr", "cp", " len", "conf", "fer", "txt", "resp", " cr", "ner", " wr", "req", " score", "er", "buf", "rb", " intr", "c", "Er", "fr", "inner", "eas", "iter", "state", "ev", "str", "valid", "rr", "l", " error", " Err", "eor", "priv", "msg", "r", "off", "count", "code", "ns", " er", "die", "h", "here", "e", "order", "gz", "init", "ch"], "buffer": ["index", "directory", "type", "mem", "ptr", "array", "button", "header", "seed", "map", "callback", "window", "stream", "raw", "temp", "Buffer", "text", "check", " Buffer", "batch", "read", "cache", "buff", "buf", "stack", "command", "message", "context", "channel", "extra", "comment", "document", "block", "empty", "phrase", "file", "base", "byte", "code", "limit", "append", "bind", "cp", "b", "table", "gc", "alias", "binary", "transform", "seek", "iter", "pad", "length", "format", "queue", "filter", "commit", "cast", "history", "package", "template", "pointer"], "path": ["node", "key", "def", "error", "walk", "axis", "ptr", "route", "mount", "patch", "ref", "has", "data", "PATH", "ctx", "p", "core", "ex", "stream", "raw", "temp", "cmd", "ath", "dir", "pattern", "text", "chain", "test", "port", "pt", "binding", "kind", "priv", "cache", "buf", "end", "policy", "com", "part", "context", "th", "url", "full", "doc", "prefix", "empty", "file", "Path", "cp", "alias", "root", "transform", "order", "trace", "method", "prop", "package", "format", "value", "pkg", "w", "history", "name", "str", "template", "pointer"], "tmp_uid": ["mp_uid", " tmp_eu", " tmp_uo", "temp_uid", "tmp_chu", "mp_user", "tmp_uu", "temp_chu", "tmp_eu", "tmp___chu", " tmp_user", "tmp_uo", "tmp_user", "mp_uu", "tmp_UID", "tmp___user", "mp_UID", "tmp___edu", "temp_user", "temp_edu", "tmp___uid", "tmp_edu"], "tmp_gid": ["tmp_gId", "tmp_gID", "tmp_groupid", "tmp_pgid", "tmp_egId", "tmp_egno", "tmp_gurid", "tmp_gids", "tmp_ggid", "tmp_guid", "tmp_ggids", "tmp_groupno", "tmp_cpid", "tmp_gupid", "tmp_Gid", "tmp_groupID", "tmp_ggpid", "tmp_grouppid", "tmp_egids", "tmp_cID", "tmp_groupId", "tmp_pgno", "tmp_cid", "tmp_Gids", "tmp_groupids", "tmp_gno", "tmp_pgId", "tmp_egid", "tmp_grid", "tmp_ggrid", "tmp_guids", "tmp_pgids", "tmp_Grid", "tmp_Gpid", "tmp_gpid", "tmp_ggID"], "tmp_mode": ["tmp10de", "tmp10command", "tmpjmean", "tmpjenv", "tmp__command", " tmp_mean", "mp__command", " tmp_env", "tmpjcommand", "mp_mode", "tmpjcmd", "mp_command", " tmp_md", "tmp__device", "tmpjdevice", "tmp10device", "tmp__de", "tmp_cmd", "tmp_mean", "tmp__mode", "tmp_md", "mp_device", "mp__mode", "tmp_de", "tmpjmode", "mp_de", "mp__de", "tmptmd", "tmp_command", "tmptdevice", "tmp_device", " tmp_device", "mp__device", "tmp10mode", "tmp_env", "tmptdev", "tmptmode", "tmpjde", " tmp_cmd"], "tmp_dev": ["tmp_ver", "img_dev", "temp_ev", "tmp_Dev", "tmp2mem", "temp_Dev", " tmp_ver", "tmp_ev", "tmptev", "tmp2ver", "temp_dev", "img_driver", "tmptver", "img_ver", " tmp_mem", "tmptdriver", "tmp_device", " tmp_device", "tmp2device", "tmp_driver", "tmp2dev", "tmptdev", "tmp_mem", "temp_device", "img_ev"]}}
{"project": "qemu", "commit_id": "becf8217deb2afc347d5172d9f30c8a8964b8b27", "target": 0, "func": "void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,\n\n                                     uintptr_t retaddr)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    int t;\n\n\n\n    cs->exception_index = EXCP_PGM;\n\n    env->int_pgm_code = excp;\n\n\n\n    /* Use the (ultimate) callers address to find the insn that trapped.  */\n\n    cpu_restore_state(cs, retaddr);\n\n\n\n    /* Advance past the insn.  */\n\n    t = cpu_ldub_code(env, env->psw.addr);\n\n    env->int_pgm_ilen = t = get_ilen(t);\n\n    env->psw.addr += t;\n\n\n\n    cpu_loop_exit(cs);\n\n}\n", "idx": 12686, "substitutes": {"env": ["conn", "et", "ctx", "scope", "hw", "window", "expr", "engine", "st", "end", "context", " environment", "cb", "console", "en", "vs", "qt", "te", "esm", "environment", "cmd", "v", "ds", "shell", "obj", "eni", "db", "nc", "cp", "oe", "enter", "eng", "esp", "equ", "server", "nv", "nw", "kh", "ner", "proc", "vp", "sb", "er", "era", "org", "cv", "ec", "dev", "enc", "config", "ev", "vt", "estate", "ei", "ent", "esc", "sv", "ef", "eu", "desc", "ew", "ah", "vm", "runner", "pee", "sp", "viron", "here", "e", "Environment", "entry", "ve", "ne", "network", "sc", "ce", "worker"], "excp": ["desctx", "exctx", "EXcmp", "pexpc", " excmp", "usctx", " exCP", "Excmp", "EXCP", "pexpir", "despc", "despir", "EXp", "pexctx", "descp", "Exp", "exCP", "uspir", "Excp", "uscp", "expir", "ExCP", "uspc", "excmp", "EXcp", "pexcp", "expc"], "retaddr": ["Retaddr", "retsaddr", "retsattr", " retptr", "retsptr", " retattr", "retattr", "retsAddress", "RetAddress", " retAddress", "Retptr", " retaddress", "Retattr", "retaddress", "retptr", "retsaddress", "retAddress", "Retaddress"], "cs": ["rc", "cf", " CS", "bs", "cus", "ca", "cn", "ys", "ctx", "core", "js", "CS", "Cs", "kt", "cc", "cas", "css", "ces", "cer", "wcs", "cks", "ds", "ls", "act", "s", "acs", "TS", "qs", "ck", "ts", "c", "cv", "nc", "ec", "vs", "gc", "cp", "cons", " cons", "ns", "ks", "fs", "sts", "sc", "rs", "ps"], "t": ["a", "at", "tg", "tc", "et", "tu", "o", "f", "ptr", "ret", "l", "tt", "p", "tr", "n", "str", " mt", " T", "ant", "temp", "x", "dt", " ti", "v", "g", "text", "pt", "ent", "ert", "wt", "title", "tree", "m", "y", "T", "rt", "ts", " ot", "c", "b", "h", "ti", "mt", "u", "ot", "it", "to", " p", "total", "d", "token", "tm", "ta", "w", "i", "tp", "vt", "te", "txt", "iat"]}}
{"project": "qemu", "commit_id": "a277c3e094d5e9f653ccc861f59e07c94c7fe6c7", "target": 0, "func": "static int usb_host_init(void)\n\n{\n\n    const struct libusb_pollfd **poll;\n\n    int i, rc;\n\n\n\n    if (ctx) {\n\n        return 0;\n\n    }\n\n    rc = libusb_init(&ctx);\n\n    if (rc != 0) {\n\n        return -1;\n\n    }\n\n    libusb_set_debug(ctx, loglevel);\n\n\n\n    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,\n\n                                usb_host_del_fd,\n\n                                ctx);\n\n    poll = libusb_get_pollfds(ctx);\n\n    if (poll) {\n\n        for (i = 0; poll[i] != NULL; i++) {\n\n            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);\n\n        }\n\n    }\n\n    free(poll);\n\n    return 0;\n\n}\n", "idx": 12701, "substitutes": {"poll": ["olls", "query", "push", "ctx", "lib", "stat", "check", "pool", "maybe", "loc", "loop", "delay", "pipe", "select", "ux", "vote", "ul", "tick", "my", "archive", "ready", "queue", "exec", "pod", "hp", "wait", "ctl", "unc", "ptr", "search", "ll", "data", "cmd", "pop", "fd", "pol", "Poll", "buff", "wp", "sync", "look", "cp", "partial", "zip", "hook", "x", "txt", "resp", "scroll", "oc", "pause", "ock", "row", "call", "dl", "proc", "claim", "batch", "np", "update", "bot", "json", "sleep", "lex", "pc", "d", "ob", "roll", "pb", "ok", "p", "body", "download", " polled", "pt", "cache", "items", "ck", "pull", "host", "list", "col", "news", "oll"], "i": ["ij", "index", "li", " c", "iu", "oi", "ii", "mi", "I", "pi", " j", "ini", "j", "ei", " li", " di", "n", "ind", "si", "uri", "ki", "zi", " ti", "v", "cli", "bi", "batch", "t", "ui", "iq", "di", "asi", "ami", " ii", "ai", "m", "hi", "s", "qi", "xi", " bi", "sim", "im", "\u0438", "c", "ci", "mc", " ni", "ti", "my", "ri", "multi", "gi", "fi", "it", "me", "z", "phi", "x", "y", "ic", "ix", "ip"], "rc": ["isc", "cr", "tc", "oc", "src", "success", "ra", "cur", "ctx", "ok", "inc", "row", "RC", "cmp", "cc", "cas", "rr", "ctr", "iq", "result", "dc", "r", "context", "rt", "ck", "roc", "c", "cb", "ro", "nc", "ci", "ec", "sync", "res", "gc", "ry", "cs", "bc", "ack", "rin", "pc", "fc", "rec", "cont", "rx", "coll", "arc", "init", "sc", "rn", "ic", "rs"]}}
{"project": "qemu", "commit_id": "2dfb4c033f2f8fbad252bed1ba3e0fed112cbb7c", "target": 0, "func": "SnapshotInfo *qmp_blockdev_snapshot_delete_internal_sync(const char *device,\n\n                                                         bool has_id,\n\n                                                         const char *id,\n\n                                                         bool has_name,\n\n                                                         const char *name,\n\n                                                         Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockBackend *blk;\n\n    AioContext *aio_context;\n\n    QEMUSnapshotInfo sn;\n\n    Error *local_err = NULL;\n\n    SnapshotInfo *info = NULL;\n\n    int ret;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n\n                  \"Device '%s' not found\", device);\n\n        return NULL;\n\n    }\n\n\n\n    aio_context = blk_get_aio_context(blk);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (!has_id) {\n\n        id = NULL;\n\n    }\n\n\n\n    if (!has_name) {\n\n        name = NULL;\n\n    }\n\n\n\n    if (!id && !name) {\n\n        error_setg(errp, \"Name or id must be provided\");\n\n        goto out_aio_context;\n\n    }\n\n\n\n    if (!blk_is_available(blk)) {\n\n        error_setg(errp, \"Device '%s' has no medium\", device);\n\n        goto out_aio_context;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_INTERNAL_SNAPSHOT_DELETE, errp)) {\n\n        goto out_aio_context;\n\n    }\n\n\n\n    ret = bdrv_snapshot_find_by_id_and_name(bs, id, name, &sn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out_aio_context;\n\n    }\n\n    if (!ret) {\n\n        error_setg(errp,\n\n                   \"Snapshot with id '%s' and name '%s' does not exist on \"\n\n                   \"device '%s'\",\n\n                   STR_OR_NULL(id), STR_OR_NULL(name), device);\n\n        goto out_aio_context;\n\n    }\n\n\n\n    bdrv_snapshot_delete(bs, id, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out_aio_context;\n\n    }\n\n\n\n    aio_context_release(aio_context);\n\n\n\n    info = g_new0(SnapshotInfo, 1);\n\n    info->id = g_strdup(sn.id_str);\n\n    info->name = g_strdup(sn.name);\n\n    info->date_nsec = sn.date_nsec;\n\n    info->date_sec = sn.date_sec;\n\n    info->vm_state_size = sn.vm_state_size;\n\n    info->vm_clock_nsec = sn.vm_clock_nsec % 1000000000;\n\n    info->vm_clock_sec = sn.vm_clock_nsec / 1000000000;\n\n\n\n    return info;\n\n\n\nout_aio_context:\n\n    aio_context_release(aio_context);\n\n    return NULL;\n\n}\n", "idx": 12704, "substitutes": {"device": ["node", "server", "ide", "instance", "path", "network", "directory", "application", "product", "DEV", "display", "handle", "address", "family", "mode", "scope", "DE", "android", "module", "resource", "Device", "model", "project", "test", "hid", "kind", "spec", "domain", "controller", "command", "connection", "disk", "description", "development", "document", "buffer", "block", "image", "remote", " Device", "location", "link", "volume", "dev", "folder", "serial", "plugin", "component", "package", "database", "driver", "ident", "pod"], "has_id": ["Has_ID", "has___name", "has__id", "has___id", "has__name", "Has_ids", "Has_name", "Has_type", "has_ids", "Has_id", "has__ID", "Has_ident", "has___ident", "has_type", "has_ID", "has_ident", "has__ids", "has___type"], "id": ["key", "ide", "path", "index", "type", "est", "f", "and", "Id", "address", "data", "ids", "admin", "addr", "n", "p", "kid", "x", "aid", "ord", "created", "user", "try", "test", "md", "is", "hid", "uid", "mid", "end", "rid", "bid", "vid", "act", "in", "tag", " tid", "sid", "url", "time", "parent", "iso", " ID", "db", "event", "create", "no", "debug", "alias", "ID", "oid", "root", "h", "dev", "ad", "pid", "it", "d", "i", "iden", "only", "ident", "ip"], "has_name": ["Has_description", "has_error", "has_description", "have_names", "have_description", "Has_name", "Has_id", "have_error", "has_names", "Has_names", "have_name"], "name": ["key", "instance", "path", "error", "stable", "type", "version", "mem", "and", "number", "local", "size", "data", "n", "p", "nam", "resource", "filename", "names", "test", "source", "len", "spec", "common", "note", "title", "end", "new", "ext", "tag", "part", "description", "none", "time", "word", "comment", "Name", "prefix", "image", "file", "base", "event", "create", "ment", "no", "ns", "alias", "dev", "named", "term", "label", "mod", "length", "ame", "package", "nm", "NAME", "normal"], "errp": ["rrpp", "derpa", "orderpat", "derpat", "aerpress", " errps", "errpress", "errper", "eorpoint", "confP", "ererper", "attrv", "confpc", "rrp", "attrpress", " errpad", "orderpad", "attrp", "errv", "lerpc", "rrpa", "arrp", "errpat", "rerpat", "derper", " errP", "diep", "rerp", "errP", "tracepa", "rerpc", "aerpad", "arrpc", "derpc", "lerpa", "rrps", "ererpress", "lerp", "ererpc", "errpa", "arrpa", "aerpoint", "diepa", "ererp", "orderP", " errpa", "ererpoint", "rerpa", "tracepad", "errorp", "aerp", "errpoint", "arrpad", "rerP", "derp", "eorpat", " errpp", "errorP", "errorv", "erp", "derpress", " errpress", "errpp", "tracepc", "eorp", "derpad", "attrP", "errps", "ererpad", "ererpa", "dieps", "diepp", "errorpress", "rerpad", "confp", "lerper", "orderp", " errpc", "derpoint", "tracep", "ererpat", " errv", "erpc", "errpad", "erP", "errpc", " errpat", "eorpad"], "bs": ["gs", "ubs", "obs", "outs", "pb", "ctx", "hz", "js", "bits", "eb", "bh", "bi", "bes", "sb", "bt", "sys", "cks", "ds", "ls", "blocks", "bn", "bd", "BS", "ts", "bos", "bm", "db", "boxes", "base", "bas", "vs", "b", "ns", "bl", "cs", "bc", "lbs", "bed", "bles", "fs", "bps", "locks", "bis", "bb", "its", "bp", "ps"], "blk": ["bellkt", "clkt", "blke", "bellkg", " blke", "blkt", "Blk", "Blak", "bk", "bleak", "brkt", " blak", "slj", "clkg", "bellck", " bltk", "plck", "blek", "bleke", "btk", "bkt", "clck", "blck", "blkg", "BLak", "blak", "bltk", "blK", "BlK", "slak", "Blck", "slk", "bellk", "blekt", "BLk", "brak", "slck", "bck", "brck", " blkg", "brk", " blkt", "plak", "bleK", "BLke", "blj", "plj", "bleck", "bletk", "clk", " blj", " blK", " blck", "BLck", "plk"], "aio_context": ["aIO_context", "aio__context", "aio__client", "a8opContext", "aio_cache", "aio_connection", "a8_ctx", "aio_client", "aioopContext", "aio__Context", "aIO_connection", "a8opctx", "a8_condition", "aioopctx", "a8_context", "a8opcondition", "a8_Context", "aio_Context", "aIO_cache", "aio__data", "a8opcontext", "aio_data", "aio_condition", "aioopcontext", "aIO_ctx", "aio_ctx", "aioopcondition"], "sn": [" sc", "nl", " sidx", " sk", "sw", "ii", " su", "cn", " sr", " nu", "n", "si", " si", "sl", "Sn", "sam", "syn", "sol", " np", "sm", "sv", "sb", " esc", "st", "SN", "tn", " sys", "fl", "nr", "nt", " sl", "bn", " shr", " sh", "gn", "sp", "sr", "fn", " sd", " ss", "sh", " sap", " ssh", "ns", "ser", " Sn", "sc", "rn", " scr", " sw", "nn", "su", "sk"], "local_err": ["locallyerr", "local_gz", "local_core", "local_mr", " local_errors", "native_init", "localitycmd", "localityerr", "locallygz", "locallytry", "nativepyiter", "local____er", "locallyEr", "localpyfee", "local____mr", "local_try", "localMEr", "local_init", "localisedfee", "localityerrors", "locallyobj", "local_Er", "uniquepyerr", "unique_core", "local_fee", "global_iter", "locallyiter", "localitymr", "localisedtry", "nativepyerr", "localpyer", "localpyiter", "localingtry", "global_er", "localMer", "nativepyerror", "nativepyinit", "native_err", "localpycore", "localpyobj", "local_error", "local_iter", "local_errors", "localMerr", "localingfee", "unique_err", "local____errors", " local_mr", "localityer", "local_obj", "localisederr", " local_obj", "local____err", " local_er", "uniquepycore", "uniquepytry", " local_cmd", "locallyer", "localpyerr", "localpyerror", " local_init", "localMorder", "localpytry", "unique_try", "global_Er", " local_try", "localisedcore", "localpyinit", "global_order", "local____cmd", "native_error", "global_gz", "localingcore", "localityinit", "local_cmd", "unique_fee", "localingerr", "global_err", "native_iter", "uniquepyfee", "local_order", "local____init", "locallyorder", "local_er"], "info": ["tx", "def", "fw", "o", "ii", "pi", "data", "ki", "si", "ui", "new", "op", "obj", "json", "rt", "ani", "fo", "ci", "res", "dev", "ti", "fi", "Info", "i", "INFO", "txt", "inf", "ip"], "ret": ["resp", "status", "rem", "def", "mem", "ptr", "out", "success", " alt", " RET", "det", "ll", "back", "Ret", "tr", "rets", "RET", "val", "t", "ert", "result", "nz", "cat", "nt", "br", "lit", "true", "gt", "alt", "ern", "aux", "Alt", "rt", "Return", "backed", "lt", "res", "ber", "re", "__", "mt", "ft", "elt", "uf", "net", "err", " Ret", "sat", "selected", "full", "cont", "arr"]}}
{"project": "qemu", "commit_id": "3eff1f46f08a360a4ae9f834ce9fef4c45bf6f0f", "target": 0, "func": "static void virtio_scsi_complete_req(VirtIOSCSIReq *req)\n\n{\n\n    VirtIOSCSI *s = req->dev;\n\n    VirtQueue *vq = req->vq;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);\n\n    if (req->sreq) {\n\n        req->sreq->hba_private = NULL;\n\n        scsi_req_unref(req->sreq);\n\n    }\n\n    virtio_scsi_free_req(req);\n\n    virtio_notify(vdev, vq);\n\n}\n", "idx": 12710, "substitutes": {"req": ["cr", "query", "ctx", "expr", "cmp", "raw", "compl", "task", "eq", "require", "gr", "coord", "rol", "ack", "urg", "nil", "requ", "qt", "pkg", "exec", "required", "qq", "ps", "pro", "tx", "rem", "wait", "wx", "ind", "cmd", "crit", "md", "comm", "wcs", "aux", "tek", "inv", "comp", "res", "dep", "tab", "txt", "resp", "ref", "rw", "seq", "call", "ctr", "rest", "org", "progress", "fr", "err", "quest", "rr", "alloc", "jp", "request", "rss", "good", "grad", "reg", "pp", "msg", "ext", "desc", "r", "range", "dq", "decl", "rec", "that", "rel", "gz", "q", "rx", "needed"], "s": ["ses", "gs", "a", "S", "serv", "l", "n", "js", "p", "si", "sq", "v", "g", "t", "is", "sb", "sv", "sys", "ds", "ls", "ats", "sa", "ts", "c", "ns", "b", "cs", "es", "fs", "sd", "sg", "os", "d", "q", "ss", "i", "w", "rs", "ps"], "vq": ["svue", " vreq", "vqs", "vdq", "jue", " vqs", "biq", "jqueue", "svql", "bue", "vqt", " vch", "vrq", "svdq", " vqt", "svch", "jreq", "vqueue", " vqueue", "cvdq", "bch", "vqu", "bq", "svqu", "cvq", "svqt", "jiq", "cvql", "vch", "vreq", "invq", "bqueue", "svq", "bqs", "invqq", "bqt", "svqs", "sviq", "invreq", "invqueue", "cvqu", "viq", "vqq", "vue", "svqueue", "jq", "vrdq", "jqq", " vqq", "vql", "vrqu", "vrql"], "vdev": ["vDEV", "vpad", "vod", "vrod", "vrhw", "vrDEV", " vev", " vdevice", "wev", " vpad", "whw", "vrev", "wdev", "vrdev", " vhw", "vdevice", "vhw", "vev", "wod", "vrdevice", "vrpad", "tpad", " vDEV", " vod", "tDEV", "tdev", "tdevice"]}}
{"project": "qemu", "commit_id": "978f2205c791de0e02c8802a645bea657408abfd", "target": 0, "func": "bool timer_pending(QEMUTimer *ts)\n\n{\n\n    QEMUTimer *t;\n\n    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {\n\n        if (t == ts) {\n\n            return true;\n\n        }\n\n    }\n\n    return false;\n\n}\n", "idx": 12724, "substitutes": {"ts": ["td", "gs", "tl", "tc", "bs", "tv", "j", "tt", "js", "tr", "g", "pt", "tis", "als", "sys", "hs", "tn", "ds", "ats", "times", "s", "aps", "TS", "tle", "qs", "vals", "stats", "tz", "ins", "ns", "cs", "h", "ims", "uts", "te", "tick", "tes", "mt", "fs", "ks", "tim", "ss", "tp", "ms", "sts", "terms", "Ts", "ps"], "t": ["td", "tt", "ant", "typ", "mint", "task", "st", "new", "nt", "m", "att", "lat", "ht", "trace", "it", "qt", "ta", "te", "type", "tg", "tl", "j", "n", "tr", "or", "kt", "dt", "v", "g", "test", "T", "obj", "term", "tmp", "mt", "target", "x", "tp", "txt", "ty", "a", "at", "f", "out", "er", "c", "of", "ot", "d", "to", "token", "tm", "tc", "o", "l", "p", "ent", "pt", "wt", "title", "ext", "ct", "tree", "off", "rt", "tf", "lt", "b", "z", "w", "y"]}}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static int av_cold libopus_encode_init(AVCodecContext *avctx)\n\n{\n\n    LibopusEncContext *opus = avctx->priv_data;\n\n    const uint8_t *channel_mapping;\n\n    OpusMSEncoder *enc;\n\n    int ret = OPUS_OK;\n\n    int coupled_stream_count, header_size, frame_size;\n\n\n\n    coupled_stream_count = opus_coupled_streams[avctx->channels - 1];\n\n    opus->stream_count   = avctx->channels - coupled_stream_count;\n\n    channel_mapping      = libav_libopus_channel_map[avctx->channels - 1];\n\n\n\n    /* FIXME: Opus can handle up to 255 channels. However, the mapping for\n\n     * anything greater than 8 is undefined. */\n\n    if (avctx->channels > 8)\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Channel layout undefined for %d channels.\\n\", avctx->channels);\n\n\n\n    if (!avctx->bit_rate) {\n\n        /* Sane default copied from opusenc */\n\n        avctx->bit_rate = 64000 * opus->stream_count +\n\n                          32000 * coupled_stream_count;\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"No bit rate set. Defaulting to %d bps.\\n\", avctx->bit_rate);\n\n    }\n\n\n\n    if (avctx->bit_rate < 500 || avctx->bit_rate > 256000 * avctx->channels) {\n\n        av_log(avctx, AV_LOG_ERROR, \"The bit rate %d bps is unsupported. \"\n\n               \"Please choose a value between 500 and %d.\\n\", avctx->bit_rate,\n\n               256000 * avctx->channels);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    frame_size = opus->opts.frame_duration * 48000 / 1000;\n\n    switch (frame_size) {\n\n    case 120:\n\n    case 240:\n\n        if (opus->opts.application != OPUS_APPLICATION_RESTRICTED_LOWDELAY)\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"LPC mode cannot be used with a frame duration of less \"\n\n                   \"than 10ms. Enabling restricted low-delay mode.\\n\"\n\n                   \"Use a longer frame duration if this is not what you want.\\n\");\n\n        /* Frame sizes less than 10 ms can only use MDCT mode, so switching to\n\n         * RESTRICTED_LOWDELAY avoids an unnecessary extra 2.5ms lookahead. */\n\n        opus->opts.application = OPUS_APPLICATION_RESTRICTED_LOWDELAY;\n\n    case 480:\n\n    case 960:\n\n    case 1920:\n\n    case 2880:\n\n        opus->opts.packet_size =\n\n        avctx->frame_size      = frame_size * avctx->sample_rate / 48000;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid frame duration: %g.\\n\"\n\n               \"Frame duration must be exactly one of: 2.5, 5, 10, 20, 40 or 60.\\n\",\n\n               opus->opts.frame_duration);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (avctx->compression_level < 0 || avctx->compression_level > 10) {\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Compression level must be in the range 0 to 10. \"\n\n               \"Defaulting to 10.\\n\");\n\n        opus->opts.complexity = 10;\n\n    } else {\n\n        opus->opts.complexity = avctx->compression_level;\n\n    }\n\n\n\n    if (avctx->cutoff) {\n\n        switch (avctx->cutoff) {\n\n        case  4000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_NARROWBAND;\n\n            break;\n\n        case  6000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_MEDIUMBAND;\n\n            break;\n\n        case  8000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_WIDEBAND;\n\n            break;\n\n        case 12000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_SUPERWIDEBAND;\n\n            break;\n\n        case 20000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_FULLBAND;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"Invalid frequency cutoff: %d. Using default maximum bandwidth.\\n\"\n\n                   \"Cutoff frequency must be exactly one of: 4000, 6000, 8000, 12000 or 20000.\\n\",\n\n                   avctx->cutoff);\n\n            avctx->cutoff = 0;\n\n        }\n\n    }\n\n\n\n    enc = opus_multistream_encoder_create(avctx->sample_rate, avctx->channels,\n\n                                          opus->stream_count,\n\n                                          coupled_stream_count,\n\n                                          channel_mapping,\n\n                                          opus->opts.application, &ret);\n\n    if (ret != OPUS_OK) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Failed to create encoder: %s\\n\", opus_strerror(ret));\n\n        return ff_opus_error_to_averror(ret);\n\n    }\n\n\n\n    ret = libopus_configure_encoder(avctx, enc, &opus->opts);\n\n    if (ret != OPUS_OK) {\n\n        ret = ff_opus_error_to_averror(ret);\n\n        goto fail;\n\n    }\n\n\n\n    header_size = 19 + (avctx->channels > 2 ? 2 + avctx->channels : 0);\n\n    avctx->extradata = av_malloc(header_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!avctx->extradata) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to allocate extradata.\\n\");\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    avctx->extradata_size = header_size;\n\n\n\n    opus->samples = av_mallocz(frame_size * avctx->channels *\n\n                               av_get_bytes_per_sample(avctx->sample_fmt));\n\n    if (!opus->samples) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to allocate samples buffer.\\n\");\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    ret = opus_multistream_encoder_ctl(enc, OPUS_GET_LOOKAHEAD(&avctx->delay));\n\n    if (ret != OPUS_OK)\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Unable to get number of lookahead samples: %s\\n\",\n\n               opus_strerror(ret));\n\n\n\n    libopus_write_header(avctx, opus->stream_count, coupled_stream_count,\n\n                         opus_vorbis_channel_map[avctx->channels - 1]);\n\n\n\n    ff_af_queue_init(avctx, &opus->afq);\n\n\n\n    opus->enc = enc;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    opus_multistream_encoder_destroy(enc);\n\n    av_freep(&avctx->extradata);\n\n    return ret;\n\n}\n", "idx": 12730, "substitutes": {"avctx": ["avecf", "avcv", "avtx", " avnp", "avercmd", " avdl", "vertx", "avercfg", " avkl", "averheight", "avetmp", "aveparams", "avercontext", "vantx", "ajcfg", "avparams", "avpkg", "avpop", "avtmp", "averct", "avheight", "abcontext", "afpkg", "averkt", "avect", "vanpop", "avertx", " avkt", "ovdyl", "ravdl", "ajdyl", " avcontext", "ajtxt", "avercmp", "avcfg", " avcf", "ajcmd", "averkl", "abtx", "averpop", "ravjac", "avcmp", "abcp", "ovctx", "avsys", "avkl", "vanctx", "ajct", "afcb", "avdl", "avcb", "savctx", "avecontext", "averdyl", "aveheight", "aftx", "ajcu", "ajcp", "savparams", "afpop", "avetx", "averctl", "verctx", " avcmp", "abctx", " avcfg", "aversys", "verctl", "avernp", "ajsys", "avertmp", "avekt", "ajcmp", "avedl", "avtxt", "avecfg", "savcfg", "avcu", "savtx", "avecu", "vancb", "avdyl", " avct", "averparams", "averpkg", "afcf", "afcontext", "ajcontext", "avekl", "savdyl", "ovcmd", "avecmd", "ovtxt", "avcp", "ravctx", "avertxt", "ajpkg", "afctx", "afdyl", " avdyl", "averctx", "avcmd", "avecv", "ravcontext", "verkl", " avjac", "afcv", "abpkg", "avkt", "avconn", "avercf", "ajtx", "savheight", "avejac", "ajrt", "avecmp", "afcfg", "afsys", "aveconn", "avercb", "avnp", "avjac", "avectl", "vercfg", "abcmd", "avctl", "avenp", "avcontext", "avedyl", "avepkg", "avert", " avcmd", "ajctx", " avtx", "savconn", "avrt", "avectx", "ajkt", "ajcf", "avcf", "afcu", "avercp", "afrt", "verpkg", "afconn", " avcv", "avct", "vertmp"], "opus": ["tumblr", "audio", "ctx", "oga", "offic", "iop", "uo", "Flickr", "aval", "avan", "biology", "photo", "mit", "apache", "soc", "wordpress", "ave", "archive", "fps", "us", "pheus", "alph", "pop", "apa", "conv", "liv", "oper", "orp", "picture", "photos", "cop", "oster", "apo", "ais", "phot", "volume", "upload", "root", "uploads", "verb", "join", "av", "jack", "ip", "vo", "paste", "ophon", "ocr", "oxy", "vp", "aud", "capt", "operative", "phones", "userc", "aus", "np", "op", "oscope", "aic", "ost", "ops", "osa", "amps", "oos", "oops", "bis", "amp", "album", "profile", "username", "umi", "au", "opa", "ahi", "ipper", "itch", "avin", "pp", "voice", "addin", "opl", "bank", "music", "ivo", "avi", "wikipedia", "voc"], "channel_mapping": ["channel_mapappings", "channel_mappings", "channel_smapping", "channel_bmapping", "channel_Mapping", "channel_Mappings", "channel_mapter", "channel_mapapper", "channel_smapper", "channel_mapapping", "channel_mapper", "channel_smapter", "channel_bmapper", "channel_bmapter", "channel_Mapper", "channel_Mapter"], "enc": ["Enc", "vec", "conn", "auth", "cmp", "cod", "proc", "conv", "ent", "act", "op", "obj", "ac", "ENC", "ec", "res", "ack", "rec", "fc", "con", "oder", "eng", "vc", "ev", "ic", "txt", "ch"], "coupled_stream_count": ["coupled_stream_data", "coupled_length_count", "coupled_stream2count", "coupled_length_length", "coupled_stream_length", "coupled_channel_counter", "coupled_length_size", "coupled_channel_length", "coupled_channel_data", "coupled_stream_Count", "coupled_stream_counter", "coupled_stream2counter", "coupled_stream_size", "coupled_channel_count", "coupled_channel_size", "coupled_channel_Count", "coupled_stream2length"], "header_size": ["line_size", "line_count", "header_SIZE", "line_shape", "header_count", "header_shape", "line_SIZE"], "frame_size": ["frame67size", "draw_size", "header_color", "frameetyrate", "frame_color", "frame\u05bcresolution", "frame_rate", "drawlylength", "frame\u05bcrate", " frame_count", "frame_resolution", "facelystatus", "framelyowner", "header\u05bccolor", "face_status", "framelyno", " frame_offset", "framelySize", "framelyrate", "drawlyrate", "frameetyno", "face_size", "frame67unit", " frame_length", " frame_no", "header\u05bcsize", "frameetyindex", "drawlysize", "facelySize", "frameetysize", "framelysize", "facelysize", "frame_Size", "frame67status", "framelystatus", "frame_unit", "face_unit", "frame\u05bccolor", "frameetyresolution", "frame_owner", "draw_owner", "framelyindex", "frameetycolor", "frame\u05bcsize", "header\u05bcrate", "draw_length", "facelyunit", "header\u05bcresolution", "face_Size", "frame_no", "frame_offset", "frame67Size", "frame_status", " frame_index", "drawlyowner", "frame_index", "draw_rate", "frame_length", "framelylength", "framelyunit", "frame_count", "header_rate", "header_resolution"]}}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_rt_frame(int sig, struct emulated_sigaction *ka, \n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUX86State *env)\n\n{\n\n\tstruct rt_sigframe *frame;\n\n\tint err = 0;\n\n\n\n\tframe = get_sigframe(ka, env, sizeof(*frame));\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\n\t\tgoto give_sigsegv;\n\n#endif\n\n\n\n\terr |= __put_user((/*current->exec_domain\n\n\t\t    \t   && current->exec_domain->signal_invmap\n\n\t\t    \t   && sig < 32\n\n\t\t    \t   ? current->exec_domain->signal_invmap[sig]\n\n\t\t\t   : */sig),\n\n\t\t\t  &frame->sig);\n\n\terr |= __put_user((target_ulong)&frame->info, &frame->pinfo);\n\n\terr |= __put_user((target_ulong)&frame->uc, &frame->puc);\n\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Create the ucontext.  */\n\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\n\terr |= __put_user(0, &frame->uc.uc_link);\n\n\terr |= __put_user(/*current->sas_ss_sp*/ 0, &frame->uc.uc_stack.ss_sp);\n\n\terr |= __put_user(/* sas_ss_flags(regs->esp) */ 0,\n\n\t\t\t  &frame->uc.uc_stack.ss_flags);\n\n\terr |= __put_user(/* current->sas_ss_size */ 0, &frame->uc.uc_stack.ss_size);\n\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate,\n\n\t\t\t        env, set->sig[0]);\n\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t/* This is movl $,%eax ; int $0x80 */\n\n\t\terr |= __put_user(0xb8, (char *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_rt_sigreturn, (int *)(frame->retcode+1));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+5));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n", "idx": 12741, "substitutes": {"sig": ["dsign", "sigm", "isIG", "sIG", "jsIG", "stsign", "SIG", "psign", "stsig", "sigs", "sich", "psigs", "stsich", "dsigen", "psig", "Sigen", "Sigs", "stsigs", "jsigen", "Sign", " sigm", "testsigma", " sich", "testsig", "sigen", "dsig", "testsiger", " sigen", "isigma", "lsigen", "jsigm", "testsIG", "Sig", "Sigma", "Siger", "siger", "isig", "lsig", "psich", "isiger", " sign", "sign", "dsigs", "jsig", "sigma", " sIG", "lsigs", " sigs", "lsign"], "ka": ["kw", "Ka", "ski", "ena", "aka", "ki", "km", "apa", "kt", "ket", "hw", "ema", "KA", "arma", "tk", "ha", "kat", "sama", "eta", "ami", "ke", "ku", "k", "sa", "kr", "ko", "uma", "qa", "kas", "ja", "ck", "kan", "ama", "ak", "kl", "ken", "ker", "kj", "gha", "ma", "ta", "tp", "pa", "ica", "sk"], "info": ["status", "rc", "def", "error", "type", "metadata", "mem", "f", "about", "conn", "obi", "local", "out", "ii", "data", "ist", "ctx", "ki", "auth", "si", "stat", "information", "user", "text", "name", "details", "io", "ui", "loc", "priv", "is", "ext", "nt", "sa", " inf", "hi", "meta", "doc", "iso", "isu", "fo", "ro", "recent", "ci", "summary", "id", "jo", "dict", "ti", "conf", " fi", "os", "prof", "it", "fi", " INFO", "Info", "ta", "i", "news", "init", "INFO", "tab", "txt", "history", "inf"], "set": ["sett", "et", "Set", "push", "session", "pen", "section", "setup", "data", "map", "ctx", "ex", "call", "si", "window", "ut", "reset", "check", "test", "eq", "store", "t", "spec", "loc", "st", "end", "msg", "ext", "tree", "send", "SET", "sa", "get", "update", "step", "add", "use", "open", "setting", "sp", "up", "site", "block", "en", "sche", "sh", "from", "it", " Set", "to", "state", "se", "init", "sc", "ch", "pack"], "env": ["server", "nv", "esm", "mem", "ptr", "et", "environment", "setup", "addr", "ctx", "hw", "window", "ut", "v", "eq", "esc", "loc", "er", "buf", "end", "ef", "eu", "ten", "ew", "context", "obj", "doc", "org", "stage", "va", "cb", "cv", "en", "ec", "code", "vs", "dev", "te", "e", "here", "enc", "state", "ape", "eng", "net", "ev", "vt", "init", "sc", "usr", "viron", "gov", "ote"], "frame": ["header", "scope", "sequence", "window", "role", "t", "close", "command", "send", "lock", "flow", "line", "channel", "word", "doc", "function", "po", "tick", "draw", "factor", "trace", "method", "ence", "ma", "def", "error", "type", "data", "cmd", "module", "reset", "next", "frames", "ke", "rame", "fb", "link", "term", "fi", "style", "join", "node", "cf", "face", "f", "version", "ref", "out", "row", "call", "feat", "user", "zone", "step", "stage", "block", "remote", "file", "fr", "scene", "iter", "state", "err", "me", "shot", "process", "force", "profile", "dict", "request", "local", "session", "response", "rule", "feature", "ze", "connection", "condition", "message", "image", "event", "base", "page", "code", "Frame", "e", "point", "list", "component", "cause", "init", "ce"]}}
{"project": "qemu", "commit_id": "f2001a7e0555b66d6db25a3ff1801540814045bb", "target": 0, "func": "static void tcp_chr_telnet_init(QIOChannel *ioc)\n\n{\n\n    char buf[3];\n\n    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */\n\n    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n}\n", "idx": 12777, "substitutes": {"ioc": ["lios", " iot", "fioci", "iiocl", "iiocal", "uioc", "lioci", "uoci", "iocent", "piocy", "pioci", "cioco", "kioc", "ciocon", "fiocy", " ioco", "iocal", "liocy", "pioc", "ciog", " iocy", "ioci", "liocent", "uiocl", "lioc", "uocy", "uioci", "iog", "uiocal", "iocy", "uiocy", "ioco", "Iocon", "iot", "Ioc", "fioc", " ioca", " ioci", " iog", "uoco", "pioco", "ioca", "uoc", "ciot", "kioci", " iocon", "iios", "iioc", "uiocent", "cioca", "Iot", "cioci", "kiog", "iocl", "fiocent", "uios", "iocon", "cioc", "liocl", "liocal", "Ioco", "kioca"], "buf": ["vec", "cur", "ctx", "window", "raw", "agg", "pool", " buffer", "BU", "ann", "cb", "coord", "fac", "urg", "uf", "queue", "pkg", "usr", "ait", "rc", "kw", "fw", "ptr", "data", "map", "aka", "cmd", "tr", "Buffer", "conv", "v", "box", "comm", "buff", "cat", "br", "fb", "db", "burst", "font", "tmp", "eng", "history", "Buff", "um", "seq", " vec", "row", "temp", "bh", "proc", "vp", "text", "batch", "ctr", "buffer", "block", "cv", "etc", "iter", "package", "str", "good", "pb", "msg", "cap", "func", "xff", "desc", "bag", "off", "bu", "pend", "img", "b", " buff", "var", "w", "nm"]}}
{"project": "qemu", "commit_id": "1606e4cf8a976513ecac70ad6642a7ec45744cf5", "target": 1, "func": "static void blk_delete(BlockBackend *blk)\n\n{\n\n    assert(!blk->refcnt);\n\n    assert(!blk->name);\n\n    assert(!blk->dev);\n\n\n\n\n    if (blk->root) {\n\n        blk_remove_bs(blk);\n\n\n    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));\n\n    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));\n\n    QTAILQ_REMOVE(&block_backends, blk, link);\n\n    drive_info_del(blk->legacy_dinfo);\n\n    block_acct_cleanup(&blk->stats);\n\n    g_free(blk);\n", "idx": 12780, "substitutes": {"blk": ["blke", "brok", "blkt", "glck", "clck", "bld", "lnk", "glak", "lnak", "brod", "clb", "blm", " blkg", " blkt", "clk", "bleb", "plk", "replunk", "glk", "Blk", "glm", "blockk", " blak", "blockak", "plck", "blek", "broak", "blck", "boke", "Blkt", "brokg", "bok", "blak", "brounk", "BLk", "Blb", "clak", "plak", " bld", "milunk", "grk", " blck", "relkt", "replak", "lnke", "blw", "relk", "replk", " blz", "blekt", "brak", "lnw", "brck", "relck", "milkg", "blockck", "brk", " blm", "blz", "milck", "bleck", "pld", "BLck", "replck", "blew", "milk", "grak", " blb", "boak", "Blak", "bleak", "blockm", "blez", "brkt", "brz", "relak", "bleke", "blkg", "grunk", "BLak", "bow", "blb", "brokt", "Blck", "plb", "brock", "blunk", "plkt", "grkt", "BLkt", " blunk"]}}
{"project": "qemu", "commit_id": "bb16172c52ac18742f3df156912c169904e92147", "target": 1, "func": "static int gdbserver_open(int port)\n\n{\n\n    struct sockaddr_in sockaddr;\n\n    int fd, val, ret;\n\n\n\n    fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n#ifndef _WIN32\n\n    fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n\n\n    /* allow fast reuse */\n\n    val = 1;\n\n    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));\n\n\n\n    sockaddr.sin_family = AF_INET;\n\n    sockaddr.sin_port = htons(port);\n\n    sockaddr.sin_addr.s_addr = 0;\n\n    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n\n        return -1;\n\n    }\n\n    ret = listen(fd, 0);\n\n    if (ret < 0) {\n\n        perror(\"listen\");\n\n\n        return -1;\n\n    }\n\n    return fd;\n\n}", "idx": 12785, "substitutes": {"port": ["server", "index", "path", "type", "version", "Port", "ptr", "et", "number", "socket", "position", "ports", "address", "pi", "family", "size", "p", "timeout", "pport", "eport", "v", "test", "pt", "localhost", "padding", "message", "PORT", "ORT", "file", "count", "page", "limit", "print", "ort", "host", "direction", "pid", "length", "format", "interface", "priority"], "sockaddr": [" sipopt", " sockattr", "sigptr", "sockadd", "Sockadd", "songattr", "sipaddr", "sysaddr", "sinkaddr", "sigaddress", " songopt", "Sockptr", " sinkadd", "sipaddress", "jsysaddr", "sackaddr", "Sckadd", "sessopt", "socksoa", "jsysopt", "sigadd", "songopt", "sckaddress", "sckaddr", "sockmap", "jsysorder", " sckattr", "Sockaddress", "sinkopt", " sckptr", " sockadd", "sessadd", " sinkaddr", " sinkdir", "sOCKdir", "sinkdir", "socattr", " sipadd", "Sckaddr", "sockattr", "sinkadd", "sockdir", "songmap", "sackopt", " sockopt", " sockadr", "sackorder", "sockoa", "jsockorder", "sOCKoa", "sysadd", " sipattr", "sckdir", "sigaddr", " sockmap", "socksaddr", "sinkattr", " sckoa", " songaddr", "sipopt", "sockadr", "sinkorder", "sckoa", "socksattr", "Sckaddress", "socksadr", "sysopt", "sipadd", "sockopt", "jsockattr", "socksptr", "sockptr", " sockdir", "sysptr", "Sckptr", " sckadd", "socmap", "sOCKaddr", "sockaddress", "socopt", "sysorder", "jsockopt", "sysattr", " sockptr", " songmap", " sckaddr", "sessaddr", "socksadd", " sckadr", "Sockaddr", " songattr", "socaddr", "sckptr", "sckadd", "sipptr", "sckattr", "sackattr", "jsysattr", " sipaddr", "sessattr", "sckadr", "sOCKadr", "sockorder", "sOCKadd", "sipattr", "songaddr", " sockoa", "jsockaddr", "sackmap"], "fd": ["ctl", "td", "cf", "fed", "unc", "ptr", "f", "handle", "ff", "ind", "ctx", "ln", "stream", "dl", "window", " ff", "dir", "dt", "pd", "fm", "fl", " fid", "func", "ds", "da", "in", "dd", "disk", "ud", "fb", "bd", " df", "hd", "db", "fp", "file", "bf", "fn", "ffff", "df", "flag", "id", "FD", "fc", "fr", "draw", "fs", "pid", "sd", "d", "fi", "elt", "uf", "dat", "i", "fin", "ld"], "val": ["vol", "tx", "il", "index", "def", "key", "Val", "mem", "f", "serv", "ref", "ind", "ctx", "p", "x", "pol", "v", "reg", "el", "pt", "sl", "test", "sol", "len", "eval", "sil", "sec", "fl", "al", "fee", "vals", "sel", "cal", "res", "rol", "cho", "VAL", "var", "col", "it", "elt", "fi", "bal", "vc", "value", "vt", "valid", "txt"], "ret": ["resp", "rem", "def", "nl", "mem", "ref", "inter", "bool", "det", "fun", "back", "fin", "cmd", "Ret", "tr", "reply", "opt", "rets", "RET", "dt", "after", "deg", "reset", "not", "try", "mail", "alf", "len", "rm", "result", "ben", "prot", "ext", "func", "nt", "desc", "get", "nat", "gt", "alt", "rect", "att", "url", "rt", "cb", "backed", "bf", "res", "flag", "print", "cert", "re", "mt", "ft", "it", "fi", "elt", "err", "final", "del", "vt", "leg", "cont", "arr"]}}
{"project": "qemu", "commit_id": "280503ee9d7833a793770d732dda5358659825e9", "target": 1, "func": "static void spapr_nvram_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);\n\n\n\n    k->realize = spapr_nvram_realize;\n\n    k->devnode = spapr_nvram_devnode;\n\n    k->dt_name = \"nvram\";\n\n    k->dt_type = \"nvram\";\n\n    k->dt_compatible = \"qemu,spapr-nvram\";\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->props = spapr_nvram_properties;\n\n    dc->vmsd = &vmstate_spapr_nvram;\n\n\n\n}", "idx": 12786, "substitutes": {"klass": ["klasses", " kasso", " kls", "Klass", "tklass", "Kasso", " klasses", "ikklass", "ikkls", "ikklasses", "Klf", "Klasses", "kcl", " kcl", "ikkcl", "tklf", "kasso", "tkls", "klf", "tklasses", "kls", "tkasso", "Kls", "Kcl", " klf"], "data": ["key", "def", "rc", " DATA", "module", " d", "kind", "di", "cache", "bin", "result", "bus", "json", "mu", " sd", "Data", "res", "device", "dev", "d", "DATA", "ata", "value", "dat", "w", "name", " Data"], "dc": ["cu", "kw", "td", "rc", "cr", "tc", "oc", "cm", "lc", "core", "cc", "cca", "cd", "dm", "dt", "dp", "DC", "ga", "md", "di", "nz", "ac", "c", "db", "disc", "nc", "dk", "ec", "cp", "gc", "mc", "bc", "pc", "fc", "d", "dh", " DC", "iac", "ca"], "k": ["key", "kw", "kn", "kh", "uk", "j", "ok", "ki", "p", "km", "kt", "kk", "tk", "mk", "g", "ik", "kind", "ku", "K", "ek", "kr", "ko", "ac", "ck", "kan", "work", "c", "ak", "kar", "kick", "dk", "wk", "kl", "ack", "unk", "ijk", "ks", "max", "it", "ikk", "kj", "pkg", "ka", "sk"]}}
{"project": "qemu", "commit_id": "aedbe19297907143f17b733a7ff0e0534377bed1", "target": 1, "func": "static void cpu_handle_ioreq(void *opaque)\n\n{\n\n    XenIOState *state = opaque;\n\n    ioreq_t *req = cpu_get_ioreq(state);\n\n\n\n    handle_buffered_iopage(state);\n\n    if (req) {\n\n        ioreq_t copy = *req;\n\n\n\n        xen_rmb();\n\n        handle_ioreq(state, &copy);\n\n        req->data = copy.data;\n\n\n\n        if (req->state != STATE_IOREQ_INPROCESS) {\n\n            fprintf(stderr, \"Badness in I/O request ... not in service?!: \"\n\n                    \"%x, ptr: %x, port: %\"PRIx64\", \"\n\n                    \"data: %\"PRIx64\", count: %u, size: %u, type: %u\\n\",\n\n                    req->state, req->data_is_ptr, req->addr,\n\n                    req->data, req->count, req->size, req->type);\n\n            destroy_hvm_domain(false);\n\n            return;\n\n        }\n\n\n\n        xen_wmb(); /* Update ioreq contents /then/ update state. */\n\n\n\n        /*\n\n         * We do this before we send the response so that the tools\n\n         * have the opportunity to pick up on the reset before the\n\n         * guest resumes and does a hlt with interrupts disabled which\n\n         * causes Xen to powerdown the domain.\n\n         */\n\n        if (runstate_is_running()) {\n\n            if (qemu_shutdown_requested_get()) {\n\n                destroy_hvm_domain(false);\n\n            }\n\n            if (qemu_reset_requested_get()) {\n\n                qemu_system_reset(VMRESET_REPORT);\n\n                destroy_hvm_domain(true);\n\n            }\n\n        }\n\n\n\n        req->state = STATE_IORESP_READY;\n\n        xenevtchn_notify(state->xce_handle,\n\n                         state->ioreq_local_port[state->send_vcpu]);\n\n    }\n\n}\n", "idx": 12787, "substitutes": {"opaque": [" opatile", " opaco", "OPatile", "oposter", "poster", "OPosit", "Oposit", "pque", "OPoster", "Opaque", "Opaco", "oplation", "OPlation", "Oposter", "oposit", "Opque", "opatile", "opaco", "paque", "Oplation", "OPaco", "opque", "OPaque", " oplation", "OPque", "posit", "Opatile"], "state": ["cor", "index", "conn", "ctx", "scope", "State", "sequence", "class", "stat", "pool", "port", "t", "close", "com", "loop", "controller", "st", "context", "stats", "change", "states", "start", "trace", "see", "length", "tx", "view", "type", "mem", "address", "data", "addr", "resource", "try", "test", "spec", "power", "STATE", "release", "pos", "res", "print", "root", "area", "ion", "style", "level", "history", "version", "out", "head", "store", "now", "offset", "in", "al", "roy", "powered", "info", "progress", "buffer", "we", "debug", "id", "ot", "hash", "config", "init", "bar", "status", "instance", "local", "session", "handle", "estate", "size", "core", "mode", "rule", "cache", "msg", "connection", "tag", "lease", "range", "runner", "count", "base", "code", "post", "action", "master", "list", "component", "value", "name", "color"], "req": ["conn", "query", "push", "attr", "ctx", "expr", "sq", "clip", "task", "low", "fresh", "require", "urg", "repl", "requ", "qt", "need", "pkg", "exec", "required", "qq", "tx", "mem", "ptr", "prev", "patch", "wx", "ind", "data", "cmd", "crit", "next", "dist", "obj", "aux", "inv", "comp", "res", "tar", "esp", "txt", "copy", "resp", "ref", "seq", "call", "reply", "proc", "ctr", "grab", "rep", "org", "info", "progress", "fr", "config", "err", "init", "quest", "rr", "alloc", "jp", "request", "rss", "good", "msg", "ext", "desc", "r", "subject", "quick", "range", "dq", "parse", "rt", "rec", "var", "q", "needed"]}}
{"project": "qemu", "commit_id": "846424350b292f16b732b573273a5c1f195cd7a3", "target": 1, "func": "static bool scsi_target_emulate_inquiry(SCSITargetReq *r)\n\n{\n\n    assert(r->req.dev->lun != r->req.lun);\n\n    if (r->req.cmd.buf[1] & 0x2) {\n\n        /* Command support data - optional, not implemented */\n\n        return false;\n\n    }\n\n\n\n    if (r->req.cmd.buf[1] & 0x1) {\n\n        /* Vital product data */\n\n        uint8_t page_code = r->req.cmd.buf[2];\n\n        r->buf[r->len++] = page_code ; /* this page */\n\n        r->buf[r->len++] = 0x00;\n\n\n\n        switch (page_code) {\n\n        case 0x00: /* Supported page codes, mandatory */\n\n        {\n\n            int pages;\n\n            pages = r->len++;\n\n            r->buf[r->len++] = 0x00; /* list of supported pages (this page) */\n\n            r->buf[pages] = r->len - pages - 1; /* number of pages */\n\n            break;\n\n        }\n\n        default:\n\n            return false;\n\n        }\n\n        /* done with EVPD */\n\n        assert(r->len < sizeof(r->buf));\n\n        r->len = MIN(r->req.cmd.xfer, r->len);\n\n        return true;\n\n    }\n\n\n\n    /* Standard INQUIRY data */\n\n    if (r->req.cmd.buf[2] != 0) {\n\n        return false;\n\n    }\n\n\n\n    /* PAGE CODE == 0 */\n\n    r->len = MIN(r->req.cmd.xfer, 36);\n\n    memset(r->buf, 0, r->len);\n\n    if (r->req.lun != 0) {\n\n        r->buf[0] = TYPE_NO_LUN;\n\n    } else {\n\n        r->buf[0] = TYPE_NOT_PRESENT | TYPE_INACTIVE;\n\n        r->buf[2] = 5; /* Version */\n\n        r->buf[3] = 2 | 0x10; /* HiSup, response data format */\n\n        r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */\n\n        r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */\n\n        memcpy(&r->buf[8], \"QEMU    \", 8);\n\n        memcpy(&r->buf[16], \"QEMU TARGET     \", 16);\n\n        pstrcpy((char *) &r->buf[32], 4, qemu_get_version());\n\n    }\n\n    return true;\n\n}\n", "idx": 12789, "substitutes": {"r": ["cr", "hr", "attr", "mr", "dr", "rl", "ir", "rar", "rate", "rm", "result", "ur", "m", "rev", "art", "sr", "gr", "rg", "it", "R", "rn", "usr", "rc", "rem", "error", "pr", "j", "tr", "rf", "or", "resource", "after", "reset", "g", "ar", "br", "kr", "rect", "obj", "self", "res", "ref", "rw", "this", "req", "adr", "er", "rb", "nr", "rest", "reader", "ro", "ry", "fr", "rd", "d", "err", "rr", "request", "lr", "l", "ren", "response", "p", "vr", "item", "url", "rt", "runner", "render", "rh", "all", "rer", "h", "re", "rec", "e", "rel", "var", "z", "q", "rx", "w", "y", "rs"], "pages": ["bytes", "types", "cats", " Pages", "ages", " instances", "prev", "codes", "units", "pointers", "tags", "lines", "data", "values", "p", "devices", "params", "keys", " page", "names", "rows", "next", "pp", "apps", "pins", "points", "num", "times", "heads", "blocks", "steps", "items", "days", "ips", "hops", "count", "page", "pos", "ins", "resources", "start", "pg", "links", "books", "images", "modules", "pdf", "posts", " p", "total", "inks", "Pages", "files", "users", "planes", "packages", "ps"]}}
{"project": "qemu", "commit_id": "de82815db1c89da058b7fb941dab137d6d9ab738", "target": 1, "func": "int qcow2_expand_zero_clusters(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table = NULL;\n\n    uint64_t nb_clusters;\n\n    uint8_t *expanded_clusters;\n\n    int ret;\n\n    int i, j;\n\n\n\n    nb_clusters = size_to_clusters(s, bs->file->total_sectors *\n\n                                   BDRV_SECTOR_SIZE);\n\n    expanded_clusters = g_malloc0((nb_clusters + 7) / 8);\n\n\n\n    ret = expand_zero_clusters_in_l1(bs, s->l1_table, s->l1_size,\n\n                                     &expanded_clusters, &nb_clusters);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Inactive L1 tables may point to active L2 tables - therefore it is\n\n     * necessary to flush the L2 table cache before trying to access the L2\n\n     * tables pointed to by inactive L1 entries (else we might try to expand\n\n     * zero clusters that have already been expanded); furthermore, it is also\n\n     * necessary to empty the L2 table cache, since it may contain tables which\n\n     * are now going to be modified directly on disk, bypassing the cache.\n\n     * qcow2_cache_empty() does both for us. */\n\n    ret = qcow2_cache_empty(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        int l1_sectors = (s->snapshots[i].l1_size * sizeof(uint64_t) +\n\n                BDRV_SECTOR_SIZE - 1) / BDRV_SECTOR_SIZE;\n\n\n\n        l1_table = g_realloc(l1_table, l1_sectors * BDRV_SECTOR_SIZE);\n\n\n\n        ret = bdrv_read(bs->file, s->snapshots[i].l1_table_offset /\n\n                BDRV_SECTOR_SIZE, (void *)l1_table, l1_sectors);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        for (j = 0; j < s->snapshots[i].l1_size; j++) {\n\n            be64_to_cpus(&l1_table[j]);\n\n        }\n\n\n\n        ret = expand_zero_clusters_in_l1(bs, l1_table, s->snapshots[i].l1_size,\n\n                                         &expanded_clusters, &nb_clusters);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\n\n\nfail:\n\n    g_free(expanded_clusters);\n\n    g_free(l1_table);\n\n    return ret;\n\n}\n", "idx": 12799, "substitutes": {"bs": ["ses", "aws", "stones", "ashes", "gs", "ubis", "ubs", "aos", "obs", "outs", "pb", "hz", "js", "bits", "bh", "bes", "sb", "aus", "hs", "lb", "cks", "sys", "ds", "ls", "blocks", "oss", "BS", "acs", "ts", "bos", "bm", "boxes", "blog", "vs", "b", "bl", "cs", "bc", "ns", "lbs", "bles", "fs", "bps", "locks", "os", "bis", "its", "bp", "fps", "ss", "sts", "rs"], "s": ["ses", "aws", "gs", "a", "S", "sw", "settings", "as", "less", "p", "js", "bits", "sq", "plays", "abilities", "sl", "ms", "bes", "comm", "is", "sb", "sv", "als", "space", "sys", "hs", "spec", "ds", "ls", "ats", "steps", "ies", "ssl", "qs", "ts", "c", "stats", "vs", "ins", "states", "b", "ns", "cs", "h", "es", "ims", "args", "ops", "changes", "fs", "locks", "os", "bis", "its", "parts", "sn", "ss", "sts", "irs", "rs", "ps"], "l1_table": ["l4_table", "l1stab", "l1zcontainer", "l1pytable", "l1_tab", "l1actable", "l14Parray", "l4ttable", "l1acquery", "l4tt", "l4_t", "l41_bl", "l41_buffer", "l1ztable", "l4_tab", "l1ttable", "l1PTable", "l14PTable", "l4tbuffer", "l1zbuffer", "l1_cache", "l4ttab", "l1_array", "l14_table", "l1pyentity", "l2_table", "l14_array", "l1_able", "l1stable", "l1_buffer", "l41_table", "l1_entry", "l2_tree", "l1_Table", "l1acTable", "l1_bl", "l15_container", "l1pytab", "l1_tree", "l1_header", "l1zable", "l15_able", "l1Pquery", "l1ttab", "l2_buffer", "l15_table", "l1tt", "l1_entity", "l1tentity", "l14Ptable", "l2_TABLE", "l1stree", "l14_Table", "l1__table", "l2_tab", "l1_container", "l2_entity", "l14Pquery", "l1_t", "l2_Table", "l1_TABLE", "l14_query", "l2_header", "l1Parray", "l1Ptable", "l1acarray", "l4_buffer", "l1__cache", "l2_cache", "l1tbuffer", "l15_buffer", "l1__tree", "l41_entry", "l1pybuffer", "l1_query", "l1scache", "l1__tab"], "nb_clusters": ["nb_glocations", "nb_blusters", "nb_crituster", "nb2chients", "nb10occurs", "nb10occusters", "nb2chanks", "nb_descusters", "nb10cluations", "nb_plroups", "nb_glusters", "nb_cousters", "nb_clanks", "nbldescues", "nb_lroups", "nb2chores", "nb_cours", "nb_pluster", "nb_clususter", "nb_clusows", "nb_blients", "nbldescows", "nb_couations", "nb_declusters", "nb_Clroups", "nb_blanks", "nb_lients", "nb_chanks", "nb_clurs", "nb_clores", "nb_chusters", "nb_regusters", "nb10clusters", "nb_occusters", "nb_clients", "nb_lanks", "nb_descuster", "nb_descues", "nb_gluster", "nb_coords", "nb_lusters", "nb_clows", "nb_chients", "nbldescusters", "nb_cluations", "nb_critocations", "nb_plusters", "nb_decluster", "nb10clords", "nb_plients", "nb_glows", "nb_Clusters", "nb_clues", "nb_declocations", "nb_declanks", "nb_occurs", "nb_clusues", "nb_cluster", "nb2clusters", "nblclues", "nblclows", "nb_glues", "nb_reguations", "nb_blores", "nb2clores", "nb_regords", "nb_occords", "nb10clurs", "nb10occords", "nb_glanks", "nb_clocations", "nb_luster", "nb_critanks", "nb_Clients", "nb_regurs", "nbldescuster", "nb_descows", "nb_clords", "nb_lores", "nb_occuations", "nb_clroups", "nb_critusters", "nb2clients", "nblcluster", "nblclusters", "nb2clanks", "nb_Cluster", "nb_clususters", "nb2chusters", "nb10occuations", "nb_chores"], "expanded_clusters": ["expanded_chers", "expanded_blanks", "expanded_commiques", "expanded___commusters", "expanded_captusters", "expanded_clocations", "expanded_bluster", "expanded___cluster", "expanded_relosures", "expanded_cluster", "expanded_commodes", "expandedlychers", "expanded_blessions", "repanded_", "expanded_clanks", "expanded_relancers", "expanded___commuster", "expanded_Closures", "expandededclancers", "expanded___clodes", "expanded_blodes", "expanded_commusters", "expandedlyclers", "expanded_chocations", "expanded_captanks", "expanded_clopes", "expanded_", "expanded_cliques", "repributed_", "expanded_Clusters", "expanded___commiques", "expandededdecessions", "expandededdecopes", "expanded_blopes", "expanded___commodes", "expanded_coninators", "expandededclopes", "expanded_gliques", "expanded_captiques", "expanded_Clocations", "expanded_chosures", "expandedlychosures", "expanded_relusters", "expanded_glodes", "expanded_decusters", "expoved_", "expanded_chusters", "expanded_blusters", "expanded_glusters", "expaped_", "expanded_clers", "expributed_", "expanded_relers", "expandededdecusters", "expanded_conanks", "expanded_bliques", "expanded_captinators", "expandedlyclusters", "expandededclessions", "expanded_clodes", "expanded_coniques", "expanded_gluster", "expanded_clancers", "expanded_Clers", "expandededdecancers", "expanded_commuster", "expanded_decancers", "expandedlyclocations", "expanded_relopes", "expanded___clusters", "expanded_closures", "expanded_conusters", "expanded_clinators", "expanded_relessions", "expanded_clessions", "expanded_blinators", "expanded___cliques", "expanded_blancers", "expanded_decessions", "expanded_relocations", "expandedlyclosures", "expanded_decopes", "expandedlychusters", "expandededclusters", "expandedlychocations"], "ret": ["resp", "status", "rem", "def", "jp", "at", "out", "ref", "success", "det", "ll", "fun", "back", "cmd", "Ret", "tr", "reply", "rets", "after", "RET", "val", "reset", "dt", "deg", "compl", "try", "vet", "t", "ert", "len", "rm", "result", "ext", "nz", "cat", "nt", "r", "get", "alt", "gt", "att", "rt", "rev", "tf", "lt", "RT", "ry", "res", "print", "flag", "red", "cert", "gc", "re", "mat", "ort", "mt", "ft", "it", "elt", "err", "net", " Ret", "del", "sat", "ter", "usr", "cont"], "i": ["ij", "index", "status", "li", "f", "um", "o", "iu", "out", "ii", "ini", "I", "pi", "ind", "l", "mi", "n", "p", "ex", "ki", "si", "uri", "zi", "this", "name", "v", "bi", "io", "batch", "ui", "ia", "iq", "di", "ami", " ii", "ai", "m", "in", "ie", "hi", "xi", "sim", "info", "im", "\u0438", "remote", "ci", "b", "h", "ims", "id", "e", "ti", "u", "list", "it", "multi", "gi", "to", "me", "ji", "init", "history", "x", "ri", "ic", "ix", "ip"], "j": ["jp", "ij", "index", "key", "f", "o", "jit", "ind", "l", "pr", "p", "js", "n", "aj", "str", "tr", "other", "bj", "v", "pt", "us", "uj", "bo", "job", "k", "m", "br", "att", "obj", "json", "ja", "c", "dj", "J", "oj", "jj", "on", "b", "jump", "jo", "fr", " dj", "jl", "jc", "ji", "it", "col", "kj", "z", "q", "ev", "je", "x", "y", "adj"]}}
{"project": "qemu", "commit_id": "12848bfc5d719bad536c5448205a3226be1fda47", "target": 1, "func": "static int local_open2(FsContext *fs_ctx, const char *path, int flags,\n\n        FsCred *credp)\n\n{\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        fd = open(rpath(fs_ctx, path), flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(rpath(fs_ctx, path), credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n\n        fd = open(rpath(fs_ctx, path), flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    return fd;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(rpath(fs_ctx, path));\n\n    errno = serrno;\n\n    return err;\n\n}\n", "idx": 12805, "substitutes": {"fs_ctx": ["oss_cp", "rets_tx", "ims_tx", "retstgz", "fs_jp", "fsamepkg", " fs_conn", "rets_conn", "fsplcp", "cs_pkg", "oss_conn", "fs_cp", "fsplctx", "retsttx", "cs_ctx", "cs_jac", "fscalcv", " fs_cmp", "fsamejp", "fsamejac", " fs_tmp", "fs_addr", "fscalcmp", "fs_context", " fs_cb", "fstconn", "ims_addr", "fscaltx", "fsplconn", "oss_obj", "fs_cb", "ims_ctx", "ims_cp", "fs_pkg", "sys_ctx", "fsttx", "fs_obj", "fs_jac", "fs_gz", "fs_conn", "fs_tmp", " fs_pkg", "fs_cmp", "sys_tx", "cs_jp", "fsamectx", "sys_cv", "fscalctx", "fs_cv", "fstgz", "fs_tx", "rets_ctx", "fsplobj", "fstctx", "sys_cmp", "rets_gz", " fs_context", " fs_obj", "retstconn", "oss_ctx", "retstctx"], "path": ["key", "f", "route", "mount", "patch", "ref", "has", "handle", "pi", "pat", "PATH", "str", "p", "cmd", "present", "ex", "ctx", "ath", "dir", "pattern", "filename", "chain", "test", "pt", "box", "binding", "spec", "priv", "kind", "policy", "m", "part", "th", "eth", "context", "ATH", "rect", "prefix", "anc", "empty", "c", "file", "Path", "alias", "mat", "root", "transform", "host", "length", "prop", "format", "pkg", "name", "full", "cont", "txt", "history", "pointer"], "flags": ["status", "types", "settings", "opens", "FLAG", "tags", "ports", "lines", "mask", "cmd", "doms", "bits", "fd", "ags", "fields", "limits", "hours", "features", "frames", "wcs", "pins", "faces", "reports", "times", "heads", "lag", "vals", "grades", "acts", "Flags", "mates", "stats", "flag", "args", "cs", "links", "amps", "locks", "posts", "levels", "options", "fps", "weights", "pps", "packages", "properties", "members", "ps"], "credp": ["credq", " cpredvp", "cbednp", "cldps", "cgedP", "Cldps", "Cldp", "cribps", "lcredpid", "cppedP", "cromphp", "credpid", "Credjp", " cpredp", "lcredp", "cldphp", "cbedps", "credphp", "scedp", "cribpa", "cribp", "cledpid", "cpredvp", "Credps", "lcredpr", "cedn", "cedp", " cpredq", "creedp", "cldP", "cprphp", "cribphp", "cribnp", "Cldphp", "credpr", "Credpa", "scedn", "creedpid", "cEDjp", "cbedp", "lcreedpid", "scredp", "Cldjp", "cbedjp", "CldP", "credn", "creedP", "cromvp", "scredjp", "cgedp", "cppedp", "cpredp", "cledpr", "cledP", "lcreedpr", "cribjp", " credq", "cgedjp", "cromp", "cEDp", "lcreedP", "scedP", "scrednp", "cbedn", "cldp", "crednp", "scredps", "scedjp", "cEDP", " credphp", "Cldpa", "cledp", "cribP", "Credp", "cppedphp", "lcreedp", "cbedP", "cprp", "cgedn", "credjp", "credps", "scredn", "credpa", "cribq", "cldjp", "cribvp", "credP", "scredP", "cldpa", "Credphp", "cpredphp", "cprP", "cedP", "CredP", " credvp", "cpredq", "scedps", "credvp", " cpredphp", "cromq", "cedjp", "cEDpa", "cedps", "cednp", "cprps", "scednp", "lcredP", "cppedps", "creedpr"]}}
{"project": "FFmpeg", "commit_id": "221b804f3491638ecf2eec1302c669ad2d9ec799", "target": 1, "func": "static inline void yuv2packedXinC(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,\n\n\t\t\t\t    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,\n\n\t\t\t\t    uint8_t *dest, int dstW, int y)\n\n{\n\n\tint i;\n\n\tswitch(c->dstFormat)\n\n\t{\n\n\tcase PIX_FMT_BGR32:\n\n\tcase PIX_FMT_RGB32:\n\n\t\tYSCALE_YUV_2_RGBX_C(uint32_t)\n\n\t\t\t((uint32_t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1];\n\n\t\t\t((uint32_t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2];\n\n\t\t}\n\n\t\tbreak;\n\n\tcase PIX_FMT_RGB24:\n\n\t\tYSCALE_YUV_2_RGBX_C(uint8_t)\n\n\t\t\t((uint8_t*)dest)[0]= r[Y1];\n\n\t\t\t((uint8_t*)dest)[1]= g[Y1];\n\n\t\t\t((uint8_t*)dest)[2]= b[Y1];\n\n\t\t\t((uint8_t*)dest)[3]= r[Y2];\n\n\t\t\t((uint8_t*)dest)[4]= g[Y2];\n\n\t\t\t((uint8_t*)dest)[5]= b[Y2];\n\n\t\t\tdest+=6;\n\n\t\t}\n", "idx": 12809, "substitutes": {"c": ["rc", "cf", "co", "f", "tc", "lc", "l", "ctx", "p", "n", "cc", "v", "t", "st", "dc", "ct", "cam", "m", "s", "ac", "C", "cv", "ci", "cp", "cs", "h", "fc", "e", "con", "cont", "d", "w", "ce", "ch"], "lumFilter": ["lutFilter", " lutFlag", "lumSort", "lulSort", "lumRef", " lumSort", "lulFilter", "lumFlag", " lutSort", "lumaRef", " lutFilter", " lumFlag", "lumaSort", "lulFlag", "lutFlag", "lutRef", "lulRef", "lumaFilter", " lutRef", "lumaFlag", "lutSort", " lumRef"], "lumSrc": ["lumResRC", "lumPRC", "lumRessrc", "lumaSource", "lumPrc", "lumSsrc", "lumaSRC", "lumPource", "lumaSsrc", "lumPsrc", "lumSRC", "lumResrc", "lumSource", "lumaSrc", "lumResource"], "lumFilterSize": ["lamBufferLength", "lumBufferStyle", "lumfilterLength", "lumfilterSIZE", "lumBufferSize", "lamBufferStyle", "lumMaskSize", "lamFilterLength", "lamFilterStyle", "lamFilterSIZE", "lumfilterStyle", "lumFilterSIZE", "lumBufferLength", "lumMaskLength", "lamBufferSize", "lamBufferSIZE", "lumBufferSIZE", "lumMaskSIZE", "lumMaskStyle", "lumFilterLength", "lumFilterStyle", "lumfilterSize", "lamFilterSize"], "chrFilter": ["chrContext", "CHrFilter", "chmrFilter", "CHrtFil", "chmrTest", "chrsFilter", "chmrFil", "chrsFil", "CHrtFilter", "chrsContext", "chrtTest", "chrtFilter", "chrFil", "chrtContext", "CHrFil", "chrsTest", "chmrContext", "CHrTest", "CHrtTest", "CHrtContext", "chrtFil", "CHrContext", "chrTest"], "chrSrc": ["chrSlrc", "chrNRC", "chrNra", "chrNrc", "chrcSlrc", "chrSra", "chrSlra", "chrNsrc", "chrcSrc", "chrSlRC", "chrcSsrc", "chrcSlsrc", "chrcSra", "chrSsrc", "chrcSRC", "chrcSlra", "chrSRC", "chrSlsrc", "chrcSlRC"], "chrFilterSize": ["chrMaskLength", "chrFilterScale", "chrMaskScale", "chrcFilterSIZE", "chrBufferLength", "chrHandlerScale", "chrBufferSize", "chrMaskSIZE", "chrcFilterScale", "chrHandlerSize", "chrcBufferSize", "chrFilterLength", "chrBufferScale", "chrcBufferLength", "chrHandlerLength", "chrcFilterSize", "chrcBufferSIZE", "chrHandlerSIZE", "chrcFilterLength", "chrBufferSIZE", "chrFilterSIZE", "chrMaskSize", "chrcBufferScale"], "dest": ["shift", "orig", "ports", "port", "loc", "st", "result", "end", "neg", "dim", "coord", "it", "shape", "del", "EST", "usr", "cont", "sum", "mem", "ptr", "params", "v", "test", "spec", "dist", "std", "table", "set", "dep", "slave", "target", "results", "est", "src", "out", "global", "temp", "foreign", "source", "rest", "trans", "dev", "transform", "iter", "d", "config", "err", "options", "dat", "status", "output", "good", "p", "chain", "deg", "priv", "origin", "dc", "msg", "desc", "r", "gate", "alt", "Dest", "decl", "master", "e", "max", "list", "prop", "pas", "w", "ident"], "dstW": ["destM", "dndW", "DstH", "dstWidth", "destW", "dstM", "ddestWidth", "ddestW", "ddestM", "DstWidth", "destWidth", "DstM", "dndWidth", "dndM", "DestM", "destH", "DestWidth", "dndH", "dstH", "DestW", "ddestH", "DestH", "DstW"], "y": ["yy", "ly", "ty", "oy", "py", "dy", "ny", "j", "p", "sy", "Y", "yi", "xy", "ay", "t", "m", "yp", "iy", "ies", "iny", "ry", "b", "my", "d", "w", "x", "ch"], "i": ["ij", "index", "mi", "ii", "I", "pi", " j", "j", "p", "n", "si", "v", "t", "is", "di", " index", " ii", "m", "im", "count", "ci", "b", "id", "set", "it", "d", "x", "ix"]}}
{"project": "FFmpeg", "commit_id": "2fc9a3eb7a8c606bd403dc9fbdb8463144b243cf", "target": 1, "func": "static int write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    int ret, did_split;\n    if (s->output_ts_offset) {\n        AVStream *st = s->streams[pkt->stream_index];\n        int64_t offset = av_rescale_q(s->output_ts_offset, AV_TIME_BASE_Q, st->time_base);\n        if (pkt->dts != AV_NOPTS_VALUE)\n            pkt->dts += offset;\n        if (pkt->pts != AV_NOPTS_VALUE)\n            pkt->pts += offset;\n    }\n    if (s->avoid_negative_ts > 0) {\n        AVStream *st = s->streams[pkt->stream_index];\n        int64_t offset = st->mux_ts_offset;\n        int64_t ts = s->internal->avoid_negative_ts_use_pts ? pkt->pts : pkt->dts;\n        if (s->internal->offset == AV_NOPTS_VALUE && ts != AV_NOPTS_VALUE &&\n            (ts < 0 || s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO)) {\n            s->internal->offset = -ts;\n            s->internal->offset_timebase = st->time_base;\n        }\n        if (s->internal->offset != AV_NOPTS_VALUE && !offset) {\n            offset = st->mux_ts_offset =\n                av_rescale_q_rnd(s->internal->offset,\n                                 s->internal->offset_timebase,\n                                 st->time_base,\n                                 AV_ROUND_UP);\n        }\n        if (pkt->dts != AV_NOPTS_VALUE)\n            pkt->dts += offset;\n        if (pkt->pts != AV_NOPTS_VALUE)\n            pkt->pts += offset;\n        if (s->internal->avoid_negative_ts_use_pts) {\n            if (pkt->pts != AV_NOPTS_VALUE && pkt->pts < 0) {\n                av_log(s, AV_LOG_WARNING, \"failed to avoid negative \"\n                    \"pts %s in stream %d.\\n\"\n                    \"Try -avoid_negative_ts 1 as a possible workaround.\\n\",\n                    av_ts2str(pkt->dts),\n                    pkt->stream_index\n                );\n            }\n        } else {\n            av_assert2(pkt->dts == AV_NOPTS_VALUE || pkt->dts >= 0 || s->max_interleave_delta > 0);\n            if (pkt->dts != AV_NOPTS_VALUE && pkt->dts < 0) {\n                av_log(s, AV_LOG_WARNING,\n                    \"Packets poorly interleaved, failed to avoid negative \"\n                    \"timestamp %s in stream %d.\\n\"\n                    \"Try -max_interleave_delta 0 as a possible workaround.\\n\",\n                    av_ts2str(pkt->dts),\n                    pkt->stream_index\n                );\n            }\n        }\n    }\n    did_split = av_packet_split_side_data(pkt);\n    if (!s->internal->header_written) {\n        ret = s->internal->write_header_ret ? s->internal->write_header_ret : write_header_internal(s);\n        if (ret < 0)\n            goto fail;\n    }\n    if ((pkt->flags & AV_PKT_FLAG_UNCODED_FRAME)) {\n        AVFrame *frame = (AVFrame *)pkt->data;\n        av_assert0(pkt->size == UNCODED_FRAME_PACKET_SIZE);\n        ret = s->oformat->write_uncoded_frame(s, pkt->stream_index, &frame, 0);\n        av_frame_free(&frame);\n    } else {\n        ret = s->oformat->write_packet(s, pkt);\n    }\n    if (s->pb && ret >= 0) {\n        if (s->flush_packets && s->flags & AVFMT_FLAG_FLUSH_PACKETS)\n            avio_flush(s->pb);\n        if (s->pb->error < 0)\n            ret = s->pb->error;\n    }\nfail:\n    if (did_split)\n        av_packet_merge_side_data(pkt);\n    if (ret < 0) {\n        pkt->pts = pts_backup;\n        pkt->dts = dts_backup;\n    }\n    return ret;\n}", "idx": 12810, "substitutes": {"s": ["ses", "gs", "S", "settings", "bs", "ports", "series", "sq", "ags", "cli", "sam", "t", "m", "qs", "stats", "vs", "states", "cs", "tests", "ims", "aunts", "its", "us", "https", "ps", "sw", "n", "js", "v", "g", "http", "comm", "spec", "space", "ds", "ats", "obj", "services", "ies", "so", "self", "args", "set", "conf", "parts", "ex", "south", "a", "f", "less", "bits", "eps", "store", "source", "als", "sb", "service", "hs", "sys", "rest", "c", "ares", "ops", "es", "changes", "fs", "events", "state", "bis", "se", "sports", "ss", "status", "aws", "has", "p", "details", "is", "sv", "ls", "r", "ts", "ins", "ns", "b", "h", "os", "these", "w", "sts", "sets", "ms", "rs"], "pkt": ["opacket", "phpdu", "parud", "cpkat", "Pdu", "parmsg", "ipkt", "pcacket", "pracket", "phpkt", "pcnt", " pcmd", "ckt", "opcmd", "cpkt", "ipgt", "ppdu", " pkg", "ipkg", "appkt", "preacket", "Pct", "precmd", "pud", "ppcmd", "portud", " pkat", "opkt", "expunt", "expkt", "prunct", "pkg", "pconn", "packet", "prnt", "cnt", "cpct", "portkt", "portunct", "phpkg", "dacket", "phpunct", "opdu", "perant", "paykt", "phpmsg", "ppacket", "Pkat", " pnt", "tkg", "cpacket", "pcmit", "portconn", " pud", "bpacket", " punt", "appcmd", "ipcmd", "pcant", "appconn", "Pgt", " packet", "payant", "parkt", "pant", "bpkt", "pckt", "punct", "pcmd", "Pcmd", "portix", "opnt", "nconn", "prekt", "pkat", "tacket", "Pkg", " pdu", "portunt", "punt", "pgt", "pnt", "ccmd", "cpdu", "perunct", " pgt", "pkgunct", "pct", "permit", "ppkt", "pdu", "perkt", "bpkat", "tkt", "appix", "pmit", "appacket", "pcunct", "pkgdu", "tcmd", "parunct", " punct", " pct", "Packet", "payunct", "portmsg", "phpacket", "nix", "prkt", "Pnt", "opkg", "paymit", "cpcmd", "bpcmd", "pix", "pkgkg", "dkt", "cdu", "cpnt", "opunct", " pmsg", "prekg", "expkg", "prekat", "appkg", "pkgkt", "pckat", "prent", "pmsg", "phpunt", "cacket", "dkg", "ddu", "Pkt", "nkt", "expacket"], "ret": ["et", " val", " alt", " RET", " fs", "Ret", "RET", "val", "t", "len", "offset", " fmt", "alt", " ans", " mem", " addr", " resp", " ref", " flag", "flag", " res", "mt", "ft", "elt", " Ret", " af"], "did_split": ["did2len", "done_break", "done2len", "done2break", "did_len", "did2break", "done2split", "done2size", "did_break", "did2split", "did_size", "done_len", "done_split", "done_size", "did2size"], "st": ["ste", "be", "stable", "td", "est", "sw", "src", "usr", "sta", "St", "ST", "ist", "ctx", "tt", "kt", "lib", "ut", "stat", "sl", "pt", "tra", "t", "nd", "stop", "sm", "bt", "sv", "stack", "end", "ct", "nt", "irst", "rest", "sa", "th", "step", "rt", "so", "ts", "ost", "sp", "art", "stage", "std", "sh", "tz", "lat", "start", "h", "set", "mt", "ad", "sty", "se", "z", "ast", "sn", "ss", "inst", "sts", "str", "ld"]}}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "static void read_sgi_header(ByteIOContext *f, SGIInfo *info)\n{\n    info->magic = (unsigned short) get_be16(f);\n    info->rle = get_byte(f);\n    info->bytes_per_channel = get_byte(f);\n    info->dimension = (unsigned short)get_be16(f);\n    info->xsize = (unsigned short) get_be16(f);\n    info->ysize = (unsigned short) get_be16(f);\n    info->zsize = (unsigned short) get_be16(f);\n#ifdef DEBUG\n    printf(\"sgi header fields:\\n\");\n    printf(\"  magic: %d\\n\", info->magic);\n    printf(\"    rle: %d\\n\", info->rle);\n    printf(\"    bpc: %d\\n\", info->bytes_per_channel);\n    printf(\"    dim: %d\\n\", info->dimension);\n    printf(\"  xsize: %d\\n\", info->xsize);\n    printf(\"  ysize: %d\\n\", info->ysize);\n    printf(\"  zsize: %d\\n\", info->zsize);\n#endif\n    return;\n}", "idx": 12814, "substitutes": {"f": ["cf", "fed", "um", "lf", "out", "far", "l", "j", "p", "fd", "ex", "stream", "v", "g", "t", "ic", "er", "fm", "ed", "buff", "sf", "ct", "m", "r", "fb", "ac", "buffer", "c", "tf", "fo", "fp", "file", "bf", "df", "b", "h", "fac", "fr", "fc", "e", "fs", "iter", "ft", "it", "d", "fi", "xf", "uf", "q", "i", "w", "fa", "full", "cont", "inf", "form", "af"], "info": ["index", "notice", "py", "query", "check", "help", "control", "doc", "add", "summary", "start", "trace", "app", "it", "INFO", "exec", "sum", "error", "by", "about", "edit", "information", "try", "http", "test", "ui", "note", "cell", "comment", "api", "fo", "link", "sync", "report", "set", "conf", "ion", "fi", "style", "i", "full", "history", "copy", "ii", "pi", "auth", "where", "req", "pretty", "now", "show", "update", " inf", "description", "debug", "id", "inner", "iter", "state", "config", "err", "init", "inf", "status", "request", "ok", "rule", "details", "kind", "cache", "desc", "hi", "time", "iso", "parse", "count", "event", "all", "no", "reason", "entry", "list", "Info", "name"]}}
{"project": "qemu", "commit_id": "e9ebead2b5c70890454e698d9ff174e3020ea861", "target": 1, "func": "static void pc_init1(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename,\n\n                     int pci_enabled, const char *cpu_model)\n\n{\n\n    char buf[1024];\n\n    int ret, linux_boot, i;\n\n    ram_addr_t ram_addr, vga_ram_addr, bios_offset, vga_bios_offset;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size = 0;\n\n    int bios_size, isa_bios_size, vga_bios_size;\n\n    PCIBus *pci_bus;\n\n    int piix3_devfn = -1;\n\n    CPUState *env;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *i8259;\n\n    int index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BlockDriverState *fd[MAX_FD];\n\n\n\n    if (ram_size >= 0xe0000000 ) {\n\n        above_4g_mem_size = ram_size - 0xe0000000;\n\n        below_4g_mem_size = 0xe0000000;\n\n    } else {\n\n        below_4g_mem_size = ram_size;\n\n    }\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_X86_64\n\n        cpu_model = \"qemu64\";\n\n#else\n\n        cpu_model = \"qemu32\";\n\n#endif\n\n    }\n\n    \n\n    for(i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find x86 CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        if (i != 0)\n\n            env->halted = 1;\n\n        if (smp_cpus > 1) {\n\n            /* XXX: enable it in all cases */\n\n            env->cpuid_features |= CPUID_APIC;\n\n        }\n\n        qemu_register_reset(main_cpu_reset, env);\n\n        if (pci_enabled) {\n\n            apic_init(env);\n\n        }\n\n    }\n\n\n\n    vmport_init();\n\n\n\n    /* allocate RAM */\n\n    ram_addr = qemu_ram_alloc(0xa0000);\n\n    cpu_register_physical_memory(0, 0xa0000, ram_addr);\n\n\n\n    /* Allocate, even though we won't register, so we don't break the\n\n     * phys_ram_base + PA assumption. This range includes vga (0xa0000 - 0xc0000),\n\n     * and some bios areas, which will be registered later\n\n     */\n\n    ram_addr = qemu_ram_alloc(0x100000 - 0xa0000);\n\n    ram_addr = qemu_ram_alloc(below_4g_mem_size - 0x100000);\n\n    cpu_register_physical_memory(0x100000,\n\n                 below_4g_mem_size - 0x100000,\n\n                 ram_addr);\n\n\n\n    /* above 4giga memory allocation */\n\n    if (above_4g_mem_size > 0) {\n\n        ram_addr = qemu_ram_alloc(above_4g_mem_size);\n\n        cpu_register_physical_memory(0x100000000ULL,\n\n                                     above_4g_mem_size,\n\n                                     ram_addr);\n\n    }\n\n\n\n\n\n    /* allocate VGA RAM */\n\n    vga_ram_addr = qemu_ram_alloc(vga_ram_size);\n\n\n\n    /* BIOS load */\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    bios_size = get_image_size(buf);\n\n    if (bios_size <= 0 ||\n\n        (bios_size % 65536) != 0) {\n\n        goto bios_error;\n\n    }\n\n    bios_offset = qemu_ram_alloc(bios_size);\n\n    ret = load_image(buf, phys_ram_base + bios_offset);\n\n    if (ret != bios_size) {\n\n    bios_error:\n\n        fprintf(stderr, \"qemu: could not load PC BIOS '%s'\\n\", buf);\n\n        exit(1);\n\n    }\n\n\n\n    if (cirrus_vga_enabled || std_vga_enabled || vmsvga_enabled) {\n\n        /* VGA BIOS load */\n\n        if (cirrus_vga_enabled) {\n\n            snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, VGABIOS_CIRRUS_FILENAME);\n\n        } else {\n\n            snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, VGABIOS_FILENAME);\n\n        }\n\n        vga_bios_size = get_image_size(buf);\n\n        if (vga_bios_size <= 0 || vga_bios_size > 65536)\n\n            goto vga_bios_error;\n\n        vga_bios_offset = qemu_ram_alloc(65536);\n\n\n\n        ret = load_image(buf, phys_ram_base + vga_bios_offset);\n\n        if (ret != vga_bios_size) {\n\nvga_bios_error:\n\n            fprintf(stderr, \"qemu: could not load VGA BIOS '%s'\\n\", buf);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* setup basic memory access */\n\n    cpu_register_physical_memory(0xc0000, 0x10000,\n\n                                 vga_bios_offset | IO_MEM_ROM);\n\n\n\n    /* map the last 128KB of the BIOS in ISA space */\n\n    isa_bios_size = bios_size;\n\n    if (isa_bios_size > (128 * 1024))\n\n        isa_bios_size = 128 * 1024;\n\n    cpu_register_physical_memory(0x100000 - isa_bios_size,\n\n                                 isa_bios_size,\n\n                                 (bios_offset + bios_size - isa_bios_size) | IO_MEM_ROM);\n\n\n\n    {\n\n        ram_addr_t option_rom_offset;\n\n        int size, offset;\n\n\n\n        offset = 0;\n\n        if (linux_boot) {\n\n            option_rom_offset = qemu_ram_alloc(TARGET_PAGE_SIZE);\n\n            load_linux(phys_ram_base + option_rom_offset,\n\n                       kernel_filename, initrd_filename, kernel_cmdline);\n\n            cpu_register_physical_memory(0xd0000, TARGET_PAGE_SIZE,\n\n                                         option_rom_offset | IO_MEM_ROM);\n\n            offset = TARGET_PAGE_SIZE;\n\n        }\n\n\n\n        for (i = 0; i < nb_option_roms; i++) {\n\n            size = get_image_size(option_rom[i]);\n\n            if (size < 0) {\n\n                fprintf(stderr, \"Could not load option rom '%s'\\n\",\n\n                        option_rom[i]);\n\n                exit(1);\n\n            }\n\n            if (size > (0x10000 - offset))\n\n                goto option_rom_error;\n\n            option_rom_offset = qemu_ram_alloc(size);\n\n            ret = load_image(option_rom[i], phys_ram_base + option_rom_offset);\n\n            if (ret != size) {\n\n            option_rom_error:\n\n                fprintf(stderr, \"Too many option ROMS\\n\");\n\n                exit(1);\n\n            }\n\n            size = (size + 4095) & ~4095;\n\n            cpu_register_physical_memory(0xd0000 + offset,\n\n                                         size, option_rom_offset | IO_MEM_ROM);\n\n            offset += size;\n\n        }\n\n    }\n\n\n\n    /* map all the bios at the top of memory */\n\n    cpu_register_physical_memory((uint32_t)(-bios_size),\n\n                                 bios_size, bios_offset | IO_MEM_ROM);\n\n\n\n    bochs_bios_init();\n\n\n\n    cpu_irq = qemu_allocate_irqs(pic_irq_request, NULL, 1);\n\n    i8259 = i8259_init(cpu_irq[0]);\n\n    ferr_irq = i8259[13];\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, i8259);\n\n        piix3_devfn = piix3_init(pci_bus, -1);\n\n    } else {\n\n        pci_bus = NULL;\n\n    }\n\n\n\n    /* init basic PC hardware */\n\n    register_ioport_write(0x80, 1, 1, ioport80_write, NULL);\n\n\n\n    register_ioport_write(0xf0, 1, 1, ioportF0_write, NULL);\n\n\n\n    if (cirrus_vga_enabled) {\n\n        if (pci_enabled) {\n\n            pci_cirrus_vga_init(pci_bus,\n\n                                ds, phys_ram_base + vga_ram_addr,\n\n                                vga_ram_addr, vga_ram_size);\n\n        } else {\n\n            isa_cirrus_vga_init(ds, phys_ram_base + vga_ram_addr,\n\n                                vga_ram_addr, vga_ram_size);\n\n        }\n\n    } else if (vmsvga_enabled) {\n\n        if (pci_enabled)\n\n            pci_vmsvga_init(pci_bus, ds, phys_ram_base + vga_ram_addr,\n\n                            vga_ram_addr, vga_ram_size);\n\n        else\n\n            fprintf(stderr, \"%s: vmware_vga: no PCI bus\\n\", __FUNCTION__);\n\n    } else if (std_vga_enabled) {\n\n        if (pci_enabled) {\n\n            pci_vga_init(pci_bus, ds, phys_ram_base + vga_ram_addr,\n\n                         vga_ram_addr, vga_ram_size, 0, 0);\n\n        } else {\n\n            isa_vga_init(ds, phys_ram_base + vga_ram_addr,\n\n                         vga_ram_addr, vga_ram_size);\n\n        }\n\n    }\n\n\n\n    rtc_state = rtc_init(0x70, i8259[8]);\n\n\n\n    qemu_register_boot_set(pc_boot_set, rtc_state);\n\n\n\n    register_ioport_read(0x92, 1, 1, ioport92_read, NULL);\n\n    register_ioport_write(0x92, 1, 1, ioport92_write, NULL);\n\n\n\n    if (pci_enabled) {\n\n        ioapic = ioapic_init();\n\n    }\n\n    pit = pit_init(0x40, i8259[0]);\n\n    pcspk_init(pit);\n\n    if (!no_hpet) {\n\n        hpet_init(i8259);\n\n    }\n\n    if (pci_enabled) {\n\n        pic_set_alt_irq_func(isa_pic, ioapic_set_irq, ioapic);\n\n    }\n\n\n\n    for(i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_init(serial_io[i], i8259[serial_irq[i]], 115200,\n\n                        serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {\n\n        if (parallel_hds[i]) {\n\n            parallel_init(parallel_io[i], i8259[parallel_irq[i]],\n\n                          parallel_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!pci_enabled || (nd->model && strcmp(nd->model, \"ne2k_isa\") == 0))\n\n            pc_init_ne2k_isa(nd, i8259);\n\n        else\n\n            pci_nic_init(pci_bus, nd, -1, \"ne2k_pci\");\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n\tif (index != -1)\n\n\t    hd[i] = drives_table[index].bdrv;\n\n\telse\n\n\t    hd[i] = NULL;\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1, i8259);\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            isa_ide_init(ide_iobase[i], ide_iobase2[i], i8259[ide_irq[i]],\n\n\t                 hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n        }\n\n    }\n\n\n\n    i8042_init(i8259[1], i8259[12], 0x60);\n\n    DMA_init(0);\n\n#ifdef HAS_AUDIO\n\n    audio_init(pci_enabled ? pci_bus : NULL, i8259);\n\n#endif\n\n\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        index = drive_get_index(IF_FLOPPY, 0, i);\n\n\tif (index != -1)\n\n\t    fd[i] = drives_table[index].bdrv;\n\n\telse\n\n\t    fd[i] = NULL;\n\n    }\n\n    floppy_controller = fdctrl_init(i8259[6], 2, 0, 0x3f0, fd);\n\n\n\n    cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device, hd);\n\n\n\n    if (pci_enabled && usb_enabled) {\n\n        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n        i2c_bus *smbus;\n\n\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100, i8259[9]);\n\n        for (i = 0; i < 8; i++) {\n\n            smbus_eeprom_device_init(smbus, 0x50 + i, eeprom_buf + (i * 256));\n\n        }\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n\tint max_bus;\n\n        int bus, unit;\n\n        void *scsi;\n\n\n\n        max_bus = drive_get_max_bus(IF_SCSI);\n\n\n\n\tfor (bus = 0; bus <= max_bus; bus++) {\n\n            scsi = lsi_scsi_init(pci_bus, -1);\n\n            for (unit = 0; unit < LSI_MAX_DEVS; unit++) {\n\n\t        index = drive_get_index(IF_SCSI, bus, unit);\n\n\t\tif (index == -1)\n\n\t\t    continue;\n\n\t\tlsi_scsi_attach(scsi, drives_table[index].bdrv, unit);\n\n\t    }\n\n        }\n\n    }\n\n\n\n    /* Add virtio block devices */\n\n    if (pci_enabled) {\n\n        int index;\n\n        int unit_id = 0;\n\n\n\n        while ((index = drive_get_index(IF_VIRTIO, 0, unit_id)) != -1) {\n\n            virtio_blk_init(pci_bus, drives_table[index].bdrv);\n\n            unit_id++;\n\n        }\n\n    }\n\n\n\n    /* Add virtio balloon device */\n\n    if (pci_enabled)\n\n        virtio_balloon_init(pci_bus);\n\n\n\n    /* Add virtio console devices */\n\n    if (pci_enabled) {\n\n        for(i = 0; i < MAX_VIRTIO_CONSOLES; i++) {\n\n            if (virtcon_hds[i])\n\n                virtio_console_init(pci_bus, virtcon_hds[i]);\n\n        }\n\n    }\n\n}\n", "idx": 12828, "substitutes": {"ram_size": ["cam_free", "ram67len", "cpu_scale", "gram_size", "ram_width", "gram_name", "ram_length", "ram_name", "ram_offset", "gram_len", "ram_Size", "cpu_Size", "ramlistsize", "ram67name", "ramlistoffset", "ramlistlen", "ram_free", "ram_len", "mem_len", "ramlistaddr", "cam_length", "gram_width", "ram_scale", "ram67width", "mem_offset", "ram67size", "mem_size", "ram_SIZE", "cpu_SIZE", "cam_size", "cpu_size", "cam_num", "ram_num", "mem_addr"], "vga_ram_size": ["vga_ram_device", "vga_mem_space", "vga_mem_size", "vga_mem_device", "vga_ram_space", "vga_mem_addr"], "boot_device": ["bootdbdev", "boot_number", "bootdbdevice", "boot_dev", "bus_device", "bootingdev", "bus_number", "bus_attribute", "bootdbattribute", "bus_dev", "bootingdevice", "bootingnumber", "bootingattribute", "bootdbnumber", "boot_attribute"], "ds": ["des", "bs", "ys", "ids", "dt", "pd", "eps", "dm", "ded", "du", "hs", "da", "dd", "eds", "dds", "bd", "DS", "db", "vs", "cs", "de", "fs", "ks", "sd", "vd", "sts", "Ds", "rs", "ps"], "kernel_filename": ["kernel_path", "proc_string", "kernel_string", "proc_filename", "kernel67network", " kernel_title", "kernelilefile", "kernel67path", "kernel67string", "proc_network", "kernelilepath", "kernel_network", " kernel_path", "kernelilefilename", "kernel_file", "kernel67filename", "kerneliletitle", "proc_path", "kernel_title", " kernel_file"], "kernel_cmdline": ["kernel_authline", "kernel_cpline", "kernel_cmdl", "kernel_commandline", "kernel_commandl", "kernel_commandstyle", "kernel_cpstyle", "kernel_authl", "kernel_cpl", "kernel_cmdstyle", "kernel_authstyle"], "initrd_filename": ["initdi_filename", "initrdrantstring", "initrdrdfilename", "initdirantfilename", "initrdrantfilename", "initrd_string", "initrdrantsequence", "initrd_sequence", "initrd_name", "initdirantname", "initdi_name", "initdirantstring", "initdi_string", "initdirantsequence", "initrdrantname", "initrdrdsequence", "initdi_sequence", "initrdrdstring", "initrdrdname"], "pci_enabled": ["pciableenable", "pciableupdated", "pcu_online", "pcu_disabled", "pci_updated", "pic_enable", "pci_disabled", "pciableenabled", "pcu_enabled", "pci_enable", "pci_online", "pic_updated", "pcu_activated", "pci_activated", "pic_disabled", "pic_enabled", "pciabledisabled"], "cpu_model": ["cpu_link", "cpu__model", "cpumyModel", " cpu_models", "CPU_size", "cpumymodel", "cpu_mode", " cpu_Model", "cpumysize", "cpu_type", "cpu_base", "cpumylink", "cpu_models", " cpu_mode", "gpu_link", "cpu__map", "CPU_model", "cpu__link", "gpu_model", "CPU_map", "cpu_module", "gpu_base", " cpu_type", "cpu_map", "cpu__Model", "CPU_Model", "gpu_models", "cpu_size", "cpu_Model", " cpu_module", "CPU_link"], "buf": ["vec", "ptr", "array", "data", "family", "map", "raw", "proc", "Buffer", "pool", "batch", " buffer", "buff", "cap", "buffer", "block", "count", "page", "code", "flag", "var", "length", "queue", "cast", "str", "pack"], "ret": ["status", "def", "mem", "ref", "out", "j", "cmd", "Ret", "class", "RET", "val", "len", "read", "sys", "ext", "ea", "lit", "alt", "std", "ry", "flag", "set", "fi", "net", "format"], "linux_boot": ["ilo___Boot", "linux__build", "ilo_host", "Linux_boot", "linux_build", "linux_bus", "linux_load", "ilo_build", "linux__host", "linux___load", "ilo___build", "Linux_Boot", "linux___bus", "ilo___host", "ilo___boot", "linux_host", "Linux_load", "linux___build", "linux__Boot", "Linux_bus", "ilo_Boot", "ilo_boot", "linux___Boot", "linux___boot", "linux___host", "linux_Boot", "linux__boot"], "i": ["status", "li", "a", "f", "o", "iu", "ii", "mi", "I", "pi", "ind", "l", "j", "ini", "n", "p", "ei", "si", "ir", "zi", "v", "cli", "g", "try", "bi", "gu", "t", "ui", "di", "ai", "m", "in", "hi", "xi", "qi", "sim", "info", "im", "c", "ci", "b", "h", "id", "ims", "e", "ti", "iter", "it", "multi", "gi", "fi", "me", "phi", "x", "ix", "ip"], "ram_addr": ["rom_addr", "mem_ptr", "rom_address", "ram_address", "mem_address", "ram_ptr", "rom_size", "mem_addr"], "vga_ram_addr": ["vga_mem_address", "vga_ram__ref", "vga_mem_ref", "vga_mem_ptr", "vga_ram_address", "vga_ram__addr", "vga_ram_ptr", "vga_mem_addr", "vga_ram_ref", "vga_ram__address", "vga_ram__ptr"], "bios_offset": ["bios_address", "bio_padding", "bio_address", "bios_padding", "bios_start", "bio_start", "bio_offset"], "vga_bios_offset": ["vga_bio_offset", "vga_bio_addr", "vga_bio_size", "vga_bios_addr"], "below_4g_mem_size": ["below_4g_mem_max", "below_4g_mem_width", "below_4g_mem_SIZE", "below_4g_ram_size", "below_4g_ram_SIZE", "below_4g_mem__size", "below_4g_mem_set", "below_4g_mem_Size", "below_4g_mem_name", "below_4g_ram_name", "below_4g_mem__width", "below_4g_mem__Size", "below_4g_ram_max"], "bios_size": ["bios_number", "bio_number", "bio_SIZE", "bios_SIZE", "bio_offset", "bio_size"], "isa_bios_size": ["isa_bios_height", "isa_bio_height", "isa_bio_SIZE", "isa_bio_name", "isa_bio_size", "isa_bios_name", "isa_bios_SIZE"], "vga_bios_size": ["vga_bios_storage", "vga_bio_storage", "vga_bios_SIZE", "vga_bio_size", "vga_bio_SIZE"], "pci_bus": ["pci_boot", "pix_bus", "pix_board", "pci_board", "pci__bus", "pci__boot", "pci_driver", "pix_driver", "pci__driver", "pci__board", "pix_boot"], "env": ["tx", "server", "nv", "vv", "exec", "conn", "et", "manager", "environment", "cmd", "ctx", "hw", "window", "proc", "ee", "vp", "v", "ent", "box", "esc", "engine", "er", "end", "ef", "ea", "eu", "func", "em", "desc", "cfg", "ah", "context", "ew", "obj", "era", "vm", "cb", "db", "event", "en", "ec", "code", "vs", "worker", "dev", "h", "tmp", "here", "e", "Environment", "door", "enc", "entry", "enter", "dh", "eng", "err", "vd", "eh", "ev", "vt", "esp", "eddy", "viron", "equ"], "cpu_irq": ["cpu_mirq", "cpu_drQ", "cpu_pirch", "cpu_pirq", "cpu_irqs", "cpu_pirqs", "cpu_mirqs", "cpu_irQ", "cpu_mirQ", "cpu_drch", "cpu_pirQ", "cpu_drqs", "cpu_mirch", "cpu_drq", "cpu_irch"], "i8259": ["i4594", "i15259", " i4259", "i6192", " i8594", " i4388", "i8594", "i15388", " i4192", "i4192", "i8192", "i6388", "i4259", "i8388", "i15594", "i4388", "i6594", "i6259", " i4594", "i15192", " i8192", " i8388"], "index": ["thread", "key", "error", "type", "axis", "address", "ind", "si", "connected", "loop", "Index", "num", "connect", "connection", "context", "info", "open", "location", "id", "input", "label", "order", "config", "fi", "interface", "valid"], "hd": ["dn", "hz", "dr", "dl", "xd", "him", "cd", "ha", "pd", "md", "hid", "HD", "hs", "dist", "dd", "kb", "bd", "rt", "ck", "rh", "sh", "df", "ht", "hl", "dh", "hn", "vd", "ld", "hp"], "MAX_IDE_BUS": ["MAX_IDEOPBS", "MAX_IDEOPUS", "MAX_IDE_OUT", "MAX_IDEOPOUT", "MAX_IDEOPBUS", "MAX_ID_US", "MAX_ID_OUT", "MAX_ID_BS", "MAX_IDE_US", "MAX_ID_BUS", "MAX_IDE_BS"], "MAX_IDE_DEVS": ["MAX_IDE_DRVS", "MAX_IDE_DPFS", "MAX_IDE_DRPS", "MAX_IDE_DEPS", "MAX_IDE_DBS", "MAX_IDE_DRFS", "MAX_IDE_DVS", "MAX_IDE_DPBS", "MAX_IDE_DEFS", "MAX_IDE_DPPS", "MAX_IDE_DPS", "MAX_IDE_DRBS", "MAX_IDE_DPVS", "MAX_IDE_DEBS", "MAX_IDE_DFS"], "fd": ["td", "cf", "f", "lf", "ff", "dl", "dir", "cd", "dt", "md", "fl", "dd", "fb", "bd", "fp", "df", "fat", "id", "FD", "fc", "fr", "fs", "pid", "sd", "fi", "fa", "fin", "ld"], "MAX_FD": ["MAXIDFD", "MAXIDHUD", "MIN_HUD", "MAX_HD", "MAX_HUD", "MIN_FD", "MAXIDHD", "MIN_DIR", "MAX_DIR", "MIN_HD", "MAXIDDIR"]}}
{"project": "qemu", "commit_id": "0bed71edbc323de12ed1e5390a85a013f6a143f4", "target": 0, "func": "static int slirp_hostfwd(SlirpState *s, const char *redir_str,\n\n                         int legacy_format)\n\n{\n\n    struct in_addr host_addr = { .s_addr = INADDR_ANY };\n\n    struct in_addr guest_addr = { .s_addr = 0 };\n\n    int host_port, guest_port;\n\n    const char *p;\n\n    char buf[256];\n\n    int is_udp;\n\n    char *end;\n\n\n\n    p = redir_str;\n\n    if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') {\n\n        is_udp = 0;\n\n    } else if (!strcmp(buf, \"udp\")) {\n\n        is_udp = 1;\n\n    } else {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (!legacy_format) {\n\n        if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n            goto fail_syntax;\n\n        }\n\n        if (buf[0] != '\\0' && !inet_aton(buf, &host_addr)) {\n\n            goto fail_syntax;\n\n        }\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    host_port = strtol(buf, &end, 0);\n\n    if (*end != '\\0' || host_port < 1 || host_port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (buf[0] != '\\0' && !inet_aton(buf, &guest_addr)) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    guest_port = strtol(p, &end, 0);\n\n    if (*end != '\\0' || guest_port < 1 || guest_port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (slirp_add_hostfwd(s->slirp, is_udp, host_addr, host_port, guest_addr,\n\n                          guest_port) < 0) {\n\n        error_report(\"could not set up host forwarding rule '%s'\",\n\n                     redir_str);\n\n        return -1;\n\n    }\n\n    return 0;\n\n\n\n fail_syntax:\n\n    error_report(\"invalid host forwarding rule '%s'\", redir_str);\n\n    return -1;\n\n}\n", "idx": 12846, "substitutes": {"s": ["S", "sw", "socket", "sq", "v", "g", "t", "is", "sb", "sv", "st", "sm", "ds", "r", "ts", "c", "h", "es", "e", "fs", "w", "ss", "i", "sts", "rs", "ps"], "redir_str": ["redirect_br", "redir_Str", "redir2str", "redir_string", "redir_br", "redirect_str", "reddir_string", "reddir_Str", "redirect_string", "reddir_br", "reddir_str", "redir2Str", "redir2br", "redirect_Str", "redir2string"], "legacy_format": ["legACY_format", "legacy_output", "legacy_form", "legacy_mode", "legACY_Format", "legacy_Format", "legACY_form", "legacy_version", "legACY_version"], "host_port": ["host_person", "host_phone", "hostablephone", "host_ports", "inner_search", "inner_queue", "host_search", "check_person", "host_pan", "hostablesearch", "archive_ort", "host_ort", " host_name", "check_post", "host_Port", "inner_phone", "archive_pan", "archive_line", " host_Port", "inner_port", "check_port", "archive_port", "host_post", "host_name", "host_queue", "check_ports", "hostableport", "hostablequeue", "host_line"], "guest_port": ["guest_type", "guest_ports", "guested_Port", "guest_PORT", "guested_ports", "guess_ports", "guest_component", "guEST_ports", "guess_PORT", "guest_Port", "guEST_port", "guested_port", "guess_export", "guest__component", "guess_port", "guEST_PORT", "guest__port", "guested_type", "guess_component", "guest__PORT", "guest_export", "guest__ports", "guEST_component", "guess_Port"], "p": ["jp", "a", "f", "ptr", "per", "pb", "pat", "n", "j", "ctx", "proc", "vp", "conv", "v", "g", "port", "pt", "t", "pp", "padding", "ping", "cache", "pass", "np", "buff", "P", "m", "k", "r", "part", "rep", "prefix", "buffer", "c", "sp", "lp", "fp", "pos", "art", "pend", "pn", "ep", "wp", "cp", "b", "start", "post", "h", "pg", "pc", "e", "point", "u", "pard", "pid", "pre", "it", "d", "pad", "prop", "ps", "uf", "q", "bp", "pkg", "i", "tp", "str", "pa", "pe", "ip"], "buf": ["orig", "cur", "ctx", "window", "raw", "pool", "port", " buffer", "doc", "cb", "uffy", "uf", "queue", "pkg", "pack", "ait", "wait", "mem", "ff", "data", "cmd", "aka", "Buffer", "conv", "v", "box", "buff", "br", "que", "cp", "pg", "tmp", "eng", "txt", "Buff", "paste", " buffers", "pause", "rw", "seq", "temp", "proc", "req", "vp", "np", "rb", "buffer", "block", "cv", "bc", "iter", "str", "bytes", "tc", "pb", "bt", "cache", "msg", "cap", "act", "cam", "desc", "xff", "bag", "off", "page", "img", "b", "pad", "q", "bp", "nm"], "is_udp": ["is_hdp", "is_urcp", "is_ddcp", "is_ugp", "is_ugport", "is_duv", "is_adcp", "is_uidport", "is_hdcp", "is_uidcp", "is_hdv", "is_ducp", "is_uidp", "is_ugpa", "is_ddp", "is_urh", "is_dup", "is_adport", "is_ddps", "is_uidpa", "is_hdport", "is_adp", "is_ugcp", "is_udps", "is_duh", "is_udpa", "is_urp", "is_duport", "is_dups", "is_urps", "is_ddh", "is_udh", "is_udcp", "is_dupa", "is_udport", "is_adv", "is_udv"], "end": ["est", "conn", "out", "exc", "ff", "pat", "window", "begin", "after", "v", "chain", "next", "except", "ent", "stop", "nd", "help", "st", "offset", " End", "send", "desc", "rest", "ended", "END", "alt", "last", "obj", "ending", "gate", "comment", "add", "event", "pos", "pend", "en", "ec", "all", "append", "start", "post", "id", "hend", "e", "set", "enc", "pard", "pad", "max", "err", "q", "w", "str", "End"]}}
{"project": "qemu", "commit_id": "e6eef7c221634c942e9f586df84aae623aa06cd5", "target": 0, "func": "int kvm_arch_put_registers(CPUState *cs, int level)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    CPUS390XState *env = &cpu->env;\n\n    struct kvm_sregs sregs;\n\n    struct kvm_regs regs;\n\n    struct kvm_fpu fpu;\n\n    int r;\n\n    int i;\n\n\n\n    /* always save the PSW  and the GPRS*/\n\n    cs->kvm_run->psw_addr = env->psw.addr;\n\n    cs->kvm_run->psw_mask = env->psw.mask;\n\n\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_GPRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            cs->kvm_run->s.regs.gprs[i] = env->regs[i];\n\n            cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_GPRS;\n\n        }\n\n    } else {\n\n        for (i = 0; i < 16; i++) {\n\n            regs.gprs[i] = env->regs[i];\n\n        }\n\n        r = kvm_vcpu_ioctl(cs, KVM_SET_REGS, &regs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    /* Floating point */\n\n    for (i = 0; i < 16; i++) {\n\n        fpu.fprs[i] = env->fregs[i].ll;\n\n    }\n\n    fpu.fpc = env->fpc;\n\n\n\n    r = kvm_vcpu_ioctl(cs, KVM_SET_FPU, &fpu);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    /* Do we need to save more than that? */\n\n    if (level == KVM_PUT_RUNTIME_STATE) {\n\n        return 0;\n\n    }\n\n\n\n    /*\n\n     * These ONE_REGS are not protected by a capability. As they are only\n\n     * necessary for migration we just trace a possible error, but don't\n\n     * return with an error return code.\n\n     */\n\n    kvm_set_one_reg(cs, KVM_REG_S390_CPU_TIMER, &env->cputm);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_CLOCK_COMP, &env->ckc);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_TODPR, &env->todpr);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_GBEA, &env->gbea);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_PP, &env->pp);\n\n\n\n    if (cap_async_pf) {\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFTOKEN, &env->pfault_token);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFCOMPARE, &env->pfault_compare);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFSELECT, &env->pfault_select);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    if (cap_sync_regs &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_ACRS &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_CRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            cs->kvm_run->s.regs.acrs[i] = env->aregs[i];\n\n            cs->kvm_run->s.regs.crs[i] = env->cregs[i];\n\n        }\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_ACRS;\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_CRS;\n\n    } else {\n\n        for (i = 0; i < 16; i++) {\n\n            sregs.acrs[i] = env->aregs[i];\n\n            sregs.crs[i] = env->cregs[i];\n\n        }\n\n        r = kvm_vcpu_ioctl(cs, KVM_SET_SREGS, &sregs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    /* Finally the prefix */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_PREFIX) {\n\n        cs->kvm_run->s.regs.prefix = env->psa;\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_PREFIX;\n\n    } else {\n\n        /* prefix is only supported via sync regs */\n\n    }\n\n    return 0;\n\n}\n", "idx": 12853, "substitutes": {"cs": ["rc", "gs", "cf", "co", "tc", "bs", "cus", "ports", "cn", "ys", "ctx", "js", "CS", "Cs", "cc", "cas", "css", "asks", "ms", "ces", "ctr", "wcs", "hs", "cks", "ds", "cms", "ls", "ats", "s", "aps", "acs", "qs", "acts", "ts", "ars", "c", "cb", "cv", "caps", "otes", "ec", "vs", "ins", "cp", "ns", "cons", "ras", "ims", "pc", "fs", "ks", "ows", "els", "ics", "vc", "cz", "sts", "ss", "sc", "checks", "ce", "rs", "irs", "ps"], "level": ["status", "index", "cost", "error", "Level", "type", "version", "local", "lc", "family", "high", "mode", "LE", "depth", "scope", "role", "where", "layer", "le", "VEL", "lvl", "loop", "command", "tag", "release", "info", "stage", "location", "top", "code", "no", "print", "scale", "state", "levels", "style", "vel", "required", "priority"], "cpu": ["node", "cu", "instance", "pu", "CPU", "wrapper", "mem", "conn", "serv", "session", "setup", "ctx", "hw", "core", "cmp", "proc", "upt", "boot", "clock", "port", "util", "common", "processor", "bench", "ork", "uu", "vm", "runner", "arch", "nc", "ka", "cp", "gc", "ane", "apache", "client", "pc", "gpu", "ne", "net", "tp", "process", "anc", "nn"], "env": ["conn", "et", "manager", "ctx", "hw", "window", "port", "exe", "engine", "den", "end", "context", "doc", "console", "cb", "en", "vs", "client", "docker", "app", "net", "queue", "gear", "esm", "exc", "environment", "addr", "v", "outer", "spec", "stack", "ea", "cfg", "menu", "shell", "obj", "extra", "eni", "inv", "db", "args", "conf", "eng", "agent", "esp", "pe", "server", "nv", "ner", "proc", "eps", "er", "era", "org", "stage", "ec", "dev", "door", "enc", "ev", "serv", "ei", "eve", "ee", "el", "esc", "sv", "origin", "ef", "ext", "eu", "desc", "ew", "runner", "event", "here", "e", "Environment", "entry", "ve", "export", "sc", "viron", "worker"], "sregs": ["srelts", "srelments", "sregments", "srelds", "sregts", "srels", "sregds"], "regs": ["resds", "replts", "ress", "REGs", "grsi", "grrs", "regns", "gregs", "prls", " reggs", "prrs", "replns", "egS", " regrs", "egns", "retts", "recs", "prs", "grgs", " regsi", "Regds", "rets", "egs", "recrs", "recls", " regds", "regds", "gregts", "Regis", "retds", "regts", "pris", "REGls", "prts", " regts", "recsi", "regls", "gregns", "reggs", "Regr", "recS", " regls", "regos", "regis", "regr", "grs", "Regrs", "recgs", "retls", "Regos", "prr", " regis", "Regts", "recns", "regS", "regrs", "regsi", "gregos", "replos", "rests", "Regls", "Regs", "REGns", "repls", "Regns", "egls", "REGS", "prds", "resr"], "fpu": ["frecpu", "frepc", "bfcpu", "fpi", "vcpu", "lfpi", "fabcu", "fedcpu", "lfpc", "mpc", "frecu", "bfpc", "vcu", "xfpu", " fpc", "Fcpu", "fcu", "xfpc", " fcpu", "Fcu", "fcpu", "fedpu", "lfcpu", "frepu", "fabcpu", "bfcu", "mcu", "vpu", "vpc", "fedpc", "mpu", "xfcu", "Fpu", "xfcpu", "bfpu", "lfpu", "fedpi", " fcu", "fabpc", "fpc", "fabpu", "Fpc", "Fpi", "mcpu"], "r": ["rc", "error", "cr", "record", "lr", "usr", "hr", "attr", "pr", "response", "p", "mr", "tr", "vr", "dr", "str", "radius", "or", "v", "ror", "rar", "rr", "adr", "ar", "rate", "er", "rm", "rank", "result", "rb", "nr", "k", "m", "br", "kr", "rt", "c", "rh", "sr", "ry", "res", "rg", "debug", "h", "re", "rec", "fr", "rd", "entry", " rc", "it", "d", "err", "q", " err", "w", "R", "ter", "ri", "rs", "arr"], "i": ["index", "dr", "cli", "gu", "t", "ami", "ai", "m", "xi", "qi", " v", "client", "ims", "it", "ji", "us", "li", "oi", "ind", "j", "ki", "si", "zi", " ti", "v", "ui", "iq", "slice", "ti", "ex", "x", "ri", "ic", "ix", "ip", "ij", "key", "mi", "ii", "I", "pi", "this", "batch", "di", " ii", "in", "sim", "info", "remote", "ci", " l", "id", "u", "multi", "me", "status", "ni", "o", "iu", " j", "ini", "ei", "uri", "p", "chain", "bi", "k", "\u0438", "h", "point", "list", "gi", "q", "phi", "init", "y"]}}
{"project": "qemu", "commit_id": "ffbb1705a33df8e2fb12b24d96663d63b22eaf8b", "target": 0, "func": "static void spapr_hotplug_req_event(uint8_t hp_id, uint8_t hp_action,\n\n                                    sPAPRDRConnectorType drc_type,\n\n                                    uint32_t drc)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());\n\n    struct hp_log_full *new_hp;\n\n    struct rtas_error_log *hdr;\n\n    struct rtas_event_log_v6 *v6hdr;\n\n    struct rtas_event_log_v6_maina *maina;\n\n    struct rtas_event_log_v6_mainb *mainb;\n\n    struct rtas_event_log_v6_hp *hp;\n\n\n\n    new_hp = g_malloc0(sizeof(struct hp_log_full));\n\n    hdr = &new_hp->hdr;\n\n    v6hdr = &new_hp->v6hdr;\n\n    maina = &new_hp->maina;\n\n    mainb = &new_hp->mainb;\n\n    hp = &new_hp->hp;\n\n\n\n    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6\n\n                               | RTAS_LOG_SEVERITY_EVENT\n\n                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED\n\n                               | RTAS_LOG_OPTIONAL_PART_PRESENT\n\n                               | RTAS_LOG_INITIATOR_HOTPLUG\n\n                               | RTAS_LOG_TYPE_HOTPLUG);\n\n    hdr->extended_length = cpu_to_be32(sizeof(*new_hp)\n\n                                       - sizeof(new_hp->hdr));\n\n\n\n    spapr_init_v6hdr(v6hdr);\n\n    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);\n\n\n\n    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);\n\n    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));\n\n    mainb->subsystem_id = 0x80; /* External environment */\n\n    mainb->event_severity = 0x00; /* Informational / non-error */\n\n    mainb->event_subtype = 0x00; /* Normal shutdown */\n\n\n\n    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);\n\n    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));\n\n    hp->hdr.section_version = 1; /* includes extended modifier */\n\n    hp->hotplug_action = hp_action;\n\n    hp->hotplug_identifier = hp_id;\n\n\n\n    switch (drc_type) {\n\n    case SPAPR_DR_CONNECTOR_TYPE_PCI:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;\n\n        if (hp->hotplug_action == RTAS_LOG_V6_HP_ACTION_ADD) {\n\n            spapr_hotplug_set_signalled(drc);\n\n        }\n\n        break;\n\n    case SPAPR_DR_CONNECTOR_TYPE_LMB:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_MEMORY;\n\n        break;\n\n    case SPAPR_DR_CONNECTOR_TYPE_CPU:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_CPU;\n\n        break;\n\n    default:\n\n        /* we shouldn't be signaling hotplug events for resources\n\n         * that don't support them\n\n         */\n\n        g_assert(false);\n\n        return;\n\n    }\n\n\n\n    if (hp_id == RTAS_LOG_V6_HP_ID_DRC_COUNT) {\n\n        hp->drc.count = cpu_to_be32(drc);\n\n    } else if (hp_id == RTAS_LOG_V6_HP_ID_DRC_INDEX) {\n\n        hp->drc.index = cpu_to_be32(drc);\n\n    }\n\n\n\n    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp, true);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->xics, spapr->check_exception_irq));\n\n}\n", "idx": 12887, "substitutes": {"hp_id": ["phy_type", "hp___id", "hpttype", "hp___controller", "phy_mid", "hp___mid", "phy_id", "hp_mid", "hp_controller", "phy_controller", "hptmid", "hptcontroller", "hp_type", "hptid", "hp___type"], "hp_action": ["rh_action", "rh__type", "hp__id", "rh_type", "hp__data", "rh__data", "hp__type", "hp_type", "rh__id", "rh_data", "hp__action", "rh__action", "rh_id", "hp_data"], "drc_type": ["drs_types", "drcetyfile", "drc_method", "drs_method", "drs_file", "drcetytype", "drcetymethod", "drc_file", "drcetytypes", "drs_type", "drc_types"], "drc": ["hdrd", " drt", "bdRC", " dRC", "hdrt", "dRC", "bdrc", "drd", "hdrc", "bdrt", "drt", " drd", "bdrd", "hdRC"], "spapr": ["spaprar", "spipR", "spapprs", " spipr", "spaprs", " spaprar", " spipR", "spapsR", " spiprar", " spaprs", "spappr", "spapsrs", " spiprs", "spappR", "spapsr", "spapprar", "spapR", " spapR", "spipr", "spapsrar", "spiprar", "spiprs"], "new_hp": ["newtip", "freshptphys", "old__h", "newJhp", "newptphys", "news_ph", "old_phy", "news_hp", "news_eh", "newjrh", "newJhtml", "newerhtml", "new_cp", "new_html", "new0hp", "NEW___hp", "news_gp", "newptip", "next___html", "NEW___phys", "newsJgp", "newJgp", "new2rh", "new___ip", "freshpthop", " new_eh", "original0ph", "new___phys", "new_gp", "fresh_ip", "newthop", "original0hl", "newpthop", "new__h", "fresh_html", "newjeh", "newJeh", " new_phi", "new_eh", "old_hp", "new___phi", "original_hp", "newsJeh", "new0hl", "new___h", "NEW_hp", "newthp", "new_h", "old_gp", "next_phi", "new0ph", "NEW___phy", "original0cp", "new___phy", "original_hl", "new___ph", "fresh_hop", "newtphys", "new_ip", "NEW_phy", "newerhyper", "new_hl", "newjphi", "newJih", "newJph", "newJphi", "newjphys", "next___phi", "newerphy", "newpthp", "news_php", "NEW___rh", "new2hp", " new_rh", "new___ih", "new2phys", "new_phy", "new0cp", "original_ph", "fresh_phys", "newsJph", "new_hyper", "new___html", "newsJhp", "freshptip", "new2phy", "new_ih", "next_ih", "new_rh", "NEW_rh", "new___rh", "newjphy", "newerhp", "new___hop", "new__gp", "new__phy", "fresh_phy", "new___hp", "next___ih", "new___hl", "new_php", "news_phy", "next___hp", "news_hyper", "new_ph", "old_h", "new_phys", "freshpthp", "new___gp", "original0hp", "new_phi", "NEW_phys", "old__gp", "newjhp", "new__hp", "old__hp", "fresh_hp", "old__phy", "new___cp", "fresh_hyper", "original_cp", "next_html", "next_hp", "new_hop"], "hdr": ["hhDR", "harp", "thtr", " hiler", "Hiler", "khld", " hrid", "shheader", "ohheader", "hrid", "hDR", "shrr", "vrs", "shdr", " htr", " hpar", "Harp", "shDR", "Hendor", "hhdrop", " hDR", "chdr", "ehDR", "ohendor", "hmheader", " hheader", "oharp", "khdr", "ehiler", "ohdr", " hrr", "hirid", "phder", "Hdr", "shld", "hhdr", "chld", "phendor", "hendor", "hld", "khheader", "thrr", "chrd", "thld", "hheader", "hdrop", "ehheader", "chrid", "hidr", " hdrop", "khDR", "ohder", "thdr", "htr", "hhld", "hird", "hhrs", "phDR", "shtr", "hild", "hpar", "vdrop", "hder", "HDR", "hrs", "hrd", "hhpar", "vDR", " hrs", "Hheader", "Hld", "hmdr", "vdr", "hrr", "ehdr", "phdr", "Hder", "ohDR", "hiler", "hmarp", "Hpar", " hld", " hrd", "hmDR"], "v6hdr": ["v4Hr", "v6khdr", "v4Hdr", "v6pharg", "v6hDR", "v6ihder", "v4HDR", "v4hld", "v4hdr", "v6phDR", "v4harg", "v6hhdr", "v6ihdr", "v4harp", "v6ohDR", "v4hbr", "v6phld", "v4Hld", "v6harg", "v4Harp", "v4Hder", "v4hrs", "v4harc", "v6ohbr", "v6hrs", "v6hder", "v6Harg", "v6iharg", "v6harc", "v6kharp", "v4Harc", "v6HDR", "v6hbr", "v6harp", "v6Hld", "v6kharc", "v6hr", "v6vder", "v4hDR", "v6hhbr", "v4Hbr", "v6hld", "v6Hr", "v6vDR", "v4hder", "v4Hrs", "v4hr", "v6hmdr", "v6hmarp", "v6ohr", "v6Harc", "v6Harp", "v6Hdr", "v6vrs", "v6khDR", "v6hhDR", "v6ohdr", "v6ihrs", "v6hmarc", "v6hmDR", "v6Hbr", "v6hhr", "v4Harg", "v6Hder", "v6phdr", "v6Hrs", "v6vdr", "v6ihDR", "v6ihld"], "maina": ["minp", "Mainae", "masterp", "manea", "masterA", "Mainea", "masterb", "centralA", "minA", "manca", "masterea", "sidep", "Mainb", "Mainsa", "mainca", "mainsa", " mainA", "centrala", "mainae", "plainb", "minb", " mainae", "mastera", "sidea", "sideb", "centralsa", "Mainla", "mainA", "Mainca", " mainla", " mainsa", "centralb", "mainp", "mainea", "masterca", "mina", "plainla", "MainA", "plainae", "mainla", "plaina", "mana", "Maina", "sideA", "manb"], "mainb": ["masterp", " mainend", "Mainn", "Mainw", "mainend", "minb", " mainab", "sidea", "primaryend", "sideb", "storeb", "Mainp", "centera", "storeba", "masterbe", "mainc", " mainp", " maine", "masterend", "mina", "mine", "Mainb", "masterh", "masterw", "mainab", "masterba", "centerbe", "centere", "storea", " mainc", " mainB", "mainba", "minj", "mainw", "sidee", "mainfb", "centerab", "mainh", " mainbe", " mainba", "mainj", "sidec", "primaryfb", "centerc", "mainp", "Mainbe", "Mainh", " mainn", "primaryb", " mainj", " mainw", "Maina", "centerb", "masterab", "masterb", "maine", "mastera", "mainbe", " mainfb", "masterc", "mainn", "mastern", "masterB", "MainB", " mainh", "centerj", "storec", "mainB", "masterfb"], "hp": ["jp", "ptr", "phys", "ph", "HP", "pr", "hz", "addr", "p", "hm", "hw", "vp", "dp", "chip", "http", "pt", "ih", "xp", "pp", "hs", "np", "pha", "prot", "php", "eth", "health", "hop", "phy", "html", "hd", "ips", "dq", "hops", "physical", "lp", "rh", "oh", "drm", "wp", "ht", "cp", "gp", "h", "hl", "prof", "nih", "dh", "ps", "hess", "eh", "phi", "hap", "pkg", "tp", "history", "ip"]}}
{"project": "qemu", "commit_id": "3393bc105d58e1f4a27d9a8e7062da9cef260cc3", "target": 0, "func": "static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)\n\n{\n\n    USBHubPort *port;\n\n    USBDevice *dev;\n\n    int i, ret;\n\n\n\n    for(i = 0; i < NUM_PORTS; i++) {\n\n        port = &s->ports[i];\n\n        dev = port->port.dev;\n\n        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {\n\n            ret = usb_handle_packet(dev, p);\n\n            if (ret != USB_RET_NODEV) {\n\n                return ret;\n\n            }\n\n        }\n\n    }\n\n    return USB_RET_NODEV;\n\n}\n", "idx": 12894, "substitutes": {"s": ["ses", "gs", "S", "bs", "ports", "j", "js", "n", "sq", "v", "sl", "t", "spec", "is", "sv", "sb", "sys", "ds", "ls", "ats", "services", "qs", "ts", "c", "sp", "ns", "b", "h", "es", "set", "fs", "os", "se", "sts", "ss", "rs", "ps"], "p": ["pro", "jp", "a", "pb", "pat", "vp", "v", "pt", "t", "pp", "now", "P", "m", "part", "press", "phy", "c", "fp", "wp", "ap", "cp", "b", "post", "h", "pc", "pre", "pkg", "w", "tp", "pa", "pe", "pod", "ps"], "port": ["pro", "server", "profile", "key", "public", "type", "peer", "Port", "serv", "socket", "handle", "per", "ports", "pi", "address", "pr", "group", "eport", "project", "pool", "pt", "test", "t", "unit", "service", "policy", "bus", "P", "connection", "cam", "tag", "th", "channel", "porter", "phy", "driver", "PORT", "bridge", "buffer", "sp", "file", "page", "link", "cp", "client", "gp", "device", "table", "pc", "ort", "host", "point", "ace", "state", "var", "component", "ve", "pl", "interface", "ported", "tab", "pe", "pod", "ip"], "dev": ["pro", "vo", "def", "rem", "stable", "be", "des", "mem", "DEV", "go", "conn", "local", "ver", "out", "serv", "pub", "dn", "det", "addr", "build", "data", "hw", "window", "raw", "Dev", "val", "v", "gu", "test", "md", "nd", "priv", "ch", "buf", "bin", "cam", "nt", "desc", "mobile", "dd", "att", "obj", "doc", "off", "dem", "development", "db", "device", "cho", "any", "ach", "ad", "develop", "sd", "de", "app", "pad", "d", "ve", "ev", "iv", "w", "av", "home", "driver", "normal", "tech"], "i": ["ij", "index", "key", "li", "f", "iu", "oi", "mi", " j", "I", "pi", " iter", "ini", "j", "uri", " li", " di", "ind", "si", "ex", "ki", " ti", "ori", " si", "g", "bi", "us", " pi", "ui", "di", " ii", " mi", "m", "ai", "in", " I", "ie", " is", "xi", "qi", " bi", "sim", "info", "im", " multi", "ci", " v", "print", "ims", "id", " ni", "e", "ti", "ri", "multi", "it", "gi", "fi", " m", "me", "ji", "phi", "init", " err", "x", "y", "ic", "ix", "ii", "ip"], "ret": ["resp", "status", "rem", "def", "plain", "out", "pret", "det", "ll", "fun", "back", "Ret", "tr", "reply", "rets", "RET", "reset", "val", "not", "reg", "try", "vet", "rm", "result", "cat", "nt", "lit", "alt", "gt", "our", "rt", "rev", "res", "print", "flag", "red", "cert", "re", "set", "mt", "rel", "ft", "it", "elt", "ne", "pas", "err", " Ret", "ter", "str", "cont", "txt", "arr"]}}
{"project": "qemu", "commit_id": "c6d2283068026035a6468aae9dcde953bd7521ac", "target": 1, "func": "BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,\n\n                                  QEMUIOVector *qiov, int nb_sectors,\n\n                                  BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BlockDriverAIOCB *ret;\n\n\n\n    if (!drv)\n\n        return NULL;\n\n    if (bs->read_only)\n\n        return NULL;\n\n    if (bdrv_check_request(bs, sector_num, nb_sectors))\n\n        return NULL;\n\n\n\n    if (bs->dirty_tracking) {\n\n        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);\n\n    }\n\n\n\n    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,\n\n                               cb, opaque);\n\n\n\n    if (ret) {\n\n\t/* Update stats even though technically transfer has not happened. */\n\n\tbs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\tbs->wr_ops ++;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 12916, "substitutes": {"bs": ["gs", "ubis", "ubs", "aos", "obs", "outs", "pb", "hz", "js", "bits", "bh", "css", "bes", "als", "sb", "aus", "hs", "sys", "cks", "pse", "ds", "ls", "ats", "bn", "bd", "BS", "qs", "bsp", "acs", "ts", "bos", "bm", "base", "boxes", "bas", "blog", "vs", "b", "ns", "cs", "bc", "lbs", "fs", "bps", "ks", "locks", "bis", "its", "bb", "ics", "bp", "ss", "sts", "ms", "rs", "ps"], "sector_num": ["section_index", "sector_index", "sector_pos", "sectoretycon", "sectoretynum", "ector_Num", "sectorableno", "section_number", " sector_mon", "sector_con", "section_num", "sector_Num", "sectoritynumber", "sectorablesym", "ser_number", "sectoretynumber", "sectoretypos", "sectorablemon", "sectorityindex", "sector_number", "ser_sym", "sector_no", "ector_number", " sector_sym", " sector_no", "sectoretysym", "sectoritynum", "sectorablenum", "ser_num", "ector_no", "sector_sym", "sectoretyindex", "ector_num", "sector_mon", "section_pos", "sectoritypos", "ser_con"], "qiov": ["qiour", "qiop", "sqiov", "viol", "Qiol", "Qveh", "sqiour", " qveh", "Qiov", "Qiour", " qiol", "Qiev", "sqiev", "Qiop", " qiev", "sqiop", " qiop", "qiev", "viov", "qveh", "viour", "vveh", " qiour", "qiol"], "nb_sectors": ["nb_pellers", "nb_sellers", "nb_seectors", "nb_nectors", "nb_segments", "nb_vevers", "nb_seeors", "nb_severs", "nb_asevers", "nb_speors", "nb_vegments", "nb_bectors", "nb_speriers", "nb_nellers", "nb_spellers", "nb_seecs", "nb_seevers", "nb_pegments", "nb_pevers", "nb_spevers", "nb_secs", "nb_seriers", "nb_veories", "nb_seories", "nb_vecs", "nb_aseories", "nb_pecs", "nb_beriers", "nb_peories", "nb_veors", "nb_bevers", "nb_spectors", "nb_beors", "nb_peors", "nb_specs", "nb_asectors", "nb_vellers", "nb_necs", "nb_vectors", "nb_seors", "nb_pectors", "nb_negments", "nb_aseors"], "cb": ["rc", "cf", "unc", "tc", "fun", "pb", "callback", "cmd", "obb", "ctx", "eb", "cc", "cd", "conv", "ctr", "bt", "gb", "lb", "rb", "func", "job", "cfg", "ck", "c", "db", "cv", "nc", "bf", "fn", "cp", "ctrl", "b", "bc", "fc", "bb", "nb", "CB", "bp", "Callback", "ob"], "opaque": [" opatile", "OPatile", " opserver", "porque", "poraque", "OPula", "opula", "oppatile", "porserver", "comppty", "OPpty", " opque", "poratile", "oppaque", "Opaque", "Opserver", "compatile", "opppty", "compaque", "Opque", "opatile", "opserver", "oppty", "compula", "opque", "OPaque", "oppula", "Opatile"], "drv": ["drvr", " drV", "srve", " drf", "derv", "derva", " drw", "drif", "drw", "crf", "crv", "drV", "vrv", "drmv", "drmm", "drmvr", "drva", " drve", " drm", " drva", "crvr", "drvc", " drvc", "drve", "srv", "drvs", "drmw", "srvs", "driv", "derm", "drmvc", "drm", "srf", "drmV", "vrV", "vrvr", "derw", "drmva", "drf", "drive", "srvr", " drvs", "crvs", "vrvc", "srw", "driw", " drvr"], "ret": ["resp", "jp", "rem", "def", "status", "ref", "success", "out", " RET", "det", "ll", "bool", "addr", "back", "Ret", "tr", "temp", "rets", "RET", "val", "reset", "reg", "t", "len", "real", "rm", "result", "nt", "lit", "gt", "alt", "last", "obj", "got", "rev", "rt", "backed", "ter", "lt", "res", "print", "gc", "red", "cert", "report", "re", "verified", "tmp", "flag", "mt", "ft", "nil", "elt", "err", "pas", "final", " Ret", "leg", "usr", "cont", "txt", "arr"], "wr_ops": ["write_outs", "write_ops", "wr_times", "wr_outs", "write_bytes", "write_times", "wr_bytes"]}}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_dct_init_x86(DCTContext *s)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_SSE(cpu_flags))\n\n        s->dct32 = ff_dct32_float_sse;\n\n    if (EXTERNAL_SSE2(cpu_flags))\n\n        s->dct32 = ff_dct32_float_sse2;\n\n    if (EXTERNAL_AVX(cpu_flags))\n\n        s->dct32 = ff_dct32_float_avx;\n\n}\n", "idx": 12927, "substitutes": {"s": ["aws", "gs", "S", "sac", "settings", "bs", "js", "sq", "ms", "is", "sb", "sv", "als", "sys", "hs", "ds", "ats", "ls", "r", "qs", "ts", "c", "ares", "ins", "ns", "ops", "cs", "an", "ims", "set", "fs", "conf", "os", "its", "ss", "sts", "sc", "sets", "rs", "ps"]}}
{"project": "FFmpeg", "commit_id": "5ecabd3c54b7c802522dc338838c9a4c2dc42948", "target": 1, "func": "static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,\n\n                             GetByteContext *gb)\n\n{\n\n    unsigned char rle_code;\n\n    unsigned char extra_byte, odd_pixel;\n\n    unsigned char stream_byte;\n\n    unsigned int pixel_ptr = 0;\n\n    int row_dec = pic->linesize[0];\n\n    int row_ptr = (avctx->height - 1) * row_dec;\n\n    int frame_size = row_dec * avctx->height;\n\n    int i;\n\n\n\n    while (row_ptr >= 0) {\n\n        if (bytestream2_get_bytes_left(gb) <= 0) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"MS RLE: bytestream overrun, %d rows left\\n\",\n\n                   row_ptr);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        rle_code = stream_byte = bytestream2_get_byteu(gb);\n\n        if (rle_code == 0) {\n\n            /* fetch the next byte to see how to handle escape code */\n\n            stream_byte = bytestream2_get_byte(gb);\n\n            if (stream_byte == 0) {\n\n                /* line is done, goto the next one */\n\n                row_ptr -= row_dec;\n\n                pixel_ptr = 0;\n\n            } else if (stream_byte == 1) {\n\n                /* decode is done */\n\n                return 0;\n\n            } else if (stream_byte == 2) {\n\n                /* reposition frame decode coordinates */\n\n                stream_byte = bytestream2_get_byte(gb);\n\n                pixel_ptr += stream_byte;\n\n                stream_byte = bytestream2_get_byte(gb);\n\n                row_ptr -= stream_byte * row_dec;\n\n            } else {\n\n                // copy pixels from encoded stream\n\n                odd_pixel =  stream_byte & 1;\n\n                rle_code = (stream_byte + 1) / 2;\n\n                extra_byte = rle_code & 0x01;\n\n                if (row_ptr + pixel_ptr + stream_byte > frame_size ||\n\n                    bytestream2_get_bytes_left(gb) < rle_code) {\n\n                    av_log(avctx, AV_LOG_ERROR,\n\n                           \"MS RLE: frame/stream ptr just went out of bounds (copy)\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                for (i = 0; i < rle_code; i++) {\n\n                    if (pixel_ptr >= avctx->width)\n\n                        break;\n\n                    stream_byte = bytestream2_get_byteu(gb);\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n\n                    pixel_ptr++;\n\n                    if (i + 1 == rle_code && odd_pixel)\n\n                        break;\n\n                    if (pixel_ptr >= avctx->width)\n\n                        break;\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n\n                    pixel_ptr++;\n\n                }\n\n\n\n                // if the RLE code is odd, skip a byte in the stream\n\n                if (extra_byte)\n\n                    bytestream2_skip(gb, 1);\n\n            }\n\n        } else {\n\n            // decode a run of data\n\n            if (row_ptr + pixel_ptr + stream_byte > frame_size) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"MS RLE: frame ptr just went out of bounds (run)\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            stream_byte = bytestream2_get_byte(gb);\n\n            for (i = 0; i < rle_code; i++) {\n\n                if (pixel_ptr >= avctx->width)\n\n                    break;\n\n                if ((i & 1) == 0)\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n\n                else\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n\n                pixel_ptr++;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* one last sanity check on the way out */\n\n    if (bytestream2_get_bytes_left(gb)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"MS RLE: ended frame decode with %d bytes left over\\n\",\n\n               bytestream2_get_bytes_left(gb));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12940, "substitutes": {"avctx": ["avjac", "avtx", "avercmd", "avcmp", " avfunc", "vactx", "AVcam", "avctl", "AVcontext", "avfunc", "awreq", "AVctx", "svcmd", "avcontext", "awctx", "avercontext", "avereq", "ajcontext", "ajctl", "avsys", "avesys", "avercpp", "vafunc", "ajcpp", "averreq", "ajctx", " avcmd", "ravcmp", " avtx", "ravctx", "svcontext", "svtx", "averctx", "avreq", "ajreq", "ajjac", "awcpp", "avectx", "vacontext", "AVtx", "avcmd", "ravcontext", "avercam", "avertx", " avcmp", " avcam", "aversys", "ajtx", "ravfunc", "avcpp", "ajsys", "svctl", " avcontext", " avctl", "avejac", "svctx", "avcam", "averjac", "awjac", "vacmp"], "pic": ["jp", "phys", "py", "png", "pi", "ctx", "p", "pol", "lib", "proc", "g", "picture", "pin", "pt", "media", "photos", "ic", "np", "icc", "cam", "peg", "doc", "pa", "pict", "sp", "Pic", "photo", "img", "cp", "Picture", "gc", "pg", "pc", "fc", "pdf", "piece", "px", "ps", "pl", "iac", "jpg", "pan", "jac", "sci"], "gb": ["bytes", "csv", "gs", "ubis", "tg", "gin", "gg", "GB", "pb", "hub", "ctx", "hog", "wb", "eb", "lib", "storage", "erb", "g", "vg", "sb", "sys", "rb", "cfg", "gt", "kb", "gd", " rgb", "fb", "phy", "vm", "html", "gram", "cb", "db", "cv", "bf", "gc", "rg", "gnu", "gm", "cgi", "bc", "yg", "pc", "pg", "gif", "eg", "sg", "uv", "mb", "px", "uf", "gy", "gz", "bg", "tm", "gam", "nb", "Gb", "jpg"], "rle_code": ["rle2mode", "rlePmessage", "rle2num", "rLE_length", "rle_bit", "rle8code", "rle_num", "rler_co", "rle_byte", "rLE_coe", "rler2error", "rler_error", "rle_page", "rlee_cod", "rler2mode", "rler2code", "rLE_byte", "rle8page", "rle2error", "rle2length", "rLE_no", "rLE_Code", "rle_create", "rle2byte", "rle8coe", "rlee_byte", "rLE_message", "rler_code", "rlee_code", "rle__codes", "rle_error", "rlePcoe", "rLE_error", "rle_no", "rle_cod", "rLE_create", "rle_message", "rle__bit", "rle_channel", "rle_co", "rler2co", "rle_coe", "rle8codes", "rle2code", "rle_Code", "rlePcode", "rle__code", "rLE_code", "rle_mode", "rle_length", "rle_text", "rLE_num", "rLE_codes", "rlee_channel", "rle_codes", "rler_mode", "rLE_page", "rle2co", "rlePno", "rle__text"], "extra_byte": [" extra_bit", " extra_field", "extra___bit", "extra___char", "extra_char", "extra___word", " extra_word", "extra_bytes", "extra_field", "extra___bytes", "extra___byte", " extra_bytes", "extra___field", "extra_word", "extra_bit", " extra_char"], "odd_pixel": ["even_sample", "even_channel", "odd67channel", " odd_picture", "odd67pixel", "odd___channel", "odd67sample", "odd___image", " odd_image", "even_pixel", "odd___pixel", "odd_channel", " odd_channel", "odd___picture", "odd_sample", "odd_image", "odd_picture"], "stream_byte": ["streamletby", "browserstwo", "public_index", "REAM_byte", "streamstwo", "stream___bytes", "streamselement", "stream_two", "empty_no", "REAM_element", "row_bit", "streamjcode", "browser_two", "streamletelement", "iterator_status", "streamjbyte", "iteratoritystatus", "streamlymem", "streamJbyte", "stream_pair", "entity_by", "stream5two", "row_bytes", "stream_member", "stream_block", "pipeletbuffer", "stream_rule", "streamptrelation", " stream_pixel", "stream5element", "row_num", "stream_result", "streamsstatus", "streamsbyte", "streamtindex", "stream_num", "stream_mem", "strJptr", "publiclyindex", "str_bytes", "browsersresult", "streamitymember", "http_relation", "streamletnote", "streamitycode", "browser_element", "streamtbinary", "iterator_code", "stream___byte", "streamtrule", "stream___name", "streamitybyte", "pipeletelement", "stream_by", "stream_fine", "stream5relation", "pipe_byte", " stream_char", "stream_second", "stream___member", "streamtmem", "strJchar", "streamitystatus", "streamlyindex", "entity_note", "stream5byte", "browserselement", "streamtbyte", "http_fine", "streamJchar", "pipe_element", "emptyjcode", "publiclybyte", "pipe_buffer", "stream5result", "stream___code", "public_mem", "entity_byte", "str_char", "stream___char", "streamscode", "pipe_link", "publiclyrule", "stream_link", "iteratoritycode", "REAM_bit", "http_byte", "streamptfine", "stream_code", "stream_ptr", "streamletlink", "streamptbyte", "iteratoritybyte", "row_buffer", "public_byte", "streamletbuffer", "stream_element", "entityletby", "public_rule", "stream_binary", "streamjno", "emptyjno", "row_note", "entityletbyte", "streamtnote", "empty_code", "stream_bit", "iterator_byte", "stream_relation", "pipeletlink", "str_ptr", "stream___status", "emptyjbyte", " stream_name", "browsersbyte", "streamingtwo", "empty_byte", "stream_no", "streamingelement", " stream_bytes", "stream_status", " stream_string", "publiclymem", "stream_string", "entity_binary", "http_second", "stream_char", "stream5second", "streamingresult", "row_byte", "entityletbinary", "streamingbyte", "iteratoritymember", "streamJbytes", "entityletnote", " stream_pair", "strJbyte", "stream_name", "streamlyrule", "stream_pixel", "REAM_buffer", " stream_buffer", "stream_note", " stream_no", "iterator_member", "streamJptr", "streamletbyte", "strJbytes", "browser_byte", "streamlybyte", "pipeletbyte", "stream_bytes", "browser_result", "streamtby", "stream5fine", "stream_index", "streamsmember", " stream_block", "stream_buffer", "streamsresult", "streamletbinary", "str_byte", "streamptsecond"], "i": ["index", "li", "a", "f", "l", "iu", "o", "oi", "mi", "ii", "I", "pi", " j", "ini", "j", "ei", "p", " di", "ind", "x", "si", "ki", "zi", "n", " ti", "cli", " si", "g", "uli", "bi", "batch", "v", "t", "us", " pi", "ui", "di", " ii", " mi", "ai", "m", "in", "k", "r", "hi", "xi", "qi", " bi", "sim", "im", "c", " multi", "ci", "b", "id", "ti", " ni", "e", "u", "multi", "gi", "it", "me", "phi", "init", " e", "ic", "ix"], "pixel_ptr": ["row_loc", "component_ptr", "pixel64addr", " pixel_pointer", "pixel_dr", "pixel_pend", "pixel____pointer", "pixel2ptr", "pixel_pointers", " pixel_rect", "pixel____ptr", "pixel64ptr", "client64pointer", "pixel_Ptr", "pixel__Ptr", " pixel_Ptr", "pixel_pr", "pixel__ptr", "pixel2pointers", "pixel2src", "pixel_loc", "pixel2pointer", "pixel_rect", "pixelptrect", "client_addr", " pixel_pend", "row_perm", "client64dr", "client_dr", "pixel_addr", " pixel_pointers", " pixel_src", "row_pointer", "row_address", "pixel____addr", "row_ptr", "client64addr", "pixelptpend", "pixel_pointer", "pixel__pr", "pixel_address", "component_Ptr", "pixelptPtr", "client_pointer", "pixel64pointer", "component_inter", "client64ptr", "row_Ptr", "row_addr", "pixelptptr", "component_pr", "pixel_perm", "pixel64dr", "pixel__inter", "pixel_src", "pixel_inter", "client_ptr", "pixel____perm"]}}
{"project": "qemu", "commit_id": "068593deea6cc61b06243a33c7fcfadb1650b654", "target": 1, "func": "void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)\n\n{\n\n    int i = 0;\n\n    int x = 0;\n\n    uint32_t l_64 = (l + 1) / 8;\n\n\n\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n\n               __func__, l, dest, src);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if ((l > 32) &&\n\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n\n        if (dest == (src + 1)) {\n\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n\n            return;\n\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n\n            mvc_fast_memmove(env, l + 1, dest, src);\n\n            return;\n\n        }\n\n    }\n\n#else\n\n    if (dest == (src + 1)) {\n\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n\n        return;\n\n    } else {\n\n        memmove(g2h(dest), g2h(src), l + 1);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    /* handle the parts that fit into 8-byte loads/stores */\n\n    if (dest != (src + 1)) {\n\n        for (i = 0; i < l_64; i++) {\n\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n\n            x += 8;\n\n        }\n\n    }\n\n\n\n    /* slow version crossing pages with byte accesses */\n\n    for (i = x; i <= l; i++) {\n\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n\n    }\n\n}\n", "idx": 12946, "substitutes": {"env": ["server", "rc", "vv", "nv", "param", "conn", "et", "manager", "environment", "dn", "estate", "attr", "cmd", "ctx", "ner", "window", "erd", "vp", "him", "v", "erb", "dt", "outer", "esc", "er", "msg", "En", "buf", "ami", "ef", "end", "desc", "ener", "ew", "context", "ah", "obj", "gate", "shell", "org", "info", "vm", "cb", "cv", "en", "code", "ec", "vs", "ager", "dev", "h", "e", "Environment", "con", "config", "enter", "err", "EN", "eh", "net", "ev", "vt", "pkg", "w", "gear", "ter", "viron", "worker"], "l": ["li", "nl", "ly", "tl", "vl", "local", "lr", "ll", "lc", "size", "j", "p", "n", "ln", "dl", "L", "v", "layer", "g", "sl", "el", "le", "t", "source", "len", "loc", "loop", "fl", "lb", "lang", "ls", "k", "m", "lock", "lit", "r", "lin", "s", "al", "line", "shell", "c", "lp", "all", "ul", "kl", "b", "h", " L", "hl", "list", "length", "d", "pl", "lo", "level", "x", "w", "y", "ld"], "dest": ["index", "orig", "sur", "port", "t", "loc", "st", "end", "result", "nt", "lit", "parent", "site", "coord", "it", "del", "usr", "pro", "mem", "ptr", "addr", "tr", "resource", "v", "next", "test", "spec", "cat", "dist", "th", "obj", "null", "them", "pos", "std", "cp", "tmp", "dep", "target", "x", "nw", "est", "out", "wb", "temp", "proc", "source", "sys", "np", "comb", "rest", "gt", "remote", "trans", "dev", "iter", "d", "to", "err", "win", "dat", "home", "go", "route", "output", "success", "p", "tif", "deg", "gen", "priv", "origin", "dc", "desc", "r", "gate", "Dest", "sp", "decl", "master", " dst", "rel", "prop", "pas", "pl", "w", "nom"], "src": ["orig", "cur", "attr", "sur", "rl", "sq", "typ", "filename", "cli", "sl", "loc", "st", "lit", "s", "site", "sr", "start", "ser", "nil", "sn", "usr", "cont", "rc", "ptr", "ind", "addr", "RC", "conv", "syn", "spec", "via", "dist", "th", "std", "comp", "sync", "slice", "input", "tmp", "set", "target", "iv", "supp", "txt", "sub", "proc", "ctr", "source", "sb", "sec", "sys", "np", "rb", "scan", "in", "rest", "trans", "inner", "iter", "from", "err", "str", "sort", "inc", "origin", "tn", "desc", "r", "url", "rt", "sp", "sel", "pri", "img", "ins", "SOURCE", "rel", "gz", "inst", "sc", "rs", "ident"], "i": ["ij", "index", "status", "li", "f", "iu", "mi", " j", "I", "pi", "ii", "ini", "j", "p", "ind", "ei", "si", "ki", "zi", "v", "cli", "bi", "t", "ui", "iq", "is", "di", "ami", " ii", "ai", "m", "in", "r", " I", "hi", "ie", "xi", "qi", "sim", "im", "\u0438", "c", "ci", "b", "wi", "id", "ti", "ri", " x", "u", "iter", "multi", "it", "gi", "ji", "me", "MI", "q", "phi", "init", "w", "x", "y", "ic", "ix", "ip"]}}
{"project": "qemu", "commit_id": "0d2cd785ef1282b14687f9f7f4b63ae4a2430be3", "target": 1, "func": "static void test_properties(const char *path, bool recurse)\n\n{\n\n    char *child_path;\n\n    QDict *response, *tuple;\n\n    QList *list;\n\n    QListEntry *entry;\n\n\n\n    g_test_message(\"Obtaining properties of %s\", path);\n\n    response = qmp(\"{ 'execute': 'qom-list',\"\n\n                   \"  'arguments': { 'path': %s } }\", path);\n\n    g_assert(response);\n\n\n\n    if (!recurse) {\n\n        return;\n\n    }\n\n\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    list = qobject_to_qlist(qdict_get(response, \"return\"));\n\n    QLIST_FOREACH_ENTRY(list, entry) {\n\n        tuple = qobject_to_qdict(qlist_entry_obj(entry));\n\n        bool is_child = strstart(qdict_get_str(tuple, \"type\"), \"child<\", NULL);\n\n        bool is_link = strstart(qdict_get_str(tuple, \"type\"), \"link<\", NULL);\n\n\n\n        if (is_child || is_link) {\n\n            child_path = g_strdup_printf(\"%s/%s\",\n\n                                         path, qdict_get_str(tuple, \"name\"));\n\n            test_properties(child_path, is_child);\n\n            g_free(child_path);\n\n        } else {\n\n            const char *prop = qdict_get_str(tuple, \"name\");\n\n            g_test_message(\"Testing property %s.%s\", path, prop);\n\n            response = qmp(\"{ 'execute': 'qom-get',\"\n\n                           \"  'arguments': { 'path': %s,\"\n\n                           \"                 'property': %s } }\",\n\n                           path, prop);\n\n            /* qom-get may fail but should not, e.g., segfault. */\n\n            g_assert(response);\n\n        }\n\n    }\n\n}\n", "idx": 12949, "substitutes": {"path": ["node", "key", "index", "type", "request", "route", "mount", "patch", "ref", "data", "pr", "pat", "PATH", "str", "p", "cmd", "call", "module", "ath", "resource", "dir", "pattern", "name", "text", "chain", "test", "binding", "kind", "policy", "item", "tree", "message", "th", "context", "url", "prefix", "self", "Path", "link", "property", "pred", "alias", "print", "root", "term", "transform", "host", "trace", "method", "format", "target", "value", "history", "pkg", "package", "full", "template", "pointer"], "recurse": ["curses", "cursive", "recurry", "Recursive", " recursed", "discurry", " recursion", "Recurses", "respurse", "Recurse", "cursion", "respursed", "discursion", "recurses", " recursive", "recursion", "curse", "discurse", "respursion", " recurses", "recursive", "Recursion", " recurry", "respurry", "discursed", "recursed"], "child_path": ["child_clean", "child___path", "parent_Path", "child_stream", "child_url", "childingpath", "childjPath", "child2dir", "childingurl", "child_link", "friend_stream", "childlyclean", "child2path", "child_ath", "parent_column", "child2link", "childrenpart", "child_part", "parent_path", "child_key", "parent_dir", "childfulpart", "friendfulath", "childfulath", "childrenpath", "parent_link", "leaf_clean", "childfulpath", "friendfulpath", "leaf_part", "leaf_path", "leaf_url", "parent_key", "childfulstream", "child___key", "child_dir", "childjdir", "childrenstream", "child_column", "friend_path", "childlypath", "friendfulstream", "friend_ath", "childingpart", "friend_part", "child2Path", "friendfulpart", "childjlink", "childrenath", "child_Path", "child___column", "childlypart", "childingclean", "childjpath", "childlyurl", "child___Path"], "response": ["resp", "server", "profile", "def", "view", "error", "application", "request", "version", "nexus", "child", "array", "output", "success", "respond", "object", "data", "present", "sequence", "relation", "body", "reply", "given", "reference", "chain", "next", "frame", "roads", "service", "result", "tree", "connection", "send", "line", "message", "context", "description", "json", "info", "document", "render", "block", "Response", "remote", "page", "image", "function", "pos", "yes", "summary", "answer", "respons", "res", "vector", "example", "report", "python", "found", "collection", "trace", "os", "value", "xml", "pointer", "onse"], "tuple": ["tdple", "attuple", "tsuple", "entuple", " tue", " tup", "tple", "ttensor", "mutested", "ttrix", "enturtle", "tskeleton", "tkeleton", "trie", " trix", "tsup", "trick", "ttrie", "tmested", "try", "tup", "tsue", "tsple", " tensor", " tested", "attensor", "tmensor", "trix", "touch", "atturtle", "ttuple", "tue", "tples", "entouch", "attry", "tilde", " turtle", "tenilde", " try", "entrie", "attrie", "mutuple", "tensor", "atrick", " tple", "mutouched", "ttue", "tenrick", "atuple", "tsurtle", " touched", "atples", " tilde", "atilde", "tmouched", " trie", "tmuple", "nurtle", "tturtle", "nrie", " tples", "tdkeleton", "tenuple", "nuple", "attouch", " trick", "turtle", "tdup", " tkeleton", "tested", "nouch", "tenples", "mutensor", "tduple", "ttry", "tsrix", "touched"], "list": ["li", "dict", "local", "array", "out", "data", "l", "map", "ist", "n", "sequence", "p", "L", "v", "lists", "pool", "load", "List", "batch", "t", "source", "st", "listed", "result", "tree", "part", "none", "json", "parent", "library", "range", "document", "layout", "null", "all", "limit", "lat", "LIST", "table", "collection", "set", "e", "flat", "joined", "level", "join", "xml"], "entry": ["key", "instance", "index", "def", "record", "child", "query", "entity", "member", "inter", "search", "data", "row", "ent", "result", "item", "cell", "nt", "line", "context", "ie", "obj", "word", "match", "add", "info", "attribute", "RY", "image", "link", "ry", "import", "table", "Entry", "e", "pair", "see", "it", "element", "se", "ary", "ex", "cue"], "prop": ["pro", "key", "def", "Prop", "bug", "attr", "data", "pr", "cmd", " Prop", "p", "cmp", "feat", "proc", "val", "test", "acc", "priv", "msg", " props", "item", "op", "desc", "obj", "rep", "info", "pos", "property", "pred", "comp", "term", "tmp", "rel", "pid", "arg", "col", "pkg", "str", "properties", "ps"]}}
{"project": "FFmpeg", "commit_id": "482ee63641f4fa50f017538af384aadbceee7a18", "target": 1, "func": "static int thp_read_header(AVFormatContext *s,\n\n                           AVFormatParameters *ap)\n\n{\n\n    ThpDemuxContext *thp = s->priv_data;\n\n    AVStream *st;\n\n    AVIOContext *pb = s->pb;\n\n    int i;\n\n\n\n    /* Read the file header.  */\n\n                           avio_rb32(pb); /* Skip Magic.  */\n\n    thp->version         = avio_rb32(pb);\n\n\n\n                           avio_rb32(pb); /* Max buf size.  */\n\n                           avio_rb32(pb); /* Max samples.  */\n\n\n\n    thp->fps             = av_d2q(av_int2float(avio_rb32(pb)), INT_MAX);\n\n    thp->framecnt        = avio_rb32(pb);\n\n    thp->first_framesz   = avio_rb32(pb);\n\n                           avio_rb32(pb); /* Data size.  */\n\n\n\n    thp->compoff         = avio_rb32(pb);\n\n                           avio_rb32(pb); /* offsetDataOffset.  */\n\n    thp->first_frame     = avio_rb32(pb);\n\n    thp->last_frame      = avio_rb32(pb);\n\n\n\n    thp->next_framesz    = thp->first_framesz;\n\n    thp->next_frame      = thp->first_frame;\n\n\n\n    /* Read the component structure.  */\n\n    avio_seek (pb, thp->compoff, SEEK_SET);\n\n    thp->compcount       = avio_rb32(pb);\n\n\n\n    /* Read the list of component types.  */\n\n    avio_read(pb, thp->components, 16);\n\n\n\n    for (i = 0; i < thp->compcount; i++) {\n\n        if (thp->components[i] == 0) {\n\n            if (thp->vst != 0)\n\n                break;\n\n\n\n            /* Video component.  */\n\n            st = avformat_new_stream(s, NULL);\n\n            if (!st)\n\n                return AVERROR(ENOMEM);\n\n\n\n            /* The denominator and numerator are switched because 1/fps\n\n               is required.  */\n\n            avpriv_set_pts_info(st, 64, thp->fps.den, thp->fps.num);\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            st->codec->codec_id = CODEC_ID_THP;\n\n            st->codec->codec_tag = 0;  /* no fourcc */\n\n            st->codec->width = avio_rb32(pb);\n\n            st->codec->height = avio_rb32(pb);\n\n            st->codec->sample_rate = av_q2d(thp->fps);\n\n            thp->vst = st;\n\n            thp->video_stream_index = st->index;\n\n\n\n            if (thp->version == 0x11000)\n\n                avio_rb32(pb); /* Unknown.  */\n\n        } else if (thp->components[i] == 1) {\n\n            if (thp->has_audio != 0)\n\n                break;\n\n\n\n            /* Audio component.  */\n\n            st = avformat_new_stream(s, NULL);\n\n            if (!st)\n\n                return AVERROR(ENOMEM);\n\n\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            st->codec->codec_id = CODEC_ID_ADPCM_THP;\n\n            st->codec->codec_tag = 0;  /* no fourcc */\n\n            st->codec->channels    = avio_rb32(pb); /* numChannels.  */\n\n            st->codec->sample_rate = avio_rb32(pb); /* Frequency.  */\n\n\n\n            avpriv_set_pts_info(st, 64, 1, st->codec->sample_rate);\n\n\n\n            thp->audio_stream_index = st->index;\n\n            thp->has_audio = 1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12951, "substitutes": {"s": ["aws", "gs", "a", "S", "f", "bs", "p", "js", "n", "v", "g", "t", "is", "sb", "sv", "hs", "sys", "ds", "ats", "ls", "in", "m", "r", "sa", "sc", "ts", "c", "sp", "stats", "ins", "ns", "b", "cs", "h", "e", "fs", "ss", "sts", "ms", "rs", "ps"], "ap": ["am", "pe", "map", " sp", "ar", "pp", "cap", "op", "al", "att", "aps", "ac", "sp", "ep", " sap", "cp", " mp", "mp", " cp", "ape", " p", "amp", "ps", "pl", " af", "pa", "tap", "ip"], "thp": ["handp", "othpa", "handpp", "rahpp", "htnp", "thapad", "thanp", " thpt", "rahcp", "thapa", "othping", "htpm", " thcp", "khtip", "ethpp", "thpkg", "othport", "thport", "THg", "ithg", "htpa", "thg", "ttp", "ithpad", "terl", "thasp", " thpe", "thapm", "therping", " thpi", "therpid", "ithps", "thcp", "ithport", "othlp", "ethping", "khpi", "khpid", "thapr", "thop", "htm", "handps", "ithpr", " thlp", "althp", "tttip", "therpa", "othop", "othf", " thnp", "althnp", "ithpid", "therp", "traceg", "thl", "authpp", "terpi", "thag", "ethP", "terpa", " thm", "ethop", "ethps", "footpp", "othcp", "thaping", "handpa", "authps", "khp", "ethp", "terps", "ithpre", "therpm", "ithP", "headpp", "thpre", "therf", "thpp", "tracepa", "othp", " thping", "therps", "THpkg", "thpm", "ithnp", "othpm", "ethpi", "thnp", " thl", "rahnp", "footop", "thapt", "headp", " thpa", "authpid", "thpr", "heartpi", "thpa", "othm", "thlp", "ithping", "thpi", "htping", "authp", "khpp", "thping", "THop", "ethl", "hearttip", "thapkg", "ithl", "ithcp", "thacp", "ethpkg", "ethpad", "thaop", "ithop", "footport", "hrpe", "ethm", "htp", "othpp", "rahp", "thpid", "hrpa", "thalp", "THp", "terpp", "thap", "ithv", "therP", "ethlp", "thps", "htv", "htop", "ethnp", "thpe", "ithpp", "othv", "ithpa", "thm", "khl", "othnp", "othpt", "heartp", "footp", " thg", " thsp", "heartpid", "thape", "ithpm", "hrp", "tham", "terp", "ethg", "ethcp", "headl", "thP", "othP", "tercp", "thaP", "therlp", "thv", "ethpre", "ithm", "thapre", "ethpa", "ithf", "hrsp", "headpid", "tracecp", "thsp", "tracep", "thaps", "thtip", "therpp", "ttpid", " thps", "thpad", "ithp", "ithlp", "ttpi", " thP", "thf", "ethpr", "thpt", "ethpm", "althP", "althm"], "st": ["ste", "spect", "stable", "td", "est", "sw", "et", "src", "usr", "sta", "St", "ST", "ist", "utt", "tt", "stream", "ut", "stat", "put", "pt", "t", "nd", "stop", "bt", "mont", "stack", "ct", "nt", "cl", "irst", "rest", "th", "obj", "first", "rt", "ost", "sp", "art", "stage", "ust", "std", "sh", "no", "must", "start", "stru", "h", "etc", "tmp", "fr", "mt", "set", "ft", "it", "net", "z", "ast", "sn", "sth", "sts", "inst", "sc", "str", "cont"], "pb": ["td", "py", "ctx", "cmp", "typ", "bj", "pool", "gb", "ab", "cb", "fp", "pid", "emb", "uf", "pkg", "tg", "peer", "pr", "eb", "pm", "conv", "buff", "fb", "db", "wp", "cp", "gc", "pg", "tmp", "mt", "conf", "bb", "mb", "tp", "tab", "span", "pa", "txt", "resp", "rpm", "um", "pause", "asm", "wb", "cod", "proc", "req", "tk", "vp", "erb", "stab", "sb", "buf", "np", "lb", "rb", "bot", "snap", "lp", "cv", "PB", "pc", "amp", "vt", "tm", "ob", "jp", "p", "dp", "pt", "pp", "func", "vm", "gp", "mp", "nb", "bp", "pl"], "i": ["status", "index", "li", "iu", "mi", " j", "I", "pi", " iter", "ini", "ii", "ind", "p", " di", "ei", "ex", "si", "j", "zi", "ki", " count", " ti", "cli", " si", "g", "name", "bi", " pi", " pos", "ui", "di", "is", " index", " ii", " mi", "m", "in", "ai", " I", "hi", " my", "xi", "qi", " bi", "sim", "info", "im", "\u0438", " multi", "ci", "ims", " ni", "ti", "ri", " x", "u", "gi", " p", "it", "multi", " m", "me", "ji", " err", "x", "y", "ic", "ix", "ip"]}}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "static int rdma_add_block(RDMAContext *rdma, const char *block_name,\n\n                         void *host_addr,\n\n                         ram_addr_t block_offset, uint64_t length)\n\n{\n\n    RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n    RDMALocalBlock *block;\n\n    RDMALocalBlock *old = local->block;\n\n\n\n    local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));\n\n\n\n    if (local->nb_blocks) {\n\n        int x;\n\n\n\n        if (rdma->blockmap) {\n\n            for (x = 0; x < local->nb_blocks; x++) {\n\n                g_hash_table_remove(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset);\n\n                g_hash_table_insert(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset,\n\n                                    &local->block[x]);\n\n            }\n\n        }\n\n        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);\n\n        g_free(old);\n\n    }\n\n\n\n    block = &local->block[local->nb_blocks];\n\n\n\n    block->block_name = g_strdup(block_name);\n\n    block->local_host_addr = host_addr;\n\n    block->offset = block_offset;\n\n    block->length = length;\n\n    block->index = local->nb_blocks;\n\n    block->src_index = ~0U; /* Filled in by the receipt of the block list */\n\n    block->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL;\n\n    block->transit_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);\n\n    block->unregister_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);\n\n    block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));\n\n\n\n    block->is_ram_block = local->init ? false : true;\n\n\n\n    if (rdma->blockmap) {\n\n        g_hash_table_insert(rdma->blockmap, (void *) block_offset, block);\n\n    }\n\n\n\n    trace_rdma_add_block(block_name, local->nb_blocks,\n\n                         (uintptr_t) block->local_host_addr,\n\n                         block->offset, block->length,\n\n                         (uintptr_t) (block->local_host_addr + block->length),\n\n                         BITS_TO_LONGS(block->nb_chunks) *\n\n                             sizeof(unsigned long) * 8,\n\n                         block->nb_chunks);\n\n\n\n    local->nb_blocks++;\n\n\n\n    return 0;\n\n}\n", "idx": 12968, "substitutes": {"rdma": ["rdmar", "redma", "rda", "ddma", "ddmar", "rodama", "rtmm", "drmma", "rrm", "redpa", "rwmc", "rdmma", "drmo", "ridsm", "rodma", "rdama", "rtma", "rwma", "ardmm", "rtsm", "redmm", "rodda", "rdca", "rownama", "rwmac", "rrmac", "rdpa", "rwpa", "rtmar", "rmar", "rrmm", "rtca", "rrmon", "redmar", "rwmm", "rownca", "drmon", "rdmo", "rownmma", "ridma", "rrmo", "drma", "rdm", "ardsm", "drca", "rdmm", "rrma", "rtmc", "drm", "rnm", "rrmc", "rdmon", "rdmac", "ddama", "rodmar", "rama", "rtmma", "rnmon", "ridmm", "ddda", "ridmar", "rnma", "drama", "ridpa", "rdmc", "ardma", "rtama", "rdda", "ardmar", "rdsm", "rwmar", "rma", "rownma", "rtmac", "rnmo"], "block_name": ["blocklistName", "blocknamename", "blockernumber", "blocknameName", "iskityName", "blockername", "block_ref", "lock_ref", "isk_offset", "blockityoffset", "blockitydata", "block_number", "lock_name", "block_no", "blocknameoffset", "blockerno", "buffer_no", "iskitydata", "isk_name", "block_data", "block__number", "block__name", "block_ident", "lock_Name", "blockityname", "buffer_Name", "block__Name", "bufferernumber", "buffererName", "blocknamedata", "blocklistref", "iskityoffset", "block__no", "blocklistname", "lock_ident", "blocklistident", "buffererno", "blockerName", "buffer_number", "iskityname", "isk_data", "isk_Name", "buffer_name", "blockityName", "bufferername", "block_Name"], "host_addr": ["hostockaddr", "host2addr", "hostameoffset", "hostdloc", "hostockpos", "portdloc", "hostingid", "hostamenum", "server_addr", "hostwaddr", "hostenaddress", "port_loc", "hostwarch", "hostingaddress", "hostdoffset", "host_address", "hostenid", "portdoffset", "hostockaddress", "server_address", "port_addr", "host_loc", "hostingaddr", "host_add", "host_offset", " host_address", "host2add", "hostwpos", "hostenhash", "host_pos", " host_arch", "server_id", "hostenaddr", "port_num", "portdnum", "port_offset", "host_id", " host_pos", "host_hash", "host_arch", "host2address", "hostockarch", "server_hash", "portdaddr", "hostdaddr", "hostdnum", "server_add", "hostwaddress", "host_num", "hostameaddr", "hostinghash", "hostameloc"], "block_offset": ["block5name", "isk_pointer", "isk___address", "isk_offset", "lock_name", "isk___addr", "block___addr", "block___pointer", "block_address", "isk_addr", "isk___pointer", "isk___offset", "block_addr", "block___address", "block5delay", "block_pointer", "lock_addr", "isk_address", "block5addr", "block___offset", "lock_delay", "block5offset", "block_delay", "lock_offset"], "length": ["bytes", "Length", " Length", "index", "amount", "type", "frequency", "position", "size", "address", "l", "family", "SIZE", "sequence", "depth", "height", "load", "len", "padding", "end", "ENGTH", "offset", "lock", "message", "description", "ength", "pieces", "range", "available", "buffer", "count", "capacity", "location", " l", "limit", "enth", "h", " len", "duration", "total", "shape", "value", "history", "ob", "form"], "local": ["tx", "def", "instance", "public", "as", "global", "primary", " locally", "same", "data", "l", "installed", "ard", "present", "admin", "this", "raw", "where", "val", "el", "store", "localhost", "loc", "initial", "common", "cache", "Local", "lang", "specific", "al", "lock", "part", "parent", "current", "info", "pal", "self", "shared", "remote", "null", "single", "all", "one", "link", "base", "file", "standard", "location", "alpha", "table", "master", "active", "inner", "my", "private", "list", "valid", "state", "ion", "unique", "var", "ma", "small", "name", "save", "full", "external"], "block": ["bit", "ban", "scope", "window", "raw", "man", "check", "load", "field", "mix", "loop", "new", "command", "book", "lock", "line", "Block", "word", "art", "client", "label", "method", "zero", "pack", "def", "view", "error", "type", "number", "object", "address", "data", "map", "group", "module", "box", "bus", "part", "comment", "self", "inv", "link", "sync", "volume", "table", "device", "set", "join", "BL", "full", "ip", "node", "key", "record", "version", "out", "global", "row", "call", "batch", "unit", "bo", "snap", "buffer", "remote", "file", "single", "unknown", "plugin", "unique", "instance", "position", "session", "p", "chain", "model", "cache", "bin", "cl", "tag", "condition", "blocks", "none", "prefix", "bridge", "image", "base", "byte", "all", "no", "b", "bl", "point", "list", "piece", "value", "commit", "name"], "old": ["at", "lower", "and", "global", "orig", "hard", "told", "ref", "same", "ind", "l", "back", "ard", "p", "older", "other", "or", "row", "hold", "Old", "after", "reset", "low", "v", "existing", "user", "test", "used", "loc", "before", "fold", "olds", "common", "new", "lock", "al", "original", "last", "high", "off", "ld", "current", "null", "base", "all", "ul", "own", "tmp", "set", "inner", " orig", "pre", "var", "from", "small", "valid", "OLD"], "x": ["tx", "xt", "index", "key", "xes", "inx", " ax", "xxxx", "sw", "wx", "ax", "yx", "j", "xxx", "ross", "xxxxxxxx", "X", "v", "xs", "check", "xy", "batch", "ay", "t", "mix", "ox", "xp", "ext", "act", "fx", "ux", " tx", "exclusive", "step", "xi", " dx", " i", " cx", "dx", "xc", "lex", "xx", "upload", "any", "cross", "nex", " y", "px", "xf", "xa", "ey", "rx", "i", " xx", "ex", "w", "y", "ix", "mx"], "nb_blocks": ["nb_headers", "NR_block", "nw_objects", "unique_items", "nbBLblocks", "nbBLitems", "nb_orders", "nb___frames", "uniqueBLchecks", "NR_blocks", "uniqueBLitems", "np_orders", "nb_items", "ni__classes", "ni_items", "ni_locks", "nb__items", "nw_headers", "nb_locks", "nb_checks", "nw_frames", "nb__locks", "ni_blocks", "nb__images", "nb_block", "nb_objects", "ni__items", "unique_times", "uniqueBLblocks", "np_blocks", "nb__blocks", "ni__blocks", "nb_images", "nb___orders", "NR_objects", "num_events", "nb___images", "nbBLtimes", "nw_blocks", "nb__frames", "unique_blocks", "np_images", "ni_classes", "uniqueBLtimes", "nb__classes", "num_frames", "nbBLchecks", "unique_checks", "ni__locks", "num_blocks", "nb___blocks", "NR_plugins", "np_frames", "num_images", "nb___events", "nb_classes", "nb_events", "nb__events", "nb_plugins", "nb_times", "nb_frames"]}}
{"project": "qemu", "commit_id": "65f82df0d7a71ce1b10cd4c5ab08888d176ac840", "target": 1, "func": "process_tx_desc(E1000State *s, struct e1000_tx_desc *dp)\n\n{\n\n    uint32_t txd_lower = le32_to_cpu(dp->lower.data);\n\n    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);\n\n    unsigned int split_size = txd_lower & 0xffff, bytes, sz, op;\n\n    unsigned int msh = 0xfffff, hdr = 0;\n\n    uint64_t addr;\n\n    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;\n\n    struct e1000_tx *tp = &s->tx;\n\n\n\n    if (dtype == E1000_TXD_CMD_DEXT) {\t// context descriptor\n\n        op = le32_to_cpu(xp->cmd_and_length);\n\n        tp->ipcss = xp->lower_setup.ip_fields.ipcss;\n\n        tp->ipcso = xp->lower_setup.ip_fields.ipcso;\n\n        tp->ipcse = le16_to_cpu(xp->lower_setup.ip_fields.ipcse);\n\n        tp->tucss = xp->upper_setup.tcp_fields.tucss;\n\n        tp->tucso = xp->upper_setup.tcp_fields.tucso;\n\n        tp->tucse = le16_to_cpu(xp->upper_setup.tcp_fields.tucse);\n\n        tp->paylen = op & 0xfffff;\n\n        tp->hdr_len = xp->tcp_seg_setup.fields.hdr_len;\n\n        tp->mss = le16_to_cpu(xp->tcp_seg_setup.fields.mss);\n\n        tp->ip = (op & E1000_TXD_CMD_IP) ? 1 : 0;\n\n        tp->tcp = (op & E1000_TXD_CMD_TCP) ? 1 : 0;\n\n        tp->tse = (op & E1000_TXD_CMD_TSE) ? 1 : 0;\n\n        tp->tso_frames = 0;\n\n        if (tp->tucso == 0) {\t// this is probably wrong\n\n            DBGOUT(TXSUM, \"TCP/UDP: cso 0!\\n\");\n\n            tp->tucso = tp->tucss + (tp->tcp ? 16 : 6);\n\n        }\n\n        return;\n\n    } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) {\n\n        // data descriptor\n\n        if (tp->size == 0) {\n\n            tp->sum_needed = le32_to_cpu(dp->upper.data) >> 8;\n\n        }\n\n        tp->cptse = ( txd_lower & E1000_TXD_CMD_TSE ) ? 1 : 0;\n\n    } else {\n\n        // legacy descriptor\n\n        tp->cptse = 0;\n\n    }\n\n\n\n    if (vlan_enabled(s) && is_vlan_txd(txd_lower) &&\n\n        (tp->cptse || txd_lower & E1000_TXD_CMD_EOP)) {\n\n        tp->vlan_needed = 1;\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header),\n\n                      le16_to_cpup((uint16_t *)(s->mac_reg + VET)));\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header + 2),\n\n                      le16_to_cpu(dp->upper.fields.special));\n\n    }\n\n        \n\n    addr = le64_to_cpu(dp->buffer_addr);\n\n    if (tp->tse && tp->cptse) {\n\n        hdr = tp->hdr_len;\n\n        msh = hdr + tp->mss;\n\n        do {\n\n            bytes = split_size;\n\n            if (tp->size + bytes > msh)\n\n                bytes = msh - tp->size;\n\n\n\n            bytes = MIN(sizeof(tp->data) - tp->size, bytes);\n\n            pci_dma_read(&s->dev, addr, tp->data + tp->size, bytes);\n\n            if ((sz = tp->size + bytes) >= hdr && tp->size < hdr)\n\n                memmove(tp->header, tp->data, hdr);\n\n            tp->size = sz;\n\n            addr += bytes;\n\n            if (sz == msh) {\n\n                xmit_seg(s);\n\n                memmove(tp->data, tp->header, hdr);\n\n                tp->size = hdr;\n\n            }\n\n        } while (split_size -= bytes);\n\n    } else if (!tp->tse && tp->cptse) {\n\n        // context descriptor TSE is not set, while data descriptor TSE is set\n\n        DBGOUT(TXERR, \"TCP segmentaion Error\\n\");\n\n    } else {\n\n\n        pci_dma_read(&s->dev, addr, tp->data + tp->size, split_size);\n\n        tp->size += split_size;\n\n    }\n\n\n\n    if (!(txd_lower & E1000_TXD_CMD_EOP))\n\n        return;\n\n    if (!(tp->tse && tp->cptse && tp->size < hdr))\n\n        xmit_seg(s);\n\n    tp->tso_frames = 0;\n\n    tp->sum_needed = 0;\n\n    tp->vlan_needed = 0;\n\n    tp->size = 0;\n\n    tp->cptse = 0;\n\n}", "idx": 12984, "substitutes": {"bytes": ["types", "gs", "units", "bs", "flags", "bits", "keys", "rows", "xs", "words", "eps", "pages", "frames", "ds", "times", "blocks", "items", "ips", "vs", "seconds", "ns", "ims", "bps", "ows", "its", "reads", "files", "ms"], "sz": [" sq", "dsq", " szi", "xsz", "dsz", "xsq", "dsld", "xszi", " sld", "xsld", "szi", "sld", "dszi", "sq"], "op": ["bit", "jp", " OP", "error", "Op", "deep", "sw", "oc", "o", "out", "push", "attr", "cmd", "ok", "pop", "p", "cmp", "dr", "operator", "opt", "typ", "oop", "perm", "oper", "pixel", "osp", "batch", "pp", "feature", "cop", "offset", "num", "omp", "lit", "operation", " Op", "obj", "hop", "info", "empty", "sp", "tf", "block", "opp", "pos", "rot", "top", "ap", "comp", "cp", "ops", "post", "mp", "OP", "ot", "app", "it", "arg", "ps", "init", "OPER", "ob", "ip"], "addr": ["ptr", "ref", "src", "asm", "address", "class", "ord", "aud", "ctr", "added", "align", "oad", "alt", "obj", "add", "arch", "link", "code", "res", "ack", "order", "rel", "hash", " address", "dh", "alloc", "Address", "arp"], "xp": ["tx", "jp", "rpm", "ipp", "inx", "ept", "wx", "isp", "ctx", "expr", "hw", "apa", "mph", "xd", "vp", "xs", "eps", "dp", "orp", "xy", "pp", "nz", "fx", "xff", "omp", "yp", "xon", "xi", "imp", "pps", "lp", "fp", "xc", "wp", "cp", "lex", "gp", "xe", "bps", "wordpress", "elt", "px", "xf", "wy", "yk", "bp", "fps", "esp", "pkg", "XP", "xt", "txt", "hp"], "tp": ["td", "tt", "cmp", "typ", "port", "t", "tch", "fp", "top", "ht", "transfer", "ta", "pkg", "exec", "hp", "ps", "def", "tg", "peer", "ptr", "tl", "cmd", "conv", "dt", "TP", "orp", "prot", "phy", "ipt", "wp", "cp", "xe", "tmp", "mt", "tar", "tip", "elt", "txt", "at", "vp", "tk", "gt", "lp", "apt", "pc", "ot", "tm", "dat", "tap", "iat", "arp", "jp", "pb", "p", "tif", "pot", "dp", "pt", "pp", "wt", "tn", "rt", "ts", "tf", "ssh", "gp", "bl", "_", "pas", "bp"]}}
{"project": "qemu", "commit_id": "9a4c0e220d8a4f82b5665d0ee95ef94d8e1509d5", "target": 0, "func": "static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)\n\n{\n\n    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);\n\n    DeviceState *vdev = DEVICE(&vinput->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));\n\n    /* force virtio-1.0 */\n\n    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;\n\n    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;\n\n    object_property_set_bool(OBJECT(vdev), true, \"realized\", errp);\n\n}\n", "idx": 13001, "substitutes": {"vpci_dev": ["vpci_priv", "vpce_dev", "vpci___ev", "vpiti_Dev", "vpci_def", "vpci__dev", "vppc___desc", "vpci42Dev", "vpci__Dev", "vpci___serv", "vpce_Dev", "vpci_serv", "vpcit_priv", "vpiti_dev", "vppc_ev", "vppc___device", "vpiti42dev", "vpci_device", "vpce_bus", "vppc___ev", "vpci_Dev", "vpio_serv", "vpio_dev", "vpci__def", "vpiti42def", "vpiti42desc", "vpiti_desc", "vpci_loc", "vpcit_loc", "vpci__desc", "vpci___device", "vpcit_dev", "vppc___dev", "vpci42def", "vppc_dev", "vpci42dev", "vpci___dev", "vpiti42Dev", "vpio_device", "vppc_device", "vpci___desc", "vpce_device", "vppc_desc", "vpiti_def", "vpci42desc", "vpci_desc", "vpci_ev", "vpci_bus"], "errp": [" Errp", " Errps", "errps", "errpat", "warnpa", "derpat", " Errpat", "derps", " Errpp", " errpa", " errps", " errP", "errP", "warnP", "erps", "derp", "erpa", "warnp", "erP", " errpp", "warnps", " errpat", "erp", "derpp", "errpp", "errpa"], "vinput": ["vonput", "cinPut", "vonstall", "vinPut", "vystall", "tinPut", "tinput", "tinputer", "vycut", "pinputer", "voncut", "cinput", "vyput", "evincut", "evinput", "vinstall", "vinputer", "evinstall", "pinPut", "pinput", "vincut", "cinputer"], "vdev": ["mptr", "lvdev", " vdiv", "mver", "ddata", " vprop", "mde", " vev", "svdev", "Vdev", " vdevice", "svdata", " vdata", "ddiv", "mdevice", "vde", "mev", " vver", "pver", "lvdevice", " vde", "lvde", "vver", " vDev", "vdevice", "vdiv", "vev", "Vev", "Vdevice", "dev", "vdata", "pdevice", "mDev", "vDev", "mdev", "pdev", "pDev", " vptr", "svev", "vprop", "svdiv", "vptr", "mprop", "ddev", "lvptr", "Vprop"]}}
{"project": "qemu", "commit_id": "3f66f764ee25f10d3e1144ebc057a949421b7728", "target": 0, "func": "static void test_visitor_out_string(TestOutputVisitorData *data,\n\n                                    const void *unused)\n\n{\n\n    char *string = (char *) \"Q E M U\";\n\n    Error *err = NULL;\n\n    QObject *obj;\n\n\n\n    visit_type_str(data->ov, &string, NULL, &err);\n\n    g_assert(!err);\n\n\n\n    obj = qmp_output_get_qobject(data->qov);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QSTRING);\n\n    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);\n\n\n\n    qobject_decref(obj);\n\n}\n", "idx": 13002, "substitutes": {"data": ["def", "route", "o", "out", "output", "query", "dal", "aw", "map", "mode", "grad", "window", "call", "pattern", "check", "batch", "di", "command", "ds", "da", "dump", "message", "att", "step", "none", "accept", "info", "mu", "open", "image", "Data", "debug", "device", "table", "dev", "ad", "defined", "d", "DATA", "format", "ata", "dat", "zero", "join", "valid"], "unused": ["UNavailable", "sunuse", "unchecked", " unchecked", " unuse", "sunavailable", "UNused", " unavailable", "sunchecked", "sunused", "UNchecked", "unavailable", "UNuse", "unuse"], "err": ["resp", "errors", "error", "cr", "ptr", "out", "exc", "usr", "attr", "cmd", "expr", "n", "erd", "req", "proc", "v", "rr", "er", "msg", "buf", "result", "rank", "sys", "Error", "kr", "r", "rev", "null", "ec", "gr", "oe", "res", "die", "Er", "dev", "fr", "e", "conf", "iter", "ev", "coll", "ex", "str", "txt", "ch", "arr"], "obj": ["bs", "orig", "onet", "attr", "ist", "ctx", "hw", "expr", "opt", "typ", "bj", "t", "nt", "od", "po", "ht", "it", "pkg", "cont", "arr", "obs", "object", "pr", "j", "cmd", "js", "v", "buff", "og", "rect", "oa", "null", "res", "tmp", "ole", "elt", "stick", "ex", "txt", "resp", "vo", "impl", "oc", "ref", "out", "src", "cod", "bh", "tk", "obo", "bo", "buf", "np", "json", "org", "ot", "str", "ob", "instance", "o", "p", "vr", "ent", "Obj", "pt", "xy", "act", "none", "opp", "oj", "oid", "rel", "inst", "adj"]}}
{"project": "qemu", "commit_id": "d1048bef9df0aacde9a54bf9b5b97a6e10950d8c", "target": 0, "func": "static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    pcms->vmport = value;\n\n}\n", "idx": 13012, "substitutes": {"obj": ["obs", "o", "ref", "object", "onet", "attr", "ist", "cmd", "ctx", "hw", "js", "cmp", "bh", "typ", "xy", "Obj", "obo", "bo", "act", "nt", "og", "ie", "att", "org", "iso", "ck", "txt", "po", "tmp", "ot", "elt", "objects", "pkg", "inst", "cont", "gov", "ob"], "value": ["node", "status", "key", "type", "local", "position", "values", "p", "present", "vp", "val", "v", "widget", "rule", "enabled", "bo", "feature", "VALUE", "show", "Value", "update", "rue", "ue", "current", "comment", "work", "open", "block", "file", "create", "function", "property", "apache", "b", "unknown", "label", "set", "state", "w", "valid"], "errp": ["rrsp", "erP", " errr", " errsp", "err", "rrr", "erp", "errsp", " errP", "rrp", "errr", "rrP", "ersp", "errP"], "pcms": ["pcm", "cpmes", "vcmes", " pcoms", "cpms", "pnoms", "cpmx", " pcmes", "vcmers", "vcoms", "pnms", "pnmers", " pcmers", "cpm", "vcms", "pxm", "pnmes", "pxmx", "pcoms", "pcmes", " pcmx", "pcmers", "pcmx", "pxms", " pcm", "pxmes"]}}
{"project": "FFmpeg", "commit_id": "5763f675024765df8f256d8b5b01926a5fbd997d", "target": 1, "func": "static int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    int ret;\n\n\n\n    st = avformat_new_stream(c->fc, NULL);\n\n    if (!st) return AVERROR(ENOMEM);\n\n    st->id = c->fc->nb_streams;\n\n    sc = av_mallocz(sizeof(MOVStreamContext));\n\n    if (!sc) return AVERROR(ENOMEM);\n\n\n\n    st->priv_data = sc;\n\n    st->codec->codec_type = AVMEDIA_TYPE_DATA;\n\n    sc->ffindex = st->index;\n\n\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n\n        return ret;\n\n\n\n    /* sanity checks */\n\n    if (sc->chunk_count && (!sc->stts_count || !sc->stsc_count ||\n\n                            (!sc->sample_size && !sc->sample_count))) {\n\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n\n               st->index);\n\n        return 0;\n\n    }\n\n\n\n    fix_timescale(c, sc);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, sc->time_scale);\n\n\n\n    mov_build_index(c, st);\n\n\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n\n        MOVDref *dref = &sc->drefs[sc->dref_id - 1];\n\n        if (mov_open_dref(&sc->pb, c->fc->filename, dref, &c->fc->interrupt_callback,\n\n            c->use_absolute_path, c->fc) < 0)\n\n            av_log(c->fc, AV_LOG_ERROR,\n\n                   \"stream %d, error opening alias: path='%s', dir='%s', \"\n\n                   \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\\n\",\n\n                   st->index, dref->path, dref->dir, dref->filename,\n\n                   dref->volume, dref->nlvl_from, dref->nlvl_to);\n\n    } else {\n\n        sc->pb = c->fc->pb;\n\n        sc->pb_is_copied = 1;\n\n    }\n\n\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if (!st->sample_aspect_ratio.num &&\n\n            (st->codec->width != sc->width || st->codec->height != sc->height)) {\n\n            st->sample_aspect_ratio = av_d2q(((double)st->codec->height * sc->width) /\n\n                                             ((double)st->codec->width * sc->height), INT_MAX);\n\n        }\n\n\n\n#if FF_API_R_FRAME_RATE\n\n        if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))\n\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,\n\n                      sc->time_scale, sc->stts_data[0].duration, INT_MAX);\n\n#endif\n\n    }\n\n\n\n    // done for ai5q, ai52, ai55, ai1q, ai12 and ai15.\n\n    if (!st->codec->extradata_size && st->codec->codec_id == AV_CODEC_ID_H264 &&\n\n        TAG_IS_AVCI(st->codec->codec_tag)) {\n\n        ret = ff_generate_avci_extradata(st);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    switch (st->codec->codec_id) {\n\n#if CONFIG_H261_DECODER\n\n    case AV_CODEC_ID_H261:\n\n#endif\n\n#if CONFIG_H263_DECODER\n\n    case AV_CODEC_ID_H263:\n\n#endif\n\n#if CONFIG_MPEG4_DECODER\n\n    case AV_CODEC_ID_MPEG4:\n\n#endif\n\n        st->codec->width = 0; /* let decoder init width/height */\n\n        st->codec->height= 0;\n\n        break;\n\n    }\n\n\n\n    /* Do not need those anymore. */\n\n    av_freep(&sc->chunk_offsets);\n\n    av_freep(&sc->stsc_data);\n\n    av_freep(&sc->sample_sizes);\n\n    av_freep(&sc->keyframes);\n\n    av_freep(&sc->stts_data);\n\n    av_freep(&sc->stps_data);\n\n    av_freep(&sc->elst_data);\n\n    av_freep(&sc->rap_group);\n\n\n\n    return 0;\n\n}\n", "idx": 13024, "substitutes": {"c": ["cor", "rc", "ce", "cu", "cf", "co", "tc", "f", "oc", "cr", "cm", "unc", "ca", "cur", "cn", "lc", "l", "ctx", "p", "cmp", "call", "cc", "cd", "v", "chain", "g", "t", "ic", "cache", "dc", "com", "icc", "ct", "cl", "m", "k", "uc", "ac", "C", "cb", "xc", "nc", "abc", "ci", "ec", "cp", "b", "mc", "cs", "bc", "etc", "pc", "fc", "rec", "con", "conf", "enc", "config", "vc", "arc", "cont", "anc", "can"], "pb": ["pro", "jp", "td", "tc", "py", "bs", "ref", "ctx", "p", "wb", "apa", "eb", "typ", "tk", "bj", "vp", "stab", "dp", "pool", "pp", "sb", "lb", "np", "rb", "ab", "ub", "fb", "plan", "sp", "cb", "lp", "fp", "cv", "PB", "db", "bf", "pac", "wp", "ap", "cp", "b", "tab", "bc", "pg", "soc", "pc", "fc", "mp", "repl", "bps", "emb", "nb", "uf", "mb", "bp", "pkg", "pl", "vt", "tp", "pa", "ob"], "atom": ["orm", "at", "f", "um", "o", "OM", "oms", "asm", "attr", " cmd", "cmd", "p", "or", "raw", " orb", "typ", "name", "ar", "ym", "msg", "com", "item", "op", "al", " symb", "m", "mol", " canon", "om", "base", " exc", "b", "mat", "tmp", "tar", "ot", "from", "to", "ata", "orb", "tm", "nm", "x", "xml", "y", "ch"], "st": ["ste", "stable", "td", "est", "sw", "et", "src", "usr", "sta", "St", "ST", "ist", "tt", "kt", "stat", "ut", "stab", "sl", "pt", "store", "stra", "nd", "t", "stop", "sv", "ct", "nt", "cl", "irst", "rest", "th", "obj", "rt", "so", "ts", "ost", "sp", "ust", "std", "sh", "must", "start", "set", "mt", "ft", "se", "stan", "ast", "sn", "sth", "ss", "inst", "str", "sts"], "sc": ["isc", "rc", "cu", "ctl", "co", "cr", "SC", "tc", "sw", "sac", "lc", "sh", "ctx", "scope", " subsc", "cc", "psc", "capt", "cer", "esc", "sv", "sec", "dc", "sb", "sch", "scan", "cl", "cam", "desc", "usc", "uc", "ac", "irc", "sp", "cv", "decl", "Sc", "nc", "ec", "sche", "must", "ci", "sync", "gc", "cons", "mc", "cs", "bc", "soc", "osc", "pc", "fc", "cgi", "sub", "enc", "scrib", "zero", "scl", "ss", "sic", "esp", "exec", "anc", "asc", "ka", "sci"], "ret": ["resp", "status", "rem", "def", "mem", "out", "ref", " alt", "inter", "det", "ll", "j", "back", "ral", "Ret", "tr", "rets", "RET", "val", "reset", "not", "reg", "try", "t", "ez", "len", "rm", "result", "ben", "nz", "nt", "r", "alt", "gt", "ern", "rt", "mel", "tf", "no", "res", "print", "ber", "re", "mt", "ft", "it", "fit", " Ret", "value", "zero"], "dref": ["fmem", "didref", "dareference", "nRef", "drel", "def", "dbref", "Def", "datchange", "dreference", "fRef", "dbRef", "didRef", "drep", "didaddr", "drRef", "datreference", "fterm", " dmem", "didreference", "daref", "dalf", "didchange", " dterm", "dataref", "didmem", "datareference", "nalf", "nrel", "Dref", "Dreference", "freference", " drel", "dchange", "drref", "bdreference", " def", "drev", "dbalf", "daRef", "faddr", " dalf", "nref", " dRef", "pRef", "Drep", "frep", "frev", "dataddr", "drreference", "bdref", "dterm", "dRef", "dmem", "datref", "preference", "dataef", "fref", "fchange", " drev", " dreference", "dbrel", "pref", "daddr", "drrep", "dataRef", "darev", "bdterm", "DRef", "bdRef"]}}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static int buffer_empty(Buffer *buffer)\n\n{\n\n    return buffer->offset == 0;\n\n}\n", "idx": 13031, "substitutes": {"buffer": ["bar", "index", "view", "face", "f", "display", "output", "out", "header", "address", "data", "map", "window", "Buffer", "text", "batch", "cache", "buff", "buf", "command", "line", "channel", "message", "comment", "bridge", "empty", "block", "db", "file", "page", "byte", "board", "null", "b", "bc", "input", "bb", "queue", "interface"]}}
{"project": "qemu", "commit_id": "b0d768c35e08d2057b63e8e77e7a513c447199fa", "target": 1, "func": "static gboolean pty_chr_timer(gpointer opaque)\n\n{\n\n    struct CharDriverState *chr = opaque;\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (s->connected) {\n\n        goto out;\n\n    }\n\n\n\n    /* Next poll ... */\n\n    pty_chr_update_read_handler(chr);\n\n\n\nout:\n\n    s->timer_tag = 0;\n\n    return FALSE;\n\n}\n", "idx": 13035, "substitutes": {"opaque": ["obeno", "obient", "opient", " opaques", "iopaque", "obque", "opacity", "popaque", "Opaques", "Opaque", "OPaques", "opaques", "iopient", "obacity", "Opacity", "oplation", "OPlation", "obaque", "Openo", "openo", "popeno", "Opque", "popient", "iopeno", "Oplation", "iopque", "opque", "OPaque", "popacity", " oplation", "iopacity"], "chr": ["echrs", "chorb", "echR", "Chrs", " chrs", "cher", " chR", "cherb", " chrb", "Chrb", "Chrl", "Chr", "Chre", "chR", "chrb", "echr", " chrl", "ChR", "Char", "choar", "chor", "chere", "chrs", "chrl", " chre", "chre", "chorl", "echrb", "chear"], "s": ["sis", "gs", "a", "S", "bs", "socket", "less", "ys", "j", "p", "js", "n", "sq", "v", "g", "t", "is", "sv", "sb", "als", "sys", "ds", "ats", "ls", "m", "ies", "ssl", "qs", "so", "ts", "self", "c", "stats", "ins", "ns", "b", "cs", "h", "set", "fs", "os", "ss", "sts", "rs", "ps"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void h263_encode_init(MpegEncContext *s)\n\n{\n\n    static int done = 0;\n\n\n\n    if (!done) {\n\n        done = 1;\n\n\n\n        init_uni_dc_tab();\n\n\n\n        init_rl(&rl_inter);\n\n        init_rl(&rl_intra);\n\n        init_rl(&rl_intra_aic);\n\n        \n\n        init_uni_mpeg4_rl_tab(&rl_intra, uni_mpeg4_intra_rl_bits, uni_mpeg4_intra_rl_len);\n\n        init_uni_mpeg4_rl_tab(&rl_inter, uni_mpeg4_inter_rl_bits, uni_mpeg4_inter_rl_len);\n\n\n\n        init_uni_h263_rl_tab(&rl_intra_aic, NULL, uni_h263_intra_aic_rl_len);\n\n        init_uni_h263_rl_tab(&rl_inter    , NULL, uni_h263_inter_rl_len);\n\n\n\n        init_mv_penalty_and_fcode(s);\n\n    }\n\n    s->me.mv_penalty= mv_penalty; //FIXME exact table for msmpeg4 & h263p\n\n    \n\n    s->intra_ac_vlc_length     =s->inter_ac_vlc_length     = uni_h263_inter_rl_len;\n\n    s->intra_ac_vlc_last_length=s->inter_ac_vlc_last_length= uni_h263_inter_rl_len + 128*64;\n\n    if(s->h263_aic){\n\n        s->intra_ac_vlc_length     = uni_h263_intra_aic_rl_len;\n\n        s->intra_ac_vlc_last_length= uni_h263_intra_aic_rl_len + 128*64;\n\n    }\n\n    s->ac_esc_length= 7+1+6+8;\n\n\n\n    // use fcodes >1 only for mpeg4 & h263 & h263p FIXME\n\n    switch(s->codec_id){\n\n    case CODEC_ID_MPEG4:\n\n        s->fcode_tab= fcode_tab;\n\n        s->min_qcoeff= -2048;\n\n        s->max_qcoeff=  2047;\n\n        s->intra_ac_vlc_length     = uni_mpeg4_intra_rl_len;\n\n        s->intra_ac_vlc_last_length= uni_mpeg4_intra_rl_len + 128*64;\n\n        s->inter_ac_vlc_length     = uni_mpeg4_inter_rl_len;\n\n        s->inter_ac_vlc_last_length= uni_mpeg4_inter_rl_len + 128*64;\n\n        s->luma_dc_vlc_length= uni_DCtab_lum_len;\n\n        s->chroma_dc_vlc_length= uni_DCtab_chrom_len;\n\n        s->ac_esc_length= 7+2+1+6+1+12+1;\n\n        s->y_dc_scale_table= ff_mpeg4_y_dc_scale_table;\n\n        s->c_dc_scale_table= ff_mpeg4_c_dc_scale_table;\n\n\n\n        if(s->flags & CODEC_FLAG_GLOBAL_HEADER){\n\n\n\n            s->avctx->extradata= av_malloc(1024);\n\n            init_put_bits(&s->pb, s->avctx->extradata, 1024);\n\n            \n\n            mpeg4_encode_visual_object_header(s);\n\n            mpeg4_encode_vol_header(s, 0, 0);\n\n\n\n//            ff_mpeg4_stuffing(&s->pb); ?\n\n            flush_put_bits(&s->pb);\n\n            s->avctx->extradata_size= (put_bits_count(&s->pb)+7)>>3;\n\n        }\n\n        \n\n        break;\n\n    case CODEC_ID_H263P:\n\n        if(s->umvplus)\n\n            s->fcode_tab= umv_fcode_tab;\n\n        if(s->modified_quant){\n\n            s->min_qcoeff= -2047;\n\n            s->max_qcoeff=  2047;\n\n        }else{\n\n            s->min_qcoeff= -127;\n\n            s->max_qcoeff=  127;\n\n        }\n\n        break;\n\n        //Note for mpeg4 & h263 the dc-scale table will be set per frame as needed later \n\n    case CODEC_ID_FLV1:\n\n        if (s->h263_flv > 1) {\n\n            s->min_qcoeff= -1023;\n\n            s->max_qcoeff=  1023;\n\n        } else {\n\n            s->min_qcoeff= -127;\n\n            s->max_qcoeff=  127;\n\n        }\n\n        s->y_dc_scale_table=\n\n        s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n\n        break;\n\n    default: //nothing needed default table allready set in mpegvideo.c\n\n        s->min_qcoeff= -127;\n\n        s->max_qcoeff=  127;\n\n        s->y_dc_scale_table=\n\n        s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n\n    }\n\n}\n", "idx": 13040, "substitutes": {"s": ["ses", "gs", "S", "bs", "ports", "sq", "ags", "t", "m", "eds", "qs", "ads", "stats", "vs", "states", "cs", "tests", "ims", "pers", "tes", "sg", "its", "terms", "ps", "des", "js", "g", "ds", "ats", "services", "ies", "parts", "ers", "i", "results", "a", "less", "eps", "als", "sb", "hs", "sys", "in", "c", "ops", "es", "changes", "fs", "bis", "se", "views", "sports", "ss", "comments", "aws", "p", "ges", "details", "bes", "is", "sv", "ls", "ches", "mods", "gets", "ts", "ins", "ns", "b", "h", "os", "styles", "sets", "sts", "w", "ms", "rs"]}}
{"project": "qemu", "commit_id": "fdfab37dfeffefbd4533b4158055c9b82d7c3e69", "target": 0, "func": "static int check_oflag_copied(BlockDriverState *bs, BdrvCheckResult *res,\n\n                              BdrvCheckMode fix)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t *l2_table = qemu_blockalign(bs, s->cluster_size);\n\n    int ret;\n\n    uint64_t refcount;\n\n    int i, j;\n\n\n\n    for (i = 0; i < s->l1_size; i++) {\n\n        uint64_t l1_entry = s->l1_table[i];\n\n        uint64_t l2_offset = l1_entry & L1E_OFFSET_MASK;\n\n        bool l2_dirty = false;\n\n\n\n        if (!l2_offset) {\n\n            continue;\n\n        }\n\n\n\n        ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,\n\n                                 &refcount);\n\n        if (ret < 0) {\n\n            /* don't print message nor increment check_errors */\n\n            continue;\n\n        }\n\n        if ((refcount == 1) != ((l1_entry & QCOW_OFLAG_COPIED) != 0)) {\n\n            fprintf(stderr, \"%s OFLAG_COPIED L2 cluster: l1_index=%d \"\n\n                    \"l1_entry=%\" PRIx64 \" refcount=%\" PRIu64 \"\\n\",\n\n                    fix & BDRV_FIX_ERRORS ? \"Repairing\" :\n\n                                            \"ERROR\",\n\n                    i, l1_entry, refcount);\n\n            if (fix & BDRV_FIX_ERRORS) {\n\n                s->l1_table[i] = refcount == 1\n\n                               ? l1_entry |  QCOW_OFLAG_COPIED\n\n                               : l1_entry & ~QCOW_OFLAG_COPIED;\n\n                ret = qcow2_write_l1_entry(bs, i);\n\n                if (ret < 0) {\n\n                    res->check_errors++;\n\n                    goto fail;\n\n                }\n\n                res->corruptions_fixed++;\n\n            } else {\n\n                res->corruptions++;\n\n            }\n\n        }\n\n\n\n        ret = bdrv_pread(bs->file, l2_offset, l2_table,\n\n                         s->l2_size * sizeof(uint64_t));\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR: Could not read L2 table: %s\\n\",\n\n                    strerror(-ret));\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n\n\n        for (j = 0; j < s->l2_size; j++) {\n\n            uint64_t l2_entry = be64_to_cpu(l2_table[j]);\n\n            uint64_t data_offset = l2_entry & L2E_OFFSET_MASK;\n\n            QCow2ClusterType cluster_type = qcow2_get_cluster_type(l2_entry);\n\n\n\n            if ((cluster_type == QCOW2_CLUSTER_NORMAL) ||\n\n                ((cluster_type == QCOW2_CLUSTER_ZERO) && (data_offset != 0))) {\n\n                ret = qcow2_get_refcount(bs,\n\n                                         data_offset >> s->cluster_bits,\n\n                                         &refcount);\n\n                if (ret < 0) {\n\n                    /* don't print message nor increment check_errors */\n\n                    continue;\n\n                }\n\n                if ((refcount == 1) != ((l2_entry & QCOW_OFLAG_COPIED) != 0)) {\n\n                    fprintf(stderr, \"%s OFLAG_COPIED data cluster: \"\n\n                            \"l2_entry=%\" PRIx64 \" refcount=%\" PRIu64 \"\\n\",\n\n                            fix & BDRV_FIX_ERRORS ? \"Repairing\" :\n\n                                                    \"ERROR\",\n\n                            l2_entry, refcount);\n\n                    if (fix & BDRV_FIX_ERRORS) {\n\n                        l2_table[j] = cpu_to_be64(refcount == 1\n\n                                    ? l2_entry |  QCOW_OFLAG_COPIED\n\n                                    : l2_entry & ~QCOW_OFLAG_COPIED);\n\n                        l2_dirty = true;\n\n                        res->corruptions_fixed++;\n\n                    } else {\n\n                        res->corruptions++;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        if (l2_dirty) {\n\n            ret = qcow2_pre_write_overlap_check(bs, QCOW2_OL_ACTIVE_L2,\n\n                                                l2_offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"ERROR: Could not write L2 table; metadata \"\n\n                        \"overlap check failed: %s\\n\", strerror(-ret));\n\n                res->check_errors++;\n\n                goto fail;\n\n            }\n\n\n\n            ret = bdrv_pwrite(bs->file, l2_offset, l2_table,\n\n                              s->cluster_size);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"ERROR: Could not write L2 table: %s\\n\",\n\n                        strerror(-ret));\n\n                res->check_errors++;\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_vfree(l2_table);\n\n    return ret;\n\n}\n", "idx": 13050, "substitutes": {"bs": ["ses", "aws", "ashes", "gs", "ubis", "ubs", "aos", "obs", "outs", "hz", "js", "bits", "bh", "bi", "bes", "als", "sb", "aus", "hs", "sys", "ds", "ls", "BS", "ts", "bos", "bm", "boxes", "bas", "blog", "vs", "ns", "bl", "cs", "bc", "lbs", "b", "fs", "bps", "locks", "os", "bis", "its", "bb", "bp", "ss", "sts", "ms", "rs", "ps"], "res": ["resp", "vol", "rem", "ress", "rc", "def", "des", "rss", "usr", "windows", "pr", "pres", "response", "RES", "expr", "scope", "req", "resource", "reset", "reg", "details", "sol", "wcs", "result", "sys", "rest", "r", "aux", "vals", "rev", "resolution", "sim", "ins", "progress", "rys", "results", "ro", "rek", "gr", "cons", "ns", "red", "ber", "Res", "re", "ack", "der", "cs", "rel", "err", "pas", "rez", "history", "news", "resources", "ms", "rr", "terms", "rs", "resh", "sum", "ps"], "fix": ["tx", "bit", "def", " fixing", "gem", "patch", "bug", " diff", "edit", "mask", " edit", "call", "raw", "fail", " update", "check", "issue", " patch", "mix", " pos", "diff", "bin", " pack", "fixes", "fx", "get", "update", " def", "add", "prefix", "use", "block", " exec", "db", "dot", "make", "xx", " Fix", "set", "FIX", "conf", "clear", "Fix", "err", " repair", " err", "commit", "init", " prefix", "ix", "pack"], "s": ["ses", "aws", "gs", "S", "as", "less", "ports", "p", "js", "series", "bits", "sq", "eps", "xs", "sl", "details", "http", "bes", "comm", "is", "sv", "sb", "als", "spec", "hs", "sys", "ds", "ats", "ls", "ess", "services", "ssl", "qs", "ts", "sp", "c", "stats", "vs", "ins", "b", "ns", "cs", "ops", "h", "ims", "args", "es", "fs", "bis", "its", "parts", "sn", "ss", "sts", "ms", "https", "rs", "ps"], "l2_table": ["l2__entry", "l2_entry", "l2__cache", "l3_entry", "l1_tab", "l2__tab", "l2_offset", "l3_table", "l1_entry", "l2_tree", "l2acoffset", "l2_cache", "l2actable", "l3_tree", "l2_tab", "l1_cache", "l2acentry", "l2__table", "l3_offset", "l1_table", "l2actree"], "ret": ["et", "pret", "fun", "back", "expr", "val", "t", "len", "result", "nt", "att", "rev", "Return", "cb", "backed", "modified", "it", "net", " Ret", "del", "usr", "cont", "arr", "rem", "def", "ptr", "ll", "addr", "cmd", "tr", "RET", "reset", "dt", "try", "cat", "print", "flag", "ber", "mt", "elt", "mb", "ter", "resp", "ref", "out", "inter", "Ret", "reply", "rets", "nz", "gt", "ry", "ft", "err", "jp", "det", "tif", "deg", "pt", "ext", "r", "alt", "got", "magic", "rt", "count", "re", "final"], "refcount": ["reqcount", " refcounter", "memcount", "Refount", "REFount", "referencecode", " refcode", "REFlength", "refcounter", "argCount", "referenceCount", "referencec", " refount", "refCount", "REFcount", "difflength", "reflength", "argcounter", "memcond", "refc", "colcode", "RefCount", "Refc", " refname", "referencecounter", "memlength", "colCount", "argcount", "referencelength", "colcount", "referencename", "refcond", "refcode", " refCount", "memount", " reflength", "referencecount", "Refcount", "diffount", "diffcount", " refc", "REFcond", "diffcond", "refname", "Refcounter", "colcounter", "reqlength", "referenceount", "reqCount", "refount", "reqname"], "i": ["ij", "index", "key", "li", "a", "iu", "mi", "local", "oi", "ii", "I", "pi", "ini", "l", "ind", "p", "n", "x", "ex", "si", "ki", "zi", "uri", "name", "v", "ori", "chain", "bi", "batch", "us", "ui", "iq", "is", "di", " ii", "ai", "m", "in", "r", "ie", "xi", "qi", "sim", "im", "\u0438", "c", "remote", "ci", "id", "ims", "e", "ti", "u", "point", "ri", "multi", "it", "gi", "me", "q", "phi", "init", "y", "ic", "ix", "ip"], "j": ["jp", "ij", "index", "o", "ind", "l", "pr", "p", "n", "js", "aj", "kid", "tr", "jas", "bj", "v", "g", "pt", "batch", "uj", "job", "k", "m", "br", "r", "obj", "json", "c", "dj", "J", "oj", "jj", "b", "ns", "jump", "fr", "e", "jl", "jc", "max", "ji", "it", "kj", "z", "q", "x", "y", "ix", "ch"], "check_errors": ["check_comments", " check_docs", " check_error", " check_rors", "check___error", "check_docs", " check_comments", "check___rors", "check_error", "check___errors", "check_rors", "check___docs"], "corruptions_fixed": ["corruptures_checked", "corruptions___locked", "corruptures_fixes", "corruptions___fixed", "corruptures_locked", "corruptions_locked", "corruptions_fixes", "corruptions___checked", "corruptions___fixes", "corruptures_fixed", "corruptions_checked"], "corruptions": ["Corrupteditions", "Corruptedures", "corstructurations", "corrupturations", "corruptedions", "corruptures", "Corruptitions", "Corruptures", "corruptitions", "corricturations", "corruptedures", "corstructures", "corrupteditions", "Corruptedions", "corruptedurations", "corrictures", "Corruptedurations", "corstructitions", "corrictitions", "Corrupturations", "corrictions", "Corruptions", "corstructions"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void mainstone_common_init(MemoryRegion *address_space_mem,\n\n                                  MachineState *machine,\n\n                                  enum mainstone_model_e model, int arm_id)\n\n{\n\n    uint32_t sector_len = 256 * 1024;\n\n    hwaddr mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 };\n\n    PXA2xxState *mpu;\n\n    DeviceState *mst_irq;\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    int be;\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    const char *cpu_model = machine->cpu_model;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa270-c5\";\n\n\n\n    /* Setup CPU & memory */\n\n    mpu = pxa270_init(address_space_mem, mainstone_binfo.ram_size, cpu_model);\n\n    memory_region_init_ram(rom, NULL, \"mainstone.rom\", MAINSTONE_ROM,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    /* There are two 32MiB flash devices on the board */\n\n    for (i = 0; i < 2; i ++) {\n\n        dinfo = drive_get(IF_PFLASH, 0, i);\n\n        if (!dinfo) {\n\n            if (qtest_enabled()) {\n\n                break;\n\n            }\n\n            fprintf(stderr, \"Two flash images must be given with the \"\n\n                    \"'pflash' parameter\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        if (!pflash_cfi01_register(mainstone_flash_base[i], NULL,\n\n                                   i ? \"mainstone.flash1\" : \"mainstone.flash0\",\n\n                                   MAINSTONE_FLASH,\n\n                                   blk_bs(blk_by_legacy_dinfo(dinfo)),\n\n                                   sector_len, MAINSTONE_FLASH / sector_len,\n\n                                   4, 0, 0, 0, 0, be)) {\n\n            fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    mst_irq = sysbus_create_simple(\"mainstone-fpga\", MST_FPGA_PHYS,\n\n                    qdev_get_gpio_in(mpu->gpio, 0));\n\n\n\n    /* setup keypad */\n\n    pxa27x_register_keypad(mpu->kp, map, 0xe0);\n\n\n\n    /* MMC/SD host */\n\n    pxa2xx_mmci_handlers(mpu->mmc, NULL, qdev_get_gpio_in(mst_irq, MMC_IRQ));\n\n\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[0],\n\n            qdev_get_gpio_in(mst_irq, S0_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S0_CD_IRQ));\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[1],\n\n            qdev_get_gpio_in(mst_irq, S1_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S1_CD_IRQ));\n\n\n\n    smc91c111_init(&nd_table[0], MST_ETH_PHYS,\n\n                    qdev_get_gpio_in(mst_irq, ETHERNET_IRQ));\n\n\n\n    mainstone_binfo.kernel_filename = machine->kernel_filename;\n\n    mainstone_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    mainstone_binfo.initrd_filename = machine->initrd_filename;\n\n    mainstone_binfo.board_id = arm_id;\n\n    arm_load_kernel(mpu->cpu, &mainstone_binfo);\n\n}\n", "idx": 13051, "substitutes": {"address_space_mem": ["address_space2mem", "address_base_reg", "address_space_Mem", "address_base2memory", "address_base_mem", "address_area_memory", "address_base_ram", "address_space_ram", "address_space_reg", "address_base2ram", "address_space_memory", "address_space2ram", "address_space2memory", "address_base2mem", "address_space2reg", "address_area_mem", "address_area_Mem", "address_base_memory", "address_base2reg"], "machine": ["node", "instance", "money", "manager", "mem", "mode", "module", "monitor", "engine", "domain", "cpu", "policy", "Machine", "connection", "m", "power", "zone", "shell", "memory", "disk", "message", "container", "vm", "iso", "handler", "image", "device", "mc", "host", "state", "achine", "agent", "network", "process", "template", "computer"], "model": ["index", "key", "type", "cm", "mi", "ll", "map", "mode", "core", "module", "min", "pm", "m", "brand", "bm", "mm", "base", "link", "grid", "dev", "lv", "label", "mod", "ma", "Model", "value", "name", "models"], "arm_id": ["am_ref", "am_num", "arm_name", "armUnum", "armUid", "arm_ref", "armjref", "armjnum", "armjid", "armjname", "armUname", "armUref", "arm_num", "am_name", "am_id"], "mainstone_flash_base": ["mainstone_flash_cache", "mainstone_flash_Base", "mainstone_Flash_bas", "mainstone_flash2Base", "mainstone_flash2buffer", "mainstone_Flash_Base", "mainstone_flash_bas", "mainstone_flash2base", "mainstone_flash_block", "mainstone_Flash_cache", "mainstone_Flash_base", "mainstone_flash2cache", "mainstone_flash_buffer", "mainstone_Flash_buffer", "mainstone_Flash_block"], "mpu": ["mtui", "pmiu", "ppiu", "epcu", "pmu", "mti", "pmtu", "pmcu", "mpus", "mtU", "mpcu", "mptu", "pmi", "pmui", "mmiu", "mpui", "pmo", "mpiu", "ppu", "pptu", "ppus", "pmus", "mmus", " mpus", "mmtu", "mpi", "epu", "mtcu", "pmU", " mpU", " mpui", "epi", "mto", "mpU", "mtus", "epo", "mmu", "mpo", "mtu"], "mst_irq": ["mst_prqs", "mst_mrqs", "mst_pirqu", "mst_prqu", "mst_iqs", "mst_irQ", "mst_irqu", "mst_prQ", "mst_pirQ", "mst_iQ", "mst_prq", "mst_iq", "mst_mrq", "mst_mrQ", "mst_mrqu", "mst_pirqs", "mst_irqs", "mst_pirq"], "dinfo": ["dInfo", " dfo", "Dinfo", "DInfo", "Dby", "linfo", "ddata", "lno", "Dinf", "lfo", "sInfo", "rinfo", "sinfo", "lInfo", "bdfo", "bdinf", " dinf", "rInfo", "Dno", " dInfo", "linf", "bdinfo", "sfo", "bdInfo", "rdata", "rfo", " dby", "dfo", " ddata", "dno", "Dfo", "dinf", "dby", "lby", "sdata", " dno"], "i": ["ij", "index", "li", "f", "go", "o", "iu", "mi", "ii", "I", "pi", " j", "ini", "j", "l", "ki", "p", " di", "si", "n", "zi", "v", " ti", " si", "cli", "gu", "bi", "t", " pi", "ui", "di", " index", " ii", "ai", "m", "in", "k", "r", "hi", "ie", "s", "xi", "qi", " bi", "sim", "info", "im", "c", "ci", "b", "h", "id", "ti", "u", "e", "multi", "gi", "it", "fi", "z", "phi", "tim", "x", "y", "ic", "ix", "ip"], "be": ["bit", "ste", "ere", "Be", "ly", "by", " BE", " pe", "eb", "or", " se", "ate", "try", "bi", "bes", "ge", "fe", "is", "bo", "st", "obe", "loop", "ke", "end", " je", "ze", "brace", "br", "send", "zone", "he", "none", "abe", "ble", "ue", "use", "range", "BE", " Be", "bf", "are", "we", "este", "ose", "zo", "b", " b", "oe", "scale", " ne", "ride", "e", "ape", "to", "it", "ve", "se", "ne", "z", "ode", "ine", "te", "ce", "beat", "pose"], "rom": ["rem", "room", "gra", "mem", "cr", "gem", "serv", "cm", "rim", "rn", "ra", "iam", "core", "mr", "dr", "ran", "roma", "reg", "rar", "arm", "ros", "ru", "rm", "com", "cpu", "dom", "rep", "chrom", "im", "rum", "bm", "ROM", "ro", "mm", "drm", "sr", "rol", "rg", "irm", "red", "res", "rob", "rain", "ri", "prem", "ram", "prom", "mn", "rs"], "cpu_model": ["pu_mode", "pu_model", "CPU_module", "cpu_link", "cpuurescope", "cpuetymodel", "cpuetytype", "pu_type", " cpu_models", "cpu_mode", "cpu_location", "pu_scope", " cpu_Model", "pu_Model", "cpu_scope", "cpu_type", "cpu_models", " cpu_mode", " cpu_value", "CPU_model", "cpuuremodel", "cpuetymode", "cpuetylocation", "cpu_value", "cpu_module", " cpu_type", "CPU_Model", "cpu_Model", "CPU_link", "cpuureModel", "pu_location"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(vu9_to_vu12)(const uint8_t *src1, const uint8_t *src2,\n\n\t\t\tuint8_t *dst1, uint8_t *dst2,\n\n\t\t\tlong width, long height,\n\n\t\t\tlong srcStride1, long srcStride2,\n\n\t\t\tlong dstStride1, long dstStride2)\n\n{\n\n    long y,x,w,h;\n\n    w=width/2; h=height/2;\n\n#ifdef HAVE_MMX\n\n    asm volatile(\n\n\tPREFETCH\" %0\\n\\t\"\n\n\tPREFETCH\" %1\\n\\t\"\n\n\t::\"m\"(*(src1+srcStride1)),\"m\"(*(src2+srcStride2)):\"memory\");\n\n#endif\n\n    for(y=0;y<h;y++){\n\n\tconst uint8_t* s1=src1+srcStride1*(y>>1);\n\n\tuint8_t* d=dst1+dstStride1*y;\n\n\tx=0;\n\n#ifdef HAVE_MMX\n\n\tfor(;x<w-31;x+=32)\n\n\t{\n\n\t    asm volatile(\n\n\t\tPREFETCH\" 32%1\\n\\t\"\n\n\t        \"movq\t%1, %%mm0\\n\\t\"\n\n\t        \"movq\t8%1, %%mm2\\n\\t\"\n\n\t        \"movq\t16%1, %%mm4\\n\\t\"\n\n\t        \"movq\t24%1, %%mm6\\n\\t\"\n\n\t        \"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t        \"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t        \"movq\t%%mm4, %%mm5\\n\\t\"\n\n\t        \"movq\t%%mm6, %%mm7\\n\\t\"\n\n\t\t\"punpcklbw %%mm0, %%mm0\\n\\t\"\n\n\t\t\"punpckhbw %%mm1, %%mm1\\n\\t\"\n\n\t\t\"punpcklbw %%mm2, %%mm2\\n\\t\"\n\n\t\t\"punpckhbw %%mm3, %%mm3\\n\\t\"\n\n\t\t\"punpcklbw %%mm4, %%mm4\\n\\t\"\n\n\t\t\"punpckhbw %%mm5, %%mm5\\n\\t\"\n\n\t\t\"punpcklbw %%mm6, %%mm6\\n\\t\"\n\n\t\t\"punpckhbw %%mm7, %%mm7\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm1, 8%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 16%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm3, 24%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm4, 32%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm5, 40%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm6, 48%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm7, 56%0\"\n\n\t\t:\"=m\"(d[2*x])\n\n\t\t:\"m\"(s1[x])\n\n\t\t:\"memory\");\n\n\t}\n\n#endif\n\n\tfor(;x<w;x++) d[2*x]=d[2*x+1]=s1[x];\n\n    }\n\n    for(y=0;y<h;y++){\n\n\tconst uint8_t* s2=src2+srcStride2*(y>>1);\n\n\tuint8_t* d=dst2+dstStride2*y;\n\n\tx=0;\n\n#ifdef HAVE_MMX\n\n\tfor(;x<w-31;x+=32)\n\n\t{\n\n\t    asm volatile(\n\n\t\tPREFETCH\" 32%1\\n\\t\"\n\n\t        \"movq\t%1, %%mm0\\n\\t\"\n\n\t        \"movq\t8%1, %%mm2\\n\\t\"\n\n\t        \"movq\t16%1, %%mm4\\n\\t\"\n\n\t        \"movq\t24%1, %%mm6\\n\\t\"\n\n\t        \"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t        \"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t        \"movq\t%%mm4, %%mm5\\n\\t\"\n\n\t        \"movq\t%%mm6, %%mm7\\n\\t\"\n\n\t\t\"punpcklbw %%mm0, %%mm0\\n\\t\"\n\n\t\t\"punpckhbw %%mm1, %%mm1\\n\\t\"\n\n\t\t\"punpcklbw %%mm2, %%mm2\\n\\t\"\n\n\t\t\"punpckhbw %%mm3, %%mm3\\n\\t\"\n\n\t\t\"punpcklbw %%mm4, %%mm4\\n\\t\"\n\n\t\t\"punpckhbw %%mm5, %%mm5\\n\\t\"\n\n\t\t\"punpcklbw %%mm6, %%mm6\\n\\t\"\n\n\t\t\"punpckhbw %%mm7, %%mm7\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm1, 8%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 16%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm3, 24%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm4, 32%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm5, 40%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm6, 48%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm7, 56%0\"\n\n\t\t:\"=m\"(d[2*x])\n\n\t\t:\"m\"(s2[x])\n\n\t\t:\"memory\");\n\n\t}\n\n#endif\n\n\tfor(;x<w;x++) d[2*x]=d[2*x+1]=s2[x];\n\n    }\n\n#ifdef HAVE_MMX\n\n\tasm(\n\n\t\tEMMS\" \\n\\t\"\n\n\t\tSFENCE\" \\n\\t\"\n\n\t\t::: \"memory\"\n\n\t\t);\n\n#endif\n\n}\n", "idx": 13068, "substitutes": {"src1": ["rc1", "sourceOne", "srcOne", "source2", "srOne", " src01", "rc3", "usr3", "source3", " src3", " srcOne", "rc2", "source7", "sr3", "usr2", "src3", "usr1", "usr01", "rc01", "sr1", "src7", "src01", " src7", "source1", "rc7", "rcOne", "sr2"], "src2": [" src4", "rc1", "srctwo", "source4", "source5", "src4", "rs2", "sourcetwo", "rstwo", "source2", "src5", "rc3", "rc5", "source3", " src3", "rs1", "rc2", " src5", "rctwo", "src3", "source1", "rc4"], "dst1": ["dsts3", "dgest01", "dest1", "pdstoreRad", "dcr001", "pdst1", "Dst2", "Dst3", "Dsts0", "dsrc0", "Dst0", "dstoreRad", "pdst01", "Dsts1", "dcrRad", "pdstRad", "dst01", "Dsts3", "dsts1", "dgest001", "dsts2", "Dsts2", "dcr1", "dsrc1", "dstore1", "dest3", "dest0", "dstRad", "pdst001", "Dst1", "dst001", "dcr01", "pdstore001", "dst0", "dsrc2", "dstore001", "dstore01", "dgestRad", "pdstore01", "pdstore1", "dst3", "dsrc3", "dest2", "dsts0", "dgest1"], "dst2": ["dst02", "Dest5", "drc0", "dest1", "dest5", "dstr5", "sst02", "dstr1", "Dest02", "Dst2", "drc02", "dsrc0", "dst5", "drc2", "sest0", "sst2", "dist5", "dest02", "dsrc02", "drc1", "sest02", "dsrc1", "sst0", "dist2", "dist1", "dest0", "dstr02", "Dst1", "Dst5", "dist02", "Dest2", "dst0", "dsrc2", "sst1", "sest2", "sest1", "dest2", "dstr2", "Dest1", "Dst02"], "height": ["hang", "ty", "wh", "kh", "density", "size", "hub", "depth", "window", "radius", "inches", "frame", "gh", "ih", "padding", "bottom", "Height", "th", "he", "headers", "html", "hei", "resolution", "stroke", "count", "sh", "ht", "volume", "grow", "draw", "length", "gravity", "shape", "ity", "sky", "gy", "angle", "zh", "history", "ch"], "srcStride1": ["srcstideOne", "srcstrideOne", "srcStack2", "srcStrideOne", "srcstride10", "srcStine1", "srcStrideName", "srcStackName", "srcStride01", "srcStide10", "srcStrat1", "srcStrat01", "srcstide2", "srcStack1", "srcstride01", "srcStratOne", "srcStridOne", "srcStrid12", "srcstide01", "srcStrid1", "srcStrat2", "srcStideName", "srcStrat10", "srcstride12", "srcStideOne", "srcStride10", "srcstride2", "srcstride1", "srcStrid2", "srcstrideName", "srcStineOne", "srcStide1", "srcStine12", "srcstide1", "srcStride12", "srcStide12", "srcstide10", "srcStine2", "srcStide01", "srcStack01", "srcstideName", "srcStratName", "srcStide2", "srcstide12"], "srcStride2": ["srcStide4", "srcStack2", "srcStro6", "srcStride4", "srcstride0", "srcStend2", "srcStrride1", "srcstide6", "srcStrideTwo", "srcstide4", "srcstrideTwo", "srcStackTwo", "srcStrib1", "srcStrobe4", "srcstide0", "srcstide2", "srcStide0", "srcStide02", "srcStack1", "srcStro4", "srcStendTwo", "srcStrobe6", "srcStro1", "srcStrib02", "srcStride0", "srcStend0", "srcstride4", "srcStrrideTwo", "srcstride6", "srcStack0", "srcStide6", "srcStro2", "srcStribTwo", "srcstideTwo", "srcstride2", "srcstride1", "srcStride02", "srcStrride2", "srcStide1", "srcStend1", "srcStrobe2", "srcstide1", "srcStrib2", "srcStrobe1", "srcStideTwo", "srcStride6", "srcStrride02", "srcStide2"], "dstStride1": ["dstSTrideone", "dstStride4", "dstSTrideOne", "dstStripOne", "dstSTride1", "dstStripId", "dstStriction1", "dstStrib1", "dstSTripone", "dstStriction01", "dstStrride1", "dstStrride2", "dstStride01", "dstStrib4", "dstStrip2", "dstStripone", "dstStrideId", "dstSTrip01", "dstStrip01", "dstStrrideId", "dstStide1", "dstStide4", "dstStrictOne", "dstStrideOne", "dstStrip4", "dstStide2", "dstStrict01", "dstStrictone", "dstSTripOne", "dstSTrip1", "dstSTride01", "dstStrictionOne", "dstStribId", "dstStrideone", "dstStideId", "dstStrict1", "dstStrib2", "dstStrride4", "dstStrip1", "dstStrictionone"], "dstStride2": ["dstSlrobe_", "dstStack_", "dstStr02", "dststide1", "dstStrib1", "dstSlride_", "dstStrib3", "dststride2", "dstStr1", "dstStide3", "dstStr2", "dstStr3", "dstStide02", "dststride1", "dststide3", "dstStride3", "dstStride02", "dstStide1", "dstStr_", "dstStide2", "dststide02", "dstStrobe_", "dstStride_", "dststride3", "dstStrib02", "dststride02", "dstStrib2", "dststide2"], "y": ["yy", "column", "key", "uy", "ty", "by", "yt", "oy", "at", "asy", "py", "dy", "ly", "o", "ny", "ys", "yx", "j", "sy", "p", "axy", "Y", "yi", "g", "xy", "ya", "ym", "t", "ay", "kit", "try", "ery", "yr", "ye", "icy", "sys", "m", "cy", "yo", "vy", "iy", "ies", "ady", "yer", "lat", "ry", "on", "b", "xx", "hot", "ish", "any", "that", "e", "my", "ot", "col", "err", "sky", "wy", "gy", "ey", "ley", "yl", "i", "z", "sat", "fy", "ch"], "x": ["index", "xd", "check", "t", "m", "ux", "xi", "xc", "en", "lat", "draw", "tx", "xes", "inx", "axis", "sw", "wx", "ax", "edit", "yx", "j", "n", "X", "v", "xp", "i", "ex", "xt", "ix", "column", "key", "est", "f", "ross", "row", "xxx", "xs", "batch", "ox", "fx", "step", "c", "lex", "xx", "id", "px", "xf", "status", "xxxx", "o", "l", "p", "name", "xy", "el", "ext", "ct", "r", "exclusive", "time", "dx", "page", "ice", "on", "e", "z", "rx", "xml", " xx", "ch"], "w": ["kw", "ww", "wh", "fw", "nw", "wx", "rw", "aw", " W", "l", "hw", "wb", "window", "p", "ex", "wl", "v", "wm", "t", "wt", "wa", "m", "wn", "r", "ew", "iw", "wall", "wid", "wk", "en", "we", "wp", "wd", "W", "wi", "wr", "win", "wy", "q", "Width"], "h": ["hang", "wh", "f", "ph", "kh", "hr", "l", "j", "high", "p", "n", "hw", "hm", "hal", "v", "ha", "g", "t", "ih", "hs", "his", "k", "m", "r", "he", "hi", "hei", "hd", "c", "oh", "en", "sh", "ht", "b", "H", "ish", "hl", "hash", "length", "z", "q", "hh", "i", "zh", "ch"], "s1": ["s3", " s3", "ats1", "src4", "rs01", "rs2", "rs4", "ss2", "rs1", "ats001", "ss0", "rs3", "ss3", "src3", " s01", " s001", "rs0", " s4", "ats2", "s01", "src01", "ats0", "rs001", "s001", "ss1", " s0", "s4", "s0"], "d": ["dict", "f", "o", "data", "l", "j", "p", "fd", "n", "dr", "D", "dl", "dis", "dt", "dm", "v", "dp", "pd", "ded", "g", "done", "t", "di", "dc", "dos", "ds", "da", "m", "dd", "r", "dL", "s", "bd", "dq", "c", "dx", "db", "b", "e", "ad", "sd", "z", "q", "dat", "did", "i", "ld", "dra"], "s2": ["src0", "ss4", "ss2", "ss0", " s4", "src4", "ss1", " s0", "s4", "s0"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void puv3_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    CPUUniCore32State *env;\n\n    UniCore32CPU *cpu;\n\n\n\n    if (initrd_filename) {\n\n        error_report(\"Please use kernel built-in initramdisk\");\n\n        exit(1);\n\n    }\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"UniCore-II\";\n\n    }\n\n\n\n    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));\n\n    if (!cpu) {\n\n        error_report(\"Unable to find CPU definition\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    puv3_soc_init(env);\n\n    puv3_board_init(env, ram_size);\n\n    puv3_load_kernel(kernel_filename);\n\n}\n", "idx": 13077, "substitutes": {"machine": ["node", "server", "instance", "money", "manager", "mode", "series", "managed", "module", "rule", "model", "chain", "check", "monitor", "frame", "engine", "domain", "space", "Machine", "connection", "m", "power", "zone", "shell", "menu", "gate", "vm", "sim", "iso", "handler", "parse", "range", "image", "keeper", "one", "link", "hello", "alias", "device", "host", "state", "achine", "shape", "me", "agent", "human", "history", "network", "save", "process", "template", "computer"], "cpu_model": ["pu_mode", "pu_model", "pu_vector", "money_model", "pu_label", "cpu_attribute", "cpu_label", "pu_string", "cpuNametype", "cpu_mode", "money_controller", "money_type", "moneyNameattribute", "money_attribute", "cpuitymodel", "pu_Model", "moneyNametype", "cpu_type", "cpu_base", "cpu_models", "cpuNameattribute", "cpuityattribute", " cpu_mode", "cpuitycontroller", "cpu_controller", "pu_models", "cpu_vector", "cpuNamecontroller", "cpu_string", "cpu_value", "pu_value", " cpu_type", "pu_base", "moneyNamecontroller", "cpuNamemodel", "cpu_Model", "cpuitytype", "moneyNamemodel"], "kernel_filename": ["kernel___fn", "ernel_fn", "loader_fn", "kernellefilename", "kernellefn", "kernelletitle", "kernel___filename", "proc_filename", "loaderlogfn", "loader_tails", "kernel_tails", "kernellogfn", "kernellogtails", "kernel_name", "kernellelayout", "kernellogsubject", "kernel___tails", "proc_title", "kernel_subject", "loaderlogtails", "kernel___subject", "kernel_fn", "loader_filename", "loaderlogfilename", "loaderlogsubject", "proc_fn", "kernel_file", "kernel_layout", "proc_layout", "ernel_filename", "loader_subject", "kernel_title", "ernel_name", "ernel_file", "kernellogfilename"], "initrd_filename": ["initrdisttxt", "initdretyfilename", "initrend_fn", "initdr_folder", "initrdistfn", "initrd_Filename", "initdr_string", "initrb_Filename", "initrd_string", "initrd_folder", "initrend_file", "initrdetyfilename", "initrd_file", "initrb_uri", "initrd___folder", "initrdistfilename", "initrd___fn", "initdretyfolder", "initdretyFilename", "initrend_txt", "initrd_txt", "initdr_filename", "initrd___string", "initrdetyfolder", "initrendistfile", "initrend_filename", "initrendistfilename", "initrd___txt", "initrdistfile", "initrendisttxt", "initdretystring", "initrd_uri", "initrb_filename", "initrb_fn", "initrd___filename", "initrd___file", "initrd_fn", "initrd___Filename", "initdr_Filename", "initrdetyFilename", "initrdetystring", "initrendistfn"], "env": ["server", "nv", "ce", "dict", "mem", "conn", "et", "manager", "global", "session", "environment", "cmd", "ctx", "scope", "email", "window", "hw", "erd", "proc", "vert", "v", "ent", "frame", "engine", "sv", "er", "priv", "buf", "stack", "shell", "context", "obj", "doc", "vm", "wall", "db", "event", "en", "ec", "mn", "vs", "cookie", "dev", "e", "conf", "entry", "state", "config", "enter", "eng", "net", "me", "ve", "win", "ev", "vt", "w", "esp", "init", "gear", "te", "viron", "equ"], "cpu": ["node", "server", "cu", "jp", "pu", "CPU", "goal", "ni", "mem", "socket", "hog", "core", "ctx", "linux", "proc", "coin", "cli", "chip", "uart", "clock", "na", "aco", "mac", "frame", "util", "cache", "np", "processor", "cam", "bench", "uda", "pai", "ola", "vm", "current", "runner", "mu", "c", "cv", "cal", "base", "cum", "comp", "cp", "gc", "nic", "nice", "cow", "gpu", "config", "bean", "net", "ne", "init", "process", "ce", "nu", "alloc", "computer"]}}
{"project": "FFmpeg", "commit_id": "caa845851d790f894a2ccbe12580934f75545f92", "target": 0, "func": "static int output_data_internal(MLPDecodeContext *m, unsigned int substr,\n\n                                uint8_t *data, unsigned int *data_size, int is32)\n\n{\n\n    SubStream *s = &m->substream[substr];\n\n    unsigned int i, out_ch = 0;\n\n    int32_t *data_32 = (int32_t*) data;\n\n    int16_t *data_16 = (int16_t*) data;\n\n\n\n    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))\n\n        return -1;\n\n\n\n    for (i = 0; i < s->blockpos; i++) {\n\n        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {\n\n            int mat_ch = s->ch_assign[out_ch];\n\n            int32_t sample = m->sample_buffer[i][mat_ch]\n\n                          << s->output_shift[mat_ch];\n\n            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;\n\n            if (is32) *data_32++ = sample << 8;\n\n            else      *data_16++ = sample >> 8;\n\n        }\n\n    }\n\n\n\n    *data_size = i * out_ch * (is32 ? 4 : 2);\n\n\n\n    return 0;\n\n}\n", "idx": 13081, "substitutes": {"m": ["am", "f", "o", "cm", "mi", "asm", "l", "j", "n", "p", "mr", "hm", "dm", "v", "g", "t", "md", "comm", "sm", "em", "k", "y", "r", "c", "mm", "bm", "b", "mc", "gm", "h", "mp", "mt", "M", "d", "tm", "nm", "ms", "mn"], "substr": ["formSTR", "singSTR", "sqstr", "formstring", " substem", "Substr", "Substring", "formstr", "Subbr", "singstr", "sqstem", "sqbr", "singstring", " substring", "substring", "SubStr", "subSTR", "Substem", "subbr", "substem", " subbr", "SubSTR", "subStr", "formStr", "sqstring", "singStr"], "data": ["bytes", "out", "size", "map", "values", "p", "n", "window", "raw", "multiple", "missing", "text", "batch", "done", "t", "cache", "bin", "new", "message", "none", "mu", "buffer", "empty", "block", "image", "all", "Data", "no", "table", "input", "any", "d", "DATA", "ata", "value", "dat", "zero", "x", "results", "sample"], "data_size": ["DATA_length", " data_Size", "data_send", "data5since", "data_Size", "data_length", "DATA_SIZE", "data_since", "sample_SIZE", "sample_send", "sample_size", "data5SIZE", "DATA_size", "data_count", "sample_since", "DATA_count", "data5size", " data_length", "data5send", "data_SIZE", " data_SIZE"], "is32": ["is40", "isl32", "is31", " is34", "is34", " is42", " is12", "sis12", "iss32", "iris32", "iris34", "sis34", "sis64", "tis64", "isl31", "tis31", "iss64", "is42", " is64", "isl42", "is12", "iss8", "isl64", "iris31", "iss12", "is64", " is31", " is8", "tis34", "sis40", "sis32", "tis32", "is8", " is40", "sis8", "tis40", "tis42"], "s": ["ses", "esm", "gs", "a", "S", "sw", "f", "serv", "settings", "p", "js", "n", "sq", "v", "g", "sl", "t", "comm", "sm", "sv", "is", "sb", "spec", "sys", "hs", "space", "service", "ds", "ls", "sa", "ssl", "sim", "ts", "sp", "c", "stats", "ins", "ns", "ops", "cs", "b", "h", "ims", "set", "e", "fs", "sd", "conf", "os", "state", "se", "sym", "z", "ss", "sts", "ms", "rs", "ps"], "i": ["index", " li", " di", "t", " pi", " ki", "ai", "xi", "qi", "it", "li", "ind", "j", "ki", "n", "si", "zi", " ti", "v", "g", "ui", " index", " bi", "im", "ti", "x", "ri", "ic", "ix", "ip", "ij", "key", "a", "at", "f", "ii", "mi", "I", "pi", " iter", " si", "batch", "di", " ii", " mi", "in", "sim", "c", "ci", " Ai", "id", " ni", "u", "multi", "to", "d", "me", "go", "iu", "o", " j", "ini", "l", "uri", "ei", "p", "bi", "io", "r", "e", " Xi", "z", "q", "phi", "init", "y"], "data_32": ["data_34", "message_33", "data__34", "data_8", "step_16", "data__8", "step_8", "message_34", "data__32", "data_33", "data__16", "message_32", "step_32", "data_152", "data__152", "data__12", "message_152", "data__33", "step_12", "data_12"], "data_16": [" data_1024", "data___1024", "data___16", " data_31", " data_180", "data_18", " data_18", "data_31", "data_1024", "data___32", "data___18", "data_180", "data_24", " data_24"], "out_ch": [" out_chi", "in_chan", "chain_ech", "out_chan", "out___channel", "out_sh", "out___sh", "mat_batch", "in_ch", "chain_ch", "out___ch", " out_chn", "mat_char", "out_ich", "in_channel", "outptch", "out_cho", "out_batch", "out_chn", "outMemwh", "chain_ich", "chain_chn", "out___chan", "outMemcom", " out_Ch", "mat_ch", "in_cho", "outMemcho", "outChanchn", "outptchannel", "out_channel", "in_sh", "in_com", " out_wh", "out_char", "outMemCh", "outChanchannel", "outChanCH", "outptCH", " out_CH", "outMemchan", "outMemch", "mat_chan", "out_CH", " out_channel", "out_chi", "out_wh", "outMemchi", "out_ech", "out_Ch", "outChanch", "out_com", "outptchn"]}}
{"project": "qemu", "commit_id": "2ebafc854d109ff09b66fb4dd62c2c53fc29754a", "target": 1, "func": "static int qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset,\n\n                                 uint64_t end_offset, void **p_feature_table,\n\n                                 Error **errp)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowExtension ext;\n\n    uint64_t offset;\n\n    int ret;\n\n\n\n#ifdef DEBUG_EXT\n\n    printf(\"qcow2_read_extensions: start=%ld end=%ld\\n\", start_offset, end_offset);\n\n#endif\n\n    offset = start_offset;\n\n    while (offset < end_offset) {\n\n\n\n#ifdef DEBUG_EXT\n\n        /* Sanity check */\n\n        if (offset > s->cluster_size)\n\n            printf(\"qcow2_read_extension: suspicious offset %lu\\n\", offset);\n\n\n\n        printf(\"attempting to read extended header in offset %lu\\n\", offset);\n\n#endif\n\n\n\n        ret = bdrv_pread(bs->file, offset, &ext, sizeof(ext));\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"qcow2_read_extension: ERROR: \"\n\n                             \"pread fail from offset %\" PRIu64, offset);\n\n            return 1;\n\n        }\n\n        be32_to_cpus(&ext.magic);\n\n        be32_to_cpus(&ext.len);\n\n        offset += sizeof(ext);\n\n#ifdef DEBUG_EXT\n\n        printf(\"ext.magic = 0x%x\\n\", ext.magic);\n\n#endif\n\n        if (ext.len > end_offset - offset) {\n\n            error_setg(errp, \"Header extension too large\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        switch (ext.magic) {\n\n        case QCOW2_EXT_MAGIC_END:\n\n            return 0;\n\n\n\n        case QCOW2_EXT_MAGIC_BACKING_FORMAT:\n\n            if (ext.len >= sizeof(bs->backing_format)) {\n\n                error_setg(errp, \"ERROR: ext_backing_format: len=%\" PRIu32\n\n                           \" too large (>=%zu)\", ext.len,\n\n                           sizeof(bs->backing_format));\n\n                return 2;\n\n            }\n\n            ret = bdrv_pread(bs->file, offset, bs->backing_format, ext.len);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret, \"ERROR: ext_backing_format: \"\n\n                                 \"Could not read format name\");\n\n                return 3;\n\n            }\n\n            bs->backing_format[ext.len] = '\\0';\n\n#ifdef DEBUG_EXT\n\n            printf(\"Qcow2: Got format extension %s\\n\", bs->backing_format);\n\n#endif\n\n            break;\n\n\n\n        case QCOW2_EXT_MAGIC_FEATURE_TABLE:\n\n            if (p_feature_table != NULL) {\n\n                void* feature_table = g_malloc0(ext.len + 2 * sizeof(Qcow2Feature));\n\n                ret = bdrv_pread(bs->file, offset , feature_table, ext.len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: ext_feature_table: \"\n\n                                     \"Could not read table\");\n\n                    return ret;\n\n                }\n\n\n\n                *p_feature_table = feature_table;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            /* unknown magic - save it in case we need to rewrite the header */\n\n            {\n\n                Qcow2UnknownHeaderExtension *uext;\n\n\n\n                uext = g_malloc0(sizeof(*uext)  + ext.len);\n\n                uext->magic = ext.magic;\n\n                uext->len = ext.len;\n\n                QLIST_INSERT_HEAD(&s->unknown_header_ext, uext, next);\n\n\n\n                ret = bdrv_pread(bs->file, offset , uext->data, uext->len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: unknown extension: \"\n\n                                     \"Could not read data\");\n\n                    return ret;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n\n\n        offset += ((ext.len + 7) & ~7);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13097, "substitutes": {"bs": ["bytes", "ses", "aws", "ubis", "gs", "ubs", "aos", "obs", "banks", "outs", "pb", "hz", "js", "bits", "eb", "bh", "bi", "bes", "ox", "als", "sb", "aus", "hs", "sys", "cks", "ds", "ls", "bn", "oss", "BS", "vals", "qs", "bsp", "ts", "bos", "bm", "boxes", "bas", "bf", "blog", "vs", "ins", "b", "bl", "cs", "bc", "lbs", "ns", "fs", "bps", "bis", "bing", "its", "bb", "bp", "fps", "ss", "sts", "rs", "ps"], "start_offset": ["start_point", "start_padding", "first_offset", "start_size", "first_size", " start_position", "st_offset", "first_pos", "st_position", "st_Offset", "start_Offset", "start_pos", " start_point", "first_padding", "st_size", "start_position", " start_padding"], "end_offset": ["stop__size", "END_offset", "end_op", "stop_number", "end_location", "endlyoffset", " end_size", "end__size", "stop__offset", "end_point", "END_Offset", "stop__number", " end_position", "end__location", "END_pointer", "end___length", "END_point", "end_Offset", "stop_offset", "stop__location", " end_Offset", "endlynumber", "end_size", "end__number", "end_position", "start_op", "end___offset", "stop_location", "end___Offset", "end__offset", "end_length", "endlylocation", "end___op", "start_Offset", "end_number", "stop_size", "start_length", "end_pointer", "endlysize"], "p_feature_table": ["p_image_table", "p_image_Table", "p_feature_Table", "p_feature_list", "pc_end", "p_image_list", "p_feature_TABLE", "pc____end", "p_end", "p____end", "p_image_TABLE"], "errp": ["errpos", "eorping", "rerpress", "lrp", "ererping", "rrpa", "eord", "lrpress", "dieping", "errper", "warnpa", "errorpad", "eorpa", "diepa", "ererp", "aerper", "derg", " errpa", "ererpos", "rerpa", "derper", "warnpos", "errpress", " errpos", "errping", "errpb", " errP", "ererpa", "rrpoint", "rrping", "errorp", "aerp", "diep", "errorpress", "rerp", "errP", "eorpoint", "warnP", "rerpad", "errpoint", "errorpa", "eorg", "diepoint", "ererP", "ererpb", "derp", "rrp", "errorping", "eorper", "rrpb", "warnp", "errpad", "errd", "aerd", "derd", "aerg", "lrpa", "lrpad", "errorpb", "errg", "eorp", "errpa"], "s": ["sis", "ses", "aws", "gs", "S", "p", "js", "bits", "si", "sq", "xs", "sb", "sv", "ds", "ls", "ats", "sa", "ts", "sp", "stats", "vs", "b", "ns", "cs", "h", "es", "fs", "os", "its", "sn", "ss", "sts", "rs", "ps"], "ext": ["orig", "ctx", "expr", " extent", "lib", "opt", " extract", "val", "t", "new", "nt", "dim", "add", "cb", "art", "split", " extrap", "ort", "exec", "cont", "tx", " Ext", "rem", "def", "ptr", "wx", "ax", "ind", "cmd", "js", "tr", " ex", "let", "v", "test", "xp", "buff", "prot", "dist", "extra", "obj", "aux", "Ext", "env", "im", "elt", "EXT", "orb", "esp", "ex", "xt", "tab", "txt", "sub", "external", "ix", "sci", "resp", "ref", "ver", "inter", "seq", "pat", " extension", "temp", "req", "text", "ez", "ox", "bf", "lex", "enc", "nex", "err", "ev", "imm", "str", "ect", "p", "ord", "tex", " extend", "el", "esc", "msg", "ef", "desc", "alt", "off", " extr", "tf", "lt", "e", "mod", "gz", "XT", "inst"], "offset": ["index", "shift", "et", "window", "initialized", "online", "t", "len", "end", "lag", "attribute", "fp", "location", "top", "coord", "start", "length", "ta", "error", "ptr", "address", "addr", "mask", "timeout", "reset", "next", "padding", "align", "OFF", "pos", "alias", "slice", "set", "area", "seek", "mt", "esp", "tab", "key", "scroll", "at", "f", "ref", "out", "row", "batch", "store", "now", "op", "slot", "buffer", "bound", "ob", "o", "output", "position", "adjusted", "section", "offs", "handle", "size", "Offset", "origin", "item", "alt", "url", "off", "range", "iso", "sp", "tz", "oid", "point", "pad", "pointer"], "ret": ["et", "pret", "fun", "back", "expr", "val", "eq", "t", "result", "new", "nt", "att", "rev", "Return", "ort", "net", " Ret", "usr", "arr", "rem", "def", "ere", "ptr", "addr", "cmd", "tr", "after", "RET", "reset", "dt", "try", "cat", "get", "RT", "res", "print", "flag", "ber", "tmp", "set", "mt", "arg", "elt", "ter", "resp", "ref", "out", " alt", "inter", "Ret", "reply", "rets", "ert", "sys", "nz", "gt", "eth", "iter", "ft", "err", "status", "il", "jp", " RET", "tif", "ord", "reg", "ent", "alt", "rt", "tf", "lt", "cert", "re"]}}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, int dstWidth, const uint8_t *src1, const uint8_t *src2,\n\n                                   int srcW, int xInc, const int16_t *hChrFilter,\n\n                                   const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                   uint8_t *formatConvBuffer,\n\n                                   uint32_t *pal)\n\n{\n\n\n\n    src1 += c->chrSrcOffset;\n\n    src2 += c->chrSrcOffset;\n\n\n\n    if (c->chrToYV12) {\n\n        c->chrToYV12(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= formatConvBuffer+VOFW;\n\n    }\n\n\n\n    if (!c->hcscale_fast) {\n\n        c->hScale(dst     , dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);\n\n    }\n\n\n\n    if (c->chrConvertRange)\n\n        c->chrConvertRange(dst, dstWidth);\n\n}\n", "idx": 13100, "substitutes": {"c": ["rc", "cu", "ce", "cf", "co", "f", "tc", "cr", "unc", "cm", "ca", "cur", "cn", "lc", "l", "ctx", "p", "n", "cmp", "call", "cc", "cd", "v", "chain", "g", "t", "comm", "ic", "com", "dc", "cache", "ct", "cam", "m", "s", "ac", "C", "self", "cb", "cv", "cal", "nc", "abc", "ci", "ec", "comp", "cp", "b", "mc", "cs", "bc", "h", "etc", "gc", "fc", "pc", "e", "con", "conf", "enc", "d", "vc", "sc", "cont", "anc", "can", "ch"], "dst": ["ldST", "msrc", "gpt", "dost", "dnt", "mest", "Dst", "dosp", "ddnt", "ddSt", " dnd", "DST", "Dost", " dost", "delld", "dopt", "gsp", "delnt", " dsrc", "dnd", "dld", "ldst", " dnt", "Dnd", "mnd", "mst", "deost", "ldest", "bnd", "bsp", "ddld", "Dsrc", "Dest", "dond", "dsp", "dest", " dest", "ddst", "delSt", "sdSt", "deST", "sdld", "sdst", "sdnt", "dSt", "ldnt", "bst", "dST", "deest", "gst", "bpt", "dpt", "Dnt", "dsrc", " dST", "gnd", "delst"], "dstWidth": ["dstW", " dstHTML", " dSTwidth", "Dmtwidth", " destWidth", "dndHeight", "DstWidth", " dSTHTML", "destLen", "dstBW", "dputBW", "DmtWidth", "dstFontSize", "DstBW", "dSTWidth", "dwtwidth", "DestWidth", "DmtBW", "destSize", " dstSize", "DestW", "dntWidth", "dSTW", " destLen", "DestHeight", "dSTSize", "dndSize", "dSTHTML", "destFontSize", "dmtBW", "dmtFontSize", "dwtWidth", "DstSize", "DestSize", " dstLen", "dstHTML", "dmtW", "drcSize", "dntHeight", "DmtW", "DstHeight", " destHeight", "dspHTML", "dSTHeight", "dmtwidth", "dntFontSize", "DmtHeight", "dputHeight", "dwtW", "DstW", "dndW", "destW", "dspWidth", "dspwidth", "Dstwidth", "dstSize", "destWidth", "dmtWidth", " dSTW", " dstW", "dndWidth", " dstHeight", "dstLen", "DstFontSize", "dstHeight", "destwidth", "destHeight", " dSTWidth", "dmtHeight", "DmtFontSize", "dSTwidth", "dwtHTML", "dputWidth", "drcHeight", "dstwidth", "drcWidth", "dntwidth", " destSize", "destBW", "drcLen", " dstwidth", "dputW", "dSTLen", "dspW"], "src1": ["rc1", "desc1", "rel1", "sourceOne", "inst2", "desc001", "inst1", "srcOne", "sc01", "source2", " src01", "rc3", "sc1", " src3", "desc2", " srcOne", "sc0", "rc2", "rel01", "inst001", "source0", "src3", "descOne", " src0", "rc01", "src01", " src001", "source1", "src0", "rel2", "source01", "rel3", "src001", "rc0", "rcOne", "scOne", "rc001", "instOne"], "src2": ["relL", " src4", "sourceTwo", "rc1", "rcL", "src02", "rel1", "src4", "source2", "ser02", "txt2", "rc3", "usr3", "source3", "source02", "sr4", "relTwo", " srcTwo", "rc2", "loc2", "txt1", "usr2", "rc02", " srcL", "src3", "rcTwo", "locTwo", "txt02", "sr1", "src32", " src02", "loc02", "source1", "srcL", "ser1", " src32", "rc4", "usrTwo", "rel2", "sr32", "ser2", "srcTwo", "rc32", "sr2"], "srcW": ["rcW", "rc1", "srcJ", "srW", "pkgW", "ctrW", " srcJ", " srcEW", "srcWidth", "source2", "pkgWidth", "rcJ", "rcEW", "rcWidth", "syn1", "srJ", "pkgw", "secW", " srcV", "sourceWidth", "ctrEW", "ctr1", "synEW", "pkgEW", "rc2", "sourceW", "synW", "srcEW", " srcw", "sourcew", "secEW", "sourceV", "synWidth", "rcV", "srcw", "sourceEW", "rcw", "srcV", "sec1", "srw", "secWidth", "sr2"], "xInc": [" xIncre", "xpINC", "xinc", "xAdd", "exAdd", "xtInc", "xfinc", "exIncre", "yInc", "yEnc", " xEnc", "dxInc", "xfIncre", "xtEnc", "dxEnc", "xpInit", "exInc", "xIncre", "xfInc", "xINC", "xInit", "xEnc", " xInit", "xpIncre", " xInv", "exEnc", "xtIncre", "dxExc", "xtAdd", " xExc", "xtinc", " xinc", "xExc", " xAdd", "xInv", "yINC", "xfInv", "yInit", " xINC", "yIncre", "dxIncre", "xtInv", "yExc", "xpInc"], "hChrFilter": ["hChrcFilter", "hChnTransform", "hChrgProfile", "hChlFilter", "hScsrFocus", "hChrApply", "hCorcProfile", "hChsrMethod", "hCHnApply", "hCHrFilter", "hChrcHash", "hChrgTransform", "hChlSpec", "hChrgSpec", "hChtTransform", "hChcProfile", "hScsrFilter", "hChrbApply", "hChtApply", "hChrcFocus", "hCHnTransform", "hCHrFormat", "hChrSpec", "hCorrTransform", "hCHrApply", "hCorrSpec", "hChrtMethod", "hChcSpec", "hScrFocus", "hScrFilter", "hCHnFormat", "hChrtFocus", "hChrHash", "hScrHash", "hChrTransform", "hChcTransform", "hChsrFilter", "hChcFilter", "hCorcFilter", "hChlTransform", "hCHnFilter", "hScsrHash", "hChnFormat", "hChtFilter", "hScrMethod", "hChtFormat", "hChrMethod", "hCorrFilter", "hChrcMethod", "hCorcTransform", "hCHrTransform", "hChnFilter", "hChrProfile", "hChrtHash", "hChrbTransform", "hChrbFilter", "hCorrProfile", "hScsrMethod", "hChrgFilter", "hChrbFormat", "hCorcSpec", "hChrtFilter", "hChsrHash", "hChrFocus", "hChsrFocus", "hChlProfile", "hChrFormat", "hChnApply"], "hChrFilterPos": ["hChrHandlerPosition", "hChrfilterPos", "hChrBufferPos", "hChrCounterCond", "hChrcfilterTrans", "hChrFormatRef", "hChcrFilterCond", "hChcFilterType", "hChcrFilterpos", "hChrCounterRef", "hChrfilterpos", "hChrFormatCond", "hChrcfilterPos", "hChrFormatpos", "hChrFilterCond", "hChrfilterType", "hChrPatternpos", "hChrfilterPosition", "hChcFilterpos", "hChrcFilterTrans", "hChrPatternPos", "hChrFilterRef", "hChrCounterPos", "hChrfilterTrans", "hChcFilterPos", "hChrBufferPosition", "hChrcFilterPosition", "hChcrFilterRef", "hChrFilterpos", "hChcrFormatRef", "hChrHandlerPos", "hChrFilterPosition", "hChrCounterpos", "hChrHandlerTrans", "hChcrFormatPos", "hChrPatternType", "hChcrFormatpos", "hChrFilterType", "hChrcfilterPosition", "hChrcFilterPos", "hChrFilterTrans", "hChrBufferTrans", "hChrFormatPos", "hChrfilterRef", "hChcrFormatCond", "hChrfilterCond", "hChcrFilterPos"], "hChrFilterSize": ["hChrBufferPos", "hChrFormatOffset", "hChcBufferSize", "hChdrFilterLen", "hChrTransformCos", "hChcFilterLen", "hChrlFieldS", "hChdrTransformSize", "hChrFilterLen", "hChrTransformLen", "hChrlFieldOffset", "hChrFormatS", "hChrFilOffset", "hChrFilterS", "hChrFieldOffset", "hChrMaskLen", "hChdrFilterSIZE", "hChcFilterStyle", "hChrFormatStats", "hChrFieldStats", "hChrBlockLen", "hChrHandlerSize", "hChrlFilterSize", "hChrFilStats", "hChrFilterCos", "hChrTransformSIZE", "hChrHandlerStyle", "hChcFilterPos", "hChrFieldS", "hChrFilSize", "hChrlFilterOffset", "hChrBufferStyle", "hChrFieldSize", "hChdrTransformLen", "hChrFilterStats", "hChrMaskSize", "hChrMaskSIZE", "hChrFormatSize", "hChcFilterSize", "hChrFilterStyle", "hChrHandlerLen", "hChrlFieldSize", "hChcBufferLen", "hChrFilterSIZE", "hChrHandlerPos", "hChdrTransformCos", "hChcBufferStyle", "hChrlFilterS", "hChrlFieldStats", "hChrlFilterStats", "hChrBufferLen", "hChrMaskCos", "hChcBufferPos", "hChrBufferSize", "hChrBlockPos", "hChrBlockStyle", "hChrFilterOffset", "hChrFilS", "hChdrFilterCos", "hChdrTransformSIZE", "hChdrFilterSize", "hChrBlockSize", "hChrTransformSize"], "formatConvBuffer": ["formatConviBuff", "formatEnvMatrix", "formatConVBuff", "formatconjBuffer", "formatConvPtr", "formatConviSize", "formatConvertMatrix", "formatConvBlock", "formatconvBuff", "formatEnvBuff", "formatconvBuffer", "formatConflTable", "formatconjComment", "formatEnVBuff", "formatConVMatrix", "formatConflBuff", "formatConjTable", "formatconvTable", "formatConvertText", "formatConvTable", "formatConjBuff", "formatConflBlock", "formatEnvBuffer", "formatConfBuff", "formatConVText", "formatConVSize", "formatConvertTable", "formatEnvertTable", "formatconvPtr", "formatConvText", "formatConcvTable", "formatConVbuffer", "formatEnVBuffer", "formatconjBuff", "formatConflComment", "formatConVBlock", "formatConjSize", "formatconjSize", "formatConVPtr", "formatEnvertText", "formatConvMatrix", "formatConjPtr", "formatconvSize", "formatConcvBuffer", "formatEnVTable", "formatConvertBuffer", "formatConvbuffer", "formatconjbuffer", "formatconvBlock", "formatEnVMatrix", "formatConfTable", "formatConviTable", "formatConvBuff", "formatconjBlock", "formatConviPtr", "formatConVBuffer", "formatConvComment", "formatConjBlock", "formatconvbuffer", "formatEnvertBuffer", "formatConviBuffer", "formatEnvText", "formatConjComment", "formatEnvertBuff", "formatEnvTable", "formatConfComment", "formatConVTable", "formatConcvBuff", "formatConjbuffer", "formatConviText", "formatconjTable", "formatConjBuffer", "formatConvSize", "formatConflBuffer", "formatconjPtr", "formatConcvMatrix", "formatconvComment", "formatConfBuffer", "formatConvertBuff", "formatConflbuffer"], "pal": ["vol", "pill", "local", "png", "ph", "pen", "attr", "pres", "pol", "what", "val", "sav", "pattern", " PAL", "el", "ass", "padding", "bat", "offset", "al", "sal", "Pal", "buffer", "isal", "cal", "theme", "scale", "alpha", "mat", "font", "quant", "conf", "pid", "flat", "style", "format", "pl", "dat", "qq", "color", "pack"]}}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void pl011_init(uint32_t base, qemu_irq irq,\n\n                CharDriverState *chr)\n\n{\n\n    int iomemtype;\n\n    pl011_state *s;\n\n\n\n    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));\n\n    iomemtype = cpu_register_io_memory(0, pl011_readfn,\n\n                                       pl011_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->chr = chr;\n\n    s->read_trigger = 1;\n\n    s->ifl = 0x12;\n\n    s->cr = 0x300;\n\n    s->flags = 0x90;\n\n    if (chr){ \n\n        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,\n\n                              pl011_event, s);\n\n    }\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 13114, "substitutes": {"base": ["bit", "index", "birth", "type", "f", "bs", "out", "ref", "handle", "size", "pi", "l", "address", "p", "x", "reset", "v", "bi", " bases", "source", "bid", "cpu", "k", "m", "memory", "kb", "parent", "prefix", "based", "use", "range", "buffer", "c", "db", "file", " Base", "bas", "pos", "bf", "bind", "b", "start", "h", "id", "root", "area", "set", "e", "state", "max", "mb", "se", "ma", "bp", "i", "init", "ca", "y", "pa", "Base", "ase"], "irq": ["virq", " irqs", " firqu", " irqu", " srqs", "iorqi", "iriq", " firq", "iriqu", " srqu", "ibrqu", "irqu", "iriqs", "ibrqs", " srq", "iorq", "ibrq", "irque", "iriqi", "virqs", " firdq", "iorch", " firqs", "irqs", "pirq", "pirch", "ircqu", "ibrch", "irqi", "iorque", "ibrqi", "ircq", "ircqi", " srdq", "ircqs", "pirqi", "ibrque", "pirque", "irch", "virqu", " irdq", "ibrdq", "virqi"], "chr": ["phR", "echrs", "ochrs", "Chrt", "Chrs", "clr", " chrs", "cher", "chrc", "chnr", "chert", " chrn", "chem", "schdr", "Chdr", "Chr", "ochrect", " chm", "clc", "chrt", "echrt", "cherar", "chR", "phr", "schrs", "echr", "schrt", "chrn", "cherr", "chdr", " chrect", "ochrt", "cherc", " chc", "Char", "ochr", "clrt", "chrect", "clm", "schrc", "schr", "cheR", "chnrt", "cherrn", "chec", "schR", "chrs", "chnrect", "phrt", "chm", "chc", "Chrn", "echdr", "cherrs", " chrt", "chnrs", "phrc"], "iomemtype": ["iometercat", "iomymTYPE", "iotemType", "iomomport", "iomomType", "iamomtype", "iomitemTYPE", "iomemstype", "iamomtypes", "iomemstypes", "iomomype", "iomemType", "iomitemType", "iotemtype", "iomimtemplate", "iomotorType", "xiemtype", "iomomtypes", "iomemtemplate", "iomotortypes", "iomitemtemplate", "iomemTYPE", "iomimtype", "iomimTYPE", "xiormport", "iomimType", "iomemcat", "iamomType", "iometerType", "iomemsype", "xiormcat", "iomormType", "iomormport", "iotemTYPE", "iamemtype", "iotymType", "iometertype", "iomymType", "iotymTYPE", "iometerport", "iamemtypes", "iamemype", "iomormtype", "iomomcat", "iamemType", "iotymtemplate", "iomormcat", "iomemype", "iomotortype", "iomemtypes", "iomotorype", "iomemport", "xiemcat", "iamomype", "iomitemtype", "xiormtype", "iomemsType", "xiemType", "iomomtype", "iotemtemplate", "iomymtemplate", "iomymtype", "xiemport", "iotymtype", "xiormType"], "s": ["status", "ses", "gs", "a", "S", "f", "settings", "o", "bs", "ports", "j", "l", "p", "js", "n", "sq", "actions", "g", "sl", "details", "ms", "store", "t", "source", "comm", "sm", "sv", "is", "sb", "spec", "sys", "als", "ds", "ls", "ats", "m", "sa", "r", "services", "so", "ts", "c", "stats", "vs", "ins", "states", "ns", "b", "ops", "h", "ims", "pers", "cs", "set", "e", "changes", "fs", "locks", "os", "its", "se", "z", "q", "sports", "i", "ss", "sts", "w", "y", "rs", "ps"]}}
{"project": "qemu", "commit_id": "dd09c36159858c66ab6e47c688e4177dd3912bf0", "target": 1, "func": "static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    gen_read_xer(cpu_gpr[gprn]);\n\n}\n", "idx": 13118, "substitutes": {"ctx": ["tx", "tc", "conn", "cm", " context", "hw", "js", "cmp", "cc", "CC", "np", "ct", "context", "obj", " cx", "c", "cb", "xc", "wd", "cp", "mc", "Context", "tmp", "conf", "px", "pkg", "ca", "txt", "voc"], "gprn": ["msprn", "mprN", "gvrl", " gpirn", "gpll", " gpirt", "gsprn", "gsprm", "gprm", " gpirnb", "gpirt", "gpirnr", "gsprl", "gprnr", "gsprt", " gprnb", "gpirn", " gpirnr", "gpln", "gpirnb", "gvrN", " gprnr", "mprm", "gplN", "gprl", "mprl", "msprl", "gsprN", " gprt", "gsprnr", "gstrt", "gprt", "msprN", "mprn", "gplm", "gprN", "msprm", "gvrn", "gprnb", "gstrn", "gstrnb", "gvrm", "gstrnr", "gsprnb"], "sprn": ["svn", "svnm", "prno", "sprno", "prnm", "prn", "sprN", "svN", " sprno", "svno", "prN", " sprnm", "sprnm", " sprN"]}}
{"project": "qemu", "commit_id": "f3c75d42adbba553eaf218a832d4fbea32c8f7b8", "target": 1, "func": "static int cpu_load_old(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    PowerPCCPU *cpu = opaque;\n\n    CPUPPCState *env = &cpu->env;\n\n    unsigned int i, j;\n\n    target_ulong sdr1;\n\n    uint32_t fpscr;\n\n    target_ulong xer;\n\n\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_betls(f, &env->gpr[i]);\n\n#if !defined(TARGET_PPC64)\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_betls(f, &env->gprh[i]);\n\n#endif\n\n    qemu_get_betls(f, &env->lr);\n\n    qemu_get_betls(f, &env->ctr);\n\n    for (i = 0; i < 8; i++)\n\n        qemu_get_be32s(f, &env->crf[i]);\n\n    qemu_get_betls(f, &xer);\n\n    cpu_write_xer(env, xer);\n\n    qemu_get_betls(f, &env->reserve_addr);\n\n    qemu_get_betls(f, &env->msr);\n\n    for (i = 0; i < 4; i++)\n\n        qemu_get_betls(f, &env->tgpr[i]);\n\n    for (i = 0; i < 32; i++) {\n\n        union {\n\n            float64 d;\n\n            uint64_t l;\n\n        } u;\n\n        u.l = qemu_get_be64(f);\n\n        env->fpr[i] = u.d;\n\n    }\n\n    qemu_get_be32s(f, &fpscr);\n\n    env->fpscr = fpscr;\n\n    qemu_get_sbe32s(f, &env->access_type);\n\n#if defined(TARGET_PPC64)\n\n    qemu_get_betls(f, &env->spr[SPR_ASR]);\n\n    qemu_get_sbe32s(f, &env->slb_nr);\n\n#endif\n\n    qemu_get_betls(f, &sdr1);\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_betls(f, &env->sr[i]);\n\n    for (i = 0; i < 2; i++)\n\n        for (j = 0; j < 8; j++)\n\n            qemu_get_betls(f, &env->DBAT[i][j]);\n\n    for (i = 0; i < 2; i++)\n\n        for (j = 0; j < 8; j++)\n\n            qemu_get_betls(f, &env->IBAT[i][j]);\n\n    qemu_get_sbe32s(f, &env->nb_tlb);\n\n    qemu_get_sbe32s(f, &env->tlb_per_way);\n\n    qemu_get_sbe32s(f, &env->nb_ways);\n\n    qemu_get_sbe32s(f, &env->last_way);\n\n    qemu_get_sbe32s(f, &env->id_tlbs);\n\n    qemu_get_sbe32s(f, &env->nb_pids);\n\n    if (env->tlb.tlb6) {\n\n        // XXX assumes 6xx\n\n        for (i = 0; i < env->nb_tlb; i++) {\n\n            qemu_get_betls(f, &env->tlb.tlb6[i].pte0);\n\n            qemu_get_betls(f, &env->tlb.tlb6[i].pte1);\n\n            qemu_get_betls(f, &env->tlb.tlb6[i].EPN);\n\n        }\n\n    }\n\n    for (i = 0; i < 4; i++)\n\n        qemu_get_betls(f, &env->pb[i]);\n\n    for (i = 0; i < 1024; i++)\n\n        qemu_get_betls(f, &env->spr[i]);\n\n    ppc_store_sdr1(env, sdr1);\n\n    qemu_get_be32s(f, &env->vscr);\n\n    qemu_get_be64s(f, &env->spe_acc);\n\n    qemu_get_be32s(f, &env->spe_fscr);\n\n    qemu_get_betls(f, &env->msr_mask);\n\n    qemu_get_be32s(f, &env->flags);\n\n    qemu_get_sbe32s(f, &env->error_code);\n\n    qemu_get_be32s(f, &env->pending_interrupts);\n\n    qemu_get_be32s(f, &env->irq_input_state);\n\n    for (i = 0; i < POWERPC_EXCP_NB; i++)\n\n        qemu_get_betls(f, &env->excp_vectors[i]);\n\n    qemu_get_betls(f, &env->excp_prefix);\n\n    qemu_get_betls(f, &env->ivor_mask);\n\n    qemu_get_betls(f, &env->ivpr_mask);\n\n    qemu_get_betls(f, &env->hreset_vector);\n\n    qemu_get_betls(f, &env->nip);\n\n    qemu_get_betls(f, &env->hflags);\n\n    qemu_get_betls(f, &env->hflags_nmsr);\n\n    qemu_get_sbe32s(f, &env->mmu_idx);\n\n    qemu_get_sbe32(f); /* Discard unused power_mode */\n\n\n\n    return 0;\n\n}\n", "idx": 13130, "substitutes": {"f": ["fw", "cf", "um", "lf", "ff", "l", "p", "fd", "rf", "F", "v", "g", "t", "fe", "mac", "fm", "ef", "sf", "fx", "y", "fb", "ac", "c", "tf", "fo", "fp", "file", "base", "bf", "b", "h", "fac", "fc", "fr", "e", "of", "fs", "conf", "ft", "d", "fi", "xf", "uf", "q", "fa", "x", "w", "full", "form", "af"], "opaque": ["coque", "opcow", "coaques", "oplque", "oplaque", "iopaque", " Opacity", "opacity", "pque", " Opaque", "Opaques", "cocow", "Opaque", "iopistine", "Opistine", "coaque", "opaques", "Opacity", "iopacity", "oplcow", "opistine", "iopaques", " Opaques", " Opistine", "paque", "paques", "opque", "oplaques", "pcow"], "version_id": [" version_i", " version_uid", "version_uid", " version_type", "version_type", "version_i"], "cpu": ["node", "cu", "pu", "CPU", "conn", "alloc", "pb", "ctx", "core", "p", "proc", "stat", "boot", "pool", "aco", "util", "cache", "np", "processor", "bench", "flow", "ork", "uma", "ola", "vm", "asus", "c", "apache", "gc", "cp", "nic", "device", "rom", "pc", " cp", "gpu", "ram", "net", "tp", "process", "pa", "anc", "clock"], "env": ["goal", "conn", "et", "manager", "cur", "attr", "ctx", "window", "operator", "opt", "engine", "den", "end", "policy", "context", "ern", "doc", "console", "en", "vs", "der", "gear", "param", "environment", "cmd", "erd", "v", "next", "spec", "ea", "menu", "obj", "extra", "eni", "inv", "db", "conf", "eng", "agent", "txt", "kernel", "equ", "server", "nv", "vv", "global", "ner", "ende", "req", "vp", "er", "common", "buf", "eur", "ten", "disk", "era", "org", "stage", "ec", "cookie", "dev", "eas", "enc", "config", "uv", "eh", "ev", "vt", "ote", "estate", "ei", "eve", "ent", "el", "esc", "ef", "ext", "desc", "ener", "ah", "ew", "vm", "runner", "chart", "event", "e", "order", "Environment", "entry", "w", "network", "viron", "worker"], "i": ["index", " li", " di", "depth", "cli", "gu", "t", "loop", " ki", "ami", "ai", "m", "xi", "qi", "iy", "ims", "my", "it", "us", "li", "oi", "ind", "ki", "n", "si", "zi", " ti", "v", "try", "g", "ui", "iq", " bi", "any", "set", "ti", "ex", "x", "ri", "ic", "span", "ix", "ip", "ij", "key", "mi", "ii", "I", "pi", "this", "uli", "batch", "di", " ii", "in", "ie", "sim", "info", "c", "ci", "you", "id", "multi", "me", "err", "init", "jp", "status", "iu", "o", "ski", "ini", "l", "ei", "p", "chain", "bi", "io", "is", "ia", "asi", "k", "hi", "\u0438", "e", "point", "list", "gi", "ity", "z", "q", "phi", "name", "y"], "j": ["jp", "ij", "li", "ni", "o", "ii", "n", "js", "p", "si", "v", "g", "bi", "uj", "k", "m", "ja", "J", "jj", "b", "jl", "jc", "ji", "it", "kj", "z", "q"], "sdr1": ["shr1", "sdr2", "SDr2", "tsdr0", "sDr6", "SDr1", "tsDR1", "Sdr01", "shr2", "sDR0", "tsdr1", "tsdr2", "sdr01", "sDR2", "slr1", "sDr2", "sdr0", "slr6", "sDr0", "Sdr1", "SDr01", "slr2", "sDr01", "shr01", "Sdr2", "sDR1", "sDr1", "tsDR0", "tsDR2", "sDR6", "tsdr6", "slr0", "tsDR6", "sdr6"], "fpscr": ["gradesrc", "bpsdr", " fpskr", " fpssr", "mskr", "fpsrc", "fpsCr", "ampssr", "gradescr", "bpscu", "framesrc", " fpsCr", "ampsrc", "fpssr", "fpskr", "bpsrc", "framescr", "msCr", "mscr", "bpssr", "bpskr", "bpscr", "interscr", "fpspr", "bpsCr", "mssr", "bpspr", "bpscd", "fpsci", "interscl", "fpscu", "bpsci", "fsrc", "ampspr", "fpsdr", "intersdr", "interscu", "fscu", "fsci", "framespr", "gradesci", "fscr", "gradescd", "fscd", "fsdr", "fscl", "fpscl", "ampscr", "fpscd", "bpscl", "framessr"], "xer": ["ixter", "uploadER", "Xor", "ixiner", "xor", "lexer", "uploade", " xeri", " xe", " xER", "lexerer", "ixor", " lexeri", " xor", "Xer", "uploader", " xter", " lexER", "plexER", "ixerer", "plexerer", "xER", "uploaderi", "ixER", "plexiner", "lexER", "XER", "xter", "plexer", "xeri", "xe", "xiner", "xerer", "Xter", " lexe", "ixer", "lexiner", " lexer"], "u": ["cu", "pu", "au", "um", "tu", "iu", "o", "out", "fu", "l", "p", " nu", "ut", "v", "user", "g", "t", "hu", "du", "ui", "util", "uid", "eu", "uc", "uu", "ud", "ue", "lu", "mu", "c", "up", "ul", "ou", "uv", "uf", "q", "U", "us", "nu", "su"]}}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoul_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 13136, "substitutes": {"str": ["Str", "f", "ptr", "out", "cur", "attr", "seq", "data", "pr", "ind", "tr", "dr", "text", "chain", "g", "test", "ctr", "t", "source", "len", "st", "msg", "end", "buf", "br", "r", "s", "doc", "buffer", "sp", "stri", "pos", "gr", "res", "print", "b", "input", "fr", "STR", "list", "length", "i", "txt", "arr"], "endptr": ["Endaddr", "endedPtr", "endedaddr", "endedctr", "endedtr", "ENDpointer", "endtr", "startptr", " endpointer", "Endpointer", "ENDptr", "Endptr", " endPtr", "endedobj", "endedptr", "ENDaddr", "ENDobj", "endctr", "ENDctr", "endedproc", " endtr", "EndPtr", "endproc", "starttr", "ENDPtr", "endPtr", "endpointer", "endaddr", "endobj", " endobj", "startpointer", "endedpointer", " endctr", "startproc", " endproc"], "err": ["resp", "errors", "rc", "error", "cr", "ptr", "lr", "usr", " typ", " ptr", " cr", "pr", "attr", " error", " Err", "tr", "dr", " wr", "cmp", " fr", "ind", "t", "er", "msg", "result", " terr", "diff", "sys", "nr", "act", "br", "Error", "r", "kr", " dr", " arr", " dist", "gr", "res", "oe", " er", "der", "Er", " res", "fr", " ni", "urg", " len", "iter", " rc", "rel", "here", " r", "i", "rr", "resh", "ch", "arr"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "static void avc_luma_midv_qrt_4w_msa(const uint8_t *src, int32_t src_stride,\n\n                                     uint8_t *dst, int32_t dst_stride,\n\n                                     int32_t height, uint8_t ver_offset)\n\n{\n\n    uint32_t loop_cnt;\n\n    v16i8 src0, src1, src2, src3, src4;\n\n    v16i8 mask0, mask1, mask2;\n\n    v8i16 hz_out0, hz_out1, hz_out2, hz_out3;\n\n    v8i16 hz_out4, hz_out5, hz_out6, hz_out7, hz_out8;\n\n    v8i16 dst0, dst1, dst2, dst3, dst4, dst5, dst6, dst7;\n\n\n\n    LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2);\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n\n\n    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src0, src1,\n\n                                                          mask0, mask1, mask2);\n\n    hz_out2 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3,\n\n                                                          mask0, mask1, mask2);\n\n\n\n    PCKOD_D2_SH(hz_out0, hz_out0, hz_out2, hz_out2, hz_out1, hz_out3);\n\n\n\n    hz_out4 = AVC_HORZ_FILTER_SH(src4, mask0, mask1, mask2);\n\n\n\n    for (loop_cnt = (height >> 2); loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src0, src1, src2, src3);\n\n        src += (4 * src_stride);\n\n        XORI_B4_128_SB(src0, src1, src2, src3);\n\n\n\n        hz_out5 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src0, src1,\n\n                                                              mask0, mask1,\n\n                                                              mask2);\n\n        hz_out7 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3,\n\n                                                              mask0, mask1,\n\n                                                              mask2);\n\n\n\n        PCKOD_D2_SH(hz_out5, hz_out5, hz_out7, hz_out7, hz_out6, hz_out8);\n\n\n\n        dst0 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out0, hz_out1, hz_out2,\n\n                                               hz_out3, hz_out4, hz_out5);\n\n        dst2 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out1, hz_out2, hz_out3,\n\n                                               hz_out4, hz_out5, hz_out6);\n\n        dst4 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out2, hz_out3, hz_out4,\n\n                                               hz_out5, hz_out6, hz_out7);\n\n        dst6 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out3, hz_out4, hz_out5,\n\n                                               hz_out6, hz_out7, hz_out8);\n\n\n\n        if (ver_offset) {\n\n            dst1 = __msa_srari_h(hz_out3, 5);\n\n            dst3 = __msa_srari_h(hz_out4, 5);\n\n            dst5 = __msa_srari_h(hz_out5, 5);\n\n            dst7 = __msa_srari_h(hz_out6, 5);\n\n        } else {\n\n            dst1 = __msa_srari_h(hz_out2, 5);\n\n            dst3 = __msa_srari_h(hz_out3, 5);\n\n            dst5 = __msa_srari_h(hz_out4, 5);\n\n            dst7 = __msa_srari_h(hz_out5, 5);\n\n        }\n\n\n\n        SAT_SH4_SH(dst1, dst3, dst5, dst7, 7);\n\n\n\n        dst0 = __msa_aver_s_h(dst0, dst1);\n\n        dst1 = __msa_aver_s_h(dst2, dst3);\n\n        dst2 = __msa_aver_s_h(dst4, dst5);\n\n        dst3 = __msa_aver_s_h(dst6, dst7);\n\n\n\n        PCKEV_B2_SB(dst1, dst0, dst3, dst2, src0, src1);\n\n        XORI_B2_128_SB(src0, src1);\n\n\n\n        ST4x4_UB(src0, src1, 0, 2, 0, 2, dst, dst_stride);\n\n\n\n        dst += (4 * dst_stride);\n\n        hz_out0 = hz_out4;\n\n        hz_out1 = hz_out5;\n\n        hz_out2 = hz_out6;\n\n        hz_out3 = hz_out7;\n\n        hz_out4 = hz_out8;\n\n    }\n\n}\n", "idx": 13137, "substitutes": {"src": ["rc", "ptr", "serv", "cur", "seq", "addr", "hz", "depth", "tr", "rl", "sur", "sq", "stat", "RC", "sl", "ctr", "syn", "source", "ipl", "loc", "sb", "st", "sec", "sys", "scan", "dist", "in", "s", "ix", "rt", "txt", "dest", "sr", "img", "std", "lat", "ins", "sync", "comp", "ser", "input", "tmp", "fc", "seek", "hl", "tp", "rx", "sn", "supp", "iv", "inst", "sc", "usr", "pkg", "rs", "sub"], "src_stride": ["src_strider", "src_grpe", "src_divid", "src_grope", "src_collice", "src_strride", "src_STRide", "src_trride", "src_divride", "src_brade", "src_drision", "src_slide", "src_strope", "src_trid", "src_strice", "src_drice", "src_drride", "src_strade", "src_strpe", "src_collide", "src_grride", "src_STRision", "src_collade", "src_brice", "src_drider", "src_slider", "src_drade", "src_strision", "src_frpe", "src_STRride", "src_gride", "src_divice", "src_strid", "src_STRope", "src_slision", "src_STRice", "src_STRpe", "src_slride", "src_fride", "src_STRid", "src_collride", "src_trice", "src_brride", "src_frride", "src_tride", "src_bride", "src_dride", "src_STRider", "src_frope", "src_divide"], "dst": [" ddest", "lsts", "ldest", "ddest", " dsts", "Dst", "Dsts", "Dest", "Ddest", "lst", "dest", " dest", "dsts", "lest"], "dst_stride": ["dst_strride", "dst_brate", "dst_decend", "dst_decide", "dst_bride", "dst_tride", "dst_trend", "dst_trride", "dst_strend", "dst_decate", "dst_strate", "dst_brend", "dst_decride", "dst_trate", "dst_brride"], "height": ["kw", "scroll", "density", "push", "size", "build", "scope", "ctx", "depth", "window", "radius", "hz", "row", "chain", "check", "ctr", "read", "padding", "wcs", "rank", "bottom", "k", "flow", "Height", "th", "headers", "resolution", "buffer", "block", "count", "capacity", "h", "grow", "conf", "hash", "length", "shape", "w", "x", "y", "angle", "zh", "history"], "ver_offset": ["stream_start", "verswstart", "verswlength", "ver2start", "ver_length", "verswoffset", "ver2length", "ver_start", "ver2offset", "stream_offset", "stream_length"], "loop_cnt": ["loop2cant", "loop_rst", "loop_cust", "loop2cpt", "loop2cnt", "loop_Ccount", "loop_cct", "loop_rnt", "loop_ctust", "loop_Cn", "loop2Cpt", "loop_fcNT", "loop_mcnt", "loop_count", "loop_fcpt", "loop2cct", "loop_cst", "loop_mcpt", "loop_fcnt", "loop_Cant", "loop_cpt", "loop_cant", "loop2Cct", "loop_countcount", "loop_mcNT", "loop_Cst", "loop2cst", "loop2count", "loop_rcct", "loop_rcst", "loop_Cust", "loop2cNT", "loop_fcant", "loop_mcant", "loop2CNT", "loop_countnt", "loop_rct", "loop2Cst", "loop_Cnt", "loop2Count", "loop_ccount", "loop_ctn", "loop_cNT", "loop_rcount", "loop2Cant", "loop_countn", "loop_Cpt", "loop_Cct", "loop2Cnt", "loop_CNT", "loop_Count", "loop_ctcount", "loop_rcnt", "loop_cn", "loop_countust", "loop_rount", "loop_ctnt"], "src0": ["rc1", "source4", " src00", "source5", "rc00", "sr00", "sr0", "source2", "src5", "rc3", "rc5", "st1", "sr4", "source3", "src00", "rc2", "sys2", "source0", "sr1", "source1", "st5", "rc4", "sys3", "st0", "sys0", "rc0", "sys1", "st2"], "src1": ["rc11", "rc1", "source11", "source4", "src11", "sys4", "source2", " src01", "rc3", "source3", "sr4", "rc2", "sr01", "sys2", "source0", "sr3", "rc01", "sr1", "src01", "source1", "rc4", "source01", "sys3", "sr11", "rc0", "sys1", "sr2"], "src2": ["sourceTwo", "rc1", "src02", "source4", "source5", "src6", "sys02", "sr02", "srTwo", "source2", "src5", "rc3", "rc5", "source3", "rc2", "sr5", "sys2", "sr3", "rc02", "rcTwo", "ser4", "sr1", "ser1", "source1", "rc4", "source6", "rc6", "ser2", "sys3", "srcTwo", "ser6", "sys1", "sr2"], "src3": ["rcThree", "ser03", "rc1", "addr3", " src03", "source5", "addr03", "sr43", "source2", "src5", "rc3", "rc5", "source3", "sr03", "ser3", "rc2", "rc43", "s", "sr5", "sr3", "source0", "source1", "addr2", "source43", "source03", "ser2", "_", "srcThree", "serThree", "src03", "src43", "addrThree", "rc0", "rc03", "sr2"], "src4": ["src54", "rc44", "rc1", " src40", " src6", "source4", "inst464", "source40", "src6", "rc14", "sub44", "src14", "rc54", "source2", "rc3", "sub54", "sr14", "source3", "sr4", "inst54", "inst4", "rc2", "sub4", "sr3", "sub464", "source14", "src44", "sc2", "source1", "rc4", "rc6", "src40", "inst44", "rc40", "sc6", "src464", "sc4", "rc464", "sr2"], "mask0": ["map0", "map8", "mask8", "mask5", "Mask0", "map1", " mask8", "mark2", "Mask2", "mark1", "key1", "Mask1", "ask2", "key0", "mark0", "ask5", "key5", " mask5", "ask1", "key2", "map2", "ask0", "Mask5", "ask8", "mark5"], "mask1": ["miss4", "permOne", "perm0", "ask3", "mark3", "missOne", "miss1", "perm2", "miss0", "mark2", "mask3", "mask4", "mark1", "ask2", "mark0", "miss2", " mask4", "perm1", "miss3", "ask1", "ask4", "ask0", " mask3", "maskOne", " maskOne"], "mask2": ["miss4", "miss8", "ask3", "mask8", "mark3", "miss1", "mark4", "miss0", " mask8", "mark2", "mask3", "mask4", "ask2", "mark0", "miss2", " mask4", "miss3", "ask1", "ask4", " mask3", "ask0", "ask8"], "hz_out0": ["hz_over1", "hz_off5", "hz_Out1", "hz_off1", "hz_OUT7", "hz_no1", "hz_no3", "hz_in3", "hz_in7", "hz_over0", "hz_in0", "hz_OUT3", "hz_Out3", "hz_over5", "hz_OUT5", "hz_Out0", "hz_OUT0", "hz_off0", "hz_in1", "hz_OUT1", "hz_no7", "hz_in5", "hz_no0"], "hz_out1": ["hztoutput3", "hz_bit1", "hz_in2", "hztout7", "hz_in3", "hztout1", "hz_outable", "hz_in7", "hz_in0", "hz_bitable", "hztoutput7", "hz_group5", "hz_output3", "hz_group3", "hztoutput5", "hz_group1", "hztoutput1", "hz_output5", "hz_bit0", "hz_bit2", "hz_in1", "hztout5", "hz_in5", "hz_output1", "hz_inable", "hz_output7", "hz_group7", "hztout3"], "hz_out2": ["hz__out3", "hz_in2", "hz__op3", "hz_outall", "hz_outb", "hz__op5", "hz_op3", "hz_back1", "hz_out32", "hz_op32", "hz_inall", "hz__out5", "hz_offall", "hz_output02", "hz__out32", "hz_inner2", "hz_innerb", "hz_outs3", "hz_in5", "hz_output2", "hz_outsall", "hz__out2", "hz_out02", "hz_clean5", "hz_backb", "hz_back2", "hz_outs2", "hz_output3", "hz_off3", "hz_in1", "hz_op5", "hz_output4", "hz_clean32", "hz_off1", "hz__op32", "hz_off4", "hz_in3", "hz_off2", "hz_clean3", "hz_op2", "hz_back5", "hz_outs1", "hz__op2", "hz_off02", "hz_inner5", "hz_inner1", "hz_inb", "hz_clean2"], "hz_out3": ["hz_no5", "hz_OUT7", "hz_OUT03", "hz_no3", "hz_out03", "hz_in3", "hz_in7", "hz_OUT3", "hz_OUT5", "hz_no03", "hz_OUT1", "hz_in1", "hz_in5", "hz_in03"], "hz_out4": ["hz_off1", "hz_in2", "hz_off4", "hz_in3", "hz_con3", "hz_in8", "hz_off2", "hz_con1", "hz_con2", "hz_OUT8", "hz_OUT2", "hz_off3", "hz_con4", "hz_OUT1", "hz_in1", "hz_OUT4", "hz_in4"], "hz_out5": ["hz_off5", "hz_output8", "hz_output6", "hz_output5", "hz_off8", "hz_output7", "hz_off7", "hz_off6"], "hz_out6": ["hz_over7", "hz_outSix", "hz_output2", "hz_output6", "hz_over2", "hz_over6", "hz_overSix", "hz_outputSix", "hz_output7"], "hz_out7": ["hz_net7", "hz_output6", "hz_outputr", "hz_outr", "hz_net6", "hz_output9", "hz_out9", "hz_net9", "hz_netr", "hz_output7"], "hz_out8": ["hz_int6", "hz_in8", "hz_in7", "hz_int8", "hz_int7", "hz_in6"], "dst0": ["dstop0", "dest1", "dest5", "dset5", "lst1", "lest0", "dset1", "lst3", "lest1", "dset3", "lest3", "dstop5", "lst0", "dest3", "dest0", "dstop3", "dstop1", "lst5", "lest5", "dset0"], "dst1": ["dest71", "dstr001", "dest1", "dstr1", "ddist71", "Dst001", "Dst71", "ddist1", "Dest0", "ddist001", "Dst0", "dest001", "dstr71", "dst71", "ddist0", "dest0", "Dest71", "Dst1", "dst001", "dstr0", "Dest001", "Dest1"], "dst2": ["dst02", " dst02", "dset02", " dset4", "dna4", "dna0", "dest02", " dset02", "dset4", "dest4", " dset2", "dest0", "dna02", " dset0", "dset2", "dna2", "dest2", "dset0"], "dst3": ["drest4", "dst23", " ddest3", " ddest2", "ddest3", " dst23", "ddest4", " ddest23", "drest23", "dest3", "dest4", "drest2", " ddest4", "ddest2", "drest3", "dest2", "dest23", "ddest23"], "dst4": ["dstoreCrit", "dstCrit", " dst414", " ddest2", " ddestCrit", "dstore414", "dstart4", "ddest4", " ddest414", "dst414", "dstore4", "dstart2", " dstCrit", "dstartCrit", "ddest414", "dstore2", "ddest2", " ddest4", "dstart414", "ddestCrit"], "dst5": [" dsp25", "dST7", "dST5", " dsp7", "dstr5", "dsp5", "dstr25", "dstr7", "dsp7", " dsp8", " dsp5", "dsp8", "dstr8", "dsp25", "dST8", "dST25", "dst8", " dst25", " dst8", "dst25"], "dst6": [" dint8", " dint6", "dst12", " dint12", "dST8", "dest8", "dst8", " dint4", "dint6", "dest4", "dint12", " dst8", "dest12", "dest6", "dST6", " dst12", "dST12", "dint4", "dint8", "dST4"], "dst7": [" dsp07", "dest1", " dsp7", " dst07", "dsp7", " dsp8", "dsp8", "dest8", "dst8", "dest07", " dsp1", "ddest8", "ddest07", " dst8", "ddest1", "dsp1", "ddest7", "dst07", "dsp07", "dest7"]}}
{"project": "qemu", "commit_id": "afcf905cff7971324c2706600ead35a1f41f417a", "target": 1, "func": "static void aml_free(gpointer data, gpointer user_data)\n\n{\n\n    Aml *var = data;\n\n    build_free_array(var->buf);\n\n\n}", "idx": 13140, "substitutes": {"data": ["bytes", "instance", "type", "ptr", "array", "ref", "attr", "map", "p", "window", "val", "user", "batch", "read", "buf", "bin", "da", "obj", "info", "reader", "mu", "buffer", "empty", "db", "all", "Data", "device", "table", "dev", "rec", "area", "ad", "pad", "d", "DATA", "ata", "dat", "name", "str"], "user_data": [" user_dat", " useruserdat", "useruserdata", " useruserbuffer", "useruserdat", "user_buffer", "user_dat", "useruserbuffer", " useruserdata", " user_buffer"], "var": ["node", "bar", "live", "type", "ptr", "vard", "array", "local", "ver", "attr", "map", "p", "grad", "row", "par", "temp", "val", "v", " variable", "let", "ar", "store", "box", "buf", "Var", "nav", "func", "cat", "tag", "r", "obj", "parse", "ars", "variable", "art", " Var", "star", "iter", "mod", "cast", "av", "name", "tab", "pack"]}}
{"project": "qemu", "commit_id": "36b15c79aa1bef5fe7543f9f2629b6413720bbfb", "target": 0, "func": "static void virtio_scsi_handle_cmd(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    /* use non-QOM casts in the data path */\n\n    VirtIOSCSI *s = (VirtIOSCSI *)vdev;\n\n    VirtIOSCSICommon *vs = &s->parent_obj;\n\n\n\n    VirtIOSCSIReq *req;\n\n    int n;\n\n\n\n    while ((req = virtio_scsi_pop_req(s, vq))) {\n\n        SCSIDevice *d;\n\n        int out_size, in_size;\n\n        if (req->elem.out_num < 1 || req->elem.in_num < 1) {\n\n            virtio_scsi_bad_req();\n\n        }\n\n\n\n        out_size = req->elem.out_sg[0].iov_len;\n\n        in_size = req->elem.in_sg[0].iov_len;\n\n        if (out_size < sizeof(VirtIOSCSICmdReq) + vs->cdb_size ||\n\n            in_size < sizeof(VirtIOSCSICmdResp) + vs->sense_size) {\n\n            virtio_scsi_bad_req();\n\n        }\n\n\n\n        if (req->elem.out_num > 1 && req->elem.in_num > 1) {\n\n            virtio_scsi_fail_cmd_req(req);\n\n            continue;\n\n        }\n\n\n\n        d = virtio_scsi_device_find(s, req->req.cmd->lun);\n\n        if (!d) {\n\n            req->resp.cmd->response = VIRTIO_SCSI_S_BAD_TARGET;\n\n            virtio_scsi_complete_req(req);\n\n            continue;\n\n        }\n\n        req->sreq = scsi_req_new(d, req->req.cmd->tag,\n\n                                 virtio_scsi_get_lun(req->req.cmd->lun),\n\n                                 req->req.cmd->cdb, req);\n\n\n\n        if (req->sreq->cmd.mode != SCSI_XFER_NONE) {\n\n            int req_mode =\n\n                (req->elem.in_num > 1 ? SCSI_XFER_FROM_DEV : SCSI_XFER_TO_DEV);\n\n\n\n            if (req->sreq->cmd.mode != req_mode ||\n\n                req->sreq->cmd.xfer > req->qsgl.size) {\n\n                req->resp.cmd->response = VIRTIO_SCSI_S_OVERRUN;\n\n                virtio_scsi_complete_req(req);\n\n                continue;\n\n            }\n\n        }\n\n\n\n        n = scsi_req_enqueue(req->sreq);\n\n        if (n) {\n\n            scsi_req_continue(req->sreq);\n\n        }\n\n    }\n\n}\n", "idx": 13149, "substitutes": {"vdev": ["vserial", " vdiv", "vpad", "wserial", "vmdiv", " vdevice", "vcpad", "vtech", " vpad", "vcdev", " vtech", "wserv", "avserial", "wdev", "vmpad", "vctech", " vserv", "vmdev", "vmtech", "vdevice", "wdevice", "avdev", "vdiv", "vcdiv", "avserv", " vserial", "vserv", "avdevice"], "vq": [" vreq", "vqs", "veq", "Vqi", " vqs", "vQ", "vqi", "svreq", "VQ", "vqueue", " vqueue", "wqueue", "wreq", " vue", " vQ", " vqi", "Vq", "vreq", "wqs", "wq", "svq", "svqs", "veQ", "Vue", "veue", "veqi", "vue", "svqueue"], "s": ["ses", "gs", "S", "serv", "bs", "less", "ys", "js", "p", "si", "sq", "v", "g", "t", "is", "sb", "sv", "spec", "sys", "hs", "ds", "ls", "m", "iss", "r", "ess", "gets", "ies", "ts", "self", "sp", "c", "b", "ns", "cs", "dev", "h", "fs", "os", "its", "ss", "news", "ms", "y", "i", "rs", "sts", "ps"], "vs": ["vo", "gs", "obs", "serv", "bs", "ves", "outs", "ys", "terms", "values", "js", "vr", "vp", "v", "xs", "lists", "nets", "Vs", "sv", "sys", "ds", "ires", "ls", "docs", "Rs", "vm", "vals", "inv", "stats", "caps", "ils", "ns", "ops", "cs", "changes", "fs", "os", "var", "its", "views", "vc", "vt", "ss", "news", "ms", "VS", "rs", "ps"], "req": ["query", "push", "ctx", "expr", "cmp", "sq", "bj", "compl", "task", "eq", "fresh", "nt", " resp", "cb", "require", "gr", "ack", "urg", "repl", "nil", "requ", "qt", "pkg", "exec", "required", "qq", "tx", "pro", "rem", "ptr", "prev", "wx", "ind", "cmd", "j", "crit", "test", "md", "comm", "xp", "iq", "wcs", "job", "cfg", "aux", "tek", "inv", "comp", "res", "term", "tmp", "conf", "txt", "resp", "rpm", "ref", "cond", "seq", "call", "proc", "ctr", "grab", "buf", "rb", "qa", "alg", "rep", "org", "Resp", "progress", "fr", "err", "quest", "rr", "jp", "request", "rss", "good", "reg", "pp", "msg", "ext", "desc", "r", "prefix", "range", "ck", "dq", "quick", "sp", "decl", "sel", "all", "rec", "rel", "var", "gz", "q", "needed"], "n": ["ation", "o", "l", "p", " count", "v", "g", "t", " N", "len", "k", "m", "N", "c", "count", "ns", "b", "h", "e", " len", "nb", "ne", "z", " nm", "nm", "name", "w", "y"], "d": ["des", "a", "f", "o", "out", "dn", "data", "j", "l", "p", "x", "dr", "D", "fd", "dm", "v", "g", "du", "t", "md", "di", "dos", "ed", "ds", "k", "m", "dd", "r", "dom", "gd", "bd", "dq", "dx", "c", "db", "b", "h", "id", "dev", "ad", "e", "u", "sd", "dh", "z", "dat", "w", "i", "did", "y", "ld", "ind"], "out_size": ["out_len", "out67fee", "out67size", "output_size", "to_size", "out_set", "outlensize", "out64fee", "outxweight", "out67set", "in_Size", "out67length", "out_weight", "out_storage", "out64Size", "out_length", "out0length", "output_height", "out_fee", "to64fee", "to_fee", "output_weight", "out0weight", "to_set", "out_height", "out64size", "outputxheight", "outlenstorage", "in_len", "out_Size", "outxlength", "outputxsize", "out67height", "out67weight", "out64set", "outlenSize", "out0size", "to64size", "outxheight", "in_storage", "to64set", "outputxweight", "outlenlen", "to_Size", "out0height", "output_length", "outxsize", "out67Size", "outputxlength", "to64Size"], "in_size": ["in68sent", "in_sent", "inner_speed", "injcache", "in64cache", "inner_cache", " in_weight", "in67len", "in_Size", "injsize", "in68SIZE", "inner64cache", "inner64speed", "in_name", "in68size", "in67Size", "in64size", " in_format", "inner_size", "in_len", " in_len", "in_weight", "inner64size", "injname", "in64name", "inner_name", "in_cache", "inner64name", "in68weight", "in_speed", " in_sent", "in_SIZE", "in_format", "injspeed", " in_SIZE", " in_Size", "in64speed", "in67format", "in67size"]}}
{"project": "qemu", "commit_id": "d82831dbc5471d72785c49b33710436af49bf9ca", "target": 0, "func": "CharDriverState *text_console_init(QemuOpts *opts)\n\n{\n\n    CharDriverState *chr;\n\n    QemuConsole *s;\n\n    unsigned width;\n\n    unsigned height;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n\n\n    width = qemu_opt_get_number(opts, \"width\", 0);\n\n    if (width == 0)\n\n        width = qemu_opt_get_number(opts, \"cols\", 0) * FONT_WIDTH;\n\n\n\n    height = qemu_opt_get_number(opts, \"height\", 0);\n\n    if (height == 0)\n\n        height = qemu_opt_get_number(opts, \"rows\", 0) * FONT_HEIGHT;\n\n\n\n    if (width == 0 || height == 0) {\n\n        s = new_console(NULL, TEXT_CONSOLE);\n\n    } else {\n\n        s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE);\n\n    }\n\n\n\n    if (!s) {\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n\n\n    s->chr = chr;\n\n    s->g_width = width;\n\n    s->g_height = height;\n\n    chr->opaque = s;\n\n    chr->chr_set_echo = text_console_set_echo;\n\n    return chr;\n\n}\n", "idx": 13154, "substitutes": {"opts": ["oprs", "OPouts", "royt", "oppouts", "otTS", "optouts", "oppds", "royvals", "OPTS", "opnt", "otts", "royTS", "otds", "prors", "opTS", "optiontions", "opt", "ott", "otvals", "ioptx", "opouts", "OPds", "ots", "optTS", "OPs", "opvals", "opds", "optvals", "optionnt", "oppts", "ioprs", "iopts", "opps", "ops", "optds", "OPts", "OPnt", "OPtions", "optps", "optt", "props", "royts", "optnt", "opttx", "prots", "optx", "options", "optrs", "optts", "iopps", "optionts", "opttions", "protx"], "chr": [" chp", "cherrb", " chrar", "echrc", "cher", "chrc", "thrb", " chrb", "ichrt", "achro", "Chr", "chner", "thr", "achl", "CHl", "chsr", "cherr", "chR", "echr", "achrt", "achR", "Chsr", "tchrt", "tchrb", " chsr", "cherner", "achrar", "ichrb", "schrb", "schar", "ichrd", "CHr", "chl", "tchr", "shrd", "chrb", "ichrar", "achrc", "chrar", "cherc", " chrc", "echrar", "ichrc", "echrs", "chers", "Chrb", "ichr", "chrt", "echrt", "achr", "cherp", " chner", "chrd", "Char", "shro", "Chp", "Chrc", "schsr", "chear", " chrt", "achrb", "chp", "tchrar", " chrs", " chR", "echar", "CHrb", "ichro", "Chner", "thsr", "shrt", "thrc", "chro", "schr", " chl", "shr", "chrs", "achrd", "CHR", "echrb"], "s": ["ses", "aws", "gs", "a", "S", "f", "bs", "socket", "less", "o", "l", "n", "p", "js", "sq", "conv", "v", "g", "sl", "bes", "t", "comm", "is", "sv", "sb", "als", "spec", "hs", "sys", "ds", "ats", "ls", "m", "r", "services", "acs", "ssl", "gets", "qs", "ts", "c", "stats", "vs", "ins", "ns", "b", "cs", "h", "ims", "es", "ops", "fs", "os", "bis", "aunts", "its", "se", "sports", "ss", "sts", "ms", "https", "i", "rs", "w", "ps"], "height": ["hang", "ty", "yt", "holes", "density", "size", "data", "high", "SIZE", "build", "row", "depth", "window", "radius", "hold", "rows", "inches", " heights", "xy", "details", "read", "help", "padding", "rank", "note", "title", "bottom", "strength", "heads", "Height", "th", "through", "hei", "dim", "range", "html", "resolution", "stroke", "buffer", "count", "capacity", "all", "lat", "no", "ht", "volume", "table", "alpha", "h", "grow", "draw", "ows", "hash", "length", "gravity", "shape", "total", "sky", "it", "style", "above", "y", "angle", "history", "ch"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    EEPRO100State *s = opaque;\n\n\n\n    switch (size) {\n\n    case 1: return eepro100_read1(s, addr);\n\n    case 2: return eepro100_read2(s, addr);\n\n    case 4: return eepro100_read4(s, addr);\n\n    default: abort();\n\n    }\n\n}\n", "idx": 13155, "substitutes": {"opaque": ["opue", " opatile", "OPatile", "iopatile", " opaques", " opue", "iopaque", "opane", "opacity", " opacity", " opane", " opque", "Opaque", "operane", "Opue", "OPaques", "operaque", "opaques", "Opacity", "Opane", "iopaques", "operue", "opatile", "iopque", "opque", "OPaque", "operacity", "OPque"], "addr": ["node", "tx", "at", "ptr", "phys", "src", "handle", "asm", "address", "data", "cmd", "ag", "hw", "p", "grad", "kt", "dr", "ord", "ctx", "adr", "added", "msg", "now", "offset", "r", "eth", "gate", "alt", "add", "info", "arch", "block", "pos", "coord", "res", "ack", "h", "id", "ad", "mt", "host", "iter", "pad", "state", "var", "dh", " address", "gz", "hash", "name", "rs", "ix", "alloc", "Address", "arp"], "size": ["Size", "type", "shift", "number", "address", "SIZE", "l", "n", "scope", "dimension", "unit", "len", "ize", "command", "offset", "align", "num", "zone", "message", "fee", "sha", "count", "capacity", "code", "scale", "grow", "weight", "length", "state", "shape", "ity", "style", "format", "small", "sn", "network", "sum"], "s": ["gs", "a", "S", "sw", "o", "less", "j", "p", "n", "js", "ex", "sq", "stat", "g", "sl", "ar", "sam", "comm", "sm", "sb", "is", "sv", "st", "spec", "hs", "space", "ds", "ls", "m", "y", "iss", "al", "ssl", "qs", "ts", "c", "sp", "ns", "an", "es", "h", "set", "fs", "os", "q", "i", "ss", "sts", "ms", "w", "rs"]}}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "bool vring_should_notify(VirtIODevice *vdev, Vring *vring)\n\n{\n\n    uint16_t old, new;\n\n    bool v;\n\n    /* Flush out used index updates. This is paired\n\n     * with the barrier that the Guest executes when enabling\n\n     * interrupts. */\n\n    smp_mb();\n\n\n\n    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&\n\n        unlikely(!vring_more_avail(vdev, vring))) {\n\n        return true;\n\n    }\n\n\n\n    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {\n\n        return !(vring_get_avail_flags(vdev, vring) &\n\n                 VRING_AVAIL_F_NO_INTERRUPT);\n\n    }\n\n    old = vring->signalled_used;\n\n    v = vring->signalled_used_valid;\n\n    new = vring->signalled_used = vring->last_used_idx;\n\n    vring->signalled_used_valid = true;\n\n\n\n    if (unlikely(!v)) {\n\n        return true;\n\n    }\n\n\n\n    return vring_need_event(vring_used_event(&vring->vr), new, old);\n\n}\n", "idx": 13156, "substitutes": {"vdev": ["vhome", "svobj", "vmdevice", "vDEV", "vmscan", "dpro", "hdev", "svdev", "svgo", " vev", "svhome", "vcev", "vgo", "svmem", "vmde", "veng", "verde", " vdevice", " vpro", "vcdev", "verdev", "svcast", "svDEV", "vde", "vcast", "voldev", "vcpro", " vdoc", "hde", "vdoc", "svde", "vmdev", " vde", "svdoc", " vhome", "sveng", " vcast", "voleng", "hscan", "vscan", "verdoc", "vdevice", " vmem", "vmem", "vermem", "vcde", " vgo", "volgo", "vobj", "vev", " vobj", " veng", "dev", "volcast", " vDEV", "hdevice", "vpro", "verhome", "ddev", " vscan", "dde", "verobj", "verDEV"], "vring": ["nthread", "svbox", " vbinding", "vbox", "convRing", " vding", "nbinding", "svding", "lray", " vng", "veray", "vebinding", "vreg", "vbinding", "verring", " vanting", "vpacking", "vvanting", "convram", "vng", "oray", "vining", "vanting", "svsetting", "vRing", " vRing", "varsetting", "varring", "vding", "formring", "veanting", "Vng", "avray", "vstar", "oRing", "qubinding", " vthread", "obinding", "veprefix", "formbinding", "verding", "Vram", "Vreg", "VRing", "verning", "avring", "vvprefix", "formanting", "formding", "varbox", "vsetting", "verbinding", " vstar", "quray", "convring", "uvining", "vning", " vsetting", "portstar", " vprefix", "svbinding", "vray", "quring", "convng", "oring", "svning", "lreg", " vpacking", "vprefix", " vray", "nring", "lring", " vreg", "Vding", "vthread", "lding", "uvray", " vbox", "avining", "vram", "avpacking", "lRing", "portring", "portthread", "uvpacking", "lbinding", "vering", "vvray", "svring", "vvring", "uvring", "portbinding", "quRing", " vram", " vning", "veding", "nstar", "varning", "lram", "Vring", " vining"], "old": [" low", "lower", "f", "o", "orig", "lf", "local", "same", "ind", "l", "back", "ard", "row", "older", "or", "other", "Old", "hold", "val", "low", "existing", "missing", "ar", "md", "used", "before", "read", "ed", "igh", "offset", "ob", "al", "r", "original", "last", "oved", "off", "ld", "en", " org", "no", "ov", "un", "id", "tmp", " orig", " Old", "ore", "from", "d", "uf", "bound", "i", "x", "OLD"], "new": ["index", "out", "latest", "size", "aw", "ren", "j", "n", "p", "x", "or", "val", "missing", "next", "t", "sv", "er", "added", "now", "fresh", "r", "ew", "update", "New", "current", "add", "recent", "create", "no", "on", "un", "b", "re", "set", "var", "from", "d", "to", "ne", "NEW", "news", "w", "valid", "only", "normal"], "v": ["vv", "f", "o", "out", "tv", "V", "l", "j", "n", "p", "vert", "g", "ig", "t", "sv", "k", "m", "y", "r", "s", "rev", "c", "inv", "cv", "ov", "b", "lv", "h", "u", "qv", "it", "d", "uv", "ve", "z", "q", "ev", "vt", "iv", "i", "av", "x", "w", "valid"]}}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static int amr_nb_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                               const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    AMRContext *s = avctx->priv_data;\n\n    int written, ret;\n\n    int16_t *flush_buf = NULL;\n\n    const int16_t *samples = frame ? (const int16_t *)frame->data[0] : NULL;\n\n\n\n    if (s->enc_bitrate != avctx->bit_rate) {\n\n        s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);\n\n        s->enc_bitrate = avctx->bit_rate;\n\n    }\n\n\n\n    if ((ret = ff_alloc_packet(avpkt, 32))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet\\n\");\n\n        return ret;\n\n    }\n\n\n\n    if (frame) {\n\n        if (frame->nb_samples < avctx->frame_size) {\n\n            flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));\n\n            if (!flush_buf)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(flush_buf, samples, frame->nb_samples * sizeof(*flush_buf));\n\n            samples = flush_buf;\n\n            if (frame->nb_samples < avctx->frame_size - avctx->delay)\n\n                s->enc_last_frame = -1;\n\n        }\n\n        if ((ret = ff_af_queue_add(&s->afq, frame)) < 0) {\n\n            av_freep(&flush_buf);\n\n            return ret;\n\n        }\n\n    } else {\n\n        if (s->enc_last_frame < 0)\n\n            return 0;\n\n        flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));\n\n        if (!flush_buf)\n\n            return AVERROR(ENOMEM);\n\n        samples = flush_buf;\n\n        s->enc_last_frame = -1;\n\n    }\n\n\n\n    written = Encoder_Interface_Encode(s->enc_state, s->enc_mode, samples,\n\n                                       avpkt->data, 0);\n\n    av_dlog(avctx, \"amr_nb_encode_frame encoded %u bytes, bitrate %u, first byte was %#02x\\n\",\n\n            written, s->enc_mode, frame[0]);\n\n\n\n    /* Get the next frame pts/duration */\n\n    ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,\n\n                       &avpkt->duration);\n\n\n\n    avpkt->size = written;\n\n    *got_packet_ptr = 1;\n\n    av_freep(&flush_buf);\n\n    return 0;\n\n}\n", "idx": 13163, "substitutes": {"avctx": ["avecf", "avtx", "vertx", "navcp", "vergc", "avercfg", "apctl", "wavctl", "vrcu", "vrctx", "navctx", "avetmp", "averhistory", "avercontext", "ajcfg", "savcp", "savctl", "avpkg", "wavkw", "avtmp", "wavhistory", "savcu", "avecb", "vercontext", "avkw", "afpkg", "aptx", "devtx", "avhistory", "avertx", "wavcomp", " avcu", " avcontext", " avctl", "avcfg", "ajca", " avcf", "wavctx", "vrcontext", "savcomp", " avgc", "afctl", "savctx", "avcb", "devctl", "avecontext", " avconf", "aftx", "wavcu", "ajcp", "devtmp", "avetx", "avgc", " avcp", "averctl", "avercomp", "verctx", "ajtmp", "abctx", " avcfg", "avertmp", "savhistory", "averca", "avecfg", "averkw", "avcu", "avecu", "navcfg", " avconn", "apctx", "AVctx", "savcontext", "afcf", "afcontext", "ajcontext", "abctl", "devctx", "savkw", "vrtx", "avcp", "avecp", "afctx", "averctx", "abtmp", "apcontext", "avconf", "wavconf", "ajcb", "avconn", "avca", "AVtmp", "avercu", "aveca", "aveconn", "avercb", " avpkg", "avctl", "wavcontext", "avcontext", "avepkg", "avegc", "AVcfg", "averconf", "ajctx", "ajconn", " avtx", "navtmp", "averconn", "savconn", "AVtx", "avectx", "avcf", "wavconn", "avercp", "avcomp", "abtx"], "avpkt": ["AVnpkt", "avpft", "AVpkt", "avcdu", "avpcvc", "avnpett", " avpdu", "avpsett", "avpcwd", "avnpvc", "avpdu", "avwpacket", "avnpacket", "AVnpvc", "awpkg", "awnpft", "AVpvc", " avcet", "avpwd", "avnpkg", "avpskg", "avpkg", "avnpdu", "avmet", "avnpet", "awnpkt", "avipkt", "avipft", "avpacket", "avwpkt", "awpft", " avpet", "AVpwd", "avwpwd", "avmdu", "avmctx", "avpckt", " avpctx", "avipett", " avcdu", "avnpkt", "AVnpacket", "avpctx", "avnpwd", "avwpvc", "avnpft", "awpkt", "avpvc", "AVnpwd", "avnpctx", "avpet", "avmkt", " avcctx", "avpsft", "avpcacket", "awpett", "avckt", "avpskt", "awnpkg", "avcet", " avckt", "avipkg", "AVpacket", "awnpett", "avpett", "avcctx"], "frame": ["header", "sequence", "window", "raw", "t", "close", "new", "command", "send", "flow", "line", "channel", "context", "word", "function", "fram", "iframe", "draw", "trace", "length", "ence", "queue", "normal", "error", "ime", "data", "cmd", "module", "reset", "next", "frames", "rame", "fb", "open", "sample", "cf", "face", "f", "row", "feat", "fe", "show", "offset", "zone", "info", "buffer", "block", "remote", "file", "fr", "scene", "from", "state", "package", "process", "force", "profile", "request", "output", "size", "response", "video", "feature", "message", "none", "time", " framed", "range", "image", "event", "code", "Frame", "point", "ace", "e", "component", "expected", "ce"], "got_packet_ptr": ["got_packettpointers", "got_packettptr", "got_packet2handle", "got_packet_handle", "got_packet2pointers", "got_packettpointer", "got_packetthandle", "got_packacket_ptr", "got_packet_pointers", "got_packacket_handle", "got_packet2pointer", "got_packacket_pointer", "got_packacket_pointers", "got_packet_pointer", "got_packet2ptr"], "s": ["ses", "gs", "S", "settings", "bs", "ports", "sq", "sl", "sam", "t", "st", "ssl", "qs", "stats", "sh", "vs", "cs", "ims", "its", "ants", "ps", "sw", "j", "js", "v", "g", "ar", "spec", "space", "ds", "ats", "sa", "obj", "services", "sc", "so", "self", "args", "set", "conf", "i", "a", "f", "as", "less", "utils", "sm", "sb", "als", "sys", "hs", "ess", "c", "es", "changes", "fs", "se", "ss", "l", "p", "is", "sv", "ls", "r", "ts", "sp", "ins", "ns", "b", "h", "os", "z", "sts", "ms", "y", "rs"], "written": ["bytes", "rew", "ritten", "output", "recorded", "writ", "itted", "started", "ll", "writing", "held", "n", "created", "connected", "changed", "built", "initialized", "wrote", "done", "Written", "encrypted", "read", "rote", "msg", "write", "led", "cooked", "assembled", "writer", "db", "loaded", "checked", "Writ", "found", "worked", "called", "printed", "w", "generated", "sent", "finished"], "ret": ["resp", "status", "rem", "def", "mem", "out", "success", "ref", "det", "ll", "fun", "back", "Ret", "tr", "reply", "temp", "rets", "after", "RET", "reset", "val", "try", "reg", "wrote", "t", "len", "read", "rm", "result", "write", "ext", "nt", "get", "alt", "gt", "last", "att", "got", "rt", "rev", "mel", "run", "rot", "res", "print", "mat", "re", "mt", "rel", "cont", "ft", "it", "elt", "err", "format", " Ret", "del", "value", "fin", "str", "sent", "finished", "arr"], "flush_buf": ["flushmmblock", "flushxbuff", " flush_pkg", "flush0addr", "flush_cb", "sync_buffer", " flush_cmd", "flush64buf", "flush55req", "flush_img", "sync_buff", "flush_fam", "flush_uf", "flush0buff", "send_buff", "flush55seq", "flushmyseq", "export64block", "ush_uf", "flush0queue", "rubxbuf", "reset_fac", "reset_pkg", "rub_buff", "flushmmbag", "flushmybin", "rub_bg", "flush2queue", "ush_seq", "ush_mu", "flush_queue", "flush67cmd", "flush64cmd", "flushablebuf", "flush55cb", "flush_req", "flush55buf", "usher55cb", "flushorimg", "ush_bin", "flush67buf", "export_bag", "flush_block", "flush2buf", "usher55buf", "flushtmu", "flush67err", "usher_buf", "flush_addr", "export_cmd", "flushmmcmd", "flush_fac", "export64bag", " flush_uf", "flushmmbuf", "flush_iter", "sync_queue", " flush_err", "send_buf", "sync_buf", "flush0buf", "flushtcb", "flush64block", "usher_req", "usher55req", "flushorbuf", "send_func", "ush_fam", "flush2buffer", " flush_cap", "flush_bin", "flush_cmd", "export64cmd", "ush_buff", "flush_err", "ush_cb", "flush64bag", "rubxbg", "flush2cap", "flush_cap", "flushablecb", "usher_uf", "flush_vec", "flush2func", "reset_buf", "flushxbuf", "flush_buffer", "ush_buffer", "rubxbuff", "flushtbuffer", "rub_buf", "export64buf", "flush_seq", "rubximg", "sync_addr", "flushablefunc", "export_buf", " flush_buffer", "flush_mu", "flush_func", "sync_func", "flush_bag", "flushorbg", "flushablebuff", "export_block", "flush55uf", "flushorbuff", "flushmybuf", "flush_bg", "usher55uf", "flush55fam", "usher_cb", "flush2uf", "flush67pkg", "flush_pkg", "flushximg", "reset_iter", "ush_buf", "flushtbuf", "flush_buff", "flushmyfam", "flushxbg", "rub_img", "send_cb", "flush55bin", "ush_vec"], "samples": ["saces", "Samples", "assicks", "samp", "Samps", "Sounds", " sides", " samp", "ssamples", "stringsaces", " sales", "saves", "Sales", "asspaces", "stringsamps", "ments", "ssaves", "spaces", "Sents", " sicks", "sales", "Saves", "sents", " samps", "Samp", " saves", "stringsamples", "mamps", "Saces", "ssamps", "stringsents", " sents", "sicks", " sounds", "sounds", "assamps", "Sides", "assamples", "sides", " spaces", "ssamp", "mamples", " saces", "samps", "mounds"]}}
{"project": "qemu", "commit_id": "97f90cbfe810bb153fc44bde732d9639610783bb", "target": 0, "func": "void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,\n\n                          int is_asi, int size)\n\n{\n\n    CPUState *saved_env;\n\n    /* XXX: hack to restore env in all cases, even if not called from\n\n       generated code */\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n    qemu_log(\"Unassigned \" TARGET_FMT_plx \" wr=%d exe=%d\\n\",\n\n             addr, is_write, is_exec);\n\n    if (!(env->sregs[SR_MSR] & MSR_EE)) {\n\n        return;\n\n    }\n\n\n\n    if (is_exec) {\n\n        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    } else {\n\n        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    }\n\n}\n", "idx": 13172, "substitutes": {"addr": ["tx", "arp", "at", "ptr", "ref", "src", "handle", "address", "data", "pat", "ctx", "attr", "hw", "x", "kt", "call", "tr", "dr", "cmd", "adr", "offset", "align", "act", "r", "eth", "obj", "oa", "add", "rt", "aro", "res", "coord", "alias", "id", "ad", "host", "mt", "ace", "hash", "dh", " address", "name", "alloc", "Address", "ip"], "is_write": ["isopread", "is_writ", "is_writing", "is___wr", "is___write", "is_read", " is_read", "isopwrite", "isopwriting", "is___writing", "is___read", " is_wr", "is_wr", " is_writing", "isopwr", " is_writ"], "is_exec": ["is___exec", " is_Exec", "isableexe", " is_ext", " is_execute", " is_exe", "is_read", " is_read", "isableec", "isableexec", " is_internal", "is_execute", "is_internal", "isableinternal", "is___internal", " is_ec", "is___ec", "is_ext", "is_ec", "is_exe", "is___exe", "is_Exec"], "is_asi": ["is__data", "is__sa", "is__ai", "is2asi", "is__asi", "is_data", "Is_ai", "is2sa", "Is_asi", "is2data", "Is_sa", "is_sa", "is2ai", "Is_data", "is_ai"], "size": ["rc", "Size", "mem", "address", "data", "SIZE", "mode", "len", "loc", "ize", "izes", "offset", "send", "fee", "sha", "count", "ffff", "scale", "args", "id", "area", "length", "shape", "name", "alloc"], "saved_env": ["save_en", "save_conn", "saved_conn", "save_env", "saved_state", "saved_en", "save_buf", "saved_buf"]}}
{"project": "FFmpeg", "commit_id": "9340a99588c2bf6209b5c396df15b893c4b576b5", "target": 1, "func": "static int RENAME(swScale)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dst[], int dstStride[]){\n\n\n\n\t/* load a few things into local vars to make the code more readable? and faster */\n\n\tconst int srcW= c->srcW;\n\n\tconst int dstW= c->dstW;\n\n\tconst int dstH= c->dstH;\n\n\tconst int chrDstW= c->chrDstW;\n\n\tconst int chrSrcW= c->chrSrcW;\n\n\tconst int lumXInc= c->lumXInc;\n\n\tconst int chrXInc= c->chrXInc;\n\n\tconst int dstFormat= c->dstFormat;\n\n\tconst int srcFormat= c->srcFormat;\n\n\tconst int flags= c->flags;\n\n\tconst int canMMX2BeUsed= c->canMMX2BeUsed;\n\n\tint16_t *vLumFilterPos= c->vLumFilterPos;\n\n\tint16_t *vChrFilterPos= c->vChrFilterPos;\n\n\tint16_t *hLumFilterPos= c->hLumFilterPos;\n\n\tint16_t *hChrFilterPos= c->hChrFilterPos;\n\n\tint16_t *vLumFilter= c->vLumFilter;\n\n\tint16_t *vChrFilter= c->vChrFilter;\n\n\tint16_t *hLumFilter= c->hLumFilter;\n\n\tint16_t *hChrFilter= c->hChrFilter;\n\n\tint32_t *lumMmxFilter= c->lumMmxFilter;\n\n\tint32_t *chrMmxFilter= c->chrMmxFilter;\n\n\tconst int vLumFilterSize= c->vLumFilterSize;\n\n\tconst int vChrFilterSize= c->vChrFilterSize;\n\n\tconst int hLumFilterSize= c->hLumFilterSize;\n\n\tconst int hChrFilterSize= c->hChrFilterSize;\n\n\tint16_t **lumPixBuf= c->lumPixBuf;\n\n\tint16_t **chrPixBuf= c->chrPixBuf;\n\n\tconst int vLumBufSize= c->vLumBufSize;\n\n\tconst int vChrBufSize= c->vChrBufSize;\n\n\tuint8_t *funnyYCode= c->funnyYCode;\n\n\tuint8_t *funnyUVCode= c->funnyUVCode;\n\n\tuint8_t *formatConvBuffer= c->formatConvBuffer;\n\n\tconst int chrSrcSliceY= srcSliceY >> c->chrSrcVSubSample;\n\n\tconst int chrSrcSliceH= -((-srcSliceH) >> c->chrSrcVSubSample);\n\n\tint lastDstY;\n\n        uint8_t *pal=NULL;\n\n\n\n\t/* vars whch will change and which we need to storw back in the context */\n\n\tint dstY= c->dstY;\n\n\tint lumBufIndex= c->lumBufIndex;\n\n\tint chrBufIndex= c->chrBufIndex;\n\n\tint lastInLumBuf= c->lastInLumBuf;\n\n\tint lastInChrBuf= c->lastInChrBuf;\n\n\t\n\n\tif(isPacked(c->srcFormat)){\n\n                pal= src[1];\n\n\t\tsrc[0]=\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= src[0];\n\n\t\tsrcStride[0]=\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= srcStride[0];\n\n\t}\n\n\tsrcStride[1]<<= c->vChrDrop;\n\n\tsrcStride[2]<<= c->vChrDrop;\n\n\n\n//\tprintf(\"swscale %X %X %X -> %X %X %X\\n\", (int)src[0], (int)src[1], (int)src[2],\n\n//\t\t(int)dst[0], (int)dst[1], (int)dst[2]);\n\n\n\n#if 0 //self test FIXME move to a vfilter or something\n\n{\n\nstatic volatile int i=0;\n\ni++;\n\nif(srcFormat==PIX_FMT_YUV420P && i==1 && srcSliceH>= c->srcH)\n\n\tselfTest(src, srcStride, c->srcW, c->srcH);\n\ni--;\n\n}\n\n#endif\n\n\n\n//printf(\"sws Strides:%d %d %d -> %d %d %d\\n\", srcStride[0],srcStride[1],srcStride[2],\n\n//dstStride[0],dstStride[1],dstStride[2]);\n\n\n\n\tif(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)\n\n\t{\n\n\t\tstatic int firstTime=1; //FIXME move this into the context perhaps\n\n\t\tif(flags & SWS_PRINT_INFO && firstTime)\n\n\t\t{\n\n\t\t\tav_log(c, AV_LOG_WARNING, \"SwScaler: Warning: dstStride is not aligned!\\n\"\n\n\t\t\t\t\t\"SwScaler:          ->cannot do aligned memory acesses anymore\\n\");\n\n\t\t\tfirstTime=0;\n\n\t\t}\n\n\t}\n\n\n\n\t/* Note the user might start scaling the picture in the middle so this will not get executed\n\n\t   this is not really intended but works currently, so ppl might do it */\n\n\tif(srcSliceY ==0){\n\n\t\tlumBufIndex=0;\n\n\t\tchrBufIndex=0;\n\n\t\tdstY=0;\t\n\n\t\tlastInLumBuf= -1;\n\n\t\tlastInChrBuf= -1;\n\n\t}\n\n\n\n\tlastDstY= dstY;\n\n\n\n\tfor(;dstY < dstH; dstY++){\n\n\t\tunsigned char *dest =dst[0]+dstStride[0]*dstY;\n\n\t\tconst int chrDstY= dstY>>c->chrDstVSubSample;\n\n\t\tunsigned char *uDest=dst[1]+dstStride[1]*chrDstY;\n\n\t\tunsigned char *vDest=dst[2]+dstStride[2]*chrDstY;\n\n\n\n\t\tconst int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input\n\n\t\tconst int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input\n\n\t\tconst int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input\n\n\t\tconst int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input\n\n\n\n//printf(\"dstY:%d dstH:%d firstLumSrcY:%d lastInLumBuf:%d vLumBufSize: %d vChrBufSize: %d slice: %d %d vLumFilterSize: %d firstChrSrcY: %d vChrFilterSize: %d c->chrSrcVSubSample: %d\\n\",\n\n// dstY, dstH, firstLumSrcY, lastInLumBuf, vLumBufSize, vChrBufSize, srcSliceY, srcSliceH, vLumFilterSize, firstChrSrcY, vChrFilterSize,  c->chrSrcVSubSample);\n\n\t\t//handle holes (FAST_BILINEAR & weird filters)\n\n\t\tif(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;\n\n\t\tif(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;\n\n//printf(\"%d %d %d\\n\", firstChrSrcY, lastInChrBuf, vChrBufSize);\n\n\t\tASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)\n\n\t\tASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)\n\n\n\n\t\t// Do we have enough lines in this slice to output the dstY line\n\n\t\tif(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>c->chrSrcVSubSample))\n\n\t\t{\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf < lastLumSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n//\t\t\t\tprintf(\"%d %d %d %d\\n\", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n//\t\t\t\tprintf(\"%d %d\\n\", lumBufIndex, vLumBufSize);\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->lumMmx2Filter, c->lumMmx2FilterPos, pal);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf < lastChrSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY < (chrSrcSliceH))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)\n\n\t\t\t\t//FIXME replace parameters through context struct (some at least)\n\n\n\n\t\t\t\tif(!(isGray(srcFormat) || isGray(dstFormat)))\n\n\t\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->chrMmx2Filter, c->chrMmx2FilterPos, pal);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t}\n\n\t\telse // not enough lines left in this slice -> load the rest in the buffer\n\n\t\t{\n\n/*\t\tprintf(\"%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\\n\",\n\n\t\t\tfirstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,\n\n\t\t\tlastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,\n\n\t\t\tvChrBufSize, vLumBufSize);*/\n\n\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf+1 < srcSliceY + srcSliceH)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->lumMmx2Filter, c->lumMmx2FilterPos, pal);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf+1 < (chrSrcSliceY + chrSrcSliceH))\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY < chrSrcSliceH)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)\n\n\n\n\t\t\t\tif(!(isGray(srcFormat) || isGray(dstFormat)))\n\n\t\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->chrMmx2Filter, c->chrMmx2FilterPos, pal);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t\tbreak; //we can't output a dstY line so let's try with the next slice\n\n\t\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t\tb5Dither= dither8[dstY&1];\n\n\t\tg6Dither= dither4[dstY&1];\n\n\t\tg5Dither= dither8[dstY&1];\n\n\t\tr5Dither= dither8[(dstY+1)&1];\n\n#endif\n\n\t    if(dstY < dstH-2)\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n#ifdef HAVE_MMX\n\n\t\tint i;\n\n            if(flags & SWS_ACCURATE_RND){\n\n                        for(i=0; i<vLumFilterSize; i+=2){\n\n                                lumMmxFilter[2*i+0]= (int32_t)lumSrcPtr[i  ];\n\n                                lumMmxFilter[2*i+1]= (int32_t)lumSrcPtr[i+(vLumFilterSize>1)];\n\n                                lumMmxFilter[2*i+2]=\n\n                                lumMmxFilter[2*i+3]= vLumFilter[dstY*vLumFilterSize + i    ]\n\n                                                + (vLumFilterSize>1 ? vLumFilter[dstY*vLumFilterSize + i + 1]<<16 : 0);\n\n                        }\n\n                        for(i=0; i<vChrFilterSize; i+=2){\n\n                                chrMmxFilter[2*i+0]= (int32_t)chrSrcPtr[i  ];\n\n                                chrMmxFilter[2*i+1]= (int32_t)chrSrcPtr[i+(vChrFilterSize>1)];\n\n                                chrMmxFilter[2*i+2]=\n\n                                chrMmxFilter[2*i+3]= vChrFilter[chrDstY*vChrFilterSize + i    ]\n\n                                                + (vChrFilterSize>1 ? vChrFilter[chrDstY*vChrFilterSize + i + 1]<<16 : 0);\n\n                        }\n\n            }else{\n\n\t\tfor(i=0; i<vLumFilterSize; i++)\n\n\t\t{\n\n\t\t\tlumMmxFilter[4*i+0]= (int32_t)lumSrcPtr[i];\n\n\t\t\tlumMmxFilter[4*i+1]= (uint64_t)lumSrcPtr[i] >> 32;\n\n\t\t\tlumMmxFilter[4*i+2]= \n\n\t\t\tlumMmxFilter[4*i+3]= \n\n\t\t\t\t((uint16_t)vLumFilter[dstY*vLumFilterSize + i])*0x10001;\n\n\t\t}\n\n\t\tfor(i=0; i<vChrFilterSize; i++)\n\n\t\t{\n\n\t\t\tchrMmxFilter[4*i+0]= (int32_t)chrSrcPtr[i];\n\n\n\t\t\tchrMmxFilter[4*i+2]= \n\n\t\t\tchrMmxFilter[4*i+3]= \n\n\t\t\t\t((uint16_t)vChrFilter[chrDstY*vChrFilterSize + i])*0x10001;\n\n\t\t}\n\n            }\n\n#endif\n\n\t\tif(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tRENAME(yuv2nv12X)(c,\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, dstW, chrDstW, dstFormat);\n\n\t\t}\n\n\t\telse if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12 like\n\n\t\t{\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t *lumBuf = lumPixBuf[0];\n\n\t\t\t\tint16_t *chrBuf= chrPixBuf[0];\n\n\t\t\t\tRENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW, chrDstW);\n\n\t\t\t}\n\n\t\t\telse //General YV12\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2yuvX)(c,\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, uDest, vDest, dstW, chrDstW);\n\n\t\t\t}\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB\n\n\t\t\t{\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\t\t\t\tRENAME(yuv2packed1)(c, *lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, chrAlpha, dstFormat, flags, dstY);\n\n\t\t\t}\n\n\t\t\telse if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB\n\n\t\t\t{\n\n\t\t\t\tint lumAlpha= vLumFilter[2*dstY+1];\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n                                lumMmxFilter[2]=\n\n                                lumMmxFilter[3]= vLumFilter[2*dstY   ]*0x10001;\n\n                                chrMmxFilter[2]=\n\n                                chrMmxFilter[3]= vChrFilter[2*chrDstY]*0x10001;\n\n\t\t\t\tRENAME(yuv2packed2)(c, *lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, lumAlpha, chrAlpha, dstY);\n\n\t\t\t}\n\n\t\t\telse //General RGB\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2packedX)(c,\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, dstW, dstY);\n\n\t\t\t}\n\n\t\t}\n\n            }\n\n\t    else // hmm looks like we can't use MMX here without overwriting this array's tail\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\tif(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2nv12XinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, dstW, chrDstW, dstFormat);\n\n\t\t}\n\n\t\telse if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12\n\n\t\t{\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2yuvXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, vDest, dstW, chrDstW);\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tyuv2packedXinC(c, \n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, dstW, dstY);\n\n\t\t}\n\n\t    }\n\n\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n#endif\n\n\t/* store changed local vars back in the context */\n\n\tc->dstY= dstY;\n\n\tc->lumBufIndex= lumBufIndex;\n\n\tc->chrBufIndex= chrBufIndex;\n\n\tc->lastInLumBuf= lastInLumBuf;\n\n\tc->lastInChrBuf= lastInChrBuf;\n\n\n\n\treturn dstY - lastDstY;\n\n}", "idx": 13204, "substitutes": {"c": ["rc", "cu", "ce", "co", "tc", "f", "cr", "at", "cm", "unc", "ca", "cur", "cn", "lc", "l", "ctx", "p", "cmp", "call", "cc", "conv", "v", "chain", "g", "ar", "t", "comm", "ic", "wcs", "com", "dc", "cache", "ct", "cam", "cation", "ac", "C", "cb", "cv", "xc", "abc", "nc", "ci", "ec", "comp", "cp", "b", "gc", "cs", "bc", "mc", "etc", "pc", "fc", "e", "con", "conf", "enc", "col", "config", "err", "vc", "w", "sc", "coll", "cont", "ch"], "src": ["rc", "sw", "serv", "cur", "seed", "stream", "sq", "filename", "conv", "sl", "ctr", "source", "loc", "sb", "st", "sys", "usc", "sel", "sr", "img", "ser", "iv", "sn", "inst", "sc", "sub", "outh"], "srcStride": ["rcRestope", "rcRestide", "srcRestope", "srcSlope", "rcStope", "srcSlride", "srcSlide", "rcRestride", "rcStride", "rcStide", "srcShride", "srcShide", "srcRestide", "srcShope", "srcRestride", "srcStope", "srcStide"], "srcSliceY": ["srcSlgeB", "srcSlideB", "srcSlsliceB", "srcSlgeX", "srcSliceX", "srcSlsliceY", "srcSlideW", "srcSlideY", "srcSlgeY", "srcSlgeW", "srcSlsliceW", "srcSlsliceX", "srcSliceB", "srcSliceW", "srcSlideX"], "srcSliceH": ["srcSlitchU", "srcSlitchW", "srcSlideU", "srcSlsliceY", "srcSlideW", "srcSlideH", "srcSliceU", "srcSlideY", "srcSlsliceU", "srcSlsliceH", "srcSlsliceW", "srcSlitchH", "srcSlitchY", "srcSliceW"], "dst": ["ddest", "dissl", "Dst", "dissc", "adsl", "adst", "Ddest", "disdest", "dsl", "adsc", "addest", "Dsc", "dsc", "Dsl", "disst"], "dstStride": ["dstRestride", "dstRestr", "dstrStr", "dstSlide", "dststride", "dstrSlrobe", "dstrStide", "dststr", "dstrStride", "dstStide", "dstrSlide", "dststrobe", "dstrSlr", "dstSlr", "dstStrobe", "dstStr", "dstRestrobe", "dstSlrobe", "dstrSlride", "dstrStrobe", "dstSlride", "dstRestide", "dststide"], "vLumFilterPos": ["vLumFilterLen", "vLumFileDef", "vLumBlockPos", "vLumFilterCol", "vLumFieldPos", "vLomBufferDef", "vLumRuleSp", "vLumBufferPos", "vLummFieldP", "vLumFileCol", "vLummFilterPos", "vLumBufferDef", "vLummFieldPos", "vLumFilDef", "vLomBufferPos", "vLumBufferNeg", "vLomBufferNeg", "vLumFieldP", "vLumFilterP", "vLumBlockP", "vLumFieldLen", "vLomFilterPos", "vLummFieldSp", "vLummFilterP", "vLumBlockSp", "vLumFilNeg", "vLumFileNeg", "vLummFilterSp", "vLumFilePos", "vLumFieldSp", "vLumRulePos", "vLumBufferCol", "vLummFilterLen", "vLumFilCol", "vLomFilterCol", "vLummFieldLen", "vLomFilterNeg", "vLomFilterDef", "vLumRuleP", "vLumFilPos", "vLumFilterNeg", "vLomBufferCol", "vLumFilterDef", "vLumFilterSp", "vLumRuleLen", "vLumBlockLen"], "vChrFilterPos": ["vChrFilterDir", "vChrFilNum", "vChrPatternPos", "vChrFilDir", "vChmControlPos", "vChrPatternDir", "vChmFilterNum", "vChrManagerVol", "vChrHandlerDir", "vChmPatternVol", "vChrManagerPos", "vChrControlNum", "vChrControlDir", "vChmFilterDir", "vChrHandlerNum", "vChrFilterPOS", "vChmFilterVol", "vChrFilterVol", "vChrManagerDir", "vChrHandlerPos", "vChrPatternVol", "vChmControlNum", "vChmFilterPOS", "vChrControlPos", "vChrPatternPOS", "vChrProfileVol", "vChmControlDir", "vChmFilterPos", "vChrProfilePos", "vChmPatternPos", "vChrManagerPOS", "vChmPatternPOS", "vChrFilPos", "vChrFilterNum", "vChrProfileDir", "vChrProfilePOS", "vChmPatternDir"], "hLumFilterPos": ["hLumFormatSec", "hLumbTransformPos", "hLumFormatFix", "hLumpFilterFix", "hLumFormatDef", "hLumpControlSec", "hLumFormatPos", "hLumbTransformDef", "hLumListenerSec", "hLumpControlPos", "hLumControlFix", "hLumpControlFix", "hLumbTransformLoc", "hLumFilterSec", "hLumpFilterPos", "hLumTransformPos", "hLumControlPos", "hLumpFilterObj", "hLumbFilterDef", "hLumFilterDef", "hLumFilterObj", "hLumFormatObj", "hLumListenerObj", "hLumControlSec", "hLumbTransformDir", "hLumFilterFix", "hLumpFilterSec", "hLumControlObj", "hLumbFilterPos", "hLumFilterLoc", "hLumListenerFix", "hLumbFilterLoc", "hLumpControlObj", "hLumListenerPos", "hLumFormatDir", "hLumTransformLoc", "hLumTransformDir", "hLumbFilterDir", "hLumFormatLoc", "hLumTransformDef", "hLumFilterDir"], "hChrFilterPos": ["hChrSpiderPos", "hChrfilterPos", "hChrFilterSpec", "hChrRulePos", "hChrFilterSize", "hChmHandlerOpen", "hChcTransformId", "hChrfilterRes", "hChrTransformPos", "hChcTransformSize", "hChmHandlerRes", "hChrTransformId", "hChmHandlerPos", "hChrSpiderId", "hChrChannelPos", "hChrSpiderSpec", "hChrRuleId", "hChrFilterRes", "hChrFilterOpen", "hChrChannelRes", "hChcFilterSpec", "hChrRuleSize", "hChmFilterRes", "hChrChannelOpen", "hChmFilterOpen", "hChcTransformPos", "hChrRuleSpec", "hChcFilterPos", "hChrSpiderSize", "hChcFilterSize", "hChcTransformSpec", "hChmFilterPos", "hChrfilterOpen", "hChrHandlerPos", "hChrHandlerOpen", "hChrTransformSpec", "hChrFilterId", "hChrTransformSize", "hChcFilterId", "hChrHandlerRes"], "vLumFilter": ["vLumbFormat", "vLumFormat", "vLumaSort", "vLumaHandler", "vLamSort", "vLomHandler", "vLumaFilter", "vLamTarget", "vLandumFilter", "vLandumaFormat", "vMumaTarget", "vLumHandler", "vLandumHandler", "vMumaSort", "vLumbfilter", "vLomFormat", "vLumbHandler", "vLumbFilter", "vMumFilter", "vLandumafilter", "vLumaTarget", "vLumSort", "vLomFilter", "vLumafilter", "vLumTarget", "vLamFilter", "vLandumfilter", "vLumbSort", "vLumbTarget", "vLomfilter", "vLandumaHandler", "vLumaFormat", "vMumTarget", "vLandumFormat", "vLumfilter", "vMumSort", "vMumaFilter", "vLandumaFilter"], "vChrFilter": ["vChmFil", "vChdrFil", "vChuFrame", "vChrQuery", "vCharFil", "vComprFrame", "vComprfilter", "vChrbFilter", "vChcrQuery", "vCompuFrame", "vChrbfilter", "vColmQuery", "vChmQuery", "vColmFilter", "vChufilter", "vChuFil", "vChdrFilter", "vCompuFil", "vChrFrame", "vCompuFilter", "vColrFil", "vComprFil", "vChrbFrame", "vChrbFil", "vCompufilter", "vCharQuery", "vChcrFilter", "vColrFilter", "vComprFilter", "vChcrFil", "vChdrfilter", "vChrfilter", "vColmFil", "vCharFilter", "vChmFilter", "vChrFil", "vChdrFrame", "vChuFilter", "vColrQuery"], "hLumFilter": ["hLumChain", "hLulChain", "hLainFil", "hLainFilter", "hLainChain", "hLumFF", "hLulFilter", "hLumRule", "hLoomFil", "hLulStream", "hILulRule", "hElumStream", "hLumaQuery", "hElulStream", "hLoomRule", "hLomFilter", "hLomQuery", "hLomStream", "hLulRule", "hILumFil", "hElumFF", "hLoomFilter", "hILulFilter", "hLumQuery", "hElulFilter", "hILumFilter", "hElumQuery", "hLumFil", "hLulFil", "hLoomChain", "hILulChain", "hLainRule", "hLulQuery", "hLumaFilter", "hILulFil", "hILumRule", "hLumaFF", "hElulQuery", "hILumChain", "hLumaStream", "hElumFilter", "hLumStream", "hElulFF", "hLulFF", "hLomFF"], "hChrFilter": ["hChuHandler", "hGrrTransform", "hShrbFrame", "hChcrTransform", "hShrFormat", "hGruTransform", "hChrtFormat", "hChmFilter", "hChtTransform", "hChrbFrame", "hChmSort", "hGruSort", "hChtSort", "hChrFrame", "hChuTransform", "hChcrFrame", "hShrFilter", "hChuFilter", "hChcrFilter", "hGruHandler", "hChtHandler", "hChrTransform", "hChmHandler", "hChcrFormat", "hGrrHandler", "hGrrFilter", "hChuSort", "hShrbTransform", "hChtFilter", "hChrHandler", "hChmTransform", "hGrrSort", "hShrbFormat", "hChrbTransform", "hChrbFilter", "hShrFrame", "hGruFilter", "hShrbFilter", "hChrbFormat", "hShrTransform", "hChrtFilter", "hChrtFrame", "hChrSort", "hChrtTransform", "hChrFormat"], "lumMmxFilter": ["lumBmxFil", "lumRmxFilter", "lumMmxConfig", "lumMoxConfig", "lumBmxHandler", "lumRmmfilter", "lumMdrHash", "lumMnzFil", "lumBmxFilter", "lumMnzFilter", "lumBnzFilter", "lumMmnHash", "lumMoxfilter", "lumMmmFilter", "lumBnzFil", "lumBnzHash", "lumMmxHandler", "lumMmmfilter", "lumMdrFil", "lumRmxFormat", "lumMixFormat", "lumMmxFormat", "lumMmnFil", "lumMmnHandler", "lumRmmConfig", "lumMmmConfig", "lumMdrFilter", "lumMnzHash", "lumRmmFilter", "lumMmmFormat", "lumMixfilter", "lumMmxfilter", "lumRmxConfig", "lumMoxFilter", "lumMmxFil", "lumMixConfig", "lumMixFilter", "lumBmxHash", "lumRmxfilter", "lumMmxHash", "lumBnzHandler", "lumMoxFormat", "lumMmnFilter", "lumMnzHandler", "lumRmmFormat", "lumMdrHandler"], "chrMmxFilter": ["chrMemmicHandler", "chrMemmxFil", "chrMmacTransform", "chrMMXFilter", "chrMemmxFilter", "chrMoxCheck", "chrEoxCheck", "chrEmxTransform", "chrEmxFilter", "chrMMXTest", "chrMoxTest", "chrEmxCheck", "chrMemmxTarget", "chrMmxCheck", "chrMMXCheck", "chrEoxTest", "chrMmmTarget", "chrMssFilter", "chrEoxFilter", "chrMssTarget", "chrMmicHandler", "chrMmicTarget", "chrMoxFilter", "chrMemmicFil", "chrEoxTransform", "chrMoxTransform", "chrMmxTest", "chrMMXTransform", "chrMmicFil", "chrMmacFilter", "chrMemmxHandler", "chrMmxTransform", "chrMmmFil", "chrEmxTest", "chrMmmFilter", "chrMmxHandler", "chrMmxFil", "chrMssHandler", "chrMmacCheck", "chrMmacTest", "chrMssFil", "chrMemmicTarget", "chrMemmicFilter", "chrMmxTarget", "chrMmicFilter", "chrMmmHandler"], "lumPixBuf": ["lumPfxBbuf", "lumPixCbuf", "lumPfxPuff", "lumPfxBrc", "lumPixBust", "lumPfxBust", "lumPixBufferrc", "lumPixCust", "lumPixBufferuff", "lumPixRust", "lumPfxPrc", "lumPixRuff", "lumPixBuff", "lumPfxBuf", "lumPixBufferbuf", "lumPixPust", "lumPfxPust", "lumPfxPbuf", "lumPixBrc", "lumPixPrc", "lumPfxBuff", "lumPixBbuf", "lumPixPbuf", "lumPixPuf", "lumPixRbuf", "lumPixCuf", "lumPixCrc", "lumPixPuff", "lumPixBufferuf", "lumPfxPuf", "lumPixCuff", "lumPixRuf"], "chrPixBuf": ["chrPixCust", "chrPixCux", "chrPxBuf", "chrPxBux", "chrPixPust", "chrPixBux", "chrPixCuf", "chrPfxPix", "chrPixBix", "chrPxPux", "chrPixPux", "chrPfxPuff", "chrPixCuff", "chrPfxBuff", "chrPxPust", "chrPixBufferuff", "chrPixPix", "chrPixBufferuf", "chrPixPuff", "chrPxBuff", "chrPfxPuf", "chrPfxBix", "chrPixBufferust", "chrPixBufferux", "chrPixBust", "chrPixDuf", "chrPxPuff", "chrPixBuff", "chrPixPuf", "chrPixDix", "chrPxBust", "chrPfxBuf", "chrPixDuff", "chrPxPuf"]}}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME(bgr24ToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_BGR24);\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        int b= src[i*3+0];\n\n        int g= src[i*3+1];\n\n        int r= src[i*3+2];\n\n\n\n        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);\n\n    }\n\n#endif /* COMPILE_TEMPLATE_MMX */\n\n}\n", "idx": 13205, "substitutes": {"dst": ["Dst", "dstr", " dbl", "Dbl", "disST", "ddest", "destr", " dsts", "dissts", "hbl", "ltr", "disstr", "Dist", "hist", "lst", "Ddest", "dist", "bdest", " ddest", "ldest", "dbl", "btr", " dist", "dest", " dest", "dsts", " dstr", "deST", "best", "hdest", "bst", " dtr", "dST", "dests", "hst", "dtr", "lest", " dST", "disst"], "src": ["ipp", "rc", "view", "impl", "ptr", "sw", "bs", "usr", "cur", "seq", "stock", "RC", "rl", "sur", "bh", "sq", "req", "proc", "lib", "sl", "ctr", "syn", "source", "ipl", "loc", "sb", "st", "via", "sec", "np", "ur", "rb", "sys", "usc", "in", "scan", "r", "times", "s", "obj", "iro", "ssl", "txt", "decl", "dest", "img", "sr", "ins", "ser", "input", "inner", "spe", "iter", "hl", "sn", "supp", "iv", "inst", "sc", "str", "rs", "sub"], "unused": ["Unchecked", "unchecked", " unchecked", "Unuse", " unuse", "UNused", "UNchecked", "Unused", "UNuse", "unuse"], "i": ["status", "index", "key", "li", "ij", "f", "iu", "o", "ski", "mi", "ii", "I", "pi", "ini", " j", "j", "ind", "p", "ki", "uri", "ei", "si", "l", "zi", "n", "name", "v", "cli", "chain", "uli", "bi", "batch", "port", "t", "is", "ui", "ic", "di", "ami", "asi", "ai", "m", "r", "xi", "qi", "sim", "info", "im", "\u0438", "ci", "h", "id", "ims", "ti", "oi", "point", "ri", "multi", "it", "gi", "ji", "me", "ma", "z", "phi", "init", "y", "span", "ix", "ip"]}}
{"project": "FFmpeg", "commit_id": "f78cd0c243b9149c7f604ecf1006d78e344aa6ca", "target": 1, "func": "void FUNC(ff_simple_idct)(DCTELEM *block)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 8; i++)\n\n        FUNC(idctRowCondDC)(block + i*8);\n\n\n\n    for (i = 0; i < 8; i++)\n\n        FUNC(idctSparseCol)(block + i);\n\n}\n", "idx": 13230, "substitutes": {"block": ["tx", "instance", "def", "ref", "out", "data", "map", "j", "row", "window", "group", "proc", "chain", "check", "load", "box", "cl", "lock", "context", "blocks", "Block", "off", "ck", "buffer", "mm", "event", "byte", "link", "no", "b", "bl", "client", "bc", "id", "set", "point", "hl", "list", "ip", "commit", "BL", "pack"], "i": ["index", " li", " di", "cli", " pi", "PI", "ai", "m", " I", "s", "xi", "qi", "ims", "my", "it", "ji", "us", "li", "by", "oi", "ind", "j", "ki", "si", "zi", " ti", "v", "try", "g", "ui", "iq", " bi", "im", "print", "ti", "fi", "x", "ri", "ic", "ex", "ix", "span", "ip", "ij", "key", "at", "ii", "mi", "I", "pi", " si", "uli", "batch", "mac", "di", " ii", " mi", "in", "sim", "c", "ci", " wi", " ni", "multi", "me", "err", " err", "ni", "iu", " j", "ini", "ei", "l", "bi", "io", "is", "asi", "hi", "\u0438", " multi", "e", "gi", " m", "q", "phi", "init", "ms", "y"]}}
{"project": "qemu", "commit_id": "f53c398aa603cea135ee58fd15249aeff7b9c7ea", "target": 1, "func": "static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev)\n\n{\n\n    if (ohci->async_td &&\n\n        ohci->usb_packet.owner != NULL &&\n\n        ohci->usb_packet.owner->dev == dev) {\n\n        usb_cancel_packet(&ohci->usb_packet);\n\n        ohci->async_td = 0;\n\n    }\n\n}\n", "idx": 13236, "substitutes": {"ohci": ["ohdi", " ohcont", "ohcu", "hci", "ehli", "oshci", "ohlc", "ehai", " ohcci", " ohco", "oshli", "okdi", "ouchdi", "hrcci", "ehci", "ihai", "ouchlc", "ohcont", "ehco", "ihpi", " ohdi", "hrco", "heredi", "Ohpi", "Ohli", "ohco", "ehpi", "Ohcci", "okcu", "hhai", "ehcci", "ihcci", "hhcci", "ohpi", "oshcci", "hlc", "hereci", "hli", "ehdi", "ouchli", "hdi", "okcci", "hhpi", "ohli", "okci", "ehcont", "hrdi", "hcu", "hcci", "ihci", "ohai", "ohcci", "hhci", "hcont", "herecu", "hrci", "oshpi", "herecci", "Ohci", " ohli", "ouchci", "ehlc"], "dev": ["pro", "def", "des", "mem", "DEV", "conn", "serv", "go", "ver", "pub", "addr", "hw", "usb", "raw", "Dev", "dis", "val", "v", "Device", "test", "md", "comm", "spec", "hid", "priv", "loc", "buf", "nt", "cam", "desc", "eth", "att", "obj", "doc", "dem", "wid", "od", "device", "adv", "serial", "rel", "app", "d", "ve", "ev", "tm", "w", "av", "ch", "tech"]}}
{"project": "FFmpeg", "commit_id": "fd0f45e58b010c0d7049914a392c3e96a2223107", "target": 1, "func": "static int av_encode(AVFormatContext **output_files,\n\n                     int nb_output_files,\n\n                     AVFormatContext **input_files,\n\n                     int nb_input_files,\n\n                     AVStreamMap *stream_maps, int nb_stream_maps)\n\n{\n\n    int ret, i, j, k, n, nb_istreams = 0, nb_ostreams = 0;\n\n    AVFormatContext *is, *os;\n\n    AVCodecContext *codec, *icodec;\n\n    AVOutputStream *ost, **ost_table = NULL;\n\n    AVInputStream *ist, **ist_table = NULL;\n\n    AVInputFile *file_table;\n\n    AVFormatContext *stream_no_data;\n\n    int key;\n\n\n\n    file_table= (AVInputFile*) av_mallocz(nb_input_files * sizeof(AVInputFile));\n\n    if (!file_table)\n\n        goto fail;\n\n\n\n    /* input stream init */\n\n    j = 0;\n\n    for(i=0;i<nb_input_files;i++) {\n\n        is = input_files[i];\n\n        file_table[i].ist_index = j;\n\n        file_table[i].nb_streams = is->nb_streams;\n\n        j += is->nb_streams;\n\n    }\n\n    nb_istreams = j;\n\n\n\n    ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *));\n\n    if (!ist_table)\n\n        goto fail;\n\n    \n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = av_mallocz(sizeof(AVInputStream));\n\n        if (!ist)\n\n            goto fail;\n\n        ist_table[i] = ist;\n\n    }\n\n    j = 0;\n\n    for(i=0;i<nb_input_files;i++) {\n\n        is = input_files[i];\n\n        for(k=0;k<is->nb_streams;k++) {\n\n            ist = ist_table[j++];\n\n            ist->st = is->streams[k];\n\n            ist->file_index = i;\n\n            ist->index = k;\n\n            ist->discard = 1; /* the stream is discarded by default\n\n                                 (changed later) */\n\n\n\n            if (ist->st->codec.rate_emu) {\n\n                ist->start = av_gettime();\n\n                ist->frame = 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* output stream init */\n\n    nb_ostreams = 0;\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        nb_ostreams += os->nb_streams;\n\n    }\n\n    if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n\n        fprintf(stderr, \"Number of stream maps must match number of output streams\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Sanity check the mapping args -- do the input files & streams exist? */\n\n    for(i=0;i<nb_stream_maps;i++) {\n\n        int fi = stream_maps[i].file_index;\n\n        int si = stream_maps[i].stream_index;\n\n        \n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > file_table[fi].nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find input stream #%d.%d\\n\", fi, si);\n\n            exit(1);\n\n        }\n\n    }\n\n    \n\n    ost_table = av_mallocz(sizeof(AVOutputStream *) * nb_ostreams);\n\n    if (!ost_table)\n\n        goto fail;\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = av_mallocz(sizeof(AVOutputStream));\n\n        if (!ost)\n\n            goto fail;\n\n        ost_table[i] = ost;\n\n    }\n\n    \n\n    n = 0;\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++) {\n\n            int found;\n\n            ost = ost_table[n++];\n\n            ost->file_index = k;\n\n            ost->index = i;\n\n            ost->st = os->streams[i];\n\n            if (nb_stream_maps > 0) {\n\n                ost->source_index = file_table[stream_maps[n-1].file_index].ist_index + \n\n                    stream_maps[n-1].stream_index;\n\n                    \n\n                /* Sanity check that the stream types match */\n\n                if (ist_table[ost->source_index]->st->codec.codec_type != ost->st->codec.codec_type) {\n\n                    fprintf(stderr, \"Codec type mismatch for mapping #%d.%d -> #%d.%d\\n\",\n\n                        stream_maps[n-1].file_index, stream_maps[n-1].stream_index,\n\n                        ost->file_index, ost->index);\n\n                    exit(1);\n\n                }\n\n                \n\n            } else {\n\n                /* get corresponding input stream index : we select the first one with the right type */\n\n                found = 0;\n\n                for(j=0;j<nb_istreams;j++) {\n\n                    ist = ist_table[j];\n\n                    if (ist->discard && \n\n                        ist->st->codec.codec_type == ost->st->codec.codec_type) {\n\n                        ost->source_index = j;\n\n                        found = 1;\n\n                    }\n\n                }\n\n                \n\n                if (!found) {\n\n                    /* try again and reuse existing stream */\n\n                    for(j=0;j<nb_istreams;j++) {\n\n                        ist = ist_table[j];\n\n                        if (ist->st->codec.codec_type == ost->st->codec.codec_type) {\n\n                            ost->source_index = j;\n\n                            found = 1;\n\n                        }\n\n                    }\n\n                    if (!found) {\n\n                        fprintf(stderr, \"Could not find input stream matching output stream #%d.%d\\n\",\n\n                                ost->file_index, ost->index);\n\n                        exit(1);\n\n                    }\n\n                }\n\n            }\n\n            ist = ist_table[ost->source_index];\n\n            ist->discard = 0;\n\n        }\n\n    }\n\n\n\n    /* for each output stream, we compute the right encoding parameters */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        ist = ist_table[ost->source_index];\n\n\n\n        codec = &ost->st->codec;\n\n        icodec = &ist->st->codec;\n\n\n\n        if (ost->st->stream_copy) {\n\n            /* if stream_copy is selected, no need to decode or encode */\n\n            codec->codec_id = icodec->codec_id;\n\n            codec->codec_type = icodec->codec_type;\n\n            codec->codec_tag = icodec->codec_tag;\n\n            codec->bit_rate = icodec->bit_rate;\n\n            switch(codec->codec_type) {\n\n            case CODEC_TYPE_AUDIO:\n\n                codec->sample_rate = icodec->sample_rate;\n\n                codec->channels = icodec->channels;\n\n                break;\n\n            case CODEC_TYPE_VIDEO:\n\n                codec->frame_rate = icodec->frame_rate;\n\n                codec->frame_rate_base = icodec->frame_rate_base;\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                break;\n\n            default:\n\n                av_abort();\n\n            }\n\n        } else {\n\n            switch(codec->codec_type) {\n\n            case CODEC_TYPE_AUDIO:\n\n                if (fifo_init(&ost->fifo, 2 * MAX_AUDIO_PACKET_SIZE))\n\n                    goto fail;\n\n                \n\n                if (codec->channels == icodec->channels &&\n\n                    codec->sample_rate == icodec->sample_rate) {\n\n                    ost->audio_resample = 0;\n\n                } else {\n\n                    if (codec->channels != icodec->channels &&\n\n                        icodec->codec_id == CODEC_ID_AC3) {\n\n                        /* Special case for 5:1 AC3 input */\n\n                        /* and mono or stereo output      */\n\n                        /* Request specific number of channels */\n\n                        icodec->channels = codec->channels;\n\n                        if (codec->sample_rate == icodec->sample_rate)\n\n                            ost->audio_resample = 0;\n\n                        else {\n\n                            ost->audio_resample = 1;\n\n                            ost->resample = audio_resample_init(codec->channels, icodec->channels,\n\n                                                        codec->sample_rate, \n\n                                                        icodec->sample_rate);\n\n\t\t\t    if(!ost->resample)\n\n\t\t\t      {\n\n\t\t\t\tprintf(\"Can't resample.  Aborting.\\n\");\n\n\t\t\t\tav_abort();\n\n\t\t\t      }\n\n                        }\n\n                        /* Request specific number of channels */\n\n                        icodec->channels = codec->channels;\n\n                    } else {\n\n                        ost->audio_resample = 1; \n\n                        ost->resample = audio_resample_init(codec->channels, icodec->channels,\n\n                                                        codec->sample_rate, \n\n                                                        icodec->sample_rate);\n\n\t\t\tif(!ost->resample)\n\n\t\t\t  {\n\n\t\t\t    printf(\"Can't resample.  Aborting.\\n\");\n\n\t\t\t    av_abort();\n\n\t\t\t  }\n\n                    }\n\n                }\n\n                ist->decoding_needed = 1;\n\n                ost->encoding_needed = 1;\n\n                break;\n\n            case CODEC_TYPE_VIDEO:\n\n                if (codec->width == icodec->width &&\n\n                    codec->height == icodec->height &&\n\n                    frame_topBand == 0 &&\n\n                    frame_bottomBand == 0 &&\n\n                    frame_leftBand == 0 &&\n\n                    frame_rightBand == 0)\n\n                {\n\n                    ost->video_resample = 0;\n\n                    ost->video_crop = 0;\n\n                } else if ((codec->width == icodec->width -\n\n                                (frame_leftBand + frame_rightBand)) &&\n\n                        (codec->height == icodec->height -\n\n                                (frame_topBand  + frame_bottomBand)))\n\n                {\n\n                    ost->video_resample = 0;\n\n                    ost->video_crop = 1;\n\n                    ost->topBand = frame_topBand;\n\n                    ost->leftBand = frame_leftBand;\n\n                } else {\n\n                    uint8_t *buf;\n\n                    ost->video_resample = 1;\n\n                    ost->video_crop = 0; // cropping is handled as part of resample\n\n                    buf = av_malloc((codec->width * codec->height * 3) / 2);\n\n                    if (!buf)\n\n                        goto fail;\n\n                    ost->pict_tmp.data[0] = buf;\n\n                    ost->pict_tmp.data[1] = ost->pict_tmp.data[0] + (codec->width * codec->height);\n\n                    ost->pict_tmp.data[2] = ost->pict_tmp.data[1] + (codec->width * codec->height) / 4;\n\n                    ost->pict_tmp.linesize[0] = codec->width;\n\n                    ost->pict_tmp.linesize[1] = codec->width / 2;\n\n                    ost->pict_tmp.linesize[2] = codec->width / 2;\n\n\n\n                    ost->img_resample_ctx = img_resample_full_init( \n\n                                      ost->st->codec.width, ost->st->codec.height,\n\n                                      ist->st->codec.width, ist->st->codec.height,\n\n                                      frame_topBand, frame_bottomBand,\n\n                                      frame_leftBand, frame_rightBand);\n\n                }\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n                break;\n\n            default:\n\n                av_abort();\n\n            }\n\n            /* two pass mode */\n\n            if (ost->encoding_needed && \n\n                (codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2))) {\n\n                char logfilename[1024];\n\n                FILE *f;\n\n                int size;\n\n                char *logbuffer;\n\n                \n\n                snprintf(logfilename, sizeof(logfilename), \"%s-%d.log\", \n\n                         pass_logfilename ? \n\n                         pass_logfilename : DEFAULT_PASS_LOGFILENAME, i);\n\n                if (codec->flags & CODEC_FLAG_PASS1) {\n\n                    f = fopen(logfilename, \"w\");\n\n                    if (!f) {\n\n                        perror(logfilename);\n\n                        exit(1);\n\n                    }\n\n                    ost->logfile = f;\n\n                } else {\n\n                    /* read the log file */\n\n                    f = fopen(logfilename, \"r\");\n\n                    if (!f) {\n\n                        perror(logfilename);\n\n                        exit(1);\n\n                    }\n\n                    fseek(f, 0, SEEK_END);\n\n                    size = ftell(f);\n\n                    fseek(f, 0, SEEK_SET);\n\n                    logbuffer = av_malloc(size + 1);\n\n                    if (!logbuffer) {\n\n                        fprintf(stderr, \"Could not allocate log buffer\\n\");\n\n                        exit(1);\n\n                    }\n\n                    fread(logbuffer, 1, size, f);\n\n                    fclose(f);\n\n                    logbuffer[size] = '\\0';\n\n                    codec->stats_in = logbuffer;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /* dump the file output parameters - cannot be done before in case\n\n       of stream copy */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n    }\n\n\n\n    /* dump the stream mapping */\n\n    fprintf(stderr, \"Stream mapping:\\n\");\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        fprintf(stderr, \"  Stream #%d.%d -> #%d.%d\\n\",\n\n                ist_table[ost->source_index]->file_index,\n\n                ist_table[ost->source_index]->index,\n\n                ost->file_index, \n\n                ost->index);\n\n    }\n\n\n\n    /* open each encoder */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            AVCodec *codec;\n\n            codec = avcodec_find_encoder(ost->st->codec.codec_id);\n\n            if (!codec) {\n\n                fprintf(stderr, \"Unsupported codec for output stream #%d.%d\\n\", \n\n                        ost->file_index, ost->index);\n\n                exit(1);\n\n            }\n\n            if (avcodec_open(&ost->st->codec, codec) < 0) {\n\n                fprintf(stderr, \"Error while opening codec for stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height\\n\", \n\n                        ost->file_index, ost->index);\n\n                exit(1);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* open each decoder */\n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = ist_table[i];\n\n        if (ist->decoding_needed) {\n\n            AVCodec *codec;\n\n            codec = avcodec_find_decoder(ist->st->codec.codec_id);\n\n            if (!codec) {\n\n                fprintf(stderr, \"Unsupported codec (id=%d) for input stream #%d.%d\\n\", \n\n                        ist->st->codec.codec_id, ist->file_index, ist->index);\n\n                exit(1);\n\n            }\n\n            if (avcodec_open(&ist->st->codec, codec) < 0) {\n\n                fprintf(stderr, \"Error while opening codec for input stream #%d.%d\\n\", \n\n                        ist->file_index, ist->index);\n\n                exit(1);\n\n            }\n\n            //if (ist->st->codec.codec_type == CODEC_TYPE_VIDEO)\n\n            //    ist->st->codec.flags |= CODEC_FLAG_REPEAT_FIELD;\n\n            ist->frame_decoded = 1;\n\n        }\n\n    }\n\n\n\n    /* init pts */\n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = ist_table[i];\n\n\tis = input_files[ist->file_index];\n\n        ist->pts = 0;\n\n        if (ist->decoding_needed) {\n\n            switch (ist->st->codec.codec_type) {\n\n            case CODEC_TYPE_AUDIO:\n\n                av_frac_init(&ist->next_pts, \n\n                             0, 0, is->pts_num * ist->st->codec.sample_rate);\n\n                break;\n\n            case CODEC_TYPE_VIDEO:\n\n                av_frac_init(&ist->next_pts, \n\n                             0, 0, is->pts_num * ist->st->codec.frame_rate);\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    \n\n    /* compute buffer size max (should use a complete heuristic) */\n\n    for(i=0;i<nb_input_files;i++) {\n\n        file_table[i].buffer_size_max = 2048;\n\n    }\n\n\n\n    /* open files and write file headers */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (av_write_header(os) < 0) {\n\n            fprintf(stderr, \"Could not write header for output file #%d (incorrect codec paramters ?)\\n\", i);\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n#ifndef CONFIG_WIN32\n\n    if ( !using_stdin )\n\n        fprintf(stderr, \"Press [q] to stop encoding\\n\");\n\n#endif\n\n    term_init();\n\n\n\n    stream_no_data = 0;\n\n    key = -1;\n\n\n\n    for(; received_sigterm == 0;) {\n\n        int file_index, ist_index;\n\n        AVPacket pkt;\n\n        uint8_t *ptr;\n\n        int len;\n\n        uint8_t *data_buf;\n\n        int data_size, got_picture;\n\n        AVPicture picture;\n\n        short samples[AVCODEC_MAX_AUDIO_FRAME_SIZE / 2];\n\n        void *buffer_to_free;\n\n        double pts_min;\n\n        \n\n    redo:\n\n        /* if 'q' pressed, exits */\n\n        if (!using_stdin) {\n\n            /* read_key() returns 0 on EOF */\n\n            key = read_key();\n\n            if (key == 'q')\n\n                break;\n\n        }\n\n\n\n        /* select the stream that we must read now by looking at the\n\n           smallest output pts */\n\n        file_index = -1;\n\n        pts_min = 1e10;\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            double pts;\n\n            ost = ost_table[i];\n\n            os = output_files[ost->file_index];\n\n            ist = ist_table[ost->source_index];\n\n            pts = (double)ost->st->pts.val * os->pts_num / os->pts_den;\n\n            if (!file_table[ist->file_index].eof_reached && \n\n                pts < pts_min) {\n\n                pts_min = pts;\n\n                file_index = ist->file_index;\n\n            }\n\n        }\n\n        /* if none, if is finished */\n\n        if (file_index < 0) {\n\n            break;\n\n        }\n\n\n\n        /* finish if recording time exhausted */\n\n        if (recording_time > 0 && pts_min >= (recording_time / 1000000.0))\n\n            break;\n\n\n\n        /* read a packet from it and output it in the fifo */\n\n        is = input_files[file_index];\n\n        if (av_read_packet(is, &pkt) < 0) {\n\n            file_table[file_index].eof_reached = 1;\n\n            continue;\n\n        }\n\n        if (!pkt.size) {\n\n            stream_no_data = is;\n\n        } else {\n\n            stream_no_data = 0;\n\n        }\n\n        if (do_hex_dump) {\n\n            printf(\"stream #%d, size=%d:\\n\", pkt.stream_index, pkt.size);\n\n            av_hex_dump(pkt.data, pkt.size);\n\n        }\n\n        /* the following test is needed in case new streams appear\n\n           dynamically in stream : we ignore them */\n\n        if (pkt.stream_index >= file_table[file_index].nb_streams)\n\n            goto discard_packet;\n\n        ist_index = file_table[file_index].ist_index + pkt.stream_index;\n\n        ist = ist_table[ist_index];\n\n        if (ist->discard)\n\n            goto discard_packet;\n\n\n\n        // printf(\"read #%d.%d size=%d\\n\", ist->file_index, ist->index, pkt.size);\n\n\n\n        len = pkt.size;\n\n        ptr = pkt.data;\n\n        while (len > 0) {\n\n            /* decode the packet if needed */\n\n            data_buf = NULL; /* fail safe */\n\n            data_size = 0;\n\n            if (ist->decoding_needed) {\n\n                /* NOTE1: we only take into account the PTS if a new\n\n                   frame has begun (MPEG semantics) */\n\n                /* NOTE2: even if the fraction is not initialized,\n\n                   av_frac_set can be used to set the integer part */\n\n                if (ist->frame_decoded) { \n\n                    /* If pts is unavailable -- we have to use synthetic one */\n\n                    if( pkt.pts != AV_NOPTS_VALUE )\n\n                    {\n\n                        ist->pts = ist->next_pts.val = pkt.pts;\n\n                    }\n\n                    else\n\n                    {\n\n                        ist->pts = ist->next_pts.val;\n\n                    }\n\n                    ist->frame_decoded = 0;\n\n                }\n\n\n\n                switch(ist->st->codec.codec_type) {\n\n                case CODEC_TYPE_AUDIO:\n\n                    /* XXX: could avoid copy if PCM 16 bits with same\n\n                       endianness as CPU */\n\n                    ret = avcodec_decode_audio(&ist->st->codec, samples, &data_size,\n\n                                               ptr, len);\n\n                    if (ret < 0)\n\n                        goto fail_decode;\n\n                    /* Some bug in mpeg audio decoder gives */\n\n                    /* data_size < 0, it seems they are overflows */\n\n                    if (data_size <= 0) {\n\n                        /* no audio frame */\n\n                        ptr += ret;\n\n                        len -= ret;\n\n                        continue;\n\n                    }\n\n                    data_buf = (uint8_t *)samples;\n\n\t\t    av_frac_add(&ist->next_pts, \n\n\t\t\t        is->pts_den * data_size / (2 * ist->st->codec.channels));\n\n                    break;\n\n                case CODEC_TYPE_VIDEO:\n\n                    {\n\n                        AVFrame big_picture;\n\n\n\n                        data_size = (ist->st->codec.width * ist->st->codec.height * 3) / 2;\n\n                        ret = avcodec_decode_video(&ist->st->codec, \n\n                                                   &big_picture, &got_picture, ptr, len);\n\n                        picture= *(AVPicture*)&big_picture;\n\n                        ist->st->quality= big_picture.quality;\n\n                        if (ret < 0) {\n\n                        fail_decode:\n\n                            fprintf(stderr, \"Error while decoding stream #%d.%d\\n\",\n\n                                    ist->file_index, ist->index);\n\n                            av_free_packet(&pkt);\n\n                            goto redo;\n\n                        }\n\n                        if (!got_picture) {\n\n                            /* no picture yet */\n\n                            ptr += ret;\n\n                            len -= ret;\n\n                            continue;\n\n                        }\n\n                        av_frac_add(&ist->next_pts, \n\n\t\t\t            is->pts_den * ist->st->codec.frame_rate_base);          \n\n                    }\n\n                    break;\n\n                default:\n\n                    goto fail_decode;\n\n                }\n\n            } else {\n\n                data_buf = ptr;\n\n                data_size = len;\n\n                ret = len;\n\n            }\n\n            ptr += ret;\n\n            len -= ret;\n\n\n\n            buffer_to_free = 0;\n\n            if (ist->st->codec.codec_type == CODEC_TYPE_VIDEO) {\n\n                pre_process_video_frame(ist, &picture, &buffer_to_free);\n\n            }\n\n\n\n            ist->frame_decoded = 1;\n\n\n\n            /* frame rate emulation */\n\n            if (ist->st->codec.rate_emu) {\n\n                int64_t pts = av_rescale((int64_t) ist->frame * ist->st->codec.frame_rate_base, 1000000, ist->st->codec.frame_rate);\n\n                int64_t now = av_gettime() - ist->start;\n\n                if (pts > now)\n\n                    usleep(pts - now);\n\n\n\n                ist->frame++;\n\n            }\n\n\n\n#if 0\n\n            /* mpeg PTS deordering : if it is a P or I frame, the PTS\n\n               is the one of the next displayed one */\n\n            /* XXX: add mpeg4 too ? */\n\n            if (ist->st->codec.codec_id == CODEC_ID_MPEG1VIDEO) {\n\n                if (ist->st->codec.pict_type != B_TYPE) {\n\n                    int64_t tmp;\n\n                    tmp = ist->last_ip_pts;\n\n                    ist->last_ip_pts  = ist->frac_pts.val;\n\n                    ist->frac_pts.val = tmp;\n\n                }\n\n            }\n\n#endif\n\n            /* transcode raw format, encode packets and output them */\n\n\n\n            for(i=0;i<nb_ostreams;i++) {\n\n                int frame_size;\n\n\n\n                ost = ost_table[i];\n\n                if (ost->source_index == ist_index) {\n\n                    os = output_files[ost->file_index];\n\n\n\n#if 0\n\n                    printf(\"%d: got pts=%f %f\\n\", i, pkt.pts / 90000.0, \n\n                           (ist->pts - ost->st->pts.val) / 90000.0);\n\n#endif\n\n                    /* set the input output pts pairs */\n\n                    ost->sync_ipts = (double)ist->pts * is->pts_num / \n\n                        is->pts_den;\n\n                    /* XXX: take into account the various fifos,\n\n                       in particular for audio */\n\n                    ost->sync_opts = ost->st->pts.val;\n\n                    //printf(\"ipts=%lld sync_ipts=%f sync_opts=%lld pts.val=%lld pkt.pts=%lld\\n\", ist->pts, ost->sync_ipts, ost->sync_opts, ost->st->pts.val, pkt.pts); \n\n\n\n                    if (ost->encoding_needed) {\n\n                        switch(ost->st->codec.codec_type) {\n\n                        case CODEC_TYPE_AUDIO:\n\n                            do_audio_out(os, ost, ist, data_buf, data_size);\n\n                            break;\n\n                        case CODEC_TYPE_VIDEO:\n\n                            /* find an audio stream for synchro */\n\n                            {\n\n                                int i;\n\n                                AVOutputStream *audio_sync, *ost1;\n\n                                audio_sync = NULL;\n\n                                for(i=0;i<nb_ostreams;i++) {\n\n                                    ost1 = ost_table[i];\n\n                                    if (ost1->file_index == ost->file_index &&\n\n                                        ost1->st->codec.codec_type == CODEC_TYPE_AUDIO) {\n\n                                        audio_sync = ost1;\n\n                                        break;\n\n                                    }\n\n                                }\n\n\n\n                                do_video_out(os, ost, ist, &picture, &frame_size, audio_sync);\n\n                                if (do_vstats && frame_size)\n\n                                    do_video_stats(os, ost, frame_size);\n\n                            }\n\n                            break;\n\n                        default:\n\n                            av_abort();\n\n                        }\n\n                    } else {\n\n                        AVFrame avframe;\n\n                                                \n\n                        /* no reencoding needed : output the packet directly */\n\n                        /* force the input stream PTS */\n\n                        \n\n                        memset(&avframe, 0, sizeof(AVFrame));\n\n                        ost->st->codec.coded_frame= &avframe;\n\n\t\t\tavframe.key_frame = pkt.flags & PKT_FLAG_KEY; \n\n                        \n\n                        av_write_frame(os, ost->index, data_buf, data_size);\n\n\t\t\tost->st->codec.frame_number++;\n\n\t\t\tost->frame_number++;\n\n                    }\n\n                }\n\n            }\n\n            av_free(buffer_to_free);\n\n        }\n\n    discard_packet:\n\n        av_free_packet(&pkt);\n\n        \n\n        /* dump report by using the output first video and audio streams */\n\n        print_report(output_files, ost_table, nb_ostreams, 0);\n\n    }\n\n    term_exit();\n\n\n\n    /* dump report by using the first video and audio streams */\n\n    print_report(output_files, ost_table, nb_ostreams, 1);\n\n\n\n    /* close each encoder */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            av_freep(&ost->st->codec.stats_in);\n\n            avcodec_close(&ost->st->codec);\n\n        }\n\n    }\n\n    \n\n    /* close each decoder */\n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = ist_table[i];\n\n        if (ist->decoding_needed) {\n\n            avcodec_close(&ist->st->codec);\n\n        }\n\n    }\n\n    \n\n\n\n    /* write the trailer if needed and close file */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        av_write_trailer(os);\n\n    }\n\n    /* finished ! */\n\n    \n\n    ret = 0;\n\n fail1:\n\n    av_free(file_table);\n\n\n\n    if (ist_table) {\n\n        for(i=0;i<nb_istreams;i++) {\n\n            ist = ist_table[i];\n\n            av_free(ist);\n\n        }\n\n        av_free(ist_table);\n\n    }\n\n    if (ost_table) {\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            if (ost) {\n\n                if (ost->logfile) {\n\n                    fclose(ost->logfile);\n\n                    ost->logfile = NULL;\n\n                }\n\n                fifo_free(&ost->fifo); /* works even if fifo is not\n\n                                          initialized but set to zero */\n\n                av_free(ost->pict_tmp.data[0]);\n\n                if (ost->video_resample)\n\n                    img_resample_close(ost->img_resample_ctx);\n\n                if (ost->audio_resample)\n\n                    audio_resample_close(ost->resample);\n\n                av_free(ost);\n\n            }\n\n        }\n\n        av_free(ost_table);\n\n    }\n\n    return ret;\n\n fail:\n\n    ret = -ENOMEM;\n\n    goto fail1;\n\n}\n", "idx": 13268, "substitutes": {"output_files": ["outputCachestyles", "input_styles", "outputCachefile", "input_modules", "input_file", "output_modules", "output_file", "output_styles", "outputCachemodules", "outputCachefiles"], "nb_output_files": ["nb_outputsfile", "nb_input_file", "nb_outputsfiles", "nb_outputsnames", "nb_output_names", "nb_output_file", "nb_input_names"], "input_files": ["input_workers", "inputablefile", "input_videos", "output_workers", "input___files", "output_data", "inputmopvideos", "inputlicfile", "input_data", "input_modules", "output_Files", "input_file", "output_modules", "output_file", "output_videos", "inputmopdata", "inputlicworkers", "input___modules", "inputablemodules", "inputlicfiles", "inputlicFiles", "input_Files", "inputableworkers", "inputablefiles", "input___workers", "input___file", "inputmopfile", "inputmopfiles"], "nb_input_files": ["nb_inputvefile", "nb_output_values", "nb_inputvescenes", "nb_input___file", "nb_output_scenes", "nb_inputvedocs", "nb_input_scenes", "nb_input___jobs", "nb_output_docs", "nb_input_jobs", "nb_inputablefs", "nb_input_fs", "nb_inputablefiles", "nb_output_uploads", "nb_input_values", "nb_output_ports", "nb_input_uploads", "nb_inputablejobs", "nb_input___fs", "nb_input___files", "nb_output_file", "nb_input___ports", "nb_input_docs", "nb_output_fs", "nb_inputvefiles", "nb_output_jobs", "nb_input_ports", "nb_input_file", "nb_inputablefile"], "stream_maps": ["stream_sets", "stream2map", "streamitymap", "fileitysets", "streamityresults", "file_maps", "stream2sets", "stream2maps", "stream_results", "fileitymap", "stream_map", "fileitymaps", "streamitymaps", "file_map", "stream2results", "streamitysets", "file_sets", "file_results", "fileityresults"], "nb_stream_maps": ["nb_streamingsets", "nb_stream_sets", "nb_Stream_lists", "nb_streaminglists", "nb_streamingmap", "nb_streamingmaps", "nb_Stream_maps", "nb_stream_lists", "nb_Stream_sets", "nb_stream_map", "nb_Stream_map"], "ret": ["resp", "jp", "status", "mem", "out", " RET", "ll", "Ret", "RET", "val", "fail", "t", "result", "new", "vals", "ry", "gc", "flag", "re", "nil", "fi", "err"], "i": ["index", "dr", "ir", "cli", "ami", "ai", "m", " I", "xi", "qi", "parent", "mm", "ite", "ims", "it", "fire", "ji", "ma", "us", "li", "oi", "ind", "ki", "si", "zi", "v", "try", "g", "ui", "iii", "im", "any", "ti", "fi", "x", "ri", "ic", "ix", "ip", "ij", "at", "um", "ii", "mi", "I", "pi", "this", "batch", "ik", "er", "di", "in", "ie", "sim", "info", "remote", "ci", "id", "multi", "me", "init", "status", "iu", "o", "ini", "ei", "uri", "p", "chain", "bi", "details", "io", "ia", "hi", "\u0438", "iso", "iri", "h", "e", "gi", "q", "phi", "name", "y"], "j": ["jp", "ij", "o", "jit", "l", "pr", "js", "p", "aj", "bj", "v", "g", "next", "bi", "adj", "uj", "bo", "nr", "m", "br", "r", "json", "ja", "slot", "dj", "J", "jj", "b", "h", "jump", "fr", "jl", "jc", "ji", "it", "kj", "z", "q", "y", "gov", "jac"], "k": ["kw", "kn", "o", "kh", "uk", "km", "p", "kid", "kt", "ok", "ki", "kk", "mk", "tk", "v", "kit", "ik", "kind", "isk", "ke", "ku", "K", "m", "ek", "kr", "ko", "ask", "ck", "c", "ak", "wk", "kick", "dk", "kl", "b", "unk", "ark", "ks", "ijk", "kj", "z", "q", "y", "ka", "sk"], "n": ["nl", "ni", "o", "cn", "ll", "l", "p", "v", "g", "np", "num", "nr", "nt", "m", "N", "c", "no", "ns", "nn", "nb", "ne", "q", "sn", "nan", "nm", "nu", "na"], "is": ["isc", "sis", "phis", "ates", "ib", "ists", "as", "bs", "has", "ii", "ports", "js", "bits", "si", "ir", "tis", "vis", "ih", "ui", "isl", "mos", "sys", "ires", "in", "lis", "iss", "was", "s", "nis", "isi", "ais", "info", "iso", "ois", "im", "orts", "iris", "ism", "ci", "are", "vs", "ins", "ils", "atis", "isa", "es", "ims", "id", "IS", "fs", "Is", "it", "bis", "its", "parts", "ps", "ris", "isin", "init", "iv", "us", "ms", "ri", "ic", "ip"], "os": ["obs", "oc", "o", "bs", "out", "et", "ys", "oses", "OS", "io", "sys", "ens", "ds", "s", "oss", "Os", "ops", "cs", "es", "ot", "its", "us", "ms", "ps"], "codec": ["formec", "codrc", "Codrc", "codEC", "cdec", "Codec", "Codressor", "Codoc", " codrc", "formressor", "codressor", "cdrc", "chEC", "chressor", " codEC", "chec", "formEC", "CodEC", "choc", "codoc", "cdEC", "formoc", "cdoc", " codoc"], "icodec": ["icodEC", "micodEC", "icopEC", "micodef", "miccodec", "miccodenc", "miccodef", "icondenc", "micodec", "icodenc", "icodef", "icondEC", "icopef", "icopec", "iccodef", "miccodEC", "iccodec", "icondec", "iccodEC", "icondef", "icopenc", "micodenc", "iccodenc"], "ost": ["ont", "est", "obs", "oc", "tt", "ox", "ilst", "op", "rest", "irst", "oss", "art", "ust", "od", "istor", "oid", "ort", "ace", "ot", "ous", "ast", "iv", "ic", "ob", "voc"], "ost_table": ["ost_trace", "ist_buffer", "ost_list", "ist_trace", "ost_buffer", "ist_list"], "ist": ["istance", "ress", "ont", "spect", "iste", "ict", "est", "ists", "et", "lda", "and", "htt", "iest", "edit", "exist", "pir", "elist", "tt", "mot", "stat", "feat", "ista", "hist", "isted", "ith", "port", "ert", "assert", "ilst", "isl", "rust", "dist", "act", "op", "irst", "isting", "rest", "dit", "IST", "ess", "artist", "cript", "isi", "ird", "vest", "art", "ust", "ism", "wp", "gest", "lat", "istor", "ort", "lect", "alist", "istant", "wordpress", "ot", "ace", "it", "list", "pect", "its", "pas", "ast", "EST", "inst", "ic", "iat", "ip"], "ist_table": ["istobjcount", "iststable", "ist___stable", "istant_table", "istPdatabase", "ost_cache", "ist_buffer", "istPtable", "ert_tree", "ist_public", "ost_tree", "istsbatch", "ist_list", "istant_body", "elist___list", "ist___tmp", "istttree", "ist_Table", "istobjbody", "ist___buffer", "ist_stable", "elist_batch", "ist_database", "istobjTable", "elist___table", "elist___batch", "elist_stable", "ast_buffer", "ert_table", "ist_count", "ast_table", "isttlist", "ost_list", "istPbuffer", "ist___batch", "ist_tmp", "istPtree", "istant_count", "ist_tree", "istttable", "ist_cache", "elist___stable", "ist___table", "ast_public", "istslist", "istsstable", "ist_batch", "istobjtable", "elist_table", "ert_buffer", "elist_list", "isttcache", "ist___list", "ert_database", "ast_tmp", "ist___public", "istant_Table", "ist_body"], "file_table": ["pathletable", "file2TABLE", "filesettable", "file_info", "file_tree", " file_list", "file_buffer", "path_TABLE", "file2tab", " file_template", " file_tree", "filelemaster", "filesetbuffer", "file2buffer", "file_list", "filePtemplate", "filelecache", "filePtable", "file2table", "fileletable", "file2info", "path_cache", " file_TABLE", "file_template", "path_master", "filePbuffer", "file_global", "filePchain", "filesetchain", " file_buffer", "file_cache", "filesettemplate", "fileleTABLE", " file_chain", "file_master", "file_tab", "filePinfo", "pathlecache", " file_tab", "file_chain", "pathleTABLE", "filePtab", "pathlemaster", " file_global", "file_TABLE", "path_table", " file_info"], "stream_no_data": ["stream_meta_DATA", "stream_meta_table", "stream_noopdata", "stream_no_table", "stream_no_error", "stream_meta_error", "stream_no_DATA", "stream_nooptable", "stream_nooperror", "stream_noopDATA", "stream_meta_data"], "key": ["KEY", "kw", "error", "type", "param", "version", "ref", "cond", "Key", "keys", "ee", "val", "num", "fee", "parent", "count", "base", "code", "ry", "flag", "start", "value", "x", "str", "pointer", "ree"], "file_index": ["file_key", "port_key", "file_id", "port_index", "file_ind", "port_ind", "port_id"], "ist_index": ["st_Index", "st_id", "istopindex", "st_address", "istopid", "istopaddress", "ist_address", "ist_id", "ist_Index", "st_index", "istopIndex"], "st": ["ste", "be", "stable", "est", "sw", "src", "sta", "St", "ST", "dr", "storage", "stat", "ut", "stop", "nd", "service", "stack", "end", "cl", "ct", "dist", "rest", "irst", "step", "first", "stage", "sp", "ust", "dest", "std", "sh", "must", "start", "set", "sty", "se", "sth", "sts", "inst", "sc", "str"], "frame": ["error", "record", "shift", "version", "cond", "seq", "sequence", "window", "depth", "fd", "reset", "chain", "frames", "source", "offset", "channel", "step", "slot", "block", "event", "base", "fr", "point", "trace", "cycle", "fps", "second", "sample"]}}
{"project": "FFmpeg", "commit_id": "f37b2d5a6884c7bea87a6c7454239381449bd637", "target": 1, "func": "int avpriv_mpeg4audio_get_config(MPEG4AudioConfig *c, const uint8_t *buf,\n                                 int bit_size, int sync_extension)\n{\n    GetBitContext gb;\n    int specific_config_bitindex;\n    init_get_bits(&gb, buf, bit_size);\n    c->object_type = get_object_type(&gb);\n    c->sample_rate = get_sample_rate(&gb, &c->sampling_index);\n    c->chan_config = get_bits(&gb, 4);\n    if (c->chan_config < FF_ARRAY_ELEMS(ff_mpeg4audio_channels))\n        c->channels = ff_mpeg4audio_channels[c->chan_config];\n    c->sbr = -1;\n    c->ps  = -1;\n    if (c->object_type == AOT_SBR || (c->object_type == AOT_PS &&\n        // check for W6132 Annex YYYY draft MP3onMP4\n        !(show_bits(&gb, 3) & 0x03 && !(show_bits(&gb, 9) & 0x3F)))) {\n        if (c->object_type == AOT_PS)\n            c->ps = 1;\n        c->ext_object_type = AOT_SBR;\n        c->sbr = 1;\n        c->ext_sample_rate = get_sample_rate(&gb, &c->ext_sampling_index);\n        c->object_type = get_object_type(&gb);\n        if (c->object_type == AOT_ER_BSAC)\n            c->ext_chan_config = get_bits(&gb, 4);\n    } else {\n        c->ext_object_type = AOT_NULL;\n        c->ext_sample_rate = 0;\n    }\n    specific_config_bitindex = get_bits_count(&gb);\n    if (c->object_type == AOT_ALS) {\n        skip_bits(&gb, 5);\n        if (show_bits_long(&gb, 24) != MKBETAG('\\0','A','L','S'))\n            skip_bits_long(&gb, 24);\n        specific_config_bitindex = get_bits_count(&gb);\n        if (parse_config_ALS(&gb, c))\n            return -1;\n    }\n    if (c->ext_object_type != AOT_SBR && sync_extension) {\n        while (get_bits_left(&gb) > 15) {\n            if (show_bits(&gb, 11) == 0x2b7) { // sync extension\n                get_bits(&gb, 11);\n                c->ext_object_type = get_object_type(&gb);\n                if (c->ext_object_type == AOT_SBR && (c->sbr = get_bits1(&gb)) == 1)\n                    c->ext_sample_rate = get_sample_rate(&gb, &c->ext_sampling_index);\n                if (get_bits_left(&gb) > 11 && get_bits(&gb, 11) == 0x548)\n                    c->ps = get_bits1(&gb);\n                break;\n            } else\n                get_bits1(&gb); // skip 1 bit\n        }\n    }\n    //PS requires SBR\n    if (!c->sbr)\n        c->ps = 0;\n    //Limit implicit PS to the HE-AACv2 Profile\n    if ((c->ps == -1 && c->object_type != AOT_AAC_LC) || c->channels & ~0x01)\n        c->ps = 0;\n    return specific_config_bitindex;\n}", "idx": 13273, "substitutes": {"c": ["csv", "ae", "rc", "ce", "cu", "cf", "co", "cr", "oc", "tc", "cm", "cur", "cn", "lc", "l", "ctx", "p", "gc", "cmp", "call", "cod", "cc", "cd", "v", "chain", "check", "ic", "com", "dc", "cache", "ct", "sc", "ac", "C", "cb", "cv", "cal", "xc", "abc", "nc", "ci", "ec", "code", "content", "comp", "cp", "b", "mc", "cs", "bc", "ctrl", "etc", "pc", "fc", "set", "con", "conf", "enc", "config", "err", "w", "ca", "coll", "cont", "anc", "can", "ch"], "buf": ["Buff", "bytes", "rc", "path", "mem", "f", "ref", "out", "data", "cmd", "pb", "p", "raw", "Buffer", "v", "box", "read", "sb", "msg", "buff", "rb", "xff", "r", "doc", "buffer", "cb", "block", "db", "cv", "img", "b", "tmp", "conf", "max", "uf", "mb", "err", "queue", "txt"], "bit_size": ["batch_rate", "batch_Size", "bit_SIZE", "batch_state", "bitvalSIZE", "bitvalsize", "bit_state", "bititysize", "bit_Size", " bit_SIZE", "bitvalSize", "bititySize", " bit_index", "bit_rate", " bit_Size", "bitvalindex", "bitityrate", "bit_index", "bititystate", "batch_size"], "sync_extension": ["sync_Extend", "sync_EXTend", "sync_xtend", "sync_extend", "sync_extended", "sync_xtended", "sync_Extended", "sync_xtension", "sync_extensions", "sync_Extension", "sync_EXTensions", "sync_EXTension", "sync_xtensions", "sync_Extensions", "sync_EXTended"], "gb": ["csv", "gs", "ib", " GB", "gg", "py", "bs", "attr", "ctx", "storage", "ga", "gu", "new", " db", "kb", " rgb", "cb", "rg", "grow", "gif", "uf", "bg", "gov", "def", "tg", "gem", "eb", "g", "cfg", "gom", "db", "gc", "args", "yg", "eg", "gpu", "fi", "bb", "mb", "um", "GB", "git", "bool", "hub", "wb", "ge", "sb", "vg", "rb", "gt", "gd", "ruby", "C", "buffer", "cv", "bf", "bc", "pc", "px", "gh", "bytes", "gin", "good", "pb", "deg", "wm", "xy", "sv", "msg", "got", "vm", "range", "bridge", "all", "img", "gp", "gm", "fc", "_", "nb", "Gb", "ch"], "specific_config_bitindex": ["specific_config_bandIndex", "specific_config_bytetype", "specific_config_shortposition", "specific_config_bitcount", "specific_config_binposition", "specific_config_Bitposition", "specific_config_bintype", "specific_config_bposition", "specific_config_bindex", "specific_config_bitIndex", "specific_config_byteposition", "specific_config_binindex", "specific_config_blength", "specific_config_baseindex", "specific_config_shortindex", "specific_config_bittype", "specific_config_Bitindex", "specific_config_byteindex", "specific_config_bitlength", "specific_config_Bittype", "specific_config_byteIndex", "specific_config_basecount", "specific_config_shortstop", "specific_config_Bitlength", "specific_config_shortlength", "specific_config_bytecount", "specific_config_bstop", "specific_config_binlength", "specific_config_bitposition", "specific_config_bytestop", "specific_config_bandcount", "specific_config_baseIndex", "specific_config_bytelength", "specific_config_bandindex", "specific_config_bitstop"]}}
{"project": "FFmpeg", "commit_id": "a52f443714b5c2a40ed272d8445f4c39220a4b69", "target": 1, "func": "static av_always_inline void vc1_apply_p_h_loop_filter(VC1Context *v, int block_num)\n\n{\n\n    MpegEncContext *s  = &v->s;\n\n    int mb_cbp         = v->cbp[s->mb_x - 1 - s->mb_stride],\n\n        block_cbp      = mb_cbp      >> (block_num * 4), right_cbp,\n\n        mb_is_intra    = v->is_intra[s->mb_x - 1 - s->mb_stride],\n\n        block_is_intra = mb_is_intra >> (block_num * 4), right_is_intra;\n\n    int idx, linesize  = block_num > 3 ? s->uvlinesize : s->linesize, ttblk;\n\n    uint8_t *dst;\n\n\n\n    if (block_num > 3) {\n\n        dst = s->dest[block_num - 3] - 8 * linesize;\n\n    } else {\n\n        dst = s->dest[0] + (block_num & 1) * 8 + ((block_num & 2) * 4 - 16) * linesize - 8;\n\n    }\n\n\n\n    if (s->mb_x != s->mb_width || !(block_num & 5)) {\n\n        int16_t (*mv)[2];\n\n\n\n        if (block_num > 3) {\n\n            right_cbp      = v->cbp[s->mb_x - s->mb_stride] >> (block_num * 4);\n\n            right_is_intra = v->is_intra[s->mb_x - s->mb_stride] >> (block_num * 4);\n\n            mv             = &v->luma_mv[s->mb_x - s->mb_stride - 1];\n\n        } else {\n\n            right_cbp      = (block_num & 1) ? (v->cbp[s->mb_x - s->mb_stride]      >> ((block_num - 1) * 4))\n\n                                             : (mb_cbp                              >> ((block_num + 1) * 4));\n\n            right_is_intra = (block_num & 1) ? (v->is_intra[s->mb_x - s->mb_stride] >> ((block_num - 1) * 4))\n\n                                             : (mb_is_intra                         >> ((block_num + 1) * 4));\n\n            mv             = &s->current_picture.motion_val[0][s->block_index[block_num] - s->b8_stride * 2 - 2];\n\n        }\n\n        if (block_is_intra & 1 || right_is_intra & 1 || mv[0][0] != mv[1][0] || mv[0][1] != mv[1][1]) {\n\n            v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n\n        } else {\n\n            idx = ((right_cbp >> 1) | block_cbp) & 5; // FIXME check\n\n            if (idx == 5) {\n\n                v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n\n            } else if (idx) {\n\n                if (idx == 1)\n\n                    v->vc1dsp.vc1_h_loop_filter4(dst + 4 * linesize, linesize, v->pq);\n\n                else\n\n                    v->vc1dsp.vc1_h_loop_filter4(dst,                linesize, v->pq);\n\n            }\n\n        }\n\n    }\n\n\n\n    dst -= 4;\n\n    ttblk = (v->ttblk[s->mb_x - s->mb_stride - 1] >> (block_num * 4)) & 0xf;\n\n    if (ttblk == TT_4X4 || ttblk == TT_4X8) {\n\n        idx = (block_cbp | (block_cbp >> 1)) & 5;\n\n        if (idx == 5) {\n\n            v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n\n        } else if (idx) {\n\n            if (idx == 1)\n\n                v->vc1dsp.vc1_h_loop_filter4(dst + linesize * 4, linesize, v->pq);\n\n            else\n\n                v->vc1dsp.vc1_h_loop_filter4(dst,                linesize, v->pq);\n\n        }\n\n    }\n\n}\n", "idx": 13311, "substitutes": {"v": ["vv", "nv", "qu", "view", "f", "um", "ver", "tv", "V", "data", "l", "values", "j", "p", "vr", "vp", "vi", "conv", "mint", "g", "virtual", "t", "vis", "sv", "video", "m", "get", "env", "vm", "c", "inv", "cv", "va", "vs", "ov", "b", "vector", "h", "lv", "verb", "nov", "e", "qv", "uv", "ve", "vc", "ev", "vt", "iv", "w", "av", "x", "i", "y", "q", "ch"], "block_num": ["blockpron", "block_type", "switch_sum", "bridgepron", "block_alph", "blocking10nom", "block_hom", "cont", "sliceIDdec", " block_number", "lock_typ", "lock1nam", "lock_hom", "block__tim", " block2um", "blockPnum", "lock1num", "bridgeprocmp", "batch10num", "lock_tim", "Block_cum", "slice_mat", " block_NUM", "block2sum", "lock_NUM", "blockPnom", "lock_nom", "sliceIDname", "block64num", "Block_num", "chain_nom", "block_um", "block2num", "block__hom", "Block_orig", "batch10mon", "block67nom", "sliceIDmat", "block10num", "blockipcmp", " block2nu", "batch10mat", "block_sum", "blockPno", "func", "switch_NUM", "blockPum", "slice_num", "blocking_num", "into", "bl", "blockprospan", "bridge_span", "block2NUM", "block_Num", " block_Num", "lock_nam", "cmp", "bridgepronum", "block1nom", "block64norm", "block_n", "block_no", "bridge_n", " block_sum", "lock1typ", " block2Num", "def", "switch_no", "batch_num", "block1type", " block2num", "blockprocmp", "block64nom", "block_typ", "blocking10num", "block10type", "lock_um", "block8sum", "block2nom", "block10um", "block4Num", "block1norm", " block2number", "block2nu", "block1mat", "lock1NUM", "block__number", "block_nom", "block2number", "blockixtim", "block_orig", "block1num", "bridgeprospan", "block_digit", "blockipnum", "chain_um", "block_mon", "blocking_type", "chain_num", "blocking10norm", "block67num", "block10nom", "block_NUM", "block_tim", "block__num", " block_nu", "lock1nom", "block10mon", "bridge_cmp", "chain_alph", "slice_dec", "block1typ", "Block_NUM", "blockPsum", "block_cum", "bool", "sliceIDnum", "blockIDdec", "switch_num", "block10norm", "lock_number", "blockixhom", "block4NUM", "lock_prim", "blocking_nom", "block1dec", "block1name", "block8num", "lock_mon", "block10mat", "blocking_norm", "block_prim", "blocking10type", " block2nom", "new", "block67um", "block8Num", "block67nu", "switch_um", "blockixnumber", "block8number", "batch10um", "block1mon", "blockipn", "block_span", "co", "batch_mon", "block_number", "block64type", " block_um", " block_nom", "bridge_num", "blockpronum", "blockPalph", "block_dec", "switch_nom", "block2digit", "blockIDnum", "blockixnum", "block_nam", "block2Num", "block_nu", "block_cmp", "block1um", "block4num", " block_digit", "block1NUM", " block2sum", "block2um", "slice_name", "blockipspan", "block4digit", "block_norm", "block1prim", "blockIDname", "blockIDmat", "batch_mat", "lock1mon", "lock1prim", "block_mat", "lock_num", "block_name", "batch_um", "block1nam"], "s": ["csv", "sis", "ses", "gs", "S", "bs", "series", "sq", "stat", "sl", "sam", "t", "m", "qs", "stats", "vs", "sh", "cs", "ims", "its", "ps", "sw", "j", "n", "js", "si", "conv", "css", "g", "comm", "spec", "space", "ed", "ds", "ats", "sa", "sc", "self", "conf", "i", "x", "ex", "an", "south", "a", "f", "as", "less", "bits", "xs", "sm", "sb", "als", "er", "sys", "hs", "al", "c", "dev", "es", "fs", "bis", "se", "sports", "ss", "sql", "aws", "has", "session", "size", "p", "is", "sv", "ls", "ts", "sp", "ns", "b", "h", "sd", "os", "sym", "z", "w", "sts", "ms", "y", "rs"], "right_cbp": ["right___cbf", "right_wspre", "right_wspl", "right_sbp", "right___gbP", "right_cppop", "right_ctrlpop", "right_rbp", "right_rbm", "right_rbf", "right_cbm", "right_gbp", "right_gbf", "right_sbP", "right_ctrlpre", "right_ctrlp", "right_gbP", "right_gbm", "right_cppre", "right_cbf", "right_sbf", "right_cbpl", "right_cbpop", "right_cpp", "right_cbpoint", "right_cbpre", "right_gbpoint", "right_cbP", "right_cvf", "right___gbp", "right_wsp", "right_cvpoint", "right_sbpoint", "right___gbm", "right_cvP", "right_ctrlpl", "right_cvp", "right___gbpoint", "right___cbpoint", "right_cvm", "right_wspop", "right___cbm", "right___cbP", "right___gbf", "right_cppl", "right___cbp"], "right_is_intra": ["right_is_itras", "right_is_instras", "right_is_indara", "right_is_istara", "right_is_instron", "right_is_intran", "right_is_interras", "right_is_itro", "right_is_intro", "right_is_indra", "right_is_indron", "right_is_interro", "right_is_itran", "right_is_intron", "right_is_itron", "right_is_itra", "right_is_intras", "right_is_istro", "right_is_istron", "right_is_interra", "right_is_instran", "right_is_indro", "right_is_instro", "right_is_interara", "right_is_istra", "right_is_interran", "right_is_instara", "right_is_instra", "right_is_intara", "right_is_itara", "right_is_interron"], "idx": ["ideex", "ridx", "ridex", "idX", "idex", "ridX", " idX", "ideX", " idex"], "ttblk": ["txtBLn", "ttblK", "ttblj", "ttBLk", "txtBLk", "ttBlK", "ttBLn", "ttBln", "ttvj", "txtBLj", "txtbln", "txtBLK", "ttvn", "ttBLj", "ttvK", "txtblj", "txtblk", "ttbln", "txtblK", "ttBlj", "ttBlk", "ttBLK", "ttvk"], "dst": ["rrc", "bddest", "Dst", "rut", "duest", "dbr", "dubr", " dbr", "rst", "ddest", "dput", " dsts", "rdest", "Dput", "Ddest", "rend", "dend", " drc", "dut", "delsts", "rest", "duput", "bdput", "bdut", "rput", "delst", "dust", "dest", " dest", "dsts", "bdst", " dput", "delend", "rsts", "Dut", "drc", "delrc", "rbr", " dend"], "mv": ["nvc", " mvs", "nv", "rmtv", "nvt", "rv", "Mvs", "mvt", " mvc", "rmvc", " mvt", "ntv", "mtv", "rmvt", "Mvc", " mtv", "Mv", "rvc", " mx", "Mx", "mvs", "mvc", "rx", "rvs", "mx", "rmv"]}}
{"project": "FFmpeg", "commit_id": "5afe1d27912be9b643ffb4ddc21f6d920260dbb0", "target": 1, "func": "static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    int len;\n\n\n\n    for(;;) {\n\n        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);\n\n        if (len != TS_PACKET_SIZE)\n\n            return len < 0 ? len : AVERROR_EOF;\n\n        /* check packet sync byte */\n\n        if ((*data)[0] != 0x47) {\n\n            /* find a new packet start */\n\n            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);\n\n            if (mpegts_resync(s) < 0)\n\n                return AVERROR(EAGAIN);\n\n            else\n\n                continue;\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 13316, "substitutes": {"s": ["aws", "ses", "gs", "a", "S", "f", "as", "sw", "bs", "j", "ctx", "p", "js", "n", "sq", "v", "g", "t", "als", "is", "sv", "st", "sb", "hs", "sys", "ds", "ats", "m", "r", "sc", "ts", "c", "sp", "ins", "ns", "b", "cs", "fs", "conf", "sg", "os", "tp", "scl", "ss", "ms", "i", "ps"], "buf": ["bytes", "Buff", "mem", "ref", "seq", "p", "wb", "window", "bh", "Buffer", "v", "box", " buffer", "read", "msg", "buff", "cap", "rb", "br", "doc", " bu", "mu", "buffer", "cb", "cv", "db", "img", "b", "bc", "tmp", " buff", "pad", "uf", "queue", "bound", "bp", "lim"], "raw_packet_size": ["raw_packets_area", "raw_packets_len", "raw_packet_len", "raw_packets_SIZE", "raw_packetewlen", "raw_packetewsize", "raw_packet_area", "raw_packets_size", "raw_packet_SIZE", "raw_packetewSIZE", "raw_packetewarea"], "data": ["bytes", "def", "a", "good", "size", "aw", "map", "flags", "p", "n", "window", " DATA", "raw", "text", "next", "load", "done", "maybe", "t", "batch", "kat", "read", "cache", "bin", "msg", "extra", "mu", "buffer", "empty", "block", "image", "all", "trans", "Data", "no", "table", "ns", "mitted", "chan", "partial", "any", "length", "d", "DATA", "format", "ata", "dat", "name", "str"], "pb": ["jp", "td", "tg", "tc", "bs", "cm", "pub", "ctx", "p", "wb", "eb", "bh", "vp", "pm", "tk", "bj", "typ", "dp", "pt", "pp", "sb", "gb", "np", "ab", "rb", "lb", "ub", "pa", "buffer", "cb", "sp", "lp", "fp", "db", "PB", "cv", "cp", "b", "gp", "bc", "pg", "mp", "pc", "xb", "bb", "uf", "px", "nb", "bp", "pkg", "pl", "tp", "pan"], "len": ["resp", "il", "Length", "bytes", "nl", "tl", "f", "ret", "lf", "Len", "ll", "size", "l", "fun", "cmd", "n", "ln", "cmp", "seq", "dl", "L", "val", "v", "compl", "sl", "el", "t", " clen", "msg", "end", "offset", "num", "ls", "nt", "lit", "lon", " bl", "sp", " le", "lic", "count", "en", "pos", " l", "limit", "all", "lan", "lp", "un", "e", "hl", "length", " el", "elt", "err", "z", "fin", "str", " length", "ld", "lc"]}}
{"project": "FFmpeg", "commit_id": "4381bddc9f93da34a44e683bdc4c05c6f061244e", "target": 0, "func": "int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)\n\n{\n\n    char *tail;\n\n    double srate = av_strtod(arg, &tail);\n\n    if (*tail || srate < 1 || (int)srate != srate) {\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Invalid sample rate '%s'\\n\", arg);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    *ret = srate;\n\n    return 0;\n\n}\n", "idx": 13339, "substitutes": {"ret": ["rc", "def", "mem", "f", "ref", "out", "ll", "back", "Ret", "tr", "rets", "opt", "RET", "val", "v", "reg", "t", "result", "nt", "r", "gt", "att", "alt", "rep", "rev", "rt", "res", "report", "re", "fr", "mt", "repl", "ft", "elt", "arr"], "arg": ["param", "oc", "ref", "ax", "attr", "cmd", "ag", "p", "inc", "call", "claim", "val", "v", "agg", "reg", "ar", "ig", "g", "mac", "msg", "in", "tag", "Arg", "r", "alg", "doc", "match", "ac", "parse", "cal", "event", "argument", "args", "ack", "ad", "iter", "enc", "var", "target", "ary", "pl", "name", "str", "asc", "arr", "arp"], "log_ctx": ["logctxctx", "logboxkw", "log_tx", " log2kw", "log_ct", "logboxctx", " log_tx", "log2lib", " log_ct", " log2lib", "log2ctx", "logctxtx", " log2context", "logboxlib", "log2kw", " log_context", "logboxcontext", " log_lib", "logctxct", " log2ctx", "log_context", "logctxcontext", " log_kw", "log_lib", "log2context", "log_kw"], "tail": ["quit", "il", "index", "wind", "ctl", "local", "det", "ll", "head", "l", "foot", "size", "tt", "body", "temp", "tailed", "ail", "t", "unit", "len", "locked", "offset", "ls", "lock", "gt", "alt", "last", "gate", "tails", "got", "ts", "buffer", "unt", "sp", "pull", "limit", "lt", "ul", "fat", "lv", "term", "tmp", "iter", "list", "length", "col", "bound", "ld", "sum"]}}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    int32_t op2;\n\n    int32_t r1;\n\n    uint32_t address;\n\n    TCGv temp;\n\n\n\n    r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n    address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n    op2 = MASK_OP_ABS_OP2(ctx->opcode);\n\n\n\n    temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n\n\n    switch (op2) {\n\n    case OPC2_32_ABS_ST_A:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);\n\n        break;\n\n    case OPC2_32_ABS_ST_D:\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);\n\n        break;\n\n    case OPC2_32_ABS_ST_DA:\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);\n\n        break;\n\n    case OPC2_32_ABS_ST_W:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL);\n\n        break;\n\n\n\n    }\n\n    tcg_temp_free(temp);\n\n}\n", "idx": 13347, "substitutes": {"env": ["node", "status", "impl", "conn", "serv", "environment", "cur", "map", "scope", "hw", "cmd", "proc", "v", "test", "stack", "buf", "cfg", "STATE", "cb", "event", "en", "dev", "viron", "set", "conf", "ev", "exec", "txt"], "ctx": ["conn", "hw", "cmp", "mk", "cas", "check", "pool", "loc", "ann", "context", "parent", "cb", "xc", "shape", "qt", "pkg", "exec", "tx", "kw", "ctl", "def", "mem", "wx", "setup", "cmd", "js", "crit", "kt", "conv", "xp", "wcs", "via", "cfg", "obj", "cp", "gc", "mc", "Context", "tmp", "conf", "txt", "history", "resp", "cf", "kh", "asm", " context", "cc", "req", "xs", "sys", "np", "json", "info", "work", " cx", "cv", "mom", "kl", "bc", "etc", "config", "tm", "jac", "jp", "cu", "tc", "cm", "chain", "except", "kind", "func", "ct", "cam", "act", "desc", "gz", "network"], "op2": ["OP2", "opp16", "r4", "OP4", "opp2", "oper4", " op6", "opt2", "opp4", "op16", " op4", "OP02", "oper2", "Op4", "r2", "optTwo", "opt02", "oper02", "oper16", "op02", "OP16", "opp02", "op5", "rTwo", "Op2", " opTwo", "Op5", "OP5", "Op6", " op5", "opt4", "op4", "r02", "op6", "OP6", "opTwo", " op02"], "r1": ["r51", "rOnce", "rOne", "rn51", "ro81", " r81", "sraj", "krMap", "nrOnce", " r3", "brName", "l01", "cr81", "erOnce", "r3", "row51", "mr51", "er001", "ro1", "ro001", "m1", "sr1", "mrOne", "vrOne", "rt1", "nr9", "raj", "cr01", "cr1", "nr001", "row81", "cr001", "er9", "vr1", "sr51", "l81", "rtFirst", "rowOne", "l001", "sr001", "range1", "m3", "R1", "crMap", "rnFirst", "R2", "erOne", "pr1", "br51", "r01", "craj", "rn1", "vrMap", "ro01", "rt51", "erMap", "l1", "er1", "r0", "rFirst", "br001", "kr1", "br1", "pr51", "kr001", "kraj", "r9", "rt001", "rName", "row1", " r2", "rangeOnce", "prFirst", " r0", "range9", "mr1", "rMap", "m0", "srMap", "range001", "r2", "R3", "R0", " rMap", "srName", "rtName", " rOne", " r51", "r81", "m2", "r001", "mr81", "nr1"], "address": ["index", "key", "path", "a", "ptr", "number", "position", "output", "size", "addr", "reference", "port", "store", "padding", "command", "offset", "memory", "context", "message", "operation", "word", "attribute", "buffer", "block", "capacity", "base", "location", "code", "alias", "table", "point", "order", "trace", "ace", "length", "shape", "interface", "i", "angle", "pointer", "Address"], "temp": ["tx", "index", "hum", "porary", "mem", "tc", "ptr", "local", "output", "perature", "tv", "p", "tr", "EMP", "mint", "v", "pretty", "pool", "test", "pt", "t", "unit", "tem", "cache", "result", "cap", "now", "offset", "m", "timer", "memory", "context", "nom", "time", "json", "current", "buffer", "sp", "variable", "unt", "empty", "cum", "term", "tmp", "fake", "draw", "iter", "trace", "pre", "Temperature", "mod", "total", "max", "emp", "vt", "tim", "dat", "tm", "level", "Temp", "cont", "txt", "template", "w", "sum"]}}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_readdir(void *opaque)\n\n{\n\n    int32_t fid;\n\n    V9fsFidState *fidp;\n\n    ssize_t retval = 0;\n\n    size_t offset = 7;\n\n    uint64_t initial_offset;\n\n    int32_t count;\n\n    uint32_t max_count;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dqd\", &fid, &initial_offset, &max_count);\n\n\n\n    trace_v9fs_readdir(pdu->tag, pdu->id, fid, initial_offset, max_count);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        retval = -EINVAL;\n\n        goto out_nofid;\n\n    }\n\n    if (!fidp->fs.dir) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    if (initial_offset == 0) {\n\n        v9fs_co_rewinddir(pdu, fidp);\n\n    } else {\n\n        v9fs_co_seekdir(pdu, fidp, initial_offset);\n\n    }\n\n    count = v9fs_do_readdir(pdu, fidp, max_count);\n\n    if (count < 0) {\n\n        retval = count;\n\n        goto out;\n\n    }\n\n    retval = offset;\n\n    retval += pdu_marshal(pdu, offset, \"d\", count);\n\n    retval += count;\n\n    trace_v9fs_readdir_return(pdu->tag, pdu->id, count, retval);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, retval);\n\n}\n", "idx": 13357, "substitutes": {"opaque": [" opatile", "pvious", " opaques", "obaques", "oplque", "oplaque", "obque", "obvious", "pque", " opque", "obatile", "Opaques", "Opaque", "opaques", "obaque", "opvious", "oplvious", "Opque", "opatile", "paque", "paques", "opque", "oplaques", "Opatile"], "fid": ["vpid", "ifid", "tfid", "tfoid", "vId", " fkid", "FId", "efoid", "Fid", "vID", " fID", "tfId", "ifkid", "fID", " faid", "Faid", "vname", "gid", "fname", "efId", "vid", "tfname", " fname", "ifname", "fId", "gID", "faid", "efid", "Foid", " fpid", "vkid", "fkid", "foid", "tfID", "gId", " foid", "efaid", "gname", "fpid", "ifpid", " fId"], "fidp": ["affidpa", "flkeypost", "foidb", "fidy", "finitpb", "fkidphp", "fIDpost", "fitpb", "flkeyp", "finitpost", "fpidp", "finity", "fidps", "flidpost", "fbidphp", "fadpc", " fity", "foidpost", "foidp", "fidpos", "flidpa", "fixp", " fidy", "fIDb", "flidlp", "faidj", "fidphp", " fIdp", "finitper", "flridnp", "fitper", " fidpe", "fridnp", "fkidper", "flkeyphp", "faidphp", "fIDj", "finpe", "fidpe", "finp", "fbidp", "fidnp", "fridp", "flidnp", "fridphp", "affidphp", " foidpe", "flbidp", " foidm", "fity", "fkeyphp", "flidp", "foidphp", "fflagpa", "foidm", " fitper", "flbidpa", "fIdper", "fpidper", "fflagper", "foidps", "finper", "fIDpb", "fidlp", "fkidnp", "finm", "fardper", " fIdper", "fbidper", "affbidper", "flridpc", "fidpb", "fpidpe", "fpidm", "faidp", "faidpost", "fidentp", "affbidp", "fIDp", "flkeyps", "fflagpos", "flidpos", " fidpb", "faidb", " fidper", "fbidpos", "flidps", "fadp", "fidentpos", "fixphp", " fitpb", "finitb", "fkeypost", "finitp", "fbidpa", "fkidpc", "fridpc", "fidpa", "fidpc", "fidentlp", " fidm", "flidpc", "foidpe", " fidpa", "finitj", "fkidp", "fixper", "fidm", "fixpa", "fidpost", "foIDj", "fkidpa", "fadnp", "fIDy", "foIDpost", "fIdpa", "fkeyp", "fardpa", "flridphp", "flbidpos", "flidphp", " foidper", "foIDp", "affbidpa", " fitp", "fidper", "fkeyps", "foidper", "flridp", "foidj", "fidb", "affbidphp", "affidp", "fadphp", "affidper", "fbidlp", "foIDb", "fIdp", "fIDper", " fIdpa", "fidentpa", "flbidlp", "fitp", "fidj", "fflagp", "faidps", "fardp", " foidp", "fflaglp"], "initial_offset": ["initial_range", "initiallycount", "initial_off", "initiallyrange", "initiallyOffset", " initial_len", "initiallyoffset", "initial_count", " initial_count", " initial_point", "initial__off", "first_index", "initial__index", "initial_index", "initial_Offset", "initial_length", "initialinglen", " initial_off", "initial_point", "first_offset", "initial_pos", "first_pos", " initial_pointer", "Initial_length", "initial__pos", "initiallyindex", "initialingoffset", "Initial_offset", "Initial_Offset", "initiallyoff", "initialingpointer", " initial_range", "initial__offset", "initial_pointer", "initiallypos", "first_off", "initialingOffset", "initial_len", " initial_Offset"], "count": ["index", "amount", "error", "type", "frequency", "child", "number", "cond", "size", "l", "cmd", "core", "n", "depth", "call", "cc", "val", "try", "counter", "batch", "ctr", "len", "read", "cache", "result", "currency", "command", "offset", "num", "ct", "nt", "time", "ount", "match", "comment", "current", "find", "buffer", "c", "empty", "all", "code", "more", "flag", "start", "h", "found", "order", "cont", "consider", "iter", "max", "length", "total", "weight", "nb", "list", "err", "z", "state", "hash", "Count", "name", "process", "force", "ch", "sum"], "max_count": ["max_len", " max_result", "max__length", "max__iter", "max_iter", "max_sum", "maxJcount", "max_Count", "max32count", "max_ctr", "maxJresult", "max32c", "Max_ctr", " max_len", "max__count", "Max_count", "max_length", "max_state", "maxJstate", "max32length", "max32iter", "max_result", "max__c", "maxJCount", "Max_Count", "max_c", " max_state", "Max_sum", " max_c", " max_iter", " max_Count", " max_length"], "pdu": ["pptem", "apge", "pcom", " pdon", "yue", "ipstat", "ipkt", "pde", "pcver", "exptu", "vpdu", "repge", " pix", "ppdu", "pingstat", "pingtu", " pkt", " pde", "apde", "fdu", "pud", " ptem", "vpuer", "runit", "opkt", "pstat", "pda", "apcu", "expue", "puer", "ipdu", "preui", "perda", "pond", "pdon", " pver", " pda", "opdu", " psu", " pcom", "cpcu", "opge", " punit", "pcdon", "pver", "mdef", "cpge", "pue", "apsu", "prdu", "repdu", " pui", "pptu", " pud", "pkt", "pui", "repuu", "apdu", "fstat", " pge", "apond", "msu", "ycu", "padu", "pingdu", "paix", "opuu", "pcu", "pretu", "pinguer", "apda", " puu", " pdef", "pingud", "pingcom", "ytem", "vpso", "reptu", " pond", "ppui", "iptu", "puu", "mdu", "optu", "psu", "ppcu", "fcu", "cpdu", " pstat", "padon", " ptu", "pso", "pdef", "predu", " pce", "opce", " pso", "cpue", "preue", "pce", "ppue", "pingsu", "expdu", " pue", "pingui", "apud", "prdef", "rcu", " pcu", "expond", "ptu", "ydu", "perud", "pingde", "punit", "prkt", "paver", "prsu", "ptem", "pge", "vpcom", "pingcu", "pix", "ipcu", "aptu", "apue", "apui", "perdu", " puer", "mkt", "rstat", "rdu", "perde", "funit", "pcix", "ipce", "pingso", "pcdu"], "s": ["gs", "S", "f", "as", "o", "bs", "session", "n", "p", "js", "sq", "v", "g", "t", "is", "sb", "sv", "sys", "ds", "ls", "m", "r", "acs", "ts", "c", "sp", "stats", "ins", "ns", "b", "h", "ims", "set", "e", "fs", "u", "os", "state", "d", "z", "w", "ss", "i", "rs", "ps"]}}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    uint32_t cc = 0;\n\n    int old_exc = cs->exception_index;\n\n    uint64_t asc = env->psw.mask & PSW_MASK_ASC;\n\n    uint64_t ret;\n\n    int flags;\n\n\n\n    /* XXX incomplete - has more corner cases */\n\n    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {\n\n        program_interrupt(env, PGM_SPECIAL_OP, 2);\n\n    }\n\n\n\n    cs->exception_index = old_exc;\n\n    if (mmu_translate(env, addr, 0, asc, &ret, &flags)) {\n\n        cc = 3;\n\n    }\n\n    if (cs->exception_index == EXCP_PGM) {\n\n        ret = env->int_pgm_code | 0x80000000;\n\n    } else {\n\n        ret |= addr & ~TARGET_PAGE_MASK;\n\n    }\n\n    cs->exception_index = old_exc;\n\n\n\n    env->cc_op = cc;\n\n    return ret;\n\n}\n", "idx": 13363, "substitutes": {"env": ["server", "nv", "esm", "nw", " ens", "ptr", "et", "conn", "sw", "environment", "cur", "cmd", "ctx", "hw", "window", "erd", "proc", "req", "cc", "v", "esc", "sv", "er", "st", "sb", "end", "sec", "ds", "desc", "ew", "context", "ah", "obj", "org", "vm", "sp", "cb", "cv", "db", "event", "en", "nc", "ec", "console", "vs", "dev", "h", "here", "e", "Environment", "conf", "enc", "hl", "config", "eng", "qt", "eh", "ev", "vt", "pkg", "esp", "forge", "sc", "te", "worker"], "addr": ["tx", "rc", "nl", "mem", "ptr", "ref", "src", "handle", "address", "attr", "cmd", "size", "hw", "ag", "wire", "cmp", "dr", "ord", "ar", "adr", "loc", "msg", "np", "offset", "num", "oad", "r", "gt", "eth", "url", "alt", "obj", "off", "add", "dest", "res", "coord", "alias", "ack", "id", "mt", "host", "ad", "hl", "arg", "hash", "pad", "elt", "net", "err", "mb", "ip", "x", "asc", "usr", "rs", "ix", "arr", "arp"], "cs": ["rc", "gs", "cf", "tc", "conn", "bs", "cus", "cn", "ys", "ctx", "CS", "js", "Cs", "cc", "cas", "css", "ms", "ces", "ctr", "cer", "wcs", "hs", "cks", "ds", "cms", "ls", "act", "obj", "acs", "qs", "ck", "ts", "c", "cv", "nc", "ec", "vs", "ins", "cp", "cons", "gc", "ns", "fs", "ks", "sts", "sc", "checks", "rs", "ps"], "ret": ["resp", "rc", "nl", "at", "mem", "ptr", "out", "ref", " RET", "ll", "data", "expr", "back", "Ret", "x", "rets", "RET", "val", "try", "reg", "test", "t", "len", "ert", "result", "end", "ext", "nz", "nt", "lit", "r", "gt", "alt", "url", "rs", "rt", "rev", "ts", "ter", "std", "res", "print", "flag", "re", "mt", "arg", "ft", "elt", " Ret", "xt", "str", "txt", "arr"], "flags": ["comments", "kw", "gs", "cf", "tags", "cond", "cmd", "mask", "bits", "ags", "cc", "fields", "acc", "wcs", "func", "bugs", "mods", "acs", "atts", "acts", "lag", "vals", "ts", "Flags", "stats", "ops", "flag", "args", "acks", "amps", "fs", "locks", "options", "fps", "files", "ents", "ms", "rs", "ps"]}}
{"project": "qemu", "commit_id": "46181129eac9a56d9a948667282dd03d5015f096", "target": 0, "func": "static int bdrv_check_update_perm(BlockDriverState *bs, uint64_t new_used_perm,\n\n                                  uint64_t new_shared_perm,\n\n                                  BdrvChild *ignore_child, Error **errp)\n\n{\n\n    BdrvChild *c;\n\n    uint64_t cumulative_perms = new_used_perm;\n\n    uint64_t cumulative_shared_perms = new_shared_perm;\n\n\n\n    /* There is no reason why anyone couldn't tolerate write_unchanged */\n\n    assert(new_shared_perm & BLK_PERM_WRITE_UNCHANGED);\n\n\n\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n\n        if (c == ignore_child) {\n\n            continue;\n\n        }\n\n\n\n        if ((new_used_perm & c->shared_perm) != new_used_perm) {\n\n            char *user = bdrv_child_user_desc(c);\n\n            char *perm_names = bdrv_perm_names(new_used_perm & ~c->shared_perm);\n\n            error_setg(errp, \"Conflicts with use by %s as '%s', which does not \"\n\n                             \"allow '%s' on %s\",\n\n                       user, c->name, perm_names, bdrv_get_node_name(c->bs));\n\n            g_free(user);\n\n            g_free(perm_names);\n\n            return -EPERM;\n\n        }\n\n\n\n        if ((c->perm & new_shared_perm) != c->perm) {\n\n            char *user = bdrv_child_user_desc(c);\n\n            char *perm_names = bdrv_perm_names(c->perm & ~new_shared_perm);\n\n            error_setg(errp, \"Conflicts with use by %s as '%s', which uses \"\n\n                             \"'%s' on %s\",\n\n                       user, c->name, perm_names, bdrv_get_node_name(c->bs));\n\n            g_free(user);\n\n            g_free(perm_names);\n\n            return -EPERM;\n\n        }\n\n\n\n        cumulative_perms |= c->perm;\n\n        cumulative_shared_perms &= c->shared_perm;\n\n    }\n\n\n\n    return bdrv_check_perm(bs, cumulative_perms, cumulative_shared_perms, errp);\n\n}\n", "idx": 13365, "substitutes": {"bs": ["bytes", "gs", "ubis", "ubs", "ib", "obs", "aos", "pb", "hz", "ctx", "js", "bits", "bh", "sb", "aus", "sys", "ds", "ls", "s", "bn", "BS", "ts", "bos", "bm", "db", "boxes", "bf", "bas", "blog", "vs", "res", "b", "bl", "cs", "bc", "lbs", "ns", "fs", "bps", "os", "bis", "its", "bp", "ms", "rs", "ps"], "new_used_perm": ["new_zero_perm", "new_usedfulpriv", "new_used_req", "new_usedfulmi", "new_user_perm", "new_used67pixel", "new_zerofulpriv", "new_use_priv", "new_user_pixel", "new_zerofulperm", "new_used_mi", "new_use_pri", "new_used_attr", "new_zero_priv", "new_user_req", "new_use_attr", "new_used67req", "new_used67perm", "new_used_pixel", "new_used_per", "new_used67attr", "new_use_prof", "new_used_pri", "new_used_prof", "new_used_priv", "new_zero_mi", "new_usedfulperm", "new_zerofulmi", "new_use_per", "new_user_attr", "new_use_perm"], "new_shared_perm": ["new_shared2priv", "new_share_mask", "new_shared_req", "new_shared_mask", "new_shared2req", "new_share_policy", "new_shared2perm", "new_shared___ptr", "new_share_priv", "new_shared_policy", "new_shared_priv", "new_shared___req", "new_shared___priv", "new_shared2mask", "new_share_ptr", "new_sharedlyperm", "new_shared___perm", "new_shared_attr", "new_sharedlyattr", "new_shared2attr", "new_sharedptperm", "new_share_req", "new_share_perm", "new_shared_ptr", "new_sharedptpriv", "new_share_attr", "new_shared_lim", "new_sharedptattr", "new_sharedptpolicy", "new_sharedlylim"], "ignore_child": ["ignore___Child", "ignore___node", "ignore___parent", " ignore_children", "ignore___child", "ignore___children", "ignore_node", "ignore_parent", "ignore_children", " ignore_node", " ignore_parent", "ignore_Child", " ignore_Child"], "errp": ["rrc", "ferpo", "errorpkg", "errpkg", "errps", "rrpa", "rrpo", "errorpad", "ierpost", "dangerpad", "ierp", "ferp", "erc", " errc", "dangerpost", "errorps", " errps", "errping", "errorp", "dangerpkg", " errP", "rrping", "errr", "nerps", "nerpo", "errP", "errpost", "errc", "errpo", "rrr", "dangerp", "nerpa", "ferpa", "rrp", "errorping", "rrP", "errpad", "erP", "ferps", "nerp", "ierpkg", "rrps", " errr", "err", "erp", "errorpost", " errping", "errpa", "ierpad"], "c": ["cr", "cur", "ctx", "t", "com", "m", "cb", "xc", "abc", "cs", "cont", "rc", "co", "unc", "cus", "lc", "j", "n", "v", "g", "comm", "container", "comp", "cp", "gc", "mc", "ctrl", "con", "conf", "vc", "i", "ca", "cf", "f", "cn", "call", "cc", "common", "C", "cv", "ci", "ec", "bc", "etc", "pc", "enc", "config", "cu", "tc", "o", "cm", "l", "p", "cd", "chain", "cache", "dc", "ct", "k", "cam", "cl", "r", "ac", "b", "fc", "e", "col", "w", "sc", "y", "ce", "anc", "ch"], "user": ["server", "actor", "browser", "username", "by", "USER", "usable", "manager", "um", "ver", "per", "admin", "owner", "role", "group", "or", "class", "creator", "author", "io", "usa", "us", "used", "er", "uid", "util", "dirty", "menu", "word", "full", "parent", "use", "info", "db", "file", "password", "client", "student", "device", "ser", "dev", "root", "id", "inner", "u", "User", "from", "valid", "prof", "me", "human", "usage", "home", "users", "name", "usr", "ip"], "perm_names": ["orig3names", "perm_types", "permmatdocs", "provmmnames", "permmatstates", "proc_names", "sym_names", "perm_ames", "proc_weights", "permmmtypes", "gp_types", "permmatdes", "symmatdes", "permpttypes", "orig3nos", "permmattypes", "perm_states", "perm8ames", "orig_names", "orig3strings", "permlauthors", "perm10names", "gpmmtypes", "perm_nas", "perm_des", "per_values", "provmmdocs", "perm3nos", "provmmAMES", "permmmnets", "perm32docs", "permsnames", "permmmdocs", "perm3strings", "permmatweights", "perm_nos", "perm_AMES", "perm_weights", "gp_names", "perm_nets", "symmatstates", "perm_chains", "sym_des", "perm32nets", "prov_names", "per_chains", "permsnos", "permmatAMES", "perm_ns", "perm10authors", "prov_AMES", "perm32AMES", "permmatnas", "perm3names", "prov_nets", "symmatns", "permsauthors", "permptnas", "proc_states", "sym_ns", "permmatnets", "gp_lines", "perm8names", "perm8states", "gpmmlines", "orig_authors", "prov_docs", "perm32names", "permlstrings", "symmatnames", "permmmlines", "gpmmnas", "permmatnames", "permmatns", "sym_states", "perm_values", "perm3authors", "permlnames", "perm_strings", "perm_docs", "proc_ames", "permlnos", "permmmnames", "perm10chains", "permsstrings", "perm10values", "per_authors", "permptlines", "perm8weights", "per_names", "orig_strings", "perm_authors", "permmatlines", "permmatames", "gpmmnames", "permptnames", "perm_lines", "gp_nas", "orig3authors", "permmmAMES", "permmmnas", "orig_nos", "provmmnets"]}}
{"project": "qemu", "commit_id": "810f49b56a5d0cd6848856af51d3093ae9adc7b1", "target": 0, "func": "static void monitor_protocol_emitter(Monitor *mon, QObject *data)\n\n{\n\n    QDict *qmp;\n\n\n\n    qmp = qdict_new();\n\n\n\n    if (!monitor_has_error(mon)) {\n\n        /* success response */\n\n        if (data) {\n\n            assert(qobject_type(data) == QTYPE_QDICT);\n\n            qobject_incref(data);\n\n            qdict_put_obj(qmp, \"return\", data);\n\n        } else {\n\n            /* return an empty QDict by default */\n\n            qdict_put(qmp, \"return\", qdict_new());\n\n        }\n\n    } else {\n\n        /* error response */\n\n        qdict_put(mon->error->error, \"desc\", qerror_human(mon->error));\n\n        qdict_put(qmp, \"error\", mon->error->error);\n\n        QINCREF(mon->error->error);\n\n        QDECREF(mon->error);\n\n        mon->error = NULL;\n\n    }\n\n\n\n    if (mon->mc->id) {\n\n        qdict_put_obj(qmp, \"id\", mon->mc->id);\n\n        mon->mc->id = NULL;\n\n    }\n\n\n\n    monitor_json_emitter(mon, QOBJECT(qmp));\n\n    QDECREF(qmp);\n\n}\n", "idx": 13366, "substitutes": {"mon": ["conn", "ston", "loader", "por", "onet", "stat", "man", "mind", "sam", "den", "mont", "jon", "m", "ann", " monitor", "MON", "mond", "mm", "mit", "coord", "met", "tom", "pers", "my", "trace", "hon", "net", "exec", "mun", "rem", "annot", "mem", "about", "cmd", "comm", "cat", "mor", "mt", "con", "monkey", "tim", "mn", "form", "ver", "mi", "cond", "hog", "auth", "zon", "proc", "monitor", "unit", "Mon", "tem", "mate", "ten", "mobile", "dom", "mu", "demon", "don", "dat", "wat", "umi", "serv", "local", "det", "admin", "min", "dm", "util", "num", "san", "runner", "mut", "mitter", "mat", "von", "non", "mons"], "data": ["def", "instance", "des", "type", "record", "rew", "o", "query", "object", "map", "p", "row", " DATA", "present", "raw", "what", "missing", "text", "details", "done", "batch", "maybe", "cache", "result", "bin", "new", "item", "m", "part", "none", "obj", "snap", "extra", "full", "parent", "info", "empty", "buffer", "one", "all", "trans", "content", "Data", "res", "table", "no", "unknown", "related", "id", "partial", "any", "rel", "hash", "d", "to", "DATA", "format", "ata", "value", "dat", "zero", "join", "name", "some", "valid", "results", "normal", "wat"], "qmp": ["qMP", "qualpro", "quMP", " qomp", "querypp", "qupro", "quomp", "qcmp", " qep", "qcomp", "qpm", "iqjp", "sqcmp", "querycp", "querymp", "querymet", "qtmp", " qtmp", "qualmp", "qupm", "qpro", "questmp", "sqcomp", "qjp", "sqcp", "quep", "sqmet", "qualcmp", "qucomp", "quickmp", " qpp", "sqpp", "qujp", "qucmp", "questomp", " qcp", "iqpp", "iqmp", "sqmp", "iqpm", "sqtmp", "sqep", " qcomp", "questtmp", "questMP", "sqjp", "querypro", "qumb", "qump", "quickpp", "qumet", " qmb", "qupp", "quickcp", "qutmp", "queryjp", "qualmet", "quickjp", "qomp", "qep", "qmet", "qpp", "qmb", "qucp", "quickpm", "queryomp", "querycmp", " qMP", "sqomp", "qcp", "quickmb"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static inline int decode_vui_parameters(H264Context *h, SPS *sps)\n\n{\n\n    int aspect_ratio_info_present_flag;\n\n    unsigned int aspect_ratio_idc;\n\n\n\n    aspect_ratio_info_present_flag = get_bits1(&h->gb);\n\n\n\n    if (aspect_ratio_info_present_flag) {\n\n        aspect_ratio_idc = get_bits(&h->gb, 8);\n\n        if (aspect_ratio_idc == EXTENDED_SAR) {\n\n            sps->sar.num = get_bits(&h->gb, 16);\n\n            sps->sar.den = get_bits(&h->gb, 16);\n\n        } else if (aspect_ratio_idc < FF_ARRAY_ELEMS(pixel_aspect)) {\n\n            sps->sar = pixel_aspect[aspect_ratio_idc];\n\n        } else {\n\n            av_log(h->avctx, AV_LOG_ERROR, \"illegal aspect ratio\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else {\n\n        sps->sar.num =\n\n        sps->sar.den = 0;\n\n    }\n\n\n\n    if (get_bits1(&h->gb))      /* overscan_info_present_flag */\n\n        get_bits1(&h->gb);      /* overscan_appropriate_flag */\n\n\n\n    sps->video_signal_type_present_flag = get_bits1(&h->gb);\n\n    if (sps->video_signal_type_present_flag) {\n\n        get_bits(&h->gb, 3);                 /* video_format */\n\n        sps->full_range = get_bits1(&h->gb); /* video_full_range_flag */\n\n\n\n        sps->colour_description_present_flag = get_bits1(&h->gb);\n\n        if (sps->colour_description_present_flag) {\n\n            sps->color_primaries = get_bits(&h->gb, 8); /* colour_primaries */\n\n            sps->color_trc       = get_bits(&h->gb, 8); /* transfer_characteristics */\n\n            sps->colorspace      = get_bits(&h->gb, 8); /* matrix_coefficients */\n\n            if (sps->color_primaries >= AVCOL_PRI_NB)\n\n                sps->color_primaries = AVCOL_PRI_UNSPECIFIED;\n\n            if (sps->color_trc >= AVCOL_TRC_NB)\n\n                sps->color_trc = AVCOL_TRC_UNSPECIFIED;\n\n            if (sps->colorspace >= AVCOL_SPC_NB)\n\n                sps->colorspace = AVCOL_SPC_UNSPECIFIED;\n\n        }\n\n    }\n\n\n\n    /* chroma_location_info_present_flag */\n\n    if (get_bits1(&h->gb)) {\n\n        /* chroma_sample_location_type_top_field */\n\n        h->avctx->chroma_sample_location = get_ue_golomb(&h->gb) + 1;\n\n        get_ue_golomb(&h->gb);  /* chroma_sample_location_type_bottom_field */\n\n    }\n\n\n\n    sps->timing_info_present_flag = get_bits1(&h->gb);\n\n    if (sps->timing_info_present_flag) {\n\n        sps->num_units_in_tick = get_bits_long(&h->gb, 32);\n\n        sps->time_scale        = get_bits_long(&h->gb, 32);\n\n        if (!sps->num_units_in_tick || !sps->time_scale) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"time_scale/num_units_in_tick invalid or unsupported (%\"PRIu32\"/%\"PRIu32\")\\n\",\n\n                   sps->time_scale, sps->num_units_in_tick);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sps->fixed_frame_rate_flag = get_bits1(&h->gb);\n\n    }\n\n\n\n    sps->nal_hrd_parameters_present_flag = get_bits1(&h->gb);\n\n    if (sps->nal_hrd_parameters_present_flag)\n\n        if (decode_hrd_parameters(h, sps) < 0)\n\n            return AVERROR_INVALIDDATA;\n\n    sps->vcl_hrd_parameters_present_flag = get_bits1(&h->gb);\n\n    if (sps->vcl_hrd_parameters_present_flag)\n\n        if (decode_hrd_parameters(h, sps) < 0)\n\n            return AVERROR_INVALIDDATA;\n\n    if (sps->nal_hrd_parameters_present_flag ||\n\n        sps->vcl_hrd_parameters_present_flag)\n\n        get_bits1(&h->gb);     /* low_delay_hrd_flag */\n\n    sps->pic_struct_present_flag = get_bits1(&h->gb);\n\n\n\n    sps->bitstream_restriction_flag = get_bits1(&h->gb);\n\n    if (sps->bitstream_restriction_flag) {\n\n        get_bits1(&h->gb);     /* motion_vectors_over_pic_boundaries_flag */\n\n        get_ue_golomb(&h->gb); /* max_bytes_per_pic_denom */\n\n        get_ue_golomb(&h->gb); /* max_bits_per_mb_denom */\n\n        get_ue_golomb(&h->gb); /* log2_max_mv_length_horizontal */\n\n        get_ue_golomb(&h->gb); /* log2_max_mv_length_vertical */\n\n        sps->num_reorder_frames = get_ue_golomb(&h->gb);\n\n        get_ue_golomb(&h->gb); /*max_dec_frame_buffering*/\n\n\n\n        if (get_bits_left(&h->gb) < 0) {\n\n            sps->num_reorder_frames         = 0;\n\n            sps->bitstream_restriction_flag = 0;\n\n        }\n\n\n\n        if (sps->num_reorder_frames > 16U\n\n            /* max_dec_frame_buffering || max_dec_frame_buffering > 16 */) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Clipping illegal num_reorder_frames %d\\n\",\n\n                   sps->num_reorder_frames);\n\n            sps->num_reorder_frames = 16;\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n    if (get_bits_left(&h->gb) < 0) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"Overread VUI by %d bits\\n\", -get_bits_left(&h->gb));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13388, "substitutes": {"h": ["uh", "ph", "kh", "has", "handle", "hr", "header", "high", "l", "hz", "p", "hm", "window", "hw", "bh", "v", "ha", "http", "t", "comm", "ih", "help", "cache", "hs", "m", "ah", "th", "he", "s", "hd", "c", "rh", "event", "oh", "sh", "ht", "b", "H", "here", "host", "hl", "hash", "dh", "her", "eh", "q", "hh", "w", "x", "y", "history", "ch", "hp"], "sps": ["isports", "Srs", "sPS", " sips", "esps", " sops", "lsports", "asds", "portsips", "ispl", "unsiffs", " spps", "splays", "geseps", "iespoints", "iesp", "yesps", "eseps", "portseps", "spps", "usps", " sists", "asrs", "nseps", "sport", "spers", "inspoints", "spoints", "gesops", "sds", "iespps", "splets", "isport", "sops", "useps", "ists", "isips", "unseps", "jsops", " srs", "commplets", " sp", "yespos", "Spp", "spp", "yespose", "insplays", "usports", "nsists", " sposes", "unsps", "jspers", "insps", "spl", "iesplays", "commpoints", "ispr", "commps", "esports", "commplays", "usiffs", "commeps", " spp", "Spers", "atspers", "portsps", "spose", " spos", " seps", "asists", "Spos", " spose", "jsPS", "gesps", "asplays", "atsps", "asips", "sips", "atspps", "iseps", "Sps", "asplets", " sport", "iesps", "nspers", " spoints", "seps", "nsps", "isplays", " sPS", "uspps", "sists", " sports", "sports", " sds", "commports", "spos", "SPS", "aspoints", "ispose", "unsips", "isps", "asports", "portsiffs", "usips", "spr", "jsps", "sposes", "ispps", "usposes", "asops", "nsds", "asps", "ispers", "ispos", "iesposes", " sts", "asPS", "nsops", " splays", "uspr", "insplets", "gespers", "espr", "sp", "atsports", "iesports", "siffs", "yesports", " spl", "ispp", "lsps", "aspp", "srs", "sts", " spers", "lspp", "lspers"], "aspect_ratio_info_present_flag": ["aspect_ratio_info_Present_log", "aspect_ratio_info_present_log", "aspect_ratio_info_present_Flag", "aspect_ratio_info_Present_flags", "aspect_ratio_info_Present_flag", "aspect_ratio_info_present_status", "aspect_ratio_info_Present_Flag", "aspect_ratio_info_Present_status", "aspect_ratio_info_present_flags"], "aspect_ratio_idc": ["aspect_ratio_idel", "aspect_ratio_Idc", "aspect_ratio_cdc", "aspect_ratio_idz", "aspect_ratio2idn", "aspect_ratio2cdl", "aspect_ratio_sidx", "aspect_ratio_itn", "aspect_ratio_idec", "aspect_ratio_idx", "aspect_ratio_idex", "aspect_ratio_cdn", "aspect_ratio_idl", "aspect_ratio_ridce", "aspect_ratio_cdz", "aspect_ratio_sidc", "aspect_ratio_ridx", "aspect_ratio_idecos", "aspect_ratio_idcos", "aspect_ratio2idc", "aspect_ratio_iden", "aspect_ratio_itc", "aspect_ratio_cdl", "aspect_ratio2idl", "aspect_ratio_Idx", "aspect_ratio_idece", "aspect_ratio_Idci", "aspect_ratio_ridc", "aspect_ratio_itl", "aspect_ratio2cdc", "aspect_ratio_ridl", "aspect_ratio_Idce", "aspect_ratio_sidn", "aspect_ratio_sidcos", "aspect_ratio_idn", "aspect_ratio2idz", "aspect_ratio_idce", "aspect_ratio_idci", "aspect_ratio2cdz", "aspect_ratio_ridci", "aspect_ratio2cdn", "aspect_ratio_itz"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,\n\n                          const uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    int ret;\n\n\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (!drv->bdrv_write_compressed) {\n\n        return -ENOTSUP;\n\n    }\n\n    ret = bdrv_check_request(bs, sector_num, nb_sectors);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);\n\n}\n", "idx": 13415, "substitutes": {"bs": ["bytes", "isc", "ses", "gs", "ubis", "ubs", "aos", "obs", "pb", "hz", "js", "bits", "bh", "bes", "sb", "aus", "bid", "hs", "sys", "cks", "ds", "ls", "iss", "BS", "qs", "bsp", "ts", "bos", "bm", "boxes", "bas", "blog", "vs", "gc", "b", "ns", "cs", "bc", "lbs", "es", "uts", "fs", "bps", "locks", "bis", "its", "bp", "sts", "ms", "rs", "ps"], "sector_num": ["sectoritynum", " sector_nm", "sectorlynum", "section_num", "sector_sym", "sector_number", "sector_pos", "server_Num", "section_no", " sector_pos", "sectorlysym", "serverlynum", " sector_number", "server_sym", "sector_Num", "sectorNamenum", "sectorNameNum", "section_Num", "sectoritynumber", "serverlysym", "server_na", "sectorNamena", "section_number", "serverlyNum", "sectorNamesym", "sector_nm", "sector_na", "sectoritypos", "sector_no", "sectorlyNum", "serverlyna", "sectoritynm", "sectorlyna", "server_num"], "buf": ["Buff", "bytes", "vec", "mem", "data", "seq", "map", "cmd", "pb", "p", "aka", "window", "raw", "Buffer", "proc", "text", "next", "batch", "box", "BU", "msg", "buff", "cap", "result", "func", "br", "bag", "doc", "buffer", "block", "cb", "cv", "b", "enc", "uf", "queue", "pkg", "alloc", "pack"], "nb_sectors": ["nb_seectors", "nb_segments", "nb_seeors", "nb_serers", "nb_seeurers", "nb_SEitors", "nb_veurers", "nb_beers", "nb_SEgments", "nb_vegments", "nb_bectors", "nb_persectors", "nb_begments", "nb_persegments", "nb_pegments", "nb_SEctors", "nb_seers", "nb_peurers", "nb_veitors", "nb_beors", "nb_SEors", "nb_perseitors", "nb_seitors", "nb_seurers", "nb_seegments", "nb_peors", "nb_serors", "nb_veers", "nb_serctors", "nb_sergments", "nb_perseors", "nb_vectors", "nb_seors", "nb_pectors", "nb_veors"], "drv": ["Drvc", "drvr", "drh", "rdr", "rdv", " drf", "drr", "DRv", "Drvr", "drif", " drw", "drw", "Drv", "darvr", "vrv", "darv", "hrh", " drve", "Drw", "vrf", " drm", "rdve", " drh", "drvc", "drve", "hrv", "srv", "drvs", "darw", "drivs", "srvs", "driv", "DRw", "hrr", "drm", "srf", "DRf", "vrvr", "vrm", " drr", "rdf", "rdw", "drf", "DRvr", "darvc", "srvr", "rdh", "DRm", "rdvs", "DRvc", "hrve", "srw", "Drf", "driw", " drvr"], "ret": ["resp", "status", "rem", "def", "out", " alt", "pret", "det", "fun", "cmd", "j", "Ret", "tr", "rets", "RET", "val", "reset", "deg", "try", "ctr", "t", "len", "result", "ext", "num", "nt", "desc", "alt", "gt", "rt", "rev", "code", "lt", "res", "print", "flag", "cert", "re", "mt", "ft", "hash", "elt", "err", "final", " Ret", "zero", "ter", "cont", "txt", "arr"]}}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int usb_host_handle_control(USBDevice *dev, USBPacket *p,\n\n               int request, int value, int index, int length, uint8_t *data)\n\n{\n\n    USBHostDevice *s = DO_UPCAST(USBHostDevice, dev, dev);\n\n    struct usbdevfs_urb *urb;\n\n    AsyncURB *aurb;\n\n    int ret;\n\n\n\n    /*\n\n     * Process certain standard device requests.\n\n     * These are infrequent and are processed synchronously.\n\n     */\n\n\n\n    /* Note request is (bRequestType << 8) | bRequest */\n\n    trace_usb_host_req_control(s->bus_num, s->addr, request, value, index);\n\n\n\n    switch (request) {\n\n    case DeviceOutRequest | USB_REQ_SET_ADDRESS:\n\n        return usb_host_set_address(s, value);\n\n\n\n    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:\n\n        return usb_host_set_config(s, value & 0xff);\n\n\n\n    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:\n\n        return usb_host_set_interface(s, index, value);\n\n    }\n\n\n\n    /* The rest are asynchronous */\n\n\n\n    if (length > sizeof(dev->data_buf)) {\n\n        fprintf(stderr, \"husb: ctrl buffer too small (%d > %zu)\\n\",\n\n                length, sizeof(dev->data_buf));\n\n        return USB_RET_STALL;\n\n    }\n\n\n\n    aurb = async_alloc(s);\n\n    aurb->packet = p;\n\n\n\n    /*\n\n     * Setup ctrl transfer.\n\n     *\n\n     * s->ctrl is laid out such that data buffer immediately follows\n\n     * 'req' struct which is exactly what usbdevfs expects.\n\n     */\n\n    urb = &aurb->urb;\n\n\n\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n\n    urb->endpoint = p->devep;\n\n\n\n    urb->buffer        = &dev->setup_buf;\n\n    urb->buffer_length = length + 8;\n\n\n\n    urb->usercontext = s;\n\n\n\n    trace_usb_host_urb_submit(s->bus_num, s->addr, aurb,\n\n                              urb->buffer_length, aurb->more);\n\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n\n\n\n    DPRINTF(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n\n\n\n    if (ret < 0) {\n\n        DPRINTF(\"husb: submit failed. errno %d\\n\", errno);\n\n        async_free(aurb);\n\n\n\n        switch(errno) {\n\n        case ETIMEDOUT:\n\n            return USB_RET_NAK;\n\n        case EPIPE:\n\n        default:\n\n            return USB_RET_STALL;\n\n        }\n\n    }\n\n\n\n    return USB_RET_ASYNC;\n\n}\n", "idx": 13426, "substitutes": {"dev": ["pro", "server", "def", "path", "des", "mem", "conn", "DEV", "go", "o", "ver", "out", "det", "addr", "ctx", "hw", "devices", "raw", "Dev", "proc", "vp", "Device", "v", "val", "g", "gu", "test", " device", "hid", "spec", "priv", "buf", "sys", "np", "scan", "cam", "nt", "dd", "disk", "obj", "env", "info", "dem", "api", "self", "debug", "device", "h", "unknown", "adv", "serial", "ad", "de", "conf", "sd", "app", "pad", "os", "d", "ve", "ev", "iv", "w", "home", "av", "normal"], "p": ["jp", "f", "patch", "o", "pb", "pat", "j", "par", "vp", "pm", "v", "pd", "dp", "g", "pt", "t", "pp", "ping", "np", "P", "m", "r", "press", "phy", "c", "sp", "lp", "wp", "ap", "cp", "b", "device", "h", "pc", "pers", "pre", "d", "q", "pkg", "i", "w", "tp", "pa", "pe", "pay", "ps"], "request": ["error", "type", "param", "version", "query", "position", "push", "object", "address", "cmd", "mode", "response", "mask", "call", "begin", "req", "reference", "Request", "task", "reset", "access", "frame", "service", "feature", "rank", "command", "item", "select", "condition", "attribute", "change", "event", "argument", "flag", "input", "reason", "set", "each", "seek", "direction", "order", "method", "enter", "requ", "q", "quest"], "value": ["server", "key", "type", "version", "number", "local", "position", "success", "array", "address", "size", "values", "x", "raw", "val", "v", "widget", "port", "field", "initial", "ceive", "VALUE", "Value", "flow", "message", "fee", "time", "json", "ue", "attribute", "current", "buffer", "variable", "count", "change", "function", "hello", "device", "start", "vector", "python", "set", "see", "weight", "total", "max", "wise", "ve", "state", "name", "valid", "expression"], "index": ["status", "key", "server", "error", "type", "insert", "axis", "number", "position", "success", "address", "ind", "size", "row", "x", "timeout", "val", "port", "test", "frame", "service", "Index", "command", "offset", "num", "connect", "lock", "condition", "open", "count", "event", "pos", "location", "device", "start", "vector", "id", "set", "order", "point", "seek", "ion", "interface", "i", "level"], "length": ["Length", "type", "ptr", "number", "size", "l", "address", "row", "sequence", "height", "load", "t", "stop", "len", "padding", "end", "ow", "loop", "ENGTH", "offset", "bus", "message", "ength", "time", "maximum", "html", "buffer", "count", "capacity", "all", "hello", "enth", "h", "ish", "vector", "duration", "max", "total", "shape", "format", "expected", "full", "angle"], "data": ["def", "tu", "size", "val", "text", " input", " device", " buffer", " d", "buf", "bin", "end", "bus", "buffer", "Data", "device", "input", "d", "DATA", "ata", "dat", "name"], "s": ["sis", "ses", "gs", "S", "bs", "socket", "ties", "sq", "sl", "qs", "stats", "sh", "vs", "cs", "ims", "its", "sn", "ps", "sw", "j", "n", "js", "g", "http", "simple", "spec", "space", "ds", "ats", "sa", "self", "set", "i", "an", "a", "f", "as", "store", "sb", "service", "hs", "sys", "ess", "c", "es", "changes", "fs", "bis", "d", "se", "ss", "serv", "l", "is", "sv", "ls", "r", "ts", "sp", "ns", "b", "h", "e", "sd", "os", "z", "w", "sts", "ms", "y", "rs"], "urb": ["impro", "udi", "hum", "ib", "uh", "ury", "obl", "pb", "utt", "obb", "usb", "eb", "ocr", "tur", "abuse", "aud", "amb", "erb", "ruff", "ief", "zb", "ofer", "uj", "ug", "ur", "rb", " turb", "eur", "uph", "orum", "ub", "ud", "aux", "comment", "rib", "cb", "urt", "ust", "deb", "bf", "img", "urban", "fine", "urus", "aff", "rob", "urg", "aur", "urbed", "conf", "gob", "uv", "uf", "nb", "anim", "err", "orb", "uff", "ob"], "aurb": ["aurabd", "urchb", "thurbb", "airu", "urchrb", "thurab", "aurab", "thurrb", "auraB", "aurf", "aurB", "urab", "urdbb", "urchnb", "thurbar", "ury", "thurf", "thurl", "aurbd", "urcha", "aurnb", "urchbs", "thurend", "augb", "urda", "urdB", "urB", "scarb", "aurbar", "aurl", "thurnb", "urchl", "aitB", "thurbd", "urdb", "urbb", "thurba", "urchbe", "aira", "aura", "aurbb", "aury", "auru", "thurbe", "aurba", "thury", "scarbb", "aucb", "aurend", "urchab", "urchu", "airB", "urchbar", "aitbar", "urchf", "urchy", "aurbs", "thura", "urchend", "airnb", "aitb", "augbd", "aucend", "airf", "airb", "augB", "aucl", "url", "scara", "aitrb", "augba", "auraba", "thurb", "aurbe", "aucbs", "thurbs", "urchbb", "thurB", "urchB", "airbe", "aurrb", "thuru", "scarB"], "ret": ["resp", "rem", "out", "ref", " RET", "det", "fun", "back", "Ret", "x", "tr", "reply", "rets", "RET", "val", "reset", "not", "deg", "store", "t", "ert", "len", "encrypted", "result", "nz", "job", "nt", "rest", "r", "alt", "gt", "rt", "rev", "tf", "run", "lt", "res", "flag", "cert", "re", "ft", "arg", "elt", "err", " Ret", "ter", "cont", "arr"]}}
{"project": "FFmpeg", "commit_id": "6abc56e892c2c2500d1fc2698fa6d580b72f721b", "target": 1, "func": "static int dshow_read_header(AVFormatContext *avctx)\n\n{\n\n    struct dshow_ctx *ctx = avctx->priv_data;\n\n    IGraphBuilder *graph = NULL;\n\n    ICreateDevEnum *devenum = NULL;\n\n    IMediaControl *control = NULL;\n\n    IMediaEvent *media_event = NULL;\n\n    HANDLE media_event_handle;\n\n    HANDLE proc;\n\n    int ret = AVERROR(EIO);\n\n    int r;\n\n\n\n    CoInitialize(0);\n\n\n\n    if (!ctx->list_devices && !parse_device_name(avctx)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Malformed dshow input string.\\n\");\n\n        goto error;\n\n    }\n\n\n\n    ctx->video_codec_id = avctx->video_codec_id ? avctx->video_codec_id\n\n                                                : AV_CODEC_ID_RAWVIDEO;\n\n    if (ctx->pixel_format != AV_PIX_FMT_NONE) {\n\n        if (ctx->video_codec_id != AV_CODEC_ID_RAWVIDEO) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Pixel format may only be set when \"\n\n                              \"video codec is not set or set to rawvideo\\n\");\n\n            ret = AVERROR(EINVAL);\n\n            goto error;\n\n        }\n\n    }\n\n    if (ctx->framerate) {\n\n        r = av_parse_video_rate(&ctx->requested_framerate, ctx->framerate);\n\n        if (r < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Could not parse framerate '%s'.\\n\", ctx->framerate);\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    r = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER,\n\n                         &IID_IGraphBuilder, (void **) &graph);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not create capture graph.\\n\");\n\n        goto error;\n\n    }\n\n    ctx->graph = graph;\n\n\n\n    r = CoCreateInstance(&CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,\n\n                         &IID_ICreateDevEnum, (void **) &devenum);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not enumerate system devices.\\n\");\n\n        goto error;\n\n    }\n\n\n\n    if (ctx->list_devices) {\n\n        av_log(avctx, AV_LOG_INFO, \"DirectShow video devices\\n\");\n\n        dshow_cycle_devices(avctx, devenum, VideoDevice, NULL);\n\n        av_log(avctx, AV_LOG_INFO, \"DirectShow audio devices\\n\");\n\n        dshow_cycle_devices(avctx, devenum, AudioDevice, NULL);\n\n        ret = AVERROR_EXIT;\n\n        goto error;\n\n    }\n\n    if (ctx->list_options) {\n\n        if (ctx->device_name[VideoDevice])\n\n            dshow_list_device_options(avctx, devenum, VideoDevice);\n\n        if (ctx->device_name[AudioDevice])\n\n            dshow_list_device_options(avctx, devenum, AudioDevice);\n\n        ret = AVERROR_EXIT;\n\n        goto error;\n\n    }\n\n\n\n    if (ctx->device_name[VideoDevice]) {\n\n        if ((r = dshow_open_device(avctx, devenum, VideoDevice)) < 0 ||\n\n            (r = dshow_add_device(avctx, VideoDevice)) < 0) {\n\n            ret = r;\n\n            goto error;\n\n        }\n\n    }\n\n    if (ctx->device_name[AudioDevice]) {\n\n        if ((r = dshow_open_device(avctx, devenum, AudioDevice)) < 0 ||\n\n            (r = dshow_add_device(avctx, AudioDevice)) < 0) {\n\n            ret = r;\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    ctx->mutex = CreateMutex(NULL, 0, NULL);\n\n    if (!ctx->mutex) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not create Mutex\\n\");\n\n        goto error;\n\n    }\n\n    ctx->event[1] = CreateEvent(NULL, 1, 0, NULL);\n\n    if (!ctx->event[1]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not create Event\\n\");\n\n        goto error;\n\n    }\n\n\n\n    r = IGraphBuilder_QueryInterface(graph, &IID_IMediaControl, (void **) &control);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media control.\\n\");\n\n        goto error;\n\n    }\n\n    ctx->control = control;\n\n\n\n    r = IGraphBuilder_QueryInterface(graph, &IID_IMediaEvent, (void **) &media_event);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media event.\\n\");\n\n        goto error;\n\n    }\n\n    ctx->media_event = media_event;\n\n\n\n    r = IMediaEvent_GetEventHandle(media_event, (void *) &media_event_handle);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media event handle.\\n\");\n\n        goto error;\n\n    }\n\n    proc = GetCurrentProcess();\n\n    r = DuplicateHandle(proc, media_event_handle, proc, &ctx->event[0],\n\n                        0, 0, DUPLICATE_SAME_ACCESS);\n\n    if (!r) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not duplicate media event handle.\\n\");\n\n        goto error;\n\n    }\n\n\n\n    r = IMediaControl_Run(control);\n\n    if (r == S_FALSE) {\n\n        OAFilterState pfs;\n\n        r = IMediaControl_GetState(control, 0, &pfs);\n\n    }\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not run filter\\n\");\n\n        goto error;\n\n    }\n\n\n\n    ret = 0;\n\n\n\nerror:\n\n\n\n    if (devenum)\n\n        ICreateDevEnum_Release(devenum);\n\n\n\n    if (ret < 0)\n\n        dshow_read_close(avctx);\n\n\n\n    return ret;\n\n}\n", "idx": 13429, "substitutes": {"avctx": ["avcv", "avtx", "ovdj", "evcmp", "afsettings", "navctx", "ovtmp", "avefx", "ajfx", "avedj", "avpkg", "avtmp", "avecb", "abcontext", "afpkg", "avcpu", "awcpu", "evtx", " avcontext", "abconn", "svctx", "avcfg", "awjp", " avcb", "avcmp", "svdj", "ovctx", "awctx", " avsetup", "awcontext", "afcb", "avcb", "avecontext", "aftx", " avcpu", "svcontext", "avetx", "avewcs", " avcmp", "abctx", " avcfg", "aircontext", "avecfg", "navcontext", " avconn", "svcv", "afcontext", "svcmp", "navwcs", "avdj", "aircpu", "ovtx", "ajdj", "ajpkg", "afctx", "svtx", "evctx", "evcontext", "avecv", "avjp", "airjp", "affx", "avesetup", "avconn", "avfx", "afdj", "afcfg", "aveconn", "navsetup", " avsettings", " avpkg", "svtmp", "avcontext", "airctx", "avepkg", "avsetup", "ajctx", " avtx", "avesettings", "avectx", " avwcs", "avsettings", "avwcs", "ovcfg", " avtmp", "svcfg", " avjp", "ovcontext", " avcv", "abtx"], "ctx": ["index", "td", "conn", "hw", "scope", "cmp", "check", "loc", "nt", "context", "doc", "parent", "cb", "xc", "abc", "yes", "qt", "pkg", "ka", "tx", "kw", "ctl", "unc", "wx", "setup", "lc", "addr", "cmd", "ind", "crit", "kt", "module", "timeout", "comm", "xp", "wcs", "note", "cfg", "obj", "cp", "gc", "ctrl", "Context", "ppo", "tmp", "conf", "ca", "txt", "cf", "this", "cc", "req", "tk", "buf", "np", "vals", "work", "c", "cv", "kl", "acl", "etc", "config", "px", "tm", "jac", "cu", "tc", "local", "cm", "p", "kind", "ct", "act", "desc", "prefix", "ck", "handler", "fc", "that"], "graph": ["node", "profile", "path", "browser", "conn", "go", "png", "background", "pen", "data", "map", "window", "stream", "storage", "dr", "man", "hold", "name", "widget", "g", "reg", "gen", "media", "Graph", "domain", "stack", "buf", "ograph", "cache", "msg", "via", "connect", "tree", "connection", "context", "gd", "memory", "json", "doc", "container", "driver", "org", "subject", "document", "igraph", "layout", "gr", "gc", "pg", "draw", "host", "order", "config", "shape", "growth", "network", "raph", "adj", "history"], "devenum": [" deienumer", " deiennum", "devinumb", " deienumb", "deenum", "deenumer", "deenom", "devenumer", "deienumer", "devinom", "deenenum", "deienum", "deennum", "deienumb", "deiennum", "devenenum", "Deenom", "Deenum", "Devenum", "devinenum", "deenumb", "devenumb", "Deenumb", "devenom", "Devenenum", "devinum", "Deenenum", " devenumb", " devenumer", "Devenumb", " devennum", " deienum", "Devenom", "devennum"], "control": ["ctl", "error", "record", "controlled", "success", "edit", "crit", "hold", "Control", "information", "media", "command", "connect", "driver", "script", "change", "support", "content", "contact", "rol", "ctrl", "management", "config", "format", "controller", "cont", "history", "form"], "media_event": ["media___error", "media_error", "media___event", " media_Event", " media_command", "media___Event", " media_error", "media_Event", "media_command", "media___command"], "media_event_handle": ["media_event_object", "media_error_handle", "media_error_object", "media_error_handler", "media_event_handler", "media_event_Handle", "media_error_Handle"], "proc": ["ptr", " Proc", "camera", "cur", "p", "cmp", "pointer", "cache", "sys", "loop", "program", "func", "processor", " PROC", "obj", "reader", "progress", "console", "gc", "debug", "ser", "pc", "tmp", "serial", "pid", "process", "exec", "alloc"], "r": ["resp", "status", "rc", "error", "cr", "f", "ret", "record", "rad", "lr", "rn", "attr", "l", "pr", "j", "row", "p", "n", "or", "dr", "ral", "mr", "ran", "v", "g", "ar", "rar", "rr", "t", "rate", "er", "result", "rm", "rb", "nr", "br", "m", "kr", "rect", "rt", "c", "run", "sr", "res", "rg", "h", "rin", "re", "fr", "e", "rel", "rd", "entry", "d", "err", "z", "q", "w", "R", "i", "usr", "rs", "arr"]}}
{"project": "qemu", "commit_id": "274250c30158f60aefb46088a7bb0d711061226c", "target": 1, "func": "static inline void s390_machine_initfn(Object *obj)\n\n{\n\n    object_property_add_bool(obj, \"aes-key-wrap\",\n\n                             machine_get_aes_key_wrap,\n\n                             machine_set_aes_key_wrap, NULL);\n\n    object_property_set_description(obj, \"aes-key-wrap\",\n\n            \"enable/disable AES key wrapping using the CPACF wrapping key\",\n\n\n    object_property_set_bool(obj, true, \"aes-key-wrap\", NULL);\n\n\n\n    object_property_add_bool(obj, \"dea-key-wrap\",\n\n                             machine_get_dea_key_wrap,\n\n                             machine_set_dea_key_wrap, NULL);\n\n    object_property_set_description(obj, \"dea-key-wrap\",\n\n            \"enable/disable DEA key wrapping using the CPACF wrapping key\",\n\n\n    object_property_set_bool(obj, true, \"dea-key-wrap\", NULL);\n\n    object_property_add_str(obj, \"loadparm\",\n\n            machine_get_loadparm, machine_set_loadparm, NULL);\n\n    object_property_set_description(obj, \"loadparm\",\n\n            \"Up to 8 chars in set of [A-Za-z0-9. ] (lower case chars converted\"\n\n            \" to upper case) to pass to machine loader, boot manager,\"\n\n            \" and guest kernel\",\n\n\n\n\n\n\n\n\n\n}", "idx": 13437, "substitutes": {"obj": ["resp", "inst", "def", "kw", "nw", "co", "obs", "phys", "o", "src", "eps", "object", "det", "attr", "ind", "addr", "j", "cmd", "n", "js", "hw", "ctx", "cmp", "kt", "bh", "req", "typ", "bj", "mk", "tk", "compl", "dl", "try", "xs", "xy", "Obj", "pt", "t", "obo", "comm", "bo", "sys", "np", "ext", "act", "nt", "m", "gt", "att", "org", "rt", "ck", "cb", "inv", "opp", "gr", "ht", "gc", "unk", "mg", "tmp", "fr", "ot", "it", "elt", "net", "stick", "pkg", "x", "cont", "txt", "ob"]}}
{"project": "FFmpeg", "commit_id": "d86d7b2486cd5c31db8e820d8a89554abf19567e", "target": 0, "func": "static int ljpeg_decode_rgb_scan(MJpegDecodeContext *s, int nb_components, int predictor, int point_transform)\n\n{\n\n    int i, mb_x, mb_y;\n\n    uint16_t (*buffer)[4];\n\n    int left[4], top[4], topleft[4];\n\n    const int linesize = s->linesize[0];\n\n    const int mask     = ((1 << s->bits) - 1) << point_transform;\n\n    int resync_mb_y = 0;\n\n    int resync_mb_x = 0;\n\n\n\n    if (s->nb_components != 3 && s->nb_components != 4)\n\n        return AVERROR_INVALIDDATA;\n\n    if (s->v_max != 1 || s->h_max != 1 || !s->lossless)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n\n    s->restart_count = s->restart_interval;\n\n\n\n    av_fast_malloc(&s->ljpeg_buffer, &s->ljpeg_buffer_size,\n\n                   (unsigned)s->mb_width * 4 * sizeof(s->ljpeg_buffer[0][0]));\n\n    buffer = s->ljpeg_buffer;\n\n\n\n    for (i = 0; i < 4; i++)\n\n        buffer[0][i] = 1 << (s->bits - 1);\n\n\n\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n\n        uint8_t *ptr = s->picture_ptr->data[0] + (linesize * mb_y);\n\n\n\n        if (s->interlaced && s->bottom_field)\n\n            ptr += linesize >> 1;\n\n\n\n        for (i = 0; i < 4; i++)\n\n            top[i] = left[i] = topleft[i] = buffer[0][i];\n\n\n\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n            int modified_predictor = predictor;\n\n\n\n            if (s->restart_interval && !s->restart_count){\n\n                s->restart_count = s->restart_interval;\n\n                resync_mb_x = mb_x;\n\n                resync_mb_y = mb_y;\n\n                for(i=0; i<4; i++)\n\n                    top[i] = left[i]= topleft[i]= 1 << (s->bits - 1);\n\n            }\n\n            if (mb_y == resync_mb_y || mb_y == resync_mb_y+1 && mb_x < resync_mb_x || !mb_x)\n\n                modified_predictor = 1;\n\n\n\n            for (i=0;i<nb_components;i++) {\n\n                int pred, dc;\n\n\n\n                topleft[i] = top[i];\n\n                top[i]     = buffer[mb_x][i];\n\n\n\n                PREDICT(pred, topleft[i], top[i], left[i], modified_predictor);\n\n\n\n                dc = mjpeg_decode_dc(s, s->dc_index[i]);\n\n                if(dc == 0xFFFFF)\n\n                    return -1;\n\n\n\n                left[i] = buffer[mb_x][i] =\n\n                    mask & (pred + (dc << point_transform));\n\n            }\n\n\n\n            if (s->restart_interval && !--s->restart_count) {\n\n                align_get_bits(&s->gb);\n\n                skip_bits(&s->gb, 16); /* skip RSTn */\n\n            }\n\n        }\n\n        if (s->rct && s->nb_components == 4) {\n\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[4*mb_x + 2] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2] - 0x200) >> 2);\n\n                ptr[4*mb_x + 1] = buffer[mb_x][1] + ptr[4*mb_x + 2];\n\n                ptr[4*mb_x + 3] = buffer[mb_x][2] + ptr[4*mb_x + 2];\n\n                ptr[4*mb_x + 0] = buffer[mb_x][3];\n\n            }\n\n        } else if (s->nb_components == 4) {\n\n            for(i=0; i<nb_components; i++) {\n\n                int c= s->comp_index[i];\n\n                if (s->bits <= 8) {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ptr[4*mb_x+3-c] = buffer[mb_x][i];\n\n                    }\n\n                } else if(s->bits == 9) {\n\n                    return AVERROR_PATCHWELCOME;\n\n                } else {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ((uint16_t*)ptr)[4*mb_x+c] = buffer[mb_x][i];\n\n                    }\n\n                }\n\n            }\n\n        } else if (s->rct) {\n\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[3*mb_x + 1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2] - 0x200) >> 2);\n\n                ptr[3*mb_x + 0] = buffer[mb_x][1] + ptr[3*mb_x + 1];\n\n                ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1];\n\n            }\n\n        } else if (s->pegasus_rct) {\n\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[3*mb_x + 1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2]) >> 2);\n\n                ptr[3*mb_x + 0] = buffer[mb_x][1] + ptr[3*mb_x + 1];\n\n                ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1];\n\n            }\n\n        } else {\n\n            for(i=0; i<nb_components; i++) {\n\n                int c= s->comp_index[i];\n\n                if (s->bits <= 8) {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ptr[3*mb_x+2-c] = buffer[mb_x][i];\n\n                    }\n\n                } else if(s->bits == 9) {\n\n                    return AVERROR_PATCHWELCOME;\n\n                } else {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ((uint16_t*)ptr)[3*mb_x+2-c] = buffer[mb_x][i];\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 13442, "substitutes": {"s": ["ses", "gs", "S", "settings", "bs", "ports", "series", "sq", "t", "m", "qs", "stats", "vs", "states", "cs", "tests", "ims", "aunts", "its", "ants", "ps", "sw", "j", "n", "js", "v", "g", "ar", "comm", "spec", "ds", "ats", "obj", "services", "sc", "ears", "args", "set", "rates", "conf", "ows", "parts", "scl", "ex", "results", "a", "as", "less", "bits", "eps", "als", "sb", "hs", "sys", "c", "ops", "es", "changes", "fs", "events", "bis", "d", "se", "sports", "ss", "comments", "aws", "has", "l", "p", "details", "bes", "is", "sv", "ls", "ts", "ins", "ns", "b", "h", "e", "os", "sets", "sts", "w", "ms", "y", "rs"], "nb_components": ["nb_expensions", "nb_distensions", "nb_expodes", "nb_comonents", "nb_compensions", "nb_colands", "nb_expands", "nb_comands", "nb_commances", "nb_comients", "nb_Components", "nb_Compands", "nb_commodes", "nb_commonents", "nb_colonents", "nb_compients", "nb_compodes", "nb_distodes", "nb_commensions", "nb_distances", "nb_Compensions", "nb_commands", "nb_distonents", "nb_colodes", "nb_comodes", "nb_compances", "nb_colients", "nb_exponents", "nb_compands", "nb_Compances", "nb_Compients", "nb_Compodes"], "predictor": ["predictcer", "fredictcer", "friptcor", "priptutor", "predictator", "friptutor", "priptcor", "friptor", "pveyoration", "pcorrectcor", "fredictor", "fredictator", "pveyive", "pveyator", "priptor", "pictator", "pictoration", "friptcer", "friptator", "pictutor", "fredictoration", "pictive", "pictor", "predictcor", "priptoration", "priptcer", "pcorrectcer", "pveyor", "fredictcor", "priptator", "priptive", "pictcer", "pictcor", "pcorrectutor", "fredictive", "friptive", "predictutor", "fredictutor", "predictive", "friptoration", "pcorrector", "predictoration"], "point_transform": ["point_draw", "pointer_sign", "point_sign", "mask_scale", "point2transform", "mask_transform", "mask_mask", "point2mask", "point2scale", "pointer_transform", "point_mask", "mask_draw", "point_scale", "pointer_mask", "pointer_scale", "point2draw"], "i": ["index", "cli", "t", "ami", "PI", "ai", "m", "xi", "qi", "ims", "it", "ji", "us", "li", "oi", "ind", "j", "ki", "si", "zi", "v", "g", "try", "ui", "iq", "iii", "im", "ti", "fi", "MI", "x", "ri", "ic", "ix", "ip", "ij", "II", "mi", "ii", "I", "pi", "batch", "mac", "ik", "di", " ii", "in", "ie", "sim", "info", "c", "remote", "ci", "id", "multi", "me", "init", "ico", "status", "ni", "iu", "ini", "ei", "uri", "p", "chain", "bi", "io", "is", "ia", "hi", "\u0438", "b", "e", "gi", "ity", "q", "phi", "name", "y"], "mb_x": ["mbjinx", "mb_ix", "lb_x", "mb__wx", "kb_w", "mbjxi", "mb__w", "lb_xml", "mb_inx", "sb_inx", "mb__x", "sb_xi", "mm_y", "mbJl", "mb_xy", "mbjx", "mbJx", "mb_xi", "mb_ux", "mb_l", "sb_x", "kbJy", "mb__y", "mb__l", "kbJix", "mbaxyux", "mb__ix", "mb_wx", "kb_x", "sb_ux", "mbjux", "kbJx", "mbJix", "lb_xs", "mb_xml", "mm_x", "mbaxyxi", "mm_wx", "mb__xy", "kb_y", "lb_ix", "mbJy", "mb_xs", "mb_w", "kb_ix", "mbaxyx", "kb_l", "mm_xy", "mbaxyinx", "kbJl"], "mb_y": ["MB_x", "mb_hot", "brain_ya", "MB_ye", "bound_ey", "bound_i", "MB_y", "mbYw", "mb_yl", "brain_yer", "bb_y", "mb_i", "bound_y", "mbaxymy", "bb_ey", "bound_w", "mbYy", "MB_my", "mb_ies", "cb_yo", "cb_y", "mb_ya", "brain_gy", "mb_gy", "bb_ies", "cb_yl", "mb_my", "mb_yo", "brain_y", "cb_x", "bb_hot", "mb_ey", "mbaxyy", "mb_yer", "mbYi", "mb_w", "mb_ye", "mbaxyye", "mbaxyx", "mbYey"], "buffer": ["view", "scroll", "mem", "button", "output", "position", "array", "header", "size", "data", "map", "row", "sequence", "window", "flash", "stream", "Buffer", "pixel", "v", "port", "batch", "frame", "cache", "buf", "buff", "result", "stack", "command", "cell", "line", "memory", "message", "library", "bridge", "document", "block", "count", "image", "page", "base", "byte", "table", "device", "binary", "iter", "length", "texture", "shape", "queue", "filter", "database", "screen"], "top": ["path", "below", "scroll", "at", "there", "lower", "l", "min", "tail", "stack", "st", "tips", "bottom", "offset", "cover", "front", "bot", "tops", "first", "hop", "control", "tools", "parent", "up", "limit", "lat", "center", "hot", "table", "Top", "master", "root", "trace", "list", "to", "TOP", "upper", "above", "level", "pointer"], "topleft": ["todorefts", "tothefts", "Toplect", "toplex", "tolex", "tplect", "podoreft", "poplelf", "todoreft", "Tplevel", "tolevel", "tothelf", "toplect", "toplevel", "podoreaft", "topleaft", "tochevel", "tplevel", "Topleft", "tolect", "tochex", "takenfts", "Tplex", "todorelf", "podorelf", "takenft", "takenaft", "tpleft", "tplex", "toleft", "tochect", "Toplex", "Tplect", "totheaft", "popleaft", "Toplevel", "popleft", "poplefts", "toplefts", "totheft", "toplelf", "Tpleft", "takenlf", "podorefts", "todoreaft", "tocheft"], "ptr": ["index", "mem", "alloc", "ref", "push", "pointers", "ind", "addr", "head", "map", "address", "depth", "tr", "dr", "temp", "req", "Ptr", "ctr", "loc", "buf", "offset", "br", "obj", "rep", "sp", "pend", "pos", "prime", "dest", "inters", "coord", "grow", "tmp", "dep", "each", "pad", "err", "zero", "pointer", "arr"], "restart_count": ["restarttenancecount", "restART__set", "restart_max", "restartlyCount", "restard_count", "restartlytable", "restart_set", "restard_Count", "restART_cond", "restartcountset", "restard_max", "restart_last", "restART_set", "restart__last", "restART__list", "restartlycount", "restart__list", "restart_list", "restART_last", "restartcountcount", "restarttenanceCount", "restart__set", "restART_code", "restart_table", "restart__count", "restard_table", "restarttenancecond", "restART_list", "restart_cond", "restART_Count", "restART__count", "restart_Count", "restart_code", "restART__last", "restART_count", "restartcountlist", "restarttenancecode", "restartlymax", "restartcountlast"]}}
{"project": "qemu", "commit_id": "b5e751b51f14cffada6be647aa576b79f1755d7e", "target": 1, "func": "static void qemu_spice_display_init_one(QemuConsole *con)\n\n{\n\n    SimpleSpiceDisplay *ssd = g_new0(SimpleSpiceDisplay, 1);\n\n\n\n    qemu_spice_display_init_common(ssd);\n\n\n\n    ssd->qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_display_interface(&ssd->qxl, con);\n\n    assert(ssd->worker);\n\n\n\n    qemu_spice_create_host_memslot(ssd);\n\n\n\n    ssd->dcl.ops = &display_listener_ops;\n\n    ssd->dcl.con = con;\n\n    register_displaychangelistener(&ssd->dcl);\n\n}\n", "idx": 13448, "substitutes": {"con": ["dial", "co", "conn", "go", "pen", "mon", "cur", "cn", "CON", "ain", "ln", "cc", "conv", "ran", "comm", "Con", "com", "bin", "connect", "Conn", "cl", "connection", "in", "gate", "obj", "ac", "c", "cal", "nc", "fn", "ec", "en", "bind", "ins", "cons", "un", "bc", "fac", "pc", "fc", "conf", "enc", "win", "ex", "ca", "coll", "an", "can", "ch"], "ssd": [" ssmd", "cssl", "mesds", "rsssd", "ysds", "essdd", "ssdm", "esssd", " ssfd", "ssud", "messd", "ssmd", "ssdd", "sdd", "ssfd", "cssbd", "hessd", "cssld", "cssdo", "essbd", " ssdm", "csssd", "essd", "rssmd", "essds", "isssd", "ysbd", "issld", "cssud", "mesdd", "cssdh", "rssl", "cssds", "cssd", "essdo", "ysdm", "sdsd", "essud", "ssdo", "issfd", "rssds", "ysd", "SSud", "SSd", "ssds", "hessds", "hessbd", "cssmd", "mesd", "ssl", "sdds", "SSds", "ssld", " sssd", "rssld", "issd", "SSsd", "issdh", "sddo", "cssdd", " ssds", "issds", "essl", "rssbd", " ssbd", "hessdm", "sssd", "rssdh", "rssfd", "ssbd", "rssd", "ssdh"]}}
{"project": "FFmpeg", "commit_id": "fe7547d69e6721d064c8604d0a6375a2d24b35ca", "target": 0, "func": "int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,\n\n                              int64_t wanted_timestamp, int flags)\n\n{\n\n    int a, b, m;\n\n    int64_t timestamp;\n\n\n\n    a = -1;\n\n    b = nb_entries;\n\n\n\n    // Optimize appending index entries at the end.\n\n    if (b && entries[b - 1].timestamp < wanted_timestamp)\n\n        a = b - 1;\n\n\n\n    while (b - a > 1) {\n\n        m         = (a + b) >> 1;\n\n\n\n        // Search for the next non-discarded packet.\n\n        while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) {\n\n            m++;\n\n            if (m == b && entries[m].timestamp >= wanted_timestamp) {\n\n                m = b - 1;\n\n                break;\n\n            }\n\n        }\n\n\n\n        timestamp = entries[m].timestamp;\n\n        if (timestamp >= wanted_timestamp)\n\n            b = m;\n\n        if (timestamp <= wanted_timestamp)\n\n            a = m;\n\n    }\n\n    m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b;\n\n\n\n    if (!(flags & AVSEEK_FLAG_ANY))\n\n        while (m >= 0 && m < nb_entries &&\n\n               !(entries[m].flags & AVINDEX_KEYFRAME))\n\n            m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;\n\n\n\n    if (m == nb_entries)\n\n        return -1;\n\n    return m;\n\n}\n", "idx": 13462, "substitutes": {"entries": ["entityrys", "entsried", "ENTords", "entents", "istlements", "pentries", "entlements", "entityials", "istents", "Entried", "ENTities", "Entries", "ENTensions", "Entlements", "ntities", "ntrys", "entried", "entsries", "identries", "Entrys", "entsrs", "Entords", "entsrys", "enties", "entsues", "pentires", "ENTrys", "ENTues", "istries", "identrs", "Entrs", "entords", "Entities", "pentensions", "entires", "entials", "ntries", "entrs", "identried", "entsires", "pentues", "identities", "entities", "Entials", "ntords", "ENTires", "istities", "entsities", "entrys", "Entents", "entensions", "entsies", "entsials", "entityries", "entslements", "entityensions", "Entensions", "Enties", "ENTies", "ENTries", "entues", "entsents", "entsensions"], "nb_entries": ["nb2ntits", "nb_ENTries", "nb_pentits", "nb_entsrows", "nb_sequries", "nb_pentries", "nb_nties", "nb2enties", "nb2ntities", "nb_ntrows", "nb_entrys", "nb_entits", "nb_ntities", "nb_ntues", "nb_entresses", "nb_countrys", "nb_Entries", "nb_Entresses", "nb_Entrys", "nb2entities", "nb_ntries", "nb_entlements", "nb_ntlements", "nb_pentities", "nb_entsits", "nb_sequrys", "nb_ntits", "nb_ENTlements", "nb_enties", "nb_entsries", "nb_entrows", "nb_contues", "nb2entits", "nb_contries", "nb_penties", "nb_countries", "nb_entues", "nb_sequresses", "nb_ENTits", "nb_countresses", "nb_entslements", "nb2nties", "nb_entsies", "nb_ENTrows", "nb2ntries", "nb2entries", "nb_entities", "nb_contities", "nb_entsities", "nb_conties"], "wanted_timestamp": ["wanted_tmetime", "wanted_timetime", "wanted_Timestamp", "wanted_timeeline", "wanted_tmence", "wanted_waitestamp", "wanted_waitence", "wanted_timstone", "wanted_timeence", "wanted_temestamp", "wanted_Timest", "wanted_temetime", "wanted_temest", "wanted_timeestamp", "wanted_mintstone", "wanted_temence", "wanted_Timstone", "wanted_tmtime", "wanted_timeetime", "wanted_timence", "wanted_timeline", "wanted_timeest", "wanted_timestone", "wanted_Timtime", "wanted_mintetime", "wanted_mintestamp", "wanted_waitest", "wanted_temeline", "wanted_tmest", "wanted_Timence", "wanted_mintest", "wanted_timest", "wanted_Timeline", "wanted_timtime", "wanted_Timetime", "wanted_tmestamp"], "flags": ["comments", "status", "types", "settings", "FLAG", "ums", "tags", "ports", "cond", "missions", "lines", "mask", "doms", "terms", "bits", "fd", "ags", "fields", "limits", "words", "details", "features", "frames", "wcs", "marks", "pins", "ments", "fts", "reports", "faces", "heads", "bugs", "finals", "lag", "atts", "magic", "acts", "ts", "Flags", "stats", "products", "states", "flag", "args", "rates", "fs", "locks", "posts", "levels", "parts", "options", "ants", " Flags", "fps", "weights", "rights", "planes", "packages", "properties"], "a": ["ae", "am", "be", "ba", "at", "aa", " A", "as", "au", "f", "o", "l", "j", "n", "p", "aaa", "apa", "aj", "A", "ga", "g", "ar", "access", "t", "la", "ia", "bo", "ea", "ab", "da", "sa", "r", "al", "ai", "s", "oa", " ca", "ac", " i", "va", "c", "ap", "alpha", "h", "area", "e", "ach", "ace", " at", "app", "eas", "d", " sa", "to", "ma", "ta", "i", "w", "x", "ca", "pa", "an", "na"], "b": ["bar", "be", "ba", "ib", "by", "f", "aa", "bs", "o", "l", "back", "j", "wb", "p", "n", "eb", "pb", "body", "v", "g", "bi", "batch", "t", "sb", "bo", "BA", "bt", "gb", "ab", "rb", "br", "y", "r", "s", "fb", "cb", "c", "db", "bm", "base", "bf", "bas", "bl", "bc", "e", "B", "u", "bis", "it", "d", "bb", "nb", "mb", "z", "length", "bound", "bp", "i", "beta", "bg", "w", "blue", "ob"], "m": ["km", "mr", "t", "rm", "mean", "s", "dim", "mm", "met", "M", "ma", "month", "mun", "am", "rem", "esm", "mem", "j", "n", "module", "pm", "v", "g", "md", "im", "bm", "om", "mc", "mt", "mb", "i", "span", "f", "um", "mi", "dn", "asm", "perm", "mo", "sm", "mac", "fm", "y", "mu", "c", "id", "u", "mis", "multi", "d", "me", "tm", "o", "cm", "l", "p", "hm", "managed", "lem", "dm", "mail", "wm", "arm", "ym", "msg", "em", "r", "vm", "mut", "gm", "mat", "h", "mp", "mod", "value", "nm", "ms", "mx"], "timestamp": ["latemark", "theporal", "timest", "payeness", "portporal", "latistic", "stimporal", "temeline", "timension", "timpoint", "timporal", "temestamp", "payetime", "porterence", "portesta", "stimestamp", "capemark", "portestamp", "timemark", "capage", "timuration", "tempestamp", "timistic", "tempuration", "streamension", "streamestamp", "matchage", "timeatile", "Timestamp", "timeness", "streamest", "latporal", "capestamp", "suspistic", "tempemark", "stimest", "estampestamp", "latesta", "tempesta", "Timetime", "timeistic", "temerence", "stimesta", "tempoint", "timepoint", "laterence", "suspetime", "estampemark", "timage", "timeeline", "timatile", "laturation", "timeension", "temporal", "suspestamp", "latatile", "estampage", "suspatile", "timeline", "temesta", "latetime", "thepoint", "matchestamp", "matchemark", "timerence", "timeestamp", "stimension", "timeetime", "timeest", "stimemark", "Timeness", "streamporal", "latestamp", "payestamp", "timetime", "timeeness", "theeline", "timeporal", "timesta", "stimuration", "theestamp"]}}
{"project": "FFmpeg", "commit_id": "668494acd8b20f974c7722895d4a6a14c1005f1e", "target": 1, "func": "static int codec_get_buffer(AVCodecContext *s, AVFrame *frame)\n{\n    InputStream *ist = s->opaque;\n    FrameBuffer *buf;\n    int ret, i;\n    if (!ist->buffer_pool && (ret = alloc_buffer(s, ist, &ist->buffer_pool)) < 0)\n        return ret;\n    buf              = ist->buffer_pool;\n    ist->buffer_pool = buf->next;\n    buf->next        = NULL;\n    if (buf->w != s->width || buf->h != s->height || buf->pix_fmt != s->pix_fmt) {\n        av_freep(&buf->base[0]);\n        av_free(buf);\n        ist->dr1 = 0;\n        if ((ret = alloc_buffer(s, ist, &buf)) < 0)\n            return ret;\n    }\n    buf->refcount++;\n    frame->opaque        = buf;\n    frame->type          = FF_BUFFER_TYPE_USER;\n    frame->extended_data = frame->data;\n    frame->pkt_pts       = s->pkt ? s->pkt->pts : AV_NOPTS_VALUE;\n    for (i = 0; i < FF_ARRAY_ELEMS(buf->data); i++) {\n        frame->base[i]     = buf->base[i];  // XXX h264.c uses base though it shouldn't\n        frame->data[i]     = buf->data[i];\n        frame->linesize[i] = buf->linesize[i];\n    }\n    return 0;\n}", "idx": 13468, "substitutes": {"s": ["ses", "gs", "a", "S", "f", "sw", "serv", "bs", "as", "less", "session", "same", "ctx", "p", "js", "n", "sq", "stat", "conv", "v", "g", "ms", "http", "sam", "t", "source", "comm", "is", "sv", "sb", "spec", "space", "sys", "hs", "er", "st", "ds", "sf", "ats", "ls", "m", "cl", "qs", "sc", "ts", "self", "c", "ares", "ins", "ns", "cs", "h", "es", "ims", "set", "fs", "app", "os", "its", "z", "ast", "ss", "w", "sts", "rs", "ps"], "frame": ["profile", "error", "fw", "cf", "face", "request", "f", "framework", "version", "object", "header", "data", "cmd", "response", "sequence", "window", "call", "dr", "feat", "req", "next", "picture", "frames", "fe", "close", "video", "feature", "command", "send", "line", "update", "message", "context", "rame", "zone", "part", "fb", "render", "c", "buffer", "image", "event", "base", "one", "remote", "plot", "fram", "we", "page", "comp", "flag", "der", "iframe", "reason", "fr", "draw", "Frame", "point", "scene", "trace", "e", "state", "component", "force", "package", "queue", "w", "cast", "x", "term", "process", "ce"], "ist": ["et", "expr", "ctx", "dr", "ir", "stat", "port", "loc", "st", "iss", "artist", "IST", "art", "fp", "ism", "ht", "ims", "it", "nil", "ive", "iste", "ict", "ists", "ind", "isd", "erd", "xp", "assert", "ui", "iq", "dist", "irst", "obj", "ust", "wp", "alist", "tip", "pect", "xt", "ic", "ix", "ip", "ij", "est", "elist", "osi", "ista", "ert", "ik", "ilst", "isting", "ess", "ois", "ost", "wi", "iter", "eh", "imm", "iat", "il", "exist", "p", "pt", "hist", "is", "ia", "act", "dit", "iz", "ac", "ins", "istant", "list", "pas", "ast", "inst", "rs"], "buf": ["vec", "bs", "fun", "ctx", "window", "kat", "BU", "ab", "new", "doc", "fg", "bd", "cb", "fp", "fac", "foo", "uf", "queue", "pkg", "lim", "arr", "def", "fw", "mem", "ptr", "ff", "data", "cmd", "Buffer", "conv", "next", "box", "buff", "br", "og", "obj", "env", "phy", "fb", "que", "rib", "db", "burst", "cp", "pg", "font", "tmp", "fi", "bb", "tab", "txt", "Buff", "ref", "seq", "wb", "bh", "proc", "feat", "vp", "req", "batch", "grab", "bo", "rb", "norm", "buffer", "block", "cv", "bf", "bc", "bed", "fr", "uv", "err", "cast", "ob", "alloc", "keep", "bar", "bytes", "good", "pb", "pt", "bt", "cache", "msg", "bin", "cap", "func", "cam", "desc", "xff", "bu", "img", "b", "bl", "var", "nb", "prop", "bp", "nm"], "ret": ["resp", "status", "rem", "def", "ref", "out", "success", "pret", "det", "ll", "Ret", "tr", "rets", "RET", "val", "v", "reset", "deg", "try", "virtual", "not", "fail", "t", "reg", "len", "rm", "result", "ext", "cat", "nt", "desc", "r", "nat", "alt", "gt", "att", "rt", "rev", "Return", "ry", "res", "print", "ber", "re", "mt", "rel", "repl", "it", "elt", "err", "pas", "net", " Ret", "ter", "valid", "cont", "txt"], "i": ["ij", "index", "status", "li", "f", "iu", "ii", "mi", "I", "pi", "ind", "ini", "j", "ei", "p", "ki", "x", "uri", "si", "ir", "zi", "v", "cli", "chain", "g", "bi", "io", "is", "ui", "di", "ami", "em", "k", "m", "ai", "hi", "qi", "xi", "sim", "im", "mu", "\u0438", "remote", "ci", "span", "b", "id", "ims", "ti", "ri", "u", "it", "gi", "multi", "ji", "me", "phi", "init", "y", "ic", "ix", "ip"], "refcount": ["referencecount", "Refcount", "reqcounter", "referenceCount", "reqcount", "Refcycle", "refCount", "Refcounter", "reqcycle", "reqCount", "refcycle", "referencecycle", "RefCount", "refcounter", "referencecounter"]}}
{"project": "FFmpeg", "commit_id": "b8edf91657ad9fa2f0c5175c9ca8fbe3c8b0c624", "target": 0, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *inpic)\n\n{\n\n    AVFilterContext   *ctx     = inlink->dst;\n\n    HisteqContext     *histeq  = ctx->priv;\n\n    AVFilterLink      *outlink = ctx->outputs[0];\n\n    int strength  = histeq->strength  * 1000;\n\n    int intensity = histeq->intensity * 1000;\n\n    int x, y, i, luthi, lutlo, lut, luma, oluma, m;\n\n    AVFrame *outpic;\n\n    unsigned int r, g, b, jran;\n\n    uint8_t *src, *dst;\n\n\n\n    outpic = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n\n    if (!outpic) {\n\n        av_frame_free(&inpic);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    av_frame_copy_props(outpic, inpic);\n\n\n\n    /* Seed random generator for antibanding. */\n\n    jran = LCG_SEED;\n\n\n\n    /* Calculate and store the luminance and calculate the global histogram\n\n       based on the luminance. */\n\n    memset(histeq->in_histogram, 0, sizeof(histeq->in_histogram));\n\n    src = inpic->data[0];\n\n    dst = outpic->data[0];\n\n    for (y = 0; y < inlink->h; y++) {\n\n        for (x = 0; x < inlink->w * histeq->bpp; x += histeq->bpp) {\n\n            GET_RGB_VALUES(r, g, b, src, histeq->rgba_map);\n\n            luma = (55 * r + 182 * g + 19 * b) >> 8;\n\n            dst[x + histeq->rgba_map[A]] = luma;\n\n            histeq->in_histogram[luma]++;\n\n        }\n\n        src += inpic->linesize[0];\n\n        dst += outpic->linesize[0];\n\n    }\n\n\n\n#ifdef DEBUG\n\n    for (x = 0; x < 256; x++)\n\n        av_dlog(ctx, \"in[%d]: %u\\n\", x, histeq->in_histogram[x]);\n\n#endif\n\n\n\n    /* Calculate the lookup table. */\n\n    histeq->LUT[0] = histeq->in_histogram[0];\n\n    /* Accumulate */\n\n    for (x = 1; x < 256; x++)\n\n        histeq->LUT[x] = histeq->LUT[x-1] + histeq->in_histogram[x];\n\n\n\n    /* Normalize */\n\n    for (x = 0; x < 256; x++)\n\n        histeq->LUT[x] = (histeq->LUT[x] * intensity) / (inlink->h * inlink->w);\n\n\n\n    /* Adjust the LUT based on the selected strength. This is an alpha\n\n       mix of the calculated LUT and a linear LUT with gain 1. */\n\n    for (x = 0; x < 256; x++)\n\n        histeq->LUT[x] = (strength * histeq->LUT[x]) / 255 +\n\n                         ((255 - strength) * x)      / 255;\n\n\n\n    /* Output the equalized frame. */\n\n    memset(histeq->out_histogram, 0, sizeof(histeq->out_histogram));\n\n\n\n    src = inpic->data[0];\n\n    dst = outpic->data[0];\n\n    for (y = 0; y < inlink->h; y++) {\n\n        for (x = 0; x < inlink->w * histeq->bpp; x += histeq->bpp) {\n\n            luma = dst[x + histeq->rgba_map[A]];\n\n            if (luma == 0) {\n\n                for (i = 0; i < histeq->bpp; ++i)\n\n                    dst[x + i] = 0;\n\n                histeq->out_histogram[0]++;\n\n            } else {\n\n                lut = histeq->LUT[luma];\n\n                if (histeq->antibanding != HISTEQ_ANTIBANDING_NONE) {\n\n                    if (luma > 0) {\n\n                        lutlo = histeq->antibanding == HISTEQ_ANTIBANDING_WEAK ?\n\n                                (histeq->LUT[luma] + histeq->LUT[luma - 1]) / 2 :\n\n                                 histeq->LUT[luma - 1];\n\n                    } else\n\n                        lutlo = lut;\n\n\n\n                    if (luma < 255) {\n\n                        luthi = (histeq->antibanding == HISTEQ_ANTIBANDING_WEAK) ?\n\n                            (histeq->LUT[luma] + histeq->LUT[luma + 1]) / 2 :\n\n                             histeq->LUT[luma + 1];\n\n                    } else\n\n                        luthi = lut;\n\n\n\n                    if (lutlo != luthi) {\n\n                        jran = LCG(jran);\n\n                        lut = lutlo + ((luthi - lutlo + 1) * jran) / LCG_M;\n\n                    }\n\n                }\n\n\n\n                GET_RGB_VALUES(r, g, b, src, histeq->rgba_map);\n\n                if (((m = FFMAX3(r, g, b)) * lut) / luma > 255) {\n\n                    r = (r * 255) / m;\n\n                    g = (g * 255) / m;\n\n                    b = (b * 255) / m;\n\n                } else {\n\n                    r = (r * lut) / luma;\n\n                    g = (g * lut) / luma;\n\n                    b = (b * lut) / luma;\n\n                }\n\n                dst[x + histeq->rgba_map[R]] = r;\n\n                dst[x + histeq->rgba_map[G]] = g;\n\n                dst[x + histeq->rgba_map[B]] = b;\n\n                oluma = (55 * r + 182 * g + 19 * b) >> 8;\n\n                histeq->out_histogram[oluma]++;\n\n            }\n\n        }\n\n        src += inpic->linesize[0];\n\n        dst += outpic->linesize[0];\n\n    }\n\n#ifdef DEBUG\n\n    for (x = 0; x < 256; x++)\n\n        av_dlog(ctx, \"out[%d]: %u\\n\", x, histeq->out_histogram[x]);\n\n#endif\n\n\n\n    av_frame_free(&inpic);\n\n    return ff_filter_frame(outlink, outpic);\n\n}\n", "idx": 13488, "substitutes": {"inlink": ["inlinked", "cinloop", "Inthread", "InLink", "inthread", " outconnection", "airlink", "innconn", "cinconn", "cinlinked", "innlink", " instream", " inconnection", "onlock", "onconnection", "inlock", "cinLink", "airblock", "cinblock", "inblock", "innLink", "Inlink", " inlock", " inloop", "INLink", "outthread", " inconn", "inconn", "INlink", " outstream", "onlink", "instream", "outLink", "inloop", "inLink", "innloop", " outlock", "INlinked", "INblock", "cinlink", "airlinked", "onstream", "airLink", "innthread", "inconnection", " inLink"], "inpic": [" inpipe", "dinpicture", " inpc", "Inpin", "injp", "inscript", "dinpict", "insp", " inpicture", "inpin", "isinpic", " inscript", "isinpicture", "outpipe", "isinpy", "inpipe", "Insp", "outscript", "oldpic", "cinnic", "inpict", "innscript", "cinpic", "innpipe", " insp", "oldpin", "dinpic", "inpc", "interpin", "ainnic", "interpicture", "inpy", "Injp", "innpic", "isinpict", "oldpicture", " innic", "ainpic", " inpin", "Inpicture", "interjp", "dinpy", "Inpic", "ainpc", "interpic", "innic", " inpy", "cinpc", "oldsp", " inpict", "inpicture", " injp"], "ctx": ["tx", "jp", "kw", "ctl", "cu", "fw", "cf", "co", "conn", "tc", "cm", "ca", "setup", "lc", "cmd", "hw", "cmp", "timeout", "kt", "cc", "conv", "loc", "sys", "np", "ct", "act", "cfg", "context", "kb", "obj", "ck", "cb", "cv", "xc", "fp", "nc", "mom", "tz", "cp", "ctrl", "mc", "gc", "tmp", "conf", "config", "pkg", "sc", "ic", "txt", "history", "iat", "jac"], "histeq": ["histrt", "hoequal", "horox", "hoeer", "plotqq", "highequ", "statqq", " histqt", " histqq", "histue", "histfy", "humreq", "Histe", " histequ", "histec", " historyeq", "Histreq", "highequal", " histime", " histeps", "histq", "statqt", "historyime", "higheq", "alerteq", "recenteq", "histqt", "histime", " histrt", "resteq", "monitoreq", "histreq", "monitoreer", "stateps", "hashequality", "plotequ", "hasheq", "histrox", " historyec", "histequality", "restequ", "humearch", " histe", "stateq", "histqq", " historyfy", "distearch", "historyue", "hashqt", "historyeq", "Histequ", "alertearch", " histreq", "Histq", "humqt", " histearch", "monitorrox", "altheq", "althec", "phyequal", "histequal", "recentrt", "althfy", "hesseq", " histq", "highe", "humequ", "historyq", "historyequality", " historyeps", "higheer", "plotqt", "alertq", "distequ", "statearch", "statreq", "historyequ", "restq", "humeer", "hashreq", "distreq", "historyfy", "histeer", "historyreq", "alertreq", "state", "hessequality", "disteq", "phyreq", "monitorequal", "Histequal", "phyrox", "historyrt", "hashq", " histue", "histearch", "humeq", "statrt", "historyequal", "historyec", "phyequ", "statq", "historyeer", "altheps", "distq", "recentequ", "historyqq", "Histue", "statime", "statequ", "hume", "hoeq", "histeps", "phyeq", "histequ", "recenteps", "highreq", "hashqq", "Histeq", "hessq", "hessreq", "phyq", "historyeps", "phyeer", "histe", "historyearch", "hashequ", "ploteq", "historye", "restreq"], "outlink": ["outink", "outli", "outdisk", "connink", " outink", "olock", "itparent", "Outlink", "onLink", "conLink", "Outink", "atlink", "outputLink", "odisk", "onport", "outputlink", "itdisk", "atdisk", "Outport", " outnode", "conink", "oli", "outnode", "connode", "connlink", "outparent", "olink", "atlock", "outputdisk", "oparent", "oLink", "onlink", "outLink", "OutLink", "outlock", "onink", "connLink", "conlink", " outLink", "itlink", " outli", "outputli", " outport", "connnode", "atparent", " outdisk", "itlock", "outport"], "x": ["index", "dr", "xd", "check", "t", "ux", "xi", "add", "xc", "tx", "xes", "inx", "axis", "wx", "ax", "yx", "j", "n", "X", "v", "xp", "upload", "xe", "any", "ex", "xt", "full", "ix", "key", "a", "at", "f", "xxx", "xs", "batch", "ox", "fx", "step", "c", "lex", "xx", "px", "xf", "wy", "xa", "ey", "xxxx", "o", "l", "p", "xy", "el", "ext", "act", "k", "ct", "time", "dx", "on", "h", "e", "max", "z", "rx", "w", " xx", "mx"], "y": ["yy", "ty", "by", "yt", "at", "py", "o", "dy", "ny", "l", "j", "p", "n", "sy", "axy", "Y", "v", "xy", "kit", "yr", "t", "ay", "ya", "cy", "vy", "iy", "ies", "ady", "c", "ry", "h", "e", "my", "sky", "wy", "z", "gy", "ey", "w", "ch"], "i": ["ij", "li", "f", "iu", "ii", "mi", "I", "pi", "l", "j", "p", "si", "v", "ai", "in", "xi", "iy", "c", "ci", "u", "it", "phi", "ic", "ix"], "luthi": ["lutia", "lushy", "luty", "lutl", " lushy", "lohy", "lohl", " lushl", " luti", "lushi", "luti", " lushi", " lutia", " lutl", "luthia", "lohi", " lushia", "luthl", "lohia", " luty", "lushl", "lushia", "luthy"], "lutlo": ["LUTla", "lUTlo", "lustlo", "lUTla", "lusthi", "Luthi", "LUTli", "lUThi", "ludhi", "lustla", "Lutli", "lUTli", "lutla", "LUTlo", "lutli", "ludla", "Lutla", "ludli", "Lutlo", "LUThi", "ludlo", "lustli"], "lut": ["luti", "flut", "sluta", "fluta", "lUT", "slut", " lUT", "sluti", "luta", " luta", " luti", "fluti", "flUT", "slUT"], "luma": ["llora", "Lamia", " lama", "slama", "Lama", "eluna", "lama", "Luma", "tlama", "llpha", "luda", "lamia", "Luna", " lora", "eluda", "tluna", "oluna", "liuma", "liuna", "ylama", "olpha", " luda", "yluma", "Lua", "lpha", "lum", "lua", "lluna", "Lum", "eluma", "sluma", "sluda", " lpha", "olora", "tluma", "lium", " lum", "yluna", "sluna", " luna", " lamia", "lluma", "elama", "luna", "lora", "liamia", "ylua", "tlua"], "oluma": ["lluna", "lluma", "oluna", "flum", "llumin", "lumin", "luna", "fluma", "llum", "olum", "flumin", "lum", "fluna", "olumin"], "m": ["mem", "f", "o", "cm", "mi", "l", "n", "p", "perm", "v", "dm", "wm", "t", "sm", "rm", "mean", "dim", "mu", "bm", "mm", "c", "gm", "h", "M", "d", "tm", "w", "mx"], "outpic": ["sysscript", "ojp", "outerpic", "injp", "insp", " outPic", "Outnic", "devscript", "opicture", "outerscript", "OutPic", " outnic", "otpic", "devpict", "outjp", " outsp", "rawpic", "outpicture", "rawsp", "orpic", "devpc", "outpict", "outerpict", "outscript", "devpic", "Outpic", " outscript", "outpc", " outp", " outpc", " outpict", "itscript", "OUTnic", "op", "sysnic", "otnic", "outPic", "OUTpic", "outerpc", "itpin", "ornic", "outsp", "opic", " outjp", "outpin", "orlink", " outpicture", "itnic", "rawnic", "outnic", "orscript", "OUTlink", "outp", "rawPic", "Outsp", "otPic", "inp", "innic", "OUTscript", "otsp", "syspic", "syspin", "OUTpin", "inpicture", "inPic", "itpic"], "r": ["rc", "a", "cr", "f", "lr", "usr", "l", "j", "p", "mr", "dr", "vr", "v", "ar", "rr", "t", "er", "rb", "k", "rt", "c", "ro", "rh", "sr", "rg", "red", "h", "re", "rin", "e", "u", "rd", "d", "q", "rx", "w", "R", "ri"], "g": ["G", "f", "gg", "l", "j", "p", "n", "ga", "v", "gu", "ig", "gb", "k", "gd", "fg", "gn", "c", "gr", "gc", "rg", "gp", "gm", "h", "mg", "e", "u", "gi", " G", "q", "gy", "bg", "gam", "w"], "b": ["be", "ba", "a", "ib", "f", "o", "bs", "l", "n", "p", "eb", "v", "bi", "t", "sb", "rb", "fb", "c", "db", "bf", "bc", "h", "e", "B", "u", "bis", "d", "bb", "z", "bg", "beta", "w", "ch"], "jran": ["jsan", " jsan", "Jlan", "nsan", "jroman", "Jbin", " jbin", "jlan", "vlan", " jroman", "vgran", "jgran", "vbin", "vran", "ngran", "djran", "jbin", "djgran", " jgran", "nroman", "nran", "Jran", " jlan", "Jgran", "djsan", "djroman"], "src": ["rc", "ptr", "gin", "bs", "lr", "addr", "str", "rl", "sq", "sl", "load", "syn", "source", "loc", "sb", "st", "origin", "sys", "ug", "bin", "rb", "np", "ur", "lit", "s", "url", "rs", "rt", "cb", "fp", "dest", "sr", "img", "fn", "ins", "scale", "ser", "rob", "tmp", "rel", "hl", "rx", "sn", "iv", "inst", "sc", "usr", "ss", "txt", "sub", "copy"], "dst": ["dnt", "adest", "Dst", "sddest", "Dcr", "dbr", "jsrc", "DST", "lsts", "ddest", "dput", "jest", "nbr", "Dput", "nst", "ncr", " dsrc", "dsst", "Ddest", "mddest", "lst", "addest", " dnt", "mdest", " ddest", "ldest", "jnt", "jst", "adput", "Dsrc", "Dest", "Dsts", "Dbr", "dest", "dsp", " dest", "Dsp", "sdsts", "dsts", " dput", "dcr", "dscr", "sdst", "dssp", "sdest", "dsbr", "dST", "lest", "nsp", "adst", "Dnt", "dsrc", "mdst", "mdST", " dST"], "in_histogram": ["in_Histogram", "in_historyograms", "in_hashogram", "in_histum", "in_histomial", "in_logograms", "in_historyhistory", "in_memob", "in_histhistory", "in_Histome", "in_hashory", "in_Histhistory", "in_historyome", "in_topograms", "in_histhist", "in_logomial", "in_memory", "in_historyology", "in_logory", "in_histob", "in_topome", "in_histicle", "in_statogram", "in_historyory", "in_statob", "in_topory", "in_historyhist", "in_memoryogram", "in_topob", "in_statory", "in_logogram", "in_hashob", "in_topogram", "in_historyicle", "in_memology", "in_memicle", "in_topometry", "in_hashum", "in_chronhist", "in_memogram", "in_histometry", "in_histology", "in_histome", "in_historyogram", "in_chronogram", "in_historyob", "in_memome", "in_historyum", "in_memhist", "in_memometry", "in_histograms", "in_memoryograms", "in_historyomial", "in_history", "in_chronory", "in_topicle", "in_History", "in_memoryory", "in_chronology", "in_statum", "in_memoryomial", "in_historyometry", "in_memhistory", "in_memograms"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_int32(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_S32);\n\n}\n", "idx": 13494, "substitutes": {"data": ["bytes", "error", "mem", "array", "session", "size", "map", "values", "window", "text", "next", "batch", "done", "store", "initial", "read", "bin", "bus", "da", "context", "accept", "json", "reader", "mu", "buffer", "image", "Data", "device", "table", "input", "ad", "iter", "state", "list", "d", "DATA", "ata", "dat", "valid"], "unused": ["unus", "unchecked", "uncchecked", "sunchecked", "unusable", "nsupported", "uncuse", "ungused", " unchecked", "ungus", "nuse", "nus", " unsupported", " unus", "unsupported", "sunusable", "uncused", "sunuse", "ungsupported", "uncusable", " unusable", "unuse", " unuse", "sunused", "nused", "unguse"]}}
{"project": "qemu", "commit_id": "353ab969730742b7392414d62f4ba9632e8cf22c", "target": 0, "func": "static void nbd_trip(void *opaque)\n\n{\n\n    NBDClient *client = opaque;\n\n    NBDExport *exp = client->exp;\n\n    NBDRequest *req;\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n    uint32_t command;\n\n\n\n    TRACE(\"Reading request.\");\n\n    if (client->closing) {\n\n        return;\n\n    }\n\n\n\n    req = nbd_request_get(client);\n\n    ret = nbd_co_receive_request(req, &request);\n\n    if (ret == -EAGAIN) {\n\n        goto done;\n\n    }\n\n    if (ret == -EIO) {\n\n        goto out;\n\n    }\n\n\n\n    reply.handle = request.handle;\n\n    reply.error = 0;\n\n\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n        goto error_reply;\n\n    }\n\n    command = request.type & NBD_CMD_MASK_COMMAND;\n\n    if (command != NBD_CMD_DISC && (request.from + request.len) > exp->size) {\n\n            LOG(\"From: %\" PRIu64 \", Len: %u, Size: %\" PRIu64\n\n            \", Offset: %\" PRIu64 \"\\n\",\n\n                    request.from, request.len,\n\n                    (uint64_t)exp->size, (uint64_t)exp->dev_offset);\n\n        LOG(\"requested operation past EOF--bad client?\");\n\n        goto invalid_request;\n\n    }\n\n\n\n    if (client->closing) {\n\n        /*\n\n         * The client may be closed when we are blocked in\n\n         * nbd_co_receive_request()\n\n         */\n\n        goto done;\n\n    }\n\n\n\n    switch (command) {\n\n    case NBD_CMD_READ:\n\n        TRACE(\"Request type is READ\");\n\n\n\n        if (request.type & NBD_CMD_FLAG_FUA) {\n\n            ret = blk_co_flush(exp->blk);\n\n            if (ret < 0) {\n\n                LOG(\"flush failed\");\n\n                reply.error = -ret;\n\n                goto error_reply;\n\n            }\n\n        }\n\n\n\n        ret = blk_pread(exp->blk, request.from + exp->dev_offset,\n\n                        req->data, request.len);\n\n        if (ret < 0) {\n\n            LOG(\"reading from file failed\");\n\n            reply.error = -ret;\n\n            goto error_reply;\n\n        }\n\n\n\n        TRACE(\"Read %u byte(s)\", request.len);\n\n        if (nbd_co_send_reply(req, &reply, request.len) < 0)\n\n            goto out;\n\n        break;\n\n    case NBD_CMD_WRITE:\n\n        TRACE(\"Request type is WRITE\");\n\n\n\n        if (exp->nbdflags & NBD_FLAG_READ_ONLY) {\n\n            TRACE(\"Server is read-only, return error\");\n\n            reply.error = EROFS;\n\n            goto error_reply;\n\n        }\n\n\n\n        TRACE(\"Writing to device\");\n\n\n\n        ret = blk_pwrite(exp->blk, request.from + exp->dev_offset,\n\n                         req->data, request.len, 0);\n\n        if (ret < 0) {\n\n            LOG(\"writing to file failed\");\n\n            reply.error = -ret;\n\n            goto error_reply;\n\n        }\n\n\n\n        if (request.type & NBD_CMD_FLAG_FUA) {\n\n            ret = blk_co_flush(exp->blk);\n\n            if (ret < 0) {\n\n                LOG(\"flush failed\");\n\n                reply.error = -ret;\n\n                goto error_reply;\n\n            }\n\n        }\n\n\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    case NBD_CMD_DISC:\n\n        TRACE(\"Request type is DISCONNECT\");\n\n        errno = 0;\n\n        goto out;\n\n    case NBD_CMD_FLUSH:\n\n        TRACE(\"Request type is FLUSH\");\n\n\n\n        ret = blk_co_flush(exp->blk);\n\n        if (ret < 0) {\n\n            LOG(\"flush failed\");\n\n            reply.error = -ret;\n\n        }\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    case NBD_CMD_TRIM:\n\n        TRACE(\"Request type is TRIM\");\n\n        ret = blk_co_discard(exp->blk, (request.from + exp->dev_offset)\n\n                                       / BDRV_SECTOR_SIZE,\n\n                             request.len / BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            LOG(\"discard failed\");\n\n            reply.error = -ret;\n\n        }\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    default:\n\n        LOG(\"invalid request type (%u) received\", request.type);\n\n    invalid_request:\n\n        reply.error = EINVAL;\n\n    error_reply:\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    }\n\n\n\n    TRACE(\"Request/Reply complete\");\n\n\n\ndone:\n\n    nbd_request_put(req);\n\n    return;\n\n\n\nout:\n\n    nbd_request_put(req);\n\n    client_close(client);\n\n}\n", "idx": 13504, "substitutes": {"opaque": ["ipener", "xaques", "ipaques", "boque", "obque", "booch", "opener", "opacity", "ipatile", "operatile", "opsaque", "boacity", "opsoch", "operaque", "oboch", "xaque", "obacity", "opaques", "operener", "opoch", "obaque", "xener", "xatile", "ipaque", "opsacity", "opatile", "opsque", "opque", "boaque", "operaques"], "client": ["resp", "server", "wrapper", "co", "peer", "conn", "manager", "application", "local", "out", "query", "google", "hunt", "cur", "cmd", "ctx", "p", "window", "owner", "this", "module", "cli", "pool", "http", "store", "close", "util", "cache", "connect", "cl", "connection", "cell", "context", "channel", "obj", "parent", "current", "api", "bolt", "handler", "prefix", "buffer", "c", "Client", "remote", "self", "event", "null", "contact", "con", "app", "config", "to", "net", "x", "ip"], "req": ["tx", "resp", "needed", "def", "pro", "jp", "mem", "query", "rw", "cur", "attr", "ind", "cmd", "ctx", "expr", "crit", "sq", "proc", "Request", "reset", "comm", "grab", "msg", "rb", "job", "nt", "desc", "r", "aux", "ck", "dq", "txt", "inv", "require", "res", "rec", "fr", "Requ", "urg", "var", "requ", "qt", "err", " requ", "q", "need", "rx", "pkg", "ire", "quest", "rr", "qq", "form"], "request": ["shift", "query", "push", "task", "load", "result", "new", "select", "have", "first", "word", "match", "attribute", "document", "art", "change", "import", "vector", "requ", "transfer", "error", "type", "param", "address", "cmd", "resource", "Request", "reset", "next", "test", "http", "initial", "forward", "self", " event", "hello", "upload", "report", "input", "pair", "seek", "each", "usage", "complete", "resp", "est", "record", "call", "reference", "claim", "update", "work", "buffer", "phrase", "transform", " argument", "config", "package", "quest", "process", "instance", "position", "response", "p", "begin", "frame", "item", " requested", "connection", "message", "accept", "QUEST", "subject", "range", "decl", "event", "create", "post", "order", "point", " query", "q", "xml", "worker"], "reply": ["resp", "notice", "error", "proxy", "sett", "respond", "route", "query", "out", "output", "translation", "back", "response", "sequence", "relation", "module", "role", "ror", "next", "try", "details", "ply", "frame", "result", "write", "policy", "sys", "connection", " Reply", "r", "part", "message", "shell", "replace", "comment", "prefix", "info", "match", "Response", "remote", "Reply", "link", "answer", "respons", "print", "related", "report", "reason", "fr", "bill", "repl", "entry", "trace", "fire", "transfer", "force", "echo", "rr", "onse"], "ret": ["pret", "fun", "back", "tt", "dr", "compl", "val", "vet", "t", "len", "result", "nt", "att", "match", "rev", "sr", "net", " Ret", "usr", "cont", "tech", "arr", "rem", "def", "mem", "ptr", "ll", "cmd", "tr", "kt", "after", "RET", "tail", "reset", "dt", "let", "try", "prot", "cat", "get", "RT", "res", "print", "mt", "arg", "elt", "ter", "resp", "at", "out", "ref", "inter", "git", "pat", "Ret", "rets", "ert", "sec", "sys", "gt", "eth", "progress", "ry", "iter", "ft", "str", "status", "jp", "success", " RET", "det", "tif", "deg", "pt", "done", "ext", "desc", "alt", "rt", "ts", "rier", "lt", "cert", "mat", "re", "format", "sat"], "command": ["key", "error", "directory", "type", "version", "button", "position", "cmd", "mode", "response", "sequence", "relation", "class", "module", "rule", "pattern", "height", "md", "frame", "mac", "domain", "service", "three", "rank", "policy", "kind", "connection", "power", "operation", "message", "description", "dom", "comment", "magic", "attribute", "handler", "document", "event", "argument", "password", "function", "code", "content", "execute", "flag", "action", "communication", "direction", "confirmed", "length", "method", "Command", "style", "value", "language", "category", "priority"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_register_reset(QEMUResetHandler *func, void *opaque)\n\n{\n\n    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));\n\n\n\n    re->func = func;\n\n    re->opaque = opaque;\n\n    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);\n\n}\n", "idx": 13513, "substitutes": {"func": ["kw", "wrapper", "impl", "cf", "unc", "f", "go", "conn", "apply", "attr", "fun", "addr", "callback", "ctx", "cc", "proc", "conv", "closure", "util", "sec", "buf", "bin", "sys", "none", "obj", "aux", "ac", "handler", "cb", "nc", "function", "fn", "comp", "res", "b", "fac", "PF", "fc", "con", "pkg", "package", "lambda", "alloc"], "opaque": ["operque", "bitque", "obque", "Opent", "opacity", " opity", "pque", " opacity", " opque", "ipatile", "pity", "Opaque", "bitacity", "bitaque", "operaque", "obacity", "Opatile", "pent", "obaque", "obity", "opity", "Opque", "pacity", "ipaque", "ipacity", "opatile", "operent", "patile", "paque", "bitent", "ipque", "opque", "ipent", "operacity", "opent"], "re": ["resp", "rem", "ere", "co", "request", "au", "ret", "ref", "bre", "Re", "cre", "ren", "p", "reset", "reg", "ar", "ent", "le", "ge", "ru", "rate", "real", "sys", "op", "m", "rest", "r", "gre", "he", "rep", "ue", "RE", "parse", "ro", "are", "we", "rer", "ry", "res", "red", "rec", "fr", "e", "spe", "rel", "pre", "con", "it", "ne", "reat", "pas", "ary", "se", "ire", "rs"]}}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "void stl_phys_notdirty(hwaddr addr, uint32_t val)\n\n{\n\n    uint8_t *ptr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!memory_region_is_ram(section->mr) || section->readonly) {\n\n        addr = memory_region_section_addr(section, addr);\n\n        if (memory_region_is_ram(section->mr)) {\n\n            section = &phys_sections[phys_section_rom];\n\n        }\n\n        io_mem_write(section->mr, addr, val, 4);\n\n    } else {\n\n        unsigned long addr1 = (memory_region_get_ram_addr(section->mr)\n\n                               & TARGET_PAGE_MASK)\n\n            + memory_region_section_addr(section, addr);\n\n        ptr = qemu_get_ram_ptr(addr1);\n\n        stl_p(ptr, val);\n\n\n\n        if (unlikely(in_migration)) {\n\n            if (!cpu_physical_memory_is_dirty(addr1)) {\n\n                /* invalidate code */\n\n                tb_invalidate_phys_page_range(addr1, addr1 + 4, 0);\n\n                /* set dirty bit */\n\n                cpu_physical_memory_set_dirty_flags(\n\n                    addr1, (0xff & ~CODE_DIRTY_FLAG));\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 13517, "substitutes": {"addr": ["tx", "index", "ress", "nl", "a", "at", "mem", "arp", "ref", "src", "lr", "inter", "handle", "asm", "address", "attr", "l", "map", "p", "hw", "tr", "dr", "ord", "ind", "adj", "adr", "loc", "np", "offset", "align", "r", "eth", "url", "obj", "hop", "sha", "off", "add", "rt", "work", "ac", "pos", "ap", "id", "ad", "mt", "ace", "rel", "pad", "hash", "ash", " address", "dh", "err", "gz", "i", "x", "rn", "arr", "rs", "ix", "alloc", "Address", "ip"], "val": ["vol", "tx", "key", "index", " arg", "resp", " value", "Val", "vec", "mem", "ret", "ref", "data", "pr", "p", "pol", "stat", "v", " update", "test", "xy", "pt", "sol", "als", "eval", "buf", " data", " valid", "al", "Value", "lit", "fee", "slot", "vals", " eval", "cal", "sel", " v", "res", "ival", "VAL", "it", "px", "value", "vt", "x", "valid"], "ptr": ["index", "td", "alloc", "ref", "pointers", "inter", "handle", "address", "attr", "pr", "ind", "p", "tr", "dr", "fd", "grad", "ctx", "Ptr", "pt", "adr", "loc", "buf", "np", "offset", "r", "eth", "add", "buffer", "sp", "fp", "pos", "inters", "pc", "pair", "seek", "point", "pad", "dh", "ps", "tp", "pointer", "arr", "ip"], "section": ["index", "member", "sect", "header", "man", "port", "result", "command", "sector", "line", "context", "channel", "parent", "function", "year", "character", "side", "param", "address", "j", "group", "resource", "test", "job", "cell", "part", "definition", "comment", "library", "link", "flag", "table", "division", "area", "pair", "set", "element", "usage", "Section", "tab", "key", "record", "version", "row", "access", "service", "sec", "description", "step", "slot", "reader", "block", "variable", "journal", "state", "option", "se", "second", "status", "region", "local", "position", "session", "size", "mode", "name", "sections", "feature", "item", "connection", "tag", "prefix", "setting", "page", "ment", "portion", "action", "master", "entry", "mod", "format", "network"]}}
{"project": "FFmpeg", "commit_id": "6f1ec38ce2193d3d4cacd87edb452c6d7ba751ec", "target": 0, "func": "static void compute_antialias_float(MPADecodeContext *s,\n\n                              GranuleDef *g)\n\n{\n\n    float *ptr;\n\n    int n, i;\n\n\n\n    /* we antialias only \"long\" bands */\n\n    if (g->block_type == 2) {\n\n        if (!g->switch_point)\n\n            return;\n\n        /* XXX: check this for 8000Hz case */\n\n        n = 1;\n\n    } else {\n\n        n = SBLIMIT - 1;\n\n    }\n\n\n\n    ptr = g->sb_hybrid + 18;\n\n    for(i = n;i > 0;i--) {\n\n        float tmp0, tmp1;\n\n        float *csa = &csa_table_float[0][0];\n\n#define FLOAT_AA(j)\\\n\n        tmp0= ptr[-1-j];\\\n\n        tmp1= ptr[   j];\\\n\n        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\\\n\n        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];\n\n\n\n        FLOAT_AA(0)\n\n        FLOAT_AA(1)\n\n        FLOAT_AA(2)\n\n        FLOAT_AA(3)\n\n        FLOAT_AA(4)\n\n        FLOAT_AA(5)\n\n        FLOAT_AA(6)\n\n        FLOAT_AA(7)\n\n\n\n        ptr += 18;\n\n    }\n\n}\n", "idx": 13524, "substitutes": {"s": ["gs", "a", "S", "p", "js", "x", "si", "sq", "t", "sv", "ds", "ats", "m", "c", "ns", "cs", "h", "es", "e", "sg", "d", "ss", "w", "ms", "rs"], "g": ["gs", "G", "tg", "f", "go", "l", "j", "p", "group", "v", "gu", "ge", "t", "gen", "msg", "m", "cfg", "r", "og", "gt", "gd", "game", "fg", "gn", "c", "gc", "b", "gp", "gm", "pg", "mg", "greg", "eg", "sg", "gi", "d", "z", "q", "bg"], "ptr": ["jp", "index", "ij", "shift", "src", "pointers", "ref", "push", "lr", "ind", "pr", "addr", "address", "row", "p", "tr", "dr", "depth", "v", "Ptr", "pt", "adr", "ctr", "t", "len", "np", "offset", "br", "m", "r", "rect", "obj", "ts", "buffer", "sp", "c", "fp", "pos", "prime", "inters", "h", "grow", "pc", "fr", "iter", "pad", "length", "pi", "iv", "nm", "tp", "rn", "pointer", "arr", "ps"], "n": ["index", "nv", "nl", "ni", "nw", "number", "cn", "size", "l", "j", "pi", "p", "ln", "v", "t", "na", "len", "np", "num", "nr", "nt", "m", "N", "Ni", "c", "en", "nc", "no", "ns", "un", " ni", "it", "d", "nb", "ne", "sn", "nm", "x", "nan", "mn", "nu", "nn"], "i": ["ij", "index", "li", "ni", "at", "iu", "ii", "mi", "I", "pi", "ind", "l", "j", "p", "x", "si", "zi", "v", "bi", "ui", "di", "k", "m", "ai", "qi", "sim", "im", "\u0438", "c", "ci", "id", "ti", "iter", "it", "multi", "gi", "phi", "y", "ic", "ix", "ip"], "tmp0": ["temp00", "txt00", "cache1", "tempzero", "pkg00", "txt0", "cacheZero", "pkg1", "temp0", "cmpZero", "tempEl", "img0", "braceZero", "tmp00", "cmp0", "pkg0", "cache0", "cmp1", "imgEl", "img00", "pkgZero", " tmpZero", " tmp00", "imgzero", "tmpZero", "brace1", "tmpEl", "brace0", "tmpzero", "cmp00", "txtEl", "txtzero"], "tmp1": ["attr1", "cmpone", "tempOne", "cmpOne", " tmp2", "buff001", "empone", "buff01", " tmpOne", "emp01", "emp1", "attrOne", "temp01", "attrone", "tmpone", " tmp01", "cmp1", "attr01", "cmp01", "tmpOne", "tmp001", "tmp2", "tmp01", "temp1", "temp001", "buff1", "emp001", "buffone", "temp2", "cmp2", " tmpone", "tempone"], "csa": [" cso", "cso", "ciesa", "ciesas", "csas", "lsa", "csp", " csp", " csas", "lsas", "ciesp", "cieso", "lso", "lsp"]}}
{"project": "qemu", "commit_id": "97679527bf2f002225d08cfb93f840cef449ac0e", "target": 1, "func": "PCIBus *i440fx_init(PCII440FXState **pi440fx_state, int *piix3_devfn, qemu_irq *pic, int ram_size)\n\n{\n\n    DeviceState *dev;\n\n    PCIBus *b;\n\n    PCIDevice *d;\n\n    I440FXState *s;\n\n    PIIX3State *piix3;\n\n\n\n    dev = qdev_create(NULL, \"i440FX-pcihost\");\n\n    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev));\n\n    b = pci_bus_new(&s->busdev.qdev, NULL, 0);\n\n    s->bus = b;\n\n    qdev_init_nofail(dev);\n\n\n\n    d = pci_create_simple(b, 0, \"i440FX\");\n\n    *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d);\n\n\n\n    piix3 = DO_UPCAST(PIIX3State, dev,\n\n                                 pci_create_simple(b, -1, \"PIIX3\"));\n\n    piix3->pic = pic;\n\n    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);\n\n    (*pi440fx_state)->piix3 = piix3;\n\n\n\n    *piix3_devfn = piix3->dev.devfn;\n\n\n\n    ram_size = ram_size / 8 / 1024 / 1024;\n\n    if (ram_size > 255)\n\n        ram_size = 255;\n\n    (*pi440fx_state)->dev.config[0x57]=ram_size;\n\n\n\n    return b;\n\n}\n", "idx": 13548, "substitutes": {"pi440fx_state": ["pi440fx___trans", "pi440fx_info", "pi440FX_info", "pi440fx___state", "pi440fx2state", "pi440fx2states", "pi440fx_State", "pi440FX_states", "pi440fx___init", "pi440fx2State", "pi440fx_trans", "pi440fx___State", "pi440fx2start", "pi440FX_state", "pi440fx_init", "pi440FX_trans", "pi440fx___states", "pi440ty_stat", "pi440fx_start", "pi440fx2stat", "pi440fx___info", "pi440FX_State", "pi440fx___start", "pi440fx_stat", "pi440FX_start", "pi440FX_init", "pi440fx___stat", "pi440ty_State", "pi440ty_state", "pi440fx_states"], "piix3_devfn": ["piix3_Devnm", "piix3_verfn", "piix3_devnm", "piix3__evfun", "piix3_deffun", "piix3_devicefn", "piix3__devfn", "piix3__devpath", "piix3_devpath", "piix3_evfun", "piix3_verln", "piix3_Devfn", "piix3_devfun", "piix3__devnm", "piix3_evln", "piix3_Devfun", "piix3_deffn", "piix3__devfun", "piix3_Devpath", "piix3_evpath", "piix3_verfc", "piix3_evnm", "piix3__evpath", "piix3_evfn", "piix3__evnm", "piix3_deviceln", "piix3_devfc", "piix3_evfc", "piix3_devicefc", "piix3__evfn", "piix3_devln", "piix3_defnm", "piix3_defpath"], "pic": ["jp", "tc", "sac", "phys", "png", "icon", "pen", "pi", "pres", "pb", "p", "pol", "lib", "pit", "picture", "pin", "ig", "bi", "ic", "ping", "cap", "pins", "bin", "icc", "cam", "magic", "pict", "sp", "script", "Pic", "eric", "phot", "gc", "nic", "mc", "pc", "fc", "fi", "ics", "ps", "iac", "i", "sc", "pa", "txt", "sci"], "ram_size": ["scale_len", "ramptSIZE", "ram_shape", "scale_size", " ram_code", " ram_scale", "ram_default", "RAM_Size", "ramxlength", "ramxdiv", "scale_shape", "ram00size", "ram_length", "ram_name", "ram2len", "cam_scale", "ramxshape", "ramptsize", "ram_Size", "bufferpldefault", "cam_name", "ramxsize", "cam_info", "rampldefault", "ram00loss", "ram_len", "bufferplsize", "RAM_len", "crypt_div", "ramplloss", "ram_loss", "buffer_default", "bufferplloss", "ram2Size", "ram00default", "ram2size", "ram_scale", "ram2SIZE", "ram_code", " ram_SIZE", "ramptlen", "RAM_SIZE", "ramptSize", "crypt_size", "ram_SIZE", "buffer_size", "crypt_shape", "ramplsize", "cam_size", "crypt_length", "ram_info", "ram_div", "RAM_size", "buffer_loss", "scale_Size"], "dev": ["conn", "hw", "raw", "dis", "val", "gu", "t", "new", "cho", "adv", "serial", "develop", "normal", "pro", "def", "des", "mem", "sw", "pub", "data", "cmd", "n", "js", "tr", "v", "g", "test", "ow", "bus", "dd", "dem", "db", "res", "device", "ad", "iv", "av", "vo", "a", "DEV", "ver", "out", "buf", "sys", "debug", "de", "enc", "vision", "se", "ev", "driver", "go", "serv", "local", "build", "p", "Dev", "util", "priv", "cam", "desc", "dj", "h", "e", "sd", "os", "pad", "ve", "prop", "w", "ch"], "b": ["be", "ba", "a", "ib", "f", "bs", "o", "out", "l", "j", "pb", "wb", "p", "n", "usb", "or", "bh", "v", "g", "bi", "t", "sb", "bo", "bt", "bin", "rb", "bus", "br", "r", "fb", "bu", "cb", "c", "db", "bank", "bl", "bc", "h", "e", "B", "u", "bb", "nb", "bg", "i", "w", "x", "y"], "d": ["a", "dict", "f", "l", "j", "n", "p", "dr", "D", "dt", "dm", "v", "g", "t", "du", "di", "dc", "ds", "da", "dd", "r", "gd", "bd", "dim", "dx", "c", "db", "dj", "der", "h", "e", "ad", "sd", "z", "w", "i", "driver"], "s": ["gs", "a", "S", "sing", "serv", "bs", "j", "p", "n", "js", "sq", "v", "g", "sl", "t", "sb", "sv", "sys", "ds", "m", "sa", "sc", "ts", "sp", "c", "sh", "ns", "cs", "fs", "sd", "os", "se", "z", "ss", "i", "w", "y", "rs", "ps"], "piix3": [" piox2", "piox1", "pix1", "piix7", "apiixels3", "pifx43", "piixels7", "piiox03", "piinx1", " piixThree", "piact3", "piixels1", "piact2", " pioxThree", "piinxthree", "pix3", "apiax7", "piIX03", "piIX4", "piixt4", "pifx3", "piIX3", "paix43", "piinx43", "piinx3", "piux03", "apiax3", "piox3", "piax7", " piixthird", "piux3", "piox03", "pixthree", "piixels3", "pifx03", " piux2", "piixthree", "pioxthree", "piixthird", "piixt3", "apifx03", "apiiox4", "parix3", "pifxthree", "apiax1", "piiox3", "pixThree", "apiix3", "parix03", "apifx43", "apiixthree", "piox2", "apifx3", "piix1", "pix2", "apiix1", "pioxthird", "piinx03", "piiox4", "piinx2", " piuxthree", "piax1", " piixthree", " piox1", "piix2", "piuxthree", "apiixelsthree", "piox7", " piix2", "piixels03", "piax3", "piixelsthree", "piix03", "piux2", "apiix43", " piox3", "piaxthree", "parix43", "piix4", "piox43", "apiiox03", "paixthree", "piixThree", "apiix4", "pirix43", " piix1", "piactthird", "piixt03", "pirix3", "paix03", "piux43", "pioxThree", "paix3", "pix03", "piuxthird", "piix43", "apiix03", "apiixels03", "piactthree", "pirixthree", "apiaxthree", "parixthree", " piux3", " piuxthird", "apiiox3", "piinxThree", "pirix03", "apiix7"]}}
{"project": "qemu", "commit_id": "c24a8a0b6dad5a33d84f5fb846edb28c43312c71", "target": 1, "func": "uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)\n\n{\n\n    return inline_cvttq(env, a, float_round_to_zero, 0);\n\n}\n", "idx": 13554, "substitutes": {"env": ["nv", "mem", "conn", "ptr", "environment", "estate", "map", "ctx", "window", "vp", "v", "esc", "En", "buf", "np", "ef", "end", "bench", "ah", "context", " environment", "info", "open", "gn", "cv", "en", "nc", "code", "ec", "ov", "dev", "e", "Environment", "conf", "hl", "config", "ev", "anc", "te", "viron", "gov"], "a": ["ae", "am", "ba", "aa", "as", "o", "sta", "data", "aaa", "apa", "A", "ga", "ar", "ya", "access", "t", "ia", "eta", "wa", "ea", "da", "sa", "ac", "ao", "c", "ap", "b", "alpha", "area", "eas", "ma", "ata", "ta", "fa", "ca", "y", "an", "na"]}}
{"project": "FFmpeg", "commit_id": "73789b85a759f3874112618120194e1712d7adcd", "target": 0, "func": "int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)\n\n{\n\n    int ret;\n\n\n\n    s->ext_audio_mask = 0;\n\n    s->xch_pos = s->xxch_pos = s->x96_pos = 0;\n\n\n\n    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)\n\n        return ret;\n\n    s->gb_in = s->gb;\n\n\n\n    if ((ret = parse_frame_header(s)) < 0)\n\n        return ret;\n\n    if ((ret = alloc_sample_buffer(s)) < 0)\n\n        return ret;\n\n    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)\n\n        return ret;\n\n    if ((ret = parse_optional_info(s)) < 0)\n\n        return ret;\n\n\n\n    // Workaround for DTS in WAV\n\n    if (s->frame_size > size && s->frame_size < size + 4)\n\n        s->frame_size = size;\n\n\n\n    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Read past end of core frame\\n\");\n\n        if (s->avctx->err_recognition & AV_EF_EXPLODE)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13555, "substitutes": {"s": ["ses", "gs", "S", "bs", "sq", "ags", "sam", "st", "m", "eds", "qs", "ads", "stats", "vs", "cs", "ims", "its", "us", "ps", "sw", "n", "js", "g", "ar", "comm", "ds", "ats", "sa", "obj", "services", "ies", "set", "ows", "ains", "parts", "ers", "save", "results", "ver", "less", "eps", "als", "sb", "er", "hs", "sys", "ops", "es", "changes", "fs", "bis", "se", "reads", "ss", "aws", "serv", "has", "outs", "ids", "l", "p", "details", "is", "sv", "ls", "r", "gets", "ts", "ins", "ns", "h", "os", "z", "q", "sets", "sts", "w", "ms", "y", "rs"], "data": ["bytes", "a", "f", "o", "out", "p", " DATA", "bits", "raw", "window", "text", "done", "t", "len", "cache", "buf", "bin", "new", "in", "m", "r", "buffer", "empty", "image", "Data", "b", "length", "d", "to", "DATA", "ata", "value", "dat", "w", "name", "str"], "size": ["Size", "type", "shift", "number", "SIZE", "n", "body", "window", "v", "g", "len", "ize", "padding", "IZE", "now", "offset", "num", "send", "zone", "message", "fee", "none", "use", "empty", "count", "en", "capacity", "ose", "no", "scale", "id", "grow", "equal", "set", "area", "max", "length", "shape", "to", "style", "format", "total", "zero", "small", "name", "normal", "sum", "general"], "ret": ["et", "pret", "fun", "back", "expr", "val", "not", "rm", "result", "nt", "lit", "att", "rev", "it", "nil", "net", " Ret", "del", "usr", "cont", "rem", "def", "mem", "ll", "j", "tr", "RET", "reset", "v", "let", "try", "cat", "res", "print", "flag", "ber", "report", "mt", "arg", "elt", "ter", "resp", "out", "ref", " alt", "Ret", "rets", "pass", "sys", "gt", "ry", "red", "iter", "ft", "status", "jp", "good", "det", "deg", "reg", "r", "alt", "url", "rt", "rier", "cert", "re", "prop", "fit", "pas", "value"]}}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv sr_cy = tcg_temp_new();\n\n\n\n    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);\n\n    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);\n\n\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);\n\n\n\n    gen_ove_cy(dc, sr_cy);\n\n    tcg_temp_free(sr_cy);\n\n}\n", "idx": 13556, "substitutes": {"dc": ["rc", "kw", "cr", "tc", "oc", "cm", "ca", "lc", "ctx", "dr", "cc", "cd", "dt", "dm", "dp", "DC", "di", "ds", "da", "desc", "doc", "ac", "c", "db", "disc", "nc", "ec", "cp", "mc", "bc", "pc", "fc", "d", "vc", "arc", "sc", "ic"], "dest": ["path", "nw", "est", "route", "src", "orig", "trip", "wb", "tr", "cas", "v", "port", "source", "loc", "spec", "origin", "result", "st", "comb", "cat", "dist", "desc", "rest", "Dest", "decl", "trans", "disc", "master", "dev", "de", "iter", "d", "win", "target", "del", "way", "home", "us", "usr"], "srca": ["srarea", " srcaa", "rcaa", "srA", " srcA", "targeta", "sourcearea", "srao", "sourceao", "targetA", "sourceA", "srcaa", "sra", "srcA", "sourcea", "targetaa", " srcao", "srcao", " srcarea", "srcarea", "rca", "rcA"], "srcb": ["sourcebb", "rcb", " srcdb", "sura", "destbb", "surr", "rcdb", " srcB", "sourceb", "source2", "dest2", "rcr", " src2", " srcbb", "sourceB", "surdb", "destb", "src2", "surb", " srcr", "srcB", "rca", "destB", "srcdb", "srcr", "srcbb"]}}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "static int decode_init_mp3on4(AVCodecContext * avctx)\n\n{\n\n    MP3On4DecodeContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    if ((avctx->extradata_size < 2) || (avctx->extradata == NULL)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Codec extradata missing or too short.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    s->chan_cfg = (((unsigned char *)avctx->extradata)[1] >> 3) & 0x0f;\n\n    s->frames = mp3Frames[s->chan_cfg];\n\n    if(!s->frames) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid channel config number.\\n\");\n\n        return -1;\n\n    }\n\n    avctx->channels = mp3Channels[s->chan_cfg];\n\n\n\n    /* Init the first mp3 decoder in standard way, so that all tables get builded\n\n     * We replace avctx->priv_data with the context of the first decoder so that\n\n     * decode_init() does not have to be changed.\n\n     * Other decoders will be inited here copying data from the first context\n\n     */\n\n    // Allocate zeroed memory for the first decoder context\n\n    s->mp3decctx[0] = av_mallocz(sizeof(MPADecodeContext));\n\n    // Put decoder context in place to make init_decode() happy\n\n    avctx->priv_data = s->mp3decctx[0];\n\n    decode_init(avctx);\n\n    // Restore mp3on4 context pointer\n\n    avctx->priv_data = s;\n\n    s->mp3decctx[0]->adu_mode = 1; // Set adu mode\n\n\n\n    /* Create a separate codec/context for each frame (first is already ok).\n\n     * Each frame is 1 or 2 channels - up to 5 frames allowed\n\n     */\n\n    for (i = 1; i < s->frames; i++) {\n\n        s->mp3decctx[i] = av_mallocz(sizeof(MPADecodeContext));\n\n        s->mp3decctx[i]->compute_antialias = s->mp3decctx[0]->compute_antialias;\n\n        s->mp3decctx[i]->adu_mode = 1;\n\n        s->mp3decctx[i]->avctx = avctx;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13571, "substitutes": {"avctx": ["avecf", "avcv", "avercmd", "vertx", "avtx", "awtx", " avkl", "navctx", " avpool", "vrctx", "avercv", "avercontext", "avereq", "avertc", "avpkg", "afcmp", "avtmp", "ajmc", "avecb", "afpkg", " avmc", "vrjac", "avertx", "avetimeout", "navsys", "avercmp", " avcontext", "avtc", " avctl", "avcfg", " avcf", " avcb", "aftimeout", "wavctx", "awjac", "averkl", "vrcontext", "aftmp", "avcmp", "ovctx", "awctx", "awcontext", "avsys", " avtxt", "avkl", "vrcmp", "averreq", "afctl", "avcb", "avecontext", "ovcb", "avetx", "averctl", "avermc", "verctx", " avcmp", "aversys", " avcfg", "avertmp", "ajcmp", "avtxt", "avecfg", "averjp", "vrctl", "avepool", " avreq", "afjac", "wavpkg", "averpkg", "afcontext", "ajcontext", "avekl", "wavcf", "navtc", "ovtx", "avecmd", "avtimeout", "vrtx", "afctx", "avreq", "averctx", "avcmd", "avjp", " avjac", "avconn", "ajjp", "aftxt", "ajtx", "avejac", "avecmp", "aveconn", "avjac", "avectl", "vercv", " avpkg", "avctl", "ajcv", "wavcontext", "avetxt", "avcontext", "avepkg", "avmc", "ajctl", "avesys", "ajctx", " avcmd", "ajconn", " avtx", "navjac", "avertimeout", "avpool", "avectx", "avcf", "avetc", "ovcfg", " avtmp", " avjp", "vrconn", "averjac", "averpool"], "s": ["ses", "gs", "S", "bs", "ports", "series", "sq", "ags", "sl", "t", "m", "iss", "acs", "qs", "stats", "vs", "states", "cs", "tests", "ims", "pers", "its", "https", "ps", "sw", "j", "js", "v", "g", "comm", "spec", "ds", "ats", "sa", "obj", "services", "args", "ows", "ains", "parts", "scl", "less", "als", "sb", "hs", "sys", "strings", "ess", "c", "ares", "es", "changes", "fs", "bis", "se", "sports", "ss", "status", "aws", "tags", "ids", "l", "p", "details", "is", "sv", "ls", "mods", "gets", "ts", "ins", "ns", "h", "os", "sts", "ms", "y", "rs"], "i": ["index", " li", " di", " count", "cli", "gu", " pi", " ki", "ami", "ai", "m", " I", "xi", "qi", " v", "ims", "it", "li", " c", "ind", "j", "ki", "n", "si", "zi", " ti", "v", "g", "ui", " pos", " index", " bi", "im", "ti", "fi", "x", "ri", "span", "ix", "ip", "ij", "a", "ii", "mi", "I", "pi", " iter", " si", "batch", "di", " ii", " mi", "in", "sim", "mu", "c", "remote", "ci", "id", " n", " ni", "u", " x", "multi", "me", " vi", "iu", " j", "ini", "l", "p", "bi", "is", "\u0438", " multi", "h", "point", "gi", " p", " m", "z", "q", "y"]}}
{"project": "qemu", "commit_id": "1acae9f22380a03b468a29a3cc035b280610b5e4", "target": 0, "func": "_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,\n\n          const struct timespec *,tsp,int,flags)\n\n#endif\n\n#endif /* CONFIG_UTIMENSAT  */\n\n\n\n#ifdef CONFIG_INOTIFY\n\n#include <sys/inotify.h>\n\n\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\nstatic int sys_inotify_init(void)\n\n{\n\n  return (inotify_init());\n\n}\n", "idx": 13589, "substitutes": {}}
{"project": "qemu", "commit_id": "8dc7a7725bd6db2aa7e3c09b49bc21a1a25f40cb", "target": 1, "func": "static void curl_readv_bh_cb(void *p)\n\n{\n\n    CURLState *state;\n\n    int running;\n\n\n\n    CURLAIOCB *acb = p;\n\n    BDRVCURLState *s = acb->common.bs->opaque;\n\n\n\n    qemu_bh_delete(acb->bh);\n\n    acb->bh = NULL;\n\n\n\n    size_t start = acb->sector_num * SECTOR_SIZE;\n\n    size_t end;\n\n\n\n    // In case we have the requested data already (e.g. read-ahead),\n\n    // we can just call the callback and be done.\n\n    switch (curl_find_buf(s, start, acb->nb_sectors * SECTOR_SIZE, acb)) {\n\n        case FIND_RET_OK:\n\n            qemu_aio_release(acb);\n\n            // fall through\n\n        case FIND_RET_WAIT:\n\n            return;\n\n        default:\n\n            break;\n\n    }\n\n\n\n    // No cache found, so let's start a new request\n\n    state = curl_init_state(s);\n\n    if (!state) {\n\n        acb->common.cb(acb->common.opaque, -EIO);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->start = 0;\n\n    acb->end = (acb->nb_sectors * SECTOR_SIZE);\n\n\n\n    state->buf_off = 0;\n\n    g_free(state->orig_buf);\n\n    state->buf_start = start;\n\n    state->buf_len = acb->end + s->readahead_size;\n\n    end = MIN(start + state->buf_len, s->len) - 1;\n\n    state->orig_buf = g_malloc(state->buf_len);\n\n    state->acb[0] = acb;\n\n\n\n    snprintf(state->range, 127, \"%zd-%zd\", start, end);\n\n    DPRINTF(\"CURL (AIO): Reading %d at %zd (%s)\\n\",\n\n            (acb->nb_sectors * SECTOR_SIZE), start, state->range);\n\n    curl_easy_setopt(state->curl, CURLOPT_RANGE, state->range);\n\n\n\n    curl_multi_add_handle(s->multi, state->curl);\n\n\n\n    /* Tell curl it needs to kick things off */\n\n    curl_multi_socket_action(s->multi, CURL_SOCKET_TIMEOUT, 0, &running);\n\n}\n", "idx": 13604, "substitutes": {"p": ["jp", "a", "pi", "pb", "j", "n", "ctx", "vp", "v", "g", "t", "pp", "ping", "np", "P", "m", "op", "r", "c", "sp", "fp", "ap", "wp", "cp", "b", "h", "pc", "q", "bp", "pkg", "i", "pa", "ps"], "state": ["index", "started", "scope", "State", "sequence", "operator", "stat", "ate", "check", "port", "t", "close", "st", "loop", "result", "policy", "command", "m", "control", "change", "states", "un", "start", "draw", "trace", "see", "view", "error", "type", "n", "resource", "the", "test", "spec", "space", "job", "power", "STATE", "comment", "run", "print", "root", "set", "style", "trust", "version", "f", "out", "call", "temp", "user", "monitor", "store", "al", "powered", "update", "zone", "current", "info", "progress", "c", "we", "active", "private", "config", "se", "init", "valid", "process", "registered", "status", "instance", "stable", "local", "success", "estate", "rule", "is", "tag", "r", "none", "time", "range", "runner", "count", "event", "base", "no", "post", "h", "ace", "list", "component", "value", "commit", "name", "finished"], "running": ["status", "using", "stable", "live", "version", " Running", "started", "cur", "hidden", "starting", "initialized", "name", "existing", "enabled", "done", "binding", "padding", "loop", "loading", "ending", "current", "working", "available", " remaining", "setting", "NING", "run", "Running", "checked", "no", "blocking", " starting", "active", "total", "ready", "visible", "bound", " started", "valid"], "acb": ["agwb", " acr", "aconbuf", " cacb", "aconbe", "ocb", "acbe", "acab", "acca", "acbr", "acnb", "acby", "acersb", "ancbd", "accby", "ecba", "aclr", "accg", "acbb", "racbe", "acd", " cacob", "accr", "sacv", "aclsb", "absb", "sacl", "ancbe", "acu", "ecbb", "pacbe", "actb", "pacsb", "accbb", "accbe", "acr", " acbb", " acu", "ecob", " cacby", "agbr", "absba", "icanb", "accl", "acong", "achb", "aconbd", "ACbuf", "accsb", "abba", "racb", "ancbb", "sacb", "macp", "pacwb", "achwb", "agb", " acby", "aca", "acona", "aconB", "racsb", "aconp", "ACB", "acg", "accB", "ocrb", "ancb", "accb", " cacsb", "accu", "icanl", " cacbb", "ancv", "accab", " cacba", "iacb", "pacp", "aconr", "iacbb", "aconrb", "accp", "ancr", "actl", "actB", "pacv", "aclba", "actp", "accwb", "aclb", "ocbb", "ancrb", "ocbe", "accnb", "abb", "iacd", "accba", "accbc", "acsb", "sacB", "achab", "macbb", " acba", " acd", "ACb", "acwb", "accob", "acp", "pacb", "actbb", "acl", " acbc", " acj", "ecb", "acerb", "actsb", "aconbb", "accbr", "achbr", " acbe", "ACp", "accbuf", " aca", "absbb", "aclnb", " acp", "ancsb", "acbc", "actrb", "pacg", "acerr", "sacbd", " acrb", "acbuf", "pacl", "iacsb", "acob", "racwb", "abnb", "acerbc", "acrb", "macb", "pacbc", " acsb", "acB", "acj", "aconu", "icanbc", "aconb", "acv", "accd", "agab", "icanbe", "sacsb", "abr", "pacbd", "accbd", "accj", "iacp", "macrb", "iacba", " cacr", "acbd", "aclj", "acba"], "s": ["status", "ses", "south", "gs", "a", "S", "as", "settings", "bs", "socket", "session", "ports", "scope", "n", "js", "bits", "params", "sq", "v", "g", "sl", "t", "comm", "is", "sb", "sv", "spec", "service", "sys", "space", "ds", "ls", "ats", "m", "sa", "r", "services", "qs", "ssl", "ts", "self", "sp", "c", "stats", "ins", "ns", "b", "args", "h", "set", "changes", "fs", "os", "bis", "its", "se", "ps", "parts", "q", "ss", "w", "sts", "https", "rs", "sk"], "end": ["index", "be", "est", "out", "ax", "ff", "size", "head", "n", "begin", "next", "port", "ent", "close", "stop", "nd", "len", "den", "gen", "st", "rend", "offset", " End", "send", "rest", "ended", "END", "last", "env", "ending", "until", "off", "add", "range", "ender", "open", "event", "dest", "en", "pos", "limit", "pend", "eff", "start", "id", "set", "e", "hend", "enc", "max", "length", "pad", "it", "eng", "z", "final", "fin", "End"]}}
{"project": "FFmpeg", "commit_id": "3a83b2461e4ce9d48ad6ab037eb14569d0e53506", "target": 1, "func": "static int dnxhd_encode_rdo(AVCodecContext *avctx, DNXHDEncContext *ctx)\n\n{\n\n    int lambda, up_step, down_step;\n\n    int last_lower = INT_MAX, last_higher = 0;\n\n    int x, y, q;\n\n\n\n    for (q = 1; q < avctx->qmax; q++) {\n\n        ctx->qscale = q;\n\n        avctx->execute2(avctx, dnxhd_calc_bits_thread, NULL, NULL, ctx->m.mb_height);\n\n    }\n\n    up_step = down_step = 2<<LAMBDA_FRAC_BITS;\n\n    lambda = ctx->lambda;\n\n\n\n    for (;;) {\n\n        int bits = 0;\n\n        int end = 0;\n\n        if (lambda == last_higher) {\n\n            lambda++;\n\n            end = 1; // need to set final qscales/bits\n\n        }\n\n        for (y = 0; y < ctx->m.mb_height; y++) {\n\n            for (x = 0; x < ctx->m.mb_width; x++) {\n\n                unsigned min = UINT_MAX;\n\n                int qscale = 1;\n\n                int mb = y*ctx->m.mb_width+x;\n\n                for (q = 1; q < avctx->qmax; q++) {\n\n                    unsigned score = ctx->mb_rc[q][mb].bits*lambda+(ctx->mb_rc[q][mb].ssd<<LAMBDA_FRAC_BITS);\n\n                    if (score < min) {\n\n                        min = score;\n\n                        qscale = q;\n\n                    }\n\n                }\n\n                bits += ctx->mb_rc[qscale][mb].bits;\n\n                ctx->mb_qscale[mb] = qscale;\n\n                ctx->mb_bits[mb] = ctx->mb_rc[qscale][mb].bits;\n\n            }\n\n            bits = (bits+31)&~31; // padding\n\n            if (bits > ctx->frame_bits)\n\n                break;\n\n        }\n\n        //av_dlog(ctx->m.avctx, \"lambda %d, up %u, down %u, bits %d, frame %d\\n\",\n\n        //        lambda, last_higher, last_lower, bits, ctx->frame_bits);\n\n        if (end) {\n\n            if (bits > ctx->frame_bits)\n\n                return -1;\n\n            break;\n\n        }\n\n        if (bits < ctx->frame_bits) {\n\n            last_lower = FFMIN(lambda, last_lower);\n\n            if (last_higher != 0)\n\n                lambda = (lambda+last_higher)>>1;\n\n            else\n\n                lambda -= down_step;\n\n            down_step *= 5; // XXX tune ?\n\n            up_step = 1<<LAMBDA_FRAC_BITS;\n\n            lambda = FFMAX(1, lambda);\n\n            if (lambda == last_lower)\n\n                break;\n\n        } else {\n\n            last_higher = FFMAX(lambda, last_higher);\n\n            if (last_lower != INT_MAX)\n\n                lambda = (lambda+last_lower)>>1;\n\n            else if ((int64_t)lambda + up_step > INT_MAX)\n\n                return -1;\n\n            else\n\n                lambda += up_step;\n\n            up_step = FFMIN((int64_t)up_step*5, INT_MAX);\n\n            down_step = 1<<LAMBDA_FRAC_BITS;\n\n        }\n\n    }\n\n    //av_dlog(ctx->m.avctx, \"out lambda %d\\n\", lambda);\n\n    ctx->lambda = lambda;\n\n    return 0;\n\n}\n", "idx": 13635, "substitutes": {"avctx": ["vctx", "vcmp", "avtx", "avjac", "avcmp", "avctl", "cvtx", "avcontext", " avsetup", "avercontext", "afcontext", "avsetup", "svcmp", "avcm", "afcm", "cvcontext", "savjp", "savctl", "savjac", "cvcc", "savctx", " avtx", "absetup", "avecontext", "aftx", "abcontext", "afctx", "svcontext", "svtx", "averctx", "avectx", "avetx", "cvctx", "averjp", "averctl", "avjp", " avjac", " avcmp", "avertx", "abctx", "avcc", "avecm", "aversetup", " avcc", " avcontext", "abcm", " avctl", "svctx", " avjp", "averjac", "vtx", "abtx", "vcontext", "abcc"], "ctx": ["index", "conn", "city", "hw", "expr", "cmp", "check", "loc", "command", "context", "console", "xc", "abc", "fn", "pkg", "exec", "tx", "kw", "ctl", "fw", "co", "unc", "wx", "setup", "lc", "addr", "cmd", "aka", "crit", "kt", "timeout", "conv", "xp", "wcs", "via", "cfg", "obj", "nc", "std", "cp", "gc", "mc", "ctrl", "pg", "Context", "ppo", "tmp", "ca", "history", "resp", "cf", "utils", "cc", "req", "tk", "proc", "ctr", "sys", "np", "info", "work", " cx", "c", "cv", "mom", "kl", "acl", "pc", "etc", "config", "kj", "iat", "jac", "jp", "cu", "tc", "cm", "handle", "ia", "func", "ct", "act", "desc", "prefix", "rt", "ck", "jj", "fc", "that", "voc"], "lambda": ["shift", "fun", "expr", "aaa", "window", "igma", "amb", "half", "sam", "t", "wa", "delay", "m", "fee", "bd", "dim", "cb", "function", "mas", "factor", "foo", "length", "qt", "ma", "lo", "ta", "zero", "lim", "appa", "lam", "kw", "lower", "lc", "hz", "la", "colm", "fred", "hello", "alpha", "scale", "partial", "tmp", "mb", "usage", "i", "fa", "priority", "dra", "a", "cf", "f", "pi", "bits", "this", "perm", "sb", "eta", "offset", "da", "broad", "qa", "json", "ja", "mu", "lu", "progress", "capacity", "bf", "prime", "kl", "una", "acl", "xa", "xf", "amd", "frequency", "lr", "aw", "size", "l", "Alpha", "deg", "xy", "func", "mega", "hi", "shr", "balance", "xb", "two", "phi", "beta", "weights", "nom", "pointer"], "up_step": ["down_sum", "upTimesteps", "down_walk", " up_loop", " up_steps", "down_STEP", "up___sum", "up___step", "up___STEP", "up_tick", "upTimetick", "upTimewalk", "upTimestep", "up_walk", "down_steps", " up_skip", "up_skip", "down_tick", "up_sum", "up___steps", "up_loop", "up_steps", "up_STEP"], "down_step": ["down2steps", "downptsteps", " down_scale", "down2step", "downptstep", " down_steps", "down2start", "up_drop", "down_stage", "down_STEP", "up_Step", " down_STEP", "down_start", "up_steps", "downptdrop", "down_drop", "down2STEP", "down_scale", "down_steps", "down_Step", "up_loop", "up_start", "up_stage", "down_loop", "downptstage", "up_STEP"], "x": ["tx", "xt", "index", "key", "path", "inx", "at", "f", "o", "wx", "ph", "ax", "l", "j", "yx", "n", "p", "ex", "xxx", "X", "v", "xs", "xy", "el", "t", "ox", "xp", "in", "m", "fx", "r", "ux", "att", "k", "time", "xi", "dx", "xc", "lat", "ry", "ice", "xx", "on", "h", "px", "xf", "z", "xa", "rx", "i", "w", "xml", "ix", "mx"], "y": ["yy", "ty", "by", "yt", "oy", "asy", "py", "dy", "ny", "ys", "j", "sy", "axy", "row", "Y", "v", "yi", "height", "try", "xy", "kit", "ym", "ay", "ya", "g", "yr", "ye", "sys", "m", "cy", "vy", "iy", "ies", "sim", "very", "lon", "yer", "ry", "b", "hot", "my", "ot", "from", "col", "sky", "yo", "z", "gy", "ey", "wy", "i", "ch"], "q": ["bit", "index", "ib", "query", "sq", "eq", "m", "lock", "qi", "quote", "qt", "requ", "queue", "bg", "pkg", "qq", "qu", "wx", "j", "mask", "v", "g", "iq", "ke", "ue", "que", "cp", "pg", "mb", "i", "pe", "ix", "ip", "quit", "key", "f", "kg", "req", "ox", "qa", "ask", "c", "cv", "ry", "id", "quant", "u", "qual", "quest", "go", "l", "p", "min", "ql", "aq", "pt", "pp", "k", "quick", "ck", "dq", "b", "gm", "h", "mp", "qv", "col", "ve", "z", "quality", "w", "Q", "ch", "question"]}}
{"project": "FFmpeg", "commit_id": "5a2645cafeca1c2207ac55cc831c3349572a82ed", "target": 1, "func": "static int find_and_decode_index(NUTContext *nut)\n\n{\n\n    AVFormatContext *s = nut->avf;\n\n    AVIOContext *bc    = s->pb;\n\n    uint64_t tmp, end;\n\n    int i, j, syncpoint_count;\n\n    int64_t filesize = avio_size(bc);\n\n    int64_t *syncpoints;\n\n    int8_t *has_keyframe;\n\n    int ret = AVERROR_INVALIDDATA;\n\n\n\n    avio_seek(bc, filesize - 12, SEEK_SET);\n\n    avio_seek(bc, filesize - avio_rb64(bc), SEEK_SET);\n\n    if (avio_rb64(bc) != INDEX_STARTCODE) {\n\n        av_log(s, AV_LOG_ERROR, \"no index at the end\\n\");\n\n        return ret;\n\n    }\n\n\n\n    end  = get_packetheader(nut, bc, 1, INDEX_STARTCODE);\n\n    end += avio_tell(bc);\n\n\n\n    ffio_read_varlen(bc); // max_pts\n\n    GET_V(syncpoint_count, tmp < INT_MAX / 8 && tmp > 0);\n\n    syncpoints   = av_malloc(sizeof(int64_t) *  syncpoint_count);\n\n    has_keyframe = av_malloc(sizeof(int8_t)  * (syncpoint_count + 1));\n\n    if (!syncpoints || !has_keyframe)\n\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < syncpoint_count; i++) {\n\n        syncpoints[i] = ffio_read_varlen(bc);\n\n        if (syncpoints[i] <= 0)\n\n            goto fail;\n\n        if (i)\n\n            syncpoints[i] += syncpoints[i - 1];\n\n    }\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        int64_t last_pts = -1;\n\n        for (j = 0; j < syncpoint_count;) {\n\n            uint64_t x = ffio_read_varlen(bc);\n\n            int type   = x & 1;\n\n            int n      = j;\n\n            x >>= 1;\n\n            if (type) {\n\n                int flag = x & 1;\n\n                x >>= 1;\n\n                if (n + x >= syncpoint_count + 1) {\n\n                    av_log(s, AV_LOG_ERROR, \"index overflow A\\n\");\n\n                    goto fail;\n\n                }\n\n                while (x--)\n\n                    has_keyframe[n++] = flag;\n\n                has_keyframe[n++] = !flag;\n\n            } else {\n\n                while (x != 1) {\n\n                    if (n >= syncpoint_count + 1) {\n\n                        av_log(s, AV_LOG_ERROR, \"index overflow B\\n\");\n\n                        goto fail;\n\n                    }\n\n                    has_keyframe[n++] = x & 1;\n\n                    x >>= 1;\n\n                }\n\n            }\n\n            if (has_keyframe[0]) {\n\n                av_log(s, AV_LOG_ERROR, \"keyframe before first syncpoint in index\\n\");\n\n                goto fail;\n\n            }\n\n            assert(n <= syncpoint_count + 1);\n\n            for (; j < n && j < syncpoint_count; j++) {\n\n                if (has_keyframe[j]) {\n\n                    uint64_t B, A = ffio_read_varlen(bc);\n\n                    if (!A) {\n\n                        A = ffio_read_varlen(bc);\n\n                        B = ffio_read_varlen(bc);\n\n                        // eor_pts[j][i] = last_pts + A + B\n\n                    } else\n\n                        B = 0;\n\n                    av_add_index_entry(s->streams[i], 16 * syncpoints[j - 1],\n\n                                       last_pts + A, 0, 0, AVINDEX_KEYFRAME);\n\n                    last_pts += A + B;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n\n        av_log(s, AV_LOG_ERROR, \"index checksum mismatch\\n\");\n\n        goto fail;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    av_free(syncpoints);\n\n    av_free(has_keyframe);\n\n    return ret;\n\n}\n", "idx": 13636, "substitutes": {"nut": ["nv", "nw", "torn", "nor", "nuts", "six", "cn", "hog", "ctx", "n", "ours", "four", "sequ", "sq", "bj", "stab", "ng", "ox", "np", "tn", "nir", "nr", "mson", "nt", "nova", "Nut", "snap", "san", "hawk", "critical", "orn", "anova", "nc", "fn", "rot", "ns", "nas", "uts", "ore", "nex", "piece", "nih", "gob", "hn", "sat", "nm", "cro", "cot", "rn"], "s": ["csv", "sis", "aws", "ses", "gs", "a", "S", "f", "sac", "bs", "n", "js", "p", "sq", "conv", "v", "sl", "t", "is", "sb", "sv", "sys", "hs", "ds", "ats", "sa", "r", "sc", "ts", "c", "stats", "ns", "b", "cs", "an", "es", "h", "set", "fs", "conf", "os", "sat", "sn", "ss", "sts", "w", "rs", "ps"], "bc": ["rc", "bitcoin", "co", "unc", "tc", "oc", "ib", "bs", "cm", "conn", "cn", "lc", "pb", "ctx", "cc", "chron", "conv", "bi", "comm", "bt", "bo", "sb", "dc", "sec", "rb", "arb", "cl", "BC", "bec", "uc", "bd", "ck", "c", "cb", "xc", "db", "nc", "bf", "ec", "console", "gc", "b", "mc", "cs", "soc", "pc", "fc", "con", "jc", "bb", "vc", "bp", "bg", "gro", "sc", "ic", "ob", "jac"], "tmp": ["bytes", "resp", "td", "ptr", "tc", "out", "size", "ind", "cmd", "ctx", "tt", "p", "important", "cmp", "params", "temp", "timeout", "mk", "assets", "perm", "test", "xy", " old", "t", "nd", " np", "stop", "cache", "buff", "buf", "np", "offset", "nt", "m", "T", "snap", "obj", "rt", "cb", "sp", "img", "root", "mp", "etc", "max", "uv", "mb", "err", "nb", "tm", "tp", "qq"], "end": ["td", "mem", "conn", "ret", "head", "ff", "size", "p", "begin", "reset", "ent", "t", "stop", "len", "nd", "st", "buf", "np", "offset", "send", "ended", "END", "alt", "obj", "ending", "off", "ue", "add", "buffer", "pend", "ep", "append", "start", "post", "id", "set", "e", "ad", "max", "length", "final", "fin", "End"], "i": ["index", "dr", "cli", "ami", "ai", "m", "xi", "qi", "ims", "it", "ji", "li", "ind", "n", "ki", "si", "zi", "v", "try", "g", "ui", "iq", "iii", "im", "ti", "ri", "ic", "ix", "ip", "ij", "f", "ii", "mi", "I", "pi", "batch", "er", "di", " ii", "in", "ie", "sim", "info", "c", "ci", "id", "multi", "me", "init", "status", "o", "iu", "ini", "l", "ei", "p", "chain", "bi", "io", "is", "ia", "k", "hi", "\u0438", "jj", "h", "e", "list", "gi", "phi", "name", "y"], "j": ["jp", "ij", "ni", "o", "ii", "ind", "l", "n", "js", "p", "aj", "bj", "v", "try", "g", "bi", "xy", "uj", "k", "m", "br", "obj", "json", "ja", "sim", "c", "dj", "J", "oj", "pos", "jj", "b", "h", "jump", "fr", "jl", "jc", "ji", "it", "kj", "z", "q", "nm", "y", "ix", "jac"], "syncpoint_count": ["syncblock_Count", "syncpoint8code", "syncblock_count", "synctype_count", "syncpoint2count", "syncpointer_code", "synctype_Count", "syncpoint1count", "syncpointer_Count", "syncpointlynumber", "syncblock_num", "syncpoint_Count", "syncpoint1Count", "syncpoint_time", "syncpointlyCount", "syncpoint2length", "syncpoint_number", "syncpoint1code", "synctype_number", "syncpoint2Count", "syncpointer_count", "syncblock_code", "syncpointer_length", "syncpoint2code", "syncpoint_found", "syncpoint_num", "syncpointlycount", "synctype_found", "syncpoint_length", "syncpoint_counter", "syncpoint8Count", "syncpoint8count", "syncpoint_code", "syncpoint_size", "syncpointlyfound", "syncpoint1num", "syncpointer_time", "syncpoint8time"], "syncpoints": ["scaledates", "syncobjects", "syncPoints", "syncbits", "synparts", " synctypes", "syncdates", "synPoints", " syncpos", "syncjobs", "flushPoints", "yncparts", "synpoints", "scalepoints", " syncobjects", "synobjects", "yncbits", "synlines", "ynctypes", "scalepointers", "synclines", "yncpos", " syncdates", "writelines", "syncpos", "scalePoints", "scrollobjects", "writeobjects", "yncobjects", "yncjobs", " syncparts", " syncPoints", " syncbits", "syncpointers", "flushpoints", "scrollpoints", "syntypes", "syndates", "synctypes", "yncpoints", "synpointers", "flushparts", "yncPoints", "writepoints", "yncpointers", "writepointers", "synjobs", "yncdates", "flushdates", "syncparts", "flushpointers", "scrolldates", "synbits", "synpos", "ynclines", " syncjobs"], "has_keyframe": ["has_linkword", "has_boxframe", "has_keyframes", "has_Keyfram", "has_KEYFrame", "has_Keycode", "has_KeyFrame", "has_Keyword", "has_boxframes", "has_powerfram", "has_keyword", "has_keyfram", "has_powerframes", "has_powerframe", "has_linkframe", "has_KEYword", "has_keycode", "has_keyFrame", "has_boxcode", "has_kframe", "has_linkframes", "has_kcode", "has_KEYframes", "has_Keyframe", "has_linkfram", "has_Keyframes", "has_linkFrame", "has_kframes", "has_KEYframe"], "x": ["tx", "bit", "xes", "inx", "type", "xxxx", "f", "wx", "xxx", "p", "ex", "n", "xd", "X", "xs", "v", "xy", "t", "ox", "xp", "fx", "ux", "xi", "dx", "c", "xc", "xx", "xe", "e", "px", "xf", "xa", "z", "rx", " xx", "xt", "y", "w", "ix", "mx"]}}
{"project": "qemu", "commit_id": "b0f74c87a1dbd6b0c5e4de7f1c5cb40197e3fbe9", "target": 1, "func": "static inline void menelaus_rtc_stop(struct menelaus_s *s)\n\n{\n\n    qemu_del_timer(s->rtc.hz);\n\n    s->rtc.next =- qemu_get_clock(rt_clock);\n\n    if (s->rtc.next < 1)\n\n        s->rtc.next = 1;\n\n}\n", "idx": 13667, "substitutes": {"s": ["ses", "aws", "gs", "S", "bs", "less", "ties", "js", "params", "sq", "g", "sl", "t", "comm", "is", "sv", "sb", "spec", "st", "hs", "sys", "service", "ds", "ls", "ats", "m", "sa", "r", "services", "ies", "qs", "so", "ts", "c", "sp", "stats", "ares", "sr", "sync", "states", "ns", "ops", "cs", "h", "es", "set", "tes", "changes", "fs", "os", "se", "ss", "sts", "ms", "rs", "su", "ps"]}}
{"project": "qemu", "commit_id": "8cf07dcbe7691dbe4f47563058659dba6ef66b05", "target": 1, "func": "int drive_init(struct drive_opt *arg, int snapshot, void *opaque)\n\n{\n\n    char buf[128];\n\n    char file[1024];\n\n    char devname[128];\n\n    char serial[21];\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int bdrv_flags, onerror;\n\n    int drives_table_idx;\n\n    char *str = arg->opt;\n\n    static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\",\n\n                                           \"cyls\", \"heads\", \"secs\", \"trans\",\n\n                                           \"media\", \"snapshot\", \"file\",\n\n                                           \"cache\", \"format\", \"serial\", \"werror\",\n\n                                           NULL };\n\n\n\n    if (check_params(params, str) < 0) {\n\n         fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\",\n\n                         buf, str);\n\n         return -1;\n\n    }\n\n\n\n    file[0] = 0;\n\n    cyls = heads = secs = 0;\n\n    bus_id = 0;\n\n    unit_id = -1;\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    index = -1;\n\n    cache = 3;\n\n\n\n    if (machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"bus\", str)) {\n\n        bus_id = strtol(buf, NULL, 0);\n\n\tif (bus_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"unit\", str)) {\n\n        unit_id = strtol(buf, NULL, 0);\n\n\tif (unit_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", str)) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf);\n\n            return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"index\", str)) {\n\n        index = strtol(buf, NULL, 0);\n\n\tif (index < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid index\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cyls\", str)) {\n\n        cyls = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"heads\", str)) {\n\n        heads = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"secs\", str)) {\n\n        secs = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"trans\", str)) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    str);\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"media\", str)) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", str);\n\n\t        return -1;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"snapshot\", str)) {\n\n        if (!strcmp(buf, \"on\"))\n\n\t    snapshot = 1;\n\n        else if (!strcmp(buf, \"off\"))\n\n\t    snapshot = 0;\n\n\telse {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cache\", str)) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return -1;\n\n        }\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"format\", str)) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return -1;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (arg->file == NULL)\n\n        get_param_value(file, sizeof(file), \"file\", str);\n\n    else\n\n        pstrcpy(file, sizeof(file), arg->file);\n\n\n\n    if (!get_param_value(serial, sizeof(serial), \"serial\", str))\n\n\t    memset(serial, 0,  sizeof(serial));\n\n\n\n    onerror = BLOCK_ERR_STOP_ENOSPC;\n\n    if (get_param_value(buf, sizeof(serial), \"werror\", str)) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' index cannot be used with bus and unit\\n\", str);\n\n            return -1;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get_index(type, bus_id, unit_id) != -1) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\",\n\n                        str, unit_id, max_devs - 1);\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get_index(type, bus_id, unit_id) != -1)\n\n        return -2;\n\n\n\n    /* init */\n\n\n\n    if (type == IF_IDE || type == IF_SCSI)\n\n        mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n    if (max_devs)\n\n        snprintf(buf, sizeof(buf), \"%s%i%s%i\",\n\n                 devname, bus_id, mediastr, unit_id);\n\n    else\n\n        snprintf(buf, sizeof(buf), \"%s%s%i\",\n\n                 devname, mediastr, unit_id);\n\n    bdrv = bdrv_new(buf);\n\n    drives_table_idx = drive_get_free_idx();\n\n    drives_table[drives_table_idx].bdrv = bdrv;\n\n    drives_table[drives_table_idx].type = type;\n\n    drives_table[drives_table_idx].bus = bus_id;\n\n    drives_table[drives_table_idx].unit = unit_id;\n\n    drives_table[drives_table_idx].onerror = onerror;\n\n    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[drives_table_idx].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    case IF_COUNT:\n\n        abort();\n\n    }\n\n    if (!file[0])\n\n        return -2;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    if (bdrv_key_required(bdrv))\n\n        autostart = 0;\n\n    return drives_table_idx;\n\n}\n", "idx": 13672, "substitutes": {"arg": ["param", "mem", "mer", "ref", "ax", "cmd", "ag", "admin", "call", "agg", "g", "ar", "ig", "reg", "ay", "md", "loc", "job", "op", "og", "tag", "Arg", "mark", "doc", "ac", "parse", "event", "argument", "ang", "cand", "alias", "args", "ack", "pg", "ad", "ark", "config", "ma", "arp"], "snapshot": ["Snapvol", "snapimage", "snapshots", "rootimage", "rootvol", "Snapshots", "rootshot", "Snapimage", "Snapshot", "apshots", "apshot", "apvol", "apimage", "rootshots", "snapvol"], "opaque": ["OPatile", "iopatile", "iopaque", "openoid", "opacity", "iopoid", "oppaque", "Opaque", "openacity", "Opacity", "oppacity", "openaque", "opatile", "opoid", "oppoid", "OPacity", "OPaque", "iopacity", "Opatile"], "buf": ["vec", "orig", "cur", "attr", "ctx", "window", "opt", "filename", "pool", "doc", "rev", "cb", "board", "uf", "queue", "pkg", "arr", "rc", "def", "ba", "param", "array", "data", "cmd", "map", "tr", "Buffer", "conv", "box", "read", "buff", "bus", "br", "cfg", "env", "obj", "db", "pos", "cp", "args", "tmp", "txt", "history", "Buff", "ref", "src", "rw", "seq", "row", "wb", "proc", "ctr", "rb", "buffer", "block", "cv", "bf", "bc", "folder", "iter", "config", "err", "bytes", "msg", "bin", "cap", "desc", "r", "base", "img", "code", "b", "var", "pad"], "file": ["vol", "path", "f", "number", "family", "body", "storage", "stat", "dir", "filename", "user", "ile", "chain", "port", "io", "le", "unit", "loc", "command", "bus", "connection", "line", "disk", "channel", "buffer", "block", "db", "base", "page", "link", "limit", "board", "fat", "table", "device", "File", "folder", "area", "list", "queue", "files", "name"], "devname": ["evstring", "volName", "devline", "devstring", "volsource", "divstring", "volnet", "bussource", "devName", "evdir", "padname", "dirname", "dirsize", "evname", "devicenames", "padnames", "DevName", "diskstring", "evnet", " devnames", "diskname", "diskpath", "dirName", "divdir", "devnames", "volname", "busline", "devicepath", "volnames", "evnames", "diskdir", "padName", "evline", "evsource", "evName", "busName", "volline", "Devnames", "devicename", "Devname", "diskName", "padnet", "dirpath", "devsize", "devpath", "disksize", "divname", "divName", "busname", "devnet", " devName", "devdir", "devicesize", "deviceName", "devsource"], "serial": ["pro", "version", "number", "mode", "usb", "phone", "proc", "security", "port", "binding", "loc", "util", "num", "bus", "sector", "description", "comment", "speed", "trans", "res", "device", "unknown", "ser", "label", "ion", "Serial", "driver"], "mediastr": ["mediestrl", "mediastrl", "mediestr", "medirastar", "mediestart", "mediestar", "medirastart", "medustar", "medirastrl", "mediustar", "mediustrl", "medastar", "medustr", "medirastr", "medustrl", "mediustart", "medustart", "medastart", "medastr", "mediastar", "medastrl", "mediastart", "mediustr"], "type": ["status", "types", "instance", "view", "ty", "Type", "by", "position", "ver", "family", "relation", "class", "role", "where", "typ", "rule", "test", "t", "ping", "kind", "title", "policy", "command", " family", " TYPE", "op", "time", "category", "parent", "info", "TYPE", "change", "all", "top", "like", "ype", "id", "state", "list", "style", "option", "format", "interface", "language", "pe", "copy"], "media": ["browser", "metadata", "position", "camera", "pi", "mode", "storage", "movie", "module", "picture", "material", "util", "video", "policy", "command", "memory", "message", "description", "meta", "category", "gallery", "magic", "library", "reader", "bridge", "image", "volume", "device", "basic", "communication", "area", "multi", "option", "style", "slave", "Media", "medi", "interface", "language", "medium", "history"], "bus_id": ["bridge_Id", "bus_mid", " bus_link", "bus_link", " bus_pid", " bus_Id", "bus2id", "busxpid", "busxname", "unit_ident", " bus_ident", "bus_ids", "bus8sid", "bus8id", "unit_mid", "busxId", " bus_sid", "bus_pid", "bus2index", "bus8name", " bus_name", "bus_name", "bus_Id", "bridge_ids", "busxident", "busxid", "bus_ident", "bus8link", "busxmid", "bridge_index", "unit_name", "bus_index", "bus2Id", "bus2ids", "bridge_id", "bus_sid"], "unit_id": ["unit_ident", " unit_name", "unit_name", "unit_uid", "unit_ref", "unit_index", "unit_ids", " unit_index", "system_ident", " unit_ref", " unit_type", "system_uid", "unit_type", "system_id", " unit_ids"], "cyls": ["cyl", "tyols", "iegs", "iel", "tyles", " cyl", "tyls", "cillers", "syl", "iesels", "sysels", "ciols", " cysels", "cyles", "syls", " cyols", " cyllers", "cysels", "ciles", " cyles", "sygs", "cyols", "cygs", "cils", "iels", " cygs", "cyllers", "tyllers"], "heads": ["uns", "relations", "roots", "owners", "offs", "outs", "head", "aches", "rows", "limits", "sticks", "headed", "hours", "olds", "masters", "cks", "HEAD", "docs", "tops", "blocks", "mins", "bots", "tails", "headers", "ads", "hops", "guards", "helps", "uploads", "links", " Heads", "locks", "aunts", "views", "reads", "sets", "loads"], "secs": ["connectls", "secls", "sectS", "seqls", "secS", "seqss", "seqs", "sectls", " secS", "secss", "connects", "seqts", " secls", "sects", " sects", "connectS", "seqS", "connectss", " secss", "sectts"], "translation": ["generation", "version", "late", "utils", "family", "relation", "tr", "rating", "conv", "lations", "binding", "padding", "util", "formation", "lang", "operation", "message", "description", "lation", "comment", "versions", "creation", "location", "trans", "rot", "alias", "communication", "heading", "transform", "selection", "direction", "ion", "transfer", "Translation", "usage", "language", "history", "normal"], "bdrv": ["bdrf", "bsrm", "bsrf", "blocksrv", "bldm", "blocksrf", "bderv", "blockdrm", "bdrm", "blockdrf", "bdrvs", "blocksrvs", "bderm", "bderf", "blockdrv", "blocksrm", "bldf", "bsrv", "bldv", "bsrvs", "bdervs", "blockdrvs", "bldvs"], "drv": ["drvs", " drp", "srvs", "frp", " drm", " drvs", "frm", "frvs", "drm", "frv", "drp", "srp", "srv", "srm"], "machine": ["vol", "instance", "proxy", "metadata", "manager", "mode", "mobi", "owner", "module", "storage", "chain", "model", "engine", "domain", "command", "Machine", "connection", "m", "mobile", " machines", "memory", "disk", "meta", "parent", "vm", "magic", "handler", "image", "link", "volume", "mc", "device", "master", "host", "state", "achine", "target", "mob", "network", "template"], "max_devs": ["max_deves", "max2evices", "max_navs", "max_veS", "max_ves", "max_devicets", "max_devS", "max_eves", "max_evts", "max_evjs", "max_Devids", "max2devs", "max_evids", "max2devS", "max_devids", "max_DevS", "max2devices", "max2evS", "max_Devices", "max_Devts", "max_vejs", "max_evS", "max_deviceids", "max_navS", "max_devjs", "max2evs", "max_evices", "max_evs", "max_Devs", "max_navices", "max_devts", "max_devices", "max_vees"], "index": ["status", "key", "instance", "error", "version", "axis", "number", "position", "address", "ind", "size", "access", "loc", "engine", "Index", "offset", "connect", "num", "connection", "lock", "context", "comment", "info", "speed", "count", "pos", "page", "link", "code", "alias", "action", "id", "order", "max", "interface", "i", "x"], "cache": ["comments", "status", "rc", "cu", "co", "version", "aches", "timeout", "cc", "check", "acc", "ache", "cover", "scan", "offset", "dirty", "lock", "comment", "ac", "buffer", "c", "count", "capacity", "code", "limit", "sync", "gc", "debug", "volume", "table", "ach", "seek", "conf", "max", "hash", "config", "option", "cycle", "Cache", "force", "sum"], "bdrv_flags": ["bdrf__flags", "bdrv__flag", "bdrv_fields", "bdrvgfields", "bdrf__status", "bdrvgstatus", "bdrf__flag", "bdrv_status", "bdrv_flag", "bdrf_fields", "bdrf_flag", "bdrv__status", "bdrv__flags", "bdrvgflags", "bdrf__fields", "bdrvgflag", "bdrf_flags", "bdrf_status", "bdrv__fields"], "onerror": ["onerlock", "error", "erlock", "asterrr", "errored", "onerrored", "asterror", "onerrr", "asterlock", "rerror", "rerrored", "rerrr", "asterrored", "rerlock", "errr"], "drives_table_idx": ["drives_table_midindex", "drives_table_indindex", "drives_table_Idxs", "drives_table_midz", "drives_table_indz", "drives_table_midxs", "drives_table_midx", "drives_table_idindex", "drives_table_Idindex", "drives_table_idxs", "drives_table_Idx", "drives_table_indxs", "drives_table_idz", "drives_table_indx", "drives_table_Idz"], "str": ["vol", "status", "Str", "inst", "def", "exec", "ptr", "out", "orig", "cur", "attr", "data", "bool", "cmd", "expr", "p", "ok", "tr", "dr", "cmp", "raw", "proc", "opt", "conv", "v", "text", "chain", "ar", "ctr", "comm", "spec", "priv", "msg", "st", "br", "desc", "cfg", "r", "obj", "s", "doc", "rs", "buffer", "sp", "comp", "res", "bc", "wr", "fr", "STR", "enc", "var", "list", "err", "name", "nick", "cont", "txt", "arr", "ps"], "params": ["types", "param", "settings", "units", "attr", "lines", "data", "flags", "values", "ctx", "cmp", "AMS", "par", "proc", "ams", "keys", "conv", "names", "v", "spec", "cap", "pins", "bars", "blocks", "json", "headers", "vals", "versions", "caps", "pos", "vs", "cp", "ops", "args", "tmp", "changes", "conf", "config", "options", "files", "name", "actions", "ps"]}}
{"project": "qemu", "commit_id": "217bfb445b54db618a30f3a39170bebd9fd9dbf2", "target": 1, "func": "static void gic_complete_irq(gic_state * s, int cpu, int irq)\n\n{\n\n    int update = 0;\n\n    int cm = 1 << cpu;\n\n    DPRINTF(\"EOI %d\\n\", irq);\n\n    if (s->running_irq[cpu] == 1023)\n\n        return; /* No active IRQ.  */\n\n    if (irq != 1023) {\n\n        /* Mark level triggered interrupts as pending if they are still\n\n           raised.  */\n\n        if (!GIC_TEST_TRIGGER(irq) && GIC_TEST_ENABLED(irq, cm)\n\n                && GIC_TEST_LEVEL(irq, cm) && (GIC_TARGET(irq) & cm) != 0) {\n\n            DPRINTF(\"Set %d pending mask %x\\n\", irq, cm);\n\n            GIC_SET_PENDING(irq, cm);\n\n            update = 1;\n\n        }\n\n    }\n\n    if (irq != s->running_irq[cpu]) {\n\n        /* Complete an IRQ that is not currently running.  */\n\n        int tmp = s->running_irq[cpu];\n\n        while (s->last_active[tmp][cpu] != 1023) {\n\n            if (s->last_active[tmp][cpu] == irq) {\n\n                s->last_active[tmp][cpu] = s->last_active[irq][cpu];\n\n                break;\n\n            }\n\n            tmp = s->last_active[tmp][cpu];\n\n        }\n\n        if (update) {\n\n            gic_update(s);\n\n        }\n\n    } else {\n\n        /* Complete the current running IRQ.  */\n\n        gic_set_running_irq(s, cpu, s->last_active[s->running_irq[cpu]][cpu]);\n\n    }\n\n}\n", "idx": 13706, "substitutes": {"s": ["comments", "ses", "aws", "gs", "S", "sw", "serv", "bs", "less", "l", "ids", "p", "js", "n", "series", "sq", "eps", "g", "sl", "details", "store", "http", "t", "comm", "is", "als", "sv", "spec", "sb", "hs", "sys", "service", "ds", "ls", "r", "services", "qs", "ssl", "ts", "self", "stats", "vs", "states", "ns", "cs", "tests", "h", "es", "ims", "set", "changes", "fs", "conf", "events", "os", "bis", "state", "its", "se", "parts", "sts", "ss", "ms", "rs", "ps"], "cpu": ["pu", "socket", "ctx", "cli", "chip", "pool", "port", "processor", "line", "context", " CPU", "client", "pid", "net", "us", "thread", "mem", "hz", "linux", "module", "css", "currency", "cat", "chrom", "nc", "cum", "sync", "gc", "cp", "device", "gpu", "prof", "cycle", "tp", "clock", "computer", "node", "server", "CPU", "phys", "cn", "proc", "pixel", "boot", "ilo", "batch", "mac", "np", "uu", "pai", "current", "ruby", "mu", "buffer", "c", "remote", "uci", "pc", "u", "process", "cu", "cm", "core", "cache", "uid", "num", "cam", "vm", "ck", "count", "base", "page", "nic", "nice", "component", "mx"], "irq": [" irqq", "ironqt", "rerqi", "fireqi", "virqueue", "irtcharge", "pirqueue", "irireq", "irqu", "iraqu", "virv", "ipqq", "iorQ", "ireq", "ferquire", "iriqueue", "pirquest", "iorqq", "pirqq", "ironq", "rirce", "virreq", "irqueue", "pirce", "irtce", "irreq", "ipqi", " irQ", "irquire", "ferreq", "nirqi", "irave", "hrqq", "irtql", "irce", "ipqu", "iraqi", "ferqi", "iriquire", "nirq", "virql", "ferq", "irece", " irqu", "warq", "pirqu", "pirv", "iorq", "warv", "iroq", "irque", " irquest", " irce", "virlock", "iraque", "ircharge", "arqu", "vircharge", "irtv", "pirq", "virquire", "fireqt", "rerqq", "virve", "ironqi", "rirql", "iroquery", "irique", "iorqu", "virqi", "virquery", "warqu", "arQ", "irve", "virq", "arq", "rerq", "irv", "pirlock", "irach", "iraquery", "irace", "iroch", "iraquest", "iraqq", "ironreq", "irtqq", "irqt", "pirqi", "mirce", "irch", "warqq", "mirquest", "hrqi", "irqq", "iriqu", "irlock", "iraq", "nirqq", "rirq", "nirce", "iriq", "virch", "mirQ", "virqt", "irequest", "fireq", "rerce", "irquery", "firereq", "irove", "arqq", "ireQ", "iriqi", "hrq", "mirq", "irql", "iriv", " irch", "hrqu", "irquest", "irtq", "rircharge", "ipq", "pirch", "irqi", "irtqu", "virce", "irav", "irilock", "pirque", "irQ"]}}
{"project": "FFmpeg", "commit_id": "ca32f7f2083f9ededd1d9964ed065e0ad07a01e0", "target": 0, "func": "static void init_dequant8_coeff_table(H264Context *h){\n\n    int i,q,x;\n\n    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly\n\n    h->dequant8_coeff[0] = h->dequant8_buffer[0];\n\n    h->dequant8_coeff[1] = h->dequant8_buffer[1];\n\n\n\n    for(i=0; i<2; i++ ){\n\n        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){\n\n            h->dequant8_coeff[1] = h->dequant8_buffer[0];\n\n            break;\n\n        }\n\n\n\n        for(q=0; q<52; q++){\n\n            int shift = div6[q];\n\n            int idx = rem6[q];\n\n            for(x=0; x<64; x++)\n\n                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =\n\n                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *\n\n                    h->pps.scaling_matrix8[i][x]) << shift;\n\n        }\n\n    }\n\n}\n", "idx": 13712, "substitutes": {"h": ["qu", "f", "sw", "ph", "kh", "handle", "hr", "l", "hz", "p", "hm", "hw", "dr", "bh", "v", "ha", "g", "http", "el", "t", "comm", "ih", "help", "cache", "hs", "php", "m", "ah", "th", "he", "env", "memory", "hi", "info", "HH", "hd", "c", "rh", "oh", "sh", "ht", "b", "ho", "H", "rec", "here", "host", "dev", "hl", "hash", "dh", "eh", "hh", "tm", "w", "history", "ch", "hp"], "i": ["ij", "index", "li", "a", "at", "ib", "f", "iu", "out", "o", "ii", "mi", "I", "pi", "ind", "ini", "j", "ei", "p", "ki", "this", "l", "si", "zi", "v", "bi", "io", "is", "ia", "ui", "di", "ami", "asi", "ai", "in", "m", "k", "hi", "xi", "qi", "sim", "info", "im", "c", "ci", "b", "id", "ti", "u", "ri", "multi", "it", "gi", "z", "phi", "init", "y", "ic", "ix", "iat", "ip"], "q": ["quit", "cu", "qu", "at", "f", "um", "query", "wx", "out", "kh", "j", "p", "sq", "req", "ql", "aq", "v", "g", "eq", "el", "le", "pt", "quest", "iq", "pp", "k", "m", "question", "qa", "qi", "ue", "qs", "que", "ck", "dq", "quick", "c", "gr", "id", "quant", "e", "u", "qv", "it", "qt", "requ", "charge", "queue", "pkg", "Q", "qual", "y", "qq", "ix", "ch", "ip"], "x": ["tx", "key", "xes", "qu", "at", "xxxx", "wx", "ax", "yx", "j", "ctx", "p", "xxx", "ex", "dr", "xxxxxxxx", "X", "xd", "v", "xs", "check", "g", "xy", "el", "pt", "t", "ox", "xp", "ch", "bo", "ext", "nz", "fx", "php", "k", "ux", "step", "xi", "ick", "c", "dx", "change", "xc", "lat", "on", "lex", "xx", "zx", "xe", "any", "e", "u", "xa", "xf", "px", "z", "rx", "pl", "xml", "xt", "y", " xx", "ey", "ix", "mx", "w"]}}
{"project": "qemu", "commit_id": "9e0ff75e5158c7dbb65ee447382bbdf4cafbef8b", "target": 1, "func": "char *vnc_display_local_addr(const char *id)\n\n{\n\n    VncDisplay *vs = vnc_display_find(id);\n\n\n\n\n    return vnc_socket_local_addr(\"%s:%s\", vs->lsock);\n\n}", "idx": 13726, "substitutes": {"id": ["def", "type", "f", "ref", "Id", "ids", "addr", "n", "kid", "aid", "rid", "uid", "mid", "end", "vid", "k", "tag", "s", "url", "info", "wid", "c", "db", "link", "no", "b", "ID", "oid", "h", "ad", "pid", "d", "init", "i", "name", "iden", "ident"], "vs": ["gs", "vl", "obs", "bs", "ves", "values", "ours", "plays", "vers", "lists", "vis", "Vs", "sv", "fits", "hs", "ls", "lights", "qs", "vm", "vals", "ts", "uds", "ils", "ins", "ns", "cs", "ims", "fs", "ks", "px", "vd", "vt", "ss", "sts", "ms", "VS", " VS", "ps"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(set_T0)\n\n{\n\n    T0 = PARAM(1);\n\n    RETURN();\n\n}\n", "idx": 13728, "substitutes": {}}
{"project": "qemu", "commit_id": "68ab47e4b4ecc1c4649362b8cc1e49794d1a6537", "target": 1, "func": "static void test_validate_fail_struct_nested(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    UserDefTwo *udp = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string0': 'string0', 'dict1': { 'string1': 'string1', 'dict2': { 'userdef1': { 'integer': 42, 'string': 'string', 'extra': [42, 23, {'foo':'bar'}] }, 'string2': 'string2'}}}\");\n\n\n\n    visit_type_UserDefTwo(v, NULL, &udp, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_UserDefTwo(udp);\n\n}\n", "idx": 13734, "substitutes": {"data": ["def", "error", "rew", "mem", "map", "window", "raw", "missing", "text", "batch", "t", "initial", "spec", "result", "bus", "da", "in", "context", "step", "json", "accept", "info", "reader", "mu", "empty", "block", "base", "Data", "ops", "device", "table", "input", "rel", "d", "DATA", "format", "ata", "zero", "dat", "join", "form"], "unused": ["untuse", "untavailable", "UNavailable", "untchecked", "unchecked", " unchecked", " unuse", "untused", "UNused", " unavailable", "UNchecked", "unavailable", "UNuse", "unuse"], "udp": ["ugper", "udpi", "ubP", "sdpa", "vdp", "udcp", "vdps", "tdpi", "sdpp", "dlp", "dlpa", "ugp", "udper", "ubp", "dlpi", "tdpa", "svpi", "ubps", "ugps", "uidpp", "udP", "udps", "vdP", "svp", "ubper", "uidps", "uidp", "vdper", "sdp", "udpp", "svcp", "tdp", "rodp", "rodps", "svpa", "rodpa", "ugP", "rodpp", "dlcp", "tdcp", "udpa", "uidpa", "sdps"], "err": ["resp", "errors", "error", "mem", "cr", "exc", "lr", "spr", "attr", "pr", "ulp", "aaa", "mr", "str", "req", "proc", "eor", "sol", "er", "msg", "priv", " terr", "sys", "Error", "r", "kr", "fee", "obj", "norm", "inv", "ec", "gr", "res", "coord", "der", "die", "Er", "fr", "urg", "e", "eas", "iter", "order", "elt", "ev", "rr", "txt", "arr"], "v": ["vv", "nv", "f", "ver", "V", "l", "j", "pr", "p", "n", "vr", "vp", "vi", "g", "t", "vis", "sv", "m", "r", "vm", "c", "cv", "vs", "ov", "b", "h", "e", "u", "it", "uv", "ve", "vc", "ev", "vt", "q", "i", "av", "w", "iv", "y"]}}
{"project": "qemu", "commit_id": "595ab64169be9063d64c3b1aa1c249fbe2662221", "target": 1, "func": "static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    ssize_t len;\n\n\n\n    do {\n\n        len = qemu_recv(s->fd, buf, size, 0);\n\n    } while (len == -1 && socket_error() == EINTR);\n\n\n\n    if (len == -1)\n\n        len = -socket_error();\n\n\n\n    return len;\n\n}\n", "idx": 13736, "substitutes": {"opaque": [" opaco", "opstain", "ploid", "OPtain", " oposer", "iopaque", "iopaco", " Opaque", "iopoid", " Optain", "opsaque", "opslay", " Oplay", "plaque", "placo", "ioposer", " opoid", "ploser", "optain", "oposer", "opoid", "opaco", "OPlay", "opsque", "opque", "OPaque", "oplay", "OPque", " Opque"], "buf": ["bytes", "bar", "vec", "mem", "bs", "data", "seq", "pb", "cmd", "p", "wb", "raw", "Buffer", "v", "batch", " buffer", "msg", "buff", "cap", "rb", "br", "doc", "fb", "que", "buffer", "block", "cb", "cv", "bf", "img", "b", "bl", "bc", "iter", "enc", "pad", "bb", "uf", "queue", "q", "bp", "ob"], "pos": ["type", "et", "Pos", "position", "o", " doc", " num", " count", " loc", " old", " clen", " index", "offset", " def", " start", "off", " ref", " os", " end", "no", " position", "start", " limit", "os", " offset"], "size": ["Size", "type", "Pos", "SIZE", "n", "si", "g", "t", "unit", "ize", "loc", "space", "cap", "end", "spec", "offset", "message", "iz", "fee", "sp", "count", "en", "since", "no", "scale", "start", "set", "os", "length", "to", " offset", "style", "z", " sizes", "name", " length", "sum"], "s": ["gs", "S", "bs", "socket", "less", "j", "l", "n", "p", "js", "sq", "v", "sam", "t", "sm", "sv", "hs", "sys", "ds", "ls", "sa", "ssl", "ts", "c", "sp", " ts", " ss", "ns", "b", "cs", "h", "fs", "ss", "i", "sts", "rs", "ps"], "len": ["vec", "fun", "ln", "lib", "val", "compl", "sl", "le", "t", "gl", "nt", "lit", "ann", " bl", " le", "lic", "en", "limit", "length", "del", "fin", " length", "li", "nl", "mem", "ret", "ptr", "lf", "ll", "ind", "n", "v", "hl", " el", "elt", "total", "resp", "ell", "Len", "seq", "dl", "offset", "al", " _", "lon", "lp", " l", "err", "ld", "bytes", "il", "l", "p", "L", "el", "gen", "fl", "ls", "off", "count", "all", "lt", "lan", "ler", "list", "z", "pl"]}}
{"project": "qemu", "commit_id": "b71706d122838d9656e1a6dae80e22401babdf37", "target": 1, "func": "static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,\n\n                                  size_t *count)\n\n{\n\n    GIOStatus status;\n\n    OVERLAPPED ov = {0};\n\n    BOOL ret;\n\n    DWORD written;\n\n\n\n    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n    ret = WriteFile(c->handle, buf, size, &written, &ov);\n\n    if (!ret) {\n\n        if (GetLastError() == ERROR_IO_PENDING) {\n\n            /* write is pending */\n\n            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);\n\n            if (!ret) {\n\n                if (!GetLastError()) {\n\n                    status = G_IO_STATUS_AGAIN;\n\n                } else {\n\n                    status = G_IO_STATUS_ERROR;\n\n\n            } else {\n\n                /* write is complete */\n\n                status = G_IO_STATUS_NORMAL;\n\n                *count = written;\n\n\n        } else {\n\n            status = G_IO_STATUS_ERROR;\n\n\n    } else {\n\n        /* write returned immediately */\n\n        status = G_IO_STATUS_NORMAL;\n\n        *count = written;\n\n\n\n\n\n\n\n\n    return status;\n", "idx": 13739, "substitutes": {"c": ["rc", "cu", "ce", "a", "cf", "f", "o", "cm", "cur", "lc", "l", "ctx", "p", "n", "cod", "cc", "cd", "v", "g", "t", "comm", "com", "dc", "cl", "k", "cam", "r", "channel", "ac", "C", "cb", "ec", "ci", "cp", "b", "mc", "cs", "bc", "h", "etc", "fc", "e", "con", "conf", "enc", "vc", "w", "ca", "cont", "can", "ch"], "buf": ["bytes", "Buff", "vec", "mem", "bs", "ref", "data", "seq", "pb", "cmd", "p", "wb", "window", "raw", "Buffer", "v", "text", "batch", "read", "msg", "buff", "cap", "rb", "br", "doc", "buffer", "block", "cb", "cv", "img", "b", "bc", "tmp", "uf", "queue", "w", "txt"], "size": ["needed", "Size", "type", "out", "data", "SIZE", "ctx", "body", "v", "g", "len", "used", "ize", "read", "cap", "now", "offset", "send", "time", "empty", " Size", "en", "code", "scale", "any", "set", "area", "seek", "length", "shape", "name", "sent", "sum"], "count": ["index", "amount", "cond", "n", "call", "created", "cc", "check", "counter", "batch", "t", "read", "ize", "cache", "ed", "write", "now", "offset", "num", "ct", "nt", "time", "ount", "comment", "current", "buffer", "event", "all", "code", "checked", "flag", "start", "found", "order", "max", "length", "list", "config", "state", "cycle", "Count", "cast", "sum"], "status": ["expr", "sequence", "stat", "cli", "check", "close", "ping", "st", "result", "new", "s", "match", "ssl", "console", "stats", "summary", "see", "wait", "error", "group", "v", "g", "sol", "spec", "read", "cat", "atus", "use", "activation", "sync", "gc", "flag", "scale", "res", "report", "set", "style", "STAT", "complete", "resp", "version", "score", "out", "enabled", "access", "source", "service", "uses", "description", "progress", "id", "active", "state", "str", "comments", "sort", "serv", "output", "success", "response", "stay", "details", "used", "msg", "title", "Status", "tag", "r", "condition", "message", "prefix", "code", "re", "reason", "list", "format", "xml", "name"], "ret": ["resp", "jp", "def", " ov", "plain", "ref", "success", " RET", "pret", "bool", "addr", "back", "j", "Ret", "tr", "stay", "rets", " returned", "RET", "reset", "v", "stat", "reg", "virtual", "try", " retained", " captured", "t", "vet", "enabled", "result", "nt", "lit", "r", "get", "alt", "true", "url", "gt", "got", "rt", "rev", "backed", "txt", "null", " continued", "RT", "std", "res", "print", "gc", "flag", "verified", "re", "mt", "entry", "elt", "err", "ne", "net", " Ret", "vt", "sat", "fin", "valid", "cont", "gov", "arr"], "written": ["bytes", "writers", " done", "wat", "drawn", "ritten", "recorded", "out", "writ", "itted", "writing", "data", "held", "n", "created", "connected", "changed", "built", "wrote", "done", "Written", " consumed", "used", "read", "len", " wrote", "ed", "write", " writer", "rote", "led", "seen", "added", " updated", "encrypted", "successful", "writer", " created", " Written", "won", "generated", "checked", " saved", "weight", "issued", " flushed", "printed", "called", "failed", " copied", "reported", "w", "needed", "sent", "finished", "played"]}}
{"project": "FFmpeg", "commit_id": "8d0a2180582005e91d9f14ae3dd219a882277c23", "target": 1, "func": "int ff_jni_exception_get_summary(JNIEnv *env, jthrowable exception, char **error, void *log_ctx)\n\n{\n\n    int ret = 0;\n\n\n\n    AVBPrint bp;\n\n\n\n    char *name = NULL;\n\n    char *message = NULL;\n\n\n\n    jclass class_class = NULL;\n\n    jmethodID get_name_id = NULL;\n\n\n\n    jclass exception_class = NULL;\n\n    jmethodID get_message_id = NULL;\n\n\n\n    jstring string;\n\n\n\n    av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC);\n\n\n\n    exception_class = (*env)->GetObjectClass(env, exception);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find Throwable class\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    class_class = (*env)->GetObjectClass(env, exception_class);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find Throwable class's class\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    get_name_id = (*env)->GetMethodID(env, class_class, \"getName\", \"()Ljava/lang/String;\");\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find method Class.getName()\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    string = (*env)->CallObjectMethod(env, exception_class, get_name_id);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Class.getName() threw an exception\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    if (string) {\n\n        name = ff_jni_jstring_to_utf_chars(env, string, log_ctx);\n\n        (*env)->DeleteLocalRef(env, string);\n\n        string = NULL;\n\n    }\n\n\n\n    get_message_id = (*env)->GetMethodID(env, exception_class, \"getMessage\", \"()Ljava/lang/String;\");\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find method java/lang/Throwable.getMessage()\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    string = (*env)->CallObjectMethod(env, exception, get_message_id);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Throwable.getMessage() threw an exception\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    if (string) {\n\n        message = ff_jni_jstring_to_utf_chars(env, string, log_ctx);\n\n        (*env)->DeleteLocalRef(env, string);\n\n        string = NULL;\n\n    }\n\n\n\n    if (name && message) {\n\n        av_bprintf(&bp, \"%s: %s\", name, message);\n\n    } else if (name && !message) {\n\n        av_bprintf(&bp, \"%s occurred\", name);\n\n    } else if (!name && message) {\n\n        av_bprintf(&bp, \"Exception: %s\", message);\n\n    } else {\n\n        av_log(log_ctx, AV_LOG_WARNING, \"Could not retreive exception name and message\\n\");\n\n        av_bprintf(&bp, \"Exception occurred\");\n\n    }\n\n\n\n    ret = av_bprint_finalize(&bp, error);\n\ndone:\n\n\n\n    av_free(name);\n\n    av_free(message);\n\n\n\n    if (class_class) {\n\n        (*env)->DeleteLocalRef(env, class_class);\n\n    }\n\n\n\n    if (exception_class) {\n\n        (*env)->DeleteLocalRef(env, exception_class);\n\n    }\n\n\n\n    if (string) {\n\n        (*env)->DeleteLocalRef(env, string);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 13740, "substitutes": {"env": ["conn", "et", "manager", "loader", "cur", "attr", "ctx", "hw", "expr", "window", "den", "end", "timer", "context", "doc", "cb", "en", "vs", "ped", "draw", "app", "qt", "net", "pkg", "gear", "forge", "usr", "exec", "gov", "def", "kw", "esm", "sw", "exc", "environment", "addr", "cmd", "erd", "v", "dt", "outer", "box", "assert", "nav", "cfg", "obj", "self", "inv", "db", "eg", "hl", "enter", "eng", "esp", "server", "vv", "nv", "impl", "nw", "req", "vp", "erb", "er", "ten", "ework", "era", "org", "stage", "cv", "ec", "wd", "dev", "iter", "config", "uv", "eh", "ev", "walker", "serv", "ect", "vert", "ent", "esc", "iev", "priv", "wt", "cap", "ef", "act", "desc", "ener", "ew", "vm", "event", "ov", "here", "e", "var", "ve", "export", "inst", "viron", "worker"], "exception": ["excception", "expaction", "exceptception", "exceptpection", "failceptor", "expection", "excpection", "interaction", "failpection", "failaction", "sexException", "exceptException", "expception", "interception", "exppection", "exceptions", "exceptceptions", "sexceptions", "sexpection", "interceptor", "sexception", "expceptor", "excException", "exaction", "exceptor", "exException", "interpection", "excceptions", "failception"], "error": ["errors", "instance", "type", "success", "address", "resource", "ror", "ception", "result", "command", "Error", "channel", "comment", "attribute", "warning", "ERROR", "change", "event", "action", "reason", "e", "order", "err", "value"], "log_ctx": ["log_pop", "base_tz", "log_lvl", "web_ctx", "log_tx", "base_cp", "baseptcp", "logloglvl", "loglogcontext", "loglogctx", "webableconn", "logpttz", " log_lvl", "base_cas", "read_ctx", "logablectx", "catmmkt", "baseptctx", "logmmhw", "log_cas", "loglogtx", "logmycas", "loggerpkg", "log2context", "loggerpop", "log_pkg", "catmmpkg", "loggercmp", "cat_hw", "log_tz", "readgercmp", "readgerctx", "readgerpkg", "logmmkt", "log_conn", " log2context", "logablecontext", "web_pop", " log_context", "log_context", "logptctx", "loglogkt", "cat_ctx", "cat_pkg", "log_desc", "logptcas", "web_conn", "baseptcas", "log_kt", "logableconn", "log_hw", "webablectx", " log2kt", "base_ctx", "logmytz", "loggerconn", "log2kt", "logmyctx", "read_desc", " log_kt", "webablecontext", " log2ctx", "logmycp", "readgerdesc", "web_context", "logmmpkg", " log2tx", "log2tx", "basepttz", "logmmctx", "read_cmp", " log_tx", "log2ctx", "loggerdesc", "webablepop", "loggercontext", "log_cmp", "catmmhw", "read_pkg", "cat_kt", "catmmctx", "loggerctx", "logablepop", "logptcp", "log_cp"], "bp": ["jp", "ba", "bs", " lb", "pb", "p", " gp", "bh", "BP", "vp", "bj", "sb", "bt", " outp", "np", "rb", "bn", " BP", " hp", " ap", "bsp", " eb", "cb", "sp", "lp", "fp", "PB", "bf", "wp", " esp", "gp", "b", "wr", "pc", "bps", "bb", "bg", "tp", "pa"], "name": ["key", "path", "type", "version", "local", "object", "data", "n", "class", "names", "filename", "text", "len", "title", "String", "part", "description", "comment", "Name", "prefix", "file", "base", "code", "alias", "action", "id", "var", "format", "ame", "NAME", "str"], "message": ["version", "member", "object", "body", "sequence", "class", "module", "reference", "filename", "text", "Message", "msg", "command", "memory", "description", "context", "comment", "console", "essage", "file", "summary", "content", "reason", "trace", "value"]}}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void vscsi_command_complete(SCSIBus *bus, int reason, uint32_t tag,\n\n                                   uint32_t arg)\n\n{\n\n    VSCSIState *s = DO_UPCAST(VSCSIState, vdev.qdev, bus->qbus.parent);\n\n    vscsi_req *req = vscsi_find_req(s, tag);\n\n    SCSIDevice *sdev;\n\n    uint8_t *buf;\n\n    int32_t res_in = 0, res_out = 0;\n\n    int len, rc = 0;\n\n\n\n    dprintf(\"VSCSI: SCSI cmd complete, r=0x%x tag=0x%x arg=0x%x, req=%p\\n\",\n\n            reason, tag, arg, req);\n\n    if (req == NULL) {\n\n        fprintf(stderr, \"VSCSI: Can't find request for tag 0x%x\\n\", tag);\n\n        return;\n\n    }\n\n    sdev = req->sdev;\n\n\n\n    if (req->sensing) {\n\n        if (reason == SCSI_REASON_DONE) {\n\n            dprintf(\"VSCSI: Sense done !\\n\");\n\n            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n            vscsi_put_req(s, req);\n\n        } else {\n\n            uint8_t *buf = sdev->info->get_buf(sdev, tag);\n\n\n\n            len = MIN(arg, SCSI_SENSE_BUF_SIZE);\n\n            dprintf(\"VSCSI: Sense data, %d bytes:\\n\", len);\n\n            dprintf(\"       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\\n\",\n\n                    buf[0], buf[1], buf[2], buf[3],\n\n                    buf[4], buf[5], buf[6], buf[7]);\n\n            dprintf(\"       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\\n\",\n\n                    buf[8], buf[9], buf[10], buf[11],\n\n                    buf[12], buf[13], buf[14], buf[15]);\n\n            memcpy(req->sense, buf, len);\n\n            req->senselen = len;\n\n            sdev->info->read_data(sdev, req->qtag);\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (reason == SCSI_REASON_DONE) {\n\n        dprintf(\"VSCSI: Command complete err=%d\\n\", arg);\n\n        if (arg == 0) {\n\n            /* We handle overflows, not underflows for normal commands,\n\n             * but hopefully nobody cares\n\n             */\n\n            if (req->writing) {\n\n                res_out = req->data_len;\n\n            } else {\n\n                res_in = req->data_len;\n\n            }\n\n            vscsi_send_rsp(s, req, 0, res_in, res_out);\n\n        } else if (arg == CHECK_CONDITION) {\n\n            dprintf(\"VSCSI: Got CHECK_CONDITION, requesting sense...\\n\");\n\n            vscsi_send_request_sense(s, req);\n\n            return;\n\n        } else {\n\n            vscsi_send_rsp(s, req, arg, 0, 0);\n\n        }\n\n        vscsi_put_req(s, req);\n\n        return;\n\n    }\n\n\n\n    /* \"arg\" is how much we have read for reads and how much we want\n\n     * to write for writes (ie, how much is to be DMA'd)\n\n     */\n\n    if (arg) {\n\n        buf = sdev->info->get_buf(sdev, tag);\n\n        rc = vscsi_srp_transfer_data(s, req, req->writing, buf, arg);\n\n    }\n\n    if (rc < 0) {\n\n        fprintf(stderr, \"VSCSI: RDMA error rc=%d!\\n\", rc);\n\n        sdev->info->cancel_io(sdev, req->qtag);\n\n        vscsi_makeup_sense(s, req, HARDWARE_ERROR, 0, 0);\n\n        vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n        vscsi_put_req(s, req);\n\n        return;\n\n    }\n\n\n\n    /* Start next chunk */\n\n    req->data_len -= rc;\n\n    if (req->writing) {\n\n        sdev->info->write_data(sdev, req->qtag);\n\n    } else {\n\n        sdev->info->read_data(sdev, req->qtag);\n\n    }\n\n}\n", "idx": 13748, "substitutes": {"bus": ["BUS", "conn", "mount", "bs", "phys", "socket", "cus", "out", "serv", "back", " BUS", "usb", "boot", "chain", "bur", "http", "box", "ass", "Bus", "bo", "is", "sys", "ux", "ud", " buses", "BS", "ck", "block", "c", "sp", "board", "b", "bc", "dev", "soc", "host", "US", " Bus", "os", "state", "us"], "reason": ["status", "type", "param", "unc", "request", "strong", "why", "cmd", "ok", "crit", "group", "call", "asons", "reg", "issue", "frame", "kind", "msg", "note", "title", "result", "command", "date", "Reason", "condition", "message", "description", "context", "none", "mark", "doc", "comment", "when", "rev", "ASON", "render", "argument", "code", "summary", "comp", "no", "flag", "report", "re", "draw", "term", "see", "state", "non", "method", "ason", "because", "cause", "zero", "name"], "tag": ["key", "error", "type", "param", "tg", "conn", "ref", "tags", "bug", "attr", "addr", "cmd", "ag", "module", "stat", "feat", "agg", "task", "reg", "test", "Tag", "field", "md", "unit", "loc", "agn", "kind", "msg", "date", "command", "num", "cat", "op", "gate", "message", "word", "doc", "lag", "match", "comment", "prefix", "TAG", "ang", "code", "debug", "flag", "oid", "pg", "id", "tick", "mt", "label", "tar", "var", "token", "target", "name", "str"], "arg": ["vol", "resp", "rc", "param", "mem", "ret", "oc", "ref", "ax", "attr", "cmd", "ag", "inc", "call", "or", "par", "pack", "proc", "val", "reg", "ar", "ig", "field", "loc", "msg", "end", "sec", "ext", "num", "op", "og", "Arg", "in", "gt", "doc", "lag", "slot", "org", "add", "count", "event", "argument", "ang", "arge", "comp", "res", "flag", "args", "ack", "pg", " larg", "urg", "enc", "max", " targ", "err", "amp", "target", "nick", "str", "rap", "arr", "arp"], "s": ["gs", "S", "sw", "as", "bs", "socket", "less", "session", "l", "j", "n", "js", "p", "ex", "sq", "v", "g", "sl", "t", "is", "sb", "sv", "st", "space", "sys", "spec", "ds", "ls", "m", "r", "ts", "self", "sp", "c", "stats", "sync", "b", "ns", "cs", "h", "es", "fs", "os", "state", "d", "z", "q", "ss", "sts", "sc", "rs", "su", "ps"], "req": ["query", "attr", "ctx", "expr", "cmp", "sq", "task", "eq", "rev", "require", "gr", "coord", "urg", "requ", "qt", "need", "rez", "pkg", "exec", "required", "qq", "ps", "tx", "rem", "rc", "def", "mem", "wx", "ind", "cmd", "j", "crit", "test", "md", "comm", "spec", "iq", "buff", "dist", "obj", "aux", "tek", "comp", "res", "dep", "conf", "eg", "supp", "txt", "resp", "rpm", "ref", "seq", "proc", "grab", "rb", "qa", "ie", "dev", "err", "quest", "rr", "rig", "jp", "request", "rss", "good", "p", "reg", "msg", "ext", "desc", "r", "prefix", "quick", "range", "dq", "parse", "decl", "rec", "var", "q", "needed"], "sdev": ["ssgu", "spay", "vdev", " sdiv", "ispay", "asconn", "asdev", "rsconn", "tsDev", "ssdevice", "svdev", "sdevice", "isserv", "sDEV", "stsdiv", "tsdev", "wsinfo", "nsserv", " sgu", "sinfo", "tsdef", "isdev", "stsdev", "vdef", "wsdev", "tsdevice", "svgu", "isconn", "nsDev", "ssdev", "wsdiv", "aspay", " sDev", "svdevice", "rsserv", "Sserv", "vdevice", "ssDEV", " sdevice", "nsdef", "stsDEV", "sdiv", "sserv", "sdef", "Sdef", "rspay", "Sdev", "SDev", "vDev", "asserv", "rsdev", " sdef", " sDEV", "sDev", "sgu", "wsdevice", "sconn", "nsdev", "ssdef", " sserv", " sinfo"], "buf": ["vec", "bs", "cur", "fun", "ctx", "raw", "agg", "val", "pool", "loc", "doc", "cb", "fac", "foo", "emb", "uf", "queue", "bg", "pkg", "zero", "lim", "arr", "pack", "def", "mem", "ff", "data", "cmd", "map", "Buffer", "conv", "v", "fam", "box", "buff", "br", "obj", "aux", "fb", "que", "burst", "tmp", "mb", "txt", "Buff", "ref", "seq", " vec", "batch", "np", "rb", "buffer", "block", "cv", "ec", "bc", "bed", "iter", "err", "str", "bytes", "good", "grad", "begin", "deg", "gen", "msg", "cap", "bin", "ext", "func", "act", "cam", "off", "img", "b", "bl", "var", "pad", "prop", "w", "nm"], "len": ["resp", "bytes", "nl", "vec", "mem", "ret", "lf", "ref", "Len", "ll", "size", "l", "fun", "fin", "n", "ln", "seq", "cmp", "lib", "str", "lc", "L", "val", "el", " clen", "la", "loc", "fl", "num", "ls", "nt", "lit", " mem", "lon", " bl", "sp", " le", "lp", "pos", "en", "fn", " l", "lan", "un", "length", " el", "elt", "gz", "err", "lim", "coll", " length", "ld", " Len"]}}
{"project": "qemu", "commit_id": "7d6250e3d1a145e5427f21f5664995e0056b34a6", "target": 0, "func": "void helper_store_sdr1(CPUPPCState *env, target_ulong val)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n\n\n    if (!env->external_htab) {\n\n        if (env->spr[SPR_SDR1] != val) {\n\n            ppc_store_sdr1(env, val);\n\n            tlb_flush(CPU(cpu));\n\n        }\n\n    }\n\n}\n", "idx": 13754, "substitutes": {"env": ["node", "server", "nv", "vv", "conn", "et", "serv", "sw", "query", "environment", "cur", "cmd", "ctx", "hw", "cb", "window", "erd", "proc", "v", "el", "store", "esc", "er", "engine", "buf", "end", "ext", "desc", "ew", "ah", "context", "obj", "doc", "sc", "sp", "chart", "cv", "event", "db", "en", "nc", "ec", "txt", "vs", "dev", "here", "e", "conf", "enc", "eg", "entry", "enter", "emb", "eng", "ve", "qt", "ev", "vt", "gear", "w", "init", "esp", "te", "viron", "gov", "worker"], "val": ["vol", "tx", "index", " arg", "status", " value", "Val", "key", " Val", "serv", "ref", "local", "V", "bool", "data", "ctx", "pol", "lib", "hal", "fail", "v", "test", "xy", " aval", "el", "sol", "unit", "pt", "util", "eval", "buf", "VALUE", "num", "Value", "slot", "vals", "resp", " eval", "pal", "empty", "sel", "pri", " vel", " v", "dev", " VAL", "VAL", "AL", "state", "it", "elt", "prop", "err", "px", "value", "vt", "qual", "valid"], "cpu": ["cu", "pu", "CPU", "mem", "phys", "alloc", "cn", "hz", "core", "hw", "ctx", "proc", "pool", "clock", " proc", "processor", "cam", "bench", "ork", "uu", "ck", "mu", "cal", "cum", "gc", "cp", "nic", "CU", "pc", "nice", " cp", "pid", "gpu", "prof", "px", "tp", "process", "nu", "ka"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size, bool is_write)\n\n{\n\n    return (size == 1) || (is_write && size == 2);\n\n}\n", "idx": 13768, "substitutes": {"opaque": ["och", "ocaque", "oclay", " opc", "oph", " oph", "occ", "opc", "openh", " oplay", "oplay", "openc", "openlay", "openaque"], "addr": ["index", "key", "ptr", "src", "ref", "handle", "attr", "address", "ctx", "dr", "kt", "loc", "cap", "br", "eth", "obj", "add", "info", "coord", "start", "ad", "var", "hash", "dh", "name", "ld", "alloc"], "size": ["bytes", "Size", "type", "mem", "settings", "number", "position", "address", "SIZE", "scope", "n", "body", "storage", "sized", "height", "len", "ize", "padding", "cache", "space", "offset", "num", "align", "message", "fee", "sha", "slot", "dim", "empty", "buffer", "count", "capacity", "sh", "scale", "grow", "equal", "area", "e", "weight", "length", "shape", "style", "small", "zero", "news", "name", "too", "sum"], "is_write": [" is_lock", " is_only", "is_writer", " is_close", "is_read", " is_read", "is_lock", " is_writer", "is_close", "is_only"]}}
{"project": "qemu", "commit_id": "6a81dd172cd5d03fce593741629cb4c78fff10cb", "target": 0, "func": "sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn,\n\n                                   uint64_t bus_offset,\n\n                                   uint32_t page_shift,\n\n                                   uint32_t nb_table,\n\n                                   bool vfio_accel)\n\n{\n\n    sPAPRTCETable *tcet;\n\n    char tmp[64];\n\n\n\n    if (spapr_tce_find_by_liobn(liobn)) {\n\n        fprintf(stderr, \"Attempted to create TCE table with duplicate\"\n\n                \" LIOBN 0x%x\\n\", liobn);\n\n        return NULL;\n\n    }\n\n\n\n    if (!nb_table) {\n\n        return NULL;\n\n    }\n\n\n\n    tcet = SPAPR_TCE_TABLE(object_new(TYPE_SPAPR_TCE_TABLE));\n\n    tcet->liobn = liobn;\n\n    tcet->bus_offset = bus_offset;\n\n    tcet->page_shift = page_shift;\n\n    tcet->nb_table = nb_table;\n\n    tcet->vfio_accel = vfio_accel;\n\n\n\n    snprintf(tmp, sizeof(tmp), \"tce-table-%x\", liobn);\n\n    object_property_add_child(OBJECT(owner), tmp, OBJECT(tcet), NULL);\n\n\n\n    object_property_set_bool(OBJECT(tcet), true, \"realized\", NULL);\n\n\n\n    return tcet;\n\n}\n", "idx": 13772, "substitutes": {"owner": ["server", "instance", "username", "peer", "owners", "member", "office", "size", "Owner", "OWN", "hw", "older", "group", "share", "window", "owned", "cc", "user", "er", "uid", "independent", "holder", " Owner", "lease", "parent", "org", "handler", "shared", "link", "own", "root", " ownership", "inner", "pty", "component", "slave", " owns", "driver"], "liobn": ["libown", "lioydn", "liocken", "liobbN", "libsn", "lioben", "flubowne", "blobcn", "libdn", "iliombn", "bloben", "liobne", "lirobn", "libcn", " liorgdn", "liOBon", " liobdn", "ilirobn", "liobarner", "liobercn", "fluobne", "liobdn", "liobyna", "liobynt", "blobycn", "lioconN", "lioyn", "liobsne", "liobna", "liobbgn", "lioysn", "ilirobon", "iliobon", "iliobnum", "blobn", "fluobN", "liorgen", " liobgn", "liobbna", "liobgn", "lirobN", "liobyn", "liobon", "flubowr", "liobnt", "liobaren", "ilirobN", "liobernt", "liorgn", "luobbna", "liobbrn", "lioconon", "liombdn", "iliombsn", "liobyner", "liobyrn", "liobbr", "liorgdn", "liockdn", " lioben", "liobner", "flubowN", "blobyn", "lirobnum", "iliobN", "liobrn", " liorgen", "lioycn", "lioberner", "liobyen", "liobycn", "ilirobnum", "iliombdn", "liOBnum", "liobarn", "liobbnt", "liOBN", "liockn", "iliobsn", "iliobn", "libowne", "liobbne", "lioconn", "lioconnum", "luobn", "liombn", "liobN", "libn", "luobbrn", "blobyen", "lirobon", "liombcn", "liobr", "lioberen", "lioberna", "iliombcn", "luobna", "liobern", "lioberrn", "fluobn", "liombsn", "liobsN", "liobben", "liorggn", "fluobr", "iliobcn", "liobbdn", "liobarcn", "luobrn", "flubown", "luobbnt", "liockgn", "blobner", " liorggn", "liobbn", "liobcn", "liobsn", "liOBn", "luobnt", "liobsr", "liobnum", "luobbn", "libowr", "blobyner", " liorgn", "libowN", "iliobdn"], "bus_offset": ["bus_connection", "bus___offset", "bus_off", "busipoffset", "buslloffset", "aseipoff", "busllshift", "bus_prefix", "bus2shift", "bus___position", "aseipoffset", "bus2off", "socket_position", "ase_offset", "ase_shift", "aseipshift", "boot_offset", "bus2slot", "bus_open", "boot_owner", "busipoff", "busllowner", "aseipslot", "bus_position", "busityowner", "boot_prefix", "ase_slot", "socket_connection", "busllprefix", "busipshift", "bus_owner", "bus_slot", "ase_off", "busityshift", "socket_offset", "busityprefix", "boot_shift", "bus___open", "socket_open", "busipslot", "busityoffset", "bus___connection", "bus_shift", "bus2offset"], "page_shift": ["menuingshift", "pageedcount", "pageedhead", "page_offset", "bus_count", "menu_size", "pageswsize", "age_shift", "pagelydist", "pageswshift", "pageedsize", "menuingslice", "busswcount", "page_dist", "busswcommand", "busswsize", "menu_slice", "page_size", "menuingsize", "pageedshift", "page_slice", "menuinghead", "pagelyshift", "pageingshift", "page_count", "pageswcount", "page_command", "age_default", "bus_size", "pageedcommand", "pageswcommand", "age_dist", "pagelydefault", "pageingsize", "busswshift", "menu_head", "pageinghead", "pageedslice", "page_head", "pagelyoffset", "pageingslice", "page_default", "bus_shift", "menu_shift", "age_offset", "bus_command"], "nb_table": ["inv___table", "nb___table", "nbablerequired", "nbablepage", "np_TABLE", "nbjtable", "nb___tab", "nbmytable", "inv___tab", "nb_scope", "inv_stable", "nb_server", "nb_index", "inv_tab", "nbmyrequired", "nb2table", "nb_binary", "nbPcontainer", "nvmyindex", "nvmypage", "inv_total", "inv___stable", "nbjcontainer", "nbPserver", "nbabletable", "nbpttable", "nb2binary", "nb_TABLE", "nv_page", "nt_server", "nbPtable", "nb_tab", "nb2TABLE", "nbptindex", "inv_table", "nbjserver", "nvmytable", "nb_stable", "np_tab", "nt___table", "nt_scope", "nt___server", "nbptpage", "nb___scope", "nb_page", "nt_container", "nbableindex", "nvmyrequired", "nv_table", "np_binary", "nb_total", "nbptrequired", "nbmyindex", "nt_table", "np_table", "nb_required", "nv_index", "nb2tab", "nb___server", "nb_container", "nbPscope", "nt___container", "nb___stable", "nbjscope", "nt___scope", "nb___container", "nbmypage", "inv___total", "nb___total", "nv_required"], "vfio_accel": ["vfio_cceler", "vfio_accl", "vfio_acccel", "vfio_ccl", "vfio_faccel", "vfio_accce", "vfio_acscel", "vfio_acel", "vfio_acsl", "vfio_acscl", "vfio_facceler", "vfio_acccl", "vfio_accceler", "vfio_acsel", "vfio_cl", "vfio_acsceler", "vfio_acceler", "vfio_acccompl", "vfio_maccompl", "vfio_faccompl", "vfio_ccel", "vfio_cel", "vfio_maccel", "vfio_acl", "vfio_accompl", "vfio_macceler", "vfio_acce", "vfio_facce", "vfio_macce"], "tcet": ["cacheet", " tcetter", " tcET", "tkett", "cciemet", "rcET", "cuee", "TChet", " tcect", "tcreset", "ecect", "ticET", "TCdat", "TCbet", " tcate", "timemet", "tkate", "lcET", "mcet", "tcemet", "tcect", "currencyett", " tcpet", "ecate", "tcel", "TCiet", "lcet", "ticot", "cuset", "timET", " tcee", "racET", "tocet", "racemet", "tcee", "TCound", "TCpet", "currencyound", "racett", "tcET", " tcbet", "tcound", "tcetter", "uscbet", "lcets", "TCot", "tcset", "TCET", " tcset", "ascound", " tcot", "tket", "ticett", "tocett", "uscpet", "mcpet", "rcets", "cacheset", " tcel", "TCel", "timet", "rchet", "racdat", "cciett", "lchet", "TCet", "currencyET", "ascet", "TCemet", "ticdat", "TCets", "tcdat", "ticet", "cacheee", "tchet", "racet", "tkect", "mciet", "ecett", "tcpet", "tocreset", "cacheetter", "racreset", "uscel", "currencyet", " tciet", "cciet", "timett", "tocemet", "tcett", "uscet", "tcbet", "ascET", "ascemet", "cuetter", "TCett", "ecet", "rcet", "tciet", "tcate", "cuet", "ascreset", "tcot", "mcET", "ascett", "tcets", " tcett", "cciET"], "tmp": ["csv", "resp", "td", "ptr", "local", "out", "rw", "src", "attr", "data", "pb", "ctx", "tt", "aaa", "cmd", "cmp", "params", "temp", "vp", "mk", "v", "xs", "perm", "test", "sam", "t", "bt", "msg", "buff", "buf", "np", "new", "rb", "space", "cache", "nt", "m", "qq", "snap", "obj", "extra", "html", "empty", "cb", "sp", "buffer", "tf", "cv", "img", "cp", "mp", "etc", "cont", "pad", "nb", "mb", "uv", "err", "zip", "tm", "tp", "MP", "tab", "txt", "sample"]}}
{"project": "qemu", "commit_id": "192cf55cc02dc0838bbfa5ac17feb7f6c1651441", "target": 1, "func": "static void debug_print_fis(uint8_t *fis, int cmd_len)\n\n{\n\n#ifdef DEBUG_AHCI\n\n    int i;\n\n\n\n    fprintf(stderr, \"fis:\");\n\n    for (i = 0; i < cmd_len; i++) {\n\n        if ((i & 0xf) == 0) {\n\n            fprintf(stderr, \"\\n%02x:\",i);\n\n        }\n\n        fprintf(stderr, \"%02x \",fis[i]);\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n#endif\n\n}\n", "idx": 13784, "substitutes": {"fis": ["fIS", "dfIS", "fisi", "vIS", "vois", "dfois", "sfIs", "xfis", "sfis", "vis", "fIs", " fIS", "dfIs", " fisi", "sfois", "sfIS", "vIs", "xfois", "fois", "dfisi", "xfisi", "xfIS", "dfis", " fois"], "cmd_len": ["cmd_Len", " cmd_del", "cmd_length", " cmd_den", " cmd_Len", "cmd2length", "cmd2del", "cmd_del", "cmd_den", " cmd_length", "cmd2len"], "i": ["status", "index", "ij", "li", "ogi", "iu", "number", "o", "oi", "ii", "mi", "I", "pi", " j", "ini", "j", "ind", "n", " di", "ki", "ei", "si", "zi", "uri", "p", "vi", " ti", "cli", "g", "bi", "batch", "t", "us", "ui", "iq", "is", "di", "ami", " ii", "num", "ai", "m", "in", "hi", "xi", "qi", " bi", "sim", "im", "\u0438", "ci", "client", "ims", "Ti", "id", "ti", "ri", " x", "multi", "gi", "it", "to", "ji", "phi", "init", "x", "y", "ic", "ix", "ip"]}}
{"project": "FFmpeg", "commit_id": "be00ec832c519427cd92218abac77dafdc1d5487", "target": 0, "func": "static av_cold int svc_encode_init(AVCodecContext *avctx)\n\n{\n\n    SVCContext *s = avctx->priv_data;\n\n    SEncParamExt param = { 0 };\n\n    int err = AVERROR_UNKNOWN;\n\n    int log_level;\n\n    WelsTraceCallback callback_function;\n\n    AVCPBProperties *props;\n\n\n\n    // Mingw GCC < 4.7 on x86_32 uses an incorrect/buggy ABI for the WelsGetCodecVersion\n\n    // function (for functions returning larger structs), thus skip the check in those\n\n    // configurations.\n\n#if !defined(_WIN32) || !defined(__GNUC__) || !ARCH_X86_32 || AV_GCC_VERSION_AT_LEAST(4, 7)\n\n    OpenH264Version libver = WelsGetCodecVersion();\n\n    if (memcmp(&libver, &g_stCodecVersion, sizeof(libver))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Incorrect library version loaded\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n#endif\n\n\n\n    if (WelsCreateSVCEncoder(&s->encoder)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to create encoder\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    // Pass all libopenh264 messages to our callback, to allow ourselves to filter them.\n\n    log_level = WELS_LOG_DETAIL;\n\n    (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_LEVEL, &log_level);\n\n\n\n    // Set the logging callback function to one that uses av_log() (see implementation above).\n\n    callback_function = (WelsTraceCallback) libopenh264_trace_callback;\n\n    (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_CALLBACK, (void *)&callback_function);\n\n\n\n    // Set the AVCodecContext as the libopenh264 callback context so that it can be passed to av_log().\n\n    (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_CALLBACK_CONTEXT, (void *)&avctx);\n\n\n\n    (*s->encoder)->GetDefaultParams(s->encoder, &param);\n\n\n\n    param.fMaxFrameRate              = avctx->time_base.den / avctx->time_base.num;\n\n    param.iPicWidth                  = avctx->width;\n\n    param.iPicHeight                 = avctx->height;\n\n    param.iTargetBitrate             = avctx->bit_rate;\n\n    param.iMaxBitrate                = FFMAX(avctx->rc_max_rate, avctx->bit_rate);\n\n    param.iRCMode                    = RC_QUALITY_MODE;\n\n    param.iTemporalLayerNum          = 1;\n\n    param.iSpatialLayerNum           = 1;\n\n    param.bEnableDenoise             = 0;\n\n    param.bEnableBackgroundDetection = 1;\n\n    param.bEnableAdaptiveQuant       = 1;\n\n    param.bEnableFrameSkip           = s->skip_frames;\n\n    param.bEnableLongTermReference   = 0;\n\n    param.iLtrMarkPeriod             = 30;\n\n    param.uiIntraPeriod              = avctx->gop_size;\n\n#if OPENH264_VER_AT_LEAST(1, 4)\n\n    param.eSpsPpsIdStrategy          = CONSTANT_ID;\n\n#else\n\n    param.bEnableSpsPpsIdAddition    = 0;\n\n#endif\n\n    param.bPrefixNalAddingCtrl       = 0;\n\n    param.iLoopFilterDisableIdc      = !s->loopfilter;\n\n    param.iEntropyCodingModeFlag     = 0;\n\n    param.iMultipleThreadIdc         = avctx->thread_count;\n\n    if (s->profile && !strcmp(s->profile, \"main\"))\n\n        param.iEntropyCodingModeFlag = 1;\n\n    else if (!s->profile && avctx->coder_type == FF_CODER_TYPE_AC)\n\n        param.iEntropyCodingModeFlag = 1;\n\n\n\n    param.sSpatialLayers[0].iVideoWidth         = param.iPicWidth;\n\n    param.sSpatialLayers[0].iVideoHeight        = param.iPicHeight;\n\n    param.sSpatialLayers[0].fFrameRate          = param.fMaxFrameRate;\n\n    param.sSpatialLayers[0].iSpatialBitrate     = param.iTargetBitrate;\n\n    param.sSpatialLayers[0].iMaxSpatialBitrate  = param.iMaxBitrate;\n\n\n\n    if ((avctx->slices > 1) && (s->max_nal_size)){\n\n        av_log(avctx,AV_LOG_ERROR,\"Invalid combination -slices %d and -max_nal_size %d.\\n\",avctx->slices,s->max_nal_size);\n\n        goto fail;\n\n    }\n\n\n\n    if (avctx->slices > 1)\n\n        s->slice_mode = SM_FIXEDSLCNUM_SLICE;\n\n\n\n    if (s->max_nal_size)\n\n        s->slice_mode = SM_DYN_SLICE;\n\n\n\n    param.sSpatialLayers[0].sSliceCfg.uiSliceMode               = s->slice_mode;\n\n    param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceNum = avctx->slices;\n\n\n\n    if (s->slice_mode == SM_DYN_SLICE) {\n\n        if (s->max_nal_size){\n\n            param.uiMaxNalSize = s->max_nal_size;\n\n            param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = s->max_nal_size;\n\n        } else {\n\n            if (avctx->rtp_payload_size) {\n\n                av_log(avctx,AV_LOG_DEBUG,\"Using RTP Payload size for uiMaxNalSize\");\n\n                param.uiMaxNalSize = avctx->rtp_payload_size;\n\n                param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = avctx->rtp_payload_size;\n\n            } else {\n\n                av_log(avctx,AV_LOG_ERROR,\"Invalid -max_nal_size, specify a valid max_nal_size to use -slice_mode dyn\\n\");\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((*s->encoder)->InitializeExt(s->encoder, &param) != cmResultSuccess) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Initialize failed\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {\n\n        SFrameBSInfo fbi = { 0 };\n\n        int i, size = 0;\n\n        (*s->encoder)->EncodeParameterSets(s->encoder, &fbi);\n\n        for (i = 0; i < fbi.sLayerInfo[0].iNalCount; i++)\n\n            size += fbi.sLayerInfo[0].pNalLengthInByte[i];\n\n        avctx->extradata = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!avctx->extradata) {\n\n            err = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        avctx->extradata_size = size;\n\n        memcpy(avctx->extradata, fbi.sLayerInfo[0].pBsBuf, size);\n\n    }\n\n\n\n    props = ff_add_cpb_side_data(avctx);\n\n    if (!props) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    props->max_bitrate = param.iMaxBitrate;\n\n    props->avg_bitrate = param.iTargetBitrate;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    svc_encode_close(avctx);\n\n    return err;\n\n}\n", "idx": 13809, "substitutes": {"avctx": ["avtx", "avercmd", "navcp", "avmsg", "abobj", "navctx", "avercontext", "avtmp", "aujac", "abcontext", "avpy", "auctl", "ajreq", "abconf", "avcpu", "avertx", "avercmp", " avcontext", "avtc", " avcu", "varnp", "svctx", "invctx", "navcmd", "avermsg", "avedt", "varreq", "averkl", "avdt", " avsys", "avcmp", "varobj", "AVcontext", "avsys", "avkl", "avercpu", "auctx", "varctx", "navkl", "averreq", "ajmsg", "avecontext", "ajcu", "averkb", "svcontext", "AVconf", "ajobj", "averctl", " avcmp", "ajtmp", "abctx", "averpy", "aversys", "avernp", "ajsys", " avpy", "avertmp", "ajcpu", "ajdt", "avcu", "AVobj", "avecu", "AVctx", " avtc", "ajcontext", "avekl", "aveconf", "averdt", "avecmd", "avcp", "avecp", "svtx", "averctx", " avkb", "avreq", "ajtc", "avcmd", "avconf", " avjac", "avconn", "varcu", "varsys", "avercu", "avejac", "aveconn", "invcu", "invjac", "avnp", "avjac", "avectl", "avobj", "avctl", "varcpu", "invcontext", "avenp", "avcontext", "avkb", " avmsg", "aveobj", "avesys", "ajctx", "aucu", "ajconn", "AVcmp", "AVpy", " avtx", "averconn", "svkb", "avectx", "averobj", "avetc", "avercp", " avtmp", "averjac"], "s": ["ses", "aws", "gs", "a", "S", "sw", "f", "as", "bs", "less", "l", "ctx", "p", "js", "n", "sq", "v", "g", "ms", "ar", "sam", "t", "comm", "spec", "sb", "is", "sv", "als", "sys", "hs", "ds", "ls", "ats", "m", "y", "ies", "qs", "ts", "self", "c", "vs", "ns", "b", "cs", "h", "es", "pers", "set", "fs", "os", "its", "sports", "w", "ss", "sc", "sts", "rs", "ps"], "log_level": ["tool_message", "log_function", "log_type", "log_mode", "logLvel", "log___function", "log_message", "logLlevel", "tool_vel", "log___type", "LOG_local", " log_type", "tool_function", "log___level", " log_function", " log_mode", "log_vel", "loginglevel", "loginglocal", "log_local", "LOG_level", "logingoperator", "tool_level", "LOG_operator", "logLoperator", "LOG_vel", "log___mode", "logingvel", "logLlocal", "log_operator"], "callback_function": ["callback_functional", "callback_address", "back_function", "back_Function", "callbacklyfunc", "callback_factor", "callbacklycolumn", "callbackzcolumn", "callback_column", "callbackzfunc", "filter_address", "callbacklyfactor", " callback_column", "filter_func", "callback_closure", "back_closure", "filter_functional", "filter_function", "callbackzfactor", "callback_Function", "callbacklyfunction", "callback_func", "callbacklyaddress", "callbacklyfunctional", " callback_func", "callbackzfunction", " callback_factor"], "props": ["Properties", "prgs", "prps", "procs", "Props", "prcs", "prperties", "parperties", "parps", "pargs", "parcs", "Progs", "Procs", "properties", "progs"]}}
{"project": "qemu", "commit_id": "6a2a5aae02b9a0b53807b9ad91f15cd4988781f9", "target": 0, "func": "static void sm501_disp_ctrl_write(void *opaque, hwaddr addr,\n\n                                  uint64_t value, unsigned size)\n\n{\n\n    SM501State *s = (SM501State *)opaque;\n\n    SM501_DPRINTF(\"sm501 disp ctrl regs : write addr=%x, val=%x\\n\",\n\n                  (unsigned)addr, (unsigned)value);\n\n\n\n    switch (addr) {\n\n    case SM501_DC_PANEL_CONTROL:\n\n        s->dc_panel_control = value & 0x0FFF73FF;\n\n        break;\n\n    case SM501_DC_PANEL_PANNING_CONTROL:\n\n        s->dc_panel_panning_control = value & 0xFF3FFF3F;\n\n        break;\n\n    case SM501_DC_PANEL_FB_ADDR:\n\n        s->dc_panel_fb_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_PANEL_FB_OFFSET:\n\n        s->dc_panel_fb_offset = value & 0x3FF03FF0;\n\n        break;\n\n    case SM501_DC_PANEL_FB_WIDTH:\n\n        s->dc_panel_fb_width = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_FB_HEIGHT:\n\n        s->dc_panel_fb_height = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_TL_LOC:\n\n        s->dc_panel_tl_location = value & 0x07FF07FF;\n\n        break;\n\n    case SM501_DC_PANEL_BR_LOC:\n\n        s->dc_panel_br_location = value & 0x07FF07FF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_H_TOT:\n\n        s->dc_panel_h_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_H_SYNC:\n\n        s->dc_panel_h_sync = value & 0x00FF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_V_TOT:\n\n        s->dc_panel_v_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_V_SYNC:\n\n        s->dc_panel_v_sync = value & 0x003F0FFF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_HWC_ADDR:\n\n        s->dc_panel_hwc_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_LOC:\n\n        s->dc_panel_hwc_location = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_COLOR_1_2:\n\n        s->dc_panel_hwc_color_1_2 = value;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_COLOR_3:\n\n        s->dc_panel_hwc_color_3 = value & 0x0000FFFF;\n\n        break;\n\n\n\n    case SM501_DC_CRT_CONTROL:\n\n        s->dc_crt_control = value & 0x0003FFFF;\n\n        break;\n\n    case SM501_DC_CRT_FB_ADDR:\n\n        s->dc_crt_fb_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_CRT_FB_OFFSET:\n\n        s->dc_crt_fb_offset = value & 0x3FF03FF0;\n\n        break;\n\n    case SM501_DC_CRT_H_TOT:\n\n        s->dc_crt_h_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_H_SYNC:\n\n        s->dc_crt_h_sync = value & 0x00FF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_V_TOT:\n\n        s->dc_crt_v_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_V_SYNC:\n\n        s->dc_crt_v_sync = value & 0x003F0FFF;\n\n        break;\n\n\n\n    case SM501_DC_CRT_HWC_ADDR:\n\n        s->dc_crt_hwc_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_CRT_HWC_LOC:\n\n        s->dc_crt_hwc_location = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_HWC_COLOR_1_2:\n\n        s->dc_crt_hwc_color_1_2 = value;\n\n        break;\n\n    case SM501_DC_CRT_HWC_COLOR_3:\n\n        s->dc_crt_hwc_color_3 = value & 0x0000FFFF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_PALETTE ... SM501_DC_PANEL_PALETTE + 0x400 * 3 - 4:\n\n        sm501_palette_write(opaque, addr - SM501_DC_PANEL_PALETTE, value);\n\n        break;\n\n\n\n    default:\n\n        printf(\"sm501 disp ctrl : not implemented register write.\"\n\n               \" addr=%x, val=%x\\n\", (int)addr, (unsigned)value);\n\n        abort();\n\n    }\n\n}\n", "idx": 13829, "substitutes": {"opaque": ["opient", " opaques", " oposit", "iopaque", "Oposit", "opacity", "ioposit", " opacity", " opque", "Opient", "Opaque", "opsaque", " oponymous", "operaque", "operonymous", "opaques", "iopient", "opsaques", "oposit", "Opque", " opient", "opsacity", "oponymous", "iopque", "opque", "operacity", "operaques", "opsonymous"], "addr": ["index", "rc", "mem", "ptr", "src", "ref", "handle", "asm", "address", "attr", "cmd", "ctx", "hw", "cmp", "ident", "name", "adr", "field", "mac", "offset", "align", "act", "r", "eth", "att", "url", "obj", "hop", "add", "prefix", "work", "info", "inv", "pos", "link", "bind", "coord", "alias", "ack", "dev", "id", "ad", "host", "seek", "pad", "hash", "var", " address", "err", "init", "rs", "ix", "alloc", "Address", "ip"], "value": ["index", "sequence", "raw", "operator", "val", "field", "new", "select", "fee", "word", "attribute", "function", "property", "vector", "label", "see", " Value", "length", "trace", "type", "number", "address", "data", "v", "test", "padding", "Value", "get", "memory", "ue", "comment", "hello", "python", "example", "input", "set", "element", "total", "server", "key", "reference", "vp", "widget", "unit", "now", "description", "json", "current", "info", "buffer", "block", "variable", "state", "weight", "option", "package", "status", "go", "values", "done", "feature", "VALUE", "message", "range", "image", "all", "byte", "create", "code", "content", "list", "format", "name", "expression"], "size": ["Size", "type", "mem", "address", "data", "SIZE", " count", " si", "field", "len", "ize", "cap", "fee", "count", "password", "code", " sock", "action", "set", " len", "state", "length", "weight", "name", "sum"], "s": ["sis", "ses", "aws", "status", "gs", "S", "bs", "ports", "j", "n", "js", "p", "sq", "sl", "details", "ms", "sol", "t", "comm", "is", "sv", "sb", "sm", "spec", "sys", "hs", "service", "ds", "ats", "ls", "m", "obj", "services", "ies", "ssl", "qs", "ips", "ts", "sp", "stats", "vs", "ins", "states", "ns", "cs", "ims", "pers", "es", "set", "changes", "fs", "os", "bis", "sn", "ss", "sts", "sports", "y", "properties", "rs", "ps"]}}
{"project": "FFmpeg", "commit_id": "9b2c28e6edbb43e00e0b2d99b95567189cd46e91", "target": 0, "func": "void rgb15to16(const uint8_t *src,uint8_t *dst,uint32_t src_size)\n\n{\n\n#ifdef HAVE_MMX\n\n  register const char* s=src+src_size;\n\n  register char* d=dst+src_size;\n\n  register int offs=-src_size;\n\n  __asm __volatile(PREFETCH\"\t%0\"::\"m\"(*(s+offs)):\"memory\");\n\n  __asm __volatile(\n\n\t\"movq\t%0, %%mm4\\n\\t\"\n\n\t\"movq\t%1, %%mm5\"\n\n\t::\"m\"(mask15b), \"m\"(mask15rg):\"memory\");\n\n  while(offs<0)\n\n  {\n\n\t__asm __volatile(\n\n\t\tPREFETCH\"\t32%1\\n\\t\"\n\n\t\t\"movq\t%1, %%mm0\\n\\t\"\n\n\t\t\"movq\t8%1, %%mm2\\n\\t\"\n\n\t\t\"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t\t\"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t\t\"pand\t%%mm4, %%mm0\\n\\t\"\n\n\t\t\"pand\t%%mm5, %%mm1\\n\\t\"\n\n\t\t\"pand\t%%mm4, %%mm2\\n\\t\"\n\n\t\t\"pand\t%%mm5, %%mm3\\n\\t\"\n\n\t\t\"psllq\t$1, %%mm1\\n\\t\"\n\n\t\t\"psllq\t$1, %%mm3\\n\\t\"\n\n\t\t\"por\t%%mm1, %%mm0\\n\\t\"\n\n\t\t\"por\t%%mm3, %%mm2\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 8%0\"\n\n\t\t:\"=m\"(*(d+offs))\n\n\t\t:\"m\"(*(s+offs))\n\n\t\t:\"memory\");\n\n\toffs+=16;\n\n  }\n\n  __asm __volatile(SFENCE:::\"memory\");\n\n  __asm __volatile(EMMS:::\"memory\");\n\n#else\n\n   const uint16_t *s1=( uint16_t * )src;\n\n   uint16_t *d1=( uint16_t * )dst;\n\n   uint16_t *e=((uint8_t *)s1)+src_size;\n\n   while( s1<e ){\n\n     register int x=*( s1++ );\n\n     /* rrrrrggggggbbbbb\n\n        0rrrrrgggggbbbbb\n\n        0111 1111 1110 0000=0x7FE0\n\n        00000000000001 1111=0x001F */\n\n     *( d1++ )=( x&0x001F )|( ( x&0x7FE0 )<<1 );\n\n   }\n\n#endif\n\n}\n", "idx": 13855, "substitutes": {"src": ["rc", "gs", "bs", "sur", "rl", "ipl", "syn", "source", "sb", "loc", "st", "sys", "bin", "ur", "scan", "rb", "usc", "ls", "r", "txt", "sel", "dest", "sr", "img", "std", "ins", "b", "ser", "input", "rob", "hl", "rx", "iv", "sn", "sts", "inst", "sc", "usr", "pkg", "rs", "sub"], "dst": ["psts", "mest", "Dst", "ptr", " dnd", "lust", "lsts", " dsts", "adsts", "pst", "dbtr", "lst", "dnd", "dut", "mnd", "mst", "Dnd", "dbsts", " dust", "dust", "Dest", "adnd", "mut", "dbst", "dest", "dsts", "lut", "adust", "lnd", "Dut", " dtr", "lest", "adst", "dbnd", "dtr", "pnd"], "src_size": ["source_Size", "src_SIZE", "srcptindex", "src_name", "src_mode", "src_index", "srcptSize", " src_len", "source_size", "src_len", "rc_mode", " src_SIZE", "source_resolution", "source_SIZE", "rc_size", "source_index", "src_resolution", "source_len", "srcptmode", "srcptname", "src_share", "source_name", "source_share", "srcptSIZE", "rc_Size", "source_weight", "src_weight", "rc_SIZE", "src_Size", "srcptsize"], "s": ["gs", "S", "f", "sw", "bs", "ys", "j", "n", "js", "p", "si", "sq", "g", "sl", "t", "sm", "sb", "sv", "st", "ds", "ls", "r", "ts", "sp", "c", "sr", "sh", "b", "cs", "es", "os", "i", "ss", "sc", "rs", "su", "ps"], "d": ["des", "f", "o", "out", "dn", "data", "l", "j", "n", "p", "fd", "dr", "D", "dt", "dm", "v", "g", "t", "st", "dc", "di", "ds", "da", "dd", "r", "bd", "dq", "c", "dx", "db", "b", "h", "ad", "z", "q", "w", "dra"], "m": ["a", "mem", "f", "o", "cm", "ref", "mi", "asm", "l", "mask", "n", "p", "module", "perm", "v", "dm", "g", "t", "sm", "em", "r", "vm", "c", "mm", "b", "mc", "gm", "h", "mt", "M", "value", "tm", "w", "nm", "name", "imm", "y"], "memory": ["metadata", "mem", "type", "frequency", "record", "ref", "cm", "alloc", "session", "address", "size", "data", "sequence", "window", "module", "reference", "Memory", "resource", "storage", "information", "model", "height", "statement", "field", "media", "cache", "command", "message", "context", "description", "time", "attribute", "buffer", "mm", "variable", "image", "phrase", "assembly", "sample", "gc", "javascript", "me", "integer", "value", "zero", "history", "network", "mx", "medium", "template", "pointer"], "s1": ["s3", "e001", "s11", " sone", "jsInit", "hs1", "hsInit", " sOne", "o1", "o91", "rs01", "d3", "oOne", "jsone", "d11", "s91", "ss51", "js2", "hs2", "eOne", "e1", "st1", "stOne", "rs1", "st51", "ss01", "o001", "ss0", "n91", "sInit", "rs3", "ss3", "s51", "n001", "s0", "js1", "hsone", "e91", "s01", "ss11", " s51", "d01", " sInit", "rs11", "n1", "sone", " s2", "st0", "s2", "nOne", "s001", "ss1", " s0", "sOne", "ssOne"], "d1": ["b1", "s11", "dOne", "p1", "d7", "bOne", " d0", "d3", "b11", "d11", " d11", "ds7", "ds3", "D3", "D7", "p0", "p3", "b0", "D0", "p7", " dOne", "ds1", "d0", "ds0", "D1", "sOne", "s0"], "e": ["f", "o", "l", "n", "p", "eb", "ee", "g", "el", "le", "ent", "t", "ge", "er", "end", "ed", "E", "eu", "r", "ue", "c", "en", "ec", "ep", "oe", "b", "h", "es", "te", "de", "u", "se", "ne", "eeee", "ev", "east", "i", "w", "x", "ele", "pe"]}}
{"project": "FFmpeg", "commit_id": "4749e074987d45cb98935a683a7ee8e1ee376d86", "target": 1, "func": "static int rle_unpack(const unsigned char *src, unsigned char *dest,\n\n    int src_len, int dest_len)\n\n{\n\n    const unsigned char *ps;\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n\n\n    ps = src;\n\n    pd = dest;\n\n    if (src_len & 1)\n\n        *pd++ = *ps++;\n\n\n\n    src_len >>= 1;\n\n    i = 0;\n\n    do {\n\n        l = *ps++;\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (pd + l > dest_end)\n\n                return ps - src;\n\n            memcpy(pd, ps, l);\n\n            ps += l;\n\n            pd += l;\n\n        } else {\n\n            if (pd + i > dest_end)\n\n                return ps - src;\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = ps[0];\n\n                *pd++ = ps[1];\n\n            }\n\n            ps += 2;\n\n        }\n\n        i += l;\n\n    } while (i < src_len);\n\n\n\n    return ps - src;\n\n}\n", "idx": 13859, "substitutes": {"src": ["rc", "sing", "ptr", "gin", "bs", "out", "cur", "attr", "ind", "addr", "str", "this", "stream", "sur", "rl", "pack", "proc", "ctr", "syn", "source", "loc", "sb", "st", "origin", "sys", "buf", "ur", "rb", "msg", "dist", "in", "s", "ssl", "rt", "txt", "null", "copy", "sr", "img", "trans", "sh", "std", "ins", "sync", "comp", "start", "ser", "rob", "tmp", "rel", "gz", "init", "sn", "supp", "sts", "inst", "sc", "usr", "rs", "sub"], "dest": ["est", "ptr", "out", "orig", "pi", "addr", "temp", "proc", "v", "test", "port", "pt", "gen", "source", "loc", "priv", "st", "end", "origin", "np", "dist", "desc", "rest", "lit", "gate", "Dest", "decl", "trans", "pos", "coord", "cp", "master", "id", "dev", "tmp", "max", "to", "prop", "target", "del", "phi", "home", "usr"], "src_len": ["srcptlength", "src6len", "src6li", "src_end", "src_limit", "srcablelen", "src_li", " src_ln", "srcptli", "src_ld", "src_size", "source_len", "src__limit", " src_li", " src_length", "source_gen", " src_size", "srcablelength", "src_gen", "source_limit", "src6ln", "src_ln", "srcptlen", "source_ld", "src__len", "srcableld", "src__li", " src_end", "srcablegen", "src__length", "srcptlimit", "src6end", "source_li", "source_length", "src_length"], "dest_len": ["dest2lan", "source_len", "source_l", "dest___lan", "dest___len", "dest_l", "dest_length", "dest2size", "dest2len", "source_end", "dest2line", "dest_size", " Dest___len", "dest_lan", " Dest_line", " Dest___lan", " Dest_size", "dest___size", " Dest___line", "dest___line", "source_length", " Dest___size", " Dest_len", "dest_line", " Dest_lan"], "ps": ["gs", "bs", "ports", "pres", "ones", "plays", "ping", "s", "eds", "stats", "vs", "po", "cs", "ims", "pers", "its", "fps", "pps", "ptr", "ph", "Ps", "pr", "js", "params", "css", "ds", "ats", "aps", "pos", "cp", "res", "posts", "parts", "pa", "pe", "pose", "pi", "ems", "proc", "eps", "als", "points", "times", "vals", "ands", "lp", "ops", "amps", "fs", "px", "checks", "jp", "ples", "p", "pt", "pp", "pins", "pse", "ls", "ips", "ts", "sp", "ins", "ns", "mp", "PS", "pes", "pas", "pl", "sts", "ms", "rs"], "pd": ["PD", "ctl", "td", "pu", "py", "ph", "pi", "pr", "pb", "pat", "p", "fd", "ln", "dl", "xd", "pm", "cd", "dt", "dp", "eps", "pt", "md", "pp", "ping", "np", "pipe", "ds", "ls", "php", "dd", "ud", "bd", "ld", "hd", "ppa", "lp", "pn", "ped", "po", "cp", "lv", "pc", "pid", "sd", "pard", "posts", "d", "pdf", "px", "vd", "phi", "pl", "pkg", "pak", "tp", "pps", "pe", "pod"], "i": ["ij", "index", "li", "a", "o", "iu", "oi", "ii", "mi", "I", "pi", "ini", "j", "ei", "n", "p", "ki", "si", "ind", "zi", "v", "cli", "bi", "io", "t", "is", "ui", "di", " ii", "ai", "m", "k", "in", "hi", "ie", "xi", "qi", "\u0438", "im", "c", "ci", "b", "print", "h", "ti", "e", "u", "iter", "it", "d", "gi", "ji", "multi", "fi", "me", "phi", "x", "y", "ic", "ix", "ip"], "l": ["il", "li", "nl", "ly", "tl", "f", "local", "lf", "ol", "lr", "ll", "lc", "j", "p", "ln", "n", "dl", "L", "v", "g", "sl", "el", "le", "t", "len", "loc", "la", "isl", "lb", "ls", "cl", "al", "lis", "ml", "lit", "m", "s", "line", "lu", "c", "lp", "lt", "ul", "kl", "b", "lv", "h", "jl", "hl", "u", "list", "length", "d", "it", "pl", "lo", "ld"], "dest_end": ["dest___begin", "rest_termin", "src_end", "destvaltermin", "dest___open", "rest_open", "rest_end", "dest___termin", "dest_begin", "dest_hend", "desc_start", "desc_ends", "dest_start", "destvalopen", "destvalend", "src_ends", "destvalbegin", "src_hend", "dest_termin", "desc_end", "dest_open", "rest_begin", "dest___end", "dest_ends"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,\n\n                                           src - (stride * 2) +\n\n                                           sizeof(uint8_t), stride,\n\n                                           dst, stride);\n\n}\n", "idx": 13867, "substitutes": {"dst": ["mest", "Dst", " dmit", "ddest", " dsts", "test", "desrc", " dsrc", "mst", "mdest", "tst", "mmit", " ddest", "Dsrc", "Dsts", "Dest", "dest", " dest", "dsts", "dmit", "deest", "dests", "tdest", "dsrc", "tmit"], "src": ["rc", "ptr", "cur", "ind", "cmp", "rl", "RC", "req", "sur", "cc", "ctr", "syn", "source", "loc", "sb", "st", "sys", "ur", "scan", "usc", "in", "dist", "r", "desc", "uint", "s", "rs", "rt", "imp", "dq", "dest", "sr", "img", "ins", "comp", "b", "ser", "input", "urg", "inner", "hl", "sn", "supp", "inst", "sc", "str", "cont", "txt", "sub"], "stride": ["strance", "suspided", "stided", "stringide", "strride", "strider", "STRope", "suspide", " strend", "drice", "STRided", "volide", "strope", "spripe", "STRance", "STRide", "spride", "ctrider", "strend", "dride", "stringope", " strided", " strance", "ctrice", "volance", "sprided", "sprride", "strice", " strride", " strider", " strope", "stipe", "volride", "strides", "volider", "dide", "stringides", "suspope", "ctrend", "strided", "STRride", "dope", "drend", " strides", "dides", "STRider", "stide", "stringride", " strice", "drider", "ctride", "stripe", " stripe", "suspride"]}}
{"project": "FFmpeg", "commit_id": "374c907fb35f8236547b24d792fbb9bed201e321", "target": 1, "func": "static int vorbis_parse(AVCodecParserContext *s1, AVCodecContext *avctx,\n\n                        const uint8_t **poutbuf, int *poutbuf_size,\n\n                        const uint8_t *buf, int buf_size)\n\n{\n\n    VorbisParseContext *s = s1->priv_data;\n\n    int duration;\n\n\n\n    if (!s->vp && avctx->extradata && avctx->extradata_size) {\n\n        s->vp = av_vorbis_parse_init(avctx->extradata, avctx->extradata_size);\n\n        if (!s->vp)\n\n            goto end;\n\n    }\n\n\n\n    if ((duration = av_vorbis_parse_frame(s->vp, buf, buf_size)) >= 0)\n\n        s1->duration = duration;\n\n\n\nend:\n\n    /* always return the full packet. this parser isn't doing any splitting or\n\n       combining, only packet analysis */\n\n    *poutbuf      = buf;\n\n    *poutbuf_size = buf_size;\n\n    return buf_size;\n\n}\n", "idx": 13888, "substitutes": {"s1": ["S2", " sOne", "ts2", "S1", "ss2", "cs1", "ss01", "cs2", "cs01", "SOne", "s0", " s01", "ts1", "s01", "csOne", "ts0", "S0", " s2", "S01", "s2", "ss1", " s0", "sOne", "ssOne"], "avctx": ["vctx", "avtx", " avkl", " avsys", " avpkg", "AVcontext", "AVctx", "avcontext", "varconfig", "avercontext", "averpkg", "avepkg", "avmc", "avsys", "avkl", "avercli", "varctx", "avpkg", "vconfig", "averkl", "varpkg", "varcli", " avtx", "avecontext", "ravctx", " avconfig", "ravmc", "varcontext", " avcli", "AVtx", "averctx", "avectx", "varkl", " avca", " avmc", "ravcontext", "avermc", "aversys", "avca", "averconfig", "avcli", "ravca", " avcontext", "varsys", "aveca", "averca", "vtx", "avconfig", "vcontext", "AVconfig"], "poutbuf": ["portbuffer", "Pinbuffer", "pOutpipe", "punebuf", "pindb", "Pinbuf", "Poutbuf", "pinbuffer", "portbuf", "portqueue", " poutbuffer", "pOutdb", "pinqueue", " pOutbuffer", " pOutqueue", "punebuffer", "pOutqueue", "poutdb", "Poutqueue", "punepipe", " poutqueue", "poutqueue", " pOutbuf", " poutdb", "punequeue", "pOutbuf", "Poutbuffer", "Pinpipe", "Poutpipe", "Pinqueue", "poutbuffer", "poutpipe", "pOutbuffer", "pinbuf", "pinpipe", "portdb", " pOutdb"], "poutbuf_size": ["poutbuffer_size", "poutbuf_SIZE", "poutbuffer_SIZE", "poutbuffer_count", "poutbuf_max", "poutbuffer_max", "poutbuffer_len", "poutbuf_len", "poutbuf_count"], "buf": ["Buff", "vec", "mem", "out", "cur", "ff", "data", "seq", "pb", "cmd", "wb", "ctx", "window", "raw", "Buffer", "proc", "batch", "box", "msg", "buff", "cap", "result", "rb", "np", "cache", "func", "br", "bag", "doc", "buffer", "cb", "block", "cv", "db", "bf", "img", "b", "bc", "tmp", "pad", "uv", "uf", "err", "queue", "pkg", "txt"], "buf_size": ["uf_index", "buf2mode", "buf67code", "buf64len", "buf64mode", "buf2error", "buf67index", "cap_len", "buffer_len", "buf_code", "uf_size", "buf64code", "buf64index", "buf64error", "buf2len", "buf_error", "buf_len", "uf_code", "buf_set", " buf_set", " buf2set", "buf_Size", "uf_start", "buf67start", "buf2size", "cap_size", "buf2set", " buf2size", "buf_index", "buffer_Size", "buf_start", "buf_mode", "cap2error", "cap2len", "buffer_mode", "buf64size", "cap_mode", "buf64start", "buf67size", " buf2len", "buffer_size", "cap2size", " buf_len", "cap_error", "cap2mode"], "s": ["aws", "ses", "gs", "S", "sw", "bs", "less", "ports", "j", "n", "js", "p", "sq", "v", "sl", "simple", "sam", "sol", "comm", "is", "sm", "sv", "sb", "spec", "hs", "sys", "ds", "ls", "ats", "ess", "services", "qs", "ts", "sp", "c", "stats", "sync", "ns", "b", "cs", "h", "ims", "sg", "os", "se", "sports", "scl", "ss", "sts", "i", "y", "rs", "ps"], "duration": ["wait", "uration", "distance", "Duration", "frequency", "version", "position", "latest", "recorded", "number", "size", "performance", "relative", "sequence", "window", "vr", "timeout", "fd", "relation", "depth", "vp", "v", "port", "len", "whatever", "padding", "video", "date", "result", "policy", "runtime", "delay", "future", "timer", "memory", "message", "description", "during", "time", "doc", "dim", "resolution", "progress", "document", "run", "event", "volume", "seconds", "portion", "verb", "trace", "length", "d", "component", "uv", "format", "period", "valid", "span", "later", "complete"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void xen_ram_init(PCMachineState *pcms,\n\n                         ram_addr_t ram_size, MemoryRegion **ram_memory_p)\n\n{\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    ram_addr_t block_len;\n\n    uint64_t user_lowmem = object_property_get_int(qdev_get_machine(),\n\n                                                   PC_MACHINE_MAX_RAM_BELOW_4G,\n\n                                                   &error_abort);\n\n\n\n    /* Handle the machine opt max-ram-below-4g.  It is basically doing\n\n     * min(xen limit, user limit).\n\n     */\n\n    if (HVM_BELOW_4G_RAM_END <= user_lowmem) {\n\n        user_lowmem = HVM_BELOW_4G_RAM_END;\n\n    }\n\n\n\n    if (ram_size >= user_lowmem) {\n\n        pcms->above_4g_mem_size = ram_size - user_lowmem;\n\n        pcms->below_4g_mem_size = user_lowmem;\n\n    } else {\n\n        pcms->above_4g_mem_size = 0;\n\n        pcms->below_4g_mem_size = ram_size;\n\n    }\n\n    if (!pcms->above_4g_mem_size) {\n\n        block_len = ram_size;\n\n    } else {\n\n        /*\n\n         * Xen does not allocate the memory continuously, it keeps a\n\n         * hole of the size computed above or passed in.\n\n         */\n\n        block_len = (1ULL << 32) + pcms->above_4g_mem_size;\n\n    }\n\n    memory_region_init_ram(&ram_memory, NULL, \"xen.ram\", block_len,\n\n                           &error_abort);\n\n    *ram_memory_p = &ram_memory;\n\n    vmstate_register_ram_global(&ram_memory);\n\n\n\n    memory_region_init_alias(&ram_640k, NULL, \"xen.ram.640k\",\n\n                             &ram_memory, 0, 0xa0000);\n\n    memory_region_add_subregion(sysmem, 0, &ram_640k);\n\n    /* Skip of the VGA IO memory space, it will be registered later by the VGA\n\n     * emulated device.\n\n     *\n\n     * The area between 0xc0000 and 0x100000 will be used by SeaBIOS to load\n\n     * the Options ROM, so it is registered here as RAM.\n\n     */\n\n    memory_region_init_alias(&ram_lo, NULL, \"xen.ram.lo\",\n\n                             &ram_memory, 0xc0000,\n\n                             pcms->below_4g_mem_size - 0xc0000);\n\n    memory_region_add_subregion(sysmem, 0xc0000, &ram_lo);\n\n    if (pcms->above_4g_mem_size > 0) {\n\n        memory_region_init_alias(&ram_hi, NULL, \"xen.ram.hi\",\n\n                                 &ram_memory, 0x100000000ULL,\n\n                                 pcms->above_4g_mem_size);\n\n        memory_region_add_subregion(sysmem, 0x100000000ULL, &ram_hi);\n\n    }\n\n}\n", "idx": 13890, "substitutes": {"pcms": ["panents", "procmic", "pconds", "pxterms", "nicterms", "socms", "cfs", "pcents", "procces", "arcts", "mcfs", "pbces", "procm", "picems", "dcents", " pcps", "pcps", "pcws", "pbns", "pcams", "pcems", "pcrs", "dcces", "pcmos", "dcms", "crs", "mcrs", "picds", "pcks", "panems", " pcrs", "nicms", "picces", "pcterms", "cpterms", "piccs", "bcms", "picmes", "pcns", "picfs", "procws", " pcfs", "pnonds", "picms", "procterms", "pnents", "bcns", "pnws", "cms", "procns", "arcms", "pcss", "pccs", "pbjs", "cpks", "pxonds", "pnmes", "pbms", "picjs", "nicams", "picents", "picensions", "pances", "socents", "pcjs", "pnns", "pnensions", "pxcs", "procfs", "pcfs", "pxams", "pcm", "pcensions", "cpss", "procms", " pcmic", "cpms", "cps", "panms", "socws", "picns", "procents", "pcces", "vcmos", "vcms", "vcts", "cpams", "pcds", "pxks", "pcmes", "mcms", "pcmic", "arcmos", "cpfs", "pxms", "pxfs", "picmic", "pcts", "cpmes", "arcss", "bcensions", "nicks", "pnmis", "mcps", "procmis", "cpcs", "pnms", "dcems", "bcds", "socmis", "proconds", "cpts", "procmes", "picm", "pcmis", "pnds", "pnterms", "vcss", "cpmos", "procjs", " pcm", "pxmes"], "ram_size": ["ramzpos", "gram_type", " ram_type", "ramttype", " ram_file", "ramzsize", " ram_length", "gram_pos", "ram2length", "ram2pos", "gram2type", "ram_pos", "cam_group", "gram_size", "block_size", "cam_number", "ram_length", "ram_name", "ram_group", "ram_ize", "ram2type", "ram2file", "gram2size", "gram2length", "rum_loss", "ram_Size", "block_length", "ram_number", " ram2type", "ram_len", "ram_loss", "rum_ize", "cam_len", "ramtsize", "ram_file", "ram2size", "ramztype", "ramtpos", "ramtlength", "rum_size", " ram2length", "rum_Size", "ram_type", "gram_length", "cam_size", "ramzlength", "block_name", " ram2file", " ram2size", "gram2pos"], "ram_memory_p": ["ram_mem_pb", "ram_mem_P", "ram_memory_t", "ram_mem_p", "ram_storage_P", "ram_storage_p", "ram_memory2pc", "ram_memory__P", "ram_memory2p", "ram_memory__pb", "ram_memory__p", "ram_memory_pc", "ram_storage_t", "ram_storage_pc", "ram_memory_pb", "ram_memory_P", "ram_memory__pre", "ram_memory2t", "ram_memory_pre", "ram_mem_pre", "ram_memory2P"], "sysmem": ["ysMem", " sysmsg", "procmem", "sycore", "systemcore", " sysMem", " sysmb", "procmm", "symm", "privgo", "Sysmb", "procgo", "symsg", "sygo", "sysmemory", "privmem", "ysmb", "Sysmemory", "ysmem", " syscore", "systemmemory", "sysMem", "privmm", "sysmm", " sysmemory", "syscore", "procdoc", "sysgo", "ysmemory", "systemmem", "Sysmem", "sysmb", "systemmsg", "symemory", "privdoc", "sysdoc", "symem", "SysMem", "sysmsg", "sydoc"], "block_len": ["block_lim", " block_Len", "block_Len", "block__size", "Block_Len", "buffer__size", "buffer_len", " block_coll", "block_size", "buffer__l", "block_lon", "block__len", "buffer__len", "Block_lon", "block_l", "block_length", "block__l", "block_coll", "block_pos", "block__mem", "buffer_mem", "Block_lim", "block_loc", "buffer__mem", "Block_len", "buffer_size", " block_length", "block_mem", "lock_Len", "lock_loc", "lock_len", "lock_pos", "buffer_l"]}}
{"project": "qemu", "commit_id": "caae58cba07efec5f0616f568531c9dfaf1e9179", "target": 1, "func": "static void pci_spapr_set_irq(void *opaque, int irq_num, int level)\n\n{\n\n    /*\n\n     * Here we use the number returned by pci_spapr_map_irq to find a\n\n     * corresponding qemu_irq.\n\n     */\n\n    sPAPRPHBState *phb = opaque;\n\n\n\n    trace_spapr_pci_lsi_set(phb->busname, irq_num, phb->lsi_table[irq_num].irq);\n\n    qemu_set_irq(spapr_phb_lsi_qirq(phb, irq_num), level);\n\n}\n", "idx": 13897, "substitutes": {"opaque": [" opaques", "oplque", "oplaque", "opane", " opque", " opane", "Opaques", "Opaque", "pane", "OPaques", "opaques", "Opane", "opllay", " oplay", "OPlay", "paque", "paques", "opque", "OPaque", "oplay", "oplaques", "OPque"], "irq_num": ["irquest_nm", "irq_mon", "irqi_num", "irq_den", "irq_n", "irq_index", "irch_sum", "irqi_n", "irch_um", "irquest_con", "irquest_num", "irqxNum", "irq_number", "irv_index", "irqi_mon", "irqxindex", "irq_um", "irqi_number", "irq_nm", "irqxmon", "irqxnum", "irq_sum", "irq_con", "irquest_mon", "irq_Num", "irch_den", "irv_mon", "irv_Num", "irch_num", "irv_num"], "level": ["impact", "status", "index", "cost", "Level", "type", "vl", "local", "family", "scope", "mode", "depth", "LE", "group", "what", "where", "fail", "low", "le", "VEL", "lvl", "command", "show", "message", "limit", " Level", "debug", "print", "scale", "equal", "levels", "length", "style", "prop", "quality", "qual", "lev", "vel", "priority"], "phb": ["phB", "phyb", "phc", "Pha", " pbar", "ophcb", "ophba", "khB", "iphbp", "phycb", "ophb", "phbp", "aphc", "aphba", "pha", "phyB", "phcb", "phbar", "aphcb", "aphB", "khb", "iphB", "ophB", " pb", "Phbb", "iphb", "phyba", "aphwb", "aphb", "phyc", " phbar", "phbb", "phybp", " pbb", "khwb", " pha", "phwb", "phba", " phc", " phbp", "khc", "iphc", " phbb", "Phbar", " phwb", " phB", " pa", "Phb"]}}
{"project": "FFmpeg", "commit_id": "2f6ec9fdd7808c8ed045ae0ca4134ab21fb785e6", "target": 1, "func": "static int alloc_sequence_buffers(DiracContext *s)\n\n{\n\n    int sbwidth  = DIVRNDUP(s->source.width,  4);\n\n    int sbheight = DIVRNDUP(s->source.height, 4);\n\n    int i, w, h, top_padding;\n\n\n\n    /* todo: think more about this / use or set Plane here */\n\n    for (i = 0; i < 3; i++) {\n\n        int max_xblen = MAX_BLOCKSIZE >> (i ? s->chroma_x_shift : 0);\n\n        int max_yblen = MAX_BLOCKSIZE >> (i ? s->chroma_y_shift : 0);\n\n        w = s->source.width  >> (i ? s->chroma_x_shift : 0);\n\n        h = s->source.height >> (i ? s->chroma_y_shift : 0);\n\n\n\n        /* we allocate the max we support here since num decompositions can\n\n         * change from frame to frame. Stride is aligned to 16 for SIMD, and\n\n         * 1<<MAX_DWT_LEVELS top padding to avoid if(y>0) in arith decoding\n\n         * MAX_BLOCKSIZE padding for MC: blocks can spill up to half of that\n\n         * on each side */\n\n        top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2);\n\n        w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); /* FIXME: Should this be 16 for SSE??? */\n\n        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;\n\n\n\n        s->plane[i].idwt_buf_base = av_mallocz((w+max_xblen)*h * sizeof(IDWTELEM));\n\n        s->plane[i].idwt_tmp      = av_malloc((w+16) * sizeof(IDWTELEM));\n\n        s->plane[i].idwt_buf      = s->plane[i].idwt_buf_base + top_padding*w;\n\n        if (!s->plane[i].idwt_buf_base || !s->plane[i].idwt_tmp)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    w = s->source.width;\n\n    h = s->source.height;\n\n\n\n    /* fixme: allocate using real stride here */\n\n    s->sbsplit  = av_malloc(sbwidth * sbheight);\n\n    s->blmotion = av_malloc(sbwidth * sbheight * 16 * sizeof(*s->blmotion));\n\n    s->edge_emu_buffer_base = av_malloc((w+64)*MAX_BLOCKSIZE);\n\n\n\n    s->mctmp     = av_malloc((w+64+MAX_BLOCKSIZE) * (h*MAX_BLOCKSIZE) * sizeof(*s->mctmp));\n\n    s->mcscratch = av_malloc((w+64)*MAX_BLOCKSIZE);\n\n\n\n    if (!s->sbsplit || !s->blmotion)\n\n        return AVERROR(ENOMEM);\n\n    return 0;\n\n}\n", "idx": 13899, "substitutes": {"s": ["ses", "gs", "S", "bs", "ports", "series", "sq", "sam", "t", "eds", "acs", "qs", "stats", "vs", "states", "cs", "ims", "pers", "its", "ants", "us", "ps", "n", "js", "g", "ar", "comm", "ds", "ats", "obj", "ies", "self", "rates", "conf", "parts", "ex", "results", "south", "a", "f", "as", "less", "bits", "eps", "als", "sb", "hs", "sys", "times", "erences", "c", "ares", "ops", "es", "changes", "fs", "bis", "ss", "comments", "aws", "has", "p", "details", "is", "sv", "ls", "ts", "ins", "ns", "b", "re", "os", "sts", "sets", "ms", "y", "rs"], "i": ["index", "mount", "dr", "cli", "gu", "ai", "m", "xi", "qi", "dim", "ish", "it", "ji", "us", "li", "ret", "oi", "ind", "j", "n", "si", "zi", "v", "g", "try", "ui", "im", "print", "any", "ti", "fi", "ex", "x", "ri", "ic", "ix", "ip", "ij", "f", "mi", "ii", "I", "pi", "yi", "batch", "di", " ii", "in", "sim", "info", "c", "ci", "id", "u", "multi", "me", "err", "init", "status", "il", "go", "iu", "o", "ini", "l", "ei", "uri", "p", "vi", "chain", "bi", "io", "is", "ia", "iri", "\u0438", "list", "gi", "q", "phi", "name", "y"], "w": ["wind", "kw", "ww", "wh", "rew", "fw", "nw", "sw", "f", "rw", "wx", "aw", "ll", "l", "hw", "wb", "window", "n", "p", "wl", "v", "widget", "wal", "height", "g", "t", "wa", "wt", "ow", "wn", "r", "ew", "iw", "html", "wid", "we", "wp", "wd", "W", "wi", "tw", "b", "ht", "wr", "u", "weight", "max", "d", "win", "z", "q", "x", "y"], "h": ["hang", "wh", "uh", "f", "ph", "kh", "o", "hr", "high", "hz", "l", "p", "hw", "hm", "bh", "hal", "v", "ha", "height", "g", "t", "ih", "hs", "k", "m", "ah", "th", "he", "hi", "hd", "c", "rh", "oh", "sh", "ht", "b", "ho", "H", "ish", "host", "hl", "hash", "dh", "z", "q", "phi", "hh", "y", "gh", "zh", "history", "ch"], "top_padding": ["bottom_offset", "top67pressure", "bottom_space", "top_prefix", "bottom_padding", "top_offset", "top_margin", "bottom_pointer", "top67space", "topPpointer", "top_adding", "top_space", "top67padding", "top_height", "topPpadding", "topPmargin", "bottom_border", "bottom_prefix", "top_border", "top67margin", "top_pointer", "topPadding", "bottom_pressure", "bottom_margin", "top_pressure", "bottom_adding", "bottom_height"]}}
{"project": "FFmpeg", "commit_id": "bfeb83a8b7d3fcf09a54d8dbc9c521e10bb17530", "target": 1, "func": "static int hevc_handle_packet(AVFormatContext *ctx, PayloadContext *rtp_hevc_ctx,\n\n                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n\n                              const uint8_t *buf, int len, uint16_t seq,\n\n                              int flags)\n\n{\n\n    const uint8_t *rtp_pl = buf;\n\n    int tid, lid, nal_type;\n\n    int first_fragment, last_fragment, fu_type;\n\n    uint8_t new_nal_header[2];\n\n    int res = 0;\n\n\n\n    /* sanity check for size of input packet: 1 byte payload at least */\n\n    if (len < RTP_HEVC_PAYLOAD_HEADER_SIZE + 1) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Too short RTP/HEVC packet, got %d bytes\\n\", len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /*\n\n     * decode the HEVC payload header according to section 4 of draft version 6:\n\n     *\n\n     *    0                   1\n\n     *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n\n     *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n     *   |F|   Type    |  LayerId  | TID |\n\n     *   +-------------+-----------------+\n\n     *\n\n     *      Forbidden zero (F): 1 bit\n\n     *      NAL unit type (Type): 6 bits\n\n     *      NUH layer ID (LayerId): 6 bits\n\n     *      NUH temporal ID plus 1 (TID): 3 bits\n\n     */\n\n    nal_type =  (buf[0] >> 1) & 0x3f;\n\n    lid  = ((buf[0] << 5) & 0x20) | ((buf[1] >> 3) & 0x1f);\n\n    tid  =   buf[1] & 0x07;\n\n\n\n    /* sanity check for correct layer ID */\n\n    if (lid) {\n\n        /* future scalable or 3D video coding extensions */\n\n        avpriv_report_missing_feature(ctx, \"Multi-layer HEVC coding\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    /* sanity check for correct temporal ID */\n\n    if (!tid) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Illegal temporal ID in RTP/HEVC packet\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* sanity check for correct NAL unit type */\n\n    if (nal_type > 50) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported (HEVC) NAL type (%d)\\n\", nal_type);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch (nal_type) {\n\n    /* video parameter set (VPS) */\n\n    case 32:\n\n    /* sequence parameter set (SPS) */\n\n    case 33:\n\n    /* picture parameter set (PPS) */\n\n    case 34:\n\n    /*  supplemental enhancement information (SEI) */\n\n    case 39:\n\n    /* single NAL unit packet */\n\n    default:\n\n        /* sanity check for size of input packet: 1 byte payload at least */\n\n        if (len < 1) {\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\\n\",\n\n                   len, nal_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        /* create A/V packet */\n\n        if ((res = av_new_packet(pkt, sizeof(start_sequence) + len)) < 0)\n\n            return res;\n\n        /* A/V packet: copy start sequence */\n\n        memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n\n        /* A/V packet: copy NAL unit data */\n\n        memcpy(pkt->data + sizeof(start_sequence), buf, len);\n\n\n\n        break;\n\n    /* aggregated packet (AP) - with two or more NAL units */\n\n    case 48:\n\n        /* pass the HEVC payload header */\n\n        buf += RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n        len -= RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n\n\n        /* pass the HEVC DONL field */\n\n        if (rtp_hevc_ctx->using_donl_field) {\n\n            buf += RTP_HEVC_DONL_FIELD_SIZE;\n\n            len -= RTP_HEVC_DONL_FIELD_SIZE;\n\n        }\n\n\n\n        res = ff_h264_handle_aggregated_packet(ctx, pkt, buf, len,\n\n                                               rtp_hevc_ctx->using_donl_field ?\n\n                                               RTP_HEVC_DOND_FIELD_SIZE : 0,\n\n                                               NULL, 0);\n\n        if (res < 0)\n\n            return res;\n\n        break;\n\n    /* fragmentation unit (FU) */\n\n    case 49:\n\n        /* pass the HEVC payload header */\n\n        buf += RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n        len -= RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n\n\n        /*\n\n         *    decode the FU header\n\n         *\n\n         *     0 1 2 3 4 5 6 7\n\n         *    +-+-+-+-+-+-+-+-+\n\n         *    |S|E|  FuType   |\n\n         *    +---------------+\n\n         *\n\n         *       Start fragment (S): 1 bit\n\n         *       End fragment (E): 1 bit\n\n         *       FuType: 6 bits\n\n         */\n\n        first_fragment = buf[0] & 0x80;\n\n        last_fragment  = buf[0] & 0x40;\n\n        fu_type        = buf[0] & 0x3f;\n\n\n\n        /* pass the HEVC FU header */\n\n        buf += RTP_HEVC_FU_HEADER_SIZE;\n\n        len -= RTP_HEVC_FU_HEADER_SIZE;\n\n\n\n        /* pass the HEVC DONL field */\n\n        if (rtp_hevc_ctx->using_donl_field) {\n\n            buf += RTP_HEVC_DONL_FIELD_SIZE;\n\n            len -= RTP_HEVC_DONL_FIELD_SIZE;\n\n        }\n\n\n\n        av_dlog(ctx, \" FU type %d with %d bytes\\n\", fu_type, len);\n\n\n\n        if (len <= 0) {\n\n            /* sanity check for size of input packet: 1 byte payload at least */\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\\n\",\n\n                   len, nal_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (first_fragment && last_fragment) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Illegal combination of S and E bit in RTP/HEVC packet\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        new_nal_header[0] = (rtp_pl[0] & 0x81) | (fu_type << 1);\n\n        new_nal_header[1] = rtp_pl[1];\n\n\n\n        res = ff_h264_handle_frag_packet(pkt, buf, len, first_fragment,\n\n                                         new_nal_header, sizeof(new_nal_header));\n\n\n\n        break;\n\n    /* PACI packet */\n\n    case 50:\n\n        /* Temporal scalability control information (TSCI) */\n\n        avpriv_report_missing_feature(ctx, \"PACI packets for RTP/HEVC\\n\");\n\n        res = AVERROR_PATCHWELCOME;\n\n        break;\n\n    }\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n    return res;\n\n}\n", "idx": 13905, "substitutes": {"ctx": ["tx", "jp", "kw", "cu", "ctl", "cf", "co", "unc", "conn", "tc", "cm", "wx", "cn", "setup", "addr", "cmd", "hw", "cmp", "kt", "cc", "kk", "cas", "conv", "xp", "wcs", "dc", "sys", "func", "ct", "act", "nt", "cfg", "cl", "desc", "context", "obj", "sc", "prefix", "ck", " cx", "cb", "cv", "xc", "nc", "fn", "ci", "tz", "cp", "wd", "gc", "conf", "config", "gz", "pkg", "ca", "iat", "jac"], "rtp_hevc_ctx": ["rtp_hevc_cv", "rtp_hevc_context", "rtp_heVC_context", "rtp_heVC_ct", "rtp_heVC_ctx", "rtp_heVC_cv", "rtp_hevc_ct"], "st": ["ste", "est", "sw", "et", "sta", "St", "ST", "ist", "utt", "tt", "ut", "sam", "ct", "nt", "act", "rest", "rt", "stage", "sp", "std", "fr", "mt", "ast", "sth", "sts", "inst", "xt", "str"], "pkt": ["ppet", "cpett", "packet", " pct", "Packet", "cnt", "cpct", " pet", "npkg", "apacket", "ppacket", "tacket", "cet", " pck", "apnt", " pnt", "ckt", "cpkt", " pkg", "pnt", "tct", "cpacket", "Pett", "packacket", "npkt", "packett", "npnt", "pct", "cpck", "ppkt", "pck", "npacket", "apkt", "ppnt", "packkt", "apkg", "cpet", "tkt", "tck", "pet", "Pet", "cacket", "pkg", "pett", "Pkt", " packet"], "timestamp": ["temestamp", "temstart", "timstart", "timtime", "simstart", "Timtime", "Timestamp", "simestamp", "Timest", "simtime", "Timstart", "temtime", "timest", "simest", "temest"], "buf": ["vec", "bs", "header", "cur", "cmp", "raw", "pool", "loc", "cb", "length", "emb", "uf", "queue", "pkg", "arr", "ait", "pack", "mem", "ptr", "ff", "data", "addr", "cmd", "aka", "Buffer", "conv", "next", "box", "buff", "packed", "br", "db", "pos", "cp", "res", "pg", "tmp", "elt", "txt", "Buff", "ref", "rw", "late", "Len", "proc", "vp", "ctr", "np", "rb", "bn", "buffer", "cv", "bc", "iter", "err", "str", "ob", "bytes", "pb", "p", "msg", "cache", "cap", "bin", "cam", "desc", "xff", "img", "b", "bl", "h", "pad", "prop", "bp", "nm"], "len": ["bytes", "resp", "nl", "vec", "mem", "ret", "lf", "late", "Len", "size", "l", "ll", "lc", "n", "ln", "fin", "dl", "L", "val", "conv", "el", "syn", "loc", "msg", "cap", "fl", "lang", "num", "ls", "nt", "line", "lis", "lon", "lp", "lic", "pos", "en", "fn", "all", "lan", "kl", "res", "enc", "iter", "length", "elt", "gz", "uf", "err", "z", "coll", "lim", "full"], "seq": ["nos", "vec", "serv", "ref", "ver", "body", "sequence", "req", "cas", "val", "next", "ctr", "gen", "frame", "sec", "msg", "loop", "flow", "alt", "ess", "vals", "cb", "count", "pos", "code", "iter", "q"], "flags": ["status", "types", "cf", "tags", "ff", "mask", "bits", "ags", "fields", "details", "fl", "faces", "ds", "vals", "ts", "Flags", "flag", "ns", "cs", "args", "links", "fs", "weight", "options", "files", "ents", "ms", "ps"], "rtp_pl": ["rtv_pp", "rtv__pp", "rtv__cl", "rtp__pp", "rtp_pb", "rtv_pb", "rtv_cl", "rtp__pb", "rtv_pl", "rtp__cl", "rtv__pl", "rtp__pl", "rtp_cl", "rtv__pb", "rtp_pp"], "tid": ["loid", "ntype", "goid", "gmid", " tip", "tgId", "nids", "lId", " ttype", "tgip", "gid", " tids", "tmid", "toid", "tids", " tmid", "ltype", "nId", "lmid", "tId", " tId", "lip", "tip", "gId", "nid", "tgoid", " toid", "lids", "tgid", "ttype"], "lid": [" lpid", "flaid", "cmid", " loid", "loid", "ntype", "mlid", "lno", " laid", "lpid", "mlids", "fltype", "cid", "lsno", "tno", "liden", "mliden", "naid", "iliden", " liden", "tmid", " lids", "floid", "ciden", "ilids", "tiden", "lsid", "ltype", "lsiden", "noid", "ilid", " ltype", "lmid", "ilpid", "mlpid", "nid", "flid", "lids", "laid", "cno", "lsmid"], "nal_type": ["nal_TYPE", "neal_types", "nals_Type", "nal2status", "naletyType", "nal_Type", "nal_length", "nal_status", "nal_name", "neal_Type", "nals_type", "nal_pe", "nAL_pe", "nAL_TYPE", "nals_ype", "nal__type", "neal_status", "neal_type", "nal2types", "nall_Type", "nal__pe", "naling_type", "naling_Type", "nAL_type", "naling_length", "naletyype", "nAL_name", "naling_block", "nal_style", "naletytype", "nall_type", "nal_types", "nal2type", "nal2Type", "nal__Type", "nal__TYPE", "nall_tag", "nAL_style", "nAL_Type", "nal_ype", "nal_block", "nal_tag"], "first_fragment": ["first_fragmentation", "first_fragramments", "first_fragrammentation", "first_frgments", "first_fragments", "first_pragment", "first_frgmentation", "first_prigment", "first_pragmentation", "first_frigments", "first_frigement", "first_pragments", "first_fragramement", "first_prigement", "first_frigmentation", "first_pragement", "first_frigment", "first_frgement", "first_prigments", "first_fragramment", "first_fragement", "first_frgment", "first_prigmentation"], "last_fragment": ["last_fragments", "last_frangmentation", "last_frigmentation", "last_fragmentation", "last_fagement", "last_fagmentation", "last_frangment", "last_figmentation", "last_frigement", "last_figment", "last_frongment", "last_fagments", "last_figments", "last_frongement", "last_figement", "last_frigments", "last_frigment", "last_fragement", "last_fagment", "last_frongmentation", "last_frangement", "last_frangments", "last_frongments"], "fu_type": ["du_type", "du_name", "fu_types", "du_types", "fu_name", "du_pe", "fu_pe"], "new_nal_header": ["new_nal_size", "new_nal__size", "new_nals_info", "new_nal__head", "new_nal_head", "new_nal__header", "new_nal_info", "new_nal__info", "new_nals_head", "new_nals_header", "new_nals_size"]}}
{"project": "FFmpeg", "commit_id": "a04c2c707de2ce850f79870e84ac9d7ec7aa9143", "target": 1, "func": "int avpriv_lock_avformat(void)\n\n{\n\n    if (lockmgr_cb) {\n\n        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))\n\n            return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 13906, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static int libschroedinger_encode_close(AVCodecContext *avctx)\n\n{\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n\n\n    /* Close the encoder. */\n\n    schro_encoder_free(p_schro_params->encoder);\n\n\n\n    /* Free data in the output frame queue. */\n\n    ff_schro_queue_free(&p_schro_params->enc_frame_queue,\n\n                        libschroedinger_free_frame);\n\n\n\n\n\n    /* Free the encoder buffer. */\n\n    if (p_schro_params->enc_buf_size)\n\n        av_freep(&p_schro_params->enc_buf);\n\n\n\n    /* Free the video format structure. */\n\n    av_freep(&p_schro_params->format);\n\n\n\n    return 0;\n\n}\n", "idx": 13915, "substitutes": {"avctx": ["avtx", "AVparams", " avparams", "AVcontext", "AVconn", "AVctx", " avconn", "ovctx", "avcontext", "avparams", "ovtx", " avtx", "avecontext", "AVtx", "avectx", "avetx", "avconn", " avcontext", "ovcontext", "aveconn", "ovparams"], "p_schro_params": ["p_schrotams", "p_schro___files", "p_schro2names", "p_schro___data", "p_schro__params", "p_schro2param", "p_schrob_param", "p_schro__info", "p_schro_pins", "p_schrob_pins", "p_schro_stats", "p_schro__ams", "p_schro_ams", "p_schrob_files", "p_schro2ams", "p_schro__pins", "p_schrob_names", "p_schro2params", "p_schrob_info", "p_schro_data", "p_schro___ams", "p_schrob_data", "p_schro___params", "p_schrotpins", "p_schro_param", "p_schro_info", "p_schrob_params", "p_schro__names", "p_schro_files", "p_schro__data", "p_schrob_ams", "p_schro_names", "p_schrob_stats", "p_schrotstats", "p_schrotparams"]}}
{"project": "FFmpeg", "commit_id": "121be310607879841d19a34d9f16d4fe9ba7f18c", "target": 0, "func": "static int cinepak_decode_frame(AVCodecContext *avctx,\n\n                                void *data, int *got_frame,\n\n                                AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int ret = 0, buf_size = avpkt->size;\n\n    CinepakContext *s = avctx->priv_data;\n\n\n\n    s->data = buf;\n\n    s->size = buf_size;\n\n\n\n    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)\n\n        return ret;\n\n\n\n    if (s->palette_video) {\n\n        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n\n        if (pal) {\n\n            s->frame->palette_has_changed = 1;\n\n            memcpy(s->pal, pal, AVPALETTE_SIZE);\n\n        }\n\n    }\n\n\n\n    if ((ret = cinepak_decode(s)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"cinepak_decode failed\\n\");\n\n    }\n\n\n\n    if (s->palette_video)\n\n        memcpy (s->frame->data[1], s->pal, AVPALETTE_SIZE);\n\n\n\n    if ((ret = av_frame_ref(data, s->frame)) < 0)\n\n        return ret;\n\n\n\n    *got_frame = 1;\n\n\n\n    /* report that the buffer was completely consumed */\n\n    return buf_size;\n\n}\n", "idx": 13943, "substitutes": {"avctx": ["avjac", "avtx", "afjac", " avpkg", "vrcpp", "AVcontext", "vrctx", "apctx", " avconn", "AVctx", "avcontext", "avercontext", "afcontext", "avecpp", "cvcontext", "avpkg", "vrtx", "avtmp", " avtx", "avecontext", "aftx", "AVpkg", "afctx", "averctx", "AVtx", "apcontext", "avectx", "aptx", "avetx", "afpkg", " avjac", "avertx", "avconn", "avcpp", "avertmp", " avcontext", "cvcpp", " avtmp", "avejac", "afconn", "aveconn", "aptmp", "cvctx", "cvtx", "vrcontext"], "data": ["bytes", "a", "rew", "mem", "f", "ref", "out", "size", "map", "flags", "p", "body", "window", " DATA", "raw", "bits", "n", "values", "str", "v", "text", "chain", "next", "batch", "done", "t", "frame", "len", "padding", "read", "video", "bin", "cache", "pipe", "apps", "end", "m", "al", "message", "extra", "mu", "buffer", "empty", "image", "pos", "Data", "content", "res", "id", "feed", "input", "area", "ad", "fr", "pad", "length", "d", "to", "DATA", "package", "ata", "options", "value", "dat", "w", "name", "actions"], "got_frame": [" got_process", " got_count", "sent_frames", "sent_frame", "got_int", "got_offset", "got_count", "got_process", "sent_int", "got_frames", "sent_offset", " got_frames"], "avpkt": ["avsppt", "avpardt", "aveppkt", "avppmsg", "wavwpnt", "avcpkt", "avcacket", "avpkg", "aveppt", "avwpkt", "avPct", "avepj", "avetpkt", "avepkt", "avppdt", "avepct", "avppkg", "avpargt", "aveppacket", "wavwpacket", "aveppj", "avwpkw", "avespacket", "avpakt", "avPkt", "avcct", "avparkt", "avtpdt", "wavpkw", "avpkw", "avepmsg", "avppgt", "avepacket", "wavpnt", "avPpt", "avetpdt", "aveppmsg", "avpdt", "avesppt", "avpaacket", "avtpkt", "avpj", "avparkg", "wavwpkw", "wavwpkt", "avcpnt", "avpamsg", "avespct", "avepgt", "avpct", "avpacket", "avetpkg", "avcj", "avcpacket", "avpgt", "avpmsg", "avckt", "avppacket", "avetpgt", "avppj", "avvpkw", "avcpkw", "avtpgt", "avtpkg", "wavpacket", "avspct", "avpnt", "avppt", "avwpacket", "wavpkt", "avvpkt", "avepkg", "avvpacket", "avwpnt", "avspacket", "avcmsg", "avvpnt", "avppkt", "avPacket", "avspkt", "avepdt", "avcpt", "avpaj", "avespkt"], "buf": ["bytes", "vec", "mem", "ref", "seq", "pb", "cmd", "p", "wb", "tr", "raw", "proc", "capt", "batch", "box", "msg", "buff", "np", "cap", "rb", "br", "buffer", "cb", "block", "cv", "db", "b", "bl", "bc", "tmp", "iter", "uf", "queue", "dat", "pkg", "lim", "alloc", "arr"], "s": ["ans", "ses", "gs", "S", "sw", "as", "serv", "bs", "has", "less", "j", "p", "js", "n", "bits", "sq", "v", "g", "details", "us", "comm", "is", "sv", "spec", "als", "sb", "sys", "hs", "ds", "ls", "ats", "y", "r", "ess", "ies", "qs", "so", "ts", "c", "stats", "vs", "ins", "b", "ns", "cs", "h", "ims", "es", "changes", "fs", "conf", "os", "bis", "its", "se", "parts", "ants", "sports", "i", "ss", "sts", "ms", "span", "rs", "ps"], "pal": ["pro", "pu", "nl", "mem", "pill", "ph", "local", "pen", "mon", "phil", "pillar", "pat", "p", "ill", "pol", "what", "pixel", "hal", "ali", "val", "v", "wal", "el", "le", "sam", " Pal", "ass", "pp", "bat", "buff", "bin", "tile", "uid", "cil", "cell", "al", "sal", "Pal", "phal", "mel", "cal", "isal", "apple", "pac", "ap", "cel", "theme", "mat", "fac", "font", "label", "rel", "pard", "app", "pid", "col", "qt", "skin", "pl", "pkg", "dat", "arr"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void taihu_405ep_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    char *filename;\n\n    qemu_irq *pic;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *bios;\n\n    MemoryRegion *ram_memories = g_malloc(2 * sizeof(*ram_memories));\n\n    MemoryRegion *ram = g_malloc0(sizeof(*ram));\n\n    hwaddr ram_bases[2], ram_sizes[2];\n\n    long bios_size;\n\n    target_ulong kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    int linux_boot;\n\n    int fl_idx, fl_sectors;\n\n    DriveInfo *dinfo;\n\n\n\n    /* RAM is soldered to the board so the size cannot be changed */\n\n    ram_size = 0x08000000;\n\n    memory_region_allocate_system_memory(ram, NULL, \"taihu_405ep.ram\",\n\n                                         ram_size);\n\n\n\n    ram_bases[0] = 0;\n\n    ram_sizes[0] = 0x04000000;\n\n    memory_region_init_alias(&ram_memories[0], NULL,\n\n                             \"taihu_405ep.ram-0\", ram, ram_bases[0],\n\n                             ram_sizes[0]);\n\n    ram_bases[1] = 0x04000000;\n\n    ram_sizes[1] = 0x04000000;\n\n    memory_region_init_alias(&ram_memories[1], NULL,\n\n                             \"taihu_405ep.ram-1\", ram, ram_bases[1],\n\n                             ram_sizes[1]);\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register cpu\\n\", __func__);\n\n#endif\n\n    ppc405ep_init(sysmem, ram_memories, ram_bases, ram_sizes,\n\n                  33333333, &pic, kernel_filename == NULL ? 0 : 1);\n\n    /* allocate and load BIOS */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register BIOS\\n\", __func__);\n\n#endif\n\n    fl_idx = 0;\n\n#if defined(USE_FLASH_BIOS)\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n    if (dinfo) {\n\n        BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo));\n\n\n\n        bios_size = bdrv_getlength(bs);\n\n        /* XXX: should check that size is 2MB */\n\n        //        bios_size = 2 * 1024 * 1024;\n\n        fl_sectors = (bios_size + 65535) >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Register parallel flash %d size %lx\"\n\n               \" at addr %lx '%s' %d\\n\",\n\n               fl_idx, bios_size, -bios_size,\n\n               bdrv_get_device_name(bs), fl_sectors);\n\n#endif\n\n        pflash_cfi02_register((uint32_t)(-bios_size),\n\n                              NULL, \"taihu_405ep.bios\", bios_size,\n\n                              bs, 65536, fl_sectors, 1,\n\n                              4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA,\n\n                              1);\n\n        fl_idx++;\n\n    } else\n\n#endif\n\n    {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Load BIOS from file\\n\");\n\n#endif\n\n        if (bios_name == NULL)\n\n            bios_name = BIOS_FILENAME;\n\n        bios = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram(bios, NULL, \"taihu_405ep.bios\", BIOS_SIZE,\n\n                               &error_abort);\n\n        vmstate_register_ram_global(bios);\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (filename) {\n\n            bios_size = load_image(filename, memory_region_get_ram_ptr(bios));\n\n            g_free(filename);\n\n            if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n                error_report(\"Could not load PowerPC BIOS '%s'\", bios_name);\n\n                exit(1);\n\n            }\n\n            bios_size = (bios_size + 0xfff) & ~0xfff;\n\n            memory_region_add_subregion(sysmem, (uint32_t)(-bios_size), bios);\n\n        } else if (!qtest_enabled()) {\n\n            error_report(\"Could not load PowerPC BIOS '%s'\", bios_name);\n\n            exit(1);\n\n        }\n\n        memory_region_set_readonly(bios, true);\n\n    }\n\n    /* Register Linux flash */\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n    if (dinfo) {\n\n        BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo));\n\n\n\n        bios_size = bdrv_getlength(bs);\n\n        /* XXX: should check that size is 32MB */\n\n        bios_size = 32 * 1024 * 1024;\n\n        fl_sectors = (bios_size + 65535) >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Register parallel flash %d size %lx\"\n\n               \" at addr \" TARGET_FMT_lx \" '%s'\\n\",\n\n               fl_idx, bios_size, (target_ulong)0xfc000000,\n\n               bdrv_get_device_name(bs));\n\n#endif\n\n        pflash_cfi02_register(0xfc000000, NULL, \"taihu_405ep.flash\", bios_size,\n\n                              bs, 65536, fl_sectors, 1,\n\n                              4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA,\n\n                              1);\n\n        fl_idx++;\n\n    }\n\n    /* Register CLPD & LCD display */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register CPLD\\n\", __func__);\n\n#endif\n\n    taihu_cpld_init(sysmem, 0x50100000);\n\n    /* Load kernel */\n\n    linux_boot = (kernel_filename != NULL);\n\n    if (linux_boot) {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"%s: load kernel\\n\", __func__);\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr,\n\n                        \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n    }\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: Done\\n\", __func__);\n\n#endif\n\n}\n", "idx": 13951, "substitutes": {"machine": ["node", "server", "instance", "money", "manager", "hard", "mode", "series", "managed", "module", "smart", "model", "check", "monitor", "engine", "mac", "command", "Machine", "cell", "m", "connection", "zone", "shell", "memory", "message", "menu", "vm", "magic", "sim", "iso", "handler", "physical", "image", "keeper", "password", "link", "mc", "host", "state", "achine", "me", "anim", "history", "controller", "process", "template", "computer"], "kernel_filename": ["kernel5file", "kernel_source", "ernel_master", "kernel_database", "ernel_base", "kernel__txt", "kernelityfile", "kernel_username", "kernel5source", "kernelingmaster", "ernel_database", "kernel_master", "kernelityfilename", "kernel__filename", "kernel__username", "kernelitydatabase", "kernel5master", "kernelingfilename", "kernel5filename", " kernel_username", "kernelphpfile", "kernelitybase", "ernel_source", "kernelphpdatabase", "kernel__file", "kernelingsource", " kernel_txt", "kernel_file", "kernelingfile", "kernelphpfilename", "ernel_filename", "kernel_txt", "ernel_file", " kernel_file", "kernelphpbase"], "initrd_filename": ["initrs_Filename", "initrs_file", "initrdmlfile", "initrd_Filename", "initrs_files", "initrd_files", "initrs_details", "initrd__file", "initrd__files", "initrdmlfilename", "initrs_filename", "initrd__processor", "initrd_file", "initrd___files", "initrd__filename", "initrdmldetails", "initrd_processor", "initrd___processor", "initrs_processor", "initrd_details", "initrd___filename", "initrd___file", "initrdmlFilename"], "filename": ["csv", "path", "sharp", "png", "Filename", "tif", "picture", "icc", "pict", "kan", "script", "Pic", "fp", "file", "fn", "pac", "bite", "kl", "fc", "fi", "kj", "tty", "sn", "sic", "txt", "til"], "pic": ["sac", "png", "spr", "icon", "pi", "p", "pol", "lib", "typ", "picture", "wic", "media", "ic", "pipe", "cam", "panic", "pa", "pict", "sp", "script", "Pic", "eric", "phot", "fn", "img", "pac", "Picture", "mc", "nic", "pc", "fc", "fi", "ics", "shot", "iac", "pan", "txt"], "sysmem": ["ysMem", "sysman", "systemm", " sysMem", " sysmb", "systemmb", "sysmemory", "ysm", "ysmb", "ysmem", "systemmemory", "sysMem", " sysm", " sysmemory", "sysm", "systemman", "ysmemory", " sysman", "systemmem", "systemMem", "sysmb", "ysman"], "bios": [" bio", "bases", "bricks", "bio", "gbases", " bases", "gbio", "Bios", "gbios", " bricks", "Bricks", "Bio", "gbricks", "Bases"], "ram_memories": ["ram_matograms", "ram_histors", "ram_cryptistries", "ram_manories", "ram_histograms", "ram_metories", "ram_sumory", "ram_temograms", "ram_memistries", "ram_memographies", "ram_manaries", "ram_messories", "ram_temors", "ram_histories", "ram_matory", "ram_messometers", "ram_matometers", "ram_memometers", "ram_cryptaries", "ram_memives", "ram_temory", "ram_histographies", "ram_sumories", "ram_memors", "ram_messory", "ram_matories", "ram_temives", "ram_memograms", "ram_cryptories", "ram_metory", "ram_histaries", "ram_cryptors", "ram_manory", "ram_matos", "ram_cryptory", "ram_history", "ram_memos", "ram_sumistries", "ram_sumaries", "ram_messos", "ram_temos", "ram_temories", "ram_temometers", "ram_manographies", "ram_memory", "ram_metaries", "ram_cryptives", "ram_mators", "ram_histives", "ram_memaries", "ram_metographies", "ram_hististries"], "ram": ["am", "path", "gra", "mem", "gem", "rw", "rad", "ra", "mic", "iam", "RAM", "row", "hw", "mode", "storage", "Ram", "lib", "raw", "reg", "sam", "md", "ru", "mac", "gb", "bin", "sys", "cpu", "rb", "scan", "cms", "cam", "m", "imus", "menu", "memory", "disk", "gram", "vm", "ruby", "dim", "rum", "mm", "gold", "ro", "base", "gc", "fat", "mc", "rom", "root", "ras", "sd", "mb", "win", "ma", "sky", "amd", "rain", "sum", "lam"], "ram_bases": ["ram_ibias", "ram_lboots", "ram_iboots", "ram_gbases", "ram___ibases", "ram_bores", "ram_ibaches", "ram_base", "ram_bas", "ram___bases", "ram_gales", "ram_beases", "ram_lasts", "ram_bales", "ram_laches", "ram___iboots", "ram_biounds", "ram_lores", "ram_bolounds", "ram_bounds", "ram_vases", "ram_voes", "ram_bones", "ram_biase", "ram_biats", "ram_biasing", "ram_basaches", "ram_bolase", "ram_bades", "ram___ibias", "ram_beones", "ram_gores", "ram_basases", "ram_basing", "ram_lias", "ram_beoes", "ram___boots", "ram_vas", "ram_vades", "ram_abaches", "ram_aboots", "ram_beores", "ram_nbias", "ram_boes", "ram_gbades", "ram_basias", "ram_bias", "ram_biases", "ram_beales", "ram_bats", "ram_lbases", "ram_abias", "ram_gases", "ram___ibaches", "ram_vias", "ram_lbias", "ram_bolats", "ram_lats", "ram_vasing", "ram_ibases", "ram_lbaches", "ram_biias", "ram_lounds", "ram___baches", "ram___bias", "ram_gbones", "ram_lales", "ram_nbases", "ram_lases", "ram_basasts", "ram_bolases", "ram_ibasts", "ram_basts", "ram_nbasing", "ram_boots", "ram_gase", "ram_lase", "ram_nbas", "ram_baches", "ram_vones", "ram_gboes", "ram_bease", "ram_abases", "ram_beades"], "ram_sizes": ["ram2mices", "ram_senses", "ram_ssists", "ram_sizing", "ram2sizes", "ram_sists", "ram_seides", "ram_sites", "ram_denses", "ram_seists", "ram_samples", "ram2sikes", "ram_ees", "ram2ses", "ram_msapes", "ram_isikes", "ram_usizes", "ram_lides", "ram_Sizes", "ram_dales", "ram_isizes", "ram_seumbers", "ram_sikes", "ram_cizes", "ram_Samples", "ram_ses", "ram__sapes", "ram_setsikes", "ram_Senses", "ram_Siz", "ram_usales", "ram_eizes", "ram_capes", "ram2seizers", "ram2sides", "ram_sizers", "ram2mizes", "ram__sites", "ram2sizers", "ram_mists", "ram_seizers", "ram2sices", "ram__sists", "ram_seiz", "ram_sapes", "ram_usamples", "ram_seizing", "ram2ssists", "ram_Sizers", "ram_stizers", "ram_sices", "ram_sses", "ram2mizers", "ram_isices", "ram_mizes", "ram_Sales", "ram_cites", "ram_lumbers", "ram__msites", "ram_seizes", "ram__msists", "ram_ssizers", "ram_sides", "ram_lizes", "ram2ssizers", "ram_setsizers", "ram_usenses", "ram_setsizes", "ram_stists", "ram2siz", "ram_lists", "ram2sists", "ram_scumbers", "ram_sales", "ram_stes", "ram_isizers", "ram_damples", "ram_liz", "ram2seiz", "ram_mizers", "ram2mikes", "ram_mikes", "ram2seizes", "ram_scizing", "ram_scists", "ram_mapes", "ram_lizing", "ram_dizes", "ram_ssizes", "ram_msizes", "ram_setsices", "ram_eists", "ram_msites", "ram_mices", "ram_sumbers", "ram2sses", "ram_msists", "ram_eizers", "ram_siz", "ram_stizes", "ram_lizers", "ram2seides", "ram_mites", "ram__msizes", "ram2ssizes", "ram__msapes", "ram_scizes", "ram__sizes", "ram_Sides", "ram_cists"], "bios_size": ["bios_Size", "bio_count", "bio_Size", "bios_count", "bio_SIZE", "bios_SIZE", "bio_size"], "kernel_base": ["kernel___size", " kernel_prefix", "kernel_scale", "kernel_prefix", "kernel___prefix", "kernel___base", "kernel___scale", " kernel_scale"], "initrd_base": ["initrs_prefix", "initrs_origin", "initrs_buffer", "initrd_prefix", "initrd_origin", "initrs_base", "initrd_buffer"], "kernel_size": ["binary_name", "kernel_name", "kernel_resolution", "kernel_speed", "binary_speed", "binary_resolution", "binary_size"], "initrd_size": ["initrd_Size", "initrd_name", "initrs_name", "initrs_Size", "initrs_size", "initrs_SIZE", "initrd_SIZE"], "linux_boot": [" linux_base", " linux_bus", "linux_base", "linuxMemBoot", "linux_bus", " linux_Boot", "linux5boot", "linux5base", "linuxMemboot", "linuxMembase", "linux5Boot", "linux5bus", "linuxMembus", "linux_Boot"], "fl_idx": ["fl_Idy", "fl_Idxf", "fl_indxc", "fl_idz", "fl_indxf", "fl_Idxc", "fl_idxc", "fl_Idz", "fl_idy", "fl_idv", "fl_indv", "fl_Idx", "fl_indz", "fl_indx", "fl_indxs", "fl_idxs", "fl_idsxs", "fl_idsx", "fl_idsy", "fl_Idv", "fl_idxf", "fl_Idxs", "fl_idsxc"], "fl_sectors": ["fl_psectors", "fl_sx", "fl_svers", "fl_severs", "fl_spevers", "fl_psecs", "fl_scs", "fl_specs", "fl_sex", "fl_secs", "fl_spex", "fl_psevers", "fl_psex", "fl_sctors", "fl_spectors"], "dinfo": ["dInfo", "dINFO", " dfo", "DInfo", "Dinfo", "Dinf", "rinf", "rinfo", " dinf", "rInfo", " dINFO", "Dno", " dInfo", "ddINFO", "rno", "DINFO", "ddinf", "rfo", "dfo", "ddinfo", "dno", "Dfo", "dinf", "ddInfo", " dno"], "bs": ["gs", "ba", "ubs", "js", "bh", "bi", "bid", "ds", "ls", "br", "bd", "BS", "bos", "bm", "bas", "bf", "ns", "bl", "cs", "bc", "lbs", "bed", "bles", "fs", "bps", "bis", "bb", "bp"]}}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static void *ff_avio_child_next(void *obj, void *prev)\n\n{\n\n    AVIOContext *s = obj;\n\n    AVIOInternal *internal = s->opaque;\n\n    return prev ? NULL : internal->h;\n\n}\n", "idx": 13969, "substitutes": {"obj": ["resp", "node", "tx", "impl", "o", "ref", "src", "out", "object", "onet", "attr", "pr", "cmd", "ctx", "j", "js", "data", "vp", "bj", "Obj", "bo", "act", "nt", "op", "info", "oj", "fn", "res", "ns", "oid", "id", "tmp", "ot", "os", "init", "txt", "ob"], "prev": [" Prev", "orig", " previous", "pres", "j", "p", "this", "cmp", "vr", "reverse", "vp", "v", "next", "before", "buf", "skip", "new", "nav", "last", "first", "parent", "current", "rev", "buffer", "sp", "inv", "pri", "pred", "wp", "Previous", "jump", "mp", "tmp", "vious", "rec", "rel", "pre", "nil", "Prev", "iv", "history"], "s": ["sis", "gs", "a", "S", "as", "o", "less", "j", "n", "p", "sq", "v", "sl", "t", "sm", "sb", "ass", "sv", "sys", "ds", "ls", "m", "r", "ssl", "ts", "sp", "c", "shared", "ins", "ns", "b", "h", "sd", "sn", "i", "ss", "sts", "rs"]}}
{"project": "qemu", "commit_id": "2886be1b01c274570fa139748a402207482405bd", "target": 1, "func": "static void pm_ioport_read(IORange *ioport, uint64_t addr, unsigned width,\n\n                            uint64_t *data)\n\n{\n\n    PIIX4PMState *s = container_of(ioport, PIIX4PMState, ioport);\n\n    uint32_t val;\n\n\n\n    switch(addr) {\n\n    case 0x00:\n\n        val = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n        break;\n\n    case 0x02:\n\n        val = s->ar.pm1.evt.en;\n\n        break;\n\n    case 0x04:\n\n        val = s->ar.pm1.cnt.cnt;\n\n        break;\n\n    case 0x08:\n\n        val = acpi_pm_tmr_get(&s->ar);\n\n        break;\n\n    default:\n\n        val = 0;\n\n        break;\n\n    }\n\n    PIIX4_DPRINTF(\"PM readw port=0x%04x val=0x%04x\\n\", (unsigned int)addr, val);\n\n    *data = val;\n\n}\n", "idx": 13988, "substitutes": {"ioport": ["ioported", "lipost", "ypport", "iopost", "ypORT", "ospport", "opost", "iopart", "yport", "opORT", "ospost", "ipart", "lipport", "osported", "liporter", "osport", "iopport", "osparent", "riported", "opart", "riporter", "ospart", "opport", "iport", "ioporter", "iparent", "liported", "ripport", "oparent", "ipost", "oport", "riport", "ypost", "osporter", "iopORT", "lipORT", "liport", "ioparent"], "addr": ["tx", "rc", "index", "nl", "type", "at", "a", "ptr", "src", "ref", "address", "attr", "cmd", "ctx", "hw", "tr", "dr", "cmp", "ord", "adr", "len", "msg", "offset", "align", "act", "tag", "r", "eth", "alt", "url", "obj", "rt", "inv", "db", "pos", "coord", "res", "ack", "start", "id", "ad", "mt", "order", "hash", "var", " address", "net", "err", "name", "str", "rs", "ix", "ip"], "data": ["bytes", "def", "ret", "out", "size", "map", "flags", "p", "n", " DATA", "window", "text", " dat", "batch", "done", "t", "cache", "buf", "bin", "bus", "m", "step", "mu", "buffer", "c", "image", "pos", "Data", "table", "dev", "pad", "length", "d", "DATA", "ata", "value", "dat", "w", "str", " Data"], "s": ["sis", "ses", "aws", "south", "gs", "a", "S", "sw", "serv", "bs", "has", "ports", "js", "params", "sq", "xs", "v", "sl", "ar", "sam", "sol", "syn", "comm", "is", "sv", "sb", "sm", "spec", "sys", "hs", "als", "ds", "ats", "ls", "sa", "iss", "services", "ies", "qs", "ts", "self", "stats", "ares", "sh", "vs", "ins", "states", "ns", "b", "cs", "h", "es", "fs", "os", "its", "parts", "ss", "sts", "ms", "actions", "rs", "ps"], "val": ["vol", "index", " value", " Val", "ctx", "stat", "len", "loc", "bil", "aval", "ann", "fee", " eval", " v", "rol", "label", "cho", "VAL", "it", "arr", "tx", "def", "mem", "ret", "pr", "crit", "pol", "fail", "v", "test", "Value", "pal", "pos", "ival", "elt", "x", "resp", "ref", "als", "eval", "buf", "al", "update", "broad", "vals", "dev", "err", "vt", "str", "valid", "Val", "local", "p", "el", "xy", "pt", "util", "msg", "num", "alt", "cal", "sel", "all", "bl", "rel", "prop", "value", "pl"]}}
{"project": "FFmpeg", "commit_id": "4d87001096ff1d4e3ee6f88f8caddbd8ccb2c816", "target": 1, "func": "static int update_dimensions(VP8Context *s, int width, int height)\n\n{\n\n    if (width  != s->avctx->width ||\n\n        height != s->avctx->height) {\n\n        if (av_image_check_size(width, height, 0, s->avctx))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        vp8_decode_flush_impl(s->avctx, 1, 0, 1);\n\n\n\n        avcodec_set_dimensions(s->avctx, width, height);\n\n    }\n\n\n\n    s->mb_width  = (s->avctx->coded_width +15) / 16;\n\n    s->mb_height = (s->avctx->coded_height+15) / 16;\n\n\n\n    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));\n\n    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));\n\n    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);\n\n    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));\n\n    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));\n\n\n\n    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||\n\n        !s->top_nnz || !s->top_border)\n\n        return AVERROR(ENOMEM);\n\n\n\n    s->macroblocks        = s->macroblocks_base + 1;\n\n\n\n    return 0;\n\n}\n", "idx": 14014, "substitutes": {"s": ["ses", "gs", "S", "bs", "ports", "storage", "sq", "ags", "sl", "t", "qs", "stats", "vs", "states", "cs", "tests", "ims", "pers", "its", "ants", "ps", "des", "sw", "n", "js", "v", "g", "comm", "spec", "ds", "ats", "services", "ies", "conf", "ains", "parts", "ers", "results", "as", "less", "bits", "scripts", "eps", "xs", "als", "sb", "er", "hs", "erences", "c", "ops", "es", "changes", "fs", "bis", "views", "sports", "ss", "comments", "aws", "ys", "ids", "details", "is", "sv", "ls", "mods", "gets", "ts", "ins", "ns", "h", "e", "sd", "os", "styles", "sts", "ms", "y", "rs"], "height": ["hang", "ty", "holes", "density", "size", "high", "row", "axy", "window", "depth", "rows", "chip", "inches", "dimension", " heights", "xy", "t", "len", "padding", "rank", "bottom", "Height", "th", "hei", "dim", "html", "resolution", "range", "stroke", "image", "capacity", "ht", "volume", "alpha", "crop", "h", "grow", "ows", "hash", "length", "gravity", "shape", "total", "sky", "it", "max", "gy", "above", "y", "angle", "history", "ch"]}}
{"project": "qemu", "commit_id": "01b05c66a3616d5a4adc39fc90962e9efaf791d1", "target": 1, "func": "int nbd_receive_reply(QIOChannel *ioc, NBDReply *reply, Error **errp)\n\n{\n\n    int ret;\n\n    const char *type;\n\n\n\n    ret = nbd_read_eof(ioc, &reply->magic, sizeof(reply->magic), errp);\n\n    if (ret <= 0) {\n\n        return ret;\n\n    }\n\n\n\n    be32_to_cpus(&reply->magic);\n\n\n\n    switch (reply->magic) {\n\n    case NBD_SIMPLE_REPLY_MAGIC:\n\n        ret = nbd_receive_simple_reply(ioc, &reply->simple, errp);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n\n\n        trace_nbd_receive_simple_reply(reply->simple.error,\n\n                                       nbd_err_lookup(reply->simple.error),\n\n                                       reply->handle);\n\n        if (reply->simple.error == NBD_ESHUTDOWN) {\n\n            /* This works even on mingw which lacks a native ESHUTDOWN */\n\n            error_setg(errp, \"server shutting down\");\n\n            return -EINVAL;\n\n        }\n\n        break;\n\n    case NBD_STRUCTURED_REPLY_MAGIC:\n\n        ret = nbd_receive_structured_reply_chunk(ioc, &reply->structured, errp);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n        type = nbd_reply_type_lookup(reply->structured.type);\n\n        trace_nbd_receive_structured_reply_chunk(reply->structured.flags,\n\n                                                 reply->structured.type, type,\n\n                                                 reply->structured.handle,\n\n                                                 reply->structured.length);\n\n        break;\n\n    default:\n\n        error_setg(errp, \"invalid magic (got 0x%\" PRIx32 \")\", reply->magic);\n\n        return -EINVAL;\n\n    }\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 14022, "substitutes": {"ioc": [" iot", "pioint", "inec", "uoci", "oog", "inosc", "ooc", "iocal", " iocal", "ioint", "pioc", "oosc", "biot", "bioc", "ioci", "uec", "oOC", "iog", "inocal", "iot", " iog", " iOC", " ioci", "inoc", "piOC", "oocl", "uot", "piocl", "iOC", "uoc", " iocl", "iec", "oot", "biec", " iosc", "iocl", "ooint", "oocal", "oec", " ioint", " iec", "bioci", "biog", "iosc", "biOC"], "reply": ["notice", "display", "py", "query", "role", "embed", "ror", "ping", "policy", "command", "pipe", "send", "line", "vote", "match", "attribute", "quote", "related", "invoke", "pty", "repl", "see", "transfer", "patch", "apply", "address", "cmd", "pop", "module", "reset", "try", "next", "note", "job", "part", "shell", "comment", "Reply", "support", "link", "sync", "print", "report", "join", "review", "resp", "proxy", "record", "mi", "call", "req", "service", "write", "info", "remote", "answer", "plugin", "se", "rr", "status", "request", "route", "play", "bro", "response", "repair", "rule", "details", "ply", "frame", "message", "replace", "prefix", "parse", "post", "article", "reason", "ve", "detail", "onse"], "errp": [" errpkg", "rerpt", "errpkg", "errps", "aerpa", "serpb", "aerP", "rrpp", "aerping", "derpa", "rerm", "serP", "ferp", "aerper", "ererp", " errpa", "ferP", "rerpa", " errps", "ferpc", " errm", "errper", "errping", "errpb", " errP", "aerp", "errm", "rrping", "rerp", "errP", "serpa", "ferpkg", "derm", " errpc", "ererP", "ererpb", "ererpkg", "rrp", " errper", "aerpp", "aerps", "derpt", "rrP", "derp", "rrpb", "rrper", " errpt", " errpp", "aerpb", "errpc", "rrps", "serp", "rrpkg", " errpb", "ererpc", "errpp", "errpt", " errping", "errpa"], "ret": ["pret", "fun", "back", "expr", "val", "port", "vet", "t", "len", "rm", "result", "end", "nt", "nat", "att", "rev", "Return", "it", "net", " Ret", "usr", "cont", "arr", "rem", "def", "quad", "mem", "ptr", "cmd", "round", "old", "tr", "RET", "reset", "dt", "try", "prot", "cat", "rect", "res", "print", "ber", "mt", "elt", "x", "xt", "ter", "txt", "out", "ref", " alt", "inter", "Ret", "rets", "rest", "gt", "ry", "iter", "ft", "str", "status", " RET", "det", "deg", "reg", "ext", "desc", "alt", "last", "rt", "rier", "code", "rot", "lt", "cert", "re", "col", "format", "final"], "type": ["types", "index", "error", "ty", "Type", " name", "sort", "version", "number", " t", "handle", " typ", " error", "p", "sequence", "relation", "class", "role", "what", "module", "group", "typ", "ror", "check", "test", "port", "field", "t", "unit", "ping", "kind", " TYPE", "offset", "tag", "r", " other", "message", "time", "info", "TYPE", "rt", " ty", "buffer", "sp", "handler", "file", " kind", "code", "link", "action", "ype", "id", "area", "rel", "trace", "length", "tp", "style", "format", "q", " Type", "value", "interface", "cast", "target", "name", "level", "pe"]}}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static void ne2000_receive(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    NE2000State *s = opaque;\n\n    uint8_t *p;\n\n    int total_len, next, avail, len, index, mcast_idx;\n\n    uint8_t buf1[60];\n\n    static const uint8_t broadcast_macaddr[6] = \n\n        { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n    \n\n#if defined(DEBUG_NE2000)\n\n    printf(\"NE2000: received len=%d\\n\", size);\n\n#endif\n\n\n\n    if (!ne2000_can_receive(s))\n\n        return;\n\n    \n\n    /* XXX: check this */\n\n    if (s->rxcr & 0x10) {\n\n        /* promiscuous: receive all */\n\n    } else {\n\n        if (!memcmp(buf,  broadcast_macaddr, 6)) {\n\n            /* broadcast address */\n\n            if (!(s->rxcr & 0x04))\n\n                return;\n\n        } else if (buf[0] & 0x01) {\n\n            /* multicast */\n\n            if (!(s->rxcr & 0x08))\n\n                return;\n\n            mcast_idx = compute_mcast_idx(buf);\n\n            if (!(s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))))\n\n                return;\n\n        } else if (s->mem[0] == buf[0] &&\n\n                   s->mem[2] == buf[1] &&                   \n\n                   s->mem[4] == buf[2] &&            \n\n                   s->mem[6] == buf[3] &&            \n\n                   s->mem[8] == buf[4] &&            \n\n                   s->mem[10] == buf[5]) {\n\n            /* match */\n\n        } else {\n\n            return;\n\n        }\n\n    }\n\n\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    index = s->curpag << 8;\n\n    /* 4 bytes for header */\n\n    total_len = size + 4;\n\n    /* address for next packet (4 bytes for CRC) */\n\n    next = index + ((total_len + 4 + 255) & ~0xff);\n\n    if (next >= s->stop)\n\n        next -= (s->stop - s->start);\n\n    /* prepare packet header */\n\n    p = s->mem + index;\n\n    s->rsr = ENRSR_RXOK; /* receive status */\n\n    /* XXX: check this */\n\n    if (buf[0] & 0x01)\n\n        s->rsr |= ENRSR_PHY;\n\n    p[0] = s->rsr;\n\n    p[1] = next >> 8;\n\n    p[2] = total_len;\n\n    p[3] = total_len >> 8;\n\n    index += 4;\n\n\n\n    /* write packet data */\n\n    while (size > 0) {\n\n        avail = s->stop - index;\n\n        len = size;\n\n        if (len > avail)\n\n            len = avail;\n\n        memcpy(s->mem + index, buf, len);\n\n        buf += len;\n\n        index += len;\n\n        if (index == s->stop)\n\n            index = s->start;\n\n        size -= len;\n\n    }\n\n    s->curpag = next >> 8;\n\n\n\n    /* now we can signal we have receive something */\n\n    s->isr |= ENISR_RX;\n\n    ne2000_update_irq(s);\n\n}\n", "idx": 14023, "substitutes": {"opaque": ["spacity", "spity", "opane", "oity", "spaque", "oane", "opacity", " opque", "Opaque", "Opacity", "ipas", "oaque", "Opane", "oacity", " oplay", "opity", "ipaque", "iplay", "opas", "OPlay", "ipque", "opque", "OPaque", "oplay", "OPas", "Opity", "OPque", " opas", "spane"], "buf": ["vec", "orig", "cur", "ctx", "window", "raw", "pool", "doc", "cb", "foo", "emb", "uf", "queue", "pkg", "lim", "arr", "ait", "tx", "pack", "mem", "ptr", "ff", "data", "map", "cmd", "aka", "Buffer", "conv", "v", "box", "buff", "br", "obj", "fb", "que", "db", "cp", "tmp", "txt", "Buff", "seq", "wb", "proc", "batch", "rb", "buffer", "block", "cv", "bf", "bc", "iter", "cast", "str", "bar", "bytes", "good", "pb", "deg", "msg", "cache", "bin", "cap", "ext", "func", "xff", "cam", "desc", "bag", "bu", "img", "b", "bl", "prop", "nm"], "size": ["notice", "Size", "shift", "storage", "new", "send", "fee", " Size", "limit", "length", "shape", "sn", "sent", "sum", "type", "mem", "number", "address", "data", "n", "timeout", "g", "padding", "space", "pos", "scale", "set", "total", " sizes", "scroll", "SIZE", "height", "ize", "now", "offset", "empty", "buffer", "c", "small", "bytes", "body", "min", "cache", "num", "message", "sp", "count", "password", "code", "no", "max", "z", "news", "name"], "s": ["sis", "ses", "gs", "S", "bs", "sq", "sl", "sam", "t", "m", "ssl", "qs", "stats", "vs", "cs", "ims", "its", "sn", "ps", "sw", "n", "js", "g", "http", "comm", "spec", "space", "ds", "ats", "so", "self", "ears", "set", "conf", "ains", "ers", "i", "server", "as", "less", "scripts", "store", "sm", "sb", "service", "als", "sys", "hs", "c", "es", "changes", "fs", "events", "state", "bis", "d", "se", "ss", "aws", "serv", "o", "is", "sv", "ls", "mods", "gets", "ts", "sp", "ns", "b", "h", "e", "os", "z", "sets", "sts", "ms", "y", "rs"], "p": ["jp", "ptr", "f", "o", "pb", "j", "n", "x", "vp", "v", "g", "pt", "t", "pp", "np", "P", "m", "op", "r", "rep", "sp", "c", "lp", "fp", "pos", "wp", "ap", "cp", "b", "po", "h", "pc", "pre", "ip", "pkg", "i", "tp", "pa", "pointer", "ps"], "total_len": ["total67Len", "full_Len", "total67len", "public_len", "equalaxylen", "public_lif", "public67lif", "total_length", "equal_len", "total67ll", "total_den", "public_Len", "total_mem", "totalaxyden", "equalaxyLen", "full_mem", "total_ll", "total_lif", "total_Len", "totalaxylength", "total_lang", "equal_Len", "public67Len", "public_lang", "public67lang", "full_ll", "equalaxylength", "total67lang", "equal_length", "equal_den", "totalaxylen", "equalaxyden", "totalaxyLen", "public67len", "total67lif", "full_len", "total67mem"], "next": ["jp", "path", "li", "shift", "ptr", "route", "prev", "position", "Next", "success", "head", "ind", "seq", "j", "sequence", "n", "timeout", "min", "after", "ng", "big", "gen", "loc", "pointer", "sec", "end", "skip", "new", "offset", "forward", "future", "front", "last", "first", "current", "pos", "page", "link", "limit", "start", "dev", "jump", "iter", "max", "length", "ne", "net", "z", "i"], "avail": ["apile", "avay", "apail", "vail", "capail", "apend", "capile", "vay", "capay", "apay", "capend", "avend", "vile", "vend", "avile"], "len": ["il", "vec", "mem", "late", "Len", "ll", "l", "fin", "fun", "n", "lib", "min", "el", "loc", "cap", "offset", "ls", "line", "lp", "pos", "en", "limit", "lan", "label", "length", "elt", "lim"], "index": ["key", "path", "error", "axis", "route", "position", "address", "ind", "addr", "head", "row", "n", "x", "j", "si", "val", "stop", "loc", "initial", "end", "Index", "new", "offset", "num", "lock", "line", "add", "info", "find", "open", "buffer", "block", "pos", "page", "link", "start", "id", "slice", "set", "point", "iter", "seek", "max", "length", "cycle", "init", "i", "ix", "ip"], "mcast_idx": ["mcast2Idxs", "mcast_midz", "mcast_ing", "mcast_txx", "mcast_idix", "mcast_Idg", "mcast2idx", "mcast_indz", "mcast_ridz", "mcast_Idc", "mcast_midc", "mcast_idc", "mcast_txct", "mcast_idsc", "mcast_Idz", "mcast_ridx", "mcast_ridxc", "mcast_indc", "mcast2Idz", "mcast_midct", "mcast_modxc", "mcast_txc", "mcast_Idxs", "mcast_idsx", "mcast_midxf", "mcast_midxc", "mcast_txz", "mcast_ridxs", "mcast_indg", "mcast_modx", "mcast_idz", "mcast2idxs", "mcast_idxf", "mcast_inx", "mcast2idz", "mcast_midx", "mcast_idsct", "mcast_ridxf", "mcast_idsz", "mcast_ridix", "mcast_idxc", "mcast_modix", "mcast_inz", "mcast2Idx", "mcast_idct", "mcast_midix", "mcast_indx", "mcast_inc", "mcast_idxs", "mcast_modxf", "mcast_Idx", "mcast_idg"], "buf1": [" buffer1", "uf3", " buffer2", " buf3", "uf0", "uf2", "buff3", "uf1", "buff0", " buffer0", "buf4", "vec3", "buf2", " buf2", "buf0", "buffer0", " buf4", "buff4", "vec1", " buf0", "vec4", "uf4", "buffer1", "buffer2", " buffer3", "buff1", "buff2", "buf3", "vec0"], "broadcast_macaddr": ["broadcast_ipref", "broadcast_MACref", "broadcast_microaddress", "broadcast_MACaddr", "broadcast_macaddress", "broadcast_ipaddress", "broadcast_microorder", "broadcast_micaddr", "broadcast_macref", "broadcast_micorder", "broadcast_macorder", "broadcast_micref", "broadcast_micaddress", "broadcast_microaddr", "broadcast_MACaddress", "broadcast_ipaddr"]}}
{"project": "FFmpeg", "commit_id": "f264d336fe61c12ce9607c3060aa5d3dca947c61", "target": 1, "func": "static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)\n\n{\n\n    int16_t tmp[146 + 60], *ptr0, *ptr1;\n\n    const int16_t *filter;\n\n    int i, t, off;\n\n\n\n    t = dec->offset2[quart];\n\n    if(t == 127){\n\n        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));\n\n        return;\n\n    }\n\n    for(i = 0; i < 146; i++)\n\n        tmp[i] = dec->filtbuf[i];\n\n    off = (t / 25) + dec->offset1[quart >> 1] + 18;\n\n\n    ptr0 = tmp + 145 - off;\n\n    ptr1 = tmp + 146;\n\n    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;\n\n    for(i = 0; i < 60; i++){\n\n        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;\n\n        ptr0++;\n\n        dec->newvec[i] = t;\n\n        ptr1[i] = t;\n\n    }\n\n}", "idx": 14024, "substitutes": {"quart": ["quarter", "qu", "quad", "hart", "frac", "crit", "ant", "opt", "mint", "aq", "qua", "clock", "cart", "ox", "ext", "ct", "pound", " quot", " quant", "quet", "qa", "minute", "pie", "quick", "rt", " quint", "art", "pocket", "rot", "crop", "quant", "point", "foo", "ART", "minus", " Quart", "qt", "percent", "amp", "integer", "q", "ilt", " quarter", "qq", "butt", "aqu", "nut"], "tmp": [" tcp", "jp", "td", "utm", "ptr", "array", "out", "adjusted", "offs", "data", "map", "ctx", "tt", "p", "cmp", "temp", "sq", "mint", "mk", "v", "test", " np", "util", "cache", "buf", "buff", "np", "new", "gb", "qq", "op", "snap", "obj", "aux", "prefix", "buffer", "sp", "up", "db", "tf", "empty", "img", "rot", "ap", "wp", "cp", "table", " mp", "mp", "etc", "ot", "total", "uv", "mb", "uf", "emp", "pkg", "zero", "txt", "ob"], "ptr0": ["attr1", "attrNR", "prime0", " ptr00", "pr10", "Ptr00", "pert047", "Ptr0", "pr256", "ptr047", "attr0", "prime6", "pertNR", "loc1", "PtrZero", "ptr10", "loc00", " ptr10", "Ptr047", "ptr2", " ptr2", "loc0", "Ptr2", "pert0", "Ptr8", "Ptr1", "attr047", "ptr6", "prime1", "locZero", " ptr256", "pt1", "PtrNR", " ptr8", "pt2", "pr1", "Ptr6", " ptrZero", "ptr8", "pt0", "pert1", "pr0", "ptrZero", "pr6", "ptr00", "pt8", "ptr256", "pt256", "ptrNR", "pt10"], "ptr1": ["ptrb", "pointers1", "Ptrb", "pertb", "Ptr4", "pointers6", "Ptr0", "pert6", "primeone", "ptr100", "Ptr3", "ptr2", "pointersb", "pointer0", "Ptr2", "prime2", "pert0", "expr1", "Ptr1", "ptr6", "prime1", "ptr4", "prime100", "pt1", "expr2", "pointer4", "pointers0", "Ptr6", "pointer1", "ptr3", "pt4", "pt0", "pert1", "Ptr100", "exprone", "Ptrone", "ptrone", "pointer3", "pt3", "expr100"], "filter": ["profile", "burn", "sort", "type", "f", "cond", "ff", "search", "map", "mask", "p", "tr", "tail", "v", "user", "check", "test", "batch", "bt", "skip", "fl", "offset", "cut", "pipe", "ct", "select", "tag", "fil", "condition", "channel", "control", "match", "attribute", "buffer", "block", "tf", "limit", "flag", "table", "alpha", "aff", "fac", "term", "transform", "ft", "Filter", "list", "hash", "config", "format", "style", "q", "ilt", "join", "only", "ch", "pack"], "i": ["index", "cli", "ai", "m", " I", "s", "qi", "xi", "client", "it", "ji", "us", "li", "oi", "ind", "j", "n", "ki", "si", "zi", "v", "g", "ui", "iq", " bi", "im", "print", "ti", "x", "span", "ic", "ix", "ip", "ij", "key", "ii", "mi", "I", "pi", "this", "di", " ii", "in", "ie", "sim", "itime", "ci", "you", "id", "iter", "u", "multi", "me", "iat", "status", "ni", "iu", "o", "ski", " j", "ini", "l", "ei", "uri", "p", "chain", "bi", "is", "asi", "hi", "\u0438", "gi", "q", "phi", "init", "y"], "t": ["ty", "type", "tg", "at", "tc", "f", "tu", "o", "a", "l", "tt", "p", "tr", "n", "tif", "temp", " T", "opt", "typ", "mint", "dt", "v", "x", "g", "test", "pt", "wt", "title", "offset", "tree", "m", "T", "s", "got", "rt", "ts", "c", "tf", "tz", "tw", "h", "term", "ti", "tar", "trace", "ot", "it", "d", "tip", "qt", "to", "total", "q", "fort", "vt", "ta", "tm", "tp", "te", "txt", "tap", "iat"], "off": ["a", "shift", "f", "et", "o", "out", "offs", "det", "ff", "onet", "pres", "j", "n", "p", "Offset", "ut", "after", "Off", "v", "pt", "len", "ox", "bo", "origin", "end", "ext", "offset", "now", "OFF", "nt", "m", "oa", "open", "art", "opp", "pos", "aft", "ap", "on", "aff", "start", "ot", "from", "it", "length", "pad", "ta"]}}
{"project": "qemu", "commit_id": "ad2d30f79d3b0812f02c741be2189796b788d6d7", "target": 1, "func": "static void scsi_disk_purge_requests(SCSIDiskState *s)\n\n{\n\n    SCSIDiskReq *r;\n\n\n\n    while (!QTAILQ_EMPTY(&s->qdev.requests)) {\n\n        r = DO_UPCAST(SCSIDiskReq, req, QTAILQ_FIRST(&s->qdev.requests));\n\n        if (r->req.aiocb) {\n\n            bdrv_aio_cancel(r->req.aiocb);\n\n        }\n\n        scsi_remove_request(r);\n\n    }\n\n}\n", "idx": 14025, "substitutes": {"s": ["aws", "ses", "south", "gs", "S", "serv", "less", "p", "n", "js", "v", "comm", "als", "spec", "is", "sb", "space", "hs", "sys", "ds", "ls", "ess", "ts", "self", "c", "sp", "stats", "ns", "ops", "h", "es", "fs", "conf", "os", "d", "sts", "ss", "y", "rs", "ps"], "r": ["rc", "rem", "cr", "request", "rw", "rn", "hr", "usr", "attr", "pr", "j", "response", "p", "mr", "dr", "or", "reb", "req", "vr", "rf", "rar", "ar", "t", "er", "rm", "end", "result", "rb", "item", "br", "obj", "rt", "c", "inv", "run", "ro", "rh", "all", "sr", "ry", "res", "rg", "b", "h", "re", "rec", "fr", "rd", "repl", "u", "d", "err", "q", "rx", "R", "rr", "rs"]}}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static int net_slirp_init(VLANState *vlan)\n\n{\n\n    if (!slirp_inited) {\n\n        slirp_inited = 1;\n\n        slirp_init();\n\n    }\n\n    slirp_vc = qemu_new_vlan_client(vlan, \n\n                                    slirp_receive, NULL);\n\n    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), \"user redirector\");\n\n    return 0;\n\n}\n", "idx": 14031, "substitutes": {"vlan": [" vLAN", "vul", "vehLAN", " vlif", "vane", "vlu", " vul", "vehlif", "svlan", "VLAN", "svlu", "vlay", "Vul", "Vlu", " vlu", "vehane", "Vlan", "Vlif", "Vane", "svul", "svlay", " vlay", "vehlan", "Vlay", "vLAN", "vlif", " vane"]}}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int pnm_decode_header(AVCodecContext *avctx, PNMContext * const s){\n\n    char buf1[32], tuple_type[32];\n\n    int h, w, depth, maxval;;\n\n\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    if (!strcmp(buf1, \"P4\")) {\n\n        avctx->pix_fmt = PIX_FMT_MONOWHITE;\n\n    } else if (!strcmp(buf1, \"P5\")) {\n\n        if (avctx->codec_id == CODEC_ID_PGMYUV) \n\n            avctx->pix_fmt = PIX_FMT_YUV420P;\n\n        else\n\n            avctx->pix_fmt = PIX_FMT_GRAY8;\n\n    } else if (!strcmp(buf1, \"P6\")) {\n\n        avctx->pix_fmt = PIX_FMT_RGB24;\n\n    } else if (!strcmp(buf1, \"P7\")) {\n\n        w = -1;\n\n        h = -1;\n\n        maxval = -1;\n\n        depth = -1;\n\n        tuple_type[0] = '\\0';\n\n        for(;;) {\n\n            pnm_get(s, buf1, sizeof(buf1));\n\n            if (!strcmp(buf1, \"WIDTH\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                w = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"HEIGHT\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                h = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"DEPTH\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                depth = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"MAXVAL\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                maxval = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"TUPLETYPE\")) {\n\n                pnm_get(s, tuple_type, sizeof(tuple_type));\n\n            } else if (!strcmp(buf1, \"ENDHDR\")) {\n\n                break;\n\n            } else {\n\n                return -1;\n\n            }\n\n        }\n\n        /* check that all tags are present */\n\n        if (w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tuple_type[0] == '\\0')\n\n            return -1;\n\n        avctx->width = w;\n\n        avctx->height = h;\n\n        if (depth == 1) {\n\n            if (maxval == 1)\n\n                avctx->pix_fmt = PIX_FMT_MONOWHITE;\n\n            else \n\n                avctx->pix_fmt = PIX_FMT_GRAY8;\n\n        } else if (depth == 3) {\n\n            avctx->pix_fmt = PIX_FMT_RGB24;\n\n        } else if (depth == 4) {\n\n            avctx->pix_fmt = PIX_FMT_RGBA32;\n\n        } else {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    } else {\n\n        return -1;\n\n    }\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    avctx->width = atoi(buf1);\n\n    if (avctx->width <= 0)\n\n        return -1;\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    avctx->height = atoi(buf1);\n\n    if (avctx->height <= 0)\n\n        return -1;\n\n    if (avctx->pix_fmt != PIX_FMT_MONOWHITE) {\n\n        pnm_get(s, buf1, sizeof(buf1));\n\n    }\n\n\n\n    /* more check if YUV420 */\n\n    if (avctx->pix_fmt == PIX_FMT_YUV420P) {\n\n        if ((avctx->width & 1) != 0)\n\n            return -1;\n\n        h = (avctx->height * 2);\n\n        if ((h % 3) != 0)\n\n            return -1;\n\n        h /= 3;\n\n        avctx->height = h;\n\n    }\n\n    return 0;\n\n}\n", "idx": 14056, "substitutes": {"avctx": ["avjac", "obconn", "vertx", "avtx", "iverctx", "avcmp", " avreq", "abcmd", "verconn", "avcu", "navtx", "ahcu", "vrctx", "navctx", " avconn", "navcmp", "avcontext", "Avcontext", "airctx", "iverjac", "obcu", "afreq", "airjac", "aircontent", "aircpu", "vercp", " avcmd", "afcmp", " avtx", "avecontext", "avcomm", "avcp", "obcomm", "vrcpu", "obctx", "aftx", " avcomm", "avcontent", "abcontext", "vercontext", "afctx", "avreq", "vrcontent", "avectx", "ahcomm", "ahctx", " avcp", "avcmd", "vercmd", "avetx", "ivercontent", "avcpu", "ivercpu", "vrjac", "verctx", " avcmp", "abctx", "Avctx", "avconn", "Avcp", "abcmp", "vercmp", " avcu", " avcontext", "ahconn", "abconn", "Avconn", "navreq", "aveconn", "abtx"], "s": ["csv", "sql", "ses", "south", "gs", "S", "sw", "settings", "as", "socket", "ctx", "n", "js", "sq", "conv", "css", "us", "is", "sb", "er", "space", "sys", "hs", "ds", "ats", "obj", "ssl", "qs", "sc", "ts", "self", "c", "stats", "ations", "ins", "ns", "b", "cs", "es", "an", "ims", "fs", "conf", "os", "bis", "ains", "its", "ants", "q", "ss", "x", "scl", "sts", "rs", "ps"], "buf1": ["vecOne", "buf15", "bag3", "Buff2", "uf11", "tmp1", "bag1", " buffer2", "buff001", " buf3", "ufache", "ufed", "que15", "pool3", "pkgOne", "bufed", "uf8", "aka15", "bu21", "cache001", "buff15", "buff21", "pool11", "aka3", " buf8", "bufache", "vec1", "ufaj", "bufone", "buffer1", "pkg2", " buffer3", "bu15", "bu0", "aka1", "cbOne", "uf21", "iterator1", "cam2", "imgOne", "uf01", "cmdone", " buffer1", "buf7", "Buffaj", "buache", "que1", "uf3", "ufable", "vecone", "braceache", "uf0", "pkg1", "buffOne", "uf1", "Buff1", "buffaj", "buf2", "cache0", "buf512", "Buff3", "bufn", "brace1", "vec2", "buff100", "buffern", "buable", "img1", "buf01", "batch1", "pkgone", "bagaj", "buffache", "cam0", "buff3", "img15", "bu1", "buf100", "vec3", "tmp3", "cmd1", "buone", "buf0", "cmd0", "buf11", "buffn", " buf0", "uf15", "ufone", "bu512", "bufable", "buffer2", " bufn", "buff512", "buff1", "poolone", "buffone", "buf8", "bag0", "ufn", "img3", "buf3", "iteratorache", "vec11", "buf21", "cmd2", "akaable", "cache1", "bufaj", "uf512", "batchone", "cb100", "uf2", "buff7", "uf001", "cb1", "bufOne", "buff0", "cb3", "aka01", "braceed", " buffer8", "pool1", " buf2", "buf001", "bu100", "bu3", "uf7", " buf7", "buffer0", "tmpOne", "iteratored", " bufOne", "tmp2", "buOne", "Buff001", "batch3", "que01", "ufOne", "cache3", "buff2", "bu2", "cam1", "batchache", "camOne", "buffer3"], "tuple_type": ["tour_type", "tour2type", "tuple2name", "cont", "def", "tuple_val", "tour_Type", "conv", "tuple2val", "tuple2Type", "tuple__val", "tuple_types", "tour2Type", "tuple__types", "tour2types", "tuple2types", "tuple__Type", "tuple_name", "tour_types", "tour2val", "tuple2type", "tuple__type", "func", "tuple_Type", "tour_val", "_"], "h": ["wh", "ph", "hr", "l", "hz", "high", "p", "n", "hm", "hw", "bh", "hal", "j", "dr", "v", "height", "g", "t", "len", "ih", "hs", "k", "m", "r", "he", "hi", "html", "c", "oh", "sh", "ht", "b", "H", "id", "hl", "d", "z", "q", "i", "x", "y", "ch", "hp"], "w": ["kw", "ww", "wh", "fw", "nw", "sw", "rw", "wx", "aw", "l", "hw", "wb", "window", "n", "p", "wl", "v", "wal", "words", "g", "height", "wa", "wt", "m", "r", "iw", "work", "wid", "we", "wp", "wd", "W", "wi", "wr", "d", "z", "q", "x", "wat"], "depth": ["path", "type", "deep", "metadata", "ptr", "ths", "hr", "p", "window", "dr", "reverse", "where", "dir", "v", "height", "t", "padding", "wcs", "stack", "tree", "m", "r", "Depth", "th", "hi", "context", "time", "dim", "dq", "debug", "volume", "scale", "root", "dev", "trace", "max", "length", "d", "hash", "weight", "q", "pkg", "level", "history", "ps"], "maxval": [" maxVal", "lastval", "maxvals", "MAXval", "MAXVAL", "MAXvalue", "Maxval", "Maxvalue", "MAXVal", "maxvalue", "maxVAL", " maxVAL", "MaxVAL", " maxvals", "lastVal", "Maxvals", " maxvalue", "maxVal", "lastVAL", "MAXvals", "lastvalue"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,\n\n                            int len, int is_write)\n\n{\n\n    return address_space_rw(&address_space_memory, addr, buf, len, is_write);\n\n}\n", "idx": 14076, "substitutes": {"addr": ["tx", "index", "at", "ptr", "et", "ref", "src", "inter", "handle", "address", "ind", "cmd", "ctx", "hw", "ag", "attr", "mk", "adr", "store", "loc", " plat", "offset", "align", "act", "r", "eth", "off", "add", "rt", "pos", "coord", "on", "ack", "urg", "ad", "pad", "to", " address", "dh", "err", "target", "pkg", "ix", "alloc", "Address"], "buf": ["Buff", "bar", "bytes", "vec", "mem", "ptr", " buffers", "ref", "data", "map", "seq", "cmd", " vec", "window", "aka", "Buffer", "batch", " buffer", "msg", "buff", "buffer", "block", "cb", "cv", "bf", "img", "b", "bc", " buff", "pad", "uf", "queue", "cast", "alloc", "arr"], "len": ["bytes", "lim", "nl", "mem", "lf", "Len", "size", "seq", "l", "fun", "n", "ln", "lib", "sl", "el", "le", " clen", "fl", "nt", "fil", "lis", "lp", "pos", "en", "lan", "kl", "un", "h", "rel", "hl", "length", "elt", "fin", "coll", " length", "ld"], "is_write": ["is__set", " is_only", " is_w", " is_Write", "is__only", "is_set", "is_w", "is_read", " is_read", " is_set", "is__write", "is__Write", "is_Write", "is_only"]}}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_link(void *opaque)\n\n{\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n    int32_t dfid, oldfid;\n\n    V9fsFidState *dfidp, *oldfidp;\n\n    V9fsString name;\n\n    size_t offset = 7;\n\n    int err = 0;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n\n\n    dfidp = get_fid(pdu, dfid);\n\n    if (dfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    oldfidp = get_fid(pdu, oldfid);\n\n    if (oldfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out;\n\n    }\n\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n\n    if (!err) {\n\n        err = offset;\n\n    }\n\nout:\n\n    put_fid(pdu, dfidp);\n\nout_nofid:\n\n    v9fs_string_free(&name);\n\n    complete_pdu(s, pdu, err);\n\n}\n", "idx": 14090, "substitutes": {"opaque": ["ocaque", "pvious", "popatile", "iopaque", "iopvious", "ocatile", "ocque", "ocacity", "opacity", "popaque", "pque", "ioposit", "oppaque", "ropque", "roposit", "ropvious", "oposit", "ropaque", "oppacity", "popque", "opvious", "opatile", "oppque", "paque", "iopque", "opque", "popacity", "oppatile", "posit"], "pdu": ["apdem", "pu", "cuu", "ppder", "Pdem", "pci", "Pdu", "psue", "produ", "ppdu", "prda", "pingtu", "pud", "pdem", "pscu", "pda", "prtu", "ipdu", "ipu", "psdu", "cso", "pstu", "psder", " psu", "opdu", " Psu", "ppdi", " Pud", "opcu", "pue", "apsu", "ipud", "prdu", "psdi", "pptu", " pui", " pud", "pui", "apdu", "ipda", "apso", "pingdu", "pcu", "pder", " puu", " pdef", "pingud", "cpdef", "quu", "perdef", "mud", "ppui", "pdi", "iptu", "prud", "puu", "psow", "mdu", "optu", "psu", "mda", "cpdu", " ptu", "pso", "pdef", " pso", "pertu", "cpue", "Psu", "qso", "psci", "ppue", "qtu", "pingsu", "pju", " pue", "apud", " pdem", "ptu", "Pui", "prosu", " Pdu", " Pju", " pci", "persu", "perud", "proud", "Pso", "Pue", "ctu", "Ptu", " pju", " pder", "cdu", "ipcu", "aptu", "prow", " pdi", "qdu", "perdu", "cpud", "perue", "prci", "proju", "opu", "mtu"], "s": ["gs", "a", "S", "f", "as", "bs", "o", "less", "session", "n", "p", "js", "sq", "v", "g", "t", "is", "sb", "sm", "sv", "sys", "ds", "m", "r", "ies", "ts", "c", "sp", "stats", "ins", "ns", "b", "cs", "h", "es", "set", "e", "fs", "sg", "os", "state", "d", "z", "i", "ss", "y", "rs", "ps"], "dfid": ["pdfhide", "dxID", "fdID", " dfh", "dfhide", "pdfand", "dfoid", "dfand", " dfpid", "dxpid", "DFID", "diskand", "ufident", " dfip", "fdh", "ufID", "lfh", "fdid", "fdident", "dxid", "DFid", "fphide", "dfh", "lfID", "dfpid", "fpoid", "dfip", "pdfoid", " dfident", "fpand", " dfID", " defid", "pdfid", " defpid", "dxip", "diskoid", "diskid", "ufid", "diskhide", "dfident", "dfID", "DFident", " defID", "lfident", "fpid", "lfid", " defip"], "oldfid": [" oldfids", "oldfsid", "oldvide", "olderFid", "olderfId", "oldvID", "oldvbid", " oldFId", "olderFID", "oldifid", "oldvid", " oldfide", "oldfdids", " oldfId", " oldFid", "oldfsids", "oldifId", "oldfide", "oldfdid", "oldFId", "oldfsID", "oldFbid", "oldferid", "oldferide", "oldFide", "oldfdbid", "oldfId", "olderfid", "oldfbid", " oldFids", "oldfID", "oldvids", "olderFId", " oldvide", "oldfdId", "oldfsId", "oldifID", "oldvId", "oldFids", "oldfids", "oldFid", "oldFID", "olderFids", " oldvId", "olderfids", " oldvid", "oldferId", "olderfID", " oldFbid", " oldfbid"], "dfidp": ["dfcharp", "definedmidp", "dfidj", "definedmidpa", "dfkidpc", "definedmidpy", "dfmidpa", "dfidpid", " dfidh", "dfmidpy", "dfidpp", "dfinitp", "dfkidp", "dfsidlp", "dfidm", " dfoidpa", "definedidp", "dfidentp", "dfidphp", " dfkidh", "dfidep", "dfidlp", "dfinitps", "dfhidepa", "dfsidpid", "dfoidpa", "cfidentwp", "dfidepa", "dfinitwp", "dfkidps", "dfhidep", "dfsidm", "definedmidphp", " dfidpa", "tfidentp", "dfidentm", "tfidentpid", "dfidentpc", "tfidpid", " dfidpp", "dfidwp", "tfidentm", "dfkidh", "dfidlike", "dfsidp", "cfidp", "tfidlp", "tfidp", " dfkidj", "dfidephp", " dfoidp", "dfidentlp", " dfkidp", "dfhidepy", "tfidm", "dfmidp", "dfidenth", "dfnamepid", "dfidentj", "dfmidlike", "dfidh", " dfkidpp", "dfidps", "dfmidj", "dfcharpp", "dfkidwp", "cfidentps", "cfidpc", "dfidepy", " dfoidj", "dfidpa", "dfidpc", "definedidpy", " dfoidlike", "dfkidj", "dfidentpp", "dfidentps", "dfkidpp", "cfidentpc", "dfidpy", "definedidphp", " dfidlike", "tfidentlp", "dfhidephp", "dfmidphp", "dfcharj", "dfcharh", "dfidentpa", "dfnamep", "dfidentwp", "dfoidp", "dfinitpc", "dfidentpid", "cfidwp", "dfnamelp", "cfidps", "dfidentlike", "dfoidj", "definedidpa", "dfnamem", "dfoidlike", " dfidj", "cfidentp"], "oldfidp": ["oldhoidP", "oldhoidpolicy", "oldfpidpoint", "oldhidpolicy", "oldfaidpolicy", "oldfoidpolicy", "oldfitm", "oldhidps", "oldfIdps", "oldfmidpb", "oldfmemm", "oldfIdp", "oldfIdpolicy", "oldvidpoint", "oldfIdpa", "oldfdidpoint", "oldfpidp", "oldfidpoint", "oldvpidpoint", "oldfaidps", "oldfoidP", "oldfitpa", "oldfidps", "oldhidp", "oldfdidpb", "oldfaidp", "oldhoidps", "oldvidpb", "oldfitp", "oldfpidpb", "oldfmidpoint", "oldfidpb", "oldvpidp", "oldvIdpa", "oldfIdm", "oldfitP", "oldhidP", "oldvpidpb", "oldfIdP", "oldfaidP", "oldvidpa", "oldfoidp", "oldfmempa", "oldfmidp", "oldfoidps", "oldvidP", "oldfmemP", "oldvidps", "oldvidm", "oldvIdm", "oldvIdp", "oldvidp", "oldfidpa", "oldhoidp", "oldfidm", "oldfmemp", "oldvIdps", "oldfdidp", "oldfidpolicy", "oldfidP", "oldvIdP"], "name": ["key", "path", "error", "type", "version", "mem", "f", "local", "out", "ref", "attr", "data", "size", "cn", "scope", "n", "names", "nam", "filename", "v", "text", "user", "chain", "msg", "title", "cap", "new", "r", "part", "message", "word", "comment", "Name", "info", "san", "prefix", "self", "c", "null", "base", "no", "alias", "ns", "id", "reason", "named", "e", " Name", "var", "err", "ame", "package", "qual", "w", "nm", "NAME", "str", "na"]}}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "int dxva2_init(AVCodecContext *s)\n\n{\n\n    InputStream *ist = s->opaque;\n\n    int loglevel = (ist->hwaccel_id == HWACCEL_AUTO) ? AV_LOG_VERBOSE : AV_LOG_ERROR;\n\n    DXVA2Context *ctx;\n\n    int ret;\n\n\n\n    if (!ist->hwaccel_ctx) {\n\n        ret = dxva2_alloc(s);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n    ctx = ist->hwaccel_ctx;\n\n\n\n    if (s->codec_id == AV_CODEC_ID_H264 &&\n\n        (s->profile & ~FF_PROFILE_H264_CONSTRAINED) > FF_PROFILE_H264_HIGH) {\n\n        av_log(NULL, loglevel, \"Unsupported H.264 profile for DXVA2 HWAccel: %d\\n\", s->profile);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (s->codec_id == AV_CODEC_ID_HEVC &&\n\n        s->profile != FF_PROFILE_HEVC_MAIN && s->profile != FF_PROFILE_HEVC_MAIN_10) {\n\n        av_log(NULL, loglevel, \"Unsupported HEVC profile for DXVA2 HWAccel: %d\\n\", s->profile);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    av_buffer_unref(&ctx->hw_frames_ctx);\n\n\n\n    ret = dxva2_create_decoder(s);\n\n    if (ret < 0) {\n\n        av_log(NULL, loglevel, \"Error creating the DXVA2 decoder\\n\");\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14108, "substitutes": {"s": ["ses", "gs", "S", "settings", "bs", "ports", "sq", "stat", "ags", "t", "st", "m", "qs", "stats", "vs", "cs", "ims", "aunts", "its", "ps", "sw", "n", "js", "params", "v", "g", "comm", "spec", "ds", "ats", "ies", "sc", "args", "set", "parts", "scl", "i", "results", "a", "less", "xs", "eps", "als", "sb", "hs", "sys", "times", "c", "es", "changes", "fs", "sports", "ss", "aws", "o", "l", "p", "details", "is", "sv", "ls", "mods", "ts", "ins", "ns", "b", "h", "os", "sets", "sts", "irs", "ms", "rs"], "ist": ["xt", "iste", "ict", "est", "ists", "htt", "ind", "exist", "tif", "erd", "typ", "ista", "pt", "hist", "ith", "ert", "is", "xp", "assert", "st", "ilst", "ih", "dist", "irst", "iss", "isting", "dit", "IST", "ess", "isi", "ost", "art", "ust", "ism", "oci", "wp", "ht", "ush", "ish", "alist", "IS", "istant", "nil", "pect", "pas", "ast", "ive", "esp", "sts", "inst", "imm"], "ctx": ["tx", "jp", "kw", "ctl", "cf", "co", "mem", "tc", "conn", "cm", "cmd", "hw", "p", "window", "kt", "cmp", "cc", "conv", "ctr", "loc", "np", "ct", "nt", "cam", "cfg", "act", "context", "kb", "obj", "sc", "ac", "ck", "c", "sp", "cv", "cb", "nc", "cp", "gc", "mc", "bc", "Context", "tmp", "pkg", "ca", "txt", "voc", "jac"], "ret": ["resp", "status", "rem", "def", "jp", "out", " alt", " RET", "det", "ll", "utils", "fun", "back", "cmd", "str", "reflect", "Ret", "tr", "rets", "after", "RET", "val", "dt", "reset", "deg", "try", "reg", "t", "ert", "len", "rm", "result", "ext", "nz", "nt", "r", "alt", "gt", "att", "rt", "rev", "lt", "RT", "ry", "res", "print", "flag", "ber", "cert", "gc", "re", "ort", "mt", "iter", "ft", "hash", "elt", "net", "pas", "err", " Ret", "value", "ter", "usr", "cont", "txt", "arr"]}}
{"project": "qemu", "commit_id": "d4cd45028898a37afb45fb449954115b4960d4e9", "target": 0, "func": "static XenPTBarFlag xen_pt_bar_reg_parse(XenPCIPassthroughState *s,\n\n                                         XenPTRegInfo *reg)\n\n{\n\n    PCIDevice *d = &s->dev;\n\n    XenPTRegion *region = NULL;\n\n    PCIIORegion *r;\n\n    int index = 0;\n\n\n\n    /* check 64bit BAR */\n\n    index = xen_pt_bar_offset_to_index(reg->offset);\n\n    if ((0 < index) && (index < PCI_ROM_SLOT)) {\n\n        int type = s->real_device.io_regions[index - 1].type;\n\n\n\n        if ((type & XEN_HOST_PCI_REGION_TYPE_MEM)\n\n            && (type & XEN_HOST_PCI_REGION_TYPE_MEM_64)) {\n\n            region = &s->bases[index - 1];\n\n            if (region->bar_flag != XEN_PT_BAR_FLAG_UPPER) {\n\n                return XEN_PT_BAR_FLAG_UPPER;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* check unused BAR */\n\n    r = &d->io_regions[index];\n\n    if (!xen_pt_get_bar_size(r)) {\n\n        return XEN_PT_BAR_FLAG_UNUSED;\n\n    }\n\n\n\n    /* for ExpROM BAR */\n\n    if (index == PCI_ROM_SLOT) {\n\n        return XEN_PT_BAR_FLAG_MEM;\n\n    }\n\n\n\n    /* check BAR I/O indicator */\n\n    if (s->real_device.io_regions[index].type & XEN_HOST_PCI_REGION_TYPE_IO) {\n\n        return XEN_PT_BAR_FLAG_IO;\n\n    } else {\n\n        return XEN_PT_BAR_FLAG_MEM;\n\n    }\n\n}\n", "idx": 14126, "substitutes": {"s": ["sis", "ses", "aws", "south", "gs", "a", "S", "status", "sw", "settings", "less", "session", "l", "p", "js", "n", "sq", "v", "http", "details", "t", "comm", "is", "sv", "sb", "st", "spec", "hs", "sys", "service", "ds", "ls", "m", "services", "ssl", "qs", "ts", "self", "sp", "c", "stats", "ins", "states", "ns", "b", "h", "es", "fs", "sd", "os", "state", "se", "sports", "ss", "sts", "i", "rs", "ps"], "reg": ["resp", "rem", "gra", "mem", "conn", "ref", "asm", "Reg", "row", "raw", "rar", "g", "REG", "scan", "br", "tag", "rest", "memory", "snap", "range", "decl", "ro", "disc", "res", "gc", "rg", "debug", "grid", "re", "rec", "greg", "eg", "sg", "eng", "err", "gro", "rr"], "d": ["session", "dn", "ind", "l", "j", "p", "n", "dr", "D", "dl", "dm", "pd", "dt", "g", "v", "t", "di", "dc", "ds", "m", "dd", "dom", "c", "dx", "db", "b", "device", "dev", "h", "ad", "sd", "dh", "w", "driver"], "region": ["record", "local", "global", "member", "section", "Region", "address", "scope", "p", "relation", "module", "reference", "resource", "chain", "rar", "dimension", "g", "pool", "t", "REG", "ge", "domain", "port", "command", "memory", "zone", "description", "slot", "buffer", "variable", "remote", "argument", "location", "summary", "gc", "b", "table", "rg", "division", "root", "state", "character", "ion", "component", "config", "country", "option", "usage", "network"], "r": ["rc", "cr", "f", "l", "j", "p", "mr", "dr", "v", "rar", "ar", "rr", "g", "t", "rm", "rb", "br", "m", "rt", "c", "ro", "sr", "res", "rg", "b", "h", "re", "e", "rd", "u", "i", "R", "w", "rn", "rs"]}}
{"project": "FFmpeg", "commit_id": "50c466d609ec60a324a7a776dfdb57c8d38faa11", "target": 1, "func": "static av_cold int g726_encode_init(AVCodecContext *avctx)\n\n{\n\n    G726Context* c = avctx->priv_data;\n\n\n\n    if (avctx->strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL &&\n\n        avctx->sample_rate != 8000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Sample rates other than 8kHz are not \"\n\n               \"allowed when the compliance level is higher than unofficial. \"\n\n               \"Resample or reduce the compliance level.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if (avctx->sample_rate <= 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Samplerate is invalid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(avctx->channels != 1){\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono is supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (avctx->bit_rate % avctx->sample_rate) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitrate - Samplerate combination is invalid\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    c->code_size = (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate;\n\n    if (c->code_size < 2 || c->code_size > 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid number of bits %d\\n\", c->code_size);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    avctx->bits_per_coded_sample = c->code_size;\n\n\n\n    g726_reset(c, c->code_size - 2);\n\n\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n    avctx->coded_frame->key_frame = 1;\n\n\n\n    /* select a frame size that will end on a byte boundary and have a size of\n\n       approximately 1024 bytes */\n\n    avctx->frame_size = ((int[]){ 4096, 2736, 2048, 1640 })[c->code_size - 2];\n\n\n\n    return 0;\n\n}\n", "idx": 14141, "substitutes": {"avctx": ["avtx", " avkl", "avercmd", "iverctx", " avdl", "avercfg", "avmsg", "navctx", "avetmp", "averhistory", "avercrit", "avercontext", "avereq", "ajcfg", "navdl", " avloc", "avpkg", "afcmp", "avtmp", " avkw", "averct", "avkw", "avpy", " savcontext", "afpkg", "ajkl", "averkt", "avect", "avhistory", "avertx", "avercmp", " avcontext", "abconn", "ajtxt", "aveaddr", "averloc", "wavtx", " avctl", "avcfg", "ajca", "navpkg", "wavctx", "avermsg", "ravjac", "avcmp", "ajpy", "avkl", "ajct", " savcmp", "avdl", "averreq", "ravconfig", "ajmsg", "avecontext", "ajcu", "ajaddr", "wavtmp", "ajcp", "ravgc", "iverpkg", "avgc", "avetx", " avcp", "averctl", "avergc", " avcmp", "abctx", "averpy", " avcfg", "avernp", "wavgc", "avertmp", "avekt", "ravpkg", "avtxt", "averca", "avecfg", "averjp", " savcp", "averkw", "afnp", " avreq", "avcu", "avecu", "navcfg", "navcontext", " avconn", "ajkw", "wavpkg", "averpkg", "afcontext", "ajcontext", "avekl", "ajhistory", "aveloc", "ivercrit", "avecmd", "avcp", "avertxt", "ravctx", "afcmd", "ajpkg", "avecp", "afctx", "ravjp", "avreq", "averctx", "wavcp", "ajjac", " avca", "avcmd", "avjp", "avemsg", " avjac", "avaddr", "abpkg", "avkt", "avconn", "aftxt", "ajtx", "avca", " savctx", "avecmp", "afcp", "avejac", "aveca", "aveconn", "averdl", "avnp", "avconfig", "avcrit", "iverconn", "navnp", "avjac", " avpkg", "avctl", "avloc", " avaddr", "avetxt", "avcontext", "avepkg", "ajctl", "afreq", "avehistory", "ajctx", " avcmd", "ajconn", "aveconfig", " avtx", "wavjp", "averconn", "abcrit", "avectx", "wavcfg", "ajkt", "ravcu", "ajconfig", "avepy", "avercp", "averaddr", "navreq", "averjac", "ajcmd", "avct"], "c": ["comments", "csv", "ce", "cu", "rc", "cf", "co", "unc", "cr", "f", "tc", "cm", "a", "cur", "lc", "l", "ctx", "p", "n", "cmp", "call", "cc", "v", "chain", "g", "t", "ic", "spec", "com", "dc", "cache", "ct", "cl", "cam", "m", "context", "ac", "C", "cb", "cv", "xc", "abc", "ec", "ci", "cp", "b", "mc", "cs", "bc", "gc", "etc", "pc", "fc", "e", "con", "conf", "enc", "config", "d", "vc", "w", "ca", "cont", "anc", "ch"]}}
{"project": "FFmpeg", "commit_id": "8332321c5737cf24ebad504bf10a03818424718d", "target": 1, "func": "static int dv_read_seek(AVFormatContext *s, int stream_index,\n\n                       int64_t timestamp, int flags)\n\n{\n\n    RawDVContext *r   = s->priv_data;\n\n    DVDemuxContext *c = r->dv_demux;\n\n    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);\n\n\n\n    dv_offset_reset(c, offset / c->sys->frame_size);\n\n\n\n    offset = avio_seek(s->pb, offset, SEEK_SET);\n\n    return (offset < 0) ? offset : 0;\n\n}\n", "idx": 14144, "substitutes": {"s": ["aws", "ses", "gs", "a", "S", "as", "bs", "n", "js", "p", "sq", "v", "g", "comm", "als", "spec", "sb", "er", "is", "hs", "sys", "ds", "ats", "ls", "qs", "sc", "ts", "self", "stats", "sr", "ns", "b", "cs", "h", "es", "fs", "os", "d", "its", "q", "sn", "w", "sts", "ss", "ms", "y", "rs", "ps"], "stream_index": ["stream_num", "ream_column", "reamidcolumn", "ream_index", "streamidcolumn", "ream_ind", "streamidind", "streamidnum", "reamidindex", "stream_column", "ream_num", "streamidindex", "reamidind", "reamidnum", "stream_ind"], "timestamp": ["datest", "Timetime", "dateness", "timest", "imeness", "datestamp", "Timage", " timetime", "timage", " timest", "timace", "Timace", "temest", " timace", "Timeness", "imest", "timeness", "Timestamp", "temetime", "imestamp", "image", "datage", "temestamp", "timetime", "Timest", "temace"], "flags": ["comments", "types", "errors", "ensions", "FLAG", "tags", "ports", "mask", "doms", "bits", "ags", "fields", "features", "faces", "reports", "ats", "months", "dds", "atts", "lag", "grades", "acts", "Flags", "stats", "flag", "args", "uploads", "links", "amps", "events", "locks", "posts", "styles", "options", "ants", "weights", "properties", "members"], "r": ["rc", "cr", "rw", "ra", "p", "mr", "or", "rl", "ir", "v", "g", "rar", "ar", "er", "rb", "nr", "br", "m", "kr", "rect", "rt", "ro", "rh", "sr", "res", "rg", "h", "re", "rd", "d", "q", "w", "R", "i", "rs"], "c": ["rc", "cu", "ce", "cf", "co", "f", "tc", "unc", "cm", "ca", "lc", "l", "ctx", "p", "cc", "v", "t", "cache", "dc", "ct", "m", "ac", "C", "cb", "cv", "xc", "ec", "cp", "b", "mc", "cs", "bc", "gc", "pc", "fc", "e", "con", "enc", "d", "vc", "sc", "ic", "ch"]}}
{"project": "qemu", "commit_id": "788d2599def0e26d92802593b07ec76e8701ccce", "target": 1, "func": "static void spapr_phb_hot_plug_child(HotplugHandler *plug_handler,\n\n                                     DeviceState *plugged_dev, Error **errp)\n\n{\n\n    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));\n\n    PCIDevice *pdev = PCI_DEVICE(plugged_dev);\n\n    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);\n\n    Error *local_err = NULL;\n\n\n\n    /* if DR is disabled we don't need to do anything in the case of\n\n     * hotplug or coldplug callbacks\n\n     */\n\n    if (!phb->dr_enabled) {\n\n        /* if this is a hotplug operation initiated by the user\n\n         * we need to let them know it's not enabled\n\n         */\n\n        if (plugged_dev->hotplugged) {\n\n            error_setg(errp, QERR_BUS_NO_HOTPLUG,\n\n                       object_get_typename(OBJECT(phb)));\n\n        }\n\n        return;\n\n    }\n\n\n\n    g_assert(drc);\n\n\n\n    spapr_phb_add_pci_device(drc, phb, pdev, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (plugged_dev->hotplugged) {\n\n        spapr_hotplug_req_add_by_index(drc);\n\n    }\n\n}\n", "idx": 14162, "substitutes": {"plug_handler": ["pluggejob", "plugityreader", "pluglydevice", "switch_handler", " plug_handle", "plugityhand", "plugitydevice", "plug_hand", "plug_job", "plugingdevice", "switchingreader", "pluglyhandle", "switchingdevice", " plug_job", "pluggehandler", " plug_device", "plug_reader", "plugityhandler", "pluggehandle", "plug_device", "switchinghandler", "plugingreader", "pluglyhandler", "pluginghand", "pluginghandler", "switch_hand", "switch_reader", "switchinghand", "plug_handle", "switch_device", "pluggedevice", "pluglyjob"], "plugged_dev": ["plugging_pub", "pluglockedptconf", "pluggedptserial", "pluggedingdevice", "plugging_dev", "plugging_ve", "plugged_conf", "pluggedptdev", "plugged_pub", "pluggedptDEV", "pluggedingve", "plugge_ev", "plugged_DEV", "plugged2device", "pluglocked_dev", "pluggedingdev", "plugging_Dev", "plugged_Dev", "pluglockedptserial", "pluggedptconf", "plugge_DEV", "plugged2dev", "plugging_ev", "plugged2ev", "plugging_device", "plugged_ev", "plugged_device", "pluggedingpub", "pluglockedptdev", "pluglockedptDEV", "plugged2Dev", "pluglocked_serial", "plugged_ve", "pluglocked_DEV", "plugge_dev", "plugged_serial", "pluglocked_conf", "plugge_device"], "errp": ["aerP", "arrp", "arrP", "errpat", "ererp", "rrpy", "arrpb", "diepad", "errpb", " errP", "aerp", "diep", "errP", " errpy", "aerpat", "arrpad", "errpy", "eorpb", "ererpat", "ererP", "ererpb", "dieP", "rrp", "rrpb", "errpad", "aerpb", " errpat", " errpad", " errpb", "diepb", "eorpy", "eorp"], "phb": ["phB", "phc", "mphB", "palb", "phbt", "hpb", "ppj", "ppc", "palbb", "khB", "pherb", "mphj", " phnb", "holb", "mphbb", "pheb", "ppb", "mphr", "phbe", "holbe", "palr", "phnb", "PHb", "mphb", "hpbt", "holbt", "phebb", "pherbb", "cmdbb", "phr", "hpbe", "khb", "pherB", "palB", "iphb", "mphc", "cmdr", "phj", "iphbe", "phbb", "phenb", "PHj", "PHB", "iphwb", "PHc", "khbb", "phwb", "hpwb", " phr", "phernb", " phbb", "pheB", "holwb", " phB", "ppB", "cmdb", "iphbt", "khr"], "pdev": ["apDev", "pcDev", " pdef", " pev", "praw", " pmem", "Pdevices", "gev", " pdevices", "Pdef", "pdevices", "pcev", "pcgu", "graw", " pgu", "pgu", "pcdef", "pdef", "pcmem", "apdev", "pcdevice", "apgu", "pev", " pdevice", "pmem", "pcraw", "pdevice", "Pdevice", "gdev", "apmem", "pDev", "pcdev", " pDev", " praw", "gdevice", "Pdev", "pcdevices"], "drc": [" dRC", "Drent", "Darc", "darc", "grc", " doc", "dric", " dric", "Drc", "DRC", "dRC", "gRC", "prc", "zrc", "didRC", "isdRC", "didric", "didiq", "doc", " darc", "zoc", "zRC", " drent", "drs", "pRC", " drs", "isdrc", "grs", "pric", " dfc", "didrc", "Dfc", "drent", "piq", "dfc", "Drs", "diq", "Dric", "Diq", "isdrent", "isdfc", "gric", "Doc", "zarc"], "local_err": ["localitydata", "local_data", "localityrr", "local__ev", "local__err", "localityerr", "localmyer", "localmyfr", "local_rr", "local___er", "local_e", "local___conn", "local_usr", "local___e", "local___err", "localmyplain", "localityusr", "localmyerr", " local_fr", "local_conn", "loc_rr", "local_error", " local_plain", "local__conn", " local_ev", " local_er", "local__error", "local__e", " local_e", " local_conn", " local_error", "loc_data", "local__er", "local_ev", "local_fr", "local_plain", "loc_usr", "loc_err", "local_er"]}}
{"project": "FFmpeg", "commit_id": "70d54392f5015b9c6594fcae558f59f952501e3b", "target": 0, "func": "av_cold int ff_dvvideo_init(AVCodecContext *avctx)\n\n{\n\n    DVVideoContext *s = avctx->priv_data;\n\n    DSPContext dsp;\n\n    static int done = 0;\n\n    int i, j;\n\n\n\n    if (!done) {\n\n        VLC dv_vlc;\n\n        uint16_t new_dv_vlc_bits[NB_DV_VLC*2];\n\n        uint8_t  new_dv_vlc_len[NB_DV_VLC*2];\n\n        uint8_t  new_dv_vlc_run[NB_DV_VLC*2];\n\n        int16_t  new_dv_vlc_level[NB_DV_VLC*2];\n\n\n\n        done = 1;\n\n\n\n        /* it's faster to include sign bit in a generic VLC parsing scheme */\n\n        for (i = 0, j = 0; i < NB_DV_VLC; i++, j++) {\n\n            new_dv_vlc_bits[j]  = dv_vlc_bits[i];\n\n            new_dv_vlc_len[j]   = dv_vlc_len[i];\n\n            new_dv_vlc_run[j]   = dv_vlc_run[i];\n\n            new_dv_vlc_level[j] = dv_vlc_level[i];\n\n\n\n            if (dv_vlc_level[i]) {\n\n                new_dv_vlc_bits[j] <<= 1;\n\n                new_dv_vlc_len[j]++;\n\n\n\n                j++;\n\n                new_dv_vlc_bits[j]  = (dv_vlc_bits[i] << 1) | 1;\n\n                new_dv_vlc_len[j]   =  dv_vlc_len[i] + 1;\n\n                new_dv_vlc_run[j]   =  dv_vlc_run[i];\n\n                new_dv_vlc_level[j] = -dv_vlc_level[i];\n\n            }\n\n        }\n\n\n\n        /* NOTE: as a trick, we use the fact the no codes are unused\n\n           to accelerate the parsing of partial codes */\n\n        init_vlc(&dv_vlc, TEX_VLC_BITS, j,\n\n                 new_dv_vlc_len, 1, 1, new_dv_vlc_bits, 2, 2, 0);\n\n        assert(dv_vlc.table_size == 1184);\n\n\n\n        for (i = 0; i < dv_vlc.table_size; i++){\n\n            int code = dv_vlc.table[i][0];\n\n            int len  = dv_vlc.table[i][1];\n\n            int level, run;\n\n\n\n            if (len < 0){ //more bits needed\n\n                run   = 0;\n\n                level = code;\n\n            } else {\n\n                run   = new_dv_vlc_run  [code] + 1;\n\n                level = new_dv_vlc_level[code];\n\n            }\n\n            ff_dv_rl_vlc[i].len   = len;\n\n            ff_dv_rl_vlc[i].level = level;\n\n            ff_dv_rl_vlc[i].run   = run;\n\n        }\n\n        ff_free_vlc(&dv_vlc);\n\n    }\n\n\n\n    /* Generic DSP setup */\n\n    ff_dsputil_init(&dsp, avctx);\n\n    ff_set_cmp(&dsp, dsp.ildct_cmp, avctx->ildct_cmp);\n\n    s->get_pixels = dsp.get_pixels;\n\n    s->ildct_cmp = dsp.ildct_cmp[5];\n\n\n\n    /* 88DCT setup */\n\n    s->fdct[0]     = dsp.fdct;\n\n    s->idct_put[0] = dsp.idct_put;\n\n    for (i = 0; i < 64; i++)\n\n       s->dv_zigzag[0][i] = dsp.idct_permutation[ff_zigzag_direct[i]];\n\n\n\n    /* 248DCT setup */\n\n    s->fdct[1]     = dsp.fdct248;\n\n    s->idct_put[1] = ff_simple_idct248_put;  // FIXME: need to add it to DSP\n\n    memcpy(s->dv_zigzag[1], ff_zigzag248_direct, 64);\n\n\n\n    avctx->coded_frame = &s->picture;\n\n    s->avctx = avctx;\n\n    avctx->chroma_sample_location = AVCHROMA_LOC_TOPLEFT;\n\n\n\n    return 0;\n\n}\n", "idx": 14168, "substitutes": {"avctx": ["avjac", "avcmp", "AVcontext", "AVctx", "avcontext", "ivcmp", "aveconf", "ivjac", "cvcontext", "AVcmp", "avecontext", " avconf", "cvcmp", "AVconf", "ivcontext", "ivctx", "avectx", "avconf", " avjac", " avcmp", " avcontext", "avecmp", "cvjac", "cvctx"], "s": ["S", "n", "p", "js", "x", "sq", "v", "g", "t", "spec", "sb", "sv", "sys", "ds", "m", "c", "ns", "b", "cs", "h", "fs", "d", "w", "ss", "sc", "ps"], "dsp": ["Dlp", "dlp", "dp", " dlp", "dnsp", "dnlp", " dp", " dSP", "Dsp", "dSP", "DSP", "dnp", "Dp", "dnSP"], "i": ["ij", "index", "key", "li", "status", "by", "at", "f", "iu", "o", "ii", "ini", "I", "pi", "ind", "mi", "ei", "p", "n", "ki", "series", "si", "zi", "uri", "name", "v", "bi", "io", "is", "ui", "ik", "di", " ii", "ai", "m", "in", "hi", "ie", "json", "xi", "info", "im", "\u0438", "iri", "ci", "h", "id", "ims", "ti", "e", "ri", "list", "gi", "multi", "it", "ji", "me", "phi", "x", "y", "ic", "ix", "ip"], "j": ["index", "and", "bs", "other", "bj", "t", "m", "ji", "it", "ind", "pr", "n", "js", "tr", "kid", "si", "v", "g", "next", "note", "job", "br", "obj", "im", "res", "ion", "ix", "ip", "ij", "key", "server", "at", "f", "out", "aj", "uj", "er", "json", "ja", "J", "jump", "id", "fr", "jc", "from", "d", "kj", "err", "jac", "jp", "jit", "l", "p", "el", "io", "pt", "k", "r", "off", "dj", "oj", "all", "jj", "b", "h", "rel", "jl", "z", "q", "y", "adj"], "dv_vlc": ["dv__vlac", "dv_tlc", "dv__flc", "dv__flt", "dv_ladc", "dv_lvlt", "dv_lvlc", "dv_ladg", "dv_flt", "dv_flac", "dv_wlcs", "dv_ladtc", "dv__vlt", "dv_klg", "dv_dltc", "dv_flcs", "dv_vlcs", "dv__flac", "dv_vlpc", "dv__vlcs", "dv_tltc", "dv_klc", "dv_fltc", "dv_plac", "dv_dlc", "dv_wlc", "dv_dlg", "dv__flcs", "dv_klpc", "dv_kltc", "dv_flfc", "dv_tlfc", "dv_plcs", "dv_flc", "dv_ladpc", "dv__vlc", "dv_wlac", "dv_vlfc", "dv_lvlfc", "dv_lvltc", "dv_vltc", "dv_tlt", "dv_vlac", "dv_plc", "dv_plt", "dv_dlpc", "dv_wlt", "dv_vlg", "dv_vlt"], "new_dv_vlc_bits": ["new_dv_vlb__bits", "new_dv_vlc__bugs", "new_dv_vlc__bs", "new_dv_vlb_bits", "new_dv_vlp_bugs", "new_dv_vlc_bugs", "new_dv_vlc__pins", "new_dv_vlcs_tops", "new_dv_vlcs_flags", "new_dv_vlb__pieces", "new_dv_vlcs_bits", "new_dv_vlb__bs", "new_dv_vlcs_bit", "new_dv_vlc_bytes", "new_dv_vlc_bit", "new_dv_vlc_flags", "new_dv_vlc__bit", "new_dv_vlc__pieces", "new_dv_vlp_bytes", "new_dv_vlp_pins", "new_dv_vlcs_bytes", "new_dv_vlp_bits", "new_dv_vlb_bs", "new_dv_vlp_pieces", "new_dv_vlc_tops", "new_dv_vlc_pieces", "new_dv_vlc_pins", "new_dv_vlb_pieces", "new_dv_vlcs_len", "new_dv_vlc__bytes", "new_dv_vlb__bit", "new_dv_vlb_bit", "new_dv_vlp_bit", "new_dv_vlc__bits", "new_dv_vlc_bs"], "new_dv_vlc_len": ["new_dv_vluc_en", "new_dv_vlcs_ln", "new_dv_vlcs_Len", "new_dv_vlc__l", "new_dv_vlc__Len", "new_dv_vlc__lib", "new_dv_vlc__ls", "new_dv_vlcs_ls", "new_dv_vlc_seq", "new_dv_vlc__ln", "new_dv_vlc_ls", "new_dv_vlcs_del", "new_dv_vlc__gen", "new_dv_vlc_lib", "new_dv_vlcs_level", "new_dv_vlc_en", "new_dv_vlcs_lim", "new_dv_vlc__len", "new_dv_vlc_gen", "new_dv_vlc__lim", "new_dv_vlc_lim", "new_dv_vlc_l", "new_dv_vlc_del", "new_dv_vlcs_len", "new_dv_vlc_ln", "new_dv_vluc_len", "new_dv_vlcs_length", "new_dv_vluc_seq", "new_dv_vlcs_l", "new_dv_vlcs_lib", "new_dv_vluc_Len", "new_dv_vlc_length", "new_dv_vlc__level", "new_dv_vlcs_gen", "new_dv_vlc_Len"], "new_dv_vlc_run": ["new_dv_vlcPruns", "new_dv_vlc_coll", "new_dv_vlc_roll", "new_dv_vlp_coll", "new_dv_vlac_roll", "new_dv_vlp_run", "new_dv_vlcProll", "new_dv_vlac_runs", "new_dv_vlp_runs", "new_dv_vlac_path", "new_dv_vlp_len", "new_dv_vlac_run", "new_dv_vlci_run", "new_dv_vlci_runs", "new_dv_vlc_runs", "new_dv_vlcPrun", "new_dv_vlci_len", "new_dv_vlc_path", "new_dv_vlci_roll", "new_dv_vlcPpath"], "new_dv_vlc_level": ["new_dv_vlc_coll", "new_dv_vlc_lvl", "new_dv_vlcs_level", "new_dv_vlcs_coll", "new_dv_vlc_log", "new_dv_vlc__coll", "new_dv_vlc_vel", "new_dv_vlc__len", "new_dv_vlcs_levels", "new_dv_vlc_levels", "new_dv_vlcs_lvl", "new_dv_vlcs_vel", "new_dv_vlcs_log", "new_dv_vlc__level", "new_dv_vlcs_len", "new_dv_vlc__log"]}}
{"project": "FFmpeg", "commit_id": "4641ae352ec587355764ffd5c43dd0d0ebd47654", "target": 1, "func": "static int libquvi_read_header(AVFormatContext *s)\n\n{\n\n    int i, ret;\n\n    quvi_t q;\n\n    quvi_media_t m;\n\n    QUVIcode rc;\n\n    LibQuviContext *qc = s->priv_data;\n\n    char *media_url, *pagetitle;\n\n\n\n    rc = quvi_init(&q);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    quvi_setopt(q, QUVIOPT_FORMAT, qc->format);\n\n\n\n    rc = quvi_parse(q, s->filename, &m);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    rc = quvi_getprop(m, QUVIPROP_MEDIAURL, &media_url);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    av_assert0(!qc->fmtctx->codec_whitelist && !qc->fmtctx->format_whitelist);\n\n    qc->fmtctx-> codec_whitelist = av_strdup(s->codec_whitelist);\n\n    qc->fmtctx->format_whitelist = av_strdup(s->format_whitelist);\n\n\n\n    ret = avformat_open_input(&qc->fmtctx, media_url, NULL, NULL);\n\n    if (ret < 0)\n\n        goto end;\n\n\n\n    rc = quvi_getprop(m, QUVIPROP_PAGETITLE, &pagetitle);\n\n    if (rc == QUVI_OK)\n\n        av_dict_set(&s->metadata, \"title\", pagetitle, 0);\n\n\n\n    for (i = 0; i < qc->fmtctx->nb_streams; i++) {\n\n        AVStream *st = avformat_new_stream(s, NULL);\n\n        AVStream *ist = qc->fmtctx->streams[i];\n\n        if (!st) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto end;\n\n        }\n\n        avpriv_set_pts_info(st, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den);\n\n        avcodec_copy_context(st->codec, qc->fmtctx->streams[i]->codec);\n\n    }\n\n\n\n    return 0;\n\n\n\nquvi_fail:\n\n    av_log(s, AV_LOG_ERROR, \"%s\\n\", quvi_strerror(q, rc));\n\n    ret = AVERROR_EXTERNAL;\n\n\n\nend:\n\n    quvi_parse_close(&m);\n\n    quvi_close(&q);\n\n    return ret;\n\n}\n", "idx": 14199, "substitutes": {"s": ["csv", "aws", "ses", "south", "gs", "a", "S", "sw", "as", "n", "js", "p", "ex", "params", "sq", "v", "ms", "sam", "t", "source", "comm", "spec", "sv", "sb", "is", "hs", "sys", "ds", "ls", "ats", "times", "erences", "r", "mods", "qs", "sc", "ts", "c", "ins", "ns", "b", "cs", "h", "ims", "args", "an", "set", "e", "changes", "fs", "conf", "sg", "os", "d", "es", "its", "parts", "sts", "ss", "w", "scl", "rs", "ps"], "i": ["ij", "index", "li", "iu", " t", "oi", "mi", "ii", "I", "pi", " j", " iter", "j", "ini", " li", "p", "ki", "si", "zi", " ti", "cli", " si", "chain", "bi", "batch", "t", " pi", "ui", "di", "ami", " index", " ii", " mi", "ai", " I", "hi", "xi", " bi", "sim", "info", "im", "\u0438", "c", "ci", "mc", "ims", "id", " ni", "ti", "u", "ri", "multi", "it", "gi", "fi", "ji", "phi", "x", "y", "ic", "ix", "ip"], "ret": ["resp", "status", "rem", "def", "at", "ref", "usr", " RET", "ll", "addr", "back", "j", "tr", "Ret", "reply", "rets", "RET", "val", "reset", "len", "rm", "result", "tn", "nz", "cat", "nt", "r", "alt", "gt", "rt", "RT", "ry", "res", "gc", "flag", "red", "print", "re", "mt", "ft", "fi", "elt", "uf", "pas", " Ret", "fin", "rr", "cont", "txt", "arr"], "q": ["quit", "qu", "at", "f", "et", "o", "query", "l", "j", "p", "sq", "ql", "aq", "v", " sq", "g", "t", "ox", "iq", "ur", "k", "r", "qa", "qi", "ue", "qs", "dq", "c", "cv", "b", "h", "u", "qt", "z", "w", "Q", "qq", "ch"], "m": ["am", "mem", "f", "o", "cm", "mi", "l", "j", "n", "p", "mr", "managed", "module", " mt", " mm", "mo", "v", "dm", "g", "t", "md", " cm", "sm", "fm", "msg", "em", "r", " mc", " rm", " im", "vm", "mu", "c", "bm", "mm", "b", "mc", "gm", "mat", "mp", "e", "mt", "M", "d", "ma", "tm", " M", "nm", "ms"], "rc": ["cor", "cr", "cur", "cmp", "rl", " cc", "ror", "auc", "rm", "uc", "imp", "cb", "star", "ack", "cs", " res", " r", "usr", "rn", "cont", "co", "lc", "crit", "RC", "rect", "roc", "irc", "rys", "nc", "sync", "gc", "comp", "con", "resp", "src", " cr", "row", "cc", "req", "ctr", "sys", "nz", "scan", "c", "cv", "ro", "ec", "ry", "red", " ro", "rin", "pc", "rom", "rd", "err", " err", "rr", "success", "ok", "cd", "dc", "r", "rt", "ck", "dq", "rec", "fc", "rob", "rx", "arc", "sc", "rs"], "qc": ["sqci", " qlc", " qcs", "flowcoll", "qlc", "qcoll", "aqdc", "qqlc", "sqcs", "iqca", "iqdc", "eqlc", "sqp", "sqt", "qulc", "eqcu", "qt", "questdc", "iqt", "qqp", "aqlc", "aqca", "qca", "quc", "eqc", "questcoll", "qudc", "eqcon", "ekci", "sqdc", "iqci", "sqlc", "iqlc", "iqcon", "ekcs", "iqc", " qcache", "iqcs", "qqc", " qca", " qci", " qcu", "sqca", "flowdc", "qqcu", "aqmc", "qn", "iql", " qdc", "eklc", "questn", "qci", "quca", "flowc", "sqmc", " qp", "aqc", "qqcache", "qcs", "qcon", "eql", "qdc", "qp", "qmc", "eqdc", "questc", "sqcon", "aqt", "eqcache", " ql", "qumc", "ekc", "ql", "qcu", "sqc", "flown", "qup", "qqci", " qn", "qqcs", " qcoll", "eqcs", "qucs", "qcache", "iqp", "eqp"], "media_url": ["media_key", "media_Url", "media___field", "base_key", "media___string", " media_string", "media___l", " media_id", "media_string", " media_l", "media_l", " media_ref", "media___url", " media_field", "base_url", "media_id", "media_field", "media_uri", "base_uri", "media_ref", "base_Url"], "pagetitle": ["pagisttitle", "pagertarget", "pagestitle", "pagetitled", "pagenarget", "pagenoken", "paginettarget", "paginetarget", "pagedetarget", "pagetoken", "pagenopic", "paginetitle", "pagistitled", "pagestoken", "paginettitle", "pagistarget", "pagedestarget", "pagedettitle", "pagetarget", "pagertoken", "paginetoken", "paginettopic", "pagenitle", "pagistitle", "pagedestitle", "pagetopic", "pagettopic", "pagertitle", "pagedetitled", "pagedestitled", "pagestarget", "paginettoken", "pagettitled", "pagestitled", "pagetttitle", "pagedesttitle", "pagettitle", "pagettarget", "pagesttitle", "paginetttitle", "paginetopic", "pagertopic", "pagettoken", "pagistoken", "pagedetitle"], "st": ["ste", "xt", "stable", "est", "sw", "src", "usr", "sta", "St", "ST", "ctx", "stream", "ut", "stat", "sl", "store", "t", "nd", "sm", "bt", "sv", "sb", "sys", "irst", "rest", "th", "obj", "rt", "ost", "sp", "art", "ust", "std", "sh", "start", "mt", "sty", "ft", "it", "se", "ast", "sn", "sth", "ss", "inst", "sc", "str", "sts", " est"], "ist": ["spect", "iste", "ict", "est", "ists", "et", "htt", "ind", "isd", "exist", "elist", "osi", "mot", "ista", "hist", "ith", "ert", "is", "ilst", "dist", "irst", "isting", "rest", "iz", "IST", "dit", "isi", "ird", "ost", "wid", "art", "ust", "ism", "std", "wp", "ht", "istor", "alist", "istant", "sty", "it", "pect", "pas", "ast", "inst", "xt", "ic", "ld"]}}
{"project": "qemu", "commit_id": "6750e795b167e3defab36502e61b8c57ede119eb", "target": 0, "func": "static int add_old_style_options(const char *fmt, QemuOpts *opts,\n\n                                 const char *base_filename,\n\n                                 const char *base_fmt)\n\n{\n\n    if (base_filename) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {\n\n            error_report(\"Backing file not supported for file format '%s'\",\n\n                         fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    if (base_fmt) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {\n\n            error_report(\"Backing file format not supported for file \"\n\n                         \"format '%s'\", fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 14220, "substitutes": {"fmt": ["qformat", "qmt", "vmt", "vlamm", "qprintf", "qmr", "vlt", "clt", "ftm", "cformat", " Flamm", "Fformat", "vformat", " Fprintf", " Fformat", " Fmt", "Fmr", "ctm", " ftm", " flamm", "Fmt", "cmt", " flt", "flamm", "vtm", "fformat", " fmr", "flt", " fformat", "Fprintf", "fmr"], "opts": ["oprs", "OPtx", "operTS", " optx", "OPrs", "opertx", "OPTS", " oprs", "operts", "iopgs", "opcs", "opTS", "atttx", "optTS", "OPs", "opers", "optcs", "ioprs", "iopts", " options", "attts", " ops", "attcs", "ops", "OPts", "opgs", " opcs", " opgs", "OPgs", "opttx", "optx", "options", "optts", "iops", "atttions", "opttions"], "base_filename": ["Base_folder", "Base_file", " base_dir", "Base_username", " base_family", "base_font", "base64family", "base64file", "base_dir", "base_folder", "base_Filename", "base_file", " base_file", "base_username", " base_src", "base_src", "Base_filename", " base_Filename", "base_family", "base64filename", "base64dir", " base_font"], "base_fmt": ["base_ftx", "base_frpl", "base_vpl", "base_vtx", "base_mMT", "base_fformat", "base_frformat", "base_vmat", "base_fmat", "base_confmat", "base_Fpl", "base_fMT", "base_confmt", "base_wmt", "base_wtx", "base_vmt", "base_wformat", "base_mtype", "base_mformat", "base_Fformat", "base_wmat", "base_mmt", "base_conftx", "base_frMT", "base_vtype", "base_ftype", "base_confformat", "base_Fmt", "base_fpl", "base_FMT", "base_frmt", "base_vMT", "base_vformat"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_flush_queued_packets(VLANClientState *vc)\n\n{\n\n    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {\n\n        VLANPacket *packet;\n\n        int ret;\n\n\n\n        packet = TAILQ_FIRST(&vc->vlan->send_queue);\n\n        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);\n\n\n\n        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);\n\n        if (ret == 0 && packet->sent_cb != NULL) {\n\n            TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);\n\n            break;\n\n        }\n\n\n\n        if (packet->sent_cb)\n\n            packet->sent_cb(packet->sender, ret);\n\n\n\n        qemu_free(packet);\n\n    }\n\n}\n", "idx": 14228, "substitutes": {"vc": ["ce", "cu", "ctl", "fw", "cf", "tc", "oc", "serv", "wx", "lc", "cmd", "VC", "hw", "vr", "cc", "vp", "v", "vet", "comm", "vin", "wcs", "sv", "dc", "nt", "fax", "att", "nec", "vm", "c", "inv", "cv", "xc", "cb", "nc", "ci", "vs", "ctrl", "gc", "ht", "cs", "bc", "lv", "etc", "pc", "fc", "irm", "vd", "ev", "vt", "ic", "WC", "voc"], "packet": [" packata", " packant", "packageew", "packageant", "buckET", "processacket", "pacew", "paketting", "paket", "parseett", "checket", "parseant", "ppel", "picketer", "packageeter", "packett", "prespet", "mixet", "formeting", "assacket", "mixacket", "formet", "mixata", "packew", "pairet", "packalty", "formacket", "stickpet", "formalty", "Packacket", "processett", "parseette", "packetter", "processet", "parseet", " packade", "packel", "claimet", "ppacket", "formett", "formetting", "pacet", "formette", "assalty", "buckacket", "sticket", "payet", "pairacket", "packade", "checkpet", "packinet", "Packeter", "packageel", "presacket", "packette", "paceter", " packpet", "preset", "pacata", "pairalty", "pacpet", " packew", "paketer", "paireting", "payacket", "checkacket", "picketter", "processette", " packinet", "formeter", "asset", "payetting", "pickacket", "packacket", "packata", "Packant", "parseew", "packand", "pickant", "parsepet", "packpet", "stickade", " packacket", "packageET", "pakew", "claiminet", "claimacket", "ppet", "checkette", "buckel", "Packet", "asseting", "packET", "bucket", "payeter", "claimpet", "pakpet", "packetting", "parseacket", "pacette", "presade", "packeting", "stickacket", "pakacket", "mixpet", "packageetter", "pakinet", "pacacket", "packageacket", "picket", "packeter", "pickand", "packageet", "pakand", "Packand", "ppET", "Packetter", "packant"], "ret": ["resp", "status", "jp", "def", "mem", "out", "success", "inter", "ref", "det", "fun", "j", "back", "cmd", "addr", "Ret", "tr", "reply", "rets", "RET", "val", "reset", "deg", "try", "pt", "ent", "ctr", "t", "vet", "len", "rm", "result", "ext", "tn", "num", "cat", "nt", "desc", "alt", "att", "gt", "match", "rt", "cb", "db", "ry", "res", "flag", "print", "re", "mt", "entry", "ft", "elt", "mb", "pet", " Ret", "ter", "cont", "arr"]}}
{"project": "FFmpeg", "commit_id": "c0bc8b9afb7e4f39d84080870b9feedcd23ab5c9", "target": 1, "func": "LF_FUNC (h,  luma,         sse2)\n\nLF_IFUNC(h,  luma_intra,   sse2)\n\nLF_FUNC (v,  luma,         sse2)\n\nLF_IFUNC(v,  luma_intra,   sse2)\n\n\n\n/***********************************/\n\n/* weighted prediction */\n\n\n\n#define H264_WEIGHT(W, H, OPT) \\\n\nvoid ff_h264_weight_ ## W ## x ## H ## _ ## OPT(uint8_t *dst, \\\n\n    int stride, int log2_denom, int weight, int offset);\n\n\n\n#define H264_BIWEIGHT(W, H, OPT) \\\n\nvoid ff_h264_biweight_ ## W ## x ## H ## _ ## OPT(uint8_t *dst, \\\n\n    uint8_t *src, int stride, int log2_denom, int weightd, \\\n\n    int weights, int offset);\n\n\n\n#define H264_BIWEIGHT_MMX(W,H) \\\n\nH264_WEIGHT  (W, H, mmx2) \\\n\nH264_BIWEIGHT(W, H, mmx2)\n\n\n\n#define H264_BIWEIGHT_MMX_SSE(W,H) \\\n\nH264_BIWEIGHT_MMX(W, H) \\\n\nH264_WEIGHT      (W, H, sse2) \\\n\nH264_BIWEIGHT    (W, H, sse2) \\\n\nH264_BIWEIGHT    (W, H, ssse3)\n\n\n\nH264_BIWEIGHT_MMX_SSE(16, 16)\n\nH264_BIWEIGHT_MMX_SSE(16,  8)\n\nH264_BIWEIGHT_MMX_SSE( 8, 16)\n\nH264_BIWEIGHT_MMX_SSE( 8,  8)\n\nH264_BIWEIGHT_MMX_SSE( 8,  4)\n\nH264_BIWEIGHT_MMX    ( 4,  8)\n\nH264_BIWEIGHT_MMX    ( 4,  4)\n\nH264_BIWEIGHT_MMX    ( 4,  2)\n\n\n\nvoid ff_h264dsp_init_x86(H264DSPContext *c)\n\n{\n\n    int mm_flags = av_get_cpu_flags();\n\n\n\n    if (mm_flags & AV_CPU_FLAG_MMX2) {\n\n        c->h264_loop_filter_strength= h264_loop_filter_strength_mmx2;\n\n    }\n\n#if HAVE_YASM\n\n    if (mm_flags & AV_CPU_FLAG_MMX) {\n\n        c->h264_idct_dc_add=\n\n        c->h264_idct_add= ff_h264_idct_add_mmx;\n\n        c->h264_idct8_dc_add=\n\n        c->h264_idct8_add= ff_h264_idct8_add_mmx;\n\n\n\n        c->h264_idct_add16     = ff_h264_idct_add16_mmx;\n\n        c->h264_idct8_add4     = ff_h264_idct8_add4_mmx;\n\n        c->h264_idct_add8      = ff_h264_idct_add8_mmx;\n\n        c->h264_idct_add16intra= ff_h264_idct_add16intra_mmx;\n\n\n\n        if (mm_flags & AV_CPU_FLAG_MMX2) {\n\n            c->h264_idct_dc_add= ff_h264_idct_dc_add_mmx2;\n\n            c->h264_idct8_dc_add= ff_h264_idct8_dc_add_mmx2;\n\n            c->h264_idct_add16     = ff_h264_idct_add16_mmx2;\n\n            c->h264_idct8_add4     = ff_h264_idct8_add4_mmx2;\n\n            c->h264_idct_add8      = ff_h264_idct_add8_mmx2;\n\n            c->h264_idct_add16intra= ff_h264_idct_add16intra_mmx2;\n\n\n\n            c->h264_v_loop_filter_chroma= ff_x264_deblock_v_chroma_mmxext;\n\n            c->h264_h_loop_filter_chroma= ff_x264_deblock_h_chroma_mmxext;\n\n            c->h264_v_loop_filter_chroma_intra= ff_x264_deblock_v_chroma_intra_mmxext;\n\n            c->h264_h_loop_filter_chroma_intra= ff_x264_deblock_h_chroma_intra_mmxext;\n\n#if ARCH_X86_32\n\n            c->h264_v_loop_filter_luma= ff_x264_deblock_v_luma_mmxext;\n\n            c->h264_h_loop_filter_luma= ff_x264_deblock_h_luma_mmxext;\n\n            c->h264_v_loop_filter_luma_intra = ff_x264_deblock_v_luma_intra_mmxext;\n\n            c->h264_h_loop_filter_luma_intra = ff_x264_deblock_h_luma_intra_mmxext;\n\n\n            c->weight_h264_pixels_tab[0]= ff_h264_weight_16x16_mmx2;\n\n            c->weight_h264_pixels_tab[1]= ff_h264_weight_16x8_mmx2;\n\n            c->weight_h264_pixels_tab[2]= ff_h264_weight_8x16_mmx2;\n\n            c->weight_h264_pixels_tab[3]= ff_h264_weight_8x8_mmx2;\n\n            c->weight_h264_pixels_tab[4]= ff_h264_weight_8x4_mmx2;\n\n            c->weight_h264_pixels_tab[5]= ff_h264_weight_4x8_mmx2;\n\n            c->weight_h264_pixels_tab[6]= ff_h264_weight_4x4_mmx2;\n\n            c->weight_h264_pixels_tab[7]= ff_h264_weight_4x2_mmx2;\n\n\n\n            c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_mmx2;\n\n            c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_mmx2;\n\n            c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_mmx2;\n\n            c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_mmx2;\n\n            c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_mmx2;\n\n            c->biweight_h264_pixels_tab[5]= ff_h264_biweight_4x8_mmx2;\n\n            c->biweight_h264_pixels_tab[6]= ff_h264_biweight_4x4_mmx2;\n\n            c->biweight_h264_pixels_tab[7]= ff_h264_biweight_4x2_mmx2;\n\n\n\n            if (mm_flags&AV_CPU_FLAG_SSE2) {\n\n                c->h264_idct8_add = ff_h264_idct8_add_sse2;\n\n                c->h264_idct8_add4= ff_h264_idct8_add4_sse2;\n\n\n\n                c->weight_h264_pixels_tab[0]= ff_h264_weight_16x16_sse2;\n\n                c->weight_h264_pixels_tab[1]= ff_h264_weight_16x8_sse2;\n\n                c->weight_h264_pixels_tab[2]= ff_h264_weight_8x16_sse2;\n\n                c->weight_h264_pixels_tab[3]= ff_h264_weight_8x8_sse2;\n\n                c->weight_h264_pixels_tab[4]= ff_h264_weight_8x4_sse2;\n\n\n\n                c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_sse2;\n\n                c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_sse2;\n\n                c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_sse2;\n\n                c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_sse2;\n\n                c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_sse2;\n\n\n\n\n                c->h264_v_loop_filter_luma = ff_x264_deblock_v_luma_sse2;\n\n                c->h264_h_loop_filter_luma = ff_x264_deblock_h_luma_sse2;\n\n                c->h264_v_loop_filter_luma_intra = ff_x264_deblock_v_luma_intra_sse2;\n\n                c->h264_h_loop_filter_luma_intra = ff_x264_deblock_h_luma_intra_sse2;\n\n\n\n\n                c->h264_idct_add16 = ff_h264_idct_add16_sse2;\n\n                c->h264_idct_add8  = ff_h264_idct_add8_sse2;\n\n                c->h264_idct_add16intra = ff_h264_idct_add16intra_sse2;\n\n            }\n\n            if (mm_flags&AV_CPU_FLAG_SSSE3) {\n\n                c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_ssse3;\n\n                c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_ssse3;\n\n                c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_ssse3;\n\n                c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_ssse3;\n\n                c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_ssse3;\n\n            }\n\n        }\n\n    }\n\n\n}", "idx": 14248, "substitutes": {"c": ["cu", "a", "cf", "f", "tc", "o", "ctx", "p", "cc", "v", "g", "t", "cache", "dc", "ct", "m", "s", "ac", "C", "cp", "b", "mc", "cs", "h", "fc", "e", "d", "w"]}}
{"project": "FFmpeg", "commit_id": "6202e2fede75df92cbc374a3f7d6893d0c5ac721", "target": 0, "func": "static int decode_band_hdr(IVI45DecContext *ctx, IVIBandDesc *band,\n\n                           AVCodecContext *avctx)\n\n{\n\n    int plane, band_num, indx, transform_id, scan_indx;\n\n    int i;\n\n\n\n    plane    = get_bits(&ctx->gb, 2);\n\n    band_num = get_bits(&ctx->gb, 4);\n\n    if (band->plane != plane || band->band_num != band_num) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid band header sequence!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    band->is_empty = get_bits1(&ctx->gb);\n\n    if (!band->is_empty) {\n\n        int old_blk_size = band->blk_size;\n\n        /* skip header size\n\n         * If header size is not given, header size is 4 bytes. */\n\n        if (get_bits1(&ctx->gb))\n\n            skip_bits(&ctx->gb, 16);\n\n\n\n        band->is_halfpel = get_bits(&ctx->gb, 2);\n\n        if (band->is_halfpel >= 2) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid/unsupported mv resolution: %d!\\n\",\n\n                   band->is_halfpel);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n#if IVI4_STREAM_ANALYSER\n\n        if (!band->is_halfpel)\n\n            ctx->uses_fullpel = 1;\n\n#endif\n\n\n\n        band->checksum_present = get_bits1(&ctx->gb);\n\n        if (band->checksum_present)\n\n            band->checksum = get_bits(&ctx->gb, 16);\n\n\n\n        indx = get_bits(&ctx->gb, 2);\n\n        if (indx == 3) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid block size!\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        band->mb_size  = 16 >> indx;\n\n        band->blk_size = 8 >> (indx >> 1);\n\n\n\n        band->inherit_mv     = get_bits1(&ctx->gb);\n\n        band->inherit_qdelta = get_bits1(&ctx->gb);\n\n\n\n        band->glob_quant = get_bits(&ctx->gb, 5);\n\n\n\n        if (!get_bits1(&ctx->gb) || ctx->frame_type == IVI4_FRAMETYPE_INTRA) {\n\n            transform_id = get_bits(&ctx->gb, 5);\n\n            if (transform_id >= FF_ARRAY_ELEMS(transforms) ||\n\n                !transforms[transform_id].inv_trans) {\n\n                avpriv_request_sample(avctx, \"Transform %d\", transform_id);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            if ((transform_id >= 7 && transform_id <= 9) ||\n\n                 transform_id == 17) {\n\n                avpriv_request_sample(avctx, \"DCT transform\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n#if IVI4_STREAM_ANALYSER\n\n            if ((transform_id >= 0 && transform_id <= 2) || transform_id == 10)\n\n                ctx->uses_haar = 1;\n\n#endif\n\n\n\n            band->inv_transform = transforms[transform_id].inv_trans;\n\n            band->dc_transform  = transforms[transform_id].dc_trans;\n\n            band->is_2d_trans   = transforms[transform_id].is_2d_trans;\n\n            if (transform_id < 10)\n\n                band->transform_size = 8;\n\n            else\n\n                band->transform_size = 4;\n\n\n\n            if (band->blk_size != band->transform_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            scan_indx = get_bits(&ctx->gb, 4);\n\n            if (scan_indx == 15) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Custom scan pattern encountered!\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (scan_indx > 4 && scan_indx < 10) {\n\n                if (band->blk_size != 4)\n\n                    return AVERROR_INVALIDDATA;\n\n            } else if (band->blk_size != 8)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            band->scan = scan_index_to_tab[scan_indx];\n\n\n\n            band->quant_mat = get_bits(&ctx->gb, 5);\n\n            if (band->quant_mat >= FF_ARRAY_ELEMS(quant_index_to_tab)) {\n\n\n\n                if (band->quant_mat == 31)\n\n                    av_log(avctx, AV_LOG_ERROR,\n\n                           \"Custom quant matrix encountered!\\n\");\n\n                else\n\n                    avpriv_request_sample(avctx, \"Quantization matrix %d\",\n\n                                          band->quant_mat);\n\n                band->quant_mat = -1;\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        } else {\n\n            if (old_blk_size != band->blk_size) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"The band block size does not match the configuration \"\n\n                       \"inherited\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (band->quant_mat < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Invalid quant_mat inherited\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n\n\n        /* decode block huffman codebook */\n\n        if (!get_bits1(&ctx->gb))\n\n            band->blk_vlc.tab = ctx->blk_vlc.tab;\n\n        else\n\n            if (ff_ivi_dec_huff_desc(&ctx->gb, 1, IVI_BLK_HUFF,\n\n                                     &band->blk_vlc, avctx))\n\n                return AVERROR_INVALIDDATA;\n\n\n\n        /* select appropriate rvmap table for this band */\n\n        band->rvmap_sel = get_bits1(&ctx->gb) ? get_bits(&ctx->gb, 3) : 8;\n\n\n\n        /* decode rvmap probability corrections if any */\n\n        band->num_corr = 0; /* there is no corrections */\n\n        if (get_bits1(&ctx->gb)) {\n\n            band->num_corr = get_bits(&ctx->gb, 8); /* get number of correction pairs */\n\n            if (band->num_corr > 61) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Too many corrections: %d\\n\",\n\n                       band->num_corr);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            /* read correction pairs */\n\n            for (i = 0; i < band->num_corr * 2; i++)\n\n                band->corr[i] = get_bits(&ctx->gb, 8);\n\n        }\n\n    }\n\n\n\n    if (band->blk_size == 8) {\n\n        band->intra_base = &ivi4_quant_8x8_intra[quant_index_to_tab[band->quant_mat]][0];\n\n        band->inter_base = &ivi4_quant_8x8_inter[quant_index_to_tab[band->quant_mat]][0];\n\n    } else {\n\n        band->intra_base = &ivi4_quant_4x4_intra[quant_index_to_tab[band->quant_mat]][0];\n\n        band->inter_base = &ivi4_quant_4x4_inter[quant_index_to_tab[band->quant_mat]][0];\n\n    }\n\n\n\n    /* Indeo 4 doesn't use scale tables */\n\n    band->intra_scale = NULL;\n\n    band->inter_scale = NULL;\n\n\n\n    align_get_bits(&ctx->gb);\n\n\n\n    return 0;\n\n}\n", "idx": 14263, "substitutes": {"ctx": ["bit", "conn", "hw", "window", "cmp", "lib", "check", "loc", "context", "cb", "xc", "ack", "pkg", "tx", "kw", "ctl", "def", "mem", "wx", "addr", "cmd", "warn", "crit", "kt", "params", "conv", "box", "comm", "wcs", "stack", "cfg", "obj", "self", "nc", "std", "comp", "cp", "mc", "args", "Context", "conf", "ca", "txt", "history", "resp", "cf", "cc", "req", "proc", "height", "batch", "bo", "buf", "sys", "np", "disk", "vals", "work", " cx", "cv", "unk", "bc", "config", "px", "iat", "jac", "tc", "serv", "cm", "msg", "dc", "func", "ct", "act", "cam", "prefix", "ck", "handler", "fc", "prop", "inst"], "band": ["bit", "raid", "display", "and", "back", "lib", "layer", "load", "command", "channel", "ud", "word", "lag", "bd", "art", "disc", "ack", "binary", "need", "filter", "def", "product", "beam", "bands", "patch", "data", "flash", "group", "box", "job", "br", "power", "dd", "chrom", "library", "db", "link", "burst", "bind", "flag", "report", "pair", "bb", "supp", "prep", "form", "border", "rad", "batch", "grab", "service", "rest", "disk", "brand", "broad", "dom", "work", "block", "plot", "cand", "unk", "bed", "plugin", "weight", "amp", "bor", "cast", "bar", "light", "bug", "stream", "chain", "pp", "Band", "bin", "bart", "tag", "road", "bag", "range", "bridge", "find", "bright", "handler", "bank", "b", "list", "format", "way"], "avctx": ["avtx", "vercfg", "avercfg", "AVcontext", "AVctx", "avecas", "svcmd", "avcontext", "avsetup", "avegc", "afcpp", "avercpp", "jamcb", "afgc", "afcb", "afsetup", "avcb", "avecmd", "aveconfig", "avecontext", "aftx", "afcmd", "avecb", " avconfig", "svgc", "afctx", "afcas", "svtx", "averctx", "jamctx", "avectx", "avgc", "avetx", "avcmd", "verctx", "avcas", "avcc", "versetup", "avcpp", " avcc", "aversetup", "jamcas", " avcontext", "jamcmd", "svctx", "afcfg", "avcfg", "vercpp", "AVcc", "avconfig", "AVconfig", "avecc"], "plane": ["profile", "face", "axis", "shift", "beam", "late", "translation", "pen", "onet", "mask", "mode", "cone", "zon", "lane", "clip", "place", "half", "port", "sea", "fl", "mate", "pipe", "mission", "zone", "orient", "panel", "gate", "flow", "plate", "phy", "plan", "pa", "bridge", "cube", "board", "plot", "rot", "car", "zo", "flag", "ane", "balance", "slice", "heading", "angle", "direction", "atten", "flat", "ve", "way", "phi", "poses", "planes", "pan", "pe", "phase", "pose"], "band_num": ["band_no", "band2number", "band_max", "band_len", "band_n", " band_dim", "bit_nom", "band_dim", "bandjnb", "band2n", "band_number", "frame_nb", "band_nb", "band_dev", " band_max", " band_len", "bandjn", " band_n", " band_number", "bit_no", "band2num", "bit_num", "frame_dev", "bandjnum", "bit_number", "band2dim", "band_nom", "frame_num", "frame_n", "bandjdev"], "indx": ["Indix", "index", " indX", "idx", "INDix", "IndX", "indix", "codx", "indy", "INDx", "Indon", "codX", "Indxc", " indix", "Index", "ndex", " index", " indon", "indX", " indxc", "indxc", "ndy", "Indx", "codix", "INDxc", "ndix", "ndx", "idy", "idon", " indy", "Indy", "cody", "idix", "indon", "idex", "INDex", "INDy"], "transform_id": ["trans_pid", "transformregids", "transform_ids", "transform_pid", "trans_type", "transformregtype", "transform_type", "trans_ids", "transformregid", "transformregpid", "trans_id"], "scan_indx": ["scan_idex", "scan_idx", "scan_ridix", "scan_ridex", "scan_ridn", "scan_ndix", "scan_idix", "scan_index", "scan_ndx", "scan_indn", "scan_idn", "scan_ridx", "scan_ndn", "scan_ndex", "scan_indix"], "i": ["ij", "li", "ii", "mi", "I", "pi", "l", "j", "p", "si", "v", "bi", "io", "t", "di", "ai", "m", "xi", " bi", "c", "ci", "b", "ti", "gi", "it", "fi", "phi", "ip"]}}
{"project": "qemu", "commit_id": "1a9353d258aba69afd8a389bf5fb705caab12ce0", "target": 0, "func": "long do_syscall(void *cpu_env, int num, long arg1, long arg2, long arg3, \n\n                long arg4, long arg5, long arg6)\n\n{\n\n    long ret;\n\n    struct stat st;\n\n    struct kernel_statfs *stfs;\n\n    \n\n#ifdef DEBUG\n\n    gemu_log(\"syscall %d\\n\", num);\n\n#endif\n\n    switch(num) {\n\n    case TARGET_NR_exit:\n\n#ifdef HAVE_GPROF\n\n        _mcleanup();\n\n#endif\n\n        _exit(arg1);\n\n        ret = 0; /* avoid warning */\n\n        break;\n\n    case TARGET_NR_read:\n\n        ret = get_errno(read(arg1, (void *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_write:\n\n        ret = get_errno(write(arg1, (void *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_open:\n\n        ret = get_errno(open((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_close:\n\n        ret = get_errno(close(arg1));\n\n        break;\n\n    case TARGET_NR_brk:\n\n        ret = do_brk((char *)arg1);\n\n        break;\n\n    case TARGET_NR_fork:\n\n        ret = get_errno(fork());\n\n        break;\n\n    case TARGET_NR_waitpid:\n\n        {\n\n            int *status = (int *)arg2;\n\n            ret = get_errno(waitpid(arg1, status, arg3));\n\n            if (!is_error(ret) && status)\n\n                tswapls((long *)&status);\n\n        }\n\n        break;\n\n    case TARGET_NR_creat:\n\n        ret = get_errno(creat((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_link:\n\n        ret = get_errno(link((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_unlink:\n\n        ret = get_errno(unlink((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_execve:\n\n        ret = get_errno(execve((const char *)arg1, (void *)arg2, (void *)arg3));\n\n        break;\n\n    case TARGET_NR_chdir:\n\n        ret = get_errno(chdir((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_time:\n\n        {\n\n            int *time_ptr = (int *)arg1;\n\n            ret = get_errno(time((time_t *)time_ptr));\n\n            if (!is_error(ret) && time_ptr)\n\n                tswap32s(time_ptr);\n\n        }\n\n        break;\n\n    case TARGET_NR_mknod:\n\n        ret = get_errno(mknod((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_chmod:\n\n        ret = get_errno(chmod((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_lchown:\n\n        ret = get_errno(chown((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_break:\n\n        goto unimplemented;\n\n    case TARGET_NR_oldstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_lseek:\n\n        ret = get_errno(lseek(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getpid:\n\n        ret = get_errno(getpid());\n\n        break;\n\n    case TARGET_NR_mount:\n\n        /* need to look at the data field */\n\n        goto unimplemented;\n\n    case TARGET_NR_umount:\n\n        ret = get_errno(umount((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_setuid:\n\n        ret = get_errno(setuid(arg1));\n\n        break;\n\n    case TARGET_NR_getuid:\n\n        ret = get_errno(getuid());\n\n        break;\n\n    case TARGET_NR_stime:\n\n        {\n\n            int *time_ptr = (int *)arg1;\n\n            if (time_ptr)\n\n                tswap32s(time_ptr);\n\n            ret = get_errno(stime((time_t *)time_ptr));\n\n        }\n\n        break;\n\n    case TARGET_NR_ptrace:\n\n        goto unimplemented;\n\n    case TARGET_NR_alarm:\n\n        ret = alarm(arg1);\n\n        break;\n\n    case TARGET_NR_oldfstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_pause:\n\n        ret = get_errno(pause());\n\n        break;\n\n    case TARGET_NR_utime:\n\n        goto unimplemented;\n\n    case TARGET_NR_stty:\n\n        goto unimplemented;\n\n    case TARGET_NR_gtty:\n\n        goto unimplemented;\n\n    case TARGET_NR_access:\n\n        ret = get_errno(access((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_nice:\n\n        ret = get_errno(nice(arg1));\n\n        break;\n\n    case TARGET_NR_ftime:\n\n        goto unimplemented;\n\n    case TARGET_NR_sync:\n\n        ret = get_errno(sync());\n\n        break;\n\n    case TARGET_NR_kill:\n\n        ret = get_errno(kill(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_rename:\n\n        ret = get_errno(rename((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_mkdir:\n\n        ret = get_errno(mkdir((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_rmdir:\n\n        ret = get_errno(rmdir((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_dup:\n\n        ret = get_errno(dup(arg1));\n\n        break;\n\n    case TARGET_NR_pipe:\n\n        {\n\n            int *pipe_ptr = (int *)arg1;\n\n            ret = get_errno(pipe(pipe_ptr));\n\n            if (!is_error(ret)) {\n\n                tswap32s(&pipe_ptr[0]);\n\n                tswap32s(&pipe_ptr[1]);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_times:\n\n        goto unimplemented;\n\n    case TARGET_NR_prof:\n\n        goto unimplemented;\n\n    case TARGET_NR_setgid:\n\n        ret = get_errno(setgid(arg1));\n\n        break;\n\n    case TARGET_NR_getgid:\n\n        ret = get_errno(getgid());\n\n        break;\n\n    case TARGET_NR_signal:\n\n        goto unimplemented;\n\n    case TARGET_NR_geteuid:\n\n        ret = get_errno(geteuid());\n\n        break;\n\n    case TARGET_NR_getegid:\n\n        ret = get_errno(getegid());\n\n        break;\n\n    case TARGET_NR_acct:\n\n        goto unimplemented;\n\n    case TARGET_NR_umount2:\n\n        ret = get_errno(umount2((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_lock:\n\n        goto unimplemented;\n\n    case TARGET_NR_ioctl:\n\n        ret = do_ioctl(arg1, arg2, arg3);\n\n        break;\n\n    case TARGET_NR_fcntl:\n\n        switch(arg2) {\n\n        case F_GETLK:\n\n        case F_SETLK:\n\n        case F_SETLKW:\n\n            goto unimplemented;\n\n        default:\n\n            ret = get_errno(fcntl(arg1, arg2, arg3));\n\n            break;\n\n        }\n\n        break;\n\n    case TARGET_NR_mpx:\n\n        goto unimplemented;\n\n    case TARGET_NR_setpgid:\n\n        ret = get_errno(setpgid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_ulimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_oldolduname:\n\n        goto unimplemented;\n\n    case TARGET_NR_umask:\n\n        ret = get_errno(umask(arg1));\n\n        break;\n\n    case TARGET_NR_chroot:\n\n        ret = get_errno(chroot((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_ustat:\n\n        goto unimplemented;\n\n    case TARGET_NR_dup2:\n\n        ret = get_errno(dup2(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_getppid:\n\n        ret = get_errno(getppid());\n\n        break;\n\n    case TARGET_NR_getpgrp:\n\n        ret = get_errno(getpgrp());\n\n        break;\n\n    case TARGET_NR_setsid:\n\n        ret = get_errno(setsid());\n\n        break;\n\n    case TARGET_NR_sigaction:\n\n#if 0\n\n        {\n\n            int signum = arg1;\n\n            struct target_old_sigaction *tact = arg2, *toldact = arg3;\n\n            ret = get_errno(setsid());\n\n            \n\n\n\n        }\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sgetmask:\n\n        goto unimplemented;\n\n    case TARGET_NR_ssetmask:\n\n        goto unimplemented;\n\n    case TARGET_NR_setreuid:\n\n        ret = get_errno(setreuid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setregid:\n\n        ret = get_errno(setregid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_sigsuspend:\n\n        goto unimplemented;\n\n    case TARGET_NR_sigpending:\n\n        goto unimplemented;\n\n    case TARGET_NR_sethostname:\n\n        ret = get_errno(sethostname((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setrlimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_getrlimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_getrusage:\n\n        goto unimplemented;\n\n    case TARGET_NR_gettimeofday:\n\n        {\n\n            struct target_timeval *target_tv = (void *)arg1;\n\n            struct timeval tv;\n\n            ret = get_errno(gettimeofday(&tv, NULL));\n\n            if (!is_error(ret)) {\n\n                target_tv->tv_sec = tswapl(tv.tv_sec);\n\n                target_tv->tv_usec = tswapl(tv.tv_usec);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_settimeofday:\n\n        {\n\n            struct target_timeval *target_tv = (void *)arg1;\n\n            struct timeval tv;\n\n            tv.tv_sec = tswapl(target_tv->tv_sec);\n\n            tv.tv_usec = tswapl(target_tv->tv_usec);\n\n            ret = get_errno(settimeofday(&tv, NULL));\n\n        }\n\n        break;\n\n    case TARGET_NR_getgroups:\n\n        goto unimplemented;\n\n    case TARGET_NR_setgroups:\n\n        goto unimplemented;\n\n    case TARGET_NR_select:\n\n        goto unimplemented;\n\n    case TARGET_NR_symlink:\n\n        ret = get_errno(symlink((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_oldlstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_readlink:\n\n        ret = get_errno(readlink((const char *)arg1, (char *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_uselib:\n\n        goto unimplemented;\n\n    case TARGET_NR_swapon:\n\n        ret = get_errno(swapon((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_reboot:\n\n        goto unimplemented;\n\n    case TARGET_NR_readdir:\n\n        goto unimplemented;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_mmap:\n\n        {\n\n            uint32_t v1, v2, v3, v4, v5, v6, *vptr;\n\n            vptr = (uint32_t *)arg1;\n\n            v1 = tswap32(vptr[0]);\n\n            v2 = tswap32(vptr[1]);\n\n            v3 = tswap32(vptr[2]);\n\n            v4 = tswap32(vptr[3]);\n\n            v5 = tswap32(vptr[4]);\n\n            v6 = tswap32(vptr[5]);\n\n            ret = get_errno((long)mmap((void *)v1, v2, v3, v4, v5, v6));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_mmap2:\n\n#else\n\n    case TARGET_NR_mmap:\n\n#endif\n\n        ret = get_errno((long)mmap((void *)arg1, arg2, arg3, arg4, arg5, arg6));\n\n        break;\n\n    case TARGET_NR_munmap:\n\n        ret = get_errno(munmap((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_truncate:\n\n        ret = get_errno(truncate((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_ftruncate:\n\n        ret = get_errno(ftruncate(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchmod:\n\n        ret = get_errno(fchmod(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchown:\n\n        ret = get_errno(fchown(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getpriority:\n\n        ret = get_errno(getpriority(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setpriority:\n\n        ret = get_errno(setpriority(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_profil:\n\n        goto unimplemented;\n\n    case TARGET_NR_statfs:\n\n        stfs = (void *)arg2;\n\n        ret = get_errno(sys_statfs((const char *)arg1, stfs));\n\n    convert_statfs:\n\n        if (!is_error(ret)) {\n\n            tswap32s(&stfs->f_type);\n\n            tswap32s(&stfs->f_bsize);\n\n            tswap32s(&stfs->f_blocks);\n\n            tswap32s(&stfs->f_bfree);\n\n            tswap32s(&stfs->f_bavail);\n\n            tswap32s(&stfs->f_files);\n\n            tswap32s(&stfs->f_ffree);\n\n            tswap32s(&stfs->f_fsid.val[0]);\n\n            tswap32s(&stfs->f_fsid.val[1]);\n\n            tswap32s(&stfs->f_namelen);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs:\n\n        stfs = (void *)arg2;\n\n        ret = get_errno(sys_fstatfs(arg1, stfs));\n\n        goto convert_statfs;\n\n    case TARGET_NR_ioperm:\n\n        goto unimplemented;\n\n    case TARGET_NR_socketcall:\n\n        ret = do_socketcall(arg1, (long *)arg2);\n\n        break;\n\n    case TARGET_NR_syslog:\n\n        goto unimplemented;\n\n    case TARGET_NR_setitimer:\n\n        goto unimplemented;\n\n    case TARGET_NR_getitimer:\n\n        goto unimplemented;\n\n    case TARGET_NR_stat:\n\n        ret = get_errno(stat((const char *)arg1, &st));\n\n        goto do_stat;\n\n    case TARGET_NR_lstat:\n\n        ret = get_errno(lstat((const char *)arg1, &st));\n\n        goto do_stat;\n\n    case TARGET_NR_fstat:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat:\n\n            if (!is_error(ret)) {\n\n                struct target_stat *target_st = (void *)arg2;\n\n                target_st->st_dev = tswap16(st.st_dev);\n\n                target_st->st_ino = tswapl(st.st_ino);\n\n                target_st->st_mode = tswap16(st.st_mode);\n\n                target_st->st_nlink = tswap16(st.st_nlink);\n\n                target_st->st_uid = tswap16(st.st_uid);\n\n                target_st->st_gid = tswap16(st.st_gid);\n\n                target_st->st_rdev = tswap16(st.st_rdev);\n\n                target_st->st_size = tswapl(st.st_size);\n\n                target_st->st_blksize = tswapl(st.st_blksize);\n\n                target_st->st_blocks = tswapl(st.st_blocks);\n\n                target_st->st_atime = tswapl(st.st_atime);\n\n                target_st->st_mtime = tswapl(st.st_mtime);\n\n                target_st->st_ctime = tswapl(st.st_ctime);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_olduname:\n\n        goto unimplemented;\n\n    case TARGET_NR_iopl:\n\n        goto unimplemented;\n\n    case TARGET_NR_vhangup:\n\n        ret = get_errno(vhangup());\n\n        break;\n\n    case TARGET_NR_idle:\n\n        goto unimplemented;\n\n    case TARGET_NR_vm86old:\n\n        goto unimplemented;\n\n    case TARGET_NR_wait4:\n\n        {\n\n            int status;\n\n            target_long *status_ptr = (void *)arg2;\n\n            struct rusage rusage, *rusage_ptr;\n\n            struct target_rusage *target_rusage = (void *)arg4;\n\n            if (target_rusage)\n\n                rusage_ptr = &rusage;\n\n            else\n\n                rusage_ptr = NULL;\n\n            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n\n            if (!is_error(ret)) {\n\n                if (status_ptr)\n\n                    *status_ptr = tswap32(status);\n\n                if (target_rusage) {\n\n                    target_rusage->ru_utime.tv_sec = tswapl(rusage.ru_utime.tv_sec);\n\n                    target_rusage->ru_utime.tv_usec = tswapl(rusage.ru_utime.tv_usec);\n\n                    target_rusage->ru_stime.tv_sec = tswapl(rusage.ru_stime.tv_sec);\n\n                    target_rusage->ru_stime.tv_usec = tswapl(rusage.ru_stime.tv_usec);\n\n                    target_rusage->ru_maxrss = tswapl(rusage.ru_maxrss);\n\n                    target_rusage->ru_ixrss = tswapl(rusage.ru_ixrss);\n\n                    target_rusage->ru_idrss = tswapl(rusage.ru_idrss);\n\n                    target_rusage->ru_isrss = tswapl(rusage.ru_isrss);\n\n                    target_rusage->ru_minflt = tswapl(rusage.ru_minflt);\n\n                    target_rusage->ru_majflt = tswapl(rusage.ru_majflt);\n\n                    target_rusage->ru_nswap = tswapl(rusage.ru_nswap);\n\n                    target_rusage->ru_inblock = tswapl(rusage.ru_inblock);\n\n                    target_rusage->ru_oublock = tswapl(rusage.ru_oublock);\n\n                    target_rusage->ru_msgsnd = tswapl(rusage.ru_msgsnd);\n\n                    target_rusage->ru_msgrcv = tswapl(rusage.ru_msgrcv);\n\n                    target_rusage->ru_nsignals = tswapl(rusage.ru_nsignals);\n\n                    target_rusage->ru_nvcsw = tswapl(rusage.ru_nvcsw);\n\n                    target_rusage->ru_nivcsw = tswapl(rusage.ru_nivcsw);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_swapoff:\n\n        ret = get_errno(swapoff((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_sysinfo:\n\n        goto unimplemented;\n\n    case TARGET_NR_ipc:\n\n        goto unimplemented;\n\n    case TARGET_NR_fsync:\n\n        ret = get_errno(fsync(arg1));\n\n        break;\n\n    case TARGET_NR_sigreturn:\n\n        goto unimplemented;\n\n    case TARGET_NR_clone:\n\n        goto unimplemented;\n\n    case TARGET_NR_setdomainname:\n\n        ret = get_errno(setdomainname((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_uname:\n\n        /* no need to transcode because we use the linux syscall */\n\n        ret = get_errno(sys_uname((struct new_utsname *)arg1));\n\n        break;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_modify_ldt:\n\n        ret = get_errno(gemu_modify_ldt(cpu_env, arg1, (void *)arg2, arg3));\n\n        break;\n\n#endif\n\n    case TARGET_NR_adjtimex:\n\n        goto unimplemented;\n\n    case TARGET_NR_mprotect:\n\n        ret = get_errno(mprotect((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n            target_ulong *pset = (void *)arg2, *poldset = (void *)arg3;\n\n            \n\n            switch(how) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -EINVAL;\n\n                goto fail;\n\n            }\n\n            \n\n            if (pset) {\n\n                target_to_host_old_sigset(&set, pset);\n\n                set_ptr = &set;\n\n            } else {\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(arg1, set_ptr, &oldset));\n\n            if (!is_error(ret) && poldset) {\n\n                host_to_target_old_sigset(poldset, &oldset);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_create_module:\n\n    case TARGET_NR_init_module:\n\n    case TARGET_NR_delete_module:\n\n    case TARGET_NR_get_kernel_syms:\n\n        goto unimplemented;\n\n    case TARGET_NR_quotactl:\n\n        goto unimplemented;\n\n    case TARGET_NR_getpgid:\n\n        ret = get_errno(getpgid(arg1));\n\n        break;\n\n    case TARGET_NR_fchdir:\n\n        ret = get_errno(fchdir(arg1));\n\n        break;\n\n    case TARGET_NR_bdflush:\n\n        goto unimplemented;\n\n    case TARGET_NR_sysfs:\n\n        goto unimplemented;\n\n    case TARGET_NR_personality:\n\n        ret = get_errno(mprotect((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_afs_syscall:\n\n        goto unimplemented;\n\n    case TARGET_NR_setfsuid:\n\n        goto unimplemented;\n\n    case TARGET_NR_setfsgid:\n\n        goto unimplemented;\n\n    case TARGET_NR__llseek:\n\n        {\n\n            int64_t res;\n\n            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n\n            *(int64_t *)arg4 = tswap64(res);\n\n        }\n\n        break;\n\n    case TARGET_NR_getdents:\n\n#if TARGET_LONG_SIZE != 4\n\n#error not supported\n\n#endif\n\n        {\n\n            struct dirent *dirp = (void *)arg2;\n\n            long count = arg3;\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct dirent *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = tswap16(de->d_reclen);\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = reclen;\n\n                    tswapls(&de->d_ino);\n\n                    tswapls(&de->d_off);\n\n                    de = (struct dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR__newselect:\n\n        ret = do_select(arg1, (void *)arg2, (void *)arg3, (void *)arg4, \n\n                        (void *)arg5);\n\n        break;\n\n    case TARGET_NR_flock:\n\n        goto unimplemented;\n\n    case TARGET_NR_msync:\n\n        ret = get_errno(msync((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_readv:\n\n        {\n\n            int count = arg3;\n\n            int i;\n\n            struct iovec *vec;\n\n            struct target_iovec *target_vec = (void *)arg2;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            for(i = 0;i < count; i++) {\n\n                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);\n\n                vec[i].iov_len = tswapl(target_vec[i].iov_len);\n\n            }\n\n            ret = get_errno(readv(arg1, vec, count));\n\n        }\n\n        break;\n\n    case TARGET_NR_writev:\n\n        {\n\n            int count = arg3;\n\n            int i;\n\n            struct iovec *vec;\n\n            struct target_iovec *target_vec = (void *)arg2;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            for(i = 0;i < count; i++) {\n\n                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);\n\n                vec[i].iov_len = tswapl(target_vec[i].iov_len);\n\n            }\n\n            ret = get_errno(writev(arg1, vec, count));\n\n        }\n\n        break;\n\n    case TARGET_NR_getsid:\n\n        ret = get_errno(getsid(arg1));\n\n        break;\n\n    case TARGET_NR_fdatasync:\n\n        goto unimplemented;\n\n    case TARGET_NR__sysctl:\n\n        goto unimplemented;\n\n    case TARGET_NR_mlock:\n\n        ret = get_errno(mlock((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_munlock:\n\n        ret = get_errno(munlock((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_mlockall:\n\n        ret = get_errno(mlockall(arg1));\n\n        break;\n\n    case TARGET_NR_munlockall:\n\n        ret = get_errno(munlockall());\n\n        break;\n\n    case TARGET_NR_sched_setparam:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_getparam:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_setscheduler:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_getscheduler:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_yield:\n\n        ret = get_errno(sched_yield());\n\n        break;\n\n    case TARGET_NR_sched_get_priority_max:\n\n    case TARGET_NR_sched_get_priority_min:\n\n    case TARGET_NR_sched_rr_get_interval:\n\n    case TARGET_NR_nanosleep:\n\n    case TARGET_NR_mremap:\n\n    case TARGET_NR_setresuid:\n\n    case TARGET_NR_getresuid:\n\n    case TARGET_NR_vm86:\n\n    case TARGET_NR_query_module:\n\n    case TARGET_NR_poll:\n\n    case TARGET_NR_nfsservctl:\n\n    case TARGET_NR_setresgid:\n\n    case TARGET_NR_getresgid:\n\n    case TARGET_NR_prctl:\n\n    case TARGET_NR_rt_sigreturn:\n\n    case TARGET_NR_rt_sigaction:\n\n    case TARGET_NR_rt_sigprocmask:\n\n    case TARGET_NR_rt_sigpending:\n\n    case TARGET_NR_rt_sigtimedwait:\n\n    case TARGET_NR_rt_sigqueueinfo:\n\n    case TARGET_NR_rt_sigsuspend:\n\n    case TARGET_NR_pread:\n\n    case TARGET_NR_pwrite:\n\n        goto unimplemented;\n\n    case TARGET_NR_chown:\n\n        ret = get_errno(chown((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getcwd:\n\n        ret = get_errno(sys_getcwd1((char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_capget:\n\n    case TARGET_NR_capset:\n\n    case TARGET_NR_sigaltstack:\n\n    case TARGET_NR_sendfile:\n\n    case TARGET_NR_getpmsg:\n\n    case TARGET_NR_putpmsg:\n\n    case TARGET_NR_vfork:\n\n        ret = get_errno(vfork());\n\n        break;\n\n    case TARGET_NR_ugetrlimit:\n\n    case TARGET_NR_truncate64:\n\n    case TARGET_NR_ftruncate64:\n\n    case TARGET_NR_stat64:\n\n    case TARGET_NR_lstat64:\n\n    case TARGET_NR_fstat64:\n\n    case TARGET_NR_lchown32:\n\n    case TARGET_NR_getuid32:\n\n    case TARGET_NR_getgid32:\n\n    case TARGET_NR_geteuid32:\n\n    case TARGET_NR_getegid32:\n\n    case TARGET_NR_setreuid32:\n\n    case TARGET_NR_setregid32:\n\n    case TARGET_NR_getgroups32:\n\n    case TARGET_NR_setgroups32:\n\n    case TARGET_NR_fchown32:\n\n    case TARGET_NR_setresuid32:\n\n    case TARGET_NR_getresuid32:\n\n    case TARGET_NR_setresgid32:\n\n    case TARGET_NR_getresgid32:\n\n    case TARGET_NR_chown32:\n\n    case TARGET_NR_setuid32:\n\n    case TARGET_NR_setgid32:\n\n    case TARGET_NR_setfsuid32:\n\n    case TARGET_NR_setfsgid32:\n\n    case TARGET_NR_pivot_root:\n\n    case TARGET_NR_mincore:\n\n    case TARGET_NR_madvise:\n\n    case TARGET_NR_getdents64:\n\n    case TARGET_NR_fcntl64:\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n    case TARGET_NR_readahead:\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n    case TARGET_NR_fsetxattr:\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n    case TARGET_NR_fgetxattr:\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    case TARGET_NR_flistxattr:\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n    case TARGET_NR_fremovexattr:\n\n        goto unimplemented;\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"Unsupported syscall: %d\\n\", num);\n\n        ret = -ENOSYS;\n\n        break;\n\n    }\n\n fail:\n\n    return ret;\n\n}\n", "idx": 14289, "substitutes": {"cpu_env": ["gpu_info", "cpu_info", "cpu_dir", "gpu_dir", "gpu_v", "gpu_env", "cpu_v"], "num": ["index", "um", "number", "out", "ver", "mon", "n", "ctx", "temp", "val", "t", "msg", "result", "np", "new", "m", "th", "off", "NUM", "current", "dim", "run", "Num", "en", "code", "no", "coord", "un", "gnu", "id", "con", "conf", "multi", "nb", "final", "zero", "tim", "nm", "x", "valid", "nom", "nu", "na"], "arg1": ["pg2", "argOne", "prop3", "doc5", "args01", "pg0", "par1", "prop2", "val1", " arg01", "ag5", "argument1", "dev2", "argument0", "val3", "pg1", "ag4", "dev5", " arg0", "dev1", "args3", "argument4", "group0", "alg2", "argument3", "par5", "alg5", "argument5", " argOne", "val5", "group3", "arg01", "valOne", "doc1", "par21", "alg1", "arg0", "doc01", "val2", "dev3", "doc0", "arg21", "args1", " arg21", "alg21", "prop5", "group2", "ag2", "ag1", "group1", "args0", "val0", "args2", "par2", "prop1", "args5", "pg3", "argument2", "argsOne"], "arg2": ["argSecond", "date02", "tag3", "target5", "Arg02", "doc3", "prop3", "doc5", "prop2", "val1", "args02", "argsTwo", "argTwo", "Arg5", "tag2", "tag5", "prop6", "target2", "date1", "val3", "doc2", " arg0", "arg02", "args3", "agSecond", "argsSecond", "date2", "ag3", " arg02", "tag02", "Arg1", "target3", "val5", "tagTwo", "Arg3", "Arg2", "doc1", "val2", "arg0", "dateTwo", "args1", " argSecond", "prop5", "ag2", "Arg0", "ag1", "target6", "args0", "args2", "args5", "tag1"], "arg3": ["tag3", "arg03", "ag6", "tag4", "val53", "date53", "doc3", "group4", "val1", "date3", "param2", "tag2", "agUE", "date1", "ar53", "val3", "doc2", "arg103", "Arg03", "args3", "ar003", "Arg43", "ag3", " arg53", "argUE", "argument3", "Arg1", "ar1", "arg003", " arg03", "group03", "args03", "tag03", "arg43", "param03", "param1", "Arg3", "Arg2", "group3", "val2", "Arg103", "ar3", "doc6", "date003", "args1", "argument03", "group2", "argument43", "argument103", "Arg53", " arg003", "ag2", " arg43", " argUE", "docUE", "args2", "arg53", " arg103", "param3"], "arg4": ["arg413", "val43", "int413", " arg40", " arg413", "arg43", " arg43", "val40", "val4", "int43", "int4", "val413", "arg40", "int40"], "arg5": ["var5", "arg25", "dim5", "arg45", "var75", "dim75", "arg75", "dim45", "dim25", " arg25", "var45", " arg75", " arg45", "var25"], "arg6": ["args9", "Arg6", "dim4", "Arg7", "dim6", "dim9", "Arg4", "args4", "arg7", "Arg9", "args6", "args7", "dim7", "arg9"], "ret": ["pret", "fun", "back", "expr", "stat", "val", "compl", "vet", "t", "len", "rm", "result", "nt", "lit", "att", "Return", "summary", "net", " Ret", "usr", "arr", "rem", "def", "nl", "des", "mem", "ll", "cmd", "j", "n", "tr", "RET", "reset", "dt", "try", "cat", "get", "flag", "gc", "mt", "arg", "elt", "mb", "full", "resp", "ref", "out", "Ret", "rets", "ben", "gt", "eth", "red", "ft", "err", "leg", "jp", "success", " RET", "det", "reg", "details", "ext", "desc", "r", "alt", "rt", "count", "re", "format", "pas", " fut"], "st": ["ste", "nl", "est", "sw", "usr", "St", "ST", "ut", "sm", "ct", "nt", "rest", "ts", "ost", "sp", " ST", "std", "mt", "d", "se", "net", "sth", "sts", "x", "sc", "str", "ld"], "stfs": ["stf", "stps", "Stf", "STps", " stf", "Stfs", "Stps", " stps", "STfs", "STms", " stms", "Stms", "stms", "STf"], "status": ["resp", "wait", "index", "currently", "error", "susp", "type", "version", "f", "sw", "success", "handle", "usr", "p", "n", "x", "ex", "si", "stat", "compl", "name", "login", "negative", "ping", "wa", "result", "msg", "Status", "uses", "atus", "s", "lag", "current", "info", "ssl", "progress", "sp", "count", "null", "code", "sex", "sync", "gc", "flag", "active", "id", "pid", "state", "valid", "err", "STAT", "str", "only"]}}
{"project": "qemu", "commit_id": "f80ac75d0e6e6e7481d61cdb86e5a741a442f100", "target": 1, "func": "static int rebuild_refcount_structure(BlockDriverState *bs,\n\n                                      BdrvCheckResult *res,\n\n                                      void **refcount_table,\n\n                                      int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t first_free_cluster = 0, reftable_offset = -1, cluster = 0;\n\n    int64_t refblock_offset, refblock_start, refblock_index;\n\n    uint32_t reftable_size = 0;\n\n    uint64_t *on_disk_reftable = NULL;\n\n    void *on_disk_refblock;\n\n    int ret = 0;\n\n    struct {\n\n        uint64_t reftable_offset;\n\n        uint32_t reftable_clusters;\n\n    } QEMU_PACKED reftable_offset_and_clusters;\n\n\n\n    qcow2_cache_empty(bs, s->refcount_block_cache);\n\n\n\nwrite_refblocks:\n\n    for (; cluster < *nb_clusters; cluster++) {\n\n        if (!s->get_refcount(*refcount_table, cluster)) {\n\n            continue;\n\n        }\n\n\n\n        refblock_index = cluster >> s->refcount_block_bits;\n\n        refblock_start = refblock_index << s->refcount_block_bits;\n\n\n\n        /* Don't allocate a cluster in a refblock already written to disk */\n\n        if (first_free_cluster < refblock_start) {\n\n            first_free_cluster = refblock_start;\n\n        }\n\n        refblock_offset = alloc_clusters_imrt(bs, 1, refcount_table,\n\n                                              nb_clusters, &first_free_cluster);\n\n        if (refblock_offset < 0) {\n\n            fprintf(stderr, \"ERROR allocating refblock: %s\\n\",\n\n                    strerror(-refblock_offset));\n\n            res->check_errors++;\n\n            ret = refblock_offset;\n\n            goto fail;\n\n        }\n\n\n\n        if (reftable_size <= refblock_index) {\n\n            uint32_t old_reftable_size = reftable_size;\n\n            uint64_t *new_on_disk_reftable;\n\n\n\n            reftable_size = ROUND_UP((refblock_index + 1) * sizeof(uint64_t),\n\n                                     s->cluster_size) / sizeof(uint64_t);\n\n            new_on_disk_reftable = g_try_realloc(on_disk_reftable,\n\n                                                 reftable_size *\n\n                                                 sizeof(uint64_t));\n\n            if (!new_on_disk_reftable) {\n\n                res->check_errors++;\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n            on_disk_reftable = new_on_disk_reftable;\n\n\n\n            memset(on_disk_reftable + old_reftable_size, 0,\n\n                   (reftable_size - old_reftable_size) * sizeof(uint64_t));\n\n\n\n            /* The offset we have for the reftable is now no longer valid;\n\n             * this will leak that range, but we can easily fix that by running\n\n             * a leak-fixing check after this rebuild operation */\n\n            reftable_offset = -1;\n\n        }\n\n        on_disk_reftable[refblock_index] = refblock_offset;\n\n\n\n        /* If this is apparently the last refblock (for now), try to squeeze the\n\n         * reftable in */\n\n        if (refblock_index == (*nb_clusters - 1) >> s->refcount_block_bits &&\n\n            reftable_offset < 0)\n\n        {\n\n            uint64_t reftable_clusters = size_to_clusters(s, reftable_size *\n\n                                                          sizeof(uint64_t));\n\n            reftable_offset = alloc_clusters_imrt(bs, reftable_clusters,\n\n                                                  refcount_table, nb_clusters,\n\n                                                  &first_free_cluster);\n\n            if (reftable_offset < 0) {\n\n                fprintf(stderr, \"ERROR allocating reftable: %s\\n\",\n\n                        strerror(-reftable_offset));\n\n                res->check_errors++;\n\n                ret = reftable_offset;\n\n                goto fail;\n\n            }\n\n        }\n\n\n\n        ret = qcow2_pre_write_overlap_check(bs, 0, refblock_offset,\n\n                                            s->cluster_size);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret));\n\n            goto fail;\n\n        }\n\n\n\n        /* The size of *refcount_table is always cluster-aligned, therefore the\n\n         * write operation will not overflow */\n\n        on_disk_refblock = (void *)((char *) *refcount_table +\n\n                                    refblock_index * s->cluster_size);\n\n\n\n        ret = bdrv_write(bs->file, refblock_offset / BDRV_SECTOR_SIZE,\n\n                         on_disk_refblock, s->cluster_sectors);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret));\n\n            goto fail;\n\n        }\n\n\n\n        /* Go to the end of this refblock */\n\n        cluster = refblock_start + s->refcount_block_size - 1;\n\n    }\n\n\n\n    if (reftable_offset < 0) {\n\n        uint64_t post_refblock_start, reftable_clusters;\n\n\n\n        post_refblock_start = ROUND_UP(*nb_clusters, s->refcount_block_size);\n\n        reftable_clusters = size_to_clusters(s,\n\n                                             reftable_size * sizeof(uint64_t));\n\n        /* Not pretty but simple */\n\n        if (first_free_cluster < post_refblock_start) {\n\n            first_free_cluster = post_refblock_start;\n\n        }\n\n        reftable_offset = alloc_clusters_imrt(bs, reftable_clusters,\n\n                                              refcount_table, nb_clusters,\n\n                                              &first_free_cluster);\n\n        if (reftable_offset < 0) {\n\n            fprintf(stderr, \"ERROR allocating reftable: %s\\n\",\n\n                    strerror(-reftable_offset));\n\n            res->check_errors++;\n\n            ret = reftable_offset;\n\n            goto fail;\n\n        }\n\n\n\n        goto write_refblocks;\n\n    }\n\n\n\n    assert(on_disk_reftable);\n\n\n\n    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {\n\n        cpu_to_be64s(&on_disk_reftable[refblock_index]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, reftable_offset,\n\n                                        reftable_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    assert(reftable_size < INT_MAX / sizeof(uint64_t));\n\n    ret = bdrv_pwrite(bs->file, reftable_offset, on_disk_reftable,\n\n                      reftable_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    /* Enter new reftable into the image header */\n\n    reftable_offset_and_clusters.reftable_offset = cpu_to_be64(reftable_offset);\n\n    reftable_offset_and_clusters.reftable_clusters =\n\n        cpu_to_be32(size_to_clusters(s, reftable_size * sizeof(uint64_t)));\n\n    ret = bdrv_pwrite_sync(bs->file,\n\n                           offsetof(QCowHeader, refcount_table_offset),\n\n                           &reftable_offset_and_clusters,\n\n                           sizeof(reftable_offset_and_clusters));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR setting reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {\n\n        be64_to_cpus(&on_disk_reftable[refblock_index]);\n\n    }\n\n    s->refcount_table = on_disk_reftable;\n\n    s->refcount_table_offset = reftable_offset;\n\n    s->refcount_table_size = reftable_size;\n\n    update_max_refcount_table_index(s);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    g_free(on_disk_reftable);\n\n    return ret;\n\n}\n", "idx": 14300, "substitutes": {"bs": ["bytes", "ashes", "ubis", "gs", "ubs", "aos", "obs", "outs", "pb", "js", "bits", "bh", "bes", "sb", "hs", "sys", "cks", "ds", "ls", "BS", "ts", "bos", "bm", "vs", "ns", "b", "cs", "bc", "bl", "lbs", "bles", "fs", "ks", "bps", "os", "bis", "its", "ss", "sts", "ms", "rs", "ps"], "res": ["resp", "rem", "ress", "rc", "def", "des", "cr", "conn", "ret", "pres", "expr", "RES", "mr", "crit", "req", " Res", "reset", "reg", "result", "rest", "r", "rev", "inv", "ro", "results", "rek", "gr", "cons", "ack", "der", "Res", "re", "red", "cs", "rel", "err", "pas", "rez", "q", "us", "rs", "resh", "ps"], "refcount_table": ["refount_map", "refCount_map", "refCount_TABLE", "refCount_data", "refcount__Table", "refcount2TABLE", "refcountMpoint", "refcount2Table", "refcount__data", "refcount__map", "refcount_tr", "refount_data", "refount_table", "refCount_tr", "refCount_point", "refcountMtr", "refcount2table", "refCount_table", "refcount2data", "refCount_Table", "refcountMtable", "refcount_Table", "refcount_data", "refcount2map", "refcount_map", "refount_TABLE", "refcount_TABLE", "refcountMTABLE", "refcount_point", "refcount__table"], "nb_clusters": ["nb_codes", "nb_cliders", "nb_ciders", "nb_combuster", "nb_shuster", "nb_planks", "nb_Clusters", "nb_colusters", "nb_coluster", "nb_Cliders", "nb_cluster", "nb_custers", "nb_shblocks", "nb_sclusters", "nb_clodes", "nb_shanches", "nb_plblocks", "nb_colanches", "nb_splanks", "nb_splocations", "nb_colblocks", "nb_sclanks", "nb_combiders", "nb_plocations", "nb_clblocks", "nb_shusters", "nb_Clodes", "nb_planches", "nb_clanks", "nb_combodes", "nb_spluster", "nb_splusters", "nb_pluster", "nb_sclocations", "nb_combusters", "nb_scluster", "nb_Cluster", "nb_clanches", "nb_clocations", "nb_plusters", "nb_custer"], "s": ["ses", "aws", "gs", "S", "sw", "settings", "less", "p", "js", "bits", "sq", "ags", "t", "comm", "is", "sb", "sv", "als", "spec", "hs", "sys", "ds", "ls", "ats", "sa", "r", "qs", "ts", "sp", "c", "stats", "vs", "ins", "ns", "b", "cs", "ops", "h", "es", "ims", "fs", "conf", "os", "its", "parts", "ants", "ss", "sts", "ms", "rs", "ps"], "refblock_offset": ["reflink_start", "refbl_offset", "refblock_address", "refblockxerror", "refBlock_error", "refbl_error", "refBlock_offset", "reflock_offset", "refBlock_slot", "refblock_length", "refblockxoffset", "refblockxaddress", "refblock__error", "refBlock_index", "reflink_offset", "refbl_point", "refblock_position", "refblockxstart", "reflock_address", "refblock__offset", "reflink_off", "refblock_slot", "refblockxlocation", "refbl_off", "refblockxaddr", "reflock_addr", "refblock_addr", "refblock_off", "refblockxoff", "refblock_location", "refblock_error", "reflock_location", "refblock__position", "refblock__length", "reflink_error", "refblock_point"], "refblock_start": ["refrecordxstart", "refblockzpoint", "refblockzstart", "refblockzlast", "refrow_shift", "refrecord_start", "refrecordxindex", "refrecord_offset", "refrow_index", "refrow_start", "refrecord_key", "refblockxoffset", "refblockxstart", "refblock0shift", "refblockzindex", "refrecordxoffset", "refrecord_index", "refblock0offset", "refblock_last", "refblock_key", "refblock_stop", "refblockxkey", "refrecordxkey", "refrow_end", "refblock0start", "refblockxindex", "refblock_end", "refblock_point", "refblock0stop", "refblock_shift"], "refblock_index": ["refblock_no", "refblockTheind", "refblockipstart", "refBlock_offset", "refblock1index", "refBlock_length", "refcase_no", "refblock1offset", "refblock1length", "refblockTheindex", "refblockipindex", "refblock_length", "refBlock_ind", "refboxipinter", "refBlock_index", "refblockTheno", "refblock_position", "refboxipinfo", "refblockTheposition", "refbox_inter", "refcase_position", "refboxipindex", "refblockipinter", "refblock_info", "refblock1ind", "refbox_index", "refblock_ind", "refblock2num", "refbox_info", "refblock2offset", "refblock2ind", "refcase_index", "refblockipinfo", "refbox_start", "refblock2index", "refblock_inter", "refboxipstart", "refcase_ind", "refblock_num"], "on_disk_reftable": ["on_disk_reffable", "on_disk_refforable", "on_disk_reaftable", "on_disk_reffables", "on_disk_reptabe", "on_disk_preftables", "on_disk_preftorable", "on_disk_reftabe", "on_disk_reaftorable", "on_disk_preaftable", "on_disk_preaftabe", "on_disk_reaftables", "on_disk_preftabe", "on_disk_reffabe", "on_disk_reaftabe", "on_disk_preaftables", "on_disk_reptable", "on_disk_reftorable", "on_disk_preftable", "on_disk_reptorable", "on_disk_preaftorable", "on_disk_reftables", "on_disk_reptables"], "on_disk_refblock": ["on_disk_nextBlock", "on_disk_referencebl", "on_disk_lastBlock", "on_disk_lastblock", "on_disk_nextbl", "on_disk_lastbl", "on_disk_referenceblock", "on_disk_referenceBlock", "on_disk_refBlock", "on_disk_nextblock", "on_disk_refbl"], "QEMU_PACKED": ["QEMU_PIX2", "QEMU_MIXed", "QEMU_MACKER", "QEMU_PACER", "QEMU_PACED", "QEMU_PADDER", "QEMU_MIXED", "QEMU_PACed", "QEMU_MACK2", "QEMU_PACKER", "QEMU_PADDed", "QEMU_PIXER", "QEMU_PADDED", "QEMU_PAC2", "QEMU_MIXER", "QEMU_MIX2", "QEMU_PACKed", "QEMU_PACK2", "QEMU_PADD2", "QEMU_PIXed", "QEMU_MACKED", "QEMU_PIXED", "QEMU_MACKed"], "cluster": ["oclust", "cloci", "glust", "scusters", "clusters", "clocation", "plumn", "scoci", "clumn", "ocluster", "clorum", "plust", "plancer", "plluster", "collique", "pluster", "CLique", "chumn", " clusters", "oclorum", "chust", "scust", "chocation", "colluster", "gloser", "glancer", " clluster", " cloci", "blusters", "collocation", "chluster", "CLust", " clocation", "colloser", "clique", " clumn", "clancer", "scluster", "ploser", "collancer", "chique", "blocation", "gluster", "CLocation", "CLuster", "oclluster", " clust", "clluster", "bluster", "scorum", "plorum", "bloci", "closer", "clust", "scocation", "collust", "scuster", "chuster"], "check_errors": ["checkityresults", "checkityrors", "check_details", "max_errors", "max_rors", "checkitydetails", "max_details", "max_results", "check_results", "check_rors", "checkityerrors"], "new_on_disk_reftable": ["new_on_disk_reftive", "new_on_disk_reffab", "new_on_disk_refttable", "new_on_disk_reftables", "new_on_disk_revtive", "new_on_disk_reffable", "new_on_disk_prectable", "new_on_disk_rectabe", "new_on_disk_prectab", "new_on_disk_reptables", "new_on_disk_revtable", "new_on_disk_reaftab", "new_on_disk_precttable", "new_on_disk_reffables", "new_on_disk_reaftable", "new_on_disk_preptable", "new_on_disk_preptables", "new_on_disk_preftable", "new_on_disk_rective", "new_on_disk_rectables", "new_on_disk_reptive", "new_on_disk_reftabe", "new_on_disk_recttable", "new_on_disk_refftable", "new_on_disk_rectable", "new_on_disk_preptive", "new_on_disk_prefttable", "new_on_disk_preftables", "new_on_disk_preftab", "new_on_disk_prectables", "new_on_disk_reafttable", "new_on_disk_reaftables", "new_on_disk_reptabe", "new_on_disk_reftab", "new_on_disk_preftive", "new_on_disk_revtables", "new_on_disk_revtabe", "new_on_disk_rectab", "new_on_disk_preftabe", "new_on_disk_reptable", "new_on_disk_preptabe"], "reftable_clusters": ["reftable_cocations", "reftable_clroups", "reftable_colusters", "reftable_colocations", "reftable_clocations", "reftable_custers", "reftable_croups", "reftable_glroups", "reftable_colroups", "reftable_glusters", "reftable_glocations"]}}
{"project": "FFmpeg", "commit_id": "f1ffb01ee9fd3a15c395c3cf6ff362ac5cd668d0", "target": 0, "func": "static int synchronize_audio(VideoState *is, short *samples,\n\n                             int samples_size1, double pts)\n\n{\n\n    int n, samples_size;\n\n    double ref_clock;\n\n\n\n    n = 2 * is->audio_st->codec->channels;\n\n    samples_size = samples_size1;\n\n\n\n    /* if not master, then we try to remove or add samples to correct the clock */\n\n    if (((is->av_sync_type == AV_SYNC_VIDEO_MASTER && is->video_st) ||\n\n         is->av_sync_type == AV_SYNC_EXTERNAL_CLOCK)) {\n\n        double diff, avg_diff;\n\n        int wanted_size, min_size, max_size, nb_samples;\n\n\n\n        ref_clock = get_master_clock(is);\n\n        diff = get_audio_clock(is) - ref_clock;\n\n\n\n        if (diff < AV_NOSYNC_THRESHOLD) {\n\n            is->audio_diff_cum = diff + is->audio_diff_avg_coef * is->audio_diff_cum;\n\n            if (is->audio_diff_avg_count < AUDIO_DIFF_AVG_NB) {\n\n                /* not enough measures to have a correct estimate */\n\n                is->audio_diff_avg_count++;\n\n            } else {\n\n                /* estimate the A-V difference */\n\n                avg_diff = is->audio_diff_cum * (1.0 - is->audio_diff_avg_coef);\n\n\n\n                if (fabs(avg_diff) >= is->audio_diff_threshold) {\n\n                    wanted_size = samples_size + ((int)(diff * is->audio_st->codec->sample_rate) * n);\n\n                    nb_samples = samples_size / n;\n\n\n\n                    min_size = ((nb_samples * (100 - SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;\n\n                    max_size = ((nb_samples * (100 + SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;\n\n                    if (wanted_size < min_size)\n\n                        wanted_size = min_size;\n\n                    else if (wanted_size > max_size)\n\n                        wanted_size = max_size;\n\n\n\n                    /* add or remove samples to correction the synchro */\n\n                    if (wanted_size < samples_size) {\n\n                        /* remove samples */\n\n                        samples_size = wanted_size;\n\n                    } else if (wanted_size > samples_size) {\n\n                        uint8_t *samples_end, *q;\n\n                        int nb;\n\n\n\n                        /* add samples */\n\n                        nb = (samples_size - wanted_size);\n\n                        samples_end = (uint8_t *)samples + samples_size - n;\n\n                        q = samples_end + n;\n\n                        while (nb > 0) {\n\n                            memcpy(q, samples_end, n);\n\n                            q += n;\n\n                            nb -= n;\n\n                        }\n\n                        samples_size = wanted_size;\n\n                    }\n\n                }\n\n                av_dlog(NULL, \"diff=%f adiff=%f sample_diff=%d apts=%0.3f vpts=%0.3f %f\\n\",\n\n                        diff, avg_diff, samples_size - samples_size1,\n\n                        is->audio_clock, is->video_clock, is->audio_diff_threshold);\n\n            }\n\n        } else {\n\n            /* too big difference : may be initial PTS errors, so\n\n               reset A-V filter */\n\n            is->audio_diff_avg_count = 0;\n\n            is->audio_diff_cum       = 0;\n\n        }\n\n    }\n\n\n\n    return samples_size;\n\n}\n", "idx": 14306, "substitutes": {"is": ["sis", "isf", "bs", "ist", "ir", "plays", "does", "iss", "s", "ism", "are", "isa", "ims", "ish", "trace", "it", "its", "us", "isc", "ists", "obs", "js", "isl", "lis", "ais", "isi", "im", "isal", "iris", "Is", "ows", "parts", "ics", "i", "ic", "ip", "needs", "as", "ii", "bits", "eps", "ik", "in", "rest", "icks", "was", "ois", "sim", "info", "es", "fs", "bis", "ris", "il", "serv", "has", "p", "details", "tis", "ires", "ls", "act", "oss", "orts", "iso", "ins", "ns", "IS", "os", "isin", "news", "init", "ms"], "samples": ["Sents", "sents", "tamples", " samps", "Samples", "Samps", "tamps", "tents", " sents", "samps"], "samples_size1": ["samples_type2", "samples_type1", "samples_type0", "samples_length0", "samples_length3", "samples_type3", "samples_length1", "samples_size2", "samples_length2", "samples_size0", "samples_size3"], "pts": ["cts", "roundls", "ctS", "streamls", "rounds", "roundsd", "streamsd", "streams", "roundS", "ctls", "ptsd", "streamS", "ctsd", "ptls", "ptS"], "n": ["network", "nv", "ni", " ns", "nw", "o", "number", "dn", "cn", "size", "l", "j", "p", "x", "ln", "min", "name", "v", "g", "t", " N", "len", "na", "np", "num", "nt", "m", "N", "k", "s", "gn", "c", "count", "nc", "en", "fn", "ns", "un", "h", "d", "ne", "net", "z", "sn", "nan", "nm", "i", "w", "an", "nu", "nn"], "samples_size": ["samples_style", "samplesPenergy", "samples_Size", "samps_style", "samples_offset", "samplesPonly", "samps_total", "samples27size", "samps_size", "samples_energy", "samplesPsize", "samples_score", "srooms_style", "samples_since", "samples_sample", "spled_start", "samples_member", "spaces_energy", "spaces_member", "samples____ize", "samples____total", "samples_total", "samples27start", "sples_size", "spaces_only", "samps_type", "samples32done", "samples_scale", "srooms_size", "sples_since", "samples_only", "srooms_offset", "samps_Size", "samps_ize", "samples_ize", "samples27sample", "samples_start", "samplesPmember", "samps_scale", "samps_done", "srooms_ize", "samples____size", "spaces_size", "samples27score", "spled_sample", "samples32size", "spled_score", "samples32total", "samples____done", "samples_type", "spled_size", "samples_done", "samples32ize", "sples_style"], "ref_clock": ["refressize", " ref2clock", "refacshock", "refjclock", "ref_time", "relative_size", "ref_shock", " ref_switch", "refaccycle", "ref_ck", "refenclock", "ref2time", "refenshock", "relativeensize", " ref2time", "refensize", " ref_frequency", "refacsize", "refjtime", "ref_frequency", "ref2frequency", "relativeencycle", " ref2frequency", "relativeenshock", "ref_size", "refrescycle", " ref_time", "relativeenclock", "refacclock", "refresshock", "relative_shock", "refjck", "ref_cycle", " ref_ck", "refencycle", "relative_cycle", "relative_clock", "refjswitch", "refresclock", "ref_switch", "ref2clock"], "diff": ["def", "distance", "shift", "f", "dy", "ref", " difference", "Diff", "size", "relative", " Diff", " delta", "fd", "different", "cmp", "p", "dl", "changed", "gap", "missing", "v", "deg", "dp", "test", "mix", "flo", "result", "iffs", "np", "delay", "now", "dist", "dc", "desc", "dd", "update", "none", "extra", "step", "iff", "range", "add", "dust", "tf", "change", "deb", "df", "comp", "eff", "alpha", "erence", "dev", "scale", "draw", "conf", " differences", "length", "d", "total", "to", "transfer", "value", "inf", "sum"], "avg_diff": ["avg_dist", "avg_change", "avg_cmp", "avg_dust", "avig_mix", "avG_dist", "avge_mix", "avge_cmp", "avig_change", "avg_mix", "avg_err", "avG_err", "avig_dust", "avg_grad", "avig_diff", "avG_grad", "avG_diff", "avge_dist", "avge_diff"], "wanted_size": ["wanted7status", "wantedlyshape", "wanted_min", "wantededlen", "wanted_len", "wanted_owner", "wishlysize", "wanted_status", "wied_location", "wiedTimelocation", "wantedlsize", "wanting_source", "wanted_format", "wanted7sized", "wantedingsize", "wanted_member", "wared_speed", "wantedingmessage", "wantedtmessage", "wantedlowner", "wantedlysource", "wantedlyenergy", "wantedTimesize", "wowed_size", "waredTsize", "wied_size", "wared_storage", "wiedTimemin", "wish_member", "wiedTimesize", "wishlyshape", "wanted_speed", "wared_size", "wanted0shape", "wanted\u05bcscale", "wowed_max", "wantedtsize", "want_size", "wowed_global", "wanted_storage", "wneededlowner", "wanted7max", "wanted_ize", "wishlymember", "wowedtglobal", "wish_shape", "wantedtglobal", "wish_size", "wantedTspeed", "wanting_energy", "wanted_max", "wanted\u05bcenergy", "wANT_sized", "wneededlshape", "wanted_scope", "wneeded_shape", "wantedlyscale", "wanted\u05bcsource", "wantedTimemin", "want_scope", "wowed_message", "wanting_size", "wantededsize", "wantedlymember", "wantedtscope", "wared_format", "wanted7stream", "waredTspeed", "wantedingglobal", "waredTformat", "wANT_stream", "wantedlenergy", "wowedtmessage", "wneededlsize", "wowedtsize", "wantededscope", "wanted_energy", "wied_min", "wowed_scope", "wANT_energy", "waredTstorage", "wanted_source", "wanted0energy", "wantedingscope", "wanted_scale", "wanted\u05bcsize", "wanted7size", "wneeded_owner", "wanted_global", "wanted_stream", "wanted_message", "wantedTformat", "wneeded_energy", "wowed_ize", "wanted7ize", "wowed_status", "wneeded_size", "wneededlenergy", "wanting_scale", "wanted_shape", "want_len", "wanted_location", "wanted_sized", "wowedtscope", "wanted7energy", "wANT_size", "wantedlshape", "wanted0owner", "wanted0size", "wantedTimelocation", "wantedTsize", "wantedTstorage", "wantedlysize"], "min_size": ["min_small", "minTcode", "min_space", " min_SIZE", "minlycode", " min_space", "min_term", "adminlystyle", "min_score", "minTstyle", " min_score", "minlySIZE", "min00style", "minlymessage", "adminlymessage", "minTmessage", "minsetterm", "min_message", "minlystyle", "min_speed", "main_term", "admin_size", "min00size", "minsetlocation", "admin_style", "min_SIZE", "min00code", "minTsize", "adminlycode", "minlyscore", "min_location", "minsetsmall", "min_style", "main_size", "minsetsize", "admin_code", "admin_message", "minlysize", "adminlysize", "min_code", "min00message", "main_location", " min_speed", "main_small"], "max_size": ["max__length", "max_height", " max_Size", "max_large", "maxnetlarge", "maxlexnotice", "maxvalheight", "max_city", "max__SIZE", "prime_city", "maxenlarge", "maxnetglobal", "primeenglobal", "maxlexSize", "primeenlarge", "rootlexscale", "max__Size", "root_size", "root_scale", "maxlexscale", "prime_large", "root_notice", "maxvallarge", "rootlexSize", "max_Size", "max_length", "maxenglobal", "maxvalglobal", " max_empty", "max_SIZE", "maxencity", "maxvalcity", "primeensize", "primeencity", "maxnetsize", "maxensize", "maxnetcity", "maxvalSize", "max_scale", "max_notice", "rootlexsize", "rootlexnotice", " max_height", " max_SIZE", "max_empty", "maxvalempty", "prime_size", "prime_global", "maxvalsize", " max_length", "max_global", "maxlexsize", "max__size", "root_Size"], "nb_samples": ["nb_idsreads", "nb_ninks", "nb_stamples", "nb_tinks", "nb_seents", "nb_setracks", "nb_svanguages", "nb___namps", "nb_nsigs", "nb42sigs", "nb_seamples", "nb_subents", "nb_Sacks", "nb_sanguages", "nb_stents", "nb_tents", "nb_samps", "nb_namples", "nb_Samps", "nb_sizes", "nb___ninks", "nb42nsreads", "nb_nsanguages", "nb42samples", "nb_Samples", "nb_sents", "nb_nizes", "nb___sinks", "nb_sigs", "nb_idsamples", "nb_tamps", "nb_tizes", "nb_Sents", "nb_subamples", "nb_svamples", "nb_sinks", "nb___nizes", "nb_stamps", "nb_sacks", "nb_stracks", "nb42nsanguages", "nb_seamps", "nb___namples", "nb_idsigs", "nb_tamples", "nb_sreads", "nb___sizes", "nb_svigs", "nb_ttracks", "nb_nsreads", "nb_servamps", "nb_namps", "nb42nsamples", "nb_subtracks", "nb_idsanguages", "nb_tacks", "nb42nsigs", "nb_nsamples", "nb_subamps", "nb_servinks", "nb_stacks", "nb___samples", "nb___samps", "nb_servamples", "nb42sreads", "nb_svreads", "nb_servizes", "nb42sanguages"], "audio_diff_avg_count": ["audio_diff_avg_nb", "audio_diff_avG_nb", "audio_diff_avG_nr", "audio_diff_avg____c", "audio_diff_avG_c", "audio_diff_avg__nr", "audio_diff_avg____count", "audio_diff_avg____Count", "audio_diff_avG_Count", "audio_diff_avg__Count", "audio_diff_avg_nr", "audio_diff_avg__c", "audio_diff_avg__count", "audio_diff_avg_Count", "audio_diff_avG_count", "audio_diff_avg_c", "audio_diff_avg____nr"]}}
{"project": "FFmpeg", "commit_id": "a82468514048fb87d9bf38689866bc3b9aaccd02", "target": 1, "func": "av_cold int ff_ivi_init_planes(IVIPlaneDesc *planes, const IVIPicConfig *cfg,\n\n                               int is_indeo4)\n\n{\n\n    int p, b;\n\n    uint32_t b_width, b_height, align_fac, width_aligned,\n\n             height_aligned, buf_size;\n\n    IVIBandDesc *band;\n\n\n\n    ivi_free_buffers(planes);\n\n\n\n    if (av_image_check_size(cfg->pic_width, cfg->pic_height, 0, NULL) < 0 ||\n\n        cfg->luma_bands < 1 || cfg->chroma_bands < 1)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    /* fill in the descriptor of the luminance plane */\n\n    planes[0].width     = cfg->pic_width;\n\n    planes[0].height    = cfg->pic_height;\n\n    planes[0].num_bands = cfg->luma_bands;\n\n\n\n    /* fill in the descriptors of the chrominance planes */\n\n    planes[1].width     = planes[2].width     = (cfg->pic_width  + 3) >> 2;\n\n    planes[1].height    = planes[2].height    = (cfg->pic_height + 3) >> 2;\n\n    planes[1].num_bands = planes[2].num_bands = cfg->chroma_bands;\n\n\n\n    for (p = 0; p < 3; p++) {\n\n        planes[p].bands = av_mallocz_array(planes[p].num_bands, sizeof(IVIBandDesc));\n\n        if (!planes[p].bands)\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* select band dimensions: if there is only one band then it\n\n         *  has the full size, if there are several bands each of them\n\n         *  has only half size */\n\n        b_width  = planes[p].num_bands == 1 ? planes[p].width\n\n                                            : (planes[p].width  + 1) >> 1;\n\n        b_height = planes[p].num_bands == 1 ? planes[p].height\n\n                                            : (planes[p].height + 1) >> 1;\n\n\n\n        /* luma   band buffers will be aligned on 16x16 (max macroblock size) */\n\n        /* chroma band buffers will be aligned on   8x8 (max macroblock size) */\n\n        align_fac       = p ? 8 : 16;\n\n        width_aligned   = FFALIGN(b_width , align_fac);\n\n        height_aligned  = FFALIGN(b_height, align_fac);\n\n        buf_size        = width_aligned * height_aligned * sizeof(int16_t);\n\n\n\n        for (b = 0; b < planes[p].num_bands; b++) {\n\n            band = &planes[p].bands[b]; /* select appropriate plane/band */\n\n            band->plane    = p;\n\n            band->band_num = b;\n\n            band->width    = b_width;\n\n            band->height   = b_height;\n\n            band->pitch    = width_aligned;\n\n            band->aheight  = height_aligned;\n\n            band->bufs[0]  = av_mallocz(buf_size);\n\n            band->bufs[1]  = av_mallocz(buf_size);\n\n            band->bufsize  = buf_size/2;\n\n            if (!band->bufs[0] || !band->bufs[1])\n\n                return AVERROR(ENOMEM);\n\n\n\n            /* allocate the 3rd band buffer for scalability mode */\n\n            if (cfg->luma_bands > 1) {\n\n                band->bufs[2] = av_mallocz(buf_size);\n\n                if (!band->bufs[2])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n            if (is_indeo4) {\n\n                band->bufs[3]  = av_mallocz(buf_size);\n\n                if (!band->bufs[3])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n            /* reset custom vlc */\n\n            planes[p].bands[0].blk_vlc.cust_desc.num_rows = 0;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14308, "substitutes": {"planes": ["groups", "cats", "banks", "settings", "classes", "ports", "devices", "limits", "cuts", "apps", "rots", "sites", "products", "states", "plane", "videos", "flows", "users", "dates", "writers", "bands", "params", "pd", "lists", "pages", "frames", "photos", "services", "versions", "boxes", "ubes", "rices", "rates", "parts", "files", "poses", "pak", "packages", "models", "types", "lines", "bits", "rows", "nets", "workers", "points", "faces", "plugins", "headers", "vals", "grades", "projects", "hops", "jobs", "cards", "images", "ques", "changes", "views", "objects", "packs", "bees", "codes", "tags", "keys", "rooms", "boards", "words", "players", "pins", "drivers", "blocks", "pieces", "lights", "anes", "maps", "modules", "ippers", "pes", "levels", "flat", "works", "weights", "sets", "plates"], "cfg": ["def", "ctl", "gs", "cf", "virt", "conn", "settings", "gg", "fig", "google", "gas", "ini", "addr", "cmd", "ctx", "oga", "req", "deg", "g", "adj", "ng", "known", "ctr", "comm", "fle", "Conf", "note", "dc", "gb", "msg", "cap", "og", "gate", "fee", "alg", "fg", "org", "gn", "cb", "c", "gom", "iana", "cand", "gc", "gp", "cgi", "bc", "mc", "args", "mg", "eas", "conf", "eg", "config", "gz", "eng", "err", "bg", "pkg", "forge", "fine", "exec", "gov", "jac"], "is_indeo4": ["is_indee1", "is_indee8", "is_indeco8", "is_indeo8", "is_inde_8", "is_indeco4", "is_indeco1", "is_indee3", "is_inde_4", "is_inde_3", "is_indee4", "is_inde_1", "is_indeo3", "is_indeo1", "is_indeco3"], "p": ["ctx", "port", "t", "ping", "php", "m", "fp", "pers", "pre", "app", "pid", "it", "pkg", "pod", "ps", "pro", "patch", "pr", "j", "n", "v", "g", "pin", "padding", "br", "power", "part", "self", "pos", "wp", "cp", "pg", "i", "tp", "x", "pa", "pe", "ip", "a", "at", "f", "out", "pi", "pat", "vp", "perm", "er", "np", "P", "op", "rep", "progress", "c", "up", "lp", "pc", " P", "u", "d", "jp", "o", "local", "per", "l", "pb", "dp", "pt", "pp", "k", "r", "sp", "ap", "post", "h", "point", "pad", "q", "pl", "bp", "w", "y"], "b": ["bar", "be", "ba", "a", "ib", "f", "by", "bs", "l", "j", "back", "wb", "eb", "or", "bh", "v", "bi", "batch", "t", "sb", "bt", "bo", "gb", "bin", "lb", "ab", "rb", "br", "m", "r", "bot", "ub", "fb", "bd", "bu", "cb", "c", "db", "base", "bf", "bl", "bc", "h", "binary", "B", "bb", "nb", "mb", "bg", "bp", "i", "bound", "ob"], "b_width": ["boxradius", "bibwidth", "bufibduration", "boxwidth", "a_width", " b_len", "a_conn", "boxduration", "buf_width", "b_len", "blogradius", "buf_duration", "boxport", "b_memory", "b_radius", "bufibradius", "blogmemory", "blogduration", "bufibmemory", "bufibwidth", "bibmemory", "blogwidth", "boxmemory", "a_port", "b2height", "bibradius", "b2width", "bibduration", "b_conn", "buf_memory", "boxheight", "a_height", "buf_radius", "boxconn", "b_duration", "b2len", "b_port"], "b_height": ["b_style", "b_gravity", "bJheight", "bb_height", "B_length", "bJstyle", "b_resolution", "b_length", "B_height", "bJhang", "bjresolution", "b_history", "B_data", "b_strength", "b_ty", "bb_style", "bjlength", "bb_history", " b_gravity", "bb_hang", "bjdata", "b_hang", "b_data", " b_ty", "bjheight", " b_strength", "B_resolution", "bJhistory"], "align_fac": ["aff_factor", " align_factor", " align2rat", "align_conv", " align2frac", " align_bu", "alignityfactor", "align_factor", "align_acc", " align2factor", "align_rat", " align_rat", "align2fac", "alignmmFac", "align_bu", "align2rat", "aff_cand", "aff_acc", "align_Fac", "alignitycand", "alignablefac", "align_fc", "coordmmconv", "coord_fc", "aff_fac", "coord_fac", " align_frac", "alignablefc", "align_frac", "alignityfac", "alignableFac", "coord_Fac", "alignableconv", " align_Fac", "alignmmfac", "alignmmfc", "alignityacc", "coord_conv", "align2frac", " align2fac", "align_cand", "align2factor", "coordmmfac", "coordmmfc", "alignmmconv", "coordmmFac"], "width_aligned": [" width_covered", "width_shaped", "width_igned", "w_aligned", "w_adjusted", " width_angled", "width64align", "width_initialized", "w_initialized", "width_align", "width_adjusted", "width_angled", " width_igned", "width64aligned", "width64angled", "width64shaped", " width_align", " width_shaped", "width_covered"], "height_aligned": ["height67ordered", "ack_enabled", "heightenalign", "height_adj", "heightenenabled", "length_adj", "heightenrot", "height2centered", "heightenordered", "length_align", " height2align", " height2aligned", "height_ordered", "ack67ordered", "height67agged", "ack67aligned", "ack_aligned", "ack_agged", " height_centered", "heightenagged", "height_agged", "height_signed", "ack67enabled", "height_enabled", " height2signed", " height_align", "height2signed", "height67enabled", "heightenaligned", "ack67agged", "ack_ordered", " height_signed", "height67aligned", "length_rot", "height_rot", "heightenadj", "height_centered", "length_aligned", "height2align", " height2centered", "height_align", "height2aligned"], "buf_size": ["buf64speed", "buf0speed", "buf_count", "buf64size", "buffer_range", "buf64SIZE", " bufxsize", "buf0range", " buf_space", "buf_space", "buf_SIZE", "buf_dim", "buffer_speed", " buf_dim", "buf0SIZE", "buffer_size", " bufxspace", " buf_count", " bufxcount", "bufxdim", "bufxspace", "bufxcount", "buffer_SIZE", "buf0size", "buf64range", "bufxsize", "buf_speed", " bufxdim", "buf_range"], "band": ["bit", "node", "ground", " bands", "frequency", "back", "group", "pixel", "batch", "field", "io", "nd", " Band", "Band", "bin", "command", "pipe", "job", "power", "tag", "part", "line", "brand", "channel", "step", "word", "zone", "bd", "bridge", "handler", "block", "art", "image", "board", "plot", "bank", "link", "flag", "plane", "bed", "binary", "pair", "plugin", "piece", "plug", "filter", "bor", "tab"]}}
{"project": "FFmpeg", "commit_id": "ce551a3925a1cf9c7824e26a246b99b6773bda4b", "target": 1, "func": "static av_cold int seqvideo_decode_init(AVCodecContext *avctx)\n{\n    SeqVideoContext *seq = avctx->priv_data;\n    seq->avctx = avctx;\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    seq->frame = av_frame_alloc();\n    if (!seq->frame)\n        return AVERROR(ENOMEM);\n    return 0;\n}", "idx": 14309, "substitutes": {"avctx": ["avtx", "vertx", " avsys", "avcmp", "avobj", " avobj", " avpkg", "vanjp", "avctl", "AVcontext", "AVsys", "AVctx", "AVjp", "avcontext", "avercontext", "averpkg", "afcontext", "avsys", "aveobj", "vanctx", "cvcontext", "avpkg", "afctl", "versys", "AVcmp", "aveconfig", " avtx", "avecontext", "aftx", " avconfig", "afctx", "vercontext", "avconfig", "AVtx", "afconfig", "averctx", "avectx", "averkt", "avjp", "verctx", " avcmp", "cvctl", "afobj", " avkt", "avkt", "vancontext", " avcontext", " avctl", "verkt", "vancmp", " avjp", "verpkg", "cvctx", "cvtx"], "seq": ["vec", "obs", "j", "sequence", "cmp", "sequ", "sq", "req", "feat", "capt", "next", "test", "eq", "batch", "gen", "syn", "len", "spec", "iq", "sec", "msg", "buf", "pse", "ext", "cl", "job", "desc", "flow", "qa", "ess", "sim", "sel", "ec", "comp", "ctrl", "Sequ", " sequence", "mp", "iter", "mod", "zip", "sup", "q", "queue", "pkg", "sc", "sub"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static BlockAIOCB *bdrv_co_aio_rw_vector(BdrvChild *child,\n\n                                         int64_t sector_num,\n\n                                         QEMUIOVector *qiov,\n\n                                         int nb_sectors,\n\n                                         BdrvRequestFlags flags,\n\n                                         BlockCompletionFunc *cb,\n\n                                         void *opaque,\n\n                                         bool is_write)\n\n{\n\n    Coroutine *co;\n\n    BlockAIOCBCoroutine *acb;\n\n\n\n    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque);\n\n    acb->child = child;\n\n    acb->need_bh = true;\n\n    acb->req.error = -EINPROGRESS;\n\n    acb->req.sector = sector_num;\n\n    acb->req.nb_sectors = nb_sectors;\n\n    acb->req.qiov = qiov;\n\n    acb->req.flags = flags;\n\n    acb->is_write = is_write;\n\n\n\n    co = qemu_coroutine_create(bdrv_co_do_rw);\n\n    qemu_coroutine_enter(co, acb);\n\n\n\n    bdrv_co_maybe_schedule_bh(acb);\n\n    return &acb->common;\n\n}\n", "idx": 14324, "substitutes": {"child": ["node", "key", "background", "handle", "seq", "ind", "pb", "ctx", "row", "other", "raw", "v", "batch", "ay", "close", "cell", "job", "cl", "nt", "poll", "shell", "ew", "desc", "th", "parent", "add", "brother", "self", "block", "c", "count", "base", "b", "client", "unk", "bl", "h", "dev", "pc", "root", "cel", "ach", "sub", "rel", "entry", "oll", "col", "children", "q", "w", "i", "x", "force", "Child", "ch"], "sector_num": ["sector_orig", "server_nom", "sectoritynam", "sectoritynum", " sector_orig", "sectoritynom", "server_number", "sector_number", "sector_nom", "server_nam", "sector_nam", "sector_Num", " sector_Num", "sectoritynumber", "sector_mon", "serveritynom", "serveritynam", "serveritynumber", "serveritynum", " sector_mon", "server_num"], "qiov": ["qiour", "eqiov", "qiv", "eqiour", "qiop", "qvr", "eqdyl", "eqovi", " qiv", "Qdyl", " qvr", "chisco", "chiev", " qisco", "Qiov", "quiour", "Qiour", "chiov", "qisco", "qovi", "Qiop", "Qovi", " qiev", "quiov", "Qiv", " qovi", "quiv", " qiop", "qiev", "quisco", "quiev", "quiop", "qdyl", "chvr", "quvr", " qdyl", " qiour"], "nb_sectors": ["nb_velements", "nb_suivers", "nb_severs", "nb_selements", "nb_speors", "nb_veivers", "nb_bectors", "nb_peers", "nb_suors", "nb_suers", "nb_pevers", "nb_peivers", "nb_seers", "nb_belements", "nb_secs", "nb_suctors", "nb_vecs", "nb_pecs", "nb_bevers", "nb_pelements", "nb_becs", "nb_spectors", "nb_spelements", "nb_specs", "nb_peors", "nb_veers", "nb_seivers", "nb_vectors", "nb_spevers", "nb_seors", "nb_pectors", "nb_veors"], "flags": ["comments", " quirks", "types", "groups", "cats", "settings", "FLAG", "tags", "offs", "utils", " offsets", "cmd", "mask", "bits", "ags", " futures", "limits", "abilities", "details", "phones", "alf", "fits", "wcs", " mods", "pins", "faces", "reports", "fts", "iffs", "heads", "bugs", "s", "items", "atts", "mods", "vals", "grades", "acts", "ads", "Flags", "stats", "forces", "flag", "args", "amps", "bps", "locks", "posts", "levels", "styles", "xf", "options", "fps", "weights", "ms", "properties", " styles", " interests", "ps"], "cb": ["fw", "cf", "bs", "pb", "cmd", "obb", "wb", "callback", "eb", "ctx", "cc", "cd", "erb", "cli", "sb", "bt", "gb", "abb", "lb", "rb", "func", "ub", "kb", "fb", "ck", "c", "cv", "db", "fp", "nc", "bf", "ctrl", "cp", "cgi", "bc", "xb", "fc", "nb", "CB", "bp", "ob"], "opaque": [" opaques", "pulent", "operque", "ropsole", "psole", "opacity", "pque", "ropacity", " opacity", "Opaques", "Opaque", "ropque", "operaque", "opaques", " opulent", "Opacity", "opulent", "ropaque", "Opulent", "pacity", "paque", "paques", "opque", "operacity", "opsole", "opersole"], "is_write": ["is__read", "is_wait", "Is_Write", "is_writ", "is_writer", "is_fine", "has_writ", "is_read", " is_read", " is_exit", "has_wait", "has_writer", "is__write", "Is_writ", "is__writ", "is_Write", "has_write", "is_exit", "Is_write", "Is_fine", "is__exit", " is_writ"], "co": ["cor", "cu", "go", "o", "local", "Co", "ctx", " Co", "cc", "mo", "ror", "io", "flo", "aco", "CO", "loc", "bo", "com", "cover", "ob", "oo", "ko", "so", "PO", "c", "ro", "fo", "po", "coord", "oe", "cons", "ho", "soc", "pc", "cho", "fc", "ano", "con", "col", "coe", "lo", "cro", "coll", "ico", "oll"], "acb": ["actbe", " cacb", "aconbe", "jacbe", "aconn", "acbe", "acch", "acca", "acbr", "acnb", " acmb", "saca", "icc", "icb", "actmb", "acbb", "achn", "absb", "sacl", "Acba", "facp", "actb", "achbe", "pacsb", "accbe", " acbb", "ainnb", "ica", "icn", "accbs", "accl", "achb", " acl", "accsb", "accn", "Acbb", "facmb", "facl", "sacb", "acc", "acon2", " acbd", "jacsb", "aca", "icbb", "sacn", "accb", " cacsb", "micsb", "ainn", "accp", "facbe", "micbc", "facn", "actp", "micbe", "micb", " ac2", "accnb", "abb", "accba", "accbc", "ac2", "achmb", "acsb", "sacrb", " acbr", " acba", " acnb", "facb", "acp", "ainb", "pacb", " acbs", "acn", "acl", "ach", "fac2", " cacp", "pacnb", "accbr", " acbe", "abh", "accc", "acmb", "jacbc", " acp", "ainba", "acbc", "jacb", "sacbd", "icl", " acrb", "pacl", "pacbr", "abnb", "acrb", " acsb", " acn", "sacc", "pach", "aconb", " cacbs", "icbd", "accbd", "accrb", "acbd", "icba", "Acb", "acba", "acbs"]}}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int standard_decode_picture_secondary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status = 0, index;\n\n\n\n    switch (v->s.pict_type)\n\n    {\n\n    case P_TYPE: status = decode_p_picture_secondary_header(v); break;\n\n    case B_TYPE: status = decode_b_picture_secondary_header(v); break;\n\n    case BI_TYPE:\n\n    case I_TYPE: break; //Nothing needed as it's done in the epilog\n\n    }\n\n    if (status < 0) return FRAME_SKIPED;\n\n\n\n    /* AC Syntax */\n\n    v->ac_table_level = decode012(gb);\n\n    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)\n\n    {\n\n        v->ac2_table_level = decode012(gb);\n\n    }\n\n    /* DC Syntax */\n\n    index = decode012(gb);\n\n    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];\n\n    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];\n\n   \n\n    return 0;\n\n}\n", "idx": 14350, "substitutes": {"v": ["vv", "nv", "qu", "view", "version", "f", "o", "ver", "tv", "V", "l", "j", "p", "wire", "vr", "vp", "vi", "conv", "val", "g", "sv", "video", "m", "y", "s", "vm", "c", "inv", "cv", "vs", "ov", "b", "vim", "lv", "h", "e", "qv", "it", "uv", "ve", "vd", "vc", "ev", "vt", "iv", "w", "av", "x", "i", "q", "value", "form"], "gb": ["csv", "gs", " GB", "gg", "py", "GB", "hog", "ctx", "wb", "hz", "hub", "eb", "storage", "g", "gu", "xy", "box", "vg", "sb", "bt", "rb", "cfg", "rect", "kb", "gd", "bn", "gt", "fg", "fb", "bridge", "cb", "bm", "db", "cv", "bf", "gc", "b", "gp", "gm", "bc", "rg", "cgi", "pc", "fc", "gif", "eg", "bb", "nb", "mb", "uf", "bg", "Gb", "gov"], "index": ["status", "key", "instance", "error", "server", "type", "axis", "insert", "position", "member", "size", "ind", "j", "scope", "row", "n", "ex", "si", "val", "check", "test", "dimension", "store", "loc", "Index", "offset", "num", "connect", "connection", "lock", "scan", "condition", "context", "add", "find", "empty", "c", "count", "capacity", "pos", "code", "device", "example", "id", "input", "set", "order", "point", "seek", "list", "length", "zero", "interface", "i", "level", "x", "ix", "sum"]}}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_class_init(ObjectClass *oc, void *data)\n\n{\n\n    MachineClass *mc = MACHINE_CLASS(oc);\n\n    NMIClass *nc = NMI_CLASS(oc);\n\n    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->ri_allowed = true;\n\n    s390mc->cpu_model_allowed = true;\n\n    s390mc->css_migration_enabled = true;\n\n    s390mc->gs_allowed = true;\n\n    mc->init = ccw_init;\n\n    mc->reset = s390_machine_reset;\n\n    mc->hot_add_cpu = s390_hot_add_cpu;\n\n    mc->block_default_type = IF_VIRTIO;\n\n    mc->no_cdrom = 1;\n\n    mc->no_floppy = 1;\n\n    mc->no_serial = 1;\n\n    mc->no_parallel = 1;\n\n    mc->no_sdcard = 1;\n\n    mc->use_sclp = 1;\n\n    mc->max_cpus = S390_MAX_CPUS;\n\n    mc->has_hotpluggable_cpus = true;\n\n    mc->get_hotplug_handler = s390_get_hotplug_handler;\n\n    mc->cpu_index_to_instance_props = s390_cpu_index_to_props;\n\n    mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids;\n\n    /* it is overridden with 'host' cpu *in kvm_arch_init* */\n\n    mc->default_cpu_type = S390_CPU_TYPE_NAME(\"qemu\");\n\n    hc->plug = s390_machine_device_plug;\n\n    hc->unplug_request = s390_machine_device_unplug_request;\n\n    nc->nmi_monitor_handler = s390_nmi;\n\n}\n", "idx": 14356, "substitutes": {"oc": ["rc", "co", "unc", "alloc", "o", "mic", "ok", "ocr", "cc", "ocation", "oco", "loc", "toc", "aco", "mac", "dc", "cms", "OC", "og", "uc", "ac", "roc", "c", "ec", "oci", "nic", "oid", "soc", "bc", "pc", "osc", "ot", "vc", "arc", "cot", "ic", "ob", "voc"], "data": ["rc", "def", "rew", "o", "out", " DATA", "raw", "di", "result", "bin", "new", "bus", "obj", "json", "info", "mu", "Data", "res", "rec", "d", "config", "DATA", "ata", "dat", "init", "name"], "mc": ["co", "mem", "tc", "conn", "cm", "tic", "mi", "lc", "mic", "mr", "cmp", "mot", "module", "cc", "mk", "mint", "css", " MC", "sam", "md", "mac", "mos", "spec", "di", "dc", "cache", "icc", "cci", "cms", "OC", "m", "cfg", "ml", "uc", "disk", "meta", "doc", "custom", "sim", "ac", "c", "bm", "mm", "disc", "abc", "mn", "ec", "yes", "gc", "cp", "nic", "bc", "cs", "mp", "pc", "any", "fc", "mt", "mod", "MC", "multi", "vc", "tm", "arc", "lim", "ms", "mx", "ic", "anc", "can", "Mc"], "nc": ["isc", "rc", "nv", "nl", "unc", "conn", "tc", "cn", "ctx", "n", "hw", "cc", "psc", "toc", "dc", "np", "nz", "nt", "nec", "roc", "ck", "xc", "mn", "ec", "gc", "ns", "nic", "cs", "bc", "pc", "fc", "nih", "nm", "rn", "ic", "anc", "nn", "NC"], "hc": [" hac", "phc", "ohcu", " hcu", "hci", "phci", "ohp", "thp", "hdc", "thcu", "hashc", "Hdc", " hdc", "Hpc", "ohac", "hpc", "Hc", "ohdc", "thac", " hp", "hac", "phcu", "hcu", " hpc", "thc", "phac", "hashac", "ohc", "hashcu", "ohpc", " hci", "Hac", "hp", "hashci"], "s390mc": ["s90mic", " s390m", " s390mn", "s30mic", "s392mc", "s30nic", "s390conn", "s30cci", "s399cci", "s399anc", " s390mic", "s390mobile", "S390mic", "s30anc", " s390nic", "s390nic", "s390MC", " s90mem", "S390mc", "s390colm", "sigmaconn", "s350MC", "s40MC", " s90conn", "s30mobile", " s30mc", " s390anc", "s90mc", "S40colm", "s350mem", "s350mic", "siftmic", "s350colm", " s30mic", " s30mn", "sigmamem", " s30m", "sletMC", "s399mic", " s90mic", "s350m", "s390cci", "s392anc", "s380mobile", " s390mobile", "s350mc", "s390mn", "S40mc", " s30cci", "s30mc", "sletcolm", "siftmc", "S390MC", "s350conn", "s390m", "sigmamic", "siftcci", "s380m", "S40mic", "s390mem", " s30mobile", "s399nic", "s399mc", "s392nic", "s90mem", " s90mc", "s380mic", "S40MC", "s350mobile", "s40colm", " s30anc", " s390cci", "s90conn", "sletmic", " s390mem", "s392mic", "s390mic", "s40mic", " s30nic", "sletmc", "S390colm", "siftmn", "s30mn", " s390conn", "s399mn", "s30m", "s40mc", "sigmamc", "s380mc", "s390anc"]}}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)\n\n{\n\n    buf[0] = 0;\n\n    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);\n\n    AV_WB16(&buf[4], s->w);\n\n    AV_WB16(&buf[6], s->h);\n\n    AV_WB16(&buf[8], num_strips);\n\n\n\n    return CVID_HEADER_SIZE;\n\n}\n", "idx": 14359, "substitutes": {"s": ["aws", "ses", "gs", "a", "S", "as", "serv", "p", "js", "n", "ex", "sq", "source", "comm", "is", "sb", "als", "sv", "spec", "ds", "ats", "in", "r", "ess", "qs", "ts", "self", "c", "ins", "ns", "b", "cs", "h", "fs", "conf", "sg", "ss", "w", "sts", "rs", "ps"], "buf": ["Buff", "bytes", "bar", "vec", "mem", "ptr", "paste", "late", "cur", "ff", "seq", "pb", "map", "cmd", "aka", "window", "Buffer", "bh", "proc", "req", "pool", "fam", "port", "batch", "box", "loc", "cache", "buff", "cap", "rb", "func", "cat", "br", "cam", "desc", "bag", "env", "off", "doc", "buffer", "cb", "cv", "db", "pos", "img", "b", "args", "bc", "fac", "font", "tmp", "uf", "err", "queue", "bp", "pkg", "cast", "usr", "tab", "arr", "pack"], "num_strips": ["num_striips", "num_stripped", "num_stripops", "num_wrapped", "num_stripips", "num_ripped", "num_snPS", "num_snps", "num_wraPS", "num_riops", "num_strippped", "num_striPS", "num_stripPS", "num_rips", "num_stripps", "num_riips", "num_snips", "num_striops", "num_wraops", "num_wraips", "num_wraps", "num_snops"], "data_size": ["DATA_length", "data_Size", "data_length", "DATA_SIZE", "DATA_Size", "data2SIZE", "data_source", "DATA_size", "DATA_source", "data2length", "data2Size", "data_SIZE", "data2size"]}}
{"project": "FFmpeg", "commit_id": "f907615f0813e8499f06a7eebccf1c63fce87c8e", "target": 1, "func": "static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n\n\n    pc->enc = av_mallocz(sizeof(MpegEncContext));\n\n    if (!pc->enc)\n\n        return -1;\n\n    pc->first_picture = 1;\n\n\n    return 0;\n\n}", "idx": 14362, "substitutes": {"s": ["ses", "aws", "gs", "a", "S", "sac", "as", "less", "p", "js", "n", "sq", "sb", "sv", "sys", "ds", "ats", "sa", "r", "acs", "qs", "ts", "c", "ins", "ns", "cs", "h", "set", "fs", "os", "ss", "sts", "ms", "i", "rs", "ps"], "pc": ["rc", "cu", "td", "co", "unc", "tc", "oc", "pi", "lc", "pr", "pb", "ctx", "p", "kt", "cc", "proc", "pm", "pan", "pd", "pt", "ic", "dc", "icc", "ct", "uc", "acs", "ac", "ck", "pic", "c", "lp", "xc", "nc", "ec", "pn", "pac", "wp", "cp", "gc", "mc", "cs", "bc", " mp", "etc", "fc", "soc", "ack", "PC", "px", "amp", "vc", "pkg", "tp", "pa", "anc"]}}
{"project": "FFmpeg", "commit_id": "a6d6b8a20072a5919d38258dd48cc612e2372f81", "target": 1, "func": "const AVOption *av_opt_next(void *obj, const AVOption *last)\n\n{\n\n    AVClass *class = *(AVClass**)obj;\n\n    if (!last && class->option[0].name) return class->option;\n\n    if (last && last[1].name)           return ++last;\n\n    return NULL;\n\n}\n", "idx": 14366, "substitutes": {"obj": ["instance", "impl", "o", "src", "object", "onet", "attr", "ctx", "js", "owner", "opt", "typ", "next", "ent", "Obj", "rb", "act", "nt", "og", "rect", "att", "off", "org", "rt", "oj", "oid", "tmp", "lass", "ot", "elt", "err", "objects", "pkg", "inst", "str", "txt", "ob", "arr"], "last": ["node", "never", "always", "est", "prev", "local", "global", "Last", "latest", "highest", "good", "push", "data", "native", "old", "str", "reverse", "stat", "leaf", "tail", "next", "ent", "close", "nd", "kind", "st", "end", "cache", "bottom", "show", "weak", "command", "nt", "br", "rest", "tag", "th", "first", "parent", "rev", "info", "empty", "count", "all", "recent", "table", "forced", "active", "any", "max", "list", "state", "length", "total", "style", "las", "final", "slave", "cycle", "ast", "needed", "full", "only"], "class": ["node", "instance", "type", "co", "product", "classes", "object", "section", "Class", "this", "lib", "module", "ass", "spec", "util", "common", " Class", "cl", "future", "tag", "first", "CLASS", "parent", "attribute", "use", "self", "c", "file", "base", "all", "function", " CLASS", "top", "lass", "con", "ace", "from", "config", "classified", "style", "package", "interface", "cast", "name", "pack"]}}
{"project": "FFmpeg", "commit_id": "369cb092ecbbaff20bb0a2a1d60536c3bc04a8f0", "target": 1, "func": "static void do_audio_out(AVFormatContext *s, OutputStream *ost,\n\n                         InputStream *ist, AVFrame *decoded_frame)\n\n{\n\n    uint8_t *buftmp;\n\n\n\n    int size_out, frame_bytes, resample_changed, ret;\n\n    AVCodecContext *enc = ost->st->codec;\n\n    AVCodecContext *dec = ist->st->codec;\n\n    int osize = av_get_bytes_per_sample(enc->sample_fmt);\n\n    int isize = av_get_bytes_per_sample(dec->sample_fmt);\n\n    uint8_t *buf = decoded_frame->data[0];\n\n    int size     = decoded_frame->nb_samples * dec->channels * isize;\n\n    int out_linesize = 0;\n\n    int buf_linesize = decoded_frame->linesize[0];\n\n\n\n    get_default_channel_layouts(ost, ist);\n\n\n\n    if (alloc_audio_output_buf(dec, enc, decoded_frame->nb_samples, &out_linesize) < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Error allocating audio buffer\\n\");\n\n        exit_program(1);\n\n    }\n\n\n\n    if (audio_sync_method > 1                      ||\n\n        enc->channels       != dec->channels       ||\n\n        enc->channel_layout != dec->channel_layout ||\n\n        enc->sample_rate    != dec->sample_rate    ||\n\n        dec->sample_fmt     != enc->sample_fmt)\n\n        ost->audio_resample = 1;\n\n\n\n    resample_changed = ost->resample_sample_fmt  != dec->sample_fmt ||\n\n                       ost->resample_channels    != dec->channels   ||\n\n                       ost->resample_channel_layout != dec->channel_layout ||\n\n                       ost->resample_sample_rate != dec->sample_rate;\n\n\n\n    if ((ost->audio_resample && !ost->avr) || resample_changed) {\n\n        if (resample_changed) {\n\n            av_log(NULL, AV_LOG_INFO, \"Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d chl:0x%\"PRIx64\" to rate:%d fmt:%s ch:%d chl:0x%\"PRIx64\"\\n\",\n\n                   ist->file_index, ist->st->index,\n\n                   ost->resample_sample_rate, av_get_sample_fmt_name(ost->resample_sample_fmt),\n\n                   ost->resample_channels, ost->resample_channel_layout,\n\n                   dec->sample_rate, av_get_sample_fmt_name(dec->sample_fmt),\n\n                   dec->channels, dec->channel_layout);\n\n            ost->resample_sample_fmt  = dec->sample_fmt;\n\n            ost->resample_channels    = dec->channels;\n\n            ost->resample_channel_layout = dec->channel_layout;\n\n            ost->resample_sample_rate = dec->sample_rate;\n\n            if (ost->avr)\n\n                avresample_close(ost->avr);\n\n        }\n\n        /* if audio_sync_method is >1 the resampler is needed for audio drift compensation */\n\n        if (audio_sync_method <= 1 &&\n\n            ost->resample_sample_fmt  == enc->sample_fmt &&\n\n            ost->resample_channels    == enc->channels   &&\n\n            ost->resample_channel_layout == enc->channel_layout &&\n\n            ost->resample_sample_rate == enc->sample_rate) {\n\n            ost->audio_resample = 0;\n\n        } else if (ost->audio_resample) {\n\n            if (!ost->avr) {\n\n                ost->avr = avresample_alloc_context();\n\n                if (!ost->avr) {\n\n                    av_log(NULL, AV_LOG_FATAL, \"Error allocating context for libavresample\\n\");\n\n                    exit_program(1);\n\n                }\n\n            }\n\n\n\n            av_opt_set_int(ost->avr, \"in_channel_layout\",  dec->channel_layout, 0);\n\n            av_opt_set_int(ost->avr, \"in_sample_fmt\",      dec->sample_fmt,     0);\n\n            av_opt_set_int(ost->avr, \"in_sample_rate\",     dec->sample_rate,    0);\n\n            av_opt_set_int(ost->avr, \"out_channel_layout\", enc->channel_layout, 0);\n\n            av_opt_set_int(ost->avr, \"out_sample_fmt\",     enc->sample_fmt,     0);\n\n            av_opt_set_int(ost->avr, \"out_sample_rate\",    enc->sample_rate,    0);\n\n            if (audio_sync_method > 1)\n\n                av_opt_set_int(ost->avr, \"force_resampling\", 1, 0);\n\n\n\n            /* if both the input and output formats are s16 or u8, use s16 as\n\n               the internal sample format */\n\n            if (av_get_bytes_per_sample(dec->sample_fmt) <= 2 &&\n\n                av_get_bytes_per_sample(enc->sample_fmt) <= 2) {\n\n                av_opt_set_int(ost->avr, \"internal_sample_fmt\", AV_SAMPLE_FMT_S16P, 0);\n\n            }\n\n\n\n            ret = avresample_open(ost->avr);\n\n            if (ret < 0) {\n\n                av_log(NULL, AV_LOG_FATAL, \"Error opening libavresample\\n\");\n\n                exit_program(1);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (audio_sync_method > 0) {\n\n        double delta = get_sync_ipts(ost, ist->last_dts) * enc->sample_rate - ost->sync_opts -\n\n                       av_fifo_size(ost->fifo) / (enc->channels * osize);\n\n        int idelta = delta * dec->sample_rate / enc->sample_rate;\n\n        int byte_delta = idelta * isize * dec->channels;\n\n\n\n        // FIXME resample delay\n\n        if (fabs(delta) > 50) {\n\n            if (ist->is_start || fabs(delta) > audio_drift_threshold*enc->sample_rate) {\n\n                if (byte_delta < 0) {\n\n                    byte_delta = FFMAX(byte_delta, -size);\n\n                    size += byte_delta;\n\n                    buf  -= byte_delta;\n\n                    av_log(NULL, AV_LOG_VERBOSE, \"discarding %d audio samples\\n\",\n\n                           -byte_delta / (isize * dec->channels));\n\n                    if (!size)\n\n                        return;\n\n                    ist->is_start = 0;\n\n                } else {\n\n                    av_fast_malloc(&async_buf, &allocated_async_buf_size,\n\n                                   byte_delta + size);\n\n                    if (!async_buf) {\n\n                        av_log(NULL, AV_LOG_FATAL, \"Out of memory in do_audio_out\\n\");\n\n                        exit_program(1);\n\n                    }\n\n\n\n                    if (alloc_audio_output_buf(dec, enc, decoded_frame->nb_samples + idelta, &out_linesize) < 0) {\n\n                        av_log(NULL, AV_LOG_FATAL, \"Error allocating audio buffer\\n\");\n\n                        exit_program(1);\n\n                    }\n\n                    ist->is_start = 0;\n\n\n\n                    generate_silence(async_buf, dec->sample_fmt, byte_delta);\n\n                    memcpy(async_buf + byte_delta, buf, size);\n\n                    buf = async_buf;\n\n                    size += byte_delta;\n\n                    buf_linesize = allocated_async_buf_size;\n\n                    av_log(NULL, AV_LOG_VERBOSE, \"adding %d audio samples of silence\\n\", idelta);\n\n                }\n\n            } else if (audio_sync_method > 1) {\n\n                int comp = av_clip(delta, -audio_sync_method, audio_sync_method);\n\n                av_log(NULL, AV_LOG_VERBOSE, \"compensating audio timestamp drift:%f compensation:%d in:%d\\n\",\n\n                       delta, comp, enc->sample_rate);\n\n//                fprintf(stderr, \"drift:%f len:%d opts:%\"PRId64\" ipts:%\"PRId64\" fifo:%d\\n\", delta, -1, ost->sync_opts, (int64_t)(get_sync_ipts(ost) * enc->sample_rate), av_fifo_size(ost->fifo)/(ost->st->codec->channels * 2));\n\n                avresample_set_compensation(ost->avr, comp, enc->sample_rate);\n\n            }\n\n        }\n\n    } else if (audio_sync_method == 0)\n\n        ost->sync_opts = lrintf(get_sync_ipts(ost, ist->last_dts) * enc->sample_rate) -\n\n                                av_fifo_size(ost->fifo) / (enc->channels * osize); // FIXME wrong\n\n\n\n    if (ost->audio_resample) {\n\n        buftmp = audio_buf;\n\n        size_out = avresample_convert(ost->avr, (void **)&buftmp,\n\n                                      allocated_audio_buf_size, out_linesize,\n\n                                      (void **)&buf, buf_linesize,\n\n                                      size / (dec->channels * isize));\n\n        size_out = size_out * enc->channels * osize;\n\n    } else {\n\n        buftmp = buf;\n\n        size_out = size;\n\n    }\n\n\n\n    /* now encode as many frames as possible */\n\n    if (!(enc->codec->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE)) {\n\n        /* output resampled raw samples */\n\n        if (av_fifo_realloc2(ost->fifo, av_fifo_size(ost->fifo) + size_out) < 0) {\n\n            av_log(NULL, AV_LOG_FATAL, \"av_fifo_realloc2() failed\\n\");\n\n            exit_program(1);\n\n        }\n\n        av_fifo_generic_write(ost->fifo, buftmp, size_out, NULL);\n\n\n\n        frame_bytes = enc->frame_size * osize * enc->channels;\n\n\n\n        while (av_fifo_size(ost->fifo) >= frame_bytes) {\n\n            av_fifo_generic_read(ost->fifo, audio_buf, frame_bytes, NULL);\n\n            encode_audio_frame(s, ost, audio_buf, frame_bytes);\n\n        }\n\n    } else {\n\n        encode_audio_frame(s, ost, buftmp, size_out);\n\n    }\n\n}\n", "idx": 14372, "substitutes": {"s": ["a", "sw", "as", "o", "src", "sq", "v", "g", "t", "is", "sv", "sb", "ds", "ats", "ls", "sa", "c", "es", "e", "fs", "os", "ss", "w", "i", "rs", "ps"], "ost": ["ont", "boost", "yt", "est", "rog", "obs", "et", "o", "oc", "htt", "tto", "onet", "ys", "ind", "utt", "tt", "ocr", "or", "otype", "OST", "ott", "oop", "iop", "ori", "lost", "oth", "rost", "store", "ox", "ert", "mont", "st", "hs", "oad", "oster", "nt", "irst", "rest", "op", "osta", "hop", "oss", "org", "irc", "vest", "om", "art", "ust", "od", "oe", "ops", "istor", "post", "oid", "soc", "ether", "orth", "rob", "ort", "host", "lov", "ot", "ft", "os", "ore", "hess", "ast", "ond", "ob", " nost"], "ist": ["isc", "il", "iste", "ict", "est", "ists", "et", "icol", "src", "htt", "isd", "pir", "exist", "elist", "tt", "osi", "erd", "rist", "vp", "iop", "oth", "ista", "ith", "hist", "pt", "osp", "ert", "ih", "is", "ik", "st", "ilst", "irst", "isting", "iss", "iz", "IST", "dit", "rest", "isi", "ird", "iw", "irc", "art", "ust", "ism", "wp", "ht", "istor", "ush", "osit", "ort", "alist", "istant", "ft", "it", "its", "ast", "iv", "sts", "inst", "ic", "txt"], "decoded_frame": ["decodedoyprofile", "decodedptframe", "decoded_frames", "deccoded_frame", "decoded_sample", "decoded3frame", "decodedingfeat", "decoded_image", "decoded_file", "decachedptcomponent", "decodedroyframe", "decodedingframes", "decoded3fram", "decached_component", "decodedoyframe", "decoded___message", "decatedmysample", "decoded3feature", "decoded_message", "decodedationcomponent", "decodededfeat", "decodedationframe", "deccoded_sequence", "decodedmymessage", "decoded_profile", "decodedoycomponent", "decodedptprofile", "decode_frame", "decodedationprofile", "decoded_sequence", "decoded___image", "decoded___frame", "deccoded_frames", "decode_feat", "decodededbase", "decoded_feature", "decoded_component", "decodedationuser", "decodedingbase", "decated_sample", "decodedationfram", "decached_frame", "decodedationfile", "decodedoyuser", "deccoded___user", "decachedptprofile", "decodededframe", "decodedroyframes", "decoded___sequence", "decoded_base", "deccoded___frame", "decodedptcomponent", "decachedptuser", "decode_base", "decodedmyimage", "decachedptframe", "decated_image", "decatedmyimage", "decoded_fram", "decodedroyuser", "decimated_frame", "decatedmyframe", "decodedingframe", "decoded___frames", "decode_frames", "decoded___sample", "decatedmymessage", "deccoded___sequence", "decimated_file", "decached_user", "decoded_feat", "decoded_user", "decodededframes", "decodedroysequence", "deccoded___frames", "decimated_fram", "decoded3file", "decoded___user", "decimated_feature", "decodedationfeature", "decached_profile", "decodedptuser", "decated_frame", "deccoded_user", "decodedmyframe", "decated_message", "decodedmysample"], "buftmp": ["fufdool", "bufdmp", "fufdMP", "buftup", "fuftMP", "fuftool", "buptmp", "buftool", "bufdool", "bufdup", "buctmp", "bufdMP", "buctup", "buptup", "fufdup", "fuftup", "buptMP", "buctool", "buftMP", "fuftmp", "fufdmp", "buptool", "buctMP"], "size_out": ["size2Out", "size_in", "size2in", "ize_out", "ize_in", "size_Out", "size2out", "ize_output", "size_output", "size2output", "ize_Out"], "frame_bytes": [" frame_offset", "frame_offset", " frame_size", "frame_byte", " frame_byte", "frame_size"], "resample_changed": ["ressample_change", "resample2changed", "resamp_rot", "resample_required", "ressample_required", "resample__changed", "ressample_locked", "resample__created", "resample_created", "resamp_created", "resample_change", "resample_rot", "resample_locked", "resample2was", "resample___changed", "resamp_changed", "resample2change", "resample___was", "resample_forced", "resamples_Changed", "resamples_change", "resamples_was", "resamp_change", "resample___change", "resample__rot", "resample2Changed", "resample___Changed", "resample_was", "resample_Changed", "ressample_forced", "resample__change", "ressample_changed", "resamples_changed"], "ret": ["resp", "jp", "status", "rew", "mem", "ref", "Ret", "RET", "reset", "val", "conv", "len", "alt", "aux", "rt", "res", "flag", "gc", "re", "tmp", "rel", "elt", "fi", "txt", "arr"], "enc": ["rc", "kw", "Enc", "vec", "unc", "conn", "et", "oc", " Enc", "exc", "ena", "ren", "cmd", "inc", "cmp", "cod", "conv", "ent", "acc", "ox", "esc", "encrypted", "sec", "En", "ens", "eu", "lang", "act", "desc", "ew", "env", "obj", "ac", "disc", "en", "ENC", "ec", "nc", "ang", "code", "oen", "ack", "enth", "acl", "rec", "fc", "con", "eg", "oder", "emb", "eng", "ne", "ev", "iv", "iac", "anc", "asc"], "buf": ["vec", "mem", "out", "output", "seq", "data", "map", "cmd", "pb", "raw", "msg", "buff", "bin", "br", "doc", "buffer", "cb", "cv", "img", "bf", "b", "bc", "tmp", "uf", "err", "queue", "txt", "arr"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_arm_shift_im(TCGv var, int shiftop, int shift, int flags)\n\n{\n\n    switch (shiftop) {\n\n    case 0: /* LSL */\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, 32 - shift);\n\n            tcg_gen_shli_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 1: /* LSR */\n\n        if (shift == 0) {\n\n            if (flags) {\n\n                tcg_gen_shri_i32(var, var, 31);\n\n                gen_set_CF(var);\n\n            }\n\n            tcg_gen_movi_i32(var, 0);\n\n        } else {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_shri_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 2: /* ASR */\n\n        if (shift == 0)\n\n            shift = 32;\n\n        if (flags)\n\n            shifter_out_im(var, shift - 1);\n\n        if (shift == 32)\n\n          shift = 31;\n\n        tcg_gen_sari_i32(var, var, shift);\n\n        break;\n\n    case 3: /* ROR/RRX */\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_rotri_i32(var, var, shift); break;\n\n        } else {\n\n            TCGv tmp = load_cpu_field(CF);\n\n            if (flags)\n\n                shifter_out_im(var, 0);\n\n            tcg_gen_shri_i32(var, var, 1);\n\n            tcg_gen_shli_i32(tmp, tmp, 31);\n\n            tcg_gen_or_i32(var, var, tmp);\n\n            dead_tmp(tmp);\n\n        }\n\n    }\n\n};\n", "idx": 14376, "substitutes": {"var": ["orig", "attr", "expr", "ctx", "raw", "val", "rank", "word", "function", "star", "car", "lat", "coord", "vs", "ser", "fac", "lv", "shape", "pkg", "usr", "pack", "kw", "view", "type", "mem", "ptr", "prev", "addr", "map", "cmd", "par", "module", "let", "v", "ar", "test", "box", "spec", "via", "Var", "vari", "cat", "obj", "ars", "self", "null", "ctrl", "cp", "input", "tmp", "bb", "vc", "iv", "av", "x", "tab", "cf", "as", "ver", "ref", "row", "temp", "req", "buf", "sys", "op", "buffer", "c", "variable", "cv", "wd", "dev", "iter", "err", "cast", "str", "bar", "go", "lr", "grad", "p", "vr", "msg", "feature", "func", "act", "ct", "tag", "bag", "vm", "rt", "sp", "mod", "watch", "w", "name"], "shiftop": ["expoper", "shiftOP", " shiftcop", "offsetop", " shiftops", "offsetcop", "hiftoper", "offsetOP", "shiftops", "hiftops", "tipop", "tipcop", "expOP", "shiftoper", "hiftOP", "expop", " shiftoper", "tipOP", "shiftcop", "hiftop", " shiftOP", "offsetops", "tipops", "expops"], "shift": ["index", "focus", "push", "window", "delete", "half", "field", "close", "loc", "help", "delay", "send", "hift", "hide", "lag", "add", "sh", "ul", "star", "center", "start", "vector", " shifted", "grow", "tick", "length", " shifts", "sup", "need", "sum", "pack", "error", "drop", "ff", "mask", "pop", "share", "xp", "stack", "ign", "align", "forward", "power", "use", "dest", "shake", "flag", "scale", "alias", "slice", "set", "seek", "tip", "eng", "join", "ift", "save", "ix", "carry", "move", "reverse", "batch", "hack", "now", "offset", "snap", "step", "ffff", "transform", "weight", "hash", "just", " Shift", "jp", "sort", "handle", "aw", "size", "skip", "diff", "alt", "off", "Shift", "dq", "count", "ssh", "shr", "effect", "pad", "value", "sign"], "flags": ["comments", "aws", "groups", "goal", "gs", "cf", "opens", "tags", "ports", "laws", "cond", "lines", "mask", "bits", "Flag", "ags", "fields", "limits", "words", "details", "features", "olds", "workers", "pins", "ments", "reports", "points", "heads", "bugs", "finals", "atts", "lag", "grades", "ts", "Flags", "mates", "stats", "products", "flag", "helps", "args", "cs", "cons", "amps", "fs", "lets", "locks", "weight", "posts", "levels", "styles", "options", "ants", " Flags", "files", "weights", "fps", "planes", "ms", "packages", "properties", "members", "af"]}}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static void vmxnet3_update_vlan_filters(VMXNET3State *s)\n\n{\n\n    int i;\n\n\n\n    /* Copy configuration from shared memory */\n\n    VMXNET3_READ_DRV_SHARED(s->drv_shmem,\n\n                            devRead.rxFilterConf.vfTable,\n\n                            s->vlan_table,\n\n                            sizeof(s->vlan_table));\n\n\n\n    /* Invert byte order when needed */\n\n    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {\n\n        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);\n\n    }\n\n\n\n    /* Dump configuration for debugging purposes */\n\n    VMW_CFPRN(\"Configured VLANs:\");\n\n    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {\n\n        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {\n\n            VMW_CFPRN(\"\\tVLAN %d is present\", i);\n\n        }\n\n    }\n\n}\n", "idx": 14379, "substitutes": {"s": ["sql", "ses", "aws", "gs", "des", "S", "sw", "o", "bs", "less", "ports", "p", "n", "js", "ex", "params", "sq", "where", "v", "eps", "g", "sl", "details", "store", "t", "source", "comm", "is", "sv", "sb", "st", "spec", "hs", "sys", "ds", "ls", "m", "r", "services", "qs", "so", "ts", "c", "stats", "ears", "vs", "states", "ns", "ops", "cs", "h", "es", "changes", "fs", "os", "d", "its", "parts", "w", "ss", "sts", "rs", "ps"], "i": ["index", " li", "cli", "gu", "t", " pi", "result", " ki", "ami", "ai", "m", " I", "xi", "qi", "client", "ims", "it", "ji", "us", "li", "oi", "ind", "j", "ki", "si", "zi", " ti", "ori", "g", "ui", "iq", " bi", "im", "print", "ti", "fi", "ex", "x", "ri", "span", "ix", "ip", "ij", "key", "mi", "ii", "I", "pi", " iter", "yi", " si", "batch", "di", " ii", " mi", "in", "json", "sim", "c", "remote", "ci", "id", "u", "multi", "to", "me", "iu", "o", "ski", " j", "ini", "l", "ei", "uri", "p", "name", "chain", "bi", "io", "hi", "iri", "\u0438", "eric", " multi", "cgi", "e", "point", "gi", " m", "z", "q", "phi", "init", "y"]}}
{"project": "qemu", "commit_id": "a9cf98d939c4f6539fad7e7d812ea16d96ba3dc9", "target": 0, "func": "static void arm_timer_recalibrate(arm_timer_state *s, int reload)\n\n{\n\n    uint32_t limit;\n\n\n\n    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {\n\n        /* Free running.  */\n\n        if (s->control & TIMER_CTRL_32BIT)\n\n            limit = 0xffffffff;\n\n        else\n\n            limit = 0xffff;\n\n    } else {\n\n          /* Periodic.  */\n\n          limit = s->limit;\n\n    }\n\n    ptimer_set_limit(s->timer, limit, reload);\n\n}\n", "idx": 14387, "substitutes": {"s": ["sis", "ses", "aws", "south", "gs", "a", "S", "sw", "bs", "less", "j", "p", "js", "sq", "sl", "http", "store", "t", "source", "comm", "is", "sb", "sv", "spec", "hs", "sys", "ds", "ls", "r", "qs", "ts", "sp", "stats", "ns", "b", "h", "es", "an", "set", "fs", "os", "se", "q", "sports", "ss", "sts", "y", "rs", "ps"], "reload": [" reloads", " reloader", "Reloaded", " Reload", " reLoad", "ReLoad", "REload", " ReLoad", "reLoad", "REloader", "reloads", " rethink", " Rethink", " Reloads", " reloaded", "REloaded", "Rethink", "REthink", "Reload", "reloaded", "reloader", "Reloads", "Reloader", "rethink"], "limit": ["status", "wait", "view", "minimum", "late", "position", "latest", "Limit", "local", "pi", "size", "l", "map", "p", "window", "timeout", "tail", "trigger", "limits", "pool", "port", "source", "len", "pointer", "policy", "enable", "delay", "cut", "offset", "lock", "lit", "line", "condition", "alt", "message", "time", "control", "match", "margin", "buffer", "block", "limited", "capacity", "base", "file", "lan", "print", "Lim", "iter", "duration", "max", "length", "it", "total", "target", "queue", "value", "filter", "level", "join", "lim", "fine", "only", "required", "priority"]}}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_down_char(void)\n\n{\n\n    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)\n\n\treturn;\n\n    if (term_history[++term_hist_entry] != NULL) {\n\n\tpstrcpy(term_cmd_buf, sizeof(term_cmd_buf),\n\n                term_history[term_hist_entry]);\n\n    } else {\n\n\tterm_hist_entry = -1;\n\n    }\n\n    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n\n}\n", "idx": 14388, "substitutes": {"term_hist_entry": ["term_hist_key", "term_history_offset", "term_histopentry", "term_hist___key", "term_history_window", "term_histityentry", "term_history_char", "term_hist_offset", "term_histitychar", "term_hist_window", "term_history_entity", "term_hist___entry", "term_hist_desc", "term_histoprow", "term_history_entry", "term_hist___no", "term_history_key", "term_history_row", "term_histopentity", "term_hist_no", "term_histitykey", "term_hist_char", "term_hist___offset", "term_hist_number", "term_history_number", "term_hist_row", "term_history_desc", "term_hist_entity", "term_histitydesc", "term_history_no"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_log_start(target_phys_addr_t phys_addr, ram_addr_t size)\n\n{\n\n        return kvm_dirty_pages_log_change(phys_addr, size,\n\n                                          KVM_MEM_LOG_DIRTY_PAGES,\n\n                                          KVM_MEM_LOG_DIRTY_PAGES);\n\n}\n", "idx": 14393, "substitutes": {"phys_addr": ["mem_adr", "physqact", " phys_map", "physqmap", "phys_map", "physipact", "phys_adr", "physqadr", "phys_address", "physipaddr", "mem_address", "physipadr", "physqaddr", " phys_adr", "mem_addr", "physipmap", "phys_act", " phys_act"], "size": ["bytes", "Size", "path", "by", "pi", "SIZE", "body", "owner", "storage", "share", "params", "used", "is", "ize", "izes", "read", "send", "fee", "sha", "dim", "use", "empty", " Size", "count", "since", "password", "code", "sh", "fat", "scale", "root", "area", "set", "max", "length", "state", "shape", "small", " sizes", "news", "name", "too", "sum"]}}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_log(int argc, const char **argv)\n\n{\n\n    int mask;\n\n    \n\n    if (argc != 2)\n\n        goto help;\n\n    if (!strcmp(argv[1], \"none\")) {\n\n        mask = 0;\n\n    } else {\n\n        mask = cpu_str_to_log_mask(argv[1]);\n\n        if (!mask) {\n\n        help:\n\n            help_cmd(argv[0]);\n\n            return;\n\n        }\n\n    }\n\n    cpu_set_log(mask);\n\n}\n", "idx": 14413, "substitutes": {"argc": ["Argc", "arknc", "arkc", " argce", "argce", " argpc", "arkce", " argnc", "agct", "Argpc", " argct", "agcs", "Argv", "Argcs", "argnc", "Argce", "Argct", "argcs", "arkv", "Argnc", " argcs", "agpc", "agc", "argpc", "argct"], "argv": [" argp", " argl", "argsl", "Argc", "regvs", "argvs", "argsp", "datepi", "datec", "argl", " argpi", "argsvs", "argss", "argk", "regc", " argvs", " argk", "datev", "Argv", "argsk", "argp", " args", "argspi", "argpi", "Argk", "argsv", "regp", "args", "argumentvs", "argumentv", "regv", "argsc", "argumentc", "dates", "Argl", "argumentp"], "mask": ["bit", "key", "allow", "shift", "patch", "cm", "bug", "bool", "map", "row", "window", "miss", "share", "hold", "gray", "mk", "pack", "mail", "batch", "msg", "result", "offset", "cat", "m", "lock", "qa", "hide", "gate", "ask", "mark", "broad", "black", "Mask", "match", "clean", "lay", "block", "mut", "count", " masked", "flag", "scale", "master", "label", "set", "transform", "mt", "clear", "weight", "hash", "list", "mb", "form", "ma", "zero", "sign", "cast", "ms", "mx", "can", "sum", "sk"]}}
{"project": "FFmpeg", "commit_id": "1a3ed056c523b4670e192301be15dbc521ec8353", "target": 0, "func": "static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)\n\n{\n\n    HEVCContext *s  = avctxt->priv_data;\n\n    int ctb_size    = 1 << s->sps->log2_ctb_size;\n\n    int more_data   = 1;\n\n    int x_ctb       = 0;\n\n    int y_ctb       = 0;\n\n    int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];\n\n\n\n    if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Impossible initial tile.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->sh.dependent_slice_segment_flag) {\n\n        int prev_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts - 1];\n\n        if (s->tab_slice_address[prev_rs] == -1) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Previous slice segment missing\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    while (more_data && ctb_addr_ts < s->sps->ctb_size) {\n\n        int ctb_addr_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts];\n\n\n\n        x_ctb = (ctb_addr_rs % ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;\n\n        y_ctb = (ctb_addr_rs / ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;\n\n        hls_decode_neighbour(s, x_ctb, y_ctb, ctb_addr_ts);\n\n\n\n        ff_hevc_cabac_init(s, ctb_addr_ts);\n\n\n\n        hls_sao_param(s, x_ctb >> s->sps->log2_ctb_size, y_ctb >> s->sps->log2_ctb_size);\n\n\n\n        s->deblock[ctb_addr_rs].beta_offset = s->sh.beta_offset;\n\n        s->deblock[ctb_addr_rs].tc_offset   = s->sh.tc_offset;\n\n        s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;\n\n\n\n        more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);\n\n        if (more_data < 0) {\n\n            s->tab_slice_address[ctb_addr_rs] = -1;\n\n            return more_data;\n\n        }\n\n\n\n\n\n        ctb_addr_ts++;\n\n        ff_hevc_save_states(s, ctb_addr_ts);\n\n        ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);\n\n    }\n\n\n\n    if (x_ctb + ctb_size >= s->sps->width &&\n\n        y_ctb + ctb_size >= s->sps->height)\n\n        ff_hevc_hls_filter(s, x_ctb, y_ctb);\n\n\n\n    return ctb_addr_ts;\n\n}\n", "idx": 14442, "substitutes": {"avctxt": ["avcitxt", " avctkt", "avcitkt", "AVccxt", "avcontxt", "AVccext", "avctext", "AVcttx", "avcontext", "avcittxt", "avptext", "AVctext", "avcxt", "avcittx", "avcttxt", "avccext", " avcttx", "avconttx", "AVcctx", "AVcttxt", "avcctxt", "AVctxt", "avconttxt", "avpttx", " avctx", "avcttx", "AVcctxt", "avctx", "avctkt", " avcttxt", "avcckt", "avckt", "avptxt", " avckt", " avcxt", "avpttxt", "avccxt", "avcctx"], "isFilterThread": ["isfilterThread", "isBrowserEvent", " isFilterEvent", "isFilterEvent", "isBrowserthread", "isWebThread", "isBrowserThread", "isWebEvent", " isfilterthread", "isFilterthread", " isfilterThread", "isfilterEvent", "isWebthread", "isfilterthread", " isFilterthread", " isfilterEvent"], "s": ["ses", "gs", "S", "bs", "ties", "ports", "ctx", "sq", "ags", "sl", "t", "m", "qs", "stats", "vs", "cs", "ims", "aunts", "its", "ants", "us", "ps", "sw", "ions", "j", "js", "v", "g", "comm", "spec", "ds", "ats", "ies", "sc", "args", "conf", "ows", "ains", "parts", "scl", "ex", "x", "actions", "a", "as", "less", "ysis", "source", "als", "sb", "service", "hs", "mys", "c", "ares", "es", "events", "fs", "changes", "bis", "sports", "ss", "comments", "aws", "has", "p", "details", "bes", "is", "sv", "ls", "gets", "ts", "ins", "ns", "b", "h", "os", "z", "w", "sts", "ms", "rs"], "ctb_addr_ts": ["ctb_addr_abs", "ctb_adr_times", "ctb_address_ps", "ctb_adr_ps", "ctb_ptr_ls", "ctb_ref_ts", "ctb_ptr_ms", "ctb_addr_ls", "ctb_ref_cs", "ctb_addr2ts", "ctb_addr2rs", "ctb_addr_rs", "ctb_addr_ps", "ctb_address_rs", "ctb_ref_snap", "ctb_adr_cs", "ctb_ptr_times", "ctb_address_ts", "ctb_ptr_ts", "ctb_addr_times", "ctb_adr_ts", "ctb_address_abs", "ctb_addr_ms", "ctb_ptr_ctr", "ctb_addr2ms", "ctb_ptr_ps", "ctb_ptr_rs", "ctb_addr_cs", "ctb_addr2tes", "ctb_addr_t", "ctb_addr_ctr", "ctb_addr_ats", "ctb_addr_tes", "ctb_ref_t", "ctb_addr_snap"]}}
{"project": "FFmpeg", "commit_id": "8155233413540c63e53a620ff5734fb4b0635611", "target": 1, "func": "static int decode_header(MPADecodeContext *s, UINT32 header)\n\n{\n\n    int sample_rate, frame_size, mpeg25, padding;\n\n    int sample_rate_index, bitrate_index;\n\n    if (header & (1<<20)) {\n\n        s->lsf = (header & (1<<19)) ? 0 : 1;\n\n        mpeg25 = 0;\n\n    } else {\n\n        s->lsf = 1;\n\n        mpeg25 = 1;\n\n    }\n\n    \n\n    s->layer = 4 - ((header >> 17) & 3);\n\n    /* extract frequency */\n\n    sample_rate_index = (header >> 10) & 3;\n\n    sample_rate = mpa_freq_tab[sample_rate_index] >> (s->lsf + mpeg25);\n\n    if (sample_rate == 0)\n\n        return 1;\n\n    sample_rate_index += 3 * (s->lsf + mpeg25);\n\n    s->sample_rate_index = sample_rate_index;\n\n    s->error_protection = ((header >> 16) & 1) ^ 1;\n\n\n\n    bitrate_index = (header >> 12) & 0xf;\n\n    padding = (header >> 9) & 1;\n\n    //extension = (header >> 8) & 1;\n\n    s->mode = (header >> 6) & 3;\n\n    s->mode_ext = (header >> 4) & 3;\n\n    //copyright = (header >> 3) & 1;\n\n    //original = (header >> 2) & 1;\n\n    //emphasis = header & 3;\n\n\n\n    if (s->mode == MPA_MONO)\n\n        s->nb_channels = 1;\n\n    else\n\n        s->nb_channels = 2;\n\n    \n\n    if (bitrate_index != 0) {\n\n        frame_size = mpa_bitrate_tab[s->lsf][s->layer - 1][bitrate_index];\n\n        s->bit_rate = frame_size * 1000;\n\n        switch(s->layer) {\n\n        case 1:\n\n            frame_size = (frame_size * 12000) / sample_rate;\n\n            frame_size = (frame_size + padding) * 4;\n\n            break;\n\n        case 2:\n\n            frame_size = (frame_size * 144000) / sample_rate;\n\n            frame_size += padding;\n\n            break;\n\n        default:\n\n        case 3:\n\n            frame_size = (frame_size * 144000) / (sample_rate << s->lsf);\n\n            frame_size += padding;\n\n            break;\n\n        }\n\n        s->frame_size = frame_size;\n\n    } else {\n\n        /* if no frame size computed, signal it */\n\n        if (!s->free_format_frame_size)\n\n            return 1;\n\n        /* free format: compute bitrate and real frame size from the\n\n           frame size we extracted by reading the bitstream */\n\n        s->frame_size = s->free_format_frame_size;\n\n        switch(s->layer) {\n\n        case 1:\n\n            s->frame_size += padding  * 4;\n\n            s->bit_rate = (s->frame_size * sample_rate) / 48000;\n\n            break;\n\n        case 2:\n\n            s->frame_size += padding;\n\n            s->bit_rate = (s->frame_size * sample_rate) / 144000;\n\n            break;\n\n        default:\n\n        case 3:\n\n            s->frame_size += padding;\n\n            s->bit_rate = (s->frame_size * (sample_rate << s->lsf)) / 144000;\n\n            break;\n\n        }\n\n    }\n\n    s->sample_rate = sample_rate;\n\n    \n\n#if defined(DEBUG)\n\n    printf(\"layer%d, %d Hz, %d kbits/s, \",\n\n           s->layer, s->sample_rate, s->bit_rate);\n\n    if (s->nb_channels == 2) {\n\n        if (s->layer == 3) {\n\n            if (s->mode_ext & MODE_EXT_MS_STEREO)\n\n                printf(\"ms-\");\n\n            if (s->mode_ext & MODE_EXT_I_STEREO)\n\n                printf(\"i-\");\n\n        }\n\n        printf(\"stereo\");\n\n    } else {\n\n        printf(\"mono\");\n\n    }\n\n    printf(\"\\n\");\n\n#endif\n\n    return 0;\n\n}\n", "idx": 14459, "substitutes": {"s": ["ses", "browser", "gs", "S", "settings", "bs", "ports", "sl", "t", "m", "qs", "stats", "vs", "cs", "tests", "ims", "pers", "tes", "sg", "its", "ants", "https", "ps", "sw", "js", "g", "comm", "spec", "ds", "ats", "obj", "services", "ies", "uploads", "set", "rates", "conf", "ains", "parts", "ers", "a", "as", "less", "utils", "eps", "source", "als", "sb", "er", "hs", "sys", "c", "ops", "dev", "es", "changes", "fs", "bis", "sports", "ss", "comments", "status", "aws", "l", "p", "ms", "details", "is", "sv", "ls", "orders", "r", "ts", "ins", "ns", "h", "os", "sets", "sts", "w", "sc", "y", "rs"], "header": ["server", "wrapper", "peer", "shift", "version", "lr", "head", "data", "size", "hidden", "response", "p", "body", "window", "dr", "tr", "addr", "name", "v", "layer", "dt", "outer", "t", "frame", "len", "er", "msg", "cache", "title", "prot", "offset", "HEAD", "timer", "r", "part", "message", "json", "player", "headers", "magic", "info", "hawk", "hd", "buffer", "block", "attribute", "lp", "event", "drm", "code", "function", "former", "debug", "table", "vector", "Header", "h", "term", " HDR", "heading", "tar", "iter", "hash", "list", "format", "token", "hh", "filter", "x", "ter", "history", "form"], "sample_rate": ["sample_area", "ample_score", "sample_count", " sample_rated", "sampleacarea", " sample_score", "frame_rate", "sampleacrate", "sample00rate", "sample2size", "frame_state", "sample00zip", "ample_count", "sample_size", "sampleplrate", "sample_zip", "sample_state", "sampleaczip", "sample67count", "ample_rate", "sample_rated", " sample_rates", " sample_rating", "sample_system", "sampleplsize", " sample_zip", "sample67score", " sample_size", "sample67rate", "sample_rates", "sample7rates", " sample_system", "frame_rates", " sample_area", "sample7rate", "sample00area", "sample7state", "sample2rate", "sampleplsystem", "sample2rating", "sample_rating", "sampleacrates", "sample00rates", "sample_score", "sample67rated"], "frame_size": ["frame_system", "frames_size", "frame_vector", "draw8Size", "frameetstrength", "framelexstrength", "frame67size", " frame_unit", "frames_address", "draw_size", "profile_store", "responselysize", "profileetstyle", "framelysystem", "profile_style", "frame67scale", "frameetstyle", "flow_scope", "framexcapacity", "frameSetoffset", "response_name", "framelexSize", "responselystart", "frameSetlength", "line_style", "profileetsize", "responselyname", "profile_size", "framelexstyle", "frame_name", "profile_strength", "scenetloss", "frame67scope", "flow_message", "flow_size", "frame_storage", "scenetweight", "frame8capacity", "responselysystem", "sample_scale", "frameetsize", " frame_count", "framelexvector", "draw8size", "frame_description", "frames_offset", "framettree", "draw_Size", "line_size", "frame_store", "line_vector", "fieldetname", " frame_storage", "frame8vector", "draw_vector", "term_size", "frame9size", "frameListname", "frame67style", "framexstorage", "scene_weight", "sample_start", "term_capacity", "fieldetoffset", "frame_speed", "sample_size", "scene_sum", "frame_location", "frametsum", "frameListstart", "frame_strength", "sample_name", "frame67store", "frame_address", "frame9weight", " frame_member", "frame2message", "frame_member", "fieldetsize", "frame2size", "framelexloss", "draw_capacity", "Frame_scale", "line_offset", " frame_length", "frame67message", "response_system", "response_size", "frame_sum", "frametunit", "framelysize", "frametloss", " frame_description", "frame_message", "frame_Size", "term_strength", "profileetstore", "framelyname", "frame67strength", "term_location", "Frame_size", "response_start", "fieldetstorage", "scene_loss", "frame_unit", " frame_tree", "framelexcapacity", "frame2scale", "frame_start", "frames_length", "framelexweight", "frame8size", "field_size", "field_name", "framexlocation", "framexsize", "frameetstorage", "field_offset", "frametsize", "frame_style", "profileetstrength", "scene_size", "framexstrength", "framelexcount", "field_storage", "frame_loss", "frameSetsize", "Frame_Size", "frameetvector", "framelexsum", "frameetname", "frame_offset", " frame_scale", "frame9loss", "frame_weight", "scenetsum", "draw8vector", "framelexstore", "flow_scale", "frametweight", "sample_store", "draw8capacity", "frame_scope", "frame_tree", "scenetsize", "frame_capacity", "frame_length", "frameListscale", "framelexmember", "frameListsize", "frame_scale", "frame8Size", " frame_speed", "frame9sum", "frameetstore", "frame2scope", "sample_weight", "framexspeed", "frame_count", "framelystart", "frameSetaddress", "framelexsize", "frameetoffset"], "mpeg25": [" microphone75", "mobi25", "cow24", "cam125", "mpeg625", "mobi26", "mpeg15", "peg125", "cam24", "ammy75", "media25", "cow75", "mpeg24", "media26", "mobi75", "mpeg75", "peg25", "cam75", "peg625", " microphone625", "peg5", "peg24", "cow5", "mpeg5", "media75", "ammy26", " microphone25", "mpeg26", "ammy25", "cam5", "cow25", "peg75", "ammy15", "mobi15", "cam625", "peg20", "mpeg125", " microphone125", "mobi20", "mpeg20", "peg26", "media5", "cam26", "cam25", "ammy20", "peg15"], "padding": ["frequency", "type", "version", "border", "shift", "position", "translation", "size", "pi", "pressure", "data", "mask", "p", "depth", "radius", "timeout", "address", "pixel", "height", "processing", "unit", "ping", "added", "policy", "delay", "offset", "zone", "context", "adding", "packing", "prefix", "margin", "resolution", "activation", "magic", "protection", "ppa", "buffer", "empty", "password", "wp", "volume", "scale", "pc", "trace", "pad", "length", "shape", "above", "pa", "pointer"], "sample_rate_index": ["sample_time_strength", "sample_rate_id", "sample_time_Index", "sample_rate_position", "sample_rates_Index", "sample_rate__offset", "sample_time_key", "sample_rate__index", "sample_rate_offset", "sample_rates_id", "sample_rate__id", "sample_time_index", "sample_stream_Index", "sample_rate_Index", "sample_stream_position", "sample_rate__Index", "sample_rates_offset", "sample_stream_offset", "sample_stream_index", "sample_rates_index", "sample_rate_i", "sample_rate_key", "sample_time_id", "sample_rate_strength", "sample_rates_i"], "bitrate_index": ["bitrate2ind", "bitrace_pos", "bittime2index", "bitRate_Index", "bitrace_Index", "bitrate_ind", "bittime_ind", "bitrate2index", "bitrate_Index", "bitRate_index", "bittime2id", "bittime2ind", "bittime_offset", "bitrate___pos", "bitrate_offset", "bitrace_ind", "bitRate_id", "bittime_index", "bitrate2id", "bittime2offset", "bitrace_index", "bitrate___Index", "bitrate_pos", "bitrate_id", "bitrate___ind", "bitrate2offset", "bitrate___index", "bittime_id"]}}
{"project": "FFmpeg", "commit_id": "2d66fc543b01995d6146fc132a778d3e722ca665", "target": 1, "func": "static av_cold int init(AVFilterContext *ctx, const char *args)\n\n{\n\n    GradFunContext *gf = ctx->priv;\n\n    float thresh = 1.2;\n\n    int radius = 16;\n\n\n\n    if (args)\n\n        sscanf(args, \"%f:%d\", &thresh, &radius);\n\n\n\n    thresh = av_clipf(thresh, 0.51, 255);\n\n    gf->thresh = (1 << 15) / thresh;\n\n    gf->radius = av_clip((radius + 1) & ~1, 4, 32);\n\n\n\n    gf->blur_line = ff_gradfun_blur_line_c;\n\n    gf->filter_line = ff_gradfun_filter_line_c;\n\n\n\n    if (ARCH_X86)\n\n        ff_gradfun_init_x86(gf);\n\n\n\n    av_log(ctx, AV_LOG_VERBOSE, \"threshold:%.2f radius:%d\\n\", thresh, gf->radius);\n\n\n\n    return 0;\n\n}\n", "idx": 14469, "substitutes": {"ctx": ["tx", "jp", "ij", "resp", "kw", "ctl", "cu", "cf", "tc", "conn", "cm", "wx", "setup", "cmd", "hw", "kg", "kt", "cmp", "cc", "kk", "mk", "cas", "bh", "conv", "req", "ia", "wcs", "dc", "sys", "np", "ct", "act", "context", "obj", "sc", "ac", "ck", " cx", "txt", "cv", "xc", "cb", "nc", "abc", "cp", "gc", "mc", "bc", "Context", "fc", "pkg", "ca", "anc", "jac"], "args": ["aws", "gs", "ids", "values", "cmd", "flags", "p", "properties", "facts", "params", "keys", "ags", "names", "rows", "xs", "limits", "fields", "words", "arms", "points", "checks", "ats", "orders", "s", "atts", "qs", "range", "ts", "caps", "vs", "ins", "ns", "cs", "Args", "ims", "members", "any", "amps", "fs", "arg", "GS", "posts", "parts", "objects", "files", "friends", "w", "weights", "users", "actions", "terms", "rs", "arr"], "gf": ["gcf", "ggf", "Gf", " gif", "gamepy", "gamefo", "ggal", "gly", "gpf", " gfo", "gual", "ggfs", "gcw", "gainfr", "ergf", "Gw", "bgfor", "gif", "sgfer", "gpv", " gfer", "gametf", "gfer", "gfs", "gfm", "bgf", "gpfac", "ergtf", "ogf", "ggwt", "sgfo", "gfr", "gcv", "ggfac", "groupfor", "gmfac", "ogfor", "gmf", "ggfr", "ggfor", "Gfm", "gcfm", " gpy", " gfr", "ogif", "gpwt", "gv", " gt", "ggfm", "gmv", "sgw", "ergpy", "guly", "gal", "gpy", " gfor", "ergfo", "gfo", "gainfm", "ggly", "gfac", "gt", "gamef", "gw", "Gv", "gufor", "gmwt", "grouply", "gainfs", " gv", "rgf", "gwt", "sgf", " gw", "ggv", " gtf", "gfor", "bgif", "rgfer", "gainf", "groupal", "guf", "groupf", "rgfo", " gfs", "gtf", " gfm", "rgw", "ogt", "bgt"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,\n\n\t\t\t\t    int enable)\n\n{\n\n\treturn kvm_set_migration_log(enable);\n\n}\n", "idx": 14476, "substitutes": {"client": ["node", "server", "key", "type", "product", "manager", "conn", "core", "window", "resource", "cli", "project", "service", "cache", "cl", "connection", "cell", "channel", "c", "Client", "file", "grid", "master", "pc", "config", "net", "name"], "enable": ["status", "allow", "activate", "apply", "pen", "begin", " Enable", "online", "enabled", "stop", "write", "end", "show", "forward", "update", "hide", "replace", "Enable", "open", "en", "disable", "english", "animate", "require", "append", "execute", "on", "sche", "debug", "start", "define", "active", "incre", "force", "complete"]}}
{"project": "FFmpeg", "commit_id": "fc8fa007fb6099643a1f742a162e5e5eda760fd6", "target": 0, "func": "static int64_t rtmp_read_seek(URLContext *s, int stream_index,\n\n                              int64_t timestamp, int flags)\n\n{\n\n    RTMP *r = s->priv_data;\n\n\n\n    if (flags & AVSEEK_FLAG_BYTE)\n\n        return AVERROR(ENOSYS);\n\n\n\n    /* seeks are in milliseconds */\n\n    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);\n\n    if (!RTMP_SendSeek(r, timestamp))\n\n        return -1;\n\n    return timestamp;\n\n}\n", "idx": 14499, "substitutes": {"s": ["aws", "gs", "a", "S", "as", "n", "p", "js", "sq", "v", "t", "comm", "is", "sb", "sv", "ds", "ls", "m", "sc", "ssl", "ts", "c", "b", "ns", "cs", "h", "es", "e", "fs", "os", "sn", "i", "sts", "ms", "https", "ss", "rs"], "stream_index": ["streamidnumber", "Stream_Index", "Streamidindex", "stream_number", "Stream_number", "streamidIndex", "Streamidnumber", "streamidind", "stream_Index", "Stream_index", "Stream_ind", "streamidindex", "StreamidIndex", "Streamidind", "stream_ind"], "timestamp": ["Timence", "Timetime", "stimeline", "tmporal", "timest", "checkestamp", " timtime", "impoint", "timence", "mintetime", " timeday", "tememark", "stimeless", "cumeless", "timeestamp", "timtime", "Timpoint", "Timtime", "tmestamp", "timeetime", "minttime", "Timeday", " timest", "stimporal", "temest", "tmeline", "timeest", "temence", "mintest", "timeeday", "checkpoint", "imest", "Timestamp", "imestamp", "timeemark", "timpoint", "cumeline", "timeday", "timporal", "checketime", "imetime", "Timemark", "timetime", "checkest", "temestamp", "cumestamp", "mintestamp", "cumporal", "stimestamp", "Timest", "timeline", "timeless", "tmeless", "timeence", "timemark"], "flags": ["comments", "status", "settings", "FLAG", "tags", "terms", "mask", "values", "ids", "bits", "ags", "fields", "words", "pages", "details", "features", "uses", "reports", "times", "heads", "aps", "lag", "atts", "grades", "ts", "Flags", "states", "flag", "args", "links", "events", "locks", "posts", "parts", "options", "ants", " Flags", "fps", "sets", "ms", "properties", "allows"], "r": ["rc", "rw", "hr", "l", "p", "mr", "vr", "or", "v", "g", "rar", "ar", "t", "er", "rb", "br", "m", "kr", "rect", "rt", "c", "ro", "sr", "res", "rg", "h", "re", "e", "rd", "d", "q", "rx", "w", "R", "rr", "rs"]}}
{"project": "FFmpeg", "commit_id": "6df1cfa7e4d488051d7b5033c0c69df970db9f82", "target": 0, "func": "static av_cold int mace_decode_init(AVCodecContext * avctx)\n\n{\n\n    MACEContext *ctx = avctx->priv_data;\n\n\n\n    if (avctx->channels > 2)\n\n        return -1;\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n\n\n    avcodec_get_frame_defaults(&ctx->frame);\n\n    avctx->coded_frame = &ctx->frame;\n\n\n\n    return 0;\n\n}\n", "idx": 14508, "substitutes": {"avctx": ["avtx", "iverctx", "avectl", "avcmp", " avpkg", "avctl", "avloc", "airtx", "vrctx", "wavctl", " avtimeout", "avcontext", "airctx", "avercontext", "avepkg", "afcontext", "aveconf", "aircp", "cvcontext", "airtimeout", "vrcmp", "avpkg", "averconf", "avtimeout", "vrtx", " avtx", "airkt", "avcp", "aftx", "ivercontext", "cvcmp", "afctx", "averctx", "avectx", "avetx", " avcp", "averkt", "avconf", "averctl", "wavconf", " avcmp", "avetimeout", " avkt", "iverloc", "avkt", "avertx", "iverkt", "airpkg", " avcontext", "afkt", "aircontext", "avekt", "afloc", "afcp", "averloc", "wavtx", "wavctx", "cvctx", "cvtx", "vrcontext"], "ctx": ["tx", "jp", "kw", "ctl", "cf", "tc", "cmd", "hw", "crit", "kt", "cmp", "timeout", "cc", "tk", "xs", "pt", "loc", "xp", "wcs", "np", "ct", "nt", "act", "cfg", "desc", "context", "kb", "obj", "ac", "ck", "cb", "cv", "xc", "nc", "tz", "cp", "ctrl", "gc", "fc", "qt", "px", "pkg", "txt", "jac"]}}
{"project": "qemu", "commit_id": "1bf6beec8a012cae4bb6fbc89c465127e9650c92", "target": 1, "func": "float16 float32_to_float16(float32 a, flag ieee STATUS_PARAM)\n\n{\n\n    flag aSign;\n\n    int_fast16_t aExp;\n\n    uint32_t aSig;\n\n    uint32_t mask;\n\n    uint32_t increment;\n\n    int8 roundingMode;\n\n    a = float32_squash_input_denormal(a STATUS_VAR);\n\n\n\n    aSig = extractFloat32Frac( a );\n\n    aExp = extractFloat32Exp( a );\n\n    aSign = extractFloat32Sign( a );\n\n    if ( aExp == 0xFF ) {\n\n        if (aSig) {\n\n            /* Input is a NaN */\n\n            float16 r = commonNaNToFloat16( float32ToCommonNaN( a STATUS_VAR ) STATUS_VAR );\n\n            if (!ieee) {\n\n                return packFloat16(aSign, 0, 0);\n\n            }\n\n            return r;\n\n        }\n\n        /* Infinity */\n\n        if (!ieee) {\n\n            float_raise(float_flag_invalid STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0x3ff);\n\n        }\n\n        return packFloat16(aSign, 0x1f, 0);\n\n    }\n\n    if (aExp == 0 && aSig == 0) {\n\n        return packFloat16(aSign, 0, 0);\n\n    }\n\n    /* Decimal point between bits 22 and 23.  */\n\n    aSig |= 0x00800000;\n\n    aExp -= 0x7f;\n\n    if (aExp < -14) {\n\n        mask = 0x00ffffff;\n\n        if (aExp >= -24) {\n\n            mask >>= 25 + aExp;\n\n        }\n\n    } else {\n\n        mask = 0x00001fff;\n\n    }\n\n    if (aSig & mask) {\n\n        float_raise( float_flag_underflow STATUS_VAR );\n\n        roundingMode = STATUS(float_rounding_mode);\n\n        switch (roundingMode) {\n\n        case float_round_nearest_even:\n\n            increment = (mask + 1) >> 1;\n\n            if ((aSig & mask) == increment) {\n\n                increment = aSig & (increment << 1);\n\n            }\n\n            break;\n\n        case float_round_up:\n\n            increment = aSign ? 0 : mask;\n\n            break;\n\n        case float_round_down:\n\n            increment = aSign ? mask : 0;\n\n            break;\n\n        default: /* round_to_zero */\n\n            increment = 0;\n\n            break;\n\n        }\n\n        aSig += increment;\n\n        if (aSig >= 0x01000000) {\n\n            aSig >>= 1;\n\n            aExp++;\n\n        }\n\n    } else if (aExp < -14\n\n          && STATUS(float_detect_tininess) == float_tininess_before_rounding) {\n\n        float_raise( float_flag_underflow STATUS_VAR);\n\n    }\n\n\n\n    if (ieee) {\n\n        if (aExp > 15) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0);\n\n        }\n\n    } else {\n\n        if (aExp > 16) {\n\n            float_raise(float_flag_invalid | float_flag_inexact STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0x3ff);\n\n        }\n\n    }\n\n    if (aExp < -24) {\n\n        return packFloat16(aSign, 0, 0);\n\n    }\n\n    if (aExp < -14) {\n\n        aSig >>= -14 - aExp;\n\n        aExp = -14;\n\n    }\n\n    return packFloat16(aSign, aExp + 14, aSig >> 13);\n\n}\n", "idx": 14521, "substitutes": {"a": ["ae", "am", "at", "aa", "as", "f", "o", "au", "go", "out", "sta", "aw", "aaa", "p", "n", "window", "A", "v", "ga", "g", "ar", "t", "ia", "angular", "ed", "ea", "ab", "act", "da", "m", "sa", "att", "s", "era", "oa", "ac", "ao", "c", "all", "ap", "b", "alpha", "h", "area", "e", "eas", "u", "app", "d", "ata", "ma", "z", "ast", "ta", "i", "w", "x", "ca", "y", "an", "na"], "STATUS_PARAM": ["STATUS_NAR", "STATUS_PARAMS", "STATUS_PAR", "STATUS_PAMS", "STATUS_VUM", "STATUS_VAR", "STATUS_NAMS", "STATUS_PARAR", "STATUS_VAM", "STATUS_VAMS", "STATUS_PUM", "STATUS_PARUM", "STATUS_NAM", "STATUS_PAM", "STATUS_NUM"], "aSign": ["anaNeg", "eSign", "asRand", "aePort", "anSeg", "aeNeg", "aaSign", "aasign", "iSign", "oDig", "aSIGN", "oReg", " aRand", " aReg", "isaSign", "aLog", "aRand", "asReg", "eScale", " aNeg", "anaSign", "anReg", "asSIGN", "ePos", "anSIGN", "anSign", "oSIGN", "aeSIGN", "asSeg", "aDig", "iSIGN", "aaReg", "isaPort", "aScale", "aShape", "aaDig", "aaExp", "asSign", "aaScale", "asign", "aaRand", "uSign", "anaRand", "isaNeg", "aPort", "anDig", "uLog", "aSeg", "uSIGN", "anShape", "anaPos", "isaSIGN", "iLog", "aPos", " aSIGN", "aNeg", " aPos", "asShape", "anLog", "uSeg", "asLog", " aPort", "asPos", " aScale", "iShape", "oSign", "aReg", "aaSIGN", "aaNeg", "aaPos", "assign", "eExp", " asign", "aeSign"], "aExp": ["nameExt", "saComp", "alphaSec", "aaExpress", "dataEx", "aaExt", "asExpress", "asEnc", "appExpress", "asExp", "aaSign", "aExec", "dataRest", "aRest", " aExt", "asExt", " aRest", "aExt", " aGe", "nameEx", "dataEXP", " aSec", " aEXP", " aExpress", "vaExp", "aaEx", "dataExp", "appExp", " aEnc", "saSp", "saExp", "alphaExp", "asExec", "aSp", "saPos", "nameExpress", "aaExp", "asGe", " aEx", "anEnc", "nameExp", "oaEXP", "alphaEx", "asComp", "alphaExpress", "aaComp", "appComp", "anExec", "vaExt", "aaExec", "aEx", "saExec", "aPos", "saSign", "aGe", " aComp", "vaExpress", " aPos", "oaExp", "oaEx", "appGe", "aEnc", "aaSec", "aExpress", "aSec", "aaSp", "aComp", " aExec", "aaPos", "anExp", "vaExec", "oaRest", "aEXP", "anComp", " aSp"], "aSig": ["aTig", "aSIG", "aVsign", "aIssign", " aSIG", "aSignigma", "aVsIG", "aIsigned", "aInsigma", "aaSIG", "aaDim", "aSignigh", "aAsigma", "aSeigh", "aVsature", "aPeg", "caSIG", "amSig", "aAsag", "AAsIG", " aInsigs", "aSetigh", "AAsigma", "AAsig", "aSnigma", "amVsiet", "aSignature", "aPig", " aInseg", "aSeIG", "aRseg", "aaSig", "aAsigh", "aSetigma", " aInsIG", "aPosag", "aDim", "aVsiet", "aPosig", "aPosigs", "saIsig", "caSign", "aAsigs", "saRsig", "aSnig", "aDIG", "aDsigs", "aSetIG", "aInsig", "aInseg", "aAsig", "caSature", "ASig", "amVsig", "aTIG", " aSignature", "aPosIG", "ASIG", " aSignIG", "aAsIG", "aSnite", "aRsite", "aDseg", "saSigma", "ASigh", "saSite", " aSignigh", "saIseg", "aSignig", "aTature", "aDig", " aSeg", "aRsigma", " aSag", "amVsigma", "aAsature", "aVsigma", "caAsign", "aaDig", "aSeigs", "caAsature", "saRsigma", "aDsig", "amSiet", "saIsigned", "aDigs", "aPIG", "aIssature", "aIseg", "amVseg", "aaDIG", "aaSigs", "saIsigs", "ASigma", "aSim", "aIssIG", "aSneg", "aSigh", "aSeg", "aSature", "saSigs", "saSig", "aaDigs", "saSeg", "aSeature", "aIsig", "aSigs", "caSig", "aSigma", " aSature", "saRseg", "aIssig", "aIsigs", " aSigh", "aSite", "aTigh", "aRsig", " aSigs", "AAsigh", "caAsig", "aInsigned", "aSignIG", "aInsiet", "caAsIG", " aInsig", "aSeite", "amSeg", "aSeeg", "aSetiet", "aSag", "aSiet", "aSeigma", "aAsign", "aInsIG", "aSeteg", "aAsim", "aVseg", "aSeim", "aaSim", "aSetig", "aInsigs", "aSigned", "aPigs", "aVsig", "aSeig", "saSigned", " aSignig", "amSigma", "aDsigned", "saRsite"], "mask": ["bit", "key", "error", "allow", "shift", "cm", "bug", "bool", "size", "map", "flags", "window", "miss", "bits", "where", "pack", "mk", "perm", "hold", "batch", "box", "known", "cache", "result", "skip", "offset", "scan", "cover", "m", "lock", "tag", "sk", "gate", "hide", "ask", "mark", "Mask", "match", "comment", "black", "use", "magic", "margin", "empty", "block", "count", "mut", "limit", " masked", "flag", "scale", "master", "set", "clear", "mod", "hash", "weight", "shape", "mb", "MAS", "ma", "filter", "zero", "sign", "level", "ms", "mx", "fix", "sum", "keep"], "increment": ["Incremented", "schementation", " decreement", "Increma", "increcomment", "vancese", "improveension", "incremental", "increma", "enableence", "remented", "incmental", "incrementation", "adjustmission", "Incrementation", "adjustmentation", "improvementation", "increence", "improvement", "Decremental", "improveition", "adjustement", "schemission", "reence", "incement", "adjustMENT", " decrecomment", "improveence", "increMENT", " decreMENT", "schement", "incment", "reement", "improvema", " decremission", "Incremental", "rese", "vanceement", "incremented", "incremission", "increition", " incrementation", "schemental", "increse", "gremented", "Decremission", "schemented", "enablemented", "adjustmented", "enablementation", "Decrement", "adjustment", "itermental", " incrementment", "improvemission", " incrementmission", "grese", "rementation", "increement", " incrementcomment", " incrementmented", "Increment", "adjustension", "Decremented", "greement", " decrement", " incremented", "improveement", "rement", "increension", "itermentation", "improvemented", "adjustition", "incma", "incmented", " decreension", "itermented", "improveMENT", "iterment", "grement", "adjustcomment", " decremented", " increition", "vancemented", "improvemental", "vancement", "enablement"], "roundingMode": ["roundifyingMode", "rounduningMODE", "roundbingMode", "turnINGmode", "roundINGMethod", "roundoundingmode", "rollingMode", "rounduningTheme", "rolluningMODE", "roundingMODE", "roundingEngine", "turnINGMethod", "turningMethod", "roundgingTheme", "roundoundingStatus", "roundningMode", "roundbingMODE", "callningMODE", "roundingMethod", "roundtingMode", "roundgingModule", "roundbingEngine", "callningEngine", "roundifyingEngine", "roundningMODE", "roundifyingMODE", "roundoundingMode", "roundINGStatus", "roundtingmode", "rolluningMode", "roundingmode", "rolluningModule", "callningMode", "turningStatus", "rollingMODE", "roundgingMODE", "callingEngine", "rollingTheme", "roundbingModule", "roundINGMode", "roundoundingMethod", "roundtingMethod", "roundINGmode", "turningmode", "roundbingTheme", "roundingModule", "callingMode", "turningMode", "callingMODE", "turnINGStatus", "roundtingStatus", "roundningEngine", "rounduningMode", "turnINGMode", "roundgingMode", "rounduningModule", "rollingModule", "roundingStatus", "rolluningTheme", "roundingTheme"]}}
{"project": "qemu", "commit_id": "0d8d7690850eb0cf2b2b60933cf47669a6b6f18f", "target": 0, "func": "int virtqueue_avail_bytes(VirtQueue *vq, int in_bytes, int out_bytes)\n\n{\n\n    unsigned int idx;\n\n    unsigned int total_bufs, in_total, out_total;\n\n\n\n    idx = vq->last_avail_idx;\n\n\n\n    total_bufs = in_total = out_total = 0;\n\n    while (virtqueue_num_heads(vq, idx)) {\n\n        unsigned int max, num_bufs, indirect = 0;\n\n        target_phys_addr_t desc_pa;\n\n        int i;\n\n\n\n        max = vq->vring.num;\n\n        num_bufs = total_bufs;\n\n        i = virtqueue_get_head(vq, idx++);\n\n        desc_pa = vq->vring.desc;\n\n\n\n        if (vring_desc_flags(desc_pa, i) & VRING_DESC_F_INDIRECT) {\n\n            if (vring_desc_len(desc_pa, i) % sizeof(VRingDesc)) {\n\n                error_report(\"Invalid size for indirect buffer table\");\n\n                exit(1);\n\n            }\n\n\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (num_bufs >= max) {\n\n                error_report(\"Looped descriptor\");\n\n                exit(1);\n\n            }\n\n\n\n            /* loop over the indirect descriptor table */\n\n            indirect = 1;\n\n            max = vring_desc_len(desc_pa, i) / sizeof(VRingDesc);\n\n            num_bufs = i = 0;\n\n            desc_pa = vring_desc_addr(desc_pa, i);\n\n        }\n\n\n\n        do {\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (++num_bufs > max) {\n\n                error_report(\"Looped descriptor\");\n\n                exit(1);\n\n            }\n\n\n\n            if (vring_desc_flags(desc_pa, i) & VRING_DESC_F_WRITE) {\n\n                if (in_bytes > 0 &&\n\n                    (in_total += vring_desc_len(desc_pa, i)) >= in_bytes)\n\n                    return 1;\n\n            } else {\n\n                if (out_bytes > 0 &&\n\n                    (out_total += vring_desc_len(desc_pa, i)) >= out_bytes)\n\n                    return 1;\n\n            }\n\n        } while ((i = virtqueue_next_desc(desc_pa, i, max)) != max);\n\n\n\n        if (!indirect)\n\n            total_bufs = num_bufs;\n\n        else\n\n            total_bufs++;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14531, "substitutes": {"vq": ["uvq", "evqs", "vqs", "vplay", "svque", "vdq", "uvque", "verz", " vqs", " vdq", "vQ", "uviq", "verqq", " vque", "evq", "verq", "evqueue", "vqt", "tvqu", "Vque", "VQ", "tvdq", " vqt", "naq", "vcq", "Vqs", "vaq", "vcplay", "vqueue", " vqueue", "vz", "nqu", "evque", "volqu", "vcque", "fqq", "Vqt", "vqu", "nque", " vQ", "evqu", "nq", "volq", "svqt", "Vq", "fque", "volque", "vque", "evdq", "verque", "tvaq", "svq", "tvq", " vqu", "svQ", " viq", "uvplay", "fz", "fq", " vz", "Vqueue", "viq", "vqq", "vciq", "volaq", " vqq", " vplay", "tvque"], "in_bytes": ["inuffyuses", "inuffyterms", "in68parts", "cin_parts", "inmmuses", "in67total", "in_parts", "inftysets", "in_terms", "in_devices", "in_allows", "inBsets", "ini_bytes", "rin_sets", "ini_uses", "in68sets", "in67uses", "cin67boxes", "in8bytes", "in_boxes", "in68boxes", "in8total", "rin_bytes", "rinftyallows", "in68fits", "in_uses", "inuffydevices", "cin67parts", "cin_boxes", "rinftybytes", "inftyfits", "cin_total", "inuffybytes", "ini_terms", "inBbytes", "in68total", "inBfits", "in8parts", "inmmdevices", "in67bytes", "in_fits", "rinftyfits", "in67terms", "rin_allows", "inftyallows", "rinftysets", "rin_fits", "ini_devices", "cin_bytes", "in_sets", "inftybytes", "in67parts", "ini67bytes", "in8boxes", "inmmbytes", "in67boxes", "inBallows", "in68allows", "cin67bytes", "inmmterms", "in67devices", "ini67terms", "ini67uses", "ini67devices", "in68bytes", "cin67total"], "out_bytes": ["out2total", "outmmbytes", "outmmnames", "total67bytes", "in_pointers", "total67maps", "out67tes", "out0bytes", "out0total", "out_names", "out_pointers", "total_total", "out67maps", "out_tes", "in_seconds", "total_bytes", "outmmnets", "out2tes", "out_nets", "total_tes", "out0tes", "out2maps", "out67bytes", "in_names", "total67total", "out67total", "out2bytes", "total67tes", "out0maps", "out_maps", "in_errors", "out_seconds", "in_nets", "total_maps", "out_errors"], "idx": ["pidex", "IDx", " idz", "Idz", "mdxs", "mdx", "midix", " idX", "pidz", "indix", "midxs", " idn", "indy", " idy", "idz", "idxi", "mdix", "midxi", " idxs", "Idxs", "pidx", "mdxi", " idex", "idxs", "indx", "IDix", " idix", "midx", " idxi", "Idex", "IDX", "pidxs", "Idn", "idy", "Idx", "Idix", "indn", "Idy", "idix", "idn", "IdX", "idex", "idX"], "total_bufs": ["total_buffals", "total_logts", "total2bufts", "total2buffers", "total_buffries", "total_ufcs", "total_ufd", "total_bufals", "total_bufries", "total_ufgs", "total_ufz", "total_buffs", "total_bufes", "total2buffcs", "total_logz", "total_brts", "total_brjs", "total_dirts", "total_ufers", "total_ufes", "total_brs", "total_buffers", "total_dirers", "total_loggs", "total_bufd", "total_ufs", "total2bufs", "total_bufers", "total_devts", "total_buffcs", "total2bufers", "total_bufgs", "total_buffjs", "total_bufferes", "total2buffts", "total_ufries", "total_cmdts", "total_cmds", "total_buffd", "total2buffs", "total_bufcs", "total_devries", "total_bufts", "total_cmdz", "total_ufts", "total_dircs", "total_ufjs", "total_buffts", "total_devd", "total_ufals", "total_dirs", "total_buffergs", "total_logs", "total_bufjs", "total_loges", "total_bufz", "total_devs", "total2bufcs", "total_brals"], "in_total": ["init_local", "in_info", "in5local", "internal_total", "internal_last", "init5parent", " in_no", "internal_stable", "inJtotal", "in5parent", "in5total", "init_total", "init_sofar", "in5sofar", "init_parent", "internal_not", "in_local", "init5local", "in_pages", "in_sofar", "init5total", "in_no", "init5sofar", "inJparent", "inJlocal", "in_not", "in_parent", " in_info", "in_last", " in_pages", "inJsofar", "in_stable"], "out_total": ["out2total", "ex_global", "out2available", "out_desc", " out_no", "dev_desc", "out2no", "out68total", "out_server", "outjserver", "out_max", "devjdesc", "dev_server", "out2max", "out1bytes", "outjtotal", "ex_reported", "out_no", "dev_required", "outjrequired", "devjtotal", "out1total", "out68bytes", "out1global", "ex_bytes", " out_max", "out1reported", "outjdesc", "ex_total", "out_global", " out_available", "out68global", "out_reported", "out_required", "devjserver", "out68reported", "devjrequired", "out_available", "dev_total"], "max": ["index", "orig", "window", "check", "t", "locked", "end", "m", "lock", "maximum", "parent", "limit", "start", "length", "ma", "tx", "co", "ax", "high", "n", "v", "box", "mad", "self", "null", "res", "scale", "root", "set", "conf", "total", "mb", "x", "ex", "full", "Max", "global", "head", "height", "ox", "now", "current", "c", "prime", "id", "hash", "to", "MAX", "med", " MAX", "size", "p", "min", "num", "act", "k", "r", "last", "exclusive", "range", "count", "base", "recent", "all", "checked", "h", "master", " Max", "mod", "final", "q", "w", "init", "ms", "mx"], "num_bufs": ["num_cmdgs", "num_rbts", "num_rbs", "num_bufits", "num_reqers", "num_cmdts", "num_bufers", "num_cvc", "num_ufts", "num_ufS", "num_bufes", "num_buffes", "num_reqs", "num_tells", "num_ufes", "num_tellts", "num_refts", "num_cmdS", "num_ufries", "num_bufS", "num_buffts", "num_ufc", "num_refds", "num_brc", "num_bufgs", "num_cvn", "num_ufn", "num_tellits", "num_cmdries", "num_ufgs", "num_buffgs", "num_brs", "num_buffds", "num_bufds", "num_cvs", "num_ufits", "num_ufs", "num_rbers", "num_cmdds", "num_cvS", "num_tellers", "num_reqts", "num_brries", "num_buffers", "num_buffS", "num_bufries", "num_brn", "num_reqc", "num_cmds", "num_bufts", "num_ufers", "num_cves", "num_buffs", "num_refs", "num_cvries", "num_buffits", "num_refries", "num_bufc", "num_bufn", "num_ufds", "num_rbc"], "desc_pa": ["desc_ppa", "descmmapa", "desc_pe", "desc_p", "asc_ppa", " desc_p", "desc5pa", "descPppa", "asc_apa", "mem_apa", "descmmpe", "asc_pa", "desc_la", "desc_pac", "desc0pe", "descPpa", "descJpe", "esc_ha", "desc5ppa", "descMemppa", " desc_PA", "descmmpa", "descJpa", "mem_pha", "desc_pn", "desc_sa", "descPp", "obj_ara", "desc3ara", " desc_pe", "desc3pan", "descPda", "descMempn", "desc_pas", "desc_ha", "mem3apa", "degmmapa", "desc5apa", "degmmpan", "desc0ppa", "desc2pa", "mem3pha", "desc5pac", "prop_par", "desc_par", "desc_apa", "obj_pet", "desc_cro", "desc0PA", "desc_pan", " desc_pan", " desc_pai", "descMemsa", "esc_pa", "desc3ppa", "degmmpa", "asc_pac", "desc_ja", "obj_la", "desc_pha", "desc___ppa", "desc2sa", "deg_pan", "prop_ja", "desc3pha", " desc_pn", "desc3apa", "obj_pa", " desc_ppa", "desc_ara", "desc___da", "descmmpan", "esc_cro", "descJapa", "descMempa", "prop_pas", " desc_sa", "deg_pa", "desc3pa", "mem_ara", "desc2ppa", "desc_PA", "deg_pe", "mem_pa", "desc___p", "esc_ppa", "prop_pa", "desc___pa", " desc_da", "deg_apa", "desc3pai", "descJpan", "desc_pet", "mem3pa", "desc_da", "desc0pa", "desc2pn", "mem3ara", "degmmpe", "desc_pai"], "i": ["ij", "index", "instance", "li", "status", "ni", "a", "f", "go", "iu", "oi", "mi", "ini", "ii", "I", "pi", "ind", "j", "ei", "p", "n", "x", "l", "si", "ir", "zi", "v", "cli", "bi", "io", "t", "is", "ia", "ui", "di", "in", "ai", "m", "k", "hi", "s", "ie", "xi", "qi", "info", "im", "c", "ci", "b", "start", "h", "id", "ims", "ti", "e", "iter", "u", "it", "gi", "err", "z", "q", "phi", "init", "y", "ic", "ix", "iat", "ip"]}}
{"project": "qemu", "commit_id": "bd5c51ee6c4f1c79cae5ad2516d711a27b4ea8ec", "target": 0, "func": "static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)\n\n{\n\n    CharDriverState *chr;\n\n    FDCharDriver *s;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(FDCharDriver));\n\n    s->fd_in = io_channel_from_fd(fd_in);\n\n    s->fd_out = io_channel_from_fd(fd_out);\n\n    fcntl(fd_out, F_SETFL, O_NONBLOCK);\n\n    s->chr = chr;\n\n    chr->opaque = s;\n\n    chr->chr_add_watch = fd_chr_add_watch;\n\n    chr->chr_write = fd_chr_write;\n\n    chr->chr_update_read_handler = fd_chr_update_read_handler;\n\n    chr->chr_close = fd_chr_close;\n\n\n\n    qemu_chr_be_generic_open(chr);\n\n\n\n    return chr;\n\n}\n", "idx": 14557, "substitutes": {"fd_in": ["dir_din", "or_inc", "FD_out", "fd_cin", "dir_ins", "dir_in", "dir_out", "or_in", "fdablecin", "fdablein", "fd_en", "orablein", "fd_inc", "fdableinc", "fd_conn", "orableinc", "FD_in", "or_cin", "fdableconn", "orableconn", "orablecin", "fd_ins", "or_conn", "FD_en", "fd_orig", "fd_din", "FD_orig"], "fd_out": ["fdockin", "disk_out", "fi_OUT", "fd_serv", "fd_new", "dir_write", "fdockout", "fd___ou", "fi_gen", "fd_write", "fd_o", "fd___out", "f0to", "fdockwrite", "f_to", "fdocknew", "dir_in", "fi_out", "f0serv", "fd___write", "fi_in", "dir_new", "disk_o", "fd0inner", "fd0serv", "f0out", "f_inner", "f_serv", "fd0out", "disk_write", "dir_out", "disk_ou", "fd_to", "fd___o", "f_out", "fd_inner", "f0inner", "fd_ou", "fd_gen", "fd_OUT", "fd0to"], "chr": ["chercr", "cht", "cherrb", "echrc", "cher", "chrc", "thrb", "cherer", " chrb", "achro", "Chr", " chbr", "thr", "CHbr", "cherrator", "chR", "cherr", " cht", "echr", "achru", "chrin", "chedr", "charru", "cheru", "acher", "chru", "achR", "chardr", "Cher", "checr", "chdr", "ichrb", "achcr", "achorer", "echro", "CHrar", "achrr", "cherru", "acht", "achar", "CHr", "chrb", "ichrar", "chnR", "chrar", "cherc", "chero", " chrc", "chrator", "cherin", "achrin", "chbr", "chebr", "chnr", "cherR", "Chrb", "ichr", "achr", "cherar", "charro", "thrar", "cherrid", "chrid", "ichrid", "chcr", "chnrin", "cherorer", "chear", "achbr", "cheR", "achrid", "achrb", "cherro", "chnrb", " chR", "cherb", "echar", "CHrb", "ichro", "achdr", "thbr", "charr", "Chorer", "chrr", "chet", " chrator", "ichbr", "chro", "cherator", "cherrr", " chro", "chorer"], "s": ["ses", "gs", "a", "S", "as", "bs", "socket", "less", "out", "ports", "o", "p", "js", "n", "si", "sq", "g", "sam", "is", "sv", "sb", "als", "sys", "hs", "ds", "ats", "ls", "in", "r", "services", "acs", "ssl", "ies", "gets", "qs", "ts", "self", "c", "so", "stats", "vs", "ins", "ns", "ops", "cs", "b", "es", "h", "set", "fs", "os", "bis", "its", "se", "ss", "sts", "ms", "https", "i", "rs", "ps"]}}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                             const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    G722Context *c = avctx->priv_data;\n\n    const int16_t *samples = (const int16_t *)frame->data[0];\n\n    int nb_samples, out_size, ret;\n\n\n\n    out_size = (frame->nb_samples + 1) / 2;\n\n    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))\n\n        return ret;\n\n\n\n    nb_samples = frame->nb_samples - (frame->nb_samples & 1);\n\n\n\n    if (avctx->trellis)\n\n        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);\n\n    else\n\n        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);\n\n\n\n    /* handle last frame with odd frame_size */\n\n    if (nb_samples < frame->nb_samples) {\n\n        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };\n\n        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);\n\n    }\n\n\n\n    if (frame->pts != AV_NOPTS_VALUE)\n\n        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);\n\n    *got_packet_ptr = 1;\n\n    return 0;\n\n}\n", "idx": 14566, "substitutes": {"avctx": ["avtx", " avpkg", "avercfg", "avcu", "apctx", " avconn", "avcontext", "averclient", "avercontext", " avtc", "avertc", "ajcontext", "afcontext", "avsys", "avesys", "avclient", "afjp", "apconn", "avpkg", "avcb", "apjp", "avecmd", "ajctx", " avtx", "avecontext", "aftx", "afcmd", "ajcu", "avecb", "ajpkg", "afctx", "averctx", "apcontext", "avectx", "aptx", "avetx", "afpkg", "avcmd", "avjp", "aversys", "avconn", "avetc", "ajjp", "apcmd", "afcu", "ajclient", " avcu", " avcontext", "avtc", "avejp", " avclient", "afsys", "afcfg", "avcfg", " avjp", "afconn", "aveconn", " avcb", "avercb", "avecfg", "averjp"], "avpkt": ["aupck", "aucpst", "avpkgnt", "avwpst", "wavcpkt", "avdkt", "avcpkt", "avpkgdat", "avpkg", "avcpst", "avpatkw", "avwpkt", "avpatck", "avopwt", "avepkt", "avcpet", "avwppt", "avepck", " avppt", "avpkgacket", "aucpkt", "avPett", "avdkg", "avopett", "avpatett", "avppdat", "comvkg", "avpett", "avwpkw", "avPet", "avcpett", "wavpet", "avoppt", "avPkt", "avpkgett", "avewpkw", "avwpwt", " avpwt", "wavpdat", "avpwt", "avwpett", "avdet", "comvkt", "avpkgpt", "avpkw", "wavpnt", "aupacket", "wavppnt", "avopkg", "avepkw", "avvet", "avppnt", "avwpck", "avvkg", "avopdat", "compkt", "avepett", "wavppdat", "avvett", "avewpett", " avopkt", "avnpett", "avopnt", "avopkw", "avopet", "avpkgkt", " avoppt", "avpacket", "avopkt", " avpett", "wavcpet", "avcpacket", "avnpkt", "avopacket", "avewpkt", "avewpck", "avopck", "aucpck", "avppacket", "avpck", "wavcpacket", "avcpck", "wavppacket", "wavpacket", "avpadkt", "comvett", "avpst", "avpnt", "avppt", "avnpacket", "wavpkt", "avpdat", "avwpacket", "avpadacket", "avpatkt", "avnpet", " avopett", "wavppkt", "compet", "comvet", "avpadst", "compkg", "avppkt", "aupst", "avpadck", "aupkt", "wavcpett", "wavpett", "avPacket", "compett", "avvkt", "avpet", "avpkgwt", " avopwt", "aucpacket", "avdett"], "frame": ["profile", "error", "face", "version", "framework", "f", "request", "header", "data", "response", "row", "sequence", "window", "call", "module", "movie", "feat", "chain", "load", "t", "close", "frames", "fe", "video", "feature", "note", "show", "command", "policy", "connection", "flow", "line", "zone", "message", "channel", "rame", "fb", "info", "block", "image", "file", "event", "one", "function", "code", "fram", "iframe", "fr", "fake", "Frame", "e", "scene", "point", "trace", "list", "length", "state", "component", "style", "me", "process", "force", "form"], "got_packet_ptr": ["got_packacket_pos", "got_packacket2ptr", "got_packet2pos", "got_packet2addr", "got_packet2ref", "got_packet_pos", "got_packacket2pointer", "got_packacket_ptr", "got_packet_ref", "got_packet8ptr", "got_packacket2pos", "got_packet_addr", "got_packet2pointer", "got_packacket_pointer", "got_packacket2addr", "got_packet_pointer", "got_packet8pointer", "got_packacket2ref", "got_packet2ptr", "got_packet8ref", "got_packacket_addr", "got_packet8addr", "got_packacket_ref"], "c": ["rc", "cu", "cf", "co", "f", "tc", "unc", "cm", "lc", "l", "ctx", "p", "cmp", "cc", "v", "chain", "g", "t", "cache", "dc", "com", "ct", "m", "r", "context", "ac", "C", "cb", "cv", "xc", "nc", "ec", "cp", "b", "mc", "cs", "bc", "h", "gc", "pc", "fc", "con", "conf", "ca", "cont"], "samples": [" stones", "stones", "passents", "Samples", "alsamps", "alsamples", "alsples", "Samps", "Sples", "pamples", "Stones", "hamps", "hples", "tances", "pamps", " sources", "passamples", " sples", "servicesamps", "servicesources", "sples", "tamples", "Sents", "hamples", "sents", " samps", "servicestones", "tents", "pents", "sources", " sents", "servicesamples", "pances", "passples", "alsents", "Sources", "passamps", "tamps", "sances", "hents", "Sances", "samps"], "nb_samples": ["nb_spamps", "nbLogsances", "nb_hamples", "nb_sources", "nb_Saves", "nb_vamps", "nb_alessions", "nb_sessions", "nb_sseeds", "nb_saces", "nb_alamps", "nb64sonents", "nb_commicks", "nb_psacks", "nb_Sicks", "nb_Sages", "nb_Sumbers", "nb_Sumps", "nb_snapamples", "nb_sappings", "nb_seamples", "nb_insicks", "nb_ssumps", "nb_tsents", "nb_hacks", "nb_Sacks", "nb_exources", "nb_mamples", "nb_xsappings", "nb_mages", "nb_insales", "nb_ssples", "nb_Sales", "nb_sages", "nb_vizes", "nbLoggesples", "nb_samps", "nb_Susters", "nb_namples", "nb_psamples", "nb_Samps", "nb_sizes", "nb_ssamples", "nbLoggesances", "nb_persays", "nb_Samples", "nb_sents", "nb_sicks", "nbLoggesamps", "nb_susters", "nb_tsumbers", "nb_saves", "nb_vamples", "nb_seaces", "nbLogsamps", "nb_gesamps", "nbLoggesamples", "nb64says", "nb_Sessions", "nb_Sents", "nb_seonents", "nb_vappings", "nb_sances", "nb_insources", "nb_persaces", "nb_xsamples", "nb_ssamps", "nb_sales", "nb_swamples", "nb_snapaces", "nb_mamps", "nb_personents", "nb_insamps", "nb_statples", "nb_commales", "nb_sacks", "nb_exents", "nb_spamples", "nb_swamps", "nb_Seeds", "nb_seays", "nb_commamples", "nb_tsamps", "nb_examples", "nb_sumbers", "nb64esays", "nb_snapages", "nb_insamples", "nb64saces", "nb_gesances", "nb_snapamps", "nb_xsamps", "nb_gesples", "nbLogsples", "nb64esamples", "nb_Saces", "nb_nents", "nb_Sources", "nb_insaves", "nb_sples", "nb_Sizes", "nb_exumbers", "nb_sonents", "nb_namps", "nb_esays", "nb_swaves", "nb_alples", "nb_speeds", "nb_ssessions", "nb_sumps", "nb_commamps", "nb64esonents", "nb_husters", "nb_statamples", "nb_Sples", "nb_says", "nb_tsamples", "nb_xsizes", "nb_hamps", "nb_psusters", "nb_gesamples", "nb_Sappings", "nb_esonents", "nb_persamples", "nb_nources", "nb_psamps", "nb_spumps", "nb_esaces", "nbLogsamples", "nb_naves", "nb_esamples", "nb_Sances", "nb_nales", "nb_swales", "nb_maces", "nb_statances", "nb_examps", "nb_alamples", "nb64esaces", "nb64samples", "nb_statamps", "nb_seeds"], "out_size": ["out_len", "out2size", "out2len", "outlenscore", " out_shift", "outlensize", " out_name", "out_SIZE", "out2SIZE", " out_Size", "outlenSIZE", "out2score", "out_Size", " out_len", " out_score", "out_shift", "out_name", "outlenlen", "out_score", " out_SIZE"], "ret": ["resp", "cor", "rem", "jp", "mem", "out", "ref", "success", "det", "ll", "fun", "back", "Ret", "rets", "RET", "reset", "val", "try", "t", "len", "result", "ext", "nt", "r", "nat", "gt", "alt", "aux", "rt", "res", "gc", "print", "cert", "re", "tmp", "mt", "rel", "over", "ft", "it", "elt", "value", "ter", "cont", "arr"], "last_samples": ["last_Samp", "last_Sents", "last_samp", "last_Siffs", "last_Sales", "last_bamples", "last_Samples", "last_siffs", "last_ssamps", "last_psiffs", "last_bents", "last_Samps", "last_bales", "last_diffs", "last_sales", "last_damples", "last_ssents", "last_samps", "last_damp", "last_bamps", "last_psamples", "last_sents", "last_ssales", "last_psamp", "last_psamps", "last_damps", "last_ssamples"]}}
{"project": "FFmpeg", "commit_id": "03d83ba34b2070878909eae18dfac0f519503777", "target": 0, "func": "static int gif_image_write_image(AVCodecContext *avctx,\n\n                                 uint8_t **bytestream, uint8_t *end,\n\n                                 const uint32_t *palette,\n\n                                 const uint8_t *buf, const int linesize,\n\n                                 AVPacket *pkt)\n\n{\n\n    GIFContext *s = avctx->priv_data;\n\n    int len = 0, height = avctx->height, width = avctx->width, x, y;\n\n    int x_start = 0, y_start = 0, trans = s->transparent_index;\n\n    int honor_transparency = (s->flags & GF_TRANSDIFF) && s->last_frame;\n\n    const uint8_t *ptr;\n\n\n\n    /* Crop image */\n\n    if ((s->flags & GF_OFFSETTING) && s->last_frame && !palette) {\n\n        const uint8_t *ref = s->last_frame->data[0];\n\n        const int ref_linesize = s->last_frame->linesize[0];\n\n        int x_end = avctx->width  - 1,\n\n            y_end = avctx->height - 1;\n\n\n\n        /* skip common lines */\n\n        while (y_start < y_end) {\n\n            if (memcmp(ref + y_start*ref_linesize, buf + y_start*linesize, width))\n\n                break;\n\n            y_start++;\n\n        }\n\n        while (y_end > y_start) {\n\n            if (memcmp(ref + y_end*ref_linesize, buf + y_end*linesize, width))\n\n                break;\n\n            y_end--;\n\n        }\n\n        height = y_end + 1 - y_start;\n\n\n\n        /* skip common columns */\n\n        while (x_start < x_end) {\n\n            int same_column = 1;\n\n            for (y = y_start; y <= y_end; y++) {\n\n                if (ref[y*ref_linesize + x_start] != buf[y*linesize + x_start]) {\n\n                    same_column = 0;\n\n                    break;\n\n                }\n\n            }\n\n            if (!same_column)\n\n                break;\n\n            x_start++;\n\n        }\n\n        while (x_end > x_start) {\n\n            int same_column = 1;\n\n            for (y = y_start; y <= y_end; y++) {\n\n                if (ref[y*ref_linesize + x_end] != buf[y*linesize + x_end]) {\n\n                    same_column = 0;\n\n                    break;\n\n                }\n\n            }\n\n            if (!same_column)\n\n                break;\n\n            x_end--;\n\n        }\n\n        width = x_end + 1 - x_start;\n\n\n\n        av_log(avctx, AV_LOG_DEBUG,\"%dx%d image at pos (%d;%d) [area:%dx%d]\\n\",\n\n               width, height, x_start, y_start, avctx->width, avctx->height);\n\n    }\n\n\n\n    /* image block */\n\n    bytestream_put_byte(bytestream, GIF_IMAGE_SEPARATOR);\n\n    bytestream_put_le16(bytestream, x_start);\n\n    bytestream_put_le16(bytestream, y_start);\n\n    bytestream_put_le16(bytestream, width);\n\n    bytestream_put_le16(bytestream, height);\n\n\n\n    if (!palette) {\n\n        bytestream_put_byte(bytestream, 0x00); /* flags */\n\n    } else {\n\n        unsigned i;\n\n        bytestream_put_byte(bytestream, 1<<7 | 0x7); /* flags */\n\n        for (i = 0; i < AVPALETTE_COUNT; i++) {\n\n            const uint32_t v = palette[i];\n\n            bytestream_put_be24(bytestream, v);\n\n        }\n\n    }\n\n\n\n    if (honor_transparency && trans < 0) {\n\n        trans = pick_palette_entry(buf + y_start*linesize + x_start,\n\n                                   linesize, width, height);\n\n        if (trans < 0) { // TODO, patch welcome\n\n            av_log(avctx, AV_LOG_DEBUG, \"No available color, can not use transparency\\n\");\n\n        } else {\n\n            uint8_t *pal_exdata = s->pal_exdata;\n\n            if (!pal_exdata)\n\n                pal_exdata = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE);\n\n            if (!pal_exdata)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(pal_exdata, s->palette, AVPALETTE_SIZE);\n\n            pal_exdata[trans*4 + 3*!HAVE_BIGENDIAN] = 0x00;\n\n        }\n\n    }\n\n    if (trans < 0)\n\n        honor_transparency = 0;\n\n\n\n    bytestream_put_byte(bytestream, 0x08);\n\n\n\n    ff_lzw_encode_init(s->lzw, s->buf, 2 * width * height,\n\n                       12, FF_LZW_GIF, put_bits);\n\n\n\n    ptr = buf + y_start*linesize + x_start;\n\n    if (honor_transparency) {\n\n        const int ref_linesize = s->last_frame->linesize[0];\n\n        const uint8_t *ref = s->last_frame->data[0] + y_start*ref_linesize + x_start;\n\n\n\n        for (y = 0; y < height; y++) {\n\n            memcpy(s->tmpl, ptr, width);\n\n            for (x = 0; x < width; x++)\n\n                if (ref[x] == ptr[x])\n\n                    s->tmpl[x] = trans;\n\n            len += ff_lzw_encode(s->lzw, s->tmpl, width);\n\n            ptr += linesize;\n\n            ref += ref_linesize;\n\n        }\n\n    } else {\n\n        for (y = 0; y < height; y++) {\n\n            len += ff_lzw_encode(s->lzw, ptr, width);\n\n            ptr += linesize;\n\n        }\n\n    }\n\n    len += ff_lzw_encode_flush(s->lzw, flush_put_bits);\n\n\n\n    ptr = s->buf;\n\n    while (len > 0) {\n\n        int size = FFMIN(255, len);\n\n        bytestream_put_byte(bytestream, size);\n\n        if (end - *bytestream < size)\n\n            return -1;\n\n        bytestream_put_buffer(bytestream, ptr, size);\n\n        ptr += size;\n\n        len -= size;\n\n    }\n\n    bytestream_put_byte(bytestream, 0x00); /* end of image block */\n\n    return 0;\n\n}\n", "idx": 14588, "substitutes": {"avctx": ["avtx", "avercmd", "navcp", "vapool", "abdad", "navctx", "Avcontext", "avercontext", "avpkg", "wavjac", "ovdad", "wavcci", "wavdad", "abcontext", "Avctx", " avcu", " avcontext", "avercmp", " avctl", "svctx", "navcmd", "wavctx", "vacheck", "vctx", "avcmp", "vactx", "ovctx", "savctx", "avecontext", "navconf", "ajcp", "svcontext", "vacontext", "ajconf", "wavcheck", "avcheck", " avcmp", "abctx", "wavpool", "svctl", "avepool", "avcu", "wavpkg", "savpkg", "avcp", "svtx", "averctx", "avcmd", "avconf", "abpkg", "avercu", "ovpkg", "vtx", "vcontext", "avjac", "ovcci", "avctl", "wavcontext", "avcontext", "avcci", "savcci", "savjac", "averconf", "ajctx", " avtx", "Avcmp", "avpool", "avectx", "avdad", "avecheck", "ovjac", "avercp", "ovcontext", "Avcu", "ajcmd", "vctl"], "bytestream": ["byterream", "Bytestamps", "bythamps", "byterstream", "byteramps", "bytestring", "bytestamps", "bythream", "bythring", "byptrstream", "byptrring", "Bytestring", "Bytestream", "byptrream", "Bythstream", "Bythring", "byptramps", "bythstream", "Bythamps", "byterring", "byteststream", "Bythream", "Byteststream"], "end": ["ff", "addr", "begin", "ent", "close", "stop", "nd", "st", "buff", "offset", "send", "ended", "ending", "add", "ender", "pend", "en", "dest", "start", "id", "set", "e", "enc", "pad", "eng", "bound"], "palette": ["Palcolor", "Palettes", "paccolor", "colorette", "colorettes", "Palaque", "pacipple", "plipple", "palcolor", "Palipple", "plaque", "plette", "pacette", "plcolor", "Pallete", "coloraque", "palaque", "palettes", "pallete", "plettes", "palipple", "pllete", "colorlete", "pacettes", "Palette"], "buf": ["bytes", "Buff", "def", "vec", "mem", "late", "ff", "seq", "cmd", "ctx", "p", "wb", "window", "eb", "raw", "proc", "Buffer", "conv", "deg", "pool", "fam", "msg", "buff", "cap", "bin", "cache", "func", "rb", "br", "cam", "desc", "doc", "fb", "buffer", "cb", "cv", "db", "img", "bf", "b", "tmp", "conf", "pad", "emb", "uf", "err", "prop", "queue", "mb", "bg", "pkg", "lim", "txt"], "linesize": ["pagesization", "setsize", "namespace", "valsiz", "locksizer", "facesize", "stylesized", "locksization", "pagesize", "linespace", "valsizer", "valsization", "linesization", "framesize", "setsiz", "imagesizer", "pagesIZE", "inesize", "framesizer", "linesIZE", " linesiz", "inesization", "framespace", "elinesization", "inesocate", "facesiz", "inesiz", "nameszie", "inesized", "locksize", "boardsIZE", "facesization", "namesize", "linesiz", "setsization", "imagessize", "vertsize", "imagesization", "stylesization", "boardsized", "stylesize", "framesization", " lineszie", "pagesocate", "lineszie", "inespace", "namesiz", "linesocate", "linessize", "boardsization", "stylesIZE", "elinesIZE", "linesizer", "vertssize", " linesization", "inesizer", "valsize", "linesized", "inesIZE", "namesization", "elinesocate", "namesizer", "vertsizer", "facesizer", "boardsize", "lockssize", "setszie", "vertsization", "imagesize", "elinesize"], "pkt": ["cpmsg", "ppmsg", "cpkg", " pqt", " pmsg", "pmsg", "ppkg", "cpqt", "pkg", "cpkt", "ppkt", " pkg", "ppqt", "pqt"], "s": ["comments", "aws", "ses", "gs", "S", "sw", "bs", "less", "ports", "ctx", "p", "js", "n", "ex", "sq", "ags", "scripts", "v", "actions", "g", "details", "t", "comm", "is", "sv", "sb", "spec", "als", "hs", "sys", "ds", "ls", "ats", "m", "times", "r", "aps", "sc", "qs", "ts", "c", "stats", "vs", "ins", "states", "ns", "ops", "cs", "h", "es", "ims", "set", "changes", "fs", "os", "aunts", "d", "styles", "parts", "z", "sports", "ss", "w", "sts", "scl", "rs", "ps"], "x": ["tx", "index", "path", "o", "l", "p", "ex", "X", "xy", "ox", "xp", "m", "xi", "dx", "image", "xx", "e", "px", "z", "rx", "w", "xt", "ix"], "y": ["yy", "index", "key", "uy", "ty", "ly", "yt", "oy", "by", "py", "o", "ny", "ys", "l", "j", "p", "axy", "n", "sy", "xxx", "yout", "Y", "acy", "yi", "try", "yz", "xy", "ya", "ym", "yr", "ay", "t", "kit", "ery", "aily", "io", "ye", "icy", "yd", "m", "cy", "zy", "vy", "iy", "ies", "ady", "yer", "yes", "lat", "ry", "b", "tiny", "idy", "iley", "rey", "hey", "e", "my", "story", "sky", "wy", "z", "gy", "ey", "ley", "yl", "yn", "ch"], "ptr": ["src", "inter", "pen", "cur", "ind", "addr", "map", "ctx", "row", "ff", "tr", "dr", "req", "loc", "pointer", "buff", "offset", "br", "dest", "pos", "pend", "id", "rel", "seek", "pad", "err", "alloc"], "ref": ["pro", "resp", "rc", "def", "mem", "ret", "f", "Ref", "orig", "ff", "seq", "addr", "map", "cmd", "row", "tr", "reference", "req", "val", "reset", "deg", "reg", "grab", "note", "buff", "cache", "ef", "rb", "br", "desc", "r", "url", "obj", "rep", "fb", "rev", "info", "range", "buffer", "cb", "ro", "db", "pos", "cal", "all", "rot", "red", "re", "rel", "conf", "iter", "arg", "uf", "prop", "err", "mb", "REF", "pkg", "tab"], "y_start": [" y_entry", "y_store", "y7part", "yGend", "ry_starting", "yGstart", "y7set", "y09inter", "ry_part", "ny0start", "ny_step", " y_open", "y0entry", "ny_end", "y_wind", "y09starting", "my_end", "x_offset", "y_begin", "ny_start", " y_since", "y_offset", "ny_entry", "y_since", "y_Start", "y_step", "yGopen", "ny_store", "my_shift", "y_inter", "ny_starter", " y_Start", "y_part", "y7start", "y0set", "y09part", "ry_set", "y09end", "y_shift", "y___entry", "y09set", "x_inter", "y09start", "x_begin", "y_starter", "ny0entry", "y7starting", "y_list", "y0start", "ny0set", "y_open", "y0store", "ny_set", "y___store", "y_entry", "y___set", "ny0store", "y_starting", "y09list", "ry_wind", "x_list", "ry_start", "y_set", "my_start", "y___start", "yGentry", "my_part", "ry_store"], "y_end": ["key67start", "y67end", "x_term", "y67ended", "yjend", "yresstart", "y2term", "my_alt", "y67east", "yPback", "yPeast", "ya_end", "yptmax", "yPstop", "yresedge", "y__term", "yptout", "my_end", "y67start", "yresend", "ya_east", "y__end", "yPend", "yJend", "ya_en", "yptstart", "y_back", "y_End", "x_stop", "key_ended", "yptend", "x_east", "y_east", "y_edge", "yjstart", "y2enable", "y_ended", "x_rest", "yjen", "ya67east", "ya67en", "key67end", "ya67end", "y_out", "y_max", "yjalt", "ey_term", "yresEnd", "ya_start", "y67en", " y_out", "ey_enable", "y67enable", "y2ended", "my_en", "y_term", "key_start", "ya67start", "ey_end", " y_max", "my_edge", "x_back", "y_en", "yJterm", "key67ended", "y_stop", "yJenable", "y_alt", "yPrest", "key_end", "y__enable", "key67enable", "y2start", "y_rest", "y_enable", "yJonly", "my_End", "yPstart", "my_start", "ey_only", "key_enable", "y__only", "y_only", "y2end", "x_ended"], "x_start": ["mx_client", "x8try", "lex03next", "x___end", "mx_start", "x10start", "x10sample", "x_root", "x_client", "lex03sample", "x_try", "x00client", "x_first", "x10try", "x10next", "mx8get", "x_index", "x03client", "lex_start", "ex_root", "x00starter", "lex_try", "ex_end", "x_train", "x00get", "ex_first", "x00start", "x2end", "x03start", "x_starter", "lex_next", "y_index", "ex_Start", "x8get", "lex03try", "mx8starter", "x8client", "x00end", "mx_get", "x03starter", "x8sample", "x_sample", "x___start", "x00old", "x2start", "x00train", "x_next", "x03sample", "x00root", "x8next", "x8starter", "mx_starter", "x03try", "ex_start", "x___old", "x03get", "x_old", "mx8client", "x03next", "x00Start", "x_get", "mx8start", "lex03start", "ex_old", "ex_train", "x8start", "x_Start", "lex_sample", "x___train", "x2index"], "x_end": ["ex_ord", "x__ad", "x_right", "ex_run", "x9end", "x9load", "ex_ad", "ex_ending", "ex_end", "x__ending", "x_until", "x_load", "x_stop", "ex_right", "x_ad", "ex_save", "ex_until", "x__start", "ex_load", "x__end", "x_max", "x_ord", "x_ending", "ex_start", "ex_max", "x9start", "ex_stop", "x9ord", "x_save", "x_run"]}}
{"project": "qemu", "commit_id": "9c4bab2668e6b5a9b69f77e3533380b6fd79034e", "target": 0, "func": "static int openfile(char *name, int flags)\n\n{\n\n\tif (bs) {\n\n\t\tfprintf(stderr, \"file open already, try 'help close'\\n\");\n\n\t\treturn 1;\n\n\t}\n\n\n\n\tbs = bdrv_new(\"hda\");\n\n\tif (!bs)\n\n\t\treturn 1;\n\n\n\n\tif (bdrv_open(bs, name, flags) == -1) {\n\n\t\tfprintf(stderr, \"%s: can't open device %s\\n\", progname, name);\n\n\t\tbs = NULL;\n\n\t\treturn 1;\n\n\t}\n\n\n\n\treturn 0;\n\n}\n", "idx": 14589, "substitutes": {"name": ["key", "path", "ni", "type", "a", "mem", "nw", "local", "out", "size", "data", "l", "j", "n", "p", "nam", "names", "filename", "val", "v", "cap", "title", "new", "m", "part", "s", "Name", "prefix", "sp", "file", "base", "b", "id", "e", " Name", "mod", "me", "ame", "ma", "format", "w", "nm", "NAME", "str", "ch"], "flags": ["types", "ensions", "FLAG", "tags", "ports", "lines", "ids", "bits", "ags", "eps", "fields", "limits", "features", "faces", "ats", "times", "heads", "aps", "atts", "lag", "grades", "acts", "ts", "Flags", "flag", "args", "cs", "locks", "posts", "styles", "parts", "options", "ants", " Flags", "fps", "weights", "ents", "ms", "properties", "members"]}}
{"project": "qemu", "commit_id": "67113c03423a23e60915574275aed7d60e9f85e1", "target": 0, "func": "static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)\n\n{\n\n    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);\n\n    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),\n\n                                  \"/e500-ccsr\"));\n\n\n\n    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);\n\n    d->config[PCI_HEADER_TYPE] =\n\n        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n\n\n    memory_region_init_alias(&b->bar0, OBJECT(ccsr), \"e500-pci-bar0\", &ccsr->ccsr_space,\n\n                             0, int128_get64(ccsr->ccsr_space.size));\n\n    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);\n\n}\n", "idx": 14591, "substitutes": {"d": ["o", "dn", "data", "l", "j", "p", "n", "x", "dr", "D", "dl", "dm", "pd", "dt", "v", "g", "ded", "dp", "t", "du", "md", "di", "dc", "ed", "dos", "ds", "ct", "da", "m", "dd", "r", "send", "bd", "dq", "c", "dx", "db", "h", "dev", "draw", "e", "de", "ad", "sd", "mod", "dh", "q", "del", "dat", "did", "w", "i", "ld", "ind"], "errp": ["erP", " errpp", "iterp", " errps", "erp", "erpp", "erps", "errps", "iterpp", " errP", "errpp", "iterps", "iterP", "errP"], "b": ["bar", "be", "blue", "ba", "a", "ib", "f", "bs", "l", "pb", "j", "p", "wb", "n", "eb", "reb", "bh", "amb", "v", "erb", "g", "bt", "sb", "gb", "ab", "rb", "job", "m", "r", "fb", "bd", "c", "cb", "db", "bc", "e", "B", "emb", "bb", "nb", "mb", "bp", "bg", "w", "y"], "ccsr": ["ccaser", "cksf", "pccr", "ccri", "ckSR", "cr", "acSR", "ccarf", "cssr", "acsr", "pcsf", "crf", "cscr", "cfcr", "ckrx", "pcrf", "cciSR", "ccspr", "pcr", "ccsf", "cfSR", "csr", "csrx", "ccar", "pcser", "ccasr", "cccr", "acri", "ccSR", "accr", "ckcr", "cfsr", "ccr", "ccisr", "pcsr", "cser", "pcrx", "cfri", "ccicr", "ccrx", "cksr", "ccrf", "csSR", "ccser", "csspr", "ccispr", "cssf", "acspr", "ckri"]}}
{"project": "FFmpeg", "commit_id": "290e7eb77bee5a54182fb3d5fb122c1e117190da", "target": 1, "func": "void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)\n\n{\n\n    int i;\n\n\n\n    for (i=0; i < in->n; i++) {\n\n        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);\n\n\n\n\n        do {\n\n            out[x] = 0.0;\n\n            x += in->pitch_lag;\n\n        } while (x < size && repeats);\n\n    }\n\n}", "idx": 14599, "substitutes": {"out": ["hit", "at", "f", "ret", "serv", "o", "output", "array", "ref", "p", "v", "check", "pool", "t", "result", "new", "obj", "off", "Out", "clean", "c", "up", "soft", "all", "pos", "ul", "res", "b", "print", "client", "found", "set", "OUT", "con", "ou", "list", "ot", "it", "net", "w", "x", "y", "sum"], "in": ["bit", "by", "at", "version", "gin", "serv", "local", "ind", "l", "inc", "old", "ex", "or", "raw", "req", "min", "din", "t", "vin", "bin", "new", "al", " IN", "In", "doc", "add", "ac", "info", "IN", "mm", "up", "file", "base", "inn", "ins", "on", "rin", "input", "re", "inner", "con", "from", "it", "ma", "isin", "init", "inf", "sum"], "size": ["index", "Size", "shift", "number", "l", "SIZE", "scope", "n", "or", "si", "v", "g", "len", "ize", "space", "offset", "num", "ze", "send", "m", "empty", "count", "capacity", "no", "scale", "start", "equal", "set", "e", "see", "max", "length", "shape", "z", "small", "sn", "w", "name", "sum"], "i": ["ij", "index", "li", "by", "f", "iu", "o", "inter", "mi", "ii", "I", "pi", "ini", "ind", "j", "uri", "n", "p", "ex", "ki", "si", "l", "zi", " ti", "v", "chain", "bi", "io", "t", "us", "ui", "is", "di", " ii", "ai", "m", " I", "hi", "xi", "sim", "info", "im", "c", " multi", "ci", "b", "id", "ims", "ti", "e", "ri", "u", "multi", "it", "gi", "fi", "me", "d", "z", "phi", "init", "x", "y", "ic", "ix", "ip"]}}
{"project": "FFmpeg", "commit_id": "c58d45e00489e07fd4606b64ad4095660494185b", "target": 1, "func": "static int film_read_header(AVFormatContext *s,\n\n                            AVFormatParameters *ap)\n\n{\n\n    FilmDemuxContext *film = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    unsigned char scratch[256];\n\n    int i;\n\n    unsigned int data_offset;\n\n    unsigned int audio_frame_counter;\n\n\n\n    film->sample_table = NULL;\n\n    film->stereo_buffer = NULL;\n\n    film->stereo_buffer_size = 0;\n\n\n\n    /* load the main FILM header */\n\n    if (avio_read(pb, scratch, 16) != 16)\n\n        return AVERROR(EIO);\n\n    data_offset = AV_RB32(&scratch[4]);\n\n    film->version = AV_RB32(&scratch[8]);\n\n\n\n    /* load the FDSC chunk */\n\n    if (film->version == 0) {\n\n        /* special case for Lemmings .film files; 20-byte header */\n\n        if (avio_read(pb, scratch, 20) != 20)\n\n            return AVERROR(EIO);\n\n        /* make some assumptions about the audio parameters */\n\n        film->audio_type = CODEC_ID_PCM_S8;\n\n        film->audio_samplerate = 22050;\n\n        film->audio_channels = 1;\n\n        film->audio_bits = 8;\n\n    } else {\n\n        /* normal Saturn .cpk files; 32-byte header */\n\n        if (avio_read(pb, scratch, 32) != 32)\n\n            return AVERROR(EIO);\n\n        film->audio_samplerate = AV_RB16(&scratch[24]);\n\n        film->audio_channels = scratch[21];\n\n        film->audio_bits = scratch[22];\n\n        if (scratch[23] == 2)\n\n            film->audio_type = CODEC_ID_ADPCM_ADX;\n\n        else if (film->audio_bits == 8)\n\n            film->audio_type = CODEC_ID_PCM_S8;\n\n        else if (film->audio_bits == 16)\n\n            film->audio_type = CODEC_ID_PCM_S16BE;\n\n        else\n\n            film->audio_type = CODEC_ID_NONE;\n\n    }\n\n\n\n    if (AV_RB32(&scratch[0]) != FDSC_TAG)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (AV_RB32(&scratch[8]) == CVID_TAG) {\n\n        film->video_type = CODEC_ID_CINEPAK;\n\n    } else\n\n        film->video_type = CODEC_ID_NONE;\n\n\n\n    /* initialize the decoder streams */\n\n    if (film->video_type) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        film->video_stream_index = st->index;\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->codec->codec_id = film->video_type;\n\n        st->codec->codec_tag = 0;  /* no fourcc */\n\n        st->codec->width = AV_RB32(&scratch[16]);\n\n        st->codec->height = AV_RB32(&scratch[12]);\n\n    }\n\n\n\n    if (film->audio_type) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        film->audio_stream_index = st->index;\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_id = film->audio_type;\n\n        st->codec->codec_tag = 1;\n\n        st->codec->channels = film->audio_channels;\n\n        st->codec->sample_rate = film->audio_samplerate;\n\n\n\n        if (film->audio_type == CODEC_ID_ADPCM_ADX) {\n\n            st->codec->bits_per_coded_sample = 18 * 8 / 32;\n\n            st->codec->block_align = st->codec->channels * 18;\n\n        } else {\n\n            st->codec->bits_per_coded_sample = film->audio_bits;\n\n            st->codec->block_align = st->codec->channels *\n\n                st->codec->bits_per_coded_sample / 8;\n\n        }\n\n\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n            st->codec->bits_per_coded_sample;\n\n    }\n\n\n\n    /* load the sample table */\n\n    if (avio_read(pb, scratch, 16) != 16)\n\n        return AVERROR(EIO);\n\n    if (AV_RB32(&scratch[0]) != STAB_TAG)\n\n        return AVERROR_INVALIDDATA;\n\n    film->base_clock = AV_RB32(&scratch[8]);\n\n    film->sample_count = AV_RB32(&scratch[12]);\n\n    if(film->sample_count >= UINT_MAX / sizeof(film_sample))\n\n        return -1;\n\n    film->sample_table = av_malloc(film->sample_count * sizeof(film_sample));\n\n    if (!film->sample_table)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for(i=0; i<s->nb_streams; i++)\n\n        av_set_pts_info(s->streams[i], 33, 1, film->base_clock);\n\n\n\n    audio_frame_counter = 0;\n\n    for (i = 0; i < film->sample_count; i++) {\n\n        /* load the next sample record and transfer it to an internal struct */\n\n        if (avio_read(pb, scratch, 16) != 16) {\n\n            av_free(film->sample_table);\n\n            return AVERROR(EIO);\n\n        }\n\n        film->sample_table[i].sample_offset =\n\n            data_offset + AV_RB32(&scratch[0]);\n\n        film->sample_table[i].sample_size = AV_RB32(&scratch[4]);\n\n        if (AV_RB32(&scratch[8]) == 0xFFFFFFFF) {\n\n            film->sample_table[i].stream = film->audio_stream_index;\n\n            film->sample_table[i].pts = audio_frame_counter;\n\n            film->sample_table[i].pts *= film->base_clock;\n\n            film->sample_table[i].pts /= film->audio_samplerate;\n\n\n\n            if (film->audio_type == CODEC_ID_ADPCM_ADX)\n\n                audio_frame_counter += (film->sample_table[i].sample_size * 32 /\n\n                    (18 * film->audio_channels));\n\n            else\n\n                audio_frame_counter += (film->sample_table[i].sample_size /\n\n                    (film->audio_channels * film->audio_bits / 8));\n\n        } else {\n\n            film->sample_table[i].stream = film->video_stream_index;\n\n            film->sample_table[i].pts = AV_RB32(&scratch[8]) & 0x7FFFFFFF;\n\n            film->sample_table[i].keyframe = (scratch[8] & 0x80) ? 0 : 1;\n\n        }\n\n    }\n\n\n\n    film->current_sample = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 14612, "substitutes": {"s": ["sis", "ses", "gs", "a", "S", "f", "as", "l", "p", "js", "n", "v", "g", "t", "comm", "spec", "is", "sb", "sv", "ds", "ls", "ats", "m", "r", "c", "stats", "ins", "b", "ns", "cs", "h", "e", "fs", "d", "skin", "ss", "sc", "rs", "ps"], "ap": ["map", " sp", "par", "ar", "pp", "cap", " par", "op", "al", "att", "aps", "ac", "sp", "ep", " sap", "apt", " mp", "mp", "ape", " p", "amp", "ps", "pl", "tp", " af", "pa", "tap", "ip"], "film": ["evil", "actor", "Film", "ideo", "performance", "farm", "talk", "internet", "hid", "DVD", "het", "ani", "intelligence", "gif", "filter", "gear", "fin", "medium", "food", "product", "flash", "information", "v", " filmmaking", "runtime", "fashion", "fb", "compliance", "drm", "print", "arel", "lamm", "production", "fi", "ovie", "review", "history", "vati", "face", "f", "mmmm", "movie", "feat", "football", "redd", "ammu", "material", "media", " movies", "fm", "vid", "lead", "interstitial", "work", " Film", "contact", "debug", "faith", "research", "hall", "Director", "tv", "race", "fiction", "intel", "frame", "pp", "video", "feature", "cam", "web", "voice", " films", "motion", "html", "find", "render", "tf", "image", "die", "article", "stall", "trak", "skin", "detail", "wikipedia"], "pb": ["jp", "rpm", "ctl", "dial", "tc", "bs", "ctx", "p", "farm", "apa", "cmp", "wb", "proc", "vp", "pm", "tk", "typ", "pan", "conv", "pool", "bj", "orp", "apy", "pt", "stab", "dp", "pp", "sb", "buf", "dc", "np", "sys", "rb", "buff", "ub", "snap", "cpp", "fb", "vm", "buffer", "cb", "lp", "cv", "fp", "PB", "cp", "pg", "mp", "pc", "prototype", "tmp", "pid", "bps", "bb", "pel", "uf", "pl", "pkg", "bp", "tp", "prep", "pa", "tap"], "st": ["ste", "spect", "stable", "est", "sw", "src", "sta", "St", "ST", "tv", "ist", "str", "sl", "sam", "sv", "isl", "ct", "rest", "sp", "std", "sh", "ped", "spe", "ss", "inst", "sc", "sts", "cont"], "scratch": ["secrub", "nowashed", "descash", " scraped", "Scraped", "searchrap", "searchratch", "swash", "escreenshot", "nowratch", "swrawler", "descarry", "ancrub", "scapy", " scapy", "swattered", " scattered", "shattered", "shratch", "Scrub", "ascratch", "scrub", "scash", "Scachable", "escash", "escratch", "Scattered", "Scapy", "bcarry", "swreenshot", "scatch", "shapy", "scarry", "schematic", " scrub", "screenshot", "escachable", "swatch", "scatter", "scraped", "searchrawler", " scatter", "escapy", "eschematic", "descattered", "Screenshot", "escrub", "descrub", "bcratch", " schematic", "ancrap", "escatter", "scrap", "swrub", "ancratch", "secraped", "escarry", "ascatch", "bchematic", "descratch", "descreenshot", "swratch", "scashed", "ascapy", "scrawler", "nowrap", "escattered", "escatch", "escrap", "escashed", " scatch", "bcachable", "shrap", "ascattered", "ascrub", "searchhematic", "escrawler", "nowrub", "ancashed", "shhematic", "shatch", "searchatch", "scachable", " scachable", "secapy", "ascatter", "secratch", "Scratch", " screenshot", "scattered", "bcattered"], "i": ["li", "iu", "o", "ii", "mi", "I", "pi", "l", "j", "p", "si", "v", "bi", "io", " ii", "ai", "m", "xi", "c", "ci", "b", "rin", "ati", "ti", "it", "d", "fi", "iat"], "data_offset": [" data_address", "data_Offset", "video_pos", "data00offset", "data_address", "data___pointer", "data00pos", "data___Offset", "data___address", "data00counter", "video_offset", "data___offset", "data00count", "video_counter", "data_counter", "data_count", " data_pointer", "video_count", "data_pos", "data_pointer", " data_Offset"], "audio_frame_counter": ["audio_frame_number", "audio_frames_sequence", "audio_frames_counter", "audio_frame_count", "audio_frames_count", "audio_frames_number", "audio_frame_sequence"]}}
{"project": "FFmpeg", "commit_id": "d9051f8f3e60768f68867c3e3116e980d855215a", "target": 1, "func": "static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)\n\n{\n\n    int16_t *block = ctx->dct_block;\n\n    unsigned int pos;\n\n\n\n    ctx->bdsp.clear_block(block);\n\n\n\n    block[0] = get_bits(&ctx->gb, 8) << 3;\n\n\n\n    for (pos = 1; pos < num_coeffs; pos++) {\n\n        uint32_t vlc, num_bits;\n\n        int value;\n\n        int coeff;\n\n\n\n        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);\n\n        if (!vlc) /* end-of-block code */\n\n            return 0;\n\n        if (vlc == -1)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        /* pos_add and num_bits are coded in the vlc code */\n\n        pos     += vlc & 15; // pos_add\n\n        num_bits = vlc >> 4; // num_bits\n\n\n\n        if (pos >= 64)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        value = get_bits(&ctx->gb, num_bits);\n\n\n\n        /* FFmpeg's IDCT behaves somewhat different from the original code, so\n\n         * a factor of 4 was added to the input */\n\n\n\n        coeff = vlcdec_lookup[num_bits][value];\n\n        if (pos < 3)\n\n            coeff *= 16;\n\n        else /* TODO Use >> 10 instead of / 1001 */\n\n            coeff = (coeff * qscale) / 1001;\n\n\n\n        block[ctx->scantable.permutated[pos]] = coeff;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14639, "substitutes": {"ctx": ["conn", "hw", "window", "cmp", "mk", "cas", "check", "loc", "nt", "context", "cb", "xc", "abc", "course", "pkg", "exec", "tx", "rc", "kw", "ctl", "def", "wx", "setup", "cmd", "crit", "kt", "conv", "xp", "stack", "cfg", "obj", "aux", "nc", "std", "cp", "ctrl", "gc", "Context", "tmp", "conf", "scl", "ca", "ic", "txt", "history", "resp", "cf", "cc", "req", "xs", "height", "sys", "np", "fx", "ork", "work", " cx", "cv", "lex", "bc", "acl", "pc", "etc", "config", "px", "tm", "HK", "iat", "jac", "jp", "cu", "tc", "cm", "ia", "dc", "ct", "act", "desc", "prefix", "ck", "that", "sc", "anc"], "num_coeffs": ["num_coefs", "num_coefers", "num_coeffS", "num_coefficientS", "num_cofficers", "num_coffS", "num_coefS", "num_coffs", "num_coefficientss", "num_cofficS", "num_coeffes", "num_coefficients", "num_coefficientes", "num_coefes", "num_coffics", "num_coefficientsS", "num_coefficientses", "num_coffers", "num_coeffers"], "qscale": ["qtransform", "Qweight", "qvscale", "QScale", " QScale", "qvweight", "qweight", " Qtransform", "qqweight", "qScale", "qqScale", "Qscale", " sqtransform", "qdelay", " sqscale", "Qtransform", "qqscale", "qvdelay", " Qscale", "qvScale", " sqScale", "qqdelay", "Qdelay"], "block": ["bit", "tx", "view", "record", "mem", "local", "out", "ref", "session", "object", "map", "mask", "row", "window", "group", "chain", "pool", "load", "batch", "box", "field", "cache", "loop", "bin", "bus", "cl", "lock", "line", "ml", "disk", "blocks", "Block", "obj", "panel", "library", "ck", "buffer", "inv", "sp", "board", "bm", "link", "limit", "sync", "bl", "ack", "bc", "list", "hash", "q", "ip", "zero", "join", "BL", "init", "save", "filter", "pack"], "pos": ["index", "shift", "bs", "pres", "val", "port", "len", "loc", "loop", "doc", "neg", "limit", "po", " position", "client", "start", "pid", "length", "ps", "pro", "def", "nos", "axis", "Pos", "ind", "pr", "spec", "padding", "apo", "part", "slice", " len", "conf", "x", " POS", "pose", "key", "at", "out", "cond", "pi", "pat", "row", "proc", "offset", "op", "P", "snap", "slot", "Position", " Pos", "up", "trans", "pc", "POS", "px", "go", "o", "position", "size", "p", "pt", "diff", "num", "tag", "off", "oss", "count", "mut", "rot", "no", "post", "point", "os", "prop", "pl", "pointer"], "vlc": ["bilc", "plcs", "vccu", "slpc", "palcc", "klc", "vinci", "llci", "plci", "lvpc", "volpc", "vlpc", "vlce", "vcci", "llc", "svcu", " plci", "pelc", "vincc", " plc", "lvcs", "wlci", "slc", "pelpc", "klci", "bilci", "pltc", "svpc", "slcc", "vinpc", "vctc", "palc", "vlcat", "lvcu", "lvvc", "vinc", "svc", "slci", "klce", "vlci", "volcat", "llpc", "palcu", "slcu", "lvcat", "bilcs", "volcu", "vlcu", "vlvc", "vcc", "lvc", "klcs", "plc", "wlcc", "wltc", "wlc", "pelcc", "llvc", "vlcc", "wlce", "vccat", " plvc", "palpc", "wlcu", "lvtc", "bilce", "vccs", "svcs", "vlcs", "wlcs", "pelci", "voltc", "wlpc", " plpc", "volc", "volcc", "lvci", "vltc"], "num_bits": [" num_nets", "num_bytes", "num2its", "total_bits", "num2bytes", "Num_bit", "num2planes", "num23bits", "num2bit", "num_planes", "num_bit", "num2bits", "num23nets", " num_bytes", "num2ints", "num_bis", "Num_bits", "num_ints", " num_planes", "num_pieces", "num23bytes", "num_vals", "num_nets", "total_bytes", "Num_its", "Num_ints", "num_its", " num_its", "num23vals", "total_bis", " num_vals", "total_pieces"], "value": ["bit", "key", "index", "instance", "type", "version", "number", "position", "tv", "address", "data", "values", "raw", "vp", "val", "v", "text", "widget", "field", "unit", "VALUE", "new", "num", "select", "tag", "Value", "true", "context", "word", "ue", "current", "attribute", "comment", "image", "function", "code", "property", "scale", "vector", "label", "serial", "TV", "see", "VAL", "length", "total", "style", "package", "name", "valid", "color"], "coeff": ["Coefficient", " Coefficient", "Coeff", "corff", "COffe", "coef", " Coeff", "COefficient", " Coff", "coref", " coffe", "coreff", " coff", " Coef", "Coff", "COeff", " coefficient", "Coef", " coef", "corffe", "coefficient", "coff", "coffe", "COef", "COff"]}}
{"project": "FFmpeg", "commit_id": "87e302bfd8ffbc6cdb20920029013956b10ace63", "target": 0, "func": "static int svq3_decode_frame(AVCodecContext *avctx,\n\n                             void *data, int *data_size,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MpegEncContext *const s = avctx->priv_data;\n\n    H264Context *const h = avctx->priv_data;\n\n    int m, mb_type;\n\n\n\n    /* special case for last picture */\n\n    if (buf_size == 0) {\n\n        if (s->next_picture_ptr && !s->low_delay) {\n\n            *(AVFrame *) data = *(AVFrame *) &s->next_picture;\n\n            s->next_picture_ptr = NULL;\n\n            *data_size = sizeof(AVFrame);\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    init_get_bits (&s->gb, buf, 8*buf_size);\n\n\n\n    s->mb_x = s->mb_y = h->mb_xy = 0;\n\n\n\n    if (svq3_decode_slice_header(h))\n\n        return -1;\n\n\n\n    s->pict_type = h->slice_type;\n\n    s->picture_number = h->slice_num;\n\n\n\n    if (avctx->debug&FF_DEBUG_PICT_INFO){\n\n        av_log(h->s.avctx, AV_LOG_DEBUG, \"%c hpel:%d, tpel:%d aqp:%d qp:%d, slice_num:%02X\\n\",\n\n               av_get_pict_type_char(s->pict_type), h->halfpel_flag, h->thirdpel_flag,\n\n               s->adaptive_quant, s->qscale, h->slice_num);\n\n    }\n\n\n\n    /* for hurry_up == 5 */\n\n    s->current_picture.pict_type = s->pict_type;\n\n    s->current_picture.key_frame = (s->pict_type == FF_I_TYPE);\n\n\n\n    /* Skip B-frames if we do not have reference frames. */\n\n    if (s->last_picture_ptr == NULL && s->pict_type == FF_B_TYPE)\n\n        return 0;\n\n    /* Skip B-frames if we are in a hurry. */\n\n    if (avctx->hurry_up && s->pict_type == FF_B_TYPE)\n\n        return 0;\n\n    /* Skip everything if we are in a hurry >= 5. */\n\n    if (avctx->hurry_up >= 5)\n\n        return 0;\n\n    if (  (avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type == FF_B_TYPE)\n\n        ||(avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type != FF_I_TYPE)\n\n        || avctx->skip_frame >= AVDISCARD_ALL)\n\n        return 0;\n\n\n\n    if (s->next_p_frame_damaged) {\n\n        if (s->pict_type == FF_B_TYPE)\n\n            return 0;\n\n        else\n\n            s->next_p_frame_damaged = 0;\n\n    }\n\n\n\n    if (frame_start(h) < 0)\n\n        return -1;\n\n\n\n    if (s->pict_type == FF_B_TYPE) {\n\n        h->frame_num_offset = (h->slice_num - h->prev_frame_num);\n\n\n\n        if (h->frame_num_offset < 0) {\n\n            h->frame_num_offset += 256;\n\n        }\n\n        if (h->frame_num_offset == 0 || h->frame_num_offset >= h->prev_frame_num_offset) {\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"error in B-frame picture id\\n\");\n\n            return -1;\n\n        }\n\n    } else {\n\n        h->prev_frame_num = h->frame_num;\n\n        h->frame_num = h->slice_num;\n\n        h->prev_frame_num_offset = (h->frame_num - h->prev_frame_num);\n\n\n\n        if (h->prev_frame_num_offset < 0) {\n\n            h->prev_frame_num_offset += 256;\n\n        }\n\n    }\n\n\n\n    for (m = 0; m < 2; m++){\n\n        int i;\n\n        for (i = 0; i < 4; i++){\n\n            int j;\n\n            for (j = -1; j < 4; j++)\n\n                h->ref_cache[m][scan8[0] + 8*i + j]= 1;\n\n            if (i < 3)\n\n                h->ref_cache[m][scan8[0] + 8*i + j]= PART_NOT_AVAILABLE;\n\n        }\n\n    }\n\n\n\n    for (s->mb_y = 0; s->mb_y < s->mb_height; s->mb_y++) {\n\n        for (s->mb_x = 0; s->mb_x < s->mb_width; s->mb_x++) {\n\n            h->mb_xy = s->mb_x + s->mb_y*s->mb_stride;\n\n\n\n            if ( (get_bits_count(&s->gb) + 7) >= s->gb.size_in_bits &&\n\n                ((get_bits_count(&s->gb) & 7) == 0 || show_bits(&s->gb, (-get_bits_count(&s->gb) & 7)) == 0)) {\n\n\n\n                skip_bits(&s->gb, h->next_slice_index - get_bits_count(&s->gb));\n\n                s->gb.size_in_bits = 8*buf_size;\n\n\n\n                if (svq3_decode_slice_header(h))\n\n                    return -1;\n\n\n\n                /* TODO: support s->mb_skip_run */\n\n            }\n\n\n\n            mb_type = svq3_get_ue_golomb(&s->gb);\n\n\n\n            if (s->pict_type == FF_I_TYPE) {\n\n                mb_type += 8;\n\n            } else if (s->pict_type == FF_B_TYPE && mb_type >= 4) {\n\n                mb_type += 4;\n\n            }\n\n            if (mb_type > 33 || svq3_decode_mb(h, mb_type)) {\n\n                av_log(h->s.avctx, AV_LOG_ERROR, \"error while decoding MB %d %d\\n\", s->mb_x, s->mb_y);\n\n                return -1;\n\n            }\n\n\n\n            if (mb_type != 0) {\n\n                hl_decode_mb (h);\n\n            }\n\n\n\n            if (s->pict_type != FF_B_TYPE && !s->low_delay) {\n\n                s->current_picture.mb_type[s->mb_x + s->mb_y*s->mb_stride] =\n\n                    (s->pict_type == FF_P_TYPE && mb_type < 8) ? (mb_type - 1) : -1;\n\n            }\n\n        }\n\n\n\n        ff_draw_horiz_band(s, 16*s->mb_y, 16);\n\n    }\n\n\n\n    MPV_frame_end(s);\n\n\n\n    if (s->pict_type == FF_B_TYPE || s->low_delay) {\n\n        *(AVFrame *) data = *(AVFrame *) &s->current_picture;\n\n    } else {\n\n        *(AVFrame *) data = *(AVFrame *) &s->last_picture;\n\n    }\n\n\n\n    avctx->frame_number = s->picture_number - 1;\n\n\n\n    /* Do not output the last pic after seeking. */\n\n    if (s->last_picture_ptr || s->low_delay) {\n\n        *data_size = sizeof(AVFrame);\n\n    }\n\n\n\n    return buf_size;\n\n}\n", "idx": 14654, "substitutes": {"avctx": ["avtx", "avercfg", "wavctl", "vrcu", "vrctx", "Avcontext", "avercontext", "avpkg", "avbc", "averbc", "avertx", "avcc", "Avctx", "avercmp", " avcontext", "Avcfg", "wavtx", "svctx", "avcfg", "wavctx", "avedt", "vrcontext", "avdt", "avcmp", "varctx", "avecontext", "avece", "svcontext", "avecam", "avetx", "avgc", "vrcam", "averctl", "avergc", " avcfg", "wavgc", "varctl", "averce", "campkg", "avcu", "avecu", "AVconn", " avconn", "AVctx", "averpkg", "averdt", "vardt", "vrtx", "svtx", "averctx", "avercam", "Avbc", "avconn", "camctx", "avercu", "svconn", "avejac", "wavconfig", "avecmp", "aveconn", "AVctl", "avconfig", "avjac", "avectl", "camjac", "avctl", "avce", "wavcontext", "avcontext", "avepkg", "varcmp", " avbc", "avegc", "aveconfig", " avtx", "camcc", "avercc", "averconn", "AVtx", "avectx", "vrce", "wavconn", "averconfig", "vrcc", "vrconn", "avcam", "averjac", "avecc"], "data": ["bytes", "a", "mem", "f", "size", "p", "window", "bits", "raw", "v", "text", "next", "picture", "batch", "t", "frame", "read", "video", "bin", "result", "align", "cache", "r", "message", "info", "buffer", "empty", "block", "image", "file", "c", "img", "Data", "content", "feed", "input", "area", "pad", "length", "d", "DATA", "ata", "value", "dat", "w", "name", "str"], "data_size": ["buf_body", " data_SIZE", "data64size", "data_Size", "data64number", "data_body", "data64SIZE", " data_number", "buf_Size", "data_number", "buf_size", "data_SIZE"], "avpkt": ["avPconn", "avpft", "avdcmd", " avpconn", " avPkt", "avPft", "avppft", "awpacket", "avcpcmd", "avppct", "awpct", "afcpkt", "avppt", "afpcmd", "avpconn", "awcpacket", "avpqt", "avnpacket", "avdkt", "avjpqt", "afcpcmd", "avPkt", "afcpacket", "avcpkt", "avpct", "awcpkt", "avcpct", "avpacket", "avnpqt", "avnpconn", "awpft", " avPqt", "avpcmd", "afpkt", "awcpct", "avPct", "avppkt", "avjpkt", "avcpacket", "avnpkt", "awcpft", "avPacket", "avcppt", "awpkt", "avjppt", " avpacket", "avdpt", "avjpconn", "avPqt", " avPacket", "avppacket", "avjpacket", "avdacket", "avcpft", "avjpcmd", "afcppt", " avPconn", " avpqt", "afppt", "afpacket"], "buf": ["bytes", "Buff", "rc", "vec", "mem", "map", "cmd", "p", "window", "raw", "bh", "Buffer", "conv", "v", "batch", "box", "read", "msg", "buff", "np", "rb", "br", "r", "doc", "fb", "buffer", "cb", "block", "cv", "img", "b", "bl", "bc", "tmp", "uf", "queue", "txt"], "s": ["ses", "gs", "S", "settings", "bs", "ports", "sq", "sam", "t", "st", "qs", "stats", "vs", "sh", "cs", "tests", "ims", "its", "sum", "ps", "sw", "n", "js", "v", "g", "ar", "spec", "ds", "ats", "sa", "services", "so", "ears", "args", "set", "conf", "parts", "results", "a", "as", "less", "bits", "sm", "sb", "service", "als", "hs", "sys", "his", "ess", "ands", "c", "es", "changes", "fs", "state", "d", "se", "sports", "ss", "comments", "sort", "has", "l", "p", "details", "is", "sv", "ls", "gets", "ts", "sp", "ins", "ns", "b", "os", "z", "sts", "ms", "y", "rs"], "h": ["f", "uh", "ph", "kh", "o", "handle", "has", "header", "l", "hz", "p", "hm", "hw", "bh", "hal", "v", "ha", "g", "http", "t", "ih", "hs", "r", "ah", "th", "he", "hi", "html", "info", "hd", "c", "rh", "oh", "ec", "sh", "ht", "b", "H", "ish", "host", "u", "hl", "hash", "os", "d", "dh", "it", "eh", "q", "hh", "w", "gh", "zh", "history", "ch", "hp"], "m": ["mem", "um", "mi", "attr", "mask", "n", "p", "cmp", " mt", "perm", "v", "dm", "t", " im", "dim", "im", "om", "img", " v", "b", "gm", "M", "d", " p", "nm", " M", "imm"], "mb_type": ["img_num", "img_type", "img_ty", "mb_num", "mb_ty", "img_time", "mb_time"], "mb_y": ["MB_x", "mb_iy", "mb__iy", "mb__e", "mb_e", "mb__y", "mb__x", "MB_iy", "MB_e", "MB_y"], "mb_x": ["emb_y", "mb__ex", "mb__xy", "emb_xy", "emb_ex", "emb_x", "mb__y", "mb__x", "mb_xy", "mb_ex"]}}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "static av_cold int rl2_decode_init(AVCodecContext *avctx)\n\n{\n\n    Rl2Context *s = avctx->priv_data;\n\n    int back_size;\n\n    int i;\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    avcodec_get_frame_defaults(&s->frame);\n\n\n\n    /** parse extra data */\n\n    if(!avctx->extradata || avctx->extradata_size < EXTRADATA1_SIZE){\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid extradata size\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /** get frame_offset */\n\n    s->video_base = AV_RL16(&avctx->extradata[0]);\n\n    s->clr_count = AV_RL32(&avctx->extradata[2]);\n\n\n\n    if(s->video_base >= avctx->width * avctx->height){\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid video_base\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /** initialize palette */\n\n    for(i=0;i<AVPALETTE_COUNT;i++)\n\n        s->palette[i] = 0xFF << 24 | AV_RB24(&avctx->extradata[6 + i * 3]);\n\n\n\n    /** decode background frame if present */\n\n    back_size = avctx->extradata_size - EXTRADATA1_SIZE;\n\n\n\n    if(back_size > 0){\n\n        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);\n\n        if(!back_frame)\n\n            return -1;\n\n        rl2_rle_decode(s,avctx->extradata + EXTRADATA1_SIZE,back_size,\n\n                           back_frame,avctx->width,0);\n\n        s->back_frame = back_frame;\n\n    }\n\n    return 0;\n\n}\n", "idx": 14658, "substitutes": {"avctx": ["avtx", "vertx", "iverctx", "avercmd", "avercm", "navctx", "avetmp", "avercontext", "avereq", "avecpu", "ajcfg", " avcrit", "avpkg", "awcp", "afcmp", "avtmp", "abcontext", "camcmp", "vercontext", "afpkg", "devtx", "avcpu", "avertx", "avcc", "awcfg", "iverjp", " avcontext", " avcu", "avejp", "wavtx", "avcfg", "wavctx", "avcm", "aftmp", "avcmp", "navcu", "ovctx", "awctx", "avecc", "avercpu", "camcp", "savctx", "avecontext", " avconf", "aftx", "ajcu", " avcpu", "ajcp", "wavcu", "avetx", "devcc", "ajconf", "savcrit", "verctx", " avcmp", "ajtmp", "abctx", " avcfg", "avecm", " avcc", "avertmp", "devcontext", "cvcfg", "ajcmp", "avecfg", "cvctx", "savcfg", "averjp", "ajcpu", "campkg", "afjac", " avreq", "avcu", "avecu", " avconn", "awconn", "savcontext", "afcontext", "ajcontext", "afjp", "devctx", "ovtx", "ovcmd", "verjac", "avcp", "ajpkg", "avecp", "afctx", "avreq", "averctx", "ajjac", "avcmd", "avjp", "avconf", "wavconf", "ovcpu", "abpkg", "avconn", "camctx", "awcmp", "ajtx", "ajjp", "avercu", "avejac", "wavconfig", "afcfg", "ivercp", "avconfig", "avcrit", "wavreq", "avjac", " avpkg", "navjp", "wavcontext", "avcontext", "avepkg", "awpkg", "cvcontext", "ajcm", "ajctx", "ajconn", " avcmd", " avtx", "avercc", "navtmp", " avconfig", "avectx", "wavcfg", "ivercpu", "averconfig", "abcmp", "cvcrit", " avtmp", " avjp", "afconn", "averjac", "abtx", "abcc"], "s": ["aws", "ses", "gs", "S", "sw", "settings", "bs", "less", "ports", "j", "p", "js", "n", "sq", "conv", "v", "g", "ms", "sl", "details", "t", "is", "sv", "spec", "sb", "als", "hs", "ds", "ats", "ls", "r", "ess", "services", "ies", "qs", "gets", "ts", "self", "c", "stats", "vs", "ins", "sync", "b", "ns", "cs", "ops", "es", "ims", "h", "set", "rates", "changes", "fs", "ows", "os", "its", "se", "views", "scl", "ss", "x", "sc", "sts", "rs", "w", "ps"], "back_size": ["back64length", "back_small", " back_length", " back_mode", "back_max", " back_Size", "backnessmode", "back_length", "back64Size", "back_time", "back_count", "backed_size", " back_max", " back_count", "back64time", "backnesssize", "backed_small", "back_scale", "backnessscale", "backnesssmall", "back_Size", "back_mode", " back_space", "back_space", "backed_scale", "backed_mode", " back_time", "back64size"], "i": ["status", "key", "ij", "li", "ni", "o", "iu", "ii", " j", "I", "pi", "mi", "ini", "j", "ind", "ei", " di", "ki", "uri", "si", "n", "zi", " ti", "v", "cli", "g", "bi", "t", "ui", "di", "asi", " ii", "ai", "m", "in", "k", " I", "hi", "ix", "xi", "qi", " bi", "sim", "c", "ci", "b", "h", "id", "ti", "ri", "u", "multi", "gi", "it", "ji", "me", "q", "phi", "x", "y", "ic", "ico", "ip"], "back_frame": ["back_part", "back2part", "front_frame", " back_window", " back_word", "back____char", "back____frame", "back2zone", "back_sample", "front_sample", "BACK_part", "back____word", "back_word", "back_window", "backuffywindow", "back_shot", "backmyframe", "back_channel", " back_shot", "backmyerror", "back____shot", "BACK_frame", "backableframe", " back_char", "back2window", "back_error", "backpychannel", "back_row", "BACK_window", " back_next", "backablewindow", "back____window", "backuffypart", "backpyframe", "back_image", "backpysample", "front_channel", "back_next", "backmywindow", "back2frame", "front_image", "backuffyword", "back_zone", "backuffyrow", "backpyimage", "backableerror", "backmynext", "back____row", "backablenext", "backuffyzone", "backuffyframe", "BACK_zone", "back_char", " back_row", " back_error"]}}
{"project": "FFmpeg", "commit_id": "01a33b835f7a9e135eb8c7b7dd98c8b89f15dea1", "target": 1, "func": "static void picmemset(PicContext *s, AVFrame *frame, int value, int run,\n\n                      int *x, int *y, int *plane, int bits_per_plane)\n\n{\n\n    uint8_t *d;\n\n    int shift = *plane * bits_per_plane;\n\n    int mask  = ((1 << bits_per_plane) - 1) << shift;\n\n    value   <<= shift;\n\n\n\n    while (run > 0) {\n\n        int j;\n\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n\n            d = frame->data[0] + *y * frame->linesize[0];\n\n            d[*x] |= (value >> j) & mask;\n\n            *x += 1;\n\n            if (*x == s->width) {\n\n                *y -= 1;\n\n                *x = 0;\n\n                if (*y < 0) {\n\n                   *y = s->height - 1;\n\n                   *plane += 1;\n\n                   if (*plane >= s->nb_planes)\n\n                       return;\n\n                   value <<= bits_per_plane;\n\n                   mask  <<= bits_per_plane;\n\n                }\n\n            }\n\n        }\n\n        run--;\n\n    }\n\n}\n", "idx": 14665, "substitutes": {"s": ["ses", "gs", "S", "f", "less", "session", "ctx", "p", "js", "n", "scope", "sq", "v", "t", "comm", "is", "spec", "service", "sv", "space", "sys", "hs", "sb", "ds", "sf", "ls", "m", "r", "qs", "sim", "sc", "ts", "c", "ins", "ns", "b", "cs", "h", "ims", "ops", "es", "e", "fs", "conf", "os", "se", "fps", "i", "ss", "sts", "ms", "span", "rs", "ps"], "frame": ["profile", "view", "cf", "face", "type", "framework", "f", "object", "sequence", "window", "movie", "load", "picture", "t", "frames", "source", "video", "feature", "show", "ze", "line", "zone", "context", "rame", "word", "render", "stroke", "c", "image", "file", "one", "iframe", "slice", "fr", "set", "Frame", "point", "scene", "ace", "state", "ence", "process", "ce", "screen", "sample", "form"], "value": ["index", "key", "view", "distance", "version", "shift", "array", "position", "number", "size", "data", "values", "map", "p", "depth", "vp", "val", "v", "VALUE", "command", "m", "Value", "line", "memory", "message", "r", "time", "ue", "current", "buffer", "variable", "image", "function", "sample", "scale", "vector", "action", "set", "weight", "length", "total", "state", "name", "expression"], "run": ["thread", "index", "error", "record", "seq", "cmd", "n", "row", "fun", "call", "runs", "ran", "task", "try", "load", "batch", "len", "loop", "skip", "pass", "ur", "num", "job", "Run", "lock", "flow", "line", "r", "step", "range", "work", "count", "plot", "image", "un", "set", "ride", "order", "draw", "pair", "con", "length", "cycle", "z", "q", "une", "running", "name", "process"], "x": ["tx", "index", "path", "axis", "position", "wx", "ax", "size", "data", "l", "yx", "row", "p", "n", "mask", "ex", "depth", "X", "v", "xs", "height", "xy", "t", "ox", "offset", "m", "al", "line", "step", "xi", "dim", "dx", "image", "pos", "lat", "xx", "client", "color", "id", "point", "length", "px", "z", "q", "w", "i", "pan", "ix"], "y": ["yy", "key", "ty", "type", "yt", "a", "axis", "py", "o", "entity", "ny", "size", "ys", "p", "axy", "n", "sy", "row", "Y", "v", "height", "yz", "xy", "ya", "ay", "t", "try", "ye", "sys", "m", "cy", "vy", "iy", "ies", "c", "image", "iny", "base", "page", "rot", "lat", "b", "table", "hot", "start", "h", "my", "sky", "z", "gy", "ey", "i", "angle", "ch"], "plane": ["profile", "key", "goal", "type", "axis", "shift", "score", "late", "pen", "mask", "mode", "depth", "scope", "cone", "p", "lane", "half", "spin", "port", "pin", "mate", "offset", "cut", "flow", "line", "zone", "panel", "gate", "dim", "plan", "stroke", "layout", "cube", "board", "plot", "limit", "ane", "scale", "slice", "id", "flat", "piece", "se", "side", "planes", "angle", "pe", "pose"], "bits_per_plane": ["bits_per_frame", "bits_per_lane", "bits_per_factor", "bits_per67planes", "bits_PER_sequence", "bits_per___plan", "bits_per67plate", "bits_PER_lane", "bits_per_planes", "bits_PER_frame", "bits_per67sequence", "bits_per_depth", "bits_PER_panel", "bits_per67plane", "bits_per_plate", "bits_per_plan", "bits_per___plane", "bits_per___depth", "bits_PER_plate", "bits_PER_factor", "bits_PER_plan", "bits_per_sequence", "bits_PER_planes", "bits_per___planes", "bits_PER_plane", "bits_per_panel", "bits_PER_depth"], "d": ["dict", "f", "o", "data", "l", "p", "fd", "n", "dr", "D", "v", "dt", "dm", "g", "t", "di", "dc", "ds", "da", "m", "dd", "r", "bd", "dim", "c", "db", "b", "h", "ad", "u", "dh", "z", "q", "dat", "w", "i"], "j": ["ij", "jp", "at", "shift", "o", "out", "jit", " jump", "ind", "l", "aj", "js", "n", "p", "other", "bj", "v", "g", "el", "t", "uj", "job", "k", "m", "r", "obj", "json", "ja", "dj", "J", "oj", "jj", "b", "jump", "jo", "fr", "jl", "jc", "_", "ji", "it", "kj", "z", "q", "i", "ju", "ch"]}}
{"project": "FFmpeg", "commit_id": "f61d44b74aaae1d306d8a0d38b7b3d4292c89ced", "target": 0, "func": "static inline void silk_stabilize_lsf(int16_t nlsf[16], int order, const uint16_t min_delta[17])\n\n{\n\n    int pass, i;\n\n    for (pass = 0; pass < 20; pass++) {\n\n        int k, min_diff = 0;\n\n        for (i = 0; i < order+1; i++) {\n\n            int low  = i != 0     ? nlsf[i-1] : 0;\n\n            int high = i != order ? nlsf[i]   : 32768;\n\n            int diff = (high - low) - (min_delta[i]);\n\n\n\n            if (diff < min_diff) {\n\n                min_diff = diff;\n\n                k = i;\n\n\n\n                if (pass == 20)\n\n                    break;\n\n            }\n\n        }\n\n        if (min_diff == 0) /* no issues; stabilized */\n\n            return;\n\n\n\n        /* wiggle one or two LSFs */\n\n        if (k == 0) {\n\n            /* repel away from lower bound */\n\n            nlsf[0] = min_delta[0];\n\n        } else if (k == order) {\n\n            /* repel away from higher bound */\n\n            nlsf[order-1] = 32768 - min_delta[order];\n\n        } else {\n\n            /* repel away from current position */\n\n            int min_center = 0, max_center = 32768, center_val;\n\n\n\n            /* lower extent */\n\n            for (i = 0; i < k; i++)\n\n                min_center += min_delta[i];\n\n            min_center += min_delta[k] >> 1;\n\n\n\n            /* upper extent */\n\n            for (i = order; i > k; i--)\n\n                max_center -= min_delta[k];\n\n            max_center -= min_delta[k] >> 1;\n\n\n\n            /* move apart */\n\n            center_val = nlsf[k - 1] + nlsf[k];\n\n            center_val = (center_val >> 1) + (center_val & 1); // rounded divide by 2\n\n            center_val = FFMIN(max_center, FFMAX(min_center, center_val));\n\n\n\n            nlsf[k - 1] = center_val - (min_delta[k] >> 1);\n\n            nlsf[k]     = nlsf[k - 1] + min_delta[k];\n\n        }\n\n    }\n\n\n\n    /* resort to the fall-back method, the standard method for LSF stabilization */\n\n\n\n    /* sort; as the LSFs should be nearly sorted, use insertion sort */\n\n    for (i = 1; i < order; i++) {\n\n        int j, value = nlsf[i];\n\n        for (j = i - 1; j >= 0 && nlsf[j] > value; j--)\n\n            nlsf[j + 1] = nlsf[j];\n\n        nlsf[j + 1] = value;\n\n    }\n\n\n\n    /* push forwards to increase distance */\n\n    if (nlsf[0] < min_delta[0])\n\n        nlsf[0] = min_delta[0];\n\n    for (i = 1; i < order; i++)\n\n        if (nlsf[i] < nlsf[i - 1] + min_delta[i])\n\n            nlsf[i] = nlsf[i - 1] + min_delta[i];\n\n\n\n    /* push backwards to increase distance */\n\n    if (nlsf[order-1] > 32768 - min_delta[order])\n\n        nlsf[order-1] = 32768 - min_delta[order];\n\n    for (i = order-2; i >= 0; i--)\n\n        if (nlsf[i] > nlsf[i + 1] - min_delta[i+1])\n\n            nlsf[i] = nlsf[i + 1] - min_delta[i+1];\n\n\n\n    return;\n\n}\n", "idx": 14673, "substitutes": {"nlsf": ["ncsfe", " nlscf", "nlisfo", "nstsfr", "dnlsb", "nlsfd", "ynlsfi", "npilsfe", " nlsfd", "nelsfs", "nlsfs", "namesstssf", "nwsfe", "nLSfc", " nlsv", "nlsb", " ncsfo", "ynlasfi", " ncscf", "nselsb", "npilsv", "nslsf", "nailsv", "nLSfe", "nailsfe", "nLSv", "nLSif", "ngsfo", "nLSfl", "dnslfo", "nlisfac", "dnslf", "namesstsfr", " nLSfo", "nqsfl", "lllsv", " nlssf", "nistsf", "nistsfs", "ncsfl", "currentlsf", "nlcfs", "onlsf", "nlasif", "nameslssf", "ngssf", "nlcfm", "llselsb", "anlcfm", "nlasf", "dnlssf", "ncsscf", "nnssf", "nselsv", "nldcf", "nlsfac", "nlasfd", "nLSfd", "nlesfac", "nlesfi", "anlsb", "anlcfs", "nilssf", "nselsfi", "anlsf", "lllsfc", "dnlsfo", "nolscf", "nlasv", "norlesf", "nolsfd", "nLSfs", "ncsv", "ncsfd", "ngsb", "nselsfo", "nlasfr", " nlsfl", " nlsfe", "ncsb", "nailsfo", "norlesv", "ncsf", "norlesfd", "currentlsfd", " ncsf", "nameslsf", "ynlsv", "nolsfac", "nldf", "nselsfc", "ncsfo", " nLSsf", "nstsd", " nLSv", "ncssf", "nelsb", "nailsfd", "onlscf", "nlasfi", "onliscf", "dnlsf", "nailsfac", "nlsfr", "npilsf", "nameslsfr", "namesstsd", "nlsfc", "nqsf", "llselsfc", "currentlesfo", " nLSfe", "norlsf", "ynlsfs", "nselsf", "ynlasf", "nlinescf", "lllsb", "nlssf", "nolsf", "nlinesf", "dnslb", "nlasd", "nwsfd", "dnslsf", "npilssf", "ynlasfs", "nlcb", "ncssfe", "nlsd", "nlinesfo", "nlsfi", "nlscf", "norlsv", "norlsfd", "nameslsd", "currentlesf", "nlisf", "onlisf", "nlassf", "onlisfo", "nilsf", "nplsfe", "nipsf", "nLSf", "nailsf", " nlsb", "nwsv", "nilsfe", "nslfo", "nLSfo", "ncsfi", "ynlasv", "nlesv", "llselsv", "nolsfe", "nlsfe", "nipsd", "nstsf", "ncsfs", "nqsv", "ncssfo", "nistsv", "nlcf", "nlesfd", "nelsf", "lllsf", "nselsfd", "anlsfs", "nslb", "currentlsfo", "norlsif", " nlsfo", "nlesif", "ncscf", " ncsfl", "ynlsf", "nstssf", "nnsfo", "nlsfl", "nslf", "nlsv", "nolsfo", "nwsf", " nLSb", "nlsfo", "currentlesfd", "currentlsfi", "anlsfm", "nldfo", "nnsb", "nLSb", "nqsfo", "nplsf", " ncsv", " ncsfe", "nipsfr", "nLSfac", "nnsf", "norlesif", "ncsfm", "onlisfac", "nLSfi", " nLSf", "currentlesfi", "nLSsf", " nLSfd", "nplsv", "nplssf", "llselsf", "ncsfc", " nlsfac", "nlsfm", "namesstsf", "nlsif", "anlcf", "nilsv", "nailssf", "nlesf", "nistsfi", "onlsfo", "ngsf", "nldfac", "onlsfac", "nipssf", " nLSfac", "nolsv", "nelsfm", "nliscf", "nlesfo", "anlcb", "nlasfs", "nlinesfe"], "order": ["index", "key", "error", "sort", "type", "record", "score", "grade", "position", "number", "o", "size", "address", "random", "seed", "mode", "row", "depth", "sequence", "p", "ord", "radius", "n", "Order", "dir", "after", "v", "chain", "ORD", "before", "er", "rank", "end", "offset", "num", "orders", "r", "sk", "m", "off", "ator", "empty", "block", "count", "page", "code", "ice", "scale", "der", "ser", "master", "id", "here", "e", "iter", "ordered", "over", "max", "length", "edge", "err", "cycle", "q", "zero", "level", "ter", "ordering"], "min_delta": ["min_dimency", "min_pelta", "minolydants", "min_tota", "min_miffs", "min__dition", "min_siff", "min_Delta", "min_dota", "min_mta", "min_ddelta", "min2delta", "min_dtota", "min64delta", "minolydimelta", "min_selt", "min_relta", "min_cdval", "min_dler", "min_dictency", "min_tDelta", "min_tler", "min_dels", "min2lota", "min_fels", "min2lelta", "min_mandency", "min_develta", "min2dition", "min_ddynamic", "min_ddelt", "min_diffs", "min_idelta", "min_sdency", "min_lelta", "min_dtency", "minolydimency", "min_trection", "minolydelta", "min2dota", "min2dency", "min_mandition", "min64dictivot", "min_selta", "min_dta", "min_lta", "min64divot", "min_cdelt", "min_miff", "min_dval", "min_Diffs", "min_melta", "min_lota", "min_telta", "min_dtelt", "min_Dota", "min_Dler", "min_mency", "min__dota", "min_celta", "min__dant", "min_Diff", "min_dtition", "min_DDelta", "min_dimants", "minolydimants", "min_mval", "min_dants", "min_devler", "min_drection", "min_cota", "min_dictler", "min_dimelta", "min_dDelta", "min_dataelta", "min_tynamic", "min_sdants", "min_siffs", "min_dtval", "min64dler", "min_rota", "min_devivot", "min_dataelt", "min_felta", "min_lition", "min_devota", "min_dynamic", "min_rant", "min_cition", "min_dimchange", "min64dictelta", "minolydchange", "min__rota", "min_divot", "min_dchange", "min_delt", "min_ddrection", "min_melt", "min_sdchange", "min_dant", "min_Delt", "min__relta", "min_pels", "min_tivot", "min_dictivot", "min_datata", "min2lency", "min_lency", "min_mandota", "minolydimchange", "min_dtelta", "min64dictota", "min_rition", "min_dictota", "min_felt", "min_cdelta", "min_mandelta", "min_idota", "min__delta", "min_telt", "min_pelt", "min__rition", "min_dency", "min64dota", "min_sdelta", "min_dictants", "min_dictDelta", "min_dataota", "min_cant", "min_mota", "min_dition", "min_diff", "min_idant", "min__rant", "min_cdency", "min_idition", "min2lition", "min_lelt", "min64dictler", "minolydency", "min_dictchange", "min_dictelta"], "pass": ["jp", "key", "def", "status", "by", "sw", "push", "fast", "mode", "row", "p", "window", "miss", "fail", "task", "check", "g", "test", "chain", "try", "batch", "acc", "stop", "mix", "ass", "read", "port", "loop", "skip", "PASS", "scan", "op", "lock", "r", "step", "ask", "through", "hop", "add", "stage", "run", "loss", "post", "ack", "pg", "id", "feed", "strip", "ride", "gain", "col", "Pass", "prop", "pas", "commit", "level", "w", "sc", "process"], "i": ["index", "cli", "port", "t", "ami", "PI", "ai", "m", " I", "s", "xi", "qi", "iy", "ims", "it", "ji", "li", "by", "oi", "ind", "ki", "si", "zi", "v", "ori", "try", "g", "kit", "ui", "iii", "im", "print", "slice", "ti", "x", "ri", "ic", "ix", "ip", "ij", "f", "ii", "mi", "I", "pi", "this", "batch", "ik", "di", "in", "ie", "sim", "info", "progress", "ci", "id", "iter", "multi", "to", "me", "init", "status", "go", "iu", "o", "ini", "l", "ei", "p", "chain", "bi", "io", "is", "ia", "item", "hi", "\u0438", "iri", "e", "point", "list", "gi", "phi", "value", "name", "y"], "k": ["key", "kw", "type", "f", "go", "kn", "o", "kh", "uk", "km", "ok", "kid", "n", "p", "row", "ki", " K", "kk", "tk", "mk", "radius", "v", "chain", "g", "kit", "spec", "ik", "kind", "rank", "er", "ke", "ku", "isk", "kg", "K", "ek", "m", "kr", "ko", "r", "s", "ask", "ck", "work", "kan", "c", "ak", "block", "kick", "kar", "wk", "dk", "ack", "ks", "ijk", "max", "it", "length", "ikk", "kj", "q", "level", "x", "y", "ka", "sk"], "center_val": ["center_obj", "pixel_val", "enter_VAL", "area_val", "pixel_err", "centerableval", "area_pl", "center_el", "escape_doc", "max_VAL", "center___pl", "center___info", "areafulel", "centerfulpl", "areafulval", "center_vec", " center_value", "center2vals", "center_bal", " center_obj", "center_value", "centerfulel", "enter_col", "enter_value", "center7col", "max_val", "center___val", "center_info", "center7VAL", "pixel_bal", "centerfulinfo", "centerablesel", " center_valid", "center_vals", "center_mod", "center_VAL", "center2val", "centerablemod", "center_doc", "enter_val", "escape_mod", "max_value", "center7val", "center_lev", "escape_sel", "center_sel", "areafulpl", "centerabledoc", " center_lev", "center_valid", "center_pl", " center_vals", "center_col", "centerfulval", "area_info", "center_err", "escape_val", "areafulinfo", "center7value", "center2lev", "area_el", "center___el", " center_vec"], "j": ["ij", "jp", "key", "bs", "jit", "ind", "pr", "l", "aj", "js", "n", "jas", "bj", "v", "g", "try", "bi", " J", "uj", "bo", "item", "job", "br", "obj", "json", "ja", "dj", "J", "oj", "jj", "b", "jump", "jo", "fr", "jl", "jc", "max", "ji", "it", "kj", "z", "q", "value", "x", "y", "jac"]}}
{"project": "qemu", "commit_id": "2e29bd04786003561303dcad940b38afe790fb9b", "target": 1, "func": "static void pci_unin_main_config_writel (void *opaque, target_phys_addr_t addr,\n\n                                         uint32_t val)\n\n{\n\n    UNINState *s = opaque;\n\n\n\n    UNIN_DPRINTF(\"config_writel addr \" TARGET_FMT_plx \" val %x\\n\", addr, val);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n\n\n    s->config_reg = val;\n\n}\n", "idx": 14679, "substitutes": {"opaque": ["opient", " opatile", " opace", " Opca", " opaco", "iopaque", "obque", "iopaco", "opca", " opque", " Opaque", "iopca", "obatile", "opsaque", "opsatile", "iopient", "obace", "obaque", "opace", " opient", " Opaco", " opca", "opatile", "opaco", " Opient", "opsque", "opque", "opsace"], "addr": ["tx", "index", "at", "mem", "ptr", "src", "address", "attr", "cmd", "ctx", "hw", "ag", "tr", "dr", "ord", "adr", "loc", "now", "offset", "align", "eth", "alt", "obj", "add", "ac", "work", "pos", "coord", "rol", "id", "ad", "ace", "pad", "var", " address", "err", "x", "rs", "alloc", "Address"], "val": ["vol", "tx", "il", "index", " arg", "bit", " value", "Val", "resp", " Val", "mem", "ret", "serv", "ref", "out", "bool", "seq", "pr", "ctx", "p", "data", "pol", "stat", "v", "reg", "test", "pt", "sl", "oval", "sol", "len", "sv", "eval", "buf", "num", "al", "Value", "alt", "slot", "vals", " eval", "cal", "sel", "all", "pos", " v", "ival", "b", "res", "bl", "rol", "VAL", "arg", "AL", "it", "var", "bal", "z", "value", "vt", "x", "valid", "txt"], "s": ["ses", "gs", "a", "S", "settings", "o", "bs", "j", "flags", "n", "p", "sq", "v", "t", "sb", "sv", "hs", "ds", "checks", "m", "r", "qs", "ts", "c", "stats", "ns", "b", "ops", "h", "e", "fs", "os", "state", "ss", "i", "w", "sts", "sets", "rs", "ps"]}}
{"project": "qemu", "commit_id": "523b018dde3b7650fe5401d0499b30cf2f117515", "target": 1, "func": "vubr_set_vring_addr_exec(VubrDev *dev, VhostUserMsg *vmsg)\n{\n    struct vhost_vring_addr *vra = &vmsg->payload.addr;\n    unsigned int index = vra->index;\n    VubrVirtq *vq = &dev->vq[index];\n    DPRINT(\"vhost_vring_addr:\\n\");\n    DPRINT(\"    index:  %d\\n\", vra->index);\n    DPRINT(\"    flags:  %d\\n\", vra->flags);\n    DPRINT(\"    desc_user_addr:   0x%016llx\\n\", vra->desc_user_addr);\n    DPRINT(\"    used_user_addr:   0x%016llx\\n\", vra->used_user_addr);\n    DPRINT(\"    avail_user_addr:  0x%016llx\\n\", vra->avail_user_addr);\n    DPRINT(\"    log_guest_addr:   0x%016llx\\n\", vra->log_guest_addr);\n    vq->desc = (struct vring_desc *)(uintptr_t)qva_to_va(dev, vra->desc_user_addr);\n    vq->used = (struct vring_used *)(uintptr_t)qva_to_va(dev, vra->used_user_addr);\n    vq->avail = (struct vring_avail *)(uintptr_t)qva_to_va(dev, vra->avail_user_addr);\n    vq->log_guest_addr = vra->log_guest_addr;\n    DPRINT(\"Setting virtq addresses:\\n\");\n    DPRINT(\"    vring_desc  at %p\\n\", vq->desc);\n    DPRINT(\"    vring_used  at %p\\n\", vq->used);\n    DPRINT(\"    vring_avail at %p\\n\", vq->avail);\n    vq->last_used_index = vq->used->idx;\n    return 0;", "idx": 14680, "substitutes": {"vra": [" vRA", "vras", "vicra", "kra", "servara", "varra", "varara", "formrum", "formtra", "varran", "vera", "vicRA", "servri", "verou", "vri", "varrou", "varrap", "jran", "vran", " vran", "valara", "formra", "evra", "ivrera", "formara", "gara", "varrum", "verra", "gri", "invran", "graf", "gra", "invraf", "frou", " vtra", "farma", "nvara", "evras", "invras", "vro", "evraf", "fra", "servraf", "frum", "fran", "evrum", "jra", "verri", "gero", "varma", "vertra", "valtra", "nvra", "invra", "ftra", "vraf", "yra", "vrar", "vararma", "viara", "ivRA", "verrar", "vRA", "veara", "verum", "kara", "fraf", "krar", "servra", "nvrum", "valra", "jraf", " vara", " vro", "verara", "varrar", "gras", "ivra", "vicrum", "vara", " vraf", "vrou", " vrum", "invrum", "vrera", "verrum", "yara", "grar", "vrum", " vrap", "viraf", "nvrar", "verap", "evara", "verraf", "valro", "vicrera", "yero", "yrar", "virum", "jrum", "vrap", "vero", " vrera", "varero", "vira", "ivrum", "krum", "fara", "fro", "invara", " varma", "vtra"], "vq": ["varue", "vdq", "vmq", "volog", "variz", "vquery", " vqueue", "viz", "wqa", "vvq", "vviz", "tvqa", "svqu", "versionquant", "convp", "convkg", "conviq", "Vq", "uvf", "vque", "wq", "svq", "tvp", "vedq", "varquery", "vf", "voiz", "vql", "viewql", "vvdq", "veqa", "vqs", "varq", "lqa", "varque", "varqi", " viz", "convq", "requue", "uvog", "vvqi", " vue", "convqq", "vqa", "volf", " vquery", "invql", "viewqq", "liq", "vvque", "voq", " vqu", "tvkg", "invqq", "svqs", "varqu", "vkg", " vkg", "versionq", "varf", "veqi", "uvqi", "svqq", "vue", "svqueue", "inviz", "reququ", "lqq", "uvq", "svque", "vmquant", "vp", "Vqs", " vqa", "voque", "vqueue", "varqq", "requql", "wque", "vog", "svqa", "invq", "lq", "tvq", " viq", "vvcf", "versioniq", "vqq", "varog", "vecf", "veque", "veq", "invquery", " vquant", "vcf", "vqi", "wqu", "volqi", "vequ", "vmqu", "varqueue", "versionqu", "viewqueue", "viewq", " vql", "vodq", "vqu", "requq", "vmiq", "volq", " vp", "voqi", "Vqq", "invqueue", "vocf", "convqa", "Vqueue", "viq", "varql", "vquant", " vqq", "varqs"]}}
{"project": "FFmpeg", "commit_id": "e7843db3df0224cafcc1af9da103a3a7286ae2ba", "target": 1, "func": "void ff_get_unscaled_swscale(SwsContext *c)\n\n{\n\n    const enum PixelFormat srcFormat = c->srcFormat;\n\n    const enum PixelFormat dstFormat = c->dstFormat;\n\n    const int flags = c->flags;\n\n    const int dstH = c->dstH;\n\n    int needsDither;\n\n\n\n    needsDither = isAnyRGB(dstFormat) &&\n\n            c->dstFormatBpp < 24 &&\n\n           (c->dstFormatBpp < c->srcFormatBpp || (!isAnyRGB(srcFormat)));\n\n\n\n    /* yv12_to_nv12 */\n\n    if ((srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) &&\n\n        (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21)) {\n\n        c->swScale = planarToNv12Wrapper;\n\n    }\n\n    /* yuv2bgr */\n\n    if ((srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUV422P ||\n\n         srcFormat == PIX_FMT_YUVA420P) && isAnyRGB(dstFormat) &&\n\n        !(flags & SWS_ACCURATE_RND) && !(dstH & 1)) {\n\n        c->swScale = ff_yuv2rgb_get_func_ptr(c);\n\n    }\n\n\n\n    if (srcFormat == PIX_FMT_YUV410P &&\n\n        (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P) &&\n\n        !(flags & SWS_BITEXACT)) {\n\n        c->swScale = yvu9ToYv12Wrapper;\n\n    }\n\n\n\n    /* bgr24toYV12 */\n\n    if (srcFormat == PIX_FMT_BGR24 &&\n\n        (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P) &&\n\n        !(flags & SWS_ACCURATE_RND))\n\n        c->swScale = bgr24ToYv12Wrapper;\n\n\n\n    /* RGB/BGR -> RGB/BGR (no dither needed forms) */\n\n    if (   isAnyRGB(srcFormat)\n\n        && isAnyRGB(dstFormat)\n\n        && srcFormat != PIX_FMT_BGR8      && dstFormat != PIX_FMT_BGR8\n\n        && srcFormat != PIX_FMT_RGB8      && dstFormat != PIX_FMT_RGB8\n\n        && srcFormat != PIX_FMT_BGR4      && dstFormat != PIX_FMT_BGR4\n\n        && srcFormat != PIX_FMT_RGB4      && dstFormat != PIX_FMT_RGB4\n\n        && srcFormat != PIX_FMT_BGR4_BYTE && dstFormat != PIX_FMT_BGR4_BYTE\n\n        && srcFormat != PIX_FMT_RGB4_BYTE && dstFormat != PIX_FMT_RGB4_BYTE\n\n        && srcFormat != PIX_FMT_MONOBLACK && dstFormat != PIX_FMT_MONOBLACK\n\n        && srcFormat != PIX_FMT_MONOWHITE && dstFormat != PIX_FMT_MONOWHITE\n\n        && srcFormat != PIX_FMT_RGB48LE   && dstFormat != PIX_FMT_RGB48LE\n\n        && srcFormat != PIX_FMT_RGB48BE   && dstFormat != PIX_FMT_RGB48BE\n\n        && srcFormat != PIX_FMT_BGR48LE   && dstFormat != PIX_FMT_BGR48LE\n\n        && srcFormat != PIX_FMT_BGR48BE   && dstFormat != PIX_FMT_BGR48BE\n\n        && (!needsDither || (c->flags&(SWS_FAST_BILINEAR|SWS_POINT))))\n\n        c->swScale= rgbToRgbWrapper;\n\n\n\n    /* bswap 16 bits per pixel/component packed formats */\n\n    if (IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR444) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR48)  ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR555) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR565) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_GRAY16) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB444) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB48)  ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB555) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB565))\n\n        c->swScale = packed_16bpc_bswap;\n\n\n\n    if ((usePal(srcFormat) && (\n\n        dstFormat == PIX_FMT_RGB32   ||\n\n        dstFormat == PIX_FMT_RGB32_1 ||\n\n        dstFormat == PIX_FMT_RGB24   ||\n\n        dstFormat == PIX_FMT_BGR32   ||\n\n        dstFormat == PIX_FMT_BGR32_1 ||\n\n        dstFormat == PIX_FMT_BGR24)))\n\n        c->swScale = palToRgbWrapper;\n\n\n\n    if (srcFormat == PIX_FMT_YUV422P) {\n\n        if (dstFormat == PIX_FMT_YUYV422)\n\n            c->swScale = yuv422pToYuy2Wrapper;\n\n        else if (dstFormat == PIX_FMT_UYVY422)\n\n            c->swScale = yuv422pToUyvyWrapper;\n\n    }\n\n\n\n    /* LQ converters if -sws 0 or -sws 4*/\n\n    if (c->flags&(SWS_FAST_BILINEAR|SWS_POINT)) {\n\n        /* yv12_to_yuy2 */\n\n        if (srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) {\n\n            if (dstFormat == PIX_FMT_YUYV422)\n\n                c->swScale = planarToYuy2Wrapper;\n\n            else if (dstFormat == PIX_FMT_UYVY422)\n\n                c->swScale = planarToUyvyWrapper;\n\n        }\n\n    }\n\n    if (srcFormat == PIX_FMT_YUYV422 &&\n\n       (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P))\n\n        c->swScale = yuyvToYuv420Wrapper;\n\n    if (srcFormat == PIX_FMT_UYVY422 &&\n\n       (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P))\n\n        c->swScale = uyvyToYuv420Wrapper;\n\n    if (srcFormat == PIX_FMT_YUYV422 && dstFormat == PIX_FMT_YUV422P)\n\n        c->swScale = yuyvToYuv422Wrapper;\n\n    if (srcFormat == PIX_FMT_UYVY422 && dstFormat == PIX_FMT_YUV422P)\n\n        c->swScale = uyvyToYuv422Wrapper;\n\n\n\n    /* simple copy */\n\n    if ( srcFormat == dstFormat ||\n\n        (srcFormat == PIX_FMT_YUVA420P && dstFormat == PIX_FMT_YUV420P) ||\n\n        (srcFormat == PIX_FMT_YUV420P && dstFormat == PIX_FMT_YUVA420P) ||\n\n        (isPlanarYUV(srcFormat) && isGray(dstFormat)) ||\n\n        (isPlanarYUV(dstFormat) && isGray(srcFormat)) ||\n\n        (isGray(dstFormat) && isGray(srcFormat)) ||\n\n        (isPlanarYUV(srcFormat) && isPlanarYUV(dstFormat) &&\n\n         c->chrDstHSubSample == c->chrSrcHSubSample &&\n\n         c->chrDstVSubSample == c->chrSrcVSubSample &&\n\n         dstFormat != PIX_FMT_NV12 && dstFormat != PIX_FMT_NV21 &&\n\n         srcFormat != PIX_FMT_NV12 && srcFormat != PIX_FMT_NV21))\n\n    {\n\n        if (isPacked(c->srcFormat))\n\n            c->swScale = packedCopyWrapper;\n\n        else /* Planar YUV or gray */\n\n            c->swScale = planarCopyWrapper;\n\n    }\n\n\n\n    if (ARCH_BFIN)\n\n        ff_bfin_get_unscaled_swscale(c);\n\n    if (HAVE_ALTIVEC)\n\n        ff_swscale_get_unscaled_altivec(c);\n\n}\n", "idx": 14694, "substitutes": {"c": ["rc", "cu", "ce", "cf", "co", "tc", "cr", "f", "cm", "ca", "cn", "lc", "l", "ctx", "p", "n", "this", "call", "cmp", "cc", "conv", "v", "g", "t", "ic", "com", "dc", "cache", "ct", "cam", "cl", "s", "ac", "C", "self", "cv", "xc", "abc", "nc", "ci", "ec", "cp", "b", "mc", "cs", "bc", "gc", "etc", "pc", "fc", "set", "e", "con", "conf", "enc", "config", "err", "z", "vc", "w", "sc", "coll", "cont", "anc", "can"], "needsDither": [" needsDoot", "needsDecith", "needsDsither", " needsDot", "requiresDith", "needsdith", "needsduth", "needsDecot", " needsDoither", "requiresDuth", "needsdithering", "needsDsithering", "needsDouth", " needsDoithering", "requiresDoith", "requiresDither", "needsdurry", "needsDithering", "requiresDouth", "requiresDoither", "needsdither", "needsDurry", "needsDuth", "needsDsot", "needsDith", "needsDsurry", " needsDurry", "needsDot", "needsDourry", "needsDecuth", " needsDithering", " needsDourry", "needsdot", "needsDoot", "needsDecither", "requiresDot", "needsDoith", "needsDoithering", "needsDoither", "requiresDoot"]}}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br)\n\n{\n\n    PCIDevice *pd = PCI_DEVICE(br);\n\n    PCIBus *parent = pd->bus;\n\n    PCIBridgeWindows *w = g_new(PCIBridgeWindows, 1);\n\n    uint16_t cmd = pci_get_word(pd->config + PCI_COMMAND);\n\n\n\n    pci_bridge_init_alias(br, &w->alias_pref_mem,\n\n                          PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                          \"pci_bridge_pref_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &w->alias_mem,\n\n                          PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                          \"pci_bridge_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &w->alias_io,\n\n                          PCI_BASE_ADDRESS_SPACE_IO,\n\n                          \"pci_bridge_io\",\n\n                          &br->address_space_io,\n\n                          parent->address_space_io,\n\n                          cmd & PCI_COMMAND_IO);\n\n\n\n    pci_bridge_init_vga_aliases(br, parent, w->alias_vga);\n\n\n\n    return w;\n\n}\n", "idx": 14716, "substitutes": {"br": ["jp", "rem", "ij", "browser", "BR", "ba", "cr", "sw", "bs", "bro", "spr", "lr", "hr", "bre", "pr", "ren", "p", "mr", "tr", "vr", "dr", "ctx", "bh", "pm", "dp", "reg", "pt", "Br", "ctr", "adr", "band", "batch", "bt", "bo", "buf", "prot", "bart", "rb", "tree", "r", "kr", "bn", "bd", "bolt", "bridge", "ck", "bm", "sp", "block", "db", "art", "nah", "gr", "tw", "b", "gp", "bl", "bc", "ber", "wr", "fr", "rel", "it", "pas", "bal", "bp", "bg", "pl", "bor", "arr"], "pd": ["PD", "td", "dn", "pi", "pr", "pb", "cmd", "p", "pat", "dr", "dl", "xd", "pm", "cd", "dt", "dp", "pt", "md", "pp", "np", "ds", "dd", "ud", "phy", "bd", "dq", "hd", "lp", "ped", "po", "wd", "cp", "wp", "pc", "sd", "pid", "d", "dh", "vd", "bp", "tp", "ps"], "parent": ["pro", "def", "public", "by", "parents", "manager", "peer", "child", "Parent", "local", "global", "out", "per", "pr", "l", "associated", "p", "n", "owner", "params", "man", "rule", "foreign", "g", "pool", "pt", "port", "test", "t", "unit", "spec", "origin", "tree", "m", "holder", "part", "r", "k", "snap", "writer", "sp", "remote", "file", "mother", "event", "gr", "fat", "client", "master", "root", "h", "mt", "pid", "shape", "ma", "pa", "ch", "form", "ps"], "w": ["wine", "kw", "ww", "fw", "wh", "nw", "a", "sw", "rw", "wx", "aw", "p", "hw", "window", "wb", "n", "man", "wl", "v", "wal", "wo", "g", "wm", "wcs", "wa", "wt", "ow", "wn", "r", "ew", "writer", "word", "iw", "rh", "wk", "we", "wp", "tw", "W", "b", "wd", "wi", "h", "wr", "d", "win", "x", "i", "y", "wat"]}}
{"project": "FFmpeg", "commit_id": "e22ebd04bcab7f86548794556c28ecca46d9c2ac", "target": 0, "func": "static void hls_transform_tree(HEVCContext *s, int x0, int y0,\n\n                               int xBase, int yBase, int cb_xBase, int cb_yBase,\n\n                               int log2_cb_size, int log2_trafo_size,\n\n                               int trafo_depth, int blk_idx)\n\n{\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n    uint8_t split_transform_flag;\n\n\n\n    if (trafo_depth > 0 && log2_trafo_size == 2) {\n\n        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, yBase);\n\n        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) =\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, yBase);\n\n    } else {\n\n        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =\n\n        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) = 0;\n\n    }\n\n\n\n    if (lc->cu.intra_split_flag) {\n\n        if (trafo_depth == 1)\n\n            lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[blk_idx];\n\n    } else {\n\n        lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[0];\n\n    }\n\n\n\n    lc->tt.cbf_luma = 1;\n\n\n\n    lc->tt.inter_split_flag = s->sps->max_transform_hierarchy_depth_inter == 0 &&\n\n                              lc->cu.pred_mode == MODE_INTER &&\n\n                              lc->cu.part_mode != PART_2Nx2N &&\n\n                              trafo_depth == 0;\n\n\n\n    if (log2_trafo_size <= s->sps->log2_max_trafo_size &&\n\n        log2_trafo_size >  s->sps->log2_min_tb_size    &&\n\n        trafo_depth     < lc->cu.max_trafo_depth       &&\n\n        !(lc->cu.intra_split_flag && trafo_depth == 0)) {\n\n        split_transform_flag = ff_hevc_split_transform_flag_decode(s, log2_trafo_size);\n\n    } else {\n\n        split_transform_flag = log2_trafo_size > s->sps->log2_max_trafo_size ||\n\n                               (lc->cu.intra_split_flag && trafo_depth == 0) ||\n\n                               lc->tt.inter_split_flag;\n\n    }\n\n\n\n    if (log2_trafo_size > 2) {\n\n        if (trafo_depth == 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, yBase)) {\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =\n\n                ff_hevc_cbf_cb_cr_decode(s, trafo_depth);\n\n        }\n\n\n\n        if (trafo_depth == 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, yBase)) {\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) =\n\n                ff_hevc_cbf_cb_cr_decode(s, trafo_depth);\n\n        }\n\n    }\n\n\n\n    if (split_transform_flag) {\n\n        int x1 = x0 + ((1 << log2_trafo_size) >> 1);\n\n        int y1 = y0 + ((1 << log2_trafo_size) >> 1);\n\n\n\n        hls_transform_tree(s, x0, y0, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 0);\n\n        hls_transform_tree(s, x1, y0, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 1);\n\n        hls_transform_tree(s, x0, y1, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 2);\n\n        hls_transform_tree(s, x1, y1, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 3);\n\n    } else {\n\n        int min_tu_size      = 1 << s->sps->log2_min_tb_size;\n\n        int log2_min_tu_size = s->sps->log2_min_tb_size;\n\n        int min_tu_width     = s->sps->min_tb_width;\n\n\n\n        if (lc->cu.pred_mode == MODE_INTRA || trafo_depth != 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) ||\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0)) {\n\n            lc->tt.cbf_luma = ff_hevc_cbf_luma_decode(s, trafo_depth);\n\n        }\n\n\n\n        hls_transform_unit(s, x0, y0, xBase, yBase, cb_xBase, cb_yBase,\n\n                           log2_cb_size, log2_trafo_size, trafo_depth, blk_idx);\n\n\n\n        // TODO: store cbf_luma somewhere else\n\n        if (lc->tt.cbf_luma) {\n\n            int i, j;\n\n            for (i = 0; i < (1 << log2_trafo_size); i += min_tu_size)\n\n                for (j = 0; j < (1 << log2_trafo_size); j += min_tu_size) {\n\n                    int x_tu = (x0 + j) >> log2_min_tu_size;\n\n                    int y_tu = (y0 + i) >> log2_min_tu_size;\n\n                    s->cbf_luma[y_tu * min_tu_width + x_tu] = 1;\n\n                }\n\n        }\n\n        if (!s->sh.disable_deblocking_filter_flag) {\n\n            ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_trafo_size,\n\n                                                  lc->slice_or_tiles_up_boundary,\n\n                                                  lc->slice_or_tiles_left_boundary);\n\n            if (s->pps->transquant_bypass_enable_flag &&\n\n                lc->cu.cu_transquant_bypass_flag)\n\n                set_deblocking_bypass(s, x0, y0, log2_trafo_size);\n\n        }\n\n    }\n\n}\n", "idx": 14723, "substitutes": {"s": ["aws", "south", "gs", "a", "S", "sw", "o", "bs", "less", "l", "p", "n", "js", "sq", "v", "g", "t", "comm", "als", "sb", "sv", "spec", "hs", "sys", "ds", "ls", "ats", "m", "sa", "acs", "qs", "ts", "c", "ns", "ops", "cs", "h", "ims", "fs", "sg", "os", "its", "sts", "ss", "scl", "rs", "ps"], "x0": [" x10", "yRes", "exZero", "ixma", "xRes", "yZero", "xi30", "xi0", "ox1", "exBase", "xZero", " x1", "xiRaw", "ixE", "timema", "rx0", " xZero", "oxz", "ex1", "xma", " xma", "xiz", "ix0", "oxRes", "y1", "rx1", "rxBase", "ixZero", "oxZero", "ixz", "x30", "oxRaw", "xz", "ix30", "timeZero", "x1", "ox10", "xiE", "ex0", "xRaw", "ox30", "xi10", "time0", " xRaw", " xRes", "xE", "ox0", "rxZero", "oxE", "x10", "xiZero"], "y0": [" yZero", "yiInfo", "ymInfo", "yChan", "uyNo", "yi0", "ym0", "yiMac", "yZero", "axyRaw", "eryChan", "skyZero", "xZero", "skyStr", "yElement", "ny0", "gyZero", "yyBase", "nyZero", "ymKey", "uySource", "ery0", "ySource", "uyStr", "axyNo", "xStr", "sky0", "YZero", "ry0", "nyElement", "Y0", "ymMac", "nyNo", "Y1", "yy0", "y1", "nyChan", "yStr", "YBase", "ryMac", "eryElement", "ryKey", "uy0", "gyElement", "eryZero", "yNo", "gy0", "xChan", "skyChan", "yy1", "uyZero", "yInfo", "yiKey", "axySource", "yKey", "yRaw", "uyChan", "yMac", "axy0", "gyChan", "nySource", "nyRaw", "uyRaw", "yyZero", " y1", "ryInfo"], "xBase": ["oxBase", "xybase", " xBas", "oxFrame", "ox1", "exBase", "xFrame", " x1", "ix1", "xBottom", "ixBottom", "ex1", "yBottom", "ixbase", "ix0", "y1", "exCheck", " xCheck", " xbase", "oxCheck", "xbase", "ixBas", "xCheck", "x1", "ixBase", "xBas", "ixCheck", "xyBas", "xyBase", "exFrame", " xBottom", " xFrame", "xyCheck"], "yBase": ["cyBase", "nybase", "yyBas", " yRaw", "iyBound", "yBest", "eryBest", "ny0", "iyBase", "yyBase", "iyBas", "eyBasic", "eryBase", "cyBest", "nyBound", "ybase", "yBas", " ybase", "eryChain", "eryBasic", "nyBase", "yy0", "eyChain", "yBound", " yBas", "nyBas", "eyBase", "iybase", "cyChain", "yBasic", "eyBest", "yChain", "nyRaw", "cyBasic", "yRaw", "yyRaw", " yBound"], "cb_xBase": ["cb_ybase", "cb_y0", "cb_rxbase", "cb_rx0", "cb_rxFrame", "cb_yFrame", "cb_rxBase", "cb_xFrame", "cb_xbase", "cb_x0"], "cb_yBase": ["cb_ybase", "cb_xBas", "cb__YFace", "cb__Ybase", "cb_xFace", "cb_ryFace", "cb__YBas", "cb_YBas", "cb_Ybase", "cb_YFace", "cb_yFace", "cb_YBase", "cb_ryBas", "cb__yBase", "cb_xbase", "cb_ryBase", "cb__ybase", "cb__YBase", "cb__yBas", "cb__yFace", "cb_yBas", "cb_rybase"], "log2_cb_size": ["log2_cb_len", "log2_cb2SIZE", "log2_cb_SIZE", "log2_tc_length", "log2_tc_size", "log2_cb__SIZE", "log2_tc_len", "log2_tc_SIZE", "log2_cb2len", "log2_cb__size", "log2_cb_length", "log2_cb2length", "log2_cb2size", "log2_cb__length", "log2_cb__len"], "log2_trafo_size": ["log2_trainfo_name", "log2_trafo_name", "log2_traphy_SIZE", "log2_traphy_mode", "log2_trafo2length", "log2_trafo_depth", "log2_trafo2Size", "log2_trafo_length", "log2_trainfo_length", "log2_trafo_Size", "log2_trainfo_SIZE", "log2_trainfo2Size", "log2_traphy_Size", "log2_trafo_mode", "log2_trainfo_size", "log2_traphy_depth", "log2_trainfo2size", "log2_trainfo_Size", "log2_trafo2size", "log2_trafo_SIZE", "log2_traphy_size", "log2_trainfo2length"], "trafo_depth": ["traifest_priority", "tragoo_deep", "trafo2counter", "trainfo_total", "traifest_mode", "trainfo_depth", "trafo_status", "traphy_deep", "trainfo_scale", "traph_rank", "trafo_path", "trafo_deep", "trafo_height", "trafo8distance", "trafo2deep", "trainfo_rank", "trainfo_level", "trafo8deep", "tri_", "trafo2count", "traifest_deep", "trafo_rank", "trafo_total", "traifest_depth", "trafo0mode", "trafo_distance", "trafo_level", "trafo_counter", "tra_", "trainfo_height", "traphy_count", "traphy_depth", "trafo2depth", "trafo8total", "tragoo_path", "trafo8depth", "trainfo_deep", "trafo_count", "tr_", "trafo2dim", "trainfo_pillar", "trafo_dim", "traph_dim", "trainfo_result", "trafo_pillar", "traphy_rank", "trafo_priority", "traph_depth", "traph_deep", "trafo_mode", "traphy_path", "tragoo_depth", "trainfo_counter", "trafo0deep", "tragoo_total", "trafo2rank", "trafo0depth", "trafo0priority", "trafo_scale", "trainfo_distance", "trainfo_status", "traphy_dim", " tra_", "trafo_result"], "blk_idx": ["blk_ridy", "blk_inx", "blk_idb", "blk_idxc", "blk_idy", "blk_Idx", "blk_idv", "blk_ridv", "blk2Idxc", "blk_Idxc", "blk_Idv", "blk_Idy", "blk2idx", "blk_ridz", "blk_inz", "blk_ridxc", "blk2idy", "blk_ridx", "blk2Idy", "blk2idxc", "blk_inv", "blk2idb", "blk2Idx", "blk_Idz", "blk_Idb", "blk2Idb", "blk_idz", "blk_ridb", "blk_iny"], "lc": ["rc", "cu", "ctl", "ell", "cf", "tl", "unc", "tc", "court", "lf", "cm", "cus", "ll", "l", "ctx", "ln", "LC", "rl", "dl", "cc", "wl", "lib", "cli", "layer", "sl", "sol", "comm", "gl", "dc", "icc", "func", "cci", "ls", "cl", "cell", "lis", "ml", "lua", "lu", "lay", "c", "mm", "lp", "lic", "disc", "ci", "kl", "cp", "gc", "mc", "cs", "bc", "lv", "uci", "pc", "fc", "acl", "etc", "ctrl", "las", "vc", "scl", "gru", "coll", "WC", "lam"], "split_transform_flag": ["split_transform_lock", "split_transform_status", "split_transform_flags", "split_transform2flag", "split_scale_lock", "split_transform2status", "split_transform2lock", "split_scale_flag", "split_transform2flags", "split_scale_flags", "split_scale_status"]}}
{"project": "FFmpeg", "commit_id": "ba3f07d0611d9a6c10eaa90b3c058ecdffe76676", "target": 1, "func": "static void aw_pulse_set2(WMAVoiceContext *s, GetBitContext *gb,\n\n                          int block_idx, AMRFixed *fcb)\n\n{\n\n    uint16_t use_mask_mem[9]; // only 5 are used, rest is padding\n\n    uint16_t *use_mask = use_mask_mem + 2;\n\n    /* in this function, idx is the index in the 80-bit (+ padding) use_mask\n\n     * bit-array. Since use_mask consists of 16-bit values, the lower 4 bits\n\n     * of idx are the position of the bit within a particular item in the\n\n     * array (0 being the most significant bit, and 15 being the least\n\n     * significant bit), and the remainder (>> 4) is the index in the\n\n     * use_mask[]-array. This is faster and uses less memory than using a\n\n     * 80-byte/80-int array. */\n\n    int pulse_off = s->aw_first_pulse_off[block_idx],\n\n        pulse_start, n, idx, range, aidx, start_off = 0;\n\n\n\n    /* set offset of first pulse to within this block */\n\n    if (s->aw_n_pulses[block_idx] > 0)\n\n        while (pulse_off + s->aw_pulse_range < 1)\n\n            pulse_off += fcb->pitch_lag;\n\n\n\n    /* find range per pulse */\n\n    if (s->aw_n_pulses[0] > 0) {\n\n        if (block_idx == 0) {\n\n            range = 32;\n\n        } else /* block_idx = 1 */ {\n\n            range = 8;\n\n            if (s->aw_n_pulses[block_idx] > 0)\n\n                pulse_off = s->aw_next_pulse_off_cache;\n\n        }\n\n    } else\n\n        range = 16;\n\n    pulse_start = s->aw_n_pulses[block_idx] > 0 ? pulse_off - range / 2 : 0;\n\n\n\n    /* aw_pulse_set1() already applies pulses around pulse_off (to be exactly,\n\n     * in the range of [pulse_off, pulse_off + s->aw_pulse_range], and thus\n\n     * we exclude that range from being pulsed again in this function. */\n\n    memset(&use_mask[-2], 0, 2 * sizeof(use_mask[0]));\n\n    memset( use_mask,   -1, 5 * sizeof(use_mask[0]));\n\n    memset(&use_mask[5], 0, 2 * sizeof(use_mask[0]));\n\n    if (s->aw_n_pulses[block_idx] > 0)\n\n        for (idx = pulse_off; idx < MAX_FRAMESIZE / 2; idx += fcb->pitch_lag) {\n\n            int excl_range         = s->aw_pulse_range; // always 16 or 24\n\n            uint16_t *use_mask_ptr = &use_mask[idx >> 4];\n\n            int first_sh           = 16 - (idx & 15);\n\n            *use_mask_ptr++       &= 0xFFFF << first_sh;\n\n            excl_range            -= first_sh;\n\n            if (excl_range >= 16) {\n\n                *use_mask_ptr++    = 0;\n\n                *use_mask_ptr     &= 0xFFFF >> (excl_range - 16);\n\n            } else\n\n                *use_mask_ptr     &= 0xFFFF >> excl_range;\n\n        }\n\n\n\n    /* find the 'aidx'th offset that is not excluded */\n\n    aidx = get_bits(gb, s->aw_n_pulses[0] > 0 ? 5 - 2 * block_idx : 4);\n\n    for (n = 0; n <= aidx; pulse_start++) {\n\n        for (idx = pulse_start; idx < 0; idx += fcb->pitch_lag) ;\n\n        if (idx >= MAX_FRAMESIZE / 2) { // find from zero\n\n            if (use_mask[0])      idx = 0x0F;\n\n            else if (use_mask[1]) idx = 0x1F;\n\n            else if (use_mask[2]) idx = 0x2F;\n\n            else if (use_mask[3]) idx = 0x3F;\n\n            else if (use_mask[4]) idx = 0x4F;\n\n            else                  return;\n\n            idx -= av_log2_16bit(use_mask[idx >> 4]);\n\n        }\n\n        if (use_mask[idx >> 4] & (0x8000 >> (idx & 15))) {\n\n            use_mask[idx >> 4] &= ~(0x8000 >> (idx & 15));\n\n            n++;\n\n            start_off = idx;\n\n        }\n\n    }\n\n\n\n    fcb->x[fcb->n] = start_off;\n\n    fcb->y[fcb->n] = get_bits1(gb) ? -1.0 : 1.0;\n\n    fcb->n++;\n\n\n\n    /* set offset for next block, relative to start of that block */\n\n    n = (MAX_FRAMESIZE / 2 - start_off) % fcb->pitch_lag;\n\n    s->aw_next_pulse_off_cache = n ? fcb->pitch_lag - n : 0;\n\n}\n", "idx": 14741, "substitutes": {"s": ["sis", "ses", "gs", "S", "settings", "bs", "series", "sq", "plays", "sl", "sam", "m", "ssl", "qs", "shared", "stats", "cs", "ims", "sg", "aunts", "its", "ps", "sw", "js", "resource", "v", "comm", "spec", "ds", "sf", "sa", "so", "sync", "args", "set", "conf", "locks", "parts", "scl", "x", "history", "south", "a", "as", "less", "store", "sm", "sb", "hs", "sys", "c", "ops", "es", "changes", "se", "sports", "ss", "aws", "local", "p", "details", "is", "sv", "ls", "ts", "ns", "b", "h", "e", "os", "w", "sts", "ms", "rs"], "gb": ["gs", "uk", "hw", "g", "buff", "rb", "gd", "kb", " rgb", "bd", "bridge", "buffer", "bm", "cb", "db", "image", "bf", "gc", "rg", "gm", "eg", "sg", "nb", "mb", "uf", "bb", "ram", "bg", "RGB"], "block_idx": ["block_ixc", "block_indexx", "block2indxs", "block_ix", "block_dixa", "block0idxf", "block2indx", "block_identth", "block_idsxc", "block_namexf", "block_itxc", "block_locxa", "blockingidxes", "block_indxf", "block0identxf", "blockOidy", "block_idy", "block_indexno", "block_idex", "blockingdix", "block2idxf", "block_idsxes", "block_Idv", "block_locxf", "blockingidxc", "block2idx", "block0identx", "block_idsxf", "block_idxc", "block0idx", "block_dixc", "block_namect", "block_indy", "block_dixf", "block_itxa", "blockOidxc", "block_indxs", "block_idexs", "block_identct", "block_indv", "block_ixes", "block_Idxf", "block_idno", "block_idexf", "block_locx", "block_idsx", "block_idth", "block0idct", "block_nameth", "block2idy", "block_indz", "block_Idy", "block_idct", "block_idv", "blockOixc", "block_Idxs", "blockOidx", "blockOixes", "block_itxf", "blockingdixes", "block_idez", "block_indl", "block_indexv", "block_Idl", "block_idxes", "block_Idxes", "blockingidx", "blockOix", "block_locxes", "blockOidxes", "block_Idz", "block_Idno", "block_idey", "block_dix", "block2idxs", "block_idel", "block_idl", "block_identxf", "block_Idxc", "block_idxf", "block_idxa", "block_itxes", "block_idz", "block_identx", "block_idev", "block_itx", "block2indy", "block_indx", "block_dixes", "block_iy", "blockingdixf", "block0identth", "block0identct", "block0idth", "blockingidxf", "blockOiy", "block_Idx", "block_ity", "block_namex", "block_indexy", "blockingdixc", "block_idxs", "block2indxf"], "fcb": ["cfd", "pca", "ricb", "racbf", "fcpb", "cfbd", "ecpb", "fcbd", "racb", "FCsb", "acnb", "eca", "aca", "acbf", "cfa", "pcb", "acsb", "acd", "fcd", "fcbf", "FCa", "racsb", "acpb", "ricd", "FCb", "pcnb", "ricbd", "ecnb", "raca", "acb", "ecb", "fca", "pcpb", "acbd", "rica", "fcnb", "cfb", "FCbf", "fcsb"], "use_mask_mem": ["use_map_mem", "use_mask2cap", "use_mask2max", "use_mask_max", "use_map_max", "use_mask_map", "use_map_ptr", "use_map2max", "use_mask2mem", "use_flag_memory", "use_mask_cap", "use_mask_memory", "use_flag_map", "use_flag_mem", "use_mask2ptr", "use_map2mem", "use_map_cap", "use_map2cap", "use_map2ptr"], "use_mask": [" use_pack", "uselymap", "use_block", "uselyquery", "use_map", "used_mask", "usellweight", "used2map", " use_mark", "uselypack", " use_block", "use_pack", "uselymark", " use_code", "usexmask", "user_shadow", "used_weight", "use_flags", "use2weight", "usellmap", "used_map", "share_map", "use64mark", "use64shadow", "use_query", "use_weight", "user_map", "share_flags", "used2weight", "use64mask", " use_tag", "use_scale", "use64map", " use_query", "uselyweight", "used2hash", "use_tag", "used2mask", "use2hash", "use64scale", "use64query", "use_box", "use2mask", "use_flag", "use2map", "use_code", "user_scale", "share_comment", "use_shadow", "usellhash", " use_map", "usexmap", "use_mark", "usellmask", "used_hash", "share_mask", "use_hash", "use_comment", " use_weight", " use_match", " use_box", "uselymask", "use_match", "user_mask", "usextag", "usexcode", " use_flag"], "pulse_start": ["pulse_end", "pulse_step", "puls_start", "pulse_down", "pulse_int", "pue_start", "pue_int", "pulse_off", "puls_step", "puls_down", "puls_end", "pue_off", "pue_end"], "n": ["ni", "o", "l", "j", "p", "v", "g", "len", "np", "num", "nr", "nt", "k", "m", "N", "r", "c", "ns", "nn", "nb", "ne", "z", "q", "w", "nm", "i", "nu", "na"], "idx": ["bidx", "idxf", "index", "kidex", "midex", "IDn", "IDx", " idz", "piddx", "indxes", "midix", "pidz", "indix", " idi", " idy", " idn", "indy", "idz", "pidxf", "kiddx", "iddx", "idxi", "midxi", " idxc", "pidx", "kidx", "IDxi", " idex", "indx", "pidix", "idxc", "IDix", " idix", "bidi", "midx", "idxes", "bidix", " idxi", "kidxc", "bidex", " idxf", "pidxc", "midn", "idy", "indi", "indz", "Idx", "Idix", "pidy", "kidix", "Idy", "idix", "midxes", "idi", "idex", "kidxes", "kidy", "idn", " iddx", "kidxf"], "range": ["index", "view", "error", "distance", "type", "route", "array", "ref", "handle", "size", "family", "scope", "row", "sequence", "radius", "timeout", "window", "call", "share", "resource", "chain", "ge", "domain", "result", "diff", "offset", "num", "align", "spread", "ANGE", "zone", "flow", "r", "rest", "lag", "ange", "resolution", "prefix", "sum", "count", "change", "base", "remote", "limit", "Range", "scale", "rang", "slice", "binary", "set", "area", "angle", "trace", "conf", "max", "length", "edge", "from", "ne", "value", "bound", "interface", "network", "span", "history", "form"], "aidx": ["indx", "edy", "indy", "index", "edi", "aidy", "aidex", "idi", "edx", "idex", "edex", "aidi", "idy", "indi"], "use_mask_ptr": ["use_map__Ptr", "use_mask_Ptr", "use_mask_pointer", "use_map_addr", "use_mask__addr", "use_map__pointer", "use_mask__rel", "use_map_pointers", "use_map_ptr", "use_map__addr", "use_map_Ptr", "use_mask__pointer", "use_mask__Ptr", "use_mask_addr", "use_mask_rel", "use_mask__ptr", "use_map_pointer", "use_map_rel", "use_mask_pointers", "use_map__ptr"]}}
{"project": "FFmpeg", "commit_id": "0ebb523f072322972ea446616676fff32e9603c6", "target": 1, "func": "static void asf_build_simple_index(AVFormatContext *s, int stream_index)\n\n{\n\n    ff_asf_guid g;\n\n    ASFContext *asf     = s->priv_data;\n\n    int64_t current_pos = avio_tell(s->pb);\n\n    int i;\n\n\n\n    avio_seek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET);\n\n    ff_get_guid(s->pb, &g);\n\n\n\n    /* the data object can be followed by other top-level objects,\n\n     * skip them until the simple index object is reached */\n\n    while (ff_guidcmp(&g, &index_guid)) {\n\n        int64_t gsize = avio_rl64(s->pb);\n\n        if (gsize < 24 || s->pb->eof_reached) {\n\n            avio_seek(s->pb, current_pos, SEEK_SET);\n\n            return;\n\n        }\n\n        avio_skip(s->pb, gsize - 24);\n\n        ff_get_guid(s->pb, &g);\n\n    }\n\n\n\n    {\n\n        int64_t itime, last_pos = -1;\n\n        int pct, ict;\n\n        int64_t av_unused gsize = avio_rl64(s->pb);\n\n        ff_get_guid(s->pb, &g);\n\n        itime = avio_rl64(s->pb);\n\n        pct   = avio_rl32(s->pb);\n\n        ict   = avio_rl32(s->pb);\n\n        av_log(s, AV_LOG_DEBUG,\n\n               \"itime:0x%\"PRIx64\", pct:%d, ict:%d\\n\", itime, pct, ict);\n\n\n\n        for (i = 0; i < ict; i++) {\n\n            int pktnum        = avio_rl32(s->pb);\n\n            int pktct         = avio_rl16(s->pb);\n\n            int64_t pos       = s->data_offset + s->packet_size * (int64_t)pktnum;\n\n            int64_t index_pts = FFMAX(av_rescale(itime, i, 10000) - asf->hdr.preroll, 0);\n\n\n\n            if (pos != last_pos) {\n\n                av_log(s, AV_LOG_DEBUG, \"pktnum:%d, pktct:%d  pts: %\"PRId64\"\\n\",\n\n                       pktnum, pktct, index_pts);\n\n                av_add_index_entry(s->streams[stream_index], pos, index_pts,\n\n                                   s->packet_size, 0, AVINDEX_KEYFRAME);\n\n                last_pos = pos;\n\n            }\n\n        }\n\n        asf->index_read = ict > 0;\n\n    }\n\n    avio_seek(s->pb, current_pos, SEEK_SET);\n\n}\n", "idx": 14745, "substitutes": {"s": ["ses", "gs", "S", "bs", "ties", "ports", "sq", "sam", "t", "m", "qs", "stats", "vs", "cs", "ims", "its", "us", "https", "ps", "sw", "j", "n", "js", "params", "v", "http", "comm", "spec", "ds", "ats", "ies", "set", "conf", "ers", "scl", "ex", "x", "an", "south", "a", "f", "as", "less", "als", "sb", "hs", "sys", "erences", "c", "ares", "es", "events", "fs", "changes", "bis", "se", "sports", "ss", "sql", "aws", "serv", "p", "details", "is", "sv", "ls", "ches", "ts", "ins", "ns", "b", "h", "e", "os", "z", "sts", "ms", "rs"], "stream_index": [" stream_id", "stream_seek", " stream_seek", "stream_pos", " stream_pos", "stream_id"], "g": ["gs", "G", "tg", "f", "go", "gg", "gent", "global", " eg", "j", "ag", " gp", "group", "v", "ga", "gu", "ig", "reg", "ge", "t", "gen", "msg", "gb", "m", " msg", "cfg", "gt", "gate", "gd", "fg", "gn", "guard", "c", "erg", "gr", "gc", "rg", "gp", "gm", "b", "h", " mg", "pg", "eg", "sg", "gain", "gi", "bg"], "asf": ["rasv", "msp", "Asc", " asc", "asfe", "asfo", "Asv", "rasf", "aresc", "Asp", "Asfe", "rasc", "aresfe", "aresfo", "rasfo", "msfo", " asv", "Asfo", "msv", "aresf", "msc", "asp", " asfo", "Asf", "asv", " asfe", " asp", "msf", "asc"], "i": ["index", " it", "cli", "t", " pi", "ami", "ai", "m", " I", "xi", "qi", " v", "it", " e", "li", "oi", "ind", "j", "ki", "n", "si", "zi", " out", " ti", "v", "ui", " pos", "iq", " k", " index", "iii", " bi", "im", "pos", "ti", "x", "ic", "ix", "ip", "ij", "f", "ii", "mi", "I", "pi", "di", " ii", "in", "sim", "c", " l", "ci", "id", "u", " x", "multi", " err", "iu", " j", "ini", "l", "ei", "p", "is", "asi", " start", "hi", "\u0438", "gi", " p", " m", "phi", "y"], "itime": ["udi", "phis", "imet", "ime", "position", "mine", "mi", "pi", "size", "ist", "iam", "pir", "hip", "isd", "timeout", "ila", "oni", "mph", "mint", "him", "uti", "port", "irin", "ih", "ia", "is", "mid", "loc", "delay", "his", "\u00ee", "income", "hi", "time", "minute", "iti", "iman", "info", "im", "imp", "rice", "mit", "import", "wi", "met", "meet", "communication", "ici", "mt", "ti", "iter", "consider", "it", "length", "mie", "phi", "idi", "tim", "tp", "ms", "fine", "iat", "ip"], "pct": ["opCT", "phpct", "phpCT", "prct", " pact", " pCT", "Pkl", "prw", "Pact", "opct", "opact", " pw", "PCT", "pact", "phpact", "pw", " pkt", "Pct", "pkt", "pkl", "Pw", "pCT", "phpkl", "opkt", " pkl", "prCT", "Pkt"], "ict": ["wine", "ont", "adi", "dict", "virt", "tc", "et", "oc", "adic", "ist", "tt", "tif", "mint", "dt", "ICT", "icit", "pd", "ent", "pt", "chest", "iq", "cot", "di", "rict", "dc", "vid", "ds", "ct", "nt", "act", "ota", "ich", "iet", "dd", "qa", "dds", "ient", "tower", "ec", "ffff", "tz", "ht", "nic", "iat", "anta", "assad", "uct", "ot", "it", "elt", "qt", "icts", "iction", "tier", "ic", "voc"]}}
{"project": "qemu", "commit_id": "1f3ddfcb258e6e0562467a9644daad3f28597da8", "target": 1, "func": "static void bdrv_qed_drain(BlockDriverState *bs)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n\n\n    /* Cancel timer and start doing I/O that were meant to happen as if it\n\n     * fired, that way we get bdrv_drain() taking care of the ongoing requests\n\n     * correctly. */\n\n    qed_cancel_need_check_timer(s);\n\n    qed_plug_allocating_write_reqs(s);\n\n    bdrv_aio_flush(s->bs, qed_clear_need_check, s);\n\n}\n", "idx": 14750, "substitutes": {"bs": ["gs", "ubs", "aos", "obs", "js", "bits", "bh", "bes", "als", "sb", "is", "aus", "hs", "cks", "ds", "ls", "ats", "iss", "aps", "asis", "acs", "BS", "qs", "ts", "bos", "bm", "bas", "vs", "b", "ns", "cs", "bc", "lbs", "es", "fs", "ks", "bis", "bing", "its", "bb", "bp", "ss", "ps"], "s": ["ses", "gs", "a", "S", "as", "less", "j", "n", "js", "p", "sq", "v", "g", "sl", "ar", "t", "us", "comm", "is", "sv", "sys", "hs", "ds", "ls", "ats", "m", "sa", "iss", "r", "ess", "qs", "ts", "c", " ss", "ins", "ns", "b", "cs", "an", "es", "ims", "h", "its", "z", "q", "ss", "sts", "i", "y", "w", "rs", "ps"]}}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtol_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtol(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 14774, "substitutes": {"str": ["Str", "stable", "f", "ptr", "out", "cur", "seq", "data", "pr", "ind", "p", "tr", "ocr", "text", "chain", "g", "ctr", "t", "source", "len", "spec", "st", "msg", "end", "buf", "br", "r", "s", "doc", "buffer", "sp", "stri", "pos", "gr", "res", "b", "print", "shr", "input", "fr", "STR", "inner", "list", "i", "txt", "arr"], "endptr": ["ndptr", "endedPtr", " endpad", "endedaddr", "endstr", "ENDpointer", "endedpad", "endrect", "startptr", " endstr", " endpointer", "ndPtr", "ENDptr", "endedrect", "startpad", " endPtr", "endedobj", "endedptr", "endpad", "ENDrect", "endingpointer", "ndobj", "endingrect", "ENDPtr", " endaddr", "endingPtr", "endPtr", "endpointer", "endaddr", "endedstr", "endobj", " endobj", "ndaddr", "startpointer", "endedpointer", "endingptr", "startstr"], "err": ["resp", "erm", "errors", "rc", "error", " gr", "cr", "ptr", "erer", "out", "exc", " e", " typ", "usr", " ptr", " cr", "pr", "attr", " error", " Err", "tr", "dr", "ocr", "ind", " fr", "viol", "ctr", "cer", "er", "msg", "result", " terr", "nr", "br", "Error", "r", "kr", "obj", " dr", " resp", " i", " dist", "gr", "res", " er", "der", "die", "Er", " res", "fr", "urg", "order", " len", "iter", " rc", "it", " r", " result", "i", "rr", "resh", "ch", "arr"]}}
{"project": "qemu", "commit_id": "340849a9ff2a246bbc9a2da3f079c9fdbd2d5852", "target": 1, "func": "static int check_bind(const char *hostname, bool *has_proto)\n\n{\n\n    int fd = -1;\n\n    struct addrinfo ai, *res = NULL;\n\n    int rc;\n\n    int ret = -1;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;\n\n    ai.ai_family = AF_UNSPEC;\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    /* lookup */\n\n    rc = getaddrinfo(hostname, NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        if (rc == EAI_ADDRFAMILY ||\n\n            rc == EAI_FAMILY) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    fd = qemu_socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n    if (fd < 0) {\n\n        goto cleanup;\n\n    }\n\n\n\n    if (bind(fd, res->ai_addr, res->ai_addrlen) < 0) {\n\n        if (errno == EADDRNOTAVAIL) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    *has_proto = true;\n\n done:\n\n    ret = 0;\n\n\n\n cleanup:\n\n    if (fd != -1) {\n\n        close(fd);\n\n    }\n\n    if (res) {\n\n        freeaddrinfo(res);\n\n    }\n\n    return ret;\n\n}\n", "idx": 14775, "substitutes": {"hostname": ["HostNAME", "Hostnames", "domainame", "Hoststring", "bindname", "bindame", "hostnames", "domainname", " hostName", "handname", "domainName", "HostName", "domainstring", "Hostname", "hostName", "hostNAME", " hostNAME", "handnames", "handNAME", "Hostame", " hostnames", "handName", "bindName", "bindstring", "hostame", "hoststring"], "has_proto": ["has_Proocol", "has_colfo", "has_PROocol", "has_propocol", "has_Propo", "has_protfo", "has_propTo", "has_proocol", "has_phyocol", "has_protserver", "has_PRObo", "has_PROpo", "has_propto", "has_phypo", "has_colto", "has_phyto", "has_proTo", "has_colocol", "has_pbocol", "has_probo", "has_proserver", "has_phybo", "has_pbserver", "has_propserver", "has_Profo", "has_Proto", "has_profo", "has_ProTo", "has_protTo", "has_protto", "has_propo", "has_PROto", "has_colTo", "has_pbto", "has_protocol", "has_Probo"], "ai": ["aa", "aim", "aaa", " di", " ha", " na", "ay", "ass", "ami", "acs", " ca", "aci", "ape", " an", " ma", "ka", "ait", "ae", "am", " av", " au", "aka", "ki", "ali", " ay", "ar", "ui", " wa", "sa", "oa", "ais", " bi", "api", " acc", "air", " da", "ti", "hai", "i", " af", " ali", "pa", "an", "a", "mi", "ii", "aj", "auth", "aki", "aus", " a", " mi", "pai", "ci", "ati", " sa", "ao", "iat", "cu", " pri", "au", " aux", " ah", "iam", "ei", "aq", "arm", "bi", "io", "ia", "asi", "aut", "hi", "AI", "ap", "rob", " ac", " pa"], "res": ["ress", "conn", "bs", "pres", "ctx", "RES", "mr", "expr", "raw", "vers", "rm", "result", "rev", "gr", "der", "ser", "nil", "rez", "usr", "ps", "rem", "des", "mem", "ret", "addr", "js", "resource", "reset", "sol", "aux", "inv", "cons", "ber", "i", "ex", "resources", "full", "ri", "results", "complete", "resp", "out", "req", "sys", "rest", "json", "vals", "progress", "remote", "rek", "ras", "err", "serv", "has", "rss", "ok", "response", "reg", "details", "ires", "desc", "r", "rt", "ins", "Res", "re", "rec", "os", "pas", "rx", "init", "ms", "rs"], "rc": ["isc", "cor", "co", "cr", "tc", "ret", "src", "cur", "lc", "addr", "row", "round", "RC", "cmp", "cc", "cd", "ror", "rr", "ctr", "len", "loc", "priv", "sec", "dc", "nz", "nr", "desc", "r", "rect", "rt", "ck", "roc", "rev", "cb", "c", "ro", "rh", "nc", "ec", "ry", "gc", "comp", "cs", "bc", "pc", "rec", "fc", "cont", "rd", "err", "rx", "coll", "arc", "sc", "rn", "ce", "rs"]}}
{"project": "qemu", "commit_id": "684e508c23d28af8d6ed2c62738a0f60447c8274", "target": 1, "func": "static bool run_poll_handlers(AioContext *ctx, int64_t max_ns)\n\n{\n\n    bool progress = false;\n\n    int64_t end_time;\n\n\n\n    assert(ctx->notify_me);\n\n    assert(ctx->walking_handlers > 0);\n\n    assert(ctx->poll_disable_cnt == 0);\n\n\n\n    trace_run_poll_handlers_begin(ctx, max_ns);\n\n\n\n    end_time = qemu_clock_get_ns(QEMU_CLOCK_REALTIME) + max_ns;\n\n\n\n    do {\n\n        AioHandler *node;\n\n\n\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n            if (!node->deleted && node->io_poll &&\n\n                node->io_poll(node->opaque)) {\n\n                progress = true;\n\n            }\n\n\n\n            /* Caller handles freeing deleted nodes.  Don't do it here. */\n\n        }\n\n    } while (!progress && qemu_clock_get_ns(QEMU_CLOCK_REALTIME) < end_time);\n\n\n\n    trace_run_poll_handlers_end(ctx, progress);\n\n\n\n    return progress;\n\n}\n", "idx": 14777, "substitutes": {"ctx": ["tx", "jp", "kw", "ctl", "cf", "co", "tc", "conn", "wx", "cm", "setup", "addr", "cmd", "hw", "crit", "cmp", "kt", "timeout", "cc", "req", "mk", "cas", "xs", "pool", "xy", "ctr", "comm", "loc", "wcs", "sys", "np", "ct", "act", "cfg", "context", "obj", "aux", "prefix", "ck", "work", "c", "cb", "cv", "xc", "txt", "kl", "wd", "cp", "course", "gc", "bc", "tz", "etc", "tmp", "conf", "qt", "tm", "pkg", "ca", "anc", "iat", "jac"], "max_ns": [" max_ms", "maxsyns", "max67xs", "maxsyseconds", " max_bs", "max__nets", "max__ms", " max_nets", "max_seconds", "max_bs", " max_mn", "max__ns", "max00nets", "max67ms", "maxsybs", "max67mn", "max00xs", "maxsyms", "max_xs", " max_xs", "max67ns", "max00ns", "max00ms", "max_mn", " max_seconds", "max_nets", "max_ms", "max__xs"], "end_time": ["endtimetimer", "endmatmin", " end_ime", " end_min", "endlyime", "end_t", "end_Time", "end__time", "end_min", "endtimehour", " end_t", "endlytime", "end__t", "end__Time", "endmatime", "end_hour", " end_Time", "endmattime", "end_ime", "endlymin", "endtimetime", "end_timer", "end__ime", " end_timer", " end_hour"], "node": ["server", "index", "key", "path", "instance", "wrapper", "nw", "peer", "child", "primary", "local", "object", "good", "data", "addr", "row", "n", "window", "callback", "leaf", "resource", "field", "t", "source", "cache", "msg", "note", "station", "np", "item", "tree", "nt", "holder", "k", "m", "obj", "hop", "parent", "handler", "self", "event", "page", "link", "fn", "content", "device", "post", "root", "id", "master", "tmp", "e", "host", "inner", "entry", "Node", "list", "ready", "token", "slave", "pkg", "normal", "ode", "name", "nn", "worker"]}}
{"project": "FFmpeg", "commit_id": "3c5cf2a31b4b29a8e4282cbe6a3f0617c14698b8", "target": 0, "func": "static int screenpresso_decode_frame(AVCodecContext *avctx, void *data,\n\n                                     int *got_frame, AVPacket *avpkt)\n\n{\n\n    ScreenpressoContext *ctx = avctx->priv_data;\n\n    AVFrame *frame = data;\n\n    int keyframe;\n\n    int ret;\n\n\n\n    /* Size check */\n\n    if (avpkt->size < 3) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small (%d)\\n\", avpkt->size);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* Basic sanity check, but not really harmful */\n\n    if ((avpkt->data[0] != 0x73 && avpkt->data[0] != 0x72) ||\n\n        avpkt->data[1] != 8) { // bpp probably\n\n        av_log(avctx, AV_LOG_WARNING, \"Unknown header 0x%02X%02X\\n\",\n\n               avpkt->data[0], avpkt->data[1]);\n\n    }\n\n    keyframe = (avpkt->data[0] == 0x73);\n\n\n\n    /* Resize deflate buffer and frame on resolution change */\n\n    if (ctx->inflated_size != avctx->width * avctx->height * 3) {\n\n        av_frame_unref(ctx->current);\n\n        ret = ff_get_buffer(avctx, ctx->current, AV_GET_BUFFER_FLAG_REF);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        /* If malloc fails, reset len to avoid preserving an invalid value */\n\n        ctx->inflated_size = avctx->width * avctx->height * 3;\n\n        ret = av_reallocp(&ctx->inflated_buf, ctx->inflated_size);\n\n        if (ret < 0) {\n\n            ctx->inflated_size = 0;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* Inflate the frame after the 2 byte header */\n\n    ret = uncompress(ctx->inflated_buf, &ctx->inflated_size,\n\n                     avpkt->data + 2, avpkt->size - 2);\n\n    if (ret) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Deflate error %d.\\n\", ret);\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    /* When a keyframe is found, copy it (flipped) */\n\n    if (keyframe)\n\n        av_image_copy_plane(ctx->current->data[0] +\n\n                            ctx->current->linesize[0] * (avctx->height - 1),\n\n                            -1 * ctx->current->linesize[0],\n\n                            ctx->inflated_buf, avctx->width * 3,\n\n                            avctx->width * 3, avctx->height);\n\n    /* Otherwise sum the delta on top of the current frame */\n\n    else\n\n        sum_delta_flipped(ctx->current->data[0], ctx->current->linesize[0],\n\n                          ctx->inflated_buf, avctx->width * 3,\n\n                          avctx->width * 3, avctx->height);\n\n\n\n    /* Frame is ready to be output */\n\n    ret = av_frame_ref(frame, ctx->current);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Usual properties */\n\n    if (keyframe) {\n\n        frame->pict_type = AV_PICTURE_TYPE_I;\n\n        frame->key_frame = 1;\n\n    } else {\n\n        frame->pict_type = AV_PICTURE_TYPE_P;\n\n    }\n\n    *got_frame = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 14813, "substitutes": {"avctx": ["avtx", "avercmd", "iverctx", "svpkg", "wavctl", "navctx", "avercontext", "avcoll", " avcrit", "avpkg", "avedad", "afpkg", "ajkl", "avertx", "avetimeout", "navsys", " avcontext", " avctl", "wavtx", "svctx", "avcfg", "navpkg", " avcb", "wavctx", "avedt", "avdt", " avsys", "navca", "navcu", "AVcontext", " avtimeout", "avsys", "avkl", " avgc", "avcb", "savctx", "avejs", "avecontext", "ajjs", "aftx", "ivercontext", "ajcu", "wavcu", "svcontext", "svcp", "avetx", "avgc", " avcp", "averctl", "savcrit", " avcfg", "wavgc", "ajcoll", "ivertimeout", "iverca", "avecfg", "ajdad", "ajdt", "avcu", "savtx", "avercoll", "avecu", "navcfg", "navcontext", "AVctx", " avconn", "savcontext", "wavpkg", "averpkg", "afcontext", "ajcontext", "avekl", "avecmd", "avtimeout", "afkl", "avcp", "ajpkg", "afctx", "wavcmd", "svtx", "svcrit", "averctx", "wavcp", "navconn", " avca", "avcmd", "ajcb", "avconn", "avca", "avercu", "afcp", "wavconfig", "aveca", "aveconn", "avercb", "avconfig", "avcrit", "avectl", "avctl", "wavcontext", "navdad", "avcontext", "avepkg", "avegc", "avesys", "AVcfg", "ajctx", "aveconfig", " avtx", "savconn", "AVtx", "afjs", "avectx", "wavcfg", "avdad", "wavconn", "averconfig", "navdt", "avercp", " avcoll", "avjs", "afconn"], "data": ["query", "flags", "depth", "window", "raw", "t", "len", "new", "delay", "m", "channel", "first", "it", "length", "ata", "def", "des", "addr", "map", "timeout", "params", "what", "share", "fields", "next", "read", "padding", "bus", "br", "obj", "extra", "use", "one", "res", "table", "args", "device", "feed", "any", "area", "input", "history", "form", "a", "version", "f", "out", "ref", "bits", "text", "height", "buf", "date", "offset", "in", "da", "headers", "info", "mu", "buffer", "empty", "block", "Data", "id", "hash", "d", "to", "DATA", "options", "dat", "valid", "str", "bytes", "status", "rew", "has", "good", "size", "values", "response", "p", "mode", "relation", "xy", "done", "cache", "video", "bin", "r", "message", "time", "image", "byte", "code", "content", "no", "ns", "action", "rel", "list", "final", "w", "name"], "got_frame": ["got_window", "got_header", "gotipwindow", "gotewframe", "gotewwindow", "received_header", "gotipframe", "gotewstate", "received_frame", "gotipstate", "received_state", "gotipheader", "got_state", "gotewheader", "received_window"], "avpkt": ["avcpvt", "avpidvt", "avpayacket", "aftpcht", "avpskat", "avprekt", "dreamptt", "avpaykw", "avpaywp", "avdkt", "vanptt", "avpadkg", "avcpkt", " avcpnton", "avfkat", "aftpkt", "avpkg", "aftpadkg", "avpact", "avpaytt", "avwpkt", "vanpadu", "avpregt", "avpakg", "avjpkt", "avprekat", "avpostkt", "avpkat", "avpkgnton", "vrpaykw", "avpcht", "avcppt", "avepkt", "avpavt", "avwppt", "vanpatt", "aftpodkat", "avpodtt", " avppt", "avpkgacket", "vrpkt", "avpkgwp", "vanpdu", "avjptt", "vrpaykt", "afpacket", "avdacket", "avpast", "aftpadkt", "avetett", "iverpayoc", "avpscht", "afcpkat", "avpett", "avpkgst", "avpcpt", "avpakt", "avcpkat", "avpodkt", " avcpdat", "avetkt", "avtpacket", "avpadkat", " avpdat", "avfkt", "avpodkat", "aftpadcht", "avetacket", "dreampst", "avoppt", "avPkt", "afcpacket", "aftpodgt", "avpwt", "afpkt", "devpvt", "avtpdt", "avpkgpt", "avcpcht", "avpkw", "vrpaydt", "aftpkat", "aftpgt", " avcpacket", "avetwt", "avtacket", "avpodkw", "avepacket", "avpacht", "vanpapt", "dreamjpkat", "dreampkat", "avcpdat", "avpidct", "avtpkw", "avpnton", "avopnton", "avpdt", "avpkgtt", "aftpkg", "avpaacket", "iverpoc", "avpadt", "avtpkt", "avfnt", "avpkgkg", "avPoc", "avpcdu", "avpapt", "avepett", "afpkat", "avpwp", " avcppt", "dreamjptt", "avpakat", "avprecht", "avpdu", "vrpkw", "afcpkt", "avcpnt", "avpkgkt", "avpodcht", "avpayoc", "avtkt", "avpatt", "vanppt", "avjpkat", "avpct", "avpacket", "avpoddt", "devpct", "avopkt", "avpkgkat", "avpckt", "avtpdat", "avcpacket", "iverpaywp", "avpgt", "avpadcht", "avwptt", "avptt", "avpadat", "avpostett", "avopacket", "devpacht", "avtwt", "avpvt", "iverpkt", "avwpdu", "afpnt", "avpadu", "dreamjpst", "avepwt", "avfacket", "devpavt", " avcpdt", "aftpodkt", "avpkgcht", " avpnton", "avtptt", "avpostacket", "devpcht", "avpadkt", "vanpakt", "avpoc", "avpst", "aftpst", "avpnt", "vrpaytt", "avppt", "avpostwt", "avpdat", "dreamjpkt", "avpadacket", "afcpnt", "avpkgoc", "devpakt", "vanpkt", " avcpkt", "avpidkt", "iverpayacket", " avpdt", "avcpct", "avpctt", "aftpadst", "avcpdt", "avpadst", "avtett", "avjpst", "avpaykt", "aftpodcht", "avpaydt", "avPacket", "avcpnton", "avpidcht", "avpodgt", " avpacket", "iverpaykt", "dreampkt", "avpadnt", "devpact", "iverpwp", "avpskt", "devpkt", "vrpdt", "avdwt", "iverpacket", "avdett", "avPwp", "avpsgt", "vrptt"], "ctx": ["conn", "hw", "expr", "scope", "cmp", "lib", "mk", "check", "pool", "loc", "nt", "context", "doc", "parent", "cb", "xc", "abc", "fn", "wordpress", "qt", "iac", "pkg", "tx", "kw", "ctl", "co", "mem", "unc", "wx", "addr", "cmd", "lc", "crit", "kt", "timeout", "xp", "cfg", "obj", "aux", "nc", "wp", "ctrl", "cp", "gc", "tmp", "mt", "conf", "ca", "resp", "cf", "dl", "cc", "req", "proc", "tk", "ctr", "sys", "np", "fx", "cv", "mom", "kl", "etc", "pc", "config", "px", "tm", "iat", "jac", "jp", "cu", "tc", "cm", "dc", "func", "ct", "act", "desc", "prefix", "ck", "tz", "ns", "that", "inst"], "frame": ["tx", "def", "instance", "f", "cmd", "row", "window", "ror", "frames", "msg", "feature", "part", "channel", "info", "block", "image", "base", "fr", "draw", "Frame", "mt", "state", "piece", "component", "shot", "name"], "keyframe": ["rootframe", "linkframe", "rootFrame", "eyzone", "rootflag", " keypoint", "linkflag", "oleFrame", "KEYframe", " keyFrame", "Keyframes", "eyflag", "keyFrame", "oleimage", " keyimage", "keyframes", " keyframes", "KEYpoint", "keyimage", "eyframe", "Keyimage", "Keypoint", "linkFrame", "keyflag", "keypoint", "oleframes", "oleframe", "linkzone", "Keyframe", "KEYframes", "rootzone", "KeyFrame", "KEYFrame", "eyFrame", "keyzone"], "ret": ["plain", "et", "pret", "fun", "back", "expr", "tt", "dr", "val", "vet", "t", "len", "rm", "result", "locked", "nt", "lit", "att", "rev", "imp", "backed", "summary", "nil", "net", " Ret", "usr", "cont", "arr", "rem", "def", "mem", "ll", "cmd", "j", "tr", "RET", "reset", "try", "cat", "cfg", "aux", "std", "res", "print", "flag", "gc", "tmp", "mt", "arg", "elt", "ter", "resp", "ref", "out", "utils", "bool", "Ret", "reply", "rets", "ert", "sys", "nz", "gt", "rep", "mel", "ft", "hash", "err", "leg", "str", "jp", "status", "success", " RET", "det", "deg", "reg", "msg", "ext", "alt", "url", "rt", "re", "failed", "value", " fut"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline TCGv iwmmxt_load_creg(int reg)\n\n{\n\n    TCGv var = new_tmp();\n\n    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));\n\n    return var;\n\n}\n", "idx": 14814, "substitutes": {"reg": ["key", "index", "rem", "region", "mem", "ref", "attr", "Reg", "addr", "req", "typ", "g", "port", "REG", "loc", "sec", "num", "cell", "k", "tag", "lit", " Reg", "br", " REG", "res", "lex", "grid", "re", "rec", "id", "eg", "mod", "state", "name", "leg", "str"]}}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)\n\n{\n\n    const ARMCPRegInfo *ri = rip;\n\n\n\n    ri->writefn(env, ri, value);\n\n}\n", "idx": 14816, "substitutes": {"env": ["nv", "esm", " ens", "mem", "conn", "et", "ope", "environment", "estate", "ctx", "hw", "window", "erd", "v", "esc", "er", "En", "ef", "ten", "ew", "context", "ah", "obj", "shell", "en", "nc", "ec", "vs", "ov", "dev", "e", "Environment", "ve", "EN", "eh", "ev", "vt", "te", "viron", "pe", "equ"], "rip": ["rig", "ipp", "jp", "rack", " Rip", "sing", "gra", "rup", "rus", "ric", "rim", "trip", "ring", "pr", "river", "hip", "rit", "pin", "ping", "roy", "rep", "ripp", "rub", "rib", "rh", "rive", "strip", "rike", "rin", "RI", "rob", "rou", "rain", "tip", "RIP", "udi", "rap", "ip"], "value": ["index", "key", "type", "data", "values", "p", "vp", "val", "v", "widget", "rule", "reg", "unit", "sv", "result", "bin", "VALUE", "new", "Value", "update", "release", "word", "ue", "current", "image", "function", "code", "property", "VI", "set", "VAL", "state", "see", "wise", "name", "process"], "ri": ["ij", "rw", "ric", "mi", "ra", "ini", "pi", "rn", "pr", "uri", "ki", "ir", "uti", "io", "ru", "rid", "rm", "di", "rio", "r", "hi", "xi", "rt", "iri", "rub", "rib", "ani", "ro", "pri", "sr", "ry", "rive", "res", "RI", "rin", "ria", "rob", "tri", "ti", "rd", "ris", "rx", "i", "rs", "udi", "rap"]}}
{"project": "qemu", "commit_id": "0e22a2d18998fd183c8181663981eb681ca977e9", "target": 1, "func": "static void vhost_scsi_stop(VHostSCSI *s)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    int ret = 0;\n\n\n\n    if (!k->set_guest_notifiers) {\n\n        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);\n\n        if (ret < 0) {\n\n                error_report(\"vhost guest notifier cleanup failed: %d\\n\", ret);\n\n        }\n\n    }\n\n    assert(ret >= 0);\n\n\n\n    vhost_scsi_clear_endpoint(s);\n\n    vhost_dev_stop(&s->dev, vdev);\n\n    vhost_dev_disable_notifiers(&s->dev, vdev);\n\n}\n", "idx": 14822, "substitutes": {"s": ["sis", "aws", "ses", "gs", "a", "S", "as", "serv", "bs", "session", "p", "js", "n", "sq", "v", "sam", "t", "comm", "is", "sb", "sv", "service", "als", "hs", "sys", "ds", "ls", "ats", "times", "r", "services", "sc", "ts", "self", "c", "vs", "ns", "ops", "cs", "h", "es", "dev", "args", "b", "changes", "fs", "os", "d", "its", "ss", "sts", "ms", "y", "i", "rs", "ps"], "vdev": ["lvdev", "vDEV", "vpad", "vmend", "cvdev", "lvdes", "svdev", " vend", "lvend", " vdevice", "vcmd", "vcdes", "vtval", " vpad", "cvdec", "vcdev", " vdec", "svDEV", "lvhw", "vdes", " vval", " vhw", " vserv", "vdec", "cvpad", "vmdev", "vchw", "svdevice", "cvval", "vdevice", "vhw", "svserv", "vcstore", "vval", " vmd", "vtdec", " vdes", " vDEV", "vserv", "vtpad", "vmd", "vtdev", "vmmd", "tserv", "tDEV", "tdev", " vstore", "vstore", "vmstore", "vcend", "vend", "tdevice"], "qbus": ["dqbuf", "Qbuf", "qqbus", "qqlock", " qboot", "qqBUS", "QBus", " qBus", "qus", " qlock", "QBUS", "qBUS", "qqboot", "qBus", "quboot", "Qus", " qus", "Qboot", "dqlock", "Qbus", "qubus", "dqBUS", "qbuf", " qBUS", "dqBus", "qqbuf", "qlock", "qboot", "qqBus", "quBUS", "quus", "dqboot", "dqbus"], "k": ["key", "kw", "kn", "kh", "uk", "j", "aka", "ki", "km", "hm", "kt", "kk", "tk", "mk", "kit", "t", "kat", "ik", "kind", "ke", "K", "ek", "UK", "kr", "get", "ck", "ak", "keeper", "kick", "wk", "kl", "b", "ack", "KR", "ijk", "ks", "ker", "max", "ikk", "kj", "z", "q", "VK", "HK", "ka", "sk"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void start_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val &= ~TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n", "idx": 14823, "substitutes": {"d": ["dn", "data", "ind", "l", "p", "fd", "dr", "D", "ord", "dl", "dm", "pd", "dp", "dt", "t", "du", "md", "di", "dc", "dos", "ds", "da", "m", "dd", "r", "dump", "gd", "bd", "info", "dq", "dx", "c", "db", "df", "debug", "b", "dev", "ad", "de", "rd", "sd", "it", "dh", "q", "dat", "ld", "dra"], "val": ["vol", "tx", "key", " value", "Val", "vec", "ret", "serv", "ref", "V", "cond", "data", "pr", "p", "crit", "pol", "v", "g", "test", "xy", "el", "sl", "t", "pt", "util", "eval", "sil", "bin", "aval", "al", "update", " _", "fb", "vals", " eval", "pal", "cal", "all", " al", "ul", " v", "res", "b", "ival", "cho", "rel", " VAL", "VAL", "it", "elt", "prop", "bal", "value", "pl", "x", "valid", "iat"]}}
{"project": "qemu", "commit_id": "1931076077254a2886daa7c830c7838ebd1f81ef", "target": 0, "func": "void memory_global_dirty_log_stop(void)\n\n{\n\n    global_dirty_log = false;\n\n\n\n    /* Refresh DIRTY_LOG_MIGRATION bit.  */\n\n    memory_region_transaction_begin();\n\n    memory_region_update_pending = true;\n\n    memory_region_transaction_commit();\n\n\n\n    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);\n\n}\n", "idx": 14840, "substitutes": {}}
{"project": "qemu", "commit_id": "77eec1b3f1493ca4813eae2fbf8702d1ef58f147", "target": 0, "func": "static inline int open_by_handle(int mountfd, const char *fh, int flags)\n\n{\n\n    errno = ENOSYS;\n\n    return -1;\n\n}\n", "idx": 14842, "substitutes": {"mountfd": ["usrFD", "streamfc", " procFD", "_form", " procfc", "usrfd", "usrform", " procfd", "_FD", "_fd", "streamfd", "_fc", " procform", "streamform", "streamFD", "usrfc"], "fh": ["fch", "fhandle", "fdh", "sfh", "sfhandle", " fih", "fdih", "fih", "fdhandle", " fhandle", " fch", "sfch", "sfih", "fdch"], "flags": ["status", "types", "nl", "settings", "ensions", "mask", "mode", "bits", "ags", "names", "fields", "details", "features", "kind", "faces", "ds", "vals", "ts", "Flags", "flag", "ns", "cs", "args", "fs", "options", "ents", "properties", "rs"]}}
{"project": "qemu", "commit_id": "541dc0d47f10973c241e9955afc2aefc96adec51", "target": 0, "func": "static void cmd_get_event_status_notification(IDEState *s,\n\n                                              uint8_t *buf)\n\n{\n\n    const uint8_t *packet = buf;\n\n\n\n    struct {\n\n        uint8_t opcode;\n\n        uint8_t polled;        /* lsb bit is polled; others are reserved */\n\n        uint8_t reserved2[2];\n\n        uint8_t class;\n\n        uint8_t reserved3[2];\n\n        uint16_t len;\n\n        uint8_t control;\n\n    } __attribute__((packed)) *gesn_cdb;\n\n\n\n    struct {\n\n        uint16_t len;\n\n        uint8_t notification_class;\n\n        uint8_t supported_events;\n\n    } __attribute((packed)) *gesn_event_header;\n\n\n\n    enum notification_class_request_type {\n\n        NCR_RESERVED1 = 1 << 0,\n\n        NCR_OPERATIONAL_CHANGE = 1 << 1,\n\n        NCR_POWER_MANAGEMENT = 1 << 2,\n\n        NCR_EXTERNAL_REQUEST = 1 << 3,\n\n        NCR_MEDIA = 1 << 4,\n\n        NCR_MULTI_HOST = 1 << 5,\n\n        NCR_DEVICE_BUSY = 1 << 6,\n\n        NCR_RESERVED2 = 1 << 7,\n\n    };\n\n    enum event_notification_class_field {\n\n        ENC_NO_EVENTS = 0,\n\n        ENC_OPERATIONAL_CHANGE,\n\n        ENC_POWER_MANAGEMENT,\n\n        ENC_EXTERNAL_REQUEST,\n\n        ENC_MEDIA,\n\n        ENC_MULTIPLE_HOSTS,\n\n        ENC_DEVICE_BUSY,\n\n        ENC_RESERVED,\n\n    };\n\n    unsigned int max_len, used_len;\n\n\n\n    gesn_cdb = (void *)packet;\n\n    gesn_event_header = (void *)buf;\n\n\n\n    max_len = be16_to_cpu(gesn_cdb->len);\n\n\n\n    /* It is fine by the MMC spec to not support async mode operations */\n\n    if (!(gesn_cdb->polled & 0x01)) { /* asynchronous mode */\n\n        /* Only polling is supported, asynchronous mode is not. */\n\n        ide_atapi_cmd_error(s, SENSE_ILLEGAL_REQUEST,\n\n                            ASC_INV_FIELD_IN_CMD_PACKET);\n\n        return;\n\n    }\n\n\n\n    /* polling mode operation */\n\n\n\n    /*\n\n     * These are the supported events.\n\n     *\n\n     * We currently only support requests of the 'media' type.\n\n     */\n\n    gesn_event_header->supported_events = NCR_MEDIA;\n\n\n\n    /*\n\n     * We use |= below to set the class field; other bits in this byte\n\n     * are reserved now but this is useful to do if we have to use the\n\n     * reserved fields later.\n\n     */\n\n    gesn_event_header->notification_class = 0;\n\n\n\n    /*\n\n     * Responses to requests are to be based on request priority.  The\n\n     * notification_class_request_type enum above specifies the\n\n     * priority: upper elements are higher prio than lower ones.\n\n     */\n\n    if (gesn_cdb->class & NCR_MEDIA) {\n\n        gesn_event_header->notification_class |= ENC_MEDIA;\n\n        used_len = event_status_media(s, buf);\n\n    } else {\n\n        gesn_event_header->notification_class = 0x80; /* No event available */\n\n        used_len = sizeof(*gesn_event_header);\n\n    }\n\n    gesn_event_header->len = cpu_to_be16(used_len\n\n                                         - sizeof(*gesn_event_header));\n\n    ide_atapi_cmd_reply(s, used_len, max_len);\n\n}\n", "idx": 14846, "substitutes": {"s": ["ses", "south", "gs", "S", "serv", "session", "p", "n", "sq", "t", "is", "sv", "sb", "st", "sys", "ds", "m", "r", "ts", "c", "stats", "ns", "cs", "h", "es", "set", "e", "fs", "sg", "os", "state", "se", "ss", "sts", "sc", "rs", "ps"], "buf": ["bar", "Buff", "bytes", "resp", "vec", "ref", "out", "rw", "cur", "seq", "data", "pb", "cmd", "p", "map", "wb", "ctx", "raw", "Buffer", "v", "batch", "bt", "msg", "buff", "cap", "result", "rb", "bin", "br", "bag", "obj", "btn", "buffer", "block", "cb", "cv", "b", "tmp", "uf", "err", "queue", "pkg", "txt", "alloc", "pack"], "packet": ["packat", "peet", "buckET", "octacket", "peacket", "payacket", "packET", "octant", "bucket", "octet", "octent", "packset", "buckette", "packsette", "packacket", "payet", "framET", "packent", "framat", "peent", "peant", "packsET", "payant", "framette", "framet", "buckat", "packette", "packsat", "payent", "packant"], "reserved2": ["presumed02", "preserved12", "resolved02", "resumed3", "reserve02", "resumed2", "reserve3", "presumed2", "presumed3", "resolved12", "resolved2", "presumed12", "preserved02", "preserved3", "reserve2", "reserve12", "reserved12", "preserved2", "resolved3", "reserved02", "resumed12", "resumed02"], "reserved3": ["Reserved4", "resolved5", "reserv23", "Reset23", "reserv4", "Reserved3", "reserved5", "Reset3", "Reset4", "reserv3", "reset4", "reserved4", "resolved4", "resolved23", "Reserved5", "Reserved23", "resolved3", "reserv5", "reset5", "Reset5", "reserved23", "reset3", "reset23"], "gesn_cdb": ["gesn___comdeb", "gesn_dcgb", "gesn_pock", "gesn_cgb", "gesn_comdeb", "gesn_ecdb", "gesn_cddb", "gesn_acDB", "gesn___comDb", "gesn_acDb", "gesn_cdo", "gesn_cobj", "gesn_recud", "gesn_ldb", "gesn___comdb", "gesn_lvd", "gesn_cdbl", "gesn_cdobj", "gesn_rdb", "gesn_cdock", "gesn___cdb", "gesn_csdb", "gesn_ctDB", "gesn_rDB", "gesn_mdb", "gesn_mgb", "gesn_dcdeb", "gesn_dcDb", "gesn___cdeb", "gesn_cock", "gesn_cd", "gesn_acdb", "gesn_ecgb", "gesn_rdo", "gesn_csdo", "gesn_dcdb", "gesn_cvd", "gesn_lud", "gesn_csDB", "gesn_pbl", "gesn_cDB", "gesn_acdeb", "gesn___cDB", "gesn_cdgb", "gesn___cDb", "gesn_cDb", "gesn_rd", "gesn_ctdb", "gesn_pgb", "gesn_mbl", "gesn___comDB", "gesn_cdeb", "gesn_comDb", "gesn_pdb", "gesn_ctd", "gesn_ctvd", "gesn_recdb", "gesn_comDB", "gesn_cbl", "gesn_ctdo", "gesn_ctud", "gesn_cud", "gesn_mock", "gesn_ecobj", "gesn_dcobj", "gesn_comdb", "gesn_csd", "gesn_recvd", "gesn_dcDB"], "max_len": ["min_mem", "maxtlen", " max_mem", "max_mem", "max_en", "maxten", "max_length", "maxtmem", "min_len", "maxtlength", " max_length", "min_length", " max_en"], "used_len": ["used___lim", "used_loc", "created___pos", "created___len", "used___pos", "created_loc", "used___len", "created_lim", "created_len", "used___loc", "created___loc", "created___lim", "used_lim", "created_pos", "used_pos"]}}
{"project": "FFmpeg", "commit_id": "850c6db97d1f78e7607952ab8b854a93a185319e", "target": 0, "func": "static int decode_plane(UtvideoContext *c, int plane_no,\n\n                        uint8_t *dst, int step, ptrdiff_t stride,\n\n                        int width, int height,\n\n                        const uint8_t *src, int use_pred)\n\n{\n\n    int i, j, slice, pix;\n\n    int sstart, send;\n\n    VLC vlc;\n\n    GetBitContext gb;\n\n    int prev, fsym;\n\n    const int cmask = c->interlaced ? ~(1 + 2 * (!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P)) : ~(!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P);\n\n\n\n    if (build_huff(src, &vlc, &fsym)) {\n\n        av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (fsym >= 0) { // build_huff reported a symbol to fill slices with\n\n        send = 0;\n\n        for (slice = 0; slice < c->slices; slice++) {\n\n            uint8_t *dest;\n\n\n\n            sstart = send;\n\n            send   = (height * (slice + 1) / c->slices) & cmask;\n\n            dest   = dst + sstart * stride;\n\n\n\n            prev = 0x80;\n\n            for (j = sstart; j < send; j++) {\n\n                for (i = 0; i < width * step; i += step) {\n\n                    pix = fsym;\n\n                    if (use_pred) {\n\n                        prev += pix;\n\n                        pix   = prev;\n\n                    }\n\n                    dest[i] = pix;\n\n                }\n\n                dest += stride;\n\n            }\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    src      += 256;\n\n\n\n    send = 0;\n\n    for (slice = 0; slice < c->slices; slice++) {\n\n        uint8_t *dest;\n\n        int slice_data_start, slice_data_end, slice_size;\n\n\n\n        sstart = send;\n\n        send   = (height * (slice + 1) / c->slices) & cmask;\n\n        dest   = dst + sstart * stride;\n\n\n\n        // slice offset and size validation was done earlier\n\n        slice_data_start = slice ? AV_RL32(src + slice * 4 - 4) : 0;\n\n        slice_data_end   = AV_RL32(src + slice * 4);\n\n        slice_size       = slice_data_end - slice_data_start;\n\n\n\n        if (!slice_size) {\n\n            av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol \"\n\n                   \"yet a slice has a length of zero.\\n\");\n\n            goto fail;\n\n        }\n\n\n\n        memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        c->bdsp.bswap_buf((uint32_t *) c->slice_bits,\n\n                          (uint32_t *)(src + slice_data_start + c->slices * 4),\n\n                          (slice_data_end - slice_data_start + 3) >> 2);\n\n        init_get_bits(&gb, c->slice_bits, slice_size * 8);\n\n\n\n        prev = 0x80;\n\n        for (j = sstart; j < send; j++) {\n\n            for (i = 0; i < width * step; i += step) {\n\n                pix = get_vlc2(&gb, vlc.table, VLC_BITS, 3);\n\n                if (pix < 0) {\n\n                    av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");\n\n                    goto fail;\n\n                }\n\n                if (use_pred) {\n\n                    prev += pix;\n\n                    pix   = prev;\n\n                }\n\n                dest[i] = pix;\n\n            }\n\n            if (get_bits_left(&gb) < 0) {\n\n                av_log(c->avctx, AV_LOG_ERROR,\n\n                        \"Slice decoding ran out of bits\\n\");\n\n                goto fail;\n\n            }\n\n            dest += stride;\n\n        }\n\n        if (get_bits_left(&gb) > 32)\n\n            av_log(c->avctx, AV_LOG_WARNING,\n\n                   \"%d bits left after decoding slice\\n\", get_bits_left(&gb));\n\n    }\n\n\n\n    ff_free_vlc(&vlc);\n\n\n\n    return 0;\n\nfail:\n\n    ff_free_vlc(&vlc);\n\n    return AVERROR_INVALIDDATA;\n\n}\n", "idx": 14848, "substitutes": {"c": ["rc", "cu", "a", "co", "tc", "f", "cr", "cf", "cm", "ca", "lc", "ctx", "p", "n", "this", "cmp", "call", "cc", "cd", "v", "conv", "g", "t", "comm", "ic", "com", "dc", "cache", "ct", "cl", "m", "cam", "s", "ac", "C", "self", "cb", "cv", "abc", "nc", "ec", "ci", "comp", "cp", "b", "mc", "cs", "bc", "h", "etc", "gc", "fc", "e", "con", "conf", "cont", "enc", "d", "config", "sc", "coll", "ce", "anc", "ch"], "plane_no": [" plane_No", " plane_nos", " plane_NO", " plane_n", "plane_No", "plane_n", "plane_ne", "plane_nos", " plane_ne", "plane_nob", " plane_nob", "plane_NO"], "dst": ["Dst", "sddest", " dnd", "nset", "sdset", "sest", "ddest", "dset", "sst", "nst", "pdest", "pst", "Ddest", "dend", "dnd", "mnd", "mst", "pdst", "Dset", "nest", "ndest", "Dest", "pend", "pdST", "sdst", "sdest", "pdnd", "dST", "Dend", "mST", "pest", " dST"], "step": ["wait", "walk", "shift", "version", "seed", "mode", "window", "tr", "chain", "batch", "frame", "stop", "st", "loop", "skip", "diff", "delay", "offset", "op", "steps", "hop", "dim", "range", "resolution", "tower", "speed", "stroke", "add", "trans", "STEP", "crop", "scale", "start", "Step", "jump", "draw", "ride", "transform", "iter", "weight", "length", "d", "shape", "w", "driver", "pointer"], "stride": ["slage", "sade", "stringide", "strider", "strride", "stize", "strise", "size", "slension", "trise", "sprension", "trides", "slide", "strize", "grise", "trice", "strine", "STRide", "spride", "stade", "Strine", "Strider", "Stride", "stice", "strice", "trride", "Strides", "sice", "strage", "gride", "sprage", "STRise", "tride", "slize", "strides", "strade", "Strension", "strension", "stringides", "sprine", "STRride", "grride", "sline", "trider", "STRider", "stringice", "stide", "Strage", "side", "slade", "grider", "stringider", "Strice"], "height": ["hang", "kw", "view", "ty", "shift", "density", "size", "family", "hub", "row", "depth", "window", "radius", "read", "rank", "bottom", "flow", "Height", "th", "dim", "range", "resolution", "stroke", "buffer", "capacity", "ht", "volume", "h", "grow", "ows", "hash", "length", "gravity", "shape", "above", "w", "y", "angle", "zh", "history"], "src": ["bytes", "rc", "inst", "sort", "shift", "ptr", "hr", "seed", "addr", "ist", "ctx", "stream", "rl", "sur", "filename", "ctr", "source", "loc", "sb", "origin", "st", "sys", "rb", "scan", "dist", "in", "desc", "r", "rest", "s", "rs", "rt", "ost", "image", "sel", "sr", "img", "std", "ins", "crop", "comp", "start", "ser", "scale", "input", "tmp", "Source", "inner", "seek", "fc", "shape", "iv", "supp", "sn", "sc", "str", "txt"], "use_pred": [" use_prop", "useablered", " use_Pred", " use_red", " use_pre", "use_red", " use_repl", "useablerepl", "useablePred", "use_repl", "use_prop", "use_pre", "use_Pred", "useablepred"], "i": ["ij", "index", "li", "iu", "ii", "mi", "I", "pi", "ind", "l", "ini", "p", "n", "x", "ki", "si", "zi", "v", "ori", "bi", "ui", "di", "ami", "asi", "in", "m", "ai", "ie", "s", "qi", "xi", "sim", "im", "\u0438", "ci", "ice", "start", "ti", "ri", "iter", "e", "gi", "it", "ji", "z", "y", "ix", "ip"], "j": ["jp", "ij", "index", "shift", "f", "o", "jit", "ii", "ind", "l", "p", "n", "js", "aj", "other", "bj", "v", "g", "bi", "ge", "uj", "end", "job", "k", "m", "br", "ie", "s", "json", "ja", "obj", "sim", "im", "dj", "J", "jj", "b", "jump", "jo", "fr", "jl", "jc", "ji", "it", "kj", "z", "q", "x", "y"], "slice": ["vol", "index", "shift", "seed", "scope", "sequence", "series", "sl", "mix", "tie", "loop", "cut", "lock", "ble", "split", "lic", "limit", "ser", "plane", "label", "zero", "angle", "li", "square", "axis", "gem", "ind", "choice", "si", "module", "try", "tile", "cell", "volume", "scale", "division", "edge", "slave", "span", "pe", "sample", "pose", "sci", "copy", "node", "scroll", "sing", "face", "late", "call", "reverse", "pixel", "batch", "source", "offset", "slot", "stage", "block", "single", "plot", "prime", "crop", "se", "dose", "ste", "region", "sort", "route", "section", "ini", "l", "cone", "chain", "frame", "gate", "range", "parse", "sp", "sel", "ice", "piece", "ve"], "pix": ["PIX", "ppIX", "cpIX", "cpius", " pitch", "ppx", "spix", " pixels", "paox", "Px", "pik", "pitch", " px", " pik", "mpix", "paik", "pIX", " pox", "spixels", "pfix", "spx", "ppix", "pius", "Pix", "ppitch", "paIX", "cpix", "pox", "ppixels", "cpfix", "mpox", "paius", "Pfix", " pIX", "Pixels", "pich", "pixels", " pich", " pfix", "px", "mpich", "Pitch", "paixels", "spIX", "paich", "paix", " pius", "cpixels", "cpx", "mpik"], "sstart": ["swind", "dstart", " sbegin", "dsend", "Send", "sssend", "ssstart", "atsopen", "nsaddr", "psrand", "Sstart", "ssopen", "pstart", "osbegin", " ssend", "pswind", "dbegin", "atsbegin", "dend", "ospart", " swind", "nsend", "sspart", "atsstart", "sstop", "psstart", " sopen", "dsbegin", " sstop", "pwind", "nsstop", "osstart", "nsstart", "ossend", "dsaddr", "snext", "dsnext", " saddr", "spart", "Sbegin", "ssbegin", "Snext", "atsend", "saddr", "dsstop", "prand", " spart", "dopen", "sbegin", "ssend", "sopen", "dsstart"], "send": ["shift", "Send", "push", "seed", "miss", "check", "load", "nd", "st", "end", "command", "add", "mit", "start", "grow", "draw", "see", "transfer", "sn", "fin", "sent", "sum", "wait", "apply", "cmd", "forward", "speed", "bind", "scale", "set", "seek", "eng", "save", "pose", " Send", "store", "ceive", "write", "offset", "connect", "scan", "jump", "transform", "se", "cast", "ss", "process", "force", "status", "sort", "size", "sv", "msg", "skip", "desc", "END", "gate", "message", "find", "parse", "sp", "pend", "append", "sd", "format", "export", "commit", "init", "sc"], "vlc": ["VLl", "VLct", "mlcs", "vll", "vlt", "kll", "wll", "VLc", "vpci", "VLci", "wlct", "klc", "wlt", "klcs", "vlct", "vpct", "vlcs", "mlc", "wlc", "wlcs", "klt", "vpc", "vlci", "wlci", "mlt", "vpl", "mll"], "gb": [" dc", " coord", " des", " deg", " td", " cc", " cd", " count", " std", " prog", " dat", " dim", " Dest", " cz", " db", " rgb", " rend", " dist", " rg", " status", " digest", " flag", " buf", " disp", " rc", " bus", "uv", " whence"], "prev": ["jp", "vv", "vec", "ptr", "serv", "ref", "orig", "trip", "seed", "attr", "pres", "cmp", "miss", "par", "vp", "perm", "conv", "next", "adj", "before", "msg", "origin", "skip", "buf", "op", "desc", "last", "snap", "first", "prefix", "rev", "PRE", "sp", "inv", "pred", "cp", "best", "jump", "rec", "tmp", "vious", "mp", "rel", "VP", "pre", "var", "Prev", "sup", "slave", "prop", "iv", "pkg", "init", "save", "txt", "ip"], "fsym": ["fmbol", "fcmp", "Fsyn", "ffsym", "zmbol", "Fmbol", "zsy", "sfsy", "flmy", "FSym", "fsyn", "tfmy", " fmbol", "fctyp", "tfSym", "fSym", "lSym", "lcmp", "lmbol", "ffsy", "rfsy", "ftyp", "fsy", "zcmp", "Fmy", "flsyn", "flsym", "ffSym", "rftyp", "ffmbol", "tfsyn", "flSym", "fcsym", "fcmbol", "sftyp", "sfsym", "lsy", "fmy", "sfmbol", "tfsym", "lsym", "rfsym", "rfmbol", " fcmp", "fcsy", "zsym", "Fsy", "Fsym", " fsy"], "dest": ["status", "sort", "est", "mem", "ptr", "shift", "vec", "out", "output", "orig", "global", "tr", "reverse", "this", "temp", "opt", "v", "chain", "g", "test", "port", "source", "loc", "st", "dc", "end", "result", "new", "msg", "comb", "cat", "dist", "desc", "rest", "lit", "alt", "dim", "Dest", "sp", "decl", "sys", "trans", "img", "gest", "coord", "table", "master", "jump", "tmp", "transform", "iter", "list", "it", "config", "shape", "max", "sup", "prop", "pas", "target", "cast", "origin", "usr", "cont", "sum", "copy"], "slice_data_start": ["slice_DATA_end", "slice_data1start", "slice_data__end", "slice_image_id", "slice_DATA_first", "slice_data1end", "slice_image2id", "slice_image2end", "slice_data2id", "slice_image2start", "slice_data__offset", "slice_DATA_start", "slice_image_start", "slice_data2end", "slice_data1first", "slice_data_id", "slice_data__start", "slice_data1offset", "slice_image_end", "slice_data_offset", "slice_data__first", "slice_data_first", "slice_DATA_offset", "slice_data2start"], "slice_data_end": ["def", "vec", "slice_data_max", "slice_data___start", "conv", "slice_no_head", "xy", "slice_no_index", "slice_no_start", "func", "slice_data____start", "slice_data____head", "slice_data___index", "slice_data____index", "slice_no_end", "slice_data_head", "slice_data_index", "jpg", "img", "slice_data____end", "slice_data___end", "slice_data___head", "_", "cont", "slice_data_e"], "slice_size": ["slice_count", "slice_shape", "tile_size", "slice_offset", " slice_shape", "tile_number", "slice_number", "tile_count", " slice_name", "slice_name", "tile_offset"]}}
{"project": "FFmpeg", "commit_id": "81a8701eb52d2b6469ae16ef442ce425388141b7", "target": 0, "func": "static int ogg_buffer_data(AVFormatContext *s, AVStream *st,\n\n                           uint8_t *data, unsigned size, int64_t granule,\n\n                           int header)\n\n{\n\n    OGGStreamContext *oggstream = st->priv_data;\n\n    OGGContext *ogg = s->priv_data;\n\n    int total_segments = size / 255 + 1;\n\n    uint8_t *p = data;\n\n    int i, segments, len, flush = 0;\n\n\n\n    // Handles VFR by flushing page because this frame needs to have a timestamp\n\n    // For theora, keyframes also need to have a timestamp to correctly mark\n\n    // them as such, otherwise seeking will not work correctly at the very\n\n    // least with old libogg versions.\n\n    // Do not try to flush header packets though, that will create broken files.\n\n    if (st->codec->codec_id == AV_CODEC_ID_THEORA && !header &&\n\n        (ogg_granule_to_timestamp(oggstream, granule) >\n\n         ogg_granule_to_timestamp(oggstream, oggstream->last_granule) + 1 ||\n\n         ogg_key_granule(oggstream, granule))) {\n\n        if (oggstream->page.granule != -1)\n\n            ogg_buffer_page(s, oggstream);\n\n        flush = 1;\n\n    }\n\n\n\n    // avoid a continued page\n\n    if (!header && oggstream->page.size > 0 &&\n\n        MAX_PAGE_SIZE - oggstream->page.size < size) {\n\n        ogg_buffer_page(s, oggstream);\n\n    }\n\n\n\n    for (i = 0; i < total_segments; ) {\n\n        OGGPage *page = &oggstream->page;\n\n\n\n        segments = FFMIN(total_segments - i, 255 - page->segments_count);\n\n\n\n        if (i && !page->segments_count)\n\n            page->flags |= 1; // continued packet\n\n\n\n        memset(page->segments+page->segments_count, 255, segments - 1);\n\n        page->segments_count += segments - 1;\n\n\n\n        len = FFMIN(size, segments*255);\n\n        page->segments[page->segments_count++] = len - (segments-1)*255;\n\n        memcpy(page->data+page->size, p, len);\n\n        p += len;\n\n        size -= len;\n\n        i += segments;\n\n        page->size += len;\n\n\n\n        if (i == total_segments)\n\n            page->granule = granule;\n\n\n\n        if (!header) {\n\n            AVStream *st = s->streams[page->stream_index];\n\n\n\n            int64_t start = av_rescale_q(page->start_granule, st->time_base,\n\n                                         AV_TIME_BASE_Q);\n\n            int64_t next  = av_rescale_q(page->granule, st->time_base,\n\n                                         AV_TIME_BASE_Q);\n\n\n\n            if (page->segments_count == 255 ||\n\n                (ogg->pref_size     > 0 && page->size   >= ogg->pref_size) ||\n\n                (ogg->pref_duration > 0 && next - start >= ogg->pref_duration)) {\n\n                ogg_buffer_page(s, oggstream);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (flush && oggstream->page.granule != -1)\n\n        ogg_buffer_page(s, oggstream);\n\n\n\n    return 0;\n\n}\n", "idx": 14865, "substitutes": {"s": ["ans", "ses", "gs", "a", "S", "sw", "bs", "src", "out", "ys", "js", "stream", "stat", "v", "g", "sl", "t", "sm", "sv", "sb", "sys", "ds", "ats", "ls", "erences", "ssl", "sc", "so", "ts", "self", "c", "sp", "stats", "b", "ns", "ops", "h", "es", "fs", "os", "its", "se", "sn", "ss", "sts", "scl", "rs", "ps"], "st": ["ste", "spect", "stable", "inst", "est", "sw", "src", "sta", "St", "ST", "ist", "tt", "stream", "stat", "sl", "t", "stop", "nd", "sm", "sv", "sb", "sec", "ct", "rest", "irst", "th", "rt", "so", "ts", "ost", "sp", "c", "art", "ust", "stage", "std", "sh", "start", "h", "set", "mt", "sty", "d", "se", "ast", "sn", "ss", "sts", "sc", "str"], "data": ["bytes", "key", "rew", "type", "map", "mode", "window", "raw", "name", "text", "next", "done", "batch", "t", "padding", "read", "cache", "buf", "bin", "delay", "offset", "memory", "message", "first", "buffer", "empty", "block", "image", "base", "pos", "content", "Data", "table", "start", "device", "id", "feed", "length", "d", "to", "DATA", "format", "ata", "value", "dat", "join", "init", "results"], "size": ["index", "notice", "Size", "shift", "member", "window", "storage", "delay", "send", "fee", "resolution", "en", "limit", "summary", "start", "see", "duration", "length", "shape", "zero", "sum", "number", "n", "timeout", "si", "g", "spec", "padding", "space", "memory", "use", "speed", "pos", "scale", "area", "set", "total", "style", "usage", "scroll", "score", "pi", "SIZE", "height", "ize", "now", "offset", "description", "empty", "buffer", "capacity", "id", "equal", "to", "small", "bytes", "status", "position", "l", "body", "stream", "cache", "message", "time", "sp", "count", "e", "max", "z", "name"], "granule": ["granulo", "ranul", "gunule", "capsuler", "granULE", "gunulo", "gnular", "granularity", "vanularity", "ganul", "mnularity", "capsularity", "circULE", "granulate", "severularity", "gunulate", "severule", "gunieval", "vanule", " granul", "gunle", " granuler", "circule", "genule", "genularity", "vanestyle", "gnul", "ranestyle", "genle", "granuler", "vanulo", "gunul", " granulate", "granieval", "granular", "severieval", "circieval", "ranular", "granle", "gunularity", "ranieval", "granul", "gnule", "mnule", "ranule", "granestyle", "gunular", "gunestyle", "capsule", "ranULE", "capsul", "severulate", "ganularity", " granularity", "ganuler", "mnle", " granULE", "ranulo", "genul", "gnulo", "circularity", "ganule", "mnul", " granieval", "ranularity"], "header": ["server", "error", "scroll", "version", "border", "peer", "shift", "iler", "head", "hidden", "body", "window", "stream", "dr", "tail", "rule", "layer", "padding", "er", "title", "offset", "holder", "timer", "writer", "player", "comment", "magic", "parent", "headers", "handler", "empty", "buffer", "block", "protection", "event", "drm", "debug", "flag", "client", "table", "vector", "h", "Header", "heading", "order", "hash", "filter", "zero", "ter", "required", "priority"], "oggstream": ["oggform", "assembclean", "oggleconnection", "assembstream", "oggpoll", "aggconsole", "ggproc", "awkstream", "oglproc", "ircstream", "ircdriver", "ogastyle", "oggconsole", "oggedstream", "ggstyle", "audconsole", "ogglestyle", "oglstream", "obbsocket", "umbleconsole", "oggleline", "angconnection", "ircconsole", "oggcontext", "obbstream", "audstack", "assembStream", "bbthread", "ggform", "oggserver", "ogpoll", "ogglestream", "ggclean", "audstream", "ggconsole", "oggedpipe", "readableconsole", "ggstream", "ogglesync", "oggstyle", "ggdriver", "oggedpoll", "oggsync", "oggthread", "obbstyle", "obbline", "aggStream", "ogstream", "assembserver", "umblestream", "ogastream", "ogthread", "obbclean", "ogasync", "ggcontext", "bbcontext", "audserver", "ggsync", "awkstack", "oggedStream", "oggproc", "ogform", "awkserver", "aggstream", "obbcontext", "oglstyle", "oggstack", "oggline", "oggledriver", "ogStream", "readablestream", "aggstyle", "angstream", "obbpipe", "awkconsole", "readablethread", "ggStream", "oggleconsole", "aggstack", "bbstream", "angStream", "oggsocket", "ogdriver", "umblestyle", "obbsync", "bbStream", "angsync", "oggclean", "bbsocket", "ggpipe", "oggStream", "oggpipe", "oggconnection", "obbStream", "obbproc", "obbserver", "oggdriver", "obbpoll", "ogglepoll", "oglStream", "ggpoll", "ogconsole", "ircpoll", "aggserver", "ggconnection", "obbdriver", "oggleStream", "ggsocket", "ogaline", "bbconsole", "umbleStream", "ggserver", "readableStream", "obbform"], "ogg": ["asc", "gs", "orm", "ib", "oc", "gg", "audio", "tt", "ocr", "stat", "aud", "ga", "pp", "ik", "buff", "og", "peg", "ream", "mpeg", "ssl", "ost", "ht", "pg", "eg", "pdf", "ink", "bb", "sc", "ob"], "p": ["jp", "a", "ptr", "f", "o", "pi", "l", "pb", "j", "pr", "vp", "v", "dp", "g", "pt", "t", "pp", "np", "offset", "P", "m", "buffer", "c", "sp", "lp", "fp", "pos", "ap", "cp", "b", "h", "pc", "u", "it", "d", "ps", "q", "pl", "tp", "pa", "pe", "ip"], "i": ["index", "li", "go", "iu", "ii", "mi", "I", "pi", "ind", "ini", "j", "ei", "n", "l", "si", "zi", "v", "cli", "g", "bi", "t", "ui", "iq", "is", "di", " ii", "ai", "m", "in", "hi", "xi", "qi", "sim", "im", "ci", "b", "h", "id", "ti", "e", "u", "iter", "multi", "it", "gi", "me", "phi", "x", "y", "ic", "ix", "ip"], "segments": ["esges", " sements", " segs", "seegments", "pements", "esctors", "psectors", "selements", "pegements", "pegments", " selements", "esgements", "segements", "peges", "tegements", "seelements", "tements", "sements", "pegins", "tegs", "egments", "elegements", "begs", "esgs", "gegements", "eleges", "seeges", "pegment", "negements", "seements", " segements", "beges", "veges", "segment", "psegements", "vectors", "geges", "sectors", "pseges", "segs", "vegments", " seges", "elements", "vegs", "gements", "gegments", "pegs", "eslements", "ements", "psegs", "nelements", "psegments", "vegins", "telements", "bements", "tegment", "elegments", "negments", "begments", "egment", "seges", " segment", "segins", "tegments", "teges", "vegements", "velements", "vegment", "vements", "psegins", "esgments", "psements", "nements"], "len": ["bytes", "il", "nl", "vec", "mem", "lf", "late", "Len", "ll", "l", "fin", "n", "ln", "str", "cmp", "seq", "L", "tail", "val", "sl", "el", "le", "t", "loc", "fl", "offset", "lang", "ls", "lis", "ml", "lit", "lin", "full", "lon", "sp", "lp", "pos", "en", "limit", "lt", "lan", "kl", "bl", "ler", "label", "length", "elt", "lim", "coll"], "page": ["index", "peak", "window", "delete", "stat", "pool", "port", "result", "policy", "command", "new", "line", "vote", "word", "parent", "document", "layout", "site", "limit", "start", "draw", "pty", "see", "queue", "filter", "phase", "wait", "view", "error", "number", "search", "address", "map", "group", "module", "pm", "next", "pages", "average", "menu", "memory", "comment", "link", "table", "pg", "total", "Page", "cycle", "tab", "pe", "form", "node", "server", "key", "record", "version", "row", "this", "pixel", "batch", "date", "offset", "step", "age", "buffer", "block", "phrase", "file", "me", "instance", "request", "go", "child", "button", "position", "session", "section", "office", "response", "stream", "rule", "statement", "frame", "pp", "cache", "web", "message", "mark", "pee", "sp", "image", "count", "event", "code", "post", "article", "point", "order", "entry", "list", "pl", "pointer"]}}
{"project": "FFmpeg", "commit_id": "38bb5a5434f913451aa512624a92b12b9925690f", "target": 0, "func": "void mpeg4_encode_picture_header(MpegEncContext * s, int picture_number)\n\n{\n\n    int time_incr;\n\n    int time_div, time_mod;\n\n\n\n    if(s->pict_type==AV_PICTURE_TYPE_I){\n\n        if(!(s->flags&CODEC_FLAG_GLOBAL_HEADER)){\n\n            if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT) //HACK, the reference sw is buggy\n\n                mpeg4_encode_visual_object_header(s);\n\n            if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT || picture_number==0) //HACK, the reference sw is buggy\n\n                mpeg4_encode_vol_header(s, 0, 0);\n\n        }\n\n        if(!(s->workaround_bugs & FF_BUG_MS))\n\n            mpeg4_encode_gop_header(s);\n\n    }\n\n\n\n    s->partitioned_frame= s->data_partitioning && s->pict_type!=AV_PICTURE_TYPE_B;\n\n\n\n    put_bits(&s->pb, 16, 0);                /* vop header */\n\n    put_bits(&s->pb, 16, VOP_STARTCODE);    /* vop header */\n\n    put_bits(&s->pb, 2, s->pict_type - 1);  /* pict type: I = 0 , P = 1 */\n\n\n\n    assert(s->time>=0);\n\n    time_div= s->time/s->avctx->time_base.den;\n\n    time_mod= s->time%s->avctx->time_base.den;\n\n    time_incr= time_div - s->last_time_base;\n\n    assert(time_incr >= 0);\n\n    while(time_incr--)\n\n        put_bits(&s->pb, 1, 1);\n\n\n\n    put_bits(&s->pb, 1, 0);\n\n\n\n    put_bits(&s->pb, 1, 1);                             /* marker */\n\n    put_bits(&s->pb, s->time_increment_bits, time_mod); /* time increment */\n\n    put_bits(&s->pb, 1, 1);                             /* marker */\n\n    put_bits(&s->pb, 1, 1);                             /* vop coded */\n\n    if (    s->pict_type == AV_PICTURE_TYPE_P\n\n        || (s->pict_type == AV_PICTURE_TYPE_S && s->vol_sprite_usage==GMC_SPRITE)) {\n\n        put_bits(&s->pb, 1, s->no_rounding);    /* rounding type */\n\n    }\n\n    put_bits(&s->pb, 3, 0);     /* intra dc VLC threshold */\n\n    if(!s->progressive_sequence){\n\n         put_bits(&s->pb, 1, s->current_picture_ptr->top_field_first);\n\n         put_bits(&s->pb, 1, s->alternate_scan);\n\n    }\n\n    //FIXME sprite stuff\n\n\n\n    put_bits(&s->pb, 5, s->qscale);\n\n\n\n    if (s->pict_type != AV_PICTURE_TYPE_I)\n\n        put_bits(&s->pb, 3, s->f_code); /* fcode_for */\n\n    if (s->pict_type == AV_PICTURE_TYPE_B)\n\n        put_bits(&s->pb, 3, s->b_code); /* fcode_back */\n\n}\n", "idx": 14872, "substitutes": {"s": ["ses", "gs", "S", "bs", "ties", "ports", "series", "sq", "ags", "m", "eds", "acs", "qs", "stats", "summary", "vs", "states", "cs", "tests", "ims", "tes", "sg", "aunts", "its", "ants", "us", "ps", "sw", "ions", "n", "js", "v", "http", "comm", "spec", "wcs", "ds", "ats", "ies", "webkit", "args", "uploads", "set", "ows", "ains", "parts", "ex", "results", "f", "as", "less", "bits", "eps", "source", "als", "sb", "er", "hs", "sys", "erences", "c", "ares", "ops", "es", "changes", "events", "fs", "bis", "se", "sports", "ss", "comments", "aws", "has", "l", "p", "ges", "details", "is", "sv", "ls", "cl", "ches", "mods", "oss", "ts", "ins", "ns", "b", "h", "os", "z", "w", "sts", "news", "ms", "y", "rs"], "picture_number": ["picture___num", " picture_nb", "picture08number", "picture08column", "picture___number", "picture___nb", "picture08nb", " picture_column", "picture08num", "picture_num", "picture_volume", "picture_column", " picture_volume", " picture_type", "picture___column", " picture_num", "picture_nb", "picture_type"], "time_incr": ["time__incr", "time_aggur", "time_accrs", "time_igncr", "time_acccr", "time_occcr", "time_ecur", "time_increer", "time_INCr", "time_agger", "time_ignr", "time_diffur", "time_occrc", "time_occer", "time_diffcr", "time_occur", "time_ecer", "time__inccr", "time_incrs", "time_ecr", "time_acctr", "time_aggcr", "time_accrd", "time_ecrc", "time_incrd", "time_suppr", "time__acccr", "time_occrs", "time_INCcr", "time_supprs", "time_inccr", "time_incre", "time_accr", "time_accre", "time_increur", "time_incrc", "time__accrs", "time_incur", "time_differ", "time_INCrd", "time__accr", "time_incer", "time_inctr", "time_increrc", "time_ignre", "time_ignrd", "time_diffr", "time_increr", "time_occr", "time__incrs", "time_INCre", "time_increcr", "time_aggr", "time__inctr", "time__acctr", "time_occtr", "time_supptr", "time_suppcr"], "time_div": ["time_sub", "time2con", " time2div", "time_exp", "time66comm", " time_sub", "time12div", "time64con", "ime_dot", "time62dec", "ime_comm", "time_comm", "time_con", "time62exp", "time2sub", "time12con", " time_dev", "time64dev", "time_dot", "time12dev", "time66dot", " time2sub", " time_con", "time12sub", " time_exp", "time_dev", "time7div", "ime_div", " time_dec", "time64div", "time66div", "time_max", "time62max", "time_dec", "time2div", "time7dec", "time2dev", "time62div", " time2dev", "time7exp", "time64sub", " time_max", "time7max", " time2con"], "time_mod": ["ime_Mod", "ime2step", "ime2div", "ime_orig", "TIME_div", "TIME_req", "ime2mod", "time67div", "time5div", "TIME_mod", "time5step", "time67Mod", "ime_div", "time5orig", "time67mod", "time2dec", "time_step", "time_req", "time_max", "time67max", "time_Mod", "ime_mod", "time2req", "time_dec", "time2div", "time2orig", "ime_max", "time2mod", "ime2orig", "TIME_dec", "time5mod", "ime_step", "time_orig", "time2step"]}}
{"project": "FFmpeg", "commit_id": "0273ceebbd01f9fd5238558e6151e0b9aa3305ab", "target": 0, "func": "static void build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, \n\n                      int nb_codes)\n\n{\n\n    uint8_t huff_size[256];\n\n    uint16_t huff_code[256];\n\n\n\n    memset(huff_size, 0, sizeof(huff_size));\n\n    build_huffman_codes(huff_size, huff_code, bits_table, val_table);\n\n    \n\n    init_vlc(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2);\n\n}\n", "idx": 14884, "substitutes": {"vlc": ["vrcs", "ell", "vrt", "vll", "flcs", "flv", "vlt", "wll", "vrv", "elvc", "vlvc", "lvl", "elcs", "elc", "vlv", "wlt", "lvvc", "lvc", "vlcs", "wlc", "wlcs", "wlvc", "lvcs", "vrc", "wlv", "flt", "flc"], "bits_table": [" bits_code", "bitslytmp", "bitsinglist", "bits_iterator", " bits_list", "bitsingtable", "bitslytable", "bitsitytmp", "bits_tmp", "bitsingiterator", " bits_iterator", "bitslycode", " bits_t", "bits_list", "bitsitylist", "bits_t", "bitsitytable", "bitsitycode", " bits_tmp", "bitslylist", "bitsingt", "bits_code"], "val_table": ["valistlist", "valistpublic", "valisttable", "vals_tab", " val_TABLE", " val_tab", "valisttab", "vals_list", "val_tab", "vals_table", "val_public", "vals_public", " val_list", "val_TABLE", "val_list"], "nb_codes": [" ngphpterms", " ng_codes", " ng_terms", "num_code", "num_codes", "nb__lines", " ng_code", "num_lines", "nb_levels", "nb_code", "nb_terms", "nb__code", "nb__codes", "nbphpcodes", "nbphpcode", " ngphpcode", " ngphplevels", "nbphplevels", " ng_levels", " ngphpcodes", "nb_lines", "nbphpterms"], "huff_size": ["hooditycode", "huf_Size", "hood_code", "huffitystorage", "huffLsize", "huf_global", "huffLSize", "huffLinfo", "huf_name", "huffitysize", "huff_info", "hooditysize", "hooditysmall", "hood_storage", "huffLcode", "huf_city", "hood_size", "huff_window", "huffitycode", "huf_code", "huffitysmall", "huffLwindow", "hood_small", "huff_name", "hooditystorage", "huff_storage", "huf_info", "huf_size", "huf_window", "huff_global", "huff_city", "huff_small", "huff_Size"], "huff_code": ["huff_error", "hUFF_number", "huff_type", "hUFF_size", "huff8Code", "hUFF__data", "huff__code", "hufflcode", "hUFF__Code", "huff_data", "hufflsize", "hUFF_code", "huff_Code", "huff__data", "huff_number", "huf_data", "hUFF_func", "huf_code", "huff8error", "hUFF__code", "hufflnumber", "huff__error", "huff_func", "huff8code", "hUFF_error", "hUFF_Code", "huff__Code", "huff8data", "huf_size", "huf_type", "hUFF_data", "hufflfunc", "hUFF__error"]}}
{"project": "qemu", "commit_id": "4d68e86bb10159099da0798f74e7512955f15eec", "target": 0, "func": "void qemu_coroutine_adjust_pool_size(int n)\n\n{\n\n    qemu_mutex_lock(&pool_lock);\n\n\n\n    pool_max_size += n;\n\n\n\n    /* Callers should never take away more than they added */\n\n    assert(pool_max_size >= POOL_DEFAULT_SIZE);\n\n\n\n    /* Trim oversized pool down to new max */\n\n    while (pool_size > pool_max_size) {\n\n        Coroutine *co = QSLIST_FIRST(&pool);\n\n        QSLIST_REMOVE_HEAD(&pool, pool_next);\n\n        pool_size--;\n\n        qemu_coroutine_delete(co);\n\n    }\n\n\n\n    qemu_mutex_unlock(&pool_lock);\n\n}\n", "idx": 14904, "substitutes": {"n": ["nl", "a", "o", "number", " fn", "dn", "cn", "l", "j", "p", "ln", "x", "names", "v", "g", " N", "na", "t", "num", "nt", "k", "m", "N", "s", "c", "count", "en", "nc", "ns", "b", "u", "d", "ity", "z", "sn", "i", "nm", "w", "nan", "y", "an", "nn"], "pool_size": ["poolpromax", "memory_capacity", "poollestorage", "policyproSIZE", "pool_limit", "poolablesize", "pool_SIZE", "poolproSIZE", "policyprosize", "poolablestorage", "policyprolimit", "poollecapacity", "memorylesize", "policypromax", "memoryleSIZE", "memory_storage", "poolprosize", "policy_SIZE", "memory_size", "poolleSIZE", "poolableSIZE", "policy_limit", "pool_storage", "memorylestorage", "pool_capacity", "poollesize", "policy_size", "memorylecapacity", "poolprolimit", "memory_SIZE", "pool_max", "policy_max", "poolablecapacity"], "co": ["vo", "cu", "oc", "o", "lc", "Co", " Co", "cc", "mo", "wo", "flo", "aco", "CO", "bo", "cover", "oo", "ko", "so", "occ", "ro", "xc", "fo", "nc", "po", "coord", "cons", "pc", "cho", "roo", "fc", "con", "ano", "coe", "pl", "lo", "gro", "cro", "coll", "ico"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void rndis_clear_responsequeue(USBNetState *s)\n\n{\n\n    struct rndis_response *r;\n\n\n\n    while ((r = s->rndis_resp.tqh_first)) {\n\n        TAILQ_REMOVE(&s->rndis_resp, r, entries);\n\n        qemu_free(r);\n\n    }\n\n}\n", "idx": 14911, "substitutes": {"s": ["ses", "aws", "gs", "S", "as", "serv", "bs", "less", "j", "n", "js", "p", "sq", "comm", "als", "is", "sv", "sb", "sys", "hs", "ds", "ls", "ats", "ts", "stats", "ares", "vs", "states", "ns", "b", "ops", "h", "fs", "os", "d", "its", "ss", "sts", "rs", "ps"], "r": ["rc", "rem", "rus", "rw", "lr", "rn", "pr", "ren", "l", "p", "mr", "j", "dr", "vr", "rl", "rf", "v", "g", "rar", "ar", "t", "ru", "er", "rm", "result", "rb", "br", "m", "rt", "c", "ro", "run", "sr", "ry", "res", "rg", "b", "h", "re", "rec", "fr", "e", "repl", "rd", "u", "d", "q", "i", "R", "rr", "rs"]}}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)\n\n{\n\n#if HAVE_YASM\n\n    int mm_flags = av_get_cpu_flags();\n\n\n\n    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {\n\n#if ARCH_X86_32\n\n        if (mm_flags & AV_CPU_FLAG_MMX) {\n\n            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;\n\n        }\n\n#endif\n\n\n\n        if (mm_flags & AV_CPU_FLAG_SSE2) {\n\n            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 14913, "substitutes": {"c": ["rc", "a", "co", "f", "tc", "cr", "o", "cf", "cm", "lc", "ctx", "p", "cc", "v", "t", "com", "dc", "cache", "ct", "cam", "m", "container", "ac", "C", "cv", "abc", "nc", "ec", "cp", "b", "gc", "cs", "bc", "h", "etc", "fc", "e", "con", "conf", "enc", "d", "config", "ca", "coll", "ce", "anc", "ch"], "codec": ["choEC", "codEC", "Codec", "Codocol", "cpocol", "Codisc", "Codoc", "choocol", "cpoder", "codeisc", "codeec", "choec", "codeoc", "cododer", " codEC", "codeEC", "cpec", "Cododer", "CodEC", " codisc", "codoc", "codisc", "codocol", "chooder", "cpEC", " codoc"]}}
{"project": "qemu", "commit_id": "b769d8fef6c06ddb39ef0337882a4f8872b9c2bc", "target": 0, "func": "int cpu_ppc_handle_mmu_fault (CPUState *env, uint32_t address, int rw,\n\n                              int is_user, int is_softmmu)\n\n{\n\n    uint32_t physical;\n\n    int prot;\n\n    int exception = 0, error_code = 0;\n\n    int access_type;\n\n    int ret = 0;\n\n\n\n//    printf(\"%s 0\\n\", __func__);\n\n    access_type = env->access_type;\n\n    if (env->user_mode_only) {\n\n        /* user mode only emulation */\n\n        ret = -2;\n\n        goto do_fault;\n\n    }\n\n    /* NASTY BUG workaround */\n\n    if (access_type == ACCESS_CODE && rw) {\n\n\tprintf(\"%s: ERROR WRITE CODE ACCESS\\n\", __func__);\n\n\taccess_type = ACCESS_INT;\n\n    }\n\n    ret = get_physical_address(env, &physical, &prot,\n\n                               address, rw, access_type);\n\n    if (ret == 0) {\n\n\tret = tlb_set_page(env, address & ~0xFFF, physical, prot,\n\n\t\t\t   is_user, is_softmmu);\n\n    } else if (ret < 0) {\n\n    do_fault:\n\n#if defined (DEBUG_MMU)\n\n\tif (loglevel > 0)\n\n\t    cpu_ppc_dump_state(env, logfile, 0);\n\n#endif\n\n        if (access_type == ACCESS_CODE) {\n\n            exception = EXCP_ISI;\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables */\n\n                error_code = EXCP_ISI_TRANSLATE;\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                error_code = EXCP_ISI_PROT;\n\n                break;\n\n            case -3:\n\n\t\t/* No execute protection violation */\n\n                error_code = EXCP_ISI_NOEXEC;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                /* No code fetch is allowed in direct-store areas */\n\n                error_code = EXCP_ISI_DIRECT;\n\n                break;\n\n            }\n\n        } else {\n\n            exception = EXCP_DSI;\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables */\n\n                error_code = EXCP_DSI_TRANSLATE;\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                error_code = EXCP_DSI_PROT;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                switch (access_type) {\n\n                case ACCESS_FLOAT:\n\n                    /* Floating point load/store */\n\n                    exception = EXCP_ALIGN;\n\n                    error_code = EXCP_ALIGN_FP;\n\n                    break;\n\n                case ACCESS_RES:\n\n                    /* lwarx, ldarx or srwcx. */\n\n                    exception = EXCP_DSI;\n\n                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT;\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    /* eciwx or ecowx */\n\n                    exception = EXCP_DSI;\n\n                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT |\n\n\t\t\tEXCP_DSI_ECXW;\n\n                    break;\n\n                default:\n\n\t\t    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    exception = EXCP_PROGRAM;\n\n                    error_code = EXCP_INVAL | EXCP_INVAL_INVAL;\n\n                    break;\n\n                }\n\n            }\n\n            if (rw)\n\n                error_code |= EXCP_DSI_STORE;\n\n\t    /* Store fault address */\n\n\t    env->spr[DAR] = address;\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\",\n\n               __func__, exception, error_code);\n\n#endif\n\n        env->exception_index = exception;\n\n        env->error_code = error_code;\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 14936, "substitutes": {"env": ["server", "rc", "nv", "esm", "ptr", "conn", "et", "manager", "sw", "environment", "cur", "setup", "addr", "cmd", "ctx", "hw", "dn", "window", "erd", "vp", "v", "next", "store", "esc", "er", "end", "rb", "desc", "ah", "context", "era", "obj", "ew", "gate", "shell", "org", "vm", "sp", "inv", "cv", "db", "en", "nc", "code", "vs", "cp", "dev", "tmp", "e", "conf", "entry", "enter", "eng", "ve", "ev", "vt", "te", "viron", "equ"], "address": ["index", "path", "record", "ptr", "route", "array", "position", "handle", "object", "addr", "uri", "relative", "reference", "resource", "port", "adr", "command", "offset", "r", "memory", "message", "description", "exclusive", "context", "attribute", "range", "add", "buffer", "page", "location", "password", "table", "device", "host", "order", "private", "interface", "network", "pointer", "Address", "ip"], "rw": ["wind", "fw", "rew", "nw", "username", "sw", "ptr", "route", "mem", "wx", "aw", "addr", "wb", "hw", "row", "rf", "raw", "window", "req", "access", "ru", "wa", "write", "rb", "nr", "r", "ew", "aux", "rt", "range", "work", "wer", "ro", "rh", "wp", "wd", "wr", "rd", "nb", "RW", "w", "rights", "rs"], "is_user": ["isdbUser", "is_or", "is2User", " is_or", "is_usr", " is_usr", "isdbuser", "is_User", "is2usr", "is2user", "isdbusr", " is_User"], "is_softmmu": ["is_SoftMMo", "is_softtmiu", "is_softtmu", "is_softmemus", "is_SoftmmU", "is_softtmuit", "is_southmmu", "is_softmcu", "is_SoftMMus", "is_softmciu", "is_softMMus", "is_softmmo", "is_softMMU", "is_southmciu", "is_Softmmo", "is_SoftMMu", "is_softmemu", "is_softmemo", "is_softmmU", "is_SoftMMU", "is_softmmiu", "is_softmcuit", "is_Softmmu", "is_softmmus", "is_softMMo", "is_softmmuit", "is_southmmiu", "is_Softmmus", "is_softMMu", "is_southmmuit", "is_southmcu", "is_softmemU", "is_southmcuit"], "physical": ["pro", "index", "protected", "path", "public", "type", "ptr", "phys", "primary", "ref", "local", "relative", "native", "p", "hw", "raw", "resource", "pixel", "information", "wm", "virtual", "port", "http", "hid", "real", "ocol", "np", "program", "specific", "health", "phy", "prefix", "console", "base", "restricted", "checked", "Physical", "binary", "pc", "serial", "host", "private", "tp", "total", "config", "net", "target", "network", "itary", "pointer"], "prot": ["pro", "protected", "type", "version", "ptr", "phys", "primary", "ports", "inet", "tif", "typ", "chron", "pattern", "reset", "virtual", "port", "io", "test", "ocol", "Prot", "np", " PROT", "mobile", "iot", "eth", "phy", "platform", "supported", "afi", "tf", "rot", "top", "prototype", "binary", "ort", "col", "transfer", "net", "format", "prop", "tp", "tech", "ip"], "access_type": ["access_operator", "accesstypemode", "Access_type", "accessetymethod", "accessibleedcolor", "access_post", "access_typ", "accessTypetype", "accessetyType", "accessTypeType", " access_method", "Access_Type", "accessedTYPE", " access_field", " access_length", "accesstypetyp", "access_method", "accessTypename", "accessingmode", "usage_post", "accessibleedlength", "accessetypost", "usage_typ", "accessetytyp", "accessinglength", "access_types", "accessingcolor", "access___types", "accesstypepost", "access_field", "Access_operator", "access_name", "accessibleedtype", "access2name", "accessTypeoperator", "accessetytype", "usage_mode", "accessedtype", "accessingpost", " access_name", "accesstypetype", "accessingtyp", "access_TYPE", "accessibleedTYPE", "usageingpost", "access_status", "usageingmode", "access_length", "access_Type", "access2type", "accessible_TYPE", "accessible_color", "access_mode", " access_status", "access___rule", "access___Type", "usageingtype", "access_rule", "accessetyfield", "accessetylength", "accessingTYPE", "access___type", "accessedlength", " access_TYPE", "accessible_length", "accessetymode", "accessetyTYPE", "Access_name", "accessedcolor", "access2Type", "accessible_type", "accessingtype", " access_Type", "usageingtyp", "usage_type", " access_types", "access_color", " access_rule"]}}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){\n\n    int y;\n\n    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;\n\n    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;\n\n\n\n    for(y=-2; y<height; y+=2){\n\n        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;\n\n        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;\n\n\n\n{START_TIMER\n\n        if(b1 <= b3)     horizontal_decompose53i(b2, width);\n\n        if(y+2 < height) horizontal_decompose53i(b3, width);\n\nSTOP_TIMER(\"horizontal_decompose53i\")}\n\n\n\n{START_TIMER\n\n        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);\n\n        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);\n\nSTOP_TIMER(\"vertical_decompose53i*\")}\n\n\n\n        b0=b2;\n\n        b1=b3;\n\n    }\n\n}\n", "idx": 14942, "substitutes": {"buffer": ["view", "allow", "face", "scroll", "button", "position", "background", "header", "data", "window", "reference", "Buffer", "pixel", "v", "surface", "pool", "port", "batch", "cache", "buf", "buff", "program", "memory", "message", "match", "available", "bridge", "document", "block", "page", "byte", "b", "table", "device", "seek", "iter", "uffer", "texture", "length", "queue", "history", "database", "screen"], "height": ["hang", "status", "kw", "view", "ty", "type", "yt", "oom", "wh", "kh", "density", " Height", "size", "high", "SIZE", "scope", "row", "depth", "window", "important", "family", "rows", "inches", " heights", "t", "padding", "rank", "bottom", "power", "Height", "th", "through", "hei", "html", "headers", "resolution", "stroke", "count", "capacity", "ht", "volume", "alpha", "h", "grow", "id", "H", "ows", "hash", "length", "gravity", "shape", "style", "sky", "visible", "TH", "above", "angle", "history", "ch"], "stride": ["stension", "strride", "stringide", "druse", "striend", "Strify", " strine", "stringify", "strine", "STRide", "Strine", "stade", "strend", "dride", "Stride", "Strride", "stend", "stine", "strpe", "STRade", "drride", " strride", "strage", "stify", "Struse", "strge", "stuse", "stage", "STRge", "strade", "Strension", "stge", "strension", "Strge", "stringension", "struse", "STRride", "stpe", "drend", "Strade", "Strpe", " strage", "stide", "Strage", "strify", "striuse", "stringride", "striide", "stripe", "Strend"], "y": ["uy", "oy", "py", "dy", "ya", "ay", "yr", "t", " ch", "ery", " h", "m", "iy", " dy", "lat", " v", "my", "yo", "ley", "by", "yt", "type", "asy", " cy", "ind", "j", "Y", "v", " ey", "try", " by", "aily", "icy", "vy", " Y", "ies", "ady", "hey", "yl", "i", "x", "yy", "key", "ty", "sy", "row", "yi", "now", "cy", " yo", "sim", " i", " py", "ry", " key", " x", "ot", "ey", " err", "ly", "ny", " j", "yout", " ly", "axy", "xy", "ym", "ye", " my", " ty", "yer", "h", "col", "sky", "z", "gy", "sat", "ch"], "b0": ["barg", "bb000", "harg", "h2", "be3", "p1", "bc0", "B0", "bearg", "v3", "v1", "cb0", "v0", "cb00", "cb1", "h1", "cb3", " barg", "bb3", "h0", "p2", "b00", "v2", " b000", "p0", "be0", "bc1", "B1", "bc2", "h3", "bc000", "bb1", "bb0", "bb00", "be1", "B3", "b000", "bb2", "B00", "p3"], "b1": ["e2", "bone", "p1", "bb9", "br4", "bb001", "B8", "b001", "bb7", "br1", " b4", "e1", "bbone", "bb3", "br2", "p2", "B2", "br7", "a1", "brone", "br01", " b7", "e9", "B1", "p0", "back001", "e01", "p3", "b7", "bb4", "b9", "b8", " bone", "b01", "back1", "a2", "a3", " b9", " b001", "bb1", "b4", "back3", " b01", "B3", "a0", " b8", "bb8", "bb2", "B0", "bb01"], "b2": ["gb2", "back0", "p1", "gb4", "v3", "l2", "bb5", "ltwo", "v1", "l1", "v0", "backtwo", "eb2", "sb0", " b4", "back2", "bTwo", "fb1", "ebTwo", "bbtwo", "bb3", "bbTwo", "p2", "v2", "eb5", "B2", " bTwo", "l3", "a1", "sb1", "fbtwo", "B1", "p0", "fb2", " b5", "p3", "vtwo", "b5", "fb3", "bb4", "sb2", " btwo", "eb1", "a2", "a02", "back3", "bb1", "b4", "bb0", "B3", "gb1", "btwo", "a0", "b02", "bb02", "gbtwo", "bb2", "sb02", "B0"], "b3": ["rb3", "ba2", "bothree", "bdthree", "b03", "bbThree", "bd3", "betaThree", "bg53", "rb2", "b63", "sb2", "bo512", "a3", "b53", "b512", "b4", "bb2", "p3", "wb23", "bb5", "ba63", "rb03", "p2", "bg4", "sb3", "aThree", "ba512", "ba23", "b7", "beta5", "bg3", "bg2", "be3", "wbthree", "beta1", "wb63", "bo3", "bThree", "bthree", "bathree", "bbthree", "be2", "b23", " bThree", "wb3", "bb03", "b5", "beta3", "bb1", "p4", "bd7", "bb63", "sb03", " b512", "ba3", "rbthree", "bdThree", "cbThree", "be53", "cb7", "cb3", "cbthree", "bb3", "a1", " b7", "bb23", "be4", "a5", " bthree", "bo2", "sbthree", "p53"]}}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    int ret, fd;\n\n    unsigned int datalen;\n\n\n\n    if (offset < s->inode.vdi_size) {\n\n        error_report(\"shrinking is not supported\");\n\n        return -EINVAL;\n\n    } else if (offset > SD_MAX_VDI_SIZE) {\n\n        error_report(\"too big image size\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n\n\n    /* we don't need to update entire object */\n\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n\n    s->inode.vdi_size = offset;\n\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n\n    close(fd);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"failed to update an inode.\");\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 14951, "substitutes": {"bs": ["gs", "ubs", "aos", "js", "bits", "bh", "bi", "bes", "als", "sb", "aus", "hs", "cks", "ds", "ls", "iss", "BS", "ts", "bos", "bm", "bf", "bas", "vs", "ils", "b", "ns", "cs", "bc", "lbs", "fs", "os", "bis", "bb", "its", "bp", "ss", "rs"], "offset": ["index", "key", "error", "shift", "o", "position", "ref", "offs", "size", "address", "addr", "mask", "row", "Offset", "timeout", "after", "reset", "loc", "padding", "before", "origin", "end", "skip", "num", "fee", "url", "off", "slot", "prefix", "range", "block", "count", "pos", "location", "alias", "start", "set", "seek", "ace", "entry", "trace", "from", "length", "pad", "to", "zero", "expected", "point", "pointer"], "s": ["sis", "ses", "gs", "S", "settings", "sq", "plays", "sl", "sam", "st", "m", "qs", "stats", "states", "cs", "ims", "its", "https", "ps", "js", "v", "g", "comm", "spec", "ds", "ats", "sa", "services", "ies", "so", " ss", "parts", "south", "a", "as", "bits", "xs", "als", "sb", "hs", "sys", "ess", "c", "ares", "ops", "es", "changes", "state", "bis", "sports", "ss", "aws", "l", "p", "details", "is", "sv", "ls", "gets", "ts", "sp", "ins", "b", "ns", "h", "sd", "w", "sts", "ms", "y", "rs"], "ret": ["resp", "status", "rem", "def", "il", "leg", "xt", "at", "f", "ptr", "out", "inter", "por", "det", "ll", "fun", "cmd", "back", "Ret", "tr", "reply", "rets", "RET", "val", "reset", "deg", "try", "len", "ert", "rm", "result", "ext", "tn", "nt", "r", "alt", "att", "gt", "rt", "lt", "res", "flag", "print", "cert", "re", "mt", "ft", "arg", "it", "elt", " Ret", "del", "fin", "ter", "usr", "cont", "arr"], "fd": ["resp", "td", "cf", "fed", "f", "ptr", "lf", "handle", "por", "dn", "ff", "cond", "fun", "ind", "ctx", "ln", "tif", "dl", "dir", "cd", "dt", "pd", "fail", "port", "fe", "fm", "gb", "result", "func", "ds", "nt", "dd", "disk", "gd", "fb", "bd", "hd", "handler", "cb", "db", "fp", "file", "bf", "fn", "df", "red", "FD", "fc", "fr", "tmp", "fs", "pid", "ft", "d", "fi", "raf", "uf", "err", "failed", "nil", "dat", "tty", "fa", "fin", "endif", "ld", "dra"], "datalen": ["datalist", "dialen", "dalize", "dalef", " damelist", "dialon", "damelef", "dallun", "damelon", "datalef", " datalist", "tatalef", "datlun", "datlen", "dalun", "datenist", "datlize", "tatalize", "damelun", "damelength", " datalun", "dallength", "dalen", "Datalen", "Datalun", "tamelen", " damelen", " damelun", "dalength", "datalun", "tamelef", "datenun", "datalength", "dalon", "dallen", "Datlize", "Datlen", "damelize", "datalize", "dialef", "Datlength", "datlength", "datenen", "tatalon", "dialize", "Datalize", "damelist", "Datlun", "Datalength", " damelength", "tamelize", "damelen", "datalon", "datenength", "dallist", "tamelon", " datalength", "dallize", "tatalen"]}}
{"project": "qemu", "commit_id": "190563f9a90c9df8ad32fc7f3e4b166deda949a6", "target": 0, "func": "static int rndis_parse(USBNetState *s, uint8_t *data, int length)\n\n{\n\n    uint32_t msg_type;\n\n    le32 *tmp = (le32 *) data;\n\n\n\n    msg_type = le32_to_cpup(tmp);\n\n\n\n    switch (msg_type) {\n\n    case RNDIS_INITIALIZE_MSG:\n\n        s->rndis_state = RNDIS_INITIALIZED;\n\n        return rndis_init_response(s, (rndis_init_msg_type *) data);\n\n\n\n    case RNDIS_HALT_MSG:\n\n        s->rndis_state = RNDIS_UNINITIALIZED;\n\n        return 0;\n\n\n\n    case RNDIS_QUERY_MSG:\n\n        return rndis_query_response(s, (rndis_query_msg_type *) data, length);\n\n\n\n    case RNDIS_SET_MSG:\n\n        return rndis_set_response(s, (rndis_set_msg_type *) data, length);\n\n\n\n    case RNDIS_RESET_MSG:\n\n        rndis_clear_responsequeue(s);\n\n        s->out_ptr = s->in_ptr = s->in_len = 0;\n\n        return rndis_reset_response(s, (rndis_reset_msg_type *) data);\n\n\n\n    case RNDIS_KEEPALIVE_MSG:\n\n        /* For USB: host does this every 5 seconds */\n\n        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);\n\n    }\n\n\n\n    return USB_RET_STALL;\n\n}\n", "idx": 14982, "substitutes": {"s": ["ses", "gs", "S", "bs", "sq", "stat", "sam", "t", "qs", "ssl", "ads", "stats", "vs", "cs", "tests", "ims", "its", "sn", "ps", "sw", "j", "n", "js", "v", "g", "http", "comm", "spec", "space", "ds", "ats", "services", "ies", "sync", "set", "conf", "south", "as", "less", "xs", "als", "sb", "er", "hs", "sys", "c", "es", "changes", "fs", "bis", "d", "sports", "ss", "aws", "l", "p", "details", "is", "sv", "ls", "r", "ches", "ts", "ins", "ns", "b", "h", "os", "w", "sts", "ms", "y", "rs"], "data": ["bytes", "def", "received", "error", "rew", "as", "attr", "aw", "size", "addr", "p", "bits", "window", "raw", "what", " DATA", "params", "ord", "text", "chain", "test", "done", "batch", "t", "nd", "advert", "apps", "cache", "buf", "bin", "ext", "new", "ds", "nt", "da", "dump", "message", "extra", "obj", "items", "mu", "empty", "block", "buffer", "trans", "Data", "ops", "device", "table", "args", "dev", "ns", "partial", "input", "any", "pad", "d", "to", "DATA", "ata", "value", "dat", "name", "form"], "length": ["Length", "amount", "type", "frequency", "ptr", "number", "position", "size", "family", "l", "address", "n", "height", "load", " clen", "len", "padding", "end", "ENGTH", "offset", "message", "ength", "time", "idth", " lengths", "buffer", "count", "capacity", " l", "enth", "h", "ish", "partial", " len", "duration", "pad", "total", "shape", "z", "join", "full"], "msg_type": [" msg_name", "msgTypename", "cmp_Type", "msgTypeType", "msg_id", "msg_name", " msg_id", "msg_t", " msg_Type", "msgTypetype", "cmp_type", " msg_t", " msg_size", "msg_Type", "msg_size", "msg_typ", "cmp_typ", "msgTypesize"], "tmp": ["yy", "bytes", "same", "tv", "attr", "ctx", "tt", "aaa", "important", "cmp", "lib", "temp", "proc", "mk", "perm", "mint", "xy", "t", "msg", "buf", "buff", "np", "stuff", "nt", "obj", "mm", "sp", "cb", "img", "mp", "etc", "partial", "mb", "sup", "emp", "tm", "needed", "txt"]}}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static int sap_write_header(AVFormatContext *s)\n\n{\n\n    struct SAPState *sap = s->priv_data;\n\n    char host[1024], path[1024], url[1024], announce_addr[50] = \"\";\n\n    char *option_list;\n\n    int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;\n\n    AVFormatContext **contexts = NULL;\n\n    int ret = 0;\n\n    struct sockaddr_storage localaddr;\n\n    socklen_t addrlen = sizeof(localaddr);\n\n    int udp_fd;\n\n    AVDictionaryEntry* title = av_dict_get(s->metadata, \"title\", NULL, 0);\n\n\n\n    if (!ff_network_init())\n\n        return AVERROR(EIO);\n\n\n\n    /* extract hostname and port */\n\n    av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &base_port,\n\n                 path, sizeof(path), s->filename);\n\n    if (base_port < 0)\n\n        base_port = 5004;\n\n\n\n    /* search for options */\n\n    option_list = strrchr(path, '?');\n\n    if (option_list) {\n\n        char buf[50];\n\n        if (av_find_info_tag(buf, sizeof(buf), \"announce_port\", option_list)) {\n\n            port = strtol(buf, NULL, 10);\n\n        }\n\n        if (av_find_info_tag(buf, sizeof(buf), \"same_port\", option_list)) {\n\n            same_port = strtol(buf, NULL, 10);\n\n        }\n\n        if (av_find_info_tag(buf, sizeof(buf), \"ttl\", option_list)) {\n\n            ttl = strtol(buf, NULL, 10);\n\n        }\n\n        if (av_find_info_tag(buf, sizeof(buf), \"announce_addr\", option_list)) {\n\n            av_strlcpy(announce_addr, buf, sizeof(announce_addr));\n\n        }\n\n    }\n\n\n\n    if (!announce_addr[0]) {\n\n        struct addrinfo hints = { 0 }, *ai = NULL;\n\n        hints.ai_family = AF_UNSPEC;\n\n        if (getaddrinfo(host, NULL, &hints, &ai)) {\n\n            av_log(s, AV_LOG_ERROR, \"Unable to resolve %s\\n\", host);\n\n            ret = AVERROR(EIO);\n\n            goto fail;\n\n        }\n\n        if (ai->ai_family == AF_INET) {\n\n            /* Also known as sap.mcast.net */\n\n            av_strlcpy(announce_addr, \"224.2.127.254\", sizeof(announce_addr));\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n        } else if (ai->ai_family == AF_INET6) {\n\n            /* With IPv6, you can use the same destination in many different\n\n             * multicast subnets, to choose how far you want it routed.\n\n             * This one is intended to be routed globally. */\n\n            av_strlcpy(announce_addr, \"ff0e::2:7ffe\", sizeof(announce_addr));\n\n#endif\n\n        } else {\n\n            freeaddrinfo(ai);\n\n            av_log(s, AV_LOG_ERROR, \"Host %s resolved to unsupported \"\n\n                                    \"address family\\n\", host);\n\n            ret = AVERROR(EIO);\n\n            goto fail;\n\n        }\n\n        freeaddrinfo(ai);\n\n    }\n\n\n\n    sap->protocols = ffurl_get_protocols(NULL, NULL);\n\n    if (!sap->protocols) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    contexts = av_mallocz(sizeof(AVFormatContext*) * s->nb_streams);\n\n    if (!contexts) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    s->start_time_realtime = av_gettime();\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        URLContext *fd;\n\n\n\n        ff_url_join(url, sizeof(url), \"rtp\", NULL, host, base_port,\n\n                    \"?ttl=%d\", ttl);\n\n        if (!same_port)\n\n            base_port += 2;\n\n        ret = ffurl_open(&fd, url, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL,\n\n                         sap->protocols);\n\n        if (ret) {\n\n            ret = AVERROR(EIO);\n\n            goto fail;\n\n        }\n\n        ret = ff_rtp_chain_mux_open(&contexts[i], s, s->streams[i], fd, 0, i);\n\n        if (ret < 0)\n\n            goto fail;\n\n        s->streams[i]->priv_data = contexts[i];\n\n        s->streams[i]->time_base = contexts[i]->streams[0]->time_base;\n\n        av_strlcpy(contexts[i]->filename, url, sizeof(contexts[i]->filename));\n\n    }\n\n\n\n    if (s->nb_streams > 0 && title)\n\n        av_dict_set(&contexts[0]->metadata, \"title\", title->value, 0);\n\n\n\n    ff_url_join(url, sizeof(url), \"udp\", NULL, announce_addr, port,\n\n                \"?ttl=%d&connect=1\", ttl);\n\n    ret = ffurl_open(&sap->ann_fd, url, AVIO_FLAG_WRITE,\n\n                     &s->interrupt_callback, NULL, sap->protocols);\n\n    if (ret) {\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n\n\n    udp_fd = ffurl_get_file_handle(sap->ann_fd);\n\n    if (getsockname(udp_fd, (struct sockaddr*) &localaddr, &addrlen)) {\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n    if (localaddr.ss_family != AF_INET\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n        && localaddr.ss_family != AF_INET6\n\n#endif\n\n        ) {\n\n        av_log(s, AV_LOG_ERROR, \"Unsupported protocol family\\n\");\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n    sap->ann_size = 8192;\n\n    sap->ann = av_mallocz(sap->ann_size);\n\n    if (!sap->ann) {\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n    sap->ann[pos] = (1 << 5);\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n    if (localaddr.ss_family == AF_INET6)\n\n        sap->ann[pos] |= 0x10;\n\n#endif\n\n    pos++;\n\n    sap->ann[pos++] = 0; /* Authentication length */\n\n    AV_WB16(&sap->ann[pos], av_get_random_seed());\n\n    pos += 2;\n\n    if (localaddr.ss_family == AF_INET) {\n\n        memcpy(&sap->ann[pos], &((struct sockaddr_in*)&localaddr)->sin_addr,\n\n               sizeof(struct in_addr));\n\n        pos += sizeof(struct in_addr);\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n    } else {\n\n        memcpy(&sap->ann[pos], &((struct sockaddr_in6*)&localaddr)->sin6_addr,\n\n               sizeof(struct in6_addr));\n\n        pos += sizeof(struct in6_addr);\n\n#endif\n\n    }\n\n\n\n    av_strlcpy(&sap->ann[pos], \"application/sdp\", sap->ann_size - pos);\n\n    pos += strlen(&sap->ann[pos]) + 1;\n\n\n\n    if (av_sdp_create(contexts, s->nb_streams, &sap->ann[pos],\n\n                      sap->ann_size - pos)) {\n\n        ret = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n    av_freep(&contexts);\n\n    av_log(s, AV_LOG_VERBOSE, \"SDP:\\n%s\\n\", &sap->ann[pos]);\n\n    pos += strlen(&sap->ann[pos]);\n\n    sap->ann_size = pos;\n\n\n\n    if (sap->ann_size > sap->ann_fd->max_packet_size) {\n\n        av_log(s, AV_LOG_ERROR, \"Announcement too large to send in one \"\n\n                                \"packet\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_free(contexts);\n\n    sap_write_close(s);\n\n    return ret;\n\n}\n", "idx": 15001, "substitutes": {"s": ["aws", "gs", "a", "S", "f", "as", "settings", "o", "socket", "l", "j", "n", "p", "js", "series", "v", "details", "t", "spec", "sv", "service", "hs", "sys", "ds", "ats", "ls", "m", "r", "qs", "ts", "self", "c", "stats", "ns", "b", "cs", "h", "ims", "es", "e", "fs", "conf", "os", "z", "sports", "ss", "sts", "w", "rs", "ps"], "sap": ["hsaps", "hsac", "hsap", "saps", "unsac", "sac", "sAP", "hsAP", "Saps", "unsAP", "SAP", "Sap", "Sac", "unsap", "unsaps"], "host": ["node", "server", "key", "type", "conn", "local", "socket", "handle", "address", "addr", "uri", "cmd", "hw", "dir", "ha", "http", "port", "localhost", "loc", "domain", "mac", " Host", "context", "Host", "hop", "subject", "prefix", "org", "container", "handler", "hd", "ost", "base", "link", "client", "h", "id", "root", "dev", "iter", "target", "pkg", "home", "hook", "name", "str", "ip"], "path": ["key", "type", "route", "href", "local", "query", "handle", "data", "l", "PATH", "cmd", "p", "uri", "stream", "stat", "ath", "dir", "pattern", "filename", "text", "port", "loc", "kind", "spec", "lang", "php", "template", "message", "context", "prefix", "file", "base", "Path", "link", "alias", "client", "id", "transform", "length", "config", "format", "package", "prop", "pl", "pkg", "filter", "name", "history"], "url": ["server", "nl", "href", "src", "ref", "address", "ll", "addr", "uri", "l", "str", "text", "http", "sl", "loc", "ssl", "api", "file", "base", "link", "ul", "alias", "cert", "id", "net", "URL", "https", "ip"], "announce_addr": ["announceablehost", "announce2host", "announced_adr", "announce_host", "announced2host", "announce_link", "announceableaddr", "announced_address", "announceiphost", "announceipaddr", "announced_host", "announced2add", "announce2addr", "announced_add", "announced_link", "announce_adr", "announceipadd", "announce_add", "announce2add", "announced2addr", "announce_address", "announced_addr", "announceableaddress"], "option_list": ["option_type", " option2data", "optionitylists", "option_name", " option2name", " option2drop", "optionListgroup", "optionListlist", " option_status", "Option_len", " option_single", "optionitylist", "option_len", "optionitystatus", " option_group", "option67list", "option7cont", "option2type", " option2list", " option2cont", " option2set", "option_group", "Option_list", "option7lists", "option7LIST", "option67drop", " option_set", "option_data", "optionitylisted", "optionityList", "option_tree", "option_status", "option0data", "option2cont", "option_drop", "option67type", "option_set", "option_def", "option2single", "option2list", "option2LIST", " option_tag", "Option_listed", "option2drop", "option67LIST", " option_data", "option_lists", "optionitydef", "option2tree", " option_drop", "option7tag", "option2name", " option2type", " option2tree", " option_type", " option_LIST", " option2LIST", " option_tree", "option67single", "option0type", "optionitylen", " option2group", "option_single", "optionListname", " option_lists", " option_cont", "option0single", "option7list", "option2set", "option_cont", " option_name", "Option_List", " option_def", "option_listed", "option_List", "option_LIST", "option_tag", "option67data", "option2group", "option67cont", "option2data", "option0list", " option2single", "option7drop"], "i": ["index", "a", "f", "ii", "mi", "I", "pi", "l", "j", "p", "n", "g", "bi", "t", "ia", "k", "m", "r", "c", "b", "id", "e", "ti", "it", "x", "ix", "ip"], "contexts": ["loges", "Contextions", "contextions", "logs", "textals", "texts", "textes", "logions", "Contextes", "logals", "Contextals", "textions", "contextals", "contextes", "Contexts"], "localaddr": [" localhost", "remoteaddress", "Localhost", "Localaddress", "localhost", "remoteip", "Localaddr", "remoteaddr", "localip", "remotehost", "localaddress", "Localip", " localip", " localaddress"], "udp_fd": ["udp8fd", "udport_fin", "udp_dir", "udport_FD", "udp8dir", "udp2fd", "udp2FD", "udport2dir", "udp_fin", "udp2fin", "udport_fd", "udp_FD", "udport2fd", "udp8fin", "udport2fin", "udport2FD", "udp8FD", "udp2dir", "udport_dir"], "title": [" name", " t", " alt", " info", " foo", "feat", " entries", " metadata", " tmp", " ti", " conn", "details", "Title", "itle", " va", " header", "desc", " msg", " tc", " addr", " titles", " entry", " details", "alias", "ame", " desc", " parent", "name"], "buf": ["browser", "vec", "orig", "cur", "ctx", "window", "raw", "pool", "port", " buffer", "doc", "cb", "caps", "uf", "queue", "pkg", "tx", "mem", "data", "cmd", "aka", "tr", "Buffer", "conv", "box", "comm", "buff", "cat", "br", "cfg", "obj", "fb", "db", "cp", "pg", "font", "tmp", "tab", "txt", "history", "Buff", "seq", "wb", "temp", "proc", "vp", "text", "batch", "np", "rb", "bn", "mu", "buffer", "cv", "bc", "bed", "iter", "err", "bar", "bytes", "pb", "bt", "cap", "act", "cam", "desc", "xff", "bag", "off", "page", "img", "b", "pad", "var", "prop", "bp", "nm"], "ai": ["ae", "am", "li", "a", "aa", "au", "ii", "mi", "aim", "ei", "aka", "aj", "si", "aki", "ali", "aq", "arm", "bi", "aii", "ia", "di", "asi", "ami", "sa", "hi", "pai", "qi", "ais", "AI", "aci", "air", "ci", "ati", "ti", "hai", "audi", "av", "ao", "an", "ait"], "pos": ["pro", "index", "position", "ref", "pi", "seq", "ind", "ff", "p", "cmp", "pt", "len", "loc", "origin", "prot", "offset", "limit", "po", "slice", "pc", "id", "rel", "pid", "ps", "priority", "pose"]}}
{"project": "FFmpeg", "commit_id": "ef23bd939d955f53bc58696bbb68960784066894", "target": 1, "func": "static void hls_prediction_unit(HEVCContext *s, int x0, int y0,\n\n                                int nPbW, int nPbH,\n\n                                int log2_cb_size, int partIdx, int idx)\n\n{\n\n#define POS(c_idx, x, y)                                                              \\\n\n    &s->frame->data[c_idx][((y) >> s->sps->vshift[c_idx]) * s->frame->linesize[c_idx] + \\\n\n                           (((x) >> s->sps->hshift[c_idx]) << s->sps->pixel_shift)]\n\n    HEVCLocalContext *lc = s->HEVClc;\n\n    int merge_idx = 0;\n\n    struct MvField current_mv = {{{ 0 }}};\n\n\n\n    int min_pu_width = s->sps->min_pu_width;\n\n\n\n    MvField *tab_mvf = s->ref->tab_mvf;\n\n    RefPicList  *refPicList = s->ref->refPicList;\n\n    HEVCFrame *ref0, *ref1;\n\n    uint8_t *dst0 = POS(0, x0, y0);\n\n    uint8_t *dst1 = POS(1, x0, y0);\n\n    uint8_t *dst2 = POS(2, x0, y0);\n\n    int log2_min_cb_size = s->sps->log2_min_cb_size;\n\n    int min_cb_width     = s->sps->min_cb_width;\n\n    int x_cb             = x0 >> log2_min_cb_size;\n\n    int y_cb             = y0 >> log2_min_cb_size;\n\n    int x_pu, y_pu;\n\n    int i, j;\n\n\n\n    int skip_flag = SAMPLE_CTB(s->skip_flag, x_cb, y_cb);\n\n\n\n    if (!skip_flag)\n\n        lc->pu.merge_flag = ff_hevc_merge_flag_decode(s);\n\n\n\n    if (skip_flag || lc->pu.merge_flag) {\n\n        if (s->sh.max_num_merge_cand > 1)\n\n            merge_idx = ff_hevc_merge_idx_decode(s);\n\n        else\n\n            merge_idx = 0;\n\n\n\n        ff_hevc_luma_mv_merge_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                                   partIdx, merge_idx, &current_mv);\n\n    } else {\n\n        hevc_luma_mv_mpv_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                              partIdx, merge_idx, &current_mv);\n\n    }\n\n\n\n    x_pu = x0 >> s->sps->log2_min_pu_size;\n\n    y_pu = y0 >> s->sps->log2_min_pu_size;\n\n\n\n    for (j = 0; j < nPbH >> s->sps->log2_min_pu_size; j++)\n\n        for (i = 0; i < nPbW >> s->sps->log2_min_pu_size; i++)\n\n            tab_mvf[(y_pu + j) * min_pu_width + x_pu + i] = current_mv;\n\n\n\n    if (current_mv.pred_flag & PF_L0) {\n\n        ref0 = refPicList[0].ref[current_mv.ref_idx[0]];\n\n        if (!ref0)\n\n            return;\n\n        hevc_await_progress(s, ref0, &current_mv.mv[0], y0, nPbH);\n\n    }\n\n    if (current_mv.pred_flag & PF_L1) {\n\n        ref1 = refPicList[1].ref[current_mv.ref_idx[1]];\n\n        if (!ref1)\n\n            return;\n\n        hevc_await_progress(s, ref1, &current_mv.mv[1], y0, nPbH);\n\n    }\n\n\n\n    if (current_mv.pred_flag == PF_L0) {\n\n        int x0_c = x0 >> s->sps->hshift[1];\n\n        int y0_c = y0 >> s->sps->vshift[1];\n\n        int nPbW_c = nPbW >> s->sps->hshift[1];\n\n        int nPbH_c = nPbH >> s->sps->vshift[1];\n\n\n\n        luma_mc_uni(s, dst0, s->frame->linesize[0], ref0->frame,\n\n                    &current_mv.mv[0], x0, y0, nPbW, nPbH,\n\n                    s->sh.luma_weight_l0[current_mv.ref_idx[0]],\n\n                    s->sh.luma_offset_l0[current_mv.ref_idx[0]]);\n\n\n\n        chroma_mc_uni(s, dst1, s->frame->linesize[1], ref0->frame->data[1], ref0->frame->linesize[1],\n\n                      0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]);\n\n        chroma_mc_uni(s, dst2, s->frame->linesize[2], ref0->frame->data[2], ref0->frame->linesize[2],\n\n                      0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1]);\n\n    } else if (current_mv.pred_flag == PF_L1) {\n\n        int x0_c = x0 >> s->sps->hshift[1];\n\n        int y0_c = y0 >> s->sps->vshift[1];\n\n        int nPbW_c = nPbW >> s->sps->hshift[1];\n\n        int nPbH_c = nPbH >> s->sps->vshift[1];\n\n\n\n        luma_mc_uni(s, dst0, s->frame->linesize[0], ref1->frame,\n\n                    &current_mv.mv[1], x0, y0, nPbW, nPbH,\n\n                    s->sh.luma_weight_l1[current_mv.ref_idx[1]],\n\n                    s->sh.luma_offset_l1[current_mv.ref_idx[1]]);\n\n\n\n        chroma_mc_uni(s, dst1, s->frame->linesize[1], ref1->frame->data[1], ref1->frame->linesize[1],\n\n                      1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0]);\n\n\n\n        chroma_mc_uni(s, dst2, s->frame->linesize[2], ref1->frame->data[2], ref1->frame->linesize[2],\n\n                      1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1]);\n\n    } else if (current_mv.pred_flag == PF_BI) {\n\n        int x0_c = x0 >> s->sps->hshift[1];\n\n        int y0_c = y0 >> s->sps->vshift[1];\n\n        int nPbW_c = nPbW >> s->sps->hshift[1];\n\n        int nPbH_c = nPbH >> s->sps->vshift[1];\n\n\n\n        luma_mc_bi(s, dst0, s->frame->linesize[0], ref0->frame,\n\n                   &current_mv.mv[0], x0, y0, nPbW, nPbH,\n\n                   ref1->frame, &current_mv.mv[1], &current_mv);\n\n\n\n        chroma_mc_bi(s, dst1, s->frame->linesize[1], ref0->frame, ref1->frame,\n\n                     x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 0);\n\n\n\n        chroma_mc_bi(s, dst2, s->frame->linesize[2], ref0->frame, ref1->frame,\n\n                     x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 1);\n\n    }\n\n}\n", "idx": 15002, "substitutes": {"s": ["aws", "ses", "ashes", "gs", "a", "S", "south", "f", "as", "serv", "bs", "sw", "less", "ports", "p", "js", "n", "ex", "params", "conv", "v", "xs", "details", "bes", "t", "comm", "is", "sb", "sv", "spec", "hs", "sys", "ds", "ls", "ats", "times", "in", "gets", "qs", "sc", "sim", "ts", "c", "stats", "ins", "states", "ns", "ops", "cs", "args", "es", "ims", "changes", "fs", "os", "its", "se", "z", "sports", "ss", "sts", "w", "sets", "scl", "rs", "ps"], "x0": ["x4", "ox1", "rx00", "path0", " x1", "ix1", "ix3", "path00", "x_", "rx0", "ex_", "ix2", " x2", "ex1", "ix_", "y3", "ix0", "x2", "y1", "x00", " x4", " x_", "x1", "ex0", "ox00", "x3", "ex2", "y4", "ox0", " x3", "ix4"], "y0": ["y2", "gy1", "cy0", "y30", "skyarg", "yZero", "cy1", "ayarg", "ry2000", "ny0", "yElement", "gyZero", "ryZero", "y2000", "Y30", "y000", " yarg", "ry2", "sky0", "ry0", "Y0", "ny2", "y03", "ny03", "Y1", "y1", "oy2000", "gyElement", " y2", "ryElement", " y30", "oyZero", "x1", "ay000", "sky000", "ry03", "ay0", "gy2000", " y000", "oy0", "yarg", " y03", "cy30", "oyElement", " y1", "gy0"], "nPbW": ["nNnW", "nPww", "nPwW", "nPnV", "nNbw", "nNbWidth", "nPbw", "nPnW", "nNnV", "nPbWidth", "nPwV", "nPcWidth", "nPcV", "nPbV", "nPnWidth", "nNnWidth", "nPcW", "nNbV", "nNnw", "nPwWidth", "nNbW", "nPcw", "nPnw"], "nPbH": ["nPPbW", "nPcY", "nPcH", "nPPpW", "nPPbH", "nPPbY", "nPcHeight", "nPPpY", "nPpH", "nPpW", "nPdY", "nPdH", "nPdW", "nPPbHeight", "nPdHeight", "nPpHeight", "nPcW", "nPPpHeight", "nPpY", "nPbHeight", "nPbY", "nPPpH"], "log2_cb_size": ["log2_cb_scale", "log2_rb_size", "log2_cb2SIZE", "log2_cbPSIZE", "log2_cbPscale", "log2_rb_Size", "log2_cb_SIZE", "log2_rb_SIZE", "log2_rb_scale", "log2_cb_Size", "log2_cb2Size", "log2_cb2scale", "log2_cb2size", "log2_cbPsize", "log2_cbPSize"], "partIdx": ["partIdn", "partIDx", "PartIdX", "partidx", "PartIdn", "Partidx", "partIndX", "Partidn", "PartidX", "Partidz", "partIDz", "partidz", "PartIdx", "partIdX", "partIdz", "partIndx", "partIDX", "partIndn", "partidn", "partIDn", "PartIdz", "partIndz", "partidX"], "idx": ["idxf", "ridx", "idxc", "Idxf", "ridxc", "midx", "Idx", "midxc", "midX", "ridxf", "Idxc", "midxf", "IdX", "idX", "ridX"], "lc": ["ctl", "cf", "tl", "unc", "tc", "lf", "cm", "lr", "ll", "l", "ctx", "ln", "LC", "rl", "dl", "cc", "sb", "dc", "lb", "cl", "ls", "cell", "lua", "c", "cb", "lp", "cv", "xc", "ec", "kl", "cp", "gc", "mc", "ctrl", "bc", "lv", "cs", "pc", "fc", "cow", "hl", "vc", "sc"], "tab_mvf": ["tab_movp", "tab_mvefield", "tab_mvcF", "tab_muvfield", "tab_mvcf", "tab_pvp", "tab_mvfield", "tab_Mvfield", "tab_mvF", "tab_pavfield", "tab_mavfield", "tab_mvfile", "tab_mavF", "tab_movfield", "tab_mavp", "tab_Mvefield", "tab_pvf", "tab_pvfield", "tab_movf", "tab_Mvef", "tab_mavf", "tab_muvp", "tab_pavp", "tab_mvp", "tab_mveF", "tab_mvcfield", "tab_pavf", "tab_muvf", "tab_mavfile", "tab_Mvf", "tab_mvcfile", "tab_mvef", "tab_Mvfile", "tab_MvF", "tab_Mvefile", "tab_mvefile", "tab_MveF"], "refPicList": ["tabParlist", "refParList", "RefpicGroup", "refCapGroup", "refParL", "refPropCache", "refPictureList", "RefpicList", "refPiclist", "refPictureL", "RefpicSet", "tabPicList", "refPicSet", "RefPicGroup", "refPicL", "refpicGroup", "tabPicL", "refCapList", "refPropList", "refpicSet", "refCapSet", "refpiclist", "tabPiclist", "refPropSet", "refCapCache", "refPropGroup", "refPicCache", "refpicList", "refPicturelist", "tabParL", "RefPicCache", "refpicCache", "refPicGroup", "RefPicList", "RefpicCache", "refParlist", "RefPicSet", "refpicL", "tabParList"], "ref0": ["Ref1", "Ref2", " ref2", "reference2", "reference0", "Ref0", "ref2", "reference1"], "ref1": ["Ref1", "Ref2", " ref2", "refOne", "referenceOne", "reference2", " refOne", "RefOne", "ref2", "reference1"], "dst0": ["DST0", "dST5", "dstr5", "dstr1", "Dst0", "dst5", "dST0", "dST1", "DST1", "Dst1", "ddest1", "Dst5", "DST5", "dstr0", "ddest0", "ddest5"], "dst1": ["DST0", "DST01", "dST01", "dstG", "Dst0", "dsts01", "dst01", "dsts1", "dnd1", "Dst01", "dST0", "dST1", "DstG", "DST1", "DSTG", "Dst1", "dnd01", "dstsG", "dSTG", "dndG", "dnd0", "dsts0"], "dst2": ["drest4", "dST7", "DST7", "DST4", "Dst2", "Dst3", "DST2", "dst7", "dST3", "ddest3", "ddest4", "dST2", "dst4", "DST3", "Dst7", "drest2", "ddest2", "drest3", "drest7", "ddest7", "dst3", "Dst4", "dST4"], "x_pu": ["x42cpu", "x2pu", "x42gpu", "y_cpu", "x42pu", "y2pro", "x_pro", "x42pro", "y2cpu", "y2pu", "x_cpu", "x_gpu", "x2gpu", "y_gpu", "y2gpu", "y_pro", "x2cpu", "x2pro"], "y_pu": ["y__cp", "y2cp", "y__pa", "y_cp", "y__po", " y_pa", " y2po", " y_po", "y2pa", "y2po", "y2pu", " y2pu", "y__pu", " y2cp", " y_cp", " y2pa", "y_pa", "y_po"], "i": ["ij", "li", "f", "o", "ii", "mi", "I", "pi", "l", "p", "v", "io", "in", "m", "r", "xi", "c", "ci", "b", "e", "it", "x", "y", "ic", "ix", "ip"], "j": ["jp", "ij", "f", "l", "aj", "js", "n", "p", "v", "g", "uj", "note", "k", "m", "ja", "c", "J", "jj", "b", "jump", "jl", "jc", "ji", "it", "kj", "z", "q"]}}
{"project": "qemu", "commit_id": "2906cddfecff21af20eedab43288b485a679f9ac", "target": 0, "func": "static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n    VirtIOBlockReq *req;\n\n    MultiReqBuffer mrb = {};\n\n\n\n    /* Some guests kick before setting VIRTIO_CONFIG_S_DRIVER_OK so start\n\n     * dataplane here instead of waiting for .set_status().\n\n     */\n\n    if (s->dataplane) {\n\n        virtio_blk_data_plane_start(s->dataplane);\n\n        return;\n\n    }\n\n\n\n    blk_io_plug(s->blk);\n\n\n\n    while ((req = virtio_blk_get_request(s))) {\n\n        virtio_blk_handle_request(req, &mrb);\n\n    }\n\n\n\n    if (mrb.num_reqs) {\n\n        virtio_blk_submit_multireq(s->blk, &mrb);\n\n    }\n\n\n\n    blk_io_unplug(s->blk);\n\n}\n", "idx": 15016, "substitutes": {"vdev": ["vDEV", "fdevice", " vdiv", "hdev", "svdev", " vev", "vmdiv", "vmde", " vdevice", "vde", " vserv", "svde", "hserv", "vmdev", " vde", "vdevice", "vdiv", "vev", "hDEV", "vmev", "fdev", " vDEV", "vserv", "svev", "svdiv", "fDEV", "hdevice", "fserv"], "vq": ["invqi", "vqi", " vrequ", "vtq", " vqi", "vtqi", "vtrequ", "invq", "vrequ", "invrequ"], "s": ["sis", "ses", "aws", "south", "gs", "S", "sw", "as", "bs", "t", "ties", "l", "j", "n", "js", "ex", "p", "sq", "v", "g", "sl", "simple", "details", "store", "sol", "source", "comm", "sm", "sv", "spec", "is", "sb", "sys", "hs", "command", "ds", "ls", "m", "r", "ts", "self", "sp", "c", "stats", "ears", "ins", "b", "ns", "cs", "ops", "an", "es", "ims", "h", "set", "changes", "fs", "conf", "os", "its", "se", "sports", "ss", "sts", "y", "sam", "rs", "ps"], "req": ["resp", "pro", "jp", "def", "tx", "request", "ref", "usr", "cur", "seq", "pr", "cmd", "ind", "crit", "call", "sq", "compl", "try", "md", "comm", "iq", "msg", "rb", "dist", "desc", "r", "aux", "que", "rib", "dq", "require", "comp", "rol", "res", "urg", "Requ", "rel", "requ", "qt", "need", "err", "q", "rx", "pkg", "ire", "quest", "rr", "qq", "form"]}}
{"project": "FFmpeg", "commit_id": "0c32e19d584ba6ddbc27f0a796260404daaf4b6a", "target": 0, "func": "static void av_noinline filter_mb_edgeh( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {\n\n    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]];\n\n        tc[1] = tc0_table[index_a][bS[1]];\n\n        tc[2] = tc0_table[index_a][bS[2]];\n\n        tc[3] = tc0_table[index_a][bS[3]];\n\n        h->s.dsp.h264_v_loop_filter_luma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->s.dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 15051, "substitutes": {"pix": ["PIX", "cpIX", " pixels", "wpiv", "Pfx", "Px", "wpx", "pik", " px", " pik", "piv", "mpx", "mpix", "pIX", "cpfx", "Pix", "cpix", "wpix", " pfx", " pIX", "wpik", " piv", "mpiv", "Pixels", "pixels", "px", "pfx", "cpixels", "cpx", "mpik"], "stride": ["slend", "strride", " strend", "divider", "swide", "stue", "divide", "slider", "strider", "stringide", "strite", " strine", "swride", "strope", "divice", "stringite", "slide", "stringine", " strue", "strine", "Strite", "Strine", "strend", "Stride", " strite", "strice", "stope", " strride", " strider", " strope", "strue", "swue", "strade", " strade", "swope", "slice", "divend", "Strade", "stide", " strice", "stringade"], "bS": ["biSP", " bOS", "bbFS", "nbN", " bINS", "sbV", "bbS", "bbOS", "nbINS", "bOS", "fbP", "sbFS", " bJS", "bdSP", " bV", "nbP", "bJS", "nbR", "bbR", "nbOS", " bP", "bdS", "bbV", " bBS", "biS", "bP", "bBS", "bV", " bL", "fbS", "nbUS", "bbJS", "bL", "nbJS", "nbB", "bUS", "biSU", "bbN", " bUS", "sbBS", "bSU", "bFS", "bdSU", "nbS", "bB", " bSU", "bN", "bR", "bgR", "bbB", "fbUS", "bgINS", "bgOS", "bINS", " bN", "bbBS", " bFS", " bSP", "fbL", "bSP", " bR", "bgS", " bB", "sbS", "nbFS", "nbL"], "qp": ["qunp", " qpc", "qpad", " qnp", "Qp", "qm", "iqnp", " qpad", "qpc", "qupc", "qqpc", " qcp", "iqpc", "qqpad", "iqm", "qup", " qm", "qupad", "qqcp", "qum", "Qm", "qP", "QP", " qP", "quP", "qucp", "qnp", "qqp", "iqp", "qcp", "Qpc"], "h": ["a", "f", "ph", "kh", "handle", "header", "l", "j", "ctx", "p", "n", "hm", "hw", "hz", "bh", "hal", "v", "g", "http", "t", "comm", "ih", "pp", "help", "cache", "hs", "k", "m", "php", "ah", "th", "he", "s", "hi", "hd", "c", "rh", "oh", "sh", "ht", "b", "H", "e", "host", "hl", "hash", "it", "q", "hh", "w", "x", "history", "ch", "hp"], "tc": ["tx", "rc", "cu", "td", "cf", "unc", "oc", "tu", "tic", "cm", "cus", " TC", "lc", "pb", "ctx", "tt", "tif", "LC", "temp", "cc", "cca", "cas", "css", "ctr", "acc", "t", "aco", "ui", "toc", "cache", "dc", "currency", "icc", "cci", "times", "uc", "fee", "sc", "ts", "c", "tf", "cv", "uca", "ec", "ci", "gc", "ctrl", "mc", "cs", "bc", "etc", "pc", "fc", "tmp", "TC", "ta", "tim", "cot", "https", "ic", "asc"]}}
{"project": "qemu", "commit_id": "f5babeacc4abccbb32f318278135a43477bdaa20", "target": 0, "func": "static void realize(DeviceState *d, Error **errp)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    Object *root_container;\n\n    char link_name[256];\n\n    gchar *child_name;\n\n    Error *err = NULL;\n\n\n\n    trace_spapr_drc_realize(spapr_drc_index(drc));\n\n    /* NOTE: we do this as part of realize/unrealize due to the fact\n\n     * that the guest will communicate with the DRC via RTAS calls\n\n     * referencing the global DRC index. By unlinking the DRC\n\n     * from DRC_CONTAINER_PATH/<drc_index> we effectively make it\n\n     * inaccessible by the guest, since lookups rely on this path\n\n     * existing in the composition tree\n\n     */\n\n    root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);\n\n    snprintf(link_name, sizeof(link_name), \"%x\", spapr_drc_index(drc));\n\n    child_name = object_get_canonical_path_component(OBJECT(drc));\n\n    trace_spapr_drc_realize_child(spapr_drc_index(drc), child_name);\n\n    object_property_add_alias(root_container, link_name,\n\n                              drc->owner, child_name, &err);\n\n    g_free(child_name);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n    vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc,\n\n                     drc);\n\n    qemu_register_reset(drc_reset, drc);\n\n    trace_spapr_drc_realize_complete(spapr_drc_index(drc));\n\n}\n", "idx": 15055, "substitutes": {"d": ["f", "o", "dn", "data", "l", "j", "n", "p", "fd", "dr", "D", "dm", "v", "dt", "pd", "t", "md", "du", "di", "dc", "ed", "ds", "da", "m", "dd", "r", "s", "c", "b", "device", "h", "dev", "draw", "e", "ad", "sd", "w"], "errp": ["arrp", "arrP", "errpat", "orderpat", "ererp", "orderP", "errper", " errcp", " errP", "errP", "orderper", "ererper", "orderp", "arrcp", "ercp", "errcp", "ererpat", "ererP", " errper", "erP", " errpat", "erp"], "drc": [" drt", "dpc", "sdrl", "darc", "virc", "wrc", "dsync", "doarc", "mroc", "diRC", "droc", "dotirc", "dorec", "mrc", " drl", "wrec", "ddarc", "dissrc", "lirc", "Dsrc", " drs", "sRC", "mRC", "sdRC", "vroc", "sdroc", "vrc", "varc", "sdrt", "sdrs", "dnarc", " dpc", "nirc", "marc", "Drc", "Droc", " dync", "disirc", "wirc", "dync", " dirc", "disrc", "dotsrc", "Drl", "dnrb", " drec", "doRC", "drs", " droc", "Drt", "narc", "dsRC", "sync", "sroc", "dsroc", "dotrt", "drt", "Darc", "lrc", "dnrt", "mirc", "src", "nroc", "ddpc", "dRC", "wRC", "ddrt", "drl", "larc", "wrs", "lrt", "dirc", "drec", "nrc", "Drs", "ddirc", "lsrc", "Drec", "dsrc", "dorc", "wsrc", " dRC", "mrec", "wpc", "ddrb", "DRC", "ddsrc", " dsrc", "dnrc", " darc", " drb", "ddrc", "disarc", "sdrc", "drb", "dotrc"], "root_container": [" root_docker", "internal_Container", "root_object", "rootlydocker", "internalingobject", "internal_container", "rootingContainer", "rootlycomponent", "rootnetcontainer", "root_cover", "internal_object", "root_docker", "root_cont", "rootnetcont", "internalingContainer", "rootingobject", "root_parent", "rootlyContainer", "rootnetparent", " root_parent", "rootingcover", " root_component", "rootnetContainer", "root_component", "internalingcontainer", "internalingcover", " root_cont", "root_Container", "internal_cover", "rootlycontainer", "rootingcontainer", " root_Container"], "link_name": ["link_no", "childtno", "pathNameName", "link_names", "child_Name", "link09Name", "child_order", "childtname", "linkNamefamily", "path_link", "linkNameName", "linktname", "childtorder", "linktid", "linketyname", "link2order", "link_id", "link_order", "path_name", "path_Name", "link2no", "link2name", "link_family", "link09link", "childtid", " link_pair", " link_names", "child_info", "linketypair", "link_link", "linktno", "link_Name", "path_family", "linketyName", "link2id", "pathNamelink", "pathNamefamily", "link09name", "linketynames", "child_names", "linktorder", "child_id", "link09family", "child_no", "link_pair", " link_Name", "linkNamename", "linkNamelink", "pathNamename", "link_info"], "child_name": ["child_title", "childlynames", "childlyname", "Child_Name", "link_names", "childlyName", "Child_name", "child_Name", "child_size", "child2path", " child_Name", " child2name", "childresourcenames", " child2names", " child2Name", "link_size", "child_path", "child2name", " child2title", "child_data", " child_names", "child2names", "childresourcesize", "child2title", "childresourcename", "childlytitle", "child_NAME", "child_names", " child_NAME", " child_title", "link_data", "childresourcedata", " child_node", "child2Name", "child_node", "Child_path"], "err": ["resp", "errors", "notice", "ere", "error", "cr", "exc", "lr", "usr", "cur", "attr", "aaa", "mr", "str", "dr", "erd", " Err", "or", "n", "erb", "eor", "cli", "rr", "er", "msg", "buf", "result", "sys", "rb", "br", "cfg", "kr", "r", "fee", "Error", "obj", "s", "rev", "cb", "ec", "res", "die", "Er", "fr", "inner", "eas", "iter", "e", "conf", "trace", "nil", "elt", "gz", "ev", "esp", "rn", "txt", "arr"]}}
{"project": "qemu", "commit_id": "7ec1e5ea4bd0700fa48da86bffa2fcc6146c410a", "target": 0, "func": "static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,\n\n                       int insn, int size, int sign)\n\n{\n\n    TCGv_i32 r_asi, r_size, r_sign;\n\n\n\n    r_asi = gen_get_asi(dc, insn);\n\n    r_size = tcg_const_i32(size);\n\n    r_sign = tcg_const_i32(sign);\n\n#ifdef TARGET_SPARC64\n\n    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);\n\n#else\n\n    {\n\n        TCGv_i64 t64 = tcg_temp_new_i64();\n\n        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);\n\n        tcg_gen_trunc_i64_tl(dst, t64);\n\n        tcg_temp_free_i64(t64);\n\n    }\n\n#endif\n\n    tcg_temp_free_i32(r_sign);\n\n    tcg_temp_free_i32(r_size);\n\n    tcg_temp_free_i32(r_asi);\n\n}\n", "idx": 15061, "substitutes": {"dc": ["rc", "tc", "oc", "cm", "ca", "lc", "ctx", "dr", "cc", "cd", "dt", "dm", "dp", "DC", "di", "icc", "ds", "doc", "ac", "dq", "c", "xc", "nc", "ci", "dk", "ec", "gc", "cp", "mc", "cs", "bc", "pc", "fc", "d", " DC", "vc", "sc"], "dst": ["adest", "adset", "Dst", "sdct", "DST", "Dct", " dsts", "dset", "adST", "dend", "dnd", "Dnd", "Dset", " dset", "Dsts", "Dest", "adnd", "dest", " dest", "sdsts", "dsts", " dct", "deST", "sdst", "sdest", "adst", "dST", "dests", "adsts", "dct"], "addr": ["tx", "rc", "nl", "a", "at", "mem", "ptr", "src", "ref", "usr", "address", "attr", "map", "ag", "str", "hw", "x", "dr", "ctx", "name", "adr", "store", "loc", "st", "np", "offset", "align", "r", "eth", "gate", "add", "ac", "start", "ack", "id", "set", "ad", "host", "ace", "hl", " address", "err", "init", "rn", "alloc", "ip"], "insn": [" inssn", "linsgn", "linsl", " insz", " insnp", "linsn", "linsz", "Insm", "insz", "ainsl", "ainsn", "Insn", "inssn", "insnp", " insl", " insgn", "ainssn", "linsm", "Insz", "ainsnp", "insl", "Insgn", "linssn", "insm", "linsnp", " insm", "insgn"], "size": ["Size", "type", "pi", "l", "SIZE", "city", "n", "address", "sy", "si", "storage", "len", "loc", "ize", "align", "send", "iz", "message", "use", "empty", "count", "capacity", "en", "code", "sh", "ose", "scale", "id", "area", "see", "length", "shape", "eng", "style", "small", "sn", "name", "sum"], "sign": ["type", "shift", "address", "mask", "round", "grad", "p", "cmp", "operator", "pay", "ig", "close", "kind", "ign", "cap", "Sign", "align", "act", "tag", "sa", "sk", "add", "SIGN", "sp", "pos", "sh", "scale", "start", "dig", "draw", "mod", "shape", "se", "form", "sc", "sum", "pack"], "r_asi": ["u_asi", "rLiat", "rgrasio", "rLski", "rYasi", "r_ski", "r_iat", " r_ali", " r_ois", "u_ami", "rYami", "u_azi", "r___asi", "rLaci", "ref_ini", "r_ali", "r___azi", "rrLski", "r1asi", "r_ati", " r_asis", "r__ini", "rr_iat", "r__azi", "u___asio", "r_azi", "rrLasi", "ref_ati", "r_ami", "rLasi", "r_ois", "u___asi", "r_aci", "rrLiat", "rYali", "r___ami", "r_asio", "r___asio", "r___asis", "r_asis", "r1ski", "rr_asi", "rrLaci", "rgrami", "r_ini", "ref_azi", "ref_asi", "r1iat", "rYazi", "r1aci", "r__asi", " r_azi", "rr_ski", " r_ami", "u___ami", "r__ati", "u___azi", "u_asio", "rgrasi", "rgrazi", "rr_aci", "r___ois"], "r_size": ["tr_sum", "m_sn", "r_sent", "tr_size", "mr_sum", "vr_set", "m_size", "r_see", "r\u05bcsent", "r\u05bcset", "vr\u05bcSize", "vr_size", "vr\u05bcsize", "tr_Size", "mr_width", "m_ize", "vr_Size", "tr_see", "vr\u05bcset", "r\u05bcsize", "r_sum", " r_Size", "r\u05bcSize", "mr_Size", "vr\u05bcsent", "r_space", "r_sn", "r_ize", "m_space", "r_Size", "vr_sent", "r_set", "r_width", "mr_size"], "r_sign": ["r___signed", " r_space", "R_signed", "r_pres", "r_san", "fr_san", "res_size", "r___pres", "r_ign", "res_ign", "tr_Sign", "tr_sign", "r7sign", "r_scale", "r_ig", "tr_san", "r__sk", "r_spec", "fr_ig", "r7transform", "r_transform", "res_sign", "r7Sign", "r___scale", "res_sk", "R_scale", "r__ign", "fr_sign", "fr_Sign", "r__sign", "r_sk", "r_Sign", "R_sign", "r_space", " r_transform", " r_Sign", "tr_spec", "r__size", "R_pres", "r___sign", "r_signed", "r7space"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "static inline float64 ucf64_itod(uint64_t i)\n\n{\n\n    union {\n\n        uint64_t i;\n\n        float64 d;\n\n    } v;\n\n\n\n    v.i = i;\n\n    return v.d;\n\n}\n", "idx": 15066, "substitutes": {"i": ["ij", "li", "f", "iu", "abi", "oi", "ii", "mi", "I", "pi", "ini", "ei", "j", "ki", " di", "p", "n", "si", "zi", "bi", "ui", "ia", "ik", "di", "is", "asi", "ami", "ai", "m", "y", "xi", "iy", "iti", " bi", "qi", "\u0438", "iri", "info", "ci", "ati", "ti", " ni", "u", "it", "gi", "d", "ity", "ji", "fi", "phi", "ri", "ic", "iat"], "v": ["vol", "nv", "vv", "f", "tv", "V", "l", "j", "n", "p", "vr", "vp", "mint", "val", "conv", "g", "sv", "m", "r", "vm", "va", "cv", "vs", "ov", "b", "h", "lv", "u", "qv", "var", "it", "d", "uv", "ve", "z", "q", "ev", "vt", "value", "w", "av", "x"]}}
{"project": "qemu", "commit_id": "23dceda62a3643f734b7aa474fa6052593ae1a70", "target": 0, "func": "int tcg_gen_code(TCGContext *s, tcg_insn_unit *gen_code_buf)\n\n{\n\n    int i, oi, oi_next, num_insns;\n\n\n\n#ifdef CONFIG_PROFILER\n\n    {\n\n        int n;\n\n\n\n        n = s->gen_last_op_idx + 1;\n\n        s->op_count += n;\n\n        if (n > s->op_count_max) {\n\n            s->op_count_max = n;\n\n        }\n\n\n\n        n = s->nb_temps;\n\n        s->temp_count += n;\n\n        if (n > s->temp_count_max) {\n\n            s->temp_count_max = n;\n\n        }\n\n    }\n\n#endif\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP))) {\n\n        qemu_log(\"OP:\\n\");\n\n        tcg_dump_ops(s);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->opt_time -= profile_getclock();\n\n#endif\n\n\n\n#ifdef USE_TCG_OPTIMIZATIONS\n\n    tcg_optimize(s);\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->opt_time += profile_getclock();\n\n    s->la_time -= profile_getclock();\n\n#endif\n\n\n\n    tcg_liveness_analysis(s);\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->la_time += profile_getclock();\n\n#endif\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP_OPT))) {\n\n        qemu_log(\"OP after optimization and liveness analysis:\\n\");\n\n        tcg_dump_ops(s);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    tcg_reg_alloc_start(s);\n\n\n\n    s->code_buf = gen_code_buf;\n\n    s->code_ptr = gen_code_buf;\n\n\n\n    tcg_out_tb_init(s);\n\n\n\n    num_insns = -1;\n\n    for (oi = s->gen_first_op_idx; oi >= 0; oi = oi_next) {\n\n        TCGOp * const op = &s->gen_op_buf[oi];\n\n        TCGArg * const args = &s->gen_opparam_buf[op->args];\n\n        TCGOpcode opc = op->opc;\n\n        const TCGOpDef *def = &tcg_op_defs[opc];\n\n        uint16_t dead_args = s->op_dead_args[oi];\n\n        uint8_t sync_args = s->op_sync_args[oi];\n\n\n\n        oi_next = op->next;\n\n#ifdef CONFIG_PROFILER\n\n        tcg_table_op_count[opc]++;\n\n#endif\n\n\n\n        switch (opc) {\n\n        case INDEX_op_mov_i32:\n\n        case INDEX_op_mov_i64:\n\n            tcg_reg_alloc_mov(s, def, args, dead_args, sync_args);\n\n            break;\n\n        case INDEX_op_movi_i32:\n\n        case INDEX_op_movi_i64:\n\n            tcg_reg_alloc_movi(s, args, dead_args, sync_args);\n\n            break;\n\n        case INDEX_op_insn_start:\n\n            if (num_insns >= 0) {\n\n                s->gen_insn_end_off[num_insns] = tcg_current_code_size(s);\n\n            }\n\n            num_insns++;\n\n            for (i = 0; i < TARGET_INSN_START_WORDS; ++i) {\n\n                target_ulong a;\n\n#if TARGET_LONG_BITS > TCG_TARGET_REG_BITS\n\n                a = ((target_ulong)args[i * 2 + 1] << 32) | args[i * 2];\n\n#else\n\n                a = args[i];\n\n#endif\n\n                s->gen_insn_data[num_insns][i] = a;\n\n            }\n\n            break;\n\n        case INDEX_op_discard:\n\n            temp_dead(s, args[0]);\n\n            break;\n\n        case INDEX_op_set_label:\n\n            tcg_reg_alloc_bb_end(s, s->reserved_regs);\n\n            tcg_out_label(s, arg_label(args[0]), s->code_ptr);\n\n            break;\n\n        case INDEX_op_call:\n\n            tcg_reg_alloc_call(s, op->callo, op->calli, args,\n\n                               dead_args, sync_args);\n\n            break;\n\n        default:\n\n            /* Sanity check that we've not introduced any unhandled opcodes. */\n\n            if (def->flags & TCG_OPF_NOT_PRESENT) {\n\n                tcg_abort();\n\n            }\n\n            /* Note: in order to speed up the code, it would be much\n\n               faster to have specialized register allocator functions for\n\n               some common argument patterns */\n\n            tcg_reg_alloc_op(s, def, opc, args, dead_args, sync_args);\n\n            break;\n\n        }\n\n#ifndef NDEBUG\n\n        check_regs(s);\n\n#endif\n\n        /* Test for (pending) buffer overflow.  The assumption is that any\n\n           one operation beginning below the high water mark cannot overrun\n\n           the buffer completely.  Thus we can test for overflow after\n\n           generating code without having to check during generation.  */\n\n        if (unlikely((void *)s->code_ptr > s->code_gen_highwater)) {\n\n            return -1;\n\n        }\n\n    }\n\n    tcg_debug_assert(num_insns >= 0);\n\n    s->gen_insn_end_off[num_insns] = tcg_current_code_size(s);\n\n\n\n    /* Generate TB finalization at the end of block */\n\n    tcg_out_tb_finalize(s);\n\n\n\n    /* flush instruction cache */\n\n    flush_icache_range((uintptr_t)s->code_buf, (uintptr_t)s->code_ptr);\n\n\n\n    return tcg_current_code_size(s);\n\n}\n", "idx": 15067, "substitutes": {"s": ["ses", "gs", "S", "bs", "ties", "ports", "sq", "t", "ments", "m", "eds", "steps", "tools", "qs", "stats", "vs", "states", "cs", "tests", "ims", "pers", "sg", "its", "ants", "ps", "sw", "j", "js", "v", "g", "comm", "spec", "ds", "ats", "services", "ies", "self", "set", "locks", "parts", "ers", "x", "properties", "results", "an", "types", "as", "less", "utils", "bits", "scripts", "eps", "als", "sb", "sm", "hs", "sys", "strings", "ands", "c", "es", "changes", "fs", "ings", "d", "se", "ss", "comments", "aws", "o", "tags", "ids", "p", "ities", "details", "rors", "is", "sv", "ls", "r", "ts", "ins", "ns", "h", "e", "os", "styles", "z", "w", "sts", "sets", "ms", "y", "rs"], "gen_code_buf": ["gen_code_uf", "gen_co_buffer", "gen_Code_buff", "gen_code2buffer", "gen_code_bu", "gen_code_buff", "gen_co_bu", "gen_co_uf", "gen_code2uf", "gen_co_cap", "gen_Code_uf", "gen_Code_buffer", "gen_code2buf", "gen_Code_buf", "gen_code2cap", "gen_code_buffer", "gen_code2bu", "gen_code_cap", "gen_co_buf"], "i": ["li", "ni", "o", "ii", "I", "pi", "j", "p", "si", "v", "bi", "t", " ii", "ai", "m", "in", "xi", " bi", "ci", "ti", "it", "phi", "x", "y", "ic", "ip"], "oi": ["ni", "ogi", "obi", "o", "abi", "ii", "mi", "ini", "pi", "ei", "ki", "imi", "tif", "osi", "oni", "oxy", "ori", "ilo", "bi", "obo", "ui", "eta", "asi", "ami", "oin", "ai", "ovi", "igi", "oa", "eni", "ois", "xi", "uno", "iri", "iso", "oj", "wei", "eric", "oid", "uci", "ati", "ti", "avi", "ot", "bis", "coe", "phi", "odi", "ico", "iat"], "oi_next": ["oi_ne", "oi_extra", "oi__bi", "mi___next", "oi__next", "oi___next", "oi_bi", "oi____next", "oi___bi", "mi___ne", "oi____bi", "eni_extra", "oi_rel", "oi____ne", "eni_next", "mi_ne", "mi_rel", "mi_bi", "oi_new", "mi_next", "oi__ne", "eni_new", "mi___bi", "oi__rel", "oi___ne", "oi___rel", "oi____rel", "mi___rel"], "num_insns": ["num_inns", "num_rsins", "num_inps", "num_insons", "num_incs", "num_rsns", "num_nsps", "num_inons", "num_insins", "num_nsns", "num_inins", "num_insn", "num_rsons", "num_inn", "num_inscs", "num_nsn", "num_rsn", "num_insps", "num_nscs"], "n": ["node", "network", "nl", "ni", "nor", "conn", "number", "dn", "cn", "ind", "l", "j", "ren", "ln", "names", "after", "name", "v", "g", "ng", "t", "na", "len", "note", "np", "new", "num", "nt", "m", "N", "y", "none", "gn", "c", "count", "all", "nc", "en", "fn", "no", "on", "ns", "un", "h", "inner", "non", "d", "nb", "ne", "net", "z", "nia", "sn", "nan", "nm", "x", "mn", "cont", "an", "nu", "nn"], "op": ["bit", "node", "pro", "Op", "oc", "prev", "o", "pr", "expr", "pop", "p", "oper", "loc", "msg", "info", "sp", "up", "ep", "ops", "ype", "OP", "arg", "var", "it", "prop", "name", "ip"]}}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static int ehci_process_itd(EHCIState *ehci,\n\n                            EHCIitd *itd)\n\n{\n\n    USBPort *port;\n\n    USBDevice *dev;\n\n    int ret;\n\n    uint32_t i, j, len, pid, dir, devaddr, endp;\n\n    uint32_t pg, off, ptr1, ptr2, max, mult;\n\n\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n\n\n    for(i = 0; i < 8; i++) {\n\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n\n            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);\n\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n\n\n            if (len > max * mult) {\n\n                len = max * mult;\n\n            }\n\n\n\n            if (len > BUFF_SIZE) {\n\n                return USB_RET_PROCERR;\n\n            }\n\n\n\n            qemu_sglist_init(&ehci->isgl, 2);\n\n            if (off + len > 4096) {\n\n                /* transfer crosses page border */\n\n                uint32_t len2 = off + len - 4096;\n\n                uint32_t len1 = len - len2;\n\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n\n            } else {\n\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n\n            }\n\n\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n\n\n            usb_packet_setup(&ehci->ipacket, pid, devaddr, endp);\n\n            usb_packet_map(&ehci->ipacket, &ehci->isgl);\n\n\n\n            ret = USB_RET_NODEV;\n\n            for (j = 0; j < NB_PORTS; j++) {\n\n                port = &ehci->ports[j];\n\n                dev = port->dev;\n\n\n\n                if (!(ehci->portsc[j] &(PORTSC_CONNECT))) {\n\n                    continue;\n\n                }\n\n\n\n                ret = usb_handle_packet(dev, &ehci->ipacket);\n\n\n\n                if (ret != USB_RET_NODEV) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            usb_packet_unmap(&ehci->ipacket);\n\n            qemu_sglist_destroy(&ehci->isgl);\n\n\n\n#if 0\n\n            /*  In isoch, there is no facility to indicate a NAK so let's\n\n             *  instead just complete a zero-byte transaction.  Setting\n\n             *  DBERR seems too draconian.\n\n             */\n\n\n\n            if (ret == USB_RET_NAK) {\n\n                if (ehci->isoch_pause > 0) {\n\n                    DPRINTF(\"ISOCH: received a NAK but paused so returning\\n\");\n\n                    ehci->isoch_pause--;\n\n                    return 0;\n\n                } else if (ehci->isoch_pause == -1) {\n\n                    DPRINTF(\"ISOCH: recv NAK & isoch pause inactive, setting\\n\");\n\n                    // Pause frindex for up to 50 msec waiting for data from\n\n                    // remote\n\n                    ehci->isoch_pause = 50;\n\n                    return 0;\n\n                } else {\n\n                    DPRINTF(\"ISOCH: isoch pause timeout! return 0\\n\");\n\n                    ret = 0;\n\n                }\n\n            } else {\n\n                DPRINTF(\"ISOCH: received ACK, clearing pause\\n\");\n\n                ehci->isoch_pause = -1;\n\n            }\n\n#else\n\n            if (ret == USB_RET_NAK) {\n\n                ret = 0;\n\n            }\n\n#endif\n\n\n\n            if (ret >= 0) {\n\n                if (!dir) {\n\n                    /* OUT */\n\n                    set_field(&itd->transact[i], len - ret, ITD_XACT_LENGTH);\n\n                } else {\n\n                    /* IN */\n\n                    set_field(&itd->transact[i], ret, ITD_XACT_LENGTH);\n\n                }\n\n\n\n                if (itd->transact[i] & ITD_XACT_IOC) {\n\n                    ehci_record_interrupt(ehci, USBSTS_INT);\n\n                }\n\n            }\n\n            itd->transact[i] &= ~ITD_XACT_ACTIVE;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 15077, "substitutes": {"ehci": ["ohdi", "ethcheck", "hci", "ehli", "ihsee", "echci", "ihcom", "ohcheck", "ehcheck", "echcoe", "htmc", "ehcom", "echcci", "ethercci", "htmci", "htmli", "etherdi", "ehc", "ethercoe", "ethsee", "phercheck", " ehli", "ihcu", "ehpi", "ethcom", "htmpi", "ethercom", "ehcci", " ehc", "etherci", " ehpi", "ohpi", "hli", "ethersee", "ethcu", "ehdi", "etherpi", "ohci", "phercoe", "ihci", "ehsee", "ethercu", "ethci", "hpi", "ethdi", "ethercheck", "ehcoe", "hc", "echcheck", "ehcu", "ethpi", "phercci", "pherci"], "itd": ["itern", "itde", "ITm", "iterself", "litde", "itds", "aitdo", "ITd", "ietd", "utself", "iterds", "itdb", "optf", "initde", "utf", "ITdo", "Itd", "itl", "itbd", "utd", " itdo", "itn", " itld", "iterl", "initf", "itmod", "latda", "Itds", " itdid", " itD", "iterm", "ritd", "ietr", " itn", " itmod", " itw", " itbd", "ITr", "initd", "ITl", "itsl", "aitd", " itr", "iterw", "mitsd", "itersd", " itsd", "pitd", "utda", "ritD", "iterdo", "litld", "mitbd", "itsdb", "litsd", "ITdc", "ietD", "optdid", "iterda", "ritmod", "initld", "itD", "iterr", "ritdo", "pitf", "iterf", " itm", "pitD", "initw", "mitds", "pitsd", "initsd", "ITD", "itsD", "itself", "iterdc", "iterd", "iterld", "Itbd", "itf", "itsda", "optld", "itsd", "iterde", "ritf", "itr", "aitl", "latdb", " itself", "itm", "ietl", "itdo", "itsn", "ritsd", "itsr", "iterdid", "itdid", "itdc", "itw", "latd", "optd", " itds", " itl", " itda", "itsds", "Itsd", "iterD", "mitd", "itld", "latds", "iterdb", "itermod", "itda", "aitdc", "litd", " itf"], "port": ["index", "type", "Port", "conn", "serv", "ports", "pi", "pr", "p", "pt", "t", "pp", "policy", "bus", "P", "parent", "PORT", "bridge", "pos", "cp", "client", "id", "pc", "ort", "state", "priority", "ip"], "dev": ["pro", "def", "des", "mem", "conn", "DEV", "serv", "ver", "pub", "hw", "Dev", "proc", "val", "loc", "priv", "buf", "cam", "nt", "obj", "wd", "res", "device", "adv", "sd", "ev", "iv", "ch"], "ret": ["status", "il", "mem", "out", " RET", "Ret", "RET", "val", " out", " count", "t", "result", "nt", " mem", " resp", "rt", " status", "res", "b", " res", "fi", " Ret", " r", " result"], "i": ["ij", "il", "index", "li", "ias", "ni", "status", "jp", "iu", "o", "ii", "mi", "I", "pi", "ini", "ind", "uri", "p", "si", "zi", "cli", "g", "bi", "io", "is", "ia", "ui", "di", "asi", "ami", "ai", "m", "in", "hi", "xi", "qi", "sim", "info", "im", "pa", "\u0438", "ci", "id", "ti", "ri", "it", "gi", "multi", "ji", "me", "z", "x", "y", "ic", "ix", "iat", "ip"], "j": ["ij", "jp", "index", "ni", "ii", "ind", "n", "js", "p", "bi", "t", "uj", "job", "lock", "m", "r", "json", "J", "pos", "b", "jump", "rel", "jl", "jc", "ji", "it", "z", "iat"], "len": ["vol", "il", "bytes", "li", "nl", "ell", "vec", "mem", "late", "lf", "Len", "size", "ll", "l", "fun", "fin", "n", "ln", "str", "lib", "dl", "cmp", "min", "L", "val", "compl", "conv", "sl", "el", "le", "loc", "den", "la", "gl", "fl", "lang", "num", "ls", "nt", "lis", "ml", "alt", "full", "lon", "wid", "sp", "lp", "count", "pos", "en", "all", "mn", "limit", "trans", "lan", "kl", "rel", "iter", "list", "length", "elt", "del", "pl", "yn", "lim", "coll", "ld"], "pid": ["index", "mi", "pi", "ind", "ctx", "p", "proc", "typ", "pp", "mid", "uid", "vid", "sid", "parent", "pos", "pri", "pn", "po", "res", "id", "pc", "rel", "os", "process", "pa", "priority", "ps"], "dir": ["vol", "directory", "dial", "addr", "mode", "grad", "fd", "tr", "dr", "p", "ir", "direct", "loc", "kind", "den", "di", "diff", "ds", "dist", "orient", "dd", "dim", "Dir", "DIR", "db", "trans", "rot", "wd", "dep", "rel", "direction", "order", "d", "del", "driver"], "devaddr": ["DEVaddress", " devaddress", "DEVptr", "evref", "devptr", "evip", "deviceref", "evaddr", "Devaddress", "Devaddr", " devref", " devptr", "Devptr", "devref", "devip", "deviceaddr", "DEVaddr", "deviceip", " devip", "devaddress"], "endp": ["EndP", "lastpt", "rendP", "Endpid", "endedpos", "rendpt", "endedp", "endedpoint", " endpoint", "lastp", "endpoint", "endP", "Endpos", " endpos", "Endpt", "Endpoint", "lastpid", "rendpid", "rendp", "endpos", " endP", "endpt", "endpid", "lastP", "endedP", "Endp"], "pg": ["jp", "tg", "rog", "um", "gg", "ph", "Pg", "p", "ag", "mph", "kk", "pm", "ha", "g", "ng", "ig", "pt", "pp", "ping", "loc", "ug", "buf", "gb", "np", "prot", "ia", "peg", "gate", "PG", "gn", "sp", "db", "pn", "wp", "po", "gc", "rg", "gp", "cp", "gm", "mp", "pc", "eg", "gi", "pas", "pl", "pkg", "ip", "bp", "tp", "pa", "ps"], "off": ["mem", "shift", "ptr", "o", "out", "offs", "det", "ff", "ind", "addr", "ok", "cmd", "Offset", "after", "Off", "pt", "el", "loc", "ox", "origin", "ow", "buf", "end", "offset", "now", "ext", "OFF", "nt", "op", "obj", "oa", "hop", "open", "opp", "pos", "en", "ap", "no", "on", "id", "of", "set", "point", "over", "order", "ot", "os", "pad", "from", "length", "err", "offer", "zero", "ex", "ip"], "ptr1": ["addr3", "prime11", "ptr11", "PtrOne", "len01", "Ptr01", "tp3", "ptOne", "len1", "pt51", "tp0", "ptr0", "tp01", "addr01", "len2", "addr0", "pt11", "ptr01", " ptr5", " ptr11", "Ptr2", "pt2", "Ptr1", "addr1", "prime1", "ptrOne", "tp1", "pt1", "ptr51", "ptr3", "lenOne", "prime51", "pt0", "ptr5", "pt5", "pt01", " ptr51", "pt3", "prime5"], "ptr2": ["rod2", "rod1", "Ptr4", "addr02", "addr3", "pt42", "ptr15", "ptr42", "Ptr01", "tip02", "ptr02", "addr01", "tip42", "Ptr3", "addr4", "pt02", "pr01", "rod5", "ptr01", "Ptr2", "prime15", "tip3", "prime2", "addr15", "pt2", "pr3", "addr1", "prime1", "ptr4", "rod15", "ptr3", "addr2", "ptr5", "addr42", "addr5", "pr2", "pt3", "pr4", "prime5", "tip2"], "max": ["med", "Max", "co", "ax", "size", "high", "map", "p", "n", "master", "min", "box", "mid", "end", "cap", "act", "m", "rest", "last", "range", "up", "inv", "all", "recent", "prime", "limit", "top", "base", "res", "cp", "scale", "best", "grow", "quant", "huge", "conf", "mod", "con", "total", "final", "lim", "ms", "full", "MAX", "mx", "sum"], "mult": ["vol", "mess", "mem", "tu", "per", "usr", "p", "tr", "cmp", "min", "multiple", "perm", "compl", "mk", "conv", "ipl", "mix", "multipl", "util", "msg", "mid", "cap", "comb", "m", "dom", "broad", "norm", "mu", "inv", "mut", "trans", "ul", "gr", "Mult", "mat", "fac", "quant", "mod", "factor", "multi", "total", "phi", "pl", "mn", "nom", "sub"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_input_pop(Visitor *v, void **obj)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    StackObject *tos = QSLIST_FIRST(&qiv->stack);\n\n\n\n    assert(tos && tos->qapi == obj);\n\n    QSLIST_REMOVE_HEAD(&qiv->stack, node);\n\n    qmp_input_stack_object_free(tos);\n\n}\n", "idx": 15082, "substitutes": {"v": ["vv", "nv", "vati", "f", "o", "ver", "tv", "V", "l", "j", "n", "vr", "vp", "vi", "conv", "g", "t", "sv", "m", "vy", "vm", "c", "cv", "vs", "ov", "b", "vim", "h", "verb", "nov", "u", "qv", "uv", "q", "vc", "vt", "iv", "i", "w", "ev", "av", "y"], "obj": ["resp", "vol", "key", "instance", "o", "ref", "src", "object", "attr", "pr", "cmd", "ctx", "expr", "js", "addr", "vr", "j", "tk", "bj", "typ", "xy", "Obj", "bo", "act", "nt", "rt", "oj", "pos", "po", "ht", "res", "gov", "oid", "id", "tmp", "ot", "os", "iv", "pkg", "inst", "str", "txt", "ob"], "qiv": ["qivable", "quivable", " qIv", "qIV", "dqiro", " qivable", " qiro", "dqiver", "quive", "dqiv", "qqIV", "dqive", " qive", "qiver", "qive", "qIv", "quIV", "qqiv", " qiver", "dqIV", "Qiv", "quiv", "qqivable", "Qiro", "Qiver", "dqIv", "qiro", "quiver", " qIV", "QIv", "qqiver"], "tos": ["toows", " toes", "Tos", "nos", " tors", "tows", "tsoos", "ptores", "tot", " toms", " toos", "not", "toos", "ToS", "ptoms", "tsors", " tows", "toores", "ptos", "tooses", "ptoes", "tores", "ptot", "tsoes", "noes", "ptows", "Toes", "ptoS", "tsos", " to", "tors", "no", " toS", "toms", "Toms", "toes", " toses", "toS", "to", "ptoses", "pto", " tot", " tores", "Toos", "Tors", "toses"]}}
{"project": "FFmpeg", "commit_id": "a443a2530d00b7019269202ac0f5ca8ba0a021c7", "target": 1, "func": "static int vmd_read_header(AVFormatContext *s,\n\n                           AVFormatParameters *ap)\n\n{\n\n    VmdDemuxContext *vmd = (VmdDemuxContext *)s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    AVStream *st;\n\n    unsigned int toc_offset;\n\n    unsigned char *raw_frame_table;\n\n    int raw_frame_table_size;\n\n    offset_t current_offset;\n\n    int i, j;\n\n    unsigned int total_frames;\n\n    int64_t video_pts_inc = 0;\n\n    int64_t current_video_pts = 0;\n\n    unsigned char chunk[BYTES_PER_FRAME_RECORD];\n\n    int lastframe = 0;\n\n\n\n    /* fetch the main header, including the 2 header length bytes */\n\n    url_fseek(pb, 0, SEEK_SET);\n\n    if (get_buffer(pb, vmd->vmd_header, VMD_HEADER_SIZE) != VMD_HEADER_SIZE)\n\n        return AVERROR_IO;\n\n\n\n    vmd->audio_sample_counter = 0;\n\n    vmd->audio_frame_divisor = 1;\n\n    vmd->audio_block_align = 1;\n\n\n\n    /* start up the decoders */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR_NOMEM;\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    vmd->video_stream_index = st->index;\n\n    st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_VMDVIDEO;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n    st->codec->width = LE_16(&vmd->vmd_header[12]);\n\n    st->codec->height = LE_16(&vmd->vmd_header[14]);\n\n    st->codec->time_base.num = 1;\n\n    st->codec->time_base.den = 10;\n\n    st->codec->extradata_size = VMD_HEADER_SIZE;\n\n    st->codec->extradata = av_mallocz(VMD_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    memcpy(st->codec->extradata, vmd->vmd_header, VMD_HEADER_SIZE);\n\n\n\n    /* if sample rate is 0, assume no audio */\n\n    vmd->sample_rate = LE_16(&vmd->vmd_header[804]);\n\n    if (vmd->sample_rate) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR_NOMEM;\n\n        av_set_pts_info(st, 33, 1, 90000);\n\n        vmd->audio_stream_index = st->index;\n\n        st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n        st->codec->codec_id = CODEC_ID_VMDAUDIO;\n\n        st->codec->codec_tag = 0;  /* no fourcc */\n\n        st->codec->channels = vmd->audio_channels = (vmd->vmd_header[811] & 0x80) ? 2 : 1;\n\n        st->codec->sample_rate = vmd->sample_rate;\n\n        st->codec->block_align = vmd->audio_block_align =\n\n            LE_16(&vmd->vmd_header[806]);\n\n        if (st->codec->block_align & 0x8000) {\n\n            st->codec->bits_per_sample = 16;\n\n            st->codec->block_align = -(st->codec->block_align - 0x10000);\n\n            vmd->audio_block_align = -(vmd->audio_block_align - 0x10000);\n\n        } else {\n\n            st->codec->bits_per_sample = 8;\n\n\n        st->codec->bit_rate = st->codec->sample_rate *\n\n            st->codec->bits_per_sample * st->codec->channels;\n\n\n\n        /* for calculating pts */\n\n        vmd->audio_frame_divisor = st->codec->channels;\n\n\n\n        video_pts_inc = 90000;\n\n        video_pts_inc *= st->codec->block_align;\n\n        video_pts_inc /= st->codec->sample_rate;\n\n        video_pts_inc /= st->codec->channels;\n\n    } else {\n\n        /* if no audio, assume 10 frames/second */\n\n        video_pts_inc = 90000 / 10;\n\n\n\n\n    toc_offset = LE_32(&vmd->vmd_header[812]);\n\n    vmd->frame_count = LE_16(&vmd->vmd_header[6]);\n\n    vmd->frames_per_block = LE_16(&vmd->vmd_header[18]);\n\n    url_fseek(pb, toc_offset, SEEK_SET);\n\n\n\n    raw_frame_table = NULL;\n\n    vmd->frame_table = NULL;\n\n    raw_frame_table_size = vmd->frame_count * 6;\n\n    raw_frame_table = av_malloc(raw_frame_table_size);\n\n\n\n\n\n    vmd->frame_table = av_malloc(vmd->frame_count * vmd->frames_per_block * sizeof(vmd_frame_t));\n\n    if (!raw_frame_table || !vmd->frame_table) {\n\n        av_free(raw_frame_table);\n\n        av_free(vmd->frame_table);\n\n        return AVERROR_NOMEM;\n\n\n    if (get_buffer(pb, raw_frame_table, raw_frame_table_size) !=\n\n        raw_frame_table_size) {\n\n        av_free(raw_frame_table);\n\n        av_free(vmd->frame_table);\n\n        return AVERROR_IO;\n\n\n\n\n    total_frames = 0;\n\n    for (i = 0; i < vmd->frame_count; i++) {\n\n\n\n        current_offset = LE_32(&raw_frame_table[6 * i + 2]);\n\n\n\n        /* handle each entry in index block */\n\n        for (j = 0; j < vmd->frames_per_block; j++) {\n\n            int type;\n\n            uint32_t size;\n\n\n\n            get_buffer(pb, chunk, BYTES_PER_FRAME_RECORD);\n\n            type = chunk[0];\n\n            size = LE_32(&chunk[2]);\n\n            if(!size)\n\n                continue;\n\n            switch(type) {\n\n            case 1: /* Audio Chunk */\n\n                vmd->frame_table[total_frames].frame_offset = current_offset;\n\n                vmd->frame_table[total_frames].stream_index = vmd->audio_stream_index;\n\n                vmd->frame_table[total_frames].frame_size = size;\n\n                memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);\n\n                total_frames++;\n\n                break;\n\n            case 2: /* Video Chunk */\n\n                vmd->frame_table[total_frames].frame_offset = current_offset;\n\n                vmd->frame_table[total_frames].frame_size = size;\n\n                vmd->frame_table[total_frames].stream_index = vmd->video_stream_index;\n\n                memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);\n\n                vmd->frame_table[total_frames].pts = current_video_pts;\n\n                if (lastframe) {\n\n                    vmd->frame_table[lastframe].pts = current_video_pts - video_pts_inc;\n\n\n                lastframe = total_frames;\n\n                total_frames++;\n\n                break;\n\n\n            current_offset += size;\n\n\n        current_video_pts += video_pts_inc;\n\n\n\n\n    av_free(raw_frame_table);\n\n\n\n    vmd->current_frame = 0;\n\n    vmd->frame_count = total_frames;\n\n\n\n    return 0;\n", "idx": 15094, "substitutes": {"s": ["aws", "gs", "a", "S", "o", "bs", "p", "js", "n", "v", "g", "t", "is", "sb", "sv", "hs", "sys", "ds", "ats", "in", "m", "sa", "r", "ls", "sc", "ts", "c", "sp", "vs", "ins", "ns", "b", "cs", "h", "es", "e", "fs", "sg", "os", "d", "ss", "sts", "ms", "rs", "ps"], "ap": ["am", " ps", " map", "map", " sp", "ar", "pp", "cap", " par", "op", "al", "att", "aps", "ac", "sp", "ep", " sap", " mp", "mp", " cp", " pu", "bp", "pl", "tp", " af", "pa", "tap", "ip"], "vmd": ["vccmd", "devmd", " vmm", "vmand", "Vmd", "evmk", "Vcmd", "ivmd", "verdd", "nvmn", "mdm", " vMD", "vvod", "gmd", "vdm", " vod", "vdd", "wdm", "devdm", "vcmd", "avmm", "gcmd", "vcasured", "vermm", "vcmn", " vmt", "gMD", "servmn", "vermt", "avdd", "valmand", "evmd", "nvcmd", "vermd", "avmn", " vmn", "mcmd", "mmd", "devmt", "nvmd", "wmd", "evod", "evmn", "vod", "wcmd", "nvMD", "servasured", "wmand", "valcmd", " vcd", "ivcd", "vermn", "mnd", " vmk", "Vnd", "wmt", "ivmn", "ivdd", "valmt", "avcmd", "valmd", "servmd", "vvmn", " vdm", "vasured", "devmn", "Vdm", "avmd", "evdm", " vcmd", "vvmk", "wnd", "vmt", "vnd", "avmt", " vasured", "servcmd", "gmn", "vvmd", "evmt", "avmand", "vmk", "vcd", "vMD", " vdd", "avcd", "vmm", "vmn"], "pb": ["jp", "td", "tc", "sw", "bs", "ctx", "p", "wb", "proc", "vp", "pm", "tk", "bj", "typ", "dp", "conv", "pt", "pp", "sb", "aus", "buf", "np", "lb", "rb", "ab", "ub", "fb", "ts", "buffer", "sp", "cb", "lp", "fp", "cv", "PB", "wp", "cp", "b", "gp", "pg", "mp", "pc", "bb", "mb", "uf", "bp", "pl", "pkg", "tp", "pa", "ob", "ps"], "st": ["ste", "status", "stable", "td", "est", "sw", "et", "usr", "sta", "St", "ST", "ist", "tt", "fd", "tr", "storage", "ut", "stat", "put", "sl", "pt", "store", "t", "nd", "stop", "sm", "sv", "sb", "stack", "mont", "ct", "nt", "irst", "r", "rest", "th", "sa", "step", "first", "rt", "ck", "ts", "ost", "sp", "stage", "art", "ust", "std", "no", "start", "stru", "tmp", "set", "mt", "cont", "sty", "ft", "se", "stan", "ast", "sn", "sth", "sts", "inst", "sc", "str", "interface", "form"], "toc_offset": ["meta_offset", "tocameoffset", "toc_table", "meta_position", "metaamepos", "toc__offset", "meta_pos", "tocamepos", "metaameposition", "tocameposition", "toc__position", "toc_pos", "tocametable", "toc_position", "metaametable", "toc__pos", "meta_table", "metaameoffset", "toc__table"], "raw_frame_table": ["raw_frame_map", "raw_frames_table", "raw_frame_list", "raw_frames_buffer", "raw_frames_list", "raw_frames_map", "raw_frame_buffer"], "raw_frame_table_size": ["raw_frame_table2size", "raw_frame_buffer_size", "raw_frame_table_length", "raw_frame_buffer_count", "raw_frame_table_count", "raw_frame_buffer_length", "raw_frame_table2len", "raw_frame_table_len", "raw_frame_buffer_len", "raw_frame_table2length", "raw_frame_table2count"], "current_offset": ["stream_page", "stream_position", "stream_pos", "stream_offset", "current_position", "current_page", "current_pos"], "i": ["li", "f", "o", "ii", "mi", "I", "pi", "l", "p", "n", "si", "v", "t", "k", "m", "r", "c", "ci", "b", "h", "ti", "e", "it", "d", "x", "y", "ic"], "j": ["jp", "ij", "f", "ii", "l", "n", "p", "js", "aj", "v", "g", "t", "k", "m", "r", "ja", "sp", "count", "J", "pos", "jj", "b", "jump", "jc", "ji", "z", "q"], "total_frames": ["total_images", " total_images", "total_videos", " total_videos"], "chunk": ["Chunks", "bord", "Chip", "chip", "bunks", "bip", "CHunks", "CHip", "chord", "CHunk", "Chunk", "chunks", "CHord", "Chord", "bunk"]}}
{"project": "FFmpeg", "commit_id": "99e5a9d1ea2a61ac9429427431e5b9c2fefb76a5", "target": 0, "func": "void dsputil_init_arm(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n    int idct_algo= avctx->idct_algo;\n\n\n\n    ff_put_pixels_clamped = c->put_pixels_clamped;\n\n    ff_add_pixels_clamped = c->add_pixels_clamped;\n\n\n\n    if (avctx->lowres == 0) {\n\n        if(idct_algo == FF_IDCT_AUTO){\n\n#if   HAVE_IPP\n\n            idct_algo = FF_IDCT_IPP;\n\n#elif HAVE_NEON\n\n            idct_algo = FF_IDCT_SIMPLENEON;\n\n#elif HAVE_ARMV6\n\n            idct_algo = FF_IDCT_SIMPLEARMV6;\n\n#elif HAVE_ARMV5TE\n\n            idct_algo = FF_IDCT_SIMPLEARMV5TE;\n\n#else\n\n            idct_algo = FF_IDCT_ARM;\n\n#endif\n\n        }\n\n\n\n        if(idct_algo==FF_IDCT_ARM){\n\n            c->idct_put= j_rev_dct_ARM_put;\n\n            c->idct_add= j_rev_dct_ARM_add;\n\n            c->idct    = j_rev_dct_ARM;\n\n            c->idct_permutation_type= FF_LIBMPEG2_IDCT_PERM;\n\n        } else if (idct_algo==FF_IDCT_SIMPLEARM){\n\n            c->idct_put= simple_idct_ARM_put;\n\n            c->idct_add= simple_idct_ARM_add;\n\n            c->idct    = simple_idct_ARM;\n\n            c->idct_permutation_type= FF_NO_IDCT_PERM;\n\n#if HAVE_ARMV6\n\n        } else if (idct_algo==FF_IDCT_SIMPLEARMV6){\n\n            c->idct_put= ff_simple_idct_put_armv6;\n\n            c->idct_add= ff_simple_idct_add_armv6;\n\n            c->idct    = ff_simple_idct_armv6;\n\n            c->idct_permutation_type= FF_LIBMPEG2_IDCT_PERM;\n\n#endif\n\n#if HAVE_ARMV5TE\n\n        } else if (idct_algo==FF_IDCT_SIMPLEARMV5TE){\n\n            c->idct_put= simple_idct_put_armv5te;\n\n            c->idct_add= simple_idct_add_armv5te;\n\n            c->idct    = simple_idct_armv5te;\n\n            c->idct_permutation_type = FF_NO_IDCT_PERM;\n\n#endif\n\n#if HAVE_IPP\n\n        } else if (idct_algo==FF_IDCT_IPP){\n\n            c->idct_put= simple_idct_ipp_put;\n\n            c->idct_add= simple_idct_ipp_add;\n\n            c->idct    = simple_idct_ipp;\n\n            c->idct_permutation_type= FF_NO_IDCT_PERM;\n\n#endif\n\n#if HAVE_NEON\n\n        } else if (idct_algo==FF_IDCT_SIMPLENEON){\n\n            c->idct_put= ff_simple_idct_put_neon;\n\n            c->idct_add= ff_simple_idct_add_neon;\n\n            c->idct    = ff_simple_idct_neon;\n\n            c->idct_permutation_type = FF_PARTTRANS_IDCT_PERM;\n\n        } else if ((CONFIG_VP3_DECODER || CONFIG_VP5_DECODER || CONFIG_VP6_DECODER || CONFIG_THEORA_DECODER) &&\n\n                   idct_algo==FF_IDCT_VP3){\n\n            c->idct_put= ff_vp3_idct_put_neon;\n\n            c->idct_add= ff_vp3_idct_add_neon;\n\n            c->idct    = ff_vp3_idct_neon;\n\n            c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;\n\n#endif\n\n        }\n\n    }\n\n\n\n    c->put_pixels_tab[0][0] = put_pixels16_arm;\n\n    c->put_pixels_tab[0][1] = put_pixels16_x2_arm;\n\n    c->put_pixels_tab[0][2] = put_pixels16_y2_arm;\n\n    c->put_pixels_tab[0][3] = put_pixels16_xy2_arm;\n\n    c->put_no_rnd_pixels_tab[0][0] = put_pixels16_arm;\n\n    c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_arm;\n\n    c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_arm;\n\n    c->put_no_rnd_pixels_tab[0][3] = put_no_rnd_pixels16_xy2_arm;\n\n    c->put_pixels_tab[1][0] = put_pixels8_arm;\n\n    c->put_pixels_tab[1][1] = put_pixels8_x2_arm;\n\n    c->put_pixels_tab[1][2] = put_pixels8_y2_arm;\n\n    c->put_pixels_tab[1][3] = put_pixels8_xy2_arm;\n\n    c->put_no_rnd_pixels_tab[1][0] = put_pixels8_arm;\n\n    c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_arm;\n\n    c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_arm;\n\n    c->put_no_rnd_pixels_tab[1][3] = put_no_rnd_pixels8_xy2_arm;\n\n\n\n#if HAVE_ARMV5TE\n\n    c->prefetch = ff_prefetch_arm;\n\n#endif\n\n\n\n#if HAVE_IWMMXT\n\n    dsputil_init_iwmmxt(c, avctx);\n\n#endif\n\n#if HAVE_ARMVFP\n\n    ff_float_init_arm_vfp(c, avctx);\n\n#endif\n\n#if HAVE_NEON\n\n    ff_dsputil_init_neon(c, avctx);\n\n#endif\n\n}\n", "idx": 15106, "substitutes": {"c": ["rc", "ce", "cu", "cf", "co", "f", "tc", "at", "cr", "cm", "out", "unc", "lc", "l", "ctx", "p", "call", "cc", "conv", "v", "chain", "g", "t", "ic", "com", "dc", "cache", "ct", "cl", "cam", "ac", "C", "cb", "cv", "xc", "abc", "nc", "ci", "ec", "content", "cp", "b", "mc", "cs", "bc", "gc", "etc", "pc", "fc", "e", "con", "conf", "enc", "u", "d", "config", "err", "w", "arc", "sc", "coll", "cont", "anc", "can", "ch"], "avctx": ["avectl", " avsys", "AVparams", "avctl", "AVcontext", "AVsys", "AVctx", "savcur", "avcontext", "savcontext", "averparams", "avercontext", "aveparams", "avsys", "avesys", " avcrit", "avparams", "AVkw", "savctx", "avecrit", "avecontext", "avecur", "averctx", "avkw", "avectx", "savcrit", " avcur", " avcontext", " avctl", "avcur", "AVctl", "avcrit", "averkw", "avekw"]}}
{"project": "FFmpeg", "commit_id": "7a4f74eed51f914e9bbfebaffd4a92ac6791f819", "target": 0, "func": "av_cold void ff_h264_free_context(H264Context *h)\n\n{\n\n    int i;\n\n\n\n    ff_h264_free_tables(h);\n\n\n\n    if (h->DPB) {\n\n        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)\n\n            ff_h264_unref_picture(h, &h->DPB[i]);\n\n        av_freep(&h->DPB);\n\n    }\n\n\n\n    h->cur_pic_ptr = NULL;\n\n\n\n    for (i = 0; i < h->nb_slice_ctx; i++)\n\n        av_freep(&h->slice_ctx[i].rbsp_buffer);\n\n    av_freep(&h->slice_ctx);\n\n    h->nb_slice_ctx = 0;\n\n\n\n    for (i = 0; i < MAX_SPS_COUNT; i++)\n\n        av_freep(h->sps_buffers + i);\n\n\n\n    for (i = 0; i < MAX_PPS_COUNT; i++)\n\n        av_freep(h->pps_buffers + i);\n\n}\n", "idx": 15108, "substitutes": {"h": ["rem", "mem", "sw", "go", "ph", "kh", "o", "has", "handle", "header", "l", "j", "hz", "p", "hm", "hw", "window", "bh", "proc", "v", "http", "comm", "ih", "help", "cache", "hs", "pp", "policy", "k", "m", "ah", "th", "he", "obj", "info", "hd", "c", "rh", "event", "oh", "sh", "ht", "b", "H", "dev", "rec", "here", "host", "hl", "hash", "it", "dh", "eh", "q", "z", "hh", "w", "x", "y", "gh", "history", "ch", "hp"], "i": ["index", " li", " di", "cli", "gu", "t", " pi", " ki", "ami", "ai", "m", " I", "xi", "qi", "client", "ims", "it", "ji", "us", "li", "by", " c", "oi", "ind", "j", "ki", "si", "zi", " ti", "g", "ui", "iq", " bi", "im", "print", "mc", "ti", "fi", "MI", "ex", "x", "ri", "ic", "ix", "ip", "ij", "at", "um", " info", "mi", "ii", "I", "pi", " iter", "this", " si", "uli", "batch", "er", "di", " ii", " mi", "in", "ie", "json", "sim", "info", "remote", "ci", " wi", " all", " ni", "u", "iter", "multi", "to", "me", "err", " vi", "init", " err", "ico", "status", "iu", "ski", " j", "ini", "ei", "p", "bi", "io", "is", "ia", "eu", "hi", "\u0438", " multi", "cgi", "e", "gi", " m", "z", "q", "phi", "name", "y"]}}
{"project": "qemu", "commit_id": "4a1cba3802554a3b077d436002519ff1fb0c18bf", "target": 1, "func": "bool aio_poll(AioContext *ctx, bool blocking)\n\n{\n\n    AioHandler *node;\n\n    int i, ret;\n\n    bool progress;\n\n    int64_t timeout;\n\n\n\n    aio_context_acquire(ctx);\n\n    progress = false;\n\n\n\n    /* aio_notify can avoid the expensive event_notifier_set if\n\n     * everything (file descriptors, bottom halves, timers) will\n\n     * be re-evaluated before the next blocking poll().  This is\n\n     * already true when aio_poll is called with blocking == false;\n\n     * if blocking == true, it is only true after poll() returns,\n\n     * so disable the optimization now.\n\n     */\n\n    if (blocking) {\n\n        atomic_add(&ctx->notify_me, 2);\n\n    }\n\n\n\n    ctx->walking_handlers++;\n\n\n\n    assert(npfd == 0);\n\n\n\n    /* fill pollfds */\n\n\n\n    if (!aio_epoll_enabled(ctx)) {\n\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n            if (!node->deleted && node->pfd.events\n\n                && aio_node_check(ctx, node->is_external)) {\n\n                add_pollfd(node);\n\n            }\n\n        }\n\n    }\n\n\n\n    timeout = blocking ? aio_compute_timeout(ctx) : 0;\n\n\n\n    /* wait until next event */\n\n    if (timeout) {\n\n        aio_context_release(ctx);\n\n    }\n\n    if (aio_epoll_check_poll(ctx, pollfds, npfd, timeout)) {\n\n        AioHandler epoll_handler;\n\n\n\n        epoll_handler.pfd.fd = ctx->epollfd;\n\n        epoll_handler.pfd.events = G_IO_IN | G_IO_OUT | G_IO_HUP | G_IO_ERR;\n\n        npfd = 0;\n\n        add_pollfd(&epoll_handler);\n\n        ret = aio_epoll(ctx, pollfds, npfd, timeout);\n\n    } else  {\n\n        ret = qemu_poll_ns(pollfds, npfd, timeout);\n\n    }\n\n    if (blocking) {\n\n        atomic_sub(&ctx->notify_me, 2);\n\n    }\n\n    if (timeout) {\n\n        aio_context_acquire(ctx);\n\n    }\n\n\n\n    aio_notify_accept(ctx);\n\n\n\n    /* if we have any readable fds, dispatch event */\n\n    if (ret > 0) {\n\n        for (i = 0; i < npfd; i++) {\n\n            nodes[i]->pfd.revents = pollfds[i].revents;\n\n        }\n\n    }\n\n\n\n    npfd = 0;\n\n    ctx->walking_handlers--;\n\n\n\n    /* Run dispatch even if there were no readable fds to run timers */\n\n    if (aio_dispatch(ctx, ret > 0)) {\n\n        progress = true;\n\n    }\n\n\n\n    aio_context_release(ctx);\n\n\n\n    return progress;\n\n}\n", "idx": 15115, "substitutes": {"ctx": ["conn", "hw", "expr", "window", "cmp", "mk", "cas", "pool", "nt", "context", "cb", "xc", "qt", "pkg", "exec", "ka", "tx", "kw", "ctl", "fw", "co", "unc", "wx", "setup", "lc", "addr", "cmd", "crit", "kt", "conv", "comm", "xp", "wcs", "cfg", "obj", "nc", "cp", "ctrl", "gc", "tmp", "conf", "vc", "x", "ca", "txt", "resp", "cf", "dl", "cc", "req", "proc", "xs", "height", "ctr", "buf", "sys", "np", "nz", "gt", "org", "cv", "kl", "wd", "bc", "etc", "acl", "config", "tm", "jac", "jp", "cu", "tc", "cm", "cd", "xy", "pt", "dc", "func", "ct", "cam", "act", "cl", "prefix", "ck", "tz", "init", "sc", "ce", "anc"], "blocking": ["status", "server", "always", "fully", "latest", "background", "ocking", "boxing", "starting", "training", "majority", "balanced", "enabled", "negative", "padding", " locking", "locked", "loading", "rolling", "lock", "poll", "broad", "blocks", "exclusive", "ending", "speaking", "packing", "available", " blocked", "warning", "buffer", "block", "forcing", "watching", "locking", "checked", "restricted", "sync", "saving", "excluding", "confirmed", "checking", "calling", "joining", "period", "playing", "running", "using", "testing", "necessary", "ordering"], "node": ["server", "index", "instance", "path", "key", "status", "nw", "peer", "child", "local", "ref", "primary", "ind", "addr", "row", "n", "x", "cmp", "proc", "cd", "source", "nd", "note", "msg", "cache", "np", "new", "station", "item", "holder", "nt", "tree", "k", "desc", "none", "obj", "parent", "wife", "handler", "c", "image", "event", "fn", "link", "gc", "cp", "post", "root", "id", "master", "tmp", "host", "entry", "Node", "list", "edge", "component", "nb", "slave", "normal", "name", "process", "nn", "worker"], "i": ["index", "li", "l", "iu", "ii", " j", "I", "pi", "mi", "ind", "j", "ini", "n", "p", "x", "ki", "si", "ei", "zi", "v", "cli", "chain", "bi", "io", "batch", "t", "ui", "di", "ami", " ii", "k", "m", "ai", "r", " I", "s", "xi", "qi", "sim", "\u0438", "c", "ite", "ci", "mc", "id", "set", "ti", "e", "iter", "ri", "gi", "multi", "fi", "it", "MI", "fire", "ji", "phi", "init", "y", "ic", "ix", "ip"], "ret": ["resp", "rem", "def", "ptr", "number", "success", "ll", "back", "cmd", "pat", "Ret", "tr", "reply", "rets", "after", "RET", "val", "reset", "dt", "done", "t", "ert", "len", "rm", "result", "ext", "nt", "r", "alt", "gt", "got", "rt", "rev", "unt", "lt", "res", "flag", "re", "tmp", "mt", "repl", "iter", "ft", "arg", "fi", "elt", "err", "xt", "txt"], "progress": ["pro", "status", "resp", "wait", "trust", "error", "distance", "exec", "mem", "success", "push", "fast", "good", " Progress", "bool", "performance", "p", "depth", " progression", "details", "done", "assert", "Progress", "help", "result", "command", "dirty", "dist", "poll", "lock", "memory", "step", "priority", "quick", "remote", "recent", "summary", "putable", "debug", "print", "res", "flag", "active", "pc", "state", "confirmed", "valid", "tip", "total", "err", "final", "usage", "process", "history", "finished", "complete", "ait"], "timeout": ["never", "directory", "socket", "tt", "sequence", "window", "t", "locked", "policy", "delay", "nt", "lock", "timer", "ssl", "resolution", "warning", "limit", "course", "duration", "confirmed", "length", "shape", "qt", "ta", "required", "wait", "error", "type", "itness", "number", "callback", "negative", "padding", "sync", "term", "tmp", " seconds", "TIME", "span", "txt", "history", "olerance", "uration", "out", "interrupted", "disabled", "height", "unit", "service", "Timeout", "slot", "elta", "buffer", "script", "capacity", "seconds", "option", "status", "region", "frequency", "tv", "size", "io", "alt", "none", "exclusive", "time", "ts", "sp", "tf", "password", "ns", "max", "format", "period", "beta", "network"], "walking_handlers": ["walking_candolds", "walking_translers", "walking_Handrollers", "walking_Handling", "walking_Handles", "walking_handrollers", "walking_transling", "walking_warerollers", "walking_candlers", "walking_handodes", "walking_manolds", "walking_Handolds", "walking_candles", "walking_handolds", "walking_wareling", "walking_Handodes", "walking_manodes", "walking_handling", "walking_Handlers", "walking_warelers", "walking_transles", "walking_wareles", "walking_manles", "walking_manlers", "walking_candodes", "walking_transrollers", "walking_handles"], "epoll_handler": ["epoll_inner", "epollpthandle", "epoll_client", "epoll_manager", "epll_client", "epollptmanager", "epollinghandler", "epllinghandler", "epll_loader", "epollerhander", "epoll_wrapper", "epock_Handler", "epol_manager", "epoll_folder", "epll_handler", "epow_handler", "epollerfolder", "epol_handle", "epollinghandle", "epow_hander", "epllingloader", "epollptinner", "epoll_loader", "epock_handler", "epollpthandler", "epol_handler", "epow_folder", "epoll_Handler", "epow_wrapper", "epll_handle", "epoll_handle", "epollerwrapper", "epllinghandle", "epock_wrapper", "epollingclient", "epollerhandler", "epllingclient", "epoll_hander", "epol_inner", "epollingloader"]}}
{"project": "FFmpeg", "commit_id": "252c0bfdc014c1fb6ad4fe06242c7beca58a6b41", "target": 1, "func": "int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)\n\n{\n\n    av_assert0(0);\n\n\n}", "idx": 15124, "substitutes": {"s": ["a", "S", "o", "n", "p", "js", "sq", "v", "t", "sb", "ds", "m", "ts", "c", "b", "ns", "cs", "h", "es", "e", "fs", "os", "d", "w", "ss", "sc", "i"], "pic": [" fl", "FR", "o", " fn", "ff", "pr", "p", "F", " fr", "fif", "picture", "fm", "fl", "fx", "image", "fp", "fn", " fps", "res", "pc", "fc", "fr", " p", "fi", "q", "fps", " fram", "ps"]}}
{"project": "FFmpeg", "commit_id": "d1a58afb95f68c5375b4a7556317d835108509ed", "target": 1, "func": "static int latm_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    PutBitContext bs;\n\n    int i, len;\n\n    uint8_t loas_header[] = \"\\x56\\xe0\\x00\";\n\n    uint8_t *buf = NULL;\n\n\n\n    if (s->streams[0]->codec->codec_id == CODEC_ID_AAC_LATM)\n\n        return ff_raw_write_packet(s, pkt);\n\n\n\n    if (pkt->size > 2 && pkt->data[0] == 0xff && (pkt->data[1] >> 4) == 0xf) {\n\n        av_log(s, AV_LOG_ERROR, \"ADTS header detected - ADTS will not be incorrectly muxed into LATM\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (pkt->size > 0x1fff)\n\n        goto too_large;\n\n\n\n    buf = av_malloc(pkt->size+1024);\n\n    if (!buf)\n\n        return AVERROR(ENOMEM);\n\n\n\n    init_put_bits(&bs, buf, pkt->size+1024);\n\n\n\n    latm_write_frame_header(s, &bs);\n\n\n\n    /* PayloadLengthInfo() */\n\n    for (i = 0; i <= pkt->size-255; i+=255)\n\n        put_bits(&bs, 8, 255);\n\n\n\n    put_bits(&bs, 8, pkt->size-i);\n\n\n\n    /* The LATM payload is written unaligned */\n\n\n\n    /* PayloadMux() */\n\n    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {\n\n        // Convert byte-aligned DSE to non-aligned.\n\n        // Due to the input format encoding we know that\n\n        // it is naturally byte-aligned in the input stream,\n\n        // so there are no padding bits to account for.\n\n        // To avoid having to add padding bits and rearrange\n\n        // the whole stream we just remove the byte-align flag.\n\n        // This allows us to remux our FATE AAC samples into latm\n\n        // files that are still playable with minimal effort.\n\n        put_bits(&bs, 8, pkt->data[0] & 0xfe);\n\n        avpriv_copy_bits(&bs, pkt->data + 1, 8*pkt->size - 8);\n\n    } else\n\n        avpriv_copy_bits(&bs, pkt->data, 8*pkt->size);\n\n\n\n    avpriv_align_put_bits(&bs);\n\n    flush_put_bits(&bs);\n\n\n\n    len = put_bits_count(&bs) >> 3;\n\n\n\n    if (len > 0x1fff)\n\n        goto too_large;\n\n\n\n    loas_header[1] |= (len >> 8) & 0x1f;\n\n    loas_header[2] |= len & 0xff;\n\n\n\n    avio_write(pb, loas_header, 3);\n\n    avio_write(pb, buf, len);\n\n\n\n    av_free(buf);\n\n\n\n    return 0;\n\n\n\ntoo_large:\n\n    av_log(s, AV_LOG_ERROR, \"LATM packet size larger than maximum size 0x1fff\\n\");\n\n    av_free(buf);\n\n    return AVERROR_INVALIDDATA;\n\n}\n", "idx": 15125, "substitutes": {"s": ["aws", "ses", "south", "gs", "S", "j", "n", "js", "p", "ctx", "sq", "xs", "t", "is", "sb", "sv", "hs", "sys", "ds", "ls", "ats", "m", "sa", "r", "ssl", "qs", "sc", "ts", "c", "sp", "stats", "ns", "b", "cs", "h", "es", "fs", "sg", "os", "its", "z", "sports", "ss", "sts", "scl", "pkg", "rs", "ps"], "pkt": ["opacket", " pwk", "Pmit", "patchwk", "Pdu", "compacket", "upacket", " pcmd", "Ppt", "patchacket", "cpkt", "ppdu", " pkg", " pwp", "patwp", "Pett", " pett", "patchkl", "compnt", "preacket", "Pct", "pwp", "postacket", "ppcmd", " pkat", "patkg", "opkt", " pkl", "pet", "pwk", "pkg", "mfeat", "packet", "patkt", "patacket", "spacket", "patchkt", "spkt", "compct", "ppkg", "paykt", "cpwp", "patct", "ppacket", "Pkat", "patk", "postkg", " pnt", "tkg", " punit", " pfeat", "cpacket", "patdu", "prmsg", "prdu", "wpkg", "payct", "wpdu", "ppnt", "compkt", "postct", "npkl", "postcmd", " packet", "npct", "pfeat", "postwk", "parkt", "prounit", "postkt", "pant", "repkt", " pet", "opnt", "pcmd", "payacket", "prekt", "pkat", "tk", "ppt", " pdu", "parpt", "patchct", "pnt", "cpdu", "paunit", "pct", "predu", " ppt", "pk", "ppkt", "pkl", "pdu", "Pwk", " pmit", "tkt", "patchfeat", "npfeat", "pmit", " pk", "repnt", "ppet", "cpmsg", " pct", "Packet", "parwk", "punit", "paymsg", "repacket", "Pmsg", "prokt", "prkt", "paacket", "Pnt", "opkg", "paymit", "prkat", "procmd", "pront", "mwk", "pakt", "wpcmd", "parett", "macket", "spet", "tct", "npkt", "cpnt", " pmsg", "proacket", "repkg", "upkt", "prect", "updu", "spnt", "mkt", "paywk", "upct", "wpkt", "pmsg", "pett", "Pkt", "prokg"], "pb": ["tx", "jp", "tc", "conn", "cm", "cn", "ctx", "p", "cmd", "bh", "vp", "tk", "conv", "typ", "pt", "sb", "aus", "np", "lb", "ub", "cpp", "ts", "cb", "lp", "cv", "fp", "PB", "cp", "b", "gp", "pg", "mp", "pc", "soc", "bb", "uf", "bp", "pkg", "tp", "ps"], "bs": ["bytes", "nos", " BS", " ns", "gs", "ubs", "aos", "obs", " buffers", " fs", " sands", "outs", "js", "bits", "bh", "css", "bys", " outs", "bes", " buffs", " bases", "als", "sb", "aus", "sys", "cks", "ls", "ats", " bits", "blocks", " cs", "BS", "bsp", "qs", "ts", "bos", " bl", "cb", " bos", "base", " blocks", " os", " ts", "boxes", "vs", " ss", "bas", "caps", "b", "ns", "cs", "bc", "lbs", "bed", "uts", "bles", "fs", "bps", "os", "bis", "Bs", "its", "bb", " bounds", "us", "ms", "rs", "ps"], "i": ["index", "li", "f", "l", "iu", "ii", "mi", "I", "pi", " iter", "ini", "j", "ind", " li", " di", "n", "p", "si", "ei", "zi", " ti", "cli", " si", "g", "gu", "bi", "v", "t", " pi", "ui", "di", "ami", " ii", " mi", "m", "y", "ai", "r", "hi", "xi", "qi", " bi", "sim", "im", "c", " multi", "ci", "b", "h", "ims", "ti", " ni", "u", "iter", "e", "gi", "it", "multi", "d", " m", "MI", "z", "phi", "x", " e", "ix", "ip"], "len": ["resp", "bytes", "Length", "li", "nl", "ni", "vec", "mem", "lf", "Len", "size", "ll", "l", "fin", "fun", "n", "ln", "lc", "cmp", "seq", "dl", "cod", "L", "val", "compl", "conv", "el", "t", "gen", "la", "loc", "gl", "fl", "offset", "num", "ls", "nt", "lis", "alt", "html", "lon", "wid", "lp", "lic", "pos", "en", "lan", "kl", "iter", "hl", "els", "length", "total", "elt", "del", "lim", "coll", "ld"], "loas_header": ["loas_data", "loas_head", "loAS_data", "loAS_byte", "loas_extra", "cont", "loas___data", "n", "loas___extra", "loas___byte", "loAS_head", "loas_channel", "loas_number", "loac_header", "loAS_info", "loas___head", "loAS_header", "loas_info", "loac_head", "loas___info", "loas_byte", "loas___header", "loac_channel", "loAS_extra", "w", "loac_number"], "buf": ["bytes", "Buff", "rc", "vec", "mem", "ptr", "out", "rw", "ff", "data", "cmd", "wb", "aka", "window", "eb", "raw", "Buffer", "conv", "v", "done", "box", "t", "used", "BU", "msg", "buff", "bin", "np", "cap", "func", "rb", "br", "xff", "broad", "doc", "off", "buffer", "cb", "block", "cv", "db", "uffy", "limit", "b", "bl", "bc", "tmp", "max", "length", "gz", "uf", "err", "queue", "bound", "w", "str", "txt", "ob", "alloc", "arr"]}}
{"project": "qemu", "commit_id": "9e559533bd825a3e371497875576137a8586c831", "target": 1, "func": "static void aio_read_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->Pflag) {\n\n        void *cmp_buf = g_malloc(ctx->qiov.size);\n\n\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n\n        }\n\n        g_free(cmp_buf);\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->vflag) {\n\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n\n    g_free(ctx);\n\n}", "idx": 15132, "substitutes": {"opaque": ["copac", "imlay", "imaque", "opacity", " opac", "popaque", " opacity", " opque", "popaques", "oque", "oaques", "poplay", "imaques", "opaques", "oaque", "imque", "OPac", "popque", "copque", "copacity", "OPacity", "copaque", "opque", "OPaque", "opac", "oplay", "OPque", "olay"], "ret": ["resp", "status", "jp", "def", "mem", "et", "out", "ref", "inter", " RET", "det", "fun", "cmd", "back", "pat", "Ret", "x", "reply", "tr", "rets", "RET", "val", "deg", "try", "xy", "t", "len", "rm", "ext", "nz", "ct", "nt", "alt", "gt", "aux", "magic", "rt", "tf", "count", "code", "ry", "res", "re", "mt", "ft", "elt", "err", " Ret", "ter"], "ctx": ["index", "td", "conn", "cur", "hw", "expr", "window", "cmp", "bj", "check", "nt", "context", "cb", "xc", "abc", "urg", "qt", "pkg", "exec", "tx", "kw", "ctl", "def", "co", "unc", "wx", "addr", "cmd", "crit", "kt", "timeout", "xp", "cfg", "obj", "aux", "nc", "std", "cp", "ctrl", "gc", "pg", "ppo", "conf", "ca", "txt", "history", "resp", "cf", "pause", " context", "pat", "dl", "cc", "proc", "tk", "batch", "np", "org", "work", " cx", "cv", "mom", "kl", "etc", "kj", "tm", "jac", "jp", "cu", "tc", "cm", "pt", "dc", "func", "ct", "act", "desc", "cl", "prefix", "rt", "ck", "pri", "jj", "tz", "dad", "fc", "inst", "sc"], "t2": ["m4", "titletwo", " tid1", " pt1", "p1", "T3", "titleTwo", "ttwo", "t1", "tmsg", "T2", "title4", "f3", " t02", " tidpl", " t4", "pttwo", " tTwo", " ptpl", "Tpl", " tidmsg", " tpl", "p2", " pt2", "t02", " t5", " ttwo", "m5", "t3", "pt2", "f2", "t5", " t3", "tpl", "m1", "fpl", " ptmsg", " t1", "T02", "tTwo", "pt4", "ptTwo", " tid2", " tmsg", "p02", "T4", "T1", "T5", "m2", "f1", "t4", "p3", "title2"], "cmp_buf": ["cmpmembuf", "cmpmemmat", "cmp____bu", "cmp_buff", "cmpxvec", "cmp_pkg", "eq____buffer", "eq____bu", "cmp_mat", "cmp____buffer", "comp_mat", "comp_pkg", "eq_bu", "cmp2buf", "cmp____loc", "cmp_loc", "cmp_bu", "cmpmembuffer", "eq_buf", "cmp____buf", "cmp2bu", "cmp2buff", "comp_vec", "cmp_buffer", "cmpmemloc", "comp_cb", "eq____loc", "cmp2mat", "cmp2buffer", "eq_loc", "eq_buffer", "cmp_vec", "cmp_cb", "cmpmembu", "comp_bu", "cmp2cb", "comp_buf", "cmpxbuffer", "comp_buff", "comp_buffer", "cmpxbuf", "cmpxpkg", "eq____buf"]}}
{"project": "FFmpeg", "commit_id": "3a54c221d574ec944db1eddf9df895808f32bf9e", "target": 1, "func": "static const char *read_ts(const char *buf, int *ts_start, int *ts_end,\n\n                           int *x1, int *y1, int *x2, int *y2)\n\n{\n\n    int i, hs, ms, ss, he, me, se;\n\n\n\n    for (i=0; i<2; i++) {\n\n        /* try to read timestamps in either the first or second line */\n\n        int c = sscanf(buf, \"%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d\"\n\n                       \"%*[ ]X1:%u X2:%u Y1:%u Y2:%u\",\n\n                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,\n\n                       x1, x2, y1, y2);\n\n        buf += strcspn(buf, \"\\n\") + 1;\n\n        if (c >= 8) {\n\n            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;\n\n            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;\n\n            return buf;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 15133, "substitutes": {"buf": ["bar", "bytes", "Buff", "vec", "cf", "mem", "paste", "ref", "out", "data", "pb", "aka", "cmd", "ctx", "p", "this", "raw", "Buffer", "bh", "vp", "conv", "v", "text", "bur", "port", "batch", "bt", "read", "msg", "buff", "bin", "end", "rb", "ob", "np", "new", "br", "cat", "func", "doc", "fg", "buffer", "cb", "block", "db", "cv", "img", "uffy", "cp", "b", "gc", "bc", "pg", "tmp", "iter", "uf", "err", "queue", "q", "pkg", "w", "str"], "ts_start": ["ps_end", "ts__start", "pt_start", "ts1end", "uts_start", "uts_begin", "ps_start", "ats_Start", "uts_step", "ts_open", "ts__end", "ats_end", "pt_end", "ps_begin", "ts_range", "ats_range", "ts__begin", "pt_first", "ts_begin", "ts1open", "ts1first", "ts_Start", "ts1start", "ts_first", "ts_step", "pt_open", "ats_start", "uts_end"], "ts_end": ["ts_stop", "ps_end", "ps_END", "ts__start", "ps_start", "ts__END", "ats_fin", "ts_line", "ts__end", "ts__roll", "ts_ended", "ats_end", "ats_start", "ts_END", "ats_ended", "ats_line", "ps_roll", "ats_stop", "ts_fin", "ts_range", "ats_range", "ts_roll"], "x1": ["ex01", "x0", "ix1", "y0", "ix01", "ix3", "ix2", "ex1", "y3", " x01", "x01", "ex3", "ex0", "x3", " x0", "ex2", " x3"], "y1": ["Y3", "Y5", " y5", "ty2", "ny5", "y01", "ny0", "my01", "y0", "my3", "Y01", "ty01", "Y0", "ny2", "y3", "my1", "Y1", "my2", "y5", "ty1", "Y2", " y0", "ny1", "ty3"], "x2": ["x4", "ex4", "exTwo", "ix3", "xt2", "ix8", "ix2", "xt3", "ex1", "y3", "ixTwo", "xtTwo", "x8", "xTwo", "ex3", "ex8", " x4", "x3", "ex2", "y4", " x3", "xt8"], "y2": ["x4", "x6", " y4", "ty2", " y6", "y6", " y3", "xtwo", " ytwo", "y3", "ty4", "ztwo", "z2", "ytwo", "z3", "ty6", "ty1", "x3", "y4", "z1"], "i": ["index", "li", " c", "go", "iu", "out", "inter", "ii", " j", "I", "pi", "ini", "ei", "j", "mi", "n", "ind", "si", "conv", "v", "chain", "gu", "bi", "t", "is", "ui", "di", " ii", "ai", "m", "in", "r", "hi", "ie", "qi", "xi", " bi", "sim", "info", "im", "c", "ci", "mc", "ti", "e", "conf", "it", "multi", "fi", "phi", "init", " err", "us", "y", "ic", "ix", "ip"], "hs": ["gs", "bs", "ths", "windows", "ys", "hm", "hy", "ems", "xs", "ha", "cks", "his", "ds", "ires", "ls", "heads", "hi", "s", "hd", "ts", "rh", "vs", "sh", "ins", "inters", "ns", "ils", "cs", "maps", "h", "ims", "es", "fs", "HS", "ks", "hl", "mes", "its", "hn", "hes", "hh", "sts", "mn", "rs", "ps"], "ms": ["bs", "mi", "ys", "js", "ems", "is", "mos", "sm", "sys", "ls", "m", "MS", "ml", "s", "mins", "mys", "ts", "mus", "mm", "mas", "vs", "ns", "mc", "cs", "es", "ims", "mp", "les", "mt", "fs", "ks", "mis", "mes", "mb", "ma", "us", "mn", "rs", "mx", "ps"], "ss": ["ses", "ress", "gs", "sw", "bs", "rss", "ys", "sy", "js", "si", "css", "sv", "sys", "pse", "ls", "iss", "s", "ess", "sim", "ts", "sr", "sh", "ns", "cs", "ser", "es", "fs", "ks", "sd", "SS", "mes", "sc", "rs", "su", "ps"], "he": ["ae", "He", "ime", "hy", "che", "ale", "him", "ha", "ile", "le", "aste", "hem", "sv", "ke", "em", "ene", "pse", "hi", "ue", "hd", "she", "het", "en", "oh", "sche", "we", "sh", "mn", "ose", "h", "e", "HE", "spe", "hen", "mes", "her", "eh", "ve", "ma", "hes", "te", "pe"], "me": ["mem", "mer", "mi", "ems", "ale", "lem", "le", "ge", "aste", "hem", "mite", "pse", "ke", "em", "Me", "mate", "m", "ml", "men", "gre", "ue", "dem", "ome", "mus", "mn", "sche", "eme", "mit", "we", "sem", "mp", "es", "e", "mt", "de", "mes", "ma", "mie", "ve", "te", "ME", "pe", "mx"], "se": ["sis", "ses", "be", "si", "sl", "le", "ge", "SE", "sea", "sv", "sb", "st", "pse", "ke", "ze", "sa", "sk", "th", "sc", "so", "she", "sr", "sche", "sex", "sh", "sem", "ser", "ese", "es", "fr", "e", "de", "sd", "ape", "mes", "sle", "ve", "ne", "ma", "te", "pe", "ch", "su", "ase"]}}
{"project": "qemu", "commit_id": "3f2cbf0d1a1340bed4a63e05b044c46df93f4768", "target": 1, "func": "target_phys_addr_t cpu_get_phys_page_debug(CPUState *env, target_ulong addr)\n\n{\n\n    target_ulong pde_addr, pte_addr;\n\n    uint64_t pte;\n\n    target_phys_addr_t paddr;\n\n    uint32_t page_offset;\n\n    int page_size;\n\n\n\n    if (env->cr[4] & CR4_PAE_MASK) {\n\n        target_ulong pdpe_addr;\n\n        uint64_t pde, pdpe;\n\n\n\n#ifdef TARGET_X86_64\n\n        if (env->hflags & HF_LMA_MASK) {\n\n            uint64_t pml4e_addr, pml4e;\n\n            int32_t sext;\n\n\n\n            /* test virtual address sign extension */\n\n            sext = (int64_t)addr >> 47;\n\n            if (sext != 0 && sext != -1)\n\n                return -1;\n\n\n\n            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pml4e = ldq_phys(pml4e_addr);\n\n            if (!(pml4e & PG_PRESENT_MASK))\n\n                return -1;\n\n\n\n            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK))\n\n                return -1;\n\n        } else\n\n#endif\n\n        {\n\n            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK))\n\n                return -1;\n\n        }\n\n\n\n        pde_addr = ((pdpe & ~0xfff) + (((addr >> 21) & 0x1ff) << 3)) &\n\n            env->a20_mask;\n\n        pde = ldq_phys(pde_addr);\n\n        if (!(pde & PG_PRESENT_MASK)) {\n\n            return -1;\n\n        }\n\n        if (pde & PG_PSE_MASK) {\n\n            /* 2 MB page */\n\n            page_size = 2048 * 1024;\n\n            pte = pde & ~( (page_size - 1) & ~0xfff); /* align to page_size */\n\n        } else {\n\n            /* 4 KB page */\n\n            pte_addr = ((pde & ~0xfff) + (((addr >> 12) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            page_size = 4096;\n\n            pte = ldq_phys(pte_addr);\n\n        }\n\n        if (!(pte & PG_PRESENT_MASK))\n\n            return -1;\n\n    } else {\n\n        uint32_t pde;\n\n\n\n        if (!(env->cr[0] & CR0_PG_MASK)) {\n\n            pte = addr;\n\n            page_size = 4096;\n\n        } else {\n\n            /* page directory entry */\n\n            pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) & env->a20_mask;\n\n            pde = ldl_phys(pde_addr);\n\n            if (!(pde & PG_PRESENT_MASK))\n\n                return -1;\n\n            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {\n\n                pte = pde & ~0x003ff000; /* align to 4MB */\n\n                page_size = 4096 * 1024;\n\n            } else {\n\n                /* page directory entry */\n\n                pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & env->a20_mask;\n\n                pte = ldl_phys(pte_addr);\n\n                if (!(pte & PG_PRESENT_MASK))\n\n                    return -1;\n\n                page_size = 4096;\n\n            }\n\n        }\n\n        pte = pte & env->a20_mask;\n\n    }\n\n\n\n    page_offset = (addr & TARGET_PAGE_MASK) & (page_size - 1);\n\n    paddr = (pte & TARGET_PAGE_MASK) + page_offset;\n\n    return paddr;\n\n}\n", "idx": 15136, "substitutes": {"env": ["server", "nv", "network", "param", "conn", "sw", "et", "manager", "exc", "environment", "dn", "estate", "attr", "ctx", "response", "ner", "eve", "window", "erd", "operator", "vp", "vert", "v", "esc", "engine", "er", "msg", "end", "den", "ef", "ener", "ew", "context", "era", " environment", "ah", "shell", "vm", "console", "inv", "cv", "event", "en", "ec", "vs", "ov", "dev", "here", "e", "Environment", "conf", "entry", "door", "config", "enter", "eng", "ve", "err", "eh", "ev", "vt", "equ", "gear", "forge", "ter", "te", "viron", "worker"], "addr": ["resp", "rc", "index", "a", "mem", "ptr", "oc", "ref", "src", "usr", "asm", "address", "attr", "l", "cmd", "hw", "size", "dr", "ord", "ha", "adj", "ar", "adr", "len", "er", "msg", "offset", "act", "oad", "r", "gate", "alt", "gt", "eth", "sha", "add", "rt", "res", "wd", "ack", "ether", "start", "id", "adv", "ad", "order", "iter", "hl", "hash", "ash", "elt", "err", "ip", "rr", "arr", "rs", "ix", "Address", "arp"], "pde_addr": ["pde_address", "pne__err", "pne_addr", "ple_addr", "pdis_address", "pdis_conn", "pde__addr", "pne_err", "pne__adr", "ple_address", "ple_add", "pde_ack", "pne_adr", "pde_adr", "pdis_addr", "pne__addr", "pde_conn", "pde_add", "pde_ptr", "pde__err", "pde__adr", "pne__ptr", "pne_ptr", "pde__ptr", "pdis_ack", "pde_err"], "pte_addr": ["ptee_id", "pte_id", "ptee_add", "ptee_addr", "pte_address", "pte_add", "ptee_address"], "pte": ["cmdes", "nte", "ptee", "apte", "cmdE", "ntee", "ntes", "ntE", "ptE", "aptE", "cmdee", "aptes", "aptee", "cmde", "ptes"], "paddr": ["Pptr", "padd", "_add", "Paddr", "_address", "pptr", " pptr", "paddress", "_ptr", "Paddress", " paddress", "Padd", " padd", "_addr"], "page_offset": [" page_no", "page_no", "page_pos", " page_pos"], "page_size": ["page_len", " page_len", "page_ize", " page_ize"], "pdpe_addr": ["pdje___pad", "pdpe_conn", "pdpe____pkg", "pdje_addr", "pdpe_add", "pdpe_____pad", "pdpe___addr", "pdpe_____addr", "pdpe__ptr", "pdpe__addr", "pdpe____pad", "pdpe___inter", "pdpe___url", "pde_pad", "pdple2url", "pde_src", "pdje_pad", "pdpe_ref", "pdpe_ptr", "pdpe_address", "pdpe_sha", "pdpe__address", "pdple_url", "pdple2ptr", "pderensha", "pderensrc", "pdpe__add", "pdple_addr", "pdpe2addr", "pdpe____inter", "pdperenpad", "pdje___inter", "pdpe_____src", "pdle_addr", "pdpe__url", "pdpe2ptr", "pdpe____ref", "pdle_mem", "pdpe____addr", "pdpe__pkg", "pdperensha", "pdple2addr", "pdpe_mem", "pdpe_inter", "pdple2pkg", "pdped_conn", "pde_sha", "pdpe_pad", "pdperensrc", "pderenaddr", "pdje___url", "pdple_pkg", "pdpe2url", "pdpe_src", "pdple_ptr", "pdpe____url", "pdpe_____sha", "pdpe____conn", "pdpe2pkg", "pdped_pkg", "pdperenaddr", "pdped_addr", "pdpe_pkg", "pdpe_url", "pdpe___pad", "pdle_add", "pderenpad", "pdje_url", "pdle_address", "pdje_inter", "pdpe__mem", "pdje___addr", "pdped_ref"], "pde": ["prene", "dene", " pdef", " pene", "piddef", "pdes", "apdel", "ddef", "pdde", " pdu", "piddem", "pene", "apdes", "pdne", "prde", "pddel", "pdene", "pddes", "prdu", "pcdes", "pddem", "pdef", "apde", "pcne", "pcde", "pdem", "pdu", "pne", "apne", "pdel", "pidde", "pcdel", "prdef", "pidene", "pddef", "dde", "ddu", " pdem"], "pdpe": ["pedpes", "pidpe", "pxpe", "pdfke", "djpl", "pmpei", "pdpl", "pdpse", "cdke", "pdfPE", "ddde", "pdpei", "pdces", "ddpe", "dlPe", "dpPe", "ddpl", "phppe", "cdfe", "pmpe", "phppes", "pdest", "pmde", "PDPE", "pdpee", "pmpee", "pdfpse", "pdPe", "djpe", "pidces", "djPe", "cdpe", "dpPE", "pdfest", "phpfle", "dlpe", "dpde", "dlpl", "PDpe", "dppe", "pidpes", "dpest", "pdde", "PDene", "pxest", "pdene", "pidfle", "ddppe", "pxpse", "pdfpe", "dpene", "ddPe", "pedfe", "pdfPe", "pnpes", "pedke", "pdfe", "pxde", "pdfpes", "pdffe", "dlppe", "pdke", "ddpei", "pdPE", "djppe", "dppse", "pdfene", "pdpes", "pedpe", "pnpe", "pdfle", "pnces", "pdppe", "PDPe", "cdpes", "dppei", "dppee", "phpces", "pdfde", "pnfle", "ddpee"], "pml4e_addr": ["pml4e_add", "pml4se_attr", "pml4pe_address", "pml4e_attr", "pml4e2attr", "pml4e__add", "pml4e__ptr", "pml4e_rev", "pml4e__attr", "pml4eu_rev", "pml4pe__ptr", "pml4pe_ptr", "pml4e_address", "pml4se_add", "pml4pe__addr", "pml4pe_addr", "pml4e_ptr", "pml4e__address", "pml4eu_ptr", "pml4pe__address", "pml4e2addr", "pml4e2add", "pml4eu_addr", "pml4eu_address", "pml4se_addr", "pml4e__addr"], "pml4e": ["pmil49me", "pml5ea", "pmil4me", "pml3se", "pml4pe", "pml246se", "pML5ee", "pml4ee", "pml4se", "pnl6e", "pml5e", "pml49ee", "pml3me", "pml6te", "pkl4ea", "pml5ee", "pml6me", "pmil49e", "pml6pe", "pml5ge", "pml8me", "pnl4te", "pml246e", "pml3te", "pml3ea", "pkl5ee", "pml5me", "pml8e", "pml4er", "pnl4e", "pmil4e", "pml6er", "pml2e", "pml2te", "pml3e", "pnl6er", "pmil4ge", "pkl4se", "pml6ge", "pnl6te", "pml4me", "pml49ge", "pmil4ee", "pML5me", "pml3ee", "pkl4ee", "pml49me", "pmil49ee", "pml3pe", "pML4e", "pML4ee", "pml4ge", "pml4ea", "pnl6pe", "pml5se", "pml2er", "pml2pe", "pml6e", "pkl5se", "pML4me", "pml246ea", "pML5e", "pkl5e", "pml246ee", "pml4te", "pnl4pe", "pml8ee", "pml6ee", "pkl4e", "pml3er", "pkl5ea", "pml49e", "pmil49ge", "pnl4er"], "sext": ["seext", "speft", "seux", "SEux", "sexit", " sexp", "pseft", "psexp", " Sext", "teft", "spexp", "spext", " seux", "leux", " Sex", " seft", " sexit", "SEx", "speext", "text", "pext", "SEext", "psex", "leext", "pexp", "SExt", " sex", " seext", "sexp", "teext", " Sexp", "psexit", "sex", " Sexit", "seft", "lex", "lext", "psext", "texp", "SExp", "pseext", "peft", "SEft", "peext"]}}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "void spapr_pci_rtas_init(void)\n\n{\n\n    spapr_rtas_register(\"read-pci-config\", rtas_read_pci_config);\n\n    spapr_rtas_register(\"write-pci-config\", rtas_write_pci_config);\n\n    spapr_rtas_register(\"ibm,read-pci-config\", rtas_ibm_read_pci_config);\n\n    spapr_rtas_register(\"ibm,write-pci-config\", rtas_ibm_write_pci_config);\n\n    if (msi_supported) {\n\n        spapr_rtas_register(\"ibm,query-interrupt-source-number\",\n\n                            rtas_ibm_query_interrupt_source_number);\n\n        spapr_rtas_register(\"ibm,change-msi\", rtas_ibm_change_msi);\n\n    }\n\n}\n", "idx": 15147, "substitutes": {}}
{"project": "qemu", "commit_id": "8ec14402029d783720f4312ed8a925548e1dad61", "target": 0, "func": "static void compare_sec_rs_finalize(SocketReadState *sec_rs)\n\n{\n\n    CompareState *s = container_of(sec_rs, CompareState, sec_rs);\n\n\n\n    if (packet_enqueue(s, SECONDARY_IN)) {\n\n        trace_colo_compare_main(\"secondary: unsupported packet in\");\n\n    } else {\n\n        /* compare connection */\n\n        g_queue_foreach(&s->conn_list, colo_compare_connection, s);\n\n    }\n\n}\n", "idx": 15173, "substitutes": {"sec_rs": [" sec_ros", "sect_rs", " sec_rd", "sec_RS", "sect_rt", " sec_res", "sec_rt", "sec_ros", "sec___RS", "sect_res", "sec___res", " sec_RS", "sec___ros", "sect_ris", "sec_ris", "sec___rs", "sec_rd", "sec_res"], "s": ["sis", "ses", "south", "gs", "a", "S", "sing", "sw", "less", "l", "p", "js", "sq", "v", "g", "sl", "t", "syn", "comm", "sm", "sb", "is", "sv", "sys", "hs", "sf", "ds", "ls", "ats", "m", "sa", "r", "ssl", "qs", "ts", "self", "c", "sp", "stats", "b", "ns", "h", "es", "e", "fs", "os", "d", "se", "ps", "z", "sports", "ss", "sts", "w", "y", "rs", "copy"]}}
{"project": "qemu", "commit_id": "b47b35250fbfa062aedf6ab6e5faab84c4a76f4f", "target": 1, "func": "FDCtrl *fdctrl_init_isa(DriveInfo **fds)\n\n{\n\n    ISADevice *dev;\n\n\n\n    dev = isa_create(\"isa-fdc\");\n\n    if (fds[0]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveA\", fds[0]->bdrv);\n\n    }\n\n    if (fds[1]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveB\", fds[1]->bdrv);\n\n    }\n\n    if (qdev_init(&dev->qdev) < 0)\n\n        return NULL;\n\n    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);\n\n}\n", "idx": 15201, "substitutes": {"fds": ["fycks", "qeps", "feedcks", "fdates", "feeddocs", "fabrs", "frs", "qds", "fortds", "fydocs", "vds", "fabdat", "tyds", "feedds", " fdates", "gooddds", " fls", "fd", "prs", "qdds", "qrets", "qdates", "feps", " faults", "fls", "pd", "fdocs", "fabrets", "forteps", "tyaults", "pls", "fdat", "tydds", " feps", "fabds", "fyds", "vls", "vrs", "qdat", "fabaults", "feedrets", "fortdates", "goodds", "qrs", "tyrs", "gooddat", "fcks", "fabdds", " fd", "fortrs", "frets", "fyrets", "fdds", "faults", " frs", "vd", "goodrets", " fdds", "qdocs", "pds", "qcks"], "dev": ["rem", "def", "des", "mem", "DEV", "go", "conn", "serv", "ver", "det", "data", "cmd", "hw", "tr", "Dev", "temp", "val", "v", "gu", "den", "priv", "di", "ow", "buf", "end", "new", "tech", "cam", "nt", "dd", "desc", "env", "obj", "doc", "comment", "add", "dem", "fo", "db", "debug", "wd", "device", "die", "cho", "adv", "ach", "develop", "de", "ad", "sd", "var", "enc", "d", "eng", "ve", "ev", "del", "dat", "w", "adj", " Dev", "pay"]}}
{"project": "FFmpeg", "commit_id": "c571424c7f6276a6374e1784ce2a33d4b6a4292d", "target": 1, "func": "static int asf_read_picture(AVFormatContext *s, int len)\n\n{\n\n    ASFContext *asf       = s->priv_data;\n\n    AVPacket pkt          = { 0 };\n\n    const CodecMime *mime = ff_id3v2_mime_tags;\n\n    enum  AVCodecID id    = AV_CODEC_ID_NONE;\n\n    char mimetype[64];\n\n    uint8_t  *desc = NULL;\n\n    AVStream   *st = NULL;\n\n    int ret, type, picsize, desc_len;\n\n    ASFStream *asf_st;\n\n\n\n    /* type + picsize + mime + desc */\n\n    if (len < 1 + 4 + 2 + 2) {\n\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture size: %d.\\n\", len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* picture type */\n\n    type = avio_r8(s->pb);\n\n    len--;\n\n    if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) {\n\n        av_log(s, AV_LOG_WARNING, \"Unknown attached picture type: %d.\\n\", type);\n\n        type = 0;\n\n    }\n\n\n\n    /* picture data size */\n\n    picsize = avio_rl32(s->pb);\n\n    len    -= 4;\n\n\n\n    /* picture MIME type */\n\n    len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype));\n\n    while (mime->id != AV_CODEC_ID_NONE) {\n\n        if (!strncmp(mime->str, mimetype, sizeof(mimetype))) {\n\n            id = mime->id;\n\n            break;\n\n        }\n\n        mime++;\n\n    }\n\n    if (id == AV_CODEC_ID_NONE) {\n\n        av_log(s, AV_LOG_ERROR, \"Unknown attached picture mimetype: %s.\\n\",\n\n               mimetype);\n\n        return 0;\n\n    }\n\n\n\n    if (picsize >= len) {\n\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture data size: %d >= %d.\\n\",\n\n               picsize, len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* picture description */\n\n    desc_len = (len - picsize) * 2 + 1;\n\n    desc     = av_malloc(desc_len);\n\n    if (!desc)\n\n        return AVERROR(ENOMEM);\n\n    len -= avio_get_str16le(s->pb, len - picsize, desc, desc_len);\n\n\n\n    ret = av_get_packet(s->pb, &pkt, picsize);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    st  = avformat_new_stream(s, NULL);\n\n    if (!st) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));\n\n    asf_st = asf->asf_st[asf->nb_streams];\n\n    if (!asf_st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;\n\n    st->codec->codec_type         = asf_st->type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id           = id;\n\n    st->attached_pic              = pkt;\n\n    st->attached_pic.stream_index = asf_st->index = st->index;\n\n    st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n\n\n\n    asf->nb_streams++;\n\n\n\n    if (*desc) {\n\n        if (av_dict_set(&st->metadata, \"title\", desc, AV_DICT_DONT_STRDUP_VAL) < 0)\n\n            av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n    } else\n\n        av_freep(&desc);\n\n\n\n    if (av_dict_set(&st->metadata, \"comment\", ff_id3v2_picture_types[type], 0) < 0)\n\n        av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_freep(&desc);\n\n    av_free_packet(&pkt);\n\n    return ret;\n\n}\n", "idx": 15206, "substitutes": {"s": ["sql", "aws", "ses", "south", "gs", "a", "S", "f", "as", "sw", "bs", "l", "j", "p", "n", "js", "ex", "bits", "sq", "v", "g", "http", "ms", "simple", "t", "us", "comm", "is", "sv", "er", "sys", "hs", "ds", "ats", "ls", "m", "y", "r", "qs", "c", "stats", "vs", "ins", "sync", "ns", "b", "cs", "h", "ims", "an", "es", "set", "ops", "changes", "fs", "conf", "os", "bis", "its", "z", "q", "sports", "ss", "sts", "w", "i", "rs", "ps"], "len": ["vol", "fun", "ln", "cmp", "lib", "compl", "val", "sl", "le", "t", "loc", "den", "lang", "nt", "lit", "en", "fn", "limit", "length", "del", "lim", "fin", " length", "mun", "li", "nl", "ellen", "mem", "ptr", "lf", "ll", "data", "n", "conv", "syn", "la", "lis", "pos", "hl", "total", "elt", "full", "mn", "ref", "Len", "seq", "dl", "lon", "lp", "trans", " l", "kl", "iter", "enc", "err", "str", "ld", "bytes", "il", "size", "l", "L", "ail", "el", "gen", "fl", "num", "ls", "ml", "wid", "all", "lt", "lan", "oln", "h", "list", "pl"], "asf": [" asfe", "Asfe", " esfe", " asfo", "Asft", " esf", " asft", "asft", "Asfo", "Asf", "asfe", " esfo", "asfo", " esft"], "mime": [" mimet", "cmime", "amie", "Mim", "gmimet", "mature", "MIME", "pIME", "mimet", " mim", "mim", " mature", "amim", "cmie", "Mie", "pim", "pime", "smime", "pie", "gmime", "amime", "gmie", "smIME", "amature", "Mature", "Mime", "gmIME", "amIME", " mie", "smim", "mie", "mIME", "smie", " mIME", "cmIME", "Mimet", "cmim"], "mimetype": ["memetme", "mimagetyop", "memettype", "mimetpe", "mimetrypes", "mrimenamepe", "mimetytype", "mimeleype", "mimemepen", "mimenamepl", "mimagitypen", "mimityop", "mimiype", "mimitypes", "mimettype", "mimagetype", "mimitytype", "mimenamepe", "mrimetypen", "mimitypl", "mimetme", "mimagitytype", "memetype", "mrimenamepen", "mimemepe", "mimestyleype", "mrimetypl", "mimestylepes", "mimerype", "mimagestylepe", "mimiytype", "mimetyme", "mimagetyme", "mimenameme", "mimetypse", "mimetyop", "memetyype", "memetpe", "mimestylepse", "mimicype", "mimeryse", "mimemepl", "mimicyme", "mimetp", "mimiypes", "mimestylese", "mimitypse", "mimeletype", "mimenamepen", "memetytype", "mimestylepe", "mrimetype", "mimetypes", "mimeleme", "mimagetypes", "mimetyse", "mimiypse", "mimagetytype", "mimagitype", "memetyme", "mimelistop", "mimagestyleme", "mimetryop", "mimememe", "mimelepe", "mimagitypes", "mimetypen", "mimestyleme", "mrimetyme", "mimagetypse", "mimetpes", "mimityme", "mimetyp", "mimagetyse", "mimestylep", "mimelistpe", "mimagestylese", "mimestyletype", "mimitype", "mimelistpes", "mimetypl", "mrimenamepl", "mimagetypen", "mimetyype", "mrimenameme", "mimicyse", "mimelistpen", "mimagitypse", "mimetrypen", "mimetrype", "mimitypen", "mimityp", "mimagityop", "mimeryme"], "desc": ["resp", "def", "des", "dict", "ptr", "ref", "seq", "pres", "cmd", "tr", "cmp", "raw", "feat", "DES", "text", "esc", "msg", "buf", "buff", "sec", "ext", "ds", "dist", "nt", "description", "obj", "meta", "doc", "comment", "sc", "disc", "pos", "summary", "ec", "comp", "res", "bc", "dev", "id", "rec", "label", "cont", "enc", "uf", "asc", "str", "Desc", "txt", "sub", "alloc"], "st": ["ste", "stable", "est", "sw", "src", "sta", "St", "ST", "ist", "stream", "sl", "t", "stop", "ct", "nt", "rest", "th", "so", "sp", "std", "sh", "start", "it", "se", "sth", "inst", "sc", "str"], "ret": ["rc", " val", " alt", "l", " num", "Ret", "RET", "val", " code", "nt", " fmt", "lit", "tag", "alt", " reply", " ans", " resp", "rt", "rev", "en", " flag", "flag", " res", "elt", "err", " Ret"], "type": ["status", "types", "key", "error", "ty", "Type", "at", "ime", "ver", "size", "family", "p", "class", "cmp", "role", "typ", "check", "test", "field", "t", "ping", "kind", "date", "title", "tag", "al", "r", "none", "time", "info", "TYPE", "block", "count", "file", "null", "byte", "pos", "code", "like", "color", "start", "ype", "id", "length", "tp", "shape", "style", "token", "format", "name", "ico", "pe"], "picsize": ["picoiz", "picoize", "mickingIZE", "picssize", "picksizer", " picssize", "apicsiz", "Picksizer", "piqueszie", "mickingize", "picsizer", " picsizer", "pICSiz", "piquesense", "picketsize", " pinsIZE", " pinsizer", "picketszie", "piquesiz", "micketsiz", "picketsense", "micsizer", " picsiz", "pICSizer", "picoze", "PicksIZE", "Picksiz", "pickingsize", "apickingiz", "picize", "piquesize", "pickingize", "micsense", "apickingze", "piciz", " picze", "piczie", "pICSze", "apicsizer", "picze", "pinsIZE", "micketsize", "apickingizer", "micsiz", "apickingize", "picszie", "picizer", " piciz", "apicsize", "micketszie", "Picksize", " picize", "picsense", "pICSize", "micketsense", "picsIZE", "picosize", "micszie", "picksiz", " pinsize", "Picsize", "picksize", "Picsizer", "micsIZE", "pICSIZE", " picsze", "picketsiz", "apicsze", "pinsize", "pickingIZE", "Picsiz", " pinsiz", "picsiz", "mickingiz", "PicsIZE", " picsIZE", "pickingizer", "picksIZE", "mickingizer", "pickingiz", "picense", "pickingze", "picIZE", "pinsizer", "pinsiz", "picsze", "micsize"], "desc_len": [" desc_length", "desc_lon", "esc_gen", " desc_ln", " desc_l", "desc2en", "desc_en", "disc_mem", "desc_ln", "desc_loc", "desc2mem", "disc_en", "desc_length", "esc_length", "desc_gen", "desc2len", "desc2lon", "esc_loc", "disc_lon", "desc_mem", "disc_len", "desc_l", " desc_gen", "esc_len"], "asf_st": ["asfo_src", "asfo_stream", "asfo_st", "asfo_sp", "asf_stream", "asf_sp", "asf_src"]}}
{"project": "qemu", "commit_id": "c0f4af171999eda4e49de5169906ce98246457f0", "target": 1, "func": "void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)\n{\n    const ARMCPRegInfo *ri = rip;\n    switch (ri->accessfn(env, ri)) {\n    case CP_ACCESS_OK:\n    case CP_ACCESS_TRAP:\n        break;\n    case CP_ACCESS_TRAP_UNCATEGORIZED:\n        env->exception.syndrome = syn_uncategorized();\n        break;\n    default:\n        g_assert_not_reached();", "idx": 15209, "substitutes": {"env": ["server", "ce", "nv", "jp", "mem", "conn", "et", "environment", "estate", "ctx", "hw", "window", "erd", "vp", "v", "pp", "sb", "er", "En", "ef", "em", "shell", "context", "obj", "vm", "en", "nc", "ec", "ep", "vs", "ov", "dev", "e", "Environment", "state", "config", "enter", "eng", "me", "EN", "eh", "ev", "vt", "w", "network", "sc", "te", "viron", "pe"], "rip": ["rig", "ipp", "rem", "rack", "jp", "gra", "rup", "rim", "ra", "trip", "ring", "pr", "par", "ping", "xp", "pp", "rid", "roy", "rep", "ripp", "rub", "rib", "rh", "RI", "strip", "rin", "rob", "tri", "rain", "rd", "piece", "RIP", "ip", "pa", "rap", "ps"], "syndrome": ["syindritic", "cyndchrome", " syntroma", " syndroma", "symondrom", "syntritic", "symondrome", "syndritic", "syindrom", "cyndroma", " syntrome", "cyntchrome", " syndritic", " syntrom", "syntchrome", "syordrom", "syndrom", "symondritic", "cyntrom", "syntrom", "syordchrome", " syndrom", "syindroma", "syndroma", "syntroma", "syordrome", "syindchrome", "syntrome", "syindrome", "cyndrome", "cyndrom", "cyntroma", "syordroma", "symondroma", "syndchrome", "cyntrome", " syntritic"], "ri": ["ni", "gra", "rus", "ric", "mi", "ra", "ini", "pi", "rn", "ki", "rf", "si", "ir", "rir", "rl", "vi", "ru", "na", "rid", "rm", "ami", "rio", "r", "hi", "iro", "xi", "rt", "iri", "rub", "ani", "ro", "rh", "pri", "sr", "rive", "ry", "RI", "rin", "riv", "tri", "ti", "rob", "rd", "gi", "raf", "ris", "rx", "i", "pa", "rs", "udi", "rap"]}}
{"project": "qemu", "commit_id": "b7c8c35f0afb62efcacd18a64067fe164e3206b6", "target": 1, "func": "static char *scsibus_get_dev_path(DeviceState *dev)\n\n{\n\n    SCSIDevice *d = DO_UPCAST(SCSIDevice, qdev, dev);\n\n    DeviceState *hba = dev->parent_bus->parent;\n\n    char *id = NULL;\n\n\n\n    if (hba && hba->parent_bus && hba->parent_bus->info->get_dev_path) {\n\n        id = hba->parent_bus->info->get_dev_path(hba);\n\n    }\n\n    if (id) {\n\n        return g_strdup_printf(\"%s/%d:%d:%d\", id, d->channel, d->id, d->lun);\n\n    } else {\n\n        return g_strdup_printf(\"%d:%d:%d\", d->channel, d->id, d->lun);\n\n    }\n\n}\n", "idx": 15239, "substitutes": {"dev": ["pro", "am", "def", "des", "mem", "DEV", "conn", "serv", "o", "out", "ver", "cmd", "hw", "p", "ex", "raw", "Dev", "dis", "v", "test", "pt", "priv", "buf", "ds", "nt", "cam", "dd", "desc", "att", "env", "obj", "doc", "add", "dem", "info", "db", "debug", "device", "die", "unknown", "h", "ad", "de", "os", "ve", "ev", "vt", "w", "cast", "av", "ch"], "d": ["def", "des", "dict", "f", "out", "dn", "ind", "l", "j", "p", "dr", "D", "dl", "ord", "dis", "dm", "pd", "ded", "done", "du", "t", "md", "di", "dc", "ds", "da", "dd", "r", "bd", "dim", "dq", "dx", "c", "dj", "db", "dot", "debug", "ad", "de", "sd", "mod", "dh", "del", "dat", "did", "w", "ld", "dra"], "hba": ["hrca", "hca", "hva", "ehca", "hbo", "Hca", "ohca", "Hba", " hva", "hdha", "hbra", "hdca", "hbc", " hbal", "haca", "ohva", "hben", " hBA", "shbo", "hda", "habu", "rhda", "hrbal", "hBA", " hha", "haba", "ohBA", "haben", "ohba", "hha", "shva", "habal", "ohda", "rhba", " hbc", "ohbc", "habre", " hda", "hbu", " hbo", "ehbu", " hben", " hbu", "rhca", "rhbra", " hbra", " hbre", "ehbre", "ehba", "ohbo", "HBA", "heca", "hrben", " hca", "shba", "hebo", "hbal", "Hbc", "heha", "hdbo", "ohbra", "shBA", "hbre", "hrba", "heba", "hdba"], "id": ["bit", "ide", "key", "path", "index", "a", "f", "and", "ref", "entity", "Id", "ids", "l", "p", "fd", "kid", "aid", "n", "with", "cd", "el", "t", "md", "source", "hid", "len", "uid", "rid", "mid", "end", "show", "bid", "num", "vid", "in", "tag", "m", "r", "sid", "hide", "url", "channel", "info", "c", "event", "en", "link", "no", "like", "ID", "start", "oid", "h", "iden", "ad", "iter", "pid", "it", "q", "target", "init", "i", "name", "str", "ident", "ip"]}}
{"project": "FFmpeg", "commit_id": "5e65f5df0e0cd91eed74cce87c5d65b19e176595", "target": 0, "func": "static int eval_lpc_coeffs(const float *in, float *tgt, int n)\n\n{\n\n    int x, y;\n\n    double f0, f1, f2;\n\n\n\n    if (in[n] == 0)\n\n        return 0;\n\n\n\n    if ((f0 = *in) <= 0)\n\n        return 0;\n\n\n\n    in--; // To avoid a -1 subtraction in the inner loop\n\n\n\n    for (x=1; x <= n; x++) {\n\n        f1 = in[x+1];\n\n\n\n        for (y=0; y < x - 1; y++)\n\n            f1 += in[x-y]*tgt[y];\n\n\n\n        tgt[x-1] = f2 = -f1/f0;\n\n        for (y=0; y < x >> 1; y++) {\n\n            float temp = tgt[y] + tgt[x-y-2]*f2;\n\n            tgt[x-y-2] += tgt[y]*f2;\n\n            tgt[y] = temp;\n\n        }\n\n        if ((f0 += f1*f2) < 0)\n\n            return 0;\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 15249, "substitutes": {"in": ["by", "at", "f", "gin", "serv", "as", "out", "o", "ind", "l", "inc", "old", "window", "raw", "ln", "ex", "min", "din", "el", "pin", "t", "is", "vin", "pp", "bin", "new", "al", "ai", "inside", "att", "nin", "In", "doc", "add", "ac", "IN", "one", "null", "all", "inn", "en", "ins", "on", "un", "mat", "rin", "input", "inner", "nn", "con", "it", "ne", "win", "isin", "i", "nan", "ine", "ic", "inf", "sum"], "tgt": [" tTarget", "pgn", " tjs", "ttgb", " tgr", " tgest", " targe", " tgz", "tbs", "tgr", "targe", "matgz", "ttgt", " tbs", " target", "trt", "fTarget", "tjs", "tengt", "tgs", " trt", "nbs", "fgt", "ttgz", "tbt", "parg", " tout", "fgb", "frt", "ttls", "fls", "ttbs", " tmp", "nls", "pgs", " tgb", "felt", "wtjs", "Targ", "targ", "nmp", "ttelt", "tgz", "tmp", " tgs", "tls", " targ", "target", "ttbt", " tbt", " tcp", "Tgs", "tengest", "Tgn", "ttarget", "tgb", "wtgt", "tcp", "tttarget", "tsgb", "fbt", "matgr", "pgt", "ttrt", "tout", "tenout", "tTarget", "telt", "tenjs", "ttcp", "tgest", "Tgt", "ngb", "farge", "ncp", "tsgt", "tgn", "ttgr", " tgn", "ntarget", " ttarget", "matgt", " telt", "tsmp", "ttTarget", "ttarge", " tls", "tsls", "ngt", "wtout", "matarget", "wtgest"], "n": ["nl", "ni", " ns", "nw", "nor", "f", "dn", "cn", "l", "j", "p", "name", "v", "g", "ng", "t", " N", "na", "len", "np", "num", "nr", "m", "N", "nt", "k", "c", "nc", "mn", "no", "ns", "d", "nb", "ne", "net", "q", "sn", "i", "nm", "nan", "w", "nn"], "x": ["index", " ax", "ctx", "dr", "xd", "t", "m", "att", "xi", "xc", "lat", "draw", "my", "tx", "xes", "inx", "by", "axis", "wx", "ax", "ind", "yx", "j", "X", "v", "try", "ar", "xp", "read", " w", "xe", "cross", "i", "ex", "xt", "ick", "full", "pe", "ix", "column", "key", "wh", "at", "scroll", "f", "xxx", "row", "xs", "height", "batch", "ox", "fx", "al", " i", " cx", "ry", "lex", "xx", "id", "u", "px", "xf", "xa", "ey", "o", "l", "p", "name", "chain", "xy", "ct", "k", "time", " dx", "dx", "page", "on", "h", "e", "z", "rx", " xx", "w", "xml", "mx"], "y": ["uy", "oy", "py", "dy", "ya", "ay", "t", "yr", "ery", "m", "zy", "s", "iy", "iny", "yu", "yes", "ish", "year", "my", "it", "yo", "by", "yt", "yx", "j", "Y", "v", "g", "try", "kit", "ed", "vy", "ies", "ady", "one", "hey", "yl", "i", "ic", "yy", "key", "ty", "sy", "yi", "height", "di", "cy", "ry", "xx", "ot", "wy", "ey", "yn", "ly", "o", "entity", "ny", "ys", "l", "p", "axy", "xy", "pt", "ym", "ye", "yer", "no", "b", "hot", "h", "col", "sky", "z", "gy", "ch"], "f0": ["xf50", "fa512", "fc1", "fc50", "xf0", "f8", "p1", "fa50", "xf9", "pold", "t1", "told", "fa0", "F0", "t0", "xf1", "F2", "fold", "t2", "F1", "p2", "F8", "fc9", "F512", "p0", "f9", "fc2", " f8", "fa1", " f50", "f50", "F50", "fc512", "t8", "fc0", "f512", "fcold", " f9"], "f1": ["f01", "F9", "f4", " f01", "f8", "p1", "h2", "t1", "fone", "F3", "f3", "F0", "tone", "t0", "F4", "h4", "F2", "h1", " fart", "fart", "F1", "field3", "t2", "p2", "sf0", "h0", "F8", "F01", "fieldart", "field01", " f8", "p0", "f9", "sf1", " f4", "p8", "sf2", "Fart", " f3", "sfone", "t9", "field1", " fone", " f9"], "f2": ["e2", "fc1", "float02", "p1", "cTwo", "t1", "l2", "t7", "f7", "F3", "f3", " fTwo", "F0", "fc10", "l1", "t0", "e3", "c2", " f10", "F2", "e1", "f10", "t2", "F1", "t02", "p2", " f7", "float1", "f02", "l02", "float2", "fc2", "l0", "c1", "t3", "e0", "float0", "fcTwo", "fTwo", "p7", "c10", " f02", "p02"]}}
{"project": "FFmpeg", "commit_id": "71a1f76d3cc937fc1a47f501fc4866f95b74d0b0", "target": 0, "func": "int swr_init(struct SwrContext *s){\n\n    s->in_buffer_index= 0;\n\n    s->in_buffer_count= 0;\n\n    s->resample_in_constraint= 0;\n\n    free_temp(&s->postin);\n\n    free_temp(&s->midbuf);\n\n    free_temp(&s->preout);\n\n    free_temp(&s->in_buffer);\n\n    free_temp(&s->dither);\n\n    swri_audio_convert_free(&s-> in_convert);\n\n    swri_audio_convert_free(&s->out_convert);\n\n    swri_audio_convert_free(&s->full_convert);\n\n    swri_rematrix_free(s);\n\n\n\n    s->flushed = 0;\n\n\n\n    if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested input sample format %d is invalid\\n\", s->in_sample_fmt);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested output sample format %d is invalid\\n\", s->out_sample_fmt);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    //FIXME should we allow/support using FLT on material that doesnt need it ?\n\n    if(av_get_planar_sample_fmt(s->in_sample_fmt) <= AV_SAMPLE_FMT_S16P || s->int_sample_fmt==AV_SAMPLE_FMT_S16P){\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_S16P;\n\n    }else\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_FLTP;\n\n\n\n    if(   s->int_sample_fmt != AV_SAMPLE_FMT_S16P\n\n        &&s->int_sample_fmt != AV_SAMPLE_FMT_S32P\n\n        &&s->int_sample_fmt != AV_SAMPLE_FMT_FLTP){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is not supported internally, S16/S32/FLT is supported\\n\", av_get_sample_fmt_name(s->int_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    set_audiodata_fmt(&s-> in, s-> in_sample_fmt);\n\n    set_audiodata_fmt(&s->out, s->out_sample_fmt);\n\n\n\n    if (s->out_sample_rate!=s->in_sample_rate || (s->flags & SWR_FLAG_RESAMPLE)){\n\n        s->resample = swri_resample_init(s->resample, s->out_sample_rate, s->in_sample_rate, s->filter_size, s->phase_shift, s->linear_interp, s->cutoff, s->int_sample_fmt);\n\n    }else\n\n        swri_resample_free(&s->resample);\n\n    if(    s->int_sample_fmt != AV_SAMPLE_FMT_S16P\n\n        && s->int_sample_fmt != AV_SAMPLE_FMT_S32P\n\n        && s->int_sample_fmt != AV_SAMPLE_FMT_FLTP\n\n        && s->resample){\n\n        av_log(s, AV_LOG_ERROR, \"Resampling only supported with internal s16/s32/flt\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n\n\n    if(s->used_ch_count && s-> in_ch_layout && s->used_ch_count != av_get_channel_layout_nb_channels(s-> in_ch_layout)){\n\n        av_log(s, AV_LOG_WARNING, \"Input channel layout has a different number of channels than the number of used channels, ignoring layout\\n\");\n\n        s-> in_ch_layout= 0;\n\n    }\n\n\n\n    if(!s-> in_ch_layout)\n\n        s-> in_ch_layout= av_get_default_channel_layout(s->used_ch_count);\n\n    if(!s->out_ch_layout)\n\n        s->out_ch_layout= av_get_default_channel_layout(s->out.ch_count);\n\n\n\n    s->rematrix= s->out_ch_layout  !=s->in_ch_layout || s->rematrix_volume!=1.0 ||\n\n                 s->rematrix_custom;\n\n\n\n#define RSC 1 //FIXME finetune\n\n    if(!s-> in.ch_count)\n\n        s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout);\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n    if(!s->out.ch_count)\n\n        s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout);\n\n\n\n    if(!s-> in.ch_count){\n\n        av_assert0(!s->in_ch_layout);\n\n        av_log(s, AV_LOG_ERROR, \"Input channel count and layout are unset\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if ((!s->out_ch_layout || !s->in_ch_layout) && s->used_ch_count != s->out.ch_count && !s->rematrix_custom) {\n\n        av_log(s, AV_LOG_ERROR, \"Rematrix is needed but there is not enough information to do it\\n\");\n\n        return -1;\n\n    }\n\n\n\nav_assert0(s->used_ch_count);\n\nav_assert0(s->out.ch_count);\n\n    s->resample_first= RSC*s->out.ch_count/s->in.ch_count - RSC < s->out_sample_rate/(float)s-> in_sample_rate - 1.0;\n\n\n\n    s->in_buffer= s->in;\n\n\n\n    if(!s->resample && !s->rematrix && !s->channel_map && !s->dither_method){\n\n        s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                                   s-> in_sample_fmt, s-> in.ch_count, NULL, 0);\n\n        return 0;\n\n    }\n\n\n\n    s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt,\n\n                                             s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0);\n\n    s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                             s->int_sample_fmt, s->out.ch_count, NULL, 0);\n\n\n\n\n\n    s->postin= s->in;\n\n    s->preout= s->out;\n\n    s->midbuf= s->in;\n\n\n\n    if(s->channel_map){\n\n        s->postin.ch_count=\n\n        s->midbuf.ch_count= s->used_ch_count;\n\n        if(s->resample)\n\n            s->in_buffer.ch_count= s->used_ch_count;\n\n    }\n\n    if(!s->resample_first){\n\n        s->midbuf.ch_count= s->out.ch_count;\n\n        if(s->resample)\n\n            s->in_buffer.ch_count = s->out.ch_count;\n\n    }\n\n\n\n    set_audiodata_fmt(&s->postin, s->int_sample_fmt);\n\n    set_audiodata_fmt(&s->midbuf, s->int_sample_fmt);\n\n    set_audiodata_fmt(&s->preout, s->int_sample_fmt);\n\n\n\n    if(s->resample){\n\n        set_audiodata_fmt(&s->in_buffer, s->int_sample_fmt);\n\n    }\n\n\n\n    s->dither = s->preout;\n\n\n\n    if(s->rematrix || s->dither_method)\n\n        return swri_rematrix_init(s);\n\n\n\n    return 0;\n\n}\n", "idx": 15252, "substitutes": {"s": ["ses", "gs", "S", "bs", "ports", "ags", "sam", "t", "m", "eds", "qs", "ads", "stats", "vs", "cs", "tests", "ims", "pers", "tes", "its", "us", "terms", "ps", "esm", "des", "sw", "n", "js", "params", "v", "g", "comm", "spec", "wcs", "ds", "ats", "obj", "services", "ies", "self", "ears", "args", "set", "conf", "ows", "parts", "ers", "i", "results", "south", "a", "as", "less", "bits", "eps", "als", "sb", "hs", "sys", "in", "grades", "c", "ops", "es", "changes", "fs", "events", "se", "reads", "sports", "ss", "comments", "aws", "has", "l", "p", "ges", "details", "is", "sv", "ls", "r", "ches", "mods", "gets", "ts", "ins", "ns", "b", "h", "os", "z", "w", "sts", "ms", "y", "rs"]}}
{"project": "qemu", "commit_id": "8de433cb0820dc1f387a2d580d255744aacd60cc", "target": 1, "func": "void pc_hot_add_cpu(const int64_t id, Error **errp)\n{\n    DeviceState *icc_bridge;\n    int64_t apic_id = x86_cpu_apic_id_from_index(id);\n    if (cpu_exists(apic_id)) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", it already exists\", id);\n    if (id >= max_cpus) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", max allowed: %d\", id, max_cpus - 1);\n    icc_bridge = DEVICE(object_resolve_path_type(\"icc-bridge\",\n                                                 TYPE_ICC_BRIDGE, NULL));\n    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);", "idx": 15260, "substitutes": {"id": ["tx", "status", "index", "key", "ide", "error", "f", "and", "ref", "Id", "ids", "p", "kid", "fd", "aid", "created", "x", "md", "t", "hid", "bid", "uid", "mid", "rid", " fid", "end", "vid", "num", "show", "in", "m", " tid", "tag", "hide", "url", "time", "wid", "c", " pid", "count", "one", "db", "code", "no", "ID", "start", "oid", "h", "ad", "pid", "it", "d", "length", "ip", "i", "name", "ick", "ident", "worker"], "errp": ["erm", "errorper", "eorping", "ererpre", "errorphp", "errps", "ererping", "ererps", "arrp", "arrpa", "traceping", "eorpa", "ererp", " errpa", "errorps", " errps", "eorphp", " errm", "errper", "errping", "errm", "errorp", " errpre", "errorpre", " errP", "errr", "errP", "tracepa", "errorpa", "tracep", " errper", "eorp", "errorping", "arrps", "errorm", "errorr", "erP", "errorP", " errr", "errpre", "err", "erp", "tracephp", "errphp", " errping", "errpa", "arrper"], "icc_bridge": ["icc_Bridge", "ic_bridge", "ic_link", "icc_link", "ic_Bridge", "icc_ridge", "ic_interface", "icc_interface", "ic_ridge"]}}
{"project": "qemu", "commit_id": "5b4a047fbe8ceb68ad1a78d51f0fadbe2bb12af7", "target": 1, "func": "static void xlnx_ep108_init(MachineState *machine)\n\n{\n\n    XlnxEP108 *s = g_new0(XlnxEP108, 1);\n\n    Error *err = NULL;\n\n\n\n    object_initialize(&s->soc, sizeof(s->soc), TYPE_XLNX_ZYNQMP);\n\n    object_property_add_child(OBJECT(machine), \"soc\", OBJECT(&s->soc),\n\n                              &error_abort);\n\n\n\n    object_property_set_bool(OBJECT(&s->soc), true, \"realized\", &err);\n\n    if (err) {\n\n        error_report(\"%s\", error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    if (machine->ram_size > EP108_MAX_RAM_SIZE) {\n\n        error_report(\"WARNING: RAM size \" RAM_ADDR_FMT \" above max supported, \"\n\n                     \"reduced to %llx\", machine->ram_size, EP108_MAX_RAM_SIZE);\n\n        machine->ram_size = EP108_MAX_RAM_SIZE;\n\n    }\n\n\n\n    if (machine->ram_size <= 0x08000000) {\n\n        qemu_log(\"WARNING: RAM size \" RAM_ADDR_FMT \" is small for EP108\",\n\n                 machine->ram_size);\n\n    }\n\n\n\n    memory_region_allocate_system_memory(&s->ddr_ram, NULL, \"ddr-ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(get_system_memory(), 0, &s->ddr_ram);\n\n\n\n    xlnx_ep108_binfo.ram_size = machine->ram_size;\n\n    xlnx_ep108_binfo.kernel_filename = machine->kernel_filename;\n\n    xlnx_ep108_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    xlnx_ep108_binfo.initrd_filename = machine->initrd_filename;\n\n    xlnx_ep108_binfo.loader_start = 0;\n\n    arm_load_kernel(s->soc.boot_cpu_ptr, &xlnx_ep108_binfo);\n\n}\n", "idx": 15288, "substitutes": {"machine": ["manager", "display", "hard", "scope", "series", "spin", "engine", "policy", "command", "m", "channel", "console", "serial", "problem", "net", "money", "module", "maker", "cell", "power", "menu", "shell", "memory", "comment", "link", "hello", "division", "mc", "device", "table", "volume", "alias", "achine", "agent", "interface", "mouse", "sample", "computer", "node", "server", "network", "smart", "virtual", "monitor", "sm", "service", "Machine", "zone", "description", "sim", "remote", "unknown", "state", "me", "instance", "session", "mode", "managed", "owner", "dm", "model", "chain", "domain", "kind", "connection", "message", "vm", "magic", "iso", "handler", "event", "keeper", "host", "direction", "component", "controller", "y", "template", "worker"], "s": ["sis", "ses", "gs", "S", "scope", "series", "sq", "sl", "sam", "t", "m", "qs", "stats", "vs", "client", "cs", "my", "sg", "ps", "j", "js", "v", "g", "http", "comm", "spec", "space", "ds", "services", "self", "args", "set", "i", "sample", "a", "less", "store", "source", "sm", "sb", "service", "sys", "hs", "times", "ess", "sim", "es", "changes", "d", "se", "sports", "ss", "aws", "serv", "session", "p", "details", "is", "sv", "ls", "sand", "ts", "sp", "ns", "b", "h", "sd", "os", "w", "sts", "ms", "y", "rs", "su"], "err": ["resp", "errors", "notice", "error", "cr", "conn", "out", "exc", "usr", "attr", "aaa", "mr", "n", "dr", "erd", "or", "riot", "erb", "eor", "cli", "rr", "cer", "er", "msg", "buf", " terr", "cfg", "kr", "r", "Error", "fee", "obj", "norm", "cb", "txt", "gr", "res", "ns", "der", "die", "Er", "fr", "e", "eas", "inner", "elt", "gz", "ev", "esp", "rn", "rs", "arr"]}}
{"project": "FFmpeg", "commit_id": "00b3ca3c7a779e3b062d6ef0c5067c60c8f8a357", "target": 1, "func": "static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,\n\n                        AVFilterInOut **open_outputs, AVClass *log_ctx)\n\n{\n\n    int pad = 0;\n\n\n\n    while (**buf == '[') {\n\n        char *name = parse_link_name(buf, log_ctx);\n\n        AVFilterInOut *match;\n\n\n\n        if (!name)\n\n            return AVERROR(EINVAL);\n\n\n\n        /* First check if the label is not in the open_outputs list */\n\n        match = extract_inout(name, open_outputs);\n\n\n\n        if (match) {\n\n            av_free(name);\n\n        } else {\n\n            /* Not in the list, so add it as an input */\n\n            match = av_mallocz(sizeof(AVFilterInOut));\n\n            match->name    = name;\n\n            match->pad_idx = pad;\n\n        }\n\n\n\n        insert_inout(curr_inputs, match);\n\n\n\n        *buf += strspn(*buf, WHITESPACES);\n\n        pad++;\n\n    }\n\n\n\n    return pad;\n\n}\n", "idx": 15290, "substitutes": {"buf": ["bar", "bytes", "rc", "Buff", "mem", "ptr", "ref", "cur", "aw", "data", "seq", "cmd", "pb", "wb", "ctx", "window", "addr", "raw", "Buffer", "conv", "text", "port", "batch", "read", "msg", "buff", "cap", "now", "rb", "end", "brace", "cat", "xff", "cam", "br", "bag", "doc", "off", "bu", "buffer", "block", "cb", "cv", "caps", "pos", "img", "wd", "b", "bc", "tmp", "iter", "uf", "err", "queue", "bound", "pkg", "w", "nm", "cast", "str", "txt", "pack"], "curr_inputs": ["curr_contextts", "curr_input_", "curr_configts", "curr_contextjs", "curr_tabjs", "curr_contextes", "curr_configes", "curr_contexteds", "curr_contexts", "curr_outputts", "curr_inputes", "curr_tabs", "curr_outputjs", "curr_configs", "curr_outputeds", "curr_outputes", "curr_tabts", "curr_tab_", "curr_inputjs", "curr_inputts", "curr_outputs", "curr_configeds", "curr_inputeds", "curr_output_", "curr_context_"], "open_outputs": ["open2outputjs", "open_inputes", "open_outputts", "open_streames", "open_columnsets", "open_inputs", "open2outputs", "open2inputjs", "open2outputsets", "open_columns", "open2inputs", "open_inputjs", "open2inputsets", "open_inputts", "open_columnts", "open_inputsets", "open2outputts", "open_Outputs", "open_logsets", "open_Outputes", "open_outputjs", "open_columnjs", "open_Outputjs", "open_streamjs", "open_streams", "open_outputsets", "open_Outputts", "open2inputts", "open_outputes", "open_logts", "open_streamts", "open_logjs", "open_logs"], "log_ctx": [" log2pkg", "log_pkg", "logkcontext", " log_pkg", " log_obj", "log_params", "logkctx", "log_obj", "logCcontext", " log_params", "logkpkg", "log2ctx", "log2params", "logkparams", "logCctx", " log2context", "log2pkg", " log_context", " log2params", " log2ctx", "logCpkg", "logCparams", "log_context", "log2context"], "name": ["key", "def", "path", "index", "type", "mem", "version", "local", "ver", "out", "good", "search", "size", "data", "n", "group", "call", "class", "nam", "names", "filename", "source", "len", "common", "msg", "cap", "title", "new", "m", "tag", "part", "none", "word", "full", "comment", "Name", "info", "prefix", "add", "parent", "base", "link", "code", "no", "alias", "start", "id", "label", "var", "length", "me", "ame", "ma", "value", "qual", "nm", "NAME", "str", "ident"], "match": ["mount", "same", "cmp", "check", "field", "result", "select", "send", "m", "parent", "change", "make", "see", "trace", "fire", "filter", "sum", "patch", "apply", "search", "map", "mask", "try", "test", "get", "part", "comment", "link", "look", "comp", "bind", "print", "scale", "pair", "join", "save", "complete", "copy", "key", "record", "move", "call", "reply", "pattern", "material", "mate", "connect", "info", "buffer", "equal", "me", "valid", "allow", "exist", "rule", "atch", "cache", "diff", "tag", "message", "mark", "replace", "find", "parse", "image", "mut", "matched", "Match", "mat", "mp", "watch", "ame", "detail"], "pad": ["index", "quad", "ptr", "paste", "patch", "bug", "size", "ind", "addr", "map", "cmd", "p", "depth", "pat", "cmp", " Pad", "coord", "port", "batch", "len", "padding", "Pad", "added", "np", "delay", "offset", "num", "new", "add", "prefix", "ads", "stroke", "dx", "pend", "pos", "bind", "append", "crop", "alias", "scale", "ack", "start", "dev", "grow", "id", "print", "adder", "ad", "pair", "pre", "mod", "length", "d", "pick", "max", " padd", "prep", "ix", "pod", "pack"]}}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "void vp8_mc_chroma(VP8Context *s, VP8ThreadData *td, uint8_t *dst1, uint8_t *dst2,\n\n                   ThreadFrame *ref, const VP56mv *mv, int x_off, int y_off,\n\n                   int block_w, int block_h, int width, int height, int linesize,\n\n                   vp8_mc_func mc_func[3][3])\n\n{\n\n    uint8_t *src1 = ref->f->data[1], *src2 = ref->f->data[2];\n\n\n\n    if (AV_RN32A(mv)) {\n\n        int mx = mv->x&7, mx_idx = subpel_idx[0][mx];\n\n        int my = mv->y&7, my_idx = subpel_idx[0][my];\n\n\n\n        x_off += mv->x >> 3;\n\n        y_off += mv->y >> 3;\n\n\n\n        // edge emulation\n\n        src1 += y_off * linesize + x_off;\n\n        src2 += y_off * linesize + x_off;\n\n        ff_thread_await_progress(ref, (3 + y_off + block_h + subpel_idx[2][my]) >> 3, 0);\n\n        if (x_off < mx_idx || x_off >= width  - block_w - subpel_idx[2][mx] ||\n\n            y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) {\n\n            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src1 - my_idx * linesize - mx_idx, linesize,\n\n                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n\n                                     x_off - mx_idx, y_off - my_idx, width, height);\n\n            src1 = td->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n            mc_func[my_idx][mx_idx](dst1, linesize, src1, linesize, block_h, mx, my);\n\n\n\n            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src2 - my_idx * linesize - mx_idx, linesize,\n\n                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n\n                                     x_off - mx_idx, y_off - my_idx, width, height);\n\n            src2 = td->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n            mc_func[my_idx][mx_idx](dst2, linesize, src2, linesize, block_h, mx, my);\n\n        } else {\n\n            mc_func[my_idx][mx_idx](dst1, linesize, src1, linesize, block_h, mx, my);\n\n            mc_func[my_idx][mx_idx](dst2, linesize, src2, linesize, block_h, mx, my);\n\n        }\n\n    } else {\n\n        ff_thread_await_progress(ref, (3 + y_off + block_h) >> 3, 0);\n\n        mc_func[0][0](dst1, linesize, src1 + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n        mc_func[0][0](dst2, linesize, src2 + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n    }\n\n}\n", "idx": 15301, "substitutes": {"s": ["ses", "a", "S", "f", "p", "js", "v", "sl", "t", "spec", "sb", "sv", "st", "sys", "ds", "sf", "sa", "ssl", "ts", "sp", "c", "stats", "ns", "cs", "h", "fs", "sd", "sg", "os", "d", "w", "ss", "sts", "sc", "rs", "ps"], "td": ["def", "ctl", "tc", "ptr", "tic", "ind", "pb", "ctx", "fd", "tr", "dl", "cd", "dt", "pd", "pt", "md", "t", "nd", "st", "dc", "tn", "ds", "ct", "nt", "dd", "th", "bd", "ssl", "rt", "ts", "tf", "db", "disc", "std", "ht", "TD", "pc", "tmp", "ad", "sd", "d", "cz", "vt", "SD", "ld", "edd"], "dst1": [" dst_", "dest_", "Dst4", "dest1", "Dst2", " dsrc_", "Dst3", "Dest4", "dost1", "drc2", " dsrc2", " dst3", "dst_", "dst4", "dost4", "drc1", "dist3", "dsrc1", "dost3", "dist2", "dest3", "dest4", "dist1", "Dest3", "dist4", " dsrc3", "dost2", "dsrc_", "drc3", "Dst1", "Dest2", "dsrc2", " dsrc1", "dst3", "dsrc3", "dest2", "drc_", "Dest1"], "dst2": ["dest1", "dsttwo", "Dst2", "Dst3", "desttwo", "Dsttwo", "Desttwo", "dly3", "dsrctwo", "dly1", "dsrc1", "dest3", "Dest3", "dlytwo", "Dst1", "Dest2", "dsrc2", "dly2", "dst3", "dsrc3", "dest2", "Dest1"], "ref": ["resp", "thread", "rc", "def", "index", "error", "mem", "f", "Ref", "ptr", "lf", "inter", "ff", "ind", "pb", "j", "p", "ctx", "tr", "call", "reference", "req", "reset", "v", "val", "g", "t", "close", "frame", "Reference", "diff", "ef", "act", "in", "k", "flow", "r", "th", "obj", "fb", "add", "range", "rt", "self", "tf", "sp", "ro", "null", "db", "bf", "link", "re", "rec", "fr", "fc", "pc", "id", "fs", "conf", "ft", "tip", "fi", "q", "tab", "pointer", "af"], "mv": [" mva", "vv", " mf", "pvp", "tmv", "ph", "mva", "vV", "gmv", "gmvi", "Mh", "mf", "mvt", " mvc", "matvi", "gmV", "pvc", "MV", "gmvm", "matV", "matvt", "pv", "mvm", "tmvm", "mV", "tmV", "Mvm", "pV", "matva", "tmvc", "tmvp", "dV", "Mv", " mvp", "Mf", "vvt", "tmva", "Mvi", "df", "Mvp", "mvi", "Mvt", "mh", " mh", "pvm", "matvm", "dv", " mvm", "matv", "dvp", " mV", "vvm", "matvp", "mvc", "mvp"], "x_off": ["xipoff", "ox_off", "rx_OFF", "m_left", "xipon", "item67off", "x_exp", "item67after", "xPleft", "x_over", "x2OFF", "x67off", "xipOFF", "ox_OFF", " x_Off", "xipOff", "path67off", "path67exp", "ex_OFF", "path67opp", "ox_on", "ex_Off", "rx_off", "x67exp", "ox_Off", "xPoff", "path_opp", "x__OFF", "path_exp", "x2off", "xzoff", "x_att", "x_offs", "rx_offs", "x67opp", "x_on", "ex_off", "xxoff", "xPover", "x2on", "x__Off", "x_opp", "x2Off", "x_left", "x_OFF", "m_over", "item_after", "xzoffs", "m_off", "x_after", "item_off", "xxOFF", "xzoffer", "xxOff", "x__off", " x_OFF", "xzOFF", "x_Off", "x_offer", "item_att", "rx_offer", "path_off", "x67after", "item67att", "x67att"], "y_off": ["yy_off", "y_of", "y_old", "z_down", "Y_offs", "y_opp", " y_opp", "y2off", "Y_Off", "Y_off", " y_Off", "yJdown", " y_open", "yJopp", "y2offs", "y2OFF", " y_old", " y_OFF", "y_offset", "y_OFF", "Y_offset", "ymoffset", "y2Off", "ymoff", "yJoff", "y2new", "z_off", "yJOff", "z_opp", "y_Off", " y_offs", " y_offset", " y_of", "yy_Off", "y_new", " y_new", "y_open", "ymOFF", "ymnew", "y_offs", "y_offer", "yy_offer", "y2offset", "y_down", "z_Off"], "block_w": ["block__w", "lock_h", "lock_w", "block__wr", " block_wr", "block__h", "block00w", "lock_W", "block00wr", "block_wr", "block__W", "block_W", "block00h", " block_W", "block00W"], "block_h": [" block_oh", "block_hi", "block_height", "block67hi", "block67w", "block5h", "blocklingw", "block2h", " block_height", "block_H", "block2H", " block_v", "Block_h", "Block_hi", "block_width", "block_v", "block2w", "block67h", " block_H", "block_oh", "Block_w", " block_width", "block5height", "blocklingoh", "block5w", "blocklingh"], "height": ["hang", "amount", "ty", "wh", "density", " Height", "size", "build", "depth", "window", "radius", "rows", "padding", "rank", "bottom", "power", "flow", "Height", "th", "html", "resolution", "count", "capacity", "acity", "volume", "h", "grow", "ows", "hash", "length", "gravity", "shape", "style", "gy", "w", "y", "angle", "history", "ch"], "linesize": ["codesization", "setsize", "levelsIZE", "facesize", "pointsization", " linesization", " linesze", "levelsizer", "codesIZE", "linesze", "valsizer", "linsize", "linesization", "valsization", "cyclesIZE", "timesize", "timesization", "inesize", "linesIZE", "headsization", "inesization", "timesIZE", "worksize", "inesized", " linessize", "inesze", "headsize", "namesize", "setsization", "setsized", "linssize", "cyclesize", "levelsized", "facessize", "linessize", " linesIZE", " linesized", "setsIZE", "codesze", "linsizer", "cyclesizer", "pointsizer", "namesIZE", "linesizer", "headsIZE", "linesized", "inesizer", "valsize", "facesized", "valsIZE", "levelsize", "linsized", "inesIZE", "facesIZE", "worksization", "worksizer", "timesizer", "pointsize", "linsization", "headsizer", "namesization", "namesizer", "pointsIZE", "codesize", "setsizer", "cyclesization", "worksIZE", "linsIZE"], "mc_func": ["mc_function", "mc2kw", " mc_function", "mc__unc", "mc__fun", "mc_unc", "mc_fun", " mc2fun", " mc2kw", "mc__func", " mc2func", "mc2fun", " mc_fun", "mc_kw", "mc2function", "mc2func", "mc__function", " mc2function", "mc__kw", " mc_unc", " mc_kw"], "src1": [" src4", " src10", "rc1", "dest1", "source4", "src4", "srcOne", "rc10", "source2", "dest10", "srOne", " src01", "rc3", "source3", " src3", " srcOne", "rc2", "src10", "usr0", "sr3", "source0", "src3", "usr1", "usr2", "usr01", " src0", "dest0", "rc01", "src01", "sr1", "source1", "rc4", "src0", "source01", "rc0", "rcOne", "dest2", "sr2"], "src2": [" src4", "rc1", "srctwo", "dest1", "src4", "addrtwo", " srctwo", "rc2", "addr4", "rctwo", " src0", "dest4", "dest0", "addr1", "addr2", "rc4", "src0", "rc0", "dest2"]}}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,\n\n                             int width, int height)\n\n{\n\n    int src_wrap, x, y;\n\n    int r, g, b;\n\n    uint8_t *lum, *cb, *cr;\n\n    const uint8_t *p;\n\n\n\n    lum = dst->data[0];\n\n    cb = dst->data[1];\n\n    cr = dst->data[2];\n\n\n\n    src_wrap = src->linesize[0] - width * BPP;\n\n    p = src->data[0];\n\n    for(y=0;y<height;y++) {\n\n        for(x=0;x<width;x++) {\n\n            RGB_IN(r, g, b, p);\n\n            lum[0] = RGB_TO_Y_CCIR(r, g, b);\n\n            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);\n\n            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);\n\n            cb++;\n\n            cr++;\n\n            lum++;\n\n        }\n\n        p += src_wrap;\n\n        lum += dst->linesize[0] - width;\n\n        cb += dst->linesize[1] - width;\n\n        cr += dst->linesize[2] - width;\n\n    }\n\n}\n", "idx": 15321, "substitutes": {"dst": ["dictionary", "Dst", "sddest", "dtst", "lination", "loe", "dtination", "deldest", "rv", "edictionary", "theest", "sdoe", "Dv", "lictionary", " doe", "dtdest", "daest", "rst", " dmit", "delest", "ddest", "thest", "dination", "rdest", "rmit", " dination", "lst", "Ddest", "eddest", "daination", "thect", "dact", " dv", "delmit", "edination", " ddest", "doe", "ldest", "Dest", "edst", "dest", " dest", " dct", "dast", "lv", "sdst", "sdest", "dmit", "dv", "theination", "lmit", "dtictionary", "lest", "dct", "delst"], "src": ["rc", "sort", "rl", "sur", "mph", "sq", "sl", "syn", "source", "sb", "sv", "st", "via", "sys", "sec", "now", "rb", "scan", "s", "rt", "sp", "sr", "img", "sh", "ins", "sync", "start", "ser", "SOURCE", "input", "tmp", "Source", "inner", "nil", "sup", "bg", "sn", "supp", "init", "inst", "sc", "iv", "rs"], "height": ["hang", "tight", "wh", "ty", "kh", "density", "size", "high", "row", "depth", "radius", "window", "inches", "ih", "padding", "bottom", "Height", "he", "th", "through", "hei", "html", "resolution", "stroke", "count", "ht", "volume", "ight", "h", "ish", "H", "gravity", "length", "total", "style", "visible", "above", " Height", "history", "ch"], "src_wrap": ["rc_wra", "src_box", "rc_wrap", "src2wrap", "rc_wrapper", "rc_box", "src_wrapper", "src2rap", "src2wrapper", " src_rap", "src2wra", "rc_rap", " src_wrapper", "src_rap", "src2box", "src_wra", " src_box"], "x": ["tx", "mx", "key", "inx", "at", "f", "o", "wx", "ax", "l", "yx", "n", "ex", "X", "xs", "v", "check", "xy", "el", "t", "ox", "xp", "act", "fx", "m", "php", "ux", "time", "through", "xi", "dx", "xc", "lat", "ry", "on", "xx", "any", "e", "inner", "ace", "xf", "z", "q", "rx", "i", "w", "xt", "ix", "ch"], "y": ["yy", "uy", "ty", "by", "yt", "oy", "at", "asy", "py", "o", "dy", "ny", "ys", "j", "sy", "axy", "Y", "yet", "v", "xy", "ya", "yr", "ay", "t", "ym", "sys", "cy", "vy", "iy", "ies", "html", "ady", "very", "ry", "h", "any", "year", "my", "ot", "it", "sky", "wy", "z", "gy", "ey", "i", "ch"], "r": ["rc", "a", " c", "f", "o", "rad", "ra", "l", "pr", "n", "mr", "dr", "vr", "ir", "or", "v", "ar", "rr", "rate", "er", "rb", "ur", "k", "m", "br", "rt", "c", "ro", "rh", "sr", "gr", "rg", "h", "rin", "re", "fr", "rec", "e", "ri", "u", "rd", "var", "d", "err", "q", "rx", "i", "R", "usr", "rs"], "g": ["gs", "G", "tg", "go", "gg", "gin", "l", "j", "ag", "n", "group", "v", "gu", "ig", "reg", "ge", "ger", "vg", "msg", "gb", "k", "m", "cfg", "og", "gt", "gd", "fg", "org", "c", "ang", "erg", "gr", "gc", "rg", "gm", "h", "pg", "mg", "yg", "e", "greg", "u", "sg", "app", "gi", "d", "arg", "eg", "z", "gy", "bg", "i", "gh"], "b": ["be", "ba", "by", "ib", "f", "bs", "l", "j", "pb", "wb", "n", "eb", "v", "bi", "t", "sb", "ab", "rb", "br", "m", "fb", "bu", "c", "db", "base", "bas", "bc", "h", "B", "u", "app", "it", "bis", "emb", "bb", "nb", "mb", "z", "bg", "i", "ob"], "lum": ["lim", "llumi", " lamd", "lau", " lau", "luma", "ilur", "llum", " luma", "Luma", " lm", "tlm", "lm", "lur", " luminum", "lumi", "tlumb", "lamd", "iolumb", "tlum", "llumb", " lom", "iolamd", " lumb", "Lm", "llamd", "ilums", " lim", "liums", "lumb", "klur", "Lum", " lumi", "ulom", "klum", "klums", "lnum", "ulumi", "ilum", " lums", "tluma", "lumm", " lumm", "luminum", "lium", "liau", "lnau", "lnuminum", "ulum", "iolim", "ulumb", "lums", "ilumm", " lur", "iolum", "liuminum", "lnums", "lom", "klumm", "llim", "Lumb", "llom"], "cb": ["rc", "cu", "cf", "ib", "obs", "cur", "cn", "cmd", "callback", "wb", "obb", "pb", "eb", "cc", "cd", "erb", "conv", "ctr", "zb", "sb", "buf", "dc", "lb", "cks", "rb", "abb", "np", "ub", "fb", "ck", "c", "cv", "db", "nc", "bf", "ci", "ctrl", "cp", "gc", "bc", "CU", "rob", "conf", "nb", "bb", "CB", "ob", "ch"], "cr": ["vol", "rc", "CR", "cm", "ca", "hr", "cur", "pr", "cmd", "core", "mr", "tr", "ocr", "dr", "crit", "cc", "cd", "try", "ar", "adr", "ctr", "rm", "dc", "rb", "br", "kr", "cy", "c", "cv", "rh", "ro", "sr", "car", "wp", "cp", "ctrl", "gc", "Cr", "bc", "cs", "gr", "pc", "rob", "fr", "mc", "cycle", "rx", "arc", "sc", "ch", "arr"], "p": ["jp", "a", "f", "o", "pi", "pr", "pb", "l", "n", "j", "v", "dp", "pt", "t", "pp", "P", "m", "rep", "c", "sp", "lp", "pos", "wp", "ap", "cp", "h", "pc", "e", "u", "d", "tp", "z", "q", "pkg", "i", "w", "pa", "ps"]}}
{"project": "qemu", "commit_id": "a5cf8262e4eb9c4646434e2c6211ef8608db3233", "target": 0, "func": "static char *pcibus_get_fw_dev_path(DeviceState *dev)\n\n{\n\n    PCIDevice *d = (PCIDevice *)dev;\n\n    char path[50], name[33];\n\n    int off;\n\n\n\n    off = snprintf(path, sizeof(path), \"%s@%x\",\n\n                   pci_dev_fw_name(dev, name, sizeof name),\n\n                   PCI_SLOT(d->devfn));\n\n    if (PCI_FUNC(d->devfn))\n\n        snprintf(path + off, sizeof(path) + off, \",%x\", PCI_FUNC(d->devfn));\n\n    return strdup(path);\n\n}\n", "idx": 15341, "substitutes": {"dev": ["pro", "def", "des", "mem", "DEV", "conn", "serv", "ver", "det", "data", "cmd", "hw", "p", "n", "raw", "Dev", "dis", "val", "v", "dm", "test", "md", "priv", "di", "buf", "sys", "ds", "nt", "cam", "dd", "att", "obj", "ie", "dem", "debug", "wd", "device", "ad", "de", "sd", "ve", "ev", "w", "cast", "av", "home"], "d": ["def", "td", "f", "o", "det", "dn", "ind", "l", "n", "p", "fd", "dr", "D", "ord", "dis", "dm", "v", "pd", "done", "t", "md", "du", "nd", "di", "dc", "ds", "da", "dd", "dom", "gd", "dim", "info", "hd", "dx", "c", "dj", "db", "od", "debug", "ad", "sd", "mod", "dh", "z", "dat", "w", "did", "ld"], "path": ["key", "index", "walk", "route", "mount", "patch", "out", "ref", "output", "data", "l", "PATH", "cmd", "n", "p", "x", "this", "str", "ex", "window", "ath", "temp", "dir", "text", "chain", "test", "pt", "binding", "loc", "kind", "read", "spec", "tree", "desc", "template", "th", "context", "ATH", "time", "url", "rect", " PATH", "parent", "prefix", "html", "self", "c", "file", "dest", "Path", " Path", "wd", "root", "id", "transform", "inner", "trace", "list", "length", "zip", "value", "pkg", "full", "history", "pointer"], "name": ["key", "error", "type", "version", "f", "mem", "a", "out", "size", "data", "l", "n", "nam", "names", "filename", "user", "len", "title", "new", "item", "part", "r", "description", "word", "parent", "Name", "prefix", "info", "comment", "base", "all", "no", "on", "alias", "id", "named", "label", " Name", "length", "ame", "w", "nm", "NAME", "str", "normal"], "off": ["hand", "def", "shift", "o", "out", "ref", " OFF", "offs", "det", "ff", "j", "n", "down", "window", "ex", "raw", "miss", "ord", "along", " on", "after", "Off", "opt", "low", "t", "before", "end", "now", "offset", "new", "OFF", "nt", "m", "op", "open", "one", "pos", "no", "on", "hot", "start", "of", "set", "then", "over", "ot", "from", "pad", "length", " offset", "offer", "zero", " Off", " af"]}}
{"project": "qemu", "commit_id": "f69a8bde29354493ff8aea64cc9cb3b531d16337", "target": 1, "func": "static int qio_channel_websock_handshake_send_response(QIOChannelWebsock *ioc,\n\n                                                       const char *key,\n\n                                                       Error **errp)\n\n{\n\n    char combined_key[QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n                      QIO_CHANNEL_WEBSOCK_GUID_LEN + 1];\n\n    char *accept = NULL, *response = NULL;\n\n    size_t responselen;\n\n\n\n    g_strlcpy(combined_key, key, QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + 1);\n\n    g_strlcat(combined_key, QIO_CHANNEL_WEBSOCK_GUID,\n\n              QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n              QIO_CHANNEL_WEBSOCK_GUID_LEN + 1);\n\n\n\n    /* hash and encode it */\n\n    if (qcrypto_hash_base64(QCRYPTO_HASH_ALG_SHA1,\n\n                            combined_key,\n\n                            QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n                            QIO_CHANNEL_WEBSOCK_GUID_LEN,\n\n                            &accept,\n\n                            errp) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    response = g_strdup_printf(QIO_CHANNEL_WEBSOCK_HANDSHAKE_RESPONSE, accept);\n\n    responselen = strlen(response);\n\n    buffer_reserve(&ioc->encoutput, responselen);\n\n    buffer_append(&ioc->encoutput, response, responselen);\n\n\n\n    g_free(accept);\n\n    g_free(response);\n\n\n\n    return 0;\n\n}\n", "idx": 15368, "substitutes": {"ioc": ["iiroc", "pioci", "iooc", "ioocon", " iroc", "diocon", " ioco", "dioh", "pioc", "dioc", "ioh", " iocy", "ioci", "ioOC", "iiocon", "iocy", "IOC", "ioco", " ioci", "Ioc", " iOC", "iooco", "iroc", "Iocy", "ioocy", " ioh", "iOC", "piocon", " iocon", "iioc", "pioh", "iioco", "iocon", "dioci", "Ioco", "ioroc"], "key": ["server", "KEY", "type", "conn", "query", "data", "Key", "keys", "ay", "mac", "k", "lock", "ek", "context", "json", " KEY", "prefix", "base", "password", "link", "code", "pri", "ssh", "ice", "client", "id", "pair", "host", "hash", "sky", "token", "q", "value", "ey", "name", "y", "ip"], "errp": [" errbp", "errps", "aerpa", "derpa", "derbp", "derr", "derps", " errpa", " errps", "errpe", " errpe", "aerp", "errr", "aerpe", "erps", "derp", "aerr", "derpe", " errr", "err", "erp", "erbp", "errbp", "errpa"], "combined_key": ["combpleted_keys", "combpletedlykey", "combined_keys", "combed_link", "combinedlymessage", "combed_name", "combinedoplink", "combinedopkey", "combine_KEY", "combpletedlyKEY", "combinedopname", "combpleted_key", "combined_query", "combine_Key", "combined_KEY", "combinedopKey", "combinedlykeys", "combined_link", "combinated_key", "combinated_query", "combinedPkeys", "combinedPkey", "combinedptlink", "combinated_link", "combinedPmessage", "combine_key", "combined_Key", "combpletedlymessage", "combinedlykey", "combinedPKEY", "combinedptkey", "combpletedlykeys", "combpleted_KEY", "combpleted_message", "combed_key", "combined_name", "combinedlyKEY", "combed_Key", "combined_message", "combinedptquery"], "accept": ["resp", "wait", "view", "allow", "request", "serv", "success", "apply", "ax", "aw", "seq", "ok", "Accept", "crit", "pack", "claim", "req", "opt", "acceptable", "except", "access", "process", "el", "acc", "buf", "result", "pass", "escape", "connect", "select", "send", "update", "release", "json", "control", " Accept", "off", "match", "ac", "open", "adapt", "event", "alert", "account", "answer", "hello", "upload", "content", "ack", "own", "input", "feed", "rec", "iter", "agree", "offer", "valid", "cont", "ait"], "response": ["resp", "bytes", "server", "def", "error", "type", "application", "version", "request", "route", "output", "success", "query", "out", "data", "body", "sequence", "relation", "timeout", "reply", "next", "frame", "service", "result", "command", "tree", "connection", "message", "description", "json", "buffer", "block", "Response", "remote", "image", "answer", "respons", "res", "hello", "vector", "complete", "example", "secret", "entry", "hash", "ve", "value", "offer", "verse", "xml", "bye", "onse"], "responselen": ["responcilize", "responselun", "responcentength", "responsellen", "responcilen", "responscelern", "responsselength", "responselens", "responserength", "responscellen", "responslon", "responsoleen", "responselsun", "responsselens", "responcelen", "responscelen", "responcelern", "responcelens", "responsselern", "responseren", "responcelun", "responcelize", "responselsength", "responserun", "responselsens", "responseler", "responslun", "responselser", "responceler", "responcelength", "responslens", "responselslen", "responscelength", "responselsen", "responcelon", "responsseler", "responscelens", "responselon", "responsselize", "responscelun", "responsoleer", "responslen", "responcellen", "responssellen", "responselern", "responcenten", "responcilength", "responcentun", "responsselon", "responcilon", "responselize", "responsoleength", "responscelon", "responscelize", "responsolelen", "responsceler", "responserern", "responselength", "responcentern", "responsselen", "responsselun", "responslize", "responslength"]}}
{"project": "qemu", "commit_id": "50628d3479e4f9aa97e323506856e394fe7ad7a6", "target": 1, "func": "void dpy_gfx_copy(QemuConsole *con, int src_x, int src_y,\n\n                  int dst_x, int dst_y, int w, int h)\n\n{\n\n    DisplayState *s = con->ds;\n\n    DisplayChangeListener *dcl;\n\n\n\n    if (!qemu_console_is_visible(con)) {\n\n        return;\n\n    }\n\n    QLIST_FOREACH(dcl, &s->listeners, next) {\n\n        if (con != (dcl->con ? dcl->con : active_console)) {\n\n            continue;\n\n        }\n\n        if (dcl->ops->dpy_gfx_copy) {\n\n            dcl->ops->dpy_gfx_copy(dcl, src_x, src_y, dst_x, dst_y, w, h);\n\n        } else { /* TODO */\n\n            dcl->ops->dpy_gfx_update(dcl, dst_x, dst_y, w, h);\n\n        }\n\n    }\n\n}\n", "idx": 15373, "substitutes": {"con": ["screen", "on", "acon", "co", "conn", "ver", "pen", "icon", "cur", "cn", "ca", "ain", "CON", "ctx", "ln", "master", "cc", "conv", "cs", "ran", "gen", "comm", "Con", "com", "cache", "connect", "func", "act", "connection", "num", "obj", "current", "open", "c", "console", "cal", "xc", "cv", "en", "fn", "nc", "txt", "anon", "db", "ins", "ctrl", "un", "ocon", "cons", "cp", "an", "soc", "pc", "fc", "bc", "client", "conf", "enc", "fac", "col", "win", "pl", "x", "sc", "cont", "anc", "can"], "src_x": ["rc_rx", "src__xp", "rc_ix", " src_ex", "src_rx", "rc_xp", "src__x", "src_ix", "src_xp", "src__ex", "rc_x", " src_xp", "src_ex"], "src_y": ["src_yy", "rc_yy", "src__y", "rc_y", "src__yy", "pkg_y", "rc_xy", "src__ny", "src_ch", "pkg_ch", "src__ch", "pkg_yy", "pkg_ny", "src__x", "src_xy", "src__xy", "rc_x", "src_ny"], "dst_x": ["ddest_ex", "ddest_rx", "ddest_y", "ddest_mm", "dst__rx", "dst__y", "dst__x", "dst__ex", "dst_mm", "dst_ex", "ddest_x", "dst_rx"], "dst_y": ["dst_ty", "dst___ty", "dst__i", "dtmp_ies", "ddest_y", "dsrc_ry", "dst_Y", "dtmp_ty", "dst__y", "dst__x", "dst___ies", "dtmp___ty", "dsrc_y", "dst_ry", "ddest_i", "dst___ry", "dst_ya", "dtmp_ry", "dtmp_y", "dtmp___ry", "dtmp___y", "dtmp___ies", "ddest_yy", "dst__yy", "dst_i", "dsrc_ya", "dsrc_Y", "dst___y", "ddest_x", "dst_ies", "dst_yy"], "w": ["kw", "wh", "fw", "nw", "sw", "rw", "wx", "aw", "wb", "hw", "window", "wl", "wal", "widget", "wcs", "wa", "wt", "ow", "m", "wn", "ew", "iw", "work", "wid", "we", " dw", "wp", "wd", "W", "wi", "wr", "d", "win", "whe", "x"], "h": ["wh", "uh", "ph", "kh", "o", "hr", "l", "hz", "high", "bh", "hold", "v", "ha", "height", "ih", "help", "m", "ah", "th", "hi", "he", "hei", "html", "hd", "c", "rh", "oh", "sh", "ht", "b", "ho", "H", "ish", "hl", "hash", "length", "it", "dh", " H", "q", "hh", "ch"], "s": ["sis", "ses", "gs", "S", "serv", "bs", "n", "p", "js", "sq", "sl", "ar", "t", "sol", "sb", "sv", "st", "sys", "ds", "ls", "ats", "iss", "ssl", "so", "ts", "c", "ns", "b", "cs", "set", "spe", "fs", "os", "ss", "sts", "sc", "scl", "rs"], "dcl": [" dbl", "adCL", " dacl", "sdfl", "sdcl", "Dlf", "dwl", "pdpl", "deCL", "pdwl", "dlc", "docl", "dlf", " dca", "pdnl", "sdbl", "ddpl", "ddCL", "dCl", "doCl", "delr", "doblock", "dnl", " dwl", "madlf", "Dctr", "debugbl", " dCL", "daacl", "Dbl", " dlr", "dobl", "ddlc", "madpl", " dCl", "DCL", "dpl", "dofl", "sdCL", " dctr", "doca", "dlr", "dacl", "madcl", "madbl", "dcom", "dctr", "debugwl", "debugcl", "adfl", " dpl", " dblock", "pdcom", "dCL", "pdbl", "ddfl", "dfl", "calcl", " dfl", "dca", "dbl", "Dpl", "danl", "debugcom", "calCl", "pdacl", "Dcl", " dnl", "adbl", "pdcl", "ddca", "ddcl", " dcom", " dlc", "ddlr", "adcl", "calbl", "dblock", "decl", "madctr", "calblock", "dolc", "depl", " dlf", "dapl", "Dfl"]}}
{"project": "qemu", "commit_id": "3c94193e0bbdd855bcbedabd27e3cbe1e6bc6242", "target": 1, "func": "static TCGArg *tcg_constant_folding(TCGContext *s, uint16_t *tcg_opc_ptr,\n                                    TCGArg *args, TCGOpDef *tcg_op_defs)\n{\n    int i, nb_ops, op_index, nb_temps, nb_globals, nb_call_args;\n    TCGOpcode op;\n    const TCGOpDef *def;\n    TCGArg *gen_args;\n    TCGArg tmp;\n    TCGCond cond;\n    /* Array VALS has an element for each temp.\n       If this temp holds a constant then its value is kept in VALS' element.\n       If this temp is a copy of other ones then the other copies are\n       available through the doubly linked circular list. */\n    nb_temps = s->nb_temps;\n    nb_globals = s->nb_globals;\n    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n    nb_ops = tcg_opc_ptr - gen_opc_buf;\n    gen_args = args;\n    for (op_index = 0; op_index < nb_ops; op_index++) {\n        op = gen_opc_buf[op_index];\n        def = &tcg_op_defs[op];\n        /* Do copy propagation */\n        if (op == INDEX_op_call) {\n            int nb_oargs = args[0] >> 16;\n            int nb_iargs = args[0] & 0xffff;\n            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {\n                if (temps[args[i]].state == TCG_TEMP_COPY) {\n                    args[i] = find_better_copy(s, args[i]);\n        } else {\n            for (i = def->nb_oargs; i < def->nb_oargs + def->nb_iargs; i++) {\n                if (temps[args[i]].state == TCG_TEMP_COPY) {\n                    args[i] = find_better_copy(s, args[i]);\n        /* For commutative operations make constant second argument */\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(mul):\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(eqv):\n        CASE_OP_32_64(nand):\n        CASE_OP_32_64(nor):\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n        CASE_OP_32_64(brcond):\n            if (temps[args[0]].state == TCG_TEMP_CONST\n                && temps[args[1]].state != TCG_TEMP_CONST) {\n                tmp = args[0];\n                args[0] = args[1];\n                args[1] = tmp;\n                args[2] = tcg_swap_cond(args[2]);\n        CASE_OP_32_64(setcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state != TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n                args[3] = tcg_swap_cond(args[3]);\n        CASE_OP_32_64(movcond):\n            cond = args[5];\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state != TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n                cond = tcg_swap_cond(cond);\n            /* For movcond, we canonicalize the \"false\" input reg to match\n               the destination reg so that the tcg backend can implement\n               a \"move if true\" operation.  */\n            if (args[0] == args[3]) {\n                tmp = args[3];\n                args[3] = args[4];\n                args[4] = tmp;\n                cond = tcg_invert_cond(cond);\n            args[5] = cond;\n        /* Simplify expressions for \"shift/rot r, 0, a => movi r, 0\" */\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[1]].val == 0) {\n        /* Simplify expression for \"op r, a, 0 => mov r, a\" cases */\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n        CASE_OP_32_64(or):\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                /* Proceed with possible constant folding. */\n            if (temps[args[2]].state == TCG_TEMP_CONST\n                && temps[args[2]].val == 0) {\n                if (temps_are_copies(args[0], args[1])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n        /* Simplify expression for \"op r, a, 0 => movi r, 0\" cases */\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(mul):\n            if ((temps[args[2]].state == TCG_TEMP_CONST\n                && temps[args[2]].val == 0)) {\n        /* Simplify expression for \"op r, a, a => mov r, a\" cases */\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(and):\n                if (temps_are_copies(args[0], args[1])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n        /* Propagate constants through copy operations and do constant\n           folding.  Constants will be substituted to arguments by register\n           allocator where needed and possible.  Also detect copies. */\n        CASE_OP_32_64(mov):\n            if (temps_are_copies(args[0], args[1])) {\n                args += 2;\n                gen_opc_buf[op_index] = INDEX_op_nop;\n            if (temps[args[1]].state != TCG_TEMP_CONST) {\n                tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n                args += 2;\n            /* Source argument is constant.  Rewrite the operation and\n               let movi case handle it. */\n            op = op_to_movi(op);\n            gen_opc_buf[op_index] = op;\n            args[1] = temps[args[1]].val;\n            /* fallthrough */\n        CASE_OP_32_64(movi):\n            tcg_opt_gen_movi(gen_args, args[0], args[1]);\n            args += 2;\n        CASE_OP_32_64(not):\n        CASE_OP_32_64(neg):\n        CASE_OP_32_64(ext8s):\n        CASE_OP_32_64(ext8u):\n        CASE_OP_32_64(ext16s):\n        CASE_OP_32_64(ext16u):\n        case INDEX_op_ext32s_i64:\n        case INDEX_op_ext32u_i64:\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding(op, temps[args[1]].val, 0);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n            args += 2;\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(mul):\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n        CASE_OP_32_64(andc):\n        CASE_OP_32_64(orc):\n        CASE_OP_32_64(eqv):\n        CASE_OP_32_64(nand):\n        CASE_OP_32_64(nor):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding(op, temps[args[1]].val,\n                                          temps[args[2]].val);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args += 3;\n        CASE_OP_32_64(setcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding_cond(op, temps[args[1]].val,\n                                               temps[args[2]].val, args[3]);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args += 4;\n            args += 4;\n        CASE_OP_32_64(brcond):\n            if (temps[args[0]].state == TCG_TEMP_CONST\n                && temps[args[1]].state == TCG_TEMP_CONST) {\n                if (do_constant_folding_cond(op, temps[args[0]].val,\n                                             temps[args[1]].val, args[2])) {\n                    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n                    gen_opc_buf[op_index] = INDEX_op_br;\n                    gen_args[0] = args[3];\n                    gen_args += 1;\n                } else {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n            } else {\n                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args += 4;\n            args += 4;\n        CASE_OP_32_64(movcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding_cond(op, temps[args[1]].val,\n                                               temps[args[2]].val, args[5]);\n                if (temps_are_copies(args[0], args[4-tmp])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else if (temps[args[4-tmp]].state == TCG_TEMP_CONST) {\n                    tcg_opt_gen_movi(gen_args, args[0], temps[args[4-tmp]].val);\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[4-tmp]);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args[4] = args[4];\n                gen_args[5] = args[5];\n                gen_args += 6;\n            args += 6;\n        case INDEX_op_call:\n            nb_call_args = (args[0] >> 16) + (args[0] & 0xffff);\n            if (!(args[nb_call_args + 1] & (TCG_CALL_CONST | TCG_CALL_PURE))) {\n                for (i = 0; i < nb_globals; i++) {\n                    reset_temp(i);\n            for (i = 0; i < (args[0] >> 16); i++) {\n                reset_temp(args[i + 1]);\n            i = nb_call_args + 3;\n            while (i) {\n                *gen_args = *args;\n                args++;\n                gen_args++;\n                i--;\n            /* Default case: we do know nothing about operation so no\n               propagation is done.  We trash everything if the operation\n               is the end of a basic block, otherwise we only trash the\n               output args.  */\n            if (def->flags & TCG_OPF_BB_END) {\n                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n            } else {\n                for (i = 0; i < def->nb_oargs; i++) {\n                    reset_temp(args[i]);\n            for (i = 0; i < def->nb_args; i++) {\n                gen_args[i] = args[i];\n            args += def->nb_args;\n            gen_args += def->nb_args;\n    return gen_args;", "idx": 15388, "substitutes": {"tcg_constant_folding": ["tcg_constant_constructending", "tcg_constant_creating", "tcg_constant_creatding", "tcg_constant_foldding", "tcg_constant_drawling", "tcg_constant_foldending", "tcg_constant_foldling", "tcg_constant_drawending", "tcg_constant_drawing", "tcg_constant_creatending", "tcg_constant_creatling", "tcg_constant_constructing", "tcg_constant_constructling", "tcg_constant_constructding", "tcg_constant_drawding"], "TCGContext": ["tcGCHandle", "TCGCcontext", "TCCcontext", "TCCObject", "TCGUcontext", "tcGObject", "tcGcontext", "TCGObject", "TCGCObject", "TCCContext", "TCGCContext", "tcGContext", "TCGcontext", "TCGUObject", "TCGUHandle", "tcGHandle", "TCGCHandle", "tcGCContext", "TCCHandle", "tcGCObject", "TCGUContext", "tcGCcontext", "TCGHandle"], "s": ["ses", "gs", "a", "S", "ctx", "n", "p", "js", "ex", "sq", "v", "xs", "g", "t", "source", "comm", "is", "sb", "sv", "space", "hs", "sys", "ds", "ats", "times", "m", "in", "r", "ts", "self", "c", "stats", "ins", "ns", "b", "cs", "h", "ims", "es", "e", "fs", "sg", "os", "app", "d", "its", "z", "ss", "sts", "w", "y", "scl", "rs", "ps"], "uint16_t": ["uint16_2", "uint32_p", "uint16_T", "uint16__t", "uint32_t", "uint16__2", "uint32_T", "uint16__T", "uint16_p", "uint16__p", "uint32_2"], "tcg_opc_ptr": ["tcg_opc_buf", "tcg_opf_pointer", "tcg_opf_ptr", "tcg_opC_pointer", "tcg_opc_ctx", "tcg_opf_buf", "tcg_opC_ptr", "tcg_opc_pointer", "tcg_opc2ctx", "tcg_opc_addr", "tcg_opC_addr", "tcg_opc2buf", "tcg_opc2ptr", "tcg_opc2pointer", "tcg_opC_pointers", "tcg_opc_pointers", "tcg_opf_ctx"], "TCGArg": ["TCGIArgs", "TCCArgs", "TCGCArg", "TFCGArg", "TCGarg", "TCPGDef", "TCPGArgs", "TCGDef", "TFCGDef", "TCCGContext", "TCCGVar", "TCgArgs", "TFGArg", "TFGarg", "TCgArg", "LCGarg", "TCGArgs", "TCGIarg", "TFCGarg", "TFCGContext", "TCGIArg", "TCCParam", "TCGPParam", "LCGArgs", "TFCGParam", "TCGPArg", "TFGDef", "TCCarg", "TCGUArg", "TCGUVar", "LCGCarg", "TCgContext", "TFGVar", "TCCGParam", "TCgarg", "TCGCTag", "TCGParam", "TCGITag", "TCCGArgs", "LCGArg", "TCgDef", "TCGPArgs", "TCCGarg", "TCGUarg", "TCCGArg", "TFGContext", "TCCGTag", "TCGVar", "TFGParam", "TCCArg", "TCPGArg", "TFCGArgs", "TCGParg", "TCGTag", "LCGCArg", "TCGUContext", "TCPGarg", "LCGCTag", "LCGTag", "TFGArgs", "LCGCArgs", "TCGCArgs", "TCGCarg", "TCgVar", "TFCGVar", "TCCGDef"], "args": ["gs", "settings", "bs", "issues", "ports", "flags", "ctx", "ags", "limits", "apps", "qs", "ads", "stats", "vs", "tests", "ims", "alls", "its", "users", "terms", "arr", "ps", "js", "params", "ams", "fields", "frames", "arms", "ds", "bugs", "aps", "atts", "Args", "__", "arg", "posts", "parts", "ex", "ents", "actions", "results", "uns", "as", "facts", "bits", "rows", "xs", "eps", "aus", "workers", "sys", "points", "docs", "vals", "grades", "ands", "ians", "jobs", "seconds", "ras", "amps", "fs", "members", "bytes", "aws", "tags", "ids", "values", "names", "words", "cache", "orders", "items", "ts", "ins", "ns", "modules", "uments", "weights", "ms", "rs"], "TCGOpDef": ["TCGOpDecl", "TCGEtpDecl", "TCGOcpDesc", "TCGOtpGen", "TCGOcpDef", "TCGUopGen", "TCGUopDesc", "TCGOopdef", "TCGOpDesc", "TCGUpdef", "TCGOpdef", "TCGUopdef", "TCGEtpDesc", "TCGOxpdef", "TCGOopDesc", "TCGOopDecl", "TCGOtpDecl", "TCGUpDef", "TCGOopDef", "TCGOxpDesc", "TCGEpDecl", "TCGOxpDef", "TCGOtpdef", "TCGEpdef", "TCGEpDesc", "TCGOcpGen", "TCGOtpDesc", "TCGOtpDef", "TCGEtpDef", "TCGUopDef", "TCGOcpdef", "TCGEpDef", "TCGEtpdef", "TCGUpDesc", "TCGUpGen", "TCGOpGen", "TCGOopGen", "TCGOxpDecl"], "tcg_op_defs": ["tcg_op2Defers", "tcg_op_efinitions", "tcg_op_devers", "tcg_op2Defds", "tcg_op__efeds", "tcg_op_defds", "tcg_op__efinitions", "tcg_op_defeds", "tcg_op_efs", "tcg_op_Definitions", "tcg_op_Defers", "tcg_op__defeds", "tcg_op2Definitions", "tcg_op2Defs", "tcg_op_Defs", "tcg_op_devinitions", "tcg_op2definitions", "tcg_op_Defts", "tcg_op_devds", "tcg_op_declds", "tcg_op_defers", "tcg_op_Defeds", "tcg_op__efts", "tcg_op__defs", "tcg_op_decls", "tcg_op_defts", "tcg_op_efts", "tcg_op2defds", "tcg_op2defs", "tcg_op_efeds", "tcg_op_definitions", "tcg_op_Defds", "tcg_op_declinitions", "tcg_op2defers", "tcg_op__definitions", "tcg_op_declers", "tcg_op_devs", "tcg_op__defts", "tcg_op__efs"], "i": ["index", "series", "cli", "t", " pi", "ami", "ai", "m", "xi", "qi", "iy", "parent", "ite", "ims", "it", "ji", "li", "oi", "j", "ki", "si", "zi", " ti", "ui", "iq", " bi", "im", "print", "slice", "ti", "fi", "x", "ri", "ic", "ix", "ip", "ij", "ii", "mi", "I", "pi", " iter", "batch", "di", " ii", " mi", "in", "sim", "info", "remote", "ci", " ni", "iter", "multi", "to", "me", "status", "iu", " j", "ini", "ei", "uri", "bi", "io", "is", "\u0438", "ice", "h", "point", "list", "gi", " m", "phi", "y"], "nb_ops": ["nb2opens", "nb_xs", "NB_obs", "nb_tops", "unique_ips", "NB_OPS", "nb___cats", "NB_ops", "nb_cats", "NB_opens", "nb_OPS", "nbxapps", "unique_cats", "NB_apps", "NB_xs", "nb___xs", "NB_ints", "nbxopens", "nbxobs", "nb_opens", "nbxops", "nb_ints", "nb___ints", "nb_obs", "nb___ops", "unique_ops", "nb_apps", "nb___ips", "nb_ips", "nb2ops", "nb___OPS", "nb2obs", "nb2apps", "unique_tops", "nb___tops"], "op_index": ["mop_index", "op_request", "op__ind", "op_level", "opp_offset", "oplx", "opLEiterator", "op_ind", "opityx", "op__info", "opityconnection", "opp_iterator", "opLElevel", "op_column", "op_iterator", "OP_ind", "opityind", "OP_index", "opp_index", "op_connection", "mop_ind", "opLEcolumn", "opp_Index", "mop_request", "op__request", "mop_info", "opLEindex", "OP_connection", "op_label", "OP_x", "oplind", "opityindex", "opp_label", "op_info", "opp_column", " op_ind", "op_Index", "oplindex", "op_x", "oplconnection", " op_Index", "op__index", "opp_level", "op_offset"], "nb_temps": ["nb_threadms", "nb_tmms", "nb_simples", "nb__tyms", "nb__typles", "nb_limples", "nb_Temms", "nb_simms", "nb_limts", "nb_TemPS", "nb__typs", "nb__tyPS", "nb_tmples", "nb2temps", "nb_tmts", "nb_tempo", "nb_temPS", "nb_timples", "nb2temms", "nb_threadts", "nb_limps", "nb__temms", "nb_timps", "nb__temples", "nb_timts", "nb_typo", "nb_tyPS", "nb_tyts", "nb_Temps", "nb_timpo", "nb_typs", "nb_simports", "nb_tyports", "nb_tmps", "nb_temms", "nb_typles", "nb_simps", "nb2temts", "nb_simPS", "nb_timms", "nb2tmps", "nb2temples", "nb_threadps", "nb2tmms", "nb_tyms", "nb_tmports", "nb_temports", "nb2tmples", "nb_threadpo", "nb_temts", "nb_temples", "nb2tmts", "nb__temPS", "nb__temps", "nb_limms", "nb_Temples"], "nb_globals": ["nb_glloculates", "nb_gllocales", "nb_glimols", "nb_glimALS", "nb_glipals", "nb_clobulates", "nb_glimal", "nb_glocals", "nb_Globals", "nb_glimally", "nb_gllocals", "nb_Glimals", "nb_glonALS", "nb_cllocales", "nb_globols", "nb_globales", "nb_Globales", "nb_cllocALS", "nb_glipols", "nb_Glimales", "nb_glonals", "nb_glocols", "nb_clobals", "nb_clobALS", "nb_globally", "nb_cllocals", "nb_glonulates", "nb_climals", "nb_glipally", "nb_glipALS", "nb_clloculates", "nb_glipal", "nb_glipales", "nb_globALS", "nb_GlobALS", "nb_globulates", "nb_climols", "nb_climales", "nb_glocales", "nb_glimales", "nb_global", "nb_clobales", "nb_glonales", "nb_GlimALS", "nb_Glimally", "nb_clobal", "nb_glocal", "nb_glimals", "nb_Globally", "nb_clobols", "nb_gllocALS", "nb_climal"], "nb_call_args": ["nb_all_frames", "nb_all2arg", "nb_all2frames", "nb_callallframes", "nb_callallargs", "nb_call2frames", "nb_callallflags", "nb_call2arg", "nb_all2flags", "nb_call2flags", "nb_call_flags", "nb_callallarg", "nb_call2args", "nb_all_arg", "nb_call_frames", "nb_all_args", "nb_call_arg", "nb_all_flags", "nb_all2args"], "op": ["bit", "jp", "key", "Op", "co", "oc", "o", "pat", "ok", "p", "pop", "inc", "cmp", "expr", "cod", "operator", "opt", "typ", "oop", "oper", " cop", "t", "pp", "bo", "spec", "loc", "cat", " prev", "k", " top", "omp", "operation", "lit", "alg", "hop", "block", "up", "opp", "sp", "top", "ep", " ops", "comp", "oe", "ops", " ip", "cp", "mp", "OP", "pre", "app", "arg", "it", "var", "cmd", "ip"], "def": ["tx", "pro", "Def", "kw", "dict", "f", "ref", "fun", "cmd", "DE", "crit", "lib", "dl", "feat", "req", "spec", "DEF", "eval", "diff", "ef", "func", "ds", "act", "desc", "da", "definition", "dist", "aux", "off", "info", "range", "block", "decl", "pos", "define", "df", "wd", "comp", "red", "dev", "dep", "de", "conf", "defined", "col", "d", "prop", "del", "ex", "form"], "gen_args": ["eval_params", "gen_fields", "eval_Args", "gen___Args", "gen___params", "gen___fields", "eval___fields", "genallargs", "eval___params", " gen_gs", "eval_args", "eval___Args", "genallgs", "genallArgs", "eval___args", " gen_Args", "eval_fields", "gen_Args", "gen_params", "gen_gs", "gen___args"], "tmp": [" rep", " num", " sp", " ret", " expr", " input", " np", " proc", " term", " prev", " pre", " dep", " comp", " resp", " ref", "sp", " prep", "mp", " match", " seq", " dst", " ind", " offset", " cur", " err", " parent", " cached"], "cond": ["resp", "tx", " Cond", "rupt", " condition", "Condition", "itionally", "da", "ressed", "condition", "obj", "Cond", " conditional", "pos", "code", "no", "eff", "red", "door", " conditions", "ond", "str"], "state": ["status", "type", "local", "handle", "State", "stat", "resource", "reset", "trigger", "port", "store", "close", "is", "cache", "write", "policy", "powered", "power", "tag", "release", "STATE", "comment", "range", "open", "states", "print", "post", "start", "re", "clear", "list", "hash", "style", "name", "color"], "nb_oargs": ["nb___ours", "nb_oarg", "nb_odeks", "nb_oans", "nb_oiargs", "nb_oaorders", "nb_oaarg", "nb09ocats", "nb_obcats", "nb_obargs", "nb_iparams", "nb_otterms", "nb_ons", "nb___ors", "nb_irs", "nb_ours", "nb_ocats", "nb09oagroups", "nb09oacats", "nb_iparts", "nb10oaws", "nb_margs", "nb_ouargs", "nb___oargs", "nb09ogroups", "nb_obgroups", "nb_oaws", "nb10oterms", "nb09ons", "nb_iarms", "nb_oorders", "nb_ouparams", "nb_oiparts", "nb_otargs", "nb_ioaws", "nb_oparams", "nb_odates", "nb_otdates", "nb_oxargs", "nb10otterms", "nb_oiorders", "nb_mbytes", "nb_ors", "nb_oeargs", "nb_ogroups", "nb_inaws", "nb_oxns", "nb10otargs", "nb_obns", "nb_oeparams", "nb09oans", "nb09oaargs", "nb10odates", "nb_oacats", "nb___ouparams", "nb_mobytes", "nb10otdates", "nb_oxgroups", "nb_mflags", "nb_ioargs", "nb_oers", "nb_odeargs", "nb_oaparts", "nb_indates", "nb___oarms", "nb_inargs", "nb___ouargs", "nb_oflags", "nb_iodates", "nb_oagroups", "nb_otaws", "nb___oparams", "nb_oparts", "nb_oaargs", "nb_moargs", "nb_oks", "nb10otaws", "nb___ouarms", "nb_oxcats", "nb_ioterms", "nb_oearms", "nb_mks", "nb_interms", "nb_moks", "nb_odeflags", "nb_oarms", "nb_oiarg", "nb_iorders", "nb10oargs", "nb_moflags", "nb_ouarms", "nb_obytes", "nb_oterms", "nb09oargs", "nb_iarg", "nb_odebytes", "nb_iargs"]}}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "static void vnc_connect(VncDisplay *vd, int csock,\n\n                        bool skipauth, bool websocket)\n\n{\n\n    VncState *vs = g_malloc0(sizeof(VncState));\n\n    int i;\n\n\n\n    vs->csock = csock;\n\n    vs->vd = vd;\n\n\n\n    if (skipauth) {\n\n\tvs->auth = VNC_AUTH_NONE;\n\n\tvs->subauth = VNC_AUTH_INVALID;\n\n    } else {\n\n        if (websocket) {\n\n            vs->auth = vd->ws_auth;\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        } else {\n\n            vs->auth = vd->auth;\n\n            vs->subauth = vd->subauth;\n\n        }\n\n    }\n\n    VNC_DEBUG(\"Client sock=%d ws=%d auth=%d subauth=%d\\n\",\n\n              csock, websocket, vs->auth, vs->subauth);\n\n\n\n    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n\n        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));\n\n    }\n\n\n\n    VNC_DEBUG(\"New client on socket %d\\n\", csock);\n\n    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n\n    qemu_set_nonblock(vs->csock);\n\n    if (websocket) {\n\n        vs->websocket = 1;\n\n        if (vd->ws_tls) {\n\n            qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io, NULL, vs);\n\n        } else {\n\n            qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);\n\n        }\n\n    } else\n\n    {\n\n        qemu_set_fd_handler(vs->csock, vnc_client_read, NULL, vs);\n\n    }\n\n\n\n    vnc_client_cache_addr(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);\n\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);\n\n\n\n    if (!vs->websocket) {\n\n        vnc_init_state(vs);\n\n    }\n\n\n\n    if (vd->num_connecting > vd->connections_limit) {\n\n        QTAILQ_FOREACH(vs, &vd->clients, next) {\n\n            if (vs->share_mode == VNC_SHARE_MODE_CONNECTING) {\n\n                vnc_disconnect_start(vs);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 15389, "substitutes": {"vd": ["vol", "VD", "vv", "nv", "td", "pb", "vr", "dl", "xd", "vp", "cd", "dt", "pd", "v", "dm", "md", "nd", "du", "sv", "di", "rid", "vid", "ds", "dd", "gd", "ud", "kb", "bd", "ved", "vm", "ld", "hd", "uds", "dj", "dri", "od", "dk", "df", "wd", "lv", "etc", "rd", "sd", "d", "dh", "uv", "ve", "vc", "vt", "idd", "udi"], "csock": ["cssocks", "cusocket", "csvock", "csvocker", "insocket", "bsoin", "capsocker", "csink", "CSOCK", "cusocker", "cssOCK", "nsink", "insick", "cusock", "lsocked", "cssoker", "bsOCK", "csvoker", "lsOCK", "cssong", "acsink", "csocks", "csOCK", "dsocker", "dsickle", " csocks", "CSoker", "cksink", "cksock", "csoker", "bsock", "cksoin", "cssocked", " cslock", " csink", "bsink", "cssocker", "cssock", "bsocked", "dsocket", "csvOCK", "rsock", "csocked", "dsocked", "csick", "insocker", "cksocket", "capsock", "csocket", "dsick", "acsocker", "cssocket", "dsock", "bsocker", "ckslock", "insock", "acsocked", " csong", "acsock", "rsocks", "csocker", "capsick", "CSocker", "nsock", "cslock", "rsick", "cusocks", "nsoin", "nsocket", "acsickle", "csickle", " csocket", "bsocket", "bsick", "rsocker", "cksong", " csocker", "cusickle", "acsocks", "csoin", "csong", "capsocket", "cusocked", "cksocker", "csslock", "lsocket", "lsock", "cusick", "CSock", "rsocket", "cusink"], "skipauth": ["withoutconn", "skiphack", " skipconn", "skiAuth", "Skiphack", " skipAuth", " skipauthor", "SkipAuth", "skipAuth", "skipconn", "skiauthor", "skipauthor", "skiconn", "withouthack", " skiphack", "Skipauthor", "withoutauth", "skiauth", "Skipconn", "Skipauth"], "websocket": ["rebsheet", "weboxesession", " websheet", "weversockets", "weboxessocket", "websice", "weosession", "seosheet", "webswitch", "websheet", "weversession", "weckssocket", "sebsocket", "websession", "weosocket", "heBSocket", "weblheet", "wecksheet", "kecksocket", "ressocket", "weyssocket", "kebsource", "ressheet", "seosession", "weisockets", "weysockets", " webswitch", "hebsock", "heBSsocket", "weverssocket", "weosource", "weisheet", "weysock", "seossocket", "weblocket", "weisocket", "sebsession", "weadsheet", "sebssocket", "heBSock", "weisice", " webssocket", "wessheet", "wessocket", "weposocket", "weblwitch", "seosocket", "rebsockets", " weressocket", "wecksource", "weadsource", "weversocket", "websock", " weresheet", "weosheet", "kecksheet", "weposockets", "weboxesocket", "weadssocket", "kebsocket", "weressocket", "wessice", "weposheet", "weBSock", "ressice", "websource", "rebsice", "wereswitch", "weboxesheet", "weBSocket", "weadsocket", "kecksource", "weversock", "weossocket", "weversheet", "keckssocket", "webssocket", "sebsheet", "kebssocket", " wereswitch", "kebsheet", "rebsocket", "hebsocket", "weposice", "heBSockets", "weresheet", "weBSockets", "wecksocket", "weresocket", " weresocket", "wessockets", "weysocket", "hebsockets", "weblsocket", "ressockets", "hebssocket", "websockets", "weBSsocket"], "vs": ["gs", "bs", "ves", "ports", "flags", "plays", "vers", "Vs", "s", "qs", "ads", "otes", "caps", "stats", "cs", "lv", "ims", "links", "ks", "ues", "its", "pps", "terms", "ps", "obs", "js", "v", "lists", "pages", "wcs", "ds", "obj", " cs", "ies", "services", "atts", "inv", " ss", "res", "args", "ows", "posts", "vc", "VS", "vv", " sv", "ver", "lines", "blogs", "vp", "xs", "eps", "nets", "hs", "docs", "vals", "uds", "ops", "es", "changes", "fs", "uv", "px", "views", "vt", "ss", "irms", "ys", "values", "vr", "names", "vi", "is", "sv", "ls", "gets", "vm", "ts", "ins", "ns", "var", "sts", "ms", "rs"], "i": ["key", "index", "li", "f", "oi", "ii", "mi", "I", "pi", " j", "ini", "j", "ind", "p", "ei", "n", "si", "zi", " ti", "v", "cli", "bi", "port", "batch", "t", "us", "is", "ui", "di", "ami", " ii", "ai", "m", "in", " I", "xi", "qi", "sim", "c", "ci", "span", "ti", "inner", "ri", "multi", "gi", "it", "me", "z", "phi", "x", "y", "ic", "ix", "ip"]}}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_current_dir(FTPContext *s)\n\n{\n\n    char *res = NULL, *start = NULL, *end = NULL;\n\n    int i;\n\n    const char *command = \"PWD\\r\\n\";\n\n    const int pwd_codes[] = {257, 0};\n\n\n\n    if (!ftp_send_command(s, command, pwd_codes, &res))\n\n        goto fail;\n\n\n\n    for (i = 0; res[i]; ++i) {\n\n        if (res[i] == '\"') {\n\n            if (!start) {\n\n                start = res + i + 1;\n\n                continue;\n\n            }\n\n            end = res + i;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (!end)\n\n        goto fail;\n\n\n\n    if (end > res && end[-1] == '/') {\n\n        end[-1] = '\\0';\n\n    } else\n\n        *end = '\\0';\n\n    av_strlcpy(s->path, start, sizeof(s->path));\n\n\n\n    av_free(res);\n\n    return 0;\n\n\n\n  fail:\n\n    av_free(res);\n\n    return AVERROR(EIO);\n\n}\n", "idx": 15401, "substitutes": {"s": ["ses", "aws", "gs", "a", "S", "f", "o", "bs", "less", "ctx", "n", "p", "js", "ex", "sq", "v", "eps", "g", "t", "sv", "sb", "hs", "sys", "ds", "ats", "ls", "m", "erences", "r", "obj", "qs", "ts", "c", "b", "ns", "cs", "an", "h", "fs", "conf", "d", "its", "w", "ss", "sts", "scl", "rs", "ps"], "res": ["ress", "conn", "windows", "pres", "expr", "RES", "raw", "val", "result", "fresh", "nt", "rev", "resolution", "gr", "cs", "net", "rez", "upper", "resh", "arr", "ps", "tx", "rem", "rc", "def", "mem", "ret", "addr", "cmd", "js", "resource", "reset", "next", "obj", "pos", "con", "full", "ri", "results", "ix", "resp", "out", "bits", "req", "sys", "rest", "vals", "uds", "ro", "red", "err", "ris", "str", "status", "serv", "response", "min", "chain", "reg", "details", "r", "prefix", "range", "rt", "base", "resy", "ins", "Res", "re", "rel", "os", "max", "q", "rx", "init", "ms", "rs", "ch"], "start": ["key", "wind", "path", "shift", "Start", "started", "size", "ST", "starting", "addr", "p", "group", " Start", "begin", "req", "reset", "next", "try", "store", "t", "stop", "before", "kind", "st", "space", "offset", "rest", "r", "part", "step", "time", "first", "range", "sp", "art", "pos", "base", "trans", "top", "id", "ish", "set", "iter", "from", "it", "length", "style", "need", "init", "name", "str"], "end": ["path", "ist", "window", "close", "nd", "len", "st", "send", "line", "ending", "add", "en", "ish", "ort", "it", "length", "nil", "fin", "End", "ff", "then", "after", "fail", "tail", "reset", "next", "rend", "until", "use", "dest", "set", "edge", "east", "wind", "be", "est", "out", "stop", "offset", "rest", "ended", "id", "to", "se", "bound", "str", "size", "begin", "chain", "except", "ent", "ext", "END", "gate", "last", "off", "range", "ender", "pend", "all", "ment", "append", "hend", "e", "point", "max", "final", "endif", "can", "ENDED"], "i": ["ij", "index", "li", "iu", "ski", "mi", "ii", " j", "pi", "I", "ind", "j", "ini", "n", "p", "ei", "si", "uri", "zi", "v", "ori", "cli", "bi", "t", "ui", "is", "ia", "di", "asi", " ii", "ai", "m", "k", "hi", "ie", "json", "xi", "qi", "sim", "info", "im", "\u0438", "iri", "mini", "ci", "id", "ims", "slice", "ti", "ri", "u", "oi", "iter", "multi", "gi", "it", "fi", "me", "ji", "phi", "x", "imm", "y", "ic", "ix", "ip"], "command": ["directory", "type", "request", "query", "which", "address", " Command", "cmd", "mode", "sequence", "call", "pattern", "rule", "service", "three", "power", "menu", "operation", "message", "description", "word", "minute", "comment", "prefix", "attribute", "sword", "buffer", "password", "function", "code", "execute", "action", "reason", "transform", "direction", "method", "Command", "history", "controller", "process", "template"], "pwd_codes": ["pwd2lines", "pwd2code", "pWD_codes", "pwd2odes", "pwd_lines", "pw_codes", "pw_code", "pwd2codes", "pw_lines", "pwd_odes", "pWD_code", "pWD_odes", "pwd_code"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opts_print(QemuOpts *opts, void *dummy)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    fprintf(stderr, \"%s: %s:\", opts->list->name,\n\n            opts->id ? opts->id : \"<noid>\");\n\n    TAILQ_FOREACH(opt, &opts->head, next) {\n\n        fprintf(stderr, \" %s=\\\"%s\\\"\", opt->name, opt->str);\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n    return 0;\n\n}\n", "idx": 15411, "substitutes": {"opts": ["oprs", " optars", " optents", "optns", "opns", "OPTS", " oprs", " optts", "opcs", "OPps", "Opgs", "opTS", "Opts", "iopTS", " opns", "OPds", " opds", "Oprs", "OPuts", "Opents", "optTS", "opents", "OPs", " opps", "opls", "optcs", "opds", "iopts", " optls", " opars", " opls", "opps", " opTS", " oputs", " ops", "ops", "optds", "OPts", "opars", "Opars", " opents", " opcs", "opgs", "optgs", "optuts", " opgs", "Opcs", "OPns", "Opls", "optrs", "optts", "iopps", "iops", "oputs"], "dummy": ["Dummy", " dummies", "datum", "sdummies", "dummies", "sdatum", " datum", "sdummy", "Datum", "Dummies"], "opt": ["def", "mem", "ret", "prev", "ver", "out", "tv", "cmd", "j", "kt", "timeout", "req", "proc", "val", "let", "pt", "t", "buf", "ext", "num", "select", "cat", "nt", "op", "tag", "alt", "gt", "obj", "aux", "trial", "slot", "anon", "block", "sp", "plot", "lt", "gr", "eff", "term", "cho", "tmp", "iter", "arg", "list", "var", "max", "col", "optim", "option", "prop", "init", "pkg", "Opt", "xml", "name", "tab", "txt"]}}
{"project": "FFmpeg", "commit_id": "fe448cd28d674c3eff3072552eae366d0b659ce9", "target": 0, "func": "static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,\n\n                                AVFrame *picture)\n\n{\n\n    int compno, reslevelno, bandno;\n\n    int x, y;\n\n\n\n    uint8_t *line;\n\n    Jpeg2000T1Context t1;\n\n\n\n    /* Loop on tile components */\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n\n        Jpeg2000Component *comp     = tile->comp + compno;\n\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n\n\n        /* Loop on resolution levels */\n\n        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {\n\n            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n\n            /* Loop on bands */\n\n            for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n                int nb_precincts, precno;\n\n                Jpeg2000Band *band = rlevel->band + bandno;\n\n                int cblkno = 0, bandpos;\n\n\n\n                bandpos = bandno + (reslevelno > 0);\n\n\n\n                if (band->coord[0][0] == band->coord[0][1] ||\n\n                    band->coord[1][0] == band->coord[1][1])\n\n                    continue;\n\n\n\n                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;\n\n                /* Loop on precincts */\n\n                for (precno = 0; precno < nb_precincts; precno++) {\n\n                    Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n                    /* Loop on codeblocks */\n\n                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n\n                        int x, y;\n\n                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n                        decode_cblk(s, codsty, &t1, cblk,\n\n                                    cblk->coord[0][1] - cblk->coord[0][0],\n\n                                    cblk->coord[1][1] - cblk->coord[1][0],\n\n                                    bandpos);\n\n\n\n                        x = cblk->coord[0][0];\n\n                        y = cblk->coord[1][0];\n\n\n\n                        if (codsty->transform == FF_DWT97)\n\n                            dequantization_float(x, y, cblk, comp, &t1, band);\n\n                        else\n\n                            dequantization_int(x, y, cblk, comp, &t1, band);\n\n                   } /* end cblk */\n\n                } /*end prec */\n\n            } /* end band */\n\n        } /* end reslevel */\n\n\n\n        /* inverse DWT */\n\n        ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data);\n\n    } /*end comp */\n\n\n\n    /* inverse MCT transformation */\n\n    if (tile->codsty[0].mct)\n\n        mct_decode(s, tile);\n\n\n\n    if (s->cdef[0] < 0) {\n\n        for (x = 0; x < s->ncomponents; x++)\n\n            s->cdef[x] = x + 1;\n\n        if ((s->ncomponents & 1) == 0)\n\n            s->cdef[s->ncomponents-1] = 0;\n\n    }\n\n\n\n    if (s->precision <= 8) {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            Jpeg2000Component *comp = tile->comp + compno;\n\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n            float *datap = comp->f_data;\n\n            int32_t *i_datap = comp->i_data;\n\n            int cbps = s->cbps[compno];\n\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n\n            int planar = !!picture->data[2];\n\n            int pixelsize = planar ? 1 : s->ncomponents;\n\n            int plane = 0;\n\n\n\n            if (planar)\n\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n\n\n\n\n            y    = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            line = picture->data[plane] + y * picture->linesize[plane];\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint8_t *dst;\n\n\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = line + x * pixelsize + compno*!planar;\n\n\n\n                if (codsty->transform == FF_DWT97) {\n\n                    for (; x < w; x += s->cdx[compno]) {\n\n                        int val = lrintf(*datap) + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        *dst = val << (8 - cbps);\n\n                        datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                } else {\n\n                    for (; x < w; x += s->cdx[compno]) {\n\n                        int val = *i_datap + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        *dst = val << (8 - cbps);\n\n                        i_datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                }\n\n                line += picture->linesize[plane];\n\n            }\n\n        }\n\n    } else {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            Jpeg2000Component *comp = tile->comp + compno;\n\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n            float *datap = comp->f_data;\n\n            int32_t *i_datap = comp->i_data;\n\n            uint16_t *linel;\n\n            int cbps = s->cbps[compno];\n\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n\n            int planar = !!picture->data[2];\n\n            int pixelsize = planar ? 1 : s->ncomponents;\n\n            int plane = 0;\n\n\n\n            if (planar)\n\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n\n\n            y     = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint16_t *dst;\n\n\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = linel + (x * pixelsize + compno*!planar);\n\n                if (codsty->transform == FF_DWT97) {\n\n                    for (; x < w; x += s-> cdx[compno]) {\n\n                        int  val = lrintf(*datap) + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        /* align 12 bit values in little-endian mode */\n\n                        *dst = val << (16 - cbps);\n\n                        datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                } else {\n\n                    for (; x < w; x += s-> cdx[compno]) {\n\n                        int val = *i_datap + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        /* align 12 bit values in little-endian mode */\n\n                        *dst = val << (16 - cbps);\n\n                        i_datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                }\n\n                linel += picture->linesize[plane] >> 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 15420, "substitutes": {"s": ["ses", "gs", "S", "src", "l", "p", "n", "js", "sq", "v", "css", "g", "t", "comm", "spec", "sb", "sv", "space", "sys", "ds", "sf", "ls", "m", "cpp", "sc", "ts", "self", "c", "stats", "b", "ns", "cs", "h", "es", "ims", "e", "fs", "sg", "os", "d", "se", "ss", "i", "sts", "rs", "ps"], "tile": ["bit", "profile", "ty", "metadata", "gem", "query", "map", "tif", "pixel", "skill", "layer", "ile", "chip", "test", "try", "t", "frame", "unit", "util", "cache", "cell", "tag", "peg", "phy", "tle", "buffer", "tf", "sel", "file", "image", "coord", "table", "grid", "term", "slice", "ti", "mt", "texture", "component", "Tile", "ve", "style", "shot", "league", "target", "ele", "te", "tab", "template"], "picture": ["profile", " Frame", "face", "record", "ff", "movie", " f", "media", "frame", "video", "fm", "fx", "original", "rame", "fb", " framed", " framing", "pic", "image", "fp", "img", " fps", "Picture", "fac", "iframe", " frames", "fps", " fram"], "compno": ["paryes", "cmpNO", "commnos", "condeno", "cpno", "cmdmo", "comdo", "comppo", "cmpmo", "componentyes", "comno", "componentno", "cmpnone", "compNO", "componenteno", " compNO", "condno", "condyes", "comyes", "commnone", "compnr", "cmpno", " compeno", "cmppo", "compnos", "cpeno", "expeno", "compnone", "cmpnr", "commpo", "conddo", "ompno", "cmdyes", "compko", "cmpname", "compeno", "cmpnos", "omppo", " compyes", "compyes", "cmdno", " compname", "compmo", "comname", "componentko", "comeno", "compdo", "componentNO", "cmpeno", "commno", "expno", "ompnone", "ompnos", "comNO", "cmpko", "parmo", "expyes", "parnr", "cpyes", "expko", "cmdnr", "cpdo", "parno", "compname", "cmpyes"], "reslevelno": [" reslayeryes", "reslvlno", "reslvlyes", "conslevelNO", "reslevelna", "reslevelmo", "conslevelano", "resslevelco", "reslvlano", "reslayerco", "restieryes", "resslayerno", "resolutionlevelnumber", "resslevelNO", "reslockno", "reslevello", "conscompno", "conscompano", "reslevelano", "restiernos", "resslayermo", "conscompna", "resleveleno", " reslayerNO", "restiertoo", "preslvlno", "resgroupzero", "resvelno", "reslevelNO", "reslvlne", "reslayerNO", "reslayerno", "restierno", "resLevelco", "resgroupno", "resLevelno", "reslockyes", "resslevelmo", "conscompNO", "reslocknos", "reslayeryes", "reslvlna", " reslayerno", "reslayertoo", "reslayernos", "preslevelno", " reslayerne", "resvelyes", "resleveltoo", "reslayerlo", " reslevelyes", "reslvllo", "reslvlco", "reslevelyes", "resgroupnumber", "resolutionlvleno", "conslevelna", "resscopezero", " reslevelne", "reslevelnos", "reslayerne", "resslayerNO", "reslockne", "rescompano", "rescompna", "preslvlyes", " reslevelNO", "resscopeeno", "resveltoo", " reslayernos", "preslevello", "resolutionlvlnumber", "resolutionlevelzero", "resLevelNO", "reslayermo", "reslocklo", "reslvlnos", " reslevelnos", "reslvlzero", "reslevelzero", "resslevelno", "rescompNO", "resgroupeno", " resleveltoo", "rescompno", "reslvlNO", "reslvlmo", " reslayertoo", "resscopeno", "reslevelnumber", "reslockNO", "resvelnos", "resolutionleveleno", "resscopenumber", "conslevelno", "reslevelco", "resolutionlevelno", "preslvllo", "resolutionlvlno", "reslvleno", "resslayerco", "resLevelmo", "preslevelyes", "reslvlnumber", "reslevelne", "resolutionlvlzero"], "bandno": ["bandna", " bandna", "roadNo", "rankno", "batchmo", "brandne", "broadno", " bandid", "batchgo", "brandpo", "broadyes", "broadio", "bandpo", "batchno", "bandgo", "batchpo", "wordgo", "bindyes", "bandid", "bandnos", " bandNO", "brandmo", "wordpo", "brandna", "bindnos", "levelno", "rankne", "wordno", "batchNo", "batchnos", "levelty", "bindno", "brandyes", "bandmo", " bandty", "bandNo", "bitNO", "broadNo", "rankNo", "bandNO", "roadna", "wordmo", "bandne", " bandio", "brandno", " bandyes", "batchyes", "brandnos", "bindpo", "brandgo", "brandNo", " bandNo", "roadno", "bandio", "bitNo", "rankid", "brandty", "batchio", "brandid", "roadNO", " bandne", "bandyes", "bitna", "bitno", "levelna", "bandty"], "x": ["tx", " ax", "at", "f", "o", "l", "yx", "n", "p", "ex", "X", "v", "xs", "xy", "t", "ox", "xp", "fx", "m", " tx", " w", "xi", " dx", "lon", " i", "dx", "xc", "top", "lat", "on", "coord", "xx", "my", "px", "xa", "z", "rx", "i", "w", "xt", " xx", "ix"], "y": ["yy", "def", "ty", "ly", "yt", "record", "py", "dy", "o", "ny", "ys", "j", "sy", "p", "n", "Y", "conv", "v", "xy", "ya", "ym", "ay", "t", "com", "ye", "new", "func", "m", "cy", "vy", "iy", "obj", "ies", "im", "c", "jpg", "img", "ry", "b", "_", "sky", "yo", "gy", "ey", "i", "cont", "fy", "ch"], "line": ["record", "lines", "l", "lc", "row", "rule", "text", "frame", "len", "Line", "cell", "lin", "buffer", "block", "image", "file", "base", "link", "code", "byte", " lines", "LINE", "scale", "entry", "style", "level", "ine"], "t1": ["m4", "pOne", "p1", "T3", "T2", "c3", "c2", " t2", "t2", "cOne", "tOne", "p2", "m3", "c1", "t3", " t3", "m1", " tOne", "p4", "T4", "T1", "m2", "t4", "p3"], "comp": ["resp", "pro", "bit", "def", "co", "cond", "cmd", "ctx", "crit", "cmp", "par", "cod", "cc", "proc", "lib", "compl", "conv", "agg", "reg", "comm", "Component", "com", "buff", "Comp", "comb", "rend", "sec", "cell", "op", "omp", "rep", "c", "om", "pos", "cp", "mp", "fc", "con", "conf", "mod", "app", "col", "prof", "component", "prop", "coll", "prep", "tab", "ch"], "codsty": ["condsty", "cellst", "cellsty", "codty", " codzz", "Codsty", " codety", "ccstyle", "condstyle", "cledless", "cdzz", "ccstro", "codstro", " codless", "codestyle", "codesty", " codsys", "codedstyle", "codedsty", "cledsty", "codesy", "codzz", "condety", "Codstyles", "codsy", "ccsy", "Codty", "codstyles", "codstyle", "Codety", " codst", "cdst", "codless", " codstyle", "cdsys", "cledty", "ccsty", "cellzz", "codestro", "cledstyle", "codsys", "Codless", "codedstro", "cdsty", "cellsys", "codedsy", "Codstyle", " codstyles", "codety", " codty", "codst", "condstyles"], "rlevel": [" rgroup", "srpass", " rvel", "rmode", "rcvel", "rtstage", "rrrole", "rtlayer", "rvel", "rwall", "rlevels", "rday", "vrlevel", "srstage", " rmode", "rrpass", "srday", " rlevels", "rarline", " rline", "rrvel", "rrday", "relevel", "rline", "reslvl", "rrlevel", "rgroup", "rtlevel", "vrgroup", "srlevel", "resday", "hvel", "hlevel", "relevels", " rrole", "rrlvl", "rarlevels", "rarlevel", "rclevel", "hday", "vrrole", "rrmode", "rlvl", "rtvel", "rlayer", "srvel", "rstage", "rewall", " rwall", " rday", "reline", "rpass", "srmode", "vrvel", "rcstage", "rrole", "rarwall", "reslevel", "hlvl", "resvel", "rrgroup", " rpass", "rclayer", "srlayer"], "nb_precincts": ["nb_precuncted", "nb_precixtings", "nb_prefunctes", "nb_precributxs", "nb_precinctls", "nb_precuixts", "nb_precointeds", "nb_precuinctS", "nb_prefuncted", "nb_precuncteds", "nb_precributes", "nb_precuincteds", "nb_precixtxs", "nb_precincteds", "nb_precixteds", "nb_precsixteds", "nb_precuixteds", "nb_precunctings", "nb_prefuncters", "nb_precixtS", "nb_precoints", "nb_precsixts", "nb_prefincts", "nb_precunctes", "nb_precributS", "nb_precributed", "nb_precributeds", "nb_precointxs", "nb_precsinctings", "nb_precuinctxs", "nb_precunctls", "nb_precributs", "nb_precsincts", "nb_precuixtxs", "nb_prefincters", "nb_precointS", "nb_precuncters", "nb_prefinctes", "nb_precuixtS", "nb_precixtls", "nb_precributings", "nb_precsincteds", "nb_precuncts", "nb_precsixtls", "nb_prefuncts", "nb_precincted", "nb_precinctS", "nb_precributers", "nb_prefincted", "nb_precsinctls", "nb_precributls", "nb_precuincts", "nb_precinctings", "nb_precinctxs", "nb_precinctes", "nb_precixts", "nb_precsixtings", "nb_precincters"], "precno": [" precnumber", "precnumber", "preccorno", "prebno", "Preknum", "prefno", "pricNo", "prevyes", "preclen", "precyes", "prebko", "prekdo", "prefdo", "prifeno", " preborno", "prekno", "prefNo", "prifno", "PrekNo", "pricno", "prikNo", "prepceno", "prepcyes", "precdo", "prefyes", "prekNo", "prefcNO", "repcno", "preccno", "prebnumber", "pricko", "precNo", "prevno", "prevNO", "prebnum", "prifko", " preblen", "prekko", "prebNO", "PrecNO", "preblen", "prerorno", "pricdo", "precnum", "prikno", "prebNo", "prikdo", "prefcdo", "Precnum", "repcNO", "prefNO", "Precno", "repceno", "prerno", "Prekno", " preclen", "prefcNo", " prebnumber", "precNO", "preveno", "preccnumber", "precko", "preknum", "prebeno", "priceno", "prifNo", "precorno", "prekNO", "PrekNO", "prefnum", "preceno", "PrecNo", "prernumber", "prefcno", "prekeno", " prebno", "repcyes", "receno", "prefeno", "recyes", "prepcno", "prerlen", "prepcNO", "pricNO", "recNO", "preborno", "recno", "precclen", "prikNO", " precorno", "prefko"], "band": ["bit", "raid", "display", "window", "val", "low", "channel", "word", "lag", "ble", "bd", "disc", "plane", "binary", "filter", "ond", "co", "beam", "bands", "mon", "high", "cmd", "flash", "group", "buff", "cell", "br", "power", "chrom", "library", "db", "ang", "bind", "flag", "sound", "ber", "pair", "gain", "bb", "prep", "tab", "node", "be", "allowed", "rad", "pixel", "boot", "batch", "bo", " Band", "comb", "dom", "brand", "broad", "work", "block", "cand", "rom", "bed", "amp", "bor", "bar", "light", "reg", "pp", "Band", "bin", "bart", "tag", "road", "bridge", "bright", "day", "byte", "b", "component", "way"], "bandpos": ["Bandpos", "broadno", "grouppos", "groupoffset", "bindPos", "barpos", "broadinfo", "BandPos", "bandloc", "broadpos", " bandloc", "bandinfo", "barinfo", "domloc", "bandoffset", "bindpos", "bandPos", "Bandloc", "bindoffset", "groupPos", "bindloc", "grouploc", " bandPos", "dompos", "domPos", " bandinfo", " bandoffset", "barno"], "prec": ["recam", " prek", "prev", "secam", "bref", "proco", "gek", "precc", "brech", "Preco", "seco", "gef", "brek", "proc", "reco", " prech", " preco", "noteco", "pricc", "Prec", "priv", "sec", "prico", "brec", "prif", "sep", " prev", "preco", "prech", "preb", " precc", "rep", "precam", "prek", "notecc", "Preb", "Pref", "pric", " pref", "notec", "prov", " precam", " prep", "rec", "prib", "notef", "pref", "gec", "gech", "prof", "Prev", " preb", "prik", "prep", "Prek"], "cblkno": ["cblogkysha", "cblunkorno", "cblukno", "clabelukno", "cblukNo", "cblckmo", "cbldkno", "cblekidno", "cbrkna", "cblarkNo", "cblkpos", "clabelukmo", "cblarkmo", "cbldknone", "cBLckmo", "cblkypos", "cblarkna", "cblkyNo", "cBLckNo", "cblunkno", "cblogkyNo", "cbleklo", "cblkkno", "cblkysha", "cblekna", "cblkeno", "cblckpos", "cbltkcro", "cblkidlo", "cblekno", "cblekidlo", "cblunknone", "clabelkne", "cBLkmo", "clabelkNo", "cblakmo", "cblukmo", "cbrkorno", "cblknos", "cblogkno", "cblkorno", "cbrarknone", "cblaksha", "cblklo", "clabelukne", "cbrkno", "cblckno", "clabelukNo", "cBLkNo", "cblkelo", "cblkcro", "cbldkorno", "cblkmo", "cblksha", "cblakpos", "cblkknos", "cblkidna", "cbldkna", "cblkyno", "cblakNo", "clabelkno", "cblogksha", "cblkena", "cblkNo", "cblekidna", "cblkkmo", "cbrarkorno", "cbltkno", "cblarkno", "cBLkno", "cblekidcro", "cBLknos", "cblckne", "cbltkna", "cBLckno", "cblkidno", "cblknone", "clabelkmo", "cblakne", "cblarknos", "cblarknone", "cblkecro", "cbrarkno", "cblogkypos", "cblarkorno", "cblkna", "cBLcknos", "cbltklo", "cblakno", "cblkidcro", "cblcksha", "cblkne", "cblcknos", "cblckNo", "cblogkyno", "cblukne", "cbrknone", "cbrarkna", "cblunkna", "cblekcro", "cblkkNo", "cblogkNo", "cblogkpos"], "cblk": [" cBLc", "crelk", "cblck", "canblkar", "dcbrk", "cbrkid", "cblkin", "crelke", "cplk", "cBLk", "canuchk", "rblekt", "lcbrk", "dcblk", " cblck", "cblj", "cllk", "cllkk", "rblk", "cblunk", "cblak", "cllq", "cBlak", "cplj", "cplks", "cBLck", "cblkar", " cBLkin", "cplkid", "canblck", "cBlunk", "cplkt", "cblekt", "cBLc", "cblc", "cbrunk", " cblak", "cblkid", "cuchk", "lcblk", "cplak", "cluak", "cbrkt", " cBLk", "cBlck", "lcbrunk", "cblkk", " cblkin", "cbrak", "crelak", "canuchke", "lcblak", "dcblak", "cbleak", "cuchkar", "canblk", "rbleks", "dcbrkk", "cblkt", " cplak", "cluks", "cllak", "cblke", "lcblunk", "cBLkk", "canuchkar", "cBlk", "cbrkk", " cplj", "cluc", "rblkid", " cBLak", "cBlj", "cbrk", "cplck", "lcbrak", "crelkar", "cuchck", "dcblq", "dcbrak", " cBLck", "cbrks", "cblekid", "cblek", "cblks", "cblej", " cplck", "rblek", "crelck", "canuchck", "cBLq", "canblke", "cbrq", " cBLks", "lcblks", "cblec", "cbleck", "lcbrks", "cblq", "cbleks", "cuchke", "cBLkin", "rblekid", "crelunk", "cuchkin", "cluk", "cBLks", "crelks", "rblks", "cBlks", " cblc", " cblks", " cplk", " cblj", "dcbrq", "dcblkk", "cBLak", "rblkt"]}}
{"project": "qemu", "commit_id": "158fd3ce98afd21f2e2639600f6414ea703a9121", "target": 0, "func": "void qemu_run_all_timers(void)\n\n{\n\n    alarm_timer->pending = 0;\n\n\n\n    /* rearm timer, if not periodic */\n\n    if (alarm_timer->expired) {\n\n        alarm_timer->expired = 0;\n\n        qemu_rearm_alarm_timer(alarm_timer);\n\n    }\n\n\n\n    /* vm time timers */\n\n    qemu_run_timers(vm_clock);\n\n    qemu_run_timers(rt_clock);\n\n    qemu_run_timers(host_clock);\n\n}\n", "idx": 15434, "substitutes": {}}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "static struct XenDevice *xen_be_get_xendev(const char *type, int dom, int dev,\n\n                                           struct XenDevOps *ops)\n\n{\n\n    struct XenDevice *xendev;\n\n\n\n    xendev = xen_be_find_xendev(type, dom, dev);\n\n    if (xendev) {\n\n        return xendev;\n\n    }\n\n\n\n    /* init new xendev */\n\n    xendev = g_malloc0(ops->size);\n\n    xendev->type  = type;\n\n    xendev->dom   = dom;\n\n    xendev->dev   = dev;\n\n    xendev->ops   = ops;\n\n\n\n    snprintf(xendev->be, sizeof(xendev->be), \"backend/%s/%d/%d\",\n\n             xendev->type, xendev->dom, xendev->dev);\n\n    snprintf(xendev->name, sizeof(xendev->name), \"%s-%d\",\n\n             xendev->type, xendev->dev);\n\n\n\n    xendev->debug      = debug;\n\n    xendev->local_port = -1;\n\n\n\n    xendev->evtchndev = xen_xc_evtchn_open(NULL, 0);\n\n    if (xendev->evtchndev == XC_HANDLER_INITIAL_VALUE) {\n\n        xen_be_printf(NULL, 0, \"can't open evtchn device\\n\");\n\n        g_free(xendev);\n\n        return NULL;\n\n    }\n\n    fcntl(xc_evtchn_fd(xendev->evtchndev), F_SETFD, FD_CLOEXEC);\n\n\n\n    if (ops->flags & DEVOPS_FLAG_NEED_GNTDEV) {\n\n        xendev->gnttabdev = xen_xc_gnttab_open(NULL, 0);\n\n        if (xendev->gnttabdev == XC_HANDLER_INITIAL_VALUE) {\n\n            xen_be_printf(NULL, 0, \"can't open gnttab device\\n\");\n\n            xc_evtchn_close(xendev->evtchndev);\n\n            g_free(xendev);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        xendev->gnttabdev = XC_HANDLER_INITIAL_VALUE;\n\n    }\n\n\n\n    QTAILQ_INSERT_TAIL(&xendevs, xendev, next);\n\n\n\n    if (xendev->ops->alloc) {\n\n        xendev->ops->alloc(xendev);\n\n    }\n\n\n\n    return xendev;\n\n}\n", "idx": 15449, "substitutes": {"type": ["types", "key", "index", "error", "ty", "Type", "version", "by", "def", "ime", "ver", "ref", "size", "data", "family", "cmd", "core", "p", "x", "class", "role", "stat", "typ", "Ty", "test", "port", "t", "ping", "kind", "domain", "controller", "title", "sys", "op", "tag", "time", "phy", "info", "TYPE", "rt", "file", "debug", "color", "ype", "pc", "id", "rel", "var", "tp", "style", "value", "pl", "name", "ico", "y", "pe"], "dom": ["node", "pro", "def", "orm", "ty", "Dom", "deep", "virt", "des", "ver", "session", "mon", "admin", "cmd", "doms", "depth", "window", "dr", "mode", "iam", "dir", "cd", "dm", "deg", "height", "du", "len", "loc", "domain", "util", "rank", "DOM", "lang", "dist", "num", "dim", "dem", "im", "om", "db", "img", "debug", "coord", "rom", "id", "root", "host", "valid", "d", "form", "prom", "mn", "driver", "tech"], "dev": ["pro", "def", "stable", "des", "mem", "DEV", "oy", "conn", "alloc", "ver", "data", "size", "cmd", "mode", "attr", "depth", "lib", "Dev", "raw", "val", "v", "len", "loc", "den", "priv", "util", "buf", "end", "dist", "nt", "desc", "off", "dem", "info", "db", "od", "debug", "wd", "device", "id", "cho", "adv", "serial", "ach", "develop", "conf", "app", "var", "pad", "d", "eng", "ve", "prop", "ev", "iv", "w", "normal", "name", "av", " Dev", "ch", "tech"], "ops": ["Ops", "types", "OPS", "settings", "opens", "bs", "obs", "tags", "utils", "outs", "flags", "values", "bits", "params", "keys", "opt", "oper", "eps", "ups", "xs", "abilities", "fields", "als", "opers", "wcs", "apps", "ds", "checks", "op", "orders", "tops", "rots", "aps", "items", "arts", "tools", "services", "orts", "vals", "ips", "ts", "ands", "hops", "stats", "caps", "vs", "ns", "cs", "args", "changes", "oops", "os", "asts", "its", "options", "sets", "actions", "rs", "ps"], "xendev": ["zenderee", "xsenddev", "oxendew", "wxendsserv", "xeastov", "xbeginer", " xbeginech", "zendem", "xsendec", "xENDel", "exentek", "oxenderv", "xendedew", "txendell", "exendek", "zendee", "nexendererer", "expendev", "xenderoc", "exaddel", "xendeev", "xendeoc", "xstoperv", "xentapter", "xENDev", "wenddev", "wbeginog", "xendiver", "rxendev", "exendec", "xendedell", "xenderell", "oxengec", "xidek", "eyenteriver", "xstopev", "xiderv", "xenderef", " xendrec", "xider", "xinitever", "xenderval", "nexenderer", "xendapter", " xadderv", "oxendedev", " xendserv", " xaddel", "xendedex", "xsenderer", "xentog", "xfenderov", "zendev", "exendev", "expendep", "zendedep", "xendedel", "xbeginov", "xengav", "xtbeginev", "xandev", "xenterew", "xendedec", "xbegindev", "Xendedev", "oxendever", "exendserv", " xendel", "xendedek", "lexendeddev", " xbeginev", "eyendever", "xbeginech", "expendererv", "xndem", "xenterev", "xexcepterer", "yentdev", "xndiver", "xndek", "xendseg", "yentev", "wendect", "Xenderv", "xendedeg", "xenterec", "xenteriver", "xidedev", "xenddev", "eyendev", "yentserv", "Xendederv", "rxenderel", " xbeginserv", "xinitep", "xendval", "xendedapter", "xentserv", "xendiv", "xenterv", "xendsov", "oxendedec", "xendsev", "rxenditem", "xtbeginerv", "wendiv", "xentev", "wbeginiv", "xexceptev", "xentrec", "xendem", "lexendederv", "xendeder", "wxentev", "xendog", "xfendov", "yenderv", "eyendiver", "rxendedov", "zenderiv", "xbeginserv", " xenter", "xendedep", "xadditem", "lexenddev", "zenderell", "xenderev", "xiniterv", "xentech", "xaddserv", " xentev", "rxenderev", "wxendapter", "oxendef", "xenderov", "wxenterv", "xandell", "xenderiver", "xenderect", "wendedev", "xendew", "lexendedek", "xbeginee", "oxenddev", "zenderev", "oxendedew", "oxendeddev", "xenderex", "xendever", "oxentev", "exenderv", "rxendel", "xadderv", "rxendeddev", "wxendedeg", "exadddev", "exaddever", "xandov", "xenderec", "wenderv", "nexendiver", " xendech", "xengem", "txendev", "xendererer", "oxendov", "exaddev", " xadddev", "xendsiver", "xendrec", "rxendov", "oxentov", "xbeginog", "exentec", "lexendedev", "xexcepteg", "zendedev", "xentep", "rxendedev", "txendov", "expenderever", "zendval", "wxendev", "xendav", "xbeginever", "xaddem", "xENDell", "xendsv", "exentel", "xtenderv", "xendell", "xexceptever", "xendek", "xentever", "xtbeginer", "expenderev", "xaddever", "xendoc", "oxendav", "rxendedoc", "xanddev", "xenderem", "lexenderv", "xbeginiv", "xendel", "xideeg", "rxendserv", "Xendell", "xenderever", "expenderep", "xeastiver", "xendex", "xeastev", " xaddev", "oxengew", "exenterv", "xndov", "xenderep", "txendedov", "oxengav", "exendov", "rxendoc", "xendeditem", "wxendeg", "xentererer", "xsendev", " xaddrec", "xidev", "xentov", "xaddov", "xenev", "xbeginoc", "xexcepterv", " xbeginel", "rxenderserv", "xtbeginoc", "yenddev", "zendedval", "exadderv", " xendem", "nexendereg", "xfenderev", "xfendiver", "xendedect", "xaddoc", "xendect", "xendedever", "xfendec", "xbeginell", "xtendev", "zendell", "xendedem", "xendeg", "rxenderech", "xenderog", "xenter", "rxenddev", "xendedserv", "nexendev", "zendep", "oxentdev", "zendedem", "xfenderiver", "eyentererer", " xaddem", "xnddev", "xexceptv", "xaddrec", "xtendoc", "xendee", "eyenterev", "xENDov", "xengval", "xenderew", "xenderech", "txendedev", "wendov", "xendef", "xfenderec", "xinitev", "xaddel", "Xendek", "wendedov", "xendedov", "xandek", "wxendseg", "xanderv", "xendsserv", "xadddev", "oxenterv", "xenderiv", "Xendev", "xbeginev", "rxendediver", "txendex", "xentek", "xendeitem", "wxendeddev", "xentell", "oxexceptov", "eyenterever", "rxendeditem", "xenditem", "eyenderer", "oxexceptever", "xexceptserv", "yenterv", "wendeddev", " xender", "xendedoc", "xenderdev", "wbeginev", "xideever", "xendedee", "oxengev", "xideev", "rxendech", "oxendec", "xenek", "xendserv", "nexenderev", "wxentew", "rxendiver", "wbeginerv", "exentserv", "xndev", "xendedev", "xenderer", "xndever", "xengec", "xenderav", "xnderv", "xfendev", "xendedech", "xengev", "exendel", "xentiv", "wxenddev", "xendederv", "wxendsev", "xbeginef", "wendedect", "xexceptov", "zendiv", "xentec", "xendsel", "xandel", "txendedex", "wendog", "yendev", "wxenderv", "wxentapter", "wxendsv", "xendep", "Xendedell", "wxendedev", "oxexceptef", "xstopdev", "wxendv", "xndeg", "xenterav", "nexendeg", "expenderv", "xstopem", "xexceptef", "wxendew", "xendov", "xiddev", "exenddev", "xenderel", "xendeddev", "xentel", "xaddev", "xenterever", "xendediver", " xenderv", " xenterv", "wxendever", "xendech", "oxendev", "xenderee", "xENDrec", "xtender", "oxexceptev", "xbeginerv", "xeastdev", "wendev", "xengep", "xsendeg", "xender", "nexenderiver", "xendec", "exentdev", "Xendedek", "exendever", "xENDex", "xndserv", "xendsec", "lexendek", "xentdev", "lexendev", "xentew", "xexceptiver", "xbeginel", "xenderserv", "xenderv", "exaddov", "xendeserv", "xENDerv", "yendserv", "xengew", "xendedval", "xsendew", "xenerv", "xendv", " xenddev", "exentev", "xendereg", "xendediv", "rxendedserv", "xsendiver", "wxendedever", " xentdev", "xendererv", "wxendserv", "expendever", "xenderapter", "txendedell"]}}
{"project": "qemu", "commit_id": "c54616608af442edf4cfb7397a1909c2653efba0", "target": 0, "func": "static void json_message_process_token(JSONLexer *lexer, QString *token, JSONTokenType type, int x, int y)\n\n{\n\n    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);\n\n    QDict *dict;\n\n\n\n    if (type == JSON_OPERATOR) {\n\n        switch (qstring_get_str(token)[0]) {\n\n        case '{':\n\n            parser->brace_count++;\n\n            break;\n\n        case '}':\n\n            parser->brace_count--;\n\n            break;\n\n        case '[':\n\n            parser->bracket_count++;\n\n            break;\n\n        case ']':\n\n            parser->bracket_count--;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n\n\n    dict = qdict_new();\n\n    qdict_put(dict, \"type\", qint_from_int(type));\n\n    QINCREF(token);\n\n    qdict_put(dict, \"token\", token);\n\n    qdict_put(dict, \"x\", qint_from_int(x));\n\n    qdict_put(dict, \"y\", qint_from_int(y));\n\n\n\n    parser->token_size += token->length;\n\n\n\n    qlist_append(parser->tokens, dict);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               parser->bracket_count + parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit_bad;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /*\n\n     * Clear out token list and tell the parser to emit an error\n\n     * indication by passing it a NULL list\n\n     */\n\n    QDECREF(parser->tokens);\n\n    parser->tokens = NULL;\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    parser->emit(parser, parser->tokens);\n\n    if (parser->tokens) {\n\n        QDECREF(parser->tokens);\n\n    }\n\n    parser->tokens = qlist_new();\n\n    parser->token_size = 0;\n\n}\n", "idx": 15457, "substitutes": {"lexer": [" lexener", "scane", "callaer", "scanener", "come", "mailer", "uploaditer", " lexp", "uploadener", "lexaer", " lexaer", "lexe", "comer", "maile", "lexter", "uploade", "scaner", "comener", "ntaxp", "lexp", "uploader", "mailener", "ntaxer", "caller", "calle", "lexener", " lexiter", "comter", "callp", "ntaxaer", " lexe", "mailiter", "ntaxe", "scanter", " lexter", "lexiter"], "token": ["node", "column", "key", "error", "number", "local", "translation", "header", "data", "ok", "p", "kt", "raw", "operator", "rule", "trigger", "text", "statement", "field", "t", "initial", "oken", "KEN", "Token", "wt", "language", "len", "tn", "now", "item", "tree", "k", "tag", "context", "message", "word", "json", "attribute", "prefix", "parse", "buffer", "variable", "tool", "event", "single", "null", "trans", "table", "start", "pair", "piece", "length", "list", "character", "element", "format", "target", "value", "name", "txt", "template", "normal", "atom"], "type": ["status", "key", "types", "index", "error", "ty", "Type", "at", "by", "ver", "size", "choice", "class", "role", "otype", "typ", "rule", "test", "port", "t", "ping", "kind", "title", "new", "op", "part", "message", "s", "time", "info", "TYPE", "file", "pos", "code", "top", "no", "color", "start", "action", "ype", "id", "set", "state", "length", "tp", "style", "format", "name", "pe"], "x": ["tx", "index", "xes", "wx", "ax", "l", "p", "ex", "X", "xs", "xy", "t", "ox", "xp", "loc", "fx", "ux", "xi", " dx", " i", "dx", " cx", "xc", "pos", "lex", "xx", "on", "px", "xf", "xa", "rx", "i", " xx", "xt", "mx", "ix"], "y": ["yy", "ly", "by", "yt", "oy", "ty", "asy", "py", "ny", "ys", "sy", "axy", "Y", "ya", "xy", "ay", "t", "ym", "ery", "ye", "cy", "vy", "iy", "ies", "sim", "ady", " ty", "yer", " py", "b", "hot", "year", "my", "sky", "yo", "gy", "ey", "i", "ic", "fy", "ch"], "parser": ["machine", "manager", "loader", "older", "class", "storage", "operator", "raw", "consumer", "layer", "pool", "processing", "engine", "policy", "book", "processor", "program", "command", "timer", "context", "parent", "document", "function", "client", "oder", "upper", "filter", "view", "metadata", "peer", "number", "callback", "params", "conv", "http", "test", "iterator", "job", "part", "definition", "self", "bird", "volume", "upload", "student", "table", "production", "Parser", "parts", "tp", "jack", "kernel", "node", "server", "plant", "ner", "this", "proc", "store", "er", "now", "scan", "disk", "json", "player", "reader", "buffer", "remote", "file", "lex", "unknown", "adder", "inner", "plugin", "state", "language", "package", "process", "driver", "instance", "wrapper", "local", "finder", "p", "rule", "arser", "builder", "func", "tree", "connection", "tag", "message", "writer", "magic", "runner", "parse", "handler", "chart", "bank", "yer", "rer", "master", "action", "format", "can", "worker"], "dict": ["key", "def", "td", "ict", "metadata", "local", "det", "cond", "ind", "data", "map", "back", "cmd", "build", "window", "D", "dl", "dir", "cd", "direct", "pd", "details", "md", "nd", "di", "func", "ds", "ct", "da", "nt", "dd", "ud", "obj", "doc", "bd", "add", "hd", "db", "dot", "bind", "df", "debug", "client", "table", "wd", "tmp", "draw", "ad", "pair", "conf", "defined", "con", "hash", "list", "d", "dh", "dat", "pkg", "ld", "inf", "sum"], "brace_count": ["scope_chain", "scope_count", "bridge_cycle", "track_count", "braceetymax", "brace_chain", "brace67score", "case_limit", "bracelemust", "bone_must", "braceetysuccess", "braceleamount", "bracefullimit", "brace_limit", "brace_const", "caseablelimit", "bridge_cache", "braceetycount", "braceablelimit", "brace_must", "brace67limit", "brace64const", "brace_Count", "brace9count", "bone_coll", "brace_max", "track_const", "trace_status", "braceablescore", "case_count", "brace_coll", "case_hash", "braceablecount", "brace_score", "bracelecount", "bracefulCount", "track_amount", "trace_success", "scopelecount", "brace_status", "brace9weight", "brace_cycle", "bracefulcount", "bracefulhash", "braceablehash", "braceetystatus", "brace_cache", "bracelecoll", "trace_max", "bone_count", "case_score", "brace9const", "brace_success", "trace_count", "track_weight", "bridge_Count", "brace_weight", "brace_hash", "caseablecount", "scopeleamount", "bracelechain", "bracefulcycle", "brace67hash", "brace64amount", "bone_amount", "brace64weight", "bracefulcache", "brace67count", "bridge_count", "bracefulscore", "caseablescore", "brace_amount", "brace9amount", "brace64count", "scope_amount", "scopelechain", "caseablehash"], "bracket_count": ["brackets_counter", "bracket64c", "brack_num", "branch_limit", "branch_Count", "bracket_code", "bracket64total", "brack_count", "bracket_num", "bracket_cache", "bracketetycount", "brackets_left", "bracket64comment", "brackets_cache", "bracket_left", "brwall_carry", "bracket_counter", "bracket2left", "bracket_comment", "bracketetyCount", "bracket2count", "branch_count", "brack_Count", "bracket_carry", "bracket_state", "branch_state", "brwall_count", "bracket_total", "bracketetynum", "bracket_Count", "brack_code", "brackets_Count", "brwall_Count", "bracket64Count", "brackets_count", "brackets_comment", "bracket64count", "bracketetycode", "bracket2counter", "bracket_c", "bracket64cache", "brwall_limit", "bracket_limit"]}}
{"project": "qemu", "commit_id": "076b35b5a56bca57c4aa41044ed304fe9c45d6c5", "target": 0, "func": "static void set_memory_options(uint64_t *ram_slots, ram_addr_t *maxram_size)\n\n{\n\n    uint64_t sz;\n\n    const char *mem_str;\n\n    const char *maxmem_str, *slots_str;\n\n    const ram_addr_t default_ram_size = (ram_addr_t)DEFAULT_RAM_SIZE *\n\n                                        1024 * 1024;\n\n    QemuOpts *opts = qemu_find_opts_singleton(\"memory\");\n\n\n\n    sz = 0;\n\n    mem_str = qemu_opt_get(opts, \"size\");\n\n    if (mem_str) {\n\n        if (!*mem_str) {\n\n            error_report(\"missing 'size' option value\");\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        sz = qemu_opt_get_size(opts, \"size\", ram_size);\n\n\n\n        /* Fix up legacy suffix-less format */\n\n        if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) {\n\n            uint64_t overflow_check = sz;\n\n\n\n            sz <<= 20;\n\n            if ((sz >> 20) != overflow_check) {\n\n                error_report(\"too large 'size' option value\");\n\n                exit(EXIT_FAILURE);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* backward compatibility behaviour for case \"-m 0\" */\n\n    if (sz == 0) {\n\n        sz = default_ram_size;\n\n    }\n\n\n\n    sz = QEMU_ALIGN_UP(sz, 8192);\n\n    ram_size = sz;\n\n    if (ram_size != sz) {\n\n        error_report(\"ram size too large\");\n\n        exit(EXIT_FAILURE);\n\n    }\n\n\n\n    /* store value for the future use */\n\n    qemu_opt_set_number(opts, \"size\", ram_size, &error_abort);\n\n    *maxram_size = ram_size;\n\n\n\n    maxmem_str = qemu_opt_get(opts, \"maxmem\");\n\n    slots_str = qemu_opt_get(opts, \"slots\");\n\n    if (maxmem_str && slots_str) {\n\n        uint64_t slots;\n\n\n\n        sz = qemu_opt_get_size(opts, \"maxmem\", 0);\n\n        slots = qemu_opt_get_number(opts, \"slots\", 0);\n\n        if (sz < ram_size) {\n\n            error_report(\"invalid value of -m option maxmem: \"\n\n                         \"maximum memory size (0x%\" PRIx64 \") must be at least \"\n\n                         \"the initial memory size (0x\" RAM_ADDR_FMT \")\",\n\n                         sz, ram_size);\n\n            exit(EXIT_FAILURE);\n\n        } else if (sz > ram_size) {\n\n            if (!slots) {\n\n                error_report(\"invalid value of -m option: maxmem was \"\n\n                             \"specified, but no hotplug slots were specified\");\n\n                exit(EXIT_FAILURE);\n\n            }\n\n        } else if (slots) {\n\n            error_report(\"invalid value of -m option maxmem: \"\n\n                         \"memory slots were specified but maximum memory size \"\n\n                         \"(0x%\" PRIx64 \") is equal to the initial memory size \"\n\n                         \"(0x\" RAM_ADDR_FMT \")\", sz, ram_size);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        *maxram_size = sz;\n\n        *ram_slots = slots;\n\n    } else if ((!maxmem_str && slots_str) ||\n\n            (maxmem_str && !slots_str)) {\n\n        error_report(\"invalid -m option value: missing \"\n\n                \"'%s' option\", slots_str ? \"maxmem\" : \"slots\");\n\n        exit(EXIT_FAILURE);\n\n    }\n\n}\n", "idx": 15482, "substitutes": {"ram_slots": ["ram_blot", "ram_plots", "ram_plores", "ram_slot", "ram_lots", "ram_blobs", "ram_lobs", "ram_lot", "ram_blots", "ram_slores", "ram_slobs", "ram_plobs", "ram_lores", "ram_blores", "ram_plot"], "maxram_size": ["maxgram_name", "maxgram_mode", "maxram_mode", "maxramaxysize", "maxram_name", "maxgram_SIZE", "maxramaxyname", "maxgram_size", "maxramaxySIZE", "maxgram_width", "maxram_width", "maxram_SIZE", "maxramaxywidth"], "sz": ["bytesz", "Size", "Sze", "insz", "siz", "geszer", "inszi", "tsZ", "insize", "gesz", "rszi", "ssz", "osnz", "tsiz", " sze", "imsz", "jsze", " sld", "insiz", "jsz", "imszer", "sld", "szer", "geszi", " szi", "gesnz", "sZ", "sszi", "imsld", "snz", "Szer", "insZ", "ssZ", "gesize", "Siz", "bytesiz", "szi", "osiz", "rsz", "insld", "oszi", "Szi", "ssze", "pszi", "Sz", "ssld", "sze", " sZ", "hasiz", "imsze", "imsiz", "SZ", "bytesze", "tszi", "psiz", "size", "Sld", "haszi", "jszi", "jsiz", "rsiz", "rsnz", " szer", "psz", "haszer", "hasz", "osz", "imszi", "tsz", "jsZ", "insze", "ssiz", "byteszi", "gesiz", "psze", " siz"], "mem_str": ["mem_Str", " mem_format", " mem_dat", "mem_dr", " mem_ctr", "memogstring", "mem_dat", "mem_stri", "mem_br", "mem2str", "mem_buf", "memaxybuf", "mem_format", "mem2dr", "memaxystri", "mem2string", "mem_ctr", "memogctr", " mem_stri", " mem_buf", "memogstr", " mem_arr", "mem_string", " mem_string", "memogStr", " mem_dr", "memaxystr", " mem_br", "mem_arr", " mem_Str", "memaxydr", "mem2arr"], "maxmem_str": ["maxgramaxydr", "maxgram_stick", "maxgram_str", "maxgramaxystick", "maxmemory_rs", "maxmemory_dr", "maxmemory_br", "maxmem_stick", "maxgramaxystr", "maxgram_string", "maxmem_dr", "maxgramaxystring", "maxmemaxystick", "maxmem_rs", "maxmem_string", "maxgram_dr", "maxmem___string", "maxmemory_string", "maxmem___br", "maxmem___str", "maxmemaxydr", "maxmem_br", "maxmemaxystring", "maxmemaxystr", "maxmemory_str", "maxmem___rs"], "slots_str": ["slops_dr", "slots_list", "slots_arr", "slops_strings", "slops_str", "slores_string", "slores_arr", "slots_STR", "slops_string", "slots_string", "slores_br", "slores_list", "slots_strings", "slores_STR", "slots_br", "slores_str", "slots_dr"], "opts": ["optouts", " opters", "experters", "operts", "iopTS", "copts", "copTS", " coptes", " oputs", "optfs", "Options", " opents", "okfs", "prots", "oktions", "okTS", "oputs", " optents", " opss", "opns", "operTS", " oprs", "prors", "opss", "Opts", "popcs", " opns", "popts", "copfs", "popsts", " coptions", "optTS", " opfs", "oplets", "operks", "OpTS", "opfs", " optorts", " copks", "iopks", "iopcs", "iopsts", "optrs", "opttions", "oprs", " copts", "optes", "attents", "popTS", "opcs", "copsts", "opters", "opouts", "ioplets", "experss", " options", " optes", " opouts", "optters", "attts", "copouts", "optss", " oports", "attorts", "options", "optts", "proTS", "optns", " copTS", "experts", "Opfs", "opsts", " coplets", "opTS", "experTS", "operlets", "opents", "okts", " optcs", "copns", "iopts", " opTS", "attcs", "opks", " opcs", "opttes", " copters", "oports", "copcs", "prouts", "optuts", " optts"], "slots": ["plotted", " slugs", "slashes", "kliders", "islots", "plbs", "islashes", "liders", "slbs", "klows", " slows", "lots", "klugs", "islotted", "plashes", "plots", "slows", "slugs", " sliders", "sliders", "blashes", "blotted", "lugs", "blbs", "islbs", "klots", "blots", "slotted", "lows"]}}
{"project": "qemu", "commit_id": "b9f7855a50a7cbf04454fa84e9d1f333151f2259", "target": 0, "func": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    /* We don't actually refresh here, but just return data queried in\n\n     * iscsi_open(): iscsi targets don't change their limits. */\n\n\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;\n\n\n\n    bs->request_alignment = iscsilun->block_size;\n\n\n\n    if (iscsilun->bl.max_xfer_len) {\n\n        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);\n\n    }\n\n\n\n    if (max_xfer_len * iscsilun->block_size < INT_MAX) {\n\n        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->lbp.lbpu) {\n\n        if (iscsilun->bl.max_unmap < 0xffffffff) {\n\n            bs->bl.max_discard =\n\n                sector_limits_lun2qemu(iscsilun->bl.max_unmap, iscsilun);\n\n        }\n\n        bs->bl.discard_alignment =\n\n            sector_limits_lun2qemu(iscsilun->bl.opt_unmap_gran, iscsilun);\n\n    } else {\n\n        bs->bl.discard_alignment = iscsilun->block_size >> BDRV_SECTOR_BITS;\n\n    }\n\n\n\n    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {\n\n        bs->bl.max_pwrite_zeroes =\n\n            iscsilun->bl.max_ws_len * iscsilun->block_size;\n\n    }\n\n    if (iscsilun->lbp.lbpws) {\n\n        bs->bl.pwrite_zeroes_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;\n\n    }\n\n    if (iscsilun->bl.opt_xfer_len &&\n\n        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {\n\n        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *\n\n                                        iscsilun->block_size);\n\n    }\n\n}\n", "idx": 15486, "substitutes": {"bs": ["irms", "ubis", "gs", "ubs", "aos", "obs", "ib", "banks", "ports", "pb", "hz", "js", "bits", "eb", "bh", "css", "bi", "bes", "zb", "sb", "bt", "aus", "hs", "cks", "ds", "ls", "ats", "bn", "bd", "BS", "bsp", "vals", "qs", "ts", "bos", "bm", "acs", "stats", "boxes", "blog", "vs", "ins", "b", "bl", "cs", "bc", "lbs", "ns", "bles", "fs", "bps", "bis", "its", "bb", "bp", "bg", "ss", "sts", "ps"], "errp": ["erP", "lerpb", "erp", "lerP", "Erp", "errpb", "ErP", "Erpb", "lerp", "erpb", "errP"], "iscsilun": ["uscsilunk", "iscchloru", "icsilmun", "uscsinu", "iscsuccessfulune", "ischslmun", "ascsiluna", "internationalsucon", "iscosilmun", "iscsnunt", "iscgilut", "iscsuou", "miscsilut", "iscitisun", "iscsilu", "uscsilmun", "iscillunt", "ascchlorun", "isecesiunt", "iscsloul", "iscillun", "isctilur", "isckillun", "rissevereund", "iscosilgun", "internationalsilun", "iscsidu", "isecineluna", "iscilune", "iscsinunk", "isclituna", "iscsevereund", "miscsilun", "iscmilout", "iscselung", "icsevereunt", "iscesiuna", "iscsevereunt", "iscinelune", "sicmilunt", "isclitmun", "miscsilmun", "uscsinuna", "iscsnmun", "iscryptun", "iscsinune", "rissilund", "iscineluna", "uscsilan", "sicsilmun", "iscsilum", "internationalsilcon", "iscsentund", "iscsilur", "usercsiloul", "rissilu", "uscsingun", "iscsilgun", "iscryptune", "sicsilunt", "iscslmun", "iscriticalut", "iscsnuna", "iscsilan", "iscmilon", "ionicspelluna", "iscittenune", "iscSilout", "iscinelcon", "iscsilout", "iscesiune", "iscesiund", "uscsiluna", "iscgilur", "isculenceund", "iscsinunt", "iscseluna", "iscsslun", "isculentmun", "misckillun", "usercsentuna", "iscsilut", "iscinelmun", "nickillan", "iscslund", "miscsilune", "miscinelun", "iscsidun", "misckillmun", "isecesiuna", "isckillut", "nicsidun", "uscsilune", "iscinelunk", "iscspellund", "usercsiluna", "iscselund", "iscryptu", "iscsentunk", "iscsentmun", "sicsiluna", "isculentuna", "iscsolUN", "nicsiluna", "iscsolunt", "iscsilon", "iscittengun", "iscmilunc", "iscsentunc", "iscseveremun", "iscsentgun", "iscsucon", "miscsiluna", "nicsilgun", "ionicspellun", "isckillunc", "iscinelund", "descgilune", "iscurityune", "uscsilur", "isculenceun", "nicsidune", "rissilum", "iscsentut", "sicmiluna", "iscmilune", "nickillun", "isclitunt", "isculenceuna", "iscsuccessfuluna", "isculentunt", "isckillmun", "iscsolune", "iscesiun", "descsiluna", "iscilunt", "uscsilund", "miscsilum", "iscspelluna", "iscosenton", "iscslut", "iscsinan", "iscinelun", "iscgilan", "iscsolgun", "uscsilung", "iscsinun", "iscosilun", "iscsuccessfulund", "iscvaleunk", "iscesigun", "iscosentun", "isecsiluna", "iscsentoul", "miscsilund", "rissevereum", "uscsilunc", "iscsilou", "icsiluna", "iscgilmun", "ascsilunt", "miscsentunk", "iscsentout", "iscsuccessfulun", "iscvaleun", "ischsilut", "iscinelum", "iscryptuna", "descgilun", "iscvaleunt", "ascsilgun", "iscosilon", "iscsevereu", "ischslun", "nickillunc", "iscosilut", "iscidentgun", "icsevereuna", "isctilgun", "iscsilmun", "iscurityun", "iscsevereuna", "isecsilune", "iscsoluna", "iscpixelun", "iscSilgun", "iscsevereum", "sicmilmun", "iscsinUN", "icsevereun", "isecesiune", "iscitisune", "iscsilune", "icseveremun", "iscgilune", "ionicsilund", "icsilunt", "iscsentunt", "iscesiunt", "iscsolun", "descsilunc", "iscryptgun", "descsilun", "uscsinunt", "iscmilun", "iscsnun", "iscsidune", "iscgilunc", "nicsidunc", "iscspellun", "isckillum", "ascsilun", "iscsiluna", "iscsilunt", "iscosentut", "isecesiun", "uscvaleun", "iscsslunc", "iscitismun", "iscittenun", "iscmilmun", "isculenceoul", "iscsidunc", "iscsevereut", "internationalsuou", "ionicspellund", "iscsuund", "isecinelun", "iscsilcon", "iscmilunt", "isecsilunt", "iscmilan", "uscvaleunk", "iscsinmun", "iscpixelund", "iscsslund", "ischsilmun", "miscsentune", "internationalsuun", "iscosilu", "iscidentunt", "miscinelune", "iscosentu", "iscchlorun", "uscsilu", "iscinelut", "usercsilund", "iscsinu", "iscSilun", "ionicsiluna", "iscurityung", "iscsslune", "iscillut", "iscchlorgun", "iscsinur", "miscsilunk", "uscsinund", "iscidentun", "uscsinmun", "uscsilgun", "ischslunt", "uscsinUN", "iscslunt", "descgilunc", "iscsluna", "isecsilu", "isckillan", "ionicsilun", "descsilune", "uscsilunt", "internationalsilou", "iscchlorund", "iscvaleune", "isctilunt", "iscspellune", "ionicspellune", "uscsinan", "isctilun", "iscinelu", "icsilun", "isclitun", "iscriticalun", "iscchloruna", "isecsilun", "uscsinung", "rissilun", "iscsinung", "iscselun", "iscsentune", "iscsilUN", "ascchlorgun", "isecinelu", "iscsenton", "internationalsilund", "iscilun", "miscsilan", "iscsentuna", "iscmiluna", "iscseverecon", "sicmilun", "uscsinune", "ascchlorunt", "iscsolunc", "uscsinun", "iscchlorunt", "nicsilun", "ischslut", "iscsidund", "isckillgun", "usercsilun", "iscsinuna", "miscinelund", "ischsilun", "iscsilunk", "iscosentgun", "iscryptunt", "iscitisu", "iscsilung", "isculentun", "uscsilUN", "iscinelou", "uscsilun", "misckillut", "usercsentoul", "usercsentund", "isecsilund", "iscosilout", "iscsuun", "nicsilunc", "uscvaleunt", "rissevereu", "iscselune", "ischsilunt", "iscinelan", "iscslun", "iscSilon", "ascchloruna", "sicsilun", "iscsilunc", "iscsentu", "iscinelunt", "iscsingun", "iscsolunk", "iscidentUN", "isecinelund", "iscosentmun", "descgiluna", "iscryptmun", "nicsilan", "nicsiduna", "iscsentan", "internationalsuund", "iscsiduna", "iscsevereun", "iscriticalum", "iscsilund", "miscsentun", "uscvaleune", "iscsevereou", "nicsilune", "iscpixeluna", "iscgilu", "rissevereun", "miscineluna", "iscgiluna", "iscsinund", "misckillum", "miscsentan", "ionicsilune", "iscselunt", "uscsinur", "iscsentun", "iscsiloul", "iscosentout", "iscilunk", "iscriticalmun", "iscmilgun", "iscittenund", "uscsinunc", "isctilan", "iscsentum", "iscpixelune", "iscgilun", "iscillmun", "iscurityunt", "iscsinunc", "isctiluna", "usercsentun", "nickillgun"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)\n\n{\n\n    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);\n\n}\n", "idx": 15492, "substitutes": {"env": ["server", "nv", "param", "conn", "environment", "dn", "ctx", "window", "ee", "v", "project", "esc", "sb", "er", "stack", "end", "buf", "ef", "rb", "ah", "context", "shell", "buffer", "cb", "cv", "db", "en", "nc", "code", "ec", "ped", "bind", "ov", "dev", "e", "conf", "entry", "config", "uv", "ve", "ev", "iv", "te", "viron"], "m": ["mem", "cm", "mi", "l", "j", "km", "n", "p", "managed", "module", "man", "perm", "v", "dm", "wm", "g", "t", "sm", "mac", "msg", "em", "menu", "vm", "mu", "c", "mm", "om", "b", "mc", "gm", "mt", "e", "M", "d", "tm", "i", "nm", "ms"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void ide_atapi_cmd(IDEState *s)\n\n{\n\n    uint8_t *buf;\n\n\n\n    buf = s->io_buffer;\n\n#ifdef DEBUG_IDE_ATAPI\n\n    {\n\n        int i;\n\n        printf(\"ATAPI limit=0x%x packet:\", s->lcyl | (s->hcyl << 8));\n\n        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {\n\n            printf(\" %02x\", buf[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n    /*\n\n     * If there's a UNIT_ATTENTION condition pending, only command flagged with\n\n     * ALLOW_UA are allowed to complete. with other commands getting a CHECK\n\n     * condition response unless a higher priority status, defined by the drive\n\n     * here, is pending.\n\n     */\n\n    if (s->sense_key == UNIT_ATTENTION &&\n\n        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {\n\n        ide_atapi_cmd_check_status(s);\n\n        return;\n\n    }\n\n    /*\n\n     * When a CD gets changed, we have to report an ejected state and\n\n     * then a loaded state to guests so that they detect tray\n\n     * open/close and media change events.  Guests that do not use\n\n     * GET_EVENT_STATUS_NOTIFICATION to detect such tray open/close\n\n     * states rely on this behavior.\n\n     */\n\n    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&\n\n        !s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {\n\n\n\n        if (s->cdrom_changed == 1) {\n\n            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n            s->cdrom_changed = 2;\n\n        } else {\n\n            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);\n\n            s->cdrom_changed = 0;\n\n        }\n\n\n\n        return;\n\n    }\n\n\n\n    /* Report a Not Ready condition if appropriate for the command */\n\n    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&\n\n        (!media_present(s) || !bdrv_is_inserted(s->bs)))\n\n    {\n\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n        return;\n\n    }\n\n\n\n    /* Execute the command */\n\n    if (atapi_cmd_table[s->io_buffer[0]].handler) {\n\n        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);\n\n        return;\n\n    }\n\n\n\n    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);\n\n}\n", "idx": 15495, "substitutes": {"s": ["sis", "ses", "errors", "gs", "S", "bs", "ties", "sq", "sl", "t", "m", "qs", "stats", "vs", "states", "cs", "ims", "aunts", "its", "https", "terms", "ps", "esm", "sw", "j", "n", "js", "params", "v", "g", "http", "simple", "comm", "spec", "ds", "ats", "services", "ies", "self", "args", "conf", "ains", "results", "a", "as", "less", "asm", "bits", "source", "als", "sb", "er", "hs", "sys", "times", "c", "ops", "es", "events", "fs", "changes", "bis", "se", "sports", "ss", "comments", "aws", "has", "p", "details", "is", "sv", "ls", "r", "gets", "ts", "ins", "ns", "b", "h", "os", "z", "w", "sts", "ms", "y", "rs"], "buf": ["bar", "Buff", "bytes", "vec", "mem", "ref", "orig", "rw", "cur", "ff", "seq", "map", "pb", "cmd", "wb", "p", "ctx", "tr", "Buffer", "proc", "conv", "v", "pool", "batch", "len", "BU", "cache", "buff", "cap", "rb", "br", "cam", "bag", "fb", "buffer", "cb", "cv", "img", "uffy", "b", "bc", "h", "tmp", "uf", "err", "queue", "pkg", "w", "cast", "txt", "pay", "pack"], "i": ["index", "li", "a", "o", "iu", "oi", "mi", " j", "I", "pi", "ii", "ini", "j", "l", "n", "p", "ki", "ei", "si", "zi", " ti", "cli", "bi", "io", "t", "ui", "is", "di", "ami", "PI", "ai", "m", "in", " I", "hi", "xi", "qi", " bi", "sim", "im", "\u0438", " multi", "ci", " v", "client", "ti", "point", "u", "my", "list", "multi", "it", "gi", "length", " m", "me", "MI", "phi", "init", "x", "ms", "y", "span", "ix", "ip"]}}
{"project": "FFmpeg", "commit_id": "d208d1eba3799c58fd6d3602d31de3e686f14aec", "target": 1, "func": "void ff_hevc_luma_mv_merge_mode(HEVCContext *s, int x0, int y0, int nPbW,\n\n                                int nPbH, int log2_cb_size, int part_idx,\n\n                                int merge_idx, MvField *mv)\n\n{\n\n    int singleMCLFlag = 0;\n\n    int nCS = 1 << log2_cb_size;\n\n    LOCAL_ALIGNED(4, MvField, mergecand_list, [MRG_MAX_NUM_CANDS]);\n\n    int nPbW2 = nPbW;\n\n    int nPbH2 = nPbH;\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n\n\n    memset(mergecand_list, 0, MRG_MAX_NUM_CANDS * sizeof(*mergecand_list));\n\n\n\n    if (s->pps->log2_parallel_merge_level > 2 && nCS == 8) {\n\n        singleMCLFlag = 1;\n\n        x0            = lc->cu.x;\n\n        y0            = lc->cu.y;\n\n        nPbW          = nCS;\n\n        nPbH          = nCS;\n\n        part_idx      = 0;\n\n    }\n\n\n\n    ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);\n\n    derive_spatial_merge_candidates(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                                    singleMCLFlag, part_idx,\n\n                                    merge_idx, mergecand_list);\n\n\n\n    if (mergecand_list[merge_idx].pred_flag[0] == 1 &&\n\n        mergecand_list[merge_idx].pred_flag[1] == 1 &&\n\n        (nPbW2 + nPbH2) == 12) {\n\n        mergecand_list[merge_idx].ref_idx[1]   = -1;\n\n        mergecand_list[merge_idx].pred_flag[1] = 0;\n\n    }\n\n\n\n    *mv = mergecand_list[merge_idx];\n\n}\n", "idx": 15515, "substitutes": {"s": ["gs", "a", "S", "f", "o", "bs", "l", "j", "n", "js", "p", "v", "cli", "g", "t", "is", "sb", "sv", "aus", "sys", "ds", "ls", "m", "r", "acs", "sc", "c", "ns", "b", "cs", "h", "ims", "es", "e", "fs", "sg", "os", "its", "sn", "w", "ss", "sts", "i", "rs", "ps"], "x0": ["ox3", "tx10", "xml0", "X1", "x7", "xx0", "xfe", "oxfe", "xZero", " x1", "ox2", "xml14", "tx5", "ix3", "X2", " xZero", " x2", "ix2", "ex1", "ox7", " x14", "x14", "x5", "xxZero", "xx14", "ix0", "x2", "ix7", "txfe", "X3", "xmlZero", "tx0", "ex3", "x1", "ix5", "ox10", "ex0", "x3", "ex2", "ixfe", "ox0", " x3", "ix10", "x10", " x7", "ox5", "X0"], "y0": [" yZero", "y2", "ny180", "h2", "yZero", "ty2", "tyZero", "dyZero", "y180", "dy0", "ny0", "nyZero", "ty06", " y06", "YZero", "h0", "Y0", "h06", "Y1", "yy0", "y1", "ytZero", "y06", " y2", "hZero", "ty0", "yy1", "dy180", "yt0", "yy180", "yyZero", " y1"], "nPbW": ["nPDbL", "nvPbWA", "nPabWR", "nPbL", "nPortbWH", "nPEdbHT", "nPortbW", "nPbpW", "nPnbV", "nPDnbL", "nPbWe", "nvPbpW", "nPnbW", "nPchW", "nvPbL", "nPEbWe", "nPortbY", "nPdW", "nPsbW", "nPcV", "nPbV", "nPxVW", "nvPbW", "nPlbWA", "nPbrW", "nPwbWR", "nPbWR", "nPbrWe", "nPbWin", "nPDnbVW", "nPEbW", "nPbWH", "nPbrHT", "nPortcW", "nPabY", "nPcY", "nPDnbW", "nPsbWe", "nPwbY", "nPbpWA", "nPsbV", "nPEdbW", "nPortbWR", "nPbWA", "nPbrV", "nPortcY", "nPsbHT", "nPchWH", "nvPbpWA", "nPdWin", "nvPbWin", "nPortcWH", "nPdL", "nPbpL", "nvPbpWin", "nPxL", "nPnbL", "nPDbW", "nPEbHT", "nPortcL", "nPDnbV", "nPcWH", "nPcVW", "nPdWA", "nPortbL", "nPdbW", "nvPbpL", "nPdbHT", "nPdbWe", "nPEdbV", "nPxW", "nPDbVW", "nPcL", "nPbVW", "nPbpWin", "nPDbV", "nPortcWR", "nPdbV", "nPwbL", "nPabL", "nPlbL", "nPlbWin", "nPchWR", "nPEdbWe", "nPlbW", "nPnbVW", "nPwbW", "nPbHT", "nPxV", "nPEbV", "nPwbWH", "nPcW", "nPcWR", "nPabW", "nPbY"], "nPbH": ["nPbHa", "nPvH", "nPbtHA", "nPobW", "nPbHE", "nPUbHE", "nMvW", "nPbpHA", "nPbpHB", "nPbT", "nPosbH", "nPvRH", "nPcT", "nPbaHE", "nPayfbH", "nPbtH", "nMvH", "nPsbW", "nPabT", "nPwbHa", "nNbY", "nNvH", "nPvHa", "nPbaHA", "nPfbMH", "nPosbHa", "nPUbpHB", "nNbH", "nPbHB", "nPvW", "nNvW", "nPcHD", "nPsbRH", "nPUbpHE", "nPbMH", "nPvY", "nPbRH", "nPabY", "nPobRH", "nPobHa", "nPUbHA", "nPaybH", "nPUbpHA", "nMbT", "nPayfbMH", "nPosbRH", "nPayfbHD", "nNvY", "nPbHD", "nMbH", "nPbHis", "nPwbH", "nPaybW", "nPbaH", "nPaybMH", "nPfbW", "nPfbHis", "nPayfbW", "nPcMH", "nPabHis", "nPosbW", "nPaybHD", "nPUbHB", "nPvMH", "nPUbpH", "nPsbHa", "nPbaHB", "nPvHis", "nNbHis", "nPvHD", "nPbtHE", "nPbtHB", "nPbpHE", "nPbHA", "nPcH", "nPfbH", "nNvHis", "nPfbHD", "nPabH", "nPbpH", "nPwbW", "nPUbH", "nPvT", "nPobH", "nPwbRH", "nMvT", "nPcW", "nPsbH", "nPfbY", "nPabW", "nPbY", "nNbW", "nMbW"], "log2_cb_size": ["log2_cb_scale", "log2_cb1sum", "log2_rb_size", "log2_rb_Size", "log2_cv_SIZE", "log2_cb_SIZE", "log2_cv_size", "log2_rb_SIZE", "log2_cbptscale", "log2_cbptsum", "log2_cv_set", "log2_rb_scale", "log2_cb_Size", "log2_cb1SIZE", "log2_rb_sum", "log2_cb1Size", "log2_cbptsize", "log2_cb_sum", "log2_cb_set", "log2_cb1size"], "part_idx": ["part_idexs", "part_idv", "part_indexx", "part_Idy", "part_pidx", "part___idx", "part_idxs", "part_idxf", "part_pidxf", "part___idv", "part_sidy", "part_idey", "part_Idn", "part_Idxc", "part_ridy", "part___sidxc", "part___idxc", "part_idxc", "part_idsn", "part_pidv", "part_sidv", "part_Idxs", "part___idy", "part___sidv", "part_sidx", "part_Idv", "part_ridxc", "part_ridx", "part_idy", "part_idsx", "part_idn", "part_ridv", "part___sidy", "part_sidxc", "part_indexxf", "part_idsxs", "part_idex", "part_iden", "part_indexv", "part_idsy", "part_Idx", "part___sidx"], "merge_idx": ["merge_idex", "merge_idz", "merge_diex", "merge_endx", "merge___idx", "merge_methodxb", "merge_idsx", "merge_idxe", "mergeptidx", "merge_ridd", "merge_partx", "merge_statxb", "merge__midxe", "merge_itx", "merge_idr", "merge_Idy", "merge_indexx", "merge_partxe", "merge_namey", "merge___statd", "mergeptheadex", "merge_endw", "merge_linx", "mergeptidex", "merge_partw", "merge_idw", "merge_ridxe", "merge_midx", "merge_namel", "merge_idsz", "merge_indexn", "merge_randix", "merge_kidxf", "merge__midw", "merge_namen", "merge_linz", "merge_statex", "merge_linn", "merge_Idxf", "merge_dix", "merge_itxf", "merge___statx", "merge_did", "merge__idw", "merge_linxe", "mergeptheadxb", "merge_statd", "merge_midr", "merge__idx", "merge_ridx", "merge__midr", "merge_idy", "mergeptheadd", "merge_idxb", "merge_ridxf", "merge___statxf", "merge_kidix", "merge_methodx", "merge___idd", "merge_idsn", "merge_endr", "merge_statxf", "merge_methodix", "merge_headxb", "merge_headx", "merge__idr", "merge_randy", "mergeptidd", "merge_endxe", "merge___idxf", "mergeptidxb", "merge_namex", "merge___statn", "merge_midw", "merge___idn", "merge_ridn", "merge_Idix", "merge_indexy", "merge_kidy", "merge_kidx", "merge_randx", "merge_idix", "merge_statn", "merge_randxb", "merge__midx", "merge_idsxe", "merge_itn", "merge_headex", "merge_idd", "merge_headd", "merge_idn", "mergeptheadx", "merge_ridz", "merge_itd", "merge_Idx", "merge_methody", "merge_partr", "merge_idl", "merge_statx", "merge__idxe", "merge_indexl", "merge_idxf", "merge_midxe", "merge_dixb"], "mv": ["vv", " mf", "vV", "mf", "mav", "MV", "mw", "Mav", "pv", "mV", "pV", "pw", "Mv", "Mf", " mav", "vq", " mq", "mq", "vav", "Mq", "pf", " mV", "Mw", " mw"], "lc": ["cu", "ctl", "tl", "unc", "tc", "lf", "cm", "lr", "ll", "l", "ln", "LC", "rl", "dl", "cc", "lib", "cli", "lvl", "lb", "icc", "cci", "func", "cl", "ls", "lu", "c", "lp", "xc", "ci", "ec", "kl", "cp", "gc", "mc", "cs", "bc", "lv", "soc", "pc", "fc", "acl", "uci", "vc", "gru", "jac"]}}
{"project": "qemu", "commit_id": "5f706fdc164b20b48254eadf7bd413edace34499", "target": 1, "func": "int s390_cpu_write_elf64_note(WriteCoreDumpFunction f, CPUState *cs,\n\n                              int cpuid, void *opaque)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    return s390x_write_all_elf64_notes(\"CORE\", f, cpu, cpuid, opaque);\n\n}\n", "idx": 15517, "substitutes": {"f": ["cf", "lf", "l", "fun", "p", "fd", " ff", "rf", "n", "F", "v", "t", "fm", "ef", "func", "sf", "fx", "fab", "fb", "c", "tf", "fp", "function", "fn", "bf", "df", "b", "fc", "fs", "d", "fi", "xf", "uf", "w", "exec"], "cs": ["cu", "cf", "bs", "cus", "CS", "js", "Cs", "cc", "cas", "css", "wcs", "ds", "ls", "s", "acs", "ac", "ts", "c", "caps", "ci", "ec", "cp", "ns", "gc", "mc", "pc", "fc", "fs", "ks", "ics", "ss", "sts", "sc", "rs", "ps"], "cpuid": ["CPu", "cu", "cuu", "pkguid", "cuid", "ctxuu", "cpUID", "pkgud", "cpuu", "ctxud", "CPuid", "CPuu", "cUID", " cpUID", "CPUID", "pkgu", "cpud", "ctxuid", " cpud", "ctxu", "pkguu", " cpuu"], "opaque": ["ocaque", " opaco", "obaques", "obent", "oplaque", "opica", "ocaco", "Opent", "ocque", "opacity", " opque", " opica", "Opaques", "hopica", "Opaque", "hopaque", "hopque", "opaques", "obacity", "Opacity", "obaque", "oplent", "ocica", "opaco", "oplacity", "opque", "hopaco", "oplaques", "opent"], "cpu": ["cu", "pu", "CPU", "gra", "phys", "alloc", "local", "core", " nu", "ctx", "linux", "proc", " computer", "clock", "util", " proc", "cache", "processor", "uu", "phy", "current", "runner", "mu", "physical", "c", "cal", "base", "cum", "lan", "ull", "gc", "cp", "nic", "gp", "pc", " cp", "gpu", "prof", " gorilla", "sky", "net", "pkg", "process", "ka"]}}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void encode_clnpass(Jpeg2000T1Context *t1, int width, int height, int bandno, int *nmsedec, int bpno)\n\n{\n\n    int y0, x, y, mask = 1 << (bpno + NMSEDEC_FRACBITS);\n\n    for (y0 = 0; y0 < height; y0 += 4)\n\n        for (x = 0; x < width; x++){\n\n            if (y0 + 3 < height && !(\n\n            (t1->flags[y0+1][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n\n            (t1->flags[y0+2][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n\n            (t1->flags[y0+3][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n\n            (t1->flags[y0+4][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG))))\n\n            {\n\n                // aggregation mode\n\n                int rlen;\n\n                for (rlen = 0; rlen < 4; rlen++)\n\n                    if (t1->data[y0+rlen][x] & mask)\n\n                        break;\n\n                ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_RL, rlen != 4);\n\n                if (rlen == 4)\n\n                    continue;\n\n                ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI, rlen >> 1);\n\n                ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI, rlen & 1);\n\n                for (y = y0 + rlen; y < y0 + 4; y++){\n\n                    if (!(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))){\n\n                        int ctxno = ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1], bandno);\n\n                        if (y > y0 + rlen)\n\n                            ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, t1->data[y][x] & mask ? 1:0);\n\n                        if (t1->data[y][x] & mask){ // newly significant\n\n                            int xorbit;\n\n                            int ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit);\n\n                            *nmsedec += getnmsedec_sig(t1->data[y][x], bpno + NMSEDEC_FRACBITS);\n\n                            ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, (t1->flags[y+1][x+1] >> 15) ^ xorbit);\n\n                            ff_jpeg2000_set_significance(t1, x, y, t1->flags[y+1][x+1] >> 15);\n\n                        }\n\n                    }\n\n                    t1->flags[y+1][x+1] &= ~JPEG2000_T1_VIS;\n\n                }\n\n            } else{\n\n                for (y = y0; y < y0 + 4 && y < height; y++){\n\n                    if (!(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))){\n\n                        int ctxno = ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1], bandno);\n\n                        ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, t1->data[y][x] & mask ? 1:0);\n\n                        if (t1->data[y][x] & mask){ // newly significant\n\n                            int xorbit;\n\n                            int ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit);\n\n                            *nmsedec += getnmsedec_sig(t1->data[y][x], bpno + NMSEDEC_FRACBITS);\n\n                            ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, (t1->flags[y+1][x+1] >> 15) ^ xorbit);\n\n                            ff_jpeg2000_set_significance(t1, x, y, t1->flags[y+1][x+1] >> 15);\n\n                        }\n\n                    }\n\n                    t1->flags[y+1][x+1] &= ~JPEG2000_T1_VIS;\n\n                }\n\n            }\n\n        }\n\n}\n", "idx": 15520, "substitutes": {"t1": ["type001", " t6", "T6", "at2", "td001", "ttah", "y81", "btae", "wt1", "tyasso", "tdae", "ttanta", "atasso", "template2", "ty1", "ty001", "t81", "ttae", "y001", "Tah", "ht91", "atae", "at11", "tt001", "type1", "Tau", "T3", "td01", "T2", "attasso", "ts2", "template1", "td25", "treeau", "tyae", "Tron", "t11", "t25", "bt001", "atron", "templateanta", "tav", "at001", "y1", "attanta", "t3", "T11", "tsau", "ts1", "tt6", "treeons", "htanta", "typeanta", "wt91", "T1", "templateah", "y2", " tasso", "Tav", "htau", "y01", "template81", "tree2", "t2", "typeah", "tdons", "att001", "tasso", "template25", "t91", "att1", "templateons", "ttasso", "tt9", "tree11", "attah", "wtasso", "wtau", "bt1", "tt3", "tt1", "tah", "t01", "tree1", "tau", "t6", " t91", "wtanta", "tanta", "treeron", "yae", "tsav", " t2", "treeanta", "T81", " tau", "htasso", "tae", "at1", "bt01", "tons", "att9", " t3", "tree25", "templateau", "td1", "tt2", "ht1", "attau", "tron", "ttau", "templateav", " t9", "yah", "t9", "t001"], "height": ["hang", "view", "wh", "ty", "border", "beam", "density", "header", "size", "high", "row", "depth", "window", "radius", "rows", "inches", "xy", "gh", "ih", "padding", "read", "hs", "bottom", "Height", "th", "hei", "html", "resolution", "image", "base", "count", "ht", "volume", "h", "input", "length", "shape", "w", "above", "angle", "history"], "bandno": [" bandnumber", "bbno", " bitNo", " bandNo", "bbNo", "bandNo", " bitno", "bandnumber", "bbnumber", " bitnumber", "bbnum", " bitnum", "bandnum", " bandnum"], "nmsedec": ["nmdedtc", "nmsEDtc", "nmsededtc", "nmssedEC", "nmdsedraw", "nmdsedec", "nmsEDEC", "nmsedtc", "nmsedraw", "nmssedec", "nmdedEC", "nmsededEC", "nmsedEC", "nmssedraw", "nmssedtc", "nmsEDraw", "nmdedraw", "nmdsedEC", "nmsEDec", "nmsededraw", "nmdedec", "nmsededec", "nmdsedtc"], "bpno": ["fpnos", "bbno", "lpNO", "bporno", "BPNo", "fpnumber", "BPnos", "fpNo", "BPnumber", "bpNO", "lpno", "bgno", "bgNO", "bpNo", "bbnos", "bborno", "bgorno", "bbNO", "bbNo", "bbnumber", "bpnumber", "BPno", "bgNo", "lporno", "fpno", "lpNo", "bpnos"], "y0": ["bit", "xyZero", "iy0", "cy83", "py000", "ryZero", "nyZero", "linkem", "t0", "xy047", "ye050", "wy17", "ny00", "iyaddr", "y25", "YZero", "y17", "iy25", "yy0", "fy047", "iyfrom", "sy83", "dy00", "nyfrom", "ryElement", "ty0", "iy050", "yeem", "uy00", "cy000", "yfrom", "ny17", " yZero", "t150", "wy03", "ye0", "vy0", "yZero", "fyBeg", "nyaddr", "yem", "py00", "y00", "y000", "sy0", "pyZero", "tZero", "syBeg", "ry180", "uy0", "cy255", "ye25", "link83", "yt00", "oy0", "uy000", "ry83", "yt0", "sy150", "ry150", "fyZero", "ye000", "y2", "xyBeg", "cy0", "ystart", "iy000", "y180", "dy0", "ny0", "yElement", "cy180", "wy00", "yaddr", "sy047", "vyfrom", "yt000", "cy2", "y03", "ny03", "yeElement", "dyBeg", "ytBeg", "t83", "py0", "y83", "syZero", "oyZero", "link0", "Y2", "ty17", "cy050", "y255", "ry050", "oyBeg", "cy25", "yyZero", "ny180", "yyem", "ty03", "vyaddr", "yeZero", "fy0", "nystart", "y150", "ry255", "ryem", "vystart", "yBeg", "ty00", "ry0", "Y0", "cyZero", "xy0", "cyem", "yyElement", " y2", "uyZero", "_", "wy0", "oy000", "ny255", "dy000", "y050", "link050", "w", "iystart", "y047", "oy00"], "x": ["tx", "column", "index", "key", "path", "inx", "xes", "at", "axis", "sw", "o", "wx", "ax", "l", "yx", "p", "ex", "xd", "X", "ident", "name", "v", "xs", "chain", "xy", "el", "pt", "ox", "xp", "read", "ext", "ct", "fx", "m", "r", "ux", "att", "time", "xi", "im", "dx", "xc", "lat", "on", "xx", "color", "xe", "h", "inner", "e", "u", "to", "px", "xf", "z", "xa", "rx", "w", "i", "xt", "xml", "ix", "mx"], "y": ["yy", "uy", "ty", "ly", "yt", "oy", "py", "dy", "ny", "ys", "yx", "j", "sy", "axy", "hy", "Y", "xy", "ya", "ym", "yr", "t", "ay", "ye", "icy", "cy", "vy", "iy", "ies", "ady", "yer", "b", "hot", "h", "my", "col", "sky", "yo", "wy", "gy", "ey", "ley", "yn", "i", "yl", "fy", "ch"], "rlen": ["plen", "dvals", "pln", "rrln", "dlan", "ranklan", " rline", "rvals", "rtll", " rfin", "rrlimit", "rrcmp", " rlan", "nrlen", "rll", "rarll", "lvals", "pmem", "nrlvl", "rval", "ranklvl", "rfin", "lline", "lval", "rcmp", " rll", "nrlin", "rtmem", "rld", "rarval", "qpl", "rlan", "rln", "rrlan", "rtler", "Rln", " rln", "rtld", " rmem", "rrlen", "rlvl", "rgl", "rcden", "rtlen", "vlen", "rlin", "rtpl", " rcmp", "rlimit", "rtcmp", "rlength", "rler", "rsl", "rarcompl", " rlength", "rtfin", "rtcompl", "rtgl", "llength", "qlen", "rpl", "psl", " rden", "mrgl", "rline", "rcler", "rden", "rarlen", "rtlimit", "Rsl", "nln", "dln", "rrlvl", "mrler", " rval", "nlen", "rmem", " rlimit", "ranklen", "rrmem", "dlen", "lfin", "llen", "qmem", "rclen", " rld", "ranklin", "rrden", "Rlen", "dlength", "vden", "rrlin", "dval", " rsl", "vln", "rcgl", "mrlen", "qld", "rtval", "Rmem", "rtline", "mrden", "rtden", "rrld", " rpl", "nval", "nrlan", "vld", " rvals", " rcompl", "rcompl", "nlan"]}}
{"project": "qemu", "commit_id": "aea390e4be652d5b5457771d25eded0dba14fe37", "target": 0, "func": "static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,\n\n                                       target_ulong *pte1p,\n\n                                       int ret, int rw)\n\n{\n\n    int store = 0;\n\n\n\n    /* Update page flags */\n\n    if (!(*pte1p & HPTE64_R_R)) {\n\n        /* Update accessed flag */\n\n        *pte1p |= HPTE64_R_R;\n\n        store = 1;\n\n    }\n\n    if (!(*pte1p & HPTE64_R_C)) {\n\n        if (rw == 1 && ret == 0) {\n\n            /* Update changed flag */\n\n            *pte1p |= HPTE64_R_C;\n\n            store = 1;\n\n        } else {\n\n            /* Force page fault for first write access */\n\n            ctx->prot &= ~PAGE_WRITE;\n\n        }\n\n    }\n\n\n\n    return store;\n\n}\n", "idx": 15521, "substitutes": {"ctx": ["tx", "resp", "jp", "kw", "cu", "rc", "cf", "mem", "conn", "tc", "cm", "kh", " context", "cmd", "hw", "p", "kt", "cc", "req", "tk", "ctr", "loc", "buf", "ct", "act", "nt", "context", "obj", "ck", " cx", "c", "cv", "xc", "ctrl", "cp", "mc", "bc", "Context", "con", "pkg", "sc", "history", "iat", "jac"], "pte1p": ["pte191P", "pte1ip", "pte3n", "pte5ip", "ptetime128P", "pte5P", "pte3P", "ptoe0g", "ptetime128p", "ptpe41p", "ptoe2P", "pte0pc", "pte001lp", "pte0g", "ptetime1ip", "pter5pc", "pter5p", "ptpe41pp", "pte0n", "ptpe1lp", "pte1001pp", "pte41lp", "pte0P", "ptoe1g", "ptpe1pp", "pte3c", "pte3d", "pte1001p", "ptoe0pc", "pte41pp", "pte5p", "pter1p", "pte01p", "ptpe41lp", "ptetime128ip", "pte1c", "ptetime1p", "pte3q", "pter1pc", "pte1pi", "pte1n", "pter1q", "ptoe2d", "pter5c", "pte1001lp", "ptoe2n", "pte191php", "pte4p", "ptoe1p", "pte128ip", "ptpe41pi", "pte0d", "pte1001pi", "pte128p", "pte4c", "ptetime1P", "pte3g", "ptoe1d", "pte5php", "pter5q", "pte4pc", "ptetime1php", "pte2n", "ptoe0p", "pte191ip", "pte1php", "ptoe2p", "pte41pi", "pter1c", "pte2d", "pte4q", "pte5q", "pte128php", "pte001p", "pte191p", "pte2P", "pte2p", "pte128P", "pte01pc", "ptoe1P", "ptpe1p", "pte001pi", "pte01g", "pte5pc", "ptetime128php", "pte1lp", "pte3pc", "pte1pp", "pte1g", "pte3p", "pte1pc", "ptoe1n", "pte1q", "pte41p", "pte1d", "pte5c", "pte001pp", "pte1P", "pte0p", "ptpe1pi", "ptoe1pc"], "ret": ["resp", "def", "des", "rew", "mem", "conn", "ref", "pert", "cmd", "Ret", "rf", "reply", "rets", "RET", "reset", "not", "read", "rm", "result", "nz", "ct", "nt", "desc", "lit", "alt", "gt", "att", "aux", "rt", "cb", "res", "flag", "re", "etc", "tmp", "mt", "ft", "ne", "vt"], "rw": ["rc", "kw", "rew", "nw", "sw", "wx", "writ", "rss", "usr", "aw", "ard", "wb", "hw", "rf", "vr", "wa", "write", "rb", "nz", "nr", "wn", "r", "aux", "iw", "rt", "dq", "rh", "sr", "wp", "shr", "wr", "rob", "urg", "rd", "ft", "mb", "RW", "rx", "w", "rn"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,\n\n                           QEMUSGList *sg, uint64_t sector,\n\n                           void (*cb)(void *opaque, int ret), void *opaque)\n\n{\n\n    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,\n\n                       DMA_DIRECTION_TO_DEVICE);\n\n}\n", "idx": 15524, "substitutes": {"bs": ["gs", "ba", "obs", "pb", "js", "bits", "bh", "bi", "sb", "bt", "gb", "cks", "ds", "ls", "bn", "bd", "BS", "bu", "bos", "bm", "bf", "bas", "blog", "b", "bl", "ns", "bc", "lbs", "cs", "es", "fs", "bps", "bis", "bb", "its", "bp", "bg", "ss"], "sg": ["sbm", " SG", "gs", "tg", "ag", " GS", "si", "sq", "ags", "igs", "g", "gu", "sam", "sol", "igm", "sb", "vg", "sv", "gb", "hs", "sch", "ds", "sa", "cfg", "s", "ssl", "sr", "erg", "rg", "gp", "gm", "yg", "eas", "sd", "GS", "sels", "bg", "ss"], "sector": [" section", " sec", "section", "sect", "address", "river", "row", "or", "storage", " se", "ar", "ifer", "ection", "sea", "spec", "sb", "erial", "sec", "er", "ctors", " sensor", "part", "sa", "sel", "ector", "fat", "ser", "vector", "tor", "serial", " sectors", "area", "selection", "component", "se", " segment", "acker", " scanner", " Sector", "Section", "tier"], "cb": ["rc", "cf", "unc", "cr", "fun", "pb", "callback", "ctx", "cmd", "eb", "cc", "cd", "erb", "sb", "buf", "gb", "dc", "lb", "rb", "func", "cfg", "fb", "ck", "c", "cv", "fp", "db", "bf", "fn", "cp", "b", "ctrl", "bc", "bb", "nb", "CB"], "opaque": ["popatile", " opaques", "paco", "ipaques", "operque", "opacity", "popaque", "pque", " opacity", " opque", "ipatile", "Opaque", "operatile", "Opaco", "operaque", "opaques", "Opacity", "popque", "Opque", "pacity", "ipaque", "ipacity", "opatile", "opaco", "paque", "operaco", "paques", "ipque", "opque", "popacity", "operacity"]}}
{"project": "qemu", "commit_id": "b6d36def6d9e9fd187327182d0abafc9b7085d8f", "target": 0, "func": "static int discard_single_l2(BlockDriverState *bs, uint64_t offset,\n\n    unsigned int nb_clusters, enum qcow2_discard_type type, bool full_discard)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Limit nb_clusters to one L2 table */\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_l2_entry;\n\n\n\n        old_l2_entry = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /*\n\n         * If full_discard is false, make sure that a discarded area reads back\n\n         * as zeroes for v3 images (we cannot do it for v2 without actually\n\n         * writing a zero-filled buffer). We can skip the operation if the\n\n         * cluster is already marked as zero, or if it's unallocated and we\n\n         * don't have a backing file.\n\n         *\n\n         * TODO We might want to use bdrv_get_block_status(bs) here, but we're\n\n         * holding s->lock, so that doesn't work today.\n\n         *\n\n         * If full_discard is true, the sector should not read back as zeroes,\n\n         * but rather fall through to the backing file.\n\n         */\n\n        switch (qcow2_get_cluster_type(old_l2_entry)) {\n\n            case QCOW2_CLUSTER_UNALLOCATED:\n\n                if (full_discard || !bs->backing_hd) {\n\n                    continue;\n\n                }\n\n                break;\n\n\n\n            case QCOW2_CLUSTER_ZERO:\n\n                if (!full_discard) {\n\n                    continue;\n\n                }\n\n                break;\n\n\n\n            case QCOW2_CLUSTER_NORMAL:\n\n            case QCOW2_CLUSTER_COMPRESSED:\n\n                break;\n\n\n\n            default:\n\n                abort();\n\n        }\n\n\n\n        /* First remove L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (!full_discard && s->qcow_version >= 3) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        } else {\n\n            l2_table[l2_index + i] = cpu_to_be64(0);\n\n        }\n\n\n\n        /* Then decrease the refcount */\n\n        qcow2_free_any_clusters(bs, old_l2_entry, 1, type);\n\n    }\n\n\n\n    qcow2_cache_put(bs, s->l2_table_cache, (void **) &l2_table);\n\n\n\n    return nb_clusters;\n\n}\n", "idx": 15530, "substitutes": {"bs": ["bytes", "ses", "aws", "ashes", "gs", "ubis", "ubs", "aos", "obs", "banks", "outs", "pb", "hz", "js", "bits", "bh", "bes", "sb", "bt", "aus", "hs", "cks", "ds", "ls", "iss", "asis", "BS", "ts", "bos", "boxes", "blog", "vs", "b", "ns", "cs", "bc", "lbs", "bl", "uts", "fs", "bps", "ks", "os", "bis", "ash", "its", "bp", "ss", "sts", "ms"], "offset": ["index", "error", "at", "shift", "o", "ref", "address", " offsets", "seed", "size", "mask", "Offset", "reset", "padding", "end", "op", "lock", "off", "slot", "attribute", "prefix", "range", "buffer", "block", "count", "pos", "location", "base", "top", "start", "oid", "slice", "id", "set", "seek", "os", "zero", "pointer"], "nb_clusters": ["nb_declients", "nb_loci", "nb_declards", "nb_blusters", "nb___clususter", "nb_collers", "nb_plores", "nb_blards", "nb___clususters", "nb7blusters", "nb___closures", "nb_slusters", "nb7clards", "nb___clusters", "nb_plosures", "nb_colluster", "nb_spluster", "nb_plers", "nb_pluster", "nb_clusosures", "nb_clususter", "nb7blards", "nb_custer", "nb_declusters", "nb_lients", "nb_splores", "nb_declers", "nb___cluster", "nb_clards", "nb_clores", "nb_Cliders", "nb_custers", "nb___clusosures", "nb_cloci", "nb_clodes", "nb_collores", "nb_clients", "nb_cients", "nb7clocations", "nb_slocations", "nb_Clodes", "nb7clodes", "nb_slards", "nb_lusters", "nb_plusters", "nb_plients", "nb_plodes", "nb_declores", "nb_Clusters", "nb_declocations", "nb_cluster", "nb_declodes", "nb_ploci", "nb_blodes", "nb_colliders", "nb___clodes", "nb_closures", "nb___clusodes", "nb7blodes", "nb_clocations", "nb_luster", "nb_collients", "nb_cliders", "nb_coci", "nb_blocations", "nb_Clores", "nb_collusters", "nb7blocations", "nb_clusodes", "nb_spliders", "nb_splusters", "nb_Closures", "nb7clusters", "nb_clers", "nb_Cluster", "nb_clususters", "nb_slodes"], "type": ["types", "index", " field", "error", "ty", "Type", " name", " size", "o", "out", " t", "size", " error", "p", " out", "dt", "test", " format", "t", "unit", "kind", " template", " TYPE", " fmt", " other", " pt", "info", "TYPE", "range", " ty", "file", " kind", " change", " event", "ype", "set", " types", "state", "to", " how", " tree", "style", " Type", " timeout", "name", "pe"], "full_discard": ["full_Discment", "full_decarded", "full_continard", "full_failal", "full_failure", "full_continarded", "full_discrip", "full_failarded", "full_decarding", "full_iscal", "full_decards", "full_dcure", "full_iscards", "full_regarded", "full_decard", "full_iscarded", "full_cachement", "full_cacheause", "full_cacheards", "full_dcal", "full_iscure", "full_discards", "full_discure", "full_discarding", "full_continarding", "full_Discards", "full_dcard", "full_dcarded", "full_Discarded", "full_Discrip", "full_cacheard", "full_Discard", "full_iscard", "full_discment", "full_iscment", "full_iscarding", "full_regrip", "full_Discause", "full_discarded", "full_Discarding", "full_regarding", "full_iscause", "full_discause", "full_regard", "full_continrip", "full_failard", "full_discal"], "s": ["ses", "aws", "gs", "S", "serv", "less", "p", "js", "bits", "sl", "http", "store", "sam", "t", "is", "sb", "sv", "space", "hs", "sys", "ds", "ls", "ats", "sa", "ess", "oss", "ssl", "ts", "c", "stats", "vs", "ins", "ns", "b", "cs", "h", "ims", "bis", "its", "parts", "sn", "ss", "sts", "rs", "ps"], "l2_table": ["l4_table", "l2_trace", "l2Ptab", "l3_TABLE", "l102_cache", "l2_term", "l3_source", "lopher_public", "lTwo_tr", "l3_cache", "l4_try", "l2_public", "l2_container", "l2_tree", "lTwo_chain", "l102_tab", "l4_TABLE", "l102_table", "l2_manager", "l3_tab", "l2Ptable", "l2_entry", "l2Ptr", "l3_entry", "l3_table", "l2_TABLE", "l2_tr", "lTwo_table", "l2_tab", "l2_try", "lTwo_tab", "l102_trace", "lopher_table", "l4_container", "lopher_term", "l3_manager", "lopher_TABLE", "l2_cache", "l3_tree", "l2_chain", "l2Pchain", "l2_source"], "l2_index": ["l10___error", "ltwo_iter", "l2_data", "l2__index", "l1_pos", "l2_ind", "ltwo_ind", "l3_node", "l3_index", "l2_error", "l2___set", "l2zindex", "l1_data", "l2znode", "ltwo_loc", "l10_error", "l10___set", "l2___list", "ltwo_Index", "l10___index", "l3_Index", "l2___error", "l2_iter", "l2_loc", "l10_set", "l10___list", "ltwo_index", "l2zIndex", "l1_Index", "l1_num", "l2_root", "l2_pos", "l2_Index", "ltwo_info", "l3_start", "l2__pos", "l1_index", "l2_num", "l10_list", "l2zstart", "l2_node", "l2__Index", "l2_info", "l10_index", "l2_set", "l2_start", "l2___index", "ltwo_root", "l2_list"], "ret": ["resp", "rem", "def", "trust", "out", "ref", " RET", "utils", "j", "Ret", "tr", "rets", "RET", "val", "v", "reset", "deg", "try", "t", "len", "result", "ext", "nt", "lit", "r", "alt", "gt", "last", "aux", "rt", "Return", "tf", "count", "prime", "limit", "ry", "res", "b", "print", "ber", "red", "re", "jump", "flag", "mt", "iter", "it", "fi", "elt", "err", "uf", "final", "value", "ter", "cont", "txt"], "i": ["ij", "key", "instance", "li", "index", "by", "o", "iu", "out", "mi", " j", "I", "pi", "ii", "l", "j", "ini", "n", "uri", "ei", "ind", "si", "ki", "zi", " ti", "v", "cli", "bi", "batch", "io", "ui", "is", "ic", "di", " ii", "ai", "m", "in", " I", "hi", "xi", "qi", " bi", "sim", "info", "im", "c", "ci", "print", "id", "ti", "e", "ri", "u", "multi", "it", "gi", "fi", "me", "phi", "x", "y", "span", "ix", "ip"], "old_l2_entry": ["old_l3_row", "old_l3_system", "old_l2___key", "old_l2tentry", "old_l1_row", "old_l3_Entry", "old_l2tEntry", "old_l1_key", "old_l2tsystem", "old_l2___entry", "old_l2_record", "old_l1_entry", "old_l3_entry", "old_l3_key", "old_l1_obj", "old_l1_word", "old_l2pEntry", "old_l2_field", "old_l2tfield", "old_l2_Entry", "old_l2pword", "old_l2_obj", "old_l2_word", "old_l2___record", "old_l2___row", "old_l1_Entry", "old_l2pentry", "old_l2prow", "old_l2_key", "old_l3_field", "old_l2_row", "old_l3_record", "old_l2_system"]}}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int64_t qemu_archipelago_getlength(BlockDriverState *bs)\n\n{\n\n    int64_t ret;\n\n    BDRVArchipelagoState *s = bs->opaque;\n\n\n\n    ret = archipelago_volume_info(s);\n\n    return ret;\n\n}\n", "idx": 15534, "substitutes": {"bs": ["sbm", "ses", "ashes", "gs", "ubs", "aos", "obs", "js", "bes", "sb", "aus", "sys", "hs", "ds", "ats", "iss", "BS", "qs", "ts", "bos", "bm", "vs", "b", "ns", "bl", "bc", "lbs", "cs", "fs", "bps", "ks", "bis", "its", "bp", "ss", "sts", "ms", "rs", "ps"], "ret": ["xt", "rem", "out", " RET", "pert", "ll", "Ret", "tr", "opt", "rets", "RET", "val", "t", "ert", "rm", "result", "nz", "nt", "lit", "alt", "gt", "att", "oret", "rev", "rt", "ts", "rat", "urt", "limit", "lt", "res", "print", "re", "mt", "ft", "it", "elt", "fi", "err", "uf", "pas", " Ret", "ter", "usr", "cont", "txt"], "s": ["sis", "ses", "gs", "S", "as", "less", "ys", "p", "js", "sq", "sam", "us", "als", "sb", "sv", "is", "sys", "ds", "ats", "ls", "ies", "qs", "ts", "vs", " ss", "ins", "b", "ns", "cs", "es", "fs", "its", "se", "ss", "sts", "rs", "ps"]}}
{"project": "qemu", "commit_id": "47445c80fb57035331574ac1ac0bcee67fb84aeb", "target": 0, "func": "static void rtas_ibm_set_eeh_option(PowerPCCPU *cpu,\n\n                                    sPAPRMachineState *spapr,\n\n                                    uint32_t token, uint32_t nargs,\n\n                                    target_ulong args, uint32_t nret,\n\n                                    target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    PCIDevice *pdev;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n    int ret;\n\n\n\n    if ((nargs != 4) || (nret != 1)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = rtas_ldq(args, 1);\n\n    addr = rtas_ld(args, 0);\n\n    option = rtas_ld(args, 3);\n\n\n\n    sphb = spapr_pci_find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    pdev = pci_find_device(PCI_HOST_BRIDGE(sphb)->bus,\n\n                           (addr >> 16) & 0xFF, (addr >> 8) & 0xFF);\n\n    if (!pdev || !object_dynamic_cast(OBJECT(pdev), \"vfio-pci\")) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_set_option) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_set_option(sphb, addr, option);\n\n    rtas_st(rets, 0, ret);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 15535, "substitutes": {"cpu": ["cu", "pu", "CPU", "mem", "conn", "phys", "core", "ctx", "hw", "linux", "proc", "cli", " proc", "np", "sys", "processor", "pai", "nc", "cp", "gc", "gp", "pc", " cp", "cow", "con", "gpu", "process", "nu"], "spapr": ["apapprc", "spcapr", "spapprs", "apapr", "spapsir", "spaphro", "spaphrs", "spaphrc", "spaprs", "spaperc", "spcapR", "apappro", "spapsR", "spcaprs", "spapir", "spaprc", "apapprs", "spaphr", "apappr", "spcapir", "apaprc", "spappro", " spaprs", "apaprs", "spapers", "spappr", "spapsrs", " spapir", "spapro", "spaper", "spapero", "spapsr", "spapR", " spapR", "spapprc", "apapro"], "token": ["node", "random", "ok", "callback", "auth", "call", "opt", "field", "t", "oken", "wt", "Token", "ens", "tn", "tree", "alt", "hat", "arn", "rt", "ts", "password", "fn", "root", "secret", "os", "prop", "target"], "nargs": ["nrets", "Nrows", " nrows", "NArgs", "nrows", "jns", "Narg", "nnarg", "numarg", "nArgs", " nrets", "nnargs", " nArgs", "narg", "Nargs", "numrets", "jargs", "numargs", "nnrows", "jrets", "nns", " nns", "nnArgs", "jarg", " narg", "numns"], "args": ["uns", "ames", "aws", "gs", "settings", "ties", "ys", "flags", "cmd", "values", "js", "keys", "params", "ags", "names", "rows", "xs", "fields", "limits", "reg", "css", "words", "arms", "is", "ds", "ls", "orders", "icks", "bugs", "dates", "gets", "qs", "vals", "days", "ars", "ts", "atts", "stats", "all", " arguments", "ns", "Args", "ras", "es", "cs", "tests", "amps", "ims", "arg", "GS", "parts", "options", "uments", "ms", "terms", "arr"], "nret": ["nrets", "numres", "nalt", " nreturn", "numret", "tret", "Nret", "numreturn", " nrets", "trets", "tRet", "numrets", "nreturn", " nres", "nRet", "Nrets", " nRet", "NRet", "Nalt", "Nres", "talt", "Nreturn", " nalt", "nres"], "rets": ["uns", "aws", "gs", "des", "ints", "outs", "ids", "values", "rows", "runs", "lists", "urs", "als", "fits", "aus", "ens", "fts", "ds", "ls", "ires", "gets", "qs", "vals", "uds", "ts", "ets", "results", "res", "ns", "states", "ras", "uts", "tes", "events", "fs", "ows", "els", "asts", "its", "sts", "terms", "rs"], "sphb": ["ssphbe", "sophb", "sptbb", "smphba", "shb", " sphc", "aspta", "spho", "aspha", "askhbe", "smphub", " smphB", "sPhc", "sphiba", "sophba", "spta", "smphb", "asphbe", " sphv", "sphy", "asptbb", "asphba", "sfxo", "sfxy", "skhba", "smphB", "sphiub", "siphbb", "sptba", " smphub", "smphc", "askhb", "ssphbb", "saphbar", "skhb", "sapha", "sophbe", "sophB", "siphba", "siphb", "shbb", " smphy", " spho", "sha", "skhB", "asphb", "shbe", " sphy", "smpho", "sfxb", "ssophbe", " smphv", "saphb", "smphbar", "smphy", "sphB", "sphib", "sPhb", "sphbar", "sphibe", "ssophbb", "splb", "smpha", "sphub", "sspha", " smpho", "asphbb", "spha", "sply", "splo", "sphbe", "sipha", " sphbar", "asphB", "smphbb", "sopha", "sphbb", "splv", "smphv", " smphc", "askhba", "sphv", "skhbe", "ssophb", "asptba", "sPhB", " sphB", "askhB", "sphba", "ssopha", " smphb", "sophbb", "sptb", "sphiB", "sPhub", "saphbe", "asptb", " sphub", "ssphb", "saphy", "sphc", "sfxv", "sphic", "saphbb"], "spc": ["spch", "spect", "splch", "spci", "ppC", "peac", "ppc", "apl", "spce", "spcc", "psc", " espci", "specc", "SpC", "ppci", " spch", " spce", "apci", " espc", "spec", "sppc", " espcc", "splc", " esppc", "pscc", "ppct", " spac", "spl", "Spcc", " spci", "splce", "pspc", "apcc", "apct", "spct", "psci", "spac", "splac", "apc", " spl", "Spct", "spC", "speC", "ppcc", "appc", "Spc", "pece", " spct", "pech", "ppl", "pec"], "pdev": ["Pev", " pmy", "Pdem", " pev", "lpdev", "padev", "mpdevice", "mdevice", "pmy", " pdata", "pprof", "pedev", "dDE", "paDE", " pdo", "pedevice", "mpev", "pcconn", "mpdem", "lpdevice", "mmy", "pdata", "pcdevice", "mdata", "dprof", "pev", "pedo", "pDE", " pdevice", "pcDE", "pdem", " pconn", "pdevice", "pdo", "Pdevice", "lpmy", "ddevice", "mdev", "padevice", "pcdev", "lpdata", "pcdo", "pcprof", "Pdev", "ddev", "paprof", "pconn", " pdem", "mpdev", "peconn"], "addr": ["tx", "rc", "ress", "key", "at", "mem", "ptr", "ref", "src", "usr", "address", "attr", "cmd", "ctx", "grad", "hw", "x", "dr", "size", "ord", "opt", "ar", "port", "adr", "len", "loc", "ext", "offset", "align", "oad", "act", "eth", "alt", "url", "att", "obj", "off", "add", "pos", "bind", "coord", "alias", "ack", "id", "start", "ad", "order", "host", "arg", "pad", "var", "hash", " address", "err", "ip", "rn", "arr", "rs", "ix", "ident", "Address", "arp"], "option": ["index", "key", "error", "type", "param", "section", "attr", "mode", "opt", "field", " Option", "command", "offset", "op", "tag", "operation", "alt", "description", "condition", "off", "slot", "comment", "attribute", "ption", "event", "optional", "alias", "Option", "action", "label", "term", " opt", "arg", "weight", "mod", "ion", "options", "prop", "value", "offer", "name", "tion"], "buid": ["suID", "uuids", "cuId", "guuid", "cuID", "guId", "cuuid", "cuid", "buId", "suuid", " buId", "suid", "guid", "BUuid", "buuid", "BUids", "BUid", "guID", " buids", "buID", "BUId", "buids", "suId", "BUID", "uuid", "uuId"], "ret": ["resp", "rem", "def", "mem", "ptr", "out", "ref", " RET", "det", "fun", "back", "Ret", "tr", "RET", "val", "t", "ert", "len", "rm", "result", "nt", "get", "alt", "gt", "rt", "ts", "Return", "res", "print", "flag", "re", "set", "mt", "arg", "ft", "it", "elt", "err", " Ret", " fut", "rs"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_acl_remove(qemu_acl *acl,\n\n                    const char *match)\n\n{\n\n    qemu_acl_entry *entry;\n\n    int i = 0;\n\n\n\n    TAILQ_FOREACH(entry, &acl->entries, next) {\n\n        i++;\n\n        if (strcmp(entry->match, match) == 0) {\n\n            TAILQ_REMOVE(&acl->entries, entry, next);\n\n            return i;\n\n        }\n\n    }\n\n    return -1;\n\n}\n", "idx": 15537, "substitutes": {"acl": ["co", "ifa", "lc", "l", "elist", "iam", "hip", "aka", "auth", "storage", "wl", "aud", "compl", "cas", "wal", "abilities", "load", "closure", "aco", "util", "policy", "esi", "cl", "al", "game", "qa", "lease", "acs", "ac", "aci", "arch", "ael", "layout", "iana", "kl", "rol", "client", "etc", "fc", "ace", "las", "elt", "ity", "ma", "ast", "scl", "anc", "asc"], "match": ["key", "path", "type", "route", "patch", "query", "apply", "search", "address", "mask", "cmp", "pattern", "rule", "text", "check", "test", "field", "atch", "cache", "tag", "m", "lock", "message", "word", "replace", "find", "link", "ATCH", "matched", "Match", "ment", "like", "mat", "re", "id", "equal", "pre", "hash", "length", "fire", "target", "filter", "valid", "force"], "entry": ["server", "key", "instance", "index", "view", "record", "entity", "member", "inter", "search", "row", "or", "ant", "next", "try", "ent", "escape", "command", "item", "cell", "nt", "job", "connection", "line", "ie", "obj", "word", "comment", "image", "event", "byte", "link", "import", "ry", "print", "table", "term", "Entry", "e", "inner", "existent", "ace", "list", "it", "enter", "element", "component", "se", "q", "queue", "name", "ce", "form"], "i": ["ij", "index", "li", "a", "f", "iu", "oi", "mi", "ii", "ini", "pi", "I", "ei", "j", "ind", "p", "n", "l", "si", "zi", "v", "next", "is", "ui", "di", " ii", "ai", "m", "k", "r", "hi", "xi", "iy", "sim", "info", "im", "c", "count", "ci", "start", "ims", "id", "u", "multi", "d", "phi", "x", "y", "ix", "ip"]}}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void ac97_initfn (PCIDevice *dev)\n\n{\n\n    PCIAC97LinkState *d = DO_UPCAST (PCIAC97LinkState, dev, dev);\n\n    AC97LinkState *s = &d->ac97;\n\n    uint8_t *c = d->dev.config;\n\n\n\n    s->pci_dev = &d->dev;\n\n    pci_config_set_vendor_id (c, PCI_VENDOR_ID_INTEL); /* ro */\n\n    pci_config_set_device_id (c, PCI_DEVICE_ID_INTEL_82801AA_5); /* ro */\n\n\n\n    c[0x04] = 0x00;      /* pcicmd pci command rw, ro */\n\n    c[0x05] = 0x00;\n\n\n\n    c[0x06] = 0x80;      /* pcists pci status rwc, ro */\n\n    c[0x07] = 0x02;\n\n\n\n    c[0x08] = 0x01;      /* rid revision ro */\n\n    c[0x09] = 0x00;      /* pi programming interface ro */\n\n    pci_config_set_class (c, PCI_CLASS_MULTIMEDIA_AUDIO); /* ro */\n\n    c[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; /* headtyp header type ro */\n\n\n\n    c[0x10] = 0x01;      /* nabmar native audio mixer base\n\n                            address rw */\n\n    c[0x11] = 0x00;\n\n    c[0x12] = 0x00;\n\n    c[0x13] = 0x00;\n\n\n\n    c[0x14] = 0x01;      /* nabmbar native audio bus mastering\n\n                            base address rw */\n\n    c[0x15] = 0x00;\n\n    c[0x16] = 0x00;\n\n    c[0x17] = 0x00;\n\n\n\n    c[0x2c] = 0x86;      /* svid subsystem vendor id rwo */\n\n    c[0x2d] = 0x80;\n\n\n\n    c[0x2e] = 0x00;      /* sid subsystem id rwo */\n\n    c[0x2f] = 0x00;\n\n\n\n    c[0x3c] = 0x00;      /* intr_ln interrupt line rw */\n\n    c[0x3d] = 0x01;      /* intr_pn interrupt pin ro */\n\n\n\n    pci_register_bar (&d->dev, 0, 256 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    pci_register_bar (&d->dev, 1, 64 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    register_savevm (\"ac97\", 0, 2, ac97_save, ac97_load, s);\n\n    qemu_register_reset (ac97_on_reset, s);\n\n    AUD_register_card (\"ac97\", &s->card);\n\n    ac97_on_reset (s);\n\n}\n", "idx": 15549, "substitutes": {"dev": ["conn", "hw", "DE", "devices", "raw", "dis", "den", "end", "nt", "adv", "serial", "develop", "app", "pro", "def", "des", "mem", "pub", "data", "Device", "v", "spec", "nav", "dist", "dd", "obj", "env", "dem", "db", "link", "device", "any", "ad", "av", "server", "vo", "a", "DEV", "ver", "dn", "boot", "store", "buf", "sys", "da", "disk", "info", "block", "debug", "de", "ev", "go", "serv", "o", "det", "build", "p", "Dev", "reg", "gen", "pp", "priv", "cam", "desc", "off", "die", "h", "sd", "pad", "ve", "prop", "w", "ch"], "d": ["a", "f", "dn", "ind", "j", "n", "p", "dr", "D", "dl", "dm", "pd", "dt", "v", "done", "t", "du", "md", "di", "dc", "dos", "ds", "da", "m", "dd", "r", "bd", "dq", "dx", "db", "b", "ad", "e", "de", "sd", "rd", "dh", "z", "dat", "did", "w", "i", "ld"], "s": ["sis", "gs", "a", "S", "bs", "o", "l", "j", "n", "p", "js", "sq", "v", "g", "t", "source", "is", "sb", "sv", "st", "sys", "ds", "ats", "ls", "m", "r", "so", "ts", "stats", "ns", "b", "cs", "h", "es", "fs", "os", "ss", "sts", "i", "y", "w", "rs", "ps"], "c": ["csv", "rc", "ce", "cu", "a", "co", "f", "cf", "tc", "o", "cm", "at", "unc", "lc", "l", "p", "n", "call", "cod", "cc", "v", "chain", "t", "loc", "ic", "spec", "cache", "dc", "ct", "m", "r", "uc", "sc", "api", "C", "ac", "cb", "cv", "xc", "all", "nc", "abc", "ec", "code", "ci", "content", "cp", "b", "gc", "cs", "bc", "h", "etc", "mc", "fc", "set", "pc", "con", "conf", "enc", "e", "list", "u", "config", "vc", "arc", "ca", "cont", "ch"]}}
{"project": "FFmpeg", "commit_id": "68900bf16bb4dda35cf5f2801ce72c15056f1939", "target": 0, "func": "static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,\n\n                      const uint8_t **poutbuf, int *poutbuf_size,\n\n                      const uint8_t *buf, int buf_size)\n\n{\n\n    CookParseContext *s = s1->priv_data;\n\n\n\n    if (s->duration)\n\n        s1->duration = s->duration;\n\n    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)\n\n        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;\n\n\n\n    /* always return the full packet. this parser isn't doing any splitting or\n\n       combining, only setting packet duration */\n\n    *poutbuf      = buf;\n\n    *poutbuf_size = buf_size;\n\n    return buf_size;\n\n}\n", "idx": 15552, "substitutes": {"s1": ["s5", "ss4", "ns2", "ts2", "s10", "ps2", "ss2", "ns10", "ss01", "ns1", "ts4", "ns0", " s01", "ts1", " s4", " s10", "s01", " s5", "ps01", "ps5", "ts0", "ts10", "ts01", " s2", "ps1", "s2", "ss1", " s0", "s4", "s0"], "avctx": ["avjac", "avectl", "avcv", "avtx", " avpkg", "avctl", "wavcontext", "varcv", "wavctl", " avct", " avconn", "avercv", "avetxt", "avcontext", "avetmp", "wavpkg", "averpkg", "avepkg", "afcontext", " avtxt", "varctx", "avpkg", "afctl", "varpkg", "avtmp", "avecontext", " avtx", "aftx", "avercc", "afctx", "averctx", "wavct", "avectx", " avca", "avetx", "avect", " avjac", "avertx", "avcc", "wavconn", "avconn", "avca", "wavtxt", " avcc", "avertmp", " avcontext", " avctl", " avtmp", "avtxt", "aveca", "afca", "aveconn", "averjac", "wavctx", "varjac", " avcv", "avct", "avecc"], "poutbuf": ["Pinbuffer", "pOutvec", "potbuffer", "Pinbuf", "Poutbuf", "pinbuffer", "poutvec", "Poutbuff", "pinvec", "pinqueue", "Pinvec", "poutbuff", "Pinbuff", "pOutqueue", "Poutqueue", "poutqueue", "p_buf", "pinbuff", "pOutbuf", "p_queue", "Poutbuffer", "potvec", "Poutvec", "Pinqueue", "pOutbuff", "poutbuffer", "potbuf", "pOutbuffer", "p_buffer", "pinbuf", "p_buff", "potqueue"], "poutbuf_size": ["poutbuffer_size", "poutbuf2size", "poutbuf_loss", "poutbuf_SIZE", "poutbuf2Size", "poutbuffer_SIZE", "poutbuffer_count", "poutbuffer_fee", "poutbuf2fee", "poutbuffer_len", "poutbuffer_Size", "poutbuf_len", "poutbuf_fee", "poutbuffer_loss", "poutbuf2len", "poutbuf_count", "poutbuf_Size"], "buf": ["bar", "Buff", "vec", "mem", "out", "ff", "data", "seq", "pb", "cmd", "p", "wb", "raw", "Buffer", "conv", "pool", "batch", "box", "msg", "buff", "cap", "cache", "rb", "pipe", "np", "func", "xff", "br", "bag", "fb", "bridge", "buffer", "cb", "block", "cv", "db", "b", "tmp", "foo", "uf", "queue", "offer", "pkg", "alloc"], "buf_size": ["queue_SIZE", "buf2length", " buf2length", "buf2len", "buf__len", " buf2size", "buf_len", "buf__code", " buf2len", "buf_SIZE", "buf2SIZE", "buf2string", "queue_size", "buf__length", "queue_string", " buf_len", "buf2code", "buf2size", "buf_code", "buf__size", "buf_length", " buf_code", "buf_string", "queue_len", " buf_SIZE", " buf_length", " buf2code"], "s": ["comments", "aws", "gs", "S", "as", "bs", "has", "less", "local", "n", "js", "p", "sq", "eps", "g", "ar", "is", "als", "sys", "hs", "ds", "ls", "ats", "m", "ess", "gets", "qs", "ts", "self", "c", "ares", "ins", "ns", "cs", "h", "ims", "pers", "es", "tes", "changes", "fs", "os", "sports", "scl", "ss", "sts", "ms", "w", "rs", "ps"]}}
{"project": "FFmpeg", "commit_id": "2f4233614a7fbe176b81de0ef14bf38bad8e6693", "target": 0, "func": "static void add_codec(FFServerStream *stream, AVCodecContext *av,\n\n                      FFServerConfig *config)\n\n{\n\n    AVStream *st;\n\n    AVDictionary **opts, *recommended = NULL;\n\n    char *enc_config;\n\n\n\n    if(stream->nb_streams >= FF_ARRAY_ELEMS(stream->streams))\n\n        return;\n\n\n\n    opts = av->codec_type == AVMEDIA_TYPE_AUDIO ?\n\n           &config->audio_opts : &config->video_opts;\n\n    av_dict_copy(&recommended, *opts, 0);\n\n    av_opt_set_dict2(av->priv_data, opts, AV_OPT_SEARCH_CHILDREN);\n\n    av_opt_set_dict2(av, opts, AV_OPT_SEARCH_CHILDREN);\n\n    if (av_dict_count(*opts))\n\n        av_log(NULL, AV_LOG_WARNING,\n\n               \"Something is wrong, %d options are not set!\\n\", av_dict_count(*opts));\n\n\n\n    if (config->stream_use_defaults) {\n\n    //TODO: reident\n\n    /* compute default parameters */\n\n    switch(av->codec_type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        if (av->bit_rate == 0) {\n\n            av->bit_rate = 64000;\n\n            av_dict_set_int(&recommended, \"ab\", av->bit_rate, 0);\n\n        }\n\n        if (av->sample_rate == 0) {\n\n            av->sample_rate = 22050;\n\n            av_dict_set_int(&recommended, \"ar\", av->sample_rate, 0);\n\n        }\n\n        if (av->channels == 0) {\n\n            av->channels = 1;\n\n            av_dict_set_int(&recommended, \"ac\", av->channels, 0);\n\n        }\n\n        break;\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        if (av->bit_rate == 0) {\n\n            av->bit_rate = 64000;\n\n            av_dict_set_int(&recommended, \"b\", av->bit_rate, 0);\n\n        }\n\n        if (av->time_base.num == 0){\n\n            av->time_base.den = 5;\n\n            av->time_base.num = 1;\n\n            av_dict_set(&recommended, \"time_base\", \"1/5\", 0);\n\n        }\n\n        if (av->width == 0 || av->height == 0) {\n\n            av->width = 160;\n\n            av->height = 128;\n\n            av_dict_set(&recommended, \"video_size\", \"160x128\", 0);\n\n        }\n\n        /* Bitrate tolerance is less for streaming */\n\n        if (av->bit_rate_tolerance == 0) {\n\n            av->bit_rate_tolerance = FFMAX(av->bit_rate / 4,\n\n                      (int64_t)av->bit_rate*av->time_base.num/av->time_base.den);\n\n            av_dict_set_int(&recommended, \"bt\", av->bit_rate_tolerance, 0);\n\n        }\n\n\n\n        if (!av->rc_eq) {\n\n            av->rc_eq = av_strdup(\"tex^qComp\");\n\n            av_dict_set(&recommended, \"rc_eq\", \"tex^qComp\", 0);\n\n        }\n\n        if (!av->rc_max_rate) {\n\n            av->rc_max_rate = av->bit_rate * 2;\n\n            av_dict_set_int(&recommended, \"maxrate\", av->rc_max_rate, 0);\n\n        }\n\n\n\n        if (av->rc_max_rate && !av->rc_buffer_size) {\n\n            av->rc_buffer_size = av->rc_max_rate;\n\n            av_dict_set_int(&recommended, \"bufsize\", av->rc_buffer_size, 0);\n\n        }\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    } else {\n\n        switch(av->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            if (av->bit_rate == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"audio bit rate is not set\\n\");\n\n            if (av->sample_rate == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"audio sample rate is not set\\n\");\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (av->width == 0 || av->height == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"video size is not set\\n\");\n\n            break;\n\n        default:\n\n            av_assert0(0);\n\n        }\n\n    }\n\n\n\n    st = av_mallocz(sizeof(AVStream));\n\n    if (!st)\n\n        return;\n\n    av_dict_get_string(recommended, &enc_config, '=', ',');\n\n    av_dict_free(&recommended);\n\n    av_stream_set_recommended_encoder_configuration(st, enc_config);\n\n    st->codec = av;\n\n    stream->streams[stream->nb_streams++] = st;\n\n}\n", "idx": 15555, "substitutes": {"stream": ["server", "view", "cf", "metadata", "version", "sw", "src", "out", "tv", "data", "row", "window", "ocr", "v", "pool", "sl", "port", "http", "Stream", "read", "stack", "video", "iterator", "now", "ream", "context", "channel", "buffer", "ost", "console", "count", "client", "table", "transform", "host", "length", "shape", "REAM", "network", "sc", "driver", "form"], "av": ["craft", "audio", "hw", "man", "com", "ab", "aval", "ai", "ann", "att", "imp", "van", "ave", "uf", "net", "pkg", "us", "ka", "am", "mem", "aka", "conv", "v", "liv", "acc", "comm", "iq", "nav", "aux", "iv", "um", "ver", "aj", "auth", "vp", "aud", "sav", "aver", "Av", "aus", "fax", "cv", "aft", "apt", "dev", "enc", "uv", "ev", "ob", "ua", "au", "wav", "tv", "aw", "iam", "vr", "ee", "sv", "util", "cap", "em", "act", "cam", "web", "ah", "aut", "ac", "AV", "img", "must", "ap", "ov", "var", "ame", "af"], "config": ["server", "rc", "cf", "param", "metadata", "tc", "settings", "fig", "conn", "about", "setup", "cmd", "ctx", "crit", "auth", "lib", "storage", "cc", "man", "access", "acc", "comm", "spec", "sec", "cache", "cap", "command", "program", "ct", "connection", "desc", "cfg", "context", "control", "ac", "c", "cal", "support", "ec", "apache", "client", "gc", "args", "bc", "unknown", "etc", "fc", "con", "conf", "enc", "cont", "net", "Config", "option", "filter", "network", "exec", "anc"], "st": ["ste", "est", "sw", "serv", "St", "ST", "ist", "sl", "sam", "sv", "ct", "rest", "irst", "ost", "stage", "sp", "ust", " ST", "std", "fr", "mt", "se", "ast", "sn", "sts", "inst", "sc", "str"], "opts": ["OPmitted", "opmitted", "OPps", "opt", "optmitted", "opct", "opats", "opls", "popats", "Opct", "ioprs", "opps", " opct", "Options", " opents", " opt", "okents", "optx", "OPfs", "iopt", " oprs", "Opts", "ioptx", "popts", " opams", " opfs", "opals", " opals", "OPt", "opfs", "OPcs", "Opams", " opls", "poprs", "popt", "Opcs", "otls", "iopats", "oprs", " copts", "OPtr", " optx", " opms", "opcs", "opms", "iopents", "okms", " opmitted", "optr", "optte", "oktx", " options", " copfs", " opte", "optt", "options", "opte", "Opls", "Opt", "optts", "otts", "OPals", " coprs", " copps", " opats", "OPrs", "OPte", "optals", "opents", " opps", "okts", "iopms", "opttr", "ottions", "iopts", "OPts", " opcs", "otams", "opams", "OPct", " optr"], "recommended": ["extculated", "suspended", "gemmented", "comculated", "optimENDED", "recommculated", "optimending", "challassed", "browseradded", "recentended", "browserened", "challended", "suggestassed", "replends", "friendassed", "gemferred", "browserended", "comENDED", "recommented", "virtualented", "suggestential", "comends", "optimened", "suggestmented", "friendened", "comferred", "suggestened", "comending", "recentened", "recommferred", "gemended", "commender", "virtualENDED", "suggestENDED", "recentculated", "replended", "virtualmented", "recommmented", "suggestented", "suspadded", "recommassed", "challential", "recommened", "comend", "extended", "commended", "extend", "virtualened", "gemened", "suggestferred", "commmented", "recommadded", "challened", "replened", "gemender", "recentend", "optimends", "comended", "optimented", "virtualadded", "suspmented", "friendential", "extened", "optimended", "friendended", "recommential", "recommends", "suggestended", "virtualended", "recommENDED", "gemENDED", "suspened", "commened", "recommender", "suggestender", "replending", "recommend", "browsermented", "recommending", "comened"], "enc_config": ["ev_desc", "enc_desc", "ev_config", "enc_conf", "ev_conf", "enc_cfg", "ev_cfg"]}}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void qmp_output_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    QObject *value = qmp_output_pop(qov);\n\n    assert(qobject_type(value) == QTYPE_QDICT);\n\n}\n", "idx": 15582, "substitutes": {"v": ["vv", "nv", "f", "o", "tv", "V", "l", "j", "p", "n", "vr", "vi", "conv", "g", "t", "sv", "m", "r", "vm", "c", "inv", "cv", "vs", "ov", "b", "vim", "h", "nov", "u", "qv", "d", "uv", "q", "vc", "vt", "ev", "i", "w", "x", "iv", "av"], "errp": ["rP", "errr", "erP", "rp", " errr", "err", "erp", " errP", "rr", "errP"], "qov": [" queryov", "quaven", "dqOV", " queryova", "qOV", "dqaven", "sqaven", "dqhov", "sqOV", " qhov", " queryhov", " qOV", "sqov", "qhov", "quov", "quOV", "qugov", "dqov", "sqgov", " queryOV", "dqgov", "qgov", "qova", "dqova", "qaven", " qova"], "value": ["bar", "server", "key", "instance", "version", "position", "object", "values", "other", "raw", "val", "widget", "model", "field", "unit", "initial", "ward", "result", "VALUE", "now", "item", "select", "tree", "Value", "json", "attribute", "buffer", "image", "remote", "null", "create", "property", "hello", "python", "unknown", "serial", "total", "component", "language"]}}
{"project": "FFmpeg", "commit_id": "ae4c9ddebc32eaacbd62681d776881e59ca6e6f7", "target": 1, "func": "void compute_images_mse_16bit(PSNRContext *s,\n\n                        const uint8_t *main_data[4], const int main_linesizes[4],\n\n                        const uint8_t *ref_data[4], const int ref_linesizes[4],\n\n                        int w, int h, double mse[4])\n\n{\n\n    int i, c, j;\n\n\n\n    for (c = 0; c < s->nb_components; c++) {\n\n        const int outw = s->planewidth[c];\n\n        const int outh = s->planeheight[c];\n\n        const uint16_t *main_line = (uint16_t *)main_data[c];\n\n        const uint16_t *ref_line = (uint16_t *)ref_data[c];\n\n        const int ref_linesize = ref_linesizes[c] / 2;\n\n        const int main_linesize = main_linesizes[c] / 2;\n\n        uint64_t m = 0;\n\n\n\n        for (i = 0; i < outh; i++) {\n\n            for (j = 0; j < outw; j++)\n\n                m += pow2(main_line[j] - ref_line[j]);\n\n            ref_line += ref_linesize;\n\n            main_line += main_linesize;\n\n        }\n\n        mse[c] = m / (double)(outw * outh);\n\n    }\n\n}\n", "idx": 15589, "substitutes": {"s": ["ses", "gs", "a", "S", "f", "sw", "less", "n", "p", "js", "ex", "sq", "v", "g", "sl", "sam", "t", "comm", "spec", "sb", "sv", "hs", "ats", "m", "r", "sim", "sc", "ts", "stats", "ins", "b", "ns", "cs", "an", "ims", "set", "e", "fs", "conf", "os", "d", "se", "ss", "sts", "scl", "span", "rs", "ps"], "main_data": ["mainxdevice", "ref__lines", "ref__data", "main_DATA", "mainmopdat", "mainmopdata", "main_device", " main_devices", "mainxdat", "ref__dat", "main_devices", "main__lines", "ref_dat", "mainxdevices", "mainitydata", "ref__DATA", "main__dat", "mainitylines", "mainmopdevice", "mainitydat", "main_dat", "ref_DATA", "main__data", " main_device", "mainityDATA", "mainmopdevices", "mainxdata", "ref_lines", "main_lines", " main_dat", "main__DATA"], "main_linesizes": ["main_pointsize", "main_lineizes", "main_pointsizers", "main_pointsizes", "main_lineizations", "main_inesize", "main_inesizers", "main_pointsizations", "main_lineizers", "main_setsize", "main_linesizers", "main_setsizes", "main_inesizes", "main_setsizations", "main_lineize", "main_inesizations", "main_setsizers", "main_linesize", "main_linesizations"], "ref_data": ["ref___bytes", "ref_results", "ref___table", "reference_points", "ref___data", "reference_data", "ref_dat", "alt_dat", "alt_table", "reference_bytes", "alt_data", "ref___points", "reference_table", "alt_results", "ref_points", "ref_table", "ref_bytes"], "ref_linesizes": ["ref_lineizes", "ref_lineize", "ref_linize", "ref_linesights", "ref_linsizations", "ref_linesizers", "ref_linights", "ref_inesize", "ref_linesize", "ref_linizations", "ref_inesights", "ref_linesizations", "ref_linsize", "ref_linsights", "ref_inesizers", "ref_linizes", "ref_inesizes", "ref_inesizations", "ref_lineizers", "ref_linizers", "ref_linsizes"], "w": ["wh", "nw", "fw", "sw", "rw", "aw", "l", "hw", "n", "wl", "v", "wa", "wt", "wn", "ew", "iw", "wid", "we", "wp", "wd", "W", "wi", "wr", "win", "x"], "h": ["wh", "o", "kh", "high", "l", "hw", "bh", "v", "height", "ih", "k", "th", "hi", "he", "oh", "ht", "ho", "H", "ish", "hl", "length", "z", "hh", "how", "gh", "zh", "ch"], "mse": ["mnae", "mrsex", "cmge", "mrse", " msem", "mge", "cmze", "mnsex", "mrae", "mnse", " mae", " msex", "mae", "mze", "smsem", "cmsem", "mrsem", " mge", "smze", "smse", "msem", "cmse", "smge", "msex", "mnsem", " mze"], "i": ["ij", "index", "li", "at", "iu", "out", "mi", "ii", "I", "pi", "ini", "l", "ind", "n", "p", "ei", "ex", "si", "zi", "ki", "v", "g", "bi", "io", "t", "ui", "ia", "di", "ami", "k", "m", "ai", "r", "ie", "hi", "xi", "qi", "im", "ci", "b", "id", "ti", "u", "multi", "it", "gi", "z", "phi", "x", "y", "ic", "ix", "ip"], "c": ["cor", "rc", "cu", "cf", "co", "f", "cr", "tc", "unc", "cm", "cus", "lc", "l", "ctx", "n", "p", "cc", "cd", "v", "chain", "g", "ar", "t", "cache", "dc", "cat", "ct", "cam", "cation", "cy", "uc", "r", "sc", "ac", "C", "count", "xc", "cv", "abc", "nc", "ci", "ec", "cp", "gc", "mc", "cs", "bc", "pc", "fc", "e", "con", "conf", "cont", "u", "\u00e7", "col", "ca", "coll", "ce", "anc", "category", "ch"], "j": ["ij", "jp", "key", "o", "kh", "out", "jit", "ind", "l", "p", "n", "js", "aj", "str", "jas", "kid", "bj", "v", "g", "ng", "pt", "xy", "ge", "t", "uj", "note", "bo", "di", "job", "k", "br", "m", "r", "obj", "json", "ja", "dj", "J", "oj", "jj", "b", "jump", "jo", "e", "jl", "jc", "_", "ji", "it", "ne", "kj", "z", "q", "je", "y", "ix", "ch", "jac"], "main_line": ["main_channel", "main___Line", "main___lin", " main_Line", "main_cell", "main_row", "main___line", "ref_Line", "ref_cell", "main_link", "main_lin", " main_block", "main_block", "ref_lin", "main___row", "ref_row", "ref_link", "main_Line", " main_channel"], "ref_line": ["orig_path", "ref_entry", "rel_line", " ref_page", "ref___entry", "ref___page", "ref___data", "ref_Line", "ref_page", "ref_block", "ref_path", "rel_data", "rel___data", "ref___line", "orig_Line", "rel___page", "ref___block", "rel_page", "rel_block", "rel___block", "orig_line", "ref___Line", "orig_entry", "ref___path", "rel___line"]}}
{"project": "qemu", "commit_id": "0dacea92d26c31d453c58de2e99c178fee554166", "target": 1, "func": "putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)\n\n{\n\n    uint32_t sum;\n\n\n\n    if (cse && cse < n)\n\n        n = cse + 1;\n\n    if (sloc < n-1) {\n\n        sum = net_checksum_add(n-css, data+css);\n\n        stw_be_p(data + sloc, net_checksum_finish(sum));\n\n    }\n\n}\n", "idx": 15594, "substitutes": {"sum": ["vol", "am", "alph", " summed", "mem", "score", "um", "tu", " summ", "aw", " num", "cmp", "si", "ut", "umm", "v", "g", "sam", "acc", "mix", "ass", "cache", "result", "su", "num", "mean", "sa", "gram", " total", "match", "sim", "add", "mm", "count", "cal", "Sum", "cum", "summary", "ul", "fac", "h", " Sum", "hash", "total", "se", "gam", "ss", "us"]}}
{"project": "qemu", "commit_id": "84aa07f109f0afaeeec63c159f3a578b955c3de9", "target": 0, "func": "uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,\n\n                       uint32_t r3)\n\n{\n\n    uintptr_t ra = GETPC();\n\n    uint64_t destlen = get_length(env, r1 + 1);\n\n    uint64_t dest = get_address(env, r1);\n\n    uint64_t srclen = get_length(env, r3 + 1);\n\n    uint64_t src = get_address(env, r3);\n\n    uint8_t pad = a2 & 0xff;\n\n    uint32_t cc = 0;\n\n\n\n    if (!(destlen || srclen)) {\n\n        return cc;\n\n    }\n\n\n\n    if (srclen > destlen) {\n\n        srclen = destlen;\n\n    }\n\n\n\n    for (; destlen || srclen; src++, dest++, destlen--, srclen--) {\n\n        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;\n\n        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, dest, ra) : pad;\n\n        if (v1 != v2) {\n\n            cc = (v1 < v2) ? 1 : 2;\n\n            break;\n\n        }\n\n    }\n\n\n\n    set_length(env, r1 + 1, destlen);\n\n    /* can't use srclen here, we trunc'ed it */\n\n    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);\n\n    set_address(env, r1, dest);\n\n    set_address(env, r3, src);\n\n\n\n    return cc;\n\n}\n", "idx": 15615, "substitutes": {"env": ["conn", "et", "manager", "ctx", "hw", "window", "den", "En", "end", "context", "cb", "console", "en", "vs", "net", "queue", "pkg", "gear", "forge", "te", "tx", "rc", "esm", "ptr", "environment", "cmd", "erd", "v", "dt", "outer", "stack", "shell", "obj", "db", "pg", "hl", "enter", "eng", "EN", "pe", "server", "nv", "nw", "ner", "req", "proc", "vp", "erb", "sb", "er", "buf", "np", "era", "org", "info", "cv", "ec", "ager", "dev", "enc", "config", "err", "eh", "ev", "vt", "estate", "esc", "pp", "msg", "desc", "ew", "ah", "gate", "vm", "event", "code", "here", "e", "entry", "ve", "w", "init", "worker"], "r1": ["rc1", "mr1", "r4", "rt2", "ar7", " r5", "r0", "r2", " r4", "rc3", "rc91", "rc5", "rt0", " r91", "ar5", "ar1", " r7", "rc2", "mr01", "rt91", "mr3", "R1", " r2", "ar0", "R01", " r01", "R2", "rc01", "r5", "ar2", "rt1", "rc4", "r01", "r7", " r0", "r91", "R4", "ar01", "rc7", "rc0", "mr4", "R7"], "a2": ["aa2", "ta2", "w2", "ta4", "atwo", "c4", "c2", "sha4", "w02", "ca2", "ca5", "sha5", "c5", "tatwo", "aa4", "a4", "sha2", "a5", "ca4", "a02", "ta02", "w4", "wtwo", "aa02", "aatwo"], "r3": ["rc1", "p30", "p1", " r30", "r4", "usr7", "arThree", "nr7", " rthree", "rc21", "pr53", "nr03", "rcthree", " r5", "ar53", "usrthree", "r0", "rc3", "usr3", "r2", " r4", " r6", "R3", "rc5", "nr21", "r21", " r03", "nr3", " r7", "rc43", "rc2", "nr4", "rcUST", "r53", " r2", "ar0", "R2", "pr3", "R5", "rc53", "r6", " rUST", "r5", "ar3", "rc30", "p5", "ar2", "rUST", "rc4", "nrUST", " r43", "usr43", "rthree", " rThree", "rc6", " r21", "r7", " r0", "pr0", "R6", "rc7", " r53", "rc0", "rc03", "r03", "r30", "rThree", "prThree", "p3", "r43"], "src": ["rc", "inst", "sing", "ptr", "serv", "cur", "attr", "addr", "stream", "rl", "sur", "proc", "sl", "ctr", "syn", "source", "loc", "sb", "st", "via", "sys", "origin", "rb", "ur", "dist", "in", "desc", "rest", "rt", "rib", "sp", "sel", "ource", "sr", "pos", "trans", "pri", "ins", "comp", "ser", "input", "rec", "rob", "tmp", "rel", "iter", "from", "tp", "sn", "iv", "supp", "sc", "usr", "rs", "sub"], "dest": ["des", "est", "ptr", "sw", "orig", "out", "data", "addr", "tr", "sur", "dir", "dis", "v", "port", "gen", "source", "loc", "priv", "st", "end", "origin", "result", "dist", "desc", "rest", "gt", "Dest", "decl", "sp", "trans", "pos", "ser", "master", "dev", " dst", "dep", "rel", "iter", "prop", "win", "pas", "target", "del", "pl", "home", "sc", "usr", "cont"], "destlen": ["estln", "srcln", "disten", "devl", "estlength", "srccompl", "descen", "estlen", "desclen", "descl", "Destlength", "destLen", "destlength", "destcoll", "Desten", "destelt", "destenc", " desten", " destlon", "Destcompl", "descelt", "deststr", "esten", "srccoll", "srcLen", " destLen", "targetLen", "srcstr", "estelt", " destcompl", "devenc", "destlan", "distlength", "targeten", "DestLen", "sourcelen", "srclength", "targetstr", "targetlength", "destln", "destl", "Destl", "desten", " deststr", "distlen", "sourcelon", " destcoll", "targetcoll", "destlon", "devlen", " destlength", " destelt", " destln", "targetl", "estl", "targetlen", "devln", " destenc", "estlan", " destlan", "sourcelength", "Destlen", "destcompl", "srcl", "descenc", "descln", "distLen", " destl", "srclan", "desclength", "desclon"], "srclen": ["srchent", "rgcleng", "srdeclene", "srplar", "srdeclim", "rnclen", "srcileng", "srcilEN", "srdecline", "srclar", "srcleng", "sercolene", "rlchower", "ctrclEN", "srchener", "srcollar", "srcolim", "srplEN", " srselist", "rnclar", "srClEN", "srceloc", "ctrcilener", "srceloen", "sercolim", "rlchent", "srclent", "srchEN", "rgclen", "srfcent", "srcelEN", "sercline", "rgcileng", "srcolower", "rgcilener", "rlclen", "srblim", "srcoloen", "srpleng", "srcollen", " srclEN", "srplog", "srflener", "srclim", "srcelower", "srfcen", "rncolloen", "srcloen", "srsclog", "srcloc", "ctrclens", "srchen", "srselist", "srplist", "srcelleng", "srClener", "sercoline", " srclist", "srcelar", " srselower", "srflen", "srcolen", "rncollar", "srclog", "rgclener", "rncloen", "slsclog", "srcellen", "ctrcilen", "rncollog", " srselEN", "srClens", " srclower", "srselower", "ctrcilEN", "srsclen", "srcolene", "slscleng", "srcilener", "srcollog", "srblen", "sercolen", "srbline", "srplener", "slclen", "srselen", "srscleng", "srceleng", "srcolloen", "srdeclen", "srcilen", "srClen", "srfcoen", "srcoline", "srfleng", "rgcilen", "srchoen", "rnclog", "srplower", "srclist", "srchens", "ctrcilens", "slsclen", "srblene", "slcleng", "rlchen", "srcelloc", "serclene", "srfcower", "rgclog", "ctrclen", "rlclent", "srplen", "ctrclener", "slcloc", "rncollen", "srclower", "rlcloen", "rlclower", "srchower", "slclog", "srcilog", "srploen", "srcelist", " srselen", "srflog", "srselEN", "serclen", "srclener", "srcilens", "srscloc", "serclim", "srcelog", "rlchoen", "srcelen", "srclEN", "slscloc", "srclens", "rgcilog", "srcolent", "srclene", "srcline", "srcellog"]}}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "void *bios_linker_loader_cleanup(GArray *linker)\n\n{\n\n    return g_array_free(linker, false);\n\n}\n", "idx": 15634, "substitutes": {"linker": ["linked", " linkler", "inkor", " linkger", "inkger", "loader", "inkener", "linke", "linkener", "linkler", "inker", "loadler", "streamor", " linkener", " linkor", "inke", "inked", "loaded", "streamer", "loade", "streamener", " linked", "inkler", "linkor", "streamger", " linke", "linkger"]}}
{"project": "qemu", "commit_id": "36778660d7fd0748a6129916e47ecedd67bdb758", "target": 0, "func": "const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,\n\n                                             hwaddr ptex, int n)\n\n{\n\n    ppc_hash_pte64_t *hptes = NULL;\n\n    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;\n\n\n\n    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {\n\n        /*\n\n         * HTAB is controlled by KVM. Fetch into temporary buffer\n\n         */\n\n        hptes = g_malloc(HASH_PTEG_SIZE_64);\n\n        kvmppc_read_hptes(hptes, ptex, n);\n\n    } else if (cpu->env.external_htab) {\n\n        /*\n\n         * HTAB is controlled by QEMU. Just point to the internally\n\n         * accessible PTEG.\n\n         */\n\n        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);\n\n    } else if (cpu->env.htab_base) {\n\n        hwaddr plen = n * HASH_PTE_SIZE_64;\n\n        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,\n\n                                 &plen, false);\n\n        if (plen < (n * HASH_PTE_SIZE_64)) {\n\n            hw_error(\"%s: Unable to map all requested HPTEs\\n\", __func__);\n\n        }\n\n    }\n\n    return hptes;\n\n}\n", "idx": 15644, "substitutes": {"cpu": ["thread", "jp", "rpm", "cu", "machine", "pu", "CPU", "conn", "phys", "onet", "cn", "hz", "core", "ctx", "cmd", "hw", "call", "linux", "p", "proc", "upt", "aq", "cli", "boot", "pool", "du", "np", "sys", "processor", "num", "php", "bench", "lock", "ork", "uu", "pai", "aux", "phy", "ruby", "library", "runner", "mu", "parse", "ck", "c", "nc", "cum", "sync", "cp", "gc", "nic", "gnu", "execute", "rom", "apache", "pc", "gp", "pid", "gpu", "prof", "tp", "component", "ram", "pkg", "us", "sc", "process", "exec", "anc", "nu", "clock"], "ptex": ["iptEX", "ptyEx", "petexe", "ptxe", "iptexe", "ptext", "petEX", " ptEX", " ptext", "ipthex", "iptex", "ptEX", "iptEx", "ptyEX", "petxe", "eptex", "iptext", "pointEx", "pointext", " pthex", "pointhex", "iptxe", "ptexe", "iptrx", "petex", "eptexe", "ptrx", "ptyex", "ptyrx", "eptxe", "eptEX", "pointrx", "pointex", "pointEX", "ptEx", "pthex"], "n": ["nv", "nl", "ni", "nw", "nor", "number", "o", "dn", "cn", "l", "j", "p", "v", "g", "ng", " N", "t", "note", "np", "num", "nr", "nt", "k", "N", "m", "c", "count", "en", "nc", "mn", "ns", "b", "nn", "u", "non", "d", "nb", "ne", "ity", "net", "sn", "nan", "nm", "name", "i", "y", "w", "nu", "na"], "hptes": ["hportses", "phpte", " hmintes", "hptis", "hportedes", "phptedes", "hpledes", "hiptses", "hmintses", "hiptis", "hepointices", " haptedes", " hpeteps", "phpted", "hpetes", "phported", " hptis", "hapte", "hptices", "hapted", "hpties", "hepointzes", "htopzes", "hpointices", "hpted", "hcertzes", " hpte", " hpetES", " hptves", "hmintves", "htopes", "hple", "hpse", " hpointies", "hpsES", "hepointese", "hcertices", "hposses", " hpointis", " hpteps", "hcertese", " hmintses", "hepointes", "hpteps", " hpetes", "hiptises", " hpties", "hcertes", "phportes", "hpointES", "hpointis", "hpseps", "hptves", " hmintves", "hposves", "hportes", "haptes", "hportES", "hpointies", "haptises", "hposes", " hpete", "hpete", "hpses", "heptices", "heptese", "hpres", "hpointese", " hptES", "haptedes", "hptses", "hpredes", "hiptedes", "heptzes", "hportis", "hpre", " hptedes", "hpte", "hposES", "heptes", " hmintES", "htopices", "hpetES", "hiptes", " hptises", "hmintES", "hptedes", "hipte", "hplises", " hpointses", " hptses", "hptES", " hpointes", "phptes", " hapte", "hptzes", "phportedes", "hpeteps", "hptises", " haptes", "htopese", "phporte", "hples", "hipties", "hportves", "hpointes", "hpointeps", " haptises", "hporte", "hpointses", "hported", "hpred", "hptese", "hporties", "hpointzes", "hmintes", "hpointe"]}}
{"project": "qemu", "commit_id": "ecf5e8eae8b0b5fa41f00b53d67747b42fd1b8b9", "target": 0, "func": "static inline bool regime_translation_disabled(CPUARMState *env,\n\n                                               ARMMMUIdx mmu_idx)\n\n{\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        switch (env->v7m.mpu_ctrl &\n\n                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK:\n\n            /* Enabled, but not for HardFault and NMI */\n\n            return mmu_idx == ARMMMUIdx_MNegPri ||\n\n                mmu_idx == ARMMMUIdx_MSNegPri;\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:\n\n            /* Enabled for all cases */\n\n            return false;\n\n        case 0:\n\n        default:\n\n            /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but\n\n             * we warned about that in armv7m_nvic.c when the guest set it.\n\n             */\n\n            return true;\n\n        }\n\n    }\n\n\n\n    if (mmu_idx == ARMMMUIdx_S2NS) {\n\n        return (env->cp15.hcr_el2 & HCR_VM) == 0;\n\n    }\n\n    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;\n\n}\n", "idx": 15653, "substitutes": {"env": ["server", "nv", "def", "network", "sw", "et", "manager", "environment", "dn", "estate", "ei", "cmd", "ctx", "ner", "window", "erd", "vp", "v", "esc", "sb", "er", "engine", "end", "ef", "em", "ten", "ew", "context", "ah", "era", "age", "cb", "cv", "en", "nc", "ec", "vs", "ov", "dev", "pg", "here", "e", "Environment", "door", "entry", "state", "config", "enter", "eng", "emb", "eh", "queue", "ev", "w", "forge", "te", "viron", "worker"], "mmu_idx": ["mmu_midk", "mmu_Idp", "mmu_pidxc", "mmu_idxc", "mmu_Idc", "mmu_idc", "mmu_idz", "mmu_idX", "mmu_midx", "mmu_idxf", "mmu_inc", "mmu_pidx", "mmu_midz", "mmu_Idz", "mmu_idk", "mmu_wifeX", "mmu_wifeex", "mmu_Idxc", "mmu_idw", "mmu_idez", "mmu_Idw", "mmu_pidxf", "mmu_idp", "mmu_midex", "mmu_wifek", "mmu_Idx", "mmu_wifex", "mmu_midp", "mmu_idex", "mmu_idew", "mmu_idexf", "mmu_inx", "mmu_Idxf", "mmu_inxf", "mmu_inxc", "mmu_midxf", "mmu_midX"]}}
{"project": "qemu", "commit_id": "2adba0a18a7950d14827e82d8068c1142ee87789", "target": 0, "func": "static void build_processor_devices(Aml *sb_scope, unsigned acpi_cpus,\n\n                                    AcpiCpuInfo *cpu, AcpiPmInfo *pm)\n\n{\n\n    int i;\n\n    Aml *dev;\n\n    Aml *crs;\n\n    Aml *pkg;\n\n    Aml *field;\n\n    Aml *ifctx;\n\n    Aml *method;\n\n\n\n    /* The current AML generator can cover the APIC ID range [0..255],\n\n     * inclusive, for VCPU hotplug. */\n\n    QEMU_BUILD_BUG_ON(ACPI_CPU_HOTPLUG_ID_LIMIT > 256);\n\n    g_assert(acpi_cpus <= ACPI_CPU_HOTPLUG_ID_LIMIT);\n\n\n\n    /* create PCI0.PRES device and its _CRS to reserve CPU hotplug MMIO */\n\n    dev = aml_device(\"PCI0.\" stringify(CPU_HOTPLUG_RESOURCE_DEVICE));\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A06\")));\n\n    aml_append(dev,\n\n        aml_name_decl(\"_UID\", aml_string(\"CPU Hotplug resources\"))\n\n    );\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, pm->cpu_hp_io_base, pm->cpu_hp_io_base, 1,\n\n               pm->cpu_hp_io_len)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(sb_scope, dev);\n\n    /* declare CPU hotplug MMIO region and PRS field to access it */\n\n    aml_append(sb_scope, aml_operation_region(\n\n        \"PRST\", AML_SYSTEM_IO, aml_int(pm->cpu_hp_io_base), pm->cpu_hp_io_len));\n\n    field = aml_field(\"PRST\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n    aml_append(field, aml_named_field(\"PRS\", 256));\n\n    aml_append(sb_scope, field);\n\n\n\n    /* build Processor object for each processor */\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        dev = aml_processor(i, 0, 0, \"CP%.02X\", i);\n\n\n\n        method = aml_method(\"_MAT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call1(CPU_MAT_METHOD, aml_int(i))));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"_STA\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call1(CPU_STATUS_METHOD, aml_int(i))));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"_EJ0\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call2(CPU_EJECT_METHOD, aml_int(i), aml_arg(0)))\n\n        );\n\n        aml_append(dev, method);\n\n\n\n        aml_append(sb_scope, dev);\n\n    }\n\n\n\n    /* build this code:\n\n     *   Method(NTFY, 2) {If (LEqual(Arg0, 0x00)) {Notify(CP00, Arg1)} ...}\n\n     */\n\n    /* Arg0 = Processor ID = APIC ID */\n\n    method = aml_method(AML_NOTIFY_METHOD, 2, AML_NOTSERIALIZED);\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        ifctx = aml_if(aml_equal(aml_arg(0), aml_int(i)));\n\n        aml_append(ifctx,\n\n            aml_notify(aml_name(\"CP%.02X\", i), aml_arg(1))\n\n        );\n\n        aml_append(method, ifctx);\n\n    }\n\n    aml_append(sb_scope, method);\n\n\n\n    /* build \"Name(CPON, Package() { One, One, ..., Zero, Zero, ... })\"\n\n     *\n\n     * Note: The ability to create variable-sized packages was first\n\n     * introduced in ACPI 2.0. ACPI 1.0 only allowed fixed-size packages\n\n     * ith up to 255 elements. Windows guests up to win2k8 fail when\n\n     * VarPackageOp is used.\n\n     */\n\n    pkg = acpi_cpus <= 255 ? aml_package(acpi_cpus) :\n\n                             aml_varpackage(acpi_cpus);\n\n\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        uint8_t b = test_bit(i, cpu->found_cpus) ? 0x01 : 0x00;\n\n        aml_append(pkg, aml_int(b));\n\n    }\n\n    aml_append(sb_scope, aml_name_decl(CPU_ON_BITMAP, pkg));\n\n}\n", "idx": 15654, "substitutes": {"sb_scope": ["sg_script", "SB_stack", "sbfScope", "sbfstyle", "sbjScope", "sb__scope", "cb_buffer", "sb_style", "sbptscope", "SB_root", "lb_device", "SB_scope", "sb_trigger", "sg_Scope", "sblybuffer", "sbldScope", "sb_device", "sb__stack", "lb_scope", "sbfscript", "sb_root", "sbldscope", "cb_scope", "SB_store", "sbldtrigger", "cb_project", "sbfscope", "sblyScope", "lb_trigger", "sb__store", "sbjscope", "sbldproject", "sbldbuffer", "sg_style", "sb__root", "sbjscript", "sbjstyle", "sb_script", "sg_scope", "sb_stack", "sblyproject", "sbptdevice", "sb_Scope", "sb_buffer", "sb_store", "cb_Scope", "sblddevice", "sbpttrigger", "sblyscope", "sb_project"], "acpi_cpus": ["acpi_capus", "acpi_comps", "acpi_capis", "acpi_CPs", "acpi_puus", "acpi_puut", "acpi_puu", "acpi_capu", "acpi_cput", "acpi_cputes", "acpi_compus", "acpi_plu", "acpi_compu", "acpi_cps", "acpi_capins", "acpi_caps", "acpi_cpores", "acpi_puores", "acpi_processut", "acpi_CPis", "acpi_CPu", "acpi_processores", "acpi_plutes", "acpi_cpu", "acpi_cpins", "acpi_caputes", "acpi_cpis", "acpi_processus", "acpi_plins", "acpi_CPus", "acpi_compis", "acpi_processu", "acpi_plus"], "cpu": ["cu", "pu", "CPU", "mem", "pi", "core", "hw", "cmp", "proc", "util", "processor", "uda", "uu", "phy", "vm", "ci", "cum", "cp", "gc", "pc", " cp", "pid", "gpu", "prof", "ram", "process", "pa", "clock"], "pm": ["am", "rpm", "pu", "gem", "py", "ph", "cm", "mi", "per", "asm", "pi", "pr", "pb", "p", "hm", "mr", "vp", "perm", "dm", "pt", "process", "sam", "ym", "pp", "rm", "em", "m", "vm", "dem", "sim", "bm", "mm", "wp", "po", "cp", "gm", "master", "mp", "pc", "mt", "pid", "prem", "prof", "ram", "px", "tm", "nm", "PM", "ms", "mx", "pa", "ps"], "i": ["index", " li", " di", "gu", "t", " pi", " ki", "ai", "m", " I", "xi", "qi", "ims", "it", " e", "li", "ind", "j", "ki", "n", "si", "zi", " ti", "v", "ui", " index", " bi", "im", "mc", "ti", "ex", "x", "ic", "ix", "ip", "f", "mi", "ii", "I", "pi", " iter", " si", "batch", "er", "di", " ii", " mi", "in", "sim", "c", "ci", " wi", "id", " ni", "multi", "me", "iu", "o", " j", "ini", " hi", "l", "p", "bi", "io", "r", "hi", " my", " multi", "e", "gi", " m", "init", "y"], "dev": ["index", "pu", "conn", "push", "attr", "hw", "DE", "devices", "raw", "val", "gu", "nt", "add", "cho", "adv", "serial", "develop", "app", "normal", "tech", "pro", "def", "des", "mem", "data", "cmd", "tr", "Device", "v", "md", "spec", "ow", "dd", "env", "dem", "api", "res", "device", "dep", "eng", "iv", "av", "nv", "DEV", "ver", "pi", "row", "proc", "scan", "disk", "info", "reader", "debug", "ach", "de", "ev", "package", "stable", "go", "handle", "roll", "p", "Dev", "el", "priv", "util", "off", "hd", "sd", "var", "pad", "ve", "w", "name"], "crs": [" crd", "acrs", "cRS", " cRS", "lcrs", "sps", "crc", " crc", " cps", "lcrc", "sres", "lRS", "acRS", "acrc", "cps", "lrs", "lrd", "lcps", "accs", "lcs", "crd", "cres", "ccs", " ccs", "lcws", "scs", "Ccs", "Crs", "Crd", "CRS", " cws", "Cres", "acps", " cres", "cws", "srs", "Cps", "lccs", "acws", "lcRS"], "pkg": ["ctx", "kg", "cmp", "lib", "module", "req", "proc", "dir", "conv", "spec", "kind", "util", "msg", "buf", "sys", "prefix", "db", "fp", "lp", "pos", "cp", "ack", "tmp", "rel", "init", "package", "packages", "pod", "pack"], "field": ["key", "def", "kw", "type", "f", "mount", "lf", "attr", "data", "ff", "map", "row", "FIELD", "v", "fields", "fe", "spec", "util", "offset", "Field", "op", "tag", "lock", "part", "dd", "message", "comment", "prefix", "info", "add", "handler", " Field", "file", "bf", "function", "link", "ment", "flag", "table", "term", "input", "label", "fc", "pair", "arg", "var", "list", "uf", "w", "name", "ld", "form"], "ifctx": ["ifconfig", "ifcontext", "iffkw", "IFctx", "IFcontext", "IFkw", "Ifctx", "Ifkw", "iffctx", "iffconfig", "Ifcontext", "ifkw", "Ifconfig", "iffcontext", "IFconfig"], "method": ["profile", "def", "path", "metadata", "mem", "manager", "f", "mount", "member", "hod", "utils", "attr", "fun", "cmd", "fd", "tr", "module", "call", "proc", "man", "cmp", "name", "Method", "access", "md", "spec", "sm", "util", "service", "result", "command", "func", "m", "message", "eth", "sim", "magic", "handler", "mm", "sp", "function", "property", "table", "METHOD", "mp", "tm", "interface", "package"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    E1000State *s = opaque;\n\n    unsigned int index = (addr & 0x1ffff) >> 2;\n\n\n\n    if (index < NREADOPS && macreg_readops[index])\n\n    {\n\n        return macreg_readops[index](s, index);\n\n    }\n\n    DBGOUT(UNKNOWN, \"MMIO unknown read addr=0x%08x\\n\", index<<2);\n\n    return 0;\n\n}\n", "idx": 15655, "substitutes": {"s": ["gs", "a", "S", "f", "o", "n", "p", "js", "sq", "v", "g", "sl", "t", "is", "sb", "sv", "hs", "ds", "r", "iss", "ess", "qs", "ts", "c", "stats", "b", "ns", "h", "es", "set", "e", "fs", "state", "z", "i", "ss", "w", "ms", "rs", "ps"]}}
{"project": "qemu", "commit_id": "c7dfbf322595ded4e70b626bf83158a9f3807c6a", "target": 1, "func": "static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)\n\n{\n\n    uint32_t len;\n\n\n\n    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {\n\n        DPRINTF(s, 1,\n\n                \"usb-ccid: not sending apdu to client, no card connected\\n\");\n\n        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);\n\n        return;\n\n    }\n\n    len = le32_to_cpu(recv->hdr.dwLength);\n\n    DPRINTF(s, 1, \"%s: seq %d, len %d\\n\", __func__,\n\n                recv->hdr.bSeq, len);\n\n    ccid_add_pending_answer(s, (CCID_Header *)recv);\n\n    if (s->card) {\n\n        ccid_card_apdu_from_guest(s->card, recv->abData, len);\n\n    } else {\n\n        DPRINTF(s, D_WARN, \"warning: discarded apdu\\n\");\n\n    }\n\n}\n", "idx": 15664, "substitutes": {"s": ["ses", "aws", "south", "gs", "S", "sw", "as", "settings", "bs", "has", "n", "js", "p", "sq", "details", "t", "us", "comm", "is", "sm", "sv", "sb", "source", "sys", "hs", "common", "spec", "ds", "ls", "ats", "r", "ies", "ssl", "qs", "ts", "c", "sp", "stats", "sync", "ns", "cs", "h", "es", "ims", "changes", "fs", "conf", "os", "bis", "aunts", "its", "z", "sports", "ss", "sts", "ms", "rs", "ps"], "recv": ["rcvr", "recordsv", "rcq", " recvc", "recvc", "Recv", "convr", "acceptV", "rcvc", "conmsg", "rcsv", "formsv", " recvs", "recmsg", "conv", "formvd", "Recvr", "reccv", "recvs", "conq", "Recvd", "formv", "priv", "rcvs", "recV", "rccv", "recvd", " recvr", "formvr", "recq", "Recmsg", "Recvs", "rcmsg", " reccv", "acceptv", "recordq", "recvr", "recordv", "recordV", "Recq", "rcV", "recsv", "RecV", " recmsg", " recsv", "acceptcv", "acceptq", "Recsv", "primsg", "rcv", " recvd", "privc", " recq", " recV", "priV"], "len": ["resp", "il", "Length", "lim", "nl", "vec", "mem", "ret", "lf", "Len", "ll", "size", "l", "lc", "seq", "n", "js", "ln", "fun", "lib", "L", "val", "sl", "el", "t", " clen", "loc", "msg", "fl", "offset", "num", "lang", "ls", "nt", "lis", "fil", "lon", " bl", "lp", "lic", "count", "en", "pos", " l", "ec", "lan", "oe", "bl", "length", "elt", "pl", "coll", "fin", "mn", " length", "ld"]}}
{"project": "FFmpeg", "commit_id": "17dc7c7a60798d3e1f78bad97423fb49c8dc1c1d", "target": 0, "func": "void ff_h264_pred_init_x86(H264PredContext *h, int codec_id)\n\n{\n\n    mm_flags = mm_support();\n\n\n\n#if HAVE_YASM\n\n    if (mm_flags & FF_MM_MMX) {\n\n        h->pred16x16[VERT_PRED8x8] = ff_pred16x16_vertical_mmx;\n\n        h->pred16x16[HOR_PRED8x8 ] = ff_pred16x16_horizontal_mmx;\n\n        h->pred8x8  [VERT_PRED8x8] = ff_pred8x8_vertical_mmx;\n\n        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_mmx;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_tm_vp8_mmx;\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_mmx;\n\n            h->pred4x4  [TM_VP8_PRED  ] = ff_pred4x4_tm_vp8_mmx;\n\n        }\n\n    }\n\n\n\n    if (mm_flags & FF_MM_MMX2) {\n\n        h->pred16x16[HOR_PRED8x8 ] = ff_pred16x16_horizontal_mmxext;\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_mmxext;\n\n        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_mmxext;\n\n        h->pred4x4  [DC_PRED     ] = ff_pred4x4_dc_mmxext;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_tm_vp8_mmxext;\n\n            h->pred8x8  [DC_PRED8x8   ] = ff_pred8x8_dc_rv40_mmxext;\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_mmxext;\n\n            h->pred4x4  [TM_VP8_PRED  ] = ff_pred4x4_tm_vp8_mmxext;\n\n            h->pred4x4  [VERT_PRED    ] = ff_pred4x4_vertical_vp8_mmxext;\n\n        }\n\n    }\n\n\n\n    if (mm_flags & FF_MM_SSE) {\n\n        h->pred16x16[VERT_PRED8x8] = ff_pred16x16_vertical_sse;\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_sse;\n\n    }\n\n\n\n    if (mm_flags & FF_MM_SSE2) {\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_sse2;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_tm_vp8_sse2;\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_sse2;\n\n        }\n\n    }\n\n\n\n    if (mm_flags & FF_MM_SSSE3) {\n\n        h->pred16x16[HOR_PRED8x8 ] = ff_pred16x16_horizontal_ssse3;\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_ssse3;\n\n        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_ssse3;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_ssse3;\n\n            h->pred4x4  [TM_VP8_PRED  ] = ff_pred4x4_tm_vp8_ssse3;\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 15679, "substitutes": {"h": ["mem", "uh", "go", "sw", "ph", "kh", "hr", "header", "head", "l", "hz", "hw", "hm", "p", "window", "dr", "bh", "v", "g", "http", "comm", "ih", "help", "ow", "hs", "cache", "er", "pp", "br", "php", "m", "ah", "th", "he", "html", "info", "hd", "c", "console", "rh", "event", "oh", "sh", "ssh", "ht", "H", "host", "each", "u", "hl", "hash", "it", "dh", "eh", "q", "z", "hh", "w", "x", "y", "history", "ch", "hp"], "codec_id": ["codisc_ids", "codecOid", "codec_type", "codecNamevid", "codcamOdir", "codisc_ID", "codecixid", "codcam_hash", "codecNameid", "codisc_id", "codect_init", "codisc_type", "codec3vid", "codec_source", "codect_id", "codec_dir", "codec2id", "codcam_id", "codecOkid", "codcamOhash", "codec_kid", "codcam_dir", "codec__id", "codec_init", "codec3source", "codect_source", "codec__type", "codcamOid", "codec2ID", "codec3id", "codcam_kid", "codec__ID", "codecOhash", "codec_vid", "codec_ids", "codec_ID", "codecNameinit", "codecEdir", "codecEhash", "codec_hash", "codec2ids", "codecixdir", "codect_vid", "codecEkid", "codecNamesource", "codecixkid", "codcamOkid", "codecEid", "codec2type", "codec3init", "codecixhash", "codecOdir", "codec__ids"]}}
{"project": "qemu", "commit_id": "c7e35da348e2e4df072e6979c48fa5283e07d1db", "target": 1, "func": "static inline abi_long target_to_host_timespec(struct timespec *host_ts,\n\n                                               abi_ulong target_addr)\n\n{\n\n    struct target_timespec *target_ts;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))\n\n        return -TARGET_EFAULT;\n\n    host_ts->tv_sec = tswapal(target_ts->tv_sec);\n\n    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);\n\n    unlock_user_struct(target_ts, target_addr, 0);\n\n    return 0;\n\n}\n", "idx": 15690, "substitutes": {"host_ts": ["host_tt", "console_ptr", "console_ps", "consoleThett", " host_ptr", "console_ts", "consoleTheptr", "host_times", " host_ms", "hostTheptr", " host_tes", " host_sts", "hostThett", "consoleTheps", "hostptsts", "console_tt", "hostptts", " host_tt", "hostpttes", "hostTheps", " host_times", "hostThets", "host_tes", "host_ms", "host_sts", "host_ps", "consoleThets", "hostptms", "host_ptr"], "target_addr": [" target_address", "target_cb", " target_cb", " target_ptr", "target__addr", "target_ptr", "target__address", " target_mt", "target_adr", "target_mt", "target__ptr", "target_ad", " target_ad", "target__cb", " target_adr", "target_address"], "target_ts": ["arget____tim", "target____ts", "target____tp", "arget_tim", "target_ptr", "arget_ts", "arget_ss", "targetThets", "targetThetis", "host_ps", "target_ss", "arget____tp", "target_times", "target_tes", "target_tp", "arget____tis", "target_tim", "host_ats", "target_mt", "arget_tp", "host_mt", "host_ptr", "target_cs", "host_cs", "host_times", "target____tis", "target_ats", "arget____ts", "target_uts", "target_ps", "target_sta", "targetThetp", "host_uts", "arget_tis", "targetThetim", "arget_sta", "target_tis", "target____tim", "host_tes"]}}
{"project": "qemu", "commit_id": "5039d6e23586fe6bbedc5e4fe302b48a66890ade", "target": 0, "func": "void DMA_init(int high_page_enable, qemu_irq *cpu_request_exit)\n\n{\n\n}\n", "idx": 15696, "substitutes": {"high_page_enable": [" cpu_memory_enable", " cpu_page_disable", " cpu_page_enable", " cpu_memory_start", " cpu_page_enabled", " cpu_memory_disable", " cpu_memory_enabled", " cpu_page_start"], "cpu_request_exit": ["cpu_requestlyexit", "cpu_requestlylimit", "cpu_request_start", "cpu_page_start", "cpu_request_enable", "cpu_page_exit", "cpu_requestlystart", "cpu_page_limit", "cpu_page_enable", "cpu_request_limit", "cpu_requestlyenable"]}}
{"project": "FFmpeg", "commit_id": "51a1c1c6ac98d1d0d0a654f066782707af092fed", "target": 0, "func": "static void decode_delta_l(uint8_t *dst,\n\n                           const uint8_t *buf, const uint8_t *buf_end,\n\n                           int w, int flag, int bpp, int dst_size)\n\n{\n\n    GetByteContext off0, off1, dgb, ogb;\n\n    PutByteContext pb;\n\n    unsigned poff0, poff1;\n\n    int i, k, dstpitch;\n\n    int planepitch_byte = (w + 7) / 8;\n\n    int planepitch = ((w + 15) / 16) * 2;\n\n    int pitch = planepitch * bpp;\n\n\n\n    if (buf_end - buf <= 64)\n\n        return;\n\n\n\n    bytestream2_init(&off0, buf, buf_end - buf);\n\n    bytestream2_init(&off1, buf + 32, buf_end - (buf + 32));\n\n    bytestream2_init_writer(&pb, dst, dst_size);\n\n\n\n    dstpitch = flag ? (((w + 7) / 8) * bpp): 2;\n\n\n\n    for (k = 0; k < bpp; k++) {\n\n        poff0 = bytestream2_get_be32(&off0);\n\n        poff1 = bytestream2_get_be32(&off1);\n\n\n\n        if (!poff0)\n\n            continue;\n\n\n\n        if (2LL * poff0 >= buf_end - buf)\n\n            return;\n\n\n\n        if (2LL * poff1 >= buf_end - buf)\n\n            return;\n\n\n\n        bytestream2_init(&dgb, buf + 2 * poff0, buf_end - (buf + 2 * poff0));\n\n        bytestream2_init(&ogb, buf + 2 * poff1, buf_end - (buf + 2 * poff1));\n\n\n\n        while ((bytestream2_peek_be16(&ogb)) != 0xFFFF) {\n\n            uint32_t offset = bytestream2_get_be16(&ogb);\n\n            int16_t cnt = bytestream2_get_be16(&ogb);\n\n            uint16_t data;\n\n\n\n            offset = ((2 * offset) / planepitch_byte) * pitch + ((2 * offset) % planepitch_byte) + k * planepitch;\n\n            if (cnt < 0) {\n\n                bytestream2_seek_p(&pb, offset, SEEK_SET);\n\n                cnt = -cnt;\n\n                data = bytestream2_get_be16(&dgb);\n\n                for (i = 0; i < cnt; i++) {\n\n                    bytestream2_put_be16(&pb, data);\n\n                    bytestream2_skip_p(&pb, dstpitch - 2);\n\n                }\n\n            } else {\n\n                bytestream2_seek_p(&pb, offset, SEEK_SET);\n\n                for (i = 0; i < cnt; i++) {\n\n                    data = bytestream2_get_be16(&dgb);\n\n                    bytestream2_put_be16(&pb, data);\n\n                    bytestream2_skip_p(&pb, dstpitch - 2);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 15723, "substitutes": {"dst": ["Dust", "dost", "dnsrc", "Dst", "dndest", "sddest", "Dost", "lust", " dost", "ddest", " dsts", "sdost", "Ddest", "lst", "dnst", " ddest", "ldest", "Dsrc", "dust", "Dsts", "sdsts", "dsts", "sdst", "lsrc", "dsrc", "dnust"], "buf": ["vec", "orig", "cur", "window", "raw", "pool", "port", "end", "doc", "cb", "fp", "uffy", "limit", "length", "uf", "queue", "pkg", "lim", "arr", "mem", "ptr", "ff", "cmd", "aka", "Buffer", "v", "box", "buff", "br", "fb", "phy", "que", "db", "pos", "cp", "pg", "tmp", "hl", "txt", "Buff", "um", "src", "rw", "ref", "seq", "wb", "temp", "req", "text", "batch", "np", "rb", "broad", "buffer", "block", "cv", "bf", "dev", "iter", "uv", "err", "bound", "MAX", "bytes", "good", "deg", "pt", "msg", "bin", "cap", "fl", "act", "cam", "desc", "off", "img", "b", "bl", "h", "max", "nb", "gz", "bp", "nm"], "buf_end": ["cmd_start", "buf00off", "uf_after", " buf0END", "buf_after", "buf00END", " buf_END", "uf_size", "buf_stop", " buf0end", "buffer_start", "cmd_END", "buf0END", "buf_ended", "buf00end", "fb_end", "cmd_ending", "fb_close", "uf_start", "fb_END", "buf0ended", "uf_stop", "uf_END", " buf0ended", "buf_ends", " buf_ends", "buf0end", "buf_ender", "buf_start", "uf_ender", "fb_ended", "uf_off", "buffer_END", "buf_END", "buffer_end", " buf0ends", "buf_ending", "uf_end", "buf00after", "buf_off", "buffer_size", " buf_ended", "buf_close", "buf_size", "cmd_end", "buf0ends"], "w": ["kw", "wind", "fw", "wh", "sw", "rw", "wx", "out", "aw", "hw", "wb", "window", "p", "wl", "v", "wal", "t", "wcs", "wa", "wt", "m", "r", "ew", "word", "iw", "c", "we", "wp", "wd", "W", "h", "wr", "weight", "d", "win", "q", "x"], "flag": ["bit", "status", "type", "f", "FLAG", "bug", "cond", "flags", "ag", "p", "cmd", "Flag", "leaf", "agged", "done", "fl", "enable", "offset", "command", "act", "lock", "flow", "tag", "age", "lag", "count", "link", "bf", "sync", "gc", "lv", "fc", "set", "weight", "fi", "sign", "needed", "valid", "af"], "bpp": [" bps", "bpl", "nbpp", " bpl", "BPP", "bispc", "bbPP", " bpc", "bipp", "rbmp", "bispp", "bppl", "nbps", "nbsupp", " bPP", "bpcp", "biPP", "Bff", "bpc", "rbpc", "bppp", " bmp", "bicpp", " bcp", "bbsupp", "bismp", "rbcp", "bbpp", "bips", "bff", "bPP", "bcp", "nbPP", "nbcpp", "nbff", "bcpp", "Bcp", "bmp", "bpPP", "biscp", "Bsupp", "bps", "rbpp", "Bpl", "bbff", "bsupp", "Bpp", " bcpp"], "dst_size": ["dst_sum", "dst_ize", "dstnetsum", "dstnetSize", "dest_ize", "dstnetize", "dst_Size", "dest_Size", "dest_size", "dstnetsize", "dest_sum"], "off0": [" offzero", "Offzero", "Off0", " offi", "offzero", "offerzero", " off5", "Off5", "ext1", "ext0", "Off1", "Offi", "off5", "offer5", "offer0", "offer1", "exti", "offi"], "off1": ["offset2", "on2", "offset4", "Off0", "Off4", "on1", "offOne", " off4", "off2", "on0", "Off2", "offer2", " off2", "offset0", "Off1", "OffOne", "onOne", " offOne", "offer0", "offerOne", "offset1", "offer1", "off4"], "dgb": ["dgt", "dgg", "Dgg", "bdgd", "Dgb", "bdgb", "sdgt", "Dbg", "rgb", "sdgb", "dbg", "bdgc", " dgd", "sdbg", "Dgd", "sdgd", "rgd", "bdgt", "sdgc", "rbg", "dgd", " dgt", "dgc", "rgg", "sdgg", " dgc"], "ogb": ["ggb", "oadbase", "oadbe", "obbb", "ugbc", "ugb", "gobd", "obl", "ogsl", "ocb", "obb", "ogc", "OGbase", "gobbc", "logt", "ogsbe", "oadb", "ugbe", "ocd", "ocbb", "ocbe", "ocbc", "ggc", "obc", "logb", "ogsb", "ugl", "ojbe", "ojbc", "ogbl", "OGbe", "ogbc", "obt", "ogbe", "ocl", "ighb", "obd", "gobb", "logbb", "ighbe", "ogl", "ogd", "gobbe", "ighbase", "ogsc", "ojb", "obbc", "ogbase", "ojl", "ighbl", "OGb", "ggbe", "ggl", "ogbb", "OGbl", "obbe", "ogt", "logd", "oadbl"], "pb": ["jp", "td", "tc", "ctx", "wb", "p", "bh", "tk", "bj", "vp", "pd", "dp", "pool", "sb", "buff", "lb", "np", "rb", "cb", "lp", "fp", "PB", "bf", "wp", "cp", "b", "pg", "pc", "tmp", "xb", "mp", "nb", "bb", "uf", "bp", "pak", "tp"], "poff0": ["pOff_", "pnotn", "pnot1", "ponent08", "pOff1", "pdes4", "pond047", " poffset1", "poff8", "poffset4", "poffsetNo", "poff02", "patt1", " patt1", "bonentNo", "paoff9", "pomNo", "pdef0", "boff08", "paoff0", "padon00", "poffset8", "pom0", " poff4", " poffset0", "pom08", " poffNo", "pdon9", "pOff8", "bonent047", " poffn", "pend0", "padon0", "bonent08", "pdefNo", "padon02", "poffNo", "pOff0", " patt0", "pdef4", "pnot0", "pdes1", "ponent0", "paoff02", " pOff4", "poffn", "pdes0", "patt0", "padon9", "poa0", " pOff_", "pattn", "pdef1", " pOffNo", " pOff8", " pOff1", "ponentNo", "pondNo", " pOff0", "pOffNo", "poff4", "pond0", "poa02", " poffset4", "pend00", "ponent047", " poffsetNo", "boff0", "pdesNo", "pom047", "poff08", "poffset0", " poff_", "paoff00", "poa9", "poffset1", "pdon0", "bonent0", "pend02", "pdon00", "poff9", "poff_", "poffset_", " poff8", "pend9", " pattn", "poff047", "pdon02", "boff047", "poff00", "pOff4", "boffNo", "pond08", "poa00"], "poff1": ["pon001", "pserverone", "pdev1", "moffsetOne", "opoff1", " poff11", "opoaOne", "poaG", "poff2", "moff1", "pobj11", "poffset01", "pehead3", "moffset0", "pof0", "pobj1", " pobj11", "poffer1", "tpoff2", "phead1", "opoaG", "poffer512", " pobjn", "peoff3", " poffn", "pserver1", "opoffOne", "pon11", "pobjn", "poff3", "poffsetOne", "poff01", "poffsetG", "ponOne", "poffsetone", "pdev001", "pod01", "pserverOne", "pobj0", "podOne", "pon01", "poffn", "moff01", "pod1", "poaOne", "poffOne", "pon2", "ponn", "pon1", "poffsetn", "pdev2", "tpoffer001", "pof3", "pof1", "opoaone", "poff001", "tpoff1", "pserverG", "pon0", "tpoffer1", "poffG", "poaone", "tpoff001", "opoa1", "poffer2", "pheadOne", "poffer001", "tpoffer512", "poffset11", "moffOne", " pobj0", "tpoff512", "pofOne", "peoffOne", "tpoffer2", "poff11", "pod0", "moffset1", "moff0", "poffset0", "pehead1", "poffset1", "phead0", "poa1", "opoffone", "peheadOne", "opoffG", "pdev512", "poffone", "peoff1", "peoff0", "pehead0", "pon512", "poff512", " pobj1", "phead3", "moffset01"], "i": ["f", "o", "ii", "mi", "I", "pi", " j", "l", "j", "n", "p", "v", "t", "in", "m", "info", "c", "ci", "id", "it", "d", "z", "q", "x", "y", "ix", "ip"], "k": ["key", "kw", "kn", "o", "kh", "uk", "j", "ok", "p", "kid", "n", "km", "kk", "mk", "tk", "v", "g", "t", "acc", "ik", "kind", "isk", "ke", "ku", "num", "K", "m", "ek", "kr", "ko", "ask", "ck", "kan", "work", "c", "ak", "kick", "wk", "ka", "jj", "kl", "b", "unk", "ijk", "ks", "ikk", "kj", "z", "q", "x", "ch", "sk"], "dstpitch": ["dstopulse", "drestpitches", "ddestpphop", "drestppitch", "dstcpip", "dstpulse", "dstcpitched", "dstPitches", "drestppitches", "dstpitched", "dstopitch", "dstppitched", "dstcphop", "ddestppip", "drestpitched", "drestpitch", "dstppitches", "dstpip", "dstcpitch", "dstppulse", "dstPitch", "ddestpip", "dstepitch", "ddestpitch", "dstppitch", "dstepitched", "drestppitched", "ddestphop", "dstPulse", "ddestppitch", "dstopitches", "dstppip", "dstpphop", "drestppulse", "dstphop", "drestpulse", "dstepip", "dstpitches", "dstPitched", "dstopitched", "ddestpitched", "dstephop", "ddestppitched"], "data": ["key", "amount", "type", "shift", "stream", "raw", "val", "text", "next", "batch", "bin", "offset", "step", "extra", "buffer", "pos", "Data", "no", "coord", "area", "rel", "pad", "DATA", "ata", "final", "value"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xff);\n\n}\n", "idx": 15728, "substitutes": {"opaque": ["mopane", "bolay", "play", "boque", "opane", "opade", "pque", " opque", " opane", " opade", "Opaque", "pade", "Opane", "boade", " oplay", "Opus", "mopus", "Opque", "oplay", "mopaque", "opus", "mopque", "paque", " opus", "opque", "boaque"], "addr": ["tx", "at", "ptr", "src", "ref", "handle", "inter", "address", "attr", "cmd", "hw", "tr", "dr", "ord", "dir", "ar", "adr", "loc", "now", "offset", "oad", "act", "r", "eth", "add", "rt", "work", "pos", "trans", "coord", "ack", "id", "ad", "host", "mt", "pad", " address", "dh", "err", "x", "rs", "Address"], "val": ["vol", "bit", "tx", " arg", " value", "Val", "mem", "ret", "serv", "ref", " weight", " vol", "ctx", "pol", "v", "sol", "loc", "buf", " valid", "aval", "al", " slot", " msg", "lit", " tx", "vals", " eval", " ty", " bl", "cal", "sel", " pref", "db", " v", "rol", "ival", "b", " seq", "VAL", "abl", "state", "it", "bal", "value", "vt", "valid", " cal"], "d": ["dict", "f", "o", "dn", "ind", "l", "j", "p", "fd", "n", "D", "dm", "pd", "g", "done", "t", "di", "dc", "ds", "da", "m", "dd", "r", "ade", "s", "bd", "dq", "c", "db", "cal", "od", "debug", "b", "h", "draw", "ad", "de", "e", "sd", "dat", "w", "ld"], "reg": ["rem", "ress", "region", "mem", "ptr", "ret", "ref", "ric", "Reg", "tr", "g", "ig", "REG", "loc", "rm", "br", "tag", "r", "rt", "ro", "db", "disc", "gr", "res", "rg", "rol", "red", "re", "rec", "fr", "rel", "eg", "mb", "rr", "tab"]}}
{"project": "qemu", "commit_id": "1a29cc8f5ebd657e159dbe4be340102595846d42", "target": 0, "func": "void serial_realize_core(SerialState *s, Error **errp)\n\n{\n\n    if (!qemu_chr_fe_backend_connected(&s->chr)) {\n\n        error_setg(errp, \"Can't create serial device, empty char device\");\n\n        return;\n\n    }\n\n\n\n    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);\n\n\n\n    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);\n\n    qemu_register_reset(serial_reset, s);\n\n\n\n    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,\n\n                             serial_event, NULL, s, NULL, true);\n\n    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);\n\n    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);\n\n    serial_reset(s);\n\n}\n", "idx": 15775, "substitutes": {"s": ["sis", "ses", "gs", "S", "bs", "ties", "ports", "sq", "t", "m", "ssl", "qs", "stats", "states", "cs", "ims", "its", "ps", "sw", "j", "n", "js", "params", "v", "g", "ar", "comm", "spec", "ds", "ats", "services", "sc", "sync", "set", "i", "save", "results", "south", "a", "as", "less", "store", "als", "sb", "er", "hs", "sys", "c", "es", "changes", "fs", "se", "sports", "ss", "aws", "o", "l", "p", "details", "is", "sv", "ls", "k", "r", "ts", "sp", "ins", "ns", "b", "h", "e", "os", "z", "w", "sts", "ms", "y", "rs"], "errp": ["errps", "ererps", "erpb", "ererp", " errps", "errpb", " errP", "errP", " errnp", "ernp", "erps", "rrp", "erernp", "rrP", "errnp", "rrpb", "erP", "rrps", "erp", " errpb"]}}
{"project": "qemu", "commit_id": "44bc910794eff956ceba0030f0751a26bed748b5", "target": 0, "func": "static int get_physical_address(CPUPPCState *env, mmu_ctx_t *ctx,\n\n                                target_ulong eaddr, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n#if 0\n\n    qemu_log(\"%s\\n\", __func__);\n\n#endif\n\n    if ((access_type == ACCESS_CODE && msr_ir == 0) ||\n\n        (access_type != ACCESS_CODE && msr_dr == 0)) {\n\n        if (env->mmu_model == POWERPC_MMU_BOOKE) {\n\n            /* The BookE MMU always performs address translation. The\n\n               IS and DS bits only affect the address space.  */\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n        } else if (env->mmu_model == POWERPC_MMU_BOOKE206) {\n\n            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,\n\n                                                   access_type);\n\n        } else {\n\n            /* No address translation.  */\n\n            ret = check_physical(env, ctx, eaddr, rw);\n\n        }\n\n    } else {\n\n        ret = -1;\n\n        switch (env->mmu_model) {\n\n        case POWERPC_MMU_32B:\n\n        case POWERPC_MMU_601:\n\n            /* Try to find a BAT */\n\n            if (env->nb_BATs != 0) {\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            if (ret < 0) {\n\n                /* We didn't match any BAT entry or don't have BATs */\n\n                ret = get_segment32(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n\n\n        case POWERPC_MMU_SOFT_6xx:\n\n        case POWERPC_MMU_SOFT_74xx:\n\n            /* Try to find a BAT */\n\n            if (env->nb_BATs != 0) {\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            if (ret < 0) {\n\n                /* We didn't match any BAT entry or don't have BATs */\n\n                ret = get_segment_6xx_tlb(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n\n\n#if defined(TARGET_PPC64)\n\n        case POWERPC_MMU_64B:\n\n        case POWERPC_MMU_2_06:\n\n        case POWERPC_MMU_2_06d:\n\n            ret = get_segment64(env, ctx, eaddr, rw, access_type);\n\n            break;\n\n#endif\n\n\n\n        case POWERPC_MMU_SOFT_4xx:\n\n        case POWERPC_MMU_SOFT_4xx_Z:\n\n            ret = mmu40x_get_physical_address(env, ctx, eaddr,\n\n                                              rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE:\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE206:\n\n            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,\n\n                                               access_type);\n\n            break;\n\n        case POWERPC_MMU_MPC8xx:\n\n            /* XXX: TODO */\n\n            cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n            break;\n\n        case POWERPC_MMU_REAL:\n\n            cpu_abort(env, \"PowerPC in real mode do not do any translation\\n\");\n\n            return -1;\n\n        default:\n\n            cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n#if 0\n\n    qemu_log(\"%s address \" TARGET_FMT_lx \" => %d \" TARGET_FMT_plx \"\\n\",\n\n             __func__, eaddr, ret, ctx->raddr);\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 15779, "substitutes": {"env": ["actor", "conn", "et", "query", "attr", "hw", "engine", "end", "context", "cb", "en", "vs", "pkg", "gear", "forge", "usr", "exec", "te", "rod", "kw", "param", "sw", "exc", "environment", "addr", "cmd", "erd", "v", "obj", "inv", "db", "conf", "enter", "eng", "iv", "kernel", "equ", "server", "nv", "nw", "proc", "req", "tk", "vp", "erb", "er", "era", "org", "work", "cv", "ec", "dev", "config", "err", "eh", "ev", "vt", "init", "ect", "estate", "esc", "ext", "act", "desc", "ew", "ah", "vm", "event", "code", "ov", "here", "e", "network", "viron", "worker"], "ctx": ["tx", "jp", "resp", "kw", "ctl", "cu", "fw", "co", "mem", "conn", "tc", "wx", "ca", "handle", " context", "setup", "data", "cmd", "hw", "kt", "cmp", "lib", "cc", "proc", "tk", "cas", "conv", "pool", "loc", "util", "msg", "stack", "sys", "np", "buf", "ct", "nt", "act", "cfg", "context", "obj", "HK", "aux", "vm", "rt", "ck", "org", "cv", "xc", "ka", "std", "cp", "etc", "conf", "qt", "net", "gz", "pkg", "sc", "txt", "iat", "jac", "worker"], "eaddr": ["rollder", " eddr", "eedder", "eedp", "adderric", "eadrect", "eeddr", "aeddr", "reammr", "eddydress", "asyhr", "eddyder", "ddder", " edder", "ezdr", "addymr", "eadrs", "elldel", "ezder", "ielddress", "eadler", "oadr", "adderdr", "reamdr", "rolller", "ezp", "dllder", "oadDR", "aeddel", "adderdress", "ddrs", "ielddro", "ellrd", "aedadr", "eyder", " eldbr", "eedtr", "eadadr", "ewaymr", "eadr", " eldder", "eadrd", "aeddro", "asyadr", "dlldress", "eadhr", "ddbr", "ellhr", "oadder", "ellder", "eadtr", "ewaydr", "ielddr", "ieldler", "eadp", "eztr", "eddydr", "ieldder", "eeddress", " edbr", "ieldric", "eddDR", "rolldr", "ieldrd", "dlldr", "elldro", "addyrect", "ieldp", "eadric", "eadmr", "eadptr", " elddr", "rolldress", "ielddel", "reamder", "eyptr", "eedptr", " eldrs", "oaddr", "eddder", "asydr", "ieldtr", "reamrect", "ieldr", "elldr", "dddr", "eadder", "eydr", "eddr", "eaddel", "elladr", "addyder", "ieldadr", "addydr", "eaddress", "eaddro", "adderder", "edddr", "eadDR", "eadbr", "ieldDR", "ellric", "ieldhr", "asyrd", "elldress", "eddyptr", "ewayrect", " edrs", "dlller", "ewayder", "eydress"], "rw": ["resp", "writers", "wind", "kw", "rack", "rew", "nw", "fw", "ptr", "wh", "wx", "writ", "rss", "aw", "wb", "hw", "window", "rf", " wr", "vr", "wl", "rl", "erb", "wo", "wal", "ru", "NW", "wa", "ow", "wt", "workers", "rb", "nr", "wn", "r", "ew", " w", "writer", "iw", "rt", "work", "rh", "wk", "wp", "wd", "tw", " ro", "wr", "rd", "RW", "rx", "w", "rs"], "access_type": ["access_operator", "accessetyunit", "attributeingerror", "accessabilityerror", "accessproType", "attributeingtype", " access_function", "issue_type", "access_typ", "accesserfunction", "accessTypetype", "accessetyType", "accessTypeType", "issue_Type", "accessureType", " access_field", "accesseterType", " access_label", " access_num", " access_typ", "ACCeroperator", "escape_type", "access_role", "accessertype", " access_ype", "ACCerfunction", "accessityfunction", "access_desc", "ACC_function", "accessionype", "accessprotable", "access_label", "accessprogroup", "accessoplabel", "accessabilityoperator", "accessetytyp", "access00typ", "accessionstatus", "accessingerror", "ACCertype", "accessTyperole", "ACCerrel", "accessionType", "accesseterstatus", "accessingfunction", "accesserrel", "access_function", "accessableerror", "accessionfunction", "access_field", "accesseroperator", "accessabilitytype", "accessableoperator", "accessopype", "attributeingoperator", "attribute_operator", "accessetytype", "ACC_operator", "accessiontype", " access_role", "accessuretype", "issue_table", "accessitytyp", "escape_desc", "accessurenum", " access_unit", "access_TYPE", "accessionlabel", "access_status", "access_rel", "accessTypecolor", "access_unit", "access_Type", "accessetertype", "access_options", "access00type", "attribute_type", "issue_group", "access_error", "accessionrel", "accessprotype", "attribute_function", " access_color", "accessabilityfunction", " access_status", "access_num", " access_options", "accessetyfield", "accessetyoperator", "accesseterfunction", "accessetyoptions", "access_ype", "accessabletype", "accessetyrel", "access_table", "accessingoperator", "escape_typ", "access00TYPE", "accessionoperator", "attributeingfunction", "accessetynum", "accessetyfunction", "accessureoptions", "accessitytype", "accessingtype", "attribute_error", "accessityType", " access_Type", "access00desc", "ACC_type", "accessoptype", "accessopType", "accessablefunction", "escape_TYPE", "access_group", "access_color", "ACC_rel"], "ret": ["et", "fun", "back", "expr", "val", "len", "rm", "result", "nt", "lit", "att", "oret", "rev", "Return", "backed", " res", " Ret", "cont", "arr", "rem", "def", "quad", "ll", "cmd", "tr", "RET", "reset", "dt", "try", "cat", "br", "get", "rect", "obj", "aux", "res", "print", "mt", "elt", "ter", "resp", "ref", "out", " alt", "inter", "utils", "Ret", "rets", "req", "ert", "sys", "gt", "mel", "jump", "iter", "ft", "hash", "err", "il", "jp", "lr", "det", "tif", "reg", "ext", "eu", "desc", "r", "alt", "url", "urn", "rt", "lt", "cert", "re", "rel", "gz", "prop", "pas", "final"]}}
{"project": "qemu", "commit_id": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d", "target": 0, "func": "static uint8_t eeprom24c0x_read(void)\n\n{\n\n    logout(\"%u: scl = %u, sda = %u, data = 0x%02x\\n\",\n\n        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);\n\n    return eeprom.sda;\n\n}\n", "idx": 15788, "substitutes": {}}
{"project": "qemu", "commit_id": "6a8f9661dc3c088ed0d2f5b41d940190407cbdc5", "target": 0, "func": "static void blockdev_do_action(int kind, void *data, Error **errp)\n\n{\n\n    TransactionAction action;\n\n    TransactionActionList list;\n\n\n\n    action.kind = kind;\n\n    action.data = data;\n\n    list.value = &action;\n\n    list.next = NULL;\n\n    qmp_transaction(&list, errp);\n\n}\n", "idx": 15791, "substitutes": {"kind": ["key", "index", "cost", "conduct", "needed", "type", "metadata", "ind", "cmd", "mode", "important", "kid", "family", "what", "Kind", "mk", "dir", "school", "md", "spec", "msg", "rank", "mid", "ke", "K", "k", "desc", "ko", "brand", "context", "th", "when", "kids", "kick", "code", "concept", "id", "ark", "state", "config", "need", "style", "topic", "name", "nick", "IND", "priority", "sk"], "data": ["bytes", "key", "def", "error", "type", "rew", "latest", "size", "attr", "response", "p", " DATA", "timeout", "raw", "what", "val", "missing", "text", "load", "batch", "done", "source", "initial", "result", "bin", "m", "message", "context", "step", "json", "snap", "info", "mu", "buffer", "empty", "image", "Data", "no", "content", "ns", "table", "device", "partial", "feed", "input", "any", "rel", "d", "DATA", "ata", "value", "dat", "name", "only", "results"], "errp": ["errpar", " erp", " ercp", "errps", " extrpad", " errpar", " errps", "diepad", " errcp", " errP", "dieps", "diep", "errP", " extrpar", "errcp", "ercp", "erps", " erP", " erps", "errpad", "erP", " extrps", " errpad", "erp", " extrp", "diepar"], "action": ["tx", "actor", "view", "a", "type", "version", "out", "edit", "cmd", "admin", "relation", "call", "role", "operator", "ACTION", "ACT", "rule", "task", "test", "t", "aco", "cart", "msg", "controller", "policy", "command", "item", "act", "op", "lock", "operation", "step", "comment", "attribute", "ac", "image", "event", "file", "create", "function", "link", "print", "alias", "acl", "article", "set", "ction", "entry", "ace", "state", "payment", "value", "Action", "commit", "package", "process", "form"], "list": ["status", "index", "li", "local", "out", "l", "map", "ist", "seq", "sequence", "relation", "group", "v", "lists", "pool", "load", "List", "batch", "t", "spec", "st", "listed", "result", "item", "act", "lock", "part", "parent", "add", "layout", "block", "null", "all", "summary", "LIST", "table", "print", "id", "label", "collection", "set", "pair", "entry", "state", "detail", "queue", "filter", "pl", "level", "template", "form"]}}
{"project": "FFmpeg", "commit_id": "659d4ba5af5d72716ee370bb367c741bd15e75b4", "target": 0, "func": "static void h263_h_loop_filter_mmx(uint8_t *src, int stride, int qscale)\n\n{\n\n    if (CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {\n\n        const int strength = ff_h263_loop_filter_strength[qscale];\n\n        DECLARE_ALIGNED(8, uint64_t, temp)[4];\n\n        uint8_t *btemp = (uint8_t*)temp;\n\n\n\n        src -= 2;\n\n\n\n        transpose4x4(btemp,     src,              8, stride);\n\n        transpose4x4(btemp + 4, src + 4 * stride, 8, stride);\n\n        __asm__ volatile (\n\n            H263_LOOP_FILTER // 5 3 4 6\n\n\n\n            : \"+m\"(temp[0]),\n\n              \"+m\"(temp[1]),\n\n              \"+m\"(temp[2]),\n\n              \"+m\"(temp[3])\n\n            : \"g\"(2 * strength), \"m\"(ff_pb_FC)\n\n            );\n\n\n\n        __asm__ volatile (\n\n            \"movq      %%mm5, %%mm1         \\n\\t\"\n\n            \"movq      %%mm4, %%mm0         \\n\\t\"\n\n            \"punpcklbw %%mm3, %%mm5         \\n\\t\"\n\n            \"punpcklbw %%mm6, %%mm4         \\n\\t\"\n\n            \"punpckhbw %%mm3, %%mm1         \\n\\t\"\n\n            \"punpckhbw %%mm6, %%mm0         \\n\\t\"\n\n            \"movq      %%mm5, %%mm3         \\n\\t\"\n\n            \"movq      %%mm1, %%mm6         \\n\\t\"\n\n            \"punpcklwd %%mm4, %%mm5         \\n\\t\"\n\n            \"punpcklwd %%mm0, %%mm1         \\n\\t\"\n\n            \"punpckhwd %%mm4, %%mm3         \\n\\t\"\n\n            \"punpckhwd %%mm0, %%mm6         \\n\\t\"\n\n            \"movd      %%mm5, (%0)          \\n\\t\"\n\n            \"punpckhdq %%mm5, %%mm5         \\n\\t\"\n\n            \"movd      %%mm5, (%0, %2)      \\n\\t\"\n\n            \"movd      %%mm3, (%0, %2, 2)   \\n\\t\"\n\n            \"punpckhdq %%mm3, %%mm3         \\n\\t\"\n\n            \"movd      %%mm3, (%0, %3)      \\n\\t\"\n\n            \"movd      %%mm1, (%1)          \\n\\t\"\n\n            \"punpckhdq %%mm1, %%mm1         \\n\\t\"\n\n            \"movd      %%mm1, (%1, %2)      \\n\\t\"\n\n            \"movd      %%mm6, (%1, %2, 2)   \\n\\t\"\n\n            \"punpckhdq %%mm6, %%mm6         \\n\\t\"\n\n            \"movd      %%mm6, (%1, %3)      \\n\\t\"\n\n            :: \"r\"(src),\n\n               \"r\"(src + 4 * stride),\n\n               \"r\"((x86_reg)stride),\n\n               \"r\"((x86_reg)(3 * stride))\n\n            );\n\n    }\n\n}\n", "idx": 15804, "substitutes": {"src": ["rc", "index", "sort", "ptr", "bs", "out", "attr", "ind", "seed", "addr", "size", "stream", "sur", "RC", "sq", "req", "sl", "ctr", "syn", "source", "loc", "sb", "st", "sec", "sys", "origin", "offset", "scan", "in", "rest", "r", "s", "sp", "dest", "pos", "sr", "img", "trans", "ins", "b", "start", "ser", "SOURCE", "input", "tmp", "slice", "sub", "iter", "from", "length", "sn", "supp", "i", "inst", "sc", "str", "iv", "rs"], "stride": ["stenge", "spine", " strize", "strenge", "strride", "stringide", " strend", "stize", "STRuse", "spade", "spide", "strise", "trise", "trine", " strine", "slride", "slade", "slide", "strine", "STRide", "spride", "lenride", "lenine", "stade", "strend", " struse", "Stride", "Strride", "stice", "stine", "STRade", "strice", "trride", "stringenge", " strride", "slenge", "Struse", "STRise", "tride", "STRice", "trade", "strade", " strade", "STRend", "STRine", "STRenge", "slice", "STRride", "struse", "sline", "STRize", "stide", "stringice", "lenice", "stringride", " strise", "strize", "lenide", "Strend"], "qscale": ["qtransform", "qvscale", "QScale", "sqtransform", " qmode", "qScale", "qqScale", "Qscale", "sqScale", "qqlevel", "qlevel", "Qtransform", "sqscale", " qScale", "qvmode", "qqscale", "Qmode", "Qlevel", "qqtransform", "sqlevel", "qvScale", "qmode"], "btemp": ["ibtem", "bresult", " bresult", "ibtemp", "ptemp", "ntemplate", "ntemp", "btemplate", "nsequence", " btem", " bcurrent", "pdat", "bbresult", "bbstem", "ptemplate", "bbcurrent", "ptem", "sbstem", "sbtemp", "psequence", "ibresult", "bsequence", "bbtem", "btmp", "btem", "bcurrent", "bdat", "sbdat", "ptmp", "bbsequence", "sbtmp", "bbtmp", "bbdat", "bbtemplate", "pstem", "ntem", "ibcurrent", "bbtemp", "bstem"], "H263_LOOP_FILTER": ["H263_LOOP_FILER", "H263_LOOP_AFOP", "H263_LOOP_FLTER", "H263_LOOP_AFTER", "H263_LOOP_FLOP", "H263_LOOP_FILOP", "H263_LOOP_FLER", "H263_LOOP_FLEN", "H263_LOOP_AFEN", "H263_LOOP_AFER", "H263_LOOP_FILEN"]}}
{"project": "qemu", "commit_id": "b63c7f6b77145c109d66a62bb3b6efe12b80d62b", "target": 0, "func": "static void bootp_reply(struct bootp_t *bp)\n\n{\n\n    BOOTPClient *bc;\n\n    struct mbuf *m;\n\n    struct bootp_t *rbp;\n\n    struct sockaddr_in saddr, daddr;\n\n    struct in_addr dns_addr;\n\n    int dhcp_msg_type, val;\n\n    uint8_t *q;\n\n\n\n    /* extract exact DHCP msg type */\n\n    dhcp_decode(bp->bp_vend, DHCP_OPT_LEN, &dhcp_msg_type);\n\n    dprintf(\"bootp packet op=%d msgtype=%d\\n\", bp->bp_op, dhcp_msg_type);\n\n\n\n    if (dhcp_msg_type == 0)\n\n        dhcp_msg_type = DHCPREQUEST; /* Force reply for old BOOTP clients */\n\n\n\n    if (dhcp_msg_type != DHCPDISCOVER &&\n\n        dhcp_msg_type != DHCPREQUEST)\n\n        return;\n\n    /* XXX: this is a hack to get the client mac address */\n\n    memcpy(client_ethaddr, bp->bp_hwaddr, 6);\n\n\n\n    if ((m = m_get()) == NULL)\n\n        return;\n\n    m->m_data += IF_MAXLINKHDR;\n\n    rbp = (struct bootp_t *)m->m_data;\n\n    m->m_data += sizeof(struct udpiphdr);\n\n    memset(rbp, 0, sizeof(struct bootp_t));\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n    new_addr:\n\n        bc = get_new_addr(&daddr.sin_addr);\n\n        if (!bc) {\n\n            dprintf(\"no address left\\n\");\n\n            return;\n\n        }\n\n        memcpy(bc->macaddr, client_ethaddr, 6);\n\n    } else {\n\n        bc = find_addr(&daddr.sin_addr, bp->bp_hwaddr);\n\n        if (!bc) {\n\n            /* if never assigned, behaves as if it was already\n\n               assigned (windows fix because it remembers its address) */\n\n            goto new_addr;\n\n        }\n\n    }\n\n\n\n    if (bootp_filename)\n\n        snprintf((char *)rbp->bp_file, sizeof(rbp->bp_file), \"%s\",\n\n                 bootp_filename);\n\n\n\n    dprintf(\"offered addr=%08x\\n\", ntohl(daddr.sin_addr.s_addr));\n\n\n\n    saddr.sin_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_ALIAS);\n\n    saddr.sin_port = htons(BOOTP_SERVER);\n\n\n\n    daddr.sin_port = htons(BOOTP_CLIENT);\n\n\n\n    rbp->bp_op = BOOTP_REPLY;\n\n    rbp->bp_xid = bp->bp_xid;\n\n    rbp->bp_htype = 1;\n\n    rbp->bp_hlen = 6;\n\n    memcpy(rbp->bp_hwaddr, bp->bp_hwaddr, 6);\n\n\n\n    rbp->bp_yiaddr = daddr.sin_addr; /* Client IP address */\n\n    rbp->bp_siaddr = saddr.sin_addr; /* Server IP address */\n\n\n\n    daddr.sin_addr.s_addr = 0xffffffffu;\n\n\n\n    q = rbp->bp_vend;\n\n    memcpy(q, rfc1533_cookie, 4);\n\n    q += 4;\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPOFFER;\n\n    } else if (dhcp_msg_type == DHCPREQUEST) {\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPACK;\n\n    }\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER ||\n\n        dhcp_msg_type == DHCPREQUEST) {\n\n        *q++ = RFC2132_SRV_ID;\n\n        *q++ = 4;\n\n        memcpy(q, &saddr.sin_addr, 4);\n\n        q += 4;\n\n\n\n        *q++ = RFC1533_NETMASK;\n\n        *q++ = 4;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0x00;\n\n\n\n        if (!slirp_restrict) {\n\n            *q++ = RFC1533_GATEWAY;\n\n            *q++ = 4;\n\n            memcpy(q, &saddr.sin_addr, 4);\n\n            q += 4;\n\n\n\n            *q++ = RFC1533_DNS;\n\n            *q++ = 4;\n\n            dns_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_DNS);\n\n            memcpy(q, &dns_addr, 4);\n\n            q += 4;\n\n        }\n\n\n\n        *q++ = RFC2132_LEASE_TIME;\n\n        *q++ = 4;\n\n        val = htonl(LEASE_TIME);\n\n        memcpy(q, &val, 4);\n\n        q += 4;\n\n\n\n        if (*slirp_hostname) {\n\n            val = strlen(slirp_hostname);\n\n            *q++ = RFC1533_HOSTNAME;\n\n            *q++ = val;\n\n            memcpy(q, slirp_hostname, val);\n\n            q += val;\n\n        }\n\n    }\n\n    *q++ = RFC1533_END;\n\n\n\n    m->m_len = sizeof(struct bootp_t) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n    udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n}\n", "idx": 15811, "substitutes": {"bp": ["jp", "bitcoin", "bs", "isp", "asm", "pb", "p", "bh", "BP", "bj", "vp", "pd", "osp", "batch", "bi", "pp", "sb", "bt", "lb", "np", "rb", "arb", "br", "php", "kb", "snap", "phy", "bsp", "sp", "cb", "lp", "fp", "bm", "bf", "blog", "wp", "cp", "b", "gp", "lbs", "pc", "bps", "bb", "nb", "BIP", "bg", "tp", "hp", "arp"], "bc": ["rc", "ba", "bitcoin", "cf", "tc", "conn", "unc", "bs", "exc", "mi", "lc", "pb", "eb", "cc", "clus", "ng", "bi", "comm", "bt", "bo", "sb", "dc", "sec", "arb", "BC", "bec", "uc", "broad", "bn", "bd", "bridge", "bm", "c", "cb", "console", "nc", "bf", "ec", "abc", "gc", "b", "mc", "soc", "pc", "fc", "con", "bb", "vc", "bg", "arc", "anc", "sc", "ic", "gov", "butt"], "m": ["am", "rem", "esm", "mem", "f", "um", "cm", "mi", "l", "j", "p", "mr", "n", "hm", "module", "man", "pm", "mo", "v", "dm", "mail", "g", "perm", "md", "t", "sm", "msg", "rm", "em", "r", "vm", "im", "mu", "bm", "c", "mm", "mn", "b", "mc", "gm", "mat", "h", "mp", "mt", "mod", "M", "d", "mb", "tm", "i", "ms", "mx"], "rbp": ["gbpy", "dbp", "erbv", "fbP", "rbpy", "robpc", "bbpc", "nrv", "robp", "dbpc", "erbpp", "dbps", "erbpc", "bbg", "rbpc", "robg", "nrpy", "rubypm", "bbgp", "rbgp", "bbv", "rblp", "erbg", "rubyp", "bbp", "bbP", "dbcp", "rbcp", "rbv", "erblp", "srcpa", "nrpa", "rbps", "fbp", "srcp", "srcpy", "dbpm", "gbv", "srcv", "fbcp", "erbcp", "nrp", "erbP", "rbpa", "gbp", "robv", "dbP", "rubyps", "erbps", "fbgp", "fbpc", "bblp", "rubypp", "rbpm", "erbgp", "erbpm", "rbpp", "rbP", "fblp", "rbg", "erbp", "dbpp", "gbpa"], "saddr": ["dsadr", " sref", "dattr", "ssref", "saddress", "sadr", "scoord", " scoord", "salign", "ssalign", "dref", " salign", "ssaddr", "sref", "sscoord", "dalign", "dscoord", " sadd", "dsaddress", "sattr", "ssadr", "dsaddr", "sadd", " sadr", "dadd", " sattr", "daddress", " saddress", "ssaddress"], "daddr": ["dsadr", " dobj", "dattr", "gitem", "dobj", "gaddr", "wobj", "saddress", "rattr", "dsadd", "dsattr", "dadr", "ddattr", "wadd", "wadr", "gattr", "wconn", "ditem", "sitem", "wattr", "dsobj", "ddaddress", "raddress", " dattr", "gaddress", "dint", " dadd", "sint", "dsaddress", "waddress", "sattr", "dsaddr", "radd", "sadd", "ddadr", "dadd", "ddaddr", " ditem", " dconn", "dsint", "dconn", "dsconn", "daddress", "waddr", " daddress", "raddr", " dint"], "dns_addr": ["dnsipmsg", "dns_msg", "dnsipaddr", "dNS_address", "dnsipaddress", "dnsgmsg", "dNS_msg", "dnsgaddr", "dNS_addr", "dns_address", "dnsgaddress"], "dhcp_msg_type": ["dhcp_cmd_type", "dhcp_req_class", "dhcp_message_style", "dhcp_cmd_TYPE", "dhcp_msg_name", "dhcp_msg_no", "dhcp_Msg_Type", "dhcp_message_no", "dhcp_cmd_name", "dhcp_Msg_type", "dhcp_msg_id", "dhcp_msg_desc", "dhcp_message_length", "dhcp_message_num", "dhcp_message_TYPE", "dhcp_Msg_style", "dhcp_msg_length", "dhcp_Msg_name", "dhcp_req_type", "dhcp_cmd_Type", "dhcp_Msg_id", "dhcp_req_name", "dhcp_msg_num", "dhcp_req_no", "dhcp_message_type", "dhcp_msg_style", "dhcp_message_Type", "dhcp_msg_TYPE", "dhcp_msg_Type", "dhcp_message_desc", "dhcp_message_name", "dhcp_msg_class"], "val": ["tx", "key", "Val", "mem", "ret", "local", "seq", "ctx", "pol", "typ", "aud", "v", "len", "eval", "msg", "al", "extra", "vals", "cal", "base", "pos", "res", "rel", "VAL", "bal", "vc", "value", "valid"], "q": ["qu", "f", "o", "query", "j", "p", "sq", "v", "g", "eq", "iq", "qa", "qi", "qs", "quote", "dq", "buffer", "c", "cv", " v", "h", "e", "u", "z", "w", "Q", "qq", "ch"]}}
{"project": "qemu", "commit_id": "4445b1d27ee65ceee12b71bc20242996c8eb5cf8", "target": 0, "func": "static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)\n\n{\n\n    switch (drc->state) {\n\n    case SPAPR_DRC_STATE_PHYSICAL_POWERON:\n\n        return RTAS_OUT_SUCCESS; /* Nothing to do */\n\n    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:\n\n        break; /* see below */\n\n    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:\n\n        return RTAS_OUT_PARAM_ERROR; /* not allowed */\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    /* if the guest is configuring a device attached to this DRC, we\n\n     * should reset the configuration state at this point since it may\n\n     * no longer be reliable (guest released device and needs to start\n\n     * over, or unplug occurred so the FDT is no longer valid)\n\n     */\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;\n\n\n\n    if (drc->unplug_requested) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_isolation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n", "idx": 15818, "substitutes": {"drc": ["Dirc", "darc", "parc", "mroc", "droc", "dnirc", "mrc", "didRC", "Dsrc", " drs", "mRC", "didisco", "didcol", "sdroc", "Dric", "daxc", "adsc", "tdRC", "Dxc", "dnsrc", "adrc", "dasrc", "sdrec", "adrec", "dric", "docr", "Droc", "Drc", "dacol", "prc", " dirc", " drec", "tdsrc", "dbRC", "didrs", "drs", " droc", "Docr", "didrc", "dsc", "adroc", "prec", "dbric", "dbsrc", "lrc", "daisco", "rdRC", "proc", " docr", " disco", "dbrc", "dRC", "dnroc", "sdsc", "lroc", "dirc", "drec", "Drs", "dsrc", " dRC", "rdarc", "dcol", "lrec", " dcol", "mrec", " dric", "DRC", "disco", " dsrc", "daRC", "tdxc", "tdrc", "dnrc", " darc", "pRC", "rdroc", " dsc", "rdrc", "didocr", "lRC", "sdrc", "dxc"]}}
{"project": "qemu", "commit_id": "2e6a64cb8d7506ad27d3b6c8000bc8d773936932", "target": 0, "func": "static void input_linux_event_mouse(void *opaque)\n\n{\n\n    InputLinux *il = opaque;\n\n    struct input_event event;\n\n    int rc;\n\n\n\n    for (;;) {\n\n        rc = read(il->fd, &event, sizeof(event));\n\n        if (rc != sizeof(event)) {\n\n            if (rc < 0 && errno != EAGAIN) {\n\n                fprintf(stderr, \"%s: read: %s\\n\", __func__, strerror(errno));\n\n                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);\n\n                close(il->fd);\n\n            }\n\n            break;\n\n        }\n\n\n\n        input_linux_handle_mouse(il, &event);\n\n    }\n\n}\n", "idx": 15823, "substitutes": {"opaque": ["compacity", "Opubis", "oplaque", "opula", "opacity", "ropacity", "Opaque", "composit", "oplosit", "eposit", "obacity", "Opacity", "ropubis", "Opula", "obaque", "oposit", "ropaque", "oplent", "obubis", "obula", "compaque", "compent", "oplacity", "epacity", "epent", "epaque", "opubis", "ropula", "opent"], "il": ["sql", "inel", "icol", "iler", "mi", "IL", "ll", "l", "ill", " pil", "wl", "iol", " sil", "ql", "intel", "ail", "illa", "ile", "ilo", "ipl", "irin", "util", "sil", "cil", "mil", "bil", "fil", "lis", "ml", "lin", "ssl", "ilk", "gil", "ul", "ils", "ull", "ial", "kl", "rol", "ili", "fol", "acl", "jl", "hl", "nil", "ool", "pel", "ilt", "yl", "til"], "event": ["index", "header", "window", "other", "raw", "task", " emit", " input", " image", "field", " command", "result", "command", "doc", "document", "change", " exc", "ack", "archive", "exec", " entity", " cue", "view", "error", "exc", "object", "data", "cmd", "test", " msg", "extra", "comment", "argument", "oe", "device", "term", "input", "arg", " ev", "ex", "out", "row", "call", "claim", "json", "vent", "age", " waiter", "info", "block", " argument", "config", " address", "ev", "request", "entity", " operation", " error", "Event", "ee", "rule", "ent", "frame", "msg", "ext", "item", "tag", "message", "press", " exception", "image", "all", "cal", "action", "e", " signal", " message", "xml"], "rc": ["cor", "co", "cr", "src", "ra", "cur", " cr", "cre", "row", "RC", "cmp", "cc", "erc", "cd", "rr", "ctr", "len", "dc", "comp", "rb", "nr", "r", "rt", "ck", "roc", "ac", "rys", "c", "cb", "ro", "nc", "ec", "sync", "res", "gc", "ry", "cs", "ack", " ro", "re", "pc", "fc", "rec", "bc", "con", "ras", "rin", "err", " r", "rx", "coll", "arc", "sc", "rn", "ce", "rs", "ch", " RC"]}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "int float64_eq( float64 a, float64 b STATUS_PARAM )\n\n{\n\n\n\n    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )\n\n         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )\n\n       ) {\n\n        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {\n\n            float_raise( float_flag_invalid STATUS_VAR);\n\n        }\n\n        return 0;\n\n    }\n\n    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );\n\n\n\n}\n", "idx": 15833, "substitutes": {"a": ["ae", "am", "at", "ba", "aa", "au", "as", "o", "out", "f", "l", "aka", "aj", "aaa", "p", "A", "aq", "ga", "ar", "el", "t", "la", "ia", "ed", "ea", "ab", "da", "al", "sa", "r", "att", "s", "era", "oa", "ac", "ao", "ak", "ap", "b", "isa", "h", "e", "ach", "u", "eas", "ma", "ata", "w", "i", "x", "ca", "y", "an"], "STATUS_PARAM": ["STATUS_ARAMS", "STATUS_NORA", "STATUS_PARAMS", "STATUS_ARA", "STATUS_ARAM", "STATUS_NORAM", "STATUS_TAGA", "STATUS_TAGAMS", "STATUS_TAGUS", "STATUS_NORAMS", "STATUS_NORUS", "STATUS_TAGAM", "STATUS_ARUS", "STATUS_PARUS", "STATUS_PARA"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_cmp(TCGCond cond,\n\n                                  int ra, int rb, int rc,\n\n                                  int islit, uint8_t lit)\n\n{\n\n    int l1, l2;\n\n    TCGv tmp;\n\n\n\n    if (unlikely(rc == 31))\n\n    return;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n\n\n    if (ra != 31) {\n\n        tmp = tcg_temp_new(TCG_TYPE_I64);\n\n        tcg_gen_mov_i64(tmp, cpu_ir[ra]);\n\n    } else\n\n        tmp = tcg_const_i64(0);\n\n    if (islit)\n\n        tcg_gen_brcondi_i64(cond, tmp, lit, l1);\n\n    else\n\n        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);\n\n\n\n    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_movi_i64(cpu_ir[rc], 1);\n\n    gen_set_label(l2);\n\n}\n", "idx": 15840, "substitutes": {"cond": ["tx", "resp", "def", " Cond", "dict", "co", "circ", "ref", " condition", "ind", " cmd", "cmd", "ctx", "expr", " pred", "cmp", "call", "cod", " ex", "cd", "reg", " flock", "ct", "cell", "lock", "condition", " inf", " def", "obj", " cont", "Cond", "c", " conditional", " exc", "bf", "bind", "comp", "pred", "like", "red", " uncond", " prep", "mat", "imm", "con", "conf", "pre", " con", "init", "ond", "cont", "jac"], "ra": ["rav", "a", "co", "cr", "rise", "rad", "rn", "pr", "RA", "rac", "row", "or", "ir", "ran", "ror", "ar", "rar", "tra", "rr", "ica", "ru", "la", "ur", "r", "hi", "range", "rt", "rat", "ro", "run", "rh", "ara", "po", "alpha", "ras", "re", "rom", "tri", "area", "rel", "rd", "raf", "Ra", "ta", "i", "ri", "rs", "rap", "dra"], "rb": ["RB", "src", "lr", "pb", "wb", "mr", "vr", "rl", "reb", "rf", "erb", "rar", "ru", "rid", "rm", "gb", "lb", "ab", "br", "r", "iro", "ruby", "rt", "cb", "db", "b", "rg", "rob", "ri", "rd", "bb", "nb", "raf", "bp", "rr", "ob"], "rc": ["isc", "co", "cr", "tc", "src", "rw", "lr", "lc", "row", "RC", "rl", "rf", "cd", "ror", "rar", "rr", "ru", "loc", "rid", "br", "r", "uc", "rt", "rev", "rib", "irc", "c", "cb", "cv", "ro", "ci", "ec", "ry", "ron", "cs", "ras", "rin", "pc", "fc", "ri", "rd", "con", "raf", "rx", "arc", "sc", "rn", "rs", "ica"], "islit": ["lestlit", "slist", "gelit", "selit", "islist", "gelist", "lestit", "itolocation", "slite", "isllit", "sllit", "lestolit", "slolit", "slitted", "itolit", "slocation", "itollit", "islocation", "gelite", "gelitted", "lestocation", "slit", "selitted", "islolit", "islite", "islitted", "selist", "selite", "itololit"], "lit": ["bit", "il", "lim", "def", "tl", "ptr", "eral", "late", "ref", "local", "ind", "l", "expr", "lib", "typ", "val", "test", " literal", "t", "loc", "la", "unit", "buf", "lang", "lock", "alt", "rt", "sel", "pos", "ite", "bf", "rot", "limit", "lt", "label", "rel", "iter", "abl", "it", "fi", "init", "cont", "iat"], "l1": ["j1", "L2", "lau", " lau", "L0", "li01", "Lau", "v3", " l0", "l51", "v1", "l81", "v0", "li2", " l81", " l01", "L3", " l9", "l01", "li1", "tl1", "l9", "v2", "l3", "tl2", "v81", "l5", "tl51", "tl81", "l0", "li0", " l3", "liau", " l5", "li9", "fl9", "fl01", "L5", "v51", "j5", "j0", "j2", "fl0", "L1", "fl1", " l51"], "l2": ["lige", "L2", "L0", "c4", "lge", "sl1", " l0", "v3", "ltwo", "sl2", "L7", "v1", "eltwo", "li2", "v0", " l7", "c2", "L3", " ltwo", "li1", " l4", "el4", "l3", "v2", "l02", "L02", "Lge", "l0", "li3", "el2", " l3", "sl02", "sl7", "l4", "l7", "c0", "el0", " lge", "ctwo", " l02", "L1"], "tmp": ["node", "resp", "td", "tg", "mem", "ptr", "tc", "py", "ret", "tv", "attr", "j", "ctx", "tt", "p", "rl", "temp", "lib", "mk", "mint", "perm", "xy", "box", "t", " np", "loc", "util", "tem", "buff", "buf", "np", "new", "cache", "tn", "nt", "m", "obj", "aux", "rt", "sp", "tf", "cv", "cb", "mut", "copy", "trap", "cp", "b", "mp", "etc", "xb", "term", "tar", "var", "nb", "mb", "uf", "emp", "vt", "tm", "pkg", "tab", "txt", "template", "rap", "ip"]}}
{"project": "qemu", "commit_id": "e3c9d76acc984218264bbc6435b0c09f959ed9b8", "target": 1, "func": "static int virtio_scsi_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIOSCSI *s = VIRTIO_SCSI(qdev);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);\n\n\n\n    unregister_savevm(qdev, \"virtio-scsi\", s);\n\n    return virtio_scsi_common_exit(vs);\n\n}\n", "idx": 15846, "substitutes": {"qdev": ["Qdef", "qualdef", "sqev", "qpad", "sqblock", "Qdevice", "qudev", "dqdev", "gdiv", "qblock", "qqreg", "qualdevice", "gev", " qpad", " qblock", "qdevice", "qublock", "sqdef", "qqdev", "qqdevice", "gproc", "Qreg", "qev", "qreg", "dqev", "qqdef", "sqdevice", "dqdef", "iqev", "sqdev", "iqdev", "sqpad", "qualreg", "iqdiv", "quedev", "qdef", "qualdev", "Qdev", "queev", "qdiv", "quediv", "gdev", "qupad", "gdef", "iqproc", "gdevice", "dqdevice", "qproc", "queproc"], "s": ["ses", "gs", "a", "S", "f", "o", "l", "p", "js", "n", "si", "sq", "v", "g", "t", "is", "sv", "hs", "ds", "ats", "ls", "iss", "ess", "gets", "qs", "ts", "c", "ns", "b", "cs", "h", "fs", "i", "ss", "sts", "ms", "w", "rs"], "vs": ["nv", "gs", "obs", "bs", "ves", "js", "vr", "vp", "v", "xs", "Vs", "sv", "hs", "ds", "ls", " cs", "ies", "qs", "ts", "ins", "ns", "cs", "fs", "ks", "vc", "vt", "ss", "sts", "ms", "VS", "rs", "ps"]}}
{"project": "qemu", "commit_id": "7d6e771f49c36f4388798ce25bde1dede40cda74", "target": 0, "func": "static int pci_vpb_init(SysBusDevice *dev)\n\n{\n\n    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);\n\n    PCIBus *bus;\n\n    int i;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        sysbus_init_irq(dev, &s->irq[i]);\n\n    }\n\n    bus = pci_register_bus(&dev->qdev, \"pci\",\n\n                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,\n\n                           get_system_memory(), get_system_io(),\n\n                           PCI_DEVFN(11, 0), 4);\n\n\n\n    /* ??? Register memory space.  */\n\n\n\n    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-selfconfig\", 0x1000000);\n\n    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-config\", 0x1000000);\n\n    if (s->realview) {\n\n        isa_mmio_setup(&s->isa, 0x0100000);\n\n    }\n\n\n\n    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);\n\n\n\n    pci_create_simple(bus, -1, \"versatile_pci_host\");\n\n    return 0;\n\n}\n", "idx": 15879, "substitutes": {"dev": ["pro", "vol", "def", "des", "mem", "DEV", "go", "conn", "serv", "ver", "local", "data", "cmd", "hw", "p", "window", "devices", "Dev", "proc", "dis", "Device", "v", "g", "gu", "md", "t", "priv", "sys", "ds", "nt", "cam", "dd", "disk", "obj", "dem", "db", "debug", "wd", "device", "h", "serial", "ad", "de", "sd", "os", "pad", "d", "ve", "stick", "ev", "w", "home", "driver"], "s": ["sis", "ses", "aws", "gs", "S", "f", "sw", "serv", "bs", "has", "less", "j", "cmd", "p", "js", "params", "sq", "v", "g", "sl", "store", "sam", "syn", "t", "comm", "sm", "sv", "sb", "is", "spec", "sys", "hs", "ds", "ls", "ats", "m", "obj", "services", "qs", "sc", "so", "ts", "self", "c", "sp", "stats", "sh", "vs", "res", "ns", "b", "cs", "args", "h", "es", "tests", "fs", "sd", "se", "ss", "sts", "rs", "ps"], "bus": ["BUS", "bar", "hand", "vol", "proxy", "mount", "bs", "out", "local", "handle", "bug", "data", "back", " BUS", "usb", "card", "user", "boot", "chain", "http", "port", "box", "loc", "Bus", "util", "buf", "loop", "book", "cat", "lock", "disk", "bridge", "buffer", "block", "c", "board", "base", "trap", "b", "device", "ack", "bc", "root", "host", "stick", "way", "vc", "cast", "us", "home", "join"], "i": ["key", "index", "li", "ias", " c", "o", "mi", " j", "I", "pi", "ii", "ind", "j", "l", "p", "ini", "ex", "si", " ti", "v", "chain", "g", "gu", "io", "t", " pi", "ui", "is", "di", "ami", " ii", " mi", "m", "ai", "y", "in", " I", "hi", "ie", "qi", "sim", "im", "\u0438", "c", " multi", "ci", " v", "client", "print", "id", "ti", " ni", "iter", "my", "e", "u", "multi", " p", "it", "gi", " m", "me", "fi", "phi", "x", "ms", " e", "ic", "ix", "ip"]}}
{"project": "qemu", "commit_id": "feced894fb6c474eb56daeb2b2d1f99bae87677f", "target": 0, "func": "static void rng_random_set_filename(Object *obj, const char *filename,\n\n                                 Error **errp)\n\n{\n\n    RngBackend *b = RNG_BACKEND(obj);\n\n    RndRandom *s = RNG_RANDOM(obj);\n\n\n\n    if (b->opened) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    if (s->filename) {\n\n        g_free(s->filename);\n\n    }\n\n\n\n    s->filename = g_strdup(filename);\n\n}\n", "idx": 15883, "substitutes": {"obj": ["et", "o", "ref", "bs", "handle", "object", "cur", "onet", "attr", "ist", "cmd", "j", "expr", "js", "ctx", "hw", "this", "window", "bh", "tk", "bj", "v", "xy", "Obj", "t", "bo", "rb", "act", "nt", "og", "rect", "org", "ck", "self", "inv", "db", "oj", "po", "ht", "oid", "h", "tmp", "ot", "os", "it", "Object", "objects", "ex", "cont", "ob"], "filename": ["csv", "sbm", "ames", "generation", "path", "directory", "FIL", "sequence", "whatever", "licensed", "println", "fp", "location", "fn", "summary", "length", "nil", "stem", "fps", "jpg", "til", "metadata", "held", "n", "frames", "fil", "release", "knife", "partial", "seek", "files", "txt", "Filename", "text", "fle", "original", "description", "finals", "json", "file", "gettable", "bite", "kl", "journal", "folder", "kj", "severe", "username", "wav", "png", "output", "p", "fired", "managed", "names", "origin", "title", "ename", "dump", "url", "mpeg", "subject", "prefix", "forth", "doi", "append", "written", "that", "ame", "nm", "name"], "errp": ["riskP", "errpr", "lerP", "lerpd", "ErP", "errorpc", "Erp", "errpd", "eorpr", "eorP", "riskpun", "errorp", " errP", "lerpr", "errP", " errpun", "riskpc", "Erpd", "errorpun", " errpc", "eorpd", "riskp", "Erpr", "errorP", "errpun", "errpc", "lerp", "eorp"], "b": ["be", "a", "ib", "f", "bs", "o", "l", "pb", "j", "p", "wb", "eb", "bh", "v", "g", "bi", "t", "sb", "bt", "gb", "ab", "rb", "br", "r", "fb", "c", "bm", "cb", "db", "base", "bc", "h", "B", "d", "nb", "bb", "mb", "bg", "bp", "i", "y"], "s": ["ses", "gs", "S", "settings", "bs", "p", "js", "n", "sq", "v", "g", "sl", "details", "sam", "is", "sv", "sb", "sys", "hs", "sf", "ds", "ls", "ats", "sa", "r", "qs", "ts", "self", "sp", "stats", "sr", "vs", "ns", "cs", "es", "changes", "fs", "os", "its", "se", "parts", "z", "q", "sn", "i", "ss", "ms", "sts", "rs", "ps"]}}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,\n\n                                           sPAPRMachineState *spapr,\n\n                                           uint32_t token, uint32_t nargs,\n\n                                           target_ulong args, uint32_t nret,\n\n                                           target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    PCIDevice *pdev;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n\n\n    if ((nargs != 4) || (nret != 2)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = rtas_ldq(args, 1);\n\n    sphb = spapr_pci_find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    if (!spapr_phb_eeh_available(sphb)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    /*\n\n     * We always have PE address of form \"00BB0001\". \"BB\"\n\n     * represents the bus number of PE's primary bus.\n\n     */\n\n    option = rtas_ld(args, 3);\n\n    switch (option) {\n\n    case RTAS_GET_PE_ADDR:\n\n        addr = rtas_ld(args, 0);\n\n        pdev = spapr_pci_find_dev(spapr, buid, addr);\n\n        if (!pdev) {\n\n            goto param_error_exit;\n\n        }\n\n\n\n        rtas_st(rets, 1, (pci_bus_num(pdev->bus) << 16) + 1);\n\n        break;\n\n    case RTAS_GET_PE_MODE:\n\n        rtas_st(rets, 1, RTAS_PE_MODE_SHARED);\n\n        break;\n\n    default:\n\n        goto param_error_exit;\n\n    }\n\n\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 15885, "substitutes": {"cpu": ["cu", "pu", "CPU", "mem", "phys", "ctx", "core", "hw", "linux", "proc", "cli", "boot", "du", " proc", "np", "processor", "cp", "gc", "gp", "pc", "nice", " cp", "cow", "pid", "gpu", "pkg", "process", "nu"], "spapr": ["spapprb", "sparrt", "sparrb", "spaprb", "spamprb", "Spapr", "spapprs", "smarr", "apapr", "spipp", "spapsrb", "smarrb", "apapprb", "smaprb", "spaprs", "spampr", "Spapp", "spraprb", "sprapr", "spampor", "spaperb", "spapor", "apaprb", "spapsro", "spapsR", "apappro", "spamprt", "spapep", "sprapR", "sparor", "spapeor", "apappR", "smaprt", "spaprt", "apappr", "spappro", "smapr", "spappp", "sparr", "sprapro", "Spappp", "apapR", "spapers", "spappr", "spapert", "spapro", "spaper", "spappR", "Spaprs", "spapsr", "smapor", "spapR", "Spappr", "spipr", "smarrt", "spapp", "smaror", "apapro", "spiprs", "Spapprs"], "token": ["status", "aws", "session", "random", "ok", "callback", "auth", "opt", "initialized", "next", "features", "store", "oken", "wt", "Token", "sys", "ens", "tn", "tree", "lock", "alt", "json", "ts", "event", "password", "root", "secret", "os"], "nargs": ["Nrows", "numparams", " nrows", "gnarg", "nparams", "numrows", "nrows", "Narg", "gnargs", "norargs", "numarg", " nparams", "tparams", "narg", "Nargs", "Nparams", "numargs", "norarg", "gnparams", "targ", "trows", " narg", "norrows", "targs", "norparams", "gnrows"], "args": ["bytes", "uns", "aws", "gs", "roots", "ret", "settings", "nuts", "ties", "flags", "cmd", "facts", "js", "bits", "keys", "params", "ags", "rows", "xs", "fields", "urs", "frames", "arms", "als", "ds", "ires", "ls", "icks", "s", "atts", "gets", "qs", "vals", "ts", "uds", "stats", "ares", "ins", "ns", "Args", "ras", "es", "cs", "tests", "arg", "its", "parts", "options", "uments", "ms", "terms", "rs"], "nret": ["nrets", "numres", "treturn", " nreturn", "numret", "tret", "Nret", "numreturn", " nrets", "trets", "tRet", "numrets", "nreturn", " nres", "nRet", "Nrets", " nRet", "NRet", "Nres", "Nreturn", "nres"], "rets": ["uns", "ses", "aws", "ress", "ails", "gs", "des", "def", "urses", "ret", "ints", "ocks", "ties", "outs", "bits", "rows", "runs", "RET", "lists", "urs", "details", "als", "fits", "fts", "ires", "ds", "ats", "ls", "ards", "aux", "tails", "acs", "qs", "vals", "rt", "ads", "uds", "ts", "ets", "results", "unts", "gets", "res", "ns", "states", "ras", "uts", "tes", "events", "fs", "els", "its", "ants", "sts", "terms", "rs"], "sphb": ["smphp", "smpr", " sphc", "sphp", "shpb", "sphalb", "sper", "smphb", "sephB", "geshpp", "smprb", "shpe", "sphe", "smphB", "smphc", "shpp", "geshpe", "sphalc", " smphw", "saphb", "geshpb", "smphr", "sphB", "sphw", "sPhb", "smphe", "smphw", "smph", " sphr", "smpb", "sephr", "sphalw", "sperb", "speh", "sphr", " smphc", "gesphp", "saphp", "sphrb", "sPhnb", "shpc", "sPhB", " sphh", "sephnb", " sphw", "sphnb", " sphrb", "shpw", " smphb", "gesphe", "sephb", "smphnb", "speb", "sPhr", "sphh", "gesphb", "sphc", "saphe"], "pdev": ["ppdevice", "Pev", " pdef", "ppdev", "hdev", " pev", " pmem", "PDev", "predev", "pcden", " pden", "dDev", "ppev", "pden", "premem", "pcvar", "pcdef", "pdef", "Pconn", "pcmem", "pcdevice", "pev", "hvar", " pdevice", "pvar", "pmem", "ppconn", " pconn", "pdevice", "Pdevice", "ddevice", "hden", "pDev", "pcdev", " pDev", "hdevice", "predevice", "Pdev", "ddev", "pconn", " pvar", "predef"], "addr": ["rc", "ress", "arp", "at", "mem", "ptr", "ref", "handle", "usr", "address", "attr", "cmd", "map", "ag", "tr", "dr", "ord", "opt", "port", "adr", "loc", "offset", "align", "dist", "eth", "url", "add", "rt", "rev", "aro", "prefix", "pos", "alias", "ack", "id", "host", "ad", "ace", "pad", "var", "hash", " address", "err", "news", "name", "rn", "arr", "ix", "Address", "ip"], "option": ["status", "index", "key", "error", "type", "param", "sort", "mode", "important", "choice", "relation", "opt", "field", "feature", "command", "offset", "op", "tag", "operation", "alt", "condition", "slot", "attribute", "comment", "setting", "ption", "change", "event", "optional", "function", "alias", "flag", "Option", "action", "term", "weight", "ion", "options", "style", "value", "prop", "TION", "offer", "package", "name", "category"], "buid": ["uuids", "cuId", "uuuid", "cuID", "cuid", "buId", "boID", " buId", "ausid", " buuid", "boid", "ausuid", "ausId", "bufID", "buuid", "BUid", " buID", " buids", "boId", "buID", "uuID", "BUId", "buids", "ausids", "bufId", "BUID", "bufid", "uuid", "uuId"]}}
{"project": "qemu", "commit_id": "a3fa1d78cbae2259491b17689812edcb643a3b30", "target": 0, "func": "static void migrate_fd_completed(MigrationState *s)\n\n{\n\n    DPRINTF(\"setting completed state\\n\");\n\n    migrate_fd_cleanup(s);\n\n    if (s->state == MIG_STATE_ACTIVE) {\n\n        s->state = MIG_STATE_COMPLETED;\n\n        runstate_set(RUN_STATE_POSTMIGRATE);\n\n    }\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n", "idx": 15890, "substitutes": {"s": ["ses", "aws", "south", "gs", "S", "sw", "serv", "bs", "o", "less", "p", "js", "sq", "eps", "v", "g", "sl", "details", "store", "sol", "t", "is", "sb", "sv", "st", "als", "hs", "sys", "ds", "ls", "ats", "m", "in", "r", "qs", "ts", "stats", "ins", "states", "ns", "b", "cs", "an", "es", "h", "set", "fs", "os", "state", "its", "se", "z", "sports", "ss", "sts", "i", "y", "w", "rs", "ps"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_adds_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tint size = memsize_z(dc);\n\n\tDIS(fprintf (logfile, \"adds.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(size),\n\n\t\t    dc->op1, dc->op2));\n\n\n\n\tcris_cc_mask(dc, CC_MASK_NZVC);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\t/* Size can only be qi or hi.  */\n\n\tt_gen_sext(t0, cpu_R[dc->op1], size);\n\n\tcris_alu(dc, CC_OP_ADD,\n\n\t\t    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 15897, "substitutes": {"dc": ["rc", "ctl", "kw", "def", "exec", "co", "cu", "tc", "oc", "conn", "cm", "ca", "cus", "lc", "mic", "ctx", "central", "dr", "dl", "cc", "cca", "dir", "cd", "dm", "ga", "dp", "DC", "du", "mac", "di", "sys", "currency", "ds", "da", "desc", "dd", "doc", "dim", "ac", "c", "mm", "db", "disc", "nc", "ci", "ec", "wp", "df", "gc", "mc", "cs", "bc", "pc", "fc", "draw", "rec", "de", "d", " DC", "vc", "dat", "arc", "sc", "ic", "design"], "t0": [" pt1", "Toval", "T3", "tn1", "txt0", "t1", "T2", " tZero", "c3", "temp0", " t4", "txt4", " t2", "tnZero", " tnull", "t2", "t2000", "tnoval", " T1", " t5", "c5", "tZero", "txt2000", " pt0", " Tnull", "txt1", "T2000", "c1", "t3", " ptnull", "tnull", "t5", " t3", "toval", " t1", "tn0", "temp1", "tempoval", " t2000", " toval", "c0", "temp2", " T0", "T4", "T1", "T5", "T0", "TZero", "t4"]}}
{"project": "FFmpeg", "commit_id": "02055b6d40d0cff867a9e41cad48edcaf6e10f2f", "target": 0, "func": "static void create_map(vorbis_context *vc, unsigned floor_number)\n\n{\n\n    vorbis_floor *floors = vc->floors;\n\n    vorbis_floor0 *vf;\n\n    int idx;\n\n    int blockflag, n;\n\n    int32_t *map;\n\n\n\n    for (blockflag = 0; blockflag < 2; ++blockflag) {\n\n        n = vc->blocksize[blockflag] / 2;\n\n        floors[floor_number].data.t0.map[blockflag] =\n\n            av_malloc((n + 1) * sizeof(int32_t)); // n + sentinel\n\n\n\n        map =  floors[floor_number].data.t0.map[blockflag];\n\n        vf  = &floors[floor_number].data.t0;\n\n\n\n        for (idx = 0; idx < n; ++idx) {\n\n            map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) *\n\n                             (vf->bark_map_size / BARK(vf->rate / 2.0f)));\n\n            if (vf->bark_map_size-1 < map[idx])\n\n                map[idx] = vf->bark_map_size - 1;\n\n        }\n\n        map[n] = -1;\n\n        vf->map_size[blockflag] = n;\n\n    }\n\n\n\n    for (idx = 0; idx <= n; ++idx) {\n\n        av_dlog(NULL, \"floor0 map: map at pos %d is %d\\n\", idx, map[idx]);\n\n    }\n\n}\n", "idx": 15906, "substitutes": {"vc": ["il", "vo", "vv", "nv", "cu", "cf", "vec", "vl", "wx", "lc", "ctx", "VC", "vr", "cc", "vp", "vi", "vert", "v", "conv", "sv", "dc", "vor", "ct", "vy", "vm", "c", "cv", "xc", "fp", "nc", "vs", "cp", "cs", "bc", "lv", "pc", "fc", "von", "uv", "vd", "vt", "av", "ic", "voc"], "floor_number": ["prime_number", "flo_Number", "prime_Number", "floortway", "floor2Number", " floor_Number", "floor___Number", "floor_bridge", "oral_Number", "prime_way", "flo_byte", "floorablenumber", "primeityway", "floor_way", "oral_bridge", "floor_year", "floor_length", "floorityobject", "floorablebridge", " floor_year", "floor2number", "flooritynumber", "floor_num", "floor_given", "floortnumber", "prime_object", "primeityobject", "floortNumber", "flo_number", "floor___length", " floor_length", "floorptNumber", "floor_Number", "floorptyear", "primeitynumber", "oral_given", "floor___year", "floor2num", "floor_byte", "floortobject", "floor_object", "floor2byte", "floorablegiven", "floorptlength", "floorableNumber", "floor___number", "oral_number", "primeityNumber", "floorityNumber", "floorityway", "flo_num", "floorptnumber"], "floors": ["flovers", " floORS", "boor", "loors", "Floores", "FloORS", " floores", "flor", "floators", "floctors", "boORS", "lovers", "boors", "floORS", "Floers", "flors", "boators", "boores", " floctors", "floours", "Floors", "boers", " flovers", "Floctors", "loours", "Flovers", "flores", " floators", "Floours", "boctors", "floers", "boours", " floers", "Floor", "loores", "floores", "flers", "loctors", "Floators", "loers"], "vf": ["vmfc", "evf", " vac", "vmfe", "svfo", " vm", "visualf", " vfo", "mrf", " vn", "Vfo", " vfc", "uvf", "fn", "vac", "vh", " vfa", "avF", "Vf", "svf", "hf", "ff", "cvfo", "uvrf", "cvcf", "vrf", "Vh", "verF", "avfo", "evcf", " vfs", "vefc", "visualfo", "vfs", "vfc", "vercf", "svfc", "avif", "vfo", "uvif", " vcf", "avf", "hif", "ffc", "visualfa", "verfo", "vmfs", "vrfe", "vif", "hfc", "visualh", "uvfc", " vh", "fm", "Vfa", "mfc", "vfa", " vfe", "cvn", " vif", "vrfs", "vecf", "evfo", "vcf", "verf", "mf", "cvf", "cvfc", "mcf", " vF", "vm", "hac", "vF", "vrfc", "avcf", "vmf", "uvcf", "vn", "evif", "vfe", "cvm", "uvac", "svcf", "vef"], "idx": ["ridix", "index", " idlex", "likedx", "midxi", "ordix", "indxi", "likez", "inex", "indlex", "uidex", "midx", " idindex", "idxes", "idxx", "tryinx", " idxx", "ridex", "idinx", "identxf", "inix", "idxf", "idxa", "inx", " idz", "likexes", "midix", "indix", "indy", "iddx", "inz", "indinx", "pidix", "ordxi", " idxes", "ridx", "Idix", "ix", "ideex", "idexy", "iix", "Idz", " idxe", "idindex", "idxy", "likeix", "uidx", "identx", "identix", "ixe", "tryix", "ridxe", "midz", "ordx", " idex", "indx", "tryx", "IDix", "likexx", " idxy", "Idex", "ordz", "idy", "idlex", "IDex", "Idx", "inxx", " idxa", "likex", "uidxe", "trylex", "idix", "identxes", "identxe", "pidex", "IDx", "IDxa", "IDxf", " idy", "idxe", "idz", "idxi", "ideix", "pidx", " idix", "IDxy", "identdx", " idxf", "identxa", " idinx", "indz", "pidy", "uidix", "identindex", "IDindex", "Idy", " iddx", "idex"], "blockflag": ["Blocktag", "locklag", "chainflag", "iskflag", " blocklag", "isktag", "blockflags", "Blockflags", " blockstyle", "blocklag", "blocktag", " blocktag", "busFlag", "labellag", "isklag", "blockslag", "lockFlag", "labelattribute", "lockflags", "blocksflag", "lockstyle", "blFlag", "busstyle", "busflag", "lockattribute", "blockFlag", "Blockflag", "labelFlag", " blockFlag", "blocksFlag", "chainflags", "lockflag", "blockstyle", "iskFlag", "chainFlag", "blockattribute", "chainlag", "labelflag", "bllag", "blflag", " blockattribute", " blockflags", "Blocklag", "BlockFlag"], "n": ["nl", "ni", "nw", "nor", "f", "number", "o", "dn", "cn", "size", "l", "j", "ll", "p", "ln", "x", "names", "name", "v", "g", "ng", "t", "na", " N", "len", "np", "num", "nt", "m", "N", "nat", "y", "k", "r", "s", "gn", "c", "all", "nc", "en", "ul", "no", "ns", "un", "b", "h", "d", "nb", "ne", "net", "nia", "sn", "i", "nm", "network", "nan", "mn", "an", "nu", "nn"], "map": ["index", "mount", "query", "window", "place", "embed", "load", "le", "result", "lock", "m", "match", "add", "mm", "split", "make", "trace", "app", "pre", "MAP", "shape", "ape", "collect", "filter", "sum", "pack", "view", "type", "metadata", "mem", "search", "data", "mask", "group", "use", "open", "one", "link", "print", "table", "set", "mt", "pair", "mb", "save", "form", "pose", "node", "copy", "ip", "row", "where", "user", "batch", "store", "write", "show", "mate", "Map", "snap", "ask", "buffer", "block", "grid", "transform", "hash", "ash", "cast", "tap", "allow", "dict", "size", "stream", "cache", "cap", "tree", "ml", "message", "replace", "sp", "code", "ap", "maps", "mat", "master", "mp", "ace", "list", "max", "pad", "ve"]}}
{"project": "qemu", "commit_id": "b6866fee58bc25b01485dcfcf8be44a915c5f573", "target": 0, "func": "static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,\n\n                                  VirtIOSCSIReq *req)\n\n{\n\n    assert(req->elem.out_num && req->elem.in_num);\n\n    req->vq = vq;\n\n    req->dev = s;\n\n    req->sreq = NULL;\n\n    req->req.buf = req->elem.out_sg[0].iov_base;\n\n    req->resp.buf = req->elem.in_sg[0].iov_base;\n\n\n\n    if (req->elem.out_num > 1) {\n\n        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],\n\n                               &req->elem.out_addr[1],\n\n                               req->elem.out_num - 1);\n\n    } else {\n\n        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],\n\n                               &req->elem.in_addr[1],\n\n                               req->elem.in_num - 1);\n\n    }\n\n}\n", "idx": 15911, "substitutes": {"s": ["a", "S", "f", "out", "p", "js", "n", "si", "sq", "v", "g", "ms", "t", "is", "sys", "ds", "in", "m", "r", "ts", "c", "ns", "b", "dev", "h", "e", "fs", "os", "d", "i", "w", "x", "ss", "rs"], "vq": ["svpe", "svue", "vdq", "veq", " vdq", " vpe", "fue", "svdq", "vequ", "quue", "lue", "Vreq", "ququ", "quque", "visue", " vue", "fqu", "fqq", "vqu", "Vq", "fque", "vque", "vreq", "Vqq", "svq", "lq", "vispe", "quq", "fq", "Vue", "vpe", "visdq", "visq", "veue", "vqq", "vue", "freq", "lreq", "lqq", "veque"], "req": ["conn", "query", "push", "attr", "expr", "ctx", "cmp", "raw", "sq", "compl", "task", "eq", "load", "flow", "fee", "require", "gr", "coord", "start", "urg", "repl", "requ", "qt", "pkg", "usr", "exec", "qq", "required", "tx", "pro", "ret", "wx", "ind", "cmd", "crit", "http", "test", "comm", "spec", "iq", "wcs", "dist", "cfg", "aux", "tek", "inv", "comp", "res", "dep", "each", "conf", "arg", "tab", "history", "form", "resp", "rpm", "ref", "rw", "seq", "call", "temp", "ctr", "grab", "buf", "rest", "rep", "org", "work", "progress", "debug", "etc", "fr", "rd", "config", "err", "quest", "rr", "jp", "request", "good", "p", "deg", "reg", "pp", "msg", "ext", "desc", "r", "quick", "range", "dq", "decl", "rec", "rel", "var", "q", "init", "worker"]}}
{"project": "qemu", "commit_id": "5eb6d9e3ef1fac096ab5b3f5c14e1f4079dd7367", "target": 0, "func": "static void usb_uas_task(UASDevice *uas, uas_ui *ui)\n\n{\n\n    uint16_t tag = be16_to_cpu(ui->hdr.tag);\n\n    uint64_t lun64 = be64_to_cpu(ui->task.lun);\n\n    SCSIDevice *dev = usb_uas_get_dev(uas, lun64);\n\n    int lun = usb_uas_get_lun(lun64);\n\n    UASRequest *req;\n\n    uint16_t task_tag;\n\n\n\n    req = usb_uas_find_request(uas, be16_to_cpu(ui->hdr.tag));\n\n    if (req) {\n\n        goto overlapped_tag;\n\n    }\n\n\n\n    switch (ui->task.function) {\n\n    case UAS_TMF_ABORT_TASK:\n\n        task_tag = be16_to_cpu(ui->task.task_tag);\n\n        trace_usb_uas_tmf_abort_task(uas->dev.addr, tag, task_tag);\n\n        if (dev == NULL) {\n\n            goto bad_target;\n\n        }\n\n        if (dev->lun != lun) {\n\n            goto incorrect_lun;\n\n        }\n\n        req = usb_uas_find_request(uas, task_tag);\n\n        if (req && req->dev == dev) {\n\n            scsi_req_cancel(req->req);\n\n        }\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);\n\n        break;\n\n\n\n    case UAS_TMF_LOGICAL_UNIT_RESET:\n\n        trace_usb_uas_tmf_logical_unit_reset(uas->dev.addr, tag, lun);\n\n        if (dev == NULL) {\n\n            goto bad_target;\n\n        }\n\n        if (dev->lun != lun) {\n\n            goto incorrect_lun;\n\n        }\n\n        qdev_reset_all(&dev->qdev);\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);\n\n        break;\n\n\n\n    default:\n\n        trace_usb_uas_tmf_unsupported(uas->dev.addr, tag, ui->task.function);\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_NOT_SUPPORTED, 0);\n\n        break;\n\n    }\n\n    return;\n\n\n\noverlapped_tag:\n\n    usb_uas_queue_response(uas, req->tag, UAS_RC_OVERLAPPED_TAG, 0);\n\n    return;\n\n\n\nbad_target:\n\n    /* FIXME: correct?  [see long comment in usb_uas_command()] */\n\n    usb_uas_queue_response(uas, tag, UAS_RC_INVALID_INFO_UNIT, 0);\n\n    return;\n\n\n\nincorrect_lun:\n\n    usb_uas_queue_response(uas, tag, UAS_RC_INCORRECT_LUN, 0);\n\n}\n", "idx": 15924, "substitutes": {"uas": ["uuast", "ujAS", "uuasis", "tuaos", "ulis", "ujasm", "ujas", "ueaz", "uasy", "ulas", "cuasha", "puias", " uasis", "puas", "ueas", "ueasha", "uuis", "puaser", " uasha", "uap", "uuasy", "puase", " uast", "uaos", "uaz", "uasha", "tuades", "ouats", " uAS", "uuasha", "uasis", "ulaser", "puis", "cuads", "uis", "ulaos", "uacon", "uast", "ouacon", "cuass", "uasm", "uats", "tuasa", "ueads", " uats", "uuasa", "uades", "ujaz", "uuades", "uuacon", "cuas", "tuase", "uuaser", "ueasis", "uaser", " uasm", "uuads", "uuass", "cuasy", "puasha", "ueats", "cuast", "uuap", "ulias", "tuasy", "tuacon", "uuaos", " uap", "ulades", "ulasis", "tuasis", "tuas", "ueap", "cuap", "uuias", "uuas", "ouasa", "uase", "puass", "uuase", "ueast", "ueasm", "uAS", "uass", "uias", "uasa", "cuasis", " uaz", "uads", "ouap", "ouas", "ouasis", "cuase", "ueAS"], "ui": ["cu", "ua", "zu", "gui", "pu", "umi", "au", "asu", "iu", "tu", "ii", "ini", "mi", "ei", "uri", "uni", "ki", "imi", "si", "zi", "ali", "vi", "cli", "gu", "iq", "uj", "util", "di", "ami", "ia", "eu", "esi", "menu", "uu", "hi", "sim", "html", "api", "lu", "mu", "isu", "ci", "una", "agi", "uci", "eas", "u", "ou", "qt", "sup", "wu", "UI", "i", "gru", "ju", "jac"], "dev": ["conn", "attr", "hw", "devices", "val", "task", "gu", "den", "nt", "doc", "disc", "der", "adv", "develop", "app", "del", "tech", "pro", "def", "des", "mem", "ptr", "pub", "data", "warn", "cmd", "tr", "v", "test", "md", "spec", "dist", "dd", "env", "obj", "comment", "dem", "db", "dest", "res", "device", "dep", "ad", "conf", " Dev", "vo", "DEV", "ver", "head", "temp", "proc", "buf", "sys", "vid", "disk", "info", "development", "remote", "wd", "debug", "unknown", "jump", "de", "enc", "d", "err", "ev", "prom", "med", "go", "serv", "det", "Dev", "priv", "cam", "desc", "tag", "off", "dj", "sd", "var", "pad", "max", "ve", "prop", "w"], "req": ["cr", "query", "cur", "attr", "expr", "ctx", "cmp", "task", "result", "fee", "require", "gr", "urg", "Requ", "requ", "qt", "need", "rez", "pkg", "exec", "required", "qq", "tx", "rem", "ptr", "wx", "ind", "pr", "cmd", "j", "js", "crit", "comm", "iq", "dist", "tek", "comp", "res", "dep", "seek", "tar", " requ", "esp", "resp", "rpm", "ref", "cond", "seq", "feat", "perm", "ctr", "friend", "rep", "jump", "fr", "err", "ev", "quest", "rr", "jp", "request", "reg", "msg", "desc", "r", "quick", "dq", "pri", "rec", "rel", "gz", "q", "rx", "needed"], "task_tag": ["resultztag", "task__match", "ask_tag", "task_cat", "taskletstring", "taskingtag", "task2id", "taskmatcode", "task_match", "task_hash", "ask_cat", "task__TAG", "taskinghash", "ask_bug", "task_string", "resultztarget", "tasklystring", "task2match", "result_target", "taskztarget", "task_bug", "task2tag", "task__bug", "task_tags", "tasklybit", "task_dat", " task_dat", "task_code", "result_tag", "tasklettags", "ask_TAG", " task_bit", "taskingTag", "task_Tag", " task_tags", "ask_match", "task_target", "tasklytag", "task_num", "resultzid", "tasklettag", "ask_Tag", "taskmattags", "task2target", " task_string", "task2bug", "taskmatdat", "taskingcat", "resultznum", "task__tag", "taskzid", " task_code", "tasklytags", "task2num", "ask_hash", "task_id", "task_bit", "taskztag", "taskmattag", "result_num", "taskletbit", "task_TAG", "taskznum", "task2TAG", "result_id"]}}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)\n\n{\n\n    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);\n\n    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);\n\n    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);\n\n\n\n    if (!dev->conf.dinfo) {\n\n        fprintf(stderr, \"%s: no drive specified\\n\", qdev->info->name);\n\n        goto err;\n\n    }\n\n    if (dev->unit == -1) {\n\n        dev->unit = bus->master ? 1 : 0;\n\n    }\n\n    switch (dev->unit) {\n\n    case 0:\n\n        if (bus->master) {\n\n            fprintf(stderr, \"ide: tried to assign master twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->master = dev;\n\n        break;\n\n    case 1:\n\n        if (bus->slave) {\n\n            fprintf(stderr, \"ide: tried to assign slave twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->slave = dev;\n\n        break;\n\n    default:\n\n        goto err;\n\n    }\n\n    return info->init(dev);\n\n\n\nerr:\n\n    return -1;\n\n}\n", "idx": 15929, "substitutes": {"qdev": ["eqvar", "Qdef", " qserv", "qpad", "sqev", "qqev", "qqbus", "Qev", "qudev", "questblock", "qudef", "dqdev", "qqserv", "qblock", "questdev", "qudevice", "qdevice", " qdevice", "qublock", "dqpad", "qserv", "qqdev", "sqdef", "qqvar", "qDev", "quDev", "qev", "qvar", "eqblock", "dqev", "qqblock", "qqdef", "dqdef", "qqpad", " qvar", "qbus", "sqdev", "eqdev", "sqpad", " qdef", "qdef", "qupad", "Qdev", "qubus", "sqDev", "quev", "sqvar", "eqpad", "questpad", "dqDev", "dqdevice", " qDev", "quvar", "questbus", "Qserv", " qev"], "base": ["server", "profile", "type", "f", "local", "out", "family", "p", "raw", "check", "bi", "unit", "used", "ui", "help", "common", "show", "kb", "extra", "parent", "based", "use", "buffer", "file", "create", "bas", "basic", "b", "h", "id", "set", "i", "normal", "name", "Base", "ase"], "dev": ["conn", "hw", "raw", "dis", "val", "gu", "loc", "end", "nt", "doc", "van", "der", "cho", "serial", "draw", "develop", "app", "del", "tech", "pack", "pro", "tx", "def", "des", "mem", "patch", "data", "cmd", "v", "test", "spec", "obj", "env", "dem", "db", "res", "prov", "device", "dep", "ad", "conf", "stick", "av", "form", "vo", "train", "DEV", "ver", "di", "buf", "scan", "disk", "debug", "wd", "unknown", "de", "ev", "cast", "go", "serv", "local", "det", "build", "Dev", "priv", "util", "cam", "desc", "off", "event", "die", "var", "pad", "ve", "watch", "prop"], "info": ["bar", "status", "key", "def", "index", "type", "by", "mem", "f", "about", "py", "out", "det", "data", "ki", "si", "val", "details", "io", "spec", "kind", "is", "di", "op", "in", " inf", "hi", "extra", "time", "doc", "api", "buffer", "block", "fo", "file", "ci", "id", "inner", "order", "conf", "iter", "app", "os", "it", "config", "fi", "to", "Info", "init", "name", "INFO", "history", "inf", "sum"], "bus": ["BUS", "vol", "hand", "proxy", "train", "mount", "bs", "local", "bug", "data", "back", "hub", "group", "lib", "where", "boot", "pool", "chain", "test", "store", "box", "loc", "Bus", "bo", "cache", "buf", "loop", "util", "book", "lock", "disk", "aux", "parent", "bolt", "bridge", "buffer", "block", "db", "board", "pos", "sync", "alias", "ack", "bc", "master", "host", "rel", "prop", "stick", "cast", "home", "us", "driver"]}}
{"project": "qemu", "commit_id": "b2c98d9d392c87c9b9e975d30f79924719d9cbbe", "target": 0, "func": "static int tcg_match_ori(TCGType type, tcg_target_long val)\n\n{\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        if (type == TCG_TYPE_I32) {\n\n            /* All 32-bit ORs can be performed with 1 48-bit insn.  */\n\n            return 1;\n\n        }\n\n    }\n\n\n\n    /* Look for negative values.  These are best to load with LGHI.  */\n\n    if (val < 0) {\n\n        if (val == (int16_t)val) {\n\n            return 0;\n\n        }\n\n        if (facilities & FACILITY_EXT_IMM) {\n\n            if (val == (int32_t)val) {\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 15943, "substitutes": {"type": ["types", "key", "error", "ty", "Type", "ver", "inter", "family", "p", "class", "role", "otype", "typ", "rule", "test", "port", "t", "ping", "kind", "ct", "time", "range", "TYPE", "info", "tool", "file", "base", "like", "ype", "id", "state", "var", "tp", "length", "style", "name", "y", "pe"], "val": ["vol", " arg", " value", " Val", "stat", "t", "loc", "bil", "aval", " eval", " v", "rol", "cho", "VAL", "it", "nil", "tx", "def", "pr", "old", "crit", "pol", "fail", "v", "test", "sol", "ival", "res", "arg", "elt", "x", "unit", "eval", "buf", "al", "update", "slot", "vals", " l", "dev", "iter", " x", "err", "vt", " interval", "valid", "status", "Val", "l", "p", "grad", "xy", " aval", "el", "viol", "func", "item", "alt", " ty", "cal", "sel", "rel", "point", "prop", "value", "pl", "ele"]}}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "void OPPROTO op_addq_EDI_T0(void)\n\n{\n\n    EDI = (EDI + T0);\n\n}\n", "idx": 15962, "substitutes": {}}
{"project": "qemu", "commit_id": "af08a58f0ca338eafee855921859a8c1ace0175b", "target": 0, "func": "static void hypercall_register_types(void)\n\n{\n\n    /* hcall-pft */\n\n    spapr_register_hypercall(H_ENTER, h_enter);\n\n    spapr_register_hypercall(H_REMOVE, h_remove);\n\n    spapr_register_hypercall(H_PROTECT, h_protect);\n\n    spapr_register_hypercall(H_READ, h_read);\n\n\n\n    /* hcall-bulk */\n\n    spapr_register_hypercall(H_BULK_REMOVE, h_bulk_remove);\n\n\n\n    /* hcall-dabr */\n\n    spapr_register_hypercall(H_SET_DABR, h_set_dabr);\n\n\n\n    /* hcall-splpar */\n\n    spapr_register_hypercall(H_REGISTER_VPA, h_register_vpa);\n\n    spapr_register_hypercall(H_CEDE, h_cede);\n\n\n\n    /* processor register resource access h-calls */\n\n    spapr_register_hypercall(H_SET_SPRG0, h_set_sprg0);\n\n    spapr_register_hypercall(H_SET_MODE, h_set_mode);\n\n\n\n    /* \"debugger\" hcalls (also used by SLOF). Note: We do -not- differenciate\n\n     * here between the \"CI\" and the \"CACHE\" variants, they will use whatever\n\n     * mapping attributes qemu is using. When using KVM, the kernel will\n\n     * enforce the attributes more strongly\n\n     */\n\n    spapr_register_hypercall(H_LOGICAL_CI_LOAD, h_logical_load);\n\n    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);\n\n    spapr_register_hypercall(H_LOGICAL_CACHE_LOAD, h_logical_load);\n\n    spapr_register_hypercall(H_LOGICAL_CACHE_STORE, h_logical_store);\n\n    spapr_register_hypercall(H_LOGICAL_ICBI, h_logical_icbi);\n\n    spapr_register_hypercall(H_LOGICAL_DCBF, h_logical_dcbf);\n\n    spapr_register_hypercall(KVMPPC_H_LOGICAL_MEMOP, h_logical_memop);\n\n\n\n    /* qemu/KVM-PPC specific hcalls */\n\n    spapr_register_hypercall(KVMPPC_H_RTAS, h_rtas);\n\n\n\n    /* ibm,client-architecture-support support */\n\n    spapr_register_hypercall(KVMPPC_H_CAS, h_client_architecture_support);\n\n}\n", "idx": 15965, "substitutes": {}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config)\n\n{\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n    BlockConf *conf = &s->conf.conf;\n\n    struct virtio_blk_config blkcfg;\n\n    uint64_t capacity;\n\n    int blk_size = conf->logical_block_size;\n\n\n\n    bdrv_get_geometry(s->bs, &capacity);\n\n    memset(&blkcfg, 0, sizeof(blkcfg));\n\n    virtio_stq_p(vdev, &blkcfg.capacity, capacity);\n\n    virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2);\n\n    virtio_stw_p(vdev, &blkcfg.cylinders, conf->cyls);\n\n    virtio_stl_p(vdev, &blkcfg.blk_size, blk_size);\n\n    virtio_stw_p(vdev, &blkcfg.min_io_size, conf->min_io_size / blk_size);\n\n    virtio_stw_p(vdev, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);\n\n    blkcfg.heads = conf->heads;\n\n    /*\n\n     * We must ensure that the block device capacity is a multiple of\n\n     * the logical block size. If that is not the case, let's use\n\n     * sector_mask to adopt the geometry to have a correct picture.\n\n     * For those devices where the capacity is ok for the given geometry\n\n     * we don't touch the sector value of the geometry, since some devices\n\n     * (like s390 dasd) need a specific value. Here the capacity is already\n\n     * cyls*heads*secs*blk_size and the sector value is not block size\n\n     * divided by 512 - instead it is the amount of blk_size blocks\n\n     * per track (cylinder).\n\n     */\n\n    if (bdrv_getlength(s->bs) /  conf->heads / conf->secs % blk_size) {\n\n        blkcfg.sectors = conf->secs & ~s->sector_mask;\n\n    } else {\n\n        blkcfg.sectors = conf->secs;\n\n    }\n\n    blkcfg.size_max = 0;\n\n    blkcfg.physical_block_exp = get_physical_block_exp(conf);\n\n    blkcfg.alignment_offset = 0;\n\n    blkcfg.wce = bdrv_enable_write_cache(s->bs);\n\n    memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));\n\n}\n", "idx": 15977, "substitutes": {"vdev": ["vmdevice", "vserial", " vdat", " vdevice", "uvpad", "wdev", "vmpad", "uvserver", "hdiv", "vtdat", "vdevice", "wdevice", "vtloc", " vserial", "volserver", "vtcam", "vmend", "hhost", "uvver", "vcdev", " vpad", "uvpro", "vdes", "vmhost", "vmdat", "uvde", "uvdev", "veraddr", "uvdat", "uvend", "vdat", "mdev", "volver", "uvenv", "vpad", "hdev", "vmdiv", " vrad", "vmde", "vcrad", "venv", "vde", " vhost", " vver", "vtver", "vmserial", " venv", " vbus", "vdiv", "uvserial", "volenv", "uvdes", "wcam", " vloc", "vrad", "vhost", "hdevice", " vcam", "uvloc", "vend", "uvaddr", " vdiv", "vmenv", "vbus", " vpro", " vend", "vdb", "mbus", "verdev", "wdb", "mdevice", "vcam", "mrad", "voldev", "vcdevice", "vmdev", " vde", "vver", "vserver", " vaddr", "vcbus", "verpro", "verdes", "vtdb", " vdes", " vserver", "vtdev", "vtdevice", "vpro", " vdb", "vaddr", "vloc"], "config": ["rc", "cf", "conn", "settings", "fig", "out", "f", "tc", "data", "cmd", "map", "storage", "text", "t", "ic", "cache", "dc", "command", "ct", "m", "cfg", "comment", "ac", "info", "buffer", "c", "count", "content", "bc", "etc", "input", "fc", "con", "Config", "options", "sc", "cont"], "s": ["ses", "gs", "a", "S", "f", "settings", "serv", "bs", "j", "n", "js", "p", "sq", "conv", "v", "g", "t", "comm", "is", "sb", "sv", "service", "spec", "hs", "sys", "ds", "ls", "m", "y", "r", "qs", "sim", "ts", "self", "c", "sp", "stats", "ins", "ns", "b", "h", "fs", "app", "os", "d", "its", "i", "ss", "w", "sts", "rs", "ps"], "conf": ["conn", "query", "ctx", "cmp", "lib", "check", "com", "rank", "command", "fg", "fre", "cb", "disc", "irm", "app", "confirmed", "exec", "def", "param", "cmd", "map", "crit", "share", "conv", "fam", "acc", "comm", "spec", "nav", "cfg", "comment", "db", "comp", "cp", "cons", "con", "ca", "cf", "f", "ref", " cz", "scan", " Conf", "info", "c", "block", "bc", "dev", "fs", "state", "err", "cast", "inf", "go", "serv", "cm", "pb", "core", "p", "Conf", "priv", "cache", "dc", "cap", "range", "cal", "aff", "ns", "prop", "can", "ch"], "blkcfg": ["blckcf", "plkfg", "blickfg", "blmkcgi", "blunkcmd", "bltkcfg", "bleckconf", "blkerconn", "blakconfig", "blakcf", "plkmsg", "blmkmsg", "blekfg", "blkwconn", "blkkconf", "blncfg", " blckcb", " blckconn", "blikimg", "blmkcfg", " blckcmd", " blckgz", "blekcmd", "blkgc", "blkconfig", "blikfg", "blekcf", " blckmsg", "blakgz", "bleckcf", "blekconf", " blckimg", "blakmsg", "blckfg", "blkkmsg", "blickcfg", "blunkcfg", "blakfg", "blunkfg", " blkfg", "blkwbg", "blckgc", "bltkcss", " blkinit", "blkkcb", " blkmsg", "plkcfg", "blackcfg", "blkwcf", "blekconfig", " blkconfig", "blakcmd", "bleckcss", " blkbg", "blakcfg", "blickconfig", "blckinit", " blckfg", "blckcgi", "blkcf", "blakcgi", "blncf", "blackconn", "blckercfg", "blikbg", "blekcss", "bleckcmd", "blckgz", "blkercfg", "blkfg", "blKfg", "blikcfg", "blnconfig", " blkcss", "blakconf", "bleckmsg", "blKcf", "blkwfg", "blikcmd", "bleckgc", "blekgc", "blkinit", "blckconfig", " blkconf", "blkwcmd", " blckinit", "bltkcmd", "blnfg", "blkimg", "blckcss", "bltkfg", "bltkconn", "blkkcfg", "blvcmd", "blackfg", "blkbg", "blkcss", "blkerfg", "blKcss", "blckercss", "bleckfg", "blackcf", "blckimg", "blekmsg", "blKconf", "blkconf", "blKconfig", "blekcgi", " blkcmd", "blvbg", "blckerconfig", "blvcfg", "blckconf", " blckbg", "blkerinit", " blkimg", "blvfg", "blckcfg", "blckbg", " blkcb", "blkgz", "blikinit", "blunkimg", "blKcfg", "bleckconfig", "blunkbg", " blckconfig", "blkkcmd", "blckconn", "blckerfg", "blkcb", "blickgc", "blkwcfg", "blckcb", "blkmsg", "blkcgi", "plkconf", " blkcf", "bltkcb", "blmkfg", "blkcmd", "bleckcgi", "blckcmd", " blckcf", " blkconn", "blckmsg", "blekgz", "blkkcss", " blckcfg", "blkkcf", "blkconn", "bleckcfg", "blkercmd", "blkkfg", "blKgc", " blckconf", "blekcfg", " blckcss", " blkgz"], "capacity": ["status", "generation", "uration", "region", "type", "units", "position", "density", "CAP", "size", "lc", "SIZE", "VERSION", "city", "sequence", "devices", "largest", "clus", "height", "abilities", "powers", "spec", "cap", "currency", "command", "ENGTH", "cci", "power", " Capacity", "condition", "pieces", "slot", "available", "buffer", "c", " capacities", "ption", "dest", "count", "ci", "volume", "bc", "max", "length", "shape", "character", "ape", "slave", "growth", "usage", "capital", "demand", "acity", "history", "alloc"]}}
{"project": "qemu", "commit_id": "aea14095ea91f792ee43ee52fe6032cd8cdd7190", "target": 0, "func": "static void decode_opc (CPUMIPSState *env, DisasContext *ctx)\n\n{\n\n    int32_t offset;\n\n    int rs, rt, rd, sa;\n\n    uint32_t op, op1;\n\n    int16_t imm;\n\n\n\n    /* make sure instructions are on a word boundary */\n\n    if (ctx->pc & 0x3) {\n\n        env->CP0_BadVAddr = ctx->pc;\n\n        generate_exception(ctx, EXCP_AdEL);\n\n        return;\n\n    }\n\n\n\n    /* Handle blikely not taken case */\n\n    if ((ctx->hflags & MIPS_HFLAG_BMASK_BASE) == MIPS_HFLAG_BL) {\n\n        int l1 = gen_new_label();\n\n\n\n        MIPS_DEBUG(\"blikely condition (\" TARGET_FMT_lx \")\", ctx->pc + 4);\n\n        tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);\n\n        tcg_gen_movi_i32(hflags, ctx->hflags & ~MIPS_HFLAG_BMASK);\n\n        gen_goto_tb(ctx, 1, ctx->pc + 4);\n\n        gen_set_label(l1);\n\n    }\n\n\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n        tcg_gen_debug_insn_start(ctx->pc);\n\n    }\n\n\n\n    op = MASK_OP_MAJOR(ctx->opcode);\n\n    rs = (ctx->opcode >> 21) & 0x1f;\n\n    rt = (ctx->opcode >> 16) & 0x1f;\n\n    rd = (ctx->opcode >> 11) & 0x1f;\n\n    sa = (ctx->opcode >> 6) & 0x1f;\n\n    imm = (int16_t)ctx->opcode;\n\n    switch (op) {\n\n    case OPC_SPECIAL:\n\n        decode_opc_special(env, ctx);\n\n        break;\n\n    case OPC_SPECIAL2:\n\n        decode_opc_special2_legacy(env, ctx);\n\n        break;\n\n    case OPC_SPECIAL3:\n\n        decode_opc_special3(env, ctx);\n\n        break;\n\n    case OPC_REGIMM:\n\n        op1 = MASK_REGIMM(ctx->opcode);\n\n        switch (op1) {\n\n        case OPC_BLTZL: /* REGIMM branches */\n\n        case OPC_BGEZL:\n\n        case OPC_BLTZALL:\n\n        case OPC_BGEZALL:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        case OPC_BLTZ:\n\n        case OPC_BGEZ:\n\n            gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);\n\n            break;\n\n        case OPC_BLTZAL:\n\n        case OPC_BGEZAL:\n\n            if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                if (rs == 0) {\n\n                    /* OPC_NAL, OPC_BAL */\n\n                    gen_compute_branch(ctx, op1, 4, 0, -1, imm << 2, 4);\n\n                } else {\n\n                    generate_exception(ctx, EXCP_RI);\n\n                }\n\n            } else {\n\n                gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);\n\n            }\n\n            break;\n\n        case OPC_TGEI ... OPC_TEQI: /* REGIMM traps */\n\n        case OPC_TNEI:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            gen_trap(ctx, op1, rs, -1, imm);\n\n            break;\n\n        case OPC_SYNCI:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            /* Break the TB to be able to sync copied instructions\n\n               immediately */\n\n            ctx->bstate = BS_STOP;\n\n            break;\n\n        case OPC_BPOSGE32:    /* MIPS DSP branch */\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_BPOSGE64:\n\n#endif\n\n            check_dsp(ctx);\n\n            gen_compute_branch(ctx, op1, 4, -1, -2, (int32_t)imm << 2, 4);\n\n            break;\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_DAHI:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            check_mips_64(ctx);\n\n            if (rs != 0) {\n\n                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 32);\n\n            }\n\n            MIPS_DEBUG(\"dahi %s, %04x\", regnames[rs], imm);\n\n            break;\n\n        case OPC_DATI:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            check_mips_64(ctx);\n\n            if (rs != 0) {\n\n                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 48);\n\n            }\n\n            MIPS_DEBUG(\"dati %s, %04x\", regnames[rs], imm);\n\n            break;\n\n#endif\n\n        default:            /* Invalid */\n\n            MIPS_INVAL(\"regimm\");\n\n            generate_exception(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case OPC_CP0:\n\n        check_cp0_enabled(ctx);\n\n        op1 = MASK_CP0(ctx->opcode);\n\n        switch (op1) {\n\n        case OPC_MFC0:\n\n        case OPC_MTC0:\n\n        case OPC_MFTR:\n\n        case OPC_MTTR:\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_DMFC0:\n\n        case OPC_DMTC0:\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n            gen_cp0(env, ctx, op1, rt, rd);\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_C0_FIRST ... OPC_C0_LAST:\n\n#ifndef CONFIG_USER_ONLY\n\n            gen_cp0(env, ctx, MASK_C0(ctx->opcode), rt, rd);\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_MFMC0:\n\n#ifndef CONFIG_USER_ONLY\n\n            {\n\n                uint32_t op2;\n\n                TCGv t0 = tcg_temp_new();\n\n\n\n                op2 = MASK_MFMC0(ctx->opcode);\n\n                switch (op2) {\n\n                case OPC_DMT:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_dmt(t0);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_EMT:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_emt(t0);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_DVPE:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_dvpe(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_EVPE:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_evpe(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_DI:\n\n                    check_insn(ctx, ISA_MIPS32R2);\n\n                    save_cpu_state(ctx, 1);\n\n                    gen_helper_di(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    /* Stop translation as we may have switched the execution mode */\n\n                    ctx->bstate = BS_STOP;\n\n                    break;\n\n                case OPC_EI:\n\n                    check_insn(ctx, ISA_MIPS32R2);\n\n                    save_cpu_state(ctx, 1);\n\n                    gen_helper_ei(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    /* Stop translation as we may have switched the execution mode */\n\n                    ctx->bstate = BS_STOP;\n\n                    break;\n\n                default:            /* Invalid */\n\n                    MIPS_INVAL(\"mfmc0\");\n\n                    generate_exception(ctx, EXCP_RI);\n\n                    break;\n\n                }\n\n                tcg_temp_free(t0);\n\n            }\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_RDPGPR:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_load_srsgpr(rt, rd);\n\n            break;\n\n        case OPC_WRPGPR:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_store_srsgpr(rt, rd);\n\n            break;\n\n        default:\n\n            MIPS_INVAL(\"cp0\");\n\n            generate_exception(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case OPC_BOVC: /* OPC_BEQZALC, OPC_BEQC, OPC_ADDI */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BOVC, OPC_BEQZALC, OPC_BEQC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_ADDI */\n\n            /* Arithmetic with immediate opcode */\n\n            gen_arith_imm(ctx, op, rt, rs, imm);\n\n        }\n\n        break;\n\n    case OPC_ADDIU:\n\n         gen_arith_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SLTI: /* Set on less than with immediate opcode */\n\n    case OPC_SLTIU:\n\n         gen_slt_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_ANDI: /* Arithmetic with immediate opcode */\n\n    case OPC_LUI: /* OPC_AUI */\n\n    case OPC_ORI:\n\n    case OPC_XORI:\n\n         gen_logic_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_J ... OPC_JAL: /* Jump */\n\n         offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;\n\n         gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);\n\n         break;\n\n    /* Branch */\n\n    case OPC_BLEZC: /* OPC_BGEZC, OPC_BGEC, OPC_BLEZL */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rt == 0) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n            /* OPC_BLEZC, OPC_BGEZC, OPC_BGEC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_BLEZL */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        }\n\n        break;\n\n    case OPC_BGTZC: /* OPC_BLTZC, OPC_BLTC, OPC_BGTZL */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rt == 0) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n            /* OPC_BGTZC, OPC_BLTZC, OPC_BLTC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_BGTZL */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        }\n\n        break;\n\n    case OPC_BLEZALC: /* OPC_BGEZALC, OPC_BGEUC, OPC_BLEZ */\n\n        if (rt == 0) {\n\n            /* OPC_BLEZ */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        } else {\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            /* OPC_BLEZALC, OPC_BGEZALC, OPC_BGEUC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        }\n\n        break;\n\n    case OPC_BGTZALC: /* OPC_BLTZALC, OPC_BLTUC, OPC_BGTZ */\n\n        if (rt == 0) {\n\n            /* OPC_BGTZ */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        } else {\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            /* OPC_BGTZALC, OPC_BLTZALC, OPC_BLTUC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        }\n\n        break;\n\n    case OPC_BEQL:\n\n    case OPC_BNEL:\n\n         check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_BEQ:\n\n    case OPC_BNE:\n\n         gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n         break;\n\n    case OPC_LWL: /* Load and stores */\n\n    case OPC_LWR:\n\n    case OPC_LL:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_LB ... OPC_LH:\n\n    case OPC_LW ... OPC_LHU:\n\n         gen_ld(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SWL:\n\n    case OPC_SWR:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_SB ... OPC_SH:\n\n    case OPC_SW:\n\n         gen_st(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SC:\n\n         check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n         gen_st_cond(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_CACHE:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_cp0_enabled(ctx);\n\n        check_insn(ctx, ISA_MIPS3 | ISA_MIPS32);\n\n        /* Treat as NOP. */\n\n        break;\n\n    case OPC_PREF:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_insn(ctx, ISA_MIPS4 | ISA_MIPS32);\n\n        /* Treat as NOP. */\n\n        break;\n\n\n\n    /* Floating point (COP1). */\n\n    case OPC_LWC1:\n\n    case OPC_LDC1:\n\n    case OPC_SWC1:\n\n    case OPC_SDC1:\n\n        gen_cop1_ldst(ctx, op, rt, rs, imm);\n\n        break;\n\n\n\n    case OPC_CP1:\n\n        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {\n\n            check_cp1_enabled(ctx);\n\n            op1 = MASK_CP1(ctx->opcode);\n\n            switch (op1) {\n\n            case OPC_MFHC1:\n\n            case OPC_MTHC1:\n\n                check_insn(ctx, ISA_MIPS32R2);\n\n            case OPC_MFC1:\n\n            case OPC_CFC1:\n\n            case OPC_MTC1:\n\n            case OPC_CTC1:\n\n                gen_cp1(ctx, op1, rt, rd);\n\n                break;\n\n#if defined(TARGET_MIPS64)\n\n            case OPC_DMFC1:\n\n            case OPC_DMTC1:\n\n                check_insn(ctx, ISA_MIPS3);\n\n                gen_cp1(ctx, op1, rt, rd);\n\n                break;\n\n#endif\n\n            case OPC_BC1EQZ: /* OPC_BC1ANY2 */\n\n                if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                    /* OPC_BC1EQZ */\n\n                    gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),\n\n                                    rt, imm << 2);\n\n                } else {\n\n                    /* OPC_BC1ANY2 */\n\n                    check_cop1x(ctx);\n\n                    check_insn(ctx, ASE_MIPS3D);\n\n                    gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),\n\n                                    (rt >> 2) & 0x7, imm << 2);\n\n                }\n\n                break;\n\n            case OPC_BC1NEZ:\n\n                check_insn(ctx, ISA_MIPS32R6);\n\n                gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),\n\n                                rt, imm << 2);\n\n                break;\n\n            case OPC_BC1ANY4:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n                check_cop1x(ctx);\n\n                check_insn(ctx, ASE_MIPS3D);\n\n                /* fall through */\n\n            case OPC_BC1:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n                gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),\n\n                                    (rt >> 2) & 0x7, imm << 2);\n\n                break;\n\n            case OPC_PS_FMT:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            case OPC_S_FMT:\n\n            case OPC_D_FMT:\n\n                gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                           (imm >> 8) & 0x7);\n\n                break;\n\n            case OPC_W_FMT:\n\n            case OPC_L_FMT:\n\n            {\n\n                int r6_op = ctx->opcode & FOP(0x3f, 0x1f);\n\n                if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                    switch (r6_op) {\n\n                    case R6_OPC_CMP_AF_S:\n\n                    case R6_OPC_CMP_UN_S:\n\n                    case R6_OPC_CMP_EQ_S:\n\n                    case R6_OPC_CMP_UEQ_S:\n\n                    case R6_OPC_CMP_LT_S:\n\n                    case R6_OPC_CMP_ULT_S:\n\n                    case R6_OPC_CMP_LE_S:\n\n                    case R6_OPC_CMP_ULE_S:\n\n                    case R6_OPC_CMP_SAF_S:\n\n                    case R6_OPC_CMP_SUN_S:\n\n                    case R6_OPC_CMP_SEQ_S:\n\n                    case R6_OPC_CMP_SEUQ_S:\n\n                    case R6_OPC_CMP_SLT_S:\n\n                    case R6_OPC_CMP_SULT_S:\n\n                    case R6_OPC_CMP_SLE_S:\n\n                    case R6_OPC_CMP_SULE_S:\n\n                    case R6_OPC_CMP_OR_S:\n\n                    case R6_OPC_CMP_UNE_S:\n\n                    case R6_OPC_CMP_NE_S:\n\n                    case R6_OPC_CMP_SOR_S:\n\n                    case R6_OPC_CMP_SUNE_S:\n\n                    case R6_OPC_CMP_SNE_S:\n\n                        gen_r6_cmp_s(ctx, ctx->opcode & 0x1f, rt, rd, sa);\n\n                        break;\n\n                    case R6_OPC_CMP_AF_D:\n\n                    case R6_OPC_CMP_UN_D:\n\n                    case R6_OPC_CMP_EQ_D:\n\n                    case R6_OPC_CMP_UEQ_D:\n\n                    case R6_OPC_CMP_LT_D:\n\n                    case R6_OPC_CMP_ULT_D:\n\n                    case R6_OPC_CMP_LE_D:\n\n                    case R6_OPC_CMP_ULE_D:\n\n                    case R6_OPC_CMP_SAF_D:\n\n                    case R6_OPC_CMP_SUN_D:\n\n                    case R6_OPC_CMP_SEQ_D:\n\n                    case R6_OPC_CMP_SEUQ_D:\n\n                    case R6_OPC_CMP_SLT_D:\n\n                    case R6_OPC_CMP_SULT_D:\n\n                    case R6_OPC_CMP_SLE_D:\n\n                    case R6_OPC_CMP_SULE_D:\n\n                    case R6_OPC_CMP_OR_D:\n\n                    case R6_OPC_CMP_UNE_D:\n\n                    case R6_OPC_CMP_NE_D:\n\n                    case R6_OPC_CMP_SOR_D:\n\n                    case R6_OPC_CMP_SUNE_D:\n\n                    case R6_OPC_CMP_SNE_D:\n\n                        gen_r6_cmp_d(ctx, ctx->opcode & 0x1f, rt, rd, sa);\n\n                        break;\n\n                    default:\n\n                        gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                                                       (imm >> 8) & 0x7);\n\n                        break;\n\n                    }\n\n                } else {\n\n                    gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                               (imm >> 8) & 0x7);\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                MIPS_INVAL(\"cp1\");\n\n                generate_exception (ctx, EXCP_RI);\n\n                break;\n\n            }\n\n        } else {\n\n            generate_exception_err(ctx, EXCP_CpU, 1);\n\n        }\n\n        break;\n\n\n\n    /* Compact branches [R6] and COP2 [non-R6] */\n\n    case OPC_BC: /* OPC_LWC2 */\n\n    case OPC_BALC: /* OPC_SWC2 */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BC, OPC_BALC */\n\n            gen_compute_compact_branch(ctx, op, 0, 0,\n\n                                       sextract32(ctx->opcode << 2, 0, 28));\n\n        } else {\n\n            /* OPC_LWC2, OPC_SWC2 */\n\n            /* COP2: Not implemented. */\n\n            generate_exception_err(ctx, EXCP_CpU, 2);\n\n        }\n\n        break;\n\n    case OPC_BEQZC: /* OPC_JIC, OPC_LDC2 */\n\n    case OPC_BNEZC: /* OPC_JIALC, OPC_SDC2 */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rs != 0) {\n\n                /* OPC_BEQZC, OPC_BNEZC */\n\n                gen_compute_compact_branch(ctx, op, rs, 0,\n\n                                           sextract32(ctx->opcode << 2, 0, 23));\n\n            } else {\n\n                /* OPC_JIC, OPC_JIALC */\n\n                gen_compute_compact_branch(ctx, op, 0, rt, imm);\n\n            }\n\n        } else {\n\n            /* OPC_LWC2, OPC_SWC2 */\n\n            /* COP2: Not implemented. */\n\n            generate_exception_err(ctx, EXCP_CpU, 2);\n\n        }\n\n        break;\n\n    case OPC_CP2:\n\n        check_insn(ctx, INSN_LOONGSON2F);\n\n        /* Note that these instructions use different fields.  */\n\n        gen_loongson_multimedia(ctx, sa, rd, rt);\n\n        break;\n\n\n\n    case OPC_CP3:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {\n\n            check_cp1_enabled(ctx);\n\n            op1 = MASK_CP3(ctx->opcode);\n\n            switch (op1) {\n\n            case OPC_LWXC1:\n\n            case OPC_LDXC1:\n\n            case OPC_LUXC1:\n\n            case OPC_SWXC1:\n\n            case OPC_SDXC1:\n\n            case OPC_SUXC1:\n\n                gen_flt3_ldst(ctx, op1, sa, rd, rs, rt);\n\n                break;\n\n            case OPC_PREFX:\n\n                /* Treat as NOP. */\n\n                break;\n\n            case OPC_ALNV_PS:\n\n            case OPC_MADD_S:\n\n            case OPC_MADD_D:\n\n            case OPC_MADD_PS:\n\n            case OPC_MSUB_S:\n\n            case OPC_MSUB_D:\n\n            case OPC_MSUB_PS:\n\n            case OPC_NMADD_S:\n\n            case OPC_NMADD_D:\n\n            case OPC_NMADD_PS:\n\n            case OPC_NMSUB_S:\n\n            case OPC_NMSUB_D:\n\n            case OPC_NMSUB_PS:\n\n                gen_flt3_arith(ctx, op1, sa, rs, rd, rt);\n\n                break;\n\n            default:\n\n                MIPS_INVAL(\"cp3\");\n\n                generate_exception (ctx, EXCP_RI);\n\n                break;\n\n            }\n\n        } else {\n\n            generate_exception_err(ctx, EXCP_CpU, 1);\n\n        }\n\n        break;\n\n\n\n#if defined(TARGET_MIPS64)\n\n    /* MIPS64 opcodes */\n\n    case OPC_LDL ... OPC_LDR:\n\n    case OPC_LLD:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_LWU:\n\n    case OPC_LD:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_ld(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_SDL ... OPC_SDR:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_SD:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_st(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_SCD:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_st_cond(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC, OPC_DADDI */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BNVC, OPC_BNEZALC, OPC_BNEC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_DADDI */\n\n            check_insn(ctx, ISA_MIPS3);\n\n            check_mips_64(ctx);\n\n            gen_arith_imm(ctx, op, rt, rs, imm);\n\n        }\n\n        break;\n\n    case OPC_DADDIU:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_arith_imm(ctx, op, rt, rs, imm);\n\n        break;\n\n#else\n\n    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            MIPS_INVAL(\"major opcode\");\n\n            generate_exception(ctx, EXCP_RI);\n\n        }\n\n        break;\n\n#endif\n\n    case OPC_DAUI: /* OPC_JALX */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n#if defined(TARGET_MIPS64)\n\n            /* OPC_DAUI */\n\n            check_mips_64(ctx);\n\n            if (rt != 0) {\n\n                TCGv t0 = tcg_temp_new();\n\n                gen_load_gpr(t0, rs);\n\n                tcg_gen_addi_tl(cpu_gpr[rt], t0, imm << 16);\n\n                tcg_temp_free(t0);\n\n            }\n\n            MIPS_DEBUG(\"daui %s, %s, %04x\", regnames[rt], regnames[rs], imm);\n\n#else\n\n            generate_exception(ctx, EXCP_RI);\n\n            MIPS_INVAL(\"major opcode\");\n\n#endif\n\n        } else {\n\n            /* OPC_JALX */\n\n            check_insn(ctx, ASE_MIPS16 | ASE_MICROMIPS);\n\n            offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;\n\n            gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);\n\n        }\n\n        break;\n\n    case OPC_MDMX:\n\n        check_insn(ctx, ASE_MDMX);\n\n        /* MDMX: Not implemented. */\n\n        break;\n\n    case OPC_PCREL:\n\n        check_insn(ctx, ISA_MIPS32R6);\n\n        gen_pcrel(ctx, rs, imm);\n\n        break;\n\n    default:            /* Invalid */\n\n        MIPS_INVAL(\"major opcode\");\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n", "idx": 15980, "substitutes": {"env": ["server", "nv", "conn", "et", "serv", "environment", "setup", "addr", "cmd", "hw", "pb", "window", "erd", "proc", "ee", "vp", "vert", "v", "outer", "esc", "sv", "er", "sb", "buf", "end", "sys", "ef", "esi", "ew", "context", "obj", "org", "vm", "buffer", "chart", "cv", "en", "ec", "code", "vs", "dev", "h", "e", "conf", "state", "var", "config", "net", "ev", "vt", "pkg", "w", "esp", "init", "viron", "txt", "pe", "worker"], "ctx": ["index", "conn", "hw", "scope", "window", "cmp", "stat", "mk", "cas", "check", "loc", "nt", "context", "kb", "cb", "xc", "abc", "qt", "pkg", "exec", "ka", "tx", "kw", "ctl", "def", "fw", "co", "wx", "setup", "warn", "cmd", "crit", "kt", "timeout", "conv", "xp", "wcs", "cfg", "obj", "aux", "nc", "std", "cp", "gc", "mc", "ctrl", "Context", "tmp", "conf", "x", "txt", "history", "resp", "cf", "canon", "pause", "phys", "kh", "this", "dl", "cc", "req", "tk", "xs", "batch", "ctr", "sys", "np", "json", "org", "work", "cv", "wk", "mom", "kl", "cookie", "bc", "etc", "config", "px", "tm", "init", "HK", "alloc", "jac", "jp", "cu", "tc", "cm", "handle", "pb", "grad", "kind", "msg", "dc", "func", "ct", "act", "desc", "cl", "prefix", "ck", "handler", "parse", "fc", "that", "gz", "bp", "inst", "sc", "anc"], "offset": ["ptr", " ox", " cpu", "addr", " sp", "p", " loc", "osp", " cop", "len", "xp", " pos", "s", " off", " shr", " opaque", " oper", "sp", " org", " reg", " esp", " ro", " res", " ori", " xp"], "rs": ["rc", "ress", "obs", "bs", "rss", "mr", "dr", "vr", "eps", "xs", "ros", "rors", "ds", "ats", "ls", "r", "aps", "Rs", "ars", "rys", "ts", "vs", "ins", "ns", "res", "cs", "ops", "ras", "ims", "pc", "acks", "ows", "os", "ris", "rx", "rr", "RS", "ps"], "rt": ["rc", "ptr", "rw", "src", "rn", "ra", "pr", "tt", "tr", "rf", "rl", "vr", "dt", "reg", "pt", "bt", "rid", "rm", "wt", "rb", "ct", "nt", "r", "rat", "art", "ro", "rh", "rot", "RT", "res", "rod", "red", "rin", "fr", "rx", "rr"], "rd": ["rc", "cr", "rog", "ptr", "udd", "rw", "rss", "ra", "hr", "usr", "dn", "mr", "dr", "erd", "rl", "cd", "rr", "ru", "nd", "rid", "rb", "ds", "dd", "r", "bd", "rh", "sr", "rod", "red", "rin", "ri", "d", "rx", "rn", "dra"], "sa": ["tha", "ba", "a", "aa", "as", "SA", "au", "ra", "sta", "ain", "si", "sq", "ar", "sl", "sam", "sm", "sb", "sv", "sys", "pse", "ds", "ai", "nat", "s", "sha", "ais", "ppa", "va", "sr", "ns", "nas", "sd", "asa", "se", "ata", "ss", "pa", "na"], "op": ["bit", "ipp", " OP", "jp", "type", "Op", "oc", "o", "ope", "cmd", "p", "pop", "cmp", "operator", "opt", "typ", "oop", "val", "oper", "osp", " cop", "rip", "pp", "cop", "cat", "act", "omp", "lit", "operation", "yp", "hop", "sp", "opl", "opp", "pos", "top", " ops", "ep", "ap", " ip", "ops", "ype", "ort", "OP", "ot", "it", "rop", "nick", "ip"], "op1": ["OP2", "optn", "OPOne", "op01", "operaj", "cop1", "opt2", "ip2", "oper2", "cop01", "OPaj", "ip0", "cop2", "OP1", "optaj", "OPn", "opt1", "ipOne", "Op2", "OpOne", "op0", "OP01", " opOne", "ip1", "oper1", "opn", "opern", "opOne", "opaj", " op0", " op01", "Op0", "Op1", "copOne"], "imm": ["vol", "il", "utm", "mem", "mi", "asm", "attr", "iam", "tt", "temp", "mint", "perm", "amm", "pt", "ym", "sm", "rm", "fm", "em", "m", "ann", "alt", "att", "pai", "sim", "vm", "im", "imp", "dim", "margin", "bm", "mm", "gm", "ims", "mp", "mt", "tm", "txt", "mun", "iat", "ip"]}}
{"project": "qemu", "commit_id": "8f3a73bc57ea83e5b3930d14fc596ea51859987a", "target": 0, "func": "bool blk_dev_is_tray_open(BlockBackend *blk)\n\n{\n\n    if (blk->dev_ops && blk->dev_ops->is_tray_open) {\n\n        return blk->dev_ops->is_tray_open(blk->dev_opaque);\n\n    }\n\n    return false;\n\n}\n", "idx": 15985, "substitutes": {"blk": [" blb", "Blks", "flck", "blc", "pln", "plq", "blockj", "Blk", "blkt", "Blak", "blockk", "flk", "blks", " blak", "blockkt", "blockak", " blc", "plck", "blq", "blck", "Blq", "fln", "Blkt", "blak", "plks", "blb", "Blck", "plb", " blks", "blockc", "Blc", " blq", "bln", "blockck", " blkt", "plak", "Blj", "flb", "blj", "plj", " blj", " bln", " blck", "plk"]}}
{"project": "FFmpeg", "commit_id": "88ddcfa37f0067aae7457b44f433982f4c6d72ee", "target": 1, "func": "static av_cold int tdsc_init(AVCodecContext *avctx)\n\n{\n\n    TDSCContext *ctx = avctx->priv_data;\n\n    const AVCodec *codec;\n\n    int ret;\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_BGR24;\n\n\n\n    /* These needs to be set to estimate buffer and frame size */\n\n    if (!(avctx->width && avctx->height)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Video size not set.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* This value should be large enough for a RAW-only frame plus headers */\n\n    ctx->deflatelen = avctx->width * avctx->height * (3 + 1);\n\n    ret = av_reallocp(&ctx->deflatebuffer, ctx->deflatelen);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Allocate reference and JPEG frame */\n\n    ctx->refframe = av_frame_alloc();\n\n    ctx->jpgframe = av_frame_alloc();\n\n    if (!ctx->refframe || !ctx->jpgframe)\n\n        return AVERROR(ENOMEM);\n\n\n\n    /* Prepare everything needed for JPEG decoding */\n\n    codec = avcodec_find_decoder(AV_CODEC_ID_MJPEG);\n\n    if (!codec)\n\n        return AVERROR_BUG;\n\n    ctx->jpeg_avctx = avcodec_alloc_context3(codec);\n\n    if (!ctx->jpeg_avctx)\n\n        return AVERROR(ENOMEM);\n\n    ctx->jpeg_avctx->flags = avctx->flags;\n\n    ctx->jpeg_avctx->flags2 = avctx->flags2;\n\n    ctx->jpeg_avctx->dct_algo = avctx->dct_algo;\n\n    ctx->jpeg_avctx->idct_algo = avctx->idct_algo;;\n\n    ret = avcodec_open2(ctx->jpeg_avctx, codec, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Set the output pixel format on the reference frame */\n\n    ctx->refframe->format = avctx->pix_fmt;\n\n\n\n    return 0;\n\n}\n", "idx": 15987, "substitutes": {"avctx": ["avtx", "iverctx", " avkl", "avercfg", "avercrit", "devcmp", "avcoll", "avereq", "ajcfg", "devkl", "savreq", " avcrit", "avpkg", "afcmp", "abcontext", "vercontext", "afpkg", "ajkl", "devtx", "avertx", "ajcrit", " avcu", " avcontext", "avtc", " avctl", "avcfg", "averkl", "avcmp", "avkl", "averreq", "afctl", "savctx", "avecrit", "avecontext", "ivercontext", "ajcu", "vercu", "ivercoll", "avetx", "avgc", " avcp", "savcrit", "avergc", "verctx", " avcmp", "vertc", "abctx", " avcfg", "devcontext", "ajcmp", "avecfg", " avreq", "avcu", " avconn", "savcontext", "averpkg", "afcontext", " avtc", "ajcontext", "avekl", "devctx", "vercp", "avcp", "afcmd", "ajpkg", "avecp", "afctx", "avreq", "averctx", "ajgc", "vercmd", "avcmd", "avconn", "ajtx", "iverreq", "avecmp", "aveconn", "avcrit", "avectl", " avpkg", "avctl", "avcontext", "avepkg", "avegc", "ajctx", " avcmd", "ajconn", " avtx", "averconn", "abcrit", "avectx", "abreq", "avetc", "abcmp", "vercmp", " avcoll", "avecoll", "ajcmd", "abtx"], "ctx": ["conn", "hw", "expr", "scope", "cmp", "mk", "val", "check", "pool", "loc", "st", "nt", "context", "doc", "cb", "xc", "abc", "qt", "iac", "pkg", "exec", "qq", "tx", "kw", "ctl", "ptr", "wx", "lc", "addr", "cmd", "crit", "kt", "timeout", "comm", "xp", "wcs", "cfg", "obj", "aux", "nc", "ctrl", "cp", "gc", "conf", "ca", "coll", "txt", "history", "resp", "cf", " context", "utils", "cc", "req", "proc", "tk", "ctr", "sys", "np", " cx", "cv", "kl", "lex", "bc", "etc", "acl", "pc", "tm", "na", "jac", "iat", "alloc", "jp", "tc", "cm", "except", "pt", "msg", "func", "ct", "cl", "act", "desc", "cam", "prefix", "rt", "ck", "tz", "inst", "mx"], "codec": ["cmdec", "codek", "odec", " codel", "oderer", "codEC", "defec", "cmdenc", "Codec", "odeca", "codeef", "coderer", "Coderer", "oduc", " codpeg", "Codoc", "codeca", "codenc", "defpeg", "codeek", "codeec", "candec", "codeenc", "citec", "candEC", "cmdek", "citEC", "citeca", " coduc", "candeco", " codeco", " codef", " codEC", "codel", "codpeg", "odeco", "defoc", "codeEC", "defEC", " codek", "cmdef", "codeel", "CodEC", "codoc", "codeeco", "odel", "cituc", "codef", "Codeco", "coduc", "canderer", "codeco", " codeca", "Codpeg", " codenc", " codoc", "odEC"], "ret": ["resp", "status", "rem", "def", "mem", "f", "out", "ref", " RET", "det", "ll", "pret", "fun", "back", "Ret", "tr", "rets", "RET", "val", "reset", "compl", "deg", "try", "reg", "t", "len", "rm", "result", "ext", "tn", "nt", "br", "lit", "get", "alt", "gt", "att", "rt", "rat", "ry", "res", "print", "flag", "ber", "cert", "re", " res", "mt", "cont", "ft", "it", "elt", "err", "pas", " Ret", "del", "value", "ter", "usr", " fut", "arr"]}}
{"project": "qemu", "commit_id": "3010460fb99776bdf0a8b170555f2ab076382f9c", "target": 1, "func": "int hvf_vcpu_exec(CPUState *cpu)\n\n{\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n    CPUX86State *env = &x86_cpu->env;\n\n    int ret = 0;\n\n    uint64_t rip = 0;\n\n\n\n    cpu->halted = 0;\n\n\n\n    if (hvf_process_events(cpu)) {\n\n        return EXCP_HLT;\n\n    }\n\n\n\n    do {\n\n        if (cpu->vcpu_dirty) {\n\n            hvf_put_registers(cpu);\n\n            cpu->vcpu_dirty = false;\n\n        }\n\n\n\n        if (hvf_inject_interrupts(cpu)) {\n\n            return EXCP_INTERRUPT;\n\n        }\n\n        vmx_update_tpr(cpu);\n\n\n\n        qemu_mutex_unlock_iothread();\n\n        if (!cpu_is_bsp(X86_CPU(cpu)) && cpu->halted) {\n\n            qemu_mutex_lock_iothread();\n\n            return EXCP_HLT;\n\n        }\n\n\n\n        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);\n\n        assert_hvf_ok(r);\n\n\n\n        /* handle VMEXIT */\n\n        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);\n\n        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);\n\n        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,\n\n                                           VMCS_EXIT_INSTRUCTION_LENGTH);\n\n\n\n        uint64_t idtvec_info = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n\n\n        hvf_store_events(cpu, ins_len, idtvec_info);\n\n        rip = rreg(cpu->hvf_fd, HV_X86_RIP);\n\n        RFLAGS(env) = rreg(cpu->hvf_fd, HV_X86_RFLAGS);\n\n        env->eflags = RFLAGS(env);\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        update_apic_tpr(cpu);\n\n        current_cpu = cpu;\n\n\n\n        ret = 0;\n\n        switch (exit_reason) {\n\n        case EXIT_REASON_HLT: {\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            if (!((cpu->interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                (EFLAGS(env) & IF_MASK))\n\n                && !(cpu->interrupt_request & CPU_INTERRUPT_NMI) &&\n\n                !(idtvec_info & VMCS_IDT_VEC_VALID)) {\n\n                cpu->halted = 1;\n\n                ret = EXCP_HLT;\n\n            }\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_MWAIT: {\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n            /* Need to check if MMIO or unmmaped fault */\n\n        case EXIT_REASON_EPT_FAULT:\n\n        {\n\n            hvf_slot *slot;\n\n            addr_t gpa = rvmcs(cpu->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);\n\n\n\n            if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&\n\n                ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {\n\n                vmx_set_nmi_blocking(cpu);\n\n            }\n\n\n\n            slot = hvf_find_overlap_slot(gpa, gpa);\n\n            /* mmio */\n\n            if (ept_emulation_fault(slot, gpa, exit_qual)) {\n\n                struct x86_decode decode;\n\n\n\n                load_regs(cpu);\n\n                env->hvf_emul->fetch_rip = rip;\n\n\n\n                decode_instruction(env, &decode);\n\n                exec_instruction(env, &decode);\n\n                store_regs(cpu);\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        case EXIT_REASON_INOUT:\n\n        {\n\n            uint32_t in = (exit_qual & 8) != 0;\n\n            uint32_t size =  (exit_qual & 7) + 1;\n\n            uint32_t string =  (exit_qual & 16) != 0;\n\n            uint32_t port =  exit_qual >> 16;\n\n            /*uint32_t rep = (exit_qual & 0x20) != 0;*/\n\n\n\n#if 1\n\n            if (!string && in) {\n\n                uint64_t val = 0;\n\n                load_regs(cpu);\n\n                hvf_handle_io(env, port, &val, 0, size, 1);\n\n                if (size == 1) {\n\n                    AL(env) = val;\n\n                } else if (size == 2) {\n\n                    AX(env) = val;\n\n                } else if (size == 4) {\n\n                    RAX(env) = (uint32_t)val;\n\n                } else {\n\n                    VM_PANIC(\"size\");\n\n                }\n\n                RIP(env) += ins_len;\n\n                store_regs(cpu);\n\n                break;\n\n            } else if (!string && !in) {\n\n                RAX(env) = rreg(cpu->hvf_fd, HV_X86_RAX);\n\n                hvf_handle_io(env, port, &RAX(env), 1, size, 1);\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n#endif\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            VM_PANIC_ON(ins_len != decode.len);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n\n\n            break;\n\n        }\n\n        case EXIT_REASON_CPUID: {\n\n            uint32_t rax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t rbx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RBX);\n\n            uint32_t rcx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t rdx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);\n\n\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, rax);\n\n            wreg(cpu->hvf_fd, HV_X86_RBX, rbx);\n\n            wreg(cpu->hvf_fd, HV_X86_RCX, rcx);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, rdx);\n\n\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_XSETBV: {\n\n            X86CPU *x86_cpu = X86_CPU(cpu);\n\n            CPUX86State *env = &x86_cpu->env;\n\n            uint32_t eax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t ecx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t edx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            if (ecx) {\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n            env->xcr0 = ((uint64_t)edx << 32) | eax;\n\n            wreg(cpu->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_INTR_WINDOW:\n\n            vmx_clear_int_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_NMI_WINDOW:\n\n            vmx_clear_nmi_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_EXT_INTR:\n\n            /* force exit and allow io handling */\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_RDMSR:\n\n        case EXIT_REASON_WRMSR:\n\n        {\n\n            load_regs(cpu);\n\n            if (exit_reason == EXIT_REASON_RDMSR) {\n\n                simulate_rdmsr(cpu);\n\n            } else {\n\n                simulate_wrmsr(cpu);\n\n            }\n\n            RIP(env) += rvmcs(cpu->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_CR_ACCESS: {\n\n            int cr;\n\n            int reg;\n\n\n\n            load_regs(cpu);\n\n            cr = exit_qual & 15;\n\n            reg = (exit_qual >> 8) & 15;\n\n\n\n            switch (cr) {\n\n            case 0x0: {\n\n                macvm_set_cr0(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 4: {\n\n                macvm_set_cr4(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 8: {\n\n                X86CPU *x86_cpu = X86_CPU(cpu);\n\n                if (exit_qual & 0x10) {\n\n                    RRX(env, reg) = cpu_get_apic_tpr(x86_cpu->apic_state);\n\n                } else {\n\n                    int tpr = RRX(env, reg);\n\n                    cpu_set_apic_tpr(x86_cpu->apic_state, tpr);\n\n                    ret = EXCP_INTERRUPT;\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                error_report(\"Unrecognized CR %d\\n\", cr);\n\n                abort();\n\n            }\n\n            RIP(env) += ins_len;\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_APIC_ACCESS: { /* TODO */\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TPR: {\n\n            ret = 1;\n\n            break;\n\n        }\n\n        case EXIT_REASON_TASK_SWITCH: {\n\n            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n            x68_segment_selector sel = {.sel = exit_qual & 0xffff};\n\n            vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,\n\n             vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo\n\n             & VMCS_INTR_T_MASK);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TRIPLE_FAULT: {\n\n            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_RDPMC:\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, 0);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, 0);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        case VMX_REASON_VMCALL:\n\n            /* TODO: inject #GP fault */\n\n            break;\n\n        default:\n\n            error_report(\"%llx: unhandled exit %llx\\n\", rip, exit_reason);\n\n        }\n\n    } while (ret == 0);\n\n\n\n    return ret;\n\n}\n", "idx": 15999, "substitutes": {"cpu": ["pu", "conn", "socket", "ctx", "hw", "window", "cmp", "stat", "cli", "pool", "exe", "program", "processor", "client", "docker", "pty", "trace", "net", "queue", "pkg", "nan", "exec", "ka", "thread", "ctl", "cmd", "hz", "linux", "module", "reset", "cat", "job", "aux", "que", "library", "nc", "cum", "comp", "gc", "cp", "python", "gpu", "prof", "bean", "stan", "tp", "clock", "kernel", "copy", "rpm", "CPU", "pause", "proc", "pixel", "upt", "boot", "ilo", "mac", "common", "np", "sys", "nz", "uu", "ruby", "mu", "c", "cv", "rom", "pc", "config", "home", "process", "jp", "cu", "local", "core", "p", "frame", "aco", "util", "cache", "num", "ct", "cam", "none", "vm", "ck", "runner", "parse", "nic", "component", "name", "mx", "worker"], "x86_cpu": ["x87_core", "x86__pu", "x87_pu", "x86_ctx", "x87_comp", "x31_cp", "x31_ctx", "x86_pu", "x86_cp", "x31_cpu", "x86__cpu", "x87_cpu", "x86__comp", "x86_comp", "x86__core", "x86_core", "x31_pu"], "env": ["server", "def", "nv", "vec", "mem", "ptr", "conn", "prev", "et", "environment", "attr", "pres", "pb", "ctx", "ner", "expr", "window", "hw", "erd", "proc", "ee", "vp", "v", "except", "el", "nd", "esc", "den", "er", "priv", "buf", "cap", "origin", "ef", "ea", "ext", "desc", "cfg", "ew", "ah", "era", "extra", "obj", "doc", "sp", "inv", "cv", "db", "en", "ec", "ep", "wp", "oe", "worker", "dev", "e", "eas", "entry", "eg", "var", "eng", "err", "win", "net", "ev", "vt", "export", "esp", "viron", "gov", "equ"]}}
{"project": "FFmpeg", "commit_id": "332f9ac4e31ce5e6d0c42ac9e0229d7d1b2b4d60", "target": 0, "func": "int intel_h263_decode_picture_header(MpegEncContext *s)\n\n{\n\n    int format;\n\n\n\n    /* picture header */\n\n    if (get_bits_long(&s->gb, 22) != 0x20) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad picture start code\\n\");\n\n        return -1;\n\n    }\n\n    s->picture_number = get_bits(&s->gb, 8); /* picture timestamp */\n\n\n\n    if (get_bits1(&s->gb) != 1) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad marker\\n\");\n\n        return -1;\t/* marker */\n\n    }\n\n    if (get_bits1(&s->gb) != 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad H263 id\\n\");\n\n        return -1;\t/* h263 id */\n\n    }\n\n    skip_bits1(&s->gb);\t/* split screen off */\n\n    skip_bits1(&s->gb);\t/* camera  off */\n\n    skip_bits1(&s->gb);\t/* freeze picture release off */\n\n\n\n    format = get_bits(&s->gb, 3);\n\n    if (format != 7) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Intel H263 free format not supported\\n\");\n\n        return -1;\n\n    }\n\n    s->h263_plus = 0;\n\n\n\n    s->pict_type = I_TYPE + get_bits1(&s->gb);\n\n    \n\n    s->unrestricted_mv = get_bits1(&s->gb); \n\n    s->h263_long_vectors = s->unrestricted_mv;\n\n\n\n    if (get_bits1(&s->gb) != 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"SAC not supported\\n\");\n\n        return -1;\t/* SAC: off */\n\n    }\n\n    if (get_bits1(&s->gb) != 0) {\n\n        s->obmc= 1;\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Advanced Prediction Mode not supported\\n\");\n\n//        return -1;\t/* advanced prediction mode: off */\n\n    }\n\n    if (get_bits1(&s->gb) != 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"PB frame mode no supported\\n\");\n\n        return -1;\t/* PB frame mode */\n\n    }\n\n\n\n    /* skip unknown header garbage */\n\n    skip_bits(&s->gb, 41);\n\n\n\n    s->qscale = get_bits(&s->gb, 5);\n\n    skip_bits1(&s->gb);\t/* Continuous Presence Multipoint mode: off */\n\n\n\n    /* PEI */\n\n    while (get_bits1(&s->gb) != 0) {\n\n        skip_bits(&s->gb, 8);\n\n    }\n\n    s->f_code = 1;\n\n\n\n    s->y_dc_scale_table=\n\n    s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n\n\n\n    return 0;\n\n}\n", "idx": 16020, "substitutes": {"s": ["ses", "gs", "S", "bs", "ties", "ports", "sq", "ags", "acs", "qs", "stats", "vs", "cs", "ims", "pers", "tes", "sg", "its", "ants", "us", "ps", "des", "n", "js", "params", "comm", "spec", "ds", "ats", "services", "ies", "uploads", "set", "rates", "conf", "ains", "parts", "ers", "results", "south", "as", "less", "eps", "als", "sb", "er", "sys", "hs", "times", "erences", "grades", "c", "ops", "es", "changes", "fs", "bis", "se", "sports", "ss", "comments", "aws", "serv", "l", "p", "ords", "details", "is", "sv", "ls", "ts", "ins", "ns", "h", "os", "w", "sts", "ms", "y", "rs"], "format": ["status", "error", "type", "at", "version", "MAT", "f", "size", "data", "mode", "call", "module", "feat", "v", "details", "t", "unit", "padding", "feature", "title", "ats", "act", "tag", "Format", " Format", "c", "count", "fp", "base", "function", "top", "AT", "print", "scale", "debug", "mat", "fc", "set", "mt", "mod", "flat", "it", "style", "fit", "option", "zero", "init", "form"]}}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "int bdrv_pwrite(BlockDriverState *bs, int64_t offset,\n\n                const void *buf1, int count1)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n    if (!drv->bdrv_pwrite)\n\n        return bdrv_pwrite_em(bs, offset, buf1, count1);\n\n    if (bdrv_wr_badreq_bytes(bs, offset, count1))\n\n        return -EDOM;\n\n    return drv->bdrv_pwrite(bs, offset, buf1, count1);\n\n}\n", "idx": 16047, "substitutes": {"bs": ["gs", "ubis", "ubs", "aos", "obs", "outs", "asm", "hz", "js", "bits", "bh", "bes", "sb", "aus", "hs", "cks", "ds", "ls", "iss", "aps", "BS", "bsp", "ads", "qs", "ts", "bos", "bm", "boxes", "bf", "blog", "vs", "gc", "b", "ns", "cs", "bc", "lbs", "uts", "ims", "bl", "bles", "fs", "bps", "ks", "locks", "bis", "its", "bb", "bp", "ss", "sts", "ms", "rs", "ps"], "offset": ["index", "key", "at", "et", "o", "position", "ref", "offs", "address", " offsets", "size", "addr", "Offset", "loc", "padding", "util", "origin", "end", "command", "now", "esi", "off", "oss", "slot", "buffer", "block", "sp", "count", "pos", "location", "bf", "top", "base", "crop", "coord", "start", "oid", "article", "slice", "area", "set", "seek", "mt", "trace", "os", "length", "pad", "offer", "bound", "zero", "pointer"], "buf1": ["fam2", " buffer1", "buf7", " buf01", " buffer2", " buf3", "buffer4", "buff0", " buffer0", "buf4", "fam1", "buf2", " buf2", "buf0", "buffer7", " buf7", "buffer0", " buffer7", " buf4", "buff4", " buf0", "fam3", "buffer1", "buffer2", "buff1", "buff2", "buffer01", "fam01", "buf01", "buf3", "buffer3"], "count1": ["cmd2", "ountr", " countRes", "countr", "counterRes", "ount100", " countr", "count0", " count100", "cmd100", "Countone", "ount1", "Count1", " count0", "countone", "ount2", "Count2", "cmd1", "count2", "ountRes", "countRes", "counter2", "count512", " countone", "ountone", "count100", "cmd512", "ount512", " countN", "counterr", " count512", "ountN", "Count0", "countN", "counter1", "CountN", " count2", "ount0"], "drv": ["drivd", "drvr", "drh", "parvd", "urgho", "rdv", "parv", "parva", "DRv", "Drvr", " drw", "drw", "Drv", " drvd", "drva", "rdb", "Drve", "Drva", "Drw", " drh", "rrvc", "Drvd", "drvc", "Drl", " drl", "drve", "urgl", " drvc", "urgvc", "Drh", "drvd", "DRl", " drho", "rrvd", "driv", "drho", "DRw", "drl", "rrl", "rrho", " drb", "rdvd", "rrb", "rrv", "DRh", "DRvr", "urgv", "drive", "driva", "rdh", "drb", "parve", " drvr", "rrh"]}}
{"project": "qemu", "commit_id": "ac125d993b461d4dee4d6df4d93ac3f2eb959d1d", "target": 1, "func": "static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n\n{\n\n    char *buffer;\n\n    int ret;\n\n    char *path = fs_path->data;\n\n\n\n    buffer = rpath(ctx, path);\n\n    ret = truncate(buffer, size);\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 16057, "substitutes": {"ctx": ["tx", "jp", "rc", "kw", "cf", "unc", "tc", "conn", "wx", "cm", "setup", "cmd", "hw", "kt", "cmp", "bh", "cc", "mk", "req", "conv", "xs", "loc", "np", "ct", "cl", "context", "ac", " cx", "cb", "cv", "xc", "nc", "cp", "wd", "gc", "bc", "fc", "px", "pkg", "sc", "exec", "anc", "jac"], "fs_path": ["fs_spec", "fs_log", "vs_path", "cs_Path", "vs_log", "cs_path", "cs_spec", "fs_Path", "vs_Path", "fs_context", "vs_context"], "size": ["Size", "type", "mem", "out", "SIZE", " resize", "n", "storage", "si", "v", "t", "len", "ize", "space", "offset", "send", "m", "zone", "iz", "fee", "s", "time", "dim", "empty", "sp", " Size", "count", "code", "no", "sync", "scale", "e", "length", "z", "sn", "name", " length", "sum"], "buffer": ["bar", "index", "face", "f", "ptr", "output", "ref", "address", "data", "map", "response", "sequence", "window", "stream", "tr", "Buffer", "text", "chain", "batch", "source", "read", "cache", "buff", "buf", "bin", "result", "command", "program", "memory", "message", "context", "channel", "attribute", "document", "block", "variable", "phrase", "board", "page", "byte", "empty", "null", "table", "device", "bc", "binary", "input", "area", "iter", "uf", "queue", "ob", "pointer", "copy"], "ret": ["xt", "rem", "ptr", "out", " alt", "inter", "pret", "j", "tr", "Ret", "rets", "RET", "val", "t", "result", "nz", "cat", "nt", "lit", "alt", "gt", "att", "match", "rt", "rev", "Return", "rat", "en", "res", "print", "flag", "re", " res", "mt", "rel", "cont", "ft", "it", "elt", "fi", " Ret", "ter", " fut", "txt"], "path": ["key", "index", "def", "ref", "data", "PATH", "p", "str", "stream", "temp", "ath", "dir", "pattern", "chain", "pt", "desc", "context", "rect", "th", "prefix", "ac", "c", "image", "file", "base", "Path", "link", "alias", "root", "id", "transform", "entry", "prop", "package", "pkg", "name", "full", "anc", "template", "pointer"]}}
{"project": "qemu", "commit_id": "8ba2aae32c40f544def6be7ae82be9bcb781e01d", "target": 0, "func": "void uuid_unparse(const uuid_t uu, char *out)\n\n{\n\n    snprintf(out, 37, UUID_FMT,\n\n            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],\n\n            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);\n\n}\n", "idx": 16068, "substitutes": {"uu": ["uy", "gent", "cur", " cu", "hw", "aaa", "cmp", "ffe", "gu", "unch", "gb", "ud", "universal", "yu", "upe", "sup", " tv", "uf", "zero", "emp", "pkg", " up", "qq", "nn", " fuzz", "chu", "ele", "hu", "ui", "iq", "ow", "ubuntu", "phy", " uh", "unt", " tofu", "gue", "gpu", " universal", "stick", "tim", "yy", "ucc", "uh", "hog", " nu", "coin", "du", "ug", "np", " tu", "lu", "empty", " du", "punk", "cup", "amps", "u", " mum", "uv", "unique", "dat", "gru", " u", "nu", "alloc", " gu", "cu", "hum", "au", "tu", "serv", "mmm", " su", " dup", " dat", "util", "uid", "cache", "cul", "eu", "gram", "bu", " bu", " tou", "sky", "crypt", " ut", "su"], "out": ["f", "o", "output", "outs", "j", "n", "p", "v", "conv", "pool", "t", "msg", "result", "bin", "new", "in", "m", "s", "Out", "buffer", "c", "res", "b", "print", "client", "table", "h", "tmp", "set", "OUT", "var", "list", "err", "w", "str", "txt", "ch", "copy"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static int stellaris_enet_can_receive(void *opaque)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n\n        return 1;\n\n\n\n    return (s->np < 31);\n\n}\n", "idx": 16083, "substitutes": {"opaque": ["pvious", "oplaque", " Opanse", "oppanse", " opac", "obvious", "opacity", " Opaque", "obatile", "oppaque", " Opois", "obacity", "opois", "obaque", "opanse", " opanse", "opvious", "oplvious", "oppac", " Opac", "pacity", "opatile", "oplacity", "patile", " opois", "paque", "opac", "oplatile", "oppois"], "s": ["sis", "aws", "gs", "S", "bs", "less", "j", "cmd", "p", "js", "sq", "v", "g", "sl", "sol", "t", "sm", "sv", "sb", "is", "als", "sys", "hs", "spec", "ds", "ls", "r", "ess", "ts", "c", "stats", "ns", "b", "ops", "h", "fs", "conf", "q", "sports", "ss", "sts", "rs", "ps"]}}
{"project": "qemu", "commit_id": "75f27498220e6ff6f78bf08fbe2cc662ec76ba89", "target": 0, "func": "void acpi_memory_unplug_cb(MemHotplugState *mem_st,\n\n                           DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    /* nvdimm device hot unplug is not supported yet. */\n\n    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));\n\n    mdev->is_enabled = false;\n\n    mdev->dimm = NULL;\n\n}\n", "idx": 16089, "substitutes": {"mem_st": ["memzsts", " mem_sts", "mem2sts", "mem_sts", " mem_est", "mem_src", "memzsrc", "mem2est", "memzst", " mem_src", "mem2st", "mem_est"], "dev": ["def", "des", "mem", "DEV", "go", "serv", "alloc", "ver", "ptr", "data", "p", "hw", "window", "devices", "raw", "Dev", "proc", "tr", "v", "test", "gu", "md", "spec", "priv", "buf", "new", "cam", "att", "env", "off", "dem", "db", "debug", "device", "der", "adv", "serial", "ad", "de", "sd", "app", "pad", "d", "ve", "ev", "iv", "w", "exec", "ch"], "errp": ["errpar", "errps", "aerP", "errorpc", " errpar", "errorps", " errps", "errpb", "errorp", " errP", "aerp", "errP", " errpc", "errorpar", "rrp", "aerpar", "rrpb", "rrpc", "errorP", "aerpb", "errpc", "rrps", " errpb", "errorpb"], "mdev": ["mvar", "omvar", "ndev", " mvar", "dmdevice", "gmdev", "hmdevice", " mDev", "omev", "mserial", "Mev", "mdevice", "gmdef", "dDev", "pserial", "mev", "mdef", "gmdevice", "nev", "gmev", "dmvar", "ndevice", "hmev", "mtemp", " mserial", "dmev", " mdevice", "dmdev", "Mtemp", " mtemp", "hmtemp", "gmDev", "ddevice", "pdevice", "mDev", "hmdev", "pdev", "Mdevice", "ndef", "pDev", "omdevice", "ddev", " mdef", "Mserial", "omdev", "MDev", "Mdev", " mev"]}}
{"project": "qemu", "commit_id": "a7824a886ed50eb4fe3c6fcd6afd8814a6973583", "target": 0, "func": "alloc_f(int argc, char **argv)\n\n{\n\n\tint64_t offset;\n\n\tint nb_sectors;\n\n\tchar s1[64];\n\n\tint num;\n\n\tint ret;\n\n\tconst char *retstr;\n\n\n\n\toffset = cvtnum(argv[1]);\n\n\tif (offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tif (argc == 3)\n\n\t\tnb_sectors = cvtnum(argv[2]);\n\n\telse\n\n\t\tnb_sectors = 1;\n\n\n\n\tret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);\n\n\n\n\tcvtstr(offset, s1, sizeof(s1));\n\n\n\n\tretstr = ret ? \"allocated\" : \"not allocated\";\n\n\tif (nb_sectors == 1)\n\n\t\tprintf(\"sector %s at offset %s\\n\", retstr, s1);\n\n\telse\n\n\t\tprintf(\"%d/%d sectors %s at offset %s\\n\",\n\n\t\t\tnum, nb_sectors, retstr, s1);\n\n\treturn 0;\n\n}\n", "idx": 16090, "substitutes": {"argv": [" argl", " argp", "argsl", "Argc", "argc", "parv", "parl", "argvs", "parc", "argsp", " argm", "argl", "argumentV", " argvs", "Argm", "parV", "Argv", "argp", " argc", "Argvs", " argV", "argsv", "Argp", "ArgV", "argsm", "argumentvs", "argumentv", "argV", "argsc", "argumentc", "argsV", "argm"], "offset": ["index", "error", "scroll", "shift", "f", "et", "unc", "o", "bs", "ref", "out", "offs", "position", "number", "size", "address", "addr", "mask", "Offset", "timeout", "reset", "onto", "store", "t", "len", "loc", "padding", "util", "origin", "result", "end", "alt", "s", "obj", "url", "off", "lag", "slot", "range", "attribute", "buffer", "sp", "layout", "base", "pos", "location", "tz", "start", "slice", "set", "transform", "seek", "point", "trace", "mt", "pad", "length", "bound", "pointer"], "nb_sectors": ["nb_vevers", "nb2vectors", "nb_psevers", "nb_sesections", "nb_nesections", "nb_psegments", "nb_secs", "nb_suters", "nb2velements", "nb2veors", "nb_vecs", "nb_sulements", "nb_lelements", "nb_peors", "nb_pectors", "nb_besections", "nb_lectors", "nb_vesections", "nb_sheors", "nb_vegments", "nb_bectors", "nb_shesections", "nb2sesections", "nb_SElements", "nb_suctors", "nb_meors", "nb_pelements", "nb_beors", "nb_spectors", "nb_veters", "nb_esvers", "nb_spevers", "nb_segments", "nb2sectors", "nb_severs", "nb_psecs", "nb2seors", "nb_psectors", "nb_pevers", "nb_seers", "nb_melements", "nb_esctors", "nb_spegments", "nb2vevers", "nb_specs", "nb_SEers", "nb_veers", "nb_leors", "nb2selements", "nb_levers", "nb_vectors", "nb_negments", "nb_esors", "nb_essections", "nb_seectors", "nb_nectors", "nb_velements", "nb_seeors", "nb_selements", "nb2severs", "nb_mectors", "nb_neors", "nb_seters", "nb_seeers", "nb_seelements", "nb_shegments", "nb_suors", "nb_SEctors", "nb_shectors", "nb_bevers", "nb_meters", "nb_SEors", "nb_seors", "nb2vesections", "nb_veors"], "s1": ["s3", "S2", " sone", " s3", "gs1", "ts2", "ps3", "paramsone", "S1", "rs2", "ps2", " s6", "gs3", "s6", "rs1", "params1", "params2", "Sone", "gs0", "rs3", "rs0", "ts1", "S3", "S6", "ts0", "sone", "S0", "ts3", " s2", "ps1", "s2", "params0", "gs2", " s0", "s0", "ps6"], "num": ["node", "index", "um", "number", "o", "ver", "local", "mon", "n", "or", "temp", "nam", "conv", "reg", "msg", "np", "new", "m", "NUM", "dim", "info", "im", "om", "count", "Num", "en", "no", "coord", "un", "id", "set", "var", "nb", "final", "nm", "valid", "nom", "sum"], "ret": ["bit", "status", "rem", "def", "ref", "out", "success", "det", "bool", "back", "j", "n", "tr", "Ret", "rets", "opt", "RET", "val", "reg", "try", "t", "len", "ben", "result", "nt", "br", "lit", "get", "alt", "gt", "rect", "rev", "rt", "backed", "res", "flag", "red", "re", "set", "mt", "repl", "iter", "arg", "it", "elt", "final", " Ret", "sat", "ter", "cont"], "retstr": ["altstring", "retStr", " retstring", "RetStr", "Retstring", "retst", "retstring", " retSTR", "Retst", "restr", "altstr", "outstr", "returnst", "outenc", "returnSTR", "defstring", " ret0", "mem0", "memstring", "returnstring", "memStr", "defStr", "defstr", "Retstr", "ret0", "reenc", "returnStr", "return0", "memstr", " retenc", "returnstr", "outstring", " retStr", "restring", "outname", " retname", "retSTR", "retname", "retenc", "altSTR", "defst", "altStr"]}}
{"project": "qemu", "commit_id": "788cf9f8c8cbda53843e060540f3e91a060eb744", "target": 1, "func": "static void hmp_cont_cb(void *opaque, int err)\n\n{\n\n    if (!err) {\n\n        qmp_cont(NULL);\n\n    }\n\n}\n", "idx": 16093, "substitutes": {"opaque": ["oaque", "opcode", "oa", "oplay", "ioplay", "opera", "iopa", "iopcode", "operlay", "iopaque", "opa", "ocode", "operaque", "opercode", "olay"], "err": ["resp", "status", "rupt", "notice", "error", "cr", "usr", "good", "ok", "aaa", "proc", "eor", "test", "rr", "ply", "try", "er", "msg", "result", "nr", "Error", "r", "kr", "fee", "none", "rev", "cb", "c", "count", "code", "res", "coord", "die", "Er", "any", "urg", "e", "iter", "conf", "state", "gz", "pl", "valid", "arr"]}}
{"project": "qemu", "commit_id": "36fef36b91f7ec0435215860f1458b5342ce2811", "target": 1, "func": "static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n\n    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);\n\n    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);\n\n    struct mfi_ctrl_info info;\n\n    size_t dcmd_size = sizeof(info);\n\n    BusChild *kid;\n\n    int num_pd_disks = 0;\n\n\n\n    memset(&info, 0x0, cmd->iov_size);\n\n    if (cmd->iov_size < dcmd_size) {\n\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n\n                                            dcmd_size);\n\n        return MFI_STAT_INVALID_PARAMETER;\n\n    }\n\n\n\n    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);\n\n    info.pci.device = cpu_to_le16(pci_class->device_id);\n\n    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);\n\n    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);\n\n\n\n    /*\n\n     * For some reason the firmware supports\n\n     * only up to 8 device ports.\n\n     * Despite supporting a far larger number\n\n     * of devices for the physical devices.\n\n     * So just display the first 8 devices\n\n     * in the device port list, independent\n\n     * of how many logical devices are actually\n\n     * present.\n\n     */\n\n    info.host.type = MFI_INFO_HOST_PCIE;\n\n    info.device.type = MFI_INFO_DEV_SAS3G;\n\n    info.device.port_count = 8;\n\n    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n\n        SCSIDevice *sdev = DO_UPCAST(SCSIDevice, qdev, kid->child);\n\n        uint16_t pd_id;\n\n\n\n        if (num_pd_disks < 8) {\n\n            pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);\n\n            info.device.port_addr[num_pd_disks] =\n\n                cpu_to_le64(megasas_get_sata_addr(pd_id));\n\n        }\n\n        num_pd_disks++;\n\n    }\n\n\n\n    memcpy(info.product_name, base_class->product_name, 24);\n\n    snprintf(info.serial_number, 32, \"%s\", s->hba_serial);\n\n    snprintf(info.package_version, 0x60, \"%s-QEMU\", qemu_hw_version());\n\n    memcpy(info.image_component[0].name, \"APP\", 3);\n\n    snprintf(info.image_component[0].version, 10, \"%s-QEMU\",\n\n             base_class->product_version);\n\n    memcpy(info.image_component[0].build_date, \"Apr  1 2014\", 11);\n\n    memcpy(info.image_component[0].build_time, \"12:34:56\", 8);\n\n    info.image_component_count = 1;\n\n    if (pci_dev->has_rom) {\n\n        uint8_t biosver[32];\n\n        uint8_t *ptr;\n\n\n\n        ptr = memory_region_get_ram_ptr(&pci_dev->rom);\n\n        memcpy(biosver, ptr + 0x41, 31);\n\n        memcpy(info.image_component[1].name, \"BIOS\", 4);\n\n        memcpy(info.image_component[1].version, biosver,\n\n               strlen((const char *)biosver));\n\n        info.image_component_count++;\n\n    }\n\n    info.current_fw_time = cpu_to_le32(megasas_fw_time());\n\n    info.max_arms = 32;\n\n    info.max_spans = 8;\n\n    info.max_arrays = MEGASAS_MAX_ARRAYS;\n\n    info.max_lds = MFI_MAX_LD;\n\n    info.max_cmds = cpu_to_le16(s->fw_cmds);\n\n    info.max_sg_elements = cpu_to_le16(s->fw_sge);\n\n    info.max_request_size = cpu_to_le32(MEGASAS_MAX_SECTORS);\n\n    if (!megasas_is_jbod(s))\n\n        info.lds_present = cpu_to_le16(num_pd_disks);\n\n    info.pd_present = cpu_to_le16(num_pd_disks);\n\n    info.pd_disks_present = cpu_to_le16(num_pd_disks);\n\n    info.hw_present = cpu_to_le32(MFI_INFO_HW_NVRAM |\n\n                                   MFI_INFO_HW_MEM |\n\n                                   MFI_INFO_HW_FLASH);\n\n    info.memory_size = cpu_to_le16(512);\n\n    info.nvram_size = cpu_to_le16(32);\n\n    info.flash_size = cpu_to_le16(16);\n\n    info.raid_levels = cpu_to_le32(MFI_INFO_RAID_0);\n\n    info.adapter_ops = cpu_to_le32(MFI_INFO_AOPS_RBLD_RATE |\n\n                                    MFI_INFO_AOPS_SELF_DIAGNOSTIC |\n\n                                    MFI_INFO_AOPS_MIXED_ARRAY);\n\n    info.ld_ops = cpu_to_le32(MFI_INFO_LDOPS_DISK_CACHE_POLICY |\n\n                               MFI_INFO_LDOPS_ACCESS_POLICY |\n\n                               MFI_INFO_LDOPS_IO_POLICY |\n\n                               MFI_INFO_LDOPS_WRITE_POLICY |\n\n                               MFI_INFO_LDOPS_READ_POLICY);\n\n    info.max_strips_per_io = cpu_to_le16(s->fw_sge);\n\n    info.stripe_sz_ops.min = 3;\n\n    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);\n\n    info.properties.pred_fail_poll_interval = cpu_to_le16(300);\n\n    info.properties.intr_throttle_cnt = cpu_to_le16(16);\n\n    info.properties.intr_throttle_timeout = cpu_to_le16(50);\n\n    info.properties.rebuild_rate = 30;\n\n    info.properties.patrol_read_rate = 30;\n\n    info.properties.bgi_rate = 30;\n\n    info.properties.cc_rate = 30;\n\n    info.properties.recon_rate = 30;\n\n    info.properties.cache_flush_interval = 4;\n\n    info.properties.spinup_drv_cnt = 2;\n\n    info.properties.spinup_delay = 6;\n\n    info.properties.ecc_bucket_size = 15;\n\n    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);\n\n    info.properties.expose_encl_devices = 1;\n\n    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);\n\n    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |\n\n                               MFI_INFO_PDOPS_FORCE_OFFLINE);\n\n    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |\n\n                                       MFI_INFO_PDMIX_SATA |\n\n                                       MFI_INFO_PDMIX_LD);\n\n\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);\n\n    return MFI_STAT_OK;\n\n}\n", "idx": 16112, "substitutes": {"s": ["ses", "gs", "a", "S", "o", "n", "p", "js", "v", "xs", "g", "sl", "t", "is", "sb", "sv", "spec", "sm", "hs", "sys", "ds", "ls", "k", "m", "r", "ies", "ts", "self", "c", "stats", "ns", "b", "cs", "h", "es", "e", "fs", "os", "state", "d", "its", "ss", "sts", "i", "y", "rs", "ps"], "cmd": ["def", "ctl", "exec", "cf", "conn", "cm", "handle", "setup", "ind", "ctx", "mode", "crit", "cmp", "call", "raw", "cc", "req", "mk", "conv", "cli", "batch", "ctr", "md", "gen", "comm", "help", "msg", "com", "sys", "command", "job", "ct", "m", "cfg", "cl", "nt", "obj", "control", "phy", "dq", "c", "cb", "Cmd", "cp", "ctrl", "args", "conf", "config", "pkg", "news", "controller", "cont", "ch"], "pci_dev": ["pdi_def", "pci_obj", "pciabledev", "pci_device", "pdi_device", "pci_def", "ppi_cmd", "ppi_dev", "pciableev", "pci_cmd", "ppi_ev", "pdi_dev", "pci_ev", "pdi_obj", "pciablecmd"], "pci_class": ["pcu_class", "pci_client", "pcu2client", "pcietydef", "pcu_case", "pclietydef", "pci2client", "pcu_type", "pciproclass", "pcli_def", "pclietyclass", "pci___cc", "pli_class", "pci___classes", "pli_close", "pci5case", "pclietylass", "pciabledesc", "pcgi_desc", "pcli_lass", "pci_desc", "pli___class", "pcietyclass", "pcietylass", "pciprolass", "pcgi___class", "pci_case", "pci___class", "pci_cc", "pciprodef", "pci5class", "pcu2type", "pli___cell", "pciolyclass", "pci_classes", "pci2class", "pciolycert", "pli_cell", "pcu_classes", "pci2type", "pciolycase", "pcgi_cc", "pcu_cert", "pci_lass", "pcgi___cell", "pci___close", "pciableclass", "pcgi___cc", "pciablecc", "pci_close", "pcu_client", "pcgi_cell", "pcgi_class", "pci___type", "pci_cert", "pcgi___desc", "pci___desc", "pcu2classes", "pli___close", "pci_def", "pci___client", "pciablecell", "pcu2class", "pcli_class", "pci_type", "pci2classes", "pci_cell", "pci5cert", "pci___cell"], "base_class": ["serviceaclink", "baseaclink", "basecllink", "baseacproc", "base_link", "baseacclass", "baseclclass", "base_num", "baseproproc", "baseclproc", "service_num", "service_proc", "serviceacproc", "service_link", "service_class", "serviceacnum", "base_proc", "baseacnum", "baseclnum", "basepronum", "baseproclass", "baseprolink", "serviceacclass"], "info": ["index", "conn", "query", " hello", "stat", "check", " input", "t", "close", "loc", "help", "policy", " status", "summary", "Inf", "start", "cho", "trace", "it", "INFO", " report", "error", "type", "metadata", "mem", " information", "about", "by", "ret", "data", " follow", "information", "try", "http", "test", "note", " data", " check", "comment", "self", "fo", " accept", "report", "conf", "ion", "fi", "history", "public", "f", "out", " doc", "row", "auth", "user", " output", "show", "now", "op", "update", " inf", "json", "debug", " frame", "unknown", "id", "iter", "state", "to", "config", "init", "safe", "inf", "status", "o", "success", "good", "admin", " error", "p", "response", "ok", "details", " alert", "kind", "cache", " about", "num", "time", " inform", "iso", "image", "event", "create", "no", "h", "rec", "e", "order", "entry", "os", "list", " perf", "value", "Info", "xml", "name", "news"], "kid": ["jp", "kw", "kn", "kh", "kg", "ctx", "ki", "kt", "hw", "cc", "kk", "mk", "kie", "kit", "kind", " ki", "ke", "K", "ek", "k", "kr", "ko", "sid", "kb", "Kid", "kids", "ck", "ak", "wk", "kick", "dk", "kl", "unk", "id", "ks", "ker", "pid", "nb", "kj", "ked", "sky", "ca", "ka", "sk"], "sdev": ["tsdet", " sdet", "sdet", "ssdevice", "sdevice", "sDEV", "dsdevice", "tsdev", "psde", "jsdev", "ssde", "psdev", "tsdef", "jsdevice", "jsdef", "dsdev", "tsdevice", "ssdev", "psDEV", "dsdef", "ssDEV", " sdevice", "ssdes", "sde", "dsdet", "sdes", "psdevice", "sdef", "Sdef", "Sdev", "Sdevice", "Sdes", " sdef", "jsdes", "ssdef"], "pd_id": ["pdjkey", "dl67i", "pd_kid", " PD_id", "pd___kid", "pd_ad", "pd67kid", " PD_link", "pd_i", "pdewkey", "dl67kid", "pd___i", "PD_id", "pdponum", "dl67ad", "pd67id", "dl67id", " PD_key", "pd_link", " PDewid", "pd_ids", "pdewid", "pd_Id", " PDewnum", " PD_num", "pdpolink", "PD_ids", "PD_Id", "PD_class", " PDewlink", "pdpoid", "pd_num", "dl_id", "pd67ad", "pd_key", "pd_class", "dl_i", "dl_kid", "pdjlink", "pdewlink", "pdewnum", "pdjnum", " PDewkey", "dl_ad", "pd___id", "pdpokey", "pd67i", "pdjid", "pd___ad"], "num_pd_disks": ["num_pd_DISps", "num_pd_discs", "num_pd_Disk", "num_pd_Disms", "num_pd_disms", "num_pd_disds", "num_pd_disps", "num_pd_devk", "num_pd_deas", "num_pd_hardcs", "num_pd_diskcs", "num_pd_DISk", "num_pd_sdks", "num_pd_Disks", "num_pd_disas", "num_pd_Disps", "num_pd_hardks", "num_pd_devms", "num_pd_devks", "num_pd_Disds", "num_pd_Discs", "num_pd_diskks", "num_pd_sdms", "num_pd_deks", "num_pd_diskms", "num_pd_Disas", "num_pd_sdds", "num_pd_deps", "num_pd_DISas", "num_pd_hardms", "num_pd_diskk", "num_pd_sdk", "num_pd_DISks", "num_pd_devds", "num_pd_hardk", "num_pd_dek", "num_pd_disk"]}}
{"project": "FFmpeg", "commit_id": "f4aaf987a588fcf5978e636edf2193df35b3e83b", "target": 1, "func": "int ff_thread_video_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *frame, int *got_packet_ptr){\n\n    ThreadContext *c = avctx->internal->frame_thread_encoder;\n\n    Task task;\n\n    int ret;\n\n\n\n    av_assert1(!*got_packet_ptr);\n\n\n\n    if(frame){\n\n        if(!(avctx->flags & CODEC_FLAG_INPUT_PRESERVED)){\n\n            AVFrame *new = avcodec_alloc_frame();\n\n            if(!new)\n\n                return AVERROR(ENOMEM);\n\n            pthread_mutex_lock(&c->buffer_mutex);\n\n            ret = c->parent_avctx->get_buffer(c->parent_avctx, new);\n\n            pthread_mutex_unlock(&c->buffer_mutex);\n\n            if(ret<0)\n\n                return ret;\n\n            new->pts = frame->pts;\n\n            new->quality = frame->quality;\n\n            new->pict_type = frame->pict_type;\n\n            av_image_copy(new->data, new->linesize, (const uint8_t **)frame->data, frame->linesize,\n\n                          avctx->pix_fmt, avctx->width, avctx->height);\n\n            frame = new;\n\n        }\n\n\n\n        task.index = c->task_index;\n\n        task.indata = (void*)frame;\n\n        pthread_mutex_lock(&c->task_fifo_mutex);\n\n        av_fifo_generic_write(c->task_fifo, &task, sizeof(task), NULL);\n\n        pthread_cond_signal(&c->task_fifo_cond);\n\n        pthread_mutex_unlock(&c->task_fifo_mutex);\n\n\n\n        c->task_index = (c->task_index+1) % BUFFER_SIZE;\n\n\n\n        if(!c->finished_tasks[c->finished_task_index].outdata && (c->task_index - c->finished_task_index) % BUFFER_SIZE <= avctx->thread_count)\n\n            return 0;\n\n    }\n\n\n\n    if(c->task_index == c->finished_task_index)\n\n        return 0;\n\n\n\n    pthread_mutex_lock(&c->finished_task_mutex);\n\n    while (!c->finished_tasks[c->finished_task_index].outdata) {\n\n        pthread_cond_wait(&c->finished_task_cond, &c->finished_task_mutex);\n\n    }\n\n    task = c->finished_tasks[c->finished_task_index];\n\n    *pkt = *(AVPacket*)(task.outdata);\n\n    av_freep(&c->finished_tasks[c->finished_task_index].outdata);\n\n    c->finished_task_index = (c->finished_task_index+1) % BUFFER_SIZE;\n\n    pthread_mutex_unlock(&c->finished_task_mutex);\n\n\n\n    *got_packet_ptr = 1;\n\n\n\n    return task.return_code;\n\n}\n", "idx": 16135, "substitutes": {"avctx": ["avectl", "avercmd", "avcmp", "navca", "avctl", "wavcontext", "wavctl", "navcmp", "navctx", "navcontext", " avconn", "awconn", "avcontext", "awctx", "Avcontext", "avercontext", "awcontext", " avtc", "avertc", "aveconf", "avcb", "avecmd", "averconf", " avcmd", "avecontext", " avconf", "avecb", "averctx", "avectx", " avca", "averctl", "avcmd", "avconf", " avcmp", "Avctx", " avcfg", "avconn", "awcfg", "avetc", "wavconn", "avca", "avercmp", " avcontext", "Avcfg", "avtc", " avctl", "avecmp", "avcfg", "Avconn", "aveca", "aveconn", " avcb", "avercb", "wavctx"], "pkt": ["ppacket", "packet", "packqt", " pqt", "packkt", "ppkg", "packkg", "pkg", "ppkt", " pkg", "ppqt", "pqt", "packacket", " packet"], "frame": ["sequence", "window", "raw", "t", "close", "result", "channel", "context", "word", "function", "fram", "iframe", "draw", "fps", "filter", "normal", "def", "error", "type", "object", "data", "reset", "next", "picture", "frames", "part", "rame", "fb", "one", "df", "fi", "style", "form", "cf", "face", "f", "framework", "ref", "call", "movie", "feat", "text", "source", "show", "in", "zone", "update", "original", "info", "buffer", "block", "remote", "file", "fr", "scene", "from", "state", "shot", "process", "force", "profile", "instance", "request", "position", "video", "feature", "message", "none", "time", "image", "event", "base", "code", "fc", "Frame", "point", "component", "value", "ce"], "got_packet_ptr": ["got_packet2Ptr", "got_packET_pointer", "got_packet2obj", "got_packacket2ptr", "got_packet2addr", "got_packacket2obj", "got_packet_Ptr", "got_packET_ptr", "got_packet2ref", "got_packacket_obj", "got_packacket2pointer", "got_packet__Ptr", "got_packacket_ptr", "got_packet__pointer", "got_packET_Ptr", "got_packet_ref", "got_packet_addr", "got_packet_obj", "got_packet2pointer", "got_packET_addr", "got_packacket_pointer", "got_packet__addr", "got_packet_pointer", "got_packacket2ref", "got_packet2ptr", "got_packacket_ref", "got_packet__ptr"], "c": ["rc", "cu", "cf", "co", "tc", "f", "unc", "cr", "cm", "cur", "cn", "lc", "l", "ctx", "p", "this", "cmp", "call", "cc", "conv", "v", "cd", "chain", "g", "t", "comm", "ic", "cache", "dc", "com", "ct", "cam", "m", "cl", "uc", "sc", "ac", "C", "cb", "cv", "xc", "abc", "nc", "ci", "ec", "comp", "cp", "gc", "mc", "cs", "bc", "b", "etc", "pc", "fc", "con", "conf", "cont", "config", "vc", "ca", "coll", "ce", "anc", "can"], "task": ["thread", "node", "bit", "craft", "bar", "error", "tc", "out", "session", "window", "feat", "missing", "test", "process", "wrong", "t", "msg", "result", "command", "func", "job", "nt", "tag", "question", "part", "message", "ask", "word", "parent", "work", "empty", "unt", "tf", "remote", "event", "block", "null", "function", "link", "byte", "image", "thing", "course", "table", "ack", "unknown", "best", "article", "action", "tmp", "master", "tar", "trace", "piece", "component", "net", "token", "slave", "target", "commit", "tty", "package", "Task", "form", "worker"], "ret": ["resp", "status", "rem", "def", "nl", "ref", "out", "git", "pret", " RET", "ll", "fun", "back", "cmd", "Ret", "tr", "rets", "RET", "val", "reset", "deg", "try", "not", "t", "len", "rm", "result", "ext", "nz", "nt", "alt", "gt", "att", "ern", "url", "rt", "rev", "Return", "res", "flag", "re", "mt", "arg", "ft", "elt", "net", " Ret", "value", "ter", "usr", "cont", "txt", "arr"], "new": ["and", "other", "raw", "t", "result", "fresh", "first", "add", "shared", "make", "un", "start", "draw", "it", "normal", "def", "nl", "j", "n", "old", "or", "created", "v", "missing", "next", "g", "big", "box", "added", "blank", "true", "self", "one", "null", "root", "tmp", "set", "save", "full", "again", "form", "public", "record", "f", "global", "row", "this", "call", "foreign", "common", "empty", "remote", "we", "private", "from", "to", "unique", "init", "small", "package", "valid", "alloc", "bar", "good", "aw", "p", "el", "diff", "ew", "New", "vm", "all", "create", "re", "non", "var", "ne", "NEW", "final", "export", "news", "name", "nm"]}}
{"project": "qemu", "commit_id": "fa3aad24d94a6cf894db52d83f72a399324a17bb", "target": 0, "func": "int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                       void *opaque, int version_id)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n\n\n    if (version_id > vmsd->version_id) {\n\n        return -EINVAL;\n\n    }\n\n    if (version_id < vmsd->minimum_version_id_old) {\n\n        return -EINVAL;\n\n    }\n\n    if  (version_id < vmsd->minimum_version_id) {\n\n        return vmsd->load_state_old(f, opaque, version_id);\n\n    }\n\n    while(field->name) {\n\n        if (field->version_id <= version_id) {\n\n            void *base_addr = opaque + field->offset;\n\n            int ret, i, n_elems = 1;\n\n\n\n            if (field->flags & VMS_ARRAY) {\n\n                n_elems = field->num;\n\n            } else if (field->flags & VMS_VARRAY) {\n\n                n_elems = *(size_t *)(opaque+field->num_offset);\n\n            }\n\n            if (field->flags & VMS_POINTER) {\n\n                base_addr = *(void **)base_addr;\n\n            }\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *addr = base_addr + field->size * i;\n\n\n\n                if (field->flags & VMS_STRUCT) {\n\n                    ret = vmstate_load_state(f, field->vmsd, addr, version_id);\n\n                } else {\n\n                    ret = field->info->get(f, addr, field->size);\n\n\n\n                }\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n            }\n\n        }\n\n        field++;\n\n    }\n\n    if (vmsd->run_after_load)\n\n        return vmsd->run_after_load(opaque);\n\n    return 0;\n\n}\n", "idx": 16147, "substitutes": {"f": ["fw", "cf", "fed", "o", "lf", "ff", "l", "p", "fd", "rf", "F", "v", "ile", "g", "t", "util", "fm", "ef", "sf", "fx", "m", "r", "fb", "c", "tf", "fo", "file", "fp", "buffer", "bf", "df", "b", "h", "fac", "fc", "fr", "e", "fs", "d", "fi", "xf", "uf", "q", "form"], "vmsd": ["vmsdt", "vnsp", "virtualmtd", "vfsd", "vcsp", " vmssd", "vmsdo", "vensionsd", "vmesdn", "mmssd", "vtsdb", "cmssd", "vjssd", "revensionsad", "vmemsd", "vemsd", "mmsdt", "vmemssd", "vensionsdm", "wmsd", "wmsdt", "vailsdid", "vmemsad", "revmsdo", "vcsl", " vinsds", "vjsde", "vnssd", "vmtdo", "vmesd", "vmsdid", "vimsds", "vcsad", "wmsbd", "cmsp", "ccssd", "vmesds", "virtualmsdo", "vemsad", "vsssd", "vinssd", "vmsdm", "vmsdn", "vpsdt", "vmssd", "vmsl", "vmsad", "vcsd", "vomsdt", "virtualmtdo", "vpsl", "wmsld", "vmesld", "vfsdt", "vmsdh", "vailssd", "virtualmtdid", " vomssd", "vomsdm", "vnsd", "mmesd", "vemsl", "vssd", "ccsp", "vnsad", "vlsdt", "vmtdid", "wmesbd", "vtssd", " vomsdh", "vmsld", "vlsl", "virtualmtdm", "wmesdt", "revmsad", "vmesbd", "vmessd", " vmsdb", "vainsdid", " vomsde", "vailsd", "vcssd", "revensionsd", "vmtd", "vinsds", "wmesd", "mmesdt", "vomsld", "vmmsad", "vainsdo", "vomsde", " vinssd", "vlsd", "vimsd", "virtualmsdid", "vensionsad", "ccsd", "vailsde", "vinsdb", "vpsd", "revmsdm", "vmmsl", "vcsdo", "vnsl", "vmtdm", "vmmsd", "vmsbd", "vmesdt", " vinsdb", "vssds", "vailsdh", "vomsdo", "cmsl", "vomsdh", "vmsds", "mmesl", "vainsdm", " vmsdh", "mmesdn", "vcsdm", "vomssd", "vmesl", "vtsl", "cmsd", "vjsd", "wmesld", "vmemsl", "mmessd", "vmsdb", "vfsbd", "vailsdm", "virtualmsd", "vainsd", "vfsld", "vomsbd", " vmsds", "vinsd", "revmsd", " vinsd", "vtsp", "vimsl", "vtsd", "mmesds", "vemssd", "vimssd", "ccsl", "vomsd", "vmsp", "vlsdn", "mmsdn", " vmsde", "revensionsdo", "vmesad", "vjsdh", "revensionsdm", "mmsl", "vensionsdo", "mmsd", "mmsds", "virtualmsdm", " vomsd", "vssdb", "vtsds", "vpsdn", "vmsde", "vailsdo", "vmmssd", "vomsad"], "opaque": [" opatile", "ogaque", "popatile", "ompenter", "obaques", " opaques", "oboxy", "ipaques", "ompaque", "obque", "ipenter", "opacity", "popaque", " opacity", "obatile", "ipatile", "Opaque", "alque", " opoxy", "opaques", "obacity", "opesc", "ogesc", "obaco", "popesc", "ompaques", "obaque", "openter", "popque", "penter", "Opesc", "pacity", "ipaque", "Opque", "ogque", "ipacity", "opatile", "alaco", "opaco", "ompacity", "alaque", "ipoxy", "paque", "opoxy", "paques", "ogatile", "ipque", "opque", "alacity", "ipaco", "Opatile"], "version_id": ["build_version", "vision_time", "versioningide", "version_ID", "video_id", "video8uid", "video8ids", "Version_d", "usage_d", "versionedoid", "usage_id", "versionalityId", "version2num", "versionityoid", "versionalityd", "version_ide", "visionityoid", "version_end", "version8oid", "build_oid", "version_data", "versionalityid", "build_id", "versionIdend", "version_mid", " version_end", "version_time", "usage_md", "versioneddata", "video_ids", "vision_ids", "VERSION_id", "visionityid", "version8uid", "versioninguid", "vision_name", "version_version", "version_info", "versionityid", "versioningids", "version_name", "version2md", "vision_i", "visionityi", "build_data", "version8version", "versionityi", "VERSION_Id", "Version_Id", "version_Id", "versionIdids", "VERSION_info", "usage_num", "visionityname", "version2d", "vision_oid", "video8ide", "Version_r", "version_num", "Version_id", "versionedversion", "vision_ID", "version_d", "vision_id", "video8id", "version_pid", "vision_d", "vision_pid", "versionIdid", "version_oid", "VERSION_ID", "versionityname", "version8ide", "versionedid", "version8id", "version8data", "video_uid", " version_ids", "video_ide", "versionalityr", "vision_mid", "version2id", "version_uid", "version_ids", "version_md", "version8ids", "versioningid", "version_r", "version_i"], "field": ["index", "machine", "manager", "mount", "member", "window", "dr", "man", "task", "layer", "load", "end", "lock", "line", "word", "match", "attribute", "add", "function", "label", "def", "view", "error", "type", "param", "lf", "address", "lc", "module", "resource", "FIELD", "fields", "test", "job", "cell", "part", "comment", "link", "flag", "table", "volume", "term", "pair", "arg", "complete", "form", "node", "server", "key", "record", "version", "row", "user", "store", "fe", "service", "offset", "player", "sim", "info", "variable", "file", "plugin", "state", "d", "option", "ld", "child", "local", "section", "good", "relation", "rule", "domain", "util", "feature", "Field", "item", "tag", "desc", "dump", "message", "prefix", "handler", "event", "master", "entry", "var", "list", "pad", "component", "format", "name", "pointer"], "base_addr": ["base66align", "balance____align", "balance____alt", "Base_dr", "base64dr", "base____alt", "base__ref", "Base_address", "base67alt", "base____id", "Base_ptr", "balance____addr", "base_align", "base67id", "base_id", "Base_ref", "base64addr", "balance_alt", "base64src", "base__ptr", "base__src", "base66alt", "base_alt", "base_ptr", "base____align", "base66addr", "balance____id", "base_address", "base_offset", "Base_addr", "base_src", "base64offset", "base_dr", "balance_addr", "Base_src", "base_ref", "balance_align", "balance_id", "base64ptr", "Base_offset", "base__addr", "base64address", "base66id", "base67addr", "base67align", "base__offset", "base____addr"], "ret": ["resp", "rem", "def", "rex", "mem", "ptr", "out", "ref", "success", " RET", "ll", "fun", "back", "cmd", "str", "Ret", "tr", "rets", "RET", "val", "reset", "try", "t", "len", "rm", "result", "ext", "nz", "cat", "nt", "rest", "lit", "r", "alt", "gt", "att", "aux", "rt", "rev", "ts", "Return", "tf", "ry", "res", "print", "flag", "re", "jump", "tmp", "mt", "repl", "iter", "ft", "hash", "elt", "err", " Ret", "ter", "usr"], "i": ["index", "li", "iu", "o", "ii", "mi", "ini", "pi", "I", "ei", "j", "l", "n", "ki", "p", "x", "si", "zi", "v", "ori", "cli", "bi", "batch", "ui", "di", "ai", "m", "in", "hi", "ie", "xi", "qi", "sim", "info", "im", "\u0438", "c", "ci", "id", "ims", "e", "ti", "it", "multi", "gi", "fi", "me", "MI", "phi", "y", "ic", "ix", "ip"], "addr": ["index", "a", "at", "ptr", "inter", "address", "attr", "grad", "dr", "ord", "mk", "arm", "adr", "loc", "offset", "align", "act", "gate", "url", "off", "add", "ac", "work", "pos", "coord", "wd", "ack", "grid", "id", "ad", "order", "ace", "iter", "rel", "pad", "amp", "ip", "rr", "ix", "alloc", "arr", "arp"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,\n\n                             TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh)\n\n{\n\n    TCGReg tmp0 = TCG_TMP0;\n\n    TCGReg tmp1 = ret;\n\n\n\n    assert(ret != TCG_TMP0);\n\n    if (ret == ah || ret == bh) {\n\n        assert(ret != TCG_TMP1);\n\n        tmp1 = TCG_TMP1;\n\n    }\n\n\n\n    switch (cond) {\n\n    case TCG_COND_EQ:\n\n    case TCG_COND_NE:\n\n        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, ah, bl, bh);\n\n        tcg_out_setcond(s, cond, ret, tmp1, TCG_REG_ZERO);\n\n        break;\n\n\n\n    default:\n\n        tcg_out_setcond(s, TCG_COND_EQ, tmp0, ah, bh);\n\n        tcg_out_setcond(s, tcg_unsigned_cond(cond), tmp1, al, bl);\n\n        tcg_out_opc_reg(s, OPC_AND, tmp1, tmp1, tmp0);\n\n        tcg_out_setcond(s, tcg_high_cond(cond), tmp0, ah, bh);\n\n        tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);\n\n        break;\n\n    }\n\n}\n", "idx": 16155, "substitutes": {"s": ["ses", "south", "gs", "S", "sw", "less", "session", "ties", "l", "ctx", "p", "js", "n", "v", "g", "t", "us", "comm", "is", "sb", "sv", "hs", "sys", "ds", "ls", "y", "r", "context", "ies", "qs", "ts", "self", "c", "stats", "ins", "ns", "b", "cs", "h", "an", "es", "ims", "fs", "sg", "os", "ains", "its", "q", "ss", "w", "sts", "i", "scl", "rs", "ix", "ps"], "cond": ["resp", "bit", "key", "def", " Cond", "cf", "co", "dict", "conn", " condition", "ind", " cmd", "cmd", "fun", "ctx", " pred", "crit", "cmp", "call", "cod", "cd", "compl", "check", "func", "connect", "ct", "act", "lock", "dd", "condition", " cont", "Cond", "c", " conditional", "pos", "code", "pred", "comp", "bind", "like", "red", "bc", "mat", "con", "conf", " con", "stick", "init", "ond", "cont", "adj", "ld", "form"], "ret": ["resp", "jp", "rc", "def", "rem", "xt", "rex", "mem", "conn", "f", "out", "ref", "det", "cmd", "back", "p", "Ret", "or", "tr", "rets", "req", "RET", "val", "reset", "ald", "g", "reg", "try", "not", "t", "store", "ert", "len", "test", "result", "buf", "sys", "nt", "lit", "r", "true", "alt", "gt", "obj", "att", "desc", "get", "rt", "rev", "Return", "ry", "res", "gc", "red", "cert", "re", "tmp", "mt", "repl", "arg", "ft", "it", "net", "x", "ter", "ob"], "al": [" tal", "am", "il", "alph", "ell", "alid", "ax", "l", "ag", "ral", "alan", "hal", "ali", "ale", "ald", "ar", "el", "ay", "alf", "als", "la", "Al", "ab", "alt", "sal", "alg", "phal", "pal", "alog", "cal", "isal", "en", "ap", "ul", "ial", "h", "ad", "AL", " hal", "bal", "ele", " ali", "aler", "af"], "ah": ["am", "at", "au", "uh", "az", "ph", "kh", "hr", "ahi", "ahs", "aka", "hal", "Ah", " ha", "amb", "ha", "AH", "erb", "ar", "ay", "ih", "athe", "buf", "hs", "igh", "ab", "ur", "enh", "eth", "hi", "hab", "ac", "alog", "aph", "het", "rh", "oh", "abc", "sh", "ap", "aff", "h", "orth", "ach", "hl", "Oh", "ash", " hal", "eh", "yah", "asha", "av", "gh", "ob", "af"], "bl": ["nl", "ba", "tl", "bs", "kh", "lr", "Bl", "ll", "l", "pb", "ill", "hal", "amb", "bj", "sl", "hist", "ay", "loc", "sb", "bt", "Al", "lb", "ab", "fl", "br", "ml", "bn", "hab", "bd", "bm", "db", "lp", "oh", "bf", "sh", "ber", "bc", "h", "jl", "hl", "abl", "bal", "pl", "bg", "BL", "bel"], "bh": ["osh", "uh", "bs", "kh", "hr", "hz", "hub", "vr", "hal", "bj", "ith", "ih", "bt", "sb", "bo", "lb", "igh", "br", "eth", "bn", "hab", "bd", "bm", "cb", "bel", "rh", "oh", "bf", "sh", "ht", "bc", "h", "biz", "hl", "dh", "bb", "nb", "phi", "bp", "bg", "hh", "gh", "ob", "hp", "bang"]}}
{"project": "qemu", "commit_id": "28f4a7083dcca084243e313ab18fcdb20d60334e", "target": 0, "func": "static void display_mouse_define(DisplayChangeListener *dcl,\n\n                                 QEMUCursor *c)\n\n{\n\n    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);\n\n\n\n    qemu_mutex_lock(&ssd->lock);\n\n    if (c) {\n\n        cursor_get(c);\n\n    }\n\n    cursor_put(ssd->cursor);\n\n    ssd->cursor = c;\n\n    ssd->hot_x = c->hot_x;\n\n    ssd->hot_y = c->hot_y;\n\n    g_free(ssd->ptr_move);\n\n    ssd->ptr_move = NULL;\n\n    g_free(ssd->ptr_define);\n\n    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);\n\n    qemu_mutex_unlock(&ssd->lock);\n\n}\n", "idx": 16163, "substitutes": {"dcl": ["dCL", "sdcr", "Dcr", " dbl", " dkl", " dcr", " dCL", "lCL", "sdfl", "Dbl", " dscl", "sdcl", "sdpl", "ccl", "dfl", "dld", "dnCL", "dnscl", " dld", "dncl", "dpl", "sdscl", "sdCL", " dfl", "dkl", "lkl", "dbl", "Dpl", "ckl", "dcr", "dnfl", "dscl", "sdbl", " dpl", "cCL", "lld", "lcl", "cld", "Dcl"], "c": ["rc", "cu", "ce", "cr", "tc", "co", "unc", "f", "oc", "cm", "ca", "cur", "lc", "l", "ctx", "n", "p", "or", "cmp", "cc", "v", "g", "t", "ic", "spec", "cache", "dc", "ct", "cam", "m", "r", "ac", "C", "cb", "xc", "nc", "abc", "ec", "cp", "b", "mc", "cs", "bc", "h", "gc", "pc", "fc", "etc", "e", "con", "u", "enc", "conf", "col", "d", "vc", "i", "arc", "x", "sc", "cont", "can", "ch"], "ssd": [" sswd", "cssr", "ssmd", " ssld", "ssdi", "hessr", "csssd", "skydh", "tssd", "cssd", "hessdh", "SSd", "ssds", "hessds", "ssl", "cssdi", "cssad", "essl", "rssbd", "sssd", "rsspd", "rssd", " ssmd", "assds", "cssl", " ssdc", "esspd", "cssld", "essd", "rssdi", "cssds", "asspd", "SSad", "tsbd", "sspd", "hessmd", " sssd", "wsld", "tsd", "rssld", "ssr", "essdc", " ssds", " ssad", "SSbd", "asssd", "wswd", "hessld", "cssbd", "hessd", "essbd", "hessisd", "essds", "rssdb", "essdb", "ssdc", "wsd", "rssds", "cssmd", "esswd", "rssr", "ssld", "SSsd", "assd", "skysd", "essld", "wsdc", "rssdh", "rsssd", "esssd", "tsds", "ssdb", "hesssd", "skyisd", "isssd", "ssisd", "rssl", " ssdi", "issr", "hessad", "SSdi", "rssisd", "cssdb", "sswd", "ssad", "issd", "issds", "skyd", "rssad", " ssbd", "ssbd", "ssdh"]}}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "static inline void stw_phys_internal(hwaddr addr, uint32_t val,\n\n                                     enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!memory_region_is_ram(section->mr) || section->readonly) {\n\n        addr = memory_region_section_addr(section, addr);\n\n        if (memory_region_is_ram(section->mr)) {\n\n            section = &phys_sections[phys_section_rom];\n\n        }\n\n#if defined(TARGET_WORDS_BIGENDIAN)\n\n        if (endian == DEVICE_LITTLE_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#else\n\n        if (endian == DEVICE_BIG_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#endif\n\n        io_mem_write(section->mr, addr, val, 2);\n\n    } else {\n\n        unsigned long addr1;\n\n        addr1 = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK)\n\n            + memory_region_section_addr(section, addr);\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr(addr1);\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            stw_le_p(ptr, val);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            stw_be_p(ptr, val);\n\n            break;\n\n        default:\n\n            stw_p(ptr, val);\n\n            break;\n\n        }\n\n        invalidate_and_set_dirty(addr1, 2);\n\n    }\n\n}\n", "idx": 16164, "substitutes": {"addr": ["tx", "rc", "a", "at", "mem", "ret", "arp", "ref", "src", "lr", "inter", "handle", "asm", "address", "attr", "map", "ag", "hw", "p", "tr", "dr", "ord", "ctx", "usr", "ind", "adr", "len", "loc", "offset", "align", "act", "r", "alt", "url", "obj", "hop", "off", "add", "rt", "work", "ac", "pos", "coord", "res", "alias", "id", "ad", "host", "point", "mt", "rel", "pad", "hash", "to", " address", "ash", "err", "var", "elt", "gz", "i", "x", "rn", "arr", "rs", "ix", "alloc", "Address", "ip"], "val": ["vol", " arg", " value", "vec", "attr", "stat", "pool", "len", "loc", " valid", "aval", " eval", " bl", " v", "rol", "cho", "VAL", "arr", "tx", "mem", "ret", "data", "pr", "crit", "pol", "fail", "v", "test", "sol", " data", " slot", "res", "ival", "elt", "x", "resp", "key", "ref", "cond", "als", "eval", "buf", "al", "slot", "vals", "buffer", " al", "err", "bal", "vt", "valid", "Val", "serv", "values", " num", "p", "grad", "el", "pt", "util", "msg", "func", "tag", "alt", " tx", " ty", "sel", "cal", " buf", "rel", "var", "col", "prop", "value", "pl"], "endian": ["endedian", "endsIAN", " endIAN", "endedendor", "enderoen", "endsian", "enderians", "endoen", "Endian", "endians", "ndserv", "endIAN", "enderian", "endingoen", "endsrian", "endingrian", "endsendor", " endserv", "endsoen", "endedIAN", "Endians", "endrian", "ENDian", "endendor", "endingians", "ndians", "endserv", "enderrian", "ENDIAN", "ENDendor", " endendor", "endedserv", " endians", "endingian", "ENDserv", "Endendor", "Endserv", "endsians", "ENDians", "ndian", "ndendor", "endedians"], "ptr": ["index", "mem", "alloc", "ref", "pointers", "inter", "handle", "attr", "pr", "address", "ind", "p", "tr", "dr", "ctx", "grad", "req", "proc", "fd", "vr", "Ptr", "deg", "pt", "adr", "ctr", "loc", "buf", "np", "offset", "func", "r", "rect", "obj", "add", "rt", "ts", "sp", "pos", "prime", "inters", "po", "fr", "pair", "seek", "rel", "point", "dep", "pad", "iter", "dh", "err", "tp", "pointer", "arr", "ps"], "section": ["index", "member", "sect", "header", "man", "port", "result", "command", "sector", "line", "function", "ser", "year", "character", "net", "side", "param", "search", "address", "group", "module", "test", "job", "part", "definition", "comment", "link", "division", "table", "term", "area", "pair", "set", "element", "usage", "Section", "tab", "server", "key", "version", "row", "service", "sec", "description", "slot", "block", "journal", "state", "option", "se", "second", "status", "instance", "region", "local", "position", "session", "size", "admin", "mode", "relation", "name", "sections", "feature", "item", "connection", "tag", "our", "prefix", "setting", "page", "ment", "portion", "action", "entry", "mod", "list", "network"], "addr1": ["addr31", "addr3", " addr2", "address1", " address2", "ptr0", "adr3", "address0", "loc1", "adr0", " addr0", " addr3", "addr0", "ptr2", "loc2", "loc0", "address2", " address0", "ptrOne", " addrOne", " address3", "adr2", "ptr3", "addr2", "address31", " address1", "ptr1", "addrOne", "adr1", "address3", "addressOne", " addr31", "loc31"]}}
{"project": "FFmpeg", "commit_id": "afa982fdae1b49a8aee00a27da876bba10ba1073", "target": 1, "func": "static void compute_scale_factors(unsigned char scale_code[SBLIMIT],\n\n                                  unsigned char scale_factors[SBLIMIT][3], \n\n                                  int sb_samples[3][12][SBLIMIT],\n\n                                  int sblimit)\n\n{\n\n    int *p, vmax, v, n, i, j, k, code;\n\n    int index, d1, d2;\n\n    unsigned char *sf = &scale_factors[0][0];\n\n    \n\n    for(j=0;j<sblimit;j++) {\n\n        for(i=0;i<3;i++) {\n\n            /* find the max absolute value */\n\n            p = &sb_samples[i][0][j];\n\n            vmax = abs(*p);\n\n            for(k=1;k<12;k++) {\n\n                p += SBLIMIT;\n\n                v = abs(*p);\n\n                if (v > vmax)\n\n                    vmax = v;\n\n            }\n\n            /* compute the scale factor index using log 2 computations */\n\n            if (vmax > 0) {\n\n                n = av_log2(vmax);\n\n                /* n is the position of the MSB of vmax. now \n\n                   use at most 2 compares to find the index */\n\n                index = (21 - n) * 3 - 3;\n\n                if (index >= 0) {\n\n                    while (vmax <= scale_factor_table[index+1])\n\n                        index++;\n\n                } else {\n\n                    index = 0; /* very unlikely case of overflow */\n\n                }\n\n            } else {\n\n                index = 63;\n\n            }\n\n            \n\n#if 0\n\n            printf(\"%2d:%d in=%x %x %d\\n\", \n\n                   j, i, vmax, scale_factor_table[index], index);\n\n#endif\n\n            /* store the scale factor */\n\n            assert(index >=0 && index <= 63);\n\n            sf[i] = index;\n\n        }\n\n\n\n        /* compute the transmission factor : look if the scale factors\n\n           are close enough to each other */\n\n        d1 = scale_diff_table[sf[0] - sf[1] + 64];\n\n        d2 = scale_diff_table[sf[1] - sf[2] + 64];\n\n        \n\n        /* handle the 25 cases */\n\n        switch(d1 * 5 + d2) {\n\n        case 0*5+0:\n\n        case 0*5+4:\n\n        case 3*5+4:\n\n        case 4*5+0:\n\n        case 4*5+4:\n\n            code = 0;\n\n            break;\n\n        case 0*5+1:\n\n        case 0*5+2:\n\n        case 4*5+1:\n\n        case 4*5+2:\n\n            code = 3;\n\n            sf[2] = sf[1];\n\n            break;\n\n        case 0*5+3:\n\n        case 4*5+3:\n\n            code = 3;\n\n            sf[1] = sf[2];\n\n            break;\n\n        case 1*5+0:\n\n        case 1*5+4:\n\n        case 2*5+4:\n\n            code = 1;\n\n            sf[1] = sf[0];\n\n            break;\n\n        case 1*5+1:\n\n        case 1*5+2:\n\n        case 2*5+0:\n\n        case 2*5+1:\n\n        case 2*5+2:\n\n            code = 2;\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        case 2*5+3:\n\n        case 3*5+3:\n\n            code = 2;\n\n            sf[0] = sf[1] = sf[2];\n\n            break;\n\n        case 3*5+0:\n\n        case 3*5+1:\n\n        case 3*5+2:\n\n            code = 2;\n\n            sf[0] = sf[2] = sf[1];\n\n            break;\n\n        case 1*5+3:\n\n            code = 2;\n\n            if (sf[0] > sf[2])\n\n              sf[0] = sf[2];\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n        \n\n#if 0\n\n        printf(\"%d: %2d %2d %2d %d %d -> %d\\n\", j, \n\n               sf[0], sf[1], sf[2], d1, d2, code);\n\n#endif\n\n        scale_code[j] = code;\n\n        sf += 3;\n\n    }\n\n}\n", "idx": 16177, "substitutes": {"scale_code": [" scale_factor", " scale_operator", "scale_operator", "scaleityoperator", "scale_codes", " scale_codes", "scaleityfactor", "scale_factor", "scaleitycode", "scaleitycodes"], "scale_factors": ["scale_factsors", "scale_actories", "scale_Factores", "scale_actores", "scale_actrees", "scale_formores", "scale_formrees", "scale_factters", "scale_Factrees", "scale_factores", "scale_factories", "scale_factorset", "scale_ctters", "scale_factsories", "scale_actorset", "scale_Factories", "scale_ctors", "scale_ctorset", "scale_factsters", "scale_Factors", "scale_actters", "scale_actors", "scale_ctories", "scale_formors", "scale_formories", "scale_factsorset", "scale_factrees"], "sb_samples": ["sb_ssamples", "sb_seamps", "sb_examples", "sb_seaces", "sb_saces", "sb_sources", "sb_tamps", "sb2exources", "sb2samples", "sb_ssources", "sb2examps", "sb_tamples", "sb2sources", "sb_samaces", "sb2sores", "sb_seources", "sb_ssores", "sb_exources", "sb2examples", "sb_sores", "sb_tources", "sb_seamples", "sb_examps", "sb2samps", "sb_taces", "sb_seores", "sb_samamps", "sb_ssamps", "sb_exores", "sb2exores", "sb_samamples", "sb_samps", "sb_samources"], "sblimit": ["sflumit", "sblomiter", "sblimIT", "sblumite", "sblomit", "splimiter", "sblimiter", "sblIMit", "sblemit", "sblomitle", "splimitle", "splemit", "sblIMIT", "sblemite", "sflumite", "sblimitle", "sblIMite", "sblumIT", "sflumIT", "sflimite", "sflumiter", "splemitle", "sblimalit", "sblumiter", "sflimiter", "sblimaliter", "sblimalitle", "sblumit", "splimIT", "splimit", "sblomIT", "sblIMiter", "sblimite", "sflimit", "sblimalIT", "sflimIT", "sblemitle", "sblemIT", "sblemiter", "splemIT", "splemiter"], "p": ["jp", "f", "ph", "pi", "pr", "pb", "x", "par", "vp", "perm", "pm", "g", "pt", "t", "pp", "ping", "m", "P", "part", "op", "power", "rep", "parse", "c", "lp", "ap", "wp", "cp", "pc", "pers", "pair", "point", "u", "d", "prop", "ps", "q", "pl", "pkg", "bp", "tp", "y", "pa", "pe", "ip"], "vmax": ["vmx", " vmin", "lvmin", "valmax", "lvrange", "vemax", "VMAX", "vopen", "vright", " vconf", "avax", "lvMax", "avmax", "nMAX", "vax", "Vright", "veconf", " vgt", " vmx", "nmax", "svax", "valconf", "svMAX", " vrange", "vmin", "valgt", "vMax", "VMax", "vconf", "avright", "vMAX", " vright", "vrange", "vemx", "svmax", "nMax", "lvmax", "vgt", "svmin", "lvopen", "svMax", "avMAX", "nax", " vax", " vMax", "Vmin", " vMAX", "avMax", "Vmax", " vopen", "valmx", "avmin", "svopen", "svrange", "lvMAX", "vegt", "Vax"], "v": ["vol", "vo", "nv", "vv", "f", "ver", "tv", "V", "l", "values", "vr", "vp", "vi", "conv", "vert", "val", "sv", "m", "vm", "va", "inv", "cv", "vs", "ov", "lv", "dev", "h", "u", "qv", "d", "uv", "ve", "vc", "q", "vt", "ev", "value", "av", "x", "y", "w", "iv"], "n": ["nv", "nl", "nw", "size", "cn", "l", "x", "g", "ng", " N", "na", "len", "nd", "t", "np", "num", "nr", "nt", "m", "N", "r", "Ni", "c", "nc", "mn", "no", "ns", "b", "ot", "max", "d", "nb", "net", "ne", "q", "sn", "nan", "w", "nm", "y", "nu", "nn"], "i": ["ij", "li", "a", "at", "by", "f", "um", "iu", "out", "o", "ii", "mi", "ini", "pi", "ind", "I", "l", "ex", "si", "ki", "zi", "bi", "io", "t", "is", "ik", "iq", "di", "ia", "ami", "m", "ai", "in", "ie", "s", "xi", "qi", "im", "c", "ci", "jj", "b", "id", "ti", "my", "point", "ri", "e", "it", "multi", "me", "z", "q", "phi", "init", "x", "y", "ic", "ix", "iat", "ip"], "j": ["jp", "ij", "be", "key", "f", "ret", "o", "bs", "jit", "ind", "l", "js", "aj", "str", "bj", "g", "bi", "t", "uj", "bo", "job", "m", "br", "r", "obj", "ja", "json", "off", "c", "dj", "J", "jj", "b", "h", "jump", "jo", "fr", "e", "jl", "jc", "ji", "d", "it", "ion", "kj", "to", "z", "q", "x", "y"], "k": ["key", "kw", "kn", "ph", "kh", "uk", "km", "kid", "kt", "ok", "ki", "kk", "tk", "mk", "g", "t", "ik", "kind", "ke", "ku", "kin", "K", "m", "ek", "kr", "ko", "ac", "ck", "c", "ak", "wk", "kick", "kl", "b", "unk", "ijk", "ks", "kj", "z", "q", "ka", "sk"], "code": ["status", "key", "error", "type", "codes", "header", "size", "ind", "data", "sequence", "cmp", "call", "cod", "cc", "check", "next", "test", "try", "close", " Code", "note", "command", "offset", "tag", "desc", "definition", "condition", "message", "description", "second", "comment", "info", "use", "c", "count", "change", "pos", "event", "function", "one", "content", "action", "id", "label", "reason", "entry", "state", "length", "component", "Code", "coe", "cycle", "force", "cause", "sign", "ode", "name", "ce", "ch"], "index": ["seed", "val", "check", "port", "close", "loc", "loop", "result", "lock", "change", "location", "start", "label", "draw", "length", "shape", "zero", "error", "type", "number", "search", "address", "ind", "timeout", "si", "test", "initial", "note", "Index", "EX", "open", "pos", "link", "slice", "set", "ion", "cycle", "level", "ex", "x", "ix", "node", "key", "scroll", "out", "row", "write", "offset", "connect", "scan", "update", "zone", "info", "empty", "block", "capacity", "prime", "id", "iter", "state", "option", "second", "status", "instance", "position", "success", "size", "is", "num", "connection", "condition", "time", "iso", "find", "count", "page", "ice", "point", "order", "list", "max", "value", "network"], "d1": [" done", "d7", "dup", "v3", "fup", "d5", "f7", "pd41", "f3", "v1", " d0", " dup", "d3", " d5", "done", "n0", "bd2", "v7", "bd41", "bd0", "pdone", "none", "D41", "bd5", " d3", "pd1", "D2", " d7", "Done", "n5", "n1", "bd1", "d0", "bdone", "f1", "d41", "vup", "D1", "pd2"], "d2": ["dt3", "n2", "d5", "dt2", "dd02", "bd64", "d02", "dd2", "d3", " d5", "D02", "dtwo", "bd2", "bd3", "D3", " dtwo", "dt5", "dd1", "d64", "Dtwo", "bd5", "dt64", "n02", " d3", " d64", "D2", " d02", "ntwo", "dd3", "D1"], "sf": ["csv", "sql", "ctl", "fw", "cf", "gs", "ty", "sw", "isf", "f", "lf", "pb", "sy", "tif", "hw", "rf", "si", "dl", "sq", "fd", "vp", "bj", "stab", "sl", "ief", "sol", "alf", "sm", "sb", "sv", "fm", "rm", "hs", "buff", "ds", "ze", "fx", "php", "fee", "ssl", "tf", "sp", "fo", "sr", "bf", "sh", "ssh", "df", "SF", "fs", "sd", "zz", "see", "fi", "xf", "uf", "sn", "supp", "ss", "tp", "scl", "rn", "qq", "fy", "sk"]}}
{"project": "FFmpeg", "commit_id": "b926b6282d3b9fc8115660ae013f74f4f8c06d30", "target": 0, "func": "static void opt_new_stream(const char *opt, const char *arg)\n\n{\n\n    AVFormatContext *oc;\n\n    if (nb_output_files <= 0) {\n\n        fprintf(stderr, \"At least one output file must be specified\\n\");\n\n        ffmpeg_exit(1);\n\n    }\n\n    oc = output_files[nb_output_files - 1];\n\n\n\n    if      (!strcmp(opt, \"newvideo\"   )) new_video_stream   (oc);\n\n    else if (!strcmp(opt, \"newaudio\"   )) new_audio_stream   (oc);\n\n    else if (!strcmp(opt, \"newsubtitle\")) new_subtitle_stream(oc);\n\n    else assert(0);\n\n}\n", "idx": 16183, "substitutes": {"opt": ["kw", "ver", "usr", "attr", "cmd", "ok", "expr", "crit", "tr", "other", "stat", "typ", "oop", "req", "proc", "text", "not", "help", "cat", "op", "og", "gt", "obj", "aux", "oss", "org", "rt", "ost", "block", "lt", "eff", "term", "etc", "OP", "ot", "it", "tip", "iter", "var", "option", "prop", "options", "net", "Opt", "rop", "init", "str", "nom", "txt"], "arg": ["key", "kw", "param", "at", "ax", "cmd", "ag", "call", "proc", "g", "ig", "spec", "command", "op", "tag", "og", "Arg", "doc", "use", "parse", "block", "count", "event", "argument", "flag", "args", "config"], "oc": ["isc", "rc", "cu", "co", "unc", "o", "mic", "ocr", "erc", "ocation", "orp", "io", "oco", "ox", "toc", " ic", "voc", "dc", "ob", "OC", "ek", "og", "uc", "oss", "org", "ac", "roc", "irc", "aic", "ost", "om", "c", "nc", "ec", "oci", "ov", "gc", "oe", "cs", "bc", "soc", "oid", "pc", "ocon", "nic", "mc", "osc", "ot", "vc", "arc", "ic", "anc", "ico", "alloc"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,\n\n\tunsigned int width, unsigned int height,\n\n\tint lumStride, int chromStride, int srcStride)\n\n{\n\n\tunsigned y;\n\n\tconst unsigned chromWidth= width>>1;\n\n\tfor(y=0; y<height; y+=2)\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\tasm volatile(\n\n\t\t\t\"xor %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\t\"pcmpeqw %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"psrlw $8, %%mm7\t\t\\n\\t\" // FF,00,FF,00...\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\tPREFETCH\" 64(%0, %%\"REG_a\", 4)\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\", 4), %%mm0\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq 8(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // U0V0 U0V0(0)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // U0V0 U0V0(4)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(0)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(4)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // UVUV UVUV(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(0)\n\n\n\n\t\t\tMOVNTQ\" %%mm2, (%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"movq 16(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq 24(%0, %%\"REG_a\", 4), %%mm2\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq %%mm2, %%mm4\t\t\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // U0V0 U0V0(8)\n\n\t\t\t\"psrlw $8, %%mm2\t\t\\n\\t\" // U0V0 U0V0(12)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(8)\n\n\t\t\t\"pand %%mm7, %%mm4\t\t\\n\\t\" // Y0Y0 Y0Y0(12)\n\n\t\t\t\"packuswb %%mm2, %%mm1\t\t\\n\\t\" // UVUV UVUV(8)\n\n\t\t\t\"packuswb %%mm4, %%mm3\t\t\\n\\t\" // YYYY YYYY(8)\n\n\n\n\t\t\tMOVNTQ\" %%mm3, 8(%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // UVUV UVUV(0)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // UVUV UVUV(8)\n\n\t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // V0V0 V0V0(0)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // V0V0 V0V0(8)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // U0U0 U0U0(0)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // U0U0 U0U0(8)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // VVVV VVVV(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // UUUU UUUU(0)\n\n\n\n\t\t\tMOVNTQ\" %%mm0, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm2, (%2, %%\"REG_a\")\t\\n\\t\"\n\n\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth)\n\n\t\t\t: \"memory\", \"%\"REG_a\n\n\t\t);\n\n\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\n\n\t\tasm volatile(\n\n\t\t\t\"xor %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\tPREFETCH\" 64(%0, %%\"REG_a\", 4)\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\", 4), %%mm0\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq 8(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"movq 16(%0, %%\"REG_a\", 4), %%mm2\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq 24(%0, %%\"REG_a\", 4), %%mm3\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"pand %%mm7, %%mm0\t\t\\n\\t\" // Y0Y0 Y0Y0(0)\n\n\t\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\" // Y0Y0 Y0Y0(4)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(8)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(12)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // YYYY YYYY(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(8)\n\n\n\n\t\t\tMOVNTQ\" %%mm0, (%1, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm2, 8(%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\n\n\t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth)\n\n\t\t\t: \"memory\", \"%\"REG_a\n\n\t\t);\n\n#else\n\n\t\tunsigned i;\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tydst[2*i+0] \t= src[4*i+0];\n\n\t\t\tudst[i] \t= src[4*i+1];\n\n\t\t\tydst[2*i+1] \t= src[4*i+2];\n\n\t\t\tvdst[i] \t= src[4*i+3];\n\n\t\t}\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tydst[2*i+0] \t= src[4*i+0];\n\n\t\t\tydst[2*i+1] \t= src[4*i+2];\n\n\t\t}\n\n#endif\n\n\t\tudst += chromStride;\n\n\t\tvdst += chromStride;\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\t}\n\n#ifdef HAVE_MMX\n\nasm volatile(   EMMS\" \\n\\t\"\n\n        \tSFENCE\" \\n\\t\"\n\n        \t:::\"memory\");\n\n#endif\n\n}\n", "idx": 16190, "substitutes": {"src": ["rc", "sw", "lr", "addr", "inc", "str", "tr", "RC", "rl", "sur", "lib", "sq", "filename", "sl", "ipl", "syn", "source", "loc", "sb", "st", "sys", "lb", "scan", "dist", "in", "r", "rect", "rt", "txt", "dest", "sr", "img", "lat", "ins", "rol", "ser", "input", "hl", "sym", "rx", "sn", "inst", "sc", "usr", "rs", "sub"], "ydst": ["ldST", "ydset", "ydste", "ynnd", "yust", "yuSt", "xdost", "ldost", "dyste", "ydST", "hydset", "odst", "ynst", "ytste", "xdST", "yuste", "ytst", "dysta", "dyst", "ynsta", "ldst", "hydsta", "ydist", "ynset", "dySt", "odist", "xdist", "hdst", "hdsta", "hydst", "yusta", "odost", "ydost", "ydSt", "ydsta", "hdset", "odST", "hydnd", "xdst", "ydnd", "ytSt", "ytsta", "ldist", "hdnd"], "udst": ["vdsta", "vdsrc", "udsta", "rodsta", "odst", "rodost", "udsc", "ubst", "rodsrc", "ubsc", "udnd", "udsrc", "odsrc", "ubstr", "adstr", "adnd", "odost", "vdost", "rodst", "udost", "ubnd", "adst", "odsta", "odstr", "udstr", "adsc", "odsc", "odnd"], "vdst": ["pdset", "vdset", "ddstart", "udt", "vdsrc", "wdset", "wdst", "odst", "vdbl", "wdsrc", "ldstart", "wdt", "ddbl", "ldst", "ldstr", "odstart", "vdstr", "pdst", "udsrc", "ddstr", "pdt", "pdsrc", "ddst", "udset", "odbl", "vdstart", "vdt", "odstr", "ldbl"], "height": ["hang", "wh", "ty", "density", "size", "high", "build", "row", "depth", "window", "rows", "inches", "ih", "padding", "rank", "hs", "bottom", "flow", "Height", "he", "hei", "block", "count", "capacity", "ht", "start", "h", "grow", "H", "id", "max", "length", "total", "shape", "w", "above", "x", "zh", "history", "ch"], "lumStride": ["lumStide", "lumRestrap", "lumRestro", "lumbRestr", "lumstro", "lumbStro", "lumStrip", "lumRro", "lumStrro", "lumaStrap", "lumStrride", "lumbStr", "lumStr", "lumEstrip", "lumbStride", "lumaEstro", "lumaStro", "lumaEstride", "lumEstro", "lumaEstrip", "lumRestr", "lumEstride", "lumaStride", "lumRestride", "lumstr", "lumstide", "lumbRestride", "lumStrap", "lumbRestro", "lumRestide", "lumRrap", "lumStro", "lumaStrip", "lumstride", "lumRrip", "lumEstrap", "lumbRestide", "lumaEstrap", "lumRride", "lumRestrip", "lumStrr", "lumbStide"], "chromStride": ["romStrip", "romStape", "chromRestide", "chromSTride", "chromSTrip", "chromStrip", "chromStape", "chromStide", "romStrrip", "romStrape", "chromRestape", "chromRestride", "chromSTide", "chromRestrip", "romStride", "romStide", "chromStrape", "romStrride", "chromSTape", "chromStrrip", "chromStrride"], "srcStride": ["rcStrobe", "srcStwrite", "srcstack", "srcStrrobe", "rcStrrobe", "srcDestide", " srcListack", "srcSTwrite", "srcRestriction", " srcListride", "srcStrobe", "srcListriction", " srcStide", " srcListide", "rcStride", "srcListride", "srcDestrobe", "srcListack", " srcListriction", "rcStide", "rcStrride", "srcStriction", " srcStriction", "srcRestide", "srcSTride", "srcRestride", " srcStack", "srcStrwrite", "rcStrwrite", "srcStack", "srcstriction", "srcRestack", "rcStwrite", "srcstide", "srcStide", "srcSTide", "srcDestride", "srcSTrobe", "srcStrride", "srcDestwrite", "srcstride", "srcListide"], "y": ["yy", "index", "ly", "ty", "yt", "oy", "by", "asy", "py", "dy", "out", "ny", "ys", "j", "sy", "axy", "p", "Y", "yet", "xy", "ya", "ym", "t", "ay", "yr", "aily", "k", "m", "cy", "vy", "yp", " Y", "iy", "ies", "ady", "count", "top", "h", "hey", "e", "my", "sky", "yo", "gy", "ey", "ley", "yl", "w", "x", "yn", "ch"]}}
{"project": "FFmpeg", "commit_id": "80b1e1c03d26ade05b0f53d0731aa7398d4ef6f9", "target": 1, "func": "static int huf_uncompress(GetByteContext *gb,\n\n                          uint16_t *dst, int dst_size)\n\n{\n\n    int32_t src_size, im, iM;\n\n    uint32_t nBits;\n\n    uint64_t *freq;\n\n    HufDec *hdec;\n\n    int ret, i;\n\n\n\n    src_size = bytestream2_get_le32(gb);\n\n    im = bytestream2_get_le32(gb);\n\n    iM = bytestream2_get_le32(gb);\n\n    bytestream2_skip(gb, 4);\n\n    nBits = bytestream2_get_le32(gb);\n\n    if (im < 0 || im >= HUF_ENCSIZE ||\n\n        iM < 0 || iM >= HUF_ENCSIZE ||\n\n        src_size < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    bytestream2_skip(gb, 4);\n\n\n\n    freq = av_calloc(HUF_ENCSIZE, sizeof(*freq));\n\n    hdec = av_calloc(HUF_DECSIZE, sizeof(*hdec));\n\n    if (!freq || !hdec) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    if ((ret = huf_unpack_enc_table(gb, im, iM, freq)) < 0)\n\n        goto fail;\n\n\n\n    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {\n\n        ret = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n\n\n    if ((ret = huf_build_dec_table(freq, im, iM, hdec)) < 0)\n\n        goto fail;\n\n    ret = huf_decode(freq, hdec, gb, nBits, iM, dst_size, dst);\n\n\n\nfail:\n\n    for (i = 0; i < HUF_DECSIZE; i++) {\n\n        if (hdec[i].p)\n\n            av_freep(&hdec[i].p);\n\n    }\n\n\n\n    av_free(freq);\n\n    av_free(hdec);\n\n\n\n    return ret;\n\n}\n", "idx": 16197, "substitutes": {"gb": ["csv", "bytes", "gs", "tg", "ib", "gin", "gg", "py", "src", "GB", "um", "pb", "hub", "ctx", "wb", "eb", "storage", "deg", "g", "xy", "io", "goo", "sb", "bt", "msg", "sys", "rb", "cfg", "gt", "kb", "gd", "bn", "phy", "html", "range", "cb", "gow", "db", "cv", "bf", "img", "gc", "rg", "gnu", "gm", "bc", "pg", "args", "pc", "gif", "eg", "gpu", "emb", "gz", "mb", "uf", "bb", "gy", "nb", "bg", "Gb", "gh", "gov", "ch"], "dst": ["dnt", "ddest", " dsts", "fdest", "dssts", "dedst", "fst", "dednt", "dsst", "gdest", " dnt", " ddest", "dux", "dsts", " dct", "dsct", " dux", "fsts", "deddest", "gux", "fct", "gnt", "gst", "dedux", "dsdest", "dct"], "dst_size": ["dst_name", "ddest_size", "dst_ize", "dest_name", "dest_ize", "dst_Size", "dest_Size", "dest_size", "ddest_SIZE", "ddest_Size", "dst2size", "dst2Size", "dst2name", "dst2ize", "dst_SIZE"], "src_size": ["src2share", " src_space", "src_length", "src2length", "src_SIZE", " src_length", " src_share", "src_share", "src__len", "src__SIZE", "src_space", "src2size", "src__size", "src2len", "src2space", "rc_size", "rc_SIZE", "src2SIZE", "src__length", " src_len", "rc_len", "src_len", "rc_length", " src_SIZE"], "im": ["am", "med", "ij", "il", "umi", "ib", "um", "imet", "ime", "cm", "mi", "rim", "aim", "imming", "mic", "iam", "imi", "ir", "him", "arm", "ig", "Im", "ym", "ih", "fm", "com", "ami", "em", "ai", "m", "imus", "dom", "ie", "iem", "sim", "dim", "imp", "iman", "om", "irm", "IM", "gm", "rom", "ims", "anim", "iv", "tim", "imm", "ic", "ip"], "iM": [" iL", " iJM", "iniM", "ioDM", "iuMX", "iuN", " iMM", "tiM", " iME", "tiMX", " iP", "IJM", "siD", "iMP", "oMP", "iME", "iniMI", "itMM", "siM", "iMT", "itN", " iDM", "iO", "iniO", "oDM", "oM", "iuME", "itM", "iuO", " iO", " iH", "tiL", "iN", "iDM", "iMX", "iR", "uiMM", "ioM", "iniMB", "iP", "IMM", "oP", " iD", "uiN", "IN", "iniN", "iL", " iMX", "tiMM", "iH", "siN", " iMT", "iMM", " iMP", "itMI", "ioP", " iMB", " iN", "tiMT", "iJM", "ioMP", "iuL", " iR", "iMB", "tiME", "iD", "siMI", "iuR", "iuD", "iuM", "siH", "iniMM", "iuMB", "tiR", "IM", "iuMT", "iMI", "uiJM", "siMM", "iuH", "iuMM", "uiM"], "nBits": ["nbits", "NBits", "nBsbits", "nAbicks", "nRins", "nbips", "nChugs", "nButits", "nBacks", "nBsacks", "nBalips", "nIBins", " nIBits", "nRits", "nBsits", "NButacks", "nBips", " nBicks", "NBbits", "NButins", " nBins", "nBbits", "nBins", " nIBbits", "NButits", "nBsins", "nbins", "nRbits", "nChins", "nIBbits", "nAbins", " nBugs", "nAbbits", "nCBins", "nRITS", "nAbits", "NBins", " nbins", "nbicks", " nBITS", "nCBITS", "nUbbits", "nUbits", "nButins", "nChips", "nBalits", "nCBits", " nIBicks", "nUbacks", "nButacks", "nChits", "nIBicks", " nbugs", " nBips", "nBugs", "NBacks", "nUbins", " nbits", "NButbits", "nBITS", "nButbits", " nIBins", "nBalins", "nBicks", "nbugs", " nbips", " nBbits", "nIBits", "nCBbits", "nbbits", "nBalugs"], "freq": ["fireQ", "finqs", " freck", "finck", "falqq", "falqi", "freQ", "frequencyqq", "frerequ", "frqt", "freqi", "Frerequ", "freqq", "fereq", "produrequ", "feqq", "freqt", "freux", "finq", "freqv", "auQ", "fireck", "frequencyqv", "freeQ", "frqs", "auv", "falq", "frequencyque", "frequencyq", "broadq", "feqi", "frq", "sleque", " freqs", "Freqq", "feQ", "finqt", "feck", "Freqs", "frequencyqi", "frequencyrequ", "frck", "feqs", " frereq", "slerequ", "feqv", "Freq", "falqv", "broadqq", "freqs", "feq", "produQ", "feque", "auq", "sleq", "ferequ", "freck", "broadQ", " freqq", " freux", "produq", "freque", "broadrequ", "frereq", "fev", "fireq", "freeqq", "produqs", "fireux", " frerequ", "aureq", "FreQ", "frev", "Freck", "Freux", " frev", "freeqs", "freeq", "feqt", "sleqq", " freQ"], "hdec": ["shdec", "ohDec", "ahde", "Hdec", "Hdecl", "ehdel", "ehdes", "hdes", "ihde", "hineg", "hneg", "hhdesc", "ihdel", " hdecl", "rrec", "ihdes", "ohrec", "ohdesc", "hdel", "ohde", "htmldec", "ahdes", "hhdec", "ehde", "shrec", "shdecl", " hdes", "hidecl", "htmlneg", " hDec", "ohfunc", "rdecl", " hnext", "shder", "hdesc", "rder", "Hde", "hidec", "htmlDec", "ahdesc", "ihDec", "ehdec", "hrdec", " hrec", "HDec", "hDec", "htmldecl", "Hrec", " hde", "Hneg", "ohdecl", "hiDec", "hrnext", "hrdecl", "ihdecl", "hnext", "ohder", "hhfunc", "Hfunc", " hneg", " hdesc", "hhdecl", "ohdec", "hdecl", "hder", "ihnext", "ahdel", "hrec", "ihrec", "ihdec", "hde", "ahdec", "ahdecl", "hrrec", "Hdes", "rdec", "Hdesc", "hfunc"], "ret": ["resp", "jp", "rem", "def", "status", "nl", "mem", "et", "out", "ref", "success", "det", "ll", "fun", "j", "cmd", "back", "Ret", "rets", "RET", "val", "reset", "dt", "deg", "ert", "rm", "result", "sys", "ext", "nt", "lit", "alt", "att", "url", "gt", "alg", "aux", "off", "rt", "rev", "progress", "Return", "summary", "ry", "res", "print", "flag", "cert", "re", "ort", "mt", "rel", "iter", "ft", "arg", "it", "elt", "net", "pas", " Ret", "del", "xt", "full", "cont", "complete"], "i": ["index", "li", "f", "o", "oi", "ii", "mi", "I", "pi", "ind", "ini", "j", "ei", "p", "n", "ki", "x", "si", "ir", "zi", "v", "cli", "chain", "g", "bi", "batch", "io", "t", "ui", "is", "di", "ami", "ai", "m", "in", "s", "xi", "qi", "parent", "sim", "info", "\u0438", "ci", "b", "wi", "mc", "ti", "iter", "u", "it", "multi", "gi", "me", "ma", "q", "phi", "y", "ic", "ix", "ip"]}}
{"project": "FFmpeg", "commit_id": "b25e84b7399bd91605596b67d761d3464dbe8a6e", "target": 1, "func": "static int hevc_frame_start(HEVCContext *s)\n\n{\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n    int ret;\n\n\n\n    memset(s->horizontal_bs, 0, 2 * s->bs_width * (s->bs_height + 1));\n\n    memset(s->vertical_bs,   0, 2 * s->bs_width * (s->bs_height + 1));\n\n    memset(s->cbf_luma,      0, s->sps->min_tb_width * s->sps->min_tb_height);\n\n    memset(s->is_pcm,        0, s->sps->min_pu_width * s->sps->min_pu_height);\n\n\n\n    lc->start_of_tiles_x = 0;\n\n    s->is_decoded        = 0;\n\n\n\n\n    if (s->pps->tiles_enabled_flag)\n\n        lc->end_of_tiles_x = s->pps->column_width[0] << s->sps->log2_ctb_size;\n\n\n\n    ret = ff_hevc_set_new_ref(s, s->sps->sao_enabled ? &s->sao_frame : &s->frame,\n\n                              s->poc);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    ret = ff_hevc_frame_rps(s);\n\n    if (ret < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Error constructing the frame RPS.\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    ret = set_side_data(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    av_frame_unref(s->output_frame);\n\n    ret = ff_hevc_output_frame(s, s->output_frame, 0);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    ff_thread_finish_setup(s->avctx);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    if (s->ref)\n\n        ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);\n\n    s->ref = NULL;\n\n    return ret;\n\n}", "idx": 16203, "substitutes": {"s": ["ses", "gs", "S", "settings", "bs", "ties", "ports", "ctx", "sq", "plays", "ags", "t", "eds", "acs", "qs", "stats", "vs", "states", "cs", "tests", "ims", "tes", "aunts", "its", "us", "ps", "sw", "j", "n", "js", "params", "v", "g", "ar", "comm", "spec", "ds", "ats", "services", "ies", "sc", "ars", "self", "conf", "ows", "parts", "scl", "results", "south", "a", "as", "less", "xs", "als", "sb", "hs", "sys", "reports", "times", "erences", "c", "ops", "es", "changes", "fs", "events", "se", "views", "sports", "ss", "comments", "aws", "serv", "o", "has", "tags", "l", "p", "details", "bes", "is", "sv", "ls", "ches", "r", "gets", "ts", "ins", "ns", "b", "h", "e", "os", "styles", "sets", "sts", "w", "ms", "rs"], "lc": ["nl", "tl", "unc", "tc", "lf", "cm", "lr", "ll", "l", "ctx", "ln", "LC", "rl", "dl", "cc", "wl", "loc", "lb", "icc", "ls", "cl", "lu", "c", "cb", "lp", "xc", "ec", "kl", "gc", "cp", "mc", "cs", "bc", "lv", "pc", "fc", "vc", "coll"], "ret": ["fun", "back", "val", "vet", "t", "len", "rm", "result", "nt", "att", "rev", "Return", "net", " Ret", "del", "usr", "cont", "arr", "rem", "def", "mem", "ll", "addr", "j", "cmd", "tr", "RET", "reset", "dt", "try", "get", "RT", "res", "print", "gc", "ber", "flag", "mt", "elt", "ter", "txt", "resp", "f", "ref", "out", " alt", "Ret", "reply", "rets", "nz", "gt", "mel", " jet", "ft", "err", "leg", "status", "jp", " RET", "det", "deg", "tn", "ext", "alt", "url", "off", "rt", "lt", "cert", "re", "pas", "final", " fut"]}}
{"project": "qemu", "commit_id": "4ed7b2c3a78f785a1bcbe575e08c379b166723e3", "target": 1, "func": "static int local_open2(FsContext *fs_ctx, V9fsPath *dir_path, const char *name,\n\n                       int flags, FsCred *credp, V9fsFidOpenState *fs)\n\n{\n\n    char *path;\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n    V9fsString fullname;\n\n    char *buffer;\n\n\n\n    /*\n\n     * Mark all the open to not follow symlinks\n\n     */\n\n    flags |= O_NOFOLLOW;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    path = fullname.data;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(buffer, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set client credentials in .virtfs_metadata directory files */\n\n        err = local_set_mapped_file_attr(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n               (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    err = fd;\n\n    fs->fd = fd;\n\n    goto out;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(buffer);\n\n    errno = serrno;\n\n    g_free(buffer);\n\nout:\n\n    v9fs_string_free(&fullname);\n\n    return err;\n\n}\n", "idx": 16204, "substitutes": {"fs_ctx": ["fs_check", "fs8cp", "fs2tx", "fsdbaddr", "fsdbkw", "sys2cp", "fspyca", "fw___kw", "fsdresp", "fs_ann", "fs_jp", "fsdctl", "fw___ctx", "fs8kw", "fs___cp", "cs_pkg", "cs_ctl", "fs__pkg", "fts_kw", "ftsdbaddr", "fspycp", "fs_cp", "cs_context", "fs___check", "uds_context", "fs8ctx", "cs_ctx", "ftsdbkw", "cs_resp", "fspycontext", "fw_check", "fs_ct", "fs__ctx", "fs_resp", "fw_cp", "ftsdbctx", "fs_addr", "ftsdbgrad", "fsdbgrad", "obs_ctx", "fs_context", "fts_ctx", "cs_obj", "fs___ctx", "fs_gc", "fts_grad", "fs8check", "obs_prefix", "uds_ctx", "cs_ann", "fs2ctx", "fs_pkg", "fsdtx", "fspyctx", "sys_ctx", "sys2obj", "fw___check", "uds_gc", "fw_ctx", "fs_obj", "fsdctx", "fs_grad", "fs_ca", "fs__tx", "sys_obj", "sys_tx", "sys2ctx", "fs_prefix", "fts_addr", "fs___kw", "fs2prefix", "sys_cp", "fs_tx", "obs_tx", "sys_context", "fsdbctx", "cs_ct", "uds_jp", "fw___cp", "fs_kw", "obs_ctl", "fs__obj", "fs_ctl", "fs2ctl", "fs2obj", "fs2cp", "sys_ca", "fw_kw", "cs_tx", "sys2tx"], "dir_path": ["dirxcontext", "dirxpath", "dir2context", "dir_case", "dir_Path", "dir2path", " directory___path", "dir___Path", "dir_ctx", " directory_path", " dir2path", " directory_case", "dir2Path", "dirxPath", " dir2ctx", " dir2context", "dir___ctx", " directory___Path", " dir_ctx", " dir_Path", " directory___ctx", "dir___path", " directory_ctx", " dir2Path", "dir___case", " directory_Path", "dir_context", "dirxctx", " dir_context", "dir2ctx", " directory___case"], "name": ["key", "type", "mem", "local", "size", "data", "mask", "n", "nam", "names", "filename", "dir", "cap", "title", "ext", "part", "parent", "Name", "prefix", "info", "comment", "c", "file", "base", "alias", "root", "id", "label", "format", "ame", "package", "nm", "NAME", "str", "normal"], "flags": ["comments", "status", "types", "errors", "settings", "FLAG", "ints", "tags", "ports", "cond", "utils", "lines", "mask", "fd", "bits", "params", "ags", "fields", "limits", "includes", "features", "details", "frames", "pins", "faces", "ats", "times", "finals", "tails", "lag", "headers", "vals", "grades", "atts", "ts", "Flags", "mates", "stats", "friendly", "products", "states", "flag", "ops", "args", "cs", "amps", "locks", "posts", "styles", "parts", "options", "ants", "fps", "weights", "actions", "properties"], "credp": ["credpc", "ancredpc", "cursedpt", "credup", "ccedpc", "creddpt", "callreedtp", " chedvp", "convashedjp", "ccedup", " cedP", "cpredtp", "accredp", "credpre", " cedpre", "cdefpc", "accredphp", "crodcp", "callreedp", "accppedpc", "cgedphp", "cribpad", "credphp", "cedpre", "ccedp", "ancdefcp", "ciedps", "cribp", "convredpad", "ancdefpad", "convredp", "cpredvp", "accredpc", "ccedn", "cnedp", " credtp", "creedpa", " credP", "callredpc", "kcedp", "ccedtp", "cashedjp", "cedp", "accppedp", "ciedp", "creedp", "cdbtp", " chedP", "icreddpt", "convashedp", "convashedup", "convashedpad", "cppedcp", "ancdefp", "kcedpre", "ancredcp", "ancredp", " cedtp", "chedvp", "cpredn", "convredup", "creddphp", "ciedphp", "cpredpre", "chedp", "callredpa", "icreddphp", "cdefp", "credn", "credf", "cdefcp", "ciedup", "cdefpad", "convredjp", " cedp", "icredps", "cledpre", "cgedp", "cppedp", "cpredp", "cribcp", "ccedpad", "cledP", "creedpc", "chedf", "cppedpad", "ciedpad", "cledtp", "creedtp", "cribpc", "ciedpt", "kredn", "icreddp", "cursedp", "ciedjp", "credcp", "cdbpc", "cpredP", "chedP", "kcedn", "icredphp", "cedtp", "credtp", "ccedpa", "cledp", "cpredcp", "ccedcp", "cnedcp", "cppedphp", "credpt", "crodp", "creddp", "cnedpc", "crodn", "credjp", "credps", "cashedpad", "callredtp", "ancredpad", "credpa", "callredp", "creddps", "cedvp", "credP", "cedf", "crodpre", "ccedjp", "cgedcp", "cgedpc", "kredpre", "cursedphp", "cdbpa", "credpad", "icredp", " chedf", "kredp", "cpredf", "cppedpc", " credf", "cedP", "ccedpre", "icredpt", " chedp", "accppedphp", " credvp", "cashedup", "callreedpa", "cdbp", "ancdefpc", "kredcp", "callreedpc", "cashedp", "credvp", "kcedcp", "icreddps", "accredcp", "cursedps", " credpre", "cnedphp", "accppedcp"], "fs": ["fw", "cf", "gs", "aos", "f", "bs", "FS", "sys", "ds", "Fs", "ls", "ess", "ips", "ts", "bf", "ns", "cs", "ims", "fc", "os", "fps", "irs", "ss", "ms", "rs", "ps"], "path": ["node", "key", "index", "route", "mount", "patch", "ref", "out", "handle", "address", "data", "PATH", "cmd", "p", "str", "x", "stream", "ctx", "temp", "ath", "dir", "filename", "pattern", "text", "chain", "test", "port", "pt", "t", "binding", "padding", "policy", "context", "url", "th", "parent", "prefix", "c", "empty", "file", "Path", "location", "link", "alias", "device", "root", "id", "transform", "host", "seek", "trace", "entry", "length", "method", "prop", "package", "ata", "target", "format", "pkg", "w", "history", "full", "template", "pointer"], "fullname": ["longresource", "longame", " fullnam", "fullame", " fullstring", "shortpath", "fulresource", "relName", "shortname", "fulpath", "longpath", "fullnam", "longName", "longname", "hostName", " fullpath", "relname", "shortName", " fullame", " fullName", "shortstring", " fullresource", "longnam", "fullstring", "fulstring", "relstring", "hostname", "fullresource", "shortame", "hostnam", "fullName", "fullpath", "longstring", "fulname", "hostame", "relame"], "buffer": ["directory", "header", "attr", "sequence", "window", "raw", "filename", "port", "engine", "gl", "result", "command", "program", "send", "context", "match", "document", "console", "function", "binary", "draw", "length", "uf", "queue", "filter", "tty", "database", "error", "mem", "ptr", "address", "data", "callback", "fd", "flash", "timeout", "tr", "Buffer", "read", "buff", "blank", "memory", "comment", "available", "null", "table", "device", "uffer", "txt", "scroll", "f", "out", "background", "reference", "temp", "text", "batch", "store", "source", "buf", "empty", "block", "phrase", "iter", "package", "bytes", "profile", "button", "handle", "size", "response", "stream", "cache", "bin", "message", "writer", "base", "password", "page", "code", "append", "b", "format", "template", "pointer"]}}
{"project": "FFmpeg", "commit_id": "63d6a6b91e4997737905bbd2cf5970ad90a31869", "target": 1, "func": "static void fix_coding_method_array (int sb, int channels, sb_int8_array coding_method)\n\n{\n\n    int j,k;\n\n    int ch;\n\n    int run, case_val;\n\n    int switchtable[23] = {0,5,1,5,5,5,5,5,2,5,5,5,5,5,5,5,3,5,5,5,5,5,4};\n\n\n\n    for (ch = 0; ch < channels; ch++) {\n\n        for (j = 0; j < 64; ) {\n\n            if((coding_method[ch][sb][j] - 8) > 22) {\n\n                run = 1;\n\n                case_val = 8;\n\n            } else {\n\n                switch (switchtable[coding_method[ch][sb][j]]) {\n\n                    case 0: run = 10; case_val = 10; break;\n\n                    case 1: run = 1; case_val = 16; break;\n\n                    case 2: run = 5; case_val = 24; break;\n\n                    case 3: run = 3; case_val = 30; break;\n\n                    case 4: run = 1; case_val = 30; break;\n\n                    case 5: run = 1; case_val = 8; break;\n\n                    default: run = 1; case_val = 8; break;\n\n                }\n\n            }\n\n            for (k = 0; k < run; k++)\n\n                if (j + k < 128)\n\n                    if (coding_method[ch][sb + (j + k) / 64][(j + k) % 64] > coding_method[ch][sb][j])\n\n                        if (k > 0) {\n\n                           SAMPLES_NEEDED\n\n                            //not debugged, almost never used\n\n                            memset(&coding_method[ch][sb][j + k], case_val, k * sizeof(int8_t));\n\n                            memset(&coding_method[ch][sb][j + k], case_val, 3 * sizeof(int8_t));\n\n                        }\n\n            j += run;\n\n        }\n\n    }\n\n}\n", "idx": 16205, "substitutes": {"sb": ["jp", "sbm", "ij", "ib", "bs", "kh", "ebin", "pb", "sy", "hw", "usb", "eb", "bh", "bj", "shop", "erb", "stab", "chron", "bi", "SB", "sm", "bt", "zb", "gb", "sys", "uj", "ih", "rb", "sf", "sch", "arb", "sa", "shell", "bn", "ja", "ssl", "bm", "sp", "db", "cb", "bf", "ssh", "jj", "gc", "b", "ht", "bc", "ach", "sit", "bps", "sg", "ji", "bis", "dh", "bb", "nb", "bg", "sn", "sth", "hh", "hap", "sc", "ob"], "channels": ["Chands", "chesunks", " chands", "chanasks", "chopes", "cars", "chars", "chanopes", "chanannels", "chands", "achunks", "chesopes", "achopes", "chunks", "Chars", "cannels", "Chans", "cans", "achannels", "chans", "cands", "chesannels", "achasks", "chesasks", "Channels", "chanunks", " chans", " chars", "chasks"], "coding_method": ["codingphpprocess", "coder_Method", "coding_handler", "coding___handler", "cording_function", "coding___function", "cording___Method", "cording_Method", "coding08Method", "coding___method", "coding08handler", "coding_Method", "code_METHOD", "coding_function", "coding_type", "code_Method", "coder_temp", "cording___method", "coding_mem", "codingJmethod", "codingphpmethod", "coding_hod", "cording___handler", "coding08function", "coding_METHOD", "codingJtemp", "codingphptemp", "coding_process", "codingJprocess", "coder_hod", "coding_nom", "coder_mem", "cording_method", "coder_type", "code_method", "cording___function", "coding___Method", "coder_process", "codingphpMETHOD", "coder_code", "coder_METHOD", "coding08method", "code_nom", "coder_nom", "coder_path", "coder_method", "cording_handler", "coding_temp", "coding_code", "coding_path", "codingJMETHOD"], "j": ["ij", "jp", "be", "li", "server", "at", "bs", "jit", "ind", "pr", "l", "n", "js", "p", "aj", "bj", "v", "g", "bi", "el", "pt", "t", "ik", "uj", "bo", "er", "job", "ek", "br", "r", "obj", "json", "ja", "off", "sim", "im", "dj", "J", "pos", "db", "jj", "b", "jump", "jo", "fr", "jl", "jc", "ot", "eg", "ji", "ion", "it", "d", "kj", "err", "z", "q", "i", "x", "y", "ix"], "k": ["key", "kw", "kn", "kh", "uk", "cm", "km", "ki", "n", "kid", "p", "kt", "ok", "l", "kk", "mk", "tk", "v", "ger", "ik", "kind", "isk", "ke", "ku", "kin", "K", "ek", "m", "r", "ko", "kr", "ask", "ck", "work", "c", "ak", "wk", "kick", "dk", "ka", "kl", "mc", "unk", "ack", "ark", "ks", "ijk", "it", "ikk", "kj", "z", "q", "i", "x", "an", "sk"], "ch": ["cor", "conn", "cht", "hw", "chip", "com", "gb", "tch", "ur", "ich", "ann", "channel", "att", "he", "ble", "arch", "cb", "sh", "gr", "ht", "cs", "cho", "sk", "anch", "co", "ph", "cmd", "chron", "v", "CH", "ih", "sch", "br", "th", "chrom", "cp", "chan", "hl", "cycle", "i", "chn", "zh", "chy", "be", "wh", "cha", "kh", "bh", "che", "batch", "work", "c", "reach", "we", "bc", "ech", "fr", "ach", "Ch", "ot", "her", "p", "mot", "cd", "chain", "atch", "bt", "r", "ah", "ac", "chart", "count", "h", "och", "col", "z", "q", "sc", "y"], "run": ["bit", "index", "cr", "back", "role", "runs", "task", "val", "check", "load", "len", "rm", "loop", "rank", "end", "ur", "Run", "m", "line", "channel", "un", "length", "running", "only", "thread", "rc", "sw", "round", "n", "group", "ran", "try", "g", "ru", "job", "use", "db", "set", "pair", "con", "une", "cycle", "i", "rain", "form", "a", "record", "version", "head", "seq", "row", "call", "boot", "batch", "pass", "scan", "step", "work", "block", "c", "ro", "UN", "ach", "win", "process", "go", "play", "roll", "l", "dir", "rule", "chain", "model", "reg", "bin", "num", "r", "range", "runner", "ck", "render", "order", "z", "q", "su"], "case_val": ["case_res", "ase_val", "Case_state", "case_Val", "Case_VAL", "case_VAL", "force_vals", "force_val", " case_value", "ase_vol", "case_dev", "Case_value", "caseetyval", "cache_str", "case___vol", "caseetyv", "Case_item", " case_vals", "case_bal", "caseetyvol", "case_eval", "case_v", "case_vals", " case_eval", "cache_val", "case2val", "case_state", "caselyvals", "caseetystr", "Case_val", "Case_vals", " case_var", "ice_bal", "ice_vol", "Case_eval", "case___val", "caselyval", "case_item", "ase_dev", "case2vals", "case_str", "ase_eval", "case2value", "case_var", "caselystate", "force_VAL", "case_vol", "ice_res", "ase_vals", "force_Val", "case___res", "cache_vol", "ice_val", "Case_Val", "case___bal", "cache_v", "case_value"], "switchtable": ["witchable", "changetab", "SwitchTABLE", "switchTABLE", "jumptab", " switchable", "switchtab", "jumpTABLE", "SwitchTable", "witchtab", "switchTable", "witchtable", "changetable", " switchtab", "witchTable", "jumpTable", " switchTable", "changeable", "Switchtable", "changeTable", "Switchtab", "switchable", "jumptable", "changeTABLE"]}}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtdcrx(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],\n\n                         cpu_gpr[rS(ctx->opcode)]);\n\n    /* Note: Rc update flag set leads to undefined state of Rc0 */\n\n#endif\n\n}\n", "idx": 16207, "substitutes": {"ctx": ["conn", "cur", "hw", "cmp", "mk", "loc", "nt", "context", "kb", "cb", "xc", "abc", "today", "urg", "qt", "pkg", "tx", "kw", "ctl", "unc", "wx", "setup", "ind", "cmd", "crit", "kt", "xp", "wcs", "cfg", "obj", "aux", "self", "nc", "std", "cp", "gc", "ctrl", "tmp", "x", "ca", "txt", "history", "resp", "nw", "cf", "dl", "cc", "req", "bh", "xs", "batch", "cpu", "np", "ork", "gt", "work", "mom", "kl", "bc", "etc", "tm", "iat", "jac", "jp", "cu", "tc", "cm", "ct", "act", "desc", "cl", "prefix", "ck", "bp", "inst", "sc", "anc", "voc"]}}
{"project": "qemu", "commit_id": "e2f89926f19d2940eda070542501f39f51a8c81f", "target": 1, "func": "int usb_packet_map(USBPacket *p, QEMUSGList *sgl)\n\n{\n\n    int is_write = (p->pid == USB_TOKEN_IN);\n\n    target_phys_addr_t len;\n\n    void *mem;\n\n    int i;\n\n\n\n    for (i = 0; i < sgl->nsg; i++) {\n\n        len = sgl->sg[i].len;\n\n        mem = cpu_physical_memory_map(sgl->sg[i].base, &len,\n\n                                      is_write);\n\n        if (!mem) {\n\n            goto err;\n\n        }\n\n        qemu_iovec_add(&p->iov, mem, len);\n\n        if (len != sgl->sg[i].len) {\n\n            goto err;\n\n        }\n\n    }\n\n    return 0;\n\n\n\nerr:\n\n    usb_packet_unmap(p);\n\n    return -1;\n\n}\n", "idx": 16211, "substitutes": {"p": ["jp", "a", "f", "o", "pi", "pb", "j", "n", "vp", "pm", "v", "g", "pt", "t", "pp", "ping", "P", "m", "k", "r", "op", "s", "c", "sp", "lp", "fp", "ap", "wp", "cp", "b", "post", "h", "pc", "e", "u", "d", "q", "bp", "pkg", "tp", "pa", "pe", "ps"], "sgl": ["rsGL", "rsgn", "nsgl", "jsGl", "nsGL", " sbg", "rsigl", "esGL", " sbl", " sfl", "esGl", " sgn", "sbg", "nsfl", "rsly", " sGL", "sgn", "jsgn", "sGl", "sfl", "nsGl", "jsfl", "esgl", "nsly", "sbl", "sly", "timesbg", "sigl", "jsgl", " sGl", "esly", "jsigl", "rsbl", "timesfl", " sigl", "rsGl", "timesgl", "rsgl", "sGL", "nsbg"], "len": ["vec", "ln", "cmp", "lib", "val", "le", "loc", "den", "gl", "lang", "nt", "lit", "rev", " bl", "en", "limit", "length", "uf", "del", "fin", "lim", " length", "li", "nl", "lf", "ll", "data", "addr", "js", "lig", "syn", " tid", "lis", "pos", "comp", "hl", "elt", "coll", "mn", "full", "ref", "mi", "Len", "seq", "dl", "nz", "lon", "lp", " l", "kl", "err", " Len", "ld", "bytes", "il", "size", "l", "L", "el", "gen", " clen", "bin", "fl", "cap", "num", "ls", "wid", "count", "all", "base", "lt", "lan", "bl", "rel", "gz", "pl"], "mem": ["bytes", "rem", "med", "ptr", "ret", "phys", "go", "ref", "member", "mi", "ll", "data", "addr", "map", "iam", "ind", "reg", "t", "md", "rm", "buf", "msg", "buff", "em", "cpu", "m", "memory", " Mem", "buffer", "mm", "byte", "mn", "Mem", "met", "mat", "mp", "imm", "mt", "ram", "mb", "ame", "me", "err", "nm", "lim", "ms", "mx", "txt", "alloc"], "i": ["ij", "index", "key", "li", "at", "f", "o", "out", "iu", "oi", "ii", "mi", "I", "pi", " j", "l", "j", "ini", "n", "ind", "ex", "si", "ki", "zi", "series", "this", "v", "cli", "chain", "g", "gu", "bi", "t", "ui", "is", "di", "asi", " ii", "ai", "m", "ei", "in", "hi", "xi", "qi", "sim", "info", "im", "\u0438", "ci", "span", "print", "id", "ims", "ti", "e", "point", "ri", "it", "multi", "gi", "ji", "fi", "ma", "phi", "init", "x", "y", "ic", "ix", "ip"]}}
{"project": "qemu", "commit_id": "73d60fa5fae60c8e07e1f295d8c7fd5d04320160", "target": 1, "func": "static void get_sensor_evt_status(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(sens->reading);\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);\n\n}\n", "idx": 16216, "substitutes": {"ibs": ["iamjs", "ibjs", "ijjs", "IBs", "zbts", "mbs", "ebjs", "ijsol", "ibcs", "mbts", "IBjs", "ijfs", "ijs", "iams", "IBc", "ibsol", "ebc", "ibc", "zbs", "mbcs", "ebs", "ibfs", " ibsol", "mbfs", "iamc", "ibts", "IBfs", " ibfs", " ibts", "zbfs", " ibjs", "IBsol", " ibcs", "zbcs"], "cmd": ["def", "ctl", "exec", "patch", "good", "seq", "ctx", "grad", "crit", "cmp", "call", "cod", "req", "raw", "cd", "cli", "check", "batch", "ctr", "md", "nd", "comm", "iq", "msg", "command", "ext", "ct", "act", "desc", "cfg", "send", "op", "job", "control", "off", "cb", "Cmd", "bind", "cp", "ctrl", "args", "mt", "conf", "config", "force", "prop", "once", "pkg", "news", "forge", "rn", "cont", "pay"], "cmd_len": ["cmdseqlen", "Cmd_ls", "Cmd_min", "cmdseqmin", "cmd_length", "Cmd_length", "cmdseqls", "cmd_ls", "cmdseqlength", "cmd_min", "Cmd_len"], "rsp": ["rp", "rcp", "Rresp", "rss", "rSP", " rSP", "Rsp", " rpc", "rdpc", "rresp", "Rp", "rcss", "rcsp", "Rss", "Rps", " rresp", "RSP", "rpc", "rdresp", "rcps", "rdsp", " rps", " rp", "Rpc", "rdSP", "rps", " rss"], "rsp_len": ["rspPlimit", "rpt_limit", "rpt_gen", "rpt_len", "rspPln", "rsp_ln", "rspPlen", "rsp_limit", "rpt_ln", "rsp_gen", "rspPgen"], "max_rsp_len": ["max_rsp2Len", "max_rresp_gen", "max_rresp_length", "max_rsp2length", "max_rresp_len", "max_rsp_length", "max_rresp_Len", "max_rsp2len", "max_rsp_Len", "max_rsp2gen", "max_rsp_gen"], "sens": ["psens", "Sensor", "Sons", "seng", "psents", "tENS", "sen", "SENS", " sems", "Sens", "isensor", "cends", "sENS", " sent", "sensor", "asons", "Sess", "sess", "vans", "psensor", "peng", " sENS", "tens", "Sems", "isends", "tensor", "psess", "isENS", "vens", "sems", "asens", "Sen", "ten", " sensor", " sends", "pent", "pens", "Sents", "vent", "sents", "sends", "Sans", "asans", "censor", " sess", "sons", "tons", "pans", "tents", "pents", " sents", "tans", "cENS", "asENS", " sen", " sans", "vENS", "isens", "sans", "pENS", " seng", "Seng", "cens", "sent", "pems"]}}
{"project": "FFmpeg", "commit_id": "3e1507a9547ac09b6ff4372123cde09f19218f3d", "target": 0, "func": "void ff_mjpeg_encode_mb(MpegEncContext *s, int16_t block[12][64])\n\n{\n\n    int i;\n\n    if (s->chroma_format == CHROMA_444) {\n\n        encode_block(s, block[0], 0);\n\n        encode_block(s, block[2], 2);\n\n        encode_block(s, block[4], 4);\n\n        encode_block(s, block[8], 8);\n\n        encode_block(s, block[5], 5);\n\n        encode_block(s, block[9], 9);\n\n\n\n        if (16*s->mb_x+8 < s->width) {\n\n            encode_block(s, block[1], 1);\n\n            encode_block(s, block[3], 3);\n\n            encode_block(s, block[6], 6);\n\n            encode_block(s, block[10], 10);\n\n            encode_block(s, block[7], 7);\n\n            encode_block(s, block[11], 11);\n\n        }\n\n    } else {\n\n        for(i=0;i<5;i++) {\n\n            encode_block(s, block[i], i);\n\n        }\n\n        if (s->chroma_format == CHROMA_420) {\n\n            encode_block(s, block[5], 5);\n\n        } else {\n\n            encode_block(s, block[6], 6);\n\n            encode_block(s, block[5], 5);\n\n            encode_block(s, block[7], 7);\n\n        }\n\n    }\n\n}\n", "idx": 16227, "substitutes": {"s": ["sql", "ses", "aws", "gs", "a", "S", "sw", "as", "f", "bs", "less", "ties", "l", "j", "n", "js", "p", "ex", "sq", "g", "ms", "details", "t", "us", "comm", "is", "sb", "als", "sv", "spec", "hs", "sys", "ds", "ls", "ats", "m", "erences", "r", "ches", "ies", "qs", "ips", "ts", "c", "stats", "vs", "ins", "b", "ns", "cs", "h", "ims", "es", "e", "tes", "fs", "os", "bis", "its", "se", "ers", "sports", "ss", "sts", "w", "rs", "ps"], "block": ["node", "bit", "def", "view", "error", "type", "dict", "record", "number", "object", "header", "size", "data", "map", "back", "row", "pop", "window", "group", "pack", "clip", "user", "chain", "model", "load", "check", "batch", "box", "frame", "loop", "bin", "new", "cl", "lock", "tag", "line", "part", "panel", "blocks", "Block", "word", "obj", "snap", "step", "condition", "use", "buffer", "image", "event", "all", "byte", "link", "base", "no", "sync", "table", "bl", "post", "label", "set", "point", "list", "hash", "just", "side", "zero", "commit", "join", "filter", "name", "ip"], "i": ["index", " li", "cli", " pi", "ai", "m", " I", "iy", "qi", "xi", " v", "ims", "it", "us", "li", "oi", "ind", "j", "ki", "n", "si", "zi", " ti", "v", "try", "ui", "iq", " init", " k", " index", " bi", "ti", "x", "ri", "ic", "ix", "ip", "ij", "a", "mi", "ii", "I", "pi", " iter", "batch", "di", " ii", " mi", "in", "sim", "ci", " key", " ni", "iter", "multi", "me", " err", "status", "ni", "iu", " j", "ini", "ei", "p", "bi", "io", "is", "asi", "k", "hi", "\u0438", " multi", "e", "gi", " m", "phi", "init", "y"]}}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,\n\n                     int ret, int rw)\n\n{\n\n    int store = 0;\n\n\n\n    /* Update page flags */\n\n    if (!(*pte1p & 0x00000100)) {\n\n        /* Update accessed flag */\n\n        *pte1p |= 0x00000100;\n\n        store = 1;\n\n    }\n\n    if (!(*pte1p & 0x00000080)) {\n\n        if (rw == 1 && ret == 0) {\n\n            /* Update changed flag */\n\n            *pte1p |= 0x00000080;\n\n            store = 1;\n\n        } else {\n\n            /* Force page fault for first write access */\n\n            ctx->prot &= ~PAGE_WRITE;\n\n        }\n\n    }\n\n\n\n    return store;\n\n}\n", "idx": 16237, "substitutes": {"ctx": ["tx", "jp", "kw", "cf", "tc", "conn", "cm", "ca", "setup", "cmd", "p", "ok", "hw", "kt", "cmp", "cc", "tk", "cas", "ctr", "loc", "ct", "act", "nt", "context", "obj", "ck", "c", " cx", "xc", "ci", "ctrl", "cp", "mc", "ack", "bc", "Context", "tmp", "pkg", "sc", "anc", "iat", "jac"], "pte1p": ["pte4P", "pte3w", "pte127ap", "pte101pp", "pte60b", "ptea21wp", "ptoe1b", "ptea1p", "pte01w", "pte8p", "pte4ap", "ptec01w", "ptea1jp", "pte4r", "ptee1r", "ptoe1pr", "pte3b", "pte1r", "ptee4sp", "pte127p", "ptee1sp", "ptea101p", "pte3c", "pte0P", "pte8pc", "pte1wp", "ptea21jp", "ptec01p", "pte21wp", "pte0r", "ptoe3pr", "pte1cp", "pte01p", "pte30p", "pte30wp", "pte101ap", "pte1c", "ptoe3p", "ptoe3b", "pte8P", "pte127d", "pte60pc", "pte4pp", "ptee1P", "pte0sp", "pte8c", "pte4p", "pte4sp", "ptoe1p", "pte101pr", "ptea1pp", "pte101b", "pte30cp", "ptee4r", "pte60p", "pte101d", "ptec1w", "ptea101ap", "pte001cp", "pte1ap", "ptee4p", "pte4d", "pte1w", "pte8w", "pte1pr", "pte001wp", "ptec01c", "ptec1pc", "pte101p", "pte21cp", "pte8r", "pte001p", "ptea21cp", "pte3pr", "ptec1p", "ptee1p", "pte1sp", "ptea1d", "pte01pc", "pte1b", "pte001jp", "pte101pc", "pte60pr", "pte21p", "pte127pp", "ptoe3pc", "pte3pc", "ptee4P", "pte1jp", "pte30jp", "pte1pp", "ptec1c", "ptea101d", "pte8sp", "pte3p", "pte1pc", "ptea1ap", "pte1d", "ptea101pp", "ptea1cp", "pte01c", "ptea1wp", "ptec01pc", "pte1P", "pte0p", "ptoe1pc", "ptea21p", "pte21jp"], "ret": ["resp", "jp", "rc", "def", "nl", "des", "mem", "ref", "pert", "Ret", "rf", "reply", "rets", "RET", "reset", "reg", "read", "rm", "result", "nz", "nt", "r", "alt", "gt", "aux", "rt", "rev", "cb", "res", "lv", "re", "etc", "mt", "ft", "arg", "ne", "vt"], "rw": ["kw", "fw", "rew", "nw", "sw", "wx", "writ", "aw", "wb", "hw", "vr", "rl", "rf", "rr", "wa", "write", "rb", "nz", "wn", "ew", "writer", "iw", "rt", "dq", "ro", "rh", "wp", "wd", "wr", "rob", "urg", "rd", "nb", "mb", "RW", "rx", "w", "rn"]}}
{"project": "qemu", "commit_id": "5a2223ca26b1a34e131b5b9a63599d9426d2c25c", "target": 0, "func": "static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)\n\n{\n\n    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);\n\n}\n", "idx": 16246, "substitutes": {"s": ["status", "ses", "gs", "a", "S", "o", "p", "n", "sq", "v", "g", "sl", "t", "is", "sb", "sv", "hs", "ds", "ls", "m", "r", "so", "ts", "sp", "c", "sh", "ns", "b", "h", "fs", "q", "ss", "sts", "i", "rs", "ps"], "bsel": ["dsels", "psel", "pser", " bser", "bser", "bpsel", "bpser", " bibl", "bgsel", "psels", "bgzh", "bsels", "bvey", "bibl", "pibl", "dvey", "bpvey", "bpzh", "bgvey", "dsel", "bgsels", "bpibl", "dzh", " bsels", "bpsels", "bzh"], "slot": ["bit", "lot", "kh", " Slot", "seed", "seq", "kid", "spot", "timeout", "module", "window", "pot", "hold", "sl", "ots", "binding", "unit", "sec", "locked", "loop", "offset", "sector", "zone", "lock", "sid", "snap", "sp", "kl", "zo", "hot", "slice", "label", "serial", "set", "hole", "pad", "Slot", "shot", "usage", "tab", "pointer"]}}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,\n\n                                           stride, dst, stride, 16, 0);\n\n}\n", "idx": 16255, "substitutes": {"dst": ["edput", "edest", "Dst", " dnd", "pput", "sest", "dput", "ddest", "ssrc", "sst", "pst", " dsrc", "Ddest", "dnd", " ddest", "ednd", "Dsrc", "Dest", "edst", "dest", " dest", " dput", "sdest", "dsrc", "pnd", "pest"], "src": ["ipp", "rc", "gin", "cur", "RC", "rl", "sur", "sl", "ipl", "ctr", "source", "loc", "sb", "st", "sec", "sys", "np", "ur", "in", "r", "s", "rs", "rt", "dq", "dest", "sr", "img", "trans", "ins", "b", "input", "inner", "hl", "bg", "sn", "iv", "sc", "str", "txt"], "stride": ["slend", "strride", " strend", "stue", "Strack", "divide", "divid", "divrid", "Strime", " strack", "slid", "slride", "slide", "shride", "strrid", " strue", "strend", "divride", " strid", "Stride", "specack", " strime", "strack", "strime", "strice", "Strides", " strride", "shrade", "strue", "shrice", "strides", "specides", "strade", " strade", "slice", "divend", " strides", "specime", "stide", "divue", " strice", "strid", "slade", " strrid", "specide"]}}
{"project": "FFmpeg", "commit_id": "6221e2478c593a0ce1183eed929cb2101dbf5265", "target": 0, "func": "int av_parse_color(uint8_t *rgba_color, const char *color_string, int slen,\n\n                   void *log_ctx)\n\n{\n\n    char *tail, color_string2[128];\n\n    const ColorEntry *entry;\n\n    int len, hex_offset = 0;\n\n\n\n    if (color_string[0] == '#') {\n\n        hex_offset = 1;\n\n    } else if (!strncmp(color_string, \"0x\", 2))\n\n        hex_offset = 2;\n\n\n\n    if (slen < 0)\n\n        slen = strlen(color_string);\n\n    av_strlcpy(color_string2, color_string + hex_offset,\n\n               FFMIN(slen-hex_offset+1, sizeof(color_string2)));\n\n    if ((tail = strchr(color_string2, ALPHA_SEP)))\n\n        *tail++ = 0;\n\n    len = strlen(color_string2);\n\n    rgba_color[3] = 255;\n\n\n\n    if (!av_strcasecmp(color_string2, \"random\") || !av_strcasecmp(color_string2, \"bikeshed\")) {\n\n        int rgba = av_get_random_seed();\n\n        rgba_color[0] = rgba >> 24;\n\n        rgba_color[1] = rgba >> 16;\n\n        rgba_color[2] = rgba >> 8;\n\n        rgba_color[3] = rgba;\n\n    } else if (hex_offset ||\n\n               strspn(color_string2, \"0123456789ABCDEFabcdef\") == len) {\n\n        char *tail;\n\n        unsigned int rgba = strtoul(color_string2, &tail, 16);\n\n\n\n        if (*tail || (len != 6 && len != 8)) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Invalid 0xRRGGBB[AA] color string: '%s'\\n\", color_string2);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        if (len == 8) {\n\n            rgba_color[3] = rgba;\n\n            rgba >>= 8;\n\n        }\n\n        rgba_color[0] = rgba >> 16;\n\n        rgba_color[1] = rgba >> 8;\n\n        rgba_color[2] = rgba;\n\n    } else {\n\n        entry = bsearch(color_string2,\n\n                        color_table,\n\n                        FF_ARRAY_ELEMS(color_table),\n\n                        sizeof(ColorEntry),\n\n                        color_table_compare);\n\n        if (!entry) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Cannot find color '%s'\\n\", color_string2);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        memcpy(rgba_color, entry->rgb_color, 3);\n\n    }\n\n\n\n    if (tail) {\n\n        unsigned long int alpha;\n\n        const char *alpha_string = tail;\n\n        if (!strncmp(alpha_string, \"0x\", 2)) {\n\n            alpha = strtoul(alpha_string, &tail, 16);\n\n        } else {\n\n            alpha = 255 * strtod(alpha_string, &tail);\n\n        }\n\n\n\n        if (tail == alpha_string || *tail || alpha > 255) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Invalid alpha value specifier '%s' in '%s'\\n\",\n\n                   alpha_string, color_string);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        rgba_color[3] = alpha;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16256, "substitutes": {"rgba_color": ["rgbon_col", "rgpha_style", "rgba_class", "rgba___cache", "rgba1field", "rgba_initial", "rgba___match", "rgba1class", "rgba_pixel", "rgaa_col", "rgba_actor", "rgba______light", "rgbon_user", "rgba___pixel", "rgbaJvalue", "rgba___col", "rgba_cache", "rgaa00default", "rgba2user", "rgba_factor", "rgroma_display", "rgba00col", "rgbon_type", "rgbaJinitial", "rggb_col", "rgbon_or", "rgbon5match", "rgbaJstyle", "rgba32private", "rgba___color", "rgbon5color", "rgba2match", "rgpo_initial", "rgba_light", "rgroma_rect", "rgba5match", "rgaa00color", "rggb_value", "rgelta_color", "rgba_theme", "rgroma_private", "rgaa00private", "rgba___factor", "rggb2color", "rgba2type", "rgbon_light", "rgbaJpixel", "rgbon_channel", "rggb2value", "rgpha_total", "rgba______theme", "rgba00color", "rgpha_color", "rgba_rect", "rgpo_cache", "rgbon_color", "rgbon_actor", "rgba___colour", "rgpi_color", "rgba2col", "rgba_match", "rgba_style", "rgbaJcache", "rgba32color", "rgba32rect", "rgba5col", "rgba2channel", "rgpo_pixel", "rgba_value", "rgba00private", "rgba5type", "rgba2value", "rgba32display", "rgba1image", "rgroma32rect", "rgelta_type", "rgba1color", "rgelta_colour", "rgaa_color", "rgroma32display", "rgpo_color", "rgba_type", "rgpi_field", "rgpi_class", "rgba_channel", "rggb2col", "rggb_color", "rgba_total", "rgbaJtotal", "rgelta_factor", "rgroma_color", "rgpi_image", "rgba_private", "rgba_display", "rgba_or", "rgba___initial", "rgroma32private", "rgbon5col", "rgba2actor", "rgpha_value", "rgbon_theme", "rgba2color", "rgba______color", "rgba_colour", "rgaa_private", "rgba_field", "rgba5color", "rgba_col", "rgba_user", "rgaa_default", "rgba___type", "rgbon5type", "rgbaJcolor", "rgroma32color", "rgba00default", "rgaa00col", "rgba_default", "rgba_image", "rgbon_match", "rgba______or"], "color_string": [" color_list", "color_array", "feature_table", "original_table", "coloriptable", "originalitytable", "color5String", "coloritytable", "coloripiterator", "color__list", "color5string", "originalityiterator", "error_string", "erroriststring", " color_strings", "original_iterator", "coloripinstance", "feature_string", "coloritypair", "color__table", "colorityString", "erroristtype", "original_instance", "coloriststring", "coloristpair", " color_array", "color_String", "colorityinstance", "feature_byte", "colorityiterator", "coloritybyte", "coloristtype", "color_type", "originalitystring", "color_strings", "color__string", " color_table", "feature5byte", "feature5table", "color__strings", "color_byte", "feature5String", "feature_String", "erroristpair", "color_iterator", "coloripstring", "coloritystring", "color_pair", "originalityinstance", "error_type", "error_pair", "color_instance", "color_list", "color5byte", "color_table", "color5table", "original_string", "coloritytype", "feature5string"], "slen": ["SLens", "SLen", "plen", "islens", "selatten", "ssleng", "selade", "islenge", "klenge", "eleng", "shens", "islatten", "sloen", "shoen", "sslon", "islen", "SLatten", "elen", "slatten", "sslatten", "selen", "slon", "latten", "ploen", "SLeng", "sslens", "lade", "slens", "plon", "slenge", "slan", "shon", "sleng", "sslade", "klatten", "plens", "elan", "shen", "ssloen", "klen", "klens", "sslan", "sllen", "ssllen", "SLan", "sslen", "elatten", "llen", "slade", "SLenge", "sellen"], "log_ctx": ["Log_tx", "logpttx", "log_tx", "log_obj", "log2obj", "log2ctx", "og_obj", "Log_context", "og_context", "logptcontext", "og_ctx", "og_tx", "Log_ctx", "log_context", "logptreq", "logptctx", "Log_req", "log_req", "log2tx", "log2context"], "tail": ["il", "index", "wind", "scroll", "ll", "ptr", "latest", "head", "seed", "lift", "foot", "pillar", "body", "size", "tt", "timeout", "lig", "temp", "depth", "leaf", "tailed", "ail", "chain", "origin", "loop", "end", "wit", "offset", "align", "pipe", "lock", "tag", "lead", "shell", "alt", "gt", "gate", "get", "condition", "tails", "last", "tle", "prefix", "neck", "buffer", "base", "pull", "limit", "link", "lt", "ul", "fat", "table", "slice", "term", "iter", "tip", "length", "ignore", "style", "detail", "lo", "zero", "sum"], "color_string2": ["color_format2", "color_comment2", "coloritystring3", "color_sequence2", "color_Stringed", "coloritynumber0", "color_string12", "color_ring1", "color_table2", "color_pair\t", "color___string\t", "color_component32", "color_sequence0", "color_String2", "color_component0", "color_word22", "color_array0", "color_component2", "color_word2", "colorationstring1", "color_name22", "color___string02", "color_name3", "color_tableed", "color_text2", "color_pair2", "color_ring3", "color_strings3", "coloritynumber2", "color_request02", "color_stringed", "colorationtable1", "color___string2", "color_String0", "colorationtableed", "color_list1", "color_dataed", "color_array1", "color_comment02", "color_list0", "color_table1", "color_strings1", "color_file1", "color_String1", "color_file2", "colorationstring2", "color_text12", "color_array32", "color_sequence3", "color___pair\t", "coloritynumber32", "color_request2", "coloritystring1", "color_array2", "color_String3", "color_word3", "color_list2", "colorationtable2", "color_text1", "color_strings2", "color_name0", "color_number2", "color_sequence1", "color_string32", "color_number32", "color_word0", "color___pair2", "coloritysequence2", "color_name2", "coloritystring2", "color_data2", "color_buffer2", "color_string22", "coloritysequence3", "color_pair02", "color_data1", "color_ring2", "color_comment\t", "color_format3", "color_string0", "colorationstringed", "color_string02", "color_request\t", "coloritystring32", "color_buffer3", "coloritysequence1", "color_string3", "color_array3", "color_string1", "coloritystring0", "color___pair02", "color_file12", "color_number0"], "entry": ["index", "instance", "key", "error", "record", "insert", "member", "inter", "search", "data", "row", "or", "ent", "rance", "result", "cell", "r", "line", "ie", "obj", "ient", "comment", "match", "info", "RY", "link", "look", "import", "ry", "table", "ries", "Entry", "tmp", "ace", "see", "list", "enter", "ary", "cue"], "len": ["il", "li", "nl", "ell", "vec", "mem", "lf", "Len", "ll", "l", "fin", "size", "n", "ln", "fun", "cmp", "lib", "seq", "L", "compl", "val", "ail", "sl", "el", "t", "loc", "end", "fl", "mil", "ls", "nt", "lit", "alt", "full", "lon", "sp", "count", "lp", "pos", "en", "fn", "limit", "all", "lan", "lt", "h", "e", "iter", "length", "elt", "z", "pl", "lim", "str"]}}
{"project": "qemu", "commit_id": "22d5cd82e98b61b1dbd791fab9f4ae0f77c0ed14", "target": 0, "func": "static int raw_inactivate(BlockDriverState *bs)\n\n{\n\n    int ret;\n\n    uint64_t perm = 0;\n\n    uint64_t shared = BLK_PERM_ALL;\n\n\n\n    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);\n\n    return 0;\n\n}\n", "idx": 16274, "substitutes": {"bs": ["irms", "ubs", "aos", "obs", "hz", "js", "bits", "bh", "bes", "sb", "aus", "cks", "ds", "ls", "iss", "asis", "acs", "BS", "bsp", "ts", "bos", "bm", "bas", "blog", "vs", "b", "ns", "cs", "bc", "lbs", "bles", "fs", "ks", "bps", "bis", "bing", "its", "bb", "bp", "ss", "ms", "rs"], "ret": ["resp", "status", "rem", "def", "leg", "out", "ref", " alt", "pret", "det", "ll", "bool", "back", "j", "Ret", "tr", "rets", "RET", "val", "v", "reset", "deg", "try", "reg", "t", "len", "rm", "result", "end", "nz", "nt", "lit", "r", "alt", "gt", "rt", "rev", "code", "ry", "res", "print", "re", "mt", "cont", "ft", "state", "it", "elt", " Ret", "ter", " fut", "txt"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,\n\n                                Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qobject_incref(*obj);\n\n    qmp_output_add_obj(qov, name, *obj);\n\n}\n", "idx": 16276, "substitutes": {"v": ["nv", "f", "o", "ver", "tv", "V", "l", "j", "p", "n", "or", "vr", "vp", "vi", "conv", "g", "vis", "sv", "k", "m", "r", "vm", "c", "inv", "cv", "ov", "b", "vim", "h", "verb", "u", "qv", "d", "uv", "q", "vc", "vt", "ev", "w", "i", "av", "y"], "name": ["key", "def", "path", "type", "f", "local", "attr", "data", "j", "n", "p", "par", "nam", "names", "val", "t", "cap", "new", "m", "word", "Name", "prefix", "info", "c", "code", "no", "ns", "id", "named", "label", " Name", "order", "var", "ame", "ma", "init", "w", "nm", "NAME", "str"], "obj": ["node", "resp", "inst", "conn", "obs", "o", "ref", "out", "src", "object", "attr", "data", "addr", "j", "ctx", "expr", "js", "seq", "cmp", "utt", "hw", "proc", "cmd", "opt", "adj", "Obj", "buf", "sys", "func", "act", "nt", "alt", "off", "oj", "pos", "po", "ns", "tmp", "elt", "err", "str", "txt", "ob", "arr"], "errp": ["rP", "rpp", "errr", "lrr", "lrpp", "rp", "erP", "lrp", "err", "erp", "erpp", "lrP", "errpp", "rr", "errP"], "qov": ["mnov", "mova", " qrov", "qnov", "dqOV", "dqog", "qOV", " qnov", " qOV", "sqov", "sqova", "sqnov", " sqrov", "qovi", "sqovi", "qrov", "dqov", " sqov", " qovi", "dqrov", "qova", " sqog", " qog", "movi", "mov", " sqOV", "qog", " qova"]}}
{"project": "qemu", "commit_id": "41ecc72ba5932381208e151bf2d2149a0342beff", "target": 0, "func": "static int setup_sigcontext(struct target_sigcontext *sc,\n\n                            CPUSH4State *regs, unsigned long mask)\n\n{\n\n    int err = 0;\n\n    int i;\n\n\n\n#define COPY(x)         __put_user(regs->x, &sc->sc_##x)\n\n    COPY(gregs[0]); COPY(gregs[1]);\n\n    COPY(gregs[2]); COPY(gregs[3]);\n\n    COPY(gregs[4]); COPY(gregs[5]);\n\n    COPY(gregs[6]); COPY(gregs[7]);\n\n    COPY(gregs[8]); COPY(gregs[9]);\n\n    COPY(gregs[10]); COPY(gregs[11]);\n\n    COPY(gregs[12]); COPY(gregs[13]);\n\n    COPY(gregs[14]); COPY(gregs[15]);\n\n    COPY(gbr); COPY(mach);\n\n    COPY(macl); COPY(pr);\n\n    COPY(sr); COPY(pc);\n\n#undef COPY\n\n\n\n    for (i=0; i<16; i++) {\n\n        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);\n\n    }\n\n    __put_user(regs->fpscr, &sc->sc_fpscr);\n\n    __put_user(regs->fpul, &sc->sc_fpul);\n\n\n\n    /* non-iBCS2 extensions.. */\n\n    __put_user(mask, &sc->oldmask);\n\n\n\n    return err;\n\n}\n", "idx": 16281, "substitutes": {"sc": ["isc", "rc", "craft", "ctl", "cr", "SC", "tc", "lc", "pb", "scope", "ctx", "cc", "sq", "psc", "capt", "comm", "esc", "sec", "dc", "sch", "scan", "usc", "cam", "desc", "cl", "irc", "c", "cv", "disc", "Sc", "ec", "sche", "sh", "sync", "gc", "mc", "cs", "bc", "osc", "pc", "set", "sic", "scl", "ss", "arc", "exec", "asc", "ch", "sci"], "regs": ["rogains", "privs", "gregs", "rogls", "Reges", "reges", "regains", "gregords", "registerS", "privords", "ggs", "roggs", "registerls", "gregls", "privgs", "gregts", "regions", "regts", "greggs", "rogS", "roges", "rogs", "regls", "reggs", "gregions", "registerts", "privions", "regords", "regS", "registers", "Regts", "rogts", "rogions", "gggs", "Reggs", "rogords", "gregS", "Regs", "gregains", "ggains", "greges"], "mask": ["bit", "key", "map", "flags", " Mask", "cmp", "tr", "pack", "gray", "check", "batch", "cache", "scan", "m", "lock", "tag", "gate", "hide", "ask", "mark", "Mask", "black", "match", "ck", "code", " masked", "gc", "flag", "scale", "mc", "label", "mt", "clear", "mod", "mb", "ma", "z", "zero", "sign", "ms", "ch", "sum", "sk"], "i": ["status", "ij", "index", "li", "f", "go", "iu", "out", "o", "oi", "mi", " j", "I", "pi", "ii", "ini", "j", "ei", "n", "p", "ind", "dr", "si", "ex", "zi", "ki", "v", "cli", "g", "gu", "bi", "batch", "t", "ui", "is", "di", "ami", " ii", "ai", "m", "in", "r", "hi", "xi", "qi", " bi", "sim", "\u0438", "c", "ci", " v", "b", "id", "ti", "ri", "u", " x", "e", "multi", "gi", "it", "ji", "me", "z", "phi", " err", "x", "y", "ix", "ip"]}}
{"project": "qemu", "commit_id": "7c4228b4771acddcb8815079bc116007cec8a1ff", "target": 1, "func": "static void vfio_unmap_bar(VFIODevice *vdev, int nr)\n\n{\n\n    VFIOBAR *bar = &vdev->bars[nr];\n\n\n\n    if (!bar->size) {\n\n        return;\n\n    }\n\n\n\n    vfio_bar_quirk_teardown(vdev, nr);\n\n\n\n    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);\n\n    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));\n\n\n\n\n    if (vdev->msix && vdev->msix->table_bar == nr) {\n\n        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);\n\n        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));\n\n\n    }\n\n\n\n    memory_region_destroy(&bar->mem);\n\n}", "idx": 16293, "substitutes": {"vdev": ["vserial", "evdef", "henv", " vev", "svdev", "avpay", "vgo", " vdevice", "svenv", "avinfo", "mserver", "vstream", "Vver", "avgen", "uvstream", "vbuf", "evswitch", "vcpay", "vdevice", "hDEV", " vserial", "avpad", "uvsys", "svctx", "vctx", "vDEV", " vinfo", " vstream", "svserial", "uvver", "avsys", "vcdev", " vpad", "vdes", "vpay", "vcinfo", " vdef", "avdev", "uvdev", "avgo", " vgo", "vev", "hctx", "vsys", "mdev", " vDEV", "avdes", "vgen", "svstream", "vcswitch", "vpad", "hdev", "svgo", "vcdes", "avserial", "avver", "venv", "svDEV", "Vsys", "uvgen", " vbuf", " vpay", " venv", "vcbuf", "svserver", " vswitch", "svpad", "svaddr", "hdevice", "evbuf", "uvaddr", "Vgen", "vcdef", "Vdev", "hev", " vctx", "mserial", "mdevice", "vswitch", "vdef", "svdevice", "vver", "vserver", " vaddr", "evdev", " vdes", " vserver", "svev", "vaddr", "uvDEV", "vinfo"], "nr": ["cor", "ij", "nv", "nw", "square", "nor", " sidx", "number", "inter", "usr", "attr", "NH", "addr", "n", "mr", "radius", "byter", " nib", " number", "eno", "next", "ng", "adr", "ctr", " numb", "uj", "np", "tn", "nz", "num", "br", "r", "Ni", "arity", "kr", "our", "cb", "ter", "NPR", "nc", "gr", "no", "coord", " NR", "NR", " neighbor", " ni", "ti", "nb", "sn", " nm", "nm", "nick", "rr", "nom", "gov", "nn"], "bar": ["cor", "aaa", "rage", "cart", "gb", "bars", "cb", "arge", "star", "car", "coord", "docker", "tick", "camp", "foo", "trace", "Bar", "percent", "usr", "arr", "mem", "ax", "ar", "job", "br", "bench", "menu", "hello", " bars", "report", " ab", "area", "pair", " buck", "arg", "mb", "ca", "tab", "az", "hub", "row", "batch", " barg", "grab", "buf", "comb", "rest", "bot", "broad", "hat", "block", "ram", "bor", "cast", "request", " foo", "good", "bug", "aw", "pb", "hist", "builder", "bart", "item", "cam", "bag", "track", "bridge", "b", "bury", "bill", "var", "gob", "prop", "pas", "watch", "worker"]}}
{"project": "qemu", "commit_id": "babfa20ca4721e950d8096f32b1dc091763a8837", "target": 0, "func": "static bool ept_emulation_fault(uint64_t ept_qual)\n\n{\n\n    int read, write;\n\n\n\n    /* EPT fault on an instruction fetch doesn't make sense here */\n\n    if (ept_qual & EPT_VIOLATION_INST_FETCH) {\n\n        return false;\n\n    }\n\n\n\n    /* EPT fault must be a read fault or a write fault */\n\n    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;\n\n    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;\n\n    if ((read | write) == 0) {\n\n        return false;\n\n    }\n\n\n\n    /*\n\n     * The EPT violation must have been caused by accessing a\n\n     * guest-physical address that is a translation of a guest-linear\n\n     * address.\n\n     */\n\n    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||\n\n        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 16318, "substitutes": {"ept_qual": [" et_quality", "techn_quality", "techn9pac", "vant_requ", "apt_har", "apt_requ", "apt_quant", "ept_requ", "apt_qual", "ept5quality", "techn_qual", " et_quant", "ept9qual", "ept___har", "vant_quality", "ept5pac", "ept_val", "ept_cmd", "ept5val", "vant_cmd", " et_qual", "ept_quant", "techn9quality", "vant_qual", "ept_specific", "vant_compl", " et_compl", "ept___qual", "pent_qual", "ept_pol", "techn_pac", "ept9quality", "techn_val", "techn9qual", "techn9val", "ept___quant", "ept_compl", "ept9pac", "pent_quick", "ept_quick", "ept___requ", "ept5qual", "pent_compl", "pent_pol", "ept_pac", "ept_quality", "vant_specific", "ept_har", "ept9val"], "read": ["index", "error", "out", "roll", "size", "data", "ind", "address", "ok", "hold", " Read", "check", "load", "access", "readable", "len", "before", "rate", "end", "show", "select", "in", "get", "r", "READ", "info", "reader", "open", "find", "run", "count", "ro", "print", "start", "Read", "id", "input", "set", "from", "length", "reading", "reads", "i", "x", "only", "ip"], "write": ["wait", "index", "scroll", "mem", "output", "out", "handle", "writ", "move", "Write", "rite", "edit", "data", "leave", "put", "vert", "check", "port", "wrote", "store", "close", "end", "enable", "cut", "send", "flow", "update", "writer", "use", "change", "create", "written", "wr", "draw", "set", "seek", "see", "w", "save", "force"]}}
{"project": "FFmpeg", "commit_id": "7cf22c79706d23d40d16cee37eb32d5797adcc2c", "target": 0, "func": "yuv2rgba64_full_X_c_template(SwsContext *c, const int16_t *lumFilter,\n\n                       const int32_t **lumSrc, int lumFilterSize,\n\n                       const int16_t *chrFilter, const int32_t **chrUSrc,\n\n                       const int32_t **chrVSrc, int chrFilterSize,\n\n                       const int32_t **alpSrc, uint16_t *dest, int dstW,\n\n                       int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)\n\n{\n\n    int i;\n\n    int A = 0xffff<<14;\n\n\n\n    for (i = 0; i < dstW; i++) {\n\n        int j;\n\n        int Y  = -0x40000000;\n\n        int U  = -128 << 23; // 19\n\n        int V  = -128 << 23;\n\n        int R, G, B;\n\n\n\n        for (j = 0; j < lumFilterSize; j++) {\n\n            Y += lumSrc[j][i]  * (unsigned)lumFilter[j];\n\n        }\n\n        for (j = 0; j < chrFilterSize; j++) {;\n\n            U += chrUSrc[j][i] * (unsigned)chrFilter[j];\n\n            V += chrVSrc[j][i] * (unsigned)chrFilter[j];\n\n        }\n\n\n\n        if (hasAlpha) {\n\n            A = -0x40000000;\n\n            for (j = 0; j < lumFilterSize; j++) {\n\n                A += alpSrc[j][i] * (unsigned)lumFilter[j];\n\n            }\n\n            A >>= 1;\n\n            A += 0x20002000;\n\n        }\n\n\n\n        // 8bit: 12+15=27; 16-bit: 12+19=31\n\n        Y  >>= 14; // 10\n\n        Y += 0x10000;\n\n        U  >>= 14;\n\n        V  >>= 14;\n\n\n\n        // 8bit: 27 -> 17bit, 16bit: 31 - 14 = 17bit\n\n        Y -= c->yuv2rgb_y_offset;\n\n        Y *= c->yuv2rgb_y_coeff;\n\n        Y += 1 << 13; // 21\n\n        // 8bit: 17 + 13bit = 30bit, 16bit: 17 + 13bit = 30bit\n\n\n\n        R = V * c->yuv2rgb_v2r_coeff;\n\n        G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n        B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n        // 8bit: 30 - 22 = 8bit, 16bit: 30bit - 14 = 16bit\n\n        output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);\n\n        output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);\n\n        output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);\n\n        if (eightbytes) {\n\n            output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);\n\n            dest += 4;\n\n        } else {\n\n            dest += 3;\n\n        }\n\n    }\n\n}\n", "idx": 16335, "substitutes": {"i": ["ij", "index", "li", "a", "by", "f", "iu", "mi", "ini", "I", "pi", "ii", "l", "ind", "n", "p", "ki", "si", "ex", "zi", "name", "v", "g", "bi", "io", "t", "ui", "ia", "ik", "di", "is", "ami", "ai", "m", "ei", "in", "ie", "hi", "qi", "xi", "sim", "info", "im", "c", "sp", "ci", "b", "h", "id", "e", "ti", "ri", "multi", "it", "gi", "ji", "me", "z", "q", "phi", "x", "y", "ic", "ix", "ip"], "j": ["other", "bj", "ng", "t", "m", "att", "it", "ji", "Ja", "by", "jet", "ind", "pr", "n", "js", "tr", "kid", "v", "g", "try", "next", "note", "job", "br", "obj", "jo", "ijk", "ion", "je", "jack", "x", "mn", "ix", "ij", "a", "at", "out", "kh", "aj", "uj", "bo", "er", "bot", "ie", "json", "ja", "J", "jump", "fr", "jc", "state", "d", "kj", "ev", "str", "gh", "ju", "jac", "jp", "o", "jit", "l", "p", "el", "pt", "k", "r", "ah", "off", "dj", "oj", "jj", "b", "jl", "z", "q", "name", "adj"], "R": ["BR", "S", "CR", "RB", "I", "V", "RG", "GR", "MR", "RA", "D", "Y", "X", "L", "A", "F", "DR", "E", "P", "N", "r", "T", "C", "RT", "W", "H", "M", "HR", "U", "RO", "RR", "Q", "RGB", "TR"], "G": ["GG", "GE", "GT", "GB", "V", "GR", "RG", "I", "D", "Y", "F", "L", "Gs", "A", "g", "Gr", "GP", "E", "P", "N", "GH", "GA", "C", "Ge", "J", "W", "H", "GD", "GI", "M", "GV", "BG", "U", "Q"], "B": ["Bi", "BB", "BR", "NB", "GB", "V", "DB", "I", "AB", "D", "Y", "L", "A", "BU", "BA", "E", "P", "BC", "T", "C", "BO", "J", "b", "W", "IB", "Both", "WB", "M", "BF", "BG", "U", "BM", "BL", "Q", "BY", "BT"]}}
