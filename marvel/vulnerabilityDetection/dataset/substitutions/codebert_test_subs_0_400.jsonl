{"project": "FFmpeg", "commit_id": "32bf6550cb9cc9f487a6722fe2bfc272a93c1065", "target": 0, "func": "int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,\n\n                      AVCodecContext *codec, int size, int big_endian)\n\n{\n\n    int id;\n\n    uint64_t bitrate;\n\n\n\n    if (size < 14) {\n\n        avpriv_request_sample(codec, \"wav header size < 14\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    codec->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    if (!big_endian) {\n\n        id                 = avio_rl16(pb);\n\n        if (id != 0x0165) {\n\n            codec->channels    = avio_rl16(pb);\n\n            codec->sample_rate = avio_rl32(pb);\n\n            bitrate            = avio_rl32(pb) * 8LL;\n\n            codec->block_align = avio_rl16(pb);\n\n        }\n\n    } else {\n\n        id                 = avio_rb16(pb);\n\n        codec->channels    = avio_rb16(pb);\n\n        codec->sample_rate = avio_rb32(pb);\n\n        bitrate            = avio_rb32(pb) * 8LL;\n\n        codec->block_align = avio_rb16(pb);\n\n    }\n\n    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */\n\n        codec->bits_per_coded_sample = 8;\n\n    } else {\n\n        if (!big_endian) {\n\n            codec->bits_per_coded_sample = avio_rl16(pb);\n\n        } else {\n\n            codec->bits_per_coded_sample = avio_rb16(pb);\n\n        }\n\n    }\n\n    if (id == 0xFFFE) {\n\n        codec->codec_tag = 0;\n\n    } else {\n\n        codec->codec_tag = id;\n\n        codec->codec_id  = ff_wav_codec_get_id(id,\n\n                                               codec->bits_per_coded_sample);\n\n    }\n\n    if (size >= 18 && id != 0x0165) {  /* We're obviously dealing with WAVEFORMATEX */\n\n        int cbSize = avio_rl16(pb); /* cbSize */\n\n        if (big_endian) {\n\n            avpriv_report_missing_feature(codec, \"WAVEFORMATEX support for RIFX files\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        size  -= 18;\n\n        cbSize = FFMIN(size, cbSize);\n\n        if (cbSize >= 22 && id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */\n\n            parse_waveformatex(pb, codec);\n\n            cbSize -= 22;\n\n            size   -= 22;\n\n        }\n\n        if (cbSize > 0) {\n\n            av_freep(&codec->extradata);\n\n            if (ff_get_extradata(codec, pb, cbSize) < 0)\n\n                return AVERROR(ENOMEM);\n\n            size -= cbSize;\n\n        }\n\n\n\n        /* It is possible for the chunk to contain garbage at the end */\n\n        if (size > 0)\n\n            avio_skip(pb, size);\n\n    } else if (id == 0x0165 && size >= 32) {\n\n        int nb_streams, i;\n\n\n\n        size -= 4;\n\n        av_freep(&codec->extradata);\n\n        if (ff_get_extradata(codec, pb, size) < 0)\n\n            return AVERROR(ENOMEM);\n\n        nb_streams         = AV_RL16(codec->extradata + 4);\n\n        codec->sample_rate = AV_RL32(codec->extradata + 12);\n\n        codec->channels    = 0;\n\n        bitrate            = 0;\n\n        if (size < 8 + nb_streams * 20)\n\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < nb_streams; i++)\n\n            codec->channels += codec->extradata[8 + i * 20 + 17];\n\n    }\n\n\n\n    if (bitrate > INT_MAX) {\n\n        if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The bitrate %\"PRIu64\" is too large.\\n\",\n\n                    bitrate);\n\n            return AVERROR_INVALIDDATA;\n\n        } else {\n\n            av_log(s, AV_LOG_WARNING,\n\n                   \"The bitrate %\"PRIu64\" is too large, resetting to 0.\",\n\n                   bitrate);\n\n            codec->bit_rate = 0;\n\n        }\n\n    } else {\n\n        codec->bit_rate = bitrate;\n\n    }\n\n\n\n    if (codec->sample_rate <= 0) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Invalid sample rate: %d\\n\", codec->sample_rate);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {\n\n        /* Channels and sample_rate values are those prior to applying SBR\n\n         * and/or PS. */\n\n        codec->channels    = 0;\n\n        codec->sample_rate = 0;\n\n    }\n\n    /* override bits_per_coded_sample for G.726 */\n\n    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)\n\n        codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate;\n\n\n\n    return 0;\n\n}\n", "idx": 3, "substitutes": {"s": ["fs", "r", "sv", "sc", "setup", "settings", "cs", "ssl", "o", "m", "sq", "w", "v", "g", "ps", "spec", "ses", "c", "sf", "parser", "t", "b", "f", "aws", "ss", "e", "ops"], "pb": ["bf", "rb", "lp", "tp", "pkg", "loc", "mp", "bp", "cpp", "prot", "xb", "ctx", "fc", "pm", "types", "um", "pl", "lib", "fp", "p", "pd", "phrase", "http", "bps", "pid", "typ", "api", "wp", "plug", "fb", "ppa", "bot", "platform", "cp", "pc", "eb", "txt", "hub", "sb", "np", "bh", "plugin", "jp", "vp", "cb", "db", "hp", "lab", "pa", "b", "dp", "wb", "summary", "rob", "bc", "lb", "lc", "PB", "pg"], "codec": [" coderc", "odac", "Coderc", "codek", "crossenc", "labesc", "defec", "codeek", "codeEC", "labEC", "copec", "cheic", " coddec", "codex", "coddec", "codbec", "codeucc", "cucc", " coduc", " coducc", "oddec", "lowac", "anterc", "odect", "cheex", "genesc", " codenc", "preduc", "genex", "defbc", "condect", "copenc", "oduc", " codbc", " codek", "cEC", "antek", "predac", "codeeco", "pedect", "antea", "predfc", "coduc", "challec", "codea", "antec", "predec", "codeef", "condic", "labex", "odex", "lowec", "codeco", "codesc", "pedef", "codenc", "challerc", " codrec", "coderc", "codeec", "pedec", "odenc", "crossac", " codesc", "crossek", "Codek", "codeac", " codEC", "cheect", "chedec", "odef", "cheec", "odesc", "cheEC", " codef", "codeex", "lowenc", "pedenc", "codeesc", "Codea", "codeuc", "coderec", "codEC", " codfc", "condec", "Codef", "odek", "cheenc", "predrec", "predenc", "labuc", " codbec", "Codbc", "challea", "predeco", "CodEC", "predex", "cex", " codect", " codic", "defEC", "codac", "cheuc", "codeenc", "defef", "codbc", "odbec", "genec", "loweco", " codex", "codebec", "condenc", "antEC", "labec", "codfc", "crossec", "predEC", "genuc", "labdec", "labrec", "cherec", "codefc", "coducc", "codef", "cec", "odec", "codect", "codrec", "challEC", "codic", "Codec", "odrec", "copuc", "codedec", "copef"], "size": ["offset", "zip", "ui", "six", "loc", "scale", "SIZE", "sync", "code", "unit", "n", "sec", "term", "se", "name", "sum", "fee", "sn", "time", "capacity", "len", "data", "video", "length", "ize", "shape", "complete", "body", "np", "speed", "small", "style", "large", "max", "storage", "address", "e", "timeout", "empty", "second", "sized", "Size"], "big_endian": ["big_endsrian", "big_indien", "big_ENDians", "big_endsarian", "big_endedian", "big_ENDian", "big_endiet", "big_endsien", "big_endrian", "big_endedrian", "big_endedien", "big_endedians", "big_endsiet", "big_endican", "big_ENDican", "big_endediet", "big_endsian", "big_ENDIAN", "big_endien", "big_endedIAN", "big_endarian", "big_indian", "big_endsican", "big_endsians", "big_endians", "big_indians", "big_endIAN", "big_indarian", "big_endsIAN"], "id": ["did", "create", " fid", "num", " ID", "lang", "key", "d", "head", "feat", "Id", "parent", "aid", "plugin", "info", "image", "rid", "gap", "f", "this", "uid", "bit", "ui", "ID", "error", "p", "ids", "pid", "name", "time", "ad", "format", "data", "kid", "mid", "url", "side", "it", "h", "zip", "ident", "gen", "vid", "code", "sid", "act", "pad", "str", "shape", "oid", "ip", "path", "source", "value", "bug", "def", "root", "api", "end", "type", "in", "ide", "start", "like", "db", "none", "kill", "bid", "link"], "bitrate": ["blockrates", " bitrates", "bitscale", "Bitrate", "bitrates", "brate", "bscale", "laturrency", " bittime", "bandrates", "blockurrency", "latspeed", "biturrency", "blocktime", "bitspeed", "blockrate", "Bitscale", "Bitrates", " bitspeed", " bitscale", "latrate", "bittime", "bandtime", "blockspeed", "latrates", " biturrency", "brates", "bandrate"]}}
{"project": "qemu", "commit_id": "c0c24b95542bc1a4dc3fc6ea71475ae04fa69189", "target": 1, "func": "static int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n\n            goto out;\n\n        }\n\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n\n            goto out;\n\n        }\n\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}", "idx": 12, "substitutes": {"xendev": ["xendep", "xentown", "xendedown", "exndev", "lexendell", "yendeddev", "xndell", "yendederv", "exendedek", "xstartiv", "xendedream", "lexENDee", "pendov", "pendef", "xenep", " xendingown", " xendee", "crossenderv", "xendingef", "yendep", "lexendee", "xendedep", "xaddee", "exndown", "xendown", " xendown", "exendedef", " xendingee", "yendev", " xendingev", "exnddev", "xENDev", "xentove", "xendedov", "xendov", "xnderv", "xnddev", "yenderv", "lexenddev", "xENDerv", "xendec", "lexendev", "exendev", "xendoy", "xendove", "xaddom", "xenev", "pendove", "pendedove", "xaddev", "xendingee", "xstartdev", "xentev", "lexENDell", "pendev", "exendom", "exendedom", "xendingoy", "crossendingerv", "xendingev", "crossendev", "xndee", "exenderv", "xstartev", "pendedev", "xestom", "lexENDev", "xendef", "exendown", "xendek", "exendream", "xendell", "xENDown", "xestek", "xENDee", " xendoy", "xendedee", "xstartec", "exnderv", "xendeddev", "yendedep", "exendee", "xendee", "xendingown", "xendingec", "pendedov", "xendediv", "xendederv", "xendom", "xendingream", "xendedev", "crossendingiv", "xendingiv", "xndev", "lexENDdev", "xestev", "xendingove", "pendedef", "xndep", "xenddev", "xendedek", "xentee", "xENDell", "xENDdev", "xestee", "xendedef", "exendedream", "xendiv", "xentef", "yenddev", "exenddev", "crossendingec", "xandev", "xendedec", "xendingov", "xandee", "xendream", "xentoy", "exendedee", "exendedev", "xenderv", "xendedove", "xstarterv", "crossendingev", "xendingerv", "exendek", " xendingoy", "yendedev", "xstartell", "xandef", "crossendiv", "xenerv", "xendedoy", "xandream", "xentov", "xendedom", "crossendec", "xaddek", "exendef", "xndown", "xstartee"], "i": ["part", "uri", "d", "mi", "isin", "z", "ri", "count", "v", "bi", "reply", "iu", "ie", "ji", "ix", "info", "pi", "ti", "iv", "phi", "ui", "l", "si", "y", "o", "p", "ci", "qi", "eni", "I", "li", "init", "mu", "b", "u", "xi", "it", "lc", "io", "fi", "multi", "m", "interface", "ij", "ini", "slice", "uli", "g", "zi", "ai", "t", "ip", "e", "yi", "index", "isi", "source", "j", "n", "cli", "id", "api", "ii", "a", "c", "in", "di", "abi", "\u0438", "gui", "gi", "ni", "x", "inner"], "xen_9pdev": ["xen_9lpdevice", "xen_9cde", "xen_9fgu", "xen_109pcache", "xen_9p3", "xen_9cdi", "xen_09cdevice", "xen_8pdiv", "xen_9tev", "xen_8dconf", "xen_9ldev", "xen_9ldef", "xen_9prad", "xen_9appconf", "xen_09pdevice", "xen_9pcprof", "xen_9pddef", "xen_09fev", "xen_9pev", "xen_9qde", "xen_10pcdevices", "xen_9lpdem", "xen_9ddem", "xen_nineptr", "xen_30pahome", "xen_9derror", "xen_16prad", "xen_9erdevices", "xen_9cpdef", "xen_9tdev", "xen_9pde", "xen_09psec", "xen_29pcprof", "xen_8ddef", "xen_ninepdevice", "xen_8ddev", "xen_9drad", "xen_9fcache", "xen_9cerror", "xen_9pidev", "xen_9ppprof", "xen_9ipgu", "xen_9lpdev", "xen_109ncache", "xen_09fdem", "xen_9peengine", "xen_9pedevice", "xen_9fsec", "xen_09fde", "xen_ninepengine", "xen_9pcdevices", "xen_9pdd", "xen_29pctr", "xen_9cpdev", "xen_9perror", "xen_9ndiv", "xen_9pcdi", "xen_109ddevice", "xen_109ddev", "xen_9ddev", "xen_9cdevice", "xen_9fengine", "xen_10pcdi", "xen_9pedev", "xen_29pprof", "xen_9pgu", "xen_9pdevice", "xen_9prerad", "xen_8pdef", "xen_09pdi", "xen_9usec", "xen_09fdi", "xen_9pcdev", "xen_9dsec", "xen_9pptr", "xen_9rdiv", "xen_09fdev", "xen_16prerad", "xen_9cengine", "xen_109pconf", "xen_9pdem", "xen_8ddiv", "xen_9frad", "xen_9pade", "xen_9cdev", "xen_29pcdev", "xen_30pdev", "xen_9ddd", "xen_9pver", "xen_9udev", "xen_30pde", "xen_9pahome", "xen_9predef", "xen_9pderror", "xen_nineddevice", "xen_9fdi", "xen_09fgu", "xen_9fev", "xen_9pdiv", "xen_30padev", "xen_29pdev", "xen_9rdef", "xen_09pdef", "xen_09f3", "xen_9tdevice", "xen_9pprof", "xen_09pver", "xen_9fver", "xen_9pcver", "xen_09fsec", "xen_9pdi", "xen_29ptr", "xen_9cdef", "xen_9psec", "xen_16predev", "xen_9fdef", "xen_9pserver", "xen_109pdevice", "xen_9pigu", "xen_9fserver", "xen_09fdevice", "xen_9pddev", "xen_109pdev", "xen_9qdevice", "xen_9fDev", "xen_9rdev", "xen_9pengine", "xen_9ldiv", "xen_09fserver", "xen_30phome", "xen_9padevice", "xen_9pdef", "xen_9qDev", "xen_10pcdevice", "xen_9predev", "xen_9dtr", "xen_ninefdev", "xen_9ptr", "xen_09fdiv", "xen_09pdiv", "xen_09p3", "xen_9f3", "xen_09pdem", "xen_9pDev", "xen_09pdev", "xen_9fdem", "xen_09fver", "xen_ninefdevice", "xen_9ddi", "xen_9ndevice", "xen_09cDev", "xen_16pdev", "xen_09perror", "xen_9ddef", "xen_9cDev", "xen_9tdef", "xen_9qdi", "xen_9cver", "xen_09pde", "xen_9fde", "xen_9appcache", "xen_16pdef", "xen_8pdev", "xen_09pserver", "xen_9wpdevice", "xen_16predef", "xen_9rconf", "xen_9phome", "xen_9pctr", "xen_9erdev", "xen_09pDev", "xen_30pdevice", "xen_ninepdev", "xen_9ncache", "xen_10pcdev", "xen_9ipserver", "xen_30padevice", "xen_9piserver", "xen_9lconf", "xen_9c3", "xen_30pade", "xen_9ftr", "xen_9ude", "xen_09cdev", "xen_9wp3", "xen_9ddevice", "xen_9nconf", "xen_9erdevice", "xen_9qhome", "xen_9pconf", "xen_9pcde", "xen_9ppdev", "xen_10pdi", "xen_9pcdevice", "xen_10pdev", "xen_09fdef", "xen_9ipdev", "xen_9cev", "xen_109ddd", "xen_9fdev", "xen_9erdi", "xen_9dconf", "xen_09pgu", "xen_9padev", "xen_ninedtr", "xen_9qdev", "xen_9appdev", "xen_9ferror", "xen_9ddiv", "xen_109nconf", "xen_9fdiv", "xen_09pev", "xen_9pdevices", "xen_109ndev", "xen_10pdevices", "xen_9fdd", "xen_9tdd", "xen_8pconf", "xen_9ddevices", "xen_9dde", "xen_ninefengine", "xen_9fdevice", "xen_10pdevice", "xen_9ndev", "xen_nineddev", "xen_9cperror", "xen_9wpdev", "xen_09ferror", "xen_109pdd", "xen_9pcache", "xen_9fprof", "xen_9fconf", "xen_9chome", "xen_9lptr"], "s": ["S", "fs", "r", "settings", "n", "ssl", "o", "p", "d", "m", "session", "w", "sa", "v", "services", "stats", "states", "service", "g", "server", "spec", "c", "t", "b", "f", "e", "sync", "params"], "fsdev": ["nsconf", "wsDev", "wsdev", "nsDev", "wsdef", "dsDev", "fsDev", "dsdev", "wsconf", "nsdef", "fsconf", "dsdef", "nsdev", "fsdef", "dsconf"], "str": ["stri", "fr", "line", "val", "cr", "rr", "text", "r", "pr", "sr", "sc", "priv", "tr", "code", "st", "p", "exec", "arr", "dr", "ct", "Str", "sta", "name", "z", "w", "data", "ocr", "txt", "sp", "expr", "kr", "c", "rs", "hr", "STR", "inner", "style", "dict", "t", "strings", "f", "err", "doc", "set", "ss", "e", "sl", "pass", "ctr", "bl", "br"], "ring_order": [" ring_type", "ring_ordered", "ring_type", "ring__position", "ring_position", "ring__order", " ring_position", "ring__ordered", " ring_ordered", "ring__type"]}}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub,\n\n                                int pred_order)\n\n{\n\n    int p, porder, psize;\n\n    int i, part_end;\n\n    int count = 0;\n\n\n\n    /* subframe header */\n\n    count += 8;\n\n\n\n    /* subframe */\n\n    if (sub->type == FLAC_SUBFRAME_CONSTANT) {\n\n        count += sub->obits;\n\n    } else if (sub->type == FLAC_SUBFRAME_VERBATIM) {\n\n        count += s->frame.blocksize * sub->obits;\n\n    } else {\n\n        /* warm-up samples */\n\n        count += pred_order * sub->obits;\n\n\n\n        /* LPC coefficients */\n\n        if (sub->type == FLAC_SUBFRAME_LPC)\n\n            count += 4 + 5 + pred_order * s->options.lpc_coeff_precision;\n\n\n\n        /* rice-encoded block */\n\n        count += 2;\n\n\n\n        /* partition order */\n\n        porder = sub->rc.porder;\n\n        psize  = s->frame.blocksize >> porder;\n\n        count += 4;\n\n\n\n        /* residual */\n\n        i        = pred_order;\n\n        part_end = psize;\n\n        for (p = 0; p < 1 << porder; p++) {\n\n            int k = sub->rc.params[p];\n\n            count += 4;\n\n            count += rice_count_exact(&sub->residual[i], part_end - i, k);\n\n            i = part_end;\n\n            part_end = FFMIN(s->frame.blocksize, part_end + psize);\n\n        }\n\n    }\n\n\n\n    return count;\n\n}\n", "idx": 35, "substitutes": {"s": ["S", "fs", "ms", "su", "sets", "r", "sc", "ts", "ns", "l", "cs", "is", "ctx", "si", "conf", "j", "qs", "o", "sim", "src", "ins", "m", "sq", "session", "bs", "ans", "v", "services", "a", "sys", "service", "g", "us", "ses", "spec", "ks", "c", "sb", "es", "self", "rs", "gs", "sym", "b", "f", "sg", "os", "ss", "js", "e", "ls", "sl", "ds", "xs"], "sub": ["sam", "rb", "bad", "part", "com", "su", "sc", "form", "l", "rc", "sing", "pb", "si", "sec", "conf", "pl", "super", "sel", "ubs", "sim", "exec", "lib", "src", "ab", "new", "ub", "config", "sq", "job", "per", "sum", "slice", "full", "py", "th", "trans", "func", "type", "data", "oper", "pro", "pred", "ray", "ses", "sb", "reg", "self", "info", "ch", "Sub", "b", "f", "rob", "summary", "ss", "child", "sl", "bc", "sup", "uc", "lc", "desc"], "pred_order": [" pred_end", " pred_grade", "red_order", " pred_ind", "red_error", "pred_desc", "predialpage", "predialorder", "pred_page", "pred_end", " pred_rank", "pred_rank", "predianorder", "pred_error", "red_desc", "predallind", "prediandesc", "prediandir", "predialerr", "red_dir", "pred_enter", " pred_page", "predallorder", "predallrank", "predialgrade", "pred_grade", "pred_dir", " pred_err", "pred_err", "predianerror", " pred_enter", "pred_ind"], "p": ["lp", "part", "tp", "r", "pr", "bp", "patch", "l", "po", "code", "j", "n", "o", "y", "at", "fp", "ep", "d", "m", "api", "wp", "pe", "k", "v", "cp", "a", "pos", "pc", "type", "g", "ps", "sp", "c", "ap", "pp", "pre", "point", "np", "pu", "jp", "pi", "P", "t", "b", "f", "op", "pa", "u", "ip", "dp", "e", "x"], "porder": ["ipid", "cname", " pOrder", "Psize", "cpname", " pcode", "pcode", "pord", "pcname", " penter", " pdesc", "Porder", "corders", "pattr", "pcorder", "pname", "hOrder", " poder", "hattr", "ipcode", "cord", "pacode", "pid", "pcdesc", " pattr", "paorder", " pord", "cpenter", "cpord", "iporder", " pid", "horder", "paoder", "csize", "ipoder", "corder", "porders", "cporder", "poder", " pname", "pdesc", "Pname", "center", "pOrder", "Pord", "penter", "cOrder", "horders", "Pdesc", "cattr", " porders", "paid"], "psize": ["psizing", "upsizer", "ppsizer", "rossize", "ksizer", "upsIZE", "ksizing", "hesize", "psization", "rosize", "linesize", "hesized", "upsization", "ppsize", "blocksization", "ksiz", "PSize", "linesiz", "PSiz", "upsize", "upscale", "upsizing", "rosization", "opsizer", "opsiz", "PSization", "pssize", "epsized", "opsize", "pscale", "hesizer", "blocksize", "blockscale", "hesization", "ppsized", "opsizing", "upsiz", "roscale", "ppsization", "epsize", "psizer", "psiz", "epsization", "PSIZE", "ksize", "blockssize", "upssize", "linesization", "linesIZE", "psIZE", "epsizer", "psized"], "i": ["ui", "io", "l", "si", "is", "j", "n", "uri", "o", "y", "at", "ci", "multi", "ind", "d", "m", "mi", "ori", "I", "api", "z", "k", "ini", "ii", "v", "bi", "end", "a", "li", "iu", "parent", "ie", "sp", "c", "start", "di", "ai", "jp", "info", "ix", "pi", "t", "b", "f", "u", "ip", "ni", "e", "xi", "x", "it", "phi", "index"], "part_end": ["part67center", " part_head", "partpsign", "art_edge", " part_start", "part67address", "part_begin", "art_ends", "part_address", "partpset", "part_sign", "partipend", "part67end", "art_end", "part_start", "part_edge", " part_begin", "partipset", "part67start", "partpend", "art_start", " part_sign", " part_center", "part_center", "part_append", " part_edge", "part_head", " part_append", "part_limit", " part_id", " part_set", " part_address", "part_ends", "part_id", " part_limit", "part_set", "partipsign"]}}
{"project": "qemu", "commit_id": "24408a7d2b459bed3697367b81ada76518ca96ef", "target": 0, "func": "static void ppc_spapr_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    const char *boot_device = args->boot_order;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    hwaddr rma_alloc_size;\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, rtas_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    spapr = g_malloc0(sizeof(*spapr));\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    /* Allocate RMA if necessary */\n\n    rma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        hw_error(\"qemu: Unable to create RMA\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < ram_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = ram_size;\n\n\n\n        /* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         */\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    /* We place the device tree and RTAS just below either the top of the RMA,\n\n     * or just below 2GB, whichever is lowere, so that it can be\n\n     * processed with 32-bit real mode code if necessary */\n\n    rtas_limit = MIN(spapr->rma_size, 0x80000000);\n\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n\n\n\n    /* We aim for a hash table of size 1/128 the size of RAM.  The\n\n     * normal rule of thumb is 1/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. */\n\n    spapr->htab_shift = 18; /* Minimum architected size */\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n\n\n    /* Set up Interrupt Controller before we create the VCPUs */\n\n    spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads,\n\n                                  XICS_IRQS);\n\n    spapr->next_irq = XICS_IRQ_BASE;\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        xics_cpu_setup(spapr->icp, cpu);\n\n\n\n        /* Set time-base frequency to 512 MHz */\n\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n\n\n\n        /* PAPR always has exception vectors in RAM not ROM. To ensure this,\n\n         * MSR[IP] should never be set.\n\n         */\n\n        env->msr_mask &= ~(1 << 6);\n\n\n\n        /* Tell KVM that we're in PAPR mode */\n\n        if (kvm_enabled()) {\n\n            kvmppc_set_papr(cpu);\n\n        }\n\n\n\n        qemu_register_reset(spapr_cpu_reset, cpu);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    spapr->ram_limit = ram_size;\n\n    if (spapr->ram_limit > rma_alloc_size) {\n\n        ram_addr_t nonrma_base = rma_alloc_size;\n\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n\n\n\n        memory_region_init_ram(ram, NULL, \"ppc_spapr.ram\", nonrma_size);\n\n        vmstate_register_ram_global(ram);\n\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n\n                                           rtas_limit - spapr->rtas_addr);\n\n    if (spapr->rtas_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* Set up EPOW events infrastructure */\n\n    spapr_events_init(spapr);\n\n\n\n    /* Set up VIO bus */\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    /* We always have at least the nvram device on VIO */\n\n    spapr_create_nvram(spapr);\n\n\n\n    /* Set up PCI */\n\n    spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW);\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    /* Graphics */\n\n    if (spapr_vga_init(phb->bus)) {\n\n        spapr->has_graphics = true;\n\n    }\n\n\n\n    if (usb_enabled(spapr->has_graphics)) {\n\n        pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        if (spapr->has_graphics) {\n\n            usbdevice_create(\"keyboard\");\n\n            usbdevice_create(\"mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              load_limit - KERNEL_LOAD_ADDR);\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            /* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             */\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    spapr->entry_point = 0x100;\n\n\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model,\n\n                                            initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            boot_device, kernel_cmdline,\n\n                                            spapr->epow_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n}\n", "idx": 43, "substitutes": {"args": ["md", "flags", "ms", "ns", "Arg", "enc", "cs", "resources", "is", "qs", "alloc", "ig", "Args", "arr", "ras", "gas", "ins", "uments", "config", "ids", "words", "any", "api", "ds", "actions", "ass", "conn", "states", "missing", "g", "arms", "arm", "apps", "spec", "ks", "powers", "np", "parser", "ants", "ams", "init", "gs", "arg", "parts", "cmd", "sg", "err", "client", "utils", "aws", "GS", "doc", "parse", "empty", "atts", "plugins", "use", "msg", "params"], "cpu_model": ["cpujmodule", "cpu_location", "gpu_model", "gpu_mode", "cpujlocation", "cpu_module", "gpu_module", "gpu_image", "gpu_location", "cpu_language", "cpu_mode", "gpu_language", "cpujbuffer", "cpujmodel", "cpu_buffer", "cpu_image", "gpu_buffer"], "kernel_filename": ["cpu_username", "boot_filename", "kernel__filename", "cpu_size", "boot_prefix", "kernel_file", "boot__prefix", "kernelblockfilename", "kernelblockusername", "cpu_filename", "kernel_prefix", "boot__file", "kernel__files", "kernelpysize", "kernelblockshell", "kernelblocksize", "kernel_username", "kernel__prefix", "kernel__file", "kernelpyusername", "kernelpyfilename", "boot__files", "kernelpyshell", "boot__filename", "kernel_files", "kernel_size", "kernel_shell", "boot_file", "boot_files", "cpu_shell"], "kernel_cmdline": ["kernel___awkline", "kernel_bitspace", "kernel_cmdmode", "kernel_wdline", "kernel_hostline", "kernel_awkmode", "kernel_commandline", "kernel_awkline", "kernel_bitclass", "kernel_bitline", "kernel_cmdlined", "kernel_commandmode", "kernel_awklined", "kernel___cmdline", "kernel___cmdmode", "kernel_cmdspace", "kernel_commandlined", "kernel_wdclass", "kernel___cmdlined", "kernel_hostspace", "kernel___awklined", "kernel_hostclass", "kernel_wdspace", "kernel_cmdclass", "kernel___awkmode"], "initrd_filename": ["initrs_filename", "initrd_prefix", "initrt_description", "initrd_sequence", "initrt_sequence", "initrt_filename", "initrd_description", "initrs_file", "initrd_file", "initrs_loader", "initrs_prefix", "initrd_loader", "initrt_file"], "boot_device": ["bootpoolunit", "bootingunit", "cpu_device", "bootpooldevice", "bootingdevice", "boot_order", "cpu_unit", "bootingdirectory", "boot_unit", "cpuingdirectory", "cpuingdevice", "bootingorder", "cpuingunit", "bootpooldirectory", "cpu_directory", "bootpoolorder", "cpu_order", "cpuingorder", "boot_directory"], "cpu": ["clock", "cache", "lp", "pkg", "lu", "fps", "linux", "mem", "gc", "node", "gp", "vm", "prem", "GPU", "gpu", "cp", "pc", "sys", "pool", "pp", "pu", "mx", "process", "boot", "proc", "nic", "CPU", "processor"], "env": ["host", "cache", "conf", "docker", "eu", "opt", "exec", "kernel", "ec", "cli", "config", "net", " environment", "mode", "loader", "conn", "exe", "port", "visor", "network", "global", "proc", "dev", "environment", "ssh", "cfg", "ev", "en"], "phb": ["uphp", "shbi", "uphb", " php", "phbs", " phbi", "php", "shp", "phbi", "uphbi", "uphbs", "shbs", " phbs", "shb"], "i": [" bi", "io", "is", "j", "n", "o", "p", "ci", "qi", "d", "m", "z", "ii", "a", "iu", "c", "in", "t", " I", "f", "b", "ip", "ni", "e", "xi", "I", "s"], "sysmem": ["systemlim", "systemmem", " sysrem", "systemMem", "procmem", " sysram", "sysmor", "procMem", "ysmem", "yslim", "systemrem", " sysmor", "sysram", "sysMem", " syslim", "systemram", "systemmor", "procram", " sysMem", "ysram", "procmor", "syslim", "sysrem", "ysrem"], "ram": ["man", "sam", "rum", "mac", "iam", "Ram", "container", "disk", "sim", "param", "mem", "ream", "cam", "nam", "rom", "AM", "access", "mm", "dim", "row", "gram", "RAM", "image", "process", "resource", "gra", "rams"], "rma_alloc_size": [" rma_alloc_small", "rma_allocfcount", " rma_alloc_address", "rma_allocacSIZE", " rma_loc_scale", "rma_allocsscale", "rma_initsnumber", "rma_init_address", "rma_alloc_capacity", " rma_alloc_scale", "rma_allocnnumber", "rma_alloc_loc", "rma_allocnize", "rma_allocenscale", "rma_allocacsized", " rma_loc_address", " rma_loc_small", "rma_allocacsize", "rma_allocsize", "rma_allocnscale", "rma_allocssize", "rma_allocfsize", "rma_allocensized", "rma_initssize", "rma_init_ize", "rma_initsize", "rma_allocnsize", "rma_init_size", "rma_allocacscale", "rma_alloc_count", "rma_alloc_number", "rma_init_scale", "rma_allocfloc", "rma_alloc_sized", " rma_loc_size", "rma_allocensize", "rma_alloc_SIZE", "rma_init_number", "rma_allocfwidth", "rma_initsscale", "rma_alloc_ize", "rma_alloc_width", "rma_alloc_scale", "rma_allocsnumber", "rma_alloc_address", "rma_allocenSIZE"], "load_limit": ["load_model", "loadlexlimit", "loader_model", "loadlexlevel", "load_lim", "loader_scale", "loader_lim", "loadlexscale", "load_level", "loader_limit", "loadlexmodel", "loadlexlim", "loader_level", "load_scale"], "rtas_limit": ["rtasaylimit", "rtos_size", "rta_default", "rtas67limited", "rtas67lim", "rtos64size", "rta_limited", "rtas_default", "rtos64limit", "rtas67limit", "rtas64limits", "rtas_limited", "rtasayadjust", "rtos_limits", "rtAS_size", "rtas67default", "rtos64limits", "rta_lim", "rtAS_limit", "rtas_limits", "rtos64adjust", "rtos_limit", "rtas_lim", "rtasaysize", "rtas64size", "rtos_adjust", "rta_limit", "rtas64limit", "rtas_adjust", "rtas64adjust", "rtasaylimits", "rtAS_limits", "rtas_size", "rtAS_lim"], "fw_size": ["fw67limit", "fw_ui", "hw_ui", "fw67name", "fw_name", "hw_limit", "fw67size", "fw67ui", "fw_limit", "hw_name", "hw_size"], "filename": ["fn", "password", "unit", "uri", "phrase", "fp", "src", "alias", "root", "title", "name", "word", "memory", "Filename", "mode", "label", "prefix", "file", "description", "url", "dll", "files", "original", "shell", "username", "timeout", "path"], "spapr": ["spaptre", "SPaptrs", "spappl", "SPapR", "swapri", "spipprs", "spapear", "sparpf", "spapsrs", "spapw", "upippar", "passappingf", "spipppr", " spapner", "spAPR", "spappw", "spaptar", " spaptner", "speprc", "spapf", "spappingf", " spaptb", "spaptrs", "swaptr", " spaprr", "SPaptar", "spippr", "spraprar", "sparpr", "SPapprs", " spaptrs", "spapri", "spaxr", "spamprc", " spaprator", "spaperrs", "spamprr", "spaptb", " spapprs", " spapl", "spatr", "spaprc", " spapnr", "spampr", "swaptrc", "spmaprator", "spapper", "spaptf", "swapr", " spaperb", "spapsr", "sparprc", "spapnr", "spatf", " spapprator", "spapeb", " spappp", "spapprb", "spepri", "passapnr", "spaptnr", "spapb", "spapprc", "spastrar", "SPapper", "spapre", " spapsrs", "SPaprs", "upipprs", "spaper", "spappf", "spmaprar", "spapsp", "spastrator", "passappingnr", "spapser", "passappingr", "spraprs", " spapprr", " spaprs", "spappingnr", "spaperc", " spapprar", "spaprar", " spapers", "spaptl", "spAPrc", " spapsr", "spapenr", "sparprs", "spapprr", "sparpre", "spepr", "sparpnr", "spaprs", "spraprc", "spatner", "spaprb", " spaperar", "spaperb", "spappingre", "spamper", "spaptr", "spappr", " spaperc", "spmapr", "spastrc", "spapsrr", "spaptR", "passapre", "SPaptR", "SPaptr", "spapR", "passapr", "spaperpr", "spaprator", "spaptrc", " spapser", "spapprar", "SPappnr", "upappr", " spaptnr", " spappr", " spapf", "SPapr", "upapar", "spaperr", "spAPar", "spastr", "passapf", "sprapr", " spaptf", "spapeer", "upippr", "spappp", " spapw", "spajer", "SPapnr", "spappner", " spaptl", " spaprb", "spapepr", "spajr", "sparpb", "spaxner", "spapner", " spapsrc", "spAPr", " spapprc", "spapp", "spapsrc", "spaperar", "spepner", "swaptner", "swapner", "spAPrar", " spaprar", "swaprc", "spaprr", "spapsnr", "spappnr", " spapper", "spatl", " spaptr", "SPappr", "spippar", "SPaper", " spapew", " spaper", "spapprs", "sparpw", "spappingr", "spaxri", "spapl", "spAPrs", "spapew", "sparprb", " spapb", "passappingre", " spaprc", "upipppr", "spmaprc", "spajrs", "spapprator", " spapp", "spapar", "upapr", "spaptri", "swaptri", "spaptner", "upaprs", "sprapp", "spaxrc", "SPapar", "spajnr", "spapers"]}}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static int mpeg1_decode_sequence(AVCodecContext *avctx, \n\n                                 UINT8 *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s1 = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n    int width, height, i, v, j;\n\n    float aspect;\n\n\n\n    init_get_bits(&s->gb, buf, buf_size);\n\n\n\n    width = get_bits(&s->gb, 12);\n\n    height = get_bits(&s->gb, 12);\n\n    s->aspect_ratio_info= get_bits(&s->gb, 4);\n\n    if(!s->mpeg2){\n\n        aspect= mpeg1_aspect[s->aspect_ratio_info];\n\n        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);\n\n    }\n\n\n\n    s->frame_rate_index = get_bits(&s->gb, 4);\n\n    if (s->frame_rate_index == 0)\n\n        return -1;\n\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n\n    if (get_bits1(&s->gb) == 0) /* marker */\n\n        return -1;\n\n    if (width <= 0 || height <= 0 ||\n\n        (width % 2) != 0 || (height % 2) != 0)\n\n        return -1;\n\n    if (width != s->width ||\n\n        height != s->height) {\n\n        /* start new mpeg1 context decoding */\n\n        s->out_format = FMT_MPEG1;\n\n        if (s1->mpeg_enc_ctx_allocated) {\n\n            MPV_common_end(s);\n\n        }\n\n        s->width = width;\n\n        s->height = height;\n\n        avctx->has_b_frames= 1;\n\n        s->avctx = avctx;\n\n        avctx->width = width;\n\n        avctx->height = height;\n\n        if (s->frame_rate_index >= 9) {\n\n            /* at least give a valid frame rate (some old mpeg1 have this) */\n\n            avctx->frame_rate = 25 * FRAME_RATE_BASE;\n\n        } else {\n\n            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];\n\n        }\n\n        s->frame_rate = avctx->frame_rate;\n\n        avctx->bit_rate = s->bit_rate;\n\n        \n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n        s1->mpeg_enc_ctx_allocated = 1;\n\n    }\n\n\n\n    skip_bits(&s->gb, 10); /* vbv_buffer_size */\n\n    skip_bits(&s->gb, 1);\n\n\n\n    /* get matrix */\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_intra_matrix[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->inter_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_non_intra_matrix[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n    }\n\n\n\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    avctx->sub_id = 1; /* indicates mpeg1 */\n\n    return 0;\n\n}\n", "idx": 60, "substitutes": {"avctx": ["avetx", "avcu", "airloc", "apconn", "aflc", "AVctx", "mpcontext", "avelc", "abctx", "avglobal", "afcus", "auloc", "ovcmd", "avcmp", "avcci", "ovctx", " avcn", "afloc", "afconn", "afcci", "aphcontext", "afctx", "AVctrl", "avlc", "apcontext", "aveloc", "alllc", "AVcontext", "avcontext", "avalsrc", "akcf", "avalcontext", "afglobal", "airctx", "avecf", "avconn", "avecmp", "avectx", "aftx", "avecci", " avcontext", "avcmd", "auctx", "afcas", "apctx", " avconn", "aphctx", "avalctx", "avecus", "avtx", "navctx", "avcf", "navsrc", "ovkw", "allcontext", "avctrl", " avglobal", "avconfig", "airconn", "avalcci", "AVcmp", "mpctx", "avsrc", "allctx", "avkw", "abconfig", "mpcmp", "afbuf", "avcus", "akcas", "ovcontext", "afcmd", "navconn", "avalcu", "abcmp", " avcmp", "abcontext", "avalconn", "AVglobal", "akctx", "alltx", "navcontext", "afcmp", "avecontext", "avloc", "aucontext", "akcontext", "avecas", "AVsrc", " avloc", "apbuf", "aphcms", "aucn", "afcf", "avcms", "afcontext", "avcn", "afcn", "afcu", " avbuf", " avkw", "aveconn", "AVconn", "mpconfig", "aircontext", "navctrl", "aphctrl", "afkw", "avecu", "AVcms", "avcas", "navcms", " avcus", " avcmd", "avbuf", "afconfig"], "buf": ["rb", "cache", "buff", "rc", "pb", "ctx", "img", "num", "conv", "bd", "fp", "alloc", "ref", "src", "mem", "ab", "byte", "raw", "config", "queue", "buffer", "vec", "bn", "fb", "cv", "nb", "fd", "data", "batch", "uf", "sb", "gb", "block", "cb", "bin", "b", "cmd", "bc", "seq"], "buf_size": ["img_align", "buflexalign", "wav_size", "buf_shape", "bufetSIZE", "wavetshape", "buflexdepth", "imglexdepth", "wav_len", "wav_shape", "imglexsize", "img_depth", "bufetsize", "buf_len", "imglexalign", "buf_align", "buf_SIZE", "wav_SIZE", "buflexsize", "wavetlen", "bufetshape", "buf_depth", "bufetlen", "wavetSIZE", "img_size", "wavetsize"], "s1": ["s01", "c1", "sc11", " s0", "sv01", "S01", "sc2", "cs1", "cone", "sOne", "qs1", "qs01", "qsone", "c11", "ws11", "cOne", "S1", "sv1", "svone", "sc1", "s11", "SOne", "Sone", "cs0", " sOne", "sone", "c0", " s2", "ws1", "qsOne", "cs2", "svOne", "c2", "s0", "ws2", "wsone", "s2", "csOne", "scone"], "s": ["conf", "d", "an", "states", "ps", "secondary", "sb", "sym", "os", "f", "parts", "js", "comments", "l", "si", "is", "o", "qs", "y", "p", "ins", "se", "ses", "site", "args", "b", "sg", "u", "serv", "sk", "ops", "sup", "plugins", "sync", "h", "S", "r", "settings", "hs", "cs", "ctx", "ssl", "south", "new", "m", "sq", "session", "w", "full", "service", "g", "your", "us", "server", "ks", "spec", "es", "gs", "t", "aws", "ss", "e", "sl", "ls", "ds", "xs", "fs", "su", "sets", "ts", "ns", "n", "a", "services", "sys", "sf", "c", "rs", "storage", "its", "bis", "client"], "height": ["driver", "times", "dist", "home", "total", "grow", "hung", "gh", "layout", "ht", "d", "head", "build", "th", "window", "tight", "image", "history", "max", "gap", "show", "media", "host", "ui", "manager", "rh", " heights", "y", "bottom", "stroke", "html", "gpu", "data", "style", "Height", "h", "arrow", "gallery", "device", "pages", "density", "deep", "lat", "w", "dy", "definition", "inches", "capacity", "slice", "pad", "length", "duration", "shape", "devices", "rank", "thin", "size", "png", "volume", "high", "mac", "container", "def", "padding", "img", "huge", "crop", "input", "rows", "alpha", "id", "resolution", "dim", "above", "distance", "xy", "fw", "direction", "depth", "ows", "version", "timeout", "ty"], "i": ["io", "l", "si", "n", "y", "p", "ci", "d", "m", "z", "mi", "I", "k", "ii", "c", "in", "ai", "info", "pi", "b", "f", "u", "x", "it", "h"], "v": ["vt", "r", "sv", "l", "n", "y", "o", "p", "va", "d", "m", "z", "V", "w", "k", "g", "video", "c", "t", "b", "f", "u", "q", "e", "h", "volume"], "j": ["r", "l", "n", "o", "y", "p", "m", "aj", "obj", "z", "adj", "w", "k", "ij", "pos", "g", "ji", "jp", "ch", "b", "q", "js", "x", "J", "h"], "aspect": [" asct", " asception", "Asception", "exct", "apects", "aspec", " aspec", " aspects", "asspects", "ASception", "ascess", "aspects", "asspir", "asct", "Aspec", "maspects", "act", "asscess", "maspect", "assspect", "apec", "acess", "Aspects", "ASpect", "assct", "exspect", "masspect", "apir", "asspecting", "apect", " aspir", "Aspect", "maspec", "asspec", "asception", "expecting", "ASpects", "rasspect", "raspect", "ASpec", "aspir", "aspecting", " ascess", "expect", "asspect", "rasct", "raspecting"]}}
{"project": "qemu", "commit_id": "f1c52354e5bdab6983d13a4c174759c585e834b3", "target": 0, "func": "static uint32_t drc_set_unusable(sPAPRDRConnector *drc)\n\n{\n\n    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;\n\n    if (drc->awaiting_release) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_allocation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n", "idx": 70, "substitutes": {"drc": ["bpc", "Dsrc", "bsrc", " duc", "sdrc", " droc", "brc", "dpc", "idroc", " dsc", "DRC", " dRC", "puc", "dvc", " drec", " dirc", "dsc", "sdvc", "adirc", "idsrc", "sdsc", "idrc", "duc", "sddc", "ldsrc", "adRC", "adsrc", "trc", " dsrc", " dvc", "iduc", "tsc", "Drc", "tdc", "Dirc", "droc", "ldrc", "dsrc", "drec", "dssrc", " ddc", "dspc", "dsrec", "ddc", "ldpc", "ldrec", "ldirc", "proc", "psrc", "tvc", "dsirc", "adrc", "prc", "brec", "dRC", "dirc", " dpc"]}}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void scsi_read_request(SCSIDiskReq *r)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    if (r->sector_count == (uint32_t)-1) {\n\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n\n        r->sector_count = 0;\n\n        scsi_req_data(&r->req, r->iov.iov_len);\n\n        return;\n\n    }\n\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n\n    if (r->sector_count == 0) {\n\n        scsi_command_complete(r, GOOD, NO_SENSE);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    n = r->sector_count;\n\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n\n\n    r->iov.iov_len = n * 512;\n\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n\n                              scsi_read_complete, r);\n\n    if (r->req.aiocb == NULL) {\n\n        scsi_read_complete(r, -EIO);\n\n    }\n\n}\n", "idx": 83, "substitutes": {"r": ["fr", "rb", "cr", "rr", "res", "gr", "ir", "req", "sr", "rh", "pr", "attr", "l", "rc", "tr", "er", "wr", "rx", "p", "R", "or", "arr", "runner", "nor", "dr", "d", "m", "rf", "mr", "rar", "w", "ro", "rw", "k", "rec", "v", "vr", "rd", "ur", "str", "g", "kr", "c", "rs", "hr", "rg", "nr", "ar", "self", "ru", "ner", "result", "t", "b", "rl", "err", "u", "cur", "this", "e", "re", "lr", "h", "ra", "request", "br"], "s": ["S", "fs", "sc", "ts", "ns", "cs", "is", "si", "ssl", "qs", "y", "p", "d", "m", "bs", "session", "status", "w", "a", "services", "stats", "sys", "service", "ps", "ses", "spec", "c", "rs", "sb", "es", "gs", "state", "b", "f", "os", "as", "aws", "ss", "e", "ls", "http", "ds", "sync"], "n": ["fn", " na", " err", " no", "i", " count", " N", "nm", "ns", "l", "un", "nan", "j", " index", "num", "y", "o", "p", " len", "nn", "nor", "node", "eni", "d", "m", "z", "adj", " p", " network", "sn", "w", "k", "an", "no", "len", "v", "nb", " num", "g", "ne", " c", "cn", "dn", "c", "nt", "nu", "nc", " l", " ng", "mn", " ns", "pn", "ng", "nl", " i", " conn", " number", " size", "b", "na", "t", "none", "f", "u", "ni", "N", "span", "nw", "x", "net", "e", "en"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void lm32_evr_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    LM32CPU *cpu;\n\n    CPULM32State *env;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem =  get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq irq[32];\n\n    ResetInfo *reset_info;\n\n    int i;\n\n\n\n    /* memory map */\n\n    hwaddr flash_base  = 0x04000000;\n\n    size_t flash_sector_size       = 256 * 1024;\n\n    size_t flash_size              = 32 * 1024 * 1024;\n\n    hwaddr ram_base    = 0x08000000;\n\n    size_t ram_size                = 64 * 1024 * 1024;\n\n    hwaddr timer0_base = 0x80002000;\n\n    hwaddr uart0_base  = 0x80006000;\n\n    hwaddr timer1_base = 0x8000a000;\n\n    int uart0_irq                  = 0;\n\n    int timer0_irq                 = 1;\n\n    int timer1_irq                 = 3;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetInfo));\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"lm32-full\";\n\n    }\n\n    cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: unable to find CPU '%s'\\n\", cpu_model);\n\n        exit(1);\n\n    }\n\n\n\n    env = &cpu->env;\n\n    reset_info->cpu = cpu;\n\n\n\n    reset_info->flash_base = flash_base;\n\n\n\n    memory_region_allocate_system_memory(phys_ram, NULL, \"lm32_evr.sdram\",\n\n                                         ram_size);\n\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    /* Spansion S29NS128P */\n\n    pflash_cfi02_register(flash_base, NULL, \"lm32_evr.flash\", flash_size,\n\n                          dinfo ? blk_by_legacy_dinfo(dinfo) : NULL,\n\n                          flash_sector_size, flash_size / flash_sector_size,\n\n                          1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    /* create irq lines */\n\n    env->pic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0));\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    lm32_uart_create(uart0_base, irq[uart0_irq], serial_hds[0]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n\n\n    /* make sure juart isn't the first chardev */\n\n    env->juart_state = lm32_juart_init(serial_hds[1]);\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, EM_LATTICEMICO32, 0, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n", "idx": 84, "substitutes": {"machine": ["model", "cache", "database", "mac", "manager", "base", "device", "object", "linux", "computer", "mem", "connection", "node", "module", "m", "config", "memory", "vm", "mode", "class", "loader", "service", "data", "usb", "game", "template", "M", "Machine", "image", "process", "state", "proc", "storage", "space", "instance", "message"], "cpu_model": ["cpuacscale", "cpu_location", "gpu_mode", "cpuacbase", "cpu_models", "cpu_source", "cpu5server", "core_mode", " cpu_params", "cpufmode", " cpu_settings", "core_base", "cpuObase", "cpuacmode", "cpufserver", "cpu67model", "cpuOparams", "cpu00settings", "cpufmodule", "processor_model", "cpu00base", "cpuacmodel", "cpuOmodel", "cpu_module", "cpuOsettings", "cpu00params", "cpu5model", "gpu_model", "processor_source", "cpu_params", "cpufmodel", "cpu_server", "processor_base", " cpu_base", "cpu_settings", "cpu_scale", "core_location", "processor_server", " cpu_mode", " cpu_scale", "core_server", "core_model", "cpu00model", "gpu_base", "cpu5source", "cpu67source", "cpu_base", "core_module", "cpu67server", "cpu_mode", "gpu_models", "cpu67base", "cpu5base", "core_models"], "kernel_filename": ["kernel__filename", " kernel__filename", "kernel_file", "kernelblockfilename", "kernelpprefix", " kernel_prefix", "kernel_prefix", "licenseblocklanguage", "license_file", "kernelblockfile", "kernel_language", "license_language", "kernel_model", "kernelblockname", "kernel_name", "licenseblockfilename", " kernel_model", "kernelblocklanguage", "kernel__prefix", "kernel__model", "kernelpmanager", "license_name", "kernel_manager", "kernelpmodel", "kernelpfilename", " kernel_manager", " kernel__prefix", "kernel__manager", "licenseblockfile", " kernel__manager", " kernel__model", "license_filename", "licenseblockname"], "cpu": ["clock", "cache", "home", "lu", "pai", "cmp", "ctx", "unit", "num", "linux", "core", "uca", "computer", "kernel", "prefix", "mem", "gc", "node", "module", "eni", "cli", " CPU", "consumer", "queue", "memory", "vm", "hu", "platform", "prem", "GPU", "gpu", "loader", "pc", "cp", "lc", "roc", "bench", "ne", "cn", "console", "python", "pool", "nu", "nc", "np", "pu", "result", "process", "boot", "performance", "jp", "proc", "nic", "cap", "ilo", "CPU", "none", "component", "ni", "instance", "chip", "net", "processor", "hw"], "env": ["uv", "cache", "manager", "password", "context", "enc", "profile", "img", "conf", "dir", "core", "eu", "exec", "ec", "enabled", "viron", "eni", "config", "skin", "vm", " environment", "theme", "engine", "loader", "energy", "ext", "conn", "exe", "console", "window", "path", "ea", "ev", "scope", "np", "ef", "exc", "state", "network", "style", "args", "db", "err", "online", "extra", "shell", "environment", "e", "qt", "life", "en", "Environment"], "dinfo": ["tinfo", "lderror", " dignore", "bdfo", "fconf", "dlignore", "finfo", "bdresult", "pstate", "dlfo", "lignore", "tinf", "pinf", " dinf", "finf", "dignore", "derror", "terror", "dlresult", "dfi", "tstate", "bdinf", "ldconf", "dlinfo", " derror", "dlfi", "dstate", " dfo", "dresult", "dconf", " dstate", "linfo", "dinf", "lfi", "dfo", " dresult", " dconf", "bdinfo", "pinfo", "ldinfo", "linf", "dlinf", "ldinf", " dfi"], "address_space_mem": ["address_space24mem", "address_space_info", "address_service_mb", "address_service_mem", "address_pace_ram", "address_space_ram", "address_space_memory", "address_service_memory", "address_service_ram", "address_space24ram", "address_pace_info", "address_pace_mem", "address_space24info", "address_space_mb"], "phys_ram": ["phys_disk", "Phys_system", "physurecontainer", "ios_region", "physmmdim", "physCsystem", "iosuregram", "physCram", "Phys_rom", "ios_gram", "mount_dim", "Phys_sam", "physCrom", "phys_system", "physCsam", "phys_scale", "phys_gram", "ios_ram", "phys_dim", "physureram", "phys_container", "phys_rom", "iosurecontainer", "iosureregion", "mount_disk", "Phys_ram", "phys_sam", "mount_scale", "physmmscale", "mount_ram", "physureregion", "physmmram", "ios_container", "iosureram", "physmmdisk", "physuregram", "phys_region"], "irq": ["interqs", "interror", "irk", "irqs", " irk", "iriq", " irror", "interq", "interk", "iriqs", "iriror", " irqs", "irik", "irror"], "reset_info": ["reset2source", "deviceoutinfo", "reseterindex", " reset_thin", "device_count", "device_base", "resetallbase", "reseterinformation", "flusherinit", "resetingthin", "flusherinfo", "reset_source", "resetjinfo", "flusherinf", "resetallinformation", "reseterinit", "sync2source", "resetjbase", "resetjcount", "flush_inf", "reset_result", "resetjinformation", "resetoutbase", "sync2information", "sync_index", "resetersource", "resetoutinformation", "sync_info", "flush_init", "flush_hand", "resetoutcount", "deviceoutinformation", "sync2info", "device_info", "sync_information", "sync_source", "resetablethin", "reset_information", "reset_inf", "device_information", "resetingdata", "resetallcount", "reset_base", "deviceoutbase", " reset_data", "resetallinfo", "reseterinf", "reseterinfo", "deviceoutcount", "reset_data", "resetabledata", "reset_thin", "flusherhand", "resetinginfo", "reset_index", "resetableresult", "sync2index", "reseterhand", "reset_hand", "resetingresult", "reset_init", "reset_count", "resetableinfo", "reset2info", "resetoutinfo", " reset_result", "reset2information", "flush_info", "reset2index"], "i": ["io", "r", "l", "is", "disk", "j", "o", "p", "d", "m", "z", "id", "ii", "v", "a", "mini", "iu", "c", "pi", "b", "f", "u", "ip", "e", "xi", "I", "s"]}}
{"project": "qemu", "commit_id": "cf57298af5336df2aece47ef16c290a3a81457dd", "target": 0, "func": "aio_write_f(int argc, char **argv)\n\n{\n\n\tchar *p;\n\n\tint count = 0;\n\n\tint nr_iov, i, c;\n\n\tint pattern = 0xcd;\n\n\tstruct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n\n\tBlockDriverAIOCB *acb;\n\n\n\n\twhile ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 'C':\n\n\t\t\tctx->Cflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'q':\n\n\t\t\tctx->qflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'P':\n\n\t\t\tpattern = atoi(optarg);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&aio_write_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (optind > argc - 2)\n\n\t\treturn command_usage(&aio_write_cmd);\n\n\n\n\tctx->offset = cvtnum(argv[optind]);\n\n\tif (ctx->offset < 0) {\n\n\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\t\treturn 0;\n\n\t}\n\n\toptind++;\n\n\n\n\tif (ctx->offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)ctx->offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tif (count & 0x1ff) {\n\n\t\tprintf(\"count %d is not sector aligned\\n\",\n\n\t\t\tcount);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tfor (i = optind; i < argc; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[i]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tcount += len;\n\n\t}\n\n\n\n\tnr_iov = argc - optind;\n\n\tqemu_iovec_init(&ctx->qiov, nr_iov);\n\n\tctx->buf = p = qemu_io_alloc(count, pattern);\n\n\tfor (i = 0; i < nr_iov; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\",\n\n\t\t\t\targv[optind]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\n\n\t\tqemu_iovec_add(&ctx->qiov, p, len);\n\n\t\tp += len;\n\n\t\toptind++;\n\n\t}\n\n\n\n\tgettimeofday(&ctx->t1, NULL);\n\n\tacb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,\n\n\t\t\t      ctx->qiov.size >> 9, aio_write_done, ctx);\n\n\tif (!acb)\n\n\t\treturn -EIO;\n\n\n\n\treturn 0;\n\n}\n", "idx": 108, "substitutes": {"argv": [" argc", "agve", " argvin", "argumentc", "paramv", "agver", "paramc", "argvs", "Argvs", "argumentv", "paramp", "argsp", "argver", "argp", " argp", " argver", " argl", "argsc", "pgp", "argumentsv", "argsf", "argV", "argc", "pgvin", "axver", "argvin", "pgc", "axc", " argve", "axp", "argsl", "Argf", "Argp", "argl", "axvs", "argf", "Argsv", "pgv", " argsv", " argvs", "paramsv", "Argv", "ArgV", "argve", "axve", "Argvin", "argsV", " argf", "Argl", "agv", " argV", "axv", "argsv", "agc", "Argc", "argumentp"], "p": ["lp", "tp", "part", "r", "bp", "l", "pb", "j", "n", "o", "y", "at", "pt", "fp", "pattern", "d", "m", "z", "api", "wp", "pe", "count", "pad", "v", "cp", "pc", "g", "ps", "sp", "port", "pp", "pre", "np", "jp", "pi", "P", "t", "b", "f", "q", "pa", "u", "ip", "e", "pointer", "h"], "nr_iov": ["invxovi", "nclexnih", "nr__iov", "nl__rolet", "nc_imedia", "nrxiov", "nr_imedia", "nrqvre", "nrqiov", "nr_iago", "nr_eni", "nrlexnih", "nr__rolet", "sr_vre", "nr_nih", "inv_ovi", "nr_rolet", "nc_nih", "nr_ilo", "nc_ilo", "nl_rolet", "nc_iov", "sr_iov", "nl_iov", "nr_iop", "nr_liv", "nclexiov", "nrqiop", "nrlexilo", "nl_ilo", "nl_ovi", "nr_ovi", "invxiov", "nrqliv", "sr_liv", "nrxeni", "nclexilo", "invxiago", "nl__ovi", "nr__ovi", "nrxiago", "nr_vre", "nrxovi", "nr__ilo", "inv_iago", "nl__iov", "nl__ilo", "invxeni", "inv_iov", "inv_eni", "nrleximedia", "nrlexiov", "sr_iop", "ncleximedia"], "i": ["hi", "ui", "l", "fi", "si", "j", "n", "uri", "y", "o", "ani", "ci", "multi", "qi", "ind", "eni", "m", "oi", "mi", "api", "adi", "ri", "k", "ini", "ii", "v", "bi", "x", "li", "ami", "iu", "ie", "ki", "zi", "inner", "di", "ix", "ai", "info", "pi", "t", "b", "f", "u", "gi", "ti", "ip", "ni", "e", "xi", "I", "it", "phi", "s", "index"], "c": ["cc", "cr", "dc", "r", "cy", "cf", "ac", "l", "cs", "enc", "code", "n", "o", "vc", "ci", "ce", "ec", "xc", "d", "m", "z", "k", "count", "unc", "v", "end", "pc", "g", "nc", "ch", "col", "t", "b", "f", "q", "u", "cmd", "cur", "C", "e", "x", "h", "lc", "s"], "ctx": ["kb", "kw", "wx", "cu", "cas", "cc", "bc", "git", "pkg", "loc", "sc", "cf", "rc", "cmp", "context", "cs", "fc", "conv", "cca", "command", "fp", "ci", "exec", "vc", "lib", "connection", "qq", "gc", "xc", "cli", "config", "obj", "voc", "qa", "sci", "tc", "cv", "event", "cp", "lc", "conn", "prefix", "ca", "console", "cn", "fw", "ctrl", "nc", "local", "cb", "tx", "la", "ck", "wcs", "cmd", "hw", "cl", "na", "pa", "utils", "instance", "ct", "cfg", "client", "sync", "cm", "anc", "cus"], "acb": ["ocbook", "acbook", "acbi", "ocB", " accB", "ocb", "accb", " acB", "aclB", "ocbi", " acbook", " accb", " acbi", "aclb", "aclbook", "accB", "aclbi", "acbo", "accbo", " acbo", " accbo", "acB"], "optind": ["optionnd", "openind", " optcount", " optinc", "openInd", " optinn", "effIND", "optionind", "optionin", "optann", "optstart", "optimint", "optimInd", "optnt", "octann", "optionnt", "optionann", "optimIND", "opennt", "octinc", "optimii", "optionIND", "optcount", "optionii", "optimann", "optimnt", "optint", "optionid", "optiminc", "Optinc", "octnd", "optioninn", " optInd", "octin", "OptInd", "optInd", " optIND", "optimin", "optiminn", "altInd", "optnd", " optstart", "octinn", "optimcount", "opnd", "optid", "octint", "altind", "optioncount", "optionstart", "optioninc", "octInd", " optin", "Optnd", "openii", " optid", "octind", "optii", "opInd", "optinn", "Optid", "effstart", "optionInd", "optIND", "altin", "optimind", " optint", "optin", "effInd", "effind", "optinc", "altIND", "optionint", "optimnd", "Optind", "opind", "opii"], "len": ["field", "ail", "all", "lp", "part", "des", "num", "resp", "dl", "lib", "le", "lang", "z", "ln", "ld", "count", "lit", "repl", "ll", "layer", "block", "la", "js", "l", "lt", "lon", "elt", "seq", "fl", "non", "min", "rev", "name", "limit", "hl", "Len", "label", "pos", "el", "li", "data", "ler", "url", "style", "err", "bl", "lf", "lc", "line", "gen", "L", "lin", "mem", "dy", "str", "ann", "lan", "length", "fun", "size", "ls", "sl", "led", "val", "n", "lim", "fin", "list", "coll", "body", "depth", "bin", "db", "span", "light", "en"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = (3 * dc +  1) >> 1;\n\n    dc = (3 * dc + 16) >> 5;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n", "idx": 121, "substitutes": {"dest": ["dist", "home", "text", "west", "comb", "hop", "ord", "num", "temp", "opt", "camp", "usr", "head", "access", "table", "orig", "lit", "est", "feat", "parent", "output", "origin", "cb", "wb", "coord", "ctr", "cont", "draw", "ui", "done", "select", "sort", "de", "option", "null", "tmp", "node", "config", "name", "miss", "stage", "route", "cdn", "mode", "success", "data", "prop", "test", "transfer", "err", "sup", "ident", "transform", "shift", "session", "status", "trans", "txt", "member", "Dest", "trip", "address", "path", "source", "desc", "dc", "die", "loc", "img", "src", "id", "rest", "dim", "master", "class", "contract", "delete", "end", "target", "start", "result", "db", "cl", "content"], "linesize": [" linespace", " linessize", "codesize", " linesizes", "codespace", "codessize", "linsiz", "linspace", "inasizes", "linesizes", "inasized", "nssize", " linesized", "codesiz", "linesiz", "nsize", "inasize", "nsized", "nsizes", "linesized", "inassize", "linsize", " linesiz", "linessize", "linssize", "linespace"], "block": ["comment", "line", "lock", "cache", "loc", "section", "def", "chain", "match", "object", "copy", "unit", "num", "exec", "ref", "group", "node", "config", "name", "word", "buffer", "load", "blocks", "check", "table", "Block", "event", "contract", "end", "type", "list", "row", "map", "col", "pack", "none", "cl", "address", "bl", "bc", "source", "clean"], "i": ["hi", "ui", "io", "l", "fi", "si", "j", "n", "uri", "p", "ci", "multi", "d", "m", "cli", "oi", "z", "I", "api", "k", "ii", "v", "bi", "li", "ami", "iu", "ie", "ji", "c", "zi", "di", "ai", "col", "pi", "mu", "b", "f", "u", "gi", "ti", "ip", "ni", "e", "xi", "x", "index"], "cm": ["hm", "man", "dc", "cr", "cc", "im", "com", "iam", "comm", "cf", "cy", "ram", "um", "ctx", "pm", "core", "car", "ci", "sem", "param", "km", "dm", "cum", "cms", "module", "m", "config", "rom", "cam", "DC", "vm", "fm", "mm", "dim", "tc", "mode", "am", "cp", "lc", "rm", "ca", "co", "cn", "ym", "wm", "c", "ctrl", "gm", "asm", "center", "mc", "em", "CM", "om", "dem", "que", "cmd", "hem", "address", "rem", "bm", "cont", "cd"]}}
{"project": "qemu", "commit_id": "301c7d38a0c359b91526391d13617386f3d9bb29", "target": 1, "func": "static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n\n        const char *desc_file_path)\n\n{\n\n    int ret;\n\n    char access[11];\n\n    char type[11];\n\n    char fname[512];\n\n    const char *p = desc;\n\n    int64_t sectors = 0;\n\n    int64_t flat_offset;\n\n    char extent_path[PATH_MAX];\n\n    BlockDriverState *extent_file;\n\n    Error *local_err = NULL;\n\n\n\n    while (*p) {\n\n        /* parse extent line:\n\n         * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET\n\n         * or\n\n         * RW [size in sectors] SPARSE \"file-name.vmdk\"\n\n         */\n\n        flat_offset = -1;\n\n        ret = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64,\n\n                access, &sectors, type, fname, &flat_offset);\n\n        if (ret < 4 || strcmp(access, \"RW\")) {\n\n            goto next_line;\n\n        } else if (!strcmp(type, \"FLAT\")) {\n\n            if (ret != 5 || flat_offset < 0) {\n\n                return -EINVAL;\n\n            }\n\n        } else if (ret != 4) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (sectors <= 0 ||\n\n            (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&\n\n             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||\n\n            (strcmp(access, \"RW\"))) {\n\n            goto next_line;\n\n        }\n\n\n\n        path_combine(extent_path, sizeof(extent_path),\n\n                desc_file_path, fname);\n\n        ret = bdrv_file_open(&extent_file, extent_path, NULL, bs->open_flags,\n\n                             &local_err);\n\n        if (ret) {\n\n            qerror_report_err(local_err);\n\n            error_free(local_err);\n\n            return ret;\n\n        }\n\n\n\n        /* save to extents array */\n\n        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {\n\n            /* FLAT extent */\n\n            VmdkExtent *extent;\n\n\n\n            ret = vmdk_add_extent(bs, extent_file, true, sectors,\n\n                            0, 0, 0, 0, sectors, &extent);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            extent->flat_start_offset = flat_offset << 9;\n\n        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {\n\n            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/\n\n            ret = vmdk_open_sparse(bs, extent_file, bs->open_flags);\n\n            if (ret) {\n\n                bdrv_unref(extent_file);\n\n                return ret;\n\n            }\n\n        } else {\n\n            fprintf(stderr,\n\n                \"VMDK: Not supported extent type \\\"%s\\\"\"\".\\n\", type);\n\n            return -ENOTSUP;\n\n        }\n\nnext_line:\n\n        /* move to next line */\n\n        while (*p && *p != '\\n') {\n\n            p++;\n\n        }\n\n        p++;\n\n    }\n\n    return 0;\n\n}\n", "idx": 122, "substitutes": {"desc": ["dep", "dist", "dc", "text", "diff", "loc", "attr", "des", "sc", "sub", "rc", "pb", "code", "sec", "dir", "exec", "src", "d", "Desc", "config", "name", "rec", "asc", "esc", "ext", "dest", "description", "Description", "c", "info", "doc", "entry", "uc", "lc", "path"], "bs": ["banks", "rb", "fs", "base", "sync", "BS", "ns", "bid", "cs", "pb", "bb", "ubs", "bps", "ib", "blocks", "bos", "fb", "tc", "ros", "bi", "ps", "ses", "sb", "rs", "iss", "gb", "ob", "gs", "abi", "cb", "vs", "db", "b", "os", "client", "bas", "ss", "ls", "bis", "bc", "ds", "bm", "bt"], "desc_file_path": ["desc_file2name", "desc_file_url", "desc_file__size", "desc_file_system", "desc_full_name", "desc_full_path", "desc_full_url", "desc_file_type", "desc_file2type", "desc_file__path", "desc_full_system", "desc_file__type", "desc_file_size", "desc_file2size", "desc_file__name", "desc_file_name", "desc_file2path", "desc_full_type", "desc_full_size"], "ret": ["part", "pat", "match", "att", "num", "alt", "ref", "group", "usr", "len", "bot", "reset", "count", "lit", "feat", "reply", "info", "arg", "proc", "bit", "msg", "br", "rep", "let", "res", "sr", "error", "hash", "valid", "tmp", "fit", "rev", "red", "format", "success", "rets", "data", "nt", "Ret", "al", "ft", "base", "code", "flag", "active", "mem", "obj", "iter", "status", "str", "fun", "reg", "final", "try", "cat", "bf", "val", "sur", "value", "bad", "back", "def", "rc", "rt", "pt", "RET", "arr", "det", "gt", "id", "ext", "mt", "result", "db", "rl", "re", "art"], "access": ["view", "cache", "open", "password", "select", "attr", "sc", "error", "ac", "rc", "object", "array", "public", "Access", "reference", "seq", "param", "src", "key", "ec", "input", "config", "acl", "acc", "ga", "buffer", "source", "id", "name", "route", "area", "qa", "mode", "asc", "esc", "parent", "length", "ses", "shape", "request", "url", "test", "sect", "image", "ace", "process", "escape", "proc", "na", "address", "resource", "pass", "use", "accessible", "path", "index"], "type": ["field", "family", "part", "types", "unit", "ref", "key", "alias", "number", "position", "parent", "Type", "info", "block", "col", "space", "post", "sort", "error", "domain", "null", "o", "y", "call", "name", "buffer", "time", "label", "format", "pos", "app", "url", "test", "style", "op", "TYPE", "comment", "base", "code", "date", "function", "location", "area", "search", "day", "length", "shape", "pre", "level", "t", "address", "size", "path", "source", "user", "model", "value", "attr", "root", "input", "id", "pe", "off", "class", "py", "platform", "file", "list", "ype", "self", "like", "none", "version", "resource", "ty", "order"], "fname": ["fcnam", " fnam", "cnames", "cname", "fcnames", "fcName", "fName", "fpath", "lfnames", " fnames", "Fpath", "lfnam", "lfName", "lfname", "fnam", "fsize", " fsize", "csize", " fpath", "Fname", "fcname", "Fsize", "cpath", "Fnames", " fName", "fnames"], "p": ["i", "lp", "tp", "pat", "r", "pr", "bp", "patch", "l", "pb", "ctx", "j", "n", "o", "fp", "d", "m", "per", "cp", "a", "python", "pc", "g", "data", "path", "c", "ap", "pair", "point", "np", "vp", "jp", "P", "t", "proc", "b", "f", "q", "pa", "e", "pointer", "h", "s"], "flat_offset": ["flat_start", " flat_padding", "flatacoff", "flatIPoffset", "flat_pad", "lat_len", "single_offset", "flat2path", "file2index", "flat_size", "flat_index", "plain67Offset", " flat_position", "flat_path", "flat_Offset", "file_offset", "flat2reset", "flat_padding", "flat33path", "flat64offset", "plain_pointer", "plain_pad", "plain67pointer", "single64route", "flat_route", "flat_count", "flat_position", "lat_count", "file_index", "flat_off", "single_route", "file2path", "flatacoffset", "flatIPpath", "flat33offset", "flat_pointer", "single64offset", "flat64size", "plain_Offset", "flat_len", "flat_reset", "flat64pointer", "file2reset", "single64size", "single64pointer", "lat_start", "flat67offset", "flatIPreset", "flat67pad", "flat67Offset", "flat___pad", "flatacposition", "flatIPindex", "flat___pointer", "flat64route", "file2offset", "flat33index", "flat___offset", "single_size", "lat_offset", "flat___Offset", "flat67pointer", "file_reset", "flat33reset", "flatacpadding", " flat_off", "flat2offset", "file_path", "plain67pad", "plain_offset", "flat2index", "plain67offset", "single_pointer"], "extent_path": ["extentacdir", "extent2path", "extent_folder", "extant_name", "extent64dir", "extent_name", "extent64folder", "extentactemplate", "extent64path", "extent_image", "extent2dir", "extent2template", "extent_url", "extension_image", "extension_url", "extant_file", "extent2url", "extension_dir", "extant_path", "extension_name", "extent_config", "extant_route", "extant_dir", "extentacurl", "extentacpath", "extant_config", "extension_path", "extent64route", "extent_template", "extent_route", "extension_template", "extant_folder", "extent_dir"], "extent_file": ["extract_filename", "extension__file", "extant_path", "extension_path", "extent_cache", "extent_files", "extract_path", "extent__file", "extract_file", "extension_file", "extent_info", "extension_queue", "extent_filename", "extent__queue", "extent_queue", "extension_cache", "extent__cache", "extant_files", "extant_info", "extension__cache", "extract_files", "extant_file", "extension__path", "extension__queue", "extent__path"], "local_err": ["locallyer", "localapperr", " local_message", "local___err", "remote_conn", "local___error", "private_result", "localappref", "remote_err", "self_err", " local_error", "local_req", "localacerr", "local_er", "localacspec", "local_bug", "local_result", "localacreq", "self_spec", "private_bug", "local___bug", "localappconn", "localacerror", "local_conn", "remote_ref", "private_err", "local_spec", "local_message", "locallyerr", "remote_er", "local_der", "local_error", "localacder", "locallyref", "self_der", "private_error", "self_req", "localapper", "local_ref", "local___result", "localacmessage", "locallyconn"], "extent": ["intract", "Extend", "xtract", " extents", "contend", " extant", "Extents", "xtension", "xtend", "extant", "intend", "extend", "contract", "extension", "extents", "Extant", "xtent", " extension", "Extension", "xtant", "intent", "intant", "extract", "xtents", "Extent", "intension", "contant", "content"]}}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void compute_rematrixing_strategy(AC3EncodeContext *s)\n\n{\n\n    int nb_coefs;\n\n    int blk, bnd, i;\n\n    AC3Block *block, *block0;\n\n\n\n    s->num_rematrixing_bands = 4;\n\n\n\n    if (s->rematrixing & AC3_REMATRIXING_IS_STATIC)\n\n        return;\n\n\n\n    nb_coefs = FFMIN(s->nb_coefs[0], s->nb_coefs[1]);\n\n\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        block = &s->blocks[blk];\n\n        block->new_rematrixing_strategy = !blk;\n\n        for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) {\n\n            /* calculate calculate sum of squared coeffs for one band in one block */\n\n            int start = ff_ac3_rematrix_band_tab[bnd];\n\n            int end   = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]);\n\n            CoefSumType sum[4] = {0,};\n\n            for (i = start; i < end; i++) {\n\n                CoefType lt = block->mdct_coef[0][i];\n\n                CoefType rt = block->mdct_coef[1][i];\n\n                CoefType md = lt + rt;\n\n                CoefType sd = lt - rt;\n\n                sum[0] += lt * lt;\n\n                sum[1] += rt * rt;\n\n                sum[2] += md * md;\n\n                sum[3] += sd * sd;\n\n            }\n\n\n\n            /* compare sums to determine if rematrixing will be used for this band */\n\n            if (FFMIN(sum[2], sum[3]) < FFMIN(sum[0], sum[1]))\n\n                block->rematrixing_flags[bnd] = 1;\n\n            else\n\n                block->rematrixing_flags[bnd] = 0;\n\n\n\n            /* determine if new rematrixing flags will be sent */\n\n            if (blk &&\n\n                block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) {\n\n                block->new_rematrixing_strategy = 1;\n\n            }\n\n        }\n\n        block0 = block;\n\n    }\n\n}\n", "idx": 149, "substitutes": {"s": ["S", "fs", "support", "sv", "sets", "su", "ts", "ns", "l", "sup", "cs", "si", "settings", "n", "conf", "ssl", "qs", "o", "south", "p", "d", "m", "sq", "session", "blocks", "v", "services", "sys", "service", "g", "ses", "sf", "c", "rs", "sb", "es", "self", "spec", "gs", "sym", "t", "b", "f", "sg", "u", "space", "os", "this", "ss", "js", "e", "sl", "ls", "ds", "sync", "xs"], "nb_coefs": ["nb_loefs", "nb_coefd", "nb_loefes", "nb_coeffls", "nb_coefficientss", "nb_coffls", "nb_coeffs", "nb_coecd", "nb_coeffes", "nb_coefls", "nb_coefns", "nb_Coefficientsd", "nb_coiffes", "nb_coecs", "nb_coiffds", "nb_coiffls", "nb_coeffcs", "nb_codfes", "nb_coiffs", "nb_coiffi", "nb_coffi", "nb_coeffits", "nb_Coefs", "nb_coeffi", "nb_coefficientsits", "nb_coeffns", "nb_coiffns", "nb_coiffcs", "nb_coefds", "nb_codfs", "nb_loecs", "nb_coiffd", "nb_cocfes", "nb_coeffd", "nb_cocfs", "nb_coefficientsd", "nb_Coefficientsits", "nb_Coefficientss", "nb_codfits", "nb_coefcs", "nb_coefficientsds", "nb_Coefficientses", "nb_coefes", "nb_coiffits", "nb_coefits", "nb_cocfns", "nb_loefits", "nb_coffns", "nb_coeffds", "nb_Coefits", "nb_coefficientses", "nb_coffs", "nb_Coefes", "nb_loecits", "nb_Coefd", "nb_cocfcs", "nb_coecits", "nb_coeces", "nb_loeces", "nb_coefi"], "blk": ["dlq", "clkt", "blc", "blq", "blkid", " blks", "brkid", "dlch", " blb", "blch", "llq", "dlk", "Blc", " bln", "brc", "slk", "clck", "brq", "llck", "blkt", "dlks", "brkt", "brch", " blck", "BLks", "slb", "clk", "sln", "Blck", "Blb", "BLck", "blck", "Blsk", "Blkt", "plck", "llsk", "plkt", "blks", "blb", "blsk", "BLkid", "plq", "bln", "plch", "brb", " blsk", " blc", "llk", "plk", "clb", "plkid", "Blk", "plks", "brk", "brks", "plsk", "BLk", "brsk", " blkt", "brck", "cln", "plb", "slkt"], "bnd": [" bND", "lind", "lbnn", "bND", "bldk", "Bnd", " bnt", "abnt", "bnn", "abld", " bind", "bbind", "abnn", "blnn", "jobdk", "jobind", "bbnd", "abind", " bld", "abnd", "bord", "Bnt", "lbnd", "bbnt", "bdd", "Bnn", "rbind", "rbnd", "Bend", " bcd", "lbnt", "blnt", "bld", "Bdd", "brind", "rbdk", "rbnt", "blend", "blord", "brnt", "pind", "bbld", "Bind", "lnt", "lld", "bind", "pnd", "lbind", "lcd", "bend", "bnt", "brnn", " bord", "pnt", "bdk", "blind", "lbdd", "brnd", "bldd", "lbdk", "blND", "lnd", " bdk", "pld", "lbld", "bcd", " bend", "BND", " bdd", "blnd", "blld", "Bld", "jobnt", "Bord", "jobnd", "brld", "abcd"], "i": ["hi", "phi", "chi", "ui", "io", "r", "l", "fi", "si", "j", "uri", "n", "y", "p", "ci", "qi", "d", "m", "id", "mi", "z", "ri", "k", "ini", "ii", "bi", "end", "x", "li", "ami", "iu", "ie", "ji", "c", "zi", "start", "di", "ai", "ix", "info", "vi", "pi", "mu", "t", "gi", "b", "ti", "ip", "ni", "e", "xi", "I", "ki", "yi", "index"], "block": ["unit", "layout", "ref", "group", "number", "check", "BL", "blocks", "build", "parent", "row", "output", "layer", "plugin", "f", "bc", "error", "object", "builder", "o", "p", "bo", "node", "join", "label", "point", "scope", "panel", "init", "style", "b", "box", "bl", "sync", "tag", "comment", "line", "lock", "base", "chain", "ack", "session", "obj", "product", "Block", "slice", "full", "address", "child", "http", "clock", "cache", "section", "def", "un", "bb", "j", "k", "off", "frame", "contract", "type", "coll", "work", "flow", "book", "tx", "anch", "none", "cl", "inner"], "block0": ["group2", " block1", "group0", "run0", "group00", "block1", "lock0", " block2", "run4", "run00", " block00", " blockzero", "block2", "Block0", "run2", "block4", "lock2", "Blockzero", "blockzero", "lock1", " block4", "Block2", "frame0", "frame2", "group4", "Block1", "block00", "frame1", "framezero"], "sum": ["comment", "mask", "cat", "cal", "cache", "total", "diff", "part", "neg", "su", "scale", "sort", "sun", "match", "um", "si", "unit", "num", "hash", "sh", "mass", "key", "group", "mem", "cum", "Sum", " sums", "up", "average", "min", "alpha", "miss", "sa", "vol", "count", "ul", "class", "skip", "ass", "pos", "type", "mix", "data", "sign", "add", "us", "mit", "gram", "mean", "weight", "info", "result", "state", "style", "dict", "max", "cost", "summary", "dot", "ss", "size", "out", "parse", "use", "pass", " summ", "index"]}}
{"project": "qemu", "commit_id": "9bb234b3b170299c39c9e88cfe7da5434a92d99d", "target": 1, "func": "void OPPROTO op_udiv_T1_T0(void)\n{\n    uint64_t x0;\n    uint32_t x1;\n    x0 = T0 | ((uint64_t) (env->y) << 32);\n    x1 = T1;\n    x0 = x0 / x1;\n    if (x0 > 0xffffffff) {\n\tT0 = 0xffffffff;\n\tT1 = 1;\n    } else {\n\tT0 = x0;\n\tT1 = 0;\n    FORCE_RET();", "idx": 164, "substitutes": {"x0": ["x00", "X5", "Xe", "xee", "Xee", "tx80", "T5", "x2", "tx0", "x80", " xe", " xee", "xe", "y2", "tx3", "y0", "T3", "t1", "t2", " x5", " x3", "X1", "X3", "T0", "Te", "T1", "X00", "yee", "tx1", "X80", " x50", "X50", "t0", "x3", "X0", " x2", " x80", "y1", "T00", " x00", "x50", "t50", "T2", "x5", "X2"], "x1": ["ax1", "x2", "ax2", "Xone", "x81", " xone", "t81", "axone", "tone", "ax0", "index1", "t1", "X1", "X01", " x01", "xone", "t0", "X81", "X0", " x2", "index01", " x81", "x01", "index0", "X2"]}}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void cpu_x86_init_mmu(CPUX86State *env)\n\n{\n\n    a20_enabled = 1;\n\n    a20_mask = 0xffffffff;\n\n\n\n    last_pg_state = -1;\n\n    cpu_x86_update_cr0(env);\n\n}\n", "idx": 176, "substitutes": {"env": ["uv", "forest", "manager", "password", "attr", "priv", "en", "her", "settings", "context", "enc", "code", "conf", "er", "dir", "core", "ec", "viron", "config", "stage", "buf", "vm", "end", "loader", "conn", "erv", "console", "server", "eng", "np", "scope", "forge", "exc", "args", "global", "db", "e", "environment", "iv", "ev", "path"]}}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "int qemu_cpu_self(void *env)\n\n{\n\n    return 1;\n\n}\n", "idx": 178, "substitutes": {"env": ["all", "device", "rc", "context", "enc", "ctx", "code", "core", "p", "exec", "ec", "viron", "config", "buffer", "py", "data", "console", "path", "port", "nc", "scope", "global", "proc", "dev", "e", "environment", "ev", "en"]}}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static void net_vhost_link_down(VhostUserState *s, bool link_down)\n\n{\n\n    s->nc.link_down = link_down;\n\n\n\n    if (s->nc.peer) {\n\n        s->nc.peer->link_down = link_down;\n\n    }\n\n\n\n    if (s->nc.info->link_status_changed) {\n\n        s->nc.info->link_status_changed(&s->nc);\n\n    }\n\n\n\n    if (s->nc.peer && s->nc.peer->info->link_status_changed) {\n\n        s->nc.peer->info->link_status_changed(s->nc.peer);\n\n    }\n\n}\n", "idx": 179, "substitutes": {"s": ["S", "i", "fs", "ms", "su", "sr", "r", "ts", "ns", "hs", "plugins", "cs", "si", "is", "private", "n", "uns", "ssl", "qs", "p", "ins", "d", "m", "sq", "bs", "se", "session", "w", "ans", "services", "sie", "sys", "states", "stats", "g", "ps", "us", "ses", "ks", "c", "sb", "rs", "es", "site", "gs", "sym", "os", "f", "b", "as", "ss", "js", "e", "ls", "its", "ops", "ds", "sync", "h"], "link_down": ["link_move", "linkfupdate", "linkingoff", "linkerdown", " link_move", "link67up", "linkingdowns", "linkingupdate", "linkerleft", "linkfup", "linkacstate", " link_up", "link_own", "link_update", " link_left", " link_own", "link_up", "linkeroff", "linkerup", "link_off", " link_off", "link67downs", "linkacupdate", " link_state", "link67down", "linkfdown", "linkingup", " link_downs", "linkacup", "linkingdown", "linkerdowns", "linkingown", "link_state", "linkacdown", " link_update", "link67left", "link_downs", "linkerown", "linkfstate", "link_left"]}}
{"project": "FFmpeg", "commit_id": "3547f8e8f8418af0c578eba0de62ecba08e460c2", "target": 0, "func": "static int rv34_decode_mv(RV34DecContext *r, int block_type)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    GetBitContext *gb = &s->gb;\n\n    int i, j, k, l;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int next_bt;\n\n\n\n    memset(r->dmv, 0, sizeof(r->dmv));\n\n    for(i = 0; i < num_mvs[block_type]; i++){\n\n        r->dmv[i][0] = svq3_get_se_golomb(gb);\n\n        r->dmv[i][1] = svq3_get_se_golomb(gb);\n\n    }\n\n    switch(block_type){\n\n    case RV34_MB_TYPE_INTRA:\n\n    case RV34_MB_TYPE_INTRA16x16:\n\n        ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n        return 0;\n\n    case RV34_MB_SKIP:\n\n        if(s->pict_type == AV_PICTURE_TYPE_P){\n\n            ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n            rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);\n\n            break;\n\n        }\n\n    case RV34_MB_B_DIRECT:\n\n        //surprisingly, it uses motion scheme from next reference frame\n\n        /* wait for the current mb row to be finished */\n\n        if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))\n\n            ff_thread_await_progress(&s->next_picture_ptr->f, s->mb_y - 1, 0);\n\n\n\n        next_bt = s->next_picture_ptr->f.mb_type[s->mb_x + s->mb_y * s->mb_stride];\n\n        if(IS_INTRA(next_bt) || IS_SKIP(next_bt)){\n\n            ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n            ZERO8x2(s->current_picture_ptr->f.motion_val[1][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n        }else\n\n            for(j = 0; j < 2; j++)\n\n                for(i = 0; i < 2; i++)\n\n                    for(k = 0; k < 2; k++)\n\n                        for(l = 0; l < 2; l++)\n\n                            s->current_picture_ptr->f.motion_val[l][mv_pos + i + j*s->b8_stride][k] = calc_add_mv(r, l, s->next_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][k]);\n\n        if(!(IS_16X8(next_bt) || IS_8X16(next_bt) || IS_8X8(next_bt))) //we can use whole macroblock MC\n\n            rv34_mc_2mv(r, block_type);\n\n        else\n\n            rv34_mc_2mv_skip(r);\n\n        ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n        break;\n\n    case RV34_MB_P_16x16:\n\n    case RV34_MB_P_MIX16x16:\n\n        rv34_pred_mv(r, block_type, 0, 0);\n\n        rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);\n\n        break;\n\n    case RV34_MB_B_FORWARD:\n\n    case RV34_MB_B_BACKWARD:\n\n        r->dmv[1][0] = r->dmv[0][0];\n\n        r->dmv[1][1] = r->dmv[0][1];\n\n        if(r->rv30)\n\n            rv34_pred_mv_rv3(r, block_type, block_type == RV34_MB_B_BACKWARD);\n\n        else\n\n            rv34_pred_mv_b  (r, block_type, block_type == RV34_MB_B_BACKWARD);\n\n        rv34_mc_1mv     (r, block_type, 0, 0, 0, 2, 2, block_type == RV34_MB_B_BACKWARD);\n\n        break;\n\n    case RV34_MB_P_16x8:\n\n    case RV34_MB_P_8x16:\n\n        rv34_pred_mv(r, block_type, 0, 0);\n\n        rv34_pred_mv(r, block_type, 1 + (block_type == RV34_MB_P_16x8), 1);\n\n        if(block_type == RV34_MB_P_16x8){\n\n            rv34_mc_1mv(r, block_type, 0, 0, 0,            2, 1, 0);\n\n            rv34_mc_1mv(r, block_type, 0, 8, s->b8_stride, 2, 1, 0);\n\n        }\n\n        if(block_type == RV34_MB_P_8x16){\n\n            rv34_mc_1mv(r, block_type, 0, 0, 0, 1, 2, 0);\n\n            rv34_mc_1mv(r, block_type, 8, 0, 1, 1, 2, 0);\n\n        }\n\n        break;\n\n    case RV34_MB_B_BIDIR:\n\n        rv34_pred_mv_b  (r, block_type, 0);\n\n        rv34_pred_mv_b  (r, block_type, 1);\n\n        rv34_mc_2mv     (r, block_type);\n\n        break;\n\n    case RV34_MB_P_8x8:\n\n        for(i=0;i< 4;i++){\n\n            rv34_pred_mv(r, block_type, i, i);\n\n            rv34_mc_1mv (r, block_type, (i&1)<<3, (i&2)<<2, (i&1)+(i>>1)*s->b8_stride, 1, 1, 0);\n\n        }\n\n        break;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 185, "substitutes": {"r": ["fr", "rb", "cr", "rr", "res", "gr", "ir", "sr", "rh", "pr", "rc", "tr", "rt", "n", "er", "o", "p", "R", "usr", "dr", "d", "m", "rf", "mr", "w", "rss", "ri", "rar", "v", "ur", "ocr", "g", "kr", "c", "rs", "hr", "rg", "nr", "ar", "self", "ru", "result", "t", "b", "f", "ra", "e", "re", "br"], "block_type": ["block_style", "block_config", "Block_type", "Block_typ", "Block_style", "blockingTYPE", "block_family", "block_index", "block_name", "blockertype", " block_year", "blockableindex", "blockfstyle", "block_TYPE", "blockernumber", "lock_number", "lock_index", "blockingconfig", "Block_size", "commentingTYPE", " block_family", "comment_type", "lock_type", "block_size", "blockworkstyle", "blockername", "blockworkconfig", "blockftype", "blockingstyle", "block_number", "blockerindex", "blockablename", "block_year", "block_typ", "blockworktype", "blockfsize", "comment_TYPE", "blockftyp", "comment_style", "blockablenumber", "blockablefamily", "comment_config", "lock_name", "commentingtype", " block_style", "blockableyear", "blockablestyle", "blockabletype", "blockworkTYPE", "commentingstyle", "blockingtype", "commentingconfig"], "s": ["conf", "d", "z", "sa", "v", "sp", "ps", "lines", "sb", "results", "sym", "strings", "f", "os", "parts", "this", "js", "comments", "sv", "si", "is", "o", "y", "qs", "p", "se", "data", "ses", "site", "scope", "b", "sg", "u", "ops", "h", "sync", "S", "sc", "settings", "hs", "cs", "ssl", "m", "sq", "session", "w", "full", "service", "g", "us", "server", "spec", "ks", "es", "gs", "t", "aws", "ss", "e", "sl", "ls", "http", "ds", "xs", "fs", "su", "ts", "ns", "n", "ims", "a", "services", "sys", "sf", "c", "rs", "self", "storage", "its", "x", "en"], "gb": ["hm", "kb", "gl", "bf", "tm", "rb", "ui", " rgb", "sc", "bb", "ge", "GB", "gh", "ci", "bg", "gc", "ga", "gp", "vg", "gn", "mb", "gnu", "cv", "gpu", "pc", "g", "eb", "usb", "abb", "gin", "hub", "sb", "rg", "gm", "gram", "gd", "gg", "gy", "gs", "gom", "cb", "db", "gi", "sg", "hw", "storage", "gam", "sl", "bc", "cfg", "bm", "cm"], "i": ["ui", "io", "fi", "si", "is", "n", "uri", "y", "o", "p", "ci", "multi", "qi", "eni", "d", "m", "oi", "z", "mi", "I", "yi", "api", "ri", "ini", "ii", "v", "a", "bi", "li", "g", "iu", "ie", "ji", "c", "in", "zi", "di", "ix", "ai", "info", "abi", "init", "pi", "mu", "t", "b", "f", "u", "gi", "ti", "ip", "ni", "e", "xi", "x", "it", "ki", "h", "lc", "index"], "j": ["si", "n", "jl", "o", "y", "p", "d", "m", "z", "ii", "v", "py", "pos", "li", "g", "ie", "ji", "c", "t", "b", "q", "f", "J", "h"], "k": ["K", "n", "y", "o", "p", "kk", "key", "d", "m", "z", "w", "v", "g", "ks", "c", "b", "q", "u", "f", "e", "sk", "ki", "h"], "l": ["lp", "n", "o", "L", "p", "m", "z", "len", "v", "el", "li", "g", "c", "ll", "kl", "nl", "b", "f", "e", "ls", "sl", "lr", "lb", "h", "lc"], "next_bt": ["nextJbb", " next_bb", "next_BT", "nextPbb", "next_bol", "next67bol", " next_bol", "next67BT", "next_bn", " next_BT", "next_bh", "nextPbt", "nextJbol", "nextJbn", "next67bh", "next67bt", "nextJbt", "next_bb", "nextJBT", " next_bn", "nextPBT", " next_bh", "nextPbn", "nextJbh"]}}
{"project": "qemu", "commit_id": "40365552c2fceacc9800ec9a87b9ead516a9a6ce", "target": 1, "func": "static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target,\n\n                             const char *replaces,\n\n                             int64_t speed, uint32_t granularity,\n\n                             int64_t buf_size,\n\n                             BlockdevOnError on_source_error,\n\n                             BlockdevOnError on_target_error,\n\n                             bool unmap,\n\n                             BlockCompletionFunc *cb,\n\n                             void *opaque, Error **errp,\n\n                             const BlockJobDriver *driver,\n\n                             bool is_none_mode, BlockDriverState *base)\n\n{\n\n    MirrorBlockJob *s;\n\n\n\n\n    if (granularity == 0) {\n\n        granularity = bdrv_get_default_bitmap_granularity(target);\n\n    }\n\n\n\n    assert ((granularity & (granularity - 1)) == 0);\n\n\n\n    if ((on_source_error == BLOCKDEV_ON_ERROR_STOP ||\n\n         on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) &&\n\n        (!bs->blk || !blk_iostatus_is_enabled(bs->blk))) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"on-source-error\");\n\n        return;\n\n    }\n\n\n\n    if (buf_size < 0) {\n\n        error_setg(errp, \"Invalid parameter 'buf-size'\");\n\n        return;\n\n    }\n\n\n\n    if (buf_size == 0) {\n\n        buf_size = DEFAULT_MIRROR_BUF_SIZE;\n\n    }\n\n\n\n    /* We can't support this case as long as the block layer can't handle\n\n     * multiple BlockBackends per BlockDriverState. */\n\n    if (replaces) {\n\n        replaced_bs = bdrv_lookup_bs(replaces, replaces, errp);\n\n        if (replaced_bs == NULL) {\n\n            return;\n\n        }\n\n    } else {\n\n        replaced_bs = bs;\n\n    }\n\n    if (replaced_bs->blk && target->blk) {\n\n        error_setg(errp, \"Can't create node with two BlockBackends\");\n\n        return;\n\n    }\n\n\n\n    s = block_job_create(driver, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->replaces = g_strdup(replaces);\n\n    s->on_source_error = on_source_error;\n\n    s->on_target_error = on_target_error;\n\n    s->target = target;\n\n    s->is_none_mode = is_none_mode;\n\n    s->base = base;\n\n    s->granularity = granularity;\n\n    s->buf_size = ROUND_UP(buf_size, granularity);\n\n    s->unmap = unmap;\n\n\n\n    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp);\n\n    if (!s->dirty_bitmap) {\n\n        g_free(s->replaces);\n\n        block_job_unref(&s->common);\n\n        return;\n\n    }\n\n\n\n    bdrv_op_block_all(s->target, s->common.blocker);\n\n\n\n    bdrv_set_enable_write_cache(s->target, true);\n\n    if (s->target->blk) {\n\n        blk_set_on_error(s->target->blk, on_target_error, on_target_error);\n\n        blk_iostatus_enable(s->target->blk);\n\n    }\n\n    s->common.co = qemu_coroutine_create(mirror_run);\n\n    trace_mirror_start(bs, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}", "idx": 200, "substitutes": {"bs": ["banks", "fs", "BS", "ns", "bid", "plugins", "cs", "pb", "bb", "fps", "ctx", "settings", "ssl", "ubs", "bits", "bps", "http", "src", "ins", "config", "proxy", "bing", "obj", "bt", "bos", "bot", "lb", "bus", "css", "ps", "hub", "ses", "sb", "rs", "iss", "obs", "gb", "bh", "gs", "bytes", "boot", "state", "vs", "db", "b", "os", "utils", "bas", "js", "ss", "ls", "bis", "bc", "ops", "ds", "bl", "its", "source"], "target": ["host", "Target", "manager", "project", "match", "device", "object", "ctx", "unit", "ssl", "builder", "core", "src", "location", "connection", "root", "remote", "config", "proxy", "head", "buffer", "bot", "platform", "master", "arget", "bus", "conn", "type", "parent", "top", "server", "output", "port", "site", "url", "tor", "origin", "nt", "scope", "plugin", "result", "image", "state", "t", "db", "b", "native", "tail", "version", "range", "address", "resource", "component", "net", "client", "goal", "path", "source"], "replaces": ["creps", "receptions", "creplaced", "greps", "creacements", "releases", "preholders", "Replaced", "greleases", "replace", "preacements", "reacements", "preplaced", " reverts", "greacements", "reps", "broadacements", "reverts", "creplaces", "greplaced", "preceptions", "broadps", "remps", "preplace", "broadholders", "preleases", "preplaces", "creholders", "preps", "remholders", "remleases", "remplace", "remverts", " reholders", "recceptions", "remplaced", " replaced", "greplace", "recholders", "Replaces", "creleases", "recplaced", "Replace", " receptions", "remplaces", "Reacements", "greplaces", "broadplaces", " reacements", "remacements", "preverts", "reholders", "replaced", "recplaces"], "speed": ["support", " source", "select", "scale", "sort", "settings", "drive", "priority", "grade", "ssl", "src", "delay", "config", "proxy", "status", "engine", "slice", "mode", "stats", "strength", "service", "duration", "length", "spec", "port", "url", "direction", "scope", "weight", "seed", "performance", "rate", "address", "ss", "slave", "score", "size", "timeout", "sl", "sync", "source"], "granularity": ["granular", "kinity", "generularity", "sanularity", "genularity", "granulus", "regacity", "sanacity", "generule", "gnity", "genity", "ginularity", "regibility", "ginulation", " granule", "kinulus", " granity", "granibility", "regapore", "ranularity", "gunity", "ranulus", " granacity", "sanulation", "sanity", "granulation", "ranular", "ginulus", "gunulus", " granulus", "generality", "gnularity", " granulation", "granity", "regulation", "generapore", "ginular", "kinacity", "sanality", "kinularity", "generity", "regularity", "genular", "genulation", "gnular", "generular", "granule", "regity", "sanapore", "gnule", "gunulation", " granular", "gunular", "genulus", "regality", "granapore", "generacity", "ranulation", "genacity", " granibility", "granacity", "granality", "sanibility", "gunularity", "ginity"], "buf_size": ["buflexnumber", "buff\u00b7strength", "bufgweight", "buflexdepth", "buflexize", "buf_number", "buf_unit", "buff_number", "buf_rate", "buf\u00b7strength", "buff_strength", "cv_content", "bufflength", "buff_depth", "buff_address", "buf_ize", "buf64strength", "buflexunit", "buf64sum", "bufgsize", " buf2size", " buf2depth", "buff_length", "buf\u00b7depth", " buf_scale", "buf64unit", "buf64depth", "buf2size", "cv_size", "buf_length", "buf_loc", "buflexsize", "buf\u00b7size", "buff_capacity", "buf64size", "buff\u00b7size", "buff\u00b7depth", "buf_content", "buffsum", "buf_strength", "buf_address", "buflexstrength", "buff\u00b7unit", "buf_sum", " buf_rate", "buffsize", "cv_loc", "buff_unit", "cv_weight", "buff_sum", "buf_weight", "buffaddress", "buf\u00b7unit", " buf_depth", "buf2scale", "buf_scale", "buff_size", "buf_capacity", "buff_ize", " buf2scale", "buf64length", "bufgcontent", "buf2depth", "buflexcapacity", "buf64address", "buf64rate", "buf_depth", "buf2rate", " buf2rate", "bufgloc", "buf64scale"], "on_source_error": ["on_source2ror", "on_edge_close", "on_source2response", "on_resource_errors", "on_target_response", "on_source2error", "on_target_ror", "on_resource_environment", "on_source_response", "on_target_errors", "on_src_error", "on_src_ror", "on_src_errors", "on_source_environment", "on_resource_error", "on_sourcearyerror", "on_sourcearyclose", "on_sourceayevent", "on_source_change", "on_sourceayerrors", "on_edgearyclose", "on_sourceayenvironment", "on_resource_event", "on_source_event", "on_source_errors", "on_source_ror", "on_src_change", "on_source_err", "on_sourceayerror", "on_source_close", "on_edgearychange", "on_edge_change", "on_target_err", "on_edge_error", "on_sourcearychange", "on_edgearyerror"], "on_target_error": ["on_targetingerror", "on_targetxerr", "on_targetaldanger", "on_site_err", "on_targetappror", "on_source_danger", "on_targetapperr", "on_targetxerror", "on_target_comment", "on_targetxror", "on_source_operation", "on_target_err", "on_site_error", "on_site_ror", "on_target_event", "on_targetalcomment", "on_targetingdanger", "on_source_ror", "on_targetapperror", "on_targetxevent", "on_targetingcomment", "on_target_danger", "on_targetappoperation", "on_target_operation", "on_target_ror", "on_targetingror", "on_source_err", "on_source_comment", "on_site_event", "on_targetalerror", "on_targetalror"], "unmap": ["Unblock", "unblock", "bitmap", "munmap", "Unmap", "unmaps", "unMAP", "bitmaps", "munmaps", "UnMAP", "bitMAP", "Unmaps", "munMAP", "munblock", "bitblock"], "cb": ["fn", "rb", "socket", "buff", "cf", "grab", "cpp", "cmp", "cs", "pb", "ctx", "bb", "conf", "conv", "fp", "exec", "src", "runner", "gc", "cli", "buf", "fb", "finder", "handler", "unc", "cv", "cp", "func", "conn", "callback", "hub", "c", "ctrl", "nc", "gb", "ob", "ck", "cmd", "bc", "sync", "CB"], "opaque": ["opac", "spacity", "ospicit", "OPac", "ospaques", "OPacity", " opicit", "opace", "ospcc", "opicit", "spac", "OPace", "ospaque", "spaque", " opaques", "operacity", " opcc", "opaques", "operace", "OPaque", "opacity", "opsicit", "opsaques", "space", "opscc", "opcc", "opsaque", "operac", "operaque"], "errp": [" errps", "nerpc", " errcp", "iterpa", "rrr", "errr", "iterps", "ercp", "erps", " errf", "dern", "errcp", "ierps", " erpc", "Erp", "iterp", "rrcp", "rrpc", "iern", "errps", "errfp", "eorp", " errping", " erping", "nerp", "erfp", " errtp", "eorf", "Err", "gerps", "ierpa", "erpa", "Erfp", "errpc", " erps", "armp", "nerps", "errtp", " erp", "armps", "erp", " errpc", "eorps", "armpa", "errping", "errn", "nertp", "gerfp", "derps", "iterfp", "eorping", " ertp", "erpc", "errf", "ierp", "gerpa", "gerp", "armn", " errr", "err", "errpa", "Erpc", "derp", "derpa", "rrp", " erf", " errfp"], "driver": ["river", "host", "dist", "cache", "manager", "settings", "drive", "ssl", "builder", "core", "src", "dr", "config", "wrapper", "proxy", "force", "engine", "operator", "finder", "Driver", "mode", "ds", "master", "bus", "handler", "port", "drivers", "test", "plugin", "creator", "client", "browser", "utils", "director", "reader", "design", "source"], "is_none_mode": ["is_noneofdirection", "is_nonefulldirection", "is_none\u00b7mode", "is_nonelymatch", "is_partial_mode", "is_nonefullonly", "is_nonealmatch", "is_none\u00b7grade", "is_default_match", "is_noneofonly", "is_nonelygrade", "is_nonelymode", "is_noneingsize", "is_nonefullmode", "is_partial_only", "is_one_mod", "is_none_grade", "is_nonealsize", "is_partial_source", "is_none_source", "is_none_mod", "is_default_mode", "is_none_error", "is_noneingmod", "is_nonealmode", "is_noneofsource", "is_none_size", "is_defaultalgrade", "is_nonealgrade", "is_one_mode", "is_none_direction", "is_defaultalmode", "is_one_size", "is_noneofmode", "is_default_error", "is_none_match", "is_none\u00b7error", "is_none_only", "is_nonefullsource", "is_nonelyerror", "is_default_grade", "is_nonealerror", "is_defaultalerror", "is_noneingmode", "is_none\u00b7match", "is_partial_direction", "is_nonealmod", "is_defaultalmatch"], "base": ["host", "support", "cache", "family", "scale", "chain", "unit", "core", "builder", "security", "root", "remote", "proxy", "force", "buffer", "status", "store", "area", "bot", "master", "frame", "prefix", "type", "service", "Base", "parent", "server", "port", "site", "shadow", "pre", "origin", "scope", "kit", "boot", "state", "db", "b", "storage", "range", "address", "resource", "bas", "size", "client", "sync", "source", "stable"], "s": ["S", "parts", "fs", "su", "r", "sets", "sync", "ts", "ns", "hs", "l", "cs", "is", "settings", "si", "n", "conf", "ssl", "o", "qs", "p", "ubs", "http", "new", "ins", "d", "m", "sq", "session", "w", "ds", "full", "v", "ops", "services", "native", "stats", "states", "service", "sys", "ps", "server", "ses", "sf", "port", "c", "rs", "spec", "es", "gs", "sym", "t", "sports", "os", "sg", "f", "u", "b", "client", "ss", "single", "js", "sl", "e", "ls", "bis", "sup", "its", "h", "request"]}}
{"project": "qemu", "commit_id": "65cdadd2e2de76f7db3bf6b7d8dd8c67abff9659", "target": 0, "func": "START_TEST(qint_get_int_test)\n\n{\n\n    QInt *qi;\n\n    const int value = 123456;\n\n\n\n    qi = qint_from_int(value);\n\n    fail_unless(qint_get_int(qi) == value);\n\n\n\n    QDECREF(qi);\n\n}\n", "idx": 218, "substitutes": {"qi": ["chi", "i", "ahi", "aka", "agi", "pai", "fi", "si", "qs", "ani", "ci", "qq", "eni", "cci", "sq", "plug", "adi", "qa", "ini", "ii", "fen", "bi", "mini", "li", "iq", "ie", "iaz", "lli", "zi", "dq", "di", "ai", "jp", "iana", "pi", "mu", "qua", "ei", "q", "gui", "gi", "ni", "xi", "Q", "qt", "quad", "ffe"]}}
{"project": "FFmpeg", "commit_id": "2bfd0a97587d26c0c39413a6291ccc66e4a928d0", "target": 1, "func": "static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)\n{\n    uint8_t symbols[256];\n    uint8_t bits[256];\n    uint16_t codes[256];\n    int num_lens, num_codes, num_codes_sum, prefix;\n    int i, j, count;\n    prefix        = 0;\n    count         = 0;\n    num_codes_sum = 0;\n    num_lens = get_bits(gb, 5);\n    for (i = 0; i < num_lens; i++) {\n        num_codes      = get_bits(gb, 9);\n        num_codes_sum += num_codes;\n        if (num_codes_sum > 256) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Too many VLCs (%d) to be read.\\n\", num_codes_sum);\n        for (j = 0; j < num_codes; j++) {\n            symbols[count] = get_bits(gb, 8);\n            bits[count]    = i + 1;\n            codes[count]   = prefix++;\n            count++;\n        if (prefix > (65535 - 256)/2) {\n        prefix <<= 1;\n    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,\n                              codes, 2, 2, symbols, 1, 1, 0);", "idx": 244, "substitutes": {"ctx": ["kb", "cc", "pkg", "loc", "sc", "cf", "rc", "cmp", "context", "cs", "conf", "conv", "cca", "vc", "ci", "connection", "cms", "xc", "cli", "config", "cam", "voc", "qa", "Context", "sci", "cv", "cp", "lc", "conn", "pc", "ca", "cn", "c", "ctrl", "tx", "bc", "cm", "cas", "hw", "anc"], "gb": ["kb", "bf", "tm", "gru", "rb", "git", "cfg", "ui", "buff", "bp", "bb", "GB", "ge", "cca", "vc", "lib", "bg", "gc", "ub", "cli", "ga", "gp", "gio", "gnu", "mb", "nb", "gz", "pc", "go", "eb", "usb", "gin", "abb", "game", "hub", "sb", "rg", "gm", "gd", "gg", "gy", "gs", "cb", "db", "b", "storage", "wb", "ges", "bc", "lb", "bm"], "vlc": ["lvk", "hlp", "lvlc", "lvf", "vlk", "llc", "llcs", "mlp", "tlc", "vlv", "lllc", "vlp", "llf", "lvc", "tlf", "mlcs", "hlcs", "vlf", "llp", "llk", "vllc", "mlc", "hlc", "llv", "mlv", "tlk", "vlcs", "tllc", "hlv"], "symbols": ["symmols", "symmolic", "Symbolic", "syembics", "SyMBals", "Symbonds", "symbol", "symbents", "Symbents", "symbals", "sympolic", "syMBonds", "sympols", "symbolics", "symbels", "Symbles", "syMBals", "Symbals", "syembolic", "symbles", "Symbol", "Symbics", "symathols", "syMBics", "symbics", "syMBents", "SyMBents", "SyMBles", "symbolol", "SyMBols", "syMBolic", "syembols", "SyMBels", "syMBol", "syMBols", "symples", "sympels", "syMBles", "symbonds", "symbolals", "symbolols", "syMBels", "SyMBolic", "symathonds", "SyMBol", "Symbols", "symbolic", "Symbels", "symmels", "SyMBics", "symbololic", "symmles", "SyMBonds", "symathol", "symathents", "symbolents", "symbolonds", "syembals"], "bits": ["bugs", "fixes", "cache", "ports", "flags", "cs", "code", "ubs", "ips", "ints", "ins", "details", "bs", "words", "config", "ries", "errors", "blocks", "status", "jobs", "cats", "ops", "x", "stats", "states", "batch", "ps", "frames", "pins", "vals", "outs", "files", "info", "init", "locks", "parts", "limits", "b", "utils", "its", "bis", "points", "bytes", "ls", "pieces", "bit", "s", "checks", "bands"], "codes": ["xxx", "fixes", "cod", "cards", "cache", "cases", "cells", "flags", "ports", "zip", "maps", "ns", "cycles", "cs", "code", "values", "ci", "ones", "items", "config", "names", "rows", "sequence", "errors", "status", "jobs", "cats", "ops", "pos", "states", "css", "lines", "length", "frames", "steps", "c", "params", "es", "outs", "cb", "locks", "strings", "odes", "ls", "x", "bytes", "seq", "checks", "windows"], "num_lens": ["num_llen", "num_towers", "num_lenth", "num_denth", "num_dens", "num_lowers", "num_Len", "num_lleng", "num_sens", "num_ten", "num_denses", "num_Lenth", "num_deng", "num_Locks", "num_llenth", "num_dayers", "num_Lens", "num_sayers", "num_slens", "num_tayers", "num_den", "num_layers", "num_docks", "num_llens", "num_slenses", "num_dowers", "num_len", "num_sen", "num_Lenses", "num_Leng", "num_slocks", "num_slenth", "num_sowers", "num_locks", "num_lenses", "num_tens", "num_leng"], "num_codes": [" num_cases", "num_code", "numNlines", "numxbits", "numxmaps", "num_lines", "num_config", "sum_codes", "numNconfig", "sum_config", " num_bits", "num_maps", "numxlines", "numxcod", "numNcodes", "num_cells", " num_checks", " num_code", "num_cases", "num_cod", "numxcode", "numxcodes", "numNcells", "sum_cells", "numxchecks", " num_lines", "numxcases", "num_checks", " num_maps", "num_bits", " num_cod", "sum_lines"], "num_codes_sum": ["num_codes_mm", "num_bits_range", "num_bits_size", "num_codesavesize", "num_lines_size", "num_codes___range", "num_comments_mm", "num_codes_not", "num_errors_sum", "num_codes_size", "num_lines_sum", "num_errors_count", "num_errors_size", "num_codes_um", "num_comments_all", "num_bits_count", "num_errors_mm", "num_bits_sum", "num_codes___max", "num_codes_count", "num_codes_max", "num_codes_range", "num_codes_num", "num_comments_num", "num_bits_not", "num_lines_um", "num_codes___sum", "num_comments_sum", "num_codes_vol", "num_codes___vol", "num_codesavesum", "num_codes_all", "num_codesavecount", "num_lines_num", "num_codesavenot", "num_bits_max", "num_bits_vol"], "prefix": ["offset", "cache", "zip", "base", "req", "scale", "bp", "patch", "hop", "padding", "priority", "code", "num", "p", "ref", "key", "number", "delay", "sequence", "name", "radius", "sum", "status", "len", "reset", "master", "label", "pad", "format", "skip", "type", "mix", "jj", "position", "wrap", "parent", "length", "c", "pre", "counter", "ix", "weight", "result", "gap", "fix", "magic", "range", "post", "pointer", "seq", "index"], "i": ["offset", "ui", "io", "l", "fi", "si", "code", "n", "y", "p", "ci", "key", "qi", "ind", "eni", "d", "mi", "id", "k", "ini", "ii", "v", "a", "x", "bi", "li", "iu", "ie", "ji", "c", "in", "zi", "di", "ix", "ai", "jp", "info", "pi", "b", "f", "u", "gi", "ip", "ni", "e", "xi", "I", "index"], "j": ["jc", "jo", "r", "l", "code", "num", "n", "jl", "y", "dj", "o", "p", "key", "ind", "d", "m", "aj", "job", "z", "ja", "k", "ij", "ii", "v", "pos", "jet", "li", "g", "jj", "ji", "c", "jp", "ch", "b", "q", "u", "f", "js", "x", "it", "J", "h", "index", "br"], "count": ["order", "loop", "cache", "offset", "Count", "zip", "base", "patch", "l", "match", "code", "n", "num", "conf", "low", "core", "p", "key", "number", "ind", "call", "name", "z", "id", "sum", "check", "w", "limit", "session", "len", "ii", "skip", "label", "g", "list", "coll", "batch", "parent", "length", "member", "c", "test", "current", "counter", "start", "weight", "depth", "ch", "process", "col", "b", "f", "q", "fix", "handle", "child", "e", "size", "use", "x", "seq", "index", "found"]}}
{"project": "FFmpeg", "commit_id": "7bf3f380466eeff24916fd6218aca13e414c6240", "target": 1, "func": "static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx,\n\n                                  CodedBitstreamUnit *unit)\n\n{\n\n    BitstreamContext bc;\n\n    int err;\n\n\n\n    err = bitstream_init(&bc, unit->data, 8 * unit->data_size);\n\n    if (err < 0)\n\n        return err;\n\n\n\n    switch (unit->type) {\n\n    case HEVC_NAL_VPS:\n\n        {\n\n            H265RawVPS *vps;\n\n\n\n            vps = av_mallocz(sizeof(*vps));\n\n            if (!vps)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_vps(ctx, &bc, vps);\n\n            if (err >= 0)\n\n                err = cbs_h265_replace_vps(ctx, vps);\n\n            if (err < 0) {\n\n                av_free(vps);\n\n                return err;\n\n            }\n\n\n\n            unit->content = vps;\n\n        }\n\n        break;\n\n    case HEVC_NAL_SPS:\n\n        {\n\n            H265RawSPS *sps;\n\n\n\n            sps = av_mallocz(sizeof(*sps));\n\n            if (!sps)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_sps(ctx, &bc, sps);\n\n            if (err >= 0)\n\n                err = cbs_h265_replace_sps(ctx, sps);\n\n            if (err < 0) {\n\n                av_free(sps);\n\n                return err;\n\n            }\n\n\n\n            unit->content = sps;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_PPS:\n\n        {\n\n            H265RawPPS *pps;\n\n\n\n            pps = av_mallocz(sizeof(*pps));\n\n            if (!pps)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_pps(ctx, &bc, pps);\n\n            if (err >= 0)\n\n                err = cbs_h265_replace_pps(ctx, pps);\n\n            if (err < 0) {\n\n                av_free(pps);\n\n                return err;\n\n            }\n\n\n\n            unit->content = pps;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_TRAIL_N:\n\n    case HEVC_NAL_TRAIL_R:\n\n    case HEVC_NAL_TSA_N:\n\n    case HEVC_NAL_TSA_R:\n\n    case HEVC_NAL_STSA_N:\n\n    case HEVC_NAL_STSA_R:\n\n    case HEVC_NAL_RADL_N:\n\n    case HEVC_NAL_RADL_R:\n\n    case HEVC_NAL_RASL_N:\n\n    case HEVC_NAL_RASL_R:\n\n    case HEVC_NAL_BLA_W_LP:\n\n    case HEVC_NAL_BLA_W_RADL:\n\n    case HEVC_NAL_BLA_N_LP:\n\n    case HEVC_NAL_IDR_W_RADL:\n\n    case HEVC_NAL_IDR_N_LP:\n\n    case HEVC_NAL_CRA_NUT:\n\n        {\n\n            H265RawSlice *slice;\n\n            int pos, len;\n\n\n\n            slice = av_mallocz(sizeof(*slice));\n\n            if (!slice)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_slice_segment_header(ctx, &bc, &slice->header);\n\n            if (err < 0) {\n\n                av_free(slice);\n\n                return err;\n\n            }\n\n\n\n            pos = bitstream_tell(&bc);\n\n            len = unit->data_size;\n\n            if (!unit->data[len - 1]) {\n\n                int z;\n\n                for (z = 0; z < len && !unit->data[len - z - 1]; z++);\n\n                av_log(ctx->log_ctx, AV_LOG_DEBUG, \"Deleted %d trailing zeroes \"\n\n                       \"from slice data.\\n\", z);\n\n                len -= z;\n\n            }\n\n\n\n            slice->data_size = len - pos / 8;\n\n            slice->data = av_malloc(slice->data_size);\n\n            if (!slice->data) {\n\n                av_free(slice);\n\n                return AVERROR(ENOMEM);\n\n            }\n\n            memcpy(slice->data,\n\n                   unit->data + pos / 8, slice->data_size);\n\n            slice->data_bit_start = pos % 8;\n\n\n\n            unit->content = slice;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_AUD:\n\n        {\n\n            H265RawAUD *aud;\n\n\n\n            aud = av_mallocz(sizeof(*aud));\n\n            if (!aud)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_aud(ctx, &bc, aud);\n\n            if (err < 0) {\n\n                av_free(aud);\n\n                return err;\n\n            }\n\n\n\n            unit->content = aud;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 245, "substitutes": {"ctx": ["kb", "kw", "gru", "cu", "cc", "pkg", "req", "loc", "cf", "rc", "fc", "context", "cmp", "grad", "conv", "cca", "vc", "lib", "ci", "connection", "gc", "xc", "cli", "ct", "cam", "cci", "config", "lex", "voc", "Context", "sci", "cv", "cp", "conn", "ocr", "coll", "cn", "c", "ctrl", "nc", "scope", "auc", "kt", "tx", "crit", "ck", "wcs", "hw", "utils", "component", "cm", "cas", "sync", "lc", "anc"], "unit": ["comment", "user", "update", "relation", "reason", "ui", "base", "section", "un", "device", "language", "object", "option", "num", "uri", "null", "letter", "uni", "number", "connection", "category", "module", "split", "term", "piece", "force", "Unit", "units", "element", "capacity", "note", "volume", "build", "format", "lc", "type", "service", "position", "package", "output", "site", "item", "target", "layer", "plugin", "block", "transfer", "book", "style", "crit", "u", "version", "component", "address", "size", "instance", "condition", "it", "kin", "source", "rule"], "bc": ["bf", "cc", "dc", "jc", "bitcoin", "sc", "bp", "cf", "ac", "fc", "rc", "context", "bb", "uca", "cca", "vc", "ci", "bg", "ec", "cms", "gc", "xc", "config", "acl", "lb", "tc", "lc", "pc", "ca", "coll", "CBC", "circ", "wic", "sb", "c", "ctrl", "nc", "gb", "mc", "cb", "tx", "oc", "lic", "ucc", "db", "BC", "cl", "cfg", "cas", "uc", "cm"], "err": ["all", "rr", "req", "er", "resp", "opt", "far", "ref", "rage", "usr", "nor", "eor", "mr", "rar", "erer", "orig", "count", "ah", "ner", "dev", "der", "magic", "doc", "go", "msg", "fg", "br", "cr", "gr", "rh", "sr", "error", "y", "valid", "yr", "ind", "min", "norm", "owner", "ler", "ise", "ry", "aster", "nr", "test", "orr", "init", "lr", "rag", "orer", "acer", "fr", "pr", "icer", "fer", "wr", "dr", "var", "iter", "ini", "str", " error", "spec", "ar", "ver", "more", "e", " Err", "later", "ir", "bug", "attr", "Er", "arr", "fy", "Error", "arm", "kr", "hr", "result", "better", "inner", "reader", "order"], "vps": ["hips", " vports", " veps", "hps", "avPS", "vists", "viPs", "svpes", " vPs", "vpes", "hsp", "fps", "svps", "avp", "Vps", "vpp", " vpps", " vpa", "veps", "svp", "svsp", "vPs", "hpps", " vops", "vpps", "svops", "avps", "avips", "fips", "sops", "fpps", "sveps", "vpa", "mpa", "pPS", "viports", "vips", "mips", "fpes", "Vists", "svpp", "pops", "Vops", "mps", "vieps", "vports", "ppp", " vips", " vPS", "svPS", "vops", "vp", "viops", "viists", "svpps", "vPS", "fpa", " vists", " vpp", " vpes", " vp", "vip", "vsp", "VPs", "svports", "sips", "spp", "mpps", " vsp", "svips"], "sps": ["vaps", "gspped", "dits", "supped", "sases", "sandpped", "sympt", "skyips", "sls", "slapes", "vpl", "skysp", "slases", "sandps", " samps", "sesper", "skypped", " sper", "pips", "paps", "spos", "sper", "vls", "sespped", "skyps", " sips", " sases", " spped", "sapes", " spe", "spe", "samples", "slips", "gspt", "sits", "gsps", "pamps", "spl", "dpped", " spos", "gsips", " samples", "ppos", "sandits", "pls", "ppl", "dps", " saves", "dips", "slps", " saps", "sesps", " ssp", "sespe", "ssp", "pamples", "sips", "vpos", " sapes", " spt", "suips", "samps", "susp", "symips", "vips", " sls", "saves", "sympped", "paves", "sups", "spped", " spl", "spt", "sandips", "symps", "saps"], "pps": ["clips", "phones", "ports", "mp", "amps", "cpp", "ups", "fps", "types", "packs", "pl", "forces", "bps", "acts", "ips", "ipes", "icks", "pes", "ppers", "charges", "aps", "inches", "ppy", "ppa", "pots", "px", "alls", "cp", "akes", "apps", "ps", "ks", "powers", "steps", "pins", "pp", "hops", "tracks", "pull", "eps", "jp", "posts", "upp", "php", "push", "drops", "mph", "js", "points", "ops", "ds", "ypes", "xs", "params", "pg"]}}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void qpa_audio_fini (void *opaque)\n\n{\n\n    (void) opaque;\n\n}\n", "idx": 246, "substitutes": {"opaque": ["operane", "oplaque", "oplacity", "opatile", " opula", "pacity", " opane", "oplatile", "opane", " opatile", "patile", "operacity", " opacity", "paque", "operacre", "pacre", " opacre", "opacity", "opacre", "opula", "pula", "oplula", "pane", "operaque"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_bulk_packet(void *priv, uint32_t id,\n\n    struct usb_redir_bulk_packet_header *bulk_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = bulk_packet->endpoint;\n\n    int len = bulk_packet->length;\n\n    AsyncURB *aurb;\n\n\n\n    DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulk_packet->status,\n\n            ep, len, id);\n\n\n\n    aurb = async_find(dev, id);\n\n    if (!aurb) {\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||\n\n            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {\n\n        ERROR(\"return bulk packet mismatch, please report this!\\n\");\n\n        len = USB_RET_NAK;\n\n    }\n\n\n\n    if (aurb->packet) {\n\n        len = usbredir_handle_status(dev, bulk_packet->status, len);\n\n        if (len > 0) {\n\n            usbredir_log_data(dev, \"bulk data in:\", data, data_len);\n\n            if (data_len <= aurb->packet->len) {\n\n                memcpy(aurb->packet->data, data, data_len);\n\n            } else {\n\n                ERROR(\"bulk buffer too small (%d > %d)\\n\", data_len,\n\n                      aurb->packet->len);\n\n                len = USB_RET_STALL;\n\n            }\n\n        }\n\n        aurb->packet->len = len;\n\n        usb_packet_complete(&dev->dev, aurb->packet);\n\n    }\n\n    async_free(dev, aurb);\n\n    free(data);\n\n}\n", "idx": 248, "substitutes": {"priv": ["mod", "pri", "tty", "auth", "attr", "req", "device", "rc", "private", "impl", "pid", "api", "pub", "prom", "pad", "pod", "cp", "conn", "pc", "prop", "eth", "pro", "pred", "ev", "gb", "info", "ch", "pi", "riv", "proc", "pack", "Priv", "deb", "reader", "aud"], "id": ["i", "did", "ident", "ID", "req", "error", "hid", "def", "ptr", "code", "ider", "sid", "p", "ref", "root", "ind", "d", "ids", "pid", "name", "head", "ad", "pad", "event", "end", "type", "fd", "kid", "mid", "Id", "parent", "url", "aid", "ide", "oid", "start", "info", "f", "ip", "one", "iden", "uid", "path"], "bulk_packet": ["bulk_packageette", "bulk_packeting", "bulkenbyteete", "bulkenpackpoint", "bulk_scette", "bulk_packageant", "bulk_packart", "bulk_payant", "bulk_packad", "bulk_framet", "bulkjpacket", "bulkjpayet", "bulk_payET", "bulk_hooket", "bulk_packageeting", "bulk_packload", "bulk_competing", "bulk_byteET", "bulk_paramant", "bulk_packseting", "bulk_packset", "bulk_formpoint", "bulkenbyteet", "bulkjpackET", "bulk_comppoint", "bulk_packete", "bulk_packant", "bulk_packageel", "bulkenbyteET", "bulk_byteete", "bulk_pacset", "bulk_promacket", "bulk_sexacket", "bulkjpackload", "bulk_compet", "bulk_plugete", "bulk_framET", "bulk_compete", "bulk_hookad", "bulk_packel", "bulk_bytepoint", "bulk_packageload", "bulk_payload", "bulk_packacket", "bulk_packageacket", "bulkjpackant", "bulk_promet", "bulk_frameting", "bulkenpacket", "bulk_packette", "bulk_packageet", "bulk_sexET", "bulk_plugeting", "bulk_hookette", "bulk_compette", "bulk_formET", "bulk_byteet", "bulk_scet", "bulk_paramet", "bulk_scad", "bulk_compant", "bulk_sexer", "bulk_compel", "bulkjpayET", "bulk_hookant", "bulk_plugET", "bulk_promette", "bulk_pacart", "bulk_promET", "bulk_paramer", "bulkenbytepoint", "bulk_comper", "bulk_packET", "bulkjpayant", "bulk_pacet", "bulk_compload", "bulk_paramette", "bulk_requestET", "bulk_pacET", "bulk_hookET", "bulk_packer", "bulkenpackET", "bulk_formet", "bulk_framete", "bulk_packpoint", "bulk_pluget", "bulk_payet", "bulk_paramacket", "bulk_hookset", "bulk_compset", "bulkenpackete", "bulk_scant", "bulk_packageET", "bulk_packsacket", "bulk_requestet", "bulk_formete", "bulk_paramET", "bulk_compET", "bulk_sexet", "bulk_requestette", "bulk_compacket", "bulk_packsel", "bulk_hookart", "bulk_compart", "bulkjpayload", "bulk_paramad"], "data": ["all", "i", "temp", "zero", "d", "len", "bus", "ata", "parent", "complete", "results", "info", "block", "DATA", "message", "done", "error", "p", "valid", "append", "dat", "name", "buffer", "load", "args", "response", "err", "open", "bytes", "next", "zip", "device", "Data", "new", "mem", "write", "raw", "pad", "str", "length", "package", "devices", "read", "options", "extra", "size", "empty", "source", "val", "cache", "fail", "def", "connection", "input", "delay", "api", "rec", "a", "body", "result", "none", "version", "da", "resource", "reader", "content"], "data_len": ["dataqpos", "dataqlen", " data_limit", "data_lang", " data_val", "next_length", "memory_size", "memory_len", "data_size", "data_Len", "next_pos", " data_pos", "next_len", "dataqlang", "memoryqlang", "memoryqsize", "memoryqLen", " data_length", "memoryqlen", "dataqlength", "data_pos", "data_length", "memory_Len", "dataqLen", " data_Len", "data_limit", "data_num", "memory_lang", "data_val", "dataqlimit", "next_num", "dataqsize"], "dev": ["user", "md", "gu", "mod", "serial", "comment", "dd", "dc", "cache", "diff", "bug", "req", "error", "device", "def", "de", "private", "conf", "temp", "p", "DEV", "debug", "valid", "dm", "root", "d", "var", "cam", "raw", "dat", "name", "w", "pub", "ad", "adv", "prom", "v", "conn", "pro", "package", "Dev", "app", "reg", "dt", "di", "prof", "info", "ch", "block", "proc", "sd", "dem", "ver", "ow", "doc", "rad", "client", "ev", "prov", "dom", "desc"], "aurb": ["ervad", "aurk", "ervin", "urf", "iverk", "mrb", "iara", "urbase", "aird", "ergb", "narc", "iarbase", "eura", "thurb", "igrbot", "aurbar", "igrw", "iverab", "thurd", "iarad", "narba", "eurc", "iarb", "ervbe", "eurk", "aurbase", "aurba", "augb", "eurbb", "aul", "narb", "auc", "aurp", "narf", "aurc", "iverbb", "aurw", "narp", "ervbb", "iverba", "aurin", "narab", "ergbe", "eurba", "urin", "eurp", "auf", "eurad", "ibrd", "augB", "aup", "iard", "ervc", "mrab", "aurbe", "aurB", "igrc", "igrin", "igrbe", "airB", "aurf", "igrb", "url", "urw", "urbot", "aurad", "aurbb", "ibrit", "urd", "ura", "ervba", "iverB", "augp", "urr", "ibrB", "mrB", "aurbot", "ervbar", "thurbase", "aurr", "aurl", "iverb", "iarB", "narB", "ervb", "urk", "aubot", "airb", "urba", "urc", "eurb", "urb", "igrr", "aub", "aurd", "ergbar", "urbb", "ervw", "aurit", "mrba", "igrf", "airit", "aur", "eurB", "igrl", "ibrb", "auga", "ervl", "iarit", "iarbb", "ervp", "igrbar", "urB", "ergl", "ervf", "urp", "aura", "aurab", "iarp", "thura"]}}
{"project": "FFmpeg", "commit_id": "964f07f68e1cc4e2d585615e2b1a1fade269afb0", "target": 1, "func": "static av_cold int hevc_init_context(AVCodecContext *avctx)\n{\n    HEVCContext *s = avctx->priv_data;\n    int i;\n    s->avctx = avctx;\n    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));\n    if (!s->HEVClc)\n        goto fail;\n    s->HEVClcList[0] = s->HEVClc;\n    s->sList[0] = s;\n    s->cabac_state = av_malloc(HEVC_CONTEXTS);\n    if (!s->cabac_state)\n        goto fail;\n    s->output_frame = av_frame_alloc();\n    if (!s->output_frame)\n        goto fail;\n    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n        s->DPB[i].frame = av_frame_alloc();\n        if (!s->DPB[i].frame)\n            goto fail;\n        s->DPB[i].tf.f = s->DPB[i].frame;\n    }\n    s->max_ra = INT_MAX;\n    s->md5_ctx = av_md5_alloc();\n    if (!s->md5_ctx)\n        goto fail;\n    ff_bswapdsp_init(&s->bdsp);\n    s->context_initialized = 1;\n    s->eos = 0;\n    return 0;\nfail:\n    hevc_decode_free(avctx);\n    return AVERROR(ENOMEM);\n}", "idx": 262, "substitutes": {"avctx": ["afpkg", "afcontext", "awctx", " avtx", "avcu", "AVpkg", "AVctx", "awcontext", "aftx", "afcu", "avalbc", "akcas", " avcontext", "avci", "avcmp", "afbc", "AVcu", " avci", " avcmp", "afcas", "avpkg", " avcu", "akctx", "avalctx", "navcontext", "avtx", "navctx", "navci", "afcmp", "afctx", "avcb", "navcb", "akcontext", "awpkg", "afcb", "awcmp", "avbc", "avcas", "AVtx", "AVcontext", "AVcmp", "avcontext", "akbc", "avalcontext", "avalcas", "afci", " avcb"], "s": ["uns", "conf", "d", "v", "states", "ps", "sb", "sym", "as", "f", "os", "strings", "this", "js", "l", "sites", "is", "si", "qs", "o", "p", "ins", "se", "stats", "data", "ses", "args", "features", "b", "sg", "u", "ops", "sync", "S", "r", "settings", "cs", "ctx", "ssl", "south", "new", "m", "sq", "session", "w", "service", "g", "your", "us", "spec", "ks", "es", "gs", "t", "native", "aws", "ss", "e", "ls", "ds", "xs", "fs", "ms", "su", "sets", "ts", "ns", "n", "ims", "services", "a", "sys", "c", "rs", "in", "self", "vs", "its"], "i": ["hi", "line", "chi", "ui", "anti", "part", "io", "req", "idi", "l", "fi", "si", "j", "uri", "o", "y", "p", "ci", "key", "multi", "qi", "module", "eni", "d", "oi", "m", "interface", "mi", "ori", "id", "adi", "ri", "ini", "ii", "v", "bi", "a", "x", "li", "iu", "ie", "c", "zi", "di", "ix", "ai", "info", "abi", "init", "pi", "mu", "gi", "f", "u", "b", "ti", "ip", "range", "ni", "e", "xi", "I", "it", "iv", "yi"]}}
{"project": "FFmpeg", "commit_id": "478f1c3d5e5463a284ea7efecfc62d47ba3be11a", "target": 1, "func": "static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int n, i, r, g, b;\n\n\n\n    if ((length % 3) != 0 || length > 256 * 3)\n\n        return AVERROR_INVALIDDATA;\n\n    /* read the palette */\n\n    n = length / 3;\n\n    for (i = 0; i < n; i++) {\n\n        r = bytestream2_get_byte(&s->gb);\n\n        g = bytestream2_get_byte(&s->gb);\n\n        b = bytestream2_get_byte(&s->gb);\n\n        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;\n\n    }\n\n    for (; i < 256; i++)\n\n        s->palette[i] = (0xFFU << 24);\n\n    s->state |= PNG_PLTE;\n\n    bytestream2_skip(&s->gb, 4);     /* crc */\n\n\n\n    return 0;\n\n}\n", "idx": 265, "substitutes": {"avctx": ["afcontext", " avchan", "Avgpu", "Avcontext", "avgpu", "afctx", "afgpu", "avcontext", "Avchan", " avgpu", "avchan", "Avctx", " avcontext", "afchan"], "s": ["times", "S", "fs", "su", "sets", "ts", "ns", "settings", "sup", "cs", "si", "ctx", "is", "l", "ssl", "qs", "o", "p", "d", "m", "sq", "session", "words", "sa", "ans", "sg", "a", "services", "sys", "sie", "service", "css", "ps", "us", "ses", "sf", "spec", "c", "rs", "sb", "self", "es", "ks", "info", "gs", "args", "vs", "t", "f", "os", "parts", "u", "as", "aws", "ss", "side", "e", "ls", "its", "js", "ops", "ds", "bis", "sync", "sl"], "length": ["jo", "total", "form", "section", "l", "padding", "code", "sh", "p", "number", "delay", "d", "se", "sequence", "limit", "buffer", "id", "word", "time", "dy", "k", "len", "Length", "slice", "count", "full", "th", "distance", "position", "data", "duration", "shape", "c", "url", "body", "library", "always", "ength", "block", "style", "angle", "f", "size", "sl", "path"], "n": ["fn", " N", "l", "ns", "un", "j", "num", "o", "p", "nd", "nn", "nor", "d", "m", "adj", "z", "sn", "w", "k", "len", "an", "v", "nb", "ne", "dn", "c", "nt", "nu", "nc", "pn", "t", "f", "u", "na", "max", "ni", "N", "e", "x", "net", "en"], "i": ["ui", "io", "l", "si", "is", "j", "uri", "o", "y", "p", "ci", "key", "multi", "qi", "eni", "d", "m", "oi", "cli", "mi", "id", "I", "api", "z", "ri", "k", "ini", "ii", "v", "bi", "li", "ami", "iu", "ie", "c", "zi", "inner", "di", "ix", "ai", "info", "start", "abi", "pi", "f", "u", "gi", "ti", "ip", "ni", "e", "xi", "x", "it", "phi", "index"], "r": ["rb", "cr", "rr", "gr", "sr", "pr", "rh", "l", "rc", "j", "er", "o", "rx", "p", "R", "dr", "d", "m", "ro", "w", "mr", "ri", "k", "v", "rd", "ur", "c", "rs", "rg", "ar", "nr", "ru", "f", "u", "rl", "q", "range", "e", "re", "lr", "x", "h", "br"], "g": ["gr", "l", "ge", "gh", "p", "ig", "bg", "group", "d", "m", "ga", "gp", "w", "k", "gn", "v", "og", "G", "ag", "c", "rg", "gm", "gb", "gg", "gy", "gs", "ng", "gi", "sg", "u", "f", "gam", "q", "e", "x", "mg", "h", "msg", "pg"], "b": ["be", "rb", "base", "l", "xb", "pb", "bb", "bd", "y", "lib", "o", "p", "B", "ab", "d", "bs", "z", "w", "fb", "k", "ba", "mb", "v", "beta", "a", "nb", "bar", "eb", "abb", "c", "sb", "ob", "gb", "boot", "db", "f", "u", "e", "emb", "x", "lb", "h"]}}
{"project": "qemu", "commit_id": "09cd058a2cf77bb7a3b10ff93c1f80ed88bca364", "target": 1, "func": "static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr,\n\n                                    uint64_t value, unsigned size,\n\n                                    MemTxAttrs attrs)\n\n{\n\n    int ret = 0;\n\n    MSIMessage from = {0}, to = {0};\n\n\n\n    from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST;\n\n    from.data = (uint32_t) value;\n\n\n\n    ret = vtd_interrupt_remap_msi(opaque, &from, &to);\n\n    if (ret) {\n\n        /* TODO: report error */\n\n        VTD_DPRINTF(GENERAL, \"int remap fail for addr 0x%\"PRIx64\n\n                    \" data 0x%\"PRIx32, from.address, from.data);\n\n        /* Drop this interrupt */\n\n        return MEMTX_ERROR;\n\n    }\n\n\n\n    VTD_DPRINTF(IR, \"delivering MSI 0x%\"PRIx64\":0x%\"PRIx32\n\n                \" for device sid 0x%04x\",\n\n                to.address, to.data, sid);\n\n\n\n    if (dma_memory_write(&address_space_memory, to.address,\n\n                         &to.data, size)) {\n\n        VTD_DPRINTF(GENERAL, \"error: fail to write 0x%\"PRIx64\n\n                    \" value 0x%\"PRIx32, to.address, to.data);\n\n    }\n\n\n\n    return MEMTX_OK;\n\n}\n", "idx": 272, "substitutes": {"opaque": ["iopaque", "oplaque", "oplec", "oplairo", "opec", "iopec", "opairo", "OPec", "oplcoe", "copc", " opc", " Opsea", "opsea", "OPairo", "opc", "OPaque", "opcoe", " opsea", " Opc", " Opaque", "OPcoe", "copaque", "iopairo", "iopcoe", "copsea"], "addr": ["host", "offset", "val", "mac", "base", "attr", "hop", "rc", "ptr", "device", " address", "ref", "src", "alias", "config", "name", "id", "ad", "len", "mode", "pos", "prefix", "type", "x", "data", "add", "ast", "work", "nr", "pair", "start", "ace", "amp", "ip", "address", "Address", "pointer", "index"], "value": ["val", "offset", "values", "alloc", "valid", "key", "number", "write", "byte", "Value", "name", "memory", "buffer", "fee", "age", "store", "v", "end", "format", "prefix", "type", "data", "length", "VALUE", "server", "port", "to", "complete", "reg", "amount", "start", "flow", "version", "range", "address", "set", "message", "index"], "size": ["offset", "val", "scale", "from", " address", "security", "name", "id", "sum", "fee", " length", "capacity", "len", "mode", "type", "data", "length", "ize", "small", "max", "storage", "set", "address", " Size", "empty", "timeout", "SIZE", "s", "Size", "desc"], "attrs": [" attds", " attr", "Attr", "attributes", "attr", "acr", " attributes", "acributes", "acrs", "Attrs", "attds", "Attributes", "Attds", "acds"]}}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "void st_flush_trace_buffer(void)\n\n{\n\n    if (trace_file_enabled) {\n\n        flush_trace_file();\n\n    }\n\n\n\n    /* Discard written trace records */\n\n    trace_idx = 0;\n\n}\n", "idx": 280, "substitutes": {}}
{"project": "qemu", "commit_id": "6a84cb1f2822e494839b93dd8c7f7f8fa6c261a9", "target": 0, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,\n\n                              char **serial)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!conf->bs) {\n\n        error_report(\"virtio-blk-pci: drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(conf->bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!*serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(conf->bs);\n\n        if (*dinfo->serial) {\n\n            *serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = conf->bs;\n\n    s->conf = conf;\n\n    s->serial = *serial;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 289, "substitutes": {"dev": ["comment", "dd", "cache", "diff", "gr", "priv", "sync", "error", "device", "def", "google", "de", "temp", "sh", "ve", "debug", "DEV", "d", "w", "vol", "ds", "prom", "v", "conn", "g", "data", "pro", "spec", "Dev", "gd", "di", "prof", "flow", "info", "ch", "block", "dem", "os", "der", "err", "ver", "client", "ev", "hw", "dom"], "conf": ["Conf", "comment", "host", "cal", "cache", "fs", "cr", "cc", "res", "bug", "req", "com", "sc", "cf", "sch", "def", "rc", "fi", "cs", "ram", "ctx", "fab", "hz", "conv", "aff", "cell", "core", "ssl", "ci", "exec", "ref", "param", "config", "bs", "acc", "sum", "sub", "pub", "con", "py", "cp", "fam", "conn", "ca", "cons", "co", "sh", "g", "cn", "lc", "spec", "c", "app", " Conf", "arch", "reg", "info", "ch", "init", "cb", "ck", "f", "cl", "bc", "cfg", "client", "cm", "cd"], "serial": ["driver", "Serial", "spot", "series", "smart", "mobile", "private", "pixel", "alias", "vision", "primary", "micro", "template", "power", "boot", "iv", "random", "material", "error", "object", "si", "normal", "valid", "color", "remote", "mode", "unknown", "kid", "secret", "flash", "sex", "pocket", "specific", "custom", "sync", "comment", "zip", "ident", "standard", "io", "patch", "device", "iso", "public", "location", "quant", "usb", "length", "server", "spec", "cho", "ser", "general", "special", "global", "address", "sql", "path", "specified", "model", "loc", "rc", "binary", "id", "vol", "phone", "digital", "prefix", "type", "erial", "coll", "initial", "util", "original", "local", "version", "regular", "resource", "pass", "instance"], "s": ["i", "uns", "sim", "d", "sum", "sa", "stat", "v", "ves", "states", "ps", "secondary", "sb", "sym", "os", "f", "js", "comments", "l", "si", "is", "o", "qs", "p", "stats", "ses", "site", "args", "b", "sg", "u", "sk", "sup", "sync", "h", "S", "r", "hs", "settings", "cs", "ssl", "south", "new", "m", "sq", "session", "w", "full", "service", "g", "us", "server", "spec", "ks", "gs", "t", "ss", "e", "sl", "ls", "ds", "request", "fs", "su", "ts", "ns", "j", "n", "services", "sys", "sf", "c", "rs", "self", "storage", "client"], "cylinders": ["sharks", "culinder", "skarks", "ellisters", "humriers", "skisters", "skasts", "cilinder", "cilriers", "shinders", "cylinder", "ellarks", "cylriers", "culovies", "culriers", "culinders", "ellasts", "humovies", "cylisters", "cilovies", "skinders", "cilinders", "shasts", "shisters", "cylarks", "huminders", "huminder", "cylasts", "ellinders", "cylovies"], "heads": ["HEAD", "comments", "pages", "plugins", "types", "olds", "height", "bits", "rows", "ids", "head", "blocks", "opens", "loads", "jobs", "mods", "versions", "boxes", "frames", "ks", "devices", "hops", "obs", "outs", "depth", "views", "tails", "shows", "locks", "reads", "features", "links", "headers", "ashes", "checks", "holes"], "secs": ["Secs", "reqseconds", "Seccs", "threadp", "reqp", "threadses", "Secses", "secseconds", "reqsets", "descsets", "secp", " secseconds", "descs", "constses", "threads", "descp", "secses", "descseconds", "constp", "constcs", "Secp", "threadcs", "reqs", "secsets", " secsets", " secp", "consts", "seccs"], "virtio_blk_id": ["virtio_blk_name", "virtio_blkt_type", "virtio_blck_info", "virtio_blck_id", "virtio_blk_type", "virtio_blkt_f", "virtio_blkt_id", "virtio_blck_ids", "virtio_blk_ids", "virtio_blk_info", "virtio_blkt_name", "virtio_blck_name", "virtio_blk_f"], "dinfo": ["rinf", "did", "rInfo", "finfo", " dhandler", "rinfo", " dinf", "finf", "fdhandler", "bderror", "derror", "sdinfo", "lInfo", "bdinf", "fdvar", "ldfo", "dInfo", " dInfo", "ldata", " did", "sdinf", " derror", "dvar", "dhandler", "fdinf", " dvar", " dfo", "ldid", "linfo", "cdfo", "dinf", "dfo", "bdinfo", "ldinfo", "fdinfo", "fInfo", "sdhandler", "linf", "sdvar", "cddata", "cdinfo", "ddata", " ddata", "cdid", "lddata", "bdInfo", "rdata"]}}
{"project": "qemu", "commit_id": "0647d47cc184da587c76743546b6af6dfdb8f1da", "target": 1, "func": "static size_t header_ext_add(char *buf, uint32_t magic, const void *s,\n\n    size_t len, size_t buflen)\n\n{\n\n    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;\n\n    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);\n\n\n\n    if (buflen < ext_len) {\n\n        return -ENOSPC;\n\n    }\n\n\n\n    *ext_backing_fmt = (QCowExtension) {\n\n        .magic  = cpu_to_be32(magic),\n\n        .len    = cpu_to_be32(len),\n\n    };\n\n    memcpy(buf + sizeof(QCowExtension), s, len);\n\n\n\n    return ext_len;\n\n}\n", "idx": 304, "substitutes": {"buf": ["bf", "rb", "home", "buff", "cf", "rc", "fi", "pb", "ctx", "img", "alloc", "fp", "tmp", "src", "ab", "queue", "buffer", "Buffer", "vec", "fb", "cv", "cp", "func", "fd", "data", "batch", "uf", "port", "fw", "bag", "pool", "bh", "result", "block", "cb", "abi", "que", "b", "cmd", "f", "cur", "wb", "aux", "bc", "cas", "uc", "msg", "seq", "br"], "magic": ["md", "xxx", "serial", "offset", "cache", "dc", "random", "io", "base", "gen", "fi", "binary", "padding", "math", "kind", "mag", "complex", "seq", "ec", "cli", "icon", "memory", "mic", "api", "MAG", "stat", "ini", "format", "mini", "prefix", "gz", "data", "afi", "length", "spec", "c", "util", "special", "parser", "info", "ix", "generic", "init", "phy", "style", "meta", "cmd", "extra", "Magic", "big", "pointer", "anta"], "s": ["S", "i", "fs", "r", "ns", "l", "cs", "si", "is", "n", "p", "d", "m", "sq", "session", "z", "v", "a", "sys", "service", "g", "us", "spec", "sb", "c", "rs", "self", "b", "f", "u", "os", "ss", "size", "sl", "e", "ls", "bytes"], "len": ["fn", "line", "val", "offset", "part", "base", "loc", "l", "gen", "fi", "cs", "low", "lim", "lon", "lib", "num", "le", "lin", "seq", "fin", "fl", "mem", "lang", "L", "rev", "n", "limit", "ln", "z", "vec", "hl", "Len", "lit", "v", "pos", "el", "li", "ann", "lan", "ler", "ie", "length", "fun", "inn", "ll", "kl", "la", "bin", "f", "size", "sl", "bl", "ls", "e", "lf", "lc", "en"], "buflen": ["buFlend", "bufrot", "bullen", "buflot", "buclade", "bullend", "buflenc", "bucleng", "cucleng", "cuclenc", "fuflot", "buflon", "buFLeng", "bufrend", "buFlen", "fuflon", "cuflade", "buflend", "fuflend", "cuflen", "fuflen", "cuclen", "buFlenc", "buFleng", "buflade", "buFLenc", "bufren", "bufron", "buFlon", "fuFlot", "cuflenc", "fuFlon", "buclen", "bullon", "buFLen", "cuclade", "buclenc", "bullot", "cufleng", "buFlot", "fuFlen", "bufleng", "fuFlend", "buFLade", "buFlade"], "ext_backing_fmt": ["ext_backing_formMT", "ext_backing_Fnt", "ext_backing_defformat", "ext_backing_fitter", "ext_backing_forract", "ext_backing_FMT", "ext_backing_Fformat", "ext_backing_formract", "ext_backing_formnt", "ext_backing_fformat", "ext_backing_fornt", "ext_backing_Fitter", "ext_backing_formformat", "ext_backing_formt", "ext_backing_Fmt", "ext_backing_fMT", "ext_backing_defnt", "ext_backing_Fract", "ext_backing_formitter", "ext_backing_forMT", "ext_backing_formmt", "ext_backing_defmt", "ext_backing_fract", "ext_backing_fnt", "ext_backing_defitter"]}}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    if (atom.size <= 40)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n\n\n    if ((uint64_t)atom.size > (1<<30))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    av_free(st->codec->extradata);\n\n    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!st->codec->extradata)\n\n        return AVERROR(ENOMEM);\n\n    st->codec->extradata_size = atom.size - 40;\n\n    avio_skip(pb, 40);\n\n    avio_read(pb, st->codec->extradata, atom.size - 40);\n\n    return 0;\n\n}\n", "idx": 305, "substitutes": {"c": ["cu", "cache", "dc", "cc", "cit", "cr", "cy", "sc", "cf", "ac", "l", "fc", "cs", "enc", "ctx", "conf", "icc", "p", "ci", "vc", "ce", "ic", "ec", "xc", "ct", "s", "tc", "con", "cv", "cp", "lc", "pc", "ca", "co", "coll", "ctrl", "nc", "h", "ch", "mc", "t", "f", "cl", "u", "cur", "C", "e", "cont", "bc", "uc", "cm", "anc", "cd", "cus"], "pb": ["bf", "rb", "lp", "tp", "bp", "bm", "prot", "cpp", "xb", "ctx", "fc", "pl", "p", "fp", "pd", "tmp", "pt", "bps", "ab", "obj", "typ", "api", "fb", "ppa", "cp", "pc", "eb", "pro", "hub", "sb", "pp", "bh", "jp", "aph", "cb", "db", "b", "pa", "rob", "dp", "bc", "lb", "cm", "uc", "lc", "PB", "pg"], "atom": ["tm", "bc", "material", "com", "base", "attr", "fac", "fab", "container", "um", "object", "orb", "month", "num", "temp", "arc", "cell", "mag", "null", "xml", "car", "param", "at", "monitor", "ab", "module", "chem", "term", "m", "config", "acl", "typ", "obj", "source", "wp", "mom", "canon", "bn", "operator", "element", "an", "a", "account", "type", "data", "prop", "arm", "chrom", "perm", "plane", "app", "item", "url", "np", "asm", "sym", "arb", "image", "om", "b", "tom", "op", "amp", "article", "orbit", "instance", "emb", "x", "http", "atomic", "cm", "dom", "art"], "st": ["fr", "ost", "sw", "cr", "sth", "r", "ste", "inst", "sc", "l", "fc", "ptr", "sec", "pt", "nd", "src", "St", "sta", "se", "stage", "sn", "rest", " est", "sa", "ad", "fe", "ld", "ut", "stop", "stream", "end", "est", "str", "ST", "sp", "ast", "ust", "sb", "nt", "pp", "start", "kt", "ist", "ace", "std", "t", "sd", "b", "cl", "sts", "amp", "ft", "this", "ss", "sl", "bl", "ct", "lc", "s", "art"]}}
{"project": "qemu", "commit_id": "89ae337acbe4dba5b2481007aec1277252d2b86c", "target": 0, "func": "static void mem_begin(MemoryListener *listener)\n\n{\n\n    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);\n\n\n\n    d->phys_map.ptr = PHYS_MAP_NODE_NIL;\n\n}\n", "idx": 321, "substitutes": {"listener": ["intener", "Listiner", "clener", "parenter", "Listener", "latender", "lister", "parenteners", "latest", "latceiver", "listiner", "intiner", "Listend", "Listencer", "clest", "listeners", "latener", " listend", "cleners", "listend", "listest", "intend", "intencer", "listceiver", " listceiver", "parentceiver", "listender", "parentener", "lateners", "parentender", " listeners", " lister", "parentest", "clender", " listencer", "listencer", " listiner", "later"], "d": ["md", "dd", "dad", "i", "dc", "did", "od", "r", "ded", "l", "j", "n", "bd", "p", "pd", "nd", "dm", "ind", "dr", "m", "dat", "id", "ad", "dy", "ld", "v", "rd", "fd", "D", "dn", "xd", "c", "dt", "gd", "dh", "t", "sd", " D", "f", "b", " dd", "da", "e", "ds", "ade"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)\n\n{\n\n    uint32_t rgb = 0;\n\n\n\n    if (bpp == 32) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;\n\n        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;\n\n        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;\n\n        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;\n\n    }\n\n    if (bpp == 16) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;\n\n        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;\n\n    }\n\n    return rgb;\n\n}\n", "idx": 325, "substitutes": {"bpp": ["lpp", "lcp", "bpc", "abbpps", "bmp", "rbpp", " bmp", "bPP", "abbpc", "lgp", "abbpp", "ebpps", "ebPP", "bcp", "fpps", "abbPP", " bcp", "ebpc", " bgp", " bPP", "fpp", "fupp", " bpps", "bgp", "bpps", "ppps", "rbgp", "rbcp", "pcp", "bupp", "fcp", "lmp", "ppp", " bupp", " bpc", "rbmp", "pupp", "ebpp"], "buf": ["tab", "uv", "rb", "aka", "home", "cache", "text", "mac", "buff", "loc", "cf", "fab", "comb", "ptr", "context", "grad", "img", "ctx", "bd", "conv", "begin", "alloc", "ha", "font", "src", "ab", "usr", "config", "queue", "buffer", "plug", "Buffer", "vec", "pub", "fb", "off", "cv", "func", "dest", "feat", "Buff", "data", "window", "uf", "border", "bag", "ph", "band", "map", "gb", "block", "cb", "book", "cap", "proc", "db", "box", "cmd", "bin", "b", "que", "cur", "wb", "uint", "bc", "uc", "msg", "path"]}}
{"project": "qemu", "commit_id": "fac7d7b1cdb21f921d7ac396365f5e920ef03096", "target": 1, "func": "int net_init_tap(const Netdev *netdev, const char *name,\n\n                 NetClientState *peer, Error **errp)\n\n{\n\n    const NetdevTapOptions *tap;\n\n    int fd, vnet_hdr = 0, i = 0, queues;\n\n    /* for the no-fd, no-helper case */\n\n    const char *script = NULL; /* suppress wrong \"uninit'd use\" gcc warning */\n\n    const char *downscript = NULL;\n\n    Error *err = NULL;\n\n    const char *vhostfdname;\n\n    char ifname[128];\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_TAP);\n\n    tap = &netdev->u.tap;\n\n    queues = tap->has_queues ? tap->queues : 1;\n\n    vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL;\n\n\n\n    /* QEMU vlans does not support multiqueue tap, in this case peer is set.\n\n     * For -netdev, peer is always NULL. */\n\n    if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) {\n\n        error_setg(errp, \"Multiqueue tap cannot be used with QEMU vlans\");\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_fds || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, fds=, and vhostfds= \"\n\n                       \"are invalid with fd=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = monitor_fd_param(cur_mon, tap->fd, &err);\n\n        if (fd == -1) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"tap\", name, NULL,\n\n                         script, downscript,\n\n                         vhostfdname, vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n    } else if (tap->has_fds) {\n\n        char **fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        int nfds, nvhosts;\n\n\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_vhostfd) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, and vhostfd= \"\n\n                       \"are invalid with fds=\");\n\n            return -1;\n\n        }\n\n\n\n        nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES);\n\n        if (tap->has_vhostfds) {\n\n            nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES);\n\n            if (nfds != nvhosts) {\n\n                error_setg(errp, \"The number of fds passed does not match \"\n\n                           \"the number of vhostfds passed\");\n\n                goto free_fail;\n\n            }\n\n        }\n\n\n\n        for (i = 0; i < nfds; i++) {\n\n            fd = monitor_fd_param(cur_mon, fds[i], &err);\n\n            if (fd == -1) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n\n\n            fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n            if (i == 0) {\n\n                vnet_hdr = tap_probe_vnet_hdr(fd);\n\n            } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) {\n\n                error_setg(errp,\n\n                           \"vnet_hdr not consistent across given tap fds\");\n\n                goto free_fail;\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             script, downscript,\n\n                             tap->has_vhostfds ? vhost_fds[i] : NULL,\n\n                             vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return 0;\n\n\n\nfree_fail:\n\n        for (i = 0; i < nfds; i++) {\n\n            g_free(fds[i]);\n\n            g_free(vhost_fds[i]);\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return -1;\n\n    } else if (tap->has_helper) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"queues=, and vhostfds= are invalid with helper=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = net_bridge_run_helper(tap->helper,\n\n                                   tap->has_br ?\n\n                                   tap->br : DEFAULT_BRIDGE_INTERFACE,\n\n                                   errp);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"bridge\", name, ifname,\n\n                         script, downscript, vhostfdname,\n\n                         vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            close(fd);\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (tap->has_vhostfds) {\n\n            error_setg(errp, \"vhostfds= is invalid if fds= wasn't specified\");\n\n            return -1;\n\n        }\n\n        script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT;\n\n        downscript = tap->has_downscript ? tap->downscript :\n\n            DEFAULT_NETWORK_DOWN_SCRIPT;\n\n\n\n        if (tap->has_ifname) {\n\n            pstrcpy(ifname, sizeof ifname, tap->ifname);\n\n        } else {\n\n            ifname[0] = '\\0';\n\n        }\n\n\n\n        for (i = 0; i < queues; i++) {\n\n            fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? \"no\" : script,\n\n                              ifname, sizeof ifname, queues > 1, errp);\n\n            if (fd == -1) {\n\n                return -1;\n\n            }\n\n\n\n            if (queues > 1 && i == 0 && !tap->has_ifname) {\n\n                if (tap_fd_get_ifname(fd, ifname)) {\n\n                    error_setg(errp, \"Fail to get ifname\");\n\n                    close(fd);\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             i >= 1 ? \"no\" : script,\n\n                             i >= 1 ? \"no\" : downscript,\n\n                             vhostfdname, vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                close(fd);\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 338, "substitutes": {"netdev": ["networkdi", " netdi", "nede", "etdev", " netconn", " netclient", "networkde", "etdi", "netDev", "natDev", " netDev", "neconn", "netconn", "nedevice", "natdev", "tundev", "etdevice", "tundevice", "natclient", "etev", "netclient", "natdevice", "networkdev", "netdevice", "tunclient", " netde", "networkev", "nedev", "netde", " netdevice", "networkconn", "netdi", "networkdevice", " netev", "netev", "tunDev"], "name": ["comment", "family", "nm", "code", "profile", "n", "temp", "new", "Name", "connection", "alias", "node", "names", "nam", "call", "id", "session", "time", "prefix", "type", "description", "parent", "server", "package", "test", "info", "cap", "none", "version", "amp", "ip", "NAME", "address", "size", "username", "client", "path", "filename"], "peer": ["user", "host", "cache", "tp", "socket", "pkg", "worker", "attr", "device", "chain", "ptr", "er", "ssl", "ep", "p", "trace", "stack", "fork", "root", "node", "remote", "pipe", "snap", "tg", "pe", "mode", "pod", "master", "tc", "conn", "type", "pc", "sys", "owner", "parent", "server", "package", "port", "pool", "pp", "self", "scope", "trap", "shared", "layer", "channel", "state", "proc", "player", "cur", "ip", "slave", "instance", "addr", "inner", "client", "pointer", "request"], "errp": [" errps", "errorf", "Errorps", "acerpa", "errr", "erps", " errf", "iterp", "errpr", "Errorp", "rrl", "erP", "errP", "orderp", "ErrorP", "orderf", "Errorr", "erpa", "errpc", "acerr", " errl", "iterl", "erp", "rrP", "errorr", "erpr", "rorpr", "acerp", " errpc", " errP", "rrf", "derf", "errl", "rorpa", "errorpc", "derpc", "acerpr", "erpc", "errf", "iterP", "rorr", "iterf", " errr", "errpa", "derr", "derp", "erf", "errorp", "orderr", "rrp", "errps", "rorp", "orderpc"], "tap": ["enter", "setup", "comb", "tim", "pb", "temp", "touch", "tf", "wp", "dra", "ppa", "wt", "sp", "ping", "jp", "atom", "cap", "php", "gap", "this", "wa", "Tap", "tw", "tr", "ta", "xml", "p", "trace", "hap", "tip", "chat", "typ", "tk", "dat", "python", "taker", "capt", "app", "pp", "task", "tin", "pot", "tm", "track", "tp", "transform", "mp", "project", "bp", "ptr", "apper", "pipe", "pin", "tick", "session", "snap", "tg", "pod", "pad", "wat", "conn", "pc", "td", "ap", "hook", "t", "trip", "amp", "kin", "ten", "opa", "ts", "tool", "each", "ga", "api", "pe", "tc", "skip", "wal", "tu", "submit", "also", "ticket", "np", "trap", "di", "flow", "pa", "tif"], "fd": ["fn", "md", "ctl", "vd", "dd", "FD", "bf", "dc", "ds", "wd", "fs", "socket", "diff", " fid", "cond", "cf", "fc", "fi", "dB", "dir", "dl", "bd", "fp", "wait", "pd", "fin", "nd", "fl", "ff", "pipe", "d", "fat", "pid", "ln", "fee", "buf", "dy", "fb", "fm", "len", "df", "handler", "fen", "ld", "dim", "wat", "stream", "writer", "xf", "dn", "xd", "td", "fun", "fw", "sf", "dt", "fa", "fed", "flow", "seed", "draft", "cb", "fx", "hd", "sd", " f", "f", "db", "da", " FD", " df", "bind", "ffff", "lf", "fe"], "queues": ["qures", "Queues", " queures", "queueue", "peues", "quries", "Queures", "queueues", "qients", "queueures", "queue", "queients", "quues", "queins", "ques", "peins", " queue", "quures", " queries", "peients", "peries", "que", "quients", "queries", "Queue", "queures", "quins", "qries", "quue", "qins"], "script": ["ctl", "comment", "draw", "xxx", "password", "setup", "sc", "secure", " scripts", "code", "ssl", "sh", "lib", "command", "exec", "document", "cript", "cli", "config", "sq", "session", "fee", "scroll", "slice", "prefix", "func", "writer", "sign", "sudo", "scope", "test", "init", "tx", "style", "inc", "Script", "scripts", "client", "sync", "seq"], "downscript": ["upstyle", "DOWNscripts", "downscripts", "upScript", "upscript", "downstyle", " downstyle", " downscripts", "upexec", " downexec", "DOWNexec", "downScript", "DOWNstyle", "DOWNscript", " downScript", "upscripts", "downexec", "DOWNScript"], "err": ["fr", "oller", "rb", "cr", "rr", "diff", "gr", "ir", "bug", "rh", "r", "req", "error", "cf", "pr", "yer", "fi", "grad", "icer", "resp", "er", "wr", "Er", "arr", "runner", "rage", "nor", "dr", "rev", "eor", "iter", "mr", "rar", "erer", "fee", "raise", " er", "org", "aa", "Error", "gz", "rm", "str", "later", " error", "ler", "ise", "kr", "aster", "nr", "orr", "exc", "result", "rn", "phy", "nil", "aaa", "der", "magic", "doc", "range", "ver", "lr", "e", "ev", "msg", "order", "acer"], "vhostfdname": ["vhostdnumber", "vhostFDnumber", "vhostFDname", "vhostfName", "vHostFDnam", "vHostfdn", "vhostfdnam", "vHostfname", "vhostdfnam", "vhostdn", "vhostdnames", "vhostFDnam", "vHostFDnumber", "vhostdfno", "vHostfdnames", "vHostfdname", "vhostddnames", "vHostfName", "vHostfdName", "vHostfno", "vhostdfName", "vhostdfname", "vhostdno", "vhostfno", "vHostfnames", "vhostddnumber", "vhostfnam", "vHostfdnumber", "vHostFDno", "vhostfdName", "vHostFDnames", "vhostddn", "vhostFDno", "vhostfdn", "vhostfname", "vHostfdnam", "vhostFDName", "vHostfdno", "vhostfnames", "vhostFDn", "vhostfdno", "vHostFDname", "vHostFDName", "vhostFDnames", "vhostdname", "vhostddname", "vhostfdnumber", "vhostfdnames", "vhostdName", "vHostFDn"], "ifname": ["defkey", " ifn", "IFname", "ifn", "IFkey", "IFn", "defname", "defn", " ifid", "ifid", "IFid", "defid", " ifkey", "ifkey"], "fds": ["fns", "hded", "hns", "hds", "cfds", " fcs", "cfcs", " fded", "hcs", "fcs", "fded", "cfns", "cfded", " fns"], "vhost_fds": ["vhost_rfrs", "vhost_fns", "vhost_rfns", "vhost_fks", "vhost_rfds", "vhost_hrs", "vhost_hns", "vhost_rfks", "vhost_hds", "vhost_frs", "vhost_hks"], "nfds": ["_", "r", "function", "new", "d", "config", "id", "func", "g", "proc"], "i": ["io", "si", "uri", "n", "sid", "ci", "ind", "cli", "pid", "id", "ini", "ii", "slice", "iu", "c", "in", "di", "ix", "ai", "init", "pi", "f", "ip", "xi", "I", "phi", "pointer", "index"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "void stream_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, const char *backing_file_str,\n\n                  int64_t speed, BlockdevOnError on_error,\n\n                  BlockCompletionFunc *cb, void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n\n\n    s = block_job_create(job_id, &stream_job_driver, bs, speed,\n\n                         cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n    s->common.co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n", "idx": 369, "substitutes": {"job_id": ["job_type", "jobEkid", " job_num", "block_id", "block_ID", "jobEids", "block_kid", "jobEID", "job_kid", " job_type", "job_num", "job_ID", " job_name", "job_name", "job_ids", "jobEid", "block_ids"], "bs": ["fs", "bc", "BS", "ns", "cs", "pb", "ctx", "bb", "fps", "builder", "bps", "ib", "src", "blocks", "buf", "bos", "fb", "stats", "ps", "ses", "sb", "rs", "es", "obs", "gb", "ob", "bh", "gs", "vs", "db", "b", "os", "bas", "ss", "js", "ls", "bis", "bid", "lb", "ds"], "base": ["family", "cache", "bc", "home", "fs", "back", "l", "settings", "padding", "cs", "ctx", "uri", "core", "builder", "null", "o", "p", "background", "src", "root", "proxy", "name", "id", "buffer", "status", "store", "area", "full", "ase", "v", "bi", "x", "prefix", "based", "Base", "server", "work", "c", "site", "body", "pre", "origin", " b", "local", "state", "db", "b", "f", "os", "storage", "address", "bas", "slave", "e", "sl", "bid", "http", "client", "sync", "source"], "backing_file_str": ["backing_file_name", "backing_files_path", "backing_files_char", "backing_file_char", "backing_files_str", "backing_files_name", "backing_files_string", "backing_file_path", "backing_file__str", "backing_file_string", "backing_file__string", "backing_file__name", "backing_file__path"], "speed": ["driver", "offset", "fast", "scale", "ota", "error", "sc", "secure", "slow", "settings", "grade", "fps", "si", "bps", "security", "enabled", " speeds", "byte", "name", "send", "status", "engine", "Speed", "slice", "stream", "type", "service", "peed", "length", "server", "spec", "sf", "start", "weight", "seed", "state", "performance", "rate", "level", "ss", "size", "score", "sync", "source"], "on_error": ["onalerror", "on_ror", "onalcall", "onalfail", " on_ror", "onayevent", "on_fail", "onayerr", "onalerr", " on_call", "on_call", "on_err", "on_offset", " on_err", "on_event", "onayerror", "onayror", " on_fail", "onaloffset", " on_offset", " on_event"], "cb": ["fn", "bf", "rb", "cache", "buff", "cf", "fc", "cs", "pb", "bb", "ctx", "code", "function", "conf", "fp", "exec", "kk", "src", "ec", "call", "buf", "cgi", "unc", "cv", "cp", "func", "pc", "ca", "co", "callback", "fun", "c", "sb", "cow", "db", "b", "f", "bc", "cm", "seq", "CB"], "opaque": ["iopaque", "iopc", "iopace", "pque", "opatile", "posque", "pacity", "copacity", "opace", " opace", "ipaque", "opque", " opque", "ipatile", " opatile", "copgate", "copque", "posacity", " opc", "posaque", " opacity", "pc", "opgate", "paque", "opc", "ipacity", "opacity", "pgate", "copatile", "posgate", "copaque", "ipque", "pace"], "errp": [" errps", "errr", "erps", "erP", "errP", "acep", "errlp", "acepc", " errlp", "errpc", "erp", " errpc", " errP", "acelp", "aceps", "erpc", " errr", "erlp", "err", "aceP", "errps", "acer"], "s": ["i", "uns", "d", "an", "v", "states", "ps", "sb", "sym", "os", "f", "js", "so", "comments", "l", "is", "si", "o", "qs", "p", "se", "css", "ses", "b", "sg", "u", "sk", "ops", "sup", "sync", "h", "S", "r", "hs", "settings", "cs", "ssl", "sh", "south", "m", "sq", "session", "w", "service", "g", "us", "server", "spec", "es", "gs", "aws", "ss", "e", "ls", "sl", "http", "ds", "sw", "fs", "ms", "su", "sets", "ts", "ns", "n", "services", "a", "sys", "sie", "submit", "sf", "c", "rs", "single", "its"]}}
{"project": "FFmpeg", "commit_id": "1bc64c2814d409d3cc129c27c493ee915bebdc4a", "target": 1, "func": "int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,\n                                              int *got_picture_ptr,\n                                              AVPacket *avpkt)\n{\n    int ret;\n    *got_picture_ptr = 0;\n    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))\n        return -1;\n    avctx->pkt = avpkt;\n    apply_param_change(avctx, avpkt);\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)\n            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,\n                                         avpkt);\n        else {\n            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,\n                                       avpkt);\n            picture->pkt_dts             = avpkt->dts;\n            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;\n            picture->width               = avctx->width;\n            picture->height              = avctx->height;\n            picture->format              = avctx->pix_fmt;\n        }\n        emms_c(); //needed to avoid an emms_c() call before every return;\n        if (*got_picture_ptr)\n            avctx->frame_number++;\n    } else\n        ret = 0;\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n     * make sure it's set correctly */\n    picture->extended_data = picture->data;\n    return ret;\n}", "idx": 372, "substitutes": {"avctx": ["umctx", "avcu", "aflc", "AVctx", "afxc", "verlc", "avelc", "abctx", "avalcca", "afcus", "abcf", "avcmp", "avalsys", "amcmp", "umcf", "amctx", "afconn", "avesync", "afcv", "afctx", "avlc", "afctrl", "akcmp", "ajchan", "AVcontext", "averchan", "avctl", "avcontext", "avalcontext", "akcf", "ajctl", "avcca", "avecf", "afctl", "avconn", "avecmp", "avectx", "evcu", "avalctrl", "avesys", "avsys", "avcv", "avecca", "avewcs", "ajcf", "afcas", "ajcus", "auctx", "evcmp", "alctx", "amcu", "avalctx", "akconn", "ajsync", "ajconn", "navctx", "avcf", "avxc", "vercf", "alcf", "akcu", "avctrl", "umcontext", "evcontext", "ajcontext", "AVcmp", "umconn", "evxc", "avcus", "avalcv", "navconn", "avalcu", "abcmp", "ajctx", "navcf", "vercontext", "avalwcs", "abcontext", "akctx", "verctx", "navcontext", "ajctrl", "afcmp", "avwcs", "avecontext", "evctx", "evcas", "aucf", "aucontext", "akcontext", "avercus", "avsync", "afchan", "afwcs", "avecb", "vercas", "ajcv", "afcf", "amcontext", "afcontext", "avercontext", "afsys", "afcu", "afsync", "akxc", "afcca", "avalcb", "vercu", "afca", "avchan", "aveconn", "AVcca", "aucu", "avecv", "ajca", "avcb", "alcontext", "aveca", "afcb", "avecu", "avcas", "alconn", "avca", "averctx", "avectl"], "picture": ["media", "comment", "family", "view", "home", "attribute", "anti", "movie", "pie", "base", "manager", "error", "profile", "ctx", "img", "ana", "gif", "query", "piece", "module", "camera", "config", "cam", "study", "figure", "pic", "definition", "winner", "guide", "import", "sea", "cover", "frame", "file", "pict", "feat", "data", "service", "video", "ami", "photo", "game", "package", "ji", "Picture", "bank", "shadow", "quote", "license", "pause", "library", "plugin", "info", "image", "share", "style", "audio", "large", "feature", "player", "storage", "summary", "statement", "parse", "entry"], "got_picture_ptr": ["got_picturenpointer", "got_image_pointer", "got_picture__addr", "got_profile_addr", "got_picturenaddr", "got_picture_address", "got_picture_offset", "got_picture_pos", "got_profile_reference", "got_picture__offset", "got_profile_pointer", "got_picture__address", "got_picture__pointer", "got_picture_pointer", "got_picture_addr", "got_image_pos", "got_picturenreference", "got_image_addr", "got_profile_ptr", "got_picture_reference", "got_picturenptr", "got_image_struct", "got_picture__ptr", "got_image_offset", "got_image_address", "got_image_ptr", "got_picture_struct"], "avpkt": ["afpke", "avemkt", "avepnt", "avpakt", "ajpkt", "avwke", "akpake", "akpkt", "avipet", "avefpki", "avipetsk", "avpet", "avspiece", "avppke", "ajpetsk", "avfpiece", "avjpkn", "avecpkt", "ajdpsk", "avgpkt", "avlpkt", "avdpet", "avefpkt", "affiece", "affke", "avmeth", "avdpkt", "avspacket", "avepkn", "affct", "akpke", "avcpet", "avpiece", "avfpkh", "avefpkh", "avcpkt", "avipkt", "avcpetsk", "avlpke", "ajdpkt", "avcpiece", "avdpsk", "akpakt", "avipsk", "affacket", "avpaacket", "avfki", "avwacket", "avcpkn", "ajpsk", "avecpqt", "affcht", "avemnt", "avecpkn", "avppacket", "avfcht", "avgpqt", "avcpnt", "avpkn", "avppkt", "avfacket", "avcpqt", "avfke", "avefpacket", "avepqt", "avmiece", "avepacket", "avpdt", "avlpiece", "avcpeth", "avfkt", "avpki", "avfiece", "avjpkt", "avppct", "avdpetsk", "avpetsk", "avdpki", "avfpkt", "avmkt", "avfpcht", "avepkt", "avpcht", "avpacket", "avspkt", "avlpacket", "avpeth", "avgpkn", "avepdt", "avlpnt", "ajpet", "avwkt", "afpiece", "avcpsk", "avdpacket", "avepiece", "avlpeth", "ajdpet", "afpkt", "avspcht", "ajdpetsk", "avepki", "avecpdt", "avfkh", "avpke", "avepkh", "avfpki", "avlpct", "akpcht", "avepeth", "afpacket", "avpnt", "avmnt", "avemiece", "avwcht", "avfpacket", "akpacht", "avfct", "afpcht", "avgpdt", "avjpqt", "avpct", "akpaacket", "avdpkh", "akpacket", "avpacht", "afpct", "avpsk", "avpkh", "avpake", "avcpdt", "affkt", "avjpdt", "avpqt", "avemeth"], "ret": ["bf", "val", "rb", "res", "value", "back", "base", "match", "pet", "rc", "att", "def", "rt", "code", "flag", "num", "alt", "fin", "RET", "ref", "det", "gt", "rev", "job", "et", "len", "lit", "ut", "success", "ur", "rets", "feat", "data", "reply", "mt", "fun", "nt", "reg", "result", "get", "rot", "ure", "arg", "Ret", "f", "ft", "re", "art"], "frame_number": ["video_version", "video_counter", "frame_no", "frame_counter", "frameblockcounter", "frameblockno", "frameblockversion", "frame_version", "video_no", "video_number", "frameblocknumber"]}}
{"project": "qemu", "commit_id": "84a3a53cf61ef691478bd91afa455c801696053c", "target": 1, "func": "static int omap_gpio_init(SysBusDevice *sbd)\n\n{\n\n    DeviceState *dev = DEVICE(sbd);\n\n    struct omap_gpif_s *s = OMAP1_GPIO(dev);\n\n\n\n    if (!s->clk) {\n\n        hw_error(\"omap-gpio: clk not connected\\n\");\n\n    }\n\n    qdev_init_gpio_in(dev, omap_gpio_set, 16);\n\n    qdev_init_gpio_out(dev, s->omap1.handler, 16);\n\n    sysbus_init_irq(sbd, &s->omap1.irq);\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,\n\n                          \"omap.gpio\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    return 0;\n\n}\n", "idx": 373, "substitutes": {"sbd": ["fspd", "sdb", " shd", "fsbb", "syshd", "osbd", " sbb", "sysdb", "osnd", "lsbb", "osfd", "sdd", "wsBD", "jsdd", "dsBD", "wspd", " snd", " scd", "psfd", "jsbd", "ushd", "sbb", " sdd", "lsBD", "sBD", "jshd", "psnd", "dshd", " sdb", " sBD", "usbd", " sfd", "spd", "lspd", "lsbd", "uscd", "sysBD", "psbd", "psbb", "sysbd", "jscd", "dsbd", "osbb", "shd", "scd", "wsbd", "snd", "wsbb", "dsdb", "fsbd", "sfd", "usdd", "fsBD"], "dev": ["driver", "md", "mod", "serial", "dd", "dc", "diff", "die", "req", "des", "device", "def", "de", "grad", "conf", "temp", "o", "ve", "p", "DEV", "exec", "debug", "dm", "d", "cam", "w", "adv", "ad", "bus", "conn", "dis", "g", "data", "Dev", "app", "devices", "self", "gd", "di", "ch", "dem", "sd", "der", "del", "rad", "ds", "ev", "hw", "dom"], "s": ["S", "i", "fs", "su", "r", "ts", "ns", "l", "cs", "is", "uns", "si", "n", "ssl", "o", "south", "p", "d", "m", "session", "w", "an", "v", "services", "sys", "service", "g", "aws", "ps", "server", "ses", "spec", "c", "sb", "rs", "es", "self", "gs", "sym", "args", "t", "sd", "os", "sg", "f", "u", "b", "ss", "js", "e", "sl", "sk", "ls", "side", "ds", "sync", "h"]}}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)\n\n{\n\n    s->codec = slave;\n\n    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];\n\n    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];\n\n}\n", "idx": 391, "substitutes": {"s": ["S", "i", "fs", "sw", "sv", "r", "su", "ns", "private", "si", "n", "ssl", "o", "south", "p", "scl", "src", "d", "m", "sq", "session", "w", "ds", "services", "a", "sys", "service", "g", "server", "ses", "sf", "spec", "c", "sb", "es", "self", "sym", "t", "b", "sg", "f", "save", "u", "serv", "address", "ss", "e", "sl", "ssh", "js", "client", "sync"], "slave": ["driver", "cod", " slaves", "ui", "r", "attr", "sc", "device", "copy", "code", "array", "si", "ssl", "o", "builder", "command", "p", "sh", "new", "node", "m", "config", "ad", "an", "mode", "slice", "master", "oe", "type", "server", "port", "sf", "sb", "c", "parser", "vp", "seed", "ace", "f", "serv", "address", "ss", "instance", "child", "e", "ssh", "post", "h", "ave", "pg"]}}
{"project": "qemu", "commit_id": "d1eb8f2acba579830cf3798c3c15ce51be852c56", "target": 0, "func": "int floatx80_eq(floatx80 a, floatx80 b, float_status *status)\n\n{\n\n\n\n    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )\n\n         || (    ( extractFloatx80Exp( b ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )\n\n       ) {\n\n        float_raise(float_flag_invalid, status);\n\n        return 0;\n\n    }\n\n    return\n\n           ( a.low == b.low )\n\n        && (    ( a.high == b.high )\n\n             || (    ( a.low == 0 )\n\n                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )\n\n           );\n\n\n\n}\n", "idx": 399, "substitutes": {"a": ["i", "home", "r", "ac", "l", "ia", "ack", "n", "ama", "y", "o", "at", "p", "ab", "A", "va", "d", "af", "aj", "m", "alpha", "ga", "api", "w", "ae", "sa", "ad", "ba", "an", "aa", "am", "ca", "ast", "parent", "c", "self", "ai", "la", "f", "as", "u", "pa", "na", "da", "au", "this", "e", "x", "h", "s", "art"], "b": ["i", "bc", "rb", "base", "r", "l", "pb", "bb", "j", "n", "y", "o", "p", "ib", "B", "ab", "other", "d", "bs", "w", "ad", "fb", "k", "ba", "mb", "v", "bi", "nb", "end", "g", "eb", "c", "sb", "cb", "db", "f", "u", "wb", "e", "x", "lb", "h", "s"], "status": ["fs", "sw", "uses", "fail", "r", "sync", "error", "ex", "code", "ity", "temp", "p", "wait", "index", "new", "gc", "wrapper", "id", "stage", "stat", "STAT", "stats", "success", "expr", "server", "complete", "current", "ix", "speed", "result", "state", "handle", "score", "out", "e", "x", "progress", "msg", "s", "source", "Status"]}}
{"project": "qemu", "commit_id": "d2ca7c0b0d876cf0e219ae7a92252626b0913a28", "target": 0, "func": "void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)\n\n{\n\n    lexer->emit = func;\n\n    lexer->state = IN_START;\n\n    lexer->token = qstring_new();\n\n    lexer->x = lexer->y = 0;\n\n}\n", "idx": 402, "substitutes": {"lexer": ["flexter", " lexator", "exger", "lexe", "flexger", "lexger", "flexener", "flexe", "lexter", "signator", "flexator", "sexe", " lexor", "Lexler", "sexener", "flexer", "Lexer", "lexor", "exer", "exe", " lexger", "Lexter", "signer", "lexator", "sexger", " lexe", "flexor", "lexener", "sexler", "exler", "signe", "sexor", " lexler", "sexer", "Lexe", "flexler", "exter", "exener", "Lexor", "Lexger", "sexter", " lexener", "lexler", " lexter", "signger"], "func": ["fn", "xxx", "text", "attr", "context", "ctx", "function", "lib", "super", "node", "token", "obj", "Function", "buf", "handler", "unc", "tc", "class", "prefix", "pc", "conn", "data", "callback", "package", "c", "self", "util", "parser", "proc", "b", "f", "as", "this", "e", "instance", "parse", "x", "reader", "lc"]}}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque, int type)\n\n{\n\n    struct qemu_paiocb *acb;\n\n\n\n    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    acb->aio_type = type;\n\n    acb->aio_fildes = fd;\n\n    acb->ev_signo = SIGUSR2;\n\n    acb->async_context_id = get_async_context_id();\n\n\n\n    if (qiov) {\n\n        acb->aio_iov = qiov->iov;\n\n        acb->aio_niov = qiov->niov;\n\n    }\n\n    acb->aio_nbytes = nb_sectors * 512;\n\n    acb->aio_offset = sector_num * 512;\n\n\n\n    acb->next = posix_aio_state->first_aio;\n\n    posix_aio_state->first_aio = acb;\n\n\n\n    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);\n\n    qemu_paio_submit(acb);\n\n    return &acb->common;\n\n}\n", "idx": 404, "substitutes": {"bs": ["bf", "rb", "fs", "bc", "base", "BS", "ns", "plugins", "fps", "pb", "bb", "lib", "bits", "http", "obj", "blocks", "ba", "bos", "fb", "lb", "abc", "bi", "sys", "eb", "ps", "ses", "sb", "gb", "ob", "bh", "gs", "boot", "vs", "db", "b", "os", "bas", "ss", "ls", "bis", "bid", "bytes", "ds"], "fd": ["fn", "bf", "dd", "FD", "dc", "fff", "fs", " fid", "cond", "fc", "fi", "lambda", "dB", "dl", "fif", "fp", "pd", "nd", "ecd", "ff", "d", "fee", "buf", "fb", "df", "handler", "ffff", "func", "sf", "fa", "flow", "draft", "fx", "f", "da", "ds", "lf", "fe"], "sector_num": ["sector_count", "sector_name", "ector_num", " sector_len", "ector_offset", "section_name", "section_id", "sectorPnum", "sector_id", "sectorPname", "section_num", "sector_offset", "ector_name", " sector_count", "section_len", " sector_name", "sectorPlen", "sector_len", "sectorPcount", "ector_id"], "qiov": ["uuno", "quliv", "uiov", " qliv", "frolet", "qgio", "quilo", "sqiov", "quuno", " qrolet", "uoren", "sqliv", "kliv", "kmus", "qoren", "qoby", "foby", "krolet", "qilo", "qudyl", "qqilo", "qrolet", " qdyl", " qoby", "qdyl", " qilo", "qugio", "qqoren", "qmus", "qquno", "quoren", "uilo", "qumus", "kiov", "qqiov", "quiov", "quoby", "quno", "fiov", "qliv", "filo", " qgio", " qmus", "qurolet", "sqdyl", "sqgio"], "nb_sectors": ["nb_tectors", "nb_sections", "nb_gegments", "nb_segments", "nb_tector", "nb_pectors", "nb_tegments", "nb_perets", "nb_peors", "nb_gector", "nb_vegments", "nb_vecs", "nb_veors", "nb_psecs", "nb_verets", "nb_psegments", "nb_gerets", "nb_sector", "nb_vectors", "nb_psectors", "nb_pegments", "nb_psections", "nb_vections", "nb_serets", "nb_teors", "nb_gectors", "nb_vector", "nb_seors", "nb_secs", "nb_pector"], "cb": ["fn", "bf", "cod", "rb", "buff", "cf", "cmp", "xb", "pb", "ctx", "bb", "orb", "function", "fp", "obb", "acl", "call", "fb", "abc", "unc", "cv", "cp", "func", "eb", "abb", "callback", "hub", "sb", "c", "ctrl", "gb", "ob", "db", "b", "rob", "wb", "bc", "sync", "cd", "CB"], "opaque": ["opaco", "opac", "OPaco", "ipaques", "hopaques", "OPacity", "opace", "pacity", " opace", "ipaque", "pac", "compacity", "ipac", "hopac", "OPace", "hopc", "compace", " opaques", " opc", " opacity", "pc", "opaques", "paque", "opc", "compaque", "OPaque", "ipacity", "opacity", " opaco", "hopaque", "compaco", " opac", "ipc"], "type": ["ocol", "phase", "tp", "attr", "role", "error", "types", "code", "function", "unit", "ity", "pb", "o", "y", "p", "key", "token", "call", "name", "typ", "id", "time", "method", "pe", "py", "format", "pos", "func", "pc", "prefix", "year", "ype", "length", "port", "site", "Type", "url", "plugin", "block", "state", "style", "col", "t", "f", "op", "address", "TYPE", "ty", "path"], "acb": ["sacp", "ecfb", "ocbar", "oca", "ancbe", "acck", "acbi", "ACb", " ace", "macbb", "accbar", "admb", "acefb", "ecbb", "macban", "actn", "adb", "ancfb", "ecsb", " ack", "ACbd", "accB", "ocfb", "acr", "icb", "actban", "sacbe", "akk", "accfb", "acbe", "akmb", "ancr", "ancsb", "ica", "maca", "ocmb", "icB", "actf", "ecv", "acbar", "ecb", " acn", "accbe", "accn", " acbi", "ocl", "ACbb", "acfb", "akb", "acv", "accbi", "occb", "anca", "acbd", "ace", " acp", " acr", " acmb", "macb", " acban", "sacbi", "acce", "macf", "acf", " acv", " acsb", "accbb", "ACfb", "aksb", "akn", " acbd", "ack", "akfb", "actb", "acebb", "accp", " acl", "accb", " acbb", "ancb", "akr", "acl", "acbb", " accb", "acban", "acn", "ecp", "rcbb", " acf", " acbe", "icbb", "ACa", "acsb", "eck", "acmb", " acbar", "macB", "acecb", "aceb", "acp", "ocb", "rcf", "accr", "acca", "accsb", "aca", "ocbb", "ecmb", "macn", "ocsb", "sacb", "accf", "ACl", "ACsb", "ocbd", "ake", "accv", " aca", "adbb", "akbb", "accmb", " acfb", "acB", "adsb", "rcb"]}}
{"project": "FFmpeg", "commit_id": "c8d0d8bc767309d5e8d9ee64addc11117190338e", "target": 1, "func": "static int crypto_open(URLContext *h, const char *uri, int flags)\n\n{\n\n    const char *nested_url;\n\n    int ret;\n\n    CryptoContext *c = h->priv_data;\n\n\n\n    if (!av_strstart(uri, \"crypto+\", &nested_url) &&\n\n        !av_strstart(uri, \"crypto:\", &nested_url)) {\n\n        av_log(h, AV_LOG_ERROR, \"Unsupported url %s\\n\", uri);\n\n        ret = AVERROR(EINVAL);\n\n        goto err;\n\n    }\n\n\n\n    if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) {\n\n        av_log(h, AV_LOG_ERROR, \"Key or IV not set\\n\");\n\n        ret = AVERROR(EINVAL);\n\n        goto err;\n\n    }\n\n    if (flags & AVIO_FLAG_WRITE) {\n\n        av_log(h, AV_LOG_ERROR, \"Only decryption is supported currently\\n\");\n\n        ret = AVERROR(ENOSYS);\n\n        goto err;\n\n    }\n\n    if ((ret = ffurl_open(&c->hd, nested_url, AVIO_FLAG_READ)) < 0) {\n\n        av_log(h, AV_LOG_ERROR, \"Unable to open input\\n\");\n\n        goto err;\n\n    }\n\n    c->aes = av_mallocz(av_aes_size);\n\n    if (!c->aes) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto err;\n\n    }\n\n\n\n    av_aes_init(c->aes, c->key, 128, 1);\n\n\n\n    h->is_streamed = 1;\n\n\n\n    return 0;\n\nerr:\n\n    av_free(c->key);\n\n    av_free(c->iv);\n\n    return ret;\n\n}\n", "idx": 436, "substitutes": {"h": ["hm", "hi", "host", "home", "rh", "auth", "r", "l", "hs", "hh", "ctx", "n", "gh", "sh", "o", "hash", "ht", "p", "ha", "d", "m", "s", "w", "hl", "kh", "oh", "v", "th", "uh", "ah", "g", "eh", "hr", "ph", "he", "self", "bh", "dh", "ch", "ih", "hd", "t", "hp", "b", "f", "u", "history", "q", "e", "http", "hw", "H"], "uri": ["umi", "i", "ui", "attribute", "ir", "io", "doi", "base", " URI", "filename", "dir", "phrase", "uni", "connection", "qi", "query", "href", "cli", "iri", "id", "mi", "api", "ri", "route", "present", "ii", "prefix", "ur", "file", "data", "afi", "message", "duration", "dn", "url", "origin", "oid", "plugin", "abi", "nil", "pi", "subject", "uid", "URI", "ilo", " ur", "u", "address", "directory", "resource", "iv", "username", "http", "path", "source", "specified"], "flags": ["bugs", "mask", "fixes", "ags", "FLAG", "fs", "orts", "lag", "properties", "settings", "prot", "plugins", "types", "faces", "flag", "bits", "fl", "fields", "ints", "ids", "opens", "mods", "stats", "cons", "vals", "ats", "ants", "tags", "files", "options", "locks", "reads", "args", "features", "parts", "rules", "Flags", "atts", "ops", "ffff", "checks"], "nested_url": ["nested_path", "nest_web", "nested_str", "nestedsfile", "nested_uri", "nest_name", "nested_id", "nested_name", "nestedsurl", "nested_l", "nest_path", "nest_uri", "nest_l", "nesting_l", "nest_id", "nested_file", "nest_url", "nestedsl", "nested_web", "nesting_url", "nesting_file", "nest_str"], "ret": ["cat", "val", "let", "res", "part", "pat", "back", " RET", "base", "error", "att", "def", "rc", "match", "rt", "flag", " Ret", "code", "resp", "j", "alt", "valid", "fin", "RET", "arr", "ref", "mem", "det", "fit", "gt", "fat", "rev", "orig", "len", "run", "lit", "ut", "ben", "success", "ext", "rets", "feat", "str", "data", "reply", "mt", "fun", "nt", "reg", "result", "get", "arg", "Ret", "al", "err", "ft", "cur", "re", "pass", "bit", "art"], "c": ["cu", "cache", "dc", "jc", "cc", "cr", "i", "cy", "sc", "cf", "ac", "l", "fc", "cs", "enc", "ctx", "code", "n", "conf", "y", "o", "vc", "p", "ci", "or", "ce", "ic", "ec", "d", "m", "config", "s", "k", "con", "v", "cp", "a", "conn", "co", "ca", "g", "coll", "cn", "self", "nc", "ch", "mc", "t", "b", "f", "u", "cur", "this", "C", "e", "uc", "ct", "cm", "lc", "anc", "cd"]}}
{"project": "FFmpeg", "commit_id": "72555f4a382744dd7f02edcb7fe6f8ed91f4dc3c", "target": 1, "func": "int ff_alloc_entries(AVCodecContext *avctx, int count)\n\n{\n\n    int i;\n\n\n\n    if (avctx->active_thread_type & FF_THREAD_SLICE)  {\n\n        SliceThreadContext *p = avctx->internal->thread_ctx;\n\n        p->thread_count  = avctx->thread_count;\n\n        p->entries       = av_mallocz_array(count, sizeof(int));\n\n\n\n        if (!p->entries) {\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        p->entries_count  = count;\n\n        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));\n\n        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));\n\n\n\n        for (i = 0; i < p->thread_count; i++) {\n\n            pthread_mutex_init(&p->progress_mutex[i], NULL);\n\n            pthread_cond_init(&p->progress_cond[i], NULL);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 439, "substitutes": {"avctx": ["afpkg", "afcontext", "abca", "afctl", "avcu", "avecmp", "AVctx", "avectx", "aucmp", "afcu", "abctx", "avcal", "avcmp", "abcmp", "raftcontext", "AVcu", "afca", "auctx", "abcontext", "avpkg", "svpkg", "AVctl", "auctl", "afcal", "raftpkg", "afcmp", "afctx", "avecontext", "aucontext", "raftctx", "svcontext", "aveca", "avecu", "AVcontext", "avca", "avctl", "AVcmp", "avcontext", "svctx", "raftcal", "svcal"], "count": ["cache", "offset", "Count", "part", "total", "base", "code", "low", "num", "n", "number", "deep", "call", "name", "limit", "id", "sum", "force", "len", "ext", "type", "list", "path", "parent", "length", "work", "c", "current", "counter", "start", "weight", "depth", "col", "max", "child", "size", "page", "seq", "index", "found"], "i": ["ui", "io", "r", "l", "fi", "si", "j", "uri", "n", "o", "y", "ci", "key", "multi", "qi", "d", "m", "oi", "id", "yi", "ri", "k", "ini", "ii", "v", "bi", "a", "x", "li", "iu", "ji", "c", "zi", "di", "start", "ai", "info", "ix", "abi", "pi", "mu", "t", "b", "f", "gi", "u", "q", "ti", "ip", "ni", "e", "xi", "I", "it", "phi", "h", "lc", "s", "index"], "p": ["lp", "tp", "part", "bp", "patch", "l", "private", "pb", "ctx", "pm", "n", "j", "o", "y", "at", "fp", "exec", "up", "http", "d", "m", "per", "api", "wp", "pe", "k", "v", "cp", "pc", "g", "data", "ps", "sp", "parent", "port", "c", "ap", "pp", "pre", "comp", "np", "current", "parser", "plugin", "vp", "jp", "pi", "P", "t", "hp", "b", "f", "op", "pa", "u", "ip", "post", "e", "it", "cop", "sync", "s", "pg"]}}
{"project": "qemu", "commit_id": "25d9747b6427de8253221d544b45e50888d4cef7", "target": 1, "func": "static int floppy_probe_device(const char *filename)\n\n{\n\n    int fd, ret;\n\n    int prio = 0;\n\n    struct floppy_struct fdparam;\n\n    struct stat st;\n\n\n\n    if (strstart(filename, \"/dev/fd\", NULL) &&\n\n        !strstart(filename, \"/dev/fdset/\", NULL)) {\n\n        prio = 50;\n\n    }\n\n\n\n    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        goto out;\n\n    }\n\n    ret = fstat(fd, &st);\n\n    if (ret == -1 || !S_ISBLK(st.st_mode)) {\n\n        goto outc;\n\n    }\n\n\n\n    /* Attempt to detect via a floppy specific ioctl */\n\n    ret = ioctl(fd, FDGETPRM, &fdparam);\n\n    if (ret >= 0)\n\n        prio = 100;\n\n\n\noutc:\n\n    qemu_close(fd);\n\nout:\n\n    return prio;\n\n}\n", "idx": 444, "substitutes": {"filename": ["fn", "bf", "tools", "database", "socket", "tty", "lua", "l", "binary", "println", "utf", "fp", "phrase", "which", "folder", "name", "word", "buffer", "Filename", "fil", "buf", "STDOUT", "ppa", "named", "prefix", "file", "feat", "txt", "length", "il", "fax", "sf", "microsoft", "sudo", "whatever", "dll", "files", "nil", "kl", "ilk", "kn", "f", "wb", "directory", "pty", "username", "FH", "wl", "path"], "fd": ["fn", "md", "vd", "bf", "dd", "FD", "wd", "fs", "dc", "feed", "cod", "die", " fid", "od", "cond", "cf", "ded", "fc", "fi", "dir", "dl", "bd", "temp", "fp", "exec", "pd", "nd", "fin", "fl", "connection", "ff", "pipe", "ud", "ind", "ecd", "d", "fat", "dat", "ln", "buf", "ad", "fb", "fe", "ld", "df", "handler", "conn", "file", "sf", "xd", "fw", "c", "fun", "dt", "gd", "fa", "fed", "draft", "fx", "hd", "db", "sd", "f", "da", "out", "FH", "ds", "lf", "cd"], "ret": ["bf", "val", "let", "fail", "res", "try", "cond", "att", "def", "pet", "fi", "ait", "rt", "lt", "j", "sec", "resp", "alt", "rx", "pt", "fin", "ref", "RET", "det", "fat", "rev", "rf", "status", "obj", "pret", "len", "lit", "py", "ben", "success", "conn", "rets", "feat", "ann", "reply", "mt", "ry", "fun", "nt", "reg", "dt", "result", "rot", "std", "Ret", "db", "rl", "err", "ft", "re", "out", "ct", "pass", "en", "art", "ort"], "fdparam": ["fparam", "dlParam", "FDparams", "FDpar", "fdParam", "dlresource", "FDparam", "fpar", "fdresource", "FDresource", "fdparams", "dparams", "dParam", "FDParam", "draftparams", "dresource", "draftparam", "dlparam", "dlparams", "draftpar", "fdpar", "dparam", "fparams"], "st": ["dd", "ost", "sth", "inst", "ste", "sc", "fi", "pt", "src", "St", "put", "stab", "d", "sta", "obj", "stage", " est", "rest", "et", "store", "stat", "ut", "stop", "stream", "rd", "est", "str", "ST", "spect", "ast", "td", "sb", "nt", "start", "ist", "state", "std", "t", "sd", "sts", "storage", "ft", "ss", "ct", "station", "fe"]}}
{"project": "qemu", "commit_id": "7d55273fcdc307399fc0e327a0c14c140cd439cf", "target": 0, "func": "static void sun4uv_init(ram_addr_t RAM_size,\n\n                        const char *boot_devices,\n\n                        const char *kernel_filename, const char *kernel_cmdline,\n\n                        const char *initrd_filename, const char *cpu_model,\n\n                        const struct hwdef *hwdef)\n\n{\n\n    CPUState *env;\n\n    char *filename;\n\n    m48t59_t *nvram;\n\n    int ret, linux_boot;\n\n    unsigned int i;\n\n    ram_addr_t ram_offset, prom_offset;\n\n    long initrd_size, kernel_size;\n\n    PCIBus *pci_bus, *pci_bus2, *pci_bus3;\n\n    QEMUBH *bh;\n\n    qemu_irq *irq;\n\n    int drive_index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BlockDriverState *fd[MAX_FD];\n\n    void *fw_cfg;\n\n    ResetData *reset_info;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (!cpu_model)\n\n        cpu_model = hwdef->default_cpu_model;\n\n\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    bh = qemu_bh_new(tick_irq, env);\n\n    env->tick = ptimer_init(bh);\n\n    ptimer_set_period(env->tick, 1ULL);\n\n\n\n    bh = qemu_bh_new(stick_irq, env);\n\n    env->stick = ptimer_init(bh);\n\n    ptimer_set_period(env->stick, 1ULL);\n\n\n\n    bh = qemu_bh_new(hstick_irq, env);\n\n    env->hstick = ptimer_init(bh);\n\n    ptimer_set_period(env->hstick, 1ULL);\n\n\n\n    reset_info = qemu_mallocz(sizeof(ResetData));\n\n    reset_info->env = env;\n\n    reset_info->reset_addr = hwdef->prom_addr + 0x40ULL;\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n    main_cpu_reset(reset_info);\n\n    // Override warm reset address with cold start address\n\n    env->pc = hwdef->prom_addr + 0x20ULL;\n\n    env->npc = env->pc + 4;\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(RAM_size);\n\n    cpu_register_physical_memory(0, RAM_size, ram_offset);\n\n\n\n    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);\n\n    cpu_register_physical_memory(hwdef->prom_addr,\n\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n\n                                 TARGET_PAGE_MASK,\n\n                                 prom_offset | IO_MEM_ROM);\n\n\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR,\n\n                       NULL, NULL, NULL);\n\n        if (ret < 0) {\n\n            ret = load_image_targphys(filename, hwdef->prom_addr,\n\n                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n\n                                  TARGET_PAGE_MASK);\n\n        }\n\n        qemu_free(filename);\n\n    } else {\n\n        ret = -1;\n\n    }\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"qemu: could not load prom '%s'\\n\",\n\n                bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = 0;\n\n    initrd_size = 0;\n\n    if (linux_boot) {\n\n        /* XXX: put correct offset */\n\n        kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR,\n\n                                    ram_size - KERNEL_LOAD_ADDR);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              ram_size - KERNEL_LOAD_ADDR);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_size = load_image_targphys(initrd_filename,\n\n                                              INITRD_LOAD_ADDR,\n\n                                              ram_size - INITRD_LOAD_ADDR);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        }\n\n        if (initrd_size > 0) {\n\n            for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) {\n\n                if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { // HdrS\n\n                    stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR);\n\n                    stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,\n\n                           &pci_bus3);\n\n    isa_mem_base = VGA_BASE;\n\n    pci_vga_init(pci_bus, 0, 0);\n\n\n\n    // XXX Should be pci_bus3\n\n    pci_ebus_init(pci_bus, -1);\n\n\n\n    i = 0;\n\n    if (hwdef->console_serial_base) {\n\n        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,\n\n                       serial_hds[i], 1);\n\n        i++;\n\n    }\n\n    for(; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_init(serial_io[i], NULL/*serial_irq[i]*/, 115200,\n\n                        serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {\n\n        if (parallel_hds[i]) {\n\n            parallel_init(parallel_io[i], NULL/*parallel_irq[i]*/,\n\n                          parallel_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n    irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS);\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,\n\n                                      i % MAX_IDE_DEVS);\n\n       if (drive_index != -1)\n\n           hd[i] = drives_table[drive_index].bdrv;\n\n       else\n\n           hd[i] = NULL;\n\n    }\n\n\n\n    pci_cmd646_ide_init(pci_bus, hd, 1);\n\n\n\n    /* FIXME: wire up interrupts.  */\n\n    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        drive_index = drive_get_index(IF_FLOPPY, 0, i);\n\n       if (drive_index != -1)\n\n           fd[i] = drives_table[drive_index].bdrv;\n\n       else\n\n           fd[i] = NULL;\n\n    }\n\n    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, fd);\n\n    nvram = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);\n\n    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", RAM_size, boot_devices,\n\n                           KERNEL_LOAD_ADDR, kernel_size,\n\n                           kernel_cmdline,\n\n                           INITRD_LOAD_ADDR, initrd_size,\n\n                           /* XXX: need an option to load a NVRAM image */\n\n                           0,\n\n                           graphic_width, graphic_height, graphic_depth,\n\n                           (uint8_t *)&nd_table[0].macaddr);\n\n\n\n    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]);\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 461, "substitutes": {"RAM_size": ["ram_name", "rib_size", "rib_name", "rib00timeout", "rib_timeout", "ram00len", "ram00timeout", "ram_len", "ram_size", "rib00name", "ram00name", "rib00size", "rib_len", "ram00size", "ram_timeout", "rib00len"], "boot_devices": ["cache_mode", "boot_device", "boot2mode", "bootlistmode", "cachelistgroups", "boot2device", "bootlistdevices", "cache_device", "cachelistdevices", "bootlistgroups", "boot2devices", "bootlistdevice", "boot_groups", "cachelistmode", "boot_mode", "boot2groups", "cache_devices", "cache_groups", "cachelistdevice"], "kernel_filename": ["kernelockfile", "kernel_family", "kernel_Filename", "kernel_file", "linux_Filename", " kernel_profile", " kernel_file", "kernel_name", "kernelockfilename", "linux_file", "kernelockprofile", "kernelockname", "linux_filename", "linux_family", " kernel_name", "kernel_profile"], "kernel_cmdline": ["kernel_commandend", "kernel_argname", "kernel_commandname", "kernel_arglen", "kernel_commandline", "kernel_cmdlen", "kernel_pathline", "kernel_argline", "kernel_pathend", "kernel_argend", "kernel_commandlen", "kernel_pathlen", "kernel_cmdend", "kernel_cmdname", "kernel_pathname"], "initrd_filename": ["initrd_mode", "initrd_path", "initrt_mode", "initrt_filename", "initrd_file", "initrt_path", "initrt_file"], "cpu_model": [" cpuacmode", "cpu_location", "cpu_cache", "cpulexscope", "cpuacmode", " cpu_image", "cpuacimage", "core_format", "cpuleximage", "cpuaclocation", "cpuacscope", "cpu_models", " cpuaccache", " cpu_cache", "cpulexmodel", "cpulexlocation", "cpu_config", " cpu_location", "cpu_scope", "core_mode", " cpuacmodel", "cpuacmodel", "core_config", "cpu_format", "cpu_mode", " cpu_scope", " cpu_mode", " cpuacmodels", "cpuaccache", "core_models", " cpu_models", "core_model", "cpu_image", "cpuacmodels"], "hwdef": ["hubdef", "ggdef", "fwdata", "fwdc", "rwmd", "fwDef", "ctxdefinition", "hlDEF", "rwdef", "ctxdecl", "iwdef", "hubdata", "rwdf", "wxspec", "hubconf", "fwdef", "wxdef", "ggdesc", "ggdefinition", "iwdf", "hldefinition", "htmd", "hostdef", "ggdecl", "htdf", "rwdesc", "ctxdef", "hlspec", "hldef", "FWdesc", "htdef", "hwdf", "iwDef", "hwconf", "FWdc", "hubDef", "hawspec", "rwdc", "ctxdesc", "hzdesc", "hwdesc", "FWDef", "hwmd", "hwspec", "hzdecl", "hwdc", "hzdefinition", "hwDef", "hwDEF", "hwdecl", "FWdef", "hwdata", "hostconf", "hostDef", "htDef", "hawdef", "wxDEF", "iwmd", "fwdesc", "hawDEF", "hwdefinition", "hawdefinition", "hostdata", "wxdefinition", "hzdef", "fwconf", "rwDef"], "env": ["her", "po", "enc", "profile", "conf", "external", "eu", "opt", "ec", "chn", "bot", "v", "ah", "output", "exc", "kit", "que", "environment", "bc", "fg", "Environment", "manager", "exec", "impl", "bg", "eni", "config", "dat", "chal", "hl", "qv", "fen", "cv", "el", "erv", "ench", "enh", "app", "site", "eng", "scope", "init", "style", "args", "err", "utils", "nw", "shell", "net", "h", "ev", "inv", "context", "ctx", "dir", "core", "session", "skin", "obj", "theme", "engine", "het", "ini", "loader", "energy", "conn", "txt", "server", "enable", "ng", "global", "cur", "vel", "extra", "e", "esi", "path", "assets", "attr", "cf", "equ", "img", "viron", "cli", "edge", "api", "end", "here", "inet", "ext", "ne", "console", "ea", "eh", "export", "nc", "np", "dict", "vs", "oa", "gui", "db", "qt", "en"], "filename": ["fn", "offset", "tty", "binary", "uri", "fp", "kernel", "src", "config", "acl", "name", "Filename", "fil", "buf", "prefix", "file", "output", "url", "dll", "files", "f", "directory", "shell", "username", "path"], "nvram": ["vcnam", "qtrom", "qtnam", "vcram", "vmem", "vcrom", "vrom", "vnam", "qtram", "nvmem", "nvrom", "qtmem", "vram", "nvnam", "vcmem"], "ret": ["model", "val", "res", "base", "script", "fi", "enc", "code", "num", "exec", "RET", "stat", "len", "reset", "ext", "rets", "nt", "reg", "Ret", "f", "re", "final", "out"], "linux_boot": ["linux67update", "linux67lock", "linux_config", "linux_size", " linux_lock", " linux_bus", "linux67bit", "linux_bit", "linux_update", "linux_lock", " linux_update", " linux_bit", " linux_config", "linux67boot", " linux_size", "linux_bus"], "i": ["io", "r", "l", "is", "j", "n", "o", "p", "d", "m", "ion", "ii", "v", "a", "c", "info", "abi", "pi", "t", " I", "f", "b", "ip", "e", "I", "it", "s"], "ram_offset": ["gram_addr", "gram_offset", "gram_size", "ram_slice", "ram_size", "gram_slice", "ram_addr"], "prom_offset": ["rem_padding", "rem_size", "prom_addr", "rem_addr", "prom_padding", "rem_offset", "prom_size"], "initrd_size": ["initrd__size", "initrd_num", "initrt_num", "initrd__len", "initrd_file", "initrd_len", "initrt_len", "initrd__file", "initrd__num", "initrt_file", "initrt_size"], "kernel_size": ["loader_address", "kernel_address", "loader_time", "loader_data", "kernel_time", "kernel_data", "loader_size"], "pci_bus": ["pki_usb", "pci_BUS", "pci_boot", "pci__boot", "pci_usb", "pki_bus", "pci__bus", "pki_BUS", "pci__usb", "pci__BUS", "pki_boot"], "pci_bus2": ["pci_device4", "pci_bus5", "pci_bus1", "pci_BUS4", "pci_Bus2", "pci_device5", "pci_Bus1", "pci_device1", "pci_device2", "pci_BUS2", "pci_Bus4", "pci_bus4", "pci_BUS1", "pci_Bus5", "pci_BUS5"], "pci_bus3": ["pci_ux2", "pci_bus11", "pci_BUS3", "pci_bus1", "pci_Bus11", "pci_Bus2", "pci_ux1", "pci_ux3", "pci_Bus1", "pci_Bus3", "pci_ux11", "pci_BUS1", "pci_BUS2", "pci_BUS11"], "bh": ["rb", "hus", "sth", "pkg", "bj", "pb", "gh", "bda", "ht", "ib", "mr", "bot", "kh", "th", "uh", "ah", "abb", "cn", "eth", "sb", "ch", "aph", "ih", "cb", "la", "lb", "phi", "pull", "bt", "br", "rh", "BT", "cpp", "adh", "p", "ha", "fl", "bg", "zh", "hl", "qv", "shr", "hub", "bal", "ph", "dh", "bol", "b", "bl", "h", "hy", "pr", "bp", "hs", "hh", "ctx", "ssl", "sh", "hab", "bs", "roth", "batch", "http", "bm", "hm", "hn", "hi", "bf", "las", "loc", "bb", "pl", "fp", " Bh", "fb", "hr", "hp", "rl", "lo", "hw"], "irq": ["iraqu", "hrqu", "iraqs", "irqs", "ireque", "iraque", "iraq", "hrque", "ireqs", "ireq", "hrq", "hrqs", "irequ", "irque", "irqu"], "drive_index": [" drive_count", "driver_len", " drive_len", " drive_id", "driver_index", "driver_count", "driver_id"], "hd": ["vd", "hm", "md", "haw", "dd", "wd", "rh", "hid", "bd", "adh", "ht", "ha", "pd", "nd", "ud", "dr", "hl", "ld", "hub", "xd", "du", "gd", "di", "cow", "std", "hp", "dri", "hw", "cd"], "MAX_IDE_BUS": ["MAX_IDEADUSB", "MAX_IDEADBD", "MAX_ISE_DEF", "MAX_ISEADDEF", "MAX_ISE_USB", "MAX_IDEADBUS", "MAX_ISEADBD", "MAX_ISEADUSB", "MAX_IDEADEF", "MAX_ISE_BUS", "MAX_IDEADDEF", "MAX_ISE_BD", "MAX_IDEABD", "MAX_IDE_USB", "MAX_IDE_BD", "MAX_ISEADBUS", "MAX_IDEABUS", "MAX_IDEAUSB", "MAX_IDE_DEF"], "MAX_IDE_DEVS": ["MAX_IDE_DAVICE", "MAX_IDE_DIRS", "MAX_IDE_DIVS", "MAX_IDE_DIvs", "MAX_IDE_DAVS", "MAX_IDE_DAvs", "MAX_IDE_DARS", "MAX_IDE_DEVICE", "MAX_IDE_DEvs", "MAX_IDE_DIVICE", "MAX_IDE_DERS"], "fd": ["vd", "md", "FD", "wd", "dc", "fs", "fc", "dir", "dl", "bd", "fp", "pd", "fl", "ff", "d", "fat", "pid", "id", "fb", "df", "v", "flow", "cb", "fx", "db", "sd", "f", "ds", "lf"], "MAX_FD": ["max_DIR", "MAX_DEF", "MAX_DF", "max_DF", "max_FD", "max_DEF", "MAX_DIR"], "fw_cfg": ["FW_cfg", "FW_def", "fw_def", "FW_config", "fw2def", "fw2conf", "fw2cfg", "fw_conf", "fw2config", "fw_config", "FW_conf"], "reset_info": ["flush_object", " reset_INFO", "config_start", "reset64info", "resetererror", "offset_comment", "reset64Info", "reset_result", "reseterINFO", " reset_Info", "resetallcheck", "resetedcheck", "resetCresult", "reset_INFO", "flush_private", " reset_error", "resetCarea", "resetCinfo", "resetallobject", "reset_error", "resetedprivate", "offsetableresult", "reset_object", "resetedobject", "offset_info", "offsetablecomment", "resetablearea", "reset_information", "offsetableinfo", "reset_Info", "reset_area", "resetCcomment", "resetallprivate", "offset_result", "reset_comment", "config_info", "resetallinfo", "reseterinfo", "reset64result", "offsetablearea", "resetallresult", "resetableresult", "config_result", "resetedinfo", "flush_check", "resetallInfo", "resetableinfo", "offset_area", "resetablecomment", "config_information", " reset_result", " reset_information", "reset_private", "flush_info", "reset_check", "reset_start"]}}
{"project": "qemu", "commit_id": "932e71cd57bab4e6206e1355c6425290721bbe34", "target": 0, "func": "static void fpu_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MIPS_FPU_MAX; i++)\n\n        env->fpus[i].fcr0 = def->CP1_fcr0;\n\n\n\n    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));\n\n    if (env->user_mode_only) {\n\n        if (env->CP0_Config1 & (1 << CP0C1_FP))\n\n            env->hflags |= MIPS_HFLAG_FPU;\n\n#ifdef TARGET_MIPS64\n\n        if (env->active_fpu.fcr0 & (1 << FCR0_F64))\n\n            env->hflags |= MIPS_HFLAG_F64;\n\n#endif\n\n    }\n\n}\n", "idx": 474, "substitutes": {"env": ["eval", "enter", "her", "enc", "conf", "er", "eu", "ec", "v", "ef", "info", "exc", "que", "dev", "emb", "environment", "manager", "inst", "ep", "exec", "eni", "config", "vm", "et", "event", "ass", "el", "erv", "arch", "eng", "scope", "init", "args", "err", "net", "ev", "ce", "context", "ctx", "code", "gear", "core", "engine", "loader", "energy", "conn", "server", "dt", "enable", "global", "vel", "extra", "e", "cache", "rc", "viron", "oder", "edge", "end", "here", "inet", "ext", "esc", "oe", "eb", "ne", "console", "ea", "export", "nc", "np", "vs", "db", "cfg", "esp", "en"], "def": ["eval", "dep", "val", "diff", "req", "decl", "cf", "gen", "de", "fi", "code", "conf", "ref", "d", "entry", "definition", "define", "adv", "df", "end", "ass", "Def", "data", "parent", "spec", "ef", "init", "info", "block", "DEF", "proc", "f", "der", "dev", "aux", "cfg", "defined"], "i": ["hi", "ui", "io", "l", "fi", "si", "j", "uri", "n", "o", "y", "p", "ci", "multi", "qi", "eni", "d", "m", "oi", "id", "mi", "ri", "k", "ini", "ii", "v", "li", "ami", "iu", "ie", "ji", "c", "zi", "di", "ix", "ai", "info", "start", "pi", "mu", "t", "gi", "f", "u", "b", "ti", "ip", "ni", "e", "xi", "I", "ki", "index"]}}
{"project": "FFmpeg", "commit_id": "ccc27e2139336b66cdec3bb73a2cc7e60ef7e599", "target": 1, "func": "static int bfi_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size;\n\n    int buf_size = avpkt->size;\n\n    BFIContext *bfi = avctx->priv_data;\n\n    uint8_t *dst = bfi->dst;\n\n    uint8_t *src, *dst_offset, colour1, colour2;\n\n    uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;\n\n    uint32_t *pal;\n\n    int i, j, height = avctx->height;\n\n\n\n    if (bfi->frame.data[0])\n\n        avctx->release_buffer(avctx, &bfi->frame);\n\n\n\n    bfi->frame.reference = 1;\n\n\n\n    if (avctx->get_buffer(avctx, &bfi->frame) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* Set frame parameters and palette, if necessary */\n\n    if (!avctx->frame_number) {\n\n        bfi->frame.pict_type = AV_PICTURE_TYPE_I;\n\n        bfi->frame.key_frame = 1;\n\n        /* Setting the palette */\n\n        if (avctx->extradata_size > 768) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Palette is too large.\\n\");\n\n            return -1;\n\n        }\n\n        pal = (uint32_t *)bfi->frame.data[1];\n\n        for (i = 0; i < avctx->extradata_size / 3; i++) {\n\n            int shift = 16;\n\n            *pal = 0;\n\n            for (j = 0; j < 3; j++, shift -= 8)\n\n                *pal +=\n\n                    ((avctx->extradata[i * 3 + j] << 2) |\n\n                    (avctx->extradata[i * 3 + j] >> 4)) << shift;\n\n            pal++;\n\n        }\n\n        bfi->frame.palette_has_changed = 1;\n\n    } else {\n\n        bfi->frame.pict_type = AV_PICTURE_TYPE_P;\n\n        bfi->frame.key_frame = 0;\n\n    }\n\n\n\n    buf += 4; // Unpacked size, not required.\n\n\n\n    while (dst != frame_end) {\n\n        static const uint8_t lentab[4] = { 0, 2, 0, 1 };\n\n        unsigned int byte   = *buf++, av_uninit(offset);\n\n        unsigned int code   = byte >> 6;\n\n        unsigned int length = byte & ~0xC0;\n\n\n\n        if (buf >= buf_end) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Input resolution larger than actual frame.\\n\");\n\n            return -1;\n\n        }\n\n\n\n        /* Get length and offset(if required) */\n\n        if (length == 0) {\n\n            if (code == 1) {\n\n                length = bytestream_get_byte(&buf);\n\n                offset = bytestream_get_le16(&buf);\n\n            } else {\n\n                length = bytestream_get_le16(&buf);\n\n                if (code == 2 && length == 0)\n\n                    break;\n\n            }\n\n        } else {\n\n            if (code == 1)\n\n                offset = bytestream_get_byte(&buf);\n\n        }\n\n\n\n        /* Do boundary check */\n\n        if (dst + (length << lentab[code]) > frame_end)\n\n            break;\n\n\n\n        switch (code) {\n\n\n\n        case 0:                //Normal Chain\n\n            if (length >= buf_end - buf) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Frame larger than buffer.\\n\");\n\n                return -1;\n\n            }\n\n            bytestream_get_buffer(&buf, dst, length);\n\n            dst += length;\n\n            break;\n\n\n\n        case 1:                //Back Chain\n\n            dst_offset = dst - offset;\n\n            length *= 4;        //Convert dwords to bytes.\n\n            if (dst_offset < bfi->dst)\n\n                break;\n\n            while (length--)\n\n                *dst++ = *dst_offset++;\n\n            break;\n\n\n\n        case 2:                //Skip Chain\n\n            dst += length;\n\n            break;\n\n\n\n        case 3:                //Fill Chain\n\n            colour1 = bytestream_get_byte(&buf);\n\n            colour2 = bytestream_get_byte(&buf);\n\n            while (length--) {\n\n                *dst++ = colour1;\n\n                *dst++ = colour2;\n\n            }\n\n            break;\n\n\n\n        }\n\n    }\n\n\n\n    src = bfi->dst;\n\n    dst = bfi->frame.data[0];\n\n    while (height--) {\n\n        memcpy(dst, src, avctx->width);\n\n        src += avctx->width;\n\n        dst += bfi->frame.linesize[0];\n\n    }\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame *)data = bfi->frame;\n\n    return buf_size;\n\n}\n", "idx": 490, "substitutes": {"avctx": ["avcu", "aflc", "avqa", "AVctx", "avelc", "abctx", "abcf", "avcmp", "aktx", "avpkg", "afcal", "afconn", "afctx", "afnp", "akcca", "avlc", "afctrl", "AVcontext", "avctl", "avcontext", "alpkg", "avcca", "ahci", "avecf", " avpkg", " avtx", "afctl", "avconn", "avecmp", "avectx", "aftx", " avcontext", "aveqa", " avcf", "avecca", "navcca", "ajcf", "ahcontext", "afcoll", "alctx", "navpkg", "akconfig", "avtx", "navctx", "avcf", "navci", "vercf", "abnp", "avecal", "alcf", "avctrl", "evcontext", "avconfig", "ajcontext", "AVcmp", "ahctl", " avrec", "afrec", "evconn", "avcal", "avci", "navconn", "afbc", "AVcu", "ajctx", "avrec", "navcf", "vercontext", "abcontext", "akctx", "verctx", "avebc", "akqa", "navcoll", "avecoll", "navcontext", "aveci", "afcmp", "avecontext", "evctx", "akcontext", "avbc", "alctrl", "verbc", "avnp", "avepkg", " avconfig", "afcf", "avcoll", "afpkg", "afcontext", "alcal", "afcu", "afcca", "aveconfig", " avci", "afqa", "AVlc", "aveconn", "AVconn", "averec", "ahctx", "navctrl", "alcontext", "avecu", "ajnp", "avectl", "evci", "afci", "afconfig"], "data": ["media", "next", "val", "cache", "offset", "value", "base", "buff", "shift", "script", "device", "rc", "Data", "padding", "array", "date", "code", "binary", "index", "head", "input", "config", "delay", "dat", "queue", "buffer", "load", "name", "id", "alpha", "time", "memory", "capacity", "len", "actions", "mode", "slice", "pad", "area", "frame", "window", "parent", "batch", "video", "duration", "message", "sequence", "output", "body", "read", "start", "result", "image", "block", "channel", "DATA", "response", "bin", "align", "da", "address", "size", "empty", "open", "bytes", "reader", "timeout", "content", "source"], "data_size": ["data\u00b7data", "data_handle", "data_len", "buffer_len", "data\u00b7handle", "buffer_data", "data\u00b7len", "data\u00b7size", "buffer_handle", "buffer_size", "data_data"], "avpkt": ["avdect", "avepnt", "avPnt", "affck", "avpet", "avtacket", "avfet", "avcck", "affet", "avfka", "afpck", "avlpkt", "avalpks", "avalpkt", "avefpkt", "affka", "affct", "afpmt", "avcpkt", "avtkt", "affmt", "avPct", "affacket", "avpsect", "avfck", "avefpcht", "avtect", "avPck", "avalpsks", "avcpks", "affect", "avfect", "afpect", "avbka", "avcacket", "avefpnt", "avcpnt", "avfacket", "avlacket", "avPacket", "avpskt", "avepcht", "avfpnt", "avpect", "avefpacket", "avpka", "avlpet", "afpet", "avcct", "avepacket", "afpka", "avbkt", "avfmt", "avfkt", "avalpskt", "avbacket", "avpks", "avfpkt", "avfpcht", "avPcht", "avckt", "avpcht", "avpacket", "avepkt", "avlpacket", "avpsnt", "avalpect", "avdacket", "afpkt", "avpsks", "avcpect", "afpacket", "avpnt", "avxpkt", "avpmt", "avfpacket", "avxpks", "avfct", "avdmt", "avpck", "avbet", "avalpnt", "avalpsnt", "avpct", "avxpect", "avtmt", "avlkt", "avalpsect", "avlcht", "afpct", "avdkt", "avPkt", "avlpka", "avlnt", "affkt", "avxpnt"], "buf": ["feed", "cache", "rb", "buff", "loc", "rc", "img", "num", "lim", "alloc", "ref", "ab", "ff", "config", "queue", "buffer", "Buffer", "vec", "fb", "len", "cv", "fd", "batch", "uf", "port", "bag", "pool", "result", "block", "cb", "proc", "box", "cmd", "cur", "bc", "cas", "uc", "seq", "br"], "buf_end": ["buf_ad", "buff_ends", "buff_ad", "buf_ends", "buf_start", "buff_end", "buff_start"], "bfi": ["nfa", "abffe", " bffe", " bzi", "gffe", "fbi", "bfam", "bani", "fci", "lbafi", "lifi", "pffe", "mbfi", "fifi", "Bii", "wafi", "obfa", "lfe", "bci", "obbi", "bfa", "fcci", "ebfi", "difi", "ffe", "bffe", "ffi", "rfi", "abfa", "oblli", "mbfen", " bci", "mbii", " bisi", "Bafi", "dfi", "Bfi", " bfe", "rfe", "Bbi", "lii", "dafi", "pfi", "lbfen", "fffe", "blli", "pifi", "ffa", "dci", "Blli", "lbfi", "bfen", "Bci", "gfi", "Bfa", " bii", "wfi", "ebii", "nfam", "Bisi", "obani", "Bcci", "bii", " bafi", "lbfa", "bisi", "mbisi", "nifi", "ebfa", "Bifi", "wfen", "rifi", "dfen", "bafi", "lzi", " bcci", "rfen", "wfa", "lfa", "Bfen", "bfe", " bifi", "abfi", "obfi", "pfa", " bfen", "gfa", " bani", " bfam", "obzi", "rafi", "Bfe", " bfa", "lani", " blli", "bbi", "nfi", "abifi", "gbi", "dfa", " bbi", "ebifi", "bifi", "lfi", "dcci", "bzi", "bcci", "rfa", "rfam"], "dst": ["fsts", "adst", "dbl", "lsp", "brc", "fsc", "drc", "iddr", " dsc", "lsc", "dsts", "dsc", "sst", "idrc", "Dsc", "sbl", "adsp", "fdr", "adsc", "nsc", "Drc", "Dsp", " dbl", " drc", "lst", " ddr", "ssc", "frc", "idsts", "dsp", "ddr", "bsc", "adrc", "fst", "bbl", "nrc", "lrc", "bst", "idst", "Dst", "nst", "ndr", " dsts"], "src": ["fn", "host", "dist", "view", "rb", "loc", "attr", "rc", "ptr", "img", "uri", "ctx", "sel", "st", "fp", "href", "config", "source", "slice", "cv", "frame", "stream", "dest", "url", "origin", "cb", "channel", "filename"], "dst_offset": ["dbl_size", "dbl_offset", "dbl_index", "dbl_length", "dst_length", "dst_size", "dst_index"], "colour1": ["color2", "draw1", "colorone", "draw3", "color1", "colourone", " colourone", "colour3", "color3", " colour3", "draw2", "drawone"], "colour2": ["color2", "draw1", "color1", "colour4", "color4", " colour4", "draw2", "draw4"], "frame_end": ["frame_offset", "frame2begin", "frame_ends", " frame_begin", "framesoffset", "framesbegin", "frame_limit", "frame2end", "image_ends", " frame_offset", "image_set", "frame_begin", "image_limit", "framesend", "image_end", "frame_set", "frame2offset"], "pal": ["mask", "cal", "fr", "val", "chi", "all", "base", "scale", "Pal", "l", "nav", "pl", "cell", "pixel", "p", "color", "ref", "ab", "pin", "delay", "pid", "alpha", "buffer", "sum", "theme", "chal", "count", "area", "len", "slice", "pad", "pod", "label", "v", "aa", "pos", "prefix", "ass", "el", "li", "wal", "skip", "border", "app", "pp", "ph", "panel", "ch", "ill", "col", "style", "pan", "al", "nl", "bin", "pocket", "f", "align", "range", "span", "isal", "cel"], "i": ["phi", "ui", "im", "io", "l", "fi", "si", "n", "uri", "y", "p", "ci", "multi", "qi", "eni", "d", "m", "z", "id", "I", "ori", "mi", "ri", "yi", "api", "k", "ini", "ii", "v", "a", "bi", "li", "ami", "iu", "ie", "ji", "in", "zi", "start", "ix", "di", "info", "ai", "vi", "image", "pi", "gi", "f", "u", "b", "jit", "ti", "ip", "ni", "e", "xi", "x", "it", "ki", "h", "index"], "j": ["fr", "jo", "jc", "shift", "l", "si", "n", "jl", "o", "y", "dj", "p", "key", "jen", "qi", "oj", "d", "m", "aj", "job", "z", "adj", "ja", "k", "ij", "ii", "v", "uj", "el", "jet", "li", "jj", "position", "ie", "jon", "ji", "ix", "jp", "ch", "b", "q", "f", "jit", "kj", "js", "e", "out", "x", "it", "J", "h"], "height": ["high", "wall", "view", "family", "scale", "container", "def", "padding", "context", "img", "num", "density", "y", "bottom", "layout", "ha", "header", "ref", "qi", "crop", "input", "d", "images", "id", "buffer", "head", "alpha", "w", "resolution", "time", "k", "dim", "slice", "v", "frame", "window", "shape", "direction", "flow", "depth", "image", "style", "history", "gap", "f", "size", "h"]}}
{"project": "qemu", "commit_id": "7b0309490cb108d881a0c66d6b350b4db7b3b4ac", "target": 1, "func": "DeviceState *qdev_device_add(QemuOpts *opts)\n\n{\n\n    ObjectClass *oc;\n\n    DeviceClass *dc;\n\n    const char *driver, *path, *id;\n\n    DeviceState *dev;\n\n    BusState *bus = NULL;\n\n    Error *err = NULL;\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    if (!driver) {\n\n        qerror_report(QERR_MISSING_PARAMETER, \"driver\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find driver */\n\n    oc = object_class_by_name(driver);\n\n    if (!oc) {\n\n        const char *typename = find_typename_by_alias(driver);\n\n\n\n        if (typename) {\n\n            driver = typename;\n\n            oc = object_class_by_name(driver);\n\n        }\n\n    }\n\n\n\n    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n\n                      \"'%s' is not a valid device model name\", driver);\n\n        return NULL;\n\n    }\n\n\n\n    if (object_class_is_abstract(oc)) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"non-abstract device type\");\n\n        return NULL;\n\n    }\n\n\n\n    dc = DEVICE_CLASS(oc);\n\n    if (dc->cannot_instantiate_with_device_add_yet) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"pluggable device type\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find bus */\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n\n            qerror_report(QERR_BAD_BUS_FOR_DEVICE,\n\n                          driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus) {\n\n            qerror_report(QERR_NO_BUS_FOR_DEVICE,\n\n                          dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !bus->allow_hotplug) {\n\n        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    /* create device, set properties */\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n    }\n\n\n\n    id = qemu_opts_id(opts);\n\n    if (id) {\n\n        dev->id = id;\n\n    }\n\n    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        return NULL;\n\n    }\n\n    if (dev->id) {\n\n        object_property_add_child(qdev_get_peripheral(), dev->id,\n\n                                  OBJECT(dev), NULL);\n\n    } else {\n\n        static int anon_count;\n\n        gchar *name = g_strdup_printf(\"device[%d]\", anon_count++);\n\n        object_property_add_child(qdev_get_peripheral_anon(), name,\n\n                                  OBJECT(dev), NULL);\n\n        g_free(name);\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        qerror_report_err(err);\n\n        error_free(err);\n\n        dev->opts = NULL;\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        qerror_report(QERR_DEVICE_INIT_FAILED, driver);\n\n        return NULL;\n\n    }\n\n    return dev;\n\n}\n", "idx": 491, "substitutes": {"opts": ["opttions", "opTS", "opfs", "optps", "experts", "opds", "optts", " copts", "otts", "optds", " copths", "lockTS", "obts", "optfs", " coptions", "alts", "lockoptions", "opoptions", "opths", "experps", " copters", "alps", "oboptions", "opps", "experters", "optoptions", "experds", "ottions", "optters", "opters", "obTS", "optTS", "options", "lockfs", "otters", "otths", "alds", "obfs", "optths", "lockts", "alters"], "oc": ["soc", "oca", "cc", "loc", "sc", "ac", "ok", "rc", "fc", "drive", "enc", "bb", "oo", "object", "o", "cca", "vc", "ic", "ec", "root", "dr", "oci", "acc", "word", "voc", "org", "unc", "oco", "ou", "pc", "roc", "ocr", "co", "oe", "oper", "coll", "mot", "c", "nc", "oid", "ob", "mc", "ace", "toc", "om", "OC", "os", "op", "ow", "iv", "bc", "http", "client", "uc", "lc", "anc"], "dc": ["cat", "cu", "cc", "disc", "sc", "cf", "ac", "device", "fc", "rc", "dir", "cca", "vc", "ec", "gc", "dr", "xc", "d", "config", "input", "dat", "DC", "ga", "cdn", "tc", "df", "lc", "pc", "ca", "coll", "dn", "c", "dt", "nc", "di", "mc", " DC", "db", "inc", "doc", "da", "director", "bc", "cm", "ds", "design", "cd"], "driver": ["text", "database", "uri", "reader", "construct", "d", "wrapper", "plugin", "cost", "der", "browser", "this", "iv", "s", "host", "serial", "_", "manager", "error", "drive", "object", "config", "ctor", "ride", "route", "Driver", "mode", "owner", "port", "url", "drivers", "test", "args", "slave", "director", "username", "ops", "feed", "project", "device", "dir", "dr", "engine", "loader", "service", "writer", "str", "dn", "driving", "oid", "sl", "design", "desc", "river", "rider", "force", "operator", "handler", "platform", "class", "end", "type", "coll", "c", "direction", "target", "get", "creator", "version", "pass", "vers"], "path": ["host", "user", "mount", "serial", "text", "loc", "device", "hop", "context", "object", "uri", "dir", "pattern", "location", "key", "alias", "root", "node", "ath", "input", "config", "cross", "step", "route", "method", "full", "loader", "prefix", "data", "parent", "length", "work", "port", "request", "url", "test", "target", "Path", "image", "resource", "child", "pass", "inner", "pointer", "sync", "source", "desc"], "id": ["host", "ident", "ID", "code", "uri", "dir", "sid", "kind", "key", "ids", "pid", "head", "route", "end", "kid", "mid", "Id", "parent", "length", "port", "url", "target", "image", "ip", "address", "tag", "source"], "dev": ["user", "host", "serial", "dist", "cache", "sync", "device", "def", "dir", "lib", "debug", "root", "node", "session", "engine", "dest", "data", "Dev", "test", "local", "block", "proc", "der", "ver", "ev"], "bus": ["host", "cat", "serial", "feed", "cache", "mount", "home", "loop", "las", "io", "bug", "back", "project", "base", "device", "drive", "object", "unit", "lib", "vc", "root", "BUS", "comment", "bridge", "config", "session", "product", "plug", "load", "route", "phone", "class", "build", "service", "usb", "coll", "front", "us", "hub", "port", "nt", "test", "pull", "plugin", "board", "boot", "block", "local", "state", "book", "proc", "db", "os", "child", "pass", "bc", "http", "sync", "Bus"], "err": ["cr", "rr", "res", "gr", "ir", "req", "pr", "rh", "error", "fi", "er", "arr", "usr", "iter", "Error", "ah", "str", "coll", "ise", "ar", "rs", "ner", "ch", "proc", "der", "cur", "ev"], "typename": ["helperename", "helperate", "tyename", "typerames", "tyenames", "tyrename", "cyperename", "tyrenname", "sypenename", "typeame", "sypamed", "typerame", "typedamed", "tyrenename", "typeename", "typenames", "typenename", "typedate", "typame", "helpenate", "typeamed", "cyperame", "cypername", "typenname", "typenamed", "sypenamel", "cypenamed", "typenamel", "helpenames", "typername", "sypenamed", "cypenename", "tyenename", "typedames", "tyenate", "helperames", "helpenename", "cyperamed", "sypamel", "sypame", "typamed", "typeamel", "typamel", "tyrenamel", "typedname", "typenate", "helpename", "typerename", "typedame", "typedename", "typeramed", "helperame", "sypename", "tyrenamed", "typerate", "cypenname", "cypename"]}}
{"project": "qemu", "commit_id": "c4d9d19645a484298a67e9021060bc7c2b081d0f", "target": 0, "func": "void thread_pool_submit(ThreadPoolFunc *func, void *arg)\n\n{\n\n    thread_pool_submit_aio(func, arg, NULL, NULL);\n\n}\n", "idx": 501, "substitutes": {"func": ["fn", "kw", "xxx", "cc", "pkg", "attr", "cf", "lambda", "ctx", "code", "function", "super", "exec", "src", "thread", "wrapper", "call", "Function", "amd", "unc", "class", "a", "pc", "package", "fun", "c", "self", "cb", "proc", "b", "as", "f", "cl", "this", "bc", "lc"], "arg": ["cat", "loc", " args", "ac", "Arg", "array", "enc", "ack", "sec", "arc", " Arg", "exec", "ig", "param", "arr", "Args", "new", "var", "call", " argument", "ass", "pc", "g", "ann", "ar", "item", "ace", "args", "ax", "inc", "par", "amp", "empty", "argument"]}}
{"project": "qemu", "commit_id": "a35faa94c8e8d851a1d07e17c98f4ab2202b8a38", "target": 0, "func": "static void pl061_register_devices(void)\n\n{\n\n    sysbus_register_dev(\"pl061\", sizeof(pl061_state),\n\n                        pl061_init_arm);\n\n    sysbus_register_dev(\"pl061_luminary\", sizeof(pl061_state),\n\n                        pl061_init_luminary);\n\n}\n", "idx": 510, "substitutes": {}}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "int cpu_exec(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    int ret;\n\n    SyncClocks sc;\n\n\n\n    /* replay_interrupt may need current_cpu */\n\n    current_cpu = cpu;\n\n\n\n    if (cpu_handle_halt(cpu)) {\n\n        return EXCP_HALTED;\n\n    }\n\n\n\n    rcu_read_lock();\n\n\n\n    cc->cpu_exec_enter(cpu);\n\n\n\n    /* Calculate difference between guest clock and host clock.\n\n     * This delay includes the delay of the last cycle, so\n\n     * what we have to do is sleep until it is 0. As for the\n\n     * advance/delay we gain here, we try to fix it next time.\n\n     */\n\n    init_delay_params(&sc, cpu);\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    if (sigsetjmp(cpu->jmp_env, 0) != 0) {\n\n#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)\n\n        /* Some compilers wrongly smash all local variables after\n\n         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.\n\n         * Reload essential local variables here for those compilers.\n\n         * Newer versions of gcc would complain about this code (-Wclobbered). */\n\n        cpu = current_cpu;\n\n        cc = CPU_GET_CLASS(cpu);\n\n#else /* buggy compiler */\n\n        /* Assert that the compiler does not smash local variables. */\n\n        g_assert(cpu == current_cpu);\n\n        g_assert(cc == CPU_GET_CLASS(cpu));\n\n#endif /* buggy compiler */\n\n        cpu->can_do_io = 1;\n\n        tb_lock_reset();\n\n        if (qemu_mutex_iothread_locked()) {\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n    }\n\n\n\n    /* if an exception is pending, we execute it here */\n\n    while (!cpu_handle_exception(cpu, &ret)) {\n\n        TranslationBlock *last_tb = NULL;\n\n        int tb_exit = 0;\n\n\n\n        while (!cpu_handle_interrupt(cpu, &last_tb)) {\n\n            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);\n\n            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);\n\n            /* Try to align the host and virtual clocks\n\n               if the guest is in advance */\n\n            align_clocks(&sc, cpu);\n\n        }\n\n    }\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n    rcu_read_unlock();\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n\n\n    return ret;\n\n}\n", "idx": 539, "substitutes": {"cpu": ["pkg", "cmp", "intel", " CPU", "cci", "cn", " cp", "auc", "cow", "boot", "cb", " pc", "proc", "bc", "lb", "processor", "gru", "cpp", "fc", "uu", "null", "uca", "ci", "node", "xc", "config", "pid", "vm", "gpu", "roc", "css", "comp", "current", "prof", "performance", "CPU", "chip", "net", "lc", "cu", "uci", "fps", "ctx", "core", " proc", "sta", "cp", "loader", "conn", "pc", "server", "ctrl", "pu", "process", "ilo", "uc", "cm", "clock", "cache", "dc", "mac", "cf", "rc", "linux", "computer", "fp", "gc", "cli", "tc", "px", "platform", "frame", "consumer", "bench", "console", "c", "nc", "ck", "nic", "none", "hw"], "cc": ["cu", "cache", "dc", "cod", "cf", "rc", "cmp", "cs", "fc", "ctx", "code", "core", "cca", "CC", "ci", "ce", " gcc", "ec", "gc", "xc", "cci", "acc", "PC", "tc", "con", "class", "cp", "VC", "conn", "pc", "co", "ca", "LC", "css", "cn", "c", "ctrl", "mc", "ucc", "cb", "ck", "cl", "bc", "client", "uc", "cm"], "ret": ["rep", "val", "res", "value", "scan", "back", " RET", "match", "pet", "fi", " Ret", "sec", "resp", "num", "alt", "valid", "RET", "ref", "mem", "det", "gc", "job", "rf", "buffer", "nz", "len", "hard", "reset", "ben", "success", "sys", "rets", "pc", "data", "reply", "ry", "fun", "nt", "rs", "reg", "test", "result", "get", "arg", "Ret", "al", "cur", "re", "ctr", "pass", "addr", "en"], "sc": ["ctl", "loop", "soc", "sw", "cr", "dc", "sr", "ac", "rc", "Sc", "cs", "si", "fc", "sh", "core", "SC", "exec", "isc", "src", " SC", "ec", "ct", "config", "sq", "acc", " Sc", "access", "sci", "tc", "asc", "cv", "esc", "pc", "ca", "sys", "sp", "spec", "sb", "rs", "c", "sac", "comp", "scope", "RC", " scr", "mc", " ss", "osc", "cl", " rc", "ss", "sk", "bc", "uc", "lc"], "last_tb": ["last_torb", "last_nb", "last_Tf", "last_tlb", "last_tabb", "last_ptbs", "last_Tp", "last_Tbi", "last_nlb", "last_tub", "last_ptk", "last_ptb", "last_Tabb", "last_torbi", "last_ptub", "last_torbs", "last_Tbl", "last_interk", "last_tbs", "last_typ", "last_nbs", "last_ctabb", "last_pbs", "last_tbl", "last_tbi", "last_nbl", "last_ctp", "last_interb", "last_ptf", "last_pbi", "last_tk", "last_ctb", "last_tybs", "last_tyb", "last_interub", "last_tp", "last_ptbl", "last_tf", "last_Tk", "last_pb", "last_Tlb", "last_ctbs", "last_Tbase", "last_tyabb", "last_Tbs", "last_pbase", "last_Tb", "last_interf", "last_torbase", "last_tbase", "last_ptlb", "last_Tub"], "tb": ["ttk", "ptbs", "tr", "ptr", "ptb", "rtk", "rtr", " tbb", "tsbb", "ttbs", "tk", "ttb", "tsbi", "ttbi", "ttr", "tbs", "rtbs", "ptk", "tsb", "ttbb", "tsr", "tbi", "tbb", "rtb", " tr", " tbi"]}}
{"project": "qemu", "commit_id": "b7b6348ab433519f16c1500e3ea04805428be91e", "target": 0, "func": "static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)\n\n{\n\n    int i;\n\n    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;\n\n    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;\n\n\n\n    copy_scsw_to_guest(&dest->scsw, &src->scsw);\n\n\n\n    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {\n\n        dest->esw[i] = cpu_to_be32(src->esw[i]);\n\n    }\n\n    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {\n\n        dest->ecw[i] = cpu_to_be32(src->ecw[i]);\n\n    }\n\n    /* extended measurements enabled? */\n\n    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||\n\n        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||\n\n        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {\n\n        return;\n\n    }\n\n    /* extended measurements pending? */\n\n    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {\n\n        return;\n\n    }\n\n    if ((stctl & SCSW_STCTL_PRIMARY) ||\n\n        (stctl == SCSW_STCTL_SECONDARY) ||\n\n        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {\n\n        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {\n\n            dest->emw[i] = cpu_to_be32(src->emw[i]);\n\n        }\n\n    }\n\n}\n", "idx": 547, "substitutes": {"dest": ["dist", "home", "text", "decl", "des", "comb", "ord", "grad", "temp", "opt", "usr", "d", "access", "sum", "orig", "lit", "build", "feat", "parent", "output", "proc", " Dest", "wb", "this", "coord", "cont", "done", "inst", "sort", "de", "outer", "st", "tmp", "gest", "config", "dat", "stage", "miss", "cdn", "destroy", "nt", "test", "pack", "slave", "sup", "priv", "wd", "ident", "sc", "gen", "new", "iter", "store", "cp", "trans", "txt", "global", "std", "Dest", "uc", "later", "source", "desc", "uv", "dc", "die", "loc", "img", " dst", "rest", "master", "class", "end", "target"], "src": ["gl", "dist", "rb", "sth", "req", "sub", "cmp", "grad", "sec", "sel", "reflect", "send", "sn", "sci", "ruby", "feat", "sb", "cb", "this", "iv", "bc", "inf", "usc", "inst", "sr", "sit", "st", "tmp", "impl", "ins", "config", "cv", "roc", "url", "RC", "rob", "sup", "sync", "lc", "support", "sc", "ack", "ctx", "ssl", "core", "stack", "sq", "bs", "slice", "usb", "ources", "chrom", "spec", "cur", "sl", "uc", "source", "uv", "sur", "loc", "attr", "rc", "img", "super", "scl", "cli", "rest", "master", "sys", "rs", "self", "target", "gb", "bin", "rl"], "pmcw": ["pmcwl", "mplcw", " pmpcew", "pmdcew", "pmmcwy", "pmlcws", "pmcwy", "pmdcsw", "pmlcwl", " pmpcwl", "PMcwa", "mplcsw", "pmcws", "pmrcwd", "PMcwd", "pmpcw", "mplcws", "pmrcws", "pmpcwl", "pmcwa", "pmcew", " pmcwa", "mpcw", " pmcwl", "pmdcwa", "pmdcw", "PMdcwd", "pmmcw", "pmacwa", "mpcws", "PMdcwa", "pmdcwd", "pmlcew", "PMdcws", " pmcew", "mpcwy", "pmmcsw", "PMcw", "pmmcws", "pmdcwy", "pmacwd", "pmpcwa", "mplcwy", "pmdcws", "PMcws", " pmpcw", "pmlcwy", "pmdcwl", "pmcsw", "pmrcwa", "pmacw", "pmcwd", "pmlcwa", "pmpcew", " pmpcwa", "pmacws", "PMdcw", "mpcsw", "pmlcsw", "pmrcw", "pmlcw"], "i": ["anti", "uri", "key", "d", "mi", "isin", "ri", "count", "v", "bi", "ie", "iu", "ji", "ix", "info", "block", "pi", "f", "ti", "phi", "s", "ui", "l", "si", "y", "o", "p", "ci", "qi", "eni", "name", "li", "data", "init", "mu", "b", "u", "xi", "it", "h", "lc", "next", "io", "r", "fi", "multi", "m", "oi", "ini", "slice", "x", "g", "jj", "zi", "ai", "t", "ei", "ip", "e", "yi", "index", "hi", "j", "module", "cli", "id", "k", "ii", "a", "type", "c", "in", "start", "di", "gi", "ni", "I"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int process_input_packet(InputStream *ist, const AVPacket *pkt)\n\n{\n\n    int i;\n\n    int got_output;\n\n    AVPacket avpkt;\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->last_dts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int ret = 0;\n\n    handle_eof:\n\n\n\n        ist->last_dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size &&\n\n            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = decode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = decode_video    (ist, &avpkt, &got_output);\n\n            if (avpkt.duration)\n\n                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            else if (ist->st->avg_frame_rate.num)\n\n                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),\n\n                                              AV_TIME_BASE_Q);\n\n            else if (ist->dec_ctx->time_base.num != 0) {\n\n                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :\n\n                                                   ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        ist->last_dts = ist->next_dts;\n\n        switch (ist->dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /\n\n                             ist->dec_ctx->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (ist->dec_ctx->time_base.num != 0) {\n\n                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->dec_ctx->time_base.num * ticks) /\n\n                                  ist->dec_ctx->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 566, "substitutes": {"ist": ["iste", "dist", "part", "isd", "sth", "ord", "er", "ht", "sim", "ists", "isc", "wp", "rss", "ld", "adder", "pect", "est", "feat", "ast", "kt", "dit", "set", "post", "uss", "iz", "osi", "ird", "inst", "ait", "pick", "st", "gest", "nd", "ind", "ard", "dat", "ict", "et", "ad", "ista", "ant", "add", "IST", "nt", "artist", "gd", "ace", "irst", "op", "ft", "ct", "it", "dd", "oss", "wd", "erd", "act", "ism", "dr", "sta", "pop", "mot", "ocr", "str", "ust", "ilst", "xt", "std", "edit", "alist", "isi", "ess", "pt", "adr", "rest", "ext", "work", "ide", "isu", "asi", "asp", "esp", "art"], "pkt": ["pkg", " pelt", "punch", "Pct", "wpnt", "jpft", " pcht", "preelt", "packet", "pkh", "pacht", "Pcht", "wpcht", "tpqt", "tpcht", "Pft", "ipkt", "ipacket", "jpqt", "tcht", "Pkg", "dacket", " pqt", "tacket", "tkt", "spcht", "dunch", "pct", " poch", "spkh", "spacket", " packet", "tpacket", "ipnt", "ipkh", "ipelt", "wpkt", "wpkh", " pnt", "spelt", "prent", "paacket", "telt", "Pkt", "cpelt", "pelt", "jpkt", "Pqt", " pft", "ipcht", "Packet", "dkt", "poch", "pqt", " pct", "jpacket", "spkt", "tpkt", "spnt", "Punch", "pakt", "pnt", "Pnt", "pft", "prekt", "spkg", "pcht", "cpacket", " punch", "dct", "cpkt", "cpoch", "preacket", " pkg", "Pelt", "ipoch", "paelt"], "i": ["rep", "res", "j", "num", "n", "p", "debug", "fin", "multi", "det", "ret", "id", "I", "et", "len", "reset", "g", "nt", "inner", "start", "info", "f", "set", "out", "x", "it", "h", "en"], "got_output": [" got_Output", "got_Output", " got_progress", "gotacinput", "genesttarget", "given_control", "gen_target", "got_value", "gen_enabled", "gotesttarget", "genestoutput", "gotacoutput", "got_generated", " got_value", "got_hidden", "gen_generated", "gotestoutput", "gotestenabled", "gotayOutput", "got_input", "gotachidden", "given_input", "got_control", "gotestgenerated", "got_reason", "genestgenerated", "got_enabled", "genestenabled", "gotaygenerated", "got_progress", "got_target", "gotayreason", "gen_output", "gotaytarget", "gotayenabled", "gotayoutput", "given_hidden", "gotaccontrol", " got_reason", "given_output"], "avpkt": ["avbputh", "ajmkt", "avbft", "navpiece", "avhelt", "avlelt", "avbpelt", "attpck", "avpaft", "avepnt", "avhcht", "avprekt", "avpakt", "avopck", "ampeth", "navdacket", "ajpkt", "avgelt", "attcpet", "affck", "avcurrentnt", "avpet", "avfet", "avnpkh", "avcpt", "avrcht", "avrkt", "avbqt", "avfpka", "afpck", "avpracket", "avelpt", "amspcht", "avvacket", "ajmelt", "avpaunch", "avppck", "avespacket", "avespkt", "avnpft", "avpft", "avpeconn", "avpeacket", "navdkat", "avhkt", "avputh", "avpreKT", "ajmft", "avvelt", "airlelt", "ajpelt", "avwett", "avbett", "AVpkt", "avspacket", "amspelt", "avgkt", "avpauth", "ullpkt", "avcpet", "aveppt", "avpiece", "avenpck", "avpconn", "airpelt", "avcpkt", "avpsth", "avnpsth", "avgft", "avpreelt", "avgcht", "avepunch", "avpeck", "avbpck", "navpacket", "airpKT", "avppt", "avopet", "affacket", "avppka", "avpaacket", "avfck", "ajmcht", "avbconn", "airpkt", "AVpakt", "avspunch", "airbett", "avnpck", "avcurrentkt", "airbft", "avopacket", "attcpck", "avelnt", "avbpft", "avmft", "avfkat", "airlKT", "avspelt", "avfcht", "avcacket", "avdkat", "avpKT", "airbkt", "airpft", "avppkt", "avfacket", "avlacket", "avrett", "avppkh", "attcpkt", "avpelt", "avenpft", "avepcht", "avpunch", "avpka", "avapkt", "avapcht", "avepacket", "avvKT", "avbcht", "avcurrentpt", "avbkt", "avppsth", "navpkat", "avcnt", "ullppck", "attcpacket", "avfkt", "avfiece", "avbuth", "avprkt", "AVputh", "navdiece", "avenpka", "avbacket", "avfunch", "avbpkt", "avfpkt", "avcpacket", "avapelt", "ullpck", "avbpcht", "avmkt", "attpkt", "avepkt", "avfconn", "avpcht", "avpacket", "attpet", "avckt", "avspkt", "AVpft", "afpconn", "avelacket", "avpeth", "ampkt", "avlKT", "avpreacket", "airbcht", "avmcht", "avnpka", "amspeth", "avwkt", "avdacket", "afpkt", "airpett", "avspcht", "avfpft", "avlpt", "avpriece", "ullpkh", "ajpft", "avwft", "afpacket", "avnpkt", "avpnt", "attpacket", "avpett", "avelkt", "avppft", "avwcht", "AVpaft", "affconn", "avbck", "amspkt", "avespunch", "avprkat", "airlkt", "avepka", "airpcht", "navpkt", "avcurrentacket", "avvkt", "airlacket", "AVpauth", "ullppkh", "avespcht", "avpck", "ajpcht", "avpaqt", "avbpkh", "ullpsth", "avbpsth", "AVpaqt", "ampelt", "ampcht", "avmelt", "airpacket", "ullppkt", "avapeth", "avbpqt", "avlkt", "navdkt", "avopkt", "avfpck", "AVpqt", "avheth", "avpacht", "avdkt", "avrft", "avpkh", "avepck", "avdiece", "avpkat", "avlnt", "avenpkt", "affkt", "avpqt", "avepft", "avspeth", "avcpck", "avpekt", "ullppsth"]}}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "static target_ulong disas_insn(DisasContext *s, CPUState *cpu)\n\n{\n\n    CPUX86State *env = cpu->env_ptr;\n\n    int b, prefixes;\n\n    int shift;\n\n    TCGMemOp ot, aflag, dflag;\n\n    int modrm, reg, rm, mod, op, opreg, val;\n\n    target_ulong next_eip, tval;\n\n    int rex_w, rex_r;\n\n    target_ulong pc_start = s->base.pc_next;\n\n\n\n    s->pc_start = s->pc = pc_start;\n\n    prefixes = 0;\n\n    s->override = -1;\n\n    rex_w = -1;\n\n    rex_r = 0;\n\n#ifdef TARGET_X86_64\n\n    s->rex_x = 0;\n\n    s->rex_b = 0;\n\n    x86_64_hregs = 0;\n\n#endif\n\n    s->rip_offset = 0; /* for relative ip address */\n\n    s->vex_l = 0;\n\n    s->vex_v = 0;\n\n    if (sigsetjmp(s->jmpbuf, 0) != 0) {\n\n        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        return s->pc;\n\n    }\n\n\n\n next_byte:\n\n    b = x86_ldub_code(env, s);\n\n    /* Collect prefixes.  */\n\n    switch (b) {\n\n    case 0xf3:\n\n        prefixes |= PREFIX_REPZ;\n\n        goto next_byte;\n\n    case 0xf2:\n\n        prefixes |= PREFIX_REPNZ;\n\n        goto next_byte;\n\n    case 0xf0:\n\n        prefixes |= PREFIX_LOCK;\n\n        goto next_byte;\n\n    case 0x2e:\n\n        s->override = R_CS;\n\n        goto next_byte;\n\n    case 0x36:\n\n        s->override = R_SS;\n\n        goto next_byte;\n\n    case 0x3e:\n\n        s->override = R_DS;\n\n        goto next_byte;\n\n    case 0x26:\n\n        s->override = R_ES;\n\n        goto next_byte;\n\n    case 0x64:\n\n        s->override = R_FS;\n\n        goto next_byte;\n\n    case 0x65:\n\n        s->override = R_GS;\n\n        goto next_byte;\n\n    case 0x66:\n\n        prefixes |= PREFIX_DATA;\n\n        goto next_byte;\n\n    case 0x67:\n\n        prefixes |= PREFIX_ADR;\n\n        goto next_byte;\n\n#ifdef TARGET_X86_64\n\n    case 0x40 ... 0x4f:\n\n        if (CODE64(s)) {\n\n            /* REX prefix */\n\n            rex_w = (b >> 3) & 1;\n\n            rex_r = (b & 0x4) << 1;\n\n            s->rex_x = (b & 0x2) << 2;\n\n            REX_B(s) = (b & 0x1) << 3;\n\n            x86_64_hregs = 1; /* select uniform byte register addressing */\n\n            goto next_byte;\n\n        }\n\n        break;\n\n#endif\n\n    case 0xc5: /* 2-byte VEX */\n\n    case 0xc4: /* 3-byte VEX */\n\n        /* VEX prefixes cannot be used except in 32-bit mode.\n\n           Otherwise the instruction is LES or LDS.  */\n\n        if (s->code32 && !s->vm86) {\n\n            static const int pp_prefix[4] = {\n\n                0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ\n\n            };\n\n            int vex3, vex2 = x86_ldub_code(env, s);\n\n\n\n            if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) {\n\n                /* 4.1.4.6: In 32-bit mode, bits [7:6] must be 11b,\n\n                   otherwise the instruction is LES or LDS.  */\n\n                break;\n\n            }\n\n            s->pc++;\n\n\n\n            /* 4.1.1-4.1.3: No preceding lock, 66, f2, f3, or rex prefixes. */\n\n            if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ\n\n                            | PREFIX_LOCK | PREFIX_DATA)) {\n\n                goto illegal_op;\n\n            }\n\n#ifdef TARGET_X86_64\n\n            if (x86_64_hregs) {\n\n                goto illegal_op;\n\n            }\n\n#endif\n\n            rex_r = (~vex2 >> 4) & 8;\n\n            if (b == 0xc5) {\n\n                vex3 = vex2;\n\n                b = x86_ldub_code(env, s);\n\n            } else {\n\n#ifdef TARGET_X86_64\n\n                s->rex_x = (~vex2 >> 3) & 8;\n\n                s->rex_b = (~vex2 >> 2) & 8;\n\n#endif\n\n                vex3 = x86_ldub_code(env, s);\n\n                rex_w = (vex3 >> 7) & 1;\n\n                switch (vex2 & 0x1f) {\n\n                case 0x01: /* Implied 0f leading opcode bytes.  */\n\n                    b = x86_ldub_code(env, s) | 0x100;\n\n                    break;\n\n                case 0x02: /* Implied 0f 38 leading opcode bytes.  */\n\n                    b = 0x138;\n\n                    break;\n\n                case 0x03: /* Implied 0f 3a leading opcode bytes.  */\n\n                    b = 0x13a;\n\n                    break;\n\n                default:   /* Reserved for future use.  */\n\n                    goto unknown_op;\n\n                }\n\n            }\n\n            s->vex_v = (~vex3 >> 3) & 0xf;\n\n            s->vex_l = (vex3 >> 2) & 1;\n\n            prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX;\n\n        }\n\n        break;\n\n    }\n\n\n\n    /* Post-process prefixes.  */\n\n    if (CODE64(s)) {\n\n        /* In 64-bit mode, the default data size is 32-bit.  Select 64-bit\n\n           data with rex_w, and 16-bit data with 0x66; rex_w takes precedence\n\n           over 0x66 if both are present.  */\n\n        dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32);\n\n        /* In 64-bit mode, 0x67 selects 32-bit addressing.  */\n\n        aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64);\n\n    } else {\n\n        /* In 16/32-bit mode, 0x66 selects the opposite data size.  */\n\n        if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) {\n\n            dflag = MO_32;\n\n        } else {\n\n            dflag = MO_16;\n\n        }\n\n        /* In 16/32-bit mode, 0x67 selects the opposite addressing.  */\n\n        if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) {\n\n            aflag = MO_32;\n\n        }  else {\n\n            aflag = MO_16;\n\n        }\n\n    }\n\n\n\n    s->prefix = prefixes;\n\n    s->aflag = aflag;\n\n    s->dflag = dflag;\n\n\n\n    /* now check op code */\n\n reswitch:\n\n    switch(b) {\n\n    case 0x0f:\n\n        /**************************/\n\n        /* extended op code */\n\n        b = x86_ldub_code(env, s) | 0x100;\n\n        goto reswitch;\n\n\n\n        /**************************/\n\n        /* arith & logic */\n\n    case 0x00 ... 0x05:\n\n    case 0x08 ... 0x0d:\n\n    case 0x10 ... 0x15:\n\n    case 0x18 ... 0x1d:\n\n    case 0x20 ... 0x25:\n\n    case 0x28 ... 0x2d:\n\n    case 0x30 ... 0x35:\n\n    case 0x38 ... 0x3d:\n\n        {\n\n            int op, f, val;\n\n            op = (b >> 3) & 7;\n\n            f = (b >> 1) & 3;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n\n\n            switch(f) {\n\n            case 0: /* OP Ev, Gv */\n\n                modrm = x86_ldub_code(env, s);\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                mod = (modrm >> 6) & 3;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    opreg = OR_TMP0;\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                xor_zero:\n\n                    /* xor reg, reg optimisation */\n\n                    set_cc_op(s, CC_OP_CLR);\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n                    break;\n\n                } else {\n\n                    opreg = rm;\n\n                }\n\n                gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n                gen_op(s, op, ot, opreg);\n\n                break;\n\n            case 1: /* OP Gv, Ev */\n\n                modrm = x86_ldub_code(env, s);\n\n                mod = (modrm >> 6) & 3;\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                    goto xor_zero;\n\n                } else {\n\n                    gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n                }\n\n                gen_op(s, op, ot, reg);\n\n                break;\n\n            case 2: /* OP A, Iv */\n\n                val = insn_get(env, s, ot);\n\n                tcg_gen_movi_tl(cpu_T1, val);\n\n                gen_op(s, op, ot, OR_EAX);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x82:\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n    case 0x80: /* GRP1 */\n\n    case 0x81:\n\n    case 0x83:\n\n        {\n\n            int val;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (b == 0x83)\n\n                    s->rip_offset = 1;\n\n                else\n\n                    s->rip_offset = insn_const_size(ot);\n\n                gen_lea_modrm(env, s, modrm);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = rm;\n\n            }\n\n\n\n            switch(b) {\n\n            default:\n\n            case 0x80:\n\n            case 0x81:\n\n            case 0x82:\n\n                val = insn_get(env, s, ot);\n\n                break;\n\n            case 0x83:\n\n                val = (int8_t)insn_get(env, s, MO_8);\n\n                break;\n\n            }\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n            gen_op(s, op, ot, opreg);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* inc, dec, and other misc arith */\n\n    case 0x40 ... 0x47: /* inc Gv */\n\n        ot = dflag;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), 1);\n\n        break;\n\n    case 0x48 ... 0x4f: /* dec Gv */\n\n        ot = dflag;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), -1);\n\n        break;\n\n    case 0xf6: /* GRP3 */\n\n    case 0xf7:\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (mod != 3) {\n\n            if (op == 0) {\n\n                s->rip_offset = insn_const_size(ot);\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            /* For those below that handle locked memory, don't load here.  */\n\n            if (!(s->prefix & PREFIX_LOCK)\n\n                || op != 2) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* test */\n\n            val = insn_get(env, s, ot);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n            gen_op_testl_T0_T1_cc();\n\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n            break;\n\n        case 2: /* not */\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                tcg_gen_movi_tl(cpu_T0, ~0);\n\n                tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0,\n\n                                            s->mem_index, ot | MO_LE);\n\n            } else {\n\n                tcg_gen_not_tl(cpu_T0, cpu_T0);\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n            break;\n\n        case 3: /* neg */\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                TCGLabel *label1;\n\n                TCGv a0, t0, t1, t2;\n\n\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                a0 = tcg_temp_local_new();\n\n                t0 = tcg_temp_local_new();\n\n                label1 = gen_new_label();\n\n\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n                tcg_gen_mov_tl(t0, cpu_T0);\n\n\n\n                gen_set_label(label1);\n\n                t1 = tcg_temp_new();\n\n                t2 = tcg_temp_new();\n\n                tcg_gen_mov_tl(t2, t0);\n\n                tcg_gen_neg_tl(t1, t0);\n\n                tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1,\n\n                                          s->mem_index, ot | MO_LE);\n\n                tcg_temp_free(t1);\n\n                tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1);\n\n\n\n                tcg_temp_free(t2);\n\n                tcg_temp_free(a0);\n\n                tcg_gen_mov_tl(cpu_T0, t0);\n\n                tcg_temp_free(t0);\n\n            } else {\n\n                tcg_gen_neg_tl(cpu_T0, cpu_T0);\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n            gen_op_update_neg_cc();\n\n            set_cc_op(s, CC_OP_SUBB + ot);\n\n            break;\n\n        case 4: /* mul */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n\n                tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext8u_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00);\n\n                set_cc_op(s, CC_OP_MULB);\n\n                break;\n\n            case MO_16:\n\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext16u_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n                set_cc_op(s, CC_OP_MULW);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n\n                tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULL);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n\n                                  cpu_T0, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULQ);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 5: /* imul */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n\n                tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext8s_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n                set_cc_op(s, CC_OP_MULB);\n\n                break;\n\n            case MO_16:\n\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n\n                tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n                set_cc_op(s, CC_OP_MULW);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n\n                tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n\n                tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n\n                set_cc_op(s, CC_OP_MULL);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n\n                                  cpu_T0, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULQ);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 6: /* div */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_helper_divb_AL(cpu_env, cpu_T0);\n\n                break;\n\n            case MO_16:\n\n                gen_helper_divw_AX(cpu_env, cpu_T0);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                gen_helper_divl_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                gen_helper_divq_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 7: /* idiv */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_helper_idivb_AL(cpu_env, cpu_T0);\n\n                break;\n\n            case MO_16:\n\n                gen_helper_idivw_AX(cpu_env, cpu_T0);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                gen_helper_idivl_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                gen_helper_idivq_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0xfe: /* GRP4 */\n\n    case 0xff: /* GRP5 */\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (op >= 2 && b == 0xfe) {\n\n            goto unknown_op;\n\n        }\n\n        if (CODE64(s)) {\n\n            if (op == 2 || op == 4) {\n\n                /* operand size for jumps is 64 bit */\n\n                ot = MO_64;\n\n            } else if (op == 3 || op == 5) {\n\n                ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16;\n\n            } else if (op == 6) {\n\n                /* default push size is 64 bit */\n\n                ot = mo_pushpop(s, dflag);\n\n            }\n\n        }\n\n        if (mod != 3) {\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (op >= 2 && op != 3 && op != 5)\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* inc Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, 1);\n\n            break;\n\n        case 1: /* dec Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, -1);\n\n            break;\n\n        case 2: /* call Ev */\n\n            /* XXX: optimize if memory (no 'and' is necessary) */\n\n            if (dflag == MO_16) {\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n            }\n\n            next_eip = s->pc - s->cs_base;\n\n            tcg_gen_movi_tl(cpu_T1, next_eip);\n\n            gen_push_v(s, cpu_T1);\n\n            gen_op_jmp_v(cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jr(s, cpu_T0);\n\n            break;\n\n        case 3: /* lcall Ev */\n\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 1 << ot);\n\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        do_lcall:\n\n            if (s->pe && !s->vm86) {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                           tcg_const_i32(dflag - 1),\n\n                                           tcg_const_tl(s->pc - s->cs_base));\n\n            } else {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                      tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            }\n\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n\n            gen_jr(s, cpu_tmp4);\n\n            break;\n\n        case 4: /* jmp Ev */\n\n            if (dflag == MO_16) {\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n            }\n\n            gen_op_jmp_v(cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jr(s, cpu_T0);\n\n            break;\n\n        case 5: /* ljmp Ev */\n\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 1 << ot);\n\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        do_ljmp:\n\n            if (s->pe && !s->vm86) {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                          tcg_const_tl(s->pc - s->cs_base));\n\n            } else {\n\n                gen_op_movl_seg_T0_vm(R_CS);\n\n                gen_op_jmp_v(cpu_T1);\n\n            }\n\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n\n            gen_jr(s, cpu_tmp4);\n\n            break;\n\n        case 6: /* push Ev */\n\n            gen_push_v(s, cpu_T0);\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x84: /* test Ev, Gv */\n\n    case 0x85:\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n        gen_op_testl_T0_T1_cc();\n\n        set_cc_op(s, CC_OP_LOGICB + ot);\n\n        break;\n\n\n\n    case 0xa8: /* test eAX, Iv */\n\n    case 0xa9:\n\n        ot = mo_b_d(b, dflag);\n\n        val = insn_get(env, s, ot);\n\n\n\n        gen_op_mov_v_reg(ot, cpu_T0, OR_EAX);\n\n        tcg_gen_movi_tl(cpu_T1, val);\n\n        gen_op_testl_T0_T1_cc();\n\n        set_cc_op(s, CC_OP_LOGICB + ot);\n\n        break;\n\n\n\n    case 0x98: /* CWDE/CBW */\n\n        switch (dflag) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0);\n\n            break;\n\n        case MO_16:\n\n            gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX);\n\n            tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n            break;\n\n        default:\n\n            tcg_abort();\n\n        }\n\n        break;\n\n    case 0x99: /* CDQ/CWD */\n\n        switch (dflag) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 63);\n\n            gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 31);\n\n            gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0);\n\n            break;\n\n        case MO_16:\n\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 15);\n\n            gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n            break;\n\n        default:\n\n            tcg_abort();\n\n        }\n\n        break;\n\n    case 0x1af: /* imul Gv, Ev */\n\n    case 0x69: /* imul Gv, Ev, I */\n\n    case 0x6b:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (b == 0x69)\n\n            s->rip_offset = insn_const_size(ot);\n\n        else if (b == 0x6b)\n\n            s->rip_offset = 1;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        if (b == 0x69) {\n\n            val = insn_get(env, s, ot);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n        } else if (b == 0x6b) {\n\n            val = (int8_t)insn_get(env, s, MO_8);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n        }\n\n        switch (ot) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n\n            tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n            tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                              cpu_tmp2_i32, cpu_tmp3_i32);\n\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n\n            tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n\n            tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n            tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n\n            break;\n\n        default:\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n\n            /* XXX: use 32 bit mul which could be faster */\n\n            tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n            tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n            break;\n\n        }\n\n        set_cc_op(s, CC_OP_MULB + ot);\n\n        break;\n\n    case 0x1c0:\n\n    case 0x1c1: /* xadd Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n            tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n        } else {\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            } else {\n\n                gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        }\n\n        gen_op_update2_cc();\n\n        set_cc_op(s, CC_OP_ADDB + ot);\n\n        break;\n\n    case 0x1b0:\n\n    case 0x1b1: /* cmpxchg Ev, Gv */\n\n        {\n\n            TCGv oldv, newv, cmpv;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            oldv = tcg_temp_new();\n\n            newv = tcg_temp_new();\n\n            cmpv = tcg_temp_new();\n\n            gen_op_mov_v_reg(ot, newv, reg);\n\n            tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]);\n\n\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv,\n\n                                          s->mem_index, ot | MO_LE);\n\n                gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n            } else {\n\n                if (mod == 3) {\n\n                    rm = (modrm & 7) | REX_B(s);\n\n                    gen_op_mov_v_reg(ot, oldv, rm);\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_op_ld_v(s, ot, oldv, cpu_A0);\n\n                    rm = 0; /* avoid warning */\n\n                }\n\n                gen_extu(ot, oldv);\n\n                gen_extu(ot, cmpv);\n\n                /* store value = (old == cmp ? new : old);  */\n\n                tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv);\n\n                if (mod == 3) {\n\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n                    gen_op_mov_reg_v(ot, rm, newv);\n\n                } else {\n\n                    /* Perform an unconditional store cycle like physical cpu;\n\n                       must be before changing accumulator to ensure\n\n                       idempotency if the store faults and the instruction\n\n                       is restarted */\n\n                    gen_op_st_v(s, ot, newv, cpu_A0);\n\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n                }\n\n            }\n\n            tcg_gen_mov_tl(cpu_cc_src, oldv);\n\n            tcg_gen_mov_tl(cpu_cc_srcT, cmpv);\n\n            tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv);\n\n            set_cc_op(s, CC_OP_SUBB + ot);\n\n            tcg_temp_free(oldv);\n\n            tcg_temp_free(newv);\n\n            tcg_temp_free(cmpv);\n\n        }\n\n        break;\n\n    case 0x1c7: /* cmpxchg8b */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if ((mod == 3) || ((modrm & 0x38) != 0x8))\n\n            goto illegal_op;\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_CX16))\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n\n                gen_helper_cmpxchg16b(cpu_env, cpu_A0);\n\n            } else {\n\n                gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0);\n\n            }\n\n        } else\n\n#endif        \n\n        {\n\n            if (!(s->cpuid_features & CPUID_CX8))\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n\n                gen_helper_cmpxchg8b(cpu_env, cpu_A0);\n\n            } else {\n\n                gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0);\n\n            }\n\n        }\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n\n\n        /**************************/\n\n        /* push/pop */\n\n    case 0x50 ... 0x57: /* push */\n\n        gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s));\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x58 ... 0x5f: /* pop */\n\n        ot = gen_pop_T0(s);\n\n        /* NOTE: order is important for pop %sp */\n\n        gen_pop_update(s, ot);\n\n        gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0);\n\n        break;\n\n    case 0x60: /* pusha */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_pusha(s);\n\n        break;\n\n    case 0x61: /* popa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_popa(s);\n\n        break;\n\n    case 0x68: /* push Iv */\n\n    case 0x6a:\n\n        ot = mo_pushpop(s, dflag);\n\n        if (b == 0x68)\n\n            val = insn_get(env, s, ot);\n\n        else\n\n            val = (int8_t)insn_get(env, s, MO_8);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x8f: /* pop Ev */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        ot = gen_pop_T0(s);\n\n        if (mod == 3) {\n\n            /* NOTE: order is important for pop %sp */\n\n            gen_pop_update(s, ot);\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n        } else {\n\n            /* NOTE: order is important too for MMU exceptions */\n\n            s->popl_esp_hack = 1 << ot;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            s->popl_esp_hack = 0;\n\n            gen_pop_update(s, ot);\n\n        }\n\n        break;\n\n    case 0xc8: /* enter */\n\n        {\n\n            int level;\n\n            val = x86_lduw_code(env, s);\n\n            level = x86_ldub_code(env, s);\n\n            gen_enter(s, val, level);\n\n        }\n\n        break;\n\n    case 0xc9: /* leave */\n\n        gen_leave(s);\n\n        break;\n\n    case 0x06: /* push es */\n\n    case 0x0e: /* push cs */\n\n    case 0x16: /* push ss */\n\n    case 0x1e: /* push ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(b >> 3);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x1a0: /* push fs */\n\n    case 0x1a8: /* push gs */\n\n        gen_op_movl_T0_seg((b >> 3) & 7);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x07: /* pop es */\n\n    case 0x17: /* pop ss */\n\n    case 0x1f: /* pop ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        reg = b >> 3;\n\n        ot = gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, reg);\n\n        gen_pop_update(s, ot);\n\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            if (reg == R_SS) {\n\n                s->tf = 0;\n\n                gen_eob_inhibit_irq(s, true);\n\n            } else {\n\n                gen_eob(s);\n\n            }\n\n        }\n\n        break;\n\n    case 0x1a1: /* pop fs */\n\n    case 0x1a9: /* pop gs */\n\n        ot = gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, (b >> 3) & 7);\n\n        gen_pop_update(s, ot);\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* mov */\n\n    case 0x88:\n\n    case 0x89: /* mov Gv, Ev */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0xc6:\n\n    case 0xc7: /* mov Ev, Iv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod != 3) {\n\n            s->rip_offset = insn_const_size(ot);\n\n            gen_lea_modrm(env, s, modrm);\n\n        }\n\n        val = insn_get(env, s, ot);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        if (mod != 3) {\n\n            gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n        } else {\n\n            gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0);\n\n        }\n\n        break;\n\n    case 0x8a:\n\n    case 0x8b: /* mov Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        break;\n\n    case 0x8e: /* mov seg, Gv */\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        if (reg >= 6 || reg == R_CS)\n\n            goto illegal_op;\n\n        gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n        gen_movl_seg_T0(s, reg);\n\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            if (reg == R_SS) {\n\n                s->tf = 0;\n\n                gen_eob_inhibit_irq(s, true);\n\n            } else {\n\n                gen_eob(s);\n\n            }\n\n        }\n\n        break;\n\n    case 0x8c: /* mov Gv, seg */\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (reg >= 6)\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(reg);\n\n        ot = mod == 3 ? dflag : MO_16;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n        break;\n\n\n\n    case 0x1b6: /* movzbS Gv, Eb */\n\n    case 0x1b7: /* movzwS Gv, Eb */\n\n    case 0x1be: /* movsbS Gv, Eb */\n\n    case 0x1bf: /* movswS Gv, Eb */\n\n        {\n\n            TCGMemOp d_ot;\n\n            TCGMemOp s_ot;\n\n\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag;\n\n            /* ot is the size of source */\n\n            ot = (b & 1) + MO_8;\n\n            /* s_ot is the sign+size of source */\n\n            s_ot = b & 8 ? MO_SIGN | ot : ot;\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                if (s_ot == MO_SB && byte_reg_is_xH(rm)) {\n\n                    tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8);\n\n                } else {\n\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                    switch (s_ot) {\n\n                    case MO_UB:\n\n                        tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    case MO_SB:\n\n                        tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    case MO_UW:\n\n                        tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    default:\n\n                    case MO_SW:\n\n                        tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    }\n\n                }\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            } else {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x8d: /* lea */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        {\n\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n            TCGv ea = gen_lea_modrm_1(a);\n\n            gen_lea_v_seg(s, s->aflag, ea, -1, -1);\n\n            gen_op_mov_reg_v(dflag, reg, cpu_A0);\n\n        }\n\n        break;\n\n\n\n    case 0xa0: /* mov EAX, Ov */\n\n    case 0xa1:\n\n    case 0xa2: /* mov Ov, EAX */\n\n    case 0xa3:\n\n        {\n\n            target_ulong offset_addr;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n            switch (s->aflag) {\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                offset_addr = x86_ldq_code(env, s);\n\n                break;\n\n#endif\n\n            default:\n\n                offset_addr = insn_get(env, s, s->aflag);\n\n                break;\n\n            }\n\n            tcg_gen_movi_tl(cpu_A0, offset_addr);\n\n            gen_add_A0_ds_seg(s);\n\n            if ((b & 2) == 0) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(ot, R_EAX, cpu_T0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, cpu_T0, R_EAX);\n\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd7: /* xlat */\n\n        tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]);\n\n        tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]);\n\n        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0);\n\n        gen_extu(s->aflag, cpu_A0);\n\n        gen_add_A0_ds_seg(s);\n\n        gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0);\n\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n\n        break;\n\n    case 0xb0 ... 0xb7: /* mov R, Ib */\n\n        val = insn_get(env, s, MO_8);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0);\n\n        break;\n\n    case 0xb8 ... 0xbf: /* mov R, Iv */\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            uint64_t tmp;\n\n            /* 64 bit case */\n\n            tmp = x86_ldq_code(env, s);\n\n            reg = (b & 7) | REX_B(s);\n\n            tcg_gen_movi_tl(cpu_T0, tmp);\n\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n\n        } else\n\n#endif\n\n        {\n\n            ot = dflag;\n\n            val = insn_get(env, s, ot);\n\n            reg = (b & 7) | REX_B(s);\n\n            tcg_gen_movi_tl(cpu_T0, val);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        }\n\n        break;\n\n\n\n    case 0x91 ... 0x97: /* xchg R, EAX */\n\n    do_xchg_reg_eax:\n\n        ot = dflag;\n\n        reg = (b & 7) | REX_B(s);\n\n        rm = R_EAX;\n\n        goto do_xchg_reg;\n\n    case 0x86:\n\n    case 0x87: /* xchg Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n        do_xchg_reg:\n\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        } else {\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n            /* for xchg, lock is implicit */\n\n            tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0,\n\n                                   s->mem_index, ot | MO_LE);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        }\n\n        break;\n\n    case 0xc4: /* les Gv */\n\n        /* In CODE64 this is VEX3; see above.  */\n\n        op = R_ES;\n\n        goto do_lxx;\n\n    case 0xc5: /* lds Gv */\n\n        /* In CODE64 this is VEX2; see above.  */\n\n        op = R_DS;\n\n        goto do_lxx;\n\n    case 0x1b2: /* lss Gv */\n\n        op = R_SS;\n\n        goto do_lxx;\n\n    case 0x1b4: /* lfs Gv */\n\n        op = R_FS;\n\n        goto do_lxx;\n\n    case 0x1b5: /* lgs Gv */\n\n        op = R_GS;\n\n    do_lxx:\n\n        ot = dflag != MO_16 ? MO_32 : MO_16;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_lea_modrm(env, s, modrm);\n\n        gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n        gen_add_A0_im(s, 1 << ot);\n\n        /* load the segment first to handle exceptions properly */\n\n        gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        gen_movl_seg_T0(s, op);\n\n        /* then put the data */\n\n        gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* shifts */\n\n    case 0xc0:\n\n    case 0xc1:\n\n        /* shift Ev,Ib */\n\n        shift = 2;\n\n    grp2:\n\n        {\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = x86_ldub_code(env, s);\n\n            mod = (modrm >> 6) & 3;\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (shift == 2) {\n\n                    s->rip_offset = 1;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = (modrm & 7) | REX_B(s);\n\n            }\n\n\n\n            /* simpler op */\n\n            if (shift == 0) {\n\n                gen_shift(s, op, ot, opreg, OR_ECX);\n\n            } else {\n\n                if (shift == 2) {\n\n                    shift = x86_ldub_code(env, s);\n\n                }\n\n                gen_shifti(s, op, ot, opreg, shift);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd0:\n\n    case 0xd1:\n\n        /* shift Ev,1 */\n\n        shift = 1;\n\n        goto grp2;\n\n    case 0xd2:\n\n    case 0xd3:\n\n        /* shift Ev,cl */\n\n        shift = 0;\n\n        goto grp2;\n\n\n\n    case 0x1a4: /* shld imm */\n\n        op = 0;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1a5: /* shld cl */\n\n        op = 0;\n\n        shift = 0;\n\n        goto do_shiftd;\n\n    case 0x1ac: /* shrd imm */\n\n        op = 1;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1ad: /* shrd cl */\n\n        op = 1;\n\n        shift = 0;\n\n    do_shiftd:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (mod != 3) {\n\n            gen_lea_modrm(env, s, modrm);\n\n            opreg = OR_TMP0;\n\n        } else {\n\n            opreg = rm;\n\n        }\n\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n\n\n        if (shift) {\n\n            TCGv imm = tcg_const_tl(x86_ldub_code(env, s));\n\n            gen_shiftd_rm_T1(s, ot, opreg, op, imm);\n\n            tcg_temp_free(imm);\n\n        } else {\n\n            gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* floats */\n\n    case 0xd8 ... 0xdf:\n\n        if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {\n\n            /* if CR0.EM or CR0.TS are set, generate an FPU exception */\n\n            /* XXX: what to do if illegal op ? */\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n            break;\n\n        }\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = modrm & 7;\n\n        op = ((b & 7) << 3) | ((modrm >> 3) & 7);\n\n        if (mod != 3) {\n\n            /* memory op */\n\n            gen_lea_modrm(env, s, modrm);\n\n            switch(op) {\n\n            case 0x00 ... 0x07: /* fxxxs */\n\n            case 0x10 ... 0x17: /* fixxxl */\n\n            case 0x20 ... 0x27: /* fxxxl */\n\n            case 0x30 ... 0x37: /* fixxx */\n\n                {\n\n                    int op1;\n\n                    op1 = op & 7;\n\n\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LESW);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n\n\n                    gen_helper_fp_arith_ST0_FT0(op1);\n\n                    if (op1 == 3) {\n\n                        /* fcomp needs pop */\n\n                        gen_helper_fpop(cpu_env);\n\n                    }\n\n                }\n\n                break;\n\n            case 0x08: /* flds */\n\n            case 0x0a: /* fsts */\n\n            case 0x0b: /* fstps */\n\n            case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */\n\n            case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */\n\n            case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */\n\n                switch(op & 7) {\n\n                case 0:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LESW);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n                    break;\n\n                case 1:\n\n                    /* XXX: the corresponding CPUID bit must be tested ! */\n\n                    switch(op >> 4) {\n\n                    case 1:\n\n                        gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUW);\n\n                        break;\n\n                    }\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUW);\n\n                        break;\n\n                    }\n\n                    if ((op & 7) == 3)\n\n                        gen_helper_fpop(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0c: /* fldenv mem */\n\n                gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x0d: /* fldcw mem */\n\n                tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                gen_helper_fldcw(cpu_env, cpu_tmp2_i32);\n\n                break;\n\n            case 0x0e: /* fnstenv mem */\n\n                gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x0f: /* fnstcw mem */\n\n                gen_helper_fnstcw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                break;\n\n            case 0x1d: /* fldt mem */\n\n                gen_helper_fldt_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x1f: /* fstpt mem */\n\n                gen_helper_fstt_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* frstor mem */\n\n                gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x2e: /* fnsave mem */\n\n                gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x2f: /* fnstsw mem */\n\n                gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                break;\n\n            case 0x3c: /* fbld */\n\n                gen_helper_fbld_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x3e: /* fbstp */\n\n                gen_helper_fbst_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3d: /* fildll */\n\n                tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n\n                gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64);\n\n                break;\n\n            case 0x3f: /* fistpll */\n\n                gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env);\n\n                tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        } else {\n\n            /* register float ops */\n\n            opreg = rm;\n\n\n\n            switch(op) {\n\n            case 0x08: /* fld sti */\n\n                gen_helper_fpush(cpu_env);\n\n                gen_helper_fmov_ST0_STN(cpu_env,\n\n                                        tcg_const_i32((opreg + 1) & 7));\n\n                break;\n\n            case 0x09: /* fxchg sti */\n\n            case 0x29: /* fxchg4 sti, undocumented op */\n\n            case 0x39: /* fxchg7 sti, undocumented op */\n\n                gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x0a: /* grp d9/2 */\n\n                switch(rm) {\n\n                case 0: /* fnop */\n\n                    /* check exceptions (FreeBSD FPU probe) */\n\n                    gen_helper_fwait(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x0c: /* grp d9/4 */\n\n                switch(rm) {\n\n                case 0: /* fchs */\n\n                    gen_helper_fchs_ST0(cpu_env);\n\n                    break;\n\n                case 1: /* fabs */\n\n                    gen_helper_fabs_ST0(cpu_env);\n\n                    break;\n\n                case 4: /* ftst */\n\n                    gen_helper_fldz_FT0(cpu_env);\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    break;\n\n                case 5: /* fxam */\n\n                    gen_helper_fxam_ST0(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x0d: /* grp d9/5 */\n\n                {\n\n                    switch(rm) {\n\n                    case 0:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fld1_ST0(cpu_env);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2t_ST0(cpu_env);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2e_ST0(cpu_env);\n\n                        break;\n\n                    case 3:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldpi_ST0(cpu_env);\n\n                        break;\n\n                    case 4:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldlg2_ST0(cpu_env);\n\n                        break;\n\n                    case 5:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldln2_ST0(cpu_env);\n\n                        break;\n\n                    case 6:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldz_ST0(cpu_env);\n\n                        break;\n\n                    default:\n\n                        goto unknown_op;\n\n                    }\n\n                }\n\n                break;\n\n            case 0x0e: /* grp d9/6 */\n\n                switch(rm) {\n\n                case 0: /* f2xm1 */\n\n                    gen_helper_f2xm1(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2x */\n\n                    gen_helper_fyl2x(cpu_env);\n\n                    break;\n\n                case 2: /* fptan */\n\n                    gen_helper_fptan(cpu_env);\n\n                    break;\n\n                case 3: /* fpatan */\n\n                    gen_helper_fpatan(cpu_env);\n\n                    break;\n\n                case 4: /* fxtract */\n\n                    gen_helper_fxtract(cpu_env);\n\n                    break;\n\n                case 5: /* fprem1 */\n\n                    gen_helper_fprem1(cpu_env);\n\n                    break;\n\n                case 6: /* fdecstp */\n\n                    gen_helper_fdecstp(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fincstp */\n\n                    gen_helper_fincstp(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0f: /* grp d9/7 */\n\n                switch(rm) {\n\n                case 0: /* fprem */\n\n                    gen_helper_fprem(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2xp1 */\n\n                    gen_helper_fyl2xp1(cpu_env);\n\n                    break;\n\n                case 2: /* fsqrt */\n\n                    gen_helper_fsqrt(cpu_env);\n\n                    break;\n\n                case 3: /* fsincos */\n\n                    gen_helper_fsincos(cpu_env);\n\n                    break;\n\n                case 5: /* fscale */\n\n                    gen_helper_fscale(cpu_env);\n\n                    break;\n\n                case 4: /* frndint */\n\n                    gen_helper_frndint(cpu_env);\n\n                    break;\n\n                case 6: /* fsin */\n\n                    gen_helper_fsin(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fcos */\n\n                    gen_helper_fcos(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */\n\n            case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */\n\n            case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */\n\n                {\n\n                    int op1;\n\n\n\n                    op1 = op & 7;\n\n                    if (op >= 0x20) {\n\n                        gen_helper_fp_arith_STN_ST0(op1, opreg);\n\n                        if (op >= 0x30)\n\n                            gen_helper_fpop(cpu_env);\n\n                    } else {\n\n                        gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                        gen_helper_fp_arith_ST0_FT0(op1);\n\n                    }\n\n                }\n\n                break;\n\n            case 0x02: /* fcom */\n\n            case 0x22: /* fcom2, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x03: /* fcomp */\n\n            case 0x23: /* fcomp3, undocumented op */\n\n            case 0x32: /* fcomp5, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x15: /* da/5 */\n\n                switch(rm) {\n\n                case 1: /* fucompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fucom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x1c:\n\n                switch(rm) {\n\n                case 0: /* feni (287 only, just do nop here) */\n\n                    break;\n\n                case 1: /* fdisi (287 only, just do nop here) */\n\n                    break;\n\n                case 2: /* fclex */\n\n                    gen_helper_fclex(cpu_env);\n\n                    break;\n\n                case 3: /* fninit */\n\n                    gen_helper_fninit(cpu_env);\n\n                    break;\n\n                case 4: /* fsetpm (287 only, just do nop here) */\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x1d: /* fucomi */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x1e: /* fcomi */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x28: /* ffree sti */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2a: /* fst sti */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2b: /* fstp sti */\n\n            case 0x0b: /* fstp1 sti, undocumented op */\n\n            case 0x3a: /* fstp8 sti, undocumented op */\n\n            case 0x3b: /* fstp9 sti, undocumented op */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* fucom st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x2d: /* fucomp st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x33: /* de/3 */\n\n                switch(rm) {\n\n                case 1: /* fcompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x38: /* ffreep sti, undocumented op */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3c: /* df/4 */\n\n                switch(rm) {\n\n                case 0:\n\n                    gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n\n                    gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x3d: /* fucomip */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x3e: /* fcomip */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x10 ... 0x13: /* fcmovxx */\n\n            case 0x18 ... 0x1b:\n\n                {\n\n                    int op1;\n\n                    TCGLabel *l1;\n\n                    static const uint8_t fcmov_cc[8] = {\n\n                        (JCC_B << 1),\n\n                        (JCC_Z << 1),\n\n                        (JCC_BE << 1),\n\n                        (JCC_P << 1),\n\n                    };\n\n\n\n                    if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);\n\n                    l1 = gen_new_label();\n\n                    gen_jcc1_noeob(s, op1, l1);\n\n                    gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                    gen_set_label(l1);\n\n                }\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        }\n\n        break;\n\n        /************************/\n\n        /* string ops */\n\n\n\n    case 0xa4: /* movsS */\n\n    case 0xa5:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_movs(s, ot);\n\n        }\n\n        break;\n\n\n\n    case 0xaa: /* stosS */\n\n    case 0xab:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_stos(s, ot);\n\n        }\n\n        break;\n\n    case 0xac: /* lodsS */\n\n    case 0xad:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_lods(s, ot);\n\n        }\n\n        break;\n\n    case 0xae: /* scasS */\n\n    case 0xaf:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_scas(s, ot);\n\n        }\n\n        break;\n\n\n\n    case 0xa6: /* cmpsS */\n\n    case 0xa7:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_cmps(s, ot);\n\n        }\n\n        break;\n\n    case 0x6c: /* insS */\n\n    case 0x6d:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base, \n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_ins(s, ot);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0x6e: /* outsS */\n\n    case 0x6f:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_outs(s, ot);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* port I/O */\n\n\n\n    case 0xe4:\n\n    case 0xe5:\n\n        ot = mo_b_d32(b, dflag);\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xe6:\n\n    case 0xe7:\n\n        ot = mo_b_d32(b, dflag);\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xec:\n\n    case 0xed:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xee:\n\n    case 0xef:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* control */\n\n    case 0xc2: /* ret im */\n\n        val = x86_ldsw_code(env, s);\n\n        ot = gen_pop_T0(s);\n\n        gen_stack_update(s, val + (1 << ot));\n\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n\n        gen_op_jmp_v(cpu_T0);\n\n        gen_bnd_jmp(s);\n\n        gen_jr(s, cpu_T0);\n\n        break;\n\n    case 0xc3: /* ret */\n\n        ot = gen_pop_T0(s);\n\n        gen_pop_update(s, ot);\n\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n\n        gen_op_jmp_v(cpu_T0);\n\n        gen_bnd_jmp(s);\n\n        gen_jr(s, cpu_T0);\n\n        break;\n\n    case 0xca: /* lret im */\n\n        val = x86_ldsw_code(env, s);\n\n    do_lret:\n\n        if (s->pe && !s->vm86) {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(val));\n\n        } else {\n\n            gen_stack_A0(s);\n\n            /* pop offset */\n\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n\n            /* NOTE: keeping EIP updated is not a problem in case of\n\n               exception */\n\n            gen_op_jmp_v(cpu_T0);\n\n            /* pop selector */\n\n            gen_add_A0_im(s, 1 << dflag);\n\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n\n            gen_op_movl_seg_T0_vm(R_CS);\n\n            /* add stack offset */\n\n            gen_stack_update(s, val + (2 << dflag));\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xcb: /* lret */\n\n        val = 0;\n\n        goto do_lret;\n\n    case 0xcf: /* iret */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);\n\n        if (!s->pe) {\n\n            /* real mode */\n\n            gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n        } else if (s->vm86) {\n\n            if (s->iopl != 3) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n            }\n\n        } else {\n\n            gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xe8: /* call im */\n\n        {\n\n            if (dflag != MO_16) {\n\n                tval = (int32_t)insn_get(env, s, MO_32);\n\n            } else {\n\n                tval = (int16_t)insn_get(env, s, MO_16);\n\n            }\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (dflag == MO_16) {\n\n                tval &= 0xffff;\n\n            } else if (!CODE64(s)) {\n\n                tval &= 0xffffffff;\n\n            }\n\n            tcg_gen_movi_tl(cpu_T0, next_eip);\n\n            gen_push_v(s, cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jmp(s, tval);\n\n        }\n\n        break;\n\n    case 0x9a: /* lcall im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag;\n\n            offset = insn_get(env, s, ot);\n\n            selector = insn_get(env, s, MO_16);\n\n\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n\n            tcg_gen_movi_tl(cpu_T1, offset);\n\n        }\n\n        goto do_lcall;\n\n    case 0xe9: /* jmp im */\n\n        if (dflag != MO_16) {\n\n            tval = (int32_t)insn_get(env, s, MO_32);\n\n        } else {\n\n            tval = (int16_t)insn_get(env, s, MO_16);\n\n        }\n\n        tval += s->pc - s->cs_base;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        } else if (!CODE64(s)) {\n\n            tval &= 0xffffffff;\n\n        }\n\n        gen_bnd_jmp(s);\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0xea: /* ljmp im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag;\n\n            offset = insn_get(env, s, ot);\n\n            selector = insn_get(env, s, MO_16);\n\n\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n\n            tcg_gen_movi_tl(cpu_T1, offset);\n\n        }\n\n        goto do_ljmp;\n\n    case 0xeb: /* jmp Jb */\n\n        tval = (int8_t)insn_get(env, s, MO_8);\n\n        tval += s->pc - s->cs_base;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        }\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0x70 ... 0x7f: /* jcc Jb */\n\n        tval = (int8_t)insn_get(env, s, MO_8);\n\n        goto do_jcc;\n\n    case 0x180 ... 0x18f: /* jcc Jv */\n\n        if (dflag != MO_16) {\n\n            tval = (int32_t)insn_get(env, s, MO_32);\n\n        } else {\n\n            tval = (int16_t)insn_get(env, s, MO_16);\n\n        }\n\n    do_jcc:\n\n        next_eip = s->pc - s->cs_base;\n\n        tval += next_eip;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        }\n\n        gen_bnd_jmp(s);\n\n        gen_jcc(s, b, tval, next_eip);\n\n        break;\n\n\n\n    case 0x190 ... 0x19f: /* setcc Gv */\n\n        modrm = x86_ldub_code(env, s);\n\n        gen_setcc1(s, b, cpu_T0);\n\n        gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1);\n\n        break;\n\n    case 0x140 ... 0x14f: /* cmov Gv, Ev */\n\n        if (!(s->cpuid_features & CPUID_CMOV)) {\n\n            goto illegal_op;\n\n        }\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_cmovcc1(env, s, ot, b, modrm, reg);\n\n        break;\n\n\n\n        /************************/\n\n        /* flags */\n\n    case 0x9c: /* pushf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_helper_read_eflags(cpu_T0, cpu_env);\n\n            gen_push_v(s, cpu_T0);\n\n        }\n\n        break;\n\n    case 0x9d: /* popf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            ot = gen_pop_T0(s);\n\n            if (s->cpl == 0) {\n\n                if (dflag != MO_16) {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK |\n\n                                                           IOPL_MASK)));\n\n                } else {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK | IOPL_MASK)\n\n                                                          & 0xffff));\n\n                }\n\n            } else {\n\n                if (s->cpl <= s->iopl) {\n\n                    if (dflag != MO_16) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)\n\n                                                              & 0xffff));\n\n                    }\n\n                } else {\n\n                    if (dflag != MO_16) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)\n\n                                                         & 0xffff));\n\n                    }\n\n                }\n\n            }\n\n            gen_pop_update(s, ot);\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            /* abort translation because TF/AC flag may change */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x9e: /* sahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_op_mov_v_reg(MO_8, cpu_T0, R_AH);\n\n        gen_compute_eflags(s);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);\n\n        tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0);\n\n        break;\n\n    case 0x9f: /* lahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_compute_eflags(s);\n\n        /* Note: gen_compute_eflags() only gives the condition codes */\n\n        tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02);\n\n        gen_op_mov_reg_v(MO_8, R_AH, cpu_T0);\n\n        break;\n\n    case 0xf5: /* cmc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        break;\n\n    case 0xf8: /* clc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);\n\n        break;\n\n    case 0xf9: /* stc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        break;\n\n    case 0xfc: /* cld */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, 1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n    case 0xfd: /* std */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, -1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n\n\n        /************************/\n\n        /* bit operations */\n\n    case 0x1ba: /* bt/bts/btr/btc Gv, im */\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        op = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        if (mod != 3) {\n\n            s->rip_offset = 1;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (!(s->prefix & PREFIX_LOCK)) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n        /* load shift */\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T1, val);\n\n        if (op < 4)\n\n            goto unknown_op;\n\n        op -= 4;\n\n        goto bt_op;\n\n    case 0x1a3: /* bt Gv, Ev */\n\n        op = 0;\n\n        goto do_btx;\n\n    case 0x1ab: /* bts */\n\n        op = 1;\n\n        goto do_btx;\n\n    case 0x1b3: /* btr */\n\n        op = 2;\n\n        goto do_btx;\n\n    case 0x1bb: /* btc */\n\n        op = 3;\n\n    do_btx:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        gen_op_mov_v_reg(MO_32, cpu_T1, reg);\n\n        if (mod != 3) {\n\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n            /* specific case: we need to add a displacement */\n\n            gen_exts(ot, cpu_T1);\n\n            tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot);\n\n            tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);\n\n            tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0);\n\n            gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n            if (!(s->prefix & PREFIX_LOCK)) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n    bt_op:\n\n        tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1);\n\n        tcg_gen_movi_tl(cpu_tmp0, 1);\n\n        tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1);\n\n        if (s->prefix & PREFIX_LOCK) {\n\n            switch (op) {\n\n            case 0: /* bt */\n\n                /* Needs no atomic ops; we surpressed the normal\n\n                   memory load for LOCK above so do it now.  */\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n                break;\n\n            case 1: /* bts */\n\n                tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                           s->mem_index, ot | MO_LE);\n\n                break;\n\n            case 2: /* btr */\n\n                tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);\n\n                tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                break;\n\n            default:\n\n            case 3: /* btc */\n\n                tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                break;\n\n            }\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n\n        } else {\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n\n            switch (op) {\n\n            case 0: /* bt */\n\n                /* Data already loaded; nothing to do.  */\n\n                break;\n\n            case 1: /* bts */\n\n                tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            case 2: /* btr */\n\n                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            default:\n\n            case 3: /* btc */\n\n                tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            }\n\n            if (op != 0) {\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* Delay all CC updates until after the store above.  Note that\n\n           C is the result of the test, Z is unchanged, and the others\n\n           are all undefined.  */\n\n        switch (s->cc_op) {\n\n        case CC_OP_MULB ... CC_OP_MULQ:\n\n        case CC_OP_ADDB ... CC_OP_ADDQ:\n\n        case CC_OP_ADCB ... CC_OP_ADCQ:\n\n        case CC_OP_SUBB ... CC_OP_SUBQ:\n\n        case CC_OP_SBBB ... CC_OP_SBBQ:\n\n        case CC_OP_LOGICB ... CC_OP_LOGICQ:\n\n        case CC_OP_INCB ... CC_OP_INCQ:\n\n        case CC_OP_DECB ... CC_OP_DECQ:\n\n        case CC_OP_SHLB ... CC_OP_SHLQ:\n\n        case CC_OP_SARB ... CC_OP_SARQ:\n\n        case CC_OP_BMILGB ... CC_OP_BMILGQ:\n\n            /* Z was going to be computed from the non-zero status of CC_DST.\n\n               We can get that same Z value (and the new C value) by leaving\n\n               CC_DST alone, setting CC_SRC, and using a CC_OP_SAR of the\n\n               same width.  */\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);\n\n            set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB);\n\n            break;\n\n        default:\n\n            /* Otherwise, generate EFLAGS and replace the C bit.  */\n\n            gen_compute_eflags(s);\n\n            tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4,\n\n                               ctz32(CC_C), 1);\n\n            break;\n\n        }\n\n        break;\n\n    case 0x1bc: /* bsf / tzcnt */\n\n    case 0x1bd: /* bsr / lzcnt */\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_extu(ot, cpu_T0);\n\n\n\n        /* Note that lzcnt and tzcnt are in different extensions.  */\n\n        if ((prefixes & PREFIX_REPZ)\n\n            && (b & 1\n\n                ? s->cpuid_ext3_features & CPUID_EXT3_ABM\n\n                : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) {\n\n            int size = 8 << ot;\n\n            /* For lzcnt/tzcnt, C bit is defined related to the input. */\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n            if (b & 1) {\n\n                /* For lzcnt, reduce the target_ulong result by the\n\n                   number of zeros that we expect to find at the top.  */\n\n                tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS);\n\n                tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size);\n\n            } else {\n\n                /* For tzcnt, a zero input must return the operand size.  */\n\n                tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size);\n\n            }\n\n            /* For lzcnt/tzcnt, Z bit is defined related to the result.  */\n\n            gen_op_update1_cc();\n\n            set_cc_op(s, CC_OP_BMILGB + ot);\n\n        } else {\n\n            /* For bsr/bsf, only the Z bit is defined and it is related\n\n               to the input and not the result.  */\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n\n\n            /* ??? The manual says that the output is undefined when the\n\n               input is zero, but real hardware leaves it unchanged, and\n\n               real programs appear to depend on that.  Accomplish this\n\n               by passing the output as the value to return upon zero.  */\n\n            if (b & 1) {\n\n                /* For bsr, return the bit index of the first 1 bit,\n\n                   not the count of leading zeros.  */\n\n                tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1);\n\n                tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1);\n\n            } else {\n\n                tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]);\n\n            }\n\n        }\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        break;\n\n        /************************/\n\n        /* bcd */\n\n    case 0x27: /* daa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_daa(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x2f: /* das */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_das(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x37: /* aaa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_aaa(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x3f: /* aas */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_aas(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0xd4: /* aam */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = x86_ldub_code(env, s);\n\n        if (val == 0) {\n\n            gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_aam(cpu_env, tcg_const_i32(val));\n\n            set_cc_op(s, CC_OP_LOGICB);\n\n        }\n\n        break;\n\n    case 0xd5: /* aad */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = x86_ldub_code(env, s);\n\n        gen_helper_aad(cpu_env, tcg_const_i32(val));\n\n        set_cc_op(s, CC_OP_LOGICB);\n\n        break;\n\n        /************************/\n\n        /* misc */\n\n    case 0x90: /* nop */\n\n        /* XXX: correct lock test for all insn */\n\n        if (prefixes & PREFIX_LOCK) {\n\n            goto illegal_op;\n\n        }\n\n        /* If REX_B is set, then this is xchg eax, r8d, not a nop.  */\n\n        if (REX_B(s)) {\n\n            goto do_xchg_reg_eax;\n\n        }\n\n        if (prefixes & PREFIX_REPZ) {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n        }\n\n        break;\n\n    case 0x9b: /* fwait */\n\n        if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==\n\n            (HF_MP_MASK | HF_TS_MASK)) {\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_fwait(cpu_env);\n\n        }\n\n        break;\n\n    case 0xcc: /* int3 */\n\n        gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        break;\n\n    case 0xcd: /* int N */\n\n        val = x86_ldub_code(env, s);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xce: /* into */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        break;\n\n#ifdef WANT_ICEBP\n\n    case 0xf1: /* icebp (undocumented, exits to external debugger) */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);\n\n#if 1\n\n        gen_debug(s, pc_start - s->cs_base);\n\n#else\n\n        /* start debug */\n\n        tb_flush(CPU(x86_env_get_cpu(env)));\n\n        qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);\n\n#endif\n\n        break;\n\n#endif\n\n    case 0xfa: /* cli */\n\n        if (!s->vm86) {\n\n            if (s->cpl <= s->iopl) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        } else {\n\n            if (s->iopl == 3) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0xfb: /* sti */\n\n        if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) {\n\n            gen_helper_sti(cpu_env);\n\n            /* interruptions are enabled only the first insn after sti */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob_inhibit_irq(s, true);\n\n        } else {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        }\n\n        break;\n\n    case 0x62: /* bound */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n        gen_lea_modrm(env, s, modrm);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        if (ot == MO_16) {\n\n            gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n        } else {\n\n            gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n        }\n\n        break;\n\n    case 0x1c8 ... 0x1cf: /* bswap reg */\n\n        reg = (b & 7) | REX_B(s);\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            gen_op_mov_v_reg(MO_64, cpu_T0, reg);\n\n            tcg_gen_bswap64_i64(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n\n        } else\n\n#endif\n\n        {\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, reg);\n\n            tcg_gen_ext32u_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_bswap32_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_32, reg, cpu_T0);\n\n        }\n\n        break;\n\n    case 0xd6: /* salc */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_compute_eflags_c(s, cpu_T0);\n\n        tcg_gen_neg_tl(cpu_T0, cpu_T0);\n\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n\n        break;\n\n    case 0xe0: /* loopnz */\n\n    case 0xe1: /* loopz */\n\n    case 0xe2: /* loop */\n\n    case 0xe3: /* jecxz */\n\n        {\n\n            TCGLabel *l1, *l2, *l3;\n\n\n\n            tval = (int8_t)insn_get(env, s, MO_8);\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (dflag == MO_16) {\n\n                tval &= 0xffff;\n\n            }\n\n\n\n            l1 = gen_new_label();\n\n            l2 = gen_new_label();\n\n            l3 = gen_new_label();\n\n            b &= 3;\n\n            switch(b) {\n\n            case 0: /* loopnz */\n\n            case 1: /* loopz */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jz_ecx(s->aflag, l3);\n\n                gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1);\n\n                break;\n\n            case 2: /* loop */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jnz_ecx(s->aflag, l1);\n\n                break;\n\n            default:\n\n            case 3: /* jcxz */\n\n                gen_op_jz_ecx(s->aflag, l1);\n\n                break;\n\n            }\n\n\n\n            gen_set_label(l3);\n\n            gen_jmp_im(next_eip);\n\n            tcg_gen_br(l2);\n\n\n\n            gen_set_label(l1);\n\n            gen_jmp_im(tval);\n\n            gen_set_label(l2);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x130: /* wrmsr */\n\n    case 0x132: /* rdmsr */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (b & 2) {\n\n                gen_helper_rdmsr(cpu_env);\n\n            } else {\n\n                gen_helper_wrmsr(cpu_env);\n\n            }\n\n        }\n\n        break;\n\n    case 0x131: /* rdtsc */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        gen_helper_rdtsc(cpu_env);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0x133: /* rdpmc */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_rdpmc(cpu_env);\n\n        break;\n\n    case 0x134: /* sysenter */\n\n        /* For Intel SYSENTER is valid on 64-bit */\n\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysenter(cpu_env);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x135: /* sysexit */\n\n        /* For Intel SYSEXIT is valid on 64-bit */\n\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1));\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n#ifdef TARGET_X86_64\n\n    case 0x105: /* syscall */\n\n        /* XXX: is it usable in real mode ? */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        /* TF handling for the syscall insn is different. The TF bit is  checked\n\n           after the syscall insn completes. This allows #DB to not be\n\n           generated after one has entered CPL0 if TF is set in FMASK.  */\n\n        gen_eob_worker(s, false, true);\n\n        break;\n\n    case 0x107: /* sysret */\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1));\n\n            /* condition codes are modified only in long mode */\n\n            if (s->lma) {\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n            }\n\n            /* TF handling for the sysret insn is different. The TF bit is\n\n               checked after the sysret insn completes. This allows #DB to be\n\n               generated \"as if\" the syscall insn in userspace has just\n\n               completed.  */\n\n            gen_eob_worker(s, false, true);\n\n        }\n\n        break;\n\n#endif\n\n    case 0x1a2: /* cpuid */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_cpuid(cpu_env);\n\n        break;\n\n    case 0xf4: /* hlt */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n        }\n\n        break;\n\n    case 0x100:\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* sldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n\n                             offsetof(CPUX86State, ldt.selector));\n\n            ot = mod == 3 ? dflag : MO_16;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 2: /* lldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);\n\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lldt(cpu_env, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 1: /* str */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n\n                             offsetof(CPUX86State, tr.selector));\n\n            ot = mod == 3 ? dflag : MO_16;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 3: /* ltr */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);\n\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_ltr(cpu_env, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 4: /* verr */\n\n        case 5: /* verw */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            gen_update_cc_op(s);\n\n            if (op == 4) {\n\n                gen_helper_verr(cpu_env, cpu_T0);\n\n            } else {\n\n                gen_helper_verw(cpu_env, cpu_T0);\n\n            }\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x101:\n\n        modrm = x86_ldub_code(env, s);\n\n        switch (modrm) {\n\n        CASE_MODRM_MEM_OP(0): /* sgdt */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0,\n\n                             cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        case 0xc8: /* monitor */\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]);\n\n            gen_extu(s->aflag, cpu_A0);\n\n            gen_add_A0_ds_seg(s);\n\n            gen_helper_monitor(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        case 0xc9: /* mwait */\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xca: /* clac */\n\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n\n                || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_helper_clac(cpu_env);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xcb: /* stac */\n\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n\n                || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_helper_stac(cpu_env);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(1): /* sidt */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit));\n\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        case 0xd0: /* xgetbv */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n\n            break;\n\n\n\n        case 0xd1: /* xsetbv */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n\n            /* End TB because translation flags may change.  */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xd8: /* VMRUN */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1),\n\n                             tcg_const_i32(s->pc - pc_start));\n\n            tcg_gen_exit_tb(0);\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n            break;\n\n\n\n        case 0xd9: /* VMMCALL */\n\n            if (!(s->flags & HF_SVME_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmmcall(cpu_env);\n\n            break;\n\n\n\n        case 0xda: /* VMLOAD */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        case 0xdb: /* VMSAVE */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        case 0xdc: /* STGI */\n\n            if ((!(s->flags & HF_SVME_MASK)\n\n                   && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n\n                || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_stgi(cpu_env);\n\n            break;\n\n\n\n        case 0xdd: /* CLGI */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_clgi(cpu_env);\n\n            break;\n\n\n\n        case 0xde: /* SKINIT */\n\n            if ((!(s->flags & HF_SVME_MASK)\n\n                 && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n\n                || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_skinit(cpu_env);\n\n            break;\n\n\n\n        case 0xdf: /* INVLPGA */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(2): /* lgdt */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(3): /* lidt */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit));\n\n            break;\n\n\n\n        CASE_MODRM_OP(4): /* smsw */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0]));\n\n            if (CODE64(s)) {\n\n                mod = (modrm >> 6) & 3;\n\n                ot = (mod != 3 ? MO_16 : s->dflag);\n\n            } else {\n\n                ot = MO_16;\n\n            }\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 0xee: /* rdpkru */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n\n            break;\n\n        case 0xef: /* wrpkru */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n\n            break;\n\n        CASE_MODRM_OP(6): /* lmsw */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            gen_helper_lmsw(cpu_env, cpu_T0);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(7): /* invlpg */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_invlpg(cpu_env, cpu_A0);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xf8: /* swapgs */\n\n#ifdef TARGET_X86_64\n\n            if (CODE64(s)) {\n\n                if (s->cpl != 0) {\n\n                    gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                } else {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]);\n\n                    tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env,\n\n                                  offsetof(CPUX86State, kernelgsbase));\n\n                    tcg_gen_st_tl(cpu_T0, cpu_env,\n\n                                  offsetof(CPUX86State, kernelgsbase));\n\n                }\n\n                break;\n\n            }\n\n#endif\n\n            goto illegal_op;\n\n\n\n        case 0xf9: /* rdtscp */\n\n            if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_start();\n\n            }\n\n            gen_helper_rdtscp(cpu_env);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_end();\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x108: /* invd */\n\n    case 0x109: /* wbinvd */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);\n\n            /* nothing to do */\n\n        }\n\n        break;\n\n    case 0x63: /* arpl or movslS (x86_64) */\n\n#ifdef TARGET_X86_64\n\n        if (CODE64(s)) {\n\n            int d_ot;\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag;\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                gen_op_mov_v_reg(MO_32, cpu_T0, rm);\n\n                /* sign extend */\n\n                if (d_ot == MO_64) {\n\n                    tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n                }\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            } else {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            }\n\n        } else\n\n#endif\n\n        {\n\n            TCGLabel *label1;\n\n            TCGv t0, t1, t2, a0;\n\n\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            t0 = tcg_temp_local_new();\n\n            t1 = tcg_temp_local_new();\n\n            t2 = tcg_temp_local_new();\n\n            ot = MO_16;\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = (modrm >> 3) & 7;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = modrm & 7;\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, ot, t0, cpu_A0);\n\n                a0 = tcg_temp_local_new();\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, t0, rm);\n\n                TCGV_UNUSED(a0);\n\n            }\n\n            gen_op_mov_v_reg(ot, t1, reg);\n\n            tcg_gen_andi_tl(cpu_tmp0, t0, 3);\n\n            tcg_gen_andi_tl(t1, t1, 3);\n\n            tcg_gen_movi_tl(t2, 0);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);\n\n            tcg_gen_andi_tl(t0, t0, ~3);\n\n            tcg_gen_or_tl(t0, t0, t1);\n\n            tcg_gen_movi_tl(t2, CC_Z);\n\n            gen_set_label(label1);\n\n            if (mod != 3) {\n\n                gen_op_st_v(s, ot, t0, a0);\n\n                tcg_temp_free(a0);\n\n           } else {\n\n                gen_op_mov_reg_v(ot, rm, t0);\n\n            }\n\n            gen_compute_eflags(s);\n\n            tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);\n\n            tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);\n\n            tcg_temp_free(t0);\n\n            tcg_temp_free(t1);\n\n            tcg_temp_free(t2);\n\n        }\n\n        break;\n\n    case 0x102: /* lar */\n\n    case 0x103: /* lsl */\n\n        {\n\n            TCGLabel *label1;\n\n            TCGv t0;\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            ot = dflag != MO_16 ? MO_32 : MO_16;\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            t0 = tcg_temp_local_new();\n\n            gen_update_cc_op(s);\n\n            if (b == 0x102) {\n\n                gen_helper_lar(t0, cpu_env, cpu_T0);\n\n            } else {\n\n                gen_helper_lsl(t0, cpu_env, cpu_T0);\n\n            }\n\n            tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);\n\n            gen_op_mov_reg_v(ot, reg, t0);\n\n            gen_set_label(label1);\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            tcg_temp_free(t0);\n\n        }\n\n        break;\n\n    case 0x118:\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* prefetchnta */\n\n        case 1: /* prefetchnt0 */\n\n        case 2: /* prefetchnt0 */\n\n        case 3: /* prefetchnt0 */\n\n            if (mod == 3)\n\n                goto illegal_op;\n\n            gen_nop_modrm(env, s, modrm);\n\n            /* nothing more to do */\n\n            break;\n\n        default: /* nop (multi byte) */\n\n            gen_nop_modrm(env, s, modrm);\n\n            break;\n\n        }\n\n        break;\n\n    case 0x11a:\n\n        modrm = x86_ldub_code(env, s);\n\n        if (s->flags & HF_MPX_EN_MASK) {\n\n            mod = (modrm >> 6) & 3;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (prefixes & PREFIX_REPZ) {\n\n                /* bndcl */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]);\n\n            } else if (prefixes & PREFIX_REPNZ) {\n\n                /* bndcu */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                TCGv_i64 notu = tcg_temp_new_i64();\n\n                tcg_gen_not_i64(notu, cpu_bndu[reg]);\n\n                gen_bndck(env, s, modrm, TCG_COND_GTU, notu);\n\n                tcg_temp_free_i64(notu);\n\n            } else if (prefixes & PREFIX_DATA) {\n\n                /* bndmov -- from reg/mem */\n\n                if (reg >= 4 || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                if (mod == 3) {\n\n                    int reg2 = (modrm & 7) | REX_B(s);\n\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    if (s->flags & HF_MPX_IU_MASK) {\n\n                        tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]);\n\n                        tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]);\n\n                    }\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    if (CODE64(s)) {\n\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                    } else {\n\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                    }\n\n                    /* bnd registers are now in-use */\n\n                    gen_set_hflag(s, HF_MPX_IU_MASK);\n\n                }\n\n            } else if (mod != 3) {\n\n                /* bndldx */\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16\n\n                    || a.base < -1) {\n\n                    goto illegal_op;\n\n                }\n\n                if (a.base >= 0) {\n\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_A0, 0);\n\n                }\n\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n                if (a.index >= 0) {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                }\n\n                if (CODE64(s)) {\n\n                    gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0);\n\n                    tcg_gen_ld_i64(cpu_bndu[reg], cpu_env,\n\n                                   offsetof(CPUX86State, mmx_t0.MMX_Q(0)));\n\n                } else {\n\n                    gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0);\n\n                    tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]);\n\n                    tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32);\n\n                }\n\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n\n            }\n\n        }\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x11b:\n\n        modrm = x86_ldub_code(env, s);\n\n        if (s->flags & HF_MPX_EN_MASK) {\n\n            mod = (modrm >> 6) & 3;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (mod != 3 && (prefixes & PREFIX_REPZ)) {\n\n                /* bndmk */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (a.base >= 0) {\n\n                    tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]);\n\n                    if (!CODE64(s)) {\n\n                        tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]);\n\n                    }\n\n                } else if (a.base == -1) {\n\n                    /* no base register has lower bound of 0 */\n\n                    tcg_gen_movi_i64(cpu_bndl[reg], 0);\n\n                } else {\n\n                    /* rip-relative generates #ud */\n\n                    goto illegal_op;\n\n                }\n\n                tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a));\n\n                if (!CODE64(s)) {\n\n                    tcg_gen_ext32u_tl(cpu_A0, cpu_A0);\n\n                }\n\n                tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0);\n\n                /* bnd registers are now in-use */\n\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n\n                break;\n\n            } else if (prefixes & PREFIX_REPNZ) {\n\n                /* bndcn */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]);\n\n            } else if (prefixes & PREFIX_DATA) {\n\n                /* bndmov -- to reg/mem */\n\n                if (reg >= 4 || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                if (mod == 3) {\n\n                    int reg2 = (modrm & 7) | REX_B(s);\n\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    if (s->flags & HF_MPX_IU_MASK) {\n\n                        tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]);\n\n                        tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]);\n\n                    }\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    if (CODE64(s)) {\n\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                    } else {\n\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                    }\n\n                }\n\n            } else if (mod != 3) {\n\n                /* bndstx */\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16\n\n                    || a.base < -1) {\n\n                    goto illegal_op;\n\n                }\n\n                if (a.base >= 0) {\n\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_A0, 0);\n\n                }\n\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n                if (a.index >= 0) {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                }\n\n                if (CODE64(s)) {\n\n                    gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0,\n\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n\n                } else {\n\n                    gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0,\n\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n\n                }\n\n            }\n\n        }\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x119: case 0x11c ... 0x11f: /* nop (multi byte) */\n\n        modrm = x86_ldub_code(env, s);\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x120: /* mov reg, crN */\n\n    case 0x122: /* mov crN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = x86_ldub_code(env, s);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = MO_64;\n\n            else\n\n                ot = MO_32;\n\n            if ((prefixes & PREFIX_LOCK) && (reg == 0) &&\n\n                (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) {\n\n                reg = 8;\n\n            }\n\n            switch(reg) {\n\n            case 0:\n\n            case 2:\n\n            case 3:\n\n            case 4:\n\n            case 8:\n\n                gen_update_cc_op(s);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                if (b & 2) {\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_start();\n\n                    }\n\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                    gen_helper_write_crN(cpu_env, tcg_const_i32(reg),\n\n                                         cpu_T0);\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_end();\n\n                    }\n\n                    gen_jmp_im(s->pc - s->cs_base);\n\n                    gen_eob(s);\n\n                } else {\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_start();\n\n                    }\n\n                    gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg));\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_end();\n\n                    }\n\n                }\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        }\n\n        break;\n\n    case 0x121: /* mov reg, drN */\n\n    case 0x123: /* mov drN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = x86_ldub_code(env, s);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = MO_64;\n\n            else\n\n                ot = MO_32;\n\n            if (reg >= 8) {\n\n                goto illegal_op;\n\n            }\n\n            if (b & 2) {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);\n\n                gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n\n                gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0);\n\n                gen_jmp_im(s->pc - s->cs_base);\n\n                gen_eob(s);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n\n                gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32);\n\n                gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n            }\n\n        }\n\n        break;\n\n    case 0x106: /* clts */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_helper_clts(cpu_env);\n\n            /* abort block because static cpu state changed */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */\n\n    case 0x1c3: /* MOVNTI reg, mem */\n\n        if (!(s->cpuid_features & CPUID_SSE2))\n\n            goto illegal_op;\n\n        ot = mo_64_32(dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0x1ae:\n\n        modrm = x86_ldub_code(env, s);\n\n        switch (modrm) {\n\n        CASE_MODRM_MEM_OP(0): /* fxsave */\n\n            if (!(s->cpuid_features & CPUID_FXSR)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_fxsave(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(1): /* fxrstor */\n\n            if (!(s->cpuid_features & CPUID_FXSR)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_fxrstor(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(2): /* ldmxcsr */\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL);\n\n            gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(3): /* stmxcsr */\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr));\n\n            gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(4): /* xsave */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(5): /* xrstor */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            /* XRSTOR is how MPX is enabled, which changes how\n\n               we translate.  Thus we need to end the TB.  */\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(6): /* xsaveopt / clwb */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* clwb */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_nop_modrm(env, s, modrm);\n\n            } else {\n\n                /* xsaveopt */\n\n                if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                    || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0\n\n                    || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                      cpu_regs[R_EDX]);\n\n                gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            }\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(7): /* clflush / clflushopt */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* clflushopt */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) {\n\n                    goto illegal_op;\n\n                }\n\n            } else {\n\n                /* clflush */\n\n                if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ))\n\n                    || !(s->cpuid_features & CPUID_CLFLUSH)) {\n\n                    goto illegal_op;\n\n                }\n\n            }\n\n            gen_nop_modrm(env, s, modrm);\n\n            break;\n\n\n\n        case 0xc0 ... 0xc7: /* rdfsbase (f3 0f ae /0) */\n\n        case 0xc8 ... 0xcf: /* rdgsbase (f3 0f ae /1) */\n\n        case 0xd0 ... 0xd7: /* wrfsbase (f3 0f ae /2) */\n\n        case 0xd8 ... 0xdf: /* wrgsbase (f3 0f ae /3) */\n\n            if (CODE64(s)\n\n                && (prefixes & PREFIX_REPZ)\n\n                && !(prefixes & PREFIX_LOCK)\n\n                && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) {\n\n                TCGv base, treg, src, dst;\n\n\n\n                /* Preserve hflags bits by testing CR4 at runtime.  */\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK);\n\n                gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32);\n\n\n\n                base = cpu_seg_base[modrm & 8 ? R_GS : R_FS];\n\n                treg = cpu_regs[(modrm & 7) | REX_B(s)];\n\n\n\n                if (modrm & 0x10) {\n\n                    /* wr*base */\n\n                    dst = base, src = treg;\n\n                } else {\n\n                    /* rd*base */\n\n                    dst = treg, src = base;\n\n                }\n\n\n\n                if (s->dflag == MO_32) {\n\n                    tcg_gen_ext32u_tl(dst, src);\n\n                } else {\n\n                    tcg_gen_mov_tl(dst, src);\n\n                }\n\n                break;\n\n            }\n\n            goto unknown_op;\n\n\n\n        case 0xf8: /* sfence / pcommit */\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* pcommit */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT)\n\n                    || (prefixes & PREFIX_LOCK)) {\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            }\n\n            /* fallthru */\n\n        case 0xf9 ... 0xff: /* sfence */\n\n            if (!(s->cpuid_features & CPUID_SSE)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC);\n\n            break;\n\n        case 0xe8 ... 0xef: /* lfence */\n\n            if (!(s->cpuid_features & CPUID_SSE)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC);\n\n            break;\n\n        case 0xf0 ... 0xf7: /* mfence */\n\n            if (!(s->cpuid_features & CPUID_SSE2)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC);\n\n            break;\n\n\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x10d: /* 3DNow! prefetch(w) */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x1aa: /* rsm */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);\n\n        if (!(s->flags & HF_SMM_MASK))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(s->pc - s->cs_base);\n\n        gen_helper_rsm(cpu_env);\n\n        gen_eob(s);\n\n        break;\n\n    case 0x1b8: /* SSE4.2 popcnt */\n\n        if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=\n\n             PREFIX_REPZ)\n\n            goto illegal_op;\n\n        if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))\n\n            goto illegal_op;\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        if (s->prefix & PREFIX_DATA) {\n\n            ot = MO_16;\n\n        } else {\n\n            ot = mo_64_32(dflag);\n\n        }\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_extu(ot, cpu_T0);\n\n        tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n        tcg_gen_ctpop_tl(cpu_T0, cpu_T0);\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n\n\n        set_cc_op(s, CC_OP_POPCNT);\n\n        break;\n\n    case 0x10e ... 0x10f:\n\n        /* 3DNow! instructions, ignore prefixes */\n\n        s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);\n\n    case 0x110 ... 0x117:\n\n    case 0x128 ... 0x12f:\n\n    case 0x138 ... 0x13a:\n\n    case 0x150 ... 0x179:\n\n    case 0x17c ... 0x17f:\n\n    case 0x1c2:\n\n    case 0x1c4 ... 0x1c6:\n\n    case 0x1d0 ... 0x1fe:\n\n        gen_sse(env, s, b, pc_start, rex_r);\n\n        break;\n\n    default:\n\n        goto unknown_op;\n\n    }\n\n    return s->pc;\n\n illegal_op:\n\n    gen_illegal_opcode(s);\n\n    return s->pc;\n\n unknown_op:\n\n    gen_unknown_opcode(env, s);\n\n    return s->pc;\n\n}\n", "idx": 569, "substitutes": {"s": ["i", "series", "conf", "d", "ions", "sci", "v", "states", "ps", "secondary", "sb", "sym", "proc", "strings", "os", "space", "js", "si", "is", "qs", "o", "p", "ys", "ins", "se", "ses", "site", "scope", "args", "features", "sg", "u", "utils", "serv", "ops", "sup", "plugins", "sync", "S", "r", "sc", "settings", "hs", "cs", "ctx", "ssl", "core", "als", "ips", "m", "sq", "session", "status", "full", "service", "g", "us", "server", "spec", "ks", "es", "gs", "options", "t", "native", "ss", "e", "ls", "ds", "xs", "fs", "socket", "su", "sets", "ts", "ns", "n", "linux", "ings", "services", "a", "sys", "sie", "sf", "c", "rs", "in", "self", "vs", "storage", "its", "client"], "cpu": ["cache", "fs", "socket", "sc", "cpp", "cmp", "cs", "ctx", "SCP", "intel", "linux", "ssl", "core", "fp", "p", "mem", "gc", "node", "config", "gp", "vm", "cp", "gpu", "sys", "conn", "roc", "bench", "c", "sb", "pool", "nc", "pu", "proc", "CPU", "net", "processor", "lc"], "env": ["cache", "settings", "context", "enc", "ctx", "si", "conf", "ssl", "eu", "ec", "eni", "viron", "config", "session", "queue", "buf", "ens", "engine", "esm", "loader", "conn", "exe", "console", "txt", "ea", "server", "c", "iss", "scope", "np", "info", "exc", "args", "proc", "e", "environment", "sl", "ev", "en"], "b": ["be", "rb", "i", "r", "l", "xb", "pb", "bb", "binary", "n", "orb", "p", "ib", "B", "ab", "bg", "byte", "d", "bs", "buffer", "w", "buf", "ba", "fb", "mb", "v", "a", "nb", "bar", "eb", "abb", "batch", "c", "sb", "reb", "ob", "cb", "wb", "e", "emb", "bis", "x", "lb", "h", "bu"], "prefixes": ["spreaderves", "fixes", "fixesures", "indexs", "prefixends", "Prefes", "terminerves", " prefixing", " prefixals", "refs", "prefixures", "fixe", "termines", "refions", "prefixipes", "prefixuses", "prefixerves", "prefixe", "indexes", "refes", "spreads", "responss", "spreadends", "periode", "terminuses", "mixes", " prefixeds", "prefixlines", "mixals", " prefixets", "responsals", "fixlines", "indexions", "termins", "periodlines", "fixeses", "prefixals", "indexerves", " prefixuses", "fixesipes", " prefixs", " prefixlines", " prefixe", "prefixions", "mixets", "indexeds", "periods", "fixeserves", " prefixipes", "indexures", " prefixends", " prefixerves", "prefixs", " prefixions", "Prefing", "refeds", " prefixures", "mixs", "prefixeds", "spreades", "Prefipes", "fixs", "indexe", "Prefs", "prefixing", "prefixets", "responsets", "fixess", "fixesing", "periodes", "fixese", "responses", "fixesuses", "indexends"], "shift": ["rep", "scale", "loc", "cmp", "sup", "Shift", "ff", "pop", "off", "rec", "pos", "row", "hift", "comp", "roll", "pack", "push", "align", "ip", "size", "ctr", "pull", "ffff", "seq", "br"], "ot": ["i", "ac", "o", "lib", "ots", "opt", "p", "or", " alloc", "ec", "ol", "stat", "no", "Len", "g", "Opt", "oll", "ian", "OT", "rot", "oc", "ogo", "t", "os", "O", "ow", "out", "ops", "ort"], "aflag": [" aflow", " aflace", "alfrag", "alflag", "alflace", "avlow", "avlace", "alflow", "aflow", " afrag", "aflace", "afrag", "avlag", "avrag"], "dflag": [" dfree", "fFLAG", "dflags", "dFLAG", "fflag", " dflags", " dFLAG", "dtfree", "ffree", "dfree", "dtflag", "fflags", "dtflags", "dtFLAG"], "modrm": [" modlr", "MODrm", "modlr", "regnm", "regrm", "regbm", "modbm", "MODnm", "reglr", " modbm", " modnm", "modnm", "MODlr", "MODbm"], "reg": ["rep", "dist", "res", "gr", "req", "loc", "comm", "ram", "rx", "debug", "exec", "mem", "Reg", "ro", "rar", "rest", "rec", "eg", "map", "asm", "ru", "rel", "REG", "re", "rem"], "rm": ["rr", "rt", "pm", "rx", "ref", "mem", "dm", "dr", "m", "rom", "rf", "mr", "rar", "mode", "repl", "rd", "rpm", "arm", "rn", "rot", "rob", "lr", "addr", "rem", "bm", "cm"], "mod": ["rep", "mult", "im", "mac", "req", "sub", "grad", "lib", "mem", "pin", "module", "m", "pop", "access", "mode", "mods", "add", "fun", "perm", "comp", "roll", "MOD", "rot", "max", "ver"], "op": ["rep", "mp", "hop", "cmp", "option", "o", "opt", "p", "up", "pin", "pop", "mode", "cp", "prop", "ap", "pool", "comp", "pre", "prev", "omp", "rot", "oc", "ip", "oper", "ops", "cop"], "opreg": ["copstat", "copmod", "oprem", " oprem", "optstat", "opstat", "coprem", "optmod", "opmod", "optreg", "copreg", " opmod", " opstat", "optrem"], "val": ["eval", "value", "loc", "grad", "alt", "lib", "valid", "exec", "ref", "mem", "split", "ret", "len", "v", "pos", "slot", "fun", "vals", "rot", "rel", "al", "sl", "seq", "index"], "next_eip": ["next_iIP", "next_peip", "next_eips", "next_eib", "next_peIP", "next_iip", "next_iib", "next_eIP", "next_peips", "next_iips", "next_uips", "next_uIP", "next_uip", "next_peib", "next_uib"], "tval": ["flen", "Tlen", "Tval", " tlen", "fval", "tarr", "farr", "Tvals", "Tarr", "tlen", "tvals", " tarr", " tvals", "fvals"], "rex_w": ["rex1w", "rex_f", "rex_x", "nexus_v", "nexus_n", "nexus_f", "rx_W", "rx_r", "rex_n", "rx_w", "rex1f", "nexus_w", "rex1v", "rex1n", "rex_W", "rx_x", "rex_v"], "rex_r": ["rex_x", "rex_nr", "rex_l", "rex_rb", "pex2x", "cmp_h", "pex_rb", "rex2x", "rex_h", "cmp_r", "pex_nr", "pex_x", "cmp_l", "pex2rb", "pex2r", "pex_r", "rex2nr", "pex2nr", "cmp_v", "rex2rb", "rex2r", "rex_v"], "pc": ["cache", "cc", "dc", "sc", "bp", "ac", "mp", "fc", "rc", "cs", "pb", "ctx", "arc", "vc", "p", "pin", "xc", "proxy", "PC", "tc", "con", "prefix", "sys", "func", "server", "port", "c", "pre", "nc", "ping", "mc", "channel", "proc", "pa", "bc", "pointer", "uc", "lc"], "base": ["model", "cache", "unit", "temp", "core", "builder", "p", "root", "name", "id", "buffer", "area", "reset", "ase", "frame", "bi", "prefix", "based", "Base", "server", "body", "pre", "origin", "basic", "bas", "extra", "processor", "index"]}}
{"project": "qemu", "commit_id": "b93c94f7ec74a577a0f74c724e8d251f01eaf65a", "target": 1, "func": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct iscsi_context *iscsi = NULL;\n\n    struct iscsi_url *iscsi_url = NULL;\n\n    struct IscsiTask task;\n\n    char *initiator_name = NULL;\n\n    int ret;\n\n\n\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n\n                     \"of 512\", BDRV_SECTOR_SIZE);\n\n        return -EINVAL;\n\n    }\n\n\n\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n\n    if (iscsi_url == NULL) {\n\n        error_report(\"Failed to parse URL : %s %s\", filename,\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n\n\n    initiator_name = parse_initiator_name(iscsi_url->target);\n\n\n\n    iscsi = iscsi_create_context(initiator_name);\n\n    if (iscsi == NULL) {\n\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n\n        ret = -ENOMEM;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n\n        error_report(\"iSCSI: Failed to set target name.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url->user != NULL) {\n\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n\n                                              iscsi_url->passwd);\n\n        if (ret != 0) {\n\n            error_report(\"Failed to set initiator username and password\");\n\n            ret = -EINVAL;\n\n            goto failed;\n\n        }\n\n    }\n\n\n\n    /* check if we got CHAP username/password via the options */\n\n    if (parse_chap(iscsi, iscsi_url->target) != 0) {\n\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n\n\n\n    /* check if we got HEADER_DIGEST via the options */\n\n    parse_header_digest(iscsi, iscsi_url->target);\n\n\n\n    task.iscsilun = iscsilun;\n\n    task.status = 0;\n\n    task.complete = 0;\n\n    task.bs = bs;\n\n\n\n    iscsilun->iscsi = iscsi;\n\n    iscsilun->lun   = iscsi_url->lun;\n\n\n\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n\n                                 iscsi_connect_cb, &task)\n\n        != 0) {\n\n        error_report(\"iSCSI: Failed to start async connect.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    while (!task.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_aio_wait();\n\n    }\n\n    if (task.status != 0) {\n\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n\n\n    /* Medium changer or tape. We dont have any emulation for this so this must\n\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n\n     * to read from the device to guess the image format.\n\n     */\n\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n\n        iscsilun->type == TYPE_TAPE) {\n\n        bs->sg = 1;\n\n    }\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    if (initiator_name != NULL) {\n\n        g_free(initiator_name);\n\n    }\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n    if (iscsi != NULL) {\n\n        iscsi_destroy_context(iscsi);\n\n    }\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n    return ret;\n\n}\n", "idx": 572, "substitutes": {"bs": ["cas", "bc", "fs", "ils", "base", "bp", "BS", "ns", "cs", "pb", "bb", "bits", "cms", "fb", "bos", "bi", "css", "ses", "iss", "sb", "rs", "gb", "bh", "gs", "vs", "bas", "ss", "ls", "its", "bid", "lb", "ds", "bis", "sync", "bl", "bt"], "filename": ["fn", "tty", "binary", "uri", "ssl", "utf", "fp", "phrase", "location", "src", "document", "java", "which", "sequence", "name", "memory", "Filename", "fil", "buffer", "download", "sbm", "prefix", "file", "fd", "txt", "length", "il", "sf", "url", "dll", "files", "nil", "kl", "subject", "kn", "f", "rl", "directory", "username", "actual", "bytes", "path"], "flags": ["mask", "fn", "FLAG", "fs", "lag", "comments", "settings", "types", "flag", "utf", "bits", "fields", "config", "ops", "format", "stats", "fun", "reg", "files", "options", "locks", "args", "features", "Flags", "bytes", "ffff", "bit", "windows"], "iscsilun": ["discslun", "discsilin", "iscsilin", "iscsalun", "iscisolune", "iscslUn", "iscislon", "discsilune", "iscsilur", "iscslin", "discsluns", "iscislun", "ibsilon", "iscsalur", "iscislur", "iscineluns", "iscsalUn", "discsiluns", "iscinelin", "ibislUn", "iscslune", "iscslur", "discslune", "iscisoluns", "ibsilun", "iscisolin", "ibislun", "ibislon", "iscinelune", "iscsilune", "ibsilUn", "iscsiluns", "iscinelun", "iscslon", "ibislur", "ibsilur", "iscsalon", "iscisolun", "iscslun", "iscislUn", "iscsilon", "iscsluns", "discsilun", "iscsilUn", "discslin"], "iscsi": ["wicsie", "ircsis", "ircdi", "discfi", "rcsi", "ircli", "becii", "becsa", "iscifi", "ircni", "islsi", "miscifi", "discsa", "discdi", "uscsi", "becsi", "incSI", "discni", "discli", "rcsa", "iscsie", "incchi", "ISCni", "iscdi", "ISCsi", "iscli", "iscfi", "iscii", "iscchi", "iscsb", "iscani", "iscci", "ircfi", "incani", "uscchi", "ircani", "ISCci", "ircsb", "discci", "ISCsa", "ircsa", "becsie", "sicsis", "iscsis", "ircci", "iscSI", "uscci", "sicsa", "wicani", "rcni", "wicsi", "iscni", "sicifi", "wicni", "uscni", "ircchi", "islni", "iscsa", "uscdi", "incni", "islsb", "discsie", "miscsa", "uscsa", "uscSI", "wicii", "incsi", "incfi", "miscsi", "discii", "miscsis", "incsa", "wicsa", "ircSI", "discsi", "sicsi", "rcci", "incli", "ircsi", "ircifi", "islsa", "wicsb"], "iscsi_url": ["iscni_file", "iscsi2url", "iscsi__str", "iscgi__source", "iscsi_service", "iscsi_Url", "iscii_str", "isceni_Url", "iscgi_url", "iscsiPservice", "iscsi2host", "iscbi_url", "iscii_channel", "iscsi___layer", "iscsi_view", "iscsi___file", "iscni_coll", "isceni_str", "iscsi_URL", "iscsiOURL", "iscsi__host", "iscsi__source", "iscsi2source", "iscsin_server", "iscsi_coll", "iscsi_host", "iscsi__user", "iscni_layer", "iscgi_host", "iscsi_fl", "iscsin_url", "iscni__coll", "isceni_url", "iscii_url", "iscsi_file", "iscgi__host", "iscgi_mount", "iscsi2mount", "iscsiOuri", "iscii_run", "iscsi__url", "iscsin_sl", "iscsiPUrl", "iscni_url", "iscsi_run", "isceni_path", "iscsi_mount", "iscbi_fl", "iscni__text", "iscsi_server", "iscii_user", "iscsi_str", "iscSI_view", "iscni__user", "iscSI_url", "iscni_text", "iscbi_coll", "iscii_name", "iscii_Url", "iscSI_uri", "iscsi_channel", "iscsi_sl", "iscsi__name", "iscsiPrun", "iscni_user", "iscni_source", "iscsiOurl", "iscsi___source", "iscsi_uri", "iscbi_location", "iscsi__mount", "iscgi__mount", "iscii_path", "iscsiOview", "iscsi_user", "iscSI_URL", "iscgi__url", "iscsi_path", "iscsi_source", "iscgi_source", "iscsiPurl", "iscni__url", "iscsi_name", "iscsin_user", "iscsi__text", "iscsi___url", "iscii_service", "iscsi_layer", "iscsi_text", "iscsi__coll", "iscsi_location"], "task": ["\u7684", " tasks", "unit", " alloc", "ACK", "method", "master", "class", "func", "parent", "result", "image", "transfer", "tx", "proc", " Task", "NAME", "Task", "instance", "TYPE", "bit", "link"], "initiator_name": ["initiating_names", "initiator_type", "initiator__type", "initiate_names", "initiation_id", "initiator_key", "initiation__names", "initiating_name", "initiation__name", "initiator__id", "initiate_name", "initiation__id", "initiation__type", "initiator_id", "initiator__names", "initiator__no", "initiator__name", "initiate_key", "initiator_no", "initiation_names", "initiation_type", "initiating_type", "initiator_names", "initiate_no", "initiator__key", "initiating_id", "initiation_name"], "ret": ["rep", "cat", "wa", "bf", "val", "let", "rb", "res", "part", "req", " RET", "back", "match", "att", "rc", "lt", "code", "flag", "num", "resp", " Ret", "alt", "rt", "opt", "wait", "pt", "fin", "RET", "ref", "arr", "mem", "det", "gt", "job", "rev", "status", "obj", "len", "count", "lit", "ut", "nb", "success", "rets", "feat", "str", "reply", "mt", "fun", "nt", "reg", "result", "get", "arg", "Ret", "proc", "rl", "ft", "cur", "re", "bit", "art"]}}
{"project": "qemu", "commit_id": "b9f7c377df4f04e9119cb0e917438dd37ef34029", "target": 1, "func": "static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,\n\n                                           const void *pkt_data,\n\n                                           size_t pkt_len)\n\n{\n\n    struct virtio_net_hdr *vhdr;\n\n    bool isip4, isip6, istcp, isudp;\n\n    uint8_t *data;\n\n    int len;\n\n\n\n    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {\n\n        return;\n\n    }\n\n\n\n    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);\n\n    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);\n\n    if (!(isip4 || isip6) || !(istcp || isudp)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet3_dump_virt_hdr(vhdr);\n\n\n\n    /* Validate packet len: csum_start + scum_offset + length of csum field */\n\n    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {\n\n        VMW_PKPRN(\"packet len:%d < csum_start(%d) + csum_offset(%d) + 2, \"\n\n                  \"cannot calculate checksum\",\n\n                  len, vhdr->csum_start, vhdr->csum_offset);\n\n        return;\n\n    }\n\n\n\n    data = (uint8_t *)pkt_data + vhdr->csum_start;\n\n    len = pkt_len - vhdr->csum_start;\n\n    /* Put the checksum obtained into the packet */\n\n    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));\n\n\n\n    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\n    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;\n\n}\n", "idx": 573, "substitutes": {"pkt": ["melt", "bnt", " pnt", "fnt", "wct", "pet", "pnt", "macket", "wnt", "Pct", "Pkt", "Pnt", "packet", "pelt", "cpnt", "wkt", "fwk", "wacket", "cpacket", "mkt", "pct", "Packet", "belt", "fkt", "bkt", "mnt", "backet", "cpet", " packet", " pct", "pwk", " pwk", "cpkt", "felt", "fet", "facket", "bwk", " pet"], "pkt_data": ["pkg_length", "packet_dat", "pkg_data", "packet_data", "pkt2data", "pkg_start", "pkt_length", "pkg_len", "pkt_start", "pkt2len", "pkt_dat", "packet_len", "pkt2dat"], "pkt_len": ["pkt64length", "packet2seq", "pkt2seq", "pkt2Len", "packet_Len", "pkt2length", "pkt64Len", "packet_en", "pet_data", "pkt_en", "pkt64seq", "packet_size", "pkt_length", "pkt_Len", "pkt64len", "packet2Len", "pet_Len", "pkt_seq", "packet2len", "pkt2len", "packet_length", "packet_len", "packet_seq", "packet2length", "pet_length", "pet_len", "pkt_size"], "vhdr": ["vhrec", "svhder", "vshrr", "evhDR", " vghrid", "vvbr", "viewhrgr", "svrhrr", "vhlvd", "svhrr", "varchhr", "vshhr", "vchrc", "svhDR", "ghrrd", "vehDR", "svhradr", "vghdr", "viewhrder", "svhrrid", "vphder", "varchder", "vhDR", "vithdi", "vghdc", "viewhdc", "vphrd", "vhrt", "vmhldr", "vchrid", "evbhdi", " vhder", "vvrid", "vrhdr", "vahder", "vbhdr", "evbhmt", "vhrdr", "vhladr", "evhrec", "vmhdr", "viewhrvd", "vihdr", "vhrr", "vghrid", "vmhlrd", "svrhder", "vihrd", "vbhDR", "vhostrd", "viewhrt", " vhrid", "ghder", "vhrid", "svrhdr", "vrhrr", "ghrd", "svhrdr", "vphld", "vbhdc", "vhlrid", "svchrc", "ghdr", " vphDR", "svhrbr", "vghrt", " vhhr", "vbhder", "vphDR", "vhder", "ghrstr", "vehder", "evhdi", "ghrder", "vbhrid", "vadhdr", "vshDR", "vhrgr", "vbhmt", "vhrd", " vghdr", "vhrhr", "svchder", " vshhr", "vhlbr", "viewhder", "svchrid", " vphder", "vhhr", "vhld", "vohmt", "vrhDR", "vghDR", "vhrrt", "vhdvd", "vhradr", "vhrDR", "evhmt", " vshdr", "vhlder", "ghrdr", "vahDR", "viewhgr", "vhdgr", "varchDR", "vohdi", "vmhrd", "vhlrd", "vadhrec", " vphdr", "svhadr", "vchder", "vchdr", "vhrc", "vmhder", "vvdr", "vbhrec", " vhld", "vehdr", "vrhder", "evbhDR", "svhrc", "vphhr", "varchdr", "vbhdi", "vethdr", "vadhrd", "vihstr", "vhldr", "vhvd", "svhrid", "evhdr", "svhbr", "evbhdr", "vadhder", " vshDR", "vadhld", "vadhDR", "vahrid", "vhddr", "vethhr", "ghstr", "vshder", "vehrr", "viewhDR", "vhstr", "vohrid", "vhostdr", "vhdder", "vhdi", "vhdc", "vshdr", "vithdr", "vmhlder", " vghder", "vithmt", "vbhrc", "vhrvd", "vhmt", "vhrrid", "vhrdc", "vithrec", "vhlgr", "viewhvd", "vvadr", "viewhdr", "vohrec", "evbhrec", "vhbr", "vohdr", "vhadr", "vbhrt", "svhdr", "vhgr", "vihder", "svchdr", "vadhstr", "vethDR", "vhrbr", "vohrc", "vohDR", "vohder", "viewhrdc", "viewhrdr", "vhrrd", "viewhrrt", "svrhDR", "vghder", " vphhr", "vahdr", "vhrstr", "vhostder", " vhDR", "viewhrDR", "vhrder", "vphdr", " vghDR"], "isip4": ["isp44", " isid6", "isidfour", " isidfour", "iep44", "isid44", "isid6", "issid8", "issip8", " isid2", "iip8", "isip8", "isipfour", " isid4", "isepfour", "isid4", "isIP6", " isip2", "isid8", "issid44", "ispfour", "isp2", "isep4", " isipfour", "isIP8", "isIP44", "issip4", "iipfour", "isid2", "iip4", "isip2", "iep8", "isp4", "iip44", "iepfour", "isep6", "isep44", "issip44", "iep4", "isep2", "issid6", "isp6", "isep8", "isip44", "isp8", "isIP4", "issid4", "issip6"], "isip6": [" isid6", "issip6", "issep6", "isid6", "isp16", "issip8", "isip8", "issepsix", "isi6", "isip12", " isip16", "isip46", "isi12", "issep12", "isid8", " isip46", "isql8", "issip12", "isisix", " isip8", "isp3", "issep8", "isid3", "isi8", "isql16", "isip3", "isep6", " isid16", "isi46", " isip3", "isql6", "isep12", "isql46", "isp6", "isepsix", "isep8", "isaf16", " isid3", "isaf6", "isaf8", "isid16", "isp8", "isid46", "isaf3", "isip16", "issipsix", " isid8", "isql12", "isqlsix", "isi16", " isid46", "isipsix"], "istcp": ["stp", "astcp", "distmp", "stcp", "astpp", "astpc", "istep", "astmp", "pectpp", "xtip", "ismmp", "ismip", "xtep", "distcp", "pectcp", "irstcp", "istpp", "stmp", "pectp", "distip", "ismep", "istpe", "stpe", "ismcp", "istpc", "distep", "irstpc", "irstpp", "irstmp", "xtmp", "astpe", "istp", "xtcp", "istmp", "irstpe", "istip", "pectpc", "astp", "irstp"], "isudp": ["isudb", "isudsp", "isadhl", "issoodc", "pudc", "pubcp", "isodl", "isugpt", "asudm", "isubp", "isugc", "isugp", "asudb", "isudps", "isoodc", "isadhp", "pudp", "issoodpt", "issudpt", "isudpt", "issoodpe", "pubp", "isubl", "isudsps", "isubb", "publ", "isubm", "isudcp", "asubps", "pudcp", "isudc", "isuffm", "isuffp", "asudps", "isuffps", "asubb", "pudl", "isubc", "isodc", "issudc", "isudm", "isubps", "asudp", "isuffb", "issoodp", "isoodpt", "isudpe", "issudp", "isubcp", "pubc", "asubp", "isoodp", "isoodpe", "isodcp", "isadhpe", "isadhcp", "isudl", "isadhc", "isudsb", "isugpe", "issudpe", "isodp", "asubm", "isudsm", "isadhpt"], "data": ["field", "next", "dd", "val", "i", "lp", "ui", "base", "Data", "padding", "zero", "p", "valid", "new", "ada", "input", " DATA", "d", "raw", "dat", "alpha", "buffer", "id", "name", "buf", "ad", "pad", "aa", "a", "ata", "missing", "li", "batch", "parent", "length", "body", "dt", "in", "start", "di", "result", "block", "image", "style", "DATA", "response", "f", "da", "size", "addr", "bytes", "index"], "len": ["fn", "line", "val", "lp", "part", "l", "gen", "lon", "lim", "n", "alt", "pl", "seq", "fin", "mem", "ind", "split", "name", "limit", "ln", "dat", " length", "dy", "count", "Len", "lit", "end", "pos", "el", "li", "str", "ann", "sp", "length", "fun", "nt", "pre", "la", "lo", "bin", "db", "f", "err", "ni", "span", "sl", "size", "bl", "lf", "en"]}}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "CommandInfoList *qmp_query_commands(Error **errp)\n\n{\n\n    CommandInfoList *list = NULL;\n\n\n\n    qmp_for_each_command(&qmp_commands, query_commands_cb, &list);\n\n\n\n    return list;\n\n}\n", "idx": 574, "substitutes": {"errp": [" errps", "erp", "errc", "erpb", "excps", "erps", " errc", " errpb", "excpb", "excp", "errps", "excc", "errpb", "erc"], "list": ["comment", "cat", "i", "List", "diff", "detail", "listed", "base", "see", "card", "l", "chain", "object", "array", "code", "arr", "new", "cli", "call", "queue", "obj", "load", "table", "join", "count", "lc", "data", "coll", "batch", "parent", "member", "result", "block", "cl", "LIST", "set", "e", "out", "lists", "bl", "collection", "client", "entry", "sync", "record", "cont"]}}
{"project": "FFmpeg", "commit_id": "ca488ad480360dfafcb5766f7bfbb567a0638979", "target": 1, "func": "static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,\n\n                         unsigned int c, const unsigned int *div_blocks,\n\n                         unsigned int *js_blocks)\n\n{\n\n    ALSSpecificConfig *sconf = &ctx->sconf;\n\n    unsigned int offset = 0;\n\n    unsigned int b;\n\n    ALSBlockData bd[2] = { { 0 } };\n\n\n\n    bd[0].ra_block         = ra_frame;\n\n    bd[0].const_block      = ctx->const_block;\n\n    bd[0].shift_lsbs       = ctx->shift_lsbs;\n\n    bd[0].opt_order        = ctx->opt_order;\n\n    bd[0].store_prev_samples = ctx->store_prev_samples;\n\n    bd[0].use_ltp          = ctx->use_ltp;\n\n    bd[0].ltp_lag          = ctx->ltp_lag;\n\n    bd[0].ltp_gain         = ctx->ltp_gain[0];\n\n    bd[0].quant_cof        = ctx->quant_cof[0];\n\n    bd[0].lpc_cof          = ctx->lpc_cof[0];\n\n    bd[0].prev_raw_samples = ctx->prev_raw_samples;\n\n    bd[0].js_blocks        = *js_blocks;\n\n\n\n    bd[1].ra_block         = ra_frame;\n\n    bd[1].const_block      = ctx->const_block;\n\n    bd[1].shift_lsbs       = ctx->shift_lsbs;\n\n    bd[1].opt_order        = ctx->opt_order;\n\n    bd[1].store_prev_samples = ctx->store_prev_samples;\n\n    bd[1].use_ltp          = ctx->use_ltp;\n\n    bd[1].ltp_lag          = ctx->ltp_lag;\n\n    bd[1].ltp_gain         = ctx->ltp_gain[0];\n\n    bd[1].quant_cof        = ctx->quant_cof[0];\n\n    bd[1].lpc_cof          = ctx->lpc_cof[0];\n\n    bd[1].prev_raw_samples = ctx->prev_raw_samples;\n\n    bd[1].js_blocks        = *(js_blocks + 1);\n\n\n\n    // decode all blocks\n\n    for (b = 0; b < ctx->num_blocks; b++) {\n\n        unsigned int s;\n\n\n\n        bd[0].block_length = div_blocks[b];\n\n        bd[1].block_length = div_blocks[b];\n\n\n\n        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;\n\n        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;\n\n\n\n        bd[0].raw_other    = bd[1].raw_samples;\n\n        bd[1].raw_other    = bd[0].raw_samples;\n\n\n\n        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {\n\n            // damaged block, write zero for the rest of the frame\n\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples);\n\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples);\n\n            return -1;\n\n        }\n\n\n\n        // reconstruct joint-stereo blocks\n\n        if (bd[0].js_blocks) {\n\n            if (bd[1].js_blocks)\n\n                av_log(ctx->avctx, AV_LOG_WARNING, \"Invalid channel pair!\\n\");\n\n\n\n            for (s = 0; s < div_blocks[b]; s++)\n\n                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];\n\n        } else if (bd[1].js_blocks) {\n\n            for (s = 0; s < div_blocks[b]; s++)\n\n                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];\n\n        }\n\n\n\n        offset  += div_blocks[b];\n\n        bd[0].ra_block = 0;\n\n        bd[1].ra_block = 0;\n\n    }\n\n\n\n    // store carryover raw samples,\n\n    // the others channel raw samples are stored by the calling function.\n\n    memmove(ctx->raw_samples[c] - sconf->max_order,\n\n            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,\n\n            sizeof(*ctx->raw_samples[c]) * sconf->max_order);\n\n\n\n    return 0;\n\n}\n", "idx": 585, "substitutes": {"ctx": ["fn", "kb", "kw", "cal", "gru", "cu", "support", "cc", "git", "pkg", "loc", "setup", "sc", "cf", "rc", "cmp", "context", "cs", "cpp", "conv", "cca", "vc", "ci", "act", "cms", "xc", "cli", "config", "sq", "cam", "concept", "qa", "Context", "sci", "tc", "cv", "cp", "lc", "conn", "sys", "ca", "css", "cn", "ctrl", "nc", "kt", "cb", "tx", "ck", "std", "wcs", "ku", "cmd", "hw", "client", "utils", "component", "bc", "cfg", "cas", "cm", "anc", "cus"], "ra_frame": ["ra_layout", "ra_scale", "la_flow", "la_frame", "la_frames", "dra_slice", "ra_flow", " ra_frames", "ra_boot", "ra_slice", "dra_frame", "dra_boot", "ra_frames", " ra_layout", "dra_frames", "la_scale"], "c": ["cc", "cr", "dc", "sc", "cf", "ac", "fc", "rc", "cs", "ci", "cms", "xc", "ct", "d", "cp", "lc", "pc", "ca", "cn", "nc", "ch", "mc", "C", "e", "bc", "cm", "cd"], "div_blocks": ["js1rows", "ra_rows", "js1bars", "ra_groups", "ra_bars", "ra_blocks", "js_bars", "js1blocks", "js1groups", "js_rows", "js_groups"], "js_blocks": ["jsESSblocks", "js67bys", "jsESSframes", "jsenblock", "js_block", " js_rooms", "js67blocks", " js_bags", "js_breaks", " js_items", "cs_breaks", "jsESSbags", "js67items", "cs_blocks", "cs_rooms", "js___blocks", "div_block", "cs_block", "jsessrooms", "js5bags", "js5block", "jsessblocks", "div_checks", "jsESSblock", "js___items", "js_bands", "js67bands", " js_frames", "js5blocks", "js_checks", "div_limits", "js___bands", "jsenchecks", "js5rooms", "js___bys", " js_block", "jsessblock", "jsessbreaks", "js_frames", "js_limits", "js_bys", "jsenlimits", "js_items", "jsenblocks", " js_bys", " js_bands", "js_rooms", "js_bags"], "sconf": ["Scfg", "pdef", "scon", "gscon", "saff", "SConf", "paff", "Sconf", "gaff", " sconfig", "sdef", "gcfg", "sconfig", "gsdef", "pConf", "sConf", " sdef", "pconf", "pconfig", "pcfg", "gconf", "scfg", "gsconf", " scon", "Saff", "pcon", "gsconfig", "gConf"], "b": ["bf", "i", "rb", "base", "r", "bp", "l", "bb", "j", "n", "p", "B", "bg", "d", "m", "bs", "buf", "fb", "k", "v", "beta", "a", "nb", "eb", "batch", "sb", "body", "block", "cb", "db", "f", "e", "bc", "lb", "h"], "bd": ["vd", "kb", "md", "bf", "dd", "wd", "BD", "dc", "ke", " cd", "BT", "od", "ok", "de", "bb", " BD", "dl", "dj", "sh", "bo", "pd", "nd", "fl", "ff", "ud", "dm", "gt", "d", "bn", "ad", "fb", "BB", "ld", "df", "bot", "note", "cdn", "wk", "th", "nb", "dk", "fd", "td", "sb", "ande", "dt", "gd", "gb", "bh", "oda", "dh", "board", "boot", "block", "cb", "kell", "hd", "db", "sd", "cmd", "da", "wb", "bl", "bc", "ds", "bm", "bt", "cd"]}}
{"project": "qemu", "commit_id": "71b58b82dac1e1dc5e08a005a14bbcafecbd9e2a", "target": 0, "func": "static int write_f(int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    int count;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int pattern = 0xcd;\n\n\n\n    while ((c = getopt(argc, argv, \"bCpP:q\")) != EOF) {\n\n        switch (c) {\n\n        case 'b':\n\n            bflag = 1;\n\n            break;\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'p':\n\n            pflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        default:\n\n            return command_usage(&write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return command_usage(&write_cmd);\n\n    }\n\n\n\n    if (bflag && pflag) {\n\n        printf(\"-b and -p cannot be specified at the same time\\n\");\n\n        return 0;\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    if (!pflag) {\n\n        if (offset & 0x1ff) {\n\n            printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n                   offset);\n\n            return 0;\n\n        }\n\n\n\n        if (count & 0x1ff) {\n\n            printf(\"count %d is not sector aligned\\n\",\n\n                   count);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    buf = qemu_io_alloc(count, pattern);\n\n\n\n    gettimeofday(&t1, NULL);\n\n    if (pflag) {\n\n        cnt = do_pwrite(buf, offset, count, &total);\n\n    } else if (bflag) {\n\n        cnt = do_save_vmstate(buf, offset, count, &total);\n\n    } else {\n\n        cnt = do_write(buf, offset, count, &total);\n\n    }\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"write failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);\n\n\n\nout:\n\n    qemu_io_free(buf);\n\n\n\n    return 0;\n\n}\n", "idx": 599, "substitutes": {"argc": [" arglc", "configc", " argn", " argC", "argumentc", "arglc", "argumentv", " argp", "catc", "catn", "argumentlc", "argumentn", "catp", "catlc", "confign", "agf", "configC", "argumentf", "argf", "agp", "Argv", " argf", "argC", "Argc", "agv", "configv", "agc", "argp", "argumentp", "Argn", "argn", "ArgC"], "argv": ["argumentp", " argb", "parf", "agver", "argvs", "Argvs", "parvs", "argumentv", " argl", "argver", "argp", " argp", " argver", "argsp", "argsc", "agvs", "argumentl", "argsf", "argV", "argsb", "argsver", "agf", "Argf", "Argp", "argumentf", "parv", "argsvs", "argf", " argvs", "Argb", "argb", "Argv", "ArgV", "agp", "argsV", " argf", "Argl", "agv", " argV", "argsv", "parc", "agc", "Argc", "argl"], "t1": ["c1", "f0", "t8", "v2", "c3", " t8", "t3", "T3", " t0", "v8", "f2", "T0", "T1", "c0", "t0", "f3", "f1", "c2", "v0", "T2", "v1", "T8"], "t2": ["a2", "int0", "ttwo", "t5", "int2", "t4", "temptwo", "a5", "a0", "a1", "T5", "temp2", "temp4", "p1", "int5", "temp1", "T0", "T1", "T4", "Ttwo", "t0", "int1", "p2", "ptwo", "T2", "p4"], "c": ["comment", "cat", "i", "dc", "cc", "cr", "cit", "r", "cy", "sc", "cf", "ac", "l", "rc", "cs", "enc", "code", "n", "p", "ci", "orc", "ce", "ec", "ind", "xc", "d", "m", "z", "k", "con", "v", "cn", "nc", "ch", "mc", "cb", "channel", "col", "t", "b", "f", "cmd", "C", "e", "ct", "lc", "cd"], "cnt": ["Count", "icount", "rcct", " cnc", " cpt", "pnt", " cno", " cct", "rcant", "cret", " cant", "acNT", "ecct", "acno", "Cant", "Cct", "cct", "Cno", "pount", "rcpt", "rcnt", "pret", "ecnt", "icct", " cNT", "Cret", "cnc", "ecret", "rcnc", "rcount", "Cnc", " cret", "ecno", "icret", "acnt", "Cnt", "CNT", "Cpt", "rcNT", "cno", "acount", "cant", "icnt", "cpt", "ecount", "cNT", "pNT"], "buf": ["bf", "rb", "cache", "aka", "home", "pkg", "socket", "buff", "loc", "cf", "rc", "fi", "context", "cmp", "ctx", "img", "bd", "alloc", "tmp", "fp", "bo", "ha", "runner", "bg", "ff", "config", "queue", "buffer", "Buffer", "vec", "fb", "cv", "pos", "func", "fd", "Buff", "data", "coll", "window", "batch", "uf", "parent", "output", "port", "fw", "bag", "pool", "bh", "result", "block", "cb", "b", "cmd", "box", "que", "err", "cur", "wb", "bc", "cas", "uc", "msg", "seq", "br"], "offset": ["total", "part", "elta", "array", "num", "zero", "aff", "layout", "ref", "alias", "number", "len", "reset", "position", "parent", "origin", "layer", "info", "image", "gap", "set", "error", "option", "o", "seq", "config", "append", "limit", "et", "unc", "pos", "format", "data", "nt", "url", "ace", "style", "addr", "pointer", "sync", "base", "shift", "ptr", "active", "operation", "Offset", "location", "area", "slice", "length", "olerance", "address", "size", "empty", "index", "attribute", "loc", "attr", "padding", "optional", "af", "alpha", "id", "api", "skip", "off", "end", "prefix", "type", "slot", "amount", "start", "align", "range", "online", "timeout", "entry", "order"], "count": ["total", "part", "text", "match", "num", "ref", "key", "number", "sum", "len", "parent", "complete", "counter", "weight", "col", "large", "max", "f", "collection", "error", "p", "call", "name", "limit", "nt", "current", "now", "b", "found", "comment", "base", "patch", "code", "multiple", "session", "queue", "partial", "full", "allow", "batch", "length", "more", "child", "size", "empty", "last", "index", "cat", "loop", "cache", "val", "Count", "bug", "low", "n", "pattern", "id", "end", "type", "list", "coll", "amount", "start", "depth", "catch", "order"], "optind": ["optnd", "optionnd", "optii", " optinc", "optionend", "optionii", "opInd", "opnd", "octint", "parentend", "parentInd", " optii", "optionind", "propind", "optint", "propnd", "optionInd", "optimind", "optiminc", "Optinc", "propend", "optimInd", "optioninc", "parentind", "octInd", "Optii", "octnd", "optinc", " optInd", "parentinc", " optnd", "optend", "opint", "OptInd", "opinc", "optInd", "Optnd", "optionint", "opend", "optimnd", "Optind", "optimend", "opind", "propInd", "octind"]}}
{"project": "FFmpeg", "commit_id": "56706ac0d5723cb549fec2602e798ab1bf6004cd", "target": 1, "func": "static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)\n\n{\n\n    int compno;\n\n    int x, y;\n\n    int *image_line;\n\n    int frame_index;\n\n    const int numcomps  = image->numcomps;\n\n    uint16_t *frame_ptr = (uint16_t *)frame->data[0];\n\n\n\n    for (compno = 0; compno < numcomps; ++compno) {\n\n        if (image->comps[compno].w > frame->linesize[0] / numcomps) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Error: frame's linesize is too small for the image\\n\");\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    for (compno = 0; compno < numcomps; ++compno) {\n\n        for (y = 0; y < avctx->height; ++y) {\n\n            image_line = image->comps[compno].data + y * image->comps[compno].w;\n\n            frame_index = y * (frame->linesize[0] / 2) + compno;\n\n            for (x = 0; x < avctx->width; ++x) {\n\n                image_line[x] = frame_ptr[frame_index] >> 4;\n\n                frame_index += numcomps;\n\n            }\n\n            for (; x < image->comps[compno].w; ++x) {\n\n                image_line[x] = image_line[x - 1];\n\n            }\n\n        }\n\n        for (; y < image->comps[compno].h; ++y) {\n\n            image_line = image->comps[compno].data + y * image->comps[compno].w;\n\n            for (x = 0; x < image->comps[compno].w; ++x) {\n\n                image_line[x] = image_line[x - image->comps[compno].w];\n\n            }\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 657, "substitutes": {"avctx": ["afcontext", "afctl", "avcu", "aviacf", "avqa", "AVcf", "AVctx", "AVcdn", "axctx", "afcu", "axcmp", "aircu", " avcontext", "avcdn", "avcmp", " avcf", " avqa", "afqa", " avcmp", "aviactx", "AVctl", " avcu", "avcf", "afcmp", "aircontext", "afctx", "axctl", "aircf", "aviacontext", "AVqa", "axcontext", "AVcontext", "avctl", "afcdn", "AVcmp", "avcontext", "airctx", "afcf", "aviacdn"], "frame": ["picture", "model", "line", "media", "view", "Frame", "Image", "series", "rame", "object", "code", "play", "function", "fram", "layout", "connection", "document", "iframe", "node", "module", "interface", "sequence", "figure", "buffer", "source", "hole", "element", "slice", "flower", "file", "data", "position", "video", "photo", "game", "ze", "frames", "package", "motion", "plane", "layer", "flow", "block", "state", "audio", "feature", "f", "component", "message", "zone", "filename"], "image": ["picture", "media", "model", "update", "example", "view", "i", "man", "Image", "attribute", "im", "database", "ui", "manager", "um", "language", "object", "copy", "img", "eye", "code", "date", "function", "imi", "application", "pixel", "connection", "document", "node", "module", "m", "edge", "memory", "age", "element", "import", "slice", "cover", "event", "mini", "file", "type", "service", "position", "office", "video", "message", "photo", "game", "package", "ami", "shape", "initial", "site", "url", "layer", "network", "audio", "large", "feature", "address", "size", "instance", "use", "page", "cm", "jpg", "record", "order", "source"], "compno": ["modn", "procNO", "hostnone", "acone", "cmpnon", "porto", "cycleNO", "critnone", "hostbo", "acno", "cyclenumber", "componentpo", "compnor", "srcn", "comnos", "componentno", "parentto", "comppos", "srcyes", "sourceone", "compNO", "collNo", "comyes", "relo", " compNo", "componentnor", "componentname", " compyes", "relno", "relyes", "relname", "sourcen", "codeone", "collto", "cmpnumber", "codeno", "ompNo", "comNO", "propyes", "comno", "hostna", "propo", "critNO", "corn", "collno", "modno", "modNo", "portNO", "codeeno", "modbo", "componentyes", "combo", "comyo", "comnone", "hosto", "ompyes", "compeno", "hopno", " comppos", "cycleno", "sourceo", "parentNo", "condn", "componentbo", "cmppo", "componentnon", "srceno", "componentnone", "condname", "comname", "coden", "compna", "portbo", " compNO", "hopnon", "procno", "parentno", "comto", "condNO", "componentNO", "compyo", "compnos", "cmpyes", "colNo", "compone", "critna", "relto", "aco", "colno", "cmpbo", "cmpNO", " comppo", "hoppo", "corname", "curno", "acn", "hostno", "comNo", "condnos", "compn", "critno", "ompnone", "cmpno", "hopnos", "procyes", "classpo", "compnone", "curNo", "relNo", "componentnos", "colbo", "compto", "propno", "portno", "classnos", "corno", "cmpnos", "cyclebo", "compbo", "ompno", " compnos", "classno", "componentna", "compnumber", "compNo", "cmpnone", "codeo", "comppo", "componentpos", "curto", "componentyo", "componento", "condno", "cmpo", "collnos", "sourceno", "srcno", "procnos", "cmpnor", "compname", "coryes", "hostNO", "codeyes", "condyes", "colln", "classnor", "parentyes", "compo", "comn", "curyes", "propname", "compnon", "collpos", " compyo", "cmpNo", "compyes", "colleno", "coln", "componentnumber", "collyes"], "x": ["xxx", "wx", "view", "i", "xes", "xx", "key", "ya", "d", "yx", "z", "v", "column", "ix", "plus", "php", "f", "s", "my", "wy", "wa", "yl", "l", "xml", "p", "xc", "cross", "name", "time", "xp", "on", "event", "el", "data", "ph", "sex", "fx", "b", "q", "u", "na", "xi", "h", "content", "ww", "code", "rx", "lex", "w", "full", "es", "ip", "ady", "e", "xs", "index", "sw", "X", "ex", "j", "n", "xa", "any", "id", "pe", "k", "px", "xy", "work", "c", "in", "self", "tx", "dx", "ax", "one", "en"], "y": ["i", "hy", "ny", "cy", "yl", "l", "hop", "ey", "j", "n", "height", "o", "p", "yr", "ky", "yn", "sy", "ya", "d", "m", "vy", "z", "id", "yi", "w", "Y", "dy", "ii", "v", "oy", "py", "zy", "type", "year", "ye", "ym", "row", "xy", "ry", "yt", "c", "iy", "ay", "gy", "ch", "yo", "col", "t", "b", "f", "u", "q", "ady", "sky", "ty", "h", "yy"], "image_line": ["media_loc", "picture_look", "image_cell", "imageFlines", "image_block", "image_liner", "image_lin", "imageFloc", "video_code", "image_size", "video_lines", " image_block", "picture_line", "image_look", "imageFlin", "imageFline", "image_lines", " image_lin", "video_lin", " image_look", "media_lines", "video_line", " image_page", "media_line", " image_lines", "image_page", "image_code", "image_loc", " image_size", "media_lin", " image_liner", "picture_lin", "picture_cell"], "frame_index": ["framelexindex", "zonelexkey", "zonelexline", " frame_pointer", "zone_key", "frame_i", "zone_line", "zone_id", "framelexkey", "framelexid", "fram_index", "frame_position", "frame_ini", "frame_key", "file_Index", "file_index", "zonelexindex", "file_i", " frame_position", "fram_ini", "frame_id", "frame_pointer", "zone_index", "frame_Index", "fram_slice", "frame_slice", "zonelexid", "frame_line", "file_slice", "fram_pointer", "framelexline"], "frame_ptr": [" image_pointer", "frame_tr", " frame_rect", "frameacptr", "frameacpointer", "frameactr", " frame_tr", " imageactr", " imageacpointer", " imageacpointers", " image_ptr", " frame_pointer", "frame_pointer", "frame_pointers", " imageacptr", " image_pointers", "frame_rect", " image_tr", "frameacpointers"]}}
{"project": "FFmpeg", "commit_id": "55815edca038997ec283569a192a3eca7f2143bc", "target": 0, "func": "static void build_feed_streams(void)\n\n{\n\n    FFStream *stream, *feed;\n\n    int i;\n\n\n\n    /* gather all streams */\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n\n        feed = stream->feed;\n\n        if (feed) {\n\n            if (!stream->is_feed) {\n\n                /* we handle a stream coming from a feed */\n\n                for(i=0;i<stream->nb_streams;i++)\n\n                    stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* gather all streams */\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n\n        feed = stream->feed;\n\n        if (feed) {\n\n            if (stream->is_feed) {\n\n                for(i=0;i<stream->nb_streams;i++)\n\n                    stream->feed_streams[i] = i;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* create feed files if needed */\n\n    for(feed = first_feed; feed != NULL; feed = feed->next_feed) {\n\n        int fd;\n\n\n\n        if (url_exist(feed->feed_filename)) {\n\n            /* See if it matches */\n\n            AVFormatContext *s;\n\n            int matches = 0;\n\n\n\n            if (av_open_input_file(&s, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {\n\n                /* Now see if it matches */\n\n                if (s->nb_streams == feed->nb_streams) {\n\n                    matches = 1;\n\n                    for(i=0;i<s->nb_streams;i++) {\n\n                        AVStream *sf, *ss;\n\n                        sf = feed->streams[i];\n\n                        ss = s->streams[i];\n\n\n\n                        if (sf->index != ss->index ||\n\n                            sf->id != ss->id) {\n\n                            http_log(\"Index & Id do not match for stream %d (%s)\\n\",\n\n                                   i, feed->feed_filename);\n\n                            matches = 0;\n\n                        } else {\n\n                            AVCodecContext *ccf, *ccs;\n\n\n\n                            ccf = sf->codec;\n\n                            ccs = ss->codec;\n\n#define CHECK_CODEC(x)  (ccf->x != ccs->x)\n\n\n\n                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {\n\n                                http_log(\"Codecs do not match for stream %d\\n\", i);\n\n                                matches = 0;\n\n                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {\n\n                                http_log(\"Codec bitrates do not match for stream %d\\n\", i);\n\n                                matches = 0;\n\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                                if (CHECK_CODEC(time_base.den) ||\n\n                                    CHECK_CODEC(time_base.num) ||\n\n                                    CHECK_CODEC(width) ||\n\n                                    CHECK_CODEC(height)) {\n\n                                    http_log(\"Codec width, height and framerate do not match for stream %d\\n\", i);\n\n                                    matches = 0;\n\n                                }\n\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n                                if (CHECK_CODEC(sample_rate) ||\n\n                                    CHECK_CODEC(channels) ||\n\n                                    CHECK_CODEC(frame_size)) {\n\n                                    http_log(\"Codec sample_rate, channels, frame_size do not match for stream %d\\n\", i);\n\n                                    matches = 0;\n\n                                }\n\n                            } else {\n\n                                http_log(\"Unknown codec type\\n\");\n\n                                matches = 0;\n\n                            }\n\n                        }\n\n                        if (!matches)\n\n                            break;\n\n                    }\n\n                } else\n\n                    http_log(\"Deleting feed file '%s' as stream counts differ (%d != %d)\\n\",\n\n                        feed->feed_filename, s->nb_streams, feed->nb_streams);\n\n\n\n                av_close_input_file(s);\n\n            } else\n\n                http_log(\"Deleting feed file '%s' as it appears to be corrupt\\n\",\n\n                        feed->feed_filename);\n\n\n\n            if (!matches) {\n\n                if (feed->readonly) {\n\n                    http_log(\"Unable to delete feed file '%s' as it is marked readonly\\n\",\n\n                        feed->feed_filename);\n\n                    exit(1);\n\n                }\n\n                unlink(feed->feed_filename);\n\n            }\n\n        }\n\n        if (!url_exist(feed->feed_filename)) {\n\n            AVFormatContext s1 = {0}, *s = &s1;\n\n\n\n            if (feed->readonly) {\n\n                http_log(\"Unable to create feed file '%s' as it is marked readonly\\n\",\n\n                    feed->feed_filename);\n\n                exit(1);\n\n            }\n\n\n\n            /* only write the header of the ffm file */\n\n            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {\n\n                http_log(\"Could not open output feed file '%s'\\n\",\n\n                         feed->feed_filename);\n\n                exit(1);\n\n            }\n\n            s->oformat = feed->fmt;\n\n            s->nb_streams = feed->nb_streams;\n\n            for(i=0;i<s->nb_streams;i++) {\n\n                AVStream *st;\n\n                st = feed->streams[i];\n\n                s->streams[i] = st;\n\n            }\n\n            av_set_parameters(s, NULL);\n\n            if (av_write_header(s) < 0) {\n\n                http_log(\"Container doesn't supports the required parameters\\n\");\n\n                exit(1);\n\n            }\n\n            /* XXX: need better api */\n\n            av_freep(&s->priv_data);\n\n            avio_close(s->pb);\n\n        }\n\n        /* get feed size and write index */\n\n        fd = open(feed->feed_filename, O_RDONLY);\n\n        if (fd < 0) {\n\n            http_log(\"Could not open output feed file '%s'\\n\",\n\n                    feed->feed_filename);\n\n            exit(1);\n\n        }\n\n\n\n        feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n\n        feed->feed_size = lseek(fd, 0, SEEK_END);\n\n        /* ensure that we do not wrap before the end of file */\n\n        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)\n\n            feed->feed_max_size = feed->feed_size;\n\n\n\n        close(fd);\n\n    }\n\n}\n", "idx": 666, "substitutes": {"stream": ["view", "cloud", "follow", "reader", "group", "thread", "table", "row", "output", "image", "channel", "f", "Stream", "pull", "message", "draw", "host", "wave", "object", "null", "node", "config", "load", "event", "port", "pool", "url", "current", "web", "board", "live", "sync", "track", "transform", "ack", "wheel", "document", "pipe", "raw", "queue", "down", "full", "length", "server", "roll", "hook", "food", "child", "sl", "uc", "design", "path", "request", "source", "clean", "model", "user", "loop", "sw", "form", "cf", "header", "control", "filter", "input", "ream", "fuel", "coll", "upload", "forward", "flow", "draft", "resource", "single", "client", "round", "content"], "feed": ["driver", "update", "view", "follow", "grow", "gh", "throw", "zero", "layout", "fork", "check", "rss", "keep", "build", "row", "image", "channel", "large", "f", "post", "page", "pull", "draw", "host", "inf", "cr", "close", "valid", "config", "Feed", "load", "event", "hub", "gram", "gg", "board", "seed", "accept", "report", "comment", "next", "zip", "fast", "sc", "gen", "ack", "cell", "write", "raw", "acc", "queue", "full", "allow", "service", "search", "length", "read", "roll", "hook", "food", "child", "sl", "uc", "design", "index", "request", "source", "model", "loop", "insert", "bug", "form", "cf", "def", "low", "wait", "control", "input", "af", "ga", "id", "feeding", "import", "scroll", "handler", "fuel", "cook", "forward", "flow", "fed", "draft", "pass", "reader", "entry", "link"], "i": ["chi", "part", "iii", "uri", "d", "mi", "z", "ri", "v", "bi", "ie", "iu", "ix", "info", "block", "image", "pi", "f", "ti", "phi", "ui", "l", "is", "si", "o", "y", "p", "ci", "qi", "eni", "min", "li", "data", "vi", "b", "q", "u", "xi", "it", "h", "lc", "io", "r", "fi", "multi", "oi", "m", "ori", "ini", "slice", "x", "g", "zi", "ai", "t", "ei", "ip", "e", "yi", "index", "isi", "hi", "j", "root", "id", "k", "ii", "a", "c", "in", "di", "start", "abi", "gi", "none", "ni", "I", "inner", "reader"], "fd": ["fn", "flows", "fr", "fff", "find", " fid", "cond", "form", "fc", "iff", "ci", "ff", "d", "ma", "fm", "handler", "aa", "file", "feat", "fa", "di", "f", "ct", "ffff", "fe", "found"], "s": ["S", "fs", "sw", "sv", "sets", "su", "ts", "ns", "l", "hs", "settings", "si", "n", "ssl", "qs", "o", "y", "p", "m", "sq", "session", "se", "rss", "v", "services", "a", "stats", "service", "g", "ps", "search", "server", "ses", "spec", "c", "rs", "sb", "site", "es", "gs", "t", "b", "f", "u", "storage", "space", "aws", "js", "e", "ls", "sl", "single", "ds", "sync", "xs", "source"], "sf": ["SF", "bf", "fr", "sw", "fs", "sv", "su", "cf", "fc", "fi", "cpp", "si", "uci", "dl", "ssl", "aff", "fp", "fl", "fy", "tf", "sq", "rf", "fee", "rss", "fb", "fm", "df", "xf", "uf", "fw", "sb", "ef", "vp", "fx", "eph", "sd", "f", "ft", "sm", "nw", "sl", "lf", "fg", "fe"], "ss": ["oss", "fs", "sw", "su", "sv", "sc", "cf", "fts", "sch", "ns", "ess", "cs", "si", "sr", "ssl", "sh", "xx", "ys", "WS", "hess", "sq", "bs", "se", "rss", "ass", "sys", "css", "sp", "ps", "ses", "iss", "sb", "rs", "es", "SS", "vs", "sd", "os", "f", "serv", "sl", "ssh", "uss", "ls", "ds", "sync", "xs", "pg"], "ccf": ["acf", "ecfs", "ucfs", "ccv", "CCfs", "ccb", "ucb", "ucs", "csrf", "ecb", "cfv", "CCs", "CCb", "csf", "acrf", "acv", "ucf", "cfrf", "cffs", "csv", "CCf", "ecs", "cff", "csfs", "ecf", "ccfs", "ccrf", "acfs"], "ccs": ["ctp", "accl", "ccv", "cfp", "rcc", "ccc", "rcf", "ucl", "ccp", "ucs", "ccl", "cfv", "ctv", "accc", "rcl", "csf", "css", "accf", "ucf", "cfs", "csv", "ucc", "csp", "cff", "accs", "rcs", "cts", "ctf"]}}
{"project": "qemu", "commit_id": "e95e9b88ba5f4a6c17f4d0c3a3a6bf3f648bb328", "target": 1, "func": "static void do_interrupt64(CPUX86State *env, int intno, int is_int,\n\n                           int error_code, target_ulong next_eip, int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr;\n\n    int type, dpl, selector, cpl, ist;\n\n    int has_error_code, new_stack;\n\n    uint32_t e1, e2, e3, ss;\n\n    target_ulong old_eip, esp, offset;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 16 + 15 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    ptr = dt->base + intno * 16;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    e3 = cpu_ldl_kernel(env, ptr + 8);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 16 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = ((target_ulong)e3 << 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    ist = e2 & 7;\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_L_MASK) || (e2 & DESC_B_MASK)) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if ((!(e2 & DESC_C_MASK) && dpl < cpl) || ist != 0) {\n\n        /* to inner privilege */\n\n        new_stack = 1;\n\n        esp = get_rsp_from_tss(env, ist != 0 ? ist + 3 : dpl);\n\n        ss = 0;\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (env->eflags & VM_MASK) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n    esp &= ~0xfLL; /* align stack */\n\n\n\n    PUSHQ(esp, env->segs[R_SS].selector);\n\n    PUSHQ(esp, env->regs[R_ESP]);\n\n    PUSHQ(esp, cpu_compute_eflags(env));\n\n    PUSHQ(esp, env->segs[R_CS].selector);\n\n    PUSHQ(esp, old_eip);\n\n    if (has_error_code) {\n\n        PUSHQ(esp, error_code);\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        ss = 0 | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0);\n\n    }\n\n    env->regs[R_ESP] = esp;\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 669, "substitutes": {"env": ["req", "her", "enc", "conf", "eu", "ec", "usr", "stat", "qa", "eve", "v", "ah", "sb", "anne", "jp", "exc", "info", "osc", "que", "dev", "environment", "Environment", "vt", "eni", "config", "dat", "stage", "vm", "chal", "et", "org", "fen", "cdn", "cv", "event", "pos", "erv", "ench", "enh", "site", "eng", "forge", "init", "args", "nw", "net", "priv", "ev", "pg", "context", "ctx", "gear", "core", "obj", "engine", "loader", "energy", "conn", "txt", "server", "enable", "global", "eur", "e", "esi", "uv", "assets", "dc", "equ", "rt", "img", "viron", "esm", "end", "here", "inet", "ext", "cot", "ne", "console", "ea", "export", "nc", "np", "target", "atten", "dict", "vs", "db", "oa", "qt", "entry", "en"], "intno": ["indnumber", "incnum", "uintnumber", "intinfo", "pointcho", "incNO", "extnum", "Intnum", "seqnumber", "incno", "INTnum", "INTinfo", "pointnos", "pointeno", "extnos", "pointno", "indno", "uintcho", "incnumber", " intname", "idnum", "pointnumber", "extnumber", "indnum", "uinteno", "intNO", "incnos", "INTNO", "seqeno", "pointnum", " intinfo", "intnumber", " intNO", "pointNO", "pointname", "idname", "intnum", "extno", "inteno", "seqno", "extNO", "inccomp", "intnos", " intnum", "intcho", "seqcho", "pointinfo", "uintno", " intnos", "Intnumber", "Intno", "intcomp", "idnumber", " intcomp", "idno", "INTno", "indNO", "intname", "extcomp", " intnumber", "indnos"], "is_int": ["isFhw", " is_intel", " is_nt", "as_integer", "is7int", "as_inter", "is_inter", "is_oct", "is_nt", "as_int", "as_nt", "is_integer", "is_intel", "is7nt", "isFind", "isFnt", "as_oct", "is7ind", "is_ind", "isFint", " is_ind", "is7intel"], "error_code": [" error_cod", "erroraccod", " error_message", "erroraccodes", "erroracmessage", " error_codes", "error_message", "erroraccode", "error_cod", "error_codes"], "next_eip": ["next_peep", "next_eeep", "next_eips", "next_peip", "next_ceips", "next_eeip", "next_eep", "next_peIP", "next_eeips", "next_eIP", "next_peof", "next_peips", "next_seIP", "next_ceIP", "next_ceof", "next_seips", "next_eof", "next_seip", "next_eeIP", "next_seep", "next_ceip", "next_eeof"], "is_hw": ["is_rt", " is_fw", "as_fw", "is_fw", " is_ht", "as_rt", "as_hw", "is_wire", " is_wire", "as_ht", "is_ht"], "dt": ["driver", "tm", "dc", "cfg", "tp", "vt", "ta", "rt", "ctx", "tt", "elt", "fp", "tmp", "dm", "dr", "tf", "tz", "dat", "tk", "tg", "ds", "qa", "DT", "tc", "ut", "tn", "wt", "mt", "txt", "cn", "ea", "dn", "td", "dq", "np", "target", "di", "kt", "dh", "jp", "nat", "t", "db", "e", "ctr", "ct", "deb", "qt", "cm", "bt"], "ptr": ["fr", "next", "Ptr", "part", "base", "loc", "shift", "inst", "attr", "req", "pend", "rc", "rt", "ctx", "tr", "pointers", "prot", "code", "pt", "p", "fp", "ref", "src", "dr", "tip", "adr", "obj", "plug", "dy", "fe", "len", "slice", "pad", "pos", "ext", "length", "port", " pointer", "td", "patch", "pair", "start", "info", "jp", "rot", "proc", "inter", "eger", "address", "addr", "ctr", "pointer", "index", "br"], "type": ["comment", "val", "action", "part", "value", "loc", "attr", "error", "types", "code", "unit", "null", "y", "kind", "o", "p", "ref", "key", "var", "name", "id", "typ", "time", "class", "py", "pos", "ype", "shape", "port", "Type", "comp", "pre", "test", "ping", "like", "block", "state", "style", "rel", "t", "none", "op", "version", "ip", "set", " typ", "size", "TYPE", "ty", "link", "rule"], "dpl": [" dsl", " dcl", "dcbl", "dbl", "ldopl", "dopl", "dspl", "pPL", "dPL", " dPL", "pcl", "dplug", "pbl", "ccl", "ppl", "dsbl", "cbl", "dsl", "psl", "dcPL", " dbl", " dopl", " dpe", "dcpl", "ldpl", "dcplug", "dsopl", "csl", "dcl", " dplug", "ldbl", "dpe", "dspe", "ldpe", "pplug"], "selector": ["accesso", "lector", "accessori", "lecto", "selectori", "accession", "SELECTor", "selecto", "SELECTion", "lection", "accessor", " selectori", "lectori", " selecto", "selectory", "selection", "Selector", "SELECTori", " selection", "Selectori", "Selectory", "SELECTory", "Selection", " selectory"], "cpl": ["dpe", "tpl", "dbl", "cpe", "tPL", " cpp", " ccl", "cPL", "dPL", " cPL", "cpp", "tcompl", " cbl", "dcompl", " cfl", "pbl", "ccl", "cfl", " ccompl", "Ccl", "ppl", "tpp", "CPL", "cbl", "dsl", "psl", "dfl", "Cfl", "ccompl", "Cpl", "ppe", "csl", "dcl", " cpe", " csl", "dpp"], "ist": ["dist", "shift", "inst", "attr", "ack", "st", "ists", "ism", "ind", "rest", "rss", "et", "aps", "ress", "reset", "slice", "ext", "est", "ast", "sp", "asm", "ace", "ush", "push", "op", "slave", "esi", "sync"], "has_error_code": ["has_erroripcoded", "has_error_codes", "has_erroraycount", "has_ror_error", "has_erroripcode", "has_ror_call", "has_error_call", "has_errorayerror", "has_ror_count", "has_error_once", "has_erroraycode", "has_erroraycodes", "has_erroripcount", "has_ror_codes", "has_error_coded", "has_erroriponce", "has_error_error", "has_error_count", "has_ror_code"], "new_stack": [" new_addr", " new_depth", "newamscope", "new_depth", "new_scope", " new_scope", "newamdepth", "new_addr", "newamaddr", "newamstack"], "e1": [" eall", "eone", "ee64", "E1", "E3", "eeone", "en3", "ea3", "ec3", "E2", " e64", "eall", "p1", "Eone", "ee4", "pall", "Eall", "E4", "ea64", "ea2", "en4", "ee3", "ea1", "ec1", "ec4", "ee1", "enone", "p2", "eaone", "e4", "en1", " eone", "econe", "p4", "e64", " e4", "ee2"], "e2": ["p3", "e62", "E1", "c1", "c20", "p62", "E3", " e62", "d1", " e02", " e200", " e20", "ec3", "E2", "d4", "e20", "i2", "p1", "ee4", "ec2", "p200", "E4", "e16", "e02", "iTwo", " eTwo", "E02", " e4", "E62", "cTwo", "eTwo", "ec02", "c4", "i1", "d20", "ec1", "ee02", "c16", "ec4", "ee1", "ee200", "d2", "p2", "e4", "c2", " e16", "i16", "e200", "p4", "ee2"], "e3": ["E1", "e03", "ea53", "e5", "E3", "ea3", " e53", "i6", "ec5", "E5", "ec3", " e03", "E6", "E4", "iiii", " e4", "ea03", "ea1", " eiii", " e15", "ec1", "E15", "i4", "ec15", "Eiii", " e5", "eiii", "e4", "e15", "e6", "e53", " e6", "E53", "i3", "E03"], "ss": ["oss", "sw", "socket", "sc", "si", "ssl", "ff", "sq", "tz", "rw", "ress", "skip", "pos", "css", "sp", "ps", "rs", "pp", "eps", "speed", "ace", "eff", "au", "slave", "ls", "sync", "s"], "old_eip": ["old_Eep", "old_peips", "old_seep", "old_pepp", "old_peip", "old_eepp", "old_eeipped", "old_oeIP", "old_peep", "old_eeIP", "old_eeep", "old_ceIP", "old_sepp", "old_eeid", "old_zeIP", "old_peipped", "old_oeip", "old_cepp", "old_peid", "old_eipped", "old_oeid", "old_eips", "old_Eip", "old_ceep", "old_oeipped", "old_eeip", "old_eeips", "old_peIP", "old_eep", "old_seip", "old_eIP", "old_ceip", "old_zeip", "old_epp", "old_zepp", "old_Epp", "old_seIP", "old_eid", "old_Eips", "old_zeep"], "esp": ["ice", "clock", "cr", "resp", "sel", "sq", "iter", "rss", "ress", "slice", "selection", "cp", "pos", "css", "sp", "spec", "sb", "pp", "speed", "ace", "nil", "push", "sg", "slave", "sup", "sync"], "offset": ["part", "shift", "loc", "error", "padding", "o", "p", "Offset", "alias", "et", "len", "no", "reset", "slice", "skip", "count", "end", "pos", "oe", "position", "adjust", "data", "parent", "slot", "length", "port", "point", "oid", "start", "seed", "align", "address", "size", "addr", "timeout", "esi", "entry", "index"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n/*\n\n\twrites 1 byte o much and might cause alignment issues on some architectures?\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];\n\n*/\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t\t//FIXME slow?\n\n\t\tdst[0]= palette[ src[i]*4+0 ];\n\n\t\tdst[1]= palette[ src[i]*4+1 ];\n\n\t\tdst[2]= palette[ src[i]*4+2 ];\n\n\t\tdst+= 3;\n\n\t}\n\n}\n", "idx": 674, "substitutes": {"src": ["dist", "rect", "rb", "support", "inf", "text", "transform", "req", "loc", "inst", "sc", "sr", "secure", "rc", "fc", "ctx", "img", "sec", "ssl", "sel", "st", "kk", "input", "config", "sq", "buf", "cdn", "slice", "sci", "ruby", "dest", "gz", "feat", "data", "scene", "spec", "sb", "c", "url", "gb", "start", "image", "cb", "bin", "b", "cur", "sl", "iv", "http", "sup", "sync", "source", "desc"], "dst": ["dbl", " dset", "dste", "ddbl", " ddest", " dsp", "hdset", "hdfe", "ssts", "dedbl", " d2", "godst", "dsts", "best", "cdest", "ddst", "dset", "dubl", "sd2", "sdste", "dedste", "dconst", "sst", "ddsts", " dste", " dsts", "godstart", "lsts", "dedst", "dstart", "sdbl", "dest", "lest", "cdsts", "bsts", "godfe", "ldest", "cdst", " dbl", "hdstart", "hdst", "lst", "sdest", "sdst", "ddconst", "ded2", "dfe", "dsp", " dstart", "dust", "d2", " dest", "duconst", "ddest", "godset", "dusts", "sest", " dfe", "bst", "cdsp", " dconst", "bsp"], "num_pixels": ["num_nixel", "num2cixels", "num2pixel", "num_Pix", "num2cix", "num_cixels", "num_norts", "num_cips", "num2pix", "num2cixel", "num_tannels", "num_pix", "num_Pips", "num_pannels", "num_tips", "num_Pipes", "num_Ports", "num_tipes", "num_pips", "num_pixel", "num_cixel", "num_corts", "num_cannels", "num_pipes", "num_Pannels", "num_cix", "num_cipes", "num_nixels", "num_ports", "num2ports", "num2corts", "num_tixels", "num_nix", "num2pixels", "num_Pixel", "num_Pixels"], "palette": [" palue", "Paloton", "alettes", "allette", "Palette", "paloton", "Palue", "gamlette", "palge", "pixelette", "gamue", "alette", "holne", "holette", "alotype", "holoton", "palignment", " palettes", "palz", "fettes", "pixellette", "fge", " palne", "gamette", "Palignment", "fz", " pallette", "valge", "hollette", "Pallette", "alge", "Palne", "valette", "valz", "valettes", "palue", "palne", " paloton", "gamignment", " palignment", "pixelotype", "pixelettes", " palotype", "alz", "pallette", "fette", "palettes", "palotype"], "i": ["hi", "field", "ui", "io", "l", "iii", "si", "is", "j", "n", "uri", "o", "y", "p", "ci", "key", "multi", "qi", "eni", "d", "m", "oi", "id", "source", "api", "ri", "ii", "slice", "v", "bi", "a", "x", "li", "data", "iu", "ie", "ji", "c", "zi", "di", "ix", "ai", "jp", "info", "image", "abi", "start", "pi", "mu", "t", "gui", "f", "b", "u", "gi", "ti", "ip", "js", "e", "page", "xi", "I", "it", "phi", "index"]}}
{"project": "FFmpeg", "commit_id": "5cd8afee99c83b62e1474f122d947de7e4ad9ff5", "target": 0, "func": "static inline void codeblock(DiracContext *s, SubBand *b,\n\n                             GetBitContext *gb, DiracArith *c,\n\n                             int left, int right, int top, int bottom,\n\n                             int blockcnt_one, int is_arith)\n\n{\n\n    int x, y, zero_block;\n\n    int qoffset, qfactor;\n\n    IDWTELEM *buf;\n\n\n\n    /* check for any coded coefficients in this codeblock */\n\n    if (!blockcnt_one) {\n\n        if (is_arith)\n\n            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);\n\n        else\n\n            zero_block = get_bits1(gb);\n\n\n\n        if (zero_block)\n\n            return;\n\n    }\n\n\n\n    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {\n\n        if (is_arith)\n\n            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);\n\n        else\n\n            b->quant += dirac_get_se_golomb(gb);\n\n    }\n\n\n\n    b->quant = FFMIN(b->quant, MAX_QUANT);\n\n\n\n    qfactor = qscale_tab[b->quant];\n\n    /* TODO: context pointer? */\n\n    if (!s->num_refs)\n\n        qoffset = qoffset_intra_tab[b->quant];\n\n    else\n\n        qoffset = qoffset_inter_tab[b->quant];\n\n\n\n    buf = b->ibuf + top * b->stride;\n\n    for (y = top; y < bottom; y++) {\n\n        for (x = left; x < right; x++) {\n\n            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */\n\n            if (is_arith)\n\n                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);\n\n            else\n\n                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);\n\n        }\n\n        buf += b->stride;\n\n    }\n\n}\n", "idx": 677, "substitutes": {"s": ["S", "r", "su", "sc", "sets", "ns", "l", "cs", "si", "is", "j", "sec", "n", "o", "p", "d", "m", "sq", "session", "bs", "w", "sa", "ds", "v", "services", "a", "sys", "service", "g", "ses", "spec", "ks", "sb", "sf", "es", "self", "rs", "gs", "sym", "options", "t", "sg", "f", "u", "os", "ss", "e", "sl", "ls", "bis", "sup"], "b": ["be", "kb", "bf", "machine", "rb", "i", "part", "base", "r", "buff", "bp", "l", "xb", "pb", "bb", "orb", "n", "j", "bd", "lib", "o", "p", "ib", "B", "ab", "bg", "d", "bs", "obj", "buffer", "api", "w", "bt", "fb", "k", "ba", "mb", "v", "a", "nb", "bi", "bar", "g", "eb", "usb", "abb", "sb", "body", "self", "ob", "bh", "cb", "t", "db", "f", "bin", "u", "wb", "this", "e", "emb", "bc", "lb", "h"], "gb": ["hm", "kb", "bf", "cu", "rb", "cod", "cc", "bb", "ctx", "GB", "cca", "ci", "ud", "gc", "ub", "m", "ga", "gp", "gate", "gnu", "mb", "nb", "pc", "g", "usb", "gin", "abb", "hub", "sb", "rg", "gm", "gram", "gd", "gg", "gy", "gs", "mc", "cb", "gom", "db", "bin", "storage", "gam", "bc", "cfg", "bm"], "c": ["cod", "cu", "dc", "cr", "cc", "r", "cf", "ac", "l", "fc", "rc", "cs", "ctx", "code", "cell", "vc", "p", "ci", "ce", "ec", "xc", "d", "m", "k", "unc", "con", "cp", "lc", "pc", "co", "g", "cn", "ctrl", "nc", "cz", "ch", "mc", "cb", "f", "u", "cmd", "C", "e", "bc", "uc", "cm"], "top": ["high", "offset", "tp", "part", "ny", "Top", "TOP", "hop", "padding", "j", "height", "lon", "n", "p", "up", "best", "min", "first", "pop", "len", "bot", "above", "stop", "pos", "position", "front", "sp", "to", "below", "target", "start", "tops", "level", "max", "t", "op", "tail", "space", "upper"], "bottom": ["offset", "good", "back", "base", "low", "j", "height", "zero", "st", "lower", "min", "both", "step", "bound", "dy", "no", "bot", "off", "stop", "above", "position", "front", "row", "below", "margin", "start", "depth", "boot", "style", "level", "max", "op", "size", "two", "last", "Bottom"], "blockcnt_one": ["blockcNT_1", "blockcntsone", "blockcnc_one", "blockcnt_two", "blockcntptwo", "blockcNT_two", "blockcNT_one", "blockcnt_One", "blockcnc_1", "blockcntstwo", "blockcnt_1", "blockcNT_One", "blockcNT_many", "blockcnt_many", "blockcntsmany", "blockcntp1", "blockcntpone", "blockcnc_many", "blockcntpmany", "blockcnc_two", "blockcnts1"], "is_arith": ["is_grinth", "is_grighth", "is_auritz", "is_larithmetic", "is_arighth", "is_aurithmetic", "is_irithmetic", "is_earith", "is_earithmetic", "is_aurth", "is_earitz", "is_iryth", "is_iruth", "is_raruth", "is_larith", "is_rarth", "is_earyth", "is_aruth", "is_earth", "is_earighth", "is_raritz", "is_grith", "is_irighth", "is_arithmetic", "is_aritz", "is_aryth", "is_aurith", "is_laryth", "is_rarith", "is_arth", "is_larinth", "is_iritz", "is_grithmetic", "is_earinth", "is_arinth", "is_earuth", "is_irith", "is_irinth", "is_irth"], "x": ["xxx", "wx", "val", "i", "by", "X", "ww", "l", "ex", "code", "j", "num", "n", "xx", "ctx", "rx", "p", "height", "key", "xc", "d", "yx", "min", "z", "id", "w", "time", "Y", "xe", "pe", "k", "xp", "px", "on", "v", "gz", "g", "xy", "work", "in", "ix", "tx", "dx", "fx", "t", "max", "ax", "f", "u", "q", "e", "xi", "h", "xs", "step", "index"], "y": ["wy", "i", "ny", "cy", "yl", "l", "ey", "j", "n", "lon", "o", "p", "yn", "key", "sy", "ya", "d", "m", "yx", "vy", "z", "win", "w", "Y", "dy", "v", "oy", "py", "zy", "type", "ye", "ym", "xy", "ry", "yt", " Y", "ay", "gy", "ch", "yo", "col", "t", "f", "u", "ady", "asy", "e", "sky", "ty", "yi", "yy", "h"], "zero_block": ["one_block", "one_lock", "zeroslock", "zero_clock", "twoaynumber", "zeroayblock", "zerosclock", "zerosbatch", "two_number", "zero_number", "empty_block", "one_sync", "zero_batch", "one_byte", "zero_lock", "zero_square", "zeroaynumber", "twoaylock", "zeroaylock", "two_lock", "two_block", "zerosblock", "zero_sync", "empty_clock", "empty_batch", "twoayblock", "empty_lock", "zero_byte", "one_square"], "qoffset": ["qupad", "dqslot", "queryoffset", "qualoffset", " qfilter", "sqoffset", "eqoffset", "bitfactor", "qualfactor", "sqoff", "qstart", "qoff", "qqaddress", "foffset", "qqoffset", " qphase", "qslot", "qqpadding", "sqphase", "querypad", "sqpadding", "eqslot", "quphase", "ffactor", "eqlimit", "queryfactor", "sqslot", "qufactor", "bitfilter", "qupadding", "sqlimit", "eqoff", "fphase", "bitoffset", "biterror", "eqfactor", "eqpad", "quoffset", "qqphase", "qlimit", "quaddress", "qphase", "qpad", " qerror", "dqlimit", "querylimit", "dqoffset", "qpadding", "dqoff", " qstart", "qulimit", "qualfilter", "fstart", "qfilter", "qustart", "sqaddress", "qualerror", "qerror", "qaddress"], "qfactor": ["dqlength", "qqformat", "viewfactor", "qqshift", "qualfactor", " qcount", "quantshift", "qualphase", "qscale", " qsf", " qphase", "qufac", "quscale", "qucount", " qlength", " qconst", "qqfactor", "quphase", "eqscale", "viewfac", "qufactor", "sqshift", "qsf", "qshift", "sqformat", "quantformat", "qcount", "qconst", "eqsf", "qufilter", "dqfac", "eqfactor", "qualconst", " qscale", "qsector", "eqlength", "qformat", "qlength", "qphase", "viewscale", "quconst", "qfac", "dqsf", "sqfactor", "qqsector", "viewfilter", "dqfactor", "dqscale", "qfilter", "quantsector", "qualcount", "dqfilter", "quantfactor", "sqsector"], "buf": ["xff", "wa", "feed", "cache", "rb", "av", "text", "buff", "cf", "fab", "rc", "fi", "pb", "ctx", "bb", "header", "bd", "fp", "alloc", "tmp", "ab", "bridge", "config", "queue", "buffer", "Buffer", "vec", "fb", "pad", "cast", "cv", "v", "msg", "off", "func", "fd", "brace", "Buff", "data", "batch", "callback", "uf", "port", "bag", "pool", "board", "result", "cb", "cap", "la", "proc", "que", "cmd", "box", "cur", "wb", "bc", "cas", "uc", "bu", "seq", "br"]}}
{"project": "FFmpeg", "commit_id": "d58a6d8537a6f34941973c5c3be93d484a4d62ed", "target": 1, "func": "static int encode_frame(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){\n\n    FFV1Context *f = avctx->priv_data;\n\n    CABACContext * const c= &f->c;\n\n    AVFrame *pict = data;\n\n    const int width= f->width;\n\n    const int height= f->height;\n\n    AVFrame * const p= &f->picture;\n\n    int used_count= 0;\n\n\n\n    if(avctx->strict_std_compliance >= 0){\n\n        av_log(avctx, AV_LOG_ERROR, \"this codec is under development, files encoded with it wont be decodeable with future versions!!!\\n\"\n\n               \"use vstrict=-1 to use it anyway\\n\");\n\n        return -1;\n\n    }\n\n        \n\n    ff_init_cabac_encoder(c, buf, buf_size);\n\n    ff_init_cabac_states(c, ff_h264_lps_range, ff_h264_mps_state, ff_h264_lps_state, 64);\n\n    c->lps_state[2] = 1;\n\n    c->lps_state[3] = 0;\n\n    \n\n    *p = *pict;\n\n    p->pict_type= FF_I_TYPE;\n\n    \n\n    if(avctx->gop_size==0 || f->picture_number % avctx->gop_size == 0){\n\n        put_cabac_bypass(c, 1);\n\n        p->key_frame= 1;\n\n        write_header(f);\n\n        clear_state(f);\n\n    }else{\n\n        put_cabac_bypass(c, 0);\n\n        p->key_frame= 0;\n\n    }\n\n\n\n    if(!f->ac){\n\n        used_count += put_cabac_terminate(c, 1);\n\n//printf(\"pos=%d\\n\", used_count);\n\n        init_put_bits(&f->pb, buf + used_count, buf_size - used_count);\n\n    }\n\n    \n\n    if(f->colorspace==0){\n\n        const int chroma_width = -((-width )>>f->chroma_h_shift);\n\n        const int chroma_height= -((-height)>>f->chroma_v_shift);\n\n\n\n        encode_plane(f, p->data[0], width, height, p->linesize[0], 0);\n\n\n\n        encode_plane(f, p->data[1], chroma_width, chroma_height, p->linesize[1], 1);\n\n        encode_plane(f, p->data[2], chroma_width, chroma_height, p->linesize[2], 1);\n\n    }else{\n\n        encode_rgb_frame(f, (uint32_t*)(p->data[0]), width, height, p->linesize[0]/4);\n\n    }\n\n    emms_c();\n\n    \n\n    f->picture_number++;\n\n\n\n    if(f->ac){\n\n        return put_cabac_terminate(c, 1);\n\n    }else{\n\n        flush_put_bits(&f->pb); //nicer padding FIXME\n\n        return used_count + (put_bits_count(&f->pb)+7)/8;\n\n    }\n\n}\n", "idx": 683, "substitutes": {"avctx": ["afcontext", " avlc", "avcomp", "avcu", "avconn", "avqa", "AVcf", "AVctx", "aflc", "avectx", "camlc", "abctx", "afcu", "camctx", "camcu", "avcc", "Avctx", " avcontext", "abcam", "AVconfig", "ajqa", "ajcomp", " avcam", "abcomp", "afcomp", "ablc", "aveconfig", "ajctx", "Avcontext", "ajcf", "afqa", "ajlc", "afcc", "abcontext", "camcontext", "aveconn", "AVconn", "avcam", "afconn", "avcf", "afctx", "avcb", "avecontext", "avlc", "abcu", "afcb", " avcc", "AVqa", "avconfig", "AVcontext", "ajcontext", "avcontext", "afcam", "Avcb", "afcf", "Avcc", "afconfig", " avcb"], "buf": ["xff", "rb", "buff", "base", "rc", "pb", "ctx", "code", "img", "header", "binary", "num", "alloc", "fp", "src", "ff", "config", "queue", "buffer", "vec", "fb", "len", "cv", "fd", "batch", "uf", "length", "port", "bag", "map", "gb", "cb", "cap", "b", "cmd", "box", "que", "wb", "bc", "uc", "seq", "br"], "buf_size": ["boardlexsize", "uf_size", "board_send", "uf2len", "uf_count", " buf_capacity", "boardlexsend", "buf_capacity", "buf5size", "uf_len", "buflexize", "buf5speed", "buf2size", "board_size", "buf_count", "buf2speed", "buf_len", "buf6speed", "buf6count", "buflexsend", "bufncount", "buf5len", "buf6size", "buf2count", "buf5count", "buflexsize", "uf2count", "buf2len", "uf2size", "buf_ize", "bufncapacity", "buf6len", "buf_send", "bufnsize", "uf2speed", "boardlexize", " buf_count", "uf_speed", "buf_speed", "board_ize"], "data": ["picture", "media", "draw", "next", "feed", "cache", "i", "ui", "sample", "buff", "base", "r", "scale", "def", "rc", "Data", "fi", "device", "img", "code", "module", "input", "d", "config", "split", "dat", "first", "buffer", "load", "alpha", "memory", "pad", "v", "frame", "format", "a", "change", "pos", "capt", "window", "parent", "batch", "output", "body", "map", "fa", "start", "board", "image", "block", "channel", "la", "proc", "DATA", "bin", "na", "align", "da", "empty", "index"], "f": ["fr", "bf", "feed", "inf", "i", "fs", "family", "fac", "cf", "form", "l", "fc", "fi", "fab", "j", "conf", "function", "n", "aff", "o", "y", "fp", "ref", "fl", "ff", "fo", "d", "m", "fat", "config", "tf", "af", "rf", "w", "fb", "k", "df", "fen", "v", "of", "fd", "file", "g", "xf", "flat", "sf", "fw", "self", "ef", "fa", "lf", "info", "t", "b", "u", "this", "e", "x", "F", "s", "fe", "h"], "c": ["cat", "cu", "i", "cc", "cache", "dc", "cr", "r", "cy", "sc", "cf", "ac", "l", "fc", "cs", "enc", "ctx", "n", "icc", "o", "vc", "ci", "ce", "ec", "xc", "d", "m", "cam", "config", "z", "w", "k", "con", "v", "cv", "cp", "x", "pc", "ca", "g", "co", "cn", "self", "ch", "center", "mc", "t", "b", "u", "cl", "q", "cur", "C", "uc", "e", "ct", "cm", "client", "h", "lc", "s"], "pict": ["picture", "fn", "buff", "fi", "pb", "img", "ctx", "pl", "fp", "cli", "fat", "config", "cam", "obj", "pic", "stat", "qa", "sci", "cp", "conn", "feat", "prop", "Pict", "capt", "flat", "fw", "np", "fa", "info", "ch", "image", "col", "proc", "gui", "doc", "ct", "fig", "qt", "cop"], "p": ["i", "cache", "lp", "tp", "part", "pr", "l", "po", "pb", "j", "n", "o", "pl", "y", "fp", "up", "m", "per", "api", "pic", "pe", "v", "py", "cp", "a", "pc", "g", "ps", "sp", "parent", "pro", "port", "ap", "pp", "pre", "np", "vp", "jp", "get", "pi", "P", "t", "hp", "b", "u", "pa", "par", "q", "ip", "dp", "op", "post", "e", "cop", "h", "s", "pg"], "picture_number": ["image_no", "picture_counter", "image_num", "image_number", "image_counter", "picture_num", "picture_no"]}}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "void do_POWER_maskg (void)\n\n{\n\n    uint32_t ret;\n\n\n\n    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {\n\n        ret = -1;\n\n    } else {\n\n        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^\n\n            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);\n\n        if ((uint32_t)T0 > (uint32_t)T1)\n\n            ret = ~ret;\n\n    }\n\n    T0 = ret;\n\n}\n", "idx": 686, "substitutes": {"ret": ["cat", "bf", "val", "let", "res", "value", "part", "back", "error", "match", "def", "rc", "rt", "flag", "code", "alt", "opt", "valid", "fin", "RET", "ref", "key", "det", "fit", "gt", "rev", "id", "true", "afe", "len", "hard", "lit", "success", "ext", "rets", "feat", "data", "wrap", "mt", "fun", "sb", "nt", "xt", "reg", "result", "arg", "Ret", "t", "f", "ft", "re", "bit", "round", "art"]}}
{"project": "qemu", "commit_id": "f06ee3d4aa547df8d7d2317b2b6db7a88c1f3744", "target": 1, "func": "static void qed_aio_read_data(void *opaque, int ret,\n\n                              uint64_t offset, size_t len)\n\n{\n\n    QEDAIOCB *acb = opaque;\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n    BlockDriverState *bs = acb->common.bs;\n\n\n\n    /* Adjust offset into cluster */\n\n    offset += qed_offset_into_cluster(s, acb->cur_pos);\n\n\n\n    trace_qed_aio_read_data(s, acb, ret, offset, len);\n\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    /* Handle zero cluster and backing file reads */\n\n    if (ret == QED_CLUSTER_ZERO) {\n\n        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);\n\n        qed_aio_next_io(acb, 0);\n\n        return;\n\n    } else if (ret != QED_CLUSTER_FOUND) {\n\n        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,\n\n                              qed_aio_next_io, acb);\n\n        return;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,\n\n                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,\n\n                   qed_aio_next_io, acb);\n\n    return;\n\n\n\nerr:\n\n    qed_aio_complete(acb, ret);\n\n}\n", "idx": 707, "substitutes": {"opaque": ["ospaques", "ipaque", "opque", "ropacity", " opque", "ocacre", "osponymous", " opxb", "ospaque", "oponymous", "oconymous", " opacity", "opaques", "opxb", "ipacity", "ropaques", "ocaques", "opacity", "ipxb", "ropacre", "ropque", "roponymous", "opacre", "ropxb", "ocaque", "ropaque", "ipque", "ospacre"], "ret": ["rep", "val", "res", "total", "sur", "error", "att", "def", "rc", "ptr", "match", "rt", "flag", "section", "num", "sec", "hash", "alt", "lt", "code", "opt", "RET", "ref", "mem", "det", "rev", "obj", "id", "status", "pub", "bot", "reset", "count", "Len", "off", "lit", "ut", "success", "ext", "rets", "prot", "feat", "data", "reply", "mt", "length", "ry", "fun", "nt", "complete", "url", "reg", "info", "result", "nil", "get", "rot", "Ret", "al", "ft", "cur", "addr", "re", "bc", "seq"], "offset": ["fn", "i", "part", "base", "loc", "shift", "error", "ptr", "from", "num", "o", "fp", "Offset", "location", "ref", "af", "obj", "id", "et", "reset", "count", "off", "skip", "end", "pos", "prefix", "position", "data", "length", "output", "initial", "url", "origin", "start", "rot", "f", "align", "range", "set", "address", "size", "addr", "timeout", "pointer", "seq", "index"], "len": ["fn", "line", "val", "all", "part", "base", "loc", "en", "l", "gen", "enc", "lt", "lon", "n", "elt", "num", "lim", "fin", "ref", "mem", "fl", "split", "rev", "name", "ln", "load", "limit", "count", "Len", "pos", "el", "file", "conn", "str", "data", "length", "fun", "nt", "url", "block", "bin", "size", "bytes", "lif", "lf", "seq"], "acb": ["ancl", "accl", "ancbe", "appb", "akbar", "acck", "ACb", "ACv", "accbody", "encib", "akbr", "arck", "ecbb", "arcfb", "acba", "ucbr", "achbr", "ancfb", "ecsb", " ack", "ACbd", "acr", "ancv", "appd", "ancd", "acd", "eca", "acib", "ACba", "ancn", "ancbr", "accbd", "accfb", "acbe", "ACr", " acba", "ecbo", "ancsb", "aclbody", "accd", "aclv", "acbf", "ACf", "ecv", "acbar", "acczb", "anczb", "ecb", "achbb", " acn", "accbe", "accn", "ocl", "ecbd", "ACbb", "acfb", "arcb", "axk", "akb", "acv", "ancbf", "acbo", "ecbody", "ocf", "anca", "acbd", " acp", " acr", "appbb", "appk", "ecf", "encb", "macb", "macp", "macf", "acf", "accbb", " acsb", " acv", "arczb", "ack", "ACd", "encbar", "accp", "ucb", " acl", "accb", " acbb", "acl", "acbb", "axbb", "achb", "ACk", "ancbo", "ucj", "aclb", "acn", " acf", " acbe", "acll", " acib", "acsb", " acbr", "accbf", "eck", "acbody", "achj", " acbo", " acbar", "ecba", "acp", " acd", "axbf", "macfb", "ocb", "ancf", "ocba", "acbr", "accr", "aczb", "accsb", "akib", "ucbb", "ancj", "ancp", "axb", "aca", "ocbb", "ancbb", "encbr", "ocsb", "anck", "ACp", "accf", "ACsb", "ACl", "ecl", "accv", " aca", "acj", "accba", " acfb", "ancb"], "s": ["socket", "r", "sets", "ns", "cs", "is", "si", "ssl", "o", "south", "p", "http", "src", "session", "sq", "se", "opens", "sa", "bos", "services", "a", "sys", "states", "stats", "g", "ps", "submit", "ses", "ks", "sb", "rs", "c", "spec", "self", "iss", "obs", "site", "gs", "state", "b", "os", "f", "storage", "ss", "js", "e", "sl", "ls", "bis", "ops", "ds", "h"], "bs": ["fs", "ms", "base", "BS", "ns", "bid", "ts", "cs", "pb", "bb", "fps", "bes", "bits", "bps", "bg", "cms", "ins", "bt", "fb", "ba", "bos", "ros", "bi", "eb", "css", "ps", "us", "ses", "ks", "sb", "iss", "rs", "obs", "gb", "bh", "gs", "bytes", "board", "cb", "vs", "db", "b", "os", "bas", "ss", "js", "ls", "bl", "bc", "lb", "ds", "bis", "bm", "its", "cus"]}}
{"project": "qemu", "commit_id": "b6c147622d31272f9728da9ec16d146bf8c45a74", "target": 1, "func": "int qcow2_update_header(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowHeader *header;\n\n    char *buf;\n\n    size_t buflen = s->cluster_size;\n\n    int ret;\n\n    uint64_t total_size;\n\n    uint32_t refcount_table_clusters;\n\n    size_t header_length;\n\n    Qcow2UnknownHeaderExtension *uext;\n\n\n\n    buf = qemu_blockalign(bs, buflen);\n\n\n\n    /* Header structure */\n\n    header = (QCowHeader*) buf;\n\n\n\n    if (buflen < sizeof(*header)) {\n\n        ret = -ENOSPC;\n\n        goto fail;\n\n    }\n\n\n\n    header_length = sizeof(*header) + s->unknown_header_fields_size;\n\n    total_size = bs->total_sectors * BDRV_SECTOR_SIZE;\n\n    refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3);\n\n\n\n    *header = (QCowHeader) {\n\n        /* Version 2 fields */\n\n        .magic                  = cpu_to_be32(QCOW_MAGIC),\n\n        .version                = cpu_to_be32(s->qcow_version),\n\n        .backing_file_offset    = 0,\n\n        .backing_file_size      = 0,\n\n        .cluster_bits           = cpu_to_be32(s->cluster_bits),\n\n        .size                   = cpu_to_be64(total_size),\n\n        .crypt_method           = cpu_to_be32(s->crypt_method_header),\n\n        .l1_size                = cpu_to_be32(s->l1_size),\n\n        .l1_table_offset        = cpu_to_be64(s->l1_table_offset),\n\n        .refcount_table_offset  = cpu_to_be64(s->refcount_table_offset),\n\n        .refcount_table_clusters = cpu_to_be32(refcount_table_clusters),\n\n        .nb_snapshots           = cpu_to_be32(s->nb_snapshots),\n\n        .snapshots_offset       = cpu_to_be64(s->snapshots_offset),\n\n\n\n        /* Version 3 fields */\n\n        .incompatible_features  = cpu_to_be64(s->incompatible_features),\n\n        .compatible_features    = cpu_to_be64(s->compatible_features),\n\n        .autoclear_features     = cpu_to_be64(s->autoclear_features),\n\n        .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),\n\n        .header_length          = cpu_to_be32(header_length),\n\n    };\n\n\n\n    /* For older versions, write a shorter header */\n\n    switch (s->qcow_version) {\n\n    case 2:\n\n        ret = offsetof(QCowHeader, incompatible_features);\n\n        break;\n\n    case 3:\n\n        ret = sizeof(*header);\n\n        break;\n\n    default:\n\n        return -EINVAL;\n\n    }\n\n\n\n    buf += ret;\n\n    buflen -= ret;\n\n    memset(buf, 0, buflen);\n\n\n\n    /* Preserve any unknown field in the header */\n\n    if (s->unknown_header_fields_size) {\n\n        if (buflen < s->unknown_header_fields_size) {\n\n            ret = -ENOSPC;\n\n            goto fail;\n\n        }\n\n\n\n        memcpy(buf, s->unknown_header_fields, s->unknown_header_fields_size);\n\n        buf += s->unknown_header_fields_size;\n\n        buflen -= s->unknown_header_fields_size;\n\n    }\n\n\n\n    /* Backing file format header extension */\n\n    if (*bs->backing_format) {\n\n        ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,\n\n                             bs->backing_format, strlen(bs->backing_format),\n\n                             buflen);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        buf += ret;\n\n        buflen -= ret;\n\n    }\n\n\n\n    /* Feature table */\n\n    Qcow2Feature features[] = {\n\n        /* no feature defined yet */\n\n    };\n\n\n\n    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,\n\n                         features, sizeof(features), buflen);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    buf += ret;\n\n    buflen -= ret;\n\n\n\n    /* Keep unknown header extensions */\n\n    QLIST_FOREACH(uext, &s->unknown_header_ext, next) {\n\n        ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        buf += ret;\n\n        buflen -= ret;\n\n    }\n\n\n\n    /* End of header extensions */\n\n    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    buf += ret;\n\n    buflen -= ret;\n\n\n\n    /* Backing file name */\n\n    if (*bs->backing_file) {\n\n        size_t backing_file_len = strlen(bs->backing_file);\n\n\n\n        if (buflen < backing_file_len) {\n\n            ret = -ENOSPC;\n\n            goto fail;\n\n        }\n\n\n\n        strncpy(buf, bs->backing_file, buflen);\n\n\n\n        header->backing_file_offset = cpu_to_be64(buf - ((char*) header));\n\n        header->backing_file_size   = cpu_to_be32(backing_file_len);\n\n    }\n\n\n\n    /* Write the new header */\n\n    ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_vfree(header);\n\n    return ret;\n\n}\n", "idx": 710, "substitutes": {"bs": ["banks", "rb", "fs", "las", "base", "BS", "ns", "bid", "cs", "pb", "bb", "bes", "bits", "ab", "blocks", "sa", "bos", "fb", "lbs", "bi", "stats", "ses", "ks", "sb", "rs", "iss", "obs", "gb", "bh", "gs", "bytes", "vs", "b", "os", "bas", "ss", "js", "ls", "bl", "bc", "lb", "ds", "bis", "sync"], "s": ["i", "all", "series", "conf", "sa", "sis", "states", "ps", "secondary", "sb", "sym", "state", "os", "f", "parts", "as", "space", "set", "js", "_", "comments", "sv", "is", "si", "o", "qs", "p", "less", "ins", "details", "stats", "ses", "site", "args", "b", "sg", "sup", "sync", "S", "settings", "cs", "ssl", "south", "session", "sq", "service", "g", "us", "spec", "ks", "es", "gs", "ss", "e", "sl", "ls", "http", "ds", "xs", "su", "sets", "ts", "ns", "ess", "byte", "services", "a", "sys", "sie", "type", "sf", "c", "rs", "storage", "bis"], "header": ["driver", "host", "line", "offset", "cache", "manager", "auth", "Header", "her", "section", "cookie", "code", "vector", "runner", "filter", "document", "root", "dr", "bridge", "metadata", "config", "queue", "head", "buffer", "token", "fat", "table", "handler", "master", "cover", "event", "gender", "holder", "conn", "writer", "data", "border", "parent", "server", "port", "body", "pair", "layer", "block", "channel", "large", "response", "player", "f", "feature", "version", "client", "message", "reader", "h", "content"], "buf": ["rb", "cache", "home", "buff", "rc", "fi", "pb", "ctx", "img", "fp", "alloc", "tmp", "src", "ab", "ff", "runner", "queue", "obj", "buffer", "Buffer", "vec", "fb", "pad", "cv", "func", "fd", "Buff", "feat", "data", "abb", "batch", "uf", "fw", "bag", "pool", "uber", "bh", "exc", "result", "block", "cb", "cap", "b", "box", "cmd", "carry", "wb", "aux", "bc", "cas", "uc", "seq"], "ret": ["cat", "val", "res", "error", "match", "def", "prot", "fi", "rc", "rt", "flag", " Ret", "num", "resp", "alt", "opt", "fin", "RET", "det", "gt", "rev", "status", "len", "lit", "success", "conn", "rets", "feat", "nt", "reg", "result", "arg", "Ret", "ft", "re", "bis", "bit"], "total_size": ["page_size", "stable_sized", "total128small", "page_len", "total_length", "total28length", "total24storage", "total_sized", "total24size", "total67small", "total_len", "total28capacity", "total67size", "total96unit", "total96depth", "stable67size", "block_unit", "total67storage", "totalxunit", "total_unit", "totalxdepth", "total24small", "total67sized", "total28size", "stable_size", "total128sized", "total96size", "block0000unit", "block0000offset", "total128size", "total96offset", "total_storage", "total_depth", "page_capacity", "stable67sized", "totalxoffset", "total0000size", "total_offset", "total128storage", "total28len", "block0000size", "block_depth", "total0000depth", "total24sized", "total_capacity", "total0000offset", "stable_small", "stable_storage", "block_offset", "total_small", "page_length", "block_size", "stable67small", "block0000depth", "totalxsize", "total0000unit", "stable67storage"], "refcount_table_clusters": ["refcount_table_sclusters", "refcount_table_clows", "refcount_table_slusters", "refcount_table_combusters", "refcount_table_lues", "refcount_table_combients", "refcount_table_combuster", "refcount_table_CLust", "refcount_table_lusters", "refcount_table_luster", "refcount_table_clunks", "refcount_table_alusters", "refcount_table_filunks", "refcount_table_flows", "refcount_table_licas", "refcount_table_flicas", "refcount_table_colicas", "refcount_table_CLows", "refcount_table_colusters", "refcount_table_clicas", "refcount_table_cluster", "refcount_table_fluster", "refcount_table_alues", "refcount_table_filues", "refcount_table_combips", "refcount_table_slust", "refcount_table_sclips", "refcount_table_coluster", "refcount_table_CLuster", "refcount_table_aluster", "refcount_table_clients", "refcount_table_scuster", "refcount_table_scust", "refcount_table_sluster", "refcount_table_colows", "refcount_table_scows", "refcount_table_filuster", "refcount_table_lunks", "refcount_table_lips", "refcount_table_sclients", "refcount_table_CLusters", "refcount_table_clust", "refcount_table_flusters", "refcount_table_lows", "refcount_table_clues", "refcount_table_alunks", "refcount_table_lients", "refcount_table_scusters", "refcount_table_filusters", "refcount_table_slows", "refcount_table_scluster", "refcount_table_clips"], "header_length": ["layer_size", "layer_limit", "header2len", "header2length", "header2shape", "header_shape", "header_size", "headers_position", "headers_shape", "header_len", "header2position", "headers_length", "layer_len", "header_position", "headers_len", "header_limit", "layer_length"], "uext": ["cueXT", "ueft", "ceXT", "uXT", "ceext", "cext", "uxt", "uft", "cuext", "ceft", "ueext", "cueext", "cueft", "ueXT"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void tcp_start_incoming_migration(const char *host_port, Error **errp)\n\n{\n\n    int s;\n\n\n\n    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);\n\n    if (s < 0) {\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,\n\n                         (void *)(intptr_t)s);\n\n}\n", "idx": 729, "substitutes": {"host_port": ["server_host", "hostpstream", "host_host", "server_port", "host_ports", "host_address", " host_stream", "hostpport", "host_stream", "server_ports", "hostpaddress", "server_address", " host_address"], "errp": [" errps", "aerr", " errcp", "ercp", "errr", "raisefp", "aerp", "erps", "errcp", "errps", "erP", "errfp", "errpe", "errP", "erfp", "raisep", "raisecp", "aerP", "erpe", "aerpe", "erp", " errP", "raiseps", " errpe", " errr", "err", " errfp"], "s": ["S", "i", "fs", "ports", "socket", "ms", "su", "r", "sets", "ts", "ns", "l", "hs", "settings", "is", "seconds", "sound", "n", "si", "ssl", "core", "o", "p", "ips", "new", "d", "m", "rows", "sq", "session", "status", "opens", "an", "v", "x", "stats", "states", "g", "ps", "lines", "server", "sf", "secondary", "sb", "c", "rs", "es", "port", "gs", "args", "t", "os", "f", "b", "u", "address", "ss", "e", "sl", "ls", "its", "ops", "ds", "sync", "h"]}}
{"project": "qemu", "commit_id": "d049bde69d8ab3dfa4edeee48896088ae9feb693", "target": 1, "func": "static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset,\n\n                                       sPAPRPHBState *sphb)\n\n{\n\n    ResourceProps rp;\n\n    bool is_bridge = false;\n\n    int pci_status, err;\n\n    char *buf = NULL;\n\n    uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev);\n\n    uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3);\n\n    uint32_t max_msi, max_msix;\n\n\n\n    if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) ==\n\n        PCI_HEADER_TYPE_BRIDGE) {\n\n        is_bridge = true;\n\n    }\n\n\n\n    /* in accordance with PAPR+ v2.7 13.6.3, Table 181 */\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"vendor-id\",\n\n                          pci_default_read_config(dev, PCI_VENDOR_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"device-id\",\n\n                          pci_default_read_config(dev, PCI_DEVICE_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"revision-id\",\n\n                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"class-code\", ccode));\n\n    if (pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"interrupts\",\n\n                 pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)));\n\n    }\n\n\n\n    if (!is_bridge) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"min-grant\",\n\n            pci_default_read_config(dev, PCI_MIN_GNT, 1)));\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"max-latency\",\n\n            pci_default_read_config(dev, PCI_MAX_LAT, 1)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-vendor-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"cache-line-size\",\n\n        pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1)));\n\n\n\n    /* the following fdt cells are masked off the pci status register */\n\n    pci_status = pci_default_read_config(dev, PCI_STATUS, 2);\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"devsel-speed\",\n\n                          PCI_STATUS_DEVSEL_MASK & pci_status));\n\n\n\n    if (pci_status & PCI_STATUS_FAST_BACK) {\n\n        _FDT(fdt_setprop(fdt, offset, \"fast-back-to-back\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_66MHZ) {\n\n        _FDT(fdt_setprop(fdt, offset, \"66mhz-capable\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_UDF) {\n\n        _FDT(fdt_setprop(fdt, offset, \"udf-supported\", NULL, 0));\n\n    }\n\n\n\n    _FDT(fdt_setprop_string(fdt, offset, \"name\",\n\n                            pci_find_device_name((ccode >> 16) & 0xff,\n\n                                                 (ccode >> 8) & 0xff,\n\n                                                 ccode & 0xff)));\n\n    buf = spapr_phb_get_loc_code(sphb, dev);\n\n    if (!buf) {\n\n        error_report(\"Failed setting the ibm,loc-code\");\n\n        return -1;\n\n    }\n\n\n\n    err = fdt_setprop_string(fdt, offset, \"ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n\n\n    if (drc_index) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#address-cells\",\n\n                          RESOURCE_CELLS_ADDRESS));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#size-cells\",\n\n                          RESOURCE_CELLS_SIZE));\n\n\n\n    max_msi = msi_nr_vectors_allocated(dev);\n\n    if (max_msi) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi\", max_msi));\n\n    }\n\n    max_msix = dev->msix_entries_nr;\n\n    if (max_msix) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi-x\", max_msix));\n\n    }\n\n\n\n    populate_resource_props(dev, &rp);\n\n    _FDT(fdt_setprop(fdt, offset, \"reg\", (uint8_t *)rp.reg, rp.reg_len));\n\n    _FDT(fdt_setprop(fdt, offset, \"assigned-addresses\",\n\n                     (uint8_t *)rp.assigned, rp.assigned_len));\n\n\n\n    if (sphb->pcie_ecs && pci_is_express(dev)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,pci-config-space-type\", 0x1));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 740, "substitutes": {"dev": ["gu", "md", "mod", "serial", "dist", "comment", "dc", "dd", "user", "diff", "prov", "die", "bug", "od", "attr", "des", "error", "priv", "device", "def", "de", "google", "grad", "conf", "debug", "DEV", "valid", "d", "cam", "vol", "prom", "mode", "pad", "off", "fail", "loader", "conn", "dis", "data", "development", "spec", "Dev", "progress", "app", "devices", "reg", "test", "current", "di", "prof", "info", "ch", "block", " device", "proc", "dem", "home", "der", "ver", "serv", "rad", "ev", "hw", "dom", "desc"], "fdt": ["dfwt", "gdt", "fdtt", "dlnot", "fdtz", "FDtt", "vdout", "fxwt", "lfc", "ydtz", "mdT", "gdd", "FDT", "fxc", "FDta", "fedc", "dirnot", "dlT", "ydn", "dlwt", "dfz", "dftt", "ldt", "fdts", "FDt", "vdtt", "ydt", "ecdnot", "fdc", "fdT", "fedtt", "fxta", "mdt", "dld", "gdts", "ecdwt", "dft", "lfts", "dirwt", "dlc", "dirtt", "fedwt", "mdc", "dltt", "fedT", "ecdt", "dfta", "fxt", "fdnot", "feedwt", "dlt", "vdT", "lfd", "fedz", "fdz", "feedT", "dfout", "dfT", "ydtt", "mdwt", "FDout", "dirt", "fedt", "fdwt", "FDwt", "fdta", "fdout", "fdd", "vdtz", "vdt", "sdT", "sdz", "lft", "vdn", "feedt", "sdt", "dlts", "ldtz", "dlta", "gdc", "sdtt", "FDc", "fdn", "ldtt", "ecdtt", "ldn", "feedta"], "offset": ["next", "phase", "attribute", "part", "enter", "shift", "loc", "attr", "error", "padding", "array", "outer", "optional", "o", "layout", "fp", "trace", "begin", "Offset", "location", "ref", "alias", "enabled", "append", "limit", "entry", "api", "bound", "et", "len", "no", "reset", "pad", "off", "slice", "offer", "skip", "format", "pos", "prefix", "scroll", "position", "exclusive", "slot", "length", "output", "initial", "url", "item", "origin", "start", "layer", "seed", "rot", "style", "align", "range", "address", "set", "online", "addr", "timeout", "pointer", "sync", "index"], "sphb": [" sphr", "sshsb", "sphr", "sphab", "sphad", "pshr", "sshp", "sphar", "sphap", " sppr", "scld", "smphr", "smphsb", "pshb", "pphr", "pphp", "pshp", " sphsb", "pphb", "sphsb", "sppb", "sclb", "sshd", "sclr", "sphp", "sshBs", "pshd", "sphd", "smphBs", " sphBs", "smphb", " sppsb", "sshr", "sppsb", "pphd", " sppb", "sppr", " sppBs", "sclp", "sphBs", "sshb", "sppBs"], "rp": ["nrP", " rper", "RP", "Rper", "rper", "nrp", "rP", " rP", "Rp", "nrper"], "pci_status": ["pci_error", "pci__status", "pci__err", "pci__stat", "pcm_status", "pci_stat", "pcm_err", "pcm_stat", "pcm_error", "pci__error", "pci_err"], "err": ["cache", "cr", "rr", "res", "req", "r", "attr", "error", "fi", "resp", "er", "temp", "ind", "iter", "errors", "len", "Error", "str", " error", "rs", "info", "result", "cb", "proc", "e", "ctr", "progress", "msg"], "buf": ["cache", "buff", "rc", "ptr", "ctx", "temp", "alloc", "tmp", "fp", "ref", "src", "mem", "queue", "buffer", "Buffer", "pad", "fd", "data", "path", "uf", "port", "pool", "block", "cb", "cmd", "bytes", "seq", "br"], "max_msi": ["max_msd", "max_MSi", "max_ssI", "max_MSd", "max_MSii", "max_msI", "max_ssd", "max_ksi", "max_ksd", "max_ksI", "max_msii", "max_ssii", "max_ssi", "max_ksii", "max_MSI"], "max_msix": ["max_mci", "max_ansiz", "max_ansci", "max_mmiz", "max_msiz", "max_ansix", "max_ansi", "max_mmci", "max_msci", "max_mi", "max_mmi", "max_mmix", "max_mix", "max_miz"]}}
{"project": "FFmpeg", "commit_id": "a8d702859b8bd17978fb5d8cb1d6acc363031e80", "target": 1, "func": "static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb)\n\n{\n\n    MLPHeaderInfo mh;\n\n    int substr, ret;\n\n\n\n    if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0)\n\n        return ret;\n\n\n\n    if (mh.group1_bits == 0) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"invalid/unknown bits per sample\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.group2_bits > mh.group1_bits) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Channel group 2 cannot have more bits per sample than group 1.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Channel groups with differing sample rates are not currently supported.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.group1_samplerate == 0) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"invalid/unknown sampling rate\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.group1_samplerate > MAX_SAMPLERATE) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Sampling rate %d is greater than the supported maximum (%d).\\n\",\n\n               mh.group1_samplerate, MAX_SAMPLERATE);\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.access_unit_size > MAX_BLOCKSIZE) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Block size %d is greater than the supported maximum (%d).\\n\",\n\n               mh.access_unit_size, MAX_BLOCKSIZE);\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Block size pow2 %d is greater than the supported maximum (%d).\\n\",\n\n               mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.num_substreams == 0)\n\n        return AVERROR_INVALIDDATA;\n\n    if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"MLP only supports up to 2 substreams.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.num_substreams > MAX_SUBSTREAMS) {\n\n\n                              \"%d substreams (more than the \"\n\n                              \"maximum supported by the decoder)\",\n\n                              mh.num_substreams);\n\n\n\n\n\n    m->access_unit_size      = mh.access_unit_size;\n\n    m->access_unit_size_pow2 = mh.access_unit_size_pow2;\n\n\n\n    m->num_substreams        = mh.num_substreams;\n\n    m->max_decoded_substream = m->num_substreams - 1;\n\n\n\n    m->avctx->sample_rate    = mh.group1_samplerate;\n\n    m->avctx->frame_size     = mh.access_unit_size;\n\n\n\n    m->avctx->bits_per_raw_sample = mh.group1_bits;\n\n    if (mh.group1_bits > 16)\n\n        m->avctx->sample_fmt = AV_SAMPLE_FMT_S32;\n\n    else\n\n        m->avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n\n\n    m->params_valid = 1;\n\n    for (substr = 0; substr < MAX_SUBSTREAMS; substr++)\n\n        m->substream[substr].restart_seen = 0;\n\n\n\n    /* Set the layout for each substream. When there's more than one, the first\n\n     * substream is Stereo. Subsequent substreams' layouts are indicated in the\n\n     * major sync. */\n\n    if (m->avctx->codec_id == AV_CODEC_ID_MLP) {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        m->substream[substr].ch_layout = mh.channel_layout_mlp;\n\n    } else {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        if (mh.num_substreams > 2)\n\n            if (mh.channel_layout_thd_stream2)\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream2;\n\n            else\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream1;\n\n        m->substream[substr].ch_layout = mh.channel_layout_thd_stream1;\n\n\n\n        if (m->avctx->channels<=2 && m->substream[substr].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) {\n\n            av_log(m->avctx, AV_LOG_DEBUG, \"Mono stream with 2 substreams, ignoring 2nd\\n\");\n\n            m->max_decoded_substream = 0;\n\n            if (m->avctx->channels==2)\n\n                m->avctx->channel_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n\n\n    m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20;\n\n\n\n    return 0;\n", "idx": 748, "substitutes": {"m": ["md", "media", "man", "tm", "machine", "mount", "jam", "i", "mod", "im", "ms", "mac", "manager", "r", "mp", "l", "um", "ctx", "pm", "n", "j", "y", "p", "km", "dm", "module", "d", "model", "mr", "vm", "fm", "mm", "k", "v", "am", "rm", "g", "ym", "arm", "wm", "c", "M", "gm", "mn", "mc", "mu", "om", "em", "t", "b", "f", "u", "q", "sm", "e", "message", "bm", "cm", "s", "h"], "gb": ["kb", "kw", "bf", "rb", "ui", "xb", "ctx", "bb", "GB", "bd", "bg", "gc", "ga", "cgi", "gnu", "mb", " bc", "abb", "usb", "gin", "hub", "sb", "rg", "gm", "gram", "gg", "gd", "gy", "gs", "db", "gam", "bc", "Gb", "bm"], "mh": [" mich", "modach", "hhs", "dch", " mkh", " mah", "hz", "gh", "emhs", "modul", "gmH", "emH", "modh", "vh", "mmH", "Mhs", "amach", "dhs", "hv", "dmah", "gmhr", "modelach", "paramh", "amih", "m1", " mch", " m1", "amH", "pmhr", "mz", "mrh", "paramrh", "emh", "mah", "tmph", "mH", "bmh", "amh", "dhr", "amhs", " mhs", "fmh", "mmhr", "fmrh", "bmph", "Mhr", "hah", "ymh", "hsh", "fmch", "dimh", "cmch", "mmph", "dmh", " mph", " mbh", "modah", "msh", "dh", "mbh", "gmh", "dimhs", "gach", " mv", "ymsh", "amhr", "tmrh", "mmsh", "mhr", "mmh", "hih", "dimich", "hh", "vhs", "mkh", "dmrh", "pmh", " mih", " mul", "cmh", " mach", "amz", "dmsh", "mmv", "Mich", "pmH", "vsh", "dimhr", "mch", "tmhr", "vH", "Mbh", "modelh", " mrh", "tmah", "Mach", "mih", "fmhs", "Mrh", "hkh", "mv", " mH", "cmrh", "gmrh", "tmsh", "model1", " msh", "paramach", "fmhr", "Mh", "amph", "emsh", "bmsh", " mz", "tmh", "Mch", "pmrh", "paramhs", "bmhr", "tmv", "gph", "h1", "hach", "mhs", "ymkh", "cmbh", "ymv", "modelhs", "hul", "mach", " mhr", "mph", "amv", "mul", "mich", "ghr"], "substr": ["extstr", "ubstr", "extchar", "subctr", "subchar", " subctr", "subStr", "ubStr", "extctr", "ubctr", " subchar", " subStr", "extStr", "ubchar"], "ret": ["rep", "bf", "val", "let", "fail", "res", "value", "bad", "back", "r", "match", "att", "def", "rc", "rt", "flag", "code", "alt", "ref", "RET", "arr", "det", "gt", "af", "status", "red", "len", "lit", "ut", "success", "rets", "feat", "reply", "mt", "sb", "nt", "reg", "result", "arg", "Ret", "al", "rl", "ft", "cur", "re", "bl", "rem", "bit", "art"]}}
{"project": "FFmpeg", "commit_id": "7e3e653618a59960b4c358e333ba2c0d21929e33", "target": 1, "func": "static AVStream * init_stream(AVFormatContext *s)\n\n{\n\n    BinDemuxContext *bin = s->priv_data;\n\n    AVStream *st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return NULL;\n\n    st->codec->codec_tag   = 0;\n\n    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;\n\n\n\n    if (!bin->width) {\n\n        st->codec->width  = (80<<3);\n\n        st->codec->height = (25<<4);\n\n    }\n\n\n\n    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);\n\n\n\n    /* simulate tty display speed */\n\n    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);\n\n\n\n    return st;\n\n}\n", "idx": 767, "substitutes": {"s": ["S", "i", "sv", "su", "sr", "r", "ts", "ns", "settings", "cs", "si", "is", "n", "ssl", "south", "p", "sed", "src", "sq", "bs", "se", "sn", "sa", "sis", "an", "a", "services", "sie", "ses", "sf", "spec", "c", "sb", "in", "es", "init", "sym", "b", "sg", "f", "os", "parts", "ss", "e", "ls", "sl", "bis", "ds", "xs"], "bin": ["sam", "scan", "base", "bm", "gen", "bon", "bid", "binary", "bb", "cookie", "n", "num", "sid", "lib", "vin", "lin", "bg", "root", "pin", "non", "bs", "dat", "win", "sn", "bn", "ba", "fb", "an", "fen", "gn", "bot", "con", "sa", "ini", "ben", "bi", "nb", "pc", "data", "gin", "bian", "len", "border", "ban", "sb", "inn", "bank", "gb", "di", "plugin", "init", "web", "boot", "db", "b", "bas", "spin", "bc", "net", "bis", "bl", "bit"], "st": ["stri", "fr", "be", "ost", "sw", "cr", "sth", "part", "r", "ste", "inst", "sc", "ts", "l", "sh", "nd", "src", "St", "stab", "d", "sta", "se", "obj", "net", "bs", "stage", "sn", "rest", " est", "sa", "stat", "ld", "ut", "stop", "stream", " St", "est", "str", "ST", "spect", "sp", "ast", "sf", "ust", "td", "sb", "nt", "start", "stan", "stal", "ist", "std", "t", "sd", "sts", "storage", "ft", "cur", "ss", "sl", "sty", "ct", "sk", "bl", "lc", "bt", "fe", "stable"]}}
{"project": "qemu", "commit_id": "e50d7607f1800c9f9c576229c6119e4c82f456d6", "target": 1, "func": "static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num,\n\n                        int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    SheepdogAIOCB *acb;\n\n    int ret;\n\n\n\n    if (bs->growable && sector_num + nb_sectors > bs->total_sectors) {\n\n        ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        bs->total_sectors = sector_num + nb_sectors;\n\n    }\n\n\n\n    acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors);\n\n    acb->aio_done_func = sd_write_done;\n\n    acb->aiocb_type = AIOCB_WRITE_UDATA;\n\n\n\n    ret = sd_co_rw_vector(acb);\n\n    if (ret <= 0) {\n\n        qemu_aio_release(acb);\n\n        return ret;\n\n    }\n\n\n\n    qemu_coroutine_yield();\n\n\n\n    return acb->ret;\n\n}\n", "idx": 781, "substitutes": {"bs": ["banks", "fs", "bc", "las", "base", "BS", "ns", "ts", "cs", "pb", "bb", "bes", "null", "qs", "lib", "bits", "bps", "ins", "obj", "blocks", "bos", "fb", "css", "ps", "ses", "ks", "sb", "iss", "obs", "ob", "bh", "gs", "bytes", "cb", "vs", "db", "b", "os", "bas", "js", "ss", "ls", "bis", "bid", "lb", "ds", "bl", "bu", "s"], "sector_num": [" sector_begin", "sector0begin", "sector0no", "sector_name", "sector_nine", "sector_un", "sector0number", "sector_number", "sectorlexbegin", "section_Num", "section_name", " sector_len", " sector_number", "sector_begin", "section_num", "sector_Num", " sector_nine", "sector_sum", "sectorlexnumber", "sector_no", " sector_name", "sector_len", " sector_no", "section_number", "sectorlexnine", "sectorlexnum", " sector_sum", "sector0num", " sector_un"], "nb_sectors": ["nb_psector", "nb_sections", "nb_secors", "nb_gegments", "nb_sefs", "nb_secrets", "nb_secgments", "nb_segments", "nb_sergments", "nb_trafs", "nb_surlements", "nb_spegments", "nb_pefs", "nb_pectors", "nb_velements", "nb_gections", "nb_serrets", "nb_tractors", "nb_spelements", "nb_tragments", "nb_tralements", "nb_serlements", "nb_pelements", "nb_gector", "nb_vegments", "nb_pecs", "nb_vecs", "nb_veors", "nb_psecs", "nb_pections", "nb_psegments", "nb_sercs", "nb_spectors", "nb_verets", "nb_sector", "nb_serors", "nb_serctors", "nb_vectors", "nb_psectors", "nb_pegments", "nb_surctors", "nb_psections", "nb_surcs", "nb_secctors", "nb_serets", "nb_selements", "nb_surgments", "nb_gecs", "nb_gectors", "nb_spefs", "nb_seors", "nb_secs", "nb_pector"], "qiov": [" qfour", " qicho", "Qfour", "Qroxy", "sqiov", "qfour", " qiop", "qroxy", "questiop", "questicho", " qnox", "qiev", "questiov", "qufour", "qiop", "sqicho", "Qiov", " qroxy", "qicho", "sqiop", "quroxy", "sqiev", "quiov", "questiev", "qnox", "qunox", " qiev", "Qnox"], "acb": ["actbase", "acbs", "ACb", "recbase", "accbar", "ocrb", " acB", "acba", "actp", "incbs", "accB", "iacb", "rcbf", "icb", "incbf", "ACba", " acba", "actbb", "ica", "acbf", "recb", "acbar", " acn", "accn", "acfb", "rcbs", "Acb", " acp", "rcb", "acrb", "accbb", " acsb", "actb", "accp", "incl", " acl", "accb", "Acbb", " acbase", " acbb", "accrb", "acl", "acbb", "recab", "accbase", "ACB", "acn", "iacbase", "ocn", "icbb", "acsb", "icbar", " acbar", "iacfb", "recfb", "acp", "ocb", "acca", "accsb", "rcl", "acbase", "Acrb", "aca", "ocbb", " acab", " acbs", "iacab", "ocsb", "ACsb", "incb", "Acsb", " aca", "accba", "acB", " acfb", "acab", " acbf"], "ret": ["part", "pat", "req", "att", "match", "resp", "alt", "opt", "ref", "orig", "len", "reset", "lit", "ut", "feat", "reply", "info", "arg", "f", "bit", "rep", "let", "res", "_", "sr", "error", "pet", "fit", "html", "rev", "red", "true", "hard", "format", "success", "rets", "data", "nt", "url", "Ret", "ft", "aud", "next", "base", "r", "flag", "code", "active", "rf", "obj", "status", "pub", "ann", "fun", "reg", "ber", "out", "final", "cat", "val", "fail", "value", "back", "def", "rt", "RET", "det", "gc", "gt", "no", "ext", "mt", "result", "db", "rl", "re", "en", "art"]}}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)\n\n{\n\n    static uint32_t bmap[INPUT_BUTTON__MAX] = {\n\n        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),\n\n        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),\n\n        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),\n\n        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),\n\n        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),\n\n    };\n\n    static uint32_t prev_state;\n\n\n\n    if (prev_state != state) {\n\n        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);\n\n        prev_state = state;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,\n\n                             real_screen->w);\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,\n\n                             real_screen->h);\n\n    } else {\n\n        if (guest_cursor) {\n\n            x -= guest_x;\n\n            y -= guest_y;\n\n            guest_x += x;\n\n            guest_y += y;\n\n            dx = x;\n\n            dy = y;\n\n        }\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);\n\n    }\n\n    qemu_input_event_sync();\n\n}\n", "idx": 794, "substitutes": {"dx": ["xxx", "wx", "wd", "dist", "dc", "view", "dd", "diff", "loc", "patch", "ww", "ex", "xx", "rx", "ud", "yx", "d", "z", "down", "w", "xp", "px", "pad", "distance", "prefix", "data", "front", "dn", "xd", "xy", "dt", "start", "ix", "depth", "dh", "phy", "fx", "zx", "max", "push", "fix", "DX", "da", "ady", "xi", "ds", "xs", "step"], "dy": ["hi", "md", "wy", "dist", "dd", "i", "ui", "diff", "ny", "yer", "ey", "j", "lon", "dir", "dl", "sy", "d", "delay", "vy", "z", "yd", "yi", "down", "ds", "dim", "ii", "py", "idy", "zy", "data", "dn", "ry", "xy", "iy", "zi", "direction", "di", "gy", "depth", "eddy", "db", "b", "f", "da", "ady", "ty", "sync", "yy"], "x": ["hi", "xxx", "i", "r", "X", "l", "ex", "n", "height", "xx", "o", "rx", "p", "xc", "d", "m", "yx", "name", "z", "id", "down", "w", "px", "v", "pos", "path", "xy", "c", "ix", "image", "t", "b", "q", "u", "ax", "e", "one", "xi", "h", "xs", "en", "index"], "y": ["wy", "i", "ny", "cy", "yl", "l", "ey", "j", "n", "o", "p", "ky", "sy", "ya", "d", "m", "vy", "z", "yi", "w", "Y", "oy", "py", "zy", "type", "ye", "year", "xy", "ry", "yt", "iy", "ish", "ay", "yan", "ch", "yo", "col", "t", "b", "q", "ady", "sky", "ty", "h", "yy"], "state": ["next", "update", "val", "i", "value", "part", "scale", "error", "private", "active", "j", "code", "st", "p", "up", "key", "new", "sy", "d", "m", "force", "z", "name", "status", "down", "notice", "id", "area", "mode", "event", "states", "type", "parent", "length", "State", "old", "in", "self", "direction", "scope", "start", "ate", "ch", "seed", "style", "b", "f", "err", "none", "version", "range", "set", "resource", "size", "e", "instance", "inner", "STATE", "sync", "step", "index", "rule"], "bmap": ["bbmaps", "bbmap", "cbMAP", "bbMAP", "cbmap", " bmaps", "bbMap", "bMAP", "cMap", "pmap", " bMap", "cMAP", "cmap", "pMap", "cbmaps", "cbMap", " bMAP", "cmaps", "pmaps", "bmaps", "pMAP", "bMap"], "prev_state": ["prevfcall", "prev_connection", "prev___connection", "prevPstatus", "keep_call", "keep_scale", "keepfscale", "keep_state", "prevfscale", " prev_State", " prev_config", "prevPcall", "prevfstate", "prevPscale", "prev_scale", "keep_status", "prevPstate", "keepfcall", " prev_connection", "prev_call", "prev_State", "prev___state", "prevfstatus", " prev_states", "prev___states", "keepfstate", "prev_status", "keepfstatus", "prev_config", "prev_states", " prev_rule", "prev_rule"]}}
{"project": "qemu", "commit_id": "4f2d3d705c1ae7dce29254e2c4645c84e77a74d4", "target": 0, "func": "static void device_initfn(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop;\n\n\n\n    if (qdev_hotplug) {\n\n        dev->hotplugged = 1;\n\n        qdev_hot_added = true;\n\n    }\n\n\n\n    dev->instance_id_alias = -1;\n\n    dev->state = DEV_STATE_CREATED;\n\n\n\n    qdev_prop_set_defaults(dev, qdev_get_props(dev));\n\n    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {\n\n        qdev_property_add_legacy(dev, prop, NULL);\n\n        qdev_property_add_static(dev, prop, NULL);\n\n    }\n\n\n\n    object_property_add_str(OBJECT(dev), \"type\", qdev_get_type, NULL, NULL);\n\n}\n", "idx": 797, "substitutes": {"obj": ["mod", "pkg", "od", "inst", "def", "po", "object", "ctx", "j", "conf", "o", "opt", "tmp", "pt", "node", "module", "api", "pos", "nb", "conn", "data", "coll", "pro", "parent", "ob", "Obj", "proc", "os", "op", "objects", "cmd", "rad", "ops", "ev"], "dev": ["gu", "md", "mod", "dd", "wd", "dc", "diff", "die", "bug", "od", "priv", "error", "device", "def", "de", "private", "enc", "grad", "object", "conf", "gh", "debug", "DEV", "new", "dm", "fo", "d", "var", "adv", "prom", "oy", "conn", "data", "pro", "pred", "development", "td", "Dev", "fw", "app", "self", "dt", "test", "gd", "di", "info", "dem", "sd", "develop", "ver", "ow", "rad", "ev", "prov", "dom", "cd"], "prop": ["dep", "val", "rb", "part", "pr", "attr", "mp", "project", "def", "po", "fi", "ptr", "pb", "object", "cmp", "device", "option", "private", "pl", "j", "opt", "pt", "p", "param", "tmp", "key", "term", "config", "properties", "name", "api", "buf", "property", "lit", "cp", "pos", "prot", "type", "dest", "feat", "data", "owner", "Prop", "pro", "pred", "ps", "pp", "comp", "np", "prev", "target", "info", "jp", "col", "rel", "proc", "feature", "rop", "op", "f", "doc", "ip", "span", "pointer", "priv", "tag", " Prop"]}}
{"project": "qemu", "commit_id": "ef8489d45927a6d35b214365e4b39ab311b48f2a", "target": 1, "func": "static void scsi_write_data(SCSIRequest *req)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    /* The request is used as the AIO opaque value, so add a ref.  */\n\n    scsi_req_ref(&r->req);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n\n        DPRINTF(\"Data transfer direction invalid\\n\");\n\n        scsi_write_complete(r, -EINVAL);\n\n        return;\n\n    }\n\n\n\n    if (!r->req.sg && !r->qiov.size) {\n\n        /* Called for the first time.  Ask the driver to send us more data.  */\n\n        r->started = true;\n\n        scsi_write_complete(r, 0);\n\n        return;\n\n    }\n\n    if (s->tray_open) {\n\n        scsi_write_complete(r, -ENOMEDIUM);\n\n        return;\n\n    }\n\n\n\n    if (r->req.cmd.buf[0] == VERIFY_10 || r->req.cmd.buf[0] == VERIFY_12 ||\n\n        r->req.cmd.buf[0] == VERIFY_16) {\n\n        if (r->req.sg) {\n\n            scsi_dma_complete(r, 0);\n\n        } else {\n\n            scsi_write_complete(r, 0);\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (r->req.sg) {\n\n        dma_acct_start(s->qdev.conf.bs, &r->acct, r->req.sg, BDRV_ACCT_WRITE);\n\n        r->req.resid -= r->req.sg->size;\n\n        r->req.aiocb = dma_bdrv_write(s->qdev.conf.bs, r->req.sg, r->sector,\n\n                                      scsi_dma_complete, r);\n\n    } else {\n\n        n = r->qiov.size / 512;\n\n        bdrv_acct_start(s->qdev.conf.bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n\n        r->req.aiocb = bdrv_aio_writev(s->qdev.conf.bs, r->sector, &r->qiov, n,\n\n                                       scsi_write_complete, r);\n\n    }\n\n}\n", "idx": 837, "substitutes": {"req": ["dep", "required", "rb", "rr", "pkg", "cmp", "grad", "er", "resp", "ref", "key", "ec", "rar", "rw", "jp", "f", "dev", "ctr", "mod", "res", "gr", "sr", "tr", "p", "exec", "sem", "config", "call", "load", "org", "release", "app", "task", "ru", "q", "err", "client", "ev", "fr", "supp", "pr", "comm", "tar", "rx", "requ", "query", "sq", "queue", "rf", "ret", "ro", "pub", "quant", "loader", "conn", "str", "require", "pro", "spec", "reg", "crit", "cmd", "cur", "ver", "e", "progress", "ra", "request", "desc", "ir", "eq", "def", "rt", "low", "module", "input", "id", "urg", "rec", "ext", "cook", "c", "hr", "rs", "dq", "resource", "re", "reader", "seq"], "r": ["rb", "rr", "er", "R", "usr", "nor", "d", "mr", "rar", "rw", "v", "vr", "rd", "ur", "rg", "f", "this", "br", "cr", "gr", "rh", "sr", "l", "tr", "o", "p", "yr", "rev", "per", "nr", "ru", "b", "q", "err", "u", "lr", "h", "fr", "pr", "wr", "rx", "dr", "m", "var", "rf", "w", "str", "g", "ar", "t", "cur", "e", "ra", "request", "user", "ir", "rc", "rt", "j", "or", "k", "kr", "c", "rs", "hr", "self", "result", "rl", "resource", "re", "reader"], "s": ["S", "fs", "sw", "su", "sr", "ns", "settings", "cs", "si", "is", "j", "sec", "uns", "ssl", "y", "qs", "p", "or", "sq", "session", "z", "w", "v", "sys", "service", "g", "str", "sp", "ps", "server", "ses", "spec", "sf", "c", "sb", "ar", "rs", "es", "params", "ser", "gs", "sym", "t", "os", "b", "f", "err", "ss", "js", "e", "sl", "ls", "http", "ds", "sync"], "n": ["i", " N", "nm", "l", "ns", "nan", "un", "j", "num", "o", "y", "p", "number", "nn", "nor", "d", "m", "z", "adj", "sn", "k", "len", "no", "v", "nb", "conn", "g", "ne", "c", "nu", "nr", "pn", "network", "nl", "t", "b", "f", "na", "ni", "N", "out", "e", "x", "net", "size", "h", "not"]}}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)\n\n{\n\n    int sa, sb;\n\n    sa = ((int64_t)*phigh < 0);\n\n    if (sa)\n\n        neg128(plow, phigh);\n\n    sb = (b < 0);\n\n    if (sb)\n\n        b = -b;\n\n    div64(plow, phigh, b);\n\n    if (sa ^ sb)\n\n        *plow = - *plow;\n\n    if (sa)\n\n        *phigh = - *phigh;\n\n}\n", "idx": 848, "substitutes": {"plow": ["flows", "iplOW", " pligh", "oplOW", "pullowe", "fligh", "PlOW", "phay", "ploy", " plrow", "plowe", "low", "play", "iplrow", "iploom", " ploom", "plows", " plows", "flowed", "plOW", "lowed", "pullOW", "pligh", " plOW", "opligh", "oplow", "plowed", "oploom", "Plrow", "pullow", "oploy", "pullowed", "lOW", "phOW", "Plow", " plowed", " plowe", "lowe", "iplowed", "iplow", "phoy", "ploom", "iplows", "flow", " play", "phow", "Plowe", " ploy", "oplay", "oplows", "plrow", "iplowe", "oplowed"], "phigh": ["phaalth", " phiy", "ophight", " phyg", "shigh", "shiz", "ophug", " phigi", "phug", "phaug", "PHiz", " phiz", " phigg", "PHigi", "Phigi", "PHalth", "philogg", "phaogg", " phai", "phaig", "phogg", " phight", "phigg", " phich", "ophalth", "phight", "phayg", "shiy", " phig", "phaigh", "philigh", "philig", "Phai", "PHigg", "phigi", "phig", "phai", "PHai", "PHigh", "PHig", "phyg", "phalth", "ophigh", "phiy", "PHiy", "philich", "phich", "phaich", "shig", "Phalth", "phiz", "Phigh", "phaight", "shigg", " phalth", " phug", "ophyg", " phogg", "ophig"], "b": ["bf", "i", "rb", " bi", "base", "r", "bp", "l", "zb", "pb", "bb", "binary", "n", "y", "p", "ib", "B", "ab", "d", "bs", " db", "w", "bt", "fb", "k", "mb", "v", "beta", "a", "nb", "bi", "bar", "g", "eb", "length", " eb", "c", "body", "gb", "bh", "ob", "db", "f", "pa", "wb", "e", "bl", "bc", "lb", "h", "s"], "sa": ["wa", "SA", "sam", " si", "za", "su", "sc", "ta", "si", "n", "ama", "sh", "p", "sy", "va", "sta", "se", "sq", "ga", "bs", "ma", "ba", "Sa", "sea", "aa", "a", "sie", "pc", "ca", "asu", "sp", "sac", "gb", "ai", "asi", "la", "sd", "as", "asa", "pa", "na", "sg", "da", "au", "ss", "sl", "sk", "s", "so", "isa"], "sb": ["bf", "rb", "sth", "sc", "bp", "zb", "pb", "bb", "si", "sec", "sh", "st", "ib", "src", "ab", "obb", "sq", "bs", "sta", "SB", "sn", "s", "ba", "fb", "mb", "bi", "nb", "a", "eb", "sp", "sf", "gb", "bh", "cb", "sd", "sg", "db", "pa", "wb", "sm", "ss", "sl", "amb", "bc", "lb", "bl", "sk", "bm", "bt"]}}
{"project": "qemu", "commit_id": "1dbfd7892b66c757fdf67f346be40233adbad80e", "target": 1, "func": "void bios_linker_loader_alloc(GArray *linker,\n\n                              const char *file,\n\n                              uint32_t alloc_align,\n\n                              bool alloc_fseg)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n\n\n    assert(!(alloc_align & (alloc_align - 1)));\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);\n\n    entry.alloc.align = cpu_to_le32(alloc_align);\n\n    entry.alloc.zone = cpu_to_le32(alloc_fseg ?\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);\n\n\n\n    /* Alloc entries must come first, so prepend them */\n\n    g_array_prepend_vals(linker, &entry, sizeof entry);\n\n}\n", "idx": 855, "substitutes": {"linker": [" linkner", "linkher", "layor", "layner", "locker", "linkener", "linkger", "layener", "linkner", "layger", "linkor", " linkher", "lockor", "inkner", " linkger", "lockher", "layher", "linkers", "layers", "inkers", "inker", "lockger", "layer", " linkers", "inkener", " linkor", " linkener"], "file": ["field", "model", "line", "feed", "offset", "cache", "value", "base", "loc", "content", "fi", "array", "code", "dir", "fp", "key", "write", "call", "name", "queue", "buffer", "source", "memory", "per", "time", "full", "class", "format", "type", "data", "File", "path", "parent", "port", "pool", "read", "files", "image", "block", "f", "align", "address", "resource", "size", "link", "filename", "ile"], "alloc_align": [" alloc_range", "loc_aligned", " alloc_aligned", "oc_space", "allocfalign", "alloc___aligned", "loc_align", "alloc_role", "allocfign", "alloc__align", "alloc__range", "oc_array", "alloc___balance", "alloc_aligned", "alloc_range", "alloc_array", "alloc_ign", "oc_align", "loc_role", "alloc__aligned", "oc_al", "allocfrange", "allocfaligned", "alloc_balance", " alloc_ign", "alloc__ign", "loc_balance", "oc_aligned", "alloc_space", "alloc___align", "alloc___role", "alloc_al"], "alloc_fseg": ["alloc_fperseg", "alloc_fsege", "alloc_fgeeg", "alloc_fperseG", "alloc_rfgeg", "alloc_fsega", "alloc_fmeeg", "alloc_rfseeg", "alloc_fseig", "alloc_rfseg", "alloc_FgeG", "alloc_fperseig", "alloc_fperseeg", "alloc_fseG", "alloc_fgegs", "alloc_rfgege", "alloc_rfsege", "alloc_fseeg", "alloc_rfgeeg", "alloc_fpersege", "alloc_rfsega", "alloc_fmega", "alloc_fgeig", "alloc_FseG", "alloc_Fgegs", "alloc_fsegs", "alloc_fgega", "alloc_fgege", "alloc_fpersega", "alloc_Fsegs", "alloc_Fgeg", "alloc_fmeg", "alloc_fgeg", "alloc_Fseg", "alloc_Fseig", "alloc_rfgega", "alloc_Fgeig", "alloc_fgeG", "alloc_fmege", "alloc_fpersegs"], "entry": ["enter", "her", "match", "card", "array", "archive", "sec", "zero", "key", "ie", "row", "parent", "plugin", "info", "ner", "image", "inc", "set", "cue", "error", "Entry", "install", "valid", "ger", "se", "per", "org", "data", "add", "ry", "nt", "ent", "lc", "comment", "line", "next", "feed", "way", "r", "ge", "cell", "new", "element", "engine", "loader", "service", "str", "writer", "member", "server", "extra", "e", "try", "index", "cat", "insert", "cache", "scan", "section", "or", "connection", "module", "ga", "ae", "import", "end", "export", "start", "result", "inter", "parse", "inner", "reader", "record", "link"]}}
{"project": "qemu", "commit_id": "95eaa78537c734fa3cb3373d47ba8c0099a36ff0", "target": 1, "func": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    /* We don't actually refresh here, but just return data queried in\n\n     * iscsi_open(): iscsi targets don't change their limits. */\n\n\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;\n\n\n\n    bs->bl.request_alignment = iscsilun->block_size;\n\n\n\n    if (iscsilun->bl.max_xfer_len) {\n\n        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);\n\n    }\n\n\n\n    if (max_xfer_len * iscsilun->block_size < INT_MAX) {\n\n        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->lbp.lbpu) {\n\n        if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) {\n\n            bs->bl.max_pdiscard =\n\n                iscsilun->bl.max_unmap * iscsilun->block_size;\n\n        }\n\n        bs->bl.pdiscard_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pdiscard_alignment = iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {\n\n        bs->bl.max_pwrite_zeroes =\n\n            iscsilun->bl.max_ws_len * iscsilun->block_size;\n\n    }\n\n    if (iscsilun->lbp.lbpws) {\n\n        bs->bl.pwrite_zeroes_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;\n\n    }\n\n    if (iscsilun->bl.opt_xfer_len &&\n\n        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {\n\n        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *\n\n                                        iscsilun->block_size);\n\n    }\n\n}\n", "idx": 860, "substitutes": {"bs": ["bf", "las", "fs", "base", "BS", "ns", "blog", "ts", "cs", "pb", "bb", "bes", "bd", "qs", "ubs", "bits", "bps", "http", "ins", "bing", "blocks", "s", "cks", "lbs", "bos", "fb", "ba", "bot", "ds", "abc", "ros", "bi", "sels", "css", "us", "ks", "sb", "iss", "rs", "obs", "gb", "ob", "outs", "bh", "bytes", "gs", "abi", "cb", "vs", "uss", "bin", "b", "os", "BC", "bas", "ss", "js", "ls", "bl", "bc", "lb", "bis", "bt"], "errp": ["erp", "errP", "erfp", "errr", "rr", " errr", "err", " errP", "rp", "errfp", "rP", " errfp", "erP", "rfp"], "iscsilun": ["iscylltun", "iscilunt", "iscalidunt", "iscillu", "ircilandon", "iscislin", "ircslin", "iscmilunion", "iscvaleune", "iscsluni", "iscillunt", "iscaliduna", "iscsilmun", "soclifun", "iscsiluc", "iscvaleund", "iscslun", "ircielcon", "iscillin", "iscslunt", "uscsluno", "socsilut", "ircsilandon", "uscslu", "iscstatunt", "iscselltun", "iscryptunt", "micielun", "uscsiluc", "iscilun", "iscilund", "usciluna", "iscyllun", "iscilauno", "iscsylvun", "ircsilin", "uscslut", "uscslin", "iscsiluni", "iscsylvken", "iscivalune", "ISCsilu", "iscalidund", "iscilsorn", "iscilianun", "ischetune", "iscielcon", "iscilluno", "iscmilunin", "explryptun", "iscryptut", "iscslune", "iscnilin", "iscsilfun", "isclifun", "isclifken", "iscsiluan", "iscsilune", "iscillut", "ircielunin", "explryptin", "iscslunion", "iscslmun", "iscslgan", "iscielu", "iscmilcon", "iscielan", "iscsilunion", "iscnilun", "uscsluni", "ircsilun", "iscalidun", "ISCsilunin", "uscieluc", "iscrubin", "ircslan", "isconsequunt", "ircsiloren", "explryptunt", "iscstatin", "uscilund", "iscsilban", "ircsilune", "iscselfun", "iscsluan", "iscrubmun", "iscilluan", "iscritund", "iscsylvuna", "iscselluna", "iscivaluna", "uscsilorn", "ischetun", "iscilau", "socsilmun", "socsiltun", "iscselunion", "iscisluna", "ircsluan", "explsiluna", "iscritun", "isculinuna", "iscyllmun", "iscivalan", "iscnilmun", "iscllund", "iscielun", "iscryptun", "uscsiluna", "iscvaleun", "ISCrilun", "iscilianuna", "uscsilgan", "usercsiluna", "isciluna", "uscslun", "iscslunin", "iscstatund", "iscslund", "isclluno", "iscsilut", "iscsilunt", "micsilken", "iscilsuna", "iscislunt", "uscieluna", "uscslunt", "usercsilfun", "isclituan", "isconsequuna", "iscseluna", "iscmilan", "usercsilun", "iscillan", "iscslan", "iscsilin", "ircsilunin", "iscilsun", "iscsilan", "iscilauni", "iscilaun", "iscslin", "iscselmun", "iscalunt", "ircsloren", "uscsiluni", "iscilianund", "iscsilken", "iscslu", "micieluna", "uscsilunt", "ircslunin", "usercslun", "usciluan", "iscvaleunt", "uscielun", "iscillun", "uscsilut", "isclitun", "iscstatuna", "soclifmun", "uscslund", "ircslmun", "ircslunt", "iscllun", "iscsellun", "iscrituna", "iscsellunt", "isculinunt", "uscsilund", "isculinut", "iscslban", "iscrilu", "isclifmun", "ircielun", "iscslandon", "iscrubun", "iscselin", "iscsellut", "iscmilun", "iscSilun", "iscrilken", "iscliftun", "iscsiluna", "irciluna", "isculinuni", "isclituno", "ircsilan", "iscchalut", "explsilun", "iscladut", "iscillorn", "iscvaleuna", "micsilunin", "iscryptin", "isculinban", "iscalun", "iscillune", "isconsequune", "iscsiloren", "isculinun", "socsilun", "iscselun", "iscilaunin", "iscsilcon", "ircsilut", "ischetunt", "iscilaandon", "iscSiluna", "explsilunt", "iscilsuc", "iscogluna", "micsiluna", "iscmiluan", "uscsilu", "iscielken", "iscislun", "uscsilin", "isciluno", "micielken", "iscilluc", "soclifut", "isclifut", "ircsiluno", "ircilun", "uscsiluan", "ircsiluna", "uscslgan", "ircsilmun", "iscilluna", "uscsluna", "iscSiluan", "iscsellmun", "iscrubuna", "iscillund", "iscilaund", "ircsluno", "isconsequun", "iscalgan", "iscchalun", "socliftun", "ircslut", "uscsilune", "iscryptuna", "iscsylvunin", "iscladuna", "iscislund", "ISCrilu", "iscilandon", "iscyllut", "iscieluna", "iscladun", "iscillcon", "iscilloren", "micielunin", "iscivalunt", "uscsluan", "iscillunin", "iscniluna", "ISCsilun", "iscaluna", "uscielorn", "micsilun", "ircielan", "isciluan", "isclluna", "iscmilfun", "ircsiluan", "iscSiluno", "iscivalut", "iscilauna", "isclitunin", "isclifu", "ISCrilunin", "iscstatun", "uscsilun", "explryptuna", "ISCsilken", "usercsluna", "ischetuna", "iscilaban", "iscilianunt", "iscsilgan", "ircsilunt", "iscladune", "iscslut", "ircslund", "iscsiltun", "iscrilunin", "usercsilunion", "iscsluna", "iscsilunin", "ircsilcon", "iscchaluna", "iscrilun", "uscilunt", "iscsellune", "ircsluna", "iscslfun", "iscivalun", "iscsilu", "iscilaoren", "iscsilandon", "usercslunion", "iscoglmun", "iscoglin", "ircslun", "iscoglun", "ISCrilken", "ircslune", "usercslfun", "iscmilin", "iscsiluno", "uscslban", "explsilin", "iscielunin", "iscchalune", "iscilu", "iscielorn", "uscsilban", "iscmiluna", "ircsilu", "uscilun", "iscislgan", "iscsluno", "uscsiluno", "iscrituno", "ircsilund", "iscsilund", "isclituna", "isclitu", "iscsloren", "iscsilorn", "isclifunin", "usciluno", "ircilu", "iscieluc"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void tap_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    TAPState *s = opaque;\n\n    int ret;\n\n    for(;;) {\n\n        ret = write(s->fd, buf, size);\n\n        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 883, "substitutes": {"opaque": ["opaca", "ropca", "opca", " opaca", "operque", "opatile", "copacity", "opsca", "opque", " opque", "ropacity", " opatile", "copque", "operacity", "opsacity", " opacity", "ropaque", "ropaca", "opacity", "copatile", "operatile", " opca", "opsaque", "copaque", "opsaca", "operaque"], "buf": ["buff", "context", "pb", "ctx", "code", "null", "alloc", "fp", "ref", "src", " buffer", "config", "queue", "buffer", "Buffer", "vec", "cv", "fd", "data", "window", "batch", "uf", "output", "port", "bag", "pool", "map", "gb", "cb", "cap", "db", "b", "cmd", "bc", "msg", "seq"], "size": ["offset", "six", "loc", "en", "enc", "code", "unit", "sec", "n", "num", "name", "z", "send", "fee", "capacity", "len", "esc", "data", "g", "length", "ize", "c", "small", "large", "max", "storage", "address", "out", "empty", "iz", "timeout", "SIZE", "Size"], "s": ["S", "fs", "socket", "secure", "ns", "si", "n", "conf", "ssl", "o", "sec", "p", "m", "sq", "w", "sa", "sys", "sie", "service", "submit", "ses", "sf", "sb", "c", "spec", "secondary", "scope", "gs", "sym", "sg", "f", "storage", "ss", "e", "sl", "ls", "ops", "ds", "sync"], "ret": ["bf", "val", "rb", "res", " RET", "r", "sr", "error", "att", "rc", "rt", "code", "flag", "num", "resp", "alt", "RET", "ref", "number", "det", "usr", "fat", "rev", "id", "iter", "obj", "len", "no", "count", "Len", "lit", "success", "rets", "reply", "ror", "fun", "nt", "xt", "reg", "result", "Ret", "t", "rl", "ft", "out", "re", "bit", "art"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_disk_realize(SCSIDevice *dev, Error **errp)\n\n{\n\n    DriveInfo *dinfo;\n\n    Error *local_err = NULL;\n\n\n\n    if (!dev->conf.bs) {\n\n        scsi_realize(dev, &local_err);\n\n        assert(local_err);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    dinfo = drive_get_by_blockdev(dev->conf.bs);\n\n    if (dinfo->media_cd) {\n\n        scsi_cd_realize(dev, errp);\n\n    } else {\n\n        scsi_hd_realize(dev, errp);\n\n    }\n\n}\n", "idx": 886, "substitutes": {"dev": ["driver", "user", "gu", "serial", "comment", "cache", "dc", "nov", "mod", "diff", "die", "bug", "req", "od", "priv", "error", "device", "def", "fi", "google", "disk", "de", "conf", "temp", "debug", "valid", "p", "d", "var", "cam", "obj", "ga", "api", "w", "pub", "ad", "vol", "bus", "end", "conn", "data", "dn", "development", "spec", "Dev", "app", "self", "gd", "di", "prof", "info", "ch", "block", "dem", "sd", "err", "ver", "ow", "rad", "client", "ev", "hw", "dom"], "errp": ["rrr", "errr", "barpc", "resultpe", "Erp", "errorP", "rrpc", "errpr", "verP", "airc", "erproc", "errorproc", "erP", "errfp", "airpe", "errpe", "errP", "errlp", "erfp", "rrfp", "Erpr", "ErP", " errlp", "rrlp", "resultp", "resultlp", "errpc", "verpc", "airlp", "rrproc", "verpr", "erp", "rrP", "errc", " errpc", " errc", "errorpr", "errorfp", "resultc", "airp", "errorpc", "barr", "barlp", "errproc", " errpe", " errr", "Erpc", "errorp", "verp", "rrp", "barp"], "dinfo": ["dbi", "bdfo", "dlink", "vdfo", "dlfo", "dldata", "DInfo", "vdinfo", " dinf", "hdinfo", "Dinf", "hdcheck", " dbi", "ldfo", "dInfo", " dInfo", "hdbi", "dlinfo", "dcheck", " dfo", "Dinfo", "dllink", "dlcheck", "Dfo", "dinf", "vddata", "dfo", "ldInfo", "vdlink", "bddata", " dcheck", "bdinfo", "ldinfo", "hdinf", "dlinf", "ddata", "ldinf", "dlbi", "bdlink"], "local_err": [" local_temp", "remote_str", "remote_err", " local_result", "localIPerr", "localJerr", "localFerr", " local_error", " local_errors", "localIPerror", "localFtemp", "local_temp", "local_er", "local_str", "localFer", "local_errors", "localJtemp", "localIPresult", "local_result", " local_er", "localJer", "local_error", "localFerrors", "localJerrors", "remote_error"]}}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    int ret, fd;\n\n    uint32_t new_vid;\n\n    SheepdogInode *inode;\n\n    unsigned int datalen;\n\n\n\n    dprintf(\"sn_info: name %s id_str %s s: name %s vm_state_size %\" PRId64 \" \"\n\n            \"is_snapshot %d\\n\", sn_info->name, sn_info->id_str,\n\n            s->name, sn_info->vm_state_size, s->is_snapshot);\n\n\n\n    if (s->is_snapshot) {\n\n        error_report(\"You can't create a snapshot of a snapshot VDI, \"\n\n                     \"%s (%\" PRIu32 \").\", s->name, s->inode.vdi_id);\n\n\n\n        return -EINVAL;\n\n    }\n\n\n\n    dprintf(\"%s %s\\n\", sn_info->name, sn_info->id_str);\n\n\n\n    s->inode.vm_state_size = sn_info->vm_state_size;\n\n    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;\n\n    /* It appears that inode.tag does not require a NUL terminator,\n\n     * which means this use of strncpy is ok.\n\n     */\n\n    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));\n\n    /* we don't need to update entire object */\n\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n\n\n\n    /* refresh inode. */\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        ret = fd;\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n\n    if (ret < 0) {\n\n        error_report(\"failed to write snapshot's inode.\");\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,\n\n                       s->addr, s->port);\n\n    if (ret < 0) {\n\n        error_report(\"failed to create inode for snapshot. %s\",\n\n                     strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    inode = (SheepdogInode *)g_malloc(datalen);\n\n\n\n    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),\n\n                      s->inode.nr_copies, datalen, 0, s->cache_enabled);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"failed to read new inode info. %s\", strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    memcpy(&s->inode, inode, datalen);\n\n    dprintf(\"s->inode: name %s snap_id %x oid %x\\n\",\n\n            s->inode.name, s->inode.snap_id, s->inode.vdi_id);\n\n\n\ncleanup:\n\n    closesocket(fd);\n\n    return ret;\n\n}\n", "idx": 899, "substitutes": {"bs": ["fs", "ms", "BS", "ns", "ts", "bid", "cs", "pb", "bb", "ssl", "qs", "ins", "bt", "sa", "bos", "bi", "ps", "ses", "sb", "iss", "rs", "obs", "gb", "bh", "gs", "vs", "b", "os", "as", "aws", "bas", "ss", "js", "ls", "bc", "lb", "ds"], "sn_info": ["sn_id", "syn_source", "sn7def", "sameopt", "s_opt", "sn_family", " sn8info", "sn_service", "snameconfig", "sn_off", "sn_iso", "snACinfo", "snacinfo", "sn5init", "sn_source", "serv_inf", "snappinf", "snamconfig", "sl_Info", "knaciso", "sn7Info", "snACiso", "serv_information", "snallinf", "knacINFO", "sn5family", " sn8diff", "snaminfo", "s_source", "serv_config", "sn7info", "sn_inf", "ns_info", "syn_service", " sn8Info", "sn_fo", "sn_Info", "snaminformation", "samesource", " sn_fo", "ns_family", "servaminformation", "ns_inf", "sn8Info", "sn_config", "kn_iso", "knacinfo", "syn_off", "syn_info", "sn_opt", "snappinfo", "kn_Info", "snameopt", "kn_info", " sn_inf", "syn_inf", "knacInfo", "snACInfo", "sn5inf", "sn8source", "snallinfo", "snallfamily", "snameinfo", "sl_info", "nsallfamily", "sn_INFO", "sn7ami", "snallinit", " sn_Info", "s_info", "nsallinit", "sn_def", "sn_init", "snamesource", "syn_Info", "snappoff", "sl_ami", "nsallinfo", "sl_def", "sn_ami", "servaminfo", "sn_diff", "kn_INFO", "snaminf", "snameinf", " sn8inf", "ns_init", "nsallinf", "sameinfo", "sn8opt", "snacINFO", "sn_information", "servaminf", "servamconfig", "snACINFO", " sn_id", "sn8inf", "sn5info", "snappsource", "sn8diff", "snameinformation", "snamservice", "sn8info", "snaciso", "snacInfo", "snamInfo", " sn_diff", "serv_info"], "s": ["i", "uns", "conf", "d", "sum", "sn", "sa", "sis", "v", "states", "ps", "secondary", "sb", "results", "info", "sym", "state", "as", "f", "js", "params", "sv", "l", "sites", "is", "si", "qs", "o", "y", "p", "ins", "details", "stats", "ses", "site", "args", "b", "sg", "ops", "sync", "h", "S", "uses", "r", "settings", "cs", "ssl", "m", "session", "sq", "w", "full", "service", "g", "us", "server", "spec", "ks", "es", "gs", "t", "ss", "e", "sl", "ls", "ds", "xs", "request", "fs", "ms", "su", "sets", "ts", "ns", "n", "services", "a", "sys", "sf", "c", "rs", "in", "self", "its"], "ret": ["cat", "bf", "val", "rb", "let", "res", "part", "base", "back", "att", "def", "rc", "fi", "pet", "rt", "flag", " Ret", "num", "resp", "hash", "alt", "opt", "valid", "pt", "fin", "RET", "ref", "arr", "det", "gt", "fat", "af", "rev", "id", "et", "len", "lit", "format", "success", "conn", "rets", "feat", "str", "data", "reply", "mt", "nb", "ror", "fun", "nt", "reg", "info", "result", "arg", "Ret", "db", "rl", "ft", "sat", "re", "pass", "ct", "bit", "art"], "fd": ["fn", "md", "bf", "dd", "FD", "wd", "dc", "rb", "fs", "feed", " fid", "flo", "cond", "cf", "fc", "fi", "bb", "resp", "dl", "alt", "bd", "dir", "fp", "exec", "fin", "nd", "fl", "ff", "d", "fat", "ln", "fee", "buf", "ad", "fb", "dy", "ld", "df", "handler", "wat", "fm", "conn", "func", "dn", "td", "fun", "dt", "gd", "fa", "draft", "cb", "fx", "hd", "db", "cd", "f", "ft", "raf", "lf", "fe"], "new_vid": [" new_addr", "newApid", "newtpin", "new_uid", "new_virt", "new_pid", "newtvid", "old_sid", " new_pid", "newnewsid", "newnewuid", "new_sid", "newAvirt", "newnewpin", "new_addr", "newtuid", "old_vid", "newAvid", "newAaddr", "newnewvid", " new_virt", "old_pin", "old_uid", "newtsid", "new_pin"], "inode": [" inova", "INovo", "inote", "Inore", " inodi", "dinoder", "nODE", "INome", "Inade", "innnode", "inova", "INade", "arinole", "ninode", "InODE", "gnoe", "incnode", "INode", "Inote", "inonymous", "rinole", "linote", "arinovo", "inoder", "rinode", "Inole", "riname", " inonymous", "dinode", "Inoder", "incoe", "rinoding", " inODE", " inoe", "inome", "node", "axore", "linade", "INote", "inade", "Innode", "INoder", "axade", "dinova", "inoding", "innade", "INore", " inole", "Inodi", "nube", "dinute", "inhole", "inube", "ginoder", "ninoder", "innODE", "inODE", "innhole", "innome", "innoe", "ancoding", "inoe", " inube", "rinoder", "inovo", "ginODE", "rinoe", "vinoder", "Inode", "gnonymous", "Inoding", "INODE", "innoder", "ginode", "innode", "ninODE", "axode", "inute", "infode", " inute", "INole", " inade", "ninade", "gnoder", "infoding", "ancole", "inore", " inhole", "incode", "infoder", "arinode", "INoding", "inname", "INube", "ancode", " inome", " inoder", "linoding", "Iname", "inole", "ninole", " iname", "arinoder", "ninovo", "vinova", "incoder", "ancodi", "ginade", "gnode", "linode", "innonymous", "vinute", " inoding", "infame", "INhole", "axoding", "iname", "inodi", "Inoe", "innole", "vinode", "noder"], "datalen": ["dalon", "davalener", "dalledeno", "davalEN", " dalsten", " datalsten", " datalEN", "dalisten", "dalEN", "Datalent", "daclender", "dalener", "Daleno", "datalener", "dalleden", " dalen", "dalledent", "datalens", "datalon", "Dalon", "dalistener", "datalent", "dallen", "datalEN", "Dalen", "Datalon", "dalen", " dalEN", "duledens", "Datalender", "dataleno", "datalender", "dalistEN", "duleden", "dalsten", "daleno", "dallEN", "dalens", "duledsten", " dalens", "DatalEN", "Datalener", "dstaleno", " datalens", "dalender", "dalent", "daliston", "Datalen", "daclen", "Dalener", "duledEN", "dallens", "davalen", "datalsten", "dstalent", "dallsten", "dstalEN", "daclon", "DalEN", "Dalender", "daclEN", "davalender", "Dalent", "daclener", "Dataleno", "dalledEN", "dstalen"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static int vnc_display_listen(VncDisplay *vd,\n\n                              SocketAddress **saddr,\n\n                              size_t nsaddr,\n\n                              SocketAddress **wsaddr,\n\n                              size_t nwsaddr,\n\n                              Error **errp)\n\n{\n\n    size_t i;\n\n\n\n    for (i = 0; i < nsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, saddr[i],\n\n                                    \"vnc-listen\",\n\n                                    &vd->lsock,\n\n                                    &vd->lsock_tag,\n\n                                    &vd->nlsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n    for (i = 0; i < nwsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, wsaddr[i],\n\n                                    \"vnc-ws-listen\",\n\n                                    &vd->lwebsock,\n\n                                    &vd->lwebsock_tag,\n\n                                    &vd->nlwebsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 906, "substitutes": {"vd": ["md", "dd", "wd", "dc", "vt", "od", "sv", "vid", "bd", "dl", "ve", "vc", "adh", "pd", "nd", "ud", "adr", "va", "d", "ov", "ed", "ld", "df", "v", "vr", "rd", "fd", "data", "dn", "xd", "td", "dt", "lv", "uds", "gd", "di", "nv", "std", "hd", "vs", "sd", "cd", "dev", "VD", "ds", "vv"], "saddr": ["sesaddr", "nsadd", "ssaddress", "dshost", "sesaddress", "ssaddr", "dsaddr", "sadd", "nshost", "saddress", "ssmd", "wsmd", "ssock", "sock", "dsaddress", "seshost", "dsock", "wsock", "wsaddress", "nsaddress", "dsadd", "smd", "sesadd", "dsmd", "shost"], "nsaddr": ["netsaddr", "NSaddress", "spad", "ainsAddress", "netspad", "vsaddress", "vspad", "nspad", "NSaddr", "nshost", "ainshost", "vsaddr", "saddress", "ainsaddr", "lsAddress", "netsaddress", "NShost", "nsAddress", "NSAddress", "lsaddress", "nsaddress", "ainsaddress", "lshost", "lsaddr"], "wsaddr": ["nwrc", "nwaddress", "wsrc", "wcall", "awsaddr", "awsaddress", "wscall", "lscall", "lsrt", "lsrc", "nwaddr", "nwock", "wrt", "awsrc", "WSaddress", "awsock", "WSrt", "WScall", "lsaddress", "WSaddr", "wsock", "wsrt", "waddr", "wsaddress", "waddress", "lsock", "lsaddr"], "nwsaddr": ["nwsalt", "nwwmd", "nhwock", "nwsmd", "nmsaddr", "nwaddress", "nwsock", "nnwaddr", "Nwsaddress", "nwsad", "nmsock", "nnwsaddress", "Nhwaddress", "Nwsock", "Nwsad", "nnwsalt", "nwpaddress", "nmsaddress", "nnwmd", "nnwsaddr", "nhwaddr", "nwpad", "nwwaddress", "nwpock", "nwsaddress", "Nhwad", "nwaddr", "nhwad", "nawsaddress", "nawsmd", "Nhwaddr", "nwwaddr", "nwwalt", "Nwsaddr", "nmsad", "nwmd", "nnwaddress", "nawsalt", "nwpaddr", "nnwalt", "nnwsmd", "Nhwock", "nwalt", "nawsaddr", "nhwaddress"], "errp": ["acerpa", "ernp", "errpre", "angersp", "erq", "Erp", "corp", "rrpc", "erP", "errpe", "errP", "errlp", "acerpre", "Erpe", "cornp", "arglp", "corP", " errlp", "angerpe", " errpre", "errpc", "angerpc", "errnp", "errq", "erp", "acerp", " errP", "argpre", "rrpe", "rrsp", " errq", "errsp", " errnp", "acerlp", "argpa", " errpa", "errpa", "Ersp", "Erpc", "angerp", "rrp", "argp", "corq"], "i": ["hi", "ui", "io", "l", "fi", "si", "is", "j", "uri", "o", "y", "p", "ci", "key", "multi", "qi", "eni", "d", "m", "oi", "name", "id", "mi", "yi", "ri", "ini", "ii", "slice", "v", "a", "bi", "x", "li", "iu", "ie", "c", "in", "di", "ix", "ai", "info", "abi", "pi", "mu", "b", "f", "u", "gi", "ti", "ei", "ni", "e", "xi", "I", "phi", "h", "lc", "s", "index"]}}
{"project": "qemu", "commit_id": "1171ae9a5b132dc631728ff17688d05ed4534181", "target": 0, "func": "static char *enumerate_cpus(unsigned long *cpus, int max_cpus)\n\n{\n\n    int cpu;\n\n    bool first = true;\n\n    GString *s = g_string_new(NULL);\n\n\n\n    for (cpu = find_first_bit(cpus, max_cpus);\n\n        cpu < max_cpus;\n\n        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {\n\n        g_string_append_printf(s, \"%s%d\", first ? \"\" : \" \", cpu);\n\n        first = false;\n\n    }\n\n    return g_string_free(s, FALSE);\n\n}\n", "idx": 913, "substitutes": {"cpus": ["ppores", "pcus", "cpacs", "pcacs", "cpuul", "cpuus", "cpores", "ctxores", "cpul", " cpis", " cppu", "ppis", "gpis", " cpio", "cpuis", "cpio", "pppu", "ctxpu", "gpuses", "ppus", "cpuses", "pcul", "ctxis", "pcis", "cppu", "cpis", " cpacs", " cpores", "ctxus", " cpul", "cpuacs", "gpus", "gpio", "pcuses", "pcio", " cpuses"], "max_cpus": ["max_gputes", "max_cpos", "max_gpos", "max_execores", "max_cputes", "max_cpuores", "max_pcos", "max_cpuuses", "max_cps", "max_cpuos", "max_executes", "max_pores", "max_dcos", "max_pcores", "max_gpums", "max_cpuus", "max_execaus", "max_pcs", "max_cpuses", "max_gpis", "max_execos", "max_cpores", "max_dcus", "max_cpaus", "max_compums", "max_dcaus", "max_gps", "max_dcutes", "max_cpums", "max_ps", "max_execuses", "max_puses", "max_pcus", "max_pums", "max_compus", "max_gpus", "max_pos", "max_gpores", "max_compis", "max_gpaus", "max_execs", "max_pus", "max_compos", "max_execus", "max_pis", "max_cpis"], "cpu": ["clock", "loop", "cu", "cache", "lu", "pai", "fc", "cmp", "fps", "uu", "unit", "linux", "core", "uca", "pixel", "fork", "gc", "node", "piece", " CPU", "thread", "pid", "queue", "net", "vm", "currency", "winner", "capacity", "platform", "cp", "GPU", "gpu", "conn", "pc", "foo", "prefix", "roc", "bench", "consumer", "loader", "css", "python", "c", "pool", "nc", "current", "np", "auc", "pu", "boot", "process", "cap", "performance", "proc", "nic", "CPU", "component", "lb", "processor", "pointer", "lc"], "s": ["S", "fs", "su", "sv", "r", "sync", "ts", "ns", "si", "is", "n", "ssl", "o", "p", "d", "m", "session", "sq", "w", "ruby", "v", "python", "sys", "str", "ps", "ses", "sf", "sb", "c", "rs", "es", "gs", "sym", "t", "b", "f", "os", "sg", "aws", "strings", "ss", "js", "e", "sl", "ls", "ops", "ds", "h"]}}
{"project": "qemu", "commit_id": "8ad9fa5d8be7fd04e723020088eca664971eb363", "target": 1, "func": "MigrationState *exec_start_outgoing_migration(const char *command,\n\n                                             int64_t bandwidth_limit,\n\n                                             int async)\n\n{\n\n    FdMigrationState *s;\n\n    FILE *f;\n\n\n\n    s = qemu_mallocz(sizeof(*s));\n\n    if (s == NULL) {\n\n        dprintf(\"Unable to allocate FdMigrationState\\n\");\n\n        goto err;\n\n    }\n\n\n\n    f = popen(command, \"w\");\n\n    if (f == NULL) {\n\n        dprintf(\"Unable to popen exec target\\n\");\n\n        goto err_after_alloc;\n\n    }\n\n\n\n    s->fd = fileno(f);\n\n    if (s->fd == -1) {\n\n        dprintf(\"Unable to retrieve file descriptor for popen'd handle\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) {\n\n        dprintf(\"Unable to set nonblocking mode on file descriptor\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    s->opaque = qemu_popen(f, \"w\");\n\n\n\n\n    s->get_error = file_errno;\n\n    s->write = file_write;\n\n    s->mig_state.cancel = migrate_fd_cancel;\n\n    s->mig_state.get_status = migrate_fd_get_status;\n\n    s->mig_state.release = migrate_fd_release;\n\n\n\n    s->state = MIG_STATE_ACTIVE;\n\n    s->detach = !async;\n\n    s->bandwidth_limit = bandwidth_limit;\n\n\n\n    if (s->detach == 1) {\n\n        dprintf(\"detaching from monitor\\n\");\n\n        monitor_suspend();\n\n        s->detach = 2;\n\n    }\n\n\n\n    migrate_fd_connect(s);\n\n    return &s->mig_state;\n\n\n\nerr_after_open:\n\n    pclose(f);\n\nerr_after_alloc:\n\n    qemu_free(s);\n\nerr:\n\n    return NULL;\n\n}", "idx": 921, "substitutes": {"command": ["menu", "attribute", "database", "password", "comm", "array", "function", "filename", "Command", "operation", "exec", "p", "connection", "input", "m", "config", "queue", "sequence", "name", "buffer", "method", "handler", "mode", "prefix", "file", "service", "data", "package", "c", "sudo", "start", "execute", "usage", "channel", "cmd", "address", "directory", "message", "path", "request"], "bandwidth_limit": ["bandwidth_block", "bandworking_limit", "bandwidth_log", "bandwidthlimitblock", "bandweight_log", "bandwidthlimitlimit", "bandwidth_level", "bandwidth_lock", "bandworking_block", "bandweight_lock", "bandwidthlimitlock", "bandweight_limit", "bandworking_lock", "bandwidth_lim", "bandweight_block", "bandweight_level", "bandworking_lim", "bandwidthlimitlog"], "async": ["assyn", "assnc", "nasynchron", " asyn", "nassync", " asynchron", "assynchronous", " assync", "Assync", "Asynchronous", "asyn", " asnc", " Asynchronous", " Asyn", "nasynchronous", "asynchron", " Async", " asynchronous", "assync", "asnc", "nasync", " Asnc", "Asynchron", "Async", "asynchronous"], "s": ["i", "uns", "conf", "d", "sis", "v", "states", "ps", "sp", "sb", "info", "sym", "state", "os", "js", "l", "is", "si", "o", "qs", "y", "p", "ins", "se", "stats", "data", "ses", "site", "args", "b", "sg", "ops", "sup", "plugins", "sync", "S", "r", "settings", "cs", "ssl", "south", "new", "m", "sq", "session", "status", "w", "full", "service", "g", "your", "us", "server", "spec", "es", "gs", "t", "native", "aws", "ss", "e", "sl", "ls", "ds", "fs", "ms", "socket", "su", "sets", "ts", "ns", "j", "n", "services", "a", "sys", "sf", "c", "rs", "its", "x", "client"], "f": ["fn", "fr", "bf", "i", "fs", "r", "cf", "l", "fc", "fi", "fu", "o", "fp", "p", "fo", "ff", "d", "m", "tf", "af", "rf", "w", "fb", "fen", "df", "v", "fd", "file", "g", "sf", "fw", "c", "fa", "fed", "lf", "fx", "t", "u", "b", "e", "F", "fe", "h"]}}
{"project": "qemu", "commit_id": "a9f8ad8f2acdb2398da5d32a5efc19cb0196d79f", "target": 1, "func": "static void register_core_rtas(void)\n\n{\n\n    spapr_rtas_register(\"display-character\", rtas_display_character);\n\n    spapr_rtas_register(\"get-time-of-day\", rtas_get_time_of_day);\n\n    spapr_rtas_register(\"power-off\", rtas_power_off);\n\n\n\n\n}", "idx": 924, "substitutes": {}}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,\n\n                              target_ulong opcode, target_ulong *args)\n\n{\n\n    target_ulong liobn = args[0];\n\n    target_ulong ioba = args[1];\n\n    target_ulong tce = args[2];\n\n    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);\n\n    VIOsPAPR_RTCE *rtce;\n\n\n\n    if (!dev) {\n\n        hcall_dprintf(\"LIOBN 0x\" TARGET_FMT_lx \" does not exist\\n\", liobn);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);\n\n\n\n#ifdef DEBUG_TCE\n\n    fprintf(stderr, \"spapr_vio_put_tce on %s  ioba 0x\" TARGET_FMT_lx\n\n            \"  TCE 0x\" TARGET_FMT_lx \"\\n\", dev->qdev.id, ioba, tce);\n\n#endif\n\n\n\n    if (ioba >= dev->rtce_window_size) {\n\n        hcall_dprintf(\"Out-of-bounds IOBA 0x\" TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);\n\n    rtce->tce = tce;\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 937, "substitutes": {"env": ["inst", "enc", "conf", "eu", "opt", "impl", "ec", "viron", "obj", "ext", "dest", "txt", "ev", "visor", "eng", "ef", "exc", "proc", "dict", "err", "estate", "emb", "environment", "iv", "cfg", "priv", "en"], "spapr": ["Spapsro", "spapri", "Spapr", "spaprar", "spAPr", "mpapr", "mpapR", "SpapR", "spapeR", "mprapri", "mpraprar", "Spaprs", "spapsR", "spepr", "spaperar", "spapsrs", "spaprs", "spapsr", "spapsro", "mprapR", "spepR", "mpaprar", "Spapro", "spepri", "Spapsrs", "spAPR", "spapR", "sprapri", "mprapr", "sprapR", "spaperi", "speprar", "spAPrs", "Spapsr", "spaper", "SpapsR", "spapro", "sprapr", "spraprs", "spAPro", "sprapro", "spraprar", "mpapri"], "opcode": ["mpbe", "ipbe", "opcodes", "epcodes", "epbe", "ipcode", "mpbar", "epbar", "opbe", "mpcodes", "ipbar", "epcode", "opbar", "ipcodes", "mpcode"], "args": ["host", "ports", " arguments", "flags", "ms", "same", "bug", "ex", "enc", "array", "function", "seconds", "ims", "Arg", "p", "Args", "lang", "ras", "fields", "ins", "config", "names", "call", "words", "members", "w", "ages", "event", "py", "stats", "missing", "data", "arms", "apps", "lines", "argument", "fun", "keys", "self", "ams", "gs", "options", "arg", "vs", "parts", "objects", "fires", "limits", "as", "aws", "strings", "extra", "parse", "empty", "atts", "use", "params"], "dev": ["gu", "md", "mod", "serial", "dist", "dd", "driver", "comment", "dc", "cache", "diff", "die", "bug", "inst", "des", "error", "def", "device", "de", "private", "conf", "host", "sh", "debug", "valid", "DEV", "p", "mem", "dm", "root", "d", "var", "obj", "w", "pub", "adv", "ad", "user", "rec", "v", "conn", "data", "ev", "development", "Dev", "app", "nt", "gd", "di", "prof", "info", "ch", "block", "dem", "sd", "develop", "ver", "rad", "client", "priv", "dom"], "rtce": ["ctce", "gtfe", "ttge", "RTCE", "gtCE", "tcel", "ttcel", "tge", "RTce", "rtco", "ctCE", "tce", "ctcel", "RTge", "tCE", "tco", "rotce", "ttced", "rtge", "ttco", "gtse", "rtced", "ctced", "gtce", "RTse", "rtcel", "rotfe", "rtfe", "tced", "rotse", "RTfe", "ttce", "rtse", "ttCE", "RTco", "rotCE", "rtCE"]}}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,\n\n                                  const char *name, Error **errp)\n\n{\n\n    NvmeCtrl *s = NVME(obj);\n\n\n\n    visit_type_int32(v, &s->conf.bootindex, name, errp);\n\n}\n", "idx": 941, "substitutes": {"obj": ["xxx", "val", "rb", "po", "object", "orb", "ctx", "j", "n", "conv", "o", "otype", "code", "p", "tmp", "opt", "bo", "act", "obb", "api", "org", "office", "c", "sb", "self", "oid", "ob", "cb", "Obj", "t", "objects", "os", "op", "b", "env", "iv", "x", "e", "Object", "ev", "so"], "v": ["uv", "vim", "i", "vt", "sv", "inv", "l", "object", "j", "conv", "o", "ve", "p", "d", "m", "ov", "V", "z", "api", "w", "vm", "k", "tv", "c", "lv", "vp", "vs", "t", "b", "f", "u", "e", "env", "iv", "x", "ev", "vv"], "opaque": ["posaque", "opac", "OPatile", "otac", "posatile", "OPac", "posac", "OPaque", "otaque", "OPacity", "opacity", "otacity", "opatile", "posacity", "otatile"], "name": ["comment", "i", "value", "part", "nm", "base", "ame", "error", "code", "n", "nice", "key", "Name", "alias", "names", "min", "word", "time", "no", "named", "label", "unknown", "a", "prefix", "type", "data", "path", "parent", "info", "block", "cap", "f", "space", "NAME", "size", "x", "anc"], "errp": ["errpre", "drlp", "drpre", "corp", "errpe", "errfp", "drfp", "errP", "errlp", "rrfp", " errlp", "rrlp", "corP", " errpre", "derlp", "derpe", " errP", "corpe", "derP", "drp", " errpe", "corlp", "derp", "rrp", " errfp", "rrpre"], "s": ["S", "fs", "ts", "ns", "cs", "si", "syn", "n", "ssl", "o", "core", "p", "m", "sq", "session", "an", "services", "sys", "service", "g", "css", "ps", "sf", "ses", "spec", "c", "rs", "os", "sg", "op", "f", "ss", "js", "e", "sl", "ssh", "ops", "ds"]}}
{"project": "FFmpeg", "commit_id": "77d2a1ca595ebe082d35c4b624ac9a9145991494", "target": 1, "func": "ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb,\n\n                    AVStream *st, RMStream *ast, int len, AVPacket *pkt,\n\n                    int *seq, int flags, int64_t timestamp)\n\n{\n\n    RMDemuxContext *rm = s->priv_data;\n\n    int ret;\n\n\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        rm->current_stream= st->id;\n\n        ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp);\n\n        if(ret)\n\n            return ret < 0 ? ret : -1; //got partial frame or error\n\n    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        if ((ast->deint_id == DEINT_ID_GENR) ||\n\n            (ast->deint_id == DEINT_ID_INT4) ||\n\n            (ast->deint_id == DEINT_ID_SIPR)) {\n\n            int x;\n\n            int sps = ast->sub_packet_size;\n\n            int cfs = ast->coded_framesize;\n\n            int h = ast->sub_packet_h;\n\n            int y = ast->sub_packet_cnt;\n\n            int w = ast->audio_framesize;\n\n\n\n            if (flags & 2)\n\n                y = ast->sub_packet_cnt = 0;\n\n            if (!y)\n\n                ast->audiotimestamp = timestamp;\n\n\n\n            switch (ast->deint_id) {\n\n                case DEINT_ID_INT4:\n\n                    for (x = 0; x < h/2; x++)\n\n                        avio_read(pb, ast->pkt.data+x*2*w+y*cfs, cfs);\n\n                    break;\n\n                case DEINT_ID_GENR:\n\n                    for (x = 0; x < w/sps; x++)\n\n                        avio_read(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);\n\n                    break;\n\n                case DEINT_ID_SIPR:\n\n                    avio_read(pb, ast->pkt.data + y * w, w);\n\n                    break;\n\n            }\n\n\n\n            if (++(ast->sub_packet_cnt) < h)\n\n                return -1;\n\n            if (ast->deint_id == DEINT_ID_SIPR)\n\n                ff_rm_reorder_sipr_data(ast->pkt.data, h, w);\n\n\n\n             ast->sub_packet_cnt = 0;\n\n             rm->audio_stream_num = st->index;\n\n             rm->audio_pkt_cnt = h * w / st->codec->block_align;\n\n        } else if ((ast->deint_id == DEINT_ID_VBRF) ||\n\n                   (ast->deint_id == DEINT_ID_VBRS)) {\n\n            int x;\n\n            rm->audio_stream_num = st->index;\n\n            ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4;\n\n            if (ast->sub_packet_cnt) {\n\n                for (x = 0; x < ast->sub_packet_cnt; x++)\n\n                    ast->sub_packet_lengths[x] = avio_rb16(pb);\n\n                rm->audio_pkt_cnt = ast->sub_packet_cnt;\n\n                ast->audiotimestamp = timestamp;\n\n            } else\n\n                return -1;\n\n        } else {\n\n            av_get_packet(pb, pkt, len);\n\n            rm_ac3_swap_bytes(st, pkt);\n\n        }\n\n    } else\n\n        av_get_packet(pb, pkt, len);\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n#if 0\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if(st->codec->codec_id == AV_CODEC_ID_RV20){\n\n            int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1);\n\n            av_log(s, AV_LOG_DEBUG, \"%d %\"PRId64\" %d\\n\", *timestamp, *timestamp*512LL/25, seq);\n\n\n\n            seq |= (timestamp&~0x3FFF);\n\n            if(seq - timestamp >  0x2000) seq -= 0x4000;\n\n            if(seq - timestamp < -0x2000) seq += 0x4000;\n\n        }\n\n    }\n\n#endif\n\n\n\n    pkt->pts = timestamp;\n\n    if (flags & 2)\n\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n\n    return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0;\n\n}\n", "idx": 944, "substitutes": {"rm": ["rb", "cr", "rr", "nm", "r", "rh", "sr", "mp", "ram", "rt", "drm", "pm", "pb", "RM", "ref", "km", "dm", "dr", "m", "rf", "mr", "vm", "fm", "mm", "am", "lc", "rd", "rpm", "mt", "arm", "wm", "rs", "asm", "rn", "mx", "mc", "sm", "lr", "rem", "bm", "cm"], "ret": ["bf", "val", "offset", "res", "pat", "back", "r", "att", "pet", "rc", "match", "l", "rt", "flag", " Ret", "num", "code", "def", "alt", "seq", "fin", "RET", "ref", "det", "fit", "gt", "rev", "id", "obj", "status", "len", "no", "lit", "ut", "success", "ext", "rets", "feat", "data", "reply", "mt", "fun", "nt", "reg", "url", "result", "rot", "Ret", "t", "f", "al", "ft", "live", "re", "bit", "en", "art"], "x": ["wa", "i", "sw", "X", "en", "l", "ey", "ex", "j", "n", "num", "xx", "y", "rx", "p", "key", "ct", "d", "m", "yx", "cross", "name", "z", "id", "xc", "w", "time", "s", "dy", "pe", "k", "xp", "px", "on", "v", "event", "pos", "a", "el", "g", "work", "xy", "c", "in", "ay", "ix", "sex", "image", "tx", "fx", "dx", "t", "b", "f", "ax", "q", "u", "ady", "e", "xi", "h", "xs", "my", "index"], "ast": ["md", "dist", "sth", "part", "pat", "att", "hop", "ref", "blast", "aste", "rss", "sa", "ld", "an", "est", "aid", "AST", "as", "post", "host", "inst", "ac", "ta", "st", "nd", "node", "ard", "ad", "et", "ant", "el", "add", "tta", "aster", "esta", "test", "parser", "ist", "ace", "na", "ft", "ct", "asting", "sam", "ost", "od", "sc", "at", "ab", "act", "sta", "acl", "old", "ap", "ar", "std", "amp", "ess", "best", "api", "rest", "ans", "cast", "am", "end", "mast", "mt", "asts", "asm", "tx", "asted", "esp", "anc", "art"], "sub_packet_cnt": ["sub_packet_wno", "sub_packet_acval", "sub_packet_data", "sub_packet_cval", "sub_packet_\n", "sub_packacketC\n", "sub_packet_cct", "sub_packacket_\n", "sub_packet_ccount", "sub_packet_acct", "sub_packet_fcount", "sub_packet_acnd", "sub_packet_acno", "sub_packet_fnt", "sub_packet_account", "sub_packetC\n", "sub_packet_wcount", "sub_packetCdata", "sub_packet_nccount", "sub_packet_fno", "sub_packetc\n", "sub_packet_cnd", "sub_packet_ncct", "sub_packet_cno", "sub_packet_acnt", "sub_packet_ncnd", "sub_packet_fnd", "sub_packacket_data", "sub_packet_fval", "sub_packet_fct", "sub_packacketCdata", "sub_packetcdata", "sub_packet_wval", "sub_packet_ncnt", "sub_packet_wnt"]}}
{"project": "qemu", "commit_id": "92b3eeadd9bc72f1f4e5ba1f62a289dc0190e88f", "target": 1, "func": "Object *object_resolve_path_component(Object *parent, const gchar *part)\n\n{\n\n    ObjectProperty *prop = object_property_find(parent, part, NULL);\n\n    if (prop == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    if (object_property_is_link(prop)) {\n\n        return *(Object **)prop->opaque;\n\n    } else if (object_property_is_child(prop)) {\n\n        return prop->opaque;\n\n    } else {\n\n        return NULL;\n\n    }\n\n}\n", "idx": 946, "substitutes": {"parent": ["host", "Parent", "object", "private", "null", "o", "p", "ref", "new", "root", "node", "fat", "obj", "peer", "partial", "class", "pos", "data", "mother", "owner", "package", "parents", "port", "pool", "comp", "self", "current", "target", "pa", "this", "component", "child", "instance", "pointer", "path"], "part": ["host", "Part", "base", "patch", "object", "private", "p", " parts", "key", "PART", "node", " component", "name", "partial", "element", " partition", " Part", "property", "class", "pos", "prefix", "type", "pre", "pair", "self", "point", "start", "parts", "component", "child", "pointer", "path"], "prop": ["val", "pr", "attr", "mp", "bp", "properties", "po", "hop", "object", "pb", "option", "j", "cmp", "p", "opt", "tmp", "key", "root", "term", "config", "pid", "obj", "typ", "api", "fb", "property", "lit", "cp", "pos", "ext", "type", "Prop", "pro", "ps", "pred", "ap", "comp", "np", "jp", "atom", "cb", "col", "cand", "rel", "proc", "rop", "pointer", "op", "dev", "ops", "cop", "priv", "lc"]}}
{"project": "qemu", "commit_id": "196fe23734ca8888ca0275ad203ccb0d20907e6d", "target": 1, "func": "static void vscsi_process_login(VSCSIState *s, vscsi_req *req)\n\n{\n\n    union viosrp_iu *iu = &req->iu;\n\n    struct srp_login_rsp *rsp = &iu->srp.login_rsp;\n\n    uint64_t tag = iu->srp.rsp.tag;\n\n\n\n    trace_spapr_vscsi__process_login();\n\n\n\n    /* TODO handle case that requested size is wrong and\n\n     * buffer format is wrong\n\n     */\n\n    memset(iu, 0, sizeof(struct srp_login_rsp));\n\n    rsp->opcode = SRP_LOGIN_RSP;\n\n    /* Don't advertise quite as many request as we support to\n\n     * keep room for management stuff etc...\n\n     */\n\n    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);\n\n    rsp->tag = tag;\n\n    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    /* direct and indirect */\n\n    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);\n\n\n\n    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);\n\n}\n", "idx": 961, "substitutes": {"s": ["fs", "su", "ts", "cs", "si", "is", "ssl", "src", "session", "status", "sa", "sis", "v", "services", "sys", "service", "ps", "us", "server", "ses", "spec", "c", "sb", "es", "self", "gs", "state", "t", "os", "f", "u", "sg", "ss", "js", "e", "ls", "ds"], "req": ["fr", "cache", "res", "rr", "gr", "ir", "rh", "r", "ctx", "conf", "resp", "rx", "exec", "sem", "ref", "requ", "qq", "query", "config", "sq", "call", "queue", "rf", "rw", "rec", "conn", "iq", "require", "ry", "spec", "rs", "reg", "dq", "info", "crit", "proc", "q", "err", "f", "rob", "serv", "cur", "resource", "ctr", "desc", "qt", "seq", "request"], "iu": ["gu", "umi", "gru", "i", "ui", "agi", "lu", "uci", "fu", "wei", "si", "sit", "uri", "ctx", "fi", "eu", "vc", "ci", "ib", "qi", "eni", "input", "cli", "cci", "uin", "iw", "sa", "ii", "hu", "gnu", "ua", "asu", "ou", "li", "sie", "iq", "afi", "ie", "tu", "ugi", "nu", "util", "ru", "ai", "vp", "pu", "isu", "abi", "mu", "gui", "ei", "u", "ti", "ni", "lb", "isi"], "rsp": ["rosp", "crosp", "crp", "rspe", " risp", "hrsp", "rsc", "rspc", "rsa", " rpp", "rssp", "prsa", "prso", "rcpc", "hrisp", "rrpc", "srsl", " rosp", "rsasp", " rspe", "prsc", "rst", "rsst", "hrspe", "rso", "srpe", "prcp", "rpe", "rcsl", "rcp", " rsc", "srso", "crspe", "prpc", "rssa", "prpp", "rcpp", "rcsp", "srasp", "srsc", "prsp", "prst", "rp", "srcp", "rrst", "rrsp", "hrp", " rp", "srsp", "rpp", "rrspe", " rcp", "rpc", " rso", "risp", "rrisp", "srpc", "prpe", " rpc", " rpe", "crsp", "rsl", "rrsa", "rasp", "prasp", "rrosp", "rsso", "rrp", "prsl", " rsl"]}}
{"project": "qemu", "commit_id": "bf43330aa418908f7a5e2acda28ac1a8ed0d8ad6", "target": 1, "func": "void cpu_tick_set_count(CPUTimer *timer, uint64_t count)\n\n{\n\n    uint64_t real_count = count & ~timer->disabled_mask;\n\n    uint64_t disabled_bit = count & timer->disabled_mask;\n\n\n\n    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -\n\n                    cpu_to_timer_ticks(real_count, timer->frequency);\n\n\n\n    TIMER_DPRINTF(\"%s set_count count=0x%016lx (%s) p=%p\\n\",\n\n                  timer->name, real_count,\n\n                  timer->disabled?\"disabled\":\"enabled\", timer);\n\n\n\n    timer->disabled = disabled_bit ? 1 : 0;\n\n    timer->clock_offset = vm_clock_offset;\n\n}\n", "idx": 963, "substitutes": {"timer": ["driver", "clock", "tm", "manager", "worker", "caster", "icer", "tim", "outer", "er", "temp", "processor", "sim", "runner", "ger", "acker", "tick", "amer", "term", "imer", "thread", "cer", "mr", "buffer", "time", "theme", "mom", "maker", "icker", "peer", "tc", "handler", "master", "event", "loader", "lc", "ext", "writer", "ler", "txt", "message", "ter", "Timer", "server", "walker", "counter", "ee", "roller", "inter", "player", "iner", "err", "ti", "browser", "timeout", "inner", "reader", "hour", "later", "acer"], "count": ["clock", "mount", "cache", "cc", "Count", "offset", "lock", "base", "cond", "match", "code", "num", "core", "number", "thread", "call", "check", "name", "load", "sum", "time", "force", "len", "cast", "full", "path", "ast", "length", "work", "c", "app", "amount", "read", "counter", "weight", "start", "current", "cpu", "process", "large", "max", "child", "size", "empty", "seq"]}}
{"project": "qemu", "commit_id": "d3c8c67469ee70fcae116d5abc277a7ebc8a19fd", "target": 1, "func": "void commit_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, BlockDriverState *top, int64_t speed,\n\n                  BlockdevOnError on_error, const char *backing_file_str,\n\n                  const char *filter_node_name, Error **errp)\n\n{\n\n    CommitBlockJob *s;\n\n    BlockReopenQueue *reopen_queue = NULL;\n\n    int orig_overlay_flags;\n\n    int orig_base_flags;\n\n    BlockDriverState *iter;\n\n    BlockDriverState *overlay_bs;\n\n    BlockDriverState *commit_top_bs = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    assert(top != bs);\n\n    if (top == base) {\n\n        error_setg(errp, \"Invalid files for merge: top and base are the same\");\n\n        return;\n\n\n\n\n    overlay_bs = bdrv_find_overlay(bs, top);\n\n\n\n    if (overlay_bs == NULL) {\n\n        error_setg(errp, \"Could not find overlay image for %s:\", top->filename);\n\n        return;\n\n\n\n\n    s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL,\n\n                         speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp);\n\n    if (!s) {\n\n        return;\n\n\n\n\n    orig_base_flags    = bdrv_get_flags(base);\n\n    orig_overlay_flags = bdrv_get_flags(overlay_bs);\n\n\n\n    /* convert base & overlay_bs to r/w, if necessary */\n\n    if (!(orig_base_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL,\n\n                                         orig_base_flags | BDRV_O_RDWR);\n\n\n    if (!(orig_overlay_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL,\n\n                                         orig_overlay_flags | BDRV_O_RDWR);\n\n\n    if (reopen_queue) {\n\n        bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err);\n\n        if (local_err != NULL) {\n\n            error_propagate(errp, local_err);\n\n            goto fail;\n\n\n\n\n\n    /* Insert commit_top block node above top, so we can block consistent read\n\n     * on the backing chain below it */\n\n    commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0,\n\n                                         errp);\n\n    if (commit_top_bs == NULL) {\n\n        goto fail;\n\n\n\n\n\n    commit_top_bs->total_sectors = top->total_sectors;\n\n    bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top));\n\n\n\n    bdrv_set_backing_hd(commit_top_bs, top, &local_err);\n\n    if (local_err) {\n\n        bdrv_unref(commit_top_bs);\n\n        commit_top_bs = NULL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n    bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err);\n\n    if (local_err) {\n\n        bdrv_unref(commit_top_bs);\n\n        commit_top_bs = NULL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    s->commit_top_bs = commit_top_bs;\n\n    bdrv_unref(commit_top_bs);\n\n\n\n    /* Block all nodes between top and base, because they will\n\n     * disappear from the chain after this operation. */\n\n    assert(bdrv_chain_contains(top, base));\n\n    for (iter = top; iter != base; iter = backing_bs(iter)) {\n\n        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves\n\n         * at s->base (if writes are blocked for a node, they are also blocked\n\n         * for its backing file). The other options would be a second filter\n\n         * driver above s->base. */\n\n        ret = block_job_add_bdrv(&s->common, \"intermediate node\", iter, 0,\n\n                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,\n\n                                 errp);\n\n        if (ret < 0) {\n\n            goto fail;\n\n\n\n\n\n    ret = block_job_add_bdrv(&s->common, \"base\", base, 0, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* overlay_bs must be blocked because it needs to be modified to\n\n     * update the backing image string. */\n\n    ret = block_job_add_bdrv(&s->common, \"overlay of top\", overlay_bs,\n\n                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->base = blk_new(BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_WRITE\n\n                      | BLK_PERM_RESIZE,\n\n                      BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_GRAPH_MOD\n\n                      | BLK_PERM_WRITE_UNCHANGED);\n\n    ret = blk_insert_bs(s->base, base, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* Required permissions are already taken with block_job_add_bdrv() */\n\n    s->top = blk_new(0, BLK_PERM_ALL);\n\n    ret = blk_insert_bs(s->top, top, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->active = bs;\n\n\n\n    s->base_flags          = orig_base_flags;\n\n    s->orig_overlay_flags  = orig_overlay_flags;\n\n\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n\n\n    trace_commit_start(bs, base, top, s);\n\n    block_job_start(&s->common);\n\n    return;\n\n\n\nfail:\n\n    if (s->base) {\n\n        blk_unref(s->base);\n\n\n    if (s->top) {\n\n        blk_unref(s->top);\n\n\n    if (commit_top_bs) {\n\n        bdrv_set_backing_hd(overlay_bs, top, &error_abort);\n\n\n    block_job_early_fail(&s->common);\n", "idx": 971, "substitutes": {"job_id": ["jobCid", " job_ident", " job_ids", "jobCname", "jobCids", "block_id", "block_ID", "job_ident", "job_ID", " job_name", "job_name", "job_ids", "jobCID", "block_ids", "block_name"], "bs": ["banks", "disabled", "fs", "las", "res", "BS", "ns", "sub", "bid", "cs", "pb", "fps", "settings", "bb", "core", "bps", "http", "src", "root", "ins", "job", "bing", "blast", "status", "blocks", "bos", "bot", "bi", "stats", "css", "ps", "ses", "sb", "rs", "site", "url", "gb", "gs", "bytes", "local", "state", "vs", "b", "os", "bas", "ss", "js", "ls", "bl", "bc", "lb", "bis", "sync"], "base": ["bf", "support", "cache", "res", "ui", "back", "bp", "sub", "settings", "pb", "bb", "core", "builder", "bottom", "super", "root", "remote", "cli", "job", "buffer", "bare", "area", "bot", "lb", "ase", "master", "full", "bat", "prefix", "change", "based", "Base", "flat", "server", "sb", "site", "body", "pre", "plain", "url", "kit", "local", "block", "state", "rel", "basic", "db", "b", "live", "bas", "out", "bc", "http", "client", "sync", "lc", "source"], "top": ["high", "part", "Top", "TOP", "hop", "sub", "settings", "ssl", "core", "bottom", "super", "p", "at", "up", "best", "root", "config", "job", "name", "first", "pop", "api", "bot", "master", "above", "platform", "pos", "prefix", "file", "front", "css", "sp", "parent", "ps", "site", "url", "pre", "origin", "prev", "plugin", "block", "state", "tops", "b", "as", "op", "bas", "http", "client", "path", "upper"], "speed": ["driver", "offset", "ime", "sort", "error", "unit", "bps", "root", " speeds", "name", "limit", "status", "sn", "ride", "engine", "Speed", "slice", "skip", "stop", "stream", "stats", "type", "peed", "sp", "length", "ps", "spec", "sf", "url", "start", "seed", "rate", "level", "sm", "ss", "size", "score", "timeout", "client", "sync", "step", "SIZE"], "on_error": ["on_success", " on_start", "on_start", " on_success", "on_err", " on_err"], "backing_file_str": ["backing_path_str", "backing_file_uri", "backing_path_uri", "backing_file2uri", "backing_file_url", "backing_file2str", "backing_file_path", "backing_path_url", "backing_file2path", "backing_path_path", "backing_file2url"], "filter_node_name": ["filter_node_path", "filter_node_names", "filter_node_type", "filter_file_path", "filter_file_name", "filter_file_type", "filter_file_names"], "errp": [" errps", "Errorps", "rrr", " errcp", "errr", "acerfp", "ercp", "erps", "errcp", "ierps", " errfp", "errorP", "rrcp", "rrpc", "Errorp", "acerps", "erP", "errfp", "errpy", "errP", "ErrorP", "rrfp", "Errorr", "errpc", " errpy", "acerr", "erp", "rrP", "errorr", " errpc", "acerp", " errP", "ierr", "errorpc", "erpc", "errorps", "ierpy", "rrps", "ierp", " errr", "err", "errorp", "rrp", "errps", "acerpy", "acerP"], "s": ["S", "fs", "su", "sv", "sc", "r", "ts", "ns", "l", "sets", "cs", "si", "hs", "is", "n", "ssl", "sh", "o", "p", "m", "sq", "se", "details", "sa", "sys", "stats", "g", "sp", "ps", "ses", "sf", "spec", "rs", "c", "gs", "sports", "b", "sg", "f", "os", "ss", "js", "e", "sl", "sk", "ls", "http", "ds", "uploads", "sync"], "reopen_queue": ["reopen_list", "reopen_stack", "reclose_queue", "reopen_manager", "reopened_manager", "reopenermenu", "reopenaylock", "refill_parent", "recreate_collection", "reopen_buf", "reopenscollection", "reopenemqueue", "reopen_server", "recreate_queue", "reopenfserver", "reopenallque", "recreate_status", "reopen__queue", "recreate_list", "reopenermanager", "reopen_menu", "reopen_priority", "reopen_collection", "reclose_base", "reopensqueue", "reopensparent", "reopen_log", "reopen___queue", "reopen_parent", "reopen__batch", "reopen_base", "reopenallserver", "refill_lock", "reopenayqueue", "reopened__manager", "reclose_que", "reopenfstatus", "reopenemstack", "reopenallstatus", "reopened__queue", "reopenayparent", "reopen___priority", "reopenerlist", "reopenfqueue", "reopened__batch", "reopen_que", "reopened_que", "reopened_batch", "reopensstatus", "reopenerqueue", "reopenercollection", "reopen__manager", "reopen___que", "reopenfque", "reopenerbuf", "reopen__que", "reopenempriority", "reopened_queue", "reopenallqueue", "reopen_status", "reopen___stack", "reopenemque", "reopenerbatch", "reopenerstatus", "reopenslog", "reopenslock", "reopenslist", "reopen_batch", "refill_log", "reopen_lock", "reopened__que", "reopenerque", "reopenaylog", "reclose_batch", "refill_queue"], "orig_overlay_flags": ["orig_overlayallflag", "orig_overline_rules", "orig_override_flags", "orig_overlayallfiles", "orig_overlay_ants", "orig_override_files", "orig_override_rules", "orig_overlayacfiles", "orig_override_bits", "orig_overlayallflags", "orig_overlay_files", "orig_override_locks", "orig_overlay_locks", "orig_overlay__ants", "orig_overlayacflag", "orig_overlay__rules", "orig_overlay_bits", "orig_overline_flag", "orig_overlayacflags", "orig_override_ants", "orig_overlay__flags", "orig_overline_files", "orig_overlayallrules", "orig_overline_flags", "orig_overlay_rules", "orig_overlay_flag"], "orig_base_flags": ["orig_base_groups", "orig_base_devices", "orig_bas_fields", "orig_bas_ants", "orig_fixed_groups", "orig_originalwflags", "orig_original_types", "orig_originalwgroups", "orig_original_rules", "orig_originalwtypes", "orig_base64types", "orig_basewflags", "orig_bas_stats", "orig_basewrules", "orig_bas_devices", "orig_base_rules", "orig_base_fields", "orig_base_bits", "orig_original_flags", "orig_fixed_states", "orig_base_states", "orig_original_groups", "orig_fixed_settings", "orig_baselicflags", "orig_base_stats", "orig_base64groups", "orig_base64rules", "orig_base_types", "orig_baselicdevices", "orig_originalwrules", "orig_base_ants", "orig_baselicfields", "orig_basewgroups", "orig_bas_bits", "orig_base64flags", "orig_basewtypes", "orig_bas_flags", "orig_fixed_flags", "orig_base_settings"], "iter": ["loop", "fs", "chain", "sub", "is", "super", "at", "iterator", "stack", "root", "ins", "rev", "status", "stat", "store", "bot", "abc", "bi", "stats", "reverse", "flat", "site", "origin", "its", "it", "sync", "seq"], "overlay_bs": ["override_bits", "overline_b", "overlay_base", "overlayer_bas", "overlayer_b", "overline_abs", "overlay__base", "override_boxes", "overlayer_cs", "overlay_bits", "overlay__ls", "override_bs", "overlay_cs", "overline_bs", "overlayer_base", "override_cases", "overlayer_bs", "overlayer_ls", "overlay_b", "override_b", "overlay_ls", "overlayer_abs", "overlay_abs", "overlay_bas", "overline_base", "overlay_boxes", "overlay__cs", "override_base", "overlay__bs", "overlay_cases"], "commit_top_bs": ["commit_\n", "commit_best_base", "commit_top_base", "commit_top_lb", " commit_\n", "commit_config", "commit_top_b", "commit_best_bs", "commit_best_lb", " commit_config", "commit_best_b"], "local_err": ["locallyres", "locallyattr", "localalerror", "Local_orig", "Local_error", "localalres", "local_res", "localalorig", "Local_req", " local_error", "local___req", "localalattr", "localalerr", "local_req", "local_er", "local_message", "global_err", "locallyerror", "local___message", "global_attr", " local_message", " local_er", "global_error", "local___err", "locallyerr", "global_res", "localalreq", " local_req", "local_orig", "local_attr", "local_error", "local___error", "Local_err"], "ret": ["val", "res", " RET", "def", "rc", "num", "resp", "alt", "RET", "gc", " r", "len", "run", " resp", "ry", "fun", "reg", "result", "Ret", "al", "re", "pass", "bc"]}}
{"project": "qemu", "commit_id": "2c6942fa7b332a95286071b92d233853e1000948", "target": 0, "func": "int bdrv_is_removable(BlockDriverState *bs)\n\n{\n\n    return bs->removable;\n\n}\n", "idx": 982, "substitutes": {"bs": ["banks", "fs", "BS", "ns", "bid", "cs", "pb", "bes", "null", "ubs", "bits", "als", "B", "ins", "bing", "blocks", "bn", "bos", "ba", "fb", "abc", "ops", "bi", "sels", "css", "ps", "ses", "iss", "gs", "Bs", "vs", "b", "os", "bas", "ss", "ls", "bis", "bc", "bytes"]}}
{"project": "FFmpeg", "commit_id": "af7d13ee4a4bf8d708f9b0598abb8f6e22b76de1", "target": 1, "func": "static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n\n{\n\n\n    return 0;\n\n}", "idx": 1035, "substitutes": {"link": ["model", "line", "man", "feed", "bug", "ack", "or", "http", "filter", "bridge", "cross", "plug", "load", "linked", "type", "add", "path", "band", "plugin", "channel", "Link", "pack", "sd", "links", "light", " Link", "tag"], "samplesref": ["samplesRef", "sampsRef", "sipesRef", "samplesreference", " samplesRef", " sampsref", " sampsreference", "sampsref", " samplesreference", "sipesref", "sampsreference", "sipesreference", " sampsRef"]}}
{"project": "qemu", "commit_id": "8ae8e904fcba484ff7c3f8f31339b56ebd88fbad", "target": 1, "func": "void qmp_blockdev_add(BlockdevOptions *options, Error **errp)\n\n{\n\n    QmpOutputVisitor *ov = qmp_output_visitor_new();\n\n    QObject *obj;\n\n    QDict *qdict;\n\n    Error *local_err = NULL;\n\n\n\n    /* Require an ID in the top level */\n\n    if (!options->has_id) {\n\n        error_setg(errp, \"Block device needs an ID\");\n\n        goto fail;\n\n    }\n\n\n\n    /* TODO Sort it out in raw-posix and drive_init: Reject aio=native with\n\n     * cache.direct=false instead of silently switching to aio=threads, except\n\n     * if called from drive_init.\n\n     *\n\n     * For now, simply forbidding the combination for all drivers will do. */\n\n    if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) {\n\n        bool direct = options->cache->has_direct && options->cache->direct;\n\n        if (!options->has_cache && !direct) {\n\n            error_setg(errp, \"aio=native requires cache.direct=true\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    visit_type_BlockdevOptions(qmp_output_get_visitor(ov),\n\n                               &options, NULL, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    obj = qmp_output_get_qobject(ov);\n\n    qdict = qobject_to_qdict(obj);\n\n\n\n    qdict_flatten(qdict);\n\n\n\n    blockdev_init(NULL, qdict, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\nfail:\n\n    qmp_output_visitor_cleanup(ov);\n\n}\n", "idx": 1038, "substitutes": {"options": ["times", "cache", "issues", "ports", "flags", "io", "comments", "com", "ts", "settings", "object", "option", "resources", "ims", "public", "null", "o", "external", "changes", "opt", "events", "exec", "or", "http", "ips", "groups", "config", "ions", "details", "acl", "errors", "names", "s", "name", "pos", "co", "Options", "data", "ents", "ps", "parent", "cho", "app", "es", "self", "current", "outs", "results", "eps", "files", "info", "style", "args", "global", "os", "ors", "op", "none", "rules", "objects", "utils", "this", "js", "e", "points", "ops", "plugins", "params", "checks"], "errp": ["nerpc", " errps", "errr", "errpre", "resultpe", " errf", "ierps", "errorP", "nerpe", "errpr", "rrpc", "erP", "errpe", "asterpr", "errP", "nerp", "armP", "errpat", "resultp", "asterp", "asterps", "asterf", " errpre", "errpc", "armp", " errpr", "resultpc", "erp", "rrP", "ierpe", "errorr", " errpc", "erpat", "nerpre", "errorpat", "ierpat", "ierP", "resultpre", " errP", "armpre", "ierr", "resultf", "ierpr", " errpe", "errf", "ierf", "ierp", "resultps", "err", "errorp", "rrp", "errps", "rrpre", "armpc"], "ov": ["uv", "lov", "nov", "vo", "ove", "ko", "av", "od", "sv", "oo", "kov", "o", "rov", "up", "obb", "orf", "ovan", "oh", "ovo", "off", "oy", "ou", "ant", "raft", "ocr", "erv", "OV", "oyer", "oid", "ob", "boot", "oc", "oval", "upp", "oa", "obile", "ova", "oven", "opp", "ow", "iv", "ev"], "obj": ["fn", "val", "cache", "od", "attr", "bj", "po", "object", "ctx", "j", "so", "n", "alt", "o", "pt", "tmp", "bo", "arr", "act", "obb", "ind", "oi", "aj", "adj", "cdn", "bot", "ass", "co", "str", "data", "coll", "output", "nt", "pp", "self", "ob", "block", "cb", "oc", "Obj", "eff", "dict", "oa", "objects", "os", "opp", "b", "op", "utils", "ops", "Object", "art"], "qdict": [" qdf", "qudata", "dqcoll", "qdetails", "pdata", "reqcoll", "eqdf", "quclean", "reqpatch", "qudict", "qpatch", "qdf", " qdetails", "qcontainer", "qict", "sqcontainer", " qdata", "reqdict", "reqdata", "qudf", " qcontainer", "eqdict", " qclean", "dqdata", "pdf", "sqdict", "eqdata", "qdata", "qucontainer", "quict", "sqdf", "pclean", " qict", "rdf", "eqdetails", "qclean", " qpatch", "rdict", "dqdict", "sqict", "pdict", " qcoll", "rdetails", "dqpatch", "rdata", "qcoll"], "local_err": ["internal_rr", "foreignaller", "internal_status", "internal_conn", "local_doc", "standardallEr", "localederr", "localallerror", "standardallerr", "standard_er", " local_doc", "localermsg", "localallerr", "local_orig", "standard_mr", "localedconn", "localererror", "standard_err", "local_Er", "localallwar", " local_error", "localerorig", "local_er", "global_err", "standard_Er", "local_war", "locallystatus", "global_error", "foreign_error", "foreignallwar", "local_mr", "foreign_war", "local_conn", "localedstatus", "localallEr", "local_cr", "local_rr", "localallmr", "standardallmr", "foreign_er", "local_msg", "global_orig", "localererr", "locallyerr", "local_error", " local_cr", "localedrr", "foreignallerr", "foreignallerror", "localaller", "internal_err", "locallyrr", "foreign_err", "local_status", " local_er", "global_msg", "standardaller", "locallyconn"]}}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void do_divwuo (void)\n\n{\n\n    if (likely((uint32_t)T1 != 0)) {\n\n        xer_ov = 0;\n\n        T0 = (uint32_t)T0 / (uint32_t)T1;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n        T0 = 0;\n\n    }\n\n}\n", "idx": 1040, "substitutes": {}}
{"project": "qemu", "commit_id": "00f4d64ee76e873be881a82d893a591487aa7950", "target": 1, "func": "static void kvmclock_pre_save(void *opaque)\n\n{\n\n    KVMClockState *s = opaque;\n\n    struct kvm_clock_data data;\n\n    int ret;\n\n\n\n    if (s->clock_valid) {\n\n        return;\n\n    }\n\n    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"KVM_GET_CLOCK failed: %s\\n\", strerror(ret));\n\n        data.clock = 0;\n\n    }\n\n    s->clock = data.clock;\n\n    /*\n\n     * If the VM is stopped, declare the clock state valid to avoid re-reading\n\n     * it on next vmsave (which would return a different value). Will be reset\n\n     * when the VM is continued.\n\n     */\n\n    s->clock_valid = !runstate_is_running();\n\n}\n", "idx": 1046, "substitutes": {"opaque": ["OPca", "opca", "pque", "occa", "OPacity", "operque", "OPaques", "pacity", "opque", " opque", "ocacity", " opaques", "operacity", " opacity", "opaques", "operaques", "paque", "OPaque", "ocaques", "opacity", "ocaque", " opca", "paques", "operaque"], "s": ["S", "i", "fs", "su", "r", "sets", "ts", "ns", "cs", "is", "si", "n", "ssl", "o", "p", "new", "d", "m", "sq", "sa", "ds", "v", "services", "g", "ps", "ses", "c", "sb", "es", "gs", "sym", "state", "args", "as", "f", "sg", "b", "aws", "ss", "e", "sl", "ls", "sup", "sync"], "data": ["next", "dd", "val", "i", "cache", "att", "def", "ns", "Data", "object", "array", "settings", "si", "o", "p", "valid", "als", "new", "input", " DATA", "config", "d", "session", "dat", "id", "buffer", "api", "ins", "alpha", "ad", "slice", " Data", "a", "ata", "missing", "type", "str", "to", "params", "in", "es", "and", "start", "results", "info", "result", "options", "state", "style", "args", "al", "DATA", "as", "f", "na", "da", "address", "aws", "e", "ops", "ds"], "ret": ["cat", "bf", "val", "fail", "res", "pat", " RET", "sr", "ait", "att", "rc", "tr", "rt", "code", " Ret", "num", "j", "alt", "pt", "valid", "fin", "RET", "ref", "det", "af", "rev", "ad", "len", "py", "stop", "success", "repl", "rets", "ext", "str", "reply", "mt", "fun", "nt", "reg", "result", "rot", "Ret", "t", "f", "err", "db", "ft", "cur", "failed", "serv", "re", "ct", "bit", "en", "art"]}}
{"project": "qemu", "commit_id": "6c1fef6b59563cc415f21e03f81539ed4b33ad90", "target": 1, "func": "static void handle_satn(ESPState *s)\n\n{\n\n    uint8_t buf[32];\n\n    int len;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_satn;\n\n        return;\n\n    }\n\n    len = get_cmd(s, buf);\n\n    if (len)\n\n        do_cmd(s, buf);\n\n}\n", "idx": 1056, "substitutes": {"s": ["S", "i", "fs", "sv", "r", "ts", "ns", "secure", "cs", "is", "n", "sec", "ssl", "o", "south", "p", "src", "d", "m", "sq", "status", "stat", "services", "a", "sys", "states", "service", "g", "ps", "us", "submit", "ses", "sf", "secondary", "sb", "rs", "c", "es", "self", "gs", "sym", "state", "t", "b", "sg", "f", "native", "u", "this", "os", "ss", "js", "e", "as", "http", "ds", "sync"], "buf": ["rb", "done", "buff", "mp", "comb", "rc", "fi", "context", "array", "code", "img", "ctx", "header", "bd", "alloc", "fp", "tmp", "src", "mem", "ff", "queue", "buffer", "Buffer", "vec", "fb", "pad", "cv", "func", "fd", "data", "batch", "uf", "bag", "map", "bh", "block", "cb", "args", "bin", "db", "cmd", "b", "f", "wb", "bc", "cas", "seq", "br"], "len": ["val", "l", "code", "j", "num", "n", "le", "seq", "fin", "ref", "fl", "rev", "obj", "id", "ln", " length", "dy", "count", "Len", "v", "a", "pos", "el", "li", "str", "data", "ler", "coll", "ie", "length", "fun", "c", "nt", "url", "ll", "bin", "f", "err", "cmd", "size", "e", "empty", "lc", "en"]}}
{"project": "FFmpeg", "commit_id": "5d97d9d53ea1cc2c28411ad734565372ddeccc32", "target": 1, "func": "static int check_checksum(ByteIOContext *bc){\n\n    unsigned long checksum= get_checksum(bc);\n\n//    return checksum != get_be32(bc);\n\n\n\n    av_log(NULL, AV_LOG_ERROR, \"%08X %08X\\n\", checksum, (int)get_be32(bc));\n\n\n\n    return 0;\n\n}\n", "idx": 1059, "substitutes": {"bc": ["soc", "cc", "dc", "jc", "com", "sc", "cf", "ac", "fc", "rc", "cs", "context", "ctx", "bb", "icc", "cca", "isc", "ec", "gc", "cms", "xc", "acl", "fb", "tc", "cv", "pc", "ca", "c", "sb", "nc", "mc", "cb", "oc", "BC", "cl", "BBC", "uc", "lc", "anc"]}}
{"project": "qemu", "commit_id": "35c2c8dc8c0899882a8e0d349d93bd657772f1e7", "target": 0, "func": "int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,\n\n                   const char *version, const char *serial, const char *model,\n\n                   uint64_t wwn,\n\n                   uint32_t cylinders, uint32_t heads, uint32_t secs,\n\n                   int chs_trans)\n\n{\n\n    uint64_t nb_sectors;\n\n\n\n    s->blk = blk;\n\n    s->drive_kind = kind;\n\n\n\n    blk_get_geometry(blk, &nb_sectors);\n\n    s->cylinders = cylinders;\n\n    s->heads = heads;\n\n    s->sectors = secs;\n\n    s->chs_trans = chs_trans;\n\n    s->nb_sectors = nb_sectors;\n\n    s->wwn = wwn;\n\n    /* The SMART values should be preserved across power cycles\n\n       but they aren't.  */\n\n    s->smart_enabled = 1;\n\n    s->smart_autosave = 1;\n\n    s->smart_errors = 0;\n\n    s->smart_selftest_count = 0;\n\n    if (kind == IDE_CD) {\n\n        blk_set_dev_ops(blk, &ide_cd_block_ops, s);\n\n        blk_set_guest_block_size(blk, 2048);\n\n    } else {\n\n        if (!blk_is_inserted(s->blk)) {\n\n            error_report(\"Device needs media, but drive is empty\");\n\n            return -1;\n\n        }\n\n        if (blk_is_read_only(blk)) {\n\n            error_report(\"Can't use a read-only drive\");\n\n            return -1;\n\n        }\n\n        blk_set_dev_ops(blk, &ide_hd_block_ops, s);\n\n    }\n\n    if (serial) {\n\n        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);\n\n    } else {\n\n        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n\n                 \"QM%05d\", s->drive_serial);\n\n    }\n\n    if (model) {\n\n        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);\n\n    } else {\n\n        switch (kind) {\n\n        case IDE_CD:\n\n            strcpy(s->drive_model_str, \"QEMU DVD-ROM\");\n\n            break;\n\n        case IDE_CFATA:\n\n            strcpy(s->drive_model_str, \"QEMU MICRODRIVE\");\n\n            break;\n\n        default:\n\n            strcpy(s->drive_model_str, \"QEMU HARDDISK\");\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (version) {\n\n        pstrcpy(s->version, sizeof(s->version), version);\n\n    } else {\n\n        pstrcpy(s->version, sizeof(s->version), qemu_get_version());\n\n    }\n\n\n\n    ide_reset(s);\n\n    blk_iostatus_enable(blk);\n\n    return 0;\n\n}\n", "idx": 1060, "substitutes": {"s": ["i", "uns", "conf", "d", "sa", "sis", "v", "states", "ps", "sb", "sym", "state", "os", "f", "parts", "as", "set", "js", "comments", "sv", "l", "sites", "si", "is", "o", "qs", "p", "less", "ins", "details", "stats", "ses", "site", "b", "sg", "u", "sync", "S", "uses", "r", "settings", "hs", "cs", "ssl", "south", "m", "session", "w", "full", "service", "g", "us", "server", "spec", "ks", "es", "gs", "t", "ss", "e", "sl", "ls", "ds", "xs", "request", "fs", "su", "sets", "ts", "ns", "n", "services", "a", "sys", "sf", "c", "rs", "self", "its", "tests"], "blk": ["clkt", "plc", "ilK", "clks", "blc", "plK", " blks", "plok", " blb", "blch", "slch", "blmk", "slok", "brke", "slk", "clck", " blke", "slsk", "Blok", "mlch", "plke", "blkt", "ylk", "ilke", "ylks", "slK", "clke", "plmk", " blmk", "clk", "ylke", "slke", "ylmk", "Blb", "blck", "plck", "blks", "mlks", "blb", "plkt", "blsk", "slck", "Blks", "plch", "mlk", "ilkt", "brok", "slkt", "slc", " blsk", "clok", "clb", "plk", "ilks", "ilok", "Blk", "plks", "mlc", "ilk", "blK", "brk", "brks", "blke", "blok", "plsk", " blkt", " blck", "slks", " blok"], "kind": ["ko", "ke", "good", "part", "division", "role", "device", "dir", "sid", "Kind", "impl", "ind", "d", "concept", "name", "id", "head", "step", "method", "engine", "k", "kick", "mode", "pod", "class", "th", "ant", "type", "year", "str", "data", "kid", "brand", "mid", "ie", "coll", "need", "spec", "shape", "direction", "start", "plugin", "info", "seed", "depth", "kt", "style", "dev", "cost", "hack", "magic", "instance", "sk", "cycle", "needed", "path"], "version": ["scale", "device", "vision", "rev", "product", "id", "stage", "engine", "mode", "release", "Version", "format", "brand", "description", "versions", "secret", "package", "server", "arch", "plugin", "seed", "image", "feature", "VERSION", "ver", "iv", "vers", "path"], "serial": ["driver", "random", "machine", "zip", "ident", "material", "series", "standard", "io", "loc", "mobile", "bug", "error", "human", "device", "patch", "iso", "private", "binary", "public", "core", "pattern", "normal", "valid", "root", "vision", "primary", "major", "phone", "mode", "micro", "description", "length", "package", "spec", "server", "initial", "flash", "power", "generic", "international", "local", "global", "pocket", "dev", "custom", "json", "component", "social", "specified"], "model": ["field", "media", "view", "machine", "zip", "base", "mobile", "human", "device", "language", "object", "install", "where", "zero", "models", "command", "control", "location", "module", "config", "vision", "product", "id", "time", "method", "mode", "label", "format", "python", "file", "type", "description", "path", "length", "package", "server", "parent", "Model", "automatic", "license", "library", "generic", "image", "block", "local", "style", "feature", "json", "vel", "single", "size", "company", "sql", "message", "params"], "wwn": ["wnn", "hiw", "awiw", "www", "wbgn", "warn", "wpwn", "wbnn", "wbwn", "wiw", " Wwn", "awws", "hww", " wmn", "Wiw", "awwn", "ewiw", "ewws", " wiw", "ewwn", "Wwn", " warn", "hwn", "Warn", " wnn", "wpnn", "wpgn", " Warn", "wgn", " Wiw", "awww", " Wgn", "wmn", "wws", " wgn", "wpmn", "hws", "wbmn", "ewww", "Wgn"], "cylinders": ["galinder", "ylences", "cyleds", "yliths", "yminders", "cycles", "cylins", "ylins", "silences", "cileds", "cilinder", "cylinder", "galcles", "quinders", "galeds", "cilisters", "cyinder", "galinders", "ciliths", "silins", "cyliths", "cyinders", "cylcles", "ylinders", "yminder", "cylisters", "cilinders", "silinder", "cyeds", "quences", "ymiths", "siliths", "ymisters", "quiths", "silisters", "cilcles", "quins", "cylences", "silinders"], "heads": ["clips", "times", "HEAD", "sections", "maps", "unks", "cycles", "pages", "olds", "height", "bits", "eeks", "ints", "ins", "ids", "rows", "head", "blocks", "opens", "members", "mods", "boards", "shots", "bands", "lines", "length", "frames", "devices", "hops", "obs", "kins", "drivers", "tracks", "nuts", "depth", "tails", "views", "archs", "locks", "reads", "cles", "tops", "sticks", "workers", "links", "headers", "planes", "versions", "checks", "holes"], "secs": ["seqes", "ctp", "seqses", "incds", "reqd", "structn", "seces", "incs", "secds", "seqs", "ctes", "secn", "eces", "structd", "secp", "ecses", "incd", "ecp", "seqp", "secses", "ctses", "incn", "secd", "ecs", "reqn", "reqs", "reqds", "cts", "structs", "structds"], "chs_trans": ["chns_translation", "chs2Trans", "chns_ctr", "chs_Trans", "chss_Trans", "chls_ctr", "chns_tr", "chs2trans", "chs2private", "chs__ctr", "chs_ctr", "chs_transfer", "chs_tr", "chs_rans", "chls_rans", "chss_trans", "chss_orig", "chs2orig", "chs__rans", "chs_orig", "chs_private", "chls_transfer", "chns_trans", "chs__trans", "chss_private", "chs_translation", "chls_trans", "chs__transfer"], "nb_sectors": ["nb_syctions", "nb_nections", "nb_pectors", "nb_ellers", "nb_pserets", "nb_sycs", "nb_vectors", "nb_psegment", "nb_locgment", "nb_sedds", "nb_ectors", "nb_serets", "nb_locors", "nb_pelections", "nb_cegment", "nb_ceors", "nb_syctors", "nb_gegments", "nb_spegments", "nb_sydds", "nb_gerets", "nb_cectors", "nb_pegments", "nb_elections", "nb_gectors", "nb_seors", "nb_segment", "nb_locctors", "nb_sellers", "nb_nectors", "nb_pseors", "nb_pecs", "nb_vecs", "nb_egments", "nb_psegments", "nb_psections", "nb_vections", "nb_cegments", "nb_secs", "nb_nerets", "nb_sections", "nb_segments", "nb_negments", "nb_gections", "nb_spelections", "nb_pedds", "nb_vedds", "nb_selections", "nb_pections", "nb_spectors", "nb_spellers", "nb_psectors", "nb_pellers", "nb_locgments"]}}
{"project": "qemu", "commit_id": "384b557da1a44ce260cd0328c06a250507348f73", "target": 1, "func": "int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,\n\n                                                 uint64_t iova, uint64_t len)\n\n{\n\n    struct vhost_iotlb_msg imsg;\n\n\n\n    imsg.iova = iova;\n\n    imsg.size = len;\n\n    imsg.type = VHOST_IOTLB_INVALIDATE;\n\n\n\n    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);\n\n}\n", "idx": 1089, "substitutes": {"dev": ["gu", "mod", "serial", "wd", "cache", "diff", "die", "bug", "od", "priv", "device", "def", "de", "gen", "enc", "grad", "conf", "p", "DEV", "debug", "group", "node", "d", "var", "cam", "obj", "api", "w", "pub", "ad", "engine", "prom", "pad", "v", "conn", "data", "pro", "Dev", "app", "reg", "gd", "di", "info", "ch", "block", "pack", "der", "cmd", "ver", "rad", "out", "client", "ev", "hw", "dom"], "iova": ["abiovo", " iiera", "siiera", "diov", " iov", "iov", "siovi", "ioval", "niova", "ioca", "abiaga", "niovi", "siova", "uoval", "uaga", "uovan", "uova", "nioval", "iovi", "abiova", "iovo", "sioca", "iiera", "iovan", "iaga", "siovan", " ioca", "diiera", "siov", "uovo", " iovo", "diova", "niovan", " iovan", "dioca", "uovi", " iaga", "sioval", "abiovan"], "len": ["fn", "line", "val", "base", "l", "gen", "enc", "lt", "n", "lim", "lon", "dl", "le", "lin", "seq", "lang", "fin", "zen", "rev", "name", "limit", "ln", "Len", "pos", "el", "conn", "li", "ann", "data", "den", "lan", "length", "size", "sl", "bl", "lif", "lf", "lc", "en"], "imsg": ["ubsg", "imgs", "igsgy", "imgi", "igsgi", "lsgi", "umsgm", "ubsgi", "fsge", "omsgi", "igsg", "img", "imsgt", "imsga", "imge", "omsgn", "fsgs", "omsgm", "umsgi", "mesgs", "ipsg", "omsb", "imsgi", "igsgn", "ssb", "ssgn", "lsgn", "imsgm", "fsg", "ipsgt", "igsgm", "omsg", "omsgt", "imsgs", "mesga", "mesg", "cmga", "ssgt", "mesgi", "mesge", "umsgy", "cmg", "lsg", "ssg", "cmgs", "umsg", "ubsgm", "fsga", "imsge", "ipsgn", "imga", "imsgn", "imsgy", "ipsb", "cmgi", "ubsgy", "lsgm", "imsb"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)\n\n{\n\n    uint32_t val;\n\n    val = gic_dist_readb(opaque, offset);\n\n    val |= gic_dist_readb(opaque, offset + 1) << 8;\n\n    return val;\n\n}\n", "idx": 1107, "substitutes": {"opaque": ["iopaque", "hopec", "iopace", "opec", "iopec", "opcode", "opace", "hoponymous", "operonymous", "ipaque", " opace", " opcode", "ipace", "opque", " opque", "comphole", "compacity", "operhole", "oponymous", "operacity", "opercode", " opec", " opacity", "iopque", "iphole", "hophole", "compaque", "compcode", "iponymous", "opacity", "ipec", "ophole", "hopaque", "operec", "ipque", " ophole", "operaque"], "offset": ["i", "phase", "attribute", "base", "loc", "error", "padding", "sector", "optional", "reference", "o", "begin", "operation", "p", "Offset", "location", "alpha", "bound", "reset", "off", "pos", "position", "parent", "slot", "length", "server", "initial", "port", "point", "target", "start", "layer", "image", "rot", "pointer", "f", "align", "online", "address", "set", "size", "addr", "emb", "entry", "index"], "val": ["eval", "all", "let", "value", "_", "base", "loc", "cond", "rt", "unit", "elt", "alt", "sel", "p", "pt", "Val", "valid", "ref", "fl", "key", "ind", "aval", "ol", "vol", "len", "v", "py", "vl", "pos", "el", "pc", "data", "slot", "il", "vals", "pre", "ot", "ee", "ay", "rot", "la", "VAL", "al", "arg", "rl", "vel", "sl", "bl", "x"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_overflow(void)\n\n{\n\n    const char *str = \"99999999999999999999999999999999999999999999\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, -ERANGE);\n\n    g_assert_cmpint(res, ==, ULLONG_MAX);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 1108, "substitutes": {"str": ["stri", "fr", "i", "cr", "res", "text", "r", "sr", "pr", "tr", "cs", "enc", "code", "ptr", "sec", "wr", "temp", "st", "exec", "arr", "dr", "input", "Str", "obj", "iter", "vec", "orig", "len", "wrap", "data", "txt", "sp", "expr", "kr", "STR", "hr", "rs", "prev", "start", "ix", "max", "cur", "frac", "ctr", "lc", "seq", "index", "br"], "endptr": ["endedptr", " endctr", "startpointer", "adpointer", "Endaddr", "endaddr", "EndPtr", "endctr", "adptr", " endPtr", "startproc", "startptr", "Endptr", " endproc", " endaddr", "endpointer", "adPtr", "Endpointer", " endpointer", "startPtr", "endedpointer", "endproc", "adaddr", "startctr", "startaddr", "endedctr", "endedproc", "endPtr"], "err": ["fr", "cr", "rr", "res", "gr", "req", "pr", "rh", "try", "error", "r", "rc", "grade", "code", "resp", "er", "rx", "Er", "arr", "rage", "dr", "ind", "var", "iter", "mr", "Error", "ler", "ise", "aster", "ar", "test", "acer", "ner", "result", "ace", "inc", "der", "ver", "lr", "ctr", "e", "msg", "order", "fe"]}}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "PXA2xxState *pxa255_init(unsigned int sdram_size)\n\n{\n\n    PXA2xxState *s;\n\n    int iomemtype, i;\n\n    DriveInfo *dinfo;\n\n\n\n    s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));\n\n\n\n    s->env = cpu_init(\"pxa255\");\n\n    if (!s->env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];\n\n\n\n    /* SDRAM & Internal Memory Storage */\n\n    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size,\n\n                    qemu_ram_alloc(NULL, \"pxa255.sdram\",\n\n                                   sdram_size) | IO_MEM_RAM);\n\n    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,\n\n                    qemu_ram_alloc(NULL, \"pxa255.internal\",\n\n                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);\n\n\n\n    s->pic = pxa2xx_pic_init(0x40d00000, s->env);\n\n\n\n    s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);\n\n\n\n    pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]);\n\n\n\n    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85);\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,\n\n                              s->pic[PXA2XX_PIC_MMC], s->dma);\n\n\n\n    for (i = 0; pxa255_serial[i].io_base; i ++)\n\n        if (serial_hds[i]) {\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n            serial_mm_init(pxa255_serial[i].io_base, 2,\n\n                           s->pic[pxa255_serial[i].irqn], 14745600/16,\n\n                           serial_hds[i], 1, 1);\n\n#else\n\n            serial_mm_init(pxa255_serial[i].io_base, 2,\n\n                           s->pic[pxa255_serial[i].irqn], 14745600/16,\n\n                           serial_hds[i], 1, 0);\n\n#endif\n\n        } else {\n\n            break;\n\n        }\n\n    if (serial_hds[i])\n\n        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],\n\n                        s->dma, serial_hds[i]);\n\n\n\n    s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]);\n\n\n\n    s->cm_base = 0x41300000;\n\n    s->cm_regs[CCCR >> 2] = 0x02000210;\t/* 416.0 MHz */\n\n    s->clkcfg = 0x00000009;\t\t/* Turbo mode active */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn,\n\n                    pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype);\n\n    register_savevm(NULL, \"pxa2xx_cm\", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);\n\n\n\n    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);\n\n\n\n    s->mm_base = 0x48000000;\n\n    s->mm_regs[MDMRS >> 2] = 0x00020002;\n\n    s->mm_regs[MDREFR >> 2] = 0x03ca4000;\n\n    s->mm_regs[MECR >> 2] = 0x00000001;\t/* Two PC Card sockets */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn,\n\n                    pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype);\n\n    register_savevm(NULL, \"pxa2xx_mm\", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);\n\n\n\n    s->pm_base = 0x40f00000;\n\n    iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn,\n\n                    pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->pm_base, 0x100, iomemtype);\n\n    register_savevm(NULL, \"pxa2xx_pm\", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);\n\n\n\n    for (i = 0; pxa255_ssp[i].io_base; i ++);\n\n    s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);\n\n    for (i = 0; pxa255_ssp[i].io_base; i ++) {\n\n        DeviceState *dev;\n\n        dev = sysbus_create_simple(\"pxa2xx-ssp\", pxa255_ssp[i].io_base,\n\n                                   s->pic[pxa255_ssp[i].irqn]);\n\n        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, \"ssi\");\n\n    }\n\n\n\n    if (usb_enabled) {\n\n        sysbus_create_simple(\"sysbus-ohci\", 0x4c000000,\n\n                             s->pic[PXA2XX_PIC_USBH1]);\n\n    }\n\n\n\n    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);\n\n    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);\n\n\n\n    s->rtc_base = 0x40900000;\n\n    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,\n\n                    pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);\n\n    pxa2xx_rtc_init(s);\n\n    register_savevm(NULL, \"pxa2xx_rtc\", 0, 0, pxa2xx_rtc_save,\n\n                    pxa2xx_rtc_load, s);\n\n\n\n    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);\n\n    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);\n\n\n\n    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);\n\n\n\n    /* GPIO1 resets the processor */\n\n    /* The handler can be overridden by board-specific code */\n\n    qdev_connect_gpio_out(s->gpio, 1, s->reset);\n\n    return s;\n\n}\n", "idx": 1119, "substitutes": {"sdram_size": ["sdram64address", "sdramlenSIZE", "sdram64SIZE", "sdramlenaddress", "sdram_length", "sdram67number", "sdram67adjust", "sdram_capacity", "sdmem_length", "sdram2length", "sdram64size", "sdram67capacity", "sdramlogcapacity", "sdmem_SIZE", "sdram_base", "sdmem_number", "sdramlogadjust", "sdmem_size", "sdmem_capacity", "sdramlognumber", "sdram67size", "sdram2size", "sdramlogsize", "sdramlensize", "sdmem_adjust", "sdramlenbase", "sdmem_base", "sdram_number", "sdram2SIZE", "sdram_address", "sdram_SIZE", "sdmem_address", "sdram_adjust", "sdram64base"], "s": ["uns", "conf", "d", "sum", "sa", "states", "ps", "sb", "sym", "state", "os", "f", "set", "js", "params", "l", "sites", "si", "is", "o", "qs", "y", "p", "ins", "stats", "data", "ses", "site", "scope", "args", "b", "sg", "u", "sync", "S", "r", "settings", "cs", "ssl", "south", "new", "m", "sq", "session", "status", "full", "service", "g", "server", "spec", "es", "gs", "t", "ss", "e", "sl", "ls", "xs", "fs", "socket", "su", "sets", "ts", "ns", "n", "ims", "services", "sys", "sie", "sf", "c", "rs", "in", "its"], "iomemtype": ["_eedesc", "iotemtype", "_untypes", "_umt", "_umdesc", "_emtype", "_undesc", "iotemtypes", "_emtypes", "_umtype", "_eet", "_umtypes", "iotemt", "iotemdesc", "iotunt", "_emdesc", "iotuntype", "_unt", "_untype", "iotuntypes", "_eetype", "iotundesc", "_emt", "_eetypes"], "i": ["hi", "chi", "r", "l", "si", "j", "n", "uri", "y", "p", "ci", "multi", "qi", "ind", "eni", "d", "m", "oi", "id", "mi", "z", "adi", "ri", "ini", "ii", "v", "bi", "x", "li", "iu", "ie", "ji", "c", "zi", "ix", "ai", "info", "mu", "t", "gi", "f", "b", "u", "ti", "ip", "ni", "e", "xi", "I", "phi", "yi", "index"], "dinfo": ["dinter", "dstatus", "rdinf", "minfo", "finfo", "dnstatus", "sdinter", "minter", "vdinfo", " dinf", "dninf", "finf", "vdinit", " dinter", "derror", "merror", "dbstatus", "dfi", "sdinfo", "sderror", "dobj", "dninfo", "mhelp", " dhelp", " dobj", "dnstate", " derror", "dhelp", "sdinf", "rdfi", "dstate", "vdinf", "dbinf", " dstate", "finit", "dinf", "dinit", "sdobj", "sdhelp", "dbstate", "sdfi", " dinit", "vderror", "rdobj", "rdinfo", " dstatus", "dbinfo", " dfi"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int usb_device_delete_addr(int busnr, int addr)\n\n{\n\n    USBBus *bus;\n\n    USBPort *port;\n\n    USBDevice *dev;\n\n\n\n    bus = usb_bus_find(busnr);\n\n    if (!bus)\n\n        return -1;\n\n\n\n    TAILQ_FOREACH(port, &bus->used, next) {\n\n        if (port->dev->addr == addr)\n\n            break;\n\n    }\n\n    if (!port)\n\n        return -1;\n\n\n\n    dev = port->dev;\n\n    TAILQ_REMOVE(&bus->used, port, next);\n\n    bus->nused--;\n\n\n\n    usb_attach(port, NULL);\n\n    dev->info->handle_destroy(dev);\n\n\n\n    TAILQ_INSERT_TAIL(&bus->free, port, next);\n\n    bus->nfree++;\n\n    return 0;\n\n}\n", "idx": 1121, "substitutes": {"busnr": ["bridgern", "pluginnb", "bridgenl", "usbrn", "buseno", "booteno", "bridgenor", "bootsn", "busnb", "bussn", "usbnor", "pluginsn", "portsn", "usbnl", "busrn", " busnor", "busnor", "bootnr", "plugineno", " busrn", " busnl", "pluginnr", "bootnb", "busnl", "portnb", "usbnr", "portnr", "bridgenr", "porteno"], "addr": ["host", "dd", "offset", "wd", "rr", "nm", "loc", "attr", "att", "hop", "rc", "ptr", "ord", "rt", "code", "uri", "sid", "rx", "at", "ref", "src", "alias", "adr", "dr", "name", "id", "route", "ad", "amd", "len", "mode", "pad", "vr", "prefix", "ext", "pos", "conn", "lan", "arm", "add", "eth", "ar", "aid", "nr", "layer", "ace", "oa", "inter", "amp", "ip", "address", "ange"], "bus": ["host", "cat", "feed", "mount", "cache", "lock", "home", "loop", "base", "bug", "io", "ac", "device", "pl", "lib", "vc", "p", "root", "BUS", "bridge", "bs", "session", "config", "se", "plug", "pod", "class", "ass", "pos", "service", "ash", "front", "usb", "parent", "bit", "us", "nt", "band", "self", "plugin", "pu", "board", "boot", "book", "block", "pack", "proc", "db", "os", "lab", "b", "ver", "this", "bas", "bin", "use", "bc", "http", "sync", "Bus"], "port": ["user", "host", "mount", "Port", "driver", "wd", "next", "ports", "part", "PORT", "bug", "pr", "project", "patch", "device", "hop", "po", "object", "option", "p", "pt", "pipe", "config", "proxy", "fat", "id", "per", "api", "pid", "step", "pod", "class", "cp", "trans", "pad", "contract", "type", "service", "pc", "prop", "parent", "pro", "forward", "pool", "pp", "pre", "export", "test", "point", "target", "plugin", "proc", "t", "op", "ver", "ip", "component", "address", "post", "pointer", "tag", "path", "art", "ort"], "dev": ["driver", "host", "user", "gu", "dd", "wd", "dist", "md", "av", "mod", "diff", "own", "cache", "bug", "od", "priv", "inst", "error", "device", "def", "fi", "conf", "ve", "debug", "DEV", "p", "ref", "mem", "fo", "comment", "d", "var", "cam", "name", "w", "pub", "ad", "adv", "prom", "v", "conn", "prop", "data", "pro", "Dev", "app", "test", "di", "flow", "info", "pu", "ch", " device", "der", "ver", "rad", " info", "ev", "dom", "desc"], "nused": ["Nusable", "nusable", "snusable", "snused", "snusage", " nusage", " nusable", "Nactive", "nactive", "nusage", "Nusage", "snactive", "Nused", " nactive"], "nfree": ["pavailable", "pFree", "pfree", "nusable", "nbavailable", " navailable", "nbFree", " nFree", "nbfree", "navailable", "pusable", "nbusable", " nusable", "nFree"]}}
{"project": "qemu", "commit_id": "7d5e199ade76c53ec316ab6779800581bb47c50a", "target": 0, "func": "static void qmp_output_type_number(Visitor *v, const char *name, double *obj,\n\n                                   Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qmp_output_add(qov, name, qfloat_from_double(*obj));\n\n}\n", "idx": 1122, "substitutes": {"v": ["uv", "gu", "val", "i", "vim", "value", "vis", "sv", "r", "l", "j", "o", "p", "d", "m", "var", "V", "w", "k", "tv", "g", "c", "lv", "self", "vi", "vs", "t", "b", "q", "u", "f", "e", "env", "iv", "x", "h", "vv"], "name": ["comment", "part", "ame", "common", "n", "num", "o", "nice", "key", "Name", "alias", "new", "names", "var", "word", "id", "w", "time", "named", "label", "a", "prefix", "type", "data", "parent", "info", "style", "f", "none", "NAME", "size", "x", "path", "desc"], "obj": ["fn", "offset", "rb", "bj", "ns", "po", "object", "orb", "j", "otype", "alt", "lib", "o", "pt", "tmp", "arr", "ref", "obb", "adj", "pos", "prefix", "foo", "func", "xy", "ob", "block", "cb", "eff", "Obj", "args", "oa", "objects", "os", "js", "emb", "bl", "Object", "so", "br"], "errp": ["ererror", " errerror", "erp", "errerror", "errf", "errc", "Ererror", " errf", " errc", "erf", "Erp", "Erf", "erc", "Erc"], "qov": ["quov", " qou", "fvo", "fovo", "idovo", "ixou", " qav", "quovo", "quav", "ixovan", "fov", "qav", "quvo", "ixov", "quou", "idova", "fova", "idvo", "ixav", "qou", "idov", "qovan", " qovan", "qvo", "quova", "quovan", "qova", "qovo"]}}
{"project": "qemu", "commit_id": "0e01b76e7cc43068f6b8cc05297f61539ccd5279", "target": 1, "func": "static int aio_write_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    int nr_iov, c;\n\n    int pattern = 0xcd;\n\n    struct aio_ctx *ctx = g_new0(struct aio_ctx, 1);\n\n\n\n    ctx->blk = blk;\n\n    while ((c = getopt(argc, argv, \"CqP:z\")) != -1) {\n\n        switch (c) {\n\n        case 'C':\n\n            ctx->Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            ctx->qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'z':\n\n            ctx->zflag = 1;\n\n            break;\n\n        default:\n\n\n            return qemuio_command_usage(&aio_write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n\n        return qemuio_command_usage(&aio_write_cmd);\n\n    }\n\n\n\n    if (ctx->zflag && optind != argc - 2) {\n\n        printf(\"-z supports only a single length parameter\\n\");\n\n\n        return 0;\n\n    }\n\n\n\n    if (ctx->zflag && ctx->Pflag) {\n\n        printf(\"-z and -P cannot be specified at the same time\\n\");\n\n\n        return 0;\n\n    }\n\n\n\n    ctx->offset = cvtnum(argv[optind]);\n\n    if (ctx->offset < 0) {\n\n        print_cvtnum_err(ctx->offset, argv[optind]);\n\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (ctx->offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               ctx->offset);\n\n        block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n\n\n        return 0;\n\n    }\n\n\n\n    if (ctx->zflag) {\n\n        int64_t count = cvtnum(argv[optind]);\n\n        if (count < 0) {\n\n            print_cvtnum_err(count, argv[optind]);\n\n\n            return 0;\n\n        }\n\n\n\n        ctx->qiov.size = count;\n\n        blk_aio_write_zeroes(blk, ctx->offset >> 9, count >> 9, 0,\n\n                             aio_write_done, ctx);\n\n    } else {\n\n        nr_iov = argc - optind;\n\n        ctx->buf = create_iovec(blk, &ctx->qiov, &argv[optind], nr_iov,\n\n                                pattern);\n\n        if (ctx->buf == NULL) {\n\n            block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n\n\n            return 0;\n\n        }\n\n\n\n        gettimeofday(&ctx->t1, NULL);\n\n        block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,\n\n                         BLOCK_ACCT_WRITE);\n\n\n\n        blk_aio_writev(blk, ctx->offset >> 9, &ctx->qiov,\n\n                       ctx->qiov.size >> 9, aio_write_done, ctx);\n\n    }\n\n    return 0;\n\n}", "idx": 1130, "substitutes": {"blk": ["plc", "clks", "blc", "blq", " blks", " blb", "plkk", "slok", "slk", "slsk", "blkt", "ilb", "brkt", "ilc", " blck", "BLks", "slK", "ilq", "slb", "clk", "Blck", "ilsk", "BLck", "blck", "Blsk", "Blkt", "clK", "plck", "slq", "blks", "Blkk", "blb", "plkt", "blsk", "plq", "Blks", "ilkt", "slkt", "slc", " blc", " blsk", "clok", "plk", "Blk", "plks", "blK", "ilk", "brk", "blok", "BLk", "BLkk", "brsk", " blkt", "brck", "blkk", "plb", "slks", " blok", " blK"], "argc": ["gl", "gv", "Arglc", " arglc", " argn", "argumentc", "arglc", "argumentv", " argl", " argp", "argsc", "argumentl", "argumentn", "gc", "axf", " argch", "axc", "argsl", "axp", "Argf", "gf", "argf", "agch", "memlc", "memc", "agc", "memv", "argch", "argsch", "agl", "agp", "Argv", "memf", " argf", "Argc", "Argl", "agv", "axv", "argsv", "axl", "argp", "argl", "Argn", "argn"], "argv": ["arkvs", " argb", "argumentc", "argvs", "argumentv", "argsp", " argl", "argp", " argp", "argsc", "argumentl", "argsf", "argV", "argsb", "axc", " argve", "axp", "Argf", "Argp", "argl", "Argve", "argsvs", "argf", "argumentb", " argvs", "Argb", "argb", "Argv", "argve", "arkc", "arkv", "arkp", "axve", " argf", "ArgV", "argumentV", "Argl", "axv", " argV", "argsv", "Argc", "argumentp"], "nr_iov": ["nr_nox", "NR_sbm", "nr_iop", "nr__iov", "nr_uni", "nr1iol", "nr_sbm", "nr__uni", "nr__iop", "NR_nox", "usr_iol", "nr__iol", "NR_ovi", "nr1iov", "nr_ovi", "usr_iov", "nr1uni", "nr1iop", "nr_iol", "usr_iop", "NR_iov", "usr_uni"], "c": ["cu", "i", "cc", "dc", "cit", "cr", "r", "cy", "sc", "cf", "ac", "l", "cmp", "cs", "enc", "code", "n", "o", "p", "ci", "ce", "ec", "xc", "d", "m", "k", "count", "v", "cp", "end", "pc", "ca", "g", "ch", "mc", "cb", "channel", "t", "b", "f", "q", "u", "cmd", "cur", "C", "e", "cm", "lc", "s"], "ctx": ["kb", "wx", "git", "all", "pkg", "cmp", "lib", "number", "qa", "sci", "cn", "anon", "auc", "jp", "block", "cb", "component", "bc", "s", "kw", "cal", "cc", "_", "fc", "conv", "vc", "ci", "exec", "seq", "qq", "xc", "config", "voc", "unc", "cv", "css", "wcs", "utils", "cas", "sync", "lc", "cus", "cu", "support", "r", "sc", "context", "cs", "chan", "cca", "cms", "sq", "acl", "obj", "cp", "conn", "g", "ctrl", "gs", "cmd", "out", "xs", "cm", "flags", "loc", "cf", "rc", "command", "fp", "connection", "cli", "id", "prefix", "sys", "ca", "console", "fw", "nc", "np", "tx", "ck", "instance", "cfg", "client", "hw", "anc"], "optind": ["extind", "extInd", "optionIND", "origInd", "octinn", "optnd", "optionnd", "optii", " optrib", "optionrib", "optionii", "optionend", "optina", "origrib", "opInd", "opnd", "optionina", "extinc", "ropnd", "optid", "origii", " optann", "parentInd", "origind", "optinn", "extid", "origIND", " optii", "optionind", "optint", "origann", "optann", "optIND", "optionInd", "optionid", "optimind", "optimint", "expinc", "ropina", "optiminc", "optimInd", "optioninc", "parentind", "octInd", "opina", "expInd", "extIND", "optinc", "parentinc", " optInd", "ropind", "optrib", "optionann", "optimIND", "optend", "opint", "ropInd", "parentinn", "optInd", "expIND", "opend", "optionint", "extinn", "octinc", "opinc", " optIND", "optimnd", "optimend", " optid", "opind", "expind", "octind"]}}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int alloc_refcount_block(BlockDriverState *bs,\n\n    int64_t cluster_index, uint16_t **refcount_block)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    unsigned int refcount_table_index;\n\n    int ret;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);\n\n\n\n    /* Find the refcount block for the given cluster */\n\n    refcount_table_index = cluster_index >> s->refcount_block_bits;\n\n\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n\n\n        uint64_t refcount_block_offset =\n\n            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n\n\n\n        /* If it's already there, we're done */\n\n        if (refcount_block_offset) {\n\n            if (offset_into_cluster(s, refcount_block_offset)) {\n\n                qcow2_signal_corruption(bs, true, -1, -1, \"Refblock offset %#\"\n\n                                        PRIx64 \" unaligned (reftable index: \"\n\n                                        \"%#x)\", refcount_block_offset,\n\n                                        refcount_table_index);\n\n                return -EIO;\n\n            }\n\n\n\n             return load_refcount_block(bs, refcount_block_offset,\n\n                 (void**) refcount_block);\n\n        }\n\n    }\n\n\n\n    /*\n\n     * If we came here, we need to allocate something. Something is at least\n\n     * a cluster for the new refcount block. It may also include a new refcount\n\n     * table if the old refcount table is too small.\n\n     *\n\n     * Note that allocating clusters here needs some special care:\n\n     *\n\n     * - We can't use the normal qcow2_alloc_clusters(), it would try to\n\n     *   increase the refcount and very likely we would end up with an endless\n\n     *   recursion. Instead we must place the refcount blocks in a way that\n\n     *   they can describe them themselves.\n\n     *\n\n     * - We need to consider that at this point we are inside update_refcounts\n\n     *   and potentially doing an initial refcount increase. This means that\n\n     *   some clusters have already been allocated by the caller, but their\n\n     *   refcount isn't accurate yet. If we allocate clusters for metadata, we\n\n     *   need to return -EAGAIN to signal the caller that it needs to restart\n\n     *   the search for free clusters.\n\n     *\n\n     * - alloc_clusters_noref and qcow2_free_clusters may load a different\n\n     *   refcount block into the cache\n\n     */\n\n\n\n    *refcount_block = NULL;\n\n\n\n    /* We write to the refcount table, so we might depend on L2 tables */\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Allocate the refcount block itself and mark it as used */\n\n    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n\n    if (new_block < 0) {\n\n        return new_block;\n\n    }\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Allocate refcount block %d for %\" PRIx64\n\n        \" at %\" PRIx64 \"\\n\",\n\n        refcount_table_index, cluster_index << s->cluster_bits, new_block);\n\n#endif\n\n\n\n    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n\n        /* Zero the new refcount block before updating it */\n\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n\n            (void**) refcount_block);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        memset(*refcount_block, 0, s->cluster_size);\n\n\n\n        /* The block describes itself, need to update the cache */\n\n        int block_index = (new_block >> s->cluster_bits) &\n\n            (s->refcount_block_size - 1);\n\n        (*refcount_block)[block_index] = cpu_to_be16(1);\n\n    } else {\n\n        /* Described somewhere else. This can recurse at most twice before we\n\n         * arrive at a block that describes itself. */\n\n        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,\n\n                              QCOW2_DISCARD_NEVER);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        /* Initialize the new refcount block only after updating its refcount,\n\n         * update_refcount uses the refcount cache itself */\n\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n\n            (void**) refcount_block);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        memset(*refcount_block, 0, s->cluster_size);\n\n    }\n\n\n\n    /* Now the new refcount block needs to be written to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);\n\n    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    /* If the refcount table is big enough, just hook the block up there */\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n        uint64_t data64 = cpu_to_be64(new_block);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);\n\n        ret = bdrv_pwrite_sync(bs->file,\n\n            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),\n\n            &data64, sizeof(data64));\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        s->refcount_table[refcount_table_index] = new_block;\n\n\n\n        /* The new refcount block may be where the caller intended to put its\n\n         * data, so let it restart the search. */\n\n        return -EAGAIN;\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    /*\n\n     * If we come here, we need to grow the refcount table. Again, a new\n\n     * refcount table needs some space and we can't simply allocate to avoid\n\n     * endless recursion.\n\n     *\n\n     * Therefore let's grab new refcount blocks at the end of the image, which\n\n     * will describe themselves and the new refcount table. This way we can\n\n     * reference them only in the new table and do the switch to the new\n\n     * refcount table at once without producing an inconsistent state in\n\n     * between.\n\n     */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);\n\n\n\n    /* Calculate the number of refcount blocks needed so far */\n\n    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size);\n\n\n\n    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {\n\n        return -EFBIG;\n\n    }\n\n\n\n    /* And now we need at least one block more for the new metadata */\n\n    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);\n\n    uint64_t last_table_size;\n\n    uint64_t blocks_clusters;\n\n    do {\n\n        uint64_t table_clusters =\n\n            size_to_clusters(s, table_size * sizeof(uint64_t));\n\n        blocks_clusters = 1 +\n\n            ((table_clusters + s->refcount_block_size - 1)\n\n            / s->refcount_block_size);\n\n        uint64_t meta_clusters = table_clusters + blocks_clusters;\n\n\n\n        last_table_size = table_size;\n\n        table_size = next_refcount_table_size(s, blocks_used +\n\n            ((meta_clusters + s->refcount_block_size - 1)\n\n            / s->refcount_block_size));\n\n\n\n    } while (last_table_size != table_size);\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Grow refcount table %\" PRId32 \" => %\" PRId64 \"\\n\",\n\n        s->refcount_table_size, table_size);\n\n#endif\n\n\n\n    /* Create the new refcount table and blocks */\n\n    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *\n\n        s->cluster_size;\n\n    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;\n\n    uint64_t *new_table = g_try_new0(uint64_t, table_size);\n\n    uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);\n\n\n\n    assert(table_size > 0 && blocks_clusters > 0);\n\n    if (new_table == NULL || new_blocks == NULL) {\n\n        ret = -ENOMEM;\n\n        goto fail_table;\n\n    }\n\n\n\n    /* Fill the new refcount table */\n\n    memcpy(new_table, s->refcount_table,\n\n        s->refcount_table_size * sizeof(uint64_t));\n\n    new_table[refcount_table_index] = new_block;\n\n\n\n    int i;\n\n    for (i = 0; i < blocks_clusters; i++) {\n\n        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);\n\n    }\n\n\n\n    /* Fill the refcount blocks */\n\n    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n\n    int block = 0;\n\n    for (i = 0; i < table_clusters + blocks_clusters; i++) {\n\n        new_blocks[block++] = cpu_to_be16(1);\n\n    }\n\n\n\n    /* Write refcount blocks to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);\n\n    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,\n\n        blocks_clusters * s->cluster_size);\n\n    g_free(new_blocks);\n\n    new_blocks = NULL;\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* Write refcount table to disk */\n\n    for(i = 0; i < table_size; i++) {\n\n        cpu_to_be64s(&new_table[i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);\n\n    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,\n\n        table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    for(i = 0; i < table_size; i++) {\n\n        be64_to_cpus(&new_table[i]);\n\n    }\n\n\n\n    /* Hook up the new refcount table in the qcow2 header */\n\n    uint8_t data[12];\n\n    cpu_to_be64w((uint64_t*)data, table_offset);\n\n    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);\n\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),\n\n        data, sizeof(data));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* And switch it in memory */\n\n    uint64_t old_table_offset = s->refcount_table_offset;\n\n    uint64_t old_table_size = s->refcount_table_size;\n\n\n\n    g_free(s->refcount_table);\n\n    s->refcount_table = new_table;\n\n    s->refcount_table_size = table_size;\n\n    s->refcount_table_offset = table_offset;\n\n\n\n    /* Free old table. */\n\n    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),\n\n                        QCOW2_DISCARD_OTHER);\n\n\n\n    ret = load_refcount_block(bs, new_block, (void**) refcount_block);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* If we were trying to do the initial refcount update for some cluster\n\n     * allocation, we might have used the same clusters to store newly\n\n     * allocated metadata. Make the caller search some new space. */\n\n    return -EAGAIN;\n\n\n\nfail_table:\n\n    g_free(new_blocks);\n\n    g_free(new_table);\n\nfail_block:\n\n    if (*refcount_block != NULL) {\n\n        qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n\n    }\n\n    return ret;\n\n}\n", "idx": 1136, "substitutes": {"bs": ["banks", "fs", "las", "base", "sync", "BS", "ns", "plugins", "cs", "pb", "bb", "fps", "bes", "ubs", "bps", "http", "blocks", "sa", "fb", "bos", "lbs", "bi", "stats", "css", "ses", "ks", "sb", "iss", "obs", "gb", "ob", "bh", "outs", "gs", "bytes", "abi", "cb", "locks", "vs", "db", "b", "os", "aws", "bas", "ss", "js", "ls", "bl", "bc", "lb", "ds", "bis", "bm"], "cluster_index": ["cluster00design", "clusteridoffset", "clusteridindex", "clue67label", "clusteridsize", "cluster00label", "clusterCindex", "cluster_height", "clusteridheight", "clusters_offset", "cluster_label", "cluster67offset", "cluster67number", "cluster_id", "cluster67size", "cluster67image", "cluster_offset", "cluster00number", "clue67number", "cluster_column", "clue67design", "clue_design", "clusterCimage", "clue_index", "clue67index", "cluster_design", "cluster67label", "cluster00index", "cluster67index", "cluster67design", "clusters_index", "clusterCoffset", "cluster_image", "clue_number", "cluster_number", "clusters_image", "cluster_size", "clue_label", "clusterCsize", "clusters_size"], "refcount_block": ["reflist64block", "refcount_view", "refcount00container", "reftype00block", "refcount\u00b7condition", "reflist64view", "refcount64lock", "refsize_header", "refcount_lock", "refcount64container", "refcount___section", "refount_block", "refcount64block", "refcount67header", "refcount___view", "refcount___block", "reftype00ver", "refcount_row", "refcountsblock", "refount_table", "reflist_section", "refcount00lock", "refcountslock", "refcount_table", "reftype_lock", "refsize_type", "refount_type", "refount_row", "refcount_type", "refcount_ver", "refcount64ver", "refcount00ver", "refount_condition", "refcount67type", "refcount64section", "refount_lock", "refcount64view", "reflist64container", "reflist_container", "reflist64section", "reftype_container", "reftype00container", "reftype_ver", "refcount_header", "refcount\u00b7block", "refsize_block", "refcount67block", "reftype_block", "refcount00block", "refcount_section", "refcount\u00b7row", "reflist_block", "refcountsrow", "refcount_container", "reflist_view", "refcount___container", "refcount_condition", "refcountscondition", "reftype00lock", "refcount\u00b7lock"], "s": ["S", "fs", "sv", "su", "sets", "comm", "ts", "ns", "settings", "l", "cs", "is", "si", "uns", "ims", "ssl", "qs", "south", "p", "less", "http", "ins", "sq", "status", "sa", "full", "services", "stats", "states", "service", "sie", "sys", "g", "css", "ps", "us", "ses", "spec", "secondary", "c", "site", "sb", "es", "rs", "iss", "self", "outs", "gs", "sym", "ks", "state", "vs", "t", "b", "f", "storage", "parts", "aws", "os", "ss", "js", "e", "sl", "ls", "bis", "its", "ds", "sync", "xs"], "refcount_table_index": ["refcount_cache_index", "refcount_tablePsize", "refcount_cache_data", "refcount_cache_level", "refcount_table_height", "refcount_table_i", "refcount_tablePindex", "refcount_table_ind", "refcount_table_length", "refcount_cache_length", "refcount_table_level", "refcount_cache_slice", "refcount_table_size", "refcount_table_data", "refcount_chain_size", "refcount_table_offset", "refcount_chain_position", "refcount_cache_size", "refcount_tablePheight", "refcount_chain_index", "refcount_table_position", "refcount_cache_ind", "refcount_table_slice", "refcount_cache_i", "refcount_cache_height", "refcount_chain_offset", "refcount_tablePlevel"], "ret": ["cat", "bf", "val", "rb", "let", "res", "value", "part", "back", " RET", "sr", "error", "match", "att", "rc", "def", "rt", "code", "flag", " Ret", "num", "hash", "alt", "lt", "pt", "fin", "RET", "ref", "mem", "det", "gt", "rev", "obj", "job", "red", "pub", "len", "reset", "count", "lit", "no", "end", "success", "ext", "rets", "conn", "feat", "reply", "mt", "fun", "nt", "reg", "info", "result", "arg", "Ret", "db", "last", "ft", "out", "re", "bit", "en", "art"]}}
{"project": "FFmpeg", "commit_id": "95801b6a0727d6f7e6f1204ce812b1e81613307d", "target": 1, "func": "static int alac_decode_frame(AVCodecContext *avctx,\n\n                             void *outbuffer, int *outputsize,\n\n                             const uint8_t *inbuffer, int input_buffer_size)\n\n{\n\n    ALACContext *alac = avctx->priv_data;\n\n\n\n    int channels;\n\n    unsigned int outputsamples;\n\n    int hassize;\n\n    int readsamplesize;\n\n    int wasted_bytes;\n\n    int isnotcompressed;\n\n    uint8_t interlacing_shift;\n\n    uint8_t interlacing_leftweight;\n\n\n\n    /* short-circuit null buffers */\n\n    if (!inbuffer || !input_buffer_size)\n\n        return input_buffer_size;\n\n\n\n    /* initialize from the extradata */\n\n    if (!alac->context_initialized) {\n\n        if (alac->avctx->extradata_size != ALAC_EXTRADATA_SIZE) {\n\n            av_log(avctx, AV_LOG_ERROR, \"alac: expected %d extradata bytes\\n\",\n\n                ALAC_EXTRADATA_SIZE);\n\n            return input_buffer_size;\n\n        }\n\n        if (alac_set_info(alac)) {\n\n            av_log(avctx, AV_LOG_ERROR, \"alac: set_info failed\\n\");\n\n            return input_buffer_size;\n\n        }\n\n        alac->context_initialized = 1;\n\n    }\n\n\n\n    init_get_bits(&alac->gb, inbuffer, input_buffer_size * 8);\n\n\n\n    channels = get_bits(&alac->gb, 3) + 1;\n\n    if (channels > MAX_CHANNELS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"channels > %d not supported\\n\",\n\n               MAX_CHANNELS);\n\n        return input_buffer_size;\n\n    }\n\n\n\n    /* 2^result = something to do with output waiting.\n\n     * perhaps matters if we read > 1 frame in a pass?\n\n     */\n\n    skip_bits(&alac->gb, 4);\n\n\n\n    skip_bits(&alac->gb, 12); /* unknown, skip 12 bits */\n\n\n\n    /* the output sample size is stored soon */\n\n    hassize = get_bits1(&alac->gb);\n\n\n\n    wasted_bytes = get_bits(&alac->gb, 2); /* unknown ? */\n\n\n\n    /* whether the frame is compressed */\n\n    isnotcompressed = get_bits1(&alac->gb);\n\n\n\n    if (hassize) {\n\n        /* now read the number of samples as a 32bit integer */\n\n        outputsamples = get_bits_long(&alac->gb, 32);\n\n        if(outputsamples > alac->setinfo_max_samples_per_frame){\n\n            av_log(avctx, AV_LOG_ERROR, \"outputsamples %d > %d\\n\", outputsamples, alac->setinfo_max_samples_per_frame);\n\n            return -1;\n\n        }\n\n    } else\n\n        outputsamples = alac->setinfo_max_samples_per_frame;\n\n\n\n    if(outputsamples > *outputsize / alac->bytespersample){\n\n        av_log(avctx, AV_LOG_ERROR, \"sample buffer too small\\n\");\n\n        return -1;\n\n    }\n\n\n\n    *outputsize = outputsamples * alac->bytespersample;\n\n    readsamplesize = alac->setinfo_sample_size - (wasted_bytes * 8) + channels - 1;\n\n\n\n    if (!isnotcompressed) {\n\n        /* so it is compressed */\n\n        int16_t predictor_coef_table[channels][32];\n\n        int predictor_coef_num[channels];\n\n        int prediction_type[channels];\n\n        int prediction_quantitization[channels];\n\n        int ricemodifier[channels];\n\n        int i, chan;\n\n\n\n        interlacing_shift = get_bits(&alac->gb, 8);\n\n        interlacing_leftweight = get_bits(&alac->gb, 8);\n\n\n\n        for (chan = 0; chan < channels; chan++) {\n\n            prediction_type[chan] = get_bits(&alac->gb, 4);\n\n            prediction_quantitization[chan] = get_bits(&alac->gb, 4);\n\n\n\n            ricemodifier[chan] = get_bits(&alac->gb, 3);\n\n            predictor_coef_num[chan] = get_bits(&alac->gb, 5);\n\n\n\n            /* read the predictor table */\n\n            for (i = 0; i < predictor_coef_num[chan]; i++)\n\n                predictor_coef_table[chan][i] = (int16_t)get_bits(&alac->gb, 16);\n\n        }\n\n\n\n        if (wasted_bytes)\n\n            av_log(avctx, AV_LOG_ERROR, \"FIXME: unimplemented, unhandling of wasted_bytes\\n\");\n\n\n\n        for (chan = 0; chan < channels; chan++) {\n\n            bastardized_rice_decompress(alac,\n\n                                        alac->predicterror_buffer[chan],\n\n                                        outputsamples,\n\n                                        readsamplesize,\n\n                                        alac->setinfo_rice_initialhistory,\n\n                                        alac->setinfo_rice_kmodifier,\n\n                                        ricemodifier[chan] * alac->setinfo_rice_historymult / 4,\n\n                                        (1 << alac->setinfo_rice_kmodifier) - 1);\n\n\n\n            if (prediction_type[chan] == 0) {\n\n                /* adaptive fir */\n\n                predictor_decompress_fir_adapt(alac->predicterror_buffer[chan],\n\n                                               alac->outputsamples_buffer[chan],\n\n                                               outputsamples,\n\n                                               readsamplesize,\n\n                                               predictor_coef_table[chan],\n\n                                               predictor_coef_num[chan],\n\n                                               prediction_quantitization[chan]);\n\n            } else {\n\n                av_log(avctx, AV_LOG_ERROR, \"FIXME: unhandled prediction type: %i\\n\", prediction_type[chan]);\n\n                /* I think the only other prediction type (or perhaps this is\n\n                 * just a boolean?) runs adaptive fir twice.. like:\n\n                 * predictor_decompress_fir_adapt(predictor_error, tempout, ...)\n\n                 * predictor_decompress_fir_adapt(predictor_error, outputsamples ...)\n\n                 * little strange..\n\n                 */\n\n            }\n\n        }\n\n    } else {\n\n        /* not compressed, easy case */\n\n        int i, chan;\n\n        for (i = 0; i < outputsamples; i++)\n\n            for (chan = 0; chan < channels; chan++) {\n\n                int32_t audiobits;\n\n\n\n                audiobits = get_bits_long(&alac->gb, alac->setinfo_sample_size);\n\n                audiobits = extend_sign32(audiobits, alac->setinfo_sample_size);\n\n\n\n                alac->outputsamples_buffer[chan][i] = audiobits;\n\n            }\n\n        /* wasted_bytes = 0; */\n\n        interlacing_shift = 0;\n\n        interlacing_leftweight = 0;\n\n    }\n\n    if (get_bits(&alac->gb, 3) != 7)\n\n        av_log(avctx, AV_LOG_ERROR, \"Error : Wrong End Of Frame\\n\");\n\n\n\n    switch(alac->setinfo_sample_size) {\n\n    case 16:\n\n        if (channels == 2) {\n\n            reconstruct_stereo_16(alac->outputsamples_buffer,\n\n                                  (int16_t*)outbuffer,\n\n                                  alac->numchannels,\n\n                                  outputsamples,\n\n                                  interlacing_shift,\n\n                                  interlacing_leftweight);\n\n        } else {\n\n            int i;\n\n            for (i = 0; i < outputsamples; i++) {\n\n                int16_t sample = alac->outputsamples_buffer[0][i];\n\n                ((int16_t*)outbuffer)[i * alac->numchannels] = sample;\n\n            }\n\n        }\n\n        break;\n\n    case 20:\n\n    case 24:\n\n        // It is not clear if there exist any encoder that creates 24 bit ALAC\n\n        // files. iTunes convert 24 bit raw files to 16 bit before encoding.\n\n    case 32:\n\n        av_log(avctx, AV_LOG_ERROR, \"FIXME: unimplemented sample size %i\\n\", alac->setinfo_sample_size);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    if (input_buffer_size * 8 - get_bits_count(&alac->gb) > 8)\n\n        av_log(avctx, AV_LOG_ERROR, \"Error : %d bits left\\n\", input_buffer_size * 8 - get_bits_count(&alac->gb));\n\n\n\n    return input_buffer_size;\n\n}\n", "idx": 1137, "substitutes": {"avctx": ["afcontext", "abca", "awcu", " avtx", "avcu", "abconfig", "awctx", "avconn", "afsci", "AVctx", "avclient", "avectx", "evconn", "navclient", "awcontext", "avcli", "aftx", "abctx", "afcu", "adtx", " avcontext", "avnas", "avalnas", "navconn", "avcmp", "awconfig", "avsci", "afca", "afnas", "afcas", "abcontext", "afcli", "navnas", "afclient", "AVsci", "avalctx", "avalsci", "afconn", "navcontext", "avtx", "adcontext", "navctx", "afcmp", "afctx", "avecontext", "evctx", "evcas", "abcu", "aveca", "avecu", "avcas", "evcontext", "avconfig", "AVcontext", "evclient", "avca", "avalcli", "adcas", "awconn", "avcontext", "awcas", "AVcmp", "avalcmp", "avalcontext", "adctx", " avcas", "navcli", "afconfig"], "outbuffer": ["bootwindow", " outheader", "Outwindow", "outbuf", "bootbuffer", "Outbuffer", "Outheader", " outwindow", "outheader", "bootbuf", "Outbuf", " outbuf", "outwindow", "bootheader"], "outputsize": ["blockSIZE", "inputSIZE", "blockSize", "writeSize", "inputsize", "outputSize", "writelength", "writesize", "outputlength", "blocklength", "inputSize", "blocksize", "inputlength", "writeSIZE", "outputSIZE"], "inbuffer": ["outqueue", "inputbuf", "conbuffer", "insidebuf", " inbuf", "outbuf", " inbuff", "insidebuff", " inqueue", "insidelength", "outsource", "Inbuffer", "inlength", "Inqueue", "conbuff", "conbuf", "Insource", "insidebuffer", "inputqueue", "insource", "inqueue", "inputbuffer", "inbuf", " insource", " inlength", "inbuff", "conlength"], "input_buffer_size": ["input_bufferpsize", "input_bufferpsmall", "input_buffer_depth", "input_bufferlexscale", "input_buffer_scale", "input_buf_cache", "input_byte_length", "input_buffer64capacity", "input_buffer00size", "input_file_depth", "input_bufferallsize", "input_bufferlexcache", "input_buffer_cache", "input_buffer00source", "input_batch_capacity", "input_bufferalllength", "input_buffer_large", "input_buffer64size", "input_buf_size", "input_buffer_small", "input_bufferalldepth", "input_buffer64width", "input_bufferlexsource", "input_buffer_source", "input_batch64size", "input_byte_size", "input_buffer_capacity", "input_buf_scale", "input_file_size", "input_buffer00large", "input_bufferpoffset", "input_file_source", "input_queue_width", "input_batch_width", "input_queue_size", "input_queue_small", "input_buffer_width", "input_batch64capacity", "input_byte_capacity", "input_buffer_SIZE", "input_batch_size", "input_buffer_length", "input_buf_source", "input_file_length", "input_bufferlexsize", "input_queue_offset", "input_queue_SIZE", "input_batch64width", "input_file_large", "input_buffer_offset"], "alac": ["calec", "alunc", "avang", "almc", "alact", "all", "avack", "elacl", "elunc", "elmac", "aliacc", "isalc", "ellacs", "ialacs", "realiac", "realac", "avacs", "dalack", " alunc", "salacc", "aliact", "advanc", "elliac", "eliac", "avacc", "ellanc", "isalacc", "elact", "ialax", "alioc", "isalac", " alact", "saloc", "alsax", "alidisc", " alacc", "galacs", "balac", "calain", "salacl", "malac", "this", "elacc", "alanc", "avmc", " alc", "elaco", "avmac", "avican", "_", "eldisc", "elac", "advack", "ialAC", "alack", "aldisc", " alec", "alain", "palmac", "eloc", " almc", "alican", "buf", "ilican", "alacc", " alAC", "baloc", "Alac", "alaco", "aloc", "alacs", "calacs", "avaut", "aliac", "feed", "galacc", "calaut", "palac", "advac", "attacc", "ellac", "realanc", "aliAC", "alAC", " alacl", " alacs", "ialac", "ilmac", " almac", " alaco", "palacc", "alsacc", "length", "avanc", "baliac", "Alacs", " alican", "advec", " alanc", " alang", "isalang", "alsac", "alec", "alc", "malAC", " alaut", "palanc", "salac", " aloc", "isalmc", "attain", "maloc", "calacc", "avac", "Aliac", "galax", "isalaco", "alang", "ilac", "maliac", "alaut", "almac", "ilanc", "advaut", "attac", "avain", "elc", "malacc", "dalaut", "alax", "dalanc", " alax", "calmac", "malunc", "alacl", "elAC", "attacs", "calac", "aliiac", "realacs", "calanc", " aliac", "isalmac", "baldisc", "alsacs", "Alax", "dalac", "Alanc", "elanc", "galac", "AlAC"], "channels": ["changuages", "bains", "chunks", " chrons", "pharms", "Channels", "CHannels", "CHains", "chrones", "bapters", "charains", "echannels", "phars", "Chrones", " chars", "chrons", "banguages", "charms", "charapters", "phannels", "chars", "echorts", "controns", "Chunks", "chorts", "echarms", " chrones", " charms", "CHapters", "Chrons", "charanguages", "charannels", "contrones", "contunks", "contannels", "chains", " chorts", "chapters", "phorts", "CHanguages", "bannels", "echars", " chunks"], "outputsamples": [" outputssomes", "inputsamples", "outputsomes", "outputpomes", "outputSamples", "outputsetsample", "outputdamples", " outputssamples", "outputsysomes", "responseportsamples", "outputinsamples", "outputpamples", "outputfamps", "outputSamps", "responseportsocks", "outputSample", "outputssamples", "outputfources", "outinsamples", "outputsamps", " outputssample", "inputpongs", "outputSongs", "inputsongs", "outputstringsources", "outputsucks", "outputinsances", "responseportsills", "outputdamps", "outputwsessions", "outputsetsamples", "outsamples", "outputsysamps", "responseportsources", "outputstringsamples", "outputwsamps", " outputssamps", "outputinsongs", "outputsysamples", " outputsomes", "outputportsocks", "outputssamps", " outputsamps", "outinsances", "outputsances", " outputsucks", "responsesources", "outputstringsills", "outputpances", "outinsamps", "outsances", "outputinsamps", "outsongs", "outputsysample", "outputsocks", "outputsetsongs", " outputsample", "outputportsamples", " outputsessions", "outputpongs", "outputdessions", "responsesamples", "inputpample", "inputsample", " outputfamples", "outputwsamples", "outinsongs", "outputssomes", "outputfills", "outputsills", "outputwsucks", "outputstringsocks", "outputsessions", "outputpamps", "outputducks", "outputpample", "outputfocks", "outputportsills", "outputportsources", "outputssample", "outputsources", "inputpamples", " outputfamps", "outsamps", "outputfucks", "outputsample", " outputfucks", "outputfamples", "outputfessions", "outputSances", "responsesocks", "responsesills", "outputsongs", " outputfessions"], "hassize": ["hassesize", "hassessize", "Hassizes", "chassense", "Harsize", "hacksizable", "hantssize", "chassizable", "halsizable", "halsense", "Harsizes", "chassesizable", "chassesense", "hyasssize", "hassesization", "harsense", "hassesolve", "hassization", "hantsize", "hassesense", "halsize", "hyantsize", "Harsizable", "hyantsolve", "hyassolve", "hactsize", "hactsizable", "hattsize", "hasssize", "harssize", "hyantsization", "harsizable", "hacksizes", "chassesize", "hassense", "hassesizable", "Hassize", "hattssize", "hassizes", "chasssize", "harsizes", "harsizing", "halssize", "hassolve", "hattsolve", "hacksizing", "hyassization", "hacksize", "hantsization", "Hassizable", "hyassize", "hantsolve", "hassizable", "hactsizes", "hassizing", "hyantssize", "Hassizing", "chassessize", "chassize", "hactsizing", "Harsizing", "hattsization", "harsize"], "readsamplesize": ["wourcesizer", "wsamplesize", "wsourcesized", "wsamplesized", "wourcesize", "wsourcesizer", "wsamplesIZE", "wviewsized", "wourcesized", "wviewsizer", "wsourcesize", "wamplesize", "wamplesized", "wviewsize", "wamplesIZE", "wourcesIZE", "wsourcesIZE", "wsamplesizer", "wamplesizer", "wviewsIZE"], "wasted_bytes": ["wanted_bytes", "wanted_pieces", "wasted__pieces", "wasted_blocks", "wasted_codes", "wanted_codes", "wasted_seconds", "wastered_seconds", "wanted_bits", "wastered_bits", "wasted__codes", "wastered_bytes", "wasted_bits", "wasted__bits", "wasted_pieces", "wastered_blocks", "wasted__bytes"], "isnotcompressed": ["isnotsuppress", "isnotcomposed", "isnotcondosed", "isnotexpacted", "isnotparressed", "isnotCompressed", "isnotsuppressed", "isnotexposed", "isnotcomplied", "isnotparression", "isnotparress", "isnotcompacted", "isnotcondression", "isnotcondressed", "isnotCompression", "isnotCompacted", "isnotComplied", "isnotsupplied", "isnotexpression", "isnotComposed", "isnotcompression", "isnotparlied", "isnotsuppression", "isnotcompress", "isnotcondacted", "isnotexpressed", "isnotCompress"], "interlacing_shift": ["interlacing_align", "interlating_align", "interlacing_reset", "interlating_reset", "interlacing___offset", "interlating_shift", "interlacing___shift", "interlacing___reset", "interlacing_offset", "interlacing___align", "interlating_offset"], "interlacing_leftweight": ["interlacing_lowwp", "interlacing_leftshift", "interlacing_lwp", "interlacing_pushshift", "interlacing_lowshift", "interlacing_lshift", "interlacing_leftw", "interlacing_pushweight", "interlacing_lweight", "interlacing_lw", "interlacing_leftwp", "interlacing_pushwp", "interlacing_lowweight", "interlacing_pushw", "interlacing_loww"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int getopt(int argc, char *argv[], char *opts)\n\n{\n\n    static int sp = 1;\n\n    int c;\n\n    char *cp;\n\n\n\n    if (sp == 1)\n\n        if (optind >= argc ||\n\n            argv[optind][0] != '-' || argv[optind][1] == '\\0')\n\n            return EOF;\n\n        else if (!strcmp(argv[optind], \"--\")) {\n\n            optind++;\n\n            return EOF;\n\n        }\n\n    optopt = c = argv[optind][sp];\n\n    if (c == ':' || (cp = strchr(opts, c)) == NULL) {\n\n        fprintf(stderr, \": illegal option -- %c\\n\", c);\n\n        if (argv[optind][++sp] == '\\0') {\n\n            optind++;\n\n            sp = 1;\n\n        }\n\n        return '?';\n\n    }\n\n    if (*++cp == ':') {\n\n        if (argv[optind][sp+1] != '\\0')\n\n            optarg = &argv[optind++][sp+1];\n\n        else if(++optind >= argc) {\n\n            fprintf(stderr, \": option requires an argument -- %c\\n\", c);\n\n            sp = 1;\n\n            return '?';\n\n        } else\n\n            optarg = argv[optind++];\n\n        sp = 1;\n\n    } else {\n\n        if (argv[optind][++sp] == '\\0') {\n\n            sp = 1;\n\n            optind++;\n\n        }\n\n        optarg = NULL;\n\n    }\n\n\n\n    return c;\n\n}\n", "idx": 1145, "substitutes": {"argc": [" arglc", "axdc", "arglc", " argn", "axn", "argpc", "arkci", "cmddc", "axct", "cmdn", "cmdc", "axpc", "axf", " argci", " argdc", "axc", "arkpc", "agf", " argct", "argct", "aglc", "argci", "argf", "cmdct", "axci", "arkc", " argf", "agv", "arklc", "axv", "agc", "argdc", " argpc", "axlc", "argn"], "argv": ["optv", "catv", "agve", "argumentc", "paramv", "arkf", "paramc", "argvs", "Argvs", "argumentv", "argsp", " argl", "argp", " argp", "argver", " argver", "argsc", "catve", "agvs", "argsf", "argV", "axf", "axver", "paramvs", "axc", "agf", "argsl", "axp", "optp", "Argf", "Argp", "argumentf", "argl", "axsv", "Argve", "catvs", "argumentver", "axvs", "arkl", "argf", "catf", "Argsv", " argsv", " argvs", "argssv", "paramsv", "Argv", "argve", "ArgV", "paramf", "argumentV", "arkv", " argf", "optc", "Argl", "arkc", "agv", "axv", " argV", "argsv", "optl", "Argc", "argumentp"], "opts": ["opTS", "optionters", "copcs", "OPcs", "ipters", "otts", "operts", "ottes", "ipTS", "copts", "copoptions", "OPters", "opercs", "opoptions", "optioncs", "OPTS", "operoptions", "ipcs", "coptes", "optes", "OPts", "otcs", "optionTS", "optionts", "opcs", "opters", "opertes", "otoptions", "ipts"], "c": ["cat", "line", "cu", "i", "cc", "bc", "dc", "cr", "cit", "r", "cy", "sc", "cf", "ac", "l", "cpp", "cmp", "chain", "cs", "ctx", "code", "n", "o", "vc", "p", "ci", "ce", "xc", "d", "m", "config", "k", "tc", "count", "con", "v", "end", "pc", "co", "coll", "cn", "nc", "ch", "csv", " pc", "col", "t", "b", "f", "cl", "err", "cmd", " rc", "C", "e", "ct", "cm", "h", "lc", "s", "cd"], "cp": ["cat", "cr", "tp", "mp", "bp", "cf", "cpp", "cmp", "cs", "pb", "ctx", "yp", "ep", "p", "ci", "fp", "gp", "CP", "wp", "pe", "conn", "pc", "ype", "ph", "pp", "ap", "np", "jp", "ch", "pn", "cb", "col", "csv", "proc", "hp", "pointer", "cmd", "op", "cd", "ip", "esp", "cop", "cm", "pg"], "optind": ["optionnd", "octend", "optina", " optinn", "optinst", "optinit", "optionina", "mpina", "vertnd", "mpIND", "varind", "optionind", "optann", "optioninder", "optinder", "optimint", "optstart", "optimInd", "propinn", "optnt", "optionnt", "optionann", " optinder", "optimIND", "rootIND", "mpind", "octinc", "optimstart", "optimii", "argina", "optionIND", "optionii", "optionini", "optimann", "optimnt", "mpInd", "optiss", "vertind", " optnt", " optii", "optint", "optionid", "rootini", "expinc", "optiminc", "expInd", "optioninn", " optInd", " optinst", "optInd", "varint", "optiminst", "optiminn", "optiminit", "optioninit", "expid", "optnd", "octinn", "combdir", "optionend", "optid", "argInd", "altind", "propind", "combind", "optionstart", "optioninc", "combstart", "octii", "octInd", "optend", " optinit", "propid", "optimiss", "optimid", "propInd", "optimdir", "octind", "optii", "optimini", "rootInd", " optann", "optinn", "argIND", "altend", "vertann", "altiss", "rootind", "vertint", " optend", "optIND", "optionInd", "combint", "optimind", "varinder", " optint", "optiondir", "optdir", "optinc", "optioninst", "optioniss", "optionint", "optimnd", "argind", "optimend", "expind", "optini", "altint"], "sp": ["i", "spot", "SP", "yp", "opt", "wp", "sn", "sci", "jp", "cap", "gap", "f", "space", "page", "osp", "sv", "inst", "isp", "si", "st", "p", "ep", "ind", "html", " sc", "se", "gp", "spe", "pos", "ph", "pp", "scope", "click", " SP", "style", "sg", "serv", "spl", "sk", "ct", "sup", "bsp", "pg", "line", "tp", "ny", "sc", " esp", "bp", "ptr", "sh", "slice", "pc", "service", "ap", "pre", "amp", "ip", "ss", "sl", "sw", "loc", "j", "pl", "pt", "fp", "sy", "Sp", "pe", "skip", "py", "type", "sf", "nc", "np", "start", "asp", "span", "esp"]}}
{"project": "qemu", "commit_id": "6240d6467077a12c24878bab645d8e2983e4975a", "target": 0, "func": "static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr,\n\n                                    uint32_t val)\n\n{\n\n    SLAVIO_TIMERState *s = opaque;\n\n    uint32_t saddr;\n\n    int reload = 0;\n\n\n\n    DPRINTF(\"write \" TARGET_FMT_plx \" %08x\\n\", addr, val);\n\n    saddr = (addr & TIMER_MAXADDR) >> 2;\n\n    switch (saddr) {\n\n    case TIMER_LIMIT:\n\n        if (slavio_timer_is_user(s)) {\n\n            // set user counter MSW, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = TIMER_MAX_COUNT64;\n\n            DPRINTF(\"processor %d user timer reset\\n\", s->slave_index);\n\n            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);\n\n        } else {\n\n            // set limit, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = val & TIMER_MAX_COUNT32;\n\n            if (!s->limit)\n\n                s->limit = TIMER_MAX_COUNT32;\n\n            ptimer_set_limit(s->timer, s->limit >> 9, 1);\n\n        }\n\n        break;\n\n    case TIMER_COUNTER:\n\n        if (slavio_timer_is_user(s)) {\n\n            // set user counter LSW, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = TIMER_MAX_COUNT64;\n\n            DPRINTF(\"processor %d user timer reset\\n\", s->slave_index);\n\n            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);\n\n        } else\n\n            DPRINTF(\"not user timer\\n\");\n\n        break;\n\n    case TIMER_COUNTER_NORST:\n\n        // set limit without resetting counter\n\n        s->limit = val & TIMER_MAX_COUNT32;\n\n        if (!s->limit)\n\n            s->limit = TIMER_MAX_COUNT32;\n\n        ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload);\n\n        break;\n\n    case TIMER_STATUS:\n\n        if (slavio_timer_is_user(s)) {\n\n            // start/stop user counter\n\n            if ((val & 1) && !s->running) {\n\n                DPRINTF(\"processor %d user timer started\\n\", s->slave_index);\n\n                ptimer_run(s->timer, 0);\n\n                s->running = 1;\n\n            } else if (!(val & 1) && s->running) {\n\n                DPRINTF(\"processor %d user timer stopped\\n\", s->slave_index);\n\n                ptimer_stop(s->timer);\n\n                s->running = 0;\n\n            }\n\n        }\n\n        break;\n\n    case TIMER_MODE:\n\n        if (s->master == NULL) {\n\n            unsigned int i;\n\n\n\n            for (i = 0; i < s->num_slaves; i++) {\n\n                if (val & (1 << i)) {\n\n                    qemu_irq_lower(s->slave[i]->irq);\n\n                    s->slave[i]->limit = -1ULL;\n\n                }\n\n                if ((val & (1 << i)) != (s->slave_mode & (1 << i))) {\n\n                    ptimer_stop(s->slave[i]->timer);\n\n                    ptimer_set_limit(s->slave[i]->timer,\n\n                                     LIMIT_TO_PERIODS(s->slave[i]->limit), 1);\n\n                    DPRINTF(\"processor %d timer changed\\n\",\n\n                            s->slave[i]->slave_index);\n\n                    ptimer_run(s->slave[i]->timer, 0);\n\n                }\n\n            }\n\n            s->slave_mode = val & ((1 << s->num_slaves) - 1);\n\n        } else\n\n            DPRINTF(\"not system timer\\n\");\n\n        break;\n\n    default:\n\n        DPRINTF(\"invalid write address \" TARGET_FMT_plx \"\\n\", addr);\n\n        break;\n\n    }\n\n}\n", "idx": 1167, "substitutes": {"opaque": ["opa", "iopaque", "OPacs", "copaque", "iopacs", "copctx", "copa", "opacs", "iopacity", "OPctx", "opque", " opque", "OPa", "oque", "oaques", " opaques", " opacity", "opaques", "iopque", "copacs", "iopa", "oaque", "oacity", "OPaque", "opacity", "iopaques", "iopctx", "opctx"], "addr": ["host", "dd", "offset", "mac", "r", "attr", "loc", "hop", "ptr", "ord", "rt", "code", "sid", "alt", "rx", "src", "dr", "adr", "sta", "tz", "ad", "xp", "ld", "len", "vr", "pos", "conn", "pc", "fd", "str", "data", "afi", "eth", "mt", "ast", "ar", "url", "asm", "ace", "cap", "oa", "amp", "align", "ip", "address", "ss", "sl", "x", "pointer", "seq"], "val": ["eval", "cal", "all", "value", "vt", "base", "def", "grad", "ctx", "num", "elt", "alt", "sel", "pt", "valid", "Val", "exec", "ref", "arr", "mem", "fl", "byte", "ind", "aval", "split", "delay", "min", "pal", "ret", "ol", "vol", "len", "dim", "count", "lit", "v", "el", "data", "slot", "vals", "reg", "test", "sol", "util", "pol", "local", "nil", "VAL", "al", "arg", "cl", "live", "sl", "bl", "x", "seq", "index"], "s": ["uns", "conf", "er", "d", "sa", "an", "v", "states", "ps", "sb", "sym", "os", "f", "parts", "js", "l", "sites", "is", "si", "o", "qs", "y", "p", "less", "ses", "site", "b", "u", "sg", "ops", "sync", "h", "S", "r", "settings", "hs", "cs", "ssl", "south", "ips", "new", "m", "session", "status", "w", "full", "service", "g", "your", "server", "spec", "es", "gs", "t", "aws", "ss", "e", "sl", "ls", "http", "ds", "xs", "request", "hm", "fs", "ms", "su", "sets", "ts", "ns", "n", "a", "services", "sie", "sys", "c", "rs", "self", "its", "en"], "saddr": ["nsval", "pvar", "sinproxy", "sbproxy", "sbcoord", "sinaddr", "Shop", "paddr", "scoord", "paddress", " sval", " sconn", "daddress", "pval", "sval", "daddr", "dhop", "sadd", " saddress", "saddress", "sbaddr", "Sconn", "Saddress", "nsvar", "dconn", "sproxy", "sinadd", " svar", "sconn", "Saddr", " sproxy", "nsaddr", "nsaddress", " shop", "sincoord", "shop", " sadd", "sbadd", " scoord", "svar"]}}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "void qemu_cpu_kick(void *env)\n\n{\n\n    return;\n\n}\n", "idx": 1194, "substitutes": {"env": ["eval", "device", "ptr", "context", "ctx", "core", "p", "exec", "param", "ec", "node", "config", "buffer", "buf", " environment", "console", "port", "nc", "scope", "global", "proc", "dev", "e", "environment", "iv", "ev", "en", "h"]}}
{"project": "qemu", "commit_id": "b591dc59bc98ee558db4ca512aa117748ebfdeef", "target": 0, "func": "static void temp_allocate_frame(TCGContext *s, int temp)\n\n{\n\n    TCGTemp *ts;\n\n    ts = &s->temps[temp];\n\n    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);\n\n    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)\n\n        tcg_abort();\n\n    ts->mem_offset = s->current_frame_offset;\n\n    ts->mem_reg = s->frame_reg;\n\n    ts->mem_allocated = 1;\n\n    s->current_frame_offset += sizeof(tcg_target_long);\n\n}\n", "idx": 1215, "substitutes": {"s": ["times", "S", "i", "fs", "ms", "sv", "sets", "su", "ns", "hs", "cs", "si", "is", "n", "ssl", "qs", "p", "less", "ins", "d", "m", "sq", "se", "session", "bs", "ans", "v", "services", "sys", "states", "service", "g", "css", "ps", "us", "ses", "ks", "spec", "c", "rs", "sb", "es", "self", "sf", "site", "gs", "sym", "t", "os", "f", "b", "sg", "this", "u", "ss", "js", "e", "ls", "sl", "tests", "ops", "ds", "as", "sync", "xs"], "temp": ["i", "dc", "cache", "base", "ex", "n", "num", "pt", "tmp", "p", "wait", "new", "key", "pipe", " temporary", "iter", "tem", "w", "Tem", "orig", "fake", "tc", "v", "py", "type", "fd", "clean", "Temp", "flat", "parent", "emp", "c", "test", "now", "atom", "porary", "local", "perature", "t", "level", "timeout", "empty", "stable"], "ts": ["times", "tm", "ags", "fs", "tp", "ms", "uts", "Ts", "ns", "hs", "tr", "ta", "cs", "tt", "types", "ims", "te", "qs", "tis", "ras", "als", "tf", "bs", "tz", "tk", "ds", "acs", "tc", "TS", "stats", "tn", "ents", "css", "ps", "ks", "rs", "ats", "es", "points", "test", "outs", "gs", "tx", "ters", "t", "as", "ments", "ss", "js", "ls", "atts", "xs", "tes"]}}
{"project": "qemu", "commit_id": "c83c66c3b58893a4dc056e272822beb88fe9ec7f", "target": 0, "func": "void qmp_block_stream(const char *device, bool has_base,\n\n                      const char *base, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (base_bs == NULL) {\n\n            error_set(errp, QERR_BASE_NOT_FOUND, base);\n\n            return;\n\n        }\n\n    }\n\n\n\n    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n\n     * underneath us.\n\n     */\n\n    drive_get_ref(drive_get_by_blockdev(bs));\n\n\n\n    trace_qmp_block_stream(bs, bs->job);\n\n}\n", "idx": 1227, "substitutes": {"device": ["driver", "model", "mount", "serial", "user", "dc", "home", "android", "mac", "mobile", "project", "de", "disk", "unit", "root", "remote", "module", "node", "d", "product", "buffer", "element", "engine", "mode", "conn", "type", "service", "server", "package", "port", "devices", "target", "di", "plugin", "image", "phy", "block", "Device", "feature", "dev", "ip", "address", "component"], "has_base": [" has_data", "has_cache", " has_cache", "has_data"], "base": ["model", "family", "cache", "home", "part", "mac", "back", "common", "chain", "binary", "unit", "absolute", "core", "builder", "root", "proxy", "name", "id", "buffer", "api", "bare", "area", "fake", "bot", "mode", "ase", "bi", "prefix", "type", "based", "file", "Base", "parent", "server", "site", "url", "plugin", "kit", "block", "image", "state", "local", "db", "b", "bu", "pa", "address", "bas", "bid", "client", "sync", "lc", "source"], "errp": [" errps", "acerpa", "rrr", "norr", "erb", "errr", "erps", " errf", "norb", "errorP", "erP", "errP", "errb", "erpa", "errpc", "acerr", "erp", "acerf", "norp", " errpc", "acerp", " errP", "rrf", "errorpc", "erpc", "errf", "errorps", "norpa", " errpa", " errr", "err", "errpa", "erf", "errorp", "rrp", "errps", "rrb", " errb"], "bs": ["banks", "fs", "las", "android", "BS", "ns", "ts", "bid", "cs", "pb", "bb", "plugins", "bes", "bd", "null", "bits", "bo", "bps", "ins", "obj", "bing", "blocks", "fb", "ba", "bos", "bot", "bus", "bi", "pos", "eb", "css", "ps", "us", "ses", "sb", "rs", "iss", "gb", "bh", "gs", "bytes", "block", "cb", "vs", "db", "b", "os", "bas", "ss", "js", "ls", "bl", "bc", "lb", "ds", "bis", "sync", "bu", "s", "br"], "base_bs": [" base_cb", "base_b", " base_vs", "base_cb", " base_ls", " base_android", "base_cs", " base_cs", " base_base", " base_bas", "base_vs", "base_bas", "base_android", "base_base", " base_b", "base_ls"], "local_err": ["local2req", "local_tx", " local_Er", "remote_err", "local2err", "local_Er", " local_tx", "self_err", " local_error", "local_req", "remote_status", "local_dr", " local_req", "locallytx", "remote_error", "local_cr", "local_rr", "local2Er", "locallyerr", "locallycr", "local_error", " local_cr", "self_dr", "self_error", "self_rr", "local_status", "locallyerror"]}}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "static void mptsas_scsi_init(PCIDevice *dev, Error **errp)\n\n{\n\n    DeviceState *d = DEVICE(dev);\n\n    MPTSASState *s = MPT_SAS(dev);\n\n\n\n    dev->config[PCI_LATENCY_TIMER] = 0;\n\n    dev->config[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n\n                          \"mptsas-mmio\", 0x4000);\n\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n\n                          \"mptsas-io\", 256);\n\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n\n                          \"mptsas-diag\", 0x10000);\n\n\n\n    if (s->msi != ON_OFF_AUTO_OFF &&\n\n        msi_init(dev, 0, 1, true, false) >= 0) {\n\n        /* TODO check for errors */\n\n        s->msi_in_use = true;\n\n    }\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n\n\n    if (!s->sas_addr) {\n\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n\n    }\n\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n\n\n    QTAILQ_INIT(&s->pending);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n\n    }\n\n}\n", "idx": 1277, "substitutes": {"dev": ["driver", "md", "mod", "serial", "dd", "gu", "comment", "dc", "home", "diff", "die", "req", "od", "r", "bug", "error", "device", "def", "de", "grad", "conf", "temp", "ve", "debug", "DEV", "valid", "dm", "config", "cam", "DC", "w", "pub", "ad", "engine", "dim", "prom", "bus", "v", "conn", "g", "data", "pro", "dn", "development", "spec", "Dev", "app", "devices", "self", "dt", "gd", "di", "prof", "info", "ch", "Device", "db", "dem", "der", "f", "cmd", "ver", "rad", "ds", "ev", "hw", "dom"], "errp": [" errps", "errP", "errr", "ErP", "rr", "Err", " errr", "Erps", " errP", "rp", "Erp", "rP", "rps", "errps"], "d": ["dd", "i", "dc", "Ds", "de", "n", "p", "pd", "dm", "m", "w", "ad", "D", "g", "dn", "c", "dt", "dh", "t", "db", "sd", "f", " dd", "dp", "e", "ds", "cd"], "s": ["driver", "i", "req", "uns", "conf", "er", "an", "v", "sp", "sb", "sym", "os", "f", "this", "js", "params", "sv", "secure", "l", "si", "is", "docker", "o", "y", "p", "less", "details", "se", "stats", "data", "ses", "site", "scope", "args", "sd", "b", "sg", "u", "serv", "side", "sk", "sync", "h", "S", "com", "r", "settings", "cs", "sh", "ssl", "south", "new", "m", "sq", "session", "bs", "w", "full", "service", "g", "your", "server", "spec", "ks", "es", "gs", "t", "native", "aws", "ss", "e", "sl", "ls", "http", "ds", "request", "sw", "fs", "su", "ts", "ns", "api", "k", "services", "sys", "sf", "c", "rs", "self", "vs", "storage", "tests", "client"]}}
{"project": "qemu", "commit_id": "e0891bd8bfd3349fc3fecde30e51900059f53f11", "target": 0, "func": "static inline int num_effective_busses(XilinxSPIPS *s)\n\n{\n\n    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&\n\n            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;\n\n}\n", "idx": 1290, "substitutes": {"s": ["S", "i", "fs", "r", "sets", "ts", "ns", "cs", "is", "ssl", "qs", "o", "south", "p", "rates", "events", "ips", "new", "m", "sq", "opens", "ops", "services", "a", "sys", "stats", "service", "g", "ps", "server", "ses", "secondary", "spec", "c", "rs", "sb", "es", "self", "sym", "t", "b", "f", "os", "ss", "js", "e", "sl", "http", "ds", "sync"]}}
{"project": "FFmpeg", "commit_id": "04dcdc464087eece349f30db42bab903cd077778", "target": 1, "func": "FFTContext *av_fft_init(int nbits, int inverse)\n\n{\n\n    FFTContext *s = av_malloc(sizeof(*s));\n\n\n\n    if (s && ff_fft_init(s, nbits, inverse))\n\n        av_freep(&s);\n\n\n\n    return s;\n\n}\n", "idx": 1307, "substitutes": {"nbits": [" nblocks", " nframes", "numblocks", " npieces", "nsbits", "nsframes", "numpieces", "nspieces", "numits", "Nblocks", "numframes", "numbits", "Nbits", "nblocks", "nits", "nframes", "Nits", " nits", "npieces"], "inverse": [" invert", "insverted", "Inverse", "Invert", "Inverted", "Inreverse", "ninreverse", "Invers", "invert", " inverted", "ninverse", "inreverse", "invers", "ninvers", "insvert", "insverse", "insreverse", "inverted", "insvers", "ninvert"], "s": ["S", "i", "fs", " changes", "r", "sync", "ts", "ns", "settings", "hs", "cs", "si", "ctx", "n", "conf", "ssl", "o", " cs", "south", "p", "als", "d", "m", "sq", "session", "ings", "w", "opens", "ches", "v", "a", "services", "func", "service", "g", " services", " c", "ps", "ses", "sf", "c", "sb", "rs", "es", "spec", "secondary", "scope", " ads", "gs", "local", "args", "os", "t", "b", "sg", "f", "u", "aws", " caps", "ss", "js", "e", "sl", "ls", "its", " is", "ds", "h"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_set_CF_bit31(TCGv var)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_shri_i32(tmp, var, 31);\n\n    gen_set_CF(tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 1308, "substitutes": {"var": ["mod", "cat", "r", "attr", "inst", "cf", "ptr", "array", "bb", "grad", "temp", "car", "vc", "opt", "tmp", "usr", "root", "dr", "name", "rf", "vm", "orig", "pad", "v", "func", "data", "comp", "prev", "vari", "variable", "feature", "dev", "Var", "err", "cur", "ver", "addr", "ctr", "vv"]}}
{"project": "FFmpeg", "commit_id": "89325417e7b33f4b08171d9d609c48662d96b2d3", "target": 1, "func": "static int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n    if (bytestream2_get_bytes_left(&s->g) < 36) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Insufficient space for SIZ\\n\");\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n    if (s->image_offset_x || s->image_offset_y) {\n        avpriv_request_sample(s->avctx, \"Support for image offsets\");\n        return AVERROR_PATCHWELCOME;\n    if (av_image_check_size(s->width, s->height, 0, s->avctx)) {\n        avpriv_request_sample(s->avctx, \"Large Dimensions\");\n        return AVERROR_PATCHWELCOME;\n    if (ncomponents <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              ncomponents);\n        return AVERROR_PATCHWELCOME;\n    s->ncomponents = ncomponents;\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Insufficient space for %d components in SIZ\\n\", s->ncomponents);\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4\n            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]);\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    /* compute image size with reduction factor */\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n    if (i == possible_fmts_nb) {\n        if (ncomponents == 4 &&\n            s->cdy[0] == 1 && s->cdx[0] == 1 &&\n            s->cdy[1] == 1 && s->cdx[1] == 1 &&\n            s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) {\n            if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n                s->cdef[0] = 0;\n                s->cdef[1] = 1;\n                s->cdef[2] = 2;\n                s->cdef[3] = 3;\n                i = 0;\n    if (i == possible_fmts_nb) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d\\n\"\n               \"cdx[0]: %d, cdy[0]: %d\\n\"\n               \"cdx[1]: %d, cdy[1]: %d\\n\"\n               \"cdx[2]: %d, cdy[2]: %d\\n\"\n               \"cdx[3]: %d, cdy[3]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               s->cdx[0],\n               s->cdy[0],\n               ncomponents > 1 ? s->cdx[1] : 0,\n               ncomponents > 1 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0,\n               ncomponents > 3 ? s->cdx[3] : 0,\n               ncomponents > 3 ? s->cdy[3] : 0);\n        return AVERROR_PATCHWELCOME;\n    s->avctx->bits_per_raw_sample = s->precision;\n    return 0;", "idx": 1318, "substitutes": {"s": ["uns", "conf", "d", "ions", "words", "v", "states", "window", "ps", "lines", "secondary", "sb", "results", "sym", "parts", "f", "os", "as", "js", "params", "_", "comments", "sv", "l", "sites", "is", "si", "qs", "o", "y", "p", "ins", "se", "format", "stats", "data", "ses", "site", "args", "b", "u", "sg", "ops", "sync", "h", "S", "uses", "r", "settings", "hs", "cs", "ssl", "new", "m", "sq", "session", "w", "full", "service", "g", "your", "us", "ks", "spec", "es", "gs", "t", "aws", "ss", "e", "ls", "size", "ds", "xs", "fs", "ms", "su", "sets", "ts", "ns", "img", "ims", "ans", "services", "a", "sys", "sf", "c", "rs", "in", "ats", "self", "vs", "tests", "bis", "its"], "i": ["ui", "io", "l", "si", "is", "j", "n", "temp", "p", "multi", "m", "ii", "count", "v", "a", "li", "iu", "c", "counter", "di", "pi", "t", "b", "f", "ti", "ip", "xi", "I"], "ncomponents": ["ncaplements", "nparlements", "nquonents", "nmaclements", "nquuments", "numcompients", "ncountonents", "ncommonent", "ncapients", "nummacresses", "ncondances", " nComplements", "sncomponents", "nquarters", "bcompounds", "ncondounds", "nummaclements", "bcommonents", "bcomplements", "ncomponent", "ncontonents", "numcompresses", "nComponents", "ncomenses", "ncontones", "numparresses", "ncommones", "nproplements", "numparlements", "ncomounds", "nproponents", "nCompances", "bcompenses", "sncompuments", "bcomponents", "ncomparters", "sncommuments", "ncaponents", "nummacones", "ncountresses", "nComponent", "numcompones", "ncountlements", "sncommones", "ncompenses", "ncontlements", "nparonents", "npropresses", "bcommounds", "ncompresses", "ncondonents", "bcommenses", "ncondonent", "nparresses", "numcomplements", "ncondenses", "nmacones", "ncompounds", " ncompances", "nmacresses", "nummaconents", "ncommarters", "nspuments", " ncomponent", "ncondlements", "sncompones", "ncommenses", " ncomplements", "ncountients", "ncompones", "ncommances", "ncompuments", "ncompients", "nmaconents", "numcomponents", "npropones", " nCompances", "nspones", "nComplements", "numparonents", "nparients", "nquones", "numparients", "ncontresses", "sncomparters", "ncommounds", "ncommuments", "ncommonents", "nsponents", "ncompances", "sncommarters", "sncommonents", " nComponents", " nComponent", "ncomonents", "nsparters", "bcommlements", "ncapresses", "ncomlements", "ncomplements", "ncommlements"], "possible_fmts": ["possible_cmters", "possible_mts", "possible_mters", "possible_fmters", "possible_mt", "possible_fmats", "possible_FMters", "possible_mats", "possible_FMts", "possible_cmt", "possible_cmts", "possible_cmats", "possible_FMt", "possible_fmt", "possible_FMats"]}}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    CommitBlockJob *s = container_of(job, CommitBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n", "idx": 1335, "substitutes": {"job": ["feed", "lock", "base", "bug", "worker", "manager", "project", "Job", "section", "object", "pb", "j", "exec", "connection", "node", "config", "queue", "status", "run", "jobs", "build", "service", "server", "work", "pool", "plugin", "jp", "flow", "result", "block", "image", "process", "cb", "db", "b", "child", "sync", "seq"], "speed": ["high", "powered", "scale", "sort", "error", "settings", "slow", "grade", "mass", "race", "limit", "status", "fee", "time", "capacity", "Speed", "slice", "scroll", "stop", "service", "strength", "peed", "gain", "length", "duration", "spec", "port", "rank", "weight", "seed", "power", "image", "sex", "performance", "rate", "level", "cost", "effect", "mph", "set", "size", "score", "sk", "skill", "strike", "step", "source"], "errp": ["errr", " errf", "iterp", "erP", "erc", "errfp", "errpe", "errP", "erfp", "iterr", "rrfp", "erpe", "erp", "rrP", "errc", " errc", " errP", " errpe", "errf", "iterf", " errr", "err", "iterpe", "erf", "rrp", " errfp", "rrc"], "s": ["S", "r", "ns", "hs", "sup", "si", "is", "sh", "o", "p", "m", "sq", "se", "session", "v", "services", "service", "g", "sp", "ps", "submit", "ses", "spec", "sf", "c", "sb", "secondary", "gs", "sym", "b", "sg", "f", "u", "ss", "js", "e", "sl", "ls", "ssh", "ds"]}}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void sd_1d97_int(int *p, int i0, int i1)\n\n{\n\n    int i;\n\n\n\n    if (i1 <= i0 + 1) {\n\n        if (i0 == 1)\n\n            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;\n\n        else\n\n            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;\n\n        return;\n\n    }\n\n\n\n    extend97_int(p, i0, i1);\n\n    i0++; i1++;\n\n\n\n    for (i = i0/2 - 2; i < i1/2 + 1; i++)\n\n        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n\n    for (i = i0/2 - 1; i < i1/2 + 1; i++)\n\n        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n\n    for (i = i0/2 - 1; i < i1/2; i++)\n\n        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n\n    for (i = i0/2; i < i1/2; i++)\n\n        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n\n}\n", "idx": 1338, "substitutes": {"p": ["lp", "private", "pm", "er", "d", "wp", "v", "ps", "sp", "jp", "ch", "pi", "P", "php", "f", "post", "cop", "s", "br", "rep", "press", "l", "y", "o", "up", "per", "python", "data", "port", "app", "pp", "comp", "point", "b", "u", "op", "it", "tp", "pr", "bp", "patch", "sh", "at", "m", "cp", "pc", "g", "ap", "pre", "pair", "prev", "t", "ip", "e", "http", "progress", "cache", "j", "n", "pl", "api", "pe", "k", "py", "a", "c", "np", "vp", "result", "hp", "pa", "x"], "i0": ["i50", "pi029", " i00", "l2", "i6", " i029", "p1", "ii50", "iu8", "pi4", "idok", "i8", " i50", "p00", " iix", "uiok", "id0", "si050", " i8", "si00", "p4", "ui8", "ui01", "ini0", "iu050", "si01", "l1", " iqa", "i029", "si5", "si6", "iu50", "id01", "i050", "id00", "si029", "ui120", "ii4", "iu120", "i01", "qi100", "ini8", "ii5", "pi6", "ii100", " i4", "ini125", "qi0", "p0", "l00", "i125", "siok", "iu125", "si1", "ui50", "qi50", "i120", "ii00", "i4", "uiqa", "pi0", "p2", "iuqa", "siix", "i00", "iix", "qi00", "ui0", " i6", "ui2", " i5", "ui1", "si0", "i2", "si125", "pix", "ini050", "i100", "si8", " i120", "i5", " i100", "iok", "ii0", "l0", "iqa", "iu0", "ii6", "si4", "ui00"], "i1": ["u251", "u100", "ip151", "it81", "ii01", "i6", "ui1001", "p1", "ini81", "i8", " iOne", "ip1001", "ini1", " i2", "i151", " i8", " i01", "it251", "ii8", "ii2", "si01", "in2", "pi1", "xi01", "li01", "in1", "in251", "i251", "in100", "ui251", "siOne", "p8", "it1", "ip2", "li1001", "ui61", "it01", "i01", "i81", "xi1", "ui100", " iup", "p0", "li151", "ip1", "i1001", "si251", "pi2", "si1", "xi2", "li1", "li6", "si61", "u1", "xi0", "ui0", "ui2", "i61", "liup", "ii1", "iiOne", "ui1", "si0", "li61", "i2", "li2", "u2", "piup", "li8", "i100", "si8", "si81", "si1001", "li0", "ini01", "iup", "iOne", "ini251", "ii0", "p6", "ui151", "ii6", "pi01"], "i": ["chi", "anti", "idi", "uri", "key", "d", "mi", "ri", "v", "bi", "ami", "iu", "ie", "ji", "ix", "info", "pi", "f", "ti", "phi", "s", "gu", "ui", "l", "si", "is", "y", "o", "ci", "qi", "eni", "I", "li", "init", "mu", "b", "u", "xi", "it", "h", "io", "r", "ik", "fi", "multi", "m", "oi", "ini", "slice", "me", "zi", "ai", "t", "ei", "ip", "e", "yi", "index", "hi", "j", "n", "cli", "id", "alpha", "api", "adi", "k", "ii", "a", "mini", "c", "in", "di", "abi", "gi", "ni", "x"]}}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)\n\n{\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tint r=  ((uint32_t*)src)[i]&0xFF;\n\n\t\tint g= (((uint32_t*)src)[i]>>8)&0xFF;\n\n\t\tint b= (((uint32_t*)src)[i]>>16)&0xFF;\n\n\n\n\t\tdst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);\n\n\t}\n\n}\n", "idx": 1341, "substitutes": {"dst": ["Dsrc", "Dsts", " ddest", "dsST", "ssts", "dtd", "rst", "dsts", "ssrc", "rtd", "dstd", "sst", " dST", "Ddest", " dsrc", "dsst", "dsrc", "sdest", "rdest", "dsdest", "ddest", "rST", "dST", "Dst", " dsts", " dtd"], "src": ["uv", "gl", "rect", "rb", "sur", "sth", "req", "loc", "inst", "sc", "attr", "sr", "l", "rc", "sync", "scenes", "r", "img", "uri", "ctx", "conv", "sel", "st", "impl", "config", "split", "buf", "rest", "slice", "ruby", "cv", "stream", "dest", "video", "rib", "spec", "sb", "url", "RC", "gb", "image", "cb", "b", "rob", "cur", "sl", "uc", "s", "source"], "i": ["hi", "chi", "ui", "io", "r", "l", "fi", "wei", "si", "is", "j", "n", "uri", "iii", "o", "p", "ci", "multi", "qi", "eni", "d", "m", "oi", "cli", "id", "source", "I", "yi", "ri", "k", "ini", "ii", "slice", "v", "bi", "a", "li", "g", "iu", "ie", "ji", "c", "zi", "di", "ai", "info", "abi", "pi", "mu", "t", "b", "f", "u", "gi", "ti", "ei", "ni", "e", "xi", "x", "it", "phi", "h", "lc", "index"]}}
{"project": "qemu", "commit_id": "35b6e94ba50cd92600a85eef444bc31df8999de1", "target": 0, "func": "static uint32_t s390_pci_generate_fid(Error **errp)\n\n{\n\n    uint32_t fid = 0;\n\n\n\n    while (fid <= ZPCI_MAX_FID) {\n\n        if (!s390_pci_find_dev_by_fid(fid)) {\n\n            return fid;\n\n        }\n\n\n\n        if (fid == ZPCI_MAX_FID) {\n\n            break;\n\n        }\n\n\n\n        fid++;\n\n    }\n\n\n\n    error_setg(errp, \"no free fid could be found\");\n\n    return 0;\n\n}\n", "idx": 1351, "substitutes": {"errp": ["rrr", "erb", "errr", "errpre", "irr", "erpre", "irp", "erP", "erc", "rorb", "errP", "errlp", "errb", " errlp", "rrpre", "erp", "errc", "irc", " errP", "rorP", "irpre", "rorlp", "erlp", "err", "rrp", "rrc", " errb", "rorp"], "fid": ["gid", "vkid", "did", "fID", "frid", "Frid", "vids", "tfid", "ifname", " fbid", "afID", "ifid", "vid", "afbid", " fpid", "Fpid", "lfaid", "gsid", " fID", "lkid", "Fid", "dkid", " fip", "fip", " faid", "fbid", "faid", "Fbid", "tfbid", "gID", "fids", "fkid", "Fids", "lfids", "lids", "afpid", "FID", "lfid", " fname", " fsid", "Fname", "ifID", "lbid", "Faid", "dids", "vbid", "lfrid", "tfip", "fsid", "gname", "ifsid", "dbid", "fname", "lname", "tfID", "afid", "fpid", " fids", " frid", "lip", "lID", "lid"]}}
{"project": "qemu", "commit_id": "bd3be4dbbf0491d6db8bf326706747b4629ace4b", "target": 0, "func": "static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    V9fsVirtioState *v = VIRTIO_9P(dev);\n\n    V9fsState *s = &v->state;\n\n\n\n    virtio_cleanup(vdev);\n\n    v9fs_device_unrealize_common(s, errp);\n\n}\n", "idx": 1360, "substitutes": {"dev": ["user", "md", "mod", "nov", "dd", "wd", "driver", "dc", "diff", "req", "bug", "priv", "device", "def", "de", "grad", "conf", "sh", "o", "p", "DEV", "debug", "virt", "d", "w", "adv", "ad", "prom", "data", "dn", "development", "Dev", "app", "gd", "info", "state", "dem", "sd", "der", "err", "ver", "rad", "ds", "ev", "dom"], "errp": [" errps", "irmlp", "irmp", "srps", "errps", "erP", "errfp", "errP", "irmfp", "errlp", "erfp", "irmps", " errlp", "srlp", "srp", "erp", "ersp", " errP", "errsp", "dersp", "derP", "derfp", " errsp", "derp", "srfp", " errfp"], "vdev": ["Vdev", "vself", "evdd", "vmdev", "Vdiff", "evdiff", "vmdevice", "vmgrad", " vgrad", " vself", "vmself", "vdiff", "Vdevice", "Vgrad", "vgrad", "vdd", "vdevice", "Vself", "evdev", " vdd", "evdevice", " vdevice", "Vdd", " vdiff"], "v": ["vd", "i", "vt", "sv", "l", "j", "n", "vu", "o", "p", "va", "d", "m", "var", "z", "V", "w", "vm", "volt", "k", "tv", "vr", "g", "server", "c", "lv", "vp", "vi", "state", "vs", "t", "b", "f", "vv", "u", "ver", "e", "iv", "x", "ev", "nv"], "s": ["S", "fs", "sv", "r", "su", "l", "si", "ssl", "o", "sh", "p", "d", "sq", "se", "w", "services", "service", "g", "server", "spec", "ses", "c", "sb", "rs", "state", "vs", "sd", "b", "sg", "f", "u", "os", "serv", "ss", "js", "sl", "ds", "h"]}}
{"project": "FFmpeg", "commit_id": "49c8132b17ec26666d71ee94a50f421b84feeb35", "target": 1, "func": "static int ipmovie_read_packet(AVFormatContext *s,\n\n                               AVPacket *pkt)\n\n{\n\n    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    int ret;\n\n\n\n    ret = process_ipmovie_chunk(ipmovie, pb, pkt);\n\n    if (ret == CHUNK_BAD)\n\n        ret = AVERROR_INVALIDDATA;\n\n    else if (ret == CHUNK_EOF)\n\n        ret = AVERROR_IO;\n\n    else if (ret == CHUNK_NOMEM)\n\n        ret = AVERROR_NOMEM;\n\n    else\n\n        ret = 0;\n\n\n\n    return ret;\n\n}\n", "idx": 1373, "substitutes": {"s": ["S", "i", "sv", "sc", "ns", "settings", "cs", "private", "ctx", "si", "n", "ssl", "qs", "south", "p", "src", "d", "m", "sq", "session", "sa", "k", "an", "v", "services", "a", "sys", "g", "data", "ps", "ses", "spec", "sf", "c", "sb", "self", "parser", "gs", "t", "parts", "f", "sg", "client", "b", "ss", "e", "sl", "ds"], "pkt": ["wkg", "pkg", "Pkg", "wct", "pet", "apkt", "Pct", " pqt", "Pkt", "packet", "apqt", "wkt", "Pqt", "wacket", "pct", "Packet", "apet", "pqt", "apacket", " packet", " pct", "Pet", " pkg", " pet"], "ipmovie": ["epmovie", "epMovie", "ipvideo", "ipfilm", "mpMovie", "ipcam", "opfilm", " ipMovie", "ippMovie", "mpvideo", "ippcam", "mpfilm", "mpmovie", "ippfilm", "epcam", " ipcam", "ippvideo", "opmovie", "opvideo", "ipMovie", "ippmovie", "opMovie"], "pb": ["bf", "rb", "pit", "lp", "mp", "bp", "cpp", "prot", "xb", "bb", "pm", "binary", "fc", "pl", "fp", "bps", "pd", "phrase", "p", "ib", "ab", "pak", "ub", "api", "fb", "ppa", "abc", "tc", "platform", "cv", "py", "cp", "pc", "eb", "prop", "uf", "hub", "sf", " eb", "sb", "pp", "gb", "bh", "vp", "jp", "aph", "abi", "cb", "b", "pa", "amp", "wb", "bc", "lb", "bm", "PB"], "ret": ["rep", "cat", "bf", "val", "rb", "let", "res", "value", "back", "error", "match", "pet", "rc", "att", "def", "rt", "flag", "replace", "ait", "code", "hash", "alt", "RET", "ref", "det", "gt", "job", "rev", "id", "status", "obj", "len", "lit", "success", "ext", "rets", "type", "conn", "data", "reply", "mt", "feat", "fun", "sb", "nt", "reg", "info", "result", "get", "cb", "Ret", "t", "db", "al", "ft", "re", "pass", "ct", "bit", "art"]}}
{"project": "FFmpeg", "commit_id": "46e3883519b7592e946258c68d072abd89e583c8", "target": 1, "func": "static int opus_decode_frame(OpusStreamContext *s, const uint8_t *data, int size)\n\n{\n\n    int samples    = s->packet.frame_duration;\n\n    int redundancy = 0;\n\n    int redundancy_size, redundancy_pos;\n\n    int ret, i, consumed;\n\n    int delayed_samples = s->delayed_samples;\n\n\n\n    ret = opus_rc_init(&s->rc, data, size);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* decode the silk frame */\n\n    if (s->packet.mode == OPUS_MODE_SILK || s->packet.mode == OPUS_MODE_HYBRID) {\n\n        if (!swr_is_initialized(s->swr)) {\n\n            ret = opus_init_resample(s);\n\n            if (ret < 0)\n\n                return ret;\n\n        }\n\n\n\n        samples = ff_silk_decode_superframe(s->silk, &s->rc, s->silk_output,\n\n                                            FFMIN(s->packet.bandwidth, OPUS_BANDWIDTH_WIDEBAND),\n\n                                            s->packet.stereo + 1,\n\n                                            silk_frame_duration_ms[s->packet.config]);\n\n        if (samples < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Error decoding a SILK frame.\\n\");\n\n            return samples;\n\n        }\n\n        samples = swr_convert(s->swr,\n\n                              (uint8_t**)s->out, s->packet.frame_duration,\n\n                              (const uint8_t**)s->silk_output, samples);\n\n        if (samples < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Error resampling SILK data.\\n\");\n\n            return samples;\n\n        }\n\n\n        s->delayed_samples += s->packet.frame_duration - samples;\n\n    } else\n\n        ff_silk_flush(s->silk);\n\n\n\n    // decode redundancy information\n\n    consumed = opus_rc_tell(&s->rc);\n\n    if (s->packet.mode == OPUS_MODE_HYBRID && consumed + 37 <= size * 8)\n\n        redundancy = opus_rc_p2model(&s->rc, 12);\n\n    else if (s->packet.mode == OPUS_MODE_SILK && consumed + 17 <= size * 8)\n\n        redundancy = 1;\n\n\n\n    if (redundancy) {\n\n        redundancy_pos = opus_rc_p2model(&s->rc, 1);\n\n\n\n        if (s->packet.mode == OPUS_MODE_HYBRID)\n\n            redundancy_size = opus_rc_unimodel(&s->rc, 256) + 2;\n\n        else\n\n            redundancy_size = size - (consumed + 7) / 8;\n\n        size -= redundancy_size;\n\n        if (size < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid redundancy frame size.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (redundancy_pos) {\n\n            ret = opus_decode_redundancy(s, data + size, redundancy_size);\n\n            if (ret < 0)\n\n                return ret;\n\n            ff_celt_flush(s->celt);\n\n        }\n\n    }\n\n\n\n    /* decode the CELT frame */\n\n    if (s->packet.mode == OPUS_MODE_CELT || s->packet.mode == OPUS_MODE_HYBRID) {\n\n        float *out_tmp[2] = { s->out[0], s->out[1] };\n\n        float **dst = (s->packet.mode == OPUS_MODE_CELT) ?\n\n                      out_tmp : s->celt_output;\n\n        int celt_output_samples = samples;\n\n        int delay_samples = av_audio_fifo_size(s->celt_delay);\n\n\n\n        if (delay_samples) {\n\n            if (s->packet.mode == OPUS_MODE_HYBRID) {\n\n                av_audio_fifo_read(s->celt_delay, (void**)s->celt_output, delay_samples);\n\n\n\n                for (i = 0; i < s->output_channels; i++) {\n\n                    s->fdsp->vector_fmac_scalar(out_tmp[i], s->celt_output[i], 1.0,\n\n                                                delay_samples);\n\n                    out_tmp[i] += delay_samples;\n\n                }\n\n                celt_output_samples -= delay_samples;\n\n            } else {\n\n                av_log(s->avctx, AV_LOG_WARNING,\n\n                       \"Spurious CELT delay samples present.\\n\");\n\n                av_audio_fifo_drain(s->celt_delay, delay_samples);\n\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n\n                    return AVERROR_BUG;\n\n            }\n\n        }\n\n\n\n        opus_raw_init(&s->rc, data + size, size);\n\n\n\n        ret = ff_celt_decode_frame(s->celt, &s->rc, dst,\n\n                                   s->packet.stereo + 1,\n\n                                   s->packet.frame_duration,\n\n                                   (s->packet.mode == OPUS_MODE_HYBRID) ? 17 : 0,\n\n                                   celt_band_end[s->packet.bandwidth]);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        if (s->packet.mode == OPUS_MODE_HYBRID) {\n\n            int celt_delay = s->packet.frame_duration - celt_output_samples;\n\n            void *delaybuf[2] = { s->celt_output[0] + celt_output_samples,\n\n                                  s->celt_output[1] + celt_output_samples };\n\n\n\n            for (i = 0; i < s->output_channels; i++) {\n\n                s->fdsp->vector_fmac_scalar(out_tmp[i],\n\n                                            s->celt_output[i], 1.0,\n\n                                            celt_output_samples);\n\n            }\n\n\n\n            ret = av_audio_fifo_write(s->celt_delay, delaybuf, celt_delay);\n\n            if (ret < 0)\n\n                return ret;\n\n        }\n\n    } else\n\n        ff_celt_flush(s->celt);\n\n\n\n    if (s->redundancy_idx) {\n\n        for (i = 0; i < s->output_channels; i++)\n\n            opus_fade(s->out[i], s->out[i],\n\n                      s->redundancy_output[i] + 120 + s->redundancy_idx,\n\n                      ff_celt_window2 + s->redundancy_idx, 120 - s->redundancy_idx);\n\n        s->redundancy_idx = 0;\n\n    }\n\n    if (redundancy) {\n\n        if (!redundancy_pos) {\n\n            ff_celt_flush(s->celt);\n\n            ret = opus_decode_redundancy(s, data + size, redundancy_size);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            for (i = 0; i < s->output_channels; i++) {\n\n                opus_fade(s->out[i] + samples - 120 + delayed_samples,\n\n                          s->out[i] + samples - 120 + delayed_samples,\n\n                          s->redundancy_output[i] + 120,\n\n                          ff_celt_window2, 120 - delayed_samples);\n\n                if (delayed_samples)\n\n                    s->redundancy_idx = 120 - delayed_samples;\n\n            }\n\n        } else {\n\n            for (i = 0; i < s->output_channels; i++) {\n\n                memcpy(s->out[i] + delayed_samples, s->redundancy_output[i], 120 * sizeof(float));\n\n                opus_fade(s->out[i] + 120 + delayed_samples,\n\n                          s->redundancy_output[i] + 120,\n\n                          s->out[i] + 120 + delayed_samples,\n\n                          ff_celt_window2, 120);\n\n            }\n\n        }\n\n    }\n\n\n\n    return samples;\n\n}", "idx": 1377, "substitutes": {"s": ["uns", "conf", "d", "ions", "words", "ps", "sb", "sym", "os", "f", "js", "comments", "sv", "l", "si", "is", "qs", "o", "p", "ins", "se", "ses", "site", "args", "b", "sg", "u", "serv", "ops", "sync", "h", "S", "uses", "hs", "settings", "cs", "ssl", "ips", "new", "m", "sq", "session", "full", "service", "g", "your", "us", "server", "ks", "spec", "es", "gs", "sports", "t", "aws", "ss", "e", "ls", "ds", "xs", "fs", "ms", "su", "sets", "ts", "ns", "n", "ims", "services", "a", "sys", "sf", "c", "rs", "self", "its"], "data": ["dd", "cache", "ui", "sample", "shift", "Data", "p", "input", "raw", "d", "dat", "memory", "buffer", "buf", "len", "slice", "pad", "rec", "ops", "a", "window", "batch", "length", "devices", "body", "start", "result", "image", "block", "channel", "DATA", "response", "da", "x", "bytes", "ds", "source"], "size": ["offset", "six", "loc", "scale", "en", "enc", "code", "unit", "sec", "n", "p", "name", "se", "sum", "fee", "time", "capacity", "len", "pos", "ize", "shape", "small", "sized", "address", "empty", "SIZE", "Size"], "redundancy_size": ["redundance_sum", "redundancy_sum", "redundance_pos", "redundance_size"], "redundancy_pos": ["redundancies_len", "redundancies_position", "redundancy_position", "redundancies_pos", "redundancy_len", "redundancy_offset", "redundancies_offset"], "ret": ["rep", "cat", "bf", "val", "offset", "fail", "rb", "res", "sur", "bad", "part", "back", "error", "match", "att", "rc", "def", "pet", "rt", "flag", "code", "sec", "num", "resp", "alt", "active", "opt", "fin", "ref", "RET", "det", "gt", "rev", "iter", "status", "red", "len", "mode", "reset", "lit", "run", "full", "format", "success", "ext", "rets", "feat", "reply", "mt", "fun", "sil", "nt", "reg", "complete", "sb", "info", "result", "get", "Ret", "al", "f", "max", "ft", "re", "pass", "bit", "en", "art"], "i": ["ui", "io", "fi", "si", "is", "j", "p", "ind", "mi", "id", "iter", "ini", "ii", "len", "reset", "mini", "ie", "in", "start", "ai", "init", "info", "f", "ni", "it", "index"], "consumed": ["conslated", "conumes", "continoved", "consuming", " consaled", " consumes", " unconsaled", "Consumption", "consume", "continlated", "continumes", "continume", "resumption", "conumed", "continumed", " unconsumed", " consoved", " conslated", "conuming", " unconslated", "manumes", "consumption", "consumes", "Consume", " consumption", "consoved", "continumption", "resoved", "conumption", "manoved", "resumes", "continuming", "Consuming", " unconsumption", "conoved", "Consumed", "continaled", "conume", "consaled", "resumed", "manumed", "manumption"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "bool qemu_co_enter_next(CoQueue *queue)\n\n{\n\n    Coroutine *next;\n\n\n\n    next = QSIMPLEQ_FIRST(&queue->entries);\n\n    if (!next) {\n\n        return false;\n\n    }\n\n\n\n    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);\n\n    qemu_coroutine_enter(next, NULL);\n\n    return true;\n\n}\n", "idx": 1381, "substitutes": {"queue": ["line", "loop", "feed", "cache", "menu", "manager", "context", "code", "collection", "lib", "command", "ue", "group", "connection", "module", "config", "delay", "job", "sequence", "buffer", "route", "qa", "event", "prefix", "file", "future", "list", "console", "batch", "server", "plugin", "channel", "que", "q", "gui", "Queue", "page", "cycle", "message", "seq"], "next": ["line", "offset", "Next", "good", "value", "same", "done", "object", "code", "sec", "latest", "core", "valid", "second", "iterator", "seq", "new", "key", "up", "primary", "first", "entry", "sequence", "obj", "step", " NEXT", "link", "frame", "end", "success", "foo", "future", "data", "reply", "front", "server", "forward", "after", "self", "prev", "current", "start", "flow", "pack", "more", "range", "page", " Next", "one", "open", "big", "client", "pointer", "last", "business"]}}
{"project": "FFmpeg", "commit_id": "a28cccf6d62dc770757491510c248ed632a836ce", "target": 1, "func": "static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int channelNum, int codingMode)\n\n{\n\n    int   band, result=0, numSubbands, lastTonal, numBands;\n\n\n\n    if (codingMode == JOINT_STEREO && channelNum == 1) {\n\n        if (get_bits(gb,2) != 3) {\n\n            av_log(NULL,AV_LOG_ERROR,\"JS mono Sound Unit id != 3.\\n\");\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (get_bits(gb,6) != 0x28) {\n\n            av_log(NULL,AV_LOG_ERROR,\"Sound Unit id != 0x28.\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* number of coded QMF bands */\n\n    pSnd->bandsCoded = get_bits(gb,2);\n\n\n\n    result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded);\n\n    if (result) return result;\n\n\n\n    pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded);\n\n    if (pSnd->numComponents == -1) return -1;\n\n\n\n    numSubbands = decodeSpectrum (gb, pSnd->spectrum);\n\n\n\n    /* Merge the decoded spectrum and tonal components. */\n\n    lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components);\n\n\n\n\n\n    /* calculate number of used MLT/QMF bands according to the amount of coded spectral lines */\n\n    numBands = (subbandTab[numSubbands] - 1) >> 8;\n\n    if (lastTonal >= 0)\n\n        numBands = FFMAX((lastTonal + 256) >> 8, numBands);\n\n\n\n\n\n    /* Reconstruct time domain samples. */\n\n    for (band=0; band<4; band++) {\n\n        /* Perform the IMDCT step without overlapping. */\n\n        if (band <= numBands) {\n\n            IMLT(&(pSnd->spectrum[band*256]), pSnd->IMDCT_buf, band&1);\n\n        } else\n\n            memset(pSnd->IMDCT_buf, 0, 512 * sizeof(float));\n\n\n\n        /* gain compensation and overlapping */\n\n        gainCompensateAndOverlap (pSnd->IMDCT_buf, &(pSnd->prevFrame[band*256]), &(pOut[band*256]),\n\n                                    &((pSnd->gainBlock[1 - (pSnd->gcBlkSwitch)]).gBlock[band]),\n\n                                    &((pSnd->gainBlock[pSnd->gcBlkSwitch]).gBlock[band]));\n\n    }\n\n\n\n    /* Swap the gain control buffers for the next frame. */\n\n    pSnd->gcBlkSwitch ^= 1;\n\n\n\n    return 0;\n\n}\n", "idx": 1404, "substitutes": {"q": ["kb", "ui", "req", "buff", "rc", "conf", "qs", "ue", "qu", "qq", "qi", "query", "m", "sq", "queue", "w", "cgi", "qa", "quant", "question", "g", "hub", "dq", "gd", "f", "Q", "qt", "quad"], "gb": ["hm", "kb", "bf", "ko", "gru", "rb", "agg", "cfg", "ui", "buff", "rc", "bb", "GB", "bg", "ga", "gp", "gal", "gio", "cgi", "gnu", "mb", "ogg", "cv", "nb", "pc", "gz", "g", "eb", "usb", "gin", "abb", "ym", "hub", "sb", "rg", "gm", "gram", "gd", "gy", "gg", "gs", "cb", "db", "b", "quad", "storage", "gam", "wb", "ges", "bc", "lb", "bm", "cm", "pg"], "pSnd": ["pHSnn", "pGSnt", "cpOsnt", "pOSnd", "pInsnd", "pSnt", "pHSdn", "pIsld", "pShnd", "pSinf", "pSsd", "pPsgn", "pEsund", "pSind", "pSdc", "PAsld", "psck", "pNnw", "cpSND", "pSnn", "PSnd", "PAsdn", "pEsnt", "pAsgn", "pAsnt", "PSND", " pSND", "pOsND", "pSnw", " pSnt", "pGSnd", "PSld", "pSdat", "pHSck", "pSund", "pGSgn", "pAsND", "pOSND", "pCnd", "pAsne", "PNnt", " pSld", " pAsdat", " pAsstd", "pNld", " pAsld", "cpOsnd", "pSuck", "pPsnt", "pAsnn", " pSnn", "pAsck", "PSsd", "pNnd", " pSinf", "pSuind", "PSnt", "PAsng", " pSind", "pEsnd", "pOsld", "pAsng", "pESnt", " pNck", " pAsnn", "PAsdk", "pEsND", "psnd", "PSign", " pNnd", "pAsnd", "pClnt", "pWSnt", "cpSld", "PSdk", " pAsne", "pHSsd", "PAsnn", "pIsND", "pHSnt", "pLSsd", "pShnt", "pNnn", "PNck", "pSunt", "pSdk", "npSind", "pInsck", "pCnt", " pAsND", " pSne", " pNinf", "PNND", "pAsnw", "pIsnd", "PNnd", "npSND", "pESND", "pAsinf", "pHSND", "PAsnt", "pShind", "pGSnn", "PSck", "PSng", "cpSnd", " pSdn", "pHSnd", " pAsvd", "pSyncnt", " pAsdn", " pAsnt", "pAssd", "PSdn", " pSstd", "npHSck", " pSck", "pRSstd", "psND", "pESnd", "pLSnd", "pSyncne", "pSstd", "pAsvd", " pAsgn", "pNnt", "pAsdn", "pResng", "pGSvd", "pLSdn", "pESnw", "psign", "pResnt", "PAsund", "pNND", "npHSND", "pAsind", "npSck", "pSyncnd", "pShdn", "pSld", " pAsdc", "PSund", "PSnn", "pWSck", "cpOsND", "pPsvd", " pSgn", "pSign", "pSgn", "pSdn", "pRSind", "pNck", "pInsinf", "pSck", "pIsind", "PAsND", "pSng", "pOSld", "pAsstd", " pSvd", "pEsdat", "pGSdn", "pCldat", "pOsnt", "pRSnd", "pHSind", "pNinf", "pAsdk", "PAssd", " pSdc", "cpSnt", "pAsdat", "pSvd", "npHSnd", "pCND", "pEsld", "pShND", "pAsund", "pSyncdc", "PAsnd", "npSnd", "pCld", "pResnd", " pAsind", " pAsnd", "cpOsld", "pSne", "pIsund", "pLSND", "pPsnd", "pInsND", "pAsign", "pClnd", "pClld", " pSdat", "pGSdc", " pNND", "PAsck", "pNind", "pWSnd", "pOsnd", "pIsstd", "pAsdc", "pGSne", "pResdk", " pSnw", "pOSnn", " pAsnw", "pWSng", "pSND", "pRSND", "pAsld", "npHSind"], "pOut": ["PIn", "fpIn", " pArray", "fpArray", " pOutput", "POut", " pIn", "pOutput", "npout", "npIn", "npOutput", "POutput", "npOut", "pout", "pIn", "Pout", "fpout", "PArray", "pArray", "fpOut", " pout"], "channelNum": [" channelNumber", "ChannelNum", " channelnum", "componentNum", "pageNumber", "pageLen", "ChannelNumber", "channelnum", "channelLen", "pageNum", "Channelnum", " channelLen", "channelNumber", "componentLen", "pagenum", "componentNumber", "ChannelLen", "componentnum"], "codingMode": ["lcodemode", "encodeMode", "lcodingMode", "codermode", "codingmode", "encodemode", "codemode", "codingMODE", "codeMode", "codingType", "cachingMODE", "encodingType", "codeMODE", "codedMode", "codeType", "castingMODE", "encodingMode", "encodeMODE", "coderMODE", "castingmode", "encodeType", "encodingmode", "lcodeMode", "codedMODE", "castingMode", "codedmode", "cachingType", "coderMode", "lcodingMODE", "lcodingmode", "lcodeMODE", "encodingMODE", "codedType", "cachingmode", "cachingMode"], "band": ["field", "phase", "part", "card", "match", "ord", "unit", "leg", "key", "group", "number", "d", "bound", "count", "position", "layer", "plugin", "weight", "boot", "channel", "gap", "component", "page", "bit", "step", "kat", "piece", "stage", "mode", "data", "point", "current", "board", "Band", "song", "tag", "line", "offset", "track", "patch", "device", "code", "function", "cell", "product", "ground", "frequency", "batch", "day", "length", "plane", "level", "amp", "ver", "bind", "cm", "kg", "bands", "loop", "bug", "back", "bb", "low", "filter", "byte", "word", "off", "broad", "type", "direction", "flow", "result", "db", "feature", "version", "range", "pass"], "numSubbands": [" numSubgroups", "numSupergroups", " numPerplanes", "numsubgroups", "numsubbands", "sumSubbands", "nSubgroups", "numPerplanes", "nSuperlines", "numSubgroups", "sumsubbands", "numBlines", "sumsubtracks", "numSubbits", "sumsubband", "numSubcats", "nSubbands", "numMicrogroups", "nSupergroups", "numsublines", "numShortplanes", "sumSubband", "numSuperbits", "numBgroups", "nSubbits", "numsubtracks", "numShortband", "numsubplanes", "sumsubplanes", "numMicrobands", "numPercats", "numBbits", "numSuperlines", "numBbands", " numPercats", "numSuperbands", " numSubcats", "numsubcats", "numSublines", "numPergroups", "numShorttracks", "numsubband", "nSuperbits", "numsubbits", "nSublines", " numSubplanes", "sumSubplanes", "numSubplanes", "sumSubtracks", "numMicrocats", "numPerbands", " numPergroups", " numPerbands", "numShortbands", "numMicroplanes", "numSubtracks", "numSubband", "nSuperbands"], "lastTonal": ["lastTooting", "lastXTronic", " lastFone", "lastTonic", "lastFon", "lastFonic", "lastBoned", "lasttooting", "lastBone", "lastConed", "lasttone", " lastTooting", " lastFooting", "LastThon", "lastForal", "LastToned", "LastThoned", "lastFone", " lastFronic", "lastThon", "lastConal", "LastToral", "lastConic", "lasttonal", "lastNotoral", " lastFonal", "lastXTonal", "lastToral", "LastThonal", "LastTonal", "lastFahn", " lastBoned", "LastTon", "lastFooting", "lastBronic", "lastXTahn", "lastToned", "lastNotoned", " lastTronic", "lastTon", "lastBonic", " lastBonal", "lastTahn", "lastBonal", "lastCronic", " lastFahn", "lastNotonal", " lastFonic", "lastBooting", "lastFonal", " lastBonic", " lastToned", " lastTonic", "lastThoned", " lastBronic", "lastThoral", "lastFoned", "lastXTonic", "lastBahn", "LastThoral", " lastTone", "lastNoton", "lastTone", " lastTahn", "lasttonic", "lastFronic", "lastThonal", "lastTronic"], "numBands": ["numCands", "numBards", "numbounds", "sumbands", "numRands", "umBsards", "NUMDands", "sumbbands", "numChands", "numbannels", "sumBacks", "NUMBans", "numDands", "numRbands", "numBbands", " numBannels", " numBsands", "sumWans", " numBards", "numPounds", "numbands", "numChannels", "umBands", "numBsannels", "umBbands", "numRards", "numRannels", "sumWounds", " numBays", "numbbands", "numBsays", "numWans", "sumBounds", "numBsounds", "numWacks", " numBsards", "numPands", "numChbands", "NUMDans", "numChounds", "numPlannels", "numDayers", "numBannels", "numDannels", " numBsannels", "NUMDayers", "numCayers", "numBsbands", "numBounds", "numCans", "numCannels", "NUMBands", "numbans", "NUMBannels", "numBays", "numDans", "umBannels", "numWands", "sumWacks", "sumBannels", "numbays", "sumbannels", "numBans", " numBsays", "numWounds", "NUMDannels", "numPlays", "numbards", "numBsards", "numPacks", "numBsands", "numBayers", "sumbounds", "numPlards", "numbacks", "umBsannels", "numPlands", "umBsands", "sumBans", "sumWands", "numChayers", "sumBands", "NUMBayers", "umBsbands", "numBacks", "umBards", "numChans", "numPans", "sumBbands"]}}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_reg(const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return env->regwptr[val];\n\n}\n", "idx": 1420, "substitutes": {"md": ["dd", "mac", "nm", "pd", "nd", "mem", "dm", "det", "module", "d", "mo", "metadata", "m", "mi", "ad", "mm", "mode", "mb", "conn", "MD", "mid", "mn", "mc", "hd", "meta", "cmd", "cm", "cd"], "val": ["eval", "all", "value", "base", "cond", "elt", "pl", "sel", "pt", "p", "Val", "ref", "key", "fl", "min", "pid", "vol", "len", "count", "v", "lit", "pos", "el", "pc", "il", "vals", "sol", "ee", "VAL", "al", "arg", "f", "sl", "bl", "x", "index"], "env": ["eval", "cache", "manager", "inv", "inst", "cf", "equ", "po", "ex", "enc", "conf", "er", "n", "eu", "ec", "viron", "eni", "config", "obj", "vm", "v", "end", "ass", "inet", "conn", "el", "ah", "exe", "ea", "server", "me", "c", "hr", "export", "nc", "scope", "np", "exc", "state", "args", "vs", "db", "err", "nw", "e", "environment", "net", "ev", "zone", "en", "h"]}}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)\n\n{\n\n    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);\n\n    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);\n\n    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);\n\n    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);\n\n}\n", "idx": 1426, "substitutes": {"dst": ["sddest", " dost", "dost", "adst", "dbl", "datst", "dste", " ddest", "ndsts", "datsts", "ssts", "lost", "gsts", "dsts", "adsts", "sdost", "dconst", "sst", " dST", "datost", "ldst", "adbl", "lsts", "ndbl", "ldste", "sdput", "datdest", "sdbl", "gost", "idconst", "gst", "ndst", "idput", "gconst", "ldsts", "ldbl", "ndput", "lst", "sdst", "idsts", "sdsts", "idbl", "ddest", "idste", "sST", "dput", "idost", "dST", " dconst", "adste", "idst", "sost", " dsts", "lST"], "block": ["comment", "line", "wall", "lock", "cache", "view", "diff", "def", "un", "chain", "object", "device", "unit", "new", "group", "number", "key", "byte", "tick", "name", "obj", "buffer", "check", "blocks", "load", "time", "down", "keep", "Block", "no", "off", "label", "end", "frame", "type", "list", "batch", "row", "output", "work", "pre", "prev", "point", "start", "panel", "flow", "image", "col", "pack", "box", "none", "ip", "out", "bc", "record", "index", "clean"], "stride": ["Strace", "charide", "STRane", "errider", "gride", "striine", "strid", "Strid", "trIDE", " strace", "dride", "charine", "strIDE", "grider", "brine", "tride", "errided", "trine", "errides", "strane", " strue", " strides", "brace", "trider", " strane", "arride", "charice", "Strine", "brided", "strice", "STRided", "fride", "STRide", "drider", " strided", "charider", "frine", " strision", "constided", " strider", "arrider", "arrice", "trided", "strides", "arrid", "constide", "arrue", "bride", "striide", "erride", "arrine", " strine", "trane", "trides", "strine", "strue", "arrided", "grine", "constision", "strision", "brider", "frider", "errine", "STRider", "grIDE", "Strided", "drine", "brision", "Strue", "striider", "constider", "drice", "strace", "Stride", "strided", " strid", "Strider", "strider", "frided", "striIDE"]}}
{"project": "qemu", "commit_id": "b86160555f8d1fe11d6bcec393e08e645d7e1e8d", "target": 1, "func": "static void integratorcp_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    ARMCPU *cpu;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_alias = g_new(MemoryRegion, 1);\n\n    qemu_irq pic[32];\n\n    DeviceState *dev;\n\n    int i;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"arm926\";\n\n    }\n\n    cpu = cpu_arm_init(cpu_model);\n\n    if (!cpu) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_ram(ram, NULL, \"integrator.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero*/\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n    /* And again at address 0x80000000 */\n\n    memory_region_init_alias(ram_alias, NULL, \"ram.alias\", ram, 0, ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias);\n\n\n\n    dev = qdev_create(NULL, TYPE_INTEGRATOR_CM);\n\n    qdev_prop_set_uint32(dev, \"memsz\", ram_size >> 20);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map((SysBusDevice *)dev, 0, 0x10000000);\n\n\n\n    dev = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000,\n\n                                qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ),\n\n                                qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ),\n\n                                NULL);\n\n    for (i = 0; i < 32; i++) {\n\n        pic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n    sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, pic[26]);\n\n    sysbus_create_varargs(\"integrator_pit\", 0x13000000,\n\n                          pic[5], pic[6], pic[7], NULL);\n\n    sysbus_create_simple(\"pl031\", 0x15000000, pic[8]);\n\n    sysbus_create_simple(\"pl011\", 0x16000000, pic[1]);\n\n    sysbus_create_simple(\"pl011\", 0x17000000, pic[2]);\n\n    icp_control_init(0xcb000000);\n\n    sysbus_create_simple(\"pl050_keyboard\", 0x18000000, pic[3]);\n\n    sysbus_create_simple(\"pl050_mouse\", 0x19000000, pic[4]);\n\n\n    sysbus_create_varargs(\"pl181\", 0x1c000000, pic[23], pic[24], NULL);\n\n    if (nd_table[0].used)\n\n        smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n\n\n\n    sysbus_create_simple(\"pl110\", 0xc0000000, pic[22]);\n\n\n\n    integrator_binfo.ram_size = ram_size;\n\n    integrator_binfo.kernel_filename = kernel_filename;\n\n    integrator_binfo.kernel_cmdline = kernel_cmdline;\n\n    integrator_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(cpu, &integrator_binfo);\n\n}", "idx": 1434, "substitutes": {"args": ["flags", "same", "ns", "cs", "enc", "active", "resources", "ig", "Args", "ras", "lang", "arr", "gas", "new", "module", "ins", "config", "ids", "words", "any", "atts", "api", "ands", "ds", "actions", "ages", "sci", "ass", "conn", "states", "missing", "apps", "arms", "ks", "spec", "parser", "ams", "init", "gs", "plugin", "ants", "results", "arg", "parts", "sg", "cmd", "err", "utils", "aws", "GS", "parse", "empty", "points", "plugins", "use", "params"], "cpu_model": ["gpu_mode", "cpulexfolder", "memory_model", "gpu_channel", "cpu_models", "cpu___folder", "cpulexmodel", "memory___range", "cpuetmodel", "gpu_scope", "memory_server", "cpu67folder", "cpujmodel", " cpu_models", "cpu_engine", "cpuetmode", "cpu67range", "cpu_network", "cpu_range", "cpu67model", "cpulexrange", "cpu_machine", "cpu___server", "memory___server", " cpu_engine", "cpujchannel", "cpu_size", "cpu_type", "gpu_model", "cpu_server", "cpu_folder", " cpu_type", "cpujmachine", "memory_range", "cpu_scope", "gpu_network", "memory___model", "memory_folder", "gpu_size", "cpu___range", "memory___folder", "cpu_channel", "cpu67server", "cpuetmachine", "cpulexserver", "cpujmode", "gpu_machine", "cpu_mode", "cpuetnetwork", "cpu___model"], "kernel_filename": ["cpu_size", "kernel_file", "kernel_directory", "intel_directory", "intelbookfilename", "cpu_filename", "intel_file", "intelbookdirectory", "kernel_model", "cpu_label", "kernelbookfilename", "intel_model", "kernel_label", "intel_filename", "intelbookmodel", "kernelbookfile", "kernelbookmodel", "kernelbookdirectory", "kernel_size", "intelbookfile"], "kernel_cmdline": ["kernel_hostpass", "kernel_hostsl", "kernel_cmdsl", "kernel_commandpass", "kernel_hostline", "kernel_commandlf", "kernel_cmdlf", "kernel_cfpass", "kernel_cfLine", "kernel_commandline", "kernel_reqsl", "kernel_commandsl", "kernel_hostlf", "kernel_reqLine", "kernel_reqline", "kernel_cfline", "kernel_cflf", "kernel_hostLine", "kernel_cmdpass", "kernel_cmdLine", "kernel_commandLine"], "initrd_filename": ["initrd__fn", "initrd__uri", "initrd_uri", "initrs_filename", "initrs_files", "initrd_fn", "initrt_uri", "initrd_output", "initrd__filename", "initrs_output", "initrt_filename", "initrd_files", "initrs_file", "initrd_file", "initrd__file", "initrt_fn", "initrt_file"], "cpu": ["host", "clock", "cu", "cache", "bc", "mac", "lu", "device", "fc", "uu", "disk", "ctx", "intel", "linux", "core", "null", "computer", "alloc", "kernel", "mem", "gc", "node", "eni", " CPU", "config", "cam", "cli", "ro", "vm", "gnu", "px", "bus", "cp", "GPU", "gpu", "vidia", "pc", "lc", "loader", "roc", "uno", "lan", "cn", "c", "pool", "nc", "np", "pu", "cow", "mx", "process", "boot", "mc", "performance", "proc", "nic", "CPU", "component", "ni", "instance", "chip", "net", "processor", "hw"], "address_space_mem": ["address_pace_mm", "address_space54ram", "address_space2memory", "address_pace2mode", "address_pace_ram", "address_space2usage", "address_pace2mm", "address_space_ram", "address_spaceacdisk", "address_space_memory", "address_space_mm", "address_pace2memory", "address_pace2usage", "address_space54mm", "address_spaceacmem", "address_pace_disk", "address_space_gram", "address_spaceacgram", "address_space_disk", "address_space_mode", "address_pace2mem", "address_pace_gram", "address_pace_memory", "address_pace_mem", "address_pace_usage", "address_space2mode", "address_space2mem", "address_space_usage", "address_space54mode", "address_space64ram", "address_space64disk", "address_space54mem", "address_space64gram", "address_pace_mode", "address_spaceacram", "address_space2mm", "address_space2ram", "address_space64mem", "address_pace2ram"], "ram": ["man", "sam", "rum", "jam", "mac", "scan", "iam", "Ram", "mor", "sc", "disk", "sim", "param", "mem", "rage", "nam", "cam", "rom", "thread", "win", "memory", "buffer", "access", "vm", "rw", "mm", "dim", "mode", "am", "gpu", "micro", "lan", "arm", "rg", "gram", "rank", "RAM", "image", "mc", "process", "program", "pack", "na", "gam", "space", "resource", "cm", "region", "gra", "hw", "ra"], "ram_alias": ["ramsali", "ram_ias", "memory_size", "gram_alias", "ram_prefix", "ramjsize", "ram_region", "ramjrole", "memory_ias", "ramjali", "ram_ali", "gram_size", "memory_alias", "ram_role", "ram_size", "gram_area", "memory_ali", "ramsrole", "ram_area", "memory_area", "ramjalias", "ramsalias", "memory_region", "memory_role", "ramssize", "gram_prefix"], "pic": ["cache", "bc", "fs", "mac", "Pic", "ac", "fc", "fi", "img", "sec", "arc", "lib", "ig", "ic", "src", "arr", "pin", "config", "pid", "icon", "__", "mic", "bus", "py", "sys", "pc", "str", "data", "pins", "gb", "pu", "lic", "pi", "proc", "nic", "bin", "xi", "sync", "seq"], "dev": ["driver", "vd", "mod", "gu", "dd", "comment", "cache", "dc", "home", "diff", "die", "bug", "od", "priv", "error", "device", "def", "de", "disk", "grad", "img", "conf", "lib", "debug", "DEV", "mem", "node", "d", "var", "cam", "plug", "vm", "adv", "dim", "prom", "bus", "v", "gpu", "conn", "data", "prop", "pro", "development", "spec", "Dev", "app", "test", "gd", "di", "pu", "ch", "result", "block", "proc", "sd", "dem", "der", "push", "ver", "serv", "rad", "go", "ev", "hw", "dom"], "i": ["hi", "loop", "chi", "ui", "diff", "vis", "l", "fi", "si", "code", "j", "num", "uri", "n", "o", "ani", "y", "p", "ci", "multi", "qi", "eni", "clip", "d", "m", "oi", "id", "mi", "I", "z", "ri", "area", "ini", "ii", "slice", "count", "v", "a", "bi", "uli", "li", "iu", "ji", "c", "zi", "di", "ix", "ai", "pi", "mu", "t", "gui", "f", "gi", "b", "ti", "u", "ip", "child", "ni", "e", "xi", "x", "it", "phi", "yi", "index"]}}
{"project": "qemu", "commit_id": "30c367ed446b6ea53245589a5cf373578ac075d7", "target": 1, "func": "static void set_vlan(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);\n\n    NetClientState **ptr = &peers_ptr->ncs[0];\n\n    Error *local_err = NULL;\n\n    int32_t id;\n\n    NetClientState *hubport;\n\n\n\n    if (dev->realized) {\n\n        qdev_prop_set_after_realize(dev, name, errp);\n\n\n\n\n\n    visit_type_int32(v, &id, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n\n\n    if (id == -1) {\n\n        *ptr = NULL;\n\n\n\n\n\n\n\n\n\n    hubport = net_hub_port_find(id);\n\n    if (!hubport) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                  name, prop->info->name);\n\n\n\n    *ptr = hubport;\n", "idx": 1435, "substitutes": {"obj": ["host", "val", "inv", "inst", "od", "att", "po", "object", "ex", "ctx", "j", "img", "o", "opt", "tmp", "pt", "impl", "fo", "api", "buf", "org", "pos", "conn", "ant", "nt", "ob", "Obj", "os", "op", "objects", "serv", "js", "env", "iv", "emb", "ev", "hw"], "v": ["vd", "uv", "i", "vt", "sv", "r", "l", "j", "n", "conv", "o", "vc", "p", "d", "m", "ov", "V", "w", "vm", "volt", "k", "tv", "g", "c", "vp", "vs", "t", "b", "u", "f", "e", "env", "ev", "hw", "s", "vv", "h"], "opaque": ["opaco", "oppacity", "opac", "operaco", " opac", "oppac", "oppaque", "opsalias", "operc", " opc", "operacity", " opacity", "opc", "operalias", " opalias", "opacity", " opaco", "oppaco", "opsc", "opalias", "opsaque", "operac", "operaque", "opsac"], "name": ["comment", "family", "i", "part", "value", "nm", "base", "ame", "error", "device", "code", "option", "n", "num", "o", "param", "key", "Name", "new", "alias", "number", "names", "nam", "word", "time", "property", "named", "label", "unknown", "a", "prefix", "type", "str", "data", "parent", "description", "port", "info", "image", "block", "none", "version", "space", "ip", "NAME", "address", "resource", "size", "pass", "x", "path", "desc"], "errp": ["nerpc", "errorf", " err", "errr", "resultpe", "erps", "eorpc", "resultr", "errorP", "errpr", "erP", "errpe", "eorp", "nerp", "errP", "errpat", "resultp", "errpc", "nerps", " errpr", " erp", "nerP", "erpe", "resultpc", "erp", "errorr", "erpr", " errpc", "erpat", "errorpat", "eorpr", "eorr", "errorpc", " errpe", " erpat", "erpc", "errf", "errorps", " errr", "err", "erf", "errorp", " erf", "errps"], "dev": ["gu", "md", "dd", "wd", "dc", "die", "bug", "od", "priv", "attr", "r", "device", "def", "de", "private", "conf", "o", "ve", "kind", "debug", "DEV", "p", "dm", "d", "cam", " priv", "w", "pub", "ad", "engine", "adv", "vol", "prom", "bus", "conn", "data", "pro", "development", "Dev", "gd", "info", "dem", "hw", "f", "ver", "ow", "rad", "env", "ev", "prov", "dom", "cd"], "prop": ["part", "pkg", "pr", "attr", "mp", "project", "properties", "prot", "device", "pb", "option", "def", "j", "p", "opt", "param", "ref", "root", "config", "pid", "typ", "property", "pod", "lit", "cp", "pos", "type", "owner", "data", "Prop", "pro", "pred", "jp", "info", "proc", "op", "f", "ip", "env", "phi", "pointer", "priv", "path"], "peers_ptr": ["peers_ref", "peers_pointers", "peer_pointers", "peer_ptr", "peers_tr", "peer_pointer", "peer_ref", "peers_pointer", "peer_tr"], "ptr": ["Ptr", "pri", "offset", "req", "loc", "inst", "attr", "pr", "prot", "fi", "tr", "rt", "grad", "pointers", "wr", "pt", "tmp", "alloc", "trace", "arr", "src", "ref", "dr", "peer", "plug", "buf", "pad", "vr", "pos", "ext", "fd", "str", "eth", "pro", "length", "port", " pointer", "pair", "phy", "rot", "proc", "inter", "pty", "slave", "spl", "ctr", "addr", "pointer", "br"], "local_err": ["local_addr", "localenerror", "remote_err", "localener", "localenerrors", " local_error", " local_errors", "local_er", "localenerr", "local_errors", "remote_addr", "local_bug", "local_war", " local_er", "remote_bug", "remote_war", "remote_er", "local_error", "remote_error"], "id": ["val", "i", "ident", "part", "ID", "ension", "base", "patch", "vid", "is", "code", "num", "sid", "kind", "p", "ig", "index", "ref", "key", "root", "d", "ids", "pid", "api", "age", "pad", "end", "type", "pc", "kid", "mid", "data", "Id", "ie", "path", "parent", "in", "url", "ide", "oid", "start", "info", "rid", "uid", "b", "q", "f", "ip", "address", "one", "addr", "x", "bit", "seq", "cd", "h"], "hubport": ["Hubports", " hubaddress", "homeport", "ubport", "homeaddress", " hubtype", "hubp", "hubPort", "Hubtype", "labports", " hubort", " hubPort", "ubPort", "labort", " hubports", "Hubpoint", "labpoint", "labserver", "ubort", "hubort", "homeort", "hubports", "Hubort", " hubserver", "bittype", "hubpoint", "labPort", "labport", "ubserver", " hubp", " hubpoint", "bitport", "bitports", "ubaddress", "hubaddress", "Hubport", "ubp", "hubtype", "homep", "HubPort", "hubserver", "bitort"]}}
{"project": "FFmpeg", "commit_id": "16c429166ddf1736972b6ccce84bd3509ec16a34", "target": 1, "func": "static av_cold int png_dec_end(AVCodecContext *avctx)\n\n{\n\n    PNGDecContext *s = avctx->priv_data;\n\n\n\n    ff_thread_release_buffer(avctx, &s->previous_picture);\n\n    av_frame_free(&s->previous_picture.f);\n\n    ff_thread_release_buffer(avctx, &s->last_picture);\n\n    av_frame_free(&s->last_picture.f);\n\n    ff_thread_release_buffer(avctx, &s->picture);\n\n    av_frame_free(&s->picture.f);\n\n    av_freep(&s->buffer);\n\n    s->buffer_size = 0;\n\n    av_freep(&s->last_row);\n\n    s->last_row_size = 0;\n\n    av_freep(&s->tmp_row);\n\n    s->tmp_row_size = 0;\n\n    av_freep(&s->extra_data);\n\n    s->extra_data_size = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 1439, "substitutes": {"avctx": ["afcontext", "avcu", "avecmp", "AVctx", "avectx", "avcus", "afcu", "AVnas", "mancms", " avcontext", "avnas", "afcus", "avalcb", "avcmp", "AVcu", "mancontext", "avcms", "afnas", "afcms", " avcmp", "afcas", "avalctx", "manctx", "afcmp", " avnas", "afctx", "avcb", "avecontext", "avecas", "AVcus", "afcb", "avalcms", "avecu", "avcas", "avconfig", "AVcontext", "avecb", "AVcmp", "avcontext", " avcus", "avalcontext", "avalcas", "manconfig", "avalconfig", "afconfig"], "s": ["i", "d", "stat", "an", "v", "ps", "sb", "sym", "as", "f", "os", "this", "js", "l", "si", "is", "o", "qs", "p", "ins", "css", "ses", "args", "b", "sg", "u", "ops", "sync", "h", "S", "r", "comm", "cs", "ctx", "ssl", "new", "m", "sq", "bs", "session", "w", "full", "service", "g", "us", "ks", "es", "gs", "t", "aws", "ss", "e", "ls", "ds", "xs", "fs", "ms", "sets", "ts", "ns", "n", "acs", "ans", "a", "services", "sys", "c", "rs", "self", "vs", "uploads", "its"]}}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void fd_chr_update_read_handler(CharDriverState *chr)\n\n{\n\n    FDCharDriver *s = chr->opaque;\n\n\n\n    if (s->fd_in_tag) {\n\n        g_source_remove(s->fd_in_tag);\n\n        s->fd_in_tag = 0;\n\n    }\n\n\n\n    if (s->fd_in) {\n\n        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);\n\n    }\n\n}\n", "idx": 1457, "substitutes": {"chr": ["chrb", "Chc", " chsr", "chc", "thsr", "chnrb", "thro", "cherru", " chrg", "cherr", "CHrg", "chnra", "Chr", "Chrs", " chrs", "CHrs", " chra", "chru", "Chsr", " chru", "cherra", "thr", "CHr", "cherrb", " chrb", " chc", "Chrg", "chrg", "chra", " chrf", " chro", "chrs", "chro", "chrf", "chnru", "Chro", "chnr", "chsr", "CHrf", "Chrf", "thc"], "s": ["S", "i", "fs", "r", "sv", "su", "sets", "ts", "ns", "l", "settings", "cs", "si", "is", "hs", "n", "uns", "ssl", "o", "p", "ins", "d", "bs", "se", "sa", "stat", "services", "stats", "service", "g", "your", "ps", "us", "sf", "ses", "spec", "c", "rs", "sb", "ks", "self", "es", "gs", "sym", "state", "args", "t", "b", "sg", "f", "aws", "ss", "js", "e", "sl", "ls", "its", "http", "ds", "sync"]}}
{"project": "FFmpeg", "commit_id": "73a60633143b7c51333a0772b45a47282ac445b6", "target": 1, "func": "static int probe_file(WriterContext *wctx, const char *filename)\n\n{\n\n    AVFormatContext *fmt_ctx;\n\n    int ret, i;\n\n    int section_id;\n\n\n\n    do_read_frames = do_show_frames || do_count_frames;\n\n    do_read_packets = do_show_packets || do_count_packets;\n\n\n\n    ret = open_input_file(&fmt_ctx, filename);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n#define CHECK_END if (ret < 0) goto end\n\n\n\n    nb_streams_frames  = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames));\n\n    nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets));\n\n    selected_streams   = av_calloc(fmt_ctx->nb_streams, sizeof(*selected_streams));\n\n\n\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n\n        if (stream_specifier) {\n\n            ret = avformat_match_stream_specifier(fmt_ctx,\n\n                                                  fmt_ctx->streams[i],\n\n                                                  stream_specifier);\n\n            CHECK_END;\n\n            else\n\n                selected_streams[i] = ret;\n\n            ret = 0;\n\n        } else {\n\n            selected_streams[i] = 1;\n\n        }\n\n    }\n\n\n\n    if (do_read_frames || do_read_packets) {\n\n        if (do_show_frames && do_show_packets &&\n\n            wctx->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER)\n\n            section_id = SECTION_ID_PACKETS_AND_FRAMES;\n\n        else if (do_show_packets && !do_show_frames)\n\n            section_id = SECTION_ID_PACKETS;\n\n        else // (!do_show_packets && do_show_frames)\n\n            section_id = SECTION_ID_FRAMES;\n\n        if (do_show_frames || do_show_packets)\n\n            writer_print_section_header(wctx, section_id);\n\n        ret = read_packets(wctx, fmt_ctx);\n\n        if (do_show_frames || do_show_packets)\n\n            writer_print_section_footer(wctx);\n\n        CHECK_END;\n\n    }\n\n\n\n    if (do_show_programs) {\n\n        ret = show_programs(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n\n\n    if (do_show_streams) {\n\n        ret = show_streams(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n    if (do_show_chapters) {\n\n        ret = show_chapters(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n    if (do_show_format) {\n\n        ret = show_format(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n\n\nend:\n\n    close_input_file(&fmt_ctx);\n\n    av_freep(&nb_streams_frames);\n\n    av_freep(&nb_streams_packets);\n\n    av_freep(&selected_streams);\n\n\n\n    return ret;\n\n}\n", "idx": 1469, "substitutes": {"wctx": ["awctx", "awcm", " wlc", "wlc", "wcb", "fctx", "awcca", "awcontext", "flc", "Wlc", "qtx", "wjc", "qjc", "wcm", "wcca", "qctx", " wcb", "wtx", "webtx", "Wctx", "webctx", "Wcmp", " wcca", " wcontext", "wcontext", "wcmp", " wcmp", " wtx", "twctx", " wjc", "twcm", "swctx", "qcontext", "webcontext", "fcmp", "twcca", "swcontext", "swcb", "fcontext", "webjc", "swcmp", " wcm", "twcontext", "Wcb", "Wcontext"], "filename": ["fn", "bf", "rb", "tty", "binary", "utf", "fp", "phrase", "location", "document", "title", "acl", "name", "word", "buffer", "Filename", "fil", "source", "file", "fd", "txt", "length", "il", "url", "dll", "files", "kl", "kn", "f", "rl", "directory", "username", "wl", "path"], "fmt_ctx": ["frt_context", "fmt_tx", "fmt_cv", "fmt2cv", "ftm_la", "fmtptx", "fmtpci", "fnt_rc", "filt_ctx", "fmt_co", "fnt_loc", "fnt_context", "fmtjc", "fmtjloc", "fformat_tx", "ftm_ctx", "fmt_lc", "fmt_c", "fmt2co", "filt_context", "frt_ctx", "filt_cv", "fnt_ctx", "fmtjctx", "fmt_cas", "fnt_tx", "fmt_la", "frt_cmp", "filt_co", "fmtpcontext", "fnt_lc", "fmtjcontext", "fformat_lc", "fmt_ca", "fmt_cms", "fformat_ctx", "filt_lc", "fnt_col", "fformat_cmp", "ftm_sc", "fmt2cmp", "fmt_context", "fmt_sc", "ftm_cas", "fnt_cmp", "fmt_ci", "fmt_cmp", "filt_cmp", "fmt_col", "frt_ca", "fmt2ctx", "filt_cms", "fnt_c", "fmtpctx", "fmt_loc", "fnt_ci", "fmt_rc"], "ret": ["rb", "match", "att", "num", "resp", "alt", "opt", "ref", "len", "lit", "ut", "feat", "reply", "sb", "ll", "info", "rot", "rep", "res", "sr", "error", "pet", "tr", " Ret", "valid", "fit", "rev", "format", "success", "rets", "data", "ry", "nt", "Ret", "ft", " RET", "flag", "code", "mem", "session", "obj", "status", "str", "fun", "reg", "cur", "cat", "bf", "val", "fail", "value", "back", "def", "rc", "rt", "RET", "arr", "det", "gt", "job", "id", "ext", "mt", "result", "db", "rl", "re", "en"], "i": ["ui", "part", "io", "l", "fi", "si", "j", "uri", "n", "y", "p", "ci", "ib", "multi", "qi", "ind", "eni", "d", "m", "oi", "id", "mi", "ri", "ini", "ii", "ij", "v", "bi", "x", "li", "iu", "ie", "zi", "di", "ix", "ai", "info", "abi", "pi", "mu", "gi", "f", "u", "b", "jit", "ti", "ip", "ni", "e", "xi", "I", "inner", "phi", "yi", "lc", "s", "index"], "section_id": ["section2num", "sectionalid", "section2ip", "sectionUit", "sectionUmin", "section_type", "thread_it", "sectionerids", "sectionEpad", " section_pad", " section_num", "section_pad", "threadUsearch", "section_uid", "sectionUid", "thread_min", "section2id", "sectionEtype", "section_kid", "sectionaltype", "sectionerid", "section_ip", "threadUid", " section_name", "section_ids", " section_uid", "sectionalside", "sectioneruid", "section_it", "section_search", "section_name", "sectionername", "section_min", "sector_type", "sectionEid", "sector_id", " section_type", "section_side", "section2type", "thread_search", "sector_kid", "threadUmin", "thread_id", " section_side", "sectionalpad", "sectionEside", " section_ids", "sector_name", "sectionUsearch", " section_ip", "section_num", "threadUit"], "selected_streams": ["selected_streamuploads", "selected_hooksets", "selected_feeds", "selected_draftships", "selected_streamsites", "selected_ucs", "selected_threadships", "selected_ucsites", "selected_outputd", "selected_ucd", "selected_draftments", "selected_draftsets", "selected_pathows", "selected_outputsites", "selected_streamows", "selected_threadd", "selected_threadments", "selected_streamsets", "selected_hooks", "selected_feedsites", "selected_streamds", "selected_feedd", "selected_columnflows", "selected_reamments", "selected_reamships", "selected_columnds", "selected_columnuploads", "selected_reams", "selected_pathsets", "selected_streamships", "selected_threads", "selected_threaduploads", "selected_draftows", "selected_outputs", "selected_outputds", "selected_reamd", "selected_lengthuploads", "selected_hookd", "selected_feedds", "selected_hookows", "selected_paths", "selected_threadflows", "selected_streamments", "selected_draftd", "selected_streamflows", "selected_lengthds", "selected_lengths", "selected_pathd", "selected_threadds", "selected_drafts", "selected_lengthflows", "selected_streamd", "selected_ucds", "selected_columns"]}}
{"project": "qemu", "commit_id": "51b0c6065aa6e47a47094d73e24be298a4a7f3a1", "target": 1, "func": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,\n\n                                          target_phys_addr_t end_addr)\n\n{\n\n    KVMState *s = kvm_state;\n\n    unsigned long size, allocated_size = 0;\n\n    KVMDirtyLog d;\n\n    KVMSlot *mem;\n\n    int ret = 0;\n\n\n\n    d.dirty_bitmap = NULL;\n\n    while (start_addr < end_addr) {\n\n        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);\n\n        if (mem == NULL) {\n\n            break;\n\n        }\n\n\n\n        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;\n\n        if (!d.dirty_bitmap) {\n\n            d.dirty_bitmap = qemu_malloc(size);\n\n        } else if (size > allocated_size) {\n\n            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);\n\n        }\n\n        allocated_size = size;\n\n        memset(d.dirty_bitmap, 0, allocated_size);\n\n\n\n        d.slot = mem->slot;\n\n\n\n        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n\n            DPRINTF(\"ioctl failed %d\\n\", errno);\n\n            ret = -1;\n\n            break;\n\n        }\n\n\n\n        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,\n\n                                      mem->start_addr, mem->memory_size);\n\n        start_addr = mem->start_addr + mem->memory_size;\n\n    }\n\n    qemu_free(d.dirty_bitmap);\n\n\n\n    return ret;\n\n}\n", "idx": 1473, "substitutes": {"start_addr": ["start_size", "end_ad", "end_src", "start64ace", "end_route", "starteraddress", "startipaddress", "start_ace", "start_ad", "start64addr", "end_ace", "start64host", "end_ptr", "startfullloc", "startfullroute", "start_host", "start_pos", "start_loc", "startfulladdress", "startipsize", "starteraddr", "startwaddr", "startwaddress", "startfhost", "start64ad", "start_route", "startfaddr", "start__hop", "start__address", "startfaddress", "start_slot", "start_ptr", "start_offset", "end_address", "end_loc", "start__offset", "end_slot", "starterptr", "starterpos", "startipaddr", "end_hop", "start_address", "startwhop", "start64address", "startipsrc", "start__addr", "end_size", "end_pos", "startfad", "end_offset", "start_src", "startfulladdr", "start_hop", "start64offset", "end_host", "startwslot"], "end_addr": ["start_size", "end__adr", "end_align", "endowpos", "end_ptr", "endowalign", "end__addr", " end_align", "end_adr", "end__ptr", "start_address", "start_offset", "start_ptr", "endfsize", "end__size", "endowaddress", "endowaddr", "end_address", "endfadr", "end__address", "end_size", "end_pos", "end_offset", " end_pos", "end__offset", "start_adr", " end_address", "endfaddr", "endfaddress"], "s": ["hm", "S", "i", "socket", "su", "r", "ts", "ns", "si", "n", "ssl", "o", "south", "p", "m", "sq", "session", "status", "w", "v", "sys", "g", "ses", "spec", "sf", "c", "sb", "site", "gs", "sym", "state", "t", "b", "f", "sg", "storage", "os", "aws", "js", "e", "sl", "instance", "client"], "size": ["i", "grow", "unit", "sec", "number", "sum", "len", "count", "ize", "weight", "large", "max", "go", "iz", "sized", "Size", "ui", "_", "si", " address", "false", " name", "name", "fee", "time", "data", "speed", "err", " sizes", " code", "SIZE", "offset", "content", "code", "new", "capacity", "full", "g", " error", "member", "length", "shape", "izes", "address", "e", " Size", "empty", "use", "cm", "value", "loc", "scale", "form", "id", "small", "storage", "handle", "big", "en"], "d": ["vd", "md", "mod", "dd", "wd", "i", "dc", "did", "dad", "done", "od", "l", "ded", "de", "j", "n", "er", "dl", "bd", "dj", "p", "o", "pd", "nd", "y", "dm", "dr", "ind", "m", "obj", "dat", "z", "id", "w", "dy", "ad", "ed", "ld", "dom", "k", "rd", "D", "fd", "g", "data", "dn", "xd", "c", "dt", "gd", "di", "dh", "state", "dict", "t", "db", "sd", "cmd", "f", "b", "u", " dd", "cd", "da", "e", "ct", "ds"], "mem": ["gu", "md", "mod", "wa", "tm", "cache", "home", "im", "nm", "com", "loc", "buff", "mor", "um", "de", "ram", "ge", "pm", "num", "lim", "alloc", "ha", "imm", "node", "mo", "m", "session", "job", "mi", "memory", "sum", "gem", "w", "vm", "name", "access", "lif", "mm", "dim", "mb", "mon", "am", "conn", "rm", "ann", "g", "ne", "member", "sp", "slot", "ev", "fun", "reg", "du", "prof", "info", "image", "mc", "em", "om", "program", "bin", "dem", "dev", "Mem", "sm", "serv", "bl", "go", "rem", "bm", "hw"]}}
{"project": "FFmpeg", "commit_id": "eb465b8c56d455fddf0f4f9f2625e2fe3ff7ea06", "target": 1, "func": "static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3],\n\n                   int dst_stride[3], int src_stride[3], int width,\n\n                   int height, uint8_t *qp_store, int qp_stride)\n\n{\n\n    int x, y, i, j;\n\n    const int count = 1<<p->log2_count;\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        int is_chroma = !!i;\n\n        int w = width  >> (is_chroma ? p->hsub : 0);\n\n        int h = height >> (is_chroma ? p->vsub : 0);\n\n        int stride = p->temp_stride[i];\n\n        int block = BLOCK >> (is_chroma ? p->hsub : 0);\n\n\n\n        if (!src[i] || !dst[i])\n\n            continue;\n\n        for (y = 0; y < h; y++) {\n\n            int index = block + block * stride + y * stride;\n\n\n\n            memcpy(p->src[i] + index, src[i] + y * src_stride[i], w );\n\n            for (x = 0; x < block; x++) {\n\n                p->src[i][index     - x - 1] = p->src[i][index +     x    ];\n\n                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];\n\n            }\n\n        }\n\n        for (y = 0; y < block; y++) {\n\n            memcpy(p->src[i] + (  block-1-y) * stride, p->src[i] + (  y+block  ) * stride, stride);\n\n            memcpy(p->src[i] + (h+block  +y) * stride, p->src[i] + (h-y+block-1) * stride, stride);\n\n        }\n\n\n\n        p->frame->linesize[i] = stride;\n\n        memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));\n\n    }\n\n\n\n    if (p->qp)\n\n        p->frame->quality = p->qp * FF_QP2LAMBDA;\n\n    else {\n\n        int qpsum=0;\n\n        int qpcount = (height>>4) * (height>>4);\n\n\n\n        for (y = 0; y < (height>>4); y++) {\n\n            for (x = 0; x < (width>>4); x++)\n\n                qpsum += qp_store[x + y * qp_stride];\n\n        }\n\n        p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA;\n\n    }\n\n//    init per MB qscale stuff FIXME\n\n    p->frame->height = height;\n\n    p->frame->width  = width;\n\n\n\n    for (i = 0; i < count; i++) {\n\n        const int x1 = offset[i+count-1][0];\n\n        const int y1 = offset[i+count-1][1];\n\n        const int x1c = x1 >> p->hsub;\n\n        const int y1c = y1 >> p->vsub;\n\n        const int BLOCKc = BLOCK >> p->hsub;\n\n        int offset;\n\n        AVPacket pkt;\n\n        int got_pkt_ptr;\n\n\n\n        av_init_packet(&pkt);\n\n        pkt.data = p->outbuf;\n\n        pkt.size = p->outbuf_size;\n\n\n\n        p->frame->data[0] = p->src[0] + x1   + y1   * p->frame->linesize[0];\n\n        p->frame->data[1] = p->src[1] + x1c  + y1c  * p->frame->linesize[1];\n\n        p->frame->data[2] = p->src[2] + x1c  + y1c  * p->frame->linesize[2];\n\n        p->frame->format  = p->avctx_enc[i]->pix_fmt;\n\n\n\n        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr);\n\n        p->frame_dec = p->avctx_enc[i]->coded_frame;\n\n\n\n        offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];\n\n\n\n        for (y = 0; y < height; y++)\n\n            for (x = 0; x < width; x++)\n\n                p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset];\n\n\n\n        if (!src[2] || !dst[2])\n\n            continue;\n\n\n\n        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1];\n\n\n\n        for (y = 0; y < height>>p->vsub; y++) {\n\n            for (x = 0; x < width>>p->hsub; x++) {\n\n                p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset];\n\n                p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset];\n\n            }\n\n        }\n\n    }\n\n\n\n    for (j = 0; j < 3; j++) {\n\n        int is_chroma = !!j;\n\n        if (!dst[j])\n\n            continue;\n\n        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j],\n\n                      width  >> (is_chroma ? p->hsub : 0),\n\n                      height >> (is_chroma ? p->vsub : 0),\n\n                      8-p->log2_count);\n\n    }\n\n}\n", "idx": 1476, "substitutes": {"p": ["lp", "part", "private", "pb", "temp", "d", "wp", "v", "ps", "sp", "parent", "jp", "pi", "P", "proc", "php", "f", "post", "cop", "s", "press", "l", "o", "exec", "up", "per", "python", "data", "port", "app", "pp", "comp", "current", "b", "q", "op", "u", "it", "h", "pg", "tp", "r", "bp", "project", "at", "m", "w", "cp", "pc", "g", "pro", "ap", "pre", "prev", "t", "ip", "e", "http", "progress", "cache", "n", "api", "k", "py", "a", "c", "self", "np", "vp", "hp", "pa", "parse"], "dst": ["fsts", "adst", "Dsrc", "dbl", "Dsts", "fbl", "drc", "ssts", "dsts", "Dstruct", "adsts", "sst", "idsrc", " dstruct", "adbl", "sbl", " dsrc", "dstruct", "dsrc", "frc", "idsts", "idstruct", "adrc", "fst", "idst", "Dst", " dsts"], "src": ["rend", "host", "gl", "dist", "support", "rb", "rect", "agg", "sur", "supp", "cmp", "loc", "inst", "sc", "sr", "attr", "secure", "rc", "sub", "prot", "sync", "ctx", "comb", "fc", "low", "ssl", "conv", "sel", "st", "img", "obl", "lib", "stack", "ins", "split", "config", "bs", "ptr", "sn", "rest", "rss", "cv", "enc", "dest", "gz", "front", "sb", "c", "url", "ser", "comp", "gb", "cb", "grad", "proc", "pack", "scenes", "rob", "cur", "serv", "sl", "iv", "sup", "uc", "seq", "source", "desc"], "dst_stride": ["dst_striider", "dst_arride", "dst_bride", "dst_arrand", "dst_striided", "dst_strand", "dst_brider", "dst_striand", "dst_strided", "dst_striide", "dst_brided", "dst_strider", "dst_arrider", "dst_arrided", "dst_brand"], "src_stride": ["src_striider", "src_bride", "src_dridi", "src_arrided", "src_arride", "src_striidi", "src_striide", "src_brider", "src_stridi", "src_strided", "src_strider", "src_striride", "src_arrider", "src_bridi", "src_dride", "src_drride", "src_drided", "src_brided", "src_striided", "src_brride", "src_strride", "src_arrride"], "height": ["high", "wall", "rh", "padding", "density", "bottom", "layout", "crop", "hang", "d", "z", "head", "alpha", "w", "resolution", "dy", "pad", "build", "distance", "window", "length", "duration", "shape", "fw", "direction", "rank", "margin", "depth", "block", "image", "gap", "ip", "Height", "size", "pull", "thin", "h", "volume", "holes"], "qp_store": ["qlp__slice", "qlp_slice", "qlp__store", "qlp__base", "qp__base", "qp__store", "qlp_draw", "qp_base", "qlp_store", "qp_draw", "qlp__draw", "qp__draw", "qlp_base", "qp_slice", "qp__slice"], "qp_stride": ["qp_striid", "qp_strider", "qp_brider", "qp_bride", "qp_trided", "qp_brided", "qp_trider", "qp_striided", "qp_tride", "qp_brid", "qp_strided", "qp_trid", "qp_striider", "qp_strid", "qp_striide"], "x": ["wy", "xxx", "wa", "wx", "r", "cy", "X", "ww", "l", "ex", "is", "code", "n", "xx", "o", "rx", "key", "d", "m", "yx", "z", "id", "w", "time", "Y", "dy", "k", "xp", "px", "on", "v", "a", "pos", "g", "xy", "c", "ix", "tx", "dx", "t", "b", "f", "ax", "u", "q", "ady", "e", "xi", "h", "xs", "s", "index"], "y": ["hi", "hy", "ny", "cy", "yl", "ey", "n", "o", "index", "ky", "yn", "yr", "sy", "ya", "d", "m", "vy", "z", "id", "w", "Y", "dy", "ii", "oy", "py", "zy", "year", "ye", "g", "ym", "ry", "xy", "c", "iy", "ay", "gy", "block", "yo", "col", "t", "b", "f", "u", "ady", "e", "sky", "ty", "yi", "yy", "h"], "i": ["chi", "part", "uri", "d", "z", "mi", "ri", "v", "bi", "iu", "ie", "ji", "ix", "info", "ih", "pi", "f", "ti", "iv", "ki", "phi", "ui", "l", "is", "si", "o", "ci", "qi", "eni", "I", "li", "init", "b", "u", "xi", "it", "h", "io", "ik", "fi", "multi", "m", "oi", "ori", "ini", "ij", "zi", "ai", "t", "ei", "ip", "e", "esi", "yi", "index", "isi", "n", "cli", "id", "api", "k", "ii", "a", "mini", "c", "di", "abi", "gi", "ni"], "j": ["r", "shift", "l", "n", "sh", "o", "d", "m", "z", "adj", "dy", "k", "ij", "ii", "v", "pos", "g", "ji", "c", "jp", "b", "q", "f", "e"]}}
{"project": "qemu", "commit_id": "a9e1c28ddaae5a48415fec1f336b5560eb85d3e1", "target": 0, "func": "int main(void)\n\n{\n\n    int nf;\n\n    Suite *s;\n\n    SRunner *sr;\n\n\n\n    s = qfloat_suite();\n\n    sr = srunner_create(s);\n\n\n\n    srunner_run_all(sr, CK_NORMAL);\n\n    nf = srunner_ntests_failed(sr);\n\n    srunner_free(sr);\n\n\n\n    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n\n}\n", "idx": 1487, "substitutes": {"nf": ["cnb", "Nfen", "nnfe", "cnfe", "nyf", "lnfen", "nyfen", "nnfen", "ynf", "Nf", "nyb", " nfe", "Nfe", "Nb", "cnc", "cnf", " nfen", "nb", "nnF", "Nc", "lnf", "ynF", "nc", "ynfen", " nc", "ynfe", "lnfe", "nfe", "nF", "nfen", "lnF", "nnf", " nb", "nyc"], "s": ["S", "fs", "cr", "sw", "r", "sv", "su", "ts", "ns", "tr", "cs", "si", "ssl", "o", "south", "p", "bs", "sq", "se", "sa", "services", "sys", "sie", "service", "g", "stats", "ps", "server", "ses", "c", "rs", "sb", "es", "ar", "gs", "t", "os", "b", "f", "sts", "space", "ss", "e", "sl", "ls", "ds", "sync"], "sr": ["fr", "rb", "sw", "cr", "rr", "sur", "gr", "ir", "r", "pr", "rh", "sv", "SR", "tr", "rt", "cs", "rx", "yr", "usr", "dr", "spr", "rf", "JR", "rw", "rss", "vr", "rd", "sp", "RR", "kr", "sb", "rs", "rg", "hr", "nr", "ser", "sol", "ar", "ru", "rn", "RS", "ss", "lr", "sl", "ctr"]}}
{"project": "qemu", "commit_id": "d78c19b5cf4821d0c198f4132a085bdbf19dda4c", "target": 0, "func": "static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,\n\n                                target_ulong tce)\n\n{\n\n    IOMMUTLBEntry entry;\n\n    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);\n\n    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;\n\n\n\n    if (index >= tcet->nb_table) {\n\n        hcall_dprintf(\"spapr_vio_put_tce on out-of-bounds IOBA 0x\"\n\n                      TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    tcet->table[index] = tce;\n\n\n\n    entry.target_as = &address_space_memory,\n\n    entry.iova = ioba & page_mask;\n\n    entry.translated_addr = tce & page_mask;\n\n    entry.addr_mask = ~page_mask;\n\n    entry.perm = spapr_tce_iommu_access_flags(tce);\n\n    memory_region_notify_iommu(&tcet->iommu, entry);\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 1497, "substitutes": {"tcet": ["tmett", "scet", "kuote", "cmnt", "TCET", "tomett", "tmets", "rcen", "tcets", "TCett", " tcset", "tcett", "bcant", "tcat", "kuet", "cmat", "tomot", "TCets", "dcent", "tcrt", "kuset", "scent", "TCant", "tocant", "tocet", "ncet", "tment", "TClet", "tmot", "bcnt", " tcote", "cmet", "hhET", "tmrt", "scnt", "TCnt", "bclet", "cment", " tcpet", "TCent", "tocnt", "TCet", "bcet", "timset", "tomET", "timet", "hhinet", "tclet", "bcent", "rcinet", "tmET", "tcET", "tcnt", "toclet", "timpet", "tocrt", "bcat", "dcet", "tmant", "ncen", "tocET", "TCot", "tcot", "ncinet", "TCrt", "tcset", "tcpet", "kupet", "hhen", "dcets", "tmet", "timote", "rcET", "tcinet", "tocets", "dcant", "scat", "tomet", "hhet", "tcen", "tcant", "rcet", "ncET", "tcent", "tcote"], "ioba": ["piobi", "enioba", "tioga", "ioco", "sioby", "tioby", "ioga", "pioba", " iogg", "iogg", "uoma", "siobe", "ioca", "iobi", "tioba", "iobe", "sioga", " ioco", " ioby", "lioha", "sioca", "uogg", "siogg", " iobe", "enioha", "enioby", " ioca", "ioma", "siobi", " ioma", "uobe", "liunta", "sioma", "iunta", "piunta", " ioga", "pioco", "ioby", "sioba", "ioha", "eniunta", "pioby", "piobe", "pioha", "tioca", "lioby", "lioba", " iobi", "sioco", "uoba"], "tce": ["tcp", "pke", "lcp", "pfe", "Tace", "ttcer", " tace", " tcer", " tke", "lcf", "TCE", "fcer", "tCE", "tco", "Tco", "fCE", "ptfe", "tche", "ttche", "lce", "ptct", "ptco", "lke", "fche", "ptce", "Tct", "lCE", "fce", "tfe", "Tfe", " tcf", "Tcp", "Tce", "pcf", "lfe", "ttce", "tke", "tct", "tcer", "tcf", " tct", " tCE", "lace", "ttCE", " tco", " tche", " tfe", "tace", " tcp", "pce"], "entry": ["comment", "cat", "line", "feed", "insert", "offset", "part", "way", " Entry", "enter", "try", "it", "error", "match", "Entry", "array", "ge", "cell", "valid", "or", "key", "new", "connection", "write", "module", "se", "obj", "send", "step", "route", "join", "element", "engine", "import", "event", "end", "type", "service", "data", "add", "ie", "row", "member", "server", "ry", "export", "info", "seed", "result", "image", "ent", "response", "inter", "inc", "cur", "component", "address", "extra", "e", "parse", "cel", "slave", "inner", "reader", "record", "link", "index"]}}
{"project": "qemu", "commit_id": "f73a2575a3bce8a3c487331c918d2c0f9b2e489d", "target": 0, "func": "static target_ulong h_enter(CPUState *env, sPAPREnvironment *spapr,\n\n                            target_ulong opcode, target_ulong *args)\n\n{\n\n    target_ulong flags = args[0];\n\n    target_ulong pte_index = args[1];\n\n    target_ulong pteh = args[2];\n\n    target_ulong ptel = args[3];\n\n    target_ulong i;\n\n    uint8_t *hpte;\n\n\n\n    /* only handle 4k and 16M pages for now */\n\n    if (pteh & HPTE_V_LARGE) {\n\n#if 0 /* We don't support 64k pages yet */\n\n        if ((ptel & 0xf000) == 0x1000) {\n\n            /* 64k page */\n\n        } else\n\n#endif\n\n        if ((ptel & 0xff000) == 0) {\n\n            /* 16M page */\n\n            /* lowest AVA bit must be 0 for 16M pages */\n\n            if (pteh & 0x80) {\n\n                return H_PARAMETER;\n\n            }\n\n        } else {\n\n            return H_PARAMETER;\n\n        }\n\n    }\n\n\n\n    /* FIXME: bounds check the pa? */\n\n\n\n    /* Check WIMG */\n\n    if ((ptel & HPTE_R_WIMG) != HPTE_R_M) {\n\n        return H_PARAMETER;\n\n    }\n\n    pteh &= ~0x60ULL;\n\n\n\n    if ((pte_index * HASH_PTE_SIZE_64) & ~env->htab_mask) {\n\n        return H_PARAMETER;\n\n    }\n\n    if (likely((flags & H_EXACT) == 0)) {\n\n        pte_index &= ~7ULL;\n\n        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);\n\n        for (i = 0; ; ++i) {\n\n            if (i == 8) {\n\n                return H_PTEG_FULL;\n\n            }\n\n            if (((ldq_p(hpte) & HPTE_V_VALID) == 0) &&\n\n                lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) {\n\n                break;\n\n            }\n\n            hpte += HASH_PTE_SIZE_64;\n\n        }\n\n    } else {\n\n        i = 0;\n\n        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);\n\n        if (!lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) {\n\n            return H_PTEG_FULL;\n\n        }\n\n    }\n\n    stq_p(hpte + (HASH_PTE_SIZE_64/2), ptel);\n\n    /* eieio();  FIXME: need some sort of barrier for smp? */\n\n    stq_p(hpte, pteh);\n\n\n\n    assert(!(ldq_p(hpte) & HPTE_V_HVLOCK));\n\n    args[0] = pte_index + i;\n\n    return H_SUCCESS;\n\n}\n", "idx": 1500, "substitutes": {"env": ["manager", "inv", "her", "equ", "context", "enc", "eye", "profile", "conf", "dir", "eu", "exec", "ec", "viron", "eni", "config", "dat", "stage", "chal", " environment", "engine", "eve", "fen", "cv", "event", "energy", "ext", "conn", "el", "erv", "txt", "ea", "server", "enh", "iss", "site", "dt", "ef", "np", "scope", "exc", "state", "global", "dict", "db", "gui", "que", "eur", "e", "environment", "esi", "net", "qt", "ev", "fg", "en", "Environment"], "spapr": ["papprc", "spamprc", "papper", "papprs", "spAPr", "spAPrc", "spaprc", "spampr", "spapper", "spaprs", "spamprs", "spamper", "spappr", "papr", "pappr", "paper", "spapprc", "spapprs", "spAPrs", "spaper", "spAPer", "paprs", "paprc"], "opcode": ["ipptr", "opcomp", "opcodes", "ipcode", "popcodes", "topcode", "ipcomp", "popptr", "opptr", "topcomp", "topptr", "popcomp", "topcodes", "ipcodes", "popcode"], "args": ["ports", " arguments", "flags", "ms", "uses", "settings", "array", "seconds", "enc", "date", "ims", "is", "axis", "p", "Args", "fields", "includes", "ins", "uments", "names", "config", "words", "call", "members", "actions", "ages", "alls", "stats", "data", "arms", "message", "apps", "lines", "argument", "keys", "vals", "points", "ants", "ams", "results", "gs", "options", "arg", "parts", "limits", "objects", "fires", "as", "utils", "GS", "aws", "extra", "parse", "ars", "use", "atts", "params"], "i": ["chi", "ui", "l", "fi", "is", "si", "j", "n", "uri", "o", "y", "p", "ci", "key", "multi", "uni", "qi", "eni", "d", "m", "z", "mi", "id", "k", "ini", "ii", "slice", "count", "v", "a", "bi", "x", "mini", "li", "iu", "ie", "ji", "c", "zi", "di", "start", "ai", "info", "image", "pi", "mu", "ei", "b", "u", "f", "ti", "gi", "ip", "ni", "e", "xi", "I", "it", "phi", "yi", "s", "index"], "hpte": ["hpointen", "Hpteh", "haptes", "hemptee", "hported", " hntea", "Hptea", "hpointel", "hptea", "pnt\n", "hptone", "Hpted", "hpto", "hPTe", " hptes", "hctei", "hctE", " hptee", "hcondee", "hpointes", "hpportee", "Hctel", "hpporte", "haptee", "hctes", "hpti", "hnt\n", "hrtel", "hcondes", " hptea", " hapto", "hpt_", "hptonee", "hveyea", "hprea", "hPTen", "hptedge", "hpport_", "hptee", "hveyee", "Hptel", "Hpti", "hnt_", "hptoneh", "hpointi", "hctea", "hport_", "Hcten", "hcti", "Hctea", "hpointe", "hntee", "hcondedge", "Hpten", "hpted", "Hptee", "hporte", "hpointo", "Hctee", "hport\n", "hempte", "Hcteh", "pnt_", "hctedge", " hntee", "hptei", "hntea", "hrto", " hptE", " haptee", "hpteh", " haptel", "hPTi", "hctel", "ppt_", " hapte", "hipte", "hpree", "haptel", "hnte", " hptel", "hveye", "hconde", "hntE", "hpten", "Hpte", "hrte", "Hcte", " haptedge", "hporteh", "Hcti", "hpre", "hPTee", "hcteh", "hapto", "hrtes", "hpt\n", "hpport\n", "hprel", "hapte", "hemptea", "hveyei", "Hcted", "hptes", "hiptE", "Hptei", "hportee", "hcten", "hpportea", " haptes", "hpportei", "hptel", "hiptea", " hntE", "Hctei", "hptE", "hpointee", "ppt\n", "hcted", "hcte", " hpto", "hiptee", " hnte", " hptedge", "haptedge", "hptoned", "hemptel", "hctee"]}}
{"project": "qemu", "commit_id": "ffe30937c89dd67a53bf3f35b962701cd9d8f70e", "target": 1, "func": "static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,\n\n                                    TCGv arg2, int add_ca, int compute_ca,\n\n                                    int compute_ov)\n\n{\n\n    TCGv t0, t1;\n\n\n\n    if ((!compute_ca && !compute_ov) ||\n\n        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {\n\n        t0 = ret;\n\n    } else {\n\n        t0 = tcg_temp_local_new();\n\n    }\n\n\n\n    if (add_ca) {\n\n        t1 = tcg_temp_local_new();\n\n        tcg_gen_mov_tl(t1, cpu_ca);\n\n    } else {\n\n        TCGV_UNUSED(t1);\n\n    }\n\n\n\n    if (compute_ca) {\n\n        /* Start with XER CA disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ca, 0);\n\n    }\n\n    if (compute_ov) {\n\n        /* Start with XER OV disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ov, 0);\n\n    }\n\n\n\n    tcg_gen_add_tl(t0, arg1, arg2);\n\n\n\n    if (compute_ca) {\n\n        gen_op_arith_compute_ca(ctx, t0, arg1, 0);\n\n    }\n\n    if (add_ca) {\n\n        tcg_gen_add_tl(t0, t0, t1);\n\n        gen_op_arith_compute_ca(ctx, t0, t1, 0);\n\n        tcg_temp_free(t1);\n\n    }\n\n    if (compute_ov) {\n\n        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);\n\n    }\n\n\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, t0);\n\n\n\n    if (!TCGV_EQUAL(t0, ret)) {\n\n        tcg_gen_mov_tl(ret, t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n", "idx": 1507, "substitutes": {"ctx": ["kb", "kw", "gru", "git", "cc", "jc", "pkg", "JC", "mac", "req", "loc", "sc", "cf", "rc", "cmp", "context", "grad", "chan", "cm", "linux", "conv", "lib", "cca", "vc", "exec", "ci", "fp", "cli", "config", "sq", "concept", "qt", " cx", "qa", "Context", "tc", "sci", "cv", "cp", "gpu", "conn", "ca", "ocr", "hub", "progress", "c", "ctrl", "comp", "scope", "np", "kt", "ch", "jp", "mc", "cb", "tx", "crit", "ck", "cpu", "exc", "cmd", "cl", "client", "utils", "component", "bc", " context", "cas", "sync", "hw", "anc"], "ret": ["eval", "cat", "val", "git", "res", "value", "back", "att", "def", "match", "cmp", "fi", "rt", "tr", "active", "resp", "linux", "alt", "rx", "opt", "RET", "ref", "mem", "usr", "det", "gt", "rev", "obj", "id", "status", "job", "store", "len", "lit", "python", "conn", "rets", "ext", "sys", "data", "reply", "mt", "txt", "ry", "nt", "reg", "jp", "info", "result", "cpu", "cb", "arg", "Ret", "ft", "aux", "re", "out", "addr", "final", "rem", "seq"], "arg1": ["ar1", "arg0", " arg3", "arg01", "tagone", "arg12", "arm1", "ar3", "ar2", "tag01", " argone", "arm01", "rg01", "att1", "argument01", "args3", "rg1", "argsone", "Argone", " arg0", "rg3", "ar0", "tag2", "tag1", "argument3", "armone", "att12", "t3", "args2", "argone", "t2", "Arg1", "arg3", "args1", "att3", "rg2", "att2", " arg01", "Arg3", "arm2", "argument12", "argument2", " arg12", "Arg2", "argument1"], "arg2": ["ttwo", "tag62", "val62", "arg0", "tagsecond", "ig2", " arg96", " argtwo", " arg4", "Arg4", "valsecond", " argsecond", " argTwo", "Arg0", "args0", "docTwo", "argtwo", "argument0", "ig96", "args4", " arg0", " arg62", "ig1", "argument96", "tag1", "tag2", "arg4", "doctwo", "args2", "ig0", "t2", "tTwo", "argsecond", "Arg1", "doc1", "arg62", "doc2", "args1", "val2", "val1", "argTwo", "argument2", "arg96", "Arg2", "argument1"], "add_ca": ["addsba", "append_cca", "addingacl", "update_car", "addfcar", "addsna", " add_aca", " add_acl", "add_aca", "add_cas", "addingCa", "add_cca", "addfcca", "update_ca", "add_na", "add_car", "append_ca", "addfcas", "appendfcar", "addfca", "addingca", "appendfca", "add_ba", "addsca", "append_car", "append_cas", "appendfcas", "addscar", "update_ba", "appendfcca", "addingaca", "update_na", " add_Ca", "add_acl", "add_Ca"], "compute_ca": ["compute_na", "compulate_ca", "compute___Ca", "compulate_Ca", "compute_ha", "compure_ha", "compute___na", "compute_ce", "compute_Ca", "compute__ce", "compure_ca", "compure_na", "compure_ce", "compute___ca", "compure_Ca", "compulate_ba", "compute_bc", "compute_cr", "compute___ce", "compute_ec", "compure_ec", "compute__ca", "compure_bc", "compute__na", "compute__Ca", "compute___bc", "compute_ba", "compulate_cr"], "compute_ov": ["compute__ove", "compute___uda", "computeableev", "compure_ovi", "compure_ove", "computeableou", "compute___ove", "compure_ou", "compate_ov", "compate_o", "compute_o", "compute___ov", "compate_ou", "compute_ou", "compute_vo", "compute__ov", "compute64ov", "compute__ovi", "compute___ovi", "compure_uda", "compute_ove", "compute_uda", "compute_ovi", "computeableOV", "compute__uda", "compute_oo", "computeableo", "compure_o", "compute_ev", "compure_ov", "compure_oo", "compute_OV", "compure_ev", "compute64o", "compute64ou", "compure_OV", "computeableov", "computeablevo", "compute64oo", "compure_vo", "compate_vo"], "t0": ["t80", "ty1", "t25", "p1", "tree000", "t00", "tt02", "nt050", "p80", "tree0", "at0", "f2", "ty0", "nt3", "pok", " t25", "te0", "p050", "ft0", " t00", "at3", "p4", "p25", " pt1", "t4", " t4", " t3", "tt1", " T2", "ty00", "tt0", "t100", "test1", "T02", "dt80", "ft100", "ntok", " T20", " t100", "T0", " t20", "T4", "nt0", "tt60", "nt1", "ft000", "f3", " pt20", "test80", "p3", "dt1", "t050", "p0", "te1", "t60", " t2", " T1", "at1", "ft2", "T3", "t2", "te4", " t02", "test60", "ty4", "T1", "t02", " t000", "p2", "nt2", "f1", "f0", " t050", "tt80", " pt0", "test0", "T80", "t000", "nt02", "te25", "dt0", "t3", "at02", "dt2", "t20", " T0", "ttok", "tree2", "T00", "p02", " pt2", "tree100", "T2", "tok", "p60"], "t1": ["litOne", "t80", "t001", "at80", "t01", "tt001", "f121", "T121", "arg0", "f0", "arg01", "p0", "te1", "temp2", "tt1", "T80", "p1", " t2", "T01", " tone", "tie1", "temp1", "tone", "at1", "t121", "te2", "temp0", "t2", "lit1", "argone", "p80", "Tone", "at0", "f2", "tName", "T0", "pone", "T1", "te121", "at2", "ttName", "te0", "p2", "lit001", "ttOne", "tie001", "f1", "fone", "tempone", " t01", "T2", "tieName", "tieOne", "litName", "tOne"]}}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size)\n\n{\n\n    const uint16_t *end;\n\n    const uint16_t *mm_end;\n\n    uint8_t *d = dst;\n\n    const uint16_t *s = (const uint16_t*)src;\n\n    end = s + src_size/2;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*s):\"memory\");\n\n    mm_end = end - 7;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movq          %1, %%mm0    \\n\\t\"\n\n            \"movq          %1, %%mm1    \\n\\t\"\n\n            \"movq          %1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            \"movq       %%mm0, %%mm3    \\n\\t\"\n\n            \"movq       %%mm1, %%mm4    \\n\\t\"\n\n            \"movq       %%mm2, %%mm5    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm0    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm1    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm2    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm3    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm4    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm5    \\n\\t\"\n\n            \"psllq         $8, %%mm1    \\n\\t\"\n\n            \"psllq        $16, %%mm2    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"psllq         $8, %%mm4    \\n\\t\"\n\n            \"psllq        $16, %%mm5    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n\n\n            \"movq       %%mm0, %%mm6    \\n\\t\"\n\n            \"movq       %%mm3, %%mm7    \\n\\t\"\n\n\n\n            \"movq         8%1, %%mm0    \\n\\t\"\n\n            \"movq         8%1, %%mm1    \\n\\t\"\n\n            \"movq         8%1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            \"movq       %%mm0, %%mm3    \\n\\t\"\n\n            \"movq       %%mm1, %%mm4    \\n\\t\"\n\n            \"movq       %%mm2, %%mm5    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm0    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm1    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm2    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm3    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm4    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm5    \\n\\t\"\n\n            \"psllq         $8, %%mm1    \\n\\t\"\n\n            \"psllq        $16, %%mm2    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"psllq         $8, %%mm4    \\n\\t\"\n\n            \"psllq        $16, %%mm5    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s),\"m\"(mask15b),\"m\"(mask15g),\"m\"(mask15r), \"m\"(mmx_null)\n\n            :\"memory\");\n\n        /* borrowed 32 to 24 */\n\n        __asm__ volatile(\n\n            \"movq       %%mm0, %%mm4    \\n\\t\"\n\n            \"movq       %%mm3, %%mm5    \\n\\t\"\n\n            \"movq       %%mm6, %%mm0    \\n\\t\"\n\n            \"movq       %%mm7, %%mm1    \\n\\t\"\n\n\n\n            \"movq       %%mm4, %%mm6    \\n\\t\"\n\n            \"movq       %%mm5, %%mm7    \\n\\t\"\n\n            \"movq       %%mm0, %%mm2    \\n\\t\"\n\n            \"movq       %%mm1, %%mm3    \\n\\t\"\n\n\n\n            STORE_BGR24_MMX\n\n\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s)\n\n            :\"memory\");\n\n        d += 24;\n\n        s += 8;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        register uint16_t bgr;\n\n        bgr = *s++;\n\n        *d++ = (bgr&0x1F)<<3;\n\n        *d++ = (bgr&0x3E0)>>2;\n\n        *d++ = (bgr&0x7C00)>>7;\n\n    }\n\n}\n", "idx": 1508, "substitutes": {"src": ["dist", "inf", "rb", "loc", "r", "sc", "inst", "rc", "enc", "st", "begin", "ins", "m", "config", "split", "rec", "rd", "dest", "fd", "gz", "length", "sb", "rs", "c", "gb", "start", "image", "b", "f", "cur", "sl", "ds", "h", "source"], "dst": ["dbl", "fbl", "delsc", "dsts", "delst", "lbl", "dsc", "fsrc", "lsrc", " dsrc", "bdct", "ydct", " dbl", "ydst", "bdsts", "lst", "dsrc", "dct", "dfe", "delsts", "lfe", "bdsc", "ydsc", "fst", "delct", " dfe", "ydsts", "bdst", "ffe"], "src_size": [" src_end", "rc_scale", "rc_size", " src_scale", "src_scale", "src_end", "rc_end"], "end": ["offset", "open", "r", "en", "enc", "END", "begin", "p", "nd", "ff", "m", "edge", "se", "z", "id", "send", "w", "ad", "k", "stop", "v", "est", "c", "start", "ending", "End", "eff", "max", "f", "size", "e", "x", "ended", "h"], "mm_end": [" mm_start", " mm_stop", "mount_end", "mm2end", "mem_ad", "mm2ends", "mm_enter", "mount_ends", "mm_ends", "mm_ad", "mm_stop", "mm_ended", "mem_end", "mm2start", "mem_start", "mm_start", "mount_start", "mm2enter", "mount_enter", "mem_ended"], "d": ["dd", "i", "dc", "r", "l", "n", "dl", "o", "p", "pd", "nd", "ind", "m", "dat", "z", "id", "w", "ad", "dy", "dim", "v", "D", "fd", "g", "data", "dn", "c", "dt", "di", "dh", "t", "sd", "b", "f", "u", "q", "db", "dp", "da", "e", "x", "ds", "h", "cd"], "s": ["S", "i", "fs", "sv", "r", "su", "sets", "ts", "l", "ns", "sync", "si", "is", "j", "n", "sec", "sh", "o", "y", "south", "p", "m", "sq", "se", "session", "z", "w", "v", "services", "sys", "states", "g", "ps", "lines", "spec", "ses", "c", "sb", "rs", "es", "start", "gs", "sym", "t", "sd", "b", "f", "u", "ss", "side", "e", "sl", "x", "ds", "h"]}}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int inet_dgram_opts(QemuOpts *opts)\n\n{\n\n    struct addrinfo ai, *peer = NULL, *local = NULL;\n\n    const char *addr;\n\n    const char *port;\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int sock = -1, rc;\n\n\n\n    /* lookup peer addr */\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;\n\n    ai.ai_family = PF_UNSPEC;\n\n    ai.ai_socktype = SOCK_DGRAM;\n\n\n\n    addr = qemu_opt_get(opts, \"host\");\n\n    port = qemu_opt_get(opts, \"port\");\n\n    if (addr == NULL || strlen(addr) == 0) {\n\n        addr = \"localhost\";\n\n    }\n\n    if (port == NULL || strlen(port) == 0) {\n\n        fprintf(stderr, \"inet_dgram: port not specified\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0))\n\n        ai.ai_family = PF_INET;\n\n    if (qemu_opt_get_bool(opts, \"ipv6\", 0))\n\n        ai.ai_family = PF_INET6;\n\n\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n\treturn -1;\n\n    }\n\n    if (sockets_debug) {\n\n        fprintf(stderr, \"%s: peer (%s:%s)\\n\", __FUNCTION__, addr, port);\n\n        inet_print_addrinfo(__FUNCTION__, peer);\n\n    }\n\n\n\n    /* lookup local addr */\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE;\n\n    ai.ai_family = peer->ai_family;\n\n    ai.ai_socktype = SOCK_DGRAM;\n\n\n\n    addr = qemu_opt_get(opts, \"localaddr\");\n\n    port = qemu_opt_get(opts, \"localport\");\n\n    if (addr == NULL || strlen(addr) == 0) {\n\n        addr = NULL;\n\n    }\n\n    if (!port || strlen(port) == 0)\n\n        port = \"0\";\n\n\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n        return -1;\n\n    }\n\n    if (sockets_debug) {\n\n        fprintf(stderr, \"%s: local (%s:%s)\\n\", __FUNCTION__, addr, port);\n\n        inet_print_addrinfo(__FUNCTION__, local);\n\n    }\n\n\n\n    /* create socket */\n\n    sock = socket(peer->ai_family, peer->ai_socktype, peer->ai_protocol);\n\n    if (sock < 0) {\n\n        fprintf(stderr,\"%s: socket(%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family), strerror(errno));\n\n        goto err;\n\n    }\n\n    setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));\n\n\n\n    /* bind socket */\n\n    if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen,\n\n                    uaddr,INET6_ADDRSTRLEN,uport,32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (bind(sock, local->ai_addr, local->ai_addrlen) < 0) {\n\n        fprintf(stderr,\"%s: bind(%s,%s,%d): OK\\n\", __FUNCTION__,\n\n                inet_strfamily(local->ai_family), uaddr, inet_getport(local));\n\n        goto err;\n\n    }\n\n\n\n    /* connect to peer */\n\n    if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen,\n\n                    uaddr, INET6_ADDRSTRLEN, uport, 32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (connect(sock,peer->ai_addr,peer->ai_addrlen) < 0) {\n\n        fprintf(stderr, \"%s: connect(%s,%s,%s,%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family),\n\n                peer->ai_canonname, uaddr, uport, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    freeaddrinfo(local);\n\n    freeaddrinfo(peer);\n\n    return sock;\n\n\n\nerr:\n\n    if (-1 != sock)\n\n        closesocket(sock);\n\n    if (local)\n\n        freeaddrinfo(local);\n\n    if (peer)\n\n        freeaddrinfo(peer);\n\n    return -1;\n\n}\n", "idx": 1519, "substitutes": {"opts": ["operments", "opTS", "opfs", "optcs", "popt", "OPcs", "optps", "optr", "optts", "oputs", "OPuts", "poptes", "otts", "operts", "opments", "opt", "obted", " optr", "ottes", "operets", "optfs", "OPt", "obts", "opets", "popts", "promets", "obt", "optt", "opercs", "operfs", "operuts", "OPTS", "optuts", "opted", "poputs", "optted", "opps", " opments", "promtes", "optes", "operps", "OPts", "optets", "OPted", "opertr", "opcs", " opTS", "otments", "opertes", "operTS", "optTS", "obTS", "opttes", "opttr", "optments", "OPfs", "OPtes", "promps", "otuts", "opert", "promts"], "ai": ["i", "agi", "lib", "mi", " mi", "sa", "qa", "an", "sci", "bi", "afi", "ami", "parent", "ay", "plugin", "channel", "aii", "ti", " li", "admin", "mod", "wa", " bi", "ui", " ga", "ac", "ait", "pai", "ta", "si", "apache", "ha", "ci", "p", "qi", "eni", "config", "org", "li", "app", "ee", "fa", " api", "ais", "na", "net", "aud", "SA", "ape", "io", " pri", " ac", "pin", " ta", "asc", "conn", "pc", "ann", "server", "hai", "ei", "address", "http", "cm", "cache", "mac", "loc", "attr", "connection", "adr", "module", "af", "bridge", "ga", "api", "ae", " sa", "aa", "py", "a", "ca", "co", "AI", "asm", "di", "asi", " ca", "db", "gui", "gi", "pa", "au", "ni", "client"], "peer": ["user", "host", "family", "offset", "tp", "socket", "pkg", "worker", "attr", "r", "chain", "ptr", "ctx", "conf", "er", "ssl", "src", "root", "remote", "node", "name", "pe", "mode", "master", "unknown", "vr", "conn", "pc", "type", "sys", "owner", "wire", "eth", "parent", "server", "request", "pool", "url", "scope", "layer", "info", "ace", "channel", "state", "proc", "inter", "ip", "address", "resource", "slave", "username", "instance", "client", "source"], "local": ["loop", "cache", "pkg", "tp", "loc", "auth", "ac", "private", "conf", "public", "ssl", "lib", "lang", "location", "remote", "node", "master", "pc", "file", "pool", "url", "shared", "layer", "state", "tx", "global", "localhost", "http"], "addr": ["home", "rr", "part", "pkg", "enter", "hop", "ord", "uri", "alt", "az", "alias", "usr", "nn", "rss", "adder", "vr", "ast", "aug", "layer", "env", "filename", "host", "auth", "ac", "ha", "node", "html", "config", "name", "amd", "ad", "route", "over", "url", "ace", "Address", "dd", "offset", "wd", "arrow", "od", "ptr", "ack", "air", "dr", "href", "area", "conn", "str", "server", "cmd", "amp", "ip", "address", "mac", "loc", "attr", "email", "rt", "bb", "east", "arr", "src", "adr", "pe", "ress", "prefix", "ext", "arm", "work", "direction", "oa", "align", "art"], "port": ["Port", "all", "part", "text", "hop", "tt", "alt", "opt", "key", "fat", "th", "position", "col", "pi", "rot", "post", "host", "PORT", "select", "option", "p", "non", "pid", "name", "per", "time", "method", "pos", "dest", "prop", "url", "test", "point", "op", "username", "h", "tag", "rule", "offset", "ports", "pr", "project", "patch", "ptr", "proxy", "ort", "slice", "pad", "cp", "allow", "service", "length", "pre", "pair", "ip", "address", "size", " Port", "password", "path", "source", "value", "mac", "loc", "attr", "pt", "wait", "adr", "token", "id", "api", "rest", "no", "phone", "class", "py", "end", "type", "body", "direction", "target", "nat", "version", "round"], "uaddr": ["luaddr", "uaddress", "luwd", "Uhost", "uwd", "uhost", "luaddress", "Uaddress", "luhost", "Uaddr", "Uwd"], "uport": ["uename", "ueport", "uip", "ulport", "ulname", "ulip", "uname", "ueip"], "rc": ["rect", "rb", "cc", "cr", "rr", "dc", "back", "r", "loc", "sc", "error", "ac", "rh", "fc", "sr", "rt", "ack", "rx", "ci", "ras", "src", "xc", "rf", "rw", "ri", "PC", "tc", "rec", "success", "rd", "pc", "roc", "irc", "reply", "RR", "c", "rs", "rg", " RC", "RC", "nc", "ru", "rn", "result", "ck", "rl", "inc", "cur", "bc", "lc", "anc"]}}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_file_size(FTPContext *s)\n\n{\n\n    char command[CONTROL_BUFFER_SIZE];\n\n    char *res = NULL;\n\n    const int size_codes[] = {213, 0};\n\n\n\n    snprintf(command, sizeof(command), \"SIZE %s\\r\\n\", s->path);\n\n    if (ftp_send_command(s, command, size_codes, &res)) {\n\n        s->filesize = strtoll(&res[4], NULL, 10);\n\n    } else {\n\n        s->filesize = -1;\n\n        av_free(res);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    av_free(res);\n\n    return 0;\n\n}\n", "idx": 1525, "substitutes": {"s": ["S", "support", "fs", "socket", "r", "sets", "ts", "ns", "settings", "cs", "is", "si", "n", "ssl", "qs", "o", "p", "new", "d", "m", "sq", "w", "opens", "ops", "services", "a", "service", "g", "ps", "us", "ses", "secondary", "c", "rs", "sb", "es", "gs", "sym", "t", "b", "f", "client", "os", "aws", "ss", "js", "e", "ls", "ssh", "http", "ds", "sync", "xs"], "command": ["md", "random", "communication", "attribute", "text", "mac", "password", "comm", "script", "error", "def", "array", "code", "function", "Command", "operation", "exec", "pattern", "connection", "document", "node", "query", "remote", "which", "input", "name", "sequence", "buffer", "send", "method", "mode", "event", "clear", "prefix", "type", "data", "length", "package", "c", "sudo", "execute", "power", "response", "php", "cmd", "directory", "re", "message", "msg", "content", "request"], "res": ["rep", "reed", "rr", "ms", "RE", "req", "r", "gr", "rh", "error", "des", "rc", "gen", "cs", "resp", "rx", "ras", "arr", "remote", "rows", "rev", "ret", "rar", "resolution", "rest", "rss", "ress", "rec", "rex", "Res", "reply", "ps", "rs", "RES", "reg", "es", "vals", "prev", "results", "result", "pres", "args", "rez", "response", "rus", "os", "err", "ra", "resource", "js", "e", "re", "rem", "msg", "params"], "size_codes": [" size_description", "size_errors", "size_200", "size_lines", " size_lines", " size_errors", "size___errors", " size_200", "size___description", "size_code", "size_description", "size___codes", " size_code", "size___code"]}}
{"project": "qemu", "commit_id": "68d45bb61c5bbfb3999486f78cf026c1e79eb301", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64)\n\n{\n\n    TCGReg datalo, datahi, addrlo, rbase;\n\n    TCGReg addrhi __attribute__((unused));\n\n    TCGMemOpIdx oi;\n\n    TCGMemOp opc, s_bits;\n\n#ifdef CONFIG_SOFTMMU\n\n    int mem_index;\n\n    tcg_insn_unit *label_ptr;\n\n#endif\n\n\n\n    datalo = *args++;\n\n    datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0);\n\n    addrlo = *args++;\n\n    addrhi = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *args++ : 0);\n\n    oi = *args++;\n\n    opc = get_memop(oi);\n\n    s_bits = opc & MO_SIZE;\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n    mem_index = get_mmuidx(oi);\n\n    addrlo = tcg_out_tlb_read(s, s_bits, addrlo, addrhi, mem_index, true);\n\n\n\n    /* Load a pointer into the current opcode w/conditional branch-link. */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK);\n\n\n\n    rbase = TCG_REG_R3;\n\n#else  /* !CONFIG_SOFTMMU */\n\n    rbase = GUEST_BASE ? TCG_GUEST_BASE_REG : 0;\n\n    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {\n\n        tcg_out_ext32u(s, TCG_REG_TMP1, addrlo);\n\n        addrlo = TCG_REG_TMP1;\n\n    }\n\n#endif\n\n\n\n    if (TCG_TARGET_REG_BITS == 32 && s_bits == MO_64) {\n\n        if (opc & MO_BSWAP) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo));\n\n            tcg_out32(s, LWBRX | TAB(datahi, rbase, TCG_REG_R0));\n\n        } else if (rbase != 0) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWZX | TAB(datahi, rbase, addrlo));\n\n            tcg_out32(s, LWZX | TAB(datalo, rbase, TCG_REG_R0));\n\n        } else if (addrlo == datahi) {\n\n            tcg_out32(s, LWZ | TAI(datalo, addrlo, 4));\n\n            tcg_out32(s, LWZ | TAI(datahi, addrlo, 0));\n\n        } else {\n\n            tcg_out32(s, LWZ | TAI(datahi, addrlo, 0));\n\n            tcg_out32(s, LWZ | TAI(datalo, addrlo, 4));\n\n        }\n\n    } else {\n\n        uint32_t insn = qemu_ldx_opc[opc & (MO_BSWAP | MO_SSIZE)];\n\n        if (!HAVE_ISA_2_06 && insn == LDBRX) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo));\n\n            tcg_out32(s, LWBRX | TAB(TCG_REG_R0, rbase, TCG_REG_R0));\n\n            tcg_out_rld(s, RLDIMI, datalo, TCG_REG_R0, 32, 0);\n\n        } else if (insn) {\n\n            tcg_out32(s, insn | TAB(datalo, rbase, addrlo));\n\n        } else {\n\n            insn = qemu_ldx_opc[opc & (MO_SIZE | MO_BSWAP)];\n\n            tcg_out32(s, insn | TAB(datalo, rbase, addrlo));\n\n            insn = qemu_exts_opc[s_bits];\n\n            tcg_out32(s, insn | RA(datalo) | RS(datalo));\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n    add_qemu_ldst_label(s, true, oi, datalo, datahi, addrlo, addrhi,\n\n                        s->code_ptr, label_ptr);\n\n#endif\n\n}\n", "idx": 1533, "substitutes": {"s": ["S", "i", "fs", "sets", "ts", "ns", "settings", "sing", "cs", "private", "context", "is", "sec", "ssl", "qs", "o", "south", "p", "d", "m", "sq", "session", "ions", "se", "secondary", "ds", "services", "a", "sys", "sie", "service", "g", "stats", "ps", "ses", "sf", "spec", "c", "sb", "es", "self", "in", "scope", "site", "gs", "sym", "t", "b", "f", "sg", "set", "js", "e", "its", "bis", "http", "client", "sync", "xs", "request"], "args": ["flags", "ms", "loc", "ns", "cs", "enc", "Arg", "sec", "qs", "axis", "alloc", "ig", "bits", "Args", "arr", "lang", "items", "fields", "icks", "ras", "includes", "uments", "config", "ids", "words", "call", "blocks", "orders", "actions", "len", "alls", "ass", "pos", "conn", "g", "arms", "afi", "argument", "ks", "spec", "body", "points", "ams", "gs", "bytes", "arg", "limits", "parts", "objects", "cmd", "doc", "inc", "err", "ars", "extra", "size", "addr", "atts", "ds", "params"], "is_64": ["is_long", "IS_24", "is_32", " is_32", " is_long", "isf64", "is_63", "isf24", "is_24", "IS_64", "IS_63", "isf63"], "datalo": ["dralos", "dralo", "mutalos", " datalan", " datla", "formahi", "dalo", "dalos", "formalo", "Datalos", "formagi", "dalan", "datagi", "dahi", "drahi", "dragi", "Datalan", "mutalan", "Datalo", "dagi", "datla", "mutla", "dla", "Datla", " datalos", "mutalo", "datalan", "datalos", "formalos"], "datahi": ["dralo", "ditaho", "netaii", " datagi", " datla", "drla", "natagi", "dataho", "natla", "netla", "ditla", " dataho", "datagi", "draii", "ditagi", "drahi", "nataho", "netalo", "dataii", "datla", "natahi", " dataii", "netahi", "ditahi"], "addrlo": ["addressLo", "rrpl", "addrpl", "amdHi", "addrelo", "alignli", " addrpos", "amdhi", "addressko", "amdla", "adderlow", "ordlo", "alignelo", " addrlow", "adderlo", "addrlim", "addresselo", "adderso", "padli", "ordli", "alignhi", "padbo", "addresshi", "drla", "addresslim", "addressHi", "addrlin", "alignpos", "addrlow", "addrko", "padlo", "amdpl", " addrlim", "addressla", "drlo", "addrso", " addrbo", "amdko", "addressli", "adrlo", " addrzo", "rrlin", "adderzo", "adrso", "rrlo", " addrelo", "addrLo", "addrbo", " addrlin", " addrpl", "adrlow", "addrHi", "alignlo", "addrzo", "ordhi", "drLo", " addrHi", "addrlc", " addrLo", " addrso", "amdLo", " addrla", " addrli", "padlc", "addrli", "drko", "addresslc", "amdlin", "rrhi", "ordpos", "addressbo", "amdlim", "addrla", "addrpos", "adrzo", "drhi", "addresslo", " addrlc", "amdlo"], "rbase": ["Rpart", "rarmodel", " rbi", " rlo", "rpart", "rlo", " Rbase", "bpart", "rlast", " Rlog", " Rbi", "rbi", "bbi", "rbas", "rarbase", "Rmodel", "rrbase", "erbase", "rarbas", " rpart", "Rbi", "rrbas", "erbi", "rarlast", " rlog", "Rbas", " Rlo", "rlog", " rbas", "bbas", "bbase", "rmodel", "Rbase", "Rlo", "rrlast", "rrmodel", "Rlog", "Rlast", "erbas"], "addrhi": ["ptrhei", "addrha", "addresshi", " addrhei", " addrHi", "drli", "addressHi", " addrli", "addressha", "addresshei", "addrli", "addrhei", "ptrha", "drlo", "addrHi", "addrui", " addrha", "drui", "drHi", "addressui", "drhi", " addrui", "ptrhi", "addresslo", "addressli"], "oi": [" si", " bi", "ahi", "ui", "agi", "i", "anti", "obi", "oji", "ik", "uci", "si", "o", "ani", "eu", "ci", "odi", " identity", "oci", "eni", " ii", "cli", "cci", "mi", "ori", "iri", "yi", "adi", " mi", "rio", "ini", "ii", " pi", "bi", "obo", "ois", "ogi", "ami", "ie", "ji", "zi", "eri", "oid", "di", "oda", "ai", "asi", "pi", "ku", "oa", "opp", "ilo", "ei", "oni", "ti", "ni", " vi", "xi", "ki", " pci", " ki", "osi"], "opc": ["OPc", " opcy", " appcy", "copcs", "OPca", "OPcs", "oopcs", "opca", " opC", "Opf", "operct", "oopci", " opcs", "OPf", "OPct", " appc", "opf", "Opb", "opct", "copc", "OPb", "Opcs", " appci", " opci", "operci", "oopcy", "Opc", "operc", "opcy", " appC", "operf", "oopC", "oopc", "copb", "opcs", "opci", " opf", "oopca", "opb", " opct", "OPci", " opca", "copf", "opC"], "s_bits": ["s__flags", "s_its", " s_flags", "s2its", "s_bytes", "s2bit", "s2flags", " s_bit", " s_its", "n_flags", " s_bytes", " s_cycles", "s_flags", "s2bits", "s_ints", "s__bit", "s_bit", "n_ints", "s__ints", "s__bits", "s__its", "n_bits", "s_cycles"], "mem_index": [" mem_col", "memnIndex", "mem__col", "mem_Index", "memntype", "memPind", "memlexcol", " mem_ind", " mem_type", " mem_Index", "memptype", " mem_int", "memnindex", "memnint", "mempint", "mempIndex", "mem_body", "mem__index", "mempindex", "memPref", " mem_ref", "mem_int", "mem_ref", "mem_col", "memlexbody", "mem_ind", " mem_body", "mem_type", "memlexindex", "memPindex", "mem__body"], "label_ptr": ["labelingoffset", "label_offset", "label_len", "labelingindex", "label_pointer", "data_pointer", " label_pointer", "labelenptr", "labelenpointer", "labelingptr", " label_len", "label_index", "labelenoffset", "data_index", "labelingpointer", " label_index", "labelinglen", "labelenindex", "data_ptr", "data_offset"]}}
{"project": "FFmpeg", "commit_id": "5c2fb561d94fc51d76ab21d6f7cc5b6cc3aa599c", "target": 0, "func": "int ff_h264_decode_ref_pic_marking(const H264Context *h, H264SliceContext *sl,\n\n                                   GetBitContext *gb)\n\n{\n\n    int i;\n\n    MMCO *mmco = sl->mmco;\n\n    int nb_mmco = 0;\n\n\n\n    if (h->nal_unit_type == NAL_IDR_SLICE) { // FIXME fields\n\n        skip_bits1(gb); // broken_link\n\n        if (get_bits1(gb)) {\n\n            mmco[0].opcode   = MMCO_LONG;\n\n            mmco[0].long_arg = 0;\n\n            nb_mmco          = 1;\n\n        }\n\n        sl->explicit_ref_marking = 1;\n\n    } else {\n\n        sl->explicit_ref_marking = get_bits1(gb);\n\n        if (sl->explicit_ref_marking) {\n\n            for (i = 0; i < MAX_MMCO_COUNT; i++) {\n\n                MMCOOpcode opcode = get_ue_golomb_31(gb);\n\n\n\n                mmco[i].opcode = opcode;\n\n                if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) {\n\n                    mmco[i].short_pic_num =\n\n                        (sl->curr_pic_num - get_ue_golomb(gb) - 1) &\n\n                            (sl->max_pic_num - 1);\n\n#if 0\n\n                    if (mmco[i].short_pic_num >= h->short_ref_count ||\n\n                        !h->short_ref[mmco[i].short_pic_num]) {\n\n                        av_log(s->avctx, AV_LOG_ERROR,\n\n                               \"illegal short ref in memory management control \"\n\n                               \"operation %d\\n\", mmco);\n\n                        return -1;\n\n                    }\n\n#endif\n\n                }\n\n                if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED ||\n\n                    opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) {\n\n                    unsigned int long_arg = get_ue_golomb_31(gb);\n\n                    if (long_arg >= 32 ||\n\n                        (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG &&\n\n                                             long_arg == 16) &&\n\n                         !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) {\n\n                        av_log(h->avctx, AV_LOG_ERROR,\n\n                               \"illegal long ref in memory management control \"\n\n                               \"operation %d\\n\", opcode);\n\n                        return -1;\n\n                    }\n\n                    mmco[i].long_arg = long_arg;\n\n                }\n\n\n\n                if (opcode > (unsigned) MMCO_LONG) {\n\n                    av_log(h->avctx, AV_LOG_ERROR,\n\n                           \"illegal memory management control operation %d\\n\",\n\n                           opcode);\n\n                    return -1;\n\n                }\n\n                if (opcode == MMCO_END)\n\n                    break;\n\n            }\n\n            nb_mmco = i;\n\n        }\n\n    }\n\n\n\n    sl->nb_mmco = nb_mmco;\n\n\n\n    return 0;\n\n}\n", "idx": 1540, "substitutes": {"h": ["hm", "hi", "host", "hy", "rh", "en", "l", "hs", "hh", "gh", "sh", "o", "ht", "p", "ha", "zh", "m", "w", "s", "beh", "hl", "oh", "v", "uh", "ah", "g", "hel", "c", "ph", "he", "hr", "bh", "ih", "hd", "t", "hp", "b", "f", "u", "q", "e", "http", "H"], "sl": ["gl", "sw", "loc", "sv", "sc", "su", "sch", "l", "si", "Sl", "sh", "pl", "ssl", "sel", "scl", "lib", "fl", "zh", "isl", "sq", "se", "acl", "SB", "sn", "s", "hl", "sa", "SL", "ul", "el", "li", "g", "coll", "il", "sf", "c", "sb", "ll", "bh", "kl", "la", "sd", "kel", "cl", "sm", "serv", "lr", "ls", "sk", "bl", "lc", "cel", "so"], "gb": ["hm", "kb", "gl", "bf", "gu", "tm", "rb", "cfg", "bb", "ge", "GB", "gh", "cca", "lib", "src", "bg", "gc", "ub", "ga", "gp", "gal", "cgi", "gnu", "mb", "nb", "gpu", "pc", "g", "eb", "usb", "gin", "game", "hub", "sb", "rg", "gm", "gram", "gd", "gg", "gy", "gs", "gom", "cb", "db", "storage", "gam", "bc", "lb", "bm", "pg", "jpg"], "i": ["ui", "hei", "io", "it", "idi", "l", "fi", "si", "j", "n", "uri", "y", "p", "ci", "multi", "qi", "eni", "d", "oi", "id", "mi", "z", "ri", "k", "ini", "ii", "ij", "count", "esi", "v", "bi", "uli", "li", "ami", "iu", "ie", "ki", "ji", "zi", "di", "ix", "ai", "info", "init", "abi", "pi", "ski", "mu", "gi", "f", "b", "ti", "ip", "ni", "e", "xi", "I", "inner", "phi", "iv", "yi", "lc", "index"], "mmco": ["MMdo", " mmcon", "mccode", " mmque", "MMloc", " mmCo", "mpco", "mmc", "smaco", " mmgo", "memcon", "smoo", "mcloc", "cmloc", " mmoo", "mmgo", "tmgo", "mmmcoll", "memco", "mcCo", "mmcol", "wxco", " mmloc", "mcoo", " mmci", "mcdo", "mmaco", "MMCo", "cmcol", "MMcoll", " mmcos", "memcoll", "cmco", "wxcon", " mmko", "wxque", "wxcos", "MMco", "mlcol", "mmCO", " mmcoll", "mmcoll", "mmdo", "tmko", "mmmloc", "memCo", "smque", "MMci", "mmmc", "mmko", "mmmko", "mmloc", "mmcode", "mmcon", " mmdo", "mcco", "memc", "mpcoll", " mmcode", "mmmcon", "mmcos", "tmco", "mploc", " mmCO", "tmloc", "mcko", "mmpo", "mccoll", "smcos", "memloc", "smco", "mlloc", "tmpo", " mmc", "memCO", "cmpo", "mmmco", "mlko", " mmaco", "memci", "mmCo", "mlgo", "smcode", "tmcos", "mmci", "tmcol", "mlcos", "mpCO", "smcon", "mcaco", "mmoo", "mlco", "mmque", "mlpo"]}}
{"project": "qemu", "commit_id": "e40a67beeda6aa6e735546e9f08f3db41e23592a", "target": 0, "func": " void cpu_sh4_invalidate_tlb(CPUSH4State *s)\n\n{\n\n    int i;\n\n\n\n    /* UTLB */\n\n    for (i = 0; i < UTLB_SIZE; i++) {\n\n        tlb_t * entry = &s->utlb[i];\n\n        entry->v = 0;\n\n    }\n\n    /* ITLB */\n\n    for (i = 0; i < UTLB_SIZE; i++) {\n\n        tlb_t * entry = &s->utlb[i];\n\n        entry->v = 0;\n\n    }\n\n\n\n    tlb_flush(s, 1);\n\n}\n", "idx": 1557, "substitutes": {"s": ["S", "fs", "sv", "sets", "r", "sr", "ts", "ns", "su", "settings", "is", "si", "ssl", "o", "y", "south", "p", "d", "m", "sq", "status", "v", "services", "a", "stats", "states", "service", "sys", "ps", "server", "ses", "sf", "spec", "c", "rs", "sb", "in", "gs", "state", "t", "os", "u", "storage", "f", "b", "ss", "js", "e", "side", "sl", "ds", "sync"], "i": ["hi", "ui", "io", "l", "fi", "si", "j", "n", "uri", "o", "y", "p", "ci", "key", "multi", "qi", "eni", "d", "m", "oi", "id", "z", "I", "mi", "source", "ri", "k", "ini", "ii", "v", "bi", "li", "ie", "iu", "ji", "c", "di", "start", "ai", "info", "ix", "pi", "mu", "t", "gi", "f", "u", "b", "ti", "ip", "ni", "e", "xi", "x", "phi", "yi", "lc", "index", "h"], "entry": ["line", "offset", "tri", "ident", "attribute", "enter", "it", "Entry", "object", "option", "ge", "si", "cell", "letter", "or", "key", "connection", "module", "input", "session", "se", "id", "source", "element", "import", "entity", "v", "event", "end", "service", "ie", "row", "server", "ry", "c", "nt", "export", "pair", "info", "image", "ent", "inter", "sl", "inner", "reader", "lc", "try", "index"]}}
{"project": "qemu", "commit_id": "22156ab498acf5f8104801148732ae8e83f336a0", "target": 0, "func": "uint16_t net_checksum_finish(uint32_t sum)\n\n{\n\n    while (sum>>16)\n\n\tsum = (sum & 0xFFFF)+(sum >> 16);\n\n    return ~sum;\n\n}\n", "idx": 1573, "substitutes": {"sum": ["comment", "mask", "user", "val", "all", "cache", "offset", "total", "text", "value", "i", "scale", "sort", "error", "match", "ac", "um", "sub", "si", "num", "hash", "null", "zero", "sh", "mass", "key", "mem", "ask", "Sum", "average", "fat", "call", "acc", "alpha", "fee", "miss", "count", "ul", "class", "a", "ass", "sign", "ash", "us", "gram", "amount", "mean", "start", "weight", "info", "result", "image", "cash", "state", "pack", "bin", "cost", "dev", "gam", "doc", "size", "out", "empty", "parse", "index"]}}
{"project": "qemu", "commit_id": "45eb768c706d3a5fbe55224c589e8b4e252781d9", "target": 0, "func": "static void pci_init_mask_bridge(PCIDevice *d)\n\n{\n\n    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and\n\n       PCI_SEC_LETENCY_TIMER */\n\n    memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4);\n\n\n\n    /* base and limit */\n\n    d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;\n\n    d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;\n\n    pci_set_word(d->wmask + PCI_MEMORY_BASE,\n\n                 PCI_MEMORY_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_MEMORY_LIMIT,\n\n                 PCI_MEMORY_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE,\n\n                 PCI_PREF_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT,\n\n                 PCI_PREF_RANGE_MASK & 0xffff);\n\n\n\n    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */\n\n    memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);\n\n\n\n    /* Supported memory and i/o types */\n\n    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;\n\n    d->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;\n\n    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_BASE,\n\n                               PCI_PREF_RANGE_TYPE_64);\n\n    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_LIMIT,\n\n                               PCI_PREF_RANGE_TYPE_64);\n\n\n\n/* TODO: add this define to pci_regs.h in linux and then in qemu. */\n\n#define  PCI_BRIDGE_CTL_VGA_16BIT\t0x10\t/* VGA 16-bit decode */\n\n#define  PCI_BRIDGE_CTL_DISCARD\t\t0x100\t/* Primary discard timer */\n\n#define  PCI_BRIDGE_CTL_SEC_DISCARD\t0x200\t/* Secondary discard timer */\n\n#define  PCI_BRIDGE_CTL_DISCARD_STATUS\t0x400\t/* Discard timer status */\n\n#define  PCI_BRIDGE_CTL_DISCARD_SERR\t0x800\t/* Discard timer SERR# enable */\n\n/*\n\n * TODO: Bridges default to 10-bit VGA decoding but we currently only\n\n * implement 16-bit decoding (no alias support).\n\n */\n\n    pci_set_word(d->wmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_PARITY |\n\n                 PCI_BRIDGE_CTL_SERR |\n\n                 PCI_BRIDGE_CTL_ISA |\n\n                 PCI_BRIDGE_CTL_VGA |\n\n                 PCI_BRIDGE_CTL_VGA_16BIT |\n\n                 PCI_BRIDGE_CTL_MASTER_ABORT |\n\n                 PCI_BRIDGE_CTL_BUS_RESET |\n\n                 PCI_BRIDGE_CTL_FAST_BACK |\n\n                 PCI_BRIDGE_CTL_DISCARD |\n\n                 PCI_BRIDGE_CTL_SEC_DISCARD |\n\n                 PCI_BRIDGE_CTL_DISCARD_SERR);\n\n    /* Below does not do anything as we never set this bit, put here for\n\n     * completeness. */\n\n    pci_set_word(d->w1cmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_DISCARD_STATUS);\n\n    d->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;\n\n    d->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_BASE,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_LIMIT,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n}\n", "idx": 1616, "substitutes": {"d": ["driver", "md", "vd", "dd", "dad", "i", "dc", "wd", "die", "done", "od", "l", "de", "j", "n", "dj", "dl", "bd", "p", "pd", "nd", "dr", "ind", "m", "config", "session", "dat", "id", "z", "ad", "ld", "D", "fd", "g", "data", "dn", "xd", "td", "c", "dt", "gd", "di", "plugin", "dh", "dict", "t", "db", "b", "f", "sd", "da", "dos", "e", "ds", "sync", "dom", "cd"]}}
{"project": "qemu", "commit_id": "2b48e10f888059a98043b4816769fa2a326a1d2c", "target": 0, "func": "static TranslationBlock *tb_alloc(target_ulong pc)\n\n{\n\n    TranslationBlock *tb;\n\n    TBContext *ctx;\n\n\n\n    assert_tb_locked();\n\n\n\n    tb = tcg_tb_alloc(&tcg_ctx);\n\n    if (unlikely(tb == NULL)) {\n\n        return NULL;\n\n    }\n\n    ctx = &tcg_ctx.tb_ctx;\n\n    if (unlikely(ctx->nb_tbs == ctx->tbs_size)) {\n\n        ctx->tbs_size *= 2;\n\n        ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size);\n\n    }\n\n    ctx->tbs[ctx->nb_tbs++] = tb;\n\n    tb->pc = pc;\n\n    tb->cflags = 0;\n\n    tb->invalid = false;\n\n    return tb;\n\n}\n", "idx": 1621, "substitutes": {"pc": ["ocol", "val", "cc", "dc", "lp", "mac", "sc", "project", "ac", "bp", "rc", "fc", "cs", "pb", "prot", "pm", "sec", "arc", "vc", "pt", "p", "ec", "xc", "pid", "tz", "mi", "PC", "tc", "asc", "platform", "func", "ca", "type", "port", "c", "nc", "point", "ping", "cpu", "mc", "oc", "toc", "pa", "amp", "bc", "pointer", "uc", "lc", "anc", "pg"], "tb": ["tab", "etab", "rb", "ttcb", "tbh", "etb", "tsbe", "etpb", "etfb", " tbs", "rtpb", "ftcb", "rbl", "ctb", "Tbase", "tfb", "ttab", "fbs", "ttbs", " tbb", "tsbb", "tbase", "ftb", "ttb", " tbh", "itbs", "itfb", "rbs", "fb", "Tbb", "tcb", " tfb", "tbs", "ctbs", "Tb", "ttbl", "rtbs", " tbase", "ftbb", " tbe", " tbl", "tbl", "Tbh", " tab", " tpb", "tbe", "rtab", "tsb", "ttbb", "ctbb", "etbs", "fbb", " tcb", "ctbase", "tbb", "ttbe", "fcb", "Tcb", "tpb", "ftab", "rtb", "rbb", "itab", "tsbl", "ttbh", "Tbs", "itb"], "ctx": ["kb", "kw", "cu", "git", "cc", "pkg", "loc", "sc", "cf", "fc", "cmp", "context", "cs", "rc", "conv", "cca", "vc", "fp", "ci", "exec", "rx", "gc", "cms", "xc", "ct", "config", "cam", "sq", "cli", "acl", "gp", "voc", "wp", "qa", "Context", "tc", "sci", "cv", "cp", "lc", "conn", "ca", "sys", "co", "cn", "css", "fw", "c", "ctrl", "nc", "jp", "mc", "cb", "tx", "cmd", "hw", "bc", "cfg", "cas", "cm", "anc", "cus"]}}
{"project": "qemu", "commit_id": "9cbaacf999b01b27dc3a22502705178057af66de", "target": 0, "func": "static void gpollfds_from_select(void)\n\n{\n\n    int fd;\n\n    for (fd = 0; fd <= nfds; fd++) {\n\n        int events = 0;\n\n        if (FD_ISSET(fd, &rfds)) {\n\n            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, &wfds)) {\n\n            events |= G_IO_OUT | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, &xfds)) {\n\n            events |= G_IO_PRI;\n\n        }\n\n        if (events) {\n\n            GPollFD pfd = {\n\n                .fd = fd,\n\n                .events = events,\n\n            };\n\n            g_array_append_val(gpollfds, pfd);\n\n        }\n\n    }\n\n}\n", "idx": 1626, "substitutes": {"fd": ["fn", "md", "draw", "vd", "dd", "FD", "wd", "fs", "fff", "dc", "feed", "cod", "die", " fid", "flo", "cond", "cf", "fc", "fi", "function", "dir", "bd", "dl", "fp", "events", "pd", "nd", "fin", "fl", "connection", "ff", "pipe", "ind", "d", "config", "pid", "id", "fee", "buf", "dy", "ds", "fb", "ld", "df", "handler", "fen", "fm", "fe", "pos", "func", " events", "length", "sf", "td", "fw", "fun", "dt", "fa", "fed", "draft", "cb", "fx", "sd", "db", "f", "ffff", "lf", "cd"]}}
{"project": "FFmpeg", "commit_id": "89f464e9c229006e16f6bb5403c5529fdd0a9edd", "target": 0, "func": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data, int *got_frame, AVPacket *avpkt)\n\n{\n\n    TiffContext *const s = avctx->priv_data;\n\n    AVFrame *const p = data;\n\n    ThreadFrame frame = { .f = data };\n\n    unsigned off;\n\n    int le, ret, plane, planes;\n\n    int i, j, entries, stride;\n\n    unsigned soff, ssize;\n\n    uint8_t *dst;\n\n    GetByteContext stripsizes;\n\n    GetByteContext stripdata;\n\n\n\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n\n\n\n    // parse image header\n\n    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid TIFF header\\n\");\n\n        return ret;\n\n    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {\n\n        av_log(avctx, AV_LOG_ERROR, \"IFD offset is greater than image size\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    s->le          = le;\n\n    // TIFF_BPP is not a required tag and defaults to 1\n\n    s->bppcount    = s->bpp = 1;\n\n    s->photometric = TIFF_PHOTOMETRIC_NONE;\n\n    s->compr       = TIFF_RAW;\n\n    s->fill_order  = 0;\n\n    free_geotags(s);\n\n\n\n    // Reset these offsets so we can tell if they were set this frame\n\n    s->stripsizesoff = s->strippos = 0;\n\n    /* parse image file directory */\n\n    bytestream2_seek(&s->gb, off, SEEK_SET);\n\n    entries = ff_tget_short(&s->gb, le);\n\n    if (bytestream2_get_bytes_left(&s->gb) < entries * 12)\n\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < entries; i++) {\n\n        if ((ret = tiff_decode_tag(s, p)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    for (i = 0; i<s->geotag_count; i++) {\n\n        const char *keyname = get_geokey_name(s->geotags[i].key);\n\n        if (!keyname) {\n\n            av_log(avctx, AV_LOG_WARNING, \"Unknown or unsupported GeoTIFF key %d\\n\", s->geotags[i].key);\n\n            continue;\n\n        }\n\n        if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {\n\n            av_log(avctx, AV_LOG_WARNING, \"Type of GeoTIFF key %d is wrong\\n\", s->geotags[i].key);\n\n            continue;\n\n        }\n\n        ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s->geotags[i].val, 0);\n\n        if (ret<0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Writing metadata with key '%s' failed\\n\", keyname);\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    if (!s->strippos && !s->stripoff) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Image data is missing\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    /* now we have the data and may start decoding */\n\n    if ((ret = init_image(s, &frame)) < 0)\n\n        return ret;\n\n\n\n    if (s->strips == 1 && !s->stripsize) {\n\n        av_log(avctx, AV_LOG_WARNING, \"Image data size missing\\n\");\n\n        s->stripsize = avpkt->size - s->stripoff;\n\n    }\n\n\n\n    if (s->stripsizesoff) {\n\n        if (s->stripsizesoff >= (unsigned)avpkt->size)\n\n            return AVERROR_INVALIDDATA;\n\n        bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,\n\n                         avpkt->size - s->stripsizesoff);\n\n    }\n\n    if (s->strippos) {\n\n        if (s->strippos >= (unsigned)avpkt->size)\n\n            return AVERROR_INVALIDDATA;\n\n        bytestream2_init(&stripdata, avpkt->data + s->strippos,\n\n                         avpkt->size - s->strippos);\n\n    }\n\n\n\n    if (s->rps <= 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"rps %d invalid\\n\", s->rps);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    planes = s->planar ? s->bppcount : 1;\n\n    for (plane = 0; plane < planes; plane++) {\n\n        stride = p->linesize[plane];\n\n        dst = p->data[plane];\n\n        for (i = 0; i < s->height; i += s->rps) {\n\n            if (s->stripsizesoff)\n\n                ssize = ff_tget(&stripsizes, s->sstype, le);\n\n            else\n\n                ssize = s->stripsize;\n\n\n\n            if (s->strippos)\n\n                soff = ff_tget(&stripdata, s->sot, le);\n\n            else\n\n                soff = s->stripoff;\n\n\n\n            if (soff > avpkt->size || ssize > avpkt->size - soff) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Invalid strip size/offset\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i,\n\n                                         FFMIN(s->rps, s->height - i))) < 0) {\n\n                if (avctx->err_recognition & AV_EF_EXPLODE)\n\n                    return ret;\n\n                break;\n\n            }\n\n            dst += s->rps * stride;\n\n        }\n\n        if (s->predictor == 2) {\n\n            if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"predictor == 2 with YUV is unsupported\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            dst   = p->data[plane];\n\n            soff  = s->bpp >> 3;\n\n            if (s->planar)\n\n                soff  = FFMAX(soff / s->bppcount, 1);\n\n            ssize = s->width * soff;\n\n            if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {\n\n                for (i = 0; i < s->height; i++) {\n\n                    for (j = soff; j < ssize; j += 2)\n\n                        AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff));\n\n                    dst += stride;\n\n                }\n\n            } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {\n\n                for (i = 0; i < s->height; i++) {\n\n                    for (j = soff; j < ssize; j += 2)\n\n                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));\n\n                    dst += stride;\n\n                }\n\n            } else {\n\n                for (i = 0; i < s->height; i++) {\n\n                    for (j = soff; j < ssize; j++)\n\n                        dst[j] += dst[j - soff];\n\n                    dst += stride;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {\n\n            dst = p->data[plane];\n\n            for (i = 0; i < s->height; i++) {\n\n                for (j = 0; j < stride; j++)\n\n                    dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j];\n\n                dst += stride;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (s->planar && s->bppcount > 2) {\n\n        FFSWAP(uint8_t*, p->data[0],     p->data[2]);\n\n        FFSWAP(int,      p->linesize[0], p->linesize[2]);\n\n        FFSWAP(uint8_t*, p->data[0],     p->data[1]);\n\n        FFSWAP(int,      p->linesize[0], p->linesize[1]);\n\n    }\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 1628, "substitutes": {"avctx": ["afcontext", "avcu", "avconn", "avecmp", "AVctx", "avectx", "ajcca", "evconn", "AVcb", "afcu", "evcu", " avcontext", "afcca", "avcmp", "ajctx", "avecca", "afca", " avcu", "aveconn", "AVconn", "afconn", "navcontext", "ajca", "navctx", "afcmp", "navcu", "afctx", "avcb", "avecontext", "evctx", "aveca", "afcb", "avecu", "evcontext", "avecb", "avca", "ajcontext", "avcontext", "navcup", "AVcmp", " avca", "afcup", "avcca", "avcup", "avecup"], "data": ["next", "feed", "cache", "database", "sample", "done", "base", "def", "Data", "object", "code", "zero", "o", "valid", "connection", "input", "d", "raw", "primary", "config", "dat", "buffer", "id", "load", "buf", "name", "ad", "len", "slice", "frame", "a", "window", "parent", "video", "body", "read", "start", "di", "init", "board", "result", "image", "block", "DATA", "response", "bin", "f", "none", "da", "size", "empty", "inner", "reader", "content"], "got_frame": ["gotnewframe", "got2sample", "got_version", "got_sample", "gotbufversion", "got2version", "got2code", "aved_frame", "aved_code", "aved2sample", "gotbufframe", "aved2version", "got2frame", "gotbufcode", "gotnewcode", "aved_sample", "gotbufsample", "aved2code", "gotnewversion", "aved_version", "got_code", "aved2frame", "gotnewsample"], "avpkt": ["avcpki", "afpke", "avfpct", "avnpct", "avapct", "avapinch", "avpeke", "avcke", "avppke", "avnpkh", "avfett", "avlpkt", "avnpft", "avpft", "AVpct", "avnpinch", "AVpkt", "affct", "affett", "avnpke", "avfpkh", "avcpkt", "avfinch", "afcke", "avfft", "avepinch", "AVppct", "avcki", "avpeki", "affinch", "AVpkh", "avfpinch", "afpinch", "avppkt", "avfacket", "avppkh", "afpki", "avenpft", "afpett", "avpect", "avapkt", "avlpinch", "avcct", "avepacket", "avfpke", "avapett", "avnpacket", "avpki", "avfkt", "avppct", "avfpkt", "avepkt", "avckt", "avpacket", "afcki", "avenpacket", "afpkt", "avfpft", "afckt", "avpinch", "avpke", "avlpct", "avnpkt", "AVppke", "avpett", "avcpct", "avenpinch", "avfpacket", "avlpett", "avfct", "avcpke", "AVpke", "AVppkt", "avpct", "afcct", "afpct", "avpkh", "avenpkt", "AVppkh", "affkt", "avepft", "avpekt"], "s": ["setup", "conf", "d", "sa", "v", "ps", "sb", "sym", "parts", "f", "os", "js", "comments", "l", "si", "is", "styles", "qs", "o", "y", "ys", "ins", "se", "ses", "args", "features", "b", "sg", "u", "side", "ops", "sup", "sync", "h", "S", "r", "hs", "settings", "cs", "ssl", "south", "new", "m", "sq", "session", "w", "full", "service", "g", "us", "spec", "ks", "es", "gs", "t", "native", "ss", "e", "ls", "ds", "xs", "fs", "ms", "su", "sets", "ts", "ns", "n", "services", "a", "sys", "sf", "c", "rs", "self", "its", "bis"], "p": ["lp", "tp", "r", "l", "pb", "n", "er", " P", "o", "pl", "fp", "pt", "param", "d", "m", "w", "wp", "v", "py", "a", "cp", "pc", "g", "ps", "sp", "c", "pp", "pre", "np", "parser", "jp", "vp", "pi", "P", "t", "proc", "b", "f", "op", "u", "e", "it", "h", "params"], "off": ["field", "line", "loop", "offs", "offset", "all", "own", " OFF", "shift", "def", "ord", "low", "n", " offline", "half", "o", "num", "alt", "less", "ff", "non", " Off", "obj", "id", "load", "down", "no", "len", "mode", "Off", "on", "unknown", "end", "pos", "a", "front", "anon", "output", "in", " on", "now", "flow", "OFF", "start", "block", "oa", "opp", "cmd", "none", "ip", "online", "side", "slave", "one", "out", "open", "en", "art"], "le": ["line", "Le", "offset", "let", "fle", "ke", "leave", "lege", "base", "les", "scale", "lu", "l", "lease", "de", "ge", "code", "low", "elt", "half", "ig", "leg", "ce", "ale", "se", "lex", "ble", "w", "pe", "cle", "len", "little", "ld", " el", "el", "oe", "ele", "li", "ell", "ne", "ler", " LE", "ie", "sle", "ll", "lee", "la", "nl", "lo", "level", "LE", "ole", "lead", "live", "side", "ling", "e", "cel", "lane", "lf", "league", "led", "fe", "ile"], "ret": ["rep", "bf", "val", "fail", "res", "value", "bad", "back", "match", "def", "att", "replace", "rt", "flag", "active", "code", "resp", "alt", "utf", "valid", "fin", "ref", "arr", "mem", "RET", "det", "af", "rev", "obj", "status", "red", "len", "lit", "format", "success", "ext", "rets", "str", "reply", "bit", "fun", "nt", "reg", "info", "result", "get", "rel", "Ret", "arg", "f", "ft", "cur", "re", "pass", "it", "rem", "lf", "en"], "plane": ["line", "fle", "ke", "scale", "code", "unit", "fly", "fl", "group", "split", "se", "ro", "pe", "mode", "sea", "charge", "cp", "pos", "co", "sp", "port", "np", "board", "q", "ane", "lane", "fe"], "planes": ["flows", "fle", "cards", "ports", "classes", "pages", "faces", "bits", "ips", "items", "groups", "rows", "cuts", "ps", "lines", "frames", "pins", "files", "eps", "levels", "days", "lists", "points", "ops", "pieces", "bands"], "i": ["chi", "all", "uri", "key", "d", "z", "mi", "ri", "v", "bi", "ami", "iu", "ie", "ji", "ix", "info", "pi", "f", "ti", "this", "phi", "ki", "ui", "_", "l", "is", "si", "y", "ci", "uni", "qi", "ind", "eni", "li", "mu", "ski", "pack", "u", "xi", "it", "bytes", "h", "io", "r", "fi", "multi", "oi", "ori", "ini", "x", "g", "zi", "ai", "ip", "e", "yi", "index", "hi", "n", "id", "k", "ii", "end", "type", "c", "in", "start", "di", "get", "gi", "ni", "I", "inner"], "j": ["r", "shift", "l", "n", "jl", "jump", "ind", "d", "aj", "obj", "z", "adj", "note", "vol", "k", "len", "jobs", "pos", "jet", "jj", "ie", "ji", "jp", "b", "kj", "J"], "entries": ["conturies", "centriers", "centries", "questrys", "enries", "questriers", "entsuries", "detries", "centrows", "gentrs", "entrows", "enturs", "entities", "ntrations", "entsurs", "gentries", "entriers", "entsorts", "centities", "contries", "entances", "questries", "entsances", "ENTries", "entorts", "entles", "entsities", "entsles", "ENTriers", "entsrations", "entrations", "ENTrys", "gentrations", "ENTrows", "ntances", "conturs", "detorts", "entsrs", "centorts", "enuries", "contles", "enurs", "detrs", "entsries", "gentances", "enles", "detities", "entrs", "enturies", "ntrs", "centrs", "ntries", "centrys", "entrys", "questrows"], "stride": ["strider", "strides", "drage", "stides", "strage", "drider", "drides", "arrage", "stage", "arrider", "arride", "stider", "stide", "dride", "arrides"], "soff": ["soeff", "sofi", "sueff", " sofi", "lofi", " soeff", "socc", " socc", "succ", "suff", "sufi", "loff", "loeff", "locc"], "ssize": ["SSize", "ssizes", "ssiz", "cssize", "SSiz", "cssiz", "rssiz", "ssizer", "cssizes", "rssizes", "rssizer", "SSizer", "cssizer", "SSizes", "rssize"], "dst": [" dsc", "fct", "fcr", " dct", "pdsc", "dsc", "fst", "pdcr", " dcr", "fsc", "dct", "dcr", "pdct", "pdst"], "stripsizes": ["striipsizes", "strippits", "strippizable", "strippingizes", "stripppize", "stripppizes", "striipsize", "strippsits", "striipsizable", "strippize", "strippizes", "stripppizable", "stripppits", "stripsizable", "strippingize", "stripsits", "strippingits", "strippsizable", "strippsize", "strippsizes", "striipsits", "stripsize", "strippingizable"], "stripdata": ["CCctx", "stripdat", "stripformat", "stripbuf", "stripctx", "CCbuf", "CCdat", "CCformat"], "keyname": ["keinnam", "kegnename", "keyonow", " kerename", "kerenow", " kerenename", "Keynename", "keinnename", "keynames", " keynames", "keynam", "Kerenum", "kerenename", "keinname", "keyonames", "kerename", "kerenam", "Keynum", "keynum", "keynow", " kerenames", "Keynam", "kegnum", "Kerename", "keylow", " keynow", "kegnam", "kerenames", " keynename", "keylename", "Kerenename", "keyoname", "keinnum", "Kerenam", "keylame", "keylames", "keynename", "kegname", " kerenow", "keyonename", "Keyname", "kerenum"]}}
{"project": "FFmpeg", "commit_id": "bd255f9feb4deea4c990e582f0ba3b90d7b64b4c", "target": 0, "func": "int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,\n\n                                              int *got_picture_ptr,\n\n                                              AVPacket *avpkt)\n\n{\n\n    int ret;\n\n\n\n    *got_picture_ptr = 0;\n\n    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))\n\n        return -1;\n\n\n\n    avctx->pkt = avpkt;\n\n    apply_param_change(avctx, avpkt);\n\n\n\n    avcodec_get_frame_defaults(picture);\n\n\n\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {\n\n        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)\n\n            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,\n\n                                         avpkt);\n\n        else {\n\n            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,\n\n                                       avpkt);\n\n            picture->pkt_dts             = avpkt->dts;\n\n            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;\n\n            picture->width               = avctx->width;\n\n            picture->height              = avctx->height;\n\n            picture->format              = avctx->pix_fmt;\n\n        }\n\n\n\n        emms_c(); //needed to avoid an emms_c() call before every return;\n\n\n\n        if (*got_picture_ptr)\n\n            avctx->frame_number++;\n\n    } else\n\n        ret = 0;\n\n\n\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n\n     * make sure it's set correctly */\n\n    picture->extended_data = picture->data;\n\n\n\n    return ret;\n\n}\n", "idx": 1657, "substitutes": {"avctx": ["umctx", "avetx", "avcu", "AVctx", "afxc", " avcor", "avalctl", "abctx", "afcus", "avcor", "avcmp", "auci", "avpkg", "agcontext", "umcf", "ovctx", "afloc", "afconn", "akcn", "afctx", "afnp", "afctrl", "aveloc", "awpkg", "akcmp", "ajcn", "AVcontext", "avctl", "avhw", "avcontext", "avalcontext", "Avcas", "avecf", "ovcmp", "afctl", "avecmp", "avconn", "attctx", "awcb", "avectx", "aftx", "evcu", "Avctx", " avcontext", "avaltx", "Avcontext", "afcas", "ajcus", "auctx", "evcmp", "avalctx", "akcrit", "akconn", "avecus", "avtx", "navctx", "avcf", "avxc", "afcrit", "agcot", "attcmp", "avectrl", "avctrl", "umcontext", "evcontext", "ovcas", "ajcontext", "AVxc", "afcor", "avalcas", "ajcit", "awcontext", "avcus", "agcmp", "ovcontext", "avcit", "avci", "attcontext", "abcmp", "ajctx", "agctx", "navcf", "evcit", "abcontext", "attcf", "akctx", "afcit", "navcontext", "aveci", "afcmp", "avecontext", "ajcu", "evctx", "avloc", "aucontext", "akcontext", "avcrit", "avecb", "navloc", "avnp", "ajcrit", "avepkg", "afcf", "afpkg", "afcontext", "awctx", "avcn", "evcb", "avenp", "afcn", "umcu", "afcu", "ovtx", "akxc", "afhw", "navcmp", "Avctl", "avcot", "ajci", "akcb", "AVconn", "navcu", "afcot", "avcb", "navctrl", " avhw", "afcb", "auhw", "avecu", "avcas", "ajnp", "abcot", "avecor", "navcrit", "avehw", "afci"], "picture": ["media", "comment", "view", "family", "attribute", "anti", "movie", "detail", "gallery", "pie", "manager", "error", "fi", "profile", "ctx", "ana", "img", "uri", "gif", "query", "piece", "module", "camera", "cam", "config", "study", "figure", "pic", "definition", "guide", "import", "slice", "cover", "frame", "file", "pict", "feat", "data", "service", "video", "ami", "photo", "game", "package", "upload", "Picture", "shadow", "whatever", "quote", "bank", "util", "pause", "library", "plugin", "info", "image", "share", "style", "audio", "large", "feature", "gui", "player", "meta", "storage", "summary", "brush", "statement", "parse", "entry", "jpg"], "got_picture_ptr": ["got_picture___addr", "got_image_pointer", "got_image_ext", "got_picture_length", "got_picture_tr", "got_picturealptr", "got_picture___ptr", "got_picturealdr", "got_picture_slice", "got_picture_pointer", "got_picture_addr", "got_picture_dr", "got_picture_ref", "got_picture_desc", "got_image_tr", "got_image_length", "got_picture___pointer", "got_image_ref", "got_picture___slice", "got_image_desc", "got_image_dr", "got_picturealpointer", "got_image_ptr", "got_picture_ext"], "avpkt": ["avperacket", "abpacket", "avspstruct", "AVpacket", "avipka", "avprekt", "avpakt", "avcke", "aphpeka", "ajpkt", "aphpkt", "akpkt", "avipet", "avipcht", "avpet", "avpreke", "avpkg", "avppke", "avwpacket", "aphpecht", "avecpkt", "avPke", "avbpunt", "avcdt", "avcpka", "avperstruct", "avpunt", "avcpcht", "avbpct", "AVpct", "akbpcht", "AVpkt", "avspacket", "affct", "affunt", "avcpet", "aphpka", "aphpekt", "avcpkt", "avipkt", "avcpelt", "ajwpacket", "ajpke", "avfstruct", "avPct", "AVppct", "avepelt", "akbpdt", "abfstruct", "avecpacket", "affacket", "akpdt", "avpecht", "aphpcht", "avpaacket", "avwpkt", "avecpqt", "aphpeet", "avpaelt", "avppacket", "avcacket", "afpunt", "avppkt", "avfacket", "avcpqt", "avpelt", "avwpvc", "avPacket", "avperkg", "avfke", "avpka", "avcct", "abpkt", "avepqt", "abfkt", "avepacket", "avpdt", "abpstruct", "ajpvc", "avfkt", "avpvc", "avppct", "avpstruct", "avbpkt", "akbpkt", "avcpacket", "avbpcht", "avepkt", "avckt", "avpcht", "avpacket", "avpercht", "avspkt", "avpreacket", "ajwpkt", "avwpke", "abfkg", "afpkt", "avfunt", "avecpelt", "avccht", "avpke", "AVppacket", "akpcht", "afpacket", "avpeka", "avfkg", "AVppke", "abpkg", "abfacket", "avbpacket", "avfelt", "avfct", "avperkt", "avcvc", "avbpdt", "ajwpvc", "AVpke", "avpaqt", "aphpet", "ajpacket", "avperdt", "avspkg", "AVppkt", "avpct", "avcunt", "avfqt", "akpacket", "afpct", "ajwpke", "avPkt", "affkt", "avpqt", "avprevc", "avpeet", "akbpacket", "avpekt"], "ret": ["cat", "bf", "val", "let", "res", "value", "back", "match", "pet", "rc", "att", "def", "rt", "code", "img", "num", "flag", "alt", "tmp", "fin", "RET", "ref", "arr", "det", "gt", "rev", "obj", "et", "len", "lit", "ut", "success", "rets", "feat", "data", "reply", "mt", "fun", "nt", "reg", "info", "result", "rot", "arg", "Ret", "f", "ft", "cur", "re"], "frame_number": ["image_no", "image_num", "frame_nr", "frame_num", "image_number", "frame_no", "image_nr"]}}
{"project": "qemu", "commit_id": "87e459a810d7b1ec1638085b5a80ea3d9b43119a", "target": 1, "func": "static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun,\n\n                                      MegasasCmd *cmd)\n\n{\n\n    struct mfi_pd_info *info = cmd->iov_buf;\n\n    size_t dcmd_size = sizeof(struct mfi_pd_info);\n\n    uint64_t pd_size;\n\n    uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (lun & 0xFF);\n\n    uint8_t cmdbuf[6];\n\n    SCSIRequest *req;\n\n    size_t len, resid;\n\n\n\n    if (!cmd->iov_buf) {\n\n        cmd->iov_buf = g_malloc0(dcmd_size);\n\n        info = cmd->iov_buf;\n\n        info->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */\n\n        info->vpd_page83[0] = 0x7f;\n\n        megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data));\n\n        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);\n\n        if (!req) {\n\n            trace_megasas_dcmd_req_alloc_failed(cmd->index,\n\n                                                \"PD get info std inquiry\");\n\n            g_free(cmd->iov_buf);\n\n            cmd->iov_buf = NULL;\n\n            return MFI_STAT_FLASH_ALLOC_FAIL;\n\n        }\n\n        trace_megasas_dcmd_internal_submit(cmd->index,\n\n                                           \"PD get info std inquiry\", lun);\n\n        len = scsi_req_enqueue(req);\n\n        if (len > 0) {\n\n            cmd->iov_size = len;\n\n            scsi_req_continue(req);\n\n        }\n\n        return MFI_STAT_INVALID_STATUS;\n\n    } else if (info->inquiry_data[0] != 0x7f && info->vpd_page83[0] == 0x7f) {\n\n        megasas_setup_inquiry(cmdbuf, 0x83, sizeof(info->vpd_page83));\n\n        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);\n\n        if (!req) {\n\n            trace_megasas_dcmd_req_alloc_failed(cmd->index,\n\n                                                \"PD get info vpd inquiry\");\n\n            return MFI_STAT_FLASH_ALLOC_FAIL;\n\n        }\n\n        trace_megasas_dcmd_internal_submit(cmd->index,\n\n                                           \"PD get info vpd inquiry\", lun);\n\n        len = scsi_req_enqueue(req);\n\n        if (len > 0) {\n\n            cmd->iov_size = len;\n\n            scsi_req_continue(req);\n\n        }\n\n        return MFI_STAT_INVALID_STATUS;\n\n    }\n\n    /* Finished, set FW state */\n\n    if ((info->inquiry_data[0] >> 5) == 0) {\n\n        if (megasas_is_jbod(cmd->state)) {\n\n            info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);\n\n        } else {\n\n            info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);\n\n        }\n\n    } else {\n\n        info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);\n\n    }\n\n\n\n    info->ref.v.device_id = cpu_to_le16(pd_id);\n\n    info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|\n\n                                          MFI_PD_DDF_TYPE_INTF_SAS);\n\n    blk_get_geometry(sdev->conf.blk, &pd_size);\n\n    info->raw_size = cpu_to_le64(pd_size);\n\n    info->non_coerced_size = cpu_to_le64(pd_size);\n\n    info->coerced_size = cpu_to_le64(pd_size);\n\n    info->encl_device_id = 0xFFFF;\n\n    info->slot_number = (sdev->id & 0xFF);\n\n    info->path_info.count = 1;\n\n    info->path_info.sas_addr[0] =\n\n        cpu_to_le64(megasas_get_sata_addr(pd_id));\n\n    info->connected_port_bitmap = 0x1;\n\n    info->device_speed = 1;\n\n    info->link_speed = 1;\n\n    resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);\n\n    g_free(cmd->iov_buf);\n\n    cmd->iov_size = dcmd_size - resid;\n\n    cmd->iov_buf = NULL;\n\n    return MFI_STAT_OK;\n\n}\n", "idx": 1672, "substitutes": {"sdev": ["sportsdem", "dsdem", "sportsdiv", " smod", "sdf", "ksnov", "fdev", "fdf", "fdiv", "sgd", " sgd", "sde", "setsdev", "setsdem", "sportsdev", "ksmod", "fdem", "sdem", " sde", "lsdiv", "dsdev", "csdev", " sdem", " snov", "cnov", "ksdev", " sdi", "lsde", "sdiv", "cdiv", "csdi", "lsnov", "cdev", "lsdev", "setsgd", "sdi", "csmod", "snov", "cde", " sdf", "sportsdf", "csnov", "dsgd", "dsde", "setsde", "smod", " sdiv", "ksdi"], "lun": ["luni", " lul", "iluni", " lone", "sluma", "sloun", "slul", "luma", "ilone", " lunt", "ilunt", " lUN", "lone", "tun", "lloun", "tune", " luma", "elun", "slune", "slunc", "slunt", "ilun", "tUN", "llun", "elunt", "tunt", "llul", "llUN", "eluma", "lunc", "llunt", "lUN", " lune", "lunt", "elone", "slUN", "luna", "elune", "lul", " luni", " lunc", " loun", "lluna", "sluna", "slun", " luna", "llune", "eluni", "llunc", "loun", "lune"], "cmd": ["ctl", "md", "host", "update", "cat", "cod", "cc", "pkg", "mac", "setup", "comm", "cf", "domain", "def", "gen", "cmp", "cookie", "cm", "ctx", "code", "conf", "grad", "cpp", "command", "vc", "qq", "cms", "module", "input", "cli", "config", "qt", "call", "Cmd", "buf", "method", "df", "mode", "off", "cp", "conn", "gz", "func", "g", "data", "window", "parent", "c", "ctrl", "dq", "target", "plugin", "init", "mc", "cb", "crit", "ck", "hw", "cl", "utils", "component", "child", "ctr", "cfg", "client", "msg", "dom", "cd", "clean"], "info": ["information", "hi", "update", "inf", "i", "zip", "home", "ui", "diff", "Info", "by", "manager", "loc", "buff", "error", "setup", "def", "iso", "fi", "gen", "si", "ctx", "conf", "command", "opt", "ref", "mem", "fo", "html", "tf", "config", "job", "name", "id", "check", "api", "note", "stat", "ii", "full", "help", "py", "off", "end", "conn", "type", "data", "afi", "current", "start", "now", "init", "block", "image", "state", "f", "op", "bug", "json", "extra", "http", "thin", "INFO", "index"], "pd_size": ["ctxrlength", "ctx_length", "ctxrsize", "pd_length", "pd_capacity", "pdrcapacity", "pd2capacity", "pd2size", "pdrlength", "pdrsize", "ctxrcapacity", "ctx_size", "pd2length", "ctx_capacity"], "cmdbuf": ["cmdbu", "commanddata", "cfbuffer", " cmddata", "cmdfunc", "cookieuf", "cfdata", "mduf", " cmdbuffer", "cookiebuff", "msgbuff", "ctxbuff", "reqbuff", "commanduf", "msguf", "reqbuffer", "mdfunc", " cmdbuff", "mdbu", "cfgfunc", "cfbuff", "cmdbuffer", "msgbuffer", "cmdbuff", "mdbuff", "commandbu", "ctxbag", " cmduf", "cfgbuf", "mdbag", "ctxbuf", "commandbuff", "requf", "reqbuf", "msgbuf", "mdbuffer", "cfbuf", "cfgbag", "msgbu", "commandbuffer", "cmduf", "cfgbuff", "ctxfunc", "cookiebuffer", "cmdbag", "cookiebuf", "commandbuf", "cmddata", "mdbuf"], "req": ["required", "wa", "dist", "zip", "res", "rr", "pkg", "gr", "r", "diff", "cf", "def", "hop", "cmp", "rt", "ctx", "grad", "conf", "resp", "low", "lib", "rx", "exec", "ref", "requ", "qq", "fit", "query", "ind", "sq", "rev", "call", "id", "queue", "check", "urg", "download", "qa", "rec", "ext", "conn", "feat", "need", "data", "iq", "require", "spec", "fun", "app", "comp", "dq", "pull", "flow", "init", "cb", "quest", "crit", "proc", "q", "err", "f", "cur", "ver", "ctr", "desc", "http", "qt", "progress", "msg", "seq", "request"], "len": ["val", "part", "loc", "en", "l", "gen", "cmp", "low", "num", "resp", "n", "alt", "lib", "dl", "elt", "fin", "fl", "ind", "min", "rev", "ln", "count", "Len", "lit", "pos", "conn", "fd", "el", "str", "data", "li", "lan", "ie", "length", "fun", "nt", "body", "url", "ll", "args", "bin", "err", "set", "js", "size", "sl", "ls", "bid", "bytes", "bl", "lf", "lc", "seq"], "resid": ["rsnum", "resID", "rsinfo", " resID", "resinfo", " resinfo", " resnum", "rsid", "respinfo", "respID", "resnum", "rsID", "respid", "respnum"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_isel(DisasContext *ctx)\n\n{\n\n    int l1, l2;\n\n    uint32_t bi = rC(ctx->opcode);\n\n    uint32_t mask;\n\n    TCGv_i32 t0;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n\n\n    mask = 0x08 >> (bi & 0x03);\n\n    t0 = tcg_temp_new_i32();\n\n    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);\n\n    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);\n\n    if (rA(ctx->opcode) == 0)\n\n        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);\n\n    else\n\n        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);\n\n    gen_set_label(l2);\n\n    tcg_temp_free_i32(t0);\n\n}\n", "idx": 1710, "substitutes": {"ctx": ["kb", "gru", "cu", "git", "cc", "pkg", "loc", "sc", "cf", "fc", "cmp", "context", "cpp", "rc", "cs", "linux", "grad", "cca", "vc", "fp", "ci", "connection", "qq", "xc", "cli", "config", "cam", "concept", "input", " cx", "qa", "Context", "tc", "sci", "gmail", "cv", "cp", "lc", "conn", "gpu", "ca", "prefix", "cn", "txt", "c", "ctrl", "comp", "kt", "cpu", "cb", "tx", "ck", "que", "cmd", "hw", "client", "utils", "component", "bc", "cfg", "cas", "sync", "cm", "anc", "cus"], "l1": ["p3", "el01", " lone", " l3", " lOne", "t4", "li01", " l0", "p0", "L01", "lone", "el3", "v2", "tOne", "L0", "p1", "L2", "li2", "el1", "l4", "Lone", "L1", "t3", "t1", "t2", "l01", "li3", "li1", "pone", "lOne", "L3", "el2", "L4", "l0", "p2", "pOne", "v0", "l3", "v1", "v4"], "l2": ["t5", " l3", " l5", "t4", "l8", "L5", " l0", "L0", "p1", "p72", "L2", "rl4", "l72", "li2", "Ltwo", "l4", " l4", "li8", "L1", "p8", "t3", "l5", "t1", "L8", "t2", " ltwo", "rltwo", "li1", "L3", "L4", "rl2", "l0", "L72", "rl3", "p2", "li72", "ltwo", "l3"], "mask": ["comment", "offset", "lock", "cc", "scan", "mac", "bug", "scale", "fac", "patch", "conf", "zero", "pixel", "filter", "ask", "qq", "delay", "bridge", "config", "m", "sum", "qa", "pad", "skip", "label", "sign", "iq", "batch", "shape", "reg", "map", "weight", "ix", "info", "depth", "Mask", "block", "ai", "pack", "feature", "gi", "q", "f", "fix", "sk", "pass", "bit"], "t0": ["p3", "f0", "f50", "t4", "t8", "p0", "d8", " t3", "pt0", " t8", " t2", "p1", "pt4", "l50", " tee", "pt2", "t3", "t1", "t2", "Tee", "tee", "t19", "f2", "p19", "dee", "T0", " t1", "T4", " t50", "l0", "d2", "p2", "pt19", "f1", "t50", "d0", "T2", "l3", "p4", "T19", "T8"]}}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void stream_process_mem2s(struct Stream *s,\n\n                                 StreamSlave *tx_dev)\n\n{\n\n    uint32_t prev_d;\n\n    unsigned char txbuf[16 * 1024];\n\n    unsigned int txlen;\n\n    uint32_t app[6];\n\n\n\n    if (!stream_running(s) || stream_idle(s)) {\n\n        return;\n\n    }\n\n\n\n    while (1) {\n\n        stream_desc_load(s, s->regs[R_CURDESC]);\n\n\n\n        if (s->desc.status & SDESC_STATUS_COMPLETE) {\n\n            s->regs[R_DMASR] |= DMASR_HALTED;\n\n            break;\n\n        }\n\n\n\n        if (stream_desc_sof(&s->desc)) {\n\n            s->pos = 0;\n\n            memcpy(app, s->desc.app, sizeof app);\n\n        }\n\n\n\n        txlen = s->desc.control & SDESC_CTRL_LEN_MASK;\n\n        if ((txlen + s->pos) > sizeof txbuf) {\n\n            hw_error(\"%s: too small internal txbuf! %d\\n\", __func__,\n\n                     txlen + s->pos);\n\n        }\n\n\n\n        cpu_physical_memory_read(s->desc.buffer_address,\n\n                                 txbuf + s->pos, txlen);\n\n        s->pos += txlen;\n\n\n\n        if (stream_desc_eof(&s->desc)) {\n\n            stream_push(tx_dev, txbuf, s->pos, app);\n\n            s->pos = 0;\n\n            stream_complete(s);\n\n        }\n\n\n\n        /* Update the descriptor.  */\n\n        s->desc.status = txlen | SDESC_STATUS_COMPLETE;\n\n        stream_desc_store(s, s->regs[R_CURDESC]);\n\n\n\n        /* Advance.  */\n\n        prev_d = s->regs[R_CURDESC];\n\n        s->regs[R_CURDESC] = s->desc.nxtdesc;\n\n        if (prev_d == s->regs[R_TAILDESC]) {\n\n            s->regs[R_DMASR] |= DMASR_IDLE;\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 1712, "substitutes": {"s": ["i", "uns", "conf", "er", "d", "ions", "an", "v", "states", "ps", "lines", "sym", "os", "f", "as", "this", "js", "comments", "l", "sites", "is", "si", "o", "qs", "y", "p", "ins", "details", "se", "ses", "site", "args", "features", "b", "sg", "u", "ops", "sync", "h", "S", "r", "settings", "cs", "changes", "ssl", "south", "new", "m", "session", "service", "g", "your", "us", "server", "ks", "es", "gs", "t", "native", "aws", "ss", "e", "ls", "http", "ds", "xs", "fs", "ms", "su", "sets", "ts", "ns", "ims", "n", "services", "sys", "c", "rs", "self", "ows", "tests", "its", "client"], "tx_dev": ["tx_root", "contextkev", "tx5dev", "tx_serv", "txkev", "tx5Dev", "tx_ev", "tx2dev", "tx5ev", "tx2ev", "contextkroot", " tx_ev", "contextkdev", "context_root", "context_dev", "tx_Dev", "txkDev", "tx_device", "tx2device", " tx_device", "context_Dev", "context_ev", "tx5root", "tx2serv", "contextkDev", " tx_serv", "txkroot", "txkdev"], "prev_d": ["prev2d", "prev__d", "Prev_dc", " prev2D", "Prev_D", " prev2dy", "prev__dc", "prevRevD", "prev2b", " prev2b", "prevKds", "prev_b", " prev_D", " prev2j", "prevKd", " prev_b", "prevPb", "prev2ds", "prev__D", " prev_j", " prev_ds", "prev_dc", " prev2sd", "prevRevd", "prevPds", "prevroyD", "prev_j", "prevKb", "prevPd", "prev_D", "prevroyj", "prevroyd", "prev2j", "prev2sd", " prev2ds", " prev2d", " prev_dy", "prev2D", "Prev_d", "prev_ds", " prev_sd", "prevRevsd", "prevRevj", "prevKdy", "prev2dy", "prevPdy", "prevroysd", "prev_sd", "prev_dy"], "txbuf": ["TXlen", "xlen", "membuffer", "xbuf", "TXbuffer", "memlen", "TXcb", "txbytes", "xbuffer", "rxbuffer", "ctxlen", "membuf", "rxqueue", "txctx", "rxlen", "rxbytes", " txbytes", "ctxbuf", "TXbuf", "rxctx", "xbytes", " txctx", "xcb", " txbuffer", "ctxctx", "rxbuf", "memqueue", "txcb", "xqueue", "ctxbuffer", " txcb", "txbuffer", "txqueue"], "txlen": ["txln", " txval", "TXlen", "xlen", "txpos", "TXLen", " txLen", "rxlength", "xlon", "hoplength", "texten", "hoplen", "misslength", "hoplim", "txen", "misslen", " txlength", " txpos", "rxlen", "rxlim", "TXlength", "hopl", " cxln", " cxlen", "mxlength", "mxlen", "TXl", "textLen", "rxlon", "rxLen", "textlen", " txlon", "xl", "mxval", "mxen", "xLen", "xen", "txLen", " txl", "txlength", " txln", "textlength", " cxpos", "TXval", "missl", "txlim", "txl", "xpos", "TXen", "rxl", "txlon", " txlim", "xln", "misslon", " txen", "txval", "rxen", " cxl"], "app": ["ape", "cache", "all", "mac", "buff", "fac", "form", "att", "container", "ac", "match", "ram", "array", "enc", "apply", "application", "p", "pattern", "arr", "stack", "ab", "raw", "append", "config", "m", "acc", "name", "access", "load", "aa", "a", "x", "APP", "g", "data", "allow", "apps", "oper", "ps", "server", "shape", "port", "ap", "reg", "pp", "c", "display", "test", "asm", "map", "App", "exc", "ch", "ace", "process", "pack", "proc", "dev", "save", "ipp", "ip", "instance", "ready", "client", "record", "path"]}}
{"project": "FFmpeg", "commit_id": "a70a3f0b4dc488ad04f81c16479c74f57b17e06f", "target": 0, "func": "static int adpcm_decode_init(AVCodecContext * avctx)\n\n{\n\n    ADPCMContext *c = avctx->priv_data;\n\n\n\n    if(avctx->channels > 2U){\n\n        return -1;\n\n    }\n\n\n\n    c->channel = 0;\n\n    c->status[0].predictor = c->status[1].predictor = 0;\n\n    c->status[0].step_index = c->status[1].step_index = 0;\n\n    c->status[0].step = c->status[1].step = 0;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_ADPCM_CT:\n\n        c->status[0].step = c->status[1].step = 511;\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WS:\n\n        if (avctx->extradata && avctx->extradata_size == 2 * 4) {\n\n            c->status[0].predictor = AV_RL32(avctx->extradata);\n\n            c->status[1].predictor = AV_RL32(avctx->extradata + 4);\n\n        }\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 1713, "substitutes": {"avctx": ["avcu", "aflc", "evlc", "AVctx", "mpcontext", "avalctl", "abctx", "abcf", "avcmp", "afconn", "afc", "mplc", "afctx", "broadsys", "avlc", "apcontext", "devlc", "AVcontext", "avctl", "avhw", "devsys", "avcontext", "avalcontext", "avecf", "afctl", "avconn", "alhw", "avectx", "devcf", "allc", "avalc", "afsc", "avsys", "devcontext", "apctx", "AVctl", "AVc", "alctx", "devconn", "avalctx", "avcf", "ajsc", "evcontext", "apcmp", "ajcontext", "AVcmp", "mpctx", "ajcup", "evconn", "broadcontext", "AVcu", "ajctx", "abcontext", "avesc", "afcmp", "avecontext", "evctx", "broadctx", "devctx", "avc", "afcup", "avcup", "afcf", "devc", "afcontext", "afsys", "afcu", "afhw", "ablc", "AVlc", "broadc", "aveconn", "AVhw", "alcontext", "avsc", "mpcf", "apcu", "avecup"], "c": ["cu", "cache", "dc", "cc", "cr", "i", "com", "sc", "cf", "ac", "l", "fc", "rc", "cs", "context", "ctx", "enc", "n", "sec", "core", "arc", "vc", "p", "ci", "exec", "anc", "ce", "ic", "ec", "d", "config", "w", "k", "tc", "abc", "con", "v", "rec", "cp", "lc", "conn", "pc", "ca", "g", "coll", "ctrl", "can", "nc", "ch", "mc", "oc", "t", "b", "f", "u", "cl", "cur", "C", "e", "uc", "ct", "client", "h", "cm", "s"]}}
{"project": "qemu", "commit_id": "e5fda03839e3c61b01d6c60de5625501d01c69d0", "target": 1, "func": "static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci)\n\n{\n\n    read_local_name_rp params;\n\n    params.status = HCI_SUCCESS;\n\n    memset(params.name, 0, sizeof(params.name));\n\n    if (hci->device.lmp_name)\n\n        strncpy(params.name, hci->device.lmp_name, sizeof(params.name));\n\n\n\n    bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE);\n\n}\n", "idx": 1721, "substitutes": {"hci": ["hcin", "hmodi", "ehcu", "pci", "hmdi", " hcu", "hmci", " hdi", " hc", "ohcin", "ohdc", "hhcu", " hcit", "pcci", "cci", "pcu", "ehdc", "hdcit", "hdodi", "hhcin", "cdi", "hcit", " hcci", "hcu", " hodi", "ohci", "hmcu", "hmcin", "hdc", "hodi", "hdi", "hcci", "hhci", " hdc", "ehci", "hhdi", "hmc", " hcin", "ccu", "pdi", "ehcin", "ohcu", "hmcit", "hc", "hdci", "ccci"], "params": ["i", "cmp", "array", "uri", "ras", "ps", "parent", "sp", "results", "info", "as", "json", "js", "media", "phys", "same", "manager", "ram", "resources", "null", "tmp", "config", "details", "name", "vm", "mm", "data", "css", "args", "response", "ops", "cas", "plugins", "pointer", "lc", "device", "settings", "cs", "ctx", "param", "cms", "obj", "missing", "server", "spec", "gs", "options", " parameters", "ip", "size", "ds", "source", "model", "cache", "mac", "attr", "copy", "camera", "names", "radius", "api", "handler", "master", "services", "type", "rs", "target", "ams", "eps", "result", "par", "parse", "instance"]}}
{"project": "qemu", "commit_id": "e2b72cb6e0443d90d7ab037858cb6834b6cca852", "target": 1, "func": "static bool vnc_should_update(VncState *vs)\n\n{\n\n    switch (vs->update) {\n\n    case VNC_STATE_UPDATE_NONE:\n\n        break;\n\n    case VNC_STATE_UPDATE_INCREMENTAL:\n\n        /* Only allow incremental updates if the output buffer\n\n         * is empty, or if audio capture is enabled.\n\n         */\n\n        if (!vs->output.offset || vs->audio_cap) {\n\n            return true;\n\n        }\n\n        break;\n\n    case VNC_STATE_UPDATE_FORCE:\n\n        return true;\n\n    }\n\n    return false;\n\n}\n", "idx": 1726, "substitutes": {"vs": ["fs", "ils", "sv", "cf", "ts", "ns", "settings", "cs", "qs", "forces", "vc", "otes", "events", "WS", "Vs", "va", "bs", "verts", "alls", "v", "cv", "services", "stats", "VS", "states", "vers", "ps", "ses", "ks", "spec", "rs", "vals", "es", "obs", "ants", "eps", "gs", "vp", "state", "os", "sts", "ss", "env", "ls", "sk", "points", "ops", "ds", "xs"]}}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoll_whitespace(void)\n\n{\n\n    const char *str = \"  \\t  \";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    int64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoll(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 1736, "substitutes": {"str": ["stri", "fr", "i", "cr", "rr", "text", "gr", "res", "req", "pr", "sr", "r", "tr", "cs", "enc", "code", "ptr", "temp", "st", "arr", "dr", "Str", "obj", "iter", "w", "ext", "txt", "sp", "kr", "spec", "old", "c", "hr", "STR", "in", "prev", "start", "std", "f", "doc", "ctr", "inner", "lc", "br"], "endptr": ["endedptr", "startpointer", "adpointer", "endedtr", "endaddr", " endtr", "endedaddr", "endtr", " endPtr", "adptr", "startproc", "startptr", "starttr", " endproc", " endaddr", "endpointer", "adPtr", " endpointer", "startPtr", "endproc", "adaddr", "adproc", "startaddr", "endPtr", "endedPtr"], "err": ["order", "fr", "cr", "rr", "res", "gr", "req", "rh", "pr", "r", "error", "bug", "rc", "grade", "code", "resp", "er", "Er", "p", "arr", "ger", "dr", "ind", "var", "call", "id", "iter", "mr", "errors", "len", "Error", "ler", "ise", "aster", "test", "info", "ner", "result", "cb", "der", "ver", "doc", "frac", "ctr", "msg", "try"]}}
{"project": "qemu", "commit_id": "aaf89c8a49a8c1259b6b181d701070c6df83f3d7", "target": 0, "func": "static void test_migrate(void)\n\n{\n\n    char *uri = g_strdup_printf(\"unix:%s/migsocket\", tmpfs);\n\n    QTestState *global = global_qtest, *from, *to;\n\n    unsigned char dest_byte_a, dest_byte_b, dest_byte_c, dest_byte_d;\n\n    gchar *cmd;\n\n    QDict *rsp;\n\n\n\n    char *bootpath = g_strdup_printf(\"%s/bootsect\", tmpfs);\n\n    FILE *bootfile = fopen(bootpath, \"wb\");\n\n\n\n    got_stop = false;\n\n    g_assert_cmpint(fwrite(bootsect, 512, 1, bootfile), ==, 1);\n\n    fclose(bootfile);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=kvm:tcg -m 150M\"\n\n                          \" -name pcsource,debug-threads=on\"\n\n                          \" -serial file:%s/src_serial\"\n\n                          \" -drive file=%s,format=raw\",\n\n                          tmpfs, bootpath);\n\n    from = qtest_start(cmd);\n\n    g_free(cmd);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=kvm:tcg -m 150M\"\n\n                          \" -name pcdest,debug-threads=on\"\n\n                          \" -serial file:%s/dest_serial\"\n\n                          \" -drive file=%s,format=raw\"\n\n                          \" -incoming %s\",\n\n                          tmpfs, bootpath, uri);\n\n    to = qtest_init(cmd);\n\n    g_free(cmd);\n\n\n\n    global_qtest = from;\n\n    rsp = qmp(\"{ 'execute': 'migrate-set-capabilities',\"\n\n                  \"'arguments': { \"\n\n                      \"'capabilities': [ {\"\n\n                          \"'capability': 'postcopy-ram',\"\n\n                          \"'state': true } ] } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    global_qtest = to;\n\n    rsp = qmp(\"{ 'execute': 'migrate-set-capabilities',\"\n\n                  \"'arguments': { \"\n\n                      \"'capabilities': [ {\"\n\n                          \"'capability': 'postcopy-ram',\"\n\n                          \"'state': true } ] } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    /* We want to pick a speed slow enough that the test completes\n\n     * quickly, but that it doesn't complete precopy even on a slow\n\n     * machine, so also set the downtime.\n\n     */\n\n    global_qtest = from;\n\n    rsp = qmp(\"{ 'execute': 'migrate_set_speed',\"\n\n              \"'arguments': { 'value': 100000000 } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    /* 1ms downtime - it should never finish precopy */\n\n    rsp = qmp(\"{ 'execute': 'migrate_set_downtime',\"\n\n              \"'arguments': { 'value': 0.001 } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n\n\n    /* Wait for the first serial output from the source */\n\n    wait_for_serial(\"src_serial\");\n\n\n\n    cmd = g_strdup_printf(\"{ 'execute': 'migrate',\"\n\n                          \"'arguments': { 'uri': '%s' } }\",\n\n                          uri);\n\n    rsp = qmp(cmd);\n\n    g_free(cmd);\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    wait_for_migration_pass();\n\n\n\n    rsp = return_or_event(qmp(\"{ 'execute': 'migrate-start-postcopy' }\"));\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    if (!got_stop) {\n\n        qmp_eventwait(\"STOP\");\n\n    }\n\n\n\n    global_qtest = to;\n\n    qmp_eventwait(\"RESUME\");\n\n\n\n    wait_for_serial(\"dest_serial\");\n\n    global_qtest = from;\n\n    wait_for_migration_complete();\n\n\n\n    qtest_quit(from);\n\n\n\n    global_qtest = to;\n\n\n\n    qtest_memread(to, start_address, &dest_byte_a, 1);\n\n\n\n    /* Destination still running, wait for a byte to change */\n\n    do {\n\n        qtest_memread(to, start_address, &dest_byte_b, 1);\n\n        usleep(10 * 1000);\n\n    } while (dest_byte_a == dest_byte_b);\n\n\n\n    qmp(\"{ 'execute' : 'stop'}\");\n\n    /* With it stopped, check nothing changes */\n\n    qtest_memread(to, start_address, &dest_byte_c, 1);\n\n    sleep(1);\n\n    qtest_memread(to, start_address, &dest_byte_d, 1);\n\n    g_assert_cmpint(dest_byte_c, ==, dest_byte_d);\n\n\n\n    check_guests_ram();\n\n\n\n    qtest_quit(to);\n\n    g_free(uri);\n\n\n\n    global_qtest = global;\n\n\n\n    cleanup(\"bootsect\");\n\n    cleanup(\"migsocket\");\n\n    cleanup(\"src_serial\");\n\n    cleanup(\"dest_serial\");\n\n}\n", "idx": 1760, "substitutes": {"uri": ["umi", "i", "ui", "database", "io", "loc", " URI", "prot", "ctx", "unit", "dir", "fp", "ci", "ref", "location", "src", "uni", "remote", "connection", "folder", "cli", "config", "name", "iri", "id", "ri", "route", "format", "prefix", "file", "url", "origin", "gb", "plugin", "URI", "address", "resource", "directory", "timeout", "http", "client", "path", "filename"], "global": ["gu", "gl", "cache", "all", "io", "common", "Global", "conf", "lib", "remote", "cli", "session", "foreign", "master", "sys", "co", "parent", "server", "can", "current", "gb", "general", "util", "local", "final", "http", "client", "msg"], "from": ["user", "driver", "fr", "action", "by", "base", "r", "back", "form", "at", "normal", "or", "param", "new", "connection", "false", "module", "d", "config", "m", "name", "vol", "From", "of", "a", "pos", "ou", "who", "add", "before", "parent", "old", "c", "after", "self", "origin", "current", "state", "args", "as", "f", "u", "cur", "range", "component", "resource", "with", "e", "client", "ce", "ra", "source"], "to": ["user", "To", "be", "socket", "by", "su", "po", "so", "o", "at", "p", "param", "new", "location", "or", "token", "name", "TO", "py", "pos", "sys", "type", "dest", "co", "afi", "too", "parent", "top", "since", "until", "site", "after", "test", "target", "options", "state", "toc", "t", "response", "as", "f", "range", "resource", "size", "out", "go", "client", "source", "rule"], "dest_byte_a": ["dest_key_A", "dest_key_b", "dest_key_a", "dest_key_address", "dest_byte_A", "dest_byte_address"], "dest_byte_b": ["dest_no_b", "dest_no_board", "dest_byte_board", "dest_byte128board", "dest_byte128b", "dest_no_a", "dest_no_e", "dest_byte_e", "dest_byte128e", "dest_byte128a"], "dest_byte_c": ["dest_byte2d", "dest_bit_C", "dest_bit_d", "dest_bit64C", "dest_byte_cat", "dest_bit64cat", "dest_bit_c", "dest_bit64c", "dest_bit64d", "dest_bit_cat", "dest_byte2c", "dest_byte2cat", "dest_byte33c", "dest_byte33cat", "dest_byte33C", "dest_byte2C", "dest_byte64c", "dest_byte64cat", "dest_byte64d", "dest_byte33d", "dest_byte64C", "dest_byte_C"], "dest_byte_d": ["dest_byte2d", "dest_char_ds", "dest_char2d", "dest_byte_ds", "dest_byte_D", "dest_char_c", "dest_char2c", "dest_char2D", "dest_byte64D", "dest_byte2c", "dest_char_d", "dest_byte64ds", "dest_char_D", "dest_byte2ds", "dest_byte2D", "dest_byte64c", "dest_byte64d", "dest_char2ds"], "cmd": ["md", "pkg", "req", "grad", "conf", "win", "head", "cn", "plugin", "cb", "ctr", "go", "msg", "cd", "host", "cc", "xml", "vc", "qq", "config", "call", "name", "buf", "method", "mode", "url", "and", "gg", "init", "args", "custom", "utils", "comm", "cookie", "gen", "ctx", "code", "acl", "Cmd", "help", "cp", "conn", "gz", "g", "fun", "ctrl", "child", "bind", "dom", "kg", "path", "clean", "cat", "mac", "bug", "cf", "def", "rc", "img", "command", "src", "module", "input", "cli", "wo", "id", "prefix", "c", "self", "nc", "target", "ck", "dict", "bin", "cl", "resource", "one", "cfg", "client", "anc"], "rsp": ["lpp", "hrsp", "irbsp", "rSp", "rrpc", "rso", "rtmp", "errsh", "rrsync", "rtjs", "rsync", " rspl", "prapp", "hrspec", "prSp", "prpc", "brSp", "prpp", "prmp", "rtso", "rcspace", "rrbsp", "arbsp", "arspl", "qsp", "risp", " rcp", "qspace", " rsl", "srisp", "irprof", "rrserv", "lbsp", "prsl", "irspl", "rbc", "prsync", "yrsp", "rsa", "prsa", "roso", "rtspl", "arserv", "arbc", " rspace", "rcsl", " rsc", "rtsl", "rspl", "qbsp", "rtsc", "irsp", "strsc", "rscope", "ardi", "errsp", "srsp", "rospec", "rtsp", "arSp", "srpc", "yrserv", "rserv", "qsc", " rscope", "arsl", "yrsh", "rrprof", "lsp", "qbc", " rmp", "prsc", "arpp", "rspec", "rsh", "qmp", "arsp", "rcp", "armp", "errserv", "rtspec", "prdi", " rsh", "strsh", "rcsp", "brsp", "prsp", "rapp", "rtbsp", "prscope", "qsync", "prspace", "arspace", "rcsc", " rjp", "srmp", "rtspace", " rp", "rpp", "rpc", "prbsp", "rrspl", "qsa", "rmp", " rpc", "lapp", "srjs", "brjs", " rserv", "rtjp", "hrso", "prbc", "rosp", "yrp", "rsc", "arsc", "rprof", "errp", "srsl", "brdi", "rjs", "robsp", "rspace", "arscope", "rjp", "prcp", "brisp", "qpc", "qserv", "brsl", "rdi", "prserv", "strspl", "arprof", "srserv", "srsc", "strsp", "rp", "qcp", "rbsp", "rrsp", "rtisp", "arpc", "rsl", "rrsa", "prjp", "rtsh", "hrbsp", "arapp"], "bootpath": ["bootfolder", "bootdir", " bootlocation", " bootformat", "lockfile", "busname", "outpath", "bootname", " bootname", "ootpath", "buslocation", "bitpath", "bootconfig", "ootfile", " bootdir", " bootlog", "ootformat", "blockfolder", "lockpath", "bootlocation", "toolfile", "bitcol", "blockpath", "bitconfig", "bootformat", " bootfolder", "buspath", " bootconfig", "lockcat", "ootdir", "outfile", "ootlog", "bitfile", " bootcat", "bootcat", " bootcol", "busfolder", "locklog", "ootcat", "bootlog", "outdir", "blocklocation", "outformat", "blockname", "toolpath", "bootcol", "toolconfig", "toolcol"], "bootfile": ["bootbase", "outpath", "Bootfile", "bootfp", " bootfiles", "bitbase", "Bootbase", "outfp", "bitfiles", "bitpath", "catfile", "Bootlog", " bootlog", "Bootfiles", "bootfiles", "catfp", "catlog", "outfile", "bitfile", " bootfp", " bootbase", "bootlog", "outlog", "outfiles", "catpath", "bitlog"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,\n\n                                          bool tso_enable)\n\n{\n\n    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;\n\n    uint16_t l3_proto;\n\n\n\n    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,\n\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);\n\n\n\n    if (!tso_enable) {\n\n        goto func_exit;\n\n    }\n\n\n\n    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,\n\n                          pkt->l4proto);\n\n\n\nfunc_exit:\n\n    return rc;\n\n}\n", "idx": 1770, "substitutes": {"pkt": ["prockt", "let", " pnt", "ppt", "lck", "lppt", "wct", " pait", "pet", "pnt", "wnt", "Pct", "lpeth", "Pkt", "Pnt", " pcht", "lkt", "packet", "pcht", "wkt", "procct", "bait", "wacket", "pct", "Pcht", "Packet", "beth", "pait", "proccht", " ppt", " pck", "bkt", "backet", " peth", " packet", " pct", "lacket", "lpkt", "pck", "Pait", "Pet", "Peth", "procacket", "Pck", "peth", " pet", "lpacket", "Ppt"], "tso_enable": ["tso_use", "tso_id", "tco_enabled", "tso__enabled", "tso_do", "tco_enable", "tco_do", "tco_id", "tso_len", "tso_enabled", "tco_len", "tso__do", "tco_use", "tso__use", "tso__enable"], "l3_proto": ["l3_po", "l3_prodo", "l3_compdo", "l3_roc", "l3_pero", "l3_proaddr", "l3_perc", "l3_protto", "l3_ppc", "l3_protaddr", "l3_proco", "l3_perto", "l3_peraddr", "l3_roco", "l3_paddr", "l3_pco", "l3_propc", "l3_pbo", "l3_perco", "l3_probo", "l3_compto", "l3_pto", "l3_protco", "l3_pdo", "l3_pepc", "l3_compc", "l3_perpc", "l3_rodo", "l3_proc", "l3_compco", "l3_peto", "l3_perdo", "l3_pedo", "l3_perbo", "l3_roto", "l3_pebo", "l3_proo"]}}
{"project": "qemu", "commit_id": "5e30a07d6d70d3073ff61e6db79d61c2b688502f", "target": 1, "func": "static int scsi_req_length(SCSIRequest *req, uint8_t *cmd)\n\n{\n\n    switch (cmd[0] >> 5) {\n\n    case 0:\n\n        req->cmd.xfer = cmd[4];\n\n        req->cmd.len = 6;\n\n        /* length 0 means 256 blocks */\n\n        if (req->cmd.xfer == 0)\n\n            req->cmd.xfer = 256;\n\n        break;\n\n    case 1:\n\n    case 2:\n\n        req->cmd.xfer = cmd[8] | (cmd[7] << 8);\n\n        req->cmd.len = 10;\n\n        break;\n\n    case 4:\n\n        req->cmd.xfer = cmd[13] | (cmd[12] << 8) | (cmd[11] << 16) | (cmd[10] << 24);\n\n        req->cmd.len = 16;\n\n        break;\n\n    case 5:\n\n        req->cmd.xfer = cmd[9] | (cmd[8] << 8) | (cmd[7] << 16) | (cmd[6] << 24);\n\n        req->cmd.len = 12;\n\n        break;\n\n    default:\n\n        trace_scsi_req_parse_bad(req->dev->id, req->lun, req->tag, cmd[0]);\n\n        return -1;\n\n    }\n\n\n\n    switch(cmd[0]) {\n\n    case TEST_UNIT_READY:\n\n    case START_STOP:\n\n    case SEEK_6:\n\n    case WRITE_FILEMARKS:\n\n    case SPACE:\n\n    case RESERVE:\n\n    case RELEASE:\n\n    case ERASE:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case VERIFY:\n\n    case SEEK_10:\n\n    case SYNCHRONIZE_CACHE:\n\n    case LOCK_UNLOCK_CACHE:\n\n    case LOAD_UNLOAD:\n\n    case SET_CD_SPEED:\n\n    case SET_LIMITS:\n\n    case WRITE_LONG:\n\n    case MOVE_MEDIUM:\n\n    case UPDATE_BLOCK:\n\n        req->cmd.xfer = 0;\n\n        break;\n\n    case MODE_SENSE:\n\n        break;\n\n    case WRITE_SAME:\n\n        req->cmd.xfer = 1;\n\n        break;\n\n    case READ_CAPACITY:\n\n        req->cmd.xfer = 8;\n\n        break;\n\n    case READ_BLOCK_LIMITS:\n\n        req->cmd.xfer = 6;\n\n        break;\n\n    case READ_POSITION:\n\n        req->cmd.xfer = 20;\n\n        break;\n\n    case SEND_VOLUME_TAG:\n\n        req->cmd.xfer *= 40;\n\n        break;\n\n    case MEDIUM_SCAN:\n\n        req->cmd.xfer *= 8;\n\n        break;\n\n    case WRITE_10:\n\n    case WRITE_VERIFY:\n\n    case WRITE_6:\n\n    case WRITE_12:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_16:\n\n        req->cmd.xfer *= req->dev->blocksize;\n\n        break;\n\n    case READ_10:\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case READ_12:\n\n    case READ_16:\n\n        req->cmd.xfer *= req->dev->blocksize;\n\n        break;\n\n    case INQUIRY:\n\n        req->cmd.xfer = cmd[4] | (cmd[3] << 8);\n\n        break;\n\n    case MAINTENANCE_OUT:\n\n    case MAINTENANCE_IN:\n\n        if (req->dev->type == TYPE_ROM) {\n\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n\n            req->cmd.xfer = cmd[9] | (cmd[8] << 8);\n\n        }\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 1783, "substitutes": {"req": ["required", "wx", "rb", "rr", "pkg", "ok", "cmp", "grad", "sec", "resp", "ref", "mr", "orig", "qa", "jp", "ch", "cb", "proc", "ctr", "pull", "mod", "wa", "res", "gr", "rh", "exec", "sem", "qq", "config", "call", "load", "org", "data", "iq", "app", "comp", "test", "q", "err", "rob", "serv", "fr", "com", "r", "tar", "ctx", "rx", "requ", "query", "dr", "sq", "rf", "war", "conn", "require", "pro", "spec", "reg", "crit", "cur", "ver", "http", "request", "desc", "cache", "cf", "def", "rt", "low", "input", "qt", "urg", "rec", "ext", "dq", "util", "client", "seq"], "cmd": ["ctl", "md", "wx", "pkg", "cmp", "grad", "num", "ht", "opt", "d", "rom", "head", "stat", "orig", "count", "ch", "cb", "col", "dev", "doc", "ctr", "go", "bit", "msg", "cd", "host", "mod", "cod", "cc", "domain", "ac", "vc", "nd", "qq", "config", "call", "buf", "mode", "data", "nt", "comp", "q", "op", "custom", "ct", "tag", "comm", "gen", "cookie", "ack", "code", "ctx", "pipe", "Cmd", "help", "cp", "conn", "ctrl", "crit", "std", "bind", "cm", "dom", "kg", "clean", "cat", "dc", "mac", "cf", "def", "rc", "img", "command", "module", "input", "cli", "force", "id", "func", "c", "ck", "dict", "cl", "cfg", "client", "hw", "seq"]}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)\n\n{\n\n    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));\n\n\n\n    if (!p_new)\n\n        return -1;\n\n\n\n    p_new->data = p_data;\n\n\n\n    if (!queue->p_head)\n\n        queue->p_head = p_new;\n\n    else\n\n        queue->p_tail->next = p_new;\n\n    queue->p_tail = p_new;\n\n\n\n    ++queue->size;\n\n    return 0;\n\n}\n", "idx": 1791, "substitutes": {"queue": ["line", "update", "next", "menu", "cache", "database", "manager", "back", "project", "priority", "context", "lot", "header", "collection", "core", "command", "p", "ue", "group", "connection", "module", "delay", "config", "proxy", "sequence", "buffer", "stage", "buf", "route", "table", "store", "qa", "master", "event", "prefix", "file", "list", "console", "parent", "server", "port", "progress", "forward", "pool", "current", "plugin", "image", "channel", "que", "gui", "Queue", "page", "use", "message", "client", "entry", "sync", "seq", "rule"], "p_data": ["p1next", "pfnext", "pfdata", "pfdat", "p1new", " p_base", "p_next", " p_next", "p_base", "p_dat", "p1data", " p_dat", "pfnew", "p1base"], "p_new": [" p_fresh", "p_NEW", "p_gen", "dataocknew", "pocknew", "p__old", "p___gen", "data_new", "pknew", "c__old", "data_fresh", "p_old", "data_New", " p_old", "c_old", "p__clean", "p__new", "p_create", "p__fresh", "pAMold", "p_New", "pockNew", "data_NEW", "p___new", " p_New", "c__new", "pAMnew", "p___old", "c__gen", "pkfresh", "pkNEW", " p__fresh", "c_new", "p_fresh", "dataockNew", "p_next", " p_NEW", "p__create", " p__old", "dataockNEW", "c__create", "c_gen", "p__next", "dataockfresh", "pkNew", "pockNEW", "p_clean", " p__next", " p_clean", "pockfresh", "p__data", " p_next", "c_create", "p___create", "p__gen", "pAMgen", " p__new", "pAMcreate"], "size": ["done", "shift", "scale", "code", "from", "external", "number", "name", "send", "capacity", "count", "exclusive", "owner", "data", "body", "depth", "small", "rate", "max", "push", "address", "cycle", "empty", "timeout", "sized", "last", "Size", "SIZE"]}}
{"project": "qemu", "commit_id": "6977afda16c1e09dfbce4bdd877459a287269b72", "target": 1, "func": "int kvmppc_reset_htab(int shift_hint)\n\n{\n\n    uint32_t shift = shift_hint;\n\n\n\n    if (!kvm_enabled()) {\n\n        /* Full emulation, tell caller to allocate htab itself */\n\n        return 0;\n\n    }\n\n    if (kvm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) {\n\n        int ret;\n\n        ret = kvm_vm_ioctl(kvm_state, KVM_PPC_ALLOCATE_HTAB, &shift);\n\n        if (ret == -ENOTTY) {\n\n            /* At least some versions of PR KVM advertise the\n\n             * capability, but don't implement the ioctl().  Oops.\n\n             * Return 0 so that we allocate the htab in qemu, as is\n\n             * correct for PR. */\n\n            return 0;\n\n        } else if (ret < 0) {\n\n            return ret;\n\n        }\n\n        return shift;\n\n    }\n\n\n\n    /* We have a kernel that predates the htab reset calls.  For PR\n\n     * KVM, we need to allocate the htab ourselves, for an HV KVM of\n\n     * this era, it has allocated a 16MB fixed size hash table already. */\n\n    if (kvmppc_is_pr(kvm_state)) {\n\n        /* PR - tell caller to allocate htab */\n\n        return 0;\n\n    } else {\n\n        /* HV - assume 16MB kernel allocated htab */\n\n        return 24;\n\n    }\n\n}\n", "idx": 1802, "substitutes": {"shift_hint": ["shift_shdr", "shift_hmint", "shift_hut", "shift_Hut", "shift_hmints", "shift_shint", "shift_Hbit", "shift_hmut", "shift_fdr", "shift_hints", "shift_hdr", "shift_fbit", "shift_Hdr", "shift_hbit", "shift_fints", "shift_hmdr", "shift_Hint", "shift_shints", "shift_Hints", "shift_fint", "shift_shut"], "ret": ["rep", "cat", "val", "git", "fail", "res", "bad", "value", "pat", "back", "r", "att", "pet", "rc", "rt", "active", "flag", "num", "alt", "RET", "ref", "mem", "det", "rev", "job", "red", "len", "hard", "reset", "lit", "success", "ext", "rets", "feat", "conn", "reply", "fun", "nt", "reg", "result", "arg", "Ret", "ft", "cur", "re", "out", "ct", "bit", "en", "art"]}}
{"project": "FFmpeg", "commit_id": "dc64f203a62083c3d5f81e8201018279c29581af", "target": 1, "func": "static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n\n                            AVPacket *avpkt) {\n\n    const uint8_t *buf = avpkt->data;\n\n\n    PTXContext * const s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    AVFrame * const p = &s->picture;\n\n    unsigned int offset, w, h, y, stride, bytes_per_pixel;\n\n    uint8_t *ptr;\n\n\n\n\n\n    offset          = AV_RL16(buf);\n\n    w               = AV_RL16(buf+8);\n\n    h               = AV_RL16(buf+10);\n\n    bytes_per_pixel = AV_RL16(buf+12) >> 3;\n\n\n\n    if (bytes_per_pixel != 2) {\n\n        av_log_ask_for_sample(avctx, \"Image format is not RGB15.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    avctx->pix_fmt = PIX_FMT_RGB555;\n\n\n\n    if (buf_end - buf < offset)\n\n\n    if (offset != 0x2c)\n\n        av_log_ask_for_sample(avctx, \"offset != 0x2c\\n\");\n\n\n\n    buf += offset;\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return -1;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    if (avctx->get_buffer(avctx, p) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    for (y=0; y<h; y++) {\n\n        if (buf_end - buf < w * bytes_per_pixel)\n\n            break;\n\n#if HAVE_BIGENDIAN\n\n        unsigned int x;\n\n        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)\n\n            AV_WN16(ptr+x, AV_RL16(buf+x));\n\n#else\n\n        memcpy(ptr, buf, w*bytes_per_pixel);\n\n#endif\n\n        ptr += stride;\n\n        buf += w*bytes_per_pixel;\n\n    }\n\n\n\n    *picture = s->picture;\n\n    *data_size = sizeof(AVPicture);\n\n\n\n    return offset + w*h*bytes_per_pixel;\n\n}", "idx": 1804, "substitutes": {"avctx": ["avetx", "avcu", "AVctx", "afxc", "avalctl", " avrc", "aircp", "avobj", "afconn", "afconnection", "akcn", "afctx", "averc", "afctrl", "avalcmd", "aveobj", "AVcontext", "avrc", "avctl", "avcontext", "avalcontext", "navcn", "afrc", "airctx", "avalconfig", "avecf", "afctl", "avconn", "avmac", "avalobj", "avectx", "avcli", "aftx", " avcontext", "avalctrl", "aircas", "avcmd", "afcas", "afcli", "avalctx", "akcrit", "akconn", " avcli", "avekb", "avtx", "navctx", "avcf", "avxc", "afcrit", "afkb", "ajxc", "avctrl", "avconfig", "afobj", "ajcontext", "akctrl", "avci", "afcmd", "navconn", "ajctx", "navcf", " avcu", "akctx", "avcp", "navcontext", "ajconfig", "avemac", "avalconnection", "avecontext", "akcontext", "avecas", "AVtx", "avcrit", "avalcli", "navcup", "afcp", "afcup", "ajcrit", "avcup", "afcf", " avconfig", "avconnection", "afcontext", "avcn", "afcn", "afcu", "akxc", "avkb", "aveconfig", " avci", "ajci", "avalmac", "aveconn", "akconnection", " avcup", "navcu", "aircontext", "AVkb", "afmac", "avecu", "avcas", "avalkb", "avectl", " avcmd", "avalcf", "afci", "afconfig", "avecp"], "data": ["draw", "media", "next", "val", "cache", "value", "database", "sample", "buff", "device", "Data", "binary", "header", "tmp", "background", "connection", "module", "input", "d", "config", "primary", "dat", "queue", "buffer", "memory", "load", "api", "slice", "pad", "frame", "pos", "window", "video", "parent", "length", "package", "batch", "pool", "body", "devices", "read", "start", "map", "result", "image", "channel", "style", "audio", "DATA", "meta", "proc", "f", "bin", "client", "align", "size", "open", "bytes", "reader", "pointer", "progress", "content", "index"], "data_size": ["datablocksize", "datablockscale", "data2size", "total_scale", "total_timeout", "data_scale", "datablocktimeout", "totalblockscale", "totalblocktimeout", "totalblockSize", "datablockSize", "data_timeout", "total_Size", "total_size", "data2scale", "data2timeout", "data_Size", "data2Size", "totalblocksize"], "avpkt": ["avPsth", "AVpkg", "avfpct", "avpnt", "avcpkw", "AVPct", "avcpkt", "avepnt", "avbpacket", "avpsth", "avebpacket", "avebpkt", "avepacket", "avpkw", "avebpkw", "avpromacket", "avpromkw", "avPct", "avppsth", "AVPsth", "avpkg", "avppkg", "avppct", "avfpkt", "avbpkt", "avcpacket", "AVPkg", "avepkt", "avfpkg", "avpct", "avpacket", "avepkw", "avPkg", "AVpsth", "avbpkw", "avPkt", "AVpct", "avpromnt", "avfpsth", "AVPkt", "AVpkt", "avcpnt", "avppkt", "avebpnt", "avbpnt", "avpromkt"], "buf": ["rb", "home", "text", "buff", "comb", "num", "ref", "usr", "ff", "v", "fd", "feat", "window", "block", "cb", "proc", "f", "wb", "coord", "ctr", "bc", "filename", "br", "aka", "um", "uu", "tmp", "bo", "config", "buffer", "plug", "cv", "dest", "prop", "port", "bag", "ru", "box", "b", "cas", "context", "ctx", "ab", "queue", "batch", "cmd", "cur", "uc", "path", "cat", "cache", "loc", "cf", "rc", "padding", "img", "header", "fp", "alloc", "src", "vec", "fb", "off", "func", "uf", "fw", "wav", "uint", "seq"], "s": ["S", "i", "fs", "sv", "r", "cs", "si", "j", "conf", "ssl", "o", "d", "m", "sq", "an", "slice", "v", "a", "services", "sys", "service", "g", "ps", "sf", "c", "np", "gs", "sym", "share", "t", "as", "sg", "f", "b", "space", "ss", "js", "e", "sky", "sk", "sup", "sync"], "picture": ["media", "family", "cache", "pkg", "detail", "gallery", "avi", "pb", "profile", "img", "fp", "gif", "config", "camera", "details", "obj", "photos", "buffer", "pic", "guide", "frame", "cp", "pict", "capt", "video", "photo", "game", "package", "Picture", "conference", "np", "plugin", "info", "jp", "vp", "image", "audio", "pocket", "meta", "gui", "feature", "summary", "png"], "p": ["i", "lp", "tp", "part", "pkg", "r", "pr", "mp", "bp", "patch", "l", "po", "pb", "j", "n", "o", "pl", "fp", "pd", "pt", "up", "d", "m", "per", "api", "wp", "pe", "v", "py", "a", "cp", "pc", "g", "sp", "ps", "pro", "port", "ap", "c", "pp", "pre", "np", "point", "vp", "jp", "pi", "P", "t", "proc", "b", "f", "op", "pa", "q", "dp", "u", "ip", "post", "e", "pointer"], "offset": ["i", "fff", "part", "buff", "hop", "num", "alias", "bound", "len", "reset", "position", "origin", "image", "rot", "f", "ffff", "o", " offsets", "append", "limit", "buffer", "et", "format", "pos", "adjust", "port", "b", "addr", "pointer", "shift", "Offset", "location", "aw", "slice", "pad", "length", "t", "address", "size", "index", "xff", "attribute", "loc", "padding", " padding", "fp", "af", "alpha", "api", "no", "off", "stop", "end", "a", "prefix", "type", "slot", "start", "usage", "align", "timeout", "entry"], "w": ["wx", "all", "wh", "d", "z", "win", "wp", "v", "wt", "weight", "max", "f", "wb", " W", "kw", "wa", "_", "l", "buffer", "pos", "b", "q", "u", "ow", "wd", "r", "ww", "sh", "m", "we", "aw", "g", "t", "size", "e", "wl", "sw", "img", "n", "height", "wo", "iw", "end", "type", "wal", "work", "fw", "c", "W", "ew", "hw"], "h": ["hi", "hm", "high", "wa", "r", "rh", "l", "hs", "hh", "n", "height", "sh", "o", "gh", "ht", "ha", "d", "m", "z", "k", "oh", "v", "uh", "ah", "g", "c", "ph", "hr", "he", "bh", "ih", "hd", "t", "b", "f", "u", "q", "e", "size", "hw", "H"], "y": ["hi", "wy", "i", "ny", "cy", "yl", "l", "hop", "ey", "j", "n", "height", "o", "yr", "yn", "key", "sy", "ya", "d", "m", "vy", "z", "yi", "Y", "dy", "k", "v", "py", "oy", "ye", "ym", "c", "ay", "gy", "ch", "yo", "col", "t", "b", "f", "u", "ady", "e", "ty", "yy"], "stride": ["STRipe", "Striden", "Stripe", "STRide", "STRider", "STRade", " strade", "STRiden", "Strade", "strade", " strided", " strision", "tride", " strider", "Stride", "trision", "trided", "strided", "striden", "trider", "stripe", " striden", "strider", "STRision", "strision", " stripe", "STRided"], "bytes_per_pixel": ["bytes_per_tile", "bytes_per_scale", "bytes_per_byte", "bytes_per\u00b7letter", "bytes_PER_letter", "bytes_Per_scale", "bytes_per\u00b7second", "bytes_per\u00b7pixel", "bytes_PER_second", "bytes_PER_channel", "bytes_Per_cell", "bytes_per\u00b7hour", "bytes_per_letter", "bytes_per\u00b7channel", "bytes_per\u00b7tile", "bytes_Per_pixel", "bytes_PER_pixel", "bytes_per_channel", "bytes_per_cell", "bytes_PER_byte", "bytes_per_hour", "bytes_per_second", "bytes_Per_byte", "bytes_per_chip"], "ptr": ["draw", "Ptr", "rect", "val", "buff", "pend", "attr", "loc", "req", "tr", "fi", "code", "img", "profile", "context", "ctx", "grad", "fp", "pt", "tmp", "alloc", "ref", "src", "dr", "tip", "obj", "buffer", "plug", "xp", "slice", "pad", "cv", "pos", "fd", "uf", "length", "port", "pair", "tx", "proc", "cur", "address", "addr", "ctr", "bc", "pointer", "br"], "x": ["xxx", "wa", "wx", "val", "i", "sw", "X", "ww", "l", "ex", "code", "num", "n", "xx", "rx", "key", "ct", "d", "m", "yx", "name", "z", "win", "xp", "px", "on", "v", "pos", "type", "xy", "work", "c", "ix", "image", "tx", "dx", "fx", "t", "max", "ax", "f", "u", "b", "e", "xi", "xs", "my", "index"]}}
{"project": "qemu", "commit_id": "97f1c45c6f456572e5b504b8614e4a69e23b8e3a", "target": 1, "func": "static void vpc_close(BlockDriverState *bs)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    g_free(s->pagetable);\n\n#ifdef CACHE\n\n    g_free(s->pageentry_u8);\n\n#endif\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n}\n", "idx": 1817, "substitutes": {"bs": ["rb", "fs", "ms", "bp", "BS", "ns", "cs", "pb", "bb", "cms", "ins", "blocks", "bt", "sa", "bos", "fb", "ba", "bi", "ps", "ses", "ks", "sb", "rs", "iss", "gb", "bh", "gs", "state", "vs", "b", "os", "ss", "ls", "bc", "lb", "ds"], "s": ["S", "ts", "ns", "cs", "si", "is", "ssl", "o", "qs", "south", "p", "d", "m", "sq", "session", "sa", "services", "a", "sys", "stats", "service", "g", "your", "states", "ps", "ses", "sb", "c", "rs", "es", "gs", "sym", "state", "t", "b", "sg", "f", "os", "aws", "ss", "js", "e", "sl", "ls", "bis", "http", "ds", "its", "sync", "xs"]}}
{"project": "qemu", "commit_id": "c88305027d5a8dbeaacf04ad2ceba79a5c5fb91e", "target": 1, "func": "POWERPC_FAMILY(POWER9)(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n\n\n    dc->fw_name = \"PowerPC,POWER9\";\n\n    dc->desc = \"POWER9\";\n\n    dc->props = powerpc_servercpu_properties;\n\n    pcc->pvr_match = ppc_pvr_match_power9;\n\n    pcc->pcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07;\n\n    pcc->pcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 |\n\n                         PCR_COMPAT_2_05;\n\n    pcc->init_proc = init_proc_POWER9;\n\n    pcc->check_pow = check_pow_nocheck;\n\n    cc->has_work = cpu_has_work_POWER9;\n\n    pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |\n\n                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |\n\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n\n                       PPC_FLOAT_FRSQRTES |\n\n                       PPC_FLOAT_STFIWX |\n\n                       PPC_FLOAT_EXT |\n\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n\n                       PPC_64B | PPC_64BX | PPC_ALTIVEC |\n\n                       PPC_SEGMENT_64B | PPC_SLBI |\n\n                       PPC_POPCNTB | PPC_POPCNTWD |\n\n                       PPC_CILDST;\n\n    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |\n\n                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |\n\n                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 |\n\n                        PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 |\n\n                        PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 |\n\n                        PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 |\n\n                        PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300;\n\n    pcc->msr_mask = (1ull << MSR_SF) |\n\n                    (1ull << MSR_TM) |\n\n                    (1ull << MSR_VR) |\n\n                    (1ull << MSR_VSX) |\n\n                    (1ull << MSR_EE) |\n\n                    (1ull << MSR_PR) |\n\n                    (1ull << MSR_FP) |\n\n                    (1ull << MSR_ME) |\n\n                    (1ull << MSR_FE0) |\n\n                    (1ull << MSR_SE) |\n\n                    (1ull << MSR_DE) |\n\n                    (1ull << MSR_FE1) |\n\n                    (1ull << MSR_IR) |\n\n                    (1ull << MSR_DR) |\n\n                    (1ull << MSR_PMM) |\n\n                    (1ull << MSR_RI) |\n\n                    (1ull << MSR_LE);\n\n    pcc->mmu_model = POWERPC_MMU_3_00;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc64_v3_handle_mmu_fault;\n\n    /* segment page size remain the same */\n\n    pcc->sps = &POWER7_POWER8_sps;\n\n    pcc->radix_page_info = &POWER9_radix_page_info;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_POWER8;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n\n                 POWERPC_FLAG_VSX | POWERPC_FLAG_TM;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x8000;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr;\n\n}\n", "idx": 1822, "substitutes": {"oc": ["soc", "oca", "mac", "loc", "ac", "ok", "rc", "fc", "enc", "o", "cca", "vc", "alloc", "exec", "isc", "xml", "ic", "ec", "oci", "config", "voc", "org", "PC", "tc", "unc", "oco", "pc", "roc", "co", "output", "c", "nc", "oid", "ob", "mc", "ucc", "toc", "OC", "inc", "doc", "bc", "uc", "anc"], "data": ["dd", "cache", "ac", "def", "device", "Data", "cca", "ci", "input", "d", "config", "raw", "dat", "load", "unc", "co", "parent", "di", "ee", "DATA", "doc", "da", "bc", "ds"], "dc": ["cu", "jc", "disc", "cf", "ac", "rc", "fc", "cca", "vc", "CC", "ec", "xc", "d", "cci", "acc", "DC", "design", "cdn", "df", "tc", "lc", "conn", "pc", "c", "dt", "nc", "di", "mc", "db", "doc", "da", "director", "bc", "uc", "cm", "cd"], "pcc": ["mcf", "Pca", "pbc", "apcf", "pci", "lcc", "lck", "Pcca", "apacc", " pco", "Puc", "ccc", "Ppc", "ppc", "cca", "apuc", "lacc", "muc", "Pcc", "puc", "cpacc", "apcc", " pca", "cCC", "pco", "cco", "macc", "cuc", "Pbc", "cci", " pCC", "cpcf", "pca", "Pco", "Pci", " puc", "PCC", " pbc", "pacc", " pck", "cbc", "pcf", "lcca", "cacc", "Pacc", "pck", "cpc", "ccca", "pCC", "cpuc", "cpcc", " pcf", " ppc", " pacc", "Pck", " pcca", "pcca", "mcc", "ccf", " pci"], "cc": ["jc", "cf", "ac", "rc", "cs", "cca", "vc", "CC", "ce", " gcc", "ec", "xc", "cci", "acc", "DC", "tc", "unc", "lc", "pc", "co", "ca", "c", "ctrl", "nc", "craft", "mc", "ucc", "ck", "WC", "bc", "client", "uc", "cm", "cd"]}}
{"project": "FFmpeg", "commit_id": "f028d4d1c393a13c66e828d45ba8412c0b4df6da", "target": 1, "func": "static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    KLVPacket klv;\n\n    int64_t essence_offset = 0;\n\n\n\n    mxf->last_forward_tell = INT64_MAX;\n\n\n\n    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find header partition pack key\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, -14, SEEK_CUR);\n\n    mxf->fc = s;\n\n    mxf->run_in = avio_tell(s->pb);\n\n\n\n    while (!s->pb->eof_reached) {\n\n        const MXFMetadataReadTableEntry *metadata;\n\n\n\n        if (klv_read_packet(&klv, s->pb) < 0) {\n\n            /* EOF - seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        PRINT_KEY(s, \"read header\", klv.key);\n\n        av_dlog(s, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n\n            if (!mxf->current_partition->essence_offset) {\n\n                compute_partition_essence_offset(s, mxf, &klv);\n\n            }\n\n\n\n            if (!essence_offset)\n\n                essence_offset = klv.offset;\n\n\n\n            /* seek to footer, previous partition or stop */\n\n            if (mxf_parse_handle_essence(mxf) <= 0)\n\n                break;\n\n            continue;\n\n        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&\n\n                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {\n\n            /* next partition pack - keep going, seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n        }\n\n\n\n        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n\n            if (IS_KLV_KEY(klv.key, metadata->key)) {\n\n                int res;\n\n                if (klv.key[5] == 0x53) {\n\n                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);\n\n                } else {\n\n                    uint64_t next = avio_tell(s->pb) + klv.length;\n\n                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n\n                    avio_seek(s->pb, next, SEEK_SET);\n\n                }\n\n                if (res < 0) {\n\n                    av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n\n                    return res;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (!metadata->read)\n\n            avio_skip(s->pb, klv.length);\n\n    }\n\n    /* FIXME avoid seek */\n\n    if (!essence_offset)  {\n\n        av_log(s, AV_LOG_ERROR, \"no essence\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, essence_offset, SEEK_SET);\n\n\n\n    mxf_compute_essence_containers(mxf);\n\n\n\n    return mxf_parse_structural_metadata(mxf);\n\n}\n", "idx": 1878, "substitutes": {"s": ["types", "sec", "conf", "sim", "d", "sa", "sci", "v", "ps", "sb", "sym", "os", "f", "space", "this", "js", "sv", "l", "si", "is", "qs", "o", "p", "ins", "se", "stats", "ses", "site", "b", "sg", "ops", "sup", "sync", "S", "support", "r", "sc", "cs", "ssl", "south", "m", "sq", "session", "service", "g", "us", "server", "spec", "es", "gs", "t", "native", "aws", "ss", "e", "ls", "http", "ds", "xs", "fs", "su", "sets", "ts", "ns", "n", "services", "sys", "sf", "c", "in", "self", "storage", "its", "client"], "ap": ["AP", "tp", "attr", "mp", "ac", "att", "pl", "arr", "api", "wp", "aps", "arp", "am", "cp", "py", "prop", "sp", "pro", "ps", "pp", "np", "map", "ams", "jp", "cap", "al", "as", "op"], "mxf": ["mcf", "Mxf", "mxc", " mxe", " mfx", "jxd", "mxd", "kxa", "Mxc", "cxd", " mcf", "fmxf", "hxd", "cxf", "dfx", "mfx", "cmcf", "fmxd", "fmcf", "kxe", "hxc", "cmxf", "dcf", "Mxd", "jcf", "dxe", "fmxc", "cxc", "cmxc", "Mfc", "Mxa", "jxc", " mxa", "hfx", "dxf", "Mxe", "mxe", "dfc", "jxf", "Mcf", "dxd", " mfc", "kcf", "mfc", "hxf", "cmxd", " mxd", "kxf", "mxa", " mxc", "ccf", "dxc"], "klv": [" kwl", "sklc", "kql", " kif", "ksll", "skvd", " kell", "ksdd", "kln", "okli", "arkwl", "skln", "Klf", "kvl", "skwl", "sknv", "kelv", "kvd", "klp", "riskwl", "Kln", "kelee", "oklf", " kvm", "aklev", "kewl", "mkla", "jql", "kslv", "Kli", "kva", "klan", "okwl", "kvc", "sklan", " kvc", "kslee", "cklc", "sklf", "cklf", " kvl", " klf", "Kla", " kla", "kicklee", "klee", "kdd", "oklv", "okvc", "klc", "akvm", "okva", "jlf", "Klan", " kdd", "skvc", "kla", "aklv", "kif", " kcol", "skif", "kll", "jwl", "klev", "Kql", "skql", "kickll", "risknv", "okvd", "keva", " klev", "Kwl", "knv", "Kvl", " klc", " kli", "jlv", "skcol", "Klc", " kln", "risklv", "kli", "skva", "sklev", "okcol", "kswl", "arkvd", "akell", "Klv", "kslly", "cklv", "kvm", "mklv", "skell", "skvm", "riskif", "kelly", "klly", "kslev", "kicklly", "sklv", "skdd", "ckwl", "oklc", "jlp", " klan", "kicklv", "kwl", " knv", "sklp", "ckvd", "kevd", "kell", "mkvl", "mklf", "Klp", "arklc", "klf", "arklv", "kcol"], "metadata": ["properties", "header", "tmp", "iterator", "ATA", "node", "m", "session", "details", "met", "ma", "definition", "stream", "ata", "data", "member", "description", "package", "shared", "parser", "info", "meta", "adata", "json", "summary", "message", "entry", "filename"]}}
{"project": "FFmpeg", "commit_id": "1577526b47439f33a999339efdec5d624b70e1da", "target": 1, "func": "static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n    opj_image_cmptparm_t cmptparm[4] = {{0}};\n    opj_image_t *img;\n    int i;\n    int sub_dx[4];\n    int sub_dy[4];\n    int numcomps;\n    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;\n    sub_dx[0] = sub_dx[3] = 1;\n    sub_dy[0] = sub_dy[3] = 1;\n    sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w;\n    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;\n    numcomps = desc->nb_components;\n    switch (avctx->pix_fmt) {\n    case AV_PIX_FMT_GRAY8:\n    case AV_PIX_FMT_YA8:\n    case AV_PIX_FMT_GRAY16:\n    case AV_PIX_FMT_YA16:\n        color_space = CLRSPC_GRAY;\n        break;\n    case AV_PIX_FMT_RGB24:\n    case AV_PIX_FMT_RGBA:\n    case AV_PIX_FMT_RGB48:\n    case AV_PIX_FMT_RGBA64:\n    case AV_PIX_FMT_GBR24P:\n    case AV_PIX_FMT_GBRP9:\n    case AV_PIX_FMT_GBRP10:\n    case AV_PIX_FMT_GBRP12:\n    case AV_PIX_FMT_GBRP14:\n    case AV_PIX_FMT_GBRP16:\n    case AV_PIX_FMT_XYZ12:\n        color_space = CLRSPC_SRGB;\n        break;\n    case AV_PIX_FMT_YUV410P:\n    case AV_PIX_FMT_YUV411P:\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUV422P:\n    case AV_PIX_FMT_YUV440P:\n    case AV_PIX_FMT_YUV444P:\n    case AV_PIX_FMT_YUVA420P:\n    case AV_PIX_FMT_YUVA422P:\n    case AV_PIX_FMT_YUVA444P:\n    case AV_PIX_FMT_YUV420P9:\n    case AV_PIX_FMT_YUV422P9:\n    case AV_PIX_FMT_YUV444P9:\n    case AV_PIX_FMT_YUVA420P9:\n    case AV_PIX_FMT_YUVA422P9:\n    case AV_PIX_FMT_YUVA444P9:\n    case AV_PIX_FMT_YUV420P10:\n    case AV_PIX_FMT_YUV422P10:\n    case AV_PIX_FMT_YUV444P10:\n    case AV_PIX_FMT_YUVA420P10:\n    case AV_PIX_FMT_YUVA422P10:\n    case AV_PIX_FMT_YUVA444P10:\n    case AV_PIX_FMT_YUV420P12:\n    case AV_PIX_FMT_YUV422P12:\n    case AV_PIX_FMT_YUV444P12:\n    case AV_PIX_FMT_YUV420P14:\n    case AV_PIX_FMT_YUV422P14:\n    case AV_PIX_FMT_YUV444P14:\n    case AV_PIX_FMT_YUV420P16:\n    case AV_PIX_FMT_YUV422P16:\n    case AV_PIX_FMT_YUV444P16:\n    case AV_PIX_FMT_YUVA420P16:\n    case AV_PIX_FMT_YUVA422P16:\n    case AV_PIX_FMT_YUVA444P16:\n        color_space = CLRSPC_SYCC;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR,\n               \"The requested pixel format '%s' is not supported\\n\",\n               av_get_pix_fmt_name(avctx->pix_fmt));\n    }\n    for (i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;\n        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx = sub_dx[i];\n        cmptparm[i].dy = sub_dy[i];\n        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];\n        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];\n    }\n    img = opj_image_create(numcomps, cmptparm, color_space);\n    // x0, y0 is the top left corner of the image\n    // x1, y1 is the width, height of the reference grid\n    img->x0 = 0;\n    img->y0 = 0;\n    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;\n    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;\n    return img;\n}", "idx": 1883, "substitutes": {"avctx": ["afpkg", "afcontext", "afsci", "AVpkg", "avconn", "AVctx", "avectx", "camctx", "Avctx", "afcca", "avcmp", "avecca", "avsci", "Avcontext", "avpkg", "akctx", "aveconn", "camcontext", "afconn", "akpkg", "camcca", "afcmp", "afctx", "avecontext", "akcontext", "akcmp", "camconn", "AVcontext", "avcontext", "avesci", "Avsci", "AVcmp", "avcca", "Avconn"], "parameters": ["paramsParameters", "paramParameters", "configparams", "paramseters", "ramparams", "configParameters", "rameters", "configeters", "paramparams", "paramsparams", "ramParameters"], "desc": ["comment", "dep", "dist", "pri", "dc", "diff", "neg", "text", "req", "decl", "loc", "des", "sc", "def", "sub", "de", "enc", "sec", "dir", "ec", "adr", "d", "config", "Desc", "name", "reci", "dim", "df", "asc", "rec", "esc", "conn", "ext", "ca", "dest", "description", "Description", "info", "dev", "der", "doc", "summary", "design"], "cmptparm": ["cmptpparm", "cmptppore", "cmppfore", "cmptfair", "cmppfair", "cmppfarm", "cmptppair", "cmptbarm", "cmptpore", "cmptbair", "cmpppare", "cmptpair", "cmpppore", "cmptpare", "cmppfare", "cmptbare", "cmptfare", "cmptbore", "cmptfarm", "cmppparm", "cmptfore", "cmptppare", "cmpppair"], "img": ["picture", "im", "transform", "imp", "aff", "tmp", "cube", "src", "bg", "iframe", "ff", "crop", "obj", "buf", "norm", "orig", "ii", "app", "gd", "cb", "ng", "amp", "iv", "fig", "sup", "tif", "br"], "i": ["ui", "io", "r", "l", "j", "n", "pixel", "p", "ci", "qi", "d", "cli", "ii", "v", "bi", "iu", "c", "pi", "t", "b", "f", "u", "ti", "ip", "e", "xi", "I", "s"], "sub_dx": ["sub__eddy", "sub__dx", "Sub_ded", "sub__dy", "Sub_dc", "sub__ded", "sub_ded", "Sub_dx", "sub__dc", "sub_ds", "sub_dj", "Sub_du", " sub_wd", "sub_eddy", "Sub_dy", " sub_dj", "sub_dq", " sub_eddy", " sub_dq", "sub_coe", "sub_du", "Sub_ds", "sub_dc", "sub_wd", " sub_coe", " sub_du", "sub__wd"], "sub_dy": ["sub__eddy", "sub_der", "Sub_idd", "sub__dx", "sub2dy", "sub_dt", "sub__d", "sub__dy", "Sub_dj", "sub_idd", "sub2dj", "Sub_die", "sub2done", " sub_d", "Sub_di", "Sub_dx", "sub__y", "Sub_der", "sub_die", "sub_done", "sub__dt", "sub2dx", "sub_dj", "sub_y", "sub_eddy", "Sub_dy", " sub_eddy", " sub_y", "sub_di", "sub_d", " sub_dt", "Sub_done"], "numcomps": ["ncomples", "numcompples", "numcompPS", "nbcompples", "numcompos", "numcomponents", "numComples", "ncompples", "numqupos", "numComps", "numcomPS", "ncomponents", "nbcompos", "ncompos", "ncomps", "nbcomppos", "numComPS", "numcompps", "ncomppos", "ncompps", "nbcompps", "numcomppos", "numquples", "nbcompPS", "numproples", "numcomples", "nbcomples", "ncomonents", "numqups", "numComonents", "numcomonents", "nbcomps", "numquonents", "numCompos", "numpropos", "numprops", "nbcomPS", "numproPS"]}}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static int xen_platform_initfn(PCIDevice *dev)\n\n{\n\n    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    pci_conf = d->pci_dev.config;\n\n\n\n    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n\n\n\n    pci_config_set_prog_interface(pci_conf, 0);\n\n\n\n    pci_conf[PCI_INTERRUPT_PIN] = 1;\n\n\n\n    pci_register_bar(&d->pci_dev, 0, 0x100,\n\n            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);\n\n\n\n    /* reserve 16MB mmio address for share memory*/\n\n    pci_register_bar(&d->pci_dev, 1, 0x1000000,\n\n            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);\n\n\n\n    platform_fixed_ioport_init(d);\n\n\n\n    return 0;\n\n}\n", "idx": 1894, "substitutes": {"dev": ["driver", "gu", "mod", "diff", "bug", "priv", "error", "device", "def", "grad", "conf", "ve", "debug", "DEV", "var", "cam", " priv", "prom", " Dev", "end", "conn", "data", "development", "Dev", "app", "info", " device", "dem", "der", "develop", "ver", "rad", "ev", "dom"], "d": ["md", "dd", "dad", "i", "dc", "done", "r", "l", "ded", "j", "n", "bd", "dl", "dj", "p", "pd", "nd", "dm", "ind", "m", "config", "dat", "z", "id", "w", "ad", "dy", "dom", "ld", "D", "fd", "g", "dn", "c", "dt", "gd", "dh", "dx", "dict", "t", "db", "b", "f", "sd", "u", "dp", "e", "ds", "s", "cd"], "pci_conf": ["pci_conn", "pci_dev", "pcu_config", "pct_conf", "pci_config", "pcm_conf", "pci_spec", "pcu_con", "pki_Conf", "pct_dev", "pcm_config", "pdi_Conf", "pci_Conf", "pcu_conn", "pcu_conf", "pdi_conf", "pct_conn", "pct_config", "pki_config", "pci_con", "pcm_spec", "pki_conf", "pcm_conn", "pki_dev", "pdi_con"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,\n\n                         V9fsPath *dir_path, const char *name, FsCred *credp)\n\n{\n\n    int retval;\n\n    V9fsString fullname, target;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_init(&target);\n\n\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    v9fs_string_sprintf(&target, \"%s\", oldpath);\n\n\n\n    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, \"ssdd\",\n\n                          &target, &fullname, credp->fc_uid, credp->fc_gid);\n\n    v9fs_string_free(&fullname);\n\n    v9fs_string_free(&target);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n        retval = -1;\n\n    }\n\n    return retval;\n\n}\n", "idx": 1896, "substitutes": {"fs_ctx": ["flow_cmp", "flowadectx", "flowadecmp", "f_ctx", "flowadecontext", "fs_cmp", "flow_req", "fs_req", "fs_conn", "f_conn", "flowadereq", "fsadecontext", "f_cas", "fsadereq", "fs_context", "flow_ctx", "fsadectx", "flow_context", "f_context", "fsadecmp", "fs_cas"], "oldpath": ["Oldlink", "Olddest", " oldath", "OLDlink", "oldath", "Oldpath", "oldurl", "oldpointer", "Oldath", " oldlink", "olddest", "olderlink", "olderurl", "OLDpath", "olderdest", "oldlink", " oldpointer", "olderpointer", "OLDpointer", "olderath", "olderpath", " oldurl", " olddest", "OLDurl"], "dir_path": [" dir_context", "dir_context", "dir___pointer", "dir_info", " dir_pointer", " dir_info", "dir_ath", " dir2context", " dir_ctx", "dir2pointer", "dir___context", " dir2ath", "dir___ath", " dir_ath", " dir2path", "dir2path", " dir2pointer", "dir2ath", "dir_ctx", "dir2context", "dir___path", "dir_pointer"], "name": ["host", "base", "password", "content", "domain", "filename", "n", "key", "Name", "alias", "root", "node", "new", "names", "nam", "word", "acl", "time", "prefix", "missing", "type", "ext", "data", "member", "description", "parent", "url", "image", "none", "version", "NAME", "address", "size", "pass", "path", "source"], "credp": ["ecredf", "credpi", "crdpo", " creedp", "creedpa", "credpo", " credc", " cprivs", "cprivpc", "cldf", "cldp", "ecredp", "cprivc", "ecldf", "crdpa", " credpo", "cprivf", " credpc", " cprivc", " cprivpc", "ecreds", " creedpa", "creams", "crdp", "crcp", " creds", " creedpo", " credpi", "credf", "credpa", "credc", "ecredc", " cprivp", "eclds", "creedpo", "creedpi", " creedpi", "cldc", "cprivp", "crcpa", "clds", "creamc", " credpa", "credpc", "creampc", "creds", "creedp", "crcpo", "crdpi", "ecldc", "crcpi", "ecldp", "creamp", "cprivs"], "retval": [" retvalid", "refVal", "intv", "altvalid", "returnVAL", "reVAL", "retint", "refval", "altVal", "altint", "returnval", " retVAL", "ntvalid", "rtval", "returnVal", "RetVal", " retVal", " reteval", "retcol", "refv", "returnvalue", "alteval", "intval", "intVal", "refvalid", "retv", "rev", "reval", "reeval", "returnv", "retVAL", "rtvalid", " retcol", "retvalid", "ntval", "altv", "rtcol", " retint", "Retv", "ntVal", "Retvalue", " retvalue", "rtVal", "refcol", "Retval", "altVAL", "RetVAL", " retv", "retvalue", "retVal", "intvalue", "altval", "ntint", "refvalue", "reteval"], "fullname": ["fullcap", "fulspan", "Fullpart", " fullName", "fullyline", "fullline", "longtext", " fullpath", "shortname", "fulpath", "longname", "fullypart", "completenamed", "fullpath", "fulName", "FullName", "fulcap", "longName", "longline", "fulname", "completename", "fuln", "fulpart", "fulln", "shortName", "completeline", "fullytext", "Fullspan", "longcap", "fullyName", "fullyspan", "fultext", "fullpart", "fullnamed", "fullName", "fullspan", "longnamed", "fullycap", "fulltext", "Fullname", " fullcap", "fullyname", "fullynamed", "shortpath", "shortn", " fulln"], "target": ["host", "cat", "next", "protected", "Target", "value", "text", "transform", "base", "password", "content", "project", "null", "pattern", "alias", "root", "token", "id", "source", "route", "method", "reset", "platform", "label", "arget", "format", "prefix", "type", "dest", "data", "owner", "front", "eth", "parent", "top", "template", "output", "secret", "url", "shadow", "task", "result", "wrong", "channel", "subject", "effect", "range", "address", "resource", "component", "prop", "net", "client", "pointer", "goal", "tag", "path", "filename"]}}
{"project": "qemu", "commit_id": "ea486926b07d2ebd73ef67315ebb1eecf39faf5a", "target": 0, "func": "static int vfio_enable_intx(VFIODevice *vdev)\n\n{\n\n    VFIOIRQSetFD irq_set_fd = {\n\n        .irq_set = {\n\n            .argsz = sizeof(irq_set_fd),\n\n            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,\n\n            .index = VFIO_PCI_INTX_IRQ_INDEX,\n\n            .start = 0,\n\n            .count = 1,\n\n        },\n\n    };\n\n    uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);\n\n    int ret;\n\n\n\n    if (vdev->intx.disabled || !pin) {\n\n        return 0;\n\n    }\n\n\n\n    vfio_disable_interrupts(vdev);\n\n\n\n    vdev->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */\n\n    ret = event_notifier_init(&vdev->intx.interrupt, 0);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: event_notifier_init failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt);\n\n    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev);\n\n\n\n    if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {\n\n        error_report(\"vfio: Error: Failed to setup INTx fd: %m\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    /*\n\n     * Disable mmaps so we can trap on BAR accesses.  We interpret any\n\n     * access as a response to an interrupt and unmask the physical\n\n     * device.  The device will re-assert if the interrupt is still\n\n     * pending.  We'll likely retrigger on the host multiple times per\n\n     * guest interrupt, but without EOI notification it's better than\n\n     * nothing.  Acceleration paths through KVM will avoid this.\n\n     */\n\n    vfio_mmap_set_enabled(vdev, false);\n\n\n\n    vdev->interrupt = VFIO_INT_INTx;\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", __func__, vdev->host.domain,\n\n            vdev->host.bus, vdev->host.slot, vdev->host.function);\n\n\n\n    return 0;\n\n}\n", "idx": 1900, "substitutes": {"vdev": ["nvdevelopment", "Vdef", "lgr", "etdie", "svdi", "pdev", "wdc", "vdie", " vdi", " vdef", "gev", "zdie", "verver", "vvdom", "evdi", "Vdc", "vhost", "verdev", "hdevelopment", "ldef", "vdd", "pserv", " vserv", "svapp", "nvrad", "svdef", "vserv", "pev", "zdev", "wdevice", "ethost", "vdevelopment", "pdef", "Vver", "vmdev", "evdie", "gdevice", "pdevice", "pdie", "vvdev", "vgr", "Vvar", "vev", "Vdie", " vver", "vmvar", "pdiff", "lev", "Vdevice", "vvdie", "zvar", " vdie", "vdi", "wserv", " vev", "evev", "evdef", "wconn", " vconn", "ldd", "evdev", "cdevice", "wdev", "ldiff", " vdc", "wdiff", " vdiff", "vdc", "nvev", "evconn", "etdev", "svdev", "hrad", "lconn", "verdie", "vver", "zver", "hev", "vapp", "vvar", "pdc", "vdom", "wev", "wdie", "uvev", "etver", "cdom", "svconn", "nvdev", "vdiv", "cdev", "vrad", "uvrad", "evdevice", " vhost", "ldevice", "cdie", "ldev", "ggr", "vvapp", "Vdev", "svrad", "evapp", "vconn", "gdev", "cev", "Vdiff", "wvar", " vgr", "verhost", "vvdevice", "svdd", "vmdevice", " vdiv", "svdie", "svdevice", "Vconn", "vdiff", "vdef", "uvdev", "wdom", "vdevice", "prad", "hdev", "vvev", "uvdevelopment", " vdevice", "crad", "wdiv", "Vdd", " vvar", "vmconn"], "ret": ["rep", "val", "fail", "res", "bad", "pat", "back", " RET", "r", "error", "match", "pet", "rc", "fab", "rt", "flag", " Ret", "num", "alt", "fin", "RET", "ref", "det", "pin", "rev", "rf", "id", "red", "len", "irm", "reset", "lit", "py", "repl", "success", "rets", "reply", "ry", "fun", "nt", "reg", "result", "get", "arg", "Ret", "std", "err", "re", "try"]}}
{"project": "qemu", "commit_id": "fc89efe693278c79273f3bbf6b581e8a749c85b0", "target": 0, "func": "void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)\n\n{\n\n    int i = 0;\n\n    int x = 0;\n\n    uint32_t l_64 = (l + 1) / 8;\n\n\n\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n\n               __func__, l, dest, src);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if ((l > 32) &&\n\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n\n        if (dest == (src + 1)) {\n\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n\n            return;\n\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n\n            mvc_fast_memmove(env, l + 1, dest, src);\n\n            return;\n\n        }\n\n    }\n\n#else\n\n    if (dest == (src + 1)) {\n\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n\n        return;\n\n    /* mvc and memmove do not behave the same when areas overlap! */\n\n    } else if ((dest < src) || (src + l < dest)) {\n\n        memmove(g2h(dest), g2h(src), l + 1);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    /* handle the parts that fit into 8-byte loads/stores */\n\n    if ((dest + 8 <= src) || (src + 8 <= dest)) {\n\n        for (i = 0; i < l_64; i++) {\n\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n\n            x += 8;\n\n        }\n\n    }\n\n\n\n    /* slow version with byte accesses which always work */\n\n    for (i = x; i <= l; i++) {\n\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n\n    }\n\n}\n", "idx": 1902, "substitutes": {"env": ["dep", "tern", "worker", "equ", "her", "context", "enc", "gear", "eye", "ctx", "er", "eu", "opt", "ep", "exec", "ec", "viron", "eni", "config", "queue", "dat", "buf", "vm", " environment", "engine", "qa", "eve", "cdn", "fen", "esi", "v", "end", "here", "inet", "conn", "ah", "el", "erv", "console", "ea", "ev", "ench", "enh", "eh", "app", "export", "eng", "np", "dt", "nc", "init", "exc", "info", "atten", "state", "style", "kn", "dict", "db", "que", "dev", "err", "e", "environment", "iv", "net", "esp", "priv", "fg", "en", "Environment"], "l": ["line", "lp", "loc", "r", "lu", "j", "n", "dl", "o", "jl", "pl", "L", "p", "lin", "lang", "y", "fl", "le", "isl", "d", "z", "ln", "ol", "k", "len", "lit", "v", "ul", "el", "li", "g", "ell", "list", "length", "il", "c", "url", "ll", "kl", "la", "nl", "al", "t", "b", "rl", "f", "u", "e", "sl", "ls", "x", "lb", "wl", "h", "lc", "s", "source"], "dest": ["dep", "dist", "home", "diff", "text", "decl", "comb", "ord", "temp", "wh", "opt", "usr", "d", "vision", "head", "bound", "lit", "v", "feat", "future", "origin", "proc", "dev", "wb", "coord", "cont", "host", "done", "inst", "secure", "de", "null", "st", "tmp", "fl", "config", "name", "route", "cdn", "destroy", "data", "prop", "url", "now", "seed", "vert", "again", "slave", "sup", "priv", "lc", "wd", "ident", "transform", "shift", "sc", "gen", "dir", "new", "location", "session", "slice", "trans", "gz", "front", "txt", "Dest", "size", "uc", "later", "path", "source", "desc", "uv", "dc", "back", "loc", "attr", "rc", "img", "pl", "other", "rest", "class", "end", "du", "direction", "target", "di", "start", "resource", "en"], "src": ["gl", "dist", "view", "rb", "text", "sub", "uri", "sec", "alt", "sel", "lib", "vision", "send", "access", "win", "sn", "download", "ruby", "lit", "feat", "sb", "ch", "cb", "proc", "iv", "pull", "s", "filename", "inst", "sort", "sr", "sit", "obl", "null", "st", "remote", "config", "route", "hl", "ul", "url", "RC", "nil", "b", "rob", "username", "sup", "sync", "r", "sc", "ssl", "sh", "stack", "slice", "gn", "stream", "gz", "front", "length", "ources", "server", "us", "cur", "sl", "uc", "source", "desc", "uv", "sur", "back", "loc", "rc", "img", "low", "pl", "rest", "connect", "rib", "c", "ource", "target", "start", "gb", "rl", "resource", "uint"], "i": ["hi", "ui", "im", "io", "r", "fi", "si", "is", "j", "n", "y", "o", "L", "p", "ci", "qi", "ind", "d", "m", "z", "mi", "I", "id", "w", "ri", "ini", "ii", "v", "bi", "li", "ie", "iu", "ji", "c", "in", "di", "ix", "ai", "pi", "b", "f", "u", "gi", "ti", "ip", "ni", "e", "xi", "x", "it", "yi", "index", "h"]}}
{"project": "qemu", "commit_id": "ba0e276db4b51bd2255a5d5ff8902c70d32ade40", "target": 0, "func": "void helper_store_fpcr (uint64_t val)\n\n{\n\n#ifdef CONFIG_SOFTFLOAT\n\n    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);\n\n#endif\n\n    switch ((val >> 58) & 3) {\n\n    case 0:\n\n        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);\n\n        break;\n\n    case 1:\n\n        set_float_rounding_mode(float_round_down, &FP_STATUS);\n\n        break;\n\n    case 2:\n\n        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);\n\n        break;\n\n    case 3:\n\n        set_float_rounding_mode(float_round_up, &FP_STATUS);\n\n        break;\n\n    }\n\n}\n", "idx": 1905, "substitutes": {"val": ["eval", "value", "base", "def", "num", "sel", "p", "pt", "Val", "valid", "ref", "key", "d", "Value", "ret", "buf", "ol", "vol", "count", "v", "ut", "py", "el", "data", "slot", "vals", "gold", "lv", "gb", "pol", "vert", "VAL", "al", "arg", "db", "b", "f", "ver", "serv", "sl", "x", "bit"]}}
{"project": "qemu", "commit_id": "ee9a569ab88edd0755402aaf31ec0c69decf7756", "target": 0, "func": "void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)\n\n{\n\n    tcet->bypass = bypass;\n\n}\n", "idx": 1909, "substitutes": {"tcet": ["tget", " tcen", "cuet", "pcen", "TCet", "cuET", "tgacket", "tmet", "TCen", "cuen", "tcable", "tgen", "TCET", "tcacket", "tmable", "tgET", " tcacket", "pcET", "tmET", "tcET", "tcen", "TCable", "pcet", " tcET", "tmen", "cuable", "pcacket"], "bypass": [" byfill", "BYride", "samePass", " byrupt", "bytePass", " byread", "ByPass", "ByPASS", "BYPass", "perfill", "Bypass", "byfill", "perpass", "byride", "byPASS", "byterupt", "perPass", "perread", "BYPASS", " byPass", "byPass", "bytePASS", "viafill", " byPASS", "BYpass", "bytepass", "samePASS", "byrupt", "Byrupt", "viaread", "byread", " byride", "sameride", "samepass", "viapass", "viaPass"]}}
{"project": "qemu", "commit_id": "9abc62f6445795522d1bf5bf17f642e44eaf032d", "target": 0, "func": "void qemu_system_wakeup_request(WakeupReason reason)\n\n{\n\n    if (!is_suspended) {\n\n        return;\n\n    }\n\n    if (!(wakeup_reason_mask & (1 << reason))) {\n\n        return;\n\n    }\n\n    runstate_set(RUN_STATE_RUNNING);\n\n    monitor_protocol_event(QEVENT_WAKEUP, NULL);\n\n    notifier_list_notify(&wakeup_notifiers, &reason);\n\n    reset_requested = 1;\n\n    qemu_notify_event();\n\n    is_suspended = false;\n\n}\n", "idx": 1917, "substitutes": {"reason": ["comment", "cause", "cond", "error", "cmp", "code", "unit", "num", "resp", "monitor", "null", "sec", "index", "race", "group", "write", "byte", "category", "number", "connection", "session", "name", "status", "notice", "source", "method", "charge", "event", "change", "year", "type", "data", "Reason", "description", "request", "exc", "result", "warning", "rule", "process", "crit", "subject", "response", "err", "effect", "issue", "component", "re", "cycle", "condition", "message", "second", "record", "report", "ception"]}}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static int rtsp_listen(AVFormatContext *s)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    char proto[128], host[128], path[512], auth[128];\n\n    char uri[500];\n\n    int port;\n\n    int default_port = RTSP_DEFAULT_PORT;\n\n    char tcpname[500];\n\n    const char *lower_proto = \"tcp\";\n\n    unsigned char rbuf[4096];\n\n    unsigned char method[10];\n\n    int rbuflen = 0;\n\n    int ret;\n\n    enum RTSPMethod methodcode;\n\n\n\n    if (!rt->protocols) {\n\n        rt->protocols = ffurl_get_protocols(NULL, NULL);\n\n        if (!rt->protocols)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    /* extract hostname and port */\n\n    av_url_split(proto, sizeof(proto), auth, sizeof(auth), host, sizeof(host),\n\n                 &port, path, sizeof(path), s->filename);\n\n\n\n    /* ff_url_join. No authorization by now (NULL) */\n\n    ff_url_join(rt->control_uri, sizeof(rt->control_uri), proto, NULL, host,\n\n                port, \"%s\", path);\n\n\n\n    if (!strcmp(proto, \"rtsps\")) {\n\n        lower_proto  = \"tls\";\n\n        default_port = RTSPS_DEFAULT_PORT;\n\n    }\n\n\n\n    if (port < 0)\n\n        port = default_port;\n\n\n\n    /* Create TCP connection */\n\n    ff_url_join(tcpname, sizeof(tcpname), lower_proto, NULL, host, port,\n\n                \"?listen&listen_timeout=%d\", rt->initial_timeout * 1000);\n\n\n\n    if (ret = ffurl_open(&rt->rtsp_hd, tcpname, AVIO_FLAG_READ_WRITE,\n\n                         &s->interrupt_callback, NULL, rt->protocols)) {\n\n        av_log(s, AV_LOG_ERROR, \"Unable to open RTSP for listening\\n\");\n\n        return ret;\n\n    }\n\n    rt->state       = RTSP_STATE_IDLE;\n\n    rt->rtsp_hd_out = rt->rtsp_hd;\n\n    for (;;) { /* Wait for incoming RTSP messages */\n\n        ret = read_line(s, rbuf, sizeof(rbuf), &rbuflen);\n\n        if (ret < 0)\n\n            return ret;\n\n        ret = parse_command_line(s, rbuf, rbuflen, uri, sizeof(uri), method,\n\n                                 sizeof(method), &methodcode);\n\n        if (ret) {\n\n            av_log(s, AV_LOG_ERROR, \"RTSP: Unexpected Command\\n\");\n\n            return ret;\n\n        }\n\n\n\n        if (methodcode == ANNOUNCE) {\n\n            ret       = rtsp_read_announce(s);\n\n            rt->state = RTSP_STATE_PAUSED;\n\n        } else if (methodcode == OPTIONS) {\n\n            ret = rtsp_read_options(s);\n\n        } else if (methodcode == RECORD) {\n\n            ret = rtsp_read_record(s);\n\n            if (!ret)\n\n                return 0; // We are ready for streaming\n\n        } else if (methodcode == SETUP)\n\n            ret = rtsp_read_setup(s, host, uri);\n\n        if (ret) {\n\n            ffurl_close(rt->rtsp_hd);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 1937, "substitutes": {"s": ["S", "fs", "serv", "r", "sv", "su", "sets", "ts", "ns", "settings", "cs", "si", "n", "sec", "ssl", "o", "conf", "south", "p", "qs", "http", "src", "d", "details", "sq", "session", "ions", "sa", "v", "services", "a", "sys", "ant", "service", "g", "txt", "us", "server", "ses", "sf", "spec", "c", "rs", "sb", "site", "params", "es", "gs", "sym", "args", "t", "b", "sg", "f", "storage", "op", "os", "aws", "client", "ss", "js", "e", "sl", "ls", "bis", "ops", "ds", "its", "sync", "xs", "request"], "rt": ["fr", "rect", "rb", "rr", "vt", "r", "rh", "BT", "att", "irt", "rc", "tr", "tt", "pt", "ht", "nd", "adr", "dr", "gt", "ott", "dat", "rf", "ut", "vr", "RT", "rat", "ant", "rd", "mt", "MT", "td", "yt", "nt", "rs", "dt", "apt", "ot", "xt", "gd", "ru", "OT", "kt", "rn", "boot", "urt", "rot", "tx", "NT", "t", "rl", "ft", "RS", "rob", "ct", "it", "qt", "bt", "art", "ort"], "proto": ["produpos", "protpo", " propo", "produbo", "roo", "peb", "prodo", "prebo", "probo", "propo", "protto", "roocol", " proname", "propos", "Propo", "prob", "pedo", "ropo", "proo", "protocol", "Prodo", "preto", "protbo", "prepos", " prob", "proocol", "Proocol", "Proname", " proocol", "peocol", "Proo", "Proto", "protpos", "produto", "peto", "preocol", "produpo", "prename", "protdo", "prepo", " prodo", "protb", "proname", "roto"], "host": ["driver", "user", "home", "database", "socket", "password", "mac", "domain", "hop", "context", "object", "header", "dir", "Host", "pattern", "act", "node", "input", "config", "proxy", "name", "id", "graph", "connect", "file", "type", "service", "parent", "server", "ith", "url", "arch", "target", "subject", "localhost", "ip", "address", "component", "addr", "username", "condition", "http", "h", "source"], "path": ["user", "home", "text", "PATH", "password", "loc", "context", "filename", "dir", "pattern", "p", "key", "location", "node", "ath", "raw", "config", "name", "id", "limit", "source", "route", "prefix", "file", "type", "prop", "data", "ith", "url", "test", "Path", "image", "col", "subject", "component", "resource", "http", "h", "content", "request"], "auth": ["wd", "home", "uth", "mac", "error", "ac", "private", "authent", "enc", "array", "ssl", "opt", "act", "ath", "config", "acl", "token", "id", "UTH", "account", "conn", "type", "data", "Auth", "eth", "afi", "anon", "crypt", "ith", "url", "arch", "info", "cmd", "ip", "address", "pass", "username", "http", "thin", "priv", "password", "author", "h"], "uri": ["line", "i", "ui", "base", "loc", "io", " URI", "prot", "unit", "dir", "src", "uni", "remote", "href", "cli", "config", "iri", "source", "api", "id", "ri", "route", "format", "prefix", "file", " url", "description", "url", "pi", "URI", " ur", "storage", "ip", "address", "resource", "timeout", "uid", "http", "username", "filename"], "port": ["user", "Port", "offset", "ports", "value", "PORT", "part", "password", "select", "patch", "hop", "match", " transport", "alt", "pt", "p", "key", "number", "config", "proxy", "name", "limit", "pid", "id", "time", "ort", "import", "slice", "count", "phone", "pos", "type", "allow", "service", "prop", "position", "length", "server", "duration", "url", "direction", "test", "target", "start", "rule", "pi", "version", "ip", "address", "component", "page", "size", "timeout", "pass", "http", "use", "index"], "tcpname": [" tcpsize", "tworkni", "tcpnam", "Tmpresource", "tmpname", "tpni", "tmpresource", "tfpresource", "TcpName", "tmpsize", "tcppath", "tfpnam", "Tmppath", "tcpName", "Tcpni", " tworkname", " tworkni", "tmpName", " tmpsize", "tpName", "Tmpname", "tipname", "tfpni", "tppName", "tpsize", "tcpNAME", "tmppath", " tcpnam", "Tcpresource", "TcpNAME", "tmpni", " tmpname", "tcpsize", "tfppath", "tcpresource", "tppsize", "tcapname", "tpname", "tipName", "TpNAME", "TpName", "Tcpname", "tfpname", "tcapni", "tworkname", " tworknam", "tcpni", "tcapName", "Tcppath", " tcpni", " tmpName", " tworkName", "tcapNAME", "tpNAME", "tippath", "tfpName", "Tpname", "TmpName", "tworknam", "tworkName", "tppname", "Tpni", " tcpName", "tipresource"], "lower_proto": ["lower_perdo", "lower_protocol", "lower_Proto", "lower_protpo", "lower_pero", "lower_perpo", "lower_protto", "lower_proo", "lower_perocol", "lower_propo", "lower_perto", "lower_Prodo", "lower_proocol", "lower_Proocol", "lower_protdo", "lower_Proo", "lower_Propo", "lower_prodo"], "rbuf": ["rebuf", "sbuff", "wbbf", "buc", "buff", "erbux", "fbbuf", "fbuf", "erbuff", "bef", "rbundle", "rbbf", "rbund", "rebux", "erbef", "sbux", "rbuc", "buf", " buc", "rbuff", "rebund", "erbuf", "bundle", "fbuc", "sbund", "rebuff", "buffy", "rbef", "wbuf", "erbund", " bundle", "sbuf", "sbef", "erbbf", "bbuf", "rbuffy", "rbbuf", "sbuffy", "erbuffy", "wbund", " buf", "wbuff", "rbux", "fbundle", " bbuf", "rebbf"], "method": ["man", "text", "prot", "header", "ssl", "cli", "config", "session", "mi", "api", "mode", "stream", "format", "prefix", "file", "message", "description", "url", "URI", "ip", "address", "resource", "username", "http", "client", "seq"], "ret": ["rep", "cat", "bf", "val", "let", "fail", "res", "value", "part", "bad", "back", " RET", "sr", "error", "match", "def", "rc", "att", "pet", "code", " Ret", "num", "resp", "flag", "alt", "lib", "RET", "ref", "det", "id", "status", "red", "obj", "len", "no", "count", "lit", "end", "success", "rets", "str", "data", "reply", "fun", "nt", "reg", "info", "result", "get", "arg", "Ret", "ft", "out", "re", "pass", "bit", "try", "art"], "methodcode": ["typeCode", "methodnumber", "nameCode", "namedef", "methoddef", "methodCode", "METHODCode", "METHODnumber", "METHODcode", "namenumber", "typecode", "typenumber", "METHODdef", "namecode"]}}
{"project": "FFmpeg", "commit_id": "365ef88d5df4756942324b633cc439154e468276", "target": 1, "func": "int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb,\n\n                            VLC *vlc, const float *level_table,\n\n                            const uint16_t *run_table, int version,\n\n                            WMACoef *ptr, int offset, int num_coefs,\n\n                            int block_len, int frame_len_bits,\n\n                            int coef_nb_bits)\n\n{\n\n    int code, level, sign;\n\n    const uint32_t *ilvl = (const uint32_t *) level_table;\n\n    uint32_t *iptr = (uint32_t *) ptr;\n\n    const unsigned int coef_mask = block_len - 1;\n\n    for (; offset < num_coefs; offset++) {\n\n        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);\n\n        if (code > 1) {\n\n            /** normal code */\n\n            offset                  += run_table[code];\n\n            sign                     = get_bits1(gb) - 1;\n\n            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;\n\n        } else if (code == 1) {\n\n            /** EOB */\n\n            break;\n\n        } else {\n\n            /** escape */\n\n            if (!version) {\n\n                level = get_bits(gb, coef_nb_bits);\n\n                /** NOTE: this is rather suboptimal. reading\n\n                 *  block_len_bits would be better */\n\n                offset += get_bits(gb, frame_len_bits);\n\n            } else {\n\n                level = ff_wma_get_large_val(gb);\n\n                /** escape decode */\n\n                if (get_bits1(gb)) {\n\n                    if (get_bits1(gb)) {\n\n                        if (get_bits1(gb)) {\n\n                            av_log(avctx, AV_LOG_ERROR,\n\n                                   \"broken escape sequence\\n\");\n\n                            return -1;\n\n                        } else\n\n                            offset += get_bits(gb, frame_len_bits) + 4;\n\n                    } else\n\n                        offset += get_bits(gb, 2) + 1;\n\n                }\n\n            }\n\n            sign                    = get_bits1(gb) - 1;\n\n            ptr[offset & coef_mask] = (level ^ sign) - sign;\n\n        }\n\n    }\n\n    /** NOTE: EOB can be omitted */\n\n    if (offset > num_coefs) {\n\n        av_log(avctx, AV_LOG_ERROR, \"overflow in spectral RLE, ignoring\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 1945, "substitutes": {"avctx": ["antctx", "afcontext", "antcontext", "akconv", "Avconfig", "apconn", "avconn", "AVctx", "avcli", "Avctx", "avci", "navcmp", "avcmp", "apci", "Avcontext", "Avconv", "apctx", "evcmp", "akctx", "AVcli", "afconn", "navcontext", "akconfig", "navctx", "antci", "afconv", "afctx", "evctx", "akcontext", "apcontext", "antconn", "evcli", "evcontext", "avconfig", "AVcontext", "avcontext", "AVcmp", "avconv", "afci", "navcli", "afconfig"], "gb": ["gu", "kb", "bf", "tm", "cod", "git", "gru", "rb", "agg", "ui", "loc", "binary", "ctx", "bb", "GB", "ge", "gh", "lib", "ha", "ci", "src", "gc", "byte", "gt", "cli", "bridge", "ga", "gp", "gal", "gate", "cgi", "tg", "bn", "lb", "gnu", "mb", "slice", "py", "nb", "gpu", "gz", "pc", "g", "eb", "abb", "gin", "usb", "ym", "go", "game", "hub", "sb", "rg", "gm", "gram", "gd", "gg", "gy", "gs", "cb", "phy", "db", "b", "sg", "storage", "gam", "bc", "cfg", "bm"], "vlc": ["svc", "wlc", "vlac", "velci", "lvct", "lvf", "wlac", "llc", "svct", "velf", "lvm", "llf", "lvc", "vlct", "velct", "wlm", "vlf", "llm", "wlf", "llac", "velc", "svf", "lvci", "lvac", "vlm", "vlci", "svci"], "level_table": ["levelalcount", "level_val", "run_list", "level__table", "level_count", "levelingval", "level__code", "levelingtable", "levelinglist", "level__count", "run_val", "run_count", "level_list", "levelalcode", "levelingtab", "run_tab", "run_family", "level__family", "level_tab", "levelaltable", "level_code", "level_family", "levelalfamily", "run_code"], "run_table": ["runvaltable", "runallwindow", "runlisttable", "run_sequence", "rungbuffer", "updateallwindow", "runallbase", "unit_interface", "update_window", "runvalbuffer", "run_base", "unit_sequence", "updateallbuffer", "runvalbase", "update_buffer", "run_buffer", "run_window", "update_table", "updatealltable", "run_count", "runvalwindow", "runallbuffer", "unit_count", "runalltable", "runlistinterface", "rungtable", "updateallbase", "rungwindow", "rungbase", "run_interface", "unit_table", "runlistsequence", "runlistcount", "update_base"], "version": ["model", "update", "support", "scale", "patch", "unit", "option", "conv", "valid", "config", "vision", "rev", "compatible", "len", "release", "Version", "beta", "build", "format", "python", "supported", "v", "cover", "parent", "length", "secret", "package", "server", "url", "depth", "vert", "feature", "native", "VERSION", "ver", "final", "versions", "step", "ception"], "ptr": ["bf", "rect", "cod", "val", "Ptr", "sth", "tty", "loc", "attr", "inst", "pr", "tr", "pb", "grad", "elt", "sh", "pt", "fp", "alloc", "trace", "ref", "src", "impl", "dr", "buffer", "gp", "stage", "buf", "slice", "pad", "py", "pos", "pc", "ocr", "eth", "length", "td", "port", "pre", "pair", "transfer", "ipt", "push", "handle", "address", "addr", "ctr", "pointer", "br"], "offset": ["i", "part", "hop", "unit", "iterator", "alias", "bound", "len", "position", "parent", "output", "origin", "layer", "info", "image", "annot", "f", "set", "post", "error", "option", "o", "axis", "trace", "append", "limit", "stage", "fee", "et", "pos", "success", "notation", "url", "point", "seed", "style", "addr", "it", "pointer", "sync", "line", "base", "shift", "iso", "operation", "Offset", "location", "area", "slice", "member", "length", "address", "size", "index", "action", "attribute", "loc", "attr", "padding", "optional", "fp", "enabled", "sequence", "alpha", "skip", "off", "stop", "end", "type", "initial", "start", "anch", "oa", "align", "entry", "order"], "num_coefs": ["num_coofi", "num_coffi", "num_coiferences", "num_coefsets", "num_coofs", "num_CoEFd", "num_coofn", "num_coefd", "num_CoEFn", "num_coiffsets", "num_Coefd", "num_Coefi", "num_crossifferences", "num_CoEFi", "num_crossiffs", "num_coeffs", "num_coifs", "num_coffn", "num_crossefs", "num_coffs", "num_CoEFs", "num_coifes", "num_coefn", "num_coeffi", "num_coalfsets", "num_crossiffes", "num_coffd", "num_coalferences", "num_coifsets", "num_crosseferences", "num_crossiffsets", "num_Coefn", "num_coiffs", "num_coEFi", "num_coeffn", "num_coEFn", "num_coefes", "num_coEFs", "num_coofd", "num_coalfs", "num_crossefes", "num_coeffd", "num_coeferences", "num_Coefs", "num_coifferences", "num_coEFd", "num_coefi", "num_crossefsets", "num_coiffes", "num_coalfes"], "block_len": ["block_Len", " block_Len", "frame_length", "block67length", " block_length", "block67Len", "block_cache", "frame_size", "frame_len", "block_data", "block67cache", "block67len", "block_length", "frame_data", "block_size", " block_cache"], "frame_len_bits": ["frame_Len2bits", "frame_len_bytes", "frame_len2pieces", "frame_Len2parts", "frame_len2bytes", "frame_val_cycles", "frame_len_parts", "frame_len_pieces", "frame_len_cycles", "frame_Len2pieces", "frame_Len_pieces", "frame_val_bits", "frame_len2parts", "frame_val_bytes", "frame_Len_parts", "frame_val_parts", "frame_Len_bytes", "frame_len2bits", "frame_Len_bits", "frame_Len2bytes"], "coef_nb_bits": ["coef_nb_bit", "coef_len_bit", "coef_num_pieces", "coef_num_bytes", "coef_nb_pieces", "coef_num_frames", "coef_len_pieces", "coef_num_bits", "coef_nb_bytes", "coef_nb_frames", "coef_len_bits"], "code": ["comment", "order", "line", "cod", "zip", "cc", "create", "base", "loc", "bug", "error", "comb", "grade", "enc", "function", "sec", "core", "p", "key", "ec", "coded", "call", "name", "id", "buffer", "status", "stage", "age", "count", "charge", "codes", "end", "change", "type", "go", "later", "func", "co", "coll", "scene", "length", "c", "complete", "comp", "test", "Code", "layer", "ch", "cb", "state", "pack", "rate", "f", "ode", "component", "address", "score", "size", "cycle", "message", "e", "second", "bit", "ce", "content", "index", "desc"], "level": ["mask", "model", "line", "val", "lock", "base", "loc", "scale", "error", "patch", "grade", "unit", "Level", "letter", "valid", "fl", "key", "call", "name", "limit", "stage", "status", "step", "pe", "vol", "len", "count", "ul", "lc", "change", "type", "coll", "member", "parent", "length", "rol", "test", "scope", "layer", "weight", "depth", "local", "rule", "global", "cost", "inc", "cl", "vel", "child", "pass", "cel", "lvl", "round", "path", "index", "clean"], "sign": ["mask", "comment", "mod", "draw", "feed", "action", "ident", "diff", "value", "scan", "shift", "scale", "sort", "form", "patch", "sub", "SIGN", "gen", "enc", "close", "sh", "pl", "p", "Sign", "act", "ind", "min", "se", "name", "call", "z", "sum", "status", "id", "sa", "connect", "dig", "skip", "pad", "pos", "change", "sp", "parent", "length", "spec", "shape", "start", "weight", "plus", "cap", "style", "pack", "max", "save", "push", "fix", "ver", "inc", "set", "err", "size", "pass", "ign", "sk", "pull", "parse", "bit", "round"], "ilvl": ["ellv", "illkl", "islvl", "illlv", "illv", " ilfl", "ilkl", "elvl", "illvl", "isllv", "islfl", "elwl", "elfl", "islwl", "iolwl", "ilwl", "illwl", "elkl", "iolvl", "ilfl", " illv", "iollv", "iolkl", " ilwl"], "iptr": ["ipor", "iptn", "iptry", "ipl", "aphor", "ptn", "ptor", "iptl", "ipr", "ctor", "inetR", "aphn", "iptor", "aphry", "ptry", "inetl", "ippl", "ctry", "aphr", "iptR", "ippR", "ctn", "ippor", "inetr", "ctr", "ipR", "inetor", "ippr"]}}
{"project": "FFmpeg", "commit_id": "9241cd2095fe8395e02be5556d657d06f65ba91f", "target": 0, "func": "int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,\n\n                         AVFilterInOut *open_inputs,\n\n                         AVFilterInOut *open_outputs, AVClass *log_ctx)\n\n{\n\n    int index = 0, ret;\n\n    char chr = 0;\n\n\n\n    AVFilterInOut *curr_inputs = NULL;\n\n\n\n    do {\n\n        AVFilterContext *filter;\n\n        filters += strspn(filters, WHITESPACES);\n\n\n\n        if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        if (filter->input_count == 1 && !curr_inputs && !index) {\n\n            /* First input can be omitted if it is \"[in]\" */\n\n            const char *tmp = \"[in]\";\n\n            if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) < 0)\n\n                goto fail;\n\n        }\n\n\n\n        if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs,\n\n                                 log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        filters += strspn(filters, WHITESPACES);\n\n        chr = *filters++;\n\n\n\n        if (chr == ';' && curr_inputs) {\n\n            av_log(log_ctx, AV_LOG_ERROR,\n\n                   \"Could not find a output to link when parsing \\\"%s\\\"\\n\",\n\n                   filters - 1);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        index++;\n\n    } while (chr == ',' || chr == ';');\n\n\n\n    if (chr) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Unable to parse graph description substring: \\\"%s\\\"\\n\",\n\n               filters - 1);\n\n        ret = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    if (open_inputs && !strcmp(open_inputs->name, \"out\") && curr_inputs) {\n\n        /* Last output can be omitted if it is \"[out]\" */\n\n        const char *tmp = \"[out]\";\n\n        if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs,\n\n                                 log_ctx)) < 0)\n\n            goto fail;\n\n    }\n\n\n\n    return 0;\n\n\n\n fail:\n\n    avfilter_graph_free(graph);\n\n    free_inout(open_inputs);\n\n    free_inout(open_outputs);\n\n    free_inout(curr_inputs);\n\n    return ret;\n\n}\n", "idx": 1946, "substitutes": {"graph": ["model", "feed", "cache", "follow", "closure", "context", "hash", "pattern", "stack", "group", "connection", "document", "node", "query", "root", "config", "proxy", "edge", "connect", "scroll", "handler", "stream", "format", "g", "parent", "output", "pool", "scope", "flow", "image", "network", "subject", "Graph", "raph", "tree", "f", "handle", "dot", "path"], "filters": ["liftons", "fters", "Filts", "FILches", "filts", "FILchers", "liftering", "flts", "flers", "filchers", "FILtered", "collets", "fileers", "fltons", "flters", "FILters", "feedlets", "ilters", "liftered", "filners", "synters", "fter", "FILts", "factters", "mattered", "Filter", "fillets", "FILers", "colts", "feedters", "syncers", "coltering", "iltering", "filecers", "fileors", "factcers", "FILtering", "feedtered", "lifters", "fillines", "filelines", "fators", "ilches", "iltered", "factners", "collines", "matter", "feedtering", "lifts", "heleners", "lifeners", "ilers", "filtering", "filators", "colches", "matts", "Filers", "butchers", "flter", "coltered", "facters", "filches", "illines", "matters", "ftering", "iltons", "mattering", "filtons", "Filtering", "feedter", "filers", "filcers", "syners", "colors", "butters", "helters", "colers", "filors", "feedts", "ftered", "fileters", "matlets", "helts", "FILators", "fts", "butter", "fltered", "FILter", "filtered", "colators", "colters", "synners", "fltering", "buttered", "Filters", "heltering", "fileners", "Fileners", "ilors", "fchers"], "open_inputs": ["open_platformts", "open_contexterences", "open_selecterences", "open_columns", "open_contextes", "open_columnops", "open_columnches", "open_selectes", "open_logviews", "open_Inputts", "open_contexts", "open_platformerences", "open_pathes", "open_pathors", "open_outputors", "open_inputviews", "open_pullerences", "open_columnts", "open_columnes", "open_columnb", "open_Inputops", "open_inputerences", "open_selectors", "open_columnerences", "open_contextviews", "open_outputerences", "open_outputb", "open_Inputb", "open_platforms", "open_inputches", "open_paths", "open_outputes", "open_selects", "open_inputops", "open_outputviews", "open_outputches", "open_Inputs", "open_contextches", "open_loges", "open_inputts", "open_pulles", "open_patherences", "open_inputb", "open_inputes", "open_outputops", "open_outputts", "open_logs", "open_inputors", "open_logerences", "open_pulls", "open_pullts", "open_platformes"], "open_outputs": ["open_connectviews", "open_returnes", "open_inputments", "open_graphes", "open_columns", "open_returning", "open_contextes", "open_methods", "open_contexts", "open_inputses", "open_inputviews", "open_outputors", "open_graphses", "open_columnflows", "open_inputing", "open_graphsets", "open_columnes", "open_patterning", "open_outputses", "open_contextsets", "open_connecterences", "open_patterns", "open_inputflows", "open_inputerences", "open_methodes", "open_outputments", "open_contextses", "open_outputerences", "open_columnors", "open_methodments", "open_methodflows", "open_outputflows", "open_outputes", "open_columnments", "open_outputviews", "open_returns", "open_outputsets", "open_inputsets", "open_outputing", "open_connects", "open_inputes", "open_connecting", "open_columning", "open_inputors", "open_patternerences", "open_returnors", "open_graphs", "open_patternviews"], "log_ctx": ["log_c", "logingobj", "logMlc", "bug_cn", "logFlc", "Log_tx", "logadepkg", "loggctx", "log_cot", " log_cn", "log_loc", "logadelc", "logadectx", "logadeobj", "loglcn", "logFcot", "log_obj", "bug_loc", "logMobj", "Log_c", "loginglc", "log_pkg", "logadecmd", "loglstack", "logMcontext", " log_tx", "logingctx", "logerctx", "Log_ctx", "log_lc", "Log_context", "logingcu", " log_cmd", "log_stack", "bug_ctx", " log_voc", "bug_stack", " log_pkg", "logFtc", "logercn", " log_tc", " log_obj", "log_cu", "log_cmd", "loglctx", "log_cf", "loggtx", "loglloc", "loggcontext", "log_tc", " log_cot", "logingvoc", "logMctx", "logMpkg", "loggc", "logerlc", "log_context", "logercmd", " log_cu", " log_cf", "log_cn", " log_lc", "log_voc", "logingcontext", "logingtx", "logMcu", "log_tx", "logercu", " log_context", "logadecu", "logercf", "logadecontext", "logFctx"], "ret": ["cat", "bf", "val", "rb", "let", "res", "part", "pat", "back", "match", "def", "rc", "att", "pet", "rt", "flag", "hash", "alt", "valid", "RET", "arr", "ref", "mem", "det", "fit", "usr", "gt", "job", "obj", "id", "session", "rev", "true", "len", "bot", "lit", "trans", "success", "conn", "rets", "feat", "wrap", "reply", "mt", "fun", "sb", "nt", "reg", "url", "result", "get", "cb", "arg", "Ret", "db", "al", "err", "ft", "re", "pass", "bit", "art"], "curr_inputs": ["curr_methoduments", "curr_selects", "curr_contextuments", "curr_hosterences", "curr_inputsets", "curr_inputb", "curr_columnsets", "curr_initialions", "curr_execes", "curr_keepments", "curr_initials", "curr_keeped", "curr_outputions", "curr_outputos", "curr_inputd", "curr_subjectes", "curr_initialerences", "curr_configs", "curr_keeps", "curr_outputls", "curr_methods", "curr_outputerences", "curr_execions", "curr_logos", "curr_pullerences", "curr_inputions", "curr_colls", "curr_outputed", "curr_contexts", "curr_hosts", "curr_keeperences", "curr_columnb", "curr_configsets", "curr_configd", "curr_columnd", "curr_inputuments", "curr_subjects", "curr_initiales", "curr_methodes", "curr_infs", "curr_hostuments", "curr_inputments", "curr_outputes", "curr_outputsets", "curr_inputos", "curr_pulles", "curr_outputb", "curr_outputs", "curr_columns", "curr_inferences", "curr_selecterences", "curr_outputd", "curr_inputls", "curr_infmaps", "curr_colos", "curr_configb", "curr_inputerences", "curr_selectments", "curr_inputes", "curr_inputed", "curr_selected", "curr_logls", "curr_outputmaps", "curr_outputuments", "curr_infuments", "curr_outputments", "curr_logs", "curr_contextes", "curr_cols", "curr_hostmaps", "curr_execs", "curr_inputmaps", "curr_pulls"], "filter": ["user", "field", "cache", "attribute", "part", "transform", "sort", "attr", "match", "ac", "patch", "context", "apply", "header", "opt", "control", "query", "term", "config", "fat", "call", "name", "force", "fil", "route", "handler", "slice", "format", "file", "parent", "search", "flat", "c", "url", "layer", "plugin", "block", "channel", "feature", "f", "op", "child", "page", "Filter", "path"], "tmp": ["field", "tab", "media", "offset", "rb", "cache", "zip", "vt", "part", "diff", "text", "attr", "mp", "cmp", "binary", "img", "ctx", "copy", "temp", "conv", "fp", "opt", "iterator", "ref", "src", "input", "term", "config", "tf", "obj", "buf", "stuff", "fake", "handler", "pad", "beta", "prefix", "ext", "dest", "data", "txt", "sp", "template", "output", "sb", "perm", "test", "result", "proc", "meta", "storage", "space", "extra", "source"], "index": ["example", "order", "loop", "update", "offset", "cache", "i", "action", "part", "diff", "open", "sort", "section", "match", "si", "active", "num", "pattern", "key", "ind", "input", "config", "append", "token", "name", "id", "Index", "alpha", "route", "connect", "len", "slice", "count", "end", "pos", "type", "search", "length", "output", "current", "weight", "info", "result", "image", "condition", "col", "level", "inc", "tail", "page", "x", "path", "found"]}}
{"project": "qemu", "commit_id": "6b9b8758c15f3bc2875dbd6e2d03c5362b8d6902", "target": 0, "func": "static int virtio_net_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIONet *n = VIRTIO_NET(qdev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);\n\n    int i;\n\n\n\n    /* This will stop vhost backend if appropriate. */\n\n    virtio_net_set_status(vdev, 0);\n\n\n\n    unregister_savevm(qdev, \"virtio-net\", n);\n\n\n\n    if (n->netclient_name) {\n\n        g_free(n->netclient_name);\n\n        n->netclient_name = NULL;\n\n    }\n\n    if (n->netclient_type) {\n\n        g_free(n->netclient_type);\n\n        n->netclient_type = NULL;\n\n    }\n\n\n\n    g_free(n->mac_table.macs);\n\n    g_free(n->vlans);\n\n\n\n    for (i = 0; i < n->max_queues; i++) {\n\n        VirtIONetQueue *q = &n->vqs[i];\n\n        NetClientState *nc = qemu_get_subqueue(n->nic, i);\n\n\n\n        qemu_purge_queued_packets(nc);\n\n\n\n        if (q->tx_timer) {\n\n            timer_del(q->tx_timer);\n\n            timer_free(q->tx_timer);\n\n        } else {\n\n            qemu_bh_delete(q->tx_bh);\n\n        }\n\n    }\n\n\n\n    g_free(n->vqs);\n\n    qemu_del_nic(n->nic);\n\n    virtio_cleanup(vdev);\n\n\n\n    return 0;\n\n}\n", "idx": 1981, "substitutes": {"qdev": ["qdevice", "Qdi", " qdi", "wver", "kver", "kdevice", "Qver", " qdevice", " qver", "pdev", "pdevice", " qDev", "Qdm", "qdm", "qdi", "kDev", "Qdevice", "QDev", "pver", "kdiv", "qudiv", " qdm", "wev", "kev", "qver", "qdiv", "Qdev", "quswitch", "vdevice", "qudevice", "vdiv", "wdev", "vswitch", "pdi", "qev", "pev", "qudev", "kdm", "qswitch", "kdev", "kswitch", "wdevice", "qDev"], "n": ["fn", "nm", "ns", "un", "l", "syn", "num", "o", "y", "p", "yn", "new", "nn", "node", "non", "nor", "d", "m", "name", "z", "ln", "adj", "sn", "w", "s", "not", "k", "an", "gn", "on", "v", "nb", "conn", "g", "ne", "cn", "dn", "c", "nt", "in", "nu", "self", "np", "current", "init", "mn", "pn", "rn", "network", "ng", "t", "b", "f", "na", "u", "none", "N", "e", "net", "en"], "vdev": ["vpack", "fconf", " vpriv", "kdevice", "vconf", "cmid", "fdev", "pdev", "fmid", "pdevice", "fpriv", "vpriv", " vconf", "kmid", "fdd", "ppriv", "fdevice", "wpack", " vpack", "pconf", "vmid", "cdd", "vdd", "kpack", "vdevice", "kdd", "cdevice", " vdd", "cdev", "wdev", "wdd", " vdevice", "kdev", "wdevice"], "i": ["hi", "phi", "chi", "ui", "io", "l", "fi", "is", "si", "j", "uri", "o", "y", "p", "ci", "multi", "qi", "eni", "d", "m", "oi", "name", "id", "mi", "ri", "k", "ini", "ii", "v", "a", "x", "type", "li", "iu", "ie", "c", "zi", "counter", "di", "ix", "ai", "pi", "mu", "b", "f", "gi", "u", "ti", "ip", "ni", "e", "xi", "I", "it", "ki", "yi", "index"], "q": ["view", "req", "gh", "sh", "qs", "p", "ic", "qu", "qq", "qi", "query", "d", "m", "sq", "queue", "z", "w", "k", "qa", "charge", "v", "co", "g", "iq", "c", "dq", "ch", "ng", "ck", "t", "que", "u", "cl", "client", "f", "cmd", "e", "x", "Q", "qt", "sync", "s", "pg"], "nc": ["dc", "cc", "nm", "cf", "ns", "fc", "enc", "ctx", "ci", "ec", "nn", "xc", "ct", "sn", "bn", "qa", "cdn", "cv", "lc", "conn", "pc", "co", "NC", "cn", "dn", "c", "nt", "nu", "rn", "mc", "nec", "ng", "nic", "na", "nw", "bc", "qt", "cm"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_widen(TCGv dest, TCGv src, int size, int u)\n\n{\n\n    if (u) {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_u8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_u16(dest, src); break;\n\n        case 2: tcg_gen_extu_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    } else {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_s8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_s16(dest, src); break;\n\n        case 2: tcg_gen_ext_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    }\n\n    dead_tmp(src);\n\n}\n", "idx": 1983, "substitutes": {"dest": ["uv", "dist", "wd", "dc", "home", "ui", "ident", "transform", "done", "loc", "die", "sort", "comb", "gen", "ptr", "grad", "img", "st", "opt", "gest", "huge", "usr", "node", "config", "name", "obj", "iter", "route", "cdn", "class", "trans", "feat", "prop", "txt", "ie", "gener", "target", "vp", "info", "seed", "proc", "Dest", " Dest", "err", "wb", "this", "nw", "uc", "coord", "cont", "sup", "priv", "later", "path", "source", "desc"], "src": ["gl", "dist", "view", "rb", "home", "sth", "req", "sub", "uri", "sec", "lib", "sel", "usr", "sn", "stat", "sb", "origin", "cb", "proc", "ctr", "iv", "go", "cont", "inf", "ui", "inst", "sr", "st", "tmp", "impl", "config", "gin", "url", "comp", "pack", "rob", "sup", "sc", "ptr", "ssl", "href", "obj", "slice", "stream", "txt", "us", "ources", "spec", "ser", "cur", "uc", "source", "desc", "uv", "sur", "loc", "attr", "rc", "img", "fp", "lower", "rest", "rec", "class", "sys", "rib", "ource", "target", "bin", "uint", "resource"], "size": ["i", "six", "grow", "shift", "scale", "loc", "sync", "rc", "si", "code", "enc", "unit", "sec", "external", "n", "y", "south", "p", "security", "uni", "z", "source", "sum", "sn", "capacity", "len", "mode", "ize", "shape", "c", "ix", "small", "sized", "range", "address", "e", "empty", "x", "SIZE", "cm", "en", "Size"], "u": ["uv", "U", "cu", "uit", "ui", "su", " su", "lu", "l", "uci", "uu", "un", "uri", "eu", "ue", "up", "uni", "gnu", "ul", "v", "ou", "ur", "g", "universal", "tu", "iu", "us", "c", "nu", " units", "du", "util", "ru", "pu", "ku", "uint", "uid", "uc"]}}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_create_branch(BDRVSheepdogState *s)\n\n{\n\n    int ret, fd;\n\n    uint32_t vid;\n\n    char *buf;\n\n\n\n    dprintf(\"%\" PRIx32 \" is snapshot.\\n\", s->inode.vdi_id);\n\n\n\n    buf = g_malloc(SD_INODE_SIZE);\n\n\n\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,\n\n                       s->addr, s->port);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    dprintf(\"%\" PRIx32 \" is created.\\n\", vid);\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        error_report(\"failed to connect\");\n\n        ret = fd;\n\n        goto out;\n\n    }\n\n\n\n    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,\n\n                      SD_INODE_SIZE, 0, s->cache_enabled);\n\n\n\n    closesocket(fd);\n\n\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    memcpy(&s->inode, buf, sizeof(s->inode));\n\n\n\n    s->is_snapshot = false;\n\n    ret = 0;\n\n    dprintf(\"%\" PRIx32 \" was newly created.\\n\", s->inode.vdi_id);\n\n\n\nout:\n\n    g_free(buf);\n\n\n\n    return ret;\n\n}\n", "idx": 1990, "substitutes": {"s": ["i", "uns", "conf", "v", "states", "ps", "secondary", "sb", "sym", "as", "f", "os", "js", "params", "same", "sv", "l", "is", "si", "qs", "o", "y", "p", "ins", "stats", "ses", "site", "args", "sg", "side", "ops", "sync", "h", "S", "r", "settings", "hs", "cs", "ssl", "new", "m", "sq", "session", "status", "service", "g", "us", "ks", "spec", "es", "gs", "options", "t", "aws", "ss", "e", "ls", "sl", "ds", "xs", "fs", "ms", "su", "sets", "ts", "ns", "n", "services", "a", "sys", "c", "rs", "in", "self", "its"], "ret": ["rb", "pat", "att", "num", "resp", "alt", "opt", "ref", "fat", "len", "lit", "ben", "feat", "reply", "sp", "ll", "arg", "f", "bit", "wa", "let", "res", "sr", "pet", " Ret", "valid", "fit", "html", "rev", "run", "success", "rets", "nt", "url", "Ret", "err", "ft", "sat", "fn", " RET", "fi", "flag", "code", "active", "bd", "var", "rf", "conn", "fun", "reg", "xt", "out", "try", "cat", "bf", "val", "fail", "fs", "sur", "bad", "back", "def", "rc", "rt", "fin", "RET", "det", "af", "id", "ext", "mt", "result", "re", "pass", "en", "art"], "fd": ["fn", "vd", "md", "bf", "dd", "FD", "wd", "dc", "fs", "feed", "buff", " fid", "cf", "fc", "fi", "resp", "dl", "bd", "fp", "nd", "fin", "fl", "ff", "d", "fat", "pid", "id", "ln", "fee", "fb", "fm", "ld", "df", "handler", "wat", "conn", "sf", "xd", "fw", "fun", "gd", "fa", "fed", "draft", "cb", "fx", "hd", "db", "cd", "f", "wb", "ds", "raf", "lf", "fe"], "vid": ["vd", "host", "cat", "cod", "val", "dc", "vic", "did", "vis", "bid", "pet", "sid", "kind", "vc", "virt", "var", "vision", "pid", "name", "id", "rev", " var", "vec", "v", "vr", "pos", " pid", "feat", "vag", "kid", "mid", "slot", "ticket", "lv", "oid", "di", "gd", "vi", " id", "vert", "vs", "hd", "db", "fx", "version", "ver", "ip", "doc", "addr", " vi", "uid", "iv", "VID", "vv"], "buf": ["xff", "bf", "wa", "feed", "rb", "cache", "buff", "cf", "rc", "fi", "context", "pb", "ctx", "temp", "bd", "fp", "tmp", "ref", "fl", "mem", "ff", "src", "queue", "buffer", "vec", "fb", "len", "pad", "cv", "conn", "dest", "feat", "data", "uf", "port", "fun", "bag", "pool", "c", "ob", "cb", "cap", "fx", "db", "b", "cmd", "f", "wb", "bc", "cas", "raf", "uc", "br"]}}
{"project": "qemu", "commit_id": "449041d4db1f82f281fe097e832f07cd9ee1e864", "target": 1, "func": "static int parse_uint8(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx8 : \"%\" PRIu8;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 1994, "substitutes": {"dev": ["md", "mod", "serial", "dd", "wd", "gr", "req", "od", "attr", "priv", "inst", "device", "def", "private", "de", "tr", "grad", "conf", "sh", "debug", "d", "w", "data", "pro", "Dev", "dt", "self", "comp", "gd", "prof", "ch", "proc", "dem", "sd", "err", "ver", "rad", "iv", "ev", "dom", "br"], "prop": ["val", "part", "pr", "attr", "r", "def", "properties", "device", "prot", "ctx", "pb", "pt", "p", "tmp", "ref", "root", "obj", "name", "property", "lit", "pos", "type", "data", "Prop", "pro", "pred", "info", "phy", "proc", "op", "f", "pointer", "priv"], "str": ["stri", "fr", "val", "cr", "text", "pr", "r", "attr", "sr", "tr", "enc", "code", "sec", "st", "pt", "arr", "Str", "name", "obj", "ext", "data", "sp", "expr", "spec", "STR", "rs", "hr", "test", "arg", "strings", "err", "cur", "ctr", "sl", "s", "br"], "ptr": ["fr", "Ptr", "offset", "val", "tty", "pr", "r", "inst", "loc", "prot", "tr", "rt", "st", "pt", "p", "fp", "ref", "src", "dr", "spr", "buf", "len", "pad", "py", "pos", "func", "fd", "sp", "length", "nt", "proc", "t", "inter", "err", "addr", "pointer", "br"], "fmt": ["hmt", "cfformat", "cnt", "fnt", "Fformat", "Fmt", "affmt", " fmd", " fMT", "affMT", "cmt", "Fmd", "htt", "Ftm", "ftt", "cfprintf", "FMT", "cfmt", "cfMT", "ftm", "fmd", "afftt", "Fnt", "fMT", "cMT", " fformat", " fnt", "fformat", "htm", "hMT", "cmd", "Ftt", "Fprintf", "afftm"]}}
{"project": "FFmpeg", "commit_id": "2f76157eb05bf63725f96167feda6b2e07501c7e", "target": 1, "func": "av_cold int swri_rematrix_init(SwrContext *s){\n\n    int i, j;\n\n    int nb_in  = av_get_channel_layout_nb_channels(s->in_ch_layout);\n\n    int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout);\n\n\n\n    s->mix_any_f = NULL;\n\n\n\n    if (!s->rematrix_custom) {\n\n        int r = auto_matrix(s);\n\n        if (r)\n\n            return r;\n\n    }\n\n    if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));\n\n        s->native_one    = av_mallocz(sizeof(int));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++) {\n\n            double rem = 0;\n\n\n\n            for (j = 0; j < nb_in; j++) {\n\n                double target = s->matrix[i][j] * 32768 + rem;\n\n                ((int*)s->native_matrix)[i * nb_in + j] = lrintf(target);\n\n                rem += target - ((int*)s->native_matrix)[i * nb_in + j];\n\n            }\n\n        }\n\n        *((int*)s->native_one) = 32768;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_s16;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s16;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(float));\n\n        s->native_one    = av_mallocz(sizeof(float));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++)\n\n            for (j = 0; j < nb_in; j++)\n\n                ((float*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((float*)s->native_one) = 1.0;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_float;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_float;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_DBLP){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));\n\n        s->native_one    = av_mallocz(sizeof(double));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++)\n\n            for (j = 0; j < nb_in; j++)\n\n                ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((double*)s->native_one) = 1.0;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_double;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_double;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){\n\n        // Only for dithering currently\n\n//         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));\n\n        s->native_one    = av_mallocz(sizeof(int));\n\n        if (!s->native_one)\n\n            return AVERROR(ENOMEM);\n\n//         for (i = 0; i < nb_out; i++)\n\n//             for (j = 0; j < nb_in; j++)\n\n//                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((int*)s->native_one) = 32768;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_s32;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s);\n\n    }else\n\n        av_assert0(0);\n\n    //FIXME quantize for integeres\n\n    for (i = 0; i < SWR_CH_MAX; i++) {\n\n        int ch_in=0;\n\n        for (j = 0; j < SWR_CH_MAX; j++) {\n\n            s->matrix32[i][j]= lrintf(s->matrix[i][j] * 32768);\n\n            if(s->matrix[i][j])\n\n                s->matrix_ch[i][++ch_in]= j;\n\n        }\n\n        s->matrix_ch[i][0]= ch_in;\n\n    }\n\n\n\n    if(HAVE_YASM && HAVE_MMX)\n\n        return swri_rematrix_init_x86(s);\n\n\n\n    return 0;\n\n}\n", "idx": 1998, "substitutes": {"s": ["uns", "conf", "er", "ubs", "d", "ions", "sa", "an", "states", "ps", "sb", "sym", "os", "f", "strings", "this", "js", "params", "sv", "l", "sites", "si", "is", "qs", "o", "p", "less", "ins", "se", "stats", "ses", "site", "args", "features", "b", "sg", "u", "serv", "ops", "sync", "h", "S", "r", "settings", "hs", "cs", "ctx", "ssl", "south", "new", "m", "sq", "session", "bs", "w", "service", "g", "us", "server", "ks", "spec", "es", "gs", "options", "sports", "t", "aws", "ss", "e", "ls", "http", "ds", "xs", "request", "fs", "ms", "su", "sets", "ts", "ns", "n", "rates", "src", "groups", "input", "services", "a", "sys", "sf", "c", "rs", "in", "self", "vs", "storage", "its", "bis"], "i": ["ui", "im", "io", "r", "ik", "l", "fi", "is", "si", "n", "uri", "o", "y", "p", "ci", "qi", "ind", "eni", "d", "m", "mi", "ori", "z", "id", "ri", "ini", "ii", "v", "bi", "x", "li", "iu", "ie", "ji", "c", "in", "zi", "di", "ix", "ai", "info", "vi", "pi", "b", "f", "u", "gi", "ip", "ni", "e", "xi", "I", "it", "ki", "yi", "index"], "j": ["jc", "jo", "r", "bj", "pr", "l", "n", "jl", "o", "y", "dj", "p", "jen", "oj", "qi", "ind", "d", "m", "aj", "obj", "z", "w", "note", "ja", "k", "ij", "ii", "v", "uj", "pos", "el", "jet", "li", "jj", "ie", "ji", "jp", "ch", "t", "b", "f", "q", "u", "jit", "kj", "js", "e", "out", "x", "it", "J", "h", "index"]}}
{"project": "qemu", "commit_id": "1a0e4c8b02ea510508970c333ee610a90b921cbb", "target": 1, "func": "void s390_machine_reset(void)\n\n{\n\n    S390CPU *ipl_cpu = S390_CPU(qemu_get_cpu(0));\n\n\n\n    qemu_devices_reset();\n\n    s390_cmma_reset();\n\n    s390_crypto_reset();\n\n\n\n    /* all cpus are stopped - configure and start the ipl cpu only */\n\n    s390_ipl_prepare_cpu(ipl_cpu);\n\n    s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu);\n\n}\n", "idx": 2009, "substitutes": {"ipl_cpu": ["ipl___cp", "impl_core", "pl_pu", "impl_fork", "ipl_current", "ipl__fork", "ipl_fork", "iplaccpu", "ipl_gpu", "ipl_core", "iplacpu", "ipl00cpu", "iplaccore", "ipl_cp", "pl_cpu", "ipl__cpu", "ipl_pu", "impl_gpu", "impl_pu", "impl_cp", "iplacgpu", "impl_cpu", "ipl00core", "ipl___gpu", "ipl__cp", "ipl00pu", "ipl___cpu", "ipl___fork", "pl_current", "pl_core", "ipl00current", "ipl__gpu"]}}
{"project": "FFmpeg", "commit_id": "73f863d751df84db7a0ca1bd83cdff1b95dc94dd", "target": 1, "func": "static int fic_decode_block(FICContext *ctx, GetBitContext *gb,\n\n                            uint8_t *dst, int stride, int16_t *block)\n\n{\n\n    int i, num_coeff;\n\n\n\n    /* Is it a skip block? */\n\n    if (get_bits1(gb)) {\n\n        /* This is a P-frame. */\n\n        ctx->frame->key_frame = 0;\n\n        ctx->frame->pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        return 0;\n\n    }\n\n\n\n    memset(block, 0, sizeof(*block) * 64);\n\n\n\n    num_coeff = get_bits(gb, 7);\n\n    if (num_coeff > 64)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    for (i = 0; i < num_coeff; i++)\n\n        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *\n\n                                     ctx->qmat[ff_zigzag_direct[i]];\n\n\n\n    fic_idct_put(dst, stride, block);\n\n\n\n    return 0;\n\n}\n", "idx": 2010, "substitutes": {"ctx": ["kb", "kw", "cu", "cc", "pkg", "mac", "loc", "sc", "cf", "cpp", "cmp", "context", "cs", "conf", "conv", "cca", "ci", "kk", "gc", "cms", "xc", "config", "cam", "voc", "qa", "Context", "sci", "cv", "cp", "lc", "conn", "pc", "ca", "cn", "hub", "fw", "c", "ctrl", "cb", "tx", "ck", "wcs", "cmd", "hw", "utils", "bc", "cfg", "cas", "cm", "anc"], "gb": ["gu", "kb", "hm", "gru", "bf", "cod", "git", "rb", "bb", "GB", "gh", "ge", "cca", "km", "bg", "dm", "gc", "gt", "cli", "ga", "gp", "gal", "gio", "cgi", "gnu", "mb", "py", "nb", "gpu", "gz", "pc", "g", "eb", "usb", "gin", "hub", "sb", "rg", "gm", "gram", "gd", "gy", "gg", "gs", "cb", "db", "b", "gam", "bc", "cfg", "bm"], "dst": [" dost", "dost", "ndsc", " dsc", "psta", "dsc", "sdost", "dsta", "sdsc", " dST", "ndsta", "psc", "Dsc", "sdST", " dsta", "ndst", "sdst", "ndST", "Dost", "pST", "dST", "Dst", "DST", "pst"], "stride": ["STRide", "STRider", "arrade", "striade", "divider", "strade", "divide", "divade", "striider", "brides", "arrider", "STRides", "strides", "strided", "arrIDE", "bride", "striide", "arride", "strider", "striides", "brided", "strIDE", "divIDE", "striIDE", "striided", "STRided", "brider"], "block": ["comment", "line", "clock", "lock", "cache", "view", "part", "base", "loc", "error", "section", "def", "chain", "object", "copy", "code", "unit", "num", "bb", "ref", "group", "number", "node", "byte", "config", "name", "limit", "buffer", "word", "blocks", "buf", "time", "id", "obj", "Block", "slice", "off", "label", "frame", "pos", "type", "position", "batch", "row", "length", "work", "shape", "point", "map", "flow", "plugin", "board", "image", "tx", "cb", "pack", "bin", "b", "none", "box", "range", "ip", "bl", "clean"], "i": ["hi", "ui", "io", "l", "si", "j", "uri", "n", "y", "o", "p", "ci", "multi", "qi", "ind", "m", "oi", "id", "mi", "I", "z", "isin", "k", "ii", "v", "a", "bi", "li", "iu", "ie", "ji", "c", "in", "di", "ix", "ai", "info", "abi", "pi", "mu", "b", "f", "u", "gi", "jit", "ti", "ip", "e", "xi", "x", "it", "yi", "s", "index"], "num_coeff": ["num_COoff", "num_ccitch", "num_Coefficients", "num_conaff", "num_coefficient", "num_collEFF", "num_ncitch", "num_collef", "num_coEFF", "num_conEFF", "num_cceff", "num_ccefficients", "num_Coeff", "num_COitch", "num_coitch", "num_COeff", "num_cooff", "num_ncefficients", "num_COefficient", "num_coaff", "num_collefficients", "num_Coefficient", "num_crosseffect", "num_callEFF", "num_ccoff", "num_colleffect", "num_coneff", "num_Coef", "num_crossefficient", "num_COefficients", "num_coeffect", "num_collefficient", "num_calleff", "num_collaff", "num_crosseff", "num_callefficient", "num_coefficients", "num_COef", "num_ncoff", "num_coef", "num_conefficient", "num_callaff", "num_crossefficients", "num_colleff", "num_nceff"]}}
{"project": "FFmpeg", "commit_id": "604c9b1196c70d79bbbc1f23e75f6a8253a74da3", "target": 1, "func": "void ff_rtsp_undo_setup(AVFormatContext *s, int send_packets)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < rt->nb_rtsp_streams; i++) {\n\n        RTSPStream *rtsp_st = rt->rtsp_streams[i];\n\n        if (!rtsp_st)\n\n            continue;\n\n        if (rtsp_st->transport_priv) {\n\n            if (s->oformat) {\n\n                AVFormatContext *rtpctx = rtsp_st->transport_priv;\n\n                av_write_trailer(rtpctx);\n\n                if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n\n                    uint8_t *ptr;\n\n                    if (CONFIG_RTSP_MUXER && rtpctx->pb && send_packets)\n\n                        ff_rtsp_tcp_write_packet(s, rtsp_st);\n\n                    avio_close_dyn_buf(rtpctx->pb, &ptr);\n\n                    av_free(ptr);\n\n                } else {\n\n                    avio_close(rtpctx->pb);\n\n                }\n\n                avformat_free_context(rtpctx);\n\n            } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC)\n\n                ff_rdt_parse_close(rtsp_st->transport_priv);\n\n            else if (rt->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC)\n\n                ff_rtp_parse_close(rtsp_st->transport_priv);\n\n        }\n\n        rtsp_st->transport_priv = NULL;\n\n        if (rtsp_st->rtp_handle)\n\n            ffurl_close(rtsp_st->rtp_handle);\n\n        rtsp_st->rtp_handle = NULL;\n\n    }\n\n}\n", "idx": 2027, "substitutes": {"s": ["S", "support", "fs", "r", "sv", "su", "ns", "sit", "si", "ctx", "cs", "ssl", "o", "st", "p", "sed", "south", "sq", "session", "sn", "w", "sa", "v", "services", "sys", "service", "g", "ps", "server", "ses", "spec", "sf", "c", "sb", "self", "gs", "t", "os", "sg", "f", "storage", "b", "u", "ss", "js", "e", "sl", "sk", "bis", "http", "ds"], "send_packets": ["send_packsETS", "send_packset", "send_framETS", "send_packspaces", "send_Packers", "send_Packet", "send_namesETS", "send_packsers", "send_namesets", "send_namespaces", "send_Packets", "send_packETS", "send_framets", "send_framers", "send_framet", "send_packpaces", "send_Packpaces", "send_packsets", "send_nameset", "send_PackETS", "send_packers", "send_packet"], "rt": ["vd", "ird", "rect", "wx", "rb", "rr", "vt", "r", "rh", "attr", "pr", "irt", "rc", "tr", "tt", "sett", "rx", "pt", "st", "ht", "vc", "adr", "dr", "gt", "rf", "rss", "ld", "vr", "RT", "rat", "rd", "ant", "mot", "mt", "txt", "yt", "rs", "nt", "dt", "apt", "ot", "kt", "rn", "rot", "NT", "hd", "t", "rl", "ft", "rob", "ct", "qt", "tri", "bt", "art"], "i": ["hi", "chi", "ui", "r", "l", "fi", "si", "j", "n", "o", "y", "p", "ci", "multi", "qi", "ind", "eni", "d", "oi", "m", "mi", "ori", "id", "ri", "k", "ini", "ii", "v", "bi", "x", "li", "ami", "ie", "iu", "c", "zi", "di", "ai", "pi", "t", "gi", "f", "u", "b", "ti", "ip", "ni", "xi", "I", "it", "phi", "yi", "index"], "rtsp_st": ["rtsf_st", "rtsv_stage", "rtsv_st", "rtsp5ld", "rtscp_step", "rtscp_cl", "rtsp_inst", "rtspeJst", "rtsf_state", "rtsv_inst", "rtsvp_start", "rtspiksts", "rtsf_ste", "rtsvp5start", "rtsp_ST", "rtsp_sc", "rtsp6stall", "rtscp_stack", "rtspeJstim", "rtsl_sr", "rtsp0stall", "rtspe_sts", "rtsp0st", "rtsp_str", "rtsvp_ld", "rtsvp_ST", "rtsp_St", "rtsp_stack", "rtspeJct", "rtsp_std", "rtsp_ld", "rtsl_sta", "rtsp_state", "rtsp_cl", "rtspJsts", "rtscp_std", "rtsp0inst", "rtsf_stat", "rtspe_st", "rtsp_start", "rtsf_St", "rtsp6sr", "rtsp_ct", "rtsvp5st", "rtsvp5sc", "rtsp_stage", "rtsp_stall", "rtsp_sr", "rtsp_ste", "rtsf_client", "rtscp_st", "rtspikst", "rtsp_step", "rtsp_sta", "rtsp_stim", "rtspeJsts", "rtspikct", "rtspJst", "rtsvp_sts", "rtsp5st", "rtspe_ct", "rtsp_client", "rtscp_str", "rtspe_stim", "rtsl_inst", "rtscp_sta", "rtsl_st", "rtsvp5ld", "rtsp_ust", "rtsp_stat", "rtsp_sts", "rtsp5sc", "rtsvp_st", "rtsf_stack", "rtsp0sr", "rtsf_inst", "rtsl_ust", "rtspikstim", "rtsf_str", "rtsv_ste", "rtsp6st", "rtsp6inst", "rtspJct", "rtsvp_sc", "rtsp5start", "rtsl_stall", "rtspJstim"], "rtpctx": ["rrpcas", "rotpqa", "rtpcms", "rotpaloc", "rtpectx", "rrprectx", "rtpointctx", "rtpsync", "rtperctx", "rtcpcli", "ntpccmp", "rtpcb", "rrprecoll", "rtprectx", "rdpctx", "rtvcms", "rdpcli", "rtpconn", "rtcpcmp", "rtcloc", "rtprecmp", "rtcpcb", "rtlpcb", "rtpcmp", "rtpcqa", "ntpcmp", "rtcploc", "rtapconn", "rotpctx", "rtpointcas", "rtpercmp", "rtccmp", "rdpccli", "ntpcctx", "rtvctx", "ntpcb", "rtpccoll", "rtcqa", "rtpactx", "rtpcconn", "ntpctx", "rtpcsync", "rdpccb", "rtpcctx", "rtprecas", "rtpecmp", "rtcpcontext", "rdpcb", "rrpcoll", "rtpecontext", "rotploc", "rtcpconf", "ntpccb", "rtpccms", "rotpeqa", "ntpccms", "rrprecas", "rtpcoll", "rotpectx", "rrprecmp", "ntpconn", "ntpcms", "rtlpcontext", "rtpercb", "rtcpctx", "rrpctx", "rtploc", "rtpaconf", "rtpeqa", "rotpecmp", "rotpcmp", "rtpccas", "rtpcas", "rtpacontext", "rdpcontext", "rdpcctx", "rtapcms", "ntpcsync", "rtpersync", "rtapcb", "rtlpcli", "rtpconf", "rotpconf", "rtpcli", "rotpaconf", "rtpccontext", "rtapctx", "rotpcontext", "rtpaloc", "rtlpctx", "rtcctx", "rotpacontext", "rtpqa", "rtpcontext", "rdpccontext", "rtpccli", "rtpccb", "rtcconf", "ntpsync", "rtcpsync", "rtccontext", "rtvconn", "rotpactx", "ntpcconn", "rtprecoll", "rtvcb", "rrpcmp", "rtpointcmp", "rotpecontext", "rtpccmp", "rtpointcoll"], "ptr": ["rep", "fr", "Ptr", "offset", "buff", "pr", "attr", "mp", "inst", "loc", "tr", "pb", "code", "ctx", "wr", "te", "sh", "p", "pt", "fp", "tmp", "arr", "src", "ref", "adr", "buffer", "plug", "buf", "rw", "pad", "vr", "pos", "type", "fd", "pc", "sp", "length", "port", "pair", "cap", "pack", "inter", "address", "addr", "pointer", "tag", "br"]}}
{"project": "qemu", "commit_id": "64c9bc181fc78275596649f591302d72df2d3071", "target": 0, "func": "static void do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n\n\n    assert(p->ep->nr == 0);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            usb_device_handle_control(s, p, request, value, index,\n\n                                      s->setup_len, s->data_buf);\n\n            if (p->status == USB_RET_ASYNC) {\n\n                return;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            p->actual_length = 0;\n\n        }\n\n        break;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len) {\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            }\n\n            return;\n\n        }\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        p->status = USB_RET_STALL;\n\n        break;\n\n\n\n    default:\n\n        p->status = USB_RET_STALL;\n\n    }\n\n}\n", "idx": 2047, "substitutes": {"s": ["i", "conf", "d", "v", "states", "sp", "ps", "sb", "sym", "parts", "f", "os", "as", "js", "params", "sv", "l", "si", "is", "qs", "y", "o", "ins", "se", "ses", "site", "b", "sg", "u", "ops", "sync", "h", "S", "r", "cs", "ssl", "ips", "new", "m", "sq", "bs", "session", "w", "service", "g", "us", "spec", "ks", "es", "gs", "t", "aws", "ss", "e", "ls", "ds", "xs", "fs", "ms", "su", "sets", "ts", "ns", "n", "services", "sys", "c", "rs", "self", "vs", "its"], "p": ["i", "cache", "lp", "tp", "r", "press", "mp", "bp", "l", "pb", "j", "n", "pm", "o", "y", "ep", "fp", "up", "ic", "d", "m", "per", "gp", "api", "wp", "pe", "k", "v", "py", "cp", "pc", "g", "data", "ps", "sp", "pro", "ap", "c", "pp", "pre", "app", "np", "jp", "vp", "pi", "P", "t", "proc", "b", "php", "op", "pa", "f", "q", "ip", "u", "post", "e", "parse", "cop", "h"], "request": ["create", "req", "setup", "hello", "Request", "header", "begin", "command", "rx", "key", "requ", "query", "input", "config", "call", "session", "queue", "buffer", "rf", "access", "id", "fee", "time", "charge", "event", "demand", "frame", "type", "data", "require", "callback", "parent", "work", "initial", "complete", "url", "du", "pair", "pull", "result", "condition", "response", "cost", "version", "address", "resource", "claim", "child", "use", "open", "message", "repeat", "report"], "value": ["media", "money", "update", "wa", "view", "val", "sample", "hello", "dollar", "option", "function", "values", "ue", "key", "number", "input", "Value", "min", "name", "buffer", "fee", "element", "v", "end", "change", "data", "description", "VALUE", "server", "output", "complete", "pair", "flow", "info", "result", "response", "max", "version", "range", "set", "resource", "message", "show", "password", "rule"], "index": ["update", "offset", "i", "action", "find", "open", "diff", "match", "context", "option", "key", "ind", "append", "call", "id", "Index", "element", "len", "connect", "slice", "end", "pos", "type", "position", "data", "search", "length", "include", "in", "point", "start", "weight", "image", "condition", "inc", "none", "address", "size", "page", "x", "pointer"]}}
{"project": "FFmpeg", "commit_id": "f566ac48ce450b013ffd5547ace48df8c47981c6", "target": 0, "func": "static int get_video_buffer(AVFrame *frame, int align)\n\n{\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);\n\n    int ret, i;\n\n\n\n    if (!desc)\n\n        return AVERROR(EINVAL);\n\n\n\n    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)\n\n        return ret;\n\n\n\n    if (!frame->linesize[0]) {\n\n        ret = av_image_fill_linesizes(frame->linesize, frame->format,\n\n                                      frame->width);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        for (i = 0; i < 4 && frame->linesize[i]; i++)\n\n            frame->linesize[i] = FFALIGN(frame->linesize[i], align);\n\n    }\n\n\n\n    for (i = 0; i < 4 && frame->linesize[i]; i++) {\n\n        int h = FFALIGN(frame->height, 32);\n\n        if (i == 1 || i == 2)\n\n            h = -((-h) >> desc->log2_chroma_h);\n\n\n\n        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);\n\n        if (!frame->buf[i])\n\n            goto fail;\n\n\n\n        frame->data[i] = frame->buf[i]->data;\n\n    }\n\n    if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) {\n\n        av_buffer_unref(&frame->buf[1]);\n\n        frame->buf[1] = av_buffer_alloc(1024);\n\n        if (!frame->buf[1])\n\n            goto fail;\n\n        frame->data[1] = frame->buf[1]->data;\n\n    }\n\n\n\n    frame->extended_data = frame->data;\n\n\n\n    return 0;\n\nfail:\n\n    av_frame_unref(frame);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 2049, "substitutes": {"frame": ["update", "view", "family", "series", "part", "setup", "unit", "layout", "framework", "table", "build", "position", "video", "window", "parent", "layer", "boot", "image", "block", "state", "f", "component", "cycle", "show", "fe", "draw", "host", "object", "node", "html", "buffer", "load", "hide", "event", "data", "ise", "motion", "point", "board", "fx", "style", "vert", "plot", "live", "zone", "flower", "fram", "rule", "line", "fr", "feed", "base", "code", "date", "play", "function", "document", "figure", "element", "df", "slice", "full", "scene", "game", "ze", "plane", "player", "e", "design", "dom", "model", "Frame", "die", "bug", "scale", "cf", "def", "header", "iframe", "module", "sequence", "word", "force", "fb", "fake", "file", "co", "coll", "frames", "self", "ide", "flow", "feature", "version", "range", "parse"], "align": ["ignment", "offset", "val", "diff", "padding", "replace", "binary", "aff", "aligned", "alt", "arr", " alignment", "join", "len", "pad", "format", "ext", "adjust", "border", "length", "amin", "work", "in", "margin", "aug", "balance", "style", "al", "angle", "lead", "addr", "ign", "x", "repeat"], "desc": ["comment", "dep", "dist", "cod", "dc", "diff", "disc", "decl", "loc", "des", "sc", "def", "sub", "de", "enc", "code", "ctx", "sec", "dir", "or", "ref", "src", "ec", "d", "config", "Desc", "design", "dim", "df", "asc", "rec", "esc", "ext", "func", "fd", "conn", "ca", "txt", "description", "spec", "layer", "info", "cb", "col", "dict", "proc", "meta", "der", "doc", "summary", "env", "bc", "lc"], "ret": ["rb", "match", "att", "alt", "opt", "ref", "len", "reset", "lit", "ut", "arg", "f", "bit", "rep", "res", "sr", "error", "replace", "fit", "run", "format", "success", "rets", "data", "nt", "test", "Ret", "al", "err", "ft", "it", "aud", "flag", "code", "mem", "obj", "wrap", "fun", "xt", "reg", "std", "cur", "out", "cat", "bf", "val", "fail", "value", "bad", "back", "def", "rc", "rt", "fin", "RET", "arr", "det", "pret", "end", "mt", "result", "nat", "re", "entry", "en", "art"], "i": ["hi", "phi", "ui", "anti", "io", "l", "fi", "si", "is", "j", "n", "uri", "y", "o", "p", "ci", "multi", "qi", "eni", "cli", "m", "oi", "d", "mi", "id", "api", "yi", "ori", "ri", "z", "k", "ini", "ii", "slice", "v", "bi", "x", "a", "li", "g", "iu", "ie", "c", "in", "di", "ix", "ai", "info", "pi", "t", "gi", "f", "u", "b", "ti", "ip", "ni", "e", "xi", "I", "it", "ki", "h", "lc", "s", "index"]}}
{"project": "qemu", "commit_id": "1eabfce6d53cb02066dbb0ac8471f8593ff24a24", "target": 0, "func": "static int kvm_get_msrs(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;\n\n    int ret, i;\n\n    uint64_t mtrr_top_bits;\n\n\n\n    kvm_msr_buf_reset(cpu);\n\n\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);\n\n    kvm_msr_entry_add(cpu, MSR_PAT, 0);\n\n    if (has_msr_star) {\n\n        kvm_msr_entry_add(cpu, MSR_STAR, 0);\n\n    }\n\n    if (has_msr_hsave_pa) {\n\n        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);\n\n    }\n\n    if (has_msr_tsc_aux) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);\n\n    }\n\n    if (has_msr_tsc_adjust) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);\n\n    }\n\n    if (has_msr_tsc_deadline) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);\n\n    }\n\n    if (has_msr_misc_enable) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);\n\n    }\n\n    if (has_msr_smbase) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);\n\n    }\n\n    if (has_msr_feature_control) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);\n\n    }\n\n    if (has_msr_bndcfgs) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);\n\n    }\n\n    if (has_msr_xss) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);\n\n    }\n\n\n\n\n\n    if (!env->tsc_valid) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);\n\n        env->tsc_valid = !runstate_is_running();\n\n    }\n\n\n\n#ifdef TARGET_X86_64\n\n    if (lm_capable_kernel) {\n\n        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);\n\n        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);\n\n        kvm_msr_entry_add(cpu, MSR_FMASK, 0);\n\n        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);\n\n    }\n\n#endif\n\n    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);\n\n    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);\n\n    if (has_msr_async_pf_en) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);\n\n    }\n\n    if (has_msr_pv_eoi_en) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);\n\n    }\n\n    if (has_msr_kvm_steal_time) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);\n\n    }\n\n    if (has_msr_architectural_pmu) {\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);\n\n        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);\n\n        }\n\n        for (i = 0; i < num_architectural_pmu_counters; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);\n\n            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);\n\n        }\n\n    }\n\n\n\n    if (env->mcg_cap) {\n\n        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);\n\n        if (has_msr_mcg_ext_ctl) {\n\n            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);\n\n        }\n\n        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);\n\n        }\n\n    }\n\n\n\n    if (has_msr_hv_hypercall) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);\n\n    }\n\n    if (has_msr_hv_vapic) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);\n\n    }\n\n    if (has_msr_hv_tsc) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);\n\n    }\n\n    if (has_msr_hv_crash) {\n\n        int j;\n\n\n\n        for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);\n\n        }\n\n    }\n\n    if (has_msr_hv_runtime) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);\n\n    }\n\n    if (cpu->hyperv_synic) {\n\n        uint32_t msr;\n\n\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);\n\n        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {\n\n            kvm_msr_entry_add(cpu, msr, 0);\n\n        }\n\n    }\n\n    if (has_msr_hv_stimer) {\n\n        uint32_t msr;\n\n\n\n        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;\n\n             msr++) {\n\n            kvm_msr_entry_add(cpu, msr, 0);\n\n        }\n\n    }\n\n    if (has_msr_mtrr) {\n\n        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);\n\n        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);\n\n        }\n\n    }\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    assert(ret == cpu->kvm_msr_buf->nmsrs);\n\n    /*\n\n     * MTRR masks: Each mask consists of 5 parts\n\n     * a  10..0: must be zero\n\n     * b  11   : valid bit\n\n     * c n-1.12: actual mask bits\n\n     * d  51..n: reserved must be zero\n\n     * e  63.52: reserved must be zero\n\n     *\n\n     * 'n' is the number of physical bits supported by the CPU and is\n\n     * apparently always <= 52.   We know our 'n' but don't know what\n\n     * the destinations 'n' is; it might be smaller, in which case\n\n     * it masks (c) on loading. It might be larger, in which case\n\n     * we fill 'd' so that d..c is consistent irrespetive of the 'n'\n\n     * we're migrating to.\n\n     */\n\n\n\n    if (cpu->fill_mtrr_mask) {\n\n        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);\n\n        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);\n\n        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);\n\n    } else {\n\n        mtrr_top_bits = 0;\n\n    }\n\n\n\n    for (i = 0; i < ret; i++) {\n\n        uint32_t index = msrs[i].index;\n\n        switch (index) {\n\n        case MSR_IA32_SYSENTER_CS:\n\n            env->sysenter_cs = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SYSENTER_ESP:\n\n            env->sysenter_esp = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SYSENTER_EIP:\n\n            env->sysenter_eip = msrs[i].data;\n\n            break;\n\n        case MSR_PAT:\n\n            env->pat = msrs[i].data;\n\n            break;\n\n        case MSR_STAR:\n\n            env->star = msrs[i].data;\n\n            break;\n\n#ifdef TARGET_X86_64\n\n        case MSR_CSTAR:\n\n            env->cstar = msrs[i].data;\n\n            break;\n\n        case MSR_KERNELGSBASE:\n\n            env->kernelgsbase = msrs[i].data;\n\n            break;\n\n        case MSR_FMASK:\n\n            env->fmask = msrs[i].data;\n\n            break;\n\n        case MSR_LSTAR:\n\n            env->lstar = msrs[i].data;\n\n            break;\n\n#endif\n\n        case MSR_IA32_TSC:\n\n            env->tsc = msrs[i].data;\n\n            break;\n\n        case MSR_TSC_AUX:\n\n            env->tsc_aux = msrs[i].data;\n\n            break;\n\n        case MSR_TSC_ADJUST:\n\n            env->tsc_adjust = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_TSCDEADLINE:\n\n            env->tsc_deadline = msrs[i].data;\n\n            break;\n\n        case MSR_VM_HSAVE_PA:\n\n            env->vm_hsave = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_SYSTEM_TIME:\n\n            env->system_time_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_WALL_CLOCK:\n\n            env->wall_clock_msr = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_STATUS:\n\n            env->mcg_status = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_CTL:\n\n            env->mcg_ctl = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_EXT_CTL:\n\n            env->mcg_ext_ctl = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_MISC_ENABLE:\n\n            env->msr_ia32_misc_enable = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SMBASE:\n\n            env->smbase = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_FEATURE_CONTROL:\n\n            env->msr_ia32_feature_control = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_BNDCFGS:\n\n            env->msr_bndcfgs = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_XSS:\n\n            env->xss = msrs[i].data;\n\n            break;\n\n        default:\n\n            if (msrs[i].index >= MSR_MC0_CTL &&\n\n                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {\n\n                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;\n\n            }\n\n            break;\n\n        case MSR_KVM_ASYNC_PF_EN:\n\n            env->async_pf_en_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_PV_EOI_EN:\n\n            env->pv_eoi_en_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_STEAL_TIME:\n\n            env->steal_time_msr = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_FIXED_CTR_CTRL:\n\n            env->msr_fixed_ctr_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_CTRL:\n\n            env->msr_global_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_STATUS:\n\n            env->msr_global_status = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\n            env->msr_global_ovf_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:\n\n            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;\n\n            break;\n\n        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:\n\n            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;\n\n            break;\n\n        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:\n\n            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_HYPERCALL:\n\n            env->msr_hv_hypercall = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_GUEST_OS_ID:\n\n            env->msr_hv_guest_os_id = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_APIC_ASSIST_PAGE:\n\n            env->msr_hv_vapic = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_REFERENCE_TSC:\n\n            env->msr_hv_tsc = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\n            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_VP_RUNTIME:\n\n            env->msr_hv_runtime = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SCONTROL:\n\n            env->msr_hv_synic_control = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SVERSION:\n\n            env->msr_hv_synic_version = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SIEFP:\n\n            env->msr_hv_synic_evt_page = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SIMP:\n\n            env->msr_hv_synic_msg_page = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\n            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_STIMER0_CONFIG:\n\n        case HV_X64_MSR_STIMER1_CONFIG:\n\n        case HV_X64_MSR_STIMER2_CONFIG:\n\n        case HV_X64_MSR_STIMER3_CONFIG:\n\n            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =\n\n                                msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_STIMER0_COUNT:\n\n        case HV_X64_MSR_STIMER1_COUNT:\n\n        case HV_X64_MSR_STIMER2_COUNT:\n\n        case HV_X64_MSR_STIMER3_COUNT:\n\n            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =\n\n                                msrs[i].data;\n\n            break;\n\n        case MSR_MTRRdefType:\n\n            env->mtrr_deftype = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix64K_00000:\n\n            env->mtrr_fixed[0] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix16K_80000:\n\n            env->mtrr_fixed[1] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix16K_A0000:\n\n            env->mtrr_fixed[2] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C0000:\n\n            env->mtrr_fixed[3] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C8000:\n\n            env->mtrr_fixed[4] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D0000:\n\n            env->mtrr_fixed[5] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D8000:\n\n            env->mtrr_fixed[6] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E0000:\n\n            env->mtrr_fixed[7] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E8000:\n\n            env->mtrr_fixed[8] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F0000:\n\n            env->mtrr_fixed[9] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F8000:\n\n            env->mtrr_fixed[10] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):\n\n            if (index & 1) {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |\n\n                                                               mtrr_top_bits;\n\n            } else {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2053, "substitutes": {"cpu": ["pkg", "cmp", "intel", "kernel", " CPU", "CP", "GPU", "cn", "auc", "boot", "mc", "proc", "que", "lb", "processor", "cpp", "fc", "uca", "exec", "node", "config", "vm", "hu", "gpu", "roc", "css", "pool", "comp", "performance", "CPU", "chip", "net", "sync", "lc", "cu", "android", "uci", "fi", "ctx", "core", "product", "proxy", "queue", "cp", "prem", "loader", "pc", "chrom", "pu", "ilo", "uc", "clock", "machine", "cache", "mac", "rc", "linux", "computer", "cli", "px", "platform", "consumer", "uno", "bench", "console", "ubuntu", "login", "c", "nc", "np", "ck", "nic", "hp", "instance", "cfg"], "env": ["context", "enc", "agent", "profile", "conf", "core", "eu", "ec", "pipe", "viron", "eni", "config", "cli", "net", "skin", "stage", "age", "cv", "end", "energy", "ext", "console", "path", "ea", "visor", "export", "ef", "exc", "cap", "style", "global", "oa", "gui", "err", "estate", "e", "environment", "desc", "cfg", "esp", "shell", "ev", "fg", "en", "Environment"], "msrs": [" msrd", "mmrd", "MsRs", "MsRS", " msRS", "mmrs", "msrd", "mmRs", "msRs", "mmRS", " msRs", "Msrd", "Msrs", "msRS"], "ret": ["val", "res", " RET", "rc", "code", " Ret", " pri", "num", " result", " len", "mem", " success", " flag", "k", "len", " resp", " reg", " mem", "nt", " b", " res", "Ret", "f", " e", " rc", " code"], "i": ["ui", "si", "n", "p", "ci", "uni", "id", "k", "ini", "ii", "slice", "type", "li", "c", "info", "init", "abi", "pi", "b", "f", "ti", "ni", "e", "I", "it", "phi", "index"], "mtrr_top_bits": ["mtrr_top_count", "mtrr_master_rows", "mtrr_master_bits", "mtrr_top_rows", "mtrr_master_bytes", "mtrr_master_count", "mtrr_top_bytes"]}}
{"project": "qemu", "commit_id": "2aece63c8a9d2c3a8ff41d2febc4cdeff2633331", "target": 0, "func": "host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)\n\n{\n\n    MemoryRegion *mr;\n\n\n\n    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);\n\n    if (memory_region_is_mapped(mr)) {\n\n        return false;\n\n    } else {\n\n        return true;\n\n    }\n\n}\n", "idx": 2063, "substitutes": {"mr": ["md", "MR", "fr", "Mr", "rr", "gr", "ir", "pr", "rh", "r", "mor", "gor", "sr", "rt", "pm", "mir", "wr", "er", "yr", "km", "usr", "gro", "adr", "dr", "m", "mm", "vr", "rer", "wk", "rm", "pc", "ur", "mt", "shr", "RR", "kr", "wm", "mk", "hr", "rg", "nr", "mn", "mx", "mer", "mc", "igr", "ml", "LR", "lr", "bm", "cm", "br"]}}
{"project": "FFmpeg", "commit_id": "73dacabfc9b9ef1fd2c08105fdab6238ee29c2fc", "target": 0, "func": "av_cold int ffv1_init_slice_contexts(FFV1Context *f)\n\n{\n\n    int i;\n\n\n\n    f->slice_count = f->num_h_slices * f->num_v_slices;\n\n    if (f->slice_count <= 0) {\n\n        av_log(f->avctx, AV_LOG_ERROR, \"Invalid number of slices\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (i = 0; i < f->slice_count; i++) {\n\n        FFV1Context *fs = av_mallocz(sizeof(*fs));\n\n        int sx          = i % f->num_h_slices;\n\n        int sy          = i / f->num_h_slices;\n\n        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;\n\n        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;\n\n        int sys         = f->avctx->height *  sy      / f->num_v_slices;\n\n        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;\n\n        f->slice_context[i] = fs;\n\n        memcpy(fs, f, sizeof(*fs));\n\n        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));\n\n\n\n        fs->slice_width  = sxe - sxs;\n\n        fs->slice_height = sye - sys;\n\n        fs->slice_x      = sxs;\n\n        fs->slice_y      = sys;\n\n\n\n        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *\n\n                                      sizeof(*fs->sample_buffer));\n\n        if (!fs->sample_buffer)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n    return 0;\n\n}\n", "idx": 2083, "substitutes": {"f": ["field", "fr", "bf", "inf", "feed", "family", "diff", "fac", "cf", "form", "l", "fc", "fi", "fab", "def", "j", "conf", "function", "p", "fp", "ref", "fl", "fo", "tf", "m", "d", "af", "framework", "rf", "w", "fb", "fm", "df", "fen", "full", "v", "of", "k", "fd", "file", "g", "flat", "uf", "sf", "fw", "c", "fun", "self", "fa", "flow", "lf", "info", "files", "fx", "t", "feature", "u", "b", "this", "e", "x", "raf", "F", "s", "fe", "h"], "i": ["hi", "phi", "ui", "im", "io", "it", "l", "fi", "si", "j", "n", "uri", "y", "o", "p", "ci", "multi", "qi", "ind", "eni", "d", "m", "id", "z", "I", "mi", "api", "ri", "area", "ini", "ii", "k", "ij", "v", "bi", "mini", "li", "ami", "ie", "iu", "c", "zi", "di", "ix", "ai", "info", "start", "pi", "gi", "u", "b", "ti", "ip", "ni", "e", "xi", "x", "inner", "ki", "s", "index"], "fs": ["FS", "fn", "fr", "bf", "feed", "flows", "times", "uses", "flags", "ms", "cells", "ports", "cf", "ts", "ns", "fc", "fi", "cs", "fps", "ums", "fer", "pages", "linux", "qs", "fp", "ips", "fields", "tf", "rows", "fat", "bs", "fb", "df", "full", "ves", "fd", "rets", "file", "ps", "uf", "vers", "flat", "frames", "ks", "fw", "sf", "vals", "rs", "lines", "obs", "outs", "files", "gs", "Fs", "posts", "fx", "args", "vs", "reads", "features", "ows", "os", "irs", "json", "utils", "ls", "fits", "ds", "raf", "lf", "s", "fe"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_pwt_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t value, unsigned size)\n\n{\n\n    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_write8(opaque, addr, value);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* FRC */\n\n        s->frc = value & 0x3f;\n\n        break;\n\n    case 0x04:\t/* VRC */\n\n        if ((value ^ s->vrc) & 1) {\n\n            if (value & 1)\n\n                printf(\"%s: %iHz buzz on\\n\", __FUNCTION__, (int)\n\n                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */\n\n                                ((omap_clk_getrate(s->clk) >> 3) /\n\n                                 /* Pre-multiplexer divider */\n\n                                 ((s->gcr & 2) ? 1 : 154) /\n\n                                 /* Octave multiplexer */\n\n                                 (2 << (value & 3)) *\n\n                                 /* 101/107 divider */\n\n                                 ((value & (1 << 2)) ? 101 : 107) *\n\n                                 /*  49/55 divider */\n\n                                 ((value & (1 << 3)) ?  49 : 55) *\n\n                                 /*  50/63 divider */\n\n                                 ((value & (1 << 4)) ?  50 : 63) *\n\n                                 /*  80/127 divider */\n\n                                 ((value & (1 << 5)) ?  80 : 127) /\n\n                                 (107 * 55 * 63 * 127)));\n\n            else\n\n                printf(\"%s: silence!\\n\", __FUNCTION__);\n\n        }\n\n        s->vrc = value & 0x7f;\n\n        break;\n\n    case 0x08:\t/* GCR */\n\n        s->gcr = value & 3;\n\n        break;\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        return;\n\n    }\n\n}\n", "idx": 2084, "substitutes": {"opaque": ["operae", "hopque", "opac", "iopaque", " opac", "opca", "iopacity", "operque", "opatile", "pac", "opque", "opae", " opae", " opque", "operca", "patile", " opatile", "operacity", " opacity", "paque", " oprobe", "iopca", "opacity", "hopaque", "hoprobe", "hopacity", "pae", "operatile", " opca", "oprobe", "operrobe", "operac", "operaque"], "addr": ["host", "offset", "mac", "socket", "base", "part", "r", "error", "device", "rc", "ptr", "ord", "padding", "code", "ack", "array", "cmp", "sid", "alt", "p", "ref", "src", "alias", "ada", "node", "adr", "dr", "eni", "ock", "delay", "id", "entry", "amd", "ad", "len", "mode", "pad", "off", "a", "x", "pos", "prefix", "data", "afi", "slot", "server", "port", "point", "target", "start", "layer", "asm", "ace", "oa", "cmd", "align", "address", "e", "Address", "pointer", "seq", "index"], "value": ["all", "total", "match", "array", "num", "key", "number", "d", "v", "video", "parent", "complete", "image", "variable", "cost", "set", "message", "media", "serial", "expression", "wave", "hello", "object", "null", "values", "p", "valid", "node", "name", "buffer", "fee", "buf", "trial", "format", "python", "data", "price", "port", "current", "response", "slave", "h", "comment", "offset", "function", "m", "w", "service", "member", "length", "VALUE", "server", "reg", "item", "pair", "native", "address", "child", "paid", "volume", "password", "money", "val", "attribute", "scale", "padding", "reference", "vector", "byte", "Value", "memory", "end", "type", "initial", "amount", "result", "gi", "version", "resource", "one", "timeout", "entry", "content"], "size": ["offset", "val", "shift", "scale", "sync", "padding", "code", "from", "sec", " address", "or", "number", "name", "fee", " length", "capacity", "len", "count", "data", "length", "ize", "small", "align", "address", "e", "empty", "timeout", "bytes", "sized", "en", "Size", "SIZE"], "s": ["S", "fs", "socket", "r", "su", "sync", "sets", "ts", "ns", "hs", "settings", "cs", "is", "si", "uns", "sec", "conf", "ssl", "o", "p", "new", "ins", "m", "d", "session", "sq", "secondary", "w", "v", "a", "services", "stats", "sys", "service", "g", "sie", "states", "native", "ps", "us", "ses", "spec", "sf", "c", "rs", "sb", "es", "self", "site", "scope", "params", "gs", "sym", "args", "t", "os", "f", "sg", "b", "this", "address", "ss", "js", "e", "ls", "side", "ds", "h"]}}
{"project": "FFmpeg", "commit_id": "b164d66e35d349de414e2f0d7365a147aba8a620", "target": 0, "func": "static void predictor_decode_mono(APEContext *ctx, int count)\n\n{\n\n    APEPredictor *p = &ctx->predictor;\n\n    int32_t *decoded0 = ctx->decoded[0];\n\n    int32_t predictionA, currentA, A, sign;\n\n\n\n    currentA = p->lastA[0];\n\n\n\n    while (count--) {\n\n        A = *decoded0;\n\n\n\n        p->buf[YDELAYA] = currentA;\n\n        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];\n\n\n\n        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +\n\n                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +\n\n                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +\n\n                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];\n\n\n\n        currentA = A + (predictionA >> 10);\n\n\n\n        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);\n\n        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);\n\n\n\n        sign = APESIGN(A);\n\n        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;\n\n        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;\n\n        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;\n\n        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;\n\n\n\n        p->buf++;\n\n\n\n        /* Have we filled the history buffer? */\n\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n\n            memmove(p->historybuffer, p->buf,\n\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n\n            p->buf = p->historybuffer;\n\n        }\n\n\n\n        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);\n\n        *(decoded0++) = p->filterA[0];\n\n    }\n\n\n\n    p->lastA[0] = currentA;\n\n}\n", "idx": 2093, "substitutes": {"ctx": ["kb", "cc", "pkg", "tp", "loc", "sc", "cf", "cpp", "rc", "context", "cs", "pb", "conv", "core", "cca", "fp", "exec", "ci", "connection", "xc", "cli", "config", "cam", "input", "wp", "qa", "Context", "sci", "tc", "cv", "cp", "conn", "pc", "ca", "cn", "c", "ctrl", "nc", "np", "parser", "mc", "cb", "tx", "hp", "cmd", "client", "utils", "bc", "cas", "cm", "anc"], "count": ["loop", "cache", "cc", "Count", "val", "part", "base", "cond", "context", "code", "num", "key", "group", "number", "ind", "call", "force", "id", "len", "type", "list", "coll", "batch", "parent", "length", "c", "comp", "test", "amount", "counter", "weight", "depth", "process", "col", "max", "b", "child", "C", "seq"], "p": ["i", "lp", "part", "pkg", "private", "pb", "pm", "er", "d", "wp", "v", "sp", "ps", "parent", "plugin", "jp", "pi", "P", "proc", "f", "this", "post", "cop", "s", "press", "l", "y", "o", "exec", "pd", "up", "per", "gp", "python", "data", "app", "pp", "comp", "point", "current", "parser", "b", "q", "op", "u", "it", "h", "pg", "tp", "r", "mp", "bp", "project", "at", "m", "w", "full", "cp", "pc", "g", "ap", "pre", "prev", "process", "t", "ip", "e", "http", "progress", "cache", "j", "n", "fp", "api", "k", "py", "a", "c", "after", "self", "np", "vp", "local", "get", "hp", "pa", "parse", "client"], "decoded0": ["decoded1", "decached4", "decached1", "decided4", " decided1", "deccoded1", "decrypted1", "decaned0", " decided4", "decrypted4", "decaned1", "decoded192", "decided1", " decoded1", "deccoded4", " decoded192", "decaned4", "decached0", "decided0", " decided192", "deccoded192", " decided0", "decoded4", "deccoded0", "decided192", " decoded4", "decached192", "decrypted0"], "predictionA": ["preditionN", "Predicteda", "PredictedB", "predictionC", "predisonY", "predolutionB", " predictionB", "PredictedC", "predicteda", "PredictionN", "PredictedN", " predictionN", "preditionA", "predictionsa", "predisonB", "predicationN", "predisonN", "PredictionC", "predolutionA", "predictiona", "predictionB", " predictedA", "predictedB", "predictionN", "PredictionA", "predictedN", " predictionY", "PredictedA", "predictionsA", "predisonA", "predolutiona", "Predictiona", "predictionsN", " predictedB", " predictedY", "PredictionB", "predicationA", "predictionsB", "predictedA", "predictedC", "predictionY", "preditionC", "predicationC", " predictedN", "predictedY", "predictionsY"], "currentA": ["presentAn", "currentP", "reportedAPI", "CurrentY", "reportedAverage", " currentAPI", "CurrentA", " currentN", " currentArray", "reportedArray", "currentAn", " currentP", "CurrentD", "reportedB", "reportedAn", " currentAn", "currentY", " currentAverage", "currentAPI", "reportedA", "presentN", "reportedD", "CurrentP", "currentArray", " currentY", "reportedN", "currentB", "contentN", " currentD", "contentArray", "contentAPI", " currentB", "CurrentAverage", "reportedP", "reportedY", "currentAverage", "presentA", "presentP", "currentD", "CurrentB", "contentA", "currentN"], "A": ["Adam", "U", "SA", "S", "AP", "K", "X", "array", "PA", "NA", "L", "Sign", "AV", "Alpha", "B", "AF", "AM", "alpha", "V", "w", "Y", "sa", "CA", "aw", "mA", "aa", "am", "a", "D", "AC", "G", "HA", "EA", "M", "ai", "W", "AA", "P", "API", "LA", "AR", "ASC", "amp", "AW", "au", "C", "N", "I", "Q", "Am", "H", "T"], "sign": ["draw", " sig", "sw", "action", "ident", "value", "scan", "vis", " SIGN", "scale", "sc", "form", "match", "sub", "SIGN", "enc", "close", "sh", "Sign", "key", "act", "ind", "tick", "sq", "min", "se", "check", "lex", "sum", "connect", "keep", "dig", "ment", "contract", "change", "type", "mix", "search", "spec", "shape", "dash", "start", "plus", "cap", "pack", "max", "save", "inc", "fix", "space", "ver", "set", "ss", "parse", "pass", "ign", "x", "pull", "IGN", "step"], "buf": ["uv", "cat", "agg", "cache", "rb", "home", "av", "pkg", "buff", "loc", "cf", "comb", "rc", "uu", "context", "code", "num", "header", "conv", "lim", "img", "begin", "alloc", "src", "bg", "ff", "hist", "raw", "config", "append", "queue", "buffer", "bt", "vec", "pub", "bn", "cv", "fam", "dest", "feat", "batch", "uf", "port", "bag", "pool", "map", "bh", "auc", "prof", "block", "cb", "cap", "nat", "la", "history", "bin", "box", "cmd", "carry", "hal", "cur", "wb", "doc", "aux", "bc", "cas", "uc", "bu", "seq", "br"]}}
{"project": "FFmpeg", "commit_id": "17ee7b5515cd1006a1f7ba4a9cced14f6526c1b0", "target": 0, "func": "static void print_report(AVFormatContext **output_files,\n\n                         AVOutputStream **ost_table, int nb_ostreams,\n\n                         int is_last_report)\n\n{\n\n    char buf[1024];\n\n    AVOutputStream *ost;\n\n    AVFormatContext *oc;\n\n    int64_t total_size;\n\n    AVCodecContext *enc;\n\n    int frame_number, vid, i;\n\n    double bitrate, ti1, pts;\n\n    static int64_t last_time = -1;\n\n    static int qp_histogram[52];\n\n\n\n    if (!is_last_report) {\n\n        int64_t cur_time;\n\n        /* display the report every 0.5 seconds */\n\n        cur_time = av_gettime();\n\n        if (last_time == -1) {\n\n            last_time = cur_time;\n\n            return;\n\n        }\n\n        if ((cur_time - last_time) < 500000)\n\n            return;\n\n        last_time = cur_time;\n\n    }\n\n\n\n\n\n    oc = output_files[0];\n\n\n\n    total_size = avio_size(oc->pb);\n\n    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too\n\n        total_size= avio_tell(oc->pb);\n\n\n\n    buf[0] = '\\0';\n\n    ti1 = 1e10;\n\n    vid = 0;\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        float q= -1;\n\n        ost = ost_table[i];\n\n        enc = ost->st->codec;\n\n        if(!ost->st->stream_copy && enc->coded_frame)\n\n            q= enc->coded_frame->quality/(float)FF_QP2LAMBDA;\n\n        if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"q=%2.1f \", q);\n\n        }\n\n        if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            float t = (av_gettime()-timer_start) / 1000000.0;\n\n\n\n            frame_number = ost->frame_number;\n\n            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"frame=%5d fps=%3d q=%3.1f \",\n\n                     frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);\n\n            if(is_last_report)\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"L\");\n\n            if(qp_hist){\n\n                int j;\n\n                int qp= lrintf(q);\n\n                if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram))\n\n                    qp_histogram[qp]++;\n\n                for(j=0; j<32; j++)\n\n                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"%X\", (int)lrintf(log(qp_histogram[j]+1)/log(2)));\n\n            }\n\n            if (enc->flags&CODEC_FLAG_PSNR){\n\n                int j;\n\n                double error, error_sum=0;\n\n                double scale, scale_sum=0;\n\n                char type[3]= {'Y','U','V'};\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"PSNR=\");\n\n                for(j=0; j<3; j++){\n\n                    if(is_last_report){\n\n                        error= enc->error[j];\n\n                        scale= enc->width*enc->height*255.0*255.0*frame_number;\n\n                    }else{\n\n                        error= enc->coded_frame->error[j];\n\n                        scale= enc->width*enc->height*255.0*255.0;\n\n                    }\n\n                    if(j) scale/=4;\n\n                    error_sum += error;\n\n                    scale_sum += scale;\n\n                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"%c:%2.2f \", type[j], psnr(error/scale));\n\n                }\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"*:%2.2f \", psnr(error_sum/scale_sum));\n\n            }\n\n            vid = 1;\n\n        }\n\n        /* compute min output value */\n\n        pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base);\n\n        if ((pts < ti1) && (pts > 0))\n\n            ti1 = pts;\n\n    }\n\n    if (ti1 < 0.01)\n\n        ti1 = 0.01;\n\n\n\n    if (verbose || is_last_report) {\n\n        bitrate = (double)(total_size * 8) / ti1 / 1000.0;\n\n\n\n        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n\n            \"size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s\",\n\n            (double)total_size / 1024, ti1, bitrate);\n\n\n\n        if (nb_frames_dup || nb_frames_drop)\n\n          snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \" dup=%d drop=%d\",\n\n                  nb_frames_dup, nb_frames_drop);\n\n\n\n        if (verbose >= 0)\n\n            fprintf(stderr, \"%s    \\r\", buf);\n\n\n\n        fflush(stderr);\n\n    }\n\n\n\n    if (is_last_report && verbose >= 0){\n\n        int64_t raw= audio_size + video_size + extra_size;\n\n        fprintf(stderr, \"\\n\");\n\n        fprintf(stderr, \"video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\\n\",\n\n                video_size/1024.0,\n\n                audio_size/1024.0,\n\n                extra_size/1024.0,\n\n                100.0*(total_size - raw)/raw\n\n        );\n\n    }\n\n}\n", "idx": 2110, "substitutes": {"output_files": ["output_frames", "input_files", " output_file", "input_bytes", " output_frames", "outputmatfile", "input_file", "output_file", "output_images", "outputmatimages", "outputmatbytes", "outputmatfiles", " output_images", "input_images", "output_bytes"], "ost_table": ["rss_system", "rss_list", "output_list", "ost_buffer", "ostallsystem", "ostalllist", "output_file", "ostslist", "oststable", "rss_buffer", "ost_system", "ost_list", "ostsfile", "ostalltable", "ostallbuffer", "output_buffer", "output_table", "ostsbuffer", "rss_table", "ost_file"], "nb_ostreams": ["nb_ostrawes", "nb_ststreams", "nb_ostlogers", "nb_odaccountsites", "nb_ostaccountlets", "nb_ostaccountsites", "nb_ostlogd", "nb_ostreamlets", "nb_odaccountlets", "nb_ststreamd", "nb_ostroundsites", "nb_odreams", "nb_odaccountes", "nb_ststreamers", "nb_oststreamd", "nb_osteces", "nb_streamd", "nb_streames", "nb_ostraws", "nb_streamers", "nb_oststreames", "nb_ostroundlets", "nb_osteclets", "nb_ostreamd", "nb_ststreames", "nb_ostecs", "nb_odreamlets", "nb_ostecsites", "nb_ostrawd", "nb_ostloges", "nb_ostlogs", "nb_odaccounts", "nb_ostroundes", "nb_oststreams", "nb_ostreamsites", "nb_ostaccounts", "nb_oststreamers", "nb_ostrounds", "nb_ostrawers", "nb_ostaccountes", "nb_ostreames", "nb_streams", "nb_odreames", "nb_odreamsites", "nb_ostreamers"], "is_last_report": ["is_next_write", "is_lastayreport", "is_next_reported", "is_last_info", "is_next_time", "is_lastmrun", "is_last_source", "is_this_report", "is_this_run", "is_last__report", "is_last_time", "is_lastalsummary", "is_lastalinfo", "is_lastalreport", "is_lastayinfo", "is_last__source", "is_last__reported", "is_this_reported", "is_lastayprint", "is_last__run", "is_full_info", "is_last_print", "is_lastalprint", "is_full_summary", "is_this_source", "is_full_report", "is_last_write", "is_full_print", "is_lastaysummary", "is_lastmreported", "is_next_report", "is_last_run", "is_lastmreport", "is_last_reported", "is_last_summary", "is_lastmsource"], "buf": ["rb", "text", "pkg", "buff", "fab", "pb", "usr", " buffer", "Buffer", "bus", "fd", "feat", "Buff", "bh", "auc", "cb", "cap", "proc", "f", "wb", "bc", "lb", "msg", "br", "uu", "font", "tmp", "bg", "config", "buffer", "cv", "fam", "data", "port", "bag", "pool", "ph", "prof", "ucc", "box", "b", "btn", "aux", "bytes", "h", "grab", "ctx", "bd", "ab", "queue", "pad", "front", "batch", "txt", "border", "cmd", "bur", "raf", "uc", "bf", "cache", "loc", "rc", "img", "bb", "fp", "src", "af", "bed", "vec", "fb", "uf", "fw", "wav", "bu", "seq"], "ost": ["host", "ocol", "soc", "oss", "od", "loc", "inst", "orb", "o", "st", "opt", "src", "odi", "adr", "ct", "ott", "sta", "obj", "voc", "et", "org", "rog", "oster", "ld", "oh", "est", "roc", "ocr", "obo", "ast", "iol", "nt", "oop", "ot", "obs", "oid", "ob", "omm", "ist", "omp", "ood", "iot", "om", "OC", "os", "annot", "op", "osta", "OST", "rob", "post", "sl", "oper", "osi"], "oc": ["ocol", "soc", "oca", "cc", "loc", "od", "ac", "ok", "oo", "orb", "o", "ec", "oci", "config", "obj", "voc", "org", "ocl", "oco", "rec", "ogg", "cot", "ou", "pc", "roc", "ocr", "og", "co", "mot", "output", "c", "nt", "obs", "oid", "ob", "toc", "om", "osc", "OC", "os", "op", "cur", "iv", "oper", "http", "uc"], "total_size": [" total_source", "last_size", "total67time", "last_number", "total_shape", "total67size", "total67storage", "last_time", "total_grade", "total_speed", "total_time", " total_time", "totallexspeed", "total67source", "total_storage", "total64time", "totallexsize", "totallexshape", "total_source", " total_grade", "total_capacity", "total64shape", "total_number", " total_shape", "total64speed", "total64size", "totallextime", " total_capacity", " total_speed", " total_storage"], "enc": ["fr", "cod", "loc", "od", "inst", "en", "ac", "equ", "fc", "ctx", "img", "sec", "code", "lib", "vc", "sel", "exec", "anc", "orc", "ic", "ssl", "ec", "ENC", "act", "oder", "obj", "voc", "Enc", "ens", "et", "hl", "rec", "ang", "cot", "conn", "ant", "sys", "roc", "ou", "ext", "iq", "coll", "c", "nt", "comp", "eng", "nc", "ot", "util", "ob", "arch", "auc", "ch", "nec", "ent", "proc", "inc", "cur", "env", "sl", "iv", "ct", "ew", "qt", "emb", "ev", "cel"], "frame_number": ["frameIdobject", "frame64number", " frame_size", " frame_no", "frame_no", "frame_source", " frame_length", "frame64no", "frame_size", " frame_object", " frame_notation", " frame_len", "frame_position", "frame_reference", "frame_len", "frame64size", "frame_object", "frameidobject", "frame64length", " frame_position", " frame_resolution", "frameidnumber", "frameidsource", " frame_source", " frame_reference", "frameIdsource", "frame_length", "frame_notation", "frameidno", "frame_resolution", "frameIdnumber", "frameIdno"], "vid": ["vd", "host", "cat", "voice", "dc", "cod", "vt", "device", "bid", "uri", "sid", "kind", "vc", "ci", "virt", "act", "pin", "dr", "var", "vision", "pid", "rev", "id", "liv", "voc", "win", "vec", "verb", "cdn", "slice", "v", "vr", "cv", "feat", "year", "lan", "duration", "port", "nc", "oid", "di", "gd", "vp", "seed", "vi", "pi", "vert", "vs", "vv", "version", "ver", "ip", "live", "iv", "uid", "vir", "VID", "quad", "volume", "index", "aud"], "i": ["hi", "udi", "chi", "ui", "anti", "io", "it", "l", "fi", "si", "uri", "n", "y", "ani", "p", "ci", "multi", "qi", "oci", "eni", "oi", "pid", "id", "mi", "ori", "isin", "adi", "ri", "ini", "ii", "v", "x", "li", "ami", "iu", "ie", "c", "zi", "di", "ai", "info", "vi", "pi", "gi", "u", "ti", "ip", "ni", "e", "xi", "I", "inner", "phi", "yi", "index"], "bitrate": ["bitsrate", "bitsspeed", "bitspeed", " bitwidth", "bytewidth", "byterate", "bitswidth", " bitspeed", "bitwidth", "bytespeed"], "ti1": ["taone", "ta1", "ti2", "sione", "si0", "tu1", "tione", "tu0", "ti0", "TI1", "si1", "tuone", "ta0", "TI0", "ta2", "si2", "tu2", "TI2"], "pts": ["nti", "hosts", "ptps", "nts", "ntps", "ctps", "cti", "ntsets", "ctsets", "pti", "cts", "hosti", "ptsets", "hostps", "hostsets"], "qp_histogram": ["qp_memor", "qp_memograms", "qp_highor", "qp2Histogram", "qp2histogram", "qp_membar", "qp_highogram", "qp2histbar", "qp2Histograms", "qp_Histogram", "qp_histbar", "qp_Histograms", "qp2histor", "qp_Histbar", "qp_Histor", "qp_highbar", "qp_histograms", "qp_histor", "qp2Histor", "qp_highograms", "qp_memogram", "qp2histograms", "qp2Histbar"], "cur_time": [" cur_id", "cur_times", "recent_name", " cur_times", "recent_times", "recentldelay", "last_name", "last_file", "cur_id", "recentlname", "curJtimes", "recent_delay", "recentltime", " cur_volume", "cur_delay", "last_time", " last_depth", "cur_file", "last_times", "curlname", "curJfile", "recentltimes", "cur_depth", " cur_weight", "curJtime", "curldelay", "cur_name", "curltimes", "cur_volume", " cur_ime", " last_time", "cur_weight", "curJname", "recent_time", " last_times", "cur_ime", "curltime"]}}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static av_always_inline void rv40_strong_loop_filter(uint8_t *src,\n\n                                                     const int step,\n\n                                                     const int stride,\n\n                                                     const int alpha,\n\n                                                     const int lims,\n\n                                                     const int dmode,\n\n                                                     const int chroma)\n\n{\n\n    int i;\n\n\n\n    for(i = 0; i < 4; i++, src += stride){\n\n        int sflag, p0, q0, p1, q1;\n\n        int t = src[0*step] - src[-1*step];\n\n\n\n        if (!t)\n\n            continue;\n\n\n\n        sflag = (alpha * FFABS(t)) >> 7;\n\n        if (sflag > 1)\n\n            continue;\n\n\n\n        p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] +\n\n              26*src[ 0*step] + 25*src[ 1*step] +\n\n              rv40_dither_l[dmode + i]) >> 7;\n\n\n\n        q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] +\n\n              26*src[ 1*step] + 25*src[ 2*step] +\n\n              rv40_dither_r[dmode + i]) >> 7;\n\n\n\n        if (sflag) {\n\n            p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims);\n\n            q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims);\n\n        }\n\n\n\n        p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 +\n\n              25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7;\n\n        q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] +\n\n              25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7;\n\n\n\n        if (sflag) {\n\n            p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims);\n\n            q1 = av_clip(q1, src[ 1*step] - lims, src[ 1*step] + lims);\n\n        }\n\n\n\n        src[-2*step] = p1;\n\n        src[-1*step] = p0;\n\n        src[ 0*step] = q0;\n\n        src[ 1*step] = q1;\n\n\n\n        if(!chroma){\n\n            src[-3*step] = (25*src[-1*step] + 26*src[-2*step] +\n\n                            51*src[-3*step] + 26*src[-4*step] + 64) >> 7;\n\n            src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] +\n\n                            51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7;\n\n        }\n\n    }\n\n}\n", "idx": 2115, "substitutes": {"src": ["gl", "dist", "view", "rb", "text", "req", "sub", "cmp", "grad", "sec", "num", "sel", "lib", "usr", "reflect", "rss", "stat", "sci", "build", "https", "feat", "iu", "sb", "aug", "cb", "proc", "iv", "bc", "go", "cont", "filename", "host", "ui", "inst", "sr", "sort", "secure", "sit", "sites", "obl", "conv", "st", "impl", "bg", "ind", "swing", "config", "stage", "hl", "cv", "dest", "url", "comp", "seed", "pack", "reach", "b", "u", "btn", "sup", "sync", "rect", "support", "supp", "transform", "shift", "sc", "scenes", "ssl", "stack", "slice", "gn", "asc", "stream", "gz", "length", "spec", "chrom", "scripts", "cur", "size", "sl", "use", "http", "uc", "source", "uv", "agg", "sur", "loc", "attr", "rc", "img", "low", "scl", "control", "input", "integ", "rest", "connect", "expl", "sys", "upload", "c", "gb", "start", "upp"], "step": ["phase", "part", "ste", "match", "grad", "sec", "drop", "key", "group", "d", "walk", "shock", "Step", "beta", "steps", "weight", "layer", "boot", "move", "gap", "push", "space", "set", "page", "draw", "mod", "option", "stroke", "trace", "seq", "config", "name", "stage", "trial", "load", "route", "run", "mode", "prop", "test", "seed", "transfer", "style", "ct", "pointer", "sync", "next", "offset", "lock", "transform", "shift", "patch", "STEP", "session", "slice", "pad", "sleep", "change", "mix", "batch", "length", "shape", "amp", "ip", "progress", "path", "index", "loop", "action", "back", "scale", "form", "wait", "input", "split", "delay", "id", "dim", "stop", "class", "frame", "type", "dash", "direction", "start", "flow", "depth", "version", "pass", "x", "repeat", "order"], "stride": ["STRide", "STRider", "STRade", "ocride", "collided", "strade", "Strided", "errade", "errider", "stIDE", "erriding", "Stride", "strides", "strided", "StrIDE", "stides", "ocrider", "collide", "erride", "striding", "stided", "stide", "strider", "collIDE", "ocrade", "collides", "ocriding", "strIDE", "STRiding", "Strides"], "alpha": ["linear", "offset", "phase", "scale", "sc", "ac", "rc", "ta", "si", "lambda", "Alpha", "filter", "A", "appa", "af", "acl", "acc", "sha", "xa", "ma", "sa", "asc", "aa", "beta", "a", "pha", "\u03b1", "rot", "la", "audio", "inc", "amp", "da", "phi", "igma"], "lims": ["liggs", "Limgs", "lamps", "vels", "velits", "imes", "volports", "limports", "ims", "lamp", "imi", "lamcs", " Limits", " limes", "Lims", "lifits", "velgs", "dirs", "lifs", "milcs", "pls", "ligports", "limi", "mils", "lifgs", "Limports", "ples", "ligs", "limps", " limcs", "dirits", " limgs", "limgs", "milp", " limports", " Limports", " limi", "lams", "limcs", "limp", "Limits", "imps", "plps", "limits", "dirports", " limps", "vols", " Lims", "pli", "limes", "volgs", " limits", "milps", " limp"], "dmode": ["sdapter", " dMode", "gphase", "rdmem", "ptool", "pdmodule", "rmode", "pmodule", "pdloop", "rmodule", "dloop", "sdloop", "gmem", "dmem", "ldmode", "dtool", "dphase", "pguide", "sdmodule", "dguide", "sdphase", "sdlane", "rmem", " dmodule", "dapter", "dMode", "ldmodule", " dloop", "gmodule", "rdlane", "madapter", "rguide", "pdapter", "sdmode", "pdtone", "vdmodule", "vdtool", "rdphase", "ldMode", "pdMode", "sdtone", "dtone", "madloop", "ldloop", "vdguide", "madmode", "pdmode", "vdmode", "rtool", "gmode", "dlane", "rdmodule", "madtone", "dmodule", "rdmode", "glane", "pmode", "rphase"], "chroma": ["alphsa", "chronac", "chronsa", "chronama", "norma", "alphac", "chromac", "normsa", "normac", "chromama", "alphama", "chrona", "chromsa", "normama"], "i": ["hi", "chi", "ui", "im", "io", "r", "l", "ik", "si", "is", "j", "n", "uri", "o", "p", "ci", "multi", "qi", "eni", "d", "m", "cli", "mi", "ori", "I", "id", "k", "ini", "ii", "v", "bi", "li", "ami", "iu", "ie", "c", "zi", "di", "ix", "ai", "info", "pi", "t", "gi", "f", "b", "u", "ti", "ei", "ip", "ni", "e", "xi", "x", "it", "phi", "yi", "index"], "sflag": [" slen", " sforge", "nlag", "cforce", "sforce", "psfd", "slen", "sret", " sflags", "Sflags", "cret", "secondaryforge", " sforce", "nflags", "tforce", "ncount", "Slag", "sfun", "siflag", "osflag", "tsflag", "siquad", "cfun", "psflag", " sfd", "oskill", " sret", "Sflag", "pflags", "cflag", "secondaryret", "nflag", "tsfd", "tslen", "Scount", " sstatus", "pflag", "silag", "tfun", " slag", "osret", "siflags", "psstatus", "tret", "osforge", " skill", " sfun", "scount", "sflags", "pquad", "secondarykill", "pslen", "secondaryflag", "sstatus", "sfd", "tsstatus", " squad", "plag", "tflag", "skill", "sforge", "squad", "slag"], "p0": ["f6", "a2", "q93", "g93", "f0", "ap1", "a0", " p00", "a00", "a1", "P6", " p50", "pr50", "pfrom", "pt0", "ip5", "ip1", "q2", "p93", "P2", "g0", "p50", "tnn", " pok", "q050", "p00", "pt050", "pt1", "ptfrom", "apfrom", "g5", "f2", " p6", "pok", "prnn", "prok", "qfrom", "P0", "ip0", "ap0", "p5", "t0", " p2", "P1", "pnn", "p6", "pr0", "q5", "p2", "p050", "ip93", "ap050", "f1", "t50", "g1", "q00", "tok", " pnn"], "q0": ["qu100", "Q1", "q80", "qu180", " q00", "qt0", "qt6", "qu48", "qu0", "Q80", "sqfrom", "sq6", "dq90", "qkn", " q48", "q8", "q180", "q6", "dq00", "y90", "sq0", "q3", "y00", "q100", "qa180", "qu00", "sq3", "y0", "sq90", "sq00", "q48", "y8", " qfrom", " q6", "sq48", "p00", "Q00", "qt3", "v80", "p80", "qa100", "v00", "q90", "qfrom", "p180", "qu1", "dq0", "Q0", "qa0", "dq8", " q3", " qkn", "sqkn", "sq8", "v0", "q00", "v1", "qa1", "p100", "qufrom", "qtkn"], "p1": ["c1", "qone", "sp0", "qainstance", "pinstance", "sp1", "ipn", "pg0", "ip1", "cone", "sOne", "h0", "qaOne", "hinstance", "pgOne", "uone", "s1", "cOne", "hOne", "spOne", "pg1", "spone", "uOne", "ipOne", "h1", "pone", "sone", "c0", "ip0", "qn", "qa0", "pn", "qOne", " pOne", "pOne", " pn", "s0", "u0", "u1", "pginstance", "qa1"], "q1": ["sq1", "qone", "kone", "dqone", "q81", "sqone", " q81", "k1", "k9", "sq0", "q9", "sq9", "dq81", "p9", "pone", "dq1", "dq0", "p81", "k0", " qone"]}}
{"project": "qemu", "commit_id": "03fcbd9dc5084ff4676c153fbe04fb0fcf939d09", "target": 1, "func": "DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)\n\n{\n\n    DeviceClass *dc;\n\n    const char *driver, *path;\n\n    DeviceState *dev;\n\n    BusState *bus = NULL;\n\n    Error *err = NULL;\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    if (!driver) {\n\n        error_setg(errp, QERR_MISSING_PARAMETER, \"driver\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find driver */\n\n    dc = qdev_get_device_class(&driver, errp);\n\n    if (!dc) {\n\n        return NULL;\n\n    }\n\n\n\n    /* find bus */\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path, errp);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n\n            error_setg(errp, \"Device '%s' can't go on %s bus\",\n\n                       driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus || qbus_is_full(bus)) {\n\n            error_setg(errp, \"No '%s' bus found for device '%s'\",\n\n                       dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {\n\n        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    if (!migration_is_idle()) {\n\n        error_setg(errp, \"device_add not allowed while migrating\");\n\n        return NULL;\n\n    }\n\n\n\n    /* create device */\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n\n\n\n\n\n    }\n\n\n\n    qdev_set_id(dev, qemu_opts_id(opts));\n\n\n\n    /* set properties */\n\n    if (qemu_opt_foreach(opts, set_property, dev, &err)) {\n\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        dev->opts = NULL;\n\n\n    }\n\n    return dev;\n\n\n\nerr_del_dev:\n\n    error_propagate(errp, err);\n\n    object_unparent(OBJECT(dev));\n\n    object_unref(OBJECT(dev));\n\n    return NULL;\n\n}", "idx": 2124, "substitutes": {"opts": [" opt", "okts", "Opps", "okps", "opTS", "opfs", "opns", "optcs", "iopcs", "iopouts", "popt", "optps", "okt", "OPcs", "optts", "copcs", " opps", "otts", "operts", "opt", " opcs", "copfs", "optfs", "OPt", "copts", "popts", "otps", "prets", " opouts", "optt", "copps", "ott", "preted", "Opted", "opercs", "popps", "pret", "OPTS", "opted", "opps", "optted", "optouts", "preps", "opouts", "operps", "OPts", "otcs", " opfs", "Opt", "otTS", "otns", "opcs", "okouts", "optns", "optTS", "popouts", "copt", "iopts", "Opts", " opns", "opert", "iopt"], "errp": [" errps", "errorf", "gerpr", "errr", "drP", "lerp", "erps", " errf", "drps", " errfp", "Erp", "errorP", "errpr", "erP", "errfp", "errpy", "rrpr", "errP", "acep", "erfp", "rrfp", "lerP", "rrpy", "Err", "gerps", "Erfp", "errpc", " errpy", "armp", " errpr", "armf", "armpr", "drpr", "erp", "rrP", "errorr", " errpc", " errP", "armfp", "rrf", "lerps", "errorpr", "gerP", "errorfp", "lerpc", "derf", "acepy", "errorpc", "derps", "eerp", "drp", "erpc", "errf", "errorps", "eerf", "eerps", "rrps", "gerp", " errpa", "errpa", " errr", "Erpc", "derp", "acef", "errorp", "derpa", "aceP", "eerpa", "rrp", "errps"], "dc": ["dd", "cu", "jc", "cc", "cr", "CD", "disc", "enter", "sc", "cf", "ac", "device", "fc", "rc", "dir", "cca", "vc", "ec", "gc", "dr", "xc", "d", "ct", "input", "dat", "DC", "ga", "design", "cdn", "df", "tc", "dk", "lc", "conn", "pc", "ca", "dn", "c", "dt", "nc", "di", "mc", "oc", "creator", "db", "controller", "inc", "doc", "da", "director", "bc", "ds", "cm", "cd", "desc"], "driver": ["river", "host", "serial", "dist", "draw", "prov", "project", "device", "drive", "uri", "dir", "builder", "reader", "dr", "d", "config", "cross", "product", "name", "force", "ctor", "source", "ride", "route", "engine", "operator", "store", "Driver", "dig", "cdn", "platform", "mode", "handler", "loader", "type", "service", "writer", "owner", "coll", "length", "dn", "devices", "dt", "url", "direction", "drivers", "target", "ide", "plugin", "test", "creator", "der", "version", "pass", "director", "iv", "vers", "design", "cd"], "path": ["user", "host", "mount", "PATH", "text", "loc", "rh", "device", "context", "enc", "object", "uri", "where", "dir", "anc", "key", "alias", "root", "node", "ath", "input", "raw", "config", "cross", "session", "name", "id", "api", "entry", "ride", "source", "route", "method", "end", "loader", "prefix", "str", "prop", "data", "parent", "package", "port", "url", "Path", "block", "child", "pass", "inner", "pointer", "sync", "request", "clean"], "dev": ["comment", "gu", "serial", "dist", "dd", "cache", "mod", "diff", "die", "bug", "auth", "priv", "od", "project", "error", "device", "def", "de", "conf", "temp", "ve", "debug", "DEV", "valid", "new", "fo", "node", "d", "var", "session", "obj", "api", "pub", "engine", "conn", "data", "development", "Dev", "progress", "app", "test", "gd", "di", "info", "result", "block", "sd", "der", "doc", "ver", "ow", "tech", "client", "ev", "prov", "dom"], "bus": ["mount", "home", "lib", "plugin", "boot", "block", "state", "proc", "os", "controller", "bc", "pull", "Bus", "host", "serial", "drive", "object", "vc", "BUS", "config", "plug", "load", "ride", "miss", "route", "hub", "port", "url", "test", "board", "b", "sync", "lc", "comment", "feed", "lock", "io", "project", "device", "dir", "session", "proxy", "engine", "service", "usb", "us", "length", "stick", "ver", "http", "user", "cat", "loop", "machine", "cache", "las", "die", "bug", "back", "def", "bb", "root", "bridge", "class", "coll", "target", "local", "db", "pass", "catch"], "err": ["cr", "rr", "res", "gr", "ir", "req", "rh", "attr", "error", "resp", "er", "Er", "arr", "rev", "iter", "errors", "orig", "Error", "ah", "sys", "str", " error", "ler", "ise", "ar", "rs", "test", "ef", "ee", "exc", "proc", "db", "inc", "der", "doc", "lr", "go", "phi", "ev", "order", "acer"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,\n\n                              int buf_size, int buf_size2)\n\n{\n\n    RVDecContext *rv = avctx->priv_data;\n\n    MpegEncContext *s = &rv->m;\n\n    int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret;\n\n\n\n    active_bits_size = buf_size * 8;\n\n    init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8);\n\n    if (s->codec_id == AV_CODEC_ID_RV10)\n\n        mb_count = rv10_decode_picture_header(s);\n\n    else\n\n        mb_count = rv20_decode_picture_header(rv);\n\n    if (mb_count < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"HEADER ERROR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->mb_x >= s->mb_width ||\n\n        s->mb_y >= s->mb_height) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"POS ERROR %d %d\\n\", s->mb_x, s->mb_y);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    mb_pos = s->mb_y * s->mb_width + s->mb_x;\n\n    left   = s->mb_width * s->mb_height - mb_pos;\n\n    if (mb_count > left) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"COUNT ERROR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) {\n\n        // FIXME write parser so we always have complete frames?\n\n        if (s->current_picture_ptr) {\n\n            ff_er_frame_end(&s->er);\n\n            ff_MPV_frame_end(s);\n\n            s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0;\n\n        }\n\n        if ((ret = ff_MPV_frame_start(s, avctx)) < 0)\n\n            return ret;\n\n        ff_mpeg_er_frame_start(s);\n\n    } else {\n\n        if (s->current_picture_ptr->f.pict_type != s->pict_type) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Slice type mismatch\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    av_dlog(avctx, \"qscale=%d\\n\", s->qscale);\n\n\n\n    /* default quantization values */\n\n    if (s->codec_id == AV_CODEC_ID_RV10) {\n\n        if (s->mb_y == 0)\n\n            s->first_slice_line = 1;\n\n    } else {\n\n        s->first_slice_line = 1;\n\n        s->resync_mb_x      = s->mb_x;\n\n    }\n\n    start_mb_x     = s->mb_x;\n\n    s->resync_mb_y = s->mb_y;\n\n    if (s->h263_aic) {\n\n        s->y_dc_scale_table =\n\n        s->c_dc_scale_table = ff_aic_dc_scale_table;\n\n    } else {\n\n        s->y_dc_scale_table =\n\n        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;\n\n    }\n\n\n\n    if (s->modified_quant)\n\n        s->chroma_qscale_table = ff_h263_chroma_qscale_table;\n\n\n\n    ff_set_qscale(s, s->qscale);\n\n\n\n    s->rv10_first_dc_coded[0] = 0;\n\n    s->rv10_first_dc_coded[1] = 0;\n\n    s->rv10_first_dc_coded[2] = 0;\n\n    s->block_wrap[0] =\n\n    s->block_wrap[1] =\n\n    s->block_wrap[2] =\n\n    s->block_wrap[3] = s->b8_stride;\n\n    s->block_wrap[4] =\n\n    s->block_wrap[5] = s->mb_stride;\n\n    ff_init_block_index(s);\n\n\n\n    /* decode each macroblock */\n\n    for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {\n\n        int ret;\n\n        ff_update_block_index(s);\n\n        av_dlog(avctx, \"**mb x=%d y=%d\\n\", s->mb_x, s->mb_y);\n\n\n\n        s->mv_dir  = MV_DIR_FORWARD;\n\n        s->mv_type = MV_TYPE_16X16;\n\n        ret = ff_h263_decode_mb(s, s->block);\n\n\n\n        // Repeat the slice end check from ff_h263_decode_mb with our active\n\n        // bitstream size\n\n        if (ret != SLICE_ERROR) {\n\n            int v = show_bits(&s->gb, 16);\n\n\n\n            if (get_bits_count(&s->gb) + 16 > active_bits_size)\n\n                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;\n\n\n\n            if (!v)\n\n                ret = SLICE_END;\n\n        }\n\n        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&\n\n            8 * buf_size2 >= get_bits_count(&s->gb)) {\n\n            active_bits_size = buf_size2 * 8;\n\n            av_log(avctx, AV_LOG_DEBUG, \"update size from %d to %d\\n\",\n\n                   8 * buf_size, active_bits_size);\n\n            ret = SLICE_OK;\n\n        }\n\n\n\n        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"ERROR at MB %d %d\\n\", s->mb_x,\n\n                   s->mb_y);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (s->pict_type != AV_PICTURE_TYPE_B)\n\n            ff_h263_update_motion_val(s);\n\n        ff_MPV_decode_mb(s, s->block);\n\n        if (s->loop_filter)\n\n            ff_h263_loop_filter(s);\n\n\n\n        if (++s->mb_x == s->mb_width) {\n\n            s->mb_x = 0;\n\n            s->mb_y++;\n\n            ff_init_block_index(s);\n\n        }\n\n        if (s->mb_x == s->resync_mb_x)\n\n            s->first_slice_line = 0;\n\n        if (ret == SLICE_END)\n\n            break;\n\n    }\n\n\n\n    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y,\n\n                    ER_MB_END);\n\n\n\n    return active_bits_size;\n\n}\n", "idx": 2130, "substitutes": {"avctx": ["afpkg", "afcontext", "AVpkg", "AVctx", "AVcv", " avctrl", "avectx", "svctl", "avenp", "avecf", "verconfig", "vercoll", "AVconfig", " avcontext", "avcmp", "AVtc", " avcf", "avcv", "ajctx", "avtc", "AVcoll", "vercontext", " avcmp", "avpkg", "svpkg", "afcoll", "AVctl", " avnp", "verctx", "ajtc", "afcf", "afloc", "navpkg", "avecoll", "navcontext", "navctx", "ajctrl", "avcf", "afcmp", "afctx", "AVctrl", "avecontext", "afnp", "avloc", "aveloc", "svcontext", "avctrl", "avconfig", "navctl", "AVcontext", "AVloc", "avctl", " avcv", "AVcmp", "avcontext", "avnp", "svctx", " avtc", "ajcv", "avcoll", "afconfig", " avpkg"], "buf": ["rb", "buff", "cf", "rc", "fi", "context", "pb", "ctx", "bb", "bd", "conv", "alloc", "fp", "tmp", "src", "config", "queue", "buffer", "vec", "fb", "cv", "fd", "data", "batch", "uf", "bag", "pool", "sb", "gb", "bh", "cb", "b", "cmd", "f", "wb", "bc", "seq", "br"], "buf_size": ["buflexsized", "bufacsize", "byte_count", "fb_clean", "bufacunit", "fblexize", "fb_ize", "byteacsize", "buflexize", "buf_fee", "fb_size", "byte_sized", "fblexsize", "fb_sized", "byte_fee", "byte_unit", "buf_count", "buflexclean", "buf_unit", "buf_uri", "buf_clean", "byteaccount", "fblexclean", "fblexsized", "buflexsize", "byte_uri", "bufaccount", "buf_scale", "buf_ize", "byte_scale", "byteacfee", "byte_size", "bufacfee", "buf_sized", "byteacunit"], "buf_size2": ["buf_rate1", "buf_rateTwo", "buf_scale192", "buf_scale182", "buf_scale1", "buf_size182", "buf_ize182", "buf_size1", "buf_end192", "buf_end182", "buf_ize2", "buf_scaleTwo", "buf_ize192", "buf_size192", "buf_scale2", "buf_rate2", "buf_end2", "buf_sizeTwo"], "rv": [" rV", "Rf", "rV", "prv", "srv", "Rp", " rf", "RV", " rvp", "srvp", "Rvd", "rf", "srp", "prvp", "rrvp", "Rv", "rvp", "prf", "rp", "rrf", "rvd", " rp", " rvd", "prvd", "rrvd", "Rvp", "srV", "srf", "srvd", "rrv"], "s": ["times", "i", "uns", "conf", "sec", "d", "sum", "sa", "v", "states", "ps", "sb", "sym", "parts", "f", "os", "as", "js", "params", "comments", "sv", "l", "sites", "si", "is", "qs", "o", "y", "p", "less", "ins", "se", "stats", "ses", "site", "features", "b", "sg", "u", "side", "ops", "h", "sync", "S", "r", "hs", "settings", "cs", "ctx", "ssl", "als", "m", "sq", "session", "bs", "w", "service", "g", "your", "us", "server", "spec", "ks", "es", "gs", "posts", "t", "aws", "ss", "e", "sl", "ls", "http", "ds", "xs", "request", "fs", "su", "sets", "ts", "ns", "n", "ims", "ans", "a", "services", "sys", "c", "rs", "self", "vs", "its"], "mb_count": ["mb67count", "mbFoffset", "mb67weight", "mb_add", "mbJcond", "mem64num", "mb_type", "mballnumber", "mb64index", "mbJcount", "mem_index", "mb_number", "bb_count", "mp_catch", "mbFcond", "bb_pos", "mb_offset", "mbFsize", "avFsize", "avFcount", "mb_num", "mem64index", "rb_add", "av_size", "rb_number", "mb67len", "mb_index", "mballcount", "mb_len", "bb_len", "avFoffset", "rb_count", "mb64num", "mb67pos", "mbJoffset", "av_offset", "mem_count", "mem64count", "mem_type", "mem64type", "mbJsize", "mb_cond", "mb_size", "avFcond", "mb_catch", "mbFcount", "mp_number", "mp_count", "av_count", "mb_weight", "av_cond", "mb64type", "bb_weight", "mballcatch", "mb64count", "mem_num"], "mb_pos": ["mbfpo", "mb_len", "mp_len", "mb__pos", "mbJlen", "mbJlength", "MB_count", "mb5pos", "mbflen", "MB_pos", "mb_length", "mb__position", "mp_pos", "emb_count", "mb2po", "MB_len", "mb__len", "mb5gen", "emb_position", "mb__length", "mb5position", "mb2count", "mb2pos", "mp_length", "mbfcount", "mbJpos", "mb2len", "mb_po", "mb_position", "mbJposition", "emb_gen", "mb_gen", "mb5count", "MB_po", "mp_position", "emb_pos", "mbfpos"], "start_mb_x": ["start_mbvpos", "start_mp_x", "start_mb_y", "start_mp_pos", "start_mbvy", "start_mb_pos", "start_mbvx", "start_mp_y"], "active_bits_size": ["active_bits___ize", "active_bits_rate", "active_bits___size", "active_bits_ize", "active_bytes_ize", "active_bytes_rate", "active_bytes_ci", "active_bits_ci", "active_bits___rate", "active_bytes_size"], "ret": ["rep", "val", "res", "value", "back", "r", "att", "pet", "rc", "def", "match", "flag", " Ret", "temp", "alt", "tmp", "ref", "RET", "arr", "det", "rev", "job", "status", "red", "len", "reset", "bot", "lit", "success", "ext", "rets", "reply", "fun", "nt", "reg", "info", "result", "get", "arg", "Ret", "al", "err", "ft", "live", "re", "bit", "last"], "mb_x": ["mp_y", "mb___width", "mb_z", "mbDx", "MB_y", "mp_x", "mb8y", "mbDw", "MB_width", "MB_count", "mbkheight", "mbDya", "mb__x", "mp_ya", "bb_x", "mbkx", "mp_w", "bb_xx", "mb_xx", "mb8width", "mb__z", "mb_width", "mb__w", "mbky", "bb_ax", "mb___xx", "mp_z", "mp_height", "mb_ya", "mb___x", "mb_w", "mb8x", "mbkz", "mb___ax", "bb_width", "mb_height", "mb_ax", "mb__y", "mb8count", "mbDy", "MB_x"], "mb_y": ["mp_y", "mb_length", "mb_wy", "MB_yl", "mbklength", "mbFy", "mp_length", "mbJy", "mbJzy", "mp_yd", "mp_width", "MB_y", "mp_x", "mb_sy", "mp_wy", "mp_area", "mb_yl", "mbkx", "mbFwy", "mb_width", "mbky", "mp_sy", "mbFyd", "mbJx", "mbJsy", "mbFx", "mp_zy", "mbkarea", "mb_area", "mp_height", "mb_cy", "mb_zy", "mb_yd", "mb_height", "MB_cy", "MB_x"]}}
{"project": "qemu", "commit_id": "bd88c780e6a17188f7fd676f3a056e5db21500e0", "target": 1, "func": "static inline int cpu_gdb_index(CPUState *cpu)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    return cpu->host_tid;\n\n#else\n\n    return cpu->cpu_index + 1;\n\n#endif\n\n}\n", "idx": 2133, "substitutes": {"cpu": ["clock", "cache", "uci", "fc", "uu", "fps", "intel", "linux", "core", "computer", "fork", "gc", "node", "eni", "cli", "config", " CPU", "vm", "cp", "loader", "gpu", "lc", "pc", "conn", "bench", "css", "include", "np", "pu", "boot", "performance", "proc", "nic", "CPU", "online", "component", "instance", "lb", "processor", "hw"]}}
{"project": "FFmpeg", "commit_id": "26227d91865ddfbfe35c9ff84853cc469e1c7daf", "target": 1, "func": "static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)\n\n{\n\n    unsigned nz = idx >> 12;\n\n\n\n    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));\n\n\n\n    return dst + 4;\n\n}\n", "idx": 2142, "substitutes": {"dst": ["fST", "idst", "fsts", "adst", "fconst", "adST", "dbl", " dset", "adconst", "datst", "dsth", "fdsts", " dsc", "dedsts", "datbl", "datST", "sdset", "dsts", "datsth", "adsts", "dset", "lbl", "dsc", "dconst", " dST", " dsth", "ldst", "Dsc", "adbl", "lsts", "dedst", "idsth", "sdST", "dest", "adsc", "idset", " dbl", "ldsts", "fdst", "lst", "Dbl", "dedest", "sdst", "idsts", "sdsts", "dedx", " dx", "adset", "dx", " dest", "idST", "idbl", "fdx", "fst", "ldST", "Dset", "dST", " dconst", "fdest", "ldbl", "Dst", " dsts", "lST"], "idx": ["Idxs", "adz", "Idwx", "pidx", " idxs", "adxt", "idlex", "adx", "idelex", "idX", "idex", "idxt", "adX", "aidz", " idxc", "idwx", "index", "minX", "idxs", " idz", "aidk", "idexs", "dz", "dX", "ridX", "idk", "minxt", "pidwx", "aidx", "ideX", "IdX", " idX", "ideex", "ridwx", "indlex", "aidex", " idk", "aidX", "aidxc", "minz", "idz", "ridx", " idxt", " idex", "dx", "pidX", "indk", "indX", " idlex", "minx", "Idx", "idxc", "dxc", "indx"], "sign": ["mask", "vis", "sub", "enc", "z", "head", "sum", "sa", "keep", "pen", "weight", "plus", "block", "max", "inc", "cost", "with", "ign", "pull", "step", "draw", "sr", "sort", "close", "ind", "min", "se", "name", "call", "load", "add", "circ", "sex", "pack", "sk", "sync", "comment", "feed", "sc", "sch", "SIGN", "sh", "Sign", "lex", "mix", "search", "spec", "shape", "reg", "roll", "ss", "size", "scan", "loc", "scale", "script", "form", "id", "connect", "contract", "type", "start", "small", "eff", "save", "align", "parse", "pass", "big"]}}
{"project": "qemu", "commit_id": "93bb1315250dd010e65dc067af103cbaf0de03ae", "target": 1, "func": "void hmp_info_block_jobs(Monitor *mon, const QDict *qdict)\n{\n    BlockJobInfoList *list;\n    Error *err = NULL;\n    list = qmp_query_block_jobs(&err);\n    assert(!err);\n    if (!list) {\n        monitor_printf(mon, \"No active jobs\\n\");\n        return;\n    }\n    while (list) {\n        if (strcmp(list->value->type, \"stream\") == 0) {\n            monitor_printf(mon, \"Streaming device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        } else {\n            monitor_printf(mon, \"Type %s, device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->type,\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        }\n        list = list->next;\n    }\n}", "idx": 2148, "substitutes": {"mon": ["man", "flo", "mor", "domain", "mun", "monitor", "mand", "mag", "bo", "lin", "dm", "mos", "pin", "module", "mo", "m", "pid", "mons", "mi", "mr", "met", "MON", " monitor", "mut", "an", "wat", "master", "prem", "mini", "conn", "mot", "ann", "meter", "mt", "gin", "login", "yahoo", "mat", "mn", "atom", "mc", "chron", "mont", "mu", "Mon", "amon", "tom", "Monitor", "bm", "month", "dom"], "qdict": ["qdef", " qdir", "qtdict", " qdat", "qdir", " qdef", "dqdict", "dqdef", "qtdat", "qdat", "dqdir", "qtdef", "qtdir", "dqdat"], "list": ["update", "view", "all", "i", "List", "lp", "part", "diff", "match", "array", "resp", "dl", "key", "group", "ln", "table", "len", "parent", "ll", "layer", "block", "la", "LIST", "set", "this", "page", "select", "l", "null", "p", "config", "min", "call", "name", "load", "true", "li", "data", "add", "test", "ist", "client", "bl", "sync", "lc", "lock", "listed", "base", "chain", "code", "stack", "new", "act", "write", "queue", "obj", "full", "str", "batch", "member", "server", "old", "pre", "pair", "item", "level", "edit", "ml", "sl", "ls", "index", "source", "loop", "val", "fail", "value", "detail", "n", "pl", "arr", "module", "other", "cli", "rec", "master", "a", "type", "coll", "self", "result", "get", "none", "cl", "resource", "single", "lists", "x", "del", "entry", "record"], "err": ["fr", "oller", "cr", "rr", "res", "gr", "ir", "req", "r", "bug", "rh", "error", "n", "resp", "er", "y", "Er", "ras", "arr", "ref", "fy", "rage", "dr", "ind", "call", "ret", "eor", "iter", "mr", "rar", "status", "raise", "Error", "sys", "str", "ler", "ise", "ry", "ar", "rs", "nr", "orr", "result", "ace", "rl", "der", "f", "lr", "e", "cor", "order", "br"]}}
{"project": "FFmpeg", "commit_id": "ed1c83508ec920bfef773e3aa3ac1764a65826ec", "target": 0, "func": "static int atrim_filter_frame(AVFilterLink *inlink, AVFrame *frame)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    TrimContext       *s = ctx->priv;\n\n    int64_t start_sample, end_sample = frame->nb_samples;\n\n    int64_t pts;\n\n    int drop;\n\n\n\n    /* drop everything if EOF has already been returned */\n\n    if (s->eof) {\n\n        av_frame_free(&frame);\n\n        return 0;\n\n    }\n\n\n\n    if (frame->pts != AV_NOPTS_VALUE)\n\n        pts = av_rescale_q(frame->pts, inlink->time_base,\n\n                           (AVRational){ 1, inlink->sample_rate });\n\n    else\n\n        pts = s->next_pts;\n\n    s->next_pts = pts + frame->nb_samples;\n\n\n\n    /* check if at least a part of the frame is after the start time */\n\n    if (s->start_sample < 0 && s->start_pts == AV_NOPTS_VALUE) {\n\n        start_sample = 0;\n\n    } else {\n\n        drop = 1;\n\n        start_sample = frame->nb_samples;\n\n\n\n        if (s->start_sample >= 0 &&\n\n            s->nb_samples + frame->nb_samples > s->start_sample) {\n\n            drop         = 0;\n\n            start_sample = FFMIN(start_sample, s->start_sample - s->nb_samples);\n\n        }\n\n\n\n        if (s->start_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&\n\n            pts + frame->nb_samples > s->start_pts) {\n\n            drop = 0;\n\n            start_sample = FFMIN(start_sample, s->start_pts - pts);\n\n        }\n\n\n\n        if (drop)\n\n            goto drop;\n\n    }\n\n\n\n    if (s->first_pts == AV_NOPTS_VALUE)\n\n        s->first_pts = pts + start_sample;\n\n\n\n    /* check if at least a part of the frame is before the end time */\n\n    if (s->end_sample == INT64_MAX && s->end_pts == AV_NOPTS_VALUE && !s->duration_tb) {\n\n        end_sample = frame->nb_samples;\n\n    } else {\n\n        drop       = 1;\n\n        end_sample = 0;\n\n\n\n        if (s->end_sample != INT64_MAX &&\n\n            s->nb_samples < s->end_sample) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->end_sample - s->nb_samples);\n\n        }\n\n\n\n        if (s->end_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&\n\n            pts < s->end_pts) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->end_pts - pts);\n\n        }\n\n\n\n        if (s->duration_tb && pts - s->first_pts < s->duration_tb) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->first_pts + s->duration_tb - pts);\n\n        }\n\n\n\n        if (drop) {\n\n            s->eof = 1;\n\n            goto drop;\n\n        }\n\n    }\n\n\n\n    s->nb_samples += frame->nb_samples;\n\n    start_sample   = FFMAX(0, start_sample);\n\n    end_sample     = FFMIN(frame->nb_samples, end_sample);\n\n    av_assert0(start_sample < end_sample);\n\n\n\n    if (start_sample) {\n\n        AVFrame *out = ff_get_audio_buffer(ctx->outputs[0], end_sample - start_sample);\n\n        if (!out) {\n\n            av_frame_free(&frame);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        av_frame_copy_props(out, frame);\n\n        av_samples_copy(out->extended_data, frame->extended_data, 0, start_sample,\n\n                        out->nb_samples, av_get_channel_layout_nb_channels(frame->channel_layout),\n\n                        frame->format);\n\n        if (out->pts != AV_NOPTS_VALUE)\n\n            out->pts += av_rescale_q(start_sample, (AVRational){ 1, out->sample_rate },\n\n                                     inlink->time_base);\n\n\n\n        av_frame_free(&frame);\n\n        frame = out;\n\n    } else\n\n        frame->nb_samples = end_sample;\n\n\n\n    s->got_output = 1;\n\n    return ff_filter_frame(ctx->outputs[0], frame);\n\n\n\ndrop:\n\n    s->nb_samples += frame->nb_samples;\n\n    av_frame_free(&frame);\n\n    return 0;\n\n}\n", "idx": 2157, "substitutes": {"inlink": ["insload", "inasline", "outlink", "insink", "outlock", " inlock", "rinlink", "insline", "inself", "Inlink", "inlock", " inink", "inlinks", "outline", "inslinks", "rinload", "rinink", " inself", " inlinks", "outload", "rinlock", "inslink", "Inline", "inaslock", "inslock", "inload", "INlock", " inload", "INself", "INlink", "inasload", "inink", "insself", "inaslink", "Inlock", "Inlinks", "INline"], "frame": ["view", "series", "part", "setup", "sim", "d", "framework", "video", "window", "info", "image", "state", "pse", "screen", "f", "component", "js", "fe", "object", "p", "node", "time", "data", "motion", "scope", "style", "zone", "fram", "line", "fr", "zip", "rame", "fi", "document", "dr", "m", "session", "figure", "dy", "element", "slice", "full", "service", "scene", "game", "ze", "spec", "me", "plane", "ss", "e", "source", "request", "Frame", "ms", "sample", "scale", "cf", "sche", "iframe", "module", "sequence", "fb", "file", "coll", "frames", "sf", "c", "flow", "feature", "rup", "range", "cfg"], "ctx": ["kw", "cc", "pkg", "mac", "loc", "sc", "cf", "context", "cs", "conf", "conv", "cca", "anc", "ci", "cms", "config", "sq", "cam", "obj", "m", "Context", "tc", "cv", "cp", "lc", "conn", "pc", "ca", "c", "ctrl", "scope", "cb", "tx", "ck", "wcs", "cmd", "bc", "cfg", "cm"], "s": ["i", "series", "setup", "sing", "conf", "sim", "d", "stat", "sis", "sci", "states", "ps", "sp", "lines", "sb", "sym", "state", "os", "f", "parts", "space", "js", "sv", "l", "si", "is", "qs", "y", "o", "p", "ins", "se", "ses", "site", "scope", "args", "b", "sg", "u", "sk", "sync", "h", "S", "r", "settings", "hs", "cs", "ssl", "m", "sq", "session", "slice", "service", "g", "us", "spec", "es", "obs", "gs", "t", "ss", "e", "sl", "ls", "ds", "xs", "source", "fs", "ms", "sample", "ts", "ns", "ims", "n", "services", "sys", "a", "frames", "sf", "c", "rs", "vs", "span"], "start_sample": ["start_size", "currentfshape", "end_sam", "end_single", "starttside", "pick_package", "starting_source", "pick_sample", "start_stage", "startfshape", "stop_scale", "start_module", "starting_sample", "startfpackage", "starttsample", "startjgroup", "currentfspace", "start_package", "current_space", "current_sample", "end_Sample", "end_package", "startxmodule", "startxsample", "end_scale", "end_source", "starttspace", "current_shape", "start67module", "startPsample", "end_space", "startfample", "start_model", "startfspace", "end_sample", "pick_slice", " start_space", "startfsample", "start_ample", "startPscale", "start_sequence", "start67sample", "start_slice", "start_single", "startxspace", "end_ample", "end_stage", "start_sem", "start_server", "start_slot", "start_scale", "stop_sequence", "starting_scale", "currentfsample", "startPample", "start_side", " start_sem", "startxslot", "startjsample", "end_slot", "startjsingle", "end_module", "startjscale", "start_source", "stop_sample", "startPSample", "currentfpackage", "start67space", "startfsource", "start67slot", "start_sam", "start_space", "stop_server", "startfscale", "end_size", " start_side", "start_group", "end_group", "starting_ample", "start_shape", "start_Sample", "starttsem", "current_package", "pick_model"], "pts": ["ointcount", "inputts", "uptses", "PTs", "iptts", "eptsd", "inputsets", "PTts", "seqs", "upts", "ints", "ctd", "condd", "ptsw", "periodlines", "roundts", "periodts", "ptsi", "roundsets", "PTsym", "periodds", "parsym", "prts", "ptss", "nts", "eptsi", "ointsets", "periodxs", "aptts", "aptsets", "aptsi", "pps", "PTss", "montd", "ptsets", "montsi", "inputxs", "montsd", "ptts", "PTns", "PTS", "parses", "inputs", "intsets", "seqsd", "monts", "iptsw", "seqsets", "ptsym", "aptsw", "uptss", "uptd", "ptns", "aptd", "ctts", "condts", "ctse", "oints", "ppS", "PTf", "ntns", "ointS", "ptses", "conds", "ptf", "PTses", "seqds", "iptd", "ptcount", "rounds", "seqcount", "seqsi", "PTgroups", "ptds", "pars", "ptse", "periods", "periodns", "PTlines", "periodcount", "prd", "ointds", "prs", "ptlines", "periodsets", "apts", "condse", "periodgroups", "roundns", "epts", "roundlines", "intts", "ptgroups", "ntts", "uptsi", "ptd", "ntsets", "ptxs", "ptS", "PTd", "PTsw", "ointf", "ptsd", "aptxs", "intns", "ipts", "roundgroups", "parss", "uptsym", "ppf", "cts", "prse"], "drop": ["comment", "field", "loop", "update", "zip", "phase", "leave", "diff", "sample", "bug", "shift", "scale", "error", "select", "pick", "ignore", "play", "close", "dl", "throw", "bottom", "dropping", "crop", "dr", "clip", "delay", "append", " dropped", "pop", "hide", "send", "qa", "keep", "no", "slice", "pad", "skip", "stop", "sleep", "delete", "change", "type", "allow", "batch", "add", "shape", "port", "bag", "plane", "Drop", "start", "roll", "layer", "col", "move", "dro", "push", "drops", "carry", "err", "dp", "gap", "alter", "pull", "repeat", "step"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs,\n\n                               const TCGArg * const args, uint16_t dead_args,\n\n                               uint8_t sync_args)\n\n{\n\n    int flags, nb_regs, i;\n\n    TCGReg reg;\n\n    TCGArg arg;\n\n    TCGTemp *ts;\n\n    intptr_t stack_offset;\n\n    size_t call_stack_size;\n\n    tcg_insn_unit *func_addr;\n\n    int allocate_args;\n\n    TCGRegSet allocated_regs;\n\n\n\n    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];\n\n    flags = args[nb_oargs + nb_iargs + 1];\n\n\n\n    nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);\n\n    if (nb_regs > nb_iargs) {\n\n        nb_regs = nb_iargs;\n\n    }\n\n\n\n    /* assign stack slots first */\n\n    call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);\n\n    call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & \n\n        ~(TCG_TARGET_STACK_ALIGN - 1);\n\n    allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);\n\n    if (allocate_args) {\n\n        /* XXX: if more than TCG_STATIC_CALL_ARGS_SIZE is needed,\n\n           preallocate call stack */\n\n        tcg_abort();\n\n    }\n\n\n\n    stack_offset = TCG_TARGET_CALL_STACK_OFFSET;\n\n    for(i = nb_regs; i < nb_iargs; i++) {\n\n        arg = args[nb_oargs + i];\n\n#ifdef TCG_TARGET_STACK_GROWSUP\n\n        stack_offset -= sizeof(tcg_target_long);\n\n#endif\n\n        if (arg != TCG_CALL_DUMMY_ARG) {\n\n            ts = &s->temps[arg];\n\n            temp_load(s, ts, tcg_target_available_regs[ts->type],\n\n                      s->reserved_regs);\n\n            tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset);\n\n        }\n\n#ifndef TCG_TARGET_STACK_GROWSUP\n\n        stack_offset += sizeof(tcg_target_long);\n\n#endif\n\n    }\n\n    \n\n    /* assign input registers */\n\n    tcg_regset_set(allocated_regs, s->reserved_regs);\n\n    for(i = 0; i < nb_regs; i++) {\n\n        arg = args[nb_oargs + i];\n\n        if (arg != TCG_CALL_DUMMY_ARG) {\n\n            ts = &s->temps[arg];\n\n            reg = tcg_target_call_iarg_regs[i];\n\n            tcg_reg_free(s, reg, allocated_regs);\n\n\n\n            if (ts->val_type == TEMP_VAL_REG) {\n\n                if (ts->reg != reg) {\n\n                    tcg_out_mov(s, ts->type, reg, ts->reg);\n\n                }\n\n            } else {\n\n                TCGRegSet arg_set;\n\n\n\n                tcg_regset_clear(arg_set);\n\n                tcg_regset_set_reg(arg_set, reg);\n\n                temp_load(s, ts, arg_set, allocated_regs);\n\n            }\n\n\n\n            tcg_regset_set_reg(allocated_regs, reg);\n\n        }\n\n    }\n\n    \n\n    /* mark dead temporaries and free the associated registers */\n\n    for(i = nb_oargs; i < nb_iargs + nb_oargs; i++) {\n\n        if (IS_DEAD_ARG(i)) {\n\n            temp_dead(s, &s->temps[args[i]]);\n\n        }\n\n    }\n\n    \n\n    /* clobber call registers */\n\n    for (i = 0; i < TCG_TARGET_NB_REGS; i++) {\n\n        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) {\n\n            tcg_reg_free(s, i, allocated_regs);\n\n        }\n\n    }\n\n\n\n    /* Save globals if they might be written by the helper, sync them if\n\n       they might be read. */\n\n    if (flags & TCG_CALL_NO_READ_GLOBALS) {\n\n        /* Nothing to do */\n\n    } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) {\n\n        sync_globals(s, allocated_regs);\n\n    } else {\n\n        save_globals(s, allocated_regs);\n\n    }\n\n\n\n    tcg_out_call(s, func_addr);\n\n\n\n    /* assign output registers and emit moves if needed */\n\n    for(i = 0; i < nb_oargs; i++) {\n\n        arg = args[i];\n\n        ts = &s->temps[arg];\n\n        reg = tcg_target_call_oarg_regs[i];\n\n        assert(s->reg_to_temp[reg] == NULL);\n\n\n\n        if (ts->fixed_reg) {\n\n            if (ts->reg != reg) {\n\n                tcg_out_mov(s, ts->type, ts->reg, reg);\n\n            }\n\n        } else {\n\n            if (ts->val_type == TEMP_VAL_REG) {\n\n                s->reg_to_temp[ts->reg] = NULL;\n\n            }\n\n            ts->val_type = TEMP_VAL_REG;\n\n            ts->reg = reg;\n\n            ts->mem_coherent = 0;\n\n            s->reg_to_temp[reg] = ts;\n\n            if (NEED_SYNC_ARG(i)) {\n\n                tcg_reg_sync(s, reg, allocated_regs);\n\n            }\n\n            if (IS_DEAD_ARG(i)) {\n\n                temp_dead(s, ts);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 2182, "substitutes": {"s": ["S", "fs", "r", "sets", "su", "ns", "settings", "private", "cs", "si", "is", "n", "conf", "ssl", "o", "p", "groups", "d", "m", "sq", "session", "se", "w", "ds", "ops", "services", "sys", "stats", "service", "states", "g", "ps", "us", "ses", "sf", "c", "site", "spec", "self", "shared", "gs", "sym", "t", "b", "f", "u", "os", "ss", "js", "e", "side", "its", "ls", "tests", "client"], "nb_oargs": ["nb_iivalid", "nb__ialls", "nb24oarg", "nb_autoerg", "nb_diextra", "nb_iiargs", "nb24ovalid", "nb_diargs", "nb_oextra", "nb_oaarg", "nb_oavalid", "nb24iivalid", "nb_oaargs", "nb_oaerg", "nb_woargs", "nb_iiseries", "nb_perg", "nb_oerg", "nb__oerg", "nb_autoextra", "nb_iseries", "nb_wovals", "nb_ialls", "nb_oaalls", "nb_oseries", "nb_iextra", "nb_ivals", "nb24iiargs", "nb_oaux", "nb_parg", "nb_pargs", "nb_autoarg", "nb__iargs", "nb_oalls", "nb24oseries", "nb_iarg", "nb_diarg", "nb_iiarg", "nb24iiseries", "nb_iaux", "nb__iarg", "nb__oalls", "nb__ierg", "nb_ivalid", "nb24iiarg", "nb__oarg", "nb_autoargs", "nb_palls", "nb_ovalid", "nb_oarg", "nb_ierg", "nb24oargs", "nb_ovals", "nb_woaux", "nb_woarg", "nb_oaseries", "nb__oargs", "nb_dierg"], "nb_iargs": ["nb_wargs", "nb_oreg", "nb_ciems", "nb_iiargs", "nb_diargs", "nb_oems", "nb_iniarr", "nb_oags", "nb_avalid", "nb_pores", "nb_iarms", "nb_piargs", "nb_piflags", "nb_ciarr", "nb_octr", "nb_iiems", "nb_oriarg", "nb_parms", "nb_ireg", "nb_bargs", "nb_rargs", "nb_oarms", "nb_iags", "nb_diflags", "nb_siages", "nb_ictr", "nb_uiarr", "nb_wems", "nb_barg", "nb_tiflags", "nb_iniems", "nb_tiarg", "nb_civalid", "nb_parg", "nb_pargs", "nb_iores", "nb_bass", "nb_iarg", "nb_oyears", "nb_diarg", "nb_iiarg", "nb_iass", "nb_oriages", "nb_tiargs", "nb_iniargs", "nb_iflags", "nb_iiflags", "nb_ciargs", "nb_sictr", "nb_aems", "nb_uiargs", "nb_wags", "nb_aargs", "nb_inivalid", "nb_oriargs", "nb_iems", "nb_ivalid", "nb_iyears", "nb_oores", "nb_tiyears", "nb_warg", "nb_piarr", "nb_rarms", "nb_iireg", "nb_diyears", "nb_iiass", "nb_iiarr", "nb_breg", "nb_oflags", "nb_rores", "nb_orictr", "nb_oarg", "nb_oages", "nb_iarr", "nb_piarg", "nb_oass", "nb_siargs", "nb_iages", "nb_rarg", "nb_uiarg", "nb_uiflags", "nb_siarg", "nb_iiags", "nb_aarr"], "args": ["ags", "all", " arguments", "ms", "ns", "Arg", "cs", "flag", "ics", "ims", "values", "alloc", "ig", "Args", "arr", "stack", "acks", "fields", "groups", "items", "ips", "ins", "uments", "config", "names", "call", "words", "blocks", "members", "ae", "orders", "method", "actions", "alls", "v", "py", "codes", "yrs", "states", "str", "data", "g", "arms", "frames", "vals", "ay", "ams", "gs", "result", "parts", "as", "objects", "ars", "extra", "size", "atts", "ds", "params"], "dead_args": ["sync_arg", "call_arg", "syncallparts", "call_flags", "syncallflags", "syncacarg", "sync_flags", "syncallargs", "syncacparts", "call_args", "syncacflags", "syncallarg", "call_parts", "syncacargs", "sync_parts"], "sync_args": ["sync_arg", "ync_parts", "ync_args", "syncallparts", "syncallflags", "yncallarg", "sync__parts", "sync_flags", "syncallargs", "yncallflags", "ync_arg", "sync__arg", "sync__args", "yncallparts", "syncallarg", "ync_flags", "sync__flags", "sync_parts", "yncallargs"], "flags": ["mask", "ags", "FLAG", "fs", "ui", "lag", "ils", "weights", "settings", "cs", "types", "flag", "conf", "bits", "arr", "fields", "ints", "ret", "status", "len", "actions", "count", "alls", "stats", "fd", "spec", "fun", "vals", "ants", "weight", "init", "options", "features", "rules", "Flags", "utils", "ops", "bit"], "nb_regs": ["nb_inds", "nb_indils", "nb_outputs", "nb_regments", "nb_accs", "nb_rels", "nb_commss", "nb67regss", "nb6gregs", "nb_signours", "nb6regments", "nb_commls", "nb_reqps", "nb_contracts", "nb_regses", "nb_reggs", "nb_gregss", "nb_recS", "nb_indls", "nb_regds", "nb6regS", "nb_regS", "nb_regals", "nb_reccs", "nb67regils", "nb0000funs", "nb67regls", "nb0000regS", "nb_platforms", "nb_countals", "nb_gregS", "nb_rolals", "nb_threadses", "nb_countses", "nb6gregss", "nb_funds", "nb_regils", "nb_threadns", "nb_comms", "nb_reqours", "nb6regs", "nb_reqgs", "nb_indss", "nb_regcs", "nb67commils", "nb_recs", "nb6regss", "nb_contractments", "nb0000funcs", "nb0000regcs", "nb_accss", "nb_regstates", "nb_platformours", "nb_rolns", "nb_accils", "nb_reqs", "nb67regs", "nb_rolses", "nb_execstates", "nb_reces", "nb_execes", "nb0000funS", "nb_relcs", "nb6gregS", "nb_regours", "nb_reggroups", "nb_accls", "nb_regss", "nb_platformps", "nb_execgroups", "nb_threads", "nb_gregs", "nb_commils", "nb_relds", "nb_outputments", "nb6gregments", "nb_counts", "nb_recds", "nb_outputS", "nb67comms", "nb_funS", "nb_countns", "nb0000regs", "nb_execs", "nb_reges", "nb_regns", "nb_platformgs", "nb_contractss", "nb_regls", "nb0000funds", "nb67commls", "nb_outputss", "nb_funcs", "nb_regps", "nb_funs", "nb_threadals", "nb_threades", "nb67commss", "nb_threadstates", "nb_threadgroups", "nb0000regds", "nb_recstates", "nb_signps", "nb_contractS", "nb_gregments", "nb_relS", "nb_recgroups", "nb_signgs", "nb_rols", "nb_signs"], "i": ["hi", "ui", "io", "it", "idi", "l", "fi", "si", "j", "n", "y", "ani", "p", "ci", "multi", "qi", "eni", "id", "mi", "z", "adi", "ri", "ini", "ii", "v", "bi", "mini", "x", "li", "g", "iu", "ie", "c", "zi", "di", "ix", "ai", "info", "pi", "mu", "t", "gi", "f", "u", "ti", "ip", "ni", "e", "xi", "I", "inner", "phi", "index"], "reg": ["mod", "val", "cache", "all", "res", "inst", "def", "sub", "rc", "num", "sec", "lib", "alloc", "exec", "debug", "param", "lang", "src", "mem", "ig", "var", "config", "call", "ret", "obj", "Reg", "stat", "orig", "no", "run", "rec", "func", "str", "data", "spec", "comp", "info", "block", "proc", "REG", "custom", "rem", "bit", "tag", "seq"], "arg": ["gu", "cat", "val", "alg", "mac", "attr", "ac", "Arg", "enc", "flag", "j", "sec", "num", "arc", "cell", " Arg", "ig", "valid", "param", "arr", "key", "ask", "alias", "mag", "gas", "act", "var", "call", " flag", "name", " argument", "orig", "ang", "ass", "str", "g", "ne", "gin", "ag", "slot", "eg", "ar", "util", "aug", "ace", "cand", "al", "ax", "b", "err", "par", "amp", "doc", "op", "ark", "parse", "pass", "addr", "argument", "bit", "tag"], "ts": ["times", "tm", "fs", "ms", "uts", "Ts", "ns", "tl", "ptr", "tim", "ta", "tt", "cs", "ims", "temp", "te", "ics", "qs", "types", "tis", "pt", "als", "tips", "tf", "bs", "tg", "ds", "acs", "tc", "alls", "TS", "trans", "stats", "str", "ps", "ks", "rs", "ats", "test", "outs", "tx", "t", "ss", "js", "tests", "ls", "atts", "xs", "tes"], "stack_offset": [" stack_index", "stack_off", "call_offset", "stack64offset", " stack_usage", "stack_addr", "stack_index", "stackflowoffset", "stack00offset", "stack64addr", "stackflowsize", "stack_Offset", "stack_size", "stackflowoff", "stack64index", "stack64scale", " stack_addr", "stack00addr", "call_Offset", "stack_scale", "call_size", "stack00index", " stack_size", " stack_off", "stack_usage", "stackflowusage", "stack00scale", " stack_scale"], "call_stack_size": ["call_thread_scale", "call_stack_slice", "call_stack\u00b7use", "call_ack_strength", "call_stackssize", "call_ack_capacity", "call_stack_max", "call_buffer_storage", "call_stack___use", "call_array\u00b7use", "call_array_use", "call_stack\u00b7size", "call_stack___speed", "call_array_speed", "call_stackflowsize", "call_ack_size", "call_bufferflowsized", "call_stacksstrength", "call_stack_strength", "call_bufferflowsize", "call_thread_max", "call_buffer_left", "call_stack_width", "call_stack\u00b7type", "call_stackflowleft", "call_stackswidth", "call_stack_use", "call_stack_sized", "call_buffer_max", "call_array\u00b7speed", "call_thread_size", "call_buffer_size", "call_array\u00b7slice", "call_stack\u00b7slice", "call_stackflowsized", "call_stackscapacity", "call_buffer_sized", "call_bufferflowcapacity", "call_stack_left", "call_stack_scale", "call_array_slice", "call_stack\u00b7storage", "call_buffer_type", "call_bufferflowleft", "call_buffer_capacity", "call_stack\u00b7max", "call_stack_storage", "call_stackflowcapacity", "call_stack_type", "call_stack\u00b7speed", "call_stack___slice", "call_array\u00b7size", "call_array_size", "call_stack_capacity", "call_stack___size", "call_ack_width", "call_stack_speed"], "func_addr": ["function_address", "function_wrapper", "func_alias", "func_wrapper", "function_ptr", "function_addr", "func_offset", "func__address", "func__offset", "func_address", "function_offset", "func_ptr", "function_alias", "func__addr", "func__wrapper"], "allocate_args": ["allocate__all", "allocate_arg", "allate_params", "allallocableargs", "allocateableargs", "allocate__args", "allocated_flags", "allocateablesize", "allalloc_args", "allocated_args", "allocate_flags", "allallocablearg", "allallocableall", "allate_size", "allocate_all", "allate_arg", "allate_args", "allalloc_arg", "allocate__size", "allallocablesize", "allocate__arg", "allocate_size", "allocateablearg", "allalloc_size", "allocated_arg", "allocateableall", "allalloc_all", "allocate_params"], "allocated_regs": ["allocated_REGuments", "allocated_reguments", "allocated_regd", "allocated_REGs", "allocated_threadd", "allocated_threadp", "allocated_regp", "allocated_memp", "allocated_memuments", "allocated_REGd", "allocated_mems", "allocated_threads", "allocated_threaduments", "allocated_memd", "allocated_REGp"]}}
{"project": "qemu", "commit_id": "838ef602498b8d1985a231a06f5e328e2946a81d", "target": 0, "func": "static void curl_multi_do(void *arg)\n\n{\n\n    BDRVCURLState *s = (BDRVCURLState *)arg;\n\n    int running;\n\n    int r;\n\n\n\n    if (!s->multi) {\n\n        return;\n\n    }\n\n\n\n    do {\n\n        r = curl_multi_socket_all(s->multi, &running);\n\n    } while(r == CURLM_CALL_MULTI_PERFORM);\n\n\n\n    curl_multi_read(s);\n\n}\n", "idx": 2187, "substitutes": {"arg": ["inf", "ac", "rc", "Arg", "array", "enc", "play", "arc", "p", "ig", "exec", "param", "arr", "or", "ic", "var", "any", "call", "load", "ad", "am", "ang", "pc", "g", "str", "ray", "arm", "ag", "work", "ar", "self", "ace", "args", "as", "inc", "par", "parse", "pass", "argument"], "s": ["S", "i", "socket", "su", "ns", "l", "hs", "settings", "si", "is", "sec", "ssl", "o", "south", "p", "or", "new", "d", "m", "sq", "sa", "an", "services", "a", "sys", "service", "g", "ps", "server", "ses", "sf", "spec", "c", "params", "rs", "es", "self", "gs", "sym", "args", "t", "b", "sg", "f", "u", "os", "ss", "js", "e", "sl", "ls", "parse", "instance", "ds", "sync"], "running": ["loop", "i", "standing", " n", "rc", "working", "blocking", "active", "n", "p", "runner", "Running", "enabled", "d", " Running", "finished", "m", " reading", "using", " working", "reading", "run", " starting", " d", "starting", "c", "rolling", " using", "inner", "current", " continuing", "result", "playing", "ending", "available", "successful", "t", " blocking", " f", "f", " e", "b", "testing", "loading", "runs", " executing", " performing"], "r": [" sr", " no", "i", "rb", "cr", "ing", "rr", " self", "sr", "rh", "error", "rc", "n", "er", " runner", "o", "p", "R", "Running", "d", "m", " p", "w", "ro", "mr", "run", " d", "rd", "g", " re", " c", " ro", "ry", "c", "rs", "rg", "ar", "nr", "hr", " rs", "ru", "rn", "result", "ng", "f", " e", "q", "err", " rc", "rl", "e", "re", "x", " str"]}}
{"project": "FFmpeg", "commit_id": "f95cfff07765912676cc613b55e2234b5d70f1bd", "target": 0, "func": "static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *config)\n\n{\n\n    static int hinted = 0;\n\n    int ret = 0;\n\n    AVDictionaryEntry *e;\n\n    const AVOption *o = NULL;\n\n    const char *option = NULL;\n\n    const char *codec_name = NULL;\n\n    char buff[1024];\n\n    AVCodecContext *ctx;\n\n    AVDictionary **dict;\n\n    enum AVCodecID guessed_codec_id;\n\n\n\n    switch (type) {\n\n    case AV_OPT_FLAG_VIDEO_PARAM:\n\n        ctx = config->dummy_vctx;\n\n        dict = &config->video_opts;\n\n        guessed_codec_id = config->guessed_video_codec_id != AV_CODEC_ID_NONE ?\n\n                           config->guessed_video_codec_id : AV_CODEC_ID_H264;\n\n        break;\n\n    case AV_OPT_FLAG_AUDIO_PARAM:\n\n        ctx = config->dummy_actx;\n\n        dict = &config->audio_opts;\n\n        guessed_codec_id = config->guessed_audio_codec_id != AV_CODEC_ID_NONE ?\n\n                           config->guessed_audio_codec_id : AV_CODEC_ID_AAC;\n\n        break;\n\n    default:\n\n        av_assert0(0);\n\n    }\n\n\n\n    if (strchr(opt, ':')) {\n\n        //explicit private option\n\n        snprintf(buff, sizeof(buff), \"%s\", opt);\n\n        codec_name = buff;\n\n        option = strchr(buff, ':');\n\n        buff[option - buff] = '\\0';\n\n        option++;\n\n        if ((ret = ffserver_set_codec(ctx, codec_name, config)) < 0)\n\n            return ret;\n\n        if (!ctx->codec || !ctx->priv_data)\n\n            return -1;\n\n    } else {\n\n        option = opt;\n\n    }\n\n\n\n    o = av_opt_find(ctx, option, NULL, type | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN);\n\n    if (!o && (!strcmp(option, \"time_base\")  || !strcmp(option, \"pixel_format\") ||\n\n               !strcmp(option, \"video_size\") || !strcmp(option, \"codec_tag\")))\n\n        o = av_opt_find(ctx, option, NULL, 0, 0);\n\n    if (!o) {\n\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                            &config->errors, \"Option not found: %s\\n\", opt);\n\n        if (!hinted && ctx->codec_id == AV_CODEC_ID_NONE) {\n\n            hinted = 1;\n\n            report_config_error(config->filename, config->line_num, AV_LOG_ERROR, NULL,\n\n                                \"If '%s' is a codec private option, then prefix it with codec name, \"\n\n                                \"for example '%s:%s %s' or define codec earlier.\\n\",\n\n                                opt, avcodec_get_name(guessed_codec_id) ,opt, arg);\n\n        }\n\n    } else if ((ret = av_opt_set(ctx, option, arg, AV_OPT_SEARCH_CHILDREN)) < 0) {\n\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors, \"Invalid value for option %s (%s): %s\\n\", opt,\n\n                arg, av_err2str(ret));\n\n    } else if ((e = av_dict_get(*dict, option, NULL, 0))) {\n\n        if ((o->type == AV_OPT_TYPE_FLAGS) && arg && (arg[0] == '+' || arg[0] == '-'))\n\n            return av_dict_set(dict, option, arg, AV_DICT_APPEND);\n\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors,\n\n                \"Redeclaring value of the option %s, previous value: %s\\n\",\n\n                opt, e->value);\n\n    } else if (av_dict_set(dict, option, arg, 0) < 0) {\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    return 0;\n\n}\n", "idx": 2188, "substitutes": {"opt": ["fn", "cat", "value", "text", "loc", "attr", "error", "object", "ord", "num", "temp", "alt", "p", "tmp", "term", "token", "append", "name", "obj", "ret", "iter", "buf", "Option", "slice", "lit", "off", "cp", "format", "pos", "ext", "prop", "txt", "expr", "Opt", "cho", "info", "options", "optim", "op", "err", "OP", "timeout", "qt", "path"], "arg": ["cat", "val", "all", "mac", "loc", "rc", "Arg", "enc", "sec", "lib", "alloc", "exec", "or", "input", "call", "obj", "end", "ext", "g", "parser", "oc", "args", "proc", "bin", "cmd", "op", "argument", "path"], "type": ["field", "i", "action", "all", "value", "attr", "sort", "error", "types", "code", "flag", "num", "y", "kind", "p", "ref", "key", "call", "name", "id", "typ", "time", "method", "pe", "class", "event", "format", "pc", "prop", "parent", "ype", "port", "Type", "url", "pre", "comp", " TYPE", "info", "block", "col", "style", "t", "op", " typ", "TYPE", "open", "ty", "path"], "config": ["driver", "text", "database", "req", "conf", "sec", "lib", "ref", "ec", "qa", "feat", "cn", "output", "complete", "mc", "state", "proc", "que", "inc", "json", "component", "bc", "cont", "cal", "manager", "FIG", "exec", "anc", "dat", "Config", "data", "drivers", "args", "utils", "ct", "lc", "not", "pg", "support", "sc", "project", "comm", "settings", "fi", "context", "document", "concept", "acl", "queue", "obj", "ini", "full", "con", "cp", "conn", "service", "front", "spec", "ctrl", "reg", "options", "subject", "crit", "cmd", "fig", "uc", "design", "desc", "cache", "dc", "cf", "rc", "control", "connection", "ext", "ca", "console", "c", "get", "gui", "cl", "cfg", "client", "content"], "e": ["eval", "object", "er", "p", "exec", "node", "m", "obj", "ae", "et", "pe", "entity", "E", "event", "oe", "esc", "g", "ea", "c", "es", "ef", "ee", "ace", "ent", "ei", "b", "ev", "en"], "o": ["vo", "ko", "i", "io", "error", "po", "object", "oo", "j", "n", "ando", "zo", "p", "bo", "fo", "mo", "oi", "obj", "wo", "ro", "k", "no", "ao", "v", "a", "pos", "ant", "ou", "co", "oe", "parent", "cho", "c", "ot", "ob", "info", "oc", "t", "oa", "O", "os", "op", "b", "f", "custom", "online", "u", "ow", "one", "go", "lo", "s", "so"], "option": ["i", "text", "archive", "alt", "key", "alias", "number", "v", "position", "parent", "block", "image", "OP", "post", "error", "object", "null", "p", "term", "append", "name", "ion", "route", "event", "app", "current", "style", "custom", "op", "open", "argument", "comment", "offset", "function", "element", "search", "length", "package", "cho", "item", "anything", "options", "index", "user", "cat", "attribute", "value", "loc", "section", "equ", "optional", "command", "or", "connection", "byte", "token", "ption", "Option", "no", "off", "esc", "c", "always", "result", "optim", "version", "x", "entry"], "codec_name": ["codescsname", "codef_key", "codeca_num", "codec_Name", "codecftype", "codec_type", "codescskey", "codec2type", "codecsprefix", "codesc_prefix", "codef_name", "codecfnum", "codec_id", "codec_prefix", "codec2num", "codef_names", "codescsid", "codecsname", "codec_data", "codecskey", "codeca_data", "codec_num", "codec2data", "codesc_key", "codesc_name", "codeca_type", "codec_names", "codecfname", "codeca_name", "codef_Name", "codecfdata", "codesc_id", "codecsid", "codescsprefix", "codec_key", "codec2name"], "buff": ["rb", "diff", "text", "uff", "pb", "ref", "alias", "ff", " buffer", "orig", "lit", "Buff", "ob", "info", "ch", "cb", "wb", "bt", "br", "font", "bo", "tmp", "nd", "bg", "qq", "ind", "append", "buffer", "buf", "data", "callback", "bag", "ph", "app", "now", "b", "box", "op", "hack", "bl", "tab", "comment", "feed", "zip", "fi", "mem", "obj", "pad", "cp", "gz", "txt", "cmd", "amp", "bind", "empty", "xff", "cat", "loop", "bf", "back", "loc", "cond", "bug", "cf", "rc", "rt", "bb", "utf", "cli", "fb", "off", "prefix", "ext", "eb", "uf", "gb", " buf"], "ctx": ["cu", "git", "cc", "dc", "pkg", "loc", "sync", "sc", "cf", "rc", "context", "cs", "cm", "conf", " context", "conv", "cca", "vc", "fp", "exec", "ci", "connection", "xc", "cli", "sq", "concept", "cci", "ct", "voc", "buf", "qa", "Context", "sci", "handler", "cv", "cp", "conn", "pc", "ca", "coll", "cn", "txt", "c", "ctrl", "nc", "scope", "auc", "mc", "cb", "tx", "la", "wcs", "cmd", "cl", "client", "this", "aux", "bc", "cfg", "cas", "uc", "lc", "anc"], "dict": ["cat", "view", "cache", "diff", "pkg", "cf", "def", "gen", "conf", "dir", "lib", "arr", "ind", "d", "session", "dat", "obj", "head", "ict", "sum", "table", "stat", "ini", "df", "con", "conn", "file", "co", "data", "coll", "dn", "map", "init", "pillar", "block", "col", "state", "db", "cmd", "inc", "tree", "doc", "json", "utils", "client", "sync", "clean"], "guessed_codec_id": ["guessed_codec__id", "guessed_codec_name", "guessed_codac_type", "guessed_codec_type", "guessed_codac_ids", "guessed_codeca_name", "guessed_codoc_name", "guessed_codoc_info", "guessed_codac_id", "guessed_codoc_ids", "guessed_codec_info", "guessed_codac_name", "guessed_codoc_id", "guessed_codec_ids", "guessed_codeca_ids", "guessed_codec__ids", "guessed_codec__name", "guessed_codeca_id"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static int decode_opc(MoxieCPU *cpu, DisasContext *ctx)\n\n{\n\n    CPUMoxieState *env = &cpu->env;\n\n\n\n    /* Local cache for the instruction opcode.  */\n\n    int opcode;\n\n    /* Set the default instruction length.  */\n\n    int length = 2;\n\n\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n        tcg_gen_debug_insn_start(ctx->pc);\n\n    }\n\n\n\n    /* Examine the 16-bit opcode.  */\n\n    opcode = ctx->opcode;\n\n\n\n    /* Decode instruction.  */\n\n    if (opcode & (1 << 15)) {\n\n        if (opcode & (1 << 14)) {\n\n            /* This is a Form 3 instruction.  */\n\n            int inst = (opcode >> 10 & 0xf);\n\n\n\n#define BRANCH(cond)                                                         \\\n\n    do {                                                                     \\\n\n        int l1 = gen_new_label();                                            \\\n\n        tcg_gen_brcond_i32(cond, cc_a, cc_b, l1);                            \\\n\n        gen_goto_tb(env, ctx, 1, ctx->pc+2);                                 \\\n\n        gen_set_label(l1);                                                   \\\n\n        gen_goto_tb(env, ctx, 0, extract_branch_offset(opcode) + ctx->pc+2); \\\n\n        ctx->bstate = BS_BRANCH;                                             \\\n\n    } while (0)\n\n\n\n            switch (inst) {\n\n            case 0x00: /* beq */\n\n                BRANCH(TCG_COND_EQ);\n\n                break;\n\n            case 0x01: /* bne */\n\n                BRANCH(TCG_COND_NE);\n\n                break;\n\n            case 0x02: /* blt */\n\n                BRANCH(TCG_COND_LT);\n\n                break;\n\n            case 0x03: /* bgt */\n\n                BRANCH(TCG_COND_GT);\n\n                break;\n\n            case 0x04: /* bltu */\n\n                BRANCH(TCG_COND_LTU);\n\n                break;\n\n            case 0x05: /* bgtu */\n\n                BRANCH(TCG_COND_GTU);\n\n                break;\n\n            case 0x06: /* bge */\n\n                BRANCH(TCG_COND_GE);\n\n                break;\n\n            case 0x07: /* ble */\n\n                BRANCH(TCG_COND_LE);\n\n                break;\n\n            case 0x08: /* bgeu */\n\n                BRANCH(TCG_COND_GEU);\n\n                break;\n\n            case 0x09: /* bleu */\n\n                BRANCH(TCG_COND_LEU);\n\n                break;\n\n            default:\n\n                {\n\n                    TCGv temp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                    gen_helper_raise_exception(cpu_env, temp);\n\n                    tcg_temp_free_i32(temp);\n\n                }\n\n                break;\n\n            }\n\n        } else {\n\n            /* This is a Form 2 instruction.  */\n\n            int inst = (opcode >> 12 & 0x3);\n\n            switch (inst) {\n\n            case 0x00: /* inc */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned int v = (opcode & 0xff);\n\n                    tcg_gen_addi_i32(REG(a), REG(a), v);\n\n                }\n\n                break;\n\n            case 0x01: /* dec */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned int v = (opcode & 0xff);\n\n                    tcg_gen_subi_i32(REG(a), REG(a), v);\n\n                }\n\n                break;\n\n            case 0x02: /* gsr */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned v = (opcode & 0xff);\n\n                    tcg_gen_ld_i32(REG(a), cpu_env,\n\n                                   offsetof(CPUMoxieState, sregs[v]));\n\n                }\n\n                break;\n\n            case 0x03: /* ssr */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned v = (opcode & 0xff);\n\n                    tcg_gen_st_i32(REG(a), cpu_env,\n\n                                   offsetof(CPUMoxieState, sregs[v]));\n\n                }\n\n                break;\n\n            default:\n\n                {\n\n                    TCGv temp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                    gen_helper_raise_exception(cpu_env, temp);\n\n                    tcg_temp_free_i32(temp);\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    } else {\n\n        /* This is a Form 1 instruction.  */\n\n        int inst = opcode >> 8;\n\n        switch (inst) {\n\n        case 0x00: /* nop */\n\n            break;\n\n        case 0x01: /* ldi.l (immediate) */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x02: /* mov (register-to-register) */\n\n            {\n\n                int dest  = (opcode >> 4) & 0xf;\n\n                int src = opcode & 0xf;\n\n                tcg_gen_mov_i32(REG(dest), REG(src));\n\n            }\n\n            break;\n\n        case 0x03: /* jsra */\n\n            {\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_movi_i32(t1, ctx->pc + 6);\n\n\n\n                /* Make space for the static chain and return address.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);\n\n\n\n                /* Push the current frame pointer.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);\n\n\n\n                /* Set the pc and $fp.  */\n\n                tcg_gen_mov_i32(REG(0), REG(1));\n\n\n\n                gen_goto_tb(env, ctx, 0, cpu_ldl_code(env, ctx->pc+2));\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                ctx->bstate = BS_BRANCH;\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x04: /* ret */\n\n            {\n\n                TCGv t1 = tcg_temp_new_i32();\n\n\n\n                /* The new $sp is the old $fp.  */\n\n                tcg_gen_mov_i32(REG(1), REG(0));\n\n\n\n                /* Pop the frame pointer.  */\n\n                tcg_gen_qemu_ld32u(REG(0), REG(1), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t1);\n\n\n\n\n\n                /* Pop the return address and skip over the static chain\n\n                   slot.  */\n\n                tcg_gen_qemu_ld32u(cpu_pc, REG(1), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t1);\n\n\n\n                tcg_temp_free_i32(t1);\n\n\n\n                /* Jump... */\n\n                tcg_gen_exit_tb(0);\n\n\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x05: /* add.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_add_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x06: /* push */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                tcg_gen_subi_i32(t1, REG(a), 4);\n\n                tcg_gen_mov_i32(REG(a), t1);\n\n                tcg_gen_qemu_st32(REG(b), REG(a), ctx->memidx);\n\n                tcg_temp_free_i32(t1);\n\n            }\n\n            break;\n\n        case 0x07: /* pop */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                TCGv t1 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_qemu_ld32u(REG(b), REG(a), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(a), 4);\n\n                tcg_gen_mov_i32(REG(a), t1);\n\n                tcg_temp_free_i32(t1);\n\n            }\n\n            break;\n\n        case 0x08: /* lda.l */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld32u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x09: /* sta.l */\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st32(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0a: /* ld.l (register indirect) */\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld32u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x0b: /* st.l */\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st32(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x0c: /* ldo.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld32u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0d: /* sto.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st32(REG(b), t1, ctx->memidx);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0e: /* cmp */\n\n            {\n\n                int a  = (opcode >> 4) & 0xf;\n\n                int b  = opcode & 0xf;\n\n\n\n                tcg_gen_mov_i32(cc_a, REG(a));\n\n                tcg_gen_mov_i32(cc_b, REG(b));\n\n            }\n\n            break;\n\n        case 0x19: /* jsr */\n\n            {\n\n                int fnreg = (opcode >> 4) & 0xf;\n\n\n\n                /* Load the stack pointer into T0.  */\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_movi_i32(t1, ctx->pc+2);\n\n\n\n                /* Make space for the static chain and return address.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);\n\n\n\n                /* Push the current frame pointer.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);\n\n\n\n                /* Set the pc and $fp.  */\n\n                tcg_gen_mov_i32(REG(0), REG(1));\n\n                tcg_gen_mov_i32(cpu_pc, REG(fnreg));\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x1a: /* jmpa */\n\n            {\n\n                tcg_gen_movi_i32(cpu_pc, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1b: /* ldi.b (immediate) */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1c: /* ld.b (register indirect) */\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld8u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x1d: /* lda.b */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld8u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1e: /* st.b */\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st8(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x1f: /* sta.b */\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st8(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x20: /* ldi.s (immediate) */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x21: /* ld.s (register indirect) */\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld16u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x22: /* lda.s */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld16u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x23: /* st.s */\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st16(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x24: /* sta.s */\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st16(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x25: /* jmp */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                tcg_gen_mov_i32(cpu_pc, REG(reg));\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x26: /* and */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_and_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x27: /* lshr */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_shr_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x28: /* ashl */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_shl_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x29: /* sub.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_sub_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2a: /* neg */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_neg_i32(REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2b: /* or */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_or_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2c: /* not */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_not_i32(REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2d: /* ashr */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_sar_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x2e: /* xor */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_xor_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2f: /* mul.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_mul_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x30: /* swi */\n\n            {\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(temp, val);\n\n                tcg_gen_st_i32(temp, cpu_env,\n\n                               offsetof(CPUMoxieState, sregs[3]));\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_SWI);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x31: /* div.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                gen_helper_div(REG(a), cpu_env, REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x32: /* udiv.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                gen_helper_udiv(REG(a), cpu_env, REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x33: /* mod.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_rem_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x34: /* umod.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_remu_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x35: /* brk */\n\n            {\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_BREAK);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n            }\n\n            break;\n\n        case 0x36: /* ldo.b */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld8u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x37: /* sto.b */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st8(REG(b), t1, ctx->memidx);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x38: /* ldo.s */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld16u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x39: /* sto.s */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st16(REG(b), t1, ctx->memidx);\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        default:\n\n            {\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n             }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return length;\n\n}\n", "idx": 2190, "substitutes": {"cpu": ["clock", "cache", "cpp", "uci", "fi", "pb", "cmp", "context", "linux", "pl", "cca", "fp", "gc", "node", "cli", "gp", "CP", "vm", "sci", "px", "cp", "prem", "gpu", "conn", "pc", "roc", "ocr", "cn", "coe", "c", "nc", "prof", "pu", "proc", "nic", "hp", "que", "CPU", "pty", "instance", "processor", "lc"], "ctx": ["kb", "cu", "support", "cc", "pkg", "loc", "sc", "cf", "rc", "cpp", "context", "cs", "cmp", "fc", "cca", "vc", "exec", "ci", "connection", "xc", "ct", "config", "sq", "cli", "obj", "qa", "Context", "sci", "cv", "cp", "conn", "pc", "ca", "fw", "c", "ctrl", "mc", "tx", "ck", "proc", "cmd", "bc", " context", "hw"], "env": ["cache", "equ", "ptr", "context", "enc", "profile", "code", "eu", "stack", "impl", "ec", "eni", "cli", "config", "dat", "qv", "cv", "conn", "ext", "console", "ea", "ev", "np", "scope", "exc", "style", "global", "args", "oa", "db", "que", "err", "online", "environment", "desc", "cfg", "qt", "priv", "fg", "en", "Environment"], "opcode": ["Opcodes", "opframe", "hopce", "Opcomb", "optcount", "pCode", "pcount", "optioncod", "optframe", "pcode", " opcod", "opercodes", "opce", "ipframe", "hopcodes", "OpCode", "opcod", "ipcode", "pcall", "optCode", "pframe", "ipCode", "opCode", "operce", "ipcodes", "Opcode", " opcodes", "opercode", "opercomb", "optionCode", "hopCode", "opcodes", "opcomb", "optcod", "optcodes", "optionce", "optcode", "opcall", " opcomb", "opercall", "optioncode", "operCode", "hopcode", " opCode", " opce", " opcall", "optce", "opcount", "pcodes", "ipcount"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)\n\n{\n\n    int rex;\n\n\n\n    if (opc & P_GS) {\n\n        tcg_out8(s, 0x65);\n\n    }\n\n    if (opc & P_DATA16) {\n\n        /* We should never be asking for both 16 and 64-bit operation.  */\n\n        assert((opc & P_REXW) == 0);\n\n        tcg_out8(s, 0x66);\n\n    }\n\n    if (opc & P_ADDR32) {\n\n        tcg_out8(s, 0x67);\n\n    }\n\n\n\n    rex = 0;\n\n    rex |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */\n\n    rex |= (r & 8) >> 1;                /* REX.R */\n\n    rex |= (x & 8) >> 2;                /* REX.X */\n\n    rex |= (rm & 8) >> 3;               /* REX.B */\n\n\n\n    /* P_REXB_{R,RM} indicates that the given register is the low byte.\n\n       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,\n\n       as otherwise the encoding indicates %[abcd]h.  Note that the values\n\n       that are ORed in merely indicate that the REX byte must be present;\n\n       those bits get discarded in output.  */\n\n    rex |= opc & (r >= 4 ? P_REXB_R : 0);\n\n    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);\n\n\n\n    if (rex) {\n\n        tcg_out8(s, (uint8_t)(rex | 0x40));\n\n    }\n\n\n\n    if (opc & (P_EXT | P_EXT38)) {\n\n        tcg_out8(s, 0x0f);\n\n        if (opc & P_EXT38) {\n\n            tcg_out8(s, 0x38);\n\n        }\n\n    }\n\n\n\n    tcg_out8(s, opc);\n\n}\n", "idx": 2195, "substitutes": {"s": ["i", "fs", "sets", "su", "setup", "ts", "ns", "settings", "hs", "cs", "is", "si", "sync", "sup", "ctx", "ssl", "o", "n", "south", "p", "http", "d", "sq", "ions", "session", "se", "status", "w", "opens", "ches", "services", "sys", "states", "service", "g", "ps", "us", "lines", "ses", "sf", "c", "sb", "site", "es", "self", "cpp", "gs", "t", "sports", "b", "f", "u", "sg", "native", "os", "ges", "js", "e", "ss", "bis", "tests", "ds", "h"], "opc": ["oppc", "copcs", "opcit", "ropf", "opt", "oopcit", "ortf", "operf", "oopt", "hopt", "ovf", "libc", "opci", "upcu", " opg", "ipf", "optf", "ripc", "ripcs", "libf", "ropz", "ropt", "OPcu", " opz", "copg", "optcu", "opf", "hopc", "opg", "operc", "ipcs", "opercu", "oplc", "ripcu", "oopc", "ospcs", " opf", "opn", "ropg", "ippc", "ortc", "OPci", "copci", "opcu", "ovc", "OPc", "ipci", "OPcs", "optlc", " opcs", "upf", "opercs", "ropc", " opcu", " oppc", "opcs", "hopf", "opz", " oplc", "oopf", "ovcs", "upc", "optc", "uplc", "copf", "ovcu", "libcs", "copcit", "ropn", "ospc", "hoppc", "ospcu", "oopci", "ipcu", "copc", "libpc", " opci", "ripf", "ortpc", " opcit", "oppf", "ortcs", "hopcs", "oppcs", "ospci", "hopn", "oopn", "copz", "oppcu", "ipc"], "r": ["fr", "rb", "i", "rr", "gr", "ir", "pr", "sr", "rh", "l", "rc", "rt", "n", "er", "o", "rx", "p", "R", "or", "dr", "d", "m", "rf", "z", "ro", "w", "rar", "v", "g", "kr", "c", "ar", "rs", "reg", "nr", "b", "f", "q", "u", "range", "e", "re", "lr", "h", "br"], "rm": ["md", "rb", "cr", "rr", "nm", "rh", "vre", "rt", "pm", "rx", "RM", "ref", "ore", "dm", "rage", "dr", "adr", "m", "rom", "rf", "mr", "ro", "rar", "vm", "vr", "rd", "rpm", "rg", "ril", "nr", "reg", "rn", "mx", "b", "rl", "rob", "lr", "addr", "re", "rem", "bm", "cm"], "x": ["i", "X", "l", "rc", "ex", "code", "xes", "n", "xx", "y", "o", "rx", "p", "xc", "d", "m", "z", "lex", "w", "xp", "v", "g", "c", "ar", "xt", "ix", "tx", "b", "f", "u", "q", "e", "re", "h", "xs"], "rex": ["rep", "xff", "gru", "wx", "res", "com", "su", "EX", "cmp", "ex", "xb", "xx", "pex", "rx", "gre", "cone", "number", "rice", "xc", "xa", "proxy", "cross", "lex", "gal", " cx", "xe", "rax", "xp", "orig", "xxxxxxxx", "abc", "xxxx", "prefix", "ext", "breaker", "xf", "flex", "Rex", "nex", "fax", "xy", "ticket", "test", "exc", "result", "sex", "tx", "dx", "rez", "rench", "none", "nexus", "coord", "re", "xi", "ux", "frac", "xs", "fe"]}}
{"project": "qemu", "commit_id": "d0d5d0e31a874d592741a088c2c5071bae164dbf", "target": 1, "func": "qcow2_co_pwritev_compressed(BlockDriverState *bs, uint64_t offset,\n\n                            uint64_t bytes, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    QEMUIOVector hd_qiov;\n\n    struct iovec iov;\n\n    z_stream strm;\n\n    int ret, out_len;\n\n    uint8_t *buf, *out_buf;\n\n    uint64_t cluster_offset;\n\n\n\n    if (bytes == 0) {\n\n        /* align end of file to a sector boundary to ease reading with\n\n           sector based I/Os */\n\n        cluster_offset = bdrv_getlength(bs->file->bs);\n\n        return bdrv_truncate(bs->file, cluster_offset, PREALLOC_MODE_OFF, NULL);\n\n    }\n\n\n\n    buf = qemu_blockalign(bs, s->cluster_size);\n\n    if (bytes != s->cluster_size) {\n\n        if (bytes > s->cluster_size ||\n\n            offset + bytes != bs->total_sectors << BDRV_SECTOR_BITS)\n\n        {\n\n            qemu_vfree(buf);\n\n            return -EINVAL;\n\n        }\n\n        /* Zero-pad last write if image size is not cluster aligned */\n\n        memset(buf + bytes, 0, s->cluster_size - bytes);\n\n    }\n\n    qemu_iovec_to_buf(qiov, 0, buf, bytes);\n\n\n\n    out_buf = g_malloc(s->cluster_size);\n\n\n\n    /* best compression, small window, no zlib header */\n\n    memset(&strm, 0, sizeof(strm));\n\n    ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n\n                       Z_DEFLATED, -12,\n\n                       9, Z_DEFAULT_STRATEGY);\n\n    if (ret != 0) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    strm.avail_in = s->cluster_size;\n\n    strm.next_in = (uint8_t *)buf;\n\n    strm.avail_out = s->cluster_size;\n\n    strm.next_out = out_buf;\n\n\n\n    ret = deflate(&strm, Z_FINISH);\n\n    if (ret != Z_STREAM_END && ret != Z_OK) {\n\n        deflateEnd(&strm);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    out_len = strm.next_out - out_buf;\n\n\n\n    deflateEnd(&strm);\n\n\n\n    if (ret != Z_STREAM_END || out_len >= s->cluster_size) {\n\n        /* could not compress: write normal cluster */\n\n        ret = qcow2_co_pwritev(bs, offset, bytes, qiov, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        goto success;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    cluster_offset =\n\n        qcow2_alloc_compressed_cluster_offset(bs, offset, out_len);\n\n    if (!cluster_offset) {\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    cluster_offset &= s->cluster_offset_mask;\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, cluster_offset, out_len);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    iov = (struct iovec) {\n\n        .iov_base   = out_buf,\n\n        .iov_len    = out_len,\n\n    };\n\n    qemu_iovec_init_external(&hd_qiov, &iov, 1);\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_WRITE_COMPRESSED);\n\n    ret = bdrv_co_pwritev(bs->file, cluster_offset, out_len, &hd_qiov, 0);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\nsuccess:\n\n    ret = 0;\n\nfail:\n\n    qemu_vfree(buf);\n\n    g_free(out_buf);\n\n    return ret;\n\n}\n", "idx": 2213, "substitutes": {"s": ["S", "i", "fs", "su", "sets", "sc", "ts", "ns", "settings", "l", "cs", "is", "si", "uns", "ims", "n", "ssl", "qs", "sec", "p", "sim", "less", "ins", "bs", "session", "se", "sq", "sa", "stat", "services", "sys", "stats", "states", "g", "service", "sie", "ps", "us", "ses", "spec", "ks", "c", "sb", "rs", "es", "self", "obs", "iss", "current", "outs", "gs", "sym", "state", "vs", "b", "f", "os", "aws", "ss", "js", "e", "sl", "ls", "bis", "ds", "sync", "xs"], "hd_qiov": [" struct_dilo", " struct_qqilo", " struct_qqiov", " struct_diov", " struct_dqilo", " struct_qqarrison", " struct_dqicho", " struct_dqiov", " struct_qqicho", " struct_qicho", " struct_qiov", " struct_qarrison", " struct_darrison", " struct_dqarrison", " struct_qilo", " struct_dicho"], "iov": ["io", "urate", " io", " vec", " ensemble", "rolet", "liv", " mechanism", "ressor", " liv", "oco", "sbm", "uno", " barr", "ouple", "NV", " bloc", "oyer", "uda", "USB", " hive", "ibl", "ilo", "iop", "oren", " bio", "airo", " gif"], "strm": ["stran", "STRms", "drbm", "eltum", "lerm", " strma", "frm", "trp", "strimid", "Strmt", "drM", "brm", "strmn", "eltimm", "trmm", " strumm", "czM", "strms", " strp", "frM", "StrM", "trm", " strum", "crM", "trM", "strbm", "Strmm", " trma", "czmn", "Strm", "striM", " stran", "crm", "strf", "drm", "brM", "strmm", "strp", "frmt", "Stram", "strmt", "crms", "Strmn", "frms", " trm", "TRm", "STRp", "STRmm", "strmid", " drM", " strimm", "strumm", "eltm", "Strimm", " dran", " strmm", "strum", "Strmid", "Strf", "eltM", "TRM", "trbm", "STRm", "brp", " drm", " trM", "czm", "trms", "STRM", "strM", "TRma", "TRp", "Strum", "STRmt", "drms", "czf", "Strp", "striam", "arrM", "strim", "frp", "Strumm", " tran", " strf", " drma", "crbm", "arrmm", " strM", "brma", "strma", "STRam", "STRmid", "arram", "lerM", " strmn", "lerumm", "Strms", "strimm", "stram", "lerum", "arrm"], "ret": ["rep", "cat", "bf", "val", "let", "res", "part", "back", "match", "def", "att", "pet", "rt", "flag", " Ret", "sec", "resp", "code", "alt", "hash", "lt", "num", "valid", "pt", "fin", "RET", "ref", "mem", "det", "gt", "fat", "rev", "pret", "len", "no", "lit", "success", "ext", "rets", "feat", "str", "reply", "mt", "fun", "nt", "reg", "result", "cb", "arg", "Ret", "db", "err", "ft", "cur", "sat", "magic", "re", "pass", "bit", "try"], "out_len": [" out_lon", "in_len", "out_lon", "in_val", " out_Len", "out_val", "in_Len", "out_Len", "out_limit", "out_pos", "in_limit", " out_pos"], "buf": ["feed", "offset", "rb", "cache", "home", "text", "pkg", "buff", "loc", "req", "cf", "rc", "pb", "ctx", "lim", "fp", "alloc", "tmp", "src", "mem", "ff", "byte", "config", "queue", "buffer", "Buffer", "vec", "fb", "len", "off", "cv", "fd", "Buff", "data", "batch", "uf", "port", "fw", "bag", "pool", "uber", "block", "cb", "cap", "b", "f", "cmd", "box", "wb", "aux", "bc", "bytes", "cas", "uc", "msg", "seq", "br"], "out_buf": ["out_file", "in_queue", "outingbuffer", "out2cb", "out_uf", "outJfile", "outJuf", "out_fp", "in_buf", "out_buff", " out_uf", "in_buffer", "out2buff", "out_queue", "in_uf", "out2buf", "outingfp", "in_cb", "out2buffer", " out_fp", "outJbuffer", "outinguf", " out_cb", "in_file", " out_buff", "out_cb", " out_buffer", "outingbuf", "outJbuf", "out_buffer"], "cluster_offset": ["cluster_off", "cluster_position", "clancer_offset", "clancer_off", "clancer_pos", "clancer_Offset", "cluster_Offset", "cluster_size", "cluster_pos"]}}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mfrom(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 2229, "substitutes": {"ctx": ["cu", "cc", "bc", "cfg", "pkg", "req", "loc", "sc", "cf", "fc", "rc", "context", "cs", "cmp", "cpp", "cca", "vc", "ci", "ce", "src", "gc", "xc", "cli", "config", "qa", "Context", "tc", "sci", "cv", "cp", "gpu", "conn", "pc", "ca", "cn", "css", "c", "ctrl", "nc", "ch", "cpu", "cb", "tx", "crit", "ck", "wcs", "cmd", "cl", "hw", "component", "ct", "cm", "cas", "lc", "anc", "cus"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                         long width, long height,\n\n                                         long lumStride, long chromStride, long dstStride)\n\n{\n\n    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n", "idx": 2246, "substitutes": {"ysrc": ["csource", "yssrc", "sssrc", "gsrc", "sc", "cssrc", "csc", "gsource", "sysuc", "ysource", "vssrc", "src", "sysource", "syssrc", "ssrc", "csrc", "vsuc", "ysuc", "sysrc", "gssrc", "ysc", "ssource", "vsource", "ssuc", "source", "gsc"], "usrc": ["vsrid", "USrc", "Usrid", " usroc", "ussrc", "sssrc", " ussrc", "vssrc", "ssrc", "USsrc", "lsrc", "lssrc", "USrid", "ssdc", "lsdc", "ssroc", " usdc", "USroc", "Usroc", "usdc", "usroc", "usrid", "Usrc", "lsroc", "vsroc", "Ussrc"], "vsrc": [" vstat", "vssource", "wsrc", "wstat", "vssrc", "vsstat", "wrc", "wources", " vources", " vrc", "wsource", "vsources", " vsource", "vstat", "vsource", "vrc", "vources"], "dst": ["adst", "adST", "Dsrc", "dsth", " dsc", "dsts", "adsts", "idsc", "dsc", "idsrc", " dST", "Dsc", "adsrc", "idsth", "adsc", "dsrc", "idsts", "idST", "adsth", "Dsth", "dST", "idst", "Dst", " dsts"], "height": ["high", "dist", "padding", "img", "density", "y", "bottom", "square", "deep", "crop", "images", "input", "alpha", "resolution", "dim", "slice", "pad", "above", "distance", "wrap", "window", "length", "shape", "direction", "rank", "depth", "image", "style", "hd", "max", "gap", "thin", "Height", "size", "pull", "ty", "h"], "lumStride": ["lumSTri", "lumstrite", "lumSTro", "lumStorerap", "lumstro", "lumStro", "lumScride", "lumSTrip", "lumSTrap", "lumStrip", "lumSTrite", "lumStoreride", "lumbStri", "lumbstro", "lumbStrap", "lumbstride", "lumbstri", "lumStorerip", "lumStrro", "lumbSTro", "lumbStro", "lumstride", "lumbStride", "lumbStrite", "lumstri", "lumStrite", "lumbStrip", "lumbSTrap", "lumStri", "lumbSTride", "lumStorero", "lumbstrite", "lumStrride", "lumStrrip", "lumStrap", "lumStrrap", "lumSTride", "lumScri", "lumbSTrip", "lumScro", "lumScrite"], "chromStride": ["chromStandro", "chelStyrip", "romStrate", "chromStrip", "romSTro", "chelStridden", "romSTrite", "chromSyncride", "chromSTrate", "chromStyridden", "chromStipe", "chelStyipe", "chromStyrip", "chromSyncipe", "chromstro", "chromSTipe", "chelStride", "chromStyipe", "chromStyride", "romSTrate", "chromstrate", "chromSTrip", "chelStipe", "chromStro", "chelStyridden", "chromSTridden", "romStride", "chromStrite", "chromStandrite", "chromSTride", "chromSTro", "chromstrite", "chromStrate", "chromSTrite", "chromSyncrip", "romStro", "chromStandrate", "chromStandride", "chelStyride", "romSTride", "chromStridden", "chromstride", "chelStrip", "chromSyncridden", "romStrite"], "dstStride": ["dstStore", "dscStrip", "dblSTore", "dststro", "dblSTrite", "dstRestrip", "dscStide", "dblStrite", "dststrite", "dblSTro", "dstStrore", "dstStrride", "dstRestride", "dblStro", "dstStrrite", "dblStore", "dstSTore", "dstRestro", "dststride", "dstStro", "dstStide", "dscSTride", "dscSTide", "dststore", "dscStride", "dblStride", "dscSTrip", "dblSTride", "dstSTide", "dstSTrip", "dstSTrite", "dstRestide", "dstStrite", "dstSTride", "dstStrip", "dscStro", "dscSTro", "dstStrro", "dstSTro"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static gboolean ga_channel_open(GAChannel *c, const gchar *path,\n\n                                GAChannelMethod method, int fd)\n\n{\n\n    int ret;\n\n    c->method = method;\n\n\n\n    switch (c->method) {\n\n    case GA_CHANNEL_VIRTIO_SERIAL: {\n\n        assert(fd < 0);\n\n        fd = qemu_open(path, O_RDWR | O_NONBLOCK\n\n#ifndef CONFIG_SOLARIS\n\n                           | O_ASYNC\n\n#endif\n\n                           );\n\n        if (fd == -1) {\n\n            g_critical(\"error opening channel: %s\", strerror(errno));\n\n            return false;\n\n        }\n\n#ifdef CONFIG_SOLARIS\n\n        ret = ioctl(fd, I_SETSIG, S_OUTPUT | S_INPUT | S_HIPRI);\n\n        if (ret == -1) {\n\n            g_critical(\"error setting event mask for channel: %s\",\n\n                       strerror(errno));\n\n            close(fd);\n\n            return false;\n\n        }\n\n#endif\n\n        ret = ga_channel_client_add(c, fd);\n\n        if (ret) {\n\n            g_critical(\"error adding channel to main loop\");\n\n            close(fd);\n\n            return false;\n\n        }\n\n        break;\n\n    }\n\n    case GA_CHANNEL_ISA_SERIAL: {\n\n        struct termios tio;\n\n\n\n        assert(fd < 0);\n\n        fd = qemu_open(path, O_RDWR | O_NOCTTY | O_NONBLOCK);\n\n        if (fd == -1) {\n\n            g_critical(\"error opening channel: %s\", strerror(errno));\n\n            return false;\n\n        }\n\n        tcgetattr(fd, &tio);\n\n        /* set up serial port for non-canonical, dumb byte streaming */\n\n        tio.c_iflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP |\n\n                         INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY |\n\n                         IMAXBEL);\n\n        tio.c_oflag = 0;\n\n        tio.c_lflag = 0;\n\n        tio.c_cflag |= GA_CHANNEL_BAUDRATE_DEFAULT;\n\n        /* 1 available byte min or reads will block (we'll set non-blocking\n\n         * elsewhere, else we have to deal with read()=0 instead)\n\n         */\n\n        tio.c_cc[VMIN] = 1;\n\n        tio.c_cc[VTIME] = 0;\n\n        /* flush everything waiting for read/xmit, it's garbage at this point */\n\n        tcflush(fd, TCIFLUSH);\n\n        tcsetattr(fd, TCSANOW, &tio);\n\n        ret = ga_channel_client_add(c, fd);\n\n        if (ret) {\n\n            g_critical(\"error adding channel to main loop\");\n\n            close(fd);\n\n            return false;\n\n        }\n\n        break;\n\n    }\n\n    case GA_CHANNEL_UNIX_LISTEN: {\n\n        if (fd < 0) {\n\n            Error *local_err = NULL;\n\n\n\n            fd = unix_listen(path, NULL, strlen(path), &local_err);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n        }\n\n        ga_channel_listen_add(c, fd, true);\n\n        break;\n\n    }\n\n    case GA_CHANNEL_VSOCK_LISTEN: {\n\n        if (fd < 0) {\n\n            Error *local_err = NULL;\n\n            SocketAddress *addr;\n\n            char *addr_str;\n\n\n\n            addr_str = g_strdup_printf(\"vsock:%s\", path);\n\n            addr = socket_parse(addr_str, &local_err);\n\n            g_free(addr_str);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n\n\n            fd = socket_listen(addr, &local_err);\n\n            qapi_free_SocketAddress(addr);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n        }\n\n        ga_channel_listen_add(c, fd, true);\n\n        break;\n\n    }\n\n    default:\n\n        g_critical(\"error binding/listening to specified socket\");\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 2265, "substitutes": {"c": ["cat", "cod", "cu", "cc", "dc", "cr", "jc", "r", "cy", "sc", "ac", "l", "cmp", "cs", "enc", "n", "vc", "p", "ci", "exec", "ec", "xc", "d", "m", "call", "w", "k", "con", "cv", "v", "cp", "lc", "conn", "pc", "ca", "g", "co", "cn", "can", "self", "ch", "mc", "channel", "col", "b", "f", "C", "e", "bc", "cm", "client", "h", "ce", "cd"], "path": ["mount", "feed", "wd", "text", "PATH", "rh", "loc", "context", "enc", "dir", "temp", "pattern", "p", "anc", "key", "location", "root", "ath", "config", "walk", "name", "id", "w", "handler", "mode", "full", "end", "prefix", "type", "file", "dest", "prop", "data", "txt", "parent", "port", "url", "Path", "cmd", "directory", "inner", "pointer", "filename"], "method": ["fn", "model", "mod", "man", "md", "text", "transform", "manager", "rh", "attr", "sort", "mp", "nom", "tr", "context", "month", "function", "header", "operation", "module", "config", "m", "call", "name", "session", "send", "status", "route", "time", "mode", "class", "end", "METHOD", "format", "func", "type", "prop", "sign", "eth", "package", "me", "url", "direction", "round", "block", "process", "channel", "cmd", "version", "this", "instance", "message", "Method", "record", "h"], "fd": ["vd", "md", " fid", "dl", "ff", "d", "fat", "ln", "fm", "ld", "wind", "cb", "f", "wb", "fe", "cd", "draw", "ird", "cod", "fc", "fan", "pd", "nd", "fl", "ind", "pid", "dat", "fee", "buf", "ad", "fen", "gd", "fa", "fx", "sd", "ft", "director", "lf", "fn", "fr", "dd", "FD", "feed", "wd", "fi", "function", "dir", "bd", "dy", "df", "wat", "writer", "front", "length", "dn", "td", "fun", "dt", "ds", "raf", "bf", "dc", "fs", "loc", "cond", "cf", "fp", "af", "fb", "handler", "func", "file", "sf", "xd", "fw", "direction", "fed", "draft", "hd", "db", "da"], "ret": ["cat", "bf", "val", "let", "fail", "res", "part", "pat", "back", " RET", "sr", "match", "att", "rc", "def", "pet", "rt", "flag", " Ret", "code", "resp", "lt", "alt", "RET", "arr", "mem", "ref", "det", "fit", "gt", "af", "rev", "obj", "status", "red", "pub", "len", "run", "lit", "success", "ext", "rets", "data", "reply", "mt", "fun", "nt", "reg", "xt", "url", "result", "arg", "Ret", "al", "f", "rl", "ft", "re", "pass", "bl", "bit", "art"], "tio": ["untio", "ttcho", " trio", "dtios", "fao", "tui", "forttimeout", "trio", "ticho", "Tfolio", " tao", "atio", "Tout", "tiao", "ttimeout", "dios", "bitigo", "fortfolio", "untout", "tao", "Ttimeout", " tigo", "dtior", "Ticho", " tco", "Tigo", " tout", " tiao", "dicho", "bitios", " tios", "fortios", " tui", "tco", "pior", "ttiao", "tout", " tior", "atior", "bitio", " ttimeout", "pios", "dtimeout", "Tiao", "tcho", "dtiao", "tiol", " tfolio", "Tio", "torao", " tauto", "torio", "gcho", "Tios", "tfolio", "gios", "ttio", "Trio", "piol", "tios", "atios", "giao", "untios", "fio", "torios", "bitauto", "dio", "Tiol", "Tco", "fios", "fui", "dtio", "gio", "tior", "dco", "ttios", "Tauto", " tcho", "untrio", "atiol", "tigo", "fortio", " ticho", "pio", "torui", "tauto", "Tior"]}}
{"project": "qemu", "commit_id": "17ad9b358bceba78ae80f2963c6036eab726010c", "target": 0, "func": "static int ram_save_block(QEMUFile *f)\n\n{\n\n    RAMBlock *block = last_block;\n\n    ram_addr_t offset = last_offset;\n\n    int bytes_sent = -1;\n\n    MemoryRegion *mr;\n\n\n\n    if (!block)\n\n        block = QLIST_FIRST(&ram_list.blocks);\n\n\n\n    do {\n\n        mr = block->mr;\n\n        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,\n\n                                    DIRTY_MEMORY_MIGRATION)) {\n\n            uint8_t *p;\n\n            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;\n\n\n\n            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,\n\n                                      DIRTY_MEMORY_MIGRATION);\n\n\n\n            p = memory_region_get_ram_ptr(mr) + offset;\n\n\n\n            if (is_dup_page(p)) {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);\n\n                qemu_put_byte(f, *p);\n\n                bytes_sent = 1;\n\n            } else {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);\n\n                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);\n\n                bytes_sent = TARGET_PAGE_SIZE;\n\n            }\n\n\n\n            break;\n\n        }\n\n\n\n        offset += TARGET_PAGE_SIZE;\n\n        if (offset >= block->length) {\n\n            offset = 0;\n\n            block = QLIST_NEXT(block, next);\n\n            if (!block)\n\n                block = QLIST_FIRST(&ram_list.blocks);\n\n        }\n\n    } while (block != last_block || offset != last_offset);\n\n\n\n    last_block = block;\n\n    last_offset = offset;\n\n\n\n    return bytes_sent;\n\n}\n", "idx": 2280, "substitutes": {"f": ["fn", "fr", "bf", "feed", "inf", "i", "fs", "buff", "form", "cf", "l", "fc", "fi", "j", "conf", "fp", "fo", "ff", "tf", "m", "d", "af", "rf", "fb", "fm", "fen", "df", "handler", "v", "file", "fd", "g", "xf", "uf", "sf", "fw", "c", "self", "fa", "lf", "info", "fx", "b", "q", "e", "F", "fe"], "block": ["view", "part", "unit", "layout", "ref", "key", "group", "number", "check", "position", "row", "plugin", "info", "image", "channel", "cb", "state", "large", "page", "bc", "manager", "error", "object", "close", "node", "config", "call", "name", "limit", "buffer", "join", "run", "label", "ban", "pool", "map", "panel", "board", "pack", "box", "b", "bl", "open", "sync", "lc", "comment", "line", "lock", "offset", "base", "chain", "ack", "function", "session", "queue", "Block", "full", "batch", "length", "pre", "prev", "ip", "address", "out", "empty", "index", "clean", "clock", "loop", "cache", "loc", "un", "blocking", "header", "module", "other", "job", "id", "no", "off", "broad", "frame", "type", "coll", "work", "flow", "tx", "none", "range", "x", "link"], "mr": ["hm", "md", "MR", "bro", "fr", "rb", "Mr", "rr", "cr", "gr", "manager", "pr", "rh", "r", "sr", "attr", "tr", "rt", "pm", "wr", "er", "yr", "km", "dm", "dr", "module", "m", "bridge", "mi", "rf", "vm", "fm", "mm", "vr", "wk", "rm", "rd", "rpm", "mt", "shr", "kr", "spec", "wm", "rs", "rg", "nr", "asm", "ru", "mn", "mx", "mc", "mer", "rl", "ml", "lr", "bm", "cm", "br"], "p": ["offset", "i", "lp", "tp", "pr", "r", "bp", "l", "po", "pb", "j", "n", "o", "fp", "m", "pid", "api", "wp", "pe", "v", "py", "cp", "pc", "ps", "sp", "port", "ap", "pool", "pp", "pre", "pair", "c", "point", "np", "vp", "jp", "pi", "P", "t", "proc", "b", "q", "pa", "u", "ip", "address", "page", "e", "pointer", "pg"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,\n\n    size_t len)\n\n{\n\n    hwaddr mapped_len = 0;\n\n    struct iovec *ventry;\n\n    assert(pkt);\n\n    assert(pkt->max_raw_frags > pkt->raw_frags);\n\n\n\n    if (!len) {\n\n        return true;\n\n     }\n\n\n\n    ventry = &pkt->raw[pkt->raw_frags];\n\n    mapped_len = len;\n\n\n\n    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);\n\n    ventry->iov_len = mapped_len;\n\n    pkt->raw_frags += !!ventry->iov_base;\n\n\n\n    if ((ventry->iov_base == NULL) || (len != mapped_len)) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 2297, "substitutes": {"pkt": ["ppacket", "spct", " pnt", "opet", "spelt", " pelt", "ppcht", "pet", "pnt", "apkt", "Pct", "apett", "Pkt", "Pnt", " pett", " pcht", "packet", "pelt", "ppnt", "cpnt", "pcht", "opnt", "apeth", "apnt", "cpacket", "pct", "apct", "Packet", "opacket", "cpct", "spacket", " peth", "apacket", " packet", " pct", "pwk", "Pet", " pwk", "Pwk", "cpkt", "cpcht", "Peth", "spkt", "ppkt", "peth", "opwk", "opkt", " pet", "Pelt", "Pett", "pett"], "pa": ["wa", "opa", "base", "apa", "ota", "pai", "ara", "po", "ia", "ta", "PA", "ana", "ama", " Pa", "ha", "p", "ada", "ka", "va", "eta", "api", "ma", "sa", "ba", "ppa", "ua", "sea", " sa", "cp", "pc", "ca", "Pa", "fa", "jp", "pu", "cpu", "pi", "LA", "qua", "na", "au", " ma", " PA"], "len": ["val", "lp", "part", "base", "loc", "late", "en", "lu", "l", "gen", "lt", "lon", "elt", "n", "alt", "lib", "lim", "le", "lin", "fin", "fl", "rev", "z", "ln", "limit", " length", "hl", "vec", "ld", "count", "Len", "lit", "pos", "el", "li", "str", "data", "ler", "lan", "length", "nt", "pre", "zi", "lic", "la", "lem", "f", "size", "ls", "lf", "lc", "seq"], "ventry": ["elementrying", "eventrying", "emptrey", "gentri", "emptri", "ventrying", "emptray", "nightrying", "entary", "ventary", "ventrys", "entries", "eventcy", "ventcy", "gentrying", "ventray", "gentrys", "vertry", "ppri", "questries", "ppry", "questri", "vertri", "emptcy", "cfcy", "pprying", "eventary", "eventray", "vertrying", "cfries", "emptrys", "eventry", "emptrying", "emptry", "elementrey", "nightrys", "gentry", "questray", "ventri", "eventries", "elementri", "nightry", "questry", "eventri", "emptries", "eventrys", "ventries", "cfry", "cfrys", "pprys", "entray", "vertrey", "ventrey", "elementry", "entry", "nightri", "questary"]}}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,\n\n                     const uint16_t *buf1, const uint16_t *ubuf0,\n\n                     const uint16_t *ubuf1, const uint16_t *vbuf0,\n\n                     const uint16_t *vbuf1, const uint16_t *abuf0,\n\n                     const uint16_t *abuf1, uint8_t *dest, int dstW,\n\n                     int yalpha, int uvalpha, int y,\n\n                     enum PixelFormat target)\n\n{\n\n    int  yalpha1 = 4095 - yalpha;\n\n    int uvalpha1 = 4095 - uvalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < (dstW >> 1); i++) {\n\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;\n\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;\n\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;\n\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;\n\n\n\n        output_pixels(i * 4, Y1, U, Y2, V);\n\n    }\n\n}\n", "idx": 2298, "substitutes": {"i": ["hi", "chi", "ui", "io", "r", "l", "ik", "fi", "iii", "si", "is", "j", "n", "uri", "y", "o", "p", "ci", "key", "multi", "qi", "d", "m", "oi", "cli", "api", "id", "z", "I", "mi", "w", "adi", "ri", "yi", "ori", "k", "ini", "ii", "ij", "v", "bi", "type", "li", "iu", "ie", "ki", "c", "in", "zi", "di", "ix", "ai", "info", "pi", "b", "f", "u", "gi", "ti", "ip", "e", "xi", "x", "it", "phi", "iv", "h", "source", "index", "isi"]}}
{"project": "FFmpeg", "commit_id": "2207ea44fb4fad4d47646a789bc244e3e84c1726", "target": 0, "func": "static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src,\n\n                                              int linesize,\n\n                                              int block_w, int block_h,\n\n                                              int src_x, int src_y,\n\n                                              int w, int h,\n\n                                              emu_edge_core_func *core_fn)\n\n{\n\n    int start_y, start_x, end_y, end_x, src_y_add = 0;\n\n\n\n    if (src_y >= h) {\n\n        src_y_add = h - 1 - src_y;\n\n        src_y     = h - 1;\n\n    } else if (src_y <= -block_h) {\n\n        src_y_add = 1 - block_h - src_y;\n\n        src_y     = 1 - block_h;\n\n    }\n\n    if (src_x >= w) {\n\n        src   += w - 1 - src_x;\n\n        src_x  = w - 1;\n\n    } else if (src_x <= -block_w) {\n\n        src   += 1 - block_w - src_x;\n\n        src_x  = 1 - block_w;\n\n    }\n\n\n\n    start_y = FFMAX(0, -src_y);\n\n    start_x = FFMAX(0, -src_x);\n\n    end_y   = FFMIN(block_h, h-src_y);\n\n    end_x   = FFMIN(block_w, w-src_x);\n\n    av_assert2(start_x < end_x && block_w > 0);\n\n    av_assert2(start_y < end_y && block_h > 0);\n\n\n\n    // fill in the to-be-copied part plus all above/below\n\n    src += (src_y_add + start_y) * linesize + start_x;\n\n    buf += start_x;\n\n    core_fn(buf, src, linesize, start_y, end_y,\n\n            block_h, start_x, end_x, block_w);\n\n}\n", "idx": 2300, "substitutes": {"buf": ["offset", "rb", "buff", "loc", "rc", "ptr", "cmp", "array", "ctx", "img", "pb", "conv", "alloc", "tmp", "stack", "ref", "config", "queue", "buffer", "Buffer", "vec", "fb", "count", "bus", "cv", "stream", "fd", "dest", "data", "uf", "port", "sb", "pool", "bag", "gb", "block", "cb", "proc", "b", "cmd", "bc", "cas", "uc", "msg", "seq", "br"], "src": ["gl", "dist", "support", "rb", "rect", "sur", "loc", "inst", "sc", "sr", "attr", "secure", "rc", "sub", "scenes", "fc", "ctx", "img", "sec", "ssl", "sel", "st", "bg", "input", "split", "config", "sq", "send", "buffer", "rss", "stat", "slice", "stream", "dest", "gz", "feat", "rib", "spec", "sb", "rs", "url", "comp", "gb", "start", "image", "cb", "proc", "b", "rob", "cur", "uc", "sl", "bc", "sup", "sync", "seq", "source"], "linesize": ["paramsize", "pagesization", "postsized", " linessize", "blocksIZE", "planesization", "pagessize", "paramsIZE", "lightsization", "blocksization", " linesized", "pagesIZE", "lightsized", " linesIZE", "planesize", "paramsization", "paramsized", " linesization", "postsize", "blocksize", "planesized", "lightsize", "linesized", "pagesize", "postsization", "linessize", "lightssize", "postsIZE", "blockssize", "linesization", "planessize", "linesIZE"], "block_w": ["blockingh", "blockacwt", "nodeacx", "block_rw", "block64wx", "blockIdw", " block_work", "lock_rw", "block67sh", " block_wx", " block_x", " block_sw", "block00h", "lock_x", "block25work", "block67x", "node_sh", "block25fw", "block_work", " block_wt", " block_rw", "blockings", "blockacsh", "block_x", "nodeacw", "blockIdwork", "blockacx", "blockingx", "lock_h", "block24wx", "block24h", "block_fw", "block24rw", "block_wt", "nodeacwin", "block00wx", "block_ws", "blockacwin", "block67w", "block_win", "block_sw", "lock_y", "block00rw", "blockacwx", " block_fw", "node_win", "lock_w", "block25h", "block25w", "node_w", "blockIdfw", "block64h", "lock_s", "block_sh", "block00y", "block67win", "block_s", "block24w", "block_y", "blockingw", "block00w", "node_x", "blockacws", "blockacsw", "block64sw", "blockach", "nodeacsh", "blockIdh", "block64w", "blockacw", " block_ws", "block_wx"], "block_h": ["blocknh", "block2h", "block67h", "block67gh", "Block_w", "block_hs", "block00h", "Block_bh", "block2y", "Block_y", "block12gh", "block2x", "block_x", "block_wa", " block_loc", "block53hw", "block55hs", "block55wa", "block00x", "lock_h", "block_oh", "block24h", "block55y", "blocknhw", "block_bh", "Block_x", "block67w", "block53w", "lock_y", "block24hw", "block_ih", "blocknbh", "block_gh", "block_loc", "block24bh", "block53y", "lock_w", " block_hs", "Block_ih", "block12w", "block00y", "Block_h", "Block_hw", "block2ih", " block_gh", "block00ih", "block55h", "block24w", "block_y", " block_wa", "block_hw", "blocknw", "block12h", " block_y", "block53h", "block67loc", "block12loc", "lock_hw", " block_oh"], "src_x": ["src___z", "block_z", "src_n", "src_ady", "src2w", "source_y", "src_z", "src___y", " src_w", " src_z", "block_x", "srcqy", "srcqz", "block_n", "sup_w", "src2x", "source_X", "sup_y", "src_xd", "src2y", "src2h", "src___x", "src_h", "sup_X", "block_y", "source_x", " src_h", "src_X", "src_w", "srcqx", "source_ady", "srcqady", "sup_x", "source_z", "source_xd", "src___n"], "src_y": ["src_ya", "srcurex", "source_Y", "source_yo", "srcureya", "src2w", "block_yl", "source_ya", "src00yo", "source_y", "src2z", "srcqyt", "src_z", "srcuresky", "srcameyn", " src_w", " src_z", "block_x", "srcqy", "src_yo", "srcameY", "src_vy", "src2x", "srcamey", " src_ny", "srcamex", "src_ny", "src2y", "source_yn", "src00x", "src_sky", "block_ya", "srcacny", "src00y", "srcacx", "srcacyt", " src_yt", " src_yo", "srcurey", "src_yt", "block_y", "source_x", "src00z", "src_yl", "src_w", "srcqx", "srcacyo", " src_vy", "srcacy", "block_sky", "srcqny", "src_yn", "srcacya", "src_Y"], "w": ["kw", "wa", "wx", "wd", "sw", "r", "rh", "l", "n", "sh", "y", "wh", "o", "p", "d", "m", "wo", "win", "z", "wp", "iw", "k", "aw", "v", "a", "g", "wt", "work", "fw", "c", "W", "t", "max", "b", "q", "u", "cl", "f", "ow", "wb", "e", "ew", "x", "hw", "s"], "h": ["hi", "hm", "host", "high", "wa", "home", "rh", "r", "en", "l", "hs", "hh", "n", "gh", "sh", "y", "o", "height", "p", "ht", "ha", "d", "m", "z", "head", "s", "k", "oh", "v", "end", "th", "uh", "ah", "g", "c", "ph", "bh", "ch", "ih", "t", "hp", "b", "q", "f", "u", "e", "x", "hw", "H"], "core_fn": ["corefuncfn", "corePfunc", "cr_fn", "corefuncfunction", "corefuncfs", "cr_function", "core_func", "cr_func", "core_format", "cr_format", "core_function", "corePfn", "cr_fs", "core_fs", "corefuncfunc", "corePfunction", "corePformat"], "start_y": ["start_z", "start00z", "startjyi", "start_yi", "start05x", "end_cy", "start67ry", "start_ry", "start67yi", "startjy", "start00ny", "startJny", "end_ny", "start05y", "start67x", "startJx", "startjry", "end_yl", "start05yl", "start67y", "start_year", "start00y", "end_z", "end_yn", "startCx", "startJz", "startCyi", "start00x", " start_yi", "start05year", "end_yi", "start_yn", "startJcy", "startCyn", "startCy", "start_ny", "startjx", "start_cy", " start_ry", "startJy", "end_year", "start_yl"], "start_x": ["start_wy", "start64z", "start_z", "start___x", "start00z", "startlye", "start_ey", "startJxs", "startlx", "start_width", "startJwidth", "start_xi", "end_asy", "end_ey", "end_X", "start_X", "start_ye", "end_xs", "start_ya", "startallX", "end_ye", "start___y", "start64x", "startJx", "start_xs", "start00ey", "startallx", "startly", "end_wy", "start00y", "end_z", "startally", "start_xy", "start00x", "startJxi", "end_xi", "start64y", "startlwy", "start64ey", "end_xy", "start___asy", "start___xs", "startJxy", "end_width", "end_ya", "start_asy", "start___z", "startallya", "startJy", "start___width"], "end_y": ["end_i", "endJny", " endJya", "start_dy", "endXx", "endXyi", "start_yn", "endLdy", "start_ya", "endJx", "endDyn", "end2x", "end33x", "endDy", "start_w", "end1x", "end_dy", "end_yn", "end2i", "endXyn", "end33y", "endLy", " endJny", "endJy", "endLya", "end2y", "end1w", "end_ya", " endJy", "end33ya", " end_ny", "start_i", "end33ny", "end1i", "endDx", "end_ny", "end_w", " end_ya", "endJdy", "endXy", "end_yi", " endJx", "endDyi", "endJya", "start_yi", "end1y", "end2w", "endLx"], "end_x": ["end_xs", "start_z", "end_ys", "start_yn", "start_ya", "endJx", "end64y", "start_ys", "endjya", "start_ey", "end_z", "end_yn", "endJy", "endjx", "end64yn", "end64x", "end_ya", "endJX", "endjy", "end_ey", "end_X", "start_X", "endjyn", "endJz", "end64ya", "start_xs"]}}
{"project": "FFmpeg", "commit_id": "e838c9852e6f0a471a6917083e70e6fe238ba26a", "target": 1, "func": "static av_cold int init_bundles(BinkContext *c)\n\n{\n\n    int bw, bh, blocks;\n\n    int i;\n\n\n\n    bw = (c->avctx->width  + 7) >> 3;\n\n    bh = (c->avctx->height + 7) >> 3;\n\n    blocks = bw * bh;\n\n\n\n    for (i = 0; i < BINKB_NB_SRC; i++) {\n\n        c->bundle[i].data = av_malloc(blocks * 64);\n\n        if (!c->bundle[i].data)\n\n            return AVERROR(ENOMEM);\n\n        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2325, "substitutes": {"c": ["cu", "cache", "dc", "cc", "cr", "com", "cy", "sc", "cf", "ac", "l", "fc", "cs", "enc", "ctx", "conf", "n", "vc", "p", "ci", "ce", "ic", "ec", "ct", "xc", "tc", "con", "cp", "lc", "pc", "ca", "co", "g", "ctrl", "nc", "ch", "mc", "oc", "t", "b", "f", "u", "cur", "C", "e", "bc", "uc", "cm", "cd", "h"], "bw": [" bwd", "adwh", "barw", "fws", "bwh", "bwt", "adwa", "bbwt", "bbw", "bwa", "bws", " bwa", "bbwa", "lbwa", "barwd", "fwd", "barwt", "adw", "fh", "lbwd", "barwa", " bwh", "fw", "abwa", "lbwt", "lbw", "Bw", "Bws", " bws", "Bwd", "Bh", "abwd", "abw", "bwd", "abwh", "adwd", "bbwd"], "bh": ["hi", "bf", "rb", "sth", "rh", "bp", "bang", "hh", "pb", "bb", "xb", "adh", "ht", "ib", "bg", "obb", "bs", "sq", "yah", "fb", "kh", "bi", "uh", "ah", "abb", "eth", "length", "hub", "sb", "ph", "dq", "ch", "ih", "cb", "hp", "b", "db", "wb", "bl", "lb", "phi", "bm", "hy", "h"], "blocks": ["flows", "times", "cells", "works", "blocking", "pages", "cycles", "types", "height", "qs", "breaks", "ools", "bits", "values", "forces", "items", "groups", "ins", "rows", "bs", "words", "errors", "bags", "units", "loads", "jobs", "bars", "lines", "frames", "steps", "books", "gets", "stores", "hops", "outs", "results", "files", "block", "locks", "limits", "angles", "rules", "planes", "waves", "runs", "bytes", "plugins", "Blocks", "checks"], "i": ["hi", "ui", "hei", "io", "l", "fi", "iii", "si", "j", "uri", "o", "p", "ci", "multi", "qi", "module", "eni", "cli", "split", "d", "oi", "interface", "mi", "ori", "I", "id", "api", "ri", "area", "qa", "k", "ini", "ii", "slice", "bi", "a", "uli", "li", "ami", "iu", "ie", "ji", "zi", "di", "layer", "ai", "ix", "info", "abi", "init", "pi", "mu", "b", "gi", "f", "u", "ti", "ip", "child", "page", "ni", "xi", "x", "e", "phi", "iv", "yi", "lc", "index"]}}
{"project": "qemu", "commit_id": "cf29a570a7aa7abab66bf256fdf9540873590811", "target": 1, "func": "static void quorum_vote(QuorumAIOCB *acb)\n\n{\n\n    bool quorum = true;\n\n    int i, j, ret;\n\n    QuorumVoteValue hash;\n\n    BDRVQuorumState *s = acb->common.bs->opaque;\n\n    QuorumVoteVersion *winner;\n\n\n\n    if (quorum_has_too_much_io_failed(acb)) {\n\n        return;\n\n    }\n\n\n\n    /* get the index of the first successful read */\n\n    for (i = 0; i < s->num_children; i++) {\n\n        if (!acb->qcrs[i].ret) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    assert(i < s->num_children);\n\n\n\n    /* compare this read with all other successful reads stopping at quorum\n\n     * failure\n\n     */\n\n    for (j = i + 1; j < s->num_children; j++) {\n\n        if (acb->qcrs[j].ret) {\n\n            continue;\n\n        }\n\n        quorum = quorum_compare(acb, &acb->qcrs[i].qiov, &acb->qcrs[j].qiov);\n\n        if (!quorum) {\n\n            break;\n\n       }\n\n    }\n\n\n\n    /* Every successful read agrees */\n\n    if (quorum) {\n\n        quorum_copy_qiov(acb->qiov, &acb->qcrs[i].qiov);\n\n        return;\n\n    }\n\n\n\n    /* compute hashes for each successful read, also store indexes */\n\n    for (i = 0; i < s->num_children; i++) {\n\n        if (acb->qcrs[i].ret) {\n\n            continue;\n\n        }\n\n        ret = quorum_compute_hash(acb, i, &hash);\n\n        /* if ever the hash computation failed */\n\n        if (ret < 0) {\n\n            acb->vote_ret = ret;\n\n            goto free_exit;\n\n        }\n\n        quorum_count_vote(&acb->votes, &hash, i);\n\n    }\n\n\n\n    /* vote to select the most represented version */\n\n    winner = quorum_get_vote_winner(&acb->votes);\n\n\n\n    /* if the winner count is smaller than threshold the read fails */\n\n    if (winner->vote_count < s->threshold) {\n\n        quorum_report_failure(acb);\n\n        acb->vote_ret = -EIO;\n\n        goto free_exit;\n\n    }\n\n\n\n    /* we have a winner: copy it */\n\n    quorum_copy_qiov(acb->qiov, &acb->qcrs[winner->index].qiov);\n\n\n\n    /* some versions are bad print them */\n\n    quorum_report_bad_versions(s, acb, &winner->value);\n\n\n\nfree_exit:\n\n    /* free lists */\n\n    quorum_free_vote_list(&acb->votes);\n\n}\n", "idx": 2328, "substitutes": {"acb": ["ocp", "aucl", "ancl", "ecfb", "aucbase", "accl", "ACb", "ucbc", "uclb", "accbar", "accob", "ecbb", " acB", "aucfb", "aucb", "actfb", "acgb", "ancfb", "ecsb", "arcB", "ucrb", "acd", "eca", " acxb", "ascbb", "acnb", "macxb", "accfb", "ecxb", "ecc", "ancbc", "arcf", " acnb", "akmb", "acsgb", "accd", "acsbb", "acbf", "acob", "ACf", "ecv", "uca", "acbar", "ascbar", "ecd", "ecb", "uck", "actk", "acsxb", "accn", "ocl", "ACbb", "acfb", "macd", "arcb", "akb", "acv", "anca", "acbd", "ucc", " acp", " acob", "acrb", "ecf", " acmb", "macb", "akbc", "macp", "acf", "accbb", " acsb", "aclsb", "racb", "ucp", " acbd", "ack", "akfb", "ucl", "actb", "accp", "ucb", " acl", "accb", " acbase", " acbb", "ancb", "accrb", "ucbd", "acl", "acbb", "acc", "axbb", "acxb", "ancwb", "aucob", "accbase", "ucv", "aclb", "racbf", "acn", "racbb", "ecp", " acgb", "aucf", "raclb", " acf", "akxb", "acsb", "accbf", "eck", "ucn", "acbc", "ecwb", "ancB", "acmb", "axbd", "ascfb", "aucp", "ucfb", "axnb", "acp", "macfb", "akrb", "ocb", "ancf", "akwb", "acwb", "aclmb", "ecbar", "akgb", "acca", "accsb", "arcbb", "ucbb", "acclb", "accc", "aklb", "acbase", "ancp", "aca", "axb", "racn", "ocbb", "ancbb", "ecmb", "ucnb", "aucbb", "accf", "mack", "ACl", "macsb", "aucbf", "ecl", "akp", "racv", "actxb", "accv", " aca", "akbb", "accmb", " acfb", "acB", "ascb", "racl", "aclf", "acck"], "i": ["anti", "part", "uri", "ib", "key", "d", "mi", "z", "ri", "v", "bi", "ami", "iu", "ie", "ji", "ix", "info", "pi", "f", "ti", "phi", "ki", "my", "ui", "l", "si", "y", "o", "p", "ci", "qi", "ind", "eni", "li", "init", "mu", "b", "q", "u", "xi", "it", "h", "io", "r", "ik", "ia", "fi", "multi", "oi", "m", "ori", "ij", "ini", "x", "zi", "ai", "ip", "e", "yi", "index", "hi", "im", "n", "id", "api", "k", "ii", "a", "mini", "c", "di", "gi", "ni", "I", "inner"], "j": ["jc", "je", "ui", "jo", "r", "bj", "l", "si", "n", "jl", "o", "y", "p", "jen", "qi", "ind", "d", "m", "aj", "z", "ja", "k", "ij", "ii", "v", "uj", "a", "jet", "li", "jj", "g", "ie", "jan", "ji", "jp", "b", "q", "f", "u", "js", "e", "ni", "x", "J", "index", "br"], "ret": ["cat", "bf", "val", "fail", "res", "req", "back", "error", "att", "match", "rc", "en", "def", "rt", "flag", "lt", "num", "alt", "opt", "valid", "ref", "RET", "mem", "det", "gt", "rev", "id", "status", "et", "store", "len", "hard", "bot", "lit", "count", "success", "ext", "rets", "reply", "mt", "flat", "fun", "nt", "reg", "url", "result", "rot", "arg", "Ret", "f", "err", "last", "ft", "re", "out", "pass", "bit", "seq", "art", "desc"], "hash": ["user", "val", "cache", "lock", " hashes", "res", "total", "base", "rh", "error", "her", "match", "num", "header", "sh", "alt", "ha", "ref", "key", "Hash", "number", "node", "sha", "rev", "id", "status", "sum", "kh", "dig", "full", "ruby", "g", "str", "ash", "pool", "url", "info", "depth", "result", "block", "response", "err", "version", " Hash", "pass", "bc", "message", "h", "msg", "seq", "index"], "s": ["conf", "d", "sa", "sis", "states", "ps", "sb", "sym", "state", "os", "f", "set", "js", "admin", "sort", "l", "sites", "is", "si", "o", "y", "qs", "p", "se", "stats", "ses", "site", "scope", "parser", "args", "b", "sg", "u", "ops", "sup", "sync", "S", "r", "sc", "settings", "cs", "ssl", "south", "new", "m", "sq", "w", "service", "g", "game", "us", "server", "spec", "ks", "es", "gs", "aws", "ss", "e", "sl", "ls", "http", "ds", "xs", "fs", "su", "sets", "ns", "n", "services", "a", "sys", "submit", "sf", "c", "self"], "winner": ["draw", "next", "won", "division", "worker", "role", "gen", "unit", "n", "num", "lot", "builder", "ani", "index", "Winner", "leader", "winning", "runner", "number", "root", "node", " winners", "token", "vote", "rev", "win", "status", "maker", "alpha", "wp", "slice", "master", "v", "adder", "success", "breaker", "year", "writer", "owner", "game", "rank", "parser", "init", "ner", "result", "block", "addon", "nick", "vict", "creator", "bin", "player", "nic", "version", "live", "widget", "score", "student", "bc", "inner", "reader", "author", "seller"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void stellaris_init(const char *kernel_filename, const char *cpu_model,\n\n                           stellaris_board_info *board)\n\n{\n\n    static const int uart_irq[] = {5, 6, 33, 34};\n\n    static const int timer_irq[] = {19, 21, 23, 35};\n\n    static const uint32_t gpio_addr[7] =\n\n      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,\n\n        0x40024000, 0x40025000, 0x40026000};\n\n    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};\n\n\n\n    qemu_irq *pic;\n\n    DeviceState *gpio_dev[7];\n\n    qemu_irq gpio_in[7][8];\n\n    qemu_irq gpio_out[7][8];\n\n    qemu_irq adc;\n\n    int sram_size;\n\n    int flash_size;\n\n    I2CBus *i2c;\n\n    DeviceState *dev;\n\n    int i;\n\n    int j;\n\n\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *flash = g_new(MemoryRegion, 1);\n\n    MemoryRegion *system_memory = get_system_memory();\n\n\n\n    flash_size = (((board->dc0 & 0xffff) + 1) << 1) * 1024;\n\n    sram_size = ((board->dc0 >> 18) + 1) * 1024;\n\n\n\n    /* Flash programming is done via the SCU, so pretend it is ROM.  */\n\n    memory_region_init_ram(flash, NULL, \"stellaris.flash\", flash_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(flash);\n\n    memory_region_set_readonly(flash, true);\n\n    memory_region_add_subregion(system_memory, 0, flash);\n\n\n\n    memory_region_init_ram(sram, NULL, \"stellaris.sram\", sram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(sram);\n\n    memory_region_add_subregion(system_memory, 0x20000000, sram);\n\n\n\n    pic = armv7m_init(system_memory, flash_size, NUM_IRQ_LINES,\n\n                      kernel_filename, cpu_model);\n\n\n\n    if (board->dc1 & (1 << 16)) {\n\n        dev = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000,\n\n                                    pic[14], pic[15], pic[16], pic[17], NULL);\n\n        adc = qdev_get_gpio_in(dev, 0);\n\n    } else {\n\n        adc = NULL;\n\n    }\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (0x10000 << i)) {\n\n            dev = sysbus_create_simple(TYPE_STELLARIS_GPTM,\n\n                                       0x40030000 + i * 0x1000,\n\n                                       pic[timer_irq[i]]);\n\n            /* TODO: This is incorrect, but we get away with it because\n\n               the ADC output is only ever pulsed.  */\n\n            qdev_connect_gpio_out(dev, 0, adc);\n\n        }\n\n    }\n\n\n\n    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr.a);\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            gpio_dev[i] = sysbus_create_simple(\"pl061_luminary\", gpio_addr[i],\n\n                                               pic[gpio_irq[i]]);\n\n            for (j = 0; j < 8; j++) {\n\n                gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j);\n\n                gpio_out[i][j] = NULL;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (board->dc2 & (1 << 12)) {\n\n        dev = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]);\n\n        i2c = (I2CBus *)qdev_get_child_bus(dev, \"i2c\");\n\n        if (board->peripherals & BP_OLED_I2C) {\n\n            i2c_create_slave(i2c, \"ssd0303\", 0x3d);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (1 << i)) {\n\n            sysbus_create_simple(\"pl011_luminary\", 0x4000c000 + i * 0x1000,\n\n                                 pic[uart_irq[i]]);\n\n        }\n\n    }\n\n    if (board->dc2 & (1 << 4)) {\n\n        dev = sysbus_create_simple(\"pl022\", 0x40008000, pic[7]);\n\n        if (board->peripherals & BP_OLED_SSI) {\n\n            void *bus;\n\n            DeviceState *sddev;\n\n            DeviceState *ssddev;\n\n\n\n            /* Some boards have both an OLED controller and SD card connected to\n\n             * the same SSI port, with the SD card chip select connected to a\n\n             * GPIO pin.  Technically the OLED chip select is connected to the\n\n             * SSI Fss pin.  We do not bother emulating that as both devices\n\n             * should never be selected simultaneously, and our OLED controller\n\n             * ignores stray 0xff commands that occur when deselecting the SD\n\n             * card.\n\n             */\n\n            bus = qdev_get_child_bus(dev, \"ssi\");\n\n\n\n            sddev = ssi_create_slave(bus, \"ssi-sd\");\n\n            ssddev = ssi_create_slave(bus, \"ssd0323\");\n\n            gpio_out[GPIO_D][0] = qemu_irq_split(\n\n                    qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0),\n\n                    qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0));\n\n            gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0);\n\n\n\n            /* Make sure the select pin is high.  */\n\n            qemu_irq_raise(gpio_out[GPIO_D][0]);\n\n        }\n\n    }\n\n    if (board->dc4 & (1 << 28)) {\n\n        DeviceState *enet;\n\n\n\n        qemu_check_nic_model(&nd_table[0], \"stellaris\");\n\n\n\n        enet = qdev_create(NULL, \"stellaris_enet\");\n\n        qdev_set_nic_properties(enet, &nd_table[0]);\n\n        qdev_init_nofail(enet);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]);\n\n    }\n\n    if (board->peripherals & BP_GAMEPAD) {\n\n        qemu_irq gpad_irq[5];\n\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n\n\n\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */\n\n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */\n\n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */\n\n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */\n\n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */\n\n\n\n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n\n    }\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            for (j = 0; j < 8; j++) {\n\n                if (gpio_out[i][j]) {\n\n                    qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 2329, "substitutes": {"kernel_filename": ["kernelprofil", "system_fil", "kernel__filename", "kernel_file", "kernelmfile", "kernelprofunction", "system_function", "kernelminformation", "kernel__information", "kernel_prefix", "kernelmfilename", "kernel__prefix", "kernel__file", "system_prefix", "system_information", "kernelprofilename", "kernel_function", "system_file", "system_filename", "kernel_fil", "kernelmprefix", "kernel_information", "kernelprofile"], "cpu_model": ["cpuemmodel", "cpulogmodel", "cpuingdescription", "cpu_location", "linux_model", "cpulogfile", "cpu_file", "cpuemmodule", " cpu_filename", "cpu_filename", " cpuemmodel", "cpuemdescription", "cpuingmodel", "linux_models", "cpu_description", "linuxlogmodels", "cpulogmodels", "linuxloglocation", "cpuingmodule", "cpu_models", "cpuemfilename", "cpuingfilename", "linuxlogmodel", " cpu_module", " cpu_description", " cpuemdescription", " cpuemfilename", "cpuloglocation", "linux_file", "linuxlogfile", "linux_location", "cpu_module", " cpuemmodule"], "board": ["comment", "model", "line", "loop", "ko", "driver", "cache", "cart", "database", "bug", "flo", "card", "device", "ack", "stroke", "Board", "o", "cell", "bo", "control", "deck", "node", "config", "bridge", "buffer", "hole", "table", "boards", "frame", "data", "bean", "coll", "brand", "row", "game", "server", "ban", "plane", "room", "flow", "plugin", "boot", "image", "block", "controller", "lane", "design"], "uart_irq": ["pu_ierc", "pu_irc", "pu_mirche", "pu_mirq", "pu_ireQ", "pu_ireq", "pu_ierq", "pu_mirQ", "pu_irche", "pu_mirc", "pu_irq", "pu_irQ", "pu_irec", "pu_ireche", "pu_ierQ", "pu_ierche"], "timer_irq": ["timer_ireq", "timer_arq", "timer_mirQ", "timer_mirq", "timer_irQ", "timer_arque", "timer_ireQ", "timer_mirque", "timer_arQ", "timer_arqs", "timer_ireque", "timer_ireqs", "timer_irque", "timer_mirqs", "timer_irqs"], "gpio_addr": ["gpios_addr", "gpios_address", "gpios_dev", "gpio_devices", "gpio_address", "gpios_devices"], "gpio_irq": ["gpio_ireque", "gpio_iriq", "gpio_arq", "gpio_mirque", "gpio_irque", "gpio_ireq", "gpio_ireQ", "gpio_mirQ", "gpio_miriq", "gpio_mirq", "gpio_ireiq", "gpio_ariq", "gpio_arque", "gpio_irQ", "gpio_arQ"], "pic": ["picture", "cache", "las", "plan", "mac", "scan", "Pic", "ac", "fc", "fi", "avi", "img", "lib", "mag", "ig", "ic", "ec", "pin", "module", "cci", "cam", "mic", "bi", "mini", "pc", "pict", "file", "li", "feat", "capt", "pins", "plugin", "mc", "image", "proc", "nic", "gui", "bc", "xi", "sync", "lc"], "gpio_dev": ["gpios_device", "gpios_info", "gpios_dev", "gpio_device", "gpio_info", "gpios_out"], "gpio_in": ["gpi_inc", "gpi_ins", "gpi_out", "gpio_inc", "gpi_in", "gpio_ins"], "gpio_out": ["gpio__in", "gpio_again", "gpi_again", "gpio__out", "gpio__outs", "gpi_outs", "gpi_out", "gpi_in", "gpio__again", "gpio_outs"], "adc": ["udc", "odf", "odm", "amdm", "adsc", "odsc", "udm", "adf", "amdc", "amdf", "amdsc", "adm", "odc", "udf", "udsc"], "sram_size": ["sramxscale", "sgram_size", "sgram_num", "sram_sized", "sram_num", "sramxoffset", "sram_name", "sramxsize", "sgram_width", "siam_size", "sgram_sized", "sram_capacity", "sram_Size", "sram_width", "sram_offset", "sgram_scale", "sgram_name", "siam_capacity", "sramxsized", "sram_scale", "sgram_offset", "siam_Size"], "flash_size": ["feed_white", "feed_chan", "feed48sized", "flash48white", "flash96white", "disk48size", "flash___offset", "feed_size", "disk_offset", "flash_offset", "flashaclength", "flash_style", "flash_range", "flash_scale", "disk_size", "flash48scale", "flashacsize", "flash_sum", "flash48size", " flash_bytes", " flash_sum", "flash_chan", "flash___style", "flash48chan", "flashalllength", "flash___size", "disk_style", "feed_sized", "feed48chan", "flash_white", "feed48white", "flash48style", "disk48offset", "flash96size", "flashallbytes", "flashacrange", "disk48scale", "feed48size", "flashallsum", "disk_scale", "flash_sized", "flash___scale", " flash_range", "flash_length", "flashallsize", " flash_length", "disk48style", "flashallrange", "flash96chan", "flash48offset", "flash96sized", "flash48sized", "flash_bytes"], "i2c": ["i4C", "i4c", "i5lc", "i5C", "ui2c", "i5dc", "i2C", "ui2dc", "i4lc", "i5c", "i2dc", "i2lc", "ui2lc", "ui2C", "i4dc"], "dev": ["user", "serial", "mac", "device", "conf", "debug", "mem", "cam", "pub", "mode", "mini", "loader", "conn", "pos", "data", "Dev", "app", "devices", "info", "pu", "boot", "block", " device", "feature", "ver", "ev"], "i": ["r", "l", "is", "n", "y", "o", "p", "d", "m", "z", "I", "w", "k", "ii", "v", "a", "g", "c", "in", "b", "f", "u", "e", "x", "h", "s"], "j": ["im", "n", "p", "d", "m", "aj", "job", "z", "ja", "k", "ij", "ii", "uj", "v", "jet", "jj", "ji", "jp", "b", "f", "jit", "js", "it", "J"], "sram": ["ssra", "tsgram", "psram", "psream", "asrum", " srum", "sream", "psra", "tsmem", "bsra", "ascm", "psgram", "sgram", " smem", "sscam", " scam", "bsream", "scam", "tsperse", "srum", "ssream", "psrum", "psperse", " sperse", "sflash", "Sflash", "psmem", "ssgram", "asram", "asgram", " scm", "sperse", "smem", " sflash", "pscm", "ssram", "sra", "bsgram", " sgram", "Sgram", "tsram", "ssflash", "Sram", "scm", "bsram", "Scam"], "flash": ["facebook", "fr", "serial", "feed", "view", "cache", "sw", "las", "fast", "zip", "scan", "transform", "bug", "bolt", "form", "fire", "array", "low", "zero", "pixel", "layout", "fly", "fl", "fox", "raw", "route", "slice", "Flash", "broad", "video", "flat", "row", "ban", "shadow", "boot", "image", "fish", "small", "pack", "large", "feature", "f", "silver", "browser", "push", "brush", "light", "flight", "pass", "spin", "http", "sync", "design", "FL"], "system_memory": ["access_usage", "access_memory", "objectalradius", "access_manager", "system_manager", "objectalcamera", "system_network", "shared_image", "object_location", " system_network", "shared_area", "system_camera", " system_message", "system_location", "system_message", " system_media", "system_usage", "object_memory", "systemalcamera", "object_radius", "accessMmanager", "systemalmemory", "system_radius", "system_media", "systemalradius", "objectalmemory", "system32radius", "systemMmemory", "access_disk", "system32camera", "shared_audio", "accessMmemory", "system_disk", "system_audio", "system32location", "accessMdisk", "accessMusage", "systemMmanager", "object_camera", "objectallocation", "systemallocation", "systemMdisk", "systemMusage", "system_area", "system_image", "system32memory", "shared_memory"]}}
{"project": "qemu", "commit_id": "6658ffb81ee56a510d7d77025872a508a9adce3a", "target": 1, "func": "void cpu_exec_init(CPUState *env)\n\n{\n\n    CPUState **penv;\n\n    int cpu_index;\n\n\n\n    if (!code_gen_ptr) {\n\n        code_gen_ptr = code_gen_buffer;\n\n        page_init();\n\n        io_mem_init();\n\n    }\n\n    env->next_cpu = NULL;\n\n    penv = &first_cpu;\n\n    cpu_index = 0;\n\n    while (*penv != NULL) {\n\n        penv = (CPUState **)&(*penv)->next_cpu;\n\n        cpu_index++;\n\n    }\n\n    env->cpu_index = cpu_index;\n\n\n    *penv = env;\n\n}", "idx": 2334, "substitutes": {"env": ["En", "eval", "next", "cache", "priv", "context", "enc", "ctx", "code", "conf", "core", "eu", "ep", "exec", "p", "tmp", "stack", "ec", "inel", "node", "eni", "config", "cv", "v", "end", "loader", "here", "conn", "el", "ne", "console", "ea", "NV", "server", "app", "export", "inner", "nc", "np", "scope", "exc", "global", "vs", "dict", "db", "args", "dev", "extra", "e", "environment", "empty", "net", "ev", "en", "Environment"], "penv": ["senv", "pnj", "fenf", "pinv", "fenchev", " penchev", "penj", "envt", "senf", "pinvs", "venvt", "penvt", "pnx", "pincode", " pencode", " penu", "penchev", "senvs", "penp", "stenh", "stench", "Penv", "pinp", "finv", "senvt", "Penu", "renvin", "fenvin", "penve", "renv", "fenj", "pench", "senu", "fenx", "pinve", "penf", "pnf", "finvs", "Penf", "fenh", "venve", "stenv", "pencode", "Penvt", "renchev", "fenvs", "fenp", "enf", "finvt", "pnv", "enj", "senh", "fencode", "pinvt", "fenu", "sench", " penx", "pinu", "penh", "renx", "fench", "fenv", "penx", "venv", "penu", "stenvs", " penvin", "enx", "penvin", "finve", "enu", " penp", "penvs", "venvs"], "cpu_index": ["cpu_name", "conn67ind", "pc_index", "cpu_slice", "cpu_i", "cpu_number", "cpu2index", "cpuxsize", "cpu_offset", "cpu__offset", "cpu67size", "cpu2length", "pu_length", "cpu_path", "cpu_pointer", "cpu_Index", " cpu_path", "pc_size", "cpuxind", "cpu2pointer", "cpu67index", "cpu__length", "pc_number", "pu_index", "conn67index", " cpu_Index", "cpuxnumber", "pc__number", " cpu_i", "cpuxindex", "cpu__index", "cpu_size", "pc__size", "conn_ind", "cpu__pointer", "pu_slice", "conn_index", "pc__offset", "cpu67ind", "pc_offset", "conn_size", "conn67size", "cpu2slice", "pu_pointer", "cpu__size", "pc__index", "cpu__number", "cpu_length", "conn67number", "cpu__slice", "conn_number", " cpu_name", "cpu_ind", "cpu67number"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tlong width, long height,\n\n\tlong lumStride, long chromStride, long dstStride)\n\n{\n\n\tRENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n", "idx": 2348, "substitutes": {"ysrc": ["sysroc", "ysrt", "iessrc", "iesrc", "yssrc", "sysrt", "xsrc", "ysroc", "sroc", "src", "insroc", "syssrc", "ssrc", "iesync", "insRC", "sysync", "sRC", "xsync", "xssrc", "iesrt", "ysync", "inssrc", "insrc", "xsrt", "ysRC", "sysRC", "sysrc"], "usrc": [" usri", "udc", "ussrc", " ussrc", "ausdc", " usource", "uri", "ausource", "uource", "usri", "ausrc", "ausri", "usource", " usdc", "usdc", "aussrc", "urc"], "vsrc": ["vloc", "vssource", "ussrc", "wsrc", "fsource", "vssrc", "vst", "usst", "wsl", "ussource", "fsrc", "svsrc", "vsl", "usource", "vsst", "ust", "wsource", "svloc", "fsl", "svsl", "vsource", "vrc", "urc", "floc", "svsource", "wloc"], "dst": ["sddest", "Dsrc", "dste", " dbe", "dsts", "ssrc", "sst", "bdbe", " dste", "Ddest", "sdST", "dbe", "bdste", "bdsts", "dsrc", "idbe", "sdst", "sdest", "idsts", "ddest", "sdsrc", "idste", "sST", "dST", "idst", "Dst", "bdst", "DST", " dsts"], "height": ["high", "dist", "padding", "img", "density", "stroke", "bottom", " heights", "y", "square", "deep", "crop", "images", "input", "alpha", "resolution", "dim", "pad", "above", "distance", "wrap", "window", "length", "shape", "direction", "rank", "depth", "image", "style", "hd", "max", "gap", "thin", "Height", "size", "pull", "ty", "h"], "lumStride": ["lumSTri", "lumstrite", "lumScrip", "lumSTro", "lumstro", "lumSTrip", "lumStro", "lumScride", "lumStrip", "lumSTrite", "lumbStri", "lumbstro", "lumbstride", "lumStrro", "lumbStrride", "lumbStro", "lumstride", "lumbStride", "lumbStrite", "lumstri", "lumStrri", "lumStrite", "lumbStrip", "lumbStrri", "lumbstrip", "lumStri", "lumstrip", "lumbstrite", "lumbStrrip", "lumStrrip", "lumStrride", "lumbStrro", "lumSTride", "lumScro", "lumScrite"], "chromStride": ["chromUro", "homStrip", "chromStrric", "chromStri", "chromUerve", "chromStrip", "homStride", "chromEstri", "chromStrri", "chromStrride", "romstrite", "chromUrite", "romstride", "chromSTric", "chromstro", "homStric", "chromEstride", "chromSTrip", "chromSTerve", "chromStro", "romStride", "chromsterve", "chromStrite", "chromUride", "chromSTride", "chromSTri", "chromSTro", "chromstrite", "chromEstric", "chromSTrite", "romsterve", "chromStric", "romstro", "romStro", "homStri", "homStrri", "homStrride", "homStrric", "chromEstrip", "chromStrrip", "chromSterve", "chromstride", "romSterve", "homStrrip", "romStrite"], "dstStride": ["dscStrip", "dscStrride", "dstRestrip", "dspStue", "dscStide", "dspTrip", "dstSTend", "dstTend", "dstStue", "dstStrride", "dstRestride", "dspStend", "dstStrrip", "dstRestro", "dstStro", "dstStide", "dspStride", "dspTend", "dstTrip", "dspTride", "dscStride", "dstTride", "dstClrip", "dstStend", "dstClue", "dstSTue", "dstSTrip", "dstTue", "dspStrip", "dstClride", "dspTue", "dscStrrip", "dstRestide", "dstSTride", "dscStrro", "dstClend", "dstStrip", "dscStro", "dstStrro"]}}
{"project": "qemu", "commit_id": "65207c59d99f2260c5f1d3b9c491146616a522aa", "target": 1, "func": "static inline bool handler_is_async(const mon_cmd_t *cmd)\n\n{\n\n    return cmd->flags & MONITOR_CMD_ASYNC;\n\n}\n", "idx": 2349, "substitutes": {"cmd": ["md", "cat", "cod", "dc", "cc", "cfg", "pkg", "req", "comm", "cf", "cookie", "cmp", "ctx", "code", "core", "command", "node", "module", "cli", "call", "obj", "Cmd", "buf", "method", "cp", "conn", "func", "c", "ctrl", "plugin", "cb", "std", "ctr", "cm", "client", "msg", "dom", "cd"]}}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int vqa_decode_init(AVCodecContext *avctx)\n\n{\n\n    VqaContext *s = (VqaContext *)avctx->priv_data;\n\n    unsigned char *vqa_header;\n\n    int i, j, codebook_index;;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = PIX_FMT_PAL8;\n\n    avctx->has_b_frames = 0;\n\n    dsputil_init(&s->dsp, avctx);\n\n\n\n    /* make sure the extradata made it */\n\n    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: expected extradata size of %d\\n\", VQA_HEADER_SIZE);\n\n\n\n\n\n    /* load up the VQA parameters from the header */\n\n    vqa_header = (unsigned char *)s->avctx->extradata;\n\n    s->vqa_version = vqa_header[0];\n\n    s->width = LE_16(&vqa_header[6]);\n\n    s->height = LE_16(&vqa_header[8]);\n\n\n\n\n\n    s->vector_width = vqa_header[10];\n\n    s->vector_height = vqa_header[11];\n\n    s->partial_count = s->partial_countdown = vqa_header[13];\n\n\n\n    /* the vector dimensions have to meet very stringent requirements */\n\n    if ((s->vector_width != 4) ||\n\n        ((s->vector_height != 2) && (s->vector_height != 4))) {\n\n        /* return without further initialization */\n\n\n\n\n\n    /* allocate codebooks */\n\n    s->codebook_size = MAX_CODEBOOK_SIZE;\n\n    s->codebook = av_malloc(s->codebook_size);\n\n    s->next_codebook_buffer = av_malloc(s->codebook_size);\n\n\n\n    /* initialize the solid-color vectors */\n\n    if (s->vector_height == 4) {\n\n        codebook_index = 0xFF00 * 16;\n\n        for (i = 0; i < 256; i++)\n\n            for (j = 0; j < 16; j++)\n\n                s->codebook[codebook_index++] = i;\n\n    } else {\n\n        codebook_index = 0xF00 * 8;\n\n        for (i = 0; i < 256; i++)\n\n            for (j = 0; j < 8; j++)\n\n                s->codebook[codebook_index++] = i;\n\n\n    s->next_codebook_buffer_index = 0;\n\n\n\n    /* allocate decode buffer */\n\n    s->decode_buffer_size = (s->width / s->vector_width) *\n\n        (s->height / s->vector_height) * 2;\n\n    s->decode_buffer = av_malloc(s->decode_buffer_size);\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n", "idx": 2358, "substitutes": {"avctx": ["accountcf", "avcu", "AVctx", "abctx", "abcf", "avcmp", " avwcs", "aucb", "ovctx", "ovcf", "afloc", "avcm", "afctx", "AVcontext", "avctl", "avcontext", "avecf", "avecmp", "avectx", " avcontext", "accountcup", " avcf", "accountctx", "avewcs", "auctx", "afcas", "AVctl", " avctl", "avekb", "navctx", "avcf", " avcm", "vercf", "afkb", "avconfig", "ovcas", "AVcp", "ovcontext", "abcmp", "vercontext", "abcontext", " avcu", "verctx", "avcp", "navcontext", "afcmp", "avwcs", "avecontext", "avloc", "aucontext", "avecas", " avloc", "afwcs", "avecb", "navcm", "navloc", "verwcs", "afcup", "afcp", "avcup", "afcf", " avconfig", "afcontext", "afcu", "AVconfig", "avkb", "aveconfig", " avkb", "navconfig", "aucu", "afcm", "avcb", "afcb", "avecu", "avcas", "navctl", "accountcontext", "avecup", "afconfig", "avecp"], "s": ["uns", "conf", "d", "states", "ps", "lines", "sb", "results", "sym", "parts", "f", "os", "js", "params", "comments", "sv", "l", "sites", "si", "is", "qs", "o", "p", "less", "ins", "se", "stats", "ses", "args", "b", "sg", "ops", "sync", "S", "r", "sc", "settings", "cs", "ctx", "ssl", "m", "sq", "session", "bs", "w", "full", "service", "g", "server", "spec", "ks", "es", "gs", "t", "aws", "ss", "e", "sl", "ls", "http", "ds", "xs", "fs", "ms", "su", "sets", "ts", "ns", "n", "services", "a", "sys", "sf", "c", "rs", "vs", "storage", "its"], "vqa_header": ["vca_buffer", "vqa64main", "vqaOcenter", "vista67center", "vqa2buffer", "vqadhead", "vca_version", "vqa67header", "vqaOrequest", "vqua_token", "vqa64header", "vasa_header", "vista67request", "vasa_metadata", "vga_version", "vqa_comment", "vga_head", "vca_block", "vasa_version", "vqua64header", "vqua64head", "vqa2version", "vasa_buffer", "vqa00header", "vqa64head", "vqaamversion", "vista_part", "vista_center", "vqa67center", "vqa_main", "vqa_border", "vqa_token", "vqa_description", "vqa00part", "vqadheader", "vqa_block", "vqaamheader", "vqa_request", "vqa67part", "vqaOpart", "vista67header", "vqadmain", "vista67part", "vqaammetadata", "vqa67request", "vga_header", "vqa_version", "vqa2header", "vqa_metadata", "vasa_comment", "vqa64token", "vqua64main", "vasa_main", "vqa_center", "vcca_header", "vca_header", "vqa_head", "vqadcomment", "vga_message", "vqua_head", "vqua_main", "vqaamblock", "vqa00center", "vasa_head", "vqaambuffer", "vcca_description", "vqa00request", "vcca_buffer", "vista_request", "vqa_buffer", "vista_header", "vcca_border", "vqaOheader", "vqua64token", "vqua_header", "vqa_message", "vqa_part"], "i": ["ui", "im", "io", "ik", "l", "fi", "si", "is", "n", "uri", "y", "o", "p", "ci", "qi", "ind", "eni", "mi", "id", "api", "z", "ri", "ini", "ii", "v", "bi", "li", "g", "iu", "ie", "ji", "ki", "in", "di", "ix", "ai", "info", "vi", "pi", "gi", "f", "u", "ti", "ip", "ni", "xi", "I", "it", "phi", "yi", "index"], "j": ["fr", "je", "jo", "ui", "jc", "jam", "l", "si", "n", "jl", "o", "y", "dj", "p", "key", "jen", "oj", "qi", "ind", "d", "m", "aj", "job", "obj", "z", "ja", "k", "ij", "ii", "off", "v", "uj", "py", "pos", "th", "jet", "li", "jj", "position", "g", "ie", "ji", "jp", "vi", "em", "b", "q", "f", "jit", "kj", "js", "size", "xi", "x", "it", "J", "h", "index", "br"], "codebook_index": ["codebook_label", "codebook_i", "codebookaccondition", "codesheet_position", "codebookenloop", "codebookPcondition", "codesheet_slice", "codebookPindex", "codebook_min", "codebookPi", "codeBOOK_count", "codebook_loop", "codebookaccount", "codeBOOK_index", "codebook_slice", "codebookaci", "codebox_length", "codeBOOKPi", "codesheet_loop", "codebook___index", "codebook_length", "codebreak_info", "codebookenslice", "codebookenindex", "codebookacindex", "codebookPcount", "codebook_count", "codebook___condition", "codebook_size", "codebook__ind", "codeBOOKPindex", "codesheet_index", "codebook_info", "codebreak_ind", "codebook__info", "codebook_ind", "codebook__point", "codebookensize", "codebox_size", "codesheet_condition", "codebreak_point", "codeBOOKPcondition", "codebreak_index", "codeBOOKPcount", "codebox_index", "codebox_label", "codebook_position", "codebook_condition", "codebook___position", "codesheet_min", "codeBOOK_condition", "codebook_point", "codebook__index", "codesheet_size", "codeBOOK_i", "codebook___min"]}}
{"project": "FFmpeg", "commit_id": "25bcf24d4d0faf0191923be8afac8f67ca98b500", "target": 0, "func": "static int open_output_file(OptionsContext *o, const char *filename)\n\n{\n\n    AVFormatContext *oc;\n\n    int i, j, err;\n\n    AVOutputFormat *file_oformat;\n\n    OutputFile *of;\n\n    OutputStream *ost;\n\n    InputStream  *ist;\n\n    AVDictionary *unused_opts = NULL;\n\n    AVDictionaryEntry *e = NULL;\n\n\n\n    if (configure_complex_filters() < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Error configuring filters.\\n\");\n\n        exit_program(1);\n\n    }\n\n\n\n    if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) {\n\n        o->stop_time = INT64_MAX;\n\n        av_log(NULL, AV_LOG_WARNING, \"-t and -to cannot be used together; using -t.\\n\");\n\n    }\n\n\n\n    if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) {\n\n        int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time;\n\n        if (o->stop_time <= start_time) {\n\n            av_log(NULL, AV_LOG_WARNING, \"-to value smaller than -ss; ignoring -to.\\n\");\n\n            o->stop_time = INT64_MAX;\n\n        } else {\n\n            o->recording_time = o->stop_time - start_time;\n\n        }\n\n    }\n\n\n\n    GROW_ARRAY(output_files, nb_output_files);\n\n    of = av_mallocz(sizeof(*of));\n\n    if (!of)\n\n        exit_program(1);\n\n    output_files[nb_output_files - 1] = of;\n\n\n\n    of->ost_index      = nb_output_streams;\n\n    of->recording_time = o->recording_time;\n\n    of->start_time     = o->start_time;\n\n    of->limit_filesize = o->limit_filesize;\n\n    of->shortest       = o->shortest;\n\n    av_dict_copy(&of->opts, o->g->format_opts, 0);\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);\n\n    if (!oc) {\n\n        print_error(filename, err);\n\n        exit_program(1);\n\n    }\n\n\n\n    of->ctx = oc;\n\n    if (o->recording_time != INT64_MAX)\n\n        oc->duration = o->recording_time;\n\n\n\n    file_oformat= oc->oformat;\n\n    oc->interrupt_callback = int_cb;\n\n\n\n    /* create streams for all unlabeled output pads */\n\n    for (i = 0; i < nb_filtergraphs; i++) {\n\n        FilterGraph *fg = filtergraphs[i];\n\n        for (j = 0; j < fg->nb_outputs; j++) {\n\n            OutputFilter *ofilter = fg->outputs[j];\n\n\n\n            if (!ofilter->out_tmp || ofilter->out_tmp->name)\n\n                continue;\n\n\n\n            switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads,\n\n                                          ofilter->out_tmp->pad_idx)) {\n\n            case AVMEDIA_TYPE_VIDEO:    o->video_disable    = 1; break;\n\n            case AVMEDIA_TYPE_AUDIO:    o->audio_disable    = 1; break;\n\n            case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break;\n\n            }\n\n            init_output_filter(ofilter, o, oc);\n\n        }\n\n    }\n\n\n\n    /* ffserver seeking with date=... needs a date reference */\n\n    if (!strcmp(file_oformat->name, \"ffm\") &&\n\n        av_strstart(filename, \"http:\", NULL)) {\n\n        int err = parse_option(o, \"metadata\", \"creation_time=now\", options);\n\n        if (err < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!strcmp(file_oformat->name, \"ffm\") && !override_ffserver &&\n\n        av_strstart(filename, \"http:\", NULL)) {\n\n        int j;\n\n        /* special case for files sent to ffserver: we get the stream\n\n           parameters from ffserver */\n\n        int err = read_ffserver_streams(o, oc, filename);\n\n        if (err < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n        for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {\n\n            ost = output_streams[j];\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = input_streams[i];\n\n                if(ist->st->codec->codec_type == ost->st->codec->codec_type){\n\n                    ost->sync_ist= ist;\n\n                    ost->source_index= i;\n\n                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup(\"anull\");\n\n                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup(\"null\");\n\n                    ist->discard = 0;\n\n                    ist->st->discard = AVDISCARD_NONE;\n\n                    break;\n\n                }\n\n            }\n\n            if(!ost->sync_ist){\n\n                av_log(NULL, AV_LOG_FATAL, \"Missing %s stream which is required by this ffm\\n\", av_get_media_type_string(ost->st->codec->codec_type));\n\n                exit_program(1);\n\n            }\n\n        }\n\n    } else if (!o->nb_stream_maps) {\n\n        char *subtitle_codec_name = NULL;\n\n        /* pick the \"best\" stream of each type */\n\n\n\n        /* video: highest resolution */\n\n        if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) {\n\n            int area = 0, idx = -1;\n\n            int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0);\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                int new_area;\n\n                ist = input_streams[i];\n\n                new_area = ist->st->codec->width * ist->st->codec->height;\n\n                if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))\n\n                    new_area = 1;\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n                    new_area > area) {\n\n                    if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))\n\n                        continue;\n\n                    area = new_area;\n\n                    idx = i;\n\n                }\n\n            }\n\n            if (idx >= 0)\n\n                new_video_stream(o, oc, idx);\n\n        }\n\n\n\n        /* audio: most channels */\n\n        if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) {\n\n            int channels = 0, idx = -1;\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = input_streams[i];\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&\n\n                    ist->st->codec->channels > channels) {\n\n                    channels = ist->st->codec->channels;\n\n                    idx = i;\n\n                }\n\n            }\n\n            if (idx >= 0)\n\n                new_audio_stream(o, oc, idx);\n\n        }\n\n\n\n        /* subtitles: pick first */\n\n        MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, \"s\");\n\n        if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) {\n\n            for (i = 0; i < nb_input_streams; i++)\n\n                if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n                    new_subtitle_stream(o, oc, i);\n\n                    break;\n\n                }\n\n        }\n\n        /* do something with data? */\n\n    } else {\n\n        for (i = 0; i < o->nb_stream_maps; i++) {\n\n            StreamMap *map = &o->stream_maps[i];\n\n\n\n            if (map->disabled)\n\n                continue;\n\n\n\n            if (map->linklabel) {\n\n                FilterGraph *fg;\n\n                OutputFilter *ofilter = NULL;\n\n                int j, k;\n\n\n\n                for (j = 0; j < nb_filtergraphs; j++) {\n\n                    fg = filtergraphs[j];\n\n                    for (k = 0; k < fg->nb_outputs; k++) {\n\n                        AVFilterInOut *out = fg->outputs[k]->out_tmp;\n\n                        if (out && !strcmp(out->name, map->linklabel)) {\n\n                            ofilter = fg->outputs[k];\n\n                            goto loop_end;\n\n                        }\n\n                    }\n\n                }\n\nloop_end:\n\n                if (!ofilter) {\n\n                    av_log(NULL, AV_LOG_FATAL, \"Output with label '%s' does not exist \"\n\n                           \"in any defined filter graph, or was already used elsewhere.\\n\", map->linklabel);\n\n                    exit_program(1);\n\n                }\n\n                init_output_filter(ofilter, o, oc);\n\n            } else {\n\n                int src_idx = input_files[map->file_index]->ist_index + map->stream_index;\n\n\n\n                ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index];\n\n                if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)\n\n                    continue;\n\n                if(o->   audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n\n                    continue;\n\n                if(o->   video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n                    continue;\n\n                if(o->    data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA)\n\n                    continue;\n\n\n\n                switch (ist->st->codec->codec_type) {\n\n                case AVMEDIA_TYPE_VIDEO:      ost = new_video_stream     (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_AUDIO:      ost = new_audio_stream     (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_SUBTITLE:   ost = new_subtitle_stream  (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_DATA:       ost = new_data_stream      (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break;\n\n                default:\n\n                    av_log(NULL, AV_LOG_FATAL, \"Cannot map stream #%d:%d - unsupported type.\\n\",\n\n                           map->file_index, map->stream_index);\n\n                    exit_program(1);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /* handle attached files */\n\n    for (i = 0; i < o->nb_attachments; i++) {\n\n        AVIOContext *pb;\n\n        uint8_t *attachment;\n\n        const char *p;\n\n        int64_t len;\n\n\n\n        if ((err = avio_open2(&pb, o->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Could not open attachment file %s.\\n\",\n\n                   o->attachments[i]);\n\n            exit_program(1);\n\n        }\n\n        if ((len = avio_size(pb)) <= 0) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Could not get size of the attachment %s.\\n\",\n\n                   o->attachments[i]);\n\n            exit_program(1);\n\n        }\n\n        if (!(attachment = av_malloc(len))) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Attachment %s too large to fit into memory.\\n\",\n\n                   o->attachments[i]);\n\n            exit_program(1);\n\n        }\n\n        avio_read(pb, attachment, len);\n\n\n\n        ost = new_attachment_stream(o, oc, -1);\n\n        ost->stream_copy               = 0;\n\n        ost->attachment_filename       = o->attachments[i];\n\n        ost->finished                  = 1;\n\n        ost->st->codec->extradata      = attachment;\n\n        ost->st->codec->extradata_size = len;\n\n\n\n        p = strrchr(o->attachments[i], '/');\n\n        av_dict_set(&ost->st->metadata, \"filename\", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE);\n\n        avio_close(pb);\n\n    }\n\n\n\n    for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) { //for all streams of this output file\n\n        AVDictionaryEntry *e;\n\n        ost = output_streams[i];\n\n\n\n        if ((ost->stream_copy || ost->attachment_filename)\n\n            && (e = av_dict_get(o->g->codec_opts, \"flags\", NULL, AV_DICT_IGNORE_SUFFIX))\n\n            && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6)))\n\n            if (av_opt_set(ost->st->codec, \"flags\", e->value, 0) < 0)\n\n                exit_program(1);\n\n    }\n\n\n\n    /* check if all codec options have been used */\n\n    unused_opts = strip_specifiers(o->g->codec_opts);\n\n    for (i = of->ost_index; i < nb_output_streams; i++) {\n\n        e = NULL;\n\n        while ((e = av_dict_get(output_streams[i]->opts, \"\", e,\n\n                                AV_DICT_IGNORE_SUFFIX)))\n\n            av_dict_set(&unused_opts, e->key, NULL, 0);\n\n    }\n\n\n\n    e = NULL;\n\n    while ((e = av_dict_get(unused_opts, \"\", e, AV_DICT_IGNORE_SUFFIX))) {\n\n        const AVClass *class = avcodec_get_class();\n\n        const AVOption *option = av_opt_find(&class, e->key, NULL, 0,\n\n                                             AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);\n\n        if (!option)\n\n            continue;\n\n        if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Codec AVOption %s (%s) specified for \"\n\n                   \"output file #%d (%s) is not an encoding option.\\n\", e->key,\n\n                   option->help ? option->help : \"\", nb_output_files - 1,\n\n                   filename);\n\n            exit_program(1);\n\n        }\n\n\n\n        // gop_timecode is injected by generic code but not always used\n\n        if (!strcmp(e->key, \"gop_timecode\"))\n\n            continue;\n\n\n\n        av_log(NULL, AV_LOG_WARNING, \"Codec AVOption %s (%s) specified for \"\n\n               \"output file #%d (%s) has not been used for any stream. The most \"\n\n               \"likely reason is either wrong type (e.g. a video option with \"\n\n               \"no video streams) or that it is a private option of some encoder \"\n\n               \"which was not actually used for any stream.\\n\", e->key,\n\n               option->help ? option->help : \"\", nb_output_files - 1, filename);\n\n    }\n\n    av_dict_free(&unused_opts);\n\n\n\n    /* check filename in case of an image number is expected */\n\n    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {\n\n        if (!av_filename_number_test(oc->filename)) {\n\n            print_error(oc->filename, AVERROR(EINVAL));\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!(oc->oformat->flags & AVFMT_NOFILE)) {\n\n        /* test if it already exists to avoid losing precious files */\n\n        assert_file_overwrite(filename);\n\n\n\n        /* open the file */\n\n        if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE,\n\n                              &oc->interrupt_callback,\n\n                              &of->opts)) < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    } else if (strcmp(oc->oformat->name, \"image2\")==0 && !av_filename_number_test(filename))\n\n        assert_file_overwrite(filename);\n\n\n\n    if (o->mux_preload) {\n\n        uint8_t buf[64];\n\n        snprintf(buf, sizeof(buf), \"%d\", (int)(o->mux_preload*AV_TIME_BASE));\n\n        av_dict_set(&of->opts, \"preload\", buf, 0);\n\n    }\n\n    oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE);\n\n\n\n    /* copy metadata */\n\n    for (i = 0; i < o->nb_metadata_map; i++) {\n\n        char *p;\n\n        int in_file_index = strtol(o->metadata_map[i].u.str, &p, 0);\n\n\n\n        if (in_file_index >= nb_input_files) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Invalid input file index %d while processing metadata maps\\n\", in_file_index);\n\n            exit_program(1);\n\n        }\n\n        copy_metadata(o->metadata_map[i].specifier, *p ? p + 1 : p, oc,\n\n                      in_file_index >= 0 ?\n\n                      input_files[in_file_index]->ctx : NULL, o);\n\n    }\n\n\n\n    /* copy chapters */\n\n    if (o->chapters_input_file >= nb_input_files) {\n\n        if (o->chapters_input_file == INT_MAX) {\n\n            /* copy chapters from the first input file that has them*/\n\n            o->chapters_input_file = -1;\n\n            for (i = 0; i < nb_input_files; i++)\n\n                if (input_files[i]->ctx->nb_chapters) {\n\n                    o->chapters_input_file = i;\n\n                    break;\n\n                }\n\n        } else {\n\n            av_log(NULL, AV_LOG_FATAL, \"Invalid input file index %d in chapter mapping.\\n\",\n\n                   o->chapters_input_file);\n\n            exit_program(1);\n\n        }\n\n    }\n\n    if (o->chapters_input_file >= 0)\n\n        copy_chapters(input_files[o->chapters_input_file], of,\n\n                      !o->metadata_chapters_manual);\n\n\n\n    /* copy global metadata by default */\n\n    if (!o->metadata_global_manual && nb_input_files){\n\n        av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata,\n\n                     AV_DICT_DONT_OVERWRITE);\n\n        if(o->recording_time != INT64_MAX)\n\n            av_dict_set(&oc->metadata, \"duration\", NULL, 0);\n\n        av_dict_set(&oc->metadata, \"creation_time\", NULL, 0);\n\n    }\n\n    if (!o->metadata_streams_manual)\n\n        for (i = of->ost_index; i < nb_output_streams; i++) {\n\n            InputStream *ist;\n\n            if (output_streams[i]->source_index < 0)         /* this is true e.g. for attached files */\n\n                continue;\n\n            ist = input_streams[output_streams[i]->source_index];\n\n            av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);\n\n        }\n\n\n\n    /* process manually set metadata */\n\n    for (i = 0; i < o->nb_metadata; i++) {\n\n        AVDictionary **m;\n\n        char type, *val;\n\n        const char *stream_spec;\n\n        int index = 0, j, ret = 0;\n\n\n\n        val = strchr(o->metadata[i].u.str, '=');\n\n        if (!val) {\n\n            av_log(NULL, AV_LOG_FATAL, \"No '=' character in metadata string %s.\\n\",\n\n                   o->metadata[i].u.str);\n\n            exit_program(1);\n\n        }\n\n        *val++ = 0;\n\n\n\n        parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec);\n\n        if (type == 's') {\n\n            for (j = 0; j < oc->nb_streams; j++) {\n\n                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {\n\n                    av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);\n\n                } else if (ret < 0)\n\n                    exit_program(1);\n\n            }\n\n        }\n\n        else {\n\n            switch (type) {\n\n            case 'g':\n\n                m = &oc->metadata;\n\n                break;\n\n            case 'c':\n\n                if (index < 0 || index >= oc->nb_chapters) {\n\n                    av_log(NULL, AV_LOG_FATAL, \"Invalid chapter index %d in metadata specifier.\\n\", index);\n\n                    exit_program(1);\n\n                }\n\n                m = &oc->chapters[index]->metadata;\n\n                break;\n\n            default:\n\n                av_log(NULL, AV_LOG_FATAL, \"Invalid metadata specifier %s.\\n\", o->metadata[i].specifier);\n\n                exit_program(1);\n\n            }\n\n            av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2365, "substitutes": {"o": ["ko", "vo", "io", "od", "l", "po", "oo", "object", "iso", "from", "n", "y", "bo", "or", "fo", "other", "mo", "oi", "obj", "ov", "wo", "no", "off", "oco", "ant", "ou", "oe", "co", "to", "c", "ot", "b", "oid", "ob", "original", "t", "oa", "os", "O", "op", "f", "u", "OC", "ow", "online", "ilo", "none", "one", "go", "http", "so"], "filename": ["fn", "xxx", "ename", "nuclear", "nm", "lua", "binary", "println", "utf", "phrase", "fp", "location", "document", "title", "which", "maximum", "abl", "acl", "name", "word", "buffer", "Filename", "figure", "fil", "sequence", "method", "download", "named", "format", "prefix", "missing", "file", "fd", "tif", "feat", "txt", "message", "length", "il", "sf", "output", "initial", "url", "dll", "files", "nil", "kl", "subject", "nl", "f", "journal", "wb", "directory", "username", "final", "actual", "msg", "path"], "oc": ["ocon", "ocol", "soc", "oca", "dc", "cc", "cu", "ocation", "loc", "cf", "ac", "ok", "rc", "fc", "oo", "ctx", "alloc", "ci", "opt", "ic", "ec", "oci", "config", "acl", "voc", "org", "unc", "ogg", "oco", "ocl", "rec", "off", "oe", "pc", "roc", "og", "ocr", "co", "ou", "c", "ot", "oid", "ob", "mc", "toc", "om", "osc", "OC", "os", "op", "doc", "oper", "http", "uc", "anc"], "i": ["ui", "io", "si", "n", "y", "ci", "d", "ini", "ii", "x", "li", "c", "in", "start", "ai", "info", "pi", "b", "f", "ti", "ip", "I", "index"], "j": ["je", "jc", "r", "bj", "ok", "l", "n", "jl", "key", "job", "obj", "ja", "ij", "pos", "str", "ie", "ji", "c", "jp", "b", "f", "json", "js", "J"], "err": ["fr", "cr", "rr", "gr", "ir", "req", "r", "attr", "loc", "error", "rh", "bug", "rc", "fi", "er", "resp", "arr", "ec", "ind", "dr", "var", "iter", "mr", "ln", "rar", "orig", "ini", "oe", "ah", "Error", "str", "co", "ler", "rs", "ee", "rn", "exc", "ch", "cb", "ace", "ner", "result", "nil", "aaa", "inc", "der", "br", "doc", "lr", "ev", "msg", "fe", "h"], "file_oformat": ["file_autoformat", "file_autostatic", "file_ioversion", "file_autoversion", "file_ttype", "file_ostatic", "file_iotype", "file_ioformat", "file_oversion", "file_iostatic", "file_otype", "file_tstatic", "file_autotype", "file_tformat", "file_tversion"], "of": ["ocation", "part", "ok", "orf", "og", "ef", "ob", "boot", "os", "f", "set", "with", "so", "de", "object", "from", "oln", "exec", "less", "fee", "et", "org", "on", "ou", "data", "comp", "current", "now", "style", "response", "op", "ow", "open", "it", "not", "found", "fi", "at", "new", "obj", "ov", "ol", "Of", "df", "full", "length", "oid", "om", "last", "request", "OF", "orb", "or", "root", "other", "af", "oft", "vol", "off", "a", "ea", "sf", "to", "alf", "after", "ot", "like", "eff", "oa", "one", "en"], "ost": ["ocol", "oss", "art", "sth", "od", "tt", "st", "oci", "ont", "ott", "org", "ogg", "oy", "og", "ocr", "oper", "ast", "nt", "ot", "oid", "ob", "omp", "ood", "om", "OST", "iol", "osi"], "ist": ["oss", "sth", "inst", "ia", "ess", "ists", "isc", "ism", "dr", "oci", "ont", "ict", "wp", "et", "ista", "est", "irc", "osi", "ati", "ast", "IST", "isu", "asi", "asp", "ais", "OST", "alist", "art"], "unused_opts": ["unused_operts", "unused_copters", "unused_OPts", "unused_copcs", "unused_copt", "unused_opters", "unused_copts", "unused_opert", "unused_opcs", "unused_OPcs", "unused_opercs", "unused_opt", "unused_operters", "unused_OPters", "unused_OPt"], "e": ["r", "n", "er", "eu", "ec", "d", "ae", "element", "ed", "entity", "E", "el", "oe", "ele", "ie", "ea", "eg", "c", "es", "ef", "ee", "ace", "ei", "entry", "ev", "en"]}}
{"project": "qemu", "commit_id": "e167adc9d9f5df4f8109aecd4552c407fdce094a", "target": 1, "func": "static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,\n\n                                   unsigned int imms, unsigned int immr)\n\n{\n\n    uint64_t mask;\n\n    unsigned e, levels, s, r;\n\n    int len;\n\n\n\n    assert(immn < 2 && imms < 64 && immr < 64);\n\n\n\n    /* The bit patterns we create here are 64 bit patterns which\n\n     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or\n\n     * 64 bits each. Each element contains the same value: a run\n\n     * of between 1 and e-1 non-zero bits, rotated within the\n\n     * element by between 0 and e-1 bits.\n\n     *\n\n     * The element size and run length are encoded into immn (1 bit)\n\n     * and imms (6 bits) as follows:\n\n     * 64 bit elements: immn = 1, imms = <length of run - 1>\n\n     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>\n\n     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>\n\n     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>\n\n     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>\n\n     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>\n\n     * Notice that immn = 0, imms = 11111x is the only combination\n\n     * not covered by one of the above options; this is reserved.\n\n     * Further, <length of run - 1> all-ones is a reserved pattern.\n\n     *\n\n     * In all cases the rotation is by immr % e (and immr is 6 bits).\n\n     */\n\n\n\n    /* First determine the element size */\n\n    len = 31 - clz32((immn << 6) | (~imms & 0x3f));\n\n    if (len < 1) {\n\n        /* This is the immn == 0, imms == 0x11111x case */\n\n        return false;\n\n    }\n\n    e = 1 << len;\n\n\n\n    levels = e - 1;\n\n    s = imms & levels;\n\n    r = immr & levels;\n\n\n\n    if (s == levels) {\n\n        /* <length of run - 1> mustn't be all-ones. */\n\n        return false;\n\n    }\n\n\n\n    /* Create the value of one element: s+1 set bits rotated\n\n     * by r within the element (which is e bits wide)...\n\n     */\n\n    mask = bitmask64(s + 1);\n\n    mask = (mask >> r) | (mask << (e - r));\n\n    /* ...then replicate the element over the whole 64 bit value */\n\n    mask = bitfield_replicate(mask, e);\n\n    *result = mask;\n\n    return true;\n\n}\n", "idx": 2395, "substitutes": {"result": ["comment", "cup", "lock", "cache", "res", "manager", "attr", "match", "replace", "changes", "valid", "tmp", "arr", "filter", "root", "session", "ret", "buffer", "status", "memory", "table", "slice", "master", "allow", "parent", "work", "shape", "complete", "params", "current", "counter", "results", "info", "global", "pack", "response", "err", "Result", "extra", "instance", "final", "message", "record", "order"], "immn": ["Immn", "Immc", "umns", "ymm", " immc", " immmn", " immm", "umn", "umm", "immm", "imm", "mmn", "immN", "irmN", "immnn", "imns", "mmnn", "imN", "ymn", "umN", "mmN", "irmn", "imnn", "imr", "ymN", "irmr", "imc", "immmn", "Immmn", "ymns", "mmr", "Immm", "immns", "immc", "irmnn", "imn"], "imms": ["emps", "imsm", " immm", "limmm", " imn", "emm", "immm", "immed", "immmed", "immps", "limmn", "iemmed", "imm", " imm", " imns", "immms", "emn", "imns", "iemms", "imsmn", "imsps", "emns", "limms", "emms", "iemns", "imsmm", "imsms", "imsns", "limns", "imps", "immns", "imsmed", "iemm", "imn"], "immr": ["imsr", "Immrr", "immrs", "irmrc", "irmp", " immrn", "irmrt", "imp", "imrt", "iemrn", "iemrr", " imm1", "imp1", "imsrs", " immrt", "immrn", "imrs", " immrc", "imprn", " immrr", "Immr", " immp", "immrc", "imprr", "imrc", "iemr", "imr", "impr", "immrr", "irmr", "immb", "immp", "immrt", "imm1", "imrr", "iem1", "Immrs", "imb", "imsrr", "Immb", "imsb"], "mask": ["mark", "match", "sub", "array", "conf", "pixel", "key", "alias", "group", "z", "sum", "qa", "count", "parent", "weight", "layer", "info", "ch", "Mask", "image", "f", "magic", "bit", "hash", "p", "seq", "ask", "hide", "cover", " masks", "data", "ban", "secret", "map", "seed", "pack", "q", "sk", "h", "comment", "lock", "offset", "shift", "patch", "code", "sh", "bits", "m", "allow", "g", "spec", "shape", "shadow", " Mask", "fix", "user", "cache", "flags", "scan", "value", "bug", "scale", "filter", "delay", "id", "skip", "a", "sign", "c", "asm", "depth", "x", "order", "escape"], "e": [" E", "i", " elements", "scale", "en", "l", "n", "er", "o", "y", "eu", "p", "ec", "d", "m", "se", "z", "w", "ae", "element", "pe", "E", "ed", "v", "el", "oe", "ele", "g", "ie", "ea", "length", "ize", "ze", "ev", "c", "es", "ee", "eps", "level", "b", "f", "u", "ss", "size", "x", "h", "fe"], "levels": ["flows", "cards", "sections", "i", "flags", "l", "lins", "sites", "xs", "xes", "breaks", "values", "children", "ones", "index", "fl", "fields", "groups", "ins", "rows", "ids", "z", "errors", "ries", "blocks", "members", "alls", "codes", "users", "ps", "lines", "length", "steps", "pins", "rs", "vals", "es", "roots", "drivers", "depth", "eps", "files", "locks", "level", "limits", "inc", "rules", "vel", "ss", "planes", "ls", "sl", "runs", "tests", "wl", "lvl", "lc", "seq", "checks"], "s": ["S", "i", "sc", "en", "l", "ns", "cs", "si", "sites", "n", "o", "y", "p", "d", "m", "se", "z", "w", "a", "x", "g", "ps", "lines", "ses", "spec", "c", "rs", "sb", "es", "b", "f", "u", "os", "ss", "ls", "sl", "size", "sk", "ds"], "r": ["rb", "i", "cr", "res", "rr", "ir", "sr", "rh", "l", "rc", "j", "n", "er", "o", "rx", "p", "R", "d", "m", "rev", "z", "rf", "w", "rw", "k", "v", "rd", "g", "c", "rs", "ar", "rg", "b", "f", "err", "q", "u", "ra", "range", "re", "x", "h"], "len": ["val", "i", "lp", "part", "loc", "l", "j", "n", "lon", "dl", "elt", "L", "lin", "le", "fl", "d", "m", "min", "z", "ln", "limit", "dy", "ld", "count", "Len", "v", "pos", "el", "li", "ell", "den", "lan", "ler", "length", "ll", "layer", "depth", "la", "f", "ls", "sl", "lf", "lc", "en"]}}
{"project": "FFmpeg", "commit_id": "1cb4ef526dd1e5f547d0354efb0831d07e967919", "target": 1, "func": "static int add_candidate_ref(HEVCContext *s, RefPicList *list,\n\n                             int poc, int ref_flag)\n\n{\n\n    HEVCFrame *ref = find_ref_idx(s, poc);\n\n\n\n    if (ref == s->ref)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!ref) {\n\n        ref = generate_missing_ref(s, poc);\n\n        if (!ref)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    list->list[list->nb_refs] = ref->poc;\n\n    list->ref[list->nb_refs]  = ref;\n\n    list->nb_refs++;\n\n\n\n    mark_ref(ref, ref_flag);\n\n    return 0;\n\n}\n", "idx": 2400, "substitutes": {"s": ["support", "S", "i", "com", "r", "ns", "cmp", "cs", "si", "context", "sup", "n", "is", "ssl", "o", "south", "p", "new", "src", "cli", "m", "sq", "d", "w", "v", "services", "a", "sys", "service", "g", "ses", "sf", "c", "sb", "site", "self", "gs", "t", "b", "sg", "f", "os", "u", "ss", "js", "e", "ops", "ds", "sync", "source"], "list": ["loop", "view", "cache", "all", "List", "lp", "diff", "i", "base", "com", "back", "l", "def", "object", "array", "code", "nav", "conf", "n", "dl", "null", "p", "index", "group", "act", "config", "call", "queue", "name", "lex", "load", "id", "w", "wp", "table", "full", "v", "frame", "li", "g", "data", "coll", "batch", "parent", "old", "c", "pool", "pre", "self", "test", "comp", "current", "ll", "info", "result", "local", "block", "get", "la", "cl", "LIST", "set", "lists", "bl", "ls", "out", "lc", "source"], "poc": ["spoca", "foca", "tproc", "foc", "jpocol", "tpc", "toca", "Puc", "Poca", "poca", "froc", " poca", "ipoca", "puc", "tpuc", "ipoc", "jpuc", "jpoca", "tocol", " puc", "ipocol", "pocol", "jpc", "pc", "spuc", "Poc", "jpoc", "spoc", "tuc", " pocol", "toc", " pc", "sproc", "troc", "proc", "tpoc", "tpoca", "iproc", "focol", "Pc", "tpocol"], "ref_flag": ["ref2flags", "ref2bit", "ref_kind", "ref_flags", "reference_bit", "reference_flags", "refackind", "reference_kind", "reference_flag", "ref2flag", "refacflags", "ref_bit", "refsflag", "refsbit", "refacflag", "refsflags"], "ref": ["field", "diff", "part", "req", "cmp", "conf", "aff", "alt", "lib", "ff", "parent", "ef", "ob", "info", "block", "cb", "col", "f", "Ref", "inc", "doc", "this", "fe", "br", "inf", "fc", "object", "null", "p", "remote", "call", "name", "el", "url", "comp", " reference", "b", "err", "pointer", "lf", "fr", "next", "fact", "base", "r", "REF", "arc", "new", "ab", "proxy", "obj", "rf", "old", "pre", "rel", "lab", "e", "source", "index", "bf", "val", "cache", "loc", "cf", "def", "bb", "nav", "n", "reference", "af", "id", "fb", "rec", "frame", "ext", "c", "self", "db", "re"], "nb_refs": ["nb_childs", "nb_defd", "nb_relits", "nb_reld", "nb_childblocks", "nb_defls", "nb_clp", "nb_refp", "nb_refd", "nb_REFls", "nb_refls", "nb_rels", "nb_defp", "nb_defs", "nb_REFs", "nb_deferences", "nb_childerences", "nb_relp", "nb_rells", "nb_refblocks", "nb_relblocks", "nb_refits", "nb_cld", "nb_defits", "nb_clits", "nb_relerences", "nb_childd", "nb_references", "nb_REFd", "nb_cls", "nb_REFerences", "nb_defblocks"]}}
{"project": "qemu", "commit_id": "fae38221e78fc9f847965f6d18b359b8044df348", "target": 1, "func": "static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)\n\n{\n\n    if (r < 0 || r > 15) {\n\n        fprintf(stderr, \"wrong register write $p%d\\n\", r);\n\n    }\n\n    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {\n\n        return;\n\n    } else if (r == PR_SRS) {\n\n        tcg_gen_andi_tl(cpu_PR[r], tn, 3);\n\n    } else {\n\n        if (r == PR_PID) {\n\n            gen_helper_tlb_flush_pid(cpu_env, tn);\n\n        }\n\n        if (dc->tb_flags & S_FLAG && r == PR_SPC) {\n\n            gen_helper_spc_write(cpu_env, tn);\n\n        } else if (r == PR_CCS) {\n\n            dc->cpustate_changed = 1;\n\n        }\n\n        tcg_gen_mov_tl(cpu_PR[r], tn);\n\n    }\n\n}\n", "idx": 2415, "substitutes": {"dc": ["draw", "jc", "cit", "cr", "cc", "cf", "rc", "fc", "context", "de", "ctx", "dl", "cca", "vc", "dm", "ec", "gc", "dr", "ct", "d", "dat", "DC", "tk", "ga", "cdn", "tc", "df", "abc", "conn", "roc", "ca", "ea", "dn", "spec", "c", "ctrl", "dt", "nc", "mc", "oc", "db", "dp", "da", "doc", "director", "bc", "cfg", "ds", "design", "anc", "cd", "desc"], "r": [" sr", "fr", "rb", "i", "cr", "rr", "attr", "ir", "pr", "sr", "rh", "error", " pr", "rc", "tr", "l", "rt", "j", "n", "wr", "er", "o", "rx", "p", "R", "or", "nor", "d", "m", "rev", "rf", "mr", "ro", "rss", "rar", "w", " hr", "v", "rd", "ur", "type", "g", "row", "kr", "ry", "c", "rs", "ar", "rg", "nr", "hr", "ru", "rn", "rel", "t", " yr", "b", "err", "u", "rl", "f", "lr", "re", "e", "x", "h", "br"], "tn": ["fn", " sr", "hn", "tm", " td", " tw", "vt", "tp", "tw", "su", "tty", "tl", "rt", "tt", "n", "tun", "fp", "TN", " tid", "nor", "tur", "token", " reply", "tk", "ln", " priv", "sn", "bn", "tc", "tu", "txt", " TN", "cn", "td", "dt", "nr", "kt", "rn", "isu", "pn", "tx", "kn", "t", " ret", " tu", "btn", "ti", " rc", " cit", "nw", "span", " tr", " args", "qt", " fn", "zn"]}}
{"project": "FFmpeg", "commit_id": "b9fa32082c71013e90eab9e9997967d2939cf4a6", "target": 1, "func": "static int vorbis_parse_id_hdr(vorbis_context *vc){\n\n    GetBitContext *gb=&vc->gb;\n\n    uint_fast8_t bl0, bl1;\n\n\n\n    if ((get_bits(gb, 8)!='v') || (get_bits(gb, 8)!='o') ||\n\n    (get_bits(gb, 8)!='r') || (get_bits(gb, 8)!='b') ||\n\n    (get_bits(gb, 8)!='i') || (get_bits(gb, 8)!='s')) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \" Vorbis id header packet corrupt (no vorbis signature). \\n\");\n\n        return 1;\n\n    }\n\n\n\n    vc->version=get_bits_long(gb, 32);    //FIXME check 0\n\n    vc->audio_channels=get_bits(gb, 8);   //FIXME check >0\n\n    vc->audio_samplerate=get_bits_long(gb, 32);   //FIXME check >0\n\n    vc->bitrate_maximum=get_bits_long(gb, 32);\n\n    vc->bitrate_nominal=get_bits_long(gb, 32);\n\n    vc->bitrate_minimum=get_bits_long(gb, 32);\n\n    bl0=get_bits(gb, 4);\n\n    bl1=get_bits(gb, 4);\n\n    vc->blocksize[0]=(1<<bl0);\n\n    vc->blocksize[1]=(1<<bl1);\n\n    if (bl0>13 || bl0<6 || bl1>13 || bl1<6 || bl1<bl0) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \" Vorbis id header packet corrupt (illegal blocksize). \\n\");\n\n        return 3;\n\n    }\n\n    // output format int16\n\n    if (vc->blocksize[1]/2 * vc->audio_channels * 2 >\n\n                                             AVCODEC_MAX_AUDIO_FRAME_SIZE) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \"Vorbis channel count makes \"\n\n               \"output packets too large.\\n\");\n\n        return 4;\n\n    }\n\n    vc->win[0]=ff_vorbis_vwin[bl0-6];\n\n    vc->win[1]=ff_vorbis_vwin[bl1-6];\n\n\n\n    if(vc->exp_bias){\n\n        int i, j;\n\n        for(j=0; j<2; j++){\n\n            float *win = av_malloc(vc->blocksize[j]/2 * sizeof(float));\n\n            for(i=0; i<vc->blocksize[j]/2; i++)\n\n                win[i] = vc->win[j][i] * (1<<15);\n\n            vc->win[j] = win;\n\n        }\n\n    }\n\n\n\n    if ((get_bits1(gb)) == 0) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \" Vorbis id header packet corrupt (framing flag not set). \\n\");\n\n        return 2;\n\n    }\n\n\n\n    vc->channel_residues= av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->channel_floors  = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->saved           = av_mallocz((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->ret             = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->buf             = av_malloc( vc->blocksize[1]                       * sizeof(float));\n\n    vc->buf_tmp         = av_malloc( vc->blocksize[1]                       * sizeof(float));\n\n    vc->previous_window=0;\n\n\n\n    ff_mdct_init(&vc->mdct[0], bl0, 1);\n\n    ff_mdct_init(&vc->mdct[1], bl1, 1);\n\n\n\n    AV_DEBUG(\" vorbis version %d \\n audio_channels %d \\n audio_samplerate %d \\n bitrate_max %d \\n bitrate_nom %d \\n bitrate_min %d \\n blk_0 %d blk_1 %d \\n \",\n\n            vc->version, vc->audio_channels, vc->audio_samplerate, vc->bitrate_maximum, vc->bitrate_nominal, vc->bitrate_minimum, vc->blocksize[0], vc->blocksize[1]);\n\n\n\n/*\n\n    BLK=vc->blocksize[0];\n\n    for(i=0;i<BLK/2;++i) {\n\n        vc->win[0][i]=sin(0.5*3.14159265358*(sin(((float)i+0.5)/(float)BLK*3.14159265358))*(sin(((float)i+0.5)/(float)BLK*3.14159265358)));\n\n    }\n\n*/\n\n\n\n    return 0;\n\n}\n", "idx": 2424, "substitutes": {"vc": ["vd", "uv", "cat", "wx", "cu", "wd", "dc", "cc", "vt", "sv", "cf", "ac", "rc", "fc", "cs", "rt", "ctx", "bb", "ci", "ic", "ce", "xc", "ct", "config", "input", "cli", "gt", "ga", "cci", "voc", "vm", "vg", "cv", "vr", "VC", "dk", "sys", "service", "ant", "dn", "fw", "c", "nt", "ctrl", "lv", "gd", "ll", "nv", "gg", "util", "vp", "plugin", "cb", "ch", "vs", "ku", "db", "cmd", "hw", "serv", "bc", "client", "lc", "vv"], "gb": ["kb", "gl", "ko", "rb", "git", "buff", "gh", "sel", "lib", "cgi", "ld", "sb", "rg", "gy", "boot", "cb", "gap", "wb", "bc", "lb", "cd", "gru", "cc", "ui", "ged", "fc", "ci", "bg", "gae", "gal", "gp", "hl", "mode", "cv", "gpu", "gin", "hub", "url", "gold", "gm", "gd", "gg", "phy", "b", " rc", "jpg", "lc", "google", "ge", "GB", "gow", "vg", "mb", "pc", "gz", "g", "usb", "game", "gs", "sl", "bm", "cm", "bf", "rc", "binary", "bb", "gc", "gt", "ga", "api", "gio", "bn", "px", "ogg", "eb", "xy", "db", "gui", "storage", "gam", "cfg", "hw"], "bl0": ["cl1", "loc5", "loc1", "pl2", "fl1", "bl00", "Bl3", "bl50", "loc2", "bo8", " bl3", "fl0", "l2", "Bl5", " bl8", "fl50", "cl2", "bok", "Bl1", "block2", "BL00", "l00", "pl5", "cl00", "loc0", "col00", "BL8", "col50", "l50", "pl00", "bl3", "bl5", "fl00", "BL50", " blk", "cl50", "blk", " bl2", "bo0", "BL2", "bo1", "bl2", "col0", "Bl00", " bl00", "pl0", "l0", "cl0", "col2", "Bl0", "pl1", "BL0", "pl3", "block00", "BL1", "blockk", "BLk", "Bl2", "pl50", "bl8", "block0"], "bl1": ["wl9", "BlOne", " blOne", "Bl3", "sl2", "label1", " blone", "obl1", "bl9", "bl4", "pl4", " bln", "ml3", "Bl1", "ml1", "plone", "wl0", "lb4", "obln", "sl3", "Bl4", "blOne", "wl1", "bl3", "obl0", "sl0", "lbOne", "ml2", "labelone", "labelOne", "ml4", " bl2", "sl4", "sl1", "lb0", "Bln", "bl2", "label0", "pl0", "plOne", "lb1", "pl9", "oblOne", "pl1", "Bl0", "BL0", "blone", "BLone", "BL9", "wlone", "BL1", "slOne", "Bl2", "bln"], "i": ["io", "l", "n", "o", "p", "ci", "d", "m", "z", "I", "k", "ij", "ii", "v", "bi", "a", "li", "ji", "c", "ai", "vi", "pi", "b", "f", "e", "x"], "j": ["fr", "jo", "jc", "r", "l", "n", "num", "dj", "o", "jl", "p", "key", "fl", "oj", "ind", "d", "m", "aj", "obj", "z", "adj", "ja", "k", "ij", "ii", "v", "uj", "pos", "jet", "li", "g", "jj", "ie", "ji", "jp", "ch", "b", "f", "jit", "kj", "js", "e", "x", "J", "br"], "win": ["mask", "host", "lock", "won", "scan", "ac", "device", "gen", "disk", "play", "enc", "intel", "write", "session", "skin", "w", "pad", "con", "build", "vine", "conn", "wal", "window", "gain", "game", "spec", "inn", "can", "start", "weight", "wan", "get", "bin", "screen", "native", "dev", "client", "gui", "Win", "WIN", "thin", "windows"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,\n\n                                         src - (stride * 2) +\n\n                                         sizeof(uint8_t), stride, dst, stride);\n\n}\n", "idx": 2429, "substitutes": {"dst": ["dedrc", "adst", "datst", " ddest", "drc", "datsts", "pdsts", "dedsts", "dsts", "adsts", "adsrc", " dsrc", "pdrc", "dedst", "datrc", "datdest", " drc", "dsrc", "pdst", "adrc", "ddest", "pddest", "dedsrc", " dsts"], "src": ["gl", "dist", "rb", "usc", "sur", "supp", "sr", "sc", "inst", "secure", "rc", "sub", "cmp", "grad", "img", "sec", "sel", "st", "lib", "bg", "config", "sq", "send", "stat", "rec", "stream", "rd", "dest", "gz", "ie", "sb", "url", "comp", "gb", "cb", "rate", "b", "cur", "sl", "ctr", "sup", "sync", "source", "desc"], "stride": ["pride", "Striding", "crided", "drider", "divider", " strided", "divide", "Strided", " strider", "crIDE", "divise", "prider", "drone", "arrider", " strone", "prIDE", "Stride", " striding", "strid", "strided", "Strid", "drided", "StrIDE", " strid", "strise", "cride", "deriding", "striding", "Strise", "arride", "strone", "dride", "Strider", " strise", "strider", "arrone", "prided", "crider", "arrided", "strIDE", "derided", "derid", "divided", "deride"]}}
{"project": "qemu", "commit_id": "c1bf3531aecf4a0ba25bb150dd5fe21edf406c88", "target": 1, "func": "static int net_vhost_user_init(NetClientState *peer, const char *device,\n\n                               const char *name, CharDriverState *chr,\n\n                               int queues)\n\n{\n\n    NetClientState *nc;\n\n    VhostUserState *s;\n\n    int i;\n\n\n\n    for (i = 0; i < queues; i++) {\n\n        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);\n\n\n\n        snprintf(nc->info_str, sizeof(nc->info_str), \"vhost-user%d to %s\",\n\n                 i, chr->label);\n\n\n\n        nc->queue_index = i;\n\n\n\n        s = DO_UPCAST(VhostUserState, nc, nc);\n\n        s->chr = chr;\n\n    }\n\n\n\n    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);\n\n\n\n    return 0;\n\n}\n", "idx": 2451, "substitutes": {"peer": ["host", "socket", "req", "worker", "ptr", "context", "pb", "er", "ssl", "p", "connection", "node", "remote", "interface", "wrapper", "source", "pe", "pod", "master", "loader", "pc", "type", "owner", "parent", "server", "port", "pp", "self", "scope", "proc", "player", "address", "instance", "http", "reader", "request"], "device": ["user", "host", "driver", "serial", "attribute", "manager", "attr", "project", "connection", "node", "module", "interface", "mode", "prefix", "type", "owner", " dev", "server", "package", "port", "devices", "layer", "plugin", "info", "depth", "Device", "feature", "dev", "dp", "ip", "address", "resource", "addr", "client", "password"], "name": ["user", "comment", "ename", "part", "create", "nm", "ame", "hello", "key", "Name", "alias", "new", "nam", "names", "word", "id", "call", "wrapper", "no", "named", "label", "event", "unknown", "prefix", "func", "type", "str", "data", "description", "path", "parent", "self", "info", "image", "network", "nick", "none", "dev", "na", "address", "NAME", "ni", "size", "e", "username", "password", "filename"], "chr": ["thrs", " chrc", "chrb", "ctrar", "Chdr", "cher", " chrt", " chsr", "thrc", "chrar", "qr", " chdr", " chrar", " chnr", "ochr", "qrc", "CHrt", "ochrb", "qro", "Chr", "Chrs", "thrf", "corlr", "qrar", "qrf", "chedr", "Chsr", "thr", "CHr", "qrs", "chrt", " chrb", "chlr", "chesr", "ctrc", "Chrc", " chrf", "chrs", "Chrb", "chdr", "chers", "chro", "corrs", " chro", "corrb", "chenr", "ochrf", "chrf", "ctro", "chelr", "Chnr", "ochrt", "Chlr", "cherb", "chnr", "chsr", "CHrb", "CHrf", "Chrf", "corr", "ctr", "chrc"], "queues": ["scheients", "Queues", " queures", "queueue", "Queures", "querue", "queueues", "querences", "queients", "queue", "Queences", "queueures", " queences", "scheures", " queients", "querures", "querues", "scheences", "queueences", "queences", "Queue", "queures", "Queients", "scheues"], "nc": ["bc", "dc", "cc", "cr", "nm", "sc", "cf", "ns", "rc", "fc", "cs", "enc", "ctx", "n", "core", "ci", "ec", "nn", "config", "net", "sn", "bn", "cdn", "unc", "aa", "cv", "nb", "conn", "pc", "NC", "ne", "cn", "kr", "dn", "c", "nt", "np", "auc", "rn", "ync", "mc", "nec", "oc", "mn", "nl", "ng", "network", "cb", "inc", "nw", "ni", "ct", "cm", "client", "uc", "lc", "anc", "nv"], "s": ["fs", "socket", "r", "su", "sc", "ns", "l", "cs", "si", "enc", "n", "ssl", "qs", "o", "p", "sq", "session", "sn", "w", "v", "stats", "sys", "conn", "g", "ne", "css", "ps", "server", "ses", "sb", "c", "rs", "es", "gs", "os", "sg", "sts", "b", "u", "f", "ss", "js", "e", "ls", "sl", "ds", "sync"], "i": ["hi", "ui", "io", "r", "l", "si", "j", "n", "uri", "o", "p", "ci", "multi", "uni", "qi", "eni", "d", "m", "cli", "oi", "mi", "id", "z", "ri", "k", "ini", "ii", "v", "bi", "x", "type", "li", "iu", "c", "in", "counter", "di", "ix", "ai", "jp", "start", "info", "pi", "mu", "t", "b", "f", "gi", "u", "ti", "ip", "ni", "e", "xi", "I", "index"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int flv_probe(AVProbeData *p)\n\n{\n\n    const uint8_t *d;\n\n\n\n    if (p->buf_size < 6)\n\n        return 0;\n\n    d = p->buf;\n\n    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {\n\n        return AVPROBE_SCORE_MAX;\n\n    }\n\n    return 0;\n\n}\n", "idx": 2466, "substitutes": {"p": ["i", "lp", "tp", "r", "bp", "l", "pb", "j", "n", "o", "fp", "m", "api", "v", "cp", "a", "pc", "data", "ps", "sp", "ap", "c", "pp", "np", "jp", "vp", "P", "t", "b", "f", "op", "pa", "u", "e", "s"], "d": ["md", "dd", "dad", "i", "dc", "did", "r", "od", "l", "de", "j", "n", "dl", "bd", "o", "pd", "nd", "dr", "ind", "m", "dat", "id", "s", "w", "ad", "dy", "k", "ld", "dim", "rd", "D", "fd", "g", "data", "dn", "c", "dt", "di", "dh", "dict", "t", "db", "b", "f", "u", "cd", "dp", "da", "e", "ds", "dom"]}}
{"project": "qemu", "commit_id": "6fa2c95f279dda62aa7e3292cc424ff3fab6a602", "target": 0, "func": "static void scsi_read_data(SCSIDevice *d, uint32_t tag)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n\n    SCSIDiskReq *r;\n\n\n\n    r = scsi_find_request(s, tag);\n\n    if (!r) {\n\n        BADF(\"Bad read tag 0x%x\\n\", tag);\n\n        /* ??? This is the wrong error.  */\n\n        scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    scsi_read_request(r);\n\n}\n", "idx": 2471, "substitutes": {"d": ["md", "dd", "i", "dc", "ded", "l", "bd", "dl", "o", "p", "pd", "m", "z", "id", "w", "ad", "ld", "fd", "D", "g", "data", "xd", "c", "dt", "gd", "di", "dh", "t", "db", "b", "dev", "f", "u", "dp", "dos", "e", "ds", "cd"], "tag": ["comment", "mod", "cat", "attribute", "rr", "bug", "loc", "attr", "error", "match", "device", "patch", "code", "date", "o", "at", "p", "param", "key", "config", "token", "name", "id", "word", "ad", "class", "Tag", "type", "feat", "str", "ag", "length", "port", "c", "reg", "test", "oid", "start", "tags", "image", "block", "t", "db", "TAG", "f", "tail", "br", "e", "desc"], "s": ["S", "req", "sr", "l", "si", "is", "j", "n", "ssl", "o", "p", "m", "sq", "session", "se", "w", "sa", "v", "a", "sys", "g", "server", "spec", "c", "rs", "ar", "sb", "self", "state", "t", "b", "f", "u", "e", "sl", "ds"], "r": ["fr", "rb", "cr", "rr", "res", "gr", "ir", "req", "sr", "pr", "rh", "rc", "rt", "er", "o", "rx", "p", "R", "arr", "dr", "m", "rf", "mr", "w", "rar", "ri", "k", "rec", "v", "vr", "ur", "rd", "g", "kr", "c", "rs", "ar", "rg", "nr", "hr", "ru", "result", "t", "b", "q", "u", "err", "e", "re", "entry", "h", "request", "br"]}}
{"project": "FFmpeg", "commit_id": "13ccba50d45662a15777b549b2fcd9b4621b0e01", "target": 0, "func": "static void opt_output_file(void *optctx, const char *filename)\n\n{\n\n    OptionsContext *o = optctx;\n\n    AVFormatContext *oc;\n\n    int i, err;\n\n    AVOutputFormat *file_oformat;\n\n    OutputStream *ost;\n\n    InputStream  *ist;\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    oc = avformat_alloc_context();\n\n    if (!oc) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        exit_program(1);\n\n    }\n\n\n\n    if (last_asked_format) {\n\n        file_oformat = av_guess_format(last_asked_format, NULL, NULL);\n\n        if (!file_oformat) {\n\n            fprintf(stderr, \"Requested output format '%s' is not a suitable output format\\n\", last_asked_format);\n\n            exit_program(1);\n\n        }\n\n        last_asked_format = NULL;\n\n    } else {\n\n        file_oformat = av_guess_format(NULL, filename, NULL);\n\n        if (!file_oformat) {\n\n            fprintf(stderr, \"Unable to find a suitable output format for '%s'\\n\",\n\n                    filename);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    oc->oformat = file_oformat;\n\n    av_strlcpy(oc->filename, filename, sizeof(oc->filename));\n\n\n\n    if (!strcmp(file_oformat->name, \"ffm\") &&\n\n        av_strstart(filename, \"http:\", NULL)) {\n\n        /* special case for files sent to avserver: we get the stream\n\n           parameters from avserver */\n\n        int err = read_avserver_streams(oc, filename);\n\n        if (err < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    } else if (!o->nb_stream_maps) {\n\n        /* pick the \"best\" stream of each type */\n\n#define NEW_STREAM(type, index)\\\n\n        if (index >= 0) {\\\n\n            ost = new_ ## type ## _stream(oc);\\\n\n            ost->source_index = index;\\\n\n            ost->sync_ist     = &input_streams[index];\\\n\n            input_streams[index].discard = 0;\\\n\n        }\n\n\n\n        /* video: highest resolution */\n\n        if (!video_disable && oc->oformat->video_codec != CODEC_ID_NONE) {\n\n            int area = 0, idx = -1;\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = &input_streams[i];\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n                    ist->st->codec->width * ist->st->codec->height > area) {\n\n                    area = ist->st->codec->width * ist->st->codec->height;\n\n                    idx = i;\n\n                }\n\n            }\n\n            NEW_STREAM(video, idx);\n\n        }\n\n\n\n        /* audio: most channels */\n\n        if (!audio_disable && oc->oformat->audio_codec != CODEC_ID_NONE) {\n\n            int channels = 0, idx = -1;\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = &input_streams[i];\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&\n\n                    ist->st->codec->channels > channels) {\n\n                    channels = ist->st->codec->channels;\n\n                    idx = i;\n\n                }\n\n            }\n\n            NEW_STREAM(audio, idx);\n\n        }\n\n\n\n        /* subtitles: pick first */\n\n        if (!subtitle_disable && oc->oformat->subtitle_codec != CODEC_ID_NONE) {\n\n            for (i = 0; i < nb_input_streams; i++)\n\n                if (input_streams[i].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n                    NEW_STREAM(subtitle, i);\n\n                    break;\n\n                }\n\n        }\n\n        /* do something with data? */\n\n    } else {\n\n        for (i = 0; i < o->nb_stream_maps; i++) {\n\n            StreamMap *map = &o->stream_maps[i];\n\n\n\n            if (map->disabled)\n\n                continue;\n\n\n\n            ist = &input_streams[input_files[map->file_index].ist_index + map->stream_index];\n\n            switch (ist->st->codec->codec_type) {\n\n            case AVMEDIA_TYPE_VIDEO:    ost = new_video_stream(oc);    break;\n\n            case AVMEDIA_TYPE_AUDIO:    ost = new_audio_stream(oc);    break;\n\n            case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream(oc); break;\n\n            case AVMEDIA_TYPE_DATA:     ost = new_data_stream(oc);     break;\n\n            default:\n\n                av_log(NULL, AV_LOG_ERROR, \"Cannot map stream #%d.%d - unsupported type.\\n\",\n\n                       map->file_index, map->stream_index);\n\n                exit_program(1);\n\n            }\n\n\n\n            ost->source_index = input_files[map->file_index].ist_index + map->stream_index;\n\n            ost->sync_ist = &input_streams[input_files[map->sync_file_index].ist_index +\n\n                                           map->sync_stream_index];\n\n            ist->discard = 0;\n\n        }\n\n    }\n\n\n\n    av_dict_copy(&oc->metadata, metadata, 0);\n\n    av_dict_free(&metadata);\n\n\n\n\n\n    output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1);\n\n    output_files[nb_output_files - 1].ctx       = oc;\n\n    output_files[nb_output_files - 1].ost_index = nb_output_streams - oc->nb_streams;\n\n    output_files[nb_output_files - 1].recording_time = o->recording_time;\n\n    output_files[nb_output_files - 1].start_time     = o->start_time;\n\n    output_files[nb_output_files - 1].limit_filesize = limit_filesize;\n\n    av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0);\n\n\n\n    /* check filename in case of an image number is expected */\n\n    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {\n\n        if (!av_filename_number_test(oc->filename)) {\n\n            print_error(oc->filename, AVERROR(EINVAL));\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!(oc->oformat->flags & AVFMT_NOFILE)) {\n\n        /* test if it already exists to avoid loosing precious files */\n\n        if (!file_overwrite &&\n\n            (strchr(filename, ':') == NULL ||\n\n             filename[1] == ':' ||\n\n             av_strstart(filename, \"file:\", NULL))) {\n\n            if (avio_check(filename, 0) == 0) {\n\n                if (!using_stdin) {\n\n                    fprintf(stderr,\"File '%s' already exists. Overwrite ? [y/N] \", filename);\n\n                    fflush(stderr);\n\n                    if (!read_yesno()) {\n\n                        fprintf(stderr, \"Not overwriting - exiting\\n\");\n\n                        exit_program(1);\n\n                    }\n\n                }\n\n                else {\n\n                    fprintf(stderr,\"File '%s' already exists. Exiting.\\n\", filename);\n\n                    exit_program(1);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* open the file */\n\n        if ((err = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE)) < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    oc->preload= (int)(mux_preload*AV_TIME_BASE);\n\n    oc->max_delay= (int)(mux_max_delay*AV_TIME_BASE);\n\n    oc->flags |= AVFMT_FLAG_NONBLOCK;\n\n\n\n    /* copy chapters */\n\n    if (chapters_input_file >= nb_input_files) {\n\n        if (chapters_input_file == INT_MAX) {\n\n            /* copy chapters from the first input file that has them*/\n\n            chapters_input_file = -1;\n\n            for (i = 0; i < nb_input_files; i++)\n\n                if (input_files[i].ctx->nb_chapters) {\n\n                    chapters_input_file = i;\n\n                    break;\n\n                }\n\n        } else {\n\n            av_log(NULL, AV_LOG_ERROR, \"Invalid input file index %d in chapter mapping.\\n\",\n\n                   chapters_input_file);\n\n            exit_program(1);\n\n        }\n\n    }\n\n    if (chapters_input_file >= 0)\n\n        copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]);\n\n\n\n    /* copy metadata */\n\n    for (i = 0; i < nb_meta_data_maps; i++) {\n\n        AVFormatContext *files[2];\n\n        AVDictionary    **meta[2];\n\n        int j;\n\n\n\n#define METADATA_CHECK_INDEX(index, nb_elems, desc)\\\n\n        if ((index) < 0 || (index) >= (nb_elems)) {\\\n\n            av_log(NULL, AV_LOG_ERROR, \"Invalid %s index %d while processing metadata maps\\n\",\\\n\n                     (desc), (index));\\\n\n            exit_program(1);\\\n\n        }\n\n\n\n        int in_file_index = meta_data_maps[i][1].file;\n\n        if (in_file_index < 0)\n\n            continue;\n\n        METADATA_CHECK_INDEX(in_file_index, nb_input_files, \"input file\")\n\n\n\n        files[0] = oc;\n\n        files[1] = input_files[in_file_index].ctx;\n\n\n\n        for (j = 0; j < 2; j++) {\n\n            MetadataMap *map = &meta_data_maps[i][j];\n\n\n\n            switch (map->type) {\n\n            case 'g':\n\n                meta[j] = &files[j]->metadata;\n\n                break;\n\n            case 's':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, \"stream\")\n\n                meta[j] = &files[j]->streams[map->index]->metadata;\n\n                break;\n\n            case 'c':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, \"chapter\")\n\n                meta[j] = &files[j]->chapters[map->index]->metadata;\n\n                break;\n\n            case 'p':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, \"program\")\n\n                meta[j] = &files[j]->programs[map->index]->metadata;\n\n                break;\n\n            }\n\n        }\n\n\n\n        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    /* copy global metadata by default */\n\n    if (metadata_global_autocopy && nb_input_files)\n\n        av_dict_copy(&oc->metadata, input_files[0].ctx->metadata,\n\n                     AV_DICT_DONT_OVERWRITE);\n\n    if (metadata_streams_autocopy)\n\n        for (i = output_files[nb_output_files - 1].ost_index; i < nb_output_streams; i++) {\n\n            InputStream *ist = &input_streams[output_streams[i].source_index];\n\n            av_dict_copy(&output_streams[i].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);\n\n        }\n\n\n\n    frame_rate    = (AVRational){0, 0};\n\n    frame_width   = 0;\n\n    frame_height  = 0;\n\n    audio_sample_rate = 0;\n\n    audio_channels    = 0;\n\n    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;\n\n    chapters_input_file = INT_MAX;\n\n    limit_filesize = UINT64_MAX;\n\n\n\n    av_freep(&meta_data_maps);\n\n    nb_meta_data_maps = 0;\n\n    metadata_global_autocopy   = 1;\n\n    metadata_streams_autocopy  = 1;\n\n    metadata_chapters_autocopy = 1;\n\n    av_freep(&streamid_map);\n\n    nb_streamid_map = 0;\n\n\n\n    av_dict_free(&codec_names);\n\n\n\n    av_freep(&forced_key_frames);\n\n    reset_options(o);\n\n}\n", "idx": 2502, "substitutes": {"optctx": ["OptContext", "optionContext", "optContext", "optionc", "Optc", "optionsctx", "optcontext", "optioncontext", "optionscontext", "optionctx", "optioncmp", "opcontext", "opContext", "optionsContext", "opc", "Optcontext", "optcmp", "opcmp", "Optctx", "optc", "optionscmp", "opctx"], "filename": ["required", "nature", "text", "setup", "uri", "phrase", "title", "maximum", "download", "fd", "feat", "il", "output", "whatever", "dll", "f", "journal", "json", "FH", "message", "ename", "null", "name", "buffer", "Filename", "fil", "STDOUT", "method", "unknown", "format", "url", "nil", "kl", "kn", "FIL", "directory", "username", "jpg", "fn", "ident", "println", "dyl", "location", "document", "write", "figure", "String", "status", "IL", "named", "stream", "txt", "length", "fax", "subject", "sheet", "size", "provided", "final", "wl", "password", "path", "source", "binary", "header", "utf", "fp", "module", "token", "metadata", "sha", "sequence", "word", "platform", "prefix", "file", "description", "sf", "initial", "WHAT", "original", "csv", "nl", "rl", "NAME", "ako", "that"], "o": ["ko", "io", "r", "od", "ok", "po", "object", "oo", "n", "p", "bo", "fo", "m", "mo", "obj", "ro", "w", "oco", "ant", "co", "roc", "parent", "c", "ot", "oid", "ob", "om", "t", "oa", "os", "O", "op", "ow", "e", "go", "so"], "oc": ["ocol", "soc", "oca", "dc", "cu", "cc", "cache", "loc", "ac", "ok", "rc", "oo", "ack", "ctx", "enc", "bb", "cca", "opt", "exec", "isc", "ic", "ec", "oci", "input", "config", "acl", "aco", "word", "voc", "org", "acs", "abc", "unc", "ogg", "oco", "pc", "roc", "og", "ocr", "AC", "coll", "co", "oper", "irc", "mot", "c", "oid", "ob", "auc", "ace", "mc", "toc", "ucc", "osc", "OC", "os", "op", "doc", "ow", "cur", "bc", "http", "uc", "anc", "pg"], "i": ["hi", "ui", "io", "r", "it", "error", "idi", "l", "ik", "fi", "si", "n", "uri", "p", "ci", "multi", "qi", "eni", "d", "cli", "oi", "name", "mi", "z", "ori", "adi", "ri", "ini", "ii", "slice", "count", "v", "bi", "x", "type", "li", "iu", "ji", "c", "zi", "di", "ix", "ai", "info", "abi", "block", "pi", "mu", "gi", "f", "u", "ti", "b", "ip", "ni", "e", "xi", "I", "inner", "phi", "index"], "err": ["fr", "all", "cr", "rr", "res", "gr", "ir", "req", "r", "pr", "rh", "error", "late", "loc", "sr", "fer", "num", "resp", "er", "Er", "yr", "arr", "runner", "rage", "nor", "dr", "var", "eor", "iter", "mr", "rar", "erer", "raise", "orig", "len", "finder", "count", "end", "Error", "str", "later", " error", "ler", "ise", "arm", "kr", "aster", "ar", "in", "nr", "self", "init", "ner", "nil", "proc", "der", "ver", "lr", "ctr", "msg", "order", "fe", "br"], "file_oformat": ["file_ooform", "file_ofill", "file_odformat", "file_jfill", "file6oformat", "file_nformat", "file_isoformat", "file_oapattern", "file6otype", "file6oversion", "file6odtype", "file_oconfig", "file_isoprintf", "file_opprintf", "file_obformat", "file_optransform", "file_Otransform", "file_nversion", "file6odformat", "file_ntype", "file_oajoin", "file_ooprintf", "file_odstore", "file_obfill", "file_oafill", "file_odconfig", "file_oaformat", "file_jformat", "file_soconfig", "file_isomethod", "file_Ofill", "file_oatransform", "file_Oform", "file_ootype", "file_oat", "file_nat", "file_Omethod", "file_roformat", "file_odtype", "file_obedit", "file_jedit", "file_oversion", "file_oscale", "file_rotype", "file_oaprintf", "file_otype", "file_Ojoin", "file_onlineformat", "file_Opattern", "file_soedit", "file_rotransform", "file6odversion", "file_optype", "file_oascale", "file_oprintf", "file_omethod", "file_roprintf", "file_ooformat", "file_obplot", "file_otransform", "file_opattern", "file_oplot", "file_ostore", "file_onlineform", "file_odat", "file_soformat", "file_ojoin", "file_oform", "file_jplot", "file6oat", "file_oaform", "file_oojoin", "file_Oformat", "file_oastore", "file_sostore", "file_soplot", "file_oaconfig", "file_oedit", "file_sofill", "file6odat", "file_odscale", "file_oamethod", "file_isoform", "file_onlinefill", "file_odversion", "file_onlinepattern", "file_Oprintf", "file_opformat", "file_soscale", "file_ootransform"], "ost": ["ocol", "oss", "\u00f3", "sth", "od", "hop", "tt", "bb", "st", "opt", "tmp", "isc", "iterator", "src", "nn", "dr", "ct", "ont", "ott", "voc", "wp", "org", "ld", "ocr", "ST", "ast", "nt", "oop", "ot", "tto", "oid", "ob", "ood", "boot", "os", "op", "OST", "ft", "rob", "oper", "osi", "ort"], "ist": ["iste", "dist", "wd", "wx", "art", "sth", "inst", "hop", "ess", "st", "pt", "ists", "act", "ism", "dr", "ind", "sta", "ict", "wp", "rest", "rss", "et", "ld", "ista", "adder", "pect", "est", "feat", "mot", "ast", "ilst", "IST", "iss", "tta", "pair", "gd", "lda", "ace", "asi", "dit", "std", "asp", "irst", "ft", "edit", "aci", "alist", "lect", "ds", "aft", "osi", "isi"]}}
{"project": "qemu", "commit_id": "8653c0158c23ec592f0041ab48b83d6cc6d152fe", "target": 0, "func": "static int spawn_thread(void)\n\n{\n\n    pthread_attr_t attr;\n\n    int ret;\n\n\n\n    cur_threads++;\n\n    idle_threads++;\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);\n\n    pthread_attr_destroy(&attr);\n\n\n\n    return ret;\n\n}\n", "idx": 2523, "substitutes": {"attr": ["cache", "rb", "attribute", "rr", "tty", "r", "error", "att", "ac", "ptr", "rt", "tt", "temp", "alt", "opt", "tmp", "arr", "ributes", "ref", "adr", "var", "append", "thread", "acc", "api", "mr", "method", "ad", "property", "attach", "py", "rat", "func", "type", "feat", "ann", "prop", "data", "conn", "parent", "rs", "ctrl", "app", "pair", "style", "args", "arg", "rel", "annot", "err", "rad", "lr", "addr", "atts", "http", "ev", "tag", "params"], "ret": ["cat", "bf", "val", "rb", "res", "base", " RET", "sr", "att", "pet", "rc", "fi", "tr", "rt", "code", " Ret", "flag", "resp", "active", "alt", "fin", "RET", "ref", "mem", "det", "rev", "obj", "et", "len", "py", "ext", "rets", "data", "reply", "mt", "fun", "nt", "reg", "info", "result", "arg", "Ret", "std", "ft", "re"], "cur_threads": ["cur_Threads", "cur_draws", "cur_drawings", "cur_threades", "cur_threadings", "cur_Threades", "cur_threadcount", "cur_poolings", "cur_poolcount", "cur_Threadcount", "cur_pools", "cur_pooles", "cur_Threadings", "cur_drawes", "cur_drawcount"], "idle_threads": ["idle_countories", "idle_processes", "idle_processories", "idle_threades", "idle_threadries", "idle_threadories", "idle_countries", "idle_countes", "idle_Threads", "idle_processries", "idle_Threadries", "idle_Threades", "idle_Threadories", "idle_processs", "idle_counts"]}}
{"project": "FFmpeg", "commit_id": "52a213865670ae69c1852d4d04cf41f8929abbd0", "target": 0, "func": "static int read_gab2_sub(AVStream *st, AVPacket *pkt)\n\n{\n\n    if (pkt->size >= 7 &&\n\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n\n        uint8_t desc[256];\n\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n\n                                             pkt->size - 7,\n\n                                             0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        pd = (AVProbeData) { .buf      = pb->buf_ptr,\n\n                             .buf_size = pb->buf_end - pb->buf_ptr };\n\n        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb = pb;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\n\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 2534, "substitutes": {"st": ["fr", "sam", "ost", "sth", "ste", "inst", "sc", "ts", "tt", "pt", "sed", "nd", "src", "St", "d", "sta", "stage", "rest", "sa", "stat", "fe", "cast", "est", "str", "ST", "sp", "sf", "td", "sb", "nt", "test", "start", "kt", "ist", "state", "std", "t", "sd", "sts", "ft", "this", "ss", "station", "ct", "s", "art"], "pkt": ["bnt", "pq", "pkg", "bft", "Pkg", "Pq", "pet", "pnt", "Pct", "Pkt", "Pnt", " pcht", "Pka", "ipka", "pft", "ckg", "packet", "ipet", "spet", "pcht", "uq", "pka", " pft", "spft", "ipcht", "pct", "Pcht", "Packet", " pka", "bq", "bkt", "ipct", "spacket", "backet", "cacket", " packet", " pct", "Pet", "Pft", "ukt", "ckt", "spkt", "uacket", "bct", " pkg", "cet", " pet", "ipkt", "ipacket", "unt"], "desc": ["dep", "dist", "cod", "dc", "text", "diff", "loc", "sc", "des", "en", "def", "sub", "cmp", "rc", "code", "dir", "src", "Desc", "config", "id", "buf", "rec", "asc", "cv", "esc", "ext", "dest", "data", "txt", "description", "pro", "info", "result", "cb", "meta", "doc", "extra", "cont", "bc", "uc", "lc", "seq"], "ret": ["val", "res", "back", "en", "match", "def", "rc", "att", "code", "num", "sec", "resp", "alt", "opt", "RET", "ref", "mem", "arr", "best", "det", "rev", "id", "status", "nz", "len", "no", "lit", "rec", "success", "ext", "rets", "feat", "data", "reply", "fun", "nt", "reg", "xt", "test", "result", "std", "Ret", "cur", "score", "re", "bit", "seq"], "ast": ["md", "asting", "host", "sam", "ost", "sth", "part", "od", "inst", "ac", "att", "ess", "ta", "ctx", "alt", "p", "Ast", "at", "nd", "ab", "act", "node", "sta", "ard", "api", "ma", "rest", "amd", "sa", "ad", "rss", "aw", "an", "cast", "mast", "am", "a", "end", "pc", "est", "add", "asts", "aster", "ap", "nt", "aid", "old", "test", "asm", "AST", "ist", "ace", "std", "sd", "asted", "op", "amp", "ft", "post", "esp", "anc", "art"], "sub_demuxer": ["sub_demployeri", "sub_demousera", "sub_demomacherer", "sub_promuxera", "sub_demuxerer", "sub_demuxers", "sub_promuxeri", "sub_demexeri", "sub_promuxed", "sub_demployers", "sub_promuxerer", "sub_democer", "sub_demexer", "sub_demomacheri", "sub_demxera", "sub_democers", "sub_demomachers", "sub_demuxera", "sub_demxed", "sub_demouseri", "sub_demxeri", "sub_democeri", "sub_promxed", "sub_promxer", "sub_promxers", "sub_demployed", "sub_demxer", "sub_promuxers", "sub_promuxer", "sub_demousers", "sub_promxera", "sub_demployerer", "sub_democed", "sub_demployer", "sub_demouser", "sub_demxerer", "sub_demuxed", "sub_demuxeri", "sub_demexers", "sub_demxers", "sub_promxerer", "sub_demexera", "sub_promxeri", "sub_demomacher"], "time_base": ["time___end", "timeallbase", "timeallextra", "threadallbase", "time2part", "time_format", "time_part", "time___size", "time_extra", "timealbase", "timealsize", "time_size", " time_end", "time_based", "thread_base", "time_end", " time_bas", "threadallformat", "thread_extra", "time_bas", " time_part", "thread_format", "time___base", " time_based", "threadallextra", "time2based", "timeallformat", "time2bas", "time2base", " time_size", "timealend"], "pb": ["bf", "rb", "pit", "lp", "pkg", "bp", "fc", "sub", "xb", "ctx", "pm", "bb", "cpp", "dl", "pl", "fp", "p", "tmp", "bps", "ib", "ab", "phrase", "ub", "primary", "typ", "api", "wp", "buf", "fb", "ba", "bot", "tc", "mb", "platform", "cv", "py", "cp", "python", "prot", "pc", "eb", "txt", "uf", "hub", "sb", "np", "gb", "bh", "plugin", "jp", "vp", "cb", "db", "b", "lab", "meta", "pa", "rob", "wb", "dp", "summary", "bc", "lb", "bm", "lc", "PB", "pg"], "pd": ["vd", "md", "bf", "dd", " td", "lp", "sth", " cd", "tp", "edd", "PD", "po", " PD", " ep", "pm", "bd", "dl", " DP", "p", "fp", " sd", "ud", "d", " ta", " db", " proto", "wp", "dra", "ppa", "ld", "py", " d", "pc", " cad", "fd", "xd", "td", "sb", "pp", "dt", "np", "gd", " cp", " std", "cb", " dc", " prod", "hd", "sd", "pa", " dd", " rc", " FD", "dp", " df", " disp", "ds", "raf", " da", "PB", "cd"]}}
{"project": "qemu", "commit_id": "1f8431f42d833e8914f2d16ce4a49b7b72b90db0", "target": 0, "func": "bool machine_iommu(MachineState *machine)\n\n{\n\n    return machine->iommu;\n\n}\n", "idx": 2535, "substitutes": {"machine": ["comment", "model", "line", "field", "part", "manager", "inst", "agent", "object", "private", "computer", "super", "alias", "node", "m", "interface", "source", "vm", "element", "mode", "master", "service", "inner", "Machine", "boot", "image", "mc", "state", "proc", "address", "slave", "instance", "company", "oper", "message", "link", "money", "rule"]}}
{"project": "qemu", "commit_id": "cc68890166c2c1c5003e3eeb8535e1872e239a95", "target": 0, "func": "static int disas_cp15_insn(CPUState *env, DisasContext *s, uint32_t insn)\n\n{\n\n    uint32_t rd;\n\n    TCGv tmp, tmp2;\n\n\n\n    /* M profile cores use memory mapped registers instead of cp15.  */\n\n    if (arm_feature(env, ARM_FEATURE_M))\n\n\treturn 1;\n\n\n\n    if ((insn & (1 << 25)) == 0) {\n\n        if (insn & (1 << 20)) {\n\n            /* mrrc */\n\n            return 1;\n\n        }\n\n        /* mcrr.  Used for block cache operations, so implement as no-op.  */\n\n        return 0;\n\n    }\n\n    if ((insn & (1 << 4)) == 0) {\n\n        /* cdp */\n\n        return 1;\n\n    }\n\n    if (IS_USER(s) && !cp15_user_ok(insn)) {\n\n        return 1;\n\n    }\n\n    if ((insn & 0x0fff0fff) == 0x0e070f90\n\n        || (insn & 0x0fff0fff) == 0x0e070f58) {\n\n        /* Wait for interrupt.  */\n\n        gen_set_pc_im(s->pc);\n\n        s->is_jmp = DISAS_WFI;\n\n        return 0;\n\n    }\n\n    rd = (insn >> 12) & 0xf;\n\n\n\n    if (cp15_tls_load_store(env, s, insn, rd))\n\n        return 0;\n\n\n\n    tmp2 = tcg_const_i32(insn);\n\n    if (insn & ARM_CP_RW_BIT) {\n\n        tmp = new_tmp();\n\n        gen_helper_get_cp15(tmp, cpu_env, tmp2);\n\n        /* If the destination register is r15 then sets condition codes.  */\n\n        if (rd != 15)\n\n            store_reg(s, rd, tmp);\n\n        else\n\n            dead_tmp(tmp);\n\n    } else {\n\n        tmp = load_reg(s, rd);\n\n        gen_helper_set_cp15(cpu_env, tmp2, tmp);\n\n        dead_tmp(tmp);\n\n        /* Normally we would always end the TB here, but Linux\n\n         * arch/arm/mach-pxa/sleep.S expects two instructions following\n\n         * an MMU enable to execute from cache.  Imitate this behaviour.  */\n\n        if (!arm_feature(env, ARM_FEATURE_XSCALE) ||\n\n                (insn & 0x0fff0fff) != 0x0e010f10)\n\n            gen_lookup_tb(s);\n\n    }\n\n    tcg_temp_free_i32(tmp2);\n\n    return 0;\n\n}\n", "idx": 2538, "substitutes": {"env": ["sv", "equ", "settings", "context", "enc", "ctx", "si", "conf", "er", "ssl", "ex", "eu", "exec", "ec", "viron", "eni", "config", "m", "dat", "stage", "ens", "esm", "eve", "v", "conn", "ne", "txt", "ea", "server", "sf", "enh", "ses", "c", "sb", "site", "iss", "eng", "ench", "np", "nc", "anne", "dh", "exc", "kn", "vs", "proc", "args", "f", "estate", "sl", "environment", "e", "esp", "ev", "en"], "s": ["S", "fs", "sv", "sets", "su", "en", "ts", "ns", "settings", "r", "cs", "si", "ctx", "is", "n", "conf", "ssl", "o", "sites", "south", "p", "y", "d", "m", "sq", "session", "config", "sa", "v", "services", "conn", "states", "service", "sys", "g", "sie", "ps", "us", "server", "ses", "secondary", "spec", "c", "site", "sb", "es", "sf", "sing", "rs", "gs", "state", "args", "vs", "t", "proc", "os", "sg", "f", "u", "client", "space", "sr", "ss", "b", "sl", "e", "tests", "set", "ds", "sync", "xs"], "insn": ["allsn", "insyn", "openssn", "insp", "linsna", "insd", "insns", "allsp", "inl", "rulesN", "inssn", "insnin", "alsname", "INSnt", "linsen", "ressn", "opensn", "INSd", "insname", "resns", "insnan", "inn", "sinname", "insl", "rulesbn", "vinn", "ainssn", "lbsp", "issn", " insz", "inchn", " insd", "resd", "opensner", "INSz", "linsner", "alsnt", " insnin", "lbsno", "sinN", "insbn", "INSnan", " inssn", "INSname", "ind", "insz", "linssn", "alsc", "alsn", "outsn", "ainsns", "rulesp", "sinp", "insner", "incp", "issnin", "innor", "vinsn", "vinns", " insnt", "opensns", "outsz", "consd", "ainsd", "inN", "linsns", "vinner", "linsn", "INSp", "insnt", "sinn", "sinbn", "ainsn", "insnc", "incl", "insN", "allsnor", "INShn", " insc", "INSen", "insno", "INSna", "inno", "lbsn", "allsns", "alsnin", " insp", "outsnc", " insnc", "inp", " insno", " insen", "lbszn", "insna", "issnan", "linsnt", "INSnc", "insen", "consp", "inns", " insnan", "insnor", "inszn", " insyn", "sinnan", " insN", "inyn", " inszn", "INSN", "consn", "INSnor", "sinnt", "issc", " insns", "inbn", "INSn", "consyn", "insc", "outsN", "rulesn", "alsnan", "inzn", "INSns", " insna", "incn", "resn", "inhn", "INSl", "inshn"], "rd": ["md", "fr", "dd", "rb", "cr", "rr", "r", "rh", "sr", "ded", "rc", "ptr", "ord", "rt", "wr", "rx", "RM", "pd", "nd", "dr", "ind", "d", "rf", "red", "rod", "rw", "rss", "dy", "ri", "raid", "ld", "dra", "rest", "vr", "ARR", "rat", "fd", "rm", "rin", "RR", "xd", "td", "rs", "rg", "hr", "ru", "rn", "rid", "RD", "db", "sd", "rl", "rob", "RF", "lr", "addr", "ds", "ra", "cd"], "tmp": ["wx", "rb", "part", "pkg", "buff", "cmp", "pb", "tt", "temp", "wp", "rw", "keep", "v", "Temp", "sp", "output", "sb", "appy", "jp", "boot", "cb", "proc", "wb", "page", "br", "vt", "cpp", "null", "p", "bg", "mmm", "config", "buf", "vm", "mm", "rm", "data", "mk", "app", "pp", "test", "b", "err", "sup", "pot", "tab", "dd", "zip", "tp", "r", "mp", "ctx", "kk", "obj", "stuff", "pad", "cp", "nb", "txt", "xt", " ss", "amp", "cache", "rc", "copy", "img", "bb", "rt", "src", "api", "fb", "fake", "tc", "cro", "py", "emp", "c", "np", "result", "db", "storage"], "tmp2": ["temp32", " tmp3", "mp3", "tmp4", "temp2", " tmp4", "tmp32", "temp4", "mp32", "mp2", "temp1", "mp4", "tmp1", " tmp32", "temp3", " tmp1", "tmp3", "mp1"]}}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState *vc_init(const char *id, ChardevBackend *backend,\n\n                                ChardevReturn *ret, Error **errp)\n\n{\n\n    return vc_handler(backend->u.vc, errp);\n\n}\n", "idx": 2564, "substitutes": {"id": ["ident", "ID", "def", "code", "uri", "sid", "kind", "ref", "root", "ids", "pid", "name", "head", "class", "data", "kid", "mid", "Id", "parent", "url", "oid", "info", "rid", "db", "q", "ip", "uid", "path"], "backend": ["frontend", "Backend", "BACKend", "frontended", "BACKender", "backen", "backender", " backen", " backender", "BACKen", "Backended", "fronten", "Backen", "BACKended", "Backender", "backended", "frontender", " backended"], "ret": ["val", "res", "auth", "att", "def", "resp", "fin", "RET", "ref", "mem", "det", "obj", "red", "pub", "lit", "ut", "conn", "rets", "data", "reply", "eth", "fun", "reg", "result", "Ret", "proc"], "errp": ["acerfp", "acepo", "erP", "errfp", "errP", "acep", "erfp", "erpi", " errpi", " errpo", "erpo", "erp", "acerp", " errP", "errpo", "errpi", "acerpi", "acefp", "aceP", " errfp", "acerP"]}}
{"project": "qemu", "commit_id": "1f3870ab242018b724b845957f7f928a2d7c1f5b", "target": 0, "func": "USBDevice *usb_host_device_open(const char *devname)\n\n{\n\n    int fd = -1, ret;\n\n    USBHostDevice *dev = NULL;\n\n    struct usbdevfs_connectinfo ci;\n\n    char buf[1024];\n\n    int bus_num, addr;\n\n    char product_name[PRODUCT_NAME_SZ];\n\n\n\n    dev = qemu_mallocz(sizeof(USBHostDevice));\n\n    if (!dev)\n\n        goto fail;\n\n\n\n#ifdef DEBUG_ISOCH\n\n    printf(\"usb_host_device_open %s\\n\", devname);\n\n#endif\n\n    if (usb_host_find_device(&bus_num, &addr,\n\n                             product_name, sizeof(product_name),\n\n                             devname) < 0)\n\n        return NULL;\n\n\n\n    snprintf(buf, sizeof(buf), USBDEVFS_PATH \"/%03d/%03d\",\n\n             bus_num, addr);\n\n    fd = open(buf, O_RDWR | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        perror(buf);\n\n        return NULL;\n\n    }\n\n\n\n    /* read the device description */\n\n    dev->descr_len = read(fd, dev->descr, sizeof(dev->descr));\n\n    if (dev->descr_len <= 0) {\n\n        perror(\"usb_host_device_open: reading device data failed\");\n\n        goto fail;\n\n    }\n\n\n\n#ifdef DEBUG\n\n    {\n\n        int x;\n\n        printf(\"=== begin dumping device descriptor data ===\\n\");\n\n        for (x = 0; x < dev->descr_len; x++)\n\n            printf(\"%02x \", dev->descr[x]);\n\n        printf(\"\\n=== end dumping device descriptor data ===\\n\");\n\n    }\n\n#endif\n\n\n\n    dev->fd = fd;\n\n    dev->configuration = 1;\n\n\n\n    /* XXX - do something about initial configuration */\n\n    if (!usb_host_update_interfaces(dev, 1))\n\n        goto fail;\n\n\n\n    ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);\n\n    if (ret < 0) {\n\n        perror(\"usb_host_device_open: USBDEVFS_CONNECTINFO\");\n\n        goto fail;\n\n    }\n\n\n\n#ifdef DEBUG\n\n    printf(\"host USB device %d.%d grabbed\\n\", bus_num, addr);\n\n#endif\n\n\n\n    ret = usb_linux_update_endp_table(dev);\n\n    if (ret)\n\n        goto fail;\n\n\n\n    if (ci.slow)\n\n        dev->dev.speed = USB_SPEED_LOW;\n\n    else\n\n        dev->dev.speed = USB_SPEED_HIGH;\n\n    dev->dev.handle_packet = usb_generic_handle_packet;\n\n\n\n    dev->dev.handle_reset = usb_host_handle_reset;\n\n    dev->dev.handle_control = usb_host_handle_control;\n\n    dev->dev.handle_data = usb_host_handle_data;\n\n    dev->dev.handle_destroy = usb_host_handle_destroy;\n\n\n\n    if (product_name[0] == '\\0')\n\n        snprintf(dev->dev.devname, sizeof(dev->dev.devname),\n\n                 \"host:%s\", devname);\n\n    else\n\n        pstrcpy(dev->dev.devname, sizeof(dev->dev.devname),\n\n                product_name);\n\n\n\n#ifdef USE_ASYNCIO\n\n    /* set up the signal handlers */\n\n    sigemptyset(&sigact.sa_mask);\n\n    sigact.sa_sigaction = isoch_done;\n\n    sigact.sa_flags = SA_SIGINFO;\n\n    sigact.sa_restorer = 0;\n\n    ret = sigaction(SIG_ISOCOMPLETE, &sigact, NULL);\n\n    if (ret < 0) {\n\n        perror(\"usb_host_device_open: sigaction failed\");\n\n        goto fail;\n\n    }\n\n\n\n    if (pipe(dev->pipe_fds) < 0) {\n\n        perror(\"usb_host_device_open: pipe creation failed\");\n\n        goto fail;\n\n    }\n\n    fcntl(dev->pipe_fds[0], F_SETFL, O_NONBLOCK | O_ASYNC);\n\n    fcntl(dev->pipe_fds[1], F_SETFL, O_NONBLOCK);\n\n    qemu_set_fd_handler(dev->pipe_fds[0], urb_completion_pipe_read, NULL, dev);\n\n#endif\n\n    dev->urbs_ready = 0;\n\n    return (USBDevice *)dev;\n\nfail:\n\n    if (dev)\n\n        qemu_free(dev);\n\n    close(fd);\n\n    return NULL;\n\n}\n", "idx": 2583, "substitutes": {"usb_host_device_open": ["usb_host_driver_new", "usb_host_device__new", "usb_host_device__open", "usb_host_device_connect", "usb_host_device_new", "usb_host_driver_open", "usb_host_device__init", "usb_host_device__connect", "usb_host_driver_connect", "usb_host_device_init", "usb_host_driver_init"], "devname": ["evsource", "evno", "evName", "disksource", "devsource", "deviceno", "devid", "propnames", "devName", " devNAME", "appName", " devno", "propNAME", "devno", "deviceName", "diskno", "devNAME", "appid", " devName", " devnames", "devicename", "devnames", "deviceid", "appno", "vernames", "verName", "propname", "vername", "diskname", " devsource", " devid", "evname", "diskName", "appname", "verNAME", "propName"], "ret": ["cat", "val", "let", "fail", "res", "part", "pat", "back", "att", "def", "rc", "fi", "tr", "rt", "match", "pet", "resp", "hash", "alt", "pt", "fin", "RET", "ref", "arr", "mem", "det", "rev", "obj", "red", "len", "no", "full", "lit", "success", "ur", "rets", "str", "data", "reply", "ry", "fun", "nt", "reg", "result", "arg", "Ret", "db", "err", "rl", "al", "re", "pass", "out", "bit", "art"], "dev": ["driver", "md", "dist", "home", "diff", "cmp", "enc", "grad", "conf", "temp", "gh", "debug", "group", "d", "v", "fd", "Dev", "info", "ch", "block", "rad", "cd", "gu", "mod", "nov", "serial", "error", "de", "p", "valid", "config", "dat", "ad", "data", "hub", "app", "nt", "test", "gd", "prof", "sd", "dem", "ow", "serv", "priv", "ev", "comment", "dd", "wd", "od", "device", "fi", "bd", "sh", "new", "raw", "var", "obj", "pub", "df", "conn", "game", "server", "cmd", "ver", "dom", "user", "val", "cache", "dc", "av", "fail", "die", "bug", "attr", "def", "ve", "DEV", "root", "api", "adv", "off", "end", "fw", "c", "self", "di", "start", "result", "db", "client", "hw"], "ci": ["cu", "i", "cc", "dc", "ui", "io", "cf", " cf", "fi", "cs", "si", "ctx", " io", "vc", "ic", " gcc", "CI", "ind", "oci", "cci", "cli", "config", "ct", " priv", "ini", "ii", " di", " cc", "sci", "lc", "conn", "li", "co", " c", "c", "ctrl", "di", "ai", "info", "init", "vi", " dc", "pi", " ca", " i", " lib", " ic", " ec", "ni", " vi", " li", " info", "ki", " exec", " pci", " ki"], "buf": ["bf", "feed", "rb", "bc", "mac", "buff", "loc", "cf", "fab", "rc", "ptr", "context", "fi", "ctx", "pb", "conv", "bd", "alloc", "tmp", "ref", "src", "ab", "ff", " buffer", "config", "queue", "buffer", "bed", "vec", "fb", "pad", "bus", "cv", "cp", "func", "fd", "feat", "data", "prop", "path", "uf", "port", "bag", "c", "bh", "result", "cb", "la", "proc", "b", "cmd", "box", "doc", "wb", "desc", "bytes", "cas", "uc", "seq", "br"], "bus_num": ["busPno", "bus_id", "bus_count", " bus2no", " bus_nom", " bus_nu", "busacid", " bus2number", "busPnumber", "bus_nu", "BUS_num", "BUS_id", "busacno", " bus2len", "busacnum", "busaccount", "bus_nom", " bus2num", "bus_len", " bus_len", "BUS_no", " bus_un", "busPnum", "bus2num", " bus_number", "bus_number", "bus2no", "bus_un", "busPlen", "bus2number", "bus_no", "BUS_count", "bus2len", " bus_no"], "addr": ["host", "md", "dist", "offset", "part", "mac", "nm", "loc", "attr", "device", "rc", "ptr", "ord", "ack", "hop", "rt", "alt", "az", "ref", "src", "alias", "node", "adr", "dr", "bridge", "name", "id", "amd", "ad", "route", "mode", "pad", "pos", "ext", "owner", "mid", "arm", "eth", "ar", "url", "arch", "nr", "nc", "layer", "ace", "la", "oa", "amp", "align", "ip", "address", "Address", "index"], "product_name": ["product__number", "product__NAME", "product_type", "product__name", "product_size", " product_number", " product_names", "plugin_name", "product__names", "product_address", " prod_name", "plugin_number", "product_number", "product_NAME", "product_names", "productnamename", " prod_address", "plugin_type", " product_NAME", "product_path", "productnamesize", "plugin_path", "productnameaddress", " prod_size"], "x": ["xxx", "wa", "wx", "val", "i", "sw", "r", "X", " X", "ww", "ex", "code", "ctx", "n", "num", "xx", "y", "rx", "p", "key", "xc", "d", "xa", "yx", "id", "z", "lex", "w", "pe", "orig", "xp", "k", "v", "xxxx", "pos", "xy", "work", "c", "xt", "ix", "sex", "tx", "dx", "fx", "t", "ax", "f", "u", "xi", "ux", "h", "xs", "index"]}}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n    float32 f32;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN square root */\n\n        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n    }\n\n    f32 = float64_to_float32(farg.d, &env->fp_status);\n\n    farg.d = float32_to_float64(f32, &env->fp_status);\n\n\n\n    return farg.ll;\n\n}\n", "idx": 2594, "substitutes": {"env": ["cal", "manager", "her", "context", "enc", "code", "ctx", "conf", "ep", "eu", "exec", "impl", "ec", "viron", "eni", "config", "queue", "obj", "chal", "engine", "fen", "cv", "v", "loader", "energy", "ext", "conn", "ah", "erv", "ass", "console", "txt", "ea", "server", "site", "eng", "np", "anne", "info", "exc", "eff", "args", "proc", "oa", "db", "que", "gui", "err", "global", "emb", "environment", "e", "qt", "ev", "en", "pg", "Environment"], "arg": ["cat", "val", "all", "mac", "attr", "Arg", "grad", "flag", "option", "enc", "num", "arc", "p", "ig", "param", "arr", "var", "config", "call", "load", "arp", "len", "v", "ang", "pc", "g", "ray", "ag", "argument", "ar", "target", "weight", "result", "ace", "args", "inter", "ax", "op", "par", "amp", "lb", "bit"], "farg": [" Falloc", "refarc", "elfflag", "infargs", " farc", " ffarg", " fflag", "ufargs", "fwarc", "fwamp", " fload", "larm", "larc", "infarc", "elfarc", " frg", " falloc", " Farg", "fflag", "ifarg", " freg", "farc", "infarg", "infflag", "tg", "farp", "fwarg", "fcarg", "freg", "ifarc", "falloc", " Fargs", "fcarc", " fargs", "dfreg", "fcload", "refarg", "targ", "ufreg", "fload", "dfarg", "refarp", " ffargs", "famp", " ffrg", "refarm", "elfarg", "farm", "ufarg", "ifarp", "refamp", "dfargs", "ufarp", "fargs", " Frg", "frg", " farm", "tload", " farp", "fwarp", " ffalloc", "elfargs", "larp", "ifamp", "fcg", "tarc", "dfarp", "larg", "fg", " fg"], "f32": ["sf34", "c34", "utf32", "f31", "c31", "c32", "utf31", "f34", " f16", "sf31", "f64", "utf34", "utf64", " f34", "tf32", "sf32", "tf16", "tf31", "c16", " f64", "f16", "sf64", "tf34", " f31", "sf16"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "int gen_new_label(void)\n\n{\n\n    TCGContext *s = &tcg_ctx;\n\n    int idx;\n\n    TCGLabel *l;\n\n\n\n    if (s->nb_labels >= TCG_MAX_LABELS)\n\n        tcg_abort();\n\n    idx = s->nb_labels++;\n\n    l = &s->labels[idx];\n\n    l->has_value = 0;\n\n    l->u.first_reloc = NULL;\n\n    return idx;\n\n}\n", "idx": 2602, "substitutes": {"s": ["S", "fs", "comments", "sv", "su", "sc", "sr", "ts", "ns", "hs", "cs", "si", "ctx", "settings", "ssl", "o", "south", "p", "less", "ins", "sq", "session", "se", "services", "states", "service", "g", "ps", "lines", "ses", "sf", "spec", "c", "sb", "rs", "self", "gs", "sym", "small", "os", "sg", "u", "space", "ss", "js", "e", "sl", "ls", "ops", "ds", "sync", "xs"], "idx": [" idxi", "midz", "pidx", "pidxc", "idX", " idxc", "Idxi", "Idxc", "IDxc", " idz", "IDx", "IDz", "idb", "idc", "Idc", " idc", "IdX", " idX", "pidxf", "idxf", "idz", "indxc", "Idxf", "midx", "midc", "pidX", "Idz", "indxi", "indz", "midxc", "Idb", "IDb", " idb", " idxf", "Idx", "idxc", "idxi", "indx"], "l": ["i", "lp", "lu", "j", "n", "dl", "pl", "jl", "o", "L", "p", "lin", "le", "cell", "fl", "ly", "ln", "ol", "ul", "v", "el", "li", "g", "ell", "il", "c", "ll", "kl", "la", "nl", "al", "t", "b", "rl", "u", "sl", "ls", "bl", "lb", "wl", "lf", "lc"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_round_to_clusters(BlockDriverState *bs,\n\n                            int64_t sector_num, int nb_sectors,\n\n                            int64_t *cluster_sector_num,\n\n                            int *cluster_nb_sectors)\n\n{\n\n    BlockDriverInfo bdi;\n\n\n\n    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {\n\n        *cluster_sector_num = sector_num;\n\n        *cluster_nb_sectors = nb_sectors;\n\n    } else {\n\n        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;\n\n        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);\n\n        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +\n\n                                            nb_sectors, c);\n\n    }\n\n}\n", "idx": 2604, "substitutes": {"bs": ["banks", "fs", "las", "base", "BS", "ns", "bid", "ts", "cs", "pb", "bes", "ubs", "bps", "bits", "obj", "lbs", "fb", "bos", "sels", "ps", "ses", "iss", "sb", "rs", "obs", "gb", "gs", "vs", "db", "b", "os", "bas", "ls", "bis", "bc", "lb", "ds", "s", "isi"], "sector_num": ["sector_count", "sector_name", "section_size", "sector_number", "section_note", "section_name", "section_num", "sector_note", "sector_nor", "section_con", "section_nor", "section_number", "sector_size", "sector_con", "section_count"], "nb_sectors": ["nb_seeters", "nb_syctors", "nb_lexctors", "nb_verics", "nb_secgments", "nb_segments", "nb_veeters", "nb_SErics", "nb_sygments", "nb_velements", "nb_syeters", "nb_SEctors", "nb_secources", "nb_seources", "nb_seccs", "nb_veources", "nb_SEgments", "nb_sycs", "nb_vegments", "nb_vecs", "nb_persegments", "nb_secctors", "nb_vectors", "nb_lexgments", "nb_lexcs", "nb_lexources", "nb_selements", "nb_persectors", "nb_SElements", "nb_secs", "nb_seceters", "nb_perselements", "nb_perserics", "nb_serics"], "cluster_sector_num": ["cluster_section_sum", "cluster_section_num", "cluster_sector_size", "cluster_sector_index", "cluster_tier_name", "cluster_section_n", "cluster_section_number", "cluster_sector_n", "cluster_section_no", "cluster_sector_name", "cluster_tier_num", "cluster_sector_number", "cluster_tier_number", "cluster_section_index", "cluster_section_count", "cluster_tier_size", "cluster_sector__sum", "cluster_sector__number", "cluster_sector_count", "cluster_sector__n", "cluster_sector__num", "cluster_sector_sum", "cluster_sector_no"], "cluster_nb_sectors": ["cluster_nb_pecs", "cluster_nb_gections", "cluster_nb_pections", "cluster_nb_vections", "cluster_nb_secctions", "cluster_nb_gecs", "cluster_nb_sector", "cluster_nb_pectors", "cluster_nb_secctor", "cluster_nb_vectors", "cluster_nb_secgments", "cluster_nb_sections", "cluster_nb_gectors", "cluster_nb_segments", "cluster_nb_gegments", "cluster_nb_vegments", "cluster_nb_secs", "cluster_nb_vector", "cluster_nb_vecs", "cluster_nb_pegments", "cluster_nb_gector", "cluster_nb_secctors"], "bdi": ["bbmi", "bbdi", "dadi", "lni", "bbdc", "fsi", "sbmi", "badi", "dni", " bsi", "bdc", " bni", "lsi", "nini", "didi", "nni", "bidi", "ldc", " bidi", " bdc", "fdc", "pidi", "fdi", "ndi", "bbni", "nmi", "bbsi", "sbdi", " badi", "ldi", "bni", "fni", "bsi", "sbini", "ddi", "pdi", "bbini", "padi", "bmi", "pni", "sbni", "bini"]}}
{"project": "qemu", "commit_id": "b0706b716769494f321a0d2bfd9fa9893992f995", "target": 1, "func": "void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)\n\n{\n\n    CPUArchState *env;\n\n\n\n    int mmu_idx;\n\n\n\n    assert_cpu_is_self(cpu);\n\n\n\n    env = cpu->env_ptr;\n\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n\n        unsigned int i;\n\n\n\n        for (i = 0; i < CPU_TLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n\n\n        for (i = 0; i < CPU_VTLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n    }\n\n}\n", "idx": 2620, "substitutes": {"cpu": ["clock", "cache", "pkg", "pec", "uci", "cpp", "rc", "ctx", "intel", "linux", "core", "uca", "eu", "fp", "gc", "node", "chu", "eni", "cli", "config", "pid", "vm", "platform", "cp", "loader", "gpu", "sys", "pc", "roc", "conn", "python", "bench", "c", "comp", "nc", "pu", "boot", "process", "proc", "nic", "hp", "CPU", "hw", "utils", "instance", "chip", "net", "processor", "lc"], "start1": [" startOne", "set01", " startLength", " startn", " start0", "startOne", "set0", "gradeOne", "end2", "offset01", "set1", "index1", "stop2", "end3", " start2", "offsetOne", "startLength", "grade01", "stop3", "stop1", "start0", "start3", "startn", "grade1", "endLength", "start01", "graden", "index01", "stopLength", "start2", "end1", " start3", "index0", "offsetn", "offset1", " start01"], "length": ["view", "offset", "total", "text", "section", "l", "padding", "number", "maximum", "sequence", "limit", "buffer", "load", "time", "len", "Length", "slice", "pad", "count", "full", "build", "end", "distance", "type", "position", "path", "duration", "shape", "url", "amount", "library", "depth", "block", "available", "style", "angle", "tail", "range", "address", "size", "collection", "seq", "filename"], "env": ["cache", "cf", "equ", "her", "context", "enc", "si", "ctx", "conf", "dir", "external", "core", "eu", "ec", "viron", "eni", "config", "session", "obj", "vm", "chal", "elf", "engine", "v", "py", "ass", "energy", "conn", "el", "ext", "file", "erv", "loader", "console", "ea", "enh", "eng", "enable", "np", "scope", "exc", "args", "dict", "vs", "db", "que", "oa", "eur", "e", "environment", "enda", "ev", "en", "Environment"], "mmu_idx": ["mmu_adi", "mmu_Idx", "mmu_idxi", "mmu_dx", "mmu_adx", "mmu_adX", "mmu_minc", "mmu_ridx", "mmu_indt", "mmu_mainx", "mmu_idc", "mmu_indexxs", "mmu__endx", "mmu_minf", "mmu_ming", "mmu_idey", "mmu__endct", "mmu_idez", "mmu_itt", "mmu_midxi", "mmu_inx", "mmu_ridxs", "mmu_dxs", "mmu_idxs", "mmu__idi", "mmu_ity", "mmu_itw", "mmu__endxs", "mmu_dxe", "mmu_idt", "mmu_endx", "mmu_indw", "mmu_idz", "mmu_endxs", "mmu_mainst", "mmu_idex", "mmu__idx", "mmu_idf", "mmu__idxe", "mmu__adx", "mmu_ipc", "mmu__idxs", "mmu_ridxi", "mmu_indx", "mmu_indexi", "mmu_mainxi", "mmu__adxs", "mmu_idct", "mmu_Idc", "mmu_ipf", "mmu_idw", "mmu_midxs", "mmu_midst", "mmu__idct", "mmu_ini", "mmu_inX", "mmu_idi", "mmu_indexX", "mmu__adi", "mmu__endxe", "mmu_idst", "mmu_Idw", "mmu_Idt", "mmu_mainxs", "mmu_ipxe", "mmu_midx", "mmu_adxs", "mmu_endxe", "mmu_ipct", "mmu_Idy", "mmu_endct", "mmu_idg", "mmu_ipx", "mmu_ridst", "mmu_Idz", "mmu__adX", "mmu_itx", "mmu_idX", "mmu_indexx", "mmu_inxs", "mmu_idxe", "mmu_indy", "mmu_idy", "mmu_ipxs", "mmu_dct", "mmu_minx", "mmu_idec", "mmu__idX", "mmu_ipg"], "i": ["ui", "io", "l", "fi", "si", "j", "n", "uri", "o", "y", "p", "ci", "multi", "qi", "d", "m", "cli", "oi", "name", "id", "api", "ri", "k", "ini", "ii", "v", "a", "x", "bi", "mini", "li", "g", "iu", "ie", "ki", "c", "in", "zi", "di", "start", "ai", "jp", "init", "abi", "info", "pi", "mu", "t", "gi", "f", "u", "b", "ti", "e", "xi", "I", "it", "phi", "yi", "lc", "index"]}}
{"project": "qemu", "commit_id": "e0ef439588ce1ede747f82b77d893190c1cc9f4d", "target": 1, "func": "blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n                   QEMUIOVector *qiov, int flags)\n{\n    BDRVBlkdebugState *s = bs->opaque;\n    BlkdebugRule *rule = NULL;\n    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {\n        uint64_t inject_offset = rule->options.inject.offset;\n        if (inject_offset == -1 ||\n            (inject_offset >= offset && inject_offset < offset + bytes))\n        {\n            break;\n    if (rule && rule->options.inject.error) {\n        return inject_error(bs, rule);\n    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);", "idx": 2622, "substitutes": {"s": ["S", "r", "ns", "settings", "cs", "si", "is", "ssl", "o", "p", "bs", "se", "sa", "stats", "sys", "states", "sie", "service", "ps", "server", "ses", "spec", "c", "sb", "rs", "es", "state", "b", "os", "f", "u", "ss", "js", "sl", "ls", "ds", "sync"], "rule": ["comment", "model", "line", "fr", "ule", "val", "cache", "lock", "update", "rr", "r", "role", "sort", "section", "match", "error", "def", "cookie", "play", "uri", "o", "sche", "debug", "root", "config", "name", "trial", "ride", "ri", "route", "fee", "run", "slice", "ul", "event", "Rule", "file", "service", "li", "ler", "callback", "parent", "url", "reg", "ee", "plugin", "ULE", "result", "block", "state", "style", "rate", "gi", "rl", "f", "err", "rules", "range", "resource", "statement", "lr", "e", "use", "tag", "order"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int idreg_init1(SysBusDevice *dev)\n\n{\n\n    IDRegState *s = MACIO_ID_REGISTER(dev);\n\n\n\n    memory_region_init_ram(&s->mem, OBJECT(s),\n\n                           \"sun4m.idreg\", sizeof(idreg_data), &error_abort);\n\n    vmstate_register_ram_global(&s->mem);\n\n    memory_region_set_readonly(&s->mem, true);\n\n    sysbus_init_mmio(dev, &s->mem);\n\n    return 0;\n\n}\n", "idx": 2624, "substitutes": {"dev": ["driver", "md", "mod", "serial", "dd", "comment", "gu", "dc", "av", "home", "nov", "die", "priv", "device", "def", "de", "grad", "img", "p", "exec", "valid", "mem", "dm", "d", "cam", "w", "prom", "link", "conn", "data", "pro", "Dev", "app", "self", "eng", "gd", "di", "ch", "dem", "cmd", "ver", "serv", "rad", "ev", "hw", "dom"], "s": ["S", "i", "fs", "ms", "su", "r", "ts", "ns", "cs", "is", "si", "sec", "n", "ssl", "o", "p", "d", "m", "sq", "session", "obj", "w", "an", "services", "a", "sys", "states", "service", "g", "ps", "ses", "sf", "spec", "c", "rs", "sb", "es", "self", "gs", "sym", "args", "t", "b", "sg", "f", "os", "storage", "side", "js", "e", "sl", "ss", "ds", "sync"]}}
{"project": "qemu", "commit_id": "f02ca5cbeaf86038834c1953247a1579d7921927", "target": 0, "func": "static inline void tcg_out_ld_ptr(TCGContext *s, int ret,\n\n                                  tcg_target_long arg)\n\n{\n\n#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n\n    if (arg != (arg & 0xffffffff))\n\n        fprintf(stderr, \"unimplemented %s with offset %ld\\n\", __func__, arg);\n\n    if (arg != (arg & 0xfff))\n\n        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));\n\n    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |\n\n              INSN_IMM13(arg & 0x3ff));\n\n#else\n\n    tcg_out_ld_raw(s, ret, arg);\n\n#endif\n\n}\n", "idx": 2628, "substitutes": {"s": ["i", "fs", "r", "sets", "sync", "ts", "ns", "settings", "cs", "private", "context", "ctx", "sec", "is", "ssl", "qs", "south", "p", "d", "sq", "session", "w", "services", "sys", "service", "g", "us", "server", "ses", "sf", "secondary", "c", "sb", "site", "self", "es", "scope", "gs", "sym", "args", "t", "b", "f", "u", "os", "js", "e", "ops", "h"], "ret": ["val", "rb", "res", "r", "sr", "en", "att", "def", "match", "tr", "Arg", "rt", "flag", " Ret", "ary", "fi", "alt", "valid", "RET", "ref", "arr", "det", "dr", "gt", "rev", "obj", "status", "red", "store", "pret", "len", "lit", "ext", "rets", "feat", "str", "data", "reply", "mt", "server", "fun", "rs", "reg", "xt", "nt", "ar", "info", "result", "Ret", "args", "b", "f", "al", "ft", "addr", "re", "bis", "seq"], "arg": ["lag", "match", "enc", "num", "alt", "ref", "len", "v", "ag", "rg", "info", "inc", "f", "magic", "doc", "bit", "msg", "ac", "Arg", "option", "p", "ig", "valid", "call", "name", "ad", "data", "ace", "args", "al", "op", "err", "addr", "argument", "lc", "tag", "gen", "flag", "arc", "param", "act", "var", "ang", "g", "str", "ar", "reg", "cmd", "amp", "extra", "use", "cat", "val", "mac", "arr", "other", "id", "func", "ext", "arm", "slot", "in", "target", "asm", "result", "ax", "par", "parse", "pass", "en", "art"]}}
{"project": "qemu", "commit_id": "95b5edcd92d64c7b8fe9f2e3e0725fdf84be0dfa", "target": 0, "func": "int xen_config_dev_blk(DriveInfo *disk)\n\n{\n\n    char fe[256], be[256];\n\n    int vdev = 202 * 256 + 16 * disk->unit;\n\n    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;\n\n    const char *devtype = cdrom ? \"cdrom\" : \"disk\";\n\n    const char *mode    = cdrom ? \"r\"     : \"w\";\n\n\n\n    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),\n\n\t     \"xvd%c\", 'a' + disk->unit);\n\n    xen_be_printf(NULL, 1, \"config disk %d [%s]: %s\\n\",\n\n                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);\n\n    xen_config_dev_dirs(\"vbd\", \"qdisk\", vdev, fe, be, sizeof(fe));\n\n\n\n    /* frontend */\n\n    xenstore_write_int(fe, \"virtual-device\",  vdev);\n\n    xenstore_write_str(fe, \"device-type\",     devtype);\n\n\n\n    /* backend */\n\n    xenstore_write_str(be, \"dev\",             disk->bdrv->device_name);\n\n    xenstore_write_str(be, \"type\",            \"file\");\n\n    xenstore_write_str(be, \"params\",          disk->bdrv->filename);\n\n    xenstore_write_str(be, \"mode\",            mode);\n\n\n\n    /* common stuff */\n\n    return xen_config_dev_all(fe, be);\n\n}\n", "idx": 2632, "substitutes": {"disk": ["vd", "md", "driver", "Disk", "diff", "part", "disc", "dl", "d", "sci", "dam", "plugin", "image", "mc", "block", "network", "dev", "draw", "ram", "drive", "docker", "pd", "config", "se", "dat", "load", "ad", "hard", "cdn", "wk", "isk", "data", "pack", "sd", "sk", "sync", "lc", "dd", "wd", "io", "device", "wheel", "core", "product", "df", "slice", "pod", "prem", "conn", "dis", "service", "dn", "read", "dri", "sky", "ds", "design", "clean", "model", "machine", "cache", "dc", "plan", "scan", "die", "connection", "word", "cer", "vol", "k", "dim", "file", "co", "work", "np", "di", "db", "storage", "da", "parse", "link"], "fe": ["fr", "bf", "fle", "ke", "ile", "flo", "ife", "fc", "de", "fi", "ge", "play", "fer", "te", "le", "BE", "efe", "se", " pe", "fee", "xe", "ae", "pe", "fb", "we", "fm", "fen", "fine", "FE", "oe", "file", "eb", "ne", "ube", "xf", "ie", "coe", "ize", "sf", "ze", "me", "he", "ef", "fa", "ee", "ace", "wife", " f", "f", "ffe", "none", "que", "lab", "abe", "e", " me", "che", "bee", "ce", "Fe"], "be": ["fr", "bf", "ke", "ape", "com", "ste", "fi", "de", "is", "ge", "fer", "bes", "te", "ve", " Be", "Be", "le", "BE", "efe", "se", "ble", "ro", "ae", "bare", "ba", "pe", "fine", "are", "bi", "ben", "ibe", "oe", "obe", "co", "ine", "eb", "ne", "ube", "FE", "pro", "ie", "coe", "ze", "ere", "he", "ee", "bre", "ber", "abe", "e", "che", "oper", "fore", "bee", "robe", "ce", "ome", "ile"], "devtype": [" devype", " devType", " devlevel", "disktype", "devype", "devType", "difftypes", "divname", " devtypes", "apptype", "apptypes", "diskype", "divlevel", "diskname", "devname", "diffname", "devlevel", " devname", "divype", "disklevel", "appname", "difftype", "appType", "diffType", "divtype", "devtypes"], "mode": ["md", "mod", "part", "password", "scale", "role", "device", "language", "option", "kind", "command", "mem", "alias", "module", "m", "config", "name", "id", "force", "Mode", "mm", "dim", "type", "position", "owner", "member", "description", "direction", "MODE", "cmd", "none", "op", "dev", "version", "range", "size", "use", "username", "path", "source"]}}
{"project": "qemu", "commit_id": "cd42d5b23691ad73edfd6dbcfc935a960a9c5a65", "target": 0, "func": "static inline void gen_intermediate_code_internal(OpenRISCCPU *cpu,\n\n                                                  TranslationBlock *tb,\n\n                                                  int search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    struct DisasContext ctx, *dc = &ctx;\n\n    uint16_t *gen_opc_end;\n\n    uint32_t pc_start;\n\n    int j, k;\n\n    uint32_t next_page_start;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    dc->tb = tb;\n\n\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->ppc = pc_start;\n\n    dc->pc = pc_start;\n\n    dc->flags = cpu->env.cpucfgr;\n\n    dc->mem_idx = cpu_mmu_index(&cpu->env);\n\n    dc->synced_flags = dc->tb_flags = tb->flags;\n\n    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"-----------------------------------------\\n\");\n\n        log_cpu_state(CPU(cpu), 0);\n\n    }\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    k = -1;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n\n\n    gen_tb_start();\n\n\n\n    do {\n\n        check_breakpoint(cpu, dc);\n\n        if (search_pc) {\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (k < j) {\n\n                k++;\n\n                while (k < j) {\n\n                    tcg_ctx.gen_opc_instr_start[k++] = 0;\n\n                }\n\n            }\n\n            tcg_ctx.gen_opc_pc[k] = dc->pc;\n\n            tcg_ctx.gen_opc_instr_start[k] = 1;\n\n            tcg_ctx.gen_opc_icount[k] = num_insns;\n\n        }\n\n\n\n        if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n            tcg_gen_debug_insn_start(dc->pc);\n\n        }\n\n\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n        dc->ppc = dc->pc - 4;\n\n        dc->npc = dc->pc + 4;\n\n        tcg_gen_movi_tl(cpu_ppc, dc->ppc);\n\n        tcg_gen_movi_tl(cpu_npc, dc->npc);\n\n        disas_openrisc_insn(dc, cpu);\n\n        dc->pc = dc->npc;\n\n        num_insns++;\n\n        /* delay slot */\n\n        if (dc->delayed_branch) {\n\n            dc->delayed_branch--;\n\n            if (!dc->delayed_branch) {\n\n                dc->tb_flags &= ~D_FLAG;\n\n                gen_sync_flags(dc);\n\n                tcg_gen_mov_tl(cpu_pc, jmp_pc);\n\n                tcg_gen_mov_tl(cpu_npc, jmp_pc);\n\n                tcg_gen_movi_tl(jmp_pc, 0);\n\n                tcg_gen_exit_tb(0);\n\n                dc->is_jmp = DISAS_JUMP;\n\n                break;\n\n            }\n\n        }\n\n    } while (!dc->is_jmp\n\n             && tcg_ctx.gen_opc_ptr < gen_opc_end\n\n             && !cs->singlestep_enabled\n\n             && !singlestep\n\n             && (dc->pc < next_page_start)\n\n             && num_insns < max_insns);\n\n\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n    if (dc->is_jmp == DISAS_NEXT) {\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    }\n\n    if (unlikely(cs->singlestep_enabled)) {\n\n        if (dc->is_jmp == DISAS_NEXT) {\n\n            tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n        }\n\n        gen_exception(dc, EXCP_DEBUG);\n\n    } else {\n\n        switch (dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 0, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_JUMP:\n\n            break;\n\n        case DISAS_UPDATE:\n\n            /* indicate that the hash table must be used\n\n               to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n            /* nothing more to generate */\n\n            break;\n\n        }\n\n    }\n\n\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        k++;\n\n        while (k <= j) {\n\n            tcg_ctx.gen_opc_instr_start[k++] = 0;\n\n        }\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"\\n\");\n\n        log_target_disas(&cpu->env, pc_start, dc->pc - pc_start, 0);\n\n        qemu_log(\"\\nisize=%d osize=%td\\n\",\n\n            dc->pc - pc_start, tcg_ctx.gen_opc_ptr -\n\n            tcg_ctx.gen_opc_buf);\n\n    }\n\n#endif\n\n}\n", "idx": 2634, "substitutes": {"cpu": ["clock", "cu", "cache", "cfg", "mac", "device", "cpp", "cmp", "fc", "pb", "uci", "rc", "linux", "core", "drm", "computer", "fp", "cca", "gc", "node", "cli", "config", "cam", "gp", "vm", "cdn", "tc", "px", "uu", "cp", "GPU", "gpu", "conn", "pc", "roc", "sys", "cn", "server", "c", "comp", "nc", "np", "gb", "auc", "pu", "cow", "mc", "boot", "performance", "proc", "nic", "hp", "CPU", "hw", "component", "uc", "bc", "lb", "processor", "chip", "lc"], "tb": ["stb", "stp", "tab", "tmb", "ctp", "ntlb", "tbh", "tp", "tmbi", "ptcb", " tbs", "untB", "ptb", "pb", "ptB", "untb", "ctb", "tsbh", " tp", "ttbs", " tbb", "tlb", "trb", " tbh", "ttb", "untrb", "tsbi", "ttbr", "itbs", "ttbi", "tcb", "pbr", "ttp", "ctbs", " tB", "tbs", "ttlb", "stbi", "ptrb", "ntb", " tab", "itb", "itbi", "tbr", "tsb", "tsp", "ttbb", "itp", "ctbb", "pbs", "stbs", "tB", " tcb", "tmab", "tmbs", "tbi", "tbb", "ntbs", " trb", "itab", "ttbh", "ntbr", "plb", " tbi", "untcb"], "search_pc": ["search2mc", "search_fc", "scan_mc", "scanablepc", "search_ac", "searchableac", " search_mc", "search__pc", "search__mc", " searchablePC", "searchablepc", " searchablefc", " search_PC", "search__ac", "search2PC", "search_PC", "scan_pc", "scanablePC", "searchablefc", "searchablemc", " searchablemc", "search__PC", "scan_ac", "search2pc", "scanableac", "search_mc", "search__fc", " searchablepc", "scanablemc", "scan_PC", "searchablePC", "search2fc", " search_fc"], "cs": ["cas", "cc", "fs", "sc", "cf", "des", "ns", "rc", "ras", "Cs", "ec", "cms", "acs", "tc", "cp", "sys", "conn", "cons", "pc", "ca", "css", "ps", "spec", "ks", "c", "rs", "nc", "CS", "ck", "args", "wcs", "utils", "ls", "sk", "bc", "ds", "lc", "cus"], "ctx": ["ctl", "cu", "cache", "cc", "loc", "sc", "cf", "rc", "cmp", "context", "fc", " context", "cca", "ci", "exec", "ec", " gcc", "xc", "cli", "config", " cx", "tc", " cc", "cp", "conn", "pc", "ca", "cn", "c", "ctrl", "nc", "mc", "cb", "tx", "cmd", " rc", "utils", "aux", "bc", "cfg", "cas", "lc"], "dc": ["cu", "git", "jc", "cc", "mac", "disc", "enter", "loc", "sc", "cf", "ac", "device", "fc", "rc", "context", "uci", "core", "cca", "vc", "ci", "exec", "cus", "ec", "dm", "cms", "dr", "xc", "input", "config", "d", "dat", "DC", "ga", "design", "cdn", "tc", "df", "rec", "abc", "cp", "lc", "conn", "pc", "c", "dt", "du", "nc", "di", "auc", "mc", " DC", "ku", "db", "proc", "inc", "cmd", "doc", "da", "director", "bc", "cfg", "uc", "cm", "anc", "cd", "desc"], "gen_opc_end": ["gen_opc_start", "gen_opc_ends", "gen_opc__max", "gen_opc_max", "gen_opl_buf", "gen_opc__buf", "gen_opc__end", "gen_opl_start", "gen_opc__start", "gen_opf_ends", "gen_opc_buf", "gen_opl__start", "gen_opf_end", "gen_opl__max", "gen_opl__buf", "gen_opl_max", "gen_opc_len", "gen_opf_pos", "gen_opl__end", "gen_opf_len", "gen_opl_end", "gen_opc_pos"], "pc_start": ["pcacsize", "pc_limit", "pcvstart", "PC_first", "pcacstart", "pcacend", "pcfcount", "PC_offset", "pc_size", "pcvfirst", "pc00start", "pcvadd", "pc7start", "pcacstarted", "pcallmax", "pc_count", "PC_started", "pcfstarted", "pc00first", "pcfstart", "PC_add", "pc00end", "pc_pos", "pc00add", "pcallend", "PC_size", "PC_max", "PC_count", "pc_offset", "pc_first", "pc_started", "PC_pos", "pc_end", "PC_start", "pc_max", "PC_end", "pc7end", "pc7max", "pc7limit", "pc_add", "pcalllimit", "pcvend", "pcaccount", "pcallstart", "pcfend", "PC_limit"], "j": ["next", "ke", "i", "jc", "jo", "offset", "lock", "ok", "ik", "l", "n", "dj", "o", "jl", "y", "p", "key", "ind", "d", "m", "aj", "job", "z", "adj", "pop", "ja", "ij", "ii", "v", "uj", "conn", "g", "jj", "length", "ji", "jp", "ch", "kn", " i", "max", "q", "f", "kj", "ak", "js", "x", "J", "index"], "k": ["ek", "kw", "ko", "ke", "i", "K", "r", "ok", "l", "ik", "ack", "n", "y", "o", "kat", "p", "kk", "key", "ask", "ka", "d", "z", "id", "w", "kick", "unk", "v", "end", "dk", "kid", "kr", "ks", "spec", "work", "c", "mk", "start", "ch", "kn", "ck", "ku", "b", "q", "f", "u", "ak", "sk", "x", "ki"], "next_page_start": ["next_page2count", "next_page_size", "next_page2size", "next_page64max", "next_page2index", "next_page2max", "next_page_end", "next_page64end", "next_page_count", "next_page2start", "next_page2end", "next_page64index", "next_page64start", "next_page_index", "next_page_max"], "num_insns": ["num_vincs", "num_innc", "num_inpaces", "num_intsn", "num_insn", "num_itsnc", "num_lincons", "num_vinpaces", "num_inns", "num_linn", "num_linnc", "num_insnc", "num_inspaces", "num_intscs", "num_intspaces", "num_vinn", "num_itsn", "num_vinns", "num_incons", "num_inn", "num_linns", "num_intsns", "num_inscons", "num_itscons", "num_incs", "num_inscs", "num_itsns"], "max_insns": ["max_insNs", "max_inns", "max_INSns", "max_insn", "max_innos", "max_vinns", "max_gesns", "max_incn", "max_incNs", "max_INSn", "max_inccons", "max_vincs", "max_vincons", "max_genns", "max_INScs", "max_inds", "max_inscons", "max_incs", "max_gends", "max_gesnos", "max_inNs", "max_tsvs", "max_vinn", "max_inccs", "max_insds", "max_tsn", "max_inn", "max_incons", "max_incns", "max_tsnos", "max_gesn", "max_vinds", "max_gencs", "max_INSNs", "max_tsns", "max_inscs", "max_invs", "max_insvs", "max_genn", "max_gesvs", "max_insnos"], "delayed_branch": ["delayed_banch", "delayed_bracket", "delayed_banches", "delayed_bancer", "delayed_branches", "delayed_franches", "delayed_franch", "delayed_backet", "delayed_granch", "delayed_granches", "delayed_grancer", "delayed_brancer", "delayed_francer", "delayed_fracket", "delayed_gracket"]}}
{"project": "qemu", "commit_id": "3a55fc0f243104998bee5106b121cff257df5d33", "target": 1, "func": "static void pci_ivshmem_realize(PCIDevice *dev, Error **errp)\n\n{\n\n    IVShmemState *s = IVSHMEM(dev);\n\n    Error *err = NULL;\n\n    uint8_t *pci_conf;\n\n    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n        PCI_BASE_ADDRESS_MEM_PREFETCH;\n\n\n\n    if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) {\n\n        error_setg(errp,\n\n                   \"You must specify either 'shm', 'chardev' or 'x-memdev'\");\n\n        return;\n\n    }\n\n\n\n    if (s->hostmem) {\n\n        MemoryRegion *mr;\n\n\n\n        if (s->sizearg) {\n\n            g_warning(\"size argument ignored with hostmem\");\n\n        }\n\n\n\n        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);\n\n        s->ivshmem_size = memory_region_size(mr);\n\n    } else if (s->sizearg == NULL) {\n\n        s->ivshmem_size = 4 << 20; /* 4 MB default */\n\n    } else {\n\n        char *end;\n\n        int64_t size = qemu_strtosz(s->sizearg, &end);\n\n        if (size < 0 || *end != '\\0' || !is_power_of_2(size)) {\n\n            error_setg(errp, \"Invalid size %s\", s->sizearg);\n\n            return;\n\n        }\n\n        s->ivshmem_size = size;\n\n    }\n\n\n\n    /* IRQFD requires MSI */\n\n    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&\n\n        !ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n        error_setg(errp, \"ioeventfd/irqfd requires MSI\");\n\n        return;\n\n    }\n\n\n\n    /* check that role is reasonable */\n\n    if (s->role) {\n\n        if (strncmp(s->role, \"peer\", 5) == 0) {\n\n            s->role_val = IVSHMEM_PEER;\n\n        } else if (strncmp(s->role, \"master\", 7) == 0) {\n\n            s->role_val = IVSHMEM_MASTER;\n\n        } else {\n\n            error_setg(errp, \"'role' must be 'peer' or 'master'\");\n\n            return;\n\n        }\n\n    } else {\n\n        s->role_val = IVSHMEM_MASTER; /* default */\n\n    }\n\n\n\n    pci_conf = dev->config;\n\n    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;\n\n\n\n    /*\n\n     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a\n\n     * bald-faced lie then.  But it's a backwards compatible lie.\n\n     */\n\n    pci_config_set_interrupt_pin(pci_conf, 1);\n\n\n\n    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,\n\n                          \"ivshmem-mmio\", IVSHMEM_REG_BAR_SIZE);\n\n\n\n    /* region for registers*/\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     &s->ivshmem_mmio);\n\n\n\n    memory_region_init(&s->bar, OBJECT(s), \"ivshmem-bar2-container\", s->ivshmem_size);\n\n    if (s->ivshmem_64bit) {\n\n        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;\n\n    }\n\n\n\n    if (s->hostmem != NULL) {\n\n        MemoryRegion *mr;\n\n\n\n        IVSHMEM_DPRINTF(\"using hostmem\\n\");\n\n\n\n        mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),\n\n                                            &error_abort);\n\n        vmstate_register_ram(mr, DEVICE(s));\n\n        memory_region_add_subregion(&s->bar, 0, mr);\n\n        pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);\n\n    } else if (s->server_chr != NULL) {\n\n        /* FIXME do not rely on what chr drivers put into filename */\n\n        if (strncmp(s->server_chr->filename, \"unix:\", 5)) {\n\n            error_setg(errp, \"chardev is not a unix client socket\");\n\n            return;\n\n        }\n\n\n\n        /* if we get a UNIX socket as the parameter we will talk\n\n         * to the ivshmem server to receive the memory region */\n\n\n\n        IVSHMEM_DPRINTF(\"using shared memory server (socket = %s)\\n\",\n\n                        s->server_chr->filename);\n\n\n\n        if (ivshmem_setup_interrupts(s) < 0) {\n\n            error_setg(errp, \"failed to initialize interrupts\");\n\n            return;\n\n        }\n\n\n\n        /* we allocate enough space for 16 peers and grow as needed */\n\n        resize_peers(s, 16);\n\n        s->vm_id = -1;\n\n\n\n        pci_register_bar(dev, 2, attr, &s->bar);\n\n\n\n        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,\n\n                              ivshmem_check_version, NULL, s);\n\n    } else {\n\n        /* just map the file immediately, we're not using a server */\n\n        int fd;\n\n\n\n        IVSHMEM_DPRINTF(\"using shm_open (shm object = %s)\\n\", s->shmobj);\n\n\n\n        /* try opening with O_EXCL and if it succeeds zero the memory\n\n         * by truncating to 0 */\n\n        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {\n\n           /* truncate file to length PCI device's memory */\n\n            if (ftruncate(fd, s->ivshmem_size) != 0) {\n\n                error_report(\"could not truncate shared file\");\n\n            }\n\n\n\n        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {\n\n            error_setg(errp, \"could not open shared file\");\n\n            return;\n\n        }\n\n\n\n        if (check_shm_size(s, fd, errp) == -1) {\n\n            return;\n\n        }\n\n\n\n        create_shared_memory_BAR(s, fd, attr, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n    }\n\n\n\n    fifo8_create(&s->incoming_fifo, sizeof(int64_t));\n\n\n\n    if (s->role_val == IVSHMEM_PEER) {\n\n        error_setg(&s->migration_blocker,\n\n                   \"Migration is disabled when using feature 'peer mode' in device 'ivshmem'\");\n\n        migrate_add_blocker(s->migration_blocker);\n\n    }\n\n}\n", "idx": 2649, "substitutes": {"dev": ["gu", "driver", "mod", "serial", "dd", "error", "device", "def", "de", "fi", "grad", "conf", "debug", "mem", "d", "cam", "w", "pub", "prom", "conn", "data", "pro", "ev", "server", "Dev", "devices", "reg", "di", "info", "ch", "phy", "proc", "dem", "ver", "rad", "priv", "hw", "dom"], "errp": ["arrps", "errorf", "errr", "errpre", " errf", "reqP", "errorP", "armpe", "rrping", "erP", "errpe", "errfp", "errps", "errP", "reqp", "erfp", "errb", "rrfp", "armP", "innerp", "arrping", "armp", "armf", "reqpre", "erp", "rrP", "errorr", "reqpe", "armpre", " errP", "rrf", "rrpe", "errorfp", "errping", "innerps", "arrp", "innerb", "errf", "rrps", " errr", "innerping", "errorp", "rrp", " errfp", "rrb", "arrb", "rrpre", "armr"], "s": ["i", "uns", "sec", "d", "stat", "an", "v", "ps", "secondary", "sb", "ch", "sym", "state", "os", "f", "js", "params", "l", "is", "si", "qs", "o", "p", "less", "ins", "details", "stats", "ses", "site", "args", "b", "sg", "u", "serv", "ops", "sync", "h", "S", "r", "comm", "device", "settings", "hs", "cs", "ssl", "new", "m", "sq", "session", "bs", "w", "service", "g", "us", "spec", "ks", "es", "gs", "t", "aws", "ss", "e", "sl", "ls", "http", "ds", "xs", "fs", "su", "sets", "ts", "ns", "n", "k", "services", "sys", "sf", "c", "rs", "self", "its", "tests"], "err": ["fr", "cache", "cr", "rr", "res", "gr", "ir", "req", "rh", "r", "error", "conf", "er", "Er", "ec", "dr", "ind", "sys", "ar", "rs", "asm", "exc", "ch", "ace", "der", "cfg", "ev", "msg"], "pci_conf": ["pci_conn", "pdi_cfg", "pci_config", "pdi_conf", "pki_\n", "pki__", "pci__", "pci_\n", "pci___", "pdi_conn", "pci_cfg", "pdi_config", "pci__\n"], "mr": ["MR", "fr", "rb", "Mr", "rr", "gr", "nm", "ir", "r", "sr", "pr", "mor", "gor", "attr", "rt", "pm", "mir", "er", "wr", "yr", "mmm", "dr", "adr", "m", "mi", "rf", "vm", "mm", "vr", "rm", "ur", "mt", "shr", "kr", "wm", "hr", "rg", "rs", "nr", "asm", "ru", "mn", "mer", "mc", "rl", "ml", "au", "lr", "bm", "br"], "end": ["offset", "value", "enter", "loc", "scale", "r", "enc", "END", "begin", "nd", "ff", "append", "edge", "z", "id", "sum", "send", "ad", "len", "event", "stop", "pos", "x", "type", "est", "length", "ize", "shape", "c", "url", "after", "start", "ending", "End", "max", "address", "e", "size", "use", "open", "ended", "h", "en", "index"]}}
{"project": "qemu", "commit_id": "ab2b9f174db088633922eaa82c2bcffd84e6bb94", "target": 1, "func": "int print_insn_lm32(bfd_vma memaddr, struct disassemble_info *info)\n\n{\n\n    fprintf_function fprintf_fn = info->fprintf_func;\n\n    void *stream = info->stream;\n\n    int rc;\n\n    uint8_t insn[4];\n\n    const Lm32OpcodeInfo *opc_info;\n\n    uint32_t op;\n\n    const char *args_fmt;\n\n\n\n    rc = info->read_memory_func(memaddr, insn, 4, info);\n\n    if (rc != 0) {\n\n        info->memory_error_func(rc, memaddr, info);\n\n        return -1;\n\n    }\n\n\n\n    fprintf_fn(stream, \"%02x %02x %02x %02x    \",\n\n            insn[0], insn[1], insn[2], insn[3]);\n\n\n\n    op = bfd_getb32(insn);\n\n    opc_info = find_opcode_info(op);\n\n    if (opc_info) {\n\n        fprintf_fn(stream, \"%-8s \", opc_info->name);\n\n        args_fmt = opc_info->args_fmt;\n\n        while (args_fmt && *args_fmt) {\n\n            if (*args_fmt == '%') {\n\n                switch (*(++args_fmt)) {\n\n                case '0': {\n\n                    uint8_t r0;\n\n                    const char *r0_name;\n\n                    r0 = (op >> 21) & 0x1f;\n\n                    r0_name = find_reg_info(r0)->name;\n\n                    fprintf_fn(stream, \"%s\", r0_name);\n\n                    break;\n\n                }\n\n                case '1': {\n\n                    uint8_t r1;\n\n                    const char *r1_name;\n\n                    r1 = (op >> 16) & 0x1f;\n\n                    r1_name = find_reg_info(r1)->name;\n\n                    fprintf_fn(stream, \"%s\", r1_name);\n\n                    break;\n\n                }\n\n                case '2': {\n\n                    uint8_t r2;\n\n                    const char *r2_name;\n\n                    r2 = (op >> 11) & 0x1f;\n\n                    r2_name = find_reg_info(r2)->name;\n\n                    fprintf_fn(stream, \"%s\", r2_name);\n\n                    break;\n\n                }\n\n                case 'c': {\n\n                    uint8_t csr;\n\n                    const char *csr_name;\n\n                    csr = (op >> 21) & 0x1f;\n\n                    csr_name = find_csr_info(csr)->name;\n\n                    if (csr_name) {\n\n                        fprintf_fn(stream, \"%s\", csr_name);\n\n                    } else {\n\n                        fprintf_fn(stream, \"0x%x\", csr);\n\n                    }\n\n                    break;\n\n                }\n\n                case 'u': {\n\n                    uint16_t u16;\n\n                    u16 = op & 0xffff;\n\n                    fprintf_fn(stream, \"0x%x\", u16);\n\n                    break;\n\n                }\n\n                case 's': {\n\n                    int16_t s16;\n\n                    s16 = (int16_t)(op & 0xffff);\n\n                    fprintf_fn(stream, \"%d\", s16);\n\n                    break;\n\n                }\n\n                case 'r': {\n\n                    uint32_t rela;\n\n                    rela = memaddr + (((int16_t)(op & 0xffff)) << 2);\n\n                    fprintf_fn(stream, \"%x\", rela);\n\n                    break;\n\n                }\n\n                case 'R': {\n\n                    uint32_t rela;\n\n                    int32_t imm26;\n\n                    imm26 = (int32_t)((op & 0x3ffffff) << 6) >> 4;\n\n                    rela = memaddr + imm26;\n\n                    fprintf_fn(stream, \"%x\", rela);\n\n                    break;\n\n                }\n\n                case 'h': {\n\n                    uint8_t u5;\n\n                    u5 = (op & 0x1f);\n\n                    fprintf_fn(stream, \"%d\", u5);\n\n                    break;\n\n                }\n\n                default:\n\n                    break;\n\n                }\n\n            } else {\n\n                fprintf_fn(stream, \"%c\", *args_fmt);\n\n            }\n\n            args_fmt++;\n\n        }\n\n    } else {\n\n        fprintf_fn(stream, \".word 0x%x\", op);\n\n    }\n\n\n\n    return 4;\n\n}\n", "idx": 2656, "substitutes": {"memaddr": ["memoryaddress", "hwptr", "hwwork", "mempad", " memaddress", "memoryaddr", "hwaddr", "mmaddress", "memptr", "mmptr", "ramaddr", " memptr", "hwaddress", "ramaddress", "memorypad", "memoryptr", "memwork", "memorywork", "mmaddr", "memaddress", "ramptr", " mempad", " memwork", "mmpad"], "info": ["information", "comment", "update", "inf", "offset", "i", "feed", "ui", "Info", "manager", "setup", "io", "buff", "error", "ok", "def", "bug", "fi", "function", "conf", "linux", "o", "alias", "fo", "config", "raf", "name", "id", "buffer", "api", "rf", "import", "handler", "help", "py", "end", "type", "data", "afi", "ami", "inner", "util", "start", "now", "init", "abi", "image", "options", "state", "inter", "gi", "f", "json", "parse", "http", "thin", "entry", "INFO", "source"], "stream": ["draw", "fn", "host", "model", "feed", "view", "loop", "track", "sw", "socket", "transform", "buff", "wave", "sync", "form", "content", "context", "ack", "public", "valid", "stack", "src", "impl", "document", "input", "raw", "thread", "wrapper", "reflect", "buffer", "stage", "w", "method", "engine", "prom", "slice", "platform", "trans", "writer", "data", "window", "console", "row", "server", "output", "port", "forward", "pool", "result", "image", "channel", "hook", "response", "client", "Stream", "resource", "cont", "open", "message", "reader", "progress", "round", "path", "source", "clean"], "rc": ["inf", "rb", "cc", "dc", "rr", "cr", "rh", "loc", "sc", "error", "ac", "ok", "fc", "cmp", "rt", "ack", "bb", "isc", "ras", "ref", "src", "dr", "ct", "xc", " src", " rac", "rog", "abc", "rec", "success", "pc", "roc", "irc", "rin", "ror", "rs", "rg", " RC", "RC", "nc", "auc", "rn", "result", "exc", "oc", "ck", "inc", "rl", "ra", "err", "cur", "bc", "uc", "lc", "anc"], "insn": [" insz", "INSz", "insp", "insns", "insd", "insconn", "issr", "INSp", "incc", "issd", "lsc", "inssn", "inb", " inssn", "lsd", "insr", "insz", "outsd", " insc", "outsc", " insns", " insb", "rsn", "INSsn", "INSne", "incr", "outsn", " insm", "lsns", "INSn", "inz", "ginp", " insp", "rsr", "incd", "insc", "inp", " insconn", "inn", "incp", "lsn", "ginm", "INSns", "incn", "incb", "outsns", "incconn", "insb", "inne", "inc", "inconn", "inm", "ginc", "rsm", " insne", "incm", "issm", "issn", "inns", "insm", "ginn", "insne", "rsd", " insd"], "opc_info": ["opl_Info", "opnc8source", "opc__inf", "opfc_job", "opc_handle", "opc_Info", "opc8source", "opl_info", "opcappname", "opnc_source", "opf_Info", "opnc8name", "opf_info", "opc_id", "opc__source", "opnc8info", "opcACjob", "opf_inf", "opcappisu", "opc_job", "opl_manager", "opnc_info", "opcACInfo", "opnc_name", "opc__info", "opc8info", "opl_num", "opnc8isu", "opc_desc", "opc8name", "opc_num", "opf_id", "opc8isu", "opfc_desc", "opfc_Info", "opc_manager", "opcappinfo", "opc_source", "opcACinfo", "opc__isu", "opxc_info", "opcACdesc", "opxc_handle", "opxc_inf", "opxc_name", "opfc_info", "opc__name", "opc_isu", "opc__handle", "opnc_isu", "opc_inf", "opc_name", "opcappsource"], "op": ["cat", "mod", "dep", "open", "loc", "error", "ok", "hop", "gen", "cmp", "mop", "option", "orb", "o", "lib", "operation", "opt", "p", "ipop", "or", "ic", "apper", "root", "node", "Op", "var", "opus", "obj", "pop", "org", "no", "off", "cp", "format", "type", "co", "prop", "sp", "top", "ype", "spec", "app", "pp", "pre", "oid", "ob", "init", "jp", "omp", "block", "oc", "vert", "proc", "opp", "inc", " Op", "ip", "set", "OP", "post", "oper", "ops", "cop", "bit"], "args_fmt": ["args_confformat", "argsetinfactory", "args_lfMT", "args_infMT", "args_Fmt", "args_frformat", "argsetinfmt", "argspfmt", "argsetfMT", "argsetinfMT", "argsphformat", "args_infactory", "args_ffMT", "args_tactory", "args_tMT", "args_ftm", "args_lfmt", "args_fformat", "args_factory", "args_fnt", "args_formilt", "args_hformat", "args_infwt", "args_formmd", "args_forformat", "args_cfformat", "args_fornt", "args_fmd", "args_forft", "args_fld", "args_confmt", "args_Fld", "args_lfmd", "args_fwt", "args_freft", "args_fatted", "argsetfactory", "args_Fformat", "args_fMT", "args_cfld", "args_formmt", "args_ffmt", "argsetinfwt", "argsphmt", "args_formMT", "args_infmt", "args_frprintf", "args_freilt", "argspftm", "args_frmt", "args_formt", "argsphtm", "args_cfmt", "argsphld", "args_frilt", "args_rfformat", "args_frMT", "args_rfnt", "args_rfreet", "args_rfilt", "args_forprintf", "args_confreet", "args_fratted", "args_Fatted", "args_tmt", "args_forilt", "argspfformat", "args_hmt", "args_rfmt", "argsetfwt", "args_htm", "args_formwt", "args_frent", "args_rfft", "argspfld", "args_lfilt", "args_formactory", "args_confnt", "args_FMT", "args_fft", "args_fprintf", "args_frnt", "args_ffformat", "args_filt", "args_hld", "args_Ftm", "args_twt", "args_freet", "argsetfmt", "args_rfprintf", "args_frmd", "args_ffatted", "args_fremt", "args_cftm"], "r0": ["ar1", "r00", "br48", "pr48", "ar200", "R4", "hr0", "pr00", "R1", "ru1", "sr50", "pr50", "sr00", "r50", "r4", "sr0", " r8", "r48", "br00", "R0", "ar0", "sr2", "R200", "ru200", "sr8", "r200", " r4", "ru0", "br50", "sr4", "pr0", "ru4", "hr4", "ar4", "br0", "r8", "hr2", "sr48", "hr8"], "r0_name": ["r0ADraw", "r0ADnm", "r0_span", "r49_default", "r0_nm", "r96_raw", "r96_name", "r0_raw", "r96ADraw", "r96ADnm", "r49_name", "r0_default", "r2_var", "r0ADname", "r96_nm", "r96ADname", "r0_len", "r2_min", "r96ADla", "r96_la", "r0ADla", "r49_len", "r0_var", "r0_min", "r0_la", "r49_span"], "r1": ["ar1", "lr3", "rw1", "R1", "crone", "sr1", "rAb", "arone", "ar81", "rc1", "rcAb", "rone", "cr1", "rtup", "lr2", "r5", "rcone", "rc81", "r81", "sr2", "R16", "rw16", "cr81", "rw2", "srup", "R3", "r3", "r16", "rw3", "Rup", "R2", "arAb", "rt2", "rt5", "crAb", "lr16", "sr5", "rup", "R5", "lr1", "rt1"], "r1_name": ["r1_cap", "r1Jtext", "r1_info", "r0_text", "r01_info", "r1_none", "r1Jname", "r1_names", "r0_none", "r0_key", "rOne_names", "r1_key", "r1_member", "rOne_cap", "r01_span", "r1Jnone", "r1_span", "r1_text", "r1_size", "r1Jkey", "rOne_name", "rOne_size", "r01_member", "r01_name"], "r2": ["r6", "rc2", "r62", "ar62", "ar2", "ar3", "r92", "rc8", "rg92", "rr2", " r6", "r4", " r8", "sr2", " rtwo", "sr32", "sr6", " r3", "rctwo", "rr92", "r3", "rc3", " r4", "artwo", "ar92", "sr4", "p32", "ar8", " r32", "p6", "rg2", "p2", "rr62", "rtwo", "r8", "r32", "p4", "rg62"], "r2_name": ["r11_name", "r4_value", "r4_name", "r2Jvalue", "r2_n", "rTwo_n", "r2jalias", "rTwo_alias", "r2_Name", "rTwo_Name", "r2Juri", "r2_uri", "r2jName", "r2Jname", "rTwojn", "r2_count", "rTwo_name", "r4_uri", "r2jn", "rTwojalias", "r2_value", "r2_alias", "r11_count", "r2longName", "r2_info", "rTwojname", "r2JName", "r2jname", "rTwojName", "r11_info", "r4_Name", "r2longuri", "r2longname", "r2longvalue"], "csr": ["csrs", "vspr", "vsrb", "csrb", "vsr", "bsrs", "vsrs", "bspr", "cssr", "cspr", "cssrb", "cssrs", "bsrb", "bsr", "csspr"], "csr_name": ["CS\n", "csstring", "ecstring", "ec\n", "ac\n", "cs\n", "acstring", "CSstring"]}}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,\n\n                   uint8_t *properties)\n\n{\n\n    int compno;\n\n\n\n    if (s->buf_end - s->buf < 2)\n\n        return AVERROR(EINVAL);\n\n\n\n    compno = bytestream_get_byte(&s->buf);\n\n\n\n    c      += compno;\n\n    c->csty = bytestream_get_byte(&s->buf);\n\n    get_cox(s, c);\n\n\n\n    properties[compno] |= HAD_COC;\n\n    return 0;\n\n}\n", "idx": 2665, "substitutes": {"s": ["S", "i", "fs", "su", "sets", "sc", "ts", "ns", "settings", "cs", "si", "is", "n", "conf", "ssl", "qs", "o", "p", "src", "d", "m", "sq", "session", "se", "w", "v", "a", "services", "sys", "g", "ps", "us", "server", "ses", "ks", "sf", "spec", "sb", "rs", "self", "es", "gs", "sym", "t", "b", "sg", "f", "u", "os", "this", "ss", "js", "e", "ls", "side", "http", "ds", "sync", "xs"], "c": ["cu", "i", "dc", "cc", "bc", "r", "cy", "sc", "cf", "ac", "l", "cs", "ctx", "code", "n", "icc", "o", "p", "ci", "ic", "ce", "ec", "xc", "d", "m", "config", "z", "w", "k", "count", "v", "pc", "ca", "g", "mc", "oc", "t", "b", "f", "u", "component", "C", "e", "x", "lc"], "properties": ["times", "fixes", "perties", "cases", "comments", "les", "classes", "effects", "settings", "types", "styles", "j", "ctx", "pb", "xml", "p", "ips", "fields", "details", "config", "units", "OPS", "ties", "property", "codes", "ops", "prop", "data", "pro", "ps", "lines", "relations", "chains", "bytes", "options", "phy", "features", "objects", "e", " props", "params", "ies"], "compno": [" comporno", "coldo", " compNO", "procNO", "compnumber", "complo", " compdo", "colto", "compNo", "hostnos", "procno", " compname", "Complo", "compdo", "cmpdo", "coordno", "compnos", "coordNo", "colnumber", " compnone", "coordyes", "Compnumber", "componentlo", " compnumber", "colno", "componentno", "hostorno", "procnos", "componentyes", "compname", "hostNO", "Compno", "procorno", "hostno", " compto", "coordnone", "compNO", "cmpno", "componentNo", " compNo", "compnone", "componentname", "comporno", "compto", " compyes", "componentnone", "cmpto", "compyes", " complo", "Compname", "componentnumber", "cmpnumber", " compnos"]}}
{"project": "qemu", "commit_id": "615220ddaf23db4c5686053257c568b46967e4b5", "target": 1, "func": "static void curses_setup(void)\n\n{\n\n    int i, colour_default[8] = {\n\n        COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN,\n\n        COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE,\n\n    };\n\n\n\n    /* input as raw as possible, let everything be interpreted\n\n     * by the guest system */\n\n    initscr(); noecho(); intrflush(stdscr, FALSE);\n\n    nodelay(stdscr, TRUE); nonl(); keypad(stdscr, TRUE);\n\n    start_color(); raw(); scrollok(stdscr, FALSE);\n\n\n\n    for (i = 0; i < 64; i ++)\n\n        init_pair(i, colour_default[i & 7], colour_default[i >> 3]);\n\n}\n", "idx": 2673, "substitutes": {"i": ["hi", "chi", "ui", "anti", "diff", "io", "r", "l", "fi", "si", "is", "j", "n", "uri", "disk", "o", "p", "ci", "key", "multi", "qi", "d", "m", "oi", "cli", "name", "id", "alpha", "ri", "ii", "slice", "v", "a", "bi", "x", "type", "li", "window", "iu", "length", "ji", "c", "zi", "start", "ix", "ai", "di", "info", "abi", "pi", "mu", "t", "gi", "f", "u", "b", "ti", "ip", "e", "xi", "I", "it", "phi", "h", "index"], "colour_default": ["colour2def", "colour_def", " colour_name", "colour_desc", "colour__list", "colour_list", " colour_master", "colour__master", " colour_desc", "colour2default", " colour_diff", "colour_master", " colour_def", "colour_diff", "colour__def", "colour_name", " colour_list", "colour__default", "colour2name", "colour__diff", "colour2desc", "colour__desc"]}}
{"project": "FFmpeg", "commit_id": "28bf81c90d36a55cf76e2be913c5215ebebf61f2", "target": 1, "func": "static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc)\n\n{\n\n#ifdef HAVE_MMX\n\n\t// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)\n\n    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))\n\n#else\n\n    if(sws_flags != SWS_FAST_BILINEAR)\n\n#endif\n\n    {\n\n    \tRENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);\n\n    }\n\n    else // Fast Bilinear upscale / crap downscale\n\n    {\n\n#ifdef ARCH_X86\n\n#ifdef HAVE_MMX2\n\n\tint i;\n\n\tif(canMMX2BeUsed)\n\n\t{\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"pxor %%mm2, %%mm2\t\t\\n\\t\" // 2*xalpha\n\n\t\t\t\"movd %5, %%mm6\t\t\t\\n\\t\" // xInc&0xFFFF\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"paddw %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"paddw %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\" //0,t,2t,3t\t\tt=xInc&0xFF\n\n\t\t\t\"movq %%mm2, \"MANGLE(temp0)\"\t\\n\\t\"\n\n\t\t\t\"movd %4, %%mm6\t\t\t\\n\\t\" //(xInc*4)&0xFFFF\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"xorl %%eax, %%eax\t\t\\n\\t\" // i\n\n\t\t\t\"movl %0, %%esi\t\t\t\\n\\t\" // src\n\n\t\t\t\"movl %1, %%edi\t\t\t\\n\\t\" // buf1\n\n\t\t\t\"movl %3, %%edx\t\t\t\\n\\t\" // (xInc*4)>>16\n\n\t\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\"\n\n\t\t\t\"xorl %%ebx, %%ebx\t\t\\n\\t\"\n\n\t\t\t\"movw %4, %%bx\t\t\t\\n\\t\" // (xInc*4)&0xFFFF\n\n\n\n#define FUNNY_Y_CODE \\\n\n\t\t\tPREFETCH\" 1024(%%esi)\t\t\\n\\t\"\\\n\n\t\t\tPREFETCH\" 1056(%%esi)\t\t\\n\\t\"\\\n\n\t\t\tPREFETCH\" 1088(%%esi)\t\t\\n\\t\"\\\n\n\t\t\t\"call \"MANGLE(funnyYCode)\"\t\\n\\t\"\\\n\n\t\t\t\"movq \"MANGLE(temp0)\", %%mm2\t\\n\\t\"\\\n\n\t\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\"\n\n\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\n\n\n\t\t\t:: \"m\" (src), \"m\" (dst), \"m\" (dstWidth), \"m\" ((xInc*4)>>16),\n\n\t\t\t\"m\" ((xInc*4)&0xFFFF), \"m\" (xInc&0xFFFF)\n\n\t\t\t: \"%eax\", \"%ebx\", \"%ecx\", \"%edx\", \"%esi\", \"%edi\"\n\n\t\t);\n\n\t\tfor(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128;\n\n\t}\n\n\telse\n\n\t{\n\n#endif\n\n\t//NO MMX just normal asm ...\n\n\tasm volatile(\n\n\t\t\"xorl %%eax, %%eax\t\t\\n\\t\" // i\n\n\t\t\"xorl %%ebx, %%ebx\t\t\\n\\t\" // xx\n\n\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\" // 2*xalpha\n\n\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movzbl  (%0, %%ebx), %%edi\t\\n\\t\" //src[xx]\n\n\t\t\"movzbl 1(%0, %%ebx), %%esi\t\\n\\t\" //src[xx+1]\n\n\t\t\"subl %%edi, %%esi\t\t\\n\\t\" //src[xx+1] - src[xx]\n\n\t\t\"imull %%ecx, %%esi\t\t\\n\\t\" //(src[xx+1] - src[xx])*2*xalpha\n\n\t\t\"shll $16, %%edi\t\t\\n\\t\"\n\n\t\t\"addl %%edi, %%esi\t\t\\n\\t\" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)\n\n\t\t\"movl %1, %%edi\t\t\t\\n\\t\"\n\n\t\t\"shrl $9, %%esi\t\t\t\\n\\t\"\n\n\t\t\"movw %%si, (%%edi, %%eax, 2)\t\\n\\t\"\n\n\t\t\"addw %4, %%cx\t\t\t\\n\\t\" //2*xalpha += xInc&0xFF\n\n\t\t\"adcl %3, %%ebx\t\t\t\\n\\t\" //xx+= xInc>>8 + carry\n\n\n\n\t\t\"movzbl (%0, %%ebx), %%edi\t\\n\\t\" //src[xx]\n\n\t\t\"movzbl 1(%0, %%ebx), %%esi\t\\n\\t\" //src[xx+1]\n\n\t\t\"subl %%edi, %%esi\t\t\\n\\t\" //src[xx+1] - src[xx]\n\n\t\t\"imull %%ecx, %%esi\t\t\\n\\t\" //(src[xx+1] - src[xx])*2*xalpha\n\n\t\t\"shll $16, %%edi\t\t\\n\\t\"\n\n\t\t\"addl %%edi, %%esi\t\t\\n\\t\" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)\n\n\t\t\"movl %1, %%edi\t\t\t\\n\\t\"\n\n\t\t\"shrl $9, %%esi\t\t\t\\n\\t\"\n\n\t\t\"movw %%si, 2(%%edi, %%eax, 2)\t\\n\\t\"\n\n\t\t\"addw %4, %%cx\t\t\t\\n\\t\" //2*xalpha += xInc&0xFF\n\n\t\t\"adcl %3, %%ebx\t\t\t\\n\\t\" //xx+= xInc>>8 + carry\n\n\n\n\n\n\t\t\"addl $2, %%eax\t\t\t\\n\\t\"\n\n\t\t\"cmpl %2, %%eax\t\t\t\\n\\t\"\n\n\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\n\n\n\n\t\t:: \"r\" (src), \"m\" (dst), \"m\" (dstWidth), \"m\" (xInc>>16), \"m\" (xInc&0xFFFF)\n\n\t\t: \"%eax\", \"%ebx\", \"%ecx\", \"%edi\", \"%esi\"\n\n\t\t);\n\n#ifdef HAVE_MMX2\n\n\t} //if MMX2 cant be used\n\n#endif\n\n#else\n\n\tint i;\n\n\tunsigned int xpos=0;\n\n\tfor(i=0;i<dstWidth;i++)\n\n\t{\n\n\t\tregister unsigned int xx=xpos>>16;\n\n\t\tregister unsigned int xalpha=(xpos&0xFFFF)>>9;\n\n\t\tdst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;\n\n\t\txpos+=xInc;\n\n\t}\n\n#endif\n\n    }\n\n}\n", "idx": 2677, "substitutes": {"dst": [" dsl", "fST", "Dsrc", "dbl", "Dsts", "cdsp", "sdrc", "fbl", "drc", "ssts", "Dst", "dsts", "ssrc", "sst", " dST", "cdST", "lsts", "dsl", "idsp", "Drc", "cdst", "lst", "dsrc", "sdst", "cdbl", "dsp", "sdsts", "idST", "idbl", "fst", "fsp", "sdsrc", "lsl", "dST", "idst", "Dsl", "DST", " dsts", "lST"], "dstWidth": ["dspHeight", "drcSize", "DstHeight", "dstW", "dscLength", "dblHeight", "dspwidth", " dstwidth", "DSTwidth", " dSTLength", "dSTwidth", "dblWidth", "dblLength", " dstSize", "DstW", "dscW", " drcHeight", "DSTSize", "dscHeight", "dblSize", "drcwidth", "dsrcWidth", "dconstLength", "dconstSize", "dconstWidth", "dscSize", "DstWidth", "dsrcHeight", "DSTWidth", "dSTHeight", "dSTW", "dSTSize", "dconstwidth", " drcSize", " dSTHeight", " dstHeight", " dstLength", " dSTwidth", "DstSize", " dSTWidth", "dstSize", "dspW", "drcHeight", "DSTW", "Dstwidth", "drcLength", "dspWidth", "DSTLength", "dstwidth", "dscWidth", "dsrcwidth", "dstHeight", "DstLength", "dSTLength", "dSTWidth", " drcWidth", "drcWidth", "dstLength", "dsrcLength", "DSTHeight", " drcLength", "dscwidth"], "src": ["inf", "rb", "sur", "loc", "sr", "sc", "inst", "secure", "attr", "rc", "sub", "fps", "img", "ctx", "filename", "conv", "sel", "st", "lib", "ipl", "SOURCE", "config", "sq", "buf", "rss", "rest", "stat", "slice", "ruby", "asc", "gz", "dest", "feat", "SourceFile", "rin", "rib", "include", "spec", "rs", "url", "RC", "gb", "Source", "sl", "ls", "sup", "sync", "seq", "source", "jpg"], "srcW": ["instH", "destW", " srcH", " srcL", " srcM", "instWidth", "sthH", "instL", "sthW", "srcL", "destWidth", "destH", "sourceM", "sourceW", " srcWidth", "sthM", "sourceWidth", "srcWidth", "sourceH", "instW", "srcH", "srcM", "destL", "sthWidth"], "xInc": ["yInc", " xExp", "contentInst", "fxIncre", "xExp", "contentInc", "xMin", "contentInit", "fxInc", "ixInit", "xDec", "xInit", "XInc", "ixExp", "yINC", "sexInc", "yMin", "sexExc", " xIncre", "XExc", "xInst", "contentExc", "yExc", " xDec", "fxDec", "yIncre", "xExc", " xInst", "sexIncre", "ixinc", "xSec", "sexSec", "XMin", "XINC", " xInit", "XIncre", "yExp", "XDec", "XExp", " xINC", "XSec", " xSec", " xMin", "xINC", "ixInc", " xinc", "xIncre", "XInst", "XInit", " xExc", "fxExc", "yinc", "xinc", "Xinc"], "i": ["ui", "io", "l", "fi", "is", "j", "n", "o", "p", "ci", "qi", "d", "m", "id", "z", "ion", "ii", "on", "v", "a", "bi", "x", "mini", "li", "g", "iu", "ie", "ji", "c", "in", "zi", "ix", "ai", "pi", "b", "f", "u", "gi", "ti", "ip", "ni", "e", "xi", "I", "it", "phi", "index"], "FUNNY_Y_CODE": ["FUNNY_Y_CTE", "FUNNY_Y_SCONE", "FUNNY_YADSCORE", "FUNNY_Y_ERCode", "FUNNY_Y_ACODE", "FUNNY_Y_Fode", "FUNNY_YAMCLodes", "FUNNY_Y_LODE", "FUNNY_YADCOME", "FUNNY_YAMCLATE", "FUNNY_Y_SCOME", "FUNNY_Y2CIDE", "FUNNY_YOPVCodes", "FUNNY_Y_CPE", "FUNNY_YADSCTE", "FUNNY_Y2ACodes", "FUNNY_Y_ECONE", "FUNNY_YADSCATE", "FUNNY_Y_Fodes", "FUNNY_Y_SCAME", "FUNNY_Y_ECATE", "FUNNY_Y_LCOD", "FUNNY_Y_Hodes", "FUNNY_Y_BCODE", "FUNNY_Y_SCOD", "FUNNY_Y_LCODE", "FUNNY_Y_VCode", "FUNNY_Y_VCATE", "FUNNY_Y2ERCODE", "FUNNY_YAMCATE", "FUNNY_Y_VCodes", "FUNNY_Y_SCATE", "FUNNY_Y2ACATE", "FUNNY_Y_Lodes", "FUNNY_Y_LCPE", "FUNNY_Y_LATE", "FUNNY_Y_SCTE", "FUNNY_YOPVCode", "FUNNY_Y_KODE", "FUNNY_Y_LOME", "FUNNY_Y_HODE", "FUNNY_Y_ERCSE", "FUNNY_YAMCLAME", "FUNNY_YADCORE", "FUNNY_Y_FODE", "FUNNY_Y2CATE", "FUNNY_Y_ERCPE", "FUNNY_Y2CSE", "FUNNY_Y_Codes", "FUNNY_YADCODE", "FUNNY_Y_ACATE", "FUNNY_Y_COD", "FUNNY_Y2Codes", "FUNNY_Y_HOME", "FUNNY_Y_SCODE", "FUNNY_YADCCE", "FUNNY_YOPVCATE", "FUNNY_Y2ACIDE", "FUNNY_YAMCAME", "FUNNY_Y_SCode", "FUNNY_Y_ERCATE", "FUNNY_Y_ACodes", "FUNNY_Y_ERCAME", "FUNNY_Y_ECodes", "FUNNY_YADSCODE", "FUNNY_Y_VCODE", "FUNNY_Y_OCODE", "FUNNY_Y2CPE", "FUNNY_Y_SCodes", "FUNNY_Y_BCATE", "FUNNY_Y_CLATE", "FUNNY_Y_ACCE", "FUNNY_Y_HATE", "FUNNY_YAMCLODE", "FUNNY_Y_SCORE", "FUNNY_Y_ECIDE", "FUNNY_Y_ECOD", "FUNNY_Y_CAME", "FUNNY_YOPCode", "FUNNY_Y2ERCSE", "FUNNY_Y_LCTE", "FUNNY_Y_OCATE", "FUNNY_Y_ACORE", "FUNNY_YAMCODE", "FUNNY_Y2Code", "FUNNY_Y_FATE", "FUNNY_YOPCATE", "FUNNY_YOPCodes", "FUNNY_Y_LCSE", "FUNNY_Y_CATE", "FUNNY_YADCOD", "FUNNY_Y_CIDE", "FUNNY_YOPVCODE", "FUNNY_YADCodes", "FUNNY_Y_ECODE", "FUNNY_Y_Kode", "FUNNY_Y_ERCODE", "FUNNY_Y_LTE", "FUNNY_YADSCCE", "FUNNY_YADSCOME", "FUNNY_Y_CLODE", "FUNNY_Y_KPE", "FUNNY_Y_COME", "FUNNY_Y2ACODE", "FUNNY_Y_ECTE", "FUNNY_Y_Code", "FUNNY_YADSCOD", "FUNNY_YOPCODE", "FUNNY_Y_BCCE", "FUNNY_YADCATE", "FUNNY_YAMCodes", "FUNNY_Y_CLAME", "FUNNY_Y_LONE", "FUNNY_Y_CSE", "FUNNY_YADSCodes", "FUNNY_Y_CLodes", "FUNNY_Y_CCE", "FUNNY_Y_CORE", "FUNNY_Y_LCode", "FUNNY_Y_BCORE", "FUNNY_Y_KSE", "FUNNY_YADCTE", "FUNNY_Y_CONE", "FUNNY_Y2ERCPE", "FUNNY_Y2CODE", "FUNNY_Y_ERCodes", "FUNNY_Y_LCATE", "FUNNY_Y_SCIDE", "FUNNY_Y_ACIDE", "FUNNY_Y_OCONE", "FUNNY_Y_SCCE", "FUNNY_Y2ERCode"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint16_t *v = pv;\n\n    uint16_t v2;\n\n    qemu_get_be16s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n    }\n\n    return -EINVAL;\n\n}\n", "idx": 2680, "substitutes": {"f": ["fr", "i", "fs", "buff", "r", "l", "n", "o", "p", "fp", "ref", "d", "m", "fat", "rf", "w", "elf", "df", "fen", "a", "file", "fd", "g", "fw", "c", "self", "fa", "lf", "info", "fx", "t", "b", "e", "x", "F", "h"], "pv": ["Psv", "lpV", "ppV", "ppv", "psv", " pV", "pvt", " psv", "PV", "pV", "lpvt", " pf", "Pv", "lpf", "ppsv", " pvt", "pf", "lpv", "ppf", "Pvt", "Pf"], "size": ["i", "l", "si", "sec", "m", "z", "w", "k", "len", "fe", "g", "length", "ize", "shape", "c", "small", " sizes", "ss", " Size", "e", "ffff", "SIZE", "Size", "h"], "v": ["val", "i", "vt", "sv", "l", "j", "n", "y", "o", "ve", "p", "d", "m", "V", "w", "volt", "k", "g", "c", "vp", "vi", "t", "b", "u", "q", "e", "x", "h", "volume", "s", "nv"], "v2": ["vii", "iii", "vtwo", "V2", "i2", "p1", " vii", "cv1", "pii", "V1", "i1", "itwo", "Vtwo", " v1", "p2", "cvtwo", "ptwo", "v1", "cv2", " vtwo"]}}
{"project": "FFmpeg", "commit_id": "c5f15f40b9b25f033fd9e8dd1e12763913098c11", "target": 1, "func": "static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data,\n\n                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n\n                              const uint8_t *buf, int len, uint16_t seq,\n\n                              int flags)\n\n{\n\n    uint8_t nal;\n\n    uint8_t type;\n\n    int result = 0;\n\n\n\n    if (!len) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Empty H264 RTP packet\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    nal  = buf[0];\n\n    type = nal & 0x1f;\n\n\n\n    assert(data);\n\n    assert(buf);\n\n\n\n    /* Simplify the case (these are all the nal types used internally by\n\n     * the h264 codec). */\n\n    if (type >= 1 && type <= 23)\n\n        type = 1;\n\n    switch (type) {\n\n    case 0:                    // undefined, but pass them through\n\n    case 1:\n\n        av_new_packet(pkt, len + sizeof(start_sequence));\n\n        memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n\n        memcpy(pkt->data + sizeof(start_sequence), buf, len);\n\n        COUNT_NAL_TYPE(data, nal);\n\n        break;\n\n\n\n    case 24:                   // STAP-A (one packet, multiple nals)\n\n        // consume the STAP-A NAL\n\n        buf++;\n\n        len--;\n\n        // first we are going to figure out the total size\n\n        {\n\n            int pass         = 0;\n\n            int total_length = 0;\n\n            uint8_t *dst     = NULL;\n\n\n\n            for (pass = 0; pass < 2; pass++) {\n\n                const uint8_t *src = buf;\n\n                int src_len        = len;\n\n\n\n                while (src_len > 2) {\n\n                    uint16_t nal_size = AV_RB16(src);\n\n\n\n                    // consume the length of the aggregate\n\n                    src     += 2;\n\n                    src_len -= 2;\n\n\n\n                    if (nal_size <= src_len) {\n\n                        if (pass == 0) {\n\n                            // counting\n\n                            total_length += sizeof(start_sequence) + nal_size;\n\n                        } else {\n\n                            // copying\n\n                            assert(dst);\n\n                            memcpy(dst, start_sequence, sizeof(start_sequence));\n\n                            dst += sizeof(start_sequence);\n\n                            memcpy(dst, src, nal_size);\n\n                            COUNT_NAL_TYPE(data, *src);\n\n                            dst += nal_size;\n\n                        }\n\n                    } else {\n\n                        av_log(ctx, AV_LOG_ERROR,\n\n                               \"nal size exceeds length: %d %d\\n\", nal_size, src_len);\n\n                    }\n\n\n\n                    // eat what we handled\n\n                    src     += nal_size;\n\n                    src_len -= nal_size;\n\n\n\n                    if (src_len < 0)\n\n                        av_log(ctx, AV_LOG_ERROR,\n\n                               \"Consumed more bytes than we got! (%d)\\n\", src_len);\n\n                }\n\n\n\n                if (pass == 0) {\n\n                    /* now we know the total size of the packet (with the\n\n                     * start sequences added) */\n\n                    av_new_packet(pkt, total_length);\n\n                    dst = pkt->data;\n\n                } else {\n\n                    assert(dst - pkt->data == total_length);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 25:                   // STAP-B\n\n    case 26:                   // MTAP-16\n\n    case 27:                   // MTAP-24\n\n    case 29:                   // FU-B\n\n        av_log(ctx, AV_LOG_ERROR,\n\n               \"Unhandled type (%d) (See RFC for implementation details\\n\",\n\n               type);\n\n        result = AVERROR(ENOSYS);\n\n        break;\n\n\n\n    case 28:                   // FU-A (fragmented nal)\n\n        buf++;\n\n        len--;                 // skip the fu_indicator\n\n        if (len > 1) {\n\n            // these are the same as above, we just redo them here for clarity\n\n            uint8_t fu_indicator      = nal;\n\n            uint8_t fu_header         = *buf;\n\n            uint8_t start_bit         = fu_header >> 7;\n\n            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;\n\n            uint8_t nal_type          = fu_header & 0x1f;\n\n            uint8_t reconstructed_nal;\n\n\n\n            // Reconstruct this packet's true nal; only the data follows.\n\n            /* The original nal forbidden bit and NRI are stored in this\n\n             * packet's nal. */\n\n            reconstructed_nal  = fu_indicator & 0xe0;\n\n            reconstructed_nal |= nal_type;\n\n\n\n            // skip the fu_header\n\n            buf++;\n\n            len--;\n\n\n\n            if (start_bit)\n\n                COUNT_NAL_TYPE(data, nal_type);\n\n            if (start_bit) {\n\n                /* copy in the start sequence, and the reconstructed nal */\n\n                av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len);\n\n                memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n\n                pkt->data[sizeof(start_sequence)] = reconstructed_nal;\n\n                memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), buf, len);\n\n            } else {\n\n                av_new_packet(pkt, len);\n\n                memcpy(pkt->data, buf, len);\n\n            }\n\n        } else {\n\n            av_log(ctx, AV_LOG_ERROR, \"Too short data for FU-A H264 RTP packet\\n\");\n\n            result = AVERROR_INVALIDDATA;\n\n        }\n\n        break;\n\n\n\n    case 30:                   // undefined\n\n    case 31:                   // undefined\n\n    default:\n\n        av_log(ctx, AV_LOG_ERROR, \"Undefined type (%d)\\n\", type);\n\n        result = AVERROR_INVALIDDATA;\n\n        break;\n\n    }\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n    return result;\n\n}\n", "idx": 2704, "substitutes": {"ctx": ["cc", "pkg", "req", "loc", "sc", "cf", "rc", "cpp", "context", "ack", "cmp", "conv", "cca", "vc", "fp", "ci", "exec", "xc", "ct", "config", "cam", "cli", "lex", "qa", "Context", "sci", "cv", "cp", "lc", "conn", "ca", "ann", "cn", "c", "ctrl", "util", "jp", "kt", "cb", "tx", "crit", "ck", "la", "wcs", "cmd", "cl", "hw", "na", "client", "bc", "ux", "cas", "sync", "cm", "anc"], "data": ["pkg", "database", "req", "grad", "d", "bus", "window", "parent", "results", "la", "proc", "DATA", "bc", "media", "done", "p", "exec", "config", "append", "dat", "buffer", "load", "pos", "response", "client", "open", "bytes", "next", "shift", "Data", "context", "code", "write", "session", "queue", "slice", "pad", "stream", "loader", "conn", "batch", "length", "reg", "read", "final", "empty", "ds", "last", "source", "val", "cache", "def", "img", "connection", "input", "first", "id", "memory", "api", "master", "aa", "class", "end", "a", "body", "start", "result", "tx", "align", "da", "reader", "record", "content"], "st": ["ost", "sth", "inst", "sc", "pt", "nd", "stack", "St", "sta", "stage", "rest", "sa", "ut", "rd", "est", "str", "ST", "capt", "ast", "sb", "nt", "start", "std", "sts", "ss", "ct"], "pkt": ["bqt", " pst", "pet", "Pct", "cpeth", " pqt", "Pkt", "Pst", "packet", "Pqt", "cpacket", "pct", "Packet", "beth", "cpct", "pqt", "cst", " pck", "bkt", "backet", "cacket", " packet", " pct", "pck", "Pet", "cpkt", "Peth", "bet", "ckt", "bct", "Pck", "peth", "cpqt", "cck", " pet", "pst"], "timestamp": ["typence", "timence", "typestamp", "timeestamp", "payestamp", "timestr", "timend", "timeence", "timeend", "payence", "payend", "timstr", "paystr", "typend", "typstr"], "buf": ["rb", "cache", "text", "pkg", "buff", "cf", "rc", "cmp", "context", "pb", "bb", "fi", "array", "conv", "prot", "begin", "fp", "tmp", "ref", "mem", "ff", "config", "queue", "limit", "buffer", "Buffer", "vec", "hl", "fb", "orig", "pad", "cv", "cp", "pos", "fd", "feat", "dest", "batch", "window", "uf", "txt", "callback", "port", "bag", "pool", "bh", "result", "cb", "cap", "la", "proc", "bin", "b", "cmd", "box", "wb", "uint", "aux", "ctr", "bc", "cas", "uc", "br"], "len": ["fn", "line", "val", "offset", "all", "loc", "en", "l", "low", "n", "lim", "dl", "lon", "num", "elt", "lin", "fin", "fl", "mem", "lang", "split", "delay", "rev", "limit", "ln", "z", "partial", "vec", "hl", "slice", "count", "Len", "full", "end", "pos", "el", "fd", "li", "lan", "length", "il", "fun", "nt", "body", "pre", "ll", "lf", "channel", "la", "bin", "f", "tail", "size", "sl", "bytes", "lvl", "lc"], "seq": ["val", "req", "gen", "code", "unit", "sec", "num", " sequence", "ref", "config", "queue", "sequence", "name", "buffer", "vec", "qa", "count", "frame", "pos", "format", "nc", "cb", "pack", "cl", "version", "cas", "desc"], "flags": ["mask", "lag", "prot", "cs", "types", "flag", "bits", "ips", "ff", "ints", "rows", "status", "format", "stats", "pos", "fd", "vals", "ats", "bytes", "options", "cb", "reads", "version", "Flags", "ls", "ops", "ffff", "bit"], "nal": ["nanatal", " nalis", "rnbal", "gnaval", "nbal", "rnaler", "nanal", "nmal", "pnAL", "anmal", "ynbal", " nbal", "gnatal", "pnals", "nals", "natal", "nAL", "rnal", " nmal", "anAL", " naval", "gnals", "Natal", "nalis", "gnal", "pnmal", " naler", "Nals", "nanalis", " nals", "Naval", "Nal", "anal", "ynAL", "naler", "Nalis", " natal", "naval", "nanals", "pnal", "ynaler", "rnAL", "ynal", " nAL", "anals"], "type": ["comment", "action", "phase", "part", "value", "base", "sort", "error", "types", "code", "unit", "y", "kind", "p", "valid", "ref", "new", "key", "typ", "name", "id", "trial", "time", "pe", "mode", "count", "class", "event", "py", "format", "pos", "year", "position", "parent", "ype", "length", "shape", "port", "Type", "ping", "info", "block", "like", "state", "style", "t", "op", "version", "ver", "TYPE", "x", "ty", "bit", "tag", "index"], "dst": [" dost", "dost", "adst", "dbl", "Dsts", " dset", "Dste", "dste", "rdst", "ssts", " dsc", "rdST", "sdset", "dsts", "adsts", "idsc", "dsc", "dset", "sdost", "sst", " dST", "adbl", "Dsc", "rdsts", "adsc", "rdsc", "Dbl", "sdst", "ssc", "sdsts", "Dost", "adset", "idST", "idbl", "idste", "Dset", "sST", "idost", "dST", "adste", "idst", "Dst", "DST", " dsts"], "pass": ["loop", "feed", "view", "fail", "loss", "scan", "ose", "r", "password", "sc", "def", "gen", "code", " bypass", "act", "strip", "name", "win", "access", "stage", "miss", "ride", "step", "qa", "ress", "run", "slice", "skip", "mode", "catch", "ass", "pos", "allow", "PASS", "prop", "row", "day", "secret", "port", "Pass", "test", "flow", "proc", "level", "cess", "pack", "push", "post", "parse", "use", "pull", "cas", "path"], "src": ["gl", "dist", "rb", "sur", "supp", "scan", "req", "loc", "sr", "sc", "attr", "secure", "select", "rc", "sub", "cmp", "inst", "img", "uri", "filename", "ssl", "sel", "config", "sq", "access", "rss", "sn", "rest", "slice", "stream", "dest", "feat", "rib", "length", "spec", "rs", "url", "ser", "ource", "flash", "RC", "start", "cb", "proc", "rob", "serv", "cur", "uc", "size", "sl", "sup", "sync", "source", "desc"]}}
{"project": "qemu", "commit_id": "4cdd01d32ee6fe04f8d909bfd3708be6864873a2", "target": 0, "func": "void bdrv_refresh_filename(BlockDriverState *bs)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    QDict *opts;\n\n\n\n    if (!drv) {\n\n        return;\n\n    }\n\n\n\n    /* This BDS's file name will most probably depend on its file's name, so\n\n     * refresh that first */\n\n    if (bs->file) {\n\n        bdrv_refresh_filename(bs->file->bs);\n\n    }\n\n\n\n    if (drv->bdrv_refresh_filename) {\n\n        /* Obsolete information is of no use here, so drop the old file name\n\n         * information before refreshing it */\n\n        bs->exact_filename[0] = '\\0';\n\n        if (bs->full_open_options) {\n\n            QDECREF(bs->full_open_options);\n\n            bs->full_open_options = NULL;\n\n        }\n\n\n\n        drv->bdrv_refresh_filename(bs);\n\n    } else if (bs->file) {\n\n        /* Try to reconstruct valid information from the underlying file */\n\n        bool has_open_options;\n\n\n\n        bs->exact_filename[0] = '\\0';\n\n        if (bs->full_open_options) {\n\n            QDECREF(bs->full_open_options);\n\n            bs->full_open_options = NULL;\n\n        }\n\n\n\n        opts = qdict_new();\n\n        has_open_options = append_open_options(opts, bs);\n\n\n\n        /* If no specific options have been given for this BDS, the filename of\n\n         * the underlying file should suffice for this one as well */\n\n        if (bs->file->bs->exact_filename[0] && !has_open_options) {\n\n            strcpy(bs->exact_filename, bs->file->bs->exact_filename);\n\n        }\n\n        /* Reconstructing the full options QDict is simple for most format block\n\n         * drivers, as long as the full options are known for the underlying\n\n         * file BDS. The full options QDict of that file BDS should somehow\n\n         * contain a representation of the filename, therefore the following\n\n         * suffices without querying the (exact_)filename of this BDS. */\n\n        if (bs->file->bs->full_open_options) {\n\n            qdict_put_obj(opts, \"driver\",\n\n                          QOBJECT(qstring_from_str(drv->format_name)));\n\n            QINCREF(bs->file->bs->full_open_options);\n\n            qdict_put_obj(opts, \"file\",\n\n                          QOBJECT(bs->file->bs->full_open_options));\n\n\n\n            bs->full_open_options = opts;\n\n        } else {\n\n            QDECREF(opts);\n\n        }\n\n    } else if (!bs->full_open_options && qdict_size(bs->options)) {\n\n        /* There is no underlying file BDS (at least referenced by BDS.file),\n\n         * so the full options QDict should be equal to the options given\n\n         * specifically for this block device when it was opened (plus the\n\n         * driver specification).\n\n         * Because those options don't change, there is no need to update\n\n         * full_open_options when it's already set. */\n\n\n\n        opts = qdict_new();\n\n        append_open_options(opts, bs);\n\n        qdict_put_obj(opts, \"driver\",\n\n                      QOBJECT(qstring_from_str(drv->format_name)));\n\n\n\n        if (bs->exact_filename[0]) {\n\n            /* This may not work for all block protocol drivers (some may\n\n             * require this filename to be parsed), but we have to find some\n\n             * default solution here, so just include it. If some block driver\n\n             * does not support pure options without any filename at all or\n\n             * needs some special format of the options QDict, it needs to\n\n             * implement the driver-specific bdrv_refresh_filename() function.\n\n             */\n\n            qdict_put_obj(opts, \"filename\",\n\n                          QOBJECT(qstring_from_str(bs->exact_filename)));\n\n        }\n\n\n\n        bs->full_open_options = opts;\n\n    }\n\n\n\n    if (bs->exact_filename[0]) {\n\n        pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename);\n\n    } else if (bs->full_open_options) {\n\n        QString *json = qobject_to_json(QOBJECT(bs->full_open_options));\n\n        snprintf(bs->filename, sizeof(bs->filename), \"json:%s\",\n\n                 qstring_get_str(json));\n\n        QDECREF(json);\n\n    }\n\n}\n", "idx": 2737, "substitutes": {"bs": ["banks", "BS", "pb", "ubs", "ras", "ib", "bing", "blocks", "bot", "bus", "bi", "ps", "sb", "ob", "bh", "outs", "block", "cb", "os", "bas", "js", "bc", "lb", "bt", "s", "br", "res", "blog", "null", "qs", "bps", "ins", "details", "lbs", "css", "ses", "web", "b", "box", "utils", "bl", "ops", "bytes", "plugins", "sync", "lc", "base", "bp", "cs", "ctx", "bits", "ab", "obj", "full", "ros", "us", "ks", "obs", "gs", "tails", "bel", "ss", "ls", "http", "ds", "bf", "fs", "las", "ums", "ts", "ns", "bb", "bes", "bn", "ba", "bos", "fb", "abc", "eb", "console", "iss", "rs", "ats", "gb", "files", "abi", "vs", "db", "bin", "its", "bis", "bid", "bu"], "drv": ["driver", " drf", "vrv", "crp", " drva", "hrav", "vrav", "hrb", "derv", "hrf", " drl", "prv", " drV", "srv", "driva", "dervr", "derb", "srvm", " dru", "drvr", "drf", "crv", "frb", "delv", "rdver", "crf", "delb", "srp", "rdv", "hrvr", "rdb", "drb", "frv", "dru", "rdu", "drvm", "delvm", "drl", "prf", "hrvm", "drV", "srl", "drver", "derf", "drif", "prvr", "vrf", "driv", "drva", "srb", " drb", " drvr", "drp", "frV", "drav", "hrva", "delf", " drver", "rru", "crl", " drp", "rrver", "srV", "srf", "vrvr", "rrv", "rrb", "prav", "srvr", "hrv", "hrver", "frvr"], "opts": [" opks", " optte", "operters", " optons", "optons", "opks", "optx", " optts", "hopts", "opt", " opgs", " optx", " opty", "operter", " optt", "ryts", "optes", " optes", "opouts", "opertons", "OPted", "optters", "opttx", " optcs", " opTs", "OPks", "opTs", "lockts", "optty", "OPds", "OPte", "hoptics", "operts", "opments", "optips", "catts", "cattes", "opths", "optgs", " opments", " opttes", "optics", "catter", "ryTs", "iopgs", "catouts", "optter", "opertes", "optte", " optters", "ropts", "operty", "opty", " optty", "locktons", "ropters", " opds", " opcs", "operds", "opergs", "optt", "OPters", "hopTs", "opted", " opte", "OPts", " optths", "opcs", "rytics", "lockgs", "opter", "catters", "opte", "ryte", "opertips", " opt", "operks", "optcs", "opds", "optts", " opths", "ropouts", "OPt", " optted", "operouts", "optted", "ioptx", "catments", "OPments", " opters", "hopte", "iopters", "lockters", "catt", "roptips", "opters", "opttes", "operths", "opgs", "cattips", " optics", "iopts", "opert"], "has_open_options": ["has_open_option", "has_close_files", "has_open_events", "has_close_options", "has_openacoptions", "has_open_files", "has_close_name", "has_open___name", "has_open___options", "has_close_option", "has_openacopens", "has_open_opens", "has_open_name", "has_open___events", "has_openacoption", "has_close_events"]}}
{"project": "qemu", "commit_id": "9b990ee5a3cc6aa38f81266fb0c6ef37a36c45b9", "target": 0, "func": "static inline bool cpu_handle_exception(CPUState *cpu, int *ret)\n\n{\n\n    if (cpu->exception_index >= 0) {\n\n        if (cpu->exception_index >= EXCP_INTERRUPT) {\n\n            /* exit request from the cpu execution loop */\n\n            *ret = cpu->exception_index;\n\n            if (*ret == EXCP_DEBUG) {\n\n                cpu_handle_debug_exception(cpu);\n\n            }\n\n            cpu->exception_index = -1;\n\n            return true;\n\n        } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n            /* if user mode only, we simulate a fake exception\n\n               which will be handled outside the cpu execution\n\n               loop */\n\n#if defined(TARGET_I386)\n\n            CPUClass *cc = CPU_GET_CLASS(cpu);\n\n            cc->do_interrupt(cpu);\n\n#endif\n\n            *ret = cpu->exception_index;\n\n            cpu->exception_index = -1;\n\n            return true;\n\n#else\n\n            if (replay_exception()) {\n\n                CPUClass *cc = CPU_GET_CLASS(cpu);\n\n                qemu_mutex_lock_iothread();\n\n                cc->do_interrupt(cpu);\n\n                qemu_mutex_unlock_iothread();\n\n                cpu->exception_index = -1;\n\n            } else if (!replay_has_interrupt()) {\n\n                /* give a chance to iothread in replay mode */\n\n                *ret = EXCP_INTERRUPT;\n\n                return true;\n\n            }\n\n#endif\n\n        }\n\n#ifndef CONFIG_USER_ONLY\n\n    } else if (replay_has_exception()\n\n               && cpu->icount_decr.u16.low + cpu->icount_extra == 0) {\n\n        /* try to cause an exception pending in the log */\n\n        cpu_exec_nocache(cpu, 1, tb_find(cpu, NULL, 0), true);\n\n        *ret = -1;\n\n        return true;\n\n#endif\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 2762, "substitutes": {"cpu": ["cmp", "intel", "kernel", " CPU", "GPU", "cn", "auc", "cow", "boot", "mc", "proc", "que", "component", "lb", "processor", "host", "colo", "cpp", "fc", "uu", "null", "uca", "node", "config", "pid", "vm", "gpu", "python", "roc", "css", "pool", "comp", "ucc", "phy", "CPU", "slave", "username", "chip", "lc", "cu", "device", "uci", "ctx", "core", "proxy", "cp", "loader", "pc", "ocr", "server", "pu", "process", "ilo", "uc", "clock", "cache", "dc", "socket", "mac", "linux", "computer", "gc", "chu", "cli", "px", "platform", "consumer", "uno", "bench", "ubuntu", "console", "c", "nc", "np", "instance", "cfg", "client", "hw"], "ret": ["rep", "val", "let", "fail", "res", "pat", "back", "att", "def", "match", "pet", "fi", "rt", "flag", "rc", "num", "code", "resp", "alt", "valid", "RET", "ref", "det", "fit", "rev", "rf", "job", "et", "pret", "len", "lit", "success", "rets", "feat", "data", "reply", "mt", "eth", "fun", "nt", "reg", "url", "test", "result", "arg", "Ret", "ft", "sat", "re", "ct", "seq", "art"], "cc": ["cu", "cache", "dc", "mac", "sc", "cf", "ac", "rc", "cmp", "cs", "ack", "ctx", "code", "core", "cca", "vc", "CC", "ci", "ec", "gc", "xc", "cci", "UC", "acc", "tc", "con", "cv", "conn", "pc", "ca", "co", "css", "cn", "c", "nc", "RC", "mc", "ucc", "ck", "cl", "BC", "bc", "client", "uc", "lc", "anc"]}}
{"project": "FFmpeg", "commit_id": "1169f0d0afc0454633cfcfad73643f0458521c67", "target": 0, "func": "void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)\n\n{\n\n#if HAVE_INLINE_ASM\n\n    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {\n\n        if (ctx->cid_table->bit_depth == 8)\n\n            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;\n\n    }\n\n#endif /* HAVE_INLINE_ASM */\n\n}\n", "idx": 2793, "substitutes": {"ctx": ["bc", "cc", "pkg", "mac", "loc", "cf", "cpp", "cmp", "context", "cs", "settings", "rc", "conv", "cca", "vc", "alloc", "exec", "fp", "ci", "gc", "cms", "xc", "config", "cam", "buf", "qa", "tc", "sci", "cv", "cp", "gpu", "conn", "pc", "ca", "lc", "cn", "fw", "c", "ctrl", "nc", "mc", "cb", "tx", "hw", "na", "aux", "ct", "cas", "cm"]}}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_infinity(farg1.d) &&\n\n                 float64_is_infinity(farg2.d))) {\n\n        /* Division of infinity by infinity */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);\n\n    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {\n\n        /* Division of zero by zero */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d))) {\n\n            /* sNaN division */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);\n\n    }\n\n\n\n    return farg1.ll;\n\n}\n", "idx": 2806, "substitutes": {"env": ["cache", "manager", "equ", "her", "context", "enc", "gear", "ack", "conf", "img", "ctx", "ep", "eu", "ec", "viron", "eni", "config", "session", "obj", "aer", "vm", " environment", "et", "chal", "engine", "fen", "loader", "energy", "conn", "ext", "ah", "erv", "console", "txt", "ea", "ev", "ench", "server", "enh", "iss", "site", "c", " environments", "eng", "ef", "exc", "style", "kn", "proc", "oa", "db", "que", "em", "shell", "environment", "esi", "e", "qt", "priv", "en", "Environment"], "arg1": ["ar1", "arg01", " arg3", "arkone", "ax1", "ar3", "ar2", " argone", "ax2", "argument01", "ax01", "axone", "argument3", "argone", "ar01", "ark01", "arg3", " arg01", "ark1", "argument2", "ark2", "argument1"], "arg2": [" argb", "arg0", "Arg82", "arget82", " argTwo", "args0", "arget1", " arg0", "param0", "args2", "Arg1", " arg82", "argsTwo", "args1", "arget2", "Argb", "argb", "arg82", "param1", "argetb", "param2", "argTwo", "Arg2", "paramTwo"], "farg1": ["fagback", "fark0", "fval01", "fasc1", "farg21", "farg11", "sfark0", "ferg5", "farg4", "fargumentinf", "fargsn", "fargsone", "farg81", "Fargs3", "sfark4", "frarginf", "fconfig1", "frg1", "fArg31", "Fargs1", "fArg3", "farg3", " fval1", "infagn41", "fArgb", " farg11", "fcard21", "fagn41", "frargumentinf", "fagnh", "sfark1", "Farg1", "fax0", " farg41", "fargb", "Farg3", "fargument1", "ferg61", "carg3", "fArg1", "frgonce", " farg5", "ferg41", " fval3", "fagn81", "fval41", "fargn", "sfarkn", "frargument41", "fargs4", "cvalone", "infagnh", "infarg1", " fval41", "frarg61", "infargpart", "Fargone", "faginf", "fagn1", " fArg11", "cval3", "frargument1", "sfarg4", "fag21", "fark4", "cvaln", "fargs2", "fargs41", "fArgn", "fargsb", "fargs0", "fconfigh", " fArg31", "farkn", " fArg81", "fari0", "fArgone", " fArg3", "frarg1", "fag61", " farg0", "fcard1", "ferginf", "fconfig41", "fergback", "sfarg0", "fargpart", "cargn", "fagn11", "farg61", " ferg1", " farg81", "fasc41", "fcard5", "fag1", "fagnonce", "frg3", "fargback", "fackpart", "faxn", "infarg41", "cval1", "fagn3", "fasc3", "fagn31", "fax4", "fargs01", "sfargn", " fArg0", "frarg41", "fval1", "farg01", "fArg2", "fcardback", " fArg1", "fargs3", " fargb", "fArg81", " fergback", "fargonce", "farg41", "Fargsn", "fax1", " fArgonce", " ferg5", "frargument61", "fackh", "sfarg1", "fack1", "fag41", "farginf", "fconfigpart", "infagnpart", "fval3", " farg21", "infargh", "fvaln", "fargument41", "fvalone", "fagn0", " farg3", "ferg1", " farg01", "carg1", "fag5", "fargh", "fasc01", " ferg21", " fargback", "infagn1", " farg31", "ferg21", "fArg11", " fargonce", "farg0", "fArg0", "fari81", "fargone", "cargone", "fark1", "fack41", "farg31", "fArgonce", "Fargn", "fargument61", "fari1", "fagnpart", "farg5", "fargs1", "Fargsone", "fari11", " fval01", "frg31", "fArg01"], "farg2": ["farcpage", "fitempage", "fregb", "forig5", "infarg2", "fparamtwo", "infargtwo", " fArgtwo", "forig96", "fvalid82", "forigtwo", "infitem2", "forarg2", "farm96", "fargumenttwo", "farg3", "fArgb", " farg52", "fvalb", " fark1", "forarg96", "fparamb", "fvalidtwo", "farg82", "fig96", "fargb", "fargument2", "carg3", " farkB", "freg96", "farm2", " fvaltwo", "fig5", "fpar96", "fArgtwo", "fark2", "fvalidpage", " farg02", "infargpage", "fitem82", "infitemtwo", "fargpage", "fargs02", "farg96", "cval3", "fargs2", "forig2", "fval52", "fargstwo", "fargsb", "fargs0", "fregtwo", "fvalid2", "fval96", " farg0", "fargument52", " fArgb", "freg2", "fitem2", "infarg82", "farctwo", " fargB", " fArg2", "fargsB", " fArg0", "fig2", "fpar2", "freg3", "fArg2", "cargtwo", "forargtwo", "fargB", "forarg5", "fargs3", " fark2", " fark02", "farc2", " fargb", "fval3", "fark02", "cvaltwo", "fitemtwo", "farkB", "infitempage", "fpartwo", " fval96", " fval2", "fparam0", " fval52", "fargument96", "fvaltwo", "fval2", "farc82", "carg2", "cval2", " farg96", " fargtwo", "farg0", "fArg0", "freg5", "fargtwo", "cargb", "farg02", "fark1", "farm5", "cvalb", "fparam2", "fpar52", "infitem82", "farg5", "fargs1", "farg52", "figtwo", "farmtwo"]}}
{"project": "qemu", "commit_id": "e4d2edc9d0c58de421eb349871e90b67edec0b9c", "target": 0, "func": "static void test_io_channel_ipv4(bool async)\n\n{\n\n    SocketAddress *listen_addr = g_new0(SocketAddress, 1);\n\n    SocketAddress *connect_addr = g_new0(SocketAddress, 1);\n\n\n\n    listen_addr->type = SOCKET_ADDRESS_KIND_INET;\n\n    listen_addr->u.inet = g_new0(InetSocketAddress, 1);\n\n    listen_addr->u.inet->host = g_strdup(\"0.0.0.0\");\n\n    listen_addr->u.inet->port = NULL; /* Auto-select */\n\n\n\n    connect_addr->type = SOCKET_ADDRESS_KIND_INET;\n\n    connect_addr->u.inet = g_new0(InetSocketAddress, 1);\n\n    connect_addr->u.inet->host = g_strdup(\"127.0.0.1\");\n\n    connect_addr->u.inet->port = NULL; /* Filled in later */\n\n\n\n    test_io_channel(async, listen_addr, connect_addr);\n\n\n\n    qapi_free_SocketAddress(listen_addr);\n\n    qapi_free_SocketAddress(connect_addr);\n\n}\n", "idx": 2817, "substitutes": {"async": ["ASync", "assyn", "ASnc", "asssync", " asyn", "asock", "aynchronous", "nassync", "aitynchronous", "assynchronous", "aock", " assync", "nasyn", "aitock", "asyn", "ASynchronous", "aitnc", "nasynchronous", "aync", " asynchronous", "assync", "asnc", "nasync", "ASock", "asynchronous", "aitync", "anc"], "listen_addr": ["listzenMaddress", "listen_ptr", "listen__ad", "listent_addr", "listzenMhost", "listen_eth", "listener_eth", "listen_anne", "listenMaddress", "listzen_host", "listener_dist", "listeren_anne", "listen64addr", "listerenranne", "listenMaddr", "listenadptr", "listen_dr", "listenworig", "listent_oa", "listzen_address", "listening_ptr", "listen_address", "listzenMaddr", "listenwaddr", "listener_dr", "listenranne", "listen64node", "listzenMurl", "listerenradr", "listenwnode", "listeren_adr", "listen_ord", "listen_orig", "listenadad", "listeren_oa", "listzen_addr", "listen__addr", "listent_osi", "listening_addr", "listen64address", "listen__address", "listenradr", "listzen_url", "listenMhost", "listener_address", "listerenraddr", "listenadaddr", "listen__ptr", "listener_ord", "listen_host", "listener_orig", "listenMurl", "listen_url", "listenraddr", "listen_dist", "listenadaddress", "listen_node", "listener_node", "listenroa", "listen_ad", "listent_adr", "listen_oa", "listerenroa", "listener_addr", "listen_osi", "listening_ad", "listenwaddress", "listen64orig", "listeren_addr", "listening_address", "listen_adr"], "connect_addr": ["connectingaddr", "connectingloc", "connectableaddr", "connect_oa", "connection_addr", " connect_adr", "connect_address", "connectionace", "sign_adr", "connectioningloc", "connect_obj", "connectableerror", " connect_ad", "config_dist", "connectingurl", "connectioningerror", "connectableurl", "conn_addr", "connect_part", "connection_loc", "conn_ack", "connectionadd", "config_addr", "connectionamd", "conn_host", "close_address", "connect_adr", "connect_attr", "sign_ace", "connect_amd", "connect_dr", "connectableaddress", " connect_node", "connect_node", "connectureid", "connect_loc", "connect_ace", "config_dr", "connect_dist", "close_part", "connectionaddr", "connectableloc", "connection_error", "connecturead", "conn_oa", "connect_ad", "connectureaddr", "connect_ord", "connection_url", "connecturenode", "connect_url", "connect_id", "sign_addr", "connect_add", " connect_amd", "connect_ack", "config_ord", "close_attr", "connectionadr", "connectionobj", " connect_add", "connectioningaddr", "connectableattr", "close_addr", "connectablepart", "connect_host", " connect_id", "connectioningurl", "connect_error", "connectingerror", "sign_obj"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_loongson_multimedia(DisasContext *ctx, int rd, int rs, int rt)\n\n{\n\n    const char *opn = \"loongson_cp2\";\n\n    uint32_t opc, shift_max;\n\n    TCGv_i64 t0, t1;\n\n\n\n    opc = MASK_LMI(ctx->opcode);\n\n    switch (opc) {\n\n    case OPC_ADD_CP2:\n\n    case OPC_SUB_CP2:\n\n    case OPC_DADD_CP2:\n\n    case OPC_DSUB_CP2:\n\n        t0 = tcg_temp_local_new_i64();\n\n        t1 = tcg_temp_local_new_i64();\n\n        break;\n\n    default:\n\n        t0 = tcg_temp_new_i64();\n\n        t1 = tcg_temp_new_i64();\n\n        break;\n\n    }\n\n\n\n    gen_load_fpr64(ctx, t0, rs);\n\n    gen_load_fpr64(ctx, t1, rt);\n\n\n\n#define LMI_HELPER(UP, LO) \\\n\n    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break\n\n#define LMI_HELPER_1(UP, LO) \\\n\n    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break\n\n#define LMI_DIRECT(UP, LO, OP) \\\n\n    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break\n\n\n\n    switch (opc) {\n\n    LMI_HELPER(PADDSH, paddsh);\n\n    LMI_HELPER(PADDUSH, paddush);\n\n    LMI_HELPER(PADDH, paddh);\n\n    LMI_HELPER(PADDW, paddw);\n\n    LMI_HELPER(PADDSB, paddsb);\n\n    LMI_HELPER(PADDUSB, paddusb);\n\n    LMI_HELPER(PADDB, paddb);\n\n\n\n    LMI_HELPER(PSUBSH, psubsh);\n\n    LMI_HELPER(PSUBUSH, psubush);\n\n    LMI_HELPER(PSUBH, psubh);\n\n    LMI_HELPER(PSUBW, psubw);\n\n    LMI_HELPER(PSUBSB, psubsb);\n\n    LMI_HELPER(PSUBUSB, psubusb);\n\n    LMI_HELPER(PSUBB, psubb);\n\n\n\n    LMI_HELPER(PSHUFH, pshufh);\n\n    LMI_HELPER(PACKSSWH, packsswh);\n\n    LMI_HELPER(PACKSSHB, packsshb);\n\n    LMI_HELPER(PACKUSHB, packushb);\n\n\n\n    LMI_HELPER(PUNPCKLHW, punpcklhw);\n\n    LMI_HELPER(PUNPCKHHW, punpckhhw);\n\n    LMI_HELPER(PUNPCKLBH, punpcklbh);\n\n    LMI_HELPER(PUNPCKHBH, punpckhbh);\n\n    LMI_HELPER(PUNPCKLWD, punpcklwd);\n\n    LMI_HELPER(PUNPCKHWD, punpckhwd);\n\n\n\n    LMI_HELPER(PAVGH, pavgh);\n\n    LMI_HELPER(PAVGB, pavgb);\n\n    LMI_HELPER(PMAXSH, pmaxsh);\n\n    LMI_HELPER(PMINSH, pminsh);\n\n    LMI_HELPER(PMAXUB, pmaxub);\n\n    LMI_HELPER(PMINUB, pminub);\n\n\n\n    LMI_HELPER(PCMPEQW, pcmpeqw);\n\n    LMI_HELPER(PCMPGTW, pcmpgtw);\n\n    LMI_HELPER(PCMPEQH, pcmpeqh);\n\n    LMI_HELPER(PCMPGTH, pcmpgth);\n\n    LMI_HELPER(PCMPEQB, pcmpeqb);\n\n    LMI_HELPER(PCMPGTB, pcmpgtb);\n\n\n\n    LMI_HELPER(PSLLW, psllw);\n\n    LMI_HELPER(PSLLH, psllh);\n\n    LMI_HELPER(PSRLW, psrlw);\n\n    LMI_HELPER(PSRLH, psrlh);\n\n    LMI_HELPER(PSRAW, psraw);\n\n    LMI_HELPER(PSRAH, psrah);\n\n\n\n    LMI_HELPER(PMULLH, pmullh);\n\n    LMI_HELPER(PMULHH, pmulhh);\n\n    LMI_HELPER(PMULHUH, pmulhuh);\n\n    LMI_HELPER(PMADDHW, pmaddhw);\n\n\n\n    LMI_HELPER(PASUBUB, pasubub);\n\n    LMI_HELPER_1(BIADD, biadd);\n\n    LMI_HELPER_1(PMOVMSKB, pmovmskb);\n\n\n\n    LMI_DIRECT(PADDD, paddd, add);\n\n    LMI_DIRECT(PSUBD, psubd, sub);\n\n    LMI_DIRECT(XOR_CP2, xor, xor);\n\n    LMI_DIRECT(NOR_CP2, nor, nor);\n\n    LMI_DIRECT(AND_CP2, and, and);\n\n    LMI_DIRECT(PANDN, pandn, andc);\n\n    LMI_DIRECT(OR, or, or);\n\n\n\n    case OPC_PINSRH_0:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 0, 16);\n\n        opn = \"pinsrh_0\";\n\n        break;\n\n    case OPC_PINSRH_1:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 16, 16);\n\n        opn = \"pinsrh_1\";\n\n        break;\n\n    case OPC_PINSRH_2:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 32, 16);\n\n        opn = \"pinsrh_2\";\n\n        break;\n\n    case OPC_PINSRH_3:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 48, 16);\n\n        opn = \"pinsrh_3\";\n\n        break;\n\n\n\n    case OPC_PEXTRH:\n\n        tcg_gen_andi_i64(t1, t1, 3);\n\n        tcg_gen_shli_i64(t1, t1, 4);\n\n        tcg_gen_shr_i64(t0, t0, t1);\n\n        tcg_gen_ext16u_i64(t0, t0);\n\n        opn = \"pextrh\";\n\n        break;\n\n\n\n    case OPC_ADDU_CP2:\n\n        tcg_gen_add_i64(t0, t0, t1);\n\n        tcg_gen_ext32s_i64(t0, t0);\n\n        opn = \"addu\";\n\n        break;\n\n    case OPC_SUBU_CP2:\n\n        tcg_gen_sub_i64(t0, t0, t1);\n\n        tcg_gen_ext32s_i64(t0, t0);\n\n        opn = \"addu\";\n\n        break;\n\n\n\n    case OPC_SLL_CP2:\n\n        opn = \"sll\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_SRL_CP2:\n\n        opn = \"srl\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_SRA_CP2:\n\n        opn = \"sra\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_DSLL_CP2:\n\n        opn = \"dsll\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    case OPC_DSRL_CP2:\n\n        opn = \"dsrl\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    case OPC_DSRA_CP2:\n\n        opn = \"dsra\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    do_shift:\n\n        /* Make sure shift count isn't TCG undefined behaviour.  */\n\n        tcg_gen_andi_i64(t1, t1, shift_max - 1);\n\n\n\n        switch (opc) {\n\n        case OPC_SLL_CP2:\n\n        case OPC_DSLL_CP2:\n\n            tcg_gen_shl_i64(t0, t0, t1);\n\n            break;\n\n        case OPC_SRA_CP2:\n\n        case OPC_DSRA_CP2:\n\n            /* Since SRA is UndefinedResult without sign-extended inputs,\n\n               we can treat SRA and DSRA the same.  */\n\n            tcg_gen_sar_i64(t0, t0, t1);\n\n            break;\n\n        case OPC_SRL_CP2:\n\n            /* We want to shift in zeros for SRL; zero-extend first.  */\n\n            tcg_gen_ext32u_i64(t0, t0);\n\n            /* FALLTHRU */\n\n        case OPC_DSRL_CP2:\n\n            tcg_gen_shr_i64(t0, t0, t1);\n\n            break;\n\n        }\n\n\n\n        if (shift_max == 32) {\n\n            tcg_gen_ext32s_i64(t0, t0);\n\n        }\n\n\n\n        /* Shifts larger than MAX produce zero.  */\n\n        tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max);\n\n        tcg_gen_neg_i64(t1, t1);\n\n        tcg_gen_and_i64(t0, t0, t1);\n\n        break;\n\n\n\n    case OPC_ADD_CP2:\n\n    case OPC_DADD_CP2:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            int lab = gen_new_label();\n\n\n\n            tcg_gen_mov_i64(t2, t0);\n\n            tcg_gen_add_i64(t0, t1, t2);\n\n            if (opc == OPC_ADD_CP2) {\n\n                tcg_gen_ext32s_i64(t0, t0);\n\n            }\n\n            tcg_gen_xor_i64(t1, t1, t2);\n\n            tcg_gen_xor_i64(t2, t2, t0);\n\n            tcg_gen_andc_i64(t1, t2, t1);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(lab);\n\n\n\n            opn = (opc == OPC_ADD_CP2 ? \"add\" : \"dadd\");\n\n            break;\n\n        }\n\n\n\n    case OPC_SUB_CP2:\n\n    case OPC_DSUB_CP2:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            int lab = gen_new_label();\n\n\n\n            tcg_gen_mov_i64(t2, t0);\n\n            tcg_gen_sub_i64(t0, t1, t2);\n\n            if (opc == OPC_SUB_CP2) {\n\n                tcg_gen_ext32s_i64(t0, t0);\n\n            }\n\n            tcg_gen_xor_i64(t1, t1, t2);\n\n            tcg_gen_xor_i64(t2, t2, t0);\n\n            tcg_gen_and_i64(t1, t1, t2);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(lab);\n\n\n\n            opn = (opc == OPC_SUB_CP2 ? \"sub\" : \"dsub\");\n\n            break;\n\n        }\n\n\n\n    case OPC_PMULUW:\n\n        tcg_gen_ext32u_i64(t0, t0);\n\n        tcg_gen_ext32u_i64(t1, t1);\n\n        tcg_gen_mul_i64(t0, t0, t1);\n\n        opn = \"pmuluw\";\n\n        break;\n\n\n\n    case OPC_SEQU_CP2:\n\n    case OPC_SEQ_CP2:\n\n    case OPC_SLTU_CP2:\n\n    case OPC_SLT_CP2:\n\n    case OPC_SLEU_CP2:\n\n    case OPC_SLE_CP2:\n\n        /* ??? Document is unclear: Set FCC[CC].  Does that mean the\n\n           FD field is the CC field?  */\n\n    default:\n\n        MIPS_INVAL(opn);\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n\n\n#undef LMI_HELPER\n\n#undef LMI_DIRECT\n\n\n\n    gen_store_fpr64(ctx, t0, rd);\n\n\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s, %s\", opn,\n\n               fregnames[rd], fregnames[rs], fregnames[rt]);\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i64(t1);\n\n}\n", "idx": 2818, "substitutes": {"ctx": ["kb", "kw", "dc", "cc", "pkg", "loc", "sc", "cf", "rc", "cmp", "context", "cs", "grad", "conv", "cca", "scl", "vc", "fp", "ci", "exec", "ux", "lib", "qq", "cms", "xc", "cli", "config", "cam", "sq", "obj", "tk", "cci", " cx", "qa", "Context", "sci", "tc", "cv", "conn", "ca", "coll", "txt", "progress", "c", "ctrl", "comp", "nc", "jp", "kt", "ch", "cb", "tx", "ck", "wcs", "cmd", "hw", "bc", " context", "cas", "sync", "cm"], "rd": ["dd", "rb", "dc", "cr", "rr", "cc", "rc", "rx", "st", "nd", "rf", "rw", "ri", "Rs", "ld", "hr", "nc", "ru", "mc", "std", "rl", "cl", "lr"], "rs": ["rb", "sw", "cr", "res", "r", "pr", "sr", "ns", "rc", "hs", "cs", "cmp", "ims", "ubs", "ras", "src", "rics", "ins", "rows", "ries", "mr", "Rs", "ds", "ps", "ks", "rg", "params", "ru", "eps", "resses", "rl", "ra", "RS", "ars", "lr", "ls", "addr", "ops", "vers", "xs", "s"], "rt": ["fr", "rb", "rr", "vt", "req", "pr", "r", "sr", "rh", "ac", "rc", "ptr", "rx", "pt", "ras", "ref", "adr", "dr", "ret", "rf", "ri", "rw", "rec", "vr", "RT", "rm", "mt", "nt", "ru", "rn", "rot", "t", "b", "q", "rl", "ls", "addr", "ct"], "opn": ["OPc", "opns", "Opn", "hopcn", "optconn", "Opf", "opconn", "optr", "opern", "oprn", "OPn", "operns", "optn", "opf", "Opb", " opb", "hopconn", "optcn", "Opc", "hopc", "opr", "operc", " opconn", " oprn", " opr", "optns", " opf", "OPrn", "hopn", "OPr", "optf", "optc", "opb", "opcn", "optrn", " opcn", " opns", "optb"], "opc": ["tooln", "OPc", "hopci", "ropn", "optcs", "toolc", "OPcode", "toolf", " opC", "OPC", "OPn", "opcode", " opcs", " opcode", "OPf", "ropcs", "optn", "opf", "copc", " opci", "ropc", "hopc", "copcode", "optci", "toolC", "ropcode", "copn", "optcode", "opcs", "hopf", "opci", " opf", "hopn", "optf", "optc", "copf", "opC"], "shift_max": ["push_max", "push_right", "push_min", "push_MAX", "shift_MAX", "shift_right", "shift_min"], "t0": ["Tkg", "tkg", "ti2", "f0", "t4", " t4", "p0", "t25", "ty00", "p1", " t2", "ta50", "wt0", "wt25", "t00", "p50", "ty2", "wt50", "ti0", "t2", "wt1", "f2", "ta0", "ty0", "T0", "T1", "T50", "ta2", "T4", " t50", "T25", "tikg", "p2", " t00", "f1", "t50", "fkg", "T2", "ty50", "ta00", "p25", "ti1", "p4"], "t1": ["t80", "te91", "te6", "ot91", "ty1", "st91", "t4", "tyONE", "pb", " t4", "p0", "te1", "st1", "ty6", "t6", "p1", " t2", " tb", "t91", "tie1", "tONE", "teONE", "Tb", "t2", "ot6", "ty91", "T0", "T1", "T4", "ot1", "otONE", "tb", "p2", " t91", "tie91", "st80", " t80", "T2", "p4", "tie80"]}}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_stat(void *opaque)\n\n{\n\n    int32_t fid;\n\n    V9fsStat v9stat;\n\n    ssize_t err = 0;\n\n    size_t offset = 7;\n\n    struct stat stbuf;\n\n    V9fsFidState *fidp;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"d\", &fid);\n\n    trace_v9fs_stat(pdu->tag, pdu->id, fid);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    offset += pdu_marshal(pdu, offset, \"wS\", 0, &v9stat);\n\n    err = offset;\n\n    trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode,\n\n                           v9stat.atime, v9stat.mtime, v9stat.length);\n\n    v9fs_stat_free(&v9stat);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, err);\n\n}\n", "idx": 2820, "substitutes": {"opaque": ["Opca", "opac", "ospec", "OPac", "opca", "OPacity", "Opaque", "opec", "opace", "ipaque", " opace", "ipace", "ipac", "Opacity", "Opec", "OPace", "ospaque", " opacity", "OPaque", "ipacity", "opacity", "ipec", "ospca", "ospacity", " opac", "ipca"], "fid": ["frid", "cname", "fID", "cfide", "cids", "fpide", "rbid", "feids", "pids", "fide", " fID", "cfida", "fekid", "lrid", "fida", "febid", "fcbid", "pid", "fbid", "fpbid", "fcide", "lfname", "fids", "fkid", "lfids", "lids", "pID", "rids", "fcida", "lfid", "rkid", "prid", " fname", "cfbid", "cide", "ckid", "cfid", "lfide", "rid", "fpida", "cid", "fname", " frid", "cbid", "fcid", "fpid", " fids", " fide", "lID", "feid", "lid"], "v9stat": ["v8log", "v6STAT", "V8status", "v8Stat", "V6stats", "v6Stat", "v09stats", "v09min", "v94stat", "V6min", "V9tag", "f8init", "f8stat", "v94status", "v91stat", "m09stat", "v09init", "v94init", "f9stats", "f9STAT", "v_Stat", "v09stat", "v91tag", "V8stat", "v8stat", "V8tag", "v9tag", "V9stat", "v09not", "m9not", "v1status", "v9min", "f8STAT", "V09stats", "V6login", "V9min", "m09log", "v_stat", "v8stats", "V9stats", "v9status", "v9not", "V09status", "vninestatus", "v8STAT", "v_stats", "vninelogin", "v9log", "v1stat", "V9Stat", "v94stats", "v6log", "V09log", "v8status", "v8login", "v_status", "m9log", "v6status", "vninestat", "v9init", "V6stat", "v9stats", "f9status", "f9init", "V9login", "vnineSTAT", "v8min", "v6min", "v09status", "v1log", "v9STAT", "v89not", "v9Stat", "V6Stat", "v1tag", "m9stat", "V9log", "v8tag", "v89log", "V9status", "v09log", "f9stat", "v8init", "m9stats", "vninestats", "V6status", "v91status", "m09not", "v89stat", "m09stats", "v9login", "V09stat", "v91log", "V8log", "v89stats", "f8stats", "v6login", "v6stats", "v6stat", "f8status"], "stbuf": ["strbuf", "restdb", "Stfunc", "STbuf", "sthdata", "sthdb", "stavec", "Stdb", "Stbuf", "restdata", "strfd", "ostbuf", "ostbuffer", "ostvec", "sthfd", "Stfd", "ostfd", "stcv", "stabuffer", "Stcv", "restbuf", "stdb", "stdata", " stfunc", "stbuffer", "STfunc", "stafd", "Stdata", "strvec", "stfd", "stvec", "strbuffer", "STcv", "restfd", "stabuf", " stcv", "sthbuf", "stfunc"], "fidp": ["fidenlp", "fpidp", " faidp", "fIDp", " fidu", "fidv", "fidlp", " fidv", "ofardp", "filp", "fIdpc", "nardpe", " fidpa", "fiddr", "ofardpc", " faidf", "fidf", "nardp", "fiddu", "filf", "fpidc", "fIdv", " fIdr", "fider", " faidr", "fardpe", "fuidpe", "fIDu", "fuidpr", "fuidp", "fiddp", "faidr", " fidf", " fidc", "nidpe", "fardu", "fiddv", "fidc", " fidr", "fuidlp", " fidpc", "nardlp", "fidx", "fpidr", "fIDv", "fidr", "fstartu", "fstartv", "fstartpc", " faidpa", "fIDr", "fIdc", "nidpr", "fidpc", "fidex", "fidenp", "fidenpr", "fIdx", "fIdp", "fardlp", "nardpr", "ofidp", "fippa", "fidec", "fipf", " fIdp", "nidlp", "ofidv", " fIdu", "fipr", "filr", "fardpr", "filpa", "faidpa", "faidp", "fidpa", "nidp", "fpidpc", "fidu", "fIdr", "fidpr", "ofidu", " fidx", "fidpe", "fidenpe", "ofardu", "fardv", "ofardv", " fIdv", "faidf", "fIdu", "fstartp", "ofidpc", "fardp", "fardpc", "fiddpc", "fidep", "fipp"], "pdu": ["bcu", "nptu", "apuu", "epuc", "buu", "dfu", " pcu", "Psu", "fde", " ptu", "copcu", "hdu", "pde", "chdu", "ipuu", "pru", " pru", "ccu", "chtu", "ctu", " pda", "Puu", "fsu", "fcu", "pda", "Pde", "puc", "aptu", "epdu", "ipdu", "pcu", "copru", "dru", "psu", " puu", "chuu", "puu", "sptu", "copsu", "fud", "bpdu", "copfu", "ddu", "bptu", "eptu", "npdu", "opcu", "opde", "copdu", "cda", "ffu", "Pud", "pud", "copuu", "ruu", "bpuc", "hcu", "bdu", "rdu", " pde", "dcu", " pud", "cdu", "hda", "rtu", "Pdu", "opru", "ftu", "opdu", "csu", "Pru", "cpdu", "ptu", "ipcu", "fuu", "epuu", "optu", "npuu", "spcu", "opuu", "iptu", "fru", "spdu", "Ptu", "cptu", "fdu", "chuc", "spsu", "cpcu", "bpuu", "apcu", "cpsu", "npcu", "Pcu", "htu", "rru", "pfu", "cpde", " psu", "apdu"], "s": ["S", "i", "fs", "r", "sync", "ns", "settings", "is", "n", "ssl", "o", "south", "p", "or", "location", "d", "m", "session", "w", "v", "ops", "a", "stats", "states", "sys", "g", "server", "spec", "ses", "secondary", "c", "sb", "rs", "scope", "gs", "sym", "state", "args", "t", "b", "f", "u", "storage", "sg", "os", "ss", "e", "uploads", "http", "h"]}}
{"project": "qemu", "commit_id": "2958620f67dcfd11476e62b4ca704dae0b978ea3", "target": 1, "func": "uint64_t helper_addlv (uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t tmp = op1;\n\n    op1 = (uint32_t)(op1 + op2);\n\n    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {\n\n        arith_excp(env, GETPC(), EXC_M_IOV, 0);\n\n    }\n\n    return op1;\n\n}\n", "idx": 2832, "substitutes": {"op1": [" op0", "oper2", "OP1", " opone", " opOne", "oper1", "Op1", "hop2", "optOne", "hop3", "opt01", "op01", "hop1", "oper3", "hopOne", "opt3", "ip1", "opt1", " opb", "hopb", "hop4", "opOne", "hop0", "opt4", "opt0", "OPOne", " op4", "OP01", "ip2", "Op2", "ipone", "op3", "op0", "opone", "oper0", "operb", "op4", "ip0", "Op01", " op3", "opb", "OP0", "operone", "OP2", "opt2", "OpOne"], "op2": [" op0", "oper2", "opTwo", "coptwo", "operv", "opv", "hop2", "oper1", " opTwo", "hop3", "hop1", "opt3", "cop3", "opt1", " opv", "hop0", "copTwo", "hopv", "optTwo", "op3", "op0", "oper0", "opttwo", " op3", " optwo", "cop2", "optwo", "opt2"]}}
{"project": "qemu", "commit_id": "778358d0a8f74a76488daea3c1b6fb327d8135b4", "target": 1, "func": "static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *group,\n\n                                   RockerTlv **group_tlvs)\n\n{\n\n    OfDpaGroup *l2_group;\n\n    RockerTlv **tlvs;\n\n    int err;\n\n    int i;\n\n\n\n    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||\n\n        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    group->l2_flood.group_count =\n\n        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);\n\n\n\n    tlvs = g_malloc0((group->l2_flood.group_count + 1) *\n\n                     sizeof(RockerTlv *));\n\n    if (!tlvs) {\n\n        return -ROCKER_ENOMEM;\n\n    }\n\n\n\n    g_free(group->l2_flood.group_ids);\n\n    group->l2_flood.group_ids =\n\n        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));\n\n    if (!group->l2_flood.group_ids) {\n\n        err = -ROCKER_ENOMEM;\n\n        goto err_out;\n\n    }\n\n\n\n    rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count,\n\n                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]);\n\n    }\n\n\n\n    /* All of the L2 interface groups referenced by the L2 flood\n\n     * must have same VLAN\n\n     */\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        l2_group = of_dpa_group_find(of_dpa, group->l2_flood.group_ids[i]);\n\n        if (!l2_group) {\n\n            continue;\n\n        }\n\n        if ((ROCKER_GROUP_TYPE_GET(l2_group->id) ==\n\n             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&\n\n            (ROCKER_GROUP_VLAN_GET(l2_group->id) !=\n\n             ROCKER_GROUP_VLAN_GET(group->id))) {\n\n            DPRINTF(\"l2 interface group 0x%08x VLAN doesn't match l2 \"\n\n                    \"flood group 0x%08x\\n\",\n\n                    group->l2_flood.group_ids[i], group->id);\n\n            err = -ROCKER_EINVAL;\n\n            goto err_out;\n\n        }\n\n    }\n\n\n\n    g_free(tlvs);\n\n    return ROCKER_OK;\n\n\n\nerr_out:\n\n    group->l2_flood.group_count = 0;\n\n    g_free(group->l2_flood.group_ids);\n\n    g_free(tlvs);\n\n\n\n    return err;\n\n}\n", "idx": 2846, "substitutes": {"of_dpa": ["of_madpi", "of__dpa", "of_Dppa", "of_cpe", "of_mdpe", "of_mdao", "of_npa", "of_ducp", "of_Dpi", "of_nao", "of_Dpa", "of_madcp", "of_cppa", "of__cao", "of_cao", "of_dppa", "of__dao", "of__cpa", "of_dao", "of__dpe", "of_madppa", "of_dcp", "of_mdpa", "of__dppa", "of_dupa", "of_npe", "of_madpa", "of_dpi", "of_dpe", "of_duppa", "of_Dcp", "of_cpa", "of_dupi", "of__cpe", "of_nppa", "of__cppa", "of_mdppa"], "group": ["user", "comment", "gu", "gru", "agg", "cache", "field", "diff", "database", "back", "project", "match", "gen", "object", "option", "gh", "cell", "key", "GROUP", "multi", "number", "module", "input", "config", "any", "call", "name", "member", "join", "an", "full", "class", "event", "type", "co", "g", "list", "coll", "batch", "parent", "row", "game", "server", "Group", "output", "package", "app", "band", "pair", "gg", "plugin", "result", "block", "committee", "global", "gap", "q", "range", "component", "single", "child", "out", "company", "message", "sync", "order", "pg", "rule"], "group_tlvs": ["group_llvs", "group_Tlvn", "group_dlvn", "group_tcfen", "group_tlli", "group_dlvd", "group_tlsd", "group_tlegs", "group_tlfd", "group_tlfen", "group_tgtn", "group_tlevs", "group_tlve", "group_dlls", "group_tlls", "group_llvd", "group_tlfi", "group_tgts", "group_tlegd", "group_dlvs", "group_tlsi", "group_llevs", "group_Tlvi", "group_llevn", "group_tllS", "group_tlln", "group_tgtd", "group_tlfe", "group_tlevi", "group_llevi", "group_tlven", "group_dlln", "group_Tlfd", "group_tcfn", "group_tlevn", "group_dlven", "group_dlld", "group_tlvn", "group_llevd", "group_tlss", "group_tlld", "group_Tlfn", "group_tlvd", "group_Tlve", "group_Tlfe", "group_llvi", "group_tlse", "group_tcfs", "group_tlegS", "group_Tlfi", "group_tlfS", "group_tlvS", "group_llvn", "group_Tlfs", "group_tlle", "group_Tlvd", "group_tlegn", "group_tllen", "group_tlfs", "group_tlvi", "group_tcfd", "group_tlevd", "group_dllen", "group_Tlvs", "group_tlfn"], "l2_group": ["l2_Group", "l2_channel", "l2ibgroups", "l2__groups", "l3_groups", "l4_group", "l2__group", "l2__channel", "l4__g", "l2__g", "l1_Group", "l2_type", "l2_client", "l4__channel", "l2ibgroup", "l4_channel", "l4_groups", "l4_g", "l4__groups", "l3_group", "l2_g", "l3_type", "l3_client", "l4__group", "l2ibclient", "l1_group", "l1_g", "l2_groups", "l2ibtype"], "tlvs": ["tLVe", "tvlls", "untLVabs", "itlvp", "itllp", "tvalt", "wtvlids", "tservids", "wtvlf", "tlegs", "tlvstat", "tvale", "tlsids", "tlld", "untLVs", "tlime", "tLVstat", " tlvp", "tlvids", "wtlve", "tservs", " tlve", " tlime", "itlvs", "tlve", "tlvabs", "tlimd", "tlle", "tlvp", "tllt", "tllits", " tlvd", "tllp", " tlimp", "tlvf", "untlvstat", "wtlvids", "tlvls", "tlss", "untlvs", "wtlvs", "tlegp", "tlls", "untlvabs", "itlvits", "itllits", "wtlvt", "tcolits", "wtvls", "tcols", "tlegits", "tlegabs", "tinyls", "wtvle", "wtvlt", "wtlvf", "wtlvls", "tvls", "wtvlls", "tlvt", "tllls", "tLVs", "tvalls", "tLVd", "tinylabs", "tLVabs", "tcolp", "tlvits", "tlimp", "tlsf", "tservf", "untLVstat", " tlims", "tinylstat", "tvle", "tvlt", "tvlids", "tlegstat", "itlls", "tlvd", " tlimd", "tLVp", "tvals", "tlims", "tvlf"], "err": ["fr", "rb", "rr", "diff", "gr", "ir", "bug", "rh", "error", "rc", "fi", "code", "er", "resp", "Er", "debug", "arr", "rage", "usr", "ind", "dr", "var", "errors", "orig", "Error", "str", " error", "ise", "init", "result", "gi", "dev", "cur", "lr", "ctr", " Err", "cfg", "phi", "progress", "msg", "br"], "i": ["hi", "chi", "ui", "io", "r", "l", "fi", "sup", "si", "j", "n", "uri", "y", "p", "ci", "key", "multi", "qi", "ind", "eni", "d", "m", "oi", "id", "z", "I", "mi", "yi", "ri", "k", "ini", "ii", "slice", "count", "v", "a", "bi", "mini", "uli", "li", "g", "iu", "ie", "ji", "c", "in", "di", "ix", "ai", "info", "init", "pi", "mu", "t", "gi", "f", "b", "u", "ti", "ip", "ni", "e", "xi", "x", "inner", "phi", "h", "my", "index"]}}
{"project": "FFmpeg", "commit_id": "8bdba1092f50d52e0af90f425811302ec91152f8", "target": 1, "func": "int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\n    const uint64_t fuzz_tag = FUZZ_TAG;\n\n    FuzzDataBuffer buffer;\n\n    const uint8_t *last = data;\n\n    const uint8_t *end = data + size;\n\n    uint32_t it = 0;\n\n\n\n    if (!c)\n\n        c = AVCodecInitialize(FFMPEG_CODEC);  // Done once.\n\n\n\n    AVCodecContext* ctx = avcodec_alloc_context3(NULL);\n\n    if (!ctx)\n\n        error(\"Failed memory allocation\");\n\n\n\n    ctx->max_pixels = 4096 * 4096; //To reduce false positive OOM and hangs\n\n\n\n    int res = avcodec_open2(ctx, c, NULL);\n\n    if (res < 0)\n\n        return res;\n\n\n\n    FDBCreate(&buffer);\n\n    int got_frame;\n\n    AVFrame *frame = av_frame_alloc();\n\n    if (!frame)\n\n        error(\"Failed memory allocation\");\n\n\n\n    // Read very simple container\n\n    AVPacket avpkt;\n\n    while (data < end && it < maxiteration) {\n\n        // Search for the TAG\n\n        while (data + sizeof(fuzz_tag) < end) {\n\n            if (data[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(data) == fuzz_tag)\n\n                break;\n\n            data++;\n\n        }\n\n        if (data + sizeof(fuzz_tag) > end)\n\n            data = end;\n\n\n\n        FDBPrepare(&buffer, &avpkt, last, data - last);\n\n        data += sizeof(fuzz_tag);\n\n        last = data;\n\n\n\n        // Iterate through all data\n\n        while (avpkt.size > 0 && it++ < maxiteration) {\n\n            av_frame_unref(frame);\n\n            int ret = decode_handler(ctx, frame, &got_frame, &avpkt);\n\n\n\n            if (it > 20)\n\n                ctx->error_concealment = 0;\n\n\n\n            if (ret <= 0 || ret > avpkt.size)\n\n               break;\n\n\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n    }\n\n\n\n    av_init_packet(&avpkt);\n\n    avpkt.data = NULL;\n\n    avpkt.size = 0;\n\n\n\n    do {\n\n        got_frame = 0;\n\n        decode_handler(ctx, frame, &got_frame, &avpkt);\n\n    } while (got_frame == 1 && it++ < maxiteration);\n\n\n\n    av_frame_free(&frame);\n\n    avcodec_free_context(&ctx);\n\n    av_freep(&ctx);\n\n    FDBDesroy(&buffer);\n\n    return 0;\n\n}", "idx": 2857, "substitutes": {"data": ["xxx", "update", "all", "i", "total", "text", "zero", "number", "d", "len", "reset", "count", "window", "parent", "video", "output", "complete", "results", "image", "block", "channel", "state", "DATA", "message", "draw", "media", "ui", "done", "error", "p", "valid", "what", "dat", "limit", "name", "buf", "pos", "format", "style", "response", "addr", "open", "bytes", "next", "offset", "shift", "device", "Data", "code", "date", "new", "multi", "raw", "queue", "capacity", "slice", "pad", "missing", "batch", "length", "read", "address", "extra", "empty", "index", "cache", "value", "sample", "latest", "connection", "input", "delay", "first", "alpha", "memory", "id", "off", "a", "body", "after", "start", "result", "none", "da", "one", "timeout", "inner", "entry", "content"], "size": ["unit", "sec", "number", "send", "sum", "sn", "len", "count", "position", "ize", "weight", "cap", "channel", "large", "max", "set", "sized", "Size", "done", "from", "close", "ci", "name", "fee", "time", "mode", "pos", "sent", "speed", "args", "bytes", "SIZE", "next", "offset", "six", "code", "function", "core", "write", "capacity", "g", "member", "scene", "length", "shape", "address", "extra", "empty", "use", "cm", "source", "loc", "scale", "memory", "c", "body", "start", "small", "cl", "storage", "handle", "timeout", "content"], "buffer": ["cache", "BU", "buff", "base", "container", "context", "header", "null", "reference", "p", "cube", "ref", "document", "byte", "input", "raw", "interface", "config", "queue", "source", "buf", "Buffer", "slice", " Buffer", "loader", "file", "writer", "uffer", "window", "batch", "uf", "console", "server", "flow", "board", "result", "image", "cb", "channel", "b", "client", "bc", "reader", "FFER"], "last": ["next", "cache", "total", "value", "done", "base", "shift", "code", "j", "low", "close", "latest", "st", "p", "nd", "used", "first", "id", "se", "recent", "len", "orig", "Last", "full", "ul", "event", "est", "parent", "length", "since", "old", "after", "self", "prev", "current", "start", "style", "max", "tail", "cur", "cycle", "empty", "final", "use", "index"], "end": ["line", "next", "offset", "i", "all", "open", "enc", "END", "n", "close", "p", "nd", "ff", "append", "edge", "id", "z", "send", "limit", "ion", "ad", "len", "off", "stop", "v", "pos", "event", "est", "mid", "length", "c", "after", "start", "ending", "End", "max", "tail", "set", "address", "e", "empty", "x", "ended", "h", "en", "index"], "ctx": ["cu", "cc", "dc", "bc", "mac", "buff", "loc", "sync", "sc", "cf", "fc", "cmp", "context", "cs", "rc", "conv", "vc", "alloc", "exec", "ci", "fp", "connection", "ec", "xc", "config", "cam", "acl", "voc", "buf", "qa", "Context", "tc", "unc", "sci", "cv", "slice", "cp", "lc", "conn", "pc", "ca", "coll", " c", "cn", "window", "c", "ctrl", "nc", "kt", "jp", "cpu", "cb", "tx", "wcs", "que", "hw", "client", "ct", "cas", "uc", "cm", "anc"], "got_frame": ["wantayboot", "got_size", "gotacstroke", "done_pixel", "found_range", "got_boot", "want_boot", " got_line", "gotacelement", "gotaydate", "got67size", "found_frame", "gotNewobject", "got_object", "gotNewdate", "wantayframe", "done_frame", "gotNewpixel", "got_frames", " got_node", "doneaydate", " got_slice", "foundacelement", "wantaysequence", " got_window", "got___range", "want_frame", "done_date", "got_element", " got_frames", "doneaypixel", "got_pixel", "got___stroke", "done_object", "gotacframe", "got_range", "doneayframe", "gotaypixel", "foundacrange", "got_node", "got_window", "got_slice", "got67frame", "got___frame", "want_size", "got_date", "gotNewframe", "gotayobject", "foundacframe", "gotaysequence", "foundacstroke", "got_line", "got_stroke", "gotacrange", "found_stroke", "wantaysize", "found_element", "want_sequence", "gotayframe", "got_sequence", "gotayboot", "got67boot", "got67sequence", "doneayobject", "got___element", "gotaysize"], "frame": ["line", "fr", "next", "zip", "Frame", "base", "buff", "loc", "bug", "cf", "rame", "setup", "fc", "fi", "object", "context", "code", "fram", "layout", "p", "fp", "fl", "connection", "iframe", "dr", "config", "framework", "element", "fb", "slice", "event", "el", "fd", "file", "position", "coll", "window", "video", "ze", "frames", "c", "body", "nc", "point", "layer", "flow", "kt", "board", "cpu", "image", "cb", "ch", "pse", "b", "f", "que", "range", "live", "component", "e", "cycle", "flower", "fe"], "avpkt": ["avelrt", "avPft", "avpze", "avlelt", "akppkt", "avpaft", "avegkt", "avpsrt", "avpakt", "ajpkt", "avtpkt", "avlett", "avgelt", "akpkt", "avfacker", "avpkg", "aveprt", "avelelt", " avpacket", "ajppft", "affut", " avtpKT", " avtpcht", "avselt", "avlpkt", "avfett", "akpze", "avPke", "avPdr", "afpnt", "avpacker", "affelt", "avpft", "avnpqt", "avfnt", "aulpkt", "akppft", "afpelt", " avtpatch", "ajppacket", "avgkt", "avspacket", "avcpett", "avegcht", "affett", "avnpelt", "avpskg", "avncht", "avcpkt", "affacker", "avnkt", "avlpke", "avgcht", "avepelt", "avsdt", "affacket", "akpdt", "avpecht", "avlpacker", "akppdt", "avjput", "avegelt", "avskt", "avlpelt", "avnprt", "akpft", "afput", " avpett", "avppdt", "avlqt", "affqt", "affcht", "ajpdr", " avpatch", "avpeatch", "ajppdr", "avspelt", "avppacket", "avfcht", "avnpkg", "avfut", "aupacket", " avpqt", "avpKT", "avlpdt", "avlkg", "avgdt", "aupke", "avppkt", "avlacket", "avfacket", "avnKT", "avcpqt", "avpelt", "avnatch", " avpcht", "avpskt", "avPacket", "avepcht", "afpett", "avpdr", "avtpKT", "avnpcht", "avjpacket", "afpacker", "avpdt", "avfpke", "avlrt", " avtpkt", "avnpacket", "avpatch", "avfkt", "avjpkt", "avlput", "akppze", "avlpdr", "avfpkt", "avcpacket", " avnpqt", "avfpcht", "avlpft", "avepkt", "avprt", "avpcht", "avpacket", "avPcht", "avspkt", "avlpacket", "avepdt", "aulpke", "avlpnt", "avegdt", " avnpett", "avtpcht", "afpkt", "avspcht", "avepkg", "avnacket", "avpaze", "avppze", "avpke", "ajpft", "afpacket", "avnpkt", "avpnt", "avelkg", "avpett", "avscht", "avelkt", "afpqt", "avppft", "avfpacket", "avfelt", " avnpkt", "aupcht", "avput", "avnpett", "aulpcht", "avpeKT", "ajpacket", "afpcht", "aupkt", "avlpze", "avjpacker", "avtpatch", "avnnt", " avpKT", "avlkt", "avfqt", " avnpacket", "affnt", "avPkt", "avppdr", "avlpcht", "aulpacket", "affkt", "avpadt", "avpqt", "avpselt", "ajppkt", "avpekt"], "it": ["loop", "update", "i", "pit", "r", "loc", "ait", "IT", "ac", "l", "sit", "you", "j", "unit", "sec", "n", "axis", "p", "wait", "exec", "st", "opt", "fit", "ind", "quit", "split", "which", "ite", "id", "iter", "limit", "I", "stat", "rit", "lit", "ul", "format", "parent", "mit", "prev", "init", "info", "get", "t", "bin", "b", "It", "op", "u", "jit", "f", "edit", "its", "out", "ct", "qt", "bit", "ort"]}}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void op_cp1_64bitmode(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_FR))) {\n\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 2880, "substitutes": {}}
{"project": "qemu", "commit_id": "40f860cd6c1aa0d3399e3f8158f20bdc5b2bfbfe", "target": 0, "func": "void disas_a64_insn(CPUARMState *env, DisasContext *s)\n\n{\n\n    uint32_t insn;\n\n\n\n    insn = arm_ldl_code(env, s->pc, s->bswap_code);\n\n    s->insn = insn;\n\n    s->pc += 4;\n\n\n\n    switch ((insn >> 24) & 0x1f) {\n\n    default:\n\n        unallocated_encoding(s);\n\n        break;\n\n    }\n\n\n\n    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {\n\n        /* go through the main loop for single step */\n\n        s->is_jmp = DISAS_JUMP;\n\n    }\n\n}\n", "idx": 2884, "substitutes": {"env": ["req", "settings", "context", "enc", "ctx", "conf", "er", "eu", "ec", "viron", "config", "m", "stage", "esm", "v", "conn", "txt", "ea", "server", "iss", "np", "scope", "exc", "state", "args", "dict", "oa", "vs", "que", "err", "js", "e", "environment", "iv", "nw", "ev", "en"], "s": ["S", "i", "fs", "sets", "ts", "ns", "settings", "sup", "cs", "si", "ctx", "is", "n", "conf", "ssl", "qs", "o", "south", "p", "d", "m", "sq", "w", "v", "services", "sys", "g", "ps", "server", "ses", "sf", "spec", "c", "rs", "site", "es", "self", "sb", "gs", "sym", "args", "t", "b", "sg", "f", "os", "u", "storage", "ss", "js", "e", "ls", "ops", "ds", "sync"], "insn": ["lsf", "valsnc", "consnc", "insg", "innc", "alsne", "insyn", " insyn", "ansn", "linscn", " insN", "insi", "linsn", "incdn", " insdn", " insg", "inssn", "consc", "valsN", "ansc", "incf", "insnc", "consn", " inssn", "incl", "inna", "intsner", "insN", "valsyn", " insf", "linsN", " insner", "intsn", "alsn", "incner", "ansnc", "alsyn", "valsi", " insl", " insnc", "incg", "insner", "insc", "intsdn", "inn", "intssn", "lsg", "linsnc", "lsn", "valsn", "insna", "valsne", "incsn", "insl", "incn", "insf", "alsi", "insdn", " insi", "consna", "inscn", "valscn", " inscn", "inc", "lsl", " insne", "ansna", "insne"]}}
{"project": "qemu", "commit_id": "96d7073fb058e6f05257cd9041ffbbd736f6ccec", "target": 0, "func": "static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)\n\n{\n\n    switch(ot) {\n\n    case OT_BYTE:\n\n        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {\n\n            goto std_case;\n\n        } else {\n\n            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);\n\n            tcg_gen_ext8u_tl(t0, t0);\n\n        }\n\n        break;\n\n    default:\n\n    std_case:\n\n        tcg_gen_mov_tl(t0, cpu_regs[reg]);\n\n        break;\n\n    }\n\n}\n", "idx": 2895, "substitutes": {"ot": ["ac", "rt", "tt", "lot", "o", "pt", "ic", "gt", "fat", "ott", "iet", "oi", "et", "ol", "bot", "ut", "oto", "cot", "oot", "mot", "ant", "mt", "nt", "oid", "OT", "boot", "rot", "iot", "oc", "nat", "t", "os", "op", "dot", "pot", "not", "art", "ort"], "t0": [" t7", "et0", "l1", "f0", "f50", "t4", " t4", "p0", " T2", "p1", " t2", "t7", "pj", "l4", " T1", "g0", "t00", "p50", "p00", "t1", "t2", "p7", " T0", "T0", "T1", " t1", "et7", " t50", "et1", "l0", "gj", " t00", "f1", "g1", "t50", " tj", "tj", "T2", "et00", "p4"], "reg": ["mod", "val", "cod", "res", "bad", "gr", "loc", "tag", "rc", "code", "sec", "num", "debug", "ig", "index", "leg", "mem", "ind", "Reg", "ret", "typ", "stat", "orig", "rog", "org", "abc", "rec", "conn", "g", "rin", "pred", "eg", "spec", "port", "rg", "pre", "eng", "round", "rem", "greg", "mn", "col", "arg", "ng", "REG", "da", "re", "big", "region", "bit", "rol", "pg"]}}
{"project": "qemu", "commit_id": "54421cb17bc744bad15f2b1adb4adefdaea83c10", "target": 0, "func": "static int hdev_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    int access_flags, create_flags;\n\n    DWORD overlapped;\n\n    char device_name[64];\n\n\n\n    if (strstart(filename, \"/dev/cdrom\", NULL)) {\n\n        if (find_cdrom(device_name, sizeof(device_name)) < 0)\n\n            return -ENOENT;\n\n        filename = device_name;\n\n    } else {\n\n        /* transform drive letters into device name */\n\n        if (((filename[0] >= 'a' && filename[0] <= 'z') ||\n\n             (filename[0] >= 'A' && filename[0] <= 'Z')) &&\n\n            filename[1] == ':' && filename[2] == '\\0') {\n\n            snprintf(device_name, sizeof(device_name), \"\\\\\\\\.\\\\%c:\", filename[0]);\n\n            filename = device_name;\n\n        }\n\n    }\n\n    s->type = find_device_type(bs, filename);\n\n    \n\n    if ((flags & BDRV_O_ACCESS) == O_RDWR) {\n\n        access_flags = GENERIC_READ | GENERIC_WRITE;\n\n    } else {\n\n        access_flags = GENERIC_READ;\n\n    }\n\n    create_flags = OPEN_EXISTING;\n\n\n\n#ifdef QEMU_TOOL\n\n    overlapped = FILE_ATTRIBUTE_NORMAL;\n\n#else\n\n    overlapped = FILE_FLAG_OVERLAPPED;\n\n#endif\n\n    s->hfile = CreateFile(filename, access_flags, \n\n                          FILE_SHARE_READ, NULL,\n\n                          create_flags, overlapped, NULL);\n\n    if (s->hfile == INVALID_HANDLE_VALUE) \n\n        return -1;\n\n    return 0;\n\n}\n", "idx": 2903, "substitutes": {"bs": ["fs", "BS", "ns", "bid", "ts", "cs", "pb", "bb", "bes", "bps", "ab", "cms", "ins", "sa", "bos", "fb", "acs", "ros", "bi", "css", "ps", "us", "ses", "ks", "iss", "sb", "rs", "es", "obs", "gb", "outs", "gs", "abi", "vs", "b", "os", "aws", "ss", "ls", "bl", "bc", "lb", "ds", "cus"], "filename": ["database", "sword", "uri", "phrase", "via", "alias", "title", "maximum", "download", "fd", "feat", "position", "il", "whatever", "dll", "image", "json", "kj", "message", "params", "ename", "lua", "application", "name", "Filename", "fil", "route", "url", "nil", "kl", "kn", "directory", "username", "jpg", "fn", "ident", "nm", "ame", "dyl", "location", "document", "abl", "status", "named", "til", "txt", "length", "fax", "subject", "sheet", "size", "wl", "password", "source", "path", "binary", "utf", "fp", "connection", "which", "token", "metadata", "sequence", "word", "memory", "prefix", "file", "description", "sf", "initial", "files", "lace", "lvl"], "flags": ["ags", "FLAG", "ils", "lag", "ports", "comments", "properties", "settings", "fps", "types", "flag", "faces", "bits", "fields", "ints", "ids", "ings", "fee", "opens", "ages", "codes", "stats", "ensions", "states", "lines", "frames", "vals", "ats", "ants", "files", "options", "locks", "args", "features", "parts", "rules", "Flags", "links", "atts", "ops", "ffff"], "s": ["S", "i", "sv", "su", "sets", "ts", "ns", "settings", "cs", "is", "si", "uns", "conf", "ssl", "p", "ubs", "sq", "session", "status", "sn", "sa", "services", "sie", "states", "service", "sys", "g", "ps", "ses", "ks", "sb", "rs", "c", "es", "self", "gs", "state", "args", "vs", "b", "os", "storage", "utils", "ss", "js", "sl", "ls", "its", "ops", "ds", "bis", "sync"], "access_flags": [" access_ops", "access_requires", " access_forces", " access_links", "access___flags", "accesslexflags", "access_forces", "access_data", "sync_reads", "access___forces", "access_links", "access___requires", "accessionflags", "access___groups", "access67ops", "access67flags", "accessionreads", "access_groups", "access_dds", "accesslextypes", "access32data", "access_mask", "access_types", "access67mask", "access_reads", "synclexflags", " access_mask", " access_groups", "access32flags", "sync_types", "synclexreads", "accesslexreads", "sync_dds", "access32links", "synclextypes", "access_ops", " access_data", "accessiondds", "sync_flags", "accesslexdds", "accessiontypes", " access_requires", "synclexdds"], "create_flags": ["write_args", "create_args", "createingmails", " create___requires", "createingports", "write_requires", " create_requires", "create_requires", " create___flags", " create_mails", "create___mails", " create___ports", "access_Flags", "createingflags", "access_ants", " create_ports", "create___ports", "create___flags", "create_Flags", "create_ants", "create___requires", "create_ports", "write_flags", "create_mails", "createingrequires", " create___mails"], "overlapped": ["overLapped", "Overlcapping", "overlanded", "Overflanded", " Overflapped", "overflaped", "overpoved", "Overlapped", "overmLpped", "overlcapping", "overflapping", "Overflaped", "overllapping", "Overlcagged", "overlipped", "overflanded", "Overlpped", " Overlaped", "overmLapping", "overlagged", "overLagged", "overlpped", " Overflapping", "overpapped", " Overfloved", "overlcagged", "Overlapping", "overllanded", "overlaapped", "Overlipped", " Overloved", "overflapped", "overmLipped", "overloved", "overlapping", "overflagged", "overLoved", "overpaped", " Overlapping", "overflipped", "Overlagged", "Overflipped", "Overlcapped", "Overflapped", "Overlaped", "Overflapping", "overlcanded", "overpapping", "overlcaped", "overLaped", " Overlapped", "overllaped", "overflpped", "overLapping", "overmLapped", "Overlanded", "overllapped", "Overlcaped", "overlaipped", "overlaapping", " Overflaped", "Overflpped", "overlcapped", "overfloved", "overlaped"], "device_name": [" device_info", "devicefullinfo", "deviceacname", "device2name", "device_Name", "device_address", " device_part", " device_key", " device_path", "deviceapppath", "devicefullname", "device2address", "device_named", "device_conn", "dev_parent", "device_key", " device_address", "device2key", "device_n", "device_path", "deviceappname", "deviceappcode", "deviceacnamed", "device_info", "device_parent", " device_Name", " device_number", "deviceappparent", " device_label", "dev_named", "deviceablename", "deviceablen", "dev_path", "devicefulllabel", "dev_code", "device_code", "deviceableconn", "devicefullpath", "deviceappnamed", "deviceacparent", "dev_n", "device_label", "device_part", "dev_conn", "device_number", "dev_name"]}}
{"project": "qemu", "commit_id": "62deb62d999cf9e2be61272c6b720104f764bd6a", "target": 0, "func": "static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    SigpInfo *si = arg.host_ptr;\n\n\n\n    if (!s390_has_feat(S390_FEAT_VECTOR)) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);\n\n        return;\n\n    }\n\n\n\n    /* cpu has to be stopped */\n\n    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {\n\n        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);\n\n        return;\n\n    }\n\n\n\n    /* parameter must be aligned to 1024-byte boundary */\n\n    if (si->param & 0x3ff) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);\n\n        return;\n\n    }\n\n\n\n    cpu_synchronize_state(cs);\n\n\n\n    if (kvm_s390_store_adtl_status(cpu, si->param)) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);\n\n        return;\n\n    }\n\n    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n}\n", "idx": 2911, "substitutes": {"cs": ["cas", "cc", "fs", "sc", "cf", "ts", "ns", "rc", "settings", "ics", "ctx", "core", "qs", "vc", "ras", "ec", "cms", "acs", "sci", "cp", "sys", "pc", "cons", "css", "ps", "ks", "spec", "c", "CS", "gs", "args", "ck", "os", "ls", "sk", "ds", "lc", "s", "cus"], "arg": ["line", "cat", "val", "mac", "ac", "rc", "fi", "Arg", "enc", "flag", "conf", "arc", "cell", "ig", "param", "or", "ec", "gc", " argument", "pc", "g", "data", "str", "ag", "argument", "spec", "ar", "in", "self", "reg", "rg", "result", "ace", "args", "proc", "nic", "inc", "doc", "ark", "parse", "bc", " args"], "cpu": ["clock", "cu", "mac", "fc", "fi", "uci", "ctx", "cm", "linux", "core", "cmp", "ci", "eni", "cli", "config", "gp", "vm", "sci", "px", "cp", "gpu", "sys", "pc", "conn", "cn", "css", "spec", "c", "nc", "np", "pu", "cow", "mc", "proc", "nic", "CPU", "chip", "lb", "processor", "lc"], "si": ["chi", "i", "ui", "agi", "su", "fi", "ci", "sim", "eni", "cci", "mi", "sn", "shi", "sa", "ini", "ii", "sis", "sci", "bi", "sie", "sys", "li", "pc", "ati", "ie", "iu", "ami", "spec", "sb", "Si", "zi", "di", "ai", "asi", "SI", "ski", "sd", "gi", "ti", "ni", "esi", "ki", "yi", "isi"]}}
{"project": "qemu", "commit_id": "ff1d1977ffe1c276f5937a6ad4b6a5b6d2b1c6ae", "target": 0, "func": "static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    target_ulong tmp;\n\n\n\n    tmp = ldtul_p(mem_buf);\n\n\n\n    if (n < 32) {\n\n        env->active_tc.gpr[n] = tmp;\n\n        return sizeof(target_ulong);\n\n    }\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)\n\n            && n >= 38 && n < 73) {\n\n        if (n < 70) {\n\n            if (env->CP0_Status & (1 << CP0St_FR))\n\n              env->active_fpu.fpr[n - 38].d = tmp;\n\n            else\n\n              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp;\n\n        }\n\n        switch (n) {\n\n        case 70:\n\n            env->active_fpu.fcr31 = tmp & 0xFF83FFFF;\n\n            /* set rounding mode */\n\n            RESTORE_ROUNDING_MODE;\n\n#ifndef CONFIG_SOFTFLOAT\n\n            /* no floating point exception for native float */\n\n            SET_FP_ENABLE(env->active_fpu.fcr31, 0);\n\n#endif\n\n            break;\n\n        case 71: env->active_fpu.fcr0 = tmp; break;\n\n        }\n\n        return sizeof(target_ulong);\n\n    }\n\n    switch (n) {\n\n    case 32: env->CP0_Status = tmp; break;\n\n    case 33: env->active_tc.LO[0] = tmp; break;\n\n    case 34: env->active_tc.HI[0] = tmp; break;\n\n    case 35: env->CP0_BadVAddr = tmp; break;\n\n    case 36: env->CP0_Cause = tmp; break;\n\n    case 37: env->active_tc.PC = tmp; break;\n\n    case 72: /* fp, ignored */ break;\n\n    default: \n\n\tif (n > 89)\n\n\t    return 0;\n\n\t/* Other registers are readonly.  Ignore writes.  */\n\n\tbreak;\n\n    }\n\n\n\n    return sizeof(target_ulong);\n\n}\n", "idx": 2913, "substitutes": {"env": ["po", "enc", "conf", "er", "sec", "eu", "ec", "exe", "output", "lv", "ef", "exc", "que", "dev", "inc", "environment", "Environment", "exec", "eni", "config", "stage", "vm", "et", "org", "fen", "cdn", "cv", "event", "el", "erv", "data", "site", "app", "eng", "ee", "init", "err", "net", "ev", "ce", "context", "code", "ctx", "core", "session", "obj", "engine", "loader", "conn", "txt", "server", "me", "dt", "enable", "global", "extra", "e", "cache", "equ", "viron", "edge", "end", "inet", "ext", "eb", "ne", "console", "ea", "export", "nc", "np", "oa", "db", "qt", "hw", "en"], "mem_buf": ["mem_buff", "mem_buffer", "mem2buff", "memory_buffer", " mem_buffer", " mem_buff", " mem_cb", "memory_uf", "memmemwb", "memmembuf", "memmembuffer", "mem2buffer", "memory_wb", "memmemuf", "mem_uf", "memory_buf", "mem2buf", "mem2cb", "mem_cb", "mem_wb"], "n": ["fn", "i", " N", "nm", "r", "ns", "un", "l", "syn", "j", "num", "o", "p", "number", "nn", "node", "non", "d", "m", "min", "rn", "name", "adj", "z", "sn", "s", "w", "note", "not", "len", "no", "an", "nor", "v", "nb", "conn", "g", "ne", "sign", "cn", "dn", "c", "nt", "in", "nu", "nc", "np", "pn", "mn", "network", "nat", "nl", "t", "ng", "b", "none", "f", "u", "na", "ni", "N", "e", "x", "net", "en"], "tmp": ["rb", "buff", "att", "cmp", "array", "pb", "temp", "TB", "tf", "tem", "v", "sp", "output", "sb", "appy", "jp", "boot", "cb", "proc", "f", "wb", "s", "bt", "vt", "cpp", "option", "p", "config", "append", "buf", "dest", "data", "prop", "app", "pp", "nt", "test", "now", "b", "err", "tab", "tm", "zip", "tp", "nm", "mp", "bp", "kk", "var", "obj", "stuff", "pad", "cp", "nb", "front", "txt", "pre", "t", "source", "desc", "yy", "cache", "su", "attr", " np", "loc", "bb", "fp", "job", "api", "fb", "fake", "verb", "tc", "emp", "np", "result", "storage"]}}
{"project": "qemu", "commit_id": "3ba235a02284c39b34a68a2a588508ffb52a7b55", "target": 0, "func": "QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)\n\n{\n\n    QEMUBH *bh;\n\n    bh = g_malloc0(sizeof(QEMUBH));\n\n    bh->ctx = ctx;\n\n    bh->cb = cb;\n\n    bh->opaque = opaque;\n\n    qemu_mutex_lock(&ctx->bh_lock);\n\n    bh->next = ctx->first_bh;\n\n    /* Make sure that the members are ready before putting bh into list */\n\n    smp_wmb();\n\n    ctx->first_bh = bh;\n\n    qemu_mutex_unlock(&ctx->bh_lock);\n\n    return bh;\n\n}\n", "idx": 2914, "substitutes": {"ctx": ["kb", "kw", "support", "cache", "cc", "cu", "pkg", "req", "loc", "sc", "cf", "cpp", "cmp", "context", "cs", "grad", "conf", "conv", "qs", "cca", "vc", "fp", "exec", "ci", "ref", "src", "xc", "cli", "config", "sq", "acl", "obj", "buf", "qa", "Context", "tc", "sci", "cv", "cp", "lc", "conn", "pc", "ca", "cn", "parent", "fw", "c", "ctrl", "nc", "jp", "ch", "tx", "cmd", "cl", "hw", "ctr", "bc", "cfg", "cas", "sync", "cm", "cus"], "cb": ["fn", "bf", "loop", "cod", "rb", "cr", "done", "closure", "req", "buff", "cf", "cpp", "cmp", "rc", "pb", "bb", "function", "code", "core", "conv", "conf", "fp", "kk", "src", "obb", "Callback", "obj", "desc", "buf", "fb", "unc", "cv", "cp", "func", "pc", "conn", "abb", "callback", "ctrl", "nc", "gb", "ob", "db", "cmd", "ctr", "bc", "cfg", "cd", "CB"], "opaque": ["boque", "obatile", "operque", "opatile", "opesc", "opace", " opace", "pyacity", "opque", " opque", "obaque", "boacity", "pyesc", " opatile", "compace", "operacity", " opacity", "boaque", "opaques", "operaques", "compatile", "pyaques", "compaque", "operesc", "opacity", "obque", "compque", "obaques", "pyaque", "obacity", "obesc", "operaque", "obace"], "bh": ["hm", "kb", "bf", "wd", "rb", "sth", "pkg", "rh", "BT", "bp", "cpp", "hs", "xb", "pb", "hh", "bb", "gh", "sh", "adh", "ht", "fp", "hap", "ib", "bg", "zh", " dh", "obb", "bs", "sq", "mr", "hl", "fb", "kh", "bi", "uh", "ang", "ah", "abb", "batch", " kb", "hub", "sb", "ph", "gb", "dh", "ch", "aph", "ih", "abi", "hp", "b", "db", " ah", "bl", "bc", "lb", "phi", "bm", "bt", "h"]}}
{"project": "FFmpeg", "commit_id": "37013fd018ae02679f177f42245f3e0e3c12d587", "target": 0, "func": "static void audiogen(void *data, enum AVSampleFormat sample_fmt,\n\n                     int channels, int sample_rate, int nb_samples)\n\n{\n\n    int i, ch, k;\n\n    double v, f, a, ampa;\n\n    double tabf1[SWR_CH_MAX];\n\n    double tabf2[SWR_CH_MAX];\n\n    double taba[SWR_CH_MAX];\n\n    unsigned static rnd;\n\n\n\n#define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v);\n\n#define uint_rand(x) (x = x * 1664525 + 1013904223)\n\n#define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1)\n\n    k = 0;\n\n\n\n    /* 1 second of single freq sinus at 1000 Hz */\n\n    a = 0;\n\n    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {\n\n        v = sin(a) * 0.30;\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n        a += M_PI * 1000.0 * 2.0 / sample_rate;\n\n    }\n\n\n\n    /* 1 second of varying frequency between 100 and 10000 Hz */\n\n    a = 0;\n\n    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {\n\n        v = sin(a) * 0.30;\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n        f  = 100.0 + (((10000.0 - 100.0) * i) / sample_rate);\n\n        a += M_PI * f * 2.0 / sample_rate;\n\n    }\n\n\n\n    /* 0.5 second of low amplitude white noise */\n\n    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {\n\n        v = dbl_rand(rnd) * 0.30;\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n    }\n\n\n\n    /* 0.5 second of high amplitude white noise */\n\n    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {\n\n        v = dbl_rand(rnd);\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n    }\n\n\n\n    /* 1 second of unrelated ramps for each channel */\n\n    for (ch = 0; ch < channels; ch++) {\n\n        taba[ch]  = 0;\n\n        tabf1[ch] = 100 + uint_rand(rnd) % 5000;\n\n        tabf2[ch] = 100 + uint_rand(rnd) % 5000;\n\n    }\n\n    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            v = sin(taba[ch]) * 0.30;\n\n            PUT_SAMPLE\n\n            f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * i) / sample_rate);\n\n            taba[ch] += M_PI * f * 2.0 / sample_rate;\n\n        }\n\n    }\n\n\n\n    /* 2 seconds of 500 Hz with varying volume */\n\n    a    = 0;\n\n    ampa = 0;\n\n    for (i = 0; i < 2 * sample_rate && k < nb_samples; i++, k++) {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            double amp = (1.0 + sin(ampa)) * 0.15;\n\n            if (ch & 1)\n\n                amp = 0.30 - amp;\n\n            v = sin(a) * amp;\n\n            PUT_SAMPLE\n\n            a    += M_PI * 500.0 * 2.0 / sample_rate;\n\n            ampa += M_PI *  2.0 / sample_rate;\n\n        }\n\n    }\n\n}\n", "idx": 2929, "substitutes": {"data": ["draw", "model", "cache", "database", "sample", "Data", "array", "binary", "o", "p", "input", "d", "m", "dat", "memory", "buffer", "window", "batch", "output", "results", "result", "image", "DATA", "da", "x"], "sample_fmt": ["sample_cformat", "sample_fld", "sample_cld", "sample_cmt", "sample_frld", "sample_clt", "sample_frmt", "sample_fformat", "sample_formlt", "sample_frlt", "sample_frformat", "sample_formmt", "sample_formformat", "sample_formld", "sample_flt"], "channels": ["achars", "chunks", "shapters", "thannels", "chones", "chambers", "chograms", "Channels", "chnunks", "thords", "shannels", "Chords", "shograms", "corapters", "echores", "echannels", " chars", "ichannels", "quannels", "chords", "ichapters", "champles", "chars", " chograms", "thamples", "quars", "thapters", "quores", "coramples", "chnamples", "shars", "quambers", "shords", "Chapters", "cheannels", "chnords", "chnambers", "echunks", "cheamples", "quords", "corannels", "achograms", " chores", "achores", "Chones", "Champles", "chnannels", "chapters", "shores", "shunks", "cheapters", "ichones", "chnones", "ichamples", "quunks", "chores", "echars", "cheunks", " chunks", "ichunks", "chnapters", "shamples", "achannels", "corords", "shambers"], "sample_rate": [" sample_mode", "sampleprerate", "sample_rat", "sample_mode", " sample_rating", "sample2scale", " sample_step", "sample_rated", "sample_time", " sample_time", "sample_width", "sampleacdata", "sample__rate", "sample64type", "sample64rated", "sample_currency", "software_rat", "system_rated", "system_type", "sample_rates", "software_rates", " sample_term", "samplefscale", "sample64rate", " sample_rated", "system_rate", "sample_scale", " sample_scale", "samplepreterm", "sample2rates", "software_rate", " sample_rates", "system_currency", "sample__rated", " sample_data", "sample64currency", "sample__rates", "sample2mode", "samplefmode", "sampleprerates", "sample_term", "sample_step", "sampleacrates", "samplefrates", " sample_width", "sample_type", "sampleacrated", "sampleprerated", "sample_data", "sample__step", "sampleacrate", "samplefrate", "sample_region", "sample_rating", "sample2rate", "software_region"], "nb_samples": ["nb_tites", "nb_bamps", "nb_Samps", "nb_tessions", "nb_cites", "nb_tances", "nb_mamples", "nb_servicesources", "nb_mites", "nb_sessions", "nb_messions", "nb_stamps", "nb_smodels", "nb_sources", "nb_scipes", "nb_nipes", "nb_cessions", "nb_Sources", "nb_bances", "nb_nources", "nb_samps", "nb_servicesamps", "nb_lances", "nb_lamples", "nb_Samples", "nb_stams", "nb_tams", "nb_Smodels", "nb_servicesmodels", "nb_camples", "nb_namps", "nb_mamps", "nb_sances", "nb_taves", "nb_nmodels", "nb_tamples", "nb_Sannels", "nb_bairs", "nb_scamples", "nb_tipes", "nb_tamps", "nb_saves", "nb_stannels", "nb_lairs", "nb_sairs", "nb_sipes", "nb_stamples", "nb_tairs", "nb_scamps", "nb_naves", "nb_sites", "nb_sannels", "nb_scaves", "nb_camps", "nb_tannels", "nb_sams", "nb_namples", "nb_lamps", "nb_servicesamples", "nb_bamples", "nb_Sams"], "i": ["phi", "chi", "ui", "anti", "ir", "io", "r", "l", "ik", "rc", "ia", "si", "j", "n", "uri", "sh", "y", "p", "ci", "ic", "qi", "d", "m", "mi", "z", "id", "alpha", "ri", "ini", "ii", "bi", "x", "mini", "li", "iu", "ie", "c", "in", "zi", "di", "ix", "ai", "info", "init", "ih", "pi", "b", "u", "gi", "ti", "ip", "ni", "e", "xi", "I", "it", "ki", "yi", "my"], "ch": ["chi", "part", "Ch", "gh", "ky", "z", "chn", "kick", "th", "cht", "ah", "bh", "channel", "pi", "col", "cel", "br", "cher", "rh", "l", "y", "p", "ci", "zh", "ach", "el", "ph", "app", "arch", "uch", "b", "q", "u", "chid", "sk", "cor", "h", "com", "sc", "sch", "code", "chan", "sh", "core", "m", "w", "cp", "ich", "conn", "g", "batch", "cho", "ver", "cur", "child", "e", "cm", "ech", "form", "rc", "j", "qu", "CH", "chart", "work", "c", "cha", "och", "anch", "cl", "che", "x"], "k": ["ek", "kw", "ko", "ke", "K", "r", "ok", "ik", "l", "j", "n", "gh", "sh", "y", "o", "p", "kk", "ky", "key", "ka", "m", "uk", "z", "w", "ad", "an", "kh", "kick", "dk", "th", "g", "ks", "work", "mk", "c", "ph", "he", "ck", "ku", "kn", "t", "b", "q", "u", "ak", "e", "sk", "x", "it", "ki", "h"], "v": ["uv", "vo", "val", "av", "value", "sv", "l", "j", "n", "conv", "y", "ve", "o", "p", "va", "d", "m", "z", "V", "w", "vol", "cv", "tv", "g", "ev", "c", "lv", "nv", "vp", "vi", "vert", "vs", "t", "b", "u", "q", "dev", "ver", "e", "iv", "x", "h", "vv"], "f": ["fr", "inf", "fs", "r", "form", "ac", "l", "fc", "j", "n", "y", "o", "fp", "p", "ff", "d", "m", "af", "tf", "z", "w", "fb", "g", "sf", "c", "fa", "info", "fx", "t", "u", "q", "b", "e", "x", "F", "fe", "h"], "a": ["wa", "action", "ac", "ia", "ta", "n", "y", "o", "at", "p", "ab", "A", "z", "va", "d", "m", "aj", "af", "sta", "alpha", "ga", "api", "access", "ma", "ae", "w", "sa", "ba", "ad", "an", "area", "aw", "mA", "aa", "am", "ata", "ca", "ea", "c", "fa", "ai", "la", "aaa", "audio", "as", "asa", "b", "u", "ak", "au", "e", "x", "h", "s"], "ampa": ["cc", "r", "ac", "rc", "iii", "bb", "temp", "o", "ci", "ab", "A", "va", "ga", "z", "w", "abc", "bi", "bar", "g", "sb", "c", " b", "vi", "q", "e", "iv", "h"], "tabf1": ["tabf01", "tabp4", "tabp3", "abf3", "tabsf3", "tabbb", "dbf3", "dbsfb", "tabc4", "abb1", "dbsf3", "tabc1", "tabf3", "tabc2", "tabsf01", "abb4", "dbf1", "tabsfb", "tabfb", "abf1", "tabb4", "tabb3", "tabp2", "abf2", "abf4", "dbsf01", "abb3", "dbfb", "tabb2", "tabsf1", "tabc3", "tabp1", "tabcb", "tabb1", "dbsf1", "tabf4", "tabc01", "abb2", "tabb01", "dbf01"], "tabf2": ["tabp4", "Tabf4", "tabc32", "tabf0", "tabp32", "tabp0", "tabc4", "Tabv0", "tabc2", "tabp2", "Tabv4", "Tabf0", "tabv0", "Tabv2", "tabv4", "Tabf2", "tabf32", "tabv2", "tabc0", "tabf4", "tabv32", "Tabv32", "Tabf32"], "taba": ["formaa", "tableA", "tablea", "tabalpha", "rowb", "tableb", "rowaa", " tabaa", "loopalpha", "forma", "abA", "tableaa", "tabA", "loopaa", "formalpha", "abb", "loopA", " tabA", "tabb", "loopa", " tabalpha", "abaa", "aba", "rowA", "tabaa", "rowa", "formA"], "rnd": ["Rwin", "rng", "urandi", "Rng", " randi", "prng", "nrng", "Randi", "randi", "rwin", "RNG", "rnt", "urng", " rnt", "rNG", " rng", "nrnt", "Rnt", "Rrand", " rrand", "Rnd", " rNG", "urrand", "nrnd", "urnd", " rwin", "nrwin", "prrand", "rrand", "prnd", "prNG"]}}
{"project": "FFmpeg", "commit_id": "ea97859c8c218b83ab747a7eabcb88ca446f6751", "target": 1, "func": "static void paint_mouse_pointer(AVFormatContext *s1, struct gdigrab *gdigrab)\n\n{\n\n    CURSORINFO ci = {0};\n\n\n\n#define CURSOR_ERROR(str)                 \\\n\n    if (!gdigrab->cursor_error_printed) {       \\\n\n        WIN32_API_ERROR(str);             \\\n\n        gdigrab->cursor_error_printed = 1;      \\\n\n    }\n\n\n\n    ci.cbSize = sizeof(ci);\n\n\n\n    if (GetCursorInfo(&ci)) {\n\n        HCURSOR icon = CopyCursor(ci.hCursor);\n\n        ICONINFO info;\n\n        POINT pos;\n\n        RECT clip_rect = gdigrab->clip_rect;\n\n        HWND hwnd = gdigrab->hwnd;\n\n        info.hbmMask = NULL;\n\n        info.hbmColor = NULL;\n\n\n\n        if (ci.flags != CURSOR_SHOWING)\n\n            return;\n\n\n\n        if (!icon) {\n\n            /* Use the standard arrow cursor as a fallback.\n\n             * You'll probably only hit this in Wine, which can't fetch\n\n             * the current system cursor. */\n\n            icon = CopyCursor(LoadCursor(NULL, IDC_ARROW));\n\n        }\n\n\n\n        if (!GetIconInfo(icon, &info)) {\n\n            CURSOR_ERROR(\"Could not get icon info\");\n\n            goto icon_error;\n\n        }\n\n\n\n        pos.x = ci.ptScreenPos.x - clip_rect.left - info.xHotspot;\n\n        pos.y = ci.ptScreenPos.y - clip_rect.top - info.yHotspot;\n\n\n\n        if (hwnd) {\n\n            RECT rect;\n\n\n\n            if (GetWindowRect(hwnd, &rect)) {\n\n                pos.x -= rect.left;\n\n                pos.y -= rect.top;\n\n            } else {\n\n                CURSOR_ERROR(\"Couldn't get window rectangle\");\n\n                goto icon_error;\n\n            }\n\n        }\n\n\n\n        av_log(s1, AV_LOG_DEBUG, \"Cursor pos (%li,%li) -> (%li,%li)\\n\",\n\n                ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y);\n\n\n\n        if (pos.x >= 0 && pos.x <= clip_rect.right - clip_rect.left &&\n\n                pos.y >= 0 && pos.y <= clip_rect.bottom - clip_rect.top) {\n\n            if (!DrawIcon(gdigrab->dest_hdc, pos.x, pos.y, icon))\n\n                CURSOR_ERROR(\"Couldn't draw icon\");\n\n        }\n\n\n\nicon_error:\n\n\n\n\n\n        if (icon)\n\n            DestroyCursor(icon);\n\n    } else {\n\n        CURSOR_ERROR(\"Couldn't get cursor info\");\n\n    }\n\n}", "idx": 2946, "substitutes": {"s1": ["s01", "ms2", "c1", "sg2", "sg1", "c3", "c6", "c01", "sg01", "ms1", "s7", "s6", " s7", "f2", "sg6", "ms6", "f7", "ms01", " s3", "c7", " s2", "s3", "f3", "f1", "c2", "s2"], "gdigrab": ["gdibrabb", "gdibrabs", "sdircabo", "gdigerabs", "gdarinabi", "gdibrabe", "sdibrabe", "eddigrab", "hdyrab", "gdyrabb", "gdyrob", "hdigralog", "gdigrationabi", "sdigrabi", "gdrigob", "hdigrateab", "gdircabo", "hdigrabb", "gdigrationab", "sdigrub", "gdigerab", "gdibrob", "gdyrab", "gdibrabo", "gdigrationub", "hdigrateabs", "gdircab", "sdigrabo", "gdigrabs", "gdrigabs", "gdirmab", "hdigrabo", "gdatarab", "sdircab", "hdigrob", "gdarinabo", "gdarinab", "gdigrateob", "sdibrab", "sdircabi", "hdyrabs", "gdatarabs", "gdibrabi", "hdigrab", "gdigrabb", "gdigrateabs", "eddibrabe", "gdibrab", "gdigerob", "hdigrabs", "gdatarabo", "sdigrab", "gdrigabi", "eddigrabe", "gdyrabs", "gdigrob", "gdigrationabe", "gdrigab", "gdigrabi", "hdyrabb", "sdibrub", "gdyrabe", "gdircabi", "gdirmabe", "hdyrabo", "gdigratealog", "sdigrabe", "gdrigalog", "gdirmob", "eddibrob", "gdigralog", "gdrigabe", "gdigeralog", "gdatarabb", "gdigrub", "eddibrab", "gdibrub", "hdigrateob", "gdrigub", "eddigrob", "gdigrateab", "gdyrabo", "gdigrabo", "gdigrabe", "gdrigabo", "hdigratealog", "sdibrabi"], "info": ["information", "hi", "comment", "about", "inf", "offset", "i", "all", "ui", "part", "Info", "text", "io", "loc", "bug", "error", "hand", "fi", "object", "si", "function", "conf", "ani", "ci", "http", "alias", "fo", "of", "config", "obj", "icon", "source", "api", "id", "name", "time", "stat", "area", "ii", "handler", "event", "py", "end", " INFO", "link", "type", "li", "off", "data", "ami", "txt", "path", "in", "inner", "util", "di", "ix", "init", "result", "image", "inter", "f", "op", "extra", "open", "INFO", "index"], "pos": [" response", "text", "vis", "part", "po", "opt", "ref", " src", "len", "bot", "feat", "position", " trans", "sp", "ps", "parent", "plus", "block", "os", "push", "doc", " loc", "rad", "post", "pull", "res", "press", "pick", "is", "axis", "p", "tip", "config", "min", "pid", "on", "prop", "data", "port", "point", "style", "op", "open", "line", "offset", "patch", " data", " POS", "act", "Pos", "lat", "obj", " position", "pop", " p", " positions", "pad", "trans", " error", "pro", "spec", " Pos", "ss", "index", "val", "cache", "neg", "loc", "def", " img", "POS", " index", "pl", "pt", " LA", "no", "px", "off", "type", "in", "start", " prop", "pres", " offset", "pass", "x", "pose"], "rect": ["Rect", "tri", "text", "loc", "attr", "r", "project", "patch", "rc", "ptr", "object", "rt", "prot", "tr", "dir", "grad", "pt", "RECT", "src", "lat", "radius", "ect", "area", "slice", "pad", "contract", "rat", "type", "feat", "data", "coll", "txt", "row", "shape", "port", "url", "map", "image", "block", "col", "rot", "box", "coord", "cont", "client", "region", "round", "path"]}}
{"project": "qemu", "commit_id": "75cc7f018328e708d94cca23c3a77e85363f25dc", "target": 1, "func": "static void machine_initfn(Object *obj)\n\n{\n\n    MachineState *ms = MACHINE(obj);\n\n\n\n    ms->kernel_irqchip_allowed = true;\n\n    ms->kvm_shadow_mem = -1;\n\n    ms->dump_guest_core = true;\n\n\n\n\n    object_property_add_str(obj, \"accel\",\n\n                            machine_get_accel, machine_set_accel, NULL);\n\n    object_property_set_description(obj, \"accel\",\n\n                                    \"Accelerator list\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"kernel-irqchip\",\n\n                             NULL,\n\n                             machine_set_kernel_irqchip,\n\n                             NULL);\n\n    object_property_set_description(obj, \"kernel-irqchip\",\n\n                                    \"Use KVM in-kernel irqchip\",\n\n                                    NULL);\n\n    object_property_add(obj, \"kvm-shadow-mem\", \"int\",\n\n                        machine_get_kvm_shadow_mem,\n\n                        machine_set_kvm_shadow_mem,\n\n                        NULL, NULL, NULL);\n\n    object_property_set_description(obj, \"kvm-shadow-mem\",\n\n                                    \"KVM shadow MMU size\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"kernel\",\n\n                            machine_get_kernel, machine_set_kernel, NULL);\n\n    object_property_set_description(obj, \"kernel\",\n\n                                    \"Linux kernel image file\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"initrd\",\n\n                            machine_get_initrd, machine_set_initrd, NULL);\n\n    object_property_set_description(obj, \"initrd\",\n\n                                    \"Linux initial ramdisk file\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"append\",\n\n                            machine_get_append, machine_set_append, NULL);\n\n    object_property_set_description(obj, \"append\",\n\n                                    \"Linux kernel command line\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dtb\",\n\n                            machine_get_dtb, machine_set_dtb, NULL);\n\n    object_property_set_description(obj, \"dtb\",\n\n                                    \"Linux kernel device tree file\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dumpdtb\",\n\n                            machine_get_dumpdtb, machine_set_dumpdtb, NULL);\n\n    object_property_set_description(obj, \"dumpdtb\",\n\n                                    \"Dump current dtb to a file and quit\",\n\n                                    NULL);\n\n    object_property_add(obj, \"phandle-start\", \"int\",\n\n                        machine_get_phandle_start,\n\n                        machine_set_phandle_start,\n\n                        NULL, NULL, NULL);\n\n    object_property_set_description(obj, \"phandle-start\",\n\n                                    \"The first phandle ID we may generate dynamically\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dt-compatible\",\n\n                            machine_get_dt_compatible,\n\n                            machine_set_dt_compatible,\n\n                            NULL);\n\n    object_property_set_description(obj, \"dt-compatible\",\n\n                                    \"Overrides the \\\"compatible\\\" property of the dt root node\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"dump-guest-core\",\n\n                             machine_get_dump_guest_core,\n\n                             machine_set_dump_guest_core,\n\n                             NULL);\n\n    object_property_set_description(obj, \"dump-guest-core\",\n\n                                    \"Include guest memory in  a core dump\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"mem-merge\",\n\n                             machine_get_mem_merge,\n\n                             machine_set_mem_merge, NULL);\n\n    object_property_set_description(obj, \"mem-merge\",\n\n                                    \"Enable/disable memory merge support\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"usb\",\n\n                             machine_get_usb,\n\n                             machine_set_usb, NULL);\n\n    object_property_set_description(obj, \"usb\",\n\n                                    \"Set on/off to enable/disable usb\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"firmware\",\n\n                            machine_get_firmware,\n\n                            machine_set_firmware, NULL);\n\n    object_property_set_description(obj, \"firmware\",\n\n                                    \"Firmware image\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"iommu\",\n\n                             machine_get_iommu,\n\n                             machine_set_iommu, NULL);\n\n    object_property_set_description(obj, \"iommu\",\n\n                                    \"Set on/off to enable/disable Intel IOMMU (VT-d)\",\n\n                                    NULL);\n\n\n\n    /* Register notifier when init is done for sysbus sanity checks */\n\n    ms->sysbus_notifier.notify = machine_init_notify;\n\n    qemu_add_machine_init_done_notifier(&ms->sysbus_notifier);\n\n}", "idx": 2950, "substitutes": {"obj": ["xxx", "rb", "att", "po", "alt", "lib", "key", "obb", "stat", "bot", "ut", "cn", "sb", "ob", "cb", "Obj", "os", "this", "js", "so", "br", "inst", "object", "o", "tmp", "bo", "node", "aj", "tk", "ad", "org", "cdn", "pos", "ass", "el", "data", "nt", "current", "now", "kl", "objects", "b", "op", "ct", "ops", "fn", "oss", "od", "ctx", "code", "active", "core", "act", "m", "oi", "bs", "element", "nb", "conn", "jet", "str", "obo", "old", "oid", "cat", "attr", "ns", "orb", "j", "n", "pl", "module", "id", "api", "off", "class", "func", "self", "eff", "oa", "instance", "Object"], "ms": ["hm", "md", "mod", "fs", "nm", "mes", "mac", "mp", "ts", "ns", "cs", "si", "pm", "mos", "m", "bs", "MS", "ems", "mr", "ma", "fm", "mm", "acs", "mb", "ans", "rm", "pc", "arms", "arm", "sp", "ps", "ks", "me", "es", "gm", "mn", "mx", "mc", "Ms", "gs", "em", "vs", "os", "sm", "utils", "ss", "ls", "mg", "s"]}}
{"project": "qemu", "commit_id": "d22b2f41c470067758b3636a01b452dfeda7069f", "target": 1, "func": "void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->peer);\n\n\n\n    /* remove from list, if necessary */\n\n    if (bs->device_name[0] != '\\0') {\n\n        QTAILQ_REMOVE(&bdrv_states, bs, list);\n\n    }\n\n\n\n    bdrv_close(bs);\n\n    if (bs->file != NULL) {\n\n        bdrv_delete(bs->file);\n\n    }\n\n\n\n    assert(bs != bs_snapshots);\n\n    qemu_free(bs);\n\n}\n", "idx": 2958, "substitutes": {"bs": ["banks", "fs", "las", "base", "BS", "ns", "bid", "cs", "pb", "bb", "bes", "null", "bits", "bps", "ubs", "ras", "ab", "bing", "obj", "blocks", "lbs", "fb", "bos", "ba", "bot", "abc", "bi", "stats", "css", "ps", "boxes", "ses", "ks", "sb", "iss", "obs", "gb", "bh", "files", "gs", "bytes", "abi", "cb", "state", "Bs", "vs", "db", "b", "os", "as", "bas", "ss", "js", "ls", "bl", "bc", "lb", "ds", "bis", "sync", "bu", "s"]}}
{"project": "qemu", "commit_id": "dde3a2184074f5c4279fd7fbfc597b5dc5859fb8", "target": 1, "func": "static void hmp_migrate_status_cb(void *opaque)\n\n{\n\n    MigrationStatus *status = opaque;\n\n    MigrationInfo *info;\n\n\n\n    info = qmp_query_migrate(NULL);\n\n    if (!info->has_status || strcmp(info->status, \"active\") == 0) {\n\n        if (info->has_disk) {\n\n            int progress;\n\n\n\n            if (info->disk->remaining) {\n\n                progress = info->disk->transferred * 100 / info->disk->total;\n\n            } else {\n\n                progress = 100;\n\n            }\n\n\n\n            monitor_printf(status->mon, \"Completed %d %%\\r\", progress);\n\n            monitor_flush(status->mon);\n\n        }\n\n\n\n        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);\n\n    } else {\n\n        if (status->is_block_migration) {\n\n            monitor_printf(status->mon, \"\\n\");\n\n        }\n\n        monitor_resume(status->mon);\n\n        timer_del(status->timer);\n\n        g_free(status);\n\n    }\n\n\n\n    qapi_free_MigrationInfo(info);\n\n}\n", "idx": 2967, "substitutes": {"opaque": ["ovaques", "operque", "copacity", "opque", "obaque", "copaques", "oque", "oaques", "copque", "ovacity", "operacity", "ovque", "opaques", "operaques", "oaque", "oacity", "ovaque", "opacity", "obque", "obaques", "obacity", "copaque", "operaque"], "status": ["update", "num", "temp", "check", "stat", "sp", "complete", "plugin", "image", "state", "json", "js", "message", "msg", "s", "error", "si", "details", "name", "stage", "method", "STAT", "mode", "stats", "success", "data", "site", "scope", "style", "args", "serv", "sync", "comment", "reason", "uses", "base", "content", "settings", "code", "date", "active", "full", "service", "str", "server", "spec", "summary", "size", "index", "source", "user", "model", "cache", "fs", "action", "wait", "module", "token", "job", "id", "api", "note", "prefix", "sys", "description", "login", "result", "gi", "version", "score", "order", "Status"], "info": ["update", "i", "total", "diff", "part", "conf", "num", "archive", "alias", "check", "stat", "bot", "ie", "image", "state", "f", "json", "information", "inf", "Info", "error", "si", "is", "details", "config", "name", "data", "now", "init", "args", "op", "about", "comment", "feed", "zip", "by", "base", "io", "iso", "fi", "fo", "ret", "full", "service", "options", "ip", "extra", "http", "INFO", "source", "index", "detail", "die", "def", "job", "id", "ga", "api", "note", "fb", "ii", "off", "py", "end", "type", "fw", "di", "start", "result", "abi", "gi", "parse"], "progress": ["update", "dist", "track", "fail", "total", "diff", "value", "done", "scale", "press", "content", "error", "sync", "quick", "grade", "active", "percent", "wait", "p", "partial", "rss", "area", "recent", "count", "activity", "grades", "demand", "help", "success", "bar", "data", " Progress", "length", "path", "work", "pool", "complete", "export", "current", "flow", "Progress", "speed", "result", "usage", "performance", "move", "history", "max", "err", "version", "resource", "size", "pass", "message", "step"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "int kvm_arch_on_sigbus(int code, void *addr)\n\n{\n\n#ifdef KVM_CAP_MCE\n\n    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {\n\n        void *vaddr;\n\n        ram_addr_t ram_addr;\n\n        target_phys_addr_t paddr;\n\n\n\n        /* Hope we are lucky for AO MCE */\n\n        vaddr = addr;\n\n        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||\n\n            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,\n\n                                               &paddr)) {\n\n            fprintf(stderr, \"Hardware memory error for memory used by \"\n\n                    \"QEMU itself instead of guest system!: %p\\n\", addr);\n\n            return 0;\n\n        }\n\n        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);\n\n    } else\n\n#endif /* KVM_CAP_MCE */\n\n    {\n\n        if (code == BUS_MCEERR_AO) {\n\n            return 0;\n\n        } else if (code == BUS_MCEERR_AR) {\n\n            hardware_memory_error();\n\n        } else {\n\n            return 1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 2996, "substitutes": {"code": ["comment", "line", "cod", "val", "cc", "reason", "loc", "error", "content", "def", "cf", "enc", "sec", "key", "ec", "call", "name", "id", "CE", "age", "pe", "mode", "count", "codes", "charge", "frame", "end", "func", "type", "co", "change", "data", "ca", "parent", "coe", "c", "nc", "Code", "ch", "cur", "ode", "cycle", "go", "message", "catch", "ce", "seq", "fe", "desc"], "addr": ["host", "offset", "mac", "enter", "loc", "r", "attr", "ac", "hop", "rc", "ptr", "ord", "rt", "array", " address", "rx", "ha", "ref", "src", "alias", "nn", "node", "adr", "call", "name", "amd", "ad", "route", "arp", "mode", "pad", "x", "conn", "func", "eth", "arm", "ast", "callback", "ar", "url", "nc", "point", "asm", "layer", "ace", "arg", "oa", "inter", "cmd", "localhost", "amp", "align", "ip", "address", "coord", "Address", "pointer"], "vaddr": ["vmd", "vaddress", "fhost", "faddress", " vaddress", " vmd", "paddress", "uaddr", "wmd", "vvhost", "varg", "whost", "pfunc", "vpad", "vvaddress", "parg", "vhost", " vfunc", "fmd", "uaddress", "farg", "vvarg", "vfunc", "phost", "faddr", "ufunc", "vvaddr", "waddr", "waddress", " vhost", "upad", " vpad", "ppad"], "ram_addr": ["ramingwork", "ram_name", "ramingpad", "gram_work", "ram_oa", "ramingaddr", "gram_addr", "gram_ace", "ram_ace", "ram_work", "gram_address", "ramvname", "vm_addr", "ramingaddress", "vm_address", "ramvhost", "gram_oa", "ramvaddr", "gram_pad", "ram_host", "ram_pad", "ram_address", "vm_name", "vm_host", "ramvaddress"], "paddr": ["porig", "pcaddr", "vaddress", "faddress", "caddr", "lpaddr", "feth", "paddress", "fptr", "jpptr", "pptr", " paddress", "Paddress", "corig", "vorig", "pcaddress", " pcap", "jpaddress", "jpaddr", "pcap", "lphost", "vhost", "jpeth", "chost", "vcap", "lporig", "phost", "faddr", "Pptr", "Peth", "peth", "caddress", "lpaddress", "pccap", "Paddr"]}}
{"project": "qemu", "commit_id": "aef172ffdc2f9c41d9cc043a55f1259e7c07e587", "target": 1, "func": "coroutine_fn iscsi_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct IscsiTask iTask;\n\n    struct unmap_list list;\n\n    int r = 0;\n\n\n\n    if (!is_byte_request_lun_aligned(offset, bytes, iscsilun)) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    if (!iscsilun->lbp.lbpu) {\n\n        /* UNMAP is not supported by the target */\n\n        return 0;\n\n    }\n\n\n\n    list.lba = offset / iscsilun->block_size;\n\n    list.num = bytes / iscsilun->block_size;\n\n\n\n    iscsi_co_init_iscsitask(iscsilun, &iTask);\n\n    qemu_mutex_lock(&iscsilun->mutex);\n\nretry:\n\n    if (iscsi_unmap_task(iscsilun->iscsi, iscsilun->lun, 0, 0, &list, 1,\n\n                         iscsi_co_generic_cb, &iTask) == NULL) {\n\n        r = -ENOMEM;\n\n        goto out_unlock;\n\n    }\n\n\n\n    while (!iTask.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_mutex_unlock(&iscsilun->mutex);\n\n        qemu_coroutine_yield();\n\n        qemu_mutex_lock(&iscsilun->mutex);\n\n    }\n\n\n\n    if (iTask.task != NULL) {\n\n        scsi_free_scsi_task(iTask.task);\n\n        iTask.task = NULL;\n\n    }\n\n\n\n    if (iTask.do_retry) {\n\n        iTask.complete = 0;\n\n        goto retry;\n\n    }\n\n\n\n    if (iTask.status == SCSI_STATUS_CHECK_CONDITION) {\n\n        /* the target might fail with a check condition if it\n\n           is not happy with the alignment of the UNMAP request\n\n           we silently fail in this case */\n\n        goto out_unlock;\n\n    }\n\n\n\n    if (iTask.status != SCSI_STATUS_GOOD) {\n\n        r = iTask.err_code;\n\n        goto out_unlock;\n\n    }\n\n\n\n    iscsi_allocmap_set_invalid(iscsilun, offset >> BDRV_SECTOR_BITS,\n\n                               bytes >> BDRV_SECTOR_BITS);\n\n\n\nout_unlock:\n\n    qemu_mutex_unlock(&iscsilun->mutex);\n\n    return r;\n\n}\n", "idx": 3001, "substitutes": {"bs": ["fs", "base", "BS", "ns", "bid", "fps", "pb", "bb", "bits", "cms", "lbs", "bos", "fb", "abc", "bi", "css", "ps", "ses", "iss", "sb", "rs", "obs", "gb", "bh", "gs", "abi", "vs", "b", "os", "BC", "aos", "bas", "ss", "ls", "bis", "bc", "ds", "sync"], "offset": ["order", "offs", "i", "part", "base", "loc", "error", "padding", "num", "zero", "o", "Offset", "location", "alias", "byte", "limit", "fee", "len", "slice", "off", "end", "pos", "prefix", "inet", "position", "data", "length", "slot", "to", "url", "origin", "start", "oid", "block", "align", "range", "address", "set", "size", "addr", "timeout", "pointer", "seq", "index"], "bytes": ["base", "les", "classes", "pages", "binary", "seconds", "elt", "values", "bits", "bps", "ones", "ips", "items", "byte", "rows", "nets", "words", "net", "used", "errors", "blocks", "fee", "units", "len", "ops", "data", "lines", "length", "devices", "es", "outs", "files", "boot", "resses", "reads", "objects", "Bytes", "abytes", "size", "its", "runs", "empty", "pieces", "seq", "nos", "tes"], "iscsilun": ["ircilune", "cusonsequumen", "iacsilune", "iscsellun", "ircsiluan", "ircslUN", "iscielunt", "inciryuna", "isconsequmun", "iscolitund", "incsilunt", "iscnilund", "ircsilune", "iscislmun", "cussilune", "iscrilune", "iscisloun", "micivaluan", "iscsluan", "iscsilur", "ircielun", "cusonsequun", "inciryunt", "micivalun", "iscstatun", "uscsilun", "iscrubun", "iscmilun", "iscivaluna", "isclesiun", "iscSilun", "iscsilUN", "isciryuna", "iscielund", "iscielUN", "micivalune", "iscstatune", "iscsiluna", "iscsilmun", "iscisluna", "inciryun", "isciryunt", "iscriloun", "iacsilund", "iscselloun", "micsilune", "iacsiluna", "incisluna", "iscslun", "ircsilUN", "iscesismun", "ISClituna", "ircielmun", "iscielun", "ISCsilmun", "ircsilur", "ISCSilUN", "ISCsilan", "iscsilumen", "ircslund", "iscsiltun", "incsiluna", "iscsuspuna", "iscillinuna", "iscislon", "uscsiluna", "iscsluna", "ircsloun", "isclitan", "iscilamun", "iscintelon", "iscolitun", "iscillinmun", "iscielune", "iscrilun", "iscilaune", "iscliton", "isciluna", "uscslun", "isclesiuan", "iscslund", "isconsequune", "iscintelun", "iscsilunt", "ircsluna", "isclesiuna", "ircilUN", "iscivaluan", "iscilun", "cussilmun", "iscinelur", "iscivalun", "iscsellen", "iscislan", "iscilune", "iscmilune", "ISCSiluna", "iscSilune", "incisloun", "ircsilen", "iscolitUN", "iacnilune", "iscivalune", "iscsilen", "ircslun", "isclitmun", "iscintelen", "iscSiluna", "iscsilan", "iscrubuan", "ircslune", "iscielmun", "iscilaumen", "iacnilund", "ISCsilon", "incsilune", "incsiloun", "iscmilunt", "uscslune", "micsiluna", "iscilaun", "iscesistun", "iscstatumen", "cusonsequmun", "iscillinun", "iscislun", "iacsilun", "isciryun", "cusonsequune", "iscilon", "iacniluna", "iscesisun", "iscesisuna", "uscslon", "iscintelur", "iscnilune", "incislun", "iscSilUN", "iscsellon", "isclitune", "iscslune", "iscsuspun", "ircilun", "ircslen", "iscrielune", "ircsiluna", "iscsuspune", "ISClitan", "iscrubune", "iscrielun", "ISCsiluna", "iscinteloun", "ircsilmun", "iscSilon", "iscsiluan", "iscsilune", "iscinelune", "iscslon", "uscsluna", "ircsiltun", "ircsilon", "ircieluna", "ircsiloun", "iscmiluna", "iscsuspoun", "isconsequun", "ISClitmun", "iscriluna", "ircieltun", "iacnilun", "uscsilon", "iscieltun", "ircslur", "iscolituna", "irciluan", "uscsilune", "cussilumen", "iscintelune", "iscrieluan", "inciryune", "cussilun", "iscielan", "ISClitun", "isclitun", "iscineluna", "iscnilun", "ircsilun", "ircslon", "iscieluna", "isconsequumen", "ISCSilon", "iscslUN", "ISCsilUN", "iscintelund", "iscsiloun", "iscniluna", "isciryune", "iscslur", "ISCsilun", "iscrubUN", "ircsilund", "micsilun", "iscslen", "iscsilund", "isclituna", "iscsloun", "iscrielUN", "micsiluan", "incislune", "iscinelun", "incsilun", "ISCSilun", "micivaluna", "iscilUN", "iscislune", "isciluan", "isclesiune", "iscsilon", "iscstatmun", "iscillintun", "iscinteluna"], "iTask": ["iuProcess", "iClient", "antiController", "idiRest", "iiNode", "iSend", "iRest", "idiClient", "iiAttempt", "apitask", "xiThread", "ciNode", "antiRequest", "ICheck", "iiThread", "iProcess", "INode", " iProcess", "siProcess", "iEmpty", "uiTask", "sTask", "uiRequest", "antiClient", " iAttempt", "pEmpty", "antiKey", "inCommand", "itask", "iCommand", "giTask", " iSend", "ITask", "uiKey", "stask", "siTask", "oiCommand", "pJob", "eJob", "iJob", "iThread", "iChild", "iniAttempt", " iRest", "iiProcess", " iThread", "uiJob", " iTest", "iiParent", "apiJob", "iuThis", "uiThread", "inShort", "iLink", "iutask", "iParent", "ciThread", "antiChild", "IProcess", "ISend", "iThis", " itask", " iLink", "iShort", "antiAttempt", "ILink", "antiTest", "siThis", "iNode", " iParent", "citask", " iChild", "idiTest", "iniThread", "iuTask", "IChild", "iiShort", "giThread", "oiTask", " iKey", "iiTask", "iSocket", "iiCommand", "giJob", "etask", "ciCheck", "iiLink", "liTask", "idiTask", "oiSocket", "oiShort", " iCheck", "iKey", "inTask", " iCommand", "eEmpty", "ciTask", "IController", "iiJob", "ciResult", "iRequest", "sThread", " iClient", "antiSend", "xiJob", " iThis", "apiTask", " iRequest", "ICommand", " iController", "ptask", "iitask", "uiAttempt", "antiRest", "iTest", " iNode", "iResult", "gitask", "inSocket", "pTask", "iController", "iCheck", "apiEmpty", "liNode", "iiSocket", "sitask", "iniTask", " iResult", "iAttempt", "xitask", "liCommand", "xiTask", "IResult", "liParent", "iniJob", "eTask", "antiTask"], "list": ["wx", "lock", "i", "List", "lp", " L", "base", "detail", "listed", "l", "def", "chain", "array", "ack", "code", "n", "null", "core", "st", "L", "tmp", " List", "arr", "cli", "acl", "obj", "queue", "id", "join", "len", "count", "ul", "full", "type", "li", "g", "str", "data", "batch", "member", "parent", "add", "pool", "pre", " l", "map", "ll", "info", "result", "block", "ist", "t", "cl", "LIST", " LIST", "this", "lists", "bl", "x", "out", "sync", "record", "seq", "index"]}}
{"project": "qemu", "commit_id": "def74c0cf05722b2e502d4b4f1219966c5b0cbd3", "target": 1, "func": "int mips_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw,\n\n                              int mmu_idx)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    hwaddr physical;\n\n    int prot;\n\n    int access_type;\n\n#endif\n\n    int ret = 0;\n\n\n\n#if 0\n\n    log_cpu_state(cs, 0);\n\n#endif\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n              \"%s pc \" TARGET_FMT_lx \" ad %\" VADDR_PRIx \" rw %d mmu_idx %d\\n\",\n\n              __func__, env->active_tc.PC, address, rw, mmu_idx);\n\n\n\n    /* data access */\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* XXX: put correct access by using cpu_restore_state()\n\n       correctly */\n\n    access_type = ACCESS_INT;\n\n    ret = get_physical_address(env, &physical, &prot,\n\n                               address, rw, access_type);\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n             \"%s address=%\" VADDR_PRIx \" ret %d physical \" TARGET_FMT_plx\n\n             \" prot %d\\n\",\n\n             __func__, address, ret, physical, prot);\n\n    if (ret == TLBRET_MATCH) {\n\n        tlb_set_page(cs, address & TARGET_PAGE_MASK,\n\n                     physical & TARGET_PAGE_MASK, prot | PAGE_EXEC,\n\n                     mmu_idx, TARGET_PAGE_SIZE);\n\n        ret = 0;\n\n    } else if (ret < 0)\n\n#endif\n\n    {\n\n        raise_mmu_exception(env, address, rw, ret);\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3003, "substitutes": {"cs": ["cache", "cc", "fs", "dc", "cr", "sc", "cf", "ns", "rc", "ctx", "qs", "ced", "ci", "ce", "Cs", "ec", "cms", "ins", "ds", "acs", "tc", "cp", "sys", "pc", "conn", "cons", "css", "ps", "cn", "ks", "spec", "c", "rs", "nc", "CS", "ck", "vs", "wcs", "ss", "ls", "sk", "bc", "cas", "lc", "s", "cus"], "address": ["host", "offset", "cache", "contact", "attribute", "mac", "enter", "password", "error", "email", "ptr", "array", "ack", "uri", "reference", "p", "location", "alias", "number", "eni", "config", "interface", "name", "api", "route", "ion", "capacity", "ress", "area", "mode", "reset", "cp", "inet", "prefix", "type", "position", "office", "path", "length", "server", "port", "site", "url", "test", "point", "target", "image", "ace", "channel", "network", "inter", "localhost", "ip", "resource", "coord", "size", "addr", "Address", "message", "pointer", "chip", "order", "index"], "rw": ["wx", "rb", "sw", "rr", "tw", "rh", "r", "sr", "ww", "rc", "working", "ptr", "rt", "wr", "wh", "rx", "RW", "rew", "src", "usr", "rack", "raw", "ran", "rows", "rf", "wp", "w", "rss", "iw", "route", "vr", "wn", "row", "work", "fw", "rs", "nr", "ru", "rn", "rl", "wb", "workers", "nw", "lr", "addr", "hw"], "mmu_idx": ["mmu_Idg", "mmu_midp", "mmu_Idx", "mmu_namex", "mmu_namexc", "mmu_midz", "mmu_idg", "mmu_idw", "mmu_Idz", "mmu_Idp", "mmu_Idxc", "mmu_nameg", "mmu_inxc", "mmu_midx", "mmu_IdX", "mmu_idX", "mmu_nameX", "mmu_idxc", "mmu_idz", "mmu_idv", "mmu_idew", "mmu_idex", "mmu_idp", "mmu_idev", "mmu_inw", "mmu_midg", "mmu_idexc", "mmu_inx", "mmu_inv"], "cpu": ["clock", "cache", "cc", "uci", "cmp", "uu", "ctx", "core", "computer", "connection", "cli", "config", "net", "vm", "tc", "cv", "cp", "gpu", "conn", "pc", "sys", "bench", "cn", "c", "nc", "np", " cp", "pu", "boot", "proc", "nic", "CPU", "hw", "utils", "bc", "cm", "processor", "lc"], "env": ["cache", "dc", "cf", "pec", "context", "enc", "ctx", "conf", "code", "core", "agent", "eu", "exec", "anc", "kernel", "ec", "viron", "eni", "config", "cli", "qt", "net", "chn", "vm", "engine", "fen", "cdn", "cv", "v", "energy", "conn", "ext", "exe", "ne", "console", "cn", "ea", "server", "c", "dt", "lv", "nc", "np", "scope", "eng", "exc", "state", "kn", "proc", "oa", "db", "gui", "err", "estate", "e", "environment", "cfg", "esp", "ev", "en", "Environment"], "physical": ["protected", "tp", "phys", "password", "binary", "intel", "linux", "external", "ssl", "pixel", "relative", "p", "remote", "config", "interface", "primary", "sq", "present", "hard", "platform", "cp", "prefix", "gpu", "pc", "type", "data", "python", "pro", "sp", "secondary", "virtual", "target", "Physical", "info", "local", "performance", "network", "proc", "php", "native", "protein", "integer", "http", "thin", "pointer", "path", "pg"], "prot": ["protected", "phys", "prototype", "io", "att", "ptr", "binary", "pb", "ssl", "fp", "seq", "cli", "config", "primary", "tf", "ret", "rf", "proxy", " proto", "status", "stat", " protocols", "fen", "reset", "platform", "pos", "prefix", "ext", "python", "type", "prop", "Prot", "txt", "pro", "pred", "server", "secondary", "port", "virtual", "plain", "test", "transfer", "rot", " protocol", "col", "proc", "php", "protein", "addr", "pointer", "password"], "access_type": ["access_types", "access_loc", " access_like", "accessertype", "accesstypestate", "access_info", "accesstypeorder", "accessalinfo", "accessitylike", " access_state", "access_time", "accesstypetypes", "accessitytime", " access_order", "access_state", "accessalloc", "access_order", "accessaltype", "accesserlike", "accesstypetype", "accesserinfo", " access_info", "accessityinfo", "accessertime", "access_like", " access_types", " access_loc", "accessitytype", " access_time"]}}
{"project": "qemu", "commit_id": "e26110cfc67d48331a76e9b1e6f7fed7569e1ab3", "target": 0, "func": "static ModuleTypeList *find_type(module_init_type type)\n\n{\n\n    ModuleTypeList *l;\n\n\n\n    init_types();\n\n\n\n    l = &init_type_list[type];\n\n\n\n    return l;\n\n}\n", "idx": 3020, "substitutes": {"type": ["field", "i", "part", "base", "role", "object", "types", "array", "code", "y", "kind", "p", "key", "module", "typ", "name", "id", "method", "pe", "class", "py", "str", "list", "parent", "Type", "test", "plugin", "info", "block", "style", "t", "TYPE", "x", "tag", "index", "rule"], "l": ["line", "i", "lp", " L", "lt", "j", "n", "dl", "o", "pl", "L", "p", "le", "fl", "d", "m", "z", "ln", "ol", "ul", "v", "el", "Li", "li", "list", "c", "ll", "like", "kl", "nl", "t", "b", "f", "u", "shell", "e", "sl", "iol", "lb", "ls", "lr", "lo", "lc", "s"]}}
{"project": "qemu", "commit_id": "8bd7f71d794b93ce027b856f5b79a98f4f82e44c", "target": 0, "func": "static int qemu_suspend_requested(void)\n\n{\n\n    int r = suspend_requested;\n\n    suspend_requested = 0;\n\n    return r;\n\n}\n", "idx": 3040, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "f43a16049ef07585789d311f314f236a314f91f7", "target": 0, "func": "int opt_cpuflags(const char *opt, const char *arg)\n\n{\n\n#define CPUFLAG_MMX2     (AV_CPU_FLAG_MMX      | AV_CPU_FLAG_MMX2)\n\n#define CPUFLAG_3DNOW    (AV_CPU_FLAG_3DNOW    | AV_CPU_FLAG_MMX)\n\n#define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW)\n\n#define CPUFLAG_SSE      (AV_CPU_FLAG_SSE      | CPUFLAG_MMX2)\n\n#define CPUFLAG_SSE2     (AV_CPU_FLAG_SSE2     | CPUFLAG_SSE)\n\n#define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2)\n\n#define CPUFLAG_SSE3     (AV_CPU_FLAG_SSE3     | CPUFLAG_SSE2)\n\n#define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3)\n\n#define CPUFLAG_SSSE3    (AV_CPU_FLAG_SSSE3    | CPUFLAG_SSE3)\n\n#define CPUFLAG_SSE4     (AV_CPU_FLAG_SSE4     | CPUFLAG_SSSE3)\n\n#define CPUFLAG_SSE42    (AV_CPU_FLAG_SSE42    | CPUFLAG_SSE4)\n\n#define CPUFLAG_AVX      (AV_CPU_FLAG_AVX      | CPUFLAG_SSE42)\n\n#define CPUFLAG_XOP      (AV_CPU_FLAG_XOP      | CPUFLAG_AVX)\n\n#define CPUFLAG_FMA4     (AV_CPU_FLAG_FMA4     | CPUFLAG_AVX)\n\n    static const AVOption cpuflags_opts[] = {\n\n        { \"flags\"   , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = \"flags\" },\n\n        { \"altivec\" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC  },    .unit = \"flags\" },\n\n        { \"mmx\"     , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX      },    .unit = \"flags\" },\n\n        { \"mmx2\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2         },    .unit = \"flags\" },\n\n        { \"sse\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE          },    .unit = \"flags\" },\n\n        { \"sse2\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2         },    .unit = \"flags\" },\n\n        { \"sse2slow\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW     },    .unit = \"flags\" },\n\n        { \"sse3\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3         },    .unit = \"flags\" },\n\n        { \"sse3slow\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW     },    .unit = \"flags\" },\n\n        { \"ssse3\"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3        },    .unit = \"flags\" },\n\n        { \"atom\"    , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM     },    .unit = \"flags\" },\n\n        { \"sse4.1\"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4         },    .unit = \"flags\" },\n\n        { \"sse4.2\"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42        },    .unit = \"flags\" },\n\n        { \"avx\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX          },    .unit = \"flags\" },\n\n        { \"xop\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP          },    .unit = \"flags\" },\n\n        { \"fma4\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4         },    .unit = \"flags\" },\n\n        { \"3dnow\"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW        },    .unit = \"flags\" },\n\n        { \"3dnowext\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT     },    .unit = \"flags\" },\n\n        { NULL },\n\n    };\n\n    static const AVClass class = {\n\n        .class_name = \"cpuflags\",\n\n        .item_name  = av_default_item_name,\n\n        .option     = cpuflags_opts,\n\n        .version    = LIBAVUTIL_VERSION_INT,\n\n    };\n\n    int flags = av_get_cpu_flags();\n\n    int ret;\n\n    const AVClass *pclass = &class;\n\n\n\n    if ((ret = av_opt_eval_flags(&pclass, &cpuflags_opts[0], arg, &flags)) < 0)\n\n        return ret;\n\n\n\n    av_force_cpu_flags(flags);\n\n    return 0;\n\n}\n", "idx": 3054, "substitutes": {"opt": ["cat", "val", "text", "attr", "ord", "option", "alt", "pl", "var", "config", "name", "buf", "Option", "ext", "prop", "Opt", "spec", "pair", "options", "oc", "proc", "cmd", "op", "optim", "OP", "bit", "path"], "arg": ["cat", "val", "mac", "gen", "Arg", "enc", "flag", "lib", "ig", "param", "mem", "var", "config", "call", "name", "load", "len", "end", "ar", "args", "proc", "inc", "cmd", "op", "argument", "bit"], "cpuflags_opts": ["cpuflags_opcs", "cpuflags_optionc", "cpuflags_opens", "cpuflags_options", "cpuflags_ops", "cpuflags_openc", "cpuflags_opencs", "cpuflags_opc", "cpuflags_optcs", "cpuflags_optioncs", "cpuflags_opents", "cpuflags_optc", "cpuflags_optionts", "cpuflags_optts"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);\n\n}\n", "idx": 3065, "substitutes": {"dst": ["cdrc", "datst", "iddr", "drc", " dsc", "datST", "dsc", " dST", "idrc", " dsrc", "datrc", "datdr", "cdsrc", "cdst", " drc", "dsrc", " ddr", "cdsc", "ddr", "idST", "dST", "idst"], "src": ["dist", "rb", "i", "sur", "loc", "inst", "sc", "sr", "rc", "sub", "img", "low", "sec", "sel", "st", "bg", "d", "config", "buf", "slice", "dest", "sb", "rs", "url", "gb", "cb", "rate", "b", "rl", "rob", "sl", "iv", "bc", "bis", "sup", "use", "s", "source"], "stride": ["STRide", "ctrine", "STRider", "arrade", " strade", "spride", "sprend", " strided", "strade", "Strided", " strider", "strip", "Strone", "drone", "drade", "drice", "ctrip", "STRip", "ctrider", " strone", "arrend", " strend", "Stride", "drided", "strided", "drride", "sprice", " strice", "STRine", " strine", "Strride", "arride", "strone", "sprided", "strine", "dride", "strider", " strride", "arrided", "ctride", "drend", "strend", "strice", "strride", " strip"]}}
{"project": "qemu", "commit_id": "81174dae3f9189519cd60c7b79e91c291b021bbe", "target": 1, "func": "static void serial_tx_done(void *opaque)\n\n{\n\n    SerialState *s = opaque;\n\n\n\n    if (s->tx_burst < 0) {\n\n        uint16_t divider;\n\n\n\n        if (s->divider)\n\n          divider = s->divider;\n\n        else\n\n          divider = 1;\n\n\n\n        /* We assume 10 bits/char, OK for this purpose. */\n\n        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /\n\n            (1000000 * 10 / (s->baudbase / divider));\n\n    }\n\n    s->thr_ipending = 1;\n\n    s->lsr |= UART_LSR_THRE;\n\n    s->lsr |= UART_LSR_TEMT;\n\n    serial_update_irq(s);\n\n}\n", "idx": 3070, "substitutes": {"opaque": ["openaques", "opac", "OPc", "OPac", "openc", "psa", "openque", "openaque", "OPaques", "pac", "opque", " opque", " opsa", " opaques", " opc", "OPque", "opaques", "paque", "opc", "OPaque", "opsa", "OPsa", "paques", " opac"], "s": ["S", "i", "fs", "spot", "same", "sets", "ts", "ns", "hs", "settings", "cs", "si", "is", "n", "conf", "ssl", "o", "sec", "south", "p", "rates", "new", "d", "m", "sq", "session", "status", "opens", "ops", "services", "a", "sys", "states", "stats", "service", "your", "g", "ps", "server", "ses", "sf", "spec", "c", "sb", "secondary", "es", "rs", "params", "scope", "gs", "sym", "state", "t", "b", "sg", "f", "os", "parts", "submit", "ss", "js", "e", "sl", "storage", "http", "ds", "sync"], "divider": [" divided", " divIDER", " divide", "divides", "decIDER", "multiplider", "divisionoration", "devider", "division", "incider", "dividable", "decide", "divice", "Dividable", "multiplision", "Division", "dividers", "Divider", " divinner", " division", "divisionider", "divide", "multiplride", "promide", "Divide", "decides", "deviders", "decidable", "Divides", "incride", "promider", "decider", "Divided", "decision", "DIVision", " divides", "incision", "divride", "divoration", "divinner", "divisionision", "Divcer", "DIVidable", "divIDER", " dividable", "promision", " divcer", "provIDER", "DIVider", "multiploration", "promice", "incoration", "devide", "DivIDER", "deciders", "devidable", "decice", " divice", "DIVcer", "providers", "divisionride", "provide", "provinner", "divided", "provided", "provider", "providable", "divcer", "Divinner"]}}
{"project": "qemu", "commit_id": "ab9509cceabef28071e41bdfa073083859c949a7", "target": 1, "func": "void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)\n\n{\n\n    QXLDevSurfaceCreate surface;\n\n\n\n    memset(&surface, 0, sizeof(surface));\n\n\n\n    dprint(1, \"%s/%d: %dx%d\\n\", __func__, ssd->qxl.id,\n\n           surface_width(ssd->ds), surface_height(ssd->ds));\n\n\n\n    surface.format     = SPICE_SURFACE_FMT_32_xRGB;\n\n    surface.width      = surface_width(ssd->ds);\n\n    surface.height     = surface_height(ssd->ds);\n\n    surface.stride     = -surface.width * 4;\n\n    surface.mouse_mode = true;\n\n    surface.flags      = 0;\n\n    surface.type       = 0;\n\n    surface.mem        = (uintptr_t)ssd->buf;\n\n    surface.group_id   = MEMSLOT_GROUP_HOST;\n\n\n\n    qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC);\n\n}\n", "idx": 3076, "substitutes": {"ssd": ["esssd", "opensdk", "issdc", " sssd", "psb", "rssdat", "bsdc", "nsds", "SSd", "vse", "ssdat", "vssd", "essd", "opensb", "ssds", "psdk", "pssd", "psd", "issd", "cssds", " ssdb", "nss", "ssdk", "issdk", "issds", "ssdb", "essds", "bsD", "rsssd", "opensds", "opensd", "ssb", "rssdk", " ssdat", "nsd", "isse", "essdc", "sss", "ass", "asd", "asdk", "SSsd", "SSds", "essdb", "ssdc", "csse", "SSdc", "sse", "vsdc", "csssd", "ssD", "rssds", "bsd", "psdc", " ssds", "cssD", "isssd", "cssdb", "bsds", "rssdc", "cssdc", "psD", "asds", "nsdk", "cssd", "sssd", "psdat", "nsdc", "rssd", "vsd", "pss", "psds", "issb"], "surface": ["sole", "database", "enter", "setup", "archive", "wrapper", "grave", "shared", "layer", "sym", "image", "f", "ope", "message", "airo", "filename", "draw", "ui", "material", "prototype", "face", "sr", "tile", "faces", "node", "buffer", "stage", " Surface", "cover", "data", "aster", "forge", "ace", "transfer", "slave", "shell", "rect", "tle", "project", "ptr", "public", "core", "cell", "document", "interface", "proxy", "skin", "peer", "area", "slice", "pad", "stream", "scene", "game", "server", "package", "spec", "ser", "texture", "generic", "FACE", "player", "cur", "sheet", "use", "request", "source", "sur", "sample", "sound", "binary", "src", "folder", "bridge", "metadata", "edge", "ula", "alpha", " surfaces", "master", "func", "console", "sf", " surf", "result", "feature", "save", "resource", "Sur", "client", "content"]}}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_750fx (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Thermal management */\n\n    gen_spr_thrm(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750_THRM4, \"THRM4\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750FX_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    gen_low_BATs(env);\n\n    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */\n\n    gen_high_BATs(env);\n\n    init_excp_7x0(env);\n\n    env->dcache_line_size = 32;\n\n    env->icache_line_size = 32;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc6xx_irq_init(env);\n\n}\n", "idx": 3082, "substitutes": {"env": ["enter", "enc", "er", "eu", "ec", "v", "ah", "output", "jp", "exc", "dev", "environment", "Environment", "forest", "gr", "done", "exec", "bg", "config", "dat", "stage", "vm", "org", "fen", "cv", "event", "el", "erv", "ench", "enh", "site", "app", "eng", "forge", "style", "kn", "args", "err", "nw", "net", "ev", "context", "code", "gear", "ctx", "skin", "obj", "status", " environment", "engine", "loader", "energy", "conn", "server", "dt", "enable", "e", "progress", "gov", "equ", "viron", "here", "ext", "console", "ea", "c", "export", "nc", "np", "dict", "vs", "db", "gui", "oa", "en"]}}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...))\n\n{\n\n    stream_printf(stream, \"Trace file \\\"%s\\\" %s.\\n\",\n\n                  trace_file_name, trace_file_enabled ? \"on\" : \"off\");\n\n}\n", "idx": 3098, "substitutes": {"stream": ["draw", "host", "model", "feed", "view", "track", "sw", "socket", "form", "tr", "context", "reader", "valid", "each", "stack", "src", "document", "pipe", "input", "thread", "buffer", "w", "method", "engine", "file", "wrap", "window", "server", "port", "pool", "test", "channel", "Stream", "resource", "child", "sl", "client", "progress", "path", "source"], "stream_printf": ["stream__print", "stream__printf", "stream_print", "stream_format", "streampformat", "streampprintf", "stream_flush", " stream_print", "stream__println", "streampprint", " stream_flush", "stream__callback", "stream_callback", " stream_format", "streampflush", " stream_callback", "stream_println", " stream_println"]}}
{"project": "FFmpeg", "commit_id": "9924f1bc34242bb9315c355108f3ce744c1f33c5", "target": 0, "func": "static int mkv_write_header(AVFormatContext *s)\n\n{\n\n    MatroskaMuxContext *mkv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    ebml_master ebml_header;\n\n    AVDictionaryEntry *tag;\n\n    int ret, i, version = 2;\n\n    int64_t creation_time;\n\n\n\n    if (!strcmp(s->oformat->name, \"webm\"))\n\n        mkv->mode = MODE_WEBM;\n\n    else\n\n        mkv->mode = MODE_MATROSKAv2;\n\n\n\n    if (mkv->mode != MODE_WEBM ||\n\n        av_dict_get(s->metadata, \"stereo_mode\", NULL, 0) ||\n\n        av_dict_get(s->metadata, \"alpha_mode\", NULL, 0))\n\n        version = 4;\n\n\n\n    if (s->nb_streams > MAX_TRACKS) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"At most %d streams are supported for muxing in Matroska\\n\",\n\n               MAX_TRACKS);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The Matroska muxer does not yet support muxing %s\\n\",\n\n                   avcodec_get_name(s->streams[i]->codecpar->codec_id));\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS ||\n\n            av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0) ||\n\n            av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0))\n\n            version = 4;\n\n    }\n\n\n\n    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));\n\n    if (!mkv->tracks) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLVERSION        ,           1);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLREADVERSION    ,           1);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXIDLENGTH    ,           4);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXSIZELENGTH  ,           8);\n\n    put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);\n\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEVERSION     ,     version);\n\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEREADVERSION ,           2);\n\n    end_ebml_master(pb, ebml_header);\n\n\n\n    mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0);\n\n    mkv->segment_offset = avio_tell(pb);\n\n\n\n    // we write 2 seek heads - one at the end of the file to point to each\n\n    // cluster, and one at the beginning to point to all other level one\n\n    // elements (including the seek head at the end of the file), which\n\n    // isn't more than 10 elements if we only write one of each other\n\n    // currently defined level 1 element\n\n    mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10);\n\n    if (!mkv->main_seekhead) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb));\n\n    if (ret < 0) goto fail;\n\n\n\n    ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n    pb = mkv->info_bc;\n\n\n\n    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);\n\n    if ((tag = av_dict_get(s->metadata, \"title\", NULL, 0)))\n\n        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);\n\n    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {\n\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);\n\n        if ((tag = av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)))\n\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);\n\n        else\n\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);\n\n\n\n        if (mkv->mode != MODE_WEBM) {\n\n            uint32_t segment_uid[4];\n\n            AVLFG lfg;\n\n\n\n            av_lfg_init(&lfg, av_get_random_seed());\n\n\n\n            for (i = 0; i < 4; i++)\n\n                segment_uid[i] = av_lfg_get(&lfg);\n\n\n\n            put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);\n\n        }\n\n    } else {\n\n        const char *ident = \"Lavf\";\n\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);\n\n        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);\n\n    }\n\n\n\n    if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) {\n\n        // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds.\n\n        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;\n\n        uint8_t date_utc_buf[8];\n\n        AV_WB64(date_utc_buf, date_utc);\n\n        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);\n\n    }\n\n\n\n    // reserve space for the duration\n\n    mkv->duration = 0;\n\n    mkv->duration_offset = avio_tell(pb);\n\n    if (!mkv->is_live) {\n\n        int64_t metadata_duration = get_metadata_duration(s);\n\n\n\n        if (s->duration > 0) {\n\n            int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);\n\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from recording time = %\" PRIu64 \"\\n\", scaledDuration);\n\n        } else if (metadata_duration > 0) {\n\n            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);\n\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from metadata = %\" PRIu64 \"\\n\", scaledDuration);\n\n        } else {\n\n            put_ebml_void(pb, 11);              // assumes double-precision float to be written\n\n        }\n\n    }\n\n    if ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)\n\n        end_ebml_master_crc32_preliminary(s->pb, &mkv->info_bc, mkv, mkv->info);\n\n    else\n\n        end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info);\n\n    pb = s->pb;\n\n\n\n    // initialize stream_duration fields\n\n    mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n    mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n\n\n    ret = mkv_write_tracks(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    for (i = 0; i < s->nb_chapters; i++)\n\n        mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id);\n\n\n\n    ret = mkv_write_chapters(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    if (mkv->mode != MODE_WEBM) {\n\n        ret = mkv_write_attachments(s);\n\n        if (ret < 0)\n\n            goto fail;\n\n    }\n\n\n\n    ret = mkv_write_tags(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)\n\n        mkv_write_seekhead(pb, mkv);\n\n\n\n    mkv->cues = mkv_start_cues(mkv->segment_offset);\n\n    if (!mkv->cues) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && mkv->reserve_cues_space) {\n\n        mkv->cues_pos = avio_tell(pb);\n\n        put_ebml_void(pb, mkv->reserve_cues_space);\n\n    }\n\n\n\n    av_init_packet(&mkv->cur_audio_pkt);\n\n    mkv->cur_audio_pkt.size = 0;\n\n    mkv->cluster_pos = -1;\n\n\n\n    avio_flush(pb);\n\n\n\n    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or\n\n    // after 4k and on a keyframe\n\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n\n        if (mkv->cluster_time_limit < 0)\n\n            mkv->cluster_time_limit = 5000;\n\n        if (mkv->cluster_size_limit < 0)\n\n            mkv->cluster_size_limit = 5 * 1024 * 1024;\n\n    } else {\n\n        if (mkv->cluster_time_limit < 0)\n\n            mkv->cluster_time_limit = 1000;\n\n        if (mkv->cluster_size_limit < 0)\n\n            mkv->cluster_size_limit = 32 * 1024;\n\n    }\n\n\n\n    return 0;\n\nfail:\n\n    mkv_free(mkv);\n\n    return ret;\n\n}\n", "idx": 3117, "substitutes": {"s": ["uns", "conf", "d", "ions", "sa", "sis", "an", "v", "states", "ps", "secondary", "sb", "sym", "os", "f", "ads", "parts", "this", "js", "comments", "sv", "l", "sites", "si", "is", "qs", "p", "events", "ins", "se", "stats", "ses", "features", "b", "sg", "u", "serv", "ops", "sup", "plugins", "sync", "S", "support", "r", "settings", "hs", "cs", "ssl", "south", "als", "new", "m", "sq", "session", "bs", "w", "service", "your", "g", "us", "server", "spec", "ks", "es", "gs", "aws", "ss", "e", "ls", "sl", "http", "ds", "xs", "request", "fs", "su", "sets", "ts", "ns", "n", "ans", "services", "a", "sys", "submit", "sf", "c", "rs", "in", "self", "single", "uploads", "its", "tests", "client"], "mkv": [" mku", " mkver", " mkov", "bbv", "tkv", " mkh", "bbov", "okV", "mkV", "wkv", "ckV", "ckv", "tkver", "skov", "mkl", "mkh", " mkV", "okov", "tku", "bbu", "mku", "kV", "ikV", "wkV", "bbver", "ikov", "okl", "kh", "mkc", "tkov", " mkl", "skV", "skc", "ikc", "okh", "okc", " mkj", "ckj", "kv", "wkj", "kl", "mkver", "mkvv", "wkvv", "ikv", "mkj", "skv", " mkvv", "okv", "mkov", "ckvv"], "pb": ["vim", "rb", "lp", "mp", "bp", "cpp", "prot", "ctx", "bb", "pm", "fp", "tmp", "phrase", "ab", "ub", "bs", "primary", "typ", "obj", "wp", "buf", "fb", "verb", "platform", "cv", "cp", "pc", "type", "message", "hub", "sb", "gb", "parser", "mc", "cb", "db", "meta", "pa", "amp", "wb", "summary", "bc", "lb", "bm", "PB"], "ebml_header": ["ebml_headers", "ebml_main", "ebsl_header", "ebsl_main", "ebsl_metadata", "ebsl_headers", "ebml_metadata"], "tag": ["comment", "cat", "bug", "tr", "ack", "xml", "key", "module", "config", "name", "id", "rec", "stream", "Tag", "type", "description", "row", "test", "tags", "feature", "TAG", "version", "entry", "record", "last", "desc"], "ret": ["rc", "code", "j", "resp", " ver", " result", " success", "vision", "rev", " r", " clen", " revision", "len", "con", "cv", " compat", " resp", " Version", " vers", "server", "result", "dev", "VERSION", " rc", " val", "out"], "i": ["ui", "io", "it", "ik", "fi", "si", "j", "n", "uri", "temp", "y", "o", "p", "ci", "multi", "qi", "ind", "eni", "d", "oi", "cli", "m", "name", "mi", "id", "iri", "api", "ori", "ri", "ini", "ii", "v", "mini", "type", "li", "g", "iu", "ie", "zi", "di", "ix", "ai", "info", "init", "abi", "start", "pi", "ski", "mu", "gi", "f", "b", "ti", "ip", "ni", "e", "xi", "I", "inner", "phi", "iv", "yi", "my", "index"], "creation_time": ["creation2timer", "creation2info", "creation_timer", "create_time", "create_tc", "creation4tc", "creation2tc", "creation4timer", "creation2time", "creation4time", "creation_info", "creation_tc", "create_info", "create_timer", "creation4info"]}}
{"project": "qemu", "commit_id": "4105de6732f771ea64113851a2ee7172c34d3a7a", "target": 1, "func": "e1000_can_receive(void *opaque)\n\n{\n\n    E1000State *s = opaque;\n\n\n\n    return (!(s->mac_reg[RCTL] & E1000_RCTL_EN) ||\n\n            s->mac_reg[RDH] != s->mac_reg[RDT]);\n\n}\n", "idx": 3130, "substitutes": {"s": ["S", "su", "ns", "settings", "si", "is", "conf", "ssl", "o", "south", "p", "new", "m", "sq", "session", "opens", "sa", "an", "ans", "services", "a", "sys", "states", "service", "your", "g", "submit", "ses", "spec", "sf", "c", "sb", "secondary", "self", "in", "scope", "params", "sym", "state", "b", "os", "f", "space", "this", "ss", "e", "sl", "ops", "ds", "sync", "request"]}}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_sws_init_swScale_mmx(SwsContext *c)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if HAVE_INLINE_ASM\n\n    if (cpu_flags & AV_CPU_FLAG_MMX)\n\n        sws_init_swScale_MMX(c);\n\n#if HAVE_MMXEXT_INLINE\n\n    if (cpu_flags & AV_CPU_FLAG_MMXEXT)\n\n        sws_init_swScale_MMX2(c);\n\n#endif\n\n#endif /* HAVE_INLINE_ASM */\n\n\n\n#if HAVE_YASM\n\n#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \\\n\n    if (c->srcBpc == 8) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 9) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 10) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \\\n\n    } else /* c->srcBpc == 16 */ { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \\\n\n    } \\\n\n} while (0)\n\n#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \\\n\n    }\n\n#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \\\n\nswitch(c->dstBpc){ \\\n\n    case 16:                          do_16_case;                          break; \\\n\n    case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \\\n\n    case 9:  if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \\\n\n    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \\\n\n    }\n\n#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \\\n\n    switch(c->dstBpc){ \\\n\n    case 16: if (!isBE(c->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \\\n\n    case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \\\n\n    case 9:  if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \\\n\n    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \\\n\n    }\n\n#define case_rgb(x, X, opt) \\\n\n        case PIX_FMT_ ## X: \\\n\n            c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \\\n\n            if (!c->chrSrcHSubSample) \\\n\n                c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \\\n\n            break\n\n#if ARCH_X86_32\n\n    if (cpu_flags & AV_CPU_FLAG_MMX) {\n\n        ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx);\n\n        ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_Y400A:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_mmx;\n\n            break;\n\n        case PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            c->chrToYV12 = ff_yuyvToUV_mmx;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_mmx;\n\n            c->chrToYV12 = ff_uyvyToUV_mmx;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_mmx;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_mmx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, mmx);\n\n        case_rgb(bgr24, BGR24, mmx);\n\n        case_rgb(bgra,  BGRA,  mmx);\n\n        case_rgb(rgba,  RGBA,  mmx);\n\n        case_rgb(abgr,  ABGR,  mmx);\n\n        case_rgb(argb,  ARGB,  mmx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmx2, , 1);\n\n    }\n\n#endif /* ARCH_X86_32 */\n\n#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \\\n\n             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \\\n\n             break; \\\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSE2) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_Y400A:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_sse2;\n\n            break;\n\n        case PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            c->chrToYV12 = ff_yuyvToUV_sse2;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_sse2;\n\n            c->chrToYV12 = ff_uyvyToUV_sse2;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_sse2;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_sse2;\n\n            break;\n\n        case_rgb(rgb24, RGB24, sse2);\n\n        case_rgb(bgr24, BGR24, sse2);\n\n        case_rgb(bgra,  BGRA,  sse2);\n\n        case_rgb(rgba,  RGBA,  sse2);\n\n        case_rgb(abgr,  ABGR,  sse2);\n\n        case_rgb(argb,  ARGB,  sse2);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSSE3) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3);\n\n        switch (c->srcFormat) {\n\n        case_rgb(rgb24, RGB24, ssse3);\n\n        case_rgb(bgr24, BGR24, ssse3);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSE4) {\n\n        /* Xto15 don't need special sse4 functions */\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,\n\n                            if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        if (c->dstBpc == 16 && !isBE(c->dstFormat))\n\n            c->yuv2plane1 = ff_yuv2plane1_16_sse4;\n\n    }\n\n\n\n    if (cpu_flags & AV_CPU_FLAG_AVX) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_YUYV422:\n\n            c->chrToYV12 = ff_yuyvToUV_avx;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->chrToYV12 = ff_uyvyToUV_avx;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_avx;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_avx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, avx);\n\n        case_rgb(bgr24, BGR24, avx);\n\n        case_rgb(bgra,  BGRA,  avx);\n\n        case_rgb(rgba,  RGBA,  avx);\n\n        case_rgb(abgr,  ABGR,  avx);\n\n        case_rgb(argb,  ARGB,  avx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 3153, "substitutes": {"c": ["cu", "dc", "cc", "cr", "bc", "cf", "ac", "l", "rc", "cs", "context", "ctx", "vc", "p", "ci", "ce", "ec", "m", "k", "con", "cv", "v", "lc", "pc", "coll", "nc", "ch", "center", "mc", "t", "b", "f", "u", "cur", "C", "e", "ct", "uc", "cm", "s"]}}
{"project": "FFmpeg", "commit_id": "0a467a9b594dd67aa96bad687d05f8845b009f18", "target": 1, "func": "static unsigned tget(const uint8_t **p, int type, int le)\n\n{\n\n    switch (type) {\n\n    case TIFF_BYTE:\n\n        return *(*p)++;\n\n    case TIFF_SHORT:\n\n        return tget_short(p, le);\n\n    case TIFF_LONG:\n\n        return tget_long(p, le);\n\n    default:\n\n        return UINT_MAX;\n\n    }\n\n}\n", "idx": 3158, "substitutes": {"p": ["i", "cache", "lp", "tp", "bp", "patch", "l", "pb", "j", "n", "o", "d", "m", "api", "wp", "w", "v", "cp", "pc", "g", "data", "ps", "sp", "port", "c", "ap", "pp", "pre", "np", "point", "vp", "jp", "pi", "P", "t", "b", "f", "op", "pa", "u", "ip", "e", "x", "pointer", "progress"], "type": ["val", "i", "action", "value", "scale", "role", "types", "code", "unit", "ity", "y", "o", "ref", "key", "name", "id", "typ", "method", "len", "ase", "class", "py", "format", "pos", "pc", "pretty", "ype", "Type", "pre", "plugin", "info", "block", "col", "style", "al", "t", "cl", "version", "op", "set", "address", "TYPE", "sl", "ct", "index"], "le": ["Le", "line", "let", "leave", "les", "lu", "l", "ge", "ple", "pl", "cell", "ial", "ve", "less", "ale", "lex", "ble", "pe", "ld", "little", "able", "lc", "el", "li", "ele", "ne", "ler", "ie", "sle", "middle", "ar", "ll", "lee", "kl", "la", "lo", "LE", "ole", "lem", "cl", "lead", "ling", "e", "sl", "lb", "lf", " LE", "led", "ile"]}}
{"project": "FFmpeg", "commit_id": "c43485f70765cb488bfdf95dc783bb9b14eb1179", "target": 1, "func": "static int decode_hq_slice(AVCodecContext *avctx, void *arg)\n\n{\n\n    int i, quant, level, orientation, quant_idx;\n\n    uint8_t quants[MAX_DWT_LEVELS][4];\n\n    DiracContext *s = avctx->priv_data;\n\n    DiracSlice *slice = arg;\n\n    GetBitContext *gb = &slice->gb;\n\n\n\n    skip_bits_long(gb, 8*s->highquality.prefix_bytes);\n\n    quant_idx = get_bits(gb, 8);\n\n\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n\n    for (level = 0; level < s->wavelet_depth; level++) {\n\n        for (orientation = !!level; orientation < 4; orientation++) {\n\n            quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0);\n\n            quants[level][orientation] = quant;\n\n        }\n\n    }\n\n\n\n    /* Luma + 2 Chroma planes */\n\n    for (i = 0; i < 3; i++) {\n\n        int64_t length = s->highquality.size_scaler * get_bits(gb, 8);\n\n        int64_t bits_left = 8 * length;\n\n        int64_t bits_end = get_bits_count(gb) + bits_left;\n\n\n\n        if (bits_end >= INT_MAX) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"end too far away\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        for (level = 0; level < s->wavelet_depth; level++) {\n\n            for (orientation = !!level; orientation < 4; orientation++) {\n\n                decode_subband(s, gb, quants[level][orientation], slice->slice_x, slice->slice_y, bits_end,\n\n                               &s->plane[i].band[level][orientation], NULL);\n\n            }\n\n        }\n\n        skip_bits_long(gb, bits_end - get_bits_count(gb));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3160, "substitutes": {"avctx": ["afcontext", "awctx", "avcu", "abconfig", "AVctx", "awcb", "avectx", "AVcb", "awcontext", "afcu", "abctx", "Avctx", "AVconfig", "Avctl", "ajctx", "awconfig", "acctl", "accb", "Avcontext", "abcontext", "AVctl", "acctx", "avcm", "afcm", "avcb", "afctx", "avecm", "ajcu", "avecontext", "avecu", "ajcm", "avconfig", "AVcontext", "avctl", "ajcontext", "avcontext", "Avcb", "abcb", "accontext"], "arg": ["val", "agi", "gen", "Arg", "array", "enc", "flag", "arc", "cell", "alloc", "ig", "param", "arr", "lang", "or", "alias", "call", "load", "abc", "ang", "ray", "ag", "slot", "spec", "ar", "can", "target", "ay", "parser", "ace", "cand", "args", "gap", "amp", "ark", "parse", "pass", "use", "argument"], "i": ["lock", "chi", "ui", "io", "l", "si", "j", "n", "uri", "o", "p", "ci", "multi", "uni", "qi", "ind", "eni", "d", "m", "oi", "id", "mi", "I", "ri", "ini", "ii", "v", "mini", "type", "li", "g", "ie", "iu", "c", "in", "zi", "di", "ix", "ai", "depth", "pi", "b", "f", "u", "gi", "ti", "ip", "ni", "e", "xi", "x", "phi", "index"], "quant": ["draw", "comment", "cat", "serial", "mult", "total", "diff", "text", "req", "scale", "secure", "pick", "gen", "patch", "quick", "complex", "qu", "requ", "query", "d", "id", "quiet", "qa", "tax", "dim", "count", "pad", "charge", "qual", "direct", "prefix", "mix", "str", "bit", "length", "package", "spec", "quality", "comp", "rank", "util", "round", "depth", "local", "channel", "std", "specific", "gap", "q", "cost", "inc", "client", "cur", "integer", "component", "post", "frac", "volume", "qt", "quad", "multipl", "aud"], "level": ["field", "update", "pri", "enc", "unit", "temp", "half", "letter", "key", "thread", "ld", "count", "parent", "quality", "weight", "layer", "block", "col", "la", "inc", "cost", "pull", "step", "serial", "error", "l", "si", "where", "Level", "less", "fl", "name", "limit", "stage", "time", "mode", "ul", "el", "url", "lvl", "style", "sync", "lc", "found", "rule", "line", "lock", "sc", "code", "ale", "status", "full", "year", "day", "length", "spec", "old", "rel", "vel", "child", "size", "wl", "rol", "path", "index", "clean", "source", "model", "loop", "wall", "fail", "value", "loc", "scale", "low", "pl", "id", "vol", "pe", "type", "file", "coll", "di", "flow", "depth", "local", "cl", "version", "levels", "resource", "pass", "condition", "lo", "round"], "orientation": ["directionution", "rotimation", "homization", "occupations", "occupization", "orientedatio", "iterational", "orientedination", "locimation", "occupatio", "variation", "orientancy", "orientuation", "orientination", "designrency", "ortotation", "loco", "orientution", "rientity", "orientity", "orientotation", "orientations", " orientraction", "orientriction", "variations", "rientation", "orientition", "iteration", "equo", " orientruction", " oriention", "equration", "ortimation", "occupation", "rientoration", "ortning", "directionition", "conductation", "directionion", "rientational", "variution", "rotraction", "orientATION", "orientedation", " orientition", "orientruction", "orientimation", "rotity", "rotational", "orientformation", "orientatio", "rientATION", " orientancy", "designATION", "variancy", " orientity", "orientning", "directionational", "locration", "variational", "orientration", "orientaton", "designaton", "conductaton", "rientuation", "conductization", "riention", "directionATION", "oriento", "ortation", "designation", "orientization", "directionruction", "orientraction", "directionoration", "variATION", "rientformation", "orientedning", " orientatio", "rientraction", "orientational", "location", "ortational", " orientoration", "occupration", "ortriction", " orientations", "homaton", "directionation", "organation", "occupancy", "riento", "rientruction", " orientformation", "occupriction", "designization", "designution", "orientrency", "rientrency", "equation", "ortization", "designational", "occupning", "iterimation", "equimation", "organuation", "homation", "designity", "directionatio", "organrency", "designuation", "occupination", "rientimation", "oriention", "rototation", "iterotation", "homity", "orientedration", "occupational", "orientedriction", "directionration", " orientational", "rotation", "orientedization", "rientition", "directionination", "rientatio", "orientoration", "organATION", "conductity", "rotformation", "rientration"], "quant_idx": ["quant_minx", "quant_dxe", "quant_aidxes", "quant_idxs", "quant0idx", "quant2idxes", "quant__idxe", "quant__endv", "quant_aidxs", "quant_endx", "quant_pidxs", "quant_adv", "quant_idex", "quant_minn", "quant_pidb", "quant_fv", "quant_adx", "quant_minxes", "quant_fx", "quant__endx", "quant_pidxes", "quant_adxe", "quant0pidb", "quant0idxes", "quant__endX", "quant_aidx", "quant2aidn", "quant0pidxes", "quant__idv", "quant2aidxes", "quant_idn", "quant_idxes", "quant0pidv", "quant_dv", "quant_ideb", "quant__endxe", "quant_idX", "quant0idb", "quant_dx", "quant2idx", "quant_idv", "quant_pidv", "quant_endX", "quant_endxe", "quant__idX", "quant_idev", "quant0idv", "quant_idexes", "quant_minxs", "quant_pidn", "quant_fb", "quant2aidxs", "quant_fxes", "quant_idxe", "quant0pidx", "quant_dX", "quant_endv", "quant__idx", "quant_aidn", "quant_idb", "quant2idxs", "quant2idn", "quant_pidx", "quant_adX", "quant2aidx"], "quants": ["qents", "inquatts", " quantis", "Quants", "quances", "quancy", " quances", "inquants", "aquents", "quatts", " quapters", "qants", "inquant", "acquant", "qancy", "quantis", "requant", "aquancy", "quents", "requancy", "Quantis", "quapters", "Quatts", " quatts", "requents", "acquapters", "Quant", "aquant", "aquances", "acquants", "qant", "requants", "acquances", "aquants", "aquapters", "inquantis"], "MAX_DWT_LEVELS": ["MAX_DWT_LELLS", "MAX_DWT_LELL5", "MAX_DWT_LEvel5", "MAX_DWT_LEVELN", "MAX_DWT_LEvelS", "MAX_DWT_LVELP", "MAX_DWT_LEALL5", "MAX_DWT_LEALLS", "MAX_DWT_LEVELP", "MAX_DWT_LEVEL5", "MAX_DWT_LEALLN", "MAX_DWT_LVELN", "MAX_DWT_LELLP", "MAX_DWT_LVELS", "MAX_DWT_LLLN", "MAX_DWT_LLLS", "MAX_DWT_LVEL5", "MAX_DWT_LLLP", "MAX_DWT_LEvelN", "MAX_DWT_LEALLP", "MAX_DWT_LELLN", "MAX_DWT_LLL5", "MAX_DWT_LEvelP"], "s": ["conf", "d", "sa", "sci", "ps", "sb", "sym", "os", "f", "parts", "space", "params", "sv", "l", "si", "is", "qs", "p", "details", "se", "data", "ses", "site", "scope", "b", "sg", "u", "utils", "serv", "side", "ops", "sup", "sync", "h", "S", "r", "sc", "settings", "cs", "ctx", "ssl", "core", "m", "sq", "session", "service", "g", "spec", "es", "gs", "t", "aws", "ss", "e", "sky", "sl", "ls", "ds", "fs", "su", "ns", "j", "n", "rates", "services", "a", "sys", "sf", "c", "rs", "self", "storage", "bis"], "slice": ["ice", "view", "zip", "diff", "sample", "scale", "sc", "match", "ring", "sub", "si", "ge", "Sl", "array", "uri", "binary", "unit", "p", "ci", "index", "rice", "node", "crop", "split", "sq", "se", "edge", "gp", "gate", "pe", "dim", "ii", "sci", " slicing", "v", "service", "ie", "slot", "package", "game", "shape", "sb", "gm", "np", "parser", "layer", "seed", "image", "storage", "range", "slave", " sliced", "sl", "parse", "thin", "source"], "gb": ["kb", "bf", "agg", "rb", "ui", "ged", "buff", "kg", "gen", "xb", "binary", "bb", "ctx", "ge", "GB", "cs", "gh", "pg", "lib", "ci", "bo", "bg", "gc", "cli", "gem", "ga", "gp", "gal", "gate", "gio", "cgi", "dim", "lb", "gn", "mb", "gpu", "gz", "pc", "g", "eb", "abb", "gin", "hub", "xy", "sb", "rg", "gold", "gm", "gram", "gd", "gy", "gg", "gs", "plugin", "cb", "phy", "db", "b", "quad", "sg", "storage", "gam", "sl", "bc", "cfg", "bm", "cd"]}}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int amr_wb_encode_init(AVCodecContext *avctx)\n\n{\n\n    AMRWBContext *s = avctx->priv_data;\n\n\n\n    if (avctx->sample_rate != 16000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only 16000Hz sample rate supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    s->mode            = get_wb_bitrate_mode(avctx->bit_rate, avctx);\n\n    s->last_bitrate    = avctx->bit_rate;\n\n\n\n    avctx->frame_size  = 320;\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n\n\n\n\n    s->state     = E_IF_init();\n\n\n\n    return 0;\n\n}", "idx": 3161, "substitutes": {"avctx": ["avcu", "ajsci", "ajcca", "avalcm", "avpkg", "aycu", "amctx", "avcci", "afloc", "afconn", "avercmd", "avcm", "afcci", "afctx", "afctrl", "averconn", "avcontext", "avesci", "akloc", "avalcontext", "avcca", "avecf", "avconn", "avectx", "evcu", " avcontext", " avcf", "ajcci", "avecca", "avcmd", "afcoll", "affw", "amcu", "avalctx", "akconn", "ajconn", "avcf", "avectrl", "akcu", "avctrl", "evcontext", "avfw", "ajcontext", "avalcci", "ajcms", "avalcoll", "afcmd", "avalcu", "ajpkg", "ajctx", "avalconn", " avcu", "akctx", "avefw", "avecoll", "avalpkg", "ajctrl", "avecontext", "evctx", "avecm", "avloc", "akcontext", " avloc", "ayctx", "afcf", "avcms", "avcoll", "amcontext", "afcontext", "avercontext", "afpkg", "aycontext", "afsci", "akcmd", "afcu", "evcms", "afcca", "avsci", "afca", "afcms", "aycms", "avalfw", "ajca", "afcm", "aveca", "avalcms", "avecu", "avca", "averctx", "amconn", "avalcf"], "s": ["S", "i", "fs", "r", "ns", "cs", "is", "ctx", "si", "n", "ssl", "o", "p", "storage", "m", "sq", "w", "sa", "acs", "ans", "v", "a", "services", "sys", "service", "g", "data", "ses", "spec", "c", "rs", "sb", "gs", "args", "t", "as", "f", "sg", "b", "os", "aws", "u", "ss", "js", "e", "sk", "ssh", "ls", "ops", "bis", "sync"]}}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)\n\n{\n\n    *q_ptr = num / den;\n\n    return num % den;\n\n}\n", "idx": 3162, "substitutes": {"q_ptr": ["p_pointer", "p_pt", " q_Ptr", "q_ctr", " q_ctr", "q_req", " q_pointer", "p_ptr", "p_req", "q_pointer", "q_pt", "q_Ptr"], "num": ["nm", "done", "su", "nom", "un", "um", "gen", "unit", "n", "null", "zero", "Num", "uni", "number", "nn", "node", "NUM", "d", "nam", "m", "sum", "norm", "mom", "no", "len", "dim", "count", "con", "mon", "nb", "prefix", "ne", "initial", "nu", "nr", "nc", "np", "du", "rem", "mn", "mu", "om", "bin", "inc", "u", "version", "one", "size", "net", "index"], "den": ["mask", "pri", "wall", "flo", "su", "des", "gen", "de", "DEN", "dan", "core", "nd", "fin", "fl", "dm", "nn", "zen", "min", "norm", "dim", "len", "fen", "mon", "con", "ne", "hen", "lan", "day", "dn", "ven", "ide", "di", "flow", "mn", "bin", "dev", "none", "der", "da", "range", "side", "iden", "rem", "design", "en", "Den"]}}
{"project": "FFmpeg", "commit_id": "69ee915e1c628fdf8b270de8c19ff357333e354a", "target": 1, "func": "void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)\n\n{\n\n    int i;\n\n\n\n    s->dts    =\n\n    s->pts    = AV_NOPTS_VALUE;\n\n    s->pos    = -1;\n\n    s->offset = 0;\n\n    for (i = 0; i < AV_PARSER_PTS_NB; i++) {\n\n        if (s->cur_offset + off >= s->cur_frame_offset[i] &&\n\n            (s->frame_offset < s->cur_frame_offset[i] ||\n\n             (!s->frame_offset && !s->next_frame_offset)) && // first field/frame\n\n            // check disabled since MPEG-TS does not send complete PES packets\n\n            /*s->next_frame_offset + off <*/  s->cur_frame_end[i]){\n\n\n\n            s->dts    = s->cur_frame_dts[i];\n\n            s->pts    = s->cur_frame_pts[i];\n\n            s->pos    = s->cur_frame_pos[i];\n\n            s->offset = s->next_frame_offset - s->cur_frame_offset[i];\n\n            if (remove)\n\n                s->cur_frame_offset[i] = INT64_MAX;\n\n            if (s->cur_offset + off < s->cur_frame_end[i])\n\n                break;\n\n        }\n\n    }\n\n}\n", "idx": 3176, "substitutes": {"s": ["conf", "d", "states", "ps", "lines", "sb", "sym", "os", "f", "as", "this", "js", "comments", "l", "is", "si", "qs", "o", "y", "p", "less", "ins", "stats", "ses", "site", "parser", "b", "sg", "u", "ops", "sync", "h", "S", "r", "settings", "hs", "cs", "ssl", "m", "sq", "session", "w", "service", "g", "us", "ks", "spec", "es", "obs", "gs", "t", "ss", "e", "ls", "http", "ds", "xs", "fs", "ms", "su", "sets", "ts", "ns", "n", "services", "a", "sys", "sf", "c", "rs", "self", "vs", "its", "bis"], "off": ["next", "offs", "offset", "ui", "diff", "shift", "error", "un", "def", "low", "o", "alt", "up", "ff", "non", "raw", "load", "down", "no", "offer", "Off", "on", "of", "pos", "over", "before", "length", "old", "after", "now", "flow", "OFF", "info", "block", "eff", "oa", "op", "online", "ip", "set", "post", "out", "open", "art"], "i": ["field", "chi", "uri", "key", "d", "mi", "isin", "ri", "v", "bi", "ami", "iu", "ie", "ji", "ix", "info", "pi", "f", "ti", "phi", "ui", "l", "si", "o", "y", "p", "ci", "qi", "ind", "name", "li", "init", "mu", "ski", "b", "u", "xi", "it", "h", "lc", "io", "fi", "multi", "m", "oi", "ori", "ini", "slice", "x", "uli", "g", "zi", "ai", "t", "ei", "ip", "e", "yi", "source", "index", "hi", "j", "n", "split", "cli", "id", "api", "k", "ii", "c", "di", "gi", "ni", "I"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_whitespace(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \" [ 43 , 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { \"a\", QLIT_QINT(32) },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str), NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 3179, "substitutes": {"i": ["ui", "part", "io", "it", "idi", "l", "fi", "si", "j", "n", "uri", "y", "o", "p", "ci", "multi", "qi", "ind", "eni", "d", "m", "oi", "id", "ori", "I", "mi", "adi", "ri", "k", "ini", "ii", "slice", "v", "bi", "li", "iu", "ie", "ji", "c", "in", "zi", "inner", "di", "ix", "ai", "info", "init", "abi", "pi", "t", "gi", "b", "f", "u", "ti", "jit", "ip", "ni", "e", "xi", "x", "bis", "phi", "iv", "yi", "my", "index"], "encoded": ["engoder", "entoding", "decoder", "deccoded", "decoding", "enoder", "unicoded", "engcoded", "Encoding", " enccoded", "Encrypted", "enoded", "encoder", "Encoded", "engoding", "unicoder", "entoded", "decrypted", "Encoder", "decoded", " encoding", "integicated", "uniccoded", "engoded", "enccoded", "encicated", " encoder", "enoding", "enrypted", "encrypted", " encicated", "entoder", "integcoded", "unicoding", "Enccoded", "decicated", "entcoded", "encoding", "integoding", "integoded"], "test_cases": ["test64reports", " test_steps", "testaldetails", "testalcases", "test64tests", "tested_files", "tested_reports", "testAllcases", "testingtests", " testdefcases", "serveraldetails", "testLcases", " testdeftest", "testAlltests", "test_tests", "testdeftests", "testplecases", "testalclasses", "serveralclasses", "test_rooms", "testingrooms", "testEsteps", " test_tips", "testaltips", "testedPartests", "tested_tests", "testalsteps", "testEtimes", " testdeftests", "testedParfiles", "testParcases", "testpledetails", "test_content", "testedParreports", " test_content", "testedParcases", "testdefcontent", "testParfiles", "test64rooms", "Test_reports", "testdeftest", "test_classes", "test_details", "test_tips", "server_files", "testLclasses", "testingcases", "test_reports", "testAllcontent", " test_times", "testLdetails", "testingreports", "Test_rooms", "testplefiles", "testEcases", "server_cases", "test_steps", "testEreports", " testdefcontent", "testpleclasses", "Test_cases", " test_tests", "serveralcases", "testLfiles", "tested_cases", "testParreports", "testaltimes", "server_classes", " test_test", "test64cases", "test_times", "testPartests", "testEtests", "testEtips", "Test_tests", "testAlltest", "testdefcases", "server_details", "test_test", "testEfiles", "test_files", "testalfiles", "serveralfiles"], "obj": ["part", "att", "po", "alt", "lib", "opt", "ref", "obb", "adj", "z", "sn", "ob", "jp", "block", "cb", "Obj", "os", "json", "js", "iv", "so", "inst", "object", "elt", "o", "p", "bo", "tmp", "name", "ass", "pos", "el", "data", "css", "init", "kl", "style", "b", "op", "err", "pr", "ctx", "code", "active", "act", "nb", "txt", "out", "cat", "val", "attr", "ns", "ex", "img", "j", "n", "pt", "arr", "id", "api", "off", "py", "ext", "coll", "ot", "result", "eff", "dict", "x", "Object", "art"], "str": ["stri", "fr", "cr", "text", "r", "sr", "pr", "tr", "object", "enc", "code", "j", "n", "wr", "elt", "o", "st", "pt", "arr", "dr", "ind", "Str", "name", "z", "cs", "ext", "data", "css", "hr", "rs", "STR", "block", "style", "Obj", "dict", "err", "js", "sl", "bl", "pass", "br"]}}
{"project": "qemu", "commit_id": "0857a06ef784783887e756d4b7b5f874512c506c", "target": 1, "func": "static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)\n\n{\n\n    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {\n\n        if (sregnames[sr].name) {\n\n            qemu_log(\"SR %s is not configured\\n\", sregnames[sr].name);\n\n        } else {\n\n            qemu_log(\"SR %d is not implemented\\n\", sr);\n\n        }\n\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n    } else if (!(sregnames[sr].access & access)) {\n\n        static const char * const access_text[] = {\n\n            [SR_R] = \"rsr\",\n\n            [SR_W] = \"wsr\",\n\n            [SR_X] = \"xsr\",\n\n        };\n\n        assert(access < ARRAY_SIZE(access_text) && access_text[access]);\n\n        qemu_log(\"SR %s is not available for %s\\n\", sregnames[sr].name,\n\n                access_text[access]);\n\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n    }\n\n}\n", "idx": 3180, "substitutes": {"dc": ["draw", "cod", "jc", "cit", "cc", "disc", "cf", "fc", "rc", "context", "ctx", "cca", "vc", "exec", "ec", "cms", "dm", "ct", "d", "xc", "cam", "dat", "DC", "ga", "cdn", "tc", "abc", "df", "pc", "fd", "ca", "ea", "c", "dt", "nc", "mc", "cb", "oc", "ck", "db", "doc", "da", "director", "bc", "cm", "ds", "design", "cd"], "sr": ["fr", "rb", "sw", "cr", "sur", "rr", "ir", "r", "pr", "attr", "sc", "rc", "tr", "SR", "rt", "ssl", "rx", "etr", "yr", "src", "usr", "dr", "adr", "spr", "rf", "radius", "rss", "rw", "route", "ruby", "vr", "RR", "kr", "sb", "hr", "rg", "ser", "nr", "rs", "ru", "rn", "rl", "cur", "serv", "lr", "ctr", "sl"], "access": ["view", "req", "match", "att", "hop", "ord", "array", "num", "rage", "rw", "qa", "est", "row", " acc", "ACC", "image", "max", "inc", " Access", "accessible", "auth", "see", "error", "ac", "object", "close", "ha", "exec", "name", "ride", "method", "ach", "add", "url", "ee", "ace", "serv", "open", "priv", "accept", "ident", "sc", "code", "play", "public", "Access", "param", "acc", "asc", "allow", "read", "address", "ss", "use", "uc", "password", "index", "source", "path", "request", "cache", "attr", "rc", "src", "edge", "alpha", "id", "ga", "connect", "abc", "cast", "esc", "expr", "rib", "pass", "en", "escape"], "access_text": ["accessible_letter", "access_txt", "Access_name", "access_TEXT", "accessible_txt", "accessingsource", "access2string", "accessPtext", "access_source", "access_length", " access_length", "access___letter", "access2name", "access_string", "accessPbytes", " access_TEXT", " access_source", "Access_string", "access_letter", "accessible_bytes", "access___txt", "accessingtext", "accessPtxt", "accessingname", " access_name", "access___text", "accessible_text", " access_txt", "access_name", "Access_text", "access2text", "access_bytes", "access___bytes", "accessPletter"]}}
{"project": "qemu", "commit_id": "e41029b378b4a65a0b89b5a8dc087aca6b5d012d", "target": 1, "func": "static void gen_lswi(DisasContext *ctx)\n\n{\n\n    TCGv t0;\n\n    TCGv_i32 t1, t2;\n\n    int nb = NB(ctx->opcode);\n\n    int start = rD(ctx->opcode);\n\n    int ra = rA(ctx->opcode);\n\n    int nr;\n\n\n\n    if (nb == 0)\n\n        nb = 32;\n\n    nr = (nb + 3) / 4;\n\n    if (unlikely(lsw_reg_in_range(start, nr, ra))) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n        return;\n\n    }\n\n    gen_set_access_type(ctx, ACCESS_INT);\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    t0 = tcg_temp_new();\n\n    gen_addr_register(ctx, t0);\n\n    t1 = tcg_const_i32(nb);\n\n    t2 = tcg_const_i32(start);\n\n    gen_helper_lsw(cpu_env, t0, t1, t2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free_i32(t1);\n\n    tcg_temp_free_i32(t2);\n\n}\n", "idx": 3182, "substitutes": {"ctx": ["kb", "gru", "cu", "cc", "pkg", "mac", "loc", "sc", "cf", "rc", "cmp", "context", "cs", "cpp", "grad", "conv", "cca", "vc", "fp", "exec", "ci", "ce", "connection", "cms", "gc", "xc", "cli", "config", "cam", "ga", "cgi", "qa", "Context", "tc", "sci", "cv", "cp", "lc", "conn", "pc", "ca", "gpu", "cn", "txt", "css", "c", "ctrl", "nc", "jp", "cpu", "cb", "tx", "crit", "ck", "cmd", "hw", "client", "component", "cor", "bc", "cfg", "cas", "sync", "cm", "anc", "cus"], "t0": ["ta1", "tty000", "f0", "t4", " t4", "t8", "p0", "t000", " t8", "p1", "ta50", "tty50", "f4", "ta000", "rt0", "T000", "ta0", "f2", "T0", "T1", "T50", "T4", "tty1", "rt8", "p2", "t50", "f1", "tty0", "T2", "p4", "T8", "rt1"], "t1": ["t01", "T81", " t81", "t4", " t4", " tOne", "p0", "test01", "te1", "tt1", "p1", "tt2", "T01", "t81", " tone", "T9", "tone", " t9", "test1", "teone", "t3", "T3", "te2", "test3", "the01", "Tone", "T0", "T1", "the3", "T4", "te9", "p2", "ttOne", "t9", "TOne", "T2", "p4", "the1", "tt81", "tOne"], "t2": ["it2", "ttwo", "tt8", "t4", "dt52", " tTwo", "t8", "v2", "p0", "tt52", "at32", "vtwo", "t200", "x2", "t52", "p1", "tt2", " t8", "t6", "it4", "p200", "it32", " t52", "xtwo", "at4", "dt2", "tTwo", "x6", "at200", "T0", "T1", " ttwo", "dt8", "at2", "T6", "Ttwo", " t6", "p32", "dtTwo", "p2", "ptwo", "ttTwo", "v0", "T2", "v1", "p4", "x1", "it200", "t32"], "nr": ["next", "rb", "rr", "nob", "eno", "r", "inv", "n", "num", "wr", "rx", "uni", "number", "nn", "nor", "adr", "eni", "min", "rf", "ori", "mr", "rar", "sn", "rss", "ri", "nz", "len", "arin", "NR", "area", "rec", "nb", "mid", "nt", "nu", "nc", "np", "ru", "init", "rn", "ner", "nl", "rel", "oa", "range", "ni", "nw", "lr", "net", "ra", "nos"]}}
{"project": "FFmpeg", "commit_id": "c61b28e0421f0f9502dfb21495a03cda191def15", "target": 0, "func": "static int decode_frame(AVCodecContext *avctx, const uint8_t *databuf,\n\n                        float **out_samples)\n\n{\n\n    ATRAC3Context *q = avctx->priv_data;\n\n    int ret, i;\n\n    uint8_t *ptr1;\n\n\n\n    if (q->coding_mode == JOINT_STEREO) {\n\n        /* channel coupling mode */\n\n        /* decode Sound Unit 1 */\n\n        init_get_bits(&q->gb, databuf, avctx->block_align * 8);\n\n\n\n        ret = decode_channel_sound_unit(q, &q->gb, q->units, out_samples[0], 0,\n\n                                        JOINT_STEREO);\n\n        if (ret != 0)\n\n            return ret;\n\n\n\n        /* Framedata of the su2 in the joint-stereo mode is encoded in\n\n         * reverse byte order so we need to swap it first. */\n\n        if (databuf == q->decoded_bytes_buffer) {\n\n            uint8_t *ptr2 = q->decoded_bytes_buffer + avctx->block_align - 1;\n\n            ptr1          = q->decoded_bytes_buffer;\n\n            for (i = 0; i < avctx->block_align / 2; i++, ptr1++, ptr2--)\n\n                FFSWAP(uint8_t, *ptr1, *ptr2);\n\n        } else {\n\n            const uint8_t *ptr2 = databuf + avctx->block_align - 1;\n\n            for (i = 0; i < avctx->block_align; i++)\n\n                q->decoded_bytes_buffer[i] = *ptr2--;\n\n        }\n\n\n\n        /* Skip the sync codes (0xF8). */\n\n        ptr1 = q->decoded_bytes_buffer;\n\n        for (i = 4; *ptr1 == 0xF8; i++, ptr1++) {\n\n            if (i >= avctx->block_align)\n\n                return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n\n\n        /* set the bitstream reader at the start of the second Sound Unit*/\n\n        init_get_bits8(&q->gb, ptr1, q->decoded_bytes_buffer + avctx->block_align - ptr1);\n\n\n\n        /* Fill the Weighting coeffs delay buffer */\n\n        memmove(q->weighting_delay, &q->weighting_delay[2],\n\n                4 * sizeof(*q->weighting_delay));\n\n        q->weighting_delay[4] = get_bits1(&q->gb);\n\n        q->weighting_delay[5] = get_bits(&q->gb, 3);\n\n\n\n        for (i = 0; i < 4; i++) {\n\n            q->matrix_coeff_index_prev[i] = q->matrix_coeff_index_now[i];\n\n            q->matrix_coeff_index_now[i]  = q->matrix_coeff_index_next[i];\n\n            q->matrix_coeff_index_next[i] = get_bits(&q->gb, 2);\n\n        }\n\n\n\n        /* Decode Sound Unit 2. */\n\n        ret = decode_channel_sound_unit(q, &q->gb, &q->units[1],\n\n                                        out_samples[1], 1, JOINT_STEREO);\n\n        if (ret != 0)\n\n            return ret;\n\n\n\n        /* Reconstruct the channel coefficients. */\n\n        reverse_matrixing(out_samples[0], out_samples[1],\n\n                          q->matrix_coeff_index_prev,\n\n                          q->matrix_coeff_index_now);\n\n\n\n        channel_weighting(out_samples[0], out_samples[1], q->weighting_delay);\n\n    } else {\n\n        /* single channels */\n\n        /* Decode the channel sound units. */\n\n        for (i = 0; i < avctx->channels; i++) {\n\n            /* Set the bitstream reader at the start of a channel sound unit. */\n\n            init_get_bits(&q->gb,\n\n                          databuf + i * avctx->block_align / avctx->channels,\n\n                          avctx->block_align * 8 / avctx->channels);\n\n\n\n            ret = decode_channel_sound_unit(q, &q->gb, &q->units[i],\n\n                                            out_samples[i], i, q->coding_mode);\n\n            if (ret != 0)\n\n                return ret;\n\n        }\n\n    }\n\n\n\n    /* Apply the iQMF synthesis filter. */\n\n    for (i = 0; i < avctx->channels; i++) {\n\n        float *p1 = out_samples[i];\n\n        float *p2 = p1 + 256;\n\n        float *p3 = p2 + 256;\n\n        float *p4 = p3 + 256;\n\n        ff_atrac_iqmf(p1, p2, 256, p1, q->units[i].delay_buf1, q->temp_buf);\n\n        ff_atrac_iqmf(p4, p3, 256, p3, q->units[i].delay_buf2, q->temp_buf);\n\n        ff_atrac_iqmf(p1, p3, 512, p1, q->units[i].delay_buf3, q->temp_buf);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3183, "substitutes": {"avctx": ["afcontext", "avcu", "abconfig", "aflc", "avconn", "AVctx", "avecmp", "avectx", "evconn", "abctx", "afcu", "airctrl", "avcc", "AVconfig", " avcontext", "navcmp", "navconn", "navconnection", "avcmp", "abcmp", "ablc", "avsq", " avcmp", "abcontext", "afcc", "apctx", "AVlc", " avconn", "afutils", "abcc", "aveconnection", "afsq", "afconn", "afconnection", "navcontext", "navctx", " avsq", "afcmp", "abconn", "aircontext", "apconfig", "afctx", "avecontext", "avlc", "evctx", "navutils", "abctrl", "abcu", "apcontext", "abutils", "afctrl", " avcc", "avctrl", "avecu", "evcontext", "apcmp", "avconfig", "AVcontext", "airconn", "evsq", "AVcmp", "avcontext", "avutils", "airctx", "avconnection", "afconfig"], "databuf": ["databale", "datacull", " datobale", " datobuffer", "datacuf", "datacluff", "datacluffer", "databsuf", "dataloguf", "dataclef", "datalogbuf", "databuff", "databouf", "datobuf", "databbuf", "datABuff", "datacuffer", "datobale", "datbuf", " datobef", "datacuff", "datambuf", "datalogull", "datbef", "datobuffer", " databbuf", "databsuff", " databale", "datbuff", " databef", "datacluf", "datobef", "datbuffer", " databull", "databef", " datobbuf", " databuffer", "datobull", "databull", "databsuffer", "datABbuf", "databuffer", "databoull", "databouffer", "dataloguff", "datambale", "datambull", "databsull", "datobbuf", "datABuf", " databuff", "databoale", " datobuff", " datobull", "datobuff", "datABull", " datobuf", "datambuffer"], "out_samples": ["out_bamples", "out_samps", "out_pamps", "out_pamp", "out_samp", "out_bamp", "out_tounds", "out_pources", "out_tamps", "out_pamples", "out_sounds", "out_bources", "out_sources", "out_Sounds", "out_Sources", "out_Samps", "out_Samp", "out_bamps", "out_Samples", "out_tamp", "out_tamples"], "q": ["comment", "cal", "update", "view", "cache", "pkg", "req", "cf", "ctx", "n", "conf", "core", "qs", "o", "sh", "p", "ue", "http", "qu", "requ", "qq", "qi", "query", "input", "d", "config", "sq", "m", "queue", "check", "w", "k", "quant", "qa", "v", "aq", "question", "co", "g", "iq", "request", "c", "comp", "self", "dq", "ch", "get", "quest", "ck", "t", "que", "cl", "u", "f", "cur", "client", "cmd", "quad", "post", "e", "x", "Q", "qt", "sync", "ce", "pg", "h"], "ret": ["rep", "wa", "bf", "val", "rb", "res", "back", " RET", "r", "error", "att", "def", "rc", "rt", "code", " Ret", "num", "flag", "alt", "opt", "fin", "RET", "ref", "det", "obj", "iter", "status", "len", "no", "run", "lit", "success", "rets", "feat", "data", "reply", "mt", "fun", "nt", "pre", "result", "Ret", "t", "f", "al", "cur", "out", "x", "re", "pass", "bit", "en", "art"], "i": ["hi", "chi", "ui", "io", "it", "l", "fi", "si", "j", "uri", "n", "y", "o", "p", "ci", "key", "multi", "qi", "ind", "eni", "d", "m", "cli", "mi", "id", "z", "ri", "ini", "ii", "slice", "v", "bi", "x", "uli", "li", "ie", "iu", "ji", "ki", "c", "zi", "di", "ix", "ai", "info", "pi", "mu", "gi", "f", "u", "b", "ti", "ip", "ni", "e", "xi", "I", "inner", "phi", "yi", "my", "index"], "ptr1": ["dr1", "Ptrn", "sth1", " ptr61", "tr4", " ptr9", "ptrn", "dr2", "pse61", "pointer3", "tr8", "dr0", "dr4", "sth61", "pt0", " ptrOne", "dr3", "pointer0", "sthOne", "Ptr2", "Ptr9", "tr0", "pointerOne", "pt4", "ptr01", "ptrname", "tr2", "sthn", "sth01", "pt3", "pointer01", "ptname", "ptr8", "pointer1", "ptr61", "ref1", "pt2", "Ptr01", "pse15", "ptr9", "ptr4", "sth2", "refone", "ptr0", "pt1", "ptr15", "pointer61", "pointer8", "Ptr1", "pointername", "ptr3", " ptr15", "trone", "ptrone", "pointern", "pse2", " ptrname", "pointer9", "tr1", "pointer15", "pse1", "pointer2", " ptr3", "pointer4", "ptrOne", "ref8", "Ptr3", "pointerone", "ref2"], "ptr2": ["dr1", "pad4", "ptrii", "dest2", "dr2", "pointer3", " ptr0", "ptb", "dr4", "pt0", "dr3", "pointer0", "dest1", "pt4", "pad2", "pointertwo", "pointerD", "pt3", "pointer1", "ptD", "pt2", "ptr4", "pointerTwo", "ptrb", "pointerii", "ptr0", "pt1", " ptrb", "destii", "pointerb", "ptrTwo", "ptrtwo", "ptr3", " ptrD", " ptrtwo", "ptrD", "padTwo", "drTwo", " ptrii", "pad1", "pointer4", "pointer2", " ptr3", "desttwo"]}}
{"project": "qemu", "commit_id": "367790cce8e14131426f5190dfd7d1bdbf656e4d", "target": 1, "func": "uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)\n\n{\n\n    uint64_t temp;\n\n    uint32_t result;\n\n\n\n    shift &= 63;\n\n    temp = (uint64_t)val << 32 >> shift;\n\n    result = temp >> 32;\n\n\n\n    env->cc_c = (temp >> 31) & 1;\n\n    env->cc_n = result;\n\n    env->cc_z = result;\n\n    env->cc_v = 0;\n\n    env->cc_x = shift ? env->cc_c : env->cc_x;\n\n\n\n    return result;\n\n}\n", "idx": 3184, "substitutes": {"env": ["manager", "esp", "equ", "her", "context", "enc", "ctx", "conf", "er", "core", "eu", "opt", "exec", "ec", "hess", "viron", "eni", "config", "edge", "obj", "chal", "et", "engine", "operator", "eve", "esi", "event", "build", "v", "here", "inet", "conn", "el", "energy", "erv", "ne", "console", "txt", "ea", "server", "output", "site", "app", "export", "eng", "self", "ef", "np", "init", "exc", "style", "global", "dict", "vert", "db", "que", "dev", "err", "inc", "vs", "eur", "vel", "extra", "e", "environment", "emb", "net", "client", "ev", "fg", "en"], "val": ["eval", "update", "all", "cache", "value", "base", "grad", "unit", "sel", "p", "valid", "Val", "exec", "fl", "split", "min", "call", "ret", "iter", "sum", "vol", "len", "slice", "ul", "v", "el", "li", "data", "vals", "pre", "test", "ee", "cash", "VAL", "arg", "sl", "seq"], "shift": ["offset", "i", "diff", "transform", "scale", "sort", "array", "Shift", "sh", "stack", "square", "strip", "sq", "force", "pop", "slice", "count", "pad", "sleep", "ffff", "mix", "wrap", "adjust", "reverse", "shr", "length", "work", "shape", "hift", "seed", "power", "center", "pack", "max", "cost", "push", "align", "fold", "range", "set", "extra", "frac", "size", "ctr", "pull", "sup", "repeat", "seq", "index"], "temp": ["offset", "cache", "total", "diff", "fact", "base", "form", "cf", "tr", "null", "tmp", "valid", "opt", "key", "fit", "input", "iter", "buffer", "tem", "partial", "orig", "fake", "tc", "count", "mix", "data", "Temp", "wrap", "txt", "flat", "length", "output", "shape", "emp", "c", "pre", "test", "current", "ee", "cert", "atom", "seed", "eff", "Result", "cur", "extra", "ctr", "empty", "timeout", "cel", "source"], "result": ["cup", "cache", "i", "res", "value", "diff", "r", "rh", "match", "grade", "array", "zero", "valid", "tmp", "new", "ret", "sum", "count", "master", "success", "mix", "data", "sign", "parent", "length", "output", "work", "complete", "pair", "test", "current", "results", "cash", "response", "err", "effect", "Result", "cur", "ver", "extra", "instance", "final", "use", "message", "order"]}}
{"project": "qemu", "commit_id": "95ce326e5b47b4b841849f8a2ac7b96d6e204dfb", "target": 1, "func": "static void term_down_char(void)\n\n{\n\n    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)\n\n\treturn;\n\n    if (term_history[++term_hist_entry] != NULL) {\n\n\tstrcpy(term_cmd_buf, term_history[term_hist_entry]);\n\n    } else {\n\n\tterm_hist_entry = -1;\n\n    }\n\n    term_printf(\"\\n\");\n\n    term_print_cmdline(term_cmd_buf);\n\n    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n\n}\n", "idx": 3205, "substitutes": {"term_hist_entry": ["term_hist_no", "term_history_count", "term_history_ry", "term_history_Entry", "term_history_entry", "term_orig_index", "term_history_index", "term_history_number", "term_histidentry", "term_hist64entry", "term_hist_size", "term_histsno", "term_histidnumber", "term_history_size", "term_orig_entry", "term_hist_enter", "term_histsindex", "term_hist64enter", "term_history_start", "term_hist_ry", "term_history_nr", "term_histsentry", "term_histalnr", "term_hist_Entry", "term_histalcount", "term_hist64start", "term_orig_no", "term_hist_id", "term_orig_id", "term_histidsize", "term_histidindex", "term_history_enter", "term_hist_start", "term_histsid", "term_hist_index", "term_histalentry", "term_hist_nr", "term_hist_number", "term_hist_count"]}}
{"project": "FFmpeg", "commit_id": "3d2c3ef4b46d96023d6f0d358e4d7d65568da67c", "target": 0, "func": "static int decode_cabac_mb_cbp_luma( H264Context *h) {\n\n    int cbp_b, cbp_a, ctx, cbp = 0;\n\n\n\n    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;\n\n    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;\n\n\n\n    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);\n\n    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;\n\n    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;\n\n    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;\n\n    return cbp;\n\n}\n", "idx": 3211, "substitutes": {"h": ["hi", "host", "hm", "rh", "r", "l", "hs", "hh", "gh", "sh", "header", "hash", "adh", "p", "ht", "ha", " H", "hist", "d", "m", "w", "hl", "oh", "ul", "th", "uh", "ang", "ah", "g", "work", "c", "hr", "ph", "he", "eh", "self", "bh", "dh", "ch", "ih", "hd", "t", "history", "hp", "f", "u", "b", "e", "http", "hw", "H"], "cbp_b": ["cbp25k", "cbpu25b", "cbpc_b", "cbpo_k", "cbpu_as", "cbp__bb", "cbpu25a", "cbp_k", "cbpu25as", "cbp_l", "cbpu_a", "cbp__b", "cbp25l", "cbpc_bb", "cbp25a", "cbpo_b", "cbp25bb", "cbpu_l", "cbp25as", "cbp_bb", "cbpo_bb", "cbpu25l", "cbp_as", "cbp_B", "cbpu_b", "cbpc_r", "cbpc_a", "cbp_r", "cbnp_b", "cbp__r", "cbnp_B", "cbp25bs", "cbnp_r", "cbp__a", "cbpo_bs", "cbp_bi", "cbp25b", "cbp_bs", "cbnp_bi"], "cbp_a": ["cbp64ae", "cblp_area", "cbc_a", "cbp_area", "cbpi_a", "cbp_aj", "cbapi_an", "cbp64area", "cblp_as", "cbp128ga", "cbp_p", "cblp_ae", "cbpi_p", "cbc_ab", "cblp_a", "cbp6ae", "cbp__ae", "cbp128an", "cbapi5aj", "cblp6as", "cblp6a", "cbpi_n", "cbapi5ga", "cbp_ae", "cbp5ga", "cbapi_aj", "cbp__area", "cbp_an", "cbapi5an", "cbc_A", "cblp6ae", "cbp_as", "cblp6area", "cbp64a", "cbp_ga", "cbapi_ga", "cbp5an", "cbp6area", "cbp64as", "cbpi_b", "cbp5a", "cbp6a", "cbp__a", "cbp128aj", "cbp_A", "cbp_n", "cbapi5a", "cbp__as", "cbp6as", "cbp5aj", "cbapi_a", "cbc_ga", "cbp128a", "cbp_ab"], "ctx": ["fn", "kb", "kw", "wx", "cu", "val", "cc", "pkg", "loc", "cy", "sc", "cf", "cpp", "cmp", "context", "fc", "rc", "cs", "conv", "cca", "vc", "fp", "ci", "ht", "kk", "src", "cue", "xc", "ct", "config", "sq", "cli", "buf", "qa", "tc", "unc", "sci", "cv", "cp", "x", "lc", "conn", "ca", "co", "feat", "cn", "css", "txt", "fw", "c", "progress", "ctrl", "comp", "dt", "nc", "np", "jp", "ch", "cb", "tx", "csv", "ck", "wcs", "cmd", "hw", "component", "bc", "cfg", "cas", "sync", "cm", "anc"]}}
{"project": "FFmpeg", "commit_id": "f0adb99d068e659178c00271a46cd469dfc01a6e", "target": 1, "func": "void ff_qsv_decode_reset(AVCodecContext *avctx, QSVContext *q)\n\n{\n\n    QSVFrame *cur;\n\n    AVPacket pkt;\n\n    int ret = 0;\n\n    mfxVideoParam param = { { 0 } };\n\n\n\n    if (q->reinit_pending) {\n\n        close_decoder(q);\n\n    } else if (q->engine_ready) {\n\n        ret = MFXVideoDECODE_GetVideoParam(q->session, &param);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MFX decode get param error %d\\n\", ret);\n\n        }\n\n\n\n        ret = MFXVideoDECODE_Reset(q->session, &param);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MFX decode reset error %d\\n\", ret);\n\n        }\n\n\n\n        /* Free all frames*/\n\n        cur = q->work_frames;\n\n        while (cur) {\n\n            q->work_frames = cur->next;\n\n            av_frame_free(&cur->frame);\n\n            av_freep(&cur);\n\n            cur = q->work_frames;\n\n        }\n\n    }\n\n\n\n    /* Reset output surfaces */\n\n    av_fifo_reset(q->async_fifo);\n\n\n\n    /* Reset input packets fifo */\n\n    while (av_fifo_size(q->pkt_fifo)) {\n\n        av_fifo_generic_read(q->pkt_fifo, &pkt, sizeof(pkt), NULL);\n\n        av_packet_unref(&pkt);\n\n    }\n\n\n\n    /* Reset input bitstream fifo */\n\n    av_fifo_reset(q->input_fifo);\n\n}\n", "idx": 3227, "substitutes": {"avctx": ["afcontext", "afsci", "aflc", "AVcf", "AVctx", "avmac", "capcontext", "capcf", " avcontext", "AVmac", "avcmp", "capctx", "navlc", "avsci", " avcmp", "AVlc", "AVsci", "afcf", "navcontext", "navctx", "avcf", "afcmp", "afctx", "avlc", "afmac", " avmac", "AVcontext", "capcmp", "AVcmp", "avcontext", "navsci"], "q": ["comment", "cal", "update", "view", "i", "req", "sync", "quick", "l", "context", "ctx", "conf", "core", "qs", "lib", "pg", "p", "ue", "qu", "requ", "qq", "qi", "query", "module", "input", "d", "m", "sq", "call", "queue", "id", "z", "check", "config", "w", "qa", "quant", "k", "v", "event", "question", "co", "g", "iq", "batch", "work", "c", "self", "dq", "info", "ch", "get", "quest", "ck", "t", "que", "f", "cmd", "client", "u", "cl", "e", "Q", "qt", "h", "ce", "request"], "cur": ["sth", "req", "ok", "enc", "sel", "usr", "keep", "build", "Cur", "ur", "ah", "row", "ch", "der", "ctr", "quad", "cr", "cher", "gr", "sr", "fac", "tr", "rev", "per", "ach", "circ", "ry", "arch", "current", "gg", "err", "open", "ct", "cor", "fr", "feed", "focus", "r", "pr", "sch", "fer", "car", "param", "query", "dr", "var", "pub", "con", "conn", "spec", "ser", "pair", "prev", "oc", "ver", "child", "bur", "uc", "cat", "sur", "attr", "rc", "or", "qu", "tur", "cer", "rest", "aur", "c", "inter", "par", "client"], "pkt": ["peacket", "pkg", "Pk", "pekid", "pet", "Pct", "Pkt", " pqt", "Pkid", "punk", "opunk", "packet", "bpkg", "bpqt", "opct", "Pqt", "mkt", "pkid", "pct", "opacket", "Packet", "mqt", "pqt", "bpkt", "pk", "mKT", "peqt", " packet", " pct", " pkid", "pekt", "mkg", "Pet", "Punk", " pk", "peet", "pek", "pKT", " punk", " pkg", " pKT", "opkt", "bpKT", " pet"]}}
{"project": "qemu", "commit_id": "0fcec41eec0432c77645b4a407d3a3e030c4abc4", "target": 1, "func": "target_ulong helper_sdiv(target_ulong a, target_ulong b)\n\n{\n\n    int64_t x0;\n\n    int32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        raise_exception(TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 / x1;\n\n    if ((int32_t) x0 != x0) {\n\n        env->cc_src2 = 1;\n\n        return x0 < 0? 0x80000000: 0x7fffffff;\n\n    } else {\n\n        env->cc_src2 = 0;\n\n        return x0;\n\n    }\n\n}\n", "idx": 3228, "substitutes": {"a": ["i", "base", "ac", "array", "n", "y", "p", "A", "va", "m", "aj", "alpha", "ma", "ae", "sa", "ba", "ad", "an", "area", "aa", "am", "ca", "c", "ar", "app", "la", "aaa", "oa", "as", "asa", "f", "u", "pa", "da", "e", "x", "s"], "b": ["i", "rb", "base", "r", "bp", "l", "bb", "j", "n", "bd", "y", "p", "ib", "B", "ab", "d", "bs", "w", "ad", "fb", "ba", "mb", "v", "g", "eb", "c", "sb", "ob", "db", "f", "u", "e", "x", "s"], "x0": ["ex000", "x00", "xx0", "f0", "f50", "ax6", "xee", "lex100", "Xee", "X100", "ax1", "ix1", "ux6", "xx1", "ix0", "ix25", "x2", " xee", "x100", "lex2", "ix000", "ex2", "ux029", "x25", "ux0", "ixee", "ax0", "x000", "xx2", "f00", "ax029", " x3", "X1", "x6", "X3", "ix00", "ex00", "xx3", "X00", " x100", " x50", "X50", "x029", " x000", "ax00", "x3", "X0", "ex0", " x2", " x029", " x6", "ex1", " x00", "x50", "f1", "lex0", " x25", "ux1", "lex1", "X2", "X25"], "x1": ["vb", "Xb", "x11", "xx0", "xx9", "xn", "xxOne", "x9", "xx11", "xb", "xx01", "v2", " x11", "XOne", "xx1", "x2", " xb", "Xn", "X9", " x9", "xx2", " x3", "X1", "X3", "X01", "xx3", " x01", "X11", "x3", " xOne", "X0", " x2", "xOne", "x01", "vn", " xn", "v1", "X2"]}}
{"project": "qemu", "commit_id": "898248a32915024a4f01ce4f0c3519509fb703cb", "target": 1, "func": "static void xhci_reset(DeviceState *dev)\n\n{\n\n    XHCIState *xhci = XHCI(dev);\n\n    int i;\n\n\n\n    trace_usb_xhci_reset();\n\n    if (!(xhci->usbsts & USBSTS_HCH)) {\n\n        DPRINTF(\"xhci: reset while running!\\n\");\n\n    }\n\n\n\n    xhci->usbcmd = 0;\n\n    xhci->usbsts = USBSTS_HCH;\n\n    xhci->dnctrl = 0;\n\n    xhci->crcr_low = 0;\n\n    xhci->crcr_high = 0;\n\n    xhci->dcbaap_low = 0;\n\n    xhci->dcbaap_high = 0;\n\n    xhci->config = 0;\n\n\n\n    for (i = 0; i < xhci->numslots; i++) {\n\n        xhci_disable_slot(xhci, i+1);\n\n    }\n\n\n\n    for (i = 0; i < xhci->numports; i++) {\n\n        xhci_port_update(xhci->ports + i, 0);\n\n    }\n\n\n\n    for (i = 0; i < xhci->numintrs; i++) {\n\n        xhci->intr[i].iman = 0;\n\n        xhci->intr[i].imod = 0;\n\n        xhci->intr[i].erstsz = 0;\n\n        xhci->intr[i].erstba_low = 0;\n\n        xhci->intr[i].erstba_high = 0;\n\n        xhci->intr[i].erdp_low = 0;\n\n        xhci->intr[i].erdp_high = 0;\n\n        xhci->intr[i].msix_used = 0;\n\n\n\n        xhci->intr[i].er_ep_idx = 0;\n\n        xhci->intr[i].er_pcs = 1;\n\n        xhci->intr[i].er_full = 0;\n\n        xhci->intr[i].ev_buffer_put = 0;\n\n        xhci->intr[i].ev_buffer_get = 0;\n\n    }\n\n\n\n    xhci->mfindex_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n    xhci_mfwrap_update(xhci);\n\n}\n", "idx": 3236, "substitutes": {"dev": ["mod", "serial", "wd", "home", "tty", "req", "priv", "device", "def", "de", "grad", "conf", "temp", "debug", "DEV", "d", "var", "cam", "w", "ad", "mode", "conn", "data", "pro", "development", "spec", "Dev", "nt", "devices", "test", "ch", "proc", "der", "ver", "rad", "sk", "ev", "hw", "dom"], "xhci": ["xwlc", "xhtci", "xphce", "xvci", "xhdli", " xwci", "xihui", "xhlcy", "phphcu", "sexhostce", "Xhdi", "rxhcu", "xxcci", "rxhcci", "xhtcit", "wehci", "xshai", "xehcit", "xhdci", "xehdr", "Xehii", "xbhlc", "xahli", "exphcci", "xhdcli", "xhdcod", "wehsci", " xphcit", "xphcin", "xshcin", "xpcci", "xhhcu", "xvdi", "xrhki", "phhcu", "xuhcin", "xahii", "xrhcin", "xhdi", "txehcu", "xhdodi", "eventhdco", "xxhco", " xehcin", "oxhlc", "ixhci", "xhlki", " xhcy", "xhwci", "xhscus", "xhmdi", "oxhcca", "xhcu", "wehlci", "xrhcci", "xhlsi", "exphci", "xhco", "xwcli", "xbhcit", "xahdr", " xehcci", "fxhsci", "phphci", "xhtcin", "txhli", "xrhii", "txehda", "xhdcu", "xwii", "myhmci", "xxbc", "plushci", "xhhcin", "xhcus", "xehdi", "fxhcp", "eventhdodi", "txehcci", "myhcit", "exhce", "xahco", "xhcci", "xhce", "fxehci", "xshcus", "xhldr", "phphlsci", "oxhii", "xbhci", "sexhco", "xihcca", " xhlc", "tyshai", "xhostsci", "xhlari", "phhci", "xphsi", " xphco", "phhii", "txhvi", "xrhui", "fxehcp", "wehlcit", "sexhostci", "txehci", "Xehki", "eventhdci", "oxhlvi", "xxehcci", "xhscod", "xhdbc", "phphsci", "xhwcus", "xahcli", "xrhlc", "xehlc", "xhhii", "xhcit", "ixhcod", "xihari", "phihii", "xhcli", "oxhdlc", "tyshcci", "xhtli", " xwcycle", "wehlsci", "xehcli", " xehcu", "xhii", "xhcca", "xxci", " xphcy", "plusehdi", "myhii", "xhki", "xehcin", "xuhcus", "xhdco", "xphki", "xhlcin", "xhdii", " xwii", "exhcli", "xihlc", "ixhdcli", "xhhsci", "exphcin", "xehco", "xhlcca", "rxhdr", "xshli", "ixhdli", "txehli", "xvcit", "sexhostco", "xhcod", "oxhvi", "xbhco", "eventhodi", "xbhcin", "oxhci", "txhcci", "exphco", "huhci", "fxhco", "xrhli", "Xhci", "xhmci", "xphci", "exhcci", "ixhdcod", "xhllc", "txehcm", "plusehci", "myahii", "phhui", "plushsi", "xhct", "xhsbc", "xrhci", "xhlbc", " xwbc", "xenki", " xhcin", "xhostvi", "xhsi", "xhdda", "xhdcca", "oxhlci", "xwcus", "oxhcci", "xhwcci", "Xehdi", "xhlco", "myhbc", "xhbc", " xhcycle", " xhbc", "xwbc", "xhlci", "Xhii", "sexhci", "txehki", "xahcu", "txhki", "xhlcm", "txhda", "xhdr", "xhari", "txehvi", "xphlc", "xehvi", "oxhari", "xuhci", "xhcy", "eventhco", "xehii", "xhmcit", "oxhlii", "Xehci", " xwcus", "xwcu", "fxhii", "xhwct", "plushcci", "eventhci", "xahbc", "sexhce", "tyhai", "plusehsi", "xxhcit", "phihci", "xxhci", "xhlcit", "xencin", "wehcin", "xehcm", " xhii", "plusehcci", "myhci", "sexhostsci", "xehce", "xwco", "oxhlcci", "xshcci", "xehsi", "xwci", "xbhcy", "rxehcu", "tyshli", "xhostci", "ixhli", "xphco", "xhlcu", "tyhci", "xxehco", "xhcycle", " xphci", "ixhdci", "plushdi", "xhdcin", "xhlce", "xpii", "xehcci", "fxehco", " xhki", "xehcod", "exphcli", "xhhci", "xxehcit", "xhwcin", "xhlsci", "xehcp", "xhssci", "xhtcci", "wehcit", "xrhco", "xhostce", "xhostcci", "phihui", "xrhai", "xwcycle", "xhlcycle", "myhmcit", "xhli", "xrhcu", "hhct", "xphcli", "xwodi", "xshct", "xphcu", "xhdlc", "xehda", "xphcci", "xhostco", "xhlcci", "xrhcycle", "xphii", "xehli", "xshci", "xehci", "tyhli", "xhldi", " xwcin", "eventhcli", "xahki", "exhci", "xhtdi", "xhcp", "fxehsci", "huhct", "myhmii", "xhmsci", " xhcus", "xhcin", "txhci", "fxehcod", "xrhsci", "xhtcli", "xhwai", "myahbc", "myhcci", " xwlc", "phphlcu", "xbhli", "xhtii", "xphcit", "phihcu", "xehodi", "xhlvi", "xhtki", "xehki", "xphli", "xehcu", "xahci", "xhda", "phphlcin", " xhcu", "xpci", "xxhcci", "myahcci", "myahci", "xhwli", "xbhsci", "txhcm", "xhlui", "xuhct", "xhostii", "xxii", " xphlc", "tyshci", "tyhcci", "xphda", "exphce", "xphcy", "oxhdari", "phphlci", "oxhdci", " xhcit", "xhsci", "fxhcod", "xrhcli", "txhcu", "hhci", "eventhdcli", "xhtcod", "xphcp", "xhai", "xahcci", "xrhce", "xhui", "xhlli", "xhodi", "wehlcin", "xhvi", "xxehci", "xvii", " xhli", "xhtco", "exhco", " xhcci", "xehsci", "xhmcin", "hhcin", "xenci", "fxehii", "xhsii", "xhlii", "xhhcod", "xihci", "xwcm", "xhmii", " xehci", "xwki", " xwki", "xhdari", "huhcus", "exhcin", "myhmdi", "xhlcp", "hhcus", "xihii", "xhslc", "xwcin", "xpvi", "phphcin", "rxehcci", "rxehci", "fxhci", "oxhdcca", "xphdi", " xhco", "xihcu", "ixhcli", "xhlcus", "xphsci", "xenii", "xhtcu", "xhcm", "huhcin", "sexhsci", " xphli", "xhlc", "rxhci", "xhdcci", "rxehdr", "myhdi", "Xhki", "xwvi"], "i": ["series", "iii", "uri", "d", "mi", "z", "isin", "ri", "v", "bi", "iu", "ie", "ji", "ix", "info", "jp", "image", "pi", "f", "ti", "iv", "phi", "ui", "inst", "l", "si", "is", "o", "y", "p", "ci", "qi", "eni", "I", "li", "init", "mu", "b", "u", "xi", "it", "lc", "fr", "udi", "io", "fi", "multi", "oi", "interface", "ini", "slice", "uli", "g", "zi", "ai", "t", "ip", "e", "esi", "yi", "index", "isi", "j", "n", "module", "cli", "id", "api", "adi", "k", "ii", "a", "mini", "c", "di", "abi", "gui", "gi", "ni", "x", "inner"]}}
{"project": "qemu", "commit_id": "068abdc8a57023eeafe1025b964a50f8a39929b4", "target": 1, "func": "int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def)\n\n{\n\n    int i, ret;\n\n\n\n    ret = -1;\n\n    *def = NULL;\n\n    for (i = 0; ppc_defs[i].name != NULL; i++) {\n\n        if ((pvr & ppc_defs[i].pvr_mask) ==\n\n            (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {\n\n            *def = &ppc_defs[i];\n\n            ret = 0;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3237, "substitutes": {"pvr": ["fvr", " Pvr", "pvt", "lprt", " pver", "lpvr", "prt", "pwr", "pver", "tpwr", "lpvt", "fcv", "lpver", " Pvt", " prt", " Prt", " pcv", "lpwr", "ppvr", " pwr", "fwr", " pvt", "ppvt", " Pver", "pcv", "ppcv", "lpcv", "ppwr", "fvt", "tpcv", "tpvr", "tpver"], "def": ["eval", "dist", "val", "feed", "diff", "pkg", "part", "req", "cond", "gen", "conf", "bd", "exec", "valid", "ref", "new", "det", "d", "var", "name", "obj", "id", "__", "definition", "df", "lit", "el", "Def", "data", "parent", "fun", "comp", "ef", "init", "info", "block", "DEF", "dev", "push", "f", "cl", "aux", "pass", "del", "defined", " Def", "desc"], "i": ["ui", "part", "io", "r", "l", "fi", "si", "j", "n", "uri", "y", "o", "p", "ci", "multi", "qi", "ind", "d", "m", "oi", "mi", "ori", "name", "ri", "k", "ini", "ii", "v", "bi", "x", "a", "li", "ie", "iu", "c", "di", "ix", "ai", "info", "init", "abi", "pi", "t", "b", "f", "gi", "u", "ip", "ni", "e", "xi", "I", "it", "yi", "index"], "ret": ["cat", "val", "let", "res", "part", "pat", "back", "match", "att", "rt", "flag", "code", "num", "alt", "RET", "ref", "group", "det", "gt", "rev", "id", "iter", "status", "len", "no", "count", "lit", "x", "success", "rets", "feat", "reply", "mt", "flat", "fun", "nt", "reg", "xt", "result", "arg", "Ret", "f", "ft", "cur", "re", "ct", "bit", "en"]}}
{"project": "qemu", "commit_id": "ef29a70d18c2d551cf4bb74b8aa9638caac3391b", "target": 0, "func": "void helper_tlb_update(uint32_t T0)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n\tuint32_t vaddr;\n\n\tuint32_t srs = env->pregs[PR_SRS];\n\n\n\n\tif (srs != 1 && srs != 2)\n\n\t\treturn;\n\n\n\n\tvaddr = cris_mmu_tlb_latest_update(env, T0);\n\n\tD(printf(\"flush old_vaddr=%x vaddr=%x T0=%x\\n\", vaddr, \n\n\t\t env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));\n\n\ttlb_flush_page(env, vaddr);\n\n#endif\n\n}\n", "idx": 3256, "substitutes": {"T0": ["Targ", " T50", "PT50", "P00", " T2", " TFalse", "Parg", "TFalse", "VT1", " T1", "t00", " Targ", "VTFalse", "t1", "t2", "targ", "PT1", "T50", "T1", " T00", "P0", "PT2", "VT0", "t0", "P1", "T00", "t50", "T2", "PT0", "tFalse"], "vaddr": ["veraddr", "Vadd", " vint", "vaddress", "fhost", "paddr", "faddress", "svwork", "Vhost", " vaddress", "verhost", "paddress", "fptr", "svaddr", "verptr", "svaddress", " vadd", "vint", "fwork", "svint", "vadd", "Vaddr", "vhost", "vwork", " vwork", "Vptr", "svhost", "fint", "faddr", "padd", " vhost", "veraddress", "Vaddress", "vptr"]}}
{"project": "qemu", "commit_id": "99fd437dee468609de8218f0eb3b16621fb6a9c9", "target": 0, "func": "static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)\n\n{\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;\n\n\n\n    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,\n\n     * replace the method name: _EJ0 by ACPI_EJ0_.\n\n     */\n\n    /* Sanity check */\n\n    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, \"_EJ0\", 4));\n\n\n\n    if (!eject) {\n\n        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, \"EJ0_\", 4);\n\n    }\n\n}\n", "idx": 3266, "substitutes": {"slot": ["cat", "serial", "offset", "spot", "val", "socket", "Slot", "loc", "role", "binary", "option", "lot", "sector", "sid", "zo", "pixel", "connection", "pin", "token", "job", "session", "hole", "route", "vol", "len", "no", "slice", "scroll", "ruby", "pos", "type", "service", "secret", "zone", "nt", "shadow", "oid", "seed", "boot", "image", "rot", "arg", "hour", "pointer", "serv", "address", "size", "addr", "timeout", "sl", "shell", "entry", "bit", "tag", "index"], "ssdt_ptr": ["ssdt___ext", "ssdt_ext", "sscot_pointer", "ssrt_ext", "ssrt_ptr", "ssdt_data", "ssdc_addr", "ssrt_dr", "ssdc_handle", "sscit_addr", "ssrt_inter", "ssdt_inter", "ssdt_handle", "ssdt_pointers", "sscot_dr", "ssdt___pointer", "sscit_dr", "sscot_ptr", "ssdt___ptr", "sscot_struct", "ssdt_struct", "ssdt_addr", "sscot_addr", "sscit_pointer", "ssdt_pointer", "sscit_ptr", "ssrt_data", "ssdc_ptr", "ssrt_pointer", "ssdt_dr", "sscot_pointers", "ssdc_pointer"], "eject": [" erupt", "beject", "ejection", "Erupt", "eJECT", "beJECT", "ecess", "bejection", "EJECT", "becess", "eeJECT", "eeject", "ejected", " ejected", "Eject", "erupt", "eecess", "eerupt", "Ejected", "eejected", "Ejection", "eejection", "Ecess", " ejection"]}}
{"project": "FFmpeg", "commit_id": "03931ecf71710452fc9e89d4f18354f0b5e05395", "target": 0, "func": "static float ssim_plane(uint8_t *main, int main_stride,\n\n                        uint8_t *ref, int ref_stride,\n\n                        int width, int height, void *temp)\n\n{\n\n    int z = 0;\n\n    int x, y;\n\n    float ssim = 0.0;\n\n    int (*sum0)[4] = temp;\n\n    int (*sum1)[4] = sum0 + (width >> 2) + 3;\n\n\n\n    width >>= 2;\n\n    height >>= 2;\n\n\n\n    for (y = 1; y < height; y++) {\n\n        for (; z <= y; z++) {\n\n            FFSWAP(void*, sum0, sum1);\n\n            for (x = 0; x < width; x+=2)\n\n                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,\n\n                                &ref[4 * (x + z * ref_stride)], ref_stride,\n\n                                &sum0[x]);\n\n        }\n\n\n\n        ssim += ssim_endn(sum0, sum1, width - 1);\n\n    }\n\n\n\n    return ssim / ((height - 1) * (width - 1));\n\n}\n", "idx": 3274, "substitutes": {"main_stride": ["main_brice", "main_shrides", "main_dride", "main_strides", "main_stided", "main_bride", "main_drice", "main_stides", "main_strine", "main_drided", "main_trided", "main_shrided", "main_strided", "main_brine", "main_trride", "main_tride", "main_stade", "main_trade", "main_drides", "main_strride", "main_striides", "main_brides", "main_shrice", "main_strice", "main_brride", "main_stine", "main_shride", "main_brided", "main_brade", "main_stide", "main_strade", "main_striided", "main_striine", "main_striide"], "ref": ["bf", "cache", "diff", "part", "base", "REF", "def", "review", "conf", "arc", "alt", "aff", "reference", "ab", "remote", "config", "min", "rf", "source", "red", "pos", "rib", "parent", "url", "pre", "ef", "ob", "info", "rel", "b", "Ref", "f", "lab", "range", "re", "lf", "fe"], "ref_stride": ["ref_collite", "ref_Strider", "ref_strade", "ref_brider", "ref_striine", "ref_strided", "ref_arrade", "ref_brite", "ref_brade", "ref_arrider", "ref_divider", "ref_brided", "ref_collade", "ref_strider", "ref_brides", "ref_strite", "ref_divided", "ref_Stride", "ref_collide", "ref_brine", "ref_divides", "ref_strine", "ref_bride", "ref_Strides", "ref_arride", "ref_striider", "ref_striide", "ref_arrite", "ref_striided", "ref_strides", "ref_Strided", "ref_collided", "ref_arrine", "ref_divide", "ref_arrided"], "height": ["hi", "arrow", "padding", "img", "density", "bottom", "zh", "deep", "crop", "d", "rows", "lat", "alpha", "radius", "id", "w", "resolution", "time", "dy", "inches", "dim", "above", "build", "distance", "window", "row", "length", "top", "shape", "direction", "rank", "weight", "flow", "depth", "center", "image", "style", "level", "gap", "ty", "Height", "size", "hold", "pull", "thin", "h"], "temp": ["wa", "cache", "i", "vt", "tw", "form", "pt", "tmp", "p", "term", "m", "white", "buffer", "tem", "w", "fake", "tc", "v", "prefix", "wrap", "Temp", "txt", "flat", "parent", "emp", "c", "current", "flow", "cut", "local", "t", "max", "size", "cel", "source", "clean"], "x": ["wy", "xxx", "wa", "wx", "i", "im", "r", "X", "ww", "l", "ex", "j", "n", "xx", "rx", "p", "my", "ct", "d", "m", "yx", "cross", "any", "lex", "id", "xc", "w", "time", "k", "xp", "px", "v", "a", "pos", "el", "xy", "c", "ix", "xa", "sex", "tx", "fx", "dx", "t", "max", "b", "f", "u", "ax", "ady", "e", "one", "xi", "h", "index"], "y": ["wy", "i", "ny", "cy", "yl", "l", "ey", "j", "n", "o", "p", "yr", "yn", "sy", "ya", "d", "m", "vy", "id", "yi", "w", "Y", "s", "dy", "v", "oy", "py", "a", "zy", "type", "ye", "g", "ym", "xy", "yt", "c", "ay", "ch", "yo", "t", "b", "f", "u", "e", "size", "ty", "h", "yy"], "sum0": ["sum3", " sum2", "um3", "mem4", "Sum4", "sum2", "mem1", "Sum0", "sum4", " sum3", "um4", "Sum2", "mem0", "Sum1", "mem2", "um0", "um1", "dim0", " sum4", "dim1", "Sum3", "dim2"], "sum1": [" sum8", " sum9", " sum2", "ram8", "sum8", "ram0", "ram1", "sum2", " sumOne", "Sum0", "sum9", "Sum2", "gramOne", "sumOne", "Sum8", "Sum1", "um0", "gram1", "um1", "umOne", "Sum9", "ram2", "SumOne", "gram9", "gram2", "um2"], "z": ["oz", "wa", "zip", "i", " w", "r", "Z", "l", "code", "j", "n", "xx", "zo", "p", "zz", "fl", "zh", "ya", "d", "m", "tz", "vy", "id", "w", "s", "Y", "dy", "ii", "v", "yz", "zy", "g", "ez", "ze", "xy", "c", "zi", "ix", "t", "f", "u", "q", "e", "iz", "yi", "zone", "h"]}}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_instance_init(Object *obj)\n\n{\n\n    object_property_add(obj, \"bootindex\", \"int32\",\n\n                        nvme_get_bootindex,\n\n                        nvme_set_bootindex, NULL, NULL, NULL);\n\n    object_property_set_int(obj, -1, \"bootindex\", NULL);\n\n}\n", "idx": 3278, "substitutes": {"obj": ["xxx", "val", "cod", "rb", "od", "inst", "po", "object", "orb", "j", "n", "ctx", "elt", "o", "code", "lib", "bo", "src", "act", "node", "java", "oi", "api", "class", "nb", "el", "coll", "txt", "parent", "cn", "sb", "self", "ob", "bh", "init", "boot", "cb", "eff", "Obj", "args", "oa", "os", "objects", "js", "instance", "emb", "Object", "art"]}}
{"project": "qemu", "commit_id": "7e39d3a2dd34a84900e10b4ea1567f3b352659af", "target": 1, "func": "static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,\n\n                          Error **errp)\n\n{\n\n    BDRVBlkverifyState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n\n\n\n    /* Open the raw file */\n\n    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-raw\"), options, \"raw\",\n\n                               bs, &child_file, false, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    /* Open the test file */\n\n    s->test_file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options,\n\n                                   \"test\", bs, &child_format, false,\n\n                                   &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    ret = 0;\n\nfail:\n\n\n\n\n    qemu_opts_del(opts);\n\n    return ret;\n", "idx": 3279, "substitutes": {"bs": ["cas", "rb", "fs", "base", "BS", "ts", "ns", "plugins", "cs", "pb", "bb", "ctx", "ssl", "qs", "bits", "bps", "als", "ib", "ins", "blocks", "sa", "bos", "fb", "lb", "bi", "css", "ps", "us", "ses", "ks", "iss", "rs", "sb", "es", "obs", "gb", "ob", "gs", "cb", "vs", "db", "b", "os", "as", "aws", "bas", "ss", "js", "ls", "bl", "bc", "ops", "ds", "bis", "bu"], "options": ["times", "offs", "fs", "base", "io", "ts", "settings", "object", "option", "public", "optional", "null", "o", "lib", "values", "opt", "p", "ips", "includes", "other", "false", "config", "details", "ions", "obj", "errors", "opens", "bos", "file", "Options", "data", "ps", "lines", "steps", "es", "scope", "outs", "info", "files", "eps", "args", "global", "style", "os", "none", "op", "e", "ls", "x", "ops", "params"], "flags": ["mask", "offset", "FLAG", "fs", "lag", "comments", "settings", "flag", "bits", "ips", "ints", " bits", "config", " flag", "errors", "ops", "stats", "file", "vals", "files", "args", "features", "parts", "Flags", "bytes", "bit", " Flags"], "errp": ["errorf", "errr", "errpre", " errf", "arrn", "errorpre", "cerpi", "rorpi", " errtp", "errorb", "errb", "ierpa", "rrpre", "errpc", " errpre", "errtp", "errortp", " errpi", "ierpi", "cerpa", "errorr", " errpc", "cern", "rrf", "errpi", "rorpa", "errorpc", "rorf", "errn", "arrp", "arrpi", "errf", "rorr", "ierf", "ierp", "cerp", "rorpc", " errr", " errpa", "errpa", "errorp", "rortp", "rrp", "arrpa", "rrb", " errn", " errb", "rorp"], "s": ["S", "base", "sv", "su", "ts", "ns", "cs", "is", "si", "n", "ssl", "p", "session", "sa", "v", "sys", "states", "https", "ps", "ses", "c", "sb", "self", "gs", "state", "vs", "t", "b", "os", "f", "utils", "ss", "js", "sl", "ls", "ops", "ds"], "opts": ["opns", "copcs", "experts", " optts", "opt", "obts", "copts", "alts", "obt", "copps", "opouts", "optes", " optes", "optters", " opg", " optg", " opps", "otts", "operts", "opments", "experta", "alments", "catts", "obcs", "optls", "opta", "alps", "opg", " opments", "olt", " opttes", "OPty", "optte", "opls", "optg", "operty", "opty", " optns", "optps", "olpt", " opcs", "obls", "optt", "operpt", "alte", "opps", " opte", "olts", "OPpt", "operps", "OPts", "opcs", "optns", "catters", "copters", "experouts", "opte", " opt", "catps", "optcs", "optts", "operta", " opls", "OPt", "otps", "operouts", "experps", "otouts", "catcs", "opters", "opttes", "optments", "otta", "oppt", "olty", " opns", "opert"], "local_err": [" local_bug", "localpyerror", "localederr", " local_cb", " local_orr", " local_war", "global_status", "local_cb", "local67worker", "global_er", "local___err", "local___error", "localederror", "localpybug", "remote_err", "custom_gr", "local__error", "local_init", "local___nor", " local_error", "local_er", "localpystatus", "custom_err", "localedbug", "localpynor", "global_err", "remote_worker", "local_bug", "local_war", "local8init", "local_worker", "localpyerr", "local_nor", "remote_error", "local___bug", "local__cry", "local67erer", "local67err", "local8err", "local_gr", "local8er", "local_cry", "local_spec", "custom_error", " local_erer", "local_msg", "local64orr", "local67er", " local_nor", "global_init", " local_cry", "remote_er", "local_error", "localpyinit", " local_spec", "local_orr", "local__erer", " local_msg", "local64error", "local67cry", "local67error", "local_erer", "local_status", "local64cb", "custom_er", "localpyer", " local_er", "local64err", "local__err", "local8status", "localedwar"], "ret": ["rep", "cat", "bf", "val", "let", "res", "part", "bad", "pat", "back", " RET", "req", "base", "match", "def", "pet", "rc", "rt", "flag", " Ret", "lt", "alt", "opt", "valid", "wait", "RET", "ref", "det", "fit", "gt", "rev", "id", "et", "len", "bot", "run", "lit", "ut", "success", "ext", "rets", "feat", "str", "data", "reply", "mt", "flat", "fun", "nt", "reg", "result", "get", "rot", "arg", "Ret", "ber", "t", "ft", "sat", "re", "final", "pass", "bit", "art"]}}
{"project": "qemu", "commit_id": "f2488736371ae902f345cf9270d141f0a6797731", "target": 1, "func": "static void tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi,\n\n                             int s_bits, int tlb_offset)\n\n{\n\n    TCGReg base = TCG_AREG0;\n\n\n\n    /* Should generate something like the following:\n\n     * pre-v7:\n\n     *   shr    tmp, addr_reg, #TARGET_PAGE_BITS                  (1)\n\n     *   add    r2, env, #off & 0xff00\n\n     *   and    r0, tmp, #(CPU_TLB_SIZE - 1)                      (2)\n\n     *   add    r2, r2, r0, lsl #CPU_TLB_ENTRY_BITS               (3)\n\n     *   ldr    r0, [r2, #off & 0xff]!                            (4)\n\n     *   tst    addr_reg, #s_mask\n\n     *   cmpeq  r0, tmp, lsl #TARGET_PAGE_BITS                    (5)\n\n     *\n\n     * v7 (not implemented yet):\n\n     *   ubfx   r2, addr_reg, #TARGET_PAGE_BITS, #CPU_TLB_BITS    (1)\n\n     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask\n\n     *   movw   r0, #off\n\n     *   add    r2, env, r2, lsl #CPU_TLB_ENTRY_BITS              (2)\n\n     *   bic    tmp, addr_reg, tmp\n\n     *   ldr    r0, [r2, r0]!                                     (3)\n\n     *   cmp    r0, tmp                                           (4)\n\n     */\n\n#  if CPU_TLB_BITS > 8\n\n#   error\n\n#  endif\n\n    tcg_out_dat_reg(s, COND_AL, ARITH_MOV, TCG_REG_TMP,\n\n                    0, addrlo, SHIFT_IMM_LSR(TARGET_PAGE_BITS));\n\n\n\n    /* We assume that the offset is contained within 16 bits.  */\n\n    assert((tlb_offset & ~0xffff) == 0);\n\n    if (tlb_offset > 0xff) {\n\n        tcg_out_dat_imm(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n\n                        (24 << 7) | (tlb_offset >> 8));\n\n        tlb_offset &= 0xff;\n\n        base = TCG_REG_R2;\n\n    }\n\n\n\n    tcg_out_dat_imm(s, COND_AL, ARITH_AND,\n\n                    TCG_REG_R0, TCG_REG_TMP, CPU_TLB_SIZE - 1);\n\n    tcg_out_dat_reg(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n\n                    TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS));\n\n\n\n    /* Load the tlb comparator.  Use ldrd if needed and available,\n\n       but due to how the pointer needs setting up, ldm isn't useful.\n\n       Base arm5 doesn't have ldrd, but armv5te does.  */\n\n    if (use_armv6_instructions && TARGET_LONG_BITS == 64) {\n\n        tcg_out_memop_8(s, COND_AL, INSN_LDRD_IMM, TCG_REG_R0,\n\n                        TCG_REG_R2, tlb_offset, 1, 1);\n\n    } else {\n\n        tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R0,\n\n                         TCG_REG_R2, tlb_offset, 1, 1);\n\n        if (TARGET_LONG_BITS == 64) {\n\n            tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R1,\n\n                             TCG_REG_R2, 4, 1, 0);\n\n        }\n\n    }\n\n\n\n    /* Check alignment.  */\n\n    if (s_bits) {\n\n        tcg_out_dat_imm(s, COND_AL, ARITH_TST,\n\n                        0, addrlo, (1 << s_bits) - 1);\n\n    }\n\n\n\n    tcg_out_dat_reg(s, (s_bits ? COND_EQ : COND_AL), ARITH_CMP, 0,\n\n                    TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS));\n\n\n\n    if (TARGET_LONG_BITS == 64) {\n\n        tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0,\n\n                        TCG_REG_R1, addrhi, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n", "idx": 3288, "substitutes": {"s": ["S", "support", "fs", "sv", "sets", "setup", "ns", "settings", "private", "context", "si", "cs", "is", "ssl", "south", "p", "complex", "groups", "input", "m", "sq", "session", "se", "stat", "services", "a", "sys", "service", "g", "server", "ses", "sf", "spec", "c", "sb", "secondary", "site", "self", "scope", "current", "rs", "gs", "sym", "t", "b", "f", "sg", "client", "u", "native", "this", "set", "ss", "js", "e", "http", "ds", "sync", "request"], "addrlo": ["addressLo", "addresshi", " addrHi", "drla", "addrLo", " addrLo", "AddressLo", "addressHi", "amdLo", "Addresslo", "Addresshi", "addresslittle", "amdlittle", "amdla", "addressla", "drlo", "addrHi", "drlittle", "addrla", "addrlittle", "addresslo", "AddressHi", "amdlo", "drLo"], "addrhi": [" addrha", "addHi", "addrha", "addrHi", " addrHi", "addha", " addrpi", "Addresshi", "addrpi", "addhi", "addpi", "AddressHi", "Addresspi", "Addressha"], "s_bits": ["s2flags", "s2pins", "s2parts", "s_pins", "ps_parts", "ps_bits", "s_flags", "s2bits", "ps_pins", "s_parts", "ps_flags"], "tlb_offset": ["tlb_location", "tlc_offset", "tlc_size", "tl_off", "tlb_attribute", "tlp_line", "tlb8size", "tlp_Offset", "tbl2size", "tlb_line", "tlb__Offset", "tlb__len", "tlc_len", "tlb2off", "tl_offset", "tbl_addr", "tlb_base", "tlb__size", "tla_no", "tlb_off", "tbl_off", "tla_off", "tlb__addr", "tbl_size", "tlb2size", "tbl2addr", "tlc_Offset", "tlb_size", "tlb_addr", "tlb8off", "tbl2off", "tla_Offset", "tlb__off", "tlb_Offset", "tlb2addr", "tl_size", "tlb_no", "tlp_position", "tlb__offset", "tlp_offset", "tl_base", "tlp_size", "tlb_sum", "tlp_sum", "tlp_attribute", "tlp_location", "tla_offset", "tlb8offset", "tbl2offset", "tlb2offset", "tlb8base", "tlb_position", "tlb_len", "tbl_offset"]}}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "static void qdm2_decode_super_block(QDM2Context *q)\n\n{\n\n    GetBitContext gb;\n\n    QDM2SubPacket header, *packet;\n\n    int i, packet_bytes, sub_packet_size, sub_packets_D;\n\n    unsigned int next_index = 0;\n\n\n\n    memset(q->tone_level_idx_hi1, 0, sizeof(q->tone_level_idx_hi1));\n\n    memset(q->tone_level_idx_mid, 0, sizeof(q->tone_level_idx_mid));\n\n    memset(q->tone_level_idx_hi2, 0, sizeof(q->tone_level_idx_hi2));\n\n\n\n    q->sub_packets_B = 0;\n\n    sub_packets_D    = 0;\n\n\n\n    average_quantized_coeffs(q); // average elements in quantized_coeffs[max_ch][10][8]\n\n\n\n    init_get_bits(&gb, q->compressed_data, q->compressed_size * 8);\n\n    qdm2_decode_sub_packet_header(&gb, &header);\n\n\n\n    if (header.type < 2 || header.type >= 8) {\n\n        q->has_errors = 1;\n\n        av_log(NULL, AV_LOG_ERROR, \"bad superblock type\\n\");\n\n        return;\n\n    }\n\n\n\n    q->superblocktype_2_3 = (header.type == 2 || header.type == 3);\n\n    packet_bytes          = (q->compressed_size - get_bits_count(&gb) / 8);\n\n\n\n    init_get_bits(&gb, header.data, header.size * 8);\n\n\n\n    if (header.type == 2 || header.type == 4 || header.type == 5) {\n\n        int csum = 257 * get_bits(&gb, 8);\n\n        csum += 2 * get_bits(&gb, 8);\n\n\n\n        csum = qdm2_packet_checksum(q->compressed_data, q->checksum_size, csum);\n\n\n\n        if (csum != 0) {\n\n            q->has_errors = 1;\n\n            av_log(NULL, AV_LOG_ERROR, \"bad packet checksum\\n\");\n\n            return;\n\n        }\n\n    }\n\n\n\n    q->sub_packet_list_B[0].packet = NULL;\n\n    q->sub_packet_list_D[0].packet = NULL;\n\n\n\n    for (i = 0; i < 6; i++)\n\n        if (--q->fft_level_exp[i] < 0)\n\n            q->fft_level_exp[i] = 0;\n\n\n\n    for (i = 0; packet_bytes > 0; i++) {\n\n        int j;\n\n\n\n        if (i >= FF_ARRAY_ELEMS(q->sub_packet_list_A)) {\n\n            SAMPLES_NEEDED_2(\"too many packet bytes\");\n\n            return;\n\n        }\n\n\n\n        q->sub_packet_list_A[i].next = NULL;\n\n\n\n        if (i > 0) {\n\n            q->sub_packet_list_A[i - 1].next = &q->sub_packet_list_A[i];\n\n\n\n            /* seek to next block */\n\n            init_get_bits(&gb, header.data, header.size * 8);\n\n            skip_bits(&gb, next_index * 8);\n\n\n\n            if (next_index >= header.size)\n\n                break;\n\n        }\n\n\n\n        /* decode subpacket */\n\n        packet = &q->sub_packets[i];\n\n        qdm2_decode_sub_packet_header(&gb, packet);\n\n        next_index      = packet->size + get_bits_count(&gb) / 8;\n\n        sub_packet_size = ((packet->size > 0xff) ? 1 : 0) + packet->size + 2;\n\n\n\n        if (packet->type == 0)\n\n            break;\n\n\n\n        if (sub_packet_size > packet_bytes) {\n\n            if (packet->type != 10 && packet->type != 11 && packet->type != 12)\n\n                break;\n\n            packet->size += packet_bytes - sub_packet_size;\n\n        }\n\n\n\n        packet_bytes -= sub_packet_size;\n\n\n\n        /* add subpacket to 'all subpackets' list */\n\n        q->sub_packet_list_A[i].packet = packet;\n\n\n\n        /* add subpacket to related list */\n\n        if (packet->type == 8) {\n\n            SAMPLES_NEEDED_2(\"packet type 8\");\n\n            return;\n\n        } else if (packet->type >= 9 && packet->type <= 12) {\n\n            /* packets for MPEG Audio like Synthesis Filter */\n\n            QDM2_LIST_ADD(q->sub_packet_list_D, sub_packets_D, packet);\n\n        } else if (packet->type == 13) {\n\n            for (j = 0; j < 6; j++)\n\n                q->fft_level_exp[j] = get_bits(&gb, 6);\n\n        } else if (packet->type == 14) {\n\n            for (j = 0; j < 6; j++)\n\n                q->fft_level_exp[j] = qdm2_get_vlc(&gb, &fft_level_exp_vlc, 0, 2);\n\n        } else if (packet->type == 15) {\n\n            SAMPLES_NEEDED_2(\"packet type 15\")\n\n            return;\n\n        } else if (packet->type >= 16 && packet->type < 48 &&\n\n                   !fft_subpackets[packet->type - 16]) {\n\n            /* packets for FFT */\n\n            QDM2_LIST_ADD(q->sub_packet_list_B, q->sub_packets_B, packet);\n\n        }\n\n    } // Packet bytes loop\n\n\n\n    if (q->sub_packet_list_D[0].packet != NULL) {\n\n        process_synthesis_subpackets(q, q->sub_packet_list_D);\n\n        q->do_synth_filter = 1;\n\n    } else if (q->do_synth_filter) {\n\n        process_subpacket_10(q, NULL);\n\n        process_subpacket_11(q, NULL);\n\n        process_subpacket_12(q, NULL);\n\n    }\n\n}\n", "idx": 3290, "substitutes": {"q": ["comment", "update", "view", "cache", "req", "r", "sync", "form", "rc", "context", "conf", "er", "sh", "qs", "core", "pg", "p", "o", "ue", "http", "qu", "requ", "qq", "qi", "query", "input", "config", "sq", "queue", "z", "check", "qa", "k", "quant", "v", "event", "question", "co", "iq", "c", "self", "dq", "info", "ch", "get", "quest", "ck", "t", "que", "cl", "client", "f", "cur", "u", "this", "component", "e", "Q", "qt", "quad", "ce", "request"], "gb": ["kb", " storage", "rb", "git", " rgb", " rg", "gh", "lib", " db", "cgi", " encoding", "sb", "rg", "gy", "cb", "yg", "bc", "ki", "gu", "gru", "ui", "vt", "ci", "bg", "gal", "gp", "vm", "gnu", "gpu", "gin", "hub", "gm", "gram", "gg", "gd", " dc", "sg", " rc", " factory", " bin", " algorithm", "ctx", "GB", " ble", " gcc", "gow", " backend", "tg", "gn", "mb", "nb", "pc", "gz", "g", "usb", " kb", "gs", "bm", " eg", "bb", "gc", "byte", "cli", "bridge", "ga", "gio", "bn", " cc", "G", " gp", "hd", "db", "bin", "gi", "storage", "gam", "cfg"], "header": ["rr", "buff", "match", "prot", "gh", "reader", "kernel", "key", "head", "cgi", "parent", "output", "counter", "layer", "plugin", "info", "block", "channel", "que", "f", "inc", "component", "headers", "bc", "message", "vv", "author", "error", "Header", "option", "outer", "config", "buffer", "gp", "record", "cover", "event", "data", "gin", "callback", "gm", "parser", "init", "center", "response", "h", "rule", "line", "offset", "context", "code", "core", "document", "query", "dr", "m", "queue", "definition", "stream", "writer", "border", "server", "item", "prev", "general", "player", "size", "bm", "request", "index", "source", "cache", "back", "n", "fp", "byte", "module", "input", "bridge", "metadata", "bn", "handler", "master", "class", "type", "forward", "hr", "body", "du", "ck", "carry", "version", "inner", "client", "hw", "content"], "packet": ["ppacket", "packets", "packoder", "packsets", "compacket", "compet", "quantacket", "compET", "ppets", "duets", "quantoder", "duET", "duet", "compoder", "packsET", "ppoder", "ppet", "compets", "packsacket", "duacket", "quantet", "packET", "quantets", "packacket", "packset"], "i": ["offset", "ui", "io", "base", "binary", "code", "n", "p", "ci", "uni", "d", "id", "buffer", "len", "ii", "slice", "c", "in", "di", "layer", "info", "abi", "pi", "bin", "ti", "ip", "I"], "packet_bytes": ["packets_bytes", "packet__size", "packet__bits", "packet___bytes", "packet_data", "packets_bits", "packet_size", "packets_gets", "packet___bits", "packet__bytes", "packet___size", "packet__data", "packet_gets", "packets_data", "packet_bits", "packet___gets", "packets_size"], "sub_packet_size": ["sub_packets_bytes", "sub_packet___len", "sub_packets_position", "sub_packet_position", "sub_packet___bytes", "sub_packets_size", "sub_packet_len", "sub_packet___size", "sub_packets_len", "sub_packet___position", "sub_packet_bytes"], "sub_packets_D": ["sub_packetsPunit", "sub_packet_unit", "sub_packets_bytes", "sub_packetsPbytes", "sub_packetsAllD", "sub_packetsPD", "sub_packetsAlld", "sub_packet_D", "sub_packet_d", "sub_packets_DS", "sub_packets_B", "sub_packetsAllbytes", "sub_packet_B", "sub_packetsAllunit", "sub_packetsPd", "sub_packets_unit", "sub_packet_DS", "sub_packet_bytes", "sub_packets_d"]}}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,\n\n                          const int16_t *filter, const int16_t *filterPos,\n\n                          int filterSize)\n\n{\n\n    int i;\n\n    for (i=0; i<dstW; i++) {\n\n        int j;\n\n        int srcPos= filterPos[i];\n\n        int val=0;\n\n        for (j=0; j<filterSize; j++) {\n\n            val += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n        }\n\n        //filter += hFilterSize;\n\n        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...\n\n        //dst[i] = val>>7;\n\n    }\n\n}\n", "idx": 3293, "substitutes": {"c": ["cu", "dc", "cit", "r", "cy", "ac", "l", "context", "icc", "o", "vc", "p", "ci", "d", "m", "w", "a", "pc", "t", "b", "f", "u", "C", "e", "cm", "h", "lc", "s"], "dst": ["dft", "dbsts", "Dsrc", "dbST", "Dsts", "odst", "odft", " dft", " ddest", "odsts", "dsts", " dST", "Ddest", "dbst", " dsrc", "dbdest", "Dft", "dsrc", "ddest", "odsrc", "dST", "Dst", "DST", " dsts"], "dstW": ["dstreamWidth", "ddrC", "dscw", "dstsWh", "dSTC", " dstH", "ddrW", "DSTw", "dstWidth", "dSTWeight", "dscW", "DstW", "dstreamW", "dstWeight", " dstsW", "drcWh", "dstC", "dstsH", "dstH", " dstWidth", "dstreamWh", "dstWh", "dSTW", "DSTC", "DstWeight", " dstWh", "DSTWeight", "dstsWidth", " dstsWh", "DSTW", " dstsH", "dSTw", "dstsW", "drcH", "dscWeight", "ddrWeight", "DstC", "Dstw", "dstreamH", "drcW", "drcWidth", "dstw", "dscC", " dstsWidth", "ddrw"], "src": ["fn", "dist", "support", "inf", "rb", "transform", "loc", "inst", "sc", "sort", "secure", "rc", "sub", "fc", "img", "conv", "ssl", "super", "control", "ref", "config", "sq", "acc", "slice", "asc", "dest", "gz", "data", "sb", "url", "target", "start", "cb", "sl", "sync", "source"], "filter": ["user", "fn", "mask", "offset", "cache", "support", "sort", "match", "sub", "replace", "rc", "flag", "header", "control", "ref", "config", "force", "limit", "buffer", "per", "fil", "alpha", "route", "slice", "v", "file", "search", "il", "forward", "url", "test", "map", "target", "layer", "block", "channel", "feature", "f", "range", "Filter", "use", "source"], "filterPos": ["FilterType", "filterLen", "filterPosition", "filPos", " filterPosition", "filLen", "filterPoint", " filterLen", "FilterLen", "filPoint", "filType", " filterType", "filPosition", "FilterPos", "filterType", "FilterPosition", " filterPoint", "filSize", "FilterPoint", "FilterSize"], "filterSize": ["filterLen", "filterZone", " filterName", "limitZone", "filterCount", "filPos", "sortScale", "shapePos", "sortLen", "filLen", "shapeLen", "sortName", " filterScale", " filterLen", "filCount", "filName", "limitSize", "filterName", "filScale", "limitPos", " filterZone", "limitCount", "filterScale", "sortPos", "sortSize", "filZone", " filterCount", "filSize", "shapeSize"], "i": ["val", "ui", "io", "l", "fi", "si", "is", "n", "uri", "o", "y", "p", "ci", "key", "qi", "eni", "d", "oi", "cli", "id", "ori", "I", "mi", "z", "ri", "k", "ini", "ii", "slice", "sci", "esi", "v", "bi", "a", "li", "ami", "ie", "iu", "ji", "zi", "di", "ix", "ai", "init", "info", "start", "pi", "gi", "f", "u", "b", "ti", "ei", "ip", "ni", "e", "xi", "x", "it", "ki", "h", "index"], "j": ["fr", "val", "jc", "ui", "jo", "req", "pr", "r", "l", "n", "jl", "y", "o", "p", "pt", "key", "oj", "qi", "m", "aj", "obj", "z", "adj", "ja", "k", "ij", "ii", "v", "uj", "bi", "el", "li", "jj", "g", "ie", "ji", "jp", "ch", "t", "b", "f", "u", "jit", "js", "e", "x", "it", "J"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "MigrationState *migrate_get_current(void)\n\n{\n\n    static MigrationState current_migration = {\n\n        .state = MIG_STATE_NONE,\n\n        .bandwidth_limit = MAX_THROTTLE,\n\n        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,\n\n        .mbps = -1,\n\n    };\n\n\n\n    return &current_migration;\n\n}\n", "idx": 3320, "substitutes": {}}
{"project": "qemu", "commit_id": "25e5e4c7e9d5ec3e95c9526d1abaca40ada50ab0", "target": 1, "func": "qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,\n\n                    size_t offset, size_t bytes, bool do_send)\n\n{\n\n    size_t done = 0;\n\n    ssize_t ret;\n\n    while (done < bytes) {\n\n        ret = iov_send_recv(sockfd, iov,\n\n                            offset + done, bytes - done, do_send);\n\n        if (ret > 0) {\n\n            done += ret;\n\n        } else if (ret < 0) {\n\n            if (errno == EAGAIN) {\n\n                qemu_coroutine_yield();\n\n            } else if (done == 0) {\n\n                return -1;\n\n            } else {\n\n                break;\n\n            }\n\n        } else if (ret == 0 && !do_send) {\n\n            /* write (send) should never return 0.\n\n             * read (recv) returns 0 for end-of-file (-data).\n\n             * In both cases there's little point retrying,\n\n             * but we do for write anyway, just in case */\n\n            break;\n\n        }\n\n    }\n\n    return done;\n\n}\n", "idx": 3322, "substitutes": {"sockfd": ["sockedfd", "socksdb", " sockshandle", "csockedfx", "csockedctx", "csockedFD", "csockfd", "csockfx", "sockfx", "sbootdb", "sockshandle", "siphandle", "sbootfx", "sbootfd", "sockhandle", "sipfd", "sockedfx", "csockedfd", "sockedctx", " socksdb", "sboothandle", " socksfd", "sbootctx", " sockhandle", "socksfx", "sipFD", "socksctx", "socksfd", "sockctx", "socksFD", "sockFD", "sockedFD", "csockctx", " sockdb", "sockdb", "sbootFD", "sipdb", " sockFD", "csockFD", " socksFD"], "iov": ["iro", "lov", "voice", "udi", "io", "ir", "oji", "uci", "iii", "imet", "ium", "imi", "anni", "uo", "odi", "uni", "oci", "eni", "oi", "rolet", "icho", "liv", "ov", "gio", "iev", "ovo", "oco", "\u00ef", "inet", "uno", "irc", "obo", "irin", "nih", "ilo", "iris", "iop", "ovi", "oren", "iv", "iol"], "ret": ["order", "cat", "bf", "val", "rb", "fail", "res", "total", "done", "base", "try", "r", "sr", "error", "att", "def", "rc", "die", "back", "rt", "code", "num", "resp", "alt", "fin", "RET", "ref", "mem", "finished", "rev", "rf", "iter", "obj", "hide", "len", "no", "count", "pos", "success", "ext", "rets", " done", "data", "reply", "bit", "orted", "fun", "complete", "nt", "reg", "dt", "url", "info", "result", "get", "cb", "Ret", "db", "f", "err", "failed", "ver", "re", "pass", "desc", "progress", "seq", "found"]}}
{"project": "qemu", "commit_id": "e24e49e6194626e4ec9f1aecce6d6a6847320bce", "target": 1, "func": "static int qcow2_change_backing_file(BlockDriverState *bs,\n\n    const char *backing_file, const char *backing_fmt)\n\n{\n\n    return qcow2_update_ext_header(bs, backing_file, backing_fmt);\n\n}\n", "idx": 3327, "substitutes": {"bs": ["banks", "rb", "fs", "las", "BS", "ns", "ts", "cs", "pb", "fps", "bb", "bes", "qs", "ubs", "bps", "ras", "blocks", "lbs", "fb", "bos", "ba", "css", "ps", "ks", "ses", "iss", "rs", "sb", "gb", "gs", "vs", "b", "bas", "ss", "ls", "bis", "bc", "lb", "ds"], "backing_file": ["backingingclass", "backing__files", "backding_files", "backing_class", "backing_format", "backing_dir", "backding_format", "backding_file", "backing__dir", "backingingfile", "backding_dir", "backacking_file", "backing_files", "backacking_files", "backacking_class", "backing__format", "backingingfiles", "backing__file"], "backing_fmt": ["backing_cma", "backing_formt", "backing_formb", "backing_fma", "backing_forformat", "backing_dmb", "backing_dformat", "backing_formct", "backing_fMT", "backing_facMT", "backing_facmt", "backing_fct", "backing_cformat", "backingingfmt", "backing_facct", "backing_dmt", "backingingdformat", "backing_formformat", "backing_cmb", "backing_formMT", "backingingfmb", "backing_dma", "backing_fmb", "backing_facformat", "backing_cct", "backingingdmt", "backingingfma", "backingingdma", "backingingdmb", "backing_cmt", "backingingfformat", "backing_formmt", "backing_forma", "backing_fformat", "backing_cMT"]}}
{"project": "FFmpeg", "commit_id": "a4f6be86d67ae30d494fbe8a470bc32b715d75a9", "target": 0, "func": "static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {\n\n    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);\n\n    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]]+1;\n\n        tc[1] = tc0_table[index_a][bS[1]]+1;\n\n        tc[2] = tc0_table[index_a][bS[2]]+1;\n\n        tc[3] = tc0_table[index_a][bS[3]]+1;\n\n        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 3330, "substitutes": {"pix": ["spik", "ipixel", "picon", "pixels", "npixel", " pio", "cpixel", "Pixels", "spix", "pixel", " pixels", "ipicon", " pik", "pox", " pox", "npox", "cpik", "cpicon", "Pix", "npix", "Pox", "cpio", "spixels", "cpix", "spio", "npixels", "pik", "Pixel", "ipix", " pixel", "pio", "fix", "cpixels", "ipixels", "fixel", "ficon", "fixels"], "stride": ["etrine", "stringide", "etrided", "brine", " strided", "switchider", "etrider", "tride", " strider", "etride", "stringided", "strive", " strive", "stringider", "trided", "strided", "stringive", "tripe", "bride", "trider", "switchided", " strine", "stripe", "strine", "strider", "brided", "switchipe", "switchide", "trive", " stripe", "brider"], "bS": ["aC", "bP", "pS", "fOs", "nbD", "pC", " bN", "aSS", " bPs", "nbP", "mbP", "cP", "bOs", "fS", "nbS", "cS", "pSC", "aS", "bC", "fSS", "bSeries", "bN", "pSeries", " bC", "bSC", " bSS", " bP", "pPs", "pOs", " bOs", " bSeries", " bSC", "aN", " bD", "bD", "aP", "pSS", "cN", "mbD", "nbPs", "mbPs", "cSS", "fN", "fC", "bPs", "mbS", "bSS"], "qp": ["qup", "Qlp", "qnp", "qe", " sqlp", "qunp", "sqe", " qnp", "Qe", "qc", "quc", " qc", " qlp", " qP", "ippr", "Qpr", "sqc", "sqnp", "qP", " sqP", " sqp", "QP", "Qp", "ipe", "Qc", "sqpr", " qb", "qlp", "sqp", "sqb", "ipp", "qpr", "qub", "qb", "ipc"], "h": ["hm", "hi", "host", "home", "rh", "r", "l", "hs", "context", "hh", "ctx", "n", "gh", "sh", "hash", "p", "ht", "ha", "m", "api", "w", "hl", "kh", "hu", "oh", "v", "H", "ul", "uh", "hhh", "conn", "ah", "g", "c", "eh", "he", "hr", "ph", "bh", "ch", "ih", "hd", "t", "history", "b", "f", "q", "u", "hp", "e", "FH", "x", "http", "hw", "s"], "tc": ["tm", "cu", "cache", "dc", "cc", "ui", "cases", "loc", "sc", "cf", "ac", "fc", "rc", "ta", "cs", "ctx", "tim", "tt", "icc", "pb", "TC", "uca", "bb", "ci", "tmp", "kk", "ic", "ec", "ff", "xc", "tf", "config", "term", "acc", "fb", "tl", "unc", "asc", "beta", "contract", " TC", "pc", "ca", "css", "tu", "c", "ctrl", "ticket", "gb", "mc", "ace", "toc", "oc", "tx", "cb", "t", " rc", "bc", "cm", "cas", "uc", "lc", "index", "cus"]}}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void sun4d_hw_init(const struct sun4d_hwdef *hwdef, ram_addr_t RAM_size,\n\n                          const char *boot_device,\n\n                          DisplayState *ds, const char *kernel_filename,\n\n                          const char *kernel_cmdline,\n\n                          const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env, *envs[MAX_CPUS];\n\n    unsigned int i;\n\n    void *iounits[MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi;\n\n    qemu_irq *cpu_irqs[MAX_CPUS], *sbi_irq, *sbi_cpu_irq,\n\n        *espdma_irq, *ledma_irq;\n\n    qemu_irq *esp_reset, *le_reset;\n\n    ram_addr_t ram_offset, prom_offset, tcx_offset;\n\n    unsigned long kernel_size;\n\n    int ret;\n\n    char buf[1024];\n\n    int drive_index;\n\n    void *fw_cfg;\n\n\n\n    /* init CPUs */\n\n    if (!cpu_model)\n\n        cpu_model = hwdef->default_cpu_model;\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        cpu_sparc_set_id(env, i);\n\n        envs[i] = env;\n\n        if (i == 0) {\n\n            qemu_register_reset(main_cpu_reset, env);\n\n        } else {\n\n            qemu_register_reset(secondary_cpu_reset, env);\n\n            env->halted = 1;\n\n        }\n\n        cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS);\n\n        env->prom_addr = hwdef->slavio_base;\n\n    }\n\n\n\n    for (i = smp_cpus; i < MAX_CPUS; i++)\n\n        cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);\n\n\n\n    /* allocate RAM */\n\n    if ((uint64_t)RAM_size > hwdef->max_mem) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d, maximum %d\\n\",\n\n                (unsigned int)(RAM_size / (1024 * 1024)),\n\n                (unsigned int)(hwdef->max_mem / (1024 * 1024)));\n\n        exit(1);\n\n    }\n\n    ram_offset = qemu_ram_alloc(RAM_size);\n\n    cpu_register_physical_memory(0, RAM_size, ram_offset);\n\n\n\n    /* load boot prom */\n\n    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);\n\n    cpu_register_physical_memory(hwdef->slavio_base,\n\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &\n\n                                 TARGET_PAGE_MASK,\n\n                                 prom_offset | IO_MEM_ROM);\n\n\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    ret = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL);\n\n    if (ret < 0 || ret > PROM_SIZE_MAX)\n\n        ret = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX);\n\n    if (ret < 0 || ret > PROM_SIZE_MAX) {\n\n        fprintf(stderr, \"qemu: could not load prom '%s'\\n\",\n\n                buf);\n\n        exit(1);\n\n    }\n\n\n\n    /* set up devices */\n\n    sbi = sbi_init(hwdef->sbi_base, &sbi_irq, &sbi_cpu_irq, cpu_irqs);\n\n\n\n    for (i = 0; i < MAX_IOUNITS; i++)\n\n        if (hwdef->iounit_bases[i] != (target_phys_addr_t)-1)\n\n            iounits[i] = iommu_init(hwdef->iounit_bases[i],\n\n                                    hwdef->iounit_version,\n\n                                    sbi_irq[hwdef->me_irq]);\n\n\n\n    espdma = sparc32_dma_init(hwdef->espdma_base, sbi_irq[hwdef->esp_irq],\n\n                              iounits[0], &espdma_irq, &esp_reset);\n\n\n\n    ledma = sparc32_dma_init(hwdef->ledma_base, sbi_irq[hwdef->le_irq],\n\n                             iounits[0], &ledma_irq, &le_reset);\n\n\n\n    if (graphic_depth != 8 && graphic_depth != 24) {\n\n        fprintf(stderr, \"qemu: Unsupported depth: %d\\n\", graphic_depth);\n\n        exit (1);\n\n    }\n\n    tcx_offset = qemu_ram_alloc(hwdef->vram_size);\n\n    tcx_init(ds, hwdef->tcx_base, phys_ram_base + tcx_offset, tcx_offset,\n\n             hwdef->vram_size, graphic_width, graphic_height, graphic_depth);\n\n\n\n    if (nd_table[0].model == NULL)\n\n        nd_table[0].model = \"lance\";\n\n    if (strcmp(nd_table[0].model, \"lance\") == 0) {\n\n        lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset);\n\n    } else if (strcmp(nd_table[0].model, \"?\") == 0) {\n\n        fprintf(stderr, \"qemu: Supported NICs: lance\\n\");\n\n        exit (1);\n\n    } else {\n\n        fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd_table[0].model);\n\n        exit (1);\n\n    }\n\n\n\n    nvram = m48t59_init(sbi_irq[0], hwdef->nvram_base, 0,\n\n                        hwdef->nvram_size, 8);\n\n\n\n    slavio_timer_init_all(hwdef->counter_base, sbi_irq[hwdef->clock1_irq],\n\n                          sbi_cpu_irq, smp_cpus);\n\n\n\n    slavio_serial_ms_kbd_init(hwdef->ms_kb_base, sbi_irq[hwdef->ms_kb_irq],\n\n                              nographic, ESCC_CLOCK, 1);\n\n    // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device\n\n    // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device\n\n    escc_init(hwdef->serial_base, sbi_irq[hwdef->ser_irq], serial_hds[1],\n\n              serial_hds[0], ESCC_CLOCK, 1);\n\n\n\n    if (drive_get_max_bus(IF_SCSI) > 0) {\n\n        fprintf(stderr, \"qemu: too many SCSI bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    main_esp = esp_init(hwdef->esp_base, 2,\n\n                        espdma_memory_read, espdma_memory_write,\n\n                        espdma, *espdma_irq, esp_reset);\n\n\n\n    for (i = 0; i < ESP_MAX_DEVS; i++) {\n\n        drive_index = drive_get_index(IF_SCSI, 0, i);\n\n        if (drive_index == -1)\n\n            continue;\n\n        esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, i);\n\n    }\n\n\n\n    kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename,\n\n                                    RAM_size);\n\n\n\n    nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, kernel_cmdline,\n\n               boot_device, RAM_size, kernel_size, graphic_width,\n\n               graphic_height, graphic_depth, hwdef->nvram_machine_id,\n\n               \"Sun4d\");\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n}\n", "idx": 3333, "substitutes": {"hwdef": ["cowdesc", "fwdecl", "fwDef", "cowdefinition", "cpuDef", "htdesc", "rwdef", "iwdef", "hawdecl", "htdefinition", "fwdef", "wdefinition", "wspec", "cowdef", "iwdesc", "hpdefined", "fwdefined", "cowDef", "hawDef", "htdef", "hpdef", "hawspec", "iwDef", "hawdefined", "wdef", "hwdesc", "cpudef", "hwspec", "cpudefined", "fwspec", "hwDef", "hwdefined", "rwdefined", "hwdecl", "iwdefinition", "hawdef", "htDef", "hpdecl", "hpDef", "hwdev", "fwdefinition", "wDef", "cpudev", "hawdefinition", "iwdefined", "rwdev", "iwdev", "hwdefinition", "rwDef"], "RAM_size": ["RAM_width", "RAM_addr", "ram_width", "RAM_unit", "ram_SIZE", "ramOsize", "ram_unit", "ram_size", "RAM_length", "ramOSIZE", "RAMMwidth", "RAMMSIZE", "RAMMsize", "RAMFlength", "ram_length", "ram_addr", "ramOunit", "RAM_SIZE", "ramOaddr", "RAMMlength", "RAMFwidth", "RAMFsize", "RAMFSIZE"], "boot_device": ["bootbookloader", "boot_model", "cpu_device", "bootaldevice", "bootbookmodel", "boot_loader", "bootbookmode", "bootalmodel", "boot_mode", "cpu_mode", "bootbookdevice", "bootalmode", "bootalloader", "cpu_loader"], "ds": ["dd", "fs", "dc", "ils", "sv", "des", "ns", "cs", "ys", "dm", "cdn", "df", "ps", "ks", "rs", "dt", "DS", "di", "dh", "eps", "tx", "std", "vs", "db", "irs", "da", "ss", "ls", "sync"], "kernel_filename": ["kernel1file", "kernel_file", "kernel1location", "hw_files", "kernel1filename", "kernel1files", "hw_file", "kernel_location", "kernel_files", "hw_location", "hw_filename"], "kernel_cmdline": ["kernel_bootline", "kernel_commandlist", "kernel_initlines", "kernel_cmdlink", "kernel_commandline", "kernel_initline", "kernel_bootlist", "kernel_commandlines", "kernel_commandlink", "kernel_bootlink", "kernel_initlink", "kernel_cmdlist", "kernel_initlist", "kernel_cmdlines", "kernel_bootlines"], "initrd_filename": ["initrdamfiles", "initrdamfn", "initrd_fp", "initrs_filename", "initrs_files", "initrd_fn", "initrdamfilename", "initrdamfp", "initrd_files", "initrs_fp", "initrs_fn"], "cpu_model": [" cpu_source", "cpu_description", "cpu__model", "cpu_models", "cpu_source", " cpupmodel", "core_mode", " cpu_Model", "cpupdescription", "core_engine", "cpu_engine", "cpupmodel", "cpugmode", "cpugcontrol", " cpu_description", "cpu_Model", "cpu__engine", "cpu__mode", " cpu_size", " cpupmode", "cpu_size", " cpupsource", "cpupsource", "cpu_server", " cpu_store", "core_control", "cpugserver", "cpu_store", " cpu_mode", "core_server", "core_model", "cpupmode", "cpu__models", " cpupdescription", "cpu_control", "cpu_mode", "cpugmodel", "core_models"], "env": ["her", "enc", "conf", "eu", "ec", "v", "ah", "exe", "ie", "output", "ef", "exc", "cb", "proc", "dev", "environment", "bc", "iv", "Environment", "gr", "inst", "exec", "impl", "zen", "eni", "config", "vm", "qv", "org", "event", "el", "erv", "site", "app", "eng", "scope", "init", "args", "err", "shell", "net", "priv", "ev", "inv", "working", "context", "ctx", "dir", "core", "session", "obj", " environment", "engine", "ini", "loader", "energy", "conn", "txt", "server", "dt", "enable", "vel", "extra", "e", "cache", "cf", "equ", "viron", "cli", "end", "here", "inet", "ext", "ne", "console", "ea", "export", "nc", "np", "vs", "dict", "db", "gui", "en", "essential"], "envs": ["atenv", "Envs", "inv", "ENviron", "enfs", "infs", "Enfs", " environ", "Env", "Environments", "ENfs", " enfs", "inviron", "ENvs", "atenvironments", "atenvs", "ENv", "environments", "atenviron", " environments", "environ", "invs", "ENvironments"], "MAX_CPUS": ["MAX_GPUs", "MAX_GPUTION", "MAX_PCUL", "MAX_GPINS", "MAX_PCUs", "MAX_cpUS", "MAX_CPUTION", "MAX_PCus", "MAX_CPUUs", "MAX_PCUS", "MAX_PUUS", "MAX_CAPUSE", "MAX_GPUL", "MAX_cpUL", "MAX_CPUs", "MAX_CPUL", "MAX_CPUUTION", "MAX_PUUTION", "MAX_PCINS", "MAX_CAPUs", "MAX_GPus", "MAX_GPUSE", "MAX_CPUUS", "MAX_CPus", "MAX_PCUSE", "MAX_GPUS", "MAX_CPINS", "MAX_cpUs", "MAX_CAPUS", "MAX_PUus", "MAX_CPUus", "MAX_cpINS", "MAX_CPUSE", "MAX_PUUs", "MAX_CAPus"], "i": ["anti", "uri", "key", "d", "z", "mi", "ri", "v", "bi", "iu", "ie", "ji", "ix", "info", "pi", "f", "ti", "ki", "phi", "my", "s", "ui", "l", "is", "si", "y", "axis", "p", "ci", "uni", "qi", "eni", "min", "name", "I", "li", "init", "mu", "ski", "b", "u", "xi", "it", "sup", "line", "udi", "io", "fi", "multi", "m", "ini", "slice", "uli", "g", "zi", "ai", "t", "ip", "e", "esi", "yi", "index", "hi", "j", "n", "split", "cli", "id", "adi", "ii", "a", "mini", "c", "di", "gi", "ni", "x", "inner", "en"], "iounits": ["iounites", "iounITS", "Iounips", "iumerites", "I8ips", "iounips", "ioulips", "I8ites", "ioulits", "ioulITS", "I8its", "iumerips", "Iounites", "IounITS", "Iounits", "i8its", "I8ITS", "ioulites", "i8ips", "i8ites", "iumerits", "iumerITS", "i8ITS"], "MAX_IOUNITS": ["MAX_ICUNINS", "MAX_IUNITS", "MAX_IOUNINS", "MAX_IOBITS", "MAX_ICUNIT", "MAX_IUNIT", "MAX_IOBINS", "MAX_IOBits", "MAX_ICUGINS", "MAX_ICUNITS", "MAX_IOUNits", "MAX_ICUGITS", "MAX_IUNits", "MAX_ICUNits", "MAX_IOBIT", "MAX_IOUNIT", "MAX_IUGINS", "MAX_IUGits", "MAX_IUGIT", "MAX_ICUGits", "MAX_IUNINS", "MAX_IUGITS", "MAX_ICUGIT"], "espdma": ["ispdmma", "espgdmma", "espdmm", "ispdmm", "esppdmm", "espsdma", "espsdmm", "esppdla", "esppdmma", "ispsdma", "espgdmm", "ispsdmm", "espdla", "esppdma", "ispdma", "espsdla", "espdmma", "espgdla", "ispdla", "ispsdmma", "espsdmma", "ispsdla", "espgdma"], "ledma": ["iledmas", "ledms", "ledmma", " ledmma", "iledmma", "iledms", "ldmas", "ldma", " ledmas", "ledmas", " ledms", "ldms", "iledma", "ldmma"], "main_esp": ["central_isp", "central_cp", "central_esp", "central_sp", "main_cp", "main_isp", "main_sp"], "nvram": ["nvgram", "ncgram", "ncmem", "lvram", "vgram", "vmem", "nvRAM", "lvgram", "vRAM", "ncRAM", "nvmem", "lvmem", "lvRAM", "vram", "ncram"], "sbi": ["lsci", "rsfi", "rsgi", " sci", " sgi", "rsci", "lsgi", "lsfi", "rsbi", " sfi", "sfi", "sgi", "lsbi", "sci"], "cpu_irqs": ["cpu_pirques", "cpu_rques", "cpu_arqs", "cpu_ireques", "cpu_igrq", "cpu_ironqu", "cpu_rues", "cpu_arues", "cpu_pirqs", "cpu_arq", "cpu_ireqs", "cpu_igrqs", "cpu_iraues", "cpu_iraques", "cpu_iraq", "cpu_arques", "cpu_pirues", "cpu_pirqu", "cpu_ironqs", "cpu_igrxes", "cpu_igrqu", "cpu_ironq", "cpu_rq", "cpu_irues", "cpu_ireq", "cpu_ireues", "cpu_pirxes", "cpu_ironxes", "cpu_irques", "cpu_iraqs", "cpu_irq", "cpu_irxes", "cpu_rqs", "cpu_pirq", "cpu_irqu"], "sbi_irq": ["sbi_irtqu", "sbi_irqs", "sbi_arqs", "sbi_arqu", "sbi_irtqs", "sbi_irtq", "sbi_drcle", "sbi_ircle", "sbi_irqu", "sbi_irtcle", "sbi_drqu", "sbi_drqs", "sbi_drq", "sbi_arcle", "sbi_arq"], "sbi_cpu_irq": ["sbi_cpu_mirq", "sbi_cpu_arqs", "sbi_cpu_irqs", "sbi_cpu_earce", "sbi_cpu_mirqs", "sbi_cpu_arq", "sbi_cpu_earqs", "sbi_cpu_mirce", "sbi_cpu_arce", "sbi_cpu_earq", "sbi_cpu_irce"], "espdma_irq": ["espdma__ierqs", "espdma_iraqu", "espdma__irqu", "espdma_iraqs", "espdma_risqu", "espdma_irque", "espdma__irqs", "espdma__ierq", "espdma_irqu", "espdma_risqs", "espdma_iraque", "espdma_ierqs", "espdma_ierqu", "espdma_risque", "espdma_ierq", "espdma_ierque", "espdma__ierque", "espdma_risq", "espdma__irq", "espdma__ierqu", "espdma_iraq", "espdma_irqs", "espdma__irque"], "ledma_irq": ["ledma_pirquest", "ledma_arQ", "ledma_arquest", "ledma_pirQ", "ledma_arp", "ledma_riq", "ledma_arq", "ledma_rip", "ledma_pirp", "ledma_irquest", "ledma_riquest", "ledma_riQ", "ledma_pirq", "ledma_irQ", "ledma_irp"], "esp_reset": [" esp_free", "esp_free", "esp_init", " esp_set", "esp__reset", "esp__free", " esp_init", "esp_set", "esp__init", "esp__set"], "le_reset": ["les_set", "le_init", "les_init", "les_offset", "les_reset", "le_offset", "le_set"], "ram_offset": ["gram_length", "gram_offset", "gram_size", "ram_index", "ram_size", "gram_index", "ram_length"], "prom_offset": ["rem_reset", "prom_addr", "rem_addr", "rem_offset", "prom_limit", "rem_limit", "prom_reset"], "tcx_offset": ["tcm_offset", "tcx64off", "tcx_ref", "tcm64index", "tcx_index", "tcx64ref", "tcm_ref", "tcm_index", "tcm64off", "tcm64offset", "tcx64offset", "tcx_off", "tcx64index", "tcm_off", "tcm64ref"], "kernel_size": ["kernel_length", "kernel___strength", " kernel_len", "kernel___size", " kernel_length", " kernel_strength", "kernel___length", "kernel_len", "kernel_strength", "kernel___len"], "ret": ["rep", "val", "all", "res", " RET", "rc", "num", "alt", "RET", "mem", "mi", "buffer", "rets", "data", "batch", " mem", "nt", "reg", "info", "result", "Ret", "re", "final"], "buf": ["buff", "loc", "ptr", "alloc", "mem", "raw", " buffer", "var", "buffer", "blocks", "pad", "cv", "func", "data", "batch", "uf", "bag", "pool", "map", "board", "block", "cb", "cap", "bin", "box", "bytes", "seq"], "drive_index": [" drive_length", " driver_length", " driver_index", " driver_number", " driver_cache", " drive_number", " drive_cache"], "fw_cfg": ["hw_config", "hw2fg", "fw_fg", "hw2cfg", "fw_cf", "hw2config", "fw2cf", "fw2fg", "hw_fg", "hw_cf", "hw_cfg", "fw2cfg", "fw2config", "fw_config", "hw2cf"]}}
{"project": "qemu", "commit_id": "88571882516a7cb4291a329c537eb79fd126e1f2", "target": 0, "func": "static int qemu_rdma_block_for_wrid(RDMAContext *rdma, int wrid_requested)\n\n{\n\n    int num_cq_events = 0, ret = 0;\n\n    struct ibv_cq *cq;\n\n    void *cq_ctx;\n\n    uint64_t wr_id = RDMA_WRID_NONE, wr_id_in;\n\n\n\n    if (ibv_req_notify_cq(rdma->cq, 0)) {\n\n        return -1;\n\n    }\n\n    /* poll cq first */\n\n    while (wr_id != wrid_requested) {\n\n        ret = qemu_rdma_poll(rdma, &wr_id_in);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;\n\n\n\n        if (wr_id == RDMA_WRID_NONE) {\n\n            break;\n\n        }\n\n        if (wr_id != wrid_requested) {\n\n            DDDPRINTF(\"A Wanted wrid %s (%d) but got %s (%\" PRIu64 \")\\n\",\n\n                print_wrid(wrid_requested),\n\n                wrid_requested, print_wrid(wr_id), wr_id);\n\n        }\n\n    }\n\n\n\n    if (wr_id == wrid_requested) {\n\n        return 0;\n\n    }\n\n\n\n    while (1) {\n\n        /*\n\n         * Coroutine doesn't start until process_incoming_migration()\n\n         * so don't yield unless we know we're running inside of a coroutine.\n\n         */\n\n        if (rdma->migration_started_on_destination) {\n\n            yield_until_fd_readable(rdma->comp_channel->fd);\n\n        }\n\n\n\n        if (ibv_get_cq_event(rdma->comp_channel, &cq, &cq_ctx)) {\n\n            perror(\"ibv_get_cq_event\");\n\n            goto err_block_for_wrid;\n\n        }\n\n\n\n        num_cq_events++;\n\n\n\n        if (ibv_req_notify_cq(cq, 0)) {\n\n            goto err_block_for_wrid;\n\n        }\n\n\n\n        while (wr_id != wrid_requested) {\n\n            ret = qemu_rdma_poll(rdma, &wr_id_in);\n\n            if (ret < 0) {\n\n                goto err_block_for_wrid;\n\n            }\n\n\n\n            wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;\n\n\n\n            if (wr_id == RDMA_WRID_NONE) {\n\n                break;\n\n            }\n\n            if (wr_id != wrid_requested) {\n\n                DDDPRINTF(\"B Wanted wrid %s (%d) but got %s (%\" PRIu64 \")\\n\",\n\n                    print_wrid(wrid_requested), wrid_requested,\n\n                    print_wrid(wr_id), wr_id);\n\n            }\n\n        }\n\n\n\n        if (wr_id == wrid_requested) {\n\n            goto success_block_for_wrid;\n\n        }\n\n    }\n\n\n\nsuccess_block_for_wrid:\n\n    if (num_cq_events) {\n\n        ibv_ack_cq_events(cq, num_cq_events);\n\n    }\n\n    return 0;\n\n\n\nerr_block_for_wrid:\n\n    if (num_cq_events) {\n\n        ibv_ack_cq_events(cq, num_cq_events);\n\n    }\n\n    return ret;\n\n}\n", "idx": 3348, "substitutes": {"rdma": ["rdm", "rrma", "rhmc", "rdga", "rdda", "rtmeta", "rmc", "rtla", "hrema", "drla", "lrmar", "rhma", "ldda", "rtma", "drema", "rda", "rtema", "rtmar", "rbema", "rnmeta", "djda", "rdmas", "ldma", "rtmma", "lrma", "rdmc", "rtda", "rhm", "rhema", "rrema", "rdmeta", "robema", "robma", "rema", "rmma", "drga", "rrm", "lrmeta", "ldm", "hrma", "rdmma", "rtmc", "drmas", "robmma", "drma", "djmma", "rhla", "rnma", "rdema", "djma", "rdla", "rbma", "rnmar", "djmas", "rhmas", "ldmc", "rbga", "rbla", "robmas", "hrmma", "rtmas", "rrmas", "rnmas", "ldmas", "ldema", "rmas", "lrmas", "rhga", "drmc", "rdmar", "rma", "hrmas"], "wrid_requested": ["wrid_reqes", "wrid_QUESTped", "wrid_requestd", "wridtresponding", "wrid_nameed", "wridFrequesting", "wrid_RequestED", "wrid_uploaded", "wrid_Requested", "wrid_request1", "wrid_timED", "wrid_QUESTED", "wrid_requesting", "wrid_warnled", "wrid_Requesting", "wrid_returned", "wrid_Request1", "wrid_claimED", "wrid_requipped", "wrid_Requestipped", "wrid_Requestped", "wrid_warnached", "wrid_requesteded", "wridtrequest1", "wrid_timed", "wrid_quested", "wridtrespond1", "wrid_passing", "wrid_respondeded", "wrid_requestised", "wridFpassED", "wrid_Requestled", "wrid_claimed", "wridFpassed", "wrid_questED", "wrid_returnled", "wrid_passED", "wrid_reqing", "wrid_Requesteded", "wrid_nameED", "wrid_times", "wrid_reqed", "wrid_requED", "wrid_Requestd", "wrid_QUESTing", "wrid_quest1", "wrid_returnached", "wrid_requed", "wridFpassing", "wrid_requestED", "wrid_reqised", "wrid_requestes", "wrid_respond1", "wrid_reqED", "wrid_requestached", "wrid_Requestised", "wrid_warned", "wridFpassped", "wrid_Requestes", "wridtresponded", "wrid_requestipped", "wridtrespondeded", "wrid_uploading", "wrid_passed", "wrid_questing", "wrid_responded", "wrid_nameing", "wrid_responding", "wridFrequestED", "wrid_QUESTed", "wrid_nameised", "wrid_claimd", "wridFrequestped", "wrid_Requestached", "wrid_requestled", "wrid_requestped", "wrid_uploadeded", "wrid_claimipped", "wrid_uploadED", "wrid_passped", "wrid_requd", "wridFrequested", "wrid_questeded", "wridtrequested", "wridtrequesteded", "wrid_warnED", "wrid_timing", "wrid_returnED", "wridtrequesting"], "cq": ["fcQ", "lcqs", "rcqs", "ncqu", "tcvc", "tcql", "cqu", "pcqu", "Cqa", "cQ", "cfqq", "tcqt", "tcq", "cql", "pcqq", "dcqt", "pcq", "lcqa", "dcql", "cqs", "pcqs", "Cqs", "rcqa", "cfq", "Cq", "fcq", "cfqs", "ncq", " cqs", "pcqt", "cfqu", "ncqq", "cqt", "CQ", "lcq", "pcvc", "pcql", "fcqa", "ccqa", "rcQ", "ccqu", "ccq", "ccqs", " cqa", " cqu", "lcqu", "cqq", "ncqs", "rcq", "cvc", "dcq", "fcqs", "cqa", "dcvc"], "cq_ctx": ["cq_cf", "cq_loc", "cw_ctx", "cq_tx", "cw_conn", "cq_conn", "cw_tx", "cq_context", "cw_context"], "wr_id_in": ["wr_type_ini", "wr_type_init", "wr_info_ins", "wr_id_ini", "wr_name_out", "wr_name_inc", "wr_type_type", "wr_id67in", "wr_type_login", "wr_type_inc", "wr_id_init", "wr_id_pin", "wr_idjinc", "wr_type_in", "wr_name_in", "wr_id__from", "wr_id_int", "wr_type_from", "wr_info_in", "wr_id_on", "wr_info_inc", "wr_id_from", "wr_id_type", "wr_id_login", "wr_id__login", "wr_type_on", "wr_id_out", "wr_info_int", "wr_id_inc", "wr_id67init", "wr_id__in", "wr_id__inc", "wr_id67on", "wr_id_ins", "wr_id67inc", "wr_idjon", "wr_idjin", "wr_idjinit", "wr_name_pin"], "num_cq_events": ["num_cqsevent", "num_cv_event", "num_cqsblocks", "num_cqxevents", "num_cv_blocks", "num_cq_rows", "num_cQ_events", "num_cQ_Events", "num_cQ_event", "num_cv_events", "num_cqxEvents", "num_cqsevents", "num_cv_rows", "num_cqsrows", "num_cq_blocks", "num_cqxevent", "num_cq_event", "num_cq_Events"]}}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *dst, int src_size)\n\n{\n\n    const uint16_t *end;\n\n    const uint16_t *mm_end;\n\n    uint8_t *d = dst;\n\n    const uint16_t *s = (const uint16_t *)src;\n\n    end = s + src_size/2;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*s):\"memory\");\n\n    __asm__ volatile(\"pxor    %%mm7,%%mm7    \\n\\t\":::\"memory\");\n\n    __asm__ volatile(\"pcmpeqd %%mm6,%%mm6    \\n\\t\":::\"memory\");\n\n    mm_end = end - 3;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movq          %1, %%mm0    \\n\\t\"\n\n            \"movq          %1, %%mm1    \\n\\t\"\n\n            \"movq          %1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            PACK_RGB32\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s),\"m\"(mask15b),\"m\"(mask15g),\"m\"(mask15r)\n\n            :\"memory\");\n\n        d += 16;\n\n        s += 4;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        register uint16_t bgr;\n\n        bgr = *s++;\n\n        *d++ = (bgr&0x1F)<<3;\n\n        *d++ = (bgr&0x3E0)>>2;\n\n        *d++ = (bgr&0x7C00)>>7;\n\n        *d++ = 255;\n\n    }\n\n}\n", "idx": 3375, "substitutes": {"src": ["dist", "rb", "sur", "loc", "r", "sc", "sr", "inst", "rc", "sub", "img", "sel", "st", "split", "slice", "rec", "stream", "dest", "gz", "data", "length", "sb", "rs", "url", "c", "gb", "start", "cb", "b", "cur", "range", "ss", "sl", "ds", "sync", "source"], "dst": ["inst", "datst", "datfl", "fsc", "datsts", " dsc", "dsts", "dsc", "sdfl", "fsrc", " dsts", " dsrc", "dfl", "insc", "dsrc", "sdst", "dfe", "insrc", "fst", "sdsrc", "datsrc", "infe", " dfe", " dfl", "sdsts", "ffe"], "src_size": ["src_len", "rc_scale", "rc_size", "src_scale", "rc_len"], "end": ["offset", "i", "ension", "r", "enc", "END", "n", "begin", "p", "nd", "m", "se", "edge", "z", "send", "id", "head", "w", "ion", "ad", "win", "k", "ender", "stop", "est", "shape", "c", "start", "ending", "End", "ent", "max", "f", "u", "dev", "set", "size", "e", "x", "ended", "h", "en"], "mm_end": ["mm_id", "mm_END", "mm67stop", "mm_ending", "mm67id", "cm_END", "mm67end", "mm_size", "mm67start", " mm_ends", "cm_ending", "mm_ends", " mm_ended", "mem_id", "mm_stop", " mm_size", "mem_end", "mm_ended", "mem_start", "mm_start", "cm_end", "mem_stop", "cm_start"], "d": ["dd", "i", "dc", "did", "Ds", "r", "l", "ded", "de", "dB", "j", "n", "dl", "o", "y", "bd", "p", "nd", "ind", "m", "dat", "z", "id", "w", "ad", "dy", "ed", "ld", "dds", "v", "D", "fd", "g", "c", "dt", "start", "di", "dh", "t", "sd", "b", "f", "u", "dos", "e", "x", "ds", "h", "cd"], "s": ["times", "S", "i", "r", "su", "sv", "sync", "ts", "l", "ns", "sets", "cs", "si", "is", "j", "n", "sec", "sh", "y", "o", "south", "p", "st", "ssl", "sup", "m", "sq", "se", "session", "z", "id", "send", "ids", "w", "v", "services", "states", "g", "ps", "sp", "us", "ses", "spec", "c", "sb", "devices", "es", "start", "t", "sd", "b", "f", "u", "os", "days", "seconds", "ments", "ss", "side", "e", "sl", "ls", "x", "dos", "ds", "tests", "h"], "bgr": ["obdr", "dgr", " brav", "obarr", "cdr", "mbr", "mgp", "rdist", "mgr", "menge", "rgp", "mge", " bdist", "brenge", "sbgr", "Bgr", "mdist", "bbr", "brge", "Bdr", "rdr", "sbbr", "Barr", "pbr", " bgp", "cgr", "bgp", "bge", "obge", " barr", "pdr", " bbr", "dbr", "obbr", "pgr", "barr", "rgr", "drav", "obgr", "obenge", "bdr", "bdist", "ddr", "cbr", "sbdr", "brav", "benge", "crav", "Bbr", "brbr", " bdr", "brgr", "mdr"]}}
{"project": "qemu", "commit_id": "a80bf99fa3dd829ecea88b9bfb4f7cf146208f07", "target": 1, "func": "static int mux_chr_can_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    MuxDriver *d = chr->opaque;\n\n\n\n    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)\n\n        return 1;\n\n    if (d->chr_can_read[chr->focus])\n\n        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);\n\n    return 0;\n\n}\n", "idx": 3392, "substitutes": {"opaque": ["hopque", "opac", "opa", "opca", "pque", "obac", "operque", "pacity", "ipaque", "opque", " opque", "obaque", "compacity", "ipca", "hopac", "operca", "operc", " opc", "opsacity", " opacity", "paque", "opc", "compaque", "opsa", "opacity", "hopaque", " opa", "opsque", "obque", "hopacity", "compque", "pa", "compac", "obacity", " opca", "opsaque", "ipque", "operaque", "ipc"], "chr": [" chrc", "chrb", "chrator", "chtr", "cltr", "clrt", " chrt", " chsr", "shrr", "cherrator", "Chcr", "archtr", "archerr", "cherrer", " chrg", "cherr", "cherR", "ochr", "clr", "chcr", "echr", "Chr", "khrer", " chra", "khr", "clra", "ocherr", "Chsr", "chrr", " chcr", "chorer", "choR", " chrb", "charr", "chorator", "sherr", "chrt", "khrator", "chartr", "Chrg", "echrc", "chrg", "motr", "Chrc", "chra", "charrt", "ochrr", "Chrb", "shr", "chrer", "charra", "khR", "archrr", "motrg", "shtr", "archr", "motsr", "chor", "chsr", "motcr", "ochtr", "chR", "echsr", "echrb", " chtr", "chrc"], "d": ["driver", "md", "dd", "dad", "dc", "did", "od", "r", "ded", "l", "de", "n", "bd", "dl", "o", "p", "pd", "nd", "dm", "ind", "ct", "m", "dat", "z", "id", "w", "ad", "dy", "dom", "ld", "rd", "D", "fd", "g", "dn", "xd", "c", "dt", "du", "gd", "di", "dh", "dict", "t", "db", " D", "b", "u", "f", "sd", "da", "e", "x", "ds", "s", "cd"]}}
{"project": "qemu", "commit_id": "8991c460be5a0811194fd4d2b49ba7146a23526b", "target": 1, "func": "static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *s)\n\n{\n\n    return s->iq_tail == 0;\n\n}\n", "idx": 3394, "substitutes": {"s": ["S", "ures", "fs", "ils", "sets", "ts", "ns", "settings", "cs", "ares", "ssl", "o", "p", "rates", "als", "ips", "ins", "rows", "ches", "ans", "services", "sys", "states", "ves", "ps", "ses", "ks", "sb", "es", "results", "gs", "sym", "ows", "b", "aws", "ss", "js", "e", "ls", "ops", "ds"]}}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *dst2, int dstWidth,\n\n                                     const uint8_t *src_in[4],\n\n                                     int srcW, int xInc, const int16_t *hChrFilter,\n\n                                     const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                     uint8_t *formatConvBuffer, uint32_t *pal)\n\n{\n\n    const uint8_t *src1 = src_in[1], *src2 = src_in[2];\n\n    if (c->chrToYV12) {\n\n        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);\n\n        c->chrToYV12(formatConvBuffer, buf2, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= buf2;\n\n    } else if (c->readChrPlanar) {\n\n        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);\n\n        c->readChrPlanar(formatConvBuffer, buf2, src_in, srcW);\n\n        src1= formatConvBuffer;\n\n        src2= buf2;\n\n    }\n\n\n\n    if (!c->hcscale_fast) {\n\n        c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hcScale(c, dst2, dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hcscale_fast(c, dst1, dst2, dstWidth, src1, src2, srcW, xInc);\n\n    }\n\n\n\n    if (c->chrConvertRange)\n\n        c->chrConvertRange(dst1, dst2, dstWidth);\n\n}\n", "idx": 3397, "substitutes": {"c": ["cu", "cache", "dc", "cr", "cit", "cc", "bc", "com", "r", "cy", "sc", "cf", "ac", "l", "rc", "cpp", "cs", "enc", "conf", "n", "core", "vc", "p", "ci", "ce", "ic", "ec", "xc", "d", "m", "config", "call", "k", "tc", "con", "cp", "lc", "conn", "pc", "co", "ca", "g", "coll", "ctrl", "comp", "nc", "ch", "mc", "oc", "t", "b", "f", "u", "cl", "cur", "C", "e", "uc", "ct", "h", "cm", "s"], "dst1": ["dstdFirst", "drc2", " drc1", "drcOne", "dest2", " dsc3", " dst3", "drc0", "dstsX", "dstOne", "drcFirst", "dsc3", "dst3", "dscOne", "drd2", "destFirst", "dscX", "dest1", "destOne", "dsts1", " dstone", "drc1", "dsts2", "dstX", "drcX", " dsc2", " dsc1", " drcX", "dstsFirst", " drcFirst", "drd3", " dstFirst", " dscOne", "dest3", "dstone", " dstX", " dsc0", " dst0", "dstd1", "dstFirst", "dstdone", "dst0", " dscFirst", " drc2", "dest0", "dscFirst", "dstsone", " drcone", " drcOne", " dstOne", "dstd2", "dsc2", "drdFirst", "dstsOne", "drd1", "dsc1", "drcone", "dsc0"], "dst2": ["destSecond", "drc2", "drest1", "Dsc2", "Dst4", "dst02", "dstageTwo", "dstBoth", "dest2", "drest2", "DstTwo", "dst152", "dstSecond", "dST2", "dST02", "Drc02", "Dsc1", "drest152", "dstageSecond", "Dst1", "DscTwo", " dest1", "drest8", " dsc152", "dstage1", "dest152", "dscBoth", "ddestBoth", "dest1", "dST4", "dSTTwo", " dstTwo", "DrcTwo", "drcTwo", "ddest02", "drc1", " dst8", "Drc2", "DstBoth", "Dst02", "dsc152", " dsc2", "dst8", " dsc8", " dsc1", "destTwo", "dst4", "drc4", "ddest2", "dstTwo", " destTwo", "ddest1", "dsc8", " destSecond", "dscSecond", "DscBoth", "Dst2", " dst152", " dstSecond", "drc02", "drcBoth", "dest8", "dstage2", "ddestTwo", "dsc2", "Drc4", "ddest4", " dest2", "dsc1", "dscTwo"], "dstWidth": ["DstHeight", "adstHeight", "drc2", "destW", " destLength", "dstW", " destwidth", "dastLength", "dest2", " drcwidth", "adstswidth", " dstwidth", "DSTwidth", "dST2", "dSTwidth", "destHeight", "drcwidth", "dscHeight", "adstsWidth", "adstsHeight", " drcHeight", "adst2", "adsts2", "dstswidth", "destWidth", "DstWidth", "dStwidth", "dstsHeight", "DSTWidth", "dSTHeight", " destW", "dsts2", " dstHeight", " dstLength", "dstsWidth", "dastHeight", "destwidth", " dstW", "drcHeight", "adstwidth", "Dstwidth", "drcLength", "destLength", "dstwidth", "adstWidth", "dscWidth", "dstHeight", "Dst2", " destHeight", "dastWidth", "dSt2", "dSTWidth", " drc2", "dastW", " drcWidth", "drcW", "dStHeight", "drcWidth", " destWidth", "dstLength", "dStWidth", "DSTHeight", "dsc2", "DST2", " dest2", "dscwidth"], "src_in": ["rc_out", "src_out", " src_again", "st_ins", "rc_inc", " src_out", "cv_again", "st_ini", "src2ini", "src__out", "cv_gin", "rc_in", "src_isin", "src2gin", "src__isin", "src_inc", "src2ins", "src__in", "st__out", "src__again", "st__ins", "cv_inc", "st_in", "src2inc", "src_again", "src_ins", "src2in", "src__inc", "src2out", "cv_in", "src2again", "src__gin", "src_gin", "src__ins", "src__ini", "rc_isin", "st__ini", "src_ini", "st__in", "st_out"], "srcW": ["destW", "rcw", "srcN", "rc2", "scL", "srcw", "slW", "source1", " srcV", "srcWh", "destw", "rc1", " srcw", "sourcew", "destN", "scW", "srcL", "destWidth", "destH", "rcN", "sourceW", "destV", " srcWidth", "surL", "slw", "sourceL", "slL", "srcWidth", "sourceH", "rcV", "srcH", " srcN", "sourceN", "rcL", "srcV", "rcW", "scWh", "sourceV", "surH", "scw", "rcWh", "destL", "surW", "surw", "slWh", "rcWidth", "source2"], "xInc": ["xAdd", "yInc", "xxEnc", " xExp", "xxIncre", "xExp", "yAdd", "XInc", "XEnc", "exExp", " xEnc", " xIncre", "exAdd", " xIncrease", "xxInc", "xIncrease", "XIncrease", "XIncre", "yExp", "exInc", "xxIncrease", " xAdd", "xEnc", " xinc", "xIncre", "yinc", "xinc", "exinc"], "hChrFilter": ["hChrBuffer", "hMcrarFilter", "hCrrFill", "hchpBuffer", "hChuFormat", "hchpFilter", "hChroFill", "hChroFormat", "hCrrFilter", "hChrFill", "hChrlFrame", "hMcrarCover", "hchrFormat", "hChuBuffer", "hChpFactor", "hChrFrame", "hChlerFill", "hChlerFrame", "hChroBuffer", "hchrFilter", "hCrrlFrame", "hChrtFrame", "hChruFill", "hMcrarWidth", "hChpBuffer", "hMcrCover", "hChrtWidth", "hCrrWidth", "hChpFilter", "hMcrFill", "hChrarWidth", "hchpFormat", "hChrFactor", "hCrrFrame", "hChlerWidth", "hCrrlWidth", "hCrrlFill", "hChpFormat", "hMcrFilter", "hChlerFilter", "hChrtFilter", "hChroWidth", "hChroFactor", "hChrtFill", "hMcrarFill", "hCrrlFilter", "hChrlFilter", "hChrarCover", "hChrarFilter", "hChruFilter", "hChruCover", "hChroCover", "hChrarFill", "hChrWidth", "hChroFilter", "hchrFactor", "hChuFactor", "hChrFormat", "hChuFilter", "hMcrWidth", "hChrlWidth", "hChrCover", "hchpFactor", "hChrlFill", "hchrBuffer", "hChruWidth"], "hChrFilterPos": ["hChrRulePos", "hChrFactorPo", "hChrBufferLen", "hChlBufferPos", "hChrBufferDef", "hChrFeatureNeg", "hChrRuleWin", "hChrBufferType", "hChrLevelPos", "hChroFilterPo", "hChlBufferLen", "hChrLevelPo", "hChrHelperPo", "hChlBufferDef", "hChlFilterWin", "hChrFilterWin", "hChrFactorPos", "hChrFilterDef", "hChrBufferPos", "hChrMaskLen", "hChrHeaderDef", "hChrHeaderLen", "hChrFilterTop", "hChlFilterDef", "hChlRuleWin", "hChrMaskDef", "hChrFactorOrigin", "hChlFilterType", "hChrFactorWin", "hChrFeaturePos", "hChrRulePo", "hChrHelperNeg", "hChrMaskPos", "hChrHelperPos", "hChlFilterPos", "hChrLevelOrigin", "hChlRuleOrigin", "hChrMaskType", "hChrFilterOrigin", "hChrFilterPo", "hChrFeatureTop", "hChrFilterNeg", "hChlFilterPo", "hChrRuleOrigin", "hChrLevelWin", "hChrFilterLen", "hChrHelperTop", "hChroFilterTop", "hChlFilterOrigin", "hChrFeaturePo", "hChlRulePos", "hChrHeaderType", "hChrFilterType", "hChlRulePo", "hChrHeaderPos", "hChlFilterLen", "hChlBufferType", "hChroFilterNeg", "hChroFilterPos"], "hChrFilterSize": ["hChrRuleSize", "hChrBufferLen", "hChrnFilterSize", "hChrFormatSize", "hChrFilterName", "hChmFilterNo", "hChrbFilterSize", "hChmBufferNo", "hChrBufferInfo", "hChrFilterSet", "hChrLimitSet", "hChrBufferSize", "hChrFormatZone", "hChrImageLength", "hChrfilterNo", "hChrImageSize", "hChrfilterLen", "hChrFilName", "hChrbFormatName", "hChmBufferSize", "hChrbFilterName", "hChrFilterInfo", "hChrFilterNo", "hChrnImageSize", "hChrRuleLength", "hChrFactorInfo", "hChrFactorLen", "hChmBufferInfo", "hChrnFilterLength", "hChrfilterSize", "hChrRuleSet", "hChrFactorZone", "hChrImageSet", "hChrFilterZone", "hChrfilterInfo", "hChrnFilterSet", "hChmFilterInfo", "hChrBufferNo", "hChrFilSize", "hChrFilterLength", "hChrFactorName", "hChmFilterLen", "hChrFormatName", "hChmFilterSize", "hChrFactorSize", "hChrbFormatSize", "hChrFilterLen", "hChrLimitSize", "hChrbFilterZone", "hChmBufferLen", "hChrnImageLength", "hChrbFormatZone", "hChrFactorNo", "hChrLimitLength", "hChrnImageSet", "hChrFilZone"], "formatConvBuffer": ["formatConvsCenter", "formatAnfBuff", "formatConVReader", "formatConVFile", "formatConVFormat", "formatConfFormat", "formatConfCode", "formatConfStream", "formatConvdCode", "formatEnvStream", "formatConuvBuffer", "formatConovBuff", "formatConconvFrame", "formatEnvBuff", "formatConverStream", "formatEnfBuff", "formatConvStream", "formatEnfCenter", "formatConvdBuffer", "formatConfBuff", "formatAnvBuff", "formatConfFile", "formatConVCode", "formatConvFile", "formatConchBegin", "formatEnVBegin", "formatConuvBuff", "formatEnVCode", "formatConfBuffer", "formatConlCenter", "formatConverBuff", "formatEnvBegin", "formatConchBuff", "formatConVBuffer", "formatConlBuff", "formatConVLine", "formatConpFormat", "formatEnVCenter", "formatConovBuffer", "formatEnVLine", "formatAnvBuffer", "formatEnvLine", "formatConVBuff", "formatConvsBuff", "formatEnvFrame", "formatConVCenter", "formatAnfBuffer", "formatConovLine", "formatConvFrame", "formatEnVFile", "formatConconvBuffer", "formatEnVFormat", "formatConuvReader", "formatConvCode", "formatAnfReader", "formatConverBuffer", "formatEnvFile", "formatConvdBuff", "formatAnvReader", "formatConconvCenter", "formatConVBegin", "formatConvBegin", "formatConpBuffer", "formatEnfFrame", "formatConchLine", "formatConVStream", "formatEnvCenter", "formatEnvFormat", "formatConfReader", "formatConpBuff", "formatEnvBuffer", "formatConvsFile", "formatConvFormat", "formatConlFrame", "formatConvLine", "formatConlBuffer", "formatConvReader", "formatEnvCode", "formatEnVBuffer", "formatEnVStream", "formatConvsBuffer", "formatConvCenter", "formatEnfBuffer", "formatEnVBuff", "formatConovBegin", "formatConchBuffer", "formatConfCenter", "formatConfFrame", "formatConvBuff", "formatConconvBuff"], "pal": ["opal", "cal", "val", "plan", "Pal", "scale", "fac", "conf", "pl", "pixel", "le", "what", "alias", "fal", "real", "area", "label", "cale", "el", "li", "ap", "vals", "pp", "ar", "ee", "panel", "local", "ace", "rel", "al", "pack", "bin", "nl", " Pal", "align"], "src1": ["loc1", " srcOne", "sourceOne", "srcN", "rc2", "loc2", "srcFirst", "source1", "rc1", "sc2", "locN", "host1", " src3", "src0", "rcN", "sc3", "loc0", "hostFirst", "source3", "srcOne", "rcOne", "scOne", "source2", "host0", "comp1", " srcFirst", "sc1", " src01", "rc3", " srcN", "rc01", "comp01", "compOne", "src3", " src0", "rcFirst", "src01", "rc0", "hostOne"], "src2": ["supTwo", "sq2", "config2", "sq02", "rc2", "source02", "rc02", "srcTwo", "ctxtwo", "rcTwo", "source1", "url1", "rc1", "src8", "urlSecond", " srcTwo", "ctx0", "configTwo", "rc8", " src02", "url4", "src0", "bufAll", "sup0", "rssBoth", "srcSecond", " src4", "sourceTwo", "rcSecond", "sq0", " srcSecond", "rcAll", "rssTwo", "rc4", "ctx2", "rcBoth", "source0", "src4", "buf0", "rctwo", "sqtwo", "srcBoth", " src8", "url2", "rss1", "ctx02", "srcAll", "bufTwo", "config1", "configBoth", " src0", "src02", "supAll", "source8", "rss2", "srctwo", "rc0", "sup2", "source2"], "buf2": ["buff4", " buf0", "buff3", "buff8", " buf4", "buf4", "buf1", "buf0", "src4", "buff2", "buff0", "uf3", "buf3", "buff1", " buf3", " buf1", "src3", "uf0", "uf2", "buf8", "uf4", "uf1", "uf8", " buf8", "src8"]}}
{"project": "qemu", "commit_id": "d470ad42acfc73c45d3e8ed5311a491160b4c100", "target": 1, "func": "static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,\n        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)\n{\n    BlockDriverState *bs = child->bs;\n    /* Perform I/O through a temporary buffer so that users who scribble over\n     * their read buffer while the operation is in progress do not end up\n     * modifying the image file.  This is critical for zero-copy guest I/O\n     * where anything might happen inside guest memory.\n     */\n    void *bounce_buffer;\n    BlockDriver *drv = bs->drv;\n    struct iovec iov;\n    QEMUIOVector local_qiov;\n    int64_t cluster_offset;\n    int64_t cluster_bytes;\n    size_t skip_bytes;\n    int ret;\n    int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n                                    BDRV_REQUEST_MAX_BYTES);\n    unsigned int progress = 0;\n    /* FIXME We cannot require callers to have write permissions when all they\n     * are doing is a read request. If we did things right, write permissions\n     * would be obtained anyway, but internally by the copy-on-read code. As\n     * long as it is implemented here rather than in a separate filter driver,\n     * the copy-on-read code doesn't have its own BdrvChild, however, for which\n     * it could request permissions. Therefore we have to bypass the permission\n     * system for the moment. */\n    // assert(child->perm & (BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE));\n    /* Cover entire cluster so no additional backing file I/O is required when\n     * allocating cluster in the image file.  Note that this value may exceed\n     * BDRV_REQUEST_MAX_BYTES (even when the original read did not), which\n     * is one reason we loop rather than doing it all at once.\n     */\n    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);\n    skip_bytes = offset - cluster_offset;\n    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,\n                                   cluster_offset, cluster_bytes);\n    bounce_buffer = qemu_try_blockalign(bs,\n                                        MIN(MIN(max_transfer, cluster_bytes),\n                                            MAX_BOUNCE_BUFFER));\n    if (bounce_buffer == NULL) {\n        ret = -ENOMEM;\n        goto err;\n    while (cluster_bytes) {\n        int64_t pnum;\n        ret = bdrv_is_allocated(bs, cluster_offset,\n                                MIN(cluster_bytes, max_transfer), &pnum);\n        if (ret < 0) {\n            /* Safe to treat errors in querying allocation as if\n             * unallocated; we'll probably fail again soon on the\n             * read, but at least that will set a decent errno.\n             */\n            pnum = MIN(cluster_bytes, max_transfer);\n        assert(skip_bytes < pnum);\n        if (ret <= 0) {\n            /* Must copy-on-read; use the bounce buffer */\n            iov.iov_base = bounce_buffer;\n            iov.iov_len = pnum = MIN(pnum, MAX_BOUNCE_BUFFER);\n            qemu_iovec_init_external(&local_qiov, &iov, 1);\n            ret = bdrv_driver_preadv(bs, cluster_offset, pnum,\n                                     &local_qiov, 0);\n            if (ret < 0) {\n                goto err;\n            bdrv_debug_event(bs, BLKDBG_COR_WRITE);\n            if (drv->bdrv_co_pwrite_zeroes &&\n                buffer_is_zero(bounce_buffer, pnum)) {\n                /* FIXME: Should we (perhaps conditionally) be setting\n                 * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy\n                 * that still correctly reads as zero? */\n                ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, pnum, 0);\n            } else {\n                /* This does not change the data on the disk, it is not\n                 * necessary to flush even in cache=writethrough mode.\n                 */\n                ret = bdrv_driver_pwritev(bs, cluster_offset, pnum,\n                                          &local_qiov, 0);\n            if (ret < 0) {\n                /* It might be okay to ignore write errors for guest\n                 * requests.  If this is a deliberate copy-on-read\n                 * then we don't want to ignore the error.  Simply\n                 * report it in all cases.\n                 */\n                goto err;\n            qemu_iovec_from_buf(qiov, progress, bounce_buffer + skip_bytes,\n                                pnum - skip_bytes);\n        } else {\n            /* Read directly into the destination */\n            qemu_iovec_init(&local_qiov, qiov->niov);\n            qemu_iovec_concat(&local_qiov, qiov, progress, pnum - skip_bytes);\n            ret = bdrv_driver_preadv(bs, offset + progress, local_qiov.size,\n                                     &local_qiov, 0);\n            qemu_iovec_destroy(&local_qiov);\n            if (ret < 0) {\n                goto err;\n        cluster_offset += pnum;\n        cluster_bytes -= pnum;\n        progress += pnum - skip_bytes;\n        skip_bytes = 0;\n    ret = 0;\nerr:\n    qemu_vfree(bounce_buffer);\n    return ret;", "idx": 3398, "substitutes": {"child": ["cache", "fs", "bc", "Child", "sub", "GV", "code", "sec", "ssl", "core", "lib", "children", "ab", "root", "job", "queue", "buf", "conn", "pc", "fd", "parent", "server", "crypt", "c", "pool", "current", "ch", "block", "bin", "cl", "cur", "uc", "bid", "inner", "client", "bit", "cus"], "offset": ["phase", "part", "base", "loc", "shift", "initialized", "error", "padding", "outer", "optional", "reference", "o", "fp", "outing", "Offset", "location", "security", "enabled", "root", "alias", "config", "acl", "alpha", "entry", "fee", "reset", "count", "off", "slice", "end", "pos", "prefix", "starting", "position", "length", "slot", "uration", "initial", "url", "origin", "start", "layer", "info", "seed", "image", "annot", "align", "ip", "address", "set", "online", "size", "timeout", "pointer", "index"], "bytes": ["zip", "fs", "les", "pages", "binary", "seconds", "null", "values", "bits", "bps", "ips", "enabled", "items", "byte", " offsets", "errors", "blocks", "fee", "len", "count", "codes", "ops", "gz", "data", "css", "parent", "lines", "steps", "complete", "url", "es", "outs", "files", "eps", "resses", "Bytes", "address", "utils", "its", "ls", "bc", "pieces", "seq", "tes"], "qiov": [" qiop", "questionliv", "Qiov", " qliv", "qliv", "questioniov", " qregor", "Qiop", "Qliv", "questioniop", "qregor", "Qregor", "questionregor", "qiop"], "bs": ["banks", "bf", "fs", "las", "cases", "base", "BS", "ns", "bid", "settings", "cs", "pb", "bb", "sub", "plugins", "bes", "lib", "ubs", "bits", "bps", "ib", "ab", "ins", "obj", "bing", "blocks", "bn", "ba", "fb", "bos", "bot", "org", "boards", "bi", "eb", "css", "ps", "bal", "ses", "sb", "rs", "ks", "iss", "obs", "gb", "bh", "outs", "gs", "cb", "vs", "db", "b", "bin", "bel", "os", "bas", "js", "ss", "ls", "bl", "bc", "lb", "ds", "bis", "s"], "bounce_buffer": ["bounceedqueue", "battery_device", "bait_transfer", "bair_table", "bair64table", "bounce_table", "bounceedsize", "bounce_buf", "bouncetbuffer", "bair_buffer", "bounce_queue", "bounce_transfer", "bounce64table", "bounce_device", "bounceinguffer", "bounceingqueue", "battery_size", "bouncetheader", "bounces_buf", "bounce64queue", "bounceingtable", "bouncetsource", "bair64buffer", "bounce_uffer", "bait_buffer", "battery_queue", "batteryedbuffer", "bounce_source", "bair64queue", "bounce_size", "bounceingtransfer", "bounces_source", "bounce64buffer", "battery_buffer", "bounces_buffer", "bounceingbuffer", "bounceeddevice", "bounces_header", "bait_uffer", "batteryedqueue", "batteryedsize", "batteryeddevice", "bounce_header", "bouncetbuf", "bair_queue", "bounceedbuffer"], "drv": [" drf", "DRc", "hrb", "DRf", "hrf", " drV", "drc", "drf", "DRv", "DRb", "drb", "drV", "rrf", " drc", "hrV", " drb", "DRV", "rrb", "rrv", "rrc", "hrv"], "iov": ["imedia", "orde", "river", "gru", " cohort", "soc", "iro", "lov", "voice", "ominium", "ir", "io", "isco", "vre", "iii", "drm", "minecraft", "dyl", "ortex", "rx", "rov", "arrison", "orman", "rolet", "liv", "nox", "userc", "voc", "buf", "gio", "mus", "vg", "volt", "ressor", "iev", "\u00ef", "sbm", "roxy", "uno", "wikipedia", "obo", "coll", "dylib", "ilib", "output", "ibr", "oyer", "iasm", "club", "yout", "oc", "ibl", "wav", "ilo", "iris", "iop", "rob", "RF", "oren", "iol", "hw"], "local_qiov": ["local_piev", "local_piop", "local_quliv", "local_iqoyer", "local_giov", "local_giop", "local_quoyer", "local_quadliv", "local_qoyer", "local_yoyer", "local_gliv", "local_piov", "local_iqiop", "local_dqiop", "local_dqiov", "local_iqliv", "local_poyer", "local_dqoyer", "local_quadiop", "local_quadiev", "local_quiop", "local_yiop", "local_iqiov", "local_quiev", "local_yiov", "local_qiop", "local_quadiov", "local_qliv", "local_yiev", "local_qiev", "local_dqliv", "local_quiov", "local_dqiev", "local_goyer"], "cluster_offset": ["cluster0size", "clayerPoffset", "cluster67start", "cluster_part", "clusters_length", "cluster1offset", "clister_label", "cluster_position", "cluster1size", "clusters_location", "clusters_address", "clayerPalign", "claco_offset", "clusterappoffset", "cluster_align", "clusters_offset", "cluster_label", "cluster67offset", "cluster_length", "clusterPalign", "clister_offset", "cluster1position", "cluster1len", "clusterPoffset", "cluster_start", "clister67label", "clusterapplocation", "cluster_address", "cluster__offset", "claco_position", "clusterapplength", "clister_start", "cluster_location", "clayer_start", "cluster67label", "clister67offset", "clusters_position", "cluster__position", "clusterPlength", "clister_len", "clister67start", "clayer_length", "claco_part", "clayerPstart", "clusterPstart", "clusterappsize", "clayer_align", "cluster__size", "cluster0offset", "cluster__address", "clayerPlength", "cluster67len", "claco_start", "cluster_len", "cluster0length", "cluster0location", "cluster_size", "clayer_offset", "clister67len", "clusters_size"], "cluster_bytes": ["cliversity_pieces", "cliversity_length", "cluster__bits", "clusterMflows", "clorer_bytes", "clensus_bytes", "cluster__values", "clorersvalues", "clusterspages", "cluster8length", "cliversity_flows", "cluster_seconds", "cluster___stores", "clancer_bytes", "cliversity_bytes", "clusters_offset", "cluster67offset", "cluster_length", "clensus_units", "cluster_lines", "cluster___bytes", "cluster___offset", "clusteringlimits", "cliversityMpieces", "cluster2pieces", "cluster67bits", "clancer_stores", "clusters_bits", "clensus67bytes", "cliversityMbytes", "clusteringpages", "clusterMpieces", "cluster_bits", "clancer_size", "cluster__offset", "clusterslimits", "clensus67bits", "cluster__bytes", "cluster_values", "clustersbytes", "cluster8pieces", "clancer_offset", "cluster2length", "clusterMlength", "clensus_bits", "clustersvalues", "clusters_bytes", "cluster2bytes", "clorerslimits", "clusteringbytes", "cluster67units", "cluster8flows", "clusters_values", "cliversityMlength", "cluster8bytes", "cluster_flows", "cluster_limits", "cluster_units", "clorerspages", "clorer_pages", "cluster67values", "cluster2bits", "clensus67offset", "clorer_values", "cluster_stores", "clorersbytes", "clusterMbytes", "clusteringvalues", "cluster_size", "cluster_pieces", "clensus_offset", "cliversityMflows", "clorer_limits", "clensus67units", "cluster___size", "cluster67bytes", "cluster_pages"], "skip_bytes": ["skip_lines", "skip_files", "skipingseconds", "skip00lines", "skipingfiles", "skip00units", "skip_bits", "skipingbytes", " skip_bits", " skip_lines", "skip2seconds", "skip2size", " skip_units", "skip_seconds", "skip_resources", "skip2bytes", " skip_items", "skip_items", " skip_files", "skip_units", "skip00bytes", " skip_resources", " skip_seconds", "skip2bits", "skip_size", " skip_size", "skipingitems", "skip00resources"], "ret": ["cat", "bf", "val", "let", "rb", "res", "back", " RET", "error", "match", "att", "rc", "pet", "def", "rt", "code", " Ret", "num", "resp", "hash", "alt", "flag", "opt", "valid", "fin", "RET", "ref", "arr", "det", "fit", "gt", "rev", "id", "iter", "obj", "len", "count", "lit", "success", "rets", "feat", "reply", "mt", "fun", "nt", "reg", "url", "result", "Ret", "ft", "sat", "re", "out", "pass", "final", "bit", "try", "art"], "pnum": ["pnut", "pronumer", "pinum", "pinumber", "pronums", "panumb", "pnums", "rnumber", "panum", "cnumer", "rnUM", "pronumber", "bnum", "ennut", "pnuma", "pinom", "cnuma", "pronenum", "bnuma", "bnut", "pnummer", "rnumption", "cnum", "cnenum", "pnUM", "PNym", "cnumb", "pcums", "pronumb", "PNum", "ennum", "PNumber", "cnumption", "pnumb", "panumer", "PNumer", "PNom", "rnuma", "pnym", "rnumb", "ynumer", "pcum", "rnums", "pronum", "pronUM", "pnom", "PNumb", "panummer", "ynumber", "pnumer", "ennUM", "pnumber", "pnumption", "pnenum", "bnUM", "pcUM", "pinym", "rnom", "rnumer", "PNummer", "pronumption", "ynum", "rnum", "pronut", "rnenum", "rnummer", "pcenum", "ynuma", "ennuma", "pronuma", "rnym"]}}
{"project": "qemu", "commit_id": "2cbe2de5454cf9af44b620b2b40d56361a12a45f", "target": 1, "func": "static void virtio_scsi_device_unrealize(DeviceState *dev, Error **errp)\n{\n    virtio_scsi_common_unrealize(dev, errp);\n}", "idx": 3399, "substitutes": {"dev": ["serial", "av", "od", "attr", "inst", "error", "device", "def", "de", "grad", "img", "conf", "sh", "p", "d", "var", "cam", "pub", "ad", "prom", "pad", "bus", "pos", "conn", "prop", "data", "eth", "pro", "ev", "Dev", "fw", "devices", "gd", "di", "proc", "dem", "ver", "serv", "rad", "priv", "hw", "dom"], "errp": [" errps", "errr", "erps", "resultr", "erP", "errps", " Errfp", "errfp", "errP", "errlp", "erfp", " errlp", "resultp", "resultlp", " Errp", "erp", " errP", " Errps", " errr", "err", "erlp", " ErrP", "resultP", " errfp"]}}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static int protocol_client_init(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    char buf[1024];\n\n    VncShareMode mode;\n\n    int size;\n\n\n\n    mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE;\n\n    switch (vs->vd->share_policy) {\n\n    case VNC_SHARE_POLICY_IGNORE:\n\n        /*\n\n         * Ignore the shared flag.  Nothing to do here.\n\n         *\n\n         * Doesn't conform to the rfb spec but is traditional qemu\n\n         * behavior, thus left here as option for compatibility\n\n         * reasons.\n\n         */\n\n        break;\n\n    case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE:\n\n        /*\n\n         * Policy: Allow clients ask for exclusive access.\n\n         *\n\n         * Implementation: When a client asks for exclusive access,\n\n         * disconnect all others. Shared connects are allowed as long\n\n         * as no exclusive connection exists.\n\n         *\n\n         * This is how the rfb spec suggests to handle the shared flag.\n\n         */\n\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n            VncState *client;\n\n            QTAILQ_FOREACH(client, &vs->vd->clients, next) {\n\n                if (vs == client) {\n\n                    continue;\n\n                }\n\n                if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE &&\n\n                    client->share_mode != VNC_SHARE_MODE_SHARED) {\n\n                    continue;\n\n                }\n\n                vnc_disconnect_start(client);\n\n            }\n\n        }\n\n        if (mode == VNC_SHARE_MODE_SHARED) {\n\n            if (vs->vd->num_exclusive > 0) {\n\n                vnc_disconnect_start(vs);\n\n                return 0;\n\n            }\n\n        }\n\n        break;\n\n    case VNC_SHARE_POLICY_FORCE_SHARED:\n\n        /*\n\n         * Policy: Shared connects only.\n\n         * Implementation: Disallow clients asking for exclusive access.\n\n         *\n\n         * Useful for shared desktop sessions where you don't want\n\n         * someone forgetting to say -shared when running the vnc\n\n         * client disconnect everybody else.\n\n         */\n\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n            vnc_disconnect_start(vs);\n\n            return 0;\n\n        }\n\n        break;\n\n    }\n\n    vnc_set_share_mode(vs, mode);\n\n\n\n    vs->client_width = surface_width(vs->vd->ds);\n\n    vs->client_height = surface_height(vs->vd->ds);\n\n    vnc_write_u16(vs, vs->client_width);\n\n    vnc_write_u16(vs, vs->client_height);\n\n\n\n    pixel_format_message(vs);\n\n\n\n    if (qemu_name)\n\n        size = snprintf(buf, sizeof(buf), \"QEMU (%s)\", qemu_name);\n\n    else\n\n        size = snprintf(buf, sizeof(buf), \"QEMU\");\n\n\n\n    vnc_write_u32(vs, size);\n\n    vnc_write(vs, buf, size);\n\n    vnc_flush(vs);\n\n\n\n    vnc_client_cache_auth(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED);\n\n\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n\n\n\n    return 0;\n\n}\n", "idx": 3401, "substitutes": {"vs": ["va", "wp", "blogs", "v", "vr", "ves", "VS", "ps", "lines", "vals", "lv", "plugin", "views", "state", "os", "as", "js", "env", "iv", "docs", "points", "s", "vt", "manager", "sv", "qs", "vc", "values", "events", "Vs", "ins", "vm", "cv", "pos", "stats", "css", "vert", "sts", "utils", "sk", "ops", "plugins", "cas", "pg", "oss", "ports", "settings", "vid", "cs", "bs", "ov", "verts", "alls", "vers", "server", "ks", "spec", "es", "obs", "prev", "gs", "posts", "ver", "ss", "ls", "http", "ds", "xs", "fs", "las", "ils", "ms", "su", "ums", "ns", "nav", "otes", "vas", "services", "rs", "vp", "eps", "its", "versions"], "data": ["media", "next", "offset", "cache", "i", "text", "sample", "base", "Data", "array", "code", "uri", "values", "p", "input", "config", "dat", "queue", "buffer", "api", "load", "alpha", "memory", "a", "ata", "window", "parent", "batch", "vals", "body", "map", "result", "block", "state", "channel", "args", "DATA", "response", "ip", "da", "message", "reader", "entry"], "len": ["val", "all", "en", "ig", "byte", "z", " length", "vec", "Len", "pos", "length", "ix", " limit", "cap", "lic", "cl", "bl", "lf", "seq"], "buf": ["rb", "buff", "loc", "bp", "rc", "fi", "pb", "code", "bb", "img", "ctx", "bd", "header", "fp", "stack", "fl", "mem", " buffers", "ab", "ff", "va", "src", "bg", " buffer", "bridge", "queue", "buffer", "bed", "Buffer", " cmd", "vec", "ba", "fb", "pad", "bus", "cv", "fd", "Buff", "window", "batch", "uf", "port", "fw", "bag", "pool", "map", " b", "bh", "block", "ucc", "cap", "la", "nat", "cb", "b", "box", "que", "cmd", "wb", "uc", "bc", "bm", "seq", "br"], "mode": ["driver", "md", "phase", "role", "layout", "phrase", "key", "rage", "mo", "ase", " scheme", "plugin", "sym", "state", "message", "mod", "ui", "manager", "language", "de", "kind", "config", "name", "stage", "route", "mm", "activity", "owner", "mid", "map", "ace", "style", "side", "slave", "rule", "lock", "device", "code", "sid", "operation", "multi", "m", "status", "Mode", "definition", "slice", "member", "day", "me", "level", "effect", "ode", "gone", "use", "model", "mac", "scale", "grade", "command", "module", "token", " role", "id", "ward", "guide", "dim", "type", "direction", "MODE", " module", "none", "version", "range"], "size": ["offset", "ny", "loc", "scale", "sync", "en", "shift", "code", "unit", "number", "name", "z", "sum", "fee", "time", "capacity", "area", "count", "mini", "type", "member", "length", "ize", "shape", "weight", "speed", "small", "style", "large", "max", "storage", " sizes", "align", "address", "page", "empty", "iz", "message", "sized", "content", "Size", "SIZE"], "client": ["character", "user", "gu", "cache", "contact", "socket", "manager", "worker", "project", "secure", "container", "public", "close", "core", "reader", "cell", "command", "connection", "friend", "remote", "cli", "config", "session", "product", "api", "con", "consumer", "contract", "end", "conn", "pc", "service", "co", "window", "parent", "server", "port", "request", "current", "plugin", "image", "local", "channel", "state", "Client", "response", "player", "cmd", "custom", "cl", "ip", "resource", "child", "company", "open", "net", "ce", "source"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *src_x,\n\n                                                 const uint8_t *src_y,\n\n                                                 int32_t src_stride,\n\n                                                 uint8_t *dst,\n\n                                                 int32_t dst_stride)\n\n{\n\n    v16i8 src_hz0, src_hz1, src_hz2, src_hz3;\n\n    v16u8 dst0, dst1, dst2, dst3;\n\n    v16i8 src_vt0, src_vt1, src_vt2, src_vt3, src_vt4;\n\n    v16i8 src_vt5, src_vt6, src_vt7, src_vt8;\n\n    v16i8 mask0, mask1, mask2;\n\n    v8i16 hz_out0, hz_out1, vert_out0, vert_out1;\n\n    v8i16 res0, res1;\n\n    v16u8 res;\n\n\n\n    LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2);\n\n    LD_SB5(src_y, src_stride, src_vt0, src_vt1, src_vt2, src_vt3, src_vt4);\n\n    src_y += (5 * src_stride);\n\n\n\n    src_vt0 = (v16i8) __msa_insve_w((v4i32) src_vt0, 1, (v4i32) src_vt1);\n\n    src_vt1 = (v16i8) __msa_insve_w((v4i32) src_vt1, 1, (v4i32) src_vt2);\n\n    src_vt2 = (v16i8) __msa_insve_w((v4i32) src_vt2, 1, (v4i32) src_vt3);\n\n    src_vt3 = (v16i8) __msa_insve_w((v4i32) src_vt3, 1, (v4i32) src_vt4);\n\n\n\n    XORI_B4_128_SB(src_vt0, src_vt1, src_vt2, src_vt3);\n\n    LD_SB4(src_x, src_stride, src_hz0, src_hz1, src_hz2, src_hz3);\n\n    LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3);\n\n    XORI_B4_128_SB(src_hz0, src_hz1, src_hz2, src_hz3);\n\n    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz0, src_hz1,\n\n                                                          mask0, mask1, mask2);\n\n    hz_out1 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz2, src_hz3,\n\n                                                          mask0, mask1, mask2);\n\n    SRARI_H2_SH(hz_out0, hz_out1, 5);\n\n    SAT_SH2_SH(hz_out0, hz_out1, 7);\n\n    LD_SB4(src_y, src_stride, src_vt5, src_vt6, src_vt7, src_vt8);\n\n\n\n    src_vt4 = (v16i8) __msa_insve_w((v4i32) src_vt4, 1, (v4i32) src_vt5);\n\n    src_vt5 = (v16i8) __msa_insve_w((v4i32) src_vt5, 1, (v4i32) src_vt6);\n\n    src_vt6 = (v16i8) __msa_insve_w((v4i32) src_vt6, 1, (v4i32) src_vt7);\n\n    src_vt7 = (v16i8) __msa_insve_w((v4i32) src_vt7, 1, (v4i32) src_vt8);\n\n\n\n    XORI_B4_128_SB(src_vt4, src_vt5, src_vt6, src_vt7);\n\n\n\n    /* filter calc */\n\n    vert_out0 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt0, src_vt1, src_vt2,\n\n                                                  src_vt3, src_vt4, src_vt5);\n\n    vert_out1 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt2, src_vt3, src_vt4,\n\n                                                  src_vt5, src_vt6, src_vt7);\n\n    SRARI_H2_SH(vert_out0, vert_out1, 5);\n\n    SAT_SH2_SH(vert_out0, vert_out1, 7);\n\n\n\n    res1 = __msa_srari_h((hz_out1 + vert_out1), 1);\n\n    res0 = __msa_srari_h((hz_out0 + vert_out0), 1);\n\n\n\n    SAT_SH2_SH(res0, res1, 7);\n\n    res = PCKEV_XORI128_UB(res0, res1);\n\n\n\n    dst0 = (v16u8) __msa_insve_w((v4i32) dst0, 1, (v4i32) dst1);\n\n    dst1 = (v16u8) __msa_insve_w((v4i32) dst2, 1, (v4i32) dst3);\n\n    dst0 = (v16u8) __msa_insve_d((v2i64) dst0, 1, (v2i64) dst1);\n\n    dst0 = __msa_aver_u_b(res, dst0);\n\n\n\n    ST4x4_UB(dst0, dst0, 0, 1, 2, 3, dst, dst_stride);\n\n}\n", "idx": 3416, "substitutes": {"src_x": [" src_w", " src_h", "src64y", "src_w", "src64h", "src64w", "src64x", "src_h"], "src_y": ["src_cy", "src_ya", " src_cy", " src_xy", "source_xy", "source_Y", "source_vy", " src_ya", "src_vy", "source_y", "src_xy", "src_Y"], "src_stride": ["src_Stride", "src_stide", "src_striider", "src_StrIDE", "src_bride", "src_frided", "src_trided", "src_brade", "src_fride", "src_rade", "src_frIDE", "src_strade", "src_striide", "src_brider", "src_frade", "src_stIDE", "src_strided", "src_rided", "src_stided", "src_strider", "src_striride", "src_stade", "src_rride", "src_Strade", "src_brided", "src_striided", "src_ride", "src_brride", "src_strIDE", "src_trride", "src_tride", "src_strride", "src_trider", "src_Strided"], "dst": ["dsts", "adst", "dest", " dest", "Dest", "adsts", "Dsts", "Dsp", "adest", " dsp", " dsts", "Dst", "adsp", "dsp"], "dst_stride": ["dst_trided", "dst_strride", "dst_stide", "dst_strided", "dst_octided", "dst_stided", "dst_trride", "dst_octride", "dst_strider", "dst_octide", "dst_tride", "dst_trider", "dst_octider", "dst_stider"], "src_hz0": ["src_hw1", "src_cz1", "src_cz0", "src_hm0", "src_hz8", "src_cz2", "src_hm1", "src_hm8", "src_cz8", "src_hw2", "src_hw8", "src_hw0", "src_hm2"], "src_hz1": ["src_cz9", "src_hzone", "src_cz1", "src_ht2", "src_volt9", "src_ht1", "src_cz2", "src_htone", "src_voltone", "src_hz9", "src_volt2", "src_ht9", "src_volt1", "src_czone"], "src_hz2": ["src_frequency4", "src_cz1", "src_z32", "src_cz2", "src_frequency1", "src_frequency2", "src_z2", "src_hz4", "src_cz4", "src_frequency32", "src_hz32", "src_z4", "src_z1", "src_cz32"], "src_hz3": ["src_cz9", "src_frequency9", "src_cz1", "src_z3", "src_cz2", "src_frequency1", "src_hz9", "src_frequency3", "src_z9", "src_frequency2", "src_z2", "src_z1", "src_cz3"], "dst0": ["dsp6", "dsc2", " dsc6", " dst10", "dst6", "dsts10", " dst6", "dsp2", "dsts0", "dsc10", "dsts2", "dsts6", " dsc10", " dsc2", " dsc0", "dsp10", "dsc6", "dst10", "dsp0", "dsc0"], "dst1": ["dsc61", "dest2", " dest1", "dest1", "dsts1", " dst61", "dsts2", "dsts61", "dest61", "dst61", " dest61", "dsc2", " dest2", "dsc1"], "dst2": ["dost02", "dst02", "dest2", " dest0", " dest1", "dest02", "dest1", " dst02", "dost2", "dost1", " dest02", "dost0", "dsc02", "dsc2", "dest0", " dest2", "dsc1", "dsc0"], "dst3": [" dst5", " dest63", "dft3", "dsts3", " dest1", "dsts63", "dest1", "dsts1", "dst5", "dft1", "dest3", "dest5", "dsts5", "dft5", " dest3", "dst63", "dft63", " dst63", "dest63", " dest5"], "src_vt0": ["src_ft0", "src_wt3", "src_ft2", "src_VT0", "src_wt0", "src_pt1", "src_wt2", "src_ft3", "src_vp2", "src_ft48", "src_rt48", "src_ft5", "src_rt1", "src_vt48", "src_rt3", "src_ft1", "src_ft8", "src_rt0", "src_wt1", "src_pt0", "src_rt2", "src_vp0", "src_ret6", "src_ret1", "src_VT8", "src_VT1", "src_pt2", "src_vp1", "src_VT2", "src_wt6", "src_rt5", "src_rt6", "src_ret2", "src_rt8", "src_pt5", "src_ret0", "src_vp48"], "src_vt1": ["src_ft0", "src_gt3", "src_ht1", "src_v1", "src_ft5", "src_rt3", "src_v2", "src_ht3", "src_rt2", "src_vt32", "src_gt1", "src_pt5", "src_ft2", "src_pt1", "src_vc3", "src_ft3", "src_rt32", "src_ht2", "src_gt0", "src_ht7", "src_wt1", "src_ft7", "src_ft32", "src_fif0", "src_pt3", "src_fifart", "src_wt0", "src_gt2", "src_vtart", "src_ft1", "src_rt0", "src_dt2", "src_rt4", "src_v7", "src_wtart", "src_ftart", "src_gt4", "src_dt0", "src_vc1", "src_ht4", "src_rt1", "src_vc5", "src_fif1", "src_vc2", "src_dt1", "src_pt2", "src_dt32"], "src_vt2": ["src_ft0", "src_gt3", "src_vt20", "src_ht1", "src_rt3", "src_ht3", "src_rt2", "src_vt32", "src_mt1", "src_vt02", " src_\n", "src_gt1", "src_ft2", "src_pt1", "src_mt2", "src_rt32", "src_ht2", "src_pt4", "src_mt6", "src_vet20", "src_wt1", "src_vet2", "src_0", "src_ft32", "src_rt20", "src_ft4", " src_8", "src_wt6", "src_gt5", "src_wt0", " src_2", "src_gt2", "src_ft6", "src_pt32", "src_2", "src_mt0", "src_vet4", "src_ft1", "src_\n", "src_ht02", "src_rt4", "src_vet1", "src_ht5", "src_rt5", " src \n", "src_ft20", "src_8", "src_gt4", " src_0", "src_rt02", "src_wt2", "src_ht4", "src \n", "src_gt02", "src_rt1", "src_pt2"], "src_vt3": ["src_vtd", "src_vr3", "src_vr1", "src_htthree", "src_ht1", "src_irtthree", "src_rt3", "src_ht3", "src_rt2", "src_vp34", "src_vr2", "src_ftthree", "src_ft2", "src_pt1", "src_vt34", "src_ft3", "src_ht2", "src_ftd", "src_rt34", "src_wt1", "src_htd", "src_irt2", "src_pt25", "src_pt3", "src_vp3", "src_vp4", "src_irt1", "src_wt25", "src_vp25", "src_ft1", "src_rt4", "src_vrd", "src_wt3", "src_vt25", "src_wt2", "src_ht4", "src_vp2", "src_rt1", "src_pt2", "src_vtthree", "src_vp1", "src_ht34", "src_irt3"], "src_vt4": ["src_ft2", "src_gt4", "src_wt5", "src_wt2", "src_gt2", "src_ft6", "src_rt1", "src_wt4", "src_ft1", "src_wt1", "src_rt2", "src_rt4", "src_ft4", "src_gt1", "src_wt6", "src_rt5", "src_gt5", "src_rt6"], "src_vt5": ["src_ft0", "src_ft2", "src_ht2", "src_ht1", "src_ft5", "src_rt1", "src_ft1", "src_rt0", "src_rt2", "src_ht5", "src_ht0", "src_rt5"], "src_vt6": ["src_ht4", "src_wt2", "src_ht2", "src_wt4", "src_rt2", "src_rt4", "src_ht8", "src_wt8", "src_ht6", "src_wt6", "src_rt6", "src_rt8"], "src_vt7": ["src_irt1", "src_irt8", "src_irt7", "src_ht1", "src_wt7", "src_ht7", "src_wt1", "src_ht17", "src_vt17", "src_ht8", "src_wt8", "src_irt17", "src_wt17"], "src_vt8": ["src_gt4", "src_ft6", "src_ft5", "src_ft8", "src_rt4", "src_gt8", "src_gt6", "src_ft4", "src_gt5", "src_rt5", "src_rt6", "src_rt8"], "mask0": ["sum0", "sum1", " mask50", "ask1", "mask3", "sum2", "mask50", "ask3", "weight0", "ask0", "ask2", "weight3", " mask3", "weight2", "weight1", "sum50", "weight50"], "mask1": ["mark1", "ask1", "pass2", "mask3", "mask5", "ask8", "ask3", "pass1", "pass5", " mask5", "mark2", " mask8", "ask2", "mask8", "ask5", "pass3", " mask3", "mark8"], "mask2": ["lock5", "lock0", "mask4", "mask5", "lock8", "mark4", "ask8", "lock2", "mark5", "ask4", " mask5", "ask0", "mark2", " mask8", " mask4", "ask2", "mask8", "ask5", "mark8"], "hz_out0": ["hz_int1", "hz_outee", "hz_maskee", "hz_inee", "hz_mask0", "hz_in1", "hz_int0", "hz_intee", "hz_mask1", "hz_in0"], "hz_out1": ["hz_bitone", "hz_inOne", "hz_outone", "hz_inone", "hz_in1", "hz_off1", "hz_outOne", "hz_bit1", "hz_bitOne", "hz_offOne", "hz_offone"], "vert_out0": ["vert_masked", "vert_ined", "vert_mask0", "vert_in3", "vert_mask1", "vert_bit1", "vert_mask3", "vert_in0", "vert_bit3", "vert_bit0", "vert_out3", "vert_outed", "vert_in1", "vert_bited"], "vert_out1": ["vert_Out1", "vert_maskOne", "vert_Out2", "vert_in2", "vert_mask2", "vert_OutOne", "vert_inOne", "vert_Out3", "vert_outOne", "vert_in3", "vert_mask1", "vert_mask3", "vert_out3", "vert_out2", "vert_in1"], "res0": ["resolution2", "Res0", "Res2", "res8", "resolution0", "rem8", "res2", "rem0", "rem2", "Res8", "resolution8"], "res1": ["rem1", "resolution2", "Res2", "res3", "Res1", "Res3", "res2", "rem2", "resolution3", "resolution1", "rem3"], "res": ["rep", "mask", "fs", "gr", "ms", "req", "bits", "rows", "rev", "blocks", "resolution", "rss", "ress", "Res", "ps", "rs", "RES", "reg", "vals", "depth", "pres", "rel", "ver", "resh", "re", "vers", "rem"]}}
{"project": "qemu", "commit_id": "a27365265cc2fed1178bf25a205e8ee02a9c0caf", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,\n\n                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n                         BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,\n\n                       cb, opaque, QEMU_AIO_READ);\n\n}\n", "idx": 3440, "substitutes": {"bs": ["las", "fs", "base", "BS", "ns", "cs", "pb", "fps", "bb", "bes", "ssl", "qs", "ubs", "bits", "ab", "obj", "blocks", "sa", "bos", "fb", "ps", "ses", "ks", "iss", "sb", "obs", "state", "vs", "b", "os", "as", "bas", "ss", "js", "ls", "bis", "bc", "lb", "ds", "bl", "sync"], "sector_num": ["sector0nom", "sector_name", "sector_number", "sector0number", " sector_number", "sector0name", "sector_Num", " sector_Num", " sector_name", "sector_nom", " sector_nom", "sector0num"], "qiov": ["eqiris", " qicho", "eqiov", "Qiris", "quilo", "eqovi", "qqdyl", "Qicho", "qovi", "qqicho", " qovi", "Qiov", "qilo", "eqicho", "qudyl", "qqilo", " qdyl", "qdyl", " qilo", "qicho", "qiris", "qqiov", "quiov", "quicho", "Qovi", " qiris"], "nb_sectors": ["nb_seators", "nb_sections", "nb_secgments", "nb_segments", "nb_veivers", "nb_sergments", "nb_separators", "nb_seivers", "nb_pectors", "nb_secctions", "nb_serivers", "nb_vegments", "nb_pections", "nb_secctors", "nb_sector", "nb_serctors", "nb_separivers", "nb_vectors", "nb_separctors", "nb_pegments", "nb_vections", "nb_serators", "nb_vector", "nb_secctor", "nb_separgments", "nb_veators", "nb_pector"], "cb": ["fn", "bf", "rb", "cc", "buff", "cf", "fc", "cs", "pb", "bb", "ctx", "function", "code", "orb", "fp", "ec", "Callback", "fee", "fb", "abc", "unc", "cv", "func", "pc", "eb", "callback", "fun", "c", "sb", "ctrl", "ob", "db", "b", "f", "bc", "cd", "CB"], "opaque": ["opac", "operbc", "pbc", "OPc", " opac", "hopaques", "obc", "opbc", "OPacity", " opbc", "pacity", "opace", "OPaques", "pac", "obaque", "OPace", "operc", " opaques", "operacity", " opacity", "opaques", "paque", "operace", "opc", "OPaque", "opacity", "hopaque", "hopacity", "obacity", "operac", "operaque", "obace"], "s": ["S", "fs", "socket", "su", "sv", "ns", "cs", "si", "is", "ssl", "o", "p", "http", "src", "sq", "session", "sa", "services", "stats", "states", "service", "sys", "ps", "ses", "secondary", "sb", "c", "self", "gs", "b", "os", "storage", "ss", "e", "ops", "ds"]}}
{"project": "qemu", "commit_id": "973945804d95878375b487c0c5c9b2556c5e4543", "target": 0, "func": "static void tcx_blit_writel(void *opaque, hwaddr addr,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    TCXState *s = opaque;\n\n    uint32_t adsr, len;\n\n    int i;\n\n\n\n    if (!(addr & 4)) {\n\n        s->tmpblit = val;\n\n    } else {\n\n        addr = (addr >> 3) & 0xfffff;\n\n        adsr = val & 0xffffff;\n\n        len = ((val >> 24) & 0x1f) + 1;\n\n        if (adsr == 0xffffff) {\n\n            memset(&s->vram[addr], s->tmpblit, len);\n\n            if (s->depth == 24) {\n\n                val = s->tmpblit & 0xffffff;\n\n                val = cpu_to_be32(val);\n\n                for (i = 0; i < len; i++) {\n\n                    s->vram24[addr + i] = val;\n\n                }\n\n            }\n\n        } else {\n\n            memcpy(&s->vram[addr], &s->vram[adsr], len);\n\n            if (s->depth == 24) {\n\n                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);\n\n            }\n\n        }\n\n        memory_region_set_dirty(&s->vram_mem, addr, len);\n\n    }\n\n}\n", "idx": 3449, "substitutes": {"opaque": ["opac", "iopaque", "copacle", "ovaques", "iopacity", "copacity", "opque", " opque", "iopac", "copac", "copaques", "oaques", "copque", "ovacity", " opacity", "opaques", "iopque", "ovacle", "oacle", "oaque", "opacle", "oacity", "ovaque", "opacity", "copaque", " opac"], "addr": ["md", "rr", "req", "hop", "cmp", "ord", "grad", "enc", "intel", "alt", "ref", "alias", "usr", "nn", "adder", "afi", "layer", "anne", "nick", "coord", "env", "host", "ac", "p", "ha", "ino", "node", "ind", "config", "name", "buf", "amd", "ad", "route", "mode", "pos", "el", "data", "enh", "url", "ace", "fx", "pointer", "h", "offset", "ost", "base", "r", "en", "ptr", "ack", "code", "sid", "kk", "act", "dr", "acl", "sta", "pad", "conn", "pc", "ar", "cmd", "amp", "ip", "address", "ady", "index", "loc", "attr", "rc", "padding", "rt", "arr", "src", "adr", "edge", "id", "aa", "frame", "arm", "ea", "work", "np", "asm", "oa", "inter", "align", "x", "lvl", "order"], "val": ["eval", "cal", "all", "value", "ival", "base", "loc", "def", "l", "fi", "enc", "rt", "elt", "sel", "p", "valid", "Val", "pt", "arr", "ref", "mem", "fl", "key", "ind", "aval", "var", "ret", "buf", "vol", "ol", "count", "v", "am", "pos", "el", "x", "py", "li", "data", "end", "slot", "il", "bal", "vals", "reg", "pre", "block", "tx", "la", "VAL", "al", "arg", "db", "b", "f", "serv", "sl", "bl", "it", "seq"], "size": ["eval", " err", "value", "padding", "ctx", " pri", " data", " arg", "mem", " length", "v", "pos", " el", "data", "length", " pos", "vals", " iv", "VAL", "al", " ret"], "s": ["S", "fs", "parts", "ms", "r", "ts", "ns", "l", "settings", "cs", "si", "is", "uns", "n", "conf", "ssl", "o", "y", "p", "new", "ins", "m", "sq", "session", "rows", "w", "v", "services", "a", "sie", "sys", "service", "g", "states", "your", "ps", "us", "ses", "spec", "c", "sb", "rs", "es", "self", "site", "ks", "secondary", "gs", "sym", "state", "args", "hs", "t", "os", "b", "sg", "f", "as", "aws", "this", "ss", "js", "e", "sl", "ls", "side", "ds", "sync"], "adsr": ["aidrr", "adescr", "assesp", "adsnr", "artsrf", "assesnr", "acksrt", "ansrr", "adesrt", "psrt", "adsrf", "adsrd", "psrr", "edsrr", "artsrr", "ddrr", "assesrr", "andsr", "adesp", "adesrr", "assesr", "andsdr", "aidrt", " adsdr", " adsrt", "ansrt", "edsrf", "adsdr", "assesdr", "ddcr", "aidpr", "Adr", "Adcr", "adsp", "artsrd", "adscr", "acksr", "Adrf", "adspr", "adsrt", "edsr", "ksrd", "ddrf", "ksr", "acksrr", "acksp", " adsnr", "artsr", "ansr", "aidr", "ddr", "assesrt", "adesr", "anspr", "ksrr", "ksrf", "andsnr", "andsrt", "edsrd", "adesrf", "psr", "Adrr", "adsrr", "pspr"], "len": ["fn", "line", "part", "base", "loc", "l", "gen", "un", "lt", "lon", "lim", "dl", "n", "lib", "le", "lin", "seq", "fin", "lang", "mem", "fl", "ind", "led", "name", "limit", "ln", "ellen", "id", "z", "dy", "ld", "dim", "count", "Len", "lit", "end", "pos", "el", "li", "ann", "den", "lan", "sp", "ie", "length", "il", "fun", "in", "ll", "lf", "la", "rel", "f", "ni", "sl", "ls", "e", "lif", "lvl", "lc", "en"], "i": ["hi", "ui", "base", "l", "is", "code", "j", "n", "si", "uri", "o", "p", "ci", "uni", "qi", "ind", "eni", "d", "oi", "z", "id", "I", "ori", "ri", "mi", "adi", "k", "ii", "ini", "v", "a", "pos", "bi", "li", "il", "c", "in", "zi", "start", "ix", "ai", "di", "vi", "pi", "gi", "f", "u", "b", "ti", "ip", "ni", "e", "xi", "x", "it", "phi", "en", "index"]}}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *data_cb_or_cr,\n\n                                                       uint8_t alpha_in,\n\n                                                       uint8_t beta_in,\n\n                                                       uint32_t img_width)\n\n{\n\n    uint16_t out0, out1, out2, out3;\n\n    v8i16 tmp1;\n\n    v16u8 alpha, beta, is_less_than;\n\n    v8i16 p0_or_q0, q0_or_p0;\n\n    v16u8 p1_or_q1_org, p0_or_q0_org, q0_or_p0_org, q1_or_p1_org;\n\n    v16i8 zero = { 0 };\n\n    v16u8 p0_asub_q0, p1_asub_p0, q1_asub_q0;\n\n    v16u8 is_less_than_alpha, is_less_than_beta;\n\n    v8i16 p1_org_r, p0_org_r, q0_org_r, q1_org_r;\n\n\n\n    {\n\n        v16u8 row0, row1, row2, row3, row4, row5, row6, row7;\n\n\n\n        LOAD_8VECS_UB((data_cb_or_cr - 2), img_width,\n\n                      row0, row1, row2, row3, row4, row5, row6, row7);\n\n\n\n        TRANSPOSE8x4_B_UB(row0, row1, row2, row3, row4, row5, row6, row7,\n\n                          p1_or_q1_org, p0_or_q0_org,\n\n                          q0_or_p0_org, q1_or_p1_org);\n\n    }\n\n\n\n    alpha = (v16u8) __msa_fill_b(alpha_in);\n\n    beta = (v16u8) __msa_fill_b(beta_in);\n\n\n\n    p0_asub_q0 = __msa_asub_u_b(p0_or_q0_org, q0_or_p0_org);\n\n    p1_asub_p0 = __msa_asub_u_b(p1_or_q1_org, p0_or_q0_org);\n\n    q1_asub_q0 = __msa_asub_u_b(q1_or_p1_org, q0_or_p0_org);\n\n\n\n    is_less_than_alpha = (p0_asub_q0 < alpha);\n\n    is_less_than_beta = (p1_asub_p0 < beta);\n\n    is_less_than = is_less_than_beta & is_less_than_alpha;\n\n    is_less_than_beta = (q1_asub_q0 < beta);\n\n    is_less_than = is_less_than_beta & is_less_than;\n\n\n\n    is_less_than = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) is_less_than);\n\n\n\n    if (!__msa_test_bz_v(is_less_than)) {\n\n        p1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p1_or_q1_org);\n\n        p0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p0_or_q0_org);\n\n        q0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q0_or_p0_org);\n\n        q1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q1_or_p1_org);\n\n\n\n        AVC_LOOP_FILTER_P0_OR_Q0(p0_org_r, q1_org_r, p1_org_r, p0_or_q0);\n\n        AVC_LOOP_FILTER_P0_OR_Q0(q0_org_r, p1_org_r, q1_org_r, q0_or_p0);\n\n\n\n        /* convert 16 bit output into 8 bit output */\n\n        p0_or_q0 = (v8i16) __msa_pckev_b(zero, (v16i8) p0_or_q0);\n\n        q0_or_p0 = (v8i16) __msa_pckev_b(zero, (v16i8) q0_or_p0);\n\n\n\n        p0_or_q0_org =\n\n            __msa_bmnz_v(p0_or_q0_org, (v16u8) p0_or_q0, is_less_than);\n\n        q0_or_p0_org =\n\n            __msa_bmnz_v(q0_or_p0_org, (v16u8) q0_or_p0, is_less_than);\n\n\n\n        tmp1 = (v8i16) __msa_ilvr_b((v16i8) q0_or_p0_org, (v16i8) p0_or_q0_org);\n\n\n\n        data_cb_or_cr -= 1;\n\n\n\n        out0 = __msa_copy_u_h(tmp1, 0);\n\n        out1 = __msa_copy_u_h(tmp1, 1);\n\n        out2 = __msa_copy_u_h(tmp1, 2);\n\n        out3 = __msa_copy_u_h(tmp1, 3);\n\n\n\n        STORE_HWORD(data_cb_or_cr, out0);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out1);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out2);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out3);\n\n        data_cb_or_cr += img_width;\n\n\n\n        out0 = __msa_copy_u_h(tmp1, 4);\n\n        out1 = __msa_copy_u_h(tmp1, 5);\n\n        out2 = __msa_copy_u_h(tmp1, 6);\n\n        out3 = __msa_copy_u_h(tmp1, 7);\n\n\n\n        STORE_HWORD(data_cb_or_cr, out0);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out1);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out2);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out3);\n\n    }\n\n}\n", "idx": 3452, "substitutes": {"data_cb_or_cr": ["data_cb_orjCR", "data_cb_nor_ca", "data_cb_or_cd", "data_cb_nor_CR", "data_cb_or_ca", "data_cb_or_cm", "data_cb_orjcm", "data_cb_orjca", "data_cb_nor_cm", "data_cb_nor_cr", "data_cb_or_Cr", "data_cb_or_CR", "data_cb_orjcr"], "alpha_in": ["alpha_ins", "alpha_out", "pha_login", "pha_ins", " alpha_bin", "alpha_login", "pha_in", " alpha_ins", "pha_out", " alpha_out", "alpha_bin"], "beta_in": ["phi_string", "beta__in", "phi_inc", "betaJstring", "beta_ins", " beta_IN", "betaJin", "phiJstring", "beta__inc", "phi_in", "beta__again", "beta_internal", " beta_internal", "beta_again", "phi_again", "betaJagain", "beta_IN", "beta_inc", "phiJagain", "beta_string", "phiJinc", " beta_ins", "phiJin", "beta__string", "betaJinc"], "img_width": ["imgallcount", "img_name", "image_width", "imgallwidth", "img2length", "imgfcount", "imgflength", "img2weight", "img_Width", "image2name", "image2count", "image_size", "img_count", "img2count", "imgfname", "img_weight", "image2length", "img2size", "image_Width", "img2name", "image2width", "img2Width", "img2width", "image_weight", "image_count", "img_length", "image_name", "image_length", "imgallname", "imgfwidth", "imgalllength", "img_size"], "out0": ["in5", "in0", "in2", "diff5", "diff0", " out5", "out5", "diff2"], "out1": ["out8", "block8", " out8", "in01", "block01", "block1", " out01", "out01", "in8", "in1"], "out2": ["in0", "out8", "in2", " out8", "input8", "in8", "input0", "input2"], "out3": ["in03", "in5", "output03", "in3", "out03", "output5", "output3", "inThree", "input03", "outThree", "outputThree", "out5", "input5", "inputThree", "input3"], "tmp1": ["qq1", "tmp11", "jp7", "qq11", "tmpOne", "qq7", "proc11", "proc1", "jp1", "proc7", "jpOne", "qqOne", "procOne", "tmp7", "jp11"], "alpha": ["i", "scale", "error", "ac", "padding", "ta", "lambda", "ana", "p", "Alpha", "alias", "A", "average", "acl", "api", "ma", "sa", "area", " gamma", "asc", "aa", "a", " Alpha", "ca", "data", "pha", "\u03b1", "margin", "weight", "init", "mu", "la", "meta", "inc", "ra", "amp", "da", "Beta", "extra", "phi", "params", "upper"], "beta": ["offset", "error", "mega", "sub", "padding", "ta", "si", "binary", "lambda", "unit", "bb", "uca", " \u03b2", "tmp", "gas", "term", "fee", "ba", "qa", "ii", "aa", "bi", "output", "\u03b1", "margin", "balance", "una", "abi", "b", "\u03b2", "negative", "pa", "Beta", "extra", "phi", "lc", "params"], "is_less_than": ["is_more_per", "is_more_with", "is_less_per", "is_less___per", "is_less_with", "is_less___than", "is_less___with", "is_more_than"], "p0_or_q0": ["p0_or_p1", "p0_or_Q1", "p0_or_q1", "p0_or_r1", "p0_or_r0", "p0_or_Q0", "p0_or_p90", "p0_or_q90", "p0_or_p0", "p0_or_Q90", "p0_or_r90"], "q0_or_p0": ["q0_or_p5", "q0_or_p2", "q0_or_w0", "q0_or_P1", "q0_or_P2", "q0_or_P5", "q0_or_w2", "q0_or_P0", "q0_or_q1", "q0_or_p1", "q0_or_q0", "q0_or_w5", "q0_or_q5", "q0_or_q2", "q0_or_w1"], "p1_or_q1_org": ["p1_or_q0_orb", "p1_or_q1sorg", "p1_or_q1_reg", "p1_or_q0_reg", "p1_or_q1_com", "p1_or_q1sorb", "p1_or_q0_org", "p1_or_q1scom", "p1_or_q0_com", "p1_or_q1_orb"], "p0_or_q0_org": ["p0_or_q0_reg", "p0_or_q1_reg", "p0_or_q0rcom", "p0_or_q1_com", "p0_or_q0rorg", "p0_or_q0rreg", "p0_or_q1_org", "p0_or_q1_or", "p0_or_q0_com", "p0_or_q0_or"], "q0_or_p0_org": ["q0_or_p0_orm", "q0_or_p0__or", "q0_or_p1_com", "q0_or_p0__org", "q0_or_p0__reg", "q0_or_p1_reg", "q0_or_p0_com", "q0_or_p0_or", "q0_or_p1_orm", "q0_or_p0_reg", "q0_or_p1_or", "q0_or_p1_org", "q0_or_p0__com"], "q1_or_p1_org": ["q1_or_p1_reg", "q1_or_p0_org", "q1_or_p167org", "q1_or_p1_Org", "q1_or_p0_orb", "q1_or_p0_Org", "q1_or_p167orb", "q1_or_p0_reg", "q1_or_p167Org", "q1_or_p1_orb"], "p0_asub_q0": ["p0_asub_f1", "p0_asub_q2", "p0_asub_p1", "p0_asub_f2", "p0_asub_pee", "p0_asub_r0", "p0_asub_Q2", "p0_asub_r1", "p0_asub_q1", "p0_asub_p2", "p0_asub_r2", "p0_asub_Q0", "p0_asub_p0", "p0_asub_ree", "p0_asub_Q1", "p0_asub_f0", "p0_asub_qee", "p0_asub_fee", "p0_asub_Qee"], "p1_asub_p0": ["p1_asub_p2", "p1_asub_P1", "p1_asub_qk", "p1_asub_c4", "p1_asub_q1", "p1_asub_ck", "p1_asub_Pk", "p1_asub_c2", "p1_asub_P0", "p1_asub_P4", "p1_asub_c0", "p1_asub_q2", "p1_asub_q0", "p1_asub_P2", "p1_asub_p4", "p1_asub_pk", "p1_asub_p1", "p1_asub_q4", "p1_asub_c1"], "q1_asub_q0": ["q1_asub_b1", "q1_asub_c00", "q1_asub_q4", "q1_asub_q00", "q1_asub_p1", "q1_asub_c0", "q1_asub_p0", "q1_asub_c1", "q1_asub_p00", "q1_asub_q1", "q1_asub_b00", "q1_asub_c4", "q1_asub_b4", "q1_asub_p4", "q1_asub_b0"], "is_less_than_alpha": ["is_less_than_inc", "is_less_than_Alpha"], "is_less_than_beta": ["is_less_than___0", "is_less_than_0", "is_less_than_Beta", "is_less_than___beta", "is_less_than___alpha", "is_less_than___Beta"], "p1_org_r": ["p1_or_or", "p1_or_r", "p1_org_rs", "p1_or_ru", "p1_org_or", "p1_org_ru", "p1_or_rs"], "p0_org_r": ["p0_gov_rs", "p0_org_lr", "p0_org_rb", "p0_gov_lr", "p0_gov_rb", "p0_org_rs", "p0_org__rb", "p0_org__rs", "p0_gov_r", "p0_org__r", "p0_org__lr"], "q0_org_r": ["q0_orgrictr", "q0_org_dr", "q0_orgrictroot", "q0_org_root", "q0_orgianroot", "q0_orgiandr", "q0_orgrictdr", "q0_or_root", "q0_or_r", "q0_or_dr", "q0_orgianr"], "q1_org_r": ["q1_org_rs", "q1_or_rb", "q1_or_rs", "q1_org_rb", "q1_or_nr", "q1_or_r", "q1_org_nr"], "row0": ["ro0", "rowsE", "row000", "roundE", "col80", "ro80", "port0", "round2", "raw50", "raw8", " row8", " rowE", "rows000", "ow0", " row000", "ow50", "row80", " row50", "round0", "ow8", "round000", "ow6", "ro5", "raw0", "port80", "col0", "row8", "rows2", "port5", "col5", "rows0", "raw6", "rowE", "row50"], "row1": ["ow4", " row11", "ow2", "rows1", "ow11", "rows11", " row100", "rank100", "ow0", "r100", "r1", "r5", "r2", "rows3", "rank1", "row11", "rank5", "row100", "rows2", "rows0", "ow1", "rows4", "ow3", "rank2"], "row2": ["ward5", "ward4", "ow2", "post5", "col1", "post1", "block62", "block2", "block4", "ow62", "block6", "ward6", "rw2", "rw62", "post4", "col4", "rw3", "ward2", "ow5", "col2", "col5", "row62", "block5", "rw5", "post2", "ow3", "block3"], "row3": ["ow4", "view3", "raw3", "ow53", "row53", "ow03", "row03", " row03", " row53", "ow6", "raw5", "view5", "view4", "ow5", "port5", "port03", "raw6", "raw1", "ow1", "view53", "port3", "ow3"], "row4": ["ow4", "raw7", "ow2", "raw3", "rows3", "ow6", "row44", "ow7", "raw4", "rows2", "rows6", "raw44", "raw6", "ow44", "rows4", "ow3", " row44"], "row5": ["ro9", "post3", "raw3", " rowFive", "ro2", "post5", "raw50", " row9", "ro50", " row50", "raw56", "ro5", "ro56", "raw5", " row56", "raw9", "post6", "roFive", "row56", "rowFive", "raw6", "post2", "raw2", "row50", "rawFive", "row9", "ro6"], "row6": ["ow4", " row26", "ro12", "row12", "post5", "ro4", "ry5", "row26", "ro86", "post4", "ry12", "ow6", "ro5", "raw5", " row62", "ow26", "row86", "post6", "raw4", "ry86", "ow5", "ry6", "row62", "raw6", "post62", " row12", "raw62", "ro26", " row86", "ro6"], "row7": ["raw7", "ry7", "ro8", "ro7", " row17", "ow57", "raw8", " row8", "row57", "raw77", "ro77", " row57", "ow77", " row77", "ow8", "row17", " row73", "raw17", "row77", "ow7", "row73", "row8", "raw4", "raw57", "raw73", "ro73", "ry77", "ry17", "ry4"]}}
{"project": "FFmpeg", "commit_id": "e15824e75b5549e53eb5c1ffb79766321ac8d122", "target": 1, "func": "int ff_h261_handle_packet(AVFormatContext *ctx, PayloadContext *data,\n\n                          AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n\n                          const uint8_t *buf, int len, uint16_t seq, int flags)\n\n{\n\n    int sbit, ebit, gobn, mbap, quant;\n\n    int res;\n\n\n\n    //av_log(ctx, AV_LOG_DEBUG, \"got h261 RTP packet with time: %u\\n\", timestamp);\n\n\n\n    /* drop data of previous packets in case of non-continuous (loss) packet stream */\n\n    if (data->buf && data->timestamp != *timestamp) {\n\n        h261_free_dyn_buffer(&data->buf);\n\n    }\n\n\n\n    /* sanity check for size of input packet */\n\n    if (len < 5 /* 4 bytes header and 1 byte payload at least */) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Too short H.261 RTP packet\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /*\n\n      decode the H.261 payload header according to section 4.1 of RFC 4587:\n\n      (uses 4 bytes between RTP header and H.261 stream per packet)\n\n\n\n         0                   1                   2                   3\n\n         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n        |SBIT |EBIT |I|V| GOBN  |   MBAP  |  QUANT  |  HMVD   |  VMVD   |\n\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n\n\n           Start bit position (SBIT): 3 bits\n\n           End bit position (EBIT): 3 bits\n\n           INTRA-frame encoded data (I): 1 bit\n\n           Motion Vector flag (V): 1 bit\n\n           GOB number (GOBN): 4 bits\n\n           Macroblock address predictor (MBAP): 5 bits\n\n           Quantizer (QUANT): 5 bits\n\n           Horizontal motion vector data (HMVD): 5 bits\n\n           Vertical motion vector data (VMVD): 5 bits\n\n\n\n    */\n\n    sbit  =  (buf[0] >> 5) & 0x07;\n\n    ebit  =  (buf[0] >> 2) & 0x07;\n\n    gobn  =  (buf[1] >> 4) & 0x0f;\n\n    mbap  = ((buf[1] << 1) & 0x1e) | ((buf[1] >> 7) & 0x01);\n\n    quant =  (buf[1] >> 4) & 0x0f;\n\n\n\n    /* pass the H.261 payload header and continue with the actual payload */\n\n    buf += RTP_H261_PAYLOAD_HEADER_SIZE;\n\n    len -= RTP_H261_PAYLOAD_HEADER_SIZE;\n\n\n\n    /* start frame buffering with new dynamic buffer */\n\n    if (!data->buf) {\n\n        /* sanity check: a new frame starts with gobn=0, sbit=0, mbap=0, uqnat=0 */\n\n        if (!gobn  && !sbit && !mbap && !quant){\n\n            res = avio_open_dyn_buf(&data->buf);\n\n            if (res < 0)\n\n                return res;\n\n            /* update the timestamp in the frame packet with the one from the RTP packet */\n\n            data->timestamp = *timestamp;\n\n        } else {\n\n            /* frame not started yet, need more packets */\n\n            return AVERROR(EAGAIN);\n\n        }\n\n    }\n\n\n\n    /* do the \"byte merging\" at the boundaries of two consecutive frame fragments */\n\n    if (data->endbyte_bits || sbit) {\n\n        if (data->endbyte_bits == sbit) {\n\n            data->endbyte |= buf[0] & (0xff >> sbit);\n\n            data->endbyte_bits = 0;\n\n            buf++;\n\n            len--;\n\n            avio_w8(data->buf, data->endbyte);\n\n        } else {\n\n            /* ebit/sbit values inconsistent, assuming packet loss */\n\n            GetBitContext gb;\n\n            init_get_bits(&gb, buf, len*8 - ebit);\n\n            skip_bits(&gb, sbit);\n\n            if (data->endbyte_bits) {\n\n                data->endbyte |= get_bits(&gb, 8 - data->endbyte_bits);\n\n                avio_w8(data->buf, data->endbyte);\n\n            }\n\n            while (get_bits_left(&gb) >= 8)\n\n                avio_w8(data->buf, get_bits(&gb, 8));\n\n            data->endbyte_bits = get_bits_left(&gb);\n\n            if (data->endbyte_bits)\n\n                data->endbyte = get_bits(&gb, data->endbyte_bits) <<\n\n                                (8 - data->endbyte_bits);\n\n            ebit = 0;\n\n            len = 0;\n\n        }\n\n    }\n\n    if (ebit) {\n\n        if (len > 0)\n\n            avio_write(data->buf, buf, len - 1);\n\n        data->endbyte_bits = 8 - ebit;\n\n        data->endbyte = buf[len - 1] & (0xff << ebit);\n\n    } else {\n\n        avio_write(data->buf, buf, len);\n\n    }\n\n\n\n    /* RTP marker bit means: last fragment of current frame was received;\n\n       otherwise, an additional fragment is needed for the current frame */\n\n    if (!(flags & RTP_FLAG_MARKER))\n\n        return AVERROR(EAGAIN);\n\n\n\n    /* write the completed last byte from the \"byte merging\" */\n\n    if (data->endbyte_bits)\n\n        avio_w8(data->buf, data->endbyte);\n\n    data->endbyte_bits = 0;\n\n\n\n    /* close frame buffering and create resulting A/V packet */\n\n    res = ff_rtp_finalize_packet(pkt, &data->buf, st->index);\n\n    if (res < 0)\n\n        return res;\n\n\n\n    return 0;\n\n}\n", "idx": 3456, "substitutes": {"ctx": ["cc", "pkg", "buff", "loc", "sc", "cf", "rc", "cpp", "context", "cmp", "conv", "cca", "fp", "exec", "xc", "cli", "cam", "tc", "cv", "cp", "lc", "conn", "ca", "ann", "c", "ctrl", "jp", "cb", "tx", "cmd", "cl", "hw", "aux", "bc", "ux", "cas", "cm", "anc"], "data": ["update", "view", "diff", "database", "req", "reader", "lib", "d", "send", "qa", "window", "parent", "output", "complete", "results", "info", "image", "la", "proc", "DATA", "this", "post", "message", "media", "wa", "ui", "done", "error", "p", "exec", "what", "valid", "config", "dat", "load", "ad", "event", "pos", "li", "add", "current", "map", "style", "al", "response", "next", "dd", "Data", "context", "function", "new", "dr", "session", "slice", "full", "stream", "loader", "conn", "change", "missing", "writer", "batch", "server", "extra", "final", "empty", "last", "model", "val", "cache", "fail", "def", "rc", "command", "connection", "input", "first", "alpha", "api", "no", "off", "class", "aa", "end", "master", "body", "after", "start", "result", "tx", "db", "da", "resource", "client"], "st": ["ost", "sw", "cr", "sth", "inst", "sc", "pl", "pt", "nd", "stack", "src", "St", "sta", "se", "rest", "sa", "ut", "rd", "str", "ST", "ast", "sp", "nt", "std", "sts", "ss", "ct"], "pkt": [" pst", "Packet", "Pst", "packet", "apkt", "apacket", " packet", " pct", "apst", "pct", "apct", "Pkt", "pst", "Pct"], "timestamp": ["Timest", "stimestamp", "tuneter", "Timetime", "Timvision", "dimestamp", "timeeline", "stimeness", "rampt", "tmvision", "timity", "metity", "stimetime", "timeline", "imension", "metest", "timeestamp", "metetime", "Timestamp", "timvision", "tmeline", "timetime", "soundest", "meteline", "rameline", "timeness", "timeest", "impt", "timeter", "stimeter", "soundestamp", "dimension", "imestamp", "imeline", "dimeline", "ramestamp", "tuneness", "Timeness", "dimest", "timeension", "metpt", "timpt", "imest", "metestamp", "imetime", "timension", "tmest", "soundeline", "ramity", "timest", "soundvision", "Timeline", "Timeter", "tunetime", "tmestamp", "imity", "tunestamp"], "buf": ["mount", "rb", "home", "text", "buff", "fab", "comb", "pb", "ff", "rw", "orig", "bus", "fd", "feat", "Buff", "window", "row", "band", "bh", "block", "cb", "cap", "la", "proc", "f", "wb", "ctr", "bc", "filename", "br", "wave", "conv", "ha", "tmp", "config", "buffer", "hide", "hl", "cv", "fam", "brace", "port", "bag", "pool", "ph", "b", "box", "aux", "cas", "fn", "ptr", "context", "fi", "code", "ab", "queue", "batch", "length", "pause", "cmd", "cur", "uc", "path", "cat", "bf", "loop", "socket", "loc", "cf", "rc", "img", "header", "lim", "utf", "alloc", "fp", "src", "vec", "fb", "off", "func", "uf", "bin", "db", "bu"], "len": ["fn", "line", "val", "offset", "lp", "part", "base", "loc", "en", "l", "gen", "un", "lon", "lim", "n", "elt", "pl", "fp", "lin", "lang", "fl", "fin", "split", "led", "min", "rev", "z", "ln", "limit", "win", " length", "hl", "fen", "count", "Len", "lit", "pos", "el", "fd", "li", "list", "lan", "den", "length", "il", "nt", "body", "ll", "lf", "la", "nl", "bin", "size", "sl", "bl", "lvl", "lc"], "seq": [" count", " cipher", " pri", " cur", " sequence", " reply", " cmd", " resp", " num", " aux", " dup", " ref", " queue", " fin", " pos", " sent", " prev", " leng", " ecc", " id", " serial", " ret", " cas", " rc", " disp", " code", " sup", " req"], "flags": ["mask", "fn", "fs", "rc", "fps", "cs", "flag", "bits", "fields", " bits", "rows", "ret", "count", "frame", "format", "fd", "ents", "frames", "vals", "ats", "options", "features", "days", "Flags", "bytes", "lvl"], "sbit": ["obsBIT", "obsbit", "sesbit", "scol", " sbits", "Sboot", "Sbin", "tsbyte", "cstag", "wstag", "ssbits", "gsbit", "symbit", "tsct", " sbyte", " sunit", "Sbit", "Sbyte", "gsbyte", "sescol", "ssbin", "symbin", " stag", "symBIT", "wsct", "wsunit", "sct", "ssbit", "wsbits", "stag", "tsbit", "csbit", "sbug", "symbyte", "ssbyte", "sbyte", "obsbyte", "sunit", "sbits", "csunit", "sbin", "sBIT", "Sbits", "SBIT", "ssboot", "gscol", " sbug", "wsbyte", "csBIT", "wsbit", "sesbug", "sesbyte", "gsbug", " scol", "obsboot", " sBIT", "tstag", " sct", "ssBIT", "sboot", "wsBIT"], "ebit": ["zebitter", "herith", "abbiter", "abbith", "eksit", "ellill", "ellit", " ebith", "zebitting", "debid", "ebits", "ellits", " ebitter", "heriter", "ebitted", "heritted", "ebitter", "ambits", "ambit", "debits", "obitted", "eksitting", "ebitting", " ebitting", "ellid", "debit", "obit", "ambid", "abbit", "debill", "ebiter", "herit", "zebith", "obiter", "ebill", "ebith", "eksitter", "eksith", "ambill", "abbitted", "obith", "zebit", "ebid"], "gobn": ["gowna", " gobner", " gobnt", "ubbns", "gobner", "gobnp", "gownt", "gowb", "ubbn", "ubbnp", " gobna", "gowner", "gorc", "bubn", " gobnet", " gobb", "gorna", "gobb", "gownp", " gobc", "gownet", " gobnp", "gobns", "bubnet", "gowc", "gown", " gobns", "gobc", "gobnt", "bubne", "gowns", "gobnet", " gobne", "bubnt", "gowne", "gobne", "ubbb", "gobna", "gorner", "gorn"], "mbap": ["megaps", "ambAP", "bgap", "ebapt", "pgak", "bgaps", "mbak", "mdap", "mdapt", "mbapt", "ebAP", "bgash", "megAP", "MBash", "MBAP", "MBak", "bgAP", "ebaps", "mbapper", "ebash", "MBap", "ambap", "mdAP", "megak", "pgap", "mbaps", "pgAP", "ebap", "mdapper", "ebapper", "MBaps", "ambapper", "ambapt", "pgaps", "mbAP", "mbash", "megap"], "quant": ["comment", "serial", "random", "compl", "ident", "pkg", "supp", "eq", "bug", "priv", "patch", "quick", "secure", "context", "private", "neutral", "complex", "sim", "qu", "requ", "qq", "qi", "query", "sq", "quiet", "pub", "qa", "tax", "pad", "charge", "qual", "iq", "spec", "progress", "quality", "comp", "util", "Quant", "qua", "gap", "q", "inc", "cmd", "forced", "dev", "cost", "cur", "frac", "final", "qt", "quad", "multipl"], "res": ["rep", "val", "ms", "req", "rh", "r", "des", "rys", "ns", "rc", "cs", "num", "resp", " result", "ras", "arr", "rows", "details", "rev", "ret", "ries", " r", "errors", "resolution", "rss", "rest", "ches", "ress", "reset", "count", "msg", "cons", "Res", "ps", "vals", "rs", "reg", "RES", "ris", "es", "results", "result", "pres", "vs", "os", "err", "ver", "resh", "js", "re", "runs", "bytes", "rem", " results", "nos"], "gb": ["gu", "kb", " storage", "rb", " bi", " bin", "ui", " rgb", " rg", "git", " img", " gl", " eg", "bb", "GB", "gh", "lib", "ubs", "ci", "bo", "gow", " gcc", "nn", "bg", "gt", " py", "ga", "gp", " db", " src", " mode", "ba", "gn", " addr", "nb", "pc", "g", "abb", "gin", " g", " kb", "hub", "sb", "rg", "gm", "gram", "gg", "gy", "gd", "di", "gs", " gy", "db", "sg", "bin", "gam", " rc", "sl", "bc", "cfg", "ki", "Gb", "bm", " GB"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int vdpau_mpeg_start_frame(AVCodecContext *avctx,\n\n                                  const uint8_t *buffer, uint32_t size)\n\n{\n\n    MpegEncContext * const s = avctx->priv_data;\n\n    Picture *pic             = s->current_picture_ptr;\n\n    struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private;\n\n    VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg;\n\n    VdpVideoSurface ref;\n\n    int i;\n\n\n\n    /* fill VdpPictureInfoMPEG1Or2 struct */\n\n    info->forward_reference  = VDP_INVALID_HANDLE;\n\n    info->backward_reference = VDP_INVALID_HANDLE;\n\n\n\n    switch (s->pict_type) {\n\n    case AV_PICTURE_TYPE_B:\n\n        ref = ff_vdpau_get_surface_id(&s->next_picture.f);\n\n        assert(ref != VDP_INVALID_HANDLE);\n\n        info->backward_reference = ref;\n\n        /* fall through to forward prediction */\n\n    case AV_PICTURE_TYPE_P:\n\n        ref = ff_vdpau_get_surface_id(&s->last_picture.f);\n\n        info->forward_reference  = ref;\n\n    }\n\n\n\n    info->slice_count                = 0;\n\n    info->picture_structure          = s->picture_structure;\n\n    info->picture_coding_type        = s->pict_type;\n\n    info->intra_dc_precision         = s->intra_dc_precision;\n\n    info->frame_pred_frame_dct       = s->frame_pred_frame_dct;\n\n    info->concealment_motion_vectors = s->concealment_motion_vectors;\n\n    info->intra_vlc_format           = s->intra_vlc_format;\n\n    info->alternate_scan             = s->alternate_scan;\n\n    info->q_scale_type               = s->q_scale_type;\n\n    info->top_field_first            = s->top_field_first;\n\n    // Both for MPEG-1 only, zero for MPEG-2:\n\n    info->full_pel_forward_vector    = s->full_pel[0];\n\n    info->full_pel_backward_vector   = s->full_pel[1];\n\n    // For MPEG-1 fill both horizontal & vertical:\n\n    info->f_code[0][0]               = s->mpeg_f_code[0][0];\n\n    info->f_code[0][1]               = s->mpeg_f_code[0][1];\n\n    info->f_code[1][0]               = s->mpeg_f_code[1][0];\n\n    info->f_code[1][1]               = s->mpeg_f_code[1][1];\n\n    for (i = 0; i < 64; ++i) {\n\n        info->intra_quantizer_matrix[i]     = s->intra_matrix[i];\n\n        info->non_intra_quantizer_matrix[i] = s->inter_matrix[i];\n\n    }\n\n\n\n    return ff_vdpau_common_start_frame(pic_ctx, buffer, size);\n\n}\n", "idx": 3460, "substitutes": {"avctx": ["AVctx", "avectx", "navconv", "AVkw", "ajctx", "avgc", "auctx", "AVctl", "AVconv", "aukw", "ajconv", "navcontext", "navctx", "avecontext", "avekw", "aucontext", "navctl", "AVcontext", "avegc", "avctl", "augc", "ajcontext", "avcontext", "AVgc", "ajctl", "avconv", "avkw"], "buffer": ["comment", "media", "picture", "text", "buff", "ram", "filename", "document", "input", "queue", "memory", "buf", "Buffer", "stream", "file", "data", "uffer", "window", "uf", "length", "port", "seed", "image", "transfer", "audio", "message", "reader", "source"], "size": [" storage", " resize", " source", "scale", " window", "buf", " length", " bytes", "file", "g", "data", " encoding", "length", "ize", "shape", "image", " limit", "izes", "large", " sizes", " Size", "SIZE", "Size"], "s": ["setup", "conf", "d", "ions", "sum", "sa", "stat", "ages", "states", "ps", "sb", "sym", "parts", "f", "os", "as", "space", "this", "set", "js", "params", "soc", "comments", "sv", "l", "sites", "si", "is", "qs", "o", "y", "p", "details", "stats", "ses", "args", "b", "sg", "irs", "ops", "sup", "sync", "h", "S", "r", "sc", "settings", "hs", "cs", "ssl", "m", "sq", "session", "full", "service", "g", "us", "server", "spec", "ks", "es", "gs", "t", "ss", "e", "ls", "http", "ds", "source", "request", "fs", "su", "sets", "ts", "ns", "n", "api", "services", "a", "sys", "sf", "c", "rs", "storage", "its", "bis"], "pic": ["picture", "fs", "mac", "Pic", "ac", "fc", "fi", "enc", "ctx", "img", "sec", "p", "fp", "ic", "pin", "cci", "config", "cam", "study", "sa", "mini", "sys", "file", "pict", "pc", "data", "photo", "spec", "c", "pins", "sac", "image", "mc", "pi", "nic", "f", "doc", "bc", "lc", "fe", "cus"], "pic_ctx": ["pic__ctrl", "pic_context", "pic_ct", "picjctrl", "picture_ctx", "pic__ci", "picture_loc", "pic_ci", "pic_loc", "picjctx", "pic__context", "pic_ctrl", "pic__ctx", "picjcontext", "picture_ci", "picture_context", "picture_ctrl", "picture_ct", "picjci"], "info": ["update", "home", "part", "diff", "follow", "buff", "text", "conf", "archive", "num", "key", "alias", "tf", "notice", "afi", "ami", "image", "meta", "f", "json", "message", "show", "information", "inf", "ui", "Info", "manager", "error", "si", "is", "from", "p", "config", "name", "time", "event", "success", "data", "app", "init", "style", "op", "about", "comment", "offset", "by", "iso", "new", "fo", "slice", "full", "help", "options", "audio", "ip", "summary", "extra", "http", "INFO", "source", "index", "desc", "user", "def", "img", "af", "metadata", "id", "api", "note", "guide", "ii", "off", "py", "frame", "end", "ext", "type", "fw", "di", "start", "result", "abi", "get", "feature", "gui", "gi", "inner", "thin"], "ref": ["comment", "bf", "inf", "offset", "cache", "diff", "fact", "part", "base", "req", "loc", "REF", "def", "rc", "fi", "object", "cmp", "num", "resp", "conf", "reference", "aff", "alt", "p", "index", "src", "ab", "remote", "ind", "href", "af", "config", "rev", "obj", "id", "source", "name", " referenced", " pref", "count", "rec", "frame", "prefix", "type", "parent", " pointer", "url", "pre", "reg", "ef", "ob", "result", " reference", "col", "rel", "inter", "b", "Ref", "f", "address", "instance", "re", "pointer", " references", "fe"], "i": ["l", "fi", "si", "is", "j", "o", "p", "ci", "m", "mi", "ii", "v", "a", "li", "iu", "c", "di", "image", "pi", "t", "b", "f", "ti", "ip", "e", "I", "it"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void h263_decode_init_vlc(MpegEncContext *s)\n\n{\n\n    static int done = 0;\n\n\n\n    if (!done) {\n\n        done = 1;\n\n\n\n        init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, \n\n                 intra_MCBPC_bits, 1, 1,\n\n                 intra_MCBPC_code, 1, 1);\n\n        init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, \n\n                 inter_MCBPC_bits, 1, 1,\n\n                 inter_MCBPC_code, 1, 1);\n\n        init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16,\n\n                 &cbpy_tab[0][1], 2, 1,\n\n                 &cbpy_tab[0][0], 2, 1);\n\n        init_vlc(&mv_vlc, MV_VLC_BITS, 33,\n\n                 &mvtab[0][1], 2, 1,\n\n                 &mvtab[0][0], 2, 1);\n\n        init_rl(&rl_inter);\n\n        init_rl(&rl_intra);\n\n        init_rl(&rvlc_rl_inter);\n\n        init_rl(&rvlc_rl_intra);\n\n        init_rl(&rl_intra_aic);\n\n        init_vlc_rl(&rl_inter);\n\n        init_vlc_rl(&rl_intra);\n\n        init_vlc_rl(&rvlc_rl_inter);\n\n        init_vlc_rl(&rvlc_rl_intra);\n\n        init_vlc_rl(&rl_intra_aic);\n\n        init_vlc(&dc_lum, DC_VLC_BITS, 10 /* 13 */,\n\n                 &DCtab_lum[0][1], 2, 1,\n\n                 &DCtab_lum[0][0], 2, 1);\n\n        init_vlc(&dc_chrom, DC_VLC_BITS, 10 /* 13 */,\n\n                 &DCtab_chrom[0][1], 2, 1,\n\n                 &DCtab_chrom[0][0], 2, 1);\n\n        init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15,\n\n                 &sprite_trajectory_tab[0][1], 4, 2,\n\n                 &sprite_trajectory_tab[0][0], 4, 2);\n\n        init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4,\n\n                 &mb_type_b_tab[0][1], 2, 1,\n\n                 &mb_type_b_tab[0][0], 2, 1);\n\n        init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15,\n\n                 &h263_mbtype_b_tab[0][1], 2, 1,\n\n                 &h263_mbtype_b_tab[0][0], 2, 1);\n\n        init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4,\n\n                 &cbpc_b_tab[0][1], 2, 1,\n\n                 &cbpc_b_tab[0][0], 2, 1);\n\n    }\n\n}\n", "idx": 3476, "substitutes": {"s": ["S", "fs", "ms", "sets", "ns", "cs", "si", "is", "ssl", "qs", "p", "m", "sq", "session", "services", "sys", "g", "ses", "sf", "c", "params", "gs", "sg", "f", "ss", "js", "e"]}}
{"project": "qemu", "commit_id": "ee71c984342408a357a74f65915bf66484ba445a", "target": 1, "func": "static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset,\n\n                             unsigned size)\n\n{\n\n    icp_pit_state *s = (icp_pit_state *)opaque;\n\n    int n;\n\n\n\n    /* ??? Don't know the PrimeCell ID for this device.  */\n\n    n = offset >> 8;\n\n    if (n > 3) {\n\n        hw_error(\"sp804_read: Bad timer %d\\n\", n);\n\n    }\n\n\n\n    return arm_timer_read(s->timer[n], offset & 0xff);\n\n}\n", "idx": 3484, "substitutes": {"opaque": ["oppacity", "opac", "ipaques", "OPac", "OPacity", "oppac", "copacity", "OPaques", "ipaque", "opque", "oppaque", "compacity", "compaques", "copaques", "ipac", "phpque", "copque", "phpacity", "opaques", "compaque", "OPaque", "ipacity", "opacity", "compque", "oppaques", "phpaques", "phpaque", "copaque"], "offset": ["i", "base", "shift", "error", "padding", "ptr", "array", "reference", "o", "at", "fp", "p", "Offset", "location", "number", "buffer", "sn", "et", "len", "reset", "pad", "off", "skip", "slice", "pos", "type", "position", "data", "parent", "slot", "length", "initial", "start", "args", "f", "range", "address", "set", "addr", "empty", "timeout", "pointer", "index"], "size": ["shift", " address", "fee", " length", "len", "count", "type", "data", "length", "ize", "c", "args", " sizes", "set", "address", "e", "timeout", "bytes", "SIZE", "Size"], "s": ["S", "socket", "sets", "ts", "ns", "settings", "si", "uns", "is", "ssl", "p", "ips", "sq", "session", "se", "opens", "sa", "services", "sys", "sie", "service", "ps", "spec", "ses", "secondary", "sb", "c", "rs", "es", "self", "scope", "gs", "sym", "abi", "args", "os", "aws", "ss", "e", "sl", "ls", "ops", "ds", "sync"], "n": ["fn", "i", " N", "nm", "en", "ns", "un", "l", "j", "num", "o", "y", "p", "number", "nn", "d", "m", "min", "name", "z", "sn", "w", "k", "no", "len", "v", "nb", "pos", "g", "ne", "dn", "c", "nt", "nr", "nc", "nl", "t", "b", "f", "na", "u", "ni", "N", "out", "x", "e"]}}
{"project": "FFmpeg", "commit_id": "d7e9533aa06f4073a27812349b35ba5fede11ca1", "target": 1, "func": "static int mpeg1_decode_sequence(AVCodecContext *avctx, \n\n                                 UINT8 *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s1 = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n    int width, height, i, v, j;\n\n    \n\n    init_get_bits(&s->gb, buf, buf_size);\n\n\n\n    width = get_bits(&s->gb, 12);\n\n    height = get_bits(&s->gb, 12);\n\n    skip_bits(&s->gb, 4);\n\n    s->frame_rate_index = get_bits(&s->gb, 4);\n\n    if (s->frame_rate_index == 0)\n\n        return -1;\n\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n\n    if (get_bits1(&s->gb) == 0) /* marker */\n\n        return -1;\n\n    if (width <= 0 || height <= 0 ||\n\n        (width % 2) != 0 || (height % 2) != 0)\n\n        return -1;\n\n    if (width != s->width ||\n\n        height != s->height) {\n\n        /* start new mpeg1 context decoding */\n\n        s->out_format = FMT_MPEG1;\n\n        if (s1->mpeg_enc_ctx_allocated) {\n\n            MPV_common_end(s);\n\n        }\n\n        s->width = width;\n\n        s->height = height;\n\n        s->has_b_frames = 1;\n\n        s->avctx = avctx;\n\n        avctx->width = width;\n\n        avctx->height = height;\n\n        avctx->frame_rate = frame_rate_tab[s->frame_rate_index];\n\n        s->frame_rate = avctx->frame_rate;\n\n        avctx->bit_rate = s->bit_rate;\n\n        \n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n        mpeg1_init_vlc(s);\n\n        s1->mpeg_enc_ctx_allocated = 1;\n\n    }\n\n\n\n    skip_bits(&s->gb, 10); /* vbv_buffer_size */\n\n    skip_bits(&s->gb, 1);\n\n\n\n    /* get matrix */\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = zigzag_direct[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[zigzag_direct[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            v = default_intra_matrix[i];\n\n            s->intra_matrix[i] = v;\n\n            s->chroma_intra_matrix[i] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = zigzag_direct[i];\n\n            s->non_intra_matrix[j] = v;\n\n            s->chroma_non_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->non_intra_matrix[zigzag_direct[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            v = default_non_intra_matrix[i];\n\n            s->non_intra_matrix[i] = v;\n\n            s->chroma_non_intra_matrix[i] = v;\n\n        }\n\n    }\n\n\n\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    return 0;\n\n}\n", "idx": 3499, "substitutes": {"avctx": ["avcu", "apconn", "AVctx", "mpcontext", "afxc", "AVcb", "abctx", "abcf", "avcmp", "awcf", "apsq", "afloc", "afconn", "afconnection", "afctx", "apcontext", "aveloc", "aptx", "airsys", "abtx", "AVcontext", "avcontext", "airctx", "mpcu", "avconn", "avectx", "aftx", " avcontext", "avsys", "abloc", "evsys", "apctx", " avconn", "avtx", " avxc", "avcf", "avxc", "avexc", "evcontext", "apcmp", "avconfig", "airconn", "ajcontext", "mpctx", "aircmp", "evconn", "awcontext", "ajctx", "abcontext", "afsq", "ajconfig", "afcmp", "abconn", "avecontext", "evctx", "avloc", "apconnection", "AVtx", "ajcb", "afcf", "avconnection", "afcontext", "awctx", "afsys", "afcu", "AVconfig", "awtx", "aveconfig", "avsq", "aveconn", "AVconn", "airsq", " avconnection", "mpconfig", "aircontext", "avcb", "afcb", "avecu", "afconfig"], "buf": ["rb", "buff", "rc", "pb", "ctx", "img", "num", "conv", "alloc", "fp", "ref", "src", "mem", "ff", "ab", "byte", "raw", "queue", "buffer", "Buffer", "vec", "fb", "cv", "nb", "fd", "data", "batch", "uf", "port", "c", "gb", "block", "cb", "proc", "max", "b", "cmd", "wb", "bc", "seq", "br"], "buf_size": ["path_size", "bufamsource", "cmd_SIZE", "cmd_size", "path_source", "cmdlexspeed", "pathamsource", "pathamsize", "cmd_speed", "path_SIZE", "bufamsize", "path_chan", "buflexspeed", "buflexSIZE", "pathamSIZE", "cmdlexsize", "buf_SIZE", "bufamSIZE", "buflexsize", "cmdlexSIZE", "bufamchan", "buf_chan", "buf_source", "buf_speed", "pathamchan"], "s1": ["s01", "psOne", "sons", "c1", "kons", " s0", "share1", "sh1", "shOne", " s01", "shareOne", "args0", "sOne", "ssOne", "ses1", "k1", "Sons", "shons", "ses_", "S1", "ses01", "args2", "share01", "args001", "sesOne", "SOne", "ps1", " sOne", "s001", "s_", " s_", "c0", "args1", " s2", "kOne", "ss1", "c2", "ss2", "s0", "share_", " s001", "ps2", "c001", "s2"], "s": ["conf", "sec", "d", "words", "sa", "an", "states", "ps", "sb", "sym", "os", "f", "parts", "as", "this", "js", "params", "l", "si", "is", "qs", "o", "y", "p", "ins", "se", "stats", "ses", "site", "args", "b", "u", "sg", "serv", "ops", "plugins", "sync", "h", "S", "r", "settings", "cs", "ctx", "ssl", "south", "new", "sq", "session", "bs", "w", "full", "service", "g", "your", "us", "server", "ks", "spec", "es", "gs", "t", "aws", "ss", "e", "sl", "ls", "http", "ds", "xs", "request", "fs", "ms", "su", "sets", "ts", "ns", "n", "services", "a", "sys", "c", "rs", "in", "self", "vs", "its", "x"], "height": ["family", "hung", "grow", "iii", "gh", "layout", "ht", "hang", "d", "build", "th", "window", "quality", "tight", "image", "history", "max", "gap", "host", "wa", "rh", "y", " heights", "stroke", "bottom", "images", "html", "gpu", "data", "port", "style", "Height", "h", "arrow", "gallery", "density", "han", "deep", "lat", "w", "dy", "definition", "inches", "we", "capacity", "slice", "pad", "wrap", "length", "duration", "shape", "rank", "thin", "ip", "size", "volume", "dom", "high", "container", "def", "padding", "img", "huge", "crop", "rows", "id", "resolution", "dim", "above", "distance", "work", "fw", "direction", "depth", "ows", "range", "timeout", "ty"], "i": ["ui", "io", "r", "l", "fi", "si", "n", "y", "ani", "p", "ci", "multi", "qi", "eni", "d", "m", "oi", "z", "ori", "I", "mi", "w", "yi", "k", "ini", "ii", "bi", "uli", "li", "g", "ami", "ie", "iu", "ji", "c", "in", "zi", "di", "ix", "ai", "vi", "pi", "t", "b", "f", "u", "gi", "ti", "ip", "ni", "e", "xi", "x", "phi", "h", "index"], "v": ["uv", "val", "av", "sv", "l", "si", "n", "y", "ve", "p", "d", "m", "z", "V", "w", "volt", "k", "ii", "tv", "g", "c", "lv", "vi", "vs", "b", "f", "u", "q", "e", "x", "h", "vv"], "j": ["jc", "r", "l", "si", "n", "dj", "o", "y", "p", "d", "m", "aj", "z", "w", "k", "ij", "ii", "uj", "li", "g", "jj", "ji", "c", "jp", "max", "b", "f", "u", "q", "jit", "js", "x", "J", "h"]}}
{"project": "FFmpeg", "commit_id": "d600b18f224e02f8bfc6660bfa442e7ff3fb057c", "target": 1, "func": "void ff_rfps_calculate(AVFormatContext *ic)\n{\n    int i, j;\n    for (i = 0; i<ic->nb_streams; i++) {\n        AVStream *st = ic->streams[i];\n        if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO)\n        // the check for tb_unreliable() is not completely correct, since this is not about handling\n        // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.\n        // ipmovie.c produces.\n        if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num)\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX);\n        if (st->info->duration_count>1 && !st->r_frame_rate.num\n            && tb_unreliable(st->codec)) {\n            int num = 0;\n            double best_error= 0.01;\n            for (j=0; j<MAX_STD_TIMEBASES; j++) {\n                int k;\n                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))\n                if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j))\n                for(k=0; k<2; k++){\n                    int n= st->info->duration_count;\n                    double a= st->info->duration_error[k][0][j] / n;\n                    double error= st->info->duration_error[k][1][j]/n - a*a;\n                    if(error < best_error && best_error> 0.000000001){\n                        best_error= error;\n                        num = get_std_framerate(j);\n                    }\n                    if(error < 0.02)\n                        av_log(NULL, AV_LOG_DEBUG, \"rfps: %f %f\\n\", get_std_framerate(j) / 12.0/1001, error);\n                }\n            }\n            // do not increase frame rate by more than 1 % in order to match a standard rate.\n            if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate)))\n                av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX);\n        }\n        av_freep(&st->info->duration_error);\n        st->info->last_dts = AV_NOPTS_VALUE;\n        st->info->duration_count = 0;\n        st->info->rfps_duration_sum = 0;\n    }\n}", "idx": 3502, "substitutes": {"ic": ["cu", "cc", "bc", "cit", "dc", "ac", "ik", "fc", "cs", "enc", "ics", "icer", "ici", "icc", "ctx", "vc", "ci", "isc", "exec", "ec", "cci", "cli", "mic", "ict", "pic", "sn", "acs", "sci", "tc", "lc", "aic", "pc", "irc", "IC", "c", "icing", "ix", "iac", "oc", "lic", "aci", "ct", "cm", "anc"], "i": ["hi", "chi", "ui", "im", "io", "r", "l", "ik", "fi", "is", "si", "n", "o", "y", "p", "ci", "qi", "ind", "eni", "d", "m", "oi", "mi", "ori", "I", "id", "ri", "ini", "ii", "ij", "v", "li", "ami", "iu", "ie", "ji", "c", "in", "zi", "di", "ix", "ai", "ih", "pi", "gi", "f", "u", "ti", "ip", "ni", "e", "xi", "x", "ki", "yi", "index"], "j": ["times", "bj", "mpeg", "num", "ijk", "key", "java", "d", "z", "adj", "ja", "v", "jon", "ji", "jp", "f", "kj", "json", "js", "s", "je", "_", "l", "dj", "o", "y", "p", "jen", "aj", "time", "pos", "li", "b", "q", "u", "xi", "J", "fr", "jo", "jc", "pr", "r", "jl", "oj", "m", "ij", "uj", "stream", "jet", "jj", "g", "jan", "length", "jit", "jam", "section", "syn", "n", "job", "note", "ii", "end", "c", "jing", "x"], "st": ["fr", "ost", "sw", "sth", "r", "ste", "inst", "sc", "ts", "l", "sv", "lt", "tt", "play", "sh", "pl", "pt", "nd", "stack", "src", "St", "d", "sta", "stage", "sn", "rest", "sa", "stat", "et", "ld", "pe", "ut", "stop", "end", "trans", "est", "dest", "str", "ST", "data", "mt", "sp", "ast", "ust", "td", "sf", "sb", "c", "nt", "dt", "start", "kt", "ist", "ace", "style", "std", "t", "sd", "sts", "cl", "ft", "this", "ss", "sl", "sk", "ct", "bl", "client", "lc", "step"], "k": ["ek", "kw", "ko", "ke", "K", "r", "ok", "ik", "n", "y", "o", "kat", "p", "kk", "ky", "key", "km", "ka", "d", "z", "id", "kick", "kh", "v", "dk", "a", "g", "kid", "kr", "ks", "work", "c", "mk", "ck", "kn", "q", "u", "f", "ak", "e", "sk", "ku", "pull", "ki", "kin", "uk"]}}
{"project": "qemu", "commit_id": "bec93d7283b635aabaf0bbff67b6da7fc99e020a", "target": 0, "func": "static void gen_compute_eflags_o(DisasContext *s, TCGv reg)\n\n{\n\n    gen_compute_eflags(s);\n\n    tcg_gen_shri_tl(reg, cpu_cc_src, 11);\n\n    tcg_gen_andi_tl(reg, reg, 1);\n\n}\n", "idx": 3513, "substitutes": {"s": ["S", "i", "com", "sv", "r", "sets", "ns", "settings", "cs", "n", "sec", "ssl", "o", "p", "groups", "d", "m", "sq", "session", "w", "services", "sys", "stats", "ses", "secondary", "sf", "c", "sb", "rs", "es", "gs", "t", "os", "f", "sg", "b", "u", "ss", "js", "e", "tests", "ops", "sync", "h"], "reg": ["mod", "res", "gr", "r", "loc", "sc", "inst", "rc", "tr", "grad", "j", "sec", "num", "core", "debug", "ig", "isc", "or", "exec", "mem", "gc", "config", "thread", "Reg", "acc", "ret", "urg", "stat", "org", "rec", "conn", "pc", "roc", "g", "sign", "eg", "spec", "c", "rs", "rg", "eng", "gb", "registered", "asm", "rem", "arg", "proc", "REG", "sg", "re", "region", "tag", "report"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,\n\n                                       int *mb_type)\n\n{\n\n    int b8_stride = 2;\n\n    int b4_stride = h->b_stride;\n\n    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;\n\n    int mb_type_col[2];\n\n    const int16_t (*l1mv0)[2], (*l1mv1)[2];\n\n    const int8_t *l1ref0, *l1ref1;\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    unsigned int sub_mb_type = MB_TYPE_L0L1;\n\n    int i8, i4;\n\n    int ref[2];\n\n    int mv[2];\n\n    int list;\n\n\n\n    assert(sl->ref_list[1][0].reference & 3);\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent,\n\n                           sl->mb_y + !!IS_INTERLACED(*mb_type));\n\n\n\n#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \\\n\n                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)\n\n\n\n    /* ref = min(neighbors) */\n\n    for (list = 0; list < 2; list++) {\n\n        int left_ref     = sl->ref_cache[list][scan8[0] - 1];\n\n        int top_ref      = sl->ref_cache[list][scan8[0] - 8];\n\n        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];\n\n        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];\n\n        if (refc == PART_NOT_AVAILABLE) {\n\n            refc = sl->ref_cache[list][scan8[0] - 8 - 1];\n\n            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];\n\n        }\n\n        ref[list] = FFMIN3((unsigned)left_ref,\n\n                           (unsigned)top_ref,\n\n                           (unsigned)refc);\n\n        if (ref[list] >= 0) {\n\n            /* This is just pred_motion() but with the cases removed that\n\n             * cannot happen for direct blocks. */\n\n            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];\n\n            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];\n\n\n\n            int match_count = (left_ref == ref[list]) +\n\n                              (top_ref  == ref[list]) +\n\n                              (refc     == ref[list]);\n\n\n\n            if (match_count > 1) { // most common\n\n                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),\n\n                                      mid_pred(A[1], B[1], C[1]));\n\n            } else {\n\n                assert(match_count == 1);\n\n                if (left_ref == ref[list])\n\n                    mv[list] = AV_RN32A(A);\n\n                else if (top_ref == ref[list])\n\n                    mv[list] = AV_RN32A(B);\n\n                else\n\n                    mv[list] = AV_RN32A(C);\n\n            }\n\n        } else {\n\n            int mask = ~(MB_TYPE_L0 << (2 * list));\n\n            mv[list]  = 0;\n\n            ref[list] = -1;\n\n            if (!is_b8x8)\n\n                *mb_type &= mask;\n\n            sub_mb_type &= mask;\n\n        }\n\n    }\n\n    if (ref[0] < 0 && ref[1] < 0) {\n\n        ref[0] = ref[1] = 0;\n\n        if (!is_b8x8)\n\n            *mb_type |= MB_TYPE_L0L1;\n\n        sub_mb_type |= MB_TYPE_L0L1;\n\n    }\n\n\n\n    if (!(is_b8x8 | mv[0] | mv[1])) {\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n        return;\n\n    }\n\n\n\n    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL\n\n        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL\n\n            mb_y  = (sl->mb_y & ~1) + sl->col_parity;\n\n            mb_xy = sl->mb_x +\n\n                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;\n\n            b8_stride = 0;\n\n        } else {\n\n            mb_y  += sl->col_fieldoff;\n\n            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity\n\n        }\n\n        goto single_col;\n\n    } else {                                             // AFL/AFR/FR/FL -> AFR/FR\n\n        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR\n\n            mb_y           =  sl->mb_y & ~1;\n\n            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;\n\n            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];\n\n            b8_stride      = 2 + 4 * h->mb_stride;\n\n            b4_stride     *= 6;\n\n            if (IS_INTERLACED(mb_type_col[0]) !=\n\n                IS_INTERLACED(mb_type_col[1])) {\n\n                mb_type_col[0] &= ~MB_TYPE_INTERLACED;\n\n                mb_type_col[1] &= ~MB_TYPE_INTERLACED;\n\n            }\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&\n\n                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&\n\n                !is_b8x8) {\n\n                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */\n\n            } else {\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        } else {                                         //     AFR/FR    -> AFR/FR\n\nsingle_col:\n\n            mb_type_col[0] =\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {\n\n                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */\n\n            } else if (!is_b8x8 &&\n\n                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {\n\n                *mb_type |= MB_TYPE_DIRECT2 |\n\n                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));\n\n            } else {\n\n                if (!h->sps.direct_8x8_inference_flag) {\n\n                    /* FIXME: Save sub mb types from previous frames (or derive\n\n                     * from MVs) so we know exactly what block size to use. */\n\n                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */\n\n                }\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        }\n\n    }\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);\n\n\n\n    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];\n\n    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];\n\n    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];\n\n    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];\n\n    if (!b8_stride) {\n\n        if (sl->mb_y & 1) {\n\n            l1ref0 += 2;\n\n            l1ref1 += 2;\n\n            l1mv0  += 2 * b4_stride;\n\n            l1mv1  += 2 * b4_stride;\n\n        }\n\n    }\n\n\n\n    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            int x8  = i8 & 1;\n\n            int y8  = i8 >> 1;\n\n            int xy8 = x8     + y8 * b8_stride;\n\n            int xy4 = x8 * 3 + y8 * b4_stride;\n\n            int a, b;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                ((l1ref0[xy8] == 0 &&\n\n                  FFABS(l1mv0[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv0[xy4][1]) <= 1) ||\n\n                 (l1ref0[xy8] < 0 &&\n\n                  l1ref1[xy8] == 0 &&\n\n                  FFABS(l1mv1[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv1[xy4][1]) <= 1))) {\n\n                a =\n\n                b = 0;\n\n                if (ref[0] > 0)\n\n                    a = mv[0];\n\n                if (ref[1] > 0)\n\n                    b = mv[1];\n\n                n++;\n\n            } else {\n\n                a = mv[0];\n\n                b = mv[1];\n\n            }\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);\n\n        }\n\n        if (!is_b8x8 && !(n & 3))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    } else if (IS_16X16(*mb_type)) {\n\n        int a, b;\n\n\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n            ((l1ref0[0] == 0 &&\n\n              FFABS(l1mv0[0][0]) <= 1 &&\n\n              FFABS(l1mv0[0][1]) <= 1) ||\n\n             (l1ref0[0] < 0 && !l1ref1[0] &&\n\n              FFABS(l1mv1[0][0]) <= 1 &&\n\n              FFABS(l1mv1[0][1]) <= 1 &&\n\n              h->x264_build > 33U))) {\n\n            a = b = 0;\n\n            if (ref[0] > 0)\n\n                a = mv[0];\n\n            if (ref[1] > 0)\n\n                b = mv[1];\n\n        } else {\n\n            a = mv[0];\n\n            b = mv[1];\n\n        }\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);\n\n    } else {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            const int x8 = i8 & 1;\n\n            const int y8 = i8 >> 1;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n\n\n            assert(b8_stride == 2);\n\n            /* col_zero_flag */\n\n            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                (l1ref0[i8] == 0 ||\n\n                 (l1ref0[i8] < 0 &&\n\n                  l1ref1[i8] == 0 &&\n\n                  h->x264_build > 33U))) {\n\n                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;\n\n                if (IS_SUB_8X8(sub_mb_type)) {\n\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];\n\n                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                        if (ref[0] == 0)\n\n                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        if (ref[1] == 0)\n\n                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        n += 4;\n\n                    }\n\n                } else {\n\n                    int m = 0;\n\n                    for (i4 = 0; i4 < 4; i4++) {\n\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n\n                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                            if (ref[0] == 0)\n\n                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);\n\n                            if (ref[1] == 0)\n\n                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);\n\n                            m++;\n\n                        }\n\n                    }\n\n                    if (!(m & 3))\n\n                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;\n\n                    n += m;\n\n                }\n\n            }\n\n        }\n\n        if (!is_b8x8 && !(n & 15))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    }\n\n}\n", "idx": 3517, "substitutes": {"h": ["hm", "hi", "host", "rh", "l", "hs", "hh", "gh", "sh", "ha", "ht", "p", "w", "s", "hl", "handler", "oh", "v", "ah", "g", "c", "ph", "he", "hr", "eh", "self", "bh", "ch", "ih", "t", "hp", "q", "cl", "u", "f", "history", "e", "http", "hw", "H"], "sl": ["gl", "sw", "flo", "loc", "su", "sc", "sch", "l", "tl", "si", "Sl", "dl", "ssl", "sel", "sh", "pl", "fl", "zh", "isl", "split", "acl", "se", "ln", "sn", "hl", "sa", "SL", "slice", "ul", "lit", "el", "li", "ell", "hel", "oper", "il", "sf", "sil", "sb", "c", "wl", "util", "ll", "bh", "kl", "la", "nl", "t", "rl", "cl", "f", "kel", "sm", "ml", "spl", "serv", "lr", "cel", "sk", "bl", "ls", "lc", "s", "pg"], "mb_type": ["mb_size", "MB_type", "db_family", "mbqid", "mb_id", "mn_size", "MB_types", "mb_length", "mn_TYPE", "db_TYPE", "mb_types", "mb_family", "db_type", "mbqtypes", "mb_TYPE", "mbqlength", "MB_id", "mbqtype", "mn_type", "MB_length", "db_id"], "mb_type_col": ["mb_type_type", "mb_types_type", "mb_types_row", "mb_type_row", "mb_types_column", "mb_type_column", "mb_types_col"], "l1mv0": ["l1mh6", "l1mh2", "l1mh1", "l1cmv0", "l1cmw1", "l1mw0", "l1mx0", "l1cmv1", "l1mh0", "l1mx1", "l1mv6", "l1mw1", "l1mw2", "l1cmw0", "l1mw6", "l1mv2", "l1cmv2", "l1cmv6", "l1mx6", "l1cmw6", "l1mx2", "l1cmw2"], "l1mv1": ["l1mh1", "l1mw0", "l1mb0", "l1dv3", "l1mh0", "l1dv1", "l1mw1", "l1dh0", "l1mh3", "l1mb3", "l1dh1", "l1mw3", "l1dh3", "l1dv0", "l1mb1", "l1mv3"], "l1ref0": ["l1Ref0", "l_reference4", "l_reference0", "l_ref4", "l_ref2", "l_reference2", "l1p4", "l1reference1", "l1ref4", "l1reference4", "l1p2", "l_reference1", "l_ref1", "l1p1", "l_ref0", "l1p0", "l1reference2", "l1Ref1", "l1Ref2", "l1ref2", "l1reference0", "l1Ref4"], "l1ref1": ["l2ref1", "l2f1", "l2ref8", "l1reference1", "l1f8", "l1f1", "l2f8", "l1arc1", "l1arc8", "l1reference8", "l1ref8"], "i8": ["p16", "m6", "u6", "m16", "p6", "u10", "p10", "p8", "m8", "u8", "u16", "i16", "i6", "m10", "i10"], "i4": [" i6", "int6", "i64", "int64", "int8", "l6", "l8", "l4", "l64", "int4", "i6", " i64"], "ref": ["comment", "cal", "val", "cache", "all", "diff", "base", "REF", "def", "rc", "num", "conf", "null", "reference", "aff", "arc", "p", "input", "config", "call", "id", "buffer", "count", "rec", "pos", "row", "pre", "comp", "ef", "info", "block", " reference", "col", "rel", "arg", "inter", "f", "Ref", "range", "pointer", "index"], "mv": ["pmv", "bmq", "mq", "bmv", "mvp", "bmvp", " mj", "pmq", " mvp", "pmvp", "bmj", "pmj", " mq", "mj"], "list": ["gl", "view", "all", "i", "List", "diff", "conf", "key", "group", "table", "len", "count", "feat", "parent", "complete", "CL", "ch", "block", "la", "large", "que", "LIST", "set", "pull", "cont", "see", "l", "null", "p", "config", "call", "name", "load", "ul", "li", "pool", "comp", "test", "map", "hold", "bl", "sync", "lc", "comment", "listed", "com", "base", "chain", "code", "L", "stack", "act", "LI", "queue", "full", "str", "g", "batch", "member", "server", "old", "pre", "pair", "child", "e", "out", "source", "index", "cat", "loop", "cache", "low", "pl", "arr", "module", "cli", "id", "rest", "type", "coll", "self", "like", "cl", "lists", "entry", "record", "seq"], "C": ["U", "S", "JC", "K", "CR", "L", "R", "DC", "V", "CA", "E", "EC", "VC", "D", "G", "LC", "c", "M", "CL", "W", "P", "CM", "O", "FC", "N", "I", "F", "H", "T"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gem_write(void *opaque, target_phys_addr_t offset, uint64_t val,\n\n        unsigned size)\n\n{\n\n    GemState *s = (GemState *)opaque;\n\n    uint32_t readonly;\n\n\n\n    DB_PRINT(\"offset: 0x%04x write: 0x%08x \", offset, (unsigned)val);\n\n    offset >>= 2;\n\n\n\n    /* Squash bits which are read only in write value */\n\n    val &= ~(s->regs_ro[offset]);\n\n    /* Preserve (only) bits which are read only in register */\n\n    readonly = s->regs[offset];\n\n    readonly &= s->regs_ro[offset];\n\n\n\n    /* Squash bits which are write 1 to clear */\n\n    val &= ~(s->regs_w1c[offset] & val);\n\n\n\n    /* Copy register write to backing store */\n\n    s->regs[offset] = val | readonly;\n\n\n\n    /* Handle register write side effects */\n\n    switch (offset) {\n\n    case GEM_NWCTRL:\n\n        if (val & GEM_NWCTRL_TXSTART) {\n\n            gem_transmit(s);\n\n        }\n\n        if (!(val & GEM_NWCTRL_TXENA)) {\n\n            /* Reset to start of Q when transmit disabled. */\n\n            s->tx_desc_addr = s->regs[GEM_TXQBASE];\n\n        }\n\n        if (!(val & GEM_NWCTRL_RXENA)) {\n\n            /* Reset to start of Q when receive disabled. */\n\n            s->rx_desc_addr = s->regs[GEM_RXQBASE];\n\n        }\n\n        break;\n\n\n\n    case GEM_TXSTATUS:\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_RXQBASE:\n\n        s->rx_desc_addr = val;\n\n        break;\n\n    case GEM_TXQBASE:\n\n        s->tx_desc_addr = val;\n\n        break;\n\n    case GEM_RXSTATUS:\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_IER:\n\n        s->regs[GEM_IMR] &= ~val;\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_IDR:\n\n        s->regs[GEM_IMR] |= val;\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_PHYMNTNC:\n\n        if (val & GEM_PHYMNTNC_OP_W) {\n\n            uint32_t phy_addr, reg_num;\n\n\n\n            phy_addr = (val & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;\n\n            if (phy_addr == BOARD_PHY_ADDRESS) {\n\n                reg_num = (val & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;\n\n                gem_phy_write(s, reg_num, val);\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\n    DB_PRINT(\"newval: 0x%08x\\n\", s->regs[offset]);\n\n}\n", "idx": 3521, "substitutes": {"opaque": ["ipesc", "Opque", "OPacity", "Opaque", "opesc", "OPesc", "opoch", "Opoch", "ipaque", "opque", "operoch", "Opesc", "Opacity", "operacity", " opacity", "OPque", " opoch", "OPaque", "ipacity", "opacity", "ipque", "operaque"], "offset": ["order", "required", "phase", "part", "role", "hop", "num", "ref", "alias", "len", "reset", "position", "parent", "layer", "image", "rot", "f", "article", "set", "bit", "sort", "error", "option", "outer", "o", "aligned", "axis", "append", "fee", "et", "mode", "pos", "port", "site", "url", "seed", "slave", "addr", "course", "pointer", "next", "disabled", "base", "ptr", "code", "operation", "Offset", "location", "slice", "length", "server", "address", "index", "attribute", "value", "loc", "attr", "padding", "optional", "alloc", "fp", "enabled", "adjusted", "skip", "off", "prefix", "type", "slot", "initial", "start", "oa", "align", "range", "online", "timeout", "seq"], "val": ["eval", "update", "part", "role", "unit", "alt", "sel", "ref", "key", "stat", "len", "count", "lit", "v", "ut", "il", "sil", "vals", "sol", "block", "rot", "arg", "bit", "cal", "lt", "elt", "p", "valid", "fl", "pal", "buffer", "fee", "buf", "pos", "el", "data", "prop", "bal", "test", "ee", "nil", "fx", "vert", "al", "b", "serv", "live", "bl", "ival", "base", "pr", "fi", "mem", "ret", "ol", "reg", "pre", "sl", "fail", "value", "loc", "pl", "ve", "pt", "Val", "byte", "aval", "split", "Value", "vol", "pret", "dim", "vl", "slot", "pol", "local", "tx", "VAL", "isal", "pass", "x", "lo", "seq"], "size": [" overflow", " count", "ival", " fl", " pri", " index", " address", " len", " af", " slot", " flag", " flags", " length", "len", "pos", " el", " error", " mem", " pos", "vals", " align", " delta", " ret"], "s": ["i", "private", "uns", "conf", "d", "sis", "states", "ps", "secondary", "sb", "sym", "state", "os", "f", "set", "js", "comments", "l", "sites", "si", "is", "o", "y", "p", "ins", "se", "ses", "site", "scope", "b", "sg", "u", "sync", "h", "S", "r", "settings", "hs", "cs", "ssl", "south", "new", "m", "sq", "session", "bs", "service", "g", "your", "server", "ks", "spec", "es", "gs", "t", "aws", "ss", "e", "sl", "ls", "http", "ds", "fs", "su", "sets", "ts", "ns", "n", "services", "a", "sys", "sie", "submit", "sf", "c", "rs", "self", "bis", "client"], "readonly": ["readalone", " readlocked", "weightonly", "loadonly", "weakalone", "rideonly", " readall", "weakOnly", " readforce", "fuljust", "bitforce", "readforce", "rideall", "weakall", "loadOnly", "writall", "Readalone", "readsafe", "Readforce", "weightjust", "readlocked", "Readonly", "fulonly", "loadall", "readjust", "writOnly", "loadsafe", "weightlocked", "weightOnly", "writalone", "writonly", "bitOnly", "ReadOnly", "readall", "fullocked", " readOnly", "rideOnly", " readjust", "Readall", "ridesafe", " readsafe", "weakonly", "fulOnly", "readOnly", "bitonly"], "phy_addr": ["phy___offset", "phy_ptr", "phy67addr", "py_prefix", "phy___addr", "phy___node", "phy___address", "phy_kn", "py_ptr", "py_addr", "py_node", "py_address", "phy67offset", "phy67node", "phy_offset", "py_kn", "py_offset", "phy_prefix", "phy67address", "phy_name", "phy_address", "py_name", "phy_node"], "reg_num": ["reg_number", "reg2num", "REG_orig", "reg_orig", "reg2no", "reg2number", "REG_no", "reg_no", "REG_number", "REG_num", "reg2orig"]}}
{"project": "qemu", "commit_id": "0b1bcb00fb2baf5f3227dd9cd849fa69bf50d7a8", "target": 1, "func": "void cpu_loop(CPUMIPSState *env)\n\n{\n\n    target_siginfo_t info;\n\n    int trapnr, ret;\n\n    unsigned int syscall_num;\n\n\n\n    for(;;) {\n\n        trapnr = cpu_mips_exec(env);\n\n        switch(trapnr) {\n\n        case EXCP_SYSCALL:\n\n            syscall_num = env->active_tc.gpr[2] - 4000;\n\n            env->active_tc.PC += 4;\n\n            if (syscall_num >= sizeof(mips_syscall_args)) {\n\n                ret = -ENOSYS;\n\n            } else {\n\n                int nb_args;\n\n                abi_ulong sp_reg;\n\n                abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0;\n\n\n\n                nb_args = mips_syscall_args[syscall_num];\n\n                sp_reg = env->active_tc.gpr[29];\n\n                switch (nb_args) {\n\n                /* these arguments are taken from the stack */\n\n                /* FIXME - what to do if get_user() fails? */\n\n                case 8: get_user_ual(arg8, sp_reg + 28);\n\n                case 7: get_user_ual(arg7, sp_reg + 24);\n\n                case 6: get_user_ual(arg6, sp_reg + 20);\n\n                case 5: get_user_ual(arg5, sp_reg + 16);\n\n                default:\n\n\n\n                ret = do_syscall(env, env->active_tc.gpr[2],\n\n                                 env->active_tc.gpr[4],\n\n                                 env->active_tc.gpr[5],\n\n                                 env->active_tc.gpr[6],\n\n                                 env->active_tc.gpr[7],\n\n                                 arg5, arg6/*, arg7, arg8*/);\n\n\n\n\n\n\n\n            if ((unsigned int)ret >= (unsigned int)(-1133)) {\n\n                env->active_tc.gpr[7] = 1; /* error flag */\n\n                ret = -ret;\n\n            } else {\n\n                env->active_tc.gpr[7] = 0; /* error flag */\n\n\n            env->active_tc.gpr[2] = ret;\n\n\n        case EXCP_TLBL:\n\n        case EXCP_TLBS:\n\n            info.si_signo = TARGET_SIGSEGV;\n\n            info.si_errno = 0;\n\n            /* XXX: check env->error_code */\n\n            info.si_code = TARGET_SEGV_MAPERR;\n\n            info._sifields._sigfault._addr = env->CP0_BadVAddr;\n\n            queue_signal(env, info.si_signo, &info);\n\n\n        case EXCP_CpU:\n\n        case EXCP_RI:\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = 0;\n\n            queue_signal(env, info.si_signo, &info);\n\n\n        case EXCP_INTERRUPT:\n\n            /* just indicate that signals should be handled asap */\n\n\n        case EXCP_DEBUG:\n\n            {\n\n                int sig;\n\n\n\n                sig = gdb_handlesig (env, TARGET_SIGTRAP);\n\n                if (sig)\n\n                  {\n\n                    info.si_signo = sig;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_TRAP_BRKPT;\n\n                    queue_signal(env, info.si_signo, &info);\n\n\n\n\n        default:\n\n            //        error:\n\n            fprintf(stderr, \"qemu: unhandled CPU exception 0x%x - aborting\\n\",\n\n                    trapnr);\n\n            cpu_dump_state(env, stderr, fprintf, 0);\n\n            abort();\n\n\n        process_pending_signals(env);\n\n", "idx": 3540, "substitutes": {"env": ["enter", "enc", "profile", "conf", "er", "eu", "ec", "eve", "v", "output", "exc", "state", "que", "dev", "f", "environment", "fg", "Environment", "inf", "manager", "esp", "exec", "eni", "config", "dat", "stage", "vm", "cdn", "event", "erv", "data", "site", "eng", "scope", "forge", "init", "args", "nw", "net", "ev", "fi", "context", "ctx", "gear", "eye", "dir", "core", "session", "obj", "queue", "iter", " environment", "engine", "ini", "conn", "txt", "NV", "server", "global", "extra", "e", "esi", "cache", "viron", "api", "py", "end", "ext", "ne", "console", "ea", "sf", "export", "nc", "np", "db", "gui", "qt", "entry", "en"], "info": ["information", "inf", "i", "ui", "diff", "Info", "error", "def", "iso", "fi", "si", "conf", "http", "alias", "fo", "tf", "config", "obj", "id", "api", "status", "qa", "ii", "py", "end", "success", "conn", "type", "tif", "service", "data", "afi", "ami", "ie", "fw", "after", "di", "start", "init", "result", "image", "state", "gi", "f", "ip", "extra", "inner", "entry", "INFO", "index", "desc"], "trapnr": ["tapnum", " trapnor", "tickrn", " trapnum", "trapnom", "trapnum", "tripnor", " trapNR", "traprn", "trapNR", "trapnl", "rapnr", " trapnl", "trapnu", "ticknum", "catchnum", "hubnr", "tapnom", "ticknom", "tripNR", " trapnu", "raprin", "catchnr", "taprn", "rapnum", " traprin", "hubnu", "tickrin", "rapnl", "trapnor", "tripnu", "tapnr", "catchnom", "catchrn", "traprin", "ticknl", "tripnr", "hubnor", "hubNR", "ticknr"], "ret": ["rep", "cat", "val", "res", "part", "back", "en", "match", "fire", "rc", "fi", "def", "rt", "code", "flag", "num", "alt", "fin", "ref", "RET", "mem", "det", "gt", "job", "rev", "status", "red", "pret", "len", "lit", "success", "ext", "rets", "reply", "mt", "fun", "nt", "reg", "xt", "result", "arg", "Ret", "al", "ft", "sat", "re", "bit", "try"], "syscall_num": ["syscallxnum", "sysflow_num", "syscall_number", "syscallablen", "syscall_no", "sysflow_Num", "syscallxn", "sysCall_n", "sysCall_num", "syscallabledim", "syscall_dim", "sysflow_number", "syscallablenumber", "syscall_mn", "sysCall_dim", "syscallxmn", "syscall_Num", "sysCall_number", "sysflow_no", "syscallxoff", "syscall_n", "syscallablenum", "syscall_off"], "nb_args": ["nb67abs", "np_reg", "nb1args", "nb25args", "nb25ass", "nb25params", "nb67params", "bm25params", "nb_resources", "nb_arg", "nb1params", "nb1reg", "nb_reg", "nb25abs", "bn_ass", "nb25items", "nb25num", "nb__params", "np_arg", "bm_abs", "bm_args", "nb__args", "bm_resources", "nb67resources", "bn_args", "nb_num", "bm_params", "nb__reg", "nb_params", "bm25args", "bm25abs", "nb__arg", "nb_ass", "np_args", "nb67args", "nb25resources", "nb_items", "bm25resources", "np_params", "bn_items", "nb1arg", "nb_abs", "bn_num"], "sp_reg": [" sp2register", " sp_rec", "sp2num", " sp_REG", "spacfun", "sp_REG", "sp2REG", "sp5rec", "sp_len", "sp_group", " sp_len", " sp_ref", "sp2conn", "sp_num", "sp_tag", "Sp_fun", "spacreg", "mp_region", "sp5REG", " sp2rec", "sp_region", " sp_tag", "sp2group", "mp_reg", "spacrc", " sp_conn", "sp_conn", "sp_ref", " sp_num", "spacregion", " sp2tag", "sp2register", "sp2len", "Sp_reg", "sp2rec", "sp2region", "sp2tag", "sp2ref", "Sp_region", "Sp_rc", " sp2reg", " sp2REG", "sp2reg", "sp5reg", " sp2ref", "sp5region", " sp2group", " sp_group", "mp_rec", " sp_register", " sp2num", "mp_REG", "sp_fun", "sp_register", "sp_rec", " sp2conn", " sp2len", "sp_rc"]}}
{"project": "FFmpeg", "commit_id": "066ad0926a53ea6ee9d5cb3e348160a881145e73", "target": 1, "func": "static int tmv_read_seek(AVFormatContext *s, int stream_index,\n\n                         int64_t timestamp, int flags)\n\n{\n\n    TMVContext *tmv = s->priv_data;\n\n    int64_t pos;\n\n\n\n    if (stream_index)\n\n        return -1;\n\n\n\n    pos = timestamp *\n\n          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);\n\n\n\n    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);\n\n    tmv->stream_index = 0;\n\n    return 0;\n\n}\n", "idx": 3551, "substitutes": {"s": ["S", "i", "support", "socket", "sets", "ts", "ns", "settings", "cs", "n", "ssl", "o", "p", "src", "d", "m", "sq", "w", "slice", "v", "services", "a", "service", "g", "server", "ses", "spec", "sf", "c", "sb", "es", "self", "gs", "t", "os", "sg", "f", "storage", "aws", "client", "ss", "js", "e", "ls", "http", "ds", "sync"], "stream_index": ["stream_pointer", "streamidlength", "streamidindex", "forward_position", "streamingprefix", " stream_address", "stream_prefix", "stream_source", "forwardidsource", "fileerpointer", "fileerlevel", "streamalindex", "streamflowlength", "forwardidindex", "stream_position", "streamalpointer", "fileerindex", "forward_source", "streamerpointer", "streamallevel", "streamalstring", "streamflowsource", "stream_level", "stream_length", "forward_index", "streamerlevel", "streamidsource", "stream_string", "forward_length", "streamerstring", "file_index", "file_pointer", " stream_prefix", "forwardidlength", "stream_address", "streamingindex", "streamflowindex", "file_level", "streamingaddress", "fileerstring", "streamerindex", "streamflowposition", "file_string", "forwardidposition", "streamidposition"], "timestamp": ["memcision", "timcision", "Timetime", "newestamp", "framcision", " Timmark", "memestamp", " Timeline", "timeline", "newetime", "framestamp", "Timestamp", "timetime", "paramoffset", "Timmark", " Timestamp", "frametime", "memoffset", " Timetime", "newmark", "neweline", "timmark", "paramestamp", "framoffset", "memetime", "Timeline", "parametime", "paramcision", "timoffset"], "flags": ["mask", "xff", "fs", "ms", "ts", "date", "flag", "sec", "bits", "ff", " flag", "time", " positions", "len", "count", "fd", "spec", "port", "vals", " whence", "options", "style", "args", "f", "Flags", "bytes", "seq"], "tmv": ["mmvv", "pmv", "htmver", "mv", "tomf", "mmcf", "mq", "tomcf", "tkv", "tkvv", "mf", "tmq", "tmver", "tluv", "tmg", "tmper", "timper", "tmtv", "mmtv", "TMv", "timov", "tkf", "tmvc", "tcv", "muv", "mtov", "pmcf", "tmcf", "mtg", "tcvv", "tlq", "tmf", "mtper", "mmv", "mmq", "mtv", "tlv", "tomv", "timv", "tlf", "tomov", "htmvv", "tcver", "mmuv", "tomg", "pmvc", "TMver", "tmvv", "htmcf", "htmv", "mmvc", "TMvv", "pmf", "tcf", "tmov", "tomper", "tmuv", "timg", "mmf", "tctv", "tccf", "TMcf", "tomvc", "tktv"], "pos": ["val", "offset", "i", "cache", "part", "neg", "loc", "cond", "patch", "po", "POS", "conf", "o", "p", "pt", "Pos", "min", "pid", "obj", " position", "len", "no", "pad", "mon", "end", "pc", "type", "position", "prop", "slot", "port", "spec", "start", "pres", "block", "rel", "os", "tell", "size", "addr", "pass", "pointer", "seq", "index", "found"]}}
{"project": "qemu", "commit_id": "58d479786b11a7e982419c1e0905b8490ef9a787", "target": 1, "func": "static void bonito_ldma_writel(void *opaque, hwaddr addr,\n                               uint64_t val, unsigned size)\n{\n    PCIBonitoState *s = opaque;\n    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;", "idx": 3555, "substitutes": {"opaque": ["uppalpha", "opac", "observer", "obac", "uppaque", "obaque", "compacity", "uppacity", "ipopaque", "opalpha", "compserver", "opserver", "operacity", "ipopacity", "operalpha", "compaque", "opacity", "operserver", "ipopalpha", "compac", "obacity", "operac", "operaque"], "addr": ["host", "dd", "ost", "offset", "part", "base", "scale", "ac", "hop", "ptr", "cmp", "ord", "ctx", "ref", "src", "node", "dr", "adr", "config", "name", "amd", "ad", "len", "mode", "pos", "holder", "data", "add", "port", "shape", "nr", "start", "ace", "tx", "oa", "align", "address", "x", "pointer", "Address", "index"], "val": ["eval", "all", "value", "base", "loc", "elt", "sel", "valid", "Val", "als", "mem", "aval", "fat", "buffer", "vol", "ol", "len", "stat", "ul", "v", "pos", "el", "data", "slot", "il", "vals", "block", "tx", "VAL", "al", "arg", "b", "sl", "x"], "size": ["offset", "loc", "scale", "ac", "ctx", "unit", "sec", "z", "fee", " length", "len", "v", "data", "length", "ize", "al", "address", " Size", "e", "x", "SIZE", "Size"], "s": ["S", "fs", "socket", "r", "ns", "hs", "si", "ssl", "o", "p", "ips", "m", "sq", "session", "w", "sa", "v", "services", "sys", "service", "ses", "secondary", "sb", "c", "es", "sym", "state", "t", "os", "f", "op", "ss", "e", "sl", "ls", "ops", "sync"]}}
{"project": "FFmpeg", "commit_id": "3d5822d9cf07d08bce82903e4715658f46b01b5c", "target": 1, "func": "static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tp_index,\n\n                                  Jpeg2000CodingStyle *codsty,\n\n                                  Jpeg2000ResLevel *rlevel, int precno,\n\n                                  int layno, uint8_t *expn, int numgbits)\n\n{\n\n    int bandno, cblkno, ret, nb_code_blocks;\n\n    int cwsno;\n\n\n\n    if (layno < rlevel->band[0].prec[precno].decoded_layers)\n\n        return 0;\n\n    rlevel->band[0].prec[precno].decoded_layers = layno + 1;\n\n\n\n    if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) {\n\n        if (*tp_index < FF_ARRAY_ELEMS(tile->tile_part) - 1) {\n\n            s->g = tile->tile_part[++(*tp_index)].tpg;\n\n        }\n\n    }\n\n\n\n    if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES)\n\n        bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH);\n\n\n\n    if (!(ret = get_bits(s, 1))) {\n\n        jpeg2000_flush(s);\n\n        return 0;\n\n    } else if (ret < 0)\n\n        return ret;\n\n\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n        Jpeg2000Band *band = rlevel->band + bandno;\n\n        Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n        if (band->coord[0][0] == band->coord[0][1] ||\n\n            band->coord[1][0] == band->coord[1][1])\n\n            continue;\n\n        nb_code_blocks =  prec->nb_codeblocks_height *\n\n                          prec->nb_codeblocks_width;\n\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n            int incl, newpasses, llen;\n\n\n\n            if (cblk->npasses)\n\n                incl = get_bits(s, 1);\n\n            else\n\n                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;\n\n            if (!incl)\n\n                continue;\n\n            else if (incl < 0)\n\n                return incl;\n\n\n\n            if (!cblk->npasses) {\n\n                int v = expn[bandno] + numgbits - 1 -\n\n                        tag_tree_decode(s, prec->zerobits + cblkno, 100);\n\n                if (v < 0 || v > 30) {\n\n                    av_log(s->avctx, AV_LOG_ERROR,\n\n                           \"nonzerobits %d invalid or unsupported\\n\", v);\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                cblk->nonzerobits = v;\n\n            }\n\n            if ((newpasses = getnpasses(s)) < 0)\n\n                return newpasses;\n\n            av_assert2(newpasses > 0);\n\n            if (cblk->npasses + newpasses >= JPEG2000_MAX_PASSES) {\n\n                avpriv_request_sample(s->avctx, \"Too many passes\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            if ((llen = getlblockinc(s)) < 0)\n\n                return llen;\n\n            if (cblk->lblock + llen + av_log2(newpasses) > 16) {\n\n                avpriv_request_sample(s->avctx,\n\n                                      \"Block with length beyond 16 bits\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            cblk->lblock += llen;\n\n\n\n            cblk->nb_lengthinc = 0;\n\n            cblk->nb_terminationsinc = 0;\n\n            do {\n\n                int newpasses1 = 0;\n\n\n\n                while (newpasses1 < newpasses) {\n\n                    newpasses1 ++;\n\n                    if (needs_termination(codsty->cblk_style, cblk->npasses + newpasses1 - 1)) {\n\n                        cblk->nb_terminationsinc ++;\n\n                        break;\n\n                    }\n\n                }\n\n\n\n                if ((ret = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0)\n\n                    return ret;\n\n                if (ret > sizeof(cblk->data)) {\n\n                    avpriv_request_sample(s->avctx,\n\n                                        \"Block with lengthinc greater than %\"SIZE_SPECIFIER\"\",\n\n                                        sizeof(cblk->data));\n\n                    return AVERROR_PATCHWELCOME;\n\n                }\n\n                cblk->lengthinc[cblk->nb_lengthinc++] = ret;\n\n                cblk->npasses  += newpasses1;\n\n                newpasses -= newpasses1;\n\n            } while(newpasses);\n\n        }\n\n    }\n\n    jpeg2000_flush(s);\n\n\n\n    if (codsty->csty & JPEG2000_CSTY_EPH) {\n\n        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)\n\n            bytestream2_skip(&s->g, 2);\n\n        else\n\n            av_log(s->avctx, AV_LOG_ERROR, \"EPH marker not found. instead %X\\n\", bytestream2_peek_be32(&s->g));\n\n    }\n\n\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n        Jpeg2000Band *band = rlevel->band + bandno;\n\n        Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;\n\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n            for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) {\n\n                if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno]\n\n                    || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4\n\n                ) {\n\n                    av_log(s->avctx, AV_LOG_ERROR,\n\n                        \"Block length %\"PRIu16\" or lengthinc %d is too large, left %d\\n\",\n\n                        cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g));\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]);\n\n                cblk->length   += cblk->lengthinc[cwsno];\n\n                cblk->lengthinc[cwsno] = 0;\n\n                if (cblk->nb_terminationsinc) {\n\n                    cblk->nb_terminationsinc--;\n\n                    cblk->nb_terminations++;\n\n                    cblk->data[cblk->length++] = 0xFF;\n\n                    cblk->data[cblk->length++] = 0xFF;\n\n                    cblk->data_start[cblk->nb_terminations] = cblk->length;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 3561, "substitutes": {"s": ["S", "i", "fs", "sv", "sets", "sc", "su", "ts", "ns", "l", "r", "cs", "si", "is", "sites", "sec", "sup", "ssl", "o", "conf", "south", "p", "http", "src", "input", "d", "m", "sq", "session", "se", "ds", "side", "v", "services", "sys", "service", "g", "server", "ses", "spec", "sf", "c", "sb", "site", "self", "es", "scope", "rs", "gs", "sym", "t", "b", "f", "sg", "os", "u", "ss", "js", "e", "sl", "bis", "ls", "ops", "client", "sk", "sync"], "tile": ["tle", "tp", "sample", "grid", "scale", "device", "google", "grade", "ge", "uri", "pixel", "square", "node", "tf", "ite", "tk", "tg", "note", "stone", "table", "slice", "file", "ele", "service", "coll", "txt", "ie", "Tile", "tu", "flat", "sf", "port", "game", "site", "plane", "gb", "target", "layer", "kt", "texture", "image", "phy", "feature", "ilo", "song", "league", "ole", "address", "skill", "sl", "sky", "chip", "surface", "zone", "tif"], "tp_index": ["lp_Index", "lp_number", "tp_Index", "tk_pointer", "tp_number", "tp_offset", "tp_role", "tf_part", "tp_value", "tf_Index", "tp__number", "tp__value", "tp_pointer", "tp__index", "tf_offset", "tp__Index", "tk_index", "lp_value", "tp_key", "tk_key", "tp_part", "tk_role", "lp_index", "tf_index"], "codsty": ["codety", "condrs", "codys", "odrs", "codestyle", "cmdrs", "cmdety", "odestyle", "odys", "odety", "cmdys", "codrs", "condys", "cmdestyle", "condety", "condestyle"], "rlevel": ["rilog", "srrule", "ristage", " rletter", "bfl", "rilayer", "bletter", "rflevel", "rilevel", "plog", "rale", "erlevel", "blevel", "clevel", "perscope", " rfl", "rstage", " rlocal", "rfl", "srvel", " rvel", "prlevel", "rLevel", "pstage", "rrule", "rflocal", " rale", "prfl", "perlevel", "rlayer", "srlog", "ervel", "rlevels", "rvel", "rlocal", "pervel", "plevel", "crule", "rarletter", "perale", "prlocal", "rffl", "pscope", "rscope", "srlevel", "rlog", "pvel", "cpc", "blevels", "rarfl", "prLevel", "erpc", "rarlevels", "rpc", "srpc", "player", "srlayer", "pale", "errule", "rfLevel", " rlevels", "srstage", "rarlevel", "cvel", " rscope", " rLevel", "rletter"], "precno": ["PrecNo", "prelNO", "Precnos", "pefeno", "procNO", "prepno", "prelNo", "procno", "perfnos", "precsno", "pregno", "Precnum", "prelno", "percnos", "pecno", "propnumber", "pecNO", "precNO", "pregNO", "preznone", "propNO", "Prefno", "precceno", "prelnumber", "precnone", "precnum", "prefNo", "perfno", "pefNO", "preccno", "procnumber", "peceno", "preccNO", "prefnos", "prepnumber", "prelnos", "pregeno", "propnone", "pefnum", "percNO", "prepnone", "precNo", "precnumber", "prelnum", "preznumber", "preceno", "prepNO", "precsnum", "prezNO", "prelnone", "PrefNo", "pecnum", "pregnum", "prefNO", "precsnos", "perfeno", "prezno", "perfNO", "propno", "Precno", "precnos", "precsNo", "prefeno", "Prefnos", "preleno", "procnone", "percno", "prefnum", "preccnos", "perceno", "pefno", "prefno", "Prefnum"], "layno": ["lbnr", "playnor", "cpunumber", "linnor", "langnor", "layernos", "playnos", "cpuno", "langno", "laynos", "linno", "laynumber", "langnos", "colno", "langNo", "cpunor", "cpunos", "linnumber", "colnos", "layerno", "laynr", "layernr", "lbNo", "layNo", "linnos", "colyes", "layerNo", "colnor", "langyes", "langnumber", "playyes", "laynor", "layernor", "playno", "langnr", "lbnumber", "lbno", "layyes", "layernumber"], "expn": ["condnum", "condn", "expnt", "expno", "xpnt", "expnum", "condno", "playno", "playnum", "xpnum", "playn", "xpn", "xpno", "condnt", "playnt"], "numgbits": ["numGbytes", "numgbbits", "numbbit", "numgbbytes", "numgits", "numGits", " numGbit", " numgbytes", " numgits", "numgbbit", "numbits", " numGbits", " numGits", "numgbit", "numbbits", "numbbytes", "numGbit", "numgbytes", " numgbit", "numGbits", " numGbytes"], "bandno": ["bandorno", "fieldnumber", "groundorno", "laynum", "bandnor", " bandnum", " bandorno", "bandsha", "pluginno", "bootname", "bootino", "laynu", "bootsha", " bandnumber", "busno", "bandnone", " bandino", "bootno", " bandname", "busorno", "tagsha", "portnu", " bandnos", "pluginnone", "tagnor", "groundnone", "brandno", "brandnumber", "brandnor", "groundname", "bandnumber", "bandNo", "brandsha", "groundno", "busnumber", "fieldino", "fieldno", "bandnu", "bandnum", "layNo", "groundnos", "bandino", "portNo", "pluginname", " bandnu", "tagnumber", "bandnos", "bandname", "groundNo", "bootnumber", "fieldname", " bandNo", "bootnor", "busNo", "portno", "pluginnos", " bandnone", "tagno", "groundnumber", "portnum"], "cblkno": ["cblskno", "cmapklno", "cblknu", "cblkyNo", "cblkid", "cblckno", "cplkkNO", "cplkno", "cblknon", "cblKnumber", "cblznu", "cblkidid", "cblkidnum", "cBlklo", "cllkid", "cblklno", "cblkNo", "cclkyna", "cblzno", "cllknumber", "cllkno", "cblksnone", "cblkyeno", "cmapknum", "cllknum", "cblkgno", "cmapklnon", "cclkNo", "cblkgnone", "cclkyno", "cllkidid", "cblkna", "cblKno", "cblqno", "cmapkno", "cblckNo", "cblkidno", "cblkidni", "cclkyNo", "cBlckni", "cBlckNo", "cblknumber", "cmapknon", "cblklnon", "cblksno", "cplkknu", "cblqnumber", "cblkyno", "cblKid", "cblknone", "cblckni", "cblflo", "cblkidlo", "cblfNo", "cblckna", "cplkNO", "cblsknu", "cblkknumber", "cclkno", "cclkyeno", "cllkidnum", "cplknumber", "cblzNO", "cblznumber", "cblckeno", "cblfno", "cblskNO", "cBlkni", "cBlkno", "cBlckno", "cblkeno", "cmapknone", "cplknu", "cllkidnumber", "cblksnon", "cblkkno", "cblknum", "cmapklnone", "cplkknumber", "cblkidna", "cblkideno", "cblkgnon", "cblklo", "cBlcklo", "cplkkno", "cBlkNo", "cblkidNo", "cblKnum", "cblcklo", "cblqnum", "cblklnone", "cblkidnumber", "cblklnum", "cmapklnum", "cblkni", "cclkeno", "cblsknumber", "cblkknu", "cblkkNO", "cclkna", "cblkyna", "cllkidno", "cblfni", "cblksnum", "cblkNO", "cblqid", "cblkgnum"], "ret": ["bf", "val", "res", "bad", "value", "pat", "back", "match", "pet", "def", "att", "rt", "flag", "resp", "alt", "valid", "fin", "ref", "RET", "arr", "mem", "det", "id", "pret", "len", "no", "lit", "ut", "success", "ext", "rets", "feat", "str", "reply", "txt", "sil", "fun", "sb", "reg", "xt", "result", "arg", "Ret", "ft", "cur", "re", "bis", "out", "bit", "en"], "nb_code_blocks": ["nb_call_block", "nb_code_units", "nb_call_bits", "nb_line_cycles", "nb_code64cycles", "nb_code_bits", "nb_code2block", "nb_code64blocks", "nb_code64block", "nb_call_frames", "nb_codepblocks", "nb_codepunits", "nb_call_blocks", "nb_codepblock", "nb_call_units", "nb_code_groups", "nb_code2frames", "nb_line_blocks", "nb_code_frames", "nb_line_block", "nb_code64groups", "nb_code_block", "nb_line_groups", "nb_code2units", "nb_code2blocks", "nb_code_cycles", "nb_codepframes"], "cwsno": [" cwsNO", "cwddo", " cwsdo", "cwlNO", " cwdno", "cwdNO", "cwbno", "cwsdo", "cwlname", "cwbname", "cwdno", "cwdname", " cwsname", "cwlno", "cwldo", "cwsname", "cwbNO", " cwdname", "cwsNO", " cwddo", " cwdNO", "cwbdo"], "band": ["field", "phase", "part", "match", "unit", "leg", "group", "number", "nn", "d", "vision", "bound", "period", "bus", "v", "position", "output", "layer", "plugin", "boot", "image", "channel", "gap", "cost", "component", "coord", "bit", "station", "host", "node", "stage", "mode", "event", "point", "web", "board", "Band", "b", "song", "tag", "zone", "line", "track", "project", "patch", "device", "disk", "flag", "cell", "product", "session", "ground", "nb", "service", "usb", "batch", "day", "plane", "audio", "back", "low", "road", "filter", "connection", "byte", "module", "bridge", "word", "guide", "class", "broad", "frame", "co", "direction", "gb", "flow", "book", "bin", "db", "version", "range", "record"], "prec": ["arec", "perp", "pere", "Prel", "prl", "Precs", " precs", "Preb", "precr", " prep", "produc", "Precr", "Prec", "Pref", " preb", "pric", "percr", "Pree", "arep", " precc", "precs", "arecs", "aref", "preg", "percs", "Prep", " pref", "prip", "prib", " preg", "prep", "produg", "procs", "prcc", "prf", "perc", "precc", "pre", "prel", "Precc", "pref", "procr", "prof", "producs", "perf", "proc", "produf", "prif", "pree", "prc", "perl", "perg", "preb", " pree"], "cblk": ["cblc", "Cflk", "cbrf", "cBLk", "cbrq", "Cflke", " cplq", "Cflc", "Cblc", "cBLkt", "cbrkt", "cplkt", "cblf", "Cflf", "cbrk", " cblq", "cbrke", "cplc", "cflf", " cplkt", "cplq", "cflk", "Cblf", " cplf", " cblkt", "Cblk", "cflke", "cBLq", "cblkt", "cblq", " cblf", "cblke", " cplk", "Cblke", "cplke", "cbrc", "cplk", "cflc", "cplf", "cBLf"], "incl": ["in0", "inf", "incf", "inc\t", "out\t", "out\n", "in\n", "outf", " in0", "in\t", " in\t", "inc\n", "out0", " inf", " in\n", "inc0"]}}
{"project": "qemu", "commit_id": "bba4e1b591531c087fce4ae501dc1ca299d8fb42", "target": 1, "func": "static void curses_refresh(DisplayChangeListener *dcl)\n\n{\n\n    int chr, nextchr, keysym, keycode, keycode_alt;\n\n\n\n    curses_winch_check();\n\n\n\n    if (invalidate) {\n\n        clear();\n\n        refresh();\n\n        curses_calc_pad();\n\n        graphic_hw_invalidate(NULL);\n\n        invalidate = 0;\n\n    }\n\n\n\n    graphic_hw_text_update(NULL, screen);\n\n\n\n    nextchr = ERR;\n\n    while (1) {\n\n        /* while there are any pending key strokes to process */\n\n        if (nextchr == ERR)\n\n            chr = getch();\n\n        else {\n\n            chr = nextchr;\n\n            nextchr = ERR;\n\n        }\n\n\n\n        if (chr == ERR)\n\n            break;\n\n\n\n#ifdef KEY_RESIZE\n\n        /* this shouldn't occur when we use a custom SIGWINCH handler */\n\n        if (chr == KEY_RESIZE) {\n\n            clear();\n\n            refresh();\n\n            curses_calc_pad();\n\n            curses_update(dcl, 0, 0, width, height);\n\n            continue;\n\n        }\n\n#endif\n\n\n\n        keycode = curses2keycode[chr];\n\n        keycode_alt = 0;\n\n\n\n        /* alt key */\n\n        if (keycode == 1) {\n\n            nextchr = getch();\n\n\n\n            if (nextchr != ERR) {\n\n                chr = nextchr;\n\n                keycode_alt = ALT;\n\n                keycode = curses2keycode[nextchr];\n\n                nextchr = ERR;\n\n\n\n                if (keycode != -1) {\n\n                    keycode |= ALT;\n\n\n\n                    /* process keys reserved for qemu */\n\n                    if (keycode >= QEMU_KEY_CONSOLE0 &&\n\n                            keycode < QEMU_KEY_CONSOLE0 + 9) {\n\n                        erase();\n\n                        wnoutrefresh(stdscr);\n\n                        console_select(keycode - QEMU_KEY_CONSOLE0);\n\n\n\n                        invalidate = 1;\n\n                        continue;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        if (kbd_layout) {\n\n            keysym = -1;\n\n            if (chr < CURSES_KEYS)\n\n                keysym = curses2keysym[chr];\n\n\n\n            if (keysym == -1) {\n\n                if (chr < ' ') {\n\n                    keysym = chr + '@';\n\n                    if (keysym >= 'A' && keysym <= 'Z')\n\n                        keysym += 'a' - 'A';\n\n                    keysym |= KEYSYM_CNTRL;\n\n                } else\n\n                    keysym = chr;\n\n            }\n\n\n\n            keycode = keysym2scancode(kbd_layout, keysym & KEYSYM_MASK);\n\n            if (keycode == 0)\n\n                continue;\n\n\n\n            keycode |= (keysym & ~KEYSYM_MASK) >> 16;\n\n            keycode |= keycode_alt;\n\n        }\n\n\n\n        if (keycode == -1)\n\n            continue;\n\n\n\n        if (qemu_console_is_graphic(NULL)) {\n\n            /* since terminals don't know about key press and release\n\n             * events, we need to emit both for each key received */\n\n            if (keycode & SHIFT) {\n\n                qemu_input_event_send_key_number(NULL, SHIFT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & CNTRL) {\n\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALT) {\n\n                qemu_input_event_send_key_number(NULL, ALT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALTGR) {\n\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n\n\n            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, true);\n\n            qemu_input_event_send_key_delay(0);\n\n            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, false);\n\n            qemu_input_event_send_key_delay(0);\n\n\n\n            if (keycode & ALTGR) {\n\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALT) {\n\n                qemu_input_event_send_key_number(NULL, ALT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & CNTRL) {\n\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & SHIFT) {\n\n                qemu_input_event_send_key_number(NULL, SHIFT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n        } else {\n\n            keysym = curses2qemu[chr];\n\n            if (keysym == -1)\n\n                keysym = chr;\n\n\n\n            kbd_put_keysym(keysym);\n\n        }\n\n    }\n\n}\n", "idx": 3582, "substitutes": {"dcl": ["dcbl", "dbl", " docl", "DCL", "fscl", "Docl", "Dscl", "dcfl", "fCL", "Dcl", "dcCl", "dccl", "dfl", "focl", "dCL", " dbl", "dscl", " dCL", "Dbl", "docl", "DCl", "dCl", "Dfl", " dCl", " dfl", " dscl", "fcl"], "chr": [" chrc", "chrb", "corrc", "cherc", "schrb", "phrn", "schrc", " chp", "chare", "chec", "shR", "ichrf", "CHr", "chep", " chlr", "charrc", "chanr", " chrb", "chlr", "chertr", "chadr", "charar", "grR", "chynr", " chadr", "shar", "ichnr", "chere", "cherf", "ichR", "ichp", "chp", "cher", "phnr", " chrg", "cherr", "chpr", "charpr", "charre", "chari", "grr", "charrb", "chyr", "CHpr", "chrg", "ichar", "chri", "charnr", "chytr", "cheR", "shr", "chre", "ichrg", "ichadr", "chrf", "chsr", "corr", " chtr", "chtr", "ichtr", "chc", "qr", " chpr", "chrn", "shrg", "chartr", "schrg", "charrf", "schr", " chrf", " chrn", "shrb", "ichr", "ichrb", "chelr", "cherb", "chnr", "charrn", "chR", "qri", "ichlr", "chyrf", "chrc", "qre", "cornr", "chetr", "grrc", "cherR", "phr", " chnr", "charri", "phrf", "charlr", "charr", "qnr", " chc", " chR", "chesr", "shlr", "cherg", "charsr", "CHar", "chenr", "ichc", "grtr", "ichrc", "CHrb", " chre", "cherre", "charadr", "corsr"], "nextchr": ["firstchrs", "lastchnr", " nextChp", " nextChri", "nextarchr", "startchr", "nextChR", "nextcher", "nextcharrs", "nextChrb", " nextchrl", "currentchry", "nextchenr", " nextchrs", "nextcherc", "nextichr", "nextchrc", "nextchrl", "nextcherre", "currentcharr", "nextcharc", "nextachrf", "nextachn", "lastchrb", "nextchrs", "nextechrs", "firstchr", " nextChr", "nextarchrt", " nextChnr", "nextachr", "nextcorrb", "lastcherc", "nextichrb", "nextchn", "startchrf", "nextcorrl", "firstachrs", " nextchrb", "nextcurrf", "nextechr", "startachn", "nextarchrs", "nextcherb", "startchrb", "nextCHnr", "nextChrc", "nextcharR", "firstchrt", "nextcorrc", "nextchary", " nextcorrb", "startachr", "nextChp", "nextachra", "lastcharr", "startachrf", "nextchp", "nextChnr", "lastcharrs", "startachrb", "nextcorr", "nextcharb", " nextchri", "lastchr", " nextchrt", "nextChri", "lastchenr", "nextcharl", "nextechri", "firstachrt", "nextachrb", "nextchers", "startchn", " nextChrs", "nextcharnr", "currentcharnr", "nextChr", "nextchry", " nextchnr", "nextcornr", "nextcharr", "nextCHr", " nextChre", "nextchrb", "nextChra", "nextcharrb", "nextchep", "nextchre", " nextChrb", "lastchers", " nextchR", " nextchre", "lastchrs", " nextchp", "firstchrb", "currentcharrc", "nextachrs", "currentchnr", "nextchert", "nextchri", "nextchrt", " nextChra", "currentchrc", " nextcornr", "nextcorrs", "nextChrs", "nextcherri", " nextcorr", "lastchrc", "nextchery", "nextCHrs", " nextChrt", "firstachr", "nextichrs", "nextchar", "nextarchra", "nextChrt", "currentchr", "nextCHR", "nextChre", "firstachrb", "nextchen", "nextichp", "lastcher", "nextcurr", "lastcharrb", "nextchnr", "nextcherf", " nextcorrl", "nextcherr", "nextcharrc", " nextChR", "nextcurrb", " nextchra", "nextcherrs", "nextcharry", "nextchR", "nextcurn", "currentcharry", "nextcherl", "nextchanr", "nextchra", "nextechre", "nextachrt", "lastcharrc", "nextchrf"], "keysym": ["rotsym", "ysymm", "keysyn", "ksys", "keyyp", "ysym", "keyyr", " keysymm", "lightsyp", "ksyn", "opensyp", "lesyd", "opensyr", "keyym", "gesyd", "rowsys", "kesy", "lightsyr", " keysm", "keysm", "lightsy", " keysyd", " keysys", "lightsyn", "ksyd", "kesym", "rotsyd", "ysm", "opensyd", "kesyp", "rotsyr", "keyy", "Keysym", "gesym", "rowsym", "lesyr", "keysys", "ksymm", "gesm", " keysyn", "rowsymm", " keysy", "opensym", "lightsym", "Keysys", "kesymm", "ysyd", " keysyp", "opensy", "rowsy", "lesym", "kesyr", "ksyr", "ksym", "keysyr", "Keysymm", "keysy", "ksyp", "keysyd", "keysyp", "kesys", "ksy", "Keysy", "lesyp", "keysymm", "rotsyp", " keysyr", "gesymm"], "keycode": ["keyCode", "typecycle", "callcode", "charcodes", "charp", "charco", "colcod", "keyvalue", "Keycycle", "keyc", "Keycod", "rulecod", "vercode", "Keycount", "locknum", " keycycle", "keyp", "charc", "kecycle", "charcat", "keycoded", "typecount", " keyfunc", " keyCode", "callcat", "fieldCode", " keycoded", " keycat", "kecod", "charcode", "typecode", "keycat", "charfunc", "hashcoded", " keyp", "colcode", "rowcode", "keycycle", "keynum", "lockcode", "typecod", "hashCode", "charvalue", "lockcod", "charcoded", "vercount", "rowcodes", "charconst", "rowCode", "fieldnum", "keyconst", "keycount", "rulecycle", "colc", "keyfunc", "rowcat", " keyconst", "hashcode", "fieldcode", "callfunc", "keycod", "lockCode", "callc", "keycodes", "kecode", "vercycle", "charnum", " keyco", " keyc", "kec", " keynum", "vercod", "keyco", "fieldco", "changecode", "Keycode", "charcod", " keycodes", "colconst", " keycod", "charCode", "changevalue", "changeCode", "rulecode", "rulec", "hashp", " keyvalue"], "keycode_alt": ["keycode_ret", "keycode_text", "keycodes_Alt", "keyc_text", "keycodexalt", "keycodexALT", "keycode_ALT", "keycode_att", "keyc_ret", "keycode_Alt", "keycodes_ret", "keyc_flat", "keyc_att", "keycodexflat", "keyc_ALT", "keycodes_alt", "keycodes_ALT", "keyc_alt", "keycodexatt", "keycode_flat"]}}
{"project": "FFmpeg", "commit_id": "b84a7330af41cec93384bf59ed68c67b09d105cd", "target": 1, "func": "static int64_t read_ts(char **line, int *duration)\n\n{\n\n    int64_t start, end;\n\n\n\n    if (sscanf(*line, \"%\"SCNd64\",%\"SCNd64, &start, &end) == 2) {\n\n        *line += strcspn(*line, \"\\\"\") + 1;\n\n        *duration = end - start;\n\n        return start;\n\n    }\n\n    return AV_NOPTS_VALUE;\n\n}\n", "idx": 3596, "substitutes": {"line": ["comment", "user", "offset", "text", "base", "l", "code", "cell", "le", "lin", "letter", "key", "byte", "name", "id", "buffer", "word", "time", "len", "Line", "slice", "LINE", "frame", "el", "file", "li", "ine", "row", "lines", "url", "body", "block", "nl", "lo", "range", "side", "e", "page", "pass", "sl", "lane", "entry", "lf", "lc", "link", "source", "rule"], "duration": ["offset", "i", "series", "Duration", "context", "date", "unit", "uri", "relative", "trace", "document", "number", "d", "delay", "m", "sequence", "stage", "time", "len", "pad", "event", "v", "video", "length", "since", "until", "port", "during", "after", "between", "gap", "doc", "range", "span", "timeout", "repeat"], "start": ["next", "offset", "i", "series", "base", "date", "from", "n", "st", "p", "begin", "index", "ind", "d", "se", "name", "id", "source", "time", "ad", "len", "run", "pad", "stop", "pos", "x", "type", "str", "data", "mid", "ie", "length", "ize", "c", "in", "origin", "read", "info", "init", "ace", "gap", "started", "cur", "Start", "range", "ip", "set", "span", "parse", "use", "it", "ce", "step", "art"], "end": ["offset", "all", "i", " extend", "date", "END", "n", "begin", "p", "nd", "ind", "append", "edge", "se", "limit", "id", "z", "time", "len", "stop", "pos", "type", "est", "data", "length", "port", "c", "ending", "End", "max", "range", "set", "address", "e", "size", "ended", "en", "index"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void raven_class_init(ObjectClass *klass, void *data)\n\n{\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->init = raven_init;\n\n    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;\n\n    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;\n\n    k->revision = 0x00;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"PReP Host Bridge - Motorola Raven\";\n\n    dc->vmsd = &vmstate_raven;\n\n    dc->no_user = 1;\n\n}\n", "idx": 3598, "substitutes": {"klass": ["kickclass", "kicklf", "kcl", "Kcl", "sklass", "Kclass", "skclass", "oklass", "kclass", " klasses", "skull", "kickazz", "kazz", " klf", "Klf", "skcl", "Kull", " kazz", "klasses", " kclass", "okcl", "kicklass", "Kazz", "okclass", "skazz", "sklasses", "kull", " kcl", "klf", "Klass", "Klasses", "okull"], "data": ["dd", "i", "cc", "create", "device", "def", "Data", "context", "input", "raw", "config", "m", "dat", "df", "rec", "parent", "info", "result", "DATA", "db", "dev", "json", "da", "reader", "record", "params"], "k": ["ek", "kw", "ko", "ke", "K", "ok", "ik", "device", "cs", "o", "kind", "p", "ijk", "kk", "key", "ka", "d", "m", "tk", "kick", "dk", "g", "kid", "kr", "ks", "c", "mk", "self", "kt", "kn", "ck", "q", "f", "u", "sk", "ku", "ki", "kin", "uk"], "dc": ["cc", "disc", "sc", "cf", "ac", "device", "rc", "de", "fc", "ec", "d", "config", "acc", "DC", "tk", "dat", "design", "df", "tc", "cdn", "dk", "pc", "c", "dt", "nc", "di", "mc", "ck", "db", "cmd", "doc", "da", "director", "bc", "ds", "lc", "cd", "desc"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void pci_add_option_rom(PCIDevice *pdev, bool is_default_rom,\n\n                               Error **errp)\n\n{\n\n    int size;\n\n    char *path;\n\n    void *ptr;\n\n    char name[32];\n\n    const VMStateDescription *vmsd;\n\n\n\n    if (!pdev->romfile)\n\n        return;\n\n    if (strlen(pdev->romfile) == 0)\n\n        return;\n\n\n\n    if (!pdev->rom_bar) {\n\n        /*\n\n         * Load rom via fw_cfg instead of creating a rom bar,\n\n         * for 0.11 compatibility.\n\n         */\n\n        int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE);\n\n\n\n        /*\n\n         * Hot-plugged devices can't use the option ROM\n\n         * if the rom bar is disabled.\n\n         */\n\n        if (DEVICE(pdev)->hotplugged) {\n\n            error_setg(errp, \"Hot-plugged device without ROM bar\"\n\n                       \" can't have an option ROM\");\n\n            return;\n\n        }\n\n\n\n        if (class == 0x0300) {\n\n            rom_add_vga(pdev->romfile);\n\n        } else {\n\n            rom_add_option(pdev->romfile, -1);\n\n        }\n\n        return;\n\n    }\n\n\n\n    path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile);\n\n    if (path == NULL) {\n\n        path = g_strdup(pdev->romfile);\n\n    }\n\n\n\n    size = get_image_size(path);\n\n    if (size < 0) {\n\n        error_setg(errp, \"failed to find romfile \\\"%s\\\"\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    } else if (size == 0) {\n\n        error_setg(errp, \"romfile \\\"%s\\\" is empty\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    }\n\n    size = pow2ceil(size);\n\n\n\n    vmsd = qdev_get_vmsd(DEVICE(pdev));\n\n\n\n    if (vmsd) {\n\n        snprintf(name, sizeof(name), \"%s.rom\", vmsd->name);\n\n    } else {\n\n        snprintf(name, sizeof(name), \"%s.rom\", object_get_typename(OBJECT(pdev)));\n\n    }\n\n    pdev->has_rom = true;\n\n    memory_region_init_ram(&pdev->rom, OBJECT(pdev), name, size, &error_abort);\n\n    vmstate_register_ram(&pdev->rom, &pdev->qdev);\n\n    ptr = memory_region_get_ram_ptr(&pdev->rom);\n\n    load_image(path, ptr);\n\n    g_free(path);\n\n\n\n    if (is_default_rom) {\n\n        /* Only the default rom images will be patched (if needed). */\n\n        pci_patch_ids(pdev, ptr, size);\n\n    }\n\n\n\n    pci_register_bar(pdev, PCI_ROM_SLOT, 0, &pdev->rom);\n\n}\n", "idx": 3602, "substitutes": {"pdev": ["qdev", "pcdiv", "tdevice", "prdevice", "nrav", "predevice", "Pdevelopment", "prvalid", " pconf", "cdc", "ndef", "nvar", "pcdc", "perad", "cdef", " pdiv", "updiv", "fdevice", "lprav", " pev", "ipdevice", "fde", "jconn", "pconf", "Pdef", "pserv", "ndi", "pde", "pdf", "cengine", "lpwd", "prwd", "ndd", "cde", "pev", "vserv", "pdi", "spserv", "pcdevice", "predevelopment", "ndevelopment", " pcam", "pvar", "ppserv", "lprad", "copdevice", "pdef", "lpvalid", "npdebug", "pdebug", "fdev", "pdevice", "prede", " pconn", "cconf", " pdef", "lpdef", "npvar", "ipdiv", "fdef", "pdevelopment", "lpdiv", "prdf", "ppdef", "ceng", "pcengine", "Pdiv", "pcdevelopment", "updev", "ppdevelopment", " pdevice", "jev", "preng", "npdev", "opdevice", "spdev", "cdevice", "ppvar", "ppdevice", "prav", "ppdiv", "qdevice", "copdevelopment", "prevar", "pengine", "opdiv", "Pdevice", "ndev", "lpdc", "nde", "spdebug", " pdf", "prcam", "Pdev", "fdiv", "qdef", "lpdev", "pcvar", "pDEV", "peng", "lpdevice", "tdev", " pvar", " pdebug", "pdc", " pde", "ndc", "prdef", "upDEV", "tdf", "nver", "cpdevice", "lpdebug", "cdiv", "prev", "opdef", "ndevice", "cdev", "vrad", "pdiv", "sprad", "copdev", "pconn", " pvalid", "ppdebug", "jdev", "ccam", "pevar", "preev", "copdi", "ppdi", "Pev", "qconf", "cpdef", "prdev", "cev", "Pver", "predev", "ndiv", "lpvar", " pwd", "fdd", "qde", "vdebug", "tdiv", "pprad", "ipvar", "pver", "nDEV", "preconn", "ppdc", "prdiv", "pcdev", "pvalid", "ppdev", "opdev", "qver", "prediv", "jde", "Peng", "pedev", "cpdev", "ipdev", "lpDEV", "prad", "uprav", "nprad", "vdev", "lpengine", "pwd", "pcam", "pdd", "pedebug", "cpdiv", "lpdd", "qdebug"], "is_default_rom": ["is_default_chrom", "is_no_chrom", "is_no2mode", "is_no2ram", "is_default_ram", "is_default_mode", "is_no_ram", "is_no_mode", "is_no2chrom", "is_no2rom", "is_default2ram", "is_default2mode", "is_no_rom", "is_default2rom", "is_default2chrom"], "errp": ["ererwp", "serpr", "yrp", "ferpa", "erb", "errr", "yrwp", "erd", "Errorpa", "finderb", "ererp", "Erp", "iterp", "errpr", "Errorp", "Errorc", "finderr", "errpe", "errfp", " errd", "errP", "errlp", "errb", "Erpe", "ErP", "Erfp", "ferp", "serwp", "rrpi", "serlp", "errwp", "errd", "erp", "ferc", "errc", "serp", " errb", " errP", "finderp", "Errorpi", "yrpr", "errpi", "iterfp", "ererpr", " errpe", "iterP", "yrlp", "errpa", "iterpe", "err", " errr", "rrp", " errfp", "ferpi", "rrc", "ererlp", "finderd", "rrpa"], "size": ["i", "unit", "sec", "number", "sum", "sn", "len", "count", "ize", "weight", "large", "page", "go", "iz", "sized", "Size", "ice", "ui", "si", "p", "security", "fee", "time", "mode", "now", "speed", "style", " sizes", "sync", "SIZE", "ny", "code", "function", "core", "sh", "capacity", "full", "year", "g", "member", "length", "shape", "address", "e", "use", "empty", "cache", "value", "loc", "scale", "form", "n", "crop", "any", "class", "mini", "esc", "type", "c", "body", "small", "storage", "handle", "range", "x", "en"], "path": ["user", "cache", "home", "text", "PATH", "part", "bug", "loc", "rh", "content", "po", "context", "enc", "code", "uri", "ctx", "binary", "temp", "dir", "p", "trace", "anc", "index", "ref", "location", "alias", "key", "root", "node", "ath", "folder", "raw", "config", "connection", "call", "id", "entry", "time", "route", "method", "slice", "full", "link", "loader", "type", "file", "clean", "prop", "sign", "parent", "length", "work", "shape", "progress", "c", "url", "test", "Path", "image", "box", "cmd", "resource", "child", "inner", "pointer", "sync", "source", "desc"], "ptr": ["mount", "val", "offset", "rb", "tty", "loc", "attr", "inst", "rc", "fi", "grad", "ctx", "pointers", "pt", "trace", "alloc", "exec", "ref", "src", "ig", "dr", "adr", "buffer", "buf", "len", "slice", "pos", "ext", "fd", "str", "port", "scope", "args", "que", "err", "address", "lr", "addr", "bc", "pointer", "br"], "name": ["mask", "part", "create", "num", " names", "key", "alias", "number", "title", "len", "parent", "info", "block", "image", "cap", "large", "dev", "space", "filename", "host", "error", "option", "null", "Name", "node", "call", "time", "pos", "data", "port", "url", "comment", "nm", "base", "ame", "code", "new", "mem", "w", "full", "str", "member", "package", "shape", "global", " NAME", "address", "child", "desc", "val", "cache", "value", "n", "nice", "connection", "names", "id", "word", "memory", "no", "end", "a", "prefix", "type", "file", "list", "self", "start", "small", "none", "version", "NAME", "resource", "pass", "x", "client", "anc"], "vmsd": ["mmsn", "vmesdn", "vmesd", "vmsdh", " vumsp", "lmesds", "mmsd", "vvssd", "vMsd", "mamsn", "vamsl", "vvsn", "vMsn", "vmsl", "vumsn", "vvsp", " vrsd", "vrsdh", " vumssd", "vvsd", "mmsl", "vomsn", "lmesdn", "vmsds", "varsdh", "vcsdn", "vMsl", "vcsds", "vmesdt", "vmsb", "vumsp", " vmsdh", "vrsdt", " vmsdt", "vomssd", "vMSd", "viasdn", "vmsdn", "lmsds", "vMSl", "vMSn", "vMshd", "vamshd", "varsd", "vrsds", "viasb", "vmesdh", "vMShd", "vmsp", "vamsd", "varsdt", "vmesds", " vmsn", "viasds", " vrsdt", " vumsd", "vrsd", "viasd", " vmsds", "lmesd", "lmsb", "vmsdt", " vmsp", "mmshd", "lmsd", "lmsdn", "vomsp", "vamsn", " vrsdh", "vmssd", "vmshd", " vrsds", "vomsd", "vmesb", "mamsl", "mamshd", "vcsb", "lmesb", " vumsn", "mamsd", "varsds", "vumsd", "vumssd", "vmsn", "vcsd", " vmssd"]}}
{"project": "FFmpeg", "commit_id": "21bffa93a6fc73e1f1859f8bc224409eaaf27658", "target": 1, "func": "static void mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s)\n\n{\n\n    AVStream       *video_st    = s->streams[0];\n\n    AVCodecParameters *video_par = s->streams[0]->codecpar;\n\n    AVCodecParameters *audio_par = s->streams[1]->codecpar;\n\n    int audio_rate = audio_par->sample_rate;\n\n    // TODO: should be avg_frame_rate\n\n    int frame_rate = ((video_st->time_base.den) * (0x10000)) / (video_st->time_base.num);\n\n    int audio_kbitrate = audio_par->bit_rate / 1000;\n\n    int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate);\n\n\n\n    avio_wb32(pb, 0x94); /* size */\n\n    ffio_wfourcc(pb, \"uuid\");\n\n    ffio_wfourcc(pb, \"PROF\");\n\n\n\n    avio_wb32(pb, 0x21d24fce); /* 96 bit UUID */\n\n    avio_wb32(pb, 0xbb88695c);\n\n    avio_wb32(pb, 0xfac9c740);\n\n\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x3);  /* 3 sections ? */\n\n\n\n    avio_wb32(pb, 0x14); /* size */\n\n    ffio_wfourcc(pb, \"FPRF\");\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n\n\n    avio_wb32(pb, 0x2c);  /* size */\n\n    ffio_wfourcc(pb, \"APRF\"); /* audio */\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, 0x2);   /* TrackID */\n\n    ffio_wfourcc(pb, \"mp4a\");\n\n    avio_wb32(pb, 0x20f);\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, audio_kbitrate);\n\n    avio_wb32(pb, audio_kbitrate);\n\n    avio_wb32(pb, audio_rate);\n\n    avio_wb32(pb, audio_par->channels);\n\n\n\n    avio_wb32(pb, 0x34);  /* size */\n\n    ffio_wfourcc(pb, \"VPRF\");   /* video */\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, 0x1);    /* TrackID */\n\n    if (video_par->codec_id == AV_CODEC_ID_H264) {\n\n        ffio_wfourcc(pb, \"avc1\");\n\n        avio_wb16(pb, 0x014D);\n\n        avio_wb16(pb, 0x0015);\n\n    } else {\n\n        ffio_wfourcc(pb, \"mp4v\");\n\n        avio_wb16(pb, 0x0000);\n\n        avio_wb16(pb, 0x0103);\n\n    }\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, video_kbitrate);\n\n    avio_wb32(pb, video_kbitrate);\n\n    avio_wb32(pb, frame_rate);\n\n    avio_wb32(pb, frame_rate);\n\n    avio_wb16(pb, video_par->width);\n\n    avio_wb16(pb, video_par->height);\n\n    avio_wb32(pb, 0x010001); /* ? */\n\n}\n", "idx": 3610, "substitutes": {"pb": ["bf", "rb", "www", "lp", "tp", "pkg", "phys", "attr", "mp", "bp", "cpp", "fc", "xb", "bb", "pm", "ctx", "blog", "prot", "pl", "dl", "p", "fp", "pd", "bps", "bs", "pid", "typ", "obj", "api", "wp", "bt", "fb", "um", "ppa", "wat", "platform", "py", "cp", "nb", "pc", "wikipedia", "prop", "uf", "hub", "sb", "np", "gb", "ob", "bh", "plugin", "vp", "jp", "posts", "proc", "db", "b", "amp", "dp", "rob", "wb", "summary", "post", "bc", "lb", "bm", "lc", "PB", "pg"], "s": ["fs", "sv", "su", "fts", "ts", "ns", "hs", "l", "si", "ctx", "is", "ssl", "qs", "p", "bs", "sq", "sa", "v", "services", "sys", "service", "g", "ps", "ses", "sf", "ks", "c", "sb", "rs", "es", "spec", "gs", "t", "b", "sg", "f", "os", "storage", "aws", "ss", "js", "e", "sl", "ls", "ops", "ds", "sync", "h"], "video_st": ["audio_sth", "media_std", "audio_st", "video_str", "video_stream", "video_std", "media_st", "video_src", "media_stream", "videoacstr", "videoacst", "audio_inst", "video_sth", "audio_str", "media_src", "video_sta", "audio_sta", "videoacsta", "videoacsth", "video_inst"], "video_par": ["audio_sp", "videoJparams", "document_rec", "video_rec", "video_sp", "video5rec", "videoJsp", "audio_params", "video_per", "document_par", "document_param", "video5par", "video5parse", "video5param", "videoJpar", "document_parse", "videoJper", "video_param", "video_parse", "video_params", "audio_per"], "audio_par": ["audio_sp", " video__rec", " video__par", "audio_comp", "audio_params", " video__base", "audioJsp", " audio_comp", "video_dis", " video_base", "video_params", "audio__rec", "video_rec", "audio__params", "video_sp", "video_pc", "audio__base", " audio_proc", "audio_pc", " audio_per", "audioJrec", " video_params", "video_comp", "audio_rec", "audioJdis", "audio_dis", "audioJpar", "audio_proc", "audio_per", " video__params", "audio_base", " video_rec", "audio__par"]}}
{"project": "qemu", "commit_id": "8f68760561abf90156456fec6ad55c3b2a066d46", "target": 1, "func": "static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)\n\n{\n\n    char *path = NULL, *buf = NULL, *host = NULL;\n\n\n\n    /* Get the PCI VFIO host id */\n\n    host = object_property_get_str(OBJECT(pdev), \"host\", NULL);\n\n    if (!host) {\n\n        goto err_out;\n\n    }\n\n\n\n    /* Construct the path of the file that will give us the DT location */\n\n    path = g_strdup_printf(\"/sys/bus/pci/devices/%s/devspec\", host);\n\n    g_free(host);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    g_free(path);\n\n\n\n    /* Construct and read from host device tree the loc-code */\n\n    path = g_strdup_printf(\"/proc/device-tree%s/ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    return buf;\n\n\n\nerr_out:\n\n    g_free(path);\n\n    return NULL;\n\n}\n", "idx": 3611, "substitutes": {"sphb": [" sphr", "sphr", " sphd", " shpb", "sPhw", "sphw", "sPhb", "shpb", "sPhd", " shpd", "sppd", "shpw", " sphw", " shpr", "shpd", "sppw", "sPhr", "shpr", "sphd", " shpw", "sppr", "sppb"], "pdev": ["Pserv", "sdevice", "Pdevice", "sdd", "hDev", "hdevice", "pdevice", "hserv", "Pdev", "Pde", "cserv", "sde", "sdev", " pde", " pdd", "pDev", " pdevice", "Pdd", "pserv", "pde", "PDev", "cDev", "cdevice", "cdev", "hdev", "pdd"], "path": ["mount", "home", "text", "part", "buff", "hop", "enc", "temp", "lang", "ref", "key", "thread", "graph", "bound", "parent", "room", "Path", "image", "col", "rh", "object", "font", "p", "node", "config", "name", "buffer", "route", "method", "hub", "port", "ph", "url", "point", "board", "box", "pointer", "h", "feed", "track", "transform", "context", "ctx", "core", "act", "loader", "conn", "length", "cmd", "bind", "progress", "cat", "cache", "PATH", "loc", "n", "root", "ath", "folder", "id", "here", "prefix", "file", "sign", "work", "c", "self", "pass", "content"], "buf": ["mount", "cat", "feed", "rb", "cache", "home", "text", "buff", "loc", "base", "cf", "rc", "padding", "context", "ctx", "null", "bd", "font", "fp", "seq", "ref", "src", "runner", "ff", "folder", "raw", "config", "queue", "buffer", "bound", "vec", "route", "fb", "Buffer", "cv", "broad", "loader", "prefix", "func", "fd", "file", "Buff", "data", "str", "coll", "uf", "port", "bag", "pool", "url", "read", "room", "result", "block", "cb", "args", "b", "cmd", "box", "wb", "bc", "bytes", "cas", "uc", "br"], "host": ["driver", "mount", "ost", "cache", "home", "loc", "content", "ac", "hop", "device", "container", "object", "array", "header", "Host", "ref", "src", "root", "node", "remote", "config", "cross", "name", "head", "graph", "route", "method", "connect", "platform", "cast", "format", "prefix", "conn", "pos", "file", "str", "ann", "front", "parent", "server", "hub", "port", "c", "pool", "url", "comp", "target", "room", "boot", "channel", "box", "cmd", "dev", "localhost", "address", "addr", "http", "h", "source"]}}
{"project": "FFmpeg", "commit_id": "8b2fce0d3f5a56c40c28899c9237210ca8f9cf75", "target": 1, "func": "static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,\n\n                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,\n\n                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)\n\n{\n\n    //FIXME Optimize (just quickly writen not opti..)\n\n    int i;\n\n    for (i=0; i<dstW; i++)\n\n    {\n\n        int val=1<<18;\n\n        int j;\n\n        for (j=0; j<lumFilterSize; j++)\n\n            val += lumSrc[j][i] * lumFilter[j];\n\n\n\n        dest[i]= av_clip_uint8(val>>19);\n\n    }\n\n\n\n    if (!uDest)\n\n        return;\n\n\n\n    if (dstFormat == PIX_FMT_NV12)\n\n        for (i=0; i<chrDstW; i++)\n\n        {\n\n            int u=1<<18;\n\n            int v=1<<18;\n\n            int j;\n\n            for (j=0; j<chrFilterSize; j++)\n\n            {\n\n                u += chrSrc[j][i] * chrFilter[j];\n\n                v += chrSrc[j][i + 2048] * chrFilter[j];\n\n            }\n\n\n\n            uDest[2*i]= av_clip_uint8(u>>19);\n\n            uDest[2*i+1]= av_clip_uint8(v>>19);\n\n        }\n\n    else\n\n        for (i=0; i<chrDstW; i++)\n\n        {\n\n            int u=1<<18;\n\n            int v=1<<18;\n\n            int j;\n\n            for (j=0; j<chrFilterSize; j++)\n\n            {\n\n                u += chrSrc[j][i] * chrFilter[j];\n\n                v += chrSrc[j][i + 2048] * chrFilter[j];\n\n            }\n\n\n\n            uDest[2*i]= av_clip_uint8(v>>19);\n\n            uDest[2*i+1]= av_clip_uint8(u>>19);\n\n        }\n\n}\n", "idx": 3621, "substitutes": {"lumFilter": ["LumbFile", "lumbBlock", "lrumMaster", "lumMaster", "lumbFilter", "lumFile", "lumsFilter", "lumerFormat", "lumerBlock", "lumBlock", "LumbHeader", "lumHeader", "lumbMaster", "lumsFile", "lrumFilter", "lrumControl", "LumFormat", "lubControl", "lumControl", "lubMaster", "lumbControl", "LumHeader", "LumbControl", "LumFilter", "lubHeader", "lumerFile", "lumbFile", "LumbFormat", "lubFilter", "LumbFilter", "lumsFormat", "LumControl", "LumFile", "LumMaster", "lumFormat", "lumbFormat", "LumbBlock", "LumbMaster", "lumbHeader", "LumBlock", "lrumHeader", "lumsBlock", "lumerFilter"], "lumSrc": ["lumDsRC", "lumPsrc", "lumbAsRC", "lumAsrc", "lumPsRC", "lumSdr", "lumbSdr", "lumPsdr", "lumbAsrc", "lumNsrc", "lumNRC", "lumbAsdr", "lumbAssrc", "lumDsdr", "lumDsrc", "lumAsdr", "lumSRC", "lumbSRC", "lumbSrc", "lumSsrc", "lumAsRC", "lumNrc", "lumDssrc", "lumbSsrc", "lumAssrc", "lumNdr", "lumPssrc"], "lumFilterSize": ["lumaFileSize", "lumaFileSection", "lumaFiltersize", "lumaFSIZE", "lumLimitCount", "lumaFilterSection", "lumFiltersize", "lumFsize", "lumaFilterLen", "lumaFileLen", "lumFileSection", "lumaFCount", "lumLimitsize", "lumaFileCount", "lumBlockSection", "lumFSIZE", "lumBlockSize", "lumFCount", "lumHandlerSize", "lumaFilterSIZE", "lumHandlerSection", "lumFilterCount", "lumBufferSize", "lumaFSize", "lumFileSize", "lumFilterSection", "lumBufferSIZE", "lumLimitSIZE", "lumBlockCount", "lumFilterLen", "lumaFilterCount", "lumFilterSIZE", "lumaFsize", "lumFileLen", "lumLimitSize", "lumBlockLen", "lumFileCount", "lumBuffersize", "lumHandlerLen", "lumHandlerCount", "lumFSize", "lumaFilterSize", "lumBufferCount"], "chrFilter": [" chrFil", "uchrgFeature", "ichrReader", "chmSource", "chrcHeader", "chrtLayer", "uchrgFormat", "chrtHandler", "chreFactor", "chrarHandler", "chrbHandler", "ichrFilter", "chrbfilter", " chrdFactor", "chrfFormat", " chrxfilter", " chrxFil", "shrFilter", "chreSource", "chrcFilter", "chrcReader", "chrnReader", "shrHeader", "shrFactor", "uchrFeature", "chrxFil", "chrxFilter", "chrgFilter", "chrLayer", "chrtReader", "ichrcFilter", "ichrcLayer", "ichrHeader", "ichrcReader", "chrarFilter", " chrFactor", "uchrFormat", "chrdFilter", "chrfFactor", "chrfFeature", "chrgFormat", " chrSource", "chrfFil", " chrxFilter", "chrnLayer", "ichrLayer", "chrcLayer", "chrarFactor", "chrfHandler", "chrHeader", "chreFilter", "chrbFormat", "chrcHandler", "chmFactor", "shrarHandler", " chrdSource", "chrHandler", "chrgFactor", "chrdSource", "uchrgFilter", "chrbFactor", "chrfilter", "chrxHandler", "chrFormat", " chrHandler", "chrxfilter", "chrtHeader", "chmFilter", "chrtFilter", "chrtFactor", "shrarHeader", "ichrcHeader", " chrfilter", "chrarHeader", "chrFeature", "uchrFactor", "chrbFil", "chrnHeader", "chrffilter", "chrReader", "chrFil", "chrFactor", "chrbFilter", "chrdFactor", "chrfFilter", "shrHandler", "uchrFilter", "shrarFactor", "chrSource", "uchrgFactor", " chrdFilter", "shrarFilter", "chrgFeature", "chrbFeature", "chrcFactor", "chrnFilter", " chrxHandler"], "chrSrc": ["chrtASrc", "chrSroc", "chrOsrc", "chrDrc", "chrsAssrc", "chrSubrt", "chrsAsRC", "chrDesrt", "chrPssrc", "chrInsrc", "chrSrx", "chrtASrt", "chrInsRC", "chrsSRC", "chrcSrc", "chrEsric", "chrcSsrc", "chrSrt", "chrInsric", "chrfSsrc", "chrSvc", "chrfDessrc", "chrFsric", "chrbInsroc", "chrSubrc", "chrUsrx", "chrtSrc", "chrPsrc", "chrtASsrc", "chrUssrc", "chrFssrc", "chrbSroc", "chrtSrt", "chrfSrc", "chrsAsrc", "chrcShrc", "chrcSsc", "chrbSrc", "chrSRC", "chrDessrc", "chrEsRC", "chrbInssrc", "chrShrc", "chrShsrc", "chrEsroc", "chrFsroc", "chrtSsrc", "chrfDesrt", "chrcSri", "chrASrc", "chrDesrc", "chrOssrc", "chrfSrt", "chrbSric", "chrtASrx", "chrcShsrc", "chrInsroc", "chrFsrc", "chrUsrt", "chrfSvc", "chrSric", "chrcShsc", "chrSubvc", "chrsSrc", "chrASvc", "chrEsrc", "chrDsrc", "chrAsrc", "chrASsrc", "chrAsRC", "chrASrt", "chrDrt", "chrcShri", "chrsSsrc", "chrPssc", "chrInssrc", "chrOsri", "chrfDesvc", "chrAssrc", "chrSsrc", "chrShsc", "chrbSsrc", "chrSubsrc", "chrEssrc", "chrDesvc", "chrfDesrc", "chrDrx", "chrPsri", "chrbInsric", "chrShri", "chrbInsrc", "chrASrx", "chrtSrx", "chrOssc", "chrSsc", "chrSri", "chrUsrc"], "chrFilterSize": ["chlFilterSize", "chrLayerCore", "chlFactorLen", "chruMaskSize", "chrFactorSize", "chrFiltersize", "chlFilter6", "chrBufferLen", "chrLimitSIZE", "chrFilter6", "chrLimitsize", "chrBuffersize", "chrbUsersize", "chrUsersize", "chruMaskStyle", "chrLimitCount", "chrLayerStyle", "chrFactor6", "chrFilterCount", "chrBufferSize", "chrBufferSIZE", "chrbUserCount", "chrFile6", "chrbFilterCount", "chrbFilterSize", "chlFactor6", "chrFilCore", "chrFileLen", "chrFilStyle", "chruFilterSize", "chrFilterLen", "chrFactorLen", "chrUserSize", "chruFilterStyle", "chrFileSize", "chruMaskCore", "chrFilterSIZE", "chrFilSize", "chrBuffer6", "chlFactorSize", "chrMaskStyle", "chrMaskSize", "chrFilterCore", "chlFilterLen", "chrLimitSize", "chrbUserSIZE", "chrUserSIZE", "chrMaskCore", "chrbFilterSIZE", "chruFilterCore", "chrbUserSize", "chrFilterStyle", "chrBufferCount", "chrLayerSize", "chrbFiltersize", "chrUserCount"], "dest": ["dist", "dc", "text", "transform", "loc", "decl", "sort", "match", "gen", "sub", "img", "outer", "south", "opt", "tmp", "src", "config", "dat", "rest", "dim", "cdn", "slice", "trans", "data", "prop", "flat", "output", " destination", "export", "du", "test", "target", "result", "options", "Dest", "wb", "coord", "path", "source", "desc"], "uDest": ["iSc", "uDi", "nuStream", "UDest", " uForce", "pDest", "UForce", "uForce", " uDist", "uiForce", "uSc", "uiBuff", "cuDi", "zuDi", "uStream", "uiSc", "pSource", " uBuff", "nuSource", " uSc", "cuSc", "uSource", "uiPriv", "iuDest", "uiDist", "cuDesc", "zuDist", "Udest", "uiStream", "uBuff", "uiDest", "cuForce", "udest", "pStream", "uPriv", "nuDest", "uDesc", "iuDist", "zuDest", "pPriv", "cuDist", "uiSource", "UDist", "iDist", " udest", "cudest", "iuSc", " uDi", "zuDesc", "uDist", "iuBuff", "uiDesc", " uDesc", "iDest", "USc", "cuDest", "nuPriv"], "dstW": ["drcw", "dscw", "drcP", " drcH", " dstH", "DscW", " drcw", "DscP", "dstaW", "DscH", "dscW", "DstW", " dstCW", "dstH", "dspP", "DstH", "dspw", "dscH", "dstP", "dspH", "dscP", "dspW", "Dscw", "drcH", "dstaH", " drcW", "dstaCW", "Dstw", "dstaw", " dstw", "drcW", "dscCW", "dstCW", "dstw", "DstP", "drcCW", " drcCW"], "chrDstW": ["chrDrcL", "chrDostH", "chrDrcY", "chrDrcH", "chrSrcH", "chrDstsN", "chrDstY", "chrKstN", "chrDstWe", "chrDsnL", "chrDostW", "chrDostWe", "chrDstP", "chrNmtC", "chrNmtP", "chrDostSW", "chrDSTSW", "chrDstsWe", "chrDsnP", "chrDSTY", "chrDsnC", "chrDrcW", "chrDostGW", "chrSstY", "chrDSTN", "chrDSTW", "chrDrcC", "chrDSTH", "chrKstW", "chrSrcY", "chrNmtW", "chrKstSW", "chrKstWe", "chrKostSW", "chrSrcGW", "chrDstL", "chrDrcGW", "chrNstW", "chrDmtL", "chrDSTGW", "chrDSTWe", "chrSstW", "chrDrcP", "chrSstGW", "chrKostW", "chrDstsW", "chrDstN", "chrDstH", "chrDstC", "chrDstSW", "chrNstC", "chrDostN", "chrDsnW", "chrSrcW", "chrDstsSW", "chrDostY", "chrDmtW", "chrKostN", "chrKostWe", "chrDmtP", "chrNmtL", "chrNstL", "chrNstP", "chrDmtC", "chrSstH", "chrDstGW"], "dstFormat": ["DscFunction", "destW", " dscType", "dscFunction", "dSTMethod", "DstFunction", "dstType", "dscMethod", "dscW", "destFormat", "dstFunction", "destType", " dstF", "DstMethod", "dSTFormat", "dstMethod", "dSTW", "DscMethod", "dspType", "dscType", "dSTType", "DstFormat", " dscW", "dSTF", "destF", "DstType", "dscFormat", "dspFunction", "DscType", "dscF", " dscF", " dstType", "dSTFunction", "dspMethod", "dstF", " dscFormat", "DscFormat", "dspFormat"], "i": ["uri", "key", "d", "mi", "z", "ri", "v", "bi", "ami", "iu", "ie", "ji", "ix", "layer", "info", "pi", "f", "ti", "ki", "phi", "gu", "ui", "l", "si", "is", "y", "o", "p", "ci", "qi", "eni", "name", "li", "init", "vi", "mu", "b", "u", "xi", "it", "h", "line", "io", "ik", "fi", "at", "oi", "m", "ret", "ori", "ini", "slice", "x", "g", "me", "zi", "ai", "t", "ei", "jit", "ip", "e", "yi", "index", "isi", "source", "val", "n", "cli", "id", "alpha", "api", "adi", "k", "ii", "mini", "c", "in", "di", "abi", "gi", "ni", "I"], "j": ["fr", "val", "jo", "je", "jc", "jam", "all", "pr", "bj", "l", "ik", "si", "n", "er", "jl", "dj", "y", "o", "p", "key", "jen", "qi", "oj", "ind", "other", "d", "m", "aj", "job", "obj", "z", "adj", "ja", "k", "ij", "ii", "ld", "v", "uj", "bi", "el", "jet", "li", "jj", "g", "ie", "ji", "ix", "jp", "ch", "b", "f", "u", "q", "jit", "json", "js", "e", "x", "it", "J", "h", "br"]}}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)\n\n{\n\n    uint32_t qid;\n\n\n\n    if (addr & ((1 << 2) - 1)) {\n\n        return;\n\n    }\n\n\n\n    if (((addr - 0x1000) >> 2) & 1) {\n\n        uint16_t new_head = val & 0xffff;\n\n        int start_sqs;\n\n        NvmeCQueue *cq;\n\n\n\n        qid = (addr - (0x1000 + (1 << 2))) >> 3;\n\n        if (nvme_check_cqid(n, qid)) {\n\n            return;\n\n        }\n\n\n\n        cq = n->cq[qid];\n\n        if (new_head >= cq->size) {\n\n            return;\n\n        }\n\n\n\n        start_sqs = nvme_cq_full(cq) ? 1 : 0;\n\n        cq->head = new_head;\n\n        if (start_sqs) {\n\n            NvmeSQueue *sq;\n\n            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {\n\n                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n            }\n\n            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n        }\n\n\n\n        if (cq->tail != cq->head) {\n\n            nvme_isr_notify(n, cq);\n\n        }\n\n    } else {\n\n        uint16_t new_tail = val & 0xffff;\n\n        NvmeSQueue *sq;\n\n\n\n        qid = (addr - 0x1000) >> 3;\n\n        if (nvme_check_sqid(n, qid)) {\n\n            return;\n\n        }\n\n\n\n        sq = n->sq[qid];\n\n        if (new_tail >= sq->size) {\n\n            return;\n\n        }\n\n\n\n        sq->tail = new_tail;\n\n        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n    }\n\n}\n", "idx": 3634, "substitutes": {"n": ["fn", "nm", "r", "ns", "l", "un", "j", "num", "o", "y", "p", "new", "node", "nor", "d", "m", "z", "adj", "s", "w", "sn", "not", "k", "an", "on", "v", "nb", "conn", "g", "ne", "dn", "c", "nt", "nu", "self", "nc", "mn", "network", "t", "b", "f", "u", "na", "q", "none", "N", "e", "net", "en"], "addr": ["host", "md", "offset", "rr", "mac", "r", "loc", "hop", "rc", "ptr", "ord", "rt", "code", "ack", "sid", "alt", "rx", "p", "ref", "arr", "nn", "node", "dr", "adr", "config", "sta", "name", "amd", "ad", "route", "len", "no", "mode", "pad", "ld", "ress", "pos", "conn", "str", "data", "mid", "add", "arm", "eth", "mt", "url", "xt", "nr", "np", "asm", "ix", "ace", "fx", "arg", "hd", "oa", "la", "amp", "align", "ip", "address", "doc", "x", "net", "seq"], "val": ["eval", "update", "offset", "value", "base", "def", "grad", "unit", "elt", "alt", "sel", "valid", "Val", "ref", "mem", "ind", "delay", "ret", "vol", "stat", "len", "ol", "count", "v", "end", "pos", "el", "slot", "old", "vals", "reg", "pre", "start", "fx", "VAL", "al", "db", "max", "sl", "x", "bit", "index"], "qid": [" qide", "Qno", "issuesid", " qbit", "sqip", "qbit", "qId", "qide", "qf", "qno", "quid", " qip", "QId", "qsid", "Qf", "sqid", "Qbit", "viewinfo", "queryid", "qinfo", "quinfo", "qi", "Qid", "Qip", "qis", "qqinfo", "dqf", " qinfo", " qsid", " qi", "dqip", "qqid", "quin", "queryno", "qin", "queryId", "issueid", " qno", "quip", " qids", "viewip", "queip", " qf", "dqId", "dqbit", " qId", "qqin", "issuepid", " qpid", "qids", "queid", "viewis", "issueip", "sqinfo", "dqinfo", "qui", "quf", "qpid", " qin", "quide", "dqid", "Qids", "sqis", "qip", "quepid", " qis", "quesid", "queryids", "qqide", "Qi", "viewid"], "start_sqs": ["start_sectses", "start_reqd", "start5sqgs", "start5sqp", "start_qqgs", "start_squd", "start_qqp", "start_sqls", "start_ql", "start5eqp", "start5sqches", "start_qus", "start_reqs", "start_sqid", "start_qud", "start_eqgs", "start_reqid", "start5eqches", "start_eqs", "start_qls", "start_eqp", "start_qid", "start_qul", "start5eqgs", "start5eqs", "start_sectd", "start5sqs", "start_eqches", "start_qqs", "start_sectls", "start_reql", "start_sql", "start_qses", "start_qs", "start_squs", "start_sqgs", "start_qd", "start_qqches", "start_sqses", "start_sqches", "start_squses", "start_sqd", "start_squls", "start_sqp", "start_quid", "start_sects"], "cq": ["cque", "ocq", "fcQ", "qQ", "dcqu", "conqi", " cql", "gqi", "encq", " cce", "ocw", "qqu", "qke", "rcqa", "rcqu", "acql", "gql", "pk", "acqa", " cQ", "cfqu", "cqi", "cqt", "ppe", " cp", "fcqa", "dcqi", "gqa", "encqu", "cue", "cqa", "lcqs", "cfpe", "cpe", "pqu", "cql", "conql", "dcqt", "qq", "dcql", "pql", "fcqu", "ocquire", "cke", "lcque", " cquire", "acQ", "lcq", "conqt", "ecqu", "rcQ", "cce", " cqu", "acke", " cpe", "acq", "pce", "acce", " ck", "pq", "ecql", "acqu", "lcce", "dcue", "cqu", "cfk", "gq", "cp", "encue", "pQ", " cque", "conq", "gqu", "ecq", " cqi", "fcqs", "cquire", "acp", "pque", "cQ", "conquire", "conw", "cqs", "ecqa", "cw", "cfq", "fcq", " cqs", "fcp", "encql", "ocqi", "pqs", "ck", " cue", "gqt", "fcql", "rcq", "dcq", " cke", " cw"], "sq": ["ship", "view", "req", "sing", "gh", "lib", "sel", "qa", "quire", "apse", "cap", "col", "que", "squ", "ku", "pull", "quad", "sv", "close", "qs", "zz", "Square", "qq", "qi", "hess", "zen", "cross", "se", "join", "qv", "iq", "pool", "pay", "fx", "q", "sk", "ct", "sync", "pg", "supp", "sc", "ctx", "sh", "ssl", "kk", "query", "queue", "rf", "aq", "shape", "ctrl", "cur", "sky", "sql", "ds", "request", "eq", "su", "scl", "qu", "square", "quit", "nox", "liv", "sys", "coll", "sf", "dq", "small", "qua", "company", "client", "entry", "seq"]}}
{"project": "FFmpeg", "commit_id": "8b27f76bf8790536afccb96780b5feb9c65636be", "target": 0, "func": "static av_cold void build_modpred(Indeo3DecodeContext *s)\n\n{\n\n  int i, j;\n\n\n\n  s->ModPred = av_malloc(8 * 128);\n\n\n\n  for (i=0; i < 128; ++i) {\n\n    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));\n\n    s->ModPred[i+1*128] = i ==   7 ?  20 :\n\n                          i == 119 ||\n\n                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));\n\n    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));\n\n    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));\n\n    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));\n\n    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));\n\n    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));\n\n    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));\n\n  }\n\n\n\n  s->corrector_type = av_malloc(24 * 256);\n\n\n\n  for (i=0; i < 24; ++i) {\n\n    for (j=0; j < 256; ++j) {\n\n      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :\n\n                                   j < 248 || (i == 16 && j == 248) ? 0 :\n\n                                   corrector_type_2[j - 248];\n\n    }\n\n  }\n\n}\n", "idx": 3658, "substitutes": {"s": ["S", "fs", "sv", "sets", "su", "r", "ts", "ns", "l", "hs", "cs", "si", "ctx", "is", "settings", "n", "ssl", "qs", "o", "south", "p", "conf", "less", "d", "sq", "session", "bs", "w", "v", "services", "sys", "stats", "service", "g", "states", "ps", "lines", "ses", "ks", "c", "rs", "sb", "es", "self", "ats", "spec", "gb", "gs", "sym", "vs", "t", "features", "os", "sg", "u", "f", "utils", "b", "ss", "js", "e", "ls", "its", "ops", "ds", "sync", "h"], "i": ["anti", "ali", "idi", "uri", "key", "d", "mi", "z", "ri", "v", "bi", "ami", "iu", "ie", "ji", "ix", "info", "image", "pi", "f", "ti", "phi", "ki", "my", "ui", "l", "si", "is", "o", "y", "p", "ci", "qi", "ind", "eni", "name", "li", "init", "b", "u", "xi", "it", "io", "r", "ik", "ia", "fi", "ic", "multi", "oi", "m", "ori", "ini", "x", "uli", "g", "me", "zi", "ai", "ip", "e", "esi", "http", "yi", "index", "isi", "hi", "im", "n", "cli", "id", "api", "adi", "ii", "c", "in", "di", "abi", "asi", "gi", "ni", "I"], "j": ["je", "jo", "jam", "jc", "im", "pr", "bj", "r", "l", "si", "n", "jl", "o", "dj", "y", "p", "key", "jen", "qi", "oj", "d", "m", "aj", "job", "z", "adj", "note", "ja", "k", "ij", "ii", "v", "uj", "bi", "jet", "li", "jj", "g", "ie", "length", "ji", "c", "ix", "jp", "ch", "b", "q", "u", "f", "kj", "ni", "js", "e", "x", "J", "h"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n", "idx": 3681, "substitutes": {"s": ["S", "i", "fs", "support", "sv", "su", "ts", "ns", "settings", "cs", "context", "ctx", "conf", "temp", "ssl", "south", "p", "src", "d", "m", "sq", "session", "w", "v", "services", "a", "sys", "service", "g", "txt", "ps", "ses", "sf", "c", "rs", "sb", "es", "t", "b", "f", "sg", "u", "js", "e", "ds", "sync", "xs"], "rlow": [" rlo", "irlower", "Rhigh", "rlo", " rlower", "pold", "xlow", "irlow", "xold", "xhigh", "xlower", "Rlow", "rwlower", "rlower", "phigh", "Rlower", "rwlo", "rold", "Rold", "rwlow", "plower", "rmid", "irmid", "plow", "rwmid", " rmid", "irlo"], "rhigh": ["rthighest", "frlimit", "rrtop", "rhighest", "rttop", "rrlimit", " rtop", "rrhighest", "frhi", "frhigh", " rlimit", "rrhi", "rtop", "frtop", " rhighest", "rthi", "rthigh", "rlimit", " rhi", "rrhigh", "rhi"], "val": ["eval", "xxx", "value", "vt", "part", "base", "r", "cond", "loc", "rt", "ctx", "j", "temp", "elt", "alt", "sel", "p", "valid", "Val", "pt", "ref", "fl", "ind", "m", "var", "min", "vol", "len", "v", "py", "a", "func", "el", "pos", "g", "data", "prop", "vals", "reg", "pre", "test", "VAL", "al", "t", "db", "b", "f", "sl", "bl", "x", "ffff", "fe"], "tmp": ["tab", "uv", "cache", "rb", "vt", "tp", "part", "buff", "attr", "mp", "ptr", "pb", "tt", "rt", "j", "temp", "ctx", "p", "fp", "kk", "TB", "pt", "src", "ff", "m", "config", "obj", "api", "buf", "vm", "fb", "stuff", "fake", "property", "tc", "cro", "v", "py", "cp", "nb", "cv", "beta", "tv", "data", "abb", "Temp", "txt", "emp", "sb", "app", "pre", "test", "np", "jp", "boot", "cb", "proc", "t", "b", "f", "storage", "pot", "bt", "vv", "br"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)\n\n{\n\n    int ret = 0;\n\n\n\n    assert(len > 0);\n\n    ccid_bulk_in_get(s);\n\n    if (s->current_bulk_in != NULL) {\n\n        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);\n\n        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);\n\n        s->current_bulk_in->pos += ret;\n\n        if (s->current_bulk_in->pos == s->current_bulk_in->len) {\n\n            ccid_bulk_in_release(s);\n\n        }\n\n    } else {\n\n        /* return when device has no data - usb 2.0 spec Table 8-4 */\n\n        ret = USB_RET_NAK;\n\n    }\n\n    if (ret > 0) {\n\n        DPRINTF(s, D_MORE_INFO,\n\n                \"%s: %d/%d req/act to guest (BULK_IN)\\n\", __func__, len, ret);\n\n    }\n\n    if (ret != USB_RET_NAK && ret < len) {\n\n        DPRINTF(s, 1,\n\n            \"%s: returning short (EREMOTEIO) %d < %d\\n\", __func__, ret, len);\n\n    }\n\n    return ret;\n\n}\n", "idx": 3691, "substitutes": {"s": ["uns", "conf", "d", "sis", "states", "ps", "secondary", "sb", "sym", "state", "strings", "f", "os", "js", "l", "sites", "is", "si", "qs", "o", "p", "ins", "se", "stats", "ses", "site", "args", "b", "sg", "u", "side", "ops", "sync", "S", "r", "hs", "settings", "cs", "changes", "ssl", "south", "m", "sq", "session", "status", "full", "service", "g", "us", "server", "ks", "spec", "es", "gs", "sports", "t", "aws", "ss", "e", "ls", "http", "ds", "xs", "fs", "su", "sets", "ts", "ns", "ims", "or", "ans", "a", "services", "sie", "sys", "c", "rs", "self", "storage", "its"], "data": ["field", "wa", "next", "val", "cache", "offset", "ui", "open", "base", "req", "def", "Data", "p", "arr", "mem", "input", "raw", "dat", "id", "buffer", "api", "memory", "buf", "limit", "name", "ad", "slice", "pad", "rec", "pos", "conn", "batch", "window", "length", "body", "start", "info", "result", "block", "la", "DATA", "response", "bin", "da", "size", "addr", "x", "bytes", "ds", "seq"], "len": ["field", "all", "lp", "part", "num", "dl", "alt", "lang", "ref", "ln", "count", "lit", "ll", "layer", "cap", "f", "done", "l", "lt", "lon", "elt", "valid", "non", "min", "rev", "name", "limit", "Len", "pos", "el", "li", "den", "nt", "url", "err", "lf", "lc", "line", "lock", "offset", "base", "en", "lin", "ret", "iter", "lan", "length", "pre", "size", "led", "index", "val", "un", "rt", "n", "lim", "fin", "id", "end", "list", "body", "start", "bin", " ret", "lif", "seq"]}}
{"project": "FFmpeg", "commit_id": "29c2fcb6776f80a0a5551bb82b43bc14c8202331", "target": 1, "func": "static void lms_update(WmallDecodeCtx *s, int ich, int ilms, int16_t input, int16_t pred)\n\n{\n\n    int16_t icoef;\n\n    int recent = s->cdlms[ich][ilms].recent;\n\n    int16_t range = 1 << (s->bits_per_sample - 1);\n\n    int bps = s->bits_per_sample > 16 ? 4 : 2; // bytes per sample\n\n\n\n    if (input > pred) {\n\n        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)\n\n            s->cdlms[ich][ilms].coefs[icoef] +=\n\n                s->cdlms[ich][ilms].lms_updates[icoef + recent];\n\n    } else {\n\n        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)\n\n            s->cdlms[ich][ilms].coefs[icoef] -=\n\n                s->cdlms[ich][ilms].lms_updates[icoef];     // XXX: [icoef + recent] ?\n\n    }\n\n    s->cdlms[ich][ilms].recent--;\n\n    s->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1);\n\n\n\n    if (input > pred)\n\n        s->cdlms[ich][ilms].lms_updates[recent] = s->update_speed[ich];\n\n    else if (input < pred)\n\n        s->cdlms[ich][ilms].lms_updates[recent] = -s->update_speed[ich];\n\n\n\n    /* XXX: spec says:\n\n    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;\n\n    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;\n\n\n\n        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two\n\n        seperate buffers? Here I've assumed that the two are same which makes\n\n        more sense to me.\n\n    */\n\n    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 4] >>= 2;\n\n    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 3] >>= 1;\n\n    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */\n\n\n\n    if (s->cdlms[ich][ilms].recent == 0) {\n\n        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.\n\n                follow kshishkov's suggestion of using a union. */\n\n        memcpy(s->cdlms[ich][ilms].lms_prevvalues + s->cdlms[ich][ilms].order,\n\n               s->cdlms[ich][ilms].lms_prevvalues,\n\n               bps * s->cdlms[ich][ilms].order);\n\n        memcpy(s->cdlms[ich][ilms].lms_updates + s->cdlms[ich][ilms].order,\n\n               s->cdlms[ich][ilms].lms_updates,\n\n               bps * s->cdlms[ich][ilms].order);\n\n        s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order;\n\n    }\n\n}\n", "idx": 3714, "substitutes": {"s": ["i", "uns", "conf", "sis", "an", "states", "ps", "secondary", "sb", "sym", "state", "os", "f", "parts", "this", "set", "js", "comments", "sv", "l", "sites", "si", "is", "qs", "o", "p", "less", "se", "ses", "site", "features", "b", "sg", "ops", "sup", "sync", "S", "sc", "hs", "cs", "ssl", "sq", "session", "w", "full", "service", "g", "your", "us", "ks", "spec", "es", "gs", "t", "native", "aws", "ss", "e", "ls", "ds", "xs", "fs", "su", "sets", "ts", "ns", "ess", "n", "services", "sie", "sys", "sf", "c", "rs", "self", "its", "tests"], "ich": ["isol", "ship", "choice", "chi", "intel", "aff", "ht", "sim", "isc", "chn", "pect", "ah", "icy", "ix", "ch", "ih", "image", "iv", "host", "inf", "ait", "imp", "ci", "ig", "impl", "qi", "ind", "config", "dat", "intelligence", "ict", "org", "hard", "ach", "ocl", "isch", "activity", "el", "ench", "arch", "strong", "current", "cand", "sk", "icht", "ct", "chip", "code", "ic", "act", "dr", "conn", "mot", "irc", "ish", "egg", "ill", "urn", "progress", "cm", "unch", "hm", "rich", "im", "form", "img", "force", "ike", "cot", "ext", "iche", "och", "igh", "anch", "hp", "che"], "ilms": ["ilMS", "hlks", "illcs", "ilcs", "illms", "olks", "alm", "ailMS", "silns", "ailvs", "lmes", "ilmins", "elmos", "hlmm", "olvs", "almm", "ilfs", "alms", "ulmad", "illme", "ilm", "hlmes", "ulmm", "elks", "ilns", "ilmad", "ulmos", "elms", "silks", "silmos", "ulm", "elcs", "ailmad", "illvs", "ilmos", "illfs", "ailcs", "ailks", "hlm", "illks", "lks", "ilme", "ailmins", "ilvs", "ilks", "ilmes", "elme", "illmad", "ailmes", "ulms", "lms", "ilmm", "hlms", "illmm", "ailarms", "illmos", "illns", "ulmes", "illarms", "silmes", "olms", "ailms", "ILmm", "ILms", "ailmos", "ailfs", "elns", "silmm", "ailm", "elMS", "elmm", "ulns", "elarms", "ILmes", "ILm", "elmins", "elmes", "olmm", "ilarms", "ulmins", "ulfs", "silms", "ulMS", "ailme", "ulks", "illmes", "almos", "illm", "ailns", "elm", "hlns", "hlmad", "elmad", "ailmm", "ularms", "ulme", "lmos"], "input": ["model", "inf", "support", "feed", "view", "insert", "i", "supp", "text", "sample", "back", "form", "error", "domain", "att", "context", "binary", "active", "img", "intel", "array", "qq", "act", "query", "cli", "config", "concept", "session", "alpha", "source", "not", "qa", "stream", "format", "conn", "tif", "irc", "data", "iq", "batch", "length", "include", "output", "spec", "c", "in", "current", "init", "result", "image", "Input", "phy", "state", "audio", "feature", "cmd", "inc", "q", "amp", "f", "child", "chip", "empty", "client", "uc", "accept", "request"], "pred": ["rep", "rend", "next", "dist", "cod", "val", "changed", "diff", "done", "buff", "confirmed", "cond", "form", "def", "expected", "cell", "tmp", "valid", "ref", "new", "fit", "ind", "red", "bed", "rest", "rod", "adv", "orig", "prom", "ed", "rec", "cast", "fitted", "prep", "stream", "prop", "data", "future", "old", "pre", "current", "eddy", "fetched", "ped", "sd", "failed", "proven", "dev", "range", "live", "Pred", "actual", "client", "defined", "last"], "icoef": ["micEF", "icaec", "icieff", "igoeff", "icheef", "coec", "icaef", "icaof", "ciof", "ciuff", "ciec", "voceff", "floene", "igoef", "icoene", "micec", "ciaf", "icief", "cienge", "icoaf", "coef", "icaEF", "ICOef", "ciefe", "icoof", "ichoaxy", "iciuff", "iscoalf", "icaception", "vocEF", "iciec", "ichoeff", "icoaxy", "coeff", "coof", "chief", "cieff", "ichoEF", "chieff", "iscoef", "ICOeb", "ciene", "ichoaped", "voceb", "iconeff", "ciEF", "chiuff", "icaaf", "vocef", "floeff", "coaf", "ICOeff", "floefe", "ichoef", "ichoof", "icheaxy", "igoefe", "coenge", "iconception", "chiec", "icoception", "miceff", "iconof", "coEF", "floef", "icoEF", "icoefe", "icienge", "cieb", "iconef", "ichoec", "coception", "ichoaf", "ICOalf", "icoeff", "icaeff", "iconaxy", "micef", "icheaped", "icoenge", "icoaped", "iscoEF", "iconaped", "icouff", "icheeff", "icoec", "igoene", "icoeb", "icoalf", "ichoalf", "ICOEF", "cief"], "cdlms": ["cdlps", "xdllems", "cdklms", "dcflmes", "cdllims", "cdlymes", "cdlens", "cdllems", "dclims", "ddlims", "cdLmes", "cdLm", "cdklvs", "cmdhlastics", "cdilcs", "cdlmas", "cdlcmes", "cdlyfs", "cdllmm", "dclcs", "cdlums", "xdlcs", "cdlemm", "cdrlims", "dclums", "cdlsfs", "cdrems", "dcluns", "xdlems", "cdljs", "mdlfs", "cdlumm", "dcrmm", "cdlloms", "ckylms", "ddellms", "xdllcs", "cdsljs", "cdnlmm", "dcLms", "cdrmm", "mdelmm", "cmdhlems", "dclyfs", "cdleims", "cdaloms", "ddellims", "cdlpm", "cdelvs", "cdilems", "cdluims", "ddlns", "cdolfs", "cdLpm", "cdrlms", "cdklmes", "cloudlm", "codflmm", "ckljs", "cdliamps", "cdhlems", "cdylcs", "cdllm", "cdlems", "cmdlastics", "cdnlvs", "cdlljs", "ckyloms", "cdnlmes", "cdolms", "cdlsmm", "cdylpm", "cdrlmm", "dclumm", "cdolems", "cddlmes", "cloudlims", "xdelms", "mdlms", "cdelims", "ddellmes", "cdlvs", "cdellms", "cdlamps", "CDlips", "cdlfs", "cmdhlms", "mdelms", "cdlcms", "cdlymm", "dclmm", "cdellmes", "codlmm", "cklmm", "cdulmes", "cdyloms", " cddlmes", "cdnlems", "cdolcs", "cdalms", "cdrlfs", "codflms", "cdnlcs", "cdllmas", "cdeljs", "xdelfs", "cklms", "cmdlmas", "cdylems", " cddlfs", "dcLm", "cdflems", "dclmes", "clouddlims", "xdllms", "xdlmm", "cdylm", "codklvs", " cdlems", "cdellmm", "clouddlms", "cdlm", "ckloms", "codflems", "CDlmas", "cdrlmes", "codklmes", "xdlvs", "cdslfs", "ddlms", "CDliamps", "cdlcs", "cdflmm", "ddellns", "cdrlmas", "cddlims", "codklmm", "dclyms", "cdelfs", "cdelems", "cdlsms", "cdylms", "cdlcmm", "cdslms", "cdnlmas", "dclymm", "dcrems", "cdulems", "cdklems", "cdrlns", "codlmes", "cdlmes", "cdaljs", "cdslmm", "cdelmes", " cddlms", "cdllcs", "cdelmm", "cdellems", "dcLmes", "cdflcs", "mdelfs", "cdlips", "cdulpm", "codlms", "xdlms", "dcflcs", "clouddlmas", "cdlims", "clouddlm", "cdllms", "dcflms", " cddlems", "mdeljs", "cdlastics", "CDlms", "cdklmm", "codlems", "cdflmes", "cdlcmas", "dcrms", "cdklastics", "cdylvs", "dclm", "cdolmes", "cdlimas", "dclpm", "cdrljs", "CDlims", "cdlumes", "cdylmes", "cdhlms", "cdlsmes", "cdhlastics", "dcrmes", "cdflms", "dclems", "dcflems", "cdnlps", "codlvs", "cdlcamps", "cddlms", "xdelvs", "cdilmes", "codflmes", "cdelns", "cdlyms", "cdellims", "cloudlms", "cmdlems", "cdolmm", "cdLms", "mdlmm", "cdnlamps", "CDlamps", "ckylmm", "cddlems", "cdulastics", "CDlps", "cddlmas", "dclymes", "mdljs", "cdlemes", "cdlmm", "cmdlms", "cdhlmas", "cdellns", "xdelmm", "cdlefs", "ddlmes", "cmdhlmas", "xdlmes", "cdulm", "dclns", "cdelms", "dclfs", "codklms", "cdilms", "cdleems", "dcLpm", "ckyljs", "cdlcps", "cdulmas", "cdlcfs", "cddlm", "cdalmm", "cdloms", "cdnlms", "cdrmes", "cdrms", "dcluims", "cdluns", "cddlfs", " cdlfs", "cloudlmas", " cdlmes", "cdyljs", "xdllmm", "dclms", "xdlfs", "cdulms", "cdlns", "CDlimas", "cdylmm", "cdrlm", "xdelmes", "cdklmas"], "recent": ["example", "dist", "unique", "diff", "create", "common", "today", "ord", "num", "archive", "complex", "received", "orig", "qa", "feat", "future", "row", "since", "complete", "aug", "large", "history", "gap", "component", "post", "ctr", "ready", "random", "sofar", "expected", "valid", "remote", "stage", "Recent", "event", "gpu", "prop", "significant", "current", "now", "custom", "hold", "region", "confirmed", "gen", "date", "active", "new", "raw", "ale", "session", "modern", "full", "allow", "many", "old", "reg", "item", "past", "extra", "progress", "dom", "last", "desc", "good", "quick", "low", "latest", "running", "popular", "command", "folder", "reported", "rec", "off", " recently", "ide", "currently", "original", "small", "feature", "version", "range", "client", "record"]}}
{"project": "FFmpeg", "commit_id": "2f86e7bd12d8023da3349f10490b1e5b64531e23", "target": 1, "func": "static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index,\n\n                         const char *filt_name, const char *args, AVClass *log_ctx)\n\n{\n\n    AVFilter *filt;\n\n    char inst_name[30];\n\n    char tmp_args[256];\n\n    int ret;\n\n\n\n    snprintf(inst_name, sizeof(inst_name), \"Parsed filter %d %s\", index, filt_name);\n\n\n\n    filt = avfilter_get_by_name(filt_name);\n\n\n\n    if (!filt) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"No such filter: '%s'\\n\", filt_name);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ret = avfilter_open(filt_ctx, filt, inst_name);\n\n    if (!*filt_ctx) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Error creating filter '%s'\\n\", filt_name);\n\n        return ret;\n\n    }\n\n\n\n    if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) {\n\n        avfilter_free(*filt_ctx);\n\n        return ret;\n\n    }\n\n\n\n    if (!strcmp(filt_name, \"scale\") && !strstr(args, \"flags\")) {\n\n        snprintf(tmp_args, sizeof(tmp_args), \"%s:%s\",\n\n                 args, ctx->scale_sws_opts);\n\n        args = tmp_args;\n\n    }\n\n\n\n    if ((ret = avfilter_init_filter(*filt_ctx, args, NULL)) < 0) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Error initializing filter '%s' with args '%s'\\n\", filt_name, args);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3721, "substitutes": {"filt_ctx": ["filt___context", "filt___voc", "filt_loc", "flt_context", "filt_c", "flt_lc", "fil_ca", "filt___ca", "flt_cp", "fill_ctx", "filt_conn", "filt_context", "fil_cs", "fill_ca", "filt___ctx", "filt_scope", "filt_cs", "fil_cmd", "fill_context", "filt_ca", "filt_cp", "filt_cmd", "filt_voc", "filt_lc", "flt_loc", "flt_ctx", "fil_ctx", "fil_scope", "flt_conn", "fil_conn", "fill_c", "fil_context", "fil_voc"], "ctx": ["support", "cas", "cc", "cu", "cfg", "pkg", "loc", "sc", "cf", "cpp", "cmp", "context", "cs", "rc", "fc", "conv", "cca", "exec", "ci", "src", "connection", "xc", "cli", "config", "cam", "concept", "obj", "graph", "qa", "Context", "tc", "cv", "cp", "conn", "pc", "ca", "cn", "c", "ctrl", "comp", "scope", "cb", "tx", "crit", "ck", "cmd", "bc", "cm", "client", "lc"], "index": ["example", "offset", "fff", "find", "part", "base", "loc", "match", "context", "active", "num", "ref", "connection", "ind", "input", "config", "name", "id", "Index", "len", "slice", "end", "pos", "prefix", "type", "search", "column", "length", "current", "info", "depth", "image", "col", "inc", "f", "size", "addr", "instance", "x"], "filt_name": ["filt__name", "filtacname", "flt_Name", "filt_id", "filtFname", "filt_node", "factory_names", "filtacnames", "filtFName", "filtPblock", "fill_name", "flt_name", "filtacNAME", "filtFvalue", "filt_value", "ffilter_path", "factory_name", "fil_names", "filtactype", "fill_Name", "filt__NAME", "factory_NAME", "filt_path", "ffilter_name", "factoryacname", "ffilter_Name", "factoryacnames", "filt__Name", "fill_value", "flt_id", "fillFName", "filt_Name", "fil_Name", "filt_NAME", "filt_names", "factoryactype", "filt_type", "filt_block", "filtPpath", "filt__type", "flt_node", "factory_type", "filt__names", "filtPname", "ffilter_block", "fillFname", "factoryacNAME", "filtPName", "fillFvalue", "fil_name"], "args": ["example", "cards", "cache", "flags", " arguments", "comments", "works", "array", "ics", "resources", "enc", "changes", "null", "values", "alloc", "ig", "bits", "Args", "ras", "ips", "items", "fields", "groups", "arr", "includes", "p", "config", "names", "ids", "name", "acl", "blocks", "qa", "actions", "ages", "alls", "help", "ass", "missing", "str", "data", "afi", "lines", "spec", "vals", "body", "ay", "results", "ams", "files", "gs", "allows", "result", "options", "bytes", "init", "arg", "limits", "parts", "strings", "objects", "links", "extra", "size", "ars", "empty", "atts", "params"], "log_ctx": ["log_cci", "logenscope", "fail_ctx", "logwcb", "tagercb", "lock_ca", "logenca", "logboardctx", "logencci", "logingcb", "log_ca", "tag_ctx", "log_sys", "logboardsc", "lock_scope", "failpctx", "logpcf", "tag_sys", "logboardjc", "tagersys", "logenctx", "logingctx", "logalfn", "logwsys", "logerctx", "Log_ctx", "logalctx", "Log_context", "logervc", "tagerctx", "tag_cb", "log_sc", "log_fn", "fail_fn", "lock_ctx", "failpfn", "log_vc", "tagervc", "failpcf", "logalcf", "lock_cci", "log_cf", "failpcn", "logboardcontext", "logpcn", "logingvc", "log_scope", "Log_sc", "fail_cn", "log_context", "logercb", "log_cn", "logwctx", "logwvc", "tag_vc", "logingsys", "log_jc", "fail_cf", "Log_jc", "logpfn", "logpctx", "log_cb", "logalcn", "logersys"], "filt": ["fld", " fld", " facet", "fizzle", "sffilter", "Fizzle", "sfilt", "flilt", " fil", "infizzle", "flt", "Flt", "sfacet", "bld", "dfilt", "sfld", "dfld", "filler", "bil", "fil", "firt", "dfiller", "flld", " ffilter", "biller", " flt", "inffilter", "sflt", "Filt", "sfizzle", "ffilter", "infirt", "dfil", "flizzle", "Facet", " filler", " firt", "infilt", "flirt", "bilt", " fizzle", "infld", "facet"], "inst_name": ["inst_info", "instance_prefix", "inst__id", "inst_names", "inst_prefix", "instameName", " inst_conn", "instance_name", "instacdata", "inst__span", "inst_Name", " inst_Name", "instamename", "inst__name", "instamespan", "Inst_name", "inst_id", "instameid", "instance_names", "instacnames", "inst_span", "Inst_names", "instance_info", " inst_names", "inst_conn", "Inst_data", "inst_data", "instacname", " inst_span", "inst__Name", " inst_id"], "tmp_args": ["temp_arg", "tmp2arg", " tmp_params", "temp_items", "tmp_items", "tmp_params", "tmp_ams", "temp_ams", "tmp_members", "temp_errors", "tmp2parts", " tmp_caps", "tmp2caps", "tmp_parts", " tmp_options", "temp_args", " tmp_arg", "tmp_arg", "temp_members", "tmp_caps", "tmp_errors", "tmp_options", " tmp_parts", "tmp2args"], "ret": ["val", "let", "fail", "rb", "res", "part", "value", "bad", "back", "r", "base", "match", "att", "rc", "def", "tr", "rt", "code", "flag", "num", "grad", "pet", "alt", "utf", "debug", "valid", "opt", "RET", "arr", "ref", "mem", "det", "gc", "gt", "job", "obj", "red", "len", "run", "bot", "lit", "ut", "success", "ext", "rets", "feat", "str", "data", "reply", "mt", "fun", "nt", "reg", "url", "info", "result", "arg", "Ret", "al", "f", "db", "ft", "cur", "err", "re", "pass"]}}
{"project": "FFmpeg", "commit_id": "dae7ff04160901a30a35af05f2f149b289c4f0b1", "target": 1, "func": "static void decode_mclms(WmallDecodeCtx *s)\n\n{\n\n    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;\n\n    s->mclms_scaling = get_bits(&s->gb, 4);\n\n    if(get_bits1(&s->gb)) {\n\n\t// mclms_send_coef\n\n\tint i;\n\n\tint send_coef_bits;\n\n\tint cbits = av_log2(s->mclms_scaling + 1);\n\n\tassert(cbits == my_log2(s->mclms_scaling + 1));\n\n\tif(1 << cbits < s->mclms_scaling + 1)\n\n\t    cbits++;\n\n\n\n\tsend_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;\n\n\n\n\tfor(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {\n\n\t    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);\n\n\t}\n\n\n\n\tfor(i = 0; i < s->num_channels; i++) {\n\n\t    int c;\n\n\t    for(c = 0; c < i; c++) {\n\n\t\ts->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);\n\n\t    }\n\n\t}\n\n    }\n\n}\n", "idx": 3722, "substitutes": {"s": ["uns", "conf", "sec", "v", "states", "ps", "lines", "sb", "sym", "os", "f", "parts", "this", "js", "l", "sites", "is", "si", "qs", "o", "y", "p", "less", "se", "ses", "site", "args", "features", "b", "sg", "u", "side", "ops", "sup", "sync", "h", "S", "r", "comm", "hs", "settings", "cs", "ssl", "south", "new", "m", "sq", "session", "w", "full", "service", "g", "server", "spec", "es", "gs", "t", "ss", "e", "ls", "ds", "xs", "fs", "ms", "su", "sets", "ts", "ns", "ims", "n", "services", "a", "sys", "sf", "rs", "self", "tests"], "i": ["hi", "phi", "ui", "io", "l", "fi", "si", "is", "j", "uri", "code", "o", "y", "p", "ci", "multi", "qi", "eni", "cli", "oi", "id", "mi", "z", "ri", "k", "ini", "ii", "slice", "v", "bi", "x", "mini", "li", "iu", "ie", "ji", "in", "zi", "di", "ix", "ai", "info", "init", "ch", "pi", "gi", "b", "u", "f", "ti", "ip", "ni", "e", "xi", "I", "it", "ki", "yi", "index"], "send_coef_bits": ["send_coeff_words", "send_coof_notes", "send_coefxnotes", "send_coof_parts", "send_coiffacvals", "send_coiff_bits", "send_coiff_points", "send_coefacbits", "send_coefacvals", "send_coef_blocks", "send_coef2bit", "send_coefxdetails", "send_coef_words", "send_coef32vals", "send_coef_dates", "send_coefacdetails", "send_coeff_bit", "send_coof_details", "send_coef_bit", "send_coef2jobs", "send_coef2words", "send_coef_points", "send_coefxparts", "send_coefpdates", "send_coef_jobs", "send_coefpbits", "send_coef32bits", "send_coef2bits", "send_coiffacbits", "send_coef_vals", "send_coef_details", "send_coefxbits", "send_coof_bits", "send_coef_notes", "send_coeff_dates", "send_coef32details", "send_coefpbit", "send_coeff_blocks", "send_coiffacpoints", "send_coeff_bits", "send_coefacpoints", "send_coef_parts", "send_coiffacdetails", "send_coef32points", "send_coiff_vals", "send_coeff_jobs", "send_coefpblocks", "send_coiff_details"], "cbits": ["ucbits", "crints", "pclocks", " cbugs", "cfubs", "cfrows", "crbits", "cfsteps", "cbands", " clocks", "cbps", "cbs", "cints", "fbit", " cbs", "ecbits", "ccbits", "cfplanes", "ucplanes", " crows", " cbps", "lcits", "cbit", "fubs", "lcbits", "cjobs", "dcbits", "lcubs", "cfbs", " cits", "crbps", "ccbps", "cits", "ecrows", " cbytes", "cfbytes", " csteps", "cplanes", " cplanes", " cjobs", "Cbits", "dclocks", "pcjobs", "ccbytes", " cints", "Cbps", " cbands", "csteps", "crubs", "ucbytes", "cfbps", "ucubs", " cbit", "crows", "ecbs", "cbugs", "cfbits", "dcbands", "ecsteps", "cfints", "Cbugs", "dcjobs", "cbytes", "ccbugs", "fbits", "Cbytes", "clocks", "pcbits", "cubs", "lcbit", "pcbands", "fits", " cubs"], "c": ["ice", "cu", "dc", "cache", "cc", "cr", "r", "cy", "sc", "cf", "ac", "l", "chain", "code", "n", "arc", "y", "core", "o", "p", "ci", "ic", "ec", "xc", "d", "m", "ct", "z", "w", "k", "count", "v", "cp", "x", "lc", "pc", "ca", "co", "nc", "ch", "col", "oc", "t", "b", "f", "u", "q", "inc", "cur", "C", "e", "cycle", "bc", "uc", "ce"]}}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static void ppc_spapr_init(ram_addr_t ram_size,\n                           const char *boot_device,\n                           const char *kernel_filename,\n                           const char *kernel_cmdline,\n                           const char *initrd_filename,\n                           const char *cpu_model)\n{\n    PowerPCCPU *cpu;\n    CPUPPCState *env;\n    int i;\n    MemoryRegion *sysmem = get_system_memory();\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    target_phys_addr_t rma_alloc_size, rma_size;\n    uint32_t initrd_base = 0;\n    long kernel_size = 0, initrd_size = 0;\n    long load_limit, rtas_limit, fw_size;\n    long pteg_shift = 17;\n    char *filename;\n    spapr = g_malloc0(sizeof(*spapr));\n    QLIST_INIT(&spapr->phbs);\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n    /* Allocate RMA if necessary */\n    rma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);\n    if (rma_alloc_size == -1) {\n        hw_error(\"qemu: Unable to create RMA\\n\");\n        exit(1);\n    }\n    if (rma_alloc_size && (rma_alloc_size < ram_size)) {\n        rma_size = rma_alloc_size;\n    } else {\n        rma_size = ram_size;\n    }\n    /* We place the device tree and RTAS just below either the top of the RMA,\n     * or just below 2GB, whichever is lowere, so that it can be\n     * processed with 32-bit real mode code if necessary */\n    rtas_limit = MIN(rma_size, 0x80000000);\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n    /* init CPUs */\n    if (cpu_model == NULL) {\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n    }\n    for (i = 0; i < smp_cpus; i++) {\n        cpu = cpu_ppc_init(cpu_model);\n        if (cpu == NULL) {\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n            exit(1);\n        }\n        env = &cpu->env;\n        /* Set time-base frequency to 512 MHz */\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n        qemu_register_reset(spapr_cpu_reset, cpu);\n        env->hreset_vector = 0x60;\n        env->hreset_excp_prefix = 0;\n        env->gpr[3] = env->cpu_index;\n    }\n    /* allocate RAM */\n    spapr->ram_limit = ram_size;\n    if (spapr->ram_limit > rma_alloc_size) {\n        ram_addr_t nonrma_base = rma_alloc_size;\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n        memory_region_init_ram(ram, \"ppc_spapr.ram\", nonrma_size);\n        vmstate_register_ram_global(ram);\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n    }\n    /* allocate hash page table.  For now we always make this 16mb,\n     * later we should probably make it scale to the size of guest\n     * RAM */\n    spapr->htab_size = 1ULL << (pteg_shift + 7);\n    spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size);\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n        env->external_htab = spapr->htab;\n        env->htab_base = -1;\n        env->htab_mask = spapr->htab_size - 1;\n        /* Tell KVM that we're in PAPR mode */\n        env->spr[SPR_SDR1] = (unsigned long)spapr->htab |\n                             ((pteg_shift + 7) - 18);\n        env->spr[SPR_HIOR] = 0;\n        if (kvm_enabled()) {\n            kvmppc_set_papr(env);\n        }\n    }\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n                                           rtas_limit - spapr->rtas_addr);\n    if (spapr->rtas_size < 0) {\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n        exit(1);\n    }\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n        exit(1);\n    }\n    g_free(filename);\n    /* Set up Interrupt Controller */\n    spapr->icp = xics_system_init(XICS_IRQS);\n    spapr->next_irq = 16;\n    /* Set up VIO bus */\n    spapr->vio_bus = spapr_vio_bus_init();\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n        if (serial_hds[i]) {\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n        }\n    }\n    /* Set up PCI */\n    spapr_create_phb(spapr, \"pci\", SPAPR_PCI_BUID,\n                     SPAPR_PCI_MEM_WIN_ADDR,\n                     SPAPR_PCI_MEM_WIN_SIZE,\n                     SPAPR_PCI_IO_WIN_ADDR);\n    for (i = 0; i < nb_nics; i++) {\n        NICInfo *nd = &nd_table[i];\n        if (!nd->model) {\n            nd->model = g_strdup(\"ibmveth\");\n        }\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n            spapr_vlan_create(spapr->vio_bus, nd);\n        } else {\n            pci_nic_init_nofail(&nd_table[i], nd->model, NULL);\n        }\n    }\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n        spapr_vscsi_create(spapr->vio_bus);\n    }\n    if (rma_size < (MIN_RMA_SLOF << 20)) {\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n        exit(1);\n    }\n    fprintf(stderr, \"sPAPR memory map:\\n\");\n    fprintf(stderr, \"RTAS                 : 0x%08lx..%08lx\\n\",\n            (unsigned long)spapr->rtas_addr,\n            (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1));\n    fprintf(stderr, \"FDT                  : 0x%08lx..%08lx\\n\",\n            (unsigned long)spapr->fdt_addr,\n            (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1));\n    if (kernel_filename) {\n        uint64_t lowaddr = 0;\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n        if (kernel_size < 0) {\n            kernel_size = load_image_targphys(kernel_filename,\n                                              KERNEL_LOAD_ADDR,\n                                              load_limit - KERNEL_LOAD_ADDR);\n        }\n        if (kernel_size < 0) {\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n                    kernel_filename);\n            exit(1);\n        }\n        fprintf(stderr, \"Kernel               : 0x%08x..%08lx\\n\",\n                KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1);\n        /* load initrd */\n        if (initrd_filename) {\n            /* Try to locate the initrd in the gap between the kernel\n             * and the firmware. Add a bit of space just in case\n             */\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n                                              load_limit - initrd_base);\n            if (initrd_size < 0) {\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n                        initrd_filename);\n                exit(1);\n            }\n            fprintf(stderr, \"Ramdisk              : 0x%08lx..%08lx\\n\",\n                    (long)initrd_base, (long)(initrd_base + initrd_size - 1));\n        } else {\n            initrd_base = 0;\n            initrd_size = 0;\n        }\n    }\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME);\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n    if (fw_size < 0) {\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n        exit(1);\n    }\n    g_free(filename);\n    fprintf(stderr, \"Firmware load        : 0x%08x..%08lx\\n\",\n            0, fw_size);\n    fprintf(stderr, \"Firmware runtime     : 0x%08lx..%08lx\\n\",\n            load_limit, (unsigned long)spapr->fdt_addr);\n    spapr->entry_point = 0x100;\n    /* SLOF will startup the secondary CPUs using RTAS */\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n        env->halted = 1;\n    }\n    /* Prepare the device tree */\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, rma_size,\n                                            initrd_base, initrd_size,\n                                            kernel_size,\n                                            boot_device, kernel_cmdline,\n                                            pteg_shift + 7);\n    assert(spapr->fdt_skel != NULL);\n    qemu_register_reset(spapr_reset, spapr);\n}", "idx": 3731, "substitutes": {"ram_size": ["gram_name", "ram_name", "ram_content", "mem_number", "ram64address", "gram_address", "ram_limit", "ram_shift", "gram_size", "mem_capacity", "ram_capacity", "ram64name", "gram_content", "ram_number", "ramallsize", "disk_shift", "ramallshift", "ram64size", "mem_size", "ramalllimit", "ram64content", "disk_size", "disk_limit", "ram_address", "mem_limit"], "boot_device": ["boot_model", "boot_platform", "bootboardplatform", "bootaldevice", "kernel_model", "kernel_mode", "bootboarddevice", "bootalplatform", "bootboardmode", "bootalmodel", "boot_mode", "bootalmode", "kernel_platform", "kernel_device", "bootboardmodel"], "kernel_filename": ["kernel_file", " kernel_platform", "kernel_mode", " kernel_file", "kernelnfilename", "kernelnmode", " kernel_mode", "kernelnfile", "kernel_platform", "kernelnplatform"], "kernel_cmdline": ["kernel_hostlines", "kernel_argname", "kernel_commandname", "kernel_arglen", "kernel_hostline", "kernel_arglines", "kernel_commandline", "kernel_cmdlen", "kernel_commandlines", "kernel_argline", "kernel_hostlen", "kernel_hostname", "kernel_commandlen", "kernel_cmdlines", "kernel_cmdname"], "initrd_filename": ["initrd_buffer", "initrd_name", "initrt_buffer", "initrt_name", "initrt_filename", "initrd_file", "initrt_file"], "cpu_model": ["processor_module", "pu_controller", "pu__state", "cpu__model", "cpu_models", "pu_models", "CPU_model", " cpu_Model", " cpu_models", "CPU_models", "cpu67models", "cpu_unit", "pu__controller", "processor_service", "cpu67model", "pu__models", "processor_model", " cpu_module", "cpu_Model", "cpu_service", "cpu_module", "processor_mode", "pu_state", "cpu_state", "cpu_controller", "cpu__controller", "cpu67Model", "CPU_Model", "CPU_unit", "cpu__state", "pu__model", "cpu__models", "pu_model", "cpu67unit", "cpu_mode"], "cpu": ["clock", "cache", "pai", "lu", "rc", "uci", "cmp", "pb", "ctx", "uu", "num", "linux", "core", "uca", "computer", "p", "kernel", "runner", "gc", "node", "chu", "eni", " CPU", "config", "gp", "vm", "hu", "platform", "cp", "GPU", "gpu", "python", "pc", "lc", "conn", "uno", "bench", "consumer", "cn", "ne", "css", "pool", "nu", "nc", "np", "auc", "pu", "pn", "process", "PU", "performance", "proc", "nic", "hp", "CPU", "ni", "instance", "xi", "processor", "hw"], "env": ["dep", "assets", "cache", "cfg", "attr", "context", "enc", "profile", "eye", "conf", "core", "ani", "eu", "ep", "stack", "ec", "viron", "eni", "config", "session", "queue", "skin", "edge", "vm", " environment", "v", "agents", "here", "energy", "conn", "el", "ext", "dest", "console", "ea", "eng", "enable", "scope", "ef", "np", "exc", "state", "network", "args", "dict", "global", "db", "gui", "que", "err", "estate", "vel", "e", "environment", "shell", "net", "ev", "en", "Environment"], "i": ["gu", "hi", "phi", "chi", "anti", "ui", "io", "fi", "si", "is", "j", "n", "uri", "o", "p", "ci", "sim", "multi", "qi", "eni", "d", "m", "oi", "id", "z", "mi", "w", "ri", "k", "ini", "ii", "v", "a", "mini", "uli", "li", "ami", "iu", "c", "in", "di", "ix", "ai", "pi", "mu", "t", "b", "f", "u", "gi", "ti", "ip", "ni", "e", "xi", "I", "ki", "index"], "sysmem": ["Sysmem", "systemmem", "Sysmon", "Sysmax", "ysmemory", " sysram", " sysmodel", "sysmodel", "sysmemory", "Syslim", "ysmem", "systemmemory", "osmem", "osmon", " sysmon", "osmax", "sysram", " sysmax", " syslim", "oslim", "systemram", "ysmodel", " sysmemory", "sysmax", "systemmodel", "ysram", "sysmon", "syslim"], "ram": ["man", "rum", "cache", "iam", "Ram", "sc", "array", "disk", "img", "mem", "rage", "config", "cam", "access", "mm", "dim", "loader", "gram", "RAM", "cow", "image", "network", "gam", "range", "resource", "region", "gra", "ra"], "rma_alloc_size": ["rma_alloc_name", "rma_alloc0limit", "rma_alloc67number", "rma_allocadlen", "rma_raw67len", "rma_allocacstream", "rma_alloc_storage", "rma_alloc_small", "rma_raw67value", "rma_alloc_offset", "rma_allocaclen", "rma_raw67number", "rma_disk0scale", "rma_alloc67size", "rma_raw67size", "rma_disk_capacity", "rma_raw_value", "rma_alloc64address", "rma_alloc_capacity", "rma_alloc64sn", "rma_alloc64size", "rma_oc_stream", "rma_alloc67value", "rma_alloclexvalue", "rma_raw_number", "rma_alloclexlen", "rma_alloc1address", "rma_allocadsize", "rma_alloc1name", "rma_disk0limit", "rma_alloc1size", "rma_alloclexnumber", "rma_alloc67len", "rma_allocacsmall", "rma_allocacsize", "rma_disk_limit", "rma_allocadvalue", "rma_disk_scale", "rma_disk_size", "rma_raw_size", "rma_oc_size", "rma_alloc_weight", "rma_alloc_value", "rma_alloc_len", "rma_alloc_number", "rma_alloc_sn", "rma_oc_small", "rma_alloc_limit", "rma_alloclexsize", "rma_alloc64weight", "rma_oc_len", "rma_disk0capacity", "rma_alloc0size", "rma_raw_len", "rma_alloc0capacity", "rma_allocadnumber", "rma_alloc_stream", "rma_disk0size", "rma_alloc_scale", "rma_alloc_address", "rma_alloc1storage", "rma_alloc0scale"], "rma_size": ["rlia67shape", "rma__term", "rma__shape", "rma__size", "rsha_full", "rma___capacity", "rma_shape", "rlia_term", "rama_speed", "rma_speed", "rlia_address", "rma_capacity", "rda_size", "rlia_size", "rda_capacity", "rsha_capacity", "rma67handle", "rlia67address", "rma_handle", "rama_size", "rlia67size", "rma_name", "rda_handle", "rma67term", "rma_source", "rama_source", "rma67shape", "rma___full", "rma67capacity", "rma_full", "rlia67term", "rma67size", "rma_length", "rsha_length", "rda_name", "rama_capacity", "rma_address", "rma___length", "rma___size", "rma_term", "rsha_size", "rlia_shape", "rma67name", "rma67address", "rma__address"], "load_limit": ["fw_position", "fw_source", " load_limits", "fw_lim", " load_lim", "load_lim", "load_position", "loadalllim", "load_limits", "load_origin", "loadallsource", "loadallposition", "load_source", "loadalllimit", "fw_limit", " load_origin"], "rtas_limit": ["rtras_limits", "rtma2len", "rtma2size", "rtras_limited", "rtras_limit", "rtas2size", "rtma_size", "rtas2len", "rtas_num", "rtras_size", "rtma_num", "rtma2lim", "rtas_limited", "rtma_len", "rtas_large", "rtas_len", "rtma_limit", "rtas_limits", "rtas2limit", "rtma_lim", "rtma_large", "rtas_lim", "rtma2limit", "rtas2lim", "rtas_size"], "fw_size": ["fwlexsize", "fw_scale", "fw0size", "hw_scale", "fwlexscale", "hw_offset", "fw0offset", "fw0scale", "fw_offset", "fwlexoffset", "fwlexdata", "fw_data", "fw0data", "hw_data", "hw_size"], "filename": ["fn", "password", "binary", "fp", "src", "acl", "name", "buffer", "Filename", "memory", "buf", "loader", "prefix", "file", "fd", "url", "dll", "files", "kl", "wav", "f", "shell", "username", "path"]}}
{"project": "FFmpeg", "commit_id": "69d0a2922f76e4e121c9f434bdf29f55b26c0c66", "target": 0, "func": "static av_cold int sonic_encode_init(AVCodecContext *avctx)\n\n{\n\n    SonicContext *s = avctx->priv_data;\n\n    PutBitContext pb;\n\n    int i, version = 0;\n\n\n\n    if (avctx->channels > MAX_CHANNELS)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono and stereo streams are supported by now\\n\");\n\n        return AVERROR(EINVAL); /* only stereo or mono for now */\n\n    }\n\n\n\n    if (avctx->channels == 2)\n\n        s->decorrelation = MID_SIDE;\n\n    else\n\n        s->decorrelation = 3;\n\n\n\n    if (avctx->codec->id == AV_CODEC_ID_SONIC_LS)\n\n    {\n\n        s->lossless = 1;\n\n        s->num_taps = 32;\n\n        s->downsampling = 1;\n\n        s->quantization = 0.0;\n\n    }\n\n    else\n\n    {\n\n        s->num_taps = 128;\n\n        s->downsampling = 2;\n\n        s->quantization = 1.0;\n\n    }\n\n\n\n    // max tap 2048\n\n    if ((s->num_taps < 32) || (s->num_taps > 1024) ||\n\n        ((s->num_taps>>5)<<5 != s->num_taps))\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid number of taps\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    // generate taps\n\n    s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant));\n\n    for (i = 0; i < s->num_taps; i++)\n\n        s->tap_quant[i] = ff_sqrt(i+1);\n\n\n\n    s->channels = avctx->channels;\n\n    s->samplerate = avctx->sample_rate;\n\n\n\n    s->block_align = 2048LL*s->samplerate/(44100*s->downsampling);\n\n    s->frame_size = s->channels*s->block_align*s->downsampling;\n\n\n\n    s->tail_size = s->num_taps*s->channels;\n\n    s->tail = av_calloc(s->tail_size, sizeof(*s->tail));\n\n    if (!s->tail)\n\n        return AVERROR(ENOMEM);\n\n\n\n    s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) );\n\n    if (!s->predictor_k)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < s->channels; i++)\n\n    {\n\n        s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples));\n\n        if (!s->coded_samples[i])\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples));\n\n\n\n    s->window_size = ((2*s->tail_size)+s->frame_size);\n\n    s->window = av_calloc(s->window_size, sizeof(*s->window));\n\n    if (!s->window)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avctx->extradata = av_mallocz(16);\n\n    if (!avctx->extradata)\n\n        return AVERROR(ENOMEM);\n\n    init_put_bits(&pb, avctx->extradata, 16*8);\n\n\n\n    put_bits(&pb, 2, version); // version\n\n    if (version == 1)\n\n    {\n\n        put_bits(&pb, 2, s->channels);\n\n        put_bits(&pb, 4, code_samplerate(s->samplerate));\n\n    }\n\n    put_bits(&pb, 1, s->lossless);\n\n    if (!s->lossless)\n\n        put_bits(&pb, 3, SAMPLE_SHIFT); // XXX FIXME: sample precision\n\n    put_bits(&pb, 2, s->decorrelation);\n\n    put_bits(&pb, 2, s->downsampling);\n\n    put_bits(&pb, 5, (s->num_taps >> 5)-1); // 32..1024\n\n    put_bits(&pb, 1, 0); // XXX FIXME: no custom tap quant table\n\n\n\n    flush_put_bits(&pb);\n\n    avctx->extradata_size = put_bits_count(&pb)/8;\n\n\n\n    av_log(avctx, AV_LOG_INFO, \"Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\\n\",\n\n        version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling);\n\n\n\n    avctx->frame_size = s->block_align*s->downsampling;\n\n\n\n    return 0;\n\n}\n", "idx": 3743, "substitutes": {"avctx": ["afcontext", "avconn", "avecmp", "AVcf", "AVctx", "appcmp", "avcn", "avectx", "evconn", "afcn", "abconfig", "avcli", "alcli", "abctx", "AVconfig", " avcontext", "avcmp", " avcf", "aveconfig", "AVcn", "afcms", "rafconn", "abcontext", " avconn", "alctx", "aveconn", "AVcli", "AVconn", "evcf", "afconn", " avcli", "avcf", "afcmp", "abconn", "afctx", "avecontext", "evctx", "alcontext", "appctx", "rafcms", "rafcontext", "AVcms", "evcontext", "avconfig", "alconn", "AVcontext", "appcontext", "avcontext", "AVcmp", "rafctx", "appcn", "afcf", "avcms", "afconfig", "avecf"], "s": ["uns", "sec", "conf", "d", "v", "states", "ps", "secondary", "results", "sym", "parts", "f", "os", "as", "this", "js", "l", "sites", "is", "si", "qs", "o", "p", "less", "ins", "stats", "ses", "site", "args", "features", "b", "sg", "u", "ops", "plugins", "sync", "h", "S", "uses", "r", "sc", "settings", "hs", "cs", "ctx", "ssl", "new", "m", "sq", "session", "bs", "w", "full", "your", "g", "us", "server", "spec", "ks", "es", "gs", "t", "native", "aws", "ss", "e", "ls", "ds", "xs", "fs", "ms", "su", "sets", "ts", "ns", "n", "ims", "rates", "services", "a", "sys", "c", "rs", "in", "ats", "self", "vs", "its", "tests"], "pb": [" self", " out", " impl", " img", " cipher", "ctx", " enc", " sc", " proto", " src", " p", " parent", " conv", " plugin", " mc", " conf", " app", " pl", " config", " std", " subp", " sp", " rc", " sup"], "i": ["hi", "chi", "ui", "io", "it", "fi", "si", "j", "num", "n", "o", "y", "p", "ci", "key", "multi", "qi", "eni", "d", "m", "id", "z", "I", "mi", "k", "len", "ii", "ini", "count", "v", "a", "bi", "mini", "type", "li", "uli", "iu", "ji", "c", "in", "zi", "current", "counter", "di", "ix", "ai", "info", "abi", "pi", "mu", "t", "gi", "b", "u", "version", "ti", "ip", "ni", "e", "xi", "x", "inner", "phi", "yi", "index"]}}
{"project": "FFmpeg", "commit_id": "2005fddcbb4e18e8f7c34326e40609e4a2d83c31", "target": 0, "func": "int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)\n\n{\n\n    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };\n\n    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };\n\n\n\n    if (mode > 6U) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"out of range intra chroma pred mode at %d %d\\n\",\n\n               h->mb_x, h->mb_y);\n\n        return -1;\n\n    }\n\n\n\n    if (!(h->top_samples_available & 0x8000)) {\n\n        mode = top[mode];\n\n        if (mode < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"top block unavailable for requested intra mode at %d %d\\n\",\n\n                   h->mb_x, h->mb_y);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if ((h->left_samples_available & 0x8080) != 0x8080) {\n\n        mode = left[mode];\n\n        if (is_chroma && (h->left_samples_available & 0x8080)) {\n\n            // mad cow disease mode, aka MBAFF + constrained_intra_pred\n\n            mode = ALZHEIMER_DC_L0T_PRED8x8 +\n\n                   (!(h->left_samples_available & 0x8000)) +\n\n                   2 * (mode == DC_128_PRED8x8);\n\n        }\n\n        if (mode < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"left block unavailable for requested intra mode at %d %d\\n\",\n\n                   h->mb_x, h->mb_y);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return mode;\n\n}\n", "idx": 3748, "substitutes": {"h": ["hm", "hi", "host", "home", "rh", "r", "auth", "l", "hs", "um", "context", "hh", "ctx", "gh", "sh", "header", "y", "adh", "p", "ht", "ha", "hash", "hist", "m", "hl", "k", "hu", "kh", "oh", "v", "th", "uh", "conn", "ah", "g", "him", "c", "ph", "eh", "hr", "he", "bh", "dh", "ch", "ih", "hd", "t", "hp", "history", "f", "u", "b", "q", "e", "http", "hw", "H"], "mode": ["driver", "md", "when", "ko", "phase", "home", "role", "match", "key", "rage", "mi", "access", "position", "power", "state", "move", "max", "cost", "go", "message", "step", "mod", "ui", "error", "language", "de", "option", "kind", "name", "stage", "ride", "time", "method", "route", "mission", "success", "mid", "site", "ace", "style", "side", "slave", "rule", "shift", "project", "device", "mega", "date", "code", "core", "m", "Mode", "theme", "member", "maybe", "me", "level", "cmd", "ode", "mage", "size", "gone", "use", "lane", "month", "source", "model", "purpose", "scale", "rc", "grade", "command", "module", "delay", "id", "ward", "guide", "no", "dim", "type", "mate", "ror", "du", "direction", "MODE", "depth", "result", "feature", "none", "version", "range"], "is_chroma": ["is_roman", "is_chroman", "is_chromo", "is_comA", "is_chromb", "is_operb", "is_chromi", "is_coman", "is_romA", "is_coma", "is_roma", "is_operA", "is_opera", "is_operan", "is_operas", "is_opero", "is_chromA", "is_operi", "is_romb", "is_romo", "is_romas", "is_romi", "is_comas", "is_chromas"], "top": ["high", "next", "all", "Top", "TOP", "hop", "header", "bottom", "opt", "best", "up", "root", "config", "primary", "call", "first", "pop", "head", "table", "bot", "full", "master", "above", "front", "to", "ap", "current", "prev", "plus", "toc", "tops", "max", "op", "dot", "upper"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)\n\n{\n\n    int bits = 8, sign = 0, shift = 0;\n\n\n\n    switch (as->fmt) {\n\n    case AUD_FMT_S8:\n\n        sign = 1;\n\n    case AUD_FMT_U8:\n\n        break;\n\n\n\n    case AUD_FMT_S16:\n\n        sign = 1;\n\n    case AUD_FMT_U16:\n\n        bits = 16;\n\n        shift = 1;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n        sign = 1;\n\n    case AUD_FMT_U32:\n\n        bits = 32;\n\n        shift = 2;\n\n        break;\n\n    }\n\n\n\n    info->freq = as->freq;\n\n    info->bits = bits;\n\n    info->sign = sign;\n\n    info->nchannels = as->nchannels;\n\n    info->shift = (as->nchannels == 2) + shift;\n\n    info->align = (1 << info->shift) - 1;\n\n    info->bytes_per_second = info->freq << info->shift;\n\n    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);\n\n}\n", "idx": 3755, "substitutes": {"info": ["update", "i", "home", "diff", "part", "setup", "private", "conf", "opt", "tf", "ions", "check", "qa", "afi", "ami", "image", "state", "f", "this", "show", "inf", "ui", "Info", "manager", "auth", "error", "si", "from", "p", "config", "name", "li", "data", "add", "app", "now", "init", "op", "it", "about", "comment", "next", "offset", "tp", "base", "io", "iso", "new", "fo", "obj", "full", "help", "txt", "options", "extra", "http", "INFO", "hi", "die", "back", "hand", "def", "id", "api", "note", "ii", "off", "py", "end", "fw", "util", "start", "di", "result", "parse", "inner"], "as": ["las", "by", "auth", "ac", "is", "at", "or", "ras", "alias", "off", "var", "pas", "se", "bs", "ga", "session", "api", "ma", "sa", "an", "acs", "ase", "ans", "am", "a", "AS", "ass", "asc", "As", "sys", "asu", "func", "nas", "afi", "ast", "us", "to", "spec", "ap", "ar", "rs", "asm", "parser", "ams", "ace", "asi", "al", "asp", "os", "pa", "aws", "address", "ars", "ss", "bas", "http", "s", "so"]}}
{"project": "qemu", "commit_id": "4fb588e95bacb770746cc794ef165fd71a4d27ea", "target": 0, "func": "static void block_job_completed_txn_abort(BlockJob *job)\n\n{\n\n    AioContext *ctx;\n\n    BlockJobTxn *txn = job->txn;\n\n    BlockJob *other_job, *next;\n\n\n\n    if (txn->aborting) {\n\n        /*\n\n         * We are cancelled by another job, which will handle everything.\n\n         */\n\n        return;\n\n    }\n\n    txn->aborting = true;\n\n    /* We are the first failed job. Cancel other jobs. */\n\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n\n        ctx = blk_get_aio_context(other_job->blk);\n\n        aio_context_acquire(ctx);\n\n    }\n\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n\n        if (other_job == job || other_job->completed) {\n\n            /* Other jobs are \"effectively\" cancelled by us, set the status for\n\n             * them; this job, however, may or may not be cancelled, depending\n\n             * on the caller, so leave it. */\n\n            if (other_job != job) {\n\n                block_job_cancel_async(other_job);\n\n            }\n\n            continue;\n\n        }\n\n        block_job_cancel_sync(other_job);\n\n        assert(other_job->completed);\n\n    }\n\n    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {\n\n        ctx = blk_get_aio_context(other_job->blk);\n\n        block_job_completed_single(other_job);\n\n        aio_context_release(ctx);\n\n    }\n\n}\n", "idx": 3763, "substitutes": {"job": ["lock", "jo", "manager", "worker", "base", "bug", "project", "Job", "section", "sub", "error", "object", "pb", "j", "runner", "connection", "new", "node", "module", "config", "queue", "session", "hide", "route", "fake", "run", "jobs", "event", "unknown", "batch", "parent", "work", "output", "ob", "plugin", "result", "block", "process", "image", "cb", "db", "b", "better", "address", "live", "child", "slave", "client", "sync"], "ctx": ["kb", "kw", "cu", "cc", "dc", "cr", "pkg", "mac", "req", "loc", "sc", "cf", "fc", "rc", "context", "cs", "grad", "cmp", "lib", "rx", "fp", "ci", "cca", "kk", "gc", "xc", "ct", "config", "sq", "acl", "voc", "buf", "qa", "cv", "cp", "lc", "conn", "pc", "ca", "co", "coll", "txt", "cn", "css", "c", "ctrl", "np", "scope", "jp", "mc", "tx", "crit", "ck", "cmd", "client", "bc", "cas", "sync", "cm", "anc", "cus"], "txn": ["Txg", "txnb", "TXg", "rtl", "xn", "cfnb", "txns", "ftn", " txb", "txtb", "xb", "tempp", "cfns", "Txn", "Txp", "cfn", "xnan", "rxN", "txN", "txtN", "txb", "rxn", "txnet", "tempns", "rtn", "rxb", "txnan", "Txb", "txtn", "TXn", "ctxns", "cfl", "rtnb", "TXb", "xns", "ftnan", "TXl", " txp", "ftns", "tempn", "ftN", "txg", "rxnet", " txns", "ctxn", "rxns", "TXns", " txl", "txtl", " txnan", "xg", "TxN", "rtns", "Txns", "ctxp", "TXnb", "txl", "rxp", "rxl", "tempnet", " txN", "ctxnet", "xN", "Txl", "txp"], "other_job": ["othererlock", "othersjob", "another_reason", "other_lock", "other_plugin", "http_job", "otherernode", "another_member", "other_message", "othererblock", "othererhome", "other_bug", "oldxaddress", " other_queue", "another_layer", "another_worker", "otherpoxsync", "anotherernode", "otherxbot", "another___reason", "another_job", "another_plugin", "old_home", "other___queue", "another_lock", " other_image", "httpingjob", "othersmember", "otheringsync", "other_cb", "another_message", "other_home", "otherxlock", " other_Job", "other_session", "anothererlock", "other_queue", "otherxjob", "otherxhome", "otherxlog", "oldxsession", "common_block", "anotherermanager", "common_layer", "oldxhome", "another_log", "othersworker", "other_bot", "other_image", "otherpoxcb", "otheringjob", "anothererblock", "httpingsync", "otherxbusiness", "anothererhome", "another___log", "other_module", "otherermanager", " other_hub", "otherpoxjob", "otheredsession", "other___reason", " other_worker", "other_business", "anothererjob", "oldxjob", "another_process", "http_runner", "other_reason", "common_job", "other___bug", "anothersbot", "anothersmember", "old_job", "otherkaddress", "another_block", " other_block", "common_business", "anothersjob", "other___block", "another_bug", "otherxlayer", "old_session", "httpingrunner", "othererbot", "other___Job", "other_member", "other_worker", "old_address", "otherkjob", "otheringcb", "other_log", "otheredjob", "other___job", "another_home", "otherxmanager", "httpingcb", "other___log", " other_plugin", "common_log", "anotherssession", "anothererbot", "common_jobs", "other_jobs", "otherksession", " other_module", "otherxaddress", "other_block", "another_node", "other_manager", "another___job", "another_manager", "other_sync", "other_hub", "another_session", "othererjob", "otherssession", "otherpoxrunner", "other_layer", "otheringrunner", "other_runner", "http_cb", "http_sync", "othersbot", "otherxsession", "otherxmember", "otheredhome", "other_address", "otheredaddress", "other_process", "otherkhome", "other_Job", "common_worker", "another_bot", "other_node", "another___bug", "othersprocess", "othersmessage"], "next": ["Next", "follow", "done", "worker", "shift", "cmp", "code", "low", "sec", "close", "seq", "new", "runner", "config", "primary", "first", "name", "step", "link", "frame", "success", "future", "data", "reply", "prev", "start", "now", "result", "state", "max", "more", "range", " Next", "size", "open", "client", "second", "later", "last"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)\n\n{\n\n    memory_region_init_io(mr, &isa_mmio_ops, NULL, \"isa-mmio\", size);\n\n}\n", "idx": 3766, "substitutes": {"mr": ["MR", "fr", "rb", "Mr", "rr", "gr", "ir", "r", "sr", "rh", "pr", "rt", "pm", "er", "RM", "rx", "usr", "dr", "adr", "m", "mi", "vm", "mm", "vr", "rm", "pc", "mt", "shr", "kr", "rs", "rg", "nr", "mn", "mx", "mc", "lr", "br"], "size": ["six", "io", "loc", "scale", "ptr", "cs", "code", "sec", "number", "name", "fee", "sn", "capacity", "len", "esc", "g", "length", "ize", "shape", "small", "args", "storage", "address", "addr", "empty", "iz", "timeout", "SIZE", "Size"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,\n\n                                  SocketAddressLegacy *localAddr,\n\n                                  SocketAddressLegacy *remoteAddr,\n\n                                  Error **errp)\n\n{\n\n    int fd;\n\n\n\n    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);\n\n    fd = socket_dgram(remoteAddr, localAddr, errp);\n\n    if (fd < 0) {\n\n        trace_qio_channel_socket_dgram_fail(ioc);\n\n        return -1;\n\n    }\n\n\n\n    trace_qio_channel_socket_dgram_complete(ioc, fd);\n\n    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3770, "substitutes": {"ioc": ["iOC", "iaog", "tiocl", "ioco", "uorp", "tioci", "ciOC", "iec", "iorp", "pioc", "iisc", "xioc", "giocl", "tioc", "ioci", "xiocl", "piorg", "gioci", "antioci", "iorg", "iaoc", "iaOC", "iiOC", "iocl", "iiorp", "cioc", " iOC", "xiOC", "piisc", "uoco", "cioci", "pioci", "piOC", "piec", "iog", "xiec", "uoc", "ciec", "iioco", "gioc", "antioc", "tiOC", "pioco", "piog", "ciocl", "piorp", "antiorg", "iioci", "iiorg", "giOC", "antiOC", "iaisc", "piocl", " iog", "iioc", "uOC", " iisc"], "localAddr": [" localChrs", "remoteAddressr", " localAdder", "remoteAddp", "localChb", "localAtter", "localIngr", "localAddp", "localErr", "localAddressest", "localAddest", "localIngri", "localIngp", "localStest", "localChri", " localChb", " localChr", "localChr", "remoteAddrs", "localAddresser", " localAddri", "localStp", "localAttr", "localChp", "localCher", "localAttp", "localAddrs", "localAttrs", "localAddressri", "localErest", "localAdder", "remoteAddest", " localAddb", "localErp", "localAddressr", "localStrs", "localAddb", "localIngb", " localAddrs", "localAddri", "remoteAddressest", "localAddressrs", "localStr", "localErrs", "remoteAddressrs", " localChp", "localChrs", "localAddressp", "remoteAddressp", " localCher", " localAddp", " localChri", "localAddressb"], "remoteAddr": ["remoteAddressb", "remoteAddressr", "RemoteAttr", "remoteErr", "remoteAddrc", "remoteAddressrc", "remoteAddp", " remoteAddressr", " remoteAddressp", "remoteIdn", "RemoteAttb", "remoteAddb", "remoteIdb", "RemoteAddrs", "remoteAddn", "remoteIdr", "remoteAddrs", "remoteAttr", "RemoteAddp", "RemoteAddb", "RemoteAttp", "remoteErrs", " remoteAddp", "remoteErp", "internalAddr", "RemoteAttrs", "remoteAddressn", "internalAddp", " remoteAddrs", "remoteIdp", " remoteAddn", "RemoteAddr", "remoteAttb", "remoteErn", "internalAddrs", " remoteAddressn", "remoteAddressrs", " remoteAddressrs", "remoteAttrs", "internalAddrc", "remoteIdrs", "remoteErrc", "remoteAddressp", "remoteAttp"], "errp": [" errps", "errorf", "errr", "iterps", "rr", " errf", "errorP", "rP", "iterp", "erP", "errps", "errfp", "errpe", "errP", "acep", "erfp", "acepc", "rf", "errpc", "erp", " errpc", " errP", "rp", "aceps", "errorfp", " errpe", "errf", "acepe", " errr", "err", "iterpe", "erf", "errorp", "iterpc", " errfp"], "fd": ["fn", "md", "vd", "bf", "dd", "FD", "feed", "dc", "fff", "wd", "diff", "fs", "die", " fid", "cf", "fc", "fi", "bd", "dl", "reader", "fp", "pd", "nd", "fin", "fl", "ff", "d", "af", "pid", "dat", "ln", "fee", "buf", "dy", "fb", "fe", "len", "df", "handler", "ld", "fm", "fen", "ffff", "rd", "xf", "dn", "sf", "xd", "fun", "du", "fa", "gd", "fed", "flow", "draft", "cb", "fx", "hd", "sd", " f", "f", "db", "da", " FD", "ds", "lf", "cd"]}}
{"project": "qemu", "commit_id": "bb3cb951ef530da7d248051347c974e4d20e6ea0", "target": 0, "func": "static void dec_bit(DisasContext *dc)\n\n{\n\n    TCGv t0, t1;\n\n    unsigned int op;\n\n    int mem_index = cpu_mmu_index(dc->env);\n\n\n\n    op = dc->ir & ((1 << 9) - 1);\n\n    switch (op) {\n\n        case 0x21:\n\n            /* src.  */\n\n            t0 = tcg_temp_new();\n\n\n\n            LOG_DIS(\"src r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);\n\n            if (dc->rd) {\n\n                t1 = tcg_temp_new();\n\n                read_carry(dc, t1);\n\n                tcg_gen_shli_tl(t1, t1, 31);\n\n\n\n                tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n                tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t1);\n\n                tcg_temp_free(t1);\n\n            }\n\n\n\n            /* Update carry.  */\n\n            write_carry(dc, t0);\n\n            tcg_temp_free(t0);\n\n            break;\n\n\n\n        case 0x1:\n\n        case 0x41:\n\n            /* srl.  */\n\n            t0 = tcg_temp_new();\n\n            LOG_DIS(\"srl r%d r%d\\n\", dc->rd, dc->ra);\n\n\n\n            /* Update carry.  */\n\n            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);\n\n            write_carry(dc, t0);\n\n            tcg_temp_free(t0);\n\n            if (dc->rd) {\n\n                if (op == 0x41)\n\n                    tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n                else\n\n                    tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n            }\n\n            break;\n\n        case 0x60:\n\n            LOG_DIS(\"ext8s r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x61:\n\n            LOG_DIS(\"ext16s r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x64:\n\n        case 0x66:\n\n        case 0x74:\n\n        case 0x76:\n\n            /* wdc.  */\n\n            LOG_DIS(\"wdc r%d\\n\", dc->ra);\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                 && mem_index == MMU_USER_IDX) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n                return;\n\n            }\n\n            break;\n\n        case 0x68:\n\n            /* wic.  */\n\n            LOG_DIS(\"wic r%d\\n\", dc->ra);\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                 && mem_index == MMU_USER_IDX) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n                return;\n\n            }\n\n            break;\n\n        case 0xe0:\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)\n\n                && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n            }\n\n            if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {\n\n                gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            }\n\n            break;\n\n        case 0x1e0:\n\n            /* swapb */\n\n            LOG_DIS(\"swapb r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x1e2:\n\n            /*swaph */\n\n            LOG_DIS(\"swaph r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16);\n\n            break;\n\n        default:\n\n            cpu_abort(dc->env, \"unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\\n\",\n\n                     dc->pc, op, dc->rd, dc->ra, dc->rb);\n\n            break;\n\n    }\n\n}\n", "idx": 3778, "substitutes": {"dc": ["cloud", "disc", "enter", "ec", "dm", "cci", "d", "head", "wp", "cgi", "qa", "central", "mc", "inc", "doc", " DC", "ku", "bc", "cd", "draw", "cc", "cr", "ac", "fc", "vc", "exec", "xc", "config", "dat", "DC", "cdn", "dest", "roc", "data", "circ", "center", "director", "ct", "lc", "cu", "jc", "cit", "sc", "device", "dir", "cca", "ic", "dr", "acc", "mic", "df", "conn", "pc", "spec", "td", "dt", "cmd", "ds", "uc", "design", "cm", "dom", "desc", "source", "cat", "cache", "mac", "loc", "cf", "rc", "input", "ga", "tc", "rec", "ea", "c", "du", "nc", "di", "db", "gui", "da"], "t0": ["it0", "T100", "l2", "l8", "at050", "temp100", "t6", "p1", "T050", "t00", "p00", "at0", "T000", "d00", "et1", "it000", "tty0", "at3", "p4", "p100", "tty000", "t4", " t4", "t8", " t3", "temp00", "temp2", "ta50", "l50", "temp1", "t100", "it1", "ta0", "T0", "T4", "T6", "p5", " t6", "temp5", "tty1", "dt192", "ta8", "d0", "t192", "dt1", "t050", "d5", "d1", "p0", " t8", " t2", "at1", "T3", "t2", "T1", "ta2", " t000", "p2", "t50", "f1", "it192", "f192", "et0", "t5", "f0", " t050", "t000", "et6", "f000", "dt0", "t3", "dt000", "temp0", " t50", "l0", "T2"], "t1": ["it0", "t01", "dt1", "ttyone", "itone", "t5", "ttone", "f0", "t4", "tty01", "Tname", "tname", " t4", "t8", "p0", " t3", "p91", "T5", "tt1", "pt0", "p1", " t2", " t8", "T01", "t91", "f4", "it91", "tt0", "dtname", " tone", "T9", "tone", "tt5", " t9", "p8", "dt0", "t3", "it1", "pt91", "t2", "tt3", "ptone", "pt1", "f2", "p9", "T0", "T1", " t5", "T4", "pone", "dt4", "tty1", "p2", "tty3", "tt01", " tname", "f1", "t9", " t01", "T2", "T8"], "op": ["mod", "cat", "loop", "offset", "lock", "cod", "open", "loc", "it", "mp", "ok", "hop", "ac", "cmp", "option", "orb", "o", "operation", "opt", "p", "Op", "ind", "opus", "pop", "id", "operator", "len", "off", "lit", "pos", "type", "prop", "sp", "expr", "top", "app", "oop", "prev", "oid", "info", "jp", "oc", "om", "opp", "ip", "set", "OP", "post", "oper", "ops", "cop", "bit", "index"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "int memory_region_get_fd(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_fd(mr->alias);\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n", "idx": 3795, "substitutes": {"mr": ["hm", "md", "MR", "tm", "rb", "Mr", "rr", "cr", "gr", "r", "sr", "rh", "pr", "rc", "rt", "er", "rx", "yr", "ref", "km", "usr", "dr", "adr", "m", "rf", "fm", "mm", "vr", "wk", "rm", "pc", "mt", "mid", "shr", "kr", "mk", "rs", "rg", "nr", "mn", "mc", "rl", "lr", "bm", "lc", "br"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,\n\n                              TCGReg r1, TCGReg r2, TCGReg rn,\n\n                              tcg_target_long ofs, bool pre, bool w)\n\n{\n\n    insn |= 1u << 31; /* ext */\n\n    insn |= pre << 24;\n\n    insn |= w << 23;\n\n\n\n    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);\n\n    insn |= (ofs & (0x7f << 3)) << (15 - 3);\n\n\n\n    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);\n\n}\n", "idx": 3811, "substitutes": {"s": ["support", "i", "fs", "r", "sets", "setup", "ns", "settings", "cs", "context", "n", "ssl", "qs", "o", "south", "p", "src", "groups", "d", "m", "ions", "sq", "session", "opens", "v", "services", "a", "ses", "secondary", "c", "scope", "sports", "t", "b", "f", "e", "tests", "span", "bis", "sync"], "insn": [" insz", "Insn", "Insb", "incign", "insp", "insns", "inl", "incz", "Insns", "incc", "INSpn", "Inspn", "inen", "Insc", "incl", "insz", "outsen", " insc", "outsc", " insns", " insb", "inpn", "Insign", "outsn", " insign", "Insner", "INSn", "inz", " insp", "outsp", " insl", "inspn", "insc", "insner", "inp", "inn", "incp", " insen", "INSner", "INSns", "insl", "incn", "incb", "outsns", "insign", "insb", "inc", "insen", "inns", "inner"], "r1": ["rOne", " r01", "sr3", "sr1", "rc1", "r01", "rcOne", " rOne", "pr01", "sr01", "r0", " r3", "r3", "rc3", " r0", "rc01", "pr3", "pr1", "pr0", "srOne", "rc0"], "r2": ["p62", "R1", "r62", "p0", "R62", "p1", "r5", "r4", "er5", "rg8", "R0", "er4", "sr2", "er2", "sr8", "r0", "rg4", "R2", " r0", "sr4", " r62", "sr5", "rg2", "p2", "rg5", "er8", "r8"], "rn": ["fn", "hn", "rb", "cr", "rr", "r", "rh", "cf", "RN", "rc", "rt", "RM", "rx", "nn", "rev", "rf", "ln", "rar", "sn", "rw", "gn", "rec", "ern", "rd", "rm", "ron", "roc", "ne", "cn", "rin", "RR", "dn", "rg", "nr", "nc", "NRS", "mn", "pn", "rl", "err", "nw", "lr", "ra", "nv"], "ofs": ["ofp", "offs", "Ofn", " ofsteps", "Ofd", "ofd", " ofd", "ifs", " ofn", " ofp", "ofn", "effc", "Ofc", "offm", "accountsup", "accountsettings", "OFsettings", "OFd", "ifp", "offp", "OFsteps", "offn", "Ofm", "ofc", "Ofs", "accounts", "effm", "ofm", " ofc", "ofsettings", "accountc", "OFn", "OFs", " ofm", "ofsup", "offd", "ofsteps", " ofsettings", "ifn", "effn", " ofsup", "OFsup", "ifm", "effs", "Ofsteps", "OFc"], "pre": ["fr", "wa", "pri", "i", "pr", "r", "po", "j", "y", "o", "p", "fp", "Pre", "up", "PRE", "pin", "m", "min", "per", "wp", "pad", "rec", "py", "pos", "prefix", "pc", "li", "ne", "pro", "sp", "ap", "pair", "prev", "jp", "pi", "pa", "ip", "post", "e", "re", "en"], "w": ["kw", "wa", "wx", "i", "sw", "r", "wave", "ww", "n", "y", "wh", "o", "p", "d", "wo", "word", "win", "z", "wp", "rw", "we", "a", "wrap", "work", "fw", "c", "prev", "W", "t", "max", "b", "q", "f", "u", "wb", "ew", "h"]}}
{"project": "qemu", "commit_id": "2e84849aa2cc7f220d3b3668f5f7e3c57bb1b590", "target": 0, "func": "static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,\n\n                                   const char *name, Error **errp)\n\n{\n\n    X86CPU *cpu = X86_CPU(obj);\n\n    const int64_t min = 0;\n\n    const int64_t max = INT_MAX;\n\n    int64_t value;\n\n\n\n    visit_type_int(v, &value, name, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n    if (value < min || value > max) {\n\n        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, \"\",\n\n                  name ? name : \"null\", value, min, max);\n\n        return;\n\n    }\n\n\n\n    cpu->env.tsc_khz = value / 1000;\n\n}\n", "idx": 3815, "substitutes": {"obj": ["host", "val", "cache", "base", "io", "po", "ex", "object", "ctx", "j", "conv", "core", "o", "p", "exec", "tmp", "act", "api", "buf", "org", "ut", "conn", "cn", "parent", "oid", "ob", "jp", "image", "cb", "boot", "Obj", "oa", "objects", "os", "env", "instance", "x", "Object"], "v": ["uv", "val", "i", "vim", "vt", "sv", "r", "l", "object", "j", "n", "conv", "o", "p", "m", "V", "api", "w", "vm", "volt", "server", "c", "vp", "vs", "t", "b", "f", "u", "e", "env", "x", "ev", "vv"], "opaque": ["opacity", "opsacity", "opsatile", "obaque", "obatile", "Opacity", "obhole", "obacity", "opatile", "opsaque", "Opatile", "Ophole", "Opaque", "ophole", "opshole"], "name": ["comment", "val", "i", "part", "base", "error", "domain", "nan", "code", "num", "n", "null", "key", "Name", "number", "new", "node", "names", "min", "id", "word", "time", "no", "label", "a", "prefix", "type", "str", "data", "description", "parent", "start", "info", "image", "max", "none", "na", "version", "space", "range", "NAME", "resource", "size", "x", "path"], "errp": [" err", "rrr", "errr", "erb", "mrpa", "rrpc", "erpt", "erP", "erc", "errP", " errpt", "errb", "ryp", "ryP", "errpc", "mrpp", " erpatch", "errpatch", " erp", "errpp", "rypa", "mrp", "erp", "rrP", "errc", " errpatch", " errc", " errpc", " errP", " erpt", " erP", "erpc", "errpt", " erb", " errr", "err", "rrpp", "errpa", "erpatch", "rrp", "rypp", "mrP", "rrc", " errb", "rrpa"], "cpu": ["clock", "val", "cache", "io", "fi", "cmp", "ctx", "core", "fp", "kernel", "mem", "node", "gp", "queue", "vm", "cp", "loader", "gpu", "conn", "pc", "lc", "GPU", "cn", "pool", "np", "pu", "cow", "process", "performance", "proc", "CPU", "instance", "net", "processor", "hw"], "value": ["media", "money", "when", "update", "val", "offset", "total", "diff", "scale", "object", "function", "num", "unit", "reference", "null", "values", "valid", "key", "number", "non", "node", "Value", "min", "id", "memory", "limit", "fee", "force", "age", "no", "property", "count", "end", "format", "prefix", "type", "data", "position", "parent", "length", "VALUE", "price", "amount", "current", "start", "now", "flow", "weight", "result", "usage", "image", "rate", "max", "feature", "version", "pa", "range", "address", "size", "message", "volume", "index"]}}
{"project": "qemu", "commit_id": "6764579f894950afe87d8ec3b323adde8925d4fd", "target": 1, "func": "static int cow_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    struct cow_header_v2 cow_header;\n\n    struct stat st;\n\n    int64_t image_sectors = 0;\n\n    char *image_filename = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n    BlockDriverState *cow_bs;\n\n\n\n    /* Read out options */\n\n    image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512;\n\n    image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n\n\n\n    ret = bdrv_create_file(filename, opts, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    cow_bs = NULL;\n\n    ret = bdrv_open(&cow_bs, filename, NULL, NULL,\n\n                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    memset(&cow_header, 0, sizeof(cow_header));\n\n    cow_header.magic = cpu_to_be32(COW_MAGIC);\n\n    cow_header.version = cpu_to_be32(COW_VERSION);\n\n    if (image_filename) {\n\n        /* Note: if no file, we put a dummy mtime */\n\n        cow_header.mtime = cpu_to_be32(0);\n\n\n\n        if (stat(image_filename, &st) != 0) {\n\n            goto mtime_fail;\n\n        }\n\n        cow_header.mtime = cpu_to_be32(st.st_mtime);\n\n    mtime_fail:\n\n        pstrcpy(cow_header.backing_file, sizeof(cow_header.backing_file),\n\n                image_filename);\n\n    }\n\n    cow_header.sectorsize = cpu_to_be32(512);\n\n    cow_header.size = cpu_to_be64(image_sectors * 512);\n\n    ret = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header));\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    /* resize to include at least all the bitmap */\n\n    ret = bdrv_truncate(cow_bs,\n\n        sizeof(cow_header) + ((image_sectors + 7) >> 3));\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\nexit:\n\n    g_free(image_filename);\n\n    bdrv_unref(cow_bs);\n\n    return ret;\n\n}\n", "idx": 3824, "substitutes": {"filename": ["fn", "nuclear", "database", "lua", "binary", "jl", "utf", "fp", "phrase", "location", "abl", "name", "figure", "Filename", "fil", "download", "slice", "til", "prefix", "file", "fd", "feat", "txt", "login", "il", "url", "dll", "files", "nil", "kl", "subject", "wav", "kn", "f", "FIL", "summary", "directory", "username", "wl", "jpg", "path", "tif"], "opts": ["expertes", "experls", "optmt", "optches", "OPcs", "experts", "optd", "optts", "otts", " optments", "operts", "opments", " optts", "ots", "OPtd", " optls", "otps", " opter", "experches", "opercs", "optls", " opmt", "opps", "expertd", " opttes", "experments", "optes", " optes", "operps", "opches", " optches", "OPts", "OPs", "otcs", " optter", "optter", "OPps", "opcs", "expers", "opttes", "opers", "optments", "opter", "opttd", "OPtes", "opls", " optmt", "ops", "opmt"], "errp": [" errps", "errr", "erps", " errf", "errorP", "irp", "errpr", "rarp", "erP", "errpe", "rarf", "rarpr", "errP", " errpr", "erp", "irpe", "errorr", "erpr", " errP", "derf", "derps", "irps", " errpe", "errf", "errorps", "rarr", " errr", "err", "irf", "derp", "erf", "errorp", "errps", "derpe"], "cow_header": ["cow_content", "cow_bridge", "cow_headers", "ow_server", "flow_header", "ow_transfer", "cow2headers", "gru_player", "ow_layer", "ow_headers", "cow___header", "cow2head", "cow_counter", "Cow_layer", "cow_main", "gru_header", "cow_director", "flow_head", "ow_cover", "cache_head", "cow_buffer", "cowbookbridge", "cowbookheaders", "Cow_header", "cow_transfer", "ow_header", "ow_version", "ow_player", "gow_cover", "cow_head", "ow_buffer", "flow_version", "cow___writer", "cow_description", "ow_bridge", "ow_filename", "cow_dr", "cache_counter", "gow_header", "cow___counter", "cow_writer", "ow_definition", "gow_detail", "flow_buffer", "cache_writer", "ow_director", "cow_player", "ow_consumer", "cow_version", "cow_consumer", "Cow_head", "Cow_headers", "cow_layer", "cache_header", "cow_detail", "flow_headers", "flow_director", "flow_content", "cow_cover", "cow_definition", "gru_main", "ow_head", "cow2layer", "cowbookheader", "cow2header", "cow_filename", "gow_description", "ow_detail", "cow___head", "cowbooktransfer", "gru_dr", "cow_server"], "st": ["fr", "ost", "art", "sw", "sth", "r", "inst", "sc", "ste", "istic", "param", "stack", "nd", "St", "put", " sc", "sta", "se", "first", "stage", "sn", "rest", "step", "store", "stop", "stream", "end", "est", "service", "str", "ST", "ast", "sp", "stress", "start", "ist", "state", "std", "sts", "ft", "set", "ss", "sl", "ct", "en", "fe"], "image_filename": ["image_url", "image__directory", "image__username", "img_processor", "media_file", "image_fn", "imageFfile", "img_username", "image___processor", " image_location", "imageFsource", "image_source", "image__file", "image_file", "image_directory", "media__file", "image_fp", "media__directory", "img__uri", "image__url", "image__uri", "large_file", "image64width", "image_width", "img__username", "image_username", "image_Filename", "imageFFilename", "media__url", " image_width", "image___uri", "image__filename", "media__filename", "large_source", "img_Filename", "large_Filename", "image_processor", "image_uri", "imageFfilename", "media_directory", "img__filename", "image___filename", "img_filename", "large_filename", "image_location", "img__processor", "img_fp", "image64Filename", "img_fn", "image__processor", "image___username", " image_Filename", "image64location", "img_uri", "media_url", "media_filename", "image64filename"], "local_err": ["local7err", "local_die", "Local_iter", "global_req", "local7gr", "Local_err", "localestdie", "local_req", "local_er", "global_err", "local_dr", "global_error", " local_gr", "Local_sr", " local_req", "local_sr", " local_die", "local_gr", "Local_ler", "localesterr", "local7sr", "local_error", "Local_gr", "localester", " local_dr", "local_ler", "local_status", "Local_status", "global_gr", "localestdr", " local_er", "local_iter", "local7iter"], "ret": ["cat", "bf", "val", "let", "rb", "res", "nm", " RET", "sr", "att", "def", "rc", "match", "rt", "flag", "j", "num", "resp", "hash", "alt", "lt", "pt", "valid", "RET", "ref", "mem", "usr", "det", "arr", "gt", "rev", "obj", "status", "red", "len", "no", "count", "lit", "end", "success", "rets", "feat", "data", "reply", "mt", "fun", "nt", "reg", "url", "result", "std", "Ret", "al", "rel", "rl", "arg", "ft", "db", "re", "pass", "en", "art"], "cow_bs": ["cow7BS", "cow7bb", "hub67BS", "cache_obj", "cow_BS", " cow7bs", "cow_fs", "cowAbs", "cow7base", "cow7fs", "cowGbs", "cowGsb", " cow_fs", "cow67base", "hub67bb", " cow_bm", "hub67bs", " cow7fs", "gow_vs", "cache_sb", "cow7bm", " cow7server", "hub_base", "cow67bs", "hub_BS", "cow67BS", "cowAserver", "cow_obj", "cowGobj", "cowAfs", "cache_fs", "cow7server", "hub67base", "gow_fs", "cow7bs", "cowAbm", " cow_server", " cow7bm", "gow_base", "cow_bb", "hub_bs", "cow67bb", "cow_vs", "cow_sb", "hub_bb", "cow_bm", "cowGfs", "gow_bs", "cow_base", "cache_bs", "cow_server"]}}
{"project": "FFmpeg", "commit_id": "4a023d5b53132ced3643d0e8397baa80cf75f656", "target": 0, "func": "static av_cold int check_format(AVCodecContext *avctx)\n\n{\n\n    AVCodecParserContext *parser;\n\n    uint8_t *pout;\n\n    int psize;\n\n    int index;\n\n    H264Context *h;\n\n    int ret = -1;\n\n\n\n    /* init parser & parse file */\n\n    parser = av_parser_init(avctx->codec->id);\n\n    if (!parser) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to open H.264 parser.\\n\");\n\n        goto final;\n\n    }\n\n    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;\n\n    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);\n\n    if (index < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to parse this file.\\n\");\n\n        goto release_parser;\n\n    }\n\n\n\n    /* check if support */\n\n    h = parser->priv_data;\n\n    switch (h->sps.bit_depth_luma) {\n\n    case 8:\n\n        if (!CHROMA444(h) && !CHROMA422(h)) {\n\n            // only this will H.264 decoder switch to hwaccel\n\n            ret = 0;\n\n            break;\n\n        }\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported file.\\n\");\n\n    }\n\n\n\nrelease_parser:\n\n    av_parser_close(parser);\n\n\n\nfinal:\n\n    return ret;\n\n}\n", "idx": 3832, "substitutes": {"avctx": ["afcontext", "avercontext", " avlc", "avconn", "avecmp", "aflc", "AVctx", "rafcmp", "avectx", "avelc", "aftx", " avsci", "rafloc", "averctrl", "Avctx", " avcontext", "avcmp", "avsci", "Avcontext", "AVlc", " avconn", "AVsci", "avesc", "aveconn", "AVconn", "afloc", "afconn", "avtx", "afcmp", "afctx", "AVctrl", "avecontext", "avlc", "avloc", "afctrl", "avsc", "aveloc", "rafcontext", "AVsc", "avctrl", "AVtx", "AVcontext", "averctx", "avcontext", "Avsci", "rafctx", "avertx", "averlc", "Avconn", " avsc"], "parser": ["kw", "xxx", "dd", "lp", "tp", "part", "manager", "r", "worker", "script", "context", "pb", "ctx", "er", "builder", "xml", "p", "fp", "pd", "fork", "ger", "root", "Parser", "arser", "paragraph", "se", "buffer", "lex", "k", "handler", "slice", "master", "v", "jack", "loader", "format", "pc", "writer", "ler", "central", "parent", "txt", "server", "argument", "spec", "c", "ar", "inner", "util", "plugin", "init", "pillar", "book", "tx", "audio", "php", "player", "magic", "au", "angler", "parse", "instance", "student", "http", "reader", "author"], "pout": ["ipouts", "pOUT", "spOut", "spOUT", "pagain", " pOut", "cpOut", "cpagain", "Pin", "cpOUT", "POut", "pOut", "spagain", "pin", "ipin", "Pouts", "cpout", "ragain", "rOUT", "Pout", "pouts", " pin", " pouts", "ipOut", "ipout", "rOut", "spout", "rout"], "psize": ["epsIZE", "psizes", "psizing", "epsizes", "alsizer", "upsIZE", "alsized", "opsized", "upsize", "alsize", "upsizing", "opsizer", "opsiz", "epsiz", "opsize", "epsized", "opsizing", "opsIZE", "upsiz", "epsizing", "epsize", "psizer", "psiz", "opsizes", "alsizes", "psIZE", "epsizer", "psized"], "index": ["field", "loop", "offset", "i", "find", "part", "scan", "value", "error", "match", "section", "array", "active", "unit", "num", "where", "pattern", "valid", "key", "number", "pin", "ind", "append", "ret", "id", "Index", "ion", "element", "len", "slice", "skip", "ini", "end", "pos", "success", "position", "list", "search", "length", "weight", "info", "result", "arg", "align", "addr", "x", "pointer", "path", "found"], "h": ["hm", "host", "rh", "r", "l", "hs", "context", "hh", "ctx", "n", "header", "sh", "o", "p", "ht", "ha", "d", "m", "w", "s", "hl", "handler", "oh", "v", "help", "uh", "conn", "ah", "g", "data", "c", "ph", "eh", "he", "hr", "bh", "ch", "ih", "hd", "t", "hp", "history", "f", "u", "q", "e", "x", "http", "hw", "H"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_move_mr(DisasContext *dc)\n\n{\n\n\tint memsize = memsize_zz(dc);\n\n\tint insn_len;\n\n\tDIS(fprintf (logfile, \"move.%c [$r%u%s, $r%u\\n\",\n\n\t\t    memsize_char(memsize),\n\n\t\t    dc->op1, dc->postinc ? \"+]\" : \"]\",\n\n\t\t    dc->op2));\n\n\n\n\tif (memsize == 4) {\n\n\t\tinsn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);\n\n\t\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\t\tcris_update_cc_op(dc, CC_OP_MOVE, 4);\n\n\t\tcris_update_cc_x(dc);\n\n\t\tcris_update_result(dc, cpu_R[dc->op2]);\n\n\t}\n\n\telse {\n\n\t\tTCGv t0;\n\n\n\n\t\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tinsn_len = dec_prep_move_m(dc, 0, memsize, t0);\n\n\t\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\t\tcris_alu(dc, CC_OP_MOVE,\n\n\t\t\t    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);\n\n\t\ttcg_temp_free(t0);\n\n\t}\n\n\tdo_postinc(dc, memsize);\n\n\treturn insn_len;\n\n}\n", "idx": 3834, "substitutes": {"dc": ["draw", "comment", "cc", "cit", "jc", "mac", "disc", "enter", "loc", "die", "sc", "cf", "ac", "device", "fc", "rc", "context", "grad", "ctx", "dir", "cca", "vc", "exec", "ec", "dm", "gc", "dr", "ct", "d", "xc", "cci", "config", "dat", "DC", "ga", "input", "design", "cdn", "tc", "df", "rec", "lc", "conn", "pc", "roc", "fd", "dest", "coll", "ea", "spec", "c", "dt", "nc", "du", "di", "mc", "oc", "std", " DC", "db", "gui", "cmd", "doc", "da", "dp", "bc", "ds", "uc", "cm", "cd", "desc"], "insn_len": ["insn_led", "insnOxval", "insnOxpre", "insl_Len", "insn2li", "insc_val", "insl2len", "insn2length", "insn_Len", "insp_len", "insc_en", "insp_Len", "insn_n", "insnOxlen", "insp_val", "insn_long", "insn2len", "insn_li", "insp_long", "insn_pre", "insp_pre", "insn2Len", "insl2length", "insl_len", "insl_length", "insc_n", "insn_en", "insn_length", "insl2Len", "insnOxlong", "insl2li", "insc_len", "insn_val", "insp_led", "insl_li"], "t0": ["tx8", "it0", "int0", "Tau", "int00", " t192", "ts192", "t8", "T18", "pt0", "ts0", "tt1", "tx0", "tt2", " t2", " t18", "tfrom", "tt0", "t00", "tt18", "pt00", "t1", "it1", "t2", "txfrom", "ptfrom", "t18", "T0", "T50", "tx00", "T1", " t1", " t50", "Tj", "ts1", "pt8", "intfrom", "it50", "tau", "T192", " tau", "ttj", "int8", "t50", " tj", "T2", "tj", "t192", "ttau"]}}
{"project": "qemu", "commit_id": "048c74c4379789d03c857cea038ec00d95b68eaf", "target": 0, "func": "static int rtc_initfn(ISADevice *dev)\n\n{\n\n    RTCState *s = DO_UPCAST(RTCState, dev, dev);\n\n    int base = 0x70;\n\n    int isairq = 8;\n\n\n\n    isa_init_irq(dev, &s->irq, isairq);\n\n\n\n    s->cmos_data[RTC_REG_A] = 0x26;\n\n    s->cmos_data[RTC_REG_B] = 0x02;\n\n    s->cmos_data[RTC_REG_C] = 0x00;\n\n    s->cmos_data[RTC_REG_D] = 0x80;\n\n\n\n    rtc_set_date_from_host(s);\n\n\n\n    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        s->coalesced_timer =\n\n            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);\n\n#endif\n\n    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);\n\n    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);\n\n\n\n    s->next_second_time =\n\n        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;\n\n    qemu_mod_timer(s->second_timer2, s->next_second_time);\n\n\n\n    register_ioport_write(base, 2, 1, cmos_ioport_write, s);\n\n    register_ioport_read(base, 2, 1, cmos_ioport_read, s);\n\n\n\n    register_savevm(\"mc146818rtc\", base, 1, rtc_save, rtc_load, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        register_savevm(\"mc146818rtc-td\", base, 1, rtc_save_td, rtc_load_td, s);\n\n#endif\n\n    qemu_register_reset(rtc_reset, s);\n\n    return 0;\n\n}\n", "idx": 3838, "substitutes": {"dev": ["gu", "driver", "mod", "serial", "dd", "die", "bug", "r", "priv", "error", "device", "def", "de", "grad", "conf", "temp", "o", "ve", "debug", "DEV", "dm", "d", "m", "cam", "w", "pub", "engine", "dim", "prom", " Dev", "mode", "v", "data", "pro", "server", "development", "Dev", "devices", "test", "info", " device", "Device", "dem", "f", "ver", "rad", "e", "ev", "dom"], "s": ["uns", "conf", "sim", "d", "an", "v", "ps", "lines", "sb", "sym", "state", "os", "f", "as", "set", "js", "params", "sv", "l", "sites", "si", "is", "o", "y", "qs", "p", "less", "ins", "details", "stats", "ses", "site", "features", "b", "sg", "u", "serv", "side", "plugins", "sync", "h", "S", "r", "settings", "hs", "cs", "changes", "ssl", "south", "new", "m", "session", "status", "w", "service", "g", "server", "spec", "ks", "es", "gs", "t", "ss", "e", "sl", "ls", "http", "ds", "request", "fs", "ms", "su", "sets", "ts", "ns", "n", "services", "a", "sys", "sie", "sf", "c", "rs", "self", "storage", "its"]}}
{"project": "qemu", "commit_id": "1f8828ef573c83365b4a87a776daf8bcef1caa21", "target": 0, "func": "static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIONet *n = opaque;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n\n        return -EINVAL;\n\n\n\n    return virtio_load(vdev, f, version_id);\n\n}\n", "idx": 3845, "substitutes": {"f": ["fn", "bf", "i", "fs", "fac", "cf", "fab", "l", "fc", "fi", "o", "fp", "p", "fo", "d", "m", "af", "tf", "elf", "fb", "df", "fen", "v", "a", "file", "fd", "sf", "c", "fa", "fx", "t", "b", "e", "F", "fe"], "opaque": ["opusonymous", "OPacity", "Opaque", "opec", "OPec", "Opace", "opace", " opace", "ompaque", "omponymous", "Opacity", "opusaques", "Opec", "OPace", " opaques", "oponymous", " opacity", " opec", "opaques", " oponymous", "ompaques", "OPaque", "opacity", "opusaque"], "version_id": ["version_d", "versioneri", " version_d", "ver_number", " version_i", "version_number", "versionali", "version_i", "ver_name", "versionernumber", "versionerversion", "version_count", " version_ids", "ver_id", "ver_i", "version_sid", "ver_version", "ver_ids", "versionalids", "versionerid", "versionalid", "version_name", "versionalsid", "version_ids", "ver_sid", "ver_count", "version_version"], "n": ["i", "ac", "ns", "l", "j", "y", "o", "p", "nn", "node", "nor", "d", "m", "name", "z", "sn", "w", "k", "an", "v", "nb", "g", "ne", "cn", "c", "nt", "nc", "rn", "pn", "network", "t", "b", "na", "u", "nw", "N", "e", "net", "s"], "vdev": ["Vdev", "Vver", "lvserv", "Vserv", "pdev", "pda", "vver", "dDev", "lvdevice", "vev", "dda", "lvdev", "Vdevice", "pDev", "lserv", " vev", "vdevice", "vDev", "lvver", "ddev", " vda", "dev", "vserv", "pev", "ldevice", "ldev", "vda", "lver", " vDev"]}}
{"project": "FFmpeg", "commit_id": "3f8148911c6e6e1f2a042bd4ca3ad8516a92130c", "target": 0, "func": "static int read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n    VideoDemuxData *s = s1->priv_data;\n\n    char filename_bytes[1024];\n\n    char *filename = filename_bytes;\n\n    int i;\n\n    int size[3]={0}, ret[3]={0};\n\n    AVIOContext *f[3] = {NULL};\n\n    AVCodecContext *codec= s1->streams[0]->codec;\n\n\n\n    if (!s->is_pipe) {\n\n        /* loop over input */\n\n        if (s->loop && s->img_number > s->img_last) {\n\n            s->img_number = s->img_first;\n\n        }\n\n        if (s->img_number > s->img_last)\n\n            return AVERROR_EOF;\n\n        if (s->use_glob) {\n\n#if HAVE_GLOB\n\n            filename = s->globstate.gl_pathv[s->img_number];\n\n#endif\n\n        } else {\n\n        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),\n\n                                  s->path, s->img_number)<0 && s->img_number > 1)\n\n            return AVERROR(EIO);\n\n        }\n\n        for(i=0; i<3; i++){\n\n            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,\n\n                           &s1->interrupt_callback, NULL) < 0) {\n\n                if(i>=1)\n\n                    break;\n\n                av_log(s1, AV_LOG_ERROR, \"Could not open file : %s\\n\",filename);\n\n                return AVERROR(EIO);\n\n            }\n\n            size[i]= avio_size(f[i]);\n\n\n\n            if(!s->split_planes)\n\n                break;\n\n            filename[ strlen(filename) - 1 ]= 'U' + i;\n\n        }\n\n\n\n        if(codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)\n\n            infer_size(&codec->width, &codec->height, size[0]);\n\n    } else {\n\n        f[0] = s1->pb;\n\n        if (url_feof(f[0]))\n\n            return AVERROR(EIO);\n\n        size[0]= 4096;\n\n    }\n\n\n\n    av_new_packet(pkt, size[0] + size[1] + size[2]);\n\n    pkt->stream_index = 0;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n\n    pkt->size= 0;\n\n    for(i=0; i<3; i++){\n\n        if(f[i]){\n\n            ret[i]= avio_read(f[i], pkt->data + pkt->size, size[i]);\n\n            if (!s->is_pipe)\n\n                avio_close(f[i]);\n\n            if(ret[i]>0)\n\n                pkt->size += ret[i];\n\n        }\n\n    }\n\n\n\n    if (ret[0] <= 0 || ret[1]<0 || ret[2]<0) {\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO); /* signal EOF */\n\n    } else {\n\n        s->img_count++;\n\n        s->img_number++;\n\n        return 0;\n\n    }\n\n}\n", "idx": 3901, "substitutes": {"s1": ["sys2", "ds11", "c1", "sons", "dsOne", "l1", " sons", " s0", "sesone", "hs1", "sys6", "c3", "l81", "c6", "sys3", "cs1", "S81", "csons", "wsOne", "sOne", "ses11", "ses1", "ds81", "s81", "ws11", "s6", "wsons", "S1", "ds1", "s11", "ses81", "hs11", "SOne", "Sone", " s11", " sOne", "sys1", "hs81", "sone", "g3", "ws1", "l0", "s3", " sone", "g2", "ses0", "g1", "c2", "s0", "g6", "csOne", "dsone", "s2", " s81", "wsone"], "pkt": ["ppacket", "pkg", "Pkg", "cpmt", "ppKT", " pmt", "apmt", "apkk", "apkt", "Pkt", "PKT", " pkk", "packet", "cpacket", "Packet", "pmt", "apacket", " packet", "ppkg", "pkk", "cpkt", "ppkt", "pKT", " pkg", " pKT", "cpkk"], "s": ["conf", "sec", "d", "sa", "v", "states", "ps", "sb", "sym", "parts", "os", "as", "js", "comments", "sv", "l", "si", "is", "o", "qs", "y", "p", "ins", "stats", "data", "ses", "site", "args", "b", "sg", "u", "plugins", "sync", "h", "S", "r", "sc", "comm", "settings", "cs", "ctx", "ssl", "m", "sq", "session", "w", "full", "service", "g", "us", "server", "ks", "spec", "es", "gs", "t", "aws", "ss", "e", "ls", "http", "ds", "xs", "fs", "ms", "sets", "ts", "ns", "n", "ims", "a", "services", "sys", "c", "rs", "self", "vs", "its"], "filename_bytes": ["filename_frames", "filename_requires", "filename2lines", " filename_frames", "username_details", "filename2zip", "filename_details", "filename_bits", "image_seconds", "filename_zip", "username_lines", "filename_lines", "message_bytes", "message_seconds", "message_bits", "message_requires", "username_zip", "username_bytes", "filename_seconds", "filename2details", " filename_lines", "filename2bytes", "image_bytes", "filename_parts", "image_parts"], "filename": ["fn", "bf", "ename", "wx", "nm", "sword", "SIZE", "binary", "uri", "utf", "fp", "phrase", "location", "src", "which", "metadata", "name", "word", "buffer", "Filename", "fil", "status", "memory", "source", "download", "slice", "prefix", "file", "feat", "fd", "data", "gz", "txt", "path", "length", "il", "output", "sf", "url", "whatever", "dll", "files", "original", "nil", "image", "kl", "kn", "subject", "sheet", "json", "directory", "username", "final", "message", "png", "password", "jpg"], "i": ["hi", "chi", "ui", "diff", "part", "io", "l", "fi", "sup", "si", "j", "uri", "n", "y", "p", "ci", "multi", "qi", "ind", "eni", "d", "split", "m", "oi", "module", "id", "mi", "I", "z", "ri", "ini", "ii", "slice", "count", "v", "bi", "mini", "type", "li", "g", "iu", "ie", "c", "zi", "di", "start", "ai", "ix", "init", "abi", "ch", "vi", "pi", "mu", "ski", "gi", "b", "u", "ti", "ip", "ni", "e", "xi", "x", "inner", "phi", "yi", "lc", "index"], "size": ["enc", "sec", "z", "send", "sum", "sn", "len", "v", "parent", "ize", "rate", "large", "max", "message", "sized", "Size", "ui", "l", "si", "from", "y", "security", "fl", "se", "name", "fee", "time", "mode", "data", "url", "speed", "sex", "args", " sizes", "SIZE", "offset", "en", "code", "core", "new", "status", "w", "capacity", "g", "member", "length", "shape", "es", "address", "e", "empty", "use", "source", "desc", "loc", "scale", "form", "j", "n", "esc", "type", "file", "c", "body", "export", "small", "storage", "x", "content"], "ret": ["value", "back", "loc", "en", "rc", "code", "num", "temp", "fo", "buffer", "status", "sum", "memory", "mode", "full", "esc", "g", "body", "info", "result", "get", "small", "response", "ft", "out", "empty", "content", "desc"], "f": ["fn", "fr", "feed", "fs", "r", "cf", "form", "l", "fc", "j", "fp", "p", "fl", "d", "m", "tf", "z", "rf", "w", "fb", "fen", "df", "v", "frame", "fd", "file", "g", "sf", "fw", "c", "fun", "fa", "fx", "t", "q", "b", "e", "x", "F", "fe", "h"], "codec": ["Coduc", " coderc", " codef", "labect", "odef", "oderc", "Coderc", "Coddec", "Codic", "labesc", "coduc", "codeEC", "callerer", "labEC", "codeesc", "labec", "callEC", "odeca", "predec", "calleca", "inderc", "buffec", "Codesc", "indef", "buffEC", "odEC", "codEC", "labdec", "bufferer", "coddec", "buffeca", "codeic", "oderer", " coduc", "codesc", "indEC", "codenc", "coderc", "codeec", "prederc", "codef", "codedec", "Codect", "Codef", "odenc", "predenc", "odec", "coderer", "indec", "codect", " codesc", " codenc", "CodEC", "codeect", "callec", "codic", "Codec", " codEC", "predesc", "oduc", "codeca", "odesc", "labic"], "img_number": ["image_umber", "imgIdobject", "img_first", "imgIdcounter", "img_page", "image_number", "imgIdnom", "imgqnumber", "image_final", "image_line", "image_counter", "img_type", "image_object", "image_first", "image_num", "imgqcounter", "imgIdnumber", "img_position", "imgPline", "image_nom", "imgitymaximum", "imgityfirst", "image_no", "imgnfirst", "img_nom", "imgqnom", "image_type", "imgIdno", "img__number", "img_umber", "imgitynumber", "imgnnumber", "img_final", "image_maximum", "imgPno", "image_position", "imgPposition", "img_counter", "img_no", "imgPnumber", "img__line", "img_num", "img_maximum", "imgitynum", "img_object", "imgIdumber", "image_page", "img_line", "imgnmaximum", "imgnnum", "imgqno", "img__position", "img__no"]}}
{"project": "FFmpeg", "commit_id": "7ed47e97297fd5ef473d0cc93f0455adbadaac83", "target": 1, "func": "static int smacker_read_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    SmackerContext *smk = s->priv_data;\n    AVStream *st, *ast[7];\n    int i, ret;\n    int tbase;\n    /* read and check header */\n    smk->magic = avio_rl32(pb);\n    if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4'))\n    smk->width = avio_rl32(pb);\n    smk->height = avio_rl32(pb);\n    smk->frames = avio_rl32(pb);\n    smk->pts_inc = (int32_t)avio_rl32(pb);\n    smk->flags = avio_rl32(pb);\n    if(smk->flags & SMACKER_FLAG_RING_FRAME)\n        smk->frames++;\n    for(i = 0; i < 7; i++)\n        smk->audio[i] = avio_rl32(pb);\n    smk->treesize = avio_rl32(pb);\n    if(smk->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant)\n        av_log(s, AV_LOG_ERROR, \"treesize too large\\n\");\n//FIXME remove extradata \"rebuilding\"\n    smk->mmap_size = avio_rl32(pb);\n    smk->mclr_size = avio_rl32(pb);\n    smk->full_size = avio_rl32(pb);\n    smk->type_size = avio_rl32(pb);\n    for(i = 0; i < 7; i++) {\n        smk->rates[i]  = avio_rl24(pb);\n        smk->aflags[i] = avio_r8(pb);\n    smk->pad = avio_rl32(pb);\n    /* setup data */\n    if(smk->frames > 0xFFFFFF) {\n        av_log(s, AV_LOG_ERROR, \"Too many frames: %\"PRIu32\"\\n\", smk->frames);\n    smk->frm_size = av_malloc_array(smk->frames, sizeof(*smk->frm_size));\n    smk->frm_flags = av_malloc(smk->frames);\n    if (!smk->frm_size || !smk->frm_flags) {\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(ENOMEM);\n    smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2'));\n    /* read frame info */\n    for(i = 0; i < smk->frames; i++) {\n        smk->frm_size[i] = avio_rl32(pb);\n    for(i = 0; i < smk->frames; i++) {\n        smk->frm_flags[i] = avio_r8(pb);\n    /* init video codec */\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    smk->videoindex = st->index;\n    st->codec->width = smk->width;\n    st->codec->height = smk->height;\n    st->codec->pix_fmt = AV_PIX_FMT_PAL8;\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codec->codec_id = AV_CODEC_ID_SMACKVIDEO;\n    st->codec->codec_tag = smk->magic;\n    /* Smacker uses 100000 as internal timebase */\n    if(smk->pts_inc < 0)\n        smk->pts_inc = -smk->pts_inc;\n    else\n        smk->pts_inc *= 100;\n    tbase = 100000;\n    av_reduce(&tbase, &smk->pts_inc, tbase, smk->pts_inc, (1UL<<31)-1);\n    avpriv_set_pts_info(st, 33, smk->pts_inc, tbase);\n    st->duration = smk->frames;\n    /* handle possible audio streams */\n    for(i = 0; i < 7; i++) {\n        smk->indexes[i] = -1;\n        if (smk->rates[i]) {\n            ast[i] = avformat_new_stream(s, NULL);\n            if (!ast[i])\n                return AVERROR(ENOMEM);\n            smk->indexes[i] = ast[i]->index;\n            ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n            if (smk->aflags[i] & SMK_AUD_BINKAUD) {\n                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT;\n            } else if (smk->aflags[i] & SMK_AUD_USEDCT) {\n                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT;\n            } else if (smk->aflags[i] & SMK_AUD_PACKED){\n                ast[i]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO;\n                ast[i]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A');\n            } else {\n                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_U8;\n            if (smk->aflags[i] & SMK_AUD_STEREO) {\n                ast[i]->codec->channels       = 2;\n                ast[i]->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n            } else {\n                ast[i]->codec->channels       = 1;\n                ast[i]->codec->channel_layout = AV_CH_LAYOUT_MONO;\n            ast[i]->codec->sample_rate = smk->rates[i];\n            ast[i]->codec->bits_per_coded_sample = (smk->aflags[i] & SMK_AUD_16BITS) ? 16 : 8;\n            if(ast[i]->codec->bits_per_coded_sample == 16 && ast[i]->codec->codec_id == AV_CODEC_ID_PCM_U8)\n                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_S16LE;\n            avpriv_set_pts_info(ast[i], 64, 1, ast[i]->codec->sample_rate\n                    * ast[i]->codec->channels * ast[i]->codec->bits_per_coded_sample / 8);\n    /* load trees to extradata, they will be unpacked by decoder */\n    if(ff_alloc_extradata(st->codec, smk->treesize + 16)){\n        av_log(s, AV_LOG_ERROR,\n               \"Cannot allocate %\"PRIu32\" bytes of extradata\\n\",\n               smk->treesize + 16);\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(ENOMEM);\n    ret = avio_read(pb, st->codec->extradata + 16, st->codec->extradata_size - 16);\n    if(ret != st->codec->extradata_size - 16){\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(EIO);\n    ((int32_t*)st->codec->extradata)[0] = av_le2ne32(smk->mmap_size);\n    ((int32_t*)st->codec->extradata)[1] = av_le2ne32(smk->mclr_size);\n    ((int32_t*)st->codec->extradata)[2] = av_le2ne32(smk->full_size);\n    ((int32_t*)st->codec->extradata)[3] = av_le2ne32(smk->type_size);\n    smk->curstream = -1;\n    smk->nextpos = avio_tell(pb);\n    return 0;", "idx": 3913, "substitutes": {"s": ["sam", "S", "support", "comments", "sv", "su", "sc", "r", "ts", "ns", "plugins", "cs", "si", "types", "n", "conf", "ssl", "qs", "o", "south", "p", "m", "sq", "session", "w", "sa", "sis", "an", "v", "services", "sys", "service", "g", "us", "ses", "sf", "spec", "c", "sb", "ks", "site", "parser", "gs", "sym", "t", "b", "f", "sg", "storage", "u", "summary", "ss", "js", "e", "sl", "ls", "ds", "sync", "request"], "pb": ["bf", "rb", "lp", "tp", "pkg", "phys", "mp", "bp", "fc", "cpp", "prot", "ctx", "pm", "xb", "pl", "fp", "p", "pd", "bps", "phrase", "ab", "typ", "api", "wp", "buf", "fb", "ppa", "tc", "abc", "platform", "esi", "cp", "pc", "prop", "eb", "rpm", "uf", "hub", "sf", "sb", "gb", "asm", "bh", "parser", "vp", "plugin", "jp", "cb", "proc", "db", "b", "lab", "pa", "dp", "summary", "apy", "wb", "rob", "bc", "lb", "lc", "PB", "pg"], "smk": ["smek", "smkt", "smdk", "symke", "irmke", "irmok", "tmsk", "smK", "spekg", "symwork", "mmc", "sykg", " smwork", " smek", " smke", "simk", "slke", "speek", "Smch", "sld", "slkg", "slq", "tmc", "symak", "spework", "symg", "speg", " smkt", "symc", "mmK", " smf", "tmck", "svke", "skwork", "tmok", "Smok", "speck", "simck", "ymke", "smku", "snke", "ymok", "speak", "omwork", "svc", "tmq", " smkg", "smsk", "tmg", "smak", "smg", "slsk", "swk", "smc", " smg", "symq", " smok", "svek", "syk", "lammsk", "simdk", "omsk", "bmck", "spek", "tmku", "slck", "tmdk", "ymkt", "emok", "slc", "sksk", "mmk", " smc", "smv", "lammk", "mbke", "spesk", "speok", "bmsk", "smf", "mmek", "simf", "smik", "swke", "mbq", "snck", "SmK", "symck", "lammd", " smik", "mbkit", "mmok", "snek", "smkin", "mbk", "skk", "smck", " smv", "slkit", "mmg", "symsk", "tmke", "svku", "svk", " smak", "irmK", "svok", "mmke", "symkit", "Smck", " smd", "Smk", "smch", "mmku", " smq", "svsk", "mmkt", " smch", "smkit", "mmck", " smK", " smdk", "svck", "slg", "emk", "ymik", "tmk", "sped", "smq", "syc", "syd", "slok", "ymck", "smke", "emK", "slk", "slik", "bmg", "smwork", "snk", "skkin", "mmdk", "bmk", "swck", "omk", "swv", "spekin", "ymk", "mmch", "smkg", "mmkg", "spedk", "mmsk", "emke", "slv", "tmik", "symku", "lammek", "mmik", "symk", "ymsk", " smck", "ymK", " smsk", "smd", "mmf", "symdk", "svdk", "smok", "omkin", "irmk", "symok"], "st": ["ost", "sw", "cr", "sth", "inst", "ste", "sc", "ts", "sh", "src", "St", "sta", "sn", "rest", "sa", "ld", "rd", "str", "ST", "sp", "sb", "ist", "std", "sts", "ss", "sl", "bl", "ct"], "ast": ["ost", "sth", "inst", "sc", "ac", "ts", "ess", "at", "ab", "node", "ream", "sta", "obj", "rest", "sa", "am", "est", "asts", "port", "pp", "asm", "AST", "std", "amp", "au", "post", "emb", "path"], "i": ["hi", "phi", "chi", "udi", "ui", "l", "fi", "si", "is", "j", "n", "uri", "y", "o", "p", "ci", "key", "multi", "qi", "ind", "eni", "d", "m", "id", "mi", "I", "z", "ori", "ri", "adi", "ini", "ii", "slice", "v", "bi", "uli", "li", "iu", "ie", "ji", "c", "in", "zi", "inner", "start", "ix", "ai", "info", "di", "init", "image", "abi", "pi", "t", "gi", "f", "b", "u", "ti", "ip", "ni", "e", "xi", "x", "it", "ki", "h", "my", "index"], "ret": ["val", "res", "back", "en", "rc", "tr", "rt", "resp", "alt", "tmp", "ref", "RET", "rev", "obj", "buffer", "row", "rs", "nt", "ru", "result", "std", "Ret", "aux", "re", "seq"], "tbase": ["dseq", "outseq", "tBase", "dbase", "outbase", "outbuffer", "mbuffer", "dBase", "mbase", "mseq", "tbuffer", "tseq", "mBase", "outBase", "dbuffer"], "frames": ["flows", "times", "cells", "flags", "ports", "videos", "weights", "pages", "fps", "cycles", "seconds", "faces", "scenes", "caps", "values", "events", "bits", "ones", "groups", "images", "rows", "blocks", "codes", "frame", "quarters", "shots", "tones", "lines", "steps", "Frames", "vals", "hops", "tracks", "files", "views", "games", "plays", "features", "parts", "rules", "links", "planes", "headers", "runs", "points", "bytes", "versions", "fram", "bands"]}}
{"project": "qemu", "commit_id": "9f1963b3f72521f75a549f8afd61b19e7da63c6f", "target": 0, "func": "static int coroutine_fn raw_co_discard(BlockDriverState *bs,\n\n                                       int64_t sector_num, int nb_sectors)\n\n{\n\n    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);\n\n}\n", "idx": 3920, "substitutes": {"bs": ["bf", "fs", "las", "base", "BS", "ns", "bid", "cs", "pb", "fps", "bb", "bes", "bits", "ubs", "als", "obj", "blocks", "lbs", "bos", "fb", "ba", "bus", "bi", "ps", "ses", "ks", "iss", "sb", "rs", "obs", "gb", "bh", "outs", "gs", "bytes", "vs", "b", "os", "ss", "bas", "ls", "bis", "bc", "lb", "ds", "bl"], "sector_num": ["sector_min", "sector_name", "sector_number", " sector_number", " sector_name", "sector_nom", " sector_min", " sector_nom"], "nb_sectors": ["nb_nesections", "nb_secors", "nb_sections", "nb_sefs", "nb_secgments", "nb_segments", "nb_negments", "nb_sergments", "nb_nefs", "nb_sersections", "nb_secctions", "nb_nectors", "nb_vegments", "nb_veors", "nb_vefs", "nb_vesections", "nb_secctors", "nb_serctors", "nb_vectors", "nb_cectors", "nb_vections", "nb_serfs", "nb_cegments", "nb_cections", "nb_seors", "nb_ceors", "nb_sesections"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,\n\n        BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);\n\n\n\n    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,\n\n                                 BDRV_REQ_ZERO_WRITE | flags,\n\n                                 cb, opaque, true);\n\n}\n", "idx": 3924, "substitutes": {"bs": ["banks", "fs", "las", "base", "BS", "ns", "bid", "plugins", "cs", "pb", "fps", "bes", "bps", "src", "ins", "obj", "blocks", "lbs", "bos", "fb", "css", "ps", "ses", "sb", "iss", "obs", "ob", "gs", "vs", "db", "b", "os", "as", "bas", "js", "ls", "bis", "bc", "ds"], "sector_num": ["sector_count", "sector_name", "sector_number", " sector_number", " sector_note", " sector_count", "sector_note", " sector_name", "sector_nb", " sector_nb"], "nb_sectors": ["nb_seriers", "nb_sections", "nb_segments", "nb_veivers", "nb_sergments", "nb_sesonents", "nb_spegments", "nb_seivers", "nb_pectors", "nb_serctions", "nb_speivers", "nb_speriers", "nb_peonents", "nb_veriers", "nb_spesector", "nb_peors", "nb_vegments", "nb_veors", "nb_sesors", "nb_seonents", "nb_sersector", "nb_psegments", "nb_spectors", "nb_veonents", "nb_spections", "nb_pseivers", "nb_serctors", "nb_vectors", "nb_psectors", "nb_pegments", "nb_vections", "nb_sesector", "nb_seors", "nb_vesector", "nb_pseriers", "nb_sesctors", "nb_sesgments"], "flags": ["mask", "ags", "offset", "FLAG", "fs", "lag", "fts", "settings", "fi", "fps", "types", "flag", "faces", "cs", "utf", "forces", "bits", "factor", "bps", "fl", "ips", "fields", "ints", "status", "fee", "count", "stats", "type", "feat", "data", "callback", "sf", "fun", "vals", "ants", "info", "bytes", "files", "nil", "options", "lf", "args", "nl", "vs", "features", "Flags", "utils", "ops", "bit", "fg", "fe", " Flags"], "cb": ["fn", "bf", "cod", "rb", "cc", "dc", "buff", "cf", "fc", "cs", "pb", "orb", "ctx", "bb", "cca", "fp", "ec", "gc", "obb", "buf", "cgi", "fb", "unc", "cv", "cp", "func", "pc", "eb", "callback", "fun", "c", "ctrl", "ob", "db", "b", "cmd", "bc", "cd", "CB"], "opaque": ["hopque", "opac", "Opque", " opac", "opsec", "operque", "Opaque", "opec", "opace", " opace", "opque", " opque", "hopace", "compacity", "Opacity", "Opec", "compace", "operacity", "opsacity", " opacity", "compaque", "opacity", "hopaque", "opsque", "hopacity", "compque", "operec", "Opac", "opsaque", "operac", "operaque"]}}
{"project": "qemu", "commit_id": "25db9ebe15125deb32958c6df74996f745edf1f9", "target": 0, "func": "static void virtio_pci_reset(DeviceState *d)\n\n{\n\n    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);\n\n    virtio_reset(proxy->vdev);\n\n    msix_reset(&proxy->pci_dev);\n\n    proxy->flags = 0;\n\n}\n", "idx": 3926, "substitutes": {"d": ["driver", "md", "dd", "dc", "device", "l", "bd", "o", "p", "dm", "m", "z", "ad", "a", "D", "fd", "g", "data", "c", "devices", "dt", "gd", "dh", "state", "dict", "sd", "db", "dev", "f", "b", "dp", "da", "e", "ds", "s"], "proxy": ["driver", "cache", "socket", "io", "clone", "container", "device", "copy", "docker", "linux", "null", "core", "super", "lib", "p", "ref", "connection", "alias", "pipe", "root", "config", "wrapper", "pid", "gp", "Proxy", "slice", "v", "roxy", "cop", "service", "pc", "parent", "server", "port", "pool", "shadow", "library", "web", "plugin", "image", "pse", "bin", "native", "f", "pa", "ip", "address", "component", "slave", "child", "instance", "http", "client", "pointer", "sync", "index"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,\n\n                            TCGReg dst, TCGReg lhs, TCGArg rhs,\n\n                            bool rhs_is_const)\n\n{\n\n    /* Emit either the reg,imm or reg,reg form of a data-processing insn.\n\n     * rhs must satisfy the \"rIK\" constraint.\n\n     */\n\n    if (rhs_is_const) {\n\n        int rot = encode_imm(rhs);\n\n        if (rot < 0) {\n\n            rhs = ~rhs;\n\n            rot = encode_imm(rhs);\n\n            assert(rot >= 0);\n\n            opc = opinv;\n\n        }\n\n        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));\n\n    } else {\n\n        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n", "idx": 3933, "substitutes": {"s": ["i", "cases", "com", "comments", "sets", "ns", "settings", "cs", "context", "ctx", "is", "n", "sec", "ssl", "o", "si", "p", "complex", "d", "cli", "sq", "session", "ions", "m", "se", "w", "services", "a", "states", "service", "g", "ses", "sf", "c", "sb", "scope", "t", "b", "f", "u", "e", "bis", "ops", "ds", "sync", "h"], "cond": ["fact", "six", "com", "loc", "def", "fc", "cmp", "ex", "context", "code", "ctx", "sec", "resp", "l", "close", "p", "exec", "ref", "imm", "ind", "xc", "ct", "config", "rupt", "con", "x", "fd", "coll", "parent", "ps", "c", "reg", "comp", "pre", "nc", "local", "crit", "b", "f", "cl", "Cond", "e", "condition", "lc", "cont"], "opc": ["opcu", "OPc", "ipci", "copcs", "iopc", "Opf", "opca", "iopf", "iopcu", " opcs", "OPf", "ipcu", "OPct", "opf", "ipca", "opct", "copc", "Opcs", "copct", " opci", "Opc", " opcu", "ipcs", "ipct", "iopca", "opcs", "Opct", "opci", " opf", "ipf", " opct", " opca", "OPci", "copf", "copci", "ipc"], "opinv": ["optv", "optInv", "ipInv", "hopconv", "opcit", "opv", " opv", "hopinv", "optinv", "ipv", "oppcit", " opcit", "oppinv", " opInv", "ipinv", "opconv", "hopcit", "opInv", "optc", " opconv", "oppconv", "ipc"], "dst": ["ldost", " dost", "dost", "Dsts", "Dste", "dste", "madsts", "madst", " dbe", " dsc", "Dst", "dsts", "dsc", "ydsp", "madbe", "sdsc", "drd", "sdhs", "ldst", " dsts", "Dsc", "brd", "ldbe", "dbe", " dhs", "dhs", "Dsp", "Drd", "ydst", "ldsts", "ydste", "madost", "sdst", "Dhs", "dsp", "sdsts", "bst", "bste", "ydrd", "bsp"], "lhs": ["lrrs", "dlhs", " lht", "klHS", "rh", "rhus", "lh", "Lhea", "klhus", "lHS", " lHS", "rht", " lh", "lrhs", "Lrs", "LHS", "lrhea", "Lhs", "rHS", "dlobs", "lhea", "klhs", "klrs", "klhea", "lht", "lhus", "dlh", "lrHS", "robs", "dlht", "klh", " lhus", "lobs", "lrs", " lobs"], "rhs": ["srhi", "yrh", "rva", "rhess", "prhl", " rHS", "nrho", "RHS", " rva", "rh", " rgh", "Rhl", "Rhh", "prhh", "lh", "rrHS", "lho", "srhs", " rhess", "pHS", "lhi", " rhh", " rhl", "yrHS", "Rh", "prh", "rhes", "lHS", "nrgh", "nrht", "rht", "Rho", "rgh", "lhess", "rhl", "Rhs", "rrva", "srHS", "rHS", " rht", "yrhess", "nrhs", " rhes", "Rht", "rrhs", "rrh", "phs", " rho", "ph", "lhes", "rho", "prhs", "srh", "Rgh", " rhi", "Rhes", "pva", "yrhs", "rhi", "rhh", " rh"], "rhs_is_const": ["rhs_is_con", "rhs_as_const", "rhs_antilesscond", "rhs_isaylinear", "rhs_as_con", "rhs_is_cond", "rhs_isamconst", "rhs_antilessunsigned", "rhs_anti_const", "rhs_isamunsigned", "rhs_islessconst", "rhs_isaycond", "rhs_islesslinear", "rhs_as_int", "rhs_antilessconst", "rhs_islessunsigned", "rhs_as_struct", "rhs_is_linear", "rhs_is_int", "rhs_antilesslinear", "rhs_isamlinear", "rhs_islesscond", "rhs_anti_linear", "rhs_is_unsigned", "rhs_isamcond", "rhs_is_struct", "rhs_isayunsigned", "rhs_isayconst", "rhs_anti_cond", "rhs_anti_unsigned"]}}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static int twl92230_init(i2c_slave *i2c)\n\n{\n\n    MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);\n\n\n\n    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);\n\n    /* Three output pins plus one interrupt pin.  */\n\n    qdev_init_gpio_out(&i2c->qdev, s->out, 4);\n\n    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);\n\n    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];\n\n\n\n    menelaus_reset(&s->i2c);\n\n\n\n    return 0;\n\n}\n", "idx": 3946, "substitutes": {"i2c": ["ui2cy", " i2dc", " i4e", "I2lc", " i4dc", " i2xc", " i3xc", "i4e", "ioucs", "i2u", "iorecu", "i5dc", "i10e", "i1dc", "iouc", "ioree", "i182f", "ialtxc", "i3cs", "ialtcs", "I2cu", "i2cy", "e10c", "iorec", "ui3f", "i3f", " i3c", "i182e", "i4c", "i10u", "e10u", "i1f", "i3xc", "i5e", "iorelc", "i2cs", "i3e", "i2e", "ialtcit", "i1ci", "e2c", "e2u", "i92u", " i3cs", "i2dc", "i3c", "ioucit", "i1u", "ui2e", "i2cu", " i2cs", "ui2c", " i2cit", "i2ci", "i2cit", "i182cy", "ui3c", "iouxc", "ui2f", " i4c", "i5ci", "i2xc", "i182c", "e2e", "i4ci", "I2c", "ui3cy", "e10e", " i4ci", "i2f", "i1c", "i1cu", " i3cit", " i2e", "i92e", "i10c", "ialtc", "i3cit", "i92c", "i1cy", "i3cy", " i2ci", "I2e", "i1lc", "ui3e", "i5c", "i2lc", "i1e", "i4dc"], "s": ["S", "i", "fs", "r", "sets", "su", "ts", "ns", "settings", "l", "cs", "is", "si", "seconds", "n", "conf", "ssl", "o", "y", "south", "p", "uns", "d", "m", "sq", "session", "z", "w", "k", "v", "services", "sys", "states", "service", "g", "us", "server", "ses", "spec", "c", "rs", "in", "sb", "self", "es", "gs", "sym", "sites", "state", "args", "t", "b", "f", "os", "u", "sg", "set", "ss", "js", "e", "sl", "ls", "ds", "sync"]}}
{"project": "FFmpeg", "commit_id": "e8c4df40e399fc87c6167c5557c11e0d904ca720", "target": 1, "func": "static int mov_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    MOVContext *mov = s->priv_data;\n\n    ByteIOContext *pb = s->pb;\n\n    MOVTrack *trk = &mov->tracks[pkt->stream_index];\n\n    AVCodecContext *enc = trk->enc;\n\n    unsigned int samplesInChunk = 0;\n\n    int size= pkt->size;\n\n\n\n    if (url_is_streamed(s->pb)) return 0; /* Can't handle that */\n\n    if (!size) return 0; /* Discard 0 sized packets */\n\n\n\n    if (enc->codec_id == CODEC_ID_AMR_NB) {\n\n        /* We must find out how many AMR blocks there are in one packet */\n\n        static uint16_t packed_size[16] =\n\n            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 0};\n\n        int len = 0;\n\n\n\n        while (len < size && samplesInChunk < 100) {\n\n            len += packed_size[(pkt->data[len] >> 3) & 0x0F];\n\n            samplesInChunk++;\n\n        }\n\n        if(samplesInChunk > 1){\n\n            av_log(s, AV_LOG_ERROR, \"fatal error, input is not a single packet, implement a AVParser for it\\n\");\n\n            return -1;\n\n        }\n\n    } else if (trk->sampleSize)\n\n        samplesInChunk = size/trk->sampleSize;\n\n    else\n\n        samplesInChunk = 1;\n\n\n\n    /* copy extradata if it exists */\n\n    if (trk->vosLen == 0 && enc->extradata_size > 0) {\n\n        trk->vosLen = enc->extradata_size;\n\n        trk->vosData = av_malloc(trk->vosLen);\n\n        memcpy(trk->vosData, enc->extradata, trk->vosLen);\n\n    }\n\n\n\n    if (enc->codec_id == CODEC_ID_H264 && trk->vosLen > 0 && *(uint8_t *)trk->vosData != 1) {\n\n        /* from x264 or from bytestream h264 */\n\n        /* nal reformating needed */\n\n        int ret = ff_avc_parse_nal_units(pkt->data, &pkt->data, &pkt->size);\n\n        if (ret < 0)\n\n            return ret;\n\n        assert(pkt->size);\n\n        size = pkt->size;\n\n    } else if (enc->codec_id == CODEC_ID_DNXHD && !trk->vosLen) {\n\n        /* copy frame to create needed atoms */\n\n        trk->vosLen = size;\n\n        trk->vosData = av_malloc(size);\n\n\n\n        memcpy(trk->vosData, pkt->data, size);\n\n    }\n\n\n\n    if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) {\n\n        trk->cluster = av_realloc(trk->cluster, (trk->entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk->cluster));\n\n        if (!trk->cluster)\n\n            return -1;\n\n    }\n\n\n\n    trk->cluster[trk->entry].pos = url_ftell(pb);\n\n    trk->cluster[trk->entry].samplesInChunk = samplesInChunk;\n\n    trk->cluster[trk->entry].size = size;\n\n    trk->cluster[trk->entry].entries = samplesInChunk;\n\n    trk->cluster[trk->entry].dts = pkt->dts;\n\n    trk->trackDuration = pkt->dts - trk->cluster[0].dts + pkt->duration;\n\n\n\n    if (pkt->pts == AV_NOPTS_VALUE) {\n\n        av_log(s, AV_LOG_WARNING, \"pts has no value\\n\");\n\n        pkt->pts = pkt->dts;\n\n    }\n\n    if (pkt->dts != pkt->pts)\n\n        trk->hasBframes = 1;\n\n    trk->cluster[trk->entry].cts = pkt->pts - pkt->dts;\n\n    trk->cluster[trk->entry].key_frame = !!(pkt->flags & PKT_FLAG_KEY);\n\n    if(trk->cluster[trk->entry].key_frame)\n\n        trk->hasKeyframes++;\n\n    trk->entry++;\n\n    trk->sampleCount += samplesInChunk;\n\n    mov->mdat_size += size;\n\n\n\n    put_buffer(pb, pkt->data, size);\n\n\n\n    put_flush_packet(pb);\n\n    return 0;\n\n}", "idx": 3956, "substitutes": {"s": ["S", "su", "sv", "sc", "r", "ns", "cs", "si", "n", "conf", "ssl", "qs", "o", "p", "d", "cli", "sq", "se", "m", "sa", "ds", "an", "sci", "v", "services", "a", "stats", "sys", "service", "g", "us", "server", "ses", "spec", "sf", "c", "sb", "params", "self", "gs", "sym", "t", "sports", "b", "f", "sg", "u", "aws", "ss", "js", "e", "sl", "ls", "bis", "http", "sup", "sync"], "pkt": ["ppunk", "ppacket", "upkt", "ppt", "pkg", "Pkg", "pet", "funk", "feter", "macket", "packacket", "Pkt", "Piece", "spkg", "punk", "packet", "piece", "munk", "pracket", " piece", "upunk", "ppwk", "ciece", "rpt", "mkt", "Packet", " ppt", "fkt", "spacket", "upacket", " peth", "racket", " packet", "cacket", "pwk", "prkt", "mkg", "peter", "Pet", "Punk", " pwk", "Pwk", "packeter", "prpt", "fet", "Peth", "rkt", "packkg", "ckt", "prwk", "reth", "spkt", "ppkt", " peter", "packkt", "peth", " punk", " pkg", "facket", "fiece", "fkg", " pet", "spiece", "upiece", "cunk", "Ppt"], "mov": ["mour", "demev", "tmou", "cmov", "tmove", "demour", " mOV", "cmev", "cmove", " mou", "mOV", "cmour", " mev", "mev", " move", "smov", "demov", "demove", "move", "smou", "tmov", "smOV", "mou", "tmOV", "smove", " mour"], "pb": ["ocol", "rb", "lp", "pkg", "bp", "fc", "cpp", "prot", "ctx", "pm", "bb", "fp", "bps", "pd", "phrase", "ib", "p", "param", "ub", "ream", "pid", "typ", "gp", "api", "wp", "fb", "ppa", "platform", "cp", "pc", "orp", "abb", "uf", "hub", "sb", "np", "bh", "plugin", "aph", "cb", "db", "pa", "amp", "rob", "wb", "summary", "dp", "bc", "lb", "bm", "PB"], "trk": ["terok", "hrk", "trakin", "frk", "erk", "trf", "srsk", "trck", "Trks", " trkt", "ersk", " trsk", "prok", "turkick", " trku", "erf", " trc", "prk", "trkick", "trok", "prks", "TRks", "hrg", " trK", "hrok", "Trk", "TrK", "srk", "frks", "rtwork", "terke", "trke", "trc", "prck", "turk", "TRK", " trwork", " trq", "trks", "hrck", "terk", "hrK", " trke", "wrke", "rtc", "perke", "erke", "TRk", "trK", "traks", "frq", "terkick", "frke", "frkt", " trks", "trku", "perks", "trsk", "trkt", "trkin", "trake", "turok", "prg", "rtK", "prf", "hrke", "trwork", "trg", " trck", "Trck", "perk", "wrk", " trkin", "trq", "srke", "prsk", " trf", "perK", "prku", "prke", "TRke", "rtk", "turq", " trg", "wrks", "srku", "wrkin", "hrks", "prkt", "prK", "turK", "turke", "prwork", "trak", "prkick", "frg", " trok", "frK", "prc"], "enc": ["cmp", "sec", "lib", "eu", "lang", "ec", "sci", "auc", "ch", "inc", "env", "iv", "cel", "kw", "cod", "alg", "auth", "rh", "ac", "secure", "install", "conv", "vc", "anc", "config", "voc", "unc", "cv", "ant", "ou", "iq", "nt", "app", "comp", "eng", "rn", "encrypted", "ent", "open", "ct", "ev", "ce", "lc", "ack", "ctx", "ssl", "ic", "ENC", "acl", "acc", "Enc", "con", "conn", "spec", "oc", "sl", "cache", "mac", "loc", "equ", "img", "alloc", "oder", "bn", "rec", "sys", "ext", "coll", "c", "nc", "util", "nec", "hw", "en"], "packed_size": ["packed_capacity", "oded_size", "packed2size", "oded_range", "packed_range", "packed2count", "oded_shape", " packed_length", "packed2capacity", "packed2length", "packed_shape", " packed_capacity", " packed_count", "packed_count", "packed_length"], "samplesInChunk": ["samplesPerChica", "samplesInCHick", "samplesInCHacket", "samplesINCheacket", "samplesInChunks", "samplesINChoca", "samplesInPartica", "samplesPerCHoy", "samplesInCHunks", "samplesInChick", "samplesInChoy", "samplesInCheunk", "samplesInchoca", "samplesInChica", "samplesInCompacket", "samplesPerChoy", "samplesPerChunk", "samplesInCHunk", "samplesInChipica", "samplesInchunks", "samplesInCunks", "samplesInChoku", "samplesInchoy", "samplesInchacket", "samplesInCHoy", "samplesPerCHoku", "samplesInCompoy", "samplesInPartunk", "samplesInCunk", "samplesInCick", "samplesPerCHunk", "samplesInchunk", "samplesInChartoy", "samplesPerCHick", "samplesInChacket", "samplesInChartoku", "samplesINChunk", "samplesInCompick", "samplesPerCHunks", "samplesInChartunk", "samplesInChoca", "samplesInCoy", "samplesInChipunk", "samplesPerCHacket", "samplesInCheoca", "samplesInChipick", "samplesINChacket", "samplesInCHoku", "samplesPerChacket", "samplesInCHica", "samplesInchoku", "samplesInCompunk", "samplesInChartunks", "samplesPerChoku", "samplesPerChunks", "samplesPerChick", "samplesInCompunks", "samplesINCheunk", "samplesPerCHica", "samplesInCheacket", "samplesInPartick", "samplesINCheoca", "samplesInCHoca"]}}
{"project": "qemu", "commit_id": "b835e919f022d768abdf00e8dc94f1a23fdcab15", "target": 1, "func": "static void gen_st_cond (DisasContext *ctx, uint32_t opc, int rt,\n\n                         int base, int16_t offset)\n\n{\n\n    const char *opn = \"st_cond\";\n\n    TCGv t0, t1;\n\n\n\n    t0 = tcg_temp_local_new();\n\n\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n    /* Don't do NOP if destination is zero: we must perform the actual\n\n       memory access. */\n\n\n\n    t1 = tcg_temp_local_new();\n\n    gen_load_gpr(t1, rt);\n\n    switch (opc) {\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_SCD:\n\n        save_cpu_state(ctx, 0);\n\n        op_st_scd(t1, t0, rt, ctx);\n\n        opn = \"scd\";\n\n        break;\n\n#endif\n\n    case OPC_SC:\n\n        save_cpu_state(ctx, 1);\n\n        op_st_sc(t1, t0, rt, ctx);\n\n        opn = \"sc\";\n\n        break;\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %d(%s)\", opn, regnames[rt], offset, regnames[base]);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 3960, "substitutes": {"ctx": ["kb", "cu", "cc", "pkg", "mac", "req", "loc", "cy", "sc", "cf", "rc", "cpp", "context", "cmp", "xs", "linux", "null", "cca", "lib", "alloc", "exec", "ci", "vc", "rx", "src", "connection", "fp", "cli", "config", "cam", "qt", "voc", " cx", "qa", "tc", "sci", "cv", "cp", "lc", "conn", "gz", "ca", "txt", "cn", "c", "ctrl", "cz", "scope", "kt", "cb", "tx", "ck", "wcs", "cmd", "hw", "client", "aux", "ctr", "cor", "bc", " context", "cas", "sync", "cm", "anc"], "opc": ["OPc", "opern", "hopct", "copC", "operct", "opercn", "OPn", "OPct", "optn", "opct", "copc", "copct", "optcn", "hopc", "operc", "optC", "OPcn", "copn", "hopn", "optct", "hopC", "optc", "opcn", "opC"], "rt": ["tab", "fr", "cat", "rect", "rb", "cr", "rr", "vt", "r", "loc", "req", "rc", "ptr", "tt", "rx", "pt", "vc", "ref", "src", "dr", "gt", "adr", "lat", "rev", "ret", "rf", "typ", "route", "reset", "vr", "RT", "format", "rd", "ant", "type", "feat", "sys", "wt", "mt", "yt", "nt", "rs", "dt", "target", "ru", "rn", "boot", "rot", "rid", "vert", "rl", "ft", "addr", "cycle", "it", "art"], "base": ["bf", "cache", "part", "loc", "scale", "l", "bb", "unit", "uri", "core", "p", "ref", "root", "ite", "name", "id", "buffer", "rest", "et", "area", "len", "reset", "ase", "count", "beta", "bi", "prefix", "lc", "based", "Base", "server", "site", "pre", "start", "boot", "ace", "rot", "db", "b", "range", "address", "bas", "set", "size", "addr", "extra", "lb", "source"], "offset": ["phase", "attribute", "part", "loc", "attr", "padding", "o", "alt", "p", "fp", "Offset", "ref", "location", "alias", "acl", "name", "alpha", "et", "area", "len", "reset", "off", "format", "pos", "prefix", "type", "position", "data", "adjust", "length", "slot", "initial", "url", "origin", "start", "boot", "rot", "b", "f", "align", "range", "address", "set", "size", "addr", "seq", "index"], "opn": ["OPc", "opns", "ipN", "OPns", "opern", "opl", " opl", "OPn", "oprn", "hopN", "ipn", "ipl", "operl", "optn", "oknc", " opb", "hopl", " opnc", "rootN", "hopc", "operc", "OPnc", " oprn", "okns", "optN", "ipb", "rootc", " opN", "iprn", "hopn", "operN", "hopnu", "opnc", "okn", "opN", "opnu", "optc", "rootn", "opb", "optrn", "optl", " opnu", "rootnu", " opns", "okc", "optb", "ipc"], "t0": ["p3", "t5", "f0", "t4", "f5", " t4", "t8", "p0", " t3", "T5", "tt1", "pt0", "p1", " t2", "f4", "pt4", "tt0", "tt5", "t00", "p8", "pt2", "t3", "T3", "p00", "pt00", "t2", "pt1", "f2", "T0", "T1", " t5", "T4", "pt8", "p2", " t00", "f1", "T2", "p4", "T8"], "t1": ["p3", "taone", "ta1", "tpre", "pb", "p0", " t3", "Tpre", "pt0", "p1", " t2", " tb", "pached", " tone", "T9", "tone", "at1", "pt2", "t3", "T3", "Tb", "t2", "pt1", "Tone", "at0", "ta0", "p9", "atached", "T0", "T1", "at2", "tached", "pt9", "tb", "p2", "t9", "ppre", "atpre", "T2", "Tached"]}}
{"project": "qemu", "commit_id": "a718978ed58abc1ad92567a9c17525136be02a71", "target": 1, "func": "static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)\n\n{\n\n    BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n\n    IDEState *s = bmdma_active_if(bm);\n\n    PCIDevice *pci_dev = PCI_DEVICE(bm->pci_dev);\n\n    struct {\n\n        uint32_t addr;\n\n        uint32_t size;\n\n    } prd;\n\n    int l, len;\n\n\n\n    pci_dma_sglist_init(&s->sg, pci_dev,\n\n                        s->nsector / (BMDMA_PAGE_SIZE / 512) + 1);\n\n    s->io_buffer_size = 0;\n\n    for(;;) {\n\n        if (bm->cur_prd_len == 0) {\n\n            /* end of table (with a fail safe of one page) */\n\n            if (bm->cur_prd_last ||\n\n                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {\n\n                return s->io_buffer_size;\n\n            }\n\n            pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);\n\n            bm->cur_addr += 8;\n\n            prd.addr = le32_to_cpu(prd.addr);\n\n            prd.size = le32_to_cpu(prd.size);\n\n            len = prd.size & 0xfffe;\n\n            if (len == 0)\n\n                len = 0x10000;\n\n            bm->cur_prd_len = len;\n\n            bm->cur_prd_addr = prd.addr;\n\n            bm->cur_prd_last = (prd.size & 0x80000000);\n\n        }\n\n        l = bm->cur_prd_len;\n\n        if (l > 0) {\n\n            qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);\n\n\n\n            /* Note: We limit the max transfer to be 2GiB.\n\n             * This should accommodate the largest ATA transaction\n\n             * for LBA48 (65,536 sectors) and 32K sector sizes. */\n\n            if (s->sg.size > INT32_MAX) {\n\n                error_report(\"IDE: sglist describes more than 2GiB.\");\n\n                break;\n\n            }\n\n            bm->cur_prd_addr += l;\n\n            bm->cur_prd_len -= l;\n\n            s->io_buffer_size += l;\n\n        }\n\n    }\n\n\n\n    qemu_sglist_destroy(&s->sg);\n\n    s->io_buffer_size = 0;\n\n    return -1;\n\n}\n", "idx": 3970, "substitutes": {"dma": ["Dma", "bmp", "ldwa", " dMA", "mdla", "DMA", "Dda", "mmp", "Dmm", "mMA", "dmm", "bma", "Dla", "ldla", "mmm", "mwa", "dmp", "ldma", "mdma", "mda", " dta", "dda", "bMA", "dwa", " dmp", "mta", "Dwa", "mma", "mdwa", "mdMA", "dla", " dwa", "bta", "dMA", "dta", " dda", "ldMA", " dmm"], "is_write": ["id_mode", "id_write", "is_writ", "id_read", "id_writ", "is_read", "is_mode"], "bm": ["BM", "md", "hm", "bf", "tm", "umi", "cache", "cfg", "im", "nm", "base", "bp", "ram", "pb", "bb", "pm", "binary", "lim", "bd", "y", "p", "bo", "fl", "bg", "dm", "module", "m", "bs", "obj", "mi", "gp", "mr", "vm", "bn", "fm", "mm", "an", "am", "bi", "nb", "sbm", "rm", "ym", "dn", "wm", "sb", "gm", "gb", "bh", "gs", "mc", "cb", "om", "em", "db", "b", "bin", "sm", "bl", "bc", "lb", "rem", "cm", "bt"], "s": ["S", "fs", "ms", "su", "r", "sr", "sv", "ts", "ns", "hs", "sync", "cs", "is", "si", "conf", "ssl", "y", "o", "qs", "p", "sim", "ys", "ins", "d", "m", "bs", "sq", "session", "se", "ings", "ions", "sn", "w", "sa", "sis", "an", "services", "sys", "states", "service", "g", "stats", "ps", "ses", "spec", "sb", "rs", "c", "es", "secondary", "sets", "gs", "sym", "state", "t", "b", "os", "sg", "storage", "f", "serv", "ss", "js", "e", "sl", "ls", "its", "set", "ds", "so"], "pci_dev": ["pcm_div", "pci_conn", "pci__addr", "pciMmode", "pci__device", "pci2conn", "pdi_priv", "pdi_device", "pciMdevice", "pdi_mode", "pcm_dev", "pci_mode", "pci_addr", "pci2div", "pci2dev", "pci_device", "pci2priv", "pcm_device", "pcm_conn", "pci_priv", "pciMdiv", "pdi_addr", "pci2device", "pci_div", "pdi_div", "pdi_dev", "pci__mode", "pciMdev", "pci__dev"], "prd": ["yrd", "rb", "rr", "ptrn", "prdy", "parcd", "trd", "Prdh", "pard", "prdh", "ptrd", " prs", "rd", " prt", "sprb", "trds", "frdd", "ird", " prdy", "irds", " prdm", " prb", "sprcd", "yrds", "ptrds", "privdt", "yrdd", "parb", "prdt", "trs", "sprd", "perdy", "ern", "prds", "perr", "sprds", "privd", "sprs", "frn", " prdh", "prdm", "irs", "ptrdy", "sprn", "yrb", " prcd", "erd", "sprdd", "ptrdm", "sprdy", "erdh", "perd", "erds", "sprdm", "pert", "frd", "irdy", " prn", "trdt", "Prd", "privs", "prs", "frds", " prdt", "prr", "ptrs", "prn", "rt", "prcd", " prds", " prdd", "prt", "pern", "ptrb", "prb", "privds", "prdd", "perb", "Prn", "Prds", "parn", " prr"], "l": ["i", "lp", "r", "lu", "tl", "j", "n", "dl", "o", "jl", "L", "p", "le", "lin", "fl", "d", "m", "z", "ln", "ol", "ld", "ul", "v", "lit", "vl", "el", "li", "ell", "length", "il", "c", "ll", "El", "kl", "la", "nl", "b", "f", "u", "rl", "e", "ls", "sl", "lb", "lf", "lc", "en"], "len": ["line", "val", "lp", "base", "loc", "lu", "lt", "low", "j", "n", "lon", "lim", "elt", "lib", "dl", "le", "lin", "L", "fl", "rev", "limit", "ln", "z", "dy", "hl", "ol", "ld", "count", "Len", "full", "v", "pos", "el", "li", "ell", "lan", "ler", "length", "il", "url", "ll", "kl", "la", "f", "err", "ni", "size", "sl", "bl", "lf", "lc", "en"]}}
{"project": "FFmpeg", "commit_id": "5a2ad7ede33b5d63c1f1b1313a218da62e1c0d48", "target": 0, "func": "static int apply_window_and_mdct(vorbis_enc_context *venc,\n\n                                 float *audio, int samples)\n\n{\n\n    int channel;\n\n    const float * win = venc->win[0];\n\n    int window_len = 1 << (venc->log2_blocksize[0] - 1);\n\n    float n = (float)(1 << venc->log2_blocksize[0]) / 4.0;\n\n    AVFloatDSPContext *fdsp = venc->fdsp;\n\n\n\n    if (!venc->have_saved && !samples)\n\n        return 0;\n\n\n\n    if (venc->have_saved) {\n\n        for (channel = 0; channel < venc->channels; channel++)\n\n            memcpy(venc->samples + channel * window_len * 2,\n\n                   venc->saved + channel * window_len, sizeof(float) * window_len);\n\n    } else {\n\n        for (channel = 0; channel < venc->channels; channel++)\n\n            memset(venc->samples + channel * window_len * 2, 0,\n\n                   sizeof(float) * window_len);\n\n    }\n\n\n\n    if (samples) {\n\n        for (channel = 0; channel < venc->channels; channel++) {\n\n            float *offset = venc->samples + channel * window_len * 2 + window_len;\n\n\n\n            fdsp->vector_fmul_reverse(offset, audio + channel * window_len, win, samples);\n\n            fdsp->vector_fmul_scalar(offset, offset, 1/n, samples);\n\n        }\n\n    } else {\n\n        for (channel = 0; channel < venc->channels; channel++)\n\n            memset(venc->samples + channel * window_len * 2 + window_len,\n\n                   0, sizeof(float) * window_len);\n\n    }\n\n\n\n    for (channel = 0; channel < venc->channels; channel++)\n\n        venc->mdct[0].mdct_calc(&venc->mdct[0], venc->coeffs + channel * window_len,\n\n                     venc->samples + channel * window_len * 2);\n\n\n\n    if (samples) {\n\n        for (channel = 0; channel < venc->channels; channel++) {\n\n            float *offset = venc->saved + channel * window_len;\n\n\n\n            fdsp->vector_fmul(offset, audio + channel * window_len, win, samples);\n\n            fdsp->vector_fmul_scalar(offset, offset, 1/n, samples);\n\n        }\n\n        venc->have_saved = 1;\n\n    } else {\n\n        venc->have_saved = 0;\n\n    }\n\n    return 1;\n\n}\n", "idx": 3971, "substitutes": {"venc": ["fenf", "vence", "rencu", "avenec", "renf", "VENcs", "enc", "venec", "renrc", "tendc", "tencu", "avene", "vinxc", "dennc", "avencf", "tenf", "fenec", "tenc", "renlc", "VENcu", "renec", "vinf", "avency", "venp", "vince", "venic", "isenc", "fenl", "dency", " vencu", "VENf", "renl", "renxc", "VENce", "vellc", "vinrc", "hene", "avendc", "tenpc", "renv", "vinpc", "wenf", "denp", "genc", "rene", "avenic", "venxc", "wenec", "vinl", "tenec", "vernc", "vincu", "ovenlc", "genlc", "denf", "fenc", "venf", " venic", "venrc", "wenp", "avenc", "tenp", "vernlc", " vencf", "renc", "vanc", "avencs", "renp", "venl", "isenf", "ovenc", "VENrc", "tenlc", "vinc", "wence", "hencu", "enf", "velf", "VENc", "avenxc", "wennc", "venlc", "henc", "isenic", "wencs", "verncs", "henf", "vency", "velec", "wencu", "verne", "tenv", "vancy", "rence", "avenpc", "velc", "renpc", "enec", "denl", "vencu", "avenlc", "denc", "avencu", "vernec", "wenc", "denlc", "genec", "avenp", "venv", "vencf", "vernf", "rencs", "gencs", "enl", " venf", "venpc", "vendc", "genf", "avenl", "avenf", "avence", "vene", "ovenf", "vennc", "ovenec", "denec", "dendc", "vencs", "vinec", "tencs", "vanp", "isencf", "wene", "gencu", "tene", " venv", "avennc", "vanf", "tenl"], "audio": ["media", "wa", "feed", "voice", "i", "sample", "io", "wave", "mpeg", "ac", "sound", "Audio", "array", "img", "binary", "play", "byte", "input", "config", "m", "alpha", "buffer", "a", "format", "file", "data", "video", "window", "length", "output", "image", "wav", "bin", "native", "space", "volume", "source"], "samples": ["vipes", "sourses", "opensamps", "sesamps", "jsaved", "vums", "insamples", "bample", " sipes", "insourses", "ssamples", "jsamples", "Songs", "ssongs", "tamp", " solutions", " sannels", " samps", "chample", "sitesounds", "jsolutions", "chaved", "dummies", "chummies", "ssipes", "dums", "bources", "sannels", "songs", "Sources", "Samp", "channels", "fipes", "ssamps", "dample", "sipes", "namps", "cheeds", " sourses", "opensipes", "vamples", "damps", "Sounds", "inseeds", "taved", "daved", " saved", "ssannels", "Sample", "isummies", "jsannels", "vannels", "Saved", "dourses", "summies", "vourses", "opensannels", "tamples", "chourses", "sources", "sitesamps", "sounds", "chums", "saved", "damples", "isaved", "nample", " songs", "Sannels", "bourses", " sounds", "sitesannels", "sample", "namples", "sums", "bamps", " samp", "famples", "seeds", "beeds", "champles", "samps", "bamples", "sitesamples", "solutions", "sesources", "dannels", "isample", "Samples", "insaved", "tamps", "dolutions", "Samps", "fourses", "sesample", "sesamples", "samp", "opensamples", "isamples", "fannels", "baved"], "channel": ["man", "phase", "database", "unit", "button", "pixel", "letter", "key", "group", "an", "contin", "bean", "window", "video", "row", "column", "layer", "plugin", "ch", "wan", "image", "block", "variable", "gap", "que", "component", "page", "cycle", "message", "campaign", "Channel", "error", "language", "option", "outer", "remote", "config", "call", "name", "stage", "route", "event", "question", "format", "url", "panel", "center", "custom", "course", "comment", "feed", "project", "chain", "chan", "function", "core", "category", "session", "queue", "element", "mon", "stream", "change", "service", "ann", "batch", "member", "server", "package", "item", "can", "global", "player", "annels", "size", "month", "path", "password", "source", "character", "model", "user", "attribute", "socket", "sample", "container", "section", "connection", "byte", "module", "tube", "token", "word", "hole", "handler", "platform", "frame", "type", "slot", "c", " channels", "nc", "direction", "target", "chron", "version", "resource", "client", "second"], "win": ["draw", "fn", "wa", "lock", "won", "scan", "wave", "ac", "gen", "nan", "disk", "enc", "play", "n", "num", "lang", "write", "input", "config", "min", "skin", "limit", "w", "ad", "run", "con", "rec", "pos", "conn", "wal", "clean", "window", "gain", "batch", "row", "work", "inn", "in", "margin", "weight", "wan", "image", "block", "col", "ng", "bin", "gui", "max", "na", "client", "Win", "widget", "thin", "rain"], "fdsp": ["all", "ndsc", "dfp", "ldspe", "ndcp", "fdsl", "d", "vdsk", "vdsm", "fdcp", "fdsk", "hdp", "ldpc", "dfsc", "this", "fdtp", "ldtp", "fdsc", "_", "dnpc", "wave", "fdspe", "config", "buffer", "ldsp", "ldsh", "dfsm", "hdpc", "vdsc", "vdp", "dfpc", "hdsk", "vdcp", "ndsp", "hdsh", "dnsp", "dntp", "fdsh", "fdp", "hdsp", "dftp", "vdse", "hdse", "g", "hdsl", "vdsl", "dnspe", "dfcp", "ldsl", "fdsm", "img", "dfse", "vdsp", "vdsh", "dfspe", "end", "dfsp", "dfsk", "ndsm", "vdpc", "fdpc", "fdse"], "offset": ["i", "attribute", "part", "value", "loc", "shift", "attr", "error", "padding", "null", "alt", "o", "layout", "pixel", "Offset", "location", "alias", "append", "alpha", "limit", "reset", "activation", "off", "help", "pad", "pos", "prefix", "end", "notation", "label", "position", "adjust", "window", "parent", "slot", "length", "output", "initial", "url", "origin", "start", "layer", "info", "seed", "image", "rot", "style", "annot", "f", "align", "ip", "address", "online", "size", "addr", "entry", "index"]}}
{"project": "qemu", "commit_id": "591b320ad046b2780c1b2841b836b50ba8192f02", "target": 1, "func": "static inline int popcountl(unsigned long l)\n\n{\n\n    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);\n\n}\n", "idx": 3977, "substitutes": {"l": ["val", "i", "lp", "r", "n", "dl", "o", "pl", "L", "p", "le", "d", "m", "ln", "ol", "len", "ul", "v", "x", "el", "li", "list", "length", "c", "ll", "kl", "la", "al", "t", "b", "f", "u", "cl", "e", "sl", "ls", "lr", "lb", "lo", "lc"]}}
{"project": "FFmpeg", "commit_id": "8542f9c4f17125d483c40c0c5723842f1c982f81", "target": 1, "func": "static int32_t parse_gain(const char *gain)\n\n{\n\n    char *fraction;\n\n    int  scale = 10000;\n\n    int32_t mb = 0;\n\n    int sign   = 1;\n\n    int db;\n\n\n\n    if (!gain)\n\n        return INT32_MIN;\n\n\n\n    gain += strspn(gain, \" \\t\");\n\n\n\n    if (*gain == '-')\n\n        sign = -1;\n\n\n\n    db = strtol(gain, &fraction, 0);\n\n    if (*fraction++ == '.') {\n\n        while (av_isdigit(*fraction) && scale) {\n\n            mb += scale * (*fraction - '0');\n\n            scale /= 10;\n\n            fraction++;\n\n        }\n\n    }\n\n\n\n    if (abs(db) > (INT32_MAX - mb) / 100000)\n\n        return INT32_MIN;\n\n\n\n    return db * 100000 + sign * mb;\n\n}\n", "idx": 3984, "substitutes": {"gain": ["ain", "loss", "grain", "scan", "attr", "scale", "wave", "sort", "gen", "unit", "learn", "gan", "group", "nn", "input", "bridge", "config", "acc", "win", "ga", "gp", "gate", "guide", "gn", "gnu", "gender", "format", "conn", "gross", "g", "sign", "gin", "dn", "shape", "wm", "inn", "forward", "can", "gram", "rank", "gg", "gb", "auc", "wan", "atten", "rule", "bin", "gap", "hack", "gam", "align", "range", "gar", "paren", "parse", "pass", "go", "kin", "password", "clean"], "fraction": ["fractions", "fletcher", "ference", "flux", "Fractions", "ofraction", "Fault", "Fancy", "braction", "rfract", "infancy", "inference", "infault", "lfractions", "Fraction", "lflux", "infractions", " fract", "infrequency", " fault", "ofrequency", "Ference", "felux", "infract", "refract", "rference", "fract", "bract", " fractions", "infraction", "Frequency", "frequency", "feletcher", "refraction", "Fract", "bletcher", "lfraction", "fault", "feraction", "Flux", "ofractions", "bractions", "lfletcher", "ofancy", "fancy", "refractions", "refletcher", "rfraction", " fletcher", "Fletcher", "rfractions", "feractions"], "db": ["bf", "dd", "rb", "Db", "scan", "base", "scale", "mp", "dB", "bb", "pb", "dl", "bd", "lib", "mag", "ib", "bg", "dm", "nn", "ab", "d", "min", "ma", "real", "dy", "ba", "fb", "mb", "bi", "nb", "fd", "eb", "sb", "gb", "gg", "DB", "cb", "b", "sd", "dp", "amb", "big", "bc", "deb", "ds", "sql", "bm", "cm", "pg"]}}
{"project": "qemu", "commit_id": "c641483fbe0aa08cd7c0580d019dc2d5a7e71138", "target": 1, "func": "static inline void ide_dma_submit_check(IDEState *s,\n\n          BlockDriverCompletionFunc *dma_cb)\n\n{\n\n    if (s->bus->dma->aiocb)\n\n\treturn;\n\n    dma_cb(s, -1);\n\n}\n", "idx": 3988, "substitutes": {"s": ["S", "sv", "ts", "ns", "is", "ssl", "o", "south", "p", "src", "input", "d", "m", "sq", "se", "session", "status", "an", "services", "sys", "states", "g", "submit", "ses", "spec", "sf", "c", "sb", "es", "self", "rs", "sym", "state", "sports", "t", "b", "f", "storage", "os", "u", "ss", "js", "e", "sl", "ops", "ds", "sync"], "dma_cb": ["dma_done", "dma_rb", "dma_callback", "dfa_done", "dfa_cb", "dma_CB", "dfa_rb", "dfa_CB", "dfa_callback"]}}
{"project": "qemu", "commit_id": "d3c8c67469ee70fcae116d5abc277a7ebc8a19fd", "target": 1, "func": "static BlockStats *bdrv_query_bds_stats(const BlockDriverState *bs,\n\n                                 bool query_backing)\n\n{\n\n    BlockStats *s = NULL;\n\n\n\n    s = g_malloc0(sizeof(*s));\n\n    s->stats = g_malloc0(sizeof(*s->stats));\n\n\n\n    if (!bs) {\n\n        return s;\n\n    }\n\n\n\n    if (bdrv_get_node_name(bs)[0]) {\n\n        s->has_node_name = true;\n\n        s->node_name = g_strdup(bdrv_get_node_name(bs));\n\n    }\n\n\n\n    s->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset);\n\n\n\n    if (bs->file) {\n\n        s->has_parent = true;\n\n        s->parent = bdrv_query_bds_stats(bs->file->bs, query_backing);\n\n    }\n\n\n\n    if (query_backing && bs->backing) {\n\n        s->has_backing = true;\n\n        s->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing);\n\n    }\n\n\n\n    return s;\n\n}\n", "idx": 4006, "substitutes": {"bs": ["banks", "fs", "las", "base", "BS", "ns", "ts", "bid", "cs", "pb", "bb", "ctx", "bm", "bes", "plugins", "qs", "ys", "ubs", "bits", "als", "bps", "http", "ras", "details", "obj", "bing", "blocks", "lbs", "bos", "fb", "ros", "bi", "stats", "sys", "nas", "css", "ps", "us", "ks", "ses", "bal", "sb", "rs", "iss", "es", "obs", "gb", "bh", "gs", "bytes", "abi", "cb", "vs", "db", "b", "os", "pse", "bin", "ss", "bas", "js", "ls", "bl", "bc", "lb", "ds", "bis", "sync", "xs"], "query_backing": ["query_tunning", "query_landing", "query_udinding", "query_backings", "query_returnlocking", "query_backlocking", "query_udings", "query_udding", "query_bounding", "query_bbinding", "query_fronting", "query_defering", "query_defding", "query_frontings", "query_tunishing", "query_frontering", "query_backning", "query_backishing", "query_frontding", "query_backding", "query_backinding", "query_bbing", "query_returnending", "query_uding", "query_callbacking", "query_boundending", "query_backging", "query_frontinding", "query_callbacked", "query_defging", "query_landering", "query_backering", "query_backending", "query_landging", "query_boundning", "query_bbings", "query_bbding", "query_bounded", "query_boundlocking", "query_callbacklocking", "query_frontning", "query_boundishing", "query_returning", "query_frontging", "query_backed", "query_tunging", "query_callbackending", "query_defing", "query_landding", "query_frontishing", "query_tuning", "query_boundging", "query_returned"], "s": ["i", "conf", " values", "er", "ubs", "ists", "d", "words", "v", "ves", "states", "ps", "lines", "secondary", "sb", "sym", "os", "f", "parts", "js", "ies", "l", "is", "si", "o", "y", "qs", "p", "less", "details", "stats", "css", "ses", "b", "sg", "u", "ops", "sync", "h", "S", "r", "settings", "hs", "cs", "ssl", "m", "session", "sq", "obj", "w", "ed", "full", "your", "g", "service", "spec", "ks", "es", "gs", "t", "sports", "aws", "ss", "e", "ls", "http", "ds", " results", "fs", "su", "sets", "ts", "ns", "n", "bes", "rates", " statements", "or", "rows", "ings", "services", "sys", "sf", "c", "rs", "self", "ows", "ges", "its", "bis"]}}
{"project": "FFmpeg", "commit_id": "6f1b2967712e25e4c39c506862982b3011e06532", "target": 1, "func": "static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,\n\n                                    const uint8_t *src, const uint8_t *src_end,\n\n                                    int width, int esc_count)\n\n{\n\n    int i = 0;\n\n    int count;\n\n    uint8_t zero_run = 0;\n\n    const uint8_t *src_start = src;\n\n    uint8_t mask1 = -(esc_count < 2);\n\n    uint8_t mask2 = -(esc_count < 3);\n\n    uint8_t *end = dst + (width - 2);\n\n\n\n    avpriv_request_sample(l->avctx, \"zero_run_line\");\n\n    return AVERROR_PATCHWELCOME;\n\n\n\noutput_zeros:\n\n    if (l->zeros_rem) {\n\n        count = FFMIN(l->zeros_rem, width - i);\n\n        if (end - dst < count) {\n\n            av_log(l->avctx, AV_LOG_ERROR, \"Too many zeros remaining.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        memset(dst, 0, count);\n\n        l->zeros_rem -= count;\n\n        dst += count;\n\n    }\n\n\n\n    while (dst < end) {\n\n        i = 0;\n\n        while (!zero_run && dst + i < end) {\n\n            i++;\n\n            if (i+2 >= src_end - src)\n\n                return AVERROR_INVALIDDATA;\n\n            zero_run =\n\n                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));\n\n        }\n\n        if (zero_run) {\n\n            zero_run = 0;\n\n            i += esc_count;\n\n            memcpy(dst, src, i);\n\n            dst += i;\n\n            l->zeros_rem = lag_calc_zero_run(src[i]);\n\n\n\n            src += i + 1;\n\n            goto output_zeros;\n\n        } else {\n\n            memcpy(dst, src, i);\n\n            src += i;\n\n            dst += i;\n\n        }\n\n    }\n\n    return  src - src_start;\n\n}\n", "idx": 4009, "substitutes": {"l": ["gl", "lp", "loc", "lu", "n", "dl", "jl", "lib", "pl", "L", "p", "le", "o", "fl", "d", "m", "acl", "ln", "ol", "k", "ld", "lb", "ul", "v", "el", "li", "ell", "list", "il", "c", "url", "ll", "kl", "la", "nl", "al", "t", "b", "rl", "u", "f", "ml", "e", "sl", "ls", "iol", "bl", "wl", "shell", "lo", "lc", "s"], "dst": [" dost", "ndost", " dct", "pdirst", "idrest", "adst", "adct", "drc", "odsth", "ddst", "fdrest", " dsrc", "Drest", "odest", " drc", "lst", "pdst", "Dsth", "idct", "ddsth", "fdste", " drest", "adost", "pdsts", " dsc", "dsts", "idsc", "sdsc", "ddsts", "dest", "ddost", "ddsrc", " dest", "adsth", "idost", "lrc", " dsts", "Dsts", "dste", "dsth", " dsp", "sdsp", "ddsc", "dsc", "sdost", " dsth", "adrest", "Dsc", "Drc", "ndst", "fdst", "dsrc", "ddrc", "dsp", "Dost", "Dest", "adrc", "idste", "idst", "dost", "Dsrc", "ndsrc", "odst", "Dste", "ndsts", "lost", "Dirst", "odost", "pdost", "lsth", "drest", "Dsp", "sdirst", "dct", "sdst", "fdost", "dirst", "Dst", "sdsts"], "src": ["gl", "dist", "rb", "text", "sub", "cmp", "sec", "sel", "send", "sn", "rss", "sci", "ruby", "sb", "ch", "cb", "proc", "s", "host", "inf", "usc", "inst", "sr", "secure", "sit", "st", "tmp", "ind", "config", "stage", "buf", "cv", "dest", "url", "comp", "flash", "pack", "rob", "sup", "sync", "support", "supp", "r", "sc", "ctx", "ssl", "core", "sh", "sq", "slice", "stream", "gz", "length", "chrom", "ser", "cur", "size", "sl", "use", "http", "uc", "source", "desc", "uv", "sur", "loc", "rc", "low", "img", "rest", "rec", "rib", "c", "rs", "ource", "gb", "start", "resource", "seq"], "src_end": ["src_id", "src_size", "srcjid", "srcjclose", "rc_size", "rc_close", "src_close", "rc_start", "rc_id", "srcjend", "srcjstart", "rc_end"], "esc_count": ["sec_low", "loc_len", "esc_depth", "esc_connection", " sc33connection", "esc_length", "escitycount", "esc_Count", "esc33count", "esc33depth", "esc_size", "esc_start", " sc33size", "esc_num", "sec_batch", "loc_num", "esc_low", "escitylow", "sec_count", "loc_length", "escitysize", " sc_connection", "loc_count", " sc_depth", " sc33depth", " sc_size", "sec_size", "esc_len", "esc_batch", "sec_start", "esc33size", "escitybatch", " sc33count", " sc_count", "sec_Count", "esc33connection"], "count": ["line", "feed", "val", "cc", "Count", "offset", "cache", "all", "base", "loc", "common", "code", "low", "n", "num", "p", "isc", "ind", "min", "call", "id", "limit", "sum", "name", "check", "len", "keep", "full", "a", "type", "list", "coll", "add", "length", "work", "old", "c", "current", "start", "weight", "depth", "ch", "process", "col", "max", "b", "f", "inc", "child", "size", "e", "s", "found"], "src_start": ["src_id", "src_last", "rc_max", "src_max", "rc_start", "rc_id", "rc_end", "rc_last"], "end": ["offset", "r", "pend", "rc", "enc", "code", "END", "n", "st", "p", "nd", "ind", "append", "edge", "z", "id", "send", "head", "w", "limit", "ion", "ad", "rest", "stop", "dest", "est", "length", "old", "c", "start", "ending", "End", "max", "u", "last", "tail", "set", "e", "size", "x", "ended", "entry", "h", "en"], "i": ["ali", "uri", "ib", "d", "z", "ri", "v", "bi", "ami", "iu", "ie", "ji", "ix", "info", "pi", "f", "ti", "phi", "inf", "ui", "si", "is", "y", "p", "ci", "qi", "ind", "eni", "name", "I", "li", "init", "b", "u", "xi", "it", "base", "io", "r", "fi", "at", "multi", "oi", "ori", "ini", "slice", "zi", "ai", "t", "ei", "ip", "e", "esi", "yi", "index", "isi", "hi", "j", "n", "cli", "id", "api", "ii", "a", "type", "c", "in", "start", "di", "gi", "ni", "x"]}}
{"project": "qemu", "commit_id": "84593a0807004d852132eaa56edf24d55793d480", "target": 1, "func": "static int ram_init_all(RAMState **rsp)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n    if (ram_state_init(rsp)) {\n\n        return -1;\n\n    }\n\n\n\n    if (migrate_use_xbzrle()) {\n\n        XBZRLE_cache_lock();\n\n        XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE);\n\n        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(),\n\n                                  TARGET_PAGE_SIZE, &local_err);\n\n        if (!XBZRLE.cache) {\n\n            XBZRLE_cache_unlock();\n\n            error_report_err(local_err);\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n        XBZRLE_cache_unlock();\n\n\n\n        /* We prefer not to abort if there is no memory */\n\n        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.encoded_buf) {\n\n            error_report(\"Error allocating encoded_buf\");\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n\n\n        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.current_buf) {\n\n            error_report(\"Error allocating current_buf\");\n\n            g_free(XBZRLE.encoded_buf);\n\n            XBZRLE.encoded_buf = NULL;\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* For memory_global_dirty_log_start below.  */\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_mutex_lock_ramlist();\n\n    rcu_read_lock();\n\n\n\n    /* Skip setting bitmap if there is no RAM */\n\n    if (ram_bytes_total()) {\n\n        RAMBlock *block;\n\n\n\n        QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n\n            unsigned long pages = block->max_length >> TARGET_PAGE_BITS;\n\n\n\n            block->bmap = bitmap_new(pages);\n\n            bitmap_set(block->bmap, 0, pages);\n\n            if (migrate_postcopy_ram()) {\n\n                block->unsentmap = bitmap_new(pages);\n\n                bitmap_set(block->unsentmap, 0, pages);\n\n            }\n\n        }\n\n    }\n\n\n\n    memory_global_dirty_log_start();\n\n    migration_bitmap_sync(*rsp);\n\n    qemu_mutex_unlock_ramlist();\n\n    qemu_mutex_unlock_iothread();\n\n    rcu_read_unlock();\n\n\n\n    return 0;\n\n}\n", "idx": 4017, "substitutes": {"rsp": ["Rsk", "hrsp", "hrosp", "erbsp", "srsk", "srp", "erosp", "rpt", "arpt", "erp", "rrbsp", "risp", "srisp", "Rsc", "rrserv", "nrserv", "rrsl", " rhtml", " rSP", "arserv", " rsc", " rpart", "nrsp", "rSP", "Rserv", " rbsp", "rrpt", "phtml", "pp", "hrp", "srsp", "Rsp", "Rsl", "rrhtml", "rrosp", "hrpart", "rrspace", "rserv", "rsk", "arsl", " risp", "rpart", "rrsc", "arsp", "Rspace", "Rpt", "psl", "ersp", "rrpart", "srSP", "arspace", " rp", "rrp", "erisp", "rosp", "rsc", "arsc", "psp", " rosp", "srsl", "ersc", "rspace", "rhtml", "srbsp", "nrsk", "ersl", "srserv", "srsc", "rp", "erSP", "rbsp", "rrsp", "rsl", "nrsc", " rsl"], "local_err": ["local_rs", "local67err", "external_ref", "localablegr", "localableerr", "local_gr", "localablers", "local67error", " local_errors", " local_error", "local67ref", "external67ref", "local_req", "external67error", "local_errors", "external_error", "local_ref", " local_gr", "external67err", "external_err", " local_req", "localableerror", " local_rs", "local_error"], "block": ["comment", "line", "lock", "cache", "bc", "base", "error", "section", "def", "chain", "tag", "object", "copy", "unit", "num", "exec", "ref", "group", "number", "byte", "node", "job", "name", "word", "buffer", "session", "blocks", "load", "join", "Block", "run", "full", "off", "label", "slice", "frame", "build", "end", "event", "type", "batch", "row", "ban", "work", "pre", "prev", "map", "flow", "plugin", "result", "image", "channel", "network", "pack", "box", "b", "range", "ip", "address", "this", "bl", "open", "inner", "sync", "record", "link", "rule"]}}
{"project": "FFmpeg", "commit_id": "86b0d9cd58137fc499f263267c3219ac6186b98e", "target": 0, "func": "static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {\n\n    const unsigned int index_a = qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = beta_table[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]]+1;\n\n        tc[1] = tc0_table[index_a][bS[1]]+1;\n\n        tc[2] = tc0_table[index_a][bS[2]]+1;\n\n        tc[3] = tc0_table[index_a][bS[3]]+1;\n\n        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 4025, "substitutes": {"pix": ["pixels", "bixel", " pico", " px", "Pixels", "pixel", " pixels", "bixels", "bpixel", "PIX", "bpico", "Px", "Pix", "px", "Pixel", "bpix", "bIX", "Pico", "pIX", "bpixels", " pixel", "fx", "fix", "bx", "fixel", "bix", " pIX", "pico", "fixels"], "stride": ["collice", "stringide", "spride", "sprid", "collade", "strade", "sprip", "collip", " strider", "strip", "briding", "drade", "drice", "brides", "spriding", "stringided", "strid", "strides", "strided", " strides", "stringice", "sprice", "sprade", " strid", "brice", "bride", "collide", "striding", "sprided", "dride", "strider", "stringiding", "sprides", "brided", "drip", "brid", "strice", "sprider", "brider"], "bS": ["bP", "pOS", "pS", "aaSP", "bSi", "pC", "BS", "aaP", " bPs", "aaS", "bIs", "basV", "aaSU", "pV", " bSU", "fS", "bV", "cP", "bootPS", "bPS", "bC", "fSi", "fSS", "bSP", "cS", "cSeries", "bSeries", " bC", "pSeries", "cOS", "bootIs", "pPS", " bSS", " bP", "rbP", "pPs", " bPS", "BSU", "rbS", " bSeries", "basSet", " bSP", "pIs", "bSU", "bOS", "fP", "rbSi", "BSP", " bSet", "bootS", "bootSi", "pP", "BP", " bV", "bSet", " bSi", "basPs", "bPs", " bOS", "pSet", " bIs", "cC", "basS", "pSi", "rbSS", "bSS"], "qp": ["qup", "Qpa", "qtp", "Qpn", "Qbp", "qtbp", "qupa", "qtpn", " qpre", "sqP", "qc", "quc", "eqc", " qc", "sqpre", "qpc", " qP", "qtP", "sqc", "eqpa", "qP", "QP", "eqp", " qbp", "Qp", "qpre", "Qc", "sqpn", "sqbp", "qpa", "Qpre", " qpn", "eqpc", "sqp", "Qpc", "qupc"], "h": ["hi", "hm", "host", "home", "hy", "rh", "r", "hs", "hh", "context", "ctx", "j", "gh", "sh", "hash", "y", "p", "ha", "ht", "han", "zh", "html", "m", "api", "w", "s", "hl", "help", "v", "oh", "uh", "conn", "ah", "g", "him", "c", "ph", "eh", "hr", "he", "self", "bh", "dh", "ch", "ih", "hd", "t", "hp", "history", "q", "f", "e", "http", "hw", "H"], "tc": ["tm", "cu", "dc", "cc", "ui", "loc", "sc", "ac", "fc", "rc", "ta", "cs", "ctx", "tt", "pb", "icc", "bb", "uca", "TC", "binary", "ci", "tmp", "ic", "ec", "xc", "tf", "config", "term", "acc", "ul", " bc", "beta", "lc", " TC", "pc", "ca", "css", "c", "ctrl", "nc", "gb", "margin", "abi", "mc", "toc", "tx", "t", "gam", " rc", "padding", "bc", "cas", "uc", " tcp", "index", "cus"]}}
{"project": "FFmpeg", "commit_id": "8c5cd1c9d33b4b287f85d42efb1aecfaee31de6c", "target": 1, "func": "static int decode_entropy_coded_image(WebPContext *s, enum ImageRole role,\n\n                                      int w, int h)\n\n{\n\n    ImageContext *img;\n\n    HuffReader *hg;\n\n    int i, j, ret, x, y, width;\n\n\n\n    img       = &s->image[role];\n\n    img->role = role;\n\n\n\n    if (!img->frame) {\n\n        img->frame = av_frame_alloc();\n\n        if (!img->frame)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    img->frame->format = AV_PIX_FMT_ARGB;\n\n    img->frame->width  = w;\n\n    img->frame->height = h;\n\n\n\n    if (role == IMAGE_ROLE_ARGB && !img->is_alpha_primary) {\n\n        ThreadFrame pt = { .f = img->frame };\n\n        ret = ff_thread_get_buffer(s->avctx, &pt, 0);\n\n    } else\n\n        ret = av_frame_get_buffer(img->frame, 1);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (get_bits1(&s->gb)) {\n\n        img->color_cache_bits = get_bits(&s->gb, 4);\n\n        if (img->color_cache_bits < 1 || img->color_cache_bits > 11) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"invalid color cache bits: %d\\n\",\n\n                   img->color_cache_bits);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        img->color_cache = av_mallocz_array(1 << img->color_cache_bits,\n\n                                            sizeof(*img->color_cache));\n\n        if (!img->color_cache)\n\n            return AVERROR(ENOMEM);\n\n    } else {\n\n        img->color_cache_bits = 0;\n\n    }\n\n\n\n    img->nb_huffman_groups = 1;\n\n    if (role == IMAGE_ROLE_ARGB && get_bits1(&s->gb)) {\n\n        ret = decode_entropy_image(s);\n\n        if (ret < 0)\n\n            return ret;\n\n        img->nb_huffman_groups = s->nb_huffman_groups;\n\n    }\n\n    img->huffman_groups = av_mallocz_array(img->nb_huffman_groups *\n\n                                           HUFFMAN_CODES_PER_META_CODE,\n\n                                           sizeof(*img->huffman_groups));\n\n    if (!img->huffman_groups)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < img->nb_huffman_groups; i++) {\n\n        hg = &img->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE];\n\n        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) {\n\n            int alphabet_size = alphabet_sizes[j];\n\n            if (!j && img->color_cache_bits > 0)\n\n                alphabet_size += 1 << img->color_cache_bits;\n\n\n\n            if (get_bits1(&s->gb)) {\n\n                read_huffman_code_simple(s, &hg[j]);\n\n            } else {\n\n                ret = read_huffman_code_normal(s, &hg[j], alphabet_size);\n\n                if (ret < 0)\n\n                    return ret;\n\n            }\n\n        }\n\n    }\n\n\n\n    width = img->frame->width;\n\n    if (role == IMAGE_ROLE_ARGB && s->reduced_width > 0)\n\n        width = s->reduced_width;\n\n\n\n    x = 0; y = 0;\n\n    while (y < img->frame->height) {\n\n        int v;\n\n\n\n        hg = get_huffman_group(s, img, x, y);\n\n        v = huff_reader_get_symbol(&hg[HUFF_IDX_GREEN], &s->gb);\n\n        if (v < NUM_LITERAL_CODES) {\n\n            /* literal pixel values */\n\n            uint8_t *p = GET_PIXEL(img->frame, x, y);\n\n            p[2] = v;\n\n            p[1] = huff_reader_get_symbol(&hg[HUFF_IDX_RED],   &s->gb);\n\n            p[3] = huff_reader_get_symbol(&hg[HUFF_IDX_BLUE],  &s->gb);\n\n            p[0] = huff_reader_get_symbol(&hg[HUFF_IDX_ALPHA], &s->gb);\n\n            if (img->color_cache_bits)\n\n                color_cache_put(img, AV_RB32(p));\n\n            x++;\n\n            if (x == width) {\n\n                x = 0;\n\n                y++;\n\n            }\n\n        } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) {\n\n            /* LZ77 backwards mapping */\n\n            int prefix_code, length, distance, ref_x, ref_y;\n\n\n\n            /* parse length and distance */\n\n            prefix_code = v - NUM_LITERAL_CODES;\n\n            if (prefix_code < 4) {\n\n                length = prefix_code + 1;\n\n            } else {\n\n                int extra_bits = (prefix_code - 2) >> 1;\n\n                int offset     = 2 + (prefix_code & 1) << extra_bits;\n\n                length = offset + get_bits(&s->gb, extra_bits) + 1;\n\n            }\n\n            prefix_code = huff_reader_get_symbol(&hg[HUFF_IDX_DIST], &s->gb);\n\n            if (prefix_code > 39) {\n\n                av_log(s->avctx, AV_LOG_ERROR,\n\n                       \"distance prefix code too large: %d\\n\", prefix_code);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (prefix_code < 4) {\n\n                distance = prefix_code + 1;\n\n            } else {\n\n                int extra_bits = prefix_code - 2 >> 1;\n\n                int offset     = 2 + (prefix_code & 1) << extra_bits;\n\n                distance = offset + get_bits(&s->gb, extra_bits) + 1;\n\n            }\n\n\n\n            /* find reference location */\n\n            if (distance <= NUM_SHORT_DISTANCES) {\n\n                int xi = lz77_distance_offsets[distance - 1][0];\n\n                int yi = lz77_distance_offsets[distance - 1][1];\n\n                distance = FFMAX(1, xi + yi * width);\n\n            } else {\n\n                distance -= NUM_SHORT_DISTANCES;\n\n            }\n\n            ref_x = x;\n\n            ref_y = y;\n\n            if (distance <= x) {\n\n                ref_x -= distance;\n\n                distance = 0;\n\n            } else {\n\n                ref_x = 0;\n\n                distance -= x;\n\n            }\n\n            while (distance >= width) {\n\n                ref_y--;\n\n                distance -= width;\n\n            }\n\n            if (distance > 0) {\n\n                ref_x = width - distance;\n\n                ref_y--;\n\n            }\n\n            ref_x = FFMAX(0, ref_x);\n\n            ref_y = FFMAX(0, ref_y);\n\n\n\n            /* copy pixels\n\n             * source and dest regions can overlap and wrap lines, so just\n\n             * copy per-pixel */\n\n            for (i = 0; i < length; i++) {\n\n                uint8_t *p_ref = GET_PIXEL(img->frame, ref_x, ref_y);\n\n                uint8_t *p     = GET_PIXEL(img->frame,     x,     y);\n\n\n\n                AV_COPY32(p, p_ref);\n\n                if (img->color_cache_bits)\n\n                    color_cache_put(img, AV_RB32(p));\n\n                x++;\n\n                ref_x++;\n\n                if (x == width) {\n\n                    x = 0;\n\n                    y++;\n\n                }\n\n                if (ref_x == width) {\n\n                    ref_x = 0;\n\n                    ref_y++;\n\n                }\n\n                if (y == img->frame->height || ref_y == img->frame->height)\n\n                    break;\n\n            }\n\n        } else {\n\n            /* read from color cache */\n\n            uint8_t *p = GET_PIXEL(img->frame, x, y);\n\n            int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES);\n\n\n\n            if (!img->color_cache_bits) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"color cache not found\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (cache_idx >= 1 << img->color_cache_bits) {\n\n                av_log(s->avctx, AV_LOG_ERROR,\n\n                       \"color cache index out-of-bounds\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            AV_WB32(p, img->color_cache[cache_idx]);\n\n            x++;\n\n            if (x == width) {\n\n                x = 0;\n\n                y++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4029, "substitutes": {"s": ["sec", "conf", "sim", "d", "ions", "ps", "sp", "sb", "sym", "os", "f", "this", "js", "comments", "l", "si", "is", "qs", "ins", "details", "se", "stats", "ses", "site", "args", "b", "sg", "ops", "sup", "S", "r", "sc", "cs", "ctx", "ssl", "sh", "m", "sq", "session", "service", "g", "spec", "ks", "es", "gs", "sports", "t", "aws", "ss", "e", "sl", "ls", "http", "ds", "xs", "request", "fs", "su", "sets", "ts", "ns", "src", "input", "services", "a", "sys", "c", "rs", "self", "its"], "role": [" Role", "val", "rb", "family", "rr", "value", "r", "scale", "attr", "ring", "profile", "function", "uri", "tool", "le", "Role", "key", "alias", "rage", "node", "module", "acl", "proxy", "name", "RO", "id", "ro", "ride", "force", "route", "theme", "definition", "dim", "mode", "slice", "label", "frame", "repl", "type", "file", "service", "member", "slot", "rg", "policy", "rol", "url", "scope", "gb", "balance", "image", "rot", "style", "rel", "state", "ole", "rl", "align", "range", "resource", "username", "region", "tag", "rule"], "w": ["wa", "wx", "wd", "sw", "l", "n", "height", "wh", "d", "m", "win", "z", "we", "a", "wt", "g", "fw", "c", "W", "t", "max", "b", "f", "hw", "u", "q", "ow", "wb", "ew", " W"], "h": ["hi", "hm", "rh", "r", "l", "n", "height", "sh", "gh", "o", "ha", "ht", "m", "z", "k", "oh", "th", "ah", "g", "c", "ph", "bh", "ch", "ih", "hd", "t", "max", "b", "q", "u", "f", "e", "H"], "img": ["md", "rb", "agi", "att", "enc", "num", "aff", "lib", "ht", "ib", "d", "tf", "icon", "fm", "orig", "feat", "og", "ie", "output", "aug", "info", "ch", "image", "cb", "ih", "f", "inc", "emb", "fg", "br", "inf", "inst", "imp", "ig", "exec", "impl", "bg", "html", "images", "config", "org", "iq", "app", "eng", "gd", "embed", "style", "u", "bl", "jpg", "ev", "pg", "ahi", "com", "mp", "utm", "dr", "m", "obj", "g", "str", "ng", "om", "amp", "fig", "cm", "dom", "im", "cf", "def", "rc", "lim", "gif", "src", "iframe", "input", "af", "imag", "api", "fb", "ext", "fw", "c", "hr", "np", "gb", "util", "feature", "aut", "big", "tif"], "hg": [" hgs", "hgs", "pbg", "pG", "hbg", "rhG", "pgs", " hG", "rhbg", "rhgs", "rhg", " hbg", "pg", "hG"], "i": ["io", "r", "l", "is", "n", "ci", "d", "m", "z", "I", "k", "ii", "in", "ix", "image", "b", "f", "ip", "e", "index"], "j": ["r", "l", "n", "o", "d", "m", "aj", "obj", "z", "adj", "ja", "k", "len", "pos", "g", "sp", "ji", "jp", "t", "b", "q", "op", "js", "J"], "ret": ["rb", "part", "att", "num", "resp", "alt", "opt", "ref", "usr", "len", "count", "lit", "ut", "feat", "reply", "info", "arg", "post", "bit", "let", "res", "rev", "et", "format", "success", "rets", "data", "nt", "url", "Ret", "al", "ft", "flag", "active", "code", "mem", "obj", "rf", "status", "str", "wrap", "fun", "reg", "out", "last", "desc", "cat", "bf", "val", "fail", "back", "def", "rc", "rt", "pt", "RET", "det", "gt", "job", "id", "no", "end", "ext", "mt", "result", "re", "pass", "en", "art"], "x": ["wa", "X", "l", "ex", "n", "pixel", "rx", "m", "z", "win", "px", "xy", "c", "ix", "image", "col", "dx", "fx", "f"], "y": ["l", "n", "height", "lon", "o", "d", "m", "vy", "z", "Y", "dy", "k", "ii", "py", "type", "g", "c", "col", "t", "b", "f", "size", "e"]}}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "void ff_mspel_motion(MpegEncContext *s,\n\n                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n\n                               uint8_t **ref_picture, op_pixels_func (*pix_op)[4],\n\n                               int motion_x, int motion_y, int h)\n\n{\n\n    Wmv2Context * const w= (Wmv2Context*)s;\n\n    uint8_t *ptr;\n\n    int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;\n\n    int emu=0;\n\n\n\n    dxy = ((motion_y & 1) << 1) | (motion_x & 1);\n\n    dxy = 2*dxy + w->hshift;\n\n    src_x = s->mb_x * 16 + (motion_x >> 1);\n\n    src_y = s->mb_y * 16 + (motion_y >> 1);\n\n\n\n    /* WARNING: do no forget half pels */\n\n    v_edge_pos = s->v_edge_pos;\n\n    src_x = av_clip(src_x, -16, s->width);\n\n    src_y = av_clip(src_y, -16, s->height);\n\n\n\n    if(src_x<=-16 || src_x >= s->width)\n\n        dxy &= ~3;\n\n    if(src_y<=-16 || src_y >= s->height)\n\n        dxy &= ~4;\n\n\n\n    linesize   = s->linesize;\n\n    uvlinesize = s->uvlinesize;\n\n    ptr = ref_picture[0] + (src_y * linesize) + src_x;\n\n\n\n        if(src_x<1 || src_y<1 || src_x + 17  >= s->h_edge_pos\n\n                              || src_y + h+1 >= v_edge_pos){\n\n            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr - 1 - s->linesize, s->linesize, 19, 19,\n\n                             src_x-1, src_y-1, s->h_edge_pos, s->v_edge_pos);\n\n            ptr= s->edge_emu_buffer + 1 + s->linesize;\n\n            emu=1;\n\n        }\n\n\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y             , ptr             , linesize);\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8           , ptr+8           , linesize);\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y  +8*linesize, ptr  +8*linesize, linesize);\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8+8*linesize, ptr+8+8*linesize, linesize);\n\n\n\n    if(s->flags&CODEC_FLAG_GRAY) return;\n\n\n\n    if (s->out_format == FMT_H263) {\n\n        dxy = 0;\n\n        if ((motion_x & 3) != 0)\n\n            dxy |= 1;\n\n        if ((motion_y & 3) != 0)\n\n            dxy |= 2;\n\n        mx = motion_x >> 2;\n\n        my = motion_y >> 2;\n\n    } else {\n\n        mx = motion_x / 2;\n\n        my = motion_y / 2;\n\n        dxy = ((my & 1) << 1) | (mx & 1);\n\n        mx >>= 1;\n\n        my >>= 1;\n\n    }\n\n\n\n    src_x = s->mb_x * 8 + mx;\n\n    src_y = s->mb_y * 8 + my;\n\n    src_x = av_clip(src_x, -8, s->width >> 1);\n\n    if (src_x == (s->width >> 1))\n\n        dxy &= ~1;\n\n    src_y = av_clip(src_y, -8, s->height >> 1);\n\n    if (src_y == (s->height >> 1))\n\n        dxy &= ~2;\n\n    offset = (src_y * uvlinesize) + src_x;\n\n    ptr = ref_picture[1] + offset;\n\n    if(emu){\n\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,\n\n                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n        ptr= s->edge_emu_buffer;\n\n    }\n\n    pix_op[1][dxy](dest_cb, ptr, uvlinesize, h >> 1);\n\n\n\n    ptr = ref_picture[2] + offset;\n\n    if(emu){\n\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,\n\n                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n        ptr= s->edge_emu_buffer;\n\n    }\n\n    pix_op[1][dxy](dest_cr, ptr, uvlinesize, h >> 1);\n\n}\n", "idx": 4041, "substitutes": {"s": ["i", "private", "uns", "sec", "conf", "d", "ions", "an", "v", "ps", "lines", "sb", "sym", "os", "f", "as", "set", "js", "comments", "sv", "l", "sites", "si", "is", "qs", "o", "y", "p", "less", "ins", "se", "ses", "site", "current", "b", "sg", "plugins", "sync", "S", "uses", "r", "sc", "settings", "hs", "cs", "ssl", "south", "als", "new", "m", "sq", "session", "service", "g", "your", "us", "spec", "ks", "es", "gs", "t", "aws", "ss", "e", "sl", "ls", "http", "ds", "xs", "fs", "su", "sets", "ts", "ns", "n", "ims", "ans", "services", "sys", "sf", "c", "rs", "self", "ges", "its", "tests", "client"], "dest_y": ["dest_sy", "dest_py", "dest_x", "src_sy", "src_py"], "dest_cb": ["destOcb", "dest_z", "source_cm", "destOmag", "destOcm", "source_cb", "dest_cm", "source_mag", "source_z", "dest_mag", "destOz"], "dest_cr": ["dest__rx", "dest_z", "dest__cb", " dest_rx", "dest__cr", "dest_rx", " dest_z", "dest__z"], "ref_picture": ["refvalimage", "refdbresolution", "reflogaudio", "refvalpicture", " ref_audio", "ref_uri", " ref_uri", "ref_pic", "refdbpicture", "reference2resolution", "ref_resolution", "refvalaudio", "reference_resolution", "reflogimage", "ref2picture", "refloguri", "reflogpicture", "refvaluri", "ref_audio", "refdbpic", "reference2pic", "reference_picture", "ref2resolution", "reference2picture", "ref2pic", "ref_image", " ref_image", "reference_pic"], "pix_op": ["pixel_op", "pix64oper", "pix_oper", "pixel_map", "pixel_oper", "pix64ops", "pix64map", "pix_ops", "pix_map", "pix64op", "pixel_ops"], "motion_x": ["motion_on", "motion2xs", "motion01y", "motion_w", "move_on", "motion01dx", "motion00xs", "motion01x", "move_z", "motionIdx", "motion_height", "motionIdy", "move_height", "motionIdheight", "move_y", "move_w", " motion_xs", "motion2dx", "motion_dx", "motion_xs", "motion2x", "motionIdon", "move_x", " motion2xs", " motion2x", "motion01xs", " motion2y", "motion00x", " motion_dx", "motion2y", "motion00dx", " motion2dx", "motion_z", "motion00y"], "motion_y": [" motion2type", "camera64y", " motion_yt", "motion00yt", "motion__x", "motion_vy", "motion01y", "motion00type", "camera_ey", "motion_yd", "loss_yd", "motion01ey", "motion__y", "motion64ey", "camera64ry", " motion_type", "motion64ry", "loss_yt", "motion_yt", "motion_ry", "motion64vy", "motion2type", "loss_x", "motion2yt", "motion2x", "motion_ey", "camera64ey", " motion2yt", "camera64vy", " motion2x", "motion__type", "camera_vy", "motion01vy", "camera_y", " motion2y", "motion00x", "motion64y", "motion01ry", "motion2y", "motion_type", "camera_ry", "motion__yt", "loss_y", "motion00y"], "h": ["hi", "hm", "i", "rh", "r", "l", "hs", "hop", "hh", "n", "gh", "sh", "y", "p", "ht", "ha", "m", "z", "oh", "v", "a", "uh", "c", "ph", "bh", "ch", "ih", "hp", "b", "q", "f", "u", "e", "x", "hw", "H"], "w": [" W", "kw", "wa", "wx", "sw", "r", "ww", "l", "ess", "n", "y", "wh", "p", "d", "m", "z", "wp", "rw", "iw", "we", "v", "g", "wt", "window", "work", "fw", "c", "W", "wcs", "b", "q", "f", "u", "ow", "wb", "nw", "x", "wl", "hw"], "ptr": ["Ptr", "pri", "i", "hei", "tty", "loc", "inst", "attr", "shift", "req", "r", "rc", "tr", "prot", "code", "cmp", "j", "sh", "fi", "grad", "pt", "trace", "p", "alloc", "tmp", "src", "fp", "dr", "buffer", "peer", "buf", "rog", "len", "slice", "pad", "pos", "ext", "dest", "fd", "prop", "sp", "length", "port", "td", "pair", "ace", "inter", "push", "rob", "address", "addr", "ctr", "pull", "pointer", "fe"], "dxy": ["dtxy", "Dwy", " dphi", "hpx", "dgb", " dzip", "hxy", " dcoord", "mxy", " dpy", "dtpx", "Dummy", "sdphy", "dphy", "Dxy", "vgb", " dphy", "dtdy", "mwy", "mcoord", "vwy", "vxy", "nquad", "Dpy", "dquad", " dquad", "dwy", " dpx", "hwy", "idpy", " doxy", "ddy", "bwy", "bquad", "dphi", " ddy", "iddy", "Dcoord", "Dquad", "mphi", "dzip", " dwy", "bpx", "doxy", " dummy", "bxy", "dummy", "Dzip", "dhoxy", "vummy", "sdwy", "nxy", "dpy", "sdoxy", "dpx", "npy", "dhphy", "sdxy", "Dgb", "dhwy", "idpx", "Dphi", "dtpy", "dhxy", " dgb", "idxy", "dcoord", "nzip", "hquad"], "offset": ["i", "shift", "loc", "hop", "padding", "o", "p", "location", "area", "aw", "mm", "off", "pos", "foo", "oe", "position", "adjust", "mt", "origin", "np", "image", "meta", "align", "ip", "addr"], "mx": ["md", "host", "wx", "ms", "loc", "wave", "mp", "hop", "hh", "pm", "mag", "axis", "rx", "m", "sq", "mi", "mr", "xp", "mm", "px", "cp", "ap", "nr", "np", "mn", "tx", "lr", "cycle", "cm"], "my": ["md", "wx", "ms", "nm", "loc", "pm", "mos", "nn", "mo", "sq", "mi", "mic", "mr", "mm", "py", "micro", "mid", "ym", "me", "np", "My", "gy", "mn", "ng", "cl", "mph", "ni", "yy"], "src_x": [" src_X", "src_ya", "srcacex", " src_width", "src_width", "src00full", "src67y", " src_height", " src_ya", "src2w", "source_y", "srcacheight", "src_z", " src_w", " src_z", " src_xs", " src_xy", "src2x", " src_yx", "source_X", "src_wx", "source_w", "src6x", "srcacwidth", "src_yx", "src6xs", "src_image", "src2y", "src00x", " src_full", "src67xs", "src00y", "srcacx", "src_xy", "src_full", "source_x", "src00z", "src_X", "src_xs", "src_w", "src67x", "src_ex", " src_ex", "src6y", "src6yx", " src_wx", " src_image", "src67yx", "src_height", "src2X"], "src_y": ["src___z", "obl_yi", "src_ya", "dest_z", "srcPx", "rc2y", "src2ey", " src_ey", " src_height", " src_ya", "src_zy", "srcJyo", "obl_y", "srcPdy", "src___yi", "rc_ey", "srcPz", "src_z", "src_ry", "src__ry", "src___y", " src_z", "rc_yo", "dest_ys", "src__y", "src_ey", "src_yo", "dest_x", "src_iy", "rc_y", "src_vy", "src2x", " src_zy", "srcJy", "rc2x", "src__ey", "src___iy", "srcJx", "srcJry", " src_ny", "src__ya", "rc2ey", "src__yi", "rc_ya", "rc_x", "srcPy", " src_dy", "srcJyi", "rc_vy", "src_dy", "src_ny", "src2y", "srcJey", "src___x", "obl_ey", "rc2ya", " src_iy", "src___ya", "src__ny", " src_yi", "srcJya", "obl_ry", "src2ya", "src_height", "src_ys", "src___height", "src__zy", "src_yi"], "v_edge_pos": ["v_nw_pose", "v_edge__position", "v_ge_off", "v_edge__pose", "v_ge__position", "v_issue_res", "v_edgeingpos", "v_edge_Pos", "v_edge\u00b7type", "v_edge__res", "v_issue_Pos", "v_issue_position", "v_nw_pos", "v_line_type", "v_edge_res", "v_edge_abs", "v_nw_len", "v_edge__port", "v_edge___len", "v_edge_type", "v_ge__port", "v_ge_port", "v_edge___pose", "v_edge\u00b7pos", "v_issue_pos", "v_edgeingcos", "v_edgexport", "v_line_po", "v_edge_len", "v_nw___Pos", "v_pe_cos", "v_line_pos", "v_edge_position", "v_edge_pose", "v_edge_cos", "v_edgelyabs", "v_edge___Pos", "v_edgeingabs", "v_nw___pose", "v_edgelycos", "v_edgelypos", "v_edge__off", "v_edgexposition", "v_ge_position", "v_edgelyposition", "v_edge__pos", "v_nw_Pos", "v_edgexpos", "v_edge_port", "v_pe_position", "v_ge__pos", "v_line_position", "v_pe_abs", "v_ge__off", "v_pe_pos", "v_edge_off", "v_edge\u00b7position", "v_edgeingposition", "v_ge_pos", "v_nw___pos", "v_edge__len", "v_edgexoff", "v_edge___pos", "v_edge\u00b7po", "v_nw___len", "v_edge_po", "v_edge__Pos"], "linesize": ["ipsizing", "pagesization", "worksizing", "postsized", " linessize", "linksizer", "ipsiz", "breaksization", "filesize", "opensized", "worksizer", "postsiz", "linsized", "filesizer", "linsiz", "filesiz", "worksize", "planesiz", "pagesizer", "linsIZE", "planesizing", "linksize", " linesized", "linesiz", " linesizer", "breaksiz", "linksizing", "linsizing", "worksiz", " linesIZE", "cssize", "planesize", "breaksize", "opensization", "postsize", " linesization", "pointsize", "linesizer", "csize", "linsization", "linesized", "planesized", "breaksizer", "pointsiz", "pagesize", "linesizing", "opensiz", "linsize", " linesiz", "csiz", "filesIZE", "linsizer", "linessize", "ipssize", "pointsizing", "ipsize", "postsization", " linesizing", "opensize", "linesization", "csization", "linssize", "linksiz", "linesIZE", "pagesiz", "pointsized"], "uvlinesize": ["novpagessize", "novlinesize", "upplinsize", "upplinesizes", "uvlinsizer", "uvvalsiz", "upplinsizable", "cvlinesize", "uvlinesizes", "uvlinsize", "uvstringsizable", "upplinesizable", "upplinsizes", "uvstringsiz", "uvlineize", "uvlinsizable", "uvonesize", "novlinesizer", "uvpagessize", "novpagesize", "uvlinesizable", "uvlinessize", "cvlinesiz", "upplinesize", "uvlinesiz", "uvonesizer", "novlinessize", "uvonessize", "uvlineizes", "novpagesizes", "uvvalsizable", "upplinesiz", "uvstringsizes", "uvlinesizer", "uvstringsize", "cvlinesizer", "uvlineiz", "uvpagesizer", "uvonesiz", "uvvalsizes", "cvlinessize", "novpagesizer", "uvlinsiz", "uvpagesizes", "novlinesizes", "uvpagesize", "uvlineizer", "uvlinsizes", "upplinsiz", "uvlinssize", "uvvalsize"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int svq1_encode_plane(SVQ1Context *s, int plane,\n\n                             unsigned char *src_plane,\n\n                             unsigned char *ref_plane,\n\n                             unsigned char *decoded_plane,\n\n                             int width, int height, int src_stride, int stride)\n\n{\n\n    const AVFrame *f = s->avctx->coded_frame;\n\n    int x, y;\n\n    int i;\n\n    int block_width, block_height;\n\n    int level;\n\n    int threshold[6];\n\n    uint8_t *src     = s->scratchbuf + stride * 16;\n\n    const int lambda = (f->quality * f->quality) >>\n\n                       (2 * FF_LAMBDA_SHIFT);\n\n\n\n    /* figure out the acceptable level thresholds in advance */\n\n    threshold[5] = QUALITY_THRESHOLD;\n\n    for (level = 4; level >= 0; level--)\n\n        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;\n\n\n\n    block_width  = (width  + 15) / 16;\n\n    block_height = (height + 15) / 16;\n\n\n\n    if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n        s->m.avctx                         = s->avctx;\n\n        s->m.current_picture_ptr           = &s->m.current_picture;\n\n        s->m.last_picture_ptr              = &s->m.last_picture;\n\n        s->m.last_picture.f.data[0]        = ref_plane;\n\n        s->m.linesize                      =\n\n        s->m.last_picture.f.linesize[0]    =\n\n        s->m.new_picture.f.linesize[0]     =\n\n        s->m.current_picture.f.linesize[0] = stride;\n\n        s->m.width                         = width;\n\n        s->m.height                        = height;\n\n        s->m.mb_width                      = block_width;\n\n        s->m.mb_height                     = block_height;\n\n        s->m.mb_stride                     = s->m.mb_width + 1;\n\n        s->m.b8_stride                     = 2 * s->m.mb_width + 1;\n\n        s->m.f_code                        = 1;\n\n        s->m.pict_type                     = f->pict_type;\n\n        s->m.me_method                     = s->avctx->me_method;\n\n        s->m.me.scene_change_score         = 0;\n\n        s->m.flags                         = s->avctx->flags;\n\n        // s->m.out_format                    = FMT_H263;\n\n        // s->m.unrestricted_mv               = 1;\n\n        s->m.lambda                        = f->quality;\n\n        s->m.qscale                        = s->m.lambda * 139 +\n\n                                             FF_LAMBDA_SCALE * 64 >>\n\n                                             FF_LAMBDA_SHIFT + 7;\n\n        s->m.lambda2                       = s->m.lambda * s->m.lambda +\n\n                                             FF_LAMBDA_SCALE / 2 >>\n\n                                             FF_LAMBDA_SHIFT;\n\n\n\n        if (!s->motion_val8[plane]) {\n\n            s->motion_val8[plane]  = av_mallocz((s->m.b8_stride *\n\n                                                 block_height * 2 + 2) *\n\n                                                2 * sizeof(int16_t));\n\n            s->motion_val16[plane] = av_mallocz((s->m.mb_stride *\n\n                                                 (block_height + 2) + 1) *\n\n                                                2 * sizeof(int16_t));\n\n        }\n\n\n\n        s->m.mb_type = s->mb_type;\n\n\n\n        // dummies, to avoid segfaults\n\n        s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;\n\n        s->m.current_picture.mb_var    = (uint16_t *)s->dummy;\n\n        s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;\n\n        s->m.current_picture.mb_type = s->dummy;\n\n\n\n        s->m.current_picture.motion_val[0]   = s->motion_val8[plane] + 2;\n\n        s->m.p_mv_table                      = s->motion_val16[plane] +\n\n                                               s->m.mb_stride + 1;\n\n        s->m.dsp                             = s->dsp; // move\n\n        ff_init_me(&s->m);\n\n\n\n        s->m.me.dia_size      = s->avctx->dia_size;\n\n        s->m.first_slice_line = 1;\n\n        for (y = 0; y < block_height; y++) {\n\n            s->m.new_picture.f.data[0] = src - y * 16 * stride; // ugly\n\n            s->m.mb_y                  = y;\n\n\n\n            for (i = 0; i < 16 && i + 16 * y < height; i++) {\n\n                memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],\n\n                       width);\n\n                for (x = width; x < 16 * block_width; x++)\n\n                    src[i * stride + x] = src[i * stride + x - 1];\n\n            }\n\n            for (; i < 16 && i + 16 * y < 16 * block_height; i++)\n\n                memcpy(&src[i * stride], &src[(i - 1) * stride],\n\n                       16 * block_width);\n\n\n\n            for (x = 0; x < block_width; x++) {\n\n                s->m.mb_x = x;\n\n                ff_init_block_index(&s->m);\n\n                ff_update_block_index(&s->m);\n\n\n\n                ff_estimate_p_frame_motion(&s->m, x, y);\n\n            }\n\n            s->m.first_slice_line = 0;\n\n        }\n\n\n\n        ff_fix_long_p_mvs(&s->m);\n\n        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code,\n\n                        CANDIDATE_MB_TYPE_INTER, 0);\n\n    }\n\n\n\n    s->m.first_slice_line = 1;\n\n    for (y = 0; y < block_height; y++) {\n\n        for (i = 0; i < 16 && i + 16 * y < height; i++) {\n\n            memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],\n\n                   width);\n\n            for (x = width; x < 16 * block_width; x++)\n\n                src[i * stride + x] = src[i * stride + x - 1];\n\n        }\n\n        for (; i < 16 && i + 16 * y < 16 * block_height; i++)\n\n            memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);\n\n\n\n        s->m.mb_y = y;\n\n        for (x = 0; x < block_width; x++) {\n\n            uint8_t reorder_buffer[3][6][7 * 32];\n\n            int count[3][6];\n\n            int offset       = y * 16 * stride + x * 16;\n\n            uint8_t *decoded = decoded_plane + offset;\n\n            uint8_t *ref     = ref_plane + offset;\n\n            int score[4]     = { 0, 0, 0, 0 }, best;\n\n            uint8_t *temp    = s->scratchbuf;\n\n\n\n            if (s->pb.buf_end - s->pb.buf -\n\n                (put_bits_count(&s->pb) >> 3) < 3000) { // FIXME: check size\n\n                av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n                return -1;\n\n            }\n\n\n\n            s->m.mb_x = x;\n\n            ff_init_block_index(&s->m);\n\n            ff_update_block_index(&s->m);\n\n\n\n            if (f->pict_type == AV_PICTURE_TYPE_I ||\n\n                (s->m.mb_type[x + y * s->m.mb_stride] &\n\n                 CANDIDATE_MB_TYPE_INTRA)) {\n\n                for (i = 0; i < 6; i++)\n\n                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i],\n\n                                  7 * 32);\n\n                if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n                    score[0] = vlc[1] * lambda;\n\n                }\n\n                score[0] += encode_block(s, src + 16 * x, NULL, temp, stride,\n\n                                         5, 64, lambda, 1);\n\n                for (i = 0; i < 6; i++) {\n\n                    count[0][i] = put_bits_count(&s->reorder_pb[i]);\n\n                    flush_put_bits(&s->reorder_pb[i]);\n\n                }\n\n            } else\n\n                score[0] = INT_MAX;\n\n\n\n            best = 0;\n\n\n\n            if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];\n\n                int mx, my, pred_x, pred_y, dxy;\n\n                int16_t *motion_ptr;\n\n\n\n                motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);\n\n                if (s->m.mb_type[x + y * s->m.mb_stride] &\n\n                    CANDIDATE_MB_TYPE_INTER) {\n\n                    for (i = 0; i < 6; i++)\n\n                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i],\n\n                                      7 * 32);\n\n\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n\n\n                    s->m.pb = s->reorder_pb[5];\n\n                    mx      = motion_ptr[0];\n\n                    my      = motion_ptr[1];\n\n                    assert(mx     >= -32 && mx     <= 31);\n\n                    assert(my     >= -32 && my     <= 31);\n\n                    assert(pred_x >= -32 && pred_x <= 31);\n\n                    assert(pred_y >= -32 && pred_y <= 31);\n\n                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);\n\n                    ff_h263_encode_motion(&s->m, my - pred_y, 1);\n\n                    s->reorder_pb[5] = s->m.pb;\n\n                    score[1]        += lambda * put_bits_count(&s->reorder_pb[5]);\n\n\n\n                    dxy = (mx & 1) + 2 * (my & 1);\n\n\n\n                    s->hdsp.put_pixels_tab[0][dxy](temp + 16,\n\n                                                   ref + (mx >> 1) +\n\n                                                   stride * (my >> 1),\n\n                                                   stride, 16);\n\n\n\n                    score[1] += encode_block(s, src + 16 * x, temp + 16,\n\n                                             decoded, stride, 5, 64, lambda, 0);\n\n                    best      = score[1] <= score[0];\n\n\n\n                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];\n\n                    score[2]  = s->dsp.sse[0](NULL, src + 16 * x, ref,\n\n                                              stride, 16);\n\n                    score[2] += vlc[1] * lambda;\n\n                    if (score[2] < score[best] && mx == 0 && my == 0) {\n\n                        best = 2;\n\n                        s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);\n\n                        for (i = 0; i < 6; i++)\n\n                            count[2][i] = 0;\n\n                        put_bits(&s->pb, vlc[1], vlc[0]);\n\n                    }\n\n                }\n\n\n\n                if (best == 1) {\n\n                    for (i = 0; i < 6; i++) {\n\n                        count[1][i] = put_bits_count(&s->reorder_pb[i]);\n\n                        flush_put_bits(&s->reorder_pb[i]);\n\n                    }\n\n                } else {\n\n                    motion_ptr[0]                      =\n\n                    motion_ptr[1]                      =\n\n                    motion_ptr[2]                      =\n\n                    motion_ptr[3]                      =\n\n                    motion_ptr[0 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[1 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[2 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[3 + 2 * s->m.b8_stride] = 0;\n\n                }\n\n            }\n\n\n\n            s->rd_total += score[best];\n\n\n\n            for (i = 5; i >= 0; i--)\n\n                avpriv_copy_bits(&s->pb, reorder_buffer[best][i],\n\n                                 count[best][i]);\n\n            if (best == 0)\n\n                s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);\n\n        }\n\n        s->m.first_slice_line = 0;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4062, "substitutes": {"s": ["conf", "sim", "d", "sum", "sa", "v", "states", "ps", "lines", "secondary", "sb", "sym", "os", "as", "parts", "strings", "this", "js", "res", "sv", "l", "si", "is", "qs", "o", "p", "ins", "ses", "site", "b", "sg", "u", "ops", "sup", "sync", "h", "S", "r", "sc", "cs", "context", "ssl", "south", "m", "sq", "session", "status", "w", "service", "g", "us", "spec", "ks", "es", "gs", "t", "native", "ss", "e", "sl", "ls", "ds", "fs", "ms", "su", "sets", "ts", "ns", "n", "ans", "services", "a", "sys", "sf", "c", "rs", "in", "its", "client"], "plane": ["line", "plan", "scale", "card", "code", "core", "axis", "fl", "clip", "limit", "pe", "qa", "dim", "slice", "mode", "flat", "port", "plate", "ide", "layer", "flow", "weight", "image", "planes", "ane", "lane", "path", "source"], "src_plane": ["src_planes", "srcwplanes", "srcwplane", "srcwlayer", "ref_lane", "ref_layer", "src_lane", "srcwlane", "src_layer", "ref_planes"], "ref_plane": ["refacplane", "referenceacplane", "refingline", "ref_channel", "reference_plane", "refacsea", "reference_line", "refaclane", " ref_pose", "refalchannel", "ref_sea", "reference_sea", "refingsea", "refingpose", "refacline", "ref_line", " ref_channel", "referenceacline", "refalsea", "refingchannel", "refalplane", "refinglane", "refalpose", "reference_lane", "refingplane", "ref_lane", "referenceacsea", " ref_sea", "ref_pose", "referenceaclane"], "decoded_plane": ["decode_source", "decoded_screen", "decodedegerlane", "decode_screen", "decodedegersource", "decode_lane", "decoded_source", "decodedegerscreen", "decode_plane", "decodedensource", "decoded_lane", "decodedegerplane", "decodedenplane", "decodedenlane", "decodedenscreen"], "height": ["hi", "high", "media", "times", "rh", "def", "padding", "east", "density", " heights", "layout", "ht", "gh", "gravity", "bottom", "stroke", "location", "huge", "deep", "crop", "hang", "rows", "memory", "resolution", "definition", "inches", "dim", "capacity", "above", "build", "ashes", "distance", "missing", "window", "gain", "length", "shape", "direction", "rank", "depth", "tight", "style", "history", "ty", "Height", "hold", "size", "pull", "thin", "h", "volume", "holes"], "src_stride": ["src_frision", "src_bride", "src_frided", "src_strision", "src_fride", "src_brision", "src_brider", "src_strided", "src_strider", "src_drider", "src_dride", "src_drided", "src_brided", "src_frider", "src_drision"], "stride": ["drider", "drision", "shrided", " strided", "Strided", " strision", "tride", " strandi", "drided", "Stride", "trision", "strided", "drride", "trided", "shrider", "shride", "trandi", "trider", "Strride", "shrision", "dride", "strider", "strandi", "drandi", " strride", "Strision", "strision", "strride"], "f": ["field", "fr", "bf", "feed", "inf", "fs", "part", "fac", "form", "cf", "l", "def", "fc", "fi", "j", "conf", "n", "aff", "o", "p", "fp", "fl", "fo", "d", "m", "config", "tf", "af", "rf", "api", "w", "fb", "df", "fen", "full", "v", "of", "frame", "file", "g", "data", "sf", "c", "self", "fa", "flow", "info", "lf", "image", "fx", "t", "feature", "q", "b", "u", "e", "page", "F", "fe", "h"], "x": ["view", "base", "X", "l", "ex", "n", "pixel", "o", "p", "d", "m", "z", "w", "px", "pos", "xy", "c", "ix", "image", "dx", "ax", "e", "h", "index"], "y": ["cy", "j", "n", "o", "p", "d", "m", "vy", "z", "w", "Y", "dy", "pos", "type", "ym", "row", "c", "col", "size", "e", "h", "index"], "i": ["line", "io", "l", "j", "n", "uri", "unit", "p", "ci", "qi", "d", "m", "z", "limit", "id", "ii", "pos", "type", "c", "in", "di", "channel", "pi", "I", "h", "index"], "block_width": ["layout_width", "block67width", "block_wen", "block48length", "layout_size", "ref48lon", "block48size", "block_income", "block_sw", "layout48width", "block\u00b7width", "block\u00b7maximum", "layout_sw", " block_size", "block_lon", "ref_wen", "block48wen", "block\u00b7size", "block\u00b7income", " block_maximum", "block48width", "layout48sw", "block48lon", "ref48wen", " block_income", "block_maximum", "layout_length", "ref48width", "ref_lon", "block67lon", "block48sw", "block_length", "layout48size", "block_size", "block67wen", "ref_width", "layout48length"], "block_height": ["plugin67health", "block_right", "layout_height", "plugin_resolution", "plugin_health", "layout_width", "plugin_height", "plugin67resolution", "block_thin", "blockingresolution", "block67health", "block67layout", "blockingheight", "block48height", "block00width", "layout_thin", "block00thin", "block_resolution", "block48width", "blockinglayout", "block00height", "plugin67height", "layout_right", "block_health", "plugin_layout", "block67height", "block48right", " block_right", "plugin67layout", "block67resolution", "block00right", "block_layout", "blockinghealth"], "level": ["model", "line", "loop", "pri", "val", "lock", "all", "value", "way", "scale", "VEL", "l", "syn", "code", "unit", "where", "Level", "n", "letter", "key", "other", "d", "thread", "limit", "source", "stage", "id", "mode", "full", "type", "file", "list", "coll", "parent", "day", "length", "server", "quality", "round", "weight", "layer", "depth", "local", "channel", "style", "col", "lo", "q", "inc", "levels", "cl", "vel", "child", "pass", "condition", "wl", "lvl", "lc", "step", "index", "clean"], "threshold": ["ethrail", "rethresh", "thresh", "THreshold", "tharail", "sthumbnail", "ethreshold", "THresh", "shreshold", "thareshold", "tharift", "Thresh", "sthrust", "thensor", "thrail", "shumbnail", "thcondition", "ethensor", "ethresh", "shresh", " thresh", "sthresh", "rethrust", "rethrift", " thrail", "ithcondition", "tharesh", "Thcondition", "Thrust", "THrift", "Threshold", "sthreshold", "rethreshold", "THensor", "ithumbnail", "thumbnail", "thrift", "shcondition", "THrail", "thrust", "ithreshold", "ithresh", "Thumbnail", "rethumbnail", "rethrail", " thensor"], "src": ["fn", "rb", "loc", "sc", "secure", "rc", "sub", "img", "ctx", "conv", "ssl", "tmp", "input", "config", "source", "slice", "stream", "dest", "feat", "url", "gb", "image", "cb", "sl", "ctr", "seq", "filename"]}}
{"project": "FFmpeg", "commit_id": "39f01e346cab464ef6c0d4ec58cc13b7123e60d8", "target": 1, "func": "static int ffmmal_add_packet(AVCodecContext *avctx, AVPacket *avpkt,\n\n                             int is_extradata)\n\n{\n\n    MMALDecodeContext *ctx = avctx->priv_data;\n\n    AVBufferRef *buf = NULL;\n\n    int size = 0;\n\n    uint8_t *data = (uint8_t *)\"\";\n\n    uint8_t *start;\n\n    int ret = 0;\n\n\n\n    if (avpkt->size) {\n\n        if (avpkt->buf) {\n\n            buf = av_buffer_ref(avpkt->buf);\n\n            size = avpkt->size;\n\n            data = avpkt->data;\n\n        } else {\n\n            buf = av_buffer_alloc(avpkt->size);\n\n            if (buf) {\n\n                memcpy(buf->data, avpkt->data, avpkt->size);\n\n                size = buf->size;\n\n                data = buf->data;\n\n            }\n\n        }\n\n        if (!buf) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto done;\n\n        }\n\n        if (!is_extradata)\n\n            ctx->packets_sent++;\n\n    } else {\n\n        if (!ctx->packets_sent) {\n\n            // Short-cut the flush logic to avoid upsetting MMAL.\n\n            ctx->eos_sent = 1;\n\n            ctx->eos_received = 1;\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    start = data;\n\n\n\n    do {\n\n        FFBufferEntry *buffer = av_mallocz(sizeof(*buffer));\n\n        if (!buffer) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto done;\n\n        }\n\n\n\n        buffer->data = data;\n\n        buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size);\n\n\n\n        if (is_extradata)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;\n\n\n\n        if (data == start)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;\n\n\n\n        data += buffer->length;\n\n        size -= buffer->length;\n\n\n\n        buffer->pts = avpkt->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->pts;\n\n        buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts;\n\n\n\n        if (!size)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;\n\n\n\n        if (!buffer->length) {\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;\n\n            ctx->eos_sent = 1;\n\n        }\n\n\n\n        if (buf) {\n\n            buffer->ref = av_buffer_ref(buf);\n\n            if (!buffer->ref) {\n\n                av_free(buffer);\n\n                ret = AVERROR(ENOMEM);\n\n                goto done;\n\n            }\n\n        }\n\n\n\n        // Insert at end of the list\n\n        if (!ctx->waiting_buffers)\n\n            ctx->waiting_buffers = buffer;\n\n        if (ctx->waiting_buffers_tail)\n\n            ctx->waiting_buffers_tail->next = buffer;\n\n        ctx->waiting_buffers_tail = buffer;\n\n    } while (size);\n\n\n\ndone:\n\n    av_buffer_unref(&buf);\n\n    return ret;\n\n}\n", "idx": 4064, "substitutes": {"avctx": ["afcontext", "afsci", "aircmp", "abctx", " avsci", "afdc", "avdc", " avcontext", "avkb", "abcmp", "avcmp", "avsci", " avkb", "abcontext", "airdc", "akctx", "afcmp", "aircontext", "afctx", "afkb", "akcontext", "abdc", "aksci", "akkb", "avcontext", "airctx"], "avpkt": ["avppet", "avppstruct", "avopkg", "avvdt", "avlppt", "AVpacket", "avPatt", "affeter", "avcstruct", "avpakt", "ajpkt", "avopstruct", "avpak", "affdt", "avtk", "ajpaacket", "avpromsth", "airspkg", "avPpt", "akpkt", "avpet", "avtacket", "avpkg", "AVwkt", "avvett", " avpacket", "aveckg", "avpk", "avfdt", "ajfpacket", "avvacket", "avfett", "avlpkt", "avvpki", "avespqt", "avpunct", "afpnt", "AVpnt", "avpsacket", "avtdt", "avfpunct", " avpnt", "avvpft", "affelt", "avpft", "avespacket", "avespkt", "avfnt", "avputh", "avepstruct", "afpelt", "ajpak", "ajpelt", "avvpacket", "avfeter", "AVpkt", "avspacket", "avpauth", "airspunct", "affett", "akPkt", "avjpeter", "avjpelt", "afpatt", "avcpkt", "avpsth", "avtkt", "afpdt", "avfatt", "avppelt", "avpromacket", "avfft", "avepet", "avpatt", " avapacket", "avespilot", "avppt", "avopet", "affacket", "akpdt", "avpaacket", "avfki", "airpkt", "airpkg", "avecstruct", "ajfpkt", "avwacket", "avpeter", "avcet", " avpett", "avtpt", "affcht", "aveckt", "avmacket", "avfilot", "avppacket", "avfcht", "afpeter", "avmatt", "avspilot", "avmett", "avlpdt", "avcpnt", "airpft", "avppkt", "avfacket", "afpki", "avpelt", "avkunct", "akpatt", "avpskt", "avtatt", "avfpnt", "afpett", "avapkt", "avjpacket", "avepqt", "avepacket", "ajpakt", "ajfpsth", "avpdt", "avapett", "ajputh", "avppqt", "avpki", "avfkt", "avspft", "avjpkt", "AVwft", "ajpk", "avpstruct", "ajpauth", "akppt", "avfpkt", "avpromelt", "avcpacket", "avmkt", "avspqt", "avfpcht", "avepkt", "avvpkt", "avpcht", "avpacket", "avckt", "avfpkg", "avspkt", "avmcht", "AVpft", "avPdt", "avpsnt", "avfsth", "avwkt", "akPdt", "avkft", "avppilot", "afpkt", "avfpsth", "avkkg", "avfpft", "avapnt", "avtett", "avapacket", "avepkg", "avkkt", "avpski", "avpromkt", "avfk", "avfuth", "afpacket", "avwft", "avpnt", "avmnt", "avpett", " avapkt", "avfpacket", "avfelt", "avcpatt", "ajfpelt", "avspunct", "AVwacket", "avvkt", "affatt", "akPpt", "avppeter", "avppkg", "avwnt", "airspkt", "ajpacket", "avspkg", "avlpatt", "avvpnt", "afpcht", "affki", "avecet", "avepilot", "akPatt", "AVwnt", "avfqt", "avopkt", "ajpsth", " avapnt", "affnt", "avtuth", "avPkt", " avapett", "avfpelt", "affkt", "airpunct", "avckg", "avpqt", "avpilot", "airspft"], "is_extradata": ["is_extrafaton", "is_descradaton", "is_extmodata", "is_extrastata", "is_exrafATA", "is_descradada", "is_extartina", "is_extrafATA", "is_exradate", "is_extandina", "is_extradala", "is_xtradata", "is_extmodate", "is_extrastATA", "is_exrafala", "is_descrafata", "is_extmodATA", "is_descrafada", "is_extadrATA", "is_extartata", "is_extradat", "is_descradata", "is_extandata", "is_xtradina", "is_extrafala", "is_extadrala", "is_extradATA", "is_extrafate", "is_extmodala", "is_descrafaton", "is_extandat", "is_extadrata", "is_extadATA", "is_extartATA", "is_extartat", "is_extadaton", "is_extradina", "is_extradate", "is_exrafata", "is_exradATA", "is_xtrafata", "is_xtrafat", "is_extandATA", "is_extadada", "is_descrafATA", "is_extrastaton", "is_exradata", "is_extrafina", "is_xtradATA", "is_extrafata", "is_xtrafATA", "is_extadata", "is_exrafate", "is_xtrafina", "is_descradATA", "is_extradaton", "is_extradada", "is_xtradat", "is_exradala", "is_extrastada", "is_extadrate", "is_extrafat", "is_extrafada"], "ctx": ["kb", "kw", "wx", "git", "cc", "pkg", "req", "loc", "sc", "cf", "cmp", "context", "conf", "conv", "cca", "vc", "alloc", "exec", "ci", "connection", "cms", "xc", "cli", "config", "sq", "ct", "obj", "qa", "tc", "sci", "cv", "cp", "conn", "ca", "co", "cn", "window", "fw", "c", "ctrl", "nc", "cb", "tx", "crit", "ck", "wcs", "cmd", "hw", "client", "utils", "aux", "bc", " context", "cas", "sync", "lc"], "buf": ["rb", "home", "pkg", "buff", "pb", "ref", "usr", "Buffer", "bus", "fd", "feat", "bh", "block", "cb", "cap", "proc", "f", "wb", "bc", "br", "bo", "tmp", "config", "plug", "cv", "fam", "bag", "pool", "box", "b", "aux", "ux", "cas", "h", "feed", "grab", "ptr", "context", "fi", "bd", "ab", "queue", "pub", "front", "fun", "cmd", "cur", "raf", "uc", "cache", "loc", "cf", "rc", "img", "bb", "header", "alloc", "fp", "src", "runner", "vec", "uncle", "fb", "off", "func", "uf", "fw", "uber", "tx", "bin", "carry", "bu", "seq"], "data": ["i", "zero", "number", "send", "len", "reset", "count", "window", "parent", "output", "complete", "results", "info", "block", "image", "la", "DATA", "message", "media", "ui", "done", "error", "p", "valid", "config", "dat", "name", "load", "limit", "ad", "mode", "pos", "url", "init", "args", "response", "addr", "open", "bytes", "next", "offset", "base", "shift", "Data", "code", "date", "background", "new", "raw", "queue", "partial", "capacity", "full", "pad", "missing", "batch", "length", "read", "address", "extra", "size", "empty", "progress", "index", "source", "val", "cache", "action", "value", "sample", "loc", "scale", "padding", "root", "input", "delay", "first", "alpha", "memory", "id", "no", "off", "stop", "end", "a", "type", "body", "result", "bin", "version", "align", "resource", "timeout", "inner", "content"], "start": ["next", "offset", "done", "shift", "rc", "from", "st", "new", "src", "root", "delay", "first", "id", "send", "time", "no", "skip", "pad", "stop", "count", "end", "pos", "starting", "mid", "before", "to", "in", "read", "init", "seed", "info", "get", "block", "started", "last", "cur", "Start", "set", "range", "parse", "open", "use", "step", "source"], "packets_sent": ["packets___sent", "packets_received", "packets_generated", "packets___fetched", "packets_fetched", "packet_needed", "packets__send", "packets___received", "packet_sent", "packets__sent", "packets__needed", "packets_send", "packets_needed", "packet_fetched", "packets__received", "packet_generated", "packet_received", "packet_send", "packets___generated"], "buffer": ["buff", "worker", "er", "Buffer", "table", "window", "layer", "block", "image", "f", "bc", "message", "manager", "wave", "builder", "seek", "callback", "port", "url", "parser", "transfer", "usher", "b", "slave", "FFER", "rule", "comment", "feed", "offset", "device", "timer", "ptr", "document", "interface", "queue", "iter", "element", "loader", "writer", "uffer", "batch", "border", "length", "server", "read", "pause", "texture", "player", "source", "cache", "binary", "bb", "copy", "header", "command", "byte", "input", "delay", "bridge", "token", "memory", "holder", "file", "bar", "uf", "result", "bin", "resource", "timeout", "reader", "entry"]}}
{"project": "FFmpeg", "commit_id": "969267482de97b08503d27d2fe090ec820273e40", "target": 1, "func": "static void write_frame(AVFormatContext *s, AVPacket *pkt, OutputStream *ost)\n\n{\n\n    AVBitStreamFilterContext *bsfc = ost->bitstream_filters;\n\n    AVCodecContext          *avctx = ost->st->codec;\n\n    int ret;\n\n\n\n    if ((avctx->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) ||\n\n        (avctx->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0))\n\n        pkt->pts = pkt->dts = AV_NOPTS_VALUE;\n\n\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && pkt->dts != AV_NOPTS_VALUE) {\n\n        int64_t max = ost->st->cur_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT);\n\n        if (ost->st->cur_dts && ost->st->cur_dts != AV_NOPTS_VALUE &&  max > pkt->dts) {\n\n            av_log(s, max - pkt->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, \"Audio timestamp %\"PRId64\" < %\"PRId64\" invalid, cliping\\n\", pkt->dts, max);\n\n            pkt->pts = pkt->dts = max;\n\n\n\n\n\n    /*\n\n     * Audio encoders may split the packets --  #frames in != #packets out.\n\n     * But there is no reordering, so we can limit the number of output packets\n\n     * by simply dropping them here.\n\n     * Counting encoded video frames needs to be done separately because of\n\n     * reordering, see do_video_out()\n\n     */\n\n    if (!(avctx->codec_type == AVMEDIA_TYPE_VIDEO && avctx->codec)) {\n\n        if (ost->frame_number >= ost->max_frames) {\n\n            av_free_packet(pkt);\n\n            return;\n\n\n        ost->frame_number++;\n\n\n\n\n    while (bsfc) {\n\n        AVPacket new_pkt = *pkt;\n\n        int a = av_bitstream_filter_filter(bsfc, avctx, NULL,\n\n                                           &new_pkt.data, &new_pkt.size,\n\n                                           pkt->data, pkt->size,\n\n                                           pkt->flags & AV_PKT_FLAG_KEY);\n\n\n\n\n\n\n\n\n\n\n\n        if (a > 0) {\n\n            av_free_packet(pkt);\n\n            new_pkt.destruct = av_destruct_packet;\n\n        } else if (a < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Failed to open bitstream filter %s for stream %d with codec %s\",\n\n                   bsfc->filter->name, pkt->stream_index,\n\n                   avctx->codec ? avctx->codec->name : \"copy\");\n\n            print_error(\"\", a);\n\n            if (exit_on_error)\n\n                exit_program(1);\n\n\n        *pkt = new_pkt;\n\n\n\n        bsfc = bsfc->next;\n\n\n\n\n    pkt->stream_index = ost->index;\n\n    ret = av_interleaved_write_frame(s, pkt);\n\n    if (ret < 0) {\n\n        print_error(\"av_interleaved_write_frame()\", ret);\n\n        exit_program(1);\n\n", "idx": 4070, "substitutes": {"s": ["S", "sv", "sets", "sc", "ts", "ns", "cs", "ctx", "sec", "ssl", "o", "st", "p", "src", "details", "sq", "session", "lex", "sa", "sci", "services", "sys", "stats", "service", "g", "ps", "server", "spec", "ses", "c", "sb", "parser", "gs", "t", "os", "f", "op", "storage", "sg", "client", "aws", "utils", "ss", "js", "sl", "sk", "ops", "ds", "so"], "pkt": ["Poch", "pkg", " pelt", "Pct", "tpelt", "gct", " pett", " pcht", "packet", "opkg", "Pcht", "apunct", "dcht", " pck", "punct", "cpkg", "pant", "ipant", "ipkt", "opkt", "pett", "ipacket", "pskg", "lpct", "Pkg", "dacket", "lpdt", "pet", "spcht", "ipet", "cpnt", "pct", " poch", "psunct", "spacket", " packet", "Pdt", "pck", "tpacket", "tpet", "Pck", " pet", "opck", "pskt", " pnt", "opet", "prent", "Pkt", "preet", "tpett", "dett", "pelt", "opnt", "cpck", "ipcht", " pant", "gacket", "Packet", "opacket", " pdt", "dkt", "poch", "lpkt", " pct", "Pant", "pset", "spkt", "tpkt", "pdt", "lpacket", "pnt", "apkt", "Pnt", "prekt", "gkt", "pcht", "cpacket", "apet", "cpet", "Pet", "tpnt", "cpkt", "gcht", " pkg", "preacket", "cpunct", "Pelt", "Pett", "ipoch", "apkg", "spett"], "ost": ["host", "ocol", "oss", "art", "\u00f3", "od", "inst", "hop", "object", "rt", "tt", "bb", "so", "orb", "o", "archive", "st", "ont", "sta", "ott", "ov", "obj", "sn", "rss", "rest", "et", "ad", "org", "ld", "ods", "pod", "oh", "stream", "est", "roc", "ocr", "ast", "iol", "upload", "oop", "nt", "tto", "ot", "oid", "ob", "obs", "ist", "ood", "oc", "osc", "os", "osta", "op", "OST", "rob", "post", "oper", "http", "osi", "ort"], "bsfc": ["cspc", "csxf", "csvc", "apsfb", "dscf", "bsFC", "pspc", "vsfs", "bsxf", "bsfb", "csfb", "pscf", "bosvc", "dsfc", "apsfs", "psvc", "bspc", "boscf", "vsFC", "vsfb", "apsfc", "csFC", "vsfc", "dsxf", "dspc", "apsFC", "psFC", "cscf", "bscf", "bsvc", "csfs", "bosfc", "csfc", "bsfs", "psxf", "psfc", "bosFC"], "avctx": ["ovcmp", "Avpkg", "afcontext", "avcu", "avecmp", "Avcf", "avconn", "AVctx", "abconfig", " avc", "avectx", "verlc", "evconn", "avelc", "abctx", "ovconn", "Avctx", " avcontext", "afhw", "avcmp", " avcf", "AVcu", "aveconfig", "Avcontext", "vercu", "vercontext", "abcontext", "avpkg", "AVlc", "vercmp", "evcmp", "akctx", "verctx", "ovctx", "aveconn", "AVconn", "abc", "afconn", "akpkg", "avec", "avcf", "AVhw", "afcmp", "afctx", "verconn", "avecontext", "avlc", "evctx", "akcontext", "avecu", "evcontext", "avc", "avconfig", "AVcontext", "avhw", "avcontext", "AVcmp", "akcf", " avconfig", "avehw", "ovcu", " avpkg"], "ret": ["val", "res", "value", "total", "code", "num", "sec", "resp", "ref", " success", "rows", "id", "MAX", "no", "len", "count", " resp", "success", "row", "rs", " res", "result", "std", "Ret", "last"], "frame_number": ["fram_position", "frameMno", "frame_position", "fram_number", "framesnumber", "framesno", "frame_note", "frame_no", "framesnote", "frameMversion", "fram_note", "frame_version", "fram_version", "frameMnumber", "framesposition", "fram_no"]}}
{"project": "qemu", "commit_id": "14fe292d86da90b79e2fb56a4986d27346339a00", "target": 1, "func": "void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *l2_table)\n\n{\n\n    CachedL2Table *entry;\n\n\n\n    entry = qed_find_l2_cache_entry(l2_cache, l2_table->offset);\n\n    if (entry) {\n\n        qed_unref_l2_cache_entry(entry);\n\n        qed_unref_l2_cache_entry(l2_table);\n\n        return;\n\n    }\n\n\n\n    if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) {\n\n        entry = QTAILQ_FIRST(&l2_cache->entries);\n\n        QTAILQ_REMOVE(&l2_cache->entries, entry, node);\n\n        l2_cache->n_entries--;\n\n        qed_unref_l2_cache_entry(entry);\n\n    }\n\n\n\n    l2_cache->n_entries++;\n\n    QTAILQ_INSERT_TAIL(&l2_cache->entries, l2_table, node);\n\n}\n", "idx": 4080, "substitutes": {"l2_cache": ["l2theroot", "l2aclast", "l1_size", "l92_cache", "l2_source", "l1_model", "l92_header", "l1_last", "l1_session", "l1_engine", "l2_image", "l2_header", "l2xsize", "l1_cache", "l2dsession", "l2lextable", "l1_cookie", "l2pubtable", "l1_table", "l2dmodel", "l2fdatabase", "l2mtable", "l2dtable", "l2thetable", "l92_table", "l2_engine", "l1_time", "l2mengine", "l2lexcache", "l2_last", "l92_database", "l2xcache", "l2mmenu", "l2_model", "l2thesize", "l2xroot", "l92lextable", "l2_cookie", "l2accache", "l2_size", "l2accookie", "l2actable", "l1_config", "l2lexlast", "l2xtable", "l2mcache", "l2lextime", "l2_session", "l1_menu", "l2_time", "l1_source", "l2_root", "l2_database", "l2lexcookie", "l2lexsource", "l2lexdatabase", "l2fheader", "l1_image", "l2dcache", "l2lexheader", "l92lexcache", "l92lexdatabase", "l2pubsource", "l1_root", "l2pubtime", "l2thecache", "l2ftable", "l2_menu", "l2_config", "l2fcache", "l2pubcache", "l92lexheader"], "l2_table": ["l2_resource", "l2fmachine", "ltwo2server", "l2jtree", "ltwo2cache", "l2jtable", "l2dbcache", "ltwo_machine", "l2jsource", "ltwojsource", "ltwo2node", "l2jmachine", "l2_template", "l22node", "l1_table", "l2_server", "l2fsource", "ltwo_source", "l2_tree", "ltwo_node", "l22table", "l1_tree", "l2jcache", "l2_source", "l2mnode", "l2mtable", "l22cache", "l2ptable", "l2dbtree", "ltwo_cache", "ltwo_server", "l1_resource", "l2pcache", "l2presource", "ltwo_table", "l2dbtable", "l1_template", "l2ptree", "l2ftable", "ltwojtable", "l2mcache", "l2mserver", "l2jtemplate", "l2_node", "l22server", "l2_machine", "l2dbtemplate", "l2fcache", "l1_cache", "ltwojmachine", "ltwo2table", "ltwojcache"], "entry": ["view", "part", "enter", "match", "her", "card", "letter", "key", "ries", "table", "ie", "row", "parent", "info", "image", "page", "cel", "je", "Entry", "object", "si", "valid", "node", "term", "se", "route", "event", "data", "ry", "nt", "ent", "slave", "it", "comment", "line", "feed", "offset", "zip", "jo", "ident", "way", "exist", "ge", "cell", "session", "obj", "element", "service", "member", "search", "server", "package", "address", "child", "e", "try", "index", "source", "cat", "insert", "value", "section", "connection", "module", "id", "import", "start", "result", "inner", "reader", "record", "link"], "n_entries": ["n___expries", "n_sentries", "n_ntry", "n__Entrows", "n_Entrows", "n___expry", "n_countrows", "n_secrys", "n_sentrys", "n_entents", "n__entries", "n__Entries", "n_ntencies", "n_entrows", "n_secries", "n___entries", "n__Entry", "n_sentry", "n__entrys", "n_entrys", "n_chry", "n_secry", "n_expances", "n__Entrys", "n_countries", "n___entry", "n_chents", "n_ntries", "n_Entries", "n_Entances", "n__entrows", "n__entry", "n_secrows", "n_entencies", "n_expries", "n_sentencies", "n_expents", "n_entry", "n___expents", "n___entents", "n_Entrys", "n_Entry", "n_Entents", "n_countencies", "n_chances", "n_entances", "n_chries", "n_expry", "n___expances", "n___entances", "n_countrys", "n_ntrys", "n_country"]}}
{"project": "FFmpeg", "commit_id": "bc488ec28aec4bc91ba47283c49c9f7f25696eaa", "target": 1, "func": "av_cold void ff_pixblockdsp_init_x86(PixblockDSPContext *c,\n\n                                     AVCodecContext *avctx,\n\n                                     unsigned high_bit_depth)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_MMX(cpu_flags)) {\n\n        if (!high_bit_depth)\n\n            c->get_pixels = ff_get_pixels_mmx;\n\n\n        c->diff_pixels = ff_diff_pixels_mmx;\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        if (!high_bit_depth)\n\n            c->get_pixels = ff_get_pixels_sse2;\n\n\n        c->diff_pixels = ff_diff_pixels_sse2;\n\n    }\n\n}", "idx": 4091, "substitutes": {"c": ["cu", "cache", "cc", "cr", "dc", "i", "sc", "cf", "ac", "l", "rc", "cmp", "cs", "enc", "ctx", "vc", "p", "ci", "ce", "ec", "ct", "m", "config", "z", "w", "s", "k", "acs", "tc", "con", "cv", "v", "cp", "lc", "pc", "ca", "g", "co", "coll", "self", "ch", "mc", "t", "f", "u", "cl", "cur", "this", "C", "e", "bc", "uc", "cm", "anc", "cd"], "avctx": ["afcontext", "AVcontext", "AVcmd", "avcmd", "AVctx", "avcb", "afctx", "AVcb", "avcontext", " avcmd", "afcb", " avcontext", "afcmd", " avcb"], "high_bit_depth": ["high_pixelpcount", "high_bitingrate", "high_bitpcount", "high_bitpredetails", "high_bit_density", "high_bitbitsize", "high_pixelpdepth", "high_bitvaldepth", "high_bitbitdepth", "high_bitingsize", "high_pixel_count", "high_bit_rate", "high_bitpredensity", "high_bitpredepth", "high_checkpredepth", "high_bitbitrate", "high_checkpredensity", "high_bitvaldensity", "high_check_depth", "high_bitbitdim", "high_bitpdepth", "high_bitprate", "high_pixelprate", "high_check_details", "high_check_density", "high_bit_size", "high_pixel_depth", "high_bit_dim", "high_pixel_rate", "high_bitingdepth", "high_bitingdim", "high_checkpredetails", "high_bit_count", "high_bitvaldetails", "high_bit_details"]}}
