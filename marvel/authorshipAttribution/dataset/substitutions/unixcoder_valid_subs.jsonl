{"code": "inputFile = open('B-small-attempt0.in', 'r')\\n  lines = inputFile.readlines()\\n  inputFile.close()\\n  \\n  outputFile = open('B-small-attempt0.out', 'w')\\n  \\n  numTests = int(lines[0])\\n  \\n  \\n  def solveCookies(c, f, x):\\n      accumTime = 0\\n      farmRate = 0\\n      while True:\\n          timeToWait = x/(2.0+farmRate)\\n          timeIfBuyFarm = (c/(2.0+farmRate) +   # Time to get a farm\\n                           x/(2.0+farmRate+f))\\n          if timeToWait <= timeIfBuyFarm:\\n              return accumTime+timeToWait\\n          else:\\n              accumTime += c/(2.0+farmRate)\\n              farmRate += f\\n  \\n  for i in range(1, numTests+1):\\n      [c, f, x] = map(lambda x: float(x), lines[i].split())\\n  \\n      outputFile.write('Case #'+str(i)+': ' + str(solveCookies(c, f, x))+'\\n')\\n  outputFile.close()\\n      \\n", "target": "0", "substitutes": {"inputFile": ["inputHandle", " inputfile", "outputDir", "sourceDir", "inputStream", " inputFiles", " inputPage", "outputFiles", "outputPage", "imageFile", " inputLine", "outputLine", "inputDir", "sourceFiles", "imagefile", "InputFile", " inputHandle", "inputPage", "inputFiles", "imageHandle", "sourceLine", "outputStream", "InputStream", "imageFiles", "Inputfile", "InputHandle", "inputLine", "InputPage", "sourceFile", "InputFiles", " inputStream", " inputDir", "inputfile"], "lines": ["rules", "results", "letters", "ines", "vals", "params", "qs", "ids", "reads", "rows", "words", "points", "codes", "values", "cells", "ds", "mails", "pins", "elines", "pages", "log", "l", "ls", "keys", "locks", " Lines", "models", "headers", "times", "files", "strings", "posts", "faces", "s", "zip", "blocks", "balls", "los", "states", "items", "tests", "line", "limits", "users", "runs", "ips", "objects", "steps"], "outputFile": [" outputfile", "outFile", "outputDir", "putFile", "inputStream", "outputfile", "outputFiles", "Outputfile", " outputFilename", "OutputDirectory", "putfile", "putFilename", "OutputStream", "inputDirectory", " outputDirectory", "finalfile", " outputDir", "finalStream", "OutputFile", " outputFiles", "inputFiles", " outputStream", "outputFilename", "OutputFiles", "outputStream", "finalFiles", "finalFile", "outfile", "outFilename", "outputDirectory", "outDir", "putDir"], "numTests": ["numTestits", "numPatries", "numTits", "multiPatickets", "numFries", "multiTickets", " numTries", "multiTasks", "multiPatests", " numtries", "numPatests", " numtcases", " numTits", " numtits", "numFickets", "numtits", "numPatasks", "numtries", " numTcases", "numTries", "multiTests", "numFcases", "numTestests", "numFits", "numFasks", "numTestcases", "numTasks", "numtcases", " numtests", "multiPatries", "numFests", "numTickets", "numTcases", "numPatickets", "multiPatasks", "numtests", "multiTries", "numTestries"], "c": ["e", "cf", "mc", "d", "h", "C", "dc", "p", "ch", "ce", "max", "u", "count", "ct", "r", "z", "t", "cat", "co", "v", "cu", "cs", "w", "cy", "uc", "n", "m", "ci", "l", "cor", "xc", "cd", "cc", "s", "time", "unc", "cell", "a", "cin", "k", "ec", "cycle", "nc", "y", "code", "sc", "b", "con", "cn", "cp", "chain", "cr", "g", "lc"], "f": ["e", "cf", "fd", "d", "fr", "h", "xf", "p", "fx", "j", "lf", "aff", "u", "z", "r", "fo", "t", "file", "fb", "form", "tf", "v", "of", "feed", "w", "sf", "q", "m", "n", "l", "rf", "fl", "fp", "inf", "fs", "df", "F", "fe", "y", "b", "fc", "fen", "g", "farm", "fa"], "x": ["e", "ctx", "size", "cf", "xs", "xi", "xt", "d", "name", "px", "X", "content", "sex", "h", "xp", "xf", "p", "fx", "xy", "j", "xml", "xes", "u", "case", "ct", "z", "rx", "val", "t", "number", "v", "string", "dx", "w", "uc", "q", "m", "n", "ci", "l", "cl", "index", "ex", "data", "xc", "wx", "php", "xxx", "xxxx", "xe", "time", "pe", "key", "ic", "F", "xx", "fe", "ix", "y", "code", "b", "fc", "g"], "accumTime": ["acumeRate", "acumeType", "accumptionLength", "AccumRate", "ccumTimes", "accumeSize", "accumSize", "accumedType", "accumeType", "accumeLength", "accumedTime", "ccumptionRate", "acumeTimes", "accumedRate", "AccumTimes", "accumptionSize", "ccumptionTimes", "accumeTimes", "accumptionTime", "acumTime", "acumRate", "ccumSize", "accumedTimes", "accuumSize", "AccumLength", "accanceTime", "accuumRate", "accanceLength", "acumTimes", "accumType", "accumLength", "accumRate", "AccumptionTimes", "ccumptionTime", "ccumRate", "acumType", "AccumTime", "accumptionType", "ccumTime", "accuumTimes", "accanceTimes", "accumptionRate", "acumeTime", "accumTimes", "AccumptionRate", "AccumptionTime", "accumeTime", "accanceRate", "ccumptionSize", "accumeRate", "accumptionTimes", "AccumptionLength", "accuumTime"], "farmRate": ["fieldSpeed", " farmPercent", "milePercent", " kitchenLimit", "Farmrate", "farmLimit", "fieldRate", "mileSize", "forkSpeed", "FarmSize", " kitchenrate", "farmSize", "forkrate", "feedRate", "FarmRate", "forkSize", "farmPercent", " farmrate", " farmSpeed", "forkRate", "flowerrate", "flowerPercent", "feedSpeed", "farmrate", "flowerSpeed", "fieldSize", "farmSpeed", " farmLimit", " farmSize", "milerate", "FarmLimit", "flowerRate", "mileRate", " kitchenRate", "feedrate", "FarmPercent", "FarmSpeed"], "timeToWait": ["timeUntilStay", " timeOfSleep", "timetoSleep", " timeUntilPlay", "timeUntilPlay", "timetoLock", " timeUntilStay", "timeToLock", "timetowait", "howToWait", "howtoSleep", "timetoLive", " timeTowait", " timeOfwait", "timeTOSleep", "timeOfSleep", "timetoGo", "timeToPlay", "timeToSleep", " timeToSleep", " timeToStay", "timeTowait", "howtoWait", "timeTOWait", "timeOfLock", " timeToLock", "time2Wait", " timeUntilSleep", "time2Play", "timeTOStay", "timeToLive", "timeToGo", "howToLive", "timeUntilSleep", "howtoLive", "time2Stay", "timeOfWait", " timeToPlay", "timeToStay", "timetoWait", "timeOfGo", "howtoGo", " timeOfWait", " timeUntilWait", "howToSleep", " timeOfLock", "timeTOPlay", "timeUntilWait", "howToGo", "timeOfLive", "time2Sleep", "timeOfwait"], "timeIfBuyFarm": ["timeIfbuyFarm", "timeIfBuyTime", "timeIfbuyfarm", "timeIfbuyTime", "timeOfbuyTime", "timeIfLeanfarm", "timeIfBuyFan", "timeIfBuyfarm", "timeOfBuyFarm", "timeIfLeanFarm", "timeOfBuyTime", "timeIfbuyFan", "timeOfbuyFarm", "timeIfLeanTime", "timeOfBuyfarm", "timeOfbuyFan", "timeOfbuyfarm", "timeOfBuyFan"], "i": ["e", "gi", "si", "xi", "ip", "d", "my", "mi", "id", "h", "slice", "p", "j", "I", "inner", "start", "u", "z", "r", "ie", "li", "pi", "t", "ui", "v", "io", "type", "n", "ci", "m", "l", "ii", "index", "bi", "di", "ti", "yi", "end", "int", "ix", "y", "ri", "iu", "ind", "info", "eni", "qi"]}}
{"code": "inputFile = open('C-small-attempt8.in', 'r')\\n  lines = inputFile.readlines()\\n  inputFile.close()\\n  \\n  outputFile = open('C-small-attempt8.out', 'w')\\n  \\n  numTests = int(lines[0])\\n  \\n  for i in range(1, numTests+1):\\n      [r, c, m] = map(lambda x: int(x), lines[i].split())\\n  \\n      openCells = r*c - m\\n  \\n      works = False\\n      matrix = [['*']*c for j in range(r)]\\n      if r >= 3 and c >= 3:\\n          order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),\\n                   (2,0), (2,1)]\\n          if openCells == 1 or openCells == 4 or openCells == 6:\\n              works = True\\n              for (x,y) in order[:openCells]:\\n                  matrix[x][y] = '.'\\n              matrix[0][0] = 'c'\\n              \\n          elif openCells >= 8:\\n              works = True\\n              filledRows = openCells / c\\n              if filledRows >= 2:\\n                  if filledRows == r:\\n                      matrix = [['.']*c for j in range(r)]\\n                      matrix[0][0] = 'c'\\n                  else:\\n                      remainder = openCells%c\\n                      if not remainder == 1:\\n                          for j in range(filledRows):\\n                              matrix[j] = ['.']*c\\n                          matrix[filledRows] = ['.']*remainder + ['*'] * (c-remainder)\\n                      elif filledRows > 2:\\n                          for j in range(filledRows-1):\\n                              matrix[j] = ['.']*c\\n                          matrix[filledRows-1] = ['.']*(c-1) + ['*']\\n                          matrix[filledRows] = ['.', '.'] + ['*']*(c-2)\\n                      else:\\n                          matrix[0] = ['.']*(c-1) + ['*']                        \\n                          matrix[1] = ['.']*(c-1) + ['*']\\n                          matrix[2] = ['.', '.', '.'] + ['*']*(c-3)\\n                      matrix[0][0] = 'c'\\n                  \\n              else:\\n                  for (x,y) in order:\\n                      matrix[x][y] = '.'\\n                  remainingOpen = openCells - 8\\n                  if remainingOpen % 2 == 0:\\n                      for j in range(remainingOpen/2):\\n                          matrix[0][j+3] = '.'\\n                          matrix[1][j+3] = '.'\\n                  else:\\n                      matrix[2][2] = '.'\\n                      remainingOpen -= 1\\n                      for j in range(remainingOpen/2):\\n                          matrix[0][j+3] = '.'\\n                          matrix[1][j+3] = '.'\\n                  matrix[0][0] = 'c'\\n  \\n      elif r == 1:\\n          works = True\\n          matrix[0] = ['.']*(c-m) + ['*']*m\\n          matrix[0][0] = 'c'\\n      elif c == 1:\\n          works = True\\n          for j in range(r-m):\\n              matrix[j][0] = '.'\\n          matrix[0][0] = 'c'\\n  \\n      elif r == 2 and c == 2:\\n          if m == 3:\\n              works = True\\n              matrix[0][0] = 'c'\\n          elif m == 0:\\n              works = True\\n              matrix = [['c', '.'], ['.', '.']]\\n      elif r == 2:\\n          if m % 2 == 0 and r*c-m > 2:\\n              works = True\\n              matrix[0] = ['.']*(c-m/2) + ['*']*(m/2)\\n              matrix[1] = ['.']*(c-m/2) + ['*']*(m/2)\\n              matrix[0][0] = 'c'\\n          elif r*c-m == 1:\\n              works = True\\n              matrix[0][0] = 'c'\\n      elif c == 2:\\n          if m % 2 == 0 and r*c-m > 2:\\n              works = True\\n              for j in range((r*c-m)/2):\\n                  matrix[j] = ['.', '.']\\n              matrix[0][0] = 'c'\\n          elif r*c-m == 1:\\n              works = True\\n              matrix[0][0] = 'c'\\n      \\n  \\n      outputFile.write('Case #'+str(i)+':\\n')\\n      '''if len(matrix) != r:\\n          print i, matrix\\n      count = 0\\n      for j in range(len(matrix)):\\n          for k in range(len(matrix[j])):\\n              if matrix[j][k] == '*':\\n                  count += 1\\n      if count != m:\\n          print i, matrix'''\\n      if not works:\\n          outputFile.write('Impossible\\n')\\n      else:\\n          for x in range(len(matrix)):\\n              for y in range(len(matrix[0])):\\n                  outputFile.write(matrix[x][y])\\n              outputFile.write('\\n')\\n  outputFile.close()\\n              \\n", "target": "0", "substitutes": {"inputFile": ["inputHandle", "outputDir", "sourceDirectory", "inputStream", " inputFiles", "outputFiles", "sourceFolder", "inputDirectory", " inputLine", "outputLine", "inputDir", "sourceFiles", "InputDir", " inputDirectory", "InputFile", "outputHandle", " inputHandle", "inputFolder", "outputFolder", "inputFiles", "outputStream", "InputStream", "InputHandle", "inputLine", "sourceFile", "outputDirectory", "InputFiles", " inputFolder", "InputLine", " inputStream", " inputDir"], "lines": ["rules", "sheets", "results", "letters", "ines", "vals", "params", "args", "reads", "rows", "points", "words", "features", "cases", "cells", "lin", "ses", "elines", "pages", "log", "l", "ls", "breaks", "locks", "groups", " Lines", "models", "headers", "zip", "files", "strings", "posts", "faces", "s", "blocks", "items", "tests", "reports", "line", "limits", "les", "runs", "ipes", "objects", "steps"], "outputFile": ["Outputfile", " outputfile", "errorFiles", "errorFile", "OutputFiles", "outputDir", " outputDir", "errorDir", "errorfile", "OutputFile", " outputFiles", "outputfile", "OutputDir", "outputFiles"], "numTests": ["numTipes", "numNasks", "numTrainickets", " numNickets", " numNesters", " numTipes", "numPatests", "numTriipes", "numtesters", " numFches", "numFipes", " numTches", "numNesters", " numTickets", "numTrainesters", "numPatesters", " numTesters", "numNests", "numTrainests", " numTasks", "numTches", "numTrainasks", "numtickets", "numTriests", "numtasks", "numTasks", " numFipes", "numTriesters", " numFesters", "numPatches", "numFesters", "numFests", "numTickets", " numNests", "numNickets", "numtests", " numNasks", "numTriches", " numFests", "numTesters", "numPatipes", "numFches"], "i": ["e", "gi", "ini", "si", "xi", "ip", "d", "id", "p", "I", "start", "u", "z", "li", "pi", "ai", "ir", "n", "ci", "l", "ij", "index", "ii", "ti", "end", "int", "k", "ix", "ri", "iu", "b", "ind", "qi"], "r": ["e", "range", "rr", "rb", "br", "d", "fr", "rc", "h", "p", "ur", "ar", "mr", "er", "u", "z", "t", "v", "ir", "re", "w", "q", "n", "l", "R", "ru", "right", "g", "s", "a", "rn", "k", "rs", "sr", "nr", "b", "rg", "f", "o", "cr"], "c": ["e", "cf", "mc", "d", "col", "h", "ac", "C", "dc", "p", "ch", "ce", "max", "u", "count", "z", "t", "cat", "co", "v", "cu", "cs", "w", "uc", "q", "n", "ci", "l", "cl", "g", "cc", "s", "cache", "a", "k", "ic", "ec", "cycle", "nc", "sc", "b", "cm", "f", "con", "cr", "o", "cp", "fc", "arc", "cn", "lc"], "m": ["e", "mc", "d", "mi", "h", "C", "p", "mr", "u", "im", "mm", "z", "t", "M", "v", "w", "q", "n", "l", "mod", "s", "k", "cm", "b", "f", "o", "cr", "g"], "x": ["e", "ctx", "xi", "xs", "d", "X", "h", "xp", "p", "xy", "z", "val", "rx", "t", "yx", "v", "dx", "w", "q", "n", "l", "el", "index", "ex", "data", "xc", "xxx", "work", "s", "key", "int", "a", "k", "xx", "ix", "code", "b", "f", "o"], "openCells": ["openWaches", "openRels", "openWodes", " openCodes", "openCalls", " openTells", "openSels", "OpenSches", "closedChips", "openChcells", "OpenSell", " openTels", "opencels", "openRipes", "openWels", "openCaches", " openCels", "openPodes", "closeRels", "opencalls", "openTels", "closeComes", "openRodes", "openRells", "closedCaches", "openPches", "openTalls", "openedCodes", "opencell", "openRell", "closeCels", "openSomes", "openRows", "openedRhips", "closeRows", "openChalls", "openSches", "openedcodes", "openTches", "OpenCcells", "openShips", "OpenSels", "openWhips", "openChches", " openTipes", "openSipes", "OpenTcells", "openSells", " openCipes", "openedCells", "openedcells", "openedChips", "openCipes", "openPalls", "openRalls", "openPatches", "openRaches", "openedRches", "openPells", "openCell", " openTodes", "openPcells", "openSows", "OpenCalls", "openRhips", "openedRells", "OpenCches", "OpenCels", "openNows", "closedRalls", "openCches", "openWalls", "opencodes", "openRches", "opencells", "openTcells", "openRomes", "OpenSells", "closeRells", "openedCalls", "openSalls", "openNomes", "openTipes", "openedCches", "openNells", "openSodes", "OpenCells", "openCodes", "openedcels", "closeCows", "openTodes", "openChhips", "openedcalls", "openWells", "OpenTatches", "openChatches", "openChells", "openSell", "OpenCodes", "openChips", "openCows", "OpenCatches", "openTells", "openCatches", "closedRhips", "openChaches", "openTatches", "closedCells", "closedCalls", "OpenSalls", "openComes", "openCcells", "OpenTells", "openedRalls", "OpenTalls", "closedRaches", "openedCels", "closeRomes", "OpenCell", "openCels", "openNels", "closeCells", "OpenSodes", "openPels", "closedRells"], "works": ["working", "ws", " starts", "results", "jobs", " results", "workers", "shows", "ns", "hops", "reads", "words", " weights", " features", " contracts", "acts", " turns", "width", "features", "holes", "cases", "planes", "dates", "cells", "ches", " patches", "res", " chains", "Works", " networks", " coordinates", "aces", "forms", "cs", "w", "nn", " runs", "breaks", "days", "right", " squares", "WORK", "batch", "hands", "checks", "work", " covers", "blocks", "shape", "worker", " moves", "wh", "makes", " workers", " spins", "es", "mask", "ops"], "matrix": ["matograph", " matMatrix", "materialomo", "matrow", "scheric", "MATlas", "donrix", "mrow", "applicationric", "matpack", "scheix", "donpack", "atric", "mrix", "applicationomo", " matlab", "attribution", "utray", "Matfix", "matray", "MatMatrix", "matfix", "MATric", "scherix", "matcost", "attric", "MATrices", "calric", "applicationensor", "matrice", "formatcost", "memrix", "atcost", "MATnn", " matrice", " matfix", "atrice", "maturation", "utric", "materialensor", "attray", "atrices", "attrix", "MATfix", "atrix", "MATrow", "donensor", " matov", " matpack", "calrices", "Matrice", "catrix", "mrices", "mitric", "MATograph", "Matensor", "applicationrix", "MATuration", "scheograph", "matlab", "utrix", "formatric", "Matrix", "matrics", " matric", "memray", " matix", "calrix", "schelas", " matri", "matov", "mitix", "atMatrix", "mitpack", "utribution", "catric", "MATov", "materialrix", "mnn", "matri", "catpack", "MATrix", "matrices", "Matrices", " matnn", "schepack", "Matograph", "formatrices", "materialov", "memric", "catensor", "calrics", "Matric", "matnn", "materialrices", "mitrix", "matric", "Matlas", "Matri", "donric", "formatrics", " matrics", " matensor", " matrices", "matix", "matlas", "scherices", "matomo", "Matomo", "MATlab", "materialric", "formatrix", " matrow", "matMatrix", "MATri", " matcost", "memribution", " maturation", "matensor", "matribution", "Matlab", "Maturation"], "j": ["e", "br", "d", "col", "uj", "h", "J", "p", "ch", "u", "im", "ct", "ie", "z", "jl", "li", "it", "jj", "v", "co", "_", "un", "w", "q", "n", "l", "adj", "jp", "ij", "ii", "dj", "index", "ja", "key", "jc", "cell", "ji", "k", "aj", "jo", "b", "cm", "f", "o", "g", "js"], "order": ["e", "comb", "rule", "tr", "id", "center", "h", "unit", "p", "ode", "address", "direction", "case", "acc", "v", "row", "random", "axis", "record", "w", "position", "Order", "type", "rank", "n", "ow", "q", "index", "right", "all", "work", "sort", "ord", "orders", "ordered", "shape", "code", "b", "array", "cr", "ordering"], "y": ["e", "ny", "yr", "d", "col", "yy", "ay", "yt", "p", "ch", "ye", "xy", "year", "z", "ty", "v", "yl", "w", "cy", "q", "oy", "n", "l", "yi", "ey", "dy", "yo", "ya", "vy", "Y", "b", "o"], "filledRows": ["filledLow", "filledMells", "filledCrows", "fillMOWS", "workedrucks", " filledRells", "fillMow", "loadedRays", "fillMows", "filledRsays", "filledrows", "loadedCays", "filledNells", "closedRows", "filledRells", "filledCocks", "filledRsOWS", "confirmedRows", "filledNrows", "filledRsells", "loadedRow", "workedRocks", "loadedRells", " filledCrows", "filledEndrows", "filledMOWS", "filledLays", " filledROWS", " filledCells", "filledCalls", "filledralls", "filledCow", "closedCrows", "filledRsrows", "fillRow", "filledrocks", "filledRays", "filledRsows", "filledChows", "filledCays", "fillROWS", "fillRows", "filledRucks", "confirmedRells", "filledEnducks", "filledRocks", "filledChOWS", "loadedCOWS", "closedCows", " filledRays", "closedRrows", "fillRells", "closedRalls", "filledCells", "filledLrows", "filledROWS", "filledNows", "filledrucks", " filledRrows", "fillMells", "filledMows", "loadedRows", "filledCOWS", "filledMow", " filledRow", "loadedCows", " filledCows", "filledCows", "confirmedROWS", "loadedROWS", "workedRrows", "filledLows", "filledChells", "loadedCells", "workedrrows", "filledChays", "closedROWS", "filledLOWS", "loadedRrows", "closedCOWS", "closedCalls", "filledrOWS", "workedRucks", "filledEndocks", "loadedCow", " filledCOWS", "filledrrows", " filledCow", "workedrows", "filledNOWS", "filledRow", "confirmedRays", "filledRsow", "filledEndows", "filledRalls", "filledCucks", " filledCays", "loadedCrows", "workedRows", "filledLells", "filledRrows", "workedrocks"], "remainder": ["mainter", "remainsser", "remamancer", "demrainner", "remrainser", "remainner", "REMainner", "remAINDER", " remainsder", "remainerter", "remainedler", "REMainDER", "remainster", "remainingcer", "demaincer", "demainder", "remamander", "mainke", "remainler", "remainerser", "remainDER", "remraincer", "remainsler", " remainsDER", "remainsDER", "remAINler", "mainster", "remaincer", "remainedder", "mainser", "remainedcer", "remamanter", "REMainsDER", " remaincer", "mainske", "remainske", "remAINner", "remainedner", "remainke", "remainser", "REMainder", "remAINder", "mainsser", "remainingDER", "REMainler", "REMainsner", "remainerder", "remrainner", "demainner", "remainingser", "mainder", "remainedDER", " remainster", "remamanDER", "remainingder", "demrainser", "REMainsler", " remainDER", "remainedser", "remrainder", "remainingter", "remainsder", " remainter", "remainerke", "demainser", "remainter", "mainsder", "REMainsder", "remainingke", "remainsner", "demraincer", " remainscer", "demrainder", "remainscer"]}}
{"code": "\\n  \\n  \\n  \\n  \\n  \\n  \\n  class memoize(object):\\n     \"\"\"Decorator. Caches a function's return value each time it is called.\\n     If called later with the same arguments, the cached value is returned\\n     (not reevaluated).\\n     \"\"\"\\n     def __init__(self, func):\\n        self.func = func\\n        self.cache = {}\\n     def __call__(self, *args):\\n        if not isinstance(args, collections.Hashable):\\n           return self.func(*args)\\n        if args in self.cache:\\n           return self.cache[args]\\n        else:\\n           value = self.func(*args)\\n           self.cache[args] = value\\n           return value\\n     def __repr__(self):\\n        '''Return the function's docstring.'''\\n        return self.func.__doc__\\n     def __get__(self, obj, objtype):\\n        '''Support instance methods.'''\\n        return functools.partial(self.__call__, obj)\\n  \\n  \\n  def precalculate():\\n      \"\"\"Perform any calculations that need to be performed before the main path\\n      (e.g., preparing lookup tables, etc.)\\n      \\n      N.B. Make sure you make any important variables global so that other\\n      functions can access them.\\n      \"\"\"\\n      pass\\n  \\n  def read_input(infile):\\n      \"\"\"This function should take an open input file, load in all of the\\n      relevant information for a single case of the problem, and output it\\n      as a single object.    \\n      \"\"\"\\n      def read_int():\\n          return int(infile.readline().strip())\\n      def read_ints():\\n          return np.array(infile.readline().split(), dtype=int)\\n      def read_bigints(): #For ints that won't fit directly in an int32 array\\n          line = infile.readline().split()\\n          return np.array(map(lambda x: int(x), line))\\n      def read_float():\\n          return float(infile.readline().strip())\\n      def read_floats():\\n          return np.array(infile.readline().split(), dtype=float)\\n      def read_string():\\n          return infile.readline().strip()\\n      def read_strings():\\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\\n      \\n      C, F, X = read_floats()\\n      \\n      case = (C, F, X)\\n      \\n      return case\\n  \\n  def solve_case(case):\\n      \"\"\"Take the input data (structured in case) and perform any necessary\\n      calculations to obtain the desired output, formatted as the appropriate\\n      string.    \\n      \"\"\"\\n      C, F, X = case\\n      \\n      rate = 2.0\\n      cookies = 0.0\\n      time = 0.0\\n      \\n      if C >= X:\\n          return X / rate\\n      \\n      while cookies < X:\\n          if cookies < C:\\n              wait_time = (C - cookies) / rate\\n              time += wait_time\\n              cookies = C\\n          time_if_wait = (X - C) / rate\\n          time_if_buy = X / (rate + F)\\n          if time_if_wait < time_if_buy:\\n              return time + time_if_wait\\n          else:\\n              rate += F\\n              cookies = 0.0\\n  \\n  \\n  if __name__ == \"__main__\":\\n      precalculate()\\n      \\n      assert len(sys.argv) == 2 #only one argument\\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\\n      infile = open(\"%s\" % sys.argv[1], 'r')\\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\\n      \\n      cases = int(infile.readline().strip('\\n'))\\n      for i in range(cases):\\n          \\n          case = read_input(infile)\\n          \\n          output = solve_case(case)\\n          \\n          outfile.write('Case #%i: %s\\n' % (i+1, output))\\n          print 'Case #%i: %s\\n' % (i+1, output)\\n      \\n      infile.close()\\n      outfile.close()\\n", "target": "1", "substitutes": {"self": ["ws", "name", "Self", "package", "op", "val", "object", "http", "c", "parent", "worker", "node", "resp", "per", "event", "ps", "pos", "plus", "patch", "none", "er", "instance", "_", "field", "w", "method", "type", "remote", "os", "plugin", "all", "ack", "s", "app", "call", "process", "f", "o", "user", "e", "full", "module", "client", "d", "default", "p", "now", "config", "context", "master", "host", "form", "v", "layer", "error", "public", "function", "data", "block", "key", "result", "this", "other", "ng", "ok", "load", "lock", "ctx", "proc", "results", "ns", "h", "item", "view", "me", "spec", "ref", "part", "parse", "q", "shared", "py", "cl", "ss", "right", "org", "work", "python", "k", "g", "wrapper"], "func": ["proc", "cf", "ctx", "exec", "module", "loop", "parser", "name", "cb", "default", "rb", "fn", "expr", "package", "enc", "doc", "fun", "conn", "instance", "amd", "val", "pkg", "util", "object", "conv", "aux", "attr", "part", "parse", "partial", "conf", "method", "uc", "function", "mod", "data", "xxx", "job", "Function", "acl", "callback", "pc", "c", "cc", "super", "unc", "wrap", "python", "addr", "sec", "var", "call", "node", "this", "code", "con", "f", "wrapper"], "cache": ["module", "proxy", "play", "ac", "enc", "gc", "list", "config", "count", "image", "css", "get", "map", "pool", "attr", "Cache", "parse", "session", "conf", "dict", "source", "query", "stack", "index", "data", "wrapper", "body", "sync", "base", "c", "lib", "block", "parent", "call", "cycle", "buffer", "site", "db", "con", "chain", "ache", "hash", "lock", "table", "store"], "value": ["name", "default", "weight", "content", "true", "current", "none", "start", "child", "instance", "media", "val", "response", "output", "values", "exp", "number", "v", "object", "root", "Value", "type", "valid", "resource", "function", "element", "index", "data", "one", "all", "new", "create", "key", "parent", "member", "VALUE", "null", "result", "message", "this", "reference", "array"], "args": ["xs", "extra", "events", "name", "words", "ras", "arg", "aults", "values", "cards", "attr", "pack", "atts", "actions", "ins", "fields", "ig", "parts", "argument", "Args", "params", "qs", "doc", "none", "_", "cs", "include", "body", "all", "empty", "blocks", " arguments", "call", "array", "alls", "module", "ids", "changes", "p", "ar", "now", "v", "loc", "ass", "function", "keys", "data", "files", "names", "links", "parents", "ars", "var", "lines", "objects", "results", "members", "vals", "gs", "ns", "rows", "len", "__", "points", "item", "arr", "kw", "ds", "parse", "axis", "ages", "ams", "groups", "items"], "obj": ["ctx", "po", "module", "name", "Object", "fn", "str", "p", "api", "j", " Obj", "op", "instance", "val", "static", "object", " object", "Obj", "dict", "type", "py", "os", "function", "typ", "data", "pointer", "mod", "base", "key", "parent", "init", "node", "tmp", "o", "objects", "js"], "objtype": [" objval", "objectType", "objval", "objectval", "objType", "modType", "modval", " objType", "objecttype", "modtype"], "infile": ["outline", " infolder", " inf", "inline", "outf", "Instream", "Infiles", " instream", "Infilename", "infilename", "INfile", "infolder", "INfiles", "instream", "INfilename", "INfolder", "Infile", "infiles", "inf", "Inline", " inline", "outstream", "outfile", "Infolder", "INstream", "Inf", " infilename", " infiles"]}}
{"code": "\\n  \\n  \\n  \\n  \\n  \\n  \\n  class memoize(object):\\n     \"\"\"Decorator. Caches a function's return value each time it is called.\\n     If called later with the same arguments, the cached value is returned\\n     (not reevaluated).\\n     \"\"\"\\n     def __init__(self, func):\\n        self.func = func\\n        self.cache = {}\\n     def __call__(self, *args):\\n        if not isinstance(args, collections.Hashable):\\n           return self.func(*args)\\n        if args in self.cache:\\n           return self.cache[args]\\n        else:\\n           value = self.func(*args)\\n           self.cache[args] = value\\n           return value\\n     def __repr__(self):\\n        '''Return the function's docstring.'''\\n        return self.func.__doc__\\n     def __get__(self, obj, objtype):\\n        '''Support instance methods.'''\\n        return functools.partial(self.__call__, obj)\\n  \\n  \\n  def precalculate():\\n      \"\"\"Perform any calculations that need to be performed before the main path\\n      (e.g., preparing lookup tables, etc.)\\n      \\n      N.B. Make sure you make any important variables global so that other\\n      functions can access them.\\n      \"\"\"\\n      pass\\n  \\n  def read_input(infile):\\n      \"\"\"This function should take an open input file, load in all of the\\n      relevant information for a single case of the problem, and output it\\n      as a single object.    \\n      \"\"\"\\n      def read_int():\\n          return int(infile.readline().strip())\\n      def read_ints():\\n          return np.array(infile.readline().split(), dtype=int)\\n      def read_bigints(): #For ints that won't fit directly in an int32 array\\n          line = infile.readline().split()\\n          return np.array(map(lambda x: int(x), line))\\n      def read_float():\\n          return float(infile.readline().strip())\\n      def read_floats():\\n          return np.array(infile.readline().split(), dtype=float)\\n      def read_string():\\n          return infile.readline().strip()\\n      def read_strings():\\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\\n      \\n      R, C, M = read_ints()\\n      \\n      return R, C, M\\n  \\n  def solve_case(case):\\n      \"\"\"Take the input data (structured in case) and perform any necessary\\n      calculations to obtain the desired output, formatted as the appropriate\\n      string.    \\n      \"\"\"\\n      R, C, M = case\\n      \\n      free = R * C - M\\n      assert free >= 1\\n      \\n      board = np.zeros((R, C), dtype=int) - 1\\n      \\n      def write_board(board):\\n          d = {0:'.', 1:'c', 2:'*'}\\n          s = \"\\n\"\\n          for row in board:\\n              for num in row:\\n                  try:\\n                      s += d[num]\\n                  except KeyError:\\n                      raise ValueError(\"Board not filled in!\")\\n              s += \"\\n\"\\n          return s\\n      \\n      board[0,0] = 1\\n      \\n      if M == 0:\\n          board[board == -1] = 0\\n          return write_board(board)\\n      \\n      if free == 1:\\n          board[board == -1] = 2\\n          return write_board(board)\\n          \\n      \\n      while min(R, C) <= M:\\n          if R < C:\\n              board[:,C-1] = 2\\n              C -= 1\\n              M -= R\\n          elif C <= R:\\n              board[R-1,:] = 2\\n              R -= 1\\n              M -= C\\n      \\n      def cascades(board, r, c):\\n          rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]\\n          cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]\\n          for r in rows:\\n              for c in cols:\\n                  if board[r,c] == 2: #Mine next to given position\\n                      return False\\n          return True\\n      \\n      if M == 0:\\n          board[board == -1] = 0\\n          if cascades(board, 0, 0):\\n              return write_board(board)\\n          else:\\n              return \"\\nImpossible\"\\n      \\n      \\n      if M > (R + C - 5):\\n          return \"\\nImpossible\"\\n          \\n      if M > 0 and (R <= 2 or C <= 2):\\n          return \"\\nImpossible\"\\n          \\n      print M, R + C - 5\\n      fill_num = min(M, R - 2)\\n      print M, fill_num\\n      board[(R - fill_num):,C-1] = 2\\n      M -= fill_num\\n      \\n      fill_num = min(M, C - 3)\\n      print M, fill_num\\n      board[R-1,(C - fill_num - 1):] = 2\\n      M -= fill_num\\n      \\n      board[board == -1] = 0\\n      return write_board(board)\\n  \\n  \\n  if __name__ == \"__main__\":\\n      precalculate()\\n      \\n      assert len(sys.argv) == 2 #only one argument\\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\\n      infile = open(\"%s\" % sys.argv[1], 'r')\\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\\n      \\n      cases = int(infile.readline().strip('\\n'))\\n      for i in range(cases):\\n          \\n          case = read_input(infile)\\n          \\n          output = solve_case(case)\\n          \\n          outfile.write('Case #%i: %s\\n' % (i+1, output))\\n          print 'Case #%i: %s\\n' % (i+1, output)\\n      \\n      infile.close()\\n      outfile.close()\\n", "target": "1", "substitutes": {"self": ["ws", "name", "Self", "package", "op", "val", "object", "http", "c", "parent", "worker", "node", "resp", "per", "event", "ps", "pos", "plus", "patch", "none", "er", "instance", "_", "field", "w", "method", "type", "remote", "os", "plugin", "all", "ack", "s", "app", "call", "process", "f", "o", "user", "e", "full", "module", "client", "d", "default", "p", "now", "config", "context", "master", "host", "form", "v", "layer", "error", "public", "function", "data", "block", "key", "result", "this", "other", "ng", "ok", "load", "lock", "ctx", "proc", "results", "ns", "h", "item", "view", "me", "spec", "ref", "part", "parse", "q", "shared", "py", "cl", "ss", "right", "org", "work", "python", "k", "g", "wrapper"], "func": ["proc", "cf", "ctx", "exec", "module", "loop", "parser", "name", "cb", "default", "rb", "fn", "expr", "package", "enc", "doc", "fun", "conn", "instance", "amd", "val", "pkg", "util", "object", "conv", "aux", "attr", "part", "parse", "partial", "conf", "method", "uc", "function", "mod", "data", "xxx", "job", "Function", "acl", "callback", "pc", "c", "cc", "super", "unc", "wrap", "python", "addr", "sec", "var", "call", "node", "this", "code", "con", "f", "wrapper"], "cache": ["module", "proxy", "play", "ac", "enc", "gc", "list", "config", "count", "image", "css", "get", "map", "pool", "attr", "Cache", "parse", "session", "conf", "dict", "source", "query", "stack", "index", "data", "wrapper", "body", "sync", "base", "c", "lib", "block", "parent", "call", "cycle", "buffer", "site", "db", "con", "chain", "ache", "hash", "lock", "table", "store"], "value": ["name", "default", "weight", "content", "true", "current", "none", "start", "child", "instance", "media", "val", "response", "output", "values", "exp", "number", "v", "object", "root", "Value", "type", "valid", "resource", "function", "element", "index", "data", "one", "all", "new", "create", "key", "parent", "member", "VALUE", "null", "result", "message", "this", "reference", "array"], "args": ["xs", "extra", "events", "name", "words", "ras", "arg", "aults", "values", "cards", "attr", "pack", "atts", "actions", "ins", "fields", "ig", "parts", "argument", "Args", "params", "qs", "doc", "none", "_", "cs", "include", "body", "all", "empty", "blocks", " arguments", "call", "array", "alls", "module", "ids", "changes", "p", "ar", "now", "v", "loc", "ass", "function", "keys", "data", "files", "names", "links", "parents", "ars", "var", "lines", "objects", "results", "members", "vals", "gs", "ns", "rows", "len", "__", "points", "item", "arr", "kw", "ds", "parse", "axis", "ages", "ams", "groups", "items"], "obj": ["ctx", "po", "module", "name", "Object", "fn", "str", "p", "api", "j", " Obj", "op", "instance", "val", "static", "object", " object", "Obj", "dict", "type", "py", "os", "function", "typ", "data", "pointer", "mod", "base", "key", "parent", "init", "node", "tmp", "o", "objects", "js"], "objtype": [" objval", "objectType", "objval", "objectval", "objType", "modType", "modval", " objType", "objecttype", "modtype"], "infile": ["outline", " infolder", " inf", "inline", "outf", "Instream", "Infiles", " instream", "Infilename", "infilename", "INfile", "infolder", "INfiles", "instream", "INfilename", "INfolder", "Infile", "infiles", "inf", "Inline", " inline", "outstream", "outfile", "Infolder", "INstream", "Inf", " infilename", " infiles"]}}
{"code": "\\n  \\n  \\n  class Cookie_2014_QB(puzutils.CodeJamProblem):\\n    def __init__(self, inputFilename):\\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\\n  \\n      self.T = None\\n  \\n    def load(self):\\n      \"\"\"\\n        input:\\n  \\n        T (number of test cases)\\n  \\n        C F X (real numbers)\\n  \\n      \"\"\"\\n  \\n      self.tests = []\\n  \\n      with open(self.inputFilename, \"rt\") as file:\\n        self.T = int(file.readline().strip())\\n  \\n        for i in xrange(self.T):\\n          (C,F,X) = [float(x) for x in file.readline().split(' ')]\\n  \\n          self.tests.append([C,F,X])\\n  \\n      return True\\n  \\n    def timeToNextFarm(self, C, rate):\\n      \"\"\"\\n        How long in seconds until we get the next farm.\\n      \"\"\"\\n  \\n      return (C * 1.0) / rate\\n  \\n    def timeToTarget(self, C, X, rate):\\n      \"\"\"\\n        How long in seconds until we hit the target.\\n      \"\"\"\\n  \\n      return ( X * 1.0) / rate\\n  \\n    def isFarmWorthIt(self, C, X, F, rate):\\n  \\n      withoutFarm = self.timeToTarget(C, X, rate)\\n      withFarm = self.timeToNextFarm(C, rate) + self.timeToTarget(C, X, rate + F)\\n  \\n  \\n      if (withFarm < withoutFarm):\\n        return True\\n      else:\\n        return False\\n  \\n    def executeTest(self, test):\\n      \"\"\"\\n        Run a test and return output.\\n      \"\"\"\\n  \\n      (C,F,X) = test\\n      rate = 2\\n      elapsed = 0.0\\n  \\n  \\n      while True:\\n        if self.isFarmWorthIt(C, X, F, rate):\\n          elapsed = elapsed + self.timeToNextFarm(C, rate)\\n          rate = rate + F\\n        else:\\n          elapsed = elapsed + self.timeToTarget(C, X, rate)\\n          return \"%0.7f\" % (elapsed, )\\n  \\n  with Cookie_2014_QB(sys.argv[1]) as problem:\\n    problem.load()\\n  \\n    problem.run()\\n", "target": "2", "substitutes": {"self": ["ws", "name", "args", "proxy", "Self", "mp", "manager", "auto", "case", "object", "http", "kernel", "day", "c", "parent", "worker", "us", "node", "event", "pos", "driver", "plus", "dev", "er", "instance", "_", "writer", "w", "method", "type", "remote", "l", "system", "plugin", "all", "time", "app", "f", "user", "server", "e", "full", "client", "default", "p", "lf", "now", "context", "master", "host", "file", "form", "co", "layer", "error", "public", "m", "data", "g", "this", "other", "ng", "load", "bug", "private", "ctx", "results", "high", "cmp", "hand", "view", "conn", "r", "handler", "spec", "ref", "group", "part", "home", "connection", "session", "q", "shared", "cl", "clock", "comp", "right", "job", "func", "cache", "work", "k", "es", "wrapper"], "inputFilename": [" inputSourceFile", " inputFile", "inputfilename", "outputSourceFile", "Inputfilename", "InputSourceFile", " inputfilename", "inputFile", "tempFilename", "outputfilename", "tempFile", "InputFile", "inputSourceFile", "InputFilename", "outputFilename", "outputFile", "tempfilename", "tempSourceFile"], "T": ["N", "Length", "G", "TF", "TN", "Time", "O", "LT", "TS", "TB", "W", "t", "TA", "M", "Z", "K", "TH", "L", "WT", "D", "R", "B", "S", "TT", "Ts", "TG", "TE", "E", "H", "V", "PT", "NT", "Y", "P", "TL", "TI"], "tests": ["classes", "results", "amples", "thumbnails", "jobs", "events", "reads", " Tests", "packs", "services", "features", "TS", "sections", "tested", "cases", "types", "forms", "Times", "suits", "scripts", "locks", "groups", "models", "checks", "files", "times", "tracks", "projects", "reports", "ests", "testers", "modules", "lines", "runs", "ts", "steps", "testing"], "i": ["e", "ip", " l", "id", "p", " I", "j", "I", " e", "z", " z", "t", "io", " iP", "n", "index", " ii", "c", "ix", "y", " v", "ind", "f", " j", " bit", " ip"], "C": ["N", "CF", "Count", "JC", "U", "Cs", "G", "Ch", "Co", "SC", "Cu", "O", "CL", "I", "CNN", "Size", "CA", "W", "YC", "M", "NC", "CM", "VC", "K", "CE", "EC", "Core", "GC", "DC", "CP", "Cache", "IC", "Custom", "CW", "CC", "L", "Sc", "D", "A", "R", "CN", "MC", "B", "CD", "S", "CO", "c", "CV", "CR", "E", "H", "CS", "API", "CI", "V", "CU", "Y", "P", "Code", "CT", "Con"], "F": ["Full", "N", "CF", "U", "Fixed", "G", "Fs", "FD", "FP", "OF", "FI", "I", "Size", "If", "IF", "FB", "W", "BF", "FL", "File", "M", "Line", "K", "Fin", "Fi", "FS", "L", "Family", "D", "FO", "EF", "R", "A", "PF", "B", "FM", "UF", "WF", "FC", "GF", "FH", "FA", "FR", "FE", "Fine", "E", "Feed", "H", "Farm", "V", "RF", "FF", "Y", "Inf", "Q", "P", "Far", "f", "FG", "MF", "AF", "FW", "Fe"], "X": ["N", "Test", "WS", "U", "CH", "EL", "ID", "XL", "G", "XP", "ZX", "J", "O", "IX", "Time", "XXX", "I", "CL", "TX", "W", "IP", "File", "M", "Z", "CE", "K", "ICE", "US", "PC", "CP", "CW", "XM", "CC", "L", "EX", "D", "R", "HTTP", "FX", "B", "WH", "Ex", "S", "FC", "Work", "FE", "Or", "E", "H", "CI", "V", "DX", "FF", "WR", "XY", "Y", "Q", "P", "XX", "PE", "CT", "Location"], "x": ["e", "xi", "xs", "event", "name", "px", "xxxxxxxx", "xp", "xf", "fx", "p", "xy", "rx", "z", "t", " ff", "v", " xp", "xb", "w", "index", "ex", " xx", "xc", "xxx", "wx", "xxxx", "xe", "c", "xx", " ex", " y", "ix", "y", " ax", " v", "f", "ax"], "rate": ["TR", "rand", "weight", "duration", "case", "M", "exp", "race", "sleep", "TIME", "CC", "rank", "seed", "c", "stage", "depth", "gain", "delay", "y", "ate", "se", "range", "speed", "du", "rule", "rated", "capacity", "Time", "width", "length", "ride", "ale", "write", "currency", "feed", "type", "sample", "R", "frac", "Scale", "FE", "time", "cycle", "code", "cer", "score", "play", "step", "urrency", "feature", "max", "Rate", "PI", "sum", "date", "rice", "example", "core", "SIZE", "grade", "function", "EE", "rates", "CR", "key", "factor", "E", "ry", "WR", "Y", "cost", "frequency", "rating", "size", "repeat", "unit", "rat", "r", "level", "Z", "report", "Factor", "source", "late", "age", "fare", "D", "Speed", "value", "raw", "erate", "sync", "average", "base", "use", "dy", "fee", "mode", "scale"], "withoutFarm": ["WithoutField", " withoutField", "withoutRoot", "withField", "WithoutRoot", "withRoot", "withoutField", "withfarm", " withoutRoot", " withoutfarm", "withoutfarm", "Withoutfarm", "WithoutFarm"], "withFarm": ["withWan", " withFactory", "WithRoot", "withoutRoot", " withoutWan", "withFactory", "partialFarm", "partialfarm", "withoutWan", "withRoot", "withfarm", " withoutRoot", "WithFarm", "withoutFactory", "partialFactory", " withfarm", "WithWan", "withoutfarm"], "test": ["Test", "event", "train", "fail", "repeat", "unit", "feature", "length", "max", "start", "case", "acc", "_", "v", "example", "iter", "type", "sample", "seed", "valid", "live", "model", "new", "temp", "time", "transfer", "catch", "call", "result", "est", "code", "f", "trial", "server", "scale", "testing"], "elapsed": ["alapsed", "Elapsed", "elayed", "Elrated", "delayed", "elocated", "collrated", "delapse", " elapse", "ellapsed", "lapses", "Elrored", " elapses", " Elapse", "elrored", "collrored", "elapses", "Elayed", "ellapse", "Elocated", "collapse", " Elimated", " elocated", "collapsed", "elaped", "ellimated", "elrated", "elimated", "delrated", "alrated", "elapse", "alocated", " elaped", "velapsed", "alapse", "Elapses", " Elapsed", "velaped", "velapse", "Elimated", "lapsed", "alrored", "lapse", "Elaped", " Elaped", "delapsed", "velrored", "Elapse", "alayed", "lrored", " elrored", "ellaped"]}}
{"code": "\\n  \\n  \\n  class Minesweeper_2014_QC(puzutils.CodeJamProblem):\\n    def __init__(self, inputFilename):\\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\\n  \\n      self.T = None\\n  \\n    def load(self):\\n      \"\"\"\\n        input:\\n  \\n        T (number of test cases)\\n  \\n        R C M (integers)\\n  \\n      \"\"\"\\n  \\n      self.tests = []\\n  \\n      with open(self.inputFilename, \"rt\") as file:\\n        self.T = int(file.readline().strip())\\n  \\n        for i in xrange(self.T):\\n          (R,C,M) = [int(x) for x in file.readline().split(' ')]\\n  \\n          self.tests.append([R,C,M])\\n  \\n      return True\\n  \\n    def boardToString(self, board):\\n      retval = \"\"\\n  \\n      for row in board:\\n        retval = retval + \"\\n\" + \"\".join(row)\\n  \\n      return retval\\n  \\n    def executeTest(self, test):\\n      \"\"\"\\n        Run a test and return output.\\n      \"\"\"\\n  \\n      (R,C,M) = test\\n  \\n      spaces = R * C\\n      blanks = spaces - M\\n  \\n      if (blanks <= 0):\\n        return \"Impossible\"\\n  \\n      board = [['.' for x in range(C)] for y in range(R)]\\n  \\n      board[R-1][C-1] = \"c\"\\n  \\n      badpositions=[]\\n      positions=[]\\n  \\n      for x in xrange(C):\\n        for y in xrange(R):\\n          if (x == (C-1)) and (y == (R-1)):\\n            continue\\n          if (x == (C-1)) and (y == (R-2)):\\n            badpositions.append((x,y))\\n            continue\\n          if (x == (C-2)) and (y == (R-1)):\\n            badpositions.append((x,y))\\n            continue\\n          if (x == (C-2)) and (y == (R-2)):\\n            badpositions.append((x,y))\\n            continue\\n  \\n          positions.append((x,y))\\n  \\n      positions.reverse()\\n  \\n      for x in badpositions:\\n        positions.insert(0, x)\\n  \\n      m = M\\n  \\n      while (m > 0):\\n        if len(positions) <= 0:\\n          return \"Impossible\"\\n  \\n        pos = positions.pop()\\n        (x,y) = pos\\n  \\n        if (board[y][x] != \".\"):\\n          return \"Impossible\"\\n  \\n        board[y][x] = '*'\\n        m = m - 1\\n  \\n      mines = sum([x.count('*') for x in board])\\n  \\n      if (mines != M):\\n        return \"Impossible\"\\n  \\n      if (blanks > 1):\\n        if (R > 1):\\n          if board[R - 2][C - 1] == \"*\":\\n            return \"Impossible\"\\n  \\n        if (C > 1):\\n          if board[R - 1][C - 2] == \"*\":\\n            return \"Impossible\"\\n  \\n        if (R > 1) and (C > 1):\\n          if board[R - 2][C - 2] == \"*\":\\n            return \"Impossible\"\\n  \\n      return self.boardToString(board)\\n  \\n  with Minesweeper_2014_QC(sys.argv[1]) as problem:\\n    problem.load()\\n  \\n    problem.run()\\n", "target": "2", "substitutes": {"self": ["ws", "args", "Self", "case", "student", "object", "http", "c", "parent", "worker", "node", "resp", "event", "driver", "plus", "er", "instance", "writer", "w", "method", "n", "l", "all", "s", "app", "f", "user", "server", "hub", "full", "e", "client", "default", "p", "lf", "context", "host", "static", "file", "form", "comment", "layer", "error", "public", "function", "g", "block", "this", "other", "ng", "load", "private", "ctx", "results", "view", "me", "r", "spec", "ref", "part", "connection", "q", "cl", "base", "func", "cache", "work", "k", "es", "wrapper"], "inputFilename": [" inputSourceFile", " inputFile", "inputfilename", "sourceDirectory", "inputFILE", "outputSourceFile", "Inputfilename", "InputSourceFile", "requestSourceFile", " inputfilename", " inputFILE", "outputFILE", "inputFile", "inputDirectory", "tempFilename", "outputfilename", "tempFile", "sourceSourceFile", "tempDirectory", "InputFile", "inputSourceFile", "sourceFilename", "requestFILE", "InputFilename", "requestFilename", "outputFilename", "outputFile", "sourceFile", "outputDirectory", "requestFile", "tempSourceFile"], "T": ["N", "Test", "U", "Length", "G", "X", "TF", "TN", "O", "LT", "I", "TS", "TB", "W", "t", "TA", "Z", "K", "TH", "L", "WT", "D", "A", "B", "S", "TT", "Ts", "TE", "E", "H", "F", "V", "NT", "Y", "Q", "P", "CT", "TI"], "tests": ["rules", "classes", "results", "amples", "events", "reads", "rows", "testing", "boards", "Testing", "features", "sections", "TS", "cases", "values", "ches", "types", "forms", "tips", "Times", "suits", "scripts", "videos", "tools", "checks", "times", "files", "tracks", "reports", "ests", "testers", "lines", "ports", "runs", "steps", "ts"], "i": ["e", "xi", "ip", "col", "id", "sex", "h", "xp", "xf", "xy", "j", "ace", "I", "u", "iii", "z", "bit", "xb", "io", "axis", "ci", "index", "ei", "ti", "ix", "ind", "f", "o"], "R": ["N", "Rh", "AR", "U", "RH", "G", "X", "SC", "RL", "RE", "J", "O", "RR", "KR", "I", "CL", "MR", "r", "W", "Rs", "Cl", "Z", "Range", "K", "HR", "RC", "DC", "RW", "RO", "SR", "RN", "Right", "Re", "CC", "L", "D", "A", "ER", "JR", "B", "RS", "Rec", "S", "BR", "CR", "E", "H", "F", "IR", "V", "RF", "DR", "RM", "GR", "Run", "Y", "NR", "Q", "P", "LR", "RA", "RG"], "C": ["N", "Cs", "U", "Cr", "CH", "G", "Ch", "X", "SC", "Co", "Cu", "O", "Cl", "CL", "CNN", "I", "CA", "W", "YC", "NC", "CM", "K", "VC", "CE", "EC", "RC", "DC", "CP", "CW", "Ca", "CC", "L", "Sc", "D", "A", "MC", "CN", "B", "S", "CO", "c", "KC", "CV", "CR", "E", "H", "AC", "CS", "CI", "F", "V", "CU", "Y", "Q", "P", "Code", "CT"], "M": ["N", "U", "VM", "ME", "G", "X", "MI", "O", "length", "CL", "I", "MR", "W", "Mass", "MD", "NM", "MS", "CM", "MQ", "EM", "Z", "K", "number", "MX", "n", "L", "CC", "OM", "D", "MN", "Mo", "MC", "FM", "B", "DM", "A", "S", "MB", "CR", "E", "H", "MF", "F", "V", "RM", "Y", "Mac", "Q", "P", "cm", "MM", "LM", "mode", "Multiple"], "x": ["xs", "xt", "name", "px", "sex", "xp", "mx", "case", "number", "cy", "position", "index", "xc", "wx", "xxxx", "xe", "c", "xx", "ax", "event", "X", "word", "ch", "width", "z", "tx", "dx", "ext", "w", "n", "l", "wa", "s", "time", "pe", "ic", "code", "b", "f", "o", "check", "e", "xa", "d", "id", "step", "p", "xy", "j", "match", "rx", "an", "t", "cross", "yx", "on", "v", "yl", "data", "one", "model", "key", "ey", "Y", "ctx", "xi", "ux", "ip", "ay", "h", "xf", "u", "image", "ct", "xb", "q", "cl", "ex", "xxx", "int", "ix", "g"], "board": ["loop", "room", "deck", "bo", "player", "cart", "word", "cube", "coll", "boards", "view", "layout", "list", "channel", "hole", "sequence", "case", "flow", "boarding", "arrow", "form", "co", "object", "comment", "card", "string", "home", "bar", "box", "axis", " boards", "Board", "problem", "core", "rank", "square", "ro", " Board", "block", "back", "ack", "cell", "frame", "reader", "shape", " clipboard", "line", "buffer", "bank", "code", "path", "array", "game", "control", "bug", "table"], "retval": ["returnvals", "interval", "retvalue", "RetVal", " retvalue", "returnVal", "intereval", " retVal", "RETval", "retvals", "RETvalue", "interVal", " retvals", " reteval", "Retvals", "RETvals", "returnval", "Retvalue", "reteval", "RETVal", "retVal", "Reteval", "returnvalue", "Retval"], "row": ["page", "range", "col", "rows", "str", "item", "view", "Row", "ride", "flow", "val", "arrow", "roll", "object", "comment", "error", "string", "record", "feed", "rank", "entry", "value", "raw", "ro", "block", "ack", "round", "key", "cell", "reader", "node", "result", "line", "insert", "buffer", "run", "array", "user", "server", "bug"], "test": ["Test", "xt", "loop", "train", "F", "X", "che", "true", "unit", "p", "match", "arg", "case", "instance", "check", "t", "host", "form", "v", "_", "long", "top", "sub", "string", "mat", "pack", "example", "iter", "slave", "fit", "sample", "py", "valid", "script", "value", "all", "model", "c", "temp", "int", "shape", "result", "call", "min", "line", " Test", "est", "run", "buffer", "code", "pattern", "txt", "array", "f", "trial", "server", "table", "testing"], "spaces": ["Spanks", "stacing", "braces", "branks", "Space", " spanks", "stans", "staces", "stanks", " spans", "space", "Spacing", " spacing", " space", "spans", "brace", "spanks", "Spaces", "brans", "spacing", "Spans"], "blanks": ["placks", "blans", "places", " blaces", "planks", "blacks", " blans", "Blans", "Blanks", "blaces", "plans", "Blank", " blacks", " blank", "plank", "blank", "Blacks", "Blaces"], "y": ["e", "yr", "ys", "ny", "zy", "my", "col", "iy", "yy", "ay", "id", "isy", "ady", "h", "yer", "yt", "ye", "xy", "j", "ch", "sy", "yan", "year", "z", "r", "ky", "t", "ty", "ym", "yl", "hy", "cy", "q", "oy", "ies", "py", "ish", "yi", "c", "iny", "ey", "dy", "yu", "ry", "yo", "ya", "yn", "vy", "Y", "gy", "b", "yd", "o"], "badpositions": [" badposes", "badPoses", "goodposions", "badPosits", "badconditions", "badcondions", "Badpositions", " badositions", "badcondresses", "badPosals", "badnositions", "BadPosition", "BadPosations", "badPosations", "badPosition", "badoses", "badPosites", "badposits", "badpositionites", " badoses", "badposations", "badosions", "badposites", "goodPosresses", "goodPositions", "BadPosites", "badposes", "badcondals", "Badposions", "badPositions", "badlocals", "badcondits", "badposition", "badlocition", "goodPosions", " badposions", "badosations", "Badposations", " badosites", "badosites", " badposations", "Badposition", "goodPosits", "goodpositions", "badpositionations", "badPosions", "badcondition", "badposals", "badositions", " badposites", "badpositionitions", "badnosions", "badnosresses", "BadPosions", "badlocions", " badosations", "goodposresses", " badosions", "badnosits", "badposresses", "BadPosals", "BadPositions", "Badposals", "badlocitions", "badPosresses", "badposions", "Badposites", "badpositiones", "badpositionions", "goodposits"], "positions": ["partitions", "locions", "posals", "posices", "psations", "locitions", "psitions", "posences", "condions", " posations", "partits", "Posals", "posions", "Positions", " posions", "potensions", " posices", "posensions", "Posions", " posensions", " posences", "Posations", "condances", "position", " poselines", "partition", "Position", " posresses", "locresses", "Posresses", "potits", "potitions", " posits", "locations", "conditions", "condations", "partals", "potences", "poselines", " posals", "condresses", "condelines", "Posices", "Posances", " position", "partices", "partensions", "psresses", "psances", "posances", "posresses", "posations", "locelines", "partences", "posits"], "m": ["e", "ms", "mc", "d", "mi", "dm", "mini", "p", "pm", "man", "mu", "sm", "mr", "u", "im", "mm", "r", "z", "bm", "t", "v", "ym", "am", "um", "w", "n", "tm", "l", "machine", "c", "mass", "b", "cm", "f", "o", "meta", "gm"], "pos": ["e", "po", "d", "ps", "pl", "p", "POS", "lab", "object", "cond", "loc", "position", "n", "l", "pro", "trans", "s", " Pos", "st", " POS", " position", "found", "no", "f", "o", "Pos"]}}
{"code": "\\n  \\n  lines = iter('''\\n  5\\n  30.0 1.0 2.0\\n  30.0 2.0 100.0\\n  30.50000 3.14159 1999.19990\\n  500.0 4.0 2000.0\\n  100.0 1.0 100000.0\\n  '''.splitlines(False)[1:])\\n  \\n  lines = iter(open(r'B-small-attempt0.in').readlines(False))\\n  \\n  caseCnt = int(next(lines))\\n  \\n  for case in range(1, caseCnt+1):\\n  \tC, F, X = map(float, next(lines).split())\\n  \t\\n  \tv = 2.0\\n  \ttotal = 0.0\\n  \tgoal = X/v\\n  \twhile 1:\\n  \t\tfarm = C/v + total\\n  \t\tif farm >= goal:\\n  \t\t\tanswer = goal\\n  \t\t\tbreak\\n  \t\tv += F\\n  \t\ttotal = farm\\n  \t\tif goal > X/v + total:\\n  \t\t\tgoal = X/v + total\t\\n  \tprint('Case #%d: %0.6lf'%(case, answer))\\n  \t\\n  \\n", "target": "3", "substitutes": {"lines": ["sheets", "rules", "results", "letters", "ines", "shows", "ids", "rows", "books", "lined", "opens", "cases", "cells", "lins", "ips", "LINE", "ses", "mails", "comments", "iter", "elines", "limit", "es", "pages", "plugins", "l", "nl", "ls", "rooms", "breaks", "locks", " Lines", "zip", "models", "files", "strings", "details", "balls", "blocks", "links", "los", "items", "vs", "line", "limits", "ides", "les", "boxes", "runs", "bytes", "objects"], "caseCnt": ["caseFNT", "CaseCuit", "CaseCnt", "caseNnc", "CaseCn", "caseCnc", "CaseNn", "caseNNT", "CaseCnc", "casecNT", "caseFnt", "CaseNnt", "casecnc", "caseNn", "caseFn", "casecn", "caseCsuit", "caseFnc", "caseCNT", "casecuit", "caseCsNT", "CaseCNT", "caseCuit", "caseCsnt", "caseNnt", "caseCn", "CaseNnc", "caseCsn", "casecnt", "CaseNNT"], "case": ["page", "sea", "name", "id", "cas", "address", "match", "ce", "config", "switch", "instance", "count", "ase", "cases", "number", "change", "race", "game", "position", "uc", "Case", "ice", "c", "bc", "use", "end", "time", "test", "chance", "x", "course", "line", "result", "choice", "code", "f", "trial", "se"], "C": ["N", "CF", "U", "CH", "G", "Co", "O", "CL", "I", "CA", "W", "M", "CM", "DC", "CP", "CC", "L", "D", "A", "Case", "R", "CN", "T", "B", "S", "CO", "c", "CV", "E", "H", "V", "CU", "Y", "Q", "P"], "F": ["N", "CF", "U", "G", "Fs", "FD", "FP", "J", "O", "I", "W", "M", "L", "D", "A", "FO", "R", "T", "PF", "B", "FH", "WF", "FC", "E", "H", "Farm", "V", "Y", "Q", "P", "f", "FW"], "X": ["N", "CF", "U", "CH", "ID", "Max", "XL", "G", "XP", "ZX", "IX", "XXX", "I", "TX", "CA", "W", "Z", "CC", "L", "D", "FO", "R", "T", "FX", "WH", "FA", "WORK", "Work", "CV", "FE", "E", "H", "UX", "VA", "Farm", "V", "x", "FF", "Y", "Q", "P", "XX", "Cross", "FW"], "v": ["e", "size", "U", "nv", "d", "vid", "ov", "vt", "i", "ve", "h", "lv", "p", "j", "cv", "vi", "u", "iv", "r", "ver", "ev", "va", "w", "q", "vr", "n", "m", "l", "vp", "value", "av", "conv", "c", "end", "sv", "k", "vs", "V", "x", "VT", "cover", "vu", "fat", "uv", "f", "version", "b", "P", "trial", "g", "tv"], "total": ["full", "size", "percent", "quant", "free", "gam", "tax", "vt", "step", "final", "tv", "json", "completely", "done", "sav", "current", "length", "max", "general", "complete", "start", "finished", "count", "number", "neutral", "summary", "sum", "random", "error", "root", "stable", "va", "type", "seed", "equal", "major", "valid", "alpha", "grade", "value", "wall", "average", "loss", "all", "gross", "key", "parent", "otal", "token", "Total", "V", "cover", "target", "result", "null", "fee", "cost", "fat", "post", "trial", "net", "scale"], "goal": ["what", "duration", "gam", "cv", "gate", "general", "gan", "student", "balance", "VP", "VA", "gain", "fat", "FG", "version", "event", "alf", "secret", "gap", "random", "ception", "GO", "wall", " goals", "winner", "f", "game", "CF", "profit", "G", "TV", "score", "done", "sale", "response", "FH", "V", "result", "jump", "FF", "cost", "trial", "size", "rage", "final", "fi", "performance", "Goal", "neutral", "home", "FO", "value", "FA", "average", "loss", "gross", "CV", "guide", "scale"], "farm": ["profit", "family", "account", "folio", "feature", "aff", "fake", "performance", "af", "number", "field", "root", "front", "practice", "fork", "plan", "fp", "FH", "FA", "risk", "job", "hunt", "runner", "winner", "fan", "paid", "Farm", "worker", "V", "result", "cover", "fee", "cost", "fat", "f", "FG"], "answer": ["rage", "vid", "evidence", "score", "ve", " experience", "ee", "folio", "ace", "vari", "vi", "acre", "offer", "question", "response", "neutral", "occup", "error", "random", "practice", "race", "agent", "query", "balance", "age", "grade", "say", "order", "au", "average", "issue", "winner", "venture", "venue", "chance", "gain", "result", "cover", "episode", "fee", "err", "array", "fen", "trial", "Answer"]}}
{"code": "\\n  lines = iter('''\\n  13\\n  5 5 23\\n  3 1 1\\n  1 3 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  10 1 4\\n  1 10 5\\n  2 10 8\\n  10 2 8\\n  2 10 9\\n  10 2 7\\n  5 3 3\\n  '''.splitlines(False)[1:])\\n  out = sys.stdout\\n  \\n  sys.setrecursionlimit(1500)\\n  \\n  \\n  class MyException(Exception):\\n  \tpass\\n  lines = iter(open(r'C-small-attempt7.in').readlines(False))\\n  out = open('c-small.answer', 'w')\\n  \\n  def solve(C, R, M):\\n  \tboard = [['.']*C for _ in range(R)]\\n  \tboard[-1][-1] = 'c'\\n  \ttry:\\n  \t\tfor r in range(R-2):\\n  \t\t\tfor c in range(C-2):\\n  \t\t\t\tif r == R-3 and c == C-3:\\n  \t\t\t\t\traise StopIteration()\\n  \t\t\t\tboard[r][c] = '*'\\n  \t\t\t\tM -= 1\\n  \t\t\t\tif M == 0:\\n  \t\t\t\t\treturn board \\n  \texcept StopIteration:\\n  \t\tpass\\n  \t\t\\n  \tif M % 2 == 0:\\n  \t\tfor r in range(R-3):\\n  \t\t\tboard[r][C-1] = '*'\\n  \t\t\tboard[r][C-2] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\tfor c in range(C-3):\\n  \t\t\tboard[R-1][c] = '*'\\n  \t\t\tboard[R-2][c] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\t\\n  \t\t\\n  \t\traise MyException()\\n  \telse:\\n  \t\tboard[R-3][C-3] = '*'\\n  \t\tM -= 1\\n  \t\tif M == 0:\\n  \t\t\treturn board\\n  \t\tfor r in range(R-2):\\n  \t\t\tboard[r][C-1] = '*'\\n  \t\t\tboard[r][C-2] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\tfor c in range(C-2):\\n  \t\t\tboard[R-1][c] = '*'\\n  \t\t\tboard[R-2][c] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\t\\n  \t\traise MyException()\\n  \t\t\\n  \t\\n  caseCnt = int(next(lines))\\n  \\n  for case in range(1, caseCnt+1):\\n  \tR,C,M = map(int, next(lines).split())\\n  \t\\n  \tprint('Case #%d:'%case, file=out)\\n  \tif M == 0:\\n  \t\tprint('c' + '.'*(C-1), file=out)\\n  \t\tfor _ in range(R-1):\\n  \t\t\tprint('.'*C, file=out)\\n  \telif R*C==M+1:\\n  \t\tprint('c' + '*'*(C-1), file=out)\\n  \t\tfor _ in range(R-1):\\n  \t\t\tprint('*'*C, file=out)\\n  \telif C == 1 and R == 1:\\n  \t\tprint('Impossible', file=out)\\n  \telif C == 1:\\n  \t\tif M > R-1:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c', file=out)\\n  \t\t\tfor _ in range(R-M-1):\\n  \t\t\t\tprint('.', file=out)\\n  \t\t\tfor _ in range(M):\\n  \t\t\t\tprint('*', file=out)\\n  \telif R == 1:\\n  \t\tif M > C-1:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c' + '.'*(C-M-1) + '*'*M, file=out)\\n  \telif C == 2:\\n  \t\tif M %2 or M//2 > R-2:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c.', file=out)\\n  \t\t\tfor _ in range(R-M//2-1):\\n  \t\t\t\tprint('..', file=out)\\n  \t\t\tfor _ in range(M//2):\\n  \t\t\t\tprint('**', file=out)\\n  \telif R == 2:\\n  \t\tif M %2 or M//2 > C-2:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)\\n  \t\t\tprint(      '.'*(C-M//2)   + '*'*(M//2), file=out)\\n  \telif M > R*C-4:\\n  \t\tprint('Impossible', file=out)\\n  \telse:\\n  \t\ttry:\\n  \t\t\tboard = solve(C, R, M)\\n  \t\t\tfor line in board:\\n  \t\t\t\tprint(''.join(line), file=out)\\n  \t\texcept MyException:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\\n  \t\\n", "target": "3", "substitutes": {"lines": ["rules", "letters", "drivers", "ines", "ids", "rows", "inline", "books", "lo", "boards", "codes", "holes", "errors", "cells", "lins", "Line", "ips", "lights", "lin", "sticks", "LINE", "ses", "mails", "comments", "elines", "pages", "log", "plugins", "l", "ls", "rooms", "breaks", "scenes", "locks", "models", "headers", "frames", "files", "strings", "posts", "faces", "balls", "blocks", "links", "los", "items", "limits", "ze", "users", "boxes", "ances", "f", "runs", "bytes", "ipes", "objects", "liners"], "out": ["client", "name", "OUT", "word", "ac", "doc", "outs", "list", "inner", "channel", "image", "sys", "output", "file", "co", "comment", "io", "error", "writer", "w", "again", "problem", "log", "dot", "data", "block", "user", "bin", "parent", "call", "result", "buffer", "code", "err", "array", "o", "copy", "net", "Out"], "C": ["N", "Country", "Count", "Cs", "U", "G", "Ch", "Cor", "X", "Co", "Cu", "Channel", "O", "WC", "I", "CL", "Size", "CA", "W", "Rs", "Cl", "CM", "VC", "K", "EC", "Z", "RC", "DC", "From", "CC", "L", "Sc", "D", "A", "Chain", "T", "B", "Rec", "S", "CR", "E", "H", "AC", "F", "V", "Y", "Q", "P", "Code", "St", "Col"], "R": ["N", "Rh", "U", "RH", "G", "Ch", "X", "Co", "RL", "J", "O", "Row", "RR", "I", "W", "Rs", "Cl", "Line", "K", "RC", "RW", "SR", "RO", "Right", "Re", "Group", "L", "Sc", "D", "A", "JR", "T", "B", "RS", "Rec", "Record", "S", "CR", "E", "H", "F", "IR", "V", "Run", "RM", "All", "Rev", "Y", "Ra", "Q", "P", "Code", "Read", "Review", "Cr", "Range"], "M": ["N", "MD", "U", "MO", "G", "ME", "X", "MI", "ARM", "J", "Me", "O", "I", "W", "TM", "MAL", "MQ", "MS", "CM", "K", "JM", "NM", "ML", "Z", "SM", "MT", "Mor", "MX", "m", "MN", "L", "OM", "Mo", "D", "A", "EM", "MC", "T", "FM", "B", "DM", "OR", "S", "MA", "IM", "MB", "E", "H", "MF", "AM", "F", " m", "V", "Ms", "RM", "All", "Y", "Q", "P", "MM", "LM", "PM"], "board": ["che", "boards", " row", "sequence", "ward", "design", "object", "student", "row", "problem", "rank", "back", " game", "stroke", "bridge", "table", "loop", "event", "ault", "bo", "player", "word", "ode", "join", "ban", "cat", "feed", "broad", "video", "body", " Board", "ack", "call", "code", "b", "array", "foot", "game", "lay", "client", "d", "deck", "cart", "play", "p", "layout", "channel", "lane", "form", "flo", "co", "comment", "error", "Board", "core", "function", "square", "one", "block", "model", "head", "ide", "frame", "result", "void", "sc", "draw", "bug", "ion", "room", "coll", "view", "que", "point", "list", "hole", "ba", "builder", "flow", "boarding", "stream", "land", "home", "entry", "boy", "oard", "work", "rock", " clipboard", "road", "catch", "bank", "door", "control", "menu"], "_": ["i", "h", "p", "t", "row", "rec", "l", "all", "x", "code", "con", "f"], "r": ["e", "range", "yr", "rr", "rb", "br", "d", "i", "nor", "rc", "h", "p", "ur", "pr", "ch", "RR", "ar", "j", "mr", "u", "er", "t", "Rs", "v", "lr", "ir", "re", "w", "q", "m", "n", "l", "ru", "right", "g", "ro", "all", "a", "rn", "k", "rs", "x", "rd", "sr", "nr", "b", "rg", "f", "err", "cr", "o", "P"], "c": ["col", "name", "rec", "uc", "cy", "ca", "orc", "unc", "rn", "y", "cm", "fc", "ch", "count", "z", "cat", "cs", "w", "n", "l", "cor", "cd", "cc", "a", "x", "cycle", "code", "b", "f", "o", "roc", "e", "d", "i", "rc", "dc", "p", "ce", "channel", "t", "v", "m", "ci", "cont", "ec", "sc", "chain", "cf", "mc", "h", "ac", "coll", "u", "ct", "cu", "cur", "q", "cl", "cache", "anc", "k", "nc", "path", "arc", "cn", "cr", "cp", "g", "lc"], "caseCnt": [" caseCNT", "caseCtx", " caseCn", "caseSctx", " casector", "caseGCtor", "caseCtor", "caseGCNT", " casectx", "casecNT", " caseCtor", "casecn", "caseScnt", "caseSctor", " casecnt", "caseGCnt", " casecNT", "caseCNT", "caseScn", "casector", "casectx", " casecn", "caseScNT", " caseCtx", "caseGCn", "caseCn", "casecnt"], "case": ["range", "section", "match", "max", "length", "ace", "ase", "cases", "number", "row", "loc", "m", "Case", "block", "bc", "end", "time", "character", "when", "x", "choice", "code"]}}
{"code": "\\n  T = int(raw_input())\\n  for test_case in xrange(1, T + 1):\\n      C, F, X = map(float, raw_input().split())\\n      answer = X / 2\\n      i = 0\\n      last_tc = 0\\n      while True:\\n          tc = last_tc + C / (2 + (i * F))\\n          if answer < tc:\\n              break\\n          answer = min(tc + X / (2 + (i + 1) * F), answer)\\n  \\n          i += 1\\n          last_tc = tc\\n      print 'Case #{}: {:.7f}'.format(test_case, answer)\\n", "target": "4", "substitutes": {"T": ["N", "U", "G", "TF", "TN", "Time", "O", "I", "TS", "TB", "W", "t", "M", "Z", "L", "WT", "D", "A", "TW", "R", "Tu", "B", "S", "TT", "TC", "E", "H", "V", "Y", "Q", "P", "TI"], "test_case": ["testrdefinition", "fixobjinstance", "case2test", "test_name", "test2case", "test_test", "test_definition", "testvalcase", "testvalline", "testobjcase", "testrcase", "case_test", "case2name", "fixobjdefinition", "fix_definition", "fix_name", "test2line", "testrname", "fixobjname", "case2line", "fix_instance", "testobjname", "testobjdefinition", "case_name", "testvaltest", "test_line", "case2case", "fixobjcase", "fix_case", "test_instance", "case_case", "test2name", "testobjinstance", "case_line", "testvalname", "testrinstance", "test2test"], "C": ["N", "CF", "Cs", "JC", "U", "G", "Cu", "O", "I", "CNN", "CA", "W", "M", "Z", "K", "CM", "EC", "DC", "CC", "L", "D", "A", "R", "B", "S", "c", "CV", "E", "CI", "V", "CU", "Y", "Q", "P"], "F": ["N", "CF", "U", "Fixed", "G", "Fs", "FD", "DF", "OF", "FI", "O", "I", "IF", "FB", "W", "BF", "M", "Z", "K", "FIN", "L", "D", "FO", "EF", "R", "PF", "B", "GF", "FH", "FM", "E", "H", "SF", "V", "RF", "FF", "Y", "Q", "P", "f", "AF"], "X": ["N", "Test", "U", "ID", "XL", "G", "XP", "IX", "XXX", "I", "CL", "TX", "W", "Z", "CE", "EC", "XM", "CC", "L", "R", "IO", "B", "S", "FC", "TC", "E", "H", "UX", "x", "V", "FF", "Y", "Q", "P", "XX", "PE", "Answer"], "answer": ["duration", " answering", " explanation", "address", "complete", "sequence", "number", "CC", "equ", "ice", "text", "c", "fe", "cover", "reply", " result", "err", "cm", "option", "version", "Answer", "evidence", " answered", "current", "ace", "z", "question", "margin", "ception", "ell", "issue", "fix", "a", "test", "x", "sr", "array", "f", "e", "update", "score", "rc", "next", "answered", "now", "response", "form", "grade", "say", "A", "expression", "new", "E", "result", "term", "size", "results", "ee", " answers", "su", "r", "string", "FIX", "average", "cache", "int", " Answer", "message", "choice", "fee"], "i": ["e", "gi", "si", "ini", "xi", "mini", "p", "j", "I", "vi", "u", "zi", "ie", "multi", "z", "li", "t", "ai", "ui", "pi", "v", "ni", "it", "io", "uri", "n", "ci", "l", "ii", "index", "ei", "bi", "ti", "di", "c", "int", "a", "init", "ic", "x", "ix", "y", "oi", "iu", "b", "f", "info", "qi"], "last_tc": ["last_cm", "last_mc", " last_lc", " last_cm", " last__TC", "last__TC", " last__mc", "last__lc", "last__tc", "last_lc", "last_TC", " last_TC", " last_mc", " last__tc", " last_cu", "last__mc", "last_cu", " last__lc"], "tc": ["cf", "tt", "e", "mc", "UC", "cb", "uca", " TC", "rc", "ta", "pb", "ac", "dc", "su", "case", "kk", "t", "tf", "cu", "race", "cs", "loc", "tk", "uc", "BC", "ci", "cum", "ctrl", "ice", "tn", "xc", "FC", "pc", "cache", "c", "TC", "bc", "cc", "toc", "temp", "test", "ic", "CI", "ec", "k", "nc", "tmp", "term", "sc", "cm", "fc", "cr", "icc", "lc"]}}
{"code": "\\n  T = int(raw_input())\\n  for test_case in xrange(1, T + 1):\\n      R, C, M = map(int, raw_input().split())\\n      N = R * C\\n      B = N - M\\n  \\n      W, H = (C, R) if R <= C else (R, C)\\n  \\n      if H == 1:\\n          answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]\\n      elif M == N - 1:\\n          answer = [['*'] * W for r in xrange(H)]\\n          answer[0][0] = 'c'\\n      elif B < 4 or B in (5, 7):\\n          answer = None\\n      elif H == 2:\\n          if M % 2 == 0:\\n              bw = B / 2\\n              answer = [\\n                  ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),\\n                  ['.'] * bw + ['*'] * (W - bw),\\n              ]\\n          else:\\n              answer = None\\n      else:\\n          answer = [['*'] * W for y in xrange(H)]\\n          answer[0][0] = 'c'\\n          answer[0][1] = answer[1][0] = answer[1][1] = '.'\\n          left = B - 4\\n          if 2 <= left:\\n              answer[0][2] = answer[1][2] = '.'\\n              left -= 2\\n          if 2 <= left:\\n              answer[2][0] = answer[2][1] = '.'\\n              left -= 2\\n  \\n          x = y = 3\\n          while (x < W or y < H) and 2 <= left:\\n              if x < W and 2 <= left:\\n                  answer[0][x] = answer[1][x] = '.'\\n                  left -= 2\\n                  x += 1\\n              if y < H and 2 <= left:\\n                  answer[y][0] = answer[y][1] = '.'\\n                  left -= 2\\n                  y += 1\\n  \\n          y = 2\\n          while 0 < left and y < H:\\n              x = 2\\n              while 0 < left and x < W:\\n                  answer[y][x] = '.'\\n                  left -= 1\\n                  x += 1\\n              y += 1\\n  \\n      if answer is None:\\n          answer = 'Impossible'\\n      else:\\n          if W == R:\\n              answer = map(list, zip(*answer))\\n          assert len(answer) == R\\n          assert len(answer[0]) == C\\n          assert sum(row.count('*') for row in answer) == M\\n          answer = '\\n'.join([''.join(row) for row in answer])\\n      print 'Case #{}:\\n{}'.format(test_case, answer)\\n", "target": "4", "substitutes": {"T": ["U", "X", "TN", "Time", "O", "TS", "TB", "t", "Z", "K", "TH", "L", "WT", "D", "A", "S", "TT", "TC", "E", "F", "V", "NT", "Y", "P"], "test_case": ["testmatchlength", "testmatchcase", "estmatchcase", "est_choice", "testvalcase", "estmatchlength", "testvalchoice", "test_length", "est_length", "testmatchab", "est_case", "test_ab", "testvalab", "testmatchchoice", "estmatchab", "est_ab", "test_choice", "estmatchchoice", "testvallength"], "R": ["U", "G", "X", "O", "RR", "Rs", "K", "SR", "RN", "RO", "L", "D", "A", "RS", "S", "CR", "E", "F", "V", "RM", "Y", "NR", "Q", "P", "RA"], "C": ["Cs", "U", "G", "X", "Co", "O", "CL", "CNN", "I", "CA", "NC", "CM", "K", "CE", "Z", "VC", "DC", "CC", "L", "D", "A", "CN", "S", "CO", "c", "CR", "E", "CI", "F", "V", "CU", "Q", "P", "CT"], "M": ["U", "G", "X", "J", "O", "I", "MD", "Z", "CM", "K", "SM", "MT", "m", "MN", "L", "D", "A", "MC", "S", "MA", "MB", "E", "F", "V", "RM", "Y", "Q", "P", "LM"], "N": ["U", "NN", "G", "X", "Wh", "J", "O", "I", "NE", "NM", "NC", "Z", "K", "RN", "n", "MN", "L", "NL", "D", "A", "S", "E", "Ni", "Ne", "Ns", "F", "V", "NH", "NT", "Y", "NS", "P"], "B": ["GB", "U", "bb", "ob", "G", "X", "AB", "J", "O", "I", "Ab", "TB", "BB", "BF", "BM", "WB", "Z", "Two", "K", "NB", "BC", "L", "D", "A", "ub", "S", "Bl", "BI", "MB", "Base", "E", "F", "V", "Sp", "Y", "Q", "b", "P", " b", "Bs", "BL", "mb"], "W": ["WS", "Word", "U", "G", "X", "MW", "Win", "Wh", "Web", "O", " w", "WC", "Wi", "VW", "WB", "Z", "tw", "WA", "K", "WE", "CW", "w", "Weight", "L", "FW", "WT", "D", "BW", "A", "WM", "TW", "We", "DW", "S", "WH", "Width", "SW", "Wa", "E", "F", "V", "WR", "NW", "wh", "Y", "GW", "Q", "P", "sw", "Sw", "Tw"], "H": ["U", "CH", "RH", "G", "Ch", "X", "GH", "h", "J", "HS", "Wh", "O", "HH", "EH", "HP", "HK", "Z", "K", "TH", "L", "Ha", "D", "A", "SH", "WH", "S", "HI", "E", "F", "V", "OH", "HC", "Y", "Q", "P", "MH", "DH", "Sw"], "answer": ["uit", "duration", "edition", " answering", "bet", " explanation", "address", "complete", "number", "object", "ew", "enum", "equ", "knowledge", "office", "cover", "reply", " result", "request", "reference", "err", "option", "search", "information", "Answer", "page", "event", "evidence", "swers", "word", "altern", "attribute", "z", "question", "field", "align", "ell", "edge", "replace", "video", "element", "une", "issue", "do", "array", "evaluate", "adapt", "e", "settings", "update", "account", "remember", "next", "document", "answered", "username", "response", "form", "comment", "error", "example", "grade", "A", "expression", "data", "result", "Y", "accept", "article", "results", "music", "memory", "activity", "correct", "ee", "content", "archive", " answers", "after", "image", "see", "offer", "output", "string", "ae", "respond", "support", "audio", "entry", "value", "agree", "average", "cache", "energy", " Answer", "description", "null", "message", "open", "episode"], "r": ["e", "d", "i", "X", "h", "p", "ur", "u", "z", "ir", "re", "ow", "n", "m", "g", "c", "s", "int", "a", "k", "rs", "rd", "Y", "b"], "bw": [" bws", "fw", "fwa", "wwin", "Bwin", "dwa", "ww", "Bp", "cw", "bbwl", " bwin", "dW", "Bwl", "wws", "pw", "fsw", "Bws", "pW", " bwe", "fwe", "bbwa", "bws", "csw", "bbw", "BW", "dw", "bwe", "dwl", "pwd", "Bw", "Bwa", "pwa", " bwd", "bbW", "bsw", "bW", "cwa", "wp", "bwin", " bsw", "bwl", "bp", " bp", "bwd", " bwa", "fwd", " bW", "cwe", "fW", "bwa"], "y": ["e", "yr", "ys", "ny", "zy", "d", "col", "iy", "ay", "yy", "i", "X", "h", "yt", "ye", "xy", "sy", "j", "p", "year", "z", "t", "ty", "yp", "v", "ym", "ly", "yl", "hy", "w", "cy", "rot", "ow", "m", "oy", "py", "n", "l", "type", "ot", "ii", "ish", "any", "yi", "c", "iny", "key", "ey", "dy", "ry", "yo", "ya", "yn", "height", "xx", "vy", "Y", "gy", "b", "yd", "ind", "ate", "o", "fy"], "left": ["col", "pl", "out", "auto", "lt", "exp", "text", "end", "rights", "off", "P", "bottom", "elt", "plus", "X", "width", "length", "none", "join", "top", "ell", "L", "l", "inside", "local", "wall", "all", "le", "ignore", "f", "o", "low", "full", "default", "self", "center", "next", "p", "inner", "down", "cross", "rel", "error", "leave", "NL", "el", "function", "S", "one", "key", "st", "min", "cost", " right", "outside", "Left", " Left", "str", "lo", "FT", "list", "column", "lower", "level", "Z", "wrong", "Lo", "ST", "small", "Right", "cl", "fl", "value", "right", "both", "null", "line", "two", "path", "no"], "x": ["e", "xi", "xs", "my", "d", "name", "ay", "id", "i", "px", "X", "sex", "step", "h", "xp", "p", "xy", "fx", "j", "width", "en", "z", "rx", "t", "cross", "yx", "on", "v", "yl", "na", "dx", "w", "cy", "q", "n", "m", "l", "index", "ex", "wa", "right", "xc", "any", "one", "xxx", "wx", "c", "s", "key", "int", "a", "ey", "k", "ya", "xx", "ix", "Y", "b", "f", "no", "o", "ax"]}}
{"code": "\\n  def read_line():\\n      return sys.stdin.readline().rstrip( '\\n' )\\n  \\n  def read_integer():\\n      return int( read_line() )\\n  \\n  def read_float():\\n      return float( read_line() )\\n  \\n  def read_floats():\\n      return [ float( x ) for x in read_line().split() ]\\n  \\n  T = read_integer()\\n  for t in range( T ):\\n      C, F, X = read_floats()\\n      rate = 2\\n      cookies = 0\\n      s = 0\\n      while True:\\n          t1 = X/rate\\n          t2 = C/rate + X/( rate + F )\\n          if t1 < t2:\\n              s += t1\\n              break\\n          s += C/rate\\n          rate += F\\n      print 'Case #%i: %.7f' % ( t + 1, s )\\n", "target": "5", "substitutes": {"x": ["e", "xs", "xi", "xt", "d", "i", "xxxxxxxx", "px", "xp", "xf", "fx", "p", "xy", "mx", "xes", "rx", "z", "v", "xb", " xp", " dx", "dx", "w", "n", "l", "ex", "xc", " c", "wx", "xxxx", "xe", "pe", " p", "xx", " ex", "ix", "y", "f", "ax"], "T": ["N", "U", "G", "Time", "p", "O", "I", "TS", "W", "TA", "M", "Z", "L", "D", "A", "TW", "R", "B", "S", "TT", "E", "H", "V", "PT", "NT", "Y", "Q", "P", "CT", "DT"], "t": ["e", "tt", "d", "i", "tz", "unit", "p", "j", "u", "z", " time", "nt", "pt", "r", "dt", "v", "w", "n", "m", "l", "tim", "ti", "c", "temp", "time", "tp", "int", "a", "test", "y", "f", "trial", "ts"], "C": ["N", "CF", "U", "CH", "G", "SC", "Cu", "O", "I", "CL", "CNN", "CA", "LC", "W", "YC", "M", "NC", "Z", "K", "CM", "EC", "DC", "CP", "CC", "L", "D", "A", "R", "CN", "B", "S", "CO", "c", "CV", "CR", "E", "H", "AC", "CI", "V", "Y", "Q", "P", "CT"], "F": ["N", "CF", "U", "G", "Fs", "FD", "TF", "O", "I", "IF", "W", "FL", "M", "Z", "L", "D", "A", "FO", "R", "PF", "B", "GF", "FM", "S", "FC", "FA", "FE", "E", "H", "V", "Y", "Q", "P", "f", "MF", "AF"], "X": ["N", "U", "XL", "SC", "XP", "XXX", "I", "CL", "TX", "W", "M", "NC", "Z", "CE", "K", "CP", "CC", "L", "D", "FO", "A", "R", "FX", "B", "S", "FC", "TC", "CR", "E", "H", "OC", "V", "FF", "Y", "Q", "P", "XX", "PE", "CT"], "rate": ["ave", "weight", "duration", "sequence", "case", "acc", "exp", "race", "prime", "rank", "seed", "times", "c", "stage", "depth", "gain", "delay", "gest", "complex", "con", "ate", "speed", "rule", "rated", "length", "ride", "count", "write", "status", "currency", "feed", "type", "sample", "SE", "FE", "time", "test", "cycle", "code", "f", "cess", "stop", "score", "play", "Rate", "date", "rice", "m", "core", "grade", "order", "rates", "temp", "key", "factor", "term", "frequency", "ts", "size", "charge", "unit", "r", "level", "age", "value", "erate", "sync", "tc", "use", "fee", "mode", "scale"], "cookies": ["tie", " cookie", " cooks", "Cookries", "cookries", "ties", "Cooks", "Cookie", "Cookies", "tries", " cookries", "cookie", "cooks", "ts"], "s": ["e", "size", "si", "ms", "events", "d", "ps", "ns", "i", "ops", "p", "sb", "u", "r", "z", "sys", "v", "ties", "sym", "ses", "sid", "sets", "w", "sf", "es", "n", "ies", "l", "m", "seconds", "ls", "os", "ss", "rates", "S", "sync", "times", "c", "sec", "sie", "states", "tests", "site", "second", "y", "f", "o", "span", "g", "se", "ts"], "t1": [" t3", "T1", "f0", " tone", "f2", "pone", "t3", " t0", "Tone", "T2", "p3", "p2", "f1", "t0", "tone", "T3", "T0", "p1", "f3"], "t2": [" T2", "T1", "te0", "tetwo", "te1", "x1", " t0", "T2", "te2", " T1", "t0", "x2", " ttwo", "T0", "Ttwo", "ttwo"]}}
{"code": "\\n  def read_line():\\n      return sys.stdin.readline().rstrip( '\\n' )\\n  \\n  def read_integer():\\n      return int( read_line() )\\n  \\n  def read_integers():\\n      return [ int( x ) for x in read_line().split() ]\\n  \\n  def flip( grid ):\\n      return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]\\n  \\n  def grow( R, C, M ):\\n      grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]\\n      b = R*C - M\\n      if C > R:\\n          R, C, grid = C, R, flip( grid )\\n          flipped = True\\n      else:\\n          flipped = False\\n      if b < 2*C:\\n          if b == 1:\\n              grid[ 0 ][ 0 ] = 'c'\\n          elif b == 3 and C >= 3:\\n              grid[ 0 ][ : 3 ] = bytearray( '.c.' )\\n          elif b % 2:\\n              return\\n          else:\\n              grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\\n              grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\\n              grid[ 0 ][ 0 ] = 'c'\\n      else:\\n          r = 0\\n          while b >= C:\\n              grid[ r ] = bytearray( C*[ '.' ] )\\n              b -= C\\n              r += 1\\n          if b:\\n              if b >= 2:\\n                  grid[ r ][ : b ] = b*'.'\\n              elif C > 2 and r > 2:\\n                  grid[ r - 1 ][ -1 ] = '*'\\n                  grid[ r ][ : 2 ] = '..'\\n              else:\\n                  return\\n          grid[ 0 ][ 0 ] = 'c'\\n      return flip( grid ) if flipped else grid\\n      \\n  T = read_integer()\\n  for t in range( T ):\\n      print 'Case #%i:' % ( t + 1 )\\n      R, C, M = read_integers()\\n      grid = grow( R, C, M )\\n      print '\\n'.join( str( row ) for row in grid ) if grid else 'Impossible'\\n", "target": "5", "substitutes": {"x": ["e", "xd", "xa", "xs", "xi", "d", "col", "i", "xxxxxxxx", "X", "px", "xp", "xf", "p", "xy", " X", "z", "val", "rx", " i", "v", "xb", "dx", "w", "n", "l", "index", "ex", " xx", "xc", "xxx", "wx", "byte", "xxxx", "xe", "xx", " y", "ix", "y", "f"], "grid": ["grain", "case", "IF", "get", "card", "mat", "div", "fit", "query", "rank", "graph", "zip", "reg", "back", "c", "cell", "init", "house", "node", "site", "db", "complex", "table", "page", "range", "rule", "shift", "device", "ace", "mu", "gap", "flat", "DC", "record", "feed", "edge", "remote", "df", "dim", "set", "ga", "code", "array", "f", "tile", "server", "hold", "hub", "update", "U", "module", "d", "client", "default", "id", "G", "num", "cart", "play", "gui", "slice", "next", "feature", "layout", "export", "max", "input", "multi", "file", "cells", "GA", "layer", " module", "m", "grade", "news", "tree", "order", "square", "data", "mode", "g", "block", "model", "new", " Grid", "temp", "frame", "format", "chain", "plot", "draw", "bug", "RH", "cube", "final", "sky", "unit", "ico", "list", "u", "heat", "gu", "report", "group", "lat", "parse", "connection", "q", "mid", "entry", "network", "wire", "last", "cache", "int", "move", "line", "Grid", "scale"], "row": ["page", "range", "col", "name", "tr", "id", "num", "rows", "rc", "word", "month", "Row", "length", "max", "flow", "ver", "number", "arrow", "group", "layer", "record", "feed", "w", "ow", "query", "rank", "entry", "index", "order", "value", "raw", "ro", "mod", "block", "model", "c", "batch", "sel", "round", "key", "week", "cell", "node", "height", "run", "sc", "cm", "array", "post", "user"], "column": ["col", "offset", "rows", "word", "slice", "unit", "item", "section", "month", "attribute", "length", "channel", "letter", "ct", "year", "number", "Column", "arrow", "group", "axis", "position", "umn", "pixel", "variable", "day", "entry", "index", "value", "component", "block", "model", "c", "cell", "dim", "character", "cycle", "line", "y", "dimension"], "R": ["N", "Rh", "U", "RH", "G", "X", "Row", "RR", "I", "W", "Rs", "K", "SR", "RO", "L", "Res", "D", "A", "B", "RS", "S", "c", "CR", "E", "H", "F", "V", "RF", "DR", "RM", "GR", "WR", "Y", "Q", "P", "Grid", "LR", "RA"], "C": ["N", "I", "Rs", "CE", "K", "cy", "CC", "c", "Q", "P", "CT", "Con", "Cs", "X", "Cu", "CL", "W", "YC", "NC", "EC", "CM", "_", "DC", "L", "Sc", "F", "e", "CF", "U", "d", "G", "Ch", "Co", "p", "ar", "RC", "ci", "A", "CN", " c", "S", "CR", "E", "H", "V", "Y", "Ra", "sc", "Count", "Max", "ac", "O", "CA", "Z", "D", "cl", "MC", "B", "CI", "CU", "cr", "Grid", "lc", "Cr"], "M": ["N", "U", "ME", "G", "X", "MI", "Me", "J", "O", "I", "MR", "W", "Ms", "MD", "NM", "Z", "CM", "K", "MS", "MQ", "MX", "m", "MN", "L", "Mo", "D", "MU", "MC", "B", "DM", "S", "MB", "E", "H", "MF", "F", "V", "Man", "RM", "Y", "Q", "P", "MM", "LM"], "b": ["e", "range", "rb", "bl", " B", "d", "bb", "ob", "bot", "i", "h", "ac", "eb", "bf", "sb", "p", "j", "ba", "u", "z", "BB", "fb", "wb", "number", "v", "part", "http", "w", "type", "m", "n", "l", "bd", "B", "ib", "body", "base", "nb", "c", "bc", "s", "block", "lb", "a", "big", "k", "null", "ab", "bs", "y", "db", "bp", "f", "bt", "o", "be", "bas", "g", "bug"], "flipped": [" flipping", " flided", "slided", "fluip", "flided", "flipping", "fluipping", " flipper", "floped", "Flipper", "fluipped", "slip", "Floped", "slipping", " flip", "Flided", "slipped", "Flipping", "flip", "fluoped", "Flip", "Flipped", "slipper", " floped", "flipper"], "r": ["e", "range", "yr", "br", "rb", "rr", "d", "tr", "fr", "i", "rc", "h", "p", "ur", "pr", "j", "ar", "dr", "er", "u", "z", "Rs", "v", "re", "w", "m", "n", "l", "ru", "right", "B", "g", "rh", "ro", "rt", "all", "c", "a", "rl", "k", "rs", "rd", "sr", "nr", "err", "f", "cr", "o"], "T": ["N", "Length", "G", "X", "O", "I", "TS", "TB", "W", "TA", "Z", " N", "L", "WT", "D", "B", "S", "TT", "E", "H", "F", "V", "Total", "NT", "Y", "Q", "P", "CT", "DT"], "t": ["e", "tt", "d", "tr", "num", "i", "ta", "tz", "p", "out", "ret", "u", "ct", "nt", "qt", "pt", "total", "dt", "v", "tw", "m", "n", "l", "ot", "ut", "text", "c", "tc", "temp", "time", "int", "tp", "test", "st", "tmp", "y", "ind", "f", "trial", "txt", "ts"]}}
{"code": "\\n  sys.setrecursionlimit(9299999)\\n  \\n  def min_time(C, F, X, speed, nb_cookies):\\n  \tif (X - nb_cookies) / speed < (X - (nb_cookies - C)) / (speed + F):\\n  \t\treturn (X - nb_cookies) / speed\\n  \telif nb_cookies >= C:\\n  \t\treturn min_time(C, F, X, speed + F, nb_cookies - C)\\n  \telse:\\n  \t\treturn (C - nb_cookies) / speed + min_time(C, F, X, speed, C)\\n  \\n  T = int(raw_input())\\n  for i in range(T):\\n  \tC, F, X = map(float, raw_input().split())\\n  \tprint 'Case #%d: %f' % (i + 1, min_time(C, F, X, 2, 0))\\n", "target": "6", "substitutes": {"C": ["N", "Count", "JC", "CF", "U", "Ch", "SC", "Cu", "O", "I", "CL", "Size", "CA", "W", "M", "NC", "CM", "K", "VC", "EC", "CE", "GC", "DC", "CP", "IC", "CC", "L", "D", "A", "R", "CN", "MC", "B", "S", "c", "TC", "CV", "CR", "E", "H", "CS", "CI", "V", "CU", "Y", "P", "Code", "CT"], "F": ["N", "CF", "For", "U", "G", "Fs", "FD", "DF", "OF", "FI", "O", "I", "If", "IF", "W", "File", "M", "Z", "K", "Fin", "Fi", "FS", "L", "Family", "D", "FO", "EF", "R", "PF", "B", "FH", "GF", "FM", "Ex", "FR", "WF", "Fine", "FE", "E", "H", "V", "RF", "All", "FF", "Y", "Inf", "Q", "P", "Far", "f", "UF", "MF", "FW"], "X": ["N", "WS", "CF", "U", "XL", "Cu", "Time", "XP", "PH", "ZX", "IX", "XXX", "CL", "Size", "I", "TX", "W", "IP", "File", "M", "NC", "Z", "CE", "K", "DC", "CP", "IC", "MX", "CW", "XM", "CC", "L", "EX", "A", "R", "FX", "B", "WH", "Ex", "S", "Work", "CV", "CR", "E", "H", "UX", "CI", "x", "V", "DX", "FF", "XY", "Y", "Q", "XX", "P", "PE", "CT"], "speed": ["size", " speeds", "stop", "weight", "duration", "name", "score", "spin", "step", "power", "clean", "eff", "p", "width", "length", "start", "performance", "count", "W", "status", "sum", "slow", "race", "date", "source", "strength", "sleep", "scroll", "sf", "SE", "rank", "seed", "grade", "Speed", "function", "peed", "rate", "EED", "fast", "ss", "sl", "zip", "c", "time", "E", "sn", "key", "gain", "screen", "min", "delay", "dist", "second", "cost", "sw", "f", "frequency", "skip", "scale"], "nb_cookies": ["nb__cookles", "nb_calledies", "nb_circie", "nb_logie", "nb_foodIES", "nb_copicles", "nb_cookries", "nb_cacheies", "nb2copies", "nb_cookles", "nb_logies", "nb_caches", "nb_Cookicles", "nb2copries", "nb_cooks", "nb_Cookeries", "nb__cookies", "nb__logies", "nb_cookys", "nb_calledie", "nb_cIES", "nb2cookys", "nb_copries", "nb_Cookries", "nb_cookIES", "nb_callies", "nb_calledIES", "nb_cles", "nb_cacheines", "nb_ceries", "nb_callIES", "nb__cookys", "nb_callories", "nb_reqie", "nb_Cookies", "nb_Cookories", "nb_circies", "nb_reqys", "nb_cacheys", "nb_copys", "nb__logIES", "nb_cookories", "nb_logys", "nb_cookeries", "nb_logIES", "nb_runies", "nb_calledys", "nb2cookicles", "nb2cookries", "nb_cies", "nb_reqines", "nb_cooky", "nb_cacheie", "nb_cookicles", "nb_logeries", "nb_calleds", "nb_Cookys", "nb_cie", "nb_callie", "nb_cookes", "nb_Cookie", "nb_runicles", "nb_cookines", "nb__cookIES", "nb_reqies", "nb_cys", "nb_cy", "nb_circeries", "nb_Cookes", "nb_CookIES", "nb_Cookines", "nb_copies", "nb_cachey", "nb_Cooky", "nb_callederies", "nb_runries", "nb__logys", "nb_foodies", "nb_logles", "nb_cs", "nb_calledories", "nb_runys", "nb2copys", "nb_foodys", "nb__logles", "nb_cookie", "nb2cookies", "nb_circes", "nb2copicles", "nb_loges", "nb_foodles", "nb_Cooks"], "T": ["N", "U", "G", "TN", "Time", "O", "I", "TS", "TB", "W", "t", "TA", "M", "Z", "K", "TH", "L", "D", "R", "B", "S", "TT", "TC", "E", "H", "V", "NT", "Y", "Q", "P", "CT", "DT"], "i": ["e", "gi", "si", "ini", "xi", "d", "col", "pos", "hi", "id", "h", "p", "j", "I", "start", "u", "zi", "z", "ie", "t", "li", "pi", "v", "type", "n", "ci", "index", "ii", "di", "c", "end", "int", "a", "k", "phi", "x", "y", "ri", "iu", "ind", "f"]}}
{"code": "CACHE = {(1, 1, 0): ['c'],\\n   (1, 2, 0): ['c.'],\\n   (1, 2, 1): ['*c'],\\n   (1, 3, 0): ['c..'],\\n   (1, 3, 1): ['*.c'],\\n   (1, 3, 2): ['**c'],\\n   (1, 4, 0): ['c...'],\\n   (1, 4, 1): ['*.c.'],\\n   (1, 4, 2): ['**.c'],\\n   (1, 4, 3): ['***c'],\\n   (1, 5, 0): ['c....'],\\n   (1, 5, 1): ['*.c..'],\\n   (1, 5, 2): ['**.c.'],\\n   (1, 5, 3): ['***.c'],\\n   (1, 5, 4): ['****c'],\\n   (2, 1, 0): ['c', '.'],\\n   (2, 1, 1): ['*', 'c'],\\n   (2, 2, 0): ['c.', '..'],\\n   (2, 2, 1): None,\\n   (2, 2, 2): None,\\n   (2, 2, 3): ['**', '*c'],\\n   (2, 3, 0): ['c..', '...'],\\n   (2, 3, 1): None,\\n   (2, 3, 2): ['*.c', '*..'],\\n   (2, 3, 3): None,\\n   (2, 3, 4): None,\\n   (2, 3, 5): ['***', '**c'],\\n   (2, 4, 0): ['c...', '....'],\\n   (2, 4, 1): None,\\n   (2, 4, 2): ['*.c.', '*...'],\\n   (2, 4, 3): None,\\n   (2, 4, 4): ['**.c', '**..'],\\n   (2, 4, 5): None,\\n   (2, 4, 6): None,\\n   (2, 4, 7): ['****', '***c'],\\n   (2, 5, 0): ['c....', '.....'],\\n   (2, 5, 1): None,\\n   (2, 5, 2): ['*.c..', '*....'],\\n   (2, 5, 3): None,\\n   (2, 5, 4): ['**.c.', '**...'],\\n   (2, 5, 5): None,\\n   (2, 5, 6): ['***.c', '***..'],\\n   (2, 5, 7): None,\\n   (2, 5, 8): None,\\n   (2, 5, 9): ['*****', '****c'],\\n   (3, 1, 0): ['c', '.', '.'],\\n   (3, 1, 1): ['*', '.', 'c'],\\n   (3, 1, 2): ['*', '*', 'c'],\\n   (3, 2, 0): ['c.', '..', '..'],\\n   (3, 2, 1): None,\\n   (3, 2, 2): ['**', '..', 'c.'],\\n   (3, 2, 3): None,\\n   (3, 2, 4): None,\\n   (3, 2, 5): ['**', '**', '*c'],\\n   (3, 3, 0): ['c..', '...', '...'],\\n   (3, 3, 1): ['*.c', '...', '...'],\\n   (3, 3, 2): None,\\n   (3, 3, 3): ['***', '...', 'c..'],\\n   (3, 3, 4): None,\\n   (3, 3, 5): ['***', '*..', '*.c'],\\n   (3, 3, 6): None,\\n   (3, 3, 7): None,\\n   (3, 3, 8): ['***', '***', '**c'],\\n   (3, 4, 0): ['c...', '....', '....'],\\n   (3, 4, 1): ['*.c.', '....', '....'],\\n   (3, 4, 2): ['**.c', '....', '....'],\\n   (3, 4, 3): ['*.c.', '*...', '*...'],\\n   (3, 4, 4): ['****', '....', 'c...'],\\n   (3, 4, 5): None,\\n   (3, 4, 6): ['****', '*...', '*.c.'],\\n   (3, 4, 7): None,\\n   (3, 4, 8): ['****', '**..', '**.c'],\\n   (3, 4, 9): None,\\n   (3, 4, 10): None,\\n   (3, 4, 11): ['****', '****', '***c'],\\n   (3, 5, 0): ['c....', '.....', '.....'],\\n   (3, 5, 1): ['*.c..', '.....', '.....'],\\n   (3, 5, 2): ['**.c.', '.....', '.....'],\\n   (3, 5, 3): ['***.c', '.....', '.....'],\\n   (3, 5, 4): ['**.c.', '*....', '*....'],\\n   (3, 5, 5): ['*****', '.....', 'c....'],\\n   (3, 5, 6): ['**.c.', '**...', '**...'],\\n   (3, 5, 7): ['*****', '*....', '*.c..'],\\n   (3, 5, 8): None,\\n   (3, 5, 9): ['*****', '**...', '**.c.'],\\n   (3, 5, 10): None,\\n   (3, 5, 11): ['*****', '***..', '***.c'],\\n   (3, 5, 12): None,\\n   (3, 5, 13): None,\\n   (3, 5, 14): ['*****', '*****', '****c'],\\n   (4, 1, 0): ['c', '.', '.', '.'],\\n   (4, 1, 1): ['*', '.', 'c', '.'],\\n   (4, 1, 2): ['*', '*', '.', 'c'],\\n   (4, 1, 3): ['*', '*', '*', 'c'],\\n   (4, 2, 0): ['c.', '..', '..', '..'],\\n   (4, 2, 1): None,\\n   (4, 2, 2): ['**', '..', 'c.', '..'],\\n   (4, 2, 3): None,\\n   (4, 2, 4): ['**', '**', '..', 'c.'],\\n   (4, 2, 5): None,\\n   (4, 2, 6): None,\\n   (4, 2, 7): ['**', '**', '**', '*c'],\\n   (4, 3, 0): ['c..', '...', '...', '...'],\\n   (4, 3, 1): ['*.c', '...', '...', '...'],\\n   (4, 3, 2): ['*.c', '*..', '...', '...'],\\n   (4, 3, 3): ['***', '...', 'c..', '...'],\\n   (4, 3, 4): ['***', '*..', '..c', '...'],\\n   (4, 3, 5): None,\\n   (4, 3, 6): ['***', '***', '...', 'c..'],\\n   (4, 3, 7): None,\\n   (4, 3, 8): ['***', '***', '*..', '*.c'],\\n   (4, 3, 9): None,\\n   (4, 3, 10): None,\\n   (4, 3, 11): ['***', '***', '***', '**c'],\\n   (4, 4, 0): ['c...', '....', '....', '....'],\\n   (4, 4, 1): ['*.c.', '....', '....', '....'],\\n   (4, 4, 2): ['**.c', '....', '....', '....'],\\n   (4, 4, 3): ['**.c', '*...', '....', '....'],\\n   (4, 4, 4): ['****', '....', 'c...', '....'],\\n   (4, 4, 5): ['****', '*...', '..c.', '....'],\\n   (4, 4, 6): ['****', '**..', '...c', '....'],\\n   (4, 4, 7): ['****', '*...', '*.c.', '*...'],\\n   (4, 4, 8): ['****', '****', '....', 'c...'],\\n   (4, 4, 9): None,\\n   (4, 4, 10): ['****', '****', '*...', '*.c.'],\\n   (4, 4, 11): None,\\n   (4, 4, 12): ['****', '****', '**..', '**.c'],\\n   (4, 4, 13): None,\\n   (4, 4, 14): None,\\n   (4, 4, 15): ['****', '****', '****', '***c'],\\n   (4, 5, 0): ['c....', '.....', '.....', '.....'],\\n   (4, 5, 1): ['*.c..', '.....', '.....', '.....'],\\n   (4, 5, 2): ['**.c.', '.....', '.....', '.....'],\\n   (4, 5, 3): ['***.c', '.....', '.....', '.....'],\\n   (4, 5, 4): ['***.c', '*....', '.....', '.....'],\\n   (4, 5, 5): ['*****', '.....', 'c....', '.....'],\\n   (4, 5, 6): ['*****', '*....', '..c..', '.....'],\\n   (4, 5, 7): ['*****', '**...', '...c.', '.....'],\\n   (4, 5, 8): ['*****', '***..', '....c', '.....'],\\n   (4, 5, 9): ['*****', '**...', '*..c.', '*....'],\\n   (4, 5, 10): ['*****', '*****', '.....', 'c....'],\\n   (4, 5, 11): ['*****', '**...', '**.c.', '**...'],\\n   (4, 5, 12): ['*****', '*****', '*....', '*.c..'],\\n   (4, 5, 13): None,\\n   (4, 5, 14): ['*****', '*****', '**...', '**.c.'],\\n   (4, 5, 15): None,\\n   (4, 5, 16): ['*****', '*****', '***..', '***.c'],\\n   (4, 5, 17): None,\\n   (4, 5, 18): None,\\n   (4, 5, 19): ['*****', '*****', '*****', '****c'],\\n   (5, 1, 0): ['c', '.', '.', '.', '.'],\\n   (5, 1, 1): ['*', '.', 'c', '.', '.'],\\n   (5, 1, 2): ['*', '*', '.', 'c', '.'],\\n   (5, 1, 3): ['*', '*', '*', '.', 'c'],\\n   (5, 1, 4): ['*', '*', '*', '*', 'c'],\\n   (5, 2, 0): ['c.', '..', '..', '..', '..'],\\n   (5, 2, 1): None,\\n   (5, 2, 2): ['**', '..', 'c.', '..', '..'],\\n   (5, 2, 3): None,\\n   (5, 2, 4): ['**', '**', '..', 'c.', '..'],\\n   (5, 2, 5): None,\\n   (5, 2, 6): ['**', '**', '**', '..', 'c.'],\\n   (5, 2, 7): None,\\n   (5, 2, 8): None,\\n   (5, 2, 9): ['**', '**', '**', '**', '*c'],\\n   (5, 3, 0): ['c..', '...', '...', '...', '...'],\\n   (5, 3, 1): ['*.c', '...', '...', '...', '...'],\\n   (5, 3, 2): ['*.c', '*..', '...', '...', '...'],\\n   (5, 3, 3): ['***', '...', 'c..', '...', '...'],\\n   (5, 3, 4): ['***', '*..', '..c', '...', '...'],\\n   (5, 3, 5): ['***', '*..', '*.c', '...', '...'],\\n   (5, 3, 6): ['***', '***', '...', 'c..', '...'],\\n   (5, 3, 7): ['***', '***', '*..', '..c', '...'],\\n   (5, 3, 8): None,\\n   (5, 3, 9): ['***', '***', '***', '...', 'c..'],\\n   (5, 3, 10): None,\\n   (5, 3, 11): ['***', '***', '***', '*..', '*.c'],\\n   (5, 3, 12): None,\\n   (5, 3, 13): None,\\n   (5, 3, 14): ['***', '***', '***', '***', '**c'],\\n   (5, 4, 0): ['c...', '....', '....', '....', '....'],\\n   (5, 4, 1): ['*.c.', '....', '....', '....', '....'],\\n   (5, 4, 2): ['**.c', '....', '....', '....', '....'],\\n   (5, 4, 3): ['**.c', '*...', '....', '....', '....'],\\n   (5, 4, 4): ['****', '....', 'c...', '....', '....'],\\n   (5, 4, 5): ['****', '*...', '..c.', '....', '....'],\\n   (5, 4, 6): ['****', '**..', '...c', '....', '....'],\\n   (5, 4, 7): ['****', '**..', '*..c', '....', '....'],\\n   (5, 4, 8): ['****', '****', '....', 'c...', '....'],\\n   (5, 4, 9): ['****', '****', '*...', '..c.', '....'],\\n   (5, 4, 10): ['****', '****', '**..', '...c', '....'],\\n   (5, 4, 11): ['****', '****', '*...', '*.c.', '*...'],\\n   (5, 4, 12): ['****', '****', '****', '....', 'c...'],\\n   (5, 4, 13): None,\\n   (5, 4, 14): ['****', '****', '****', '*...', '*.c.'],\\n   (5, 4, 15): None,\\n   (5, 4, 16): ['****', '****', '****', '**..', '**.c'],\\n   (5, 4, 17): None,\\n   (5, 4, 18): None,\\n   (5, 4, 19): ['****', '****', '****', '****', '***c'],\\n   (5, 5, 0): ['c....', '.....', '.....', '.....', '.....'],\\n   (5, 5, 1): ['*.c..', '.....', '.....', '.....', '.....'],\\n   (5, 5, 2): ['**.c.', '.....', '.....', '.....', '.....'],\\n   (5, 5, 3): ['***.c', '.....', '.....', '.....', '.....'],\\n   (5, 5, 4): ['***.c', '*....', '.....', '.....', '.....'],\\n   (5, 5, 5): ['*****', '.....', 'c....', '.....', '.....'],\\n   (5, 5, 6): ['*****', '*....', '..c..', '.....', '.....'],\\n   (5, 5, 7): ['*****', '**...', '...c.', '.....', '.....'],\\n   (5, 5, 8): ['*****', '***..', '....c', '.....', '.....'],\\n   (5, 5, 9): ['*****', '***..', '*...c', '.....', '.....'],\\n   (5, 5, 10): ['*****', '*****', '.....', 'c....', '.....'],\\n   (5, 5, 11): ['*****', '*****', '*....', '..c..', '.....'],\\n   (5, 5, 12): ['*****', '*****', '**...', '...c.', '.....'],\\n   (5, 5, 13): ['*****', '*****', '***..', '....c', '.....'],\\n   (5, 5, 14): ['*****', '*****', '**...', '*..c.', '*....'],\\n   (5, 5, 15): ['*****', '*****', '*****', '.....', 'c....'],\\n   (5, 5, 16): ['*****', '*****', '**...', '**.c.', '**...'],\\n   (5, 5, 17): ['*****', '*****', '*****', '*....', '*.c..'],\\n   (5, 5, 18): None,\\n   (5, 5, 19): ['*****', '*****', '*****', '**...', '**.c.'],\\n   (5, 5, 20): None,\\n   (5, 5, 21): ['*****', '*****', '*****', '***..', '***.c'],\\n   (5, 5, 22): None,\\n   (5, 5, 23): None,\\n   (5, 5, 24): ['*****', '*****', '*****', '*****', '****c']}\\n  \\n  \\n  T = int(input())\\n  for i in range(T):\\n  \tR, C, M = map(int, input().split())\\n  \tprint('Case #{}:'.format(i + 1))\\n  \ttry:\\n  \t\tprint('\\n'.join(CACHE[(R, C, M)]))\\n  \texcept:\\n  \t\tprint('Impossible')\\n", "target": "6", "substitutes": {"CACHE": ["CAGK", "CACCH", "CACK", "CASCH", "HEACHE", "CACES", "CACHES", "HEACHHE", "CAGES", "CACHHE", "CASK", "CAGHE", "CAGCH", "HEACHK", "HEACHCH", "CACHK", "CASHE", "HEACCH", "CACHCH", "HEACES", "HEACK", "HEACHES", "CASES"]}}
{"code": "\\n  \\n  f = open(sys.argv[1],'r')\\n  \\n  num = int(f.readline())\\n  \\n  for i in range(num):\\n      c, e, x = [float(x) for x in f.readline().split()]\\n      n = int((x*e-2*c)/(c*e))\\n      if n < 0:\\n          n = 0\\n      t = 0\\n      for j in range(n):\\n          t += c/(2+j*e)\\n      t += x/(2+n*e)\\n      print 'Case #{}: {}'.format(i+1, t)\\n", "target": "7", "substitutes": {"f": ["fd", "d", "fr", "h", "p", "af", "r", "z", "fo", "file", "tf", "form", "ref", "v", "handler", "of", "io", "feed", "w", "conf", "sf", "m", "l", "fs", "s", "a", "df", "F", "buff", "b", "fc", "g"], "num": ["size", "d", "col", "om", "id", "offset", "h", "max", "en", "u", "Num", "count", "multi", "number", "sum", "tu", "um", "div", "iter", "un", "loc", "m", "np", "index", "end", "init", "k", "ul", "min", "off", "con", "b", "oct", "g", "nom", "nu"], "i": ["si", "ini", "xi", "ip", "d", "id", "mini", "h", "slice", "p", "I", "start", "u", "ie", "z", "pi", "ai", "li", "v", "io", "type", "ci", "m", "l", "ii", "index", "ti", "int", "ix", "y", "iu", "b", "ind"], "c": ["cf", "d", "col", "h", "C", "p", "ce", "u", "count", "r", "z", "v", "cs", "w", "cy", "q", "m", "ci", "l", "s", "a", "k", "ec", "y", "b", "con", "cn", "o", "g"], "e": ["size", "d", "ne", "ee", "h", "p", "ce", "en", "u", "oe", "r", "z", "ie", "v", "ed", "ell", "ae", "w", "m", "el", "l", "g", "s", "E", "ey", "ec", "line", "y", "ze", "b", "o", "es"], "x": ["size", "xs", "xi", "xt", "d", "px", "X", "h", "xp", "xf", "p", "xy", " X", "u", "ct", "z", "r", "rx", "number", " z", "_", "v", "dx", "w", "q", "m", "ci", "l", "index", "ex", "xc", "xxx", "wx", "xe", "s", "k", "xx", "ix", "y", "b", "o", "ax", "g"], "n": ["N", "ny", "size", "d", "ne", "ns", "nor", "p", "en", "u", "count", "r", "nt", "z", "ni", "v", "nn", "w", "m", "l", "net", "ot", "g", "pn", "nb", "s", "sn", "a", "k", "nc", "y", "b", "no", "o", "cn", "nu"], "t": ["tt", "at", "d", "offset", "ta", "tz", "p", "u", "ct", "r", "nt", "z", "tf", "pt", "dt", "v", "tu", "type", "m", "l", "ot", "T", "tn", "ti", "te", "s", "tc", "tp", "int", "y", "b", "o", "g", "ts"], "j": ["d", "ne", "h", "J", "p", "ch", "u", "z", "r", "nt", "ie", "li", "jj", "v", "w", "m", "l", "jp", "int", "jc", "ji", "k", "y", "b", "o", "g"]}}
{"code": "\\n  \\n  f = open(sys.argv[1],'r')\\n  \\n  num = int(f.readline())\\n  \\n  def count(z, r, c):\\n      return len(z_and_nei(z,r,c))\\n  \\n  def nei(z, r, c):\\n      s = z_and_nei(z, r, c)\\n      s -= set(z)\\n      return s\\n  \\n  def z_and_nei(z, r, c):\\n      s = set()\\n      for x in z:\\n          s.add(x)\\n          s.add((x[0]-1,x[1]-1))\\n          s.add((x[0]-1,x[1]))\\n          s.add((x[0]-1,x[1]+1))\\n          s.add((x[0],x[1]-1))\\n          s.add((x[0],x[1]+1))\\n          s.add((x[0]+1,x[1]-1))\\n          s.add((x[0]+1,x[1]))\\n          s.add((x[0]+1,x[1]+1))\\n      o = set()\\n      for x in s:\\n          if x[0] < 0 or x[0] > r-1 or x[1] < 0 or x[1] > c-1:\\n              o.add(x)\\n      s-=o\\n      return s\\n  \\n  def find_config(z, r, c, t):\\n      if count(z,r,c) == t:\\n          return z\\n      if count(z,r,c) > t:\\n          return []\\n      n = nei(z,r,c)\\n      for x in n:\\n          z.append(x)\\n          if find_config(z,r,c,t) != []:\\n              return z\\n          z.pop()\\n      return []\\n  \\n  for i in range(num):\\n      print 'Case #{}:'.format(i+1)\\n      r, c, m = [int(x) for x in f.readline().split()]\\n      if r*c-m == 1:\\n          print 'c' + '*'*(c-1)\\n          for i in range(r-1):\\n              print '*'*c\\n      else:\\n          z = find_config([(0,0)], c, r, c*r-m)\\n          if z == []:\\n              print \"Impossible\"\\n          else:\\n              s = z_and_nei(z, c, r)\\n              for j in range(r):\\n                  for k in range(c):\\n                      if j == 0 and k == 0:\\n                          print 'c',\\n                      elif (k,j) in s:\\n                          print '.',\\n                      else:\\n                          print '*',\\n                  print\\n  \\n  \\n", "target": "7", "substitutes": {"f": ["e", "proc", "fd", "d", "fr", "h", "p", "fx", "ch", "af", "fo", "file", "tf", "ref", "handler", "v", "fb", "stream", "io", "ft", "form", "feed", "w", "conf", "l", "fp", "fast", "fs", "g", "df", "F", "arf", "y", "b", "fc", "info"], "num": ["size", "name", "col", "om", "fn", "ctr", "norm", "len", "h", "p", "max", "en", "u", "Num", "count", "multi", "number", "total", "cu", "sum", "na", "um", "inc", "iter", "w", "loc", "np", "nb", "temp", "bin", "sn", "NUM", "nc", "con", "b", "no", "cm", "uni", "g", "nu"], "z": ["e", "zy", "d", "tz", "h", "az", "zo", "p", "ez", "ce", "zh", "config", "u", "er", "za", "zi", "zn", "zen", "like", "Z", "v", "nz", " Z", "ed", "zz", "w", "q", "zl", "iz", "l", "zer", "cl", "fl", "wa", "g", "zip", "one", "all", "a", "ld", "cz", "y", "ze", "gz", "code", "b", "count", "zone", "bug"], "r": ["e", "range", "yr", "rr", "rb", "br", "d", "tr", "fr", "nor", "rc", "h", "C", "p", "ur", "pr", "ar", "dr", "er", "u", "v", "lr", "rec", "ir", "re", "w", "q", "hr", "l", "rf", "R", "ru", "g", "rh", "a", "rn", "rs", "sr", "nr", "y", "b", "err", "cr"], "c": ["e", "cf", "d", "rc", "h", "ac", "C", "dc", "p", "ch", "ce", "u", "count", "ct", "cu", "v", "cs", "w", "uc", "q", "cy", "ci", "l", "cl", "ca", "g", "pc", "cc", "cin", "cell", "a", "nc", "y", "sc", "b", "con", "cm", "cr", "cn", "lc"], "s": ["ws", "xs", "events", "sb", "ing", "ls", "times", "states", "us", "vs", "site", "y", "ends", "options", "si", "sg", "ps", "qs", "services", "er", "ssl", "status", "sa", "its", "ses", "cs", "w", "l", "os", "sl", "ks", "posts", "ans", "a", "sv", "set", "rs", "b", "sites", "ments", "e", "ys", "d", "p", "opens", "multi", "an", "sys", "v", "sym", "sum", "south", "fs", "g", "S", "strings", "sn", "uns", "lines", "sc", "js", "ts", "size", "gs", "ns", "rows", "h", "so", "su", "u", "sh", "ed", "ds", "sets", "ies", "ss", "groups", "sync", "ions", "ves", "users", "ips", "es"], "x": ["xs", "xt", "px", "sex", "xp", "fx", " X", "case", "exp", "rex", "index", "xc", "wx", "any", "ph", "xx", "y", "ax", "event", "ww", "X", "opt", "tx", "_", "dx", "ext", "w", "l", "wa", "time", "pe", "a", "ic", "code", "b", "check", "e", "d", "self", "zx", "id", "p", "xy", "xml", "go", "xes", "config", "rx", "cross", "on", "v", "co", "na", "loc", "ci", "alpha", "data", "one", "xi", "ux", "h", "xf", "view", "u", "ct", "hex", "xb", "q", "cl", "ex", "xxx", "work", "python", "int", "lex", "ix", "sw", "g"], "o": ["e", "d", "ob", "oo", "bo", "oa", "h", "p", "O", "so", "out", "op", "u", "oe", "on", "v", "io", "w", "l", "os", "ot", "ro", "ou", "yo", "off", "other", "y", "do", "b", "no", "g"], "t": ["e", "tt", "at", " T", "d", "tr", "ta", "tz", "h", "p", "out", "u", "nt", "tf", "total", "it", "pt", "v", "dt", "type", "q", "tm", "l", "ot", "T", "tc", "time", "tp", "a", "int", "y", "b", "g", "ts"], "n": ["N", "e", "d", "ne", "ns", "p", "en", "ct", "nt", "ni", "v", "cs", "nn", "w", "q", "l", "ot", "g", "all", "nb", "sn", "a", "nc", "y", "b", "con", "net"], "i": ["e", "gi", "si", "ini", "xi", "ip", "iq", "id", "h", "slice", "p", "I", "u", "im", "ie", "multi", "li", "pi", "ih", "ai", "ui", "v", "io", "uri", "q", "ci", "l", "ii", "index", "ti", "di", "int", "phi", "ix", "y", "ri", "iu", "b", "ind", "eni", "qi"], "m": ["e", "range", "ms", "mc", "d", "mi", "mini", "h", "C", "p", "u", "mm", "M", "v", "um", "w", "q", "l", "a", "y", "b", "cm", "g"]}}
{"code": "\\n  \\n  def solve(c, f, x):\\n      time = 0\\n      cps = 2.0\\n      while True:\\n          time_to_farm = c / cps\\n          time_to_end = x / cps\\n          buy_a_farm = (time_to_farm + x / (cps + f)) < time_to_end\\n          if buy_a_farm:\\n              time += time_to_farm\\n              cps += f\\n          else:\\n              time += time_to_end\\n              return time\\n  \\n  if __name__ == '__main__':\\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\\n      with fin, fout:\\n          T = int(fin.readline())\\n          for case in xrange(1, T+1):\\n              c, f, x = map(float, fin.readline().split())\\n              soln = solve(c, f, x)\\n              print >> fout, \"Case #{0}: {1:.7f}\".format(case, soln)\\n  \\n", "target": "8", "substitutes": {"c": ["e", "cf", "d", "i", "h", "C", "dc", "p", "ce", "start", "u", "count", "ct", "r", "z", "t", "co", "v", "cu", "com", "cs", "w", "n", "m", "l", "cc", "s", "end", "cell", "k", "cycle", "y", "code", "b", "con", "cm", "fc", "g", "lc"], "f": ["e", "cf", "fd", "d", "fr", "i", "h", "xf", "p", "fx", "u", "af", "z", "fm", "t", "fb", "file", "v", "field", "w", "sf", "m", "n", "l", "rf", "fp", "fs", "end", "F", "fe", "y", "b", "fc", "frequency", "fen", "g", "farm", "fa"], "x": ["e", "xs", "xi", "d", "event", "name", "i", "X", "sex", "h", "xp", "xf", "p", "fx", "xes", "u", "im", "rx", "z", "change", "t", "cross", "r", "tx", "v", "xb", "w", "q", "m", "n", "l", "index", "ex", "wa", "xc", "wx", "xxx", "s", "end", "ic", "xx", "fe", "ix", "y", "b", "fc", "farm"], "time": ["e", "size", " TIME", "speed", "name", "duration", "money", "weight", "self", "h", "ac", "Time", "p", "length", "ime", "ace", "count", "year", "micro", "t", "file", "form", " Time", "v", "etime", "space", "date", "rice", "race", "UTC", "trace", "type", "sleep", "m", "TIME", "clock", "tim", "rate", "value", "back", "times", " times", "temp", "end", "depth", "cycle", "call", "how", "line", "timer", "cost", "frequency", "timeout"], "cps": ["cpp", "cups", "rpps", "rmp", "cmp", "lpps", "Cips", "ucups", "chms", "cpps", " cp", " cups", "rfs", "cfs", " cPS", "lcups", "cms", "CPS", "Cups", "mpps", "lpp", "lfs", "dcfs", "chmp", "dcps", "mfs", "mps", "chfs", "lps", "mpp", "cips", "ucPS", " cpps", "lcp", " cpp", "Cp", "rps", "lcPS", "rms", "lcps", "dcms", "ucps", "ucpps", "rips", "Cps", "Cpps", " cips", "chps", "cp", "Cpp", "dcmp", "rpp", "cPS"], "time_to_farm": ["time_to_f", "time_from_fork", "time_from_farm", "time_to_fork", "time_from_end", "time_from_field", "time_to_field"], "time_to_end": ["time_until_start", "time_until_begin", "time_until_fin", "time_to_fin", "time_to_begin", "time_until_end", "time_to_start"], "buy_a_farm": ["buy_a_field", "buy_aacf", "buy_a_f", "buy_a_forest", "buy_an_f", "buy_aacfarm", "buy_aacfield", "buy_an_farm", "buy_an_forest"], "fin": ["proc", "ini", "br", "fd", "ori", "fr", "fn", "len", "final", "thin", "fi", "rin", "finished", "ret", "en", "fun", "conn", "pen", "non", "inner", "file", "form", "die", "lin", "FIN", "Fin", "fer", "inv", "n", "rf", "fp", "fine", "close", "rt", "ro", "ln", "bin", "end", "init", "run", "fat", "raf", "fen", "skip", "nu", "fa"], "fout": [" fOut", "FOut", " Fout", "rfoutput", "Foutput", "rfOut", "fOut", "fdout", "rfout", " Findex", "fdOut", " foutput", "rfin", " Foutput", "Fin", "cfin", " findex", "Findex", "fdin", " Fin", "fdindex", "cfoutput", "Fout", "cfout", "cfindex", "findex", "foutput"], "T": ["N", "Test", "U", "loop", "X", "TN", "C", "Time", "O", "max", "I", "TS", "sequence", "W", "t", "M", "Z", "TH", "L", "WT", "D", "A", "Case", "R", "TW", "B", "S", "TT", "E", "H", "test", "F", "V", "NT", "Y", "P", "trial", "CT", "TI"], "case": ["size", "name", "exc", "X", "step", "p", "section", "me", "ce", "length", "ace", "match", "instance", "ase", "cases", "t", "nce", "CE", "date", "race", "rice", "loc", "uc", "position", "Case", "ice", "de", "use", "int", "pe", "se", "test", "fe", "line", "result", "call", "code", "sc", "trial", "bug"], "soln": ["Sols", "Ssol", " slyn", " sol", "sols", "spsol", "spols", "nsol", "nsoln", "ssol", "solk", "spoln", "ssoln", "nslyn", "nsolk", "sol", "slyn", " sols", "splyn", "Soln", " solk", "Slyn", " ssol", "ssolk", "sslyn"]}}
{"code": "\\n  \\n  IMPOSSIBLE = []\\n  \\n  def transpose(grid):\\n      return map(list, zip(*grid))\\n  \\n  def find_grid(R, C, M):\\n      \"\"\"Return a grid of a solution, if one exists, otherwise []\\n  \\n      Observations:\\n      * WLOG, C <= R (otherwise, take the transpose of a solution)\\n      * Trivial cases are:\\n        - M = 0 or  M = RC - 1\\n        - C = 1\\n        - (R, C) = (2, 2)\\n        - (R, C, M) = (3, 3, 2)\\n        - (C, M) = (2, 1)\\n      * If M >= C >= 2 and R >= 3, we can add a row of C mines to the bottom and consider M'=M-C, R'=R-1\\n      * The remaining cases are M <= R-2, and M + 1 == R == C >= 4, which are both solvable\\n      \"\"\"\\n      if M == 0:\\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          return grid\\n      elif M == R * C - 1:\\n          grid = [['*' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          return grid\\n      elif C > R:\\n          return transpose(find_grid(C, R, M))\\n      elif C == 1:\\n          return [['c']] + [['.'] for i in xrange(R-M-1)] + [['*'] for i in xrange(M)]\\n      elif (R, C) == (2, 2) or (R, C, M) == (3, 3, 2) or (C, M) == (2, 1):\\n          return IMPOSSIBLE\\n  \\n      assert 2 <= C <= R >= 3, \"R={} C={} M={}\".format(R, C, M)\\n  \\n      if M >= C:\\n          s = find_grid(R-1, C, M-C)\\n          return s and s + [['*' for c in xrange(C)]]\\n      elif M <= R-2 and C >= 3:\\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          for i in xrange(M):\\n              grid[R-i-1][C-1] = '*'\\n          return grid\\n      elif M + 1 == R == C >= 4:\\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          grid[R-1][C-2] = '*'\\n          for i in xrange(M-1):\\n              grid[R-i-1][C-1] = '*'\\n          return grid\\n  \\n      assert False, \"R={} C={} M={}\".format(R, C, M)\\n  \\n  def check_soln(grid, R, C, M):\\n      \"\"\"checking, because debugging...\"\"\"\\n      error = \"R={} C={} M={}\".format(R, C, M)\\n      assert sum(row.count('*') for row in grid) == M, error\\n      assert sum(row.count('c') for row in grid) == 1, error\\n      assert len(grid) == R, error\\n      assert all(len(row) == C for row in grid), error\\n      _ = [i for i, row in enumerate(grid) if 'c' in row][0]\\n      click = (_, [i for i, c in enumerate(grid[_]) if c == 'c'][0])\\n  \\n      def neighbours(r, c):\\n          ns = [(i, j) for i in range(max(r-1,0),min(r+2,R)) for j in range(max(c-1,0),min(c+2,C))]\\n          ns.remove((r, c))\\n          return ns\\n  \\n      cpy = map(list, grid)\\n      def fill(cpy, pos):\\n          cpy[pos[0]][pos[1]] = str(sum(1 for i, j in neighbours(*pos) if grid[i][j] == '*'))\\n          if cpy[pos[0]][pos[1]] == '0':\\n              for i, j in neighbours(*pos):\\n                  if cpy[i][j] == '.':\\n                      fill(cpy, (i, j))\\n      fill(cpy, click)\\n      assert sum(row.count('.') for row in cpy) == 0, error\\n  \\n  def solve(R, C, M):\\n      soln = find_grid(R, C, M)\\n      if soln == IMPOSSIBLE:\\n          return \"Impossible\"\\n      else:\\n          check_soln(soln, R, C, M)\\n          return '\\n'.join(''.join(row) for row in soln)\\n  \\n  if __name__ == '__main__':\\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\\n      with fin, fout:\\n          T = int(fin.readline())\\n          for case in xrange(1, T+1):\\n              r, c, m = map(int, fin.readline().split())\\n              soln = solve(r, c, m)\\n              print >> fout, \"Case #{0}:\\n{1}\".format(case, soln)\\n  \\n", "target": "8", "substitutes": {"IMPOSSIBLE": ["IMPESSible", "IMPASSibles", "IMPUSORS", "IMpOSSibles", "IMPOSURE", "IMPOSIBLE", "IMpOSSURE", "IMPUSibles", "IMpASSIVE", "IMpASSIBLE", "IMPASSURE", "IMpASSURE", "IMPESSIVE", "IMpOSSORS", "IMpASSORS", "IMPESSORS", "IMPASSible", "IMPOSible", "IMpASSible", "IMPESSURE", "IMPUSIBLE", "IMPOSSibles", "IMPESSIBLE", "IMpOSSIVE", "IMPOSSIVE", "IMPOSIVE", "IMPOSSible", "IMPASSIBLE", "IMPASSIVE", "IMPOSSURE", "IMpOSSIBLE", "IMPUSible", "IMPASSORS", "IMpOSSible", "IMPESSibles", "IMPOSSORS", "IMpASSibles"], "grid": ["ge", "manager", "out", "filter", "sequence", "card", "mat", "query", "sim", "index", "graph", "reg", "cell", "house", "node", "site", "db", "complex", "cm", "table", "page", "range", "sg", "mu", "gap", "flat", "align", "edge", "type", "method", "storage", "dim", "df", "x", "window", "array", "f", "copy", "server", "lay", "rr", "module", "client", "G", "id", "play", "layout", "gr", "input", "file", "cells", "layer", "tree", "order", "square", "data", "g", "volume", "block", "model", "frame", "chain", "plot", "draw", "rows", "cube", "panel", "str", "unit", "list", "column", "flow", "arr", "lat", "group", "dict", "q", "age", "network", "cache", "sort", "move", "line", "choice", "Grid"], "R": ["N", "Rh", "AR", "TR", "U", "RH", "G", "X", "RE", "RR", "MR", "W", "Rs", "Range", "Cl", "K", "RC", "RW", "SR", "RO", "RN", "Re", "Ro", "L", "D", "A", "ER", "JR", "B", "RS", "Rec", "S", "RP", "CR", "E", "H", "F", "IR", "V", "DR", "Run", "RM", "GR", "WR", "Y", "Ra", "NR", "Q", "P", "RT", "LR", "RA", "RG"], "C": ["N", "Cs", "U", "G", "Ch", "X", "SC", "Co", "Cu", "O", "CL", "I", "CA", "W", "YC", "NC", "CM", "VC", "CE", "K", "EC", "RC", "DC", "CC", "L", "D", "A", "MC", "CN", "B", "S", "CO", "CV", "CR", "E", "H", "CS", "AC", "CI", "F", "V", "CU", "Y", "Q", "P", "CT", "Cr"], "M": ["N", "AR", "U", "MO", "VM", "ME", "G", "X", "MI", "J", "Me", "O", "MOD", "RR", "I", "CL", "MR", "W", "MD", "CM", "K", "Z", "RC", "DC", "Mor", "MN", "L", "OM", "CC", "D", "A", "MC", "Mo", "B", "DM", "S", "MA", "IM", "MB", "CR", "E", "H", "AM", "F", "V", "DR", "Man", "RM", "CU", "Y", "Q", "P", "cm", "Mc", "MM", "LM", "RA", "Range"], "c": ["e", "cf", "d", "col", "h", "ac", "p", "ch", "ce", "ct", "z", "cat", "co", "v", "cu", "cs", "n", "l", "cl", "xc", "ca", "cc", "unc", "a", "ic", "k", "ec", "x", "code", "con", "b", "f", "cm", "cn", "arc", "cr", "g", "lc"], "r": ["e", "range", "yr", "br", "rb", "id", "fr", "p", "ur", "pr", "gr", "ar", "er", "u", "t", "it", "v", "lr", "ir", "re", "n", "l", "ru", "g", "ner", "rn", "rs", "x", "sr", "b", "err", "f", "rg", "o"], "i": ["e", "xi", "ip", "iq", "col", "id", "p", "ar", "I", "im", "z", "it", "ai", "pi", "v", "ir", "q", "n", "ci", "l", "ii", "bi", "ti", "int", "ic", "x", "iu", "b", "ind", "arc", "g"], "s": ["e", "si", "sg", "ws", "d", "gs", "ps", "h", "p", "sb", " S", "services", "su", "u", "t", "cells", "v", "sym", "ses", "sets", "w", "sq", "es", "sample", "n", "sim", "l", "ss", "S", "storage", "sync", "blocks", "a", "states", "y", "b", "sites", "f", "o", "ts", "g", "abs"], "row": ["plane", "col", "rug", "rows", "cube", "unit", "Row", "column", "flow", "roll", "ow", "ho", "rown", "ice", "ro", "block", "ox", "ack", "cell", "head", "run", "rid", "sc", "array", "ros", "copy", "roc"]}}
{"code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/B/'\\n  \\n  \\n  \\n  def solve (f_in, f_out):\\n      T = int(f_in.readline())\\n      for testcase in range(1,T+1):\\n          line = f_in.readline()\\n          C,F,X = [float(q) for q in line.split()]\\n          result = compute (C,F,X)\\n          f_out.write('Case #' + str(testcase) + ': ' + str(result) + '\\n')\\n  \\n  \\n  def compute(C,F,X):\\n      cps = 2\\n      farms = 0\\n      timespent = 0\\n      while X / cps > C/cps + X/(cps+F):\\n          farms += 1\\n          timespent += C/cps\\n          cps += F\\n  \\n      return timespent + X/cps\\n  \\n  \\n  \\n  \\n  \\n  def main_run():\\n      filenames = [x for x in os.listdir (directory)]\\n      filenames = [x for x in filenames if x.endswith('.in')]\\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\\n      chosen_filename =  sorted(l1)[-1][1][:-3]\\n  \\n      print ('Directory : ', directory)\\n      print ('Chosen Filename : ',chosen_filename)\\n      print()\\n      print ('Start : ', time.ctime())\\n      print()\\n      \\n      f_in = open(directory+chosen_filename+'.in')\\n      f_out = open(directory+chosen_filename+'.out', 'w')\\n      solve(f_in,f_out)\\n      f_in.close()\\n      f_out.close()\\n  \\n      print ()\\n      print ('End : ', time.ctime())\\n  \\n  \\n  main_run()\\n", "target": "9", "substitutes": {"directory": ["module", "d", "du", "location", "name", "distance", "package", "xf", "direct", "environment", "document", "section", "manager", "dial", "command", "division", "archive", "specified", "config", "definition", "direction", "itory", "category", "dir", "file", "condition", "project", "library", "root", "filename", "space", "domain", "home", "connection", "DI", "application", "database", "Directory", "language", "variable", "D", "machine", "office", "binary", "tree", "prefix", "selection", "metadata", "resource", "upload", "xxx", "volume", "private", "c", "python", "description", "collection", "picture", "y", "path", "mode", "folder", "password"], "f_in": ["f_input", "c_ins", "f_nin", " f_inn", "sf_again", "f__in", "f_IN", "f___ini", "f2IN", "sf_out", " f_input", "f2in", "fadeini", "sf_in", "f___out", "c_in", "f_again", "fadein", "f_inn", " f_nin", "f___nin", "f_rin", "fadeout", "F_out", "F_ins", "f__input", "f__nin", "F_IN", "f___in", "c_rin", "f__out", "f_ins", "f_ini", " f_ini", "F_in", "sf_ins", "f2out", "fadeinn", "c_out", "f2ins"], "f_out": ["f_Out", " f_off", "f_off", " f_inc", "f2in", "f__out", "f2again", "f__in", "f__Out", " f2out", " f2io", " f_err", "f_inc", " f2again", " f_Out", " f_io", " f2in", "f2out", " f_again", "f2io", "f_err", "f_io", "f_again"], "T": ["N", "G", "TN", "Time", "O", "TS", "W", "t", "TA", "M", "Z", "DT", "type", "TIME", "L", "WT", "D", "A", "R", "B", "S", "TT", "time", "E", "H", "V", "Total", "NT", "Y", "Q", "P", "TI"], "testcase": ["traincases", "vercase", "traincase", "Testcase", "vertrial", "TestCase", "estCase", "testcases", " testtrial", "verCase", "testtrial", "testCase", " testcases", "testcode", " testcode", "estcase", "trainCase", "esttrial", "vercode", "Testcases", "estcode", " testCase"], "line": ["page", "name", "col", "rule", "ine", "inline", "online", "liner", "lined", "section", "match", "channel", "case", "question", "val", "file", "response", "Line", "object", "lin", "row", "LINE", "string", "source", "nl", "log", "query", "sample", "l", "entry", "data", "block", "sel", "time", "cell", "frame", "run", "lines", "code"], "C": ["N", "CF", "Cs", "U", "G", "O", "I", "CNN", "CL", "W", "M", "NC", "CE", "K", "CM", "EC", "Z", "DC", "CC", "L", "D", "A", "R", "CN", "MC", "B", "CD", "S", "c", "CR", "E", "H", "CS", "CI", "V", "CU", "Y", "Q", "P", "Code"], "F": ["Full", "Flow", "CF", "For", "N", "U", "Factory", "Fixed", "G", "Fs", "FD", "DF", "OF", "FI", "O", "J", "I", "W", "M", "Z", "Fi", "L", "Family", "D", "A", "EF", "R", "FO", "FM", "PF", "B", "FH", "Ex", "S", "Fine", "Fun", "E", "H", "FE", "V", "RF", "Form", "FF", "Y", "Q", "P", "Far", "f", "AF"], "X": ["N", "CF", "U", "XL", "G", "Cu", "XP", "ZX", "Time", "O", "IX", "Event", "CL", "I", "TX", "W", "IP", "M", "NC", "Z", "K", "CE", "Content", "Data", "MX", "Custom", "CW", "CC", "L", "EX", "D", "A", "Check", "R", "FX", "B", "Ex", "S", "FC", "Work", "CR", "E", "H", "UX", "V", "Form", "FF", "XY", "Y", "Q", "P", "XX", "Code", "PE", "Location", "Cross"], "q": ["eq", "quant", "iq", "name", "id", "num", "i", "quality", "qa", " text", "p", " question", " Q", " query", "r", "question", "qq", "qt", " time", " z", "v", "qu", " comment", "sq", "n", "query", "type", "m", "sample", "seq", " seq", " eq", "c", "cell", " p", "k", " qu", "dq", "Q", " code", "g", "qi"], "result": ["page", "results", "compl", "default", "score", "rc", "final", "feature", "match", "ret", "complete", "case", "ver", "r", "response", "output", "report", "comment", "res", "error", "row", "dict", "grade", "valid", "value", "data", "air", "description", "Result", "success", "test", "err", "Results", "diff", "answer", "info"], "cps": ["feps", "leps", "pcaps", "cpps", "coars", "ctpps", "css", "Cups", "Cipes", "uncpped", "cmpsy", "ctpe", "fars", "fps", "cmps", "rss", " css", "pcpsy", "cmaps", "pcps", "lcPS", "lups", "cops", " cips", "lceps", "camps", "lipes", "cupped", "ramps", "Cips", "cpe", "ctps", "CPS", "cpsy", "uncpe", "fpps", "cips", "caps", "cuars", " cpp", "Camps", "lcps", "cpped", "Cps", " camps", "cPS", "cupe", " caps", "cups", "lcips", " cpsy", "cueps", "lps", "Ceps", "uncps", "cipes", "Cpy", "rps", "cpy", "uncpps", "ceps", "pcpp", " ceps", "cpp", " cpy", "cars", " cups", " cipes", " cPS", "cupps", "lcpy", "lcss", "reps", "cmpp", "copps", "lcamps", "coeps", "ctpped"], "farms": ["cores", "carming", "carms", "farming", "fares", "ctores", "qarming", "qarm", "qarms", "alfares", "alfarms", "Farms", "qores", "ctarming", "alfarming", "cares", "ctarm", "fores", "Farm", "Fares", "carm", "alfarm", "Farming", "ctarms", "farm"], "timespent": ["csep", "Timespent", "etimespent", "imesave", "imesaved", "Timespace", "cspent", " timespace", "timesaved", " timescent", "Timesep", "timescent", "timesave", "imescent", " timesaved", " timesave", "etimesaved", "csent", "imespent", "imesep", "etimesave", "cscent", "timesent", "etimescent", "imesent", "csave", "cspace", " timesent", " timesep", "timespace", "timesep", "Timesave"], "filenames": [" filENaming", "filernodes", "filenenames", "filname", "filEName", "fillename", " filename", "filenaming", "selenaming", "fillenames", "filenename", "filencename", "filennodes", "filnaming", "fileneame", "filvename", "filennocations", "fnaming", "selenames", "filenname", "filennames", "filenodes", "filnodes", " filEName", " filenaming", "filernaming", " filENames", "selenodes", "fileneames", "fnames", " filENename", "filesenaves", "fename", "filrenames", "filesrennames", "selhenodes", "filvenodes", "filernocations", "filhenaming", "filENaming", "fnodes", "filencame", "filencames", "filesennames", "filvenaming", "filennaves", "selhenames", "filENames", "selenocations", "selhenaming", "filesename", "selhenocations", "filencaming", "filhenocations", "filrennames", "fenodes", "filesrenaves", " filenename", "filrenaves", "filesrenames", "filenaves", "fileneaves", "filennnames", "fenames", "fillenaming", "filhenames", "filhenodes", "fname", "filename", "filesrename", "filesenames", "filrename", "filenocations", "filennaming", "filENename", "filvenames", "fenaming", "filnames", "fillenename", "filernames"], "x": ["xd", "xs", "xt", "name", "sex", "xp", "fx", "mx", "im", "http", "rex", "index", " xx", "xc", "php", "wx", "xxxx", "c", "xe", "ph", "xx", "y", "ax", "opt", "xia", "z", "tx", "dx", "ext", "w", "n", "l", "upload", "time", "pe", "test", "code", "f", "e", "xa", "d", "i", "p", "xy", "xml", "xes", "rx", "t", "file", "cross", "v", "re", "example", "m", "ci", "data", "rax", "ctx", "xi", "ux", "content", "h", "xf", "view", "u", "image", "r", "xb", "com", "ex", "www", "xxx", "work", "lex", "ix", "path", "nex", "qu"], "l1": [" l10", " l0", "lnone", "fl9", "fl2", "ln2", "lone", "fl1", "L0", "fl0", "ln10", "l9", " l9", "l0", " l2", "L10", "l10", " lone", "L9", "L1", "ln1", "l2", "Lone", "L2"], "chosen_filename": ["chosing_name", "churned_filename", "choseningFilename", "chosing_filename", "churned_named", "chosen_Filename", "chosen_named", "churned_directory", "chosen_directory", "chosen_username", "chosen_queue", "chosed_directory", "chosed_queue", "chosing_directory", "chosed_filename", "chosed_Filename", "chosing_Filename", "chosed_username", "choseningqueue", "chosen_name", "choseningdirectory", "churned_Filename", "choseningname", "choseningfilename"]}}
{"code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'\\n  \\n  \\n  \\n  def solve_one_case (R,C,M):\\n          l = []\\n          for i in range(R):\\n              for j in range(C):\\n                  l.append((i,j))\\n  \\n          empty_mat = []\\n          for i in range(R):\\n              empty_mat.append(['.']*C)\\n  \\n          found = False\\n  \\n          assert (0,0) in l\\n          l = l[1:]\\n          l = l[::-1]\\n          assert (0,0) not in l\\n          \\n          output = ''\\n          \\n          for mine_placement in itertools.combinations(l,M):\\n              mat = deepcopy(empty_mat)\\n              for cell in mine_placement:\\n                  mat[cell[0]][cell[1]] = '*'\\n              if isOneClick(mat, R, C, M):\\n                  mat[0][0] = 'c'\\n                  for line in mat:\\n                      output += ''.join(line) + '\\n'\\n                  found = True\\n                  return output\\n              \\n          if not found:\\n              return 'Impossible\\n'\\n          \\n          assert ValueError()\\n          \\n  def solve (f_in, f_out):\\n      T = int(f_in.readline())\\n      for testcase in range(1,T+1):\\n          line = f_in.readline()\\n          R,C,M = [int(q) for q in line.split()]\\n          print (testcase,R,C,M)\\n  \\n          output = solve_one_case (R,C,M)\\n          f_out.write('Case #' + str(testcase) + ':\\n')\\n          f_out.write(output)\\n  \\n          \\n  \\n  \\n  def isOneClick (mat, R, C, M):\\n  \\n      mat_cpy = deepcopy(mat)\\n      oneclickcells = [(0,0)]\\n      while oneclickcells:\\n          node = oneclickcells.pop()\\n          mat_cpy[node[0]][node[1]] = 'v'\\n          if noNearbyMines(mat_cpy,node):\\n              oneclickcells.extend(getNearbyUnvisited(mat_cpy, node))\\n  \\n      return sum([l.count('.') for l in mat_cpy]) == 0\\n      \\n  \\n  def getNearbyUnvisited(mat, node):\\n      R = len(mat)\\n      C = len(mat[0])\\n      deltas_r = [0]\\n      deltas_c = [0]\\n      if node[0] > 0:\\n          deltas_r.append(-1)\\n      if node[1] > 0:\\n          deltas_c.append(-1)\\n      if node[0] < R-1:\\n          deltas_r.append(1)\\n      if node[1] < C-1:\\n          deltas_c.append(1)\\n  \\n      ret_list = []\\n      for delta_r in deltas_r:\\n          for delta_c in deltas_c:\\n              next_node = (node[0]+delta_r, node[1] + delta_c)\\n              if mat[next_node[0]][next_node[1]] not in ['*','v']:\\n                  ret_list.append((next_node[0],next_node[1]))\\n  \\n      return ret_list\\n  \\n  def noNearbyMines(mat,node):\\n      R = len(mat)\\n      C = len(mat[0])\\n      deltas_r = [0]\\n      deltas_c = [0]\\n      if node[0] > 0:\\n          deltas_r.append(-1)\\n      if node[1] > 0:\\n          deltas_c.append(-1)\\n      if node[0] < R-1:\\n          deltas_r.append(1)\\n      if node[1] < C-1:\\n          deltas_c.append(1)\\n  \\n      for delta_r in deltas_r:\\n          for delta_c in deltas_c:\\n              if mat[node[0] + delta_r][node[1] + delta_c] == '*':\\n                  return False\\n      return True\\n      \\n  def main_run():\\n      filenames = [x for x in os.listdir (directory)]\\n      filenames = [x for x in filenames if x.endswith('.in')]\\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\\n      chosen_filename =  sorted(l1)[-1][1][:-3]\\n  \\n      print ('Directory : ', directory)\\n      print ('Chosen Filename : ',chosen_filename)\\n      print()\\n      print ('Start : ', time.ctime())\\n      print()\\n      \\n      f_in = open(directory+chosen_filename+'.in')\\n      f_out = open(directory+chosen_filename+'.out', 'w')\\n      solve(f_in,f_out)\\n      f_in.close()\\n      f_out.close()\\n  \\n      print ()\\n      print ('End : ', time.ctime())\\n  \\n  \\n  main_run()\\n  \\n", "target": "9", "substitutes": {"directory": ["page", "module", "d", "content", "unit", "document", "command", "config", "desc", "dir", "cat", "uri", "filename", "home", "comments", "Directory", "language", "cont", "entry", "tree", "prefix", "files", "generated", "description", "pattern", "path", "mode", "folder"], "R": ["N", "I", "MR", "Rs", "Line", "K", "Res", "index", "BR", "Q", "P", "Range", "RG", "pos", "X", "RR", "W", "_", "L", "JR", "all", "s", "F", "pattern", "RA", "AR", "U", "d", "G", "id", "RL", "input", "RC", "SR", "example", "Re", "A", "S", "CR", "E", "H", "V", "WR", "Y", "Rh", "RH", "r", "ed", "RW", "RO", "RN", "D", "B", "RS", "IR", "DR", "RM", "GR", "NR", "g", "LR"], "C": ["N", "JC", "Cs", "U", "G", "X", "SC", "Cu", "O", "I", "CL", "Size", "CA", "W", "YC", "NC", "CM", "K", "VC", "EC", "Z", "CE", "DC", "CW", "CC", "L", "Sc", "D", "A", "CN", "MC", "B", "S", "c", "KC", "CV", "CR", "E", "H", "AC", "CS", "CI", "F", "V", "CU", "Y", "Q", "P", "Code", "CT", "Con", "Cr"], "M": ["N", "range", "U", "VM", "G", " L", "ME", "X", "J", "O", "I", "CL", "MR", "r", "W", "Ms", "MD", "NM", "MQ", "CM", "v", "Z", "MS", "K", "MX", "m", "MN", "L", "n", "EM", "D", "MU", "MC", "FM", "B", "DM", "S", "E", "H", "MF", "AM", "Memory", "F", " m", "V", "Man", "RM", "Y", "Q", "P", "MM", "LM"], "l": ["e", "lit", "d", " L", "len", " lines", "lv", "pl", "p", "ll", "list", "lf", "u", "r", "z", "t", "li", "it", "left", "v", "ly", "lin", "long", "loc", "nl", "m", "n", "L", "el", "ls", "la", "dl", "fl", "lis", "sl", "ml", "acl", "all", "sel", "c", "ln", "s", "rl", "lp", "ol", "ul", "kl", "lines", "b", "le", "f", "o", "g", "lc"], "i": ["e", "ini", "si", "xi", "ip", "d", "id", "p", "I", "start", "u", "ie", "r", "li", "pi", "ai", "ui", "ni", "it", "v", "io", "n", "m", "ci", "ii", "bi", "di", "ti", "yi", "c", "int", "a", "k", "y", "ri", "iu", "b", "ind", "f", "qi"], "j": ["d", "J", "p", "I", "z", "r", "jl", "li", "ie", "jj", "v", "jam", "q", "n", "m", "jp", "ij", "ii", "c", "ja", "jc", "ji", "k", "y", "b", "f", "g", "js"], "empty_mat": ["empty_match", "blank_all", "empty_all", " empty_format", "white_math", "white_mas", "white_batch", "empty67batch", "empty_batch", "empty67math", "empty67mat", " empty_mm", "empty67mas", "empty_mas", "white_mat", "blank_match", "empty_math", "empty_tab", "empty_mm", "blank_list", "blank_mat", "empty_list", " empty_tab", "empty_format"], "found": ["failed", "default", "broken", "still", "defined", "finding", "ll", "finished", "now", "count", "like", "given", "fixed", "z", "Found", "printed", "lost", "left", " find", "form", "Find", "error", "built", "source", "expected", " Found", "used", "missing", "fl", "fall", "successful", "old", "filled", "new", "temp", "finder", "confirmed", "fe", "find", "matched", "loaded", "f", "sect", "search"], "output": ["shell", "production", "out", "complete", "left", "generation", "log", "graph", "text", "end", "debug", "version", "doc", "current", "letter", "write", "n", "L", "dot", "all", "target", "reason", "full", "module", " Output", "fn", "Output", "written", "document", "command", "xml", "input", "config", "response", "file", "comment", "summary", "layer", "plain", "example", "resource", "expression", "model", "new", "generated", "result", "format", "struct", "content", "str", "unit", "display", "image", "console", "string", "connection", "language", "analysis", "value", "job", "ln", "style", "lib", "message", "control"], "mine_placement": ["mine_Placing", "mine_placing", "mine_replacements", "mine_placements", "mine_splignment", "mine_Placement", "mine_replacing", "mine_splacing", "mine_Placements", "mine_plignment", "mine_splacements", "mine_Plignment", "mine_replacement", "mine_Pluster", "mine_repluster", "mine_explacements", "mine_replignment", "mine_pluster", "mine_explacement", "mine_expluster", "mine_explacing", "mine_splacement"], "mat": ["col", "math", "mp", "man", "qt", "mol", "position", "hm", "graph", "ut", "text", "hat", "reg", "c", "phi", "stat", "table", "mot", "att", "act", "tab", "atten", "mm", "lab", "map", "cat", "flat", "n", "la", "dot", "wa", "dim", "test", "material", "pat", "array", "net", "Matrix", "module", "fn", "p", "document", "match", "config", "mac", "feat", "file", "lin", "layer", "na", "loc", "m", "pot", "md", "temp", "format", "plot", "Mat", "at", "dom", "h", "unit", "list", "ct", "arr", "nt", "lat", "atom", "dict", "mult", "grid", "ml", "wt", "mt", "ma", "nat"], "cell": ["shell", "col", "cle", "Cell", "word", "unit", "p", "match", "list", "ce", "letter", "column", "case", "cat", "cells", "co", "v", "object", "group", "row", "layer", "field", "ell", "cy", "q", "edge", "el", "cl", "entry", "element", "char", "model", "c", "cc", "label", "key", "k", "character", "lic", "call", "cel", "contact", "lc"], "line": ["page", "shell", "range", "e", "name", "col", "word", "inline", "len", "str", "lo", "unit", "header", "lined", "section", "point", "match", "lf", "list", "out", "input", "column", "case", "file", "li", "Line", "left", "lin", "row", "string", "layer", "LINE", "error", "look", "source", "nl", "log", "n", "entry", "live", "link", "data", "text", "ml", "sync", "block", "model", "ln", "label", "int", "frame", "cycle", "run", "lines", "code", "chain", "lc"], "T": ["N", "TR", "U", "Length", "X", "TN", "Time", "O", "I", "TS", "W", "t", "TA", "Z", "K", "DT", "L", "WT", "D", "B", "S", "TT", "Ts", "E", "H", "F", "Type", "V", "Total", "NT", "Y", "Q", "P", "CT", "TI"], "testcase": ["catchtype", "catchcase", "catchsequence", "showCase", "testposition", "showcase", "exampleCase", "xtposition", "Testcase", "fitCase", "TestCase", "examplecase", "testnumber", "estCase", " testposition", " testnumber", "testtrial", "testsequence", "xtcase", "Testtype", "Testtrial", "fitcase", "testtype", "testCase", "xtnumber", "exampletrial", "showsequence", "fitposition", "catchCase", "Testsequence", "estnce", "estcase", "xtCase", "esttrial", "testnce", "fitnumber", "showtype", "Testnce", "examplence", " testCase"], "mat_cpy": ["mat_fPy", "mat_Cpes", "mat_ccps", "mat_popy", "mat_ccpy", "mat_ncpy", "mat128cps", "mat_cpython", "mat_lpy", "mat128ccpy", "mat_ppy", "mat_fp", "mat_lopy", "mat_Cpu", "mat_cps", "mat128ccps", "mat_cPy", "mat_fpe", "mat_ccpu", "mat_cpes", "mat_Cpc", "mat_cachepython", "mat_copy", "mat_CPy", "mat_Cpsy", "mat_fps", "mat_fpes", "mat_cachepe", "mat128cpu", "mat_cachepsy", "mat_locpy", "mat_Cps", "mat_ncpsy", "mat_Copy", "mat_ncpython", "mat_cpsy", "mat_cpe", "mat_Cpy", "mat_locpe", "mat_pPy", "mat_ncpe", "mat_lpe", "mat_lp", "mat128ccpu", "mat_fpc", "mat128cpe", "mat_Cp", "mat_fopy", "mat_locpc", "mat_Cpython", "mat_cachepy", "mat_locpes", "mat_ppe", "mat_fpy", "mat128ccpe", "mat_cpu", "mat_cp", "mat_fpu", "mat_cpc", "mat_Cpe", "mat_ccpe", "mat128cpy"], "oneclickcells": ["onepixelcells", "oneClicklines", "onechipcells", " oneclickells", "oneleftcells", "onechipells", "onefocuscells", " oneclickrows", "onefocusells", "oneclickcell", " onebuttonells", "oneClickcells", "onecrossrows", " onechipcells", "oneclicklines", " oneclickcats", "oneleftcell", "oneClickcell", "oneClickcats", "onefocuscases", " oneclicklines", " oneclickcases", " oneclickcs", "onebuttoncs", "onechipholes", "oneclickells", " onechipcats", "onebuttoncells", "oneswitchcs", " oneswitchcases", " onebuttonholes", "oneswitchcells", "onecrosscases", " oneswitchells", "onefocusrows", "oneclickcases", "oneleftstates", "onepixelcats", " oneswitchcells", "onechipcats", "onebuttonholes", "oneclickstates", "oneswitchrows", "oneswitchholes", "oneclickcs", "onechipcs", " oneclickstates", "oneswitchells", " onebuttoncells", "oneclickcats", "oneClickstates", " onebuttoncs", "onebuttonells", "onepixellines", " oneclickholes", "oneswitchcases", " onechiplines", "oneclickrows", "onecrossells", "oneclickholes", "onecrosscells", "onechiplines", " oneswitchrows", " oneclickcell"], "node": ["N", "e", "gen", "cdn", "event", "location", "name", "id", "word", "package", "enc", "ode", "document", "op", "none", "input", "child", "mor", "object", "route", "comment", "card", "cut", "layer", "row", "ha", "scene", "part", "parse", "connection", "root", "source", "nn", "edge", "loc", "un", "n", "remote", "core", "day", "seed", "valid", "index", "tree", "element", "live", "local", "missing", "link", "component", "block", "model", "anch", "dest", "label", "key", "parent", "leaf", "set", "stroke", "Node", "path", "f", "post", "load"], "f_in": ["f_In", "fLoginner", "cf_inner", "sf_resource", "f64in", "cf_out", "cf_in", "sf_inner", "f__inner", "sf_out", "cf_ins", "f2in", "f__out", "f__in", "f_ins", "f_inner", "sf_in", "f2inner", "fLogin", "f64out", "f64ins", "f_resource", "sf_ins", "f2out", "fLogins", "f64inner", "f__ins", "fLogout", "sf_In", "f2ins"], "f_out": ["f_output", "firmtemp", "firmin", "f2err", "c_err", "fiddleout", "f_temp", "fiddletemp", "f2in", " f_output", "c_io", "f__out", "fiddlein", "f__io", "f__in", " f2out", " f2io", " f_engine", "fiddleengine", "f_engine", " f_io", " f2in", " f_temp", "firmengine", "f2out", "f2io", "f__err", "f_err", "firmout", "c_in", "c_out", " f2output", "f_io", "f2output"]}}
{"code": "\\n  f = open( sys.argv[1] )\\n  f.readline()\\n  \\n  numcases = 1\\n  input = f.readline()\\n  while input != \"\":\\n  \tinC,inF,inX = [float(x) for x in input.split()]\\n  \\n  \tstart = (0.0,0.0,2.0)\\n  \th = [start]\\n  \tchecked =set()\\n  \\n  \twhile h[0][1] < inX:\\n  \t\tx = heapq.heappop(h)\\n  \\n  \t\tif x in checked:\\n  \t\t\tcontinue\\n  \t\telse:\\n  \t\t\tchecked.add(x)\t\\n  \\n  \t\ttime,numCookies,rate = x\\n  \t\ttimeW = (inX - numCookies) / rate\\n  \t\theapq.heappush( h,(time+timeW,numCookies+rate*timeW,rate) )\\n  \\n  \t\ttimeF = (inC - numCookies) / rate\\n  \t\tnewC = numCookies + rate*timeF\\n  \t\tnewT = time + timeF\\n  \t\theapq.heappush( h,(newT,(newC - inC),rate+inF) )\\n  \t\theapq.heappush( h,(newT,newC,rate) )\\n  \\n  \toutput = \"{:.7f}\".format(h[0][0])\\n  \\n  \tprint \"Case #\"+str(numcases)+\": \"+output\\n  \tinput = f.readline()\\n  \tnumcases += 1\\n  \t\\n", "target": "10", "substitutes": {"f": ["e", "fw", "full", "fd", "d", "fr", "i", "fn", "bf", "p", "lf", "r", "handler", "t", "file", "fb", "tf", "form", "v", "io", "feed", "w", "sf", "m", "l", "rf", "function", "fp", "inf", "fast", "fs", "c", "s", "F", "b", "fc", "fen", "g", "folder", "fa"], "numcases": [" numrows", "numbertests", "numberevents", "numcuts", "ncells", "umevents", "nrows", "numcells", " numchains", "ncases", "numevents", " numcells", "numberchains", "umtests", "NUMchains", "NUMtests", "nevents", " numcuts", "numberrows", "numchains", " numevents", "umcases", "NUMcuts", "numbercases", "umcells", "NUMcases", "numrows", "ntests", " numtests", "numbercuts", "numtests"], "input": ["exec", "exc", "rc", "content", " Input", "qa", "RAW", "unit", "document", "current", "next", "address", "command", "PUT", "out", "xml", "config", "case", "image", "flow", "question", "action", "form", "comment", "submit", "cli", "error", "string", "Input", "help", "source", "feed", "cur", "q", "initial", "entry", "resource", "value", "inf", "data", "text", "raw", "enter", "progress", "empty", "temp", " inputs", "result", "buffer", "pattern", "active", "request", "argument", "load", "answer", "url"], "inC": ["outC", " inCC", "newB", "outX", "onN", " inT", "outT", "onC", " inW", "newF", "inCC", "outB", " inN", "inB", " inE", "inE", "inW", "newX", "incN", "inN", "outF", " inB", "outCC", "incE", "incW", "outP", "inT", "INP", "INCC", " inP", "INT", "inP", "INC", "onW", "onE", "incC"], "inF": ["iniW", "outT", " inV", "InV", " inW", "InD", "outD", "iniT", "inW", "iniX", "inG", "InW", "outF", "InG", "InT", "inD", "inT", "InF", "iniG", "iniD", "outG", "iniF", "InX", "inV", "iniV"], "inX": ["outC", "InY", "isinQ", "outX", "InQ", "isinX", "outY", " inx", "Inx", " inY", "incX", "inx", "inQ", "INX", "incR", " inQ", " inR", "inY", "InC", "isinY", "INC", "INQ", "outR", "isinC", "InX", "incY", "INx", "inR", "incC"], "x": ["e", "xd", "xs", "xi", "d", "name", "event", "num", "i", "px", "X", "ww", "xxxxxxxx", "xp", "content", "sex", "xf", "p", "xy", "fx", "max", " X", "u", "z", "r", "rx", "t", "check", "exp", "cross", "tx", "xb", " xp", "v", "_", "dx", "example", "w", "day", "cl", "index", "he", "ex", "data", "xc", "php", "xxx", "wx", "sync", "c", "xe", "work", "new", "test", "xx", " y", "fe", "ix", "y", "b", "ax", "g", "abc"], "start": ["range", "size", "starting", "stop", "speed", "id", "offset", "i", "step", "p", "add", "Start", "now", "change", "v", "source", "w", "limit", "seed", "index", "order", "base", "c", "end", "init", "set", "k", "open", "active", "y", "started", "skip", "info", "check"], "h": ["e", "ctx", "loop", "d", "hi", "self", "i", "hash", "hand", "lo", "p", "ch", "hh", "ah", "u", "r", "sh", "t", "host", "form", "history", "hist", "v", "ha", "ih", "ht", "home", "http", "help", "w", "hm", "q", "m", "n", "hr", "l", "log", "he", "cl", "oh", "hp", "rh", "body", "g", "c", "work", "s", "end", "H", "head", "gh", "ph", "k", "y", "hs", "b", "handled", "o", "eh", "bh", "check", " hp"], "checked": ["failed", "interrupted", "broken", "checking", "selected", "locked", " unchecked", "done", "disabled", "coded", "required", "finished", "worked", "count", "changed", "tested", "enabled", "fixed", "static", "printed", "closed", "history", "connected", "q", "expected", "restricted", "forced", "used", "checks", "controlled", "confirmed", "set", "matched", "active", "found", "started", "loaded", "handled", "check", "packed"], "time": ["size", "speed", "name", "money", "power", "Time", "length", "ime", "year", "change", "t", "date", "rice", "home", "w", "sleep", "type", "m", "TIME", "age", "clock", "tim", "value", "data", "close", "right", "hour", "times", "c", "work", "temp", "end", "depth", "delay", "timer", "code", "cost", "frequency", "timeout", "info"], "numCookies": [" numcookipes", "maxcookles", "numRecies", "numcookings", "numRecipeies", "numcookipes", "numBrewies", " numBrewIES", "numConfigys", "numCipes", " numBrewries", " numCookuries", "numCookries", "numCircries", " numRecipeys", "maxcookries", " numCookices", "numColds", " numCookIES", "maxCookys", "numCookisodes", "numCookles", " numcookings", " numcookuries", " numBrewies", "numIngredientsys", "numIngredientsries", "maxCookles", "numConfigles", "numConfigies", "numRecipeices", "maxcookys", "numcookys", "numIngredientsles", " numCookys", "numCooks", "numColdys", " numBrewipes", "numcookisodes", "numcooks", " numcookys", " numRecipeices", "numReciperies", "numRecipes", "numcookles", "numCIES", "numIngredientsies", "numCookuries", " numcooks", "numBrewipes", "maxCookies", "numCircies", "numCies", "numRecings", " numReciperies", "numBrewys", "numcookuries", "numCircipes", "numcookies", "numConfigices", " numCookipes", " numCooks", "numRecipeys", "numBrews", "numCookings", " numcookies", "numCircIES", " numRecipeies", "numCries", "numCookys", "numBrewries", " numCookries", "numcookices", "numBrewuries", "maxcookies", " numCookings", "numCookipes", "numConfigries", "numcookries", "numColduries", " numCookisodes", "numCookices", " numcookisodes", "numCookIES", "maxCookries", "numRecisodes", "numColdies", "numBrewIES"], "rate": ["rand", "weight", "duration", "name", "ime", "case", "number", "race", "prime", "slave", "sleep", "rank", "seed", "zip", "price", "depth", "delay", "ate", "range", "speed", "priority", "rule", "rated", "width", "length", "ride", "write", "currency", "type", "dim", " speed", "cycle", "code", "score", "id", "play", "match", "Rate", "date", "rice", "density", "re", "core", "grade", "resource", "order", "rates", "key", "run", "cost", "frequency", "rating", "size", "charge", "repeat", "unit", "rat", "r", "change", "level", "source", "late", "age", "fare", "value", "erate", "sync", " frequency", "base", "use", "fan", "fee", "mode", "scale"], "timeW": ["timew", "TimeV", "TimeC", "imew", "speedW", "Timew", "imeC", "speedw", "TimeH", "costH", "speedL", "timeC", " timew", "costF", " timeC", "imeW", " timeV", "costW", "timeL", "timeV", "imeF", "TimeF", "costL", "speedH", "speedV", "TimeL", "TimeW", "timeH", "speedF"], "timeF": ["timW", "memoryW", "TimeD", "memoryf", "TimeC", "timeD", "rateF", "timT", "clockW", "timerW", "timf", "timerF", "memoryF", "timeGF", "timeT", "valueW", "timef", "memoryT", "timeC", " timeD", "timerT", "rateD", "rateW", "clockF", "TimeF", "clockC", "clockGF", "valueC", "timerf", "TimeW", "valueF", "valueGF", "TimeGF", "timF"], "newC": ["NewT", "NEWT", "NewP", "NewCE", "existingT", " newF", " NewT", "nextH", "newP", "newF", " NewCE", "NewC", "newCE", "nextF", "NEWC", " newCE", "newH", "Newc", "oldc", "oldC", " NewP", "existingc", "existingC", " newP", "oldP", "nextC", "NEWH", "oldT", "newc", " newH", " NewC", "existingP", "NEWF", "nextT"], "newT": ["firstC", "NewT", "NewF", "newTA", "freshDT", "freshTime", " newF", "firstT", "newF", "rawDT", "rawTA", "newDT", "NewC", " newt", "nextF", "Newt", "nextTime", "NewTime", "rawT", "newt", " newTime", "nextTA", "newTime", "freshT", "nextDT", "firstt", "nextC", "firstF", "freshTA", "rawTime", "nextT"], "output": ["exec", "double", "operation", "edit", "Output", "written", "unit", "document", "\u3044", "command", "out", "xml", "config", "letter", "sequence", "response", "write", "console", "number", "left", "summary", "string", "help", "source", "again", "log", "resource", "function", "expression", "dot", "value", "text", "new", "generated", "result", "until", "format", "version", "control"]}}
{"code": "\\n  def makeBoardR(b):\\n  \tnumR, numC, numMines, filledR, filledC = b\\n  \tq = numMines / numR\\n  \tr = numMines % numR\\n  \\n  \tif q <= numC-2 and r == 0:\\n  \t\tboard = [\"*\"*(filledC + numC) for x in range (filledR)]\\n  \t\tboard.append( \"*\"*(filledC+q)+\".\"*(numC-q) )\\n  \t\tboard.append( \"*\"*(filledC+q)+\".\"*(numC-q-1)+\"c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telif numMines == numR * numC - 1:\\n  \t\tboard = [\"*\"*(filledC + numC) for x in range (filledR+1)]\\n  \t\tboard.append( \"*\"*(filledC+numC-1)+\"c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telse:\\n  \t\toutput = \"Impossible\"\\n  \\n  \treturn output\\n  \\n  def makeBoardC(b):\\n  \tnumR, numC, numMines, filledR, filledC = b\\n  \tq = numMines / numC\\n  \tr = numMines % numC\\n  \\n  \tif q <= numR-2 and r == 0:\\n  \t\tboard = [\"*\"*(filledC+numC) for x in range(filledR+q)]\\n  \t\tfor x in range( numR-1-q ):\\n  \t\t\tboard.append( \"*\"*filledC + \"..\" )\\n  \t\tboard.append( \"*\"*filledC + \".c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telif numMines == numR * numC - 1:\\n  \t\tboard = [\"*\"*(filledC+numC) for x in range(filledR+numR-1)]\\n  \t\tboard.append( \"*\"*(filledC+numC-1) + \"c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telse:\\n  \t\toutput = \"Impossible\"\\n  \treturn output\\n  \\n  def makeBoard(b):\\n  \tnumR, numC, numMines, filledR, filledC = b\\n  \tq = numMines / (numC-2)\\n  \tr = numMines % (numC-2)\\n  \\n  \tboard = [\"*\"*(numC+filledC) for x in range(filledR)]\\n  \tfor x in range(q):\\n  \t\tboard.append( \"*\"*(numC-2+filledC)+\"..\" )\\n  \tboard.append( \"*\"*(r+filledC)+\".\"*(numC-r) )\\n  \tfor x in range(numR-q-2):\\n  \t\tboard.append( \"*\"*filledC+\".\"*numC )\\n  \tboard.append( \"*\"*filledC + \".\"*(numC-1) + \"c\" )\\n  \treturn \"\\n\".join(board)\\n  \\n  def makeBoard0(b):\\n  \tnumR,numC,numMines,filledR,filledC = b\\n  \tboard = [\"*\"*(numC+filledC) for x in range(filledR)]\\n  \tfor x in range(numR-1):\\n  \t\tboard.append( \"*\"*(filledC)+\".\"*numC )\\n  \tboard.append( \"*\"*(filledC) + \".\"*(numC-1) + \"c\" )\\n  \treturn \"\\n\".join(board)\\n  \\n  f = open( sys.argv[1] )\\n  f.readline()\\n  \\n  numCase = 1\\n  l = f.readline()\\n  while l != \"\":\\n  \tnumR, numC, numMines = [int(x) for x in l.split()]\\n  \\n  \tboards = deque()\\n  \tif numR == 1:\\n  \t\tif numC == 1 and numMines == 0:\\n  \t\t\toutput = \"c\"\\n  \t\telif numC == 1 and numMines > 0:\\n  \t\t\toutput = \"Impossible\"\\n  \t\telse:\\n  \t\t\toutput = \"*\"*numMines + \".\"*(numC-numMines-1) + \"c\"\\n  \telif numC == 1:\\n  \t\toutput = \"\\n\".join(\"*\"*numMines + \".\"*(numR-numMines-1) + \"c\")\\n  \telse:\\n  \t\tboards.append( (numR,numC,numMines,0,0) )\\n  \t\toutput = \"Impossible\"\\n  \\n  \twhile output == \"Impossible\" and len(boards) > 0:\\n  \t\tb = boards.popleft()\\n  \t\tnumR,numC,numMines,filledR,filledC = b\\n  \t\tif numMines == 0:\\n  \t\t\toutput = makeBoard0(b)\\n  \t\t\tbreak\\n  \\n  \t\tif numMines >= numC and numR > 2:\\n  \t\t\tboards.append( (numR-1,numC,numMines-numC,filledR+1,filledC) )\\n  \t\tif numMines >= numR and numC > 2:\\n  \t\t\tboards.append( (numR,numC-1,numMines-numR,filledR,filledC+1) )\\n  \\n  \t\tif numMines <= (numR-2)*(numC-2):\\n  \t\t\toutput = makeBoard(b)\\n  \\n  \t\tif numR == 2:\\n  \t\t\toutput = makeBoardR(b)\\n  \\n  \t\tif numC == 2:\\n  \t\t\toutput = makeBoardC(b)\\n  \t\t\\n  \tprint \"Case #\"+str(numCase)+\":\\n\"+output\\n  \tl = f.readline()\\n  \tnumCase += 1\\n", "target": "10", "substitutes": {"b": ["br", "rb", "bl", "d", "bb", "ob", "cb", "i", "pb", "h", "bf", "p", "sb", "j", "book", "t", "wb", "lab", "fb", "object", "v", "root", "pa", "home", "http", "bis", "obj", "bar", "n", "gb", "m", "boot", "bd", "bub", "B", "ib", "body", "back", "base", "nb", "c", "bc", "lib", "app", "lb", "a", "abs", "k", "ab", "this", "bs", "db", "bp", "y", "bas", "amb", "o", "mb", "hub"], "numR": ["nM", "NUMM", "nC", "NUMR", "nbr", " numM", "nbR", "monL", "NumRs", "numL", " numX", "NumR", "umRs", "nbRs", "nr", "umC", "sumL", " numP", "sumM", "numP", "nomD", "numM", "umR", "umL", " numr", "NumN", "sumC", " numRs", "numX", "NumL", "NumC", "NumP", " numD", "nL", "NUMP", " numRec", "nomM", "monC", "nbC", "nP", "nR", " numN", "numRec", "umN", "sumR", "nomRec", "nomC", "numN", "sumr", "NUMX", "nomR", "monX", "sumN", "NumD", "NumM", "numD", " numL", "monP", "numr", "widthr", "widthC", "numRs", "widthR", "monR", "nomL", "widthM", "monM", "umM", "NumRec", "umr"], "numC": ["domR", "NUMM", "numberCC", "nC", "umD", "NUMR", "NUMN", "nuN", "homC", " numM", "nomc", "umS", "nuCS", "multiL", "multiD", "namc", "multiP", "sumE", " numCor", "numL", "NumR", "sumCM", "numCM", "nT", "umiR", "numberCs", "numT", "namS", "nCS", "numc", "homc", "nuC", "umC", "umic", "multiT", " numP", "multic", "umc", " numT", "nN", "domc", "namN", "numP", "NumCS", "nomD", "sumCs", " numU", "numM", "umR", "NumCor", "umL", "numCs", "NumN", "numberc", "NUMT", "sumC", "namC", "umiC", "numberN", "normC", "numberR", "numU", "NumL", "normc", "NumC", "sumc", "NumP", "numE", " numD", "numberCor", " numE", "nL", "umiCM", " numc", "nomU", "umCC", "numberC", "normR", "domCs", "normS", "nP", "nR", "homR", "NUMc", "numCS", "numberCM", " numN", "umN", "sumR", "multiC", "nomC", "numCC", "NUMD", "numN", "NUMC", "NumD", "nE", "NumM", "nuP", "NUML", "NumT", "numD", " numL", "numCor", "namR", "NumE", "numberD", "domC", "domCC", "domE", "nc", "NumU", "numS", "nD", "umE", "Numc"], "numMines": ["numPiddles", "homCizes", "numGides", "numRines", "numCMizes", "nbmizes", "numCodes", "numGiners", "numPine", "numMains", "numPiners", "nMine", "nMines", " numGides", "numLakes", " numPiddles", "numMarks", "numDizes", "numGimes", "numMipes", "numMachines", "numRinations", "nummined", "nummains", "numMine", "NumCines", "numMsakes", "numLains", " numMakes", "numCinations", "numNains", "numTains", " numNins", "numMakes", "numTakes", "numPipes", "umiMine", "numModes", "numMachipes", "nMined", "numGizes", "nbmines", "NumMines", "nMains", " numGimes", "numDeminers", " numMimes", "numDemines", "numMimes", "numMiddles", "numCakes", " numGains", "numMachiddles", "nbMines", "numGains", "numGakes", "nGined", "numMiners", " numGiners", "homCinations", " numMinks", "nummizes", "numCians", "umiMiners", "umiDemarks", "numDimes", " numGines", " numNakes", "numCMines", "numLined", "homCines", " numMiners", "umiMines", "numPanes", " numTined", "homCodes", " numPanes", "numCines", "numNinks", "numDiddles", " numGined", "numDemarks", " numPines", "numNined", "numTines", "numDines", "numTins", "numMined", "nbmined", "numDined", "numMides", "numMsiques", "nGines", "numParks", "homMines", "numCizes", " numMined", "numRizes", " numPipes", "numCModes", " numMains", " numGizes", "numMsines", "numCMinations", " numMizes", "numGine", "numNins", "umiDeminers", "numMachanes", "numNakes", "NumCains", "numLines", "numminers", " numMides", "numRodes", "numCains", "numNides", "nummimes", " numMiddles", "nbMians", "numGians", "numCiners", " numMins", "numCined", " numTines", "numTined", "umiDemine", "numTiques", "nGine", "nbmians", "numManes", "numDemine", "umiDemines", "homMinations", "homMizes", " numMipes", "nbMined", "numCides", "NumCides", " numTakes", "NumMakes", " numManes", " numNines", "numCine", "umiMarks", " numMiques", "numMizes", "numMsins", "numGinks", " numNiques", "numDipes", "nGains", "nbMizes", " numGinks", "numMiques", "numMinks", "numGined", "numNiques", "nummines", "numMians", "numLine", "NumCakes", " numTains", "numNines", "numDanes", "homModes", "nummians", "numMinations", "numMins", "NumMides", "numPines", "numGines", "NumMains"], "filledR": [" filledr", "filledRs", "printedGr", "drawnR", "finishedRR", "loadedQ", "playedAt", "loadedDR", "selectedRs", "finishedR", "finishedLine", "numK", "filledQ", "loadedD", " filledD", "selectedQ", "printedRe", "printedR", "printedLine", "finishedK", "printedP", "filledP", "printedr", "numP", "loadedAt", "printedRs", " filledRR", "publishedJ", "signedRe", "selectedDR", "finishedGr", "printedRun", "filledRe", "playedRR", "filledK", "filledAt", "filledRun", "finishedr", "filledGr", "filledJ", "publishedRun", "loadedR", " filledAt", "printedC", "selectedr", "finishedJ", "loadedC", " filledQ", "filledRR", "finishedRe", "loadedRs", "printedK", "selectedL", "filledr", "loadedRR", "publishedGr", " filledL", "finishedRun", "signedr", "finishedC", "filledD", "loadedL", "filledLine", "filledL", "playedL", "printedJ", "selectedC", "publishedR", "loadedr", "filledDR", "signedR", "finishedP", "signedLine", "drawnDR", "finishedD", "playedR", "selectedR", "drawnC"], "filledC": ["builtC", " filledCM", "drawnR", "loadedCT", "focusedC", "paintedFrom", "filledCT", "filledB", "foundC", "numCode", "filledCM", "filledMC", "focusedD", "printedD", "hedR", "loadedD", "paintedR", "hedCode", "packedC", "ippedCT", "loadedCI", "filledCode", "filledFrom", "filledCL", "paintedCS", "numc", "printedR", "ippedS", "filledCS", " filledNC", "loadedMC", "paintedSc", "loadedS", "focusedCl", "keptc", "drawnCustom", "packedc", "ippedC", "filledM", "filledS", "loadedSc", "packedE", "filledSc", "loadedM", "builtCL", " filledCustom", " filledE", "placedC", "placedc", "builtS", "paintedCL", "illedC", "printedB", "keptR", "filledCh", " filledCA", "ippedR", " filledc", "loadedCustom", "packedR", "filledCustom", "focusedB", "filledNC", "paintedS", "keptCode", "paintedC", "builtR", "foundR", " filledCI", "loadedR", " filledM", " filledMC", "illedCAR", "printedC", "illedCh", "numE", "paintedCs", "filledc", " filledCh", " filledS", "loadedC", "loadedc", "loadedCh", "wonS", "shownCI", "paintedCA", "foundCS", "loadedFrom", "paintedc", "drawnNC", "loadedCs", "filledD", "loadedCAR", "filledCI", "shownR", "filledCA", " filledFrom", "filledCs", "wonCL", "loadedN", "hedc", "loadedCM", "filledCAR", "hedC", "filledCl", " filledCT", "wonC", "filledE", "placedR", "keptC", "placedCs", " filledCl", "filledN", "packedSc", "focusedR", "shownMC", "paintedCM", "loadedNC", "paintedCl", "paintedM", " filledN", "loadedB", " filledCAR", "wonR", "illedN", "focusedCA", "loadedCS", "shownC", "drawnC", "illedR"], "q": ["eq", "charge", "quant", "d", "iq", "qs", "id", "i", "ail", "quality", "requ", "h", "qa", "ac", "p", "que", "ch", "j", "ur", "ce", "max", "qual", "u", "qi", "count", "z", "qt", "qq", "t", "ai", "sh", "ill", "v", "am", "row", "w", "sq", "kg", "m", "query", "n", "ak", "cl", "one", "back", "c", "s", "int", "k", "depth", "quest", "ix", "dq", "y", "ue", "Q", "needed", "ck", "load", "req", "g", "qu"], "r": ["e", "range", "rr", "rb", "d", "tr", "i", "rc", "h", "p", "ur", "pr", "ar", "er", "u", "z", "arr", "t", "v", "ir", "re", "w", "m", "n", "rf", "R", "ru", "order", "right", "rh", "g", "rt", "pc", "c", "s", "kr", "k", "rs", "rd", "asc", "nr", "sr", "y", "err", "rg", "cr", "o"], "board": ["che", " row", "case", "ward", "design", "object", "pool", "row", "box", "uc", "stone", "back", "cell", " game", "node", "stroke", "loop", "device", "player", "word", "bo", "clean", "ban", "court", "ui", "bit", "poll", "feed", "craft", "video", "wall", "ack", "detail", "code", "post", "game", "hold", "lay", "client", "deck", "cart", "document", "layout", "channel", "input", "holder", "lane", "cross", "flo", "comment", "layer", "error", "Board", "function", "block", "model", "progress", "ck", "phone", "draw", " dashboard", "lock", "wheel", "bug", "pod", "panel", "coll", "view", "que", "list", "hole", "image", "flow", "boarding", "home", "sync", "batch", "cache", "work", "round", "road", "screen", " clipboard", "bank", "control", "menu"], "x": ["full", "ctx", "xi", "xt", "ux", "my", "col", "id", "X", "sex", "h", "xp", "xf", "p", "xy", "fx", "max", "xes", "ct", "rx", "z", "val", "t", "yx", "bit", "_", "v", "co", "na", "yl", "w", "m", "n", "cl", "index", "ex", "xc", "wx", "xe", "work", "lex", "k", "xx", "ix", "y", "code", "nex", "ax", "g", "qu"], "output": ["production", "environment", "section", "complete", "come", "out", "future", "number", "design", "object", "generation", "position", "component", "ut", "benefit", "put", "toc", "debug", "version", "page", "fore", "operation", "word", "current", "product", "PUT", "write", "dt", "ilo", "dot", "ou", "target", "detail", "net", "ort", "update", "module", "don", "edit", "Output", "document", "export", "input", "config", "response", "summary", "layer", "pre", "application", "pot", "outer", "resource", "function", "progress", "result", "run", "external", "struct", "unit", "exit", "display", "image", "flow", "console", "cut", "respond", "job", "cache", "round", "lib", "control"]}}
{"code": "\\n  \\n  def click(C, F, X):\\n      states = Queue.PriorityQueue()\\n  \\n      states.put((0.0, 2.0, False))\\n      while not states.empty():\\n          time, rate, is_done = states.get()\\n  \\n          if is_done:\\n              return time\\n  \\n          states.put((\\n              time + X / rate,\\n              rate,\\n              True\\n          ))\\n  \\n          states.put((\\n              time + C / rate,\\n              rate + F,\\n              False\\n          ))\\n  \\n      return None\\n  \\n  def main():\\n      cases = int(sys.stdin.readline())\\n  \\n      for case in range(cases):\\n          C, F, X = map(float, sys.stdin.readline().split())\\n          print 'Case #%d: %.7f' % (case + 1, click(C, F, X))\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "target": "11", "substitutes": {"C": ["N", "CF", "U", "Cy", "Cu", "Time", "O", "CL", "I", "CA", "W", "M", "EC", "CM", "Z", "CE", "K", "DC", "CP", "CC", "L", "D", "A", "R", "T", "B", "S", "FC", "c", "E", "H", "CS", "CI", "V", "CU", "FF", "Y", "Q", "P", "CT"], "F": ["N", "Flow", "CF", "U", "Fs", "FD", "DF", "OF", "I", "FB", "W", "FL", "BF", "File", "M", "Z", "Fi", "FS", "L", "Family", "FO", "EF", "FM", "FH", "PF", "T", "B", "FA", "FC", "GF", "FE", "Feed", "E", "H", "V", "RF", "FF", "Y", "Q", "P", "f", "AF", "FW", "Fe"], "X": ["N", "CF", "U", "XL", "Time", "XP", "O", "IX", "XXX", "CL", "I", "TX", "W", "IP", "Z", "CE", "K", "EC", "XM", "CC", "L", "Cross", "EX", "D", "R", "T", "FX", "B", "Ex", "FC", "Work", "FE", "E", "H", "UX", "x", "V", "DX", "FF", "XY", "Y", "Q", "P", "XX", "PE", "FW"], "states": ["rules", "settings", "queue", "results", "events", "jobs", "workers", "ids", "works", "properties", "stats", "services", "outs", "stores", "start", "status", "games", "dates", "cells", "plays", "state", "lights", "types", "sleep", "forces", "plugins", "powers", "ins", "seconds", " services", "rooms", "keys", " stations", "ss", "rates", "locks", "groups", "charges", "models", "sync", "times", "files", "strings", "players", "frames", "blocks", "flows", "cycles", "items", "tests", "reports", "States", "lines", "users", "sites", "ports", "runs", "chains", "objects", "steps"], "time": ["size", "speed", "d", "name", "event", "money", "weight", "id", "play", "true", "Time", "current", "length", "ime", "now", "start", "count", "year", "micro", "change", "it", "date", "rice", "race", "sleep", "TIME", "age", "clock", "value", "data", "hour", "back", "times", "all", "new", "c", "s", "end", "frame", "depth", "when", "call", "delay", "timer", "cost", "user", "timeout"], "rate": ["rating", "range", "size", "counter", "speed", "weight", "name", "duration", "score", "event", "rule", "rated", "Time", "length", "Rate", "count", "r", "change", "level", "number", "write", "currency", "date", "race", "rice", "feed", "sample", "age", "seed", "grade", "order", "value", "data", "rates", " frequency", "sync", "erate", "base", "stage", "FE", "key", "factor", "use", "price", "depth", "cycle", "x", "buffer", "delay", "timer", "fee", "dist", "f", "frequency", "timeout", "mode", "scale"], "is_done": ["is_Done", " is_finished", "is_finished", "is_started", " is_Done", "is_handled", " is_handled", " is_started"], "cases": ["classes", "settings", "xs", "events", "shows", "rows", "changes", "points", "sections", "features", "ints", "values", "cells", "ches", "types", "cs", "comments", "tips", "ups", " tests", "Times", "forces", "rooms", "breaks", "times", "checks", "files", "blocks", "cycles", "tests", "limits", "lines", "ases", "chains", "runs", "steps"], "case": ["e", "default", "id", "num", "i", "slice", "address", "length", "ace", "ride", "ce", "config", "count", "ct", "instance", "ase", "number", " i", "change", "ASE", "race", "Case", "index", "ice", "c", "use", "end", "int", "test", "chance", "catch", "x", "character", "line", "choice", "USE", " CASE", "code", "f"]}}
{"code": "\\n  NEIGHBOURS = [\\n      (-1, -1), (-1, 0), (-1, 1),\\n      ( 0, -1),          ( 0, 1),\\n      ( 1, -1), ( 1, 0), ( 1, 1),\\n  ]\\n  \\n  MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\n  \\n  def valid(size, location, changes):\\n      y, x = location\\n      for y1, x1 in changes:\\n          y1 += y\\n          x1 += x\\n          if y1 < 0 or y1 >= size[0]:\\n              continue\\n          if x1 < 0 or x1 >= size[1]:\\n              continue\\n          yield (y1, x1)\\n  \\n  def click(size, grid, location):\\n      y, x = location\\n      if grid[y][x] is 0:\\n          return None\\n  \\n      grid = [row[:] for row in grid]\\n      grid[y][x] = 0\\n  \\n      for y, x in valid(size, location, NEIGHBOURS):\\n          if grid[y][x]:\\n              grid[y][x] = False\\n  \\n      return grid\\n  \\n  def sweep(R, C, M):\\n      grid = [[True] * C for _ in range(R)]\\n      size = (R, C)\\n  \\n      if M + 1 == R * C:\\n          grid[0][0] = False\\n          return grid, (0, 0)\\n  \\n      states = []\\n      for y in range(R):\\n          for x in range(C):\\n              location = (y, x)\\n              states.append((click(size, grid, location), location))\\n  \\n      while states:\\n          grid, location = states.pop(0)\\n  \\n          mines_count = sum([sum(row) for row in grid])\\n          if mines_count == M:\\n              return grid, location\\n  \\n          if mines_count < M:\\n              continue\\n  \\n          for new_location in valid(size, location, NEIGHBOURS):\\n              new_grid = click(size, grid, new_location)\\n              if new_grid:\\n                  states.insert(0, (new_grid, new_location))\\n  \\n      return None\\n  \\n  def validate(size, grid, location):\\n  \\n      result = [row[:] for row in grid]\\n  \\n      y, x = location\\n      result[y][x] = sum([\\n          grid[y1][x1]\\n          for y1, x1 in valid(size, (y, x), NEIGHBOURS)\\n      ])\\n      assert result[y][x] == 0\\n  \\n      seen = set([location])\\n      locations = set([location])\\n  \\n      while locations:\\n          location = locations.pop()\\n          for y, x in valid(size, location, NEIGHBOURS):\\n              assert grid[y][x] is not True\\n              result[y][x] = sum([\\n                  grid[y1][x1]\\n                  for y1, x1 in valid(size, (y, x), NEIGHBOURS)\\n              ])\\n              if result[y][x] == 0 and (y, x) not in seen:\\n                  locations.add((y, x))\\n                  seen.add((y, x))\\n  \\n      for row in result:\\n          for col in row:\\n              assert col is not False\\n  \\n      for y, row in enumerate(result):\\n          output = ''\\n          for x, col in enumerate(row):\\n              if col is True:\\n                  output += '*'\\n              else:\\n                  output += str(col)\\n          print output\\n  \\n  \\n  def process(case, R, C, M):\\n      result = sweep(R, C, M)\\n  \\n      print 'Case #%d:' % (case + 1)\\n      if not result:\\n          print 'Impossible'\\n          return\\n  \\n      grid, location = result\\n      for y, row in enumerate(grid):\\n          output = ''\\n          for x, col in enumerate(row):\\n              if (y, x) == location:\\n                  output += 'c'\\n              elif col:\\n                  output += '*'\\n              else:\\n                  output += '.'\\n          print output\\n  \\n  \\n  \\n  def main():\\n      cases = int(sys.stdin.readline())\\n  \\n      for case in range(cases):\\n          R, C, M = map(int, sys.stdin.readline().split())\\n          process(case, R, C, M)\\n  \\n      return\\n      for case in range(100):\\n          R = random.randrange(51) + 1\\n          C = random.randrange(51) + 1\\n          M = random.randrange(R * C - 1) + 1\\n          process(case * 100000 + M - 1, R, C, M)\\n  \\n  \\n  if __name__ == '__main__':\\n      main()\\n", "target": "11", "substitutes": {"NEIGHBOURS": ["NEIGHBHOURS", "NEIGHBHOUDS", "NEIGHNBOOLS", "NEIGHBOUNPS", "NEIGHEBOUTPS", "NEIGHBouTS", "NEIGHBOWRT", "NEIGHBouPS", "NEIGHBHOUPS", "NEIGHBHOULS", "NEIGHBOUTTS", "NEIGHEBours", "NEIGHBOURT", "NEIGHBOORS", "NEIGHBouRS", "NEIGHBOPLERT", "NEIGHBOUTPS", "NEIGHNBOUPS", "NEIGHBOUrs", "NEIGHBOUNDS", "NEIGHBOWRS", "NEIGHBOPLErs", "NEIGHEBOURS", "NEIGHNBOULS", "NEIGHBOUDS", "NEIGHBOUNLS", "NEIGHBOOrs", "NEIGHEBOURT", "NEIGHBOOPS", "NEIGHNBOORS", "NEIGHBours", "NEIGHBOUTRS", "NEIGHBOOTS", "NEIGHBOUTS", "NEIGHBOODS", "NEIGHBOWrs", "NEIGHNBOODS", "NEIGHEBouPS", "NEIGHEBOUTrs", "NEIGHEBOUTTS", "NEIGHBouRT", "NEIGHNBOURS", "NEIGHEBOUTRS", "NEIGHEBOUPS", "NEIGHBOPLERS", "NEIGHBOOLS", "NEIGHEBOUTS", "NEIGHBOUTrs", "NEIGHEBouRT", "NEIGHBOULS", "NEIGHBOUNRS", "NEIGHBOUPS", "NEIGHEBouRS", "NEIGHBOWPS", "NEIGHBOPLEPS", "NEIGHEBOUrs", "NEIGHNBOUDS", "NEIGHNBOOPS"], "MOVES": ["MOVED", " MOUSES", "MOVes", " MOVes", "MOUSes", "MATCHES", " MOVED", "MOVING", " MOUSes", "MARKED", " MOUSED", "MARKES", "MATCHING", "MOUSES", "MARKING", "MOUSED", "MARKes", "MOUSING", "MATCHes", " MOVING", "MATCHED", " MOUSING"], "size": ["name", "large", "address", "general", "ize", "security", "uri", "region", "position", "day", "c", "member", "site", "cm", "si", "speed", "capacity", "width", "sized", "count", "z", "action", "status", "ui", "engine", "scene", "edge", "sample", "remote", "storage", "empty", "time", "code", "area", "settings", "center", "export", "Size", "year", "form", "sum", "example", "loc", "m", "ci", "SIZE", "core", "grade", "function", "south", "square", "six", "model", "shape", "ng", "Y", "chain", "draw", "zone", "external", "activity", "content", "unit", "state", "string", "connection", "small", "source", "city", "sync", "style", "cache", "course", "mode", "scale"], "location": ["LOC", "section", "address", "auto", "uri", "region", "generation", "box", "position", "c", "member", "cell", "collection", "node", "site", "population", "gallery", "range", "event", "operation", "X", "length", "instance", "remote", "L", "l", "local", "storage", "area", "station", "module", "d", "i", "center", "slice", "feature", "layout", "command", "division", "direction", "response", "layer", "error", "density", "community", "loc", "m", "function", "south", "mode", "model", "new", "success", "shape", "directory", "moving", "Y", "draw", "Location", "ion", "origin", "activity", "content", "unit", "point", "definition", "image", "state", "filename", "home", "connection", "localhost", "place", "language", "network", "entry", "selection", "description", "null", "message", "move", "g", "folder", "lc"], "changes": ["settings", "results", "xs", "events", "images", "places", "rows", "works", "content", "features", "codes", "changed", "maps", "change", "errors", "values", "cells", "dates", "history", "status", "marks", "comments", "actions", "fields", "breaks", "grades", "files", "details", "Changes", "shape", "items", " moves", "moving", "lines", "boxes", "diff", "objects", "steps"], "y": ["story", "yang", "cy", "oy", "sim", "c", "gy", "yd", "ny", "my", "uy", "yy", "sy", "ye", "ch", "z", "yp", "w", "type", "n", "yi", "yo", "vy", "b", "f", "o", "game", "area", "hub", "e", "yr", "ys", "zy", "module", "d", "client", "id", "i", "p", "xy", "j", "year", "t", "yx", "v", "yl", "loc", "ory", "m", "ci", "key", "ey", "ry", "ya", "yn", "Y", "service", "ay", "ady", "h", "sky", "yt", "r", "ym", "hy", "q", "py", "dy", "height", "ix", "country"], "x": ["xs", "xt", "name", "px", "sex", "xp", "im", "exp", "position", "cy", "index", "ice", "xc", "wx", "c", "xe", "xx", "ax", "my", "event", "pos", "act", "X", "width", "z", "dx", "w", "n", "l", "wa", "create", "time", "f", "e", "xa", "id", "i", "p", "xy", "j", "xml", "rx", "cross", "t", "yx", "host", "v", "na", "yl", "example", "loc", "m", "key", "ya", "ng", "Y", "xi", "ay", "content", "ady", "h", "xf", "view", "column", "u", "image", "ct", "r", "change", "xb", "q", "cl", "ex", "xxx", "work", "int", "ix"], "y1": [" y0", "yOne", "yed", "y4", "vy2", "Y0", "xed", "ya2", "Y4", "ry2", " y3", "x81", "Yed", "ry3", "Y2", " y4", "ya81", "y3", "y2", " y81", " yOne", "ey81", " yed", "x0", "vy1", "ya0", "ry4", "y01", "ey01", " y01", "ya01", "ya1", "x2", "ey1", "Y3", "yaOne", "ry1", "vyOne", "xOne", "y0", "Y1", " y2", "vy81", "y81"], "x1": ["xt0", " x10", "yone", " xOne", "z2", " xone", "X1", "z10", "x81", "xx3", "z1", "xt1", "X3", "xt2", "x3", "y3", "y2", " yOne", "z81", "x10", "X\n", " x2", "z0", "x0", "xone", " x0", "x2", " x81", "xiOne", "xOne", "xtone", "xi1", " y2", "y0", "zone", "y81", "y10", "xi2", "xx1"], "grid": ["address", "gate", "general", "security", "uri", "div", "scope", "query", "sim", "graph", "back", "details", "parent", "cell", "house", "node", "site", "db", "debug", "cm", "gallery", "page", "range", "rule", "ace", "status", "gap", "route", "feed", "edge", "Grid", "remote", "valid", "storage", "plugin", "all", "dim", "window", "code", "tile", "game", "server", "hold", "station", "update", "module", "client", "default", "num", "cart", "gui", "layout", "gr", "export", "input", "config", "multi", "file", "static", "form", "cells", "sum", "layer", "cum", "grade", "function", "square", "data", "block", "model", "new", " Grid", "frame", "chain", "draw", "lock", "bug", " grids", "activity", "cube", "content", "unit", "point", "cfg", "column", "image", "flow", "ed", "state", "group", "domain", "connection", "age", "mid", "network", "link", "sync", "cache", "gru", "message", "line", "move", "main", "active", "contact", "g", "scale"], "row": ["page", "range", "up", "container", "module", "client", "rows", "device", "item", "view", "month", "way", "Row", "column", "flow", "image", "r", "year", "ward", "status", "arrow", "form", "roll", "co", "state", "group", "field", "error", "box", "record", "feed", "oy", "query", "day", "entry", "zero", "link", "element", "order", "port", "week", "ro", "block", "model", "round", "area", "scale", "key", "cell", "frame", "node", "line", "build", "post", "user", "server", "wheel", "bug"], "R": ["N", "Rh", "TR", "U", "RH", "X", "RE", "O", "RR", "MR", "r", "Rs", "K", "RW", "RO", "SR", "L", "D", "A", "ER", "JR", "T", "B", "RS", "S", "CR", "E", "H", "F", "DR", "V", "RM", "GR", "Y", "NR", "Q", "P", "RA", "Cr", "RG"], "C": ["N", "U", "G", "X", "Cu", "O", "CL", "Size", "I", "W", "CM", "K", "Z", "CE", "EC", "DC", "CP", "CC", "L", "D", "A", "CN", "T", "B", "S", "c", "CR", "E", "H", "AC", "CS", "F", "CI", "V", "CU", "Y", "Q", "P"], "M": ["N", "U", "G", "X", "J", "O", "I", "r", "W", "MS", "NM", "CM", "K", "SM", "MT", "m", "MN", "L", "D", "A", "MC", "T", "B", "S", "E", "H", "F", "V", "RM", "Y", "Q", "P", "LM"], "_": ["X", "ac", "p", "oc", "j", "q", "cc", "new", "Y", "ck", "f"], "states": ["rules", "settings", "results", "relations", "jobs", "events", "gs", "args", "images", "ids", "rows", "works", "stats", "points", "services", "stores", "sections", "features", "uses", "status", "errors", "plays", "cells", "state", "ages", "actions", "plugins", "ins", "powers", "south", "keys", "rates", "locks", "groups", "storage", "models", "charges", "files", "strings", "details", "s", "blocks", "parts", "flows", "items", "reports", "active", "States", "modules", "lines", "sites", "ports", "chains", "runs", "steps"], "mines_count": ["minES_sum", "mines_sum", "mines_dist", "minises_Count", "minises_count", "minesh_count", "minesh_dist", "minises_len", "minES_count", "mines_code", "mines_len", "mines_child", "mines_Count", "minES_code", "minesh_child"], "new_location": ["New_location", " new_address", "New_position", "new_region", "New_region", " new_loc", "new67location", "new_module", "newJloc", "new67loc", "New_loc", "new_loc", "new67address", " new_site", "new_position", "newJaddress", " new_module", "newJmodule", "newJlocation", "new_address", " new_position", "new_site", "new67module"], "new_grid": ["new_state", "New_state", "newnetgrid", " new_volume", "newjstate", "new_volume", "newjmodule", "new_media", "newsvolume", "newnetstate", " new_state", "new_module", "New_media", "New_grid", "new_storage", "newjgrid", " new_storage", "newjlocation", "newsgrid", "newnetstorage", " new_module", "new_row", "New_row", "newsstorage", "newsstate", "newnetvolume"], "result": ["page", "range", "results", "default", "content", " Result", "final", "done", "product", "match", "complete", "now", "master", "r", "response", "status", "report", "res", "root", "sum", "group", "source", "function", "data", "progress", "new", "Result", "success", "test", "dist", "found", "err", "diff", "search", "table"]}}
{"code": "'''\\n  Created on Apr 11, 2014\\n  \\n  @author: mostasem\\n  '''\\n  \\n  \\n  def getSeconds(C,F,X):\\n      seconds = 0.0\\n      cookie_rate = 2\\n      solved =False\\n      while (not solved):\\n          choice1 = X/cookie_rate\\n          choice2 = C/cookie_rate + X/(cookie_rate + F)\\n          if(choice1 < choice2):\\n              seconds += choice1\\n              solved = True\\n          else :\\n              seconds += C/cookie_rate\\n              cookie_rate += F\\n      \\n      return seconds\\n  \\n  f_r = open('B.in',\"r\")\\n  n_test=int(f_r.readline().strip()) \\n  f_w = open(\"B.out\", \"w\")\\n  result = \"\"\\n  for i in range(n_test):\\n      C,F,X = map(float,f_r.readline().split())\\n      seconds = getSeconds(C,F,X)\\n      result = str(seconds)\\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\\n      f_w.write(output_str+'\\n')\\n      \\n  f_r.close()\\n  f_w.close()\\n  \\n", "target": "12", "substitutes": {"C": ["N", "CF", "Cs", "U", "G", "Ch", "Cu", "O", "COR", "CL", "CNN", "I", "CA", "W", "M", "CM", "K", "CE", "EC", "DC", "CP", "Cache", "CC", "L", "D", "A", "R", "MC", "T", "CN", "B", "S", "CO", "c", "CV", "CR", "E", "H", "CS", "CI", "V", "CU", "Y", "Q", "P", "Code", "CT", "Col"], "F": ["N", "CF", "U", "G", "Fs", "FD", "DF", "FI", "I", "If", "IF", "FB", "W", "FL", "File", "M", "Z", "FIN", "Fi", "FS", "L", "Family", "D", "FO", "A", "R", "T", "PF", "B", "FH", "GF", "FA", "FC", "S", "FR", "Fine", "FE", "E", "SF", "H", "Feed", "V", "FF", "Y", "Q", "P", "Far", "f", "MF", "FM", "FW", "Fe"], "X": ["N", "CF", "U", "CH", "XL", "G", "XP", "IX", "Event", "XXX", "CL", "CNN", "I", "TX", "W", "IP", "M", "Z", "EC", "CE", "K", "DC", "MX", "XM", "CC", "L", "EX", "D", "FO", "R", "HTTP", "T", "FX", "FM", "B", "Ex", "WH", "S", "FC", "Work", "FE", "CR", "E", "H", "UX", "x", "V", "FF", "XY", "Y", "Check", "Q", "P", "XX", "PE", "Cross", "FW"], "seconds": ["letters", "events", "jobs", "duration", "months", "outs", "future", "errors", "values", "fps", "fixes", "charges", "times", "frames", "c", "details", "sec", "states", "fe", "runs", "ractions", "services", "codes", "ses", "SEC", "forces", "videos", "s", "reports", "sites", "steps", "settings", "hours", "series", "sections", "comments", "function", "days", "six", "terms", "eps", "files", "strings", "utils", "limits", "second", "lines", "later", "bytes", "ones", "objects", "results", "Second", "fires", "sets", "sf", "years", "ss", "flows", "tests", "fee", " Seconds"], "cookie_rate": ["cookie\u00b7number", "cookie_rating", "cookieacscale", "cookie_scale", "cookie\u00b7rate", "cookiefrate", "cookie_rule", " cookie_rating", "cookie\u00b7rates", "cookiefrule", "cookie_time", "cookie_cycle", " cookie_rates", "server_rate", "cookieacrating", "cookie_number", "cookieacrule", " cookie_cycle", "cook_time", " cookie_rule", "cookie_speed", " cookie_speed", "cookieacrate", "cookie\u00b7date", " cookie_scale", "cookie_date", " cookie_time", "server_rates", "cookie_rates", "cook_rates", "cookiefrating", "cookiefscale", "cook_rate", "server_date", "server_number", "cook_rating"], "solved": ["solver", "ssolve", "Solving", "unsolving", "solving", "ssolved", "Solved", "ssolves", "Solves", "solves", " solve", "unsolved", "solve", "ssolution", " solver", "solution", " solving", "Solve", "ssolver", "unsolution", "unsolve", "Solver", "Solution", "ssolving"], "choice1": ["choice0", " choice4", "choiceOne", "ChoiceOne", "caseOne", "option4", "choiceed", "select4", "Choice2", "select0", "change1", "Choice1", "option0", "case1", "case0", "select1", "Choice0", "case3", "Choice3", "changeOne", "choice3", "change3", "case2", "option1", "change2", "Choiceed", "caseed", " choiceed", "choice4", " choice0"], "choice2": [" Choice1", " choice4", " ChoiceTwo", "ChoiceTwo", "Choice2", "Choice1", "case1", "Choice4", " Choice2", "case2", " Choice4", "case4", " choiceTwo", "choice4", "choiceTwo"], "f_r": ["f_l", "f2r", "flexsr", "io_w", "flexc", "sf2h", "f2reader", "sf_reader", "flexw", "f_rb", "io_r", "f67rb", " f_sr", "fipw", "sf2w", "f_rt", "sf_r", "f2w", "f_c", "f2h", "f_h", "flexr", "sf2reader", "f2c", "f67err", "f67r", "flexrs", "fipr", "f_err", "sf_h", "io_c", "f_rs", " f_rs", "io_rt", " f_l", "f67l", "fiprs", "fipsr", " f_err", " f_rb", "flexrt", "sf2r", "sf_w", "f_reader", "f_sr", "f2rt"], "n_test": ["nxtests", "n_tests", "n_Test", "p_testing", "nxtest", " n_trial", "nxtesting", "n_train", "nxtrain", "p_test", "nxTest", " n_testing", "n_testing", " n_train", "n_trial", "nxtrial", "p_tests", "p_Test"], "f_w": ["w_wa", "f__writer", " f__wb", "firmw", "f__wb", "f2r", " f_z", "f_we", " f2z", " f__writer", "f__h", " f2w", "ffz", "f_wb", "f2w", "ffww", "w_r", "firmww", "f_z", " f2ww", "fxwa", " f__h", "ffw", "f__w", " f_ww", "fxwe", "f_h", " f_h", " f_wb", "w_we", "fxr", "fxw", "w_w", "firmz", "f2z", " f__w", "f_ww", "f2ww", "f_wa", "firmr", " f2r", "f_writer", "ffr", " f_writer"], "result": ["resp", "range", "results", "our", "compl", "default", "score", "final", "json", "str", "out", "ret", "desc", "case", "ver", "r", "response", "output", "status", "report", "comment", "res", "summary", "part", "date", "string", "example", "dict", "rate", "value", "data", "text", "runner", "description", "Result", "success", "test", "RES", "message", "second", "term", "format", "err", "Results", "diff", "answer", "reason"], "i": ["e", "gi", "si", "ini", "xi", "counter", "ip", "d", "id", "num", "slice", "p", "j", "I", "start", "u", "zi", "r", "multi", "li", "pi", "ui", "cli", "uri", "iter", "ci", "index", "ii", "ei", "ti", "di", "c", "int", "phi", "x", "ix", "y", "iu", "ind", "f", "trial", "chi"], "output_str": ["flat_str", "outputJbr", "output24string", "outputJstri", "output24pr", "output_pr", " output_pr", "flat_br", "outputJstr", "output24arr", "flat_stri", "output_string", "output24str", "output_char", "output_br", " output_string", "outputJchar", "output_stri", "flat_char", "output_arr", " output_arr"]}}
{"code": "'''\\n  Created on Apr 12, 2014\\n  \\n  @author: mostasem\\n  '''\\n  \\n  def getFloorRoots(m):\\n      r1 = -1 + math.sqrt(1 + (8 * m))/2\\n      r2 = -1 - math.sqrt(1 + (8 * m))/2\\n      return int(math.floor(r1))\\n      \\n  def boardHasZero(R,C,M):\\n      if(R > 1 and C > 1):\\n          S = M/C\\n          Sr = M % C\\n          print S,Sr\\n          return R >= S+3 or (R == S+2 and ((Sr % 2) == 0 or (((C + Sr) % 3 == 0) and (2*C >= (C + Sr + 4))))) or (R == S+1  and (C + Sr) % 2 == 0 and (2*C >= (C + Sr + 4)))  #M <= ((R*C) - 4)\\n      else :\\n          return M <= ((R*C) - 2)\\n  \\n  \\n  def generateMineSweeperCase(R,C,M):\\n  \\n      board = \"\"\\n  \\n      if( R > 1 and C > 1 ): # generate special\\n          S = M/C\\n          Sr = M % C\\n          print S,Sr\\n          if(S): # all rows of *\\n              board +=\"\\n\"\\n              if(R >= S+3 or (R == S+2 and Sr % 2 == 0)):\\n                  board += (S - 1) * ((C*\"*\") + \"\\n\")\\n              else:\\n                  board += (S - 2) * ((C*\"*\") + \"\\n\")\\n              board +=  ((C*\"*\"))\\n              \\n          if(R >= S+3):\\n              if(Sr):\\n                  board +=\"\\n\"\\n                  board += ((Sr *\"*\") + ((C - Sr) *\".\"))\\n              Rm = R - (S + 1)\\n              if(Rm):\\n                  board +=\"\\n\"\\n                  board += (Rm - 1) * ((C*\".\") + \"\\n\")\\n                  board +=  ((C*\".\"))\\n                  \\n          elif(R == S + 2):\\n              Sm = 0\\n              if(Sr % 2 == 0):\\n                  board +=\"\\n\"\\n                  board += (((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\") +\"\\n\")\\n                  board += ((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\")\\n              else:\\n                  board +=\"\\n\"\\n                  board += (((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\") +\"\\n\")\\n                  board += ((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\")\\n          else :\\n              Sm = Sr + C\\n              board +=\"\\n\"\\n              board += (((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\") +\"\\n\")\\n              board += ((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\")\\n                  \\n          list_board = list(board)\\n          list_board[len(list_board) - 1] = 'c'\\n          board = \"\".join(list_board)\\n      else:\\n          board +=\"\\n\"\\n          if(C == 1):\\n              board += M * \"*\\n\"\\n              board += (R-M-1) * \".\\n\"\\n              board +=  \"c\"\\n          else:\\n              board += M * \"*\"\\n              board += (C-M-1) * \".\"\\n              board += \"c\"\\n              \\n      return board\\n         \\n         \\n         \\n  \\n  f_r = open('C.in',\"r\")\\n  n_test=int(f_r.readline().strip()) \\n  f_w = open(\"C.out\", \"w\")\\n  result = \"\"\\n  for i in range(n_test):\\n      R,C,M = map(int,f_r.readline().split())\\n      print R,C,M\\n      if(boardHasZero(R,C,M)):\\n          result = generateMineSweeperCase(R,C,M)\\n      else :\\n          result =\"\\nImpossible\"\\n      print result\\n      output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)\\n      f_w.write(output_str+'\\n')\\n      \\n  f_r.close()\\n", "target": "12", "substitutes": {"m": ["e", "ms", "d", "mi", "km", "i", "dm", "h", "wm", "p", "j", "rm", "mu", "mr", "im", "mm", "r", "bm", "fm", "v", "w", "hm", "n", "tm", "l", "c", "s", "a", "dim", "x", "y", "b", "f", "o", "g", "gm", "mn"], "r1": ["R1", " r3", "sr3", "R8", "r0", " r8", " r0", "p0", "R0", "R2", "sr1", "R3", "r8", "p2", "r3", "p8", "sr0", "p1", "sr2"], "r2": ["R1", "R2", " r4", " R4", " R2", " R1", "R0", " R0", "R4", "r0", " r0", "r4"], "R": ["N", "AR", "U", "RH", "G", "X", "RE", "O", "RR", "I", "r", "W", "Rs", "K", "RW", "SR", "RO", "RN", "Right", "Re", "L", "Res", "D", "A", "ER", "JR", "T", "B", "RS", "BR", "RP", "E", "H", "F", "IR", "V", "DR", "RM", "GR", "WR", "Y", "Ra", "Q", "P", " r", "RA"], "C": ["N", "CF", "Cs", "Count", "U", "JC", "G", "Ch", "X", "Co", "Cu", "Cow", "O", "I", "CL", "Size", "CNN", "CA", "W", "YC", "NC", "CM", "K", "CE", "EC", "VC", "DC", "Cache", "Custom", "CW", "Ca", "CC", "L", "Sc", "D", "A", "CN", "T", "MC", "B", " c", "CO", "c", "CV", "CR", "E", "H", "F", "CI", "V", "CU", "Y", "Q", "P", "Mc", "Code"], "M": ["N", "U", "G", "X", "J", "O", "I", "W", "Z", "CM", "K", "SM", "L", "D", "A", "MC", "T", "B", "MA", "c", "E", "H", "MF", "F", "V", "RM", "Y", "Q", "P", "MM", "LM"], "S": ["N", "Ps", "U", "Sl", "G", "X", "SC", "AS", "SL", "O", "SI", "TS", "r", "W", "Rs", "MS", "K", "SE", "L", "Sc", "Sa", "D", "A", "System", "T", "SH", "B", "RS", "Sec", "Sh", "s", "Si", "E", "H", "CS", "Ns", "F", "SS", "V", "SU", "Y", "NS", "SA", "Q", "P"], "Sr": ["Asrr", " SSsr", "ScR", "Asr", "Psri", "Nyr", "Src", "Usr", "Spr", "Dsra", " SSkr", "Despr", "SSra", "Snr", "Scrs", "Nnr", "Statesrr", "Desr", "Psrs", "Usra", "Srs", "Desir", "Syr", "skr", "SSnr", "Dsrc", " Sir", "CSr", "CSsr", "sR", " SSr", "Sir", "sr", " SSR", "SSsr", "CSnr", "Srr", " Sra", "ssr", " Skr", "Statessr", "SSr", "Dsri", "CSyr", "Psr", " Ssr", "Statesr", "Scr", " Src", "PSri", "Sri", "SR", "Dsr", "Sra", "Pssr", "Nsr", "Assr", "Dsrs", "PSrc", "Statespr", "PSr", "DsR", "Psrr", "UsR", "src", "Aspr", "Skr", "Psrc", "Pspr", "Usrs", "Ssr", "Nrc", "SSpr", " SR", "SSir", "SSyr", "Desra", "NR", " Spr", "Scra", "PSrs", "Nr"]}}
{"code": "\\n  def read_str(): return stdin.readline().rstrip('\\n')\\n  def read_int(): return int(stdin.readline())\\n  def read_ints(): return map(int, stdin.readline().split())\\n  def read_floats(): return map(float, stdin.readline().split())\\n  \\n  \\n  def solve_case():\\n      C, F, X = read_floats()\\n      rate = 2\\n      current = 0\\n      best = X / rate\\n      \\n      while True:\\n          current += C / rate\\n          rate += F\\n          next = current + X / rate\\n          if next < best:\\n              best = next\\n          else:\\n              break\\n      \\n      return best\\n  \\n      \\n  def main():\\n      cases = read_int()\\n      for case in range(1, cases + 1):\\n          print('Case #{}: {:.7f}'.format(case, solve_case()))\\n  \\n          \\n  main()\\n", "target": "13", "substitutes": {"C": ["N", "CF", "U", "G", "Cu", "O", "I", "CL", "W", "M", "NC", "CE", "K", "CM", "DC", "CC", "L", "D", "A", "Case", "R", "MC", "T", "B", "S", "CO", "c", "CV", "CR", "E", "CU", "Y", "Q", "P"], "F": ["N", "CF", "U", "G", "FD", "O", "FT", "I", "IF", "W", "M", "Z", "K", "L", "D", "A", "R", "T", "PF", "B", "GF", "S", "FA", "FC", "FR", "FE", "CR", "E", "H", "V", "Y", "Q", "P", "f"], "X": ["N", "U", "CH", "XL", "G", "XP", "ZX", "XXX", "I", "CL", "TX", "IF", "W", "M", "NC", "Z", "CE", "K", "ICE", "DC", "CC", "L", "D", "R", "T", "FX", "B", "S", "FC", "FE", "CR", "E", "H", "UX", "x", "V", "DX", "FF", "Current", "XY", "Y", "Q", "P", "XX", "PE"], "rate": ["rating", " rates", "size", "update", "ave", "speed", "counter", "rand", "weight", "rule", "score", " Rate", "correct", "rated", "unit", "length", "complete", "ride", "max", "Rate", "count", "acc", "r", "change", "level", "exp", "give", "root", "currency", "date", "race", "prime", "pair", "feed", " score", "sample", "core", "rank", "age", "grade", "seed", "recent", "value", "data", "rates", "erate", "base", "progress", "stage", "use", "time", "test", "depth", " speed", "cycle", "delay", "est", "fee", "code", "cost", "frequency", "cr", "ate", "mode", "scale"], "current": ["update", "counter", "default", "correct", "length", "complete", "now", "future", "sequence", "count", "master", "reported", "change", "critical", "first", "race", "example", "cur", "past", "recent", "data", "currently", "c", "progress", "temp", "time", "parent", "test", "depth", "result", "Current", "choice", "active", "second", "today", "code"], "best": ["perfect", "rand", "default", " worst", "good", "highest", "score", "final", "max", "ale", "none", "instance", "master", "largest", "it", " Best", "first", "top", "Success", "fork", "rank", " newest", "recent", "fast", "right", "value", "leader", "average", "last", "winner", "better", "new", "Best", "progress", "all", "back", "end", "success", "test", " highest", "null", "result", "mate", "this", "fe", "est", "worst", "latest", " winner", "cost", "most", "bottom"], "next": ["gen", "loop", "rand", "default", " first", "correct", "step", "final", " Next", " last", "max", "now", "future", "start", "Next", "sequence", "r", "change", "pred", "first", "error", "prev", "again", "past", "recent", "close", "last", "better", "new", "progress", "c", "end", "parent", "success", "cycle", "open", "this", "line", "est", "second", "code", "latest", "worst", "cost", "later"], "cases": ["classes", "settings", "events", "loop", "places", "rows", "changes", "capacity", "points", "cas", "sections", "features", "instance", "errors", "values", "cells", " folds", "its", "cs", "tips", "ls", "Case", "days", "groups", "times", "files", "details", "test", "cycles", "tests", "children", "ends", "lines", "ases", "chains", "runs", "steps"], "case": ["e", "size", "charge", "loop", "name", "default", "id", "num", "i", "p", "address", "match", "ace", "instance", "count", "ase", "change", " i", "race", "rice", "example", "uc", "Case", "ice", "c", "use", "end", "int", "test", "set", "chance", "x", "result", "line", "catch", "character", "cycle", "CI", "code", "f"]}}
{"code": "\\n  \\n  def read_str(): return stdin.readline().rstrip('\\n')\\n  def read_int(): return int(stdin.readline())\\n  def read_ints(): return map(int, stdin.readline().split())\\n  def read_floats(): return map(float, stdin.readline().split())\\n  \\n  \\n  def atos(A):\\n      return '\\n'.join([''.join(row) for row in A])\\n      \\n  \\n  def get_field(r, c):\\n      field = [['.'] * c for i in range(r)]\\n      field[0][0] = 'c'\\n      return field\\n      \\n      \\n  def is_forbidden(i, j):\\n      return i == 0 and j == 0 or i == 0 and j == 1 or \\\\n          i == 1 and j == 0 or i == 1 and j == 1\\n      \\n      \\n  def fill(field, r, c, m):\\n      left = m\\n      for ii in range(r - 1, -1, -1):\\n          i = ii\\n          j = c - 1\\n          while i < r and j >= 0:\\n              if is_forbidden(i, j):\\n                  i += 1\\n                  j -= 1\\n                  continue\\n              if left == 0:\\n                  return 0\\n              field[i][j] = '*'\\n              left -= 1\\n              \\n              i += 1\\n              j -= 1\\n              \\n          if ii == 0:\\n              for jj in range(c - 2, 1, -1):\\n                  i = ii\\n                  j = jj\\n                  while i < r and j >= 0:\\n                      if is_forbidden(i, j):\\n                          i += 1\\n                          j -= 1\\n                          continue\\n                      if left == 0:\\n                          return 0\\n                      field[i][j] = '*'\\n                      left -= 1\\n                      \\n                      i += 1\\n                      j -= 1\\n              \\n      if r * c == m + 1:\\n          if r > 1:\\n              field[1][0] = '*'\\n          if c > 1:\\n              field[0][1] = '*'\\n          if r > 1 and c > 1:\\n              field[1][1] = '*'\\n          return 0\\n              \\n      return left\\n  \\n      \\n  def solve_case():\\n      r, c, m = read_ints()\\n      \\n      field = get_field(r, c)\\n          \\n      left = fill(field, r, c, m)\\n          \\n      return 'Impossible' if left != 0 else atos(field)\\n      \\n      \\n  def main():\\n      cases = read_int()\\n      for case in range(1, cases + 1):\\n          print('Case #{}:\\n{}'.format(case, solve_case()))\\n  \\n          \\n  main()\\n", "target": "13", "substitutes": {"A": ["N", "AN", "AA", "AR", "G", "ac", "C", "AB", "I", "CA", "W", "an", "M", "Z", "K", "ram", "NA", "n", "analysis", "L", "D", "alpha", "R", "T", "B", "grid", "As", "S", "LA", "mA", "H", "a", "AC", "F", "Ar", "Y", "This", "P", "array", "area", "AD"], "row": ["col", "rew", "rows", "xxxxxxxx", "rc", "Row", "input", "column", "instance", "mm", "arr", "uu", "object", "rw", "ud", " Row", "obj", "record", "feed", "ow", "entry", "rown", "raw", "ro", "block", "model", "round", "cell", "df", "reader", "gram", "node", "result", "line", "x", "insert", "array", "f", "board", " rows"], "r": ["e", "range", "yr", "rr", "br", "rb", "d", "tr", "fr", "rc", "h", "str", "pr", "p", "ur", "gr", "ar", "rm", "mr", "dr", "u", "er", "z", "arr", "t", "v", "lr", "rec", "ir", "re", "w", "q", "adr", "n", "hr", "l", "R", "ru", "right", "g", "rh", "a", "rs", "x", "sr", "nr", "y", "b", "err", "f", "rg", "cr"], "c": ["e", "cf", "mc", "d", "col", "rc", "h", "ac", "C", "dc", "p", "ch", "ce", "u", "z", "t", "co", "v", "cu", "cs", "w", "cy", "q", "uc", "n", "ci", "l", "right", "ca", "cc", "s", "end", "a", "k", "ec", "x", "nc", "y", "cm", "b", "f", "arc", "cp", "cr", "con", "o", "cn", "lc"], "field": ["section", "manager", "man", "number", "object", "day", "fields", "machine", "fill", "ff", "end", "cell", "cover", "err", "option", "table", "page", "rule", "player", "word", "patch", "er", "li", "condition", "root", "record", "type", "element", "all", "label", "time", "fix", "x", "f", "post", "user", "e", "module", "d", "default", "play", "true", "slice", "p", "document", "match", "input", "inner", "file", "form", "v", "comment", "layer", "FIELD", "function", "data", "block", "model", "key", "result", "term", "load", "diff", "lock", "Field", "list", "child", "column", "force", "change", "ed", "group", "part", "string", "source", "q", "value", "round", "sort", "int", "null", "message", "line", "g"], "i": ["e", "ki", "gi", "si", "ini", "xi", "ip", "d", "ori", "mi", "anti", "id", "mini", "p", "api", "fi", "I", "vi", "u", "iv", "zi", "ie", "z", "li", "it", "ai", "pi", "v", "ui", "ni", "io", "uri", "ir", "multi", "n", "ci", "l", "ik", "ij", "ib", "ti", "bi", "di", "yi", "s", "int", "a", "ji", "ic", "phi", "x", "ix", "y", "ri", "iu", "b", "ind", "f", "oi", "o", "ia", "info", "eni", "qi"], "j": ["e", "page", "si", "br", "d", "name", "ne", "uj", "h", "J", "p", "ch", "jet", "ah", "u", "z", "ie", "li", "jl", "jen", "pt", "v", "on", "t", "it", "part", "note", "obj", "q", "n", "ci", "l", "adj", "jp", "ij", "ot", "dj", "jon", "el", "all", "je", "bj", "ja", "key", "jc", "a", "ji", "k", "x", "line", "ix", "off", "y", "aj", "jo", "js", "b", "f", "o", "g", "oj"], "m": ["e", "range", "ms", "mc", "d", "mi", "middle", "h", "p", "man", "mr", "mu", "u", "im", "mm", "z", "t", "M", "v", "ym", "um", "re", "w", "q", "n", "tm", "l", "machine", "a", "x", "y", "b", "cm", "f", "o", "g"], "left": ["shell", "col", "offset", "pl", "lt", "obj", "fields", "end", "member", "cell", "fe", "err", "url", "rule", "shift", "plus", "length", "none", "z", "li", "ell", "n", "L", "l", "only", "all", "empty", "label", "x", "ul", "false", "found", "code", "le", "ignore", "o", "copy", "low", "full", "e", "default", "self", "id", "center", "p", "inner", "error", "leave", "partial", "hide", "function", "min", "cost", "diff", "skip", "size", "Left", "len", " Left", "joined", "lo", "child", "after", "wrong", "small", "Right", "used", "cl", "missing", "fl", "right", "last", "null", "line", "ix", "two", "cel", "no", "lc"], "ii": ["cf", "gi", "ini", "size", "si", "d", "iq", "col", "yy", "id", "middle", "mini", "url", "center", "h", "qa", "circle", "p", "fi", "inner", "vi", "iii", "iv", "after", "z", "ie", "li", "ai", "sci", "ni", "ili", "n", "ci", "illi", "l", "say", "ice", "ig", "fl", "ei", "inf", "di", "img", "ani", "end", "init", "sil", "ji", "cycle", "ix", "y", "ri", "cm", "ind", "b", "f", "iw", "II", "err", "ignore", "bug", "eni", "qi", "ort"], "jj": ["JC", "d", "bb", "JJ", "uj", "h", "J", "p", "man", "mm", "jl", "qq", "rec", "q", "n", "tm", "dj", "jp", "ij", "right", "cc", "ja", "jc", "gn", "ji", "x", "ix", "aj", "y", "jo", "cm", "b", "cp", "g", "gm"], "cases": ["rules", "size", "counter", "rule", "shift", "rows", "section", "inner", "sections", "child", "instance", "count", "values", "cells", "mat", "stack", "Case", "fields", "times", "test", "tests", "children", "ends", "lines", "path", "trial", "options"], "case": ["pos", "_", "index", "right", "all", "end"]}}
{"code": "\\n  FILE_NAME_BASE = 'B-small-attempt0'\\n  NUM_PROCESSES = 0\\n  MEM_LIMIT_GB = 1.5 # per worker process\\n  RECURSION_LIMIT = 1000\\n  \\n  def parse(inp):\\n  \tcost, prod, goal = (float(x) for x in inp.readline().split())\\n  \treturn cost, prod, goal\\n  \\n  def solve(cost, prod, goal):\\n  \trate = 2\\n  \tnow = 0\\n  \twhile True:\\n  \t\tnobuyEnd = goal / rate\\n  \t\tbuyEnd = cost / rate + goal / (rate + prod)\\n  \t\tif buyEnd < nobuyEnd:\\n  \t\t\tnow += cost / rate\\n  \t\t\trate += prod\\n  \t\telse:\\n  \t\t\treturn '%0.7f' % (now + nobuyEnd)\\n  \\n  def main():\\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\\n  \\n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\\n  \\n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\\n  \tnumCases = int(inp.readline())\\n  \tif NUM_PROCESSES == 0:\\n  \t\tresults = [\\n  \t\t\tsolve(*parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \telse:\\n  \t\tpool = Pool(NUM_PROCESSES)\\n  \t\tresults = [\\n  \t\t\tpool.apply_async(solve, parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \tinp.close()\\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\\n  \tfor case, result in enumerate(results):\\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\\n  \t\tout.write('Case #%d: %s\\n' % (case + 1, value))\\n  \t\tout.flush()\\n  \tout.close()\\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "target": "14", "substitutes": {"FILE_NAME_BASE": ["FILE_NAME_BEBase", "FILE_NAME_BBase", "FILE_NAME_HSE", "FILE_NAME_HBase", "FILE_NAME_BEASE", "FILE_NAME_BSE", "FILE_NAME_BESE", "FILE_NAME_HASE"], "NUM_PROCESSES": ["NUM_PRECESSURES", "NUM_PROCNECTes", "NUM_PROCcessES", "NUM_PRECESSes", "NUM_PROCESSions", "NUM_PROCProcessES", "NUM_PROCESSURES", "NUM_PRECProcessions", "NUM_PRECProcessES", "NUM_PROCProcessURES", "NUM_PROCNECTES", "NUM_PROCcesses", "NUM_PRECESSions", "NUM_PRECProcesses", "NUM_PROCProcessions", "NUM_PROCNECTURES", "NUM_PROCNECTions", "NUM_PRECESSES", "NUM_PROCProcesses", "NUM_PROCESSes", "NUM_PROCcessions", "NUM_PROCcessURES", "NUM_PRECProcessURES"], "MEM_LIMIT_GB": ["MEM_LIMITEDGB", "MEM_LIMIT_GW", "MEM_LIMIT__GB", "MEM_LIMITED_GW", "MEM_LIMITED_GB", "MEM_LIMITED_MB", "MEM_LIMIT_MB", "MEM_LIMITEDRAM", "MEM_LIMITEDGW", "MEM_LIMIT__GW", "MEM_LIMITED_RAM", "MEM_LIMITEDMB", "MEM_LIMIT_RAM", "MEM_LIMIT__RAM", "MEM_LIMIT__MB"]}}
{"code": "\\n  FILE_NAME_BASE = 'C-small-attempt0'\\n  NUM_PROCESSES = 0\\n  MEM_LIMIT_GB = 1.5 # per worker process\\n  RECURSION_LIMIT = 1000\\n  \\n  def parse(inp):\\n  \trows, cols, mines = (int(x) for x in inp.readline().split())\\n  \treturn rows, cols, mines\\n  \\n  def search(rows, cols, mines):\\n  \\n  \tassert 0 <= mines < rows * cols\\n  \tif mines == 0:\\n  \t\treturn ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)\\n  \tif mines == rows * cols - 1:\\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\\n  \\n  \tif rows == 1:\\n  \t\treturn ['c' + '.' * (cols - 1 - mines) + '*' * mines]\\n  \tif cols == 1:\\n  \t\treturn ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines\\n  \\n  \tif mines > rows * cols - 4:\\n  \t\treturn None\\n  \\n  \\n  \treturn None\\n  \\n  class SearchBoard(object):\\n  \\n  \tdef __init__(self, rows, cols):\\n  \t\tself.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]\\n  \t\tself.mineCount = 0\\n  \\n  \tdef addMine(self, row, col):\\n  \t\tcounts = self.counts\\n  \t\tassert counts[row + 1][col + 1] < 10\\n  \t\ttop = counts[row + 0]\\n  \t\ttop[col + 0] += 1\\n  \t\ttop[col + 1] += 1\\n  \t\ttop[col + 2] += 1\\n  \t\tmid = counts[row + 1]\\n  \t\tmid[col + 0] += 1\\n  \t\tmid[col + 1] += 10\\n  \t\tmid[col + 2] += 1\\n  \t\tbot = counts[row + 2]\\n  \t\tbot[col + 0] += 1\\n  \t\tbot[col + 1] += 1\\n  \t\tbot[col + 2] += 1\\n  \t\tself.mineCount += 1\\n  \\n  \tdef removeMine(self, row, col):\\n  \t\tcounts = self.counts\\n  \t\tassert counts[row + 1][col + 1] >= 10\\n  \t\ttop = counts[row + 0]\\n  \t\ttop[col + 0] -= 1\\n  \t\ttop[col + 1] -= 1\\n  \t\ttop[col + 2] -= 1\\n  \t\tmid = counts[row + 1]\\n  \t\tmid[col + 0] -= 1\\n  \t\tmid[col + 1] -= 10\\n  \t\tmid[col + 2] -= 1\\n  \t\tbot = counts[row + 2]\\n  \t\tbot[col + 0] -= 1\\n  \t\tbot[col + 1] -= 1\\n  \t\tbot[col + 2] -= 1\\n  \t\tself.mineCount -= 1\\n  \\n  \tdef checkConnected(self):\\n  \t\tcounts = self.counts\\n  \t\tcols = len(counts[0]) - 2\\n  \t\trows = len(counts) - 2\\n  \\n  \t\tfor rowIdx, row in enumerate(counts):\\n  \t\t\tif rowIdx == 0 or rowIdx > rows:\\n  \t\t\t\tcontinue\\n  \t\t\ttry:\\n  \t\t\t\tcolIdx = row.index(0, 1, -1)\\n  \t\t\texcept ValueError:\\n  \t\t\t\tpass\\n  \t\t\telse:\\n  \t\t\t\tclick = (rowIdx, colIdx)\\n  \t\t\t\tbreak\\n  \t\telse:\\n  \t\t\treturn None\\n  \\n  \t\trevealed = set()\\n  \t\tdef reveal(row, col):\\n  \t\t\tif 1 <= row <= rows and 1 <= col <= cols:\\n  \t\t\t\tpos = (row, col)\\n  \t\t\t\tif pos not in revealed:\\n  \t\t\t\t\trevealed.add(pos)\\n  \t\t\t\t\tcount = counts[row][col]\\n  \t\t\t\t\tif count == 0:\\n  \t\t\t\t\t\tfor dr in (-1, 0, 1):\\n  \t\t\t\t\t\t\tfor dc in (-1, 0, 1):\\n  \t\t\t\t\t\t\t\tif dr != 0 or dc != 0:\\n  \t\t\t\t\t\t\t\t\treveal(row + dr, col + dc)\\n  \t\t\t\t\telse:\\n  \t\t\t\t\t\tassert count < 10\\n  \t\treveal(*click)\\n  \t\tnumNonMines = rows * cols - self.mineCount\\n  \t\tif len(revealed) != numNonMines:\\n  \t\t\tassert len(revealed) < numNonMines\\n  \t\t\treturn None\\n  \\n  \t\tboard = [\\n  \t\t\t\t['.' if cell < 10 else '*' for cell in row[1 : -1]]\\n  \t\t\t\tfor row in counts[1 : -1]\\n  \t\t\t\t]\\n  \t\tboard[click[0] - 1][click[1] - 1] = 'c'\\n  \t\treturn [''.join(row) for row in board]\\n  \\n  def searchBruteForce(rows, cols, mines):\\n  \tif mines == rows * cols - 1:\\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\\n  \\n  \tsearchBoard = SearchBoard(rows, cols)\\n  \\n  \tdef searchRec(idx, remaining):\\n  \t\tif remaining == 0:\\n  \t\t\treturn searchBoard.checkConnected()\\n  \t\telif idx < remaining:\\n  \t\t\treturn None\\n  \t\telse:\\n  \t\t\tpos = divmod(idx, cols)\\n  \t\t\tsearchBoard.addMine(*pos)\\n  \t\t\tfound = searchRec(idx - 1, remaining - 1)\\n  \t\t\tsearchBoard.removeMine(*pos)\\n  \t\t\tif found is not None:\\n  \t\t\t\treturn found\\n  \t\t\treturn searchRec(idx - 1, remaining)\\n  \\n  \treturn searchRec(rows * cols - 1, mines)\\n  \\n  def solve(rows, cols, mines):\\n  \tboard = search(rows, cols, mines)\\n  \\n  \tif board is None:\\n  \t\tboard = searchBruteForce(rows, cols, mines)\\n  \t\tif board is None:\\n  \t\t\treturn '\\n' + 'Impossible'\\n  \t\tprint 'ERROR: fast search missed solution for %dx%d board, %d mines:' \\\\n  \t\t\t\t% (rows, cols, mines)\\n  \t\tfor row in board:\\n  \t\t\tprint row\\n  \t\tprint\\n  \\n  \tassert len(board) == rows\\n  \tassert all(len(row) == cols for row in board)\\n  \tcounts = { 'c': 0, '.': 0, '*': 0 }\\n  \tfor row in board:\\n  \t\tfor cell in row:\\n  \t\t\tcounts[cell] += 1\\n  \tassert counts['c'] == 1\\n  \tassert counts['*'] == mines\\n  \\n  \tflowBoard = [\\n  \t\t\t['.' if cell == 'c' else cell for cell in row]\\n  \t\t\tfor row in board\\n  \t\t\t]\\n  \tdef countMinesOn(row, col):\\n  \t\tif 0 <= row < rows and 0 <= col < cols:\\n  \t\t\treturn 1 if flowBoard[row][col] == '*' else 0\\n  \t\telse:\\n  \t\t\treturn 0\\n  \tdef countMinesNear(row, col):\\n  \t\treturn sum(\\n  \t\t\tcountMinesOn(row + dr, col + dc)\\n  \t\t\tfor dr in (-1, 0, 1)\\n  \t\t\tfor dc in (-1, 0, 1)\\n  \t\t\t)\\n  \tdef reveal(row, col):\\n  \t\tif 0 <= row < rows and 0 <= col < cols:\\n  \t\t\tassert flowBoard[row][col] != '*'\\n  \t\t\tif flowBoard[row][col] == '.':\\n  \t\t\t\tcount = countMinesNear(row, col)\\n  \t\t\t\tflowBoard[row][col] = str(count)\\n  \t\t\t\tif count == 0:\\n  \t\t\t\t\tfor dr in (-1, 0, 1):\\n  \t\t\t\t\t\tfor dc in (-1, 0, 1):\\n  \t\t\t\t\t\t\treveal(row + dr, col + dc)\\n  \tclickRow, = [i for i, row in enumerate(board) if 'c' in row]\\n  \tclickCol = board[clickRow].index('c')\\n  \treveal(clickRow, clickCol)\\n  \tassert all('.' not in row for row in flowBoard), flowBoard\\n  \\n  \tassert all(type(row) == str for row in board)\\n  \treturn '\\n' + ''.join('\\n' + ''.join(row) for row in board)\\n  \\n  def main():\\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\\n  \\n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\\n  \\n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\\n  \tnumCases = int(inp.readline())\\n  \tif NUM_PROCESSES == 0:\\n  \t\tresults = [\\n  \t\t\tsolve(*parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \telse:\\n  \t\tpool = Pool(NUM_PROCESSES)\\n  \t\tresults = [\\n  \t\t\tpool.apply_async(solve, parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \tinp.close()\\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\\n  \tfor case, result in enumerate(results):\\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\\n  \t\tout.write('Case #%d: %s\\n' % (case + 1, value))\\n  \t\tout.flush()\\n  \tout.close()\\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "target": "14", "substitutes": {"FILE_NAME_BASE": ["FILE_NAME_LASE", "FILE_NAME_HANCE", "FILE_NAME_LASH", "FILE_NAME_LARS", "FILE_NAME_BASH", "FILE_NAME_BANCE", "FILE_NAME_LANCE", "FILE_NAME_BARS", "FILE_NAME_HASH", "FILE_NAME_BUARS", "FILE_NAME_HARS", "FILE_NAME_BUANCE", "FILE_NAME_BUASH", "FILE_NAME_BUASE", "FILE_NAME_HASE"], "NUM_PROCESSES": ["NUM_PRECESSURES", "NUM_PROCUMes", "NUM_PROCUMES", "NUM_PROCNECTes", "NUM_PRECESSes", "NUM_PROCESSORS", "NUM_PROCProcessES", "NUM_PROCESSURES", "NUM_PRECProcessES", "NUM_PROCProcessORS", "NUM_PROCProcessURES", "NUM_PROCNECTES", "NUM_PRECESSORS", "NUM_PRECProcesses", "NUM_PROCNECTURES", "NUM_PROCNECTORS", "NUM_PROCUMORS", "NUM_PRECESSES", "NUM_PROCProcesses", "NUM_PROCESSes", "NUM_PRECProcessORS", "NUM_PROCUMURES", "NUM_PRECProcessURES"], "MEM_LIMIT_GB": ["MEM_LIMITINGB", "MEM_LIMITINGMB", "MEM_LIMITING", "MEM_LIMITED_GB", "MEM_LIMITED_MB", "MEM_LIMIT_MB", "MEM_LIMITED_G", "MEM_LIMITINGGB", "MEM_LIMITINMB", "MEM_LIMITINGG", "MEM_LIMITED_SEC", "MEM_LIMIT_SEC", "MEM_LIMITINSEC", "MEM_LIMIT_G", "MEM_LIMITINGSEC"]}}
{"code": "\\n  \\n  EOL = \"\\n\"\\n  \\n  \\n  def is_equal_approx(x, y, epsilon=1e-6):\\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\\n      \\n      By default, 'epsilon' is 1e-6.\\n      \"\"\"\\n      if -epsilon <= x - y <= epsilon:\\n          return True\\n  \\n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\\n          return False\\n  \\n      return (-epsilon <= (x - y) / x <= epsilon\\n          or -epsilon <= (x - y) / y <= epsilon)\\n    \\n  def read_syms(fd):\\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\\n      return fd.readline().strip().split()\\n  \\n  def read_ints(fd):\\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\\n      return [int(p) for p in read_syms(fd)]\\n  \\n  def read_floats(fd):\\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\\n      return [float(p) for p in read_syms(fd)]\\n  \\n  \\n  class Mtrx(object):\\n      \"\"\"A matrix object.\"\"\"\\n      \\n      def __init__(self, rows, cols, data):\\n          assert len(data) == rows * cols\\n          self.rows = rows\\n          self.cols = cols\\n          self.data = data\\n          \\n      def cell(self, r, c):\\n          return self.data[r * self.cols + c]\\n      \\n      def getrow(self, i):\\n          return [self.cell(i, c) for c in xrange(self.cols)]\\n  \\n      def getcol(self, i):\\n          return [self.cell(c, i) for c in xrange(self.rows)]\\n      \\n      @classmethod\\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\\n          \\n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\\n          Pre-determined size can be passed using `rows` and `cols`.\\n          \"\"\"\\n          data = []\\n          if rows is None:\\n              assert cols is None\\n              rows, cols = read_ints(fd)\\n          else:\\n              assert cols is not None\\n          for _ in range(rows):\\n              line = readfunc(fd)\\n              assert len(line) == cols\\n              data.extend(line)\\n          return Mtrx(rows, cols, data)\\n              \\n      @classmethod\\n      def read_int_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_ints, rows, cols)\\n              \\n      @classmethod\\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_syms, rows, cols)\\n              \\n      def __str__(self):\\n          res = \"\"\\n          for i in xrange(self.rows):\\n              res += str(self.getrow(i)) + EOL\\n          return res\\n      \\n      def __repr__(self):\\n          return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\\n                                         self.cols, self.data)\\n  \\n  \\n  cachetotals = 0\\n  cachemisses = 0\\n  \\n  def statreset():\\n      global cachemisses, cachetotals\\n      cachemisses = 0\\n      cachetotals = 0\\n  \\n  class memoizeit(object):\\n      \"\"\"Decorator. Caches a function's return value each time it is called.\\n      \\n      If called later with the same arguments, the cached value is returned \\n      (not reevaluated).\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          self.cache = {}\\n          \\n      def __call__(self, *args):\\n          \\n          global cachetotals, cachemisses\\n          cachetotals += 1\\n          \\n          try:\\n              return self.cache[args]\\n          except KeyError:\\n              \\n              cachemisses += 1\\n              \\n              value = self.func(*args)\\n              self.cache[args] = value\\n              return value\\n          except TypeError:\\n  \\n              cachemisses += 1\\n  \\n              return self.func(*args)\\n      \\n      @property\\n      def __name__(self):\\n          return self.func.__name__\\n      \\n      def __get__(self, obj, objtype):\\n          \"\"\"Support instance methods.\"\"\"\\n          return functools.partial(self.__call__, obj)\\n  \\n  \\n  class timeit(object):\\n      \"\"\"Decorator that times a function.\\n      \\n      When function ends, print name, runtime, return value and cache stats.\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          \\n      def __call__(self, *args):\\n          start = time.time()\\n          value = self.func(*args)\\n          delta = time.time() - start\\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\\n              cachetotals else 0\\n          print self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\\n              delta, value, cachedata)\\n          return value\\n      \\n      def __get__(self, obj, objtype):\\n          return functools.partial(self.__call__, obj)\\n  \\n  \\n  def read_input(filename):\\n      data = []\\n      with open(filename, \"r\") as f:\\n          cases = read_ints(f)[0]\\n          for _ in xrange(cases):\\n              case = {}\\n              case[\"C\"], case[\"F\"], case[\"X\"] = read_floats(f)\\n              data.append(case)\\n      return data\\n  \\n  def make_output(fname, output):\\n      CASE_PRFX = \"Case #%s: \"\\n      fname = fname + time.strftime(\"%H%M%S\") + \".out\"\\n      with open(fname, \"w\") as f:\\n          restext = []\\n          print \"Output content ===============\"\\n          for i, outdata in enumerate(output):\\n              line = CASE_PRFX % (i + 1,) + str(outdata) + EOL\\n              print line,\\n              restext.append(line)\\n          print \"=\" * 30\\n          f.writelines(restext)\\n  \\n  \\n  @memoizeit\\n  def will_a_farm_help(target, current_rate, farm_cost, farm_rate):\\n      no_farm = target / current_rate\\n      with_farm = farm_cost / current_rate + target / (farm_rate + current_rate)\\n      if no_farm > with_farm:\\n          return True, farm_cost / current_rate\\n      else:\\n          return False, no_farm\\n  \\n  @timeit\\n  def solveit(case):\\n      C = case[\"C\"]\\n      F = case[\"F\"]\\n      X = case[\"X\"]\\n      \\n      t = 0\\n      current_rate = 2.0 # default rate of 2 cookies per seconds\\n      \\n      while True:\\n          new_farm, add_time = will_a_farm_help(X, current_rate, C, F)\\n          if new_farm:\\n              t += add_time\\n              current_rate += F\\n          else:\\n              t += add_time\\n              return t\\n  \\n  \\n  @timeit\\n  def main(fname):\\n      data = read_input(fname)\\n      output = []\\n      for case in data:\\n          statreset() # reset cache stats\\n          res = solveit(case)\\n          output.append(res)\\n      make_output(fname, output)\\n  \\n  \\n  if __name__ == '__main__':\\n      main(\"B-small-attempt0.in\")\\n", "target": "15", "substitutes": {"EOL": [" EOF", "EBOF", "eol", "EOC", " EOC", "eOF", "EBol", "Eol", " Eol", "EOF", "EBOL", "eOC", "eOL", "EBOC"], "x": ["e", "xa", "xs", "xi", "d", "ay", "id", "px", "sex", "h", "xf", "xy", "point", "width", "u", "z", "rx", "ty", "yx", "on", "v", "dx", "w", "n", "m", "wy", "l", "ex", "xc", "wx", "win", "xe", "time", "int", "cell", "a", "ph", "k", "ya", "xx", "ix", "Y", "b", "f", "ax"], "y": ["e", "ny", "ys", "yr", "zy", "d", "iy", "yy", "ay", "ady", "yt", "sy", "ye", "j", "year", "z", "ky", "ty", "v", "ym", "yl", "hy", "w", "cy", "oy", "ies", "wy", "py", "n", "l", "yi", "ey", "dy", "ry", "yo", "ya", "vy", "Y", "b", "yd", "f", "o"], "epsilon": ["epssilony", "epssilon", "epelton", "eprilency", "epsalhen", "epillen", "epilron", "epsalON", "epssilons", "epSilor", "epslan", "epsiloton", "ppillron", "iprilron", "epsalon", "epineloton", "apsilon", "epilloner", "iprilor", "epiolan", "epalons", "eprilen", "epeltron", "EPsilon", "epssilON", "ipsilony", "ppsilen", "epiolon", "epiolons", "epssiloner", "epillency", "epalron", "epillone", "eprilON", "epillron", "epilony", "ppeltony", "epsilone", "epalyson", "EPeltone", "epillON", "epilen", "epeltoner", "epinelron", "ppillon", "epslON", "ppeltron", "epssilhen", "ipsilon", "ppsilony", "epsilhen", "ipsilor", "epilON", "eprilony", "epSilony", "epineloner", "ppillen", "epilone", "epillhen", "epalysron", "ppillON", "ppelton", "ppsilON", "apillony", "epillony", "apsilron", "epinelon", "epsilency", "epillons", "ppsilron", "epeltons", "EPsilone", "epilons", "epeltone", "epssilron", "ppsilon", "apilloner", "epeltency", "epSilon", "apillron", "EPsilency", "epalan", "apsilony", "epssiloton", "epalysoton", "epsilons", "epsilen", "epsilony", "epsiloner", "epiolhen", "ppeltone", "epalON", "epalysoner", "EPeltency", "epslon", "epsalan", "ppsilone", "epsalron", "epiloton", "eprilone", "ipsilron", "eprilon", "epsilON", "epSilron", "epssilen", "epsilan", "epssilone", "eprilan", "epillon", "epilor", "epillan", "apillon", "epelten", "epssilan", "epilon", "epiloner", "EPsilony", "eprilor", "EPeltony", "epeltON", "iprilony", "epalon", "EPelton", "epeltony", "epalhen", "eprilons", "iprilon", "epilan", "epsilron", "eprilron", "epsalons", "epslron", "epsilor", "apsiloner"], "fd": ["cf", "fw", "pd", "buf", "rb", "d", "cb", "fr", "handle", "FD", "fn", "fed", "nd", "driver", "dc", "bf", "fx", "ecd", "fi", "lf", "af", "handler", "dir", "fb", "file", "fm", "stream", "wb", "dd", "ds", "pdf", "feed", "pipe", "vd", "sf", "td", "draft", "bd", "dl", "fl", "fp", "fs", "wd", "ff", "hd", "cod", "df", " fid", "reader", "ld", "fe", "fin", "db", "fat", "f", "fc", "fen", "draw", "wind", "gd", "folder", "fa"], "p": ["e", "ip", "d", "pp", "h", "mp", "ap", "pr", "op", "u", "pi", "pid", "v", "pa", "type", "q", "n", "m", "np", "gp", "py", "jp", "l", "vp", "fp", "pc", "ep", "tp", "python", "sp", "lp", "ph", "wp", "bp", "P", "b", "f", "cp", "o", "g"], "self": ["ws", "events", "proxy", "Self", "github", "object", "http", "wx", "ff", "end", "parent", "worker", "us", "node", "err", "resp", "page", "per", "event", "pos", "plus", "dev", "qa", "er", "instance", "z", "cs", "w", "es", "n", "l", "os", "plugin", "all", "old", "s", "app", "a", "df", "tmp", "b", "f", "user", "e", "full", "gen", "client", "d", "default", "j", "lf", "now", "config", "context", "master", "host", "sys", "form", "co", "error", "m", "fs", "new", "this", "other", "ng", "ko", "ctx", "results", "h", "view", "ref", "spec", "part", "home", "q", "cl", "work", "gh", "k", "req", "g", "wrapper"], "rows": ["heads", "ws", "xs", "events", "reads", " row", "aults", "errors", "values", "row", "types", "pages", "ins", "ls", "fields", "index", "rooms", "frames", "times", "checks", "orders", " columns", "tracks", "runs", "ries", "rules", "qs", "pos", " lines", "length", "features", "rings", "cs", "breaks", "ks", "models", "headers", "posts", "all", "s", "blocks", "rs", "window", "reports", "modules", "OWS", "ports", "ops", "relations", "d", "ids", "opens", "planes", "levels", "cells", "keys", "days", "char", "files", "faces", "head", "roots", "lines", "boxes", "devices", "results", "members", "vals", "points", "holes", "ows", "forms", "docs", "rown", "groups", "views", "olds", "flows", "items", "tests", "users", "ros", "ips", "es"], "cols": [" colb", "cles", "colds", "colln", "Colts", "colsi", " colts", "columnds", "colb", "colops", "collcount", "Cols", "yls", "clcs", "threadts", "columnows", "columnes", "columnd", "Colp", "cold", "COLs", "columncount", "threads", "columncs", "collows", " colw", "COLabs", " colp", "coles", "columnops", "ylp", " coli", "pools", "threadgs", "COLops", "columnsd", "colcs", "columnts", "pooli", "ylls", " colsi", "dicts", "Coln", "columns", " colds", " colls", " colS", "COLsd", "columnabs", "colsd", "dictn", "colls", "coln", " coln", "Colsd", "COLd", "columnsi", "pooln", "COLgs", "Coli", "colcount", "dicti", "colp", "columnn", "colows", "columni", "cld", "colgs", " colops", "coli", "colli", "colabs", "yln", "Colds", " colcount", "colS", "colles", "columnw", " colgs", "Cold", "Colows", " coles", "columnb", "COLn", " cold", "Colabs", "ColS", "Colb", "colts", " colows", "COLts", "columnS", "Colls", " colabs", "colw", " colcs", "poolsi", "Colw"], "data": ["append", "json", "api", "media", "dd", "values", "row", "div", "Data", "actions", "index", "text", "zip", "parent", "cell", "float", "table", "pos", "li", "ata", "feed", "la", "sample", "valid", "dat", "breaks", "body", "all", "blocks", "a", "window", "buffer", "code", "array", "f", "post", "steps", "d", "default", "next", "input", "config", "multi", "response", "form", "cells", "partial", "alpha", "da", "block", "model", "result", "lines", "format", "load", "bytes", "draw", "devices", "results", "memory", "content", "str", "list", "column", "image", "arr", "DATA", "group", "string", "source", "dict", "missing", "raw", "di", "xxx", "batch", "reader", "items", "scale"], "r": ["e", "range", "rr", "rb", "d", "col", "rc", "j", "ar", "u", "er", "z", "v", "lr", "row", "rec", "ra", "w", "q", "m", "n", "l", "entry", "R", "ru", "right", "rh", "s", "k", "rs", "sr", "nr", "b", "f", "cr", "rar"], "c": ["e", "cf", "d", "col", "h", "ac", "dc", "ch", "ce", "u", "ct", "z", "cat", "co", "cu", "v", "row", "rec", "cs", "cy", "uc", "n", "ci", "m", "l", "cl", "xc", "pc", "cc", "s", "unc", "int", "cell", "k", "ic", "ec", "nc", "code", "cm", "b", "f", "fc", "cr", "cp", "arc", "lc"], "i": ["e", "si", "ini", "xi", "ip", "d", "col", "mi", "id", "ch", "j", "I", "u", "z", "li", "it", "ai", "ui", "v", "pi", "cu", "io", "q", "n", "ci", "l", "ii", "index", "di", "yi", "s", "int", "cell", "ic", "ix", "ri", "iu", "b", "oi", "f", "lc", "qi"], "cls": [" clsys", "wells", "Clsg", "clabs", "hellsb", "Clabs", "Cls", "Clsys", " Clp", "wellsb", " Cls", "Classsb", "CLabs", "clusters", "clS", "hells", "CLS", "wellusters", " Clsys", " clabs", "CLs", "clsb", "clsg", "clsys", "Classsg", "CLsg", "clp", "Classs", " clp", " clusters", "Clusters", "Clp", "Clsb", "CLsb", "ClS", " clsb", "hellS"], "readfunc": ["readfunction", "writefunc", "loadfunc", " readfunction", "loadproc", " readproc", "loadfun", " readfun", "writefun", "readfun", "writefunction", "writeproc", "loadfunction", "readproc"], "_": ["non", "un", "q", "l", "al", "all", "k", "f", "g"], "line": ["page", "range", "d", "name", "col", "content", "inline", "len", "str", "lo", "item", "header", "section", "length", "lf", "input", "column", "file", "number", "li", "Line", "band", "lin", "row", "string", "LINE", "record", "limit", "log", "l", "el", "entry", "text", "body", "char", "block", "byte", "model", "sync", "zip", "base", "end", "cell", "frame", "reader", "buffer", "lines", "code", "no", "lc"]}}
{"code": "\\n  \\n  EOL = \"\\n\"\\n  \\n  \\n  def is_equal_approx(x, y, epsilon=1e-6):\\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\\n      \\n      By default, 'epsilon' is 1e-6.\\n      \"\"\"\\n      if -epsilon <= x - y <= epsilon:\\n          return True\\n  \\n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\\n          return False\\n  \\n      return (-epsilon <= (x - y) / x <= epsilon\\n          or -epsilon <= (x - y) / y <= epsilon)\\n    \\n  def read_syms(fd):\\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\\n      return fd.readline().strip().split()\\n  \\n  def read_ints(fd):\\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\\n      return [int(p) for p in read_syms(fd)]\\n  \\n  def read_floats(fd):\\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\\n      return [float(p) for p in read_syms(fd)]\\n  \\n  \\n  class Mtrx(object):\\n      \"\"\"A matrix object.\"\"\"\\n      \\n      def __init__(self, rows, cols, data):\\n          assert len(data) == rows * cols\\n          self.rows = rows\\n          self.cols = cols\\n          self.data = data\\n          \\n      def cell(self, r, c):\\n          return self.data[r * self.cols + c]\\n      \\n      def getrow(self, i):\\n          return [self.cell(i, c) for c in xrange(self.cols)]\\n  \\n      def getcol(self, i):\\n          return [self.cell(c, i) for c in xrange(self.rows)]\\n      \\n      @classmethod\\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\\n          \\n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\\n          Pre-determined size can be passed using `rows` and `cols`.\\n          \"\"\"\\n          data = []\\n          if rows is None:\\n              assert cols is None\\n              rows, cols = read_ints(fd)\\n          else:\\n              assert cols is not None\\n          for _ in range(rows):\\n              line = readfunc(fd)\\n              assert len(line) == cols\\n              data.extend(line)\\n          return Mtrx(rows, cols, data)\\n              \\n      @classmethod\\n      def read_int_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_ints, rows, cols)\\n              \\n      @classmethod\\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_syms, rows, cols)\\n              \\n      def __str__(self):\\n          res = \"\"\\n          for i in xrange(self.rows):\\n              res += str(self.getrow(i)) + EOL\\n          return res\\n      \\n      def __repr__(self):\\n          return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\\n                                         self.cols, self.data)\\n  \\n  \\n  cachetotals = 0\\n  cachemisses = 0\\n  \\n  def statreset():\\n      global cachemisses, cachetotals\\n      cachemisses = 0\\n      cachetotals = 0\\n  \\n  class memoizeit(object):\\n      \"\"\"Decorator. Caches a function's return value each time it is called.\\n      \\n      If called later with the same arguments, the cached value is returned \\n      (not reevaluated).\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          self.cache = {}\\n          \\n      def __call__(self, *args):\\n          \\n          global cachetotals, cachemisses\\n          cachetotals += 1\\n          \\n          try:\\n              return self.cache[args]\\n          except KeyError:\\n              \\n              cachemisses += 1\\n              \\n              value = self.func(*args)\\n              self.cache[args] = value\\n              return value\\n          except TypeError:\\n  \\n              cachemisses += 1\\n  \\n              return self.func(*args)\\n      \\n      @property\\n      def __name__(self):\\n          return self.func.__name__\\n      \\n      def __get__(self, obj, objtype):\\n          \"\"\"Support instance methods.\"\"\"\\n          return functools.partial(self.__call__, obj)\\n  \\n  \\n  class timeit(object):\\n      \"\"\"Decorator that times a function.\\n      \\n      When function ends, print name, runtime, return value and cache stats.\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          \\n      def __call__(self, *args):\\n          start = time.time()\\n          value = self.func(*args)\\n          delta = time.time() - start\\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\\n              cachetotals else 0\\n          print self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\\n              delta, value, cachedata)\\n          return value\\n      \\n      def __get__(self, obj, objtype):\\n          return functools.partial(self.__call__, obj)\\n  \\n  \\n  def read_input(filename):\\n      data = []\\n      with open(filename, \"r\") as f:\\n          cases = read_ints(f)[0]\\n          for _ in xrange(cases):\\n              case = {}\\n              case[\"R\"], case[\"C\"], case[\"M\"] = read_ints(f)\\n              data.append(case)\\n      return data\\n  \\n  def make_output(fname, output):\\n      CASE_PRFX = \"Case #%s: \"\\n      fname = fname + time.strftime(\"%H%M%S\") + \".out\"\\n      with open(fname, \"w\") as f:\\n          restext = []\\n          print \"Output content ===============\"\\n          for i, outdata in enumerate(output):\\n              line = CASE_PRFX % (i + 1,) + EOL + str(outdata) + EOL\\n              print line,\\n              restext.append(line)\\n          print \"=\" * 30\\n          f.writelines(restext)\\n  \\n  \\n  MINE = \"*\"\\n  CLICK = \"c\"\\n  UNK = \".\"\\n  \\n  class Board(object):\\n      \\n      def __init__(self, r, c):\\n          self.rows = r\\n          self.cols = c\\n          self.edge_row_idx = self.rows - 1\\n          self.edge_col_idx = self.cols - 1\\n          self.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]\\n          self.board[0][0] = CLICK\\n  \\n      def fill_edge_row(self, m):\\n          i = self.edge_col_idx\\n          while m > 0 and i >= 0:\\n              self.board[self.edge_row_idx][i] = MINE\\n              i -= 1\\n              m -= 1\\n          self.edge_row_idx -= 1\\n  \\n      def fill_edge_col(self, m):\\n          i = self.edge_row_idx\\n          while m > 0 and i >= 0:\\n              self.board[i][self.edge_col_idx] = MINE\\n              i -= 1\\n              m -= 1\\n          self.edge_col_idx -= 1\\n  \\n      def __str__(self):\\n          return EOL.join([\"\".join(r) for r in self.board])\\n  \\n  @memoizeit\\n  def is_stage_solvable(rows, cols, mines):\\n      \"\"\"Return True iff stage is solvable. \\n      Also return fill instruction:\\n      0 if impossible/dontcare, 1 to fill row, 2 to fill column, \\n      3 for row special (most in the row), 4 for col special (most in the col)\\n      \"\"\"\\n      rc = rows * cols\\n      \\n      if mines == rc:\\n          return False, 0\\n  \\n      if rows == 1:\\n          return mines <= rc - 1, 2\\n      if cols == 1:\\n          return mines <= rc - 1, 1\\n      \\n      if mines == rc - 1:\\n          return True, 1  # doesn't matter what to fill\\n      \\n      if mines > rc - 4:\\n          return False, 0\\n      \\n      if rows == 2:\\n          return (False, 0) if mines == 1 else (True, 2)\\n      if cols == 2:\\n          return (False, 0) if mines == 1 else (True, 1)\\n          \\n      if rows <= cols:\\n          if mines >= rows:\\n              return True, 2\\n          if mines == rows - 1:\\n              if mines == cols - 1:\\n                  if rows == 3:\\n                      return False, 0\\n                  return True, 4 # L shape fill, most in the column\\n              else:\\n                  return True, 1 # fill row\\n          return True, 2 \\n      else:\\n          if mines >= cols:\\n              return True, 1\\n          if mines == cols - 1:\\n              if mines == rows - 1:\\n                  if cols == 3:\\n                      return False, 0\\n                  return True, 3 # L shape fill, most in the row\\n              else:\\n                  return True, 2 # fill column\\n          return True, 1 \\n  \\n  @timeit\\n  def solveit(case):\\n      rows = case[\"R\"]\\n      cols = case[\"C\"]\\n      mines = case[\"M\"]\\n      \\n      b = Board(rows, cols)\\n      r, c, m = rows, cols, mines\\n      \\n      while m >= 0:\\n          okgo, howtofill = is_stage_solvable(r, c, m)\\n          if not okgo:\\n              return \"Impossible\"\\n          if howtofill == 1: # fill row\\n              b.fill_edge_row(m)\\n              if m <= c:\\n                  break # fill and done\\n              m -= c\\n              r -= 1\\n          elif howtofill == 2: # fill column\\n              b.fill_edge_col(m)\\n              if m <= r:\\n                  break # fill and done\\n              m -= r\\n              c -= 1\\n          elif howtofill == 3: # L shape fill, most in the row\\n              b.fill_edge_row(m - 1)\\n              b.fill_edge_col(1)\\n              break # fill and done\\n          elif howtofill == 4: # L shape fill, most in the column\\n              b.fill_edge_col(m - 1)\\n              b.fill_edge_row(1)\\n              break # fill and done\\n          else:\\n              assert False\\n  \\n      return str(b) \\n  \\n  \\n  \\n  @timeit\\n  def main(fname):\\n      data = read_input(fname)\\n      output = []\\n      for case in data:\\n          statreset() # reset cache stats\\n          res = solveit(case)\\n          output.append(res)\\n      make_output(fname, output)\\n  \\n  \\n  if __name__ == '__main__':\\n      main(\"C-small-attempt0.in\")\\n", "target": "15", "substitutes": {"EOL": [" EOF", "EBOF", "eol", "EOC", " EOC", "eOF", "EBol", "Eol", " Eol", "EOF", "EBOL", "eOC", "eOL", "EBOC"], "x": ["e", "xa", "xs", "xi", "d", "ay", "id", "px", "X", "sex", "h", "xf", "xy", "point", "width", "u", "z", "rx", "t", "ty", "yx", "on", "v", "dx", "w", "n", "wy", "l", "ex", "xc", "wx", "win", "xe", "time", "int", "cell", "a", "ph", "k", "ya", "xx", "ix", "Y", "b", "f", "ax"], "y": ["e", "ny", "ys", "yr", "zy", "d", "iy", "yy", "ay", "ady", "yt", "sy", "ye", "j", "year", "z", "ky", "ty", "t", "v", "ym", "yl", "hy", "w", "cy", "oy", "ies", "wy", "py", "n", "l", "yi", "ey", "dy", "ry", "yo", "ya", "vy", "Y", "b", "yd", "f", "o"], "epsilon": ["epssilony", "epssilon", "epelton", "eprilency", "epsalhen", "epillen", "epilron", "epsalON", "epssilons", "epSilor", "epslan", "epsiloton", "ppillron", "iprilron", "epsalon", "epineloton", "apsilon", "epilloner", "iprilor", "epiolan", "epalons", "eprilen", "epeltron", "EPsilon", "epssilON", "ipsilony", "ppsilen", "epiolon", "epiolons", "epssiloner", "epillency", "epalron", "epillone", "eprilON", "epillron", "epilony", "ppeltony", "epsilone", "epalyson", "EPeltone", "epillON", "epilen", "epeltoner", "epinelron", "ppillon", "epslON", "ppeltron", "epssilhen", "ipsilon", "ppsilony", "epsilhen", "ipsilor", "epilON", "eprilony", "epSilony", "epineloner", "ppillen", "epilone", "epillhen", "epalysron", "ppillON", "ppelton", "ppsilON", "apillony", "epillony", "apsilron", "epinelon", "epsilency", "epillons", "ppsilron", "epeltons", "EPsilone", "epilons", "epeltone", "epssilron", "ppsilon", "apilloner", "epeltency", "epSilon", "apillron", "EPsilency", "epalan", "apsilony", "epssiloton", "epalysoton", "epsilons", "epsilen", "epsilony", "epsiloner", "epiolhen", "ppeltone", "epalON", "epalysoner", "EPeltency", "epslon", "epsalan", "ppsilone", "epsalron", "epiloton", "eprilone", "ipsilron", "eprilon", "epsilON", "epSilron", "epssilen", "epsilan", "epssilone", "eprilan", "epillon", "epilor", "epillan", "apillon", "epelten", "epssilan", "epilon", "epiloner", "EPsilony", "eprilor", "EPeltony", "epeltON", "iprilony", "epalon", "EPelton", "epeltony", "epalhen", "eprilons", "iprilon", "epilan", "epsilron", "eprilron", "epsalons", "epslron", "epsilor", "apsiloner"], "fd": ["cf", "fw", "pd", "buf", "rb", "d", "cb", "fr", "handle", "FD", "fn", "fed", "nd", "driver", "dc", "bf", "fx", "ecd", "fi", "lf", "af", "handler", "dir", "fb", "file", "fm", "stream", "wb", "dd", "ds", "pdf", "feed", "pipe", "vd", "sf", "td", "draft", "bd", "dl", "fl", "fp", "fs", "wd", "ff", "hd", "cod", "df", " fid", "reader", "ld", "fe", "fin", "db", "fat", "f", "fc", "fen", "draw", "wind", "gd", "folder", "fa"], "p": ["e", "ip", "d", "pp", "h", "mp", "ap", "pr", "op", "u", "t", "pi", "pid", "v", "pa", "type", "q", "n", "np", "gp", "py", "jp", "l", "vp", "fp", "pc", "ep", "tp", "python", "sp", "lp", "ph", "wp", "bp", "P", "b", "f", "cp", "o", "g"], "self": ["ws", "events", "proxy", "Self", "github", "object", "http", "wx", "ff", "end", "parent", "worker", "us", "node", "err", "resp", "page", "per", "event", "pos", "plus", "dev", "qa", "er", "instance", "z", "cs", "w", "es", "n", "l", "os", "plugin", "all", "old", "s", "app", "a", "df", "tmp", "b", "f", "user", "e", "full", "gen", "client", "d", "default", "j", "lf", "now", "config", "context", "master", "host", "sys", "form", "co", "error", "fs", "new", "this", "other", "ng", "ko", "ctx", "results", "h", "view", "ref", "spec", "part", "home", "q", "cl", "work", "gh", "k", "req", "g", "wrapper"], "rows": ["heads", "ws", "xs", "events", "reads", " row", "aults", "errors", "values", "row", "types", "pages", "ins", "ls", "fields", "index", "rooms", "frames", "times", "checks", "orders", " columns", "tracks", "runs", "ries", "rules", "qs", "pos", " lines", "length", "features", "rings", "cs", "breaks", "ks", "models", "headers", "posts", "all", "s", "blocks", "rs", "window", "reports", "modules", "OWS", "ports", "ops", "relations", "d", "ids", "opens", "planes", "levels", "cells", "keys", "days", "char", "files", "faces", "head", "roots", "lines", "boxes", "devices", "results", "members", "vals", "points", "holes", "ows", "forms", "docs", "rown", "groups", "views", "olds", "flows", "items", "tests", "users", "ros", "ips", "es"], "cols": [" colb", "cles", "colds", "colln", "Colts", "colsi", " colts", "columnds", "colb", "colops", "collcount", "Cols", "yls", "clcs", "threadts", "columnows", "columnes", "columnd", "Colp", "cold", "COLs", "columncount", "threads", "columncs", "collows", " colw", "COLabs", " colp", "coles", "columnops", "ylp", " coli", "pools", "threadgs", "COLops", "columnsd", "colcs", "columnts", "pooli", "ylls", " colsi", "dicts", "Coln", "columns", " colds", " colls", " colS", "COLsd", "columnabs", "colsd", "dictn", "colls", "coln", " coln", "Colsd", "COLd", "columnsi", "pooln", "COLgs", "Coli", "colcount", "dicti", "colp", "columnn", "colows", "columni", "cld", "colgs", " colops", "coli", "colli", "colabs", "yln", "Colds", " colcount", "colS", "colles", "columnw", " colgs", "Cold", "Colows", " coles", "columnb", "COLn", " cold", "Colabs", "ColS", "Colb", "colts", " colows", "COLts", "columnS", "Colls", " colabs", "colw", " colcs", "poolsi", "Colw"], "data": ["append", "json", "api", "media", "dd", "values", "row", "div", "Data", "actions", "index", "text", "zip", "parent", "cell", "float", "table", "pos", "li", "ata", "feed", "la", "sample", "valid", "dat", "breaks", "body", "all", "blocks", "a", "window", "buffer", "code", "array", "f", "post", "steps", "d", "default", "next", "input", "config", "multi", "response", "form", "cells", "partial", "alpha", "da", "block", "model", "result", "lines", "format", "load", "bytes", "draw", "devices", "results", "memory", "content", "str", "list", "column", "image", "arr", "DATA", "group", "string", "source", "dict", "missing", "raw", "di", "xxx", "batch", "reader", "items", "scale"], "r": ["e", "range", "rr", "rb", "d", "col", "j", "ar", "u", "er", "z", "v", "lr", "row", "rec", "ra", "w", "q", "n", "l", "entry", "R", "ru", "right", "rh", "s", "k", "rs", "sr", "nr", "b", "f", "cr", "rar"], "c": ["e", "cf", "d", "col", "h", "ac", "C", "dc", "ch", "ce", "u", "ct", "z", "t", "cat", "co", "cu", "v", "row", "rec", "cs", "cy", "uc", "n", "ci", "l", "cl", "xc", "pc", "cc", "s", "unc", "int", "cell", "k", "ic", "ec", "nc", "code", "cm", "b", "f", "fc", "cr", "cp", "arc", "lc"], "i": ["e", "si", "ini", "xi", "ip", "d", "col", "mi", "id", "ch", "j", "I", "u", "z", "li", "it", "ai", "ui", "v", "pi", "cu", "io", "q", "n", "ci", "l", "ii", "index", "di", "yi", "s", "int", "cell", "ic", "ix", "ri", "iu", "b", "oi", "f", "lc", "qi"], "cls": [" clsys", "wells", "Clsg", "clabs", "hellsb", "Clabs", "Cls", "Clsys", " Clp", "wellsb", " Cls", "Classsb", "CLabs", "clusters", "clS", "hells", "CLS", "wellusters", " Clsys", " clabs", "CLs", "clsb", "clsg", "clsys", "Classsg", "CLsg", "clp", "Classs", " clp", " clusters", "Clusters", "Clp", "Clsb", "CLsb", "ClS", " clsb", "hellS"], "readfunc": ["readfunction", "writefunc", "loadfunc", " readfunction", "loadproc", " readproc", "loadfun", " readfun", "writefun", "readfun", "writefunction", "writeproc", "loadfunction", "readproc"], "_": ["non", "un", "q", "l", "al", "all", "k", "f", "g"], "line": ["page", "range", "d", "name", "col", "content", "inline", "len", "str", "lo", "item", "header", "section", "length", "lf", "input", "column", "file", "number", "li", "Line", "band", "lin", "row", "string", "LINE", "record", "limit", "log", "l", "el", "entry", "text", "body", "char", "block", "byte", "model", "sync", "zip", "base", "end", "cell", "frame", "reader", "buffer", "lines", "code", "no", "lc"]}}
{"code": "\\n  BIG_NUM=100000\\n  def Solve(C,F,X):\\n      best_time=float('inf')\\n      for n in xrange(0,BIG_NUM):\\n          if n==0:\\n              farm_time=0\\n          else:\\n              farm_time += C/(2+(n-1)*F)\\n          if best_time<=farm_time: break\\n          cookie_time=X/(2+n*F)\\n  \\n          if farm_time+cookie_time<best_time:\\n              best_time=farm_time+cookie_time\\n  \\n      return '%.9f'%best_time\\n  \\n  \\n  \\n  def parse(infile):\\n      C,F,X=map(float, infile.readline().split() )\\n      return C,F,X\\n  \\n  \\n  \\n  class GCJ_Parser( object ):\\n      def __init__(self,fname):\\n          self.infile=open(fname,'r')\\n          self.NumCases=int(self.infile.readline().strip() )\\n          self.caseNum=0\\n  \\n      def __iter__(self): return self\\n  \\n      def next(self):\\n          if self.caseNum==self.NumCases: raise StopIteration\\n          self.caseNum += 1\\n          args=parse(self.infile)\\n          return self.caseNum , args\\n  \\n  \\n  def runmain():\\n      myCases=GCJ_Parser(sys.argv[1])\\n  \\n      outname=sys.argv[1].rstrip('.in')+'.out'\\n      if os.path.isfile(outname):\\n          oldout=outname+'.old'\\n          ii=0\\n          while os.path.isfile(oldout):\\n              ii+=1\\n              oldout=outname+'.old'+str(ii)\\n          os.rename(outname,oldout)\\n          print 'Rename: %s -> %s'%(outname,oldout)   \\n   \\n      outfile=open(outname,'w')\\n  \\n      for iCase, args in myCases:\\n          answer=Solve(*args)\\n  \\n          print 'Case #'+str(iCase)+':',answer\\n          print >> outfile, 'Case #'+str(iCase)+':',answer\\n  \\n  \\n  \\n  \\n  if __name__=='__main__':\\n      runmain()\\n", "target": "16", "substitutes": {"BIG_NUM": ["BIGOCSIZE", "BIGS_UM", "BIGPOTIME", "BIGOCNUM", "BIGS_DAY", "BIG_DAY", "BIGNNUM", "BIGS_TIME", "BIGS_SIZE", "BIGSNSIZE", "BIGNUM", "BIGPONUM", "BIG_SIZE", "BIGNSIZE", "BIGS_num", "BIG_num", "BIGPOUM", "BIG_TIME", "BIGSNUM", "BIGOCnum", "BIGOCDAY", "BIGSNTIME", "BIGNTIME", "BIGPOSIZE", "BIGS_NUM", "BIGSNNUM", "BIG_UM"], "C": ["N", "CF", "U", "G", "O", "I", "CNN", "CA", "W", "M", "NC", "CE", "K", "CM", "DC", "CP", "CC", "L", "D", "A", "R", "MC", "T", "CN", "B", " c", "S", "CO", "c", "CR", "E", "H", "CI", "V", "CU", "Y", "P"], "F": ["N", "CF", "U", "UL", "G", "Fs", "FD", "DF", "OF", "O", "I", "FB", "W", "FL", "M", "K", "Fi", "FS", "L", "Family", "D", "FO", "EF", "T", "PF", "FH", "GF", "B", "WF", "FM", "FA", "E", "SF", "H", "V", "FF", "Y", "Q", "P", "Far", "f", "MF", "FW"], "X": ["N", "CF", "U", "XL", "G", "XP", "ZX", "J", "O", "IX", "XXX", "CL", "TX", "W", "IP", "NC", "M", "Z", "K", "CC", "L", "D", "A", "HTTP", "R", "T", "FX", "B", "Ex", "S", "FC", "FE", "E", "H", "UX", "x", "V", "FF", "XY", "Y", "XXXX", "Q", "P", "XX"], "best_time": ["feature_time", "farm_cost", "feature_content", "bestlyprice", "best2date", "featureianspace", "bestianprice", "bestvalspace", "bestacim", "best2time", "bestianspace", "best2am", "bestiantimer", "best_timer", "bestianim", "best_cost", "best_times", "bestvalcontent", "featureiantime", "bestactimer", "bestxsize", "better_size", "bestacdate", "latest_timer", "featureiancontent", "best2TIME", "best_am", "farm_date", "latest_size", "latestianim", "best_TIME", "feature_space", "bestlycontent", "best_content", "farm_am", "bestxtimes", "bestxtime", "latest_im", "farm_Time", "better_times", "bestxtimer", "bestactime", "best_im", "bestvalprice", "featureianprice", "latestiantime", "bestiancontent", "bestlyspace", "bestlytime", "best_price", "feature_price", "best_Time", "best2times", "best_size", "bestactimes", "best2Time", "latestiansize", "better_timer", "best_date", "best_space", "bestvaltime", "latestiantimer", "bestaccost", "farm_times", "farm_TIME", "latest_time", "bestacsize", "best2cost", "better_time", "bestiantime", "bestiansize"], "n": ["N", "e", "size", "d", "ns", "nd", "num", "i", "fn", "p", "j", "count", "r", "nt", "z", "t", "ni", "v", " N", "nn", "w", "m", "L", "l", "network", " c", "pn", "nb", "c", "s", "sn", "a", "k", "x", "nc", "y", "b", "ind", "f", "cn", "o", "P", "g", "nu"], "farm_time": ["fork_frequency", "fork_type", "fork_time", "fork_count", "fork_tim", "farm64duration", "farm6time", "farm___times", "farm_etime", "farm5timeout", "farm6times", "farm64times", "farmiantim", "fork_duration", "field_ime", "farm6value", "farmianfrequency", "fieldianetime", "fork_times", "farm_speed", "farmianetime", "fieldianspeed", "farm64tim", "farmianduration", "farm_ime", "farmianime", "farm_frequency", "farm___time", "farm___type", "farm_duration", "field_etime", "farm5speed", "farm64time", "farmiancount", "farm_timeout", "farm_count", "field_speed", "farm5etime", "farm_tim", "fork_timeout", "farm5times", "farm5value", "farmiantimes", "farm5time", "farm5ime", "fork_speed", "fieldianime", "farmiantime", "farm6timeout", "farm_times", "field_time", "farm___count", "fork_value", "farm_value", "farmianspeed", "farmiantype", "fieldiantime", "farm_type"], "cookie_time": ["best_max", "wheel_speed", "cookie_speed", "wheel_time", "cookielTIME", "cookieianTIME", "cookie_max", "cookie_type", "cookieltime", "best_type", "farm_times", "farm_TIME", "wheel_times", "cookieiansleep", "cookieiantimes", "cookieltimes", "farm_sleep", "best_times", "cookie_times", "cookie_TIME", "cookieiantime", "wheel_price", "cookie_price", "cookielsleep", "cookie_sleep"], "infile": ["insfiles", "outFile", "outline", " infolder", "inputfilename", " inf", " inFile", "inline", "Instream", "inputstream", " instream", "Infilename", " instring", "inputstring", "infilename", "INfile", "outfilename", "insfilename", "INfiles", "infolder", "instream", "inputFile", "INfilename", "INfolder", "INFile", "InFile", "Infile", "outfiles", "infiles", "inf", "instring", "Inline", "insfile", "outstring", "insstream", " inline", "INstring", "outstream", "Infolder", "INstream", "Inf", " infilename", "inFile", "INf", "inputfile"], "self": ["ws", "name", "proxy", "Self", "mp", "case", "object", "http", "ls", "wx", "c", "parent", "worker", "node", "P", "resp", "event", "pos", "plus", "instance", "_", "cs", "w", "es", "l", "os", "plugin", "all", "s", "x", "false", "tmp", "f", "user", "e", "full", "client", "p", "lf", "now", "config", "context", "master", "host", "sys", "error", "layer", "public", "m", "function", "data", "acl", "new", "result", "this", "other", "ng", "load", "ctx", "proc", "results", "cmp", "h", "view", "me", "r", "ref", "spec", "part", "session", "q", "cl", "func", "cache", "work", "python", "k", "reader", "g", "wrapper"], "fname": ["foldname", "lfame", "lfname", "foldame", "lfnom", "outName", " fword", "cname", "outword", "outpath", "fnom", " fame", "fword", "lffile", "fName", "cword", " fnom", "fame", "cpath", "foldfile", " fName", " ffile", "cName", "foldnom", "fpath", " fpath", "ffile"], "NumCases": ["numCases", "numCAS", "NumCances", "numCatches", "Numcatches", "NumCASE", "NumOccases", "numcase", "NumScASE", "numChAS", "NumChases", "NumCatches", "NumScases", "NumChainases", "NumChainASE", "numCASE", "NumOccances", "Numcances", "NumOccase", "NumChase", "Numcases", "NumCAS", "NumCase", "NumChASE", "numChASE", "numcatches", "numCances", "numCase", "numcases", "NumScAS", "NumScase", "NumChAS", "Numcase", "NumChainAS", "numChases", "NumOccatches", "numChase", "numcances", "NumChainase"], "caseNum": ["codenum", "trialNumber", "codeNumber", "aceNUM", "trialName", "CaseNumber", "CaseNo", "acenum", "codeCounter", "trialnum", "trialNum", "chanceNo", "caseNo", "caseCounter", "casenum", "CaseTon", "aceNo", "CaseNum", "chancenum", "chanceTon", " casenum", "Casenum", "aceNum", "caseTon", "CaseName", "CaseNUM", "caseName", "CaseCounter", "caseNUM", " caseTon", " caseNo", " caseName", " caseNUM", "caseNumber", " caseNumber", " caseCounter", "codeNum", "chanceNum"], "args": ["Args", "params", "gs", "vals", "flags", "extra", "ay", "iq", "pos", "stats", "qa", "str", "words", "doc", "ras", "xml", "arg", "config", "Arg", "arr", "gu", "ai", "_", "icks", "GS", "long", "aux", "cs", "obj", "parse", "ae", "w", "dict", "atts", "axis", "py", "ass", "A", "ig", " arg", "data", "ams", "body", "au", "all", "new", "a", "parts", "abs", " arguments", "items", "blank", "call", "ix", "limits", "other", "lines", "argument", "array", "chain", "ax", "objects", "abc"], "myCases": ["myCsases", "MYCsASE", "myCsASE", "MyCased", "MYCsases", "MyCase", "mycases", "myAcase", "mycase", "MyChases", "myChase", "myAcases", "myAcats", "MyCats", "MyChase", "myCASE", "myAcASE", "MyChats", "mycased", "myAcased", "mycASE", "myCsased", "MYCase", "MyCases", "myChased", "myChats", "MYCases", "MYCASE", "MYCsased", "myCats", "MYCsase", "myChases", "myCsase", "MYCased", "myCased", "mycats", "MyChased", "myCase"], "outname": ["outline", "Outfilename", "outsize", " outline", " outfilename", "inpath", "inline", "outputline", "againbase", "Outline", "outName", "outbase", "Outname", "OutName", "outputfile", "infilename", "insize", "outfilename", " outpath", "Outfile", "outpath", "upName", "upname", "upline", "Outpath", "upfile", "againsize", "againname", "outputpath", "againName", " outName", " outbase", "inName", "inname", "againfile", "inbase", " outsize", "outputname"], "oldout": ["oldname", "OLDOUT", "newname", " oldOut", "oldOUT", "newin", "olderOut", "oldername", "olderexp", "OLDout", "newout", "OLDOut", "OldOut", "olderin", "Oldname", "oldpassword", "oldOut", "Oldin", "olderpassword", "OldOUT", "newOut", "olderout", "Oldexp", "newOUT", " oldin", " oldOUT", "newpassword", " oldname", "oldin", " oldpassword", "Oldout", " oldexp", "oldexp"], "ii": ["gi", "si", "ini", "xi", "ali", "ori", "hi", "id", "i", "mini", "abi", " iii", "agi", "fi", "vi", "iii", "zi", "li", "pi", "ai", "ui", "ni", "ili", "cu", "ci", "iz", "index", "ice", "ei", "inf", "di", "ti", "ani", "ji", "ien", " bi", "lu", "ind", "II", "zie", "uni", "chi", "eni", "qi"], "outfile": ["outFile", " outfilename", " outfil", "offfilename", "Outname", "infilename", "outfilename", " outpath", "Inname", "Outfile", "outpath", "offfile", "Inpath", "OutFile", "InFile", "Infile", "Outpath", "offfil", "offFile", "inFile", " outFile", "infil", "outfil"], "iCase": ["oiTest", "oiPlace", "iCondition", "ICondition", "eiCase", "oiCase", " iExample", " iGame", "iPlace", " iPlace", "chiCase", "chiGame", "ITest", "siCondition", " iCode", "iExample", "chiExample", "ICode", "iTest", "iGame", " iCondition", "siCode", "IPlace", "iCode", "ICase", " iTest", "siCase", "eiGame", "eiExample"], "answer": ["update", "ave", "default", "score", "edit", "swers", "ee", "altern", "next", "address", "exit", "ace", "answered", " answers", "offer", "question", "acc", "response", "output", "comment", "random", "string", "ell", "example", "ae", "feed", "respond", "equ", "grade", "say", "order", "air", "au", "average", "issue", "all", "empty", "new", "fix", " Answer", "a", "blank", "result", "message", "reply", "argument", "err", "array", "option", "Answer"]}}
{"code": "\\n  def Fill(outmat,R,C,F):\\n      nF=F\\n      outmat[:2,:2]='.'\\n      nF-=4\\n      if nF==0: return\\n  \\n      outmat[2,:2]='.'\\n      nF-=2\\n      if nF==0: return    \\n  \\n      outmat[:2,2]='.'\\n      nF-=2\\n      if nF==0: return\\n  \\n      for iC in xrange(3,C):\\n          if nF==1:\\n              outmat[2,2]='.'\\n              return\\n          outmat[:2,iC]='.'\\n          nF-=2\\n          if nF==0: return\\n          \\n      for iR in xrange(3,R):\\n          if nF==1:\\n              outmat[2,2]='.'\\n              return\\n          outmat[iR,:2]='.'\\n          nF-=2\\n          if nF==0: return\\n  \\n      for iR,iC in ( (iR,iC) for iR in xrange(2,R)\\n                     for iC in xrange(2,C)):\\n          outmat[iR,iC]='.'\\n          nF-=1\\n          if nF==0: return\\n      \\n  \\n  \\n  \\n  def Solve(R,C,M):\\n      F=R*C-M\\n      if F==0: return '\\nImpossible'\\n      if (R>1 and C>1 and F in (2,3)):\\n          return '\\nImpossible'\\n  \\n      outmat=np.zeros( (R,C), dtype='S1')\\n      outmat[:,:]='*'\\n  \\n      if R==1:\\n          for i in xrange(F):\\n              outmat[0][i]='.'\\n      \\n      elif C==1:\\n          for i in xrange(F):\\n              outmat[i][0]='.'\\n  \\n      elif F>1:\\n          if F in (2,3,5,7): return \"\\nImpossible\"\\n          elif (R==2 or C==2) and F%2 != 0:\\n              return \"\\nImpossible\"\\n          elif R==2:\\n              outmat[:,:F/2]='.'\\n          elif C==2:\\n              outmat[:F/2,:]='.'\\n          else: Fill(outmat,R,C,F)\\n          \\n      outmat[0,0]='c'\\n      outmatlines=[ ''.join(x) for x in outmat ]\\n      answer='\\n'+'\\n'.join(outmatlines)\\n  \\n      Verify(answer,F)\\n  \\n      return answer\\n  \\n  disp=[ (dx,dy) for dx in (-1,0,1)\\n      for dy in (1,0,-1) if (dx !=0 or dy!=0) ]\\n  \\n  def Verify(answer,F):\\n      lines=[list(x) for x in answer.split('\\n')]\\n      if len(lines[0])==0: lines.pop(0)\\n      R,C=len(lines),len(lines[0])\\n      assert lines[0][0]=='c'\\n      assert answer.count('.')+1==F\\n      q=Queue.Queue()\\n      q.put( (0,0) )\\n  \\n      def adjToMine(x,y):\\n          for dx,dy in disp:\\n              if 0<=x+dx<R and 0<=y+dy<C:\\n                  if lines[x+dx][y+dy]=='*': return True\\n          return False\\n                  \\n  \\n      while not q.empty():\\n          x,y=q.get()\\n          for dx,dy in disp:\\n              if 0<=x+dx<R and 0<=y+dy<C:\\n                  if lines[x+dx][y+dy]=='c': continue\\n                  lines[x+dx][y+dy]='c'\\n                  if not adjToMine(x+dx,y+dy):\\n                      q.put( (x+dx,y+dy) )\\n  \\n      clicked='\\n'.join([ ''.join(x) for x in lines])\\n      if clicked.find('.')>=0:\\n          print '\\n','*'*20,\"\\nERROR, input:\"\\n          print answer\\n          print 'OUTPUT:'\\n          print clicked\\n      \\n  \\n  \\n  \\n  def parse(infile):\\n      R,C,M=map(int, infile.readline().split() )\\n      return R,C,M\\n  \\n  \\n  \\n  class GCJ_Parser( object ):\\n      def __init__(self,fname):\\n          self.infile=open(fname,'r')\\n          self.NumCases=int(self.infile.readline().strip() )\\n          self.caseNum=0\\n  \\n      def __iter__(self): return self\\n  \\n      def next(self):\\n          if self.caseNum==self.NumCases: raise StopIteration\\n          self.caseNum += 1\\n          args=parse(self.infile)\\n          return self.caseNum , args\\n  \\n  \\n  def runmain():\\n      myCases=GCJ_Parser(sys.argv[1])\\n  \\n      outname=sys.argv[1].rstrip('.in')+'.out'\\n      if os.path.isfile(outname):\\n          oldout=outname+'.old'\\n          ii=0\\n          while os.path.isfile(oldout):\\n              ii+=1\\n              oldout=outname+'.old'+str(ii)\\n          os.rename(outname,oldout)\\n          print 'Rename: %s -> %s'%(outname,oldout)   \\n   \\n      outfile=open(outname,'w')\\n  \\n      for iCase, args in myCases:\\n          answer=Solve(*args)\\n  \\n          print 'Case #'+str(iCase)+':',answer\\n          print >> outfile, 'Case #'+str(iCase)+':',answer\\n  \\n  \\n  \\n  \\n  if __name__=='__main__':\\n      runmain()\\n", "target": "16", "substitutes": {"outmat": ["Outcat", "OUTflat", "Outmot", "againmat", "upformat", "againMat", "OUTmot", "upmat", " outmath", "incat", "outcat", "outmol", "againmol", "againcat", "againmath", "outflat", "outformat", "offmat", "outmot", "outputmol", "inmol", "inmat", "againlat", "outputlat", "resultmol", "offcat", "OUTmult", "OUTMat", " outlat", " outformat", "atmat", " outmot", "atmol", "outmath", "Outmat", "OUTmol", "OUTlat", "inmult", "outmatch", "outlat", "inmath", "outputcat", "atcat", "outputMat", "offmol", "OutMat", "resultmat", " outMat", "outputmatch", "Outformat", "Outmath", "OUTmat", "resultMat", "outputmat", "againformat", " outmatch", "atmath", " outcat", "OUTformat", "resultmult", "Outmol", "outmult", "upmatch", "inflat", "outMat", "againflat", "againmult", "upmol", "informat", "offmatch", "OUTmath", " outmult", "Outmult", "Outlat", "inMat", "outputformat", "outputmot", " outmol", "againmot", "againmatch"], "R": ["N", "Rh", "TR", "AR", "U", "RH", "G", "X", "Rank", "RL", "RE", "O", "RR", "KR", "I", "MR", "r", "W", "Rs", "Range", "K", "HR", "RC", "RW", "SR", "RO", "RN", "Right", "Re", "Ro", "L", "D", "A", "UR", "JR", "T", "OR", "B", "RS", "Rec", "S", "BR", "RP", "CR", "E", "H", "Br", "IR", "V", "DR", "RF", "RM", "GR", "Run", "WR", "Y", "Ra", "NR", "Q", "P", " r", "RA", "RG"], "C": ["N", "JC", "Cs", "U", "G", "Ch", "Cor", "SC", "X", "Cu", "O", "CL", "I", "CNN", "CA", "W", "YC", "Cl", "CM", "VC", "K", "CE", "EC", "Three", "NC", "DC", "GC", "CW", "Ca", "CC", "L", "Sc", "D", "A", "T", "B", " c", "S", "FC", "c", "KC", "CV", "Or", "CR", "E", "H", "AC", "CS", "CI", "V", "CU", "Y", "P", "CT", "Con", "Cr"], "F": ["N", "cf", "CF", "U", "Fixed", "G", "Fs", "FD", "X", "TF", "DF", "J", "OF", "O", "I", "If", "IF", "FB", "W", "FL", "File", "Fl", "Z", "EC", "K", "Fit", "Fi", "L", "Family", "D", "A", "EF", "FO", "GF", "FH", "PF", "B", "T", "S", "FC", "FA", "FR", "WF", "new", "FE", "CR", "E", "H", "Fine", "Fun", "V", "FF", "Y", "ELF", "Q", "P", "IO", "f", "FG", "Far", "AF", "Fe"], "nF": ["unFile", "nM", "cnM", "nU", " nQ", "nC", "wf", "noneFamily", "nwF", "nV", "neC", "nwf", "unQ", "wL", "Nf", "iF", "fnV", "fnU", " nFamily", "pf", "nEF", "pnL", "lG", " nEF", " nC", " nG", "nFile", " nU", " nL", "lD", "nELF", "ND", "NOF", " nW", "connFile", "lnH", " nM", "NE", "ynD", "NC", "NV", "cnF", " nf", "nanOF", "lnQ", "iE", "noneF", "lnEF", "ynL", "dnD", "unF", " nV", "connF", "unFamily", "nanFamily", "neF", "lC", "NFile", "nW", "connE", " nH", "wW", "nwL", "lnE", "nL", "unC", "NELF", "ynF", "fnD", "dnFamily", "lFamily", " nD", "nwW", "dnF", "NL", "nanF", "neD", "unD", "nQ", "lnf", "nf", "pEF", "cnf", "fnF", "dnC", "pE", "ynELF", "lnFamily", "lnF", "fnC", "pnF", " nFile", "fnf", "nE", "nH", " nOF", "pF", "unH", "noneV", "NM", "wF", "neU", "NF", "connf", "fnE", "nanC", "nFamily", "noneE", "pnD", " nE", "pnELF", "lF", "neG", "cnE", "nOF", "NFamily", "iFile", "nG", "nanE", "nD", "nanQ"], "iC": ["iN", "eniF", "biC", " iCs", "biM", "iM", "aC", "iuM", " iT", "aU", "liDC", " iM", "siM", "iiM", "niN", " iDC", "iCNN", " iL", "iL", "iuC", "aM", "iiR", "niR", "jC", "iCs", "iF", "jR", "aF", "iiF", "iDC", "iU", "siU", "siC", "niL", "jM", "liF", " iN", "biT", "eniCNN", "eniDC", "iSc", "iiN", " iF", "iT", "iuR", "iiU", "niCs", "liCNN", "iuSc", "siR", "jT", "siL", " iCNN", "biR", "siCs", "liC", "aR", "iiC", "niM", "aSc", "eniC", " iSc", "siF", "niC"], "iR": ["iN", "cAr", "biC", "siRs", "pR", "biM", "iM", "siN", "uC", "aiB", " iM", "aiC", "siM", "uM", "iRh", "cC", "iiR", "iB", "iAr", " iB", "jC", "jR", "pRs", " iG", "siC", "siG", " iN", "iRs", "ciC", "ciN", "siRh", "aiR", "biRs", "jRs", "pC", "siAr", " iRs", "cB", "iiRs", "uR", "pM", " iAr", "jRh", "aiAr", "ciR", " iRh", "cR", "uRs", "siR", "ciRs", "biR", "ciAr", "iG", "iiC", "ciM", "iiG"], "M": ["N", "U", "G", "X", "MI", "J", "I", "MR", "W", "MS", "Z", "CM", "K", "m", "MN", "L", "D", "OR", "A", "MC", "T", "B", "c", "E", "H", "V", "RM", "Y", "Q", "P", "MM", "MF"], "i": ["e", "si", "ini", "xi", "d", "mi", "id", "p", "j", "ar", "I", "u", "im", "z", "r", "ie", "t", "pi", "ai", "it", "v", "li", "multi", "ni", "io", "m", "n", "ci", "l", "index", "ti", "c", "int", "a", "ic", "phi", "iu", "b", "f", "qi"], "outmatlines": ["outmatline", "outMatlin", "outcatline", "OutMatlines", "outMatlines", "out_line", "out_lin", "outmatlin", "outcatlines", "Outmatlines", "OutMatline", "out_lines", "outcatlin", "Outmatlin", "outMatline", "Outmatline", "OutMatlin"]}}
{"code": "for i in range(int(input())):\\n  \\n      c, f, x = tuple(map(float, str.split(input())))\\n  \\n      base_time = 0.0\\n      base_rate = 2.0\\n      farms_count = 0\\n      best_time = None\\n  \\n      current_time = base_time + x / (base_rate + farms_count * f)\\n  \\n      while best_time is None or best_time > current_time:\\n  \\n          best_time = current_time\\n          base_time += c / (base_rate + farms_count * f)\\n          farms_count += 1\\n  \\n          current_time = base_time + x / (base_rate + farms_count * f)\\n  \\n      print(str.format(\"Case #{}: {}\", i + 1, best_time))\\n", "target": "17", "substitutes": {"i": ["e", "gi", "si", "xi", "id", "abi", "p", "j", "I", "start", "u", "zi", "z", "multi", "li", "pi", "ai", "ui", "t", "v", "cli", "field", "uri", "n", "ci", "index", "ei", "bi", "di", "ti", "int", "a", "phi", "ix", "y", "iu", "ind", "uni", "chi", "qi"], "c": ["e", "cf", "size", "d", "h", "C", "p", "max", "u", "count", "r", "z", "t", "v", "w", "cy", "q", "n", "ci", "m", "l", "xc", "base", "cc", "s", "time", "a", "nc", "y", "b", "con", "fc", "cm", "o", "lc"], "f": ["e", "cf", "fd", "d", "fr", "fac", "h", "xf", "bf", "p", "fx", "u", "af", "count", "r", "t", "file", "tf", "form", "fb", "v", "of", "field", "feed", "fit", "sf", "m", "n", "l", "rf", "fp", "inf", "fs", "time", "df", "frame", "F", "fe", "y", "b", "fc", "frequency", "g"], "x": ["e", "size", "xs", "d", "plus", "X", "h", "xf", "p", "fx", "xes", "u", "z", "r", "rx", "t", "number", "cross", "v", "w", "q", "n", "m", "l", "ex", "fast", "inf", "xc", "time", "a", "xx", "ix", "y", "b", "g"], "base_time": ["best_rate", " base___year", "base1rate", "current_cost", "base___tim", "base_cost", "base67time", "best_timer", "base1size", "base67rate", "base2time", "base_times", "base_size", " base___rate", "base_timer", "base67source", "current_times", "base5rate", "base1time", "base___year", "base5size", " base___time", "base2cost", "base___time", "base2timer", "current_source", "base5time", "base_tim", "base_year", "best_size", "current_timer", "current_rate", "base67times", " base_year", " base_tim", "base_source", "base___rate", "base5timer", "base2times", " base___tim", "base1timer"], "base_rate": ["ase_speed", "best_rate", "core_wave", "basewaverate", "base__speed", "base_shape", "fixed_rating", "basewaveshape", "base__time", "base__grade", "core_rates", "base_speed", "basewavespeed", "ase_shape", "ase_rating", "core_time", "base_rates", "basewaverating", "base_grade", "fixed_time", "fixed_rate", "core_rate", "best_grade", "ase_rate", "base_wave", "best_speed", "fixed_speed", "base_rating", "base__rate"], "farms_count": ["farms_length", "farms_size", "farms64count", "farm_rate", "farms_base", "farms_sum", "farms64size", "farmsacdepth", "farmsacbase", "farming_count", "farmsetcount", "farming_counter", "farms64rate", "farm_Count", "farm_base", "farm_length", "farmsetcounter", "farm_depth", "farmsaccount", "farm_count", "farm_size", "farmsetsize", "farms64sum", "farms_counter", "farming_sum", "farms_rate", "farmsetsum", "farm_sum", "farming_size", "farms_Count", "farms_depth"], "best_time": ["best1am", "best1times", "best_memory", "thisiantime", "best_money", "bestingmemory", "best_times", "better_length", "bestingtime", "better_size", "better_memory", "this_money", "best_am", "better_speed", "best___size", "this_count", "thisianmoney", "best_count", "bestacmoney", "better_date", "bestiantimes", "bestingtimes", "best1date", "bestingspeed", "better_times", "bestianmoney", "bestactime", "thisiancount", "better_Time", "bestiancount", "this_times", "better_am", "best_Time", "best_size", "bestactimes", "this_time", "best_date", "best___times", "best_length", "best_speed", "best___time", "thisiantimes", "better_time", "bestiantime", "best1time", "bestaccount"], "current_time": ["currentmcount", "best_clock", " current_date", " current_home", "best_times", "reported_length", "current_count", " current_rate", "current_live", "currentmcycle", "current_home", "current_times", "current_date", "reported_value", "current67live", "currentmtype", "current_cycle", "current64type", "current67time", "current_type", "current64time", "reported_depth", "next_time", "best_live", "next_type", "current67times", "next_count", "current67clock", "current_clock", "current_length", "current_value", "current_rate", "current_depth", "currentmtime", "next_cycle", "current64count", "current64cycle", "reported_time"]}}
{"code": "\\n  \\n  '''\\n  ...\\n  ...\\n  ...\\n  ...\\n  ...\\n  '''\\n  \\n  for i in range(int(input())):\\n  \\n      r, c, m = tuple(map(int, str.split(input())))\\n      count = r * c - m\\n      field = dict(map(lambda c: (c, \"*\"), itertools.product(range(c), range(r))))\\n      answer = \"Impossible\"\\n  \\n      if m == 0:\\n  \\n          answer = field\\n  \\n      elif 1 in (r, c):\\n  \\n          for p in itertools.islice(itertools.product(range(c), range(r)), count):\\n  \\n              field[p] = \".\"\\n  \\n          answer = field\\n  \\n      elif count in (0, 2, 3, 5, 7):\\n  \\n          pass\\n  \\n      elif count == 1:\\n  \\n          answer = field\\n  \\n      elif count // 2 < c or count == c * 2 + 1:\\n  \\n          if count % 2 != 0:\\n  \\n              tail = 3\\n              ncount = count - 3\\n  \\n          else:\\n  \\n              tail = 0\\n              ncount = count\\n  \\n          for x in range(ncount // 2):\\n  \\n              field[(x, 0)] = field[(x, 1)] = \".\"\\n  \\n          for x in range(tail):\\n  \\n              field[(x, 2)] = \".\"\\n  \\n          answer = field\\n  \\n      elif not (c == 2 and count % c == 1):\\n  \\n          for x in range(c):\\n  \\n              field[(x, 0)] = field[(x, 1)] = \".\"\\n  \\n          count -= 2 * c\\n          tail = 0\\n          if count % c == 1:\\n  \\n              tail = 2\\n              count -= 1\\n  \\n          y = 2\\n          while count > 0:\\n  \\n              rx = min(count, c)\\n              for x in range(rx):\\n  \\n                  field[(x, y)] = \".\"\\n  \\n              count -= rx\\n              y += 1\\n  \\n          for x in range(tail):\\n  \\n              field[(x, y)] = \".\"\\n  \\n          answer = field\\n  \\n      field[(0, 0)] = \"c\"\\n      print(str.format(\"Case #{}:\", i + 1))\\n      if isinstance(answer, dict):\\n  \\n          for y in range(r):\\n  \\n              print(str.join(\"\", map(lambda x: field[(x, y)], range(c))))\\n  \\n      else:\\n  \\n          print(answer)\\n", "target": "17", "substitutes": {"i": ["e", "si", "ini", "xi", "ip", "iq", "mi", "id", "mini", "slice", "j", "I", "u", "im", "z", "multi", "li", "pi", "ai", "ui", "v", "uri", "n", "ci", "ii", "index", "ice", "ti", "di", "int", "phi", "ix", "iu", "ind", "f", "eni"], "r": ["e", "range", "rr", "rb", "d", "rc", "h", "radius", "ur", "pr", "ar", "u", "er", "t", "v", "ir", "re", "cur", "w", "q", "n", "l", "rf", "R", "ru", "right", "g", "rh", "ro", "s", "a", "rn", "k", "rs", "sr", "nr", "b", "f", "cr", "o", "rar"], "c": ["e", "cf", "size", "mc", "d", "col", "rc", "h", "ac", "C", "dc", "coll", "ch", "ce", "max", "u", "ct", "z", "t", "co", "v", "cu", "rec", "cs", "w", "cy", "q", "vc", "n", "ci", "l", "uc", "g", "xc", "pc", "cc", "s", "cache", "unc", "a", "k", "ec", "cycle", "nc", "code", "sc", "b", "con", "f", "cm", "cr", "o", "arc", "cn", "fc", "lc"], "m": ["e", "range", "size", "mc", "d", "mi", "num", "h", "C", "more", "pm", "j", "length", "mr", "u", "mm", "z", "pi", "M", "number", "co", "v", "q", "n", "l", "mult", "dim", "b", "cm", "f", "o", "g"], "count": ["col", "name", "weight", "offset", "more", "case", "number", "race", "limit", "log", "index", "zip", "parent", "depth", "cm", "con", "ind", "range", "carry", "C", "ch", "current", "length", "z", "cond", "w", "allow", "type", "scroll", "n", "l", "all", "cc", "time", "call", "cycle", "process", "found", "code", "b", "f", "const", "e", "d", "default", "score", "id", "num", "match", "max", "v", "comment", "sum", "error", "loc", "conf", "core", "order", "ount", "key", "min", "cf", "size", "Count", "counter", "mc", "content", "len", "coll", "h", "ac", "list", "child", "force", "level", "q", "age", "flag", "value", "base", "cache", "catch", "null", "nc", "cr", "lc"], "field": ["upp", "manager", "man", "dd", "number", "object", "row", "box", "query", "equ", "seed", "fields", "index", "end", "cell", "custom", "cover", "option", "ground", "url", "table", "page", "range", "rule", "player", "word", "patch", "C", "attribute", "question", "condition", "_", "record", "type", "element", "only", "plugin", "all", "label", "fix", "test", "array", "f", "post", "user", "check", "e", "update", "d", "default", "id", "play", "document", "match", "input", "file", "form", "comment", "layer", "FIELD", "function", "the", "order", "data", "block", "model", "key", "result", "term", "format", "diff", "info", "size", "service", "pp", "Field", "list", "child", "force", "output", "group", "string", "source", "q", "variable", "entry", "value", "wire", "cache", "lib", "message", "line", "folder"], "answer": ["name", " answering", " explanation", "address", "number", "query", "equ", "knowledge", "fill", "parent", "install", "cover", "reply", "err", "option", "Answer", "evidence", " answered", "swers", "player", "arel", "attribute", "ace", "question", "margin", "ell", "edge", "replace", "video", "issue", "fix", "array", "area", "eni", "update", "score", "document", "answered", "fake", "response", "form", "entity", "comment", "error", "side", "example", "grade", "say", "expression", "order", "metadata", "result", "term", "size", "memory", "ee", "correct", "archive", " answers", "after", "image", "offer", "output", "string", "practice", "source", "audio", "value", "average", "cache", "energy", " Answer", "description", "message", "fee"], "p": ["proc", "e", "ip", "d", "col", "pos", "pp", "patch", "h", "pm", "j", "u", "like", "z", "t", "get", "pi", "v", "w", "pre", "q", "n", "np", "py", "l", "fp", "ach", "param", "pn", "pc", "int", "a", "pe", "ph", "lp", "python", "code", "P", "b", "f", "post", "o", "cp", "g"], "tail": ["size", "stop", "col", "weight", "offset", "act", "ail", "len", "coll", "patch", "slice", "unit", "width", "length", "start", "child", "tag", "li", "number", "condition", "t", "left", "lead", "pull", "sum", "row", "margin", "loc", "position", "type", "limit", "n", "thread", "support", "l", "index", "local", "body", "sync", "zip", "batch", "all", "cache", "tc", "wrap", "end", "head", "sn", "test", "collection", "lex", "tick", "cycle", "line", "target", "call", "run", "code", "term", "ind", "chain", "tails", "span", "lc"], "ncount": ["nlength", "ccall", "Nlimit", "nncoll", "Nsize", "ncoll", "ltail", "nnlength", "llength", "ccount", "lsize", " nlimit", "ncall", "dtail", "lcall", "nlimit", "nncount", "zcall", "zcount", "ntail", "lcoll", "nsize", "clength", "dlength", "lcount", "zlength", "dcoll", "nntail", "dcount", "llimit", "Ncount", " nsize"], "x": ["xs", "xt", "name", "col", "px", "sex", "xp", "exp", "row", "index", "ice", "xc", "wx", "any", "php", "xxxx", "xe", "xx", "ax", "search", "my", "plus", "ww", "X", "z", "tx", "w", "n", "l", "s", "time", "pe", "ic", "code", "b", "f", "o", "check", "e", "full", "xa", "d", "self", "id", "num", "xy", "j", "xes", "t", "cross", "yx", "co", "v", "on", "el", "g", "one", "key", "xi", "ux", "h", "xf", "view", "u", "ct", "q", "ex", "xxx", "work", "int", "lex", "k", "ix", "no", "es"], "y": ["e", "ny", "ys", "yr", "zy", "d", "col", "yy", "isy", "ay", "id", "h", "yt", "ye", "sy", "j", "xy", "u", "year", "z", "ty", "t", "get", "v", "ym", "yl", "w", "cy", "type", "q", "oy", "n", "py", "l", "yi", "iny", "key", "ey", "dy", "a", "python", "ry", "ya", "yn", "vy", "Y", "code", "b", "yd", "f", "o"], "rx": ["size", "rr", "rb", "col", "act", "xxxxxxxx", "rc", "coll", "radius", "width", "mx", "cross", "tx", "co", "push", "lr", "pull", "rw", "rec", "ra", "circ", "loc", "limit", "n", "core", "rf", "index", "R", "rss", "ex", "rh", "wx", "sync", "rt", "rl", "lex", "ry", "rs", "cycle", "nc", "min", "rd", "nr", "ri", "fc", "cr", "lc", "abc"]}}
{"code": "\\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  def debug(*args):\\n      print(*args, file=sys.stderr)\\n  \\n  fin = sys.stdin\\n  T = int(fin.readline())\\n  for case in range(1, T + 1):\\n      C, F, X = map(float, fin.readline().split())\\n  \\n  \\n      rate = 2\\n      time = 0\\n  \\n      best = 10**20\\n  \\n      while time < best:\\n          result = X / rate + time\\n          if result < best:\\n              best = result\\n          time += C / rate\\n          rate += F\\n  \\n  \\n  \\n      print(\"Case #%d: %.7f\" % (case, best))\\n  \\n", "target": "18", "substitutes": {"fin": ["proc", "ini", "br", "rb", "fd", "tun", "fr", "i", "fn", "dev", "len", "lo", "thin", "done", "fi", "rin", "en", "conn", "inner", "start", "dir", "file", "fb", "util", "spec", "die", "lin", "FIN", "Fin", "div", "inv", "iter", "prof", "fp", "fine", "inf", "ln", "lib", "bin", "init", "inn", "fat", "f", "raf", "fen", "req", "info", "nu", "fa"], "T": ["N", "U", " trial", "TN", "Time", "O", "I", "TS", "TB", "t", "M", "Z", "TH", "L", "WT", "D", "Case", "R", "B", "S", "TT", "TC", "E", "test", "V", " t", "Y", "Q", "P"], "case": ["size", "loop", "name", "num", " trial", "section", "cas", "length", "ace", "match", "complete", "instance", "count", "ase", "cases", " test", "nce", "CE", "race", "rice", "core", "seq", "Case", "ice", " c", "c", "test", "chance", "x", " suite", "line", "course", "site", "est", " CASE", "code", "f", "EST", "trial"], "C": ["N", "CF", "Count", "U", "G", "Cu", "Time", "CL", "I", "CA", "count", "W", "M", "EC", "K", "DC", "CC", "L", "D", "A", "R", "B", "S", "CO", "c", "CV", "E", "CS", "ACE", "CI", "V", "CU", "Y", "Q", "P"], "F": ["N", "CF", "U", "G", "FD", "TF", "Time", "OF", "O", "FT", "I", "W", "BF", "M", "Z", "K", "L", "D", "A", "FO", "R", "EF", "PF", "B", "GF", "FH", "FA", "FC", "FE", "Fine", "E", "H", "FU", "V", "FF", "Y", "Q", "P", "f", "FG", "frequency", "AF"], "X": ["N", "CF", "U", "CH", "XL", "G", "Time", "XP", "XXX", "CL", "TX", "W", "Z", "EC", "K", "CE", "XT", "RC", "CC", "L", "D", "R", "B", "S", "TC", "CV", "E", "H", "CI", "x", "V", "FF", "XY", "Y", "Q", "P", "XX", "PE"], "rate": ["rating", "size", "ave", "speed", "rand", "rule", "score", "correct", "rated", "rc", "Time", "ride", "Rate", "force", "count", "r", "root", "currency", "error", "date", "race", "prime", "rice", "feed", "trace", "sample", "core", "rank", "age", "grade", "seed", "order", "peed", "rates", "erate", " frequency", "FE", "CR", "dy", "use", "test", "depth", "cycle", " speed", "delay", "est", "code", "cost", "err", "con", " grace", "frequency", "cr", "cale", "trial", "scale"], "time": ["size", "stop", "speed", "U", "duration", "event", "ac", "Time", "ime", "ace", "max", "start", "complete", "trial", "count", "force", "r", "change", "t", "Z", " Time", "error", "date", "race", "trace", "type", "TIME", "CC", "grade", "live", "order", "fast", "times", "c", "progress", " times", "FE", "end", "factor", "stage", "test", "depth", "cycle", "x", "course", "timer", "est", "cost", "Q", "f", "frequency", "timeout", "scale"], "best": ["perfect", "size", "loop", "rand", " worst", "good", "highest", "score", "correct", "final", " fastest", "std", "p", "max", "ale", "start", "instance", "r", "master", "peak", "largest", " Best", "top", "race", "trace", "rank", "valid", "live", " newest", "order", "right", "fast", "last", "times", "better", "progress", "Best", "winner", "new", "end", "round", "pe", "success", "test", "depth", "x", "est", "worst", "latest", " winner", "cost", "aster", "trial", "scale"], "result": ["results", "duration", "event", "default", "score", "distance", "correct", "final", "feature", "current", "match", "complete", "ride", "future", "r", "master", "error", "race", "rice", "trace", "rank", "core", "grade", "D", "valid", "R", "order", "data", "runner", "better", "progress", "round", "success", "test", "Result", "catch", "mate", "worst", "cost", "f", "diff", "trial"]}}
{"code": "\\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n   \\n  \\n  \\n  \\n  \\n  def debug(*args):\\n      print(*args, file=sys.stderr)\\n  \\n  fin = sys.stdin\\n  T = int(fin.readline())\\n  for case in range(1, T + 1):\\n      RR, CC, M = map(int, fin.readline().split())\\n      R, C = None, None\\n      blocks = RR*CC - M\\n      inverse = False\\n      if RR > CC:\\n          inverse = True\\n          R, C = CC, RR\\n      else:\\n          R, C = RR, CC\\n      result = None\\n      if R == 1:\\n          result = [('.' * blocks) + ('*' * M)]\\n      elif R == 2:\\n          if blocks == 1:\\n              result = ['.' + ('*' * (C-1)), '*' * C]\\n          elif blocks % 2 == 0 and blocks != 2:\\n              cc = blocks // 2\\n              result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \\n          else:\\n              result = None\\n      else:\\n          if blocks == 1:\\n              result = ['*' * C] * R\\n          elif blocks == 4:\\n              result = ['..' + (C-2)*'*']*2\\n              result += ['*'*C] * (R-2)\\n          elif blocks == 6:\\n              result = ['...' + (C-3)*'*']*2\\n              result += ['*'*C] * (R-2)\\n          for rows in range(3, R+1):\\n              for columns in range(rows, C+1):\\n                  size = rows * columns\\n                  if size - blocks >= 0:\\n                      if size - blocks <= columns - 2: \\n                          result = []\\n                          for r in range(rows):\\n                              if r < rows - 1:\\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\\n                              else:\\n                                  cc = columns - (size - blocks)\\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\\n                          for r in range(R - rows):\\n                              result.append('*' * C)\\n                      elif size - blocks == columns - 1 and rows >= 4:\\n                          result = []\\n                          for r in range(rows):\\n                              if r < rows - 2:\\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\\n                              elif r == rows - 2:\\n                                  cc = columns - 1\\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\\n                              else:\\n                                  cc = 2\\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\\n                          for r in range(R - rows):\\n                              result.append('*' * C)\\n                      \\n  \\n  \\n  \\n      print(\"Case #%d: \" % (case))\\n      if result is None:\\n          debug('impossible', blocks, RR, CC)\\n          print(\"Impossible\")\\n      else:\\n          mines = 0\\n          for r in range(RR):\\n              row = ''\\n              for c in range(CC):\\n                  rr, cc = r, c\\n                  if inverse:\\n                      rr, cc = c, r\\n                  if rr == 0 and cc == 0:\\n                      row += 'c'\\n                  else:\\n                      row += result[rr][cc]\\n                      if result[rr][cc] == '*':\\n                          mines += 1\\n              print(row)\\n          if mines != M:\\n              raise Exception(\"%d != %d %d x %d\" % (mines, M, RR, CC))\\n              \\n  \\n  \\n", "target": "18", "substitutes": {"fin": ["ini", "br", "rb", "fd", "tun", "fr", "fn", "len", "h", "lo", "thin", "rin", "fi", "en", "conn", "inner", "su", "file", "serv", "util", "die", "lin", "FIN", "Fin", "div", "inv", "iter", "fit", "kin", "el", "os", "ran", "fp", "inf", "fine", "ln", "bin", "init", "inn", "fat", "f", "raf", "fen", "tin", "nu", "fa"], "T": ["N", "TR", "X", "TF", "TN", "Time", "O", "TS", "TB", "W", "t", "Z", "K", " N", "TH", "L", "D", "B", "S", "TT", "TC", "time", "E", "H", "F", "V", " t", "Y", "Q", "P", "RT", "CT"], "case": ["e", "d", "num", "X", "p", "section", "length", "ace", " time", "cases", "v", "seq", "ice", "cor", "B", "times", "bc", "tc", "TC", "end", "sec", "time", "test", "line", "b", "P", "trial"], "RR": ["Rh", "TR", "RH", "RL", "CCC", "RD", "MR", "RB", "Rs", "HR", "RC", "DC", "RW", "SR", "RO", "RN", "JR", "RS", "RP", "CV", "CR", "IR", "DR", "RF", "RM", "GR", "WR", "NR", "ARR", "RT", "LR", "RA", "RG"], "CC": ["CF", "CH", "UC", "X", "SC", "WC", "CL", "CNN", "CA", "LC", "NC", "EC", "CM", "VC", "CE", "GG", "PC", "GC", "DC", "RC", "CP", "CON", "CW", "Z", "BC", "MC", "RS", "CD", "FC", "CO", "CV", "TC", "CR", "AC", "OC", "CB", "RM", "FF", "XX", "MM", "CT", "CCC"], "M": ["N", "U", "G", "MI", "O", "LM", "MOD", "CL", "CNN", "I", "MR", "W", "TM", "MD", "MS", "CM", "K", "RC", "DC", "m", "MN", "L", "OM", "D", "A", "MC", "B", "DM", "S", "IM", "AC", "H", "F", "V", "RM", "Y", "Q", "P", "MM", "MF", "CCC"], "R": ["N", "Rh", "TR", "U", "RH", "G", "X", "Co", "RL", "Block", "RD", "I", "MR", "RB", "W", "Rs", "Range", "K", "RC", "RW", "SR", "RO", "RN", "Right", "L", "D", "A", "JR", "B", "RS", "right", "S", "BR", "RP", "CR", "E", "H", "IR", "F", "RF", "DR", "V", "RM", "GR", "Run", "Y", "NR", "Q", "P", "RT", "LR", "RA", "RG"], "C": ["N", "WC", "CE", "K", "CON", "HC", "Q", "P", "CT", "Cs", "X", "Cu", "CL", "CNN", "W", "YC", "NC", "Cl", "EC", "CM", "VC", "DC", "L", "Sc", "CO", "F", "CCC", "JC", "CF", "U", "G", "Ch", "SC", "Co", "Control", "Size", "RC", "CW", "BC", "A", "CN", "S", "CR", "E", "H", "AC", "V", "Y", "Count", "Length", "O", "CA", "Z", "GC", "Right", "D", "MC", "B", "CV", "CS", "CI", "CU", "Code"], "blocks": [" Blocks", "units", "N", "heads", "jobs", "events", " results", "RESULTS", "words", "outs", "cases", "errors", "TM", "Rs", "values", "K", "types", "pages", "packages", "ins", "times", "checks", "frames", "bc", "balls", "CB", "Blocks", "BL", "runs", "rules", "cb", "X", "length", "features", "W", "maps", "bars", "nos", "n", "L", "plugins", "pieces", "breaks", "ks", "s", "F", "bs", "modules", "b", "steps", "ops", "classes", "Block", "levels", "planes", "MS", "cells", "PC", "CW", "BC", "bits", "days", "locks", "S", "block", "files", "limits", "lines", "boxes", "bytes", "results", "rons", "cl", "MC", "B", "RS", "groups", "ions", "cycles", "items", "flows", "users", "chains", "control", "quarters"], "inverse": ["outverse", "Invert", "uninclude", "INclude", "Inverted", "INverse", "inreverse", "Inreverse", "uninverted", "outvert", "outreverse", "inverted", "insvert", "INverted", "include", "Include", "INreverse", "uninverse", "outverted", "insverse", "uninreverse", "Inverse", "insreverse", "insverted", "invert"], "result": ["math", "json", "package", "ret", "complete", "filter", "number", "attr", "pack", "details", "err", "search", "url", "table", "rules", "page", "params", "compl", "event", "rule", " Result", "current", "product", "length", "features", "desc", "status", "res", "root", "record", "method", "replace", "valid", "rest", "df", "test", "color", "buffer", "found", "array", "reason", "default", "account", "true", "match", "config", "master", "response", "comment", "summary", "error", "date", "grade", "function", "data", "block", "Result", "success", "Results", "diff", "answer", "info", "results", "memory", "final", "coll", "view", "list", "output", "report", "group", "source", "dict", "follow", "runner", "func", "cache", "round", "use", "description", "catch", "message"], "cc": ["cf", "ucc", "mc", "ced", "weight", "cb", "rc", "content", "coll", "ac", "lv", "dc", "length", "cv", "ce", "ll", "count", "ct", "acc", "cca", "cases", "kk", "mm", "cells", "co", "CE", "PC", "RC", "DC", "cs", "inc", "loc", "uc", "sq", "ci", "rank", "cl", "ca", "cci", "cd", "FC", "ff", "block", "pc", "bc", "sec", "anc", "tc", "cell", "shape", "ec", "nc", "code", "sc", "con", "ck", "fc", "cm", "cr", "cost", "cp", "control", "lc"], "rows": ["heads", "xs", "events", "col", "errors", "cases", "values", "types", "pages", "rank", "ins", "rss", "rh", "times", "checks", "frames", "end", "orders", "runs", "ries", "rules", "qs", "length", "features", "count", "_", "DC", "cs", "n", "breaks", "ks", "all", "s", "rs", "x", "OWS", "d", "rc", "p", "sections", "planes", "cells", "vers", "keys", "lines", "sc", "boxes", "results", "members", "h", "ows", "forms", "rown", "right", "RS", "groups", "views", "items", "tests", "height", "users", "ros", "es"], "columns": ["Columnrows", "patterns", "coles", "Columnses", "rounders", "rounds", "ColumnS", "coll", "colS", "columnings", "structns", "methodes", "Columnsets", "roundrows", "Columners", "Columnensions", "indexs", "colb", " columnb", "colensions", "indexes", "Columnns", "paragraphows", "columnsets", " columnS", "cells", "colers", "indexsets", " columnows", "patternes", "methods", "roundes", "patternings", "structs", "columnb", "methodS", "colrows", "scrollows", "cols", "columnses", "celles", "scrollb", "methodows", "cellensions", "cellrows", "Columnes", "columnows", "Columnl", "paragraphses", "paragraphs", "Columnings", "columnl", "Columns", "columnes", "patternns", "columnns", "columnrows", "scrolls", "columnS", "scrollS", "colows", "colses", "Columnows", "columners", "colsets", "columnensions", "structes", "paragraphes", "indexl", "structings"], "size": ["name", "white", "default", "shift", "content", "len", "clean", "large", "enc", "radius", "capacity", "width", "length", "address", "Size", "en", "column", "see", "count", "sized", "z", "ize", "year", "number", "form", "cells", "ows", "cs", "small", "loc", "w", "position", "source", "n", "core", "SIZE", "support", "ci", "cl", "external", "order", "rate", "six", "mode", "s", "empty", "sec", "use", "member", "sn", "area", "time", "sort", "shape", "when", "x", "code", "sc", "es", "scale"], "r": ["e", "range", "yr", "rb", "br", " rc", "d", "fr", "i", "rc", "h", "pr", "p", "ur", "gr", "ar", "er", "z", "v", "lr", "rw", "rec", "ir", "w", "resh", "m", "n", "l", "rf", "ru", "right", "rh", "g", "ro", "ner", "rl", "k", "rs", "x", "rd", "sr", "nr", "b", "rg", "f", "cr"]}}
{"code": "\\n  T = int(input())\\n  for case in range(1,T+1):\\n      C,F,X = (Decimal(x) for x in input().split())\\n      \\n      ans = X/2\\n      time,rate = 0,2\\n      while True:\\n          if time >= ans:\\n              break\\n          ans = min(ans,(X/rate)+time)\\n          time,rate = time+(C/rate),rate+F\\n      print(\"Case #\",case,\": \",ans,sep = '')\\n", "target": "19", "substitutes": {"T": ["N", "Test", "U", "G", "Time", "O", "CL", "I", "TS", "W", "t", "M", "Z", "K", "TIME", "L", "D", "A", "TW", "R", "B", "S", "TT", "c", "TC", "E", "H", "V", "Y", "Q", "P"], "case": ["U", "name", "id", "num", "repeat", "Time", "p", "series", "ce", "ace", "config", "instance", "ase", "cases", "number", "CE", "ASE", "race", "rice", "pair", "loc", "TIME", "SE", "Case", "ice", "xc", "c", "E", "a", "end", "ACE", "test", "pe", "fe", "line", " CASE", "P", "f", "trial", "mode", "se"], "C": ["N", "CF", "U", "G", "Cu", "O", "CL", "CA", "W", "M", "Z", "K", "CE", "EC", "CM", "DC", "CC", "L", "D", "A", "R", "B", "S", "c", "CV", "E", "AC", "CS", "CI", "CU", "Y", "P"], "F": ["N", "CF", "U", "G", "FD", "Time", "O", "I", "W", "file", "File", "M", "Z", "feed", "L", "D", "A", "FO", "R", "IO", "PF", "B", "FH", "FA", "FC", "FR", "FE", "E", "H", "V", "FF", "Y", "Q", "P", "format", "f", "frequency", "AF"], "X": ["N", "AN", "U", "Time", "XP", "CL", "TX", "W", "IP", "M", "NC", "Z", "CE", "K", "EC", "PC", "TIME", "XM", "CC", "L", "Times", "EX", "D", "Case", "A", "R", "S", "TT", "TC", "E", "H", "CR", "V", "FF", "Y", "Q", "P", "XX", "PE"], "x": ["e", "xa", "xs", "xi", "xt", "event", "exc", "num", "i", "xp", "xf", "p", "xy", "z", "rx", "t", "cross", "number", "tx", "xb", "pair", "w", "q", "ex", "data", "xc", "xxx", "wx", "c", "xe", "s", "test", "xx", "y", "f", "ax", "abc"], "ans": ["AN", "rules", "ANS", "ms", "xs", "cons", "mean", "ns", "offs", "activity", "slice", "ras", "cas", "series", "auto", "ace", " cases", "an", "cases", "ase", "errors", "ai", "amps", "can", "ays", "ents", "chan", "na", "aces", "cs", "example", "plan", "Times", "ins", "OS", "ES", "ls", "An", "A", "seconds", "cross", "rates", "au", "S", "ann", "eps", "times", " times", "s", "anc", "stuff", "a", "CS", "cycles", "scan", "phase", "ants", "ats", "aned", " means", "ases", "ances", "span", "trial", "ones", "es", "ops"], "time": ["e", "size", " TIME", "speed", "ms", "duration", "event", "correct", "ac", "Time", "timeout", "length", "ime", "ace", "start", "count", "year", "context", "change", "z", "t", "an", " Time", "etime", "am", "chan", "date", "race", "space", "com", "uc", "type", "TIME", "clock", "live", "ice", "tim", "century", "data", "one", "times", "c", " times", "tc", "end", "test", "custom", "depth", "cycle", "shape", "delay", "timer", "run", "Y", "y", "cost", "f", "frequency", "span", "cr", "trial", "scale"], "rate": ["rating", "range", "size", "speed", "weight", "duration", "rule", "score", "repeat", "Time", "width", "length", "ime", "ride", "ale", "Rate", "rat", "rx", "level", "write", "date", "race", "rice", "TIME", "sample", "core", "grade", "order", "value", "rates", "erate", "sync", "base", "CR", "fan", "dim", "se", "test", "depth", "cycle", "line", "delay", "fee", "Y", "code", "con", "frequency", "cr", "span", "mode", "scale"]}}
{"code": "T = int(input())\\n  \\n  def solve(R,C,M):\\n      if R>C:\\n          flipboard = solve(C,R,M)\\n          if flipboard:\\n              return [[flipboard[j][i] for j in range(C)] for i in range(R)]\\n          else:\\n              return\\n      if M==0:\\n          board = [['.']*C for i in range(R)]\\n          board[-1][-1] = 'c'\\n          return board\\n      if R == 1:\\n          board = ['*' if i<M else '.' for i in range(R*C)]\\n          board[-1] = 'c'\\n          return [board]\\n      if R == 2:\\n          if R*C==M+1:\\n              board = [['*']*C for i in range(R)]\\n              board[-1][-1] = 'c'\\n              return board\\n          if (M%2) or (M+2)==(R*C):\\n              return\\n          board = [['*' if i<(M/2) else '.' for i in range(C)] for j in range(R)]\\n          board[-1][-1] = 'c'\\n          return board\\n      if M>=R:\\n          subboard = solve(R,C-1,M-R)\\n          if subboard:\\n              return [['*']+r for r in subboard]\\n          return\\n      if (R,C,M) == (3,3,2):\\n          return\\n      k = min(M,C-2)\\n      board = [['*']*k+['.']*(C-k)]\\n      for i in range(M-k):\\n          board.append(['*']+['.']*(C-1))\\n      while len(board)<R:\\n          board.append(['.']*(C))\\n      board[-1][-1] = 'c'\\n      return board\\n      \\n           \\n      \\n  \\n  for case in range(1,T+1):\\n      print(\"Case #\",case,\": \",sep='')\\n      R,C,M = (int(x) for x in input().split())\\n      ans = solve(R,C,M)\\n      if ans:\\n          for r in ans:\\n              print(''.join(r))\\n      else:\\n          print('Impossible')\\n  \\n  \\n", "target": "19", "substitutes": {"T": ["N", "U", "G", "X", "TN", "Time", "O", "I", "TS", "TB", "W", "t", "TM", "Z", "L", "D", "A", "B", "S", "TT", "E", "H", "test", "F", "Type", "V", " t", "Y", "Q", "P", "CT", "TI"], "R": ["N", "Rh", "TR", "AR", "U", "RH", "Rule", "G", "X", "RL", "J", "RE", "O", "RR", "KR", "I", "CL", "MR", "W", "Rs", "Range", "Cl", "K", "RW", "SR", "RO", "RN", "Mor", "Re", "Right", "m", "L", "D", "A", "ER", "JR", "B", "RS", "S", "c", "RP", "CR", "E", "H", "F", "IR", "V", "Run", "DR", "RM", "GR", "WR", "Y", "Ra", "NR", "Q", "P", "RT", "RA", "Cr", "RG"], "C": ["N", "JC", "Count", "U", "G", "Ch", "X", "Co", "Cu", "O", "COR", "CL", "I", "CNN", "Size", "CA", "W", "NC", "CM", "K", "VC", "Cl", "Z", "EC", "CE", "DC", "CW", "CC", "L", "Sc", "D", "A", "CN", "MC", "B", "S", "CAR", "CO", "c", "CV", "CR", "E", "H", "AC", "CS", "CI", "F", "V", "CU", "Y", "Q", "P", "CT", "Cr"], "M": ["N", "U", "MO", "ID", "VM", "G", "ME", "Ch", "X", "MI", "J", "Me", "O", "I", "CL", "MR", "W", "TM", "MD", "MS", "Z", "CM", "K", "NM", "JM", "Mi", "Mor", "MX", "m", "MN", "L", "OM", "Mo", "D", "A", "OR", "MC", "FM", "B", "DM", "S", "MA", "IM", "Model", "c", "MB", "E", "H", "MF", "AM", "F", "V", "Man", "RM", "Y", "Q", "P", "cm", "MM", "LM"], "flipboard": ["fliphole", "flippline", "flipcart", "flipperboard", "flippercart", "flipphole", "flippedboard", "flippingline", " flippingboard", "flipBoard", "Fliphole", " flipline", "Flipcart", "flippBoard", "flippback", "flipback", "slideboards", "flipperhole", " flippingline", "flideBoard", " flippingrow", "flipboards", "Flipboards", "flideboards", "flipline", "Flipboard", "flippedback", " flipback", "flippedboards", "flippedBoard", "flippingcart", "flippingboard", "flippboards", "Flippboards", "flippingrow", "flippedline", "slipboard", "flideboard", "flippedrow", "flippcart", " fliprow", "Flippboard", "slideboard", " flippingback", "flippboard", "flippingback", "flipperboards", "slipBoard", "flippingboards", "Flipphole", "slipboards", "flippinghole", "flipprow", "fliprow", "slideBoard", "Flippcart"], "j": ["e", "xi", "uj", "oj", "h", "J", "p", "im", "z", "ie", "jl", "li", "jj", "v", "ni", "ir", "obj", "q", "n", "m", "l", "adj", "jp", "ij", "ii", "kj", "je", "c", "ja", "jc", "ji", "aj", "y", "b", "ind", "f", "o", "g", "js", "qi"], "i": ["e", "gi", "si", "xi", "ip", "d", "iq", "ori", "id", "p", "I", "u", "im", "zi", "ie", "li", "pi", "ai", "ui", "v", "ni", "it", "io", "m", "ci", "n", "ik", "l", "ii", "index", "ei", "bi", "ti", "di", "ib", "yi", "c", "int", "ji", "phi", "ri", "iu", "b", "f", "o", "iw", "chi", "g", "qi"], "board": ["che", "boards", "val", "ward", "design", "object", "card", "row", "pool", "box", "uc", "rank", "day", "back", "c", "bc", "custom", "node", "stroke", "off", "table", "page", "loop", "bo", "player", "word", "clean", "ode", "length", "join", "ban", "feed", "plan", "video", "valid", "une", "port", "all", "ack", "code", "b", "f", "foot", "post", "game", "check", "lay", "e", "d", "client", "deck", "cart", "play", "p", "document", "layout", "channel", "lane", "cross", "file", "form", "flo", "co", "comment", "Board", "core", "function", "one", "block", "model", "head", "ide", "frame", "result", "chain", "phone", "ko", "bug", "ion", "room", "rows", "coll", "view", "que", "list", "hole", "child", "ba", "flow", "boarding", "stream", "land", "home", "bar", "hack", "work", "round", "rock", "road", "null", " clipboard", "line", "bank", "control", "menu"], "subboard": ["superboard", "supercart", "subrow", " subBoard", " subview", "searchview", "ubline", "searchboard", "superBoard", "ubcart", "subBoard", "ubboards", " subline", "superrow", "ubboard", "searchline", "Subboards", "Subboard", "ubview", " subrow", "ubBoard", "subboards", "subline", "ubrow", "searchrow", "Subrow", "subview", " subcart", " subboards", "subcart"], "r": ["e", "range", "Rh", "br", "rb", "ear", "d", "ring", "id", "nor", "rc", "h", "ac", "p", "ur", "gr", "ar", "mr", "u", "im", "er", "v", "res", "ir", "re", "w", "q", "m", "n", "l", "ru", "right", "al", " c", "g", "ro", "c", "s", "kr", "ner", "a", "rs", "result", "sr", "run", "nr", "P", "b", "f", "chain", "cr", "array"], "k": ["e", "d", "km", "sk", " K", "ac", "p", "ch", "max", "u", "z", "kw", "kk", "t", "it", "v", "K", "ke", "w", "q", "ka", "ak", "n", "m", "ku", "rank", "l", "ks", "block", "c", "work", "s", "key", "end", "y", "ck", "ok", "b", "f", "o", "ko", "mk", "g"], "case": ["e", "size", "name", "id", "X", "p", "section", "match", "ace", "ce", "switch", "instance", "ase", "cases", "race", "loc", "position", "type", "Case", "ice", " c", "text", "one", "c", "tc", "time", "E", "key", "pe", "test", "shape", "choice", " CASE", "code", "path", "P", "trial", "mode"], "x": ["e", "xa", "xs", "xi", "xt", "d", "X", "h", "xp", "p", "xy", " X", "u", "z", "rx", "v", "xb", "w", "q", "n", "l", "index", "ex", "xc", " c", "xxx", "wx", "int", "a", "ic", "xx", "y", "f", "ax", "g"], "ans": ["AN", "ANS", "ms", "cons", "ano", "ns", "ids", " scans", "sk", "ians", "ras", "cas", "anes", "man", "ana", "an", "ase", "ai", "can", "ays", "ents", "ds", "na", "aces", "lang", "lan", "plan", "ania", "ins", "ls", "aus", "cus", "os", "ks", "ens", "ane", "ann", "ani", "anc", "ions", "scan", "ants", "nas", "aned", "ats", " means", "con", "ases", "aning", "span", "ons", "ops"]}}
{"code": "f = open('Bsmall.in', 'r')\\n  g = open('outputB.txt', 'w')\\n  \\n  data = [[float(e) for e in line.strip(\"\\n\").split(' ')] for line in f]\\n  T = int(data.pop(0)[0])\\n  \\n  for i, case in enumerate(data):\\n      C, F, X = case[0], case[1], case[2]\\n      n = 1\\n      t = X/2\\n      t_next = X/(2 + F) + C/2\\n      metric = (t_next < t)\\n      while metric:\\n          n += 1\\n          t = t_next\\n          t_next = t_next - X/(2 + F*(n-1)) + C/(2 + F*(n-1)) + X/(2 + F*n)\\n          metric = (t_next < t)\\n      g.write('Case #%i: %f\\n' %(i+1, t))\\n  f.close()\\n  g.close()\\n", "target": "20", "substitutes": {"f": ["fw", "fd", "d", "fold", "fr", "info", "h", "bf", "p", "fx", "fi", "er", "af", "flow", "u", "r", "z", "fo", "tf", "ft", "file", "form", "v", "fb", "w", "fit", "m", "l", "rf", "fp", "inf", "fs", "c", "df", "frame", "x", "fe", "b", "fc", "o", "fen", "fa"], "g": ["gi", "sg", "ge", "d", "gs", "G", "h", "gui", "p", "j", "erg", "gc", "cfg", "out", "go", "bg", "u", "r", "gu", "v", "group", "w", "q", "m", "og", "l", "ig", "c", "gh", "k", "x", "ga", "vg", "gz", "b", "rg", "err", "o", "gd", "game", "gg", "gm"], "data": ["d", "default", "pos", "content", "slice", "next", "p", "series", "match", "list", "input", "config", "sequence", "change", "file", "response", "DATA", "flat", "Data", "ata", "w", "sample", "database", "dat", "index", "function", "text", "body", "zip", "c", "cache", "split", "time", "a", "test", "result", "lines", "code", "array", "diff", "info", "table"], "e": ["ge", "d", "ele", "ee", "p", "ce", "ace", "u", "r", "ie", "z", "change", "it", "ed", "ev", "ae", "w", "edge", "m", "ea", "el", "l", "entry", "element", "ei", "de", "te", " E", "c", "energy", "E", "end", "pe", "a", "x", "fe", "y", "ze", "code", "b", "ite", "es"], "line": ["page", "ge", "d", "name", "inline", "len", "h", "lo", "header", "lined", "lf", "out", "r", "file", "li", "Line", "object", "v", "band", "group", "lin", "row", "string", "source", "w", "nl", "log", "l", "cl", "block", "all", "c", "ner", "cell", "frame", "buffer", "lines", "user"], "T": ["N", "Test", "Count", "Time", "p", "O", "I", "z", "M", "Z", "type", "L", "D", "R", "B", "TT", "time", "E", "H", "test", "Total", "Y", "P", "trial"], "i": ["si", "ini", "ip", "d", "id", "p", "j", "I", "start", "u", "r", "z", "li", "ai", "ui", "ni", "pi", "v", "type", "ci", "m", "l", "ii", "index", "ti", "c", "int", "k", "x", "y", "iu", "ind"], "case": ["ge", "name", "event", "default", "id", "slice", "p", "section", "ce", "ace", "match", "ride", "switch", "instance", "ase", "cases", "change", "comment", "space", "example", "pair", "position", "type", "Case", "ice", "text", "c", "use", "key", "pe", "test", "shape", "catch", "call", "result", "choice", "code", "trial", "info", "bug"], "C": ["N", "U", "G", "O", "I", "Size", "W", "M", "Z", "K", "DC", "CC", "L", "D", "A", "R", "B", " c", "S", "c", "E", "H", "V", "Y", "Q", "P"], "F": ["N", "CF", "U", "G", "Fs", "FD", "DF", "OF", "FI", "O", "I", "FB", "W", "BF", "FL", "M", "Z", "K", "AF", "Fi", "FS", "L", "D", "A", "EF", "FO", "PF", "GF", "B", "FH", "FA", "FC", "Fun", "E", "H", "SF", "V", "FF", "Y", "Q", "P", "FOR"], "X": ["N", "CF", "U", "CH", "XL", "G", "Co", "XP", "O", "IX", "I", "CL", "W", "M", "Z", "CE", "K", "EC", "CC", "L", "D", "Case", "A", "R", "B", "S", "FC", "c", "CR", "E", "H", "x", "V", "FF", "Y", "Q", "P", "XX", "PE", "CT"], "n": ["N", "size", "d", "ne", "ns", "num", "len", "next", "p", "j", "en", "u", "count", "r", "nt", "z", "number", "v", "ni", "w", "m", "l", "net", "nb", "c", "s", "sn", "a", "k", "x", "nc", "y", "ng", "b", "o", "cn", "nu"], "t": ["at", "tt", "d", "ta", "h", "p", "j", "u", "r", "nt", "pt", "tf", "qt", "Ti", "dt", "v", "it", "w", "type", "m", "l", "ot", " c", "ut", "ti", "rt", "c", "s", "temp", "time", "int", "a", "tp", "test", "st", "x", "y", "tmp", "b", "o", "ts"], "t_next": ["tixnext", "t2next", "t_total", " t_future", "t67sequence", "T_start", "tixsequence", "t_prev", "ntixlatest", "t67latest", "T_last", "t2good", "ntixnext", "t2sequence", "tixgood", "T_shift", "tt_done", "T_total", "nt_latest", "t_last", "nt_sequence", "tixlatest", "t_sequence", "tt_next", "T_next", "nt_good", "t67good", "t_good", "t_start", "t_open", "t67next", "t2latest", " t_Next", "t_done", "t_future", "ntixgood", "t_shift", "t_success", "t_latest", "nt_next", "tt_open", "T_prev", "t_Next", "ntixsequence", "T_success"], "metric": ["matchric", "momogram", "metogram", "linr", "micric", "linrix", " metrics", "merics", "Metogram", "metr", " metogram", "meric", "meency", "metrics", " metr", "matchrics", "Metency", "metency", "momric", "momrics", "metrix", "momency", "meogram", "micrix", " metrix", "micr", "Metrics", "linric", "Metric", "matchogram", "linrics", "micrics"]}}
{"code": "def make_string(R, C, M):\\n      grid = [['.' for j in xrange(C)] for i in xrange(R)]\\n      grid[-1][-1] = 'c'\\n      t = M\\n      for i in xrange(R):\\n          for j in xrange(C):\\n              if M:\\n                  if forbidden(R, C, t, i, j):\\n                      continue\\n                  grid[i][j] = '*'\\n                  M -= 1\\n              else:\\n                  break\\n      s = ''\\n      if M:\\n          return 'Impossible'\\n      for r in grid:\\n          s += ''.join(r)+'\\n'\\n      return s[:-1]\\n  \\n  def forbidden(R, C, M, i, j):\\n      a = M / C\\n      b = M % C\\n      if (R*C - M == 1):\\n          return False\\n  \\n      if i >= (R-2) and j >= (C-2):\\n          return True\\n  \\n      if i >= (R-2) and b:\\n          if b % 2:\\n              return True\\n          if j < b/2:\\n              return False\\n          else:\\n              return True\\n      return False\\n          \\n  \\n  f = open('Csmall.in', 'r')\\n  g = open('outputC.txt', 'w')\\n  \\n  data = [[int(e) for e in line.strip(\"\\n\").split(' ')] for line in f]\\n  T = int(data.pop(0)[0])\\n  for i, case in enumerate(data):\\n      R, C, M = case[0], case[1], case[2]\\n      num_cells = R*C\\n      if (R-1) == 0 or (C-1) == 0:\\n          s = make_string(R, C, M)\\n          g.write('Case #%i:\\n%s\\n' %(i+1,s))\\n          continue\\n      else:\\n          s = make_string(R, C, M)\\n          g.write('Case #%i:\\n%s\\n' %(i+1, s))\\n          \\n  \\n  f.close()\\n  g.close()\\n", "target": "20", "substitutes": {"R": ["N", "Rh", "U", "RH", "Rule", "G", "Ch", "X", "Co", "J", "O", "RR", "KR", "I", "Role", "MR", "W", "Rs", "Cl", "RG", "K", "RC", "RO", "SR", "Right", "RN", "Re", "Ro", "Group", "L", "Res", "D", "A", "JR", "B", "RS", "S", "c", "BR", "CR", "E", "H", "Br", "F", "V", "Run", "RM", "GR", "WR", "Y", "Ra", "NR", "Q", "P", "RA", "Range"], "C": ["N", "CF", "Cs", "JC", "U", "Count", "G", "Ch", "Cor", "X", "Co", "SC", "Cu", "O", "CL", "I", "CNN", "CA", "W", "YC", "NC", "CM", "VC", "CE", "K", "Z", "EC", "DC", "CW", "CC", "L", "Sc", "D", "Case", "A", "MC", "CN", "B", " c", "S", "c", "CV", "CR", "E", "H", "AC", "CS", "CI", "F", "V", "CU", "Y", "Q", "P", "Code", "CT", "Con", "Cr"], "M": ["N", "U", "MO", "G", "ME", "X", "MI", "J", "Me", "O", "I", "CL", "MR", "W", "BM", "MS", "Z", "CM", "K", "MD", "Mi", "SM", "MT", "Mor", "m", "MN", "L", "Mo", "D", "A", "MC", "FM", "B", "DM", "S", "MA", "IM", "c", "MB", "E", "H", "MF", "AM", "F", " m", "V", "Man", "RM", "Y", "Q", "P", "cm", "MM", "LM"], "grid": ["range", "module", "rule", "G", "id", "cube", "play", "gui", "str", "unit", "ode", "layout", "gr", "ace", "list", "sequence", "arr", "multi", "ward", "law", "row", "mat", "div", "ata", "w", "edge", "q", "Grid", "m", "age", "sim", "ice", "graph", "reg", "block", "model", "c", " Grid", "cell", "frame", "test", "house", "x", "db", "code", "complex", "array", "chain", "et", "draw"], "j": ["si", "xi", "d", "uj", "J", "p", "vi", "u", "im", "ie", "z", "jl", "it", "li", "jj", "v", "ni", "jam", "w", "q", "n", "m", "l", "adj", "jp", "ij", "ii", "ib", "job", "bi", "je", "c", "bj", "ja", "jc", "ji", "k", "x", "ab", "y", "aj", "ind", "o", "js", "oj"], "i": ["ini", "hi", "I", "zi", "ni", "io", "uri", "index", "bi", "ti", "c", "ji", "y", "esi", "P", "ind", "iw", "ia", "chi", "gi", "si", "my", "mi", "z", "li", "ui", "type", "n", "l", "ij", "ii", "ib", "yi", "LI", "x", "ri", "o", "eni", "d", "id", "num", "slice", "p", "inner", "vi", "multi", "pi", "ai", "v", "ir", "m", "ci", "key", "iu", "info", "xi", "ori", "ip", "iq", "mini", "u", "ie", "it", "part", "ei", "di", "int", "CI", "ix", "qi"], "t": ["at", "tt", "d", "h", "p", "out", "I", "u", "z", "it", "TM", "v", "w", "type", "m", "n", "tm", "l", "A", " c", "ti", "c", "temp", "int", "F", "x", "y", "Y", "tmp", "o"], "s": ["xs", "name", "words", "ures", "sb", "section", "out", "ing", "sim", "ls", "c", "sec", "states", "site", "y", "ends", "ries", "abs", "si", "sg", "ps", " lines", " S", "codes", "z", "status", "ses", "w", "type", "n", "sample", "l", "seconds", "os", "ings", "blocks", "set", "rs", "x", "ances", "o", "ments", "steps", "ops", "d", "self", "p", "sys", "cells", "v", "sym", "sum", "space", "side", "comments", "conf", "sq", "m", "south", "S", " statements", "second", "lines", "span", "js", "ts", "size", "gs", "ns", "rows", "unit", "uses", "su", "u", "sh", "spec", "ed", "ches", "ds", "string", "ows", "aces", "sets", "session", "sf", "py", "ss", "single", "sync", "ains", "ions", "ips", "es"], "r": ["Rh", "range", "rb", "d", "h", "str", " ir", "p", "section", "gr", "arr", "it", "v", " d", "res", "mat", "w", "q", "m", "n", "l", "right", " c", "rh", "all", "c", "ner", "rs", "result", " arc", "run", "arc", "array", "cr"], "a": ["si", "aa", "ac", "p", "ba", "an", "ai", "am", "na", "sa", "ae", "m", "ci", "alpha", "A", "ca", "mA", "c", "ma", "ab", "ga", "aj", "y", "o", "area", "ia"], "b": ["rb", "d", "bb", "h", "eb", "bf", "p", "sb", "ba", "u", "z", "wb", "v", "w", "m", "n", "l", "A", "B", "ib", "bi", "base", "nb", "c", "lb", "k", "x", "ab", "bs", "y", "o", "be", "bh", "mb"], "f": ["fw", "cf", "fd", "d", "fold", "fr", "info", "h", "xf", "p", "bf", "fi", "u", "af", "flow", "z", "fo", "fm", "file", "form", "fb", "v", "tf", "io", "feed", "w", "conf", "q", "sf", "m", "n", "l", "rf", "fp", "fs", " F", "c", "frame", "F", "x", "fe", "fc", "o", "fen", "ef", "fa"], "g": ["gen", "gi", "sg", "ge", "d", "gs", "G", "h", "p", "bg", "cfg", "go", "u", "gu", "file", "fm", "v", "group", "w", "conf", "q", "m", "og", "gp", "l", "ig", "graph", "reg", "c", "gh", "x", "ga", "y", "vg", "gz", "err", "game", "gg", "gm"], "data": ["size", "results", "d", "default", "shift", "rows", "slice", "next", "p", "series", "list", "input", "sequence", "u", "change", "response", "values", "map", "v", "DATA", "row", "error", "Data", "ata", "w", "dat", "index", "body", "c", "new", "key", "blocks", "test", "x", "result", "lines", "code", "array", "o", "diff", "load", "info"], "e": ["page", "ge", "d", "ele", "ee", "eg", "eb", "p", "ce", "ace", "en", "za", "ie", "ed", "ev", "ke", "ae", "n", "ea", "el", "entry", "ice", "element", "ei", "one", "te", " E", "E", "pe", "ade", "ec", "x", "fe", "ze", "code", "o", "ite", "es", "se", "ef"], "line": ["page", "ge", "d", "ine", "len", "str", "p", "en", "file", "li", "Line", "v", "band", "lin", "row", "string", "n", "m", "l", "el", "cl", "link", "de", "block", "c", "cell", "frame", "lines", "code", "et"], "T": ["N", "X", "unit", "O", "I", "z", "number", "Z", "trace", "type", "D", "A", "B", "S", "time", "E", "H", "test", "F", "shape", "V", "Y", "P", "trial"], "case": ["event", "default", "name", "slice", "section", "match", "ace", "ce", "ride", "switch", "instance", "force", "change", "ase", "part", "space", "error", "pair", "record", "example", "type", "Case", "ice", "entry", "one", "block", "c", "key", "pe", "cell", "ide", "test", "shape", "catch", "call", "result", "choice", "code", "do", "path", "trial", "bug"], "num_cells": ["num_lines", " num_lines", "num_rows", " num_rows", "num_cell", " num_cell"]}}
{"code": "\\n  def read_word(f):\\n      return next(f).strip()\\n  \\n  def read_int(f, b=10):\\n      return int(read_word(f), b)\\n  \\n  def read_letters(f):\\n      return list(read_word(f))\\n  \\n  def read_digits(f, b=10):\\n      return [int(x, b) for x in read_letters(f)]\\n  \\n  def read_words(f, d=' '):\\n      return read_word(f).split(d)\\n  \\n  def read_ints(f, b=10, d=' '):\\n      return [int(x, b) for x in read_words(f, d)]\\n  \\n  def read_floats(f, d=' '):\\n      return [float(x) for x in read_words(f, d)]\\n  \\n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\\n      return [reader(f, *args, **kwargs) for i in range(R)]\\n  \\n  def solve(solver, fn, out_fn=None):\\n      in_fn = fn + '.in'\\n      if out_fn is None:\\n          out_fn = fn + '.out'\\n      with open(in_fn, 'r') as fi:\\n          with open(out_fn, 'w') as fo:\\n              T = read_int(fi)\\n              for i in range(T):\\n                  case = read_case(fi)\\n                  res = solver(case)\\n                  write_case(fo, i, res)\\n  \\n  \\n  def read_case(f):\\n      return read_floats(f)\\n  \\n  def write_case(f, i, res):\\n      f.write('Case #%d: '%i)\\n      f.write('%s'%res)\\n      f.write('\\n')\\n  \\n  \\n  def solve_small(case):\\n      (C, F, X) = case\\n      res = 0\\n      i = 0\\n      while X/(2 + i*F) > C/(2 + i*F) + X/(2 + (i+1)*F):\\n          res += C/(2 + i*F)\\n          i += 1\\n      return res + X/(2 + i*F)\\n  \\n  def solve_large(case):\\n      return solve_small(case)\\n  \\n  DEBUG = 'i'\\n  \\n", "target": "21", "substitutes": {"f": ["e", "cf", "fw", "fd", "fold", "self", "fr", "info", "fed", "fac", "h", "p", "bf", "j", "fm", "fi", "fx", "lf", "fun", "af", "u", "r", "fo", "uf", "t", "tf", "file", "form", "ft", "v", "fb", "of", "die", "feed", "w", "fit", "sf", "m", "n", "l", "rf", "function", "fp", "inf", "fs", "ff", "files", "c", "s", "a", "df", "frame", "buff", "fe", "fat", "fc", "o", "fen", "fab", "g", "fa"], "b": ["e", "rb", "bb", "h", "bf", "p", "sb", "j", "length", "u", "r", "z", "t", "wb", "fb", "v", "w", "m", "n", "l", "B", "bi", "ib", "body", "base", "nb", "c", "bc", "s", "end", "lb", "a", "k", "ab", "y", "db", "o", "g"], "x": ["e", "xa", "xs", "xi", "id", "num", "word", "h", "xp", "xf", "p", "xy", "fx", "j", "max", "u", "z", "rx", "t", "get", "_", "v", "co", "xb", "w", "q", "n", "m", "l", "valid", "index", "ex", "xc", "wx", "xxx", "xxxx", "c", "xe", "s", "int", "k", "xx", "ix", "y", "ax", "g"], "d": ["e", "fd", "name", "nd", "id", "dm", "h", "dc", "p", "j", "u", "z", "r", "dir", "t", "dd", "dt", "v", "ds", "w", "m", "n", "l", "D", "sd", "dat", "dl", "data", "ad", "di", "cd", "da", "c", "end", "dy", "dim", "a", "k", "ld", "y", "db", "do", "o", "g"], "R": ["N", "range", "TR", "U", "RH", "G", "J", "O", "RR", "I", "r", "W", "Rs", "M", "RG", "RW", "SR", "RN", "RO", "L", "Res", "D", "A", "OR", "B", "rh", "S", "CR", "H", "rs", "V", "RM", "Y", "NR", "Q", "P", " r", "RA", "Range"], "reader": ["rr", "rb", "parser", "rand", "default", "driver", "rc", "word", "length", "ride", "dr", "inner", "input", "er", "instance", "read", "handler", "r", "library", "writer", "io", "row", "random", "iter", "w", "feed", "method", "source", "Reader", "seed", "entry", "value", "runner", "callback", "int", "df", "argument", "array", "transfer", "mode", "wrapper", "rar"], "i": ["e", "gi", "ini", "si", "xi", "ip", "ori", "mi", "id", "mini", "h", "p", "j", "fi", "I", "vi", "u", "im", "zi", "r", "z", "li", "pi", "ai", "t", "v", "it", "ni", "ui", "io", "uri", "ir", "multi", "w", "n", "ci", "l", "eni", "ii", "index", "bi", "ti", "di", "c", "s", "int", "a", "k", "phi", "ix", "y", "ri", "iu", "ind", "chi", "qi"], "solver": ["insolver", "solving", "seolution", "insolved", "Solved", "seolving", "insolution", "solve", "ssolution", "solved", "seolver", "solution", "setsolver", "setsolution", "setsolve", "setsolving", "insolve", "Solve", "seanger", "ssolver", "ssanger", "setsanger", "setsolved", "Solver", "sanger", "Solution", "ssolving"], "fn": ["fd", "name", "syn", "h", "enc", "bf", "p", "fi", "out", "fun", "feat", "file", "output", "fb", "v", "nm", "io", "filename", "bn", "n", "m", "kn", "rf", "function", "fl", "fp", "typ", "native", "c", "ln", "sn", "wt", "FN", "node", "nc", "path", "format", "fat", "fc", "o", "dn", "fen", "cn", "fa"], "out_fn": ["out2fp", "outacfc", "flatingfn", "out_fp", "flat_fp", "in_file", "outingfp", "out_filename", "outingfn", "outFilefn", "outingkn", "outackn", "out_kn", "output_fun", "outFilefile", "out_function", "out_fc", "out2function", "flatingkn", "output_fn", "outingfc", "output_file", " out_fp", "out_n", "flat_fn", "outFilefun", "flat_kn", "outacfn", " out_n", "in_fp", "out2n", " out_function", "out_fun", "flat_fc", "outacfp", "out2fn", "outFilefp", "in_filename", "flatingfc", "output_fp", "out_file", "flatingfp"], "in_fn": ["in64filename", "in_fp", "in64nc", "bin_fn", "out_fp", "bin_nc", "in64fn", "out_fc", "in_fd", "in_fc", "bin_filename", "in_nc", "out_fd", "in_filename", "bin_fp", "in64fp"], "T": ["N", "U", "G", "num", "J", "p", "O", "I", "TS", "r", "W", "t", "number", "M", "Z", "type", "L", "D", "Case", "A", "B", "S", "c", "E", "H", "CI", "V", "NT", "Y", "Q", "P", "CT", "TI"], "case": ["sea", "ge", "che", "section", "cases", "ice", "c", "end", "cell", "fe", "fact", "P", "se", "fa", "ch", "ace", "ride", "instance", "type", "time", "pe", "app", "test", "call", "code", "cer", "e", "client", "default", "id", "p", "cas", "match", "ce", "config", "ase", "form", "co", "rice", "pair", "example", "conf", "core", "function", "key", "shape", "result", "sc", "chain", "trial", "info", "bug", "exc", "fi", "force", "r", "fo", "profile", "Case", "base", "cache", "use", "catch", "line", "cp", "mode"], "res": ["red", "ras", "ret", "out", "css", "Rs", "cases", "rep", "Res", "ES", "powers", "rev", "rh", "reg", "reset", "details", "init", "us", "RES", "err", "runs", "resp", "range", "gi", "cons", "ps", "cs", "remote", "os", "rest", "test", "rs", "sr", "ri", "rem", "e", "id", "rc", "p", "pres", "match", "resolution", "rx", "response", "MS", "cells", "error", "rap", "rice", "ris", "re", "resh", "core", "resource", "data", "result", "Results", "trial", "results", "ms", "rows", "RE", "me", "fi", "r", "arr", "spec", "Case", "RS", " Res", "CS", "GR", "cr", "req", "es"], "C": ["N", "Cs", "U", "CH", "G", "Cu", "O", "COR", "I", "CL", "CA", "W", "M", "CE", "K", "CM", "DC", "CC", "L", "D", "A", "B", "S", "c", "CV", "E", "H", "CS", "CI", "V", "CU", "Y", "Q", "P"], "F": ["N", "CF", "U", "Ext", "G", "Fs", "FD", "OF", "DF", "O", "I", "FB", "W", "File", "M", "Z", "K", "FIN", "FS", "L", "D", "FO", "EF", "A", "FH", "B", "GF", "FM", "PF", "FC", "E", "H", "SF", "V", "Y", "Q", "P", "MF", "AF", "FW"], "X": ["N", "CF", "U", "CH", "EL", "XL", "G", "Cu", "XP", "IX", "XXX", "I", "CL", "TX", "W", "M", "NC", "Z", "CE", "EC", "XM", "CC", "L", "EX", "D", "Case", "HTTP", "IO", "Ex", "S", "FC", "CR", "E", "H", "UX", "V", "FF", "CU", "XY", "Y", "Q", "P", "XX", "PE"], "DEBUG": ["N", "e", "name", "exc", "id", " error", "rc", "unit", "feat", "r", "cases", "error", "core", "Res", "Case", "prefix", "key", "end", "CR", "init", "test", "CI", "result", "line", " result", "err", "P", "trial", " r"]}}
{"code": "\\n  def read_word(f):\\n      return next(f).strip()\\n  \\n  def read_int(f, b=10):\\n      return int(read_word(f), b)\\n  \\n  def read_letters(f):\\n      return list(read_word(f))\\n  \\n  def read_digits(f, b=10):\\n      return [int(x, b) for x in read_letters(f)]\\n  \\n  def read_words(f, d=' '):\\n      return read_word(f).split(d)\\n  \\n  def read_ints(f, b=10, d=' '):\\n      return [int(x, b) for x in read_words(f, d)]\\n  \\n  def read_floats(f, d=' '):\\n      return [float(x) for x in read_words(f, d)]\\n  \\n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\\n      return [reader(f, *args, **kwargs) for i in range(R)]\\n  \\n  def solve(solver, fn, out_fn=None):\\n      in_fn = fn + '.in'\\n      if out_fn is None:\\n          out_fn = fn + '.out'\\n      with open(in_fn, 'r') as fi:\\n          with open(out_fn, 'w') as fo:\\n              T = read_int(fi)\\n              for i in range(T):\\n                  case = read_case(fi)\\n                  res = solver(case)\\n                  write_case(fo, i, res)\\n  \\n  \\n  def read_case(f):\\n      return read_ints(f)\\n  \\n  def write_case(f, i, res):\\n      f.write('Case #%d: '%i)\\n      if isinstance(res, list):\\n          res[0][0] = 'c'\\n          res = '\\n'.join(''.join(c for c in r) for r in res)\\n      f.write('\\n%s'%res)\\n      f.write('\\n')\\n  \\n  \\n  def solve_small(case):\\n      (R, C, M) = case\\n      if R == 1:\\n          return 'c' + '.'*(C-M-1) + '*'*M\\n      if C == 1:\\n          return '\\n'.join(['c'] + ['.']*(R-M-1) + ['*']*M)\\n      m = R*C - M\\n      res = [['*']*C for r in range(R)]\\n      if m == 1:\\n          return res\\n      for r in range(2, R+1):\\n          c = m // r\\n          z = m % r\\n          if c < 2 or c + (z>0) > C:\\n              continue\\n          if z == 1 and (r < 3 or c < 3):\\n              continue\\n          for x in range(r):\\n              for y in range(c):\\n                  res[x][y] = '.'\\n          for y in range(z):\\n              res[y][c] = '.'\\n          if z == 1:\\n              res[z][c] = '.'\\n              res[r-1][c-1] = '*'\\n          return res\\n      return 'Impossible'\\n  \\n  def solve_large(case):\\n      return solve_small(case)\\n  \\n  DEBUG = 'f'\\n  \\n", "target": "21", "substitutes": {"f": ["e", "cf", "fw", "fd", "self", "fold", "fr", "info", "fed", "h", "bf", "p", "j", "xf", "fi", "fx", "lf", "fun", "af", "u", "fo", "fm", "t", "tf", "file", "ft", "form", "v", "fb", "of", "feed", "w", "conf", "fit", "sf", "l", "rf", "function", "fp", "inf", "fs", "ff", "func", "files", "s", "a", "df", "frame", "F", "buff", "fe", "this", "uf", "fc", "fen", "g", "fa"], "b": ["e", "rb", "bb", "h", "bf", "p", "sb", "j", "length", "u", "t", "wb", "v", "w", "n", "l", "B", "bi", "body", "base", "nb", "s", "end", "lb", "a", "dy", "k", "ab", "bs", "db", "be", "o", "g"], "x": ["e", "xa", "xs", "xi", "id", "num", "X", "word", "h", "xp", "xf", "p", "xy", "fx", "j", "max", "input", "u", "rx", "t", "get", "_", "v", "bit", "xb", "w", "q", "n", "l", "valid", "index", "ex", "xc", "wx", "xxx", "xxxx", "xe", "s", "int", "k", "xx", "ix", "ax", "g"], "d": ["e", "fd", "name", "nd", "id", "h", "dc", "p", "j", "u", "dir", "t", "dd", "dt", "v", "ds", "dx", "w", "n", "l", "D", "sd", "dat", "dl", "data", "ad", "di", "cd", "md", "da", "end", "split", "dy", "dim", "a", "k", "ld", "db", "do", "o", "g"], "R": ["N", "range", "TR", "AR", "U", "RH", "G", "X", "RL", "J", "RE", "O", "RR", "I", "CL", "W", "Rs", "RG", "K", "RC", "SR", "RN", "RO", "Re", "L", "Res", "D", "A", "JR", "B", "RS", "rh", "S", "RP", "CR", "E", "H", "F", "V", "RF", "DR", "RM", "GR", "Y", "Q", "P", "RA", "Range"], "reader": ["rr", "rb", "parser", "driver", "loader", "rc", "slice", "upper", "length", "ride", "inner", "input", "er", "instance", "builder", "read", "handler", "library", "writer", "io", "row", "rw", "iter", "w", "feed", "method", "Reader", "entry", "value", "reading", "runner", "callback", "ner", "ctor", "lc", "finder", "argument", "array", "transfer", "wrapper"], "i": ["e", "gi", "ini", "si", "xi", "ip", "iq", "mi", "id", "p", "j", "fi", "I", "u", "im", "zi", "li", "t", "ai", "pi", "v", "it", "ni", "io", "uri", "q", "n", "ci", "l", "ii", "index", "bi", "di", "ti", "s", "int", "a", "k", "phi", "ix", "ri", "iu", "ind", "chi", "qi"], "solver": ["ssolve", "Solving", " soper", "insolver", "insolving", "solving", "ssolves", "Solves", "solves", "seolving", "soper", " solve", "Soper", "solve", "seolver", "seolves", "insolve", " solving", "Solve", "ssolver", "Solver", "seolve", "insoper", "ssolving"], "fn": ["fd", "name", "syn", "h", "enc", "p", "fi", "out", "fun", "feat", "file", "output", "fb", "write", "v", "nm", "io", "filename", "loc", "n", "kn", "orn", "function", "fl", "fp", "typ", "native", "ln", "lib", "sn", "wt", "FN", "node", "nc", "path", "format", "fat", "fc", "o", "fen", "dn", "cn", "fa"], "out_fn": ["out2filename", "extra_fn", "extraPfp", "flatingfn", "out_fp", "out_path", "flat_fp", "out2fd", "in_file", "outPfp", "outingfp", "out_filename", "output_path", "outingfn", "outFilefn", "flatingbin", "outFilepath", "extraPn", "outqfc", "outqfp", "output_fun", "out_fc", "in_fd", "outqbin", "out_fd", "outPfunc", "output_fn", "outPn", "extra_n", "outingfc", "out2file", "extraPfunc", "outPfn", "extra_func", "out_n", "flat_fn", "outFilefun", "extraPfn", "out_func", "out_bin", "out_fun", "flat_fc", "extra_fp", "out2fn", "outFilefp", "in_filename", "flatingfc", "flat_bin", "output_fp", "out_file", "outqfn", "flatingfp", "outingbin"], "in_fn": ["in_folder", "in_fp", "in_fil", "bin_fn", "out_fp", "out_fil", "inwfilename", "bin_mn", "inwmn", "bin_filename", "in_mn", "in_filename", "inwfp", "bin_fp", "out_folder", "inwfn"], "T": ["N", "U", "G", "X", "J", "p", "O", "I", "TS", "W", "t", "TA", "Z", "L", "D", "A", "B", "S", "E", "H", "F", "CI", "V", "NT", "Y", "Q", "P"], "case": ["e", "default", "X", "slice", "p", "ch", "section", "cas", "fi", "match", "ce", "ace", "ride", "switch", "config", "instance", "force", "fo", "change", "ase", "cases", "string", "rice", "ise", "pair", "loc", "profile", "type", "uc", "cl", "Case", "ice", "rest", "function", "base", "cache", "use", "key", "pe", "time", "end", "test", "shape", "catch", "call", "result", " CASE", "fact", "code", "sc", "cer", "cp", "trial", "info", "fa"], "res": ["vre", "ras", "ret", "out", "val", "Rs", "cases", "rec", "Res", "rev", "rh", "reg", "details", "RES", "err", "resp", "ps", "fr", "ch", "mr", "cs", "remote", "os", "rest", "s", "rez", "rs", "ri", "rem", "e", "rc", "p", "pres", "gr", "match", "resolution", "rx", "response", "error", "rap", "rice", "esc", "ris", "re", "core", "resource", "data", "ro", "Result", "result", "results", "ms", "exc", "ns", "ces", "fi", "su", "arr", "spec", "ches", "Case", "ex", "right", "RS", " Res", "catch", "ros", "req", "es"], "c": ["cf", "e", "rc", "h", "ac", "dc", "p", "ch", "ct", "t", "co", "v", "cu", "rec", "cs", "w", "uc", "n", "ci", "l", "xc", "cd", "cc", "unc", "anc", "a", "k", "sc", "con", "cp", "cn", "lc"], "r": ["e", "range", "br", "rb", "rc", "h", "str", "pr", "p", "ur", "gr", "rm", "u", "co", "v", "ir", "re", "w", "n", "l", "ru", "rh", "ro", "all", "rl", "rs", "result", "ri", "err", "cr"], "C": ["N", "U", "G", "Ch", "X", "SC", "Cu", "O", "I", "CL", "CA", "W", "NC", "Cl", "K", "VC", "DC", "CW", "CC", "L", "D", "A", "MC", "CN", "B", "S", "CO", "E", "H", "CS", "F", "CI", "V", "CU", "Y", "Q", "P", "Cr"], "M": ["N", "U", "G", "X", "MI", "J", "O", "I", "W", "MD", "MQ", "Z", "CM", "MX", "MN", "L", "CC", "D", "A", "MC", "B", "S", "E", "H", "MF", "F", "V", "RM", "Y", "Q", "P", "MM", "LM"]}}
{"code": "\\n  \\n  TEST_CASES = [\\n      (\"\"\"4\\n  30.0 1.0 2.0\\n  30.0 2.0 100.0\\n  30.50000 3.14159 1999.19990\\n  500.0 4.0 2000.0\\n  \"\"\",\"\"\"Case #1: 1.0000000\\n  Case #2: 39.1666667\\n  Case #3: 63.9680013\\n  Case #4: 526.1904762\\n  \"\"\")\\n  ]\\n  \\n  \"\"\"\\n  Z is number of farms held\\n  tF(Z) is time to build a farm = C / (2+(F*Z))\\n  tX(Z) is time to win = X / (2+(F*Z))\\n  No point incresing Z when tX(Z) < (tX(Z+1) + tF(Z)\\n      == X / (2+(F*Z)) < (X / (2+(F*(Z+1))) + (C / (2+(F*Z)))\\n      == (X - C) / (2+(F*Z)) < X / (2+(F*(Z+1)))\\n      == (X - C) * (2+(F*Z)+F) < X * (2+(F*Z))\\n      == 2X - 2C + XFZ - CFZ + XF - CF < 2X + XFZ\\n      == XF - CF - 2C < CFZ\\n      == (XF - CF - 2C) / CF < Z\\n  \"\"\"\\n  \\n  def parse_input(input_reader):\\n      case_count = int(input_reader.readline())\\n      case_idx = 0\\n      while case_count > case_idx:\\n          case_idx += 1\\n          input_line = input_reader.readline().rstrip(\"\\n\").split(\" \")\\n          input_values = {\"C\": float(input_line[0]),\\n                          \"F\": float(input_line[1]),\\n                          \"X\": float(input_line[2]),\\n                          \"case\": case_idx}\\n          yield input_values\\n  \\n  def solve_problem(output_writer=sys.stdout, **kwargs):\\n      case = kwargs['case']\\n      C_val = kwargs['C']\\n      F_val = kwargs['F']\\n      X_val = kwargs['X']\\n  \\n      best_Z = ((X_val * F_val) - (C_val * F_val) - (2 * C_val)) / (C_val * F_val)\\n      best_Z = int(ceil(best_Z))\\n      if best_Z < 0:\\n          best_Z = 0\\n  \\n      tX = lambda z: (X_val / (2+(F_val * z)))\\n      tF = lambda z: (C_val / (2+(F_val * z)))\\n  \\n      total_time = reduce(lambda x,y: x + tF(y), range(best_Z), tX(best_Z))\\n      print >> output_writer, \"Case #%d: %.7f\" % (case, total_time)\\n  \\n  def solve_inputs(input_reader, output_writer):\\n      \"\"\"\\n      Loop through each problem input in input reader and solve it.\\n  \\n      Outputs responses to output_writer.\\n      \"\"\"\\n      for input_values in parse_input(input_reader):\\n          solve_problem(output_writer=output_writer, **input_values)\\n  \\n  def run_tests():\\n      idx = 0\\n      all_pass = True\\n      for problem_input, expected_output in TEST_CASES:\\n          idx += 1\\n          input_reader = StringIO(problem_input)\\n          output_writer = StringIO()\\n          solve_inputs(input_reader, output_writer)\\n          problem_output = output_writer.getvalue()\\n          if problem_output == expected_output:\\n              print \"Test %d: Success\" % idx\\n          else:\\n              all_pass = False\\n              print \"Test %d: Failure\" % idx\\n          input_reader.close()\\n          output_writer.close()\\n      if all_pass:\\n          print \"All tests were successful!\"\\n      else:\\n          print \"Something didn't match - try again.\"\\n  \\n  def main():\\n      parser = OptionParser()\\n      parser.add_option(\"-f\", \"--file\",\\n                        dest=\"filename_stem\",\\n                        help=\"read input from FILE.in and write to FILE.out\",\\n                        metavar=\"FILE\")\\n  \\n      (options, args) = parser.parse_args()\\n      if options.filename_stem:\\n          print \"Running in file mode.\"\\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\\n          solve_inputs(input_reader, output_writer)\\n      else:\\n          print \"Running in test mode.\"\\n          run_tests()\\n  \\n  if __name__ == \"__main__\":\\n      main()\\n", "target": "22", "substitutes": {"TEST_CASES": ["TEST_CATCHES", "TEST_CASER", "TEST_CLATCHIONS", "TEST_CLASes", "TEST_CACHES", "TEST_CACes", "TEST_CASIONS", "TEST_CASes", "TEST_CLASER", "TEST_CACER", "TEST_CLASES", "TEST_CLATCHER", "TEST_CACHes", "TEST_CACHER", "TEST_CLASIONS", "TEST_CACHIONS", "TEST_CLATCHes", "TEST_CATCHes", "TEST_CATCHIONS", "TEST_CACIONS", "TEST_CACES", "TEST_CATCHER", "TEST_CLATCHES"], "input_reader": ["inputerreader", "inputerobject", "input_parser", "inputedright", " input_writer", "input24writer", "output_reader", "output_object", "input24server", " input_author", "input_object", "inputerstream", "output_right", "input_server", "input_stream", "input_writer", "input24right", "output_server", " input_parser", "inputerwriter", "inputedwriter", "output_stream", "inputedserver", "inputedreader", "input_right", "input24reader", "input_author"], "case_count": ["case_length", "input_length", " case_number", "caseennumber", "case__start", " case_weight", " case_length", "caseenlength", "input_count", "case__number", "caseenweight", "input_start", "case__count", "case_number", "input_number", "caseencount", "case__length", "case_weight", "case_start"], "case_idx": ["case_idsxf", "case_idw", "case_indw", "casexidxb", "case_Idindex", "case_indexxb", "case_indexxs", "casexindexy", "case_infoy", "case_inindex", "case_infov", "case_indexindex", "case_indx", "case_infox", "case_idsx", "case_Idxs", "case_Idxf", "case_idxf", "casexidv", "case_Idx", "case_indexxc", "case_Idxc", "case_idsn", "case_idsxs", "case_idy", "case_indexx", "case_idxb", "case_Idy", "case_inxs", "case_inx", "case_indxc", "case_infoxb", "case_idxs", "casexindexxb", "case_idindex", "case_idn", "case_indexv", "casexidy", "case_Idw", "case_inxc", "case_indexy", "case_indy", "casexidx", "casexindexx", "casexindexv", "case_Idn", "case_idv", "case_idxc"], "input_line": [" input_data", "input_inline", " input_block", "input_look", "raw_Line", "command___stroke", "inputlexdata", "inputlexinline", "inputlogstroke", "raw_line", "inputingblock", "input5item", "input5liner", "raw_liner", "raw_record", "input__record", "inputlexlook", "command_liner", "command___line", "input__line", "input_record", "command_line", "input___line", "input___stroke", "input__look", "input_liner", "inputlogline", "input__Line", "command_match", "raw_look", "input_data", " input_inline", "input_item", "input___liner", "inputlexline", "inputingline", "inputlexblock", "inputlexrecord", "input_block", "inputlogmatch", "raw_item", "command_stroke", "input___match", "input_match", "inputingdata", "command___liner", "inputinginline", "input5line", "inputlexLine", "input_Line", "inputlogliner", "command___match", "input5look", "input_stroke"], "input_values": ["Input_value", "input_vals", "input_lines", "input_value", "input__vals", "inputsvalue", "output_changes", "input__lines", "input_changes", "input__values", "input__changes", "Input_lines", "Input_values", "output_values", "output_lines", "inputsvals", "inputsvalues", "Input_vals", "inputslines", "output_vals"], "output_writer": ["output_writers", "outputoutwriter", "outputoutbuffer", "output_reader", "output_buffer", "outputoutwriters", "input_buffer", "input_writer", "input_writers", "outputoutreader"], "case": ["name", "section", "match", "instance", "force", "change", "cases", "ase", "condition", "CE", "error", "pair", "type", "Case", "ice", "model", "key", "time", "test", "shape", "catch", "CI", "call", " CASE", "code", "trial"], "C_val": ["F\n", "C\n", "X_VAL", "C_VAL", " C\n", "C_Val", "X\n", "X_Val", "C_value", "X_value"], "F_val": ["F_eval", "F_value", " F_value", "F_rel", " F_gen", "Fpyrel", " F67val", " F_col", " F_rel", "Fistval", "F67val", "Fistslot", " Fpyslot", "Fpyval", " F67eval", "Fistrel", "Fistcol", "Fpyslot", " Fpycol", "Fpycol", " Fpyval", "F_gen", " F67value", "F_slot", " F_slot", "F67eval", " F67gen", "F67gen", " F_eval", "F_col", " Fpyrel", "F67value"], "X_val": ["XpVal", "H_Val", "P_value", "X_num", "Xpval", "P_val", "Xpvalue", "X_Val", "H_val", "X5Val", "X_value", "H_num", "Xpvals", "P_vals", "X5value", "X5num", "X_vals", "H_value", "P_Val", "X5val"], "best_Z": ["bestPZ", "bestMatzone", "average_case", "bestMatzip", "average_Z", "best_zone", "best_case", "average_zone", "bestMatZ", "bestPcase", "bestMatcase", "bestPzip", "bestPzone", "best_zip", "average_zip"]}}
{"code": "\\n  \\n  TEST_CASES = [\\n      (\"\"\"5\\n  5 5 23\\n  3 1 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  \"\"\",\"\"\"Case #1:\\n  Impossible\\n  Case #2:\\n  c\\n  .\\n  *\\n  Case #3:\\n  Impossible\\n  Case #4:\\n  c......\\n  .......\\n  .......\\n  ....***\\n  Case #5:\\n  c........*\\n  .........*\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  \"\"\"),\\n      (\"\"\"3\\n  5 4 3\\n  5 3 8\\n  5 5 14\\n  \"\"\",\"\"\"Case #1:\\n  c...\\n  ....\\n  ....\\n  ...*\\n  ..**\\n  Case #2:\\n  Impossible\\n  Case #3:\\n  c...*\\n  ....*\\n  ...**\\n  *****\\n  *****\\n  \"\"\")\\n  ]\\n  \\n  IMPOSSIBLE = \"Impossible\"\\n  \\n  \"\"\"\\n  S is number of safe squares = (R*C) - M\\n  If S == 1 then always possible:\\n      Assume click in top left, all else mines\\n  Special cases (R or C is small):\\n  If R == 1 or C == 1 then always possible:\\n      Assume click in top left and all safe squares in a line\\n  Else if R == 2 or C == 2 then possible iff S % 2 == 0:\\n      Assume click in top left and all safe squares are in a 2 * X line\\n  Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)\\n     OR if S % 2 == 0 \\n  \"\"\"\\n  \\n  def parse_input(input_reader):\\n      case_count = int(input_reader.readline())\\n      case_idx = 0\\n      while case_count > case_idx:\\n          case_idx += 1\\n          input_line = [int(x) for x in input_reader.readline().split()]\\n          input_values = {\"case\": case_idx,\\n                          \"R\": input_line[0],\\n                          \"C\": input_line[1],\\n                          \"M\": input_line[2]}\\n          yield input_values\\n  \\n  \\n  def solve_problem(output_writer=sys.stdout, **kwargs):\\n      case = kwargs['case']\\n      rows = kwargs['R']\\n      cols = kwargs['C']\\n      mines = kwargs['M']\\n      safe_squares = ((rows * cols) - mines)\\n      print >> output_writer, \"Case #%d:\" % case\\n      row_string = \"{:*<%ds}\" % cols\\n      impossible = False\\n      if safe_squares == 1:\\n          print >> output_writer, row_string.format(\"c\")\\n          for row in range(1, rows):\\n              print >> output_writer, row_string.format(\"\")\\n      elif rows == 1:\\n          safe_string = \"c\" + (\".\" * (safe_squares - 1))\\n          print >> output_writer, row_string.format(safe_string)\\n      elif cols == 1:\\n          for row in range(rows):\\n              cell = \"\"\\n              if row == 0:\\n                  cell = \"c\"\\n              elif row < safe_squares:\\n                  cell = \".\"\\n              print >> output_writer, row_string.format(cell)\\n      elif safe_squares == 2:\\n          impossible = True\\n      elif rows == 2:\\n          safe_cols, remainder = divmod(safe_squares, 2)\\n          if remainder == 1:\\n              impossible = True\\n          else:\\n              safe_string = \".\" * (safe_cols - 1)\\n              print >> output_writer, row_string.format(\"c%s\" % safe_string)\\n              print >> output_writer, row_string.format(\".%s\" % safe_string)\\n      elif cols == 2:\\n          safe_rows, remainder = divmod(safe_squares, 2)\\n          if remainder == 1:\\n              impossible = True\\n          else:\\n              for row in range(rows):\\n                  cells = \"\"\\n                  if row == 0:\\n                      cells = \"c.\"\\n                  elif row < safe_rows:\\n                      cells = \"..\"\\n                  print >> output_writer, row_string.format(cells)\\n      else:\\n          safe_rows, remainder = divmod(safe_squares, cols)\\n          if remainder == 1 and cols == 3 and safe_rows == 2:\\n              impossible = True\\n          elif safe_rows > 1:\\n              if remainder == 1 and safe_rows == 2:\\n                  mid_safe = \".\" * (cols-2)\\n                  for row in range(rows):\\n                      cell_one = \".\"\\n                      mid_cells = mid_safe\\n                      last_cell = \".\"\\n                      if row == 0:\\n                          cell_one = \"c\"\\n                      elif safe_rows == 0:\\n                          cell_one = \".\"\\n                          mid_cells = \".\" * (remainder + 1)\\n                      elif safe_rows < 0:\\n                          cell_one = \"\"\\n                          mid_cells = \"\"\\n                      if safe_rows < 3:\\n                          last_cell = \"\"\\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\\n                      safe_rows -= 1\\n              elif remainder == 1:\\n                  mid_safe = \".\" * (cols-2)\\n                  for row in range(rows):\\n                      cell_one = \".\"\\n                      mid_cells = mid_safe\\n                      last_cell = \".\"\\n                      if row == 0:\\n                          cell_one = \"c\"\\n                      elif safe_rows == 0:\\n                          cell_one = \".\"\\n                          mid_cells = \".\" * remainder\\n                      elif safe_rows < 0:\\n                          cell_one = \"\"\\n                          mid_cells = \"\"\\n                      if safe_rows < 2:\\n                          last_cell = \"\"\\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\\n                      safe_rows -= 1\\n              else:\\n                  full_safe = \".\" * cols\\n                  for row in range(rows):\\n                      cells = full_safe\\n                      if row == 0:\\n                          cells = \"c\" + (\".\" * (cols - 1))\\n                      elif row == safe_rows:\\n                          cells = \".\" * remainder\\n                      elif row > safe_rows:\\n                          cells = \"\"\\n                      print >> output_writer, row_string.format(cells)\\n          else:\\n              safe_cols, remainder = divmod(safe_squares, 2)\\n              if remainder == 1 and safe_cols < 4:\\n                  impossible = True\\n              elif remainder == 0:\\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\\n                  for row in range(2, rows):\\n                      print >> output_writer, row_string.format(\"\")\\n              else:\\n                  safe_cols -= 1\\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\\n                  print >> output_writer, row_string.format(\"...\")\\n                  for row in range(3, rows):\\n                      print >> output_writer, row_string.format(\"\")\\n      if impossible:\\n          print >> output_writer, IMPOSSIBLE\\n  \\n  def solve_inputs(input_reader, output_writer):\\n      \"\"\"\\n      Loop through each problem input in input reader and solve it.\\n  \\n      Outputs responses to output_writer.\\n      \"\"\"\\n      for input_values in parse_input(input_reader):\\n          solve_problem(output_writer=output_writer, **input_values)\\n  \\n  def run_tests():\\n      idx = 0\\n      all_pass = True\\n      for problem_input, expected_output in TEST_CASES:\\n          idx += 1\\n          input_reader = StringIO(problem_input)\\n          output_writer = StringIO()\\n          solve_inputs(input_reader, output_writer)\\n          problem_output = output_writer.getvalue()\\n          if problem_output == expected_output:\\n              print \"Test %d: Success\" % idx\\n          else:\\n              all_pass = False\\n              print \"Test %d: Failure\" % idx\\n              print problem_output\\n          input_reader.close()\\n          output_writer.close()\\n      if all_pass:\\n          print \"All tests were successful!\"\\n      else:\\n          print \"Something didn't match - try again.\"\\n  \\n  def main():\\n      parser = OptionParser()\\n      parser.add_option(\"-f\", \"--file\",\\n                        dest=\"filename_stem\",\\n                        help=\"read input from FILE.in and write to FILE.out\",\\n                        metavar=\"FILE\")\\n  \\n      (options, args) = parser.parse_args()\\n      if options.filename_stem:\\n          print \"Running in file mode.\"\\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\\n          solve_inputs(input_reader, output_writer)\\n      else:\\n          print \"Running in test mode.\"\\n          run_tests()\\n  \\n  if __name__ == \"__main__\":\\n      main()\\n", "target": "22", "substitutes": {"TEST_CASES": ["TEST_CASEES", "TEST_CATCHES", "TEST_CRASes", "TEST_CACes", "TEST_CACSE", "TEST_CASSE", "TEST_CASIONS", "TEST_CATCHSE", "TEST_CRACes", "TEST_CASes", "TEST_CRASSE", "TEST_CASEIONS", "TEST_CATCHIONS", "TEST_CATCHes", "TEST_CACIONS", "TEST_CASEes", "TEST_CACES", "TEST_CASESE", "TEST_CRACIONS", "TEST_CRACES", "TEST_CRASIONS", "TEST_CRACSE", "TEST_CRASES"], "IMPOSSIBLE": ["IMPACibility", "IMPESSible", "IMPESSABLE", "IMPOSSibility", "IMPENSIBLE", "IMpOSSABLE", "IMPENSABLE", "IMPOSSABLE", "IMPACABLE", "IMpENSible", "IMPESSIBLE", "IMpENSIBLE", "IMPOSSible", "IMpOSSIBLE", "IMPACible", "IMPENSible", "IMpOSSibility", "IMPACIBLE", "IMpENSibility", "IMPESSibility", "IMpOSSible", "IMPENSibility", "IMpENSABLE"], "input_reader": ["inputmatread", "inputingreader", "output_entry", "documentmatread", "input_read", "output_reader", "documentmatreader", "inputFeditor", "document_read", "output_resource", "documentmatiterator", "input_inner", "inputmatreader", "inputFilewriter", "inputingwriter", "inputingresource", "input_entry", "document_reader", "document_editor", "document_inner", "input_editor", "document_magic", "inputingentry", "inputFwriter", "document_iterator", "inputFileresource", "documentmatinner", "inputmatiterator", "input_writer", "inputFilereader", "inputFreader", "input_magic", "inputFileentry", "inputmatinner", "input_resource", "document_writer", "inputFmagic", "input_iterator"], "case_count": ["casefcount", "ase_Count", "case__Count", "case\u00b7count", "ase_count", "word\u00b7body", "caseftotal", "word_body", "caseNtotal", "ase__id", "case_id", "word\u00b7level", "case\u00b7body", "ase_id", "case__id", "caseflevel", "word_total", "word_count", "case_Count", "word\u00b7total", "case\u00b7level", "word_level", "case_total", "caseNbody", "caseNlevel", "case__count", "ase__Count", "casefbody", "caseNcount", "case\u00b7total", "case_level", "ase__count", "word\u00b7count", "case_body"], "case_idx": ["case_Idxe", "case_idn", "case_idsxs", "case_idy", "case_infoc", "case_Idy", "case_Idxes", "case_countv", "case_infox", "case_idc", "case_idsx", "case_infor", "case_Idv", "case_countX", "case_Idr", "case_countxe", "case_Idxs", "case_countx", "case_idsxes", "case_idxe", "case_countc", "case_IdX", "case_idxes", "case_idxs", "case_idr", "case_Idc", "case_Idn", "case_countxs", "case_idv", "case_Idx", "case_infoy", "case_idX", "case_idsn"], "input_line": ["importLogline", "inputxlines", "output_try", "input_sample", "inputLogtry", "inputLoglines", "output_line", "inputwline", "inputloglines", "importLogstroke", "import_line", "argumentlogsample", "input___lines", "inputLoglane", "output_lines", "inputxline", "inputLogside", "inputsline", "input_lane", "input___try", "argument_lines", "argumentlogline", "output_lane", "import_side", "inputwlines", "Input_values", "argumentlogliner", "input_try", "inputwblock", "input___line", "input_liner", "inputlogline", "Input_line", "Input_block", "argument_liner", "inputLogstroke", "input_side", "import_stroke", "argumentloglines", "input___lane", "argument_line", "inputLogentry", "import_entry", "importLogentry", "input_block", "inputwvalues", "input_lines", "inputsentry", "importLogside", "inputxliner", "input_entry", "Input_lines", "inputlogsample", "inputxsample", "argument_sample", "inputsstroke", "inputlogliner", "input_stroke", "inputLogline", "inputsside"], "x": ["e", "xd", "xs", "xi", "xt", "d", "id", "i", "px", "X", "xxxxxxxx", "xp", "xf", "fx", "xy", "p", "xes", " X", "u", "rx", "z", "val", "v", "xb", "pair", "index", "ex", " xx", "xc", "wx", "xxx", "xxxx", "xe", "pe", "xx", "fe", "ix", "y", "ax"], "input_values": ["Input_value", "input_vals", "input_value", "Input_rows", "output_changes", "output_value", "input_changes", "input_rows", "Input_values", "output_values", "Input_vals", "output_vals"], "output_writer": ["output_writers", "output_driver", "outputpubwriters", "out_writers", "output_reader", " output_reader", " output_writers", "out_reader", "outputpubdriver", "out_writer", "out_engine", " output_driver", "outputpubwriter", "outputpubreader", "output_engine"], "case": ["size", "name", "patch", "slice", "section", "address", "match", "ce", "force", "instance", "change", "ase", "number", "_", "error", "Error", "pair", "example", "position", "type", "Case", "ice", "model", "key", "test", "shape", "catch", "line", "code", "trial"], "rows": ["classes", "heads", "results", "members", "ids", "reads", "Row", "months", "length", "features", "sections", "holes", "cases", "planes", "values", "ows", "types", "pages", "fields", "rown", "rooms", "keys", "groups", "headers", "posts", "frames", "times", "checks", "blocks", "tests", "rs", "items", "lines", "users", "OWS", "ros", "runs", "ries"], "cols": ["colions", "coli", "wells", "coles", "wellths", " coli", "Colions", "Colths", "welles", " colions", "Coles", " coles", "columnions", "Coli", "Cols", "columnes", "wellions", "columns", "columnths", "columni", "colths"], "mines": ["colions", " minors", "coles", "eminus", "minsions", "minces", "emines", "mindes", "minsus", "Minors", "mindions", "mindors", "eminors", "eminions", "Mines", "minses", " minces", "minsces", "Minus", "colors", "minions", "minors", " minus", " minions", "colces", "Minions", "mindus", "minus", "colus"], "safe_squares": ["safe_Squared", "safe_quases", "safe_squapes", "safe_Squases", "safe_quapes", "safe_Squares", "safe_collases", "safe_collared", "safe_squared", "safe_collapes", "safe_squases", "safe_quares", "safe_collares", "safe_quared", "safe_Squapes"]}}
{"code": "\\n  \\n  N = int(sys.stdin.readline())\\n  \\n  for T in range(1, N+1):\\n      C, F, X = map(float, sys.stdin.readline().split(' '))\\n  \\n      N = 0\\n      for i in range(int(X)):\\n          diff = (2 + F * i) * C - F * X\\n          if diff >= 0: break\\n          N = i\\n  \\n      total = 0\\n      for i in range(N):\\n          val = C / (2 + i * F)\\n          total += val\\n      val = X / (2.0 + N * F)\\n      total += val\\n          \\n      ans = '%s' % (total)\\n      print 'Case #%(T)s: %(ans)s' % locals()\\n", "target": "23", "substitutes": {"N": ["U", "NN", "G", " n", "J", "O", "I", "Size", "CNN", "Num", "M", "NC", "Z", "NI", "K", "ni", "NB", "NA", "n", "NL", "L", "Diff", "D", "NF", "A", "R", "IO", "B", "S", "Len", "E", "Ne", "Ni", "H", "Ns", "NO", "V", "NT", "Node", "Y", "NS", "Q", "P", "f", "No", "Part"], "T": ["U", "d", " I", "O", "j", "I", "u", "Ti", "t", "Z", "L", "D", "A", "B", "ti", "c", "time", "E", "a", " t", "P", "f", "II"], "C": ["CF", "Count", "U", "G", "Co", "Cu", "O", "I", "CNN", "W", "M", "K", "DC", "CC", "L", "D", "A", "R", "B", "S", "c", "CR", "E", "H", "CI", "V", "CU", "Y", "Q", "P", "f"], "F": ["CF", "U", "G", "Fs", "FD", "J", "OF", "FI", "O", "DF", "fi", "I", "IF", "W", "BF", "M", "Z", "K", "Factor", "Fi", "L", "D", "A", "EF", "R", "PF", "B", "GF", "FH", "FC", "E", "H", "CI", "V", "FF", "Y", "Inf", "Q", "P", "f", "FG", "Fe"], "X": ["CF", "U", "Length", "XL", "Fixed", "XP", "IX", "XXX", "length", "I", "CNN", "TX", "W", "M", "Z", "K", "DC", "CC", "L", "Cross", "D", "A", "Check", "R", "B", "Ex", "S", "FC", "Work", "FE", "CR", "E", "H", "x", "V", "FF", "Y", "XX", "Q", "P", "MAX", "f"], "i": ["e", "ini", "si", "xi", "ip", "d", "id", "lo", "p", " I", "j", "I", "Bi", "u", "im", "PI", "ie", "multi", "r", "li", "pi", "NI", "t", "v", "it", "ai", "io", "DI", "Fi", "n", "ci", "L", "l", "ii", "mult", "inf", "di", "z", "c", "LI", "int", "a", "CI", "x", "V", "ix", "Inf", "iu", "b", "ind", "f", "II", "Pi", "iw", "chi"], "diff": ["range", "mix", "d", "default", "shift", "Delta", "max", "change", "different", "part", "error", " difference", "div", "iff", "conf", "IFF", "Diff", "index", "comp", "value", "fine", "data", "frac", "new", "split", "fix", "int", "df", "test", "min", "FF", "dist", "err", "ignore", "f", "ind", "no", "info", "lc"], "total": ["full", "percent", "quant", "translation", "mean", "stats", "final", "length", "max", "complete", "start", "count", "nt", "multi", "t", "summary", "sum", "error", "part", "flat", "partial", "normal", "equal", "valid", "index", "mult", "alpha", "local", "value", "trans", "average", "loss", "all", "base", "gross", "frac", "ALL", "toc", "otal", "Total", "result", "null", " Total", "NT", "cost", "fat", "no", "f", " TOTAL", "info", "scale"], "val": ["vals", "col", "ee", "dev", "len", "final", "ac", "unit", "p", "opt", "doc", "viol", "cal", "VAL", "count", "nt", "rel", "crit", "cat", "util", "v", "sum", "part", "error", "pal", "el", "grade", "l", "valid", "py", "mult", "eval", "value", "al", "data", "au", "ann", "base", "all", "func", "split", "grad", "var", "call", "ul", "result", "fat", "err", "Val", "trial", "scale"], "ans": ["AN", "ANS", "vals", "cas", "ana", "an", "errors", "ents", "aux", " spans", "na", "nan", "ates", "lan", "plan", "analysis", "ls", "aus", "ran", "ann", "anc", "ross", "ations", "ants", "ases", "alls", "es"]}}
{"code": "\\n  \\n  \\n  def show_board(board):\\n      for row in board:\\n          print ''.join(row)\\n  \\n  \\n  N = int(sys.stdin.readline())\\n  \\n  for T in range(1, N+1):\\n      (R, C, M) = map(int, sys.stdin.readline().split(' '))\\n      E = R*C-M # empty\\n      possible, reverse, need_adjust, column_base = (False, False, False, False)\\n      if C > R:\\n          (R, C) = (C, R)\\n          reverse = True\\n  \\n      W = 0\\n      lastRow = 0\\n      if E == 0:\\n          pass\\n      elif E == 1 or M == 0:\\n          W = C\\n          possible = True\\n      elif C == 1:\\n          W = 1\\n          if E > 0:\\n              possible = True\\n      elif C == 2:\\n          W = 2\\n          lastRow = int(E / 2) + 1   # 1 base\\n          if E % 2 == 0 and E >= 4:\\n              possible = True\\n      elif C >= 3:\\n          for w in range(2, C+1):\\n              lastRow = int(E / w) + 1   # 1 base\\n              if lastRow > R: continue\\n              lastRowNum = E % w\\n              \\n              if lastRow == 2 and lastRowNum == 0:\\n                  pass\\n              elif lastRow == 2:   # lastRow == 1 => impossible\\n                  if lastRowNum == 0:\\n                      W = w\\n                      possible = True\\n                      break\\n              elif lastRow >= 3:\\n                  if lastRowNum >= 2 or lastRowNum == 0:\\n                      W = w\\n                      possible = True\\n                      break\\n                  elif C >= 4 and lastRowNum == 1 and R >= 3:\\n                      W = w\\n                      possible = True\\n                      need_adjust = True\\n                      break\\n          if not possible:\\n              for w in range(2, R+1):\\n                  lastRow = int(E / w) + 1   # 1 base\\n                  if lastRow > R: continue\\n                  lastRowNum = E % w\\n                  if lastRow == 2 and lastRowNum == 0:\\n                      pass\\n                  elif lastRow == 2:   # lastRow == 1 => impossible\\n                      if lastRowNum == 0:\\n                          W = w\\n                          possible = True\\n                          column_base = True\\n                          break\\n                  elif lastRow >= 3:\\n                      if lastRowNum >= 2 or lastRowNum == 0:\\n                          W = w\\n                          possible = True\\n                          column_base = True\\n                          break\\n                      elif C >= 4 and lastRowNum == 1 and R >= 3:\\n                          W = w\\n                          possible = True\\n                          need_adjust = True\\n                          column_base = True\\n                          break\\n                                  \\n      if not possible:\\n          if reverse:\\n              R, C = (C, R)        \\n          ans = 'Impossible %sx%s M=%s' % (R, C, M)\\n          print 'Case #%(T)s: %(ans)s' % locals()\\n          continue\\n  \\n      board = [['*'] * C for i in range(R)]\\n      for i in range(E):\\n          if not column_base:\\n              c = i % W\\n              r = i / W\\n          else:\\n              r = i % W\\n              c = i / W            \\n          board[r][c] = '.'\\n      if need_adjust:\\n          board[lastRow-1][1], board[lastRow-2][-1] = board[lastRow-2][-1], board[lastRow-1][1]\\n      if reverse:\\n          board = map(list, zip(*board))\\n          R, C = (C, R)\\n  \\n      clicked = False\\n      for r in range(R):\\n          if clicked: break\\n          for c in range(C):\\n              cell = board[r][c]\\n              if cell != '.': continue\\n              if E == 1:\\n                  board[r][c] = 'c'\\n                  clicked = True\\n                  break\\n              \\n              if r >= 1  and c >= 1  and board[r-1][c-1] == '*': continue\\n              if r >= 1              and board[r-1][c]   == '*': continue\\n              if r >= 1  and c < C-1 and board[r-1][c+1] == '*': continue\\n              if             c >= 1  and board[r][c-1]   == '*': continue\\n              if             c < C-1 and board[r][c+1]   == '*': continue\\n              if r < R-1 and c >= 1  and board[r+1][c-1] == '*': continue\\n              if r < R-1             and board[r+1][c]   == '*': continue\\n              if r < R-1 and c < C-1 and board[r+1][c+1] == '*': continue\\n              board[r][c] = 'c'\\n              clicked = True\\n              break\\n  \\n      ans = 'Possible' if possible else 'Impossible'\\n      print 'Case #%(T)s:' % locals()\\n      show_board(board)\\n", "target": "23", "substitutes": {"board": ["col", "rule", "deck", "rows", "word", "cart", "coll", "boards", "ode", "interface", "list", "channel", "input", "hole", "sequence", "flow", "down", "form", "flo", "card", "feed", "Board", "entry", "square", "wall", "data", "one", "ro", "c", "cell", "frame", "reader", "node", "line", "buffer", "code", "array", "post", "game", "table"], "row": ["page", "loop", "col", "rows", "word", "X", "Block", "view", "section", "Row", "channel", "flow", "ward", "string", " Row", "ows", "bar", "record", "feed", "Board", "ow", "entry", "rown", "raw", "port", "ro", "block", "round", "cell", "frame", "test", "OW", "null", "x", "node", "line", "buffer", "stroke", "Y", "post", "user", "server", " rows", "table"], "N": ["U", "G", " n", "X", "O", "I", "Size", "W", "NM", "Z", "K", "n", "L", "D", "A", "B", "S", "H", "Ni", "Ne", "Ns", "F", "V", "NT", "Node", "Y", "NS", "Q", "P", "No"], "T": ["U", "G", "X", "O", "Row", "I", "W", "t", "K", "L", "D", "A", "B", "S", "H", "F", "V", " t", "Y", "P"], "R": ["U", "G", "X", "O", "RR", "I", "r", "W", "Rs", "K", "SR", "RO", "L", "D", "A", "B", "S", "CR", "H", "F", "V", "Y", "NR", "Q", "P", "RA"], "C": ["Cs", "U", "G", "X", "Cu", "O", "I", "W", "CM", "K", "Z", "CC", "L", "D", "A", "B", "S", "c", "CR", "H", "F", "V", "CU", "Y", "Q", "P"], "M": ["U", "MO", "G", "X", "J", "O", "I", "W", "MD", "Z", "K", "m", "MN", "L", "D", "A", "FM", "B", "S", "H", "F", "Man", "V", "RM", "Y", "Q", "P", "LM"], "E": ["e", "U", "G", "X", "O", "Edge", "I", "W", "EC", "Z", "K", "IE", "GE", "L", "ES", "D", "A", "EF", "B", "S", "H", "F", "V", "Y", "El", "P", "Q"]}}
{"code": "\\n  def calculate_time(c, f, x, num_farms):\\n  \tt = 0.0\\n  \trate = 2.0\\n  \tfor i in range(num_farms):\\n  \t\tt += c / rate\\n  \t\trate += f\\n  \t\t\\n  \tt += x / rate\\n  \treturn t\t\\n  \\n  t = int(sys.stdin.readline().strip())\\n  \\n  for i in range(t):\\n  \tprint \"Case #\" + str(i + 1) + \":\",\\n  \\n  \t(c, f, x) = [float(i) for i in sys.stdin.readline().strip().split()]\\n  \t\\n  \tif x <= c:\\n  \t\tt = calculate_time(c, f, x, 0)\\n  \telse:\\n  \t\topt_rate = f * (x - c) / c\\n  \t\tnum_farms = (opt_rate - 2) / f\\n  \t\tt1 = calculate_time(c, f, x, int(math.floor(num_farms)))\\n  \t\tt2 = calculate_time(c, f, x, int(math.ceil(num_farms)))\\n  \\n  \t\tt = min(t1, t2)\\n  \t\t\\n  \tprint \"%.7f\" % t\\n", "target": "24", "substitutes": {"c": ["e", "cf", "mc", "d", "col", "h", "ac", "C", "dc", "p", "ch", "ce", "max", "u", "count", "r", "z", "cat", "co", "v", "cu", "cs", "w", "cy", "uc", "n", "m", "ci", "l", "cl", "xc", "cc", "s", "cache", "time", "cin", "a", "k", "cycle", "nc", "y", "sc", "con", "b", "cm", "fc", "cn", "g", "lc"], "f": ["e", "cf", "fd", "d", "fr", "fac", "h", "xf", "p", "fi", "u", "af", "count", "z", "r", "file", "form", "tf", "fb", "v", "fo", "w", "fit", "sf", "q", "m", "n", "l", "rf", "fl", "fp", "inf", "fs", "ff", "s", "time", "F", "fe", "y", "b", "float", "fc", "o", "fen", "frequency", "con", "g", "fa"], "x": ["e", "ctx", "cf", "xa", "xs", "xi", "xt", "d", "event", "X", "sex", "h", "xf", "p", "fx", "j", "xy", "max", "en", "u", "im", "ct", "z", "r", "rx", "number", "tx", "v", "dx", "ext", "w", "uc", "q", "m", "n", "ci", "l", "cl", "index", "ex", "xc", "wx", "xxx", "work", "s", "time", "int", "k", "ic", "xx", "ix", "y", "b", "con", "fc", "o", "ax", "g", "lc"], "num_farms": ["num_sfms", "numaccarts", "num_lms", "num_affarming", "num_fieldarm", "num_Fares", "num_fieldrations", "num_Fars", "num_colarms", "num_affarms", "num_formaves", "num_Farms", "numlfarm", "num_darm", "num_rfares", "numffieldares", "num_forearms", "num_farts", "numacfarts", "numffieldrations", "num_formarm", "num_carts", "numlfarms", "num_rfrations", "num_frations", "num_pharm", "num_sfarms", "numaccarms", "numaccarn", "numacfarn", "num_farn", "num_dars", "numlfores", "num_darms", "numffares", "num_affarts", "num_fars", "num_faves", "num_lores", "numldarms", "num_formars", "num_forearming", "num_Faves", "numacfarms", "num_sfarming", "num_foreers", "num_fores", "num_fms", "num_larm", "num_affarn", "num_colarming", "num_forems", "num_larming", "numacfarming", "numldarm", "num_fieldares", "numffieldarms", "numffarms", "num_rfarms", "num_colarts", "num_dores", "num_rfarm", "num_carming", "num_fers", "num_Fores", "num_lers", "num_farm", "num_farming", "numffrations", "num_formarms", "numldars", "numldores", "num_fares", "num_colarn", "num_carms", "num_Frations", "num_Farm", "numffarm", "num_sfers", "num_pharms", "num_phars", "num_lars", "num_fieldarms", "num_phaves", "numffieldarm", "numlfars", "numaccarming", "num_carn", "num_larms"], "t": ["e", "tt", "at", "stop", "d", "duration", "elt", "ta", "h", "tz", "p", "j", "out", "lt", "u", "ct", "r", "z", "pt", "tf", "it", "nt", "dt", "v", "_", "qt", "w", "type", "tta", "n", "m", "tm", "l", "ot", "T", "tn", "ut", "rt", "all", "s", "temp", "time", "tp", "int", "mt", "tg", "test", "token", "y", "b", "o", "g", "ts"], "rate": ["cf", "gen", "tt", "e", "stop", "speed", "charge", "weight", "rule", "score", "thro", "rc", "rated", " beta", "ac", "unit", " rule", "length", "max", "ride", "trial", "Rate", "rat", "r", "acc", "z", " time", "exp", "date", "re", "feed", "type", "limit", "m", "core", "rank", "grade", "seed", "fl", "fast", "rates", "tap", "frac", "sync", "zip", " frequency", " control", "time", "fan", "dy", " speed", "delay", "ga", " alpha", "fee", "beta", "code", "con", "float", "fc", " ratio", "frequency", "ate", "cr", " r", "scale"], "i": ["e", "gi", "si", "ini", "xi", "ip", "d", "mi", "id", "mini", "h", "slice", "p", "j", "fi", "I", "start", "u", "zi", "ie", "multi", "z", "li", "pi", "ai", "ui", "v", "cli", "io", "uri", "type", "m", "ci", "n", "l", "ii", "index", "ei", "ti", "di", "end", "int", "a", "ic", "phi", "ix", "y", "ri", "iu", "b", "ind", "o", "qi"], "opt_rate": ["opt_speed", " opt_cycle", "opt_cycle", "opt_rule", " opt_rates", "optnnum", "optnrates", " opt_num", " opt_rule", "opt_num", "optnrate", "opt_rates", " opt_speed", "optnrule", "opt_scale", " opt_scale"], "t1": [" t3", "T1", "f0", "fn", "f81", "Tn", "f2", "t3", " t0", "T2", "tn", "f1", " tn", " t81", "t0", "T3", "t81", "T0", "T81", "f3"], "t2": [" t3", "dt1", " t4", "T1", "tt2", "tt3", "dt4", "T4", "t3", "ttwo", "T2", "ptwo", "tt4", "p3", "p2", "dt2", "t4", " ttwo", "dttwo", "Ttwo", "p4", "tttwo"]}}
{"code": "\\n  def generate_matrix(r, c, char):\\n  \tmat = [[char for i in range(c)] for j in range(r)]\\n  \treturn mat\\n  \t\\n  def merge(mat1, mat2):\\n  \tfor i in range(len(mat1)):\\n  \t\tfor j in range(len(mat1[i])):\\n  \t\t\tmat2[i][j] = mat1[i][j]\\n  \treturn mat2\\n  \\n  def solve(r, c, m):\\n  \tif 0 == m:\\n  \t\tmat = generate_matrix(r, c, '.')\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \t\t\\n  \tf = r * c - m\\n  \t\\n  \tif 0 == f:\\n  \t\treturn False\\n  \t\t\\n  \tif 1 == f:\\n  \t\tmat = generate_matrix(r, c, '*')\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \t\t\\n  \tif 1 == min(r, c):\\n  \t\tmat = generate_matrix(r, c, '*')\\n  \t\tfor i in range(f):\\n  \t\t\tmat[0 if 1 == r else i][0 if 1 == c else i] = '.'\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \\n  \tif 2 == min(r, c):\\n  \t\tif (0 != f % 2) or (2 == f):\\n  \t\t\treturn False\\n  \t\tmat = generate_matrix(r, c, '*')\\n  \t\tfor i in range(f // 2):\\n  \t\t\tmat[0 if 2 == r else i][0 if 2 == c else i] = '.'\\n  \t\t\tmat[1 if 2 == r else i][1 if 2 == c else i] = '.'\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \t\t\\n  \tif (3 == r) and (3 == c):\\n  \t\tif (4 == f) or (6 == f):\\n  \t\t\tmat = generate_matrix(r, c, '*')\\n  \t\t\tfor i in range(f // 2):\\n  \t\t\t\tmat[0][i] = '.'\\n  \t\t\t\tmat[1][i] = '.'\\n  \t\t\tmat[0][0] = 'c'\\n  \t\t\treturn mat\\n  \t\tif 8 == f:\\n  \t\t\tmat = generate_matrix(r, c, '.')\\n  \t\t\tmat[2][2] = '*'\\n  \t\t\tmat[0][0] = 'c'\\n  \t\t\treturn mat\\n  \t\treturn False\\n  \t\t\\n  \trows_to_reduce = min(r - 3, m // c)\\n  \tif 0 < rows_to_reduce:\\n  \t\tres = solve(r - rows_to_reduce, c, m - rows_to_reduce * c)\\n  \t\tif False == res:\\n  \t\t\treturn False\\n  \t\tmat = merge(res, generate_matrix(r, c, '*'))\\n  \t\treturn mat\\n  \t\t\\n  \tcols_to_reduce = min(c - 3, m // r)\\n  \tif 0 < cols_to_reduce:\\n  \t\tres = solve(r, c - cols_to_reduce, m - cols_to_reduce * r)\\n  \t\tif False == res:\\n  \t\t\treturn False\\n  \t\tmat = merge(res, generate_matrix(r, c, '*'))\\n  \t\treturn mat\\n  \t\\n  \tmat = generate_matrix(r, c, '.')\\n  \tfor i in range(min(m, r - 2)):\\n  \t\tmat[r - i - 1][c - 1] = '*'\\n  \tif m == r - 1:\\n  \t\tmat[r - 1][c - 2] = '*'\\n  \tmat[0][0] = 'c'\\n  \treturn mat\\n  \t\t\t\\n  \\n  t = int(sys.stdin.readline().strip())\\n  \\n  for i in range(t):\\n  \tprint \"Case #\" + str(i + 1) + \":\"\\n  \\n  \tr, c, m = [int(i) for i in sys.stdin.readline().strip().split()]\\n  \t\\n  \tres = solve(r, c, m)\\n  \t\\n  \tif False == res:\\n  \t\tprint \"Impossible\"\\n  \telse:\\n  \t\tfor i in range(r):\\n  \t\t\tfor j in range(c):\\n  \t\t\t\tsys.stdout.write(res[i][j])\\n  \t\t\tprint\\n", "target": "24", "substitutes": {"r": ["e", "range", "yr", "br", "rb", "rr", "d", "fr", "rc", "h", "p", "ur", "pr", "ar", "dr", "u", "er", "z", "v", "ra", "ir", "re", "w", "q", "n", "hr", "l", "rf", "R", "ru", "right", "rh", "g", "ro", "rt", "s", "a", "rn", "k", "rs", "x", "sr", "nr", "run", "y", "b", "err", "rg", "cr"], "c": ["e", "cf", "mc", "d", "col", "rc", "h", "ac", "dc", "C", "p", "ch", "ce", "u", "ct", "z", "v", "cu", "rec", "cs", "w", "cy", "uc", "q", "n", "ci", "l", "cl", "ca", "cc", "s", "cin", "cell", "a", "k", "ic", "ec", "x", "nc", "y", "sc", "b", "cm", "con", "cp", "cr", "arc", "g", "lc"], "char": ["e", "gi", "mc", "d", "tr", "fr", "ctr", "id", "rc", "h", "C", "dc", "ch", "ar", "I", "letter", "u", "im", "co", "v", "cs", "w", "uc", "q", "ci", "Char", "s", "int", "cell", "k", "character", "x", "cm", "cr", "g"], "mat": ["comb", "col", "math", "mp", "man", "mx", "tag", "qt", "mit", "fm", "crit", "util", "mitt", "mag", "mol", "hm", "mas", "mun", "graph", "ut", "hat", "text", "MAT", "template", "mic", "cm", "bt", "stat", "mot", "att", "om", "act", "tab", "opt", "doc", "mu", "atten", "agg", "mm", "cat", "map", "_", "hot", "flat", "ata", "dat", "wa", "all", "app", "dim", "test", "token", "material", "x", "pat", "b", "array", "mem", "net", "ort", "abc", "Matrix", "module", "d", "num", "fn", "p", "met", "match", "mac", "feat", "bm", "file", "ith", "ht", "mar", "layer", "na", "loc", "cont", "md", "rt", "min", "mon", " Mat", "format", "et", "plot", "Mat", "at", "mc", "struct", "sat", "h", "ac", "unit", "ct", "arr", "it", "ha", "lat", "atom", "dict", "mult", "wat", " matrix", "mt", "wt", "mate", "ma", "nat", "mode"], "i": ["ini", "name", "api", "I", "iv", "zi", "ni", "io", "uri", "index", "bi", "ti", "ji", "phi", "y", "ind", "ia", "gi", "si", "mi", "mu", "z", "li", "ui", "n", "l", "ij", "ii", "yi", "a", "x", "hip", "ri", "b", "o", "e", "d", "id", "p", "vi", "pi", "ai", "v", "ir", "loc", "ci", "key", "iu", "ment", "xi", "ion", "ip", "h", "u", "ie", "it", "q", "ei", "di", "int", "k", "oi", "g", "qi"], "j": ["e", "si", "br", "d", "uj", "h", "J", "p", "ch", "u", "qi", "z", "jl", "li", "it", "jj", "v", "q", "n", "ci", "l", "jp", "ij", "ii", "jc", "a", "ji", "k", "x", "y", "iu", "b", "ind", "o", "g", "js", "oj"], "mat1": ["Mat1", "Mat3", " mat7", "nat2", "m3", " mat10", "ha2", "mm1", "m5", "mm3", "ha5", "mat5", "mat7", "ha0", "Mat2", " matr", "mat0", "m0", " mat5", "mm2", " mat0", "nat10", "Mat10", "natr", "matr", "m1", "mat10", "mm0", "Matr", "Mat0", "Mat7", "mat3", "m7", "ha1", "nat1", "m2"], "mat2": ["cat2", "math2", "Mat1", "cat1", " matall", "nat2", " matrix2", "mat5", "Mat2", "mat0", "cat5", "math1", "Mat4", " mat5", " matrix4", "nat5", " mat0", "mp2", "mp1", "mp5", " mat4", " matrixall", "mat4", "cat0", "Matall", "math5", " matrix1", "nat1", "mp0", "matall"], "m": ["e", "range", "mc", "d", "mi", "h", "p", "mu", "mr", "u", "mm", "z", "fm", "M", "v", "w", "q", "n", "l", "mad", "s", "a", "k", "x", "y", "b", "cm", "o", "g"], "f": ["e", "cf", "d", "fold", "fr", "h", "xf", "p", "u", "z", "fm", "tf", "form", "fb", "v", "of", "feed", "w", "fit", "q", "sf", "n", "l", "rf", "function", "fp", "fs", "ff", "all", "s", "a", "df", "k", "F", "x", "fe", "y", "found", "b", "fc", "o", "fen", "g", "fa"], "rows_to_reduce": ["rows_to_indolve", "rows_to_merown", "rows_to_induce", "rows_to_down", "rows_to_meruce", "rows_to_redown", "rows_to_meruction", "rows_to_reduction", "rows_to_dolve", "rows_to_merolve", "rows_to_redolve", "rows_to_induction", "rows_to_duction", "rows_to_indown", "rows_to_duce"]}}
{"code": "def time_to_get(target, num_factories, factory_cost, factory_increase):\\n      rate = 2.0\\n      t = 0\\n      for i in range(num_factories):\\n          t += factory_cost/rate\\n          rate += factory_increase\\n      return t + target/rate\\n      \\n  def solve(C,F,X):\\n      min_sol = None\\n      num_fact = 0\\n      while True:\\n          t = time_to_get(X, num_fact, C, F)\\n          if min_sol is None or t < min_sol:\\n              min_sol = t\\n              num_fact += 1\\n          else:\\n              return min_sol\\n  \\n  if __name__ == \"__main__\":\\n      T = int(raw_input())\\n      for i in range(1, T+1):\\n          C,F,X = map(float, raw_input().split())\\n          print \"Case #%d: %.07f\" % (i, solve(C,F,X))\\n", "target": "25", "substitutes": {"target": ["N", "range", "e", "weight", "Target", "offset", "unit", "current", "auto", "trial", "force", "output", "M", "cut", "flat", "source", "iter", "fit", "limit", "n", "core", "L", "arget", "function", "resource", "R", "value", "gt", "growth", "parent", "E", "x", "site", "dist", "goal", "Y", "transform", "cost", "P", "timeout", "scale"], "num_factories": ["num_weighthips", "num_acticles", "num_fories", "num_factors", "num_fors", "num_actores", "num_actives", "num_countores", "num_fives", "num_counthips", "num_actories", "num_partors", "num_weightores", "num_counticles", "num_partives", "num_partories", "num_countories", "num_weightories", "num_factives", "num_facthips", "num_acthips", "num_factores", "num_facticles", "num_weighticles", "num_actors"], "factory_cost": ["factory2price", "factory2cost", "fault_Cost", "fault_cost", "factory_Cost", "finite_tax", "factory_count", "factory_sum", "factory2sum", "fault_count", "factory_tax", "factory_price", "finite_price", "factory2tax", "finite_sum", "finite_cost"], "factory_increase": ["factory_creASE", "factory_variases", "factory_variation", "factory_Increase", "factory_increased", "factory_crease", "factory_incasing", "factory_changeasing", "factory_Increasing", "factory_variase", "factory_enhASE", "factory_creasing", "factory_changeased", "factory_increation", "factory_increASE", "factory_incase", "factory_creased", "factory_incases", "factory_enhasing", "factory_increasing", "factory_variasing", "factory_incation", "factory_Increation", "factory_enhase", "factory_increases", "factory_Increases", "factory_changease", "factory_changeASE", "factory_enhased"], "rate": ["rating", "gen", " rates", "tt", "size", "speed", "rand", "weight", "d", "rule", "score", "thro", " Rate", "ee", "ta", " beta", "ac", "unit", "p", "ride", "max", "go", "Rate", " e", "rat", "r", "exp", "root", "sum", "sub", "rice", "prime", "re", "date", "feed", "fit", "m", "core", "rank", " re", "seed", "grade", "value", "rates", "sync", "te", " r", "c", "time", "dy", " p", "test", "depth", "delay", "dist", "fee", "y", " alpha", "term", " source", "con", "float", " ratio", "cost", "frequency", "ate", "cr", "transfer", "g", "scale", "beta"], "t": ["at", "tt", "e", "d", "ta", "h", "Time", "p", "u", "ct", "r", "pt", "z", "it", "total", "tf", "dt", "v", "nt", "type", "n", "m", "tm", "l", "ot", "tn", "ti", "c", "temp", "s", "time", "tp", "int", "wt", "test", "x", "y", "tmp", "b", "f", "o", "trial", "g", "ts"], "i": ["e", "gi", "si", "xi", "ip", "d", "col", "ID", "id", "num", "h", "p", "j", "I", "start", "u", "im", "r", "z", "pi", "ai", "v", "m", "n", "ci", "l", "index", "ti", "di", "c", "s", "int", "a", "init", "phi", "x", "y", "ri", "iu", "ind", "f", "trial", "g", "qi"], "C": ["N", "CF", "Cs", "U", "G", "SC", "Cu", "O", "CL", "I", "CNN", "CA", "W", "YC", "M", "CM", "K", "CE", "DC", "CP", "Cache", "CC", "L", "D", "A", "R", "MC", "B", "FC", "CO", "c", "KC", "CR", "E", "H", "CI", "V", "CU", "Y", "P", "f", "CT", "Con"], "F": ["CF", "U", "G", "Fs", "FD", "DF", "FT", "I", "FB", "FL", "BF", "File", "M", "Fi", "L", "Family", "D", "FO", "UF", "FH", "GF", "PF", "B", "WF", "FC", "FR", "Fun", "E", "H", "V", "Form", "FF", "Y", "Q", "P", "f", "FG", "MF", "AF", "FM", "FW", "Fe"], "X": ["N", "CF", "U", "Target", "XL", "G", "XP", "ZX", "PH", "O", "IX", "XXX", "CL", "I", "TX", "W", "IP", "File", "M", "Z", "Input", "Data", " x", "XM", "L", "D", "A", "R", "HTTP", "FX", "WH", "B", "Ex", "Check", "S", "Work", "E", "H", "UX", "x", "V", "Form", "FF", "XY", "Y", "fact", "DX", "Q", "P", "XX", "PE", "FW"], "min_sol": ["min\u00b7flo", "min_ol", "min_rel", " min_col", " min_mol", "minedol", "max_Sol", "max_mol", "min_col", " min_ol", "minedSol", "min2loc", "minedval", " min_val", "min\u00b7rel", "min_loc", "min2mol", "min_mol", "min__sol", " min_rel", "min__Sol", "min\u00b7sol", "min_flo", "max_sol", "min\u00b7ol", "min2ol", "max_ol", "min_Sol", "min__mol", " min_Sol", "min_val", " min_flo", " min_loc", "minedsol", "min2sol", "min__ol"], "num_fact": ["num_factor", "num67actor", " num_part", " num_act", " num_facts", "num_act", "numLfactor", "num_frequency", " num_factor", "num67part", "num_actor", " num_actor", "numLfact", "numLfrequency", " num_frequency", "num67fact", "num_facts", "num_part"], "T": ["N", "G", "TN", "Time", "O", "I", "TS", "W", "Ti", "M", "Z", "n", "L", "WT", "D", "R", "B", "S", "TT", "Ts", "time", "E", "H", "Type", "V", "PT", "Total", "Y", "Q", "P", "TI"]}}
{"code": "\\n  def all_grids(R,C,M, lp=0,placed=0):\\n      rem = R*C-lp\\n      if M-placed >= rem:\\n          if M-placed > rem:\\n              return None\\n          \\n          res = set()\\n          for i in range(lp, R*C):\\n              res.add(i)\\n          return [res]\\n          \\n      if placed == M:\\n          return [set()]\\n  \\n      res = []\\n      for i in range(lp, R*C):\\n          sub_sol = all_grids(R,C,M,i+1, placed+1)\\n          if sub_sol is None:\\n              continue\\n              \\n          for s in sub_sol:\\n              s.add(i)\\n              res.append(s)\\n      return res\\n  \\n  def adj(R,C,i):\\n      \\n      res = []\\n      left_edge = i % C == 0\\n      top_edge = i // C == 0\\n      right_edge = (i+1) % C == 0\\n      bottom_edge = i // C == R-1\\n      \\n      if not left_edge:\\n          res.append(i-1)\\n          if not top_edge:\\n              res.append(i-1-C)\\n          if not bottom_edge:\\n              res.append(i+C-1)\\n              \\n      if not right_edge:\\n          res.append(i+1)\\n          if not top_edge:\\n              res.append(i+1-C)\\n          if not bottom_edge:\\n              res.append(i+1+C)\\n              \\n      if not bottom_edge:\\n          res.append(i+C)\\n      if not top_edge:\\n          res.append(i-C)\\n      return res\\n          \\n      \\n      \\n      \\n  def solution(R,C,g):\\n      M = R*C\\n      res = []\\n      num_zeroes = 0\\n      for i in range(M):\\n          if i in g:\\n              res.append('x')\\n              continue\\n          x = 0\\n          for a in adj(R,C,i):\\n              if a in g:\\n                  x += 1\\n          if x == 0:\\n              num_zeroes += 1\\n          res.append(x)\\n          \\n      for i in range(M):\\n          if i in g:\\n              continue\\n          r = res[i]\\n          if r == 0 and num_zeroes == 1:\\n              continue\\n          connected = False\\n          for a in adj(R,C,i):\\n              if res[a] == 0:\\n                  connected = True\\n                  break\\n          if not connected:\\n              return None\\n      \\n      return res.index(0)\\n  \\n  def transcribe(R,C, g, sol):\\n      res = []\\n      for i in range(R):\\n          r = []\\n          for j in range(C):\\n              x = i*C+j\\n              if x in g:\\n                  r.append('*')\\n              elif x == sol:\\n                  r.append('c')\\n              else:\\n                  r.append('.')\\n          res.append(r)\\n      return res\\n  \\n  def printed_sol(transcript):\\n      if transcript is None:\\n          return \"Impossible\"\\n      else:\\n          return \"\\n\".join(\"\".join(row) for row in transcript)\\n  \\n  def solve(R,C,M):\\n      if M == R*C-1:\\n          g = []\\n          for i in range(R*C-1):\\n              g.append(i)\\n          return transcribe(R,C, g, R*C-1)\\n      \\n      for g in all_grids(R,C,M):\\n          sol = solution(R,C,g)\\n          if sol is None:\\n              continue\\n          return transcribe(R,C, g, sol)\\n      return None\\n              \\n      \\n  def output_grid(R,C,g):\\n      for i in range(R):\\n          for j in range(C):\\n              if i*C+j not in g:\\n                  sys.stdout.write(\".\")\\n              else:\\n                  sys.stdout.write(\"*\")\\n          sys.stdout.write(\"\\n\")\\n  \\n  if __name__ == \"__main__\":\\n      T = int(raw_input())\\n      for i in range(1,T+1):\\n          R,C,M = map(int, raw_input().split())\\n          print \"Case #%d:\" % i\\n          print printed_sol(solve(R,C,M))\\n", "target": "25", "substitutes": {"R": ["N", "Rh", "AR", "TR", "U", "RH", "Rule", "G", "X", "RL", "RE", "J", "RIP", "RR", "KR", "I", "MR", "W", "Rs", "Cl", "Range", "K", "RC", "Rob", "RW", "SR", "RO", "Right", "RN", "Re", "L", "Res", "D", "A", "ER", "JR", "B", "RS", "Rec", "S", "BR", "RP", "CR", "E", "H", "Br", "F", "IR", "DR", "Run", "V", "WR", "RM", "GR", "Ra", "NR", "Q", "P", "LR", "RA", "RG"], "C": ["N", "JC", "Cs", "CF", "U", "Count", "G", "Ch", "X", "SC", "Cu", "O", "WC", "CL", "I", "CNN", "Size", "CA", "W", "YC", "Cl", "CM", "VC", "CE", "K", "EC", "NC", "GC", "DC", "CP", "ERC", "CC", "L", "Sc", "D", "A", "CN", "MC", "B", "S", "FC", "c", "KC", "CV", "CR", "E", "H", "CS", "CI", "F", "V", "CU", "Y", "Q", "P", "Central", "CT", "Con"], "M": ["N", "U", "MO", "G", "X", "J", "p", "O", "LM", "REM", "I", "man", "MR", "mm", "W", "MD", "ML", "NM", "CM", "JM", "Mi", "MP", "MT", "MX", "m", "MN", "L", "Multi", "EM", "D", "A", "OM", "MC", "FM", "B", "DM", "S", "MA", "IM", "MB", "E", "H", "F", "V", "RM", "Y", "Q", "P", "cm", "MM", "MF", "PM"], "lp": ["LP", "pit", "pp", "Mp", "len", "lv", "pl", "mp", "pm", "p", "lf", "mm", "li", "lr", "pa", "layer", "CP", "loc", "pre", "m", "L", "l", "PP", "ls", "np", "lvl", "dl", "fp", "base", "LI", "RP", "lb", "bp", "cm", "b", "P", "cp", "LM", "LR", "lc"], "placed": ["LP", "mounted", "shaped", "owned", "places", "pos", "mi", "packed", "selected", "len", "pl", "led", "pm", "p", "powered", "section", "claimed", "mr", "added", "holder", "mm", "li", "left", "ed", "pool", "pa", "PL", "loc", "pre", "position", "central", "place", "replace", "m", "shared", "used", "l", "seq", "represented", "Position", "arent", "pg", "B", "aid", "reg", "named", "filled", "LI", "aced", "lb", "paid", "controlled", "sp", "occupied", "ordered", "ld", "fe", "marked", "matched", "found", "b", "cm", "P", "no", "numbered", "assembled"], "rem": ["resp", "ps", "xp", "pm", "me", "pres", "rm", "REM", "ret", "im", "mm", "master", "repl", "pop", "ref", "exp", "rep", "pa", "prev", "re", "pre", "place", "m", "remote", "original", "cl", "jp", "rest", "recent", "kept", "prem", "reg", "cache", "remove", "sp", "min", "Rem", "cm", "mem", " Rem"], "res": ["rys", "ws", " results", "args", "ress", "ras", "ret", "css", "Rs", "cases", "exp", "errors", "yrs", "obj", "ins", "Res", "ES", "powers", "rss", "rev", "rh", "reg", "details", "RES", "err", "runs", "ries", "resp", "rules", "params", "ps", "qs", "works", "mr", "features", "rus", "maps", "nos", "cs", "es", "remote", "seq", "os", "rest", "breaks", "models", "rez", "blocks", "rs", "sr", "bs", "relations", "ids", "rc", "changes", "p", "pres", "gr", "max", "resolution", "rx", "response", "rel", "cells", "ris", "re", "loc", "resh", "rates", "S", "eps", "Result", "result", "lines", "Results", "js", "results", "ms", "vals", "ns", "rows", "pers", "resources", "arr", "ios", "right", "RS", " Res", "ros", "req", "ons"], "i": ["ini", "aci", "hi", "api", "I", "im", "zi", "anti", "ni", "sci", "io", "uri", "position", "index", "bi", "ti", "c", "ji", "phi", "ami", "y", "err", "ind", "iw", "ia", "chi", "gi", "si", "mi", "z", "li", "ui", "iter", "n", "l", "ii", "yi", "ic", " bi", "ri", "b", "f", "o", "eni", "e", "id", "slice", "p", "multi", "t", "pi", "ai", "v", "ir", "m", "ci", "iu", "info", "xi", "ip", "ori", "iq", "mini", "u", "image", "ie", "it", "cli", "ios", "ei", "di", "int", "ix", "isi", "oi", "lc", "qi"], "sub_sol": ["subpubrel", "subpubsol", " sub_sl", "sub_Sol", "sub_sql", "subpubol", "Sub_Sol", "Sub_sql", "sub_sl", " sub_oln", "Sub_sol", "subjsol", "subjSol", " sub_ol", "subregsol", "subjrel", "sub_oln", "subregol", " sub_Sol", "subpuboln", "sub_rel", "subjsql", "subregsl", "subjoln", "sub_ol", "subjol", " sub_rel", "subregSol"], "s": ["e", "settings", "si", "sg", "ws", "results", "d", "ps", "ns", "p", "sb", "su", "resolution", "sys", "spec", "cells", "sub", "ses", "cs", "sets", "ages", "sq", "es", "m", "n", "sf", "l", "sim", "ls", "os", "ss", "sl", "fs", "S", "c", "details", "sec", "sp", "ions", "states", "sr", "sc", "sites", "o", "search", "se"], "left_edge": ["full_edge", "left_ee", "left_side", "full_side", "full_ee", "left_end", "full_end", "right_line", "left_line", "right_side"], "top_edge": ["top_hop", "top_event", "top_ide", "topingend", "middle_line", "top_gate", "middle\u00b7edge", "root_ge", "top_end", "top\u00b7ide", "bottom_line", "topingedge", "top_line", " top_end", "root_edge", "middle\u00b7line", "bottom_event", "middle\u00b7distance", "top_distance", "middle_distance", "top_element", "middle_ide", " top_element", "bottom_size", "topingge", "middle_edge", " top_ge", "middle\u00b7ide", "root_hop", "top\u00b7edge", "top_ge", "topingelement", "top_size", "top\u00b7distance", "top\u00b7line", "root_gate"], "right_edge": ["top_enter", "right\u00b7enter", "down_Edge", "right__tie", "right_pe", "right\u00b7end", "right__Edge", "top_end", "down_tie", "right_age", "down_age", "right__age", "right_tie", "right__edge", "right\u00b7edge", "top_pe", "right_Edge", "right_enter", "down_edge", "right\u00b7pe", "right_end"], "bottom_edge": ["wrong_link", "wrong\u00b7edge", "bottom_layer", "bottom\u00b7anne", "wrong\u00b7anne", "bottom\u00b7link", "wrong_anne", "bottom_ense", "top_error", "bottom\u00b7edge", "top_end", "bottom_line", "wrong\u00b7link", "bottom_enter", "front_line", "top_ense", " bottom_grade", "wrong_layer", "bottom_degree", "bottom_link", " bottom_end", "bottom_end", " bottom_enter", "wrong\u00b7layer", "bottom_anne", "front_edge", "front_degree", "bottom_grade", "front_route", "bottom_route", "bottom\u00b7layer", "bottom_error", "wrong_edge"], "g": ["e", "gen", "gi", "sg", "mc", "ge", "d", "gs", "G", "play", "h", "eg", "p", "gl", "erg", "gr", "bg", "msg", "go", "ch", "gc", "cfg", "mg", "gu", "LG", "v", "group", "GS", "GG", "GV", "GC", "w", "q", "m", "gp", "n", "l", "gb", "cl", "Group", "CG", "ig", " G", "GF", "gre", "groups", "reg", "c", "gh", "k", "ic", "Gs", "ga", "b", "rg", "f", "game", "gg", "gm"], "num_zeroes": ["num_zeroms", "num_zoops", "num_zooms", "num_zzoom", "num_zzos", "num_zos", "num_eroms", "num_zonops", "num_zzoes", "num_zooes", "num_erops", "num_zops", "num_zereros", "num_zeros", "num_zoom", "num_zoos", "num_zoes", "num_zoeros", "num_zerops", "num_zoms", "num_zeroom", "num_zoneros", "num_zonoes", "num_zzops", "num_eroes", "num_zonos", "num_zooom", "num_eros"], "x": ["e", "xa", "xs", "xi", "xt", "id", "px", "X", "xxxxxxxx", "h", "xp", "xf", "p", "xy", "width", "xml", "xes", "u", "rx", "z", "t", "cross", "tx", "yx", "exp", "v", "xb", "dx", "w", "m", "rex", "index", "ex", "xc", "wx", "xxx", "xxxx", "c", "xe", "work", "int", "xx", "ix", "y", "f", "ax"], "a": ["e", "xi", "br", "d", "aa", "ta", "ac", "p", "ar", "ana", "ba", "u", "z", "an", "t", "ai", "ha", "na", "sa", "ra", "ae", "w", "m", "n", "la", "ea", "alpha", "A", "wa", "ad", "ca", "aaa", "all", "c", "ja", "int", "ya", "result", "ma", "ga", "active", "y", "b", "err", "f", "o", "area", "ia"], "r": ["e", "br", "d", "h", "p", "ur", "pr", "ar", "er", "u", "z", "t", "v", "attr", "re", "w", "m", "n", "l", "c", "k", "rs", "sr", "nr", "y", "b", "err", "f", "array", "o"], "connected": ["connect", "br", "linked", "charged", "tun", "broken", "opened", "selected", "h", "rounded", "red", "online", "thin", "rupt", "finished", "conn", "bound", "ended", "tested", "established", "closed", "on", "ed", "compatible", "sect", "hidden", "connection", "loc", "normal", "public", "central", "rational", "valid", "function", "graph", "rev", "wired", "visible", "reg", "supported", "controlled", " disconnected", "ordered", "Connect", "open", "active", "run", "path", "con", "loaded", "complex", "sc", "no", "f", "fitted", "shown"], "sol": ["gi", "sg", "col", "gs", "sql", "poly", "gl", "gr", "GS", "group", "mol", "q", "ls", " G", "GF", "grid", "graph", "groups", "reg", "model", "gn", "Gr", "ol", "GR", "min", "Sol", "cr", "gm"]}}
{"code": "T = int(raw_input())\\n  \\n  def solve(C, F, X):\\n      best = x/2\\n      buildTime, speed = 0, 2\\n      while True:\\n          buildTime += C/speed\\n          if buildTime > best:\\n              break\\n          speed += F\\n          best = min(best, buildTime + X/speed)\\n      return best\\n  \\n  for z in xrange(T):\\n      c, f, x = map(float, raw_input().split())\\n      print \"Case #%d: %.7f\" % (z+1, solve(c, f, x))\\n", "target": "26", "substitutes": {"T": ["N", "G", "TF", "Time", "O", "I", "TS", "TB", "W", "t", "M", "Z", "K", "TH", "L", "D", "A", "R", "B", "S", "TT", "time", "E", "H", "V", "Y", "Q", "P", "CT"], "C": ["N", "CF", "U", "G", "Cu", "CL", "I", "W", "M", "Z", "K", "CM", "DC", "CC", "L", "D", "A", "R", "MC", "B", "S", "FC", "CR", "E", "H", "CI", "V", "CU", "Y", "Q", "P"], "F": ["N", "CF", "U", "G", "Fs", "FD", "O", "I", "W", "BF", "M", "Z", "K", "Fi", "L", "D", "FO", "EF", "R", "A", "GF", "PF", "FH", "B", "S", "Fine", "FE", "E", "H", "SF", "V", "FF", "Y", "Q", "P", "FG", "FW"], "X": ["N", "U", "XL", "Time", "ZX", "XP", "XXX", "I", "W", "Z", "K", "CC", "L", "D", "R", "B", "Ex", "S", "Work", "time", "E", "H", "V", "DX", "FF", "Y", "Q", "P", "XX"], "best": [" largest", "size", "star", "rand", "d", "default", "good", "score", "highest", "correct", "eff", "final", "std", " fastest", "p", "opt", "max", "start", "case", "master", "r", "peak", "t", "largest", " Best", "top", "effective", "w", "rank", "l", "live", "index", "fast", "ss", "right", " closest", "last", "winner", "better", "all", "Best", "new", "s", "round", "end", "success", "k", "result", "est", "worst", "latest", "cost", " winner", " better", "b", "EST", "g", "orig"], "buildTime": ["breakTime", " buildSize", "buildingLength", "updateTimes", "buildSize", "buildingTime", "breakRate", " buildLength", "BuildCount", "BuildTime", "buildingForce", "buildingSpeed", "BuildRate", "breakCount", "Buildtime", "buildLength", "updateSpeed", "buildtime", " buildTimes", " buildSpeed", "updateLength", "buildForce", " buildRate", "buildingRate", "buildTimes", " buildCount", "buildRate", "buildingSize", "buildSpeed", "buildingCount", "updateCount", "updateTime", "buildCount", "BuildSize", " buildForce", "breakTimes", "BuildForce", " buildtime", "buildingtime", "updateRate"], "speed": ["size", "stop", "weight", "name", "score", "distance", "step", "power", "width", "length", "match", "ime", "start", "performance", "force", "send", "level", "sum", "error", "slow", "race", "ness", "boost", "strength", "type", "rank", "sim", "grade", "seed", "Speed", "comp", "order", "peed", "rate", "fast", "EED", "value", "style", "time", "mass", "cycle", "delay", "dist", "second", "cost", "draw", "scale"], "z": ["zy", "d", "step", "tz", "az", "zo", "slice", "p", "xy", "j", "ez", "zh", "u", "count", "zi", "zen", " i", "t", "Z", "pop", "nz", "q", "n", "iz", "sim", "zip", "s", "time", "int", "end", "init", "cz", "y", "ze", "code", "gz", "ind", "zone"], "c": ["cf", "e", "d", "col", "i", "h", "ac", "p", "ce", "u", "r", "t", "co", "cu", "v", "cs", "w", "uc", "cy", "n", "ci", "l", "cl", "cent", "xc", "cod", "k", "nc", "y", "sc", "con", "b", "fc", "cm", "cr", "lc"], "f": ["cf", "e", "fd", "d", "fr", "i", "p", "fx", "j", "fi", "u", "t", "fb", "file", "v", "w", "sf", "m", "l", "rf", "fl", "fp", "inf", "fs", "fe", "y", "b", "fc"], "x": ["e", "xs", "d", "name", "default", "i", "sex", "h", "xp", "xf", "p", "xy", "fx", "width", "u", "rx", "t", "cross", "v", "dx", "example", "w", "q", "n", "m", "l", "index", "ex", "fast", "data", "xc", "s", "test", "k", "ic", "xx", "ix", "y", "Y", "b", "ax", "search"]}}
{"code": "\\n  T = int(raw_input())\\n  \\n  def generate(R, C, a, sw):\\n      if sw:\\n          R, C = C, R\\n      res = [['*']*C for i in xrange(R)]\\n      for i in xrange(len(a)):\\n          for j in xrange(a[i]):\\n              if sw:\\n                  res[j][i] = '.'\\n              else:\\n                  res[i][j] = '.'\\n      res[0][0] = 'c'\\n      return str(res)[2:-2].replace(' ', '').replace(\"'\",'').replace('[', '').replace('],','\\n').replace(',', '')\\n  \\n  \\n  def solveEq(k, s, x1):\\n      if 2*(x1 + k - 2) > s or k*x1 < s:\\n          return None\\n      r = [0]*k\\n      r[0] = r[1] = x1\\n      s -= 2*x1\\n      for i in xrange(k-2, 0, -1):\\n          t = min(x1, s - 2*i + 2)\\n          r[k-i] = t\\n          s -= t\\n      return r\\n  \\n  def solve(R, C, M):\\n      S = R*C\\n      nm = S - M\\n      if R == 1 or C == 1:\\n          if R == 1:\\n              return '*'*M + '.'*(S-M-1) + 'c'\\n          else:\\n              return '*\\n'*M + '.\\n'*(S-M-1) + 'c'\\n      else:\\n          sw = False\\n          if R > C:\\n              R, C = C, R\\n              sw = True\\n          if nm == 2 or nm == 3 or nm == 5 or nm == 7 or (R == 2 and nm%2 == 1 and nm > 1):\\n              return \"Impossible\"\\n          if nm == 1:\\n              return generate(R, C, [1], sw)\\n          for k in xrange(2, R+1):\\n              for x1 in xrange(2, C+1):\\n                  r = solveEq(k, nm, x1)\\n                  if r != None:\\n                      return generate(R, C, r, sw)\\n          return \"Something wrong\"\\n  \\n  for z in xrange(T):\\n      c, f, x = map(int, raw_input().split())\\n      print \"Case #%d:\\n%s\" % (z+1, solve(c, f, x))\\n", "target": "26", "substitutes": {"T": ["N", "TR", "G", "X", "TN", "Time", "O", "I", "TB", "W", "TM", "Z", "K", "L", "D", "A", "B", "TT", "TC", "H", "F", "V", "NT", "Y", "P"], "R": ["N", "Rh", "TR", "U", "rb", "RH", "G", "X", "J", "Tr", "O", "RR", "KR", "I", "MR", "W", "Rs", "Range", "K", "RW", "SR", "RO", "RN", "Re", "L", "Res", "D", "A", "JR", "B", "RS", "RP", "CR", "E", "H", "F", "V", "DR", "Run", "RM", "GR", "Y", "Ra", "NR", "Q", "P", "ARR", "RT", "RA", "RG"], "C": ["N", "Cs", "U", "G", "Ch", "X", "Co", "SC", "Cu", "O", "CL", "I", "CA", "W", "YC", "NC", "CM", "K", "VC", "CE", "EC", "DC", "CC", "L", "Sc", "D", "A", "CN", "B", " c", "CO", "c", "KC", "CR", "E", "H", "CS", "CI", "F", "V", "Cos", "CU", "Y", "NR", "Q", "P", "CT", "Con"], "a": ["at", "e", "args", "aa", "ac", "p", "ar", "u", "z", "an", "arr", "ai", "am", "na", "sa", "ra", "ae", "w", "n", "Na", "m", "alpha", "A", "wa", "ca", "da", "au", "aaa", "all", "c", "x", "ab", "aj", "b", "array", "f", "o", "area"], "sw": ["WS", "ws", "default", "rew", "sk", "ww", "h", "coll", "oss", "cv", "now", "sm", "switch", "su", "im", "sh", "W", "response", " Sw", "tw", "stream", "wn", "row", "rw", "sa", "RW", "hw", "ew", "w", "sf", "ow", "igh", "hop", "zero", "wa", "nw", "sl", "rh", "wx", "sync", "zip", "SW", "cc", "sn", "wrap", "wt", "sp", "null", "x", "nc", "wp", "sr", "WR", "wh", "est", "ng", "sc", "array", "iw", "cr", "Sw", " SW"], "res": ["resp", "e", "results", "ms", "br", "vals", " results", "args", "qs", "ns", "rows", "rc", "p", "ras", "pres", "gr", "ret", "mr", "resolution", "arr", "response", "Rs", "rep", "ris", "re", "cs", "q", "es", "remote", "Res", "os", "rest", "rss", "data", "rev", "rh", "eps", "reg", "sol", "c", " Res", "rez", "blocks", "rs", "RES", "result", "x", "bs", "rem", "err", "cr", "runs", "req", "ons"], "i": ["e", "gi", "si", "ini", "xi", "ip", "d", "iq", "mi", "id", "p", "I", "u", "im", "zi", "ie", "z", "li", "pi", "ai", "ui", "v", "io", "q", "n", "ci", "m", "l", "ik", "ij", "ii", "index", "ei", "ti", "di", "yi", "c", "int", "ji", "phi", "x", "y", "iu", "b", "f", "o", "g", "qi"], "j": ["e", "gi", "si", "xi", "br", "d", "uj", "str", "J", "p", "u", "ie", "jl", "li", "z", "jj", "v", "ni", "q", "n", "ci", "l", "jp", "kj", "ii", "ij", "je", " ii", "c", "ja", "jc", "ji", "x", "y", "aj", "iu", "b", "ind", "IJ", "f", "o", "g", "oj"], "k": ["N", "d", "sk", "h", "p", "ch", "max", "u", "z", "kw", "kk", "it", "_", "v", "K", "ky", "ke", "w", "tk", "q", "kin", "m", "n", "ak", "l", "ku", "ks", "uk", "c", "key", "x", "y", "ck", "b", "ok", "f", "o", "ko", "mk", "g"], "s": ["e", "si", "ws", "sign", "xs", "ms", "d", "gs", "ps", "ns", "sk", "h", "p", "u", "su", "z", "v", "sym", "ds", "sa", "cs", "w", "sq", "es", "m", "n", "l", "ls", "os", "south", "ss", "ks", "sync", "c", "sec", "tp", "se", "sv", "rs", "x", "second", "y", "ats", "b", "f", "o", "span", "g", "sup", "ts"], "x1": ["f0", "zN", "z2", "xN", " xone", "X1", "w2", "xione", "XN", " x4", "p0", "w1", " xn", "X2", "z1", "Xone", "wn", "y2", " x2", "X4", "x0", "y1", "xone", "z4", "p2", "f1", " x0", "x2", "X0", "Xn", "xn", "y0", "xi1", " xN", "p1", "x4", "xi2", "xi0"], "r": ["e", "range", "br", "rb", "rr", "d", "fr", "nor", "rc", "h", "p", "pr", "ur", "RR", "ar", "mr", "u", "er", "z", "Rs", "v", "lr", "ir", "re", "w", "q", "m", "n", "hr", "l", "ru", "right", "rh", "rt", "c", "kr", "rs", "x", "result", "sr", "nr", "b", "err", "f", "rg", "o", "cr", "P", "g"], "t": ["e", "at", "tt", "d", "ta", "h", "p", "u", "z", "tf", "total", "v", "w", "m", "n", "tm", "l", "ot", "ti", "te", "c", "new", "tp", "wt", "test", "x", "tor", "target", "y", "b", "f", "o", "g", "ts"], "M": ["N", "U", "G", "ME", "X", "MI", "J", "O", "I", "W", "Ms", "MD", "NM", "MQ", "CM", "K", "JM", "Z", "GM", "m", "n", "L", "MN", "Mo", "D", "A", "MC", "B", "DM", "E", "H", "F", "V", "Y", "Q", "P", "LM"], "S": ["N", "U", "G", "X", "SC", "SL", "O", "I", "W", "Rs", "Single", "K", "SR", "FS", "n", "SE", "L", "D", "A", "SH", "B", "RS", "Su", "E", "H", "F", "SS", "V", "SU", "NS", "Y", "SA", "Q", "P"], "nm": ["N", "range", "ny", "ms", "nv", "km", "ns", "ne", "mi", "nor", "dm", " n", "num", "TN", "pm", "me", "rm", "mr", "sm", "Num", "mm", "nt", "bm", "Ms", "fm", "NM", "NC", "CM", "ym", "ni", " N", "CW", "nn", "arm", "nl", "m", "n", "NL", "MN", "mid", "np", "nw", "md", "all", "c", "rn", "Ns", " NM", "nc", "RM", "nr", "NT", "NW", "NS", "NR", "cm", "LM", "PM", "cn", "nom", "nu", "wm", "mn"]}}
{"code": "\\n  def readint():\\n      return int(sys.stdin.readline())\\n  \\n  def readfloatarray():\\n      return map(float, sys.stdin.readline().strip().split())\\n  \\n  def readintarray():\\n      return map(int, sys.stdin.readline().strip().split())\\n  \\n  def readpairs(start=0):\\n      elems = readintarray()[start:]\\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\\n  \\n  def readstring():\\n      return sys.stdin.readline()[:-1]\\n  \\n", "target": "27", "substitutes": {"start": ["starting", "size", "stop", "pos", "shift", "offset", "id", "len", "step", "next", "p", "length", "max", "Start", "add", "count", "send", "get", "part", "source", "limit", "index", "sort", "use", "end", "int", "init", "s", "st", "set", "x", "min", "ind", "skip", "se", "check"], "elems": ["elecs", " elements", "elemas", "elm", "leles", "elema", "lecs", "elements", "olements", " elema", "elmas", "elma", "lems", "lemas", " elem", " eleles", " elecs", "lem", "eleles", "elles", "olema", "elms", "olem", "olems", "elem", "elcs", "elments", " elemas"], "i": ["e", " u", "gi", "si", "ini", "xi", "ip", "col", "mi", "pos", "id", " n", "abi", "p", " I", "j", "I", "u", "zi", "z", "t", "pi", "li", "ai", "v", " x", "n", "ci", "l", "ii", "index", "bi", "ti", "di", "c", "int", "k", "x", "ix", "ri", "iu", "oi", "ind", "f", "o", " j", "eni", "qi"]}}
{"code": "\\n  \\n  \\n  directions = list(itertools.product([1, 0, -1], [1, 0, -1]))\\n  def count_neighbors(table, r, c):\\n      cols = len(table[0])\\n      rows = len(table)\\n      return sum(table[r + x][c + y] == \"*\" for x, y in directions \\n                  if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\\n  \\n  def is_valid(table):\\n      cols = len(table[0])\\n      rows = len(table)\\n      for r in xrange(rows):\\n          for c in xrange(cols):\\n              has_zero = any(table[r + x][c + y] == 0 for x, y in directions \\n                              if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\\n              if table[r][c] != \"*\" and not has_zero:\\n                  return False\\n  \\n      return True\\n  \\n  \\n  def draw_table(table, hide=False):\\n      cols = len(table[0])\\n      rows = len(table)\\n      ascii_table = \"\"\\n      for r in xrange(rows):\\n          for c in xrange(cols):\\n              if table[r][c] != \"*\":\\n                  ch = \"c\" if r == 0 and c == 0 else \".\"\\n                  table[r][c] = count_neighbors(table, r, c) if not hide else ch\\n  \\n              ascii_table += str(table[r][c])\\n  \\n          ascii_table += \"\\n\"\\n  \\n      return ascii_table[:-1]\\n  \\n  def solve(R, C, M):\\n      r = c = 0\\n      current_mines = R * C\\n      table = [[\"*\"] * C for k in xrange(R)]\\n      while M < current_mines:\\n          if table[r][c] == '*':\\n              table[r][c] = \".\"\\n              current_mines -= 1\\n  \\n          if current_mines > M and r + 1 < R and table[r+1][c] == \"*\":\\n              table[r+1][c] = \".\"\\n              current_mines -= 1\\n  \\n          draw_table(table)\\n          c += 1\\n          if c >= C:\\n              c = 0\\n              r += 1\\n  \\n      return table\\n  \\n  for i in xrange(readint()):\\n      R, C, M = readintarray()\\n  \\n      print \"Case #%d:\" % (i + 1)\\n      if M < (R * C) - 1:\\n          table = solve(R, C, M)\\n          if is_valid(table):\\n              print draw_table(table, hide=True)\\n          else:\\n              table = solve(C, R, M)\\n              rotated = [[\"*\"] * C for k in xrange(R)]\\n              for r in xrange(R - 1, -1, -1):\\n                  for c in xrange(C):\\n                      rotated[R - r - 1][c] = table[c][r]\\n  \\n              print draw_table(rotated, hide=True) if is_valid(rotated) else \"Impossible\"\\n  \\n      elif M == R * C:\\n          print \"Impossible\"\\n  \\n      else:\\n          table = [[\"*\"] * C for k in xrange(R)]\\n          table[0][0] = '.'\\n          print draw_table(table, hide=True)\\n", "target": "27", "substitutes": {"directions": ["Directations", "structions", "Directories", "Directions", "Direction", "directors", "direction", "Directors", "connectors", "Directives", "connections", "irectations", "directives", "directories", "connection", "directionion", "irectors", "structors", "directionives", "struction", "directionors", "irectories", "irection", "structations", "irectives", "directations", "directionions", "irections", "connectories"], "table": ["col", "che", "package", "section", "story", "out", "sequence", "case", "object", "row", "div", "database", "query", "machine", "stage", "conference", "cell", "character", "db", "MM", "page", "range", "rule", "tab", "month", "interface", "count", "root", "flat", "Table", "system", "element", "body", "time", "app", "test", "window", "buffer", "transform", "code", "b", "array", "f", "server", "e", "module", "tr", "slice", "header", "feature", "channel", "input", "config", "master", "file", "t", "form", "comment", "error", "layer", "stable", "m", "core", "tree", "function", "data", "block", "model", "key", "chart", "frame", "result", "this", "term", "chain", "article", "container", "figure", "cube", "panel", "view", "list", "image", "output", "total", "stream", "bar", "connection", "session", "source", "profile", "q", "TABLE", "py", "batch", "base", "style", "cache", "round", "python", "message", "course", "choice"], "r": ["e", "range", "yr", "rr", "rb", "br", "d", "tr", "fr", "rc", "h", "p", "ur", "pr", "j", "gr", "ar", "mr", "dr", "u", "er", "t", "Rs", "v", "lr", "row", "rec", "ra", "ir", "re", "w", "q", "vr", "m", "n", "hr", "l", "ru", "right", "g", "rh", "rt", "ro", "user", "kr", "a", "rs", "rd", "sr", "nr", "b", "rg", "f", "err", "o", "cr"], "c": ["col", "rec", "cy", "uc", "ca", "xc", "unc", "cm", "con", "fc", "count", "z", "cat", "_", "cs", "w", "n", "l", "cd", "cc", "s", "a", "code", "b", "f", "o", "e", "d", "rc", "dc", "p", "oc", "ce", "ar", "t", "co", "v", "m", "ci", "function", "pc", "ec", "sc", "chain", "cf", "mc", "h", "ac", "u", "ct", "cu", "vc", "q", "cl", "cache", "course", "nc", "arc", "cn", "cr", "cp", "g", "lc"], "cols": ["collines", "colws", "colsi", "critlines", "columnws", " colws", " colses", "colops", "columnx", "columnsym", "COLws", "poolubs", "paths", "lengthws", "colerences", "poollines", "llx", "lengthses", "colx", "lengthsym", "llcs", "colsym", "COLs", "icols", "columncs", "lengths", "columnops", "lls", "pools", "methodses", "filops", " colours", "patherences", "methods", "columnlines", "colcs", "critments", "contractws", "icolws", "COLses", "colways", "columnubs", "filses", "rolls", "icolses", "columns", "colses", " colss", "cals", " colsym", "calerences", "calments", "contractcs", "critubs", "crits", "llsi", "rollss", "calcs", "filx", "llses", " colerences", "columnsi", "contractsi", " colways", "pathments", "llws", "llops", "contracts", "columnments", "fils", "colments", "pathcs", "methodws", " colments", "colss", "columnses", "rollours", "colours", "colubs", "rollways", "poolments", " colcs"], "rows": ["classes", "rules", "relations", "heads", "results", "ws", "roc", "events", "members", "ids", "rew", "rc", "opens", "length", "features", "ubs", "holes", "planes", "levels", "values", "cells", "cases", "errors", "acks", "row", "rw", "vers", "types", "ows", "cs", "forms", "cats", "pages", "ow", "fields", "rown", "rooms", "ums", "ks", "breaks", "rh", "groups", "views", "posts", "frames", "times", "checks", "rog", "olds", "blocks", "orders", "tracks", "flows", "rs", "items", "wards", "roots", "reports", "tests", "lines", "users", "OWS", "boxes", "ros", "cr", "runs", "ips", "ries"], "x": ["e", "ys", "xs", "xt", "my", "d", "xi", "ay", "id", "px", "X", "h", "fx", "xy", "j", "ye", "p", "xml", "xes", "u", "ct", "z", "rx", "t", "cross", "tx", "on", "v", "com", "w", "cy", "n", "m", "ci", "l", "wy", "py", "index", "ex", "xc", "any", "wx", "work", "s", "win", "time", "int", "a", "ey", "dy", "lex", "ic", "ya", "xx", "ix", "Y", "b", "f", "o", "ax", "es"], "y": ["e", "ny", "ys", "yr", "zy", "d", "col", "iy", "yy", "ay", "h", "yt", "sy", "ye", "j", "p", "z", "ky", "t", "ty", "ym", "yl", "hy", "w", "cy", "n", "oy", "ies", "py", "m", "ci", "wy", "yi", "s", "ey", "dy", "ry", "ya", "yn", "vy", "Y", "b", "yd", "f"], "has_zero": ["have_zero", " has_alpha", "has_one", "has_alpha", " has_0", "have_one", "have_money", "has_money", "have_Zero", "has_Zero", "has_0", " has_one"], "hide": ["sea", "Hide", "hi", "shift", " show", "id", "info", "h", " hidden", "que", "layout", "disable", "ride", "child", "fake", "display", "secret", "case", "li", "ha", "sub", "home", "rub", "bar", "ise", "loc", "fit", "broad", "late", "ib", "label", "use", "ider", "ide", "fe", "shadow", "bare", "cover", "mask", "isi", "code", "ignore", "plot", "hidden", "shown", "show", "hid"], "ascii_table": ["asciiettable", "asciini_comb", "ascii_list", "asciui_cache", "ascii_Table", "ascii_comb", "asciui_table", "ascii2section", "asciio_section", "asciui_body", "ascii_body", "asciio_table", "ascii_term", "asciini_section", "asciini_list", "ascii_trace", "asciui_Table", "asciini_term", "asciini_table", "asciini_body", "asciio_trace", "ascii_cache", "ascii_section", "asciietcomb", "ascii2trace", "asciietlist", "ascii2table"], "ch": ["e", "CH", "cb", "Ch", "che", "h", "j", "channel", "sch", "case", "chan", "root", "div", "cur", "conf", "n", "ci", "cl", "cor", "chrom", "cd", "char", "chart", "character", "code", "chain", "f", "cp", "cr", "chi", "qu"], "R": ["N", "Rh", "U", "RH", "G", "X", "J", "O", "RR", "I", "MR", "W", "Rs", "K", "RO", "SR", "Re", "L", "D", "A", "T", "B", "S", "RP", "CR", "E", "H", "F", "V", "GR", "RM", "Y", "Ra", "Q", "P", "RA", "Cr"], "C": ["N", "CF", "U", "G", "Ch", "X", "O", "I", "W", "CM", "K", "VC", "Z", "DC", "CW", "CC", "L", "D", "A", "MC", "T", "B", "S", "CR", "E", "H", "F", "CI", "V", "CU", "Y", "Q", "P"], "M": ["N", "U", "G", "X", "MW", "Ma", "J", "O", "I", "W", "MS", "Z", "CM", "K", "Mi", "m", "L", "D", "MC", "T", "B", "S", "E", "H", "F", " m", "V", "RM", "Y", "Q", "P", "MM", "MF"], "current_mines": ["current_versiones", "current_manes", "current_minsES", "current_Miner", "current_minss", "current_manions", "current_mnions", "current_minsodes", "current_minors", "current_monions", "current_partors", "current_masterizes", "current_mnodes", "current_mones", "current_mnes", "current_masteres", "current_minizes", "current_mine", "current_millES", "current_partis", "current_Minizes", "current_versions", "current_partes", "current_Mines", "current_mons", "current_minses", "current_minser", "current_minsors", "current_minis", "current_partions", "current_minES", "current_minsis", "current_millions", "current_maxions", "current_minodes", "current_minsions", "current_minions", "current_mnizes", "current_versionizes", "current_versionions", "current_miner", "current_Minions", "current_masterions", "current_minsizes", "current_Mine", "current_miller", "current_masterodes", "current_manors", "current_monizes", "current_maxizes", "current_milles", "current_manis", "current_mins", "current_maxes", "current_minse", "current_maxe", "current_MinES"], "k": ["d", "km", "ces", "ct", "ky", "kk", "get", "co", "K", "ket", "cs", "ke", "w", "q", "n", "ku", "cor", "ks", "cc", "ner", "a", "ck", "cr", "g", "king"]}}
{"code": "\\n  def iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tyield line_index, line.strip().split(' ')\\n  \\n  def iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 1\\n  \t\tcase = []\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not line_index % n:\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \\n  def iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 0\\n  \t\tnew_case = True\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tif new_case:\\n  \t\t\t\tnew_case = False\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \t\t\t\tassert len(line.strip().split(' ')) == 1\\n  \t\t\t\tlines_left = int(line.strip())\\n  \t\t\t\tif not lines_left:\\n  \t\t\t\t\tnew_case = True\\n  \t\t\t\t\tyield case_counter, case\\n  \t\t\t\tcontinue\\n  \t\t\tif lines_left:\\n  \t\t\t\tlines_left -= 1\\n  \t\t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not lines_left:\\n  \t\t\t\tnew_case = True\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\\n  def part_of_list_to_int(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(int(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_int(array):\\n  \treturn part_of_list_to_int(array, [True] * len(array))\\n  \\n  def part_of_list_to_float(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(float(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_float(array):\\n  \treturn part_of_list_to_float(array, [True] * len(array))\\n  \\n  def get_max_array_on_index(array, index):\\n  \telem_len = len(array[0])\\n  \tassert index < elem_len\\n  \tfor elem in array:\\n  \t\tassert elem_len == len(elem)\\n  \tmax_sub = array[0][index]\\n  \tmax_elem = array[0]\\n  \tfor elem in array:\\n  \t\tif elem[index] > max_sub:\\n  \t\t\tmax_sub = elem[index]\\n  \t\t\tmax_elem = elem\\n  \treturn max_elem\\n  \\n  def list_index_in_sorted_with_position(a_list, value, pos):\\n  \tlist_len = len(a_list)\\n  \tif list_len == 1:\\n  \t\tif a_list[0] == value:\\n  \t\t\treturn pos\\n  \t\treturn -1\\n  \tif a_list[list_len/2] > value:\\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\\n  \telse:\\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\\n  \t\\n  def list_index_in_sorted_list(a_list, value):\\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\\n  \\n  def copy_list(list):\\n  \tres = []\\n  \tfor elem in list:\\n  \t\tres.append(elem)\\n  \treturn res\t\\n  \\n  \\n  def solve(C, F, X):\\n  \tfarms_num = 0\\n  \twaiting_for_farms = 0\\n  \tproduction_rate = 2\\n  \tfinal_run_time = X / production_rate\\n  \tresult = final_run_time + waiting_for_farms\\n  \t\\n  \tprint \"%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f\" % (farms_num,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tproduction_rate,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfinal_run_time,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twaiting_for_farms,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult)\\n  \t\t\\n  \\n  \t\\n  \twhile True:\\n  \t\tfarms_num += 1\\n  \t\twaiting_for_farms += C / production_rate\\n  \t\tproduction_rate += F\\n  \t\tfinal_run_time = X / production_rate\\n  \t\tnew_result = final_run_time + waiting_for_farms\\n  \t\tprint \"%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f\" % (farms_num,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tproduction_rate,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfinal_run_time,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twaiting_for_farms,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew_result)\\n  \t\tif new_result > result:\\n  \t\t\treturn result\\n  \t\tresult = new_result\\n  \t\\n  def calc_result(case):\\n  \tresult = None\\n  \t\\n  \tC = float(case[0])\\n  \tF = float(case[1])\\n  \tX = float(case[2])\\n  \tprint C, F, X\\n  \t\\n  \tresult = solve(C, F, X)\\n  \tprint result\\n  \t\\n  \treturn result\\n  \\n  def main(filepath):\\n  \tstart_time = time.time()\\n  \twith file('output.txt', 'wb') as f_out:\\n  \t\t\\n  \t\tfor case_index, case in iterate_cases_1lpc(filepath):\\n  \t\t\t\\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\\n  \t\t\tresult = calc_result(case)\\n  \t\t\t\\n  \t\t\tf_out.write(\"Case #%d: %.07f\\n\" % (case_index, result))\\n  \t\t\t\t\\n  if __name__ == '__main__':\\n  \tmain(sys.argv[1])\\n", "target": "28", "substitutes": {"filepath": [" filecase", " filePath", "Filepath", "FilePath", "fname", " filename", "Filename", "fcase", "filecase", "filename", "fpath", "fPath", "Filecase", "filePath"]}}
{"code": "\\n  def iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tyield line_index, line.strip().split(' ')\\n  \\n  def iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 1\\n  \t\tcase = []\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not line_index % n:\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \\n  def iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 0\\n  \t\tnew_case = True\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tif new_case:\\n  \t\t\t\tnew_case = False\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \t\t\t\tassert len(line.strip().split(' ')) == 1\\n  \t\t\t\tlines_left = int(line.strip())\\n  \t\t\t\tif not lines_left:\\n  \t\t\t\t\tnew_case = True\\n  \t\t\t\t\tyield case_counter, case\\n  \t\t\t\tcontinue\\n  \t\t\tif lines_left:\\n  \t\t\t\tlines_left -= 1\\n  \t\t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not lines_left:\\n  \t\t\t\tnew_case = True\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\\n  def part_of_list_to_int(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(int(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_int(array):\\n  \treturn part_of_list_to_int(array, [True] * len(array))\\n  \\n  def part_of_list_to_float(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(float(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_float(array):\\n  \treturn part_of_list_to_float(array, [True] * len(array))\\n  \\n  def get_max_array_on_index(array, index):\\n  \telem_len = len(array[0])\\n  \tassert index < elem_len\\n  \tfor elem in array:\\n  \t\tassert elem_len == len(elem)\\n  \tmax_sub = array[0][index]\\n  \tmax_elem = array[0]\\n  \tfor elem in array:\\n  \t\tif elem[index] > max_sub:\\n  \t\t\tmax_sub = elem[index]\\n  \t\t\tmax_elem = elem\\n  \treturn max_elem\\n  \\n  def list_index_in_sorted_with_position(a_list, value, pos):\\n  \tlist_len = len(a_list)\\n  \tif list_len == 1:\\n  \t\tif a_list[0] == value:\\n  \t\t\treturn pos\\n  \t\treturn -1\\n  \tif a_list[list_len/2] > value:\\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\\n  \telse:\\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\\n  \t\\n  def list_index_in_sorted_list(a_list, value):\\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\\n  \\n  def copy_list(list):\\n  \tres = []\\n  \tfor elem in list:\\n  \t\tres.append(elem)\\n  \treturn res\t\\n  \\n  \\n  def conj_mat(a):\\n  \tR = len(a)\\n  \tC = len(a[0])\\n  \tres = [['.' for _ in xrange(R)] for __ in xrange(C)]\\n  \tfor i in xrange(R):\\n  \t\tfor j in xrange(C):\\n  \t\t\tres[j][i] = a[i][j]\\n  \treturn res\\n  \\n  def one_line_builder(R, C, M):\\n  \tres = []\\n  \tres.extend(['*'] * M)\\n  \tres.extend(['.'] * (C - M))\\n  \tres[-1] = 'c'\\n  \treturn [res]\\n  \t\\n  def two_line_builder(R, C, M):\\n  \tline = []\\n  \tline.extend(['*'] * (M / 2))\\n  \tline.extend(['.'] * (C - M / 2))\\n  \tres = [line, copy_list(line)]\\n  \tres[1][-1] = 'c'\\n  \tif M%2 == 1:\\n  \t\tres[0][-1] = '*'\\n  \treturn res\\n  \t\\n  def three_line_builder(R, C, M):\\n  \tres = [['.' for _ in xrange(C)] for __ in xrange(R)]\\n  \tres[-1][-1] = 'c'\\n  \tm = min([M, R * C - 9])\\n  \tstop_flag = False\\n  \tfor j in xrange(C):\\n  \t\tif stop_flag:\\n  \t\t\tbreak\\n  \t\tfor i in xrange(R):\\n  \t\t\tif m == 0:\\n  \t\t\t\tstop_flag = True\\n  \t\t\t\tbreak\\n  \t\t\tres[i][j] = '*'\\n  \t\t\tm -= 1\\n  \tprint i,j\\n  \tif i == 2:\\n  \t\tres[1][j-1] = '.'\\n  \t\tif j == C - 3:\\n  \t\t\tres[0][j] = '*'\\n  \t\telse:\\n  \t\t\tres[0][-1] = '*'\\n  \t\\n  \tif M <= R * C - 9:\\n  \t\treturn res\\n  \telse:\\n  \t\tm = M - (R * C - 9)\\n  \t\tassert m not in [2, 4, 6, 7, 9]\\n  \t\tassert m > 0\\n  \t\tassert m < 10\\n  \t\t\\n  \t\tres[-3][-3] = '*'\\n  \t\tm -= 1\\n  \t\tif m == 0: return res\\n  \t\tres[-2][-3] = '*'\\n  \t\tres[-1][-3] = '*'\\n  \t\tm -= 2\\n  \t\tif m == 0: return res\\n  \t\tres[-3][-2] = '*'\\n  \t\tres[-3][-1] = '*'\\n  \t\tm -= 2\\n  \t\tif m == 0: return res\\n  \t\tres[-2][-2] = '*'\\n  \t\tres[-2][-1] = '*'\\n  \t\tres[-1][-2] = '*'\\n  \t\tm -= 3\\n  \t\tif m == 0: return res\\n  \t\tassert False\\n  \t\\n  \t\\n  \t\\n  def over_three_line_builder(R, C, M):\\n  \tif M <= (R - 3) * C:\\n  \t\tres = [['*' for _ in xrange(C)] for __ in xrange(M / C)]\\n  \t\tflag = False\\n  \t\tif (M % C) != (C - 1):\\n  \t\t\tline = ['*' for _ in xrange(M % C)]\\n  \t\t\tline.extend(['.' for _ in xrange(C - (M % C))])\\n  \t\telse:\\n  \t\t\tline = ['*' for _ in xrange((M % C) - 1)]\\n  \t\t\tline.extend(['.' for _ in xrange((C - (M % C)) + 1)])\\n  \t\t\tflag = True\\n  \t\tres.append(line)\\n  \t\tindex = len(res)\\n  \t\tres.extend([['.' for _ in xrange(C)] for __ in xrange(R - len(res))])\\n  \t\tif flag:\\n  \t\t\tres[index][0] = '*'\\n  \t\tres[-1][-1] = 'c'\\n  \t\tassert len(res) == R\\n  \t\tassert len(res[0]) == C\\n  \t\treturn res\\n  \telse:\\n  \t\tres = [['*' for _ in xrange(C)] for __ in xrange(R - 3)]\\n  \t\tM -= (R - 3) * C\\n  \t\ttmp = three_line_builder(3, C, M)\\n  \t\tif len(tmp) != 3: # error msg\\n  \t\t\treturn tmp\\n  \t\tres.extend(tmp)\\n  \t\treturn res\\n  \t\\n  def solve(R, C, M):\\n  \tres = None\\n  \t\\n  \tif M == R * C:\\n  \t\treturn 'Impossible'\\n  \tif R >= 3 and C >= 3:\\n  \t\tif R*C - M in [7, 5, 3, 2]:\\n  \t\t\treturn 'Impossible'\\n  \t\treturn over_three_line_builder(R, C, M)\\n  \t\t\\n  \telif R != 1 and C != 1:  #which means one of them is 2, and the other not 1\\n  \t\tif (R*C - M) % 2 == 1:\\n  \t\t\tif M < R*C - 1:\\n  \t\t\t\treturn 'Impossible'\\n  \t\tif M + 2 == R * C:\\n  \t\t\treturn 'Impossible'\\n  \t\telse:\\n  \t\t\tif R == 2:\\n  \t\t\t\treturn two_line_builder(R, C, M)\\n  \t\t\telse:\\n  \t\t\t\ttmp = two_line_builder(C, R, M)\\n  \t\t\t\treturn conj_mat(tmp)\\n  \t\\n  \telse:\t\t\t\t\t#which means one of them is 1\\n  \t\tif R == 1:\\n  \t\t\treturn one_line_builder(R, C, M)\\n  \t\telse:\\n  \t\t\ttmp = one_line_builder(C, R, M)\\n  \t\t\treturn conj_mat(tmp)\\n  \t\t\\n  \treturn res\\n  \\n  def mat_to_str(a):\\n  \tif a in ['Impossible', 'Not Implemented']:\\n  \t\treturn a\\n  \tstr_out = ''\\n  \tfor row in a:\\n  \t\tfor elem in row:\\n  \t\t\tstr_out += elem\\n  \t\tstr_out += '\\n'\\n  \treturn str_out[:-1]\\n  \t\\n  def calc_result(case):\\n  \tresult = None\\n  \t\\n  \tR = int(case[0])\\n  \tC = int(case[1])\\n  \tM = int(case[2])\\n  \tprint R, C, M\\n  \t\\n  \tresult = solve(R, C, M)\\n  \t\\n  \tstr_out = mat_to_str(result)\\n  \tm = str_out.count('*')\\n  \tassert (m==0 or m==M)\\n  \tprint str_out\\n  \t\\n  \treturn '\\n%s' % str_out\\n  \\n  def main(filepath):\\n  \tstart_time = time.time()\\n  \twith file('output.txt', 'wb') as f_out:\\n  \t\t\\n  \t\tfor case_index, case in iterate_cases_1lpc(filepath):\\n  \t\t\t\\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\\n  \t\t\tresult = calc_result(case)\\n  \t\t\t\\n  \t\t\tf_out.write(\"Case #%d: %s\\n\" % (case_index, result))\\n  \t\t\t\t\\n  if __name__ == '__main__':\\n  \tmain(sys.argv[1])\\n", "target": "28", "substitutes": {"filepath": [" filecase", " filePath", "Filepath", "FilePath", "fname", " filename", "Filename", "fcase", "filecase", "filename", "fpath", "fPath", "Filecase", "filePath"]}}
{"code": "\\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      t = int(f.readline())\\n      for _t in range(t):\\n  \\n          C, F, X = [float(x) for x in f.readline().split()]\\n  \\n          base = X / 2.0\\n  \\n          new_strategy = old_strategy = base\\n          time_building = 0\\n          farms = 0\\n          fastest_speed = 2\\n          while new_strategy <= old_strategy:\\n              old_strategy = new_strategy\\n              time_building += C / fastest_speed\\n              farms += 1\\n              fastest_speed += F\\n              new_strategy = time_building + X / fastest_speed\\n              \\n          \\n          print (\"Case #\" + str(_t+1) + \": \" + str(old_strategy))\\n      \\n  \\n", "target": "29", "substitutes": {"f": ["e", "fw", "cf", "fd", "d", "fr", "i", "fed", "h", "bf", "p", "fi", "fo", "u", "af", "r", "handler", "z", "file", "fb", "tf", "form", "v", "stream", "of", "feed", "w", "sf", "n", "m", "l", "rf", "function", "fl", "fp", "inf", "fs", "body", "c", "s", "df", "fe", "b", "fc", "o", "fen", "g"], "fn": ["full", "fw", "fd", "name", "len", "syn", "bf", "p", "fil", "fi", "lf", "fun", "wl", "feat", "fm", "file", "fb", "output", "wn", "bn", "filename", "w", "sf", "n", "kn", "utf", "function", "fl", "fp", "fs", "func", "c", "ln", "unc", "sn", "gn", "FN", "nc", "path", "b", "format", "fc", "dn", "fen", "o", "txt", "fat"], "t": ["at", "e", "tt", " T", "d", "i", "num", "ta", "tz", "p", "start", "z", "pt", "nt", "tf", "ty", "dt", "v", "w", "type", "n", "m", "l", "T", "ti", "c", "s", "temp", "time", "int", "tp", "test", "y", "b", "o", "ts"], "_t": ["_T", " ift", "_c", " _f", "_y", " _tt", " _c", "_f", " ifc", " _y", " _T", "_tt", " ifT"], "C": ["N", "CF", "Cs", "U", "G", "SC", "Cu", "I", "Size", "CA", "W", "M", "EC", "CM", "K", "DC", "CC", "L", "Sc", "D", "A", "T", "B", " c", "S", "FC", "c", "CV", "CR", "E", "CI", "V", "CU", "Y", "Q", "P", "CT"], "F": ["N", "CF", "U", "G", "O", "I", "W", "M", "Z", "L", "D", "A", "FO", "R", "T", "FH", "B", "PF", "FR", "E", "SF", "H", "V", "FF", "Y", "Q", "P", "MF", "AF", "FW"], "X": ["N", "CF", "U", "Length", "XL", "XP", "Time", "IX", "I", "Size", "TX", "W", "M", "Z", "K", "MX", "CC", "L", "D", "R", "T", "FX", "B", "S", "FC", "Scale", "Base", "E", "H", "time", "UX", "V", "FF", "Y", "Q", "P", "XX", "FW"], "x": ["e", " col", "xi", "i", "h", "xf", "fx", "p", "xy", " int", "u", "ct", "rx", "z", "r", "tx", "ft", " ff", "v", "dx", "w", "n", "l", "index", "ex", "xc", "xxx", "wx", " ft", "xxxx", "c", "test", "xx", "y", " code", " fe", "g"], "base": ["N", "size", "U", "weight", "default", "offset", "i", "unit", "p", "Delta", "max", "start", "count", "fixed", "q", "n", "L", "basic", "B", "c", "Scale", "temp", "Base", "time", "mass", "null", "y", "Y", "b", "chain", "area", "scale"], "new_strategy": ["new_struration", "new_standateg", "new_druration", "new_trategy", "new_strateg", "new_truration", "new_brategy", "new_strategic", "new_stracy", "new_drateg", "new_Strient", "new_brateg", "new_specacy", "new_specategic", "new_Strateg", "new_dracy", "new_trient", "new_Stracy", "new_trategic", "new_drategy", "new_trateg", "new_specateg", "new_bruration", "new_Strategic", "new_strient", "new_Strategy", "new_specategy", "new_drategic", "new_standategy", "new_standient"], "old_strategy": ["old_strategic", "old_trateg", "old_grategy", "old_spategy", "old_trategic", "old_spateg", "old_brategy", "old_drategy", "old_stranger", "old_spanger", "old_cranger", "old_drategic", "old_crateg", "old_tranger", "old_stranty", "old_Strategy", "old_Strategic", "old_grateg", "old_stracy", "old_strateg", "old_tracy", "old_brateg", "old_branty", "old_spategic", "old_crategy", "old_Strateg", "old_gracy", "old_tranty", "old_brategic", "old_Stracy", "old_trategy", "old_drateg"], "time_building": [" time_builders", "time_build", "time\u00b7finding", "time_calling", " time_finding", " time_calling", "time\u00b7testing", " time_adding", "time_testing", "time_increasing", " time_testing", " time_increasing", "time_finding", "time\u00b7calling", "time_adding", " time_reporting", "time_builders", " time_build", "time\u00b7building", "time_reporting"], "farms": ["sfares", "infarms", "farming", "fares", "sfarming", "infarm", "Farms", "infarming", "infares", "ifarms", "ifarm", "Farm", "sfarms", "Fares", "ifarming", "Farming", "ifares", "farm", "sfarm"], "fastest_speed": ["fastest_size", "fastest_performance", "fastest2speed", "fastess_scale", "fastest4duration", "fastess\u00b7scale", "fastest_length", "fastgest_length", "fastestactime", "fastest_time", "fastest2size", "fastest\u00b7size", "fastess_size", "fastess_speed", "fastgest_time", "fastestacperformance", "fastEST_time", "fastEST_performance", "fastEST_speed", "fastest_duration", "fastest4speed", "fastest4time", "fastest2scale", "fastgest_speed", "fastest\u00b7scale", "fastgest_duration", "fastest\u00b7speed", "fastess\u00b7size", "fastest_scale", "fastestacspeed", "fastess\u00b7speed"]}}
{"code": "\\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      t = int(f.readline())\\n      for _t in range(t):\\n  \\n          R, C, M = [int(x) for x in f.readline().split()]\\n          free_spots = R * C - M - 1\\n  \\n          if M == 0:\\n              answer = [[\".\" for x in range(C)] for y in range(R)]\\n              answer[0][0] = \"c\"\\n          elif R == 1:\\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\\n          elif C == 1:\\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\\n              answer = zip(*answer[::-1])\\n          elif free_spots >= 3: # and M % R >= 2:\\n              answer = [[\"*\" for x in range(C)] for y in range(R)]\\n              answer[0][0] = \"c\"\\n              answer[0][1] = \".\"\\n              answer[1][1] = \".\"\\n              answer[1][0] = \".\"\\n              free_spots -= 3\\n              tr, br, c = 0, 1, 2\\n              if c >= C:\\n                  tr, br, c = 2, 3, 0\\n              for _i in range(free_spots):\\n                  if answer[tr][c] == \"*\":\\n                      answer[tr][c] = \".\"\\n                  elif answer[br][c] == \"*\":\\n                      answer[br][c] = \".\"\\n                      if c < C-1:\\n                          c+=1\\n                      else:\\n                          tr, br = tr + 2, br + 2\\n                          c = 0\\n                          if br == R:\\n                              br, tr = br-1, tr-1\\n                  \\n          else:\\n              answer = [\"Impossible\",]\\n  \\n          \\n          \\n          print (\"Case #\" + str(_t+1) + \":\")\\n          for _i in answer:\\n              print \"\".join(_i)\\n      \\n  \\n", "target": "29", "substitutes": {"f": ["e", "cf", "fd", "d", "fr", "i", "fed", "h", "bf", "p", "j", "fo", "u", "af", "r", "handler", "z", "file", "tf", "fb", "form", "v", "stream", "feed", "w", "sf", "n", "l", "fp", "fs", "ff", "c", "df", "F", "fe", "path", "b", "fc", "o", "fen", "g"], "fn": ["cf", "full", "fd", "name", "num", "len", "syn", "bf", "p", "fil", "ll", "fun", "wl", "r", "nt", "fm", "file", "tf", "output", "fb", "feat", "bn", "filename", "source", "method", "sf", "n", "kn", "l", "function", "fl", "fp", "fs", "func", "ln", "c", "sn", "unc", "FN", "F", "nc", "fin", "path", "format", "fat", "fc", "o", "dn", "txt"], "t": ["e", "tt", "d", "offset", "i", "ta", "tz", "h", "p", "start", "r", "nt", "z", "qt", "tf", "dt", "v", "w", "type", "n", "tm", "l", "T", "ti", "c", "temp", "int", "wt", "tp", "tmp", "b", "o", "ts"], "_t": ["_m", "_T", "_p", " _T", " _p", " _m"], "R": ["N", "Rh", "U", "RH", "G", "X", "RR", "MR", "r", "W", "Rs", "K", "RC", "RW", "SR", "RO", "L", "D", "A", "T", "B", "RS", "S", "c", "RP", "CR", "E", "H", "F", "V", "RM", "Y", "Ra", "Q", "P", "RT", "RA", "RG"], "C": ["N", "U", "G", "X", "SC", "Cu", "O", "CL", "CA", "r", "W", "YC", "Cl", "CM", "Z", "K", "VC", "GC", "DC", "RC", "CC", "L", "D", "A", "MC", "T", "B", "S", "c", "CV", "CR", "E", "H", "AC", "F", "CI", "V", "CU", "Y", "Q", "P", "Cr"], "M": ["N", "U", "MO", "G", "X", "J", "O", "LM", "I", "MR", "r", "W", "MS", "Z", "CM", "Mi", "MT", "MX", "MN", "L", "Mo", "D", "A", "MU", "MC", "T", "B", "DM", "S", "MA", "E", "H", "AM", "F", "V", "RM", "Y", "Q", "P", "MM", "MF"], "x": ["e", "xs", "xt", "ux", "d", "xi", "i", "num", "X", "h", "xp", "opt", "xf", "p", "xy", "j", "mx", "input", " X", "u", "rx", "z", "r", "tx", "yx", "_", "v", "xb", "ym", "dx", "w", "q", "n", "l", "index", "ex", "xc", "text", "wx", " cx", "c", " tx", "int", "test", "k", "xx", "b", "ax"], "free_spots": ["free_tockets", "free_splOTS", "free_pies", "free_pOTS", "free_Spockets", "free_Spots", "free_ponents", "free_SPot", "free_Spokes", "free_mokes", "free_tots", "free_powers", "free_spaceot", "free_spaceots", "free_splowers", "free_spies", "free_SpOTS", "free_pot", "free_Spies", "free_spot", "free_mOTS", "free_spowers", "free_splot", "free_spaceonents", "free_pokes", "free_SPOTS", "free_tot", "free_ties", "free_spaceOTS", "free_Spowers", "free_pockets", "free_mot", "free_Spot", "free_mots", "free_spOTS", "free_spokes", "free_spockets", "free_pots", "free_splots", "free_SPonents", "free_SPots", "free_sponents"], "answer": ["page", "e", "size", "update", "results", "evidence", "score", "swers", "ee", "word", "document", "section", "address", "complete", "answered", " answers", "en", "archive", "after", "z", "r", "offer", "response", "output", "number", "question", "v", "cash", "comment", "field", "string", "side", "ell", "ae", "respond", "replace", "support", "equ", "audio", "entry", "grade", "knowledge", "expression", "order", "data", "issue", "average", "round", "energy", "python", "description", "result", "message", "cover", "reply", "do", "array", "option", "search", "Answer"], "y": ["yr", "my", "d", "ay", "om", "h", "ye", "p", "j", "im", "z", "ym", "am", "yl", "w", "cy", "q", "py", "yu", "yo", "k", "ya", "ma", "Y", "cm", "yd", "b", "o"], "m": ["e", "ms", "mc", "em", "mi", "i", "mp", "pm", "p", "man", "mu", "u", "mm", "r", "z", "an", "v", "ym", "am", "w", "n", "l", "ml", "mod", "c", "ma", "b", "cm", "o", "g", "mn"]}}
{"code": "def solve_case(t):\\n      c, f, x = [float(num) for num in raw_input().strip().split()]\\n      current_time_usage = x / 2.0\\n  \\n      n = 1\\n      build_farm_time = c / (2.0 + float((n - 1) * f))\\n      attemp_time_usage = (x / (2.0 + float(n * f))) + build_farm_time\\n  \\n      while attemp_time_usage < current_time_usage:\\n          current_time_usage = attemp_time_usage\\n  \\n          n += 1\\n          build_farm_time += c / (2.0 + float((n - 1) * f))\\n          attemp_time_usage = (x / (2.0 + float(n * f))) + build_farm_time\\n  \\n      print 'Case #%d: %.7f' % (t, current_time_usage,)\\n  \\n  def main():\\n      t = int(raw_input().strip())\\n      for i in range(1, t + 1):\\n          solve_case(i)\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "target": "30", "substitutes": {"t": ["at", "tt", "e", "xt", "d", "ta", "tz", "p", "j", "start", "u", "ct", "z", "nt", "pt", "tf", "dt", "v", "tw", "tu", "w", "type", "m", "l", "ot", "T", "tn", "ti", "template", "temp", "tc", "time", "tp", "int", "test", "st", "y", "b", "o", "ts"], "c": ["e", "cf", "size", "d", "col", "C", "dc", "p", "ch", "ce", "max", "u", "count", "z", "r", "v", "cs", "circ", "w", "cy", "ci", "m", "l", "xc", "cc", "time", "k", "nc", "y", "con", "b", "cm", "cr", "cn", "lc"], "f": ["e", "cf", "fd", "d", "fac", "h", "xf", "p", "bf", "j", "u", "z", "fm", "file", "form", "fb", "v", "of", "w", "sf", "m", "l", "rf", "fp", "inf", "fs", "s", "time", "F", "fe", "b", "float", "fc", "o", "g"], "x": ["e", "xs", "xi", "d", "X", "h", "xp", "xf", "p", "xy", "fx", "max", "en", "xes", "u", "ct", "z", "rx", "r", "number", "v", "w", "q", "l", "index", "ex", "xc", "s", "time", "int", "k", "xx", "ix", "y", "b", "o", "g"], "num": ["dom", "gen", "name", "id", "fn", "unit", "child", "u", "Num", "number", "uu", "coord", "nm", "sum", "um", "un", "nn", "m", "index", "tim", "nw", "text", "img", "param", "nb", "temp", "NUM", "bin", "sn", "dim", "node", "result", "nr", "umi", "nat", "mon", "term", "con", "b", "nam", "uni", "nom", "nu"], "current_time_usage": ["current_time_use", "current_time_used", "current_time_Usage", "current_time_access", "current_time_current"], "n": ["N", "e", "size", "d", "name", "ne", "ns", "fn", "nor", "p", "j", "none", "en", "conn", "u", "non", "z", "nt", "an", "number", "r", "v", "nm", "nan", "un", "w", "m", "np", "l", "g", "nb", "ln", "s", "sn", "k", "nc", "min", "y", "b", "no", "o", "span", "cn", "nu"], "build_farm_time": ["build_farm_name", "build_field_time", "build_field_Time", "build_field_times", "build_time_times", "build_farmthetype", "build_time_time", "build_farmthetimes", "build_field_name", "build_time_clock", "build_farm_Time", "build_farm_times", "build_farm_type", "build_farm_clock", "build_farmthetime"], "attemp_time_usage": ["attemp_timesusage", "attemp_timefmem", "attemp_timefusage", "attemp_time_use", "attemp_timesuse", "attemp_time_used", "attemp_time_size", "attemp_time_history", "attemp_timefuse", "attemp_timefused", "attemp_timeshistory", "attemp_time_capacity", "attemp_time_mem", "attemp_timesused"], "i": ["e", "si", "xi", "ip", "d", "id", "p", "j", "I", "inner", "start", "u", "im", "z", "r", "li", "pi", "v", "type", "m", "l", "ii", "index", "di", "ti", "time", "int", "k", "phi", "y", "iu", "b", "ind"]}}
{"code": "class Sweeper(object):\\n      def __init__(self, r, c, m):\\n          self.matrix = [['.' for j in range(0, c)] for i in range(0, r)]\\n          self.matrix[0][0] = 'c'\\n  \\n          self.r = r\\n          self.c = c\\n          self.m = m\\n          self.current_r = r\\n          self.current_c = c\\n          self.current_m = m\\n  \\n      def fill_row(self):\\n          if self.current_r >= 3 and self.current_m >= self.current_c:\\n              for i in range(0, self.current_c):\\n                  self.matrix[self.current_r - 1][i] = '*'\\n              self.current_r -= 1\\n              self.current_m -= self.current_c\\n              return True\\n          return False\\n  \\n      def fill_col(self):\\n          if self.current_c >= 3 and self.current_m >= self.current_r:\\n              for i in range(0, self.current_r):\\n                  self.matrix[i][self.current_c - 1] = '*'\\n              self.current_c -= 1\\n              self.current_m -= self.current_r\\n              return True\\n          return False\\n  \\n      def fill_partial(self):\\n          if self.current_r >= 3:\\n              fill_num = min(self.current_m, self.current_c - 2)\\n              for i in range(0, fill_num):\\n                  self.matrix[self.current_r - 1][self.current_c - 1 - i] = '*'\\n              self.current_m -= fill_num\\n              if fill_num > 0:\\n                  self.current_r -= 1\\n          if self.current_c >= 3:\\n              fill_num = min(self.current_m, self.current_r - 2)\\n              for i in range(0, fill_num):\\n                  self.matrix[self.current_r - 1 - i][self.current_c - 1] = '*'\\n              self.current_m -= fill_num\\n              if fill_num > 0:\\n                  self.current_c -= 1\\n          if self.current_m > 0:\\n              return False\\n          else:\\n              return True\\n  \\n      def fill_special_one(self):\\n          if self.current_r * self.current_c == self.current_m + 1:\\n              for i in range(0, self.current_r):\\n                  for j in range(0, self.current_c):\\n                      self.matrix[i][j] = '*'\\n              self.matrix[0][0] = 'c'\\n              self.current_r = 0\\n              self.current_c = 0\\n              self.current_m = 0\\n              return True\\n          return False\\n  \\n      def fill_special_col(self):\\n          if self.current_c == 1 and self.current_r > self.current_m:\\n              for i in range(0, self.current_m):\\n                  self.matrix[self.current_r - 1 - i][0] = '*'\\n              self.matrix[0][0] = 'c'\\n              self.current_m = 0\\n              self.current_r = 0\\n              self.current_c = 0\\n              return True\\n          return False\\n  \\n      def fill_special_row(self):\\n          if self.current_r == 1 and self.current_c > self.current_m:\\n              for i in range(0, self.current_m):\\n                  self.matrix[0][self.current_c - 1 - i] = '*'\\n              self.matrix[0][0] = 'c'\\n              self.current_m = 0\\n              self.current_r = 0\\n              self.current_c = 0\\n              return True\\n          return False\\n  \\n  def print_matrix(matrix):\\n      for row in matrix:\\n          s = ''\\n          for col in row:\\n              s += col\\n          print s\\n  \\n      \\n  def solve_case(t):\\n      r, c, m = [int(num) for num in raw_input().strip().split()]\\n      sweeper = Sweeper(r, c, m)\\n      print 'Case #%d:' % (t,)\\n      if sweeper.fill_special_one() or sweeper.fill_special_col() or sweeper.fill_special_row():\\n          print_matrix(sweeper.matrix)\\n          return\\n      f_result = True\\n      while sweeper.current_m > 0 and f_result:\\n          f_result = False\\n          f_result |= sweeper.fill_row()\\n          f_result |= sweeper.fill_col()\\n      if sweeper.current_m > 0:\\n          sweeper.fill_partial()\\n      if sweeper.current_m > 0:\\n          print 'Impossible'\\n      else:\\n          print_matrix(sweeper.matrix)\\n  \\n  def main():\\n      t = int(raw_input().strip())\\n      for i in range(1, t + 1):\\n          solve_case(i)\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "target": "30", "substitutes": {"self": ["ws", "extra", "args", "Self", "manager", "complete", "man", "case", "object", "http", "kernel", "wx", "parent", "lc", "worker", "node", "site", "err", "page", "resp", "per", "event", "pos", "plus", "word", "qa", "ch", "er", "instance", "map", "res", "field", "w", "method", "type", "n", "remote", "l", "os", "world", "plugin", "all", "ack", "time", "app", "a", "x", "b", "f", "o", "game", "user", "full", "e", "client", "d", "default", "next", "p", "lf", "go", "config", "context", "master", "host", "cross", "form", "sys", "co", "v", "layer", "error", "public", "data", "g", "new", "temp", "result", "this", "utils", "other", "ng", "ok", "load", "skip", "private", "ctx", "proc", "results", "ns", "high", "coll", "h", "hand", "view", "me", "point", "ref", "spec", "group", "part", "q", "cl", "comp", "missing", "right", "raw", "www", "func", "base", "cache", "work", "style", "mass", "k", "mate", "line", "no", "es", "wrapper"], "r": ["e", "range", "rr", "rb", "d", "fr", "rc", "h", "radius", "p", "ar", "mr", "dr", "er", "u", "v", "ra", "ir", "re", "w", "n", "hr", "l", "rf", "R", "ru", "right", "rh", "ro", "k", "rs", "x", "rd", "sr", "nr", "y", "b", "rg", "f", "cr"], "c": ["e", "mc", "d", "rc", "h", "ac", "C", "dc", "p", "ch", "ce", "u", "count", "z", "cat", "v", "cu", "rec", "w", "cy", "q", "n", "ci", "l", "cc", "a", "k", "x", "nc", "y", "b", "cm", "f", "con", "cr", "cn", "g", "lc"], "m": ["e", "range", "ms", "mc", "d", "mi", "h", "ac", "p", "pm", "rm", "mr", "mu", "max", "u", "mm", "z", "M", "v", "w", "q", "n", "l", "md", "a", "k", "x", "y", "b", "cm", "f", "o", "g"], "matrix": ["Matrix", "matcost", "attric", "tq", " matric", "Matbox", "atpack", "atcost", "latment", "matric", "matrow", "tment", "Matrib", "dimbox", "mensor", "dimrib", "Matment", "dimrix", "atrices", "attrix", "atrow", "latq", "atrix", " matrices", "Matcost", "matment", "latrices", "matpack", "attmap", "atric", "matq", "latrix", "attrices", "trices", " matpack", "matrices", "mrib", "mrix", "Matrices", "attrow", "matbox", "Matvector", "atmap", "matmap", " matmap", "Matq", "latrow", " matvector", " matcost", "dimensor", "matensor", "latric", "Matensor", "atvector", "trix", "matrib", "mbox", "attpack", "matvector"], "j": ["gi", "xi", " ti", "abi", "ime", " o", "iii", "iv", "zi", "z", "ie", "ai", "ati", "ij", " ni", "bi", "di", " si", " ii", "je", "ja", "ji", "k", " bi", "ri", "b", " b", "o"], "i": ["e", "gi", "si", "ini", "xi", "ip", "mi", "id", "mini", "h", "p", "I", "u", "zi", "ie", "z", "multi", "li", "pi", "ai", "ui", "ni", "v", "io", "ir", "ci", "n", "l", "ij", "ii", "index", "ei", "bi", "ti", "di", "yi", "int", "ji", "k", "ic", "phi", "x", "ix", "y", "ri", "iu", "b", "oi", "f", "o", "iw", "ia", "qi"], "current_r": ["current_rr", "currentMR", "currentAllc", "currentDc", "reported_rg", "currentDr", "current_rf", "reported_e", "currentVrate", "reported_mr", "current_e", "currentMc", "current_reb", "reported_m", "currentXc", "currentVr", "currentDmr", "current_mr", "currentQc", "reported_l", "currentDreb", "currentSr", "currentPrb", "current__c", "currentQr", "reported_rr", "current_R", "reported_reb", "current__r", "currentVc", "currentScol", "reported_R", "current__e", "current_col", "current___c", "currentQm", "currentPr", "current_l", "currentPm", "currentPc", "current_rb", "currentXr", "reported_rate", "reported_rc", "currentXm", "currentMm", "reported_c", "currentSc", "reported_row", "reported_r", "current___reb", "current_rg", "currentAllrf", "reported_col", "current_row", "currentVm", "current_rate", "currentXrg", "current___mr", "currentSm", "reported_hr", "current__m", "reported_rb", "currentAllm", "currentMr", "reported_rf", "currentAllr", "current_hr", "current_rc", "current___r", "currentQrr"], "current_c": ["current_mc", "currentParc", "currentMemfc", "currentDc", "currentDr", "currentMemc", "currentAh", "current_cur", "currentMemr", "current_h", "reported_rn", "end", "reported_m", "currentXc", "current_rn", "current_count", "current_n", "pos", "currentAc", "currentIPc", "currentLr", "currentIcount", "_", "current_b", "currentIPm", "reported_count", "w", "reported_rec", "all", "currentAr", "reported_b", "currentMemm", "reported_fc", "current_pc", "current_rec", "current_w", "reported_mc", "current_d", "currentImc", "currentPr", "currentPm", "currentPc", "currentParr", "reported_d", "currentXr", "currentLrec", "current_fc", "reported_rc", "currentXm", "reported_h", "currentPd", "currentIPcin", "reported_w", "reported_c", "currentIc", "reported_r", "current_cin", "reported_cur", "currentLm", "reported_cin", "currentIPr", "currentDmc", "currentParrn", "currentAcur", "reported_n", "reported_pc", "currentLc", "currentXpc", "current_rc", "currentIr", "currentDcount", "currentParw"], "current_m": ["current_mc", "currentOr", "currentDc", "currentOco", "currentDr", "reported_nr", "current64c", "currentJc", "currentWm", "currentKnr", "currentOm", "currentDm", "current64nm", "currentWc", "reported_m", "current64r", "current_am", "current_ar", "current_b", "currentWmu", "currentJm", "currently_p", "currentOc", "reported_am", "reported_b", "currentJr", "currently_c", "reported_ar", "current_p", "reported_mc", "reported_mu", "currentWr", "currentJp", "currentKc", "reported_c", "reported_r", "reported_nm", "currently_r", "current_mu", "current_nm", "reported_f", "currentDmc", "current64m", "currently_m", "reported_co", "current_f", "current_nr", "current_co", "currentKr", "currentKm"], "fill_num": ["fillensum", "fillennum", "fill_net", " fill_gap", "fill_common", "ill_none", " fill_dim", "fill2num", "fill_none", " fill_multi", "fill64gap", " fill_name", "fill___net", "fillNnum", "fillennone", "fill2sum", "update_n", " fill_Num", "fill67gap", "fill67num", "fillingum", "fillingnu", "fillingnum", "fill_nu", "update_nu", "fill_nb", " fill_nb", "fill67nb", "ill_sum", "update_um", "fill___sum", "fill___num", " fill_number", "fill64nb", " fill_sum", "update_sum", "fill_multi", "ill_common", "fill_Num", "fill32mom", "fill___Num", " fill_net", "fill64num", "fill_dim", " fill_mom", "fill_n", "fillNcommon", "fillNnone", "fill2number", "fill64sum", "fill_um", "fill_name", "fill_gap", "fill2name", "ill_num", "fill_mom", "fillencommon", "fill32Num", "fillingnone", "update_num", "fill67sum", "fill32multi", "fill32num", "fill_number", "fillNsum", "fill_sum", "update_none"]}}
{"code": "__author__ = 'jrokicki'\\n  \\n  RL = lambda: sys.stdin.readline().strip()\\n  IA = lambda: map(int, RL().split(\" \"))\\n  LA = lambda: map(long, RL().split(\" \"))\\n  FA = lambda: map(float, RL().split(\" \"))\\n  \\n  T = int(sys.stdin.readline())\\n  \\n  for CASE in range(T):\\n      C,F,X = FA()\\n      tick = 2.\\n      answer = X/tick\\n  \\n      game = 0\\n      while True:\\n          span = C / tick\\n          tick += F\\n          test = game + span + X/tick\\n          game = game + span\\n  \\n          if test < answer:\\n              answer = test\\n          else:\\n              if tick > X:\\n                  break\\n  \\n      print \"Case #%d: %s\" % (CASE+1, answer)\\n  \\n", "target": "31", "substitutes": {"__author__": ["__title_", "__authorable", "__author_", "__versionable", "__version_", "__title__", " __authorable", "__version__", " __version__", "__typeable", "__type__", " __versionable", "__titleable", " __version_", " __author_", "__type_"], "RL": ["LP", "EL", "XL", "UL", "URL", "IL", "SL", "HL", "LS", "LL", "RR", "DL", "CL", "LT", "MR", "LC", "RB", "FL", "ML", "QL", "HR", "RC", "STR", "SR", "VR", "REL", "LB", "NL", "L", "LU", "JR", "YL", "BR", "RP", "Ul", "CR", "rl", "VL", "String", "IR", "OL", "DR", "WR", "El", "TL", "ARR", "RAL", "BL", "LE", "LR"], "IA": ["AE", "AA", "SC", " CA", "ABC", "CA", "TA", "NI", "NC", "GA", " ABC", "IC", "IE", " AI", "ci", "CC", "AU", "LI", "CV", "ACC", "AC", "AI", "ACE", "CI", "CU", "BA", "SA", " CI", "II"], "LA": ["CLA", "LP", "LS", "LL", "LT", "CL", "CA", "LC", "LO", "TA", "LAN", "LG", "GA", "LB", "NA", "LU", "PLA", "AU", "MA", "LI", "La", "Li", "Lu", "BA", "SA", "LM", "LE", "LR"], "FA": ["AA", "CF", "RA", "EA", "fa", "DA", "FP", "TF", "DF", "CA", "FB", "FL", "TA", "WA", "GA", "FIN", "NF", "A", "SPA", "LU", "GF", "AU", "FC", "MA", "FE", "VA", "FF", "SA", "FG", "Fa", "AF", "PA", "FW"], "T": ["N", "U", "G", "TF", "TN", "O", "I", "TS", "TX", "TB", "W", "t", "M", "Z", "TH", "L", "D", "A", "R", "B", "S", "TT", "TG", "TC", "E", "H", "NT", "Y", "Q", "P"], "CASE": ["CEEEEE", " CATE", "Rase", "RATE", "CEOUNT", "CATE", "MASE", "CEEEE", "CEASE", "Cases", " Case", "DASE", " CEEEE", "Case", "DEEEE", " Cases", "Mase", " COUNT", "RASE", "Rases", "MATE", "COUNT", "Mases", "CEase", "DOUNT", "Dase"], "C": ["N", "CF", "U", "G", "Game", "O", "I", "case", "W", "M", "Z", "CE", "K", "DC", "CC", "L", "D", "A", "Case", "R", "B", "S", "c", "E", "V", "cycle", "CU", "Y", "Q", "P", "CT"], "F": ["N", "CF", "U", "G", "FD", "O", "I", "W", "FL", "M", "Z", "Fi", "L", "D", "A", "EF", "R", "B", "S", "FE", "E", "H", "V", "Y", "Q", "P", "f", "FG", "AF"], "X": ["N", "Test", "WS", "U", "XL", "G", "XP", "Game", "ZX", "O", "IX", "XXX", "I", "TX", "W", "M", "Z", "CE", "K", " x", "GE", "L", "EX", "D", "A", "R", "FX", "B", "S", "FE", "E", "H", "x", "V", "FF", "Y", "XXXX", "Q", "P", "XX", "PE", "Answer"], "tick": ["spin", "pick", "case", "hit", "race", "pad", "day", "ice", "kick", "flex", "timeout", "loop", "event", "word", "switch", "question", "write", "nick", "feed", "scroll", "hello", "stuff", "time", "cycle", "call", "click", "track", "strip", "d", "play", "step", "series", " beat", "ick", "year", "ping", "cross", "t", "stick", "trace", "poke", "boot", "enter", "frame", "shape", "jump", "draw", "trial", "bug", "mini", "repeat", "market", "start", "micro", "roll", "sticks", "axis", "wake", "icker", "clock", "sync", "style", "work", "win", "dy", "lex", "move", "episode", "trip", "quad", "scale"], "answer": ["size", "duration", "event", "score", "evidence", " answered", "activity", "offset", "play", "season", "next", "series", "address", "complete", "answered", "vote", "future", "start", " answers", "case", "year", "offer", "question", "response", "number", "margin", "race", "example", "edge", "rank", "video", "gamer", "grade", "audio", "A", "ice", "say", "order", "average", "issue", "winner", "draw", "ACE", "blank", "result", "episode", "reply", "fee", "array", "area", "trial", "Answer"], "game": ["team", "event", "rule", "gam", "G", "show", "player", "play", "step", "season", "unit", "Game", "series", "start", "case", "GAME", "year", "flow", "games", "Games", "history", "stick", "field", "card", "race", "sim", "pad", "gaming", "index", "g", "week", "players", "winner", "win", "kick", "scale", "zone", "draw", "frame", "window", "move", "episode", "jump", "cycle", "goal", "Y", "board", "trial", "slot", "lot"], "span": ["size", "sea", "sign", "duration", "event", "pause", "spin", "score", "player", "step", "season", "strike", "p", "feature", "series", "period", "channel", "year", "games", "number", "ticket", "gap", "part", "space", "sum", "race", "margin", "div", "pan", "n", "age", "sim", "char", "winner", "style", "win", "conference", "draw", "dim", "shape", "cycle", "move", "episode", "min", "sam", "y", "fen", "trial", "scale"], "test": ["Test", "stop", "loop", "event", "default", "train", "score", "play", "repeat", "unit", "match", "start", "switch", "fake", "case", "acc", "example", "trace", "type", "valid", "index", "script", "sync", "style", "stage", "const", "scale", "app", "fix", "int", "FE", "tests", "catch", "x", "result", "fe", "trip", " Test", "est", "ester", "code", "err", "EST", "trial", "txt", "show", "testing"]}}
{"code": "__author__ = 'jrokicki'\\n  \\n  RL = lambda: sys.stdin.readline().strip()\\n  IA = lambda: map(int, RL().split(\" \"))\\n  LA = lambda: map(long, RL().split(\" \"))\\n  FA = lambda: map(float, RL().split(\" \"))\\n  \\n  T = int(sys.stdin.readline())\\n  \\n  def clear(R,C,b, x, y):\\n      b = b[:]\\n      n = 0\\n      for i in range(max(0,x-1), min(R,x+2)):\\n          for j in range(max(0,y-1), min(C, y+2)):\\n              if b[C*i+j] == '*':\\n                  n += 1\\n                  b = b[:C*i+j] + '.' + b[C*i+j+1:]\\n      return b, n\\n  mem = dict()\\n  def pb(R,C,b):\\n      for x in range(R):\\n          print b[x*C:x*C+C]\\n  \\n  def board(R,C,b,x,y,M,m):\\n      global mem\\n      print x\\n      key = (R,C,b,M,x,y,m)\\n      if key in mem: return mem[key]\\n      if x >= R or y >= C:\\n          mem[key] = None\\n      else:\\n          lb = b\\n          n = 0\\n          good = False\\n          for i in range(y,C):\\n              nb,nn = clear(R,C, lb, x, i)\\n              n += nn\\n              if m - n - M == 0:\\n                  mem[key] = nb\\n                  good = True\\n                  break\\n              elif m - n - M < 0:\\n                  break\\n              lb = bb\\n          mem[key] = board(R,C,bb,M,x+1,0,m-n)\\n      return mem[key]\\n  \\n  for CASE in range(T):\\n      R,C,M = IA()\\n      IMPOSSIBLE = \"Impossible\"\\n  \\n      b = \"\"\\n      cleared = R*C-M\\n      for x in range(R):\\n          b += \"*\" * C\\n      if M == R*C-1:\\n          b = \"c\" + b[1:]\\n          answer = b\\n      else:\\n          good = False\\n          x,y = 0,0\\n          q = [(b,0,0,0)]\\n          mem = {}\\n          while not good and q:\\n              board,total_cleared,x,y = q.pop(0)\\n              if (board,total_cleared,x,y) in mem:\\n                  continue\\n              mem[(board,total_cleared,x,y)] = True\\n              if x >= R: continue\\n              if y >= C:\\n                  q.append((last_board,total_cleared,x+1,0))\\n                  continue\\n              last_board = board\\n              new_board, cleared_mines = clear(R,C,last_board,x,y)\\n              total_cleared += cleared_mines\\n  \\n              if total_cleared == cleared:\\n                  good = True\\n                  last_board = new_board\\n                  q = []\\n                  break\\n              elif total_cleared - cleared == -1:\\n                  q.append((new_board,total_cleared,x,y+1))\\n                  q.append((new_board,total_cleared,x+1,0))\\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\\n              elif total_cleared > cleared:\\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\\n              else:\\n                  q.append((new_board,total_cleared,x,y+1))\\n              last_board = new_board\\n          if good:\\n              answer = last_board\\n          else:\\n              answer = None\\n      if not answer:\\n          answer = \"Impossible\"\\n      else:\\n          b = \"\"\\n          for x in range(R):\\n              b += answer[x*C:x*C+C] + \"\\n\"\\n          answer = \"c\" + b[1:-1]\\n      print \"Case #%d:\\n%s\" % (CASE+1, answer)\\n  \\n", "target": "31", "substitutes": {"__author__": ["__version___", "__alias___", "__title__", "__version__", "__title___", " __author___", " __version__", "__alias__", "__author___", " __version___"], "RL": ["LP", "LD", "rb", "EL", "XL", "UL", "URL", "IL", "SL", "SB", "HL", "LS", "LL", "RR", "DL", "LT", "CL", "MR", "LC", "RB", "FL", "ML", "QL", "HR", "RC", "STR", "SR", "REL", "VR", "NL", "L", "LU", "IO", "RS", "BR", "Ul", "CR", "rl", "VL", "IR", "DR", "OL", "GR", "WR", "El", "TL", "ARR", "BL", "LR"], "IA": ["AA", "AE", "AR", "DA", "MI", "IL", "I", "SI", "CA", "BB", "TA", "IP", "NI", "IG", "GA", "HA", "IE", "NA", "ci", "A", "IO", "IB", "ca", "MA", "IM", "BI", "LI", "ia", "CR", "BBC", "AI", "a", "CI", "IR", "VI", "Y", "SA", "BA", "Q", "II", "area", "RA"], "LA": ["LP", "IL", "LS", "LL", "LT", "CL", "SI", "CA", "LO", "TA", "LAN", "LG", "GA", "NA", "la", "LB", "LU", "AU", "MA", "LI", "La", "Li", "Lu", "BA", "SA", "LIB", "LM", "LR"], "FA": ["AA", "EA", "FD", "FP", "HF", "FI", "CA", "FB", "FL", "WA", "FFFF", "GA", "HA", "FIN", "Fi", "FW", "AAA", "GF", "PLA", "MA", "FE", "VA", "FF", "FG", "Fa", "PA", "fa", "Fe"], "T": ["N", "U", "G", "X", "TN", "J", "O", "I", "TS", "TX", "TB", "W", "t", "TM", "Z", "K", "L", "D", "B", "S", "TT", "E", "H", "F", "V", "Y", "Q", "P"], "R": ["N", "Rh", "AR", "U", "RH", "RI", "G", "X", "J", "RE", "RR", "KR", "I", "MR", "r", "W", "Rs", "K", "HR", "RC", "RO", "SR", "RN", "Re", "L", "D", "A", "ER", "JR", "B", "RS", "S", "BR", "CR", "E", "H", "F", "IR", "V", "DR", "GR", "RM", "WR", "Y", "Ra", "NR", "Q", "P", "RT", " r", "RA", "RG"], "C": ["N", "CF", "Cs", "U", "Cy", "G", "Ch", "X", "SC", "Co", "Cu", "O", "IX", "I", "CL", "CA", "r", "W", "YC", "NC", "CM", "VC", "K", "CE", "EC", "Z", "DC", "CP", "Ca", "CC", "L", "Sc", "D", "A", "CN", "MC", "B", " c", "S", "c", "KC", "CR", "E", "H", "AC", "CS", "CI", "F", "V", "CU", "Y", "Q", "P", "Code", "CT", "Con", "Cr"], "b": ["eb", "sb", "fb", "wb", "bd", "binary", "bi", "bu", "c", "bc", "db", "bt", "bool", "beta", "cb", "X", "pb", "z", "BB", "bit", "_", "w", "l", "ib", "all", "abb", "s", "a", "ab", "buffer", "bs", "f", "o", "e", "rb", "bl", "d", "ob", "id", "num", "p", "t", "v", "gb", "ub", "E", "bp", "be", "emb", "bb", "h", "bf", "ba", "u", "r", "xb", "D", "B", "base", "MB", "bin", "k", "message", "mb", "g"], "x": ["xs", "xt", "hi", "sex", "I", "mx", " X", "im", "cy", "rex", "index", " xx", "xc", "wx", "c", "xe", "xx", "ax", "my", "X", "width", "z", "tx", "_", "dx", "w", "l", "s", "a", "ic", "code", "f", "o", "e", "xa", "d", "id", "num", "p", "xy", "max", "rx", "t", "on", "v", "ci", "one", "min", "Y", "xi", "ay", "h", "u", "r", "change", "ed", "ex", "win", "int", "k", "ix", "g"], "y": ["e", "ny", "yr", "ys", "d", "yy", "ay", "h", "sky", "yt", "p", "sy", "ch", "I", "u", "z", "r", "t", "ty", "v", "ym", "yl", "w", "cy", "type", "oy", "l", "py", " Y", "yi", "c", "s", "time", "ey", "dy", "a", "ry", "yo", "k", "ya", "yn", "vy", "Y", "o"], "n": ["N", "e", "ny", "d", "name", "ne", "ns", "nd", "num", "len", "h", "p", "out", "en", "u", "r", "z", "nt", "t", "number", "v", "ni", " N", "na", "un", "w", "nl", "np", "l", "net", "all", "c", "ln", "sn", "init", "k", "yn", "nc", "min", "f", "no", "o", "cn", "dn", "g", "nu"], "i": ["e", "si", "ini", "xi", "ip", "d", "hi", "mi", "id", "p", "I", "u", "im", "r", "ie", "z", "li", "pi", "ai", "ui", "v", "ni", "t", "io", "ci", "l", "ii", "index", "bi", "di", "yi", "c", "int", "ji", "k", "phi", "ix", "Y", "iu", "ind", "f", "o", "ia", "g", "eni", "qi"], "j": ["e", "si", "d", "h", "J", "p", "xy", "ch", "u", "z", "r", "jl", "t", "li", "ie", "jj", "v", "w", "l", "jp", "ij", "ii", "je", "c", "ja", "jc", "ji", "k", "ix", "jo", "aj", "f", "o", "g", "js"], "mem": ["comb", "access", "large", "vm", "im", "val", "nm", "hw", "tm", "index", "de", "mod", "reg", "lim", "member", "node", "range", "mi", "nd", "tab", "pm", "mm", "mor", "BM", "map", "note", "ib", "all", " memory", "gram", "buffer", " Mem", "dem", "rem", "bl", "ME", "num", " MEM", "gl", "max", "rm", "bm", "comment", "summary", "sum", "ram", "um", "loc", "gb", "function", "data", "md", "program", "temp", "asm", "term", "info", "Mem", "mc", "em", "struct", "memory", "mini", "item", "me", "image", "nt", "ref", "ym", "am", "mo", "EM", "link", "value", "cache", "lib", "imm", "mb", "store"], "M": ["N", "U", "G", "ME", "X", "J", "p", "O", "I", "r", "W", "Ms", "MD", "MS", "Z", "v", "CM", "NM", "Mi", "K", "BM", "MT", "L", "MN", "EM", "D", "A", "MC", "B", "S", "c", "E", "H", "F", "V", "RM", "Y", "Q", "P", "cm", "MF"], "m": ["e", "N", "ms", "mc", "d", "mi", "om", "dm", "mini", "h", "p", "pm", "mr", "en", "sm", "u", "im", "mm", "r", "z", "bm", "t", "fm", "v", "ym", "nm", "w", "tm", "l", "c", "s", "min", "Y", "f", "o", "cm", "g", "mn"], "key": ["N", "name", "col", "arg", "case", "Key", "val", "number", "row", "rec", "cy", "index", "close", "c", "sec", "parent", "cell", "my", "short", "msg", "ace", "switch", "count", "field", "note", "type", "cor", "label", "fix", "code", "f", "e", "sign", "ne", "id", "num", "p", "match", "go", "ver", "co", "error", "ke", "loc", "core", "order", "keys", "char", "block", "ry", "ck", "info", "lock", "ee", "kw", "change", "ref", "source", "link", "value", "right", "sync", "base", "cache", "use", "int", "k", "no", "KEY"], "lb": ["rb", "bl", "bb", "cb", "pb", "eb", "pl", "sb", "lf", "ll", "lam", "abl", "afe", "lt", "bm", "BB", "wb", "fb", "li", "BM", "lab", "lr", "lin", "LB", "la", "nl", "L", "l", "gb", "ls", "dl", "ub", "B", "bi", "ml", "lbs", "acl", "ln", "bc", "lib", "BBC", "blog", "rl", "lp", "lu", "cm", "lot", "lc", "abc"], "good": [" Good", "Good", " cool", "broken", "clean", "bug", "next", "done", "best", "quick", "fun", "improve", "like", "wrong", "bad", "comment", "little", "error", "slow", "hack", "pretty", "valid", "same", " bad", "fine", "job", "better", " nice", "stuff", "fix", "big", "success", "bugs", "result", "kind", "yes", "gy", " bug", "ok", "err", "nice", "ready", " GOOD", "show", "check"], "nb": ["ny", "bb", "ns", "nd", "num", "cb", "len", "bf", "sb", "count", "nt", "bm", "wb", "number", "fb", "ni", "bn", "NB", "nl", "np", "adj", "kb", "bd", "bi", "ln", "abb", "bc", "sn", "dy", "nc", "ab", "nr", "tmp", "dn", "cn", "nu"], "nn": ["ny", "nv", "bb", "NN", "ne", "ns", "nd", "fn", "len", "byn", "nt", "ni", "nm", "nz", "wn", "bn", "nan", "na", "NB", "nl", "kn", "np", "ii", "nw", "ann", "pn", "ln", "abb", "sn", "dy", "gn", "nc", "inn", "nr", "dn", "nu", "mn"], "CASE": ["CODY", "CUODY", "CUASE", "RASE", "Rases", "CUases", "CMASE", "CUASS", "CMases", "Cases", "CMODY", "CASS", "RASS", "CMASS", "RODY"], "IMPOSSIBLE": ["IMPOSSBILITY", "IMPossBILITY", "IMpOSSBILITY", "IMpossible", "IMPORTSIBLE", "IMPossIVE", "IMPORTSIVE", "IMPENSIBLE", "IMpossIVE", "IMPossIBLE", "IMPORTSBILITY", "IMpOSSIVE", "IMPORTSible", "IMPOSSIVE", "IMPossible", "IMPENSBILITY", "IMPOSSible", "IMPENSIVE", "IMpossIBLE", "IMpossBILITY", "IMpOSSIBLE", "IMPENSible", "IMpOSSible"], "cleared": [" cleanned", " cleed", "Cleared", "Cleed", " clearing", "clearing", "CLEanned", "cleanned", "Clearing", "CLEed", "CLEaring", "cleed", "CLEared", "Cleanned"], "answer": ["rr", "short", "aa", "rc", "ac", "eb", "best", "ll", "z", "question", "BB", "fb", "comment", "ell", "gb", "back", "better", "abb", "gain", "blank", "result", "ab", "reply", "err", "f", "Answer", "abc"], "q": ["iq", "nd", "id", "short", "qa", "p", " question", "ll", "quick", "like", "z", "question", "qq", "qt", "bit", "comment", "query", "ad", "back", "k", "buff", "quit", "dq", " quick", "Q", "g", " questions", "check"], "board": ["lay", "loop", "deck", "bo", "player", "word", "play", "boards", "channel", "hole", "flow", "book", "ward", "design", "comment", "row", "error", "game", "hack", "uc", "Board", "video", "pad", "block", "program", "cache", "bc", "ack", "c", "buffer", "bank", "line", "forward", "post", "draw", "bug", "table"]}}
{"code": "T = int(raw_input().strip())\\n  \\n  for i in xrange(T):\\n  \tC, F, X = map(float, raw_input().strip().split(' '))\\n  \tbest = X / 2.0\\n  \tc_sum = 0\\n  \tfactories = 1\\n  \tn_sum = c_sum + C / (2.0 + (factories - 1) * F)\\n  \twhile n_sum + X / (2.0 + factories * F) < best:\\n  \t\tbest = n_sum + X / (2.0 + factories * F)\\n  \t\tc_sum = n_sum\\n  \t\tfactories += 1\\n  \t\tn_sum = c_sum + C / (2.0 + (factories - 1) * F)\\n  \\n  \tprint \"Case #%s: %s\" % (i + 1, best)\\n", "target": "32", "substitutes": {"T": ["N", "Test", "G", "TN", "Time", "O", "I", "TS", "TB", "W", "t", "M", "Z", "K", "L", "WT", "D", "A", "R", "B", "S", "TT", "E", "H", "V", "Total", "Y", "Q", "P", "EST", "TI"], "i": ["e", "gi", "ini", "inter", "xi", "d", "id", "slice", "p", " I", "j", "I", "start", "u", "z", "ie", "li", "pi", "t", "n", "ci", "ij", "index", "ii", "ti", "c", "end", "int", "key", "k", "phi", "x", "ix", "y", "ind", "f"], "C": ["N", "CF", "Cs", "U", "G", "Cu", "O", "I", "CL", "CNN", "CA", "W", "M", "CM", "K", "EC", "DC", "CC", "L", "D", "A", "R", "B", "S", "FC", "CO", "c", "CV", "CR", "E", "H", "CI", "V", "CU", "Y", "Q", "P"], "F": ["N", "Full", "CF", "U", "Ext", "Fixed", "G", "Fs", "FD", "DF", "OF", "O", "I", "IF", "FB", "W", "BF", "File", "M", "Z", "K", "Fit", "L", "D", "FO", "EF", "R", "PF", "B", "GF", "FM", "WF", "FH", "Function", "FY", "Fine", "FE", "E", "H", "SF", "FOR", "V", "RF", "FF", "Y", "Q", "P", "f", "FG", "AF", "FW"], "X": ["N", "Test", "U", "Length", "RH", "XL", "G", "SC", "XP", "O", "IX", "XXX", "I", "CL", "TX", "W", "M", "Z", "EC", "K", "CE", "CW", "CC", "L", "D", "A", "R", "Check", "B", "Ex", "S", "FC", "Best", "E", "H", "AC", "x", "V", "FF", "XY", "Y", "Q", "P", "XX", "MAX", "CT", "Cross"], "best": ["default", "self", "good", "pp", "highest", "correct", "short", "final", "std", "current", "max", "start", "case", "instance", "master", "largest", " Best", "co", "top", "existing", "obj", "pretty", "enough", "rank", "Better", "recent", "right", "last", "winner", "better", "new", "Best", "all", "temp", "success", "test", "x", "result", "this", "node", "FF", "est", "maximum", "worst", "cost", "latest", "MAX", "most", " better", "EST", "bottom", "diff"], "c_sum": [" c_average", "callsum", "c6comb", "callnum", "c_um", " c_comb", "c_comb", "c_mean", "c_num", "c___seed", "c_count", " c_um", "p_max", " c_cache", "p_mean", "c_max", "c_cache", "callaverage", "c_average", "c_seed", "c_stat", "callstat", "p_sum", "c6um", " c_num", "c___mean", "c___sum", "c___max", "p_seed", "c6sum", "c6cache", " c_count", " c_stat"], "factories": ["Factractions", "factsORY", "gallories", "facturation", "gallores", "Factories", " factores", "factsicles", "fories", "FactORY", " factORY", "gallors", "factsologies", "galluries", "fors", "factores", " factors", "condors", "factsories", "condractions", "factors", " facticles", "facticles", "actologies", "actors", "facturies", "ficles", "Facturation", "partories", "Factors", "factORY", "fologies", " factologies", "actORY", "partologies", "Facticles", " factractions", "Facturies", "particles", "factsuration", " facturies", "fores", "Factores", "furies", "factractions", " facturation", "actories", "Factologies", "condories", "condores", "parturies", "factsors", "factologies"], "n_sum": [" n_gram", "n_diff", " c_Sum", "n_mean", "n__gram", "nXstate", "n_num", "nXstart", "n__size", " n__match", "nxsize", " n_match", "nxmatch", "n_cost", " n_size", "nXcost", " n_diff", " n_count", " n_start", "nXcount", " n_cost", "nXmean", " n_num", "n_state", "n_count", "n_size", " n__size", "n_start", "n__match", "nXsum", "n__sum", "n_gram", " n_mean", "n_match", " n__gram", "nxgram", " c_num", "n_Sum", " n_state", "nxsum", " n__sum"]}}
{"code": "T = int(raw_input().strip())\\n  misses = set()\\n  \\n  for i in xrange(T):\\n  \tR, C, M = map(int, raw_input().strip().split(' '))\\n  \tF = R * C - M\\n  \timpossible = False\\n  \tif F == 1:\\n  \t\tmatrix = [\"c\" + \"*\" * (C - 1)]\\n  \t\tfor _ in xrange(R - 1):\\n  \t\t\tmatrix.append(\"*\" * C)\\n  \telif R == 1:\\n  \t\tmatrix = [\"c\" + \".\" * (F - 1) + \"*\" * (C - F)]\\n  \telif C == 1:\\n  \t\tmatrix = [\"c\"]\\n  \t\tfor _ in xrange(F - 1):\\n  \t\t\tmatrix.append(\".\")\\n  \t\tfor _ in xrange(R - F):\\n  \t\t\tmatrix.append(\"*\")\\n  \telif R == 2:\\n  \t\tif F % 2 == 0 and (C > 1 and F != 2 or C == 1 and F <= 2):\\n  \t\t\tmatrix = [\\n  \t\t\t\t\"c\" + \".\" * (F / 2 - 1) + \"*\" * (C - F / 2),\t\\n  \t\t\t\t\".\" * (F / 2) + \"*\" * (C - F / 2)\\n  \t\t\t]\\n  \t\telse:\\n  \t\t\tmatrix = []\\n  \t\t\timpossible = True\\n  \telse:\\n  \t\tstack = []\\n  \t\tmatrix = []\\n  \t\tfor j in xrange(C, 1, -1):\\n  \t\t\tif F - 2 * j >= 0 and (R - 2) * j >= F - 2 * j:\\n  \t\t\t\tstack.append([j, j])\\n  \\n  \t\twhile stack:\\n  \t\t\telems = stack.pop()\\n  \t\t\tse = sum(elems)\\n  \t\t\tif se == F:\\n  \t\t\t\tfor count in elems:\\n  \t\t\t\t\tmatrix.append(\".\" * count + \"*\" * (C - count))\\n  \t\t\t\tfor _ in xrange(R - len(elems)):\\n  \t\t\t\t\tmatrix.append(\"*\" * C)\\n  \t\t\t\tmatrix[0] = \"c\" + matrix[0][1:]\\n  \t\t\t\tbreak\\n  \t\t\telif len(elems) < R:\\n  \t\t\t\tfor j in xrange(elems[-1], 1, -1):\\n  \t\t\t\t\tif F - se - j >= 0 and (R - len(elems)) * j >= F - se:\\n  \t\t\t\t\t\tstack.append(elems[::] + [j])\\n  \\n  \t\tif matrix == []:\\n  \t\t\timpossible =True\\n  \\n  \tprint \"Case #%s:\" % (i + 1)\\n  \tif impossible:\\n  \t\tprint \"Impossible\"\\n  \telse:\\n  \t\tfor row in matrix:\\n  \t\t\tprint row\\n", "target": "32", "substitutes": {"T": ["N", "U", "X", "TF", "TN", "Time", "O", "I", "TS", "TB", "W", "t", "TA", "Z", "L", "D", "B", "S", "TT", "TC", "E", "H", "V", "Total", "NT", "Y", "Q", "P"], "misses": ["maned", "processits", "missed", "licages", "lices", "manits", "missages", "manages", "processed", "licits", "liced", "processes", "processages", "missits", "manes"], "i": ["N", "gi", "ip", "d", "iq", "col", "id", "h", "J", "p", " I", "I", "im", "z", "r", "n", "D", "ii", "cor", "ti", "all", "c", "int", "ind", "g"], "R": ["N", "Rh", "U", "RH", "G", "X", "J", "O", "RR", "I", "MR", "r", "W", "Rs", "Range", "K", "RC", "RW", "SR", "RO", "Right", "Re", "n", "L", "D", "A", "JR", "B", "RS", "S", "BR", "CR", "E", "H", "V", "RF", "RM", "Y", "NR", "Q", "P", "RT", "RA", "RG"], "C": ["N", "Count", "CF", "Cs", "U", "G", "Ch", "Cor", "X", "Co", "Cu", "J", "O", "COR", "I", "CL", "Size", "CNN", "CA", "r", "W", "YC", "Cl", "CM", "K", "EC", "CE", "DC", "CC", "L", "D", "A", "MC", "B", "S", "CO", "c", "CV", "CR", "E", "H", "AC", "CI", "V", "CU", "Y", "Q", "P", "CT", "Cr"], "M": ["N", "U", "G", "X", "O", "I", "W", "MS", "Z", "CM", "m", "MN", "L", "D", "A", "MC", "FM", "B", "DM", "S", "CR", "E", "H", "V", "RM", "Y", "Q", "P", "MM", "MF"], "F": ["N", "Full", "CF", "U", "Fixed", "G", "Fs", "FD", "X", "OF", "J", "DF", "O", "FO", "I", "IF", "FB", "W", "FL", "BF", "File", "Fl", "Z", "K", "Fi", "FS", "L", "Family", "D", "A", "EF", "IO", "FM", "PF", "FH", "B", "S", "FC", "FR", "GF", "FE", "Fine", "E", "H", "SF", "V", "RF", "FF", "All", "Y", "Inf", "Q", "P", "f", "Far", "FG", "Fa", "AF"], "impossible": ["greatossibility", "ispective", "impurity", "Impure", "Impossibility", " impossibility", "compossible", "greatossible", "Impossible", "greatossibly", "impective", "impossibly", "greaturity", "Impective", "ispurity", "ispossibly", "ispure", "compurity", "impossibility", "impure", " impure", "compossibly", " impective", "compossibility", "ispossible", "ispossibility"], "matrix": ["atrics", "mortrix", "mathuri", " matMatrix", " matress", "matrow", "atplex", "atric", "matral", "trices", "attrices", "mrix", "latMatrix", "tvector", "matx", "attribution", "tric", "Matfix", "latx", "latrice", "MATx", "matfix", "matride", "Matride", "molrix", "macrices", " matride", " matment", "tensor", "metogram", "scherix", "attric", "MATrices", "matrice", "metrices", " matfix", "mortux", "latplex", "macric", "atrices", "attrix", "MATfix", "atrow", "atrix", "metrics", "latrices", "attral", "latrix", "mmric", " matplex", "mortric", "mrices", "atuster", "mmrices", "macrix", "mathrices", "macress", "matvector", " matuster", " matogram", "rubrices", "Matrix", "matrics", "matogram", " matric", "latvector", " matx", " matri", "molress", "mmrix", "atMatrix", "mmrice", "metric", "matment", "tplex", "matri", "mride", "MATrix", "matrices", "metrix", "Matrices", "scheri", "matuster", "metrow", "atri", "maturi", "Matogram", "latric", "trix", "molrices", "Matric", "latfix", "morturi", "mathribution", "mathric", "matplex", "matric", "metract", "mathral", "mfix", "mathrix", "Matment", " matrics", " matensor", " matrices", " matract", "rubrix", "scherices", " matribution", "matract", "matux", "mathensor", "rubplex", " matrow", "matMatrix", " matux", "mathux", "rubvector", "matensor", " maturi", "atract", "matribution", " matral", "scheuster", "molric", "metment", "attrice", "matress"], "_": ["U", "ip", "d", "__", "ac", "p", "out", "u", "non", "val", "ing", "of", "q", "place", "n", "l", " un", "A", "al", "all", "s", "a", "lex", "k", "x", "___", "o", "up", "g"], "stack": ["shell", "queue", "loop", "console", "white", "self", "fr", "shift", "cube", "history", "str", "slice", "view", "document", "list", "switch", "sequence", "force", "Stack", "context", "z", "file", "pop", "roll", "left", "v", "push", "pull", "first", "layer", "pack", "string", "reverse", "parse", "scope", "trace", "scroll", "la", "l", "cl", "index", "function", "tree", "sl", "data", "zip", "batch", "back", "cache", "ack", "stage", "work", "wrap", "int", "new", "lc", "st", "set", "cycle", "sc", "array", "chain", "ind", "diff", "stream", "scale", "check"], "j": ["e", "si", "br", "d", "pos", "fr", "num", "uj", "h", "J", "p", "ch", "pr", "jet", "z", "r", "ie", "t", "sh", "jl", "li", "jj", "v", "note", "q", "m", "n", "l", "adj", "jp", "ij", "py", "dj", "fl", "ii", "index", "seq", "je", "c", "ja", "jc", "int", "sp", "ji", "k", "x", "y", "aj", "jo", "b", "ind", "f", "o", "el", "g", "js"], "elems": ["Elemes", "elec", "elm", "lemes", "elemes", "elks", " eleks", "elements", "olements", "elens", "Elems", "lemms", "lems", "Elens", "elns", " elemes", "lements", " elem", "elmes", " elens", " elec", "eleks", "lem", "lemments", "lemlems", "Elec", "elc", "ellems", "lemmes", " elelems", "lemks", "lemm", "elms", "olem", "lemns", "oleks", "olems", "elem", "Elem", "elelems", "elments", "Eleks", "olemes"], "se": ["e", "size", "si", "sea", "ge", "sle", "ne", "nd", "fr", "ve", "ee", "me", "sy", "ch", "ce", "length", "su", "see", "arse", "ie", "sh", "ase", "nt", "Se", "pse", "sum", "sa", "ses", "parse", "ose", "ke", "ae", " Se", "sq", "SE", "ci", "sd", " SE", "ss", "de", "sed", "sl", "sem", "sel", "sec", "use", "pe", "sp", "th", "fe", "est", "ze", "le", "be", "ser"], "count": ["cf", "e", "size", "Count", "ge", "col", "weight", "id", "num", "len", "coll", "p", "ch", "length", "list", "max", "start", "child", "see", "ct", "z", "nt", "li", "number", "cat", "sum", "cur", "loc", "q", "n", "core", "l", "seq", "index", "last", "base", "c", "cc", "cache", "key", "mass", "ph", "th", "depth", "cycle", "code", "ind", "f"]}}
{"code": "if len(sys.argv) == 1:\\n      sys.stdin = open(\"B.in\")\\n  else:\\n      sys.stdin = open(sys.argv[1])\\n  \\n  def to_floats(s):\\n      return map(float, s.split())\\n  \\n  def get_floats():\\n      return to_floats(raw_input())\\n  \\n  n_cases = input()\\n  \\n  for case in xrange(1, n_cases + 1):\\n      farm_cost, farm_increase, goal = get_floats()\\n  \\n      best_time = float('inf')\\n      time = 0.0\\n      rate = 2.0\\n      while time < best_time:\\n          best_time = min(best_time, time + goal / rate)\\n          time += farm_cost / rate\\n          rate += farm_increase\\n  \\n      print \"Case #%d: %.7f\" % (case, best_time)\\n", "target": "33", "substitutes": {"sys": ["shell", "proc", "ys", "exec", "module", "loop", "self", "gui", "Sys", "sb", "runtime", "ll", "input", "mac", "host", "util", "parse", "cs", "hw", "session", "np", "kernel", "py", "usr", "machine", "os", "system", "sim", "script", "six", "fs", "sync", "linux", "pkg", "pc", "windows", "win", "python", "call", "site", "wp", "process", "run", "user", "server", "net", "misc"], "stdin": ["stdinput", "adnin", "buildins", "STDout", " stdnin", " stdinput", "martnin", "buildinput", " stdout", "STDinput", "adins", "buildout", " stdins", "adout", "martin", "adin", "martins", "stdins", "STDin", "STDins", "stdnin", "martout", "buildin", "stdout"], "s": ["e", "si", "sg", "d", "i", "str", "sb", "p", "services", "input", "su", "ssl", "r", "v", "submit", "string", "source", "w", "sf", "m", "n", "l", "ls", "os", "ss", "data", "text", "S", "sl", "strings", "c", "a", "b", "f", "g"], "n_cases": [" n2details", " n_runs", "nxrooms", " n2lines", " n2pieces", " nxruns", " n_times", " n_rooms", "n2pieces", "n_runs", "n2cases", "nnumrooms", "n67details", "nnumtimes", " n_pieces", "n_pieces", "n67pieces", "n67cases", "n_lines", "nnumcases", "nxruns", "nnumruns", " nxrooms", "n_rooms", "n2lines", "n_details", " n_lines", " n_details", "n2details", "nxtimes", "nxcases", "n67lines", " nxcases", " nxtimes", " n2cases", "n_times"], "case": [" match", "sea", " sub", " instance", "loop", "rial", "repeat", " self", " count", "section", "address", "ce", "match", "ace", " cases", "trial", " e", "instance", "count", "ase", "cases", "change", "nce", " d", "race", " Case", "game", " x", " seq", " loop", "core", "Case", "ice", " example", " c", " line", "base", "use", " p", "test", "chance", " use", " suite", " position", "phase", " CASE", "code", " feat", " code", " fe", "bug"], "farm_cost": ["farm\u00b7count", "farmpycost", "random_cost", "farmpyrule", "random_scale", " farm_rule", "farm_scale", "farm\u00b7cost", "farm_effect", " farm_effect", "farmpyeffect", "farm_count", "farm\u00b7scale", "farm_rule", "random_count"], "farm_increase": ["farm_increaser", "farm_Decreases", "farm_Increaser", "farm_increases", "farm_incasing", "farm_creaser", "farm_incases", "farm_Decrease", "farm_incASE", "farm_creASE", "farm_incased", "farm_creased", "farm_DecreASE", "farm_Decreased", "farm_increasing", "farm_crease", "farm_Increased", "farm_creases", "farm_Increase", "farm_creasing", "farm_increased", "farm_incase", "farm_Increasing", "farm_increASE", "farm_incaser"], "goal": ["team", "range", "gen", "speed", "gam", "large", "unit", "best", "gate", "vote", "lane", "Goal", "gap", "die", "home", "cookie", "edge", "limit", "value", "leader", "risk", "average", "loss", "winner", "gross", "growth", "guide", "gain", "jump", "target", "phase", "cost", "game", "trial", "mode", "gender", "scale"], "best_time": ["best64money", "best_rate", "best___age", "worst_time", "end_times", " best_date", "best_money", "best_times", "end_start", "worst_times", "best___rank", "end_speed", "best_rank", "worst_length", "worst_rate", "best_age", "better_money", " best_age", "better_Time", "best_Time", " best_rank", "best_date", "best___times", "best_length", "best_year", "best_start", "best_speed", "best___time", "better_time", "best64Time", "end_time", "best64time", " best_times", " best_year"], "time": ["range", "size", "speed", "name", "duration", "money", "id", "url", "play", "h", "Time", "month", "way", "point", "length", "ime", "match", "now", "start", "max", "image", "im", "change", "etime", "am", "date", "rice", "home", "race", "type", "sleep", "m", "TIME", "age", "clock", "live", "order", "value", "close", "hour", "volume", "last", "times", "use", "depth", "delay", "timer", "cost", "up", "mode", "scale"], "rate": ["rating", "range", "size", "speed", "rage", "weight", "duration", "rule", "score", " Rate", "rated", "step", "unit", "width", "rise", "ride", "go", "ime", "Rate", "force", "rat", "r", "level", "date", "race", "rice", "limit", "core", "age", "rank", "grade", "seed", "value", "rates", "erate", "times", "stage", "depth", "gain", "delay", "dist", "fee", "frequency", "rade", "mode", "scale"]}}
{"code": "if len(sys.argv) == 1:\\n      sys.stdin = open(\"C.in\")\\n  else:\\n      sys.stdin = open(sys.argv[1])\\n  \\n  def to_ints(s):\\n      return map(int, s.split())\\n  \\n  def get_ints():\\n      return to_ints(raw_input())\\n  \\n  sys.setrecursionlimit(4000)\\n  \\n  def fill(rows, cols, mines):\\n      seen = set()\\n      visited = set()\\n  \\n      def search(numbered, zeros, min_numbered):\\n          left = (rows * cols - mines) - len(numbered)\\n          if left == 0:\\n              raise StopIteration((numbered, zeros))\\n          if left < 0:\\n              return\\n          for n in xrange(min_numbered, len(numbered)):\\n              number = numbered[n]\\n              if number in zeros:\\n                  continue\\n              row, col = number\\n              neigh = []\\n              if row > 0:\\n                  if col > 0: neigh.append((row - 1, col - 1))\\n                  neigh.append((row - 1, col))\\n                  if col < cols - 1: neigh.append((row - 1, col + 1))\\n              if col > 0: neigh.append((row, col - 1))\\n              if col < cols - 1: neigh.append((row, col + 1))\\n              if row < rows - 1:\\n                  if col > 0: neigh.append((row + 1, col - 1))\\n                  neigh.append((row + 1, col))\\n                  if col < cols - 1: neigh.append((row + 1, col + 1))\\n              neigh = list(set(neigh) - set(numbered))\\n              zeros.add(number)\\n              search(numbered + neigh, zeros, n + 1)\\n              zeros.remove(number)\\n  \\n      try:\\n          for row in xrange(rows):\\n              for col in xrange(cols):\\n                  search([(row, col)], set(), 0)\\n      except StopIteration, e:\\n          numbered, zeros = e.message\\n          board = {}\\n          for row, col in numbered + list(zeros):\\n              board[row, col] = '.'\\n          if zeros:\\n              board[zeros.pop()] = 'c'\\n          else: # case where first click is on a number\\n              board[0, 0] = 'c'\\n          out = ''\\n          for row in xrange(rows):\\n              for col in xrange(cols):\\n                  out += board.get((row, col), '*')\\n              out += '\\n'\\n          return out.strip()\\n      return 'Impossible'\\n  \\n  n_cases = input()\\n  for case in xrange(1, n_cases + 1):\\n      rows, cols, mines = get_ints()\\n  \\n      result = fill(rows, cols, mines)\\n  \\n      print \"Case #%d:\" % case\\n      print result\\n", "target": "33", "substitutes": {"sys": ["shell", "proc", "ys", "exec", "module", "parser", "self", "gui", "Sys", "std", "p", "ll", "auto", "input", "er", "mac", "host", "util", "console", "parse", "cs", "hw", "kernel", "np", "py", "sim", "machine", "os", "system", "script", "fs", "sync", "linux", "func", "pc", "c", "win", "lib", "python", "socket", "cache", "scan", "call", "site", "wp", "process", "run", "tty", "server", "net"], "stdin": ["stout", "STDout", "stddin", " stdsin", " stdout", " STDins", " stdins", " STDin", "stin", "stdins", "STDin", "stins", "STDdin", "STDsin", " stddin", "STDins", " STDout", " STDsin", "stdout", "stdsin"], "s": ["e", "si", "sg", "d", "str", "sb", "p", "services", "su", "ssl", "r", "v", "string", "source", "w", "sq", "sf", "m", "l", "ls", "ss", "sl", "S", "strings", "c", "a", "sv", "second", "b", "array", "f", "o", "g"], "rows": ["heads", "xs", "thumbnails", "shows", "ids", "words", "boards", "months", "opens", "sections", "xes", "features", "rings", "holes", "planes", "levels", "values", "cells", "cases", "vers", "ows", "cats", "pages", "ins", "fields", "rown", "rooms", "keys", "grades", "ks", "locks", "groups", "views", "frames", "times", "checks", "files", "balls", "blocks", "orders", "flows", "items", "rs", "tracks", "tests", "x", "lines", "users", "boxes", "sels", "ports", "runs", "ips", "ries"], "cols": ["coli", "colions", " colp", "columnp", "coles", "roundops", "rounds", " colrows", " coli", "colls", "coln", " coln", " Colses", "columnc", "keepn", "Colions", "Colc", " colses", " colions", " colgs", "colops", "Coles", " coles", "Colrows", "colrows", "columnses", "columnions", " Cols", "keeps", "Coli", "colc", "Cols", "roundgs", "keepes", "keepc", " Coli", "collports", "columnes", "collops", "Coln", "roundports", "columnrows", "colp", "Colp", "columns", "colses", "columnn", "collgs", " colports", " Coles", "columni", "colgs", "colports", " colops"], "mines": ["colions", "coles", "tunions", "mins", "colists", "Mins", "ninions", "nines", "Mines", "Minists", " minists", "nineds", "minions", "tunes", "minists", "tunenses", "mineds", "ninenses", "Minenses", " mins", "minenses", "tuneds", " minions", "Mineds", "Minions"], "seen": ["selected", "written", "finished", "killed", "see", "changed", "given", "master", " unseen", "lost", "connected", "registered", "served", "expected", "used", "known", "missing", "kept", "received", "visible", "generated", "confirmed", "ordered", "found", "started", "hidden", "sent", "shown"], "visited": ["visenced", "navited", "navized", "navenced", "expited", "versionited", "visized", "navorted", "versionenced", "versionized", "expized", "exported", "expenced", "versionorted", "visorted"], "numbered": ["nor", "identified", "running", "locked", "address", "complete", "sequence", "printed", "design", "provided", "log", "won", "made", "index", "filled", "balls", "even", "member", "collection", "loaded", "drawn", "interrupted", "player", "specified", "length", "none", "initialized", "sized", "given", "kk", "modified", "iter", "zero", "umbered", "received", "ned", "winner", "mentioned", "blocks", "ordered", "occupied", "found", "shown", "steps", "rawn", "starting", "padding", "num", "limited", "written", "done", "lined", "blocking", "layout", "series", "inner", "config", "multi", "issued", "partial", "original", "encrypted", "initial", "below", "pointer", "nil", "generated", "meaning", "matched", "lines", "later", "umbers", "aligned", "shaped", "loader", "selected", "coll", "joined", "que", "en", "total", "meter", "colored", "string", "uno", "rown", "runner", "named", "ln", "line", "started", "signed"], "zeros": ["demons", "zos", "zersol", "zeoes", "demoes", "zeol", "zeroes", "zoes", "zersols", "zerols", "zeroos", "erops", "demo", "eros", "zedo", "logoos", "economos", "logos", "zersbos", "zyol", "demros", "zedons", "eroes", "economops", "bios", "zerOS", "zersors", "zero", "zerol", "zeos", "erons", "ero", "zros", "bio", "zedops", "demos", "zerons", "economoes", "zerso", "zersOS", "zyoids", "zersoes", "zeoids", "zOS", "persos", "zerues", "zebos", "econombos", "logols", "erors", "zedos", "zyos", "bioes", "persbos", "zersues", "zersons", "erues", "zerbos", "zedOS", "zersoids", "zo", "zybos", "zeo", "bions", "persoos", "persols", "zerros", "zersos", "zops", "zeops", "logbos", "zerops", "zons", "zerors", "zeroids", "zues", "demops", "zedoes", "zors", "zersops", "zersros", "zersoos"], "min_numbered": ["len_colored", "min_drawn", "min_colored", "len_sized", " min_drawn", "min_number", "len_numbered", "min_sized", "len_number", " min_colored"], "left": ["size", "counter", "d", "cle", "ne", "pos", "offset", "Left", "len", "coll", "lo", "pl", "p", "length", "none", "inner", "li", "flo", "roll", "leave", "partial", "ell", "small", "loc", "position", "nl", "l", "used", "cl", "initial", "hide", "zero", "fl", "index", "right", "last", "ln", "empty", "label", "ner", "cell", "null", "min", "two", "found", "cost", "le", "diff", "low", "lc"], "n": ["N", "e", "size", "d", "ne", "nd", "num", "i", "nor", "ns", "len", "p", "j", "u", "non", "count", "r", "nt", "z", "nan", "na", "un", "nn", "w", "m", "l", "network", "index", "nw", " c", "pn", "nb", "c", "ln", "sn", "k", "x", "nc", "b", "no", "f", "o", "nin"], "number": ["page", "range", "size", "N", "counter", "name", "num", "word", "coll", "month", "address", "length", "none", "letter", "column", "count", "non", "r", "total", "object", "umber", "group", "string", "error", "note", "div", "un", "nn", "position", "initial", "zero", "rown", "mult", "index", "value", "square", "block", "c", "work", "label", "even", "member", "null", "result", "line", "x", "node", "nr", "two", "b", "no", "version", "phone", "Number"], "row": ["page", "range", "rr", "name", "tr", "num", "family", "rc", "step", "coll", "month", "view", "Row", "length", "column", "year", "r", "ver", "ward", "arrow", "roll", "co", "pull", "group", "rw", "ew", "box", "record", "loc", "cur", "feed", "position", "ow", "rot", "rect", "arch", "rank", "entry", "index", "rown", "order", "value", "right", "chrom", "rh", "port", "ro", "zip", "block", "sel", "c", "round", "model", "ack", "key", "cell", "head", "ry", "node", "x", "line", "ull", "keep", "ug", "rid", "post", "user"], "col": ["il", "COL", "poly", "pl", "fil", "near", "val", "div", "cy", "oy", "log", "day", "index", "zip", "sel", "c", "sec", "cell", "y", "fact", "cm", "con", "fc", "ind", "page", "pos", "word", " column", "ch", "length", "ll", "byn", "count", "cat", "ill", "cond", "field", "ell", "cor", "x", "cycle", "f", "ne", "num", "fn", "p", "year", "icol", "rel", "file", "co", "long", "loc", "inc", "el", "char", "block", "key", "ol", "min", "keep", "pol", "Col", "ail", "coll", "lo", "cal", "child", "column", "ct", "nt", "ref", "roll", "cur", "rot", "cl", "fl", " Col", "win", "round", "int", "nc", "line", "cel", "path", "cp", "lc"], "neigh": ["geigh", "uneibling", "naigh", " nealth", "nigh", "bealth", "nyigh", "neoph", "nux", "enneight", " neig", "geig", "naque", "beih", "unechel", "naight", "geighth", "seoph", "night", " neuth", "Nealth", " kneisen", "naih", "neih", "nyil", "nyih", "notealth", "seigh", "pseighth", "pseoph", "naig", "noteeks", "meighth", "neagle", "neibling", "nig", "annealth", "noteigh", "annechel", "nealth", "pseuth", "neight", "enneig", "NEir", "seagle", "Neoph", "enneigh", " neoph", " neighth", "NEalth", "naighth", "neisen", " kneoph", "neux", "neighth", "uneigh", "naeks", " neir", "nchel", " neibling", "beigh", "noph", "neir", "nyalth", "nechel", "ennealth", "seuth", "Neisen", "nair", " neagle", "meoph", "neque", "seighth", "nighth", "mechel", " neque", "neuth", "naalth", "noteig", "neeks", " neeks", "pseagle", "unealth", "neil", "seig", "geux", " nechel", " knealth", " kneigh", "nagle", "nail", "NEagle", " neisen", "geoph", "NEigh", " neux", "pseigh", "neig", "noteque", "meigh", "pseig", "anneibling", "naagle", "anneigh", "beil", "nalth", "naoph", "gealth", "Neigh", "noteighth", "nachel"], "board": ["bird", "league", "loop", "room", "deck", "bo", "cart", "coll", "boards", "view", "bug", "layout", "list", "channel", "hole", "sequence", "holder", "flow", "book", "form", "stream", "flo", "object", "land", "comment", "card", "error", "group", "bar", "box", "game", " boards", "feed", "Board", "la", "block", "model", "conference", " clipboard", "buffer", "bank", "code", "path", "chain", "foot", "phone", "control", "menu", "table", "store"], "pop": ["clear", "crop", "shift", "high", "highest", "drop", "pick", "delete", "op", "clone", "peak", "first", "push", "pull", "Pop", "top", "prev", "reverse", "flush", "fork", "stack", "close", "last", "back", "remove", "head", "tail", "bottom"]}}
{"code": "\\n  INPUT = 'B-small-attempt1.in'\\n  OUTPUT = 'B-small-attempt1.out'\\n  \\n  \\n  def solve(C, F, X):\\n  \\n      cps = 2.0\\n      farm_time = 0.0\\n      time = X / cps\\n      \\n      while True:\\n          farm_time += C / cps\\n          cps += F\\n          ntime = farm_time + X / cps\\n          if ntime < time:\\n              time = ntime\\n          else:\\n              break\\n      return time\\n  \\n  \\n  if __name__ == '__main__':\\n      inp = open(INPUT)\\n      out = open(OUTPUT, 'w')\\n      \\n      T = int(inp.readline())\\n  \\n      for case in range(T):\\n          sol = solve(*map(float, inp.readline().split()))\\n          out.write('Case #%i: %.7f\\n' % (case + 1, sol))\\n", "target": "34", "substitutes": {"INPUT": ["InLINE", "inPUT", "inFILE", "inFORMATION", "INFILE", "InFIG", "INFORMATION", "ANSFILE", "InPUT", "ANSPUT", "INFIG", "inPORT", "ANSFORMATION", "inLINE", "INLINE", "InFORMATION", "ANSPORT", "INPORT", "inFIG", " INFIG", "InPORT", " INLINE", "InFILE", " INFILE"], "OUTPUT": ["OUTTPUT", "OUTPOURCE", "OUTERUTE", "OUGPPUT", "OUTTPOU", "OUTPUTUT", "OUSPPUT", "OUTERUT", "OUTTPOURCE", "OUTCUTE", "OUTPOU", "OUTPULT", "OUTCut", "OUTPUTE", "OUGPUT", "OUTTPPUT", "OUSPut", "PUSPULT", "OUSPOU", "OUTCUT", "OUGPOURCE", "OUTPUTOURCE", "PUTPut", "PUSPut", "OUPUTOU", "OUPUTOURCE", "OUTPPUT", "OUTPUTPUT", "OUTERULT", "OUSPUTE", "OUPUTPUT", "OUSPUT", "OUTERut", "PUTPUTE", "OUSPOURCE", "PUSPUTE", "OUGPOU", "OUTPUTOU", "PUSPUT", "OUSPULT", "OUTCULT", "OUPUTUT", "PUTPULT", "OUTPut", "PUTPUT"], "C": ["N", "CF", "Cs", "U", "G", "Co", "Cu", "O", "I", "CA", "W", "M", "CM", "K", "DC", "CC", "L", "D", "A", "R", "B", "S", "FC", "c", "CV", "E", "H", "V", "CU", "Y", "Q", "P"], "F": ["N", "cf", "CF", "U", "G", "FD", "DF", "Time", "FI", "O", "I", "FB", "W", "M", "L", "D", "FO", "A", "R", "FH", "PF", "B", "GF", "WF", "FM", "FE", "Fun", "E", "H", "Farm", "V", "FF", "Y", "Q", "P", "f", "FG", "FW"], "X": ["N", "CF", "U", "XL", "XP", "Time", "J", "IX", "Event", "XXX", "CL", "I", "TX", "W", "M", "Z", "CE", "K", "XM", "CC", "L", "D", "A", "R", "B", "E", "H", "x", "V", "FF", "Y", "Q", "P", "XX"], "cps": ["ucfs", " cpy", "cups", "crcs", "dops", "pcfs", " ccs", "cpe", "ucups", "pcpy", "cfs", "lcfs", "ufs", "acps", "dpe", " cPS", "ccs", "crfs", "CPS", "Cups", "uops", "upe", "dps", "lcpc", "ups", " cops", "upc", "ucPS", "lccs", "upped", "cpc", "Cpy", "dpped", "pcPS", " cfs", "pcps", "ucps", "lcPS", "cpy", "lcps", "crps", "crpped", "cops", " cpped", "cpped", " cpe", "Cps", "acPS", "acfs", "acups", "Cpc", "lcpped", "uPS", "cPS", "Cfs"], "farm_time": ["farm\u00b7times", "fork_length", "fork_times", "farmactime", "farmaclength", "farm_speed", " farm_volume", " farm_times", "farm_times", "farm_Time", "farmactimes", "field_time", "farm_power", "fork_time", "farm_length", "farm_volume", "farm\u00b7time", " farm_Time", "field_speed", "field_times", "field_power", "farm\u00b7volume", "farm\u00b7Time"], "time": ["e", "size", " TIME", "speed", "name", "duration", "money", "weight", "id", "power", "h", "Time", "timeout", "length", "ime", "im", "force", "val", "t", "response", "form", "file", "_", "v", "etime", "ed", "space", "date", "race", "rice", "error", "UTC", "type", "TIME", "rank", "age", "clock", "function", "rate", "value", "data", "back", "times", "c", "work", " times", "cache", "end", "frame", "depth", "call", "cycle", "x", "line", "timer", "term", "cost", "f", "frequency", " Time"], "ntime": ["ctile", "ndype", "ntile", "rtime", "ntrace", "NTime", "ncim", "ctime", "owntimes", "owntetime", "ntimes", "uptime", "uptype", "ndime", "uptrace", "ctimate", "ntetime", "ptimate", "ncimate", "ncimes", "owntime", "uptile", "ndile", "ntype", "ntim", "ctype", "ptim", "rtimes", "NTimes", "ptime", "ncime", "rtice", "NTice", "owntice", "ctimes", "ntice", "ndrace", "rtetime", "ctrace", "ntimate", "NTetime", "ctim", "ptimes"], "inp": ["inncp", "cinps", "inper", " inps", "fileps", "innps", "fileb", "innper", "winps", "filec", "infp", " infp", "innp", "cinp", "incb", "incp", "winp", "inps", " inproc", "inc", "incps", "winfp", "Inproc", "Infp", " incp", "inb", " inb", " inc", "incc", "filep", "cincp", "winproc", " inper", "Inp", "inproc", "cinper", "Inps"], "out": ["at", "exec", "extra", "client", "name", "OUT", "word", "p", "outs", "op", "image", "file", "output", "exp", "object", "io", "error", "writer", "part", "ext", "obj", "w", "again", "log", "outer", "block", "cache", "new", "temp", "parent", "call", "line", "off", "to", "err", "no", "o", "copy", "up", "net", "Out", "outside"], "T": ["N", "Test", "U", "G", "TN", "Time", "O", "I", "CL", "LT", "TS", "W", "t", "TA", "M", "TH", "L", "GT", "WT", "TW", "Case", "R", "B", "S", "TT", "E", "PO", "V", "Total", "Y", "Q", "P", "CT", "DT"], "case": ["size", "rial", "name", "fold", "id", " trial", "pose", "section", "match", "ace", "ce", "complete", "sequence", "instance", "ase", "cases", "number", "nce", "CE", "ASE", "rice", "race", "uc", "position", "Case", "ice", "c", "use", "int", "pe", "ide", "test", "ACE", "CI", "catch", "x", "lic", "line", "choice", "USE", "phase", " CASE", "code"], "sol": ["sal", "sle", "ele", "sql", "rol", "lo", "scl", "ll", " Sol", "sch", "wl", "LO", "rel", "level", "li", "flo", "ell", "mol", "loc", "pal", "nl", "NL", "L", "el", "l", "ls", "cl", "sel", "ole", "ln", "sn", "rl", "vel", "ol", "isol", "OL", "olve", "dL", "le", "Sol", "Solution", "less"]}}
{"code": "\\n  INPUT = 'C-small-attempt0.in'\\n  OUTPUT = 'C-small-attempt0.out'\\n  \\n  \\n  def solve(R, C, M):\\n      grid = [[0 for c in range(C)] for r in range(R)]\\n  \\n      def get_cell(cell_r, cell_c):\\n          if not(0 <= cell_r < R):\\n              return None\\n          if not(0 <= cell_c < C):\\n              return None\\n          return grid[cell_r][cell_c]\\n  \\n      def for_each_neighbour(cell_r, cell_c, func):\\n          ret = []\\n          coords = (\\n              (cell_r - 1, cell_c - 1), (cell_r - 1, cell_c), (cell_r - 1, cell_c + 1),\\n              (cell_r, cell_c - 1), (cell_r, cell_c + 1),\\n              (cell_r + 1, cell_c - 1), (cell_r + 1, cell_c), (cell_r + 1, cell_c + 1)\\n          )\\n          for nb in coords:\\n              if get_cell(nb[0], nb[1]) is not None:\\n                  ret.append(func(nb[0], nb[1]))\\n          return ret\\n  \\n      def mark_dirty(cell_r, cell_c):\\n          if grid[cell_r][cell_c] != '*':\\n              grid[cell_r][cell_c] += 1\\n      \\n      def unmark_dirty(cell_r, cell_c):\\n          if grid[cell_r][cell_c] != '*':\\n              grid[cell_r][cell_c] -= 1\\n  \\n      def check_empty_neighbours(cell_r, cell_c):\\n          return (0 in for_each_neighbour(cell_r, cell_c, lambda r, c: get_cell(r, c)))\\n  \\n      def click():\\n          for i, row in enumerate(grid):\\n              for j, cell in enumerate(row):\\n                  if cell != '*':\\n                      if cell == 0 or ((R * C - M) == 1):\\n                          grid[i][j] = 'c'\\n                          return\\n  \\n      def place_mine():\\n          for i, row in enumerate(grid):\\n              for j, cell in enumerate(row):\\n                  if cell == '*':\\n                      continue\\n                  prevstate = grid[i][j]\\n                  grid[i][j] = '*'\\n                  for_each_neighbour(i, j, mark_dirty)\\n                  if not (True in for_each_neighbour(i, j, check_empty_neighbours)):\\n                      grid[i][j] = prevstate\\n                      for_each_neighbour(i, j, unmark_dirty)\\n                  else:\\n                      return True\\n          return False\\n  \\n      for m in range(M):\\n          if not place_mine():\\n              return 'Impossible\\n'\\n  \\n      click()\\n  \\n      ret = ''\\n      for row in grid:\\n          ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '\\n'\\n  \\n      return ret\\n  \\n  \\n  if __name__ == '__main__':\\n      inp = open(INPUT)\\n      out = open(OUTPUT, 'w')\\n      \\n      T = int(inp.readline())\\n  \\n      for case in range(T):\\n          sol = solve(*map(int, inp.readline().split()))\\n          out.write('Case #%i:\\n%s' % (case + 1, sol))\\n", "target": "34", "substitutes": {"INPUT": ["inCT", "inST", " INOU", "inPUT", " INCT", " OUTOU", "INOU", " OUTCT", "INST", "inOU", " INST", "INCT", " OUTST"], "OUTPUT": ["OUTAOT", " OUTTPUT", " OUTTAUT", "OUTROT", " OUTTPOT", " OUTTPTE", " OUTTPURE", "OUTAURE", "OUPLURE", "OUPLTE", "OUTRUT", "OUTPOT", " OUTTAOT", "OUTPTE", " OUTTATE", " OUTTAURE", "OUTPURE", "OUPLOT", "OUTATE", "OUTRTE", "OUTAUT", "OUTRURE", "OUPLUT"], "R": ["N", "Rh", "U", "RH", "G", "X", "RR", "MR", "W", "Rs", "K", "RC", "RO", "RN", "SR", "L", "D", "A", "B", "S", "CR", "E", "H", "F", "V", "DR", "RM", "GR", "Y", "NR", "Q", "P", "RA", "RG"], "C": ["N", "JC", "U", "UC", "G", "X", "SC", "CL", "I", "CA", "W", "NC", "CM", "K", "VC", "EC", "Z", "DC", "CP", "CC", "L", "D", "A", "MC", "CN", "B", "S", "CO", "CV", "CR", "E", "H", "AC", "F", "CI", "V", "CU", "Y", "Q", "P", "CT", "Cr"], "M": ["N", "U", "G", "X", "J", "O", "I", "MR", "W", "Z", "CM", "K", "MN", "L", "D", "A", "MC", "B", "S", "CR", "E", "H", "F", "V", "RM", "Y", "Q", "P", "LM"], "grid": ["lay", "range", "ge", "module", "client", "col", "rule", "cube", "cart", "panel", "surface", "gui", "slice", "unit", "layout", "grain", "export", "auto", "gr", "input", "list", "column", "arr", "book", "gu", "file", "map", "press", "gap", "group", "res", "layer", "domain", "mat", "align", "div", "mag", "box", "dict", "edge", "Grid", "q", "query", "age", "entry", "graph", "data", "storage", "reg", "block", "model", "cache", "df", "house", "node", "window", "line", "site", "db", "vg", "complex", "cm", "array", "chain", "draw", "server", "g", "hold", "gm", "table", "station"], "c": ["cf", "e", "mc", "rr", "d", "col", "rc", "h", "ac", "dc", "p", "ch", "ar", "ce", "ct", "v", "cu", "cs", "w", "uc", "cy", "n", "ci", "l", "ca", "xc", "rh", "pc", "cc", "anc", "cin", "rn", "ec", "x", "nc", "cm", "b", "f", "err", "cr", "con", "cn", "cp", "lc"], "r": ["e", "range", "yr", "rr", "rb", "d", "fr", "rc", "p", "pr", "ar", "mr", "u", "er", "co", "ra", "ir", "re", "w", "n", "hr", "usr", "rf", "resource", "ru", "rh", "rt", "kr", "k", "rs", "rd", "sr", "run", "nr", "ri", "b", "rg", "f", "cm", "cr", "err", "rar"], "cell_r": ["cel_hr", "cell_ar", "cell_hr", "cellalrc", "char_t", "cellingc", " cell_rb", "client_hr", "char64nr", "cell1r", "draw_r", "cell9hr", "charalrec", "charalrc", "char_rc", "cell_nr", " cell_rc", "cell9r", "cel_h", "client9ro", "char64dr", "cell64c", "charge_right", "cel_er", "cellJc", "cellalr", "draw_nr", "char64c", "case_ro", "cell64r", "cel_sr", "cell_h", "cell1rw", "cell_rh", "cell1c", "cel_ro", "cell_rc", "cell_d", "cell_right", "cell64dr", "cel_o", "cellJnr", "client9rt", "cell_o", "cellinghr", "cell9rt", "charalt", "draw_ro", "cellalt", "cellJhr", " cell_l", "save_r", "cel_nr", "cel_ur", "cell_er", "cell_n", "cell_l", "save_nr", "cel_ar", "cel_c", "cellJrt", "draw_n", "cellJr", "case_d", "cell_dr", "cell64h", "cell1nr", "char_dr", "char_r", "char_c", "charge_rb", "cell_rt", "cell_sr", "cell_ro", "cellingdr", "cel_l", "cel_rw", "cel_rt", " cell_ar", "client9hr", "case_c", "client9r", "charalr", "cell9ro", "cell_rec", "cell64ar", "save_ro", "cellJrh", "cel_r", "cel_right", "cellalrec", "save_rh", " cell_nr", "charge_nr", "char64r", "cellJro", "client_r", "cellJdr", "cel_dr", "char_rec", "charge_r", "cell_t", "client_rt", "cellingr", "cell_rb", "cell_rw", "case_r", "cell64nr", "cell_ur", "char_nr", "cellingsr", "client_ro"], "cell_c": ["cell_fc", "cell67fc", "cell25center", "cel_dc", "ell_c", " cell_ci", "cellXrec", "cellacr", "cellDr", "cell67r", "cellAcenter", "cell67i", "save67c", "cellIPcs", "cell_dc", "cellAc", "cellWm", "cellFfc", " cell_center", "cellJcenter", " cell_rec", "cell67c", " cell_i", "cellacdc", "ell_chain", "Cell_r", "cellIdc", "cell_1", "cell_ci", "cellWc", "cellAcc", " cell_con", "ell_cur", "cel_fc", "cellJc", " cell_cc", "cellIPcin", "cellXc", "save_c", "cell25d", "cell_cu", "cellXcc", "ice_c", "cellDm", "cell25i", "cell54t", "cellAci", "cell_pc", "cell_m", "iceJcur", "cell_center", "iceJcenter", "cellAfc", "cell67cu", "cel_ec", "cellSc", "cell_w", "cell67ec", "cell_d", "pixel_cin", "cell_chain", "cellDc", "cellIdw", "cellFci", "save67r", "cell_cc", "cel_i", "cellIPr", "cellAr", "cell_cs", "Cell_cu", "cell25r", "CellIPcs", "cel_ci", "Cell_cs", " cell_cin", " cell_m", "cell_ec", "cellIPfc", "ice_center", "iceJc", "cel_cu", "cell67t", " cell_fc", "cellScenter", "cell_b", "cell_cur", "cellLcin", "CellIPcu", "save_r", "cellJw", "cell_n", "pixel_d", "cell_ct", "cell67nc", "cell53r", "cellac1", "save67nc", "contact_c", " cell_C", "cell25fc", "cellAi", "cellXC", "cellIdr", "cellArec", "cel_c", "cell25b", "cel_b", "cell67cin", "cellacc", "cellIPchain", "cellWcon", "save67t", "save_nc", "cell54nc", "cellIPcu", "cellSw", "cellWr", "cel_center", "Cell_c", "cellIPC", "ice_w", "cellIPc", "cel_cin", "cell_nc", "cellFr", "CellIPc", "pixel_c", "cellLr", "cel_C", " cell_w", "cell_rec", "cellIPcur", "cel_ct", "cell_i", "cell25ci", "cel_r", "cel_1", "cell25c", "cell53ci", "cell_con", "contact_cs", "contact_chain", "cellJcur", "cell67center", "save_t", "cell_C", "contact_n", "cellScur", "ice_cur", "cell67ci", "cel_d", "cell54r", "cell53cin", "CellIPr", "cellAC", "cellLc", "cell_t", " cell_pc", "cellFc", "cellDcon", "cell54c", "cell_cin", "ell_C", "pixel_r", "cellIdpc", "cell53c", "iceJw"], "func": ["cf", " function", "proc", "aug", "exec", "comb", "module", "loop", "self", "cb", "fn", "slice", "apply", "dec", "fun", "val", "sys", "map", "layer", "obj", "loc", "method", "function", "Function", "conv", "callback", "bc", "cc", "work", "unc", "super", "pc", "df", "sec", "worker", "node", "nc", "code", "con", "f", "fc", "wrapper"], "ret": ["Ret", "resp", "d", "default", "fn", "len", "true", "str", "alt", "bf", "fun", "arg", "arr", "val", "nt", "repl", "output", "ref", "res", "group", "part", "rep", "det", "mat", "re", "obj", "ext", "dict", "el", "gt", "data", "rt", "reg", "all", "last", "end", "result", "rets", "reply", "db", "detail", "b", "array", "fab", "RET", "union"], "coords": ["locinates", "Cocoord", "locords", "coordord", " cocoord", "Coinates", "Coords", "coordords", "coord", "coordinates", "cocoord", "locord", "coinates", "locorder", " coorder", "coorder", "Coord", "loccoord", " coinates", "coordorder", " coord"], "nb": ["ny", "nob", "bb", "ob", "ne", "cb", "nd", "ns", "num", "fn", "iq", "eb", "bf", "sb", "bg", "byn", "bm", "qq", "lab", "number", "wb", "ni", "nm", "bn", "obj", "NB", "nn", "nl", "n", "gb", "np", "adj", "kb", "bd", "binary", "net", "bi", "ib", "batch", "bc", "abb", "bin", "sn", "nit", "node", "nc", "ab", "nr", "bs", "db", "bp", "b", "dn", "mb", "cn", "nu"], "i": ["e", "gi", "si", "ini", "xi", "mi", "p", "I", "u", "li", "pi", "ai", "ui", "v", "io", "n", "ci", "l", "ii", "bi", "di", "yi", "k", "x", "y", "ri", "iu", "b", "f", "o"], "row": ["range", "col", "id", "rows", "cube", "slice", "item", "Row", "auto", "input", "child", "column", "flow", "roll", "object", "v", "group", "ell", "feed", "q", "entry", "index", "ray", "order", "data", "raw", "block", "key", "k", "x", "node", "line", "array", "post", "user", "bug"], "j": ["e", "si", "d", "uj", "h", "J", "p", "ch", "jet", "z", "jl", "li", "jj", "v", "left", "q", "n", "l", "adj", "jp", "ij", "ii", "kj", "el", "dj", "job", "ja", "jc", "ji", "k", "x", "y", "aj", "b", "f", "o"], "cell": ["charge", " Cell", "col", "offset", "num", "Cell", "slice", "p", "cal", "column", "count", "z", "ver", "form", "cells", "co", "v", "group", "field", "ell", "un", "inc", "uc", "q", "ci", "pixel", "l", "entry", "ice", "index", "component", "model", "cc", "label", "cache", "key", "sec", "k", "call", "x", "line", "node", "cel", "ind", "f", "o", "g", "lc"]}}
{"code": "\\n  class Solver(object):\\n      def __init__(self):\\n          pass\\n      \\n      def solve(self, inputs):\\n          c, f, x = [float(t) for t in inputs[0].split()]\\n          if x <= c:\\n              return '%.7f'%(x/2)\\n          ii = int(math.ceil((f*x-2*c)/(f*c)-1))\\n          if ii <= 0:\\n              return '%.7f'%(x/2)\\n          t = 0\\n          for i in range(ii):\\n              t += c/(2+i*f)\\n          t += x/(2+ii*f)\\n          return '%.7f'%t\\n          pass\\n      \\n      def feed(self, inputs):\\n          lines = [x.strip() for x in inputs]\\n          outputs = []\\n          test_case_n = int(lines[0])\\n          cur = 1\\n          for i in range(test_case_n):\\n              i = i\\n              case_line_cnt = 1\\n              case_inputs = lines[cur:cur+case_line_cnt]\\n              cur += case_line_cnt\\n              outputs.append(self.solve(case_inputs))\\n          return outputs\\n  \\n  if __name__ == '__main__':\\n      iname = 'B-small-attempt0.in'\\n      sample_in = '''\\n      4\\n  30.0 1.0 2.0\\n  30.0 2.0 100.0\\n  30.50000 3.14159 1999.19990\\n  500.0 4.0 2000.0\\n      '''\\n      sample_out = '''\\n  Case #1: 1.0000000\\n  Case #2: 39.1666667\\n  Case #3: 63.9680013\\n  Case #4: 526.1904762\\n      '''\\n      if os.path.exists(iname):\\n          with open(iname) as f:\\n              inputs = f.readlines()\\n      else:\\n          inputs = [x.strip() for x in sample_in.split('\\n') if x.strip()]\\n      solver = Solver()\\n      outputs = solver.feed(inputs)\\n      fail_flag = False\\n      if os.path.exists(iname):\\n          with open(iname+'.out', 'w') as f:\\n              for i, v in enumerate(outputs):\\n                  print >> f, 'Case #%d: %s'%(i+1, str(v))\\n      else:\\n          ans = set([x.strip() for x in sample_out.split('\\n') if x.strip()])\\n          for i, v in enumerate(outputs):\\n              t = 'Case #%d: %s'%(i+1, str(v))\\n              if t not in ans:\\n                  print '!!! Wrong:', t\\n                  fail_flag = True\\n      print '===================================================='\\n      for i, v in enumerate(outputs):\\n          print 'Case #%d: %s'%(i+1, str(v))\\n      print '===================================================='\\n      print 'done' if not fail_flag else 'fail'\\n      pass\\n", "target": "35", "substitutes": {"self": ["e", "gen", "full", "ws", "client", "ns", "driver", "h", "Self", "p", "j", "view", "er", "context", "r", "selves", "host", "_", "object", "writer", "connection", "w", "q", "es", "m", "cl", "os", "plugin", "all", "work", "cache", "super", "app", "parent", "peer", "k", "worker", "reader", "node", "this", "ng", "o", "user", "server", "g"], "inputs": ["outputd", " inputd", "drawlines", "Inputtests", "subjectlines", "contractlines", "subjects", " inputerences", "inputtests", "inputws", "Inputments", "outputws", "outputtests", "Inputd", "inputings", "inputabs", " inputabs", "inputments", "draws", "Inputws", "contractings", "contractd", "Inputings", "outputp", "outputments", "Inputs", "outputings", "outputlines", " inputments", "inputsets", " inputsets", "inputlines", " inputp", "drawp", " inputches", "outputabs", "Inputlines", "Inputches", " inputlines", "outputches", "inputches", "subjecterences", "inputd", "outputerences", "inputerences", "inputp", "Inputabs", "subjectsets", " inputws", "contracts", "outputsets", " inputtests"], "c": ["e", "cf", "size", "d", "col", "h", "C", "p", "ch", "ce", "max", "u", "case", "count", "z", "r", "cs", "w", "cy", "q", "n", "ci", "m", "l", "g", "cc", "s", "a", "k", "y", "con", "b", "cm", "fc", "o", "cn"], "f": ["fw", "fm", "fb", "tf", "io", "ff", "buff", "fe", "y", "fc", "fa", "fore", "fr", "z", "uf", "feed", "w", "n", "l", "s", "a", "df", "F", "arf", "b", "o", "ef", "e", "full", "fd", "d", "fn", "fac", "p", "j", "ce", "lf", "af", "file", "form", "elf", "m", "ci", "fp", "fs", "files", "fen", "info", "cf", "h", "xf", "bf", "fi", "u", "r", "fo", "ft", "ref", "sf", "q", "rf", "fl", "g"], "x": ["xs", "xt", "name", "xp", "pl", "fx", "val", "index", "xc", "text", "wx", "xxxx", "xe", "xx", "y", "con", "fc", "ax", "event", "plus", "X", "z", "tx", "_", "w", "n", "l", "s", "time", "pe", "test", "ic", "code", "b", "o", "e", "xa", "d", "id", "p", "xy", "j", "xml", "max", "input", "xes", "rx", "on", "re", "m", "ci", "size", "xi", "ux", "exc", "content", "h", "xf", "u", "ct", "hex", "xb", "string", "q", "ex", "xxx", "int", "python", "ix", "sw"], "t": ["e", "tt", "at", "d", "col", "ta", "h", "p", "j", "start", "u", "r", "z", "nt", "tf", "ty", "it", "dt", "tu", "w", "q", "type", "n", "m", "l", "ot", "T", "tim", "ut", "ti", "tc", "s", "time", "tp", "int", "a", "E", "test", "y", "b", "o", "g", "ts"], "ii": ["gi", "ini", "si", "xi", "iq", "mini", "abi", "fi", "vi", "iii", "u", "zi", "z", "ie", "li", "pi", "ai", "ui", "sci", "ni", "n", "ci", "l", "py", "lli", "ice", "index", "ei", "inf", "bi", "ti", "di", "yi", "int", "ix", "y", "iu", "ind", "II", "chi", "qi"], "i": ["e", "gi", "si", "ini", "xi", "ip", "d", "mi", "id", "h", "lo", "p", "j", "fi", "I", "vi", "u", "im", "zi", "ie", "z", "r", "li", "pi", "ai", "ni", "ui", "io", "n", "ci", "m", "l", "index", "ei", "bi", "di", "ti", "yi", "int", "ic", "k", "phi", "y", "iu", "b", "ind", "o", "qi"], "lines": ["rules", "ws", "xs", "ines", "vals", "qs", "ids", "reads", "rows", "words", "points", "lf", "sections", "codes", "cases", "cells", "lins", "ds", "lin", "ses", "forms", "comments", "elines", "pages", "log", "ins", "l", "ls", "breaks", "groups", "models", "frames", "files", "strings", "faces", "blocks", "cycles", "tests", "items", "vs", "line", "limits", "ends", "runs", "objects", "steps", "liners"], "outputs": ["inputwords", "Outputp", "outputd", "outputposts", "returnf", " Outputsd", "feeds", "outputwords", "Outputposts", " outputsd", " outputh", "Outputh", "returnd", "returnwords", " outputd", "outputsd", "returns", "inputments", "inputh", "Outputlines", "outputp", " outputments", " Outputs", " outputf", "outputlines", "inputf", "inputlines", "outputparts", "inputposts", " outputposts", "outputf", "Outputs", " outputparts", "Outputments", "inputd", " outputwords", "outputh", "Outputd", "inputparts", "inputp", "Outputparts", "outputments", " outputlines", "feedsd", " outputp"], "test_case_n": ["test_cases_p", "test_case1n", "test_case_p", "test_case__c", "test_case1sn", "test_case_b", "test_case1c", "test_cases_sn", "test_cases_b", "test_case__b", "test_case_ns", "test_case_sn", "test_cases_ns", "test_case1b", "test_case__sn", "test_cases_n", "test_case_c", "test_case__n", "test_cases_c"], "cur": ["comb", "tt", "inter", "pub", "col", "id", "ctr", "shift", "rc", "tri", "p", "ch", "ur", "current", "pr", "length", "dec", "dr", "start", "ah", "u", "count", "Cur", "r", "ver", "ct", "uu", "cu", "row", "prev", "inc", "iter", "uc", "loc", "ci", "cont", "sth", "usr", "sur", "rest", "cor", "char", "end", "ph", "k", "catch", "nc", "keep", "sc", "ind", "cr", "const", "quad", "ser"], "case_line_cnt": ["case_line_acount", "case_line_Cnt", "case_line_Cno", "case_line_nNT", "case_line_acno", "case_line_nount", "case_line_acnt", "case_line_lccount", "case_line_ccount", "case_line_nnc", "case_line_cNT", "case_line_fccount", "case_line_cno", "case_line_account", "case_line_acnc", "case_line_cnc", "case_line_lcnt", "case_line_fcNT", "case_line_acNT", "case_line_Count", "case_line_count", "case_line_lcNT", "case_line_fcnt", "case_line_lcnc", "case_line_lcno", "case_line_fcnc", "case_line_nnt", "case_line_CNT", "case_line_Cnc"], "case_inputs": ["case_outputws", "case_incd", "case_inclines", "case_configd", "case_outputments", "case_countws", "case_outputlines", "case_outputions", "case_incments", "case_countlines", "case_inputlines", "case_lengths", "case_configlines", "case_lengthions", "case_outputd", "case_counts", "case_incs", "case_inputments", "case_inputd", "case_lengthlines", "case_configs", "case_countions", "case_outputs", "case_lengthws", "case_configments", "case_inputions", "case_inputws"], "iname": ["innami", "incfer", "coe", " inname", "incaming", " inamel", "inioe", "inAME", " inamer", "cinamer", "iniam", "iniette", "iniami", " inaming", "came", "cname", " inami", "incame", " inames", "niname", "iniamer", "innames", " inoe", "iniaming", "inam", " inam", "inette", "innette", "inamel", "cames", "iniAME", "ninAME", "inoe", "inamer", "incames", "inami", "iniame", "inifer", "inames", "infer", "inname", "ininame", "ciname", " infer", " inette", "inaming", "incAME", " inAME", "ninames", "cinAME", "cinam", "ninamel", "incamel", "iniames"], "sample_in": ["sample2ins", "sample_ins", "sample67out", "sample2out", "sample67in", " sample_ins", "sample_inc", "sample_inas", "sample67inc", "sample2inas", " sample_inc", "sample67config", " sample_inas", "sample2in", "sample_config", " sample_config"], "sample_out": [" sample_again", "sample_again"], "solver": ["Saver", " sistor", " solve", "setsistor", "solve", "Solution", "solution", " solution", "saver", "setsolver", "setsolution", "setsolve", "Solve", "setsaver", "Solver", "Sistor", "sistor"], "fail_flag": ["fail_lag", "fail1status", "fail1flag", "pass_lag", "fail1count", "pass_count", "fail__count", "fail1lag", "pass_flag", "fail__flag", "fail__lag", "fail_count", "fail__status", "fail_status", "pass_status"], "v": ["nv", "vals", "d", "ve", "lv", "p", "j", "vv", "vi", "u", "iv", "z", "val", "r", "values", "ev", "va", "w", "vd", "q", "l", "av", "sv", "k"]}}
{"code": "\\n  class Solver(object):\\n      def __init__(self):\\n          pass\\n      \\n      def solve(self, inputs):\\n          R, C, M = [int(x) for x in inputs[0].split()]\\n          mp = []\\n          for r in range(R):\\n              mp.append(['.']*C)\\n          mp[0][0] = 'c'\\n          outputs = []\\n          if M == 0:\\n              for row in mp:\\n                  outputs.append(''.join(row))\\n              return outputs\\n          rr, cc, rm = R, C, M\\n          while rm >= min(rr, cc):\\n              if rr <= cc:\\n                  for r in range(rr):\\n                      mp[r][cc-1] = '*'\\n                  cc -= 1\\n                  rm -= rr\\n              else:\\n                  for c in range(cc):\\n                      mp[rr-1][c] = '*'\\n                  rr -= 1\\n                  rm -= cc\\n          \\n          if rm == 0:\\n              if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R, C) != 1:\\n                  return ['Impossible']\\n          else:\\n              if min(rr, cc) - rm >= 2:\\n                  if rr <= cc:\\n                      for r in range(rr-rm, rr):\\n                          mp[r][cc-1] = '*'\\n                  else:\\n                      for c in range(cc-rm, cc):\\n                          mp[rr-1][c] = '*'\\n              else:\\n                  if min(rr, cc) >= 4:\\n                      if rr <= cc:\\n                          for r in range(2, rr):\\n                              mp[r][cc-1] = '*'\\n                          mp[rr-1][cc-2] = '*'\\n                      else:\\n                          for c in range(2, cc):\\n                              mp[rr-1][c] = '*'\\n                          mp[rr-2][cc-1]='*'\\n                  elif min(rr,cc) == 3:\\n                      if max(rr, cc) == 3:\\n                          return ['Impossible']\\n                      else:\\n                          if rr <= cc:\\n                              mp[2][cc-1] = '*'\\n                              mp[2][cc-2] = '*'\\n                          else:\\n                              mp[rr-1][2] = '*'\\n                              mp[rr-2][2] = '*'\\n                  else:\\n                      return ['Impossible']\\n                      \\n          for row in mp:\\n              outputs.append(''.join(row))\\n          return outputs\\n          pass\\n      \\n      def feed(self, inputs):\\n          lines = [x.strip() for x in inputs]\\n          outputs = []\\n          test_case_n = int(lines[0])\\n          cur = 1\\n          for i in range(test_case_n):\\n              i = i\\n              case_line_cnt = 1\\n              case_inputs = lines[cur:cur+case_line_cnt]\\n              cur += case_line_cnt\\n              R, C, M = [int(x) for x in case_inputs[0].split()]\\n              rslt = self.solve(case_inputs)\\n              if self.verify(rslt, R, C, M):\\n                  outputs.append(rslt)\\n              else:\\n                  raise 'Failed'\\n          return outputs\\n      \\n      def verify(self, outputs, RR, CC, MCNT):\\n          if 'Impossible' == outputs[0]:\\n              return True\\n          rr = len(outputs)\\n          cc = len(outputs[0])\\n          if RR != rr or CC != cc:\\n              return False\\n          bd = []\\n          mask = []\\n          for i in range(rr):\\n              mask.append([1]*cc)\\n              bd.append([0]*cc)\\n              for j in range(cc):\\n                  if outputs[i][j] == '*':\\n                      bd[i][j] = 9\\n                  elif outputs[i][j] == 'c':\\n                      start = (i, j)\\n          for r in range(rr):\\n              for c in range(cc):\\n                  if bd[r][c] == 9:\\n                      for i in [r-1,r,r+1]:\\n                          for j in [c-1,c,c+1]:\\n                              if 0 <= i < rr and 0 <= j < cc:\\n                                  if bd[i][j] != 9:\\n                                      bd[i][j] += 1\\n  \\n          nlist = [start]\\n          while len(nlist):\\n              i, j = nlist.pop(0)\\n              if mask[i][j] != 0:\\n                  mask[i][j] = 0\\n                  if bd[i][j] == 9:\\n                      raise '!!! BOMB'\\n                  elif bd[i][j] == 0:\\n                      for ii in [i-1,i,i+1]:\\n                          for jj in [j-1,j,j+1]:\\n                              if 0<=ii<rr and 0<=jj<cc:\\n                                  if ii != i or jj != j:\\n                                      nlist.append((ii,jj))\\n          mcnt = 0\\n          for r in range(rr):\\n              for c in range(cc):\\n                  if mask[r][c] == 1:\\n                      mcnt += 1\\n                  if mask[r][c] == 1 and bd[r][c] != 9:\\n                      return False\\n                  if mask[r][c] != 1 and bd[r][c] == 9:\\n                      return False\\n          return (mcnt == MCNT)\\n                  \\n  \\n  if __name__ == '__main__':\\n      iname = 'C-small-attempt0.in'\\n      sample_in = '''\\n  7\\n  5 5 23\\n  3 1 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  3 4 0\\n  2 2 3\\n      '''\\n      sample_out = '''\\n  Case #1: 1.0000000\\n  Case #2: 39.1666667\\n  Case #3: 63.9680013\\n  Case #4: 526.1904762\\n      '''\\n      if os.path.exists(iname):\\n          with open(iname) as f:\\n              inputs = f.readlines()\\n      else:\\n          inputs = [x.strip() for x in sample_in.split('\\n') if x.strip()]\\n      solver = Solver()\\n      outputs = solver.feed(inputs)\\n      fail_flag = False\\n      if os.path.exists(iname):\\n          with open(iname+'.out', 'w') as f:\\n              for i, v in enumerate(outputs):\\n                  print >> f, 'Case #%d:'%(i+1)\\n                  print >> f, '\\n'.join(v)\\n      print '===================================================='\\n      for i, v in enumerate(outputs):\\n          print 'Case #%d:'%(i+1)\\n          print '\\n'.join(v)\\n      print '===================================================='\\n      print 'done' if not fail_flag else 'fail'\\n      pass\\n", "target": "35", "substitutes": {"self": ["resp", "e", "gen", "client", "d", "h", "Self", "p", "er", "selves", "t", "host", "_", "object", "obj", "w", "q", "n", "py", "os", "func", "s", "app", "k", "worker", "this", "f", "user", "g"], "inputs": ["outputd", "Inputtests", "inputtests", "dictlines", "outputtests", "Inputsets", "Inputd", "dictsets", "outputp", "Inputs", "outputlines", "inputsets", "inputlines", "Inputlines", " inputtests", "Inputp", " inputlines", "dicts", "inputd", "dictd", "inputp", "outputsets", " inputp"], "R": ["N", "U", "RH", "G", "X", "MR", "W", "Rs", "K", "RC", "SR", "RO", "RN", "L", "D", "A", "T", "B", "RS", "S", "CR", "E", "H", "F", "V", "DR", "RF", "RM", "GR", "Y", "NR", "P", "RT", "LR", "RA", "RG"], "C": ["N", "U", "G", "X", "SC", "Cu", "O", "WC", "I", "CL", "CA", "W", "NC", "CM", "VC", "K", "CE", "RC", "DC", "CW", "L", "D", "A", "MC", "T", "CN", "B", "S", "KC", "CR", "E", "CS", "F", "CI", "RM", "CU", "P", "cr", "CCC"], "M": ["N", "U", "mc", "G", "X", "O", "LM", "I", "MR", "mm", "W", "MD", "CM", "MX", "m", "MN", "L", "D", "A", "MC", "T", "B", "S", "E", "H", "F", "V", "RM", "Y", "Q", "P", "MH", "MM", "MF"], "x": ["e", "xd", "xa", "xs", "xi", "ux", "d", "xt", "id", "px", "X", "xxxxxxxx", "ww", "sex", "xp", "xf", "fx", "p", "xy", "mx", "xes", " X", "z", "rx", "t", "tx", "exp", "dx", "w", "ex", "xc", "xxx", "wx", "xxxx", "xe", "lex", "xx", "ix", "y", "f", "ax"], "mp": ["mph", "px", "large", "pl", "ap", "upp", "op", "mx", "fm", "rup", "rep", "mag", "vp", "zip", "mod", "lim", "ep", "ph", "cap", "cm", "MM", "up", "gm", "omp", "params", "ps", "pm", "msg", "agg", "mm", "map", "yp", "emp", "imp", "app", "pe", "mom", "sp", "tmp", "mem", "post", "meta", "mop", "p", "match", "company", "mac", "loc", "csv", "m", "np", "fp", "clip", "md", "eps", "amp", "pc", "frame", "lp", "wp", "mk", "proc", "ms", "mc", "ip", "par", "pp", "Mp", "cmp", "me", "spec", "amps", "MP", "mo", "jp", "comp", "mult", "pg", "aps", "cop", "mate", "ma", "cp", "mb"], "r": ["e", "range", "yr", "br", "rb", "fr", "rc", "h", "p", "ur", "pr", "oc", "ar", "dr", "er", "u", "lr", "attr", "ir", "re", "loc", "w", "m", "hr", "l", "rf", "order", "ru", "rh", "rt", "ro", "rn", "rl", "k", "rs", "rd", "sr", "nr", "err", "rg", "b", "f", "cr", "rar"], "outputs": ["OutputS", "outputps", "Outputions", " outputps", "outputions", "outputks", "inputS", "inputps", "Outputps", " outputS", "Outputlines", "columnlines", "Outputi", "columnions", "outputlines", "inputi", "inputlines", "outputi", "Outputs", "outputS", " outputions", " outputi", "Outputks", "columns", "columnks", " outputks", " outputlines"], "row": ["mc", "col", "rew", "rows", "rc", "slice", "month", "Row", "match", "mr", "input", "agg", "micro", "mm", "mac", "arr", "rup", "mar", "rec", "rep", "mat", "ows", "record", "feed", "w", "ow", "rank", "entry", "rown", "order", "raw", "mod", "ro", "model", "round", "ack", "cell", "rn", "frame", "gram", "line", "sc", "cm", "array", "post", "up", "roc"], "rr": ["pr", "dr", "dd", "lr", "attr", "rec", "uc", "rss", "rh", "irc", "rn", "rl", "cover", "rd", "nr", "err", "gro", "fr", "act", "rol", "add", "mr", "er", "agg", "route", "iter", "vr", "ru", "ack", "addr", "rs", "call", "sr", "track", "code", "rg", "f", "gg", "orig", "rb", "tr", "wr", "rc", "aa", "gr", "ce", "ar", "rx", "co", "ror", "rw", "RC", "error", "ir", "inc", "loc", "order", "rer", "rt", "CR", "rack", "ck", "bug", "rar", "cf", "mc", "bb", "pp", "coll", "h", "ac", "arr", "ra", "vc", "adr", "q", "hr", "der", "rf", "actor", "air", "kr", "arc", "cr", "req", "g"], "cc": ["col", "cv", "case", "acc", "cca", "rec", "uc", "cy", "ca", "cci", "xc", "ff", "bc", "cell", "rn", "custom", "cm", "con", "fc", "ucc", "rule", "cb", "lv", "ll", "kk", "cs", "cd", "ack", "ic", "rs", "call", "code", "f", "gg", "CCC", "rc", "aa", "dc", "oc", "ce", "go", "co", "can", "RC", "inc", "loc", "ci", "pc", "ec", "ck", "sc", "cf", "mc", "bb", "sk", "cmp", "coll", "ac", "ct", "cu", "com", "vc", "q", "cl", "anc", "k", "nc", "cn", "cr", "cp", "g", "lc"], "rm": ["range", "cdn", "rb", "mc", "km", "cb", "mi", "dm", "nor", "rc", "cmp", "vm", "pm", "mr", "dr", "MR", "mm", "rx", "orr", "fm", "co", "ref", "lr", "nm", "ym", "attr", "cond", "RC", "ir", "cre", "arm", "adr", "m", "ci", "irm", "rf", "orm", "rh", "md", "cd", "rt", "mod", "pc", "rom", "RP", "kr", "bm", "rn", "RM", "rd", "nr", "sr", "min", "mir", "cm", "err", "rem", "cr", "cp", "cn", "lc", "mn"], "c": ["e", "mc", "d", "col", "rc", "h", "ac", "coll", "dc", "p", "ce", "u", "count", "ct", "co", "cu", "cs", "un", "loc", "cy", "uc", "q", "m", "n", "ci", "l", "cl", "xc", "cd", "g", "pc", "cache", "unc", "anc", "ic", "k", "ec", "nc", "code", "sc", "b", "arc", "f", "con", "cp", "cm", "cr", "cn", "lc"]}}
{"code": "filename = raw_input(\"Name of file: \")\\n  infile = open(filename, \"r\")\\n  outfile = open(filename + \".out\", \"w\")\\n  \\n  \\n  T = int(infile.readline()[:-1])\\n  \\n  \\n  def getMinTime(c, f, x):\\n      p0 = 2.0\\n      s_prev = x / p0\\n      s_curr = c / p0\\n      prev_item = 0\\n      next_item = x / (p0 + f)\\n      n = 1\\n      while s_prev + prev_item > s_curr + next_item:\\n          s_prev = s_curr\\n          prev_item = next_item\\n          s_curr += c / (p0 + (n * f))\\n          next_item = x / (p0 + ((n + 1) * f))\\n          n += 1\\n      return s_prev + prev_item\\n  \\n  for t in range(1, T + 1):\\n      items = infile.readline()[:-1].split(\" \")\\n      c = float(items[0])\\n      f = float(items[1])\\n      x = float(items[2])\\n      time = getMinTime(c, f, x)\\n      outfile.write(\"Case #%d: %.7f\\n\" %(t, time))\\n      \\n          \\n      \\n  \\n  outfile.close()\\n  infile.close()\\n", "target": "36", "substitutes": {"filename": ["il", "figure", "fd", "name", "location", "itled", "fn", "stem", "ames", "knife", "document", "fil", "uture", "jet", "username", "phrase", "jl", "file", "dll", "ername", "sf", "kn", "journal", "database", "binary", "Filename", "utf", "prefix", "selection", "fp", "FH", "nil", "sheet", "named", "files", "ln", "SourceFile", "s", "title", "ename", "names", "tail", "directory", "download", "kl", "FILE", "path", "subject", "that", "which"], "infile": ["outline", "outFile", " inf", "inline", "outf", "Infiles", " inlock", "inputFile", "outlock", "inputlock", "inputf", "InFile", "Infile", "outfiles", "infiles", "inlock", "inf", "Inline", " inline", "inputline", "Inf", "inFile", "inputfile", " infiles"], "outfile": ["outline", "outFile", "Outletter", "outletter", " outline", "OUTFile", "inline", " outf", "outf", "Outline", " outletter", "Outfolder", "infolder", "instream", "Outfile", " outstream", "OutFile", "outfolder", "inf", "OUTline", "OUTf", "OUTfile", "outstream", " outfolder", "inFile", " outFile", "inletter", "Outstream"], "T": ["N", "Length", "G", "X", "TN", "C", "Time", "p", "O", "I", "Size", "TS", "W", "M", "Z", "TH", "L", "D", "A", "TW", "R", "B", "S", "TT", "E", "H", "F", "V", "Y", "Q", "P"], "c": ["e", "cf", "size", "at", "d", "i", "h", "C", "dc", "p", "ch", "ce", "u", "ct", "r", "z", "v", "cu", "cs", "w", "cy", "q", "uc", "m", "ci", "l", "s", "a", "cin", "k", "ic", "nc", "y", "b", "con", "cm", "fc", "g", "lc"], "f": ["e", "cf", "fd", "d", "fr", "i", "h", "xf", "p", "fi", "u", "af", "z", "r", "fb", "form", "file", "fm", "v", "fo", "w", "q", "sf", "m", "l", "rf", "fp", "inf", "fs", "s", "df", "k", "F", "fe", "y", "b", "fc", "fen", "g", "fa"], "x": ["e", "size", "xa", "xs", "xi", "d", "plus", "i", "X", "h", "xp", "xf", "p", "xy", "fx", "max", "xes", "u", "im", "case", "z", "r", "rx", "cross", "tx", "co", "v", "com", "w", "q", "m", "ci", "l", "cl", "index", "ex", "xc", "wx", "s", "python", "a", "pe", "ic", "F", "xx", "ix", "y", "con", "cm", "b"], "p0": ["sp4", "f0", "n1", "m3", "m6", "c90", " p4", " p1", "sp90", "f50", "c4", "p50", "a50", "p00", "a00", "n00", "c50", "v0", "f2", "c00", " p2", "P00", "P0", "p90", "m0", "v3", "sp1", "P1", "f00", "p3", "a1", "p2", "f4", "f1", "m1", "a4", "sp0", "P6", "c0", "v6", "P3", "v1", "a0", "n0", "c1", "P2", "c2", "a2", "p4", "p6", "P4", " p90", "p1"], "s_prev": [" s_init", "s___next", "s_rev", " s_rev", "s_pre", "ns___prev", "s_next", "ns_next", "ns_cur", "ns___iter", "ns_iter", "s_orig", " s_ctr", "s_vious", " s_cur", "s_iter", "s___cur", "s___prev", "ns_prev", "s_cur", "ns___cur", "ns___next", "s_init", "s___iter", " s_orig", "s_ctr", " s_vious", " s_pre", " s_next"], "s_curr": ["s_surro", "s_curra", "s_serrs", "s_prevrs", "s_Currer", "s_surrl", "s_centrl", "s_Curr", "s_Currs", "s_surr", "s_corra", "s_prevred", "s_curred", "s_corr", "s_serr", "s_corrs", "s_Curra", "s_currc", "s_centro", "s_catrar", "s_schr", "s_Curred", "s_prevrc", "s_schrer", "s_prevr", "s_serra", "s_Currc", "s_currer", "s_corro", "s_catrs", "s_Currar", "s_schrar", "s_corrl", "s_catrer", "s_schrs", "s_serrer", "s_curro", "s_centr", "s_catr", "s_currar", "s_currs", "s_correr", "s_currl"], "prev_item": ["prev\u00b7entry", "prev_layer", "next_layer", "prev\u00b7function", "prev\u00b7layer", " previous_item", " previous__step", " previous_layer", "prevPitem", "prevPiter", "next_value", " previous__layer", " next_function", "prev_function", " previous__item", "prev__item", "next_iter", "prev_element", "prev_entry", "prev_instance", "next_instance", "prev__element", "prev\u00b7element", " previous__element", "prev_value", " previous_element", " next_entry", "prev\u00b7item", "prev_iter", "prev__layer", "prevPvalue", "prev__step", "prev_step", " previous_step", "prev\u00b7step"], "next_item": ["next__Item", "prev_object", "nextxitem", "prev_offset", "nextxevent", "next_offset", "next__object", "prev_element", "nextxitems", "next_event", "next_Item", "nextpItem", "prev_event", "nextpobject", "next__element", "next_element", "nextpitem", "next_object", "nextpelement", "next__item", "nextxItem", "prev_Item", "prev_items", "next_items"], "n": ["N", "e", "d", "ne", "ns", "i", "num", "fn", "len", "p", "j", "max", "en", "u", "count", "r", "nt", "an", "z", "v", "un", "w", "nn", "m", "l", "adj", "all", "nb", "s", "sn", "k", "nc", "y", "b", "span", "o", "nu"], "t": ["N", "e", "tt", "at", "d", "i", "p", "j", "z", "nt", "r", "tf", "dt", "v", "w", "type", "m", "l", "tim", "s", "tp", "a", "int", "k", "y", "b", "o", "ts"], "items": ["units", "articles", "results", "members", "xs", "effects", "events", "jobs", "qs", "ids", "rows", "lists", "works", "words", "item", "opens", "xml", "sections", "features", "values", "photos", "types", "comments", "forms", "cats", "pages", "bits", "es", "ins", "plugins", "docs", "pieces", "keys", "grades", "data", "apps", "groups", "eps", "models", "files", "strings", "blocks", "names", "links", "phones", "projects", "Items", "flows", "tests", "lines", "users", "boxes", "ips", "objects", "ops"], "time": ["e", "tt", "size", "name", "event", "id", "tz", "h", "Time", "p", "ime", "now", "count", "z", "v", "etime", "date", "w", "type", "q", "m", "tm", "clock", "tim", "rate", "value", "data", "text", "times", "s", "temp", "tc", "depth", "timer", "y", "term", "frequency", "info", "scale"]}}
{"code": "filename = raw_input(\"Name of file: \")\\n  infile = open(filename, \"r\")\\n  outfile = open(filename + \".out\", \"w\")\\n  \\n  \\n  T = int(infile.readline()[:-1])\\n  \\n  def addMinesDiagonally(r, c, m):\\n      field = []\\n      for i in range (r):\\n          row = []\\n          for j in range(c):\\n              row += [\".\"]\\n          field += [row]\\n          \\n      for i in range (r + c):\\n          ver = min (i, r - 1)\\n          hor = max (0, 1 + i - r)\\n          while ver >= 0 and hor <= c - 1 and m > 0:\\n              if m == 1 and hor == c - 2 and ver == r - 2:\\n                  ver -= 1\\n                  hor += 1\\n              field[ver][hor] = \"*\"\\n              ver -= 1\\n              hor += 1\\n              m -= 1\\n          \\n      return field\\n  \\n  def isPossible(field):\\n      if field[-1][-1] != \".\":\\n          return False\\n      up = True\\n      left = True\\n      diag = True\\n      if len(field) > 1 and field[-2][-1] != \".\":\\n              up = len(field[-1]) <= 1\\n      if len(field[-1]) > 1 and field[-1][-2] != \".\":\\n              left = len(field) <= 1\\n      if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != \".\":\\n          diag = False\\n      return (up and left and diag) or \\\\n             ((not up) and (not left) and (not diag))\\n      \\n  \\n  for t in range(1, T + 1):\\n      items = infile.readline()[:-1].split(\" \")\\n      r = int(items[0])\\n      c = int(items[1])\\n      m = int(items[2])\\n      field = addMinesDiagonally(r, c, m)\\n      if isPossible(field):\\n          field[-1][-1] = \"c\"\\n          s = \"\"\\n          for line in field:\\n              for cell in line:\\n                  s += cell\\n              s += \"\\n\"\\n          outfile.write(\"Case #%d:\\n%s\\n\" %(t, s[:-1]))\\n      else:\\n          s = \"IMPOSSIBLE!!!!\\n\"\\n          for line in field:\\n              for cell in line:\\n                  s += cell\\n              s += \"\\n\"\\n          outfile.write(\"Case #%d:\\n%s\\n\" %(t, s[:-1]))\\n      \\n          \\n      \\n  \\n  outfile.close()\\n  infile.close()\\n", "target": "36", "substitutes": {"filename": ["il", "figure", "fd", "name", "itled", "sql", "fn", "stem", "slice", "ames", "knife", "document", "fil", "jet", "username", "lace", "wl", "phrase", "jl", "file", "til", "dll", "ername", "mble", "pal", "sf", "amer", "kn", "database", "doi", "binary", "Filename", "utf", "selection", "fp", "nil", "sheet", "files", "ln", "SourceFile", "title", "ename", "tail", "directory", "download", "kl", "FILE", "path", "f", "subject", "that", "which"], "infile": ["outline", "outFile", "inline", " inFile", "Instream", "Infiles", " instream", "Infilename", "infilename", "outfilename", "instream", "InFile", "Infile", "outfiles", "infiles", "Inline", " inline", "outstream", " infilename", "inFile", " infiles"], "outfile": ["outline", "outFile", "outletter", " outline", "OUTFile", "inline", " outf", "outf", "Outline", " outletter", "OUTletter", "instream", "Outfile", "Outf", " outstream", "inf", "OUTstream", "OUTfile", "outstream", "inFile", " outFile", "inletter", "Outstream"], "T": ["N", "TR", "U", "Length", "G", "X", "TN", "C", "O", "I", "Size", "TS", "W", "M", "Z", "K", "L", "WT", "D", "A", "R", "B", "S", "TT", "E", "H", "F", "V", "Y", "Q", "P", "CT"], "r": ["e", "range", "rr", "rb", "d", "tr", "fr", "rc", "h", "p", "pr", "ur", "ar", "u", "er", "v", "rec", "ra", "ir", "re", "w", "n", "l", "R", "ru", "right", "rh", "rt", "ro", "a", "rn", "k", "rs", "x", "rd", "sr", "nr", "ri", "b", "f", "o", "cr"], "c": ["e", "mc", "d", "col", "rc", "center", "h", "ac", "C", "dc", "p", "ch", "ce", "en", "u", "ct", "z", "cat", "v", "cu", "cs", "w", "cy", "q", "uc", "n", "ci", "l", "g", "cc", "a", "k", "x", "nc", "y", "b", "cm", "f", "con", "o", "cr", "cp", "cn", "lc"], "m": ["e", "range", "mc", "d", "mi", "om", "dm", "h", "vm", "p", "rm", "mr", "en", "u", "er", "im", "mm", "z", "an", "pi", "M", "v", "bm", "fm", "am", "meter", "um", "re", "w", "q", "n", "tm", "l", "machine", "end", "a", "k", "x", "min", "y", "mon", "b", "cm", "f", "o", "g"], "field": ["eff", "package", "pick", "section", "manager", "man", "case", "number", "util", "object", "pull", "box", "seed", "fields", "machine", "zip", "ff", "end", "node", "off", "option", "url", "table", "range", "event", "rule", "player", "word", "patch", "length", "er", "uf", "condition", "record", "type", "element", "all", "label", "time", "fix", "ld", "array", "f", "post", "user", "area", "update", "module", "play", "slice", "p", "document", "feature", "match", "input", "file", "form", "v", "comment", "layer", "error", "space", "um", "FIELD", "function", "order", "data", "block", "model", "key", "frame", "result", "this", "format", "load", "diff", "lock", "service", "coll", "Field", "bf", "list", "child", "force", "change", "group", "part", "string", "source", "value", "wire", "style", "sort", "null", "message", "cel", "flower"], "i": ["e", "range", "si", "xi", "ip", "d", "id", "h", "p", "ar", "I", "u", "im", "ie", "z", "li", "pi", "v", "io", "ir", "w", "n", "ci", "l", "ii", "di", "int", "k", "phi", "x", "y", "ri", "iu", "b", "ind", "f", "o", "g", "qi"], "row": ["range", "our", "col", "tr", "id", "num", "rows", "rc", "step", "coll", "h", "month", "feature", "Row", "max", "child", "column", "form", "group", "box", "feed", "w", "cur", "uc", "ow", "rank", "query", "index", "element", "order", "value", "port", "ro", "block", "model", "key", "x", "ul", "sc", "array", "f", "cr", "server"], "j": ["e", "cf", "ac", "p", "year", "z", "ct", "co", "v", "jam", "cy", "q", "jac", "ij", "ib", "je", "cc", "sec", "jc", "k", "cycle", "y", "code", "cm", "b", "f", "o", "g"], "ver": ["range", "inter", "br", "col", "om", "fr", "num", "aver", "ve", "h", "coll", "pr", "ur", "feature", "iver", "gr", "ever", "cv", "mr", "dr", "browser", "reach", "er", "v", "res", "root", "vers", "ir", "re", "iter", "cur", "vert", "type", "VER", "oy", "gener", "over", "av", "air", "conv", "ter", "car", "test", "var", "x", "cover", "min", "cher", "b", "f", "err", "version", "con", "cr", "vr", "Ver"], "hor": ["dom", "br", "d", "ov", "hi", "mi", "om", "nor", "aver", "h", "lo", "hover", "tri", "pr", "ur", "xy", "ever", "cv", "lor", "mr", "far", "reach", "mor", "dir", "cro", "v", "uri", "meter", "ra", "home", "ir", "um", "ior", "rub", "cur", "rum", "vert", "broad", "ho", "oy", "hr", "oh", "hide", "floor", "over", "cor", "air", "door", "chrom", "vor", "car", "oor", "dy", "dim", "Hor", "hom", "shadow", "bor", "ri", "orient", "mir", "cr", "version", "low", "vr", "hub"], "up": ["Up", "ip", "ahead", "around", "plus", "ama", "uph", "coll", "mp", "upper", "upp", "api", "p", "ap", "length", "op", "ame", "u", "flow", "down", "own", "upe", "top", "ra", "home", "um", "ups", "pre", "equal", "ure", "floor", "over", " Up", "UP", "one", "back", "all", "user", "parent", "upt", "ma", "move", "area", "lock", "sup", "union"], "left": ["double", "ge", "il", "d", "pos", "plus", "limited", "Left", "len", "lon", "lo", "pl", "led", "p", "length", "out", "lt", "byn", "flow", "down", "rel", "li", "exp", "level", "wrong", "law", "long", "ly", "leave", "ell", "loc", "nl", "NL", "limit", "l", "el", "la", "log", "hide", "where", "fl", "L", "right", "sl", "cl", "all", "lim", "ner", "ul", "lic", "two", "lu", "le", "o", "low", "url"], "diag": ["diagg", "Diap", "siag", "diig", "siagram", "diags", "biog", "biags", "biag", "biagn", "liig", " diig", " diagn", "liog", " diags", "siags", "Diagn", "diagram", "siig", " diagg", "liag", "siagg", "diagn", "liagg", "Diagram", "liagn", "liags", " diog", "diap", "Diags", "siagn", "liap", " diagram", "diog", "Diag", " diap"], "t": ["e", "tt", "d", "col", "tr", "ta", "h", "tz", "p", "u", "z", "nt", "tf", "ty", "tl", "dt", "v", "w", "type", "n", "l", "ot", "text", "title", "time", "int", "st", "x", "y", "b", "f", "o", "table", "ts"], "items": ["articles", "amples", "results", "events", "images", "qs", "ids", "rows", "lists", "ops", "json", "words", "item", "opens", "features", "bands", "values", "cells", "bytes", "bars", "photos", "comments", "cats", "pages", "ins", "plugins", "docs", "fields", "pieces", "keys", "apps", "groups", "eps", "models", "files", "strings", "gets", "names", "blocks", "links", "phones", "orders", "flows", "Items", "lines", "styles", "boxes", "sites", "ips", "objects", "steps", "js", "abs"], "s": ["ws", "append", "sb", "ing", "types", "ins", "ls", "parts", "states", "us", "si", "ps", "X", "services", "add", "z", "_", "ses", "w", "n", "sample", "l", "blocks", "a", "sv", "sp", "x", "b", "f", "o", "ments", "ops", "e", "settings", "d", "id", "slice", "p", "series", "input", "cells", "v", "sym", "comments", "g", "S", "strings", "lines", "format", "gs", "ns", "rows", "u", "spec", "ed", "ds", "string", "sets", "sf", "ss", "single", "ips", "es"], "line": ["range", "loop", "col", "rule", "ine", "struct", "inline", "len", "lo", "unit", "liner", "lined", "point", "column", "lace", "case", "file", "li", "write", "Line", "co", "group", "lin", "string", "layer", "un", "n", "l", "el", "block", "end", "frame", " inline", "cycle", "cel", "lines", "code", "chain", "f"], "cell": ["col", "struct", "Cell", "inline", "tab", "str", "unit", "ch", "Field", "match", "length", "add", "input", "child", "column", "case", "count", "z", "cat", "cells", "v", "cond", "group", "string", "long", "ell", "div", "un", "feed", "entry", "text", "char", "block", "all", "label", "chart", "character", "call", "pattern", "cel", "code"]}}
{"code": "\"\"\"Usage:\\n      pypy X.py < X-size.in > X-size.out\\n  or sometimes\\n      python X.py < X-size.in > X-size.out\\n  \"\"\"\\n  \\n  def setup(infile):\\n      return locals()\\n  \\n  def reader(testcase, infile, C=None, **ignore):\\n      I = map(float, infile.next().split())\\n      return locals()\\n  \\n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\\n  \\n      C, F, X = I\\n      n = [0]\\n      r = 2.\\n  \\n      res = X / r\\n      while True:\\n          n.append(n[-1] + C / r)\\n          r += F\\n          nres = n[-1] + X / r\\n          if nres >= res:\\n              break\\n          res = nres\\n  \\n      return 'Case #%s: %s\\n' % (testcase, res)\\n  \\n  if __name__ == '__main__':\\n      T = int(sys.stdin.next())\\n      common = setup(sys.stdin)\\n      for t in xrange(1, T+1):\\n          sys.stdout.write(solver(**reader(t, **common)))\\n", "target": "37", "substitutes": {"infile": ["outline", " inile", " infolder", "incfile", "inline", "Infiles", " instream", "Infilename", "infilename", "INfile", "outfilename", "infolder", "INfiles", "instream", "INfilename", "incline", "INline", "Infile", "outfiles", "INile", "outfolder", "infiles", "incstream", "Inline", "incfolder", "inile", " inline", "outstream", "outfile", "outile", "INstream"], "testcase": ["inpath", "incases", "testingCase", "Testcase", "TestCase", " testpoint", "testcases", "testingcase", "testpath", "Testpath", "validcase", "inCase", "testpoint", "testCase", " testcases", "Testpoint", "incase", "validCase", " testpath", "testingcases", "validpoint", "Testcases", " testCase"], "C": ["Count", "Cs", "CF", "U", "G", "SC", "Cu", "O", "CL", "CA", "W", "Rs", "M", "NC", "CM", "VC", "K", "Z", "DC", "CC", "L", "D", "A", "R", "CN", "B", " c", "FC", "c", "CR", "E", "H", "CI", "V", "Y", "Q", "CT"], "I": ["U", "ID", "G", "i", "IN", "J", "O", "If", "PI", "Num", "W", "IP", " i", "NI", "M", "K", "Fi", "L", "Id", "D", "A", "R", "IO", "B", "E", "H", "CI", "V", "In", "Y", "Is", "Q"], "N": ["U", "G", "J", "O", "W", "M", "Z", "K", "L", "D", "A", "R", "B", "E", "H", "Ns", "V", "Y", "NS", "Q"], "P": ["Ps", "Pr", "U", "AP", "J", "p", "O", "PI", "W", "IP", "M", "CP", "PP", "A", "R", "PF", "Par", "E", "H", "V", "PT", "Y", "Q", "Pi", "Pl", "Pos"], "T": ["U", "TF", "TN", "Time", "O", "TS", "TB", "W", "Ti", "TA", "M", "Z", "K", "OT", "TH", "L", "WT", "D", "TW", "R", "B", "TT", "Ts", "TP", "H", "E", "Type", "V", "PT", "Total", "NT", "Y", "Q", "CT"], "S": ["U", "G", "SC", "Space", "O", " s", "SI", "W", "M", "SR", "SN", "SE", "Sa", "A", "SH", "ss", "s", "Si", "E", "H", "Ns", "SS", "V", "Y", "NS"], "F": ["U", "G", "Fs", "FD", "J", "O", "W", "M", "Z", "K", "L", "D", "A", "R", "PF", "B", "FE", "CR", "E", "H", "V", "RF", "Y", "Q", "f"], "X": ["U", "RH", "XL", "G", "J", "XP", "ZX", "O", "RR", "XXX", "CL", "TX", "W", "rx", "Rs", "M", "Z", "K", "CC", "L", "D", "R", "B", "RS", "Ex", "CR", "E", "H", "IR", "x", "V", "Y", "Q", "XX", "PE"], "n": ["e", "d", "ne", "ns", "i", "nor", "fn", "num", " Ne", "p", "j", "out", "none", "en", "u", "z", " RN", "nt", "v", "na", "un", "nn", "w", "m", "np", "l", "network", " init", "R", " ni", " c", "g", "nb", "c", "s", "ner", "sn", "a", "rn", "Ns", " ns", "x", "node", "nc", "nr", "ng", "y", "b", "f", "no", "o", "cr", " fn", "net", "nu"], "r": ["e", "range", "rr", "rb", "fr", "wr", "i", "rc", "p", "ur", "pr", "gr", "ar", "max", "mr", "u", "rx", "Rs", "v", "lr", " R", "re", "w", "q", "m", "hr", "l", "rf", "R", "ru", "right", "rh", "g", "rt", "ro", "c", "s", "CR", "rn", "rs", "x", "result", "sr", "nr", "err", "b", "f", "cr"], "res": ["resp", "Rh", "results", "rr", " results", "rc", "RE", "ras", "gr", "ret", "max", "resolution", "rx", "Rs", "response", "row", "error", "rec", " R", "re", "resh", "remote", "Res", "resource", "R", "rest", "right", "RS", "rev", "rh", "reg", "details", " Res", "rez", "CR", "Result", "rs", "RES", "result", "x", "GR", "nr", "NR", "err", "rem", "ros", "Results", "runs", "cr", "req", "ries"], "nres": ["nRes", "mRes", "nries", "Nresp", "sresolution", "sresult", "pres", "Nresult", "mresp", "Nres", "noneRes", "rRes", "noneres", "cresult", "\tresolution", "sres", "rRES", "cres", "pries", "noneresp", "\tresult", "\tries", "nresult", "cRES", "cRes", "rres", "nRES", "presult", "NRes", "mres", "rresult", "sries", "nresolution", "nresp", "NRES", "presolution"], "common": ["ctx", "real", "standard", " custom", "extra", "name", "family", "norm", "regular", "unique", "current", "complete", "general", "Common", "total", "util", "special", "loc", "normal", "generic", " Common", "basic", "valid", "local", "body", "all", "new", "c", "tc", "TC", "test", "custom", "other", "complex", "con", "specific", "no", "f", "o", "union"], "t": ["tt", "d", "tr", "i", "num", "p", "j", "ct", "nt", "it", "tf", "normal", "m", "tm", "tower", "the", "mult", "ti", "te", "all", "c", "tc", "int", "tp", "a", "test", "x", "y", "ind", "f", "o", "g", "ts"]}}
{"code": "\"\"\"Usage:\\n      pypy X.py < X-size.in > X-size.out\\n  or sometimes\\n      python X.py < X-size.in > X-size.out\\n  \"\"\"\\n  \\n  def setup(infile):\\n      return locals()\\n  \\n  def reader(testcase, infile, C=None, **ignore):\\n      P = map(int, infile.next().split())\\n      return locals()\\n  \\n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\\n  \\n      R, C, M = P\\n      MM = M\\n  \\n      F = np.array([['.'] * C] * R)\\n      while M > 0:\\n          if R >= C and M >= C and R > 2:\\n              M -= C\\n              R -= 1\\n              F[R] = '*'\\n          elif C > R  and M >= R and C > 2:\\n              M -= R\\n              C -= 1\\n              F[:, C] = '*'\\n          elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):\\n              if M < C - 1:\\n                  R -= 1\\n                  F[R, C - M:C] = '*'\\n              elif M < R - 1:\\n                  C -= 1\\n                  F[R - M:R, C] = '*'\\n              elif M == C - 1:\\n                  R -= 1\\n                  F[R, C - M + 1:C] = '*'\\n                  F[R - 1, C - 1] = '*'\\n              else:\\n                  C -= 1\\n                  F[R - M + 1:R, C] = '*'\\n                  F[R - 1, C - 1] = '*'\\n              M = 0\\n          elif M == R * C - 1:\\n              F[:, :] = '*'\\n              M = 0\\n          else:\\n              return 'Case #%s:\\n%s\\n' % (testcase, 'Impossible')\\n  \\n      F[0, 0] = 'c'\\n      assert (F == '*').sum() == MM\\n      return 'Case #%s:\\n%s\\n' % (testcase, '\\n'.join(''.join(f.tolist()) for f in F))\\n  \\n  if __name__ == '__main__':\\n      T = int(sys.stdin.next())\\n      common = setup(sys.stdin)\\n      for t in xrange(1, T+1):\\n          sys.stdout.write(solver(**reader(t, **common)))\\n", "target": "37", "substitutes": {"infile": ["outFile", "incfile", " inFile", "inFILE", "INFILE", "Infiles", "outconfig", "Infilename", "inputconfig", "infilename", " inconfig", " incomplete", "INfile", "incFILE", "outfilename", "inputFile", "INfiles", "INFile", "incomplete", "InFile", "Infile", "outfiles", "infiles", "inputfiles", "Incomplete", "incFile", "outfile", "incfiles", " infilename", "inFile", "inconfig", "InFILE", "outcomplete", "inputfile", " infiles"], "testcase": ["maincase", "Testcase", "TestCase", "Testfile", "testfile", "Testcache", "testingfile", "testcases", "testingcase", "testcache", "maincases", " testfile", " testcache", "testCase", " testcases", "testingcases", "maincache", "mainCase", "Testcases", " testCase"], "C": ["Count", "Cs", "U", "G", "Ch", "Cor", "X", "SC", "Co", "Cu", "Any", "O", "CL", "CNN", "Size", "CA", "r", "W", "NC", "CM", "K", "VC", "CE", "EC", "Cl", "GC", "DC", "CP", "Ca", "CC", "L", "Sc", "D", "A", "CN", "MC", "B", "Rec", " c", "Chain", "c", "CR", "E", "H", "CS", "AC", "CI", "V", "CU", "Y", "Q", "Mc", "Code"], "P": ["Ps", "U", "AP", "G", "X", "J", "p", "O", "PN", "PI", "W", "IP", "K", "CP", "L", "PP", "D", "A", "PF", "B", "PS", "RP", "E", "H", "TP", "Po", "PO", "V", "PT", "Y", "Q", "PE", "NP", "PA"], "N": ["U", "NN", "G", "X", "p", "O", "W", "K", "n", "L", "D", "A", "CN", "B", "E", "Ns", "V", "NT", "Y", "NS", "Q"], "I": ["U", "ID", "i", "MI", "IL", "J", "p", "O", "SI", "PI", "IP", "NI", "K", "IO", "B", "LI", "HI", "E", "H", "AI", "API", "CI", "V", "Y", "Is", "Q", "Pi", "TI"], "T": ["U", "G", "X", "TF", "TN", "Time", "O", "TS", "W", "t", "TA", "Z", "K", "TH", "L", "WT", "D", "B", "TT", "TC", "E", "H", "V", "PT", "Total", "NT", "Y", "Q", "CT"], "S": ["SP", "U", "Sl", "G", "SC", "SL", "SI", "SO", "SR", "SN", "SK", "SE", "Sa", "A", "SH", "PS", "s", "Si", "SS", "V", "SU", "Y", "NS", "SA", "Q"], "R": ["Rh", "AR", "U", "RH", "G", "Ch", "Cor", "X", "Co", "RE", "J", "O", "RIP", "RR", "CL", "MR", "r", "W", "Rs", "File", "Range", "Line", "K", "DC", "RW", "SR", "RN", "RO", "Re", "CC", "L", "Reader", "D", "A", "ER", "Group", "B", "RS", "BR", "RP", "CR", "E", "H", "Gr", "V", "DR", "RF", "RM", "GR", "Run", "Y", "Ra", "NR", "Q", "RT", " r", "LR", "RA", "RG"], "M": ["U", "CH", "Rule", "G", "X", "Co", "J", "RE", "O", "LM", "CL", "MR", "r", "W", "TM", "MD", "MS", "CM", "K", "Ms", "SM", "MT", "Mor", "Re", "m", "MN", "L", "OM", "D", "A", "OR", "MC", "B", "DM", "MA", "Model", "IM", "MB", "E", "H", "AM", "V", "Man", "RM", "Y", "Q", "Mc", "MF"], "MM": ["NN", "X", "MI", "max", "CNN", "DD", "mm", "W", "_", "MP", "DC", "n", "CC", "D", "MC", "FM", "FC", "MB", "RM", "Mc", "MF", " mm"], "F": ["Full", "CF", "Test", "U", "AP", "Fixed", "G", "Fs", "FD", "X", "Do", "TF", "DF", "O", "FT", "Frame", "IF", "W", "BF", "File", "Line", "Z", "K", "ULT", "L", "D", "FO", "EF", "A", "FM", "GF", "PF", "B", "WF", "FC", "FA", "Function", "FR", "FE", "Base", "E", "H", "API", "V", "Form", "FF", "Y", "Q", "FG", "Point", "MF", "AF", "Part"], "f": ["e", "cf", "d", "fr", "i", "h", "p", "j", "fun", "flow", "fo", "t", "file", "form", "ref", "v", "it", "w", "fit", "m", "n", "l", "function", "fl", "fp", "fast", "fs", "all", "c", "df", "x", "fe", "found", "b", "fc", "info"]}}
{"code": "\\n  \\n  \\n  sys.setrecursionlimit(5000)\\n  \\n  INPUT = \"tiny\"\\n  INPUT = \"B-large.in\"\\n  INPUT = \"B-small-attempt0.in\"\\n  \\n  def debug(*args):\\n      return\\n      sys.stderr.write(str(args) + \"\\n\")\\n  \\n  class Memoize:\\n      def __init__(self,function):\\n          self._cache = {}\\n          self._callable = function\\n              \\n      def __call__(self, *args, **kwds):\\n          cache = self._cache\\n          key = self._getKey(*args,**kwds)\\n          try: return cache[key]\\n          except KeyError:\\n              cachedValue = cache[key] = self._callable(*args,**kwds)\\n              return cachedValue\\n      \\n      def _getKey(self,*args,**kwds):\\n          return kwds and (args, ImmutableDict(kwds)) or args    \\n  \\n  def do_trial(C, F, X, rate=2.0):\\n      win_time_wait = X / rate\\n      buy_time = C / rate\\n      win_time_buy_1 = buy_time + X / (rate+F)\\n      if win_time_wait < win_time_buy_1:\\n          return win_time_wait\\n      return buy_time + do_trial(C, F, X, rate+F)\\n  \\n  f = file(INPUT)\\n  T = int(f.readline()[:-1])\\n  for i in range(T):\\n      C, F, X = [float(x) for x in f.readline().split()]\\n      v = do_trial(C, F, X)\\n      print \"Case #%d: %s\" % (i+1, v)\\n", "target": "38", "substitutes": {"INPUT": ["InLINE", "Ininput", "inPUT", "INInput", "inFILE", "INinput", "INFILE", " INInput", "InST", "InPUT", "InInput", "inLINE", "InVERT", "INLINE", "insinput", "INVERT", "inVERT", "inST", " INLINE", "insPUT", "INST", "ininput", "InFILE", "insFILE", " INST", " INVERT", "insInput", "inInput"], "self": ["args", "proxy", "Self", "package", "api", "manager", "case", "object", "http", "c", "parent", "worker", "node", "per", "plus", "patch", "er", "instance", "_", "w", "type", "remote", "plugin", "s", "app", "call", "user", "server", "e", "full", "module", "client", "p", "now", "context", "master", "host", "sys", "form", "co", "layer", "public", "m", "this", "utils", "other", "ng", "load", "private", "ctx", "ns", "h", "me", "point", "child", "r", "part", "parse", "connection", "session", "q", "func", "work", "python", "k", "g"], "function": ["full", "module", "operation", "name", "fn", "closure", "word", "package", "document", "fun", "functional", "instance", "handler", "action", "file", "number", " func", "object", "library", "string", "method", "position", "resource", "job", "Function", "func", "callback", "new", "unc", "python", "parent", " Function", "call", "code", "wrapper"], "_cache": ["workcache", "workcall", "_pool", "wache", "workfunction", "_store", " _cycle", " _pool", "wcall", "_function", "workache", "_call", "wfunction", " _store", "_ache", "_cycle", "wcache"], "_callable": ["howcallables", "_ncable", "_functionables", "_codeables", "_functioner", "_callfunc", "_caller", "_Callable", "_usefunc", "howcallbackfunc", "_functionable", "_ncname", "_useer", "_codefunc", "_codeer", "howcallfunc", "_callbackfunc", "_ncfunc", "_callbackable", "_callname", "_callbackname", "_Callables", "howcallbackables", "_Callname", "_useable", "howcallbackname", "_useables", "_codeable", "_callbackables", "howcallbackable", "_Callfunc", "howcallname", "_ncables", "_callables", "_functionfunc", "howcallable"], "cache": ["module", "client", "args", "default", "proxy", "cmp", "ac", "p", "api", "match", "config", "fake", "cat", "object", "can", "pool", "row", "Cache", "parse", "cookie", "ached", "session", "source", "dict", "query", "index", "data", "ca", "storage", "sync", "base", "model", "c", "temp", "lib", "parent", "app", "call", "code", "array", "ache", "hash", "lock", "table", "store"], "key": ["size", "service", " Key", "name", "id", " entry", "ee", "str", "item", "section", "match", "Key", "mac", "val", "file", "host", "object", "field", "row", "root", "sum", "error", "connection", "loc", "type", "entry", "index", "link", "value", "keys", "data", "base", "c", "temp", "parent", "time", "k", "call", "result", "fee", "y", "code", "path", "copy", "hash", "timeout", "KEY", "reason", "url", "check"], "cachedValue": [" curedValue", "cachedModel", "CashedKey", "cachableEntry", "cachableValue", " curedEntry", "Cachedvalue", "capedValue", "cashedValue", "curedString", "cachedKey", " curedvalue", "curedEntry", "CachedValue", " curedString", "cachableString", "capedKey", "cannedString", "cashedKey", "CashedValue", "cachablevalue", "curedValue", "cachedString", "cannedEntry", " cachedvalue", "cachedEntry", "curedvalue", "cashedvalue", "cachedvalue", "curedKey", "cashedModel", "curedModel", "CachedKey", "Cashedvalue", "capedvalue", "CachedModel", "cannedValue", "cannedvalue", " cachedEntry", " cachedString", "capedModel", "CashedModel"], "C": ["N", "CF", "Count", "JC", "U", "Cy", "G", "Co", "SC", "Cu", "O", "CL", "CNN", "I", "CA", "W", "YC", "M", "NC", "CE", "K", "CM", "VC", "EC", "GC", "DC", "Cache", "CP", "CW", "CC", "L", "D", "A", "Case", "R", "CN", "MC", "B", "S", "FC", "CO", "c", "CV", "CR", "E", "CI", "V", "CU", "Y", "P", "Code", "CT"], "F": ["CF", "U", "UL", "G", "Fs", "FD", "Fore", "DF", "OF", "O", "I", "FB", "W", "FL", "BF", "File", "M", "K", "FER", "Fin", "L", "Family", "D", "FO", "EF", "IO", "PF", "B", "UF", "GF", "FH", "FA", "FC", "FM", "WF", "Fine", "FE", "E", "H", "Feed", "Fun", "V", "RF", "Form", "FF", "Y", "FILE", "Q", "P", "FG", "MF", "FW"], "X": ["N", "U", "RH", "XL", "G", "FORM", "XP", "ZX", "Time", "IX", "Event", "XXX", "CL", "I", "TX", "W", "IP", "File", "M", "Z", "CE", "K", "XT", "MX", "XM", "CC", "L", "EX", "D", "R", "FX", "B", "WH", "Ex", "Work", "TC", "CR", "E", "H", "time", "UX", "CI", "V", "Form", "FF", "DX", "XY", "Y", "Q", "P", "PE", "Power"], "rate": ["rating", "range", "size", "charge", "speed", "rand", "weight", "rule", "score", "duration", "rated", "play", "capacity", "power", "unit", "width", "ride", "ale", "tie", "Rate", "r", "cry", "currency", "date", "race", "rice", "prime", "density", "re", "feed", "source", "type", "m", "core", "rank", "late", "grade", "seed", "R", "value", "fine", "rates", "erate", "sync", "base", "FE", "time", "fan", "dy", "CR", "tone", "delay", "fee", "Y", "cost", "con", "float", "frequency", "cr", "ate", "trial", "scale"], "win_time_wait": ["win_time_time", "win_size_delay", "win_space_wait", "win_time2min", "win_time2win", "win_space_min", "win_timealwait", "win_time_win", "win_times_wait", "win_timealtime", "win_time2delay", "win_times_0", "win_time_delay", "win_timeal0", "win_space2min", "win_space2wait", "win_space2win", "win_time_play", "win_space2delay", "win_time2wait", "win_size_wait", "win_timealdelay", "win_time_min", "win_times_time", "win_space_delay", "win_times_delay", "win_space_win", "win_time_0", "win_size_play"], "buy_time": ["buy_volume", "buy2duration", "buy64weight", "buy671", "buy_1", "buy2count", "buy8space", "buy_weight", "buy67volume", "win_weight", "buy67space", "buy_duration", "win_time", "buy2times", "buy67weight", "buy_count", "buy_space", "buy8volume", "buy_times", "win_times", "win_duration", "win_space", "buy8times", "win_volume", "buy67time", "buy641", "buy64time", "win_count", "buy8time", "buy67times", "buy2time", "buy64times", "win_1"], "win_time_buy_1": ["win_time_play_1", "win_time_play_one", "win_time_play_time", "win_time_buy_inf", "win_time_play_inf", "win_time_win_inf", "win_time_win_time", "win_time_buy_time", "win_time_buy_one", "win_time_win_1", "win_time_win_one"], "f": ["e", "full", "fd", "d", "fr", "info", "fn", "fed", "h", "bf", "p", "xf", "lf", "r", "handler", "z", "file", "t", "form", "ref", "fb", "of", "io", "fing", "feed", "conf", "sf", "m", "l", "rf", "fp", "fast", "inf", "fs", "c", "s", "fe", "b", "fc", "fen", "g", "fa"], "T": ["N", "U", "G", "TN", "Time", "O", "I", "TS", "TB", "W", "Ti", "t", "TA", "M", "DT", "TH", "n", "L", "GT", "D", "TW", "R", "Tu", "B", "S", "TT", "TC", "time", "E", "Type", "V", "PT", "Total", "Y", "Q", "P", "CT", "TI"], "i": ["e", "gi", "si", "xi", "ip", "d", "pos", "hi", "id", "h", "slice", "p", " I", "j", "I", "vi", "im", "t", "pi", "li", "ui", "uri", "q", "n", "ci", "l", "ii", "index", "ti", "c", "int", "k", "CI", "phi", "ix", "y", "ri", "ind", " j", "chi", "qi"], "x": ["e", "xs", "xi", "d", "h", "xp", "xf", "p", "xy", " int", "I", "ct", "z", "rx", "r", "t", "tx", "dx", "w", "n", "index", "ex", "xc", "xxx", "wx", "c", "xe", "test", "xx", "y", "Y", " _"], "v": ["e", "nv", "ve", "lv", "vm", "p", " V", "vv", "vari", "vi", "u", "iv", "z", "val", "t", "ev", "va", "w", "vd", "q", "m", "n", "vol", "l", "vp", "value", "conv", "c", "s", "sv", "k", "vs", "V", "VT", "vy", "y", "b", "uv", "qv", "g", "tv"]}}
{"code": "\\n  \\n  \\n  \\n  INPUT = \"tiny\"\\n  INPUT = \"C-small-attempt1.in\"\\n  \\n  def debug(*args):\\n      sys.stderr.write(str(args) + \"\\n\")\\n  \\n  class Memoize:\\n      def __init__(self,function):\\n          self._cache = {}\\n          self._callable = function\\n              \\n      def __call__(self, *args, **kwds):\\n          cache = self._cache\\n          key = self._getKey(*args,**kwds)\\n          try: return cache[key]\\n          except KeyError:\\n              cachedValue = cache[key] = self._callable(*args,**kwds)\\n              return cachedValue\\n      \\n      def _getKey(self,*args,**kwds):\\n          return kwds and (args, ImmutableDict(kwds)) or args    \\n  \\n  IMPOSSIBLE = set([(2,2,2), (2,2,1), (2,3,1), (2,4,1), (2,5,1)])\\n  \\n  for i in range(2,51):\\n      IMPOSSIBLE.add((2,i,1))\\n      IMPOSSIBLE.add((i,2,1))\\n  \\n  SOLN = {\\n      (1,2,1) : [\"c*\"],\\n      (2,1,1) : [\"c\", \"*\"],\\n      (2,2,3) : [\"c*\", \"**\"],\\n  }\\n  \\n  def solve(R, C, M):\\n      if M == 0:\\n          s = [\"c%s\" % ('.' * (C-1))]\\n          for i in range(R-1):\\n              s.append('.' * C)\\n          return s\\n      t = (R, C, M)\\n      if t in IMPOSSIBLE:\\n          debug(\"** %s %s %s\" % t)\\n          raise ValueError\\n      if t in SOLN:\\n          return SOLN[t]\\n  \\n      if C < M and R > 2:\\n          try:\\n              return solve(R-1, C, M-C) + [\"*\" * C]\\n          except ValueError:\\n              pass\\n  \\n      if C <= R:\\n          if M >= C and R > 2:\\n              return solve(R-1, C, M-C) + [\"*\" * C]\\n      else:\\n          if M >= R and C > 2:\\n              return [\"%s*\" % s for s in solve(R, C-1, M-R)]\\n      if R > 2:\\n          mines = min(C, M)\\n          if mines == C - 1:\\n              mines -= 1\\n          try:\\n              return solve(R-1, C, M-mines) + [(\".\" * (C - mines)) + (\"*\" * mines)]\\n          except ValueError:\\n              if C > 2:\\n                  mines = min(R, M)\\n              if mines == R - 1:\\n                  mines -= 1\\n              s = [\"%s%s\" % (s, '*' if k > C-mines else '.') for k, s in enumerate(solve(R, C-1, M-mines))]\\n              return s\\n      debug(R, C, M)\\n      return []\\n  \\n  def do_trial(R, C, M):\\n      try:\\n          r = solve(R,C,M)\\n          s = \"\\n\" + '\\n'.join(r)\\n          assert len(r) == R\\n          for r1 in r:\\n              assert len(r1) == C\\n          assert len(''.join(k for k in s if k == '*')) == M\\n          return s\\n      except ValueError:\\n          return \"\\nImpossible\"\\n  \\n  \\n  def all():\\n      for R in range(1,50):\\n          for C in range(1,50):\\n              for M in range(R*C):\\n                  print(R, C, M)\\n                  print(do_trial(R, C, M))\\n      sys.exit(0)\\n  \\n  \\n  f = file(INPUT)\\n  T = int(f.readline()[:-1])\\n  for i in range(T):\\n      R, C, M = [int(x) for x in f.readline().split()]\\n      v = do_trial(R, C, M)\\n      print \"Case #%d: %s\" % (i+1, v)\\n", "target": "38", "substitutes": {"INPUT": ["OUTInput", "inPUT", "INInput", " inLINE", " INInput", "OUTLINE", " inVERT", "OUTVERT", "inLINE", " inInput", "INLINE", "INVERT", "inVERT", " inPUT", "OUTPUT", " INLINE", " INVERT", "inInput"], "self": ["e", "full", "ctx", "per", "client", "event", "args", "plus", "proxy", "Self", "patch", "me", "p", "current", "api", "manager", "point", "view", "now", "child", "er", "instance", "case", "context", "master", "host", "form", "ref", "_", "object", "part", "layer", "parse", "connection", "session", "w", "public", "q", "resource", "data", "plugin", "func", "all", "work", "c", "app", "parent", "python", "worker", "call", "this", "node", "other", "ng", "load", "user", "server", "g", "private"], "function": ["full", "module", "operation", "name", "fn", "closure", "word", "package", "document", "fun", "functional", "instance", "handler", "number", " func", "object", "library", "string", "method", "position", "resource", "Function", "func", "callback", "new", "unc", "python", " Function", "F", "call", "node", "this", "array", "float", "wrapper"], "_cache": [" _object", "allcache", "logobject", "allfunction", "logcache", "pyfunction", " _call", "pyconfig", "_function", "pycache", "pyCache", " _ache", "allconfig", "allCache", "_config", "_Cache", "_object", "_call", "logcall", "_ache", "logache"], "_callable": [" _callables", " _Callables", " _Callable", "_generb", " _calling", "_caller", "_Callable", "_cables", "_cer", "_Calling", " _CallFunction", "_createing", "_createable", " _caller", "_callb", "_Callb", "_calling", "_cb", "_Callables", " _callb", "_generable", " _Caller", "_generer", " _Calling", " _Callb", "_createFunction", "_callFunction", "_generables", "_callables", " _callFunction", "_Caller", "_CallFunction", "_createer", "_cable"], "cache": ["mc", "module", "client", "args", "default", "ac", "p", "api", "match", "config", "fake", "instance", "case", "get", "cat", "can", "object", "pool", "root", "Cache", "parse", "cookie", "session", "conf", "dict", "index", "value", "data", "wrapper", "storage", "base", "model", "c", "temp", "parent", "call", "result", "null", "code", "array", "ache", "hash", "lock", "table", "store"], "key": ["page", "size", "sign", "service", " Key", "name", "id", "str", "item", "p", "section", "ace", "Key", "ver", "file", "object", "root", "sum", "error", "string", "date", "connection", "source", "method", "type", "query", "core", "entry", "index", "link", "value", "keys", "data", "base", "c", "temp", "int", "parent", "call", "result", "y", "code", "path", "copy", "hash", "KEY", "reason"], "cachedValue": ["codedValues", "encodedVal", "scachedKey", "scappedvalue", "scappedValues", "codedValue", "casedVal", "cashedValue", "casedValue", "scappedKey", "cachedKey", "scachedValue", "encachedvalue", "cashedKey", "cryptedValues", "encodedValue", "encodedvalue", "encachedValues", "cappedKey", "cappedVal", "encachedVal", "cachedValues", "cashedvalue", "cachedvalue", "cryptedValue", "cryptedKey", "codedvalue", "cryptedvalue", "cachedVal", "casedvalue", "encodedValues", "scachedValues", "cappedvalue", "scappedValue", "encachedValue", "codedVal", "casedValues", "scachedvalue", "cappedValue", "cappedValues", "cashedValues"], "IMPOSSIBLE": ["IMPRECIBLE", "IMPESSible", "IMPASSibles", "IMLPASSibility", "IMpASSibility", "IMpOSSibles", "IMPUSibles", "IMpESSIBLE", "IMLPOSSibility", "IMPRECibles", "IMPOSSibilities", "IMLPASSible", "IMpESSibles", "IMpASSIBLE", "IMPOSSibility", "IMPASSibility", "IMLPASSIBLE", "IMPISSibles", "IMPRECibility", "IMPISSible", "IMPASSible", "IMLPOSSible", "IMpESSible", "IMpASSible", "IMPossIBLE", "IMPOSSibles", "IMPUSIBLE", "IMPESSIBLE", "IMLPOSSIBLE", "IMLPOSSibles", "IMpASSibles", "IMPossible", "IMPASSibilities", "IMPOSSible", "IMPUSibility", "IMPASSIBLE", "IMLPASSibles", "IMPRECible", "IMPISSIBLE", "IMpOSSIBLE", "IMpOSSibility", "IMPossibility", "IMPISSibilities", "IMPossibles", "IMPESSibility", "IMPUSible", "IMpOSSible", "IMPESSibles", "IMPossibilities", "IMpESSibility"], "i": ["e", "gi", "si", "xi", "ip", "d", "id", "h", "p", "j", "I", "u", "im", "ie", "z", "li", "pi", "ai", "io", "n", "ci", "m", "l", "ii", "index", "bi", "ti", "c", "int", "a", "phi", "two", "y", "ri", "iu", "b", "ind", "cm", "o", "qi"], "SOLN": ["SRLN", "SolNG", "solNE", "SILM", "SOLn", "SALNG", "SOVNG", "solN", "sOLNE", "SolNE", "SALK", "sOLM", "solM", " SOLNs", "SLn", "SOVN", "SOLNT", "SRLNs", "SRLNT", "SSOLN", "SOLM", "SALN", "SLN", "SILNE", " SALn", "SolM", "SOLNE", "sOLn", "SSolNG", "SOLNs", "SVOLN", "SOLK", "SRLn", "SILN", "SolK", " SALNT", "SALNT", "SSOLn", "SSOLK", "SOVn", "SOVK", "sOLN", "SALn", "SILn", "SSolN", "SVOLn", " SALNs", "SVOLNs", "SOLNG", "SLM", "SSoln", "soln", "Soln", "SVOLNT", "SLNE", "SolN", "SSOLNG", "SALNs", " SOLNT", " SALN", "SSolK", " SOLn"], "R": ["N", "Rh", "AR", "U", "RH", "G", "X", "RE", "RR", "I", "MR", "W", "Rs", "Range", "K", "RC", "RW", "RO", "SR", "RN", "Re", "m", "L", "D", "A", "ER", "JR", "B", "Rec", "S", "c", "RP", "CR", "E", "H", "F", "IR", "V", "DR", "Run", "RM", "WR", "Y", "NR", "P", "RA", "RG"], "C": ["N", "Count", "Cs", "CF", "U", "G", "Ch", "X", "SC", "Cu", "O", "I", "CL", "Size", "CNN", "CA", "W", "YC", "Cl", "EC", "K", "VC", "CM", "CE", "NC", "DC", "Cache", "CC", "L", "Sc", "D", "A", "MC", "B", " c", "S", "CO", "c", "CV", "CR", "E", "H", "CS", "AC", "CI", "F", "V", "CU", "Y", "Q", "P", "Mc", "CT", "Cr"], "M": ["N", "U", "G", "Ch", "X", "MI", "J", "RE", "O", "I", "MR", "W", "TM", "MD", "MQ", "CM", "K", "MT", "m", "MN", "L", "OM", "D", "A", "MC", "B", "S", "MA", "IM", "E", "H", "AM", "F", " m", "V", "RM", "Y", "Q", "P", "Mc", "MM", "LM", "PM"], "s": ["e", "d", "params", "ps", "args", "ns", "gs", "h", "p", "services", "u", "ssl", "_", "ed", "ds", "string", "its", "cs", "w", "es", "m", "n", "ins", "ls", "als", "os", "ings", "south", "ss", "sl", "https", "S", "strings", "c", "a", "states", "rs", "y", "lines", "b", "array", "sites", "o", "g", "ts"], "t": ["e", "tt", "d", "tr", "ta", "h", "str", "p", "j", "out", "u", "z", "it", "tf", "dt", "string", "w", "type", "m", "n", "tm", "l", "the", "tim", "ut", "ti", "S", "te", "all", "c", "tc", "tg", "int", "a", "temp", "test", "st", "tor", "this", "y", "tmp", "b", "o", "tip", "g", "ts"]}}
{"code": "T = int(raw_input());\\n  for q in range(T):\\n      [C,F,X] = map(float, raw_input().split());\\n  \\n  \\n      Time = 0.;\\n      Rate = 2.;\\n      Fin = False;\\n      while (not Fin):\\n          t0 = X/Rate;\\n          t1 = C/Rate + X/(Rate+F);\\n  \\n          if t0 <= t1:\\n              Time += t0;\\n              Fin = True;\\n          else:\\n              Time += C/Rate;\\n              Rate += F;\\n  \\n      print \"Case #%d:\" % (q+1),;\\n      print \"%.7f\" % Time;\\n      \\n          \\n", "target": "39", "substitutes": {"T": ["N", "U", "Length", "G", "O", "TS", "W", "t", "M", "Z", "K", "L", "D", "A", "R", "Tu", "B", "S", "TT", "Ts", "TC", "E", "H", "V", "Total", "Y", "Q", "P", "TI"], "q": ["eq", "quant", "d", "iq", "qs", "id", "num", "i", "requ", "h", "p", "j", "max", "I", "quick", "u", "count", "z", "qt", "qq", "t", "r", "v", "w", "sq", "n", "query", "seq", "c", "int", "a", "k", "x", "quit", "dq", "y", "Q", "P", "ind", "f", "req", "g", "qu"], "C": ["N", "U", "G", "Cu", "O", "I", "CL", "CNN", "Size", "CA", "W", "M", "Z", "K", "VC", "EC", "DC", "CC", "L", "D", "A", "R", "B", "S", "CO", "c", "CV", "E", "H", "AC", "CS", "CI", "V", "CU", "Y", "Q", "P", "Code"], "F": ["N", "CF", "U", "G", "Fs", "FD", "DF", "O", "I", "IF", "W", "FL", "M", "L", "D", "FO", "EF", "R", "PF", "B", "FH", "GF", "FM", "FA", "FC", "Feed", "Fine", "E", "H", "FE", "V", "RF", "FF", "Y", "Q", "P", "f", "AF", "FW"], "X": ["N", "CF", "U", "XL", "G", "XP", "CL", "I", "TX", "W", "M", "Z", "CE", "K", "MX", "XM", "CC", "L", "D", "A", "R", "B", "Ex", "S", "FC", "FE", "CR", "E", "H", "x", "V", "DX", "Y", "Q", "P", "XX", "PE"], "Time": ["Count", "Length", "ID", "Force", "Ch", "Inter", "Offset", "Query", "Price", "Event", "Frame", "Start", "Size", "ime", "Str", "Hour", " time", "Performance", "Power", "File", "Clock", "Name", "Line", "Z", "Money", "Tim", "Value", "Unit", "Context", "Data", "Position", "Times", "TIME", "Service", "Speed", "Check", "Timer", "Date", "time", "Thread", "Shift", "String", "Duration", "Type", "Timeout", "Form", "Y", "Mode", "Code", "Cost", "Depth"], "Rate": ["Dur", "Flow", "Count", "Version", "Sample", "Rule", "Length", "Depth", "Fixed", "Byte", "Audio", "Do", "Rank", "Control", "Force", "Channel", "Break", "Event", "RR", "Size", "Key", "File", "Line", "CE", "Percent", "Unit", "Value", "Repeat", "Factor", "Gate", "Grade", "Default", "Proxy", "Phase", "Re", "Order", "Weight", "Group", "State", "Service", "Speed", "R", "UR", "IO", "rate", "Float", "Function", "Scale", "Sem", "FE", "Base", "Fine", "Train", "E", "Duration", " rate", "Type", "Source", "Write", "Score", "Y", "Ra", "Mode", "Code", "Power", "PM", "Number", "Range"], "Fin": ["Dur", "Eth", "Ch", "Fake", "Fore", "Cor", "FD", "Sent", "Tr", "Wh", "Die", "Break", "Qu", "Car", "Ku", "Bi", "Sk", "Num", "Throw", "Close", "Finish", "Pol", "FIN", " fin", "Nice", "Fit", "Fra", "Fr", "Res", "Fail", "Fan", "Tu", "Len", "Progress", "Com", "Rom", "Fine", "Fun", "Ul", "Train", "Ni", "Init", "Late", "Beg", "Run", "fin", "Cond", "Like", "Lu", "Conf", "Long", "Fa", "Log"], "t0": ["T1", "f0", "pfe", "t5", "ta00", "f2", "p0", "ta1", " t00", "t2", "Tfe", "T00", "T2", "t00", "p2", "f1", "ta0", "T5", " t2", " tfe", " t5", "ta5", "T0", "p1", "tfe"], "t1": [" t3", "dt1", " t4", "T1", "f0", "dt0", "T100", "f2", "dt4", "T4", "t3", "f100", "dt3", "t100", "t2", " t100", "T2", "f1", " t2", "t4", "T0", "T3"]}}
{"code": "def Trivial(R,C,char):\\n      for i in range(R):\\n          Ans = '';\\n          for j in range(C):\\n              if (i==j==0):\\n                  Ans += 'c';\\n              else:\\n                  Ans += char;\\n          print Ans;\\n  \\n  \\n  def Draw1(R,C,Blank):\\n      Ans = \"c\";\\n      for i in range(Blank-1):\\n          Ans += '.';\\n      for i in range(R*C-Blank):\\n          Ans += '*';\\n      if (R == 1):\\n          print Ans;        \\n          return;\\n      if (C == 1):\\n          for i in range(len(Ans)):\\n              print Ans[i];\\n  \\n  def Draw2(R,C,Blank):\\n      if (Blank%2 != 0) or (Blank == 2):\\n          print \"Impossible\";\\n          return;\\n      Row1 = '.'*(Blank/2) + '*'*(Mine/2);\\n      Row0 = 'c' + Row1[1:];\\n      if R==2:\\n          print Row0;\\n          print Row1;\\n      else:\\n          for i in range(len(Row0)):\\n              print Row0[i]+Row1[i];\\n      return;\\n  \\n  \\n  def Generate(R, C, Blank):\\n      TODO = Blank;\\n      Spaces = [0]*R;\\n      if TODO <= 2*C:\\n          if TODO%2 == 0:\\n              Spaces[0] = TODO/2;\\n              Spaces[1] = TODO-Spaces[0];\\n          else:\\n              if (TODO == 7):\\n                  Spaces[0] = 3;\\n                  Spaces[1] = 2;\\n                  Spaces[2] = 2;\\n              else:\\n                  Spaces[0] = (TODO-3)/2;\\n                  Spaces[1] = (TODO-3)/2;\\n                  Spaces[2] = 3;\\n      else:\\n          row = 0;\\n          if (TODO >= 2*C+2):\\n              Spaces[0] = C;\\n              Spaces[1] = C;\\n              TODO -= 2*C;\\n              row = 2;\\n              \\n          while TODO > C+1:\\n              if (TODO == 2*C+1) and (C != 3):\\n                  Spaces[row] = C-1;\\n                  Spaces[row+1] = C-1;\\n                  Spaces[row+2] = 3;\\n                  TODO = 0;\\n              else:\\n                  Spaces[row] = C;\\n                  TODO -= C;\\n                  row += 1;\\n          if (TODO == C+1):\\n              Spaces[row] += C-1;\\n              Spaces[row+1] = 2;\\n              TODO = 0;\\n          Spaces[row] += TODO;\\n  \\n      for r in range(R):\\n          Ans = '.'*Spaces[r] + '*'*(C-Spaces[r]);\\n          if r == 0:\\n              Ans = 'c'+Ans[1:];\\n          print Ans;\\n  \\n  \\n  def Solve(R, C, M):\\n      Blank = R*C-M;\\n      if Blank == 0:\\n          print \"Impossible\";\\n          return;\\n  \\n      if (Blank == 1):\\n          Trivial(R,C,'*');\\n          return\\n      if (Blank == R*C):\\n          Trivial(R,C,'.');\\n          return\\n  \\n      if (R == 1) or (C == 1):\\n            Draw1(R,C,Blank);\\n            return\\n  \\n      if (R-2)*(C-2) == 0:\\n          Draw2(R,C,Blank);\\n          return\\n  \\n      if Blank in [2,3,5,7]:\\n          print \"Impossible\";\\n          return;\\n      \\n      if (R >= 3) and (C >= 3):\\n          Generate(R, C, Blank);\\n  \\n      return;\\n  \\n  \\n  T = int(raw_input());\\n  for q in range(T):\\n      [Row,Col,Mine] = map(int, raw_input().split());\\n  \\n      Blanks = Row*Col - Mine;\\n      \\n      print \"Case #%d:\" % (q+1)\\n      Solve(Row, Col, Mine);\\n      \\n          \\n", "target": "39", "substitutes": {"R": ["N", "Rh", "U", "RH", "Rule", "G", "X", "Co", "RL", "Rank", "J", "O", "RR", "I", "W", "Roman", "Rs", "Range", "Cl", "K", "RC", "RW", "RO", "SR", "RN", "Right", "Re", "L", "Res", "D", "A", "JR", "B", "RS", "S", "BR", "RP", "CR", "E", "H", "Br", "F", "IR", "V", "Run", "RF", "RM", "Y", "Ra", "NR", "Q", "P", "LR", "RA", "RG"], "C": ["N", "JC", "Cs", "Count", "U", "UC", "G", "Ch", "X", "Co", "SC", "Cu", "O", "CL", "I", "CNN", "CA", "W", "YC", "Cl", "CM", "VC", "K", "EC", "NC", "CE", "GC", "DC", "Cache", "Custom", "CW", "Ca", "CC", "L", "Sc", "D", "Case", "A", "B", " c", "S", "c", "KC", "CV", "CR", "E", "H", "CS", "CI", "F", "V", "CU", "Y", "Q", "P", "Con"], "char": ["e", "CHAR", "Character", "ctr", "Ch", "short", "str", "ch", "u", "v", "string", "esc", "cur", "uc", "ci", "CC", "Char", "text", "c", "car", "int", "cell", "character", "void", "f", "CCC", "escape"], "i": ["e", "gi", "si", "ini", "xi", "ip", "d", "col", "id", "h", "p", "I", "start", "vi", "u", "ie", "z", "li", "pi", "ai", "ui", "ih", "v", "ni", "it", "io", "uri", "n", "ci", "m", "l", "ii", "index", "ei", "bi", "di", "ti", "yi", "c", "int", "a", "k", "x", "ix", "y", "ri", "code", "iu", "b", "f", "o", "iw", "ia", "chi", "g", "qi"], "Ans": ["EllS", "Synb", "ANc", "Anneches", "ANlines", "Annets", "AnneS", "Samsi", "Ens", "Anneges", "ANws", "Annws", " Anths", "Annlines", "Annecs", "Ells", "Anneths", "Bons", "annges", "Anths", " Anc", "Anks", "Navths", " Anns", "AnnS", "Pathks", "Pathlines", "Acns", "ANs", "Af", "Samows", "Navs", " Ants", "AnS", "Ansi", " Anows", "Enches", "Acc", "Anows", "AnalyS", "Analyths", "Ants", "Enrors", "Navges", "Connects", " Anws", "Anns", " Ansi", "ANts", "As", "Annec", "Ellths", "Anges", "Bonts", "Bonns", "Synns", "ANsi", "Sams", " Ann", " Anlines", "AS", "Anws", "Paths", "Anches", " AnS", "Acb", "ANcs", "annths", "annf", "ConnectS", "Ancs", "anns", "Anrors", "Ann", "Annelines", " Ancs", " Anrors", "Anf", "Anc", "Ents", "ANS", "Elln", "PathS", " Anb", "Annesi", "Enns", "ANches", "Connectsi", "Aks", "Connectows", " Anks", "Ensi", "Analys", "Anlines", "ANf", "Enlines", "Annes", "Bonrors", "ANks", "Anb", "Acs", "SamS", "Sync", "annks", "Analyn", "NavS", "annS", "Syns"], "j": ["e", "gi", "si", "iy", "pos", "J", "p", "ch", "I", "z", "jl", "ai", "jj", "v", "co", "jac", "n", "m", "ci", "l", "jp", "ij", "ii", "ei", "je", " ii", "bj", "c", "ja", "ia", "jc", "ji", "k", "ix", "y", "jo", "oi", "b", "ind", "code", "o", "g", "\u0438", "js", "oj"], "Blank": [" Blan", "BLisk", "Blunk", "Clace", "Blink", " Blamp", "Brunk", "blan", "blane", " Blane", "blanks", "BLANK", " Blisk", "BLanks", "Clan", "PlANK", "Blace", "Place", "Flan", "blash", "Blane", "Flank", " blANK", "Planks", "Flanking", "BLunk", " Blace", " Blash", "BLan", "Brank", "Clash", "blace", "Blash", " BlANK", "blink", "Blamp", "Flane", "BlANK", " blace", "FlANK", " Blanking", " blanks", " blamp", "BrANK", "Clanks", "Blanking", "blanking", "Clank", "BLank", " blank", "Brace", "Blisk", "blank", "BLanking", "blamp", " blanking", "blunk", "BLace", "blisk", "Plank", "Plink", " blink", "blANK", "Blan", "Planking", "Plan"], "Row1": ["CellOne", "Cell0", "rowOne", "Row2", "row0", " RowOne", "Cell2", "Cell1", "LineOne", "row2", "Line1", "Row3", " Row2", "row3", "Line0", "RowOne", "Cell3", "row1", "Line3", "Line2"], "Row0": ["Cell0", "Column1", "Row2", "Column4", " Row4", "Line00", "Line50", "row0", " Row8", "Cell2", "Row50", "Row00", " Row00", "row8", "Cell1", " Row50", "row2", "Line1", "Row8", "Column8", "Row4", " Row2", "Line0", "Ro50", "Ro0", "Ro1", "row1", "row4", "Line2", "Ro00", "Column0"], "TODO": ["TOKDo", "TODOA", "tODH", "NPDo", "TADOS", "PODON", "TOCOO", "TODEO", "TNDEO", "TOKo", " TOVY", "TodBo", "TOVOL", "POKo", "TOYOA", " TOVO", "TNDO", "NTodDo", "TPDT", " TODo", "FODo", "TodMo", "TOKEO", "TODPO", "TODOL", "POKO", " TODT", "TOYDO", "TWodMo", "TOCo", "PODO", "TODOK", "TodY", " TPDOO", "NTODO", "TodOs", "TMDOO", "VTodO", "TPDOA", "TEDO", "TODC", " TPDo", "TPDOO", "TOYOO", " TODOK", "FOKo", "TOTALOD", "TOCT", "FOKOO", "TOKU", "GODOD", "FOKOA", "tODEO", "VTODOS", "TOVDO", "tOKO", "TDDOL", "tODO", "TOVY", "TOOE", "TodOD", "FODOA", "TODH", "NTodC", "TODT", "TOYo", "FOKO", "TNDC", "VTodE", "TOKOE", "TOTALMo", "TADO", "TOVO", "FODOO", "TODE", "TOTALOs", " TODY", "TOVBo", "tPDo", "TDDDO", "Todo", "TOTALo", "TodON", "TodU", "tPDH", "TOTALO", "TMDT", "TodH", "TOTALDo", "NTODDo", "TLLPO", "VTODE", "TODU", "TOTALON", "PODDo", "NPDPO", "TOCO", "TEDo", "TNDDo", "TodEO", "TODOO", " TPDDO", "TOVOK", "GodOE", "tPDOO", "POKON", "tODDO", "TODo", "TodDO", "TOOD", "TODOD", "NTODC", "VTODO", "tODo", "TPDH", "TADOs", "NODPO", "TOKOO", "GodO", "TODOE", "TPDDo", "TECOK", "TOKOA", "TodOS", "TDDO", "TOKOS", "TWodOS", " TOVBo", "tOKEO", " TOVOK", "FODO", "TodE", "POKDo", "TPDO", "TOKC", "TodC", "TWodO", "tOKU", " TODOO", "tODU", "TOYO", "TPDPO", "TLLO", "GODOE", " TODOL", "NPDDo", " TODBo", "TODOS", "TADMo", "NTodEO", "TOTALOS", "TEDPO", "TOO", " TPDOL", "GodOD", "TOKON", "VTodOD", "TodDo", " TPDO", "TWODOs", "TMDo", "TODBo", " TPDT", "tOKDO", "VTODOD", "NODO", "TEDDo", "TodOE", "TODON", "TDDOO", "TPDDO", "TECY", "TodO", "TPDo", "NTodO", "TodOO", "PODo", "TECO", "TOKOD", "TodOK", "TOVOO", "TMDO", "TOYEO", " TODDO", "TOKDO", "tPDO", "TPDOL", "NODo", "tODOO", "TODDo", "GODEO", "TODOs", "TWodOs", "TOKE", "TLLo", "TODY", "TECBo", "TOYU", "NPDO", "VTodOS", "NODDo", "TOEO", "TWODMo", "TWODO", "NTODEO", "TOCH", "TODMo", "TOTALE", "TWODOS", "GODO", "TOKO", "GodEO", "TLLDo", "TODDO"], "Spaces": ["Spacements", "spaces", "SPays", "spacements", "Spfaces", " Spacing", " Spfaces", "spays", "Slaches", "spapes", "SPaches", " Spaced", "Slacing", "sppaces", " Spays", "SPapes", "Spapes", " Spaches", "Prefaces", " Spices", "SPaced", "spaced", "Slans", " Spacements", "Pracing", "Preffaces", "Prans", "Places", "Spays", "Spabs", "Sppaces", "spfaces", "SPacing", "spices", "Slays", " Sppaces", "Prefacing", "Praces", "spaches", "Spacing", " Spans", "SPices", "Placements", "Paraces", "Slacements", "Placing", "spans", "Parpaces", "Prefabs", "SPfaces", "Slaces", "Plfaces", "SPaces", "SPans", "Praches", " Spapes", "Paracing", "Plans", "Plapes", "Paraced", "Plaches", "spacing", "SPabs", "Spans", " Spabs", "SPacements", "Plices", "Spaced", "Spices", "Spaches"], "row": ["page", "range", "container", "col", "tr", "num", "rows", "offset", "step", "h", "bug", "month", "p", "length", "channel", "max", "column", "count", "flow", "group", "error", "record", "feed", "position", "ow", "entry", "index", "where", "order", "value", "raw", "port", "mod", "block", "c", "key", "head", "cell", "x", "line", "height", "min", "y", "post", "o", "low", "scale"], "Mine": ["crop", "Sample", "Continue", "Max", "repeat", "Block", "RGB", "case", "Circ", "Roman", "Line", "Repeat", "Cut", "CC", "Case", "Rec", "CV", "cell", "line", "Diamond", "White", "cr", "CCC", "Cr", "Fill"]}}
{"code": "\\n  \\n  def process(C, F, X):\\n  \tspeed = 2.0\\n  \ttime = 0.0\\n  \twhile True:\\n  \t\tif C / speed + X / (speed + F) > X / speed:\\n  \t\t\ttime += X / speed\\n  \t\t\tbreak\\n  \t\ttime += C / speed\\n  \t\tspeed += F\\n  \treturn round(time, 7)\\n  \\n  input_file = open(sys.argv[1], 'r')\\n  T = int(input_file.readline())\\n  for i in range(T):\\n  \t(C, F, X) = map(float, input_file.readline().split())\\n  \tprint 'Case #%d:' % (i + 1), process(C, F, X)\\n", "target": "40", "substitutes": {"C": ["N", "CF", "Cs", "JC", "U", "G", "SC", "Cu", "O", "CL", "I", "CA", "W", "YC", "M", "CM", "K", "EC", "CE", "VC", "GC", "DC", "CP", "CC", "L", "D", "A", "R", "MC", "CN", "B", "S", "FC", "CO", "c", "CV", "CR", "E", "AC", "CI", "V", "CU", "Y", "P", "chain", "CT", "Con"], "F": ["N", "Flow", "CF", "U", "Ext", "Fixed", "G", "Fs", "FD", "Fore", "OF", "DF", "FI", "O", "I", "FB", "W", "FL", "File", "M", "Z", "K", " f", "FIN", "Fin", "Fi", "FS", "L", "Family", "D", "FO", "EF", "R", "A", "FM", "B", "FH", "PF", "GF", "FC", "FR", "FA", "WF", "Fine", "Fun", "E", "H", "SF", "FE", "V", "FF", "Y", "FILE", "Q", "P", "f", "FG", "FW"], "X": ["N", "Test", "CF", "U", "XL", "G", "XP", "Time", "IX", "Event", "XXX", "CL", "I", "TX", "CA", "W", "IP", "File", "Z", "CE", "DC", "Right", "XM", "CC", "L", "Cross", "D", "FO", "R", "HTTP", "FX", "B", "WH", "Ex", "Check", "S", "FC", "Work", "c", "FE", "CR", "E", "H", "UX", "x", "V", "DX", "FF", "XY", "Y", "Q", "P", "XX", "PE", "CT", "FW"], "speed": ["size", "stop", "sign", "service", "weight", "duration", "score", "distance", "step", "power", "capacity", "Time", "powered", "width", "length", "ride", "start", "performance", "count", "force", "swing", "level", "status", "send", "engine", "sum", "slow", "race", "strength", "pipe", "sleep", "scroll", "rank", "grade", "seed", "Speed", "index", "rate", "peed", "fast", "sync", "style", "sort", "key", "fan", "mass", "shape", "x", "screen", "cycle", "depth", "delay", "second", "cost", "path", "f", "frequency", "timeout", "mode", "scale"], "time": ["size", "stop", " TIME", "loop", "duration", "weight", "money", "name", "shift", "power", "Time", "timeout", "length", "ime", "start", "case", "count", "year", "t", "slow", "race", "date", "trace", "type", "TIME", "sleep", "age", "clock", "tim", "rate", "value", "hour", "times", "use", "tick", "depth", "cycle", "x", "how", "delay", "timer", "second", "cost", "frequency", " Time"], "input_file": ["inputingtype", "inputmemfile", "inputfulmessage", "inputfulfile", "inputingsource", "output_socket", "inputfulclass", "inputingfile", "output_file", "inputmemtype", "output_handle", "inputmemsource", "image_class", "input_socket", "input_message", "imageingclass", "image_type", "input_source", "input_type", "input_stream", "input_handle", "inputmemclass", "inputingclass", "output_source", "output_class", "imageingfile", "output_stream", "imageingsource", "inputfulhandle", "output_message", "imageingtype", "image_source", "image_file", "input_class"], "T": ["N", "U", "Length", "G", "TN", "Time", "O", "I", "TS", "W", "t", "M", "Z", "K", "UTC", "TH", "TIME", "L", "D", "A", "TW", "R", "B", "S", "TT", "TC", "E", "H", "V", "Total", "NT", "Y", "P", "DT"], "i": ["e", "gi", "si", "inter", "xi", "ip", "d", "pos", "mi", "id", "h", "p", "j", "I", "start", "u", "im", "multi", "t", "pi", "li", "uri", "type", "n", "ci", "m", "l", "index", "ii", "c", "end", "int", "phi", "x", "y", "ind", "f", "qi"]}}
{"code": "\\n  def put_mines_last_step(R, C, M, grid):\\n  \tif M == 0:\\n  \t\treturn\\n  \tR -= 1\\n  \tC -= 1\\n  \tgrid[R][C] = '*'\\n  \tM -= 1\\n  \tr = R - 1\\n  \tc = C - 1\\n  \twhile M > 0:\\n  \t\tif r > c:\\n  \t\t\tgrid[r][C] = '*'\\n  \t\t\tr -= 1\\n  \t\telse:\\n  \t\t\tgrid[R][c] = '*'\\n  \t\t\tc -= 1\\n  \t\tM -= 1\\n  \\n  def put_mines(R, C, M, grid):\\n  \tif R > C:\\n  \t\tif M < C:\\n  \t\t\tput_mines_last_step(R, C, M, grid)\\n  \t\t\treturn\\n  \t\tfor i in range(C):\\n  \t\t\tgrid[R - 1][i] = '*'\\n  \t\tput_mines(R - 1, C, M - C, grid)\\n  \t\treturn\\n  \tif M < R:\\n  \t\tput_mines_last_step(R, C, M, grid)\\n  \t\treturn\\n  \tfor i in range(R):\\n  \t\tgrid[i][C - 1] = '*'\\n  \tput_mines(R, C - 1, M - R, grid)\\n  \treturn\\n  \\n  def process(R, C, M):\\n  \trlt = ''\\n  \tgrid = []\\n  \tfor i in range(R):\\n  \t\tgrid.append(['.'] * C)\\n  \tput_mines(R, C, M, grid)\\n  \tif not C == 1:\\n  \t\tfor i in range(R):\\n  \t\t\tif not grid[i][0] == '.':\\n  \t\t\t\tbreak\\n  \t\t\tif not grid[i][1] == '.':\\n  \t\t\t\treturn '\\nImpossible'\\n  \tif not R == 1:\\n  \t\tfor i in range(C):\\n  \t\t\tif not grid[0][i] == '.':\\n  \t\t\t\tbreak\\n  \t\t\tif not grid[1][i] == '.':\\n  \t\t\t\treturn '\\nImpossible'\\n  \tgrid[0][0] = 'c'\\n  \tfor i in grid:\\n  \t\trlt += '\\n' + ''.join(i)\\n  \treturn rlt\\n  \\n  input_file = open(sys.argv[1], 'r')\\n  T = int(input_file.readline())\\n  for i in range(T):\\n  \t(R, C, M) = map(int, input_file.readline().split())\\n  \tprint 'Case #%d:' % (i + 1), process(R, C, M)\\n", "target": "40", "substitutes": {"R": ["N", "Rh", "e", "AR", "U", "RH", "Rule", "G", "X", "RL", "RE", "p", "Row", "RR", "I", "MR", "W", "Rs", "RG", "K", "RC", "RW", "RO", "SR", "RN", "Right", "Re", "L", "Res", "D", "A", "ER", "JR", "B", "RS", "Rec", "S", "RP", "CR", "E", "H", "Gr", "F", "IR", "V", "x", "RF", "RM", "WR", "DR", "Run", "Y", "Ra", "NR", "Q", "P", "GR", "Region", "RT", "LR", "RA", "Cr", "Range"], "C": ["N", "Rh", "CF", "Cs", "U", "d", "G", "Ch", "X", "Co", "SC", "Cu", "O", "CL", "I", "CNN", "CA", "W", "YC", "NC", "CE", "CM", "K", "VC", "Cl", "EC", "GC", "DC", "Cont", "RC", "CW", "Z", "m", "CC", "L", "Sc", "D", "A", "MC", "CN", "B", "Chain", "S", "CV", "CR", "E", "H", "AC", "CI", "F", "V", "CU", "Y", "Q", "Mc", "P", "Code", "CT", "Cr"], "M": ["N", "U", "VM", "G", "ME", "X", "MI", "Me", "J", "O", "MOD", "RR", "I", "CL", "MR", "W", "Meta", "Ms", "MD", "NM", "CM", "K", "JM", "Mi", "MS", "EM", "Mor", "m", "MN", "L", "Multi", "Mo", "D", "A", "OM", "MC", "OR", "B", "DM", "FM", "S", "MB", "E", "H", "MF", "AM", "F", "V", "Man", "RM", "Module", "Y", "Q", "Mc", "P", "cm", "AMD", "MM", "LM"], "grid": ["ID", "json", "auto", "man", "filter", "case", "law", "card", "row", "mat", "div", "mag", "fit", "rank", "query", "sim", "graph", "close", "mod", "reg", "zip", "stage", "cell", "hard", "house", "node", "site", "db", "cm", "table", "range", "rule", "gage", "product", "mu", "count", "mm", "press", "gap", "flat", "record", "edge", "remote", "valid", "storage", "df", "F", "x", "ga", "code", "medium", "array", "f", "server", "hold", "update", "module", "client", "G", "id", "cart", "play", "gui", "p", "layout", "gr", "export", "xml", "input", "config", "multi", "file", "static", "form", "cells", " module", "layer", "date", "csv", "m", "ci", "cum", "grade", "live", "order", "data", "g", "block", "model", " Grid", "frame", "run", "format", "chain", "plot", "diff", "draw", "bug", "standard", "crop", "cube", "final", "ac", "str", "unit", "cfg", "list", "column", "u", "image", "heat", "flow", "report", "group", "cli", "lat", "string", "parse", "q", "age", "mid", "script", "wire", "cache", "work", "move", "line", "message", "active", "rid", "arc", "cr", "Grid", "lc"], "r": ["e", "Rh", "yr", "rr", "rb", "br", "d", "rc", "h", "p", "RR", "ar", "mr", "u", "er", "MR", "W", "Rs", "v", "lr", "ir", "w", "m", "n", "l", "ru", "right", "rh", "CR", "rs", "x", "sr", "nr", "b", "cm", "f", "P", "cr", "o", "Cr"], "c": ["e", "N", "mc", "U", "d", "rc", "h", "ac", "dc", "p", "I", "u", "z", "t", "v", "cu", "rec", "w", "uc", "q", "cy", "m", "n", "CC", "l", "ci", "right", "cc", "s", "a", "k", "x", "nc", "y", "b", "cm", "f", "P", "cr", "o", "chain", "lc", "Cr"], "i": ["ini", "il", "name", "hi", "I", "im", "zi", "ni", "io", "uri", "index", "bi", "ti", "init", "phi", "y", "ind", "iw", "chi", "gi", "si", "mi", " I", "z", "li", "_", "ui", "n", "l", "ii", "yi", "LI", "s", "a", "ic", "x", "ri", "b", "f", "o", "eni", "e", "module", "d", "id", "gui", "slice", "p", "j", "ar", "input", "multi", "t", "pi", "ai", "v", "ir", "m", "ci", "model", "iu", "info", "xi", "ip", "iq", "mini", "h", "fi", "u", "ie", "gu", "it", "cli", "ei", "B", "di", "int", "CI", "ix", "g", "qi"], "rlt": [" relt", "Rlett", "Rlt", "cmin", "relt", " rmin", "clt", " rlett", "rLT", "Rlet", "mlt", "mlett", "rlet", " rLT", "rmin", "clet", "mLT", "celt", "rlett", "melt", "cLT", " rlet", "Relt", "Rmin", "RLT"], "input_file": ["inputacfp", " input_File", " inputingfile", "input1module", "input_files", "inputachandler", "input_handler", "input_File", "inputinghandler", "inputingfile", " input_handler", "input___fp", "inputedfiles", "input1file", " input_files", "inputacfile", "inputedfile", " inputingfilename", "inputedhandler", "input1File", "inputingfiles", " input_module", " inputinghandler", "input_filename", "inputedfilename", " inputingfiles", "inputacbuffer", "input_buffer", "inputingfilename", " input_fp", "input_module", "input_fp", "inputfileFile", "inputfilemodule", "inputfilefiles", "input___file", "input1files", "input___buffer", "inputfilefile", "input___handler", " input_filename", " input_buffer"], "T": ["N", "TR", "U", "G", "X", "TN", "Time", "O", "I", "TS", "TB", "W", "t", "TA", "Z", "K", "TH", "L", "WT", "D", "A", "B", "S", "TT", "TC", "E", "H", "F", "V", "Total", "NT", "Y", "Q", "P", "DT"]}}
{"code": "\\n  lines = [line.strip() for line in open(sys.argv[1])]\\n  count = int(lines[0])\\n  \\n  for i in xrange(count):\\n      farm_cost,farm_production,target = map(float, lines[i+1].split())\\n      seconds = 0\\n      production = 2\\n      best = float(\"inf\")\\n      while True:\\n          best = min(best, seconds + target / production)\\n          seconds += farm_cost / production\\n          if seconds >= best: break\\n          production += farm_production\\n  \\n      print \"Case #%s: %.7f\" % (i+1, best)\\n", "target": "41", "substitutes": {"lines": ["rules", "letters", "xs", "ines", "args", "qs", "ids", "rows", "points", "words", "lined", "sections", "codes", "values", "cells", "lins", "lights", "ds", "ips", "comments", "elines", "pages", "l", "ls", "breaks", "groups", " Lines", "headers", "posts", "frames", "files", "strings", "s", "blocks", "links", "los", "loads", "cycles", "items", "runs", "bytes", "objects", "steps"], "line": ["e", "page", "strip", "d", "name", "cle", "ine", "rule", "inline", "word", "str", "p", "lf", "column", "file", "Line", "v", "lin", "row", "LINE", "source", "nl", "l", "day", "link", "de", "sl", "char", "block", "sel", "c", "s", "end", "split", "cell", "frame", "kl", "code", "le", "f", "url", "lc"], "count": ["Count", "size", "counter", "weight", "id", "num", "act", "len", "large", "length", "list", "max", "deep", "start", "child", "now", "case", "force", "number", "first", "sum", "part", "type", "limit", "n", "core", "index", "order", "close", "base", "c", "cc", "time", "key", "depth", "cycle", "call", "find", "process", "found", "code", "path"], "i": ["e", "gi", "si", "ini", "xi", "ip", "d", "my", "id", "num", "mini", "slice", "p", " I", "j", "I", "start", "u", "ie", "z", "multi", "li", "pi", "ai", "ui", "v", "part", "type", "n", "ci", "ii", "index", "di", "ti", "c", " ii", "key", "int", "k", "phi", "x", "y", "esi", "iu", "ind", "f", " j", "qi"], "farm_cost": ["farm___depth", "enough_rate", "farm64price", "farm64cost", "enough_price", "enough64rate", "farm64rate", "tower___depth", "enough_cost", "farm___rate", "farm___cost", "tower_cost", "enough64cost", "farm_rate", "tower___rate", "farm_depth", "tower___cost", "farm_price", "enough64price", "tower_rate", "tower_depth"], "farm_production": ["farm_termination", "farm2Production", "farm_product", "farm2product", "farm2production", "farm_Production", " farm_termination", "farm_budget", " farm_product", " farm_Production", " farm_budget", "farm2cost"], "target": ["range", "stop", "platform", "origin", "weight", "profit", "high", "highest", "large", "unit", "next", "current", "point", "width", "border", "force", "master", "peak", "output", "total", "top", "effective", "source", "edge", "type", "hop", "support", "component", "better", "growth", "end", "success", "price", "window", "goal", "phase", "second", "cost", "latest", "confidence"], "seconds": ["gravity", "size", "comes", "hours", "speed", "service", "duration", "asts", "changes", "final", "unit", "months", "period", "services", "outs", "sections", "future", "send", "security", "errors", "left", "small", "fps", "minimum", "forces", "years", "pieces", "prototype", "south", "ss", "scenes", "times", "files", "s", "sec", "low", "flash", "flows", "tests", "bugs", "fe", "reports", "second", "ends", "latest", "sites", "confidence", "ances", "since", "bytes", "ones", "objects", "steps", "quarters", "ops"], "production": ["standard", "stop", "profit", "good", "highest", "capacity", "final", "power", "season", "unit", " prod", "current", "width", "length", "border", "product", "Production", "future", "performance", "start", " profits", "produ", "commercial", "communication", "output", "project", "first", "ope", "competitive", "top", "company", "flower", "boost", "core", "termination", "prototype", "alpha", "last", "winner", "better", "progress", "stage", "growth", "paid", "success", "protection", "fe", "second", "development", "cost", "worst", "confidence", "latest", " Production", "efficiency", "produced"], "best": [" biggest", " largest", "perfect", "standard", "failed", "working", "default", "self", " worst", "good", "highest", "profit", "pp", "eff", "final", "std", "p", "max", "start", "instance", "master", "peak", "largest", " Best", "first", "ast", "top", "existing", "effective", "half", "rank", "live", " newest", "only", "same", "ss", "right", " closest", "average", "last", "back", "winner", "better", "bottom", "Best", "new", "end", "gold", " finest", "success", " highest", "test", "great", "this", "est", "goal", "today", "worst", "cost", "latest", "diff", "asts", "hest"]}}
{"code": "\\n  lines = [line.strip() for line in open(sys.argv[1])]\\n  count = int(lines[0])\\n  \\n  for i in xrange(count):\\n      R,C,M = map(int, lines[i+1].split())\\n      print \"Case #%s:\" % (i+1)\\n  \\n      w = max(R,C)\\n      h = min(R,C)\\n      X = R*C - M\\n      assert X > 0\\n  \\n      if X == 1:\\n          rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]\\n      elif h == 1:\\n          rows = ['c' + '.' * (X-1) + '*' * M]\\n      elif X == 4:\\n              rows = [\\n                  'c.' + '*' * (w-2),\\n                  '..' + '*' * (w-2),\\n              ] + ['*' * w] * (h-2)\\n      elif h == 2:\\n          if X%2 == 1 or X == 2:\\n              rows = None\\n          else:\\n              rows = [\\n                  'c' + '.' * (X/2-1) + '*' * (M/2),\\n                  '.' + '.' * (X/2-1) + '*' * (M/2)\\n              ]\\n      elif X <= 5 or X == 7:\\n          rows = None\\n  \\n      elif X%2 == 0 and X <= w*2:\\n          r = X/2\\n          rows = [\\n              'c' + '.' * (r - 1) + '*' * (w-r),\\n                    '.' * r       + '*' * (w-r),\\n          ] + ['*' * w] * (h-2)\\n  \\n      elif X <= w*3 and (X % 3) != 1:\\n          n = (X+1) / 3\\n          t = X - 2*n\\n          rows = [\\n              'c' + '.' * (n-1) + '*' * (w-n),\\n                    '.' * n     + '*' * (w-n),\\n                    '.' * t     + '*' * (w-t)\\n          ] + ['*' * w] * (h-3)\\n      else:\\n          n = X / w\\n          t = X % w\\n          if t == 1:\\n              rows = (\\n                      ['c' + (w-1) * '.']\\n                  +   ['.' * w] * (n-2)\\n                  +   ['.' * (w-1) + '*']\\n                  +   ['..' + '*' * (w-2)]\\n                  +   ['*' * w] * (h - n - 1)\\n              )\\n          else:\\n              k = 1 if t == 0 else 0\\n              rows = (\\n                      ['c' + (w-1) * '.']\\n                  +   ['.' * w] * (n-1)\\n                  +   ['.' * t + '*' * (w-t)] * (1 - k)\\n                  +   ['*' * w] * (h - n - 1 + k)\\n              )\\n  \\n      if rows:\\n          if R > C:\\n              rows = [\"\".join(row[i] for row in rows) for i in xrange(R)]\\n  \\n          for row in rows:\\n              print row\\n  \\n          assert len(rows) == R\\n          assert len(rows[0]) == C\\n          assert sum(1 for row in rows for col in row if col == '*') == M\\n  \\n      else:\\n          print \"Impossible\"\\n  \\n", "target": "41", "substitutes": {"lines": ["letters", "xs", "ines", "vals", "args", "qs", "ids", "points", "words", "lined", "values", "cells", "lins", "ds", "ses", "elines", "pages", "es", "plugins", "l", "ins", "ls", "breaks", "groups", " Lines", "headers", "posts", "models", "files", "strings", "s", "blocks", "links", "los", "items", "vs", "limits", "runs", "ips", "objects"], "line": ["e", "page", "strip", "d", "name", "cle", "ine", "word", "inline", "str", "lf", "lane", "file", "li", "Line", "v", "lin", "LINE", "source", "nl", "m", "l", "day", "link", "de", "sl", "block", "sel", "c", "split", "cell", "code", "le", "f", "lc"], "count": ["N", "Count", "size", "counter", "id", "num", "len", "coll", "ch", "length", "max", "start", "case", "z", "number", "total", "sum", "q", "limit", "m", "l", "index", "base", "c", "cc", "depth", "x", "call", "y", "found", "code", "con", "b"], "i": ["e", "gi", "si", "ini", "xi", "my", "d", "iq", "mi", "id", "mini", "slice", "p", "j", "I", "inner", "start", "vi", "u", "multi", "li", "pi", "ai", "ui", "uri", "ci", "m", "l", "index", "ii", "ti", "di", "yi", "c", "int", "phi", "x", "y", "iu", "ind", "chi", "eni", "qi"], "R": ["N", "Rh", "U", "RH", "G", "RR", "I", "W", "Rs", "K", "RC", "SR", "RO", "L", "Res", "D", "A", "T", "B", "RS", "S", "CR", "E", "H", "F", "IR", "V", "RM", "GR", "Y", "NR", "Q", "P", "RA"], "C": ["N", "U", "Max", "G", "Ch", "SC", "O", "WC", "I", "W", "Cl", "CM", "Z", "K", "VC", "DC", "CC", "L", "D", "A", "MC", "T", "B", "S", "c", "CR", "E", "H", "AC", "F", "V", "Y", "Q", "P", "Cr"], "M": ["N", "U", "G", "ME", "J", "Me", "O", "I", "MR", "W", "Mass", "MD", "MS", "Z", "CM", "K", "ML", "m", "MN", "L", "D", "A", "MC", "T", "B", "S", "E", "H", "AM", "F", "V", "Y", "Q", "P", "MH", "MM"], "w": ["ws", "Wh", "wb", "hw", "ew", "TW", "wd", "c", "we", "y", "iw", "west", "ww", "word", "width", "z", "W", "aw", "ow", "l", "wa", "wall", "week", "s", "time", "a", "x", "b", "f", "o", "d", " W", "p", "max", "wl", "tw", "v", "rw", "m", "H", "wal", "wave", "Y", "way", "u", "sh", "kw", "q", "win", "work", "wt", "wh", "sw", "g"], "h": ["e", "d", "hi", " H", "ww", "p", "ch", "j", "width", "hh", "max", "HH", "ah", "u", "z", "W", "sh", "ih", "v", "ht", "hw", "hm", "q", "m", "hr", "l", "oh", "wa", "rh", "g", "all", "c", "time", "gh", "H", "a", "uh", "ph", "th", "x", "min", "wh", "y", "b", "f", "o", "bh"], "X": ["N", "WS", "Count", "U", "CH", "RH", "Length", "ID", "XL", "Do", "XP", "J", "Wh", "Time", "O", "PH", "Event", "XXX", "ZX", "I", "Size", "Any", "IX", "TX", "z", "W", "ML", "Z", "CE", "K", "MX", "Right", "TH", " x", "XM", "L", "Cross", "D", "TW", "A", "MC", "T", "HTTP", "WH", "B", "Ex", "S", "Work", "Width", "E", "H", "F", "x", "V", "DX", "WR", "FF", "XY", "Y", "y", "XX", "Q", "P", "MAX", "PE", "FW"], "rows": ["rules", "classes", "heads", "relations", "results", "members", "ews", "events", "ws", "workers", "images", "ids", "works", "Row", "features", "holes", "cases", "errors", "values", "cells", "planes", "ays", "ows", "forms", "pages", "fields", "index", "rooms", "rown", "keys", "breaks", "data", "raw", "views", "groups", "posts", "models", "headers", "frames", "files", "checks", "times", "blocks", "orders", "flows", "items", "rs", "x", "roots", "tracks", "tests", "users", "OWS", "array", "ports", "runs"], "r": ["e", "br", "rr", "d", "fr", "nor", "rc", "p", "j", "ar", "er", "u", "z", "v", "rw", "re", "q", "m", "hr", "l", "rf", "ru", "right", "rh", "g", "ro", "c", "a", "rs", "x", "sr", "nr", "y", "b", "cr", "o"], "n": ["N", "e", "at", "d", "name", "ne", "ns", "num", "nor", "p", "j", "out", "en", "u", "nt", "z", "an", "on", "v", " N", "un", "nn", "q", "m", "l", "ot", "net", "all", "nb", "c", "s", "a", "x", "nc", "y", "b", "f", "no", "o", "g"], "t": ["at", "tt", "e", "N", " T", "d", "ta", "p", "j", "out", "u", "z", "nt", "it", "pt", "ty", "dt", "v", "q", "type", "m", "l", "ot", "T", "tn", "c", "s", "time", "tp", "a", "x", "y", "b", "f", "o", "g", "ts"]}}
{"code": "\\n  '''\\n  Input\\n  The first line of the input gives the number of test cases, T. T lines follow. \\n  Each line contains three space-separated real-valued numbers: C, F and X.\\n  \\n  Output\\n  For each test case, output one line containing \"Case #x: y\", where x is \\n  the test case number (starting from 1) and y is the minimum number of seconds \\n  it takes before you can have X delicious cookies.\\n  \\n  We recommend outputting y to 7 decimal places, but it is not required. \\n  y will be considered correct if it is close enough to the correct number: \\n  within an absolute or relative error of 10^-6. \\n  \\n  Limits\\n  1 <= T <= 100.\\n  \\n  Small dataset\\n  1 <= C <= 500.\\n  1 <= F <= 4.\\n  1 <= X <= 2000.\\n  \\n  Large dataset\\n  1 <= C <= 10000.\\n  1 <= F <= 100.\\n  1 <= X <= 100000.\\n  \\n  \\n  ---Input  \\n  4\\n  30.0 1.0 2.0\\n  30.0 2.0 100.0\\n  30.50000 3.14159 1999.19990\\n  500.0 4.0 2000.0\\n  \\n  ---Output \\n  Case #1: 1.0000000\\n  Case #2: 39.1666667\\n  Case #3: 63.9680013\\n  Case #4: 526.1904762\\n  \\n  '''\\n  \\n  \\n  \\n  \\n  \\n  f = open(sys.argv[1])\\n  def input(): return f.readline().strip();\\n  \\n  def bestTime(C, F, X):\\n      v = 2   #speed of production, cookies/sec\\n      t = 0   #total time of production, sec\\n      while True:\\n          tX = X / v          #time to reach goal at current speed\\n          tC = C / v          #time to buy farm\\n          tXc = X / (v + F)   #time to reach goal after adding farm\\n          if tX <= tC + tXc:\\n              break\\n          t += tC\\n          v += F\\n      t += tX\\n      return t\\n  \\n  \\n  for caseNo in xrange(1, int(input())+1):\\n      C, F, X = map(float, input().split())\\n      print 'Case #%d: %.7f' % (caseNo, bestTime(C, F, X))\\n      \\n  \\n  \\n", "target": "42", "substitutes": {"f": ["e", "cf", "full", "fd", "d", "i", "h", "bf", "p", "lf", "af", "r", "fo", "handler", "file", "t", "tf", "ft", "fb", "ref", "elf", "feed", "w", "m", "n", "l", "rf", "fp", "fs", "ff", "c", "s", "df", "x", "b", "raf"], "C": ["N", "U", "G", "O", "I", "CL", "W", "M", "Z", "K", "VC", "DC", "L", "D", "A", "R", "T", "B", "S", "c", "E", "H", "V", "cycle", "Y", "P"], "F": ["N", "U", "G", "Fs", "J", "O", "I", "W", "M", "Z", "K", "L", "D", "A", "R", "T", "PF", "FM", "B", "E", "H", "V", "Y", "Q", "P"], "X": ["U", "XL", "XP", "IX", "TX", "W", "M", "Z", "K", "D", "T", "Ex", "S", "E", "H", "V", "x", "DX", "FF", "Y", "Q", "P", "XX"], "v": ["e", "i", "p", " V", "vv", "vi", "u", "r", "t", "w", "vd", "q", "m", "n", "l", "c", "time", "sv", "k", "vs", "V", "uv", "b", "o", "version", "g", "tv"]}}
{"code": "\\n  '''\\n  Input\\n  The first line of the input gives the number of test cases, T. T lines follow. \\n  Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).\\n  \\n  Output\\n  For each test case, output a line containing \"Case #x:\", where x is the test case number. \\n  On the following R lines, output the board configuration with C characters per line, \\n  using '.' to represent an empty cell, '*' to represent a cell that contains a mine, \\n  and 'c' to represent the clicked cell. If there is no possible configuration, \\n  then instead of the grid, output a line with \"Impossible\" instead. \\n  If there are multiple possible configurations, output any one of them.\\n  \\n  Limits\\n  0 <= M < R * C.\\n  \\n  Small dataset\\n  1 <= T <= 230.\\n  1 <= R, C <= 5.\\n  \\n  Large dataset\\n  1 <= T <= 140.\\n  1 <= R, C <= 50.\\n  \\n  Sample\\n  ---Input \\n  5\\n  5 5 23\\n  3 1 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  \\n  ---Output \\n  Case #1:\\n  Impossible\\n  Case #2:\\n  c\\n  .\\n  *\\n  Case #3:\\n  Impossible\\n  Case #4:\\n  ......*\\n  .c....*\\n  .......\\n  ..*....\\n  Case #5:\\n  **********\\n  **********\\n  **********\\n  ****....**\\n  ***.....**\\n  ***.c...**\\n  ***....***\\n  **********\\n  **********\\n  **********\\n  \\n  \\n  '''\\n  \\n  \\n  f = open(sys.argv[1])\\n  def input(): return f.readline().strip();\\n  \\n  def genBoards(R, C, M):\\n      for mines in combinations( product(range(R), range(C)), M):\\n          board = [ ['.'] * C + [''] for _ in range(R) ]\\n          for row, col in mines:\\n              board[row][col] = '*'\\n          yield board + [[''] * (C+1)]\\n      pass\\n  \\n  def oneClickSolution(R, C, M):\\n      for bd in genBoards(R, C, M):\\n          minTile = 10\\n          for r in range(R):\\n              for c in range(C):\\n                  if bd[r][c] == '.':\\n                      n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))\\n                      bd[r][c] = `n`\\n                      if n <= minTile:\\n                          minTile = n\\n                          minR, minC = r, c\\n          if minTile < 10:\\n              queue = [ (minR, minC) ]\\n              nOpen = 0\\n              while queue:\\n                  r,c = queue.pop()\\n                  if bd[r][c] == '0':\\n                      for i in -1,0,1:\\n                          for j in -1,0,1:\\n                              if i or j: # we don't add the one we popped back\\n                                  queue.append( (r+i, c+j) )\\n                  if bd[r][c] not in '.*':\\n                      bd[r][c] = '.'\\n                      nOpen += 1\\n              if M + nOpen == R*C:\\n                  bd[minR][minC] = 'c'\\n                  return '\\n'.join( ''.join(row[:-1]) for row in bd[:-1] )\\n  \\n      return 'Impossible'\\n  \\n  \\n  clk = clock()\\n  \\n  for caseNo in xrange(1, int(input())+1):\\n      R, C, M = map(int, input().split())\\n      print >>sys.stderr, caseNo, R, C, M #, oneClickSolution(R, C, M)<>'Impossible'\\n      print 'Case #%d:' % caseNo  \\n      print oneClickSolution(R, C, M)\\n      \\n  print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\\n  \\n", "target": "42", "substitutes": {"f": ["e", "fd", "d", "fn", "h", "bf", "p", "lf", "af", "handler", "fo", "file", "t", "tf", "form", "fb", "v", "io", "feed", "w", "m", "l", "rf", "fp", "fs", "s", "df", "F", "x", "found", "b", "raf", "ef", "fa"], "R": ["N", "Rh", "U", "RH", "G", "Rot", "X", "O", "Row", "RR", "I", "MR", "W", "Rs", "RG", "K", "Ru", "RW", "RO", "SR", "Right", "Re", "Ro", "L", "D", "A", "T", "B", "RS", "S", "BR", "CR", "E", "H", "Br", "F", "V", "RF", "Run", "RM", "GR", "DR", "Y", "NR", "Q", "P", "RA", "Cr", "Range"], "C": ["N", "JC", "Cs", "Count", "U", "G", "Ch", "X", "Cu", "O", "I", "CL", "Size", "CA", "W", "YC", "Column", "CM", "K", "Z", "VC", "DC", "CC", "L", "D", "A", "MC", "T", "Chain", "B", "S", "CR", "E", "H", "F", "CI", "V", "cycle", "CU", "Y", "Q", "P", "Code", "Cr"], "M": ["N", "Mon", "U", "VM", "G", "X", "MI", "O", "I", "MR", "W", "Ms", "NM", "MS", "CM", "m", "MN", "L", "OM", "D", "MC", "T", "FM", "B", "DM", "S", "MB", "E", "H", "MF", "AM", "F", "V", "RM", "Y", "Q", "P", "Mode", "LM"], "mines": ["ines", "mesences", "miners", " minES", "minences", "mesations", "minations", "MinES", "inences", "Minences", "Mines", "minES", "meses", "inations", "mesions", "Miners", "Minations", "minions", "inions", "rosions", "rosers", " miners", "rosES", "roses", " minions", "Minions"], "board": ["d", "room", "deck", "bo", "cart", "word", "boards", "p", "ode", "layout", "channel", "list", "sequence", "flow", "boarding", "ward", "form", "flo", "object", "card", "bar", "box", "feed", "Board", "core", "entry", "ro", "back", "block", "cell", "x", "buffer", "line", "stroke", "code", "b", "array", "o", "control", "menu", "table"], "_": ["self", "__", "p", "q", "all", "k", "x", "g"], "row": ["page", "range", "tr", "id", "num", "rows", "rc", "coll", "Row", "channel", "column", "flow", "ward", "co", "group", "bar", "box", "feed", "w", "uc", "q", "ow", "rank", "entry", "index", "order", "port", "ro", "block", "ack", "key", "cell", "x", "line", "server", "bug"], "col": ["COL", "num", "rows", "act", "coll", "p", "ch", "column", "ct", "cat", "flo", "co", "loc", "pri", "rot", "core", "day", "el", "cl", "fl", "cor", "sel", "ox", "round", "win", "key", "cell", "k", "ol", "th", "x", "line", "min", "y", "cm", "chain", "fc", "ind", "con", "Col"], "bd": ["pd", "cdn", "bind", "bl", "d", "bb", "don", "bot", "cb", "nd", "deck", "fd", "deb", "dc", "online", "bf", "sb", "od", "odo", "ba", "bm", "kk", "dd", "fb", "wb", "sh", "ds", "dan", "ke", "vd", "gb", "td", "BD", "hide", "sd", "fl", "de", "ad", "bi", "md", "cd", "ml", "ff", "hd", "nb", "ande", "bc", "abb", "bin", "bow", "ld", "line", "bs", "db", "ng", "ck", "b", "zb", "gd"], "minTile": [" mintile", "MINCore", "MINTile", " minPixel", "MinCore", "miniPixel", "MINtile", "smallTile", " minImage", " minCore", "maxtile", "smallTable", "minCore", "smallPixel", "miniImage", "MinTile", "smallImage", "miniTile", "maxTile", "MinImage", "Mintile", "mintile", "miniTable", "minTable", "minPixel", " minTable", "minImage", "MinPixel", "maxImage"], "r": ["e", "range", "br", "rr", "rb", "d", "id", "fr", "rc", "h", "p", "ur", "pr", "ar", "dr", "u", "er", "t", "Rs", "v", "lr", "attr", "ir", "re", "w", "q", "vr", "m", "rank", "l", "hr", "rf", "ru", "right", "g", "ro", "s", "kr", "a", "rn", "rl", "k", "rs", "x", "sr", "run", "nr", "b", "rg", "cr", "o"], "c": ["cf", "e", "d", "rc", "center", "h", "ac", "coll", "dc", "p", "ce", "channel", "config", "u", "count", "ct", "z", "t", "cu", "v", "can", "com", "cs", "cur", "w", "uc", "q", "vc", "m", "ci", "l", "xc", "pc", "cc", "s", "cache", "cell", "k", "ec", "x", "course", "nc", "cycle", "y", "code", "sc", "b", "cm", "cr", "cp", "o", "cn", "lc"], "n": ["N", "e", "d", "ne", "ns", "fn", "num", "len", "p", "conn", "u", "z", "nt", "t", "number", "zn", "ni", "v", "nan", "sum", "w", "nn", "m", "np", "l", "network", "pn", "nb", "s", "sn", "rn", "yn", "x", "nc", "min", "y", "b", "cn", "no", "o", "g", "nu"], "i": ["e", "gi", "ini", "si", "xi", "d", "iy", "iq", "h", "p", "fi", "I", "u", "iv", "iii", "zi", "z", "ie", "li", "pi", "ai", "it", "v", "ni", "ui", "io", "q", "m", "ci", "l", "ik", "ij", "ii", "ei", "bi", "ti", "ib", "di", "yi", "int", "a", "ji", "phi", "y", "ri", "iu", "b", "oi", "iw", "o", "ia", "chi", "g", "qi"], "j": ["e", "gi", "br", "ion", "d", "uj", "vision", "h", "J", "p", "ch", "u", "im", "qi", "z", "jl", "jj", "v", "jam", "obj", "q", "oy", "l", "dj", "jp", "ij", "ii", "kj", "adj", "job", "bj", "ja", "jit", "jc", "ji", "k", "x", "y", "aj", "b", "o", "js", "oj"], "minR": ["initM", " minM", "minM", "minr", "initr", "smallR", "diffM", " minr", "Minr", "initC", "MinR", " minRs", "smallC", "diffC", "MinC", "initR", "minRs", "MinRs", "diffR", "smallr", "smallRs", "diffr"], "minC": ["mitL", "minL", "Minc", "mitB", "MinF", "smallN", "mineCR", " minc", " minF", "mineC", "smallF", "mineL", " minN", "minN", " minCR", "minF", "mitCR", " minB", "minc", "smallc", " minL", "smallC", "MinN", "MinC", "minCR", "mineB", "minB", "mitC"], "queue": ["page", "update", "loop", "Que", "event", "free", "id", "Queue", "view", "p", "que", "channel", "list", "en", "config", "sequence", "count", "force", "file", "status", "console", "route", "pool", "group", "q", "stack", "grid", "job", "sync", "batch", "block", "cache", "progress", "use", "end", "parent", "worker", "protected", "buffer", "line", "process", "delay", "db", "ue", "Q", "server", "lock", "menu"], "nOpen": ["nNext", " nDraw", "nCapture", "NOpen", " nCapture", "lnNext", "lnCapture", "NDraw", "nDraw", "lnOpen", "NNext", " nNext", "lnDraw", "NCapture"]}}
{"code": "__author__ = 'Jeffrey'\\n  \\n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\B-small-attempt0.in\"\\n  outFileName = inFileName[ : -2] + \"out\"\\n  \\n  \\n  def parseInput(f):\\n      T = int(f.readline())\\n      L = []\\n  \\n      for i in range(T):\\n          L.append([float(i) for i in f.readline().split()])\\n  \\n      return T, L\\n  \\n  \\n  def calculateWinTime(C, F, X):\\n      R = 2.0 # rate of cookie profit (cookies/s)\\n      totalTime = 0.0\\n      while (X / R >= C/R + X/(R + F)):\\n          totalTime += C / R\\n          R += F\\n      return totalTime + X / R\\n  \\n  \\n  def playGame(T,L):\\n      for i in range(T):\\n          result = calculateWinTime(L[i][0], L[i][1], L[i][2])\\n          yield \"Case #\" + str(i + 1) + \": \" + \"{:0.7f}\".format(result)\\n  \\n  \\n  if __name__==\"__main__\":\\n      iF = open(inFileName, 'r')\\n      T, L = parseInput(iF)\\n      iF.close()\\n  \\n      print(T)\\n      print(L)\\n  \\n      oF = open(outFileName, \"wb\")\\n      for out in playGame(T, L):\\n          print(out)\\n          oF.write(bytes(out + \"\\n\",'utf-8'))\\n      oF.close()\\n", "target": "43", "substitutes": {"__author__": ["__version___", " __version____", "__author____", "__Author____", "__version__", "__Author__", " __author___", "__creator___", " __version__", "__Author___", " __author____", "__author___", " __version___", "__creator____", "__version____", "__creator__"], "inFileName": ["inStreamLine", " inFileNames", "inPlaceNames", "inFileSize", "inputDirName", "inDirPath", "inPlacePath", "inPerNames", "inDirName", "inClassname", "inSourceFileNames", "inClassLine", " inFilename", " inFileLine", "inputDirPath", "inPerLine", "inputDirSize", "inPername", "inFilename", "inSourceFilePath", "inputFileName", "inStreamName", "inStreamNames", "inputDirNames", "inStreamname", "inFilePath", "inSourceFileName", " inClassLine", "inPerName", "inPlaceSize", "inDirNames", " inClassName", "inClassNames", "inClassName", "inSourceFileSize", "inputFileNames", "inDirSize", "inFileNames", " inClassNames", "inPlaceName", "inFileLine", "inputFilePath", " inClassname", "inputFileSize"], "outFileName": ["inDirPath", "outTablePath", "outfileKey", "outTableName", "inDirName", "inDirname", "inFileKey", "outfilename", "outDirKey", "inFilename", "outDirPath", "outfileName", "inFilePath", "outTablename", "outDirName", "inDirKey", "outfilePath", "outFilePath", "outFileKey", "outFilename", "outTableKey", "outDirname"], "f": ["e", "fd", "d", "self", "fr", "fac", "h", "xf", "bf", "p", "input", "af", "r", "fo", "fm", "file", "t", "form", "fb", "tf", "v", "of", "io", "feed", "w", "iter", "sf", "conf", "m", "n", "l", "rf", "fl", "fp", "inf", "fs", "c", "df", "k", "buff", "x", "fe", "arf", "b", "fc", "fen", "g", "ef"], "T": ["N", "U", "Length", "G", "Time", "FT", "I", "LT", "TS", "TB", "W", "Ti", "t", "TA", "M", "Z", "Input", "TH", "GT", "D", "A", "Int", "B", "S", "TT", "INT", "E", "H", "int", "V", "NT", "Y", "Q", "P", "DT"], "L": ["N", "LP", "U", "EL", "UL", "IL", "SL", "LS", "LL", "DL", "LT", "CL", "List", "LO", "FL", "W", "ML", "M", "Z", "K", "LB", "NL", "l", "D", "A", "LU", "B", "LA", "LI", "E", "dL", "V", "OL", "Y", "Li", "Lu", "P", "II", "Long", "BL", "LR", "LIN"], "i": ["e", "gi", "si", "ini", "xi", "ip", "d", "id", "num", "abi", "p", "j", "I", "u", "zi", "z", "r", "gu", "li", "number", "ai", "it", "v", "pi", "t", "io", "n", "m", "l", "ii", "index", "data", "ti", "di", "c", "int", "a", "k", "phi", "x", "iu", "b", "ind", "o"], "C": ["N", "U", "G", "O", "I", "W", "YC", "M", "CM", "K", "D", "MC", "B", "S", "c", "CR", "E", "H", "CI", "V", "CU", "Y", "P", "CT"], "F": ["N", "U", "XL", "G", "Fs", "I", "W", "File", "M", "K", "D", "FM", "FH", "PF", "WF", "E", "H", "V", "x", "RF", "Y", "Q", "P"], "X": ["U", "XL", "XP", "IX", "XXX", "TX", "W", "File", "Z", "Unix", " x", "FX", "Ex", "H", "x", "V", "DX", "FF", "Y", "XXXX", "XX", "Q", "P", "FW"], "R": ["N", "RH", "G", "Time", "O", "RR", "I", "r", "W", "Rs", "M", "Z", "K", "RW", "SR", "D", "JR", "S", "CR", "E", "V", "RF", "RM", "Q", "P"]}}
{"code": "__author__ = 'Jeffrey'\\n  \\n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-small-attempt0.in\"\\n  \\n  outFileName = inFileName[: -2] + \"out\"\\n  \\n  \\n  def parseInput(f):\\n      T = int(f.readline())\\n      L = []\\n  \\n      for i in range(T):\\n          L.append([int(i) for i in f.readline().split()])\\n  \\n      return T, L\\n  \\n  \\n  def calculateOneClick(R, C, M):\\n      size = R * C\\n      if R == 1 or C == 1 and M < size:\\n          return generateWinBoardBaseCase(R, C, M)\\n      elif size - M == 1:\\n          return generateWinBoardBaseCase(R, C, M)\\n      elif size - M >= 4:\\n          return generateWinBoard(R, C, M)\\n      return \"Impossible\"\\n  \\n  def generateWinBoard(R,C,M):\\n      emptySpace = R * C - M - 4\\n      out = \"c\"\\n      if C > 1:\\n          out += \".\"\\n          for i in range(2,C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      if R > 1:\\n          out += '\\n'\\n          out += \".\"\\n          if C > 1:\\n              out += \".\"\\n          for i in range(2,C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      for r in range(2,R):\\n          out += '\\n'\\n          for c in range(C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      return out\\n  \\n  def generateWinBoardBaseCase(R,C,M):\\n      emptySpace = R * C - M - 1\\n      out = \"c\"\\n      if C > 1:\\n          for c in range(1,C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      for r in range(1,R):\\n          out += '\\n'\\n          for c in range(C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      return out\\n  \\n  \\n  def playGame(T, L):\\n      for i in range(T):\\n          result = calculateOneClick(L[i][0], L[i][1], L[i][2])\\n          yield \"Case #\" + str(i + 1) + \":\\n\" + str(result)\\n  \\n  \\n  if __name__ == \"__main__\":\\n      iF = open(inFileName, 'r')\\n      T, L = parseInput(iF)\\n      iF.close()\\n  \\n      print(T)\\n      print(L)\\n  \\n      oF = open(outFileName, \"wb\")\\n      for out in playGame(T, L):\\n          print(out)\\n          oF.write(bytes(out + \"\\n\", 'utf-8'))\\n      oF.close()\\n", "target": "43", "substitutes": {"__author__": ["__authors___", "__version___", "__authors__", " __creator__", "__version__", " __author___", "__creator___", " __creator___", "__author___", "__creator__"], "inFileName": [" inDirPath", "inDirPath", "inFilesName", "outClassUrl", "inStreamPath", "inLinePath", "inPlaceLine", "outClassName", "inPlacePath", "inLineHandle", "inDirName", "inFileHandle", " inDirLine", "outFileUrl", "inStreamUrl", "inDirHandle", " inFileLine", "inLineLine", " inDirName", "inDirLine", " inDirHandle", "inStreamNames", "inStreamName", " inFileHandle", "inClassPath", "inFilesPath", " inFilePath", "inPlaceHandle", "outClassNames", "inFileUrl", "inClassUrl", "inFilePath", "outFileNames", "inFilesNames", "inClassNames", "inLineName", "outFilePath", "inClassName", "inFilesUrl", "inFileNames", "inPlaceName", "inFileLine", "outClassPath"], "outFileName": ["outFullSize", "outDirectoryName", "outDirFile", "outFileFile", "outDirectoryFile", "outDirectoryPath", "outputFileSize", "outputDirPath", "outFullPath", "outputDirName", "outDirPath", "outFileSize", "outputFileName", "outputFilePath", "outFullFile", "outDirectorySize", "outDirName", "outDirSize", "outFilePath", "outputDirFile", "outFullName", "outputFileFile", "outputDirSize"], "f": ["e", "fd", "d", "fr", "h", "xf", "bf", "p", "fi", "aff", "input", "af", "fo", "z", "file", "fb", "form", "t", "stream", "v", "http", "feed", "w", "conf", "m", "l", "rf", "fl", "fp", "inf", "fs", "a", "df", "k", "F", "x", "fe", "arf", "b", "fc", "g", "fa"], "T": ["N", "U", "Length", "G", "X", "Time", "O", "I", "LT", "TS", "TX", "TB", "W", "t", "IP", "TA", "Z", "K", "Port", "GT", "WT", "D", "A", "Int", "B", "Tu", "S", "Len", "TT", "Ts", "TG", "E", "H", "int", "F", "V", "PT", "NT", "Y", "Q", "P", "TI", "RT", "CT", "DT"], "L": ["N", "LP", "EL", " l", "XL", "G", "RL", "IL", "SL", "J", "LS", "LL", "O", "DL", "I", "LT", "CL", "LC", "W", "FL", "ML", "Z", "Line", "K", "LB", "NL", "l", "D", "LU", "B", "We", "S", "LA", "LI", "E", "H", "VL", "F", "V", "dL", "Lu", "Q", "P", "TL", "BL", "LM", "LE", "LR"], "i": ["e", "gi", "si", "il", "xi", "ip", "d", "iq", "id", "h", "p", "j", "ar", "I", "input", "u", "ie", "z", "li", "it", "ai", "ui", "v", "t", "pi", "io", "ir", "q", "n", "ci", "m", "l", "cl", "ii", "index", "ei", "ti", "di", "int", "a", "k", "ic", "x", "iu", "b", "ind", "o", "iw", "g", "lc"], "R": ["N", "Rh", "TR", "AR", "U", "RH", "G", "X", "RE", "J", "O", "RR", "KR", "I", "Role", "MR", "W", "Rs", "Cl", "Range", "K", "RC", "RW", "RO", "SR", "Right", "Re", "Ro", "Res", "D", "A", "ER", "JR", "OR", "B", "RS", "Rec", "S", "BR", "RP", "CR", "E", "H", "Gr", "F", "V", "Run", "DR", "RM", "WR", "GR", "Y", "Ra", "NR", "Q", "P", "RT", "LR", "RA", "RG"], "C": ["N", "CF", "Cs", "Count", "U", "You", "G", "Ch", "X", "Co", "SC", "Cu", "Channel", "O", "WC", "CL", "Size", "I", "CNN", "CA", "There", "W", "YC", "Rs", "NC", "CM", "VC", "K", "CE", "EC", "Cl", "DC", "From", "Custom", "Context", "CC", "Sc", "D", "A", "Case", "MC", "B", "S", "Com", "CV", "Or", "CR", "E", "H", "CS", "CI", "F", "V", "CU", "Y", "Q", "P", "Code", "CT", "Con", "Cr"], "M": ["N", "Mon", "U", "VM", "G", "X", "J", "O", "Min", "I", "Size", "CL", "W", "Ms", "MD", "NM", "MS", "CM", "K", "Z", "MT", "m", "MN", "Mo", "D", "A", "MC", "FM", "B", "DM", "S", "IM", "MB", "E", "H", "MF", "AM", "F", "Man", "V", "RM", "Y", "Q", "P", "Mc", "Mode", "MM", "LM"], "size": ["N", "si", "G", "mini", "content", "capacity", "large", "length", "max", "Size", "sized", "ize", "sh", "W", "number", "z", "sum", "small", "loc", "w", "position", "n", "SIZE", "core", "cl", "m", "six", "S", "empty", "sec", "sn", "member", "case", "shape", "Y", "sc", "cm", "mode", "scale"], "emptySpace": ["execSpread", "EmptyCase", " emptyspace", "EmptySp", "originalspace", "equalSpace", "missingShipping", "activespace", "emptySp", "errorPlace", "errorSpace", "brokenSpace", "emptyService", " emptyService", "openSp", "fullShipping", "openSpace", "Emptyspace", "fullLine", "EmptySpread", "nicCase", "openLine", "originalLine", " emptyRoom", "EmptyShipping", " emptySample", "execSp", "exclusiveSpace", "nicSpace", "emptySpread", "execSpace", " emptySp", "noneSp", "brokenCase", "nicSp", "brokenSp", "exclusiveSample", "emptyRoom", "filledShipping", "EmptySpace", " emptyLine", "originalSp", "equalSp", "exclusiveSp", "nicPlace", "missingSpace", "filledSp", "fullSpace", "nonePlace", "filledSpace", "emptyPlace", "EmptySample", "fullSp", " emptyShipping", "EmptyRoom", "emptyShipping", "openRoom", "noneSand", "originalSpace", "errorSand", "emptySand", "missingSp", "emptyLine", "exclusiveLine", "EmptyService", "emptyspace", "EmptyPlace", "brokenSpread", "noneSpace", "equalService", "execPlace", "emptySample", "errorSp", "emptyCase", "EmptyLine", "brokenPlace", "activeSp", "activeSpace", "EmptySand"], "out": ["name", "outs", "number", "exp", "pool", "io", "obj", "query", "end", "parent", "init", "off", "err", "option", "version", "timeout", "up", "url", "page", "word", "qa", "doc", "z", "bit", "flat", "ext", "w", "again", "n", "all", "token", "call", "window", "o", "copy", "user", "post", "Out", "full", "client", "d", "OUT", "p", "match", "channel", "multi", "static", "t", "file", "co", "response", "sum", "error", "pre", "function", "data", "block", "new", "temp", "key", "this", "diff", "trial", "external", "at", "cmd", "point", "list", "conn", "output", "it", "ref", "part", "string", "script", "ex", "raw", "cache", "lib", "bin", "int", "null", "line", "goal", "no"], "r": ["range", "yr", "rr", "rb", "br", "rc", "h", "p", "ur", "j", "ar", "u", "er", "v", "ra", "ir", "re", "q", "m", "ru", "right", "ro", "kr", "rn", "k", "rs", "sr", "nr", "b", "rg", "err", "cr"], "c": ["e", "cf", "col", "ac", "p", "oc", "ce", "u", "ct", "z", "cat", "cu", "v", "cs", "w", "cy", "q", "n", "ci", "m", "l", "cl", "cd", "pc", "cc", "ic", "k", "ec", "x", "nc", "y", "code", "b", "arc", "cm", "cr", "g", "lc"], "result": ["page", "results", "default", "score", "final", "match", "list", "ret", "response", "output", "res", "card", "source", "dict", "entry", "data", "text", "back", "new", "Result", "success", "cost", "err", "diff", "trial", "RET", "url"]}}
{"code": "\\n  T = int(input())\\n  \\n  for x in range(1, T+1):\\n      (C, F, X) = [float(y) for y in input().split()]\\n      totalsecs = 0\\n      cur_speed = 2\\n      while True:\\n          cur_time = X/cur_speed\\n          new_speed = cur_speed + F\\n          new_time = C/cur_speed + X/new_speed\\n          if new_time < cur_time:\\n              totalsecs += C/cur_speed\\n              cur_speed = new_speed\\n          else:\\n              totalsecs += cur_time\\n              break\\n      \\n      print(\"Case #%d: %.7f\" % (x, totalsecs))\\n", "target": "44", "substitutes": {"T": ["N", "U", "G", "Time", "O", "I", "TS", "W", "t", "M", "Z", "K", "UTC", "L", "WT", "D", "A", "R", "B", "S", "TT", "TC", "time", "E", "H", "V", "Total", "Y", "Q", "P", "CT"], "x": ["xa", "xi", "xt", "xs", "d", "col", "i", "xxxxxxxx", "sex", "step", "patch", "xp", "xf", "p", "xy", "max", "u", "z", "rx", "t", "v", "dx", "n", "index", "ex", "xc", "xxx", "batch", "c", "time", "int", "xx", "ix", "f", "ax"], "C": ["N", "CF", "Cs", "Count", "U", "G", "O", "CL", "I", "CA", "W", "M", "Z", "K", "CM", "CE", "DC", "CC", "L", "D", "A", "R", "B", "S", "c", "E", "CI", "V", "CU", "Y", "Q", "P", "CT"], "F": ["N", "CF", "U", "G", "FD", "O", "I", "W", "M", "Z", "K", " f", "L", "D", "A", "EF", "R", "PF", "B", "S", "c", "CR", "E", "H", "V", "Y", "Q", "P", "f"], "X": ["N", "U", "CH", "XL", "XP", "ZX", "Time", "CL", "TX", "W", "NC", "Z", "CE", "K", "EC", "RC", "DC", "CC", "L", "D", "A", "R", "S", "CR", "E", "H", "UX", "V", "FF", "Y", "Q", "P", "XX", "PE"], "y": ["e", "yr", "ys", "ny", "zy", "my", "yy", "i", "xxxxxxxx", "sky", "yer", "sy", "ye", "yan", " sy", "z", "t", "yz", "ym", " ye", "yl", "cy", " ya", "oy", "n", " ay", "py", " dy", " py", " yo", "yi", "s", "ey", "dy", "yu", "ry", "yo", "ya", "vy", "Y", "gy", "yd", " my"], "totalsecs": [" totalSeces", " totalsectimes", "totallogd", "totalSECes", " totalSecseconds", "totalsecondtimes", " totalsecp", "totallogseconds", "totaliseces", "totalSecp", "totalisecseconds", " totalsecd", " totalSecs", " totalSecd", "totalSECseconds", "totalseconds", "totalsectimes", "totalsqseconds", "totalsecondc", "totalSecS", " totalsecseconds", "totalsqs", "totalSeces", "totalisecc", "totalSecseconds", "totalisecs", "totalsecondseconds", "totallogures", "totalSecd", "totalsecd", "totallogs", " totalSecures", " totalsecS", "totalsqp", "totalsecS", "totalisectimes", " totalSecS", "totalsqps", "totalSECS", "totalSecs", "totalsecc", "totalseces", "totalisecS", " totalsecures", "totalSecps", " totalsecps", "totalsecures", "totalsecseconds", "totalSecures", " totalseces", "totalsecps", "totalsecp", "totalSECs", " totalsecc"], "cur_speed": ["cur__name", "cur__distance", "cur_stream", "cur_name", "curpyspeed", "cur__speed", "cur__time", "cur_sex", " cur_duration", " cur_rate", "curpystream", " cur_power", " cur_stream", "curpyrate", "curpytime", " cur_sex", "cur_power", "new_rate", "new_lane", " cur_name", "cur_lane", "cur_rate", "cur_distance", "cur_duration", " cur_distance"], "cur_time": ["current_speed", "current_times", "current_rate", "cur_rate", "cur_tim", "current_tim", "cur__times", "cur__speed", "cur__time", "current_time", " cur_rate", "cur_times", "cur__tim"], "new_speed": ["new_length", "current_speed", "New_time", "current_rate", "cur_weight", "current_cost", "cur_steam", "New_speed", "new_steam", "New_weight", "new_cost", "new_rate", "new___weight", "new_weight", "new___steam", "current_time", "New_length", "new___time", "new___speed"], "new_time": [" new_rate", "newMyear", "newFtimes", "new_price", "new_value", " new_price", "newMrate", "new_year", "newjrate", "new_times", "newFvalue", "new_rate", "newjtime", " new_year", " new_value", "newFprice", " new_times", "newMtimer", "newFtime", "newMtime", "new_timer", "newjyear", "newjtimer", " new_timer"]}}
{"code": "\\n  T = int(input())\\n  \\n  for n in range(1, T+1):\\n      print(\"Case #%d:\" % n)\\n      (R, C, M) = (int(x) for x in input().split())\\n      dots = R*C - M\\n      if M == 0:\\n          print(\"\\n\".join([\"c\"+(C-1)*\".\"] + (R-1)*[C*\".\"]))\\n      elif dots == 0:\\n          print(\"Impossible\")\\n      elif R == 1:\\n          assert C - M > 0\\n          print(\"c\"+(C-M-1)*\".\"+M*\"*\")\\n      elif C == 1:\\n          assert R - M > 0\\n          print(\"c\\n\"+(R-M-1)*\".\\n\"+M*\"*\\n\", end='')\\n      elif dots == 1:\\n          print(\"\\n\".join([\"c\"+ (C-1)*\"*\"] + (R-1)*[C*\"*\"]))\\n      elif dots > 3:\\n          if (dots == 5) or (dots == 7):\\n              print(\"Impossible\")\\n              continue\\n          if (R == 2) or (C == 2):\\n              if dots%2 != 0 :\\n                  print(\"Impossible\")\\n                  continue\\n              elif R == 2:\\n                  l = int(dots/2)\\n                  print(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\\n                  print(l*\".\"+(C-l)*\"*\")\\n                  continue\\n              elif C == 2:\\n                  l = int(dots/2)\\n                  print(\"c.\")\\n                  print((l-1)*\"..\\n\", end='')\\n                  print(int(M/2)*\"**\\n\", end='')\\n                  continue\\n          (lines, extra) = divmod(dots, C)\\n          temp = []\\n          if (lines >= 2) and (extra != 1):\\n              temp.append(\"c\"+(C-1)*\".\")\\n              temp.extend((lines-1)*[C*\".\"])\\n              temp.append(extra*\".\"+(C-extra)*\"*\")\\n              temp.extend((R-lines-1)*[C*\"*\"])\\n              print(\"\\n\".join(temp))\\n              continue\\n          elif (lines > 2) and (extra == 1):\\n              temp.append(\"c\"+(C-1)*\".\")\\n              temp.extend((lines-2)*[C*\".\"])\\n              temp.append((C-1)*\".\"+\"*\")\\n              temp.append(\"..\"+ (C-2)*\"*\")\\n              temp.extend((R-lines-1)*[C*\"*\"])\\n              print(\"\\n\".join(temp))\\n              continue\\n          elif (lines == 2) and (extra == 1):\\n              temp.append(\"c\"+(C-2)*\".\"+\"*\")\\n              temp.append((C-1)*\".\"+\"*\")\\n              temp.append(3*\".\"+(C-3)*\"*\")\\n              temp.extend((R-3)*[C*\"*\"])\\n              print(\"\\n\".join(temp))\\n              continue\\n          elif lines < 2:\\n              (l, rem) = divmod(dots, 2)\\n              if rem == 1:\\n                  l -= 1\\n                  rem += 2\\n              temp.append(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\\n              temp.append(l*\".\"+(C-l)*\"*\")\\n              temp.append(rem*\".\"+(C-rem)*\"*\")\\n              temp.extend( (R-3)*[ C*\"*\" ])\\n              print(\"\\n\".join(temp))\\n              continue\\n      else:\\n          print(\"Impossible\")\\n  \\n", "target": "44", "substitutes": {"T": ["N", "Length", "G", "X", "TN", "Time", "O", "I", "TS", "TB", "W", "t", "Z", "K", " N", "L", "WT", "D", "A", "B", "S", "TT", "TC", "time", "E", "H", "F", "V", " t", "NT", "Y", "P"], "n": ["N", "e", "d", "ns", "nd", "num", "i", "p", "j", "en", "u", "r", "nt", "z", "t", "v", " N", "na", "un", "nn", "w", "m", "ot", "c", "ln", "s", "a", "Ns", "k", "nc", "y", "b", "f", "o", "g"], "R": ["N", "Rh", "AR", "U", "G", "X", "Co", "RL", "RE", "J", "O", "RR", "MR", "r", "W", "Rs", "K", "RC", "RW", "SR", "RO", "RN", "Re", "L", "D", "A", "ER", "UR", "B", "RS", "Rec", "S", "c", "RP", "CR", "E", "H", "F", "IR", "V", "DR", "rs", "GR", "RM", "Y", "NR", "Q", "P", "RT", "LR", "RA", "Cr", "RG"], "C": ["N", "Count", "Cs", "CF", "U", "JC", "Length", "G", "Ch", "X", "Co", "SC", "Cu", "O", "CL", "CNN", "I", "CA", "LC", "r", "W", "YC", "count", "Cl", "CM", "CE", "VC", "EC", "K", "NC", "RC", "DC", "LINE", "CC", "L", "Sc", "D", "A", "CN", "MC", "B", "CD", "S", "c", "CV", "CR", "E", "H", "CS", "AC", "CI", "F", "V", "CU", "Y", "Q", "P", "Code", "CT", "CCC", "Cr"], "M": ["N", "U", "MO", "Sl", "G", "X", "MI", "J", "O", "LM", "I", "MR", "r", "W", "MD", "MQ", "Z", "CM", "K", "Line", "ML", "SM", "MT", "MX", "m", "MN", "L", "D", "A", "MC", "B", "DM", "S", "MA", "IM", "E", "H", "AM", "F", "V", "RM", "Y", "Q", "P", "MF"], "x": ["e", "xd", "xa", "xs", "xi", "ux", "d", "i", "xxxxxxxx", "X", "h", "xp", "xf", "p", "xy", "j", "u", "z", "r", "rx", "t", "v", "xb", "w", "q", "m", "ex", "xc", "xxx", "wx", "xxxx", "c", "xe", "xx", "y", "b", "f", "ax", "g"], "dots": ["Dotes", "Dumbers", " dumbers", "dotes", "lashes", "sdot", "drots", "bots", "Dugs", " dashes", "DOTS", "dotted", "motes", "mdots", "longs", "dashes", "bugs", " diffs", " dips", " drots", "potted", " dongs", "mdotted", "ddOTS", "Dips", "tots", "ddashes", "indOTS", "didods", "dips", "dOTS", "dists", "Dets", "pOTS", "didumbers", "sdods", "Dots", "mdOTS", "dot", "dott", "sdots", " dott", "indots", "mdot", "tiffs", "Dods", "tOTS", " dists", "ddotted", "tets", " dotted", "mashes", "pots", "tips", "ddots", "dugs", "lotes", "Dotted", "pot", "lOTS", "lots", "sdOTS", "dumbers", " dops", "Dists", "Dops", "didots", "Drots", "dops", " dets", "mots", " dot", "Dot", "bOTS", "Dongs", "sdumbers", "dongs", " dOTS", "dods", "tops", "tot", "dets", "Diffs", "indrots", "mOTS", "diffs", "brots", "indugs", "Dashes", "sdott", "Dott", "didot"], "l": ["e", "il", "d", " L", "i", "h", "pl", "p", "j", "ll", "u", "r", "z", "t", "li", "v", "lin", "ell", "loc", "w", "nl", "m", "L", "el", "ls", "fl", "dl", "sl", "al", "c", "ln", "s", "lc", "ol", "ul", "line", "kl", "lu", "b", "f", "le", "o"], "end": ["size", "stop", "ion", "name", "event", "pos", "id", "offset", "append", "exit", "length", "add", "inner", "start", "en", "ended", "send", "it", "output", "object", "End", "error", "edge", "method", "type", "begin", " End", "entry", "index", "rest", "ad", "enter", "anch", "use", "init", "tail", "set", "est", "ends", "END", "ent", "ending", "post", "then"], "lines": ["N", "size", "letters", "ines", "d", "ns", "i", "rows", "inline", "h", "points", "p", "length", "codes", "z", "levels", "planes", "cases", "cells", "lins", "Line", "Rs", "v", "lin", "LINE", "notes", "comments", "pages", "NL", "log", "ins", "ls", "breaks", " Lines", "models", "zip", "times", "checks", "strings", "c", "s", "blocks", "links", "cycles", "rs", "line", "limits", "ends", "b", "f", "runs", "LR"], "extra": ["e", "size", "origin", "white", "ne", "optional", "args", "plus", "default", "exclusive", "inline", " Extra", "rc", "internal", "regular", "radius", "next", "current", "ras", "skip", "border", "max", "inner", "added", " extras", "fake", "after", "config", "length", "EXT", "aux", "random", "error", "margin", "ext", "special", "magic", "q", "original", "outer", "alpha", "missing", "ex", "order", "data", "di", "zip", "base", "empty", "custom", "line", "other", "second", "needed", "err", "ignore", "background", "Extra", "diff", "area", "info", "external", "wrapper"], "temp": ["full", "size", "white", "edit", "mini", "clean", "unit", "current", "j", "api", "export", "list", "now", "inner", "fake", "let", "holder", "multi", "response", "output", "get", "left", "v", "flat", "note", "partial", "iter", "pre", "stack", "adj", "index", "tree", "body", "zip", "base", "template", "cache", "empty", "key", "init", "test", "buffer", "Temp", "other", "tmp", "err", "tem", "diff", "copy", "options"]}}
{"code": "\\n  numCases = input()\\n  for case in range( 1, numCases + 1 ):\\n    C, F, X = raw_input().split()\\n    C = float(C)\\n    F = float(F)\\n    X = float(X)\\n    time = 0.0\\n    rate = 2.0\\n    \\n    while ( True ):\\n      timeToFinish = X / rate\\n      timeToFarm   = C / rate\\n      farmPayoffTime = C / F\\n  \\n      if timeToFinish < ( timeToFarm + farmPayoffTime ):\\n        time += timeToFinish\\n        break\\n      else:\\n        time += timeToFarm\\n        rate += F\\n  \\n  \\n    output = '{0:0.15f}'.format( time )\\n  \\n    print 'Case #' + str( case ) + ': ' + str( output )\\n", "target": "45", "substitutes": {"numCases": ["numCatches", "numRasing", " numPased", "numPasing", "numCasing", " numRats", "numRats", " numRasing", "numRases", " numRases", "numCased", "numPases", "numScats", " numRatches", "numScases", "numScasing", " numCased", "numCats", "numPats", " numPatches", "numPased", "numRased", " numCats", " numCatches", " numPasing", "numChased", "numPatches", "numChasing", " numPases", "numChases", "numScatches", "numRatches", "numChatches", " numCasing"], "case": ["loop", "name", "event", "id", "num", "i", " trial", "address", "length", "match", "ace", "sequence", "count", "instance", "ase", "cases", "number", "change", "race", "pair", "uc", "position", "core", "Case", "ice", " c", "c", "bc", "cache", "cause", "test", "chance", "catch", "x", "cycle", "line", "result", "call", "phase", " CASE", "code", "cost", "f", "trial", "lc"], "C": ["N", "CF", "Count", "U", "G", "Cu", "Time", "O", "CL", "CNN", "Size", "I", "CA", "W", "M", "CM", "CE", "EC", "DC", "CC", "L", "D", "A", "Case", "R", "MC", "T", "B", "S", "FC", "CO", "c", "CV", "CR", "E", "CI", "V", "CU", "Y", "Q", "P"], "F": ["N", "CF", "GF", "U", "G", "Fs", "FD", "FP", "Fore", "Time", "Field", "DF", "O", "I", "FB", "W", "File", "M", "Z", "K", "Fi", "L", "Family", "D", "FO", "EF", "A", "R", "T", "PF", "FH", "B", "FM", "WF", "FC", "S", "FA", "FE", "FU", "E", "H", "V", "RF", "FF", "Y", "Q", "P", "Far", "f", "FG", "AF", "FW"], "X": ["N", "CF", "U", "XL", "Time", "XP", "IX", "XXX", "CL", "I", "Rate", "TX", "W", "File", "M", "Z", "CE", "K", "MX", "CC", "L", "EX", "D", "A", "R", "T", "FX", "B", "Ex", "S", "FC", "Work", "FE", "CR", "E", "H", "x", "V", "DX", "FF", "XY", "Y", "Q", "P", "XX", "PE"], "time": ["size", "speed", "name", "event", "money", "duration", "activity", "power", "Time", "length", "ime", "ace", "start", "count", "change", "t", "form", "etime", "date", "race", "rice", "trace", "type", "TIME", "sleep", "age", "clock", "live", "data", "times", "c", "depth", "cycle", "x", "line", "delay", "timer", "cost", "f", "frequency", "scale"], "rate": [" trace", "weight", "duration", " Rate", "ime", " duration", "CE", "race", " seconds", "fps", "sleep", "TIME", "seed", "UR", "PF", "FC", "times", "c", "depth", "gain", "delay", "Q", "con", " TIME", "speed", "rule", "FD", "thro", "length", " delay", "count", " age", "write", "root", "feed", "type", "R", "peed", "frac", "FE", "code", "f", " date", "CF", "d", "play", "feature", " beat", "Rate", "BF", "date", "rice", "grade", "live", "data", "rates", "CR", "factor", "Y", "cost", "frequency", "cf", " timeout", " throttle", "power", "unit", " event", "r", "level", " scale", "age", "air", " power", "erate", " frequency", "CV", "use", "dy", "fan", "fee", "grow", "scale"], "timeToFinish": ["timeWillComplete", " timeOfFinish", "timetoEnd", "timeOfEnd", " timeWillDie", "timeWillFarm", "timeWillDie", "timeWillFinish", "timeToComplete", "timeTOFarm", " timeToStart", "timetoComplete", " timeWillFinish", "timeWillEnd", "timetoClose", "timeToDie", " timeOfInstall", "timetoFinish", " timeToComplete", " timeWillClose", " timeWillComplete", " timeOfFarm", "timeTOFinish", "timeOfInstall", "timetoStart", "timetoFarm", "timeTODie", "timetoInstall", "timeTOClose", " timeToDie", " timeToClose", "timeTOComplete", "timeToInstall", " timeToInstall", "timeToStart", "timeToEnd", " timeOfEnd", " timeToEnd", " timeWillStart", "timeWillInstall", "timeWillStart", "timeToClose", "timeOfFinish", "timeWillClose", " timeWillFarm", "timetoDie", "timeTOStart", "timeOfFarm"], "timeToFarm": [" timeOfFinish", "timePleaseForce", " timeFromForest", "timeToForce", "timeFromForce", "timeTOFarm", "timeToForest", "timeTOFan", " timeOfF", " timeToFly", "timeFromFly", "timeOfFan", "timeToFan", "timeFromForest", "timeFromFinish", "timeToF", "timeInFly", "timePleaseForest", "timetoFinish", "timeInFinish", " timeToForest", "timetoForce", " timeOfFarm", "timeTOFinish", " timeToF", "timePleaseFarm", "timetoFarm", "timeInF", "timetoForest", "timeFromFarm", "timePleaseFinish", " timeToForce", "timeOfFly", " timeOfFly", " timeFromFarm", "timeFromF", "timeOfF", "timeInFarm", "timeOfFinish", "timeOfFarm", " timeFromFinish", " timeToFan", "timeToFly", " timeOfFan", " timeFromForce"], "farmPayoffTime": ["farmPaydownSize", "farmWorkwallFile", "farmPayflowTimes", "farmPaydownRate", "farmWorkwallRate", "farmPaywallTime", "farmPayflowSize", "farmPaydownTimes", "farmPayoffFile", "farmPayoffTimes", "farmPaywallRate", "farmWorkwallTime", "farmPayupTimes", "farmPayupSize", "farmPayonFile", "farmPayupTime", "farmPayoffSize", "farmPayonTime", "farmPayoffRate", "farmPayonRate", "farmPaywallFile", "farmWorkoffTime", "farmPayflowTime", "farmWorkoffRate", "farmPaydownFile", "farmWorkoffFile", "farmPaydownTime"], "output": ["update", "stop", "module", "event", "duration", "name", "Output", "unit", "exit", "address", "channel", "complete", "input", "out", "display", "config", "sequence", "response", "number", "history", "console", "write", "status", "object", "file", "string", "example", "log", "function", "expression", "value", "data", "job", "text", "result", "message", "wave", "run", "cost", "frequency", "control", "mode", "reason"]}}
{"code": "\\n  def DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines ):\\n    x = []\\n    numSpaces = 0\\n    numMines = 0\\n  \\n    gridRows = max( R-2, 0 )\\n    gridCols = max( C-2, 0 )\\n  \\n    for r in xrange( 0, R ):\\n      x.append( [] )\\n      for c in xrange( 0, C ):\\n        x[ r ].append( '.' )\\n        numSpaces += 1\\n  \\n    if gridMines > 0:\\n      for r in xrange( 0, gridRows ):\\n        if numMines >= gridMines:\\n          break;\\n        for c in xrange( 0, gridCols ):\\n          x[ r ][ c ] = '*'\\n          numMines += 1\\n          numSpaces -= 1\\n          if numMines >= gridMines:\\n            break;\\n  \\n    for r in xrange( 0, R ):\\n      if sideMines <= 0:\\n        break\\n      for c in xrange( gridCols, C ):\\n        x[ r ][ c ] = '*'\\n        numMines += 1\\n        numSpaces -= 1\\n        sideMines -= 1\\n        if sideMines <= 0:\\n          break\\n  \\n    for c in xrange( 0, C ):\\n      if bottomMines <= 0:\\n        break\\n      for r in xrange( gridRows, R ):\\n        x[ r ][ c ] = '*'\\n        numMines += 1\\n        numSpaces -= 1\\n        bottomMines -= 1\\n        if bottomMines <= 0:\\n          break\\n      \\n    x[ R - 1][ C - 1 ] = 'c'\\n    \\n    if numMines != M and ( R * C ) - M != 1:\\n      print \"ERROR!!!!!!!!!!!!!!!!!!!!!!!!\"\\n      print ( R * C ) - M\\n  \\n  \\n    o = \"\"\\n  \\n    if Flip:\\n      for c in xrange( 0, C ):\\n        for r in xrange( 0, R ):\\n           o += x[ r ][ c ]\\n        o += '\\n'\\n    else:\\n      for r in xrange( 0, R ):\\n        for c in xrange( 0, C ):\\n           o += x[ r ][ c ]\\n        o += '\\n'\\n  \\n    return o[:-1] #strip the extra newline\\n  \\n  \\n  \\n  \\n  numCases = input()\\n  for case in xrange( 1, numCases + 1 ):\\n    R, C, M = [int(x) for x in raw_input().split()]\\n  \\n    Output = None\\n  \\n    Flip = C > R\\n    if Flip:\\n      temp = R\\n      R = C\\n      C = temp\\n  \\n    NonMines = ( R * C ) - M\\n    if ( NonMines == 0 ):\\n      Output = \"Impossible\"\\n    elif ( C == 1 ):\\n      gridMines = 0\\n      extraMines = M - gridMines\\n      Output = DrawMines( R, C, M, Flip, gridMines, extraMines, 0 )\\n    elif ( NonMines == 2 or  NonMines == 3 ):\\n      Output = \"Impossible\"\\n    else:\\n      maxGridCols = max( 0, C - 2 )\\n      maxGridRows = max( 0, R - 2 )\\n      gridMines = min( M, maxGridCols * maxGridRows )\\n      extraMines = M - gridMines\\n      extraPairs = ( extraMines + 1 ) / 2\\n      extraPairsSide = max( min( extraPairs, maxGridRows - 1 ), 0 )\\n      extraPairsBottom = max( min( extraPairs - extraPairsSide, maxGridCols - 1 ), 0 )\\n      safeExtraPairs = extraPairsSide + extraPairsBottom\\n      blockingPairsSide = max( min( extraPairs - safeExtraPairs, 1 ), 0 )\\n      blockingPairsBottom = max( min( extraPairs - blockingPairsSide - safeExtraPairs, 1 ), 0 )\\n      blockingPairs = blockingPairsSide + blockingPairsBottom\\n      totalPairs = safeExtraPairs + blockingPairs\\n  \\n      \\n      if ( gridMines > 0 and extraMines % 2 != 0 and blockingPairs == 0 ):\\n        extraMines += 1\\n        gridMines -= 1\\n  \\n      if ( NonMines == 1 ):\\n        if extraMines % 2 != 0:\\n          extraMines += 1\\n        blockingPairsSide += 1\\n        blockingPairsBottom += 1\\n      \\n      if extraMines % 2 == 0:\\n        sideMines = 2 * ( extraPairsSide + blockingPairsSide )\\n        bottomMines = 2 * ( extraPairsBottom + blockingPairsBottom )\\n        Output = DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines )\\n      else:\\n        Output = \"Impossible\"\\n  \\n    output = \"\\n\" + Output\\n    print 'Case #' + str( case ) + ': ' + str( output )\\n", "target": "45", "substitutes": {"R": ["N", "Rh", "U", "RH", "G", "X", "RL", "J", "RE", "Row", "RR", "MR", "W", "Rs", "Range", "K", "RC", "RW", "RO", "SR", "Right", "L", "D", "A", "ER", "JR", "T", "B", "RS", "S", "BR", "RP", "CR", "E", "H", "IR", "F", "V", "DR", "GR", "RM", "WR", "Y", "Ra", "NR", "Q", "P", "LR", "RA", "RG"], "C": ["N", "JC", "Cs", "U", "G", "Ch", "X", "SC", "Co", "Cu", "O", "COR", "CL", "I", "CNN", "CA", "W", "YC", "CM", "VC", "EC", "K", "CE", "Z", "RC", "DC", "CP", "CW", "CC", "L", "Sc", "D", "A", "CN", "T", "MC", "B", "S", "CV", "CR", "E", "H", "CS", "AC", "F", "CI", "V", "CU", "Y", "Q", "P", "CT", "Cr"], "M": ["N", "U", "G", "X", "MI", "O", "I", "MR", "W", "CM", "Z", "MT", "m", "n", "L", "MN", "Mo", "D", "A", "MC", "T", "B", "DM", "S", "MB", "E", "H", "F", " m", "V", "RM", "Y", "Q", "P", "Mode", "MM"], "Flip": ["flIP", " FlIP", "flipping", " Flop", "Clipping", " Flipping", "Flide", "Flipping", "flide", "FLIP", "flip", "FLide", " Flide", "Flop", "FlIP", "FLip", "FLop", "flop", "Clip", "Clop", "ClIP"], "gridMines": ["numRines", "gridMine", "numRanes", "gridMined", "numMains", "gridVains", "gridMains", "gridMizes", "numMine", "numBine", "numLains", "gridLains", "numLanes", "gridRines", "layoutCains", "mainMines", "numRains", "gridLine", "gridRined", "gridWales", "gridDined", "gridPlanes", "gridCines", "gridRiners", "gridLined", "gridDines", "gridNining", "gridWines", "layoutMains", "mainManes", "gridCizes", "mainWanes", "gridPlines", "gridLanes", "numBanes", "gridRains", "layoutMizes", "gridVines", "numRine", "gridWining", "layoutCanes", "numLines", "numBines", "gridDains", "gridNines", "layoutMines", "groupRined", "layoutCizes", "gridNales", "groupMiners", "mainWales", "gridManes", "numManes", "mainWining", "mainMining", "gridVanes", "gridLiners", "gridPlining", "gridMiners", "groupRines", "mainWines", "groupMains", "groupMined", "gridCanes", "layoutCines", "gridNanes", "gridMales", "gridVizes", "gridWanes", "gridMining", "layoutManes", "gridDiners", "gridCains", "groupRains", "gridPlales", "numLine", "mainMales", "numBains", "gridLizes", "gridLines", "groupRiners", "groupMines"], "sideMines": [" sideLanes", "sideGodes", "sideMains", "sideMiners", "sideMails", "sideManes", "sideGine", "sideMasks", "rightMsasks", "bottomMizes", "sideMsasks", "rightMines", "bottomRiners", "sideNines", "siteMices", "sideRizes", " sideLales", "sideLasks", "sideLales", "sidemines", "siteMines", "sideMine", "sideLanes", "bottomRizes", " sideMales", "sideGines", "sideNices", "bottomRines", "sideLines", "siteMains", "rightMasks", "sideMices", "sideMoles", "sideDiners", "sideMsizes", "sideModes", " sideLine", "bottomMoles", "sideLine", "rightMsines", "sidemices", "sideMsoles", "sideLodes", "sideDines", "sideRine", "rightMsodes", "sideDizes", "sideRines", "sideRoles", "sideMales", "sideNails", "rightMsine", "sideRiners", "sideMizes", "sidemains", "sidemails", "sideNains", "sideMsiners", "siteMails", "sideDoles", " sideManes", "sideMsines", " sideLines", "sideGasks", "sideRales", " sideMine", "sideRanes", "rightModes", "sideMsodes", "sideMsine", "rightMine", "bottomMiners", "bottomRoles"], "bottomMines": ["leftMsined", "bottommizes", "sideMains", "reverseMizes", "sideManes", "bottomBipes", "bottomMizes", "bottomMoons", "bottomVains", "bottommines", "reversemizes", "bottomMales", "bottomDemines", "leftMsains", "bottomMsains", "reverseMined", "bottomMetanes", "bottomMined", "sideLains", "leftMsales", "reverseMoons", "bottomVined", "bottomSined", "sideLines", "reversemoons", "bottomChains", "sideMices", "bottomVines", "bottomChined", "bottomMipes", "leftMsines", "sideBines", "bottomSizes", "bottommices", "bottomPined", "bottomVices", "bottomBanes", "reversemined", "bottommoons", "bottomMetices", "leftMines", "sideMipes", "bottomLains", "bottomBices", "bottomSines", "bottomChines", "bottomChales", "bottomLices", "bottomLales", "sideMined", "sideBices", "leftMales", "sideLices", "bottomDemices", "bottomMains", "reversemines", "leftMined", "sideLined", "bottommains", "bottomDemipes", "bottomMetines", "bottomPizes", "bottomMsined", "bottomBines", "bottomPines", "bottomDemanes", "sideBanes", "bottomMices", "reverseMines", "bottomLined", "bottomSoons", "bottommined", "leftMains", "sideBipes", "bottomMsines", "bottomPoons", "bottomManes", "bottomMetipes", "bottomLines", "bottomMsales"], "x": ["e", "xs", "xt", "xi", "d", "ux", "plus", "px", "X", "content", "h", "xp", "view", "p", "fx", "xy", "xml", "list", "xes", " X", "u", "case", "image", "config", "z", "rx", "t", "tx", "cross", "change", "co", "v", "on", "w", "q", "m", "n", "l", "index", "ex", "wa", "data", "xc", "wx", "php", "work", "xe", "create", "python", "int", "pe", "ic", "k", "xx", "ix", "y", "code", "b", "array", "f", "ax", "draw", "g"], "numSpaces": ["numPlices", "NUMSpacing", "numFacing", "sumspacing", "NUMSpaces", "numspaces", "numSPacing", "numChans", "numPays", "numPlacements", "sumSpares", "numspays", "numPlines", "numPices", "numSPans", "numLans", " numPans", "numSpacing", "NumSpacing", " numPacing", "NUMspaces", " numSpays", "sumSpaces", "NUMspacements", "numSPices", "numPlace", " numPays", "sumSpices", "numChaces", "numChines", "numspices", "numspacing", " numPines", "NUMSpace", "numPans", "numSpines", "sumspares", " numPaces", "numLares", "numspace", "numSpace", "NUMSpacements", "numChace", "sumspaces", " numSpines", "numLacing", "numFays", "numspines", "numPacing", "numSpices", "numPlaces", "numSpares", "NUMspace", "NumSPans", "sumspices", "numPlans", "NUMspacing", "numFines", "NumSpaces", "sumSpacing", "numSpacements", "numPlares", " numSpans", "numSPaces", "numChacing", "numLices", "numLaces", "numSpays", "numPlacing", "NumSpices", "numPines", "NumSpans", "numspacements", "numspares", "NumSPaces", "NumSPices", "numChacements", "NumSPacing", "numFaces", " numSpacing", "numSpans", "numPaces"], "numMines": ["numLians", "NUMDanes", "NumLine", "numDiners", "numPine", "NumPine", "numMains", "numPiners", "NumLains", "nrDines", "numMites", "numMipes", "NUMDiners", "nummains", "nummine", "numMine", "numLains", "NUMMines", "numLanes", "umMines", " numLine", "umDains", "numTains", "NumMines", "numDins", "numRemins", "numLins", "umDine", "umDines", "numMiners", "NumPites", "numTine", "umMinks", "numLipes", "numPites", "numLined", "numReminers", "numChines", "numChine", "numPails", "NumMites", "NumLians", "NumMians", "numPanes", "numTines", "NUMManes", "numWine", "numDines", " numMails", "numMined", "numWanes", "NUMMiners", "numChians", " numLails", " numLains", "numDinks", " numMains", "NUMDine", "umDinks", "nrMipes", " numMine", "nrDipes", "nrMins", "numLines", "numWined", "nummails", "NumPines", "umMains", "numLites", "numRemipes", "numChains", "nrMines", "numRemines", "numFanes", "NumLined", "numFine", "NumLines", "numManes", "numMails", "numPined", "numTites", "numPinks", "numDine", "NumMine", "numLinks", "numDains", "NumManes", "NUMMine", "numFines", "NUMDines", "numDipes", "numLails", "numLiners", "numPains", "umMine", "numMinks", " numLines", "NumPains", "nrMiners", "nummines", "numMians", "numLine", "numWines", "nrDins", "numDanes", "numFiners", "nrDiners", "NumMined", "nummians", "numMins", "NumLanes", "numPines", "NumMains"], "gridRows": ["gridTaces", " gridRhows", "gridRaces", "gridRsows", "gridRhores", "gridLrows", "numRanks", "gridFrows", "numRaces", "numLrows", "gridMs", "numLores", " gridROWS", "gridRsOWS", "gridRsoles", "numROWS", "gridRhOWS", "gridLOWS", "gridRs", "gridRss", " gridRs", "gridRhs", "gridLows", "numLOWS", " gridRoles", "gridRrows", " gridRholes", "gridRoles", "gridRanks", "gridLores", "numRows", "gridLaces", "gridFows", "gridRhows", "gridRores", "numLaces", "gridTrows", " gridRhs", "gridMoles", "gridMrows", " gridRhOWS", "gridMOWS", "gridRhrows", "gridMores", "gridTows", "gridMows", "gridRholes", "numRrows", "numLanks", "gridTanks", "gridFaces", "numRores", "numLows", "gridFanks", "gridLanks", "gridROWS"], "gridCols": ["hardCOLns", "manColses", "gridColumns", "gridcolgs", "gridVertgs", "gridcold", "hardCold", "gridVertths", "manCOLs", "gridCOLn", "gridColumnns", "gridCOLths", "gridCOLses", "gridColses", "gridColn", "gridColths", "hardCOLs", "gridColgs", "manColths", "hardColle", "hardCOLle", "manCOLses", "gridcolths", "gridCOLs", "gridColle", "hardCOLn", "gridCOLns", "manCols", "manCOLths", "gridCOLgs", "gridColumnle", "gridColumnn", "gridCold", "gridColns", "gridcolns", "manColgs", "hardCols", "manCOLgs", "gridcolle", "gridCOLd", "gridVerts", "gridVertses", "gridcols", "hardColn", "gridColumnd", "gridcoln", "gridCOLle", "gridcolses", "hardCOLd", "hardColns"], "r": ["e", "range", "yr", "rr", "rb", "br", "d", "fr", "i", "rc", "h", "p", "pr", "ur", "j", "gr", "ar", "rm", "oc", "dr", "u", "er", "z", "ver", "t", "v", "lr", "ir", "re", "cur", "w", "q", "m", "n", "l", "rf", "resource", "ru", "right", "g", "ro", "s", "ner", "a", "rn", "k", "rs", "rd", "sr", "nr", "run", "y", "b", "rg", "f", "err", "cr", "rar"], "c": ["cf", "e", "d", "col", "name", "id", "i", "rc", "h", "ac", "dc", "p", "ur", "ch", "ar", "ce", "u", "count", "ct", "z", "t", "cat", "co", "v", "cu", "rec", "ir", "cs", "cur", "w", "uc", "type", "q", "m", "n", "ci", "l", "cl", "cc", "s", "cache", "unc", "a", "rn", "k", "ec", "y", "code", "sc", "cm", "b", "f", "arc", "cr", "cp", "fc", "cn", "g", "lc"], "o": ["e", "po", "d", "ano", "oo", "i", "bo", "h", "lo", "p", "O", "so", "ooo", "out", "go", "auto", "u", "t", " i", "co", "v", "object", "io", "error", "mo", "obj", "ho", "m", "n", "l", "os", "ino", " yo", "ro", "one", "vo", "a", "yo", "k", "oid", " m", "off", "ando", "y", "to", "do", " O", "b", "no", "f"]}}
{"code": "\\n  def oneMoreFarm(C, F, nFarms):\\n  \treturn C/(2.0 + nFarms*F)\\n  \t\\n  \\n  \\n  inputFileName = sys.argv[1]\\n  \\n  f = file(inputFileName)\\n  fout = file(\"output.txt\", \"w\")\\n  \\n  T = int(f.readline().strip())\\n  \\n  for case in xrange(T):\\n  \\n  \tdata = f.readline().split()\\n  \tC = eval(data[0])\\n  \tF = eval(data[1])\\n  \tX = eval(data[2])\\n  \\n  \ttmin = X/2.0\\n  \tfoundMin = False\\n  \\n  \tS = 0\\n  \tnFarms = 0\\n  \\n  \twhile not foundMin:\\n  \t\tnFarms += 1\\n  \t\tS += oneMoreFarm(C, F, nFarms - 1)\\n  \t\tt = S + X/(2.0 + nFarms*F)\\n  \t\tif t < tmin:\\n  \t\t\ttmin = t\\n  \t\telse:\\n  \t\t\tfoundMin = True\\n  \\n  \tfout.write(\"Case #%d: %.7f\\n\" %(case + 1, tmin))\\n", "target": "46", "substitutes": {"C": ["N", "CF", "Cs", "JC", "U", "G", "Ch", "Co", "Cu", "O", "CL", "CNN", "I", "CA", "W", "M", "Cl", "CM", "CE", "EC", "K", "DC", "CC", "L", "D", "Case", "A", "R", "B", " c", "c", "E", "H", "CI", "V", "CU", "Y", "Q", "P", "CT"], "F": ["Full", "N", "CF", "U", "UL", "G", "Fs", "FD", "DF", "OF", "O", "If", "FB", "W", "File", "M", "FER", "Fi", "L", "D", "FO", "EF", "PF", "FM", "B", "FH", "WF", "FA", "Feed", "FE", "E", "H", "Fine", "V", "FF", "FILE", "Y", "ELF", "Q", "Far", "P", "FG", "MF", "AF", "Fe"], "nFarms": ["nFarters", "nMarms", "nPFarming", "nPakers", "nPharming", "nFakers", "nDarming", "nPFars", " nFarters", " nPFakers", "pFarm", " nFarm", "nfarming", " nPFarms", " nFares", "pFarms", "pFolds", "nfarms", " nPFers", "nAfarm", "nPFaves", "pFarming", " nfarming", " nFrees", "nPers", "nFarmarm", " nFakers", "nWares", "nFarmares", " nPFaves", "nFares", "nAfarms", "nDarms", "nFsarms", "nFsakers", "nFarm", "nFsaves", "nMarm", "NFarmares", "nAllarm", "NFarming", " nFarming", " nPFarm", "NFarmarming", "nAfarming", " nFars", "nFars", "nMares", "nPFarms", " nfarm", "NFarms", "nAllars", "nPharms", "NFarm", " nfars", "nFolds", "nWarms", "NFares", "pfolds", "nPaves", "NFarmarm", "nPFrees", " nFers", "nParms", "nFarmarming", "nPFarm", "nMarming", "nPFers", " nPFrees", "nfolds", "nFaves", "nFrees", "pfarming", " nfares", "nfarters", "nfars", "nFarmarms", "pfarm", " nfarms", "nAllarms", "nPFares", "nDarm", "nFers", " nPFarming", "nAllarters", "nWarming", " nfarters", "nFsers", "nfares", "nfarm", "nPFarters", "nAfolds", "nPharm", "nFarming", "nfrees", "nPhrees", "nWarm", "nPFakers", "nDolds", "pfarms", " nFaves", "NFarmarms"], "inputFileName": ["inputFilenameEnd", "sourcefileName", "inputDirName", "inputFullSize", "inputfileEnd", "inputFilenameHandle", "sourceFileHandle", "inputfileHandle", "inputFilesEnd", "sourcefileEnd", "outputFileDir", "inputfileNames", "inputFilenameName", "outputFileSize", "inputDirPath", "sourcefileNames", "inputFilesNames", "inputFilenameNames", "inputFileDir", "inputDirSize", "inputClassPath", "inputFullName", "sourceFileNames", "outputDirPath", "inputClassSize", "outputDirName", "inputClassName", "inputClassDir", "inputFileEnd", "outputFileName", "outputDirDir", "outputFilePath", "inputFullDir", "sourceFileEnd", "inputFileHandle", "sourceFileName", "inputfileName", "inputFilesHandle", "inputFileSize", "inputFilesName", "inputFileNames", "sourcefileHandle", "inputFullPath", "inputDirDir", "inputFilePath", "outputDirSize"], "f": ["e", "cf", "fd", "d", "fr", "i", "fn", "h", "p", "input", "u", "af", "z", "fo", "file", "tf", "form", "fb", "v", "io", "feed", "w", "log", "m", "l", "fp", "inf", "fast", "fs", "c", "s", "df", "x", "fe", "b", "g"], "fout": ["fagain", "fileagain", "Ffile", "Foutput", "touts", "filein", "ffile", "fouts", "filefile", "toutput", " fagain", " foutput", " fin", "Fin", "fileout", " ffile", "Fout", "Fagain", "fin", "Fouts", " fouts", "tout", "tin", "foutput"], "T": ["N", "Length", "G", "TN", "J", "Time", "O", "I", "TS", "W", "TA", "M", "Z", "K", "TH", "L", "WT", "D", "A", "TT", "E", "H", "V", "Total", "NT", "Y", "Q", "P", "CT", "DT"], "case": ["Test", "size", "name", "id", "shift", "i", "num", "slice", "me", "section", "length", "match", "ce", "ace", "start", "sequence", "ie", "ase", "cases", "number", "CE", "ASE", "row", "rice", "loc", "position", "SE", "Case", "ice", " c", "c", "use", "time", "end", "test", "shape", "x", "line", "USE", "code", "trial", "se"], "data": ["e", "results", "d", "fail", "pos", "step", "slice", "p", "series", "list", "complete", "input", "start", "config", "change", "response", "output", "file", "dd", "v", "object", "DATA", "group", "string", "na", "parse", "div", "Data", "sample", "n", "dat", "function", "missing", "ad", "text", "body", "da", "batch", "block", "c", "style", "s", "split", "end", "call", "message", "line", "result", "lines", "load", "info"], "X": ["N", "U", "Length", "XL", "G", "XP", "O", "IX", "CL", "Size", "TX", "W", "IP", "M", "Z", "CC", "L", "D", "R", "ex", "Ex", "Width", "E", "H", "SS", "x", "V", "DX", "FF", "Y", "Q", "P", "XX", "PE", "CT"], "tmin": ["TMin", "ttmin", "dtpos", "ttMin", "tfin", "fmax", "ymax", "tfmax", "fMin", "tonly", "dtMin", "yai", "ttpos", "fstart", "ttonly", "Tmax", " tin", "dtonly", "tpos", "tMin", "dtmin", "tlimit", "tai", " tlimit", "Tlimit", " tmax", "Tmin", " tai", "tfmin", "ymin", "ylimit", "tmax", "Tpos", "fmin", "tstart", "Tai", "Tonly", "fin", " tMin", "tfstart", "tin", " tstart"], "foundMin": ["foundMax", "FoundMax", " Foundmin", "foundMini", "findingMin", "requiredMin", "Foundmin", "FoundMini", "requiredmin", " foundSmall", "requiredMini", "leftMIN", "findingmin", "FoundMin", "foundSmall", "leftMini", "FoundMIN", " FoundMIN", " foundMini", " foundMIN", " foundMax", "foundmin", "requiredMIN", "leftMax", "leftMin", "findingSmall", "foundMIN", " FoundMin", " foundmin", " FoundSmall", "findingMIN"], "S": ["N", "WS", "U", "Sample", "G", "O", " s", "I", "Size", "TS", "SI", "W", "M", "Z", " N", "SE", "L", " SS", "D", "Case", "A", "R", "ss", "B", " SF", "s", "Si", "H", "CS", "DS", "SS", "V", "Y", "NS", "SA", "Q", "P", "Socket", "Part"], "t": ["at", "tt", "e", "xt", "d", "i", "ta", "tz", "p", "TS", "u", "ct", "r", "nt", "M", "total", "dt", "v", "tu", "w", "m", "n", "l", "ot", "ti", "rt", "te", "c", "s", "temp", "tc", "E", "tp", "wt", "int", "test", "x", "y", "tmp", "P", "b", "txt", "ts"]}}
{"code": "\\n  def transpose(result, R, C):\\n  \tresultSplitted = result.split(\"\\n\")\\n  \taux = R*[\"\"]\\n  \tfor i in xrange(R):\\n  \t\tfor j in xrange(C):\\n  \t\t    aux[i] += resultSplitted[j][i]\\n  \t\taux[i] += \"\\n\"\\n  \tresult = \"\"\\n  \tfor item in aux:\\n  \t\tresult += item + \"\\n\"\\n  \treturn result.strip()\\n  \\n  \\n  inputFileName = sys.argv[1]\\n  \\n  f = file(inputFileName)\\n  fout = file(\"output.txt\", \"w\")\\n  \\n  T = int(f.readline())\\n  \\n  for case in xrange(T):\\n  \tdata = f.readline().strip().split(\" \")\\n  \tR = int(data[0])\\n  \tC = int(data[1])\\n  \tM = int(data[2])\\n  \\n  \tresult = \"\"\\n  \\n  \tx = min(R,C)\\n  \ty = max(R,C)\\n  \\n  \tif M > (y - 2)*x and M != y*x - 1:\\n  \t\tN = M - (y-2)*x\\n  \t\tif N%2 == 1 or y*x - M == 2:\\n  \t\t\tresult = \"Impossible\"\\n  \tif result != \"Impossible\":\\n  \t\ti = 0\\n  \t\twhile M > 0: # 2\\n  \t\t\tif i < y - 2:\\n  \t\t\t\tif M >= x:\\n  \t\t\t\t\tresult += x*\"*\" + \"\\n\"\\n  \t\t\t\t\tM -= x\\n  \t\t\t\t\ti += 1\\n  \t\t\t\telif M <= x - 2:\\n  \t\t\t\t\tresult += M*\"*\" + (x - M) * \".\" + \"\\n\"\\n  \t\t\t\t\tM = 0\\n  \t\t\t\t\ti += 1\\n  \t\t\t\telif i + 2 < y - 1:\\n  \t\t\t\t\tresult += (M-1)*\"*\" + (x - M + 1) * \".\" + \"\\n\" + \"*\" + (x-1)*\".\" + \"\\n\"\\n  \t\t\t\t\tM = 0\\n  \t\t\t\t\ti += 2\\n  \t\t\t\telse:\\n  \t\t\t\t\tresult = \"Impossible\"\\n  \t\t\t\t\tbreak\\n  \t\t\telse:\\n  \t\t\t\tif M%2 != 0:\\n  \t\t\t\t\tresult += x*\"*\" + \"\\n\"\\n  \t\t\t\t\tresult += (x-1)*\"*\" + \"c\"\\n  \t\t\t\telse:\\n  \t\t\t\t\tn = M/2\\n  \t\t\t\t\tresult += n*\"*\" + (x-n)*\".\" + \"\\n\"\\n  \t\t\t\t\tresult += n*\"*\" + (x-n-1)*\".\" + \"c\"\\n  \t\t\t\tM = 0\\n  \t\t\t\ti += 2\\n  \t\t\t\t\t\\n  \t\twhile i <= y - 1 and result != \"Impossible\":\\n  \t\t\tif i == y - 1:\\n  \t\t\t\tresult += (x-1)*\".\" + \"c\"\\n  \t\t\telse:\\n  \t\t\t\tresult += x*\".\" + \"\\n\"\\n  \t\t\ti += 1\\n  \t\\n  \tif R < C and result != \"Impossible\":\\n  \t\tresult = transpose(result, R, C)\\n  \\n  \tfout.write(\"Case #%d:\\n%s\\n\" %(case + 1, result))\\n", "target": "46", "substitutes": {"result": ["page", "results", "figure", "event", "default", "compl", "RESULTS", "content", "final", "package", "view", "current", "product", "match", "ret", "out", "input", "exit", "config", "sequence", "r", "response", "output", "status", "number", "report", "res", "root", "summary", "string", "error", "re", "example", "source", "method", "ULT", "replace", "valid", "resource", "function", "expression", "value", "text", "job", "runner", "cache", "new", "description", "df", "Result", "test", "success", "catch", "null", "buffer", "message", "this", "transform", "err", "array", "Results", "answer", "search", "reason", "table"], "R": ["range", "Rh", "U", "RH", "Max", "G", "Cor", "X", "Rank", "J", "RD", "RR", "I", "r", "W", "Rs", "Rad", "root", "row", "RC", "RW", "RO", "RN", "SR", "L", "D", "A", "JR", "ru", "B", "RS", "S", "CR", "E", "H", "Result", "F", "V", "DR", "RM", "RF", "Y", "Ra", "NR", "Q", "P", "array", "RA", "RG"], "C": ["JC", "Cs", "U", "Cy", "Max", "G", "Ch", "X", "SC", "Cu", "J", "O", "I", "CL", "CA", "W", "YC", "NC", "CM", "VC", "Z", "CE", "Cl", "DC", "CP", "CW", "CC", "L", "D", "MC", "B", "S", "c", "CR", "E", "H", "CS", "F", "CI", "V", "CU", "Y", "Q", "P", "CT"], "resultSplitted": ["resultClilled", " resultsplashed", "resultsplitized", "resultSplited", "ResultSplitted", "resultSlashed", "ResultSpitting", " resultSplitized", "ResultSpited", "resultSpitted", "resultsplitted", "resultSplashed", "resultSplitited", "resultSplitized", "resultClitted", "resultSpited", "resultSlited", "resultSpilled", "resultsplashed", " resultsplited", "resultSlitized", "ResultSplited", " resultsplitized", "resultClitting", "resultsplited", " resultSplashed", "resultSplititized", " resultsplitted", "ResultSpilled", "resultSplitashed", "resultSplilled", " resultSplited", "ResultSpitted", "resultClited", "ResultSplitting", "resultSplitilled", "resultSplititted", "resultSplitting", "resultSlitted", "resultSpitting", "ResultSplilled", "resultSplititting"], "aux": ["aligned", "exec", "extra", "events", "ux", "args", "ault", "ww", "cmp", "final", "section", "iterator", "cas", "input", "config", "sequence", "af", "feat", "ai", "total", "ui", "flat", "sub", "Array", "long", "front", "partial", "ext", "special", "uc", " auxiliary", "seq", "auc", "ex", "ru", "au", "AU", "union", "frac", "amp", "temp", "items", "Items", "null", "utils", "ursive", "main", "asc", "tmp", "array", "iliary", "sect", "external", "lc", "assembled", "abc"], "i": ["e", "si", "ini", "xi", "ip", "d", "ori", "mi", "id", "h", "J", "p", "I", "u", "im", "z", "r", "li", "t", "ai", "ui", "v", "pi", "it", "ni", "io", "ir", "q", "n", "ci", "m", "l", "ii", "index", "ei", "bi", "ti", "c", "int", "a", "k", "ri", "iu", "b", "ind", "o", "g", "qi"], "j": ["e", "si", "xi", "d", "num", "h", "J", "p", "ch", "u", "im", "ct", "z", "ie", "li", "jj", "v", "obj", "q", "n", "m", "ci", "l", "adj", "jp", "ij", "ii", "index", "c", "key", "ji", "k", "code", "b", "ind", "g", "js", "qi"], "item": ["ip", "extra", "name", "event", "num", "X", "step", "p", "section", "current", "I", "input", "instance", "val", "foo", " Item", "v", "object", "root", "row", "string", "bar", "obj", "example", "anything", "entry", "function", "order", "value", "raw", "new", "temp", " it", "items", "Item", "this", "other", "option", "array", "trial"], "inputFileName": ["InputFileUrl", "fileFileName", "inputfileUrl", "inputDirName", "InputFileNum", "inputFolderName", "inputfilePath", "InputfileName", "inputfileDesc", "inputFileDescription", "inputJarPath", "fileJarPath", "inputDirPath", "inputFileDir", "inputFolderDir", "fileFileDescription", "InputfileUrl", "inputSourceFileUrl", "fileJarName", "inputJarName", "inputFolderUrl", "inputDirDescription", "inputfileDir", "inputFileDesc", "fileFileDesc", "inputJarDesc", "inputSourceFileDir", "fileJarDesc", "fileFilePath", "inputSourceFileName", "inputSourceFileNum", "InputFileDir", "fileJarDescription", "inputfileDescription", "InputfileNum", "InputFileName", "inputfileName", "inputFileNum", "InputfileDir", "inputDirDesc", "inputFileUrl", "inputFolderNum", "inputFilePath", "inputfileNum", "inputJarDescription"], "f": ["e", "fw", "fd", "d", "fr", "fn", "h", "p", "input", "af", "r", "fo", "z", "file", "t", "fb", "form", "tf", "v", "io", "feed", "w", "m", "l", "rf", "fp", "inf", "fs", "ff", "c", "s", "df", "F", "buff", "b", "fc", "info", "folder"], "fout": [" fOut", "FOut", "Fout", "fstr", "Fstr", "fdstr", "fdOut", "Fouts", " fouts", "fOut", " fstr", "fouts", "fdouts", "fdout"], "T": ["U", "G", "X", "TN", "J", "Time", "O", "I", "TS", "TB", "W", "t", "TM", "TA", "Z", "K", "L", "D", "A", "B", "S", "TT", "E", "H", "F", "V", "NT", "Y", "Q", "P"], "case": ["gi", "col", "shift", " ti", "h", "section", "ct", "z", "val", "ai", "obj", "q", "ci", "seq", "ice", "tim", "ib", "job", "ti", "times", "je", "c", "temp", "sec", "time", "cell", "test", "cycle", "code"], "data": ["e", "d", "args", "pos", "default", "id", "content", "aa", "slice", "p", "current", "series", "list", "none", "input", "start", "config", "r", "response", "output", "number", "first", "object", "DATA", "na", "rec", "string", "date", "Data", "source", "m", "n", "sample", "pad", "dat", "index", "function", "missing", "value", "da", "body", "one", "xxx", "batch", "block", "c", "details", "s", "split", "key", "a", "int", "items", "lines", "code", "array", "load", "info"], "M": ["U", "G", "ME", "X", "MI", "J", "O", "I", "W", "MD", "NM", "MS", "Z", "K", "MT", "MX", "m", "MN", "L", "Mo", "D", "A", "MC", "B", "DM", "S", "MA", "IM", "E", "H", "F", "V", "Y", "Q", "P", "MM", "LM"], "x": ["e", "size", "xi", "xs", "my", "d", "num", "X", "h", "p", "xy", "width", "max", "xes", "u", "ct", "r", "rx", "z", "t", "number", "v", "w", "m", "n", "L", "l", "ci", "index", "ex", "xc", "wx", "c", "s", "int", "xx", "min", "ix", "Y", "b", "o", "ax"], "y": ["e", "ny", "yr", "my", "d", "yy", "ay", "X", "h", "p", "sy", "ch", "xy", "z", "r", "ky", "t", "v", "ym", "w", "cy", "type", "m", "n", " Y", "oy", "l", "py", "c", "ey", "dy", "a", "yo", "ya", "min", "vy", "Y", "gy", "b", "o"], "N": ["U", "G", " n", "X", "J", "O", "I", "W", "NM", "NI", "n", "MN", "L", "m", "D", "B", "S", "E", "Ni", "Ns", "NO", "F", "V", "NT", "Y", "NS", "Q", "P", "No"]}}
{"code": "\\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      T = int(f.readline())\\n      for _T in xrange(T):\\n          C, F, X = map(float, f.readline().split())\\n  \\n          cps = 2.0\\n          t = 0.0\\n          best_t = X / cps\\n  \\n          while True:\\n              t += C / cps\\n              if t >= best_t:\\n                  break\\n  \\n              cps += F\\n              best_t = min(best_t, t + X / cps)\\n  \\n          print \"Case #%d: %.7f\" % (_T+1, best_t)\\n", "target": "47", "substitutes": {"f": ["e", "fw", "cf", "fd", "d", "fr", "i", "fed", "bf", "p", "fi", "lf", "u", "af", "r", "handler", "fo", "file", "tf", "fb", "form", "v", "feed", "w", "sf", "m", "l", "rf", "function", "fp", "inf", "fs", "ff", "c", "df", "x", "fe", "b", "fc", "o", "fen", "g", "fa"], "fn": ["cf", "fw", "full", "fd", "name", "ren", "len", "syn", "enc", "p", "fil", "fi", "lf", "fun", "wl", "feat", "fm", "file", "output", "fb", "nm", "wn", "bn", "filename", "loc", "method", "n", "kn", "hn", "function", "fl", "fp", "tn", "fs", "func", "ln", "c", "lib", "unc", "wt", "gn", "FN", "nc", "path", "fat", "format", "fc", "dn", "fen", "txt"], "T": ["N", "U", "G", "TF", "TN", "Time", "O", "length", "I", "TS", "W", "TA", "M", "Z", "TH", "L", "GT", "D", "A", "R", "B", "S", "TT", "Ts", "TG", "E", "H", "V", "Total", "NT", "Y", "Q", "P", "CT"], "_T": [" _F", " _C", "_N", " _N", " _L", "_L", "_t", "_F", "_C", " _t"], "C": ["N", "CF", "U", "G", "O", "I", "CL", "W", "M", "Z", "K", "CM", "EC", "CC", "L", "D", "A", "R", "B", "S", "FC", "c", "TC", "CV", "CR", "E", "H", "V", "CU", "Y", "Q", "P", "CT"], "F": ["N", "CF", "U", "G", "Fs", "FD", "TF", "O", "FT", "I", "W", "BF", "M", "Z", "K", "L", "D", "A", "R", "PF", "B", "FM", "FC", "FE", "E", "H", "V", "FF", "Y", "Q", "P", "AF", "FW"], "X": ["N", "CF", "U", "XL", "G", "XP", "J", "ZX", "XXX", "CL", "TS", "TX", "W", "M", "Z", "EC", "K", "CC", "L", "EX", "D", "A", "FO", "R", "B", "S", "FC", "TC", "CR", "E", "H", "UX", "x", "V", "FF", "Y", "Q", "P", "XX", "PE", "CT"], "cps": [" ceps", "cpp", "cpes", "citsp", "lcPs", "ccpps", "cmpes", "rcPs", "ccPS", "citps", "cpps", "upp", "CPs", "arcsp", " cPS", "acps", "ccps", "Cops", "citpps", "ueps", "CPS", "aceps", "ucops", "cPs", "ucPs", "csp", "eeps", "acops", "rcpps", "upps", "uceps", "ups", " cPs", "cmps", "Ceps", "ucPS", "rcps", "ccPs", "rcPS", "eps", "citpes", " cpps", "arcpps", "epps", "cmpps", " cpp", "epp", "cmsp", "ucps", "lcPS", "lcps", "ucpps", "cops", "arcps", "Cps", "lceps", "arcpes", "ceps", "acPS", "cPS"], "t": ["e", "at", "tt", "d", "i", "ta", "p", "ont", "start", "u", "ct", "z", "pt", "nt", "tf", "r", "ft", "dt", "v", "tw", "w", "type", "n", "m", "l", "ot", "ti", "TT", "c", "temp", "s", "int", "a", "tp", "test", "x", "PT", "y", "b", "o", "ts"], "best_t": ["best_tt", "best_f", " bestPt", " bestJf", "bestJT", "best_p", "bestPf", "bestJt", "best_T", " bestJtt", "bestJtt", " best_tt", " bestPf", "bestPp", " bestPT", "bestJp", "bestPT", "bestPtt", " best_f", " bestPp", " bestJp", "bestPt", " best_ts", "bestJts", "best_ts", " bestJt", " best_p", " best_T", "bestJf", " bestJT"]}}
{"code": "\\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      T = int(f.readline())\\n      for _T in xrange(T):\\n          R, C, M = map(int, f.readline().split())\\n  \\n          print \"Case #%d:\" % (_T+1)\\n  \\n          left = R * C - M\\n  \\n          if R == 1:\\n              s = 'c'\\n              s += '.' * (left - 1)\\n              s += '*' * M\\n              print s\\n              continue\\n          if C == 1:\\n              print 'c'\\n              for i in xrange(left - 1):\\n                  print '.'\\n              for i in xrange(M):\\n                  print '*'\\n              continue\\n  \\n          if left == 1:\\n              print 'c' + '*' * (C-1)\\n              for i in xrange(R-1):\\n                  print '*' * C\\n              continue\\n  \\n          if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\\n              print \"Impossible\"\\n              continue\\n          if R == 2:\\n              assert left not in (2, 3, 5, 7)\\n              assert left >= 4\\n              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)\\n              print '.' + '.' * (left/2 - 1) + '*' * (M/2)\\n              continue\\n          if C == 2:\\n              assert left >= 4\\n              assert left not in (2, 3, 5, 7)\\n              print 'c.'\\n              left -= 2\\n              R -= 1\\n              while left:\\n                  print '..'\\n                  left -= 2\\n                  R -= 1\\n              assert R >= 0\\n              while R:\\n                  print '**'\\n                  R -= 1\\n              continue\\n  \\n          assert R >= 3\\n          assert C >= 3\\n  \\n          if left == 4:\\n              print 'c.' + '*' * (C-2)\\n              print '..' + '*' * (C-2)\\n              for i in xrange(R-2):\\n                  print '*' * C\\n              continue\\n  \\n          if left in (2, 3, 5, 7):\\n              print \"Impossible\"\\n              continue\\n  \\n          assert left >= 6\\n  \\n          cols = max(3, (left + R-1) // R)\\n  \\n          if left % cols == 1:\\n              assert left >= 10\\n  \\n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\\n              left -= cols\\n              R -= 1\\n  \\n              while left > cols + 1:\\n                  print '.' * cols + '*' * (C - cols)\\n                  left -= cols\\n                  R -= 1\\n              assert left == cols + 1\\n              print '.' * (cols - 1) + '*' * (C - cols + 1)\\n              print '.' * (2) + '*' * (C - 2)\\n              R -= 2\\n  \\n              assert R >= 0\\n  \\n              while R:\\n                  print '*' * C\\n                  R -= 1\\n              continue\\n          else:\\n              assert left >= 6\\n  \\n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\\n              left -= cols\\n              R -= 1\\n  \\n              while left > cols:\\n                  print '.' * cols + '*' * (C - cols)\\n                  left -= cols\\n                  R -= 1\\n              assert left >= 2\\n              print '.' * (left) + '*' * (C - left)\\n              R -= 1\\n  \\n              assert R >= 0\\n  \\n              while R:\\n                  print '*' * C\\n                  R -= 1\\n              continue\\n  \\n          1/0\\n", "target": "47", "substitutes": {"f": ["e", "fw", "full", "fd", "fr", "fed", "h", "bf", "p", "fi", "u", "af", "r", "fo", "file", "t", "tf", "fb", "form", "v", "feed", "w", "sf", "m", "n", "l", "rf", "fp", "inf", "fs", "c", "df", "F", "x", "b", "fc", "o", "fen", "g", "fa"], "fn": ["full", "fd", "name", "len", "syn", "bf", "fil", "fi", "ll", "conn", "fun", "wl", "feat", "fm", "file", "fb", "output", "wn", "bn", "filename", "sf", "n", "kn", "rf", "utf", "function", "fl", "fp", "fs", "func", "ln", "lib", "sn", "unc", "wt", "FN", "F", "nc", "fin", "path", "format", "fat", "fc", "dn", "fen", "txt", "fa"], "T": ["N", "TR", "G", "X", "TN", "Time", "O", "length", "I", "TS", "TX", "TB", "W", "t", "Z", "K", "TH", "n", "L", "WT", "D", "A", "TW", "S", "TT", "E", "F", "V", "Total", "NT", "Y", "Q", "P", "DT", "Tw"], "_T": ["_N", " _N", "_M", " _M", "_t", "_F", " _t"], "R": ["N", "Rh", "TR", "AR", "U", "RH", "G", "X", "Left", "RL", "RE", "J", "O", "RR", "I", "r", "W", "Rs", "RG", "Line", "K", "RC", "RW", "SR", "RO", "Right", "RN", "Re", "L", "D", "A", "B", "RS", "right", "S", "ro", "c", "RP", "CR", "E", "H", "F", "V", "RF", "DR", "RM", "GR", "All", "Y", "NR", "Q", "P", "RT", " r", "RA", "Range"], "C": ["N", "CF", "Cs", "U", "G", "X", "Left", "Co", "SC", "Cu", "O", "COR", "I", "CNN", "CA", "r", "W", "CM", "CE", "K", "EC", "RC", "DC", "RO", "Right", "CC", "L", "Sc", "D", "A", "B", "S", "CO", "c", "CR", "E", "H", "F", "V", "CU", "Y", "Q", "P", "Cr"], "M": ["N", "U", "G", "X", "Left", "J", "O", "LM", "I", "MR", "r", "W", "TM", "MD", "NM", "Z", "CM", "K", "MS", "MT", "Mor", "m", "MN", "L", "D", "A", "OR", "MC", "B", "DM", "S", "MA", "E", "H", "F", "V", "RM", "Y", "Q", "P", "MM", "MF"], "left": ["N", "shell", "col", "cle", " L", "offset", "pl", "required", "out", "I", "lt", "case", "LC", "lr", "row", "PL", "log", "CC", "ctrl", "index", "text", "c", "reset", "ALL", "end", "cell", "P", "cm", "err", "ax", "bottom", "LM", "pos", "plus", "X", "internal", "LL", "length", "CL", "none", "byn", "FL", "li", "Cl", "just", "root", "top", "ell", "nl", "n", "L", "l", "all", "CO", "old", "label", "a", "sp", "F", "x", "ul", "found", "le", "ignore", "o", "low", "net", "full", "e", "d", "bl", "self", "SC", "center", "RL", "Control", "p", "j", "inner", "file", "static", "co", "error", "leave", "partial", "loc", "NL", "m", "cont", "function", "data", "one", "ro", "CR", "key", "st", "this", "min", "LE", "outside", "size", "ion", "rows", "Left", "len", "str", "lo", "list", "column", "ct", "r", "lower", "output", "it", "roll", "Z", "wrong", "ST", "RO", "small", "Right", "used", "cl", "fl", "value", "right", "B", "last", "null", "line", "two", "path", "no", "control", "LR", "lc"], "s": ["e", "si", "ws", "sign", "sg", "d", "ns", "center", "h", "str", "p", "sb", "out", "su", "r", "t", "ed", "sym", "sum", "string", "ses", "cs", "comments", "sets", "small", "w", "sf", "es", "n", "m", "ins", "l", "ls", "ings", "south", "ss", "square", "right", "S", "strings", "c", "ans", "a", "ions", "us", "y", "lines", "b", "o", "span", "secondary", "g"], "i": ["e", "si", "xi", "il", "ip", "id", "p", " I", "j", "I", "u", "im", "ie", "z", "r", "li", "it", "pi", "ai", "v", "io", "n", "ci", "m", "l", "ii", "ei", "ti", "di", "c", "int", "x", "iu", "ind", "IJ", "o", "iw", "g"], "cols": ["columnabs", "colabs", " colrows", "coln", " coln", "COLspan", "Cold", "Colrows", "colrows", "COLn", " cold", "Colabs", "Cols", "COLrows", " colspan", "columnd", "Coln", "Colspan", "columns", "cold", "COLs", "columnn", " colabs", "colspan"]}}
{"code": "\"\"\"\\n  Google Code Jam 2014 Qualification Problem B\\n  Usage:\\n      python b.py < input.txt > output.txt\\n  \"\"\"\\n  \\n  \\n  def solve_problem(farm_cost, farm_rate, target):\\n      rate = 2.0\\n      farms = 0.0\\n  \\n      while (farms + target / rate) > (farms + farm_cost / rate + target / (rate + farm_rate)):\\n          farms = farms + farm_cost / rate\\n          rate = rate + farm_rate\\n  \\n      return farms + target / rate\\n  \\n  \\n  if __name__ == \"__main__\":\\n      num_of_cases = int(sys.stdin.readline().strip())\\n      for i in xrange(1, num_of_cases + 1):\\n          farm_cost, farm_rate, target = map(float, sys.stdin.readline().strip().split())\\n          print \"Case #{0}: {1:9.7f}\".format(i, solve_problem(farm_cost, farm_rate, target))\\n", "target": "48", "substitutes": {"farm_cost": ["farm_weight", " farm_ace", "farm\u00b7cost", " farm_weight", "farm_rank", "farm_ace", " farm_state", "farm\u00b7key", "yard_score", "yard_level", "farm_score", " farm_sum", "farm\u00b7ace", "farm_length", " farm_key", "farm_level", "farm_state", " farm_length", "yard_cost", "farm_key", "farm_sum", " farm_rank"], "farm_rate": [" farm_currency", "flower_scale", "farm_scale", "flower_factor", "farmxrates", "farm5rates", "farmingtier", "farmxtrade", "flower_rate", "farm\u00b7fare", "farm5tier", " farm_trade", "farm_trade", "fork_fare", "fork_scale", " farm_seed", "farm5seed", "farm5fare", "farm_seed", "fork_rates", "farm\u00b7rate", "farmxrate", "farm_fare", "fork_tier", "farm\u00b7rates", "farmingrates", "farmingrate", "farm_factor", "farm_tier", "farm_rates", "farm5rate", " farm_rates", "farmxcurrency", "farm\u00b7tier", "farm_currency", "farmingseed", " farm_tier", "fork_rate"], "target": ["range", "size", "property", "padding", "percent", "stop", "name", "platform", "Target", "tax", "profit", "effect", "offset", "large", "unit", "current", "feature", "width", "match", "ret", "channel", "market", "conn", "direction", "force", "master", "host", "project", "object", "route", "root", "top", "biased", "flat", "attr", "home", "theme", "source", "feed", "farm", "type", "limit", "hop", "sample", "core", "arget", "resource", "itter", "value", "staff", "base", "dest", "template", "parent", "tail", "gain", "site", "pattern", "goal", "transform", "fox", "term", "path", "phase", "fat", "format", "nat", "reference", "ground", "trial", "net", "scale"], "rate": ["ave", "rand", "weight", " Rate", "ration", "race", "rank", "seed", "price", "depth", "gain", "delay", "ate", "farm", "range", "speed", "rule", "rated", "capacity", "rake", "width", "ride", "ale", "root", "currency", "feed", "type", "sample", "frac", "time", "test", "x", " rates", "score", "profit", "step", "radius", "feature", "match", "Rate", "rice", "re", "arm", "grade", "resource", "rates", "growth", "factor", "ry", " ratio", "tier", "frequency", "rating", "size", "charge", "rage", "ee", "unit", "rat", "state", "source", "age", "fare", "value", "air", "erate", "sync", "base", "fan", "fee", "mode", "scale"], "farms": ["ffarms", "rfairs", "feats", " fears", "sfares", "fats", "garm", "ffarming", "infarms", "farming", "fares", "feares", "sfarming", "fearms", "infarm", "larm", "Farms", "infats", "fears", "larming", " farm", "gares", "infarming", "Fears", "Fats", "infares", "fearm", "garms", "garming", " fares", "infairs", "rfarms", "rfears", "lears", "Farm", "ffakers", " farming", "feakers", "fearming", "sfarms", "Fakers", "fairs", "Fares", "rfarming", " fairs", "infears", "Farming", "ffarm", "fakers", "farm", "sfarm", "larms"], "num_of_cases": ["num_ofofcases", "num_ofoffits", "num_of_times", "num_ofofcase", "num_of67times", "num_of67case", "num_ofoftimes", "num_of67fits", "num_of67cases", "num_of_sections", "num_of_case", "num_of_fits"], "i": ["e", "gi", "si", "aci", "xi", "ip", "col", "mi", "id", "h", "p", "j", "I", "zi", "r", "li", "t", "pi", "_", "uri", "n", "ci", "ii", " c", "ti", "bi", "c", "int", "k", "x", "ix", "ind", "f", "uni", " j", "eni", "qi"]}}
{"code": "\"\"\"\\n  Google Code Jam 2014 Qualification Problem C\\n  Usage:\\n      python c.py < input.txt > output.txt\\n  \"\"\"\\n  \\n  \\n  def iter_neighbors(x, y, cells):\\n      columns = len(cells[0])\\n      rows = len(cells)\\n  \\n      if y > 0:\\n          if x > 0:\\n              yield x - 1, y - 1\\n          yield x, y - 1\\n  \\n          if x + 1 < columns:\\n              yield x + 1, y - 1\\n  \\n      if x > 0:\\n          yield x - 1, y\\n  \\n      if x + 1 < columns:\\n          yield x + 1, y\\n  \\n      if y + 1 < rows:\\n          if x > 0:\\n              yield x - 1, y + 1\\n  \\n          yield x, y + 1\\n  \\n          if x + 1 < columns:\\n              yield x + 1, y + 1\\n  \\n  \\n  def try_to_click(x, y, cells, remaining):\\n      if remaining == 0:\\n          return cells\\n  \\n      recent = []\\n  \\n      opened = 0\\n  \\n      for n_x, n_y in iter_neighbors(x, y, cells):\\n          if cells[n_y][n_x] == \"?\":\\n              cells[n_y][n_x] = \".\"\\n              opened += 1\\n              recent.append((n_x, n_y))\\n  \\n      if opened == remaining:\\n          return cells\\n  \\n      if opened > remaining:\\n          return []\\n  \\n      for n_x, n_y in recent:\\n          solution = try_to_click(n_x, n_y, copy.deepcopy(cells), remaining - opened)\\n          if solution:\\n              return solution\\n  \\n      return []\\n  \\n  \\n  def solve_problem(rows, columns, mines):\\n  \\n      for x in xrange(columns):\\n          for y in xrange(rows):\\n              cells = [[\"?\" for i in xrange(columns)] for j in xrange(rows)]\\n              cells[y][x] = \"c\"\\n              solution = try_to_click(x, y, cells, rows * columns - mines - 1)\\n  \\n              if solution:\\n                  return \"\\n\".join([\"\".join(row) for row in solution]).replace(\"?\", \"*\")\\n  \\n      return \"Impossible\"\\n  \\n  \\n  if __name__ == \"__main__\":\\n      num_of_cases = int(sys.stdin.readline().strip())\\n      for i in xrange(1, num_of_cases + 1):\\n  \\n          rows, columns, mines = map(int, sys.stdin.readline().strip().split())\\n  \\n          print \"Case #{0}:\\n{1}\".format(i, solve_problem(rows, columns, mines))\\n", "target": "48", "substitutes": {"x": ["xs", "xt", "col", "name", "px", "by", "val", "cy", "index", "xc", "any", "wx", "c", "cell", "xx", "yes", "ax", "my", "event", "X", "ye", "ch", "z", "tx", "_", "dx", "w", "n", "l", "s", "pe", "a", "ic", "code", "b", "f", "o", "e", "ys", "d", "id", "p", "xy", "xml", "xes", "rx", "t", "ty", "yx", "on", "v", "na", "inx", "m", "ci", "ey", "ry", "ya", "Y", "ck", "xi", "ay", "h", "u", "image", "ct", "q", "ex", "right", "xxx", "win", "work", "int", "dy", "lex", "k", "ix", "no", "g"], "y": ["e", "ny", "ys", "yr", "zy", "my", "d", "col", "iy", "yy", "ay", "id", "type", "ady", "h", "sky", "yt", "sy", "ye", "xy", "ch", "p", "year", "z", "ky", "t", "ty", "yx", "v", "ym", "idy", "yl", "hy", "w", "cy", "q", "ies", "n", "oy", "py", "wy", "ery", "m", "l", "ci", "ish", "yi", "c", "ey", "dy", "cell", "a", "ry", "yo", "yu", "ya", "yn", "min", "vy", "Y", "gy", "yes", "b", "yd", "o"], "cells": ["letters", "xs", "events", "books", "words", "case", "cases", "games", "values", "cards", "yrs", "cy", "cats", "pages", "ls", "fields", "rooms", "charges", "windows", "c", "details", "cell", "parts", "phones", "states", "ries", "rules", "cb", "features", "codes", "z", "_", "ences", "cs", "plugins", "l", "breaks", "ks", " Cells", "models", "all", "s", "blocks", "reports", "false", "sites", "ports", "classes", "settings", "images", "true", "ce", "xes", "sections", "comments", "conf", "ells", "csv", "ci", "south", "keys", "apps", "facts", "files", "versions", "lines", "styles", "objects", "sheets", "members", "Cell", "points", " cell", "ces", "holes", "ches", "ed", "ows", "ies", "grid", "groups", "cache", "ions", "tests", "items", "cel", "inches"], "columns": ["widthops", "platformes", "colings", "widthensions", "maximumes", "platforms", "wellns", "widthes", "colensions", "Columnions", "colops", "columnumes", "ylns", "widthfs", "patternes", "widths", "cols", "paths", "Columnes", "yls", " columnes", "columnows", "patternses", "columnes", "cellumes", "widthows", " columnensions", "colths", "patterns", "coles", "maximumths", "columnops", " columnings", "Columnfs", "yles", "welles", "widthions", "cellows", "widthumes", "platformths", "columnions", "paragraphs", "colns", "ylues", "columnths", "colses", "maximumses", "wellues", "colions", "wells", "Columnses", "colches", "colfs", "columnings", "maximums", "widthches", "patternions", "widthues", " columnses", "colues", "columnues", "cellops", "pathes", "pathstates", "colstates", "Columns", "pathches", "columnns", "Columnches", " columnments", "Columnows", "colows", "columnensions", "columnments", "columnfs", "colments", "columnstates", "paragraphings", "platformses", "columnses", "Columnstates", " columnues", "paragraphses", "columnches", "paragraphments", "columes"], "rows": ["rules", "relations", "heads", "members", "events", "col", "ids", "reads", "months", "opens", "length", "features", "rings", "r", "holes", "cases", "planes", "values", "acks", "dates", "yards", "vers", "types", "ows", "forms", "w", "rics", "pages", "ins", "fields", "rown", "rooms", "keys", "breaks", "ks", "groups", "views", "headers", "posts", "frames", "times", "c", "checks", "s", "windows", "blocks", "files", "faces", "orders", "flows", "projects", "rs", "tracks", "height", "reports", "tests", "lines", "users", "boxes", "ports", "runs", "ries"], "remaining": [" remain", "resaining", "remain", "remained", "resain", "expained", "Remerving", "romain", " remstanding", "Remaining", "Remains", "romaining", "expaining", "expain", "resstanding", "resains", "Remending", "remerving", "reserving", "remstanding", "remending", "Remained", "expains", "resained", " remerving", "remains", "resending", " remending", "Remstanding", " remained", "romains", "romained", "Remain"], "recent": ["events", "client", "event", "memory", "exclusive", "correct", "short", "true", "unique", "shown", "best", "accessible", "current", "opens", "complete", "archive", "quick", "instance", "updated", "closed", "exp", "sofar", "region", "partial", "record", "small", "original", "remote", "initial", "valid", "past", "many", "right", "close", "raw", "fresh", "successful", "last", "old", "modern", "progress", "new", "confirmed", "items", "apse", "window", "open", "active", "today", " recently", "latest", "complex", "popular", "ances", "apsed", "later", "created", "available", "ready", "hold", "folder", "Recent"], "opened": ["size", "raised", "drawn", " reopened", "rated", "selected", "locked", "lined", "ened", "opens", "worked", "answered", "initialized", "added", "opening", "sized", "ended", "updated", "called", "established", "closed", "ed", "connected", "served", "focused", "expected", "original", "used", "forced", "early", "posted", "pressed", "ned", "edited", "successful", "adjusted", "aced", "eno", "ordered", "confirmed", "open", "anged", "played", "nc", "started", "signed", " consumed", "created", "apsed", "awed", "aled", "handled", "assembled", "produced", "shown", "released", "orig", "rawn"], "n_x": ["en_y", "N_x", "enFy", "en_wy", "n_ya", "en_z", "enFwy", " n_dx", "n_yx", "n_z", "nNewrx", "n_rx", "nNewy", "enFx", " n_na", "nFz", "enFz", "nFwy", " n_ux", "nFx", "n_ux", "nFy", "nNewwx", "n_dx", "n_wy", "N_rx", "n_ci", "n_wx", "N_y", "en_x", " n_z", " n_yx", "n_na", "nNewx", " n_ya", "N_wx", " n_ci"], "n_y": ["n___x", "nin_y", "nLogx", "N_x", "nLogz", "n_yl", "nLogwy", "nXx", "n_yn", " n_wy", "tXx", "n___gy", "n_i", " n_yn", "nXyi", " n_gy", "n_z", "t_i", "n_yi", "nin_z", "nNewny", "nNewy", "nNewyn", "nin_yi", "tXyi", "N_ym", "nXi", "n___y", "n_wy", "nin_ey", "n_ey", "no_ny", "N_y", "t_x", "n___yn", "t_yi", " n_z", "N_yt", "nXy", "n_ny", "no_y", "no_yl", "n_gy", "nLogy", "tXi", "tXy", "n_yt", "no_yn", "n_ym", "t_y", "nNewyl"], "solution": ["psour", "solver", "fsolution", "ssolve", "Solving", "solutions", "sesolution", "sesolved", "solving", "suffolved", "psolved", "colution", "ssolved", "Solved", "suffolver", "absolve", "absolutions", "suffolution", "fsolve", "folver", "sesolving", " solve", "sesolutions", "ssour", "sesolver", "colver", " solved", "solve", "psolve", "ssolution", "folving", "Solution", "solved", "sour", " solutions", "absolver", "Solutions", "setsolution", "setsolver", "setsolve", "absolution", "psolution", "colve", "setsolving", "suffolving", "fsolving", " solving", "setsour", "Solve", "colutions", "ssolver", "setsolved", "folved", "fsolver", "Solver", "sesolve", "ssolutions", "folution", "ssolving"], "mines": ["MINions", "minuses", "Minutes", "tens", "mins", "MINuses", "tenions", "Mins", "Minuses", "millutes", "Mines", "minutes", "Minies", "minizes", " minizes", "tenes", "minions", "MINs", "millions", "Minizes", "millizes", "milles", " minutes", " minuses", " mins", " minies", "minies", " minions", "Minions", "MINes", "tenies"], "i": ["e", "xi", "ip", "d", "iy", "col", "h", "u", "im", "z", "li", "pi", "ai", "it", "v", "io", "q", "m", "ci", "n", "l", "ii", "yi", "c", "ia", "int", "ix", "b", "ind", "f", "iw"], "j": ["ny", "yr", "zy", "my", "iy", "yy", "ay", "ady", "h", "p", "ct", "z", "co", " ye", "hy", "q", "m", "ci", "ij", "je", "yu", "dy", "ji", "ry", "k", "b", "cm", "o"], "row": [" u", "range", " ur", "container", " col", "col", "cube", "rc", "item", "ye", "xy", "Row", "r", " z", "uu", "co", "v", " d", "error", " Row", "feed", "rect", "ow", "query", " key", "entry", "rown", "value", "raw", " c", "char", "sel", "model", " r", "cell", " tr", "node", "result", "line", " v", " ro", "cer", "server", "bug"], "num_of_cases": ["num_of_tests", "num_of_times", "num_of_windows", "num_of_case", "num_of_blocks"]}}
{"code": "\\n  \\n  data Test = Test {\\n        cout     :: Double\\n      , bonus    :: Double\\n      , objectif :: Double\\n      } deriving Show\\n  \\n  newtype Solution = Solution { temps :: Double }\\n  \\n  instance Show Solution where\\n      show (Solution t) = show t\\n  \\n  main = do\\n      interact (unlines . map showCase . zip [1..] . map resoudre . goTest . tail . lines)\\n  \\n    where\\n      goTest [] = []\\n      goTest (l:ls) =\\n          let [c, f, x] = map read $ words l\\n          in Test c f x : goTest ls\\n  \\n      showCase :: (Int, Solution) -> String\\n      showCase (i, s) = printf \"Case #%d: %s\" i (show s)\\n  \\n  resoudre :: Test -> Solution\\n  resoudre Test {..} | premierAchat > sansAchat = Solution sansAchat\\n                     | otherwise                = go premierAchat 2\\n    where\\n      go t prod | tempsAvecAchat >= tempsSansAchat = Solution (t + tempsSansAchat)\\n                | otherwise                        =\\n                    go (t + delaiProchainAchat) prod'\\n        where\\n          prod' = prod + bonus\\n  \\n          tempsAvecAchat = objectif / prod'\\n          tempsSansAchat = (objectif - cout) / prod\\n  \\n          delaiProchainAchat = cout / prod'\\n  \\n      premierAchat = cout / 2\\n      sansAchat    = objectif / 2\\n", "target": "49", "substitutes": {"Test": ["Example", "Server", "Version", "Sample", "Rule", "Feature", "ert", "Fixed", "G", "Class", "X", " Tests", "Time", "Testing", "Path", "Script", "Text", "If", "App", "case", "Title", " test", "File", "Name", "Match", "Config", "Value", "Choice", "Array", "Zero", "Split", "Data", "ose", "Dev", "Fit", "Table", " tests", "q", "Step", "Format", "Case", "Examples", "Check", "R", "T", "S", "Runner", "Model", "Best", " Testing", "Train", "Result", "test", "It", "Type", "F", "ore", "Fix", "est", "ests", "Setup", "P", "Code", "Point", "Stage", "Study", "Proof", "Ver"], "Solution": ["N", "Example", "LP", "Version", "Sample", "Student", "Object", "rape", "Application", "Report", "File", "M", "Line", "Learn", "olves", "User", "Description", "Fit", "Person", "My", "Int", "Course", "Response", "New", "Q", "P", "Correction", "Answer", "Fixed", "X", "J", "C", "opt", "Time", "Opt", "Str", "Command", "_", "Money", "Choice", "Table", "olution", "n", "Group", " solution", "R", "T", "Best", "Train", "F", "olve", "Node", "Error", "Simple", "Evidence", "Part", "Matrix", "Feature", "G", "Class", "Ch", "ve", "Co", "Integer", "Script", "Num", "Mer", "Member", "Problem", "Struct", "Net", "example", "Position", "S", "Sim", "Function", "Par", "Vector", "Result", "String", "Type", "V", "Fix", "XY", "Setup", "Y", "Product", "Study", "Point", "Results", "Long", "Multiple", "Location", "Option", "Go", "Do", "O", "Package", "Exception", "Variable", "Success", "Array", "string", "Nice", "Map", "olutions", "D", "Case", "Population", "Model", "Code"], "main": ["Example", "results", "loop", "Main", "next", "done", "msg", "section", "doc", "Title", "output", "foo", "root", "obj", "example", "seq", "Examples", "script", "mult", " example", "Train", "Result", "result", "line", "run", "plot", " code", "js"], "goTest": ["GoTesting", "goTesting", " gotest", "gTesting", "doTesting", "GOtest", "goServer", " goSample", "GOSample", " goCase", "cotest", "GoTrain", "GoSample", "GoServer", "goTrain", "GOTrain", "gTest", "GOTest", " goTrain", "gameTest", "gSample", "GOCase", "doTest", "gaTest", "gameTesting", "gameServer", "goSample", "gaServer", "GoTest", "GOTesting", "GoCheck", "coTesting", "goCheck", "gotest", "goCase", "coTest", "gaCheck", "gtest", "GoCase", "gameCheck", " goTesting", "dotest", "gaTesting"], "let": ["gen", "struct", "LET", "ve", "opt", "Let", "section", "out", "list", "letter", "lets", "case", "file", "output", "Struct", "v", "script", "model", "temp", "init", "test", "set", "var", "line", "format", "le"], "c": ["e", "mc", "d", "id", "i", "rc", "h", "ac", "C", "dc", "p", "ch", "ll", "ar", "u", "case", "er", "z", "r", "t", "v", "cs", "w", "q", "n", "m", "l", "cache", "s", "cc", "k", "y", "code", "b", "fc", "o", "g", "lc"], "f": ["e", "cf", "fd", "d", "i", "h", "xf", "fx", "p", "fi", "lf", "fun", "u", "z", "file", "tf", "form", "fb", "v", "of", "fer", "w", "q", "sf", "n", "m", "l", "rf", "fl", "fp", "fs", "ff", "s", "df", "F", "fe", "b", "fc", "o", "g"], "x": ["e", "xa", "xs", "xi", "ux", "d", "xt", "i", "X", "h", "xp", "xf", "p", "j", "xml", "u", "ct", "z", "tx", "v", "dx", "w", "q", "n", "ci", "ls", "index", "ex", "xc", "xxx", "ox", "s", "k", "st", "xx", "ix", "y", "b", "o", "ax"], "otherwise": [" othersp", "OTHERthen", "Othersp", "othersp", " otherfore", "OTHERwise", " otherthen", "otherfore", " elsethen", "Otherwise", "Otherthen", "OTHERsp", " elsewise", " elsefore", "otherthen", "OTHERfore"], "tempsAvecAchat": ["tempsAvecAnchat", "tempsAverAsformat", "tempsAvecAsgap", "tempsAverApi", "tempsAvecAbpi", "tempsAvecAcat", "tempsAvecAngap", "tempsAvecAbgap", "tempsAvecApi", "tempsAvecAformat", "tempsAvertArChat", "tempsAvecScat", "tempsAvecSChat", "tempsAvecAspi", "tempsAverAformat", "tempsAvecAnpi", "tempsAverAchat", "tempsAvecArChat", "tempsAverAschat", "tempsAvertArchat", "tempsAvertAChat", "tempsAvecAschat", "tempsAvecAbchat", "tempsAvecArchat", "tempsAverAsgap", "tempsAvertAchat", "tempsAvertArcat", "tempsAvecArpi", "tempsAvertArpi", "tempsAvecSchat", "tempsAvecSpi", "tempsAvecAsformat", "tempsAverAgap", "tempsAverAspi", "tempsAvecArcat", "tempsAvertApi", "tempsAvecAbformat", "tempsAvecAnformat", "tempsAvecAgap", "tempsAvertAcat", "tempsAvecAChat"], "delaiProchainAchat": ["delaiProchainAbcot", "delaiProchainAschat", "delaiProChainAver", "delaiProchainArchat", "delaiProchainArver", "delaiProChainAscot", "delaiProChainAhack", "delaiProchainArcot", "delaiProChainAshack", "delaiProchainAhack", "delaiProchainArhack", "delaiProchainAbchat", "delaiProchainAbpi", "delaiProChainAspi", "delaiProChainAchat", "delaiProChainAsver", "delaiProchainAver", "delaiProchainAshack", "delaiProChainApi", "delaiProChainAcot", "delaiProchainAbver", "delaiProchainAspi", "delaiProchainArpi", "delaiProchainAsver", "delaiProChainAschat", "delaiProchainAscot", "delaiProchainAcot", "delaiProchainApi"], "sansAchat": ["sanAquant", "sansAbvert", "sansAcot", "sanAcore", "sansAscore", "sansArChat", "sonsAChat", "sonsAquad", "sanAscat", "sanAsChat", "sansArchat", "sansAscot", "sansaquant", "sanAvert", "sansAsChat", "sansAsvert", "sanAcot", "sanAscore", "sansAAcore", "sansacot", "sansAChat", "sansAquad", "sansArquad", "sansacat", "sansavert", "sanAChat", "sanAsvert", "sansAquant", "sansAbquant", "sansAAchat", "sansAbchat", "sanAsquant", "sansAvert", "sansAAcat", "sansAbChat", "sansAschat", "sansaChat", "sansaquad", "sanAscot", "sanAchat", "sansAscat", "sansAcat", "sansacore", "sansachat", "sansAcore", "sanAcat", "sanAschat", "sonsAchat", "sansAAcot", "sansAsquant"]}}
{"code": "t = int(input())\\n  \\n  VIDE = 0\\n  MINE = 1\\n  CURSEUR = 2\\n  \\n  def test_position(arr, lignes, cols, y, x):\\n      def voisinage_libre(arr, y, x):\\n          if y > 0:\\n              if x > 0 and arr[y-1][x-1] == MINE:\\n                  return False\\n              if arr[y-1][x] == MINE:\\n                  return False\\n              if x < cols - 1 and arr[y-1][x+1] == MINE:\\n                  return False\\n  \\n          if x > 0 and arr[y][x-1] == MINE:\\n              return False\\n          if x < cols - 1 and arr[y][x+1] == MINE:\\n              return False\\n  \\n          if y < lignes - 1:\\n              if x > 0 and arr[y+1][x-1] == MINE:\\n                  return False\\n              if arr[y+1][x] == MINE:\\n                  return False\\n              if x < cols - 1 and arr[y+1][x+1] == MINE:\\n                  return False\\n  \\n          return True\\n  \\n      def remplissage_rec(arr, y, x):\\n          if x < 0 or y < 0 or x >= cols or y >= lignes:\\n              return\\n          elif arr[y][x] == CURSEUR:\\n              return\\n  \\n          arr[y][x] = CURSEUR\\n          if voisinage_libre(arr, y, x):\\n              remplissage_rec(arr, y-1, x-1)\\n              remplissage_rec(arr, y-1, x)\\n              remplissage_rec(arr, y-1, x+1)\\n              remplissage_rec(arr, y, x-1)\\n              remplissage_rec(arr, y, x+1)\\n              remplissage_rec(arr, y+1, x-1)\\n              remplissage_rec(arr, y+1, x)\\n              remplissage_rec(arr, y+1, x+1)\\n  \\n      if arr[y][x] != VIDE:\\n          return False\\n  \\n      arr2 = [ [ arr[i][j] for j in range(0, cols) ] for i in range(0, lignes) ]\\n  \\n      remplissage_rec(arr2, y, x)\\n  \\n      for i in range(0, lignes):\\n          for j in range(0, cols):\\n              if arr2[i][j] == VIDE:\\n                  return False\\n      return True\\n  \\n  def dfs(arr, lignes, cols, mines, y, x):\\n      cases_restantes = (cols - x) + ((lignes - y) * cols)\\n  \\n      if cases_restantes < mines:\\n          return None\\n      elif mines <= 0:\\n          for i in range(0, lignes):\\n              for j in range(0, cols):\\n                  if test_position(arr, lignes, cols, i, j):\\n                      return (i, j)\\n      elif x >= cols:\\n          return dfs(arr, lignes, cols, mines, y+1, 0)\\n      elif y >= lignes:\\n          return None\\n      else:\\n          res = dfs(arr, lignes, cols, mines, y, x+1)\\n          if res != None:\\n              return res\\n  \\n          arr[y][x] = MINE\\n          res = dfs(arr, lignes, cols, mines-1, y, x+1)\\n          if res != None:\\n              return res\\n  \\n          arr[y][x] = VIDE\\n          return None\\n  \\n  for i in range(0, t):\\n      ligne  = input().split(\" \")\\n      lignes = int(ligne[0])\\n      cols   = int(ligne[1])\\n      mines  = int(ligne[2])\\n  \\n      arr = [ [VIDE] * cols for _ in range(0, lignes) ]\\n  \\n      res = dfs(arr, lignes, cols, mines, 0, 0)\\n  \\n      print (\"Case #\"+str(i+1)+\":\")\\n  \\n      if res == None:\\n          print (\"Impossible\")\\n      else:\\n          (y, x) = res\\n  \\n          for i in range(0, lignes):\\n              for j in range(0, cols):\\n                  if i == y and j == x:\\n                      print('c', end='')\\n                  elif arr[i][j] == VIDE:\\n                      print('.', end='')\\n                  else:\\n                      print('*', end='')\\n  \\n              print('', end='\\n')\\n", "target": "49", "substitutes": {"t": [" T", "xt", "d", "num", "ta", "p", "u", "it", "total", "bit", "ext", "w", "type", "m", "n", "T", "ti", "all", "c", "tp", "a", "b", "f", "o", "g", "table", "ts"], "VIDE": ["VENEA", "VIDF", "VIDENCE", "VISEA", "VPF", "VISENCE", " VIDe", "VPEA", "VDe", "VPe", "VISe", "VENF", "VDF", "VISE", "VPE", "VENENCE", "VENE", "VDEA", " VIDENCE", " VIDEA", "VIDe", "VIDEA", "VDE", "VENe"], "MINE": ["FINE", "FKE", "FMine", " Mine", "mINE", "Nined", "MAining", "Mined", "Vined", "FMined", "NKE", "NINE", "REMined", "Mine", "FMKE", "Fined", "Nina", "UNining", "VINE", "VME", "HINE", "UNine", "MISC", "JKE", " Mina", " MKE", "MKE", " MME", "Mining", "Mina", "Vina", "FISC", "Nining", "Vinite", "Hined", "mISC", "UNined", " Minite", "Pinite", "HISC", "Hining", " Mined", "Pine", "JINE", "Jining", "PINE", "Nine", "mine", "Minite", "Vining", "REMME", "REMine", "Fine", "FMINE", "MAINE", "Pined", "UNINE", "FMining", "Pining", " Mining", "Hine", "REMINE", "Jine", "MME", "MAine", "Vine", "mined", "MAined", "Fining"], "CURSEUR": ["CURRSEUL", "CRCseARCH", "CURRseur", "CURSURR", "CURSECIR", "CURseUR", "CURSur", "CURSECUR", "CURTEUR", "CURseVER", "CURseIR", "CURseur", "CRCseUR", "CURSEIR", "CURSIVER", "CURSIUL", "CURRseVER", "CURSIur", "CURTEUL", "CURSEURR", "CURRseUL", "CURSUR", "CURseURR", "CRCseUL", "CRCSEARCH", "CURSECVER", "CURSEARCH", "CURRseURR", "CURSARCH", "CURSIARCH", "CURSIIR", "CRCSEur", "CURSEVER", "CURRSEur", "CURTEur", "CURRSEVER", "CURRSEUR", "CURseARCH", "CURRseIR", "CURSEUL", "CURseUL", "CRCSEUL", "CURRSEIR", "CURSIUR", "CURSEur", "CURSECur", "CURRSEURR", "CURSUL", "CURRseUR", "CURTEURR", "CRCseur", "CRCSEUR"], "arr": ["br", "az", "dr", "arb", "acc", "attr", "rep", "div", "obj", "av", "au", "ann", "art", "aj", "err", "ind", "abs", "att", "yy", "fr", "enc", "z", "arrow", "cat", "align", "ext", "dat", "aaa", "frac", "adv", "app", "test", "rs", "ab", "Ar", "array", "abc", "yr", "rr", "rb", "bl", "tr", "aa", "inst", "gr", "ar", "xml", "feat", "ir", "arm", "el", "war", "order", "data", "car", "arp", "var", "plot", "mk", "aug", "par", "bb", "ay", "coll", "str", "list", "archive", "r", "lat", "bar", "dict", "adr", "arch", "hr", "ray", "air", "img", "batch", "cache", "work", "int", "arc", "req"], "lignes": ["lignuses", "lignues", "lignmentes", "lignmentses", " ligningines", "Ligns", " lucs", "Lignments", "lignions", "elignions", "lancses", " lignses", "ligningues", " ligninges", "ligningines", "lignmentions", "ligns", "Lignumes", "Lignmentes", " lignings", "lucs", "lignmentumes", "lIGNines", "lignmentues", "elignings", " ligns", "eligns", "lgns", "elignses", "Lignmentumes", "linales", "lancues", " luces", "lucues", "Lignes", "lances", "lgnions", "Lignmentuses", "ligninges", "lignumes", "ligningses", "lignmentuses", "linals", "lIGNumes", "Lignuses", "lignines", "lignings", "lignmentines", "lIGNs", "lgnses", "eligninges", "lIGNues", " lucses", "lignses", "linalses", "lucses", "lancs", "lignments", " lignines", "luces", "elignes", "eligningses", "lgnes", "lIGNes", "ligningions", "ligninguses", "ligningumes", " ligningues", "lIGNuses", " lucues", "eligningions", " lignues", "linalues"], "cols": ["coles", "lld", "lls", "columnabs", "collines", "colabs", "Collines", "colsi", "columnless", " colts", " colals", "coln", " coln", "Colss", "velsi", "COLns", " colless", "colss", " colses", "velless", "Cold", "colops", "llses", "llals", "Colns", "Colses", "Coles", "columnsi", " coles", "columnlines", " colns", "COLn", " cold", "columnts", "velts", "Colabs", "Cols", "Colals", "COLes", " colsi", "vels", "colts", "colns", "colals", "columnes", "Coln", "lles", "colless", "llops", "columns", "llss", "colses", "columnn", "COLs", " colabs", "cold", " colops", " colss", "Colops", " collines"], "y": ["by", "auto", "out", "yang", "cy", "oy", "wy", "any", "c", "gy", "yes", "yd", "ny", "my", "uy", "yy", "ye", "sy", "ch", "yah", "z", "type", "n", "yi", "yu", "yo", "vy", "b", "f", "o", "e", "yr", "ys", "zy", "iy", "id", "p", "xy", "year", "ty", "sys", "yl", "m", "say", "key", "ey", "ry", "ya", "yn", "Y", "fy", "ay", "isy", "ady", "h", "sky", "yt", "yan", "u", "ie", "ky", "ym", "idy", "bar", "hy", "py", "ery", "base", "acy", "python", "dy", "asy", "ix", "arty"], "x": ["xs", "xt", "name", "px", "sex", "by", "xp", "large", "fx", "im", "day", "index", "xc", "php", "wx", "any", "c", "xe", "xx", "yes", "gy", "ax", "page", "my", "event", "X", "ye", "width", "z", "tx", "bit", "dx", "ext", "w", "type", "n", "l", "wa", "s", "time", "pe", "a", "code", "b", "f", "e", "full", "xa", "d", "id", "p", "xy", "xml", "xes", "rx", "cross", "host", "yx", "v", "long", "yl", "na", "m", "el", "alpha", "data", "one", "key", "ey", "shape", "ya", "Y", "at", "size", "xi", "ay", "high", "content", "ady", "h", "xf", "view", "en", "u", "image", "ct", "r", "hy", "q", "ex", "xxx", "work", "int", "python", "dy", "lex", "k", "ix", "no", "g"], "arr2": [" arr1", "arc0", "str2", "array\n", " arr4", "array0", "str1", "arr3", "arr0", " arr3", "arr1", "arr4", "array2", " arr0", "array4", "array1", "str3", "str4", "array3", "arc\n"], "i": ["e", "si", "xi", "d", "id", "h", "p", "I", "u", "z", "ie", "li", "ai", "v", "n", "m", "l", "jp", "ij", "ii", "index", "di", "yi", "c", " ii", "ji", "k", "iu", "b", "f", "o"], "j": ["e", "xi", "d", "uj", "h", "J", "p", "z", "ie", "jl", "li", " k", "jj", "v", "q", " J", "n", "ci", "l", "adj", "jp", "ij", "ii", "kj", "je", "c", " ii", "ja", "jc", "ji", "k", " jo", "ix", " il", "jo", "b", "f", "o", "js", "oj"]}}
{"code": "\\n  f = open(sys.argv[1])\\n  T = int(f.readline())\\n  for test in range(T):\\n      data = f.readline().split()\\n      C = Decimal(data[0])\\n      F = Decimal(data[1])\\n      X = Decimal(data[2])\\n      curr_rate = Decimal(2)\\n      best_time = Decimal(10**100)\\n      curr_time = Decimal(0)\\n      while curr_time < best_time:\\n          poss_finish_time = curr_time + X / curr_rate\\n          if poss_finish_time < best_time:\\n              best_time = poss_finish_time\\n  \\n          curr_time += C / curr_rate\\n          curr_rate += F\\n  \\n      print \"Case #%d: %.7f\" % (test + 1, best_time)\\n", "target": "50", "substitutes": {"f": ["e", "fw", "cf", "fd", "d", "fr", "i", "h", "p", "input", "af", "r", "fo", "fm", "t", "file", "tf", "form", "fb", "v", "stream", "io", "handler", "feed", "w", "m", "l", "fp", "fast", "inf", "fs", "c", "s", "df", "x", "b", "raf", "fc", "g", "folder"], "T": ["N", "Test", "Length", "Time", "O", "I", "TS", "t", "M", "Z", "TH", "TIME", "L", "GT", "WT", "D", "R", "Tu", "B", "S", "TT", "Ts", "E", "H", "Type", "V", "NT", "Y", "Q", "P", "CT", "DT"], "test": [" match", "Test", "loop", " rest", "train", " iT", " trial", " val", "repeat", "testing", "unit", "tri", " count", "match", " fe", "trial", "case", "ver", " z", "t", " d", "long", "example", " tests", " ret", " seq", "thread", "seed", " dummy", "valid", "seq", "rest", "index", "order", " example", " c", " testing", " experiment", "fix", " temp", "tests", "x", "call", " Test", " err", " check", "est", "txt", "diff", "EST", " j", " loop", "check", " text", " ip"], "data": ["d", "fail", "pos", "content", "aa", "json", "package", "slice", "next", "done", "p", "series", "list", "input", "file", "response", "output", "map", "first", "object", "DATA", "na", "string", "parse", "Data", "ata", "feed", "n", "la", "video", "dat", "missing", "index", "value", "ad", "da", "body", "text", "batch", "block", "style", "empty", "s", "split", "a", "message", "line", "lines", "code", "array", "load", "bytes", "info"], "C": ["N", "CF", "U", "G", "Cu", "O", "I", "CL", "CA", "W", "M", "NC", "Z", "K", "EC", "CE", "DC", "CC", "L", "D", "A", "R", "B", "S", "FC", "CO", "c", "CV", "E", "H", "CS", "AC", "CI", "V", "Y", "Q", "P", "CT", "CCC"], "F": ["N", "CF", "U", "G", "FD", "J", "FI", "O", "I", "W", "M", "Z", "L", "D", "FO", "EF", "R", "PF", "B", "GF", "FH", "S", "FC", "FA", "FY", "Fun", "E", "H", "V", "FF", "Y", "Q", "P", "FG", "MF"], "X": ["CF", "U", "CH", "XL", "Cu", "XP", "Time", "Event", "XXX", "CL", "TX", "W", "IP", "File", "Z", "EC", "K", "Data", "CW", "XM", "CC", "L", "R", "S", "FC", "Work", "CR", "H", "x", "V", "FF", "Y", "XX", "P", "Q", "PE"], "curr_rate": ["curr_rates", "curr___base", "curr_depth", "curry_rates", "currpytimer", "curr_timer", "curr8time", "curR_rates", "curr8value", "currpytime", "curR_time", "curr8rate", "curr___rates", "curr___time", "currpyvalue", "curry_time", "curR_timer", "currpyrate", "curR_value", "curr___rate", "curry_depth", "curr_value", "curr8timer", "curr_Rate", "curr_base", "curry_Rate", "curR_rate", "curry_rate", "curR_base"], "best_time": ["best_rate", "best_depth", "practice_method", "best_clock", "bestiantype", " best_tim", "best_times", "better_length", "best01time", "best01Time", "practice_depth", "practice_type", "bestiandepth", "best_method", "best01length", "better_date", "best_type", "bestianmethod", "bestactim", "better_times", "best01times", "better_tim", "bestactime", "better_Time", "bestacclock", "better_rate", "best_tim", "best_Time", "bestactimes", "best_date", "best_length", " best_clock", "better_time", "practice_time", "bestiantime", " best_times"], "curr_time": ["curr_times", "curr_timer", "curr1rate", "curr_scale", "curr7tim", "currjtime", "curr1times", "curr2time", "curr2year", "curr1time", "curr_speed", "currjscale", "curr2tim", "curry_speed", "curr___speed", "curr___time", "curR_time", "curR_timer", "curry_time", "curr___memory", "curR_times", "curr_tim", "curry_scale", "curry_times", "currjtimes", "curr7time", "curr7times", "curr1timer", "curr_year", "curr_memory", "curr___rate", "curry_tim", "curr2times", "currjrate", "curr7year", "curry_year", "curR_rate", "curry_rate", "curry_memory"], "poss_finish_time": ["poss_finishing_rate", "poss_finishing_weight", "poss_finish_size", "poss_finish2time", "poss_finishing_times", "poss_finish_rate", "poss_finishing_size", "poss_finish_weight", "poss_finish2times", "poss_finishing_time", "poss_finish2size", "poss_finishing_mode", "poss_finish_times", "poss_finish_mode"]}}
{"code": "\\n  f = open(sys.argv[1])\\n  T = int(f.readline())\\n  for test in range(T):\\n      R, C, M = map(int, f.readline().strip().split())\\n      Rorig = R\\n      Corig = C\\n      impossible = False\\n      grid = [['.' for i in range(C)] for j in range(R)]\\n  \\n      curr_coord = [0,0]\\n      while M > 0 and not impossible:\\n          if (C > R): # more columns - fill one in\\n              num_mines_in_column = R\\n              if M < R:\\n                  num_mines_in_column = min(R - 2, M)\\n              if num_mines_in_column <= 0:\\n                  impossible = True\\n                  break\\n              for ii in range(num_mines_in_column):\\n                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'\\n              C -= 1\\n              curr_coord[1] += 1\\n              M -= num_mines_in_column\\n          else:\\n              num_mines_in_row = C\\n              if M < C:\\n                  num_mines_in_row = min(C - 2, M)\\n              if num_mines_in_row <= 0:\\n                  impossible = True\\n                  break\\n              for ii in range(num_mines_in_row):\\n                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'\\n              R -= 1\\n              curr_coord[0] += 1\\n              M -= num_mines_in_row\\n  \\n      print \"Case #%d:\" % (test + 1)\\n      if impossible:\\n          print \"Impossible\"\\n      else:\\n          for ii in range(Rorig):\\n              for jj in range(Corig):\\n                  if grid[ii][jj] == '.':\\n                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':\\n                          grid[ii][jj] = 'dirty'\\n                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\\n                          grid[ii][jj] = 'dirty'\\n                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\\n                          grid[ii][jj] = 'dirty'\\n  \\n          for ii in range(Rorig):\\n              for jj in range(Corig):\\n                  if grid[ii][jj] == 'dirty':\\n                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':\\n                          grid[ii][jj] = '.'\\n                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':\\n                          grid[ii][jj] = '.'\\n                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\\n                          grid[ii][jj] = '.'\\n                      else:\\n                          if ii != Rorig - 1 or jj != Corig - 1:\\n                              impossible = True\\n  \\n          if impossible:\\n              print \"Impossible\"\\n          else:\\n              grid[Rorig-1][Corig-1] = 'c'\\n  \\n              for ii in range(Rorig):\\n                  print \" \".join([val for val in grid[ii]])\\n  \\n  \\n", "target": "50", "substitutes": {"f": ["e", "fw", "fd", "d", "fr", "fn", "h", "p", "fx", "r", "lf", "af", "z", "fo", "handler", "t", "file", "tf", "form", "fb", "v", "ref", "io", "feed", "w", "iter", "m", "l", "fp", "fast", "fs", "g", "c", "s", "F", "buff", "x", "b", "o", "fen", "info", "folder"], "T": ["N", "Test", "U", "X", "TF", "TN", "Time", "O", "I", "TS", "TB", "t", "TA", "Z", "L", "WT", "D", "B", "S", "TT", "Ts", "TG", "TC", "Tab", "E", "H", "F", "Type", "V", "Y", "Q", "P", "CT", "DT"], "test": ["e", "d", "tr", " ti", " now", " me", " cp", "ct", "r", "nt", " z", "t", "n", " seq", "py", "tim", "ti", "times", "c", "time", " temp", " check", "code", "ind", " b", "g"], "R": ["N", "Rh", "AR", "U", "RH", "G", "X", "J", "RE", "RR", "I", "MR", "r", "W", "Rs", "K", "RW", "SR", "RN", "Right", "RO", "L", "D", "A", "ER", "B", "RS", "S", "RP", "CR", "E", "H", "F", "V", "RM", "Y", "Ra", "NR", "Q", "P", "RT", " r", "RA", "RG"], "C": ["N", "CF", "Cs", "JC", "U", "RH", "Cy", "G", "X", "Co", "Cu", "O", "I", "Size", "CNN", "CL", "CA", "W", "NC", "CM", "K", "EC", "Cl", "CE", "DC", "CC", "L", "D", "A", "CN", "B", " c", "S", "CO", "c", "CV", "CR", "E", "H", "F", "CI", "V", "CU", "Y", "P", "CT"], "M": ["N", "U", "G", "X", "J", "O", "MOD", "I", "r", "W", "MD", "MS", "JM", "MT", "m", "MN", "L", "D", "MC", "B", "DM", "S", "IM", "E", "H", "F", "V", "RM", "MON", "Y", "Q", "P", "PM"], "Rorig": ["TOrig", "ROrig", "Tseq", "RGcoll", "Torig", "RGOrig", "RGorig", "Tcoll", "Rseq", "RGseq", "Ccoll", "Rcoll", "Cseq", "COrig"], "Corig": ["corigs", "corig", "CorIG", "corIG", " Corrig", "Stig", "Strig", "Corrig", "Corigs", " Corigs", "StIG", "Stigs", "corrig", " CorIG"], "impossible": ["possibly", "Impact", "possible", "Impossibility", "pact", "compable", "compossible", "ispact", "impable", "Impossible", "pable", "impossibly", "possibility", "Impossibly", "impact", "Impable", "ispossibly", "impossibility", "compossibly", "compossibility", "ispossible", "ispossibility"], "grid": [" cells", " trace", "ID", " grids", "id", " cell", " id", " row", " Q", " mat", " chain", " QR", " data", "mat", " sim", " seq", " solution", "A", " np", " G", " mask", " structure", " block", " residue", " Grid", "chain", " coord", "Grid"], "i": ["e", "gi", "d", "id", "h", "ac", "p", " I", "op", "I", "im", "ie", "z", "ai", "co", "ir", "q", "ci", "ib", "pc", "bc", "a", " bi", "ix", "y", "b", "o", "iw", "g"], "j": ["d", "pos", "id", "num", "J", "ar", "u", "im", "ct", "z", "r", "ie", "co", "ym", "ir", "q", " J", "n", "jp", "ij", "cor", "c", "k", "x", "y", "b", "ind", "g"], "curr_coord": ["curvr2coord", "curvr_num", "curr_orig", "curvr_coord", "curr2coord", "curr2pos", "curr2num", "curvr2pos", "curvr_orig", "curr2orig", "curr_num", "curvr_pos", "curr_pos", "curvr2num", "curvr2orig"]}}
{"code": "\\n  \\n  \\n  \\n  tCase = int(sys.stdin.readline())\\n  \\n  def calcTemp(taxa, X):\\n  \treturn X/taxa;\\n  \\n  def main(C, F, X):\\n  \\n  \ttaxa = 2.0\\n  \tresp = 0\\n  \t\\n  \t\\n  \twhile True:\\n  \t\tif C/taxa + calcTemp(taxa + F, X) < calcTemp(taxa, X):\\n  \t\t\tresp += C/taxa\\n  \t\t\ttaxa += F\t\t\t\\n  \t\telse:\\n  \t\t\tresp += calcTemp(taxa, X)\\n  \t\t\treturn resp\\n  \t\\n  \t\\n  \treturn 0\\n  \t\t\\n   \\n  if __name__ == '__main__':\\n  \tfor i in xrange(tCase):\t\\n  \t\t\\n  \t\tC, F, X = [float(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tprint \"Case #%d: %s\" % (i + 1, main(C, F, X))\\n", "target": "51", "substitutes": {"tCase": ["TCode", "fStep", "dtCase", "tCountry", "TCountry", "tcCase", "TCase", "dtTest", "dtCountry", "fCode", " tCountry", "dtcase", " tTest", "TStep", "TTest", "fCase", "tTest", "tcStep", "fcase", "tStep", "tcCode", "tcase", "tCode", "tccase", "Tcase", " tcase"], "taxa": ["cartA", "taxA", "carta", "cartan", "TaxA", "axas", "cartb", "axae", "taxea", "lexae", "planta", "Taxa", "oxea", "taxe", "oxas", "taxaa", "oxb", " taxaa", "genan", "ttA", "oxi", "plantb", "plantA", "lexo", "lexas", "plantas", "axaa", " taxan", "oxan", "gena", "lexa", "axA", " taxi", "cartas", " taxA", "lexA", " taxas", "tta", "taxan", "tte", "ttan", " taxe", "axi", "axa", "oxa", "Taxb", "taxae", "genA", "lexea", "oxA", " taxo", "axan", "Taxe", " taxea", "oxaa", "taxo", "Taxan", "taxi", " taxae", "taxas", "axo", "taxb", " taxb"], "X": ["N", "WS", "U", "UC", "XL", "G", "XP", "ZX", "IX", "Event", "XXX", "I", "CL", "TX", "CA", "W", "IP", "M", "Z", "CE", "K", "Value", "MX", "XM", "CC", "L", "EX", "Cross", "D", "A", "R", "HTTP", "T", "Int", "B", "FX", "Ex", "FC", "Work", "FE", "CR", "E", "H", "Rex", "UX", "V", "DX", "FF", "Form", "XY", "Y", "Q", "P", "XX", "PE", "Location"], "C": ["N", "CF", "Cs", "JC", "U", "UC", "G", "Ch", "Co", "Cu", "O", "COR", "I", "CL", "CNN", "CA", "W", "M", "CM", "K", "CE", "VC", "EC", "DC", "CC", "L", "D", "A", "Case", "R", "T", "B", "S", "FC", "c", "CV", "CR", "E", "CI", "V", "CU", "Y", "P", "CT", "CCC"], "F": ["N", "CF", "U", "G", "Fs", "FD", "DF", "OF", "O", "I", "FB", "W", "File", "M", "Z", "K", "Fin", "Fi", "L", "D", "A", "EF", "R", "FO", "T", "PF", "B", "FH", "GF", "FM", "FC", "Fine", "Fun", "E", "H", "SF", "API", "V", "Form", "FF", "Y", "Q", "P", "f", "FG", "MF", "FW", "Fe"], "resp": ["camp", "col", "par", "pos", "bb", "num", "cmp", "eff", "xp", "ac", "p", "exit", "ll", "aff", "conn", "acc", "nt", "r", "response", "z", "exp", "ref", "cond", "nz", "res", "rep", "na", "rec", "conf", "respond", "CC", "seq", "comp", "Rec", "rev", "rh", "frac", "c", "cache", "temp", "Response", "Resp", "success", "esp", "result", "fe", "tmp", "err", "f", "req", "lc"], "i": ["e", "gi", "si", "ini", "xi", "ip", "col", "mi", "id", "mini", "slice", "p", "j", "I", "zi", "ie", "z", "li", "pi", "ai", "uri", "type", "n", "ci", "index", "ii", "bi", "di", "c", "int", "a", "phi", "ix", "ri", "code", "iu", "ind", "f"], "x": ["e", "ctx", "xs", "xi", "xt", "xp", "xf", "fx", "p", "xy", "u", "ct", "rx", "z", "r", "v", " xp", " f", "dx", "w", "n", "m", " np", "ex", "xc", "www", "xxx", "wx", " c", "xxxx", "c", " cx", "int", "test", "xx", "y", "code", "XX", "f", "ax"]}}
{"code": "\\n  \\n  tCase = int(sys.stdin.readline())\\n  \\n  \\n  def map(R, C, Bombs):\\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\\n  \tprint Bombs\\n  \tm[R-1][C-1] = 'c'\\n  \tlastSkip = False\\n  \tfor i in xrange(R):\\n  \t\tfor j in xrange(C):\\n  \t\t\tif Bombs == 0:\\n  \t\t\t\tbreak\\n  \t\t\t\\n  \t\t\tif lastSkip:\\n  \t\t\t\tm[i][j] = 'f'\\n  \t\t\t\tcontinue\\n  \t\t\t\\n  \t\t\tif R - i == 2 or C - j == 2:\\n  \t\t\t\tif Bombs == 1:\\n  \t\t\t\t\tm[i][j] = 'f'\\n  \t\t\t\t\tlastSkip = True\\n  \t\t\t\t\tcontinue\\n  \t\t\t\\n  \t\t\t\t\\n  \t\t\tm[i][j] = '*'\\n  \t\t\tBombs -= 1\\n  \t\t\tlastSkip = False\\n  \t\tlastSkip = False\\n  \t\t\t\t\\n  \t\\n  \t\\n  \tfor line in m:\\n  \t\tfor c in line:\\n  \t\t\tprint c,\\n  \t\tprint\\n  \t\t\\n  \t\t\\n  def imprimir(m):\\n  \tfor line in m:\\n  \t\tfor c in line:\\n  \t\t\tprint c,\\n  \t\tprint\\n  \t\t\\n  def map2(R, C, Bombs):\\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\\n  \tm[R-1][C-1] = 'c'\\n  \tlastSkip = False\\n  \t\\n  \tii = 0\\n  \tjj = 0\\n  \twhile Bombs > 0:\\n  \t\tfor j in xrange(jj, C):\\n  \t\t\tif Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\\n  \t\t\t\tm[ii][j] = '*'\\n  \t\t\t\tBombs -= 1\\n  \t\t\telse:\\n  \t\t\t\tcontinue\\n  \t\t\\n  \t\t\\n  \t\tfor i in xrange(ii+1, R):\\n  \t\t\tif Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\\n  \t\t\t\tm[i][jj] = '*'\\n  \t\t\t\tBombs -= 1\\n  \t\t\telse:\\n  \t\t\t\tif Bombs > 0:\\n  \t\t\t\t\tprint \"Impossible\"\\n  \t\t\t\t\treturn\\n  \t\t\t\tcontinue\\n  \t\tjj += 1\\n  \t\tii += 1\\n  \timprimir(m)\\n  \t\\n  \t\t\t\t\\n  \t\\n  \t\\n  \\n  \t\t\\n  def main(R, C, M):\\n  \tvazios = R * C - M\\n  \\n  \tif R == 1 or C == 1 or vazios == 1 or vazios >= 4:\\n  \t\tmap2(R, C, M)\\n  \telse:\\n  \t\tprint \"Impossible\"\\n  \\n  \treturn \"\"\\n  \t\t\\n   \\n  if __name__ == '__main__':\\n  \tfor i in xrange(tCase):\t\\n  \t\t\\n  \t\tR, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tprint \"Case #%d:\" % (i + 1)\\n  \t\tmain(R, C, M)\\n", "target": "51", "substitutes": {"tCase": ["ttcase", "tfPath", "TPath", "tfcases", "TName", "tfName", "TCase", "ttPath", "tName", "tcase", "ttName", " tcases", "Tcases", "tPath", "tfCase", "Tcase", "ttCase", " tPath", "tcases", " tcase", "tfcase"], "R": ["N", "Rh", "TR", "AR", "U", "RH", "G", "X", "RL", "Block", "J", "RE", "O", "RIP", "RR", "KR", "I", "CL", "Role", "r", "W", "Rs", "Range", "Cl", "Line", "K", "RW", "RO", "SR", "RN", "Right", "Re", "L", "Sc", "Res", "D", "A", "ER", "JR", "T", "B", "RS", "Rec", "S", "Par", "BR", "RP", "CR", "E", "H", "Br", "F", "IR", "V", "Run", "DR", "GR", "All", "RM", "WR", "Y", "Ra", "Region", "Q", "P", "NR", " r", "LR", "RA", "RG"], "C": ["N", "JC", "Cs", "CF", "U", "G", "Ch", "X", "SC", "Cu", "J", "O", "I", "CL", "CNN", "Size", "CA", "W", "YC", "Cl", "CM", "VC", "K", "EC", "CE", "GC", "DC", "RFC", "CW", "Ca", "CC", "L", "Sc", "D", "A", "CN", "T", "MC", "B", "S", "KC", "CV", "CR", "E", "H", "AC", "CS", "CI", "F", "V", "CU", "Y", "Q", "P", "Code", "Cr"], "Bombs": ["Fomb", "Subunks", "Bandals", "Bategories", "basm", "Bauts", " Bombie", "Balosion", "Bbusters", "Bootlocks", "Ubambers", "Buffauts", "Blombs", "bombs", "Bombie", "UBresses", "Suborers", "BWombs", "Blategories", "PBombs", "Besses", "bambers", "Balandals", "Blouts", "PBowers", "Ubauts", "Ambones", "Phomers", "Bootorders", "besses", "FBresses", "Phombs", " Bomes", " Bunks", "BBaos", "bbusters", "SBandals", "PBorders", "Fombs", "MBombs", "bounces", "Baches", "UBashes", "BWaos", "Bambers", "bowers", "bumbs", "Businessategories", "Bashes", " Bones", "Blocks", "Blockombs", "FBballs", "Subandals", "bandals", " Baos", "Bacteria", "GBambers", "Bootombs", "Ubombs", " Besses", "Barees", "Buffurches", "GBiers", "Fambers", "BBombies", "Blacteria", "Ambbusters", "BFomers", "SBorers", "OBombies", "Burches", "Bunks", "Bounces", "FBashes", "Bosion", "GBombies", "BBasm", "Ambomas", "UBombs", " Bbusters", " Bballs", " Bandals", "Bomb", "bauts", "Balashes", "brees", "bouts", "blocks", "Lumbs", "SBombs", "BFomes", "BBomb", "SBunks", "BFauts", "Louts", "Biers", "Ambombs", "BBacteria", "Balouts", " Bomb", "Buffombs", " Bauts", "OBambers", "Subombs", "Businessombies", "Balacteria", "BBouts", "MBambers", "baches", "Bliers", "Baombs", "BWumbs", "Balauts", "Baos", " Bomas", "BFaches", "Bomas", "Ubballs", " Basm", "BBombs", "UBballs", "Phauts", "Lambers", "Bouts", " Bouts", "bballs", "Borders", "PBlocks", "BFesses", "Businessiers", "Blockandals", "BFurches", "baos", "Lombs", "BWomb", "Baounces", "Bones", "Balresses", "Buffomers", "Bomes", "Blockosion", "bosion", "GBumbs", "Bresses", "Bootowers", "Bomers", "GBategories", " Bounces", "OBumbs", "Blockauts", " Borers", "Phurches", "BFombs", "Forders", "bomas", "Bumbs", "Bowers", "Businessombs", "Balombies", " Bumbs", "bombie", "Borers", "Blombies", "GBombs", "Brees", "borders", "bones", "MBumbs", "Balballs", "bomb", "Bballs", " Baches", "MBombies", "bomes", " Bambers", " Borders", "Baombie", "OBombs", " Brees", "Bombies", "FBombs", "Balombs", "Basm"], "m": ["e", "ms", "mc", "em", "module", "d", "mi", "om", "dm", "mini", "h", "vm", "p", "pm", "man", "mr", "sm", "mu", "rm", "u", "im", "mm", "r", "bm", "fm", "t", "z", "mos", "media", "v", "ym", "form", "am", "lin", "um", "mo", "w", "hm", "n", "l", "machine", "md", "ml", "semble", "s", "a", "message", "ma", "y", "b", "cm", "f", "o", "g", "gm", "wm"], "x": ["full", "ctx", "e", "xi", "xt", "ux", "xs", "event", "id", "ww", "X", "sex", "word", "h", "xp", "xxxxxxxx", "xf", "fx", "p", "xy", "xes", "u", "rx", "z", "r", "cross", "tx", "t", "on", "v", "co", "_", "w", "q", "n", "rex", "l", "index", "ex", "vent", "xc", "xxx", "rax", "xxxx", "work", "a", "lex", "ph", "k", "xx", "ix", "y", "code", "XX", "b", "f", "nex", "ax"], "lastSkip": ["firstskip", "latestskip", " Lastskip", " LastDiff", "nextCopy", "lastCopy", " lastDiff", " lastCopy", "LastHop", "Lastskip", "firstCopy", "firstJump", "lastDiff", "latestHop", "nextSkip", " lastHop", " LastCopy", " lastskip", "LastSkip", " LastSkip", "lastJump", "latestSkip", "LastDiff", "lastHop", "nextskip", "LastJump", "lastskip", "firstSkip", "latestCopy", "nextJump", "LastCopy", " lastJump"], "i": ["e", "gi", "ini", "si", "xi", "ip", "ori", "d", "mi", "id", "h", "p", "fi", "it", "I", "vi", "u", "im", "iv", "ie", "z", "r", "multi", "pi", "ai", "li", "v", "ui", "ili", "io", "ni", "ir", "q", "ci", "n", "l", "ij", "ei", "bi", "ti", "di", "yi", "ani", "int", "a", "ji", "ic", "ix", "y", "ri", "iu", "b", "f", "o", "g", "eni", "qi"], "j": ["e", "xi", "d", "uj", "h", "J", "p", "ch", "jet", "u", "im", "z", "r", "jl", "ie", "li", "v", "note", "ir", "w", "q", "n", "ci", "l", "adj", "jp", "ij", "dj", "java", "job", "je", "ja", "jc", "a", "jit", "ji", "k", "ix", "y", "aj", "jo", "b", "f", "ind", "o", "g", "js", "oj"], "line": ["page", "range", "mc", "ine", "inline", "word", "lo", "online", "liner", "lined", "ode", "point", "lace", "case", "ync", "change", "li", "Line", "co", "long", "lin", "string", "nl", "n", "log", "l", "cl", "link", "ino", "lining", "sync", "block", "ner", "end", "cell", "set", "call", "course", "nc", "main", "cycle", "eline", "ze", "lines", "code", "cm", "le", "chain", "no", "o", "ite", "lock", "lc", "store"], "c": ["e", "mc", "d", "h", "ac", "dc", "p", "ce", "out", "case", "z", "r", "cat", "co", "cu", "cs", "w", "cy", "uc", "ci", "n", "l", "cl", "xc", "cd", "pc", "cc", "cache", "unc", "a", "k", "ec", "cycle", "nc", "code", "sc", "b", "cm", "f", "fc", "cr", "g", "lc"], "ii": ["gi", "si", "ini", "xi", "mini", "abi", "qa", "ari", "fi", "vi", "iii", "iv", "zi", "ie", "z", "jl", "li", "pi", "ai", "ih", "ni", "sci", "ui", "ski", "ci", "jp", "ij", "ice", "ei", "inf", "bi", "di", "ani", "jc", "ji", "ix", "ri", "iu", "ind", "II", "iw", "uni", "info", "qi"], "jj": ["ki", "JC", "gi", "aq", "bb", "yy", "JJ", "uj", "ww", "rc", "qa", "J", "Jump", "NJ", "ZZ", "iii", "mm", "jl", "li", "pi", "ai", "Ja", "ni", "nn", "q", "ci", "CC", "dj", "jp", "ij", "JR", "kj", "java", "di", "cc", "ja", "gh", "jc", "jit", "ji", "xx", "jump", "ix", "aj", "ri", "jo", "IJ", "II", "iw", "III", "qi"], "M": ["N", "U", "MO", "G", "X", "MI", "J", "O", "LM", "I", "W", "MD", "MS", "Z", "CM", "K", "MX", "MN", "L", "Mo", "D", "A", "MU", "MC", "T", "B", "E", "H", "AM", "F", "V", "Man", "RM", "Y", "Q", "P", "MF"], "vazios": ["vzio", "baudixels", "vaudixels", "Vazenos", "Vazits", "baudlos", "vachio", "vzios", "vaudicals", "vazixels", "Vazio", "Vzenos", "vazeios", " vaudicals", "baudiol", "vasixels", " vaudicho", " vazicals", "Vzio", "baziol", "vazicals", "vzenos", "vaudlos", "bazixels", "bazlos", "vazeenos", "vaziol", "vaxio", "vaudiol", "vazeio", "vazits", "vaxicho", " vaudios", "vasios", "vazeiol", "vzits", "vazio", "vazeixels", "vzicals", "vazenos", "vaxios", "vasiol", " vazicho", "vachios", "bazios", "vachits", "Vzios", "vaudicho", "baudios", "vazeits", "vazicho", "vaudio", "Vzits", "vzicho", "vaudios", " vazio", "vaxicals", "Vazios", "vaslos", "vazelos", "vazlos", "vachenos", " vaudio"]}}
{"code": "\\n  def debug(v):\\n      pass#print(v)\\n  \\n  def read(f):\\n      t = tuple(int(v) for v in f.readline().split())\\n      debug(t)\\n      return t\\n  \\n  def readf(f):\\n      t = tuple(float(v) for v in f.readline().split())\\n      debug(t)\\n      return t\\n  \\n  def answer(f, X, ans):\\n      out = \"Case #{}: {}\".format(X, ans)\\n      f.write(out)\\n      f.write(\"\\n\")\\n      print(out)\\n  \\n  \\n  \\n  def main(inf, outf):\\n      T, = read(inf)\\n      for casenmbr in range(1, T + 1):\\n          C, F, X = readf(inf)\\n  \\n          power = 2\\n          farmtime = round(C / power, 7)\\n          keikatime = 0\\n          totaltime = round(X / power, 7)\\n  \\n          while True:\\n              keikatime += farmtime\\n              power += F\\n              farmtime = round(C / power, 7)\\n              nokoritime = round(X / power, 7)\\n              if keikatime + nokoritime > totaltime:\\n                  break\\n              totaltime = keikatime + nokoritime\\n  \\n          answer(outf, casenmbr, totaltime)\\n  \\n  \\n  if __name__==\"__main__\":\\n      infname = sys.argv[1]\\n      outfname = os.path.splitext(infname)[0] + \".out\"\\n      with open(infname, \"r\") as inf:\\n          with open(outfname, \"w\") as outf:\\n              main(inf, outf)\\n", "target": "52", "substitutes": {"v": ["vals", "h", "lv", "p", "j", "vv", "u", "val", "w", "vd", "m", "n", "kernel", "vp", "value", "data", "conv", "model", "c", "sv", "vs", "V", "env", "uv", "f", "o", "version", "g"]}}
{"code": "\\n  def debug(v):\\n      pass#print(v)\\n  \\n  def read(f):\\n      t = tuple(int(v) for v in f.readline().split())\\n      debug(t)\\n      return t\\n  \\n  def readf(f):\\n      t = tuple(float(v) for v in f.readline().split())\\n      debug(t)\\n      return t\\n  \\n  def answer(f, X, ans):\\n      out = \"Case #{}:\\n{}\".format(X, ans)\\n      f.write(out)\\n      f.write(\"\\n\")\\n      print(out)\\n  \\n  def answer_cells(f, X, cells):\\n      out = \"Case #{}:\".format(X)\\n      f.write(out)\\n      f.write(\"\\n\")\\n      print(out)\\n      for row in cells:\\n          out = \"\".join(row)\\n          f.write(out)\\n          f.write(\"\\n\")\\n          print(out)\\n  \\n  def main(inf, outf):\\n      T, = read(inf)\\n      for casenmbr in range(1, T + 1):\\n          R, C, M = read(inf)\\n  \\n          if M == 0:\\n              cells = [['.'] * C for i in range(R)]\\n              cells[0][0] = 'c'\\n              answer_cells(outf, casenmbr, cells)\\n              continue\\n  \\n          empty = R * C - M\\n  \\n          if empty == 1:\\n              cells = [['*'] * C for i in range(R)]\\n              cells[0][0] = 'c'\\n              answer_cells(outf, casenmbr, cells)\\n              continue\\n  \\n          if R == 1 or C == 1:\\n              cells = [['.'] * C for i in range(R)]\\n              m = 0\\n              for r in range(R):\\n                  for c in range(C):\\n                      cells[r][c] = '*'\\n                      m += 1\\n                      if m == M:\\n                          break\\n                  else:\\n                      continue\\n                  break\\n              cells[-1][-1] = 'c'\\n              answer_cells(outf, casenmbr, cells)\\n              continue\\n  \\n          if empty in (2, 3, 5, 7):\\n              answer(outf, casenmbr, \"Impossible\")\\n              continue\\n  \\n          if (R == 2 or C == 2) and empty % 2:\\n              answer(outf, casenmbr, \"Impossible\")\\n              continue\\n  \\n          cells = [['*'] * C for i in range(R)]\\n  \\n  \\n          cells[0][0] = 'c'\\n          empty -= 1\\n          cc = 1\\n          rr = 1\\n          while empty > 0:\\n              if cc < C:\\n                  for r in range(rr):\\n                      if empty == 2 and r == rr - 1:\\n                          break\\n                      cells[r][cc] = '.'\\n                      empty -= 1\\n                      if empty == 0:\\n                          break\\n                  cc += 1\\n              if rr < R and empty > 0:\\n                  for c in range(cc):\\n                      if empty == 2 and c == cc - 1:\\n                          break\\n                      cells[rr][c] = '.'\\n                      empty -= 1\\n                      if empty == 0:\\n                          break\\n                  rr += 1            \\n  \\n          answer_cells(outf, casenmbr, cells)\\n  \\n  \\n  if __name__==\"__main__\":\\n      infname = sys.argv[1]\\n      outfname = os.path.splitext(infname)[0] + \".out\"\\n      with open(infname, \"r\") as inf:\\n          with open(outfname, \"w\") as outf:\\n              main(inf, outf)\\n", "target": "52", "substitutes": {"v": ["vals", "h", "lv", "p", "j", "vv", "u", "val", "w", "vd", "m", "n", "kernel", "vp", "value", "data", "conv", "model", "c", "sv", "vs", "V", "env", "uv", "f", "o", "version", "g"]}}
{"code": "\\n  \\n  def solve(C, F, X):\\n      rate = 2.0\\n      time_to_win = X / rate\\n  \\n      time_used = C / rate\\n      rate += F\\n      time_to_win_new = time_used + X / rate\\n  \\n      while time_to_win_new < time_to_win:\\n          time_to_win = time_to_win_new\\n          \\n          time_used += C / rate\\n          rate += F\\n          time_to_win_new = time_used + X / rate\\n  \\n      return time_to_win\\n  \\n  def main():\\n      N = int(sys.stdin.readline()) # number of testcases\\n      for i in range(N):\\n          [C, F, X] = [float(x) for x in sys.stdin.readline().rstrip().split()]\\n  \\n          result = solve(C, F, X)\\n          print (\"Case #%s: %.7f\" % (i+1, result))\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "target": "53", "substitutes": {"C": ["CF", "Cs", "U", "G", "SC", "Cu", "CL", "CA", "W", "YC", "M", "NC", "CM", "VC", "K", "CE", "EC", "GC", "DC", "CC", "L", "D", "A", "R", "MC", "T", "B", "S", "c", "CV", "CR", "E", "H", "CS", "CI", "V", "CU", "Y", "P"], "F": ["CF", "U", "G", "Fs", "FD", "DF", "OF", "FI", "O", "I", "FB", "W", "M", "K", " f", "FIN", "L", "D", "A", "EF", "GF", "PF", "T", "FH", "FM", "WF", "B", "FE", "E", "H", "V", "FF", "Y", "FILE", "Q", "P", "f", "FG", "FW"], "X": ["CF", "U", "XL", "SC", "XP", "ZX", "Time", "IX", "XXX", "CL", "TX", "W", "M", "NC", "Z", "CE", "K", "ICE", "EC", "XM", "CC", "L", "D", "R", "HTTP", "T", "FX", "Ex", "FC", "TC", "CR", "E", "H", "AC", "UX", "ACE", "time", "x", "V", "DX", "FF", "Y", "Q", "P", "XX", "PE"], "rate": ["ave", "ge", "rand", "weight", "gam", " Rate", "ime", "tie", "case", "acc", "exp", "cry", "race", "prime", "slave", "rank", "seed", "gain", "delay", "complex", "con", "cm", "float", "ate", "ground", "se", "range", "speed", "rule", "rated", "rake", "width", "ride", "write", "root", "currency", "die", "feed", "type", "sample", "fine", "time", "test", "cycle", "buffer", "code", "score", "feature", "go", "Rate", "date", "rice", "core", "grade", "rates", "CR", "factor", "ry", "frequency", "fre", "rating", "size", "charge", "rage", "unit", "rat", "level", "dry", "late", "erate", "sync", "base", "dy", "fee", "grow", "cr", "cale", "mode", "scale"], "time_to_win": ["time_to_min", "time_to_window", "time_to_run", "time_from_Win", "time_from_win", "time_to_bin", "time_to_int", "time_from_int", "time_from_bin", "time_to_Win"], "time_used": [" time_limited", "time_needed", " time_use", "time_limited", "time96limited", "Time_used", "time01used", " time_available", "time_opened", "Time_usage", "time96use", "time2available", "time2used", "time96available", "time01available", "time2needed", "time_use", "time96used", "time01needed", " time_opened", "time01opened", "Time_available", "time_usage", "Time_use", " time_needed", "time_available", "Time_needed", "time2usage"], "time_to_win_new": ["time_to_wintnew", "time_to_wintold", "time_to_bin_now", "time_to_bin_new", "time_to_win_now", "time_to_bin_ew", "time_to_wintNew", "time_to_wintew", "time_to_win_old", "time_to_win_ew", "time_to_bin_New", "time_to_bin_old", "time_to_win_New"], "N": ["Count", "Time", "I", "Size", "Rate", "Num", "M", "NC", "Z", "Line", "K", "n", "L", "D", "A", "R", "fine", "S", "Ns", "process", "NT", "Y", "P", "Number"]}}
{"code": "\\n  \\n  def neighbours(grid, (i, j), n, m):\\n      for a in range(max(i-1, 0), min(i+2, n)):\\n          for b in range(max(j-1, 0), min(j+2, m)):\\n              if (a != i or b != j):\\n                  yield (a, b)\\n  \\n  def isGridCorrect(grid):\\n      g = list(grid)\\n      n = len(g)\\n      m = len(g[0])\\n      queue = [(0, 0)]\\n  \\n      while queue:\\n          v = queue.pop(0)\\n          g[v[0]][v[1]] = 'r'\\n          bomb = False\\n          for (i, j) in neighbours(g, v, n, m):\\n              if g[i][j] == '*':\\n                  bomb = True\\n          if not bomb:\\n              for (i, j) in neighbours(g, v, n, m):\\n                  if g[i][j] != 'r':\\n                      queue.append((i, j))\\n  \\n      for i in range(n):\\n          for j in range(m):\\n              if g[i][j] != 'r' and g[i][j] != '*':\\n                  return 'WRONG'\\n  \\n      return 'Right'\\n  \\n  def createGrid(R, C, s):\\n      field = []\\n      for i in range(R):\\n          field.append([s] * C)\\n      field[0][0] = 'c'\\n      return field\\n  \\n  def draw(grid):\\n      s = \"\"\\n      for row in grid:\\n          s += \"\\n\" + ''.join(row)\\n      return s\\n  \\n  def reduceRows(grid, k, l, M):\\n      if k <= 2:\\n          return (grid, k, l, M)\\n      \\n  \\n      for j in range(l):\\n          grid[k-1][j] = '*'\\n      k -= 1\\n      M -= l\\n      return (grid, k, l, M)\\n  \\n  def reduceCols(grid, k, l, M):\\n      if l <= 2:\\n          return (grid, k, l, M)\\n      \\n  \\n      for i in range(k):\\n          grid[i][l-1] = '*'\\n      l -= 1\\n      M -= k\\n      return (grid, k, l, M)\\n  \\n  def solve(R, C, M):\\n      mp = M\\n      if M == 0:\\n          f = createGrid(R, C, '.')\\n          return draw(f)\\n      elif M == R*C - 1:\\n          f = createGrid(R, C, '*')\\n          return draw(f)\\n      elif (R == 2 or C == 2) and (M % 2 == 1 or M == R*C - 2):\\n          return \"\\n\" + 'Impossible' #+ '1: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\\n      elif R > 2 and C > 2 and (M == R*C - 2 or M == R*C - 3 or M == R*C - 5 or M == R*C - 7):\\n          return \"\\n\" + 'Impossible' #+ '2: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\\n      else:\\n          grid = createGrid(R, C, '.')\\n  \\n  \\n          k = R\\n          l = C\\n  \\n          while (M >= l and k > 2) or (M >= k and l > 2):\\n              if l >= k:\\n                  (grid, k, l, M) = reduceCols(grid, k, l, M)\\n              elif k > l:\\n                  (grid, k, l, M) = reduceRows(grid, k, l, M)\\n  \\n  \\n          if M == 0:\\n              return draw(grid)\\n          if M < l - 1 and k > 2:\\n              for j in range(l - M, l):\\n                  grid[k-1][j] = '*'\\n          elif M < k - 1 and l > 2:\\n              for i in range(k - M, k):\\n                  grid[i][l-1] = '*'\\n          elif l > 3 and k > 3:\\n              for i in range(2, k):\\n                  grid[i][l-1] = '*'\\n              M -= k - 2\\n              for j in range(l - M - 1, l - 1):\\n                  grid[k-1][j] = '*'\\n          else:\\n              return \"\\n\" + 'Impossible' #+ '3: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\\n  \\n          return draw(grid)\\n  \\n  def main():\\n      N = int(sys.stdin.readline()) # number of testcases\\n      for i in range(N):\\n          [R, C, M] = [int(x) for x in sys.stdin.readline().rstrip().split()]\\n  \\n          result = solve(R, C, M)\\n          print (\"Case #%s:%s\" % (i+1, result))\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "target": "53", "substitutes": {"grid": ["ge", "json", "filter", "card", "uri", "div", "query", "graph", "zip", "mod", "c", "cell", "house", "gae", "node", "site", "db", "gm", "table", "rule", "gap", "flat", "record", "edge", "remote", "storage", "dim", "window", "ga", "code", "array", "game", "server", "update", "module", "client", "d", "id", "cart", "play", "gui", "slice", "layout", "xml", "input", "multi", "file", "form", "ht", "layer", "csv", "magic", "grade", "live", "data", "block", "model", "frame", "chain", "draw", "lock", "bug", "dom", "cube", "panel", "unit", "list", "u", "column", "gu", "spec", "cli", "group", "parse", "connection", "q", "age", "sync", "cache", "line", "contact", "Grid"], "n": ["N", "e", "size", "d", "ne", "ns", "num", "len", "h", "p", "en", "u", "z", "r", "an", "t", "nt", "on", "nm", "ni", "un", "w", "q", "np", "c", "ln", "sn", "x", "nc", "y", "o", "mn"], "m": ["e", "N", "size", "ms", "mc", "d", "mi", "om", "h", "p", "pm", "sm", "en", "u", "im", "mm", "r", "z", "an", "fm", "ym", "nm", "w", "tm", "c", "dim", "min", "y", "cm", "o", "mn"], "a": ["e", "d", "aa", "ac", "p", "ap", "ar", "ba", "af", "u", "an", "ai", "am", "na", "pa", "sa", "asa", "va", "ae", "ak", "alpha", "A", "ca", "ad", "au", "da", "c", "ma", "ab", "ga", "aj", "y", "ax", "area", "ia", "fa"], "b": ["e", "rb", "d", "bb", "ob", "aa", "h", "eb", "bf", "p", "sb", "ba", "u", "z", "r", "fb", "wb", "am", "bis", "w", "bd", "B", "ib", "bi", "body", "aaa", "nb", "c", "abb", "lb", "x", "ab", "ga", "bs", "y", "bp", "o", "be", "mb", "beta"], "g": ["e", "gi", "sg", "ge", "d", "gs", "G", "play", "h", "item", "p", "msg", "erg", "bg", "cfg", "gr", "go", "u", "r", "gu", "group", "w", "q", "gp", "gb", "og", "ig", "graph", "reg", "c", "gh", "gae", "x", "gas", "ga", "y", "vg", "rg", "game", "gg", "gm"], "queue": ["update", "buf", "module", "event", "gui", "Queue", "p", "que", "manager", "match", "list", "complete", "out", "config", "sequence", "force", "master", "ping", "enabled", "file", "status", "foo", "pool", "group", "cli", "layer", "q", "wait", "stack", "seq", "live", "order", "graph", "job", "block", "all", "cache", "progress", "stage", "parent", "worker", "message", "buffer", "result", "main", "delay", "line", "ue", "Q", "array", "chain", "load", "server", "menu"], "v": ["e", "nv", "d", "ov", "ve", "dev", "h", "lv", "vm", "p", "vin", "vv", "vi", "u", "iv", "z", "val", "ver", "t", "r", "li", "ev", "va", "w", "vd", "q", "video", "vp", "av", "c", "sv", "vs", "V", "x", "y", "vg", "uv", "qv", "o"], "bomb": ["bird", "osion", "ball", "charge", "bang", "enemy", "controller", "fail", "broken", "bo", "storm", "aa", "az", "bug", "unit", "rupt", "clone", "secret", " bombs", "critical", "pill", "foo", "bad", "error", "hack", "atom", "ash", "riot", "attack", "prefix", "bi", "rocket", "body", "Bomb", "aaa", "beat", "flash", "moon", "leaf", "blog", "mass", "blank", "null", "pattern", "timeout", "zone", "less", "bell", " Bomb"], "i": ["e", "ki", "gi", "si", "ini", "xi", "il", "ori", "d", "ip", "mi", "id", "info", "h", "lo", "p", "api", "I", "vi", "u", "iv", "im", "zi", "z", "ie", "li", "pi", "ai", "ui", "ni", "it", "io", "ci", "ik", "ij", "ii", "ei", "bi", "di", "ti", "yi", "c", "int", "ji", "x", "ix", "y", "ri", "iu", "o", "ia", "eni", "qi"], "j": ["e", "em", "br", "xi", "d", "name", "ion", "ne", "fr", "uj", "h", "J", "p", "ch", "jet", "u", "im", "qi", "z", "r", "jl", "sh", "li", "ie", "jj", "note", "obj", "q", "ci", "adj", "jp", "kj", "ii", "ij", "el", "L", "je", "c", "ja", "jc", "ji", "ol", "x", "false", "y", "aj", "jo", "kl", "o", "js", "oj"], "R": ["N", "Rh", "U", "G", "id", "X", "str", "J", "RR", "add", "I", "join", "r", "W", "Rs", "_", "K", "SR", "Right", "L", "Res", "D", "A", "T", "B", "RS", "S", "all", "c", "end", "E", "H", "F", "V", "Q", "P", "format", " r", "url"], "C": ["N", "CF", "Cs", "U", "d", "G", "Ch", "X", "I", "W", "Z", "CE", "K", "DC", "CC", "L", "D", "A", "T", "B", " c", "S", "c", "CR", "E", "CS", "F", "V", "Q", "P", "CT"], "s": ["e", "settings", "si", "ws", "sg", "d", "gs", "ps", "ns", "G", "rows", "h", "slice", "p", "sb", "series", "u", "su", "sequence", "z", "r", "t", "ing", "spec", "_", "ed", "ds", "summary", "sym", "string", "cs", "comments", "sets", "w", "conf", "sf", "es", "sq", "q", "csv", "fields", "ss", "fs", "S", "c", "strings", "details", "sv", "states", "us", "y", "lines", "sc", "o", "secondary"], "field": ["d", "rule", "id", "patch", "str", "slice", "Field", "p", "match", "input", "column", "force", "z", "file", "form", "condition", "_", "object", "group", "layer", "card", "sum", "string", "div", "box", "record", "source", "w", "type", "FIELD", "fields", "function", "element", "data", "block", "model", "c", "key", "end", "cell", "line", "format", "array", "load"], "row": ["page", "range", "col", "rows", "cube", "slice", "item", "Row", "input", "column", "instance", "r", "form", "object", "group", "string", "card", "record", "feed", "q", "query", "entry", "data", "raw", "block", "model", "round", "key", "cell", "x", "result", "line", "sc", "array", "draw", "server"], "k": ["e", "ki", "d", "dk", "id", "sk", "h", "p", "ch", "u", "r", "z", "sh", "t", "ky", "kw", "kk", "K", "ke", "w", "q", "ka", "ik", "ak", "kn", "ks", "c", "work", "key", "x", "ek", "y", "kl", "ck", "ok", "o", "ko", "mk"], "l": ["e", "il", "d", "ail", "h", "pl", "p", "ll", "u", "r", "z", "li", "t", "ly", "lin", "yl", "ell", "q", "nl", "L", "el", "ls", "dl", "sl", "al", "ml", "c", "ln", "lp", "ol", "ul", "kl", "lu", "y", "o", "lc"], "M": ["N", "U", "G", "X", "J", "O", "I", "MR", "mm", "W", "TM", "MD", "NM", "Z", "CM", "K", "ML", "MS", "JM", "Mi", "SM", "GM", "L", "MN", "EM", "D", "A", "OM", "MC", "T", "FM", "B", "DM", "S", "IM", "MB", "E", "H", "MF", "AM", "F", "V", "Y", "Q", "P", "cm", "MM", "LM"]}}
{"code": "\\n  def solve_case(c, f, x, case_number):\\n      rate = 2.0\\n      time = 0.0\\n      rest = x\\n      while True:\\n          time_to_c = c / rate\\n          time_to_x = rest / rate\\n          if time_to_c < time_to_x:\\n              time_to_x_with_boost = time_to_c + (rest / (rate + f))\\n              if time_to_x_with_boost < time_to_x:\\n                  rate += f\\n                  time += time_to_c\\n              else:\\n                  break\\n          else:\\n              break\\n      time += rest / rate\\n      print \"Case #%d: %.7f\" % (case_number, time)\\n  \\n  r = sys.stdin\\n  \\n  if len(sys.argv) > 1:\\n      r = open(sys.argv[1], 'r')\\n  \\n  total_cases = r.readline()\\n  for case_number in range(1, int(total_cases) + 1):\\n      values = map(float, r.readline().split(' '))\\n      solve_case(values[0], values[1], values[2], case_number)\\n", "target": "54", "substitutes": {"c": ["e", "cf", "d", "rc", "h", "ac", "C", "p", "start", "case", "count", "z", "t", "co", "w", "n", "m", "ci", "l", "xc", "cc", "cycle", "nc", "y", "b", "cm", "con", "lc"], "f": ["e", "cf", "speed", "d", "fr", "i", "h", "xf", "bf", "p", "feature", "u", "force", "z", "fm", "t", "file", "fb", "v", "fit", "sf", "q", "m", "n", "l", "rf", "function", "fp", "inf", "fs", "frac", "F", "y", "b", "fc", "frequency"], "x": ["e", "full", "xs", "d", "event", "default", "i", "X", "p", "xy", "max", "auto", "xes", "case", "rx", "z", "t", "v", "ext", "re", "w", "q", "n", "l", "index", "ex", "fast", "xc", "wx", "times", "work", "test", "y", "b", "con", "fc", "array", "abc"], "case_number": ["case_num", " case_direction", "caseOline", "caseOaddress", " case__no", "caseOcount", "casesnumber", "case_length", " case_address", " case__number", "case___number", "ase_number", "case___line", "caseOnumber", "case__no", " case_count", " case_num", "ase_no", "case_line", " case__address", "case___num", " case__num", "caseOnum", " case_name", " case_length", "case_address", "casesname", "case__number", "case__address", "casesdirection", " case_no", "case_no", "case__num", "case_count", "ase_name", "case_name", "caseOno", "case_direction", "ase_num", " case_line", "case___count", "caseslength"], "rate": ["rating", "range", "size", "stop", "speed", "ave", "rage", "rand", "weight", "bb", "rule", "score", "duration", "rc", "rated", "power", "feature", "length", "ime", "max", "ride", "Rate", "case", "force", "count", "report", "rice", "race", "re", "feed", "type", "rank", "core", "grade", "seed", "rss", "rates", "beat", "erate", "sync", "base", "use", "fan", "dy", "factor", "tone", "depth", "cycle", "F", "buffer", "delay", "wave", "fee", "cost", "con", "frequency", "cr", "mode", "scale", "lc"], "time": ["size", "counter", "speed", "duration", "name", "money", "rule", "weight", "rc", "Time", "runtime", "length", "ime", "now", "start", "trial", "case", "year", "t", " Time", "etime", "space", "date", "race", "rice", "type", "sleep", "m", "TIME", "grade", "clock", "function", "data", "hour", "times", "progress", "test", "depth", "cycle", "line", "delay", "run", "timer", "y", "transform", "cost", " timestamp", "frequency", "timeout", "mode", "url", "lc"], "rest": ["range", "stop", "fr", "rc", "play", "repeat", "p", "ur", "feature", "length", "max", "start", "case", "force", "rx", "z", "res", "rec", "re", "feed", "sleep", "core", "clock", "past", "rss", "beat", "sync", "Rest", "reg", "frac", "progress", "work", "use", "end", "int", "test", "st", "ab", "min", "dist", "est", "transform", "y", "con", "cr", "const", "trial"], "time_to_c": ["time_from_x", "time_to_f", "time_from_e", "time_to_case", "time_from_d", "time_to_d", "time_from_c", "time_to_e", "time_from_f"], "time_to_x": ["time_from_x", "time_from_X", "time_to_f", "time_to_z", "time_to_X", "time_from_z", "time_from_c", "time_from_f", "time_to_p"], "time_to_x_with_boost": ["time_to_x_without_fuel", "time_to_x_with_Boost", "time_to_x_without_Boost", "time_to_x_with_growth", "time_to_x_with_fuel", "time_to_x_without_growth", "time_to_x_with_time", "time_to_x_without_boost", "time_to_x_without_time"], "r": ["e", "rr", "rb", "br", "parser", "d", "tr", "fr", "wr", "rc", "p", "gr", "ar", "mr", "dr", "er", "u", "rx", "t", "v", "res", "rw", "ir", "re", "w", "hr", "l", "R", "ru", "rh", "rt", "runner", "kr", "ner", "rl", "reader", "rs", "rd", "sr", "nr", "b", "rg", "err"], "total_cases": [" total_items", "total_measures", "totalallcases", "totalXruns", " total_measures", " total_tests", " total_runs", "totalenitems", "total_tests", "totalXcases", "totalXitems", "totalallmeasures", "totalallruns", "totalencases", "total_runs", "total_items", "totalalltests", "totalenruns"], "values": ["rules", "relations", "results", "settings", "members", "ms", "vals", "params", "Values", "places", "ns", "rows", "stats", "changes", "series", "features", "maps", "val", "errors", "cases", "cells", "v", "types", "forms", "years", "als", "seconds", "verts", "value", "grades", "data", "rates", "ks", "groups", "charges", "models", "measures", "frames", "times", "versions", "flows", "items", "vs", "tests", "roots", "bs", "ends", "lines", "ports", "lists", "es", "options", "objects"]}}
{"code": "\\n  \\n  def print_basic_board(no_mine, r, c):\\n      printed_c = False\\n      for row in range(0, r):\\n          line = []\\n          for column in range(0, c):\\n              if printed_c:\\n                  if no_mine > 0:\\n                      line.append(\".\")\\n                      no_mine -= 1\\n                  else:\\n                      line.append(\"*\")\\n              else:\\n                  line.append(\"c\")\\n                  no_mine -= 1\\n                  printed_c = True\\n          print \"\".join(line)\\n  \\n  \\n  def print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c):\\n      printed_c = False\\n      for row in range(0, r):\\n          line = []\\n          for column in range(0, c):\\n              if printed_c:\\n                  if row < no_mine_row and column < no_mine_column:\\n                      line.append(\".\")\\n                  elif rest_no_mine_for_column > 0 and column == no_mine_column:\\n                      line.append(\".\")\\n                      rest_no_mine_for_column -= 1\\n                  elif rest_no_mine_for_row > 0 and row == no_mine_row:\\n                      line.append(\".\")\\n                      rest_no_mine_for_row -= 1\\n                  else:\\n                      line.append(\"*\")\\n              else:\\n                  line.append(\"c\")\\n                  printed_c = True\\n          print \"\".join(line)\\n  \\n  \\n  def solve_case(r, c, m, case_number):\\n      print \"Case #%d:\" % case_number\\n      no_mine = r * c - m\\n      if r < 2 or c < 2 or no_mine == 1:\\n          print_basic_board(no_mine, r, c)\\n      else:\\n          no_mine_row_max = int(math.ceil(float(no_mine) / 2))\\n          if no_mine_row_max > r:\\n              no_mine_row_max = r\\n          for no_mine_column in range(2, int(math.ceil(float(no_mine) / 2)) + 1):\\n              if no_mine_column > c:\\n                  break\\n              for no_mine_row in range(2, no_mine_row_max + 1):\\n                  rest_no_mine = no_mine - (no_mine_column * no_mine_row)\\n                  if rest_no_mine < 0:\\n                      continue\\n                  if rest_no_mine == 1:\\n                      continue\\n  \\n                  if rest_no_mine == 0:\\n                      print_board(no_mine_row, no_mine_column, 0, 0, r, c)\\n                      return\\n                  if rest_no_mine <= no_mine_row and no_mine_column < c:\\n                      print_board(no_mine_row, no_mine_column, 0, rest_no_mine, r, c)\\n                      return\\n                  if rest_no_mine <= no_mine_column and no_mine_row < r:\\n                      print_board(no_mine_row, no_mine_column, rest_no_mine, 0, r, c)\\n                      return\\n  \\n                  if rest_no_mine > 3 and no_mine_column < c and no_mine_row < r:\\n                      for rest_no_mine_for_row in range(2, no_mine_column):\\n                          rest_no_mine_for_column = rest_no_mine - rest_no_mine_for_row\\n                          if rest_no_mine_for_column < no_mine_row:\\n                              print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c)\\n                              return\\n  \\n          print \"Impossible\"\\n  \\n  r_file = sys.stdin\\n  \\n  if len(sys.argv) > 1:\\n      r_file = open(sys.argv[1], 'r')\\n  \\n  total_cases = r_file.readline()\\n  for case_number in range(1, int(total_cases) + 1):\\n      values = map(int, r_file.readline().split(' '))\\n      solve_case(values[0], values[1], values[2], case_number)\\n  \\n", "target": "54", "substitutes": {"no_mine": ["remote_mine", "so_min", "noAmining", "no_grave", "remote_wine", " no_select", "no_download", " no_mining", "no_brown", "noFmine", " no_write", "so_charge", "no67wine", "no__min", "non_vale", "so_mine", "so_grave", "no67mine", "no__select", " no_min", "no_care", "no_charge", "remote67mine", "no_message", "remote67powder", "remote67brown", "non_mining", " no_grade", "no_vale", "nice_mining", "niceFdownload", "nice_mine", "no__grave", "no_select", " no_wine", "noApine", " no_powder", " no_pine", "no_wine", "nice_download", "No_mining", "noAmine", "non_grade", "niceFmining", "noFmining", "no__mining", "no_grade", "No_pine", "remote_brown", "remote_powder", "no__charge", "no_mining", "No_mine", "no__mine", "remote67wine", "noFdownload", "no_powder", "No_min", "no67powder", "noAselect", "noFcare", "no67brown", "niceFmine", "no_min", "niceFcare", "non_mine", "nice_care", "no_pine", " no_message", "no__pine", "no_write"], "r": ["e", "range", "br", "rb", "rr", "d", "fr", "i", "nor", "rc", "h", "p", "ur", "pr", "j", "ar", "mr", "dr", "er", "u", "t", "v", "lr", "ra", "ir", "re", "w", "q", "n", "hr", "l", "R", "ru", "right", "g", "ro", "s", "kr", "a", "k", "rs", "x", "rd", "sr", "nr", "b", "rg", "f", "err", "o", "cr"], "c": ["e", "cf", "mc", "d", "col", "i", "rc", "h", "ac", "C", "dc", "p", "ch", "ce", "u", "z", "t", "co", "cu", "v", "rec", "cs", "w", "cy", "uc", "q", "ci", "n", "l", "cl", "ca", "pc", "cc", "s", "k", "ec", "x", "nc", "y", "con", "cm", "f", "b", "cp", "cr", "cn", "g", "lc"], "printed_c": [" printed_m", "picked_ct", "worked_c", "printedTheline", "printed67rec", "printed67ec", "printedTher", "led_f", "printed_line", "printed_ec", "led_cp", "printedThee", "printed_k", "printedThek", " printed_r", " printed_line", " printed_e", "printed_pc", "printedJc", "printedptk", "led_case", "printed67m", "printed_ct", "printed67c", "printedJf", "printed_e", "printedlyrec", "picked67ct", "led_c", " printed_lc", "printedptc", "printed67ct", "picked_c", "printedThem", "printedJcu", "printed_rec", "printedJcase", "printedptline", "picked_cu", "picked_rec", "printed_cn", " printed_cn", " printed_uc", "printedLogcase", "printed_r", "printedlyc", "printed_uc", "worked_pc", "printedJrec", "printed_cu", "worked_e", "picked67cu", "picked67rec", "printed_lc", "printedlycu", "printed_m", "printedptlc", "printedlyct", "printedJcp", "printed67cu", "printed_case", "printed_f", "printed67e", "printedJct", "printedThelc", "picked67c", "printedThec", "worked_ec", "printed_cp", "printedLogcp", " printed_k", "printed67r", "printedLogc", "printed67pc", "printedLogf"], "row": ["page", "range", "container", "col", "tr", "rew", "offset", "rows", "num", "rc", "slice", "month", "Row", "length", "channel", "ride", "max", "year", "arrow", "roll", "ref", "group", "layer", "error", "re", "record", "rect", "ow", "rank", "entry", "rown", "index", "order", "value", "right", "raw", "ro", "batch", "block", "round", "key", "cell", "ry", "collection", "reader", "run", "array", "cr", "user"], "line": ["ge", "name", "cle", "inline", "auto", "Line", "object", "band", "limit", "log", "day", "stage", "cell", "member", "site", "db", "page", "rule", "ine", "word", "liner", "none", "li", "status", "engine", "note", "record", "nl", "plan", "l", "sl", "body", "plugin", "call", "code", "do", "le", "user", "server", "e", "gen", "ne", "lane", "file", "comment", "lin", "layer", "side", "pin", "el", "live", "one", "block", "model", "key", "lines", "chain", "lock", "lo", "unit", "item", "list", "group", "LINE", "source", "cl", "entry", "link", "grid", "sync", "base", "style", "use", "message", "mode", "lc"], "column": ["page", "container", "col", "weight", "offset", "four", "word", "coll", "unit", "header", "section", "current", "Row", "width", "attribute", "length", "channel", "year", "ct", "arrow", "number", "Column", "left", "long", "field", "group", "method", "position", "day", "initial", "entry", "index", "minute", "value", "right", "block", "sec", "cell", "member", "lc", "collection", "character", "maximum", "path", "cm", "const"], "no_mine_row": ["no_mine_col", "no_mining_rot", "no_mining_col", "no_mine_roll", "no_mining_entry", "no_mine_rows", "no_mine67row", "no_mine64column", "no_mining_row", "no_mine64rot", "no_mine_entry", "no_mine64row", "no_mine_cell", "no_mine67col", "no_mine67roll", "no_mine64rows", "no_mine_rot", "no_mine67column", "no_mining_cell", "no_mining_roll", "no_mining_column", "no_mining_rows"], "no_mine_column": ["no_mine_col", "no_mine_current", "no_mining_current", "no_mine_connection", "index", "end", "no_mine___position", "no_minessection", "no_mining_col", "pos", "no_mine___col", "none", "count", "_", "no_mining_row", "no_mining_position", "no_minescol", "no_mine_cell", "no_mine_index", "all", "s", "no_mining_cell", "no_mineetrow", "no_mine_section", "match", "no_minescolumn", "no_mineetcurrent", "config", "no_mine___column", "no_mineetposition", "no_minesrow", "no_mineetcolumn", "no_mine___row", "no_mining_index", "no_mining_connection", "no_mine_position", "no_mining_section", "no_mining_column"], "rest_no_mine_for_row": ["rest_no_mine_foraccol", "rest_no_mine_foracentry", "rest_no_mine_for_rows", "rest_no_mine_foracrows", "rest_no_mine_for__rows", "rest_no_mine_for_entry", "rest_no_mine_for__column", "rest_no_mine_foracrow", "rest_no_mine_for__row", "rest_no_mine_for__col", "rest_no_mine_for_col"], "rest_no_mine_for_column": ["rest_no_mine_in_row", "rest_no_mine_in_page", "rest_no_mine_for_entry", "rest_no_mine_for__column", "rest_no_mine_for_cell", "rest_no_mine_in__column", "rest_no_mine_forallpage", "rest_no_mine_in__page", "rest_no_mine_in_col", "rest_no_mine_forallcolumn", "rest_no_mine_in__col", "rest_no_mine_in__row", "rest_no_mine_forallrow", "rest_no_mine_for__row", "rest_no_mine_forallcol", "rest_no_mine_for__col", "rest_no_mine_for_col", "rest_no_mine_in_column", "rest_no_mine_for_page", "rest_no_mine_for__page"], "m": ["e", "range", "mc", "d", "mi", "i", "h", "p", "ch", "man", "mr", "u", "z", "t", "M", "v", "mat", "um", "re", "w", "n", "l", "mod", "s", "x", "min", "y", "cm", "b", "f", "o", "cr", "meta", "g"], "case_number": ["casenumnumber", " case_category", "caseiddescription", "casenumcategory", "result_type", "result_Number", "case_num", "casenumnum", "case_type", "case_category", "caseidnumber", "case_group", "caseblockcategory", "caseblocknumber", "caseblockgroup", "casenumgroup", "caseidNumber", " case_num", "resultblockdescription", "caseblockdescription", "caseblocknum", "resultblockNumber", "case_description", "resultblocktype", "caseblocktype", "caseblockNumber", "result_number", " case_group", "caseidtype", "result_description", "resultblocknumber", "case_Number"], "no_mine_row_max": ["no_mine_column_last", "no_mine_rows_max", "no_mine_rows_min", "no_mine_row_ax", "no_mine_row_min", "no_mine_row_last", "no_mine_rowvmin", "no_mine_rowvsize", "no_mine_rows_ax", "no_mine_rowpmax", "no_mine_row_col", "no_mine_column_min", "no_mine_column_max", "no_mine_rowpmin", "no_mine_row_size", "no_mine_rowpax", "no_mine_rows_col", "no_mine_rows_size", "no_mine_rowvmax"], "rest_no_mine": ["rest_not_mine", "rest_notvelmining", "rest_no_mate", "rest_novelmining", "rest_notvelweight", "rest_novelmine", "rest_novelmate", "rest_not_mining", "rest_notvelmate", "rest_no_weight", "rest_notvelmine", "rest_novelweight", "rest_no_mining", "rest_not_mate", "rest_not_weight"]}}
{"code": "t = int(raw_input())\\n  \\n  for case in range(t):\\n  \\n  \tc, f, x = raw_input().split()\\n  \tc = float(c)\\n  \tf = float(f)\\n  \tx = float(x)\\n  \\n  \tt = 0\\n  \tcps = 2.0\\n  \twhile c/cps < x/cps and t+x/cps > t+c/cps + x/(cps+f):\\n  \t\tt += c/cps\\n  \t\tcps += f\\n  \\n  \tt += x/cps\\n  \\n  \tprint 'Case #'+str(case+1)+':', t\\n", "target": "55", "substitutes": {"t": ["at", "tt", "e", " T", "d", "duration", "i", "ta", "tz", "h", "p", "j", "out", "start", "u", "ct", "pt", "nt", "qt", "r", "total", "z", "dt", "v", "ty", "it", "tf", "trace", "q", "type", "m", "n", "l", "ot", "T", "ut", "ti", "s", "temp", "time", "int", "a", "tc", "tp", "test", "wt", "this", "y", "ant", "b", "o", "g", "ts"], "case": ["e", "size", "d", "client", "default", "id", "slice", "p", "section", "match", "length", "ace", "future", "switch", "sequence", "count", "instance", "change", "cases", "number", "ase", "nce", "ASE", "rice", "example", "position", "type", "Case", "ice", "use", "time", "pe", "end", "test", "chance", "catch", "call", "shape", "choice", "USE", "code"], "c": ["e", "cf", "d", "col", "i", "rc", "h", "ac", "C", "p", "ce", "u", "count", "ct", "r", "z", "v", "cu", "cs", "w", "cy", "q", "uc", "n", "ci", "m", "l", "ca", "pc", "cc", "s", "a", "k", "ec", "nc", "y", "b", "con", "cm", "fc", "g", "lc"], "f": ["cf", "e", "fd", "d", "col", "fr", "i", "h", "xf", "p", "fx", "j", "bf", "fi", "now", "u", "z", "r", "file", "form", "fb", "tf", "v", "ft", "field", "um", "feed", "w", "sf", "q", "n", "m", "l", "rf", "fl", "fp", "inf", "fs", "s", "df", "k", "F", "fe", "y", "b", "fc", "o", "fen", "g", "ef"], "x": ["e", "cf", "ctx", "xs", "xi", "d", "i", "X", "h", "C", "xf", "p", "fx", "j", "ch", "xes", "u", "z", "r", "rx", "cross", "form", "tx", "co", "v", "com", "ext", "w", "q", "n", "m", "ci", "l", "cl", "ex", "xc", "php", "wx", "xxx", "s", "time", "pe", "int", "test", "ic", "F", "ph", "xx", "ix", "y", "b", "fc", "o", "ax", "g"], "cps": ["ucfs", "ccfs", "ctpt", "ctamps", "cpps", " cales", " cases", "ccps", "Cups", "cases", "dps", "cpt", "fps", "ancpped", "pcps", "ancps", " cips", "camps", "ccips", "ctases", "lcrs", "cplanes", "cpe", "Cips", "ctips", "acps", "bpped", "ctps", "Cases", "cips", "caps", "vpps", "ancases", "vpped", "Camps", "fips", "lcps", "cpped", "ctfs", "fpped", "Cps", "acups", "chpe", "cPS", "bups", "cups", " ccs", "fcamps", "crs", "cfs", "dpe", "ccs", "fPS", "acpe", "pccs", "fcps", "fcPS", "fpe", "fups", "chrs", "dpp", "capped", "acips", "lcpe", " cfs", "ucps", "lcpp", "Cpped", "Cfs", "cpp", "fcases", "Cpt", "bps", "cales", "chpp", "fccs", "Cpe", "ucips", "fcales", "ucpe", "ccales", "fcpt", " cPS", "bplanes", "pcases", "drs", "caups", "vases", "fplanes", "ucPS", "Cales", "vps", "ctales", "caplanes", "ucases", " cpe", "Cpps", "ancpps", "chps", "pcPS"]}}
{"code": "t = int(raw_input())\\n  \\n  for case in range(t):\\n  \tprint 'Case #'+str(case+1)+':'\\n  \tr, c, m = raw_input().split()\\n  \tr = int(r)\\n  \tc = int(c)\\n  \tm = int(m)\\n  \\n  \tif m==0:\\n  \t\tprint 'c' + ('.'*(c-1))\\n  \t\tfor i in range(r-1):\\n  \t\t\tprint '.'*c\\n  \telif r == 1:\\n  \t\tprint 'c'+('.'*(c-m-1))+('*'*(m))\\n  \telif c == 1:\\n  \t\tprint 'c'\\n  \t\tfor i in range(r-m-1):\\n  \t\t\tprint '.'\\n  \t\tfor i in range(m):\\n  \t\t\tprint '*'\\n  \telif r == 2:\\n  \t\tif m%2==0 and c>2 and m<r*c-2:\\n  \t\t\tprint 'c'+('.'*(c-m/2-1))+('*'*(m/2))\\n  \t\t\tprint ('.'*(c-m/2))+('*'*(m/2))\\n  \t\telif m == r*c - 1:\\n  \t\t\tprint 'c'+('*'*(c-1))\\n  \t\t\tprint '*'*c\\n  \t\telse:\\n  \t\t\tprint 'Impossible'\\n  \telif c == 2:\\n  \t\tif m%2==0 and r>2 and m<r*c-2:\\n  \t\t\tprint 'c.'\\n  \t\t\tfor i in range(r-m/2-1):\\n  \t\t\t\tprint '..'\\n  \t\t\tfor i in range(m/2):\\n  \t\t\t\tprint '**'\\n  \t\telif m == r*c - 1:\\n  \t\t\tprint 'c*'\\n  \t\t\tfor i in range(r-1):\\n  \t\t\t\tprint '**'\\n  \t\telse:\\n  \t\t\tprint 'Impossible'\\n  \telif c == 3 and r == 3:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\telif m == 6:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 7:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c**'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \telif c == 3 and r == 4:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 5:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 9:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c**'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \telif c == 3 and r == 5:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 8:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 12:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c**'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \telif c == 4 and r == 3:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\telif m == 5:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\telif m == 7:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c***'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \telif c == 4 and r == 4:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '..**'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 11:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 15:\\n  \t\t\tprint 'c***'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \telif c == 4 and r == 5:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 15:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 16:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 17:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 18:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 19:\\n  \t\t\tprint 'c***'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \telif c == 5 and r == 3:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '...**'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '..***'\\n  \t\telif m == 8:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \telif c == 5 and r == 4:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '..***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 15:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 16:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 17:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 18:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 19:\\n  \t\t\tprint 'c****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \telif c == 5 and r == 5:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '*****'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 13:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 15:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 16:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 17:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 18:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 19:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 20:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 21:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 22:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 23:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 24:\\n  \t\t\tprint 'c****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \telse:\\n  \t\tprint 'Impossible'\\n  \\n", "target": "55", "substitutes": {"t": ["at", "tt", "e", "d", "tz", "h", "p", "start", "u", "z", "it", "dt", "v", "w", "type", "q", "n", "tm", "l", "T", "port", "s", "time", "test", "x", "y", "b", "f", "o", "trial", "ts"], "case": ["size", "name", "id", "slice", "me", "section", "match", "ace", "length", "ce", "instance", "count", "ase", "cases", "number", "rice", "race", "loc", "position", "type", "Case", "ice", "text", "use", "end", "time", "app", "test", "x", "line", "code", "table", "trial"], "r": ["e", "range", "yr", "rr", "rb", "br", "d", "tr", "fr", "rc", "h", "p", "ur", "j", "pr", "ar", "mr", "u", "er", "z", "v", "rec", "ir", "re", "w", "q", "n", "hr", "l", "R", "ru", "g", "rh", "ter", "s", "k", "rs", "x", "sr", "nr", "y", "b", "err", "f", "o", "cr"], "c": ["e", "cf", "mc", "d", "col", "rc", "h", "ac", "C", "dc", "p", "ch", "oc", "ur", "ce", "ar", "u", "count", "ct", "z", "cat", "co", "v", "cu", "rec", "cs", "re", "w", "cy", "q", "uc", "n", "ci", "l", "cl", "ca", "xc", "pc", "cc", "s", "cin", "a", "k", "ic", "ec", "x", "y", "code", "sc", "b", "cm", "f", "con", "cr", "o", "cp", "g", "lc"], "m": ["e", "range", "ms", "mc", "em", "module", "d", "mi", "om", "dm", "h", "p", "ur", "j", "me", "pm", "ar", "man", "mr", "mu", "sm", "rm", "u", "im", "mm", "z", "fm", "an", "M", "bm", "v", "ym", "am", "um", "mo", "re", "w", "arm", "hm", "n", "tm", "l", "machine", "md", "mod", "s", "a", "lc", "k", "x", "y", "mon", "er", "b", "cm", "f", "o", "g", "gm"], "i": ["e", "si", "xi", "ip", "id", "h", "p", "j", "I", "u", "iv", "ie", "li", "pi", "ai", "ui", "v", "it", "io", "ci", "l", "ii", "ei", "bi", "ti", "ib", "di", "yi", "int", "ji", "ic", "phi", "x", "ri", "iu", "b", "oi", "f", "iw", "o", "chi", "qi"]}}
{"code": "def CASE(IN):\\n      def rstr(): return IN.readline().strip()\\n      def rint(): return int(rstr())\\n      def rints(): return map(int, rstr().split())\\n      def rfs(): return map(float, rstr().split())\\n      c, f, x = rfs()\\n      b = 2.0\\n      if x <= c:\\n          return x/b\\n      t = 0\\n      while True:\\n          tf = x/(b+f) + c/b\\n          tn = x/b\\n          if tn <= tf:\\n              return t + tn\\n          t += c/b\\n          b += f\\n  \\n  \\n  def RUN(IN, OUT):\\n      t = int(IN.readline().strip())\\n      for i in xrange(1,t+1):\\n          OUT.write(\"Case #%i: %.7f\\n\" % (i, CASE(IN)))\\n  \\n  if __name__ == \"__main__\":\\n      RUN(sys.stdin, sys.stdout)\\n", "target": "56", "substitutes": {"IN": ["N", "IND", "URL", "INS", "X", "IL", "IGN", "OU", "DL", "READ", "CL", "inner", "URI", "ABC", "input", "out", "WIN", "TEXT", "M", "DATA", "FIN", "PIN", "LINE", "IC", "STR", "Input", "TIME", "PER", "MN", "ins", "CC", "MIN", "OSS", "ER", "IO", "EN", "NG", "ALL", "INT", "SQL", "AC", "String", "IR", "F", "In", "FF", "INE", "FILE", "Q", "ON", "LIB", "II", "MAX", "BL", "PE", "Out", "LIN"], "c": ["e", "cf", "d", "center", "h", "ac", "C", "dc", "p", "ce", "u", "case", "ct", "z", "r", "v", "cu", "cs", "w", "cy", "n", "m", "ci", "l", "CC", "cd", "cc", "s", "a", "k", "y", "con", "fc", "cm", "cn", "const", "cr", "o", "g", "CCC", "lc"], "f": ["e", "cf", "fd", "d", "h", "bf", "p", "j", "u", "r", "z", "fb", "v", "w", "sf", "n", "m", "l", "rf", "fp", "fs", "a", "k", "F", "y", "fc", "o", "g", "fa"], "x": ["e", "xs", "xt", "xi", "d", "X", "h", "xf", "p", "xy", "u", "case", "ct", "z", "r", "rx", "tx", "v", "w", "q", "n", "m", "l", "index", "ex", "xc", "python", "a", "int", "k", "xx", "y", "code", "fc", "o", "g"], "b": ["e", "br", "rb", "d", "bb", "ob", "pb", "h", "bf", "p", "sb", "eb", "out", "u", "r", "z", "fb", "wb", "v", "w", "n", "m", "l", "boot", "B", "ad", "al", "ib", "base", "nb", "bc", "s", "lb", "a", "k", "ab", "bs", "y", "bp", "db", "bt", "o", "g"], "t": ["at", "tt", "e", "d", "ta", "h", "p", "j", "out", "u", "ct", "z", "pt", "tl", "dt", "v", "tw", "ty", "total", "w", "type", "n", "m", "l", "ot", "the", "T", "ti", "template", "tc", "s", "time", "tp", "wt", "a", "temp", "st", "tty", "y", "ant", "to", "o", "trial", "g", "ts"], "tf": ["cf", "xff", "cb", "fn", "TF", "ta", "pb", "bf", "fb", "fg", "tw", "flat", "conf", "sf", "n", "fp", "xc", "ff", "cc", "tc", "tp", "df", "ffff", "fe", "tmp", "tif", "fy", "fc", "bt", "cr", "cp", "lc", "fa"], "tn": ["cf", "tt", "kt", "rb", "fd", " rc", "bb", "cb", "ns", "ww", "ta", "tz", "bf", "p", "out", "ba", "u", "z", "nt", "bm", "uf", "tx", "dt", "tw", "v", "bn", "tu", "btn", "nn", "n", "kn", "gb", "td", "py", "ot", "fl", "gt", "fp", "ff", "nb", "ox", "bc", "tc", "unc", "tp", "dy", "k", "bs", "y", "cn", "fc", "bt", "g", "ts"], "OUT": ["PATH", "INS", "Writer", "Output", "FORM", "RAW", "OU", "out", "STDOUT", "PUT", "READ", "TEXT", "CL", "ERROR", "EXT", "STR", "DC", "ST", "LINE", "OT", "FS", "NAME", "TABLE", "OS", "EX", "outer", "IO", "NG", "GET", "INT", "TO", " out", "In", "WR", "FILE", "Q", "BL", "Out"], "i": ["e", "gi", "si", "inter", "xi", "ip", "d", "id", "num", "h", "p", "j", "I", "u", "count", "r", "pi", "li", "n", "ci", "l", "index", "ii", "T", "bi", "ti", "yi", "int", "k", "y", "iu", "ind", " j", "qi"]}}
{"code": "def get_a(r, c, f='.'):\\n      A = []\\n      for i in xrange(r):\\n          A.append([f] * c)\\n      return A\\n  \\n  \\n  def apply(A, r, c, B):\\n      for i, b in enumerate(B):\\n          for j, v in enumerate(b):\\n              A[r + i][c + j] = v\\n  \\n  \\n  def draw(A):\\n      if A is None:\\n          return '\\nImpossible'\\n      res = ['']\\n      for a in A:\\n          res.append(''.join(a))\\n      return '\\n'.join(res)\\n  \\n  \\n  def trans(A):\\n      if not A:\\n          return None\\n      B = get_a(len(A[0]), len(A))\\n      for i, a in enumerate(A):\\n          for j, v in enumerate(a):\\n              B[j][i] = v\\n      return B\\n  \\n  \\n  def check(A, m, r, c):\\n      if A is None:\\n          return True\\n      cnts = {'c': 0, '*': 0, '.': 0}\\n  \\n      assert len(A) == r\\n      for i in xrange(r):\\n          assert len(A[i]) == c\\n          for j in xrange(c):\\n              cnts[A[i][j]] += 1\\n      assert cnts['*'] == m\\n      assert cnts['c'] == 1\\n      assert cnts['.'] == r * c - m - 1\\n  \\n  \\n  def CASE(IN):\\n      def rstr():\\n          return IN.readline().strip()\\n  \\n      def rint():\\n          return int(rstr())\\n  \\n      def rints():\\n          return map(int, rstr().split())\\n      r, c, m = rints()\\n      A = solve(m, r, c)\\n      if A:\\n          A[-1][-1] = 'c'\\n      check(A, m, r, c)\\n      return draw(A)\\n  \\n  \\n  def solve(m, r, c):\\n      if r > c:\\n          return trans(solve(m, c, r))\\n      assert r <= c\\n      assert m != r * c\\n      e = r * c - m\\n      if e == 1:\\n          A = get_a(r, c, '*')\\n          return A\\n      if r == 1:\\n          A = get_a(1, c, '.')\\n          for i in xrange(m):\\n              A[0][i] = '*'\\n          return A\\n      if r == 2:\\n          if e == 2 or e % 2 == 1:\\n              return None\\n          A = get_a(2, c, '.')\\n          assert m % 2 == 0\\n          for i in xrange(m / 2):\\n              A[0][i] = A[1][i] = '*'\\n          return A\\n      assert r >= 3\\n      A = get_a(r, c, '*')\\n      if e in (2, 3, 5, 7):\\n          return None\\n      E = [c] * (e / c) + ([e % c] if e % c else [])\\n      if sum(E) < e:\\n          E.append(e % c)\\n          assert sum(E) == e\\n      if len(E) == 1:\\n          E = [e / 2] * 2\\n          if sum(E) < e:\\n              e.append(1)\\n      if E[0] != E[1]:\\n          s = sum(E[:2])\\n          E[0] = E[1] = s / 2\\n          if sum(E[:2]) != s:\\n              assert len(E) == 2\\n              E.append(1)\\n      if E[-1] == 1:\\n          if len(E) > 3:\\n              E[-2] -= 1\\n              E[-1] += 1\\n          else:\\n              E[0] -= 1\\n              E[1] -= 1\\n              E[2] += 2\\n      for i in xrange(len(E)):\\n          for j in xrange(E[i]):\\n              A[-i - 1][-j - 1] = '.'\\n      return A\\n  \\n  \\n  def RUN(IN, OUT):\\n      t = int(IN.readline().strip())\\n      for i in xrange(1, t + 1):\\n          OUT.write(\"Case #%i: %s\\n\" % (i, CASE(IN)))\\n  \\n  if __name__ == \"__main__\":\\n      RUN(sys.stdin, sys.stdout)\\n", "target": "56", "substitutes": {"r": ["range", "yr", "rr", "rb", "d", "tr", "fr", "rc", "h", "p", "ur", "pr", "ar", "rm", "mr", "dr", "er", "u", "z", "Rs", "ra", "ir", "re", "cur", "w", "q", "n", "l", "R", "ru", "g", "rh", "ro", "end", "rl", "k", "rs", "x", "rd", "sr", "nr", "err", "rg", "cr", "o"], "c": ["cf", "mc", "d", "col", "rc", "h", "ac", "C", "dc", "p", "ch", "ce", "u", "count", "z", "co", "cu", "can", "rec", "cs", "w", "cy", "q", "n", "ci", "l", "xc", "pc", "cc", "jc", "k", "ec", "x", "nc", "y", "sc", "con", "fc", "o", "cr", "cm", "cp", "g", "lc"], "f": ["cf", "d", "fold", "fr", "h", "bf", "p", "fx", "fi", "fun", "u", "af", "fm", "fb", "form", "of", "field", "feed", "sf", "q", "l", "rf", "fl", "fp", "fs", "ff", "df", "F", "x", "fe", "fc", "g", "ef", "fa"], "A": ["AA", "N", "Am", "Ma", "ap", "I", "If", "Ant", "M", "At", "K", "Data", "Input", "Average", "Res", "An", "Az", "Ap", "Entry", "MA", "end", "AM", "Empty", "New", "Q", "P", "AD", "Args", "X", "C", "First", "There", "W", "_", "Alpha", "General", "Order", "L", "R", "System", "T", "As", "LA", "Mult", "all", "And", "API", "F", "Ar", "array", "Art", "Error", "OA", "RA", "Instance", "The", "AR", "U", "d", "AP", "G", "AS", "Any", "p", "Ad", "ar", "Parts", "GA", "HA", "Content", "Ac", "Ca", "NA", "Ha", "alpha", "data", "AU", "S", "mA", "Wa", "H", "AC", "Result", "V", "All", "Y", "Product", "This", "AF", "O", "Min", "Adam", "Ab", "App", "CA", "Array", "Act", "Auth", "D", "AV", "Gener", "Action", "Code", "g", "PA"], "i": ["gi", "si", "ini", "xi", "ip", "d", "ori", "id", "h", "p", "I", "u", "im", "zi", "ie", "z", "li", "pi", "ai", "it", "ni", "ui", "io", "n", "ci", "l", "ii", "index", "bi", "ti", "di", "yi", "int", "k", "x", "y", "ri", "iu", "ind", "o", "g"], "B": ["N", "AA", "U", "G", "X", "C", "AB", "J", "O", "I", "Ab", "BB", "W", "BM", "M", "WB", "Z", "K", "Other", "NB", "BC", "L", "D", "R", "T", "S", "BI", "MB", "H", "F", "V", "CB", "Y", "BA", "Q", "Bs", "P", "BL"], "b": ["br", "d", "h", "p", "sb", "u", "z", "BB", "un", "w", "n", "l", "base", "nb", "k", "x", "ab", "bs", "y", "o", "g"], "j": ["si", "br", "d", "uj", "h", "str", "J", "p", "ch", "u", "im", "z", "ie", "li", "jl", "jj", "_", "q", "n", "l", "jp", "ij", "ii", "ja", "key", "jc", "int", "ji", "k", "x", "aj", "y", "jo", "ind", "o", "g", "js", "oj"], "v": ["nv", "d", "ve", "h", "lv", "p", "vv", "vi", "u", "z", "ver", "va", "w", "q", "n", "l", "value", "av", "conv", "sv", "k", "vs", "V", "x", "y", "uv", "o", "g"], "res": ["resp", "relations", "results", "ms", "vals", " results", "ps", "args", "ress", "RE", "p", "ras", "pres", "gr", "resolution", "arr", "response", "Rs", "values", "rap", "ris", "re", " R", " resolution", "remote", "Res", "powers", "os", "R", "breaks", "RS", "rev", "rh", "data", "right", "details", " Res", "blocks", "Result", "rs", "RES", "result", "bs", "err", "ros", "Results", "es", "ons"], "a": ["d", "args", "aa", "h", "ac", "p", "ap", "api", "ar", "ba", "u", "z", "an", "response", "ai", "ha", "am", "na", "sa", "aw", "Array", "ra", "va", "ae", "w", "n", "analysis", "actions", "alpha", "ach", "ad", "wa", "au", "aaa", "av", "all", "art", "app", "parts", "ma", "ab", "ga", "aj", "array", "area", "ia"], "m": ["range", "mc", "d", "mi", "h", "C", "p", "ur", "pm", "ar", "rm", "mr", "mu", "sm", "u", "er", "im", "mm", "z", "an", "bm", "M", "ym", "am", "um", "re", "w", "q", "n", "l", "R", "md", "all", "k", "x", "y", "cm", "o", "g"], "cnts": [" cntns", "ecNTp", "CNTd", "ecNTns", "cndl", " contns", "ccts", "categi", "cntls", "cNTd", "Cnds", "cpts", "cnds", "contns", "cndi", "Cnti", "Cndls", "Cnte", "crtps", "cptps", "CNTs", "criti", "critls", "cwnls", " conti", "Cntd", "cntps", "cntl", "countp", "cNTi", "cntd", "cnotps", "Cnotp", "cNTls", "cntns", "cntp", "critns", "Cntls", "Cnts", "cNTches", "critp", "categns", "cnotches", "cntches", "crte", "ecnts", "Cntl", "cnte", "cNTe", "cnots", " cnti", "cwnl", "ecNTls", "crits", "Cnots", "countches", "categs", "Cntp", "crts", "conti", "cctls", "cctp", "Cndi", "counts", "conts", "Cntches", "cctns", "cwns", "cwni", "ecntls", "cnti", "cnotp", "Cnotches", "Cndl", "CNTe", "cNTl", "CNTps", "ecntns", "crtd", "countps", " conts", "cNTs", "Cntps", "Cnotps", "cptd", "cndls", "cpte", "ecntp", "cNTp", "ecNTs", "cNTns", "cNTps"], "IN": ["AN", "URL", "INS", "IL", "RAW", "OU", "AL", "CL", "inner", "input", "URI", "I", "M", "DATA", "CON", "PIN", "IC", "Input", "MN", "ins", "Reader", "IO", "EN", "IM", "bin", "INT", "AC", "AD", "IR", "In", "FILE", "LIB", "BL", "Con", "Out", "LIN"], "e": [" eb", "range", "d", "ee", "h", "p", "ce", "u", "er", "z", "ed", "ae", "w", "es", "n", "l", " ce", "end", "ec", "x", "fe", "y", "err", "se"]}}
{"code": "\\n  \\n  filename = \"B-small-attempt0.in\"\\n  \\n  inp = open(filename, \"rU\")\\n  \\n  n = int(inp.readline().strip())\\n  \\n  for case in range(1, n + 1):\\n      cost, freq, goal = map(float, inp.readline().strip().split(\" \"))\\n      fac = 0.0\\n      time = 0.0\\n      test = lambda x: (goal/(2+(freq * (x + 1)))) + (cost /(2+(freq * x)))\\n      test2 = lambda x: (goal/(2+(freq * x)))\\n      while(test2(fac) > test(fac)):\\n          time += cost/(2 + (freq *  fac))\\n          fac += 1\\n      time += goal/(2+(freq*fac))\\n      print(\"Case #{}: {}\".format(case, time))\\n", "target": "57", "substitutes": {"filename": ["figure", "fd", "name", "location", "fn", "final", "document", "fil", "jet", "approximately", "username", "file", "largest", "dll", "mble", "string", "connection", "source", "database", "binary", "Filename", "utf", "prefix", "fp", "nil", "sheet", "files", "SourceFile", "title", "subject", "ename", "directory", "buffer", "iled", "download", "FILE", "maximum", "path", "url", "which"], "inp": ["inper", "insh", "outb", "Inc", " inf", "Inh", "INsp", "exf", "inh", "insp", "INf", "isinb", "insc", "isinper", "outp", "Inb", "exp", "INproc", "outh", "exsp", " inproc", "inc", "isinc", "inb", "INper", "INp", "inf", " inb", " inc", "INc", " insp", "isinp", "INb", "exproc", " inper", "Inp", "inproc", "outc", "insb"], "n": ["N", "size", "d", "ns", "num", "fn", "i", "len", "p", "j", "en", "u", "count", "z", "nt", "r", "t", "number", "iter", "w", "m", "l", "network", "net", "nb", "c", "s", "sn", "k", "x", "nc", "nr", "y", "nat", "b", "f", "span", "o", "cn"], "case": ["loop", "d", "name", "exc", "num", "X", " trial", "step", "slice", "section", "address", "length", "ce", "ace", "future", "config", "su", "count", "instance", "ase", "cases", "number", "change", "nce", "pack", "space", "race", "rice", "uc", "edge", "day", "clock", "Case", "ice", " c", "c", "pe", "chance", "catch", "x", "shape", "line", "y", "code", "f", "trial", "se"], "cost": ["cf", "size", "charge", "speed", "weight", "oo", "score", "effect", "rule", "step", "feature", "width", "length", "cal", "gate", "go", "start", "ace", " costs", "count", "level", "co", "gap", "sum", "half", "rank", "age", "grade", "data", "risk", "loss", "gross", "c", "scale", "use", "factor", "price", "shape", "k", "x", "gain", "fee", "f", "Cost"], "freq": ["frez", "frequality", "feu", "normalQ", "variquality", "perance", "france", "lifance", "freance", "feq", "peru", " freance", "lifqs", "frp", " freqs", "fastq", "fastQ", "freqs", "lifQ", "fru", "FreQ", "frk", "variqs", "realq", "normalz", " frequality", "varip", "fastity", "frek", "Frequality", "freity", "normality", "perq", "freu", " freQ", "feqs", " frep", "Freity", "Frep", "frqs", "perk", "Frek", "realqs", "feance", "frep", "Freq", "Frez", "freQ", "frq", "realance", "Freu", "fastz", "normalq", "Freqs", "variq", "realu", "Freance", "lifq"], "goal": ["team", "range", "gen", "rage", "origin", "gam", "effect", "distance", "feature", "fi", "width", "gate", "go", "general", "direction", "gan", "lane", "gu", "level", "Goal", "gin", "gap", "lead", "coord", "die", "margin", "home", "spread", "den", "cookie", "half", "safety", "limit", "balance", "wall", "risk", "loss", "winner", "gross", "style", "kick", "factor", "guide", "budget", "gain", "result", "height", "target", "jump", "fee", "game", "trial", "gender", "scale"], "fac": ["cf", "real", "loop", "weight", "gam", "ctr", "act", "eff", "ac", "bug", "fx", "gl", "feature", "cas", "fi", "Fac", "cal", "ace", "start", "fun", "fake", "config", "count", "acc", "feat", "gu", "form", "fam", "co", "gap", "lat", "race", "front", "cert", "circ", "loc", "iter", "trace", "q", "sim", "auc", "frac", "ff", "func", "c", "tc", "temp", "lag", "factor", "lc", "buff", "x", "result", "fe", "gain", "y", "fact", "fee", "fat", "f", "span", "fen", "g", "scale"], "time": ["size", "speed", "loop", "weight", "event", "name", "duration", "id", "play", "step", "h", "ac", "Time", "way", "length", "ace", "start", "trial", "count", "z", "t", "form", " Time", "gap", "error", "date", "race", "trace", "sleep", "m", "age", "sim", "clock", "tim", "rate", "hour", "port", "times", "progress", "work", "temp", "use", "end", "shape", "depth", "x", "call", "delay", "fact", "f", "timeout", "scale"], "test": ["Test", "loop", "fail", "default", "train", "act", "cmp", "match", "start", "acc", "feat", "val", "tx", "write", "pack", "race", "iter", "valid", "index", "fast", "prop", "ff", "stage", "temp", "use", "end", "parent", "fix", "tests", "catch", "call", "trip", " Test", "est", "code", "err", "trial", "check", "testing"], "test2": ["Test02", "iter2", "test0", "Test0", " testTwo", "match02", "match2", "script02", "iter32", "match0", "Test1", "testTwo", "Test2", " test0", "match1", "test32", "scriptTwo", " test32", " test02", "script32", "iter02", "test1", "iterTwo", "test02", "script2", " test1"]}}
{"code": "\\n  def check_bounds(state, coord):\\n      if coord[0] < 0 or coord[1] < 0:\\n          return False\\n      elif coord[0] > (len(state) - 1):\\n          return False\\n      elif coord[1] > (len(state[coord[0]]) - 1):\\n          return False\\n      else:\\n          return True\\n  \\n  def clear(state, coord):\\n      for r in range(-1,2):\\n          for c in range(-1,2):\\n              row = coord[0] + r\\n              col = coord[1] + c\\n              if check_bounds(state, (row, col)):\\n                  state[row][col] = 0\\n  \\n  def count(state):\\n      return sum([sum(x) for x in state])\\n  \\n  def state_print(state):\\n      print(\"c\" + \"\".join([\"*\"  if x else \".\" for x in state[0][1:]]))\\n      for line in state[1:]:\\n          print(\"\".join([\"*\"  if x else \".\" for x in line]))\\n  \\n  def solve(state, mines):\\n      prev_state = deepcopy(state)\\n      for row in range(len(state)):\\n          for col in range(len(state[row])):\\n              new_state = deepcopy(state)\\n              clear(new_state, (row, col))\\n              c = count(new_state)\\n              if(c < mines):\\n                  state = prev_state\\n              elif( c == mines):\\n                  state_print(new_state)\\n                  return True\\n              else:\\n                  if col == len(state[row]) -2:\\n                      prev_state = deepcopy(state)\\n                  state = new_state\\n      print(\"Impossible\")\\n      return False\\n  \\n  \\n  \\n  \\n  def main():\\n      filename = \"C-small-attempt0.in\"\\n  \\n  \\n      inp = open(filename, \"rU\")\\n  \\n      n = int(inp.readline().strip())\\n  \\n      for case in range(1, n + 1):\\n          R, C, M = map(int, inp.readline().strip().split(\" \"))\\n          state = [[1 for x in range(C)] for y in range(R)]\\n          print(\"Case #{}:\".format(case))\\n          solve(state, M)\\n  \\n  main()\\n", "target": "57", "substitutes": {"state": ["name", "section", "address", "STATE", "object", "region", "un", "scope", "position", "seed", "machine", "zip", "back", "parent", "cell", "states", "node", "stat", "range", "rule", "patch", "ode", "length", "ace", "instance", "count", "type", "l", "local", "body", "port", "old", "all", "time", "pe", "test", "code", "f", "area", "update", "self", "oper", "step", "slice", "p", "j", "match", "now", "config", "down", "file", "form", "history", "can", "error", "space", "layer", "date", "pair", "loc", "public", "m", "core", "grade", "resource", "function", "order", "data", "al", "block", "model", "new", "key", "frame", "st", "shape", "run", "bug", "private", "size", "power", "unit", "point", "cal", "list", "start", "force", "output", "part", "string", "parse", "connection", "source", "session", "State", "value", "sync", "style", "work", "cache", "use", "message", "statement", "scale", "store"], "coord": ["ctx", " coordinate", "range", "dom", "loop", "du", "location", "pos", "num", "cube", "word", "coll", "patch", "dc", "xy", "point", "address", "cal", "channel", "config", "direction", "number", "cat", "form", "co", "gap", "route", "lat", "error", "date", " coordinates", "com", "connection", "pair", "loc", "record", "position", "rect", "pixel", "ctrl", "index", "comp", "order", "data", "component", "char", "batch", "xxxx", "cell", "ord", "dim", "cand", "color", "shape", "call", "node", "layer", "code", "con", "span", "area"], "r": ["e", "range", "rr", "br", "d", "i", "rc", "h", "p", "ar", "z", "v", "ir", "re", "w", "q", "m", "l", "rh", "g", "ro", "s", "end", "rn", "k", "rs", "rd", "nr", "b", "rg", "f", "cr"], "c": ["cf", "e", "mc", "d", "i", "rc", "center", "h", "ac", "coll", "dc", "p", "ch", "j", "ce", "u", "count", "ct", "z", "co", "v", "cu", "cs", "w", "cy", "uc", "m", "ci", "l", "ca", "pc", "cc", "s", "bc", "unc", "a", "toc", "k", "ec", "cycle", "nc", "min", "sc", "b", "con", "f", "cm", "cr", "chain", "g", "lc"], "row": ["offset", "Row", "uc", "oy", "rank", "index", "cell", "node", "con", "page", "range", "pos", "month", "length", "none", "arrow", "field", "record", "feed", "w", "ow", "port", "ack", "ri", "f", "post", "user", "low", "area", "server", "tr", "num", "i", "rc", "p", "xy", "co", "loc", "hop", "order", "one", "ro", "block", "key", "head", "frame", "ry", "min", "sc", "lock", "bug", "rows", "h", "coll", "view", "column", "flow", "group", "cur", "entry", "rown", "right", "batch", "dy", "k", "rid", "scale"], "col": ["cf", "COL", "pos", "offset", "act", "ail", "rc", "ady", "word", "coll", "h", "num", "i", "p", "ch", "j", "column", "count", "ct", "year", "val", "rel", "cat", "co", "yl", "loc", "w", "cy", "cur", "rot", "oy", "ci", "el", "l", "cl", "seq", "index", "fl", " Col", "cor", "win", "sec", "key", "int", "cell", "k", "ol", "min", "keep", "path", "con", "ind", "f", "fc", "cp", "foot", "cr", "o", "Col"], "x": ["e", "ctx", "xa", "xs", "xi", "ux", "d", "xt", "id", "i", "px", "X", "sex", "h", "xp", "xf", "p", "xy", "point", "oint", " X", "u", "xes", "z", "rx", "t", "cross", "exp", "yx", "co", "v", "_", "xb", "on", "inx", "long", "dx", "w", "q", "rex", "l", "index", "ex", "xc", "xxx", "wx", "xe", "work", "expl", "int", "pe", "lex", "ic", "test", "xx", "ix", "code", "array", "f", "ax", "g", "check"], "line": ["range", "name", "pos", "ne", "inline", "len", "str", "slice", "lined", "point", "length", "max", "column", "val", "li", "number", "Line", "co", "lin", "string", "un", "log", "l", "day", "block", "ln", "end", "pe", "cell", "time", "frame", "cycle", "run", "lines", "code", "con", "o"], "mines": ["colores", "colions", "generions", "coles", "generes", "minxes", "minores", " minores", "rainES", "rainics", "rainions", "minations", "MinES", "Minics", " minations", "MINus", "MINations", "Mines", "minES", "generES", "Minus", "MINores", "Minations", "minions", "raines", "Minxes", "generics", "minics", " minus", " minxes", "colxes", "Minores", " minions", "Minions", "MINes", "minus"], "prev_state": [" prev_position", " prev_name", "vious_resource", "vious_line", "prev_line", "prev_stat", " prev_start", "prev_resource", "vious_key", "prev_states", "prev_position", "vious_state", " prev_resource", "prev_name", "prev_start", " prev_stat", "prev_key", " prev_states"], "new_state": ["newJstates", "cleanJspace", "newamcomponent", "prev_component", "new67state", "prev_scope", "next_row", "next_state", "new67call", "clean_space", "cleanJstate", "cleanJobject", "new_scope", "clean_state", "new67style", "next_call", "cleanJstates", "new_space", "prev_style", "newJobject", "newJspace", "prev_resource", "new_style", "next_slice", "new_order", "new_rule", "newamscope", "new_slice", "prev_rule", "new_object", "clean_states", "new_private", "new_component", "newamstyle", "prev_order", "new_row", "new_states", "new67slice", "new_call", "newJstate", "newamstate", "clean_object", "new67row", "new67rule", "prev_private", "newParresource", "newParstate", "new67private", "newParorder", "new_resource"], "filename": ["aml", "il", "figure", "fd", "jpg", "itled", "mph", "fn", "document", "fil", "jet", "approximately", "username", "phrase", "jl", "file", "File", "dll", "connection", "profile", "sf", "amer", "database", "ls", "binary", "Filename", "utf", "fp", "ppa", "nil", "sheet", "files", "SourceFile", "title", "ename", "directory", "open", "ema", "appy", "iled", "download", "FILE", "kl", "path", "subject", "which"], "inp": ["kinpt", "INpo", "insh", "Inc", "kinp", "Inh", "inh", "insp", "innproc", "insc", "innp", "innc", "Inpt", " inpo", "INproc", "incp", "kinps", "inps", " inproc", "inc", "inpo", "innpo", "incps", "Inl", "INp", "inf", " inc", " inl", "incpt", " inh", "INc", "inl", "insl", "kinf", "Inp", "inproc", "Inf", "Inps", "incf", "inpt"], "n": ["N", "size", "ne", "ns", "i", "num", "len", "p", "j", "en", "count", "nt", "t", "number", "ni", "un", "m", "l", "network", "nb", "s", "sn", "k", "nc", "con", "b", "span", "o", "cn", "nu"], "case": ["e", "size", "name", "mi", "id", "SC", "patch", "p", "section", "me", "match", "ace", "ce", "length", "config", "count", "instance", "change", "cases", "ase", "number", "nce", "loc", "position", "uc", "Case", "ice", "block", "bc", "use", "time", "key", "a", "test", "catch", "call", "code", "cp", "trial", "mode"], "R": ["N", "Rh", "U", "RH", "G", "X", "p", "RR", "I", "MR", "W", "Rs", "K", "RO", "RN", "L", "State", "D", "A", "T", "B", "RS", "S", "CR", "E", "H", "F", "V", "DR", "RM", "Y", "Q", "P"], "C": ["N", "U", "G", "X", "Co", "Cu", "O", "COR", "I", "CL", "W", "CE", "K", "DC", "CC", "L", "D", "A", "T", "B", "S", "CV", "CR", "E", "H", "CI", "F", "V", "CU", "Y", "Q", "P", "Col"], "M": ["N", "U", "MO", "G", "X", "J", "O", "I", "W", "MD", "MS", "CM", "MT", "m", "MN", "L", "D", "MC", "T", "B", "DM", "S", "E", "H", "MF", " m", "F", "V", "RM", "Y", "Q", "P", "MM", "LM"], "y": ["yr", "my", "d", "yy", "ay", "ady", "h", "month", "ye", "ch", "xy", "j", "year", "z", "ym", "yl", "cy", "q", "oy", "day", "dy", "ry", "ya", "cycle", " yr", "Y", "gy", "yd"]}}
{"code": "\\n  BASE_RATE = 2.0\\n  \\n  def process_case(C, F, X):\\n      rate = BASE_RATE\\n      total_time = 0.0\\n      while True:        \\n          xtime = X / rate\\n          ctime = C / rate\\n          ext_rate = rate + F\\n          ext_time = ctime + (X / ext_rate)\\n          if xtime <= ext_time:\\n              total_time += xtime\\n              break\\n          total_time += ctime\\n          rate = ext_rate\\n      return total_time\\n  \\n  def result_gen(lines):\\n      ncases = int(next(lines))\\n      for ci in range(1,ncases+1):\\n          C, F, X = line_of_floats(next(lines))\\n          result = process_case(C, F, X)\\n          yield 'Case #{0}: {1:.7f}\\n'.format(ci, result)\\n  \\n  def line_of_floats(s):\\n      return [float(sub) for sub in s.split()]\\n  \\n  def input_gen(f_in):\\n      for line in f_in:\\n          if line.endswith('\\n'):\\n              line = line[:-1]\\n          yield line\\n  \\n  def start(basename):\\n      infile = basename + '.in'\\n      outfile = basename + '.out'\\n      f_in = open(infile, 'r')\\n      f_out = open(outfile, 'w')\\n      f_out.writelines(result_gen(input_gen(f_in)))\\n      f_in.close()\\n      f_out.close()\\n  \\n  start('B-small-attempt0')\\n", "target": "58", "substitutes": {"BASE_RATE": ["BASE_BRAT", "BASE2BRAT", "BASE2BRATES", "BASE_MATCH", "BASE_WRACE", "BASE_BRATE", "BASE_BRACE", "BASE_WRATES", "BASE_GRATE", "BASE_GRASE", "BASE_RATCH", "BASE_LASE", "BASE_MATE", "BASE_RACE", "BASE_GRATCH", "BASE_WRATE", "BASE_LATE", "BASE_RASE", "BASE2RATE", "BASE_LATES", "BASE2RACE", "BASE_MATES", "BASE2RAT", "BASE2BRACE", "BASE2BRATE", "BASE_WRAT", "BASE2RATES", "BASE_BRATES", "BASE_LATCH", "BASE_RATES", "BASE_MASE", "BASE_GRATES", "BASE_RAT"], "C": ["N", "CF", "Cs", "U", "Cy", "G", "Co", "SC", "Cu", "O", "CL", "CNN", "I", "CA", "W", "Cl", "M", "CM", "Z", "CE", "NC", "K", "Line", "DC", "CP", "L", "D", "A", "Case", "R", "MC", "T", "CN", "B", "S", "FC", "c", "CV", "E", "CS", "CI", "V", "CU", "Y", "P"], "F": ["N", "CF", "U", "G", "Fs", "FD", "DF", "O", "I", "FB", "W", "FL", "File", "M", "Z", "K", "FIN", "Fi", "FS", "L", "D", "A", "R", "T", "PF", "B", "FH", "GF", "FA", "S", "WF", "FM", "E", "H", "CI", "V", "FF", "Y", "Q", "P", "UF", "f", "FG", "Fe"], "X": ["N", "Test", "CF", "U", "CH", "XL", "G", "Cu", "Time", "ZX", "XP", "O", "IX", "XXX", "CL", "TX", "W", "IP", "File", "M", "NC", "Z", "CE", "K", "EC", "XM", "CC", "L", "EX", "D", "R", "T", "FX", "B", "WH", "Ex", "S", "FC", "CR", "E", "H", "UX", "CI", "x", "V", "FF", "XY", "Y", "Q", "P", "XX", "PE", "CT"], "rate": ["rand", "weight", " trace", " fee", "case", "exp", "race", "prime", "rank", " formula", " grade", "depth", "gain", "delay", " tie", "con", "range", "speed", "rule", "rated", "rake", "RR", "ride", "ale", "currency", "feed", "sample", "R", "frac", "FE", "time", " status", "cycle", "ga", " source", "code", " code", "score", "rc", "true", "feature", " rule", " feed", "max", "Rate", "date", "rice", "core", "grade", "alpha", "rates", "CR", "factor", "ry", "run", "cost", "frequency", "trial", "rating", " credit", "charge", " rc", "unit", "rat", "r", "com", "late", "GE", "age", "value", "sync", "fee", " acc", "cr", "cale", "scale"], "total_time": [" total_times", "total\u00b7times", "total\u00b7time", "total64money", "total_money", "total\u00b7rate", "total_date", "total64rate", " total_rate", " total_money", "total64time", "total_times", " total_date", " total_timer", "total64times", "total_timer", "total\u00b7date", "total_rate"], "xtime": ["extime", "xtype", "cture", "rtype", "rtage", "extype", "rtime", "xage", "octime", "ptale", "xtale", "xtimate", "xtage", "pasttime", "ctimate", "ptimate", "pasture", "cttime", "pttime", "xetime", "octure", "xime", "ptime", "ctale", "xype", "octale", "pastimate", "rtetime", "extetime", "pastime", "xture", "xttime", "extage", "xtetime", "pture", "octimate"], "ctime": ["cture", "latimate", "latime", "xtIME", "CTimes", "octime", "xtale", "xtimate", "xtage", "ptimes", "ftimes", "ctimate", "CTIME", "ptimate", "CTale", "cttime", "ftage", "ctIME", "ptime", "ctale", "CTime", "latimes", "ftime", "xtimes", "CTtime", "octale", "octimes", "ctimes", "lature", "fttime", "xture", "ctage", "xttime", "octIME", "pture", "CTage"], "ext_rate": ["extiancycle", "xt_cycle", "external_date", "extiantime", "xt_rate", "main_rat", "ext_cycle", "main_rate", "ext_rat", "main_rates", "ext_speed", "main_speed", "xt_scale", "external_scale", "xt_time", "external_rate", "ext_scale", "ext_date", "external_rat", "ext_rates", "extianscale", "extianrate"], "ext_time": ["ext64rule", "ext\u00b7call", "extingrate", "xt_speed", "xt_rate", "extingtime", "external_rule", "ext\u00b7time", "extmtime", "xt_rule", "ext_rule", "extmrate", "ext_call", "ext\u00b7rate", "ext64rate", "extingrule", "ext_speed", "external_call", "xt_time", "external_rate", "ext\u00b7rule", "extmrule", "extmcall", "external_time", "ext64time", "ext64speed", "extingspeed"], "lines": ["rules", "results", "ines", "ns", "ids", "rows", "words", "lined", "sections", "codes", "cases", "planes", "cells", "lins", "Line", "ds", "lin", "ses", "elines", "pages", "ins", "plugins", "ls", "breaks", "groups", "models", "posts", "frames", "files", "strings", "blocks", "links", "los", "cycles", "items", "tests", "flows", "limits", "users", "runs", "lists", "objects", "steps", "lc"], "ncases": ["ncased", "necasing", "natches", "necases", "ncatches", "nase", "dcasing", "necase", "dcatches", "lcases", "nased", "nsased", "nsatches", "lcase", "lcatches", "necatches", "lcased", "ncase", "dcases", "nsasing", "nsases", "dcased", "necased", "nases", "ncasing"], "ci": ["cf", "ini", "si", "xi", "i", "dc", "viol", "ce", "oci", "I", "case", "ct", "zi", "li", "pi", "cat", "co", "cu", "sci", "cs", "uc", "cia", "cont", "l", "ii", "inf", "cci", "di", "char", " ii", "c", "cod", "cin", "ic", "CI", "nc", " il", "code", "cm", "ind", "arc", "f", "fc", "cn", "lc"], "result": ["page", "results", "counter", "default", "score", "RESULTS", "final", "feature", "product", "match", "ret", "complete", "future", "case", "r", "response", "output", "report", "comment", "res", "date", "ise", "dict", "grade", "function", "value", "data", "text", "runner", "new", "df", "Result", "success", "test", "message", "mate", "transform", "Results", "answer"], "s": ["e", "si", "ws", "ines", "rows", "slice", "sb", "p", "series", "services", "sections", "su", "cells", "spec", "space", "string", "ses", "sets", "comments", "source", "n", "ins", "l", "ls", "ss", "sl", "S", "strings", "c", "parts", "states", "items", "tests", "sc", "sites", "f", "g", "se"], "sub": ["si", " substr", "id", "slice", "sb", "section", "child", "desc", "case", "exp", "form", "sum", " subs", "ses", "string", "loc", "uc", "type", "sim", "seq", "sd", " Sub", "ub", "job", "text", "sing", "sel", "bc", "Sub", "sec", " subst", "cell", "test", "sam", "sc", "repe", "sup", "lc"], "f_in": ["f_nin", "cf_IN", "cf_ins", "f__in", "f__IN", "f_IN", "cf_nin", " f_ins", "f2IN", "cf_in", "f2in", "f_inner", "f_din", " f_inner", "cf_out", " f_IN", "f__nin", " f_din", "f__out", "f_ins", "f_ini", " f_ini", "f2out", "f__ins", "f2ins"], "line": ["page", "range", "strip", "loop", "name", "pos", "ine", "rule", "word", "inline", "str", "unit", "liner", "lined", "document", "next", "lf", "out", "input", "case", "file", "response", "Line", "object", "lin", "row", "string", "LINE", "side", "error", " Line", "source", "limit", "log", "n", "L", "l", "cl", "entry", "function", "link", "text", "block", "base", "c", "all", "end", "pe", "cell", "frame", "site", "message", "buffer", "run", "code", "f", "lc"], "basename": [" baseline", "baseame", "pacename", "baseername", "baseme", "baseimen", " baseme", " basimen", "ancename", "pacername", "basername", "anceme", "ancame", "ancername", " basame", " basername", "pacimen", "pacame", "basame", "baseename", "baseline", "baseeme", "baseeline", "anceline", "basimen"], "infile": [" inile", " inbase", " infolder", "inifile", "inpipe", "outbase", "outpipe", " inpipe", "inifilename", "linfile", "linfolder", "infilename", "outfilename", "infolder", "outfiles", "infiles", "outfolder", "linfiles", "inipipe", "inile", "inibase", "outile", "inbase", " infilename", "linile", " infiles"], "outfile": ["outFile", "Outfilename", "inputname", "outname", " outfilename", "inpath", " outclass", "Outname", "outputfile", "infilename", "outfilename", "inputFile", " outpath", "Outfile", "outpath", "inputclass", "outputclass", "Outpath", "outclass", "outputFile", "inname", " outname", "outputname", " outFile", "inputfile"], "f_out": ["f___in", "f_Out", " f_OUT", "f_nin", "f_OUT", "f___OUT", " f_nin", "f___outer", "f_outer", " f_outer", " f_Out", "f___out", " f_again", "f_again"]}}
{"code": "\\n  def mines_refill(board, xr, xc, nfree):\\n      to_refill = xr*xc - nfree\\n      for r in reversed(range(2, xr)):\\n          for c in reversed(range(2, xc)):\\n              if not to_refill:\\n                  return\\n              assert(board[r][c] == '.')\\n              board[r][c] = '*'\\n              to_refill -= 1\\n      for r in reversed(range(xr)):\\n          for c in reversed(range(xc)):\\n              if not to_refill:\\n                  return\\n              if board[r][c] == '.':\\n                  board[r][c] = '*'\\n                  to_refill -= 1\\n      assert(to_refill == 0)\\n      \\n  def generate_board(nrows, ncols, nmines):\\n      nfree = nrows*ncols - nmines\\n      xr=1; xc=1;\\n      while True:\\n          if xr*xc >= nfree:\\n              break\\n          if xr < nrows:\\n              xr += 1\\n          if xr*xc >= nfree:\\n              break\\n          if xc < ncols:\\n              xc += 1\\n      board = [['*' for c in range(ncols)] for r in range(nrows)]\\n      for r in range(xr):\\n          for c in range(xc):\\n              board[r][c] = '.'\\n      mines_refill(board, xr, xc, nfree)\\n      board[0][0] = 'c'\\n      return board\\n          \\n  def find_click_point(board):\\n      nrows = len(board)\\n      ncols = len(board[0])\\n      for r in range(nrows):\\n          for c in range(ncols):\\n              if board[r][c] == 'c':\\n                  return (r,c)\\n      raise ValueError('Start point not present')\\n  \\n  def enum_neighbour_coords(r0, c0, nrows, ncols):\\n      for r in range(r0-1, r0+2):\\n          if r<0 or r>=nrows:\\n              continue\\n          for c in range(c0-1, c0+2):\\n              if c<0 or c>=ncols:\\n                  continue\\n              yield (r,c)\\n  \\n  def click_board(board, click_coords):\\n      nrows = len(board)\\n      ncols = len(board[0])\\n      points = [click_coords]\\n      while points:\\n          r0,c0 = points.pop()\\n          mines_cnt = 0\\n          for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\\n              if board[r][c] == '*':\\n                  mines_cnt += 1\\n          board[r0][c0] = str(mines_cnt)\\n          if not mines_cnt:\\n              for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\\n                  if board[r][c] == '.':\\n                      points.append((r,c))\\n  \\n  def all_fields_checked(board):\\n      nrows = len(board)\\n      ncols = len(board[0])\\n      for r in range(nrows):\\n          for c in range(ncols):\\n              if board[r][c] == '.':\\n                  return False\\n      return True\\n  \\n  def is_board_oneclick(original_board):\\n      board = [row[:] for row in original_board] # deep copy\\n      assert(board[0][0] == 'c')\\n      r,c = find_click_point(board)\\n      click_board(board, (r,c))\\n      is_oneclick = all_fields_checked(board)\\n      return is_oneclick\\n  \\n  def board2result(board):\\n      return [''.join(row) for row in board]\\n  \\n  def process_case(nrows, ncols, nmines):\\n      board = generate_board(nrows, ncols, nmines)\\n      if is_board_oneclick(board):\\n          result = board2result(board)\\n      else:\\n          result = ['Impossible']\\n      return result\\n  \\n  def result_gen(lines):\\n      ncases = int(next(lines))\\n      for ci in range(1,ncases+1):\\n          R, C, M = line_of_numbers(next(lines))\\n          result = process_case(R, C, M)\\n          yield 'Case #{0}:\\n'.format(ci, result)\\n          for res_line in result:\\n              yield res_line + '\\n'\\n      \\n  def line_of_numbers(s):\\n      return [int(sub) for sub in s.split()]\\n  \\n  def input_gen(f_in):\\n      for line in f_in:\\n          if line.endswith('\\n'):\\n              line = line[:-1]\\n          yield line\\n  \\n  def start(basename):\\n      infile = basename + '.in'\\n      outfile = basename + '.out'\\n      f_in = open(infile, 'r')\\n      f_out = open(outfile, 'w')\\n      f_out.writelines(result_gen(input_gen(f_in)))\\n      f_in.close()\\n      f_out.close()\\n  \\n  start('C-small-attempt0')\\n", "target": "58", "substitutes": {"board": ["che", "boards", "sequence", "case", "ward", "design", "object", "card", "box", "rank", "back", "cell", "custom", "node", "stroke", "table", "loop", "du", "event", "rule", "ault", "bo", "player", "word", "clean", "ode", "length", "ban", "cat", "feed", "video", "body", "all", "ack", "buffer", "code", "foot", "post", "game", "server", "self", "deck", "cart", "layout", "channel", "config", "lane", "form", "flo", "co", "comment", "Board", "core", "function", "square", "block", "model", "head", "frame", "ide", "result", "ck", "phone", "ko", "draw", "bug", "dom", "room", "pause", "rows", "coll", "view", "que", "list", "hole", "child", "ba", "flow", "image", "boarding", "stream", "land", "home", "entry", "boy", "oard", " clipboard", "road", "null", "line", "control"], "xr": [" xrd", "ysr", "Xpr", "yhr", " xe", "wwrb", "ylr", "dxpr", " xR", "xesr", "sexra", "yrs", "rxe", "Xrs", "idrt", "wxrt", "xe", "xrd", "xxsr", "xxnr", "xrb", "txsr", "pxrc", "qrc", "zr", " Xsr", "pxrt", "qrt", "xhr", "txr", "Xr", "dxdr", "wxnr", "rxr", "txrb", "sexsr", "xesrb", "axrs", "Xra", "txdr", "xsr", "txrt", "qr", "xnr", "txra", "Xrb", "xrt", "axhr", "axrt", " xsr", "xR", " Xr", "xesnr", "exr", "rxsr", "wxrb", "pxrb", "yr", "xdr", "xpr", "axpr", "dxra", "exnr", "dxsr", "dxrt", "txpr", "rxrs", "xesrt", "Xnr", "exrs", "sexrs", "ypr", "znr", "pxr", "rxnr", "sexr", " Xrd", "zrs", "Xsr", "idr", "ylrs", "wwrt", " xnr", "xxe", "exrb", "wxr", "xrs", "idnr", "xxrd", "axdr", "rxR", "Xhr", "xxR", "xra", " xra", "idrb", " xrb", "yra", "wwr", " XR", "qrb", "ylra", "xrc", "dxrb", "zrb", "wwrc", "dxr", "xxr", " xrs", "axr"], "xc": ["xd", "ctx", "cf", "eq", "xa", "xs", "xt", "exc", "zx", "cb", "rc", "cmp", "ac", "xp", "dc", "xf", "qa", "enc", "oc", "usc", "vin", "xes", "ct", "rx", "fb", "wb", "xb", "cu", "rec", "cre", "loc", "vc", "uc", "ci", "wy", "ctrl", "wa", "rh", "wx", "etc", "pc", "xe", "bc", "tc", "sec", "unc", "cin", "ince", "ic", "x", "dq", "con", "fc", "acs", "icc", "lc", "abc"], "nfree": ["nFree", "fnblocks", "ncover", "nframe", "Nused", "fnfree", "nlocked", " nframe", "ynFree", "dnfree", "Nframe", "fnFree", "dncover", "nblocks", " nblocks", "numfree", "ntframe", "Nfe", "ntfree", " nused", "dnblocks", "nused", "nfine", "nfit", "ynused", "wrows", "nfe", "NFree", "numused", "ntused", "fncover", "nbused", "Nlocked", "numlocked", "ynfit", " ncover", "wFree", "Nfine", " nFree", "numFree", "wfree", " nlocked", " nfine", "nbfine", "ntFree", " nfit", "wfe", "dnFree", " nfe", "ynfree", "nbFree", "Nfit", "nbfree", "Nfree", "Nrows"], "to_refill": ["to_refillin", "to_reills", "to_relil", "to_bfil", "to_lfil", "to_reail", "to_repend", "to_defilling", "to_ffil", "to_relill", "to_reresh", "to_bfill", "to_filling", "to_reiller", "to_bfail", "to_reend", "to_refiller", "to_lfills", "to_bfend", "to_Refail", "to_defil", "to_ffills", "to_Refill", "to_bfills", "to_bfilling", "to_refend", "to_lfillin", "to_ffillin", "to_fil", "to_reilling", "to_refail", "to_repills", "to_repil", "to_reilled", "to_Refil", "to_reil", "to_relilled", "to_filler", "to_defill", "to_Refilling", "to_Refilled", "to_bfiller", "to_refilled", "to_refills", "to_fill", "to_relail", "to_lfill", "to_reill", "to_ffill", "to_defail", "to_bfresh", "to_repill", "to_refresh", "to_reillin", "to_relresh", "to_refil", "to_refilling"], "r": ["br", "pr", "dr", "lr", "attr", "rh", "ner", "rn", "rd", "nr", "err", "range", "fr", "mr", "er", "z", "w", "n", "l", "R", "ru", "s", "a", "rs", "x", "sr", "b", "rg", "f", "o", "e", "yr", "rr", "rb", "d", "self", "tr", "wr", "rc", "p", "oc", "j", "gr", "ar", "t", "v", "ir", "re", "m", "g", "ro", "rt", "result", "h", "str", "ur", "u", "ra", "cur", "q", "hr", "rf", "right", "kr", "k", "arc", "cr", "vr"], "c": ["col", "name", "cv", "rec", "uc", "cy", "ca", "unc", "cell", "y", "con", "cm", "fc", "enc", "C", "ch", "count", "z", "cs", "w", "type", "n", "l", "cc", "s", "ic", "x", "code", "b", "f", "o", "e", "d", "i", "rc", "dc", "p", "oc", "ce", "ar", "config", "t", "co", "v", "m", "ci", "cont", "g", "pc", "ec", "sc", "chain", "cf", "mc", "h", "ac", "ur", "u", "ct", "cu", "cur", "vc", "q", "cl", "cent", "cache", "k", "nc", "arc", "cr", "cp", "cn", "lc"], "nrows": ["ncblocks", "ncrows", "ncrs", "netows", "numblocks", "Nrs", "ncells", "Nboards", "ynows", " npages", "nclines", "netrows", "nblocks", " nblocks", "numcells", "Npages", "nows", "numfree", "ynrow", " nrs", "neblocks", "noncells", "nonows", " nrow", "ntrows", "nonrows", "Ncells", "ntrow", "nonfree", " nlines", " ncells", "ynrows", "numrow", "nlines", " nows", "nonblocks", "nrs", "netlines", "nerows", "nerow", "neows", "ynboards", "Nrow", "ntows", "ncrow", "Nows", "ncows", "numrows", "numows", " nboards", "Nblocks", "nrow", "nboards", "npages", "Nfree", "ntpages", "netblocks", "Nrows"], "ncols": ["Ncolumnb", "ncld", "Ncolapses", "nllapses", "numColes", "ncolb", " ncolows", "numcoles", " ncolsets", "nmins", "nCold", "nColapses", "Ncolows", "nlles", " ncolumnts", "nColes", "Ncolz", "Ncolb", " ncolumnops", "nCols", " ncolumns", "numcold", " ncolumnows", "ncolumnes", "nclb", "ncolts", " ncolts", "Ncoli", "npti", "Ncoles", "ncolumnsets", "numcolumnd", "ncolapses", "numcolumnses", "ncolumns", "Ncolts", "nColb", " ncoli", "numcolumns", "nptz", "NColi", "Ncols", "nminb", "nclses", "numcolumnb", "numcolb", "nllses", "nllts", "nlli", "nColsets", "Ncolops", "ncolumnts", "nCOLts", "Ncolumnows", " ncolb", "nCOLs", "numCols", "nColts", "npts", "ncolows", "ncolumnapses", " ncolumnsets", "ncolumnd", "ncls", "Ncolumnses", "Ncolumnops", "numcolses", "NCols", "ncolsets", "ncolumnops", "ncolumni", " ncolumnb", "Ncolumnes", "nColows", "ncolumnb", "ncold", "nColz", "Ncolumnapses", "nllops", "ncolumnses", "ncolz", "ncoles", "NColz", " ncolumni", "Ncolses", "nptes", "ncolses", "nColi", " ncolops", "nColses", "nlls", "ncolumnows", "nCOLsets", "nminows", "numCold", "Ncolumns", "numcols", "NColes", "ncolumnz", "nColops", "nCOLb", "ncoli", "NColts", "numColb", "ncolops"], "nmines": ["ncoles", "Nmns", " nlins", "nlins", "Nmnores", "npries", "Nminores", "nserves", " nminions", " nlinipes", " nmins", "nmills", "nlinions", " nlinions", "nmins", "Nmins", "nmnions", "nmns", "nmnes", "npriions", "nmilles", " nlines", "Nmines", "ncolions", "nlines", "nservs", "ncolipes", "nminions", "nmnores", "nmillions", "nminipes", "nservions", " nminipes", "nmillipes", "nservores", "nminores", "Nminions", "Nmnes", "Nmnions", "nlinipes", "npris", "npriores"], "r0": ["cr8", "r1", "rr100", " r8", "c90", "x00", "xE", "p00", "p50", "cr0", "r50", "p0", "cE", "c50", "r100", "cr100", "c00", "rr0", "p90", "x1", " r1", " r90", "r8", "x0", " r100", "rr8", "r00", "pE", "rE", "c1", "r90", " r50", "p1"], "c0": ["lc00", "f0", "xc00", "r1", "xc0", "c90", "k00", "c63", "p00", "p0", "lc90", "k1", "c050", "c00", "p90", "rc050", "xc63", "rc00", "cie", "rc1", "f00", "fie", " c00", "r00", "r050", "xcie", " c90", "rc0", "k050", "c1", "k0", " c63", "lc0", " cie", "f63"]}}
{"code": "f = open('input.in')\\n  g = open('output', 'w')\\n  \\n  T = int(f.readline()[:-1])\\n  \\n  def tot(n) :\\n      if n == 0 : return X / 2\\n      else :\\n          s = 0\\n          for i in range(0, n) : s += C / (2 + i*F)\\n          return s + X / (2 + n*F)\\n  \\n  for case in xrange(T) :\\n      C, F, X = map(float, f.readline()[:-1].split())\\n      N =  int(X/C) + 1\\n      s, e = 0, N\\n      if tot(0) >= tot(1) : \\n          while True :\\n              m = (s+e)/2\\n              if tot(m) <= tot(m-1) and tot(m) <= tot(m+1) : break\\n              elif tot(m-1) <= tot(m) <= tot(m+1) : e = m\\n              elif tot(m-1) >= tot(m) >= tot(m+1) : s = m\\n              else : 1/0\\n      else : m = 0\\n      output = 'Case #' + str(case + 1) + ': ' + str(tot(m))\\n      g.write(output + '\\n')\\n      print output\\n  \\n  f.close()\\n  g.close()\\n", "target": "59", "substitutes": {"f": ["fw", "fd", "d", "fr", "info", "h", "p", "lf", "input", "flow", "handler", "fo", "t", "file", "tf", "fb", "form", "v", "ref", "stream", "io", "feed", "w", "conf", "l", "function", "fp", "fs", "body", "func", "c", "a", "df", "x", "b", "fc", "o", "fen"], "g": ["gen", "gi", "sg", "ge", "d", "gs", "G", "h", "p", "msg", "j", "cfg", "out", "go", "u", "mg", "r", "z", "t", "v", "group", "io", "w", "q", "gb", "l", "og", "gp", "log", "ig", "c", "gh", "x", "ga", "vg", "gz", "b", "rg", "o", "gm"], "T": ["U", "G", "TN", "O", "I", "TS", "W", "t", "M", "Z", "L", "D", "A", "R", "B", "S", "TT", "c", "E", "H", "V", "NT", "Y", "Q", "P", "CT"], "n": ["d", "ne", "ns", "num", "h", "p", "j", "u", "z", "nt", "r", "t", "M", "v", "ni", "nn", "w", "q", "l", "c", "a", "Ns", "k", "x", "nc", "y", "b", "o", "cn"], "s": ["size", "si", "WS", "xs", "ms", "ws", "d", "gs", "ps", "ns", "rows", " lines", "Us", "p", " S", "u", "su", "z", "r", "t", "v", "sum", "its", "ses", "cs", "w", "es", "ies", "l", "ls", "os", "ss", " c", "S", "eps", "c", "ans", "sn", "E", "a", "Ns", "ions", "states", "us", "x", "rs", "y", "Y", "lines", "ends", "b", "o", "se", "ops"], "i": ["gi", "si", "ini", "xi", "ip", "d", "id", "num", "p", "j", "I", "u", "z", "ie", "r", "li", "ai", "ni", "v", "q", "ci", "l", "ii", "bi", "ti", "c", "int", "a", "x", "ix", "y", "b", "ind"], "case": ["d", "name", "id", "p", "section", "me", "address", "match", "length", "ce", "ace", "switch", "instance", "count", "ase", "cases", "_", "position", "core", "Case", "ice", " c", "c", "use", "time", "int", "key", "test", "shape", "x", "line", "code", "trial", "mode", "se"], "C": ["CF", "Cs", "U", "G", "Cu", "O", "I", "W", "M", "Z", "K", "CM", "CE", "DC", "CC", "L", "D", "A", "R", "B", "S", "c", "CR", "E", "H", "CS", "V", "CU", "Y", "Q", "P"], "F": ["CF", "U", "G", "Fs", "FD", "DF", "O", "I", "W", "M", "Z", "K", "FIN", "L", "D", "A", "GF", "B", "FH", "PF", "S", "FC", "Fun", "E", "H", "SF", "V", "FF", "Y", "Q", "P"], "X": ["U", "xs", "G", "XP", "O", "IX", "I", "CL", "Size", "z", "W", "M", "NC", "Z", "CE", "K", "w", " x", "XM", "CC", "L", "Sc", "D", "A", "R", "B", "Ex", "S", "c", "E", "H", "Ns", "x", "V", "Y", "NS", "Q", "P", "XX"], "N": ["U", "d", "G", "p", "O", "I", "Size", "Num", "W", "M", "Z", "L", "D", "A", "R", "B", "S", "c", "E", "Ne", "H", "Ns", "V", "x", "Y", "Q", "P"], "e": ["d", "ne", "ee", "h", "p", "j", "en", "u", "oe", "z", "r", "ie", "t", "v", "ed", "ae", "w", "es", "l", "el", " E", "c", "end", "E", "ec", "x", "fe", "y", "b", "o", "se"], "m": ["ms", "mc", "module", "em", "d", "my", "km", "om", "mi", "dm", "h", "more", "month", "p", "pm", "j", "me", "man", "mr", "sm", "mu", "u", "im", "mm", "z", "r", "bm", "t", "an", "M", "mac", "fm", "v", "ym", "nm", "am", "um", "mo", "hm", "tm", "l", "L", "machine", "md", "c", "E", "a", "x", "line", "y", "mon", "b", "cm", "o", "gm", "mn"], "output": ["fore", " Output", "four", "Output", "written", "final", "unit", "next", "document", "O", "current", "xml", "out", "op", "input", "en", "config", "print", "image", "response", "write", "console", "file", "summary", "io", "note", "string", "cut", "example", "pretty", "application", "method", "w", "l", "log", "binary", "information", "dot", "expression", "text", "byte", "generated", "put", "result", "message", "target", "tmp", "debug", "format", "o", "control", "reason", "external"]}}
{"code": "f = open('input.in')\\n  g = open('output', 'w')\\n  \\n  T = int(f.readline()[:-1])\\n  \\n  for case in xrange(T) :\\n      R, C, M = map(int, f.readline()[:-1].split())\\n      FREE = R*C - M\\n      if FREE == 0 : res = '\\nImpossible'\\n      elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '\\nImpossible'\\n      elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '\\nImpossible'\\n      else :\\n          MAP = [['.' for c in range(C)] for r in range(R)]\\n          MAP[0][0] = 'c'\\n          if R == 1 :\\n              for i in range(C-1, C-M-1, -1) : MAP[0][i] = '*'\\n          elif C == 1 :\\n              for i in range(R-1, R-M-1, -1) : MAP[i][0] = '*'\\n          elif R == 2 :\\n              for i in range(C-1, C-M/2-1, -1) : MAP[0][i], MAP[1][i] = '*', '*'\\n              if FREE == 1 : MAP[1][0] = '*'\\n          elif C == 2 :\\n              for i in range(R-1, R-M/2-1, -1) : MAP[i][0], MAP[i][1] = '*', '*'\\n              if FREE == 1 : MAP[0][1] = '*'\\n          else :\\n              com = M / C\\n              for i in range(R-1, max(R-com-1, 2), -1) :\\n                  MAP[i] = ['*' for j in range(C)]\\n                  M -= C\\n              I = max([i for i, j in enumerate(MAP) if j[0] == '.'])\\n              if I == 2 :\\n                  com = M / 3\\n                  if com == 0 : i = C\\n                  for i in range(C-1, C-com-1, -1) :\\n                      MAP[0][i], MAP[1][i], MAP[2][i] = '*', '*', '*'\\n                      M -= 3\\n                  if M >= 1 : MAP[2][i-1] = '*'\\n                  if M >= 2 :\\n                      if i != 1 : MAP[2][i-2] = '*'\\n                      else : MAP[1][0] = '*'\\n              else :\\n                  for i in range(C-1, C-M-1, -1) : MAP[I][i] = '*'\\n                  if i == 1 :\\n                      MAP[I][i] = '.'\\n                      MAP[I-1][C-1] = '*'\\n          res = '\\n' + '\\n'.join([''.join(i) for i in MAP])\\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\\n      g.write(output + '\\n')\\n      print output\\n  \\n  f.close()\\n  g.close()\\n", "target": "59", "substitutes": {"f": ["e", "fd", "d", "fr", "info", "h", "p", "lf", "input", "u", "z", "uf", "t", "file", "fb", "tf", "form", "v", "io", "feed", "w", "sf", "m", "n", "l", "rf", "fp", "fs", "ff", "s", "df", "F", "x", "b", "fc", "o"], "g": ["gen", "gi", "sg", "gs", "G", "h", "gui", "gl", "gc", "cfg", "go", "z", "group", "w", "q", "m", "gp", "gb", "log", "k", "ga", "ng", "gz", "mem", "gg", "gd", "gm", "wm"], "T": ["N", "G", "X", "TF", "TN", "TS", "TEXT", "TX", "TB", "W", "t", "TM", "TA", "Z", "TH", "L", "SIZE", "GT", "D", "S", "TT", "TC", "E", "H", "F", "V", "NT", "Y", "Q", "P", "UT", "CT", "DT"], "case": ["size", "TR", "U", "SC", "X", "O", "ace", " X", "TA", "EC", "row", "seq", "ice", "cor", "ti", "times", "CO", "TC", "bc", "sec", "time", "E", "toc", "test", "cycle", "x", "REC", "cm", "trial"], "R": ["N", "Rh", "AR", "U", "RH", "YR", "G", "Ch", "X", "Co", "RE", "O", "RR", "COR", "CL", "MR", "W", "Rs", "Range", "Cl", "K", "VC", "RC", "RW", "SR", "RO", "RN", "Re", "Group", "L", "D", "A", "UR", "ER", "JR", "B", "RS", "RED", "Rec", "S", "CO", "RP", "CR", "E", "H", "F", "IR", "V", "DR", "NER", "GR", "RM", "WR", "Rem", "Y", "Ra", "NR", "Q", "P", "RT", "RA", "RG"], "C": ["N", "COR", "WC", "CE", "K", "CON", "RFC", "CC", "FC", "Q", "P", "CT", "Con", "Cs", "X", "Cu", "J", "CL", "CNN", "W", "YC", "NC", "Cl", "EC", "CM", "VC", "DC", "ERC", "L", "Sc", "CAR", "CO", "F", "JC", "U", "G", "Ch", "SC", "Co", "CAN", "RC", "SR", "CW", "Ca", "A", "CN", "S", "CR", "E", "H", "AC", "V", "Y", "ANC", "O", "CA", "Core", "GC", "CP", "Cache", "D", "MC", "B", "CV", "CS", "CI", "CU", "Code"], "M": ["N", "Mon", "AR", "U", "MO", "VM", "G", "X", "MI", "J", "O", "LM", "CL", "MR", "W", "MD", "MS", "Z", "CM", "K", "MT", "MX", "m", "MN", "L", "OM", "Mo", "D", "A", "MU", "MC", "FM", "B", "DM", "S", "MA", "IM", "E", "H", "AM", "F", "COM", "V", "RM", "Y", "Q", "P", "MM", "MF", "RA"], "FREE": ["NOR", "NULL", "REE", "free", "WARN", "MW", "ALE", "RE", "MORE", "COR", "REM", "NE", "MEN", "ERROR", "NEW", "CONT", "LE", "ARE", "CON", "TYPE", "DE", "CLOSE", "ICE", "MODE", "RO", "WE", "Re", "ENT", "NAME", "GE", "SIZE", "FIELD", "ER", "UN", "BER", "ONE", "UM", "ORE", "EW", "ROM", "OVER", "MER", "FR", "EN", "HOW", "CO", "FE", "NUM", "VALUE", "NO", "F", "NER", "RES", "YOU", "USER", "Free", "CLE", "GR", "WR", "USE", "REC", "DER", "WARNING", "MON", "CRE", "MAX", "NR", "FILE", "ERE", " FRE", "ZE", "RA"], "res": ["resp", "clear", "results", "our", " RES", "correct", "ress", "RE", "REG", "msg", "lear", "ras", "pres", "gr", "match", "VAL", "css", "resolution", "arr", "rus", "response", "MS", "rap", "re", "resh", "Res", "release", "resource", "reg", "cache", "reset", "rez", "details", "RES", "result", "reed", "GR", "REC", "err", "req", "reason"], "MAP": ["TR", "NULL", "MO", "AP", "PATH", "RESULTS", "LOC", "Maps", "MW", "OP", "JSON", "GROUP", "REG", "RAW", "PUT", "CL", "MEN", "MR", "SO", "maps", "DO", "map", "MS", "ML", "ARE", "DATA", "TYPE", "LOAD", "CON", "MP", "MODE", "SM", "RO", "WE", "LIST", "MAS", "MAC", "Map", "MN", "COM", "NAME", "SIZE", "PER", "CC", "MC", "UN", "APP", "MAT", "MA", "CO", "GET", "CAP", "ACC", "NUM", "ACE", "RES", "RM", "USE", "FILE", "SET", "MAX", "MH", "LM", "CT", "KEY"], "c": ["e", "cf", "d", "h", "p", "u", "ct", "z", "w", "m", "n", "l", "cl", "cc", "k", "ec", "x", "cm", "b", "cn", "cp", "o", "lc"], "r": ["e", "range", "yr", "rr", "rc", "p", "ur", "ar", "u", "co", "v", "rec", "ir", "re", "m", "rf", "ro", "rn", "err", "rg", "b", "cm", "cr"], "i": ["ini", "il", "im", "zi", "ni", "io", "uri", "index", "bi", "ti", "ji", "phi", "y", "ind", "II", "iw", "ia", "chi", "gi", "si", "mi", "mu", "z", "li", "ui", "n", "l", "ij", "ii", "ib", "yi", "s", "a", "ic", "x", "ri", "b", "o", "e", "d", "id", "p", "multi", "pi", "ai", "v", "m", "ci", "iu", "xi", "ip", "mini", "h", "fi", "u", "ie", "it", "cli", "q", "comp", "ei", "ish", "di", "int", "k", "CI", "qi"], "com": ["comb", "dom", "om", "comm", "ME", "num", "X", " COM", "COR", "REM", "CL", "cal", "company", "lam", "im", "Component", "communication", "co", "CONT", "CM", "WE", "loc", "conf", "uc", "tm", "CC", "COM", "OM", "sim", "cl", "cum", "comp", "log", "ex", "al", "common", "mod", "IM", "Com", "lim", "all", "TC", "SIM", " Com", "CO", "tc", "imp", "CI", "x", "ab", "min", "CU", "cm", "rem", "con", "mem", "up"], "j": ["si", " Dj", "num", "json", "J", "item", "p", "im", "z", "jl", "li", "t", "jj", "v", "_", "it", "obj", " J", "q", "m", "n", "ci", "l", "jp", "adj", "ij", "dj", "bj", "ja", "jit", " it", "ji", "k", " jo", "aj", "jo", "b", "IJ", "o", "js", "oj"], "I": ["N", "U", "X", "MI", "J", "SI", "PI", "W", "IT", "NI", "Z", "VC", "UI", "IC", "DI", "ci", "L", "B", "KI", "BI", "LI", "AI", "CI", "VI", "V", "F", "Y", "Is", "GI", "Q", "P", "IJ", "II", "IA"]}}
{"code": "def solve():\\n      c, f, x = map(float, raw_input().split())\\n      ans = 1e40\\n      cur = 0.0\\n      psp = 2.0\\n      while cur < ans + 1e-8:\\n          ans = min(ans, cur + x / psp)\\n          cur += c / psp\\n          psp += f\\n      return ans\\n  for t in xrange(int(raw_input())):\\n      print \"Case #%d: %.7f\" % (t + 1, solve())\\n", "target": "60", "substitutes": {"c": ["e", "d", "i", "h", "ac", "C", "dc", "p", "ch", "ce", "max", "u", "count", "r", "z", "co", "cu", "cs", "w", "uc", "n", "ci", "l", "cus", "ca", "cc", "s", "unc", "a", "y", "sc", "con", "cm", "b", "cp", "o", "cn", "lc"], "f": ["cf", "e", "d", "col", "i", "h", "xf", "p", "bf", "u", "z", "form", "v", "w", "sf", "q", "n", "m", "l", "rf", "fp", "inf", "fs", "df", "F", "fe", "y", "b", "fc", "o", "g", "fa"], "x": ["e", "cf", "xs", "d", "i", "px", "X", "h", "xp", "xf", "p", "max", "xes", "u", "z", "rx", "an", "cross", "v", "w", "q", "n", "sq", "l", "ex", "xc", "s", "unc", "ph", "xx", "ix", "y", "b", "g"], "ans": ["AN", "ANS", "ws", "xs", "cons", "ps", "args", "ns", "offs", "sk", "rc", "len", "ac", "p", "oss", "ar", "ace", "max", "an", "ase", "amps", "can", "ays", "ds", "na", "cs", "aces", "ins", "ls", "A", "aus", "os", "cus", "ss", "ad", "ks", "ens", "au", "ann", "eps", "all", "s", "anc", "unc", "a", "ars", "urs", "rs", "vs", "scan", "asc", "ants", "ats", "aned", "span", "acs", "es", "ops"], "cur": ["cf", "inter", "per", "col", "ctr", "rc", "ur", "oc", "current", "ch", "ce", "ar", "now", "dr", "start", "ah", "su", "Cur", "count", "r", "arr", "ver", "acc", "occ", "cat", "co", "cu", "prev", "iter", "uc", "ci", " Cur", "sur", "rest", "cus", "cor", "char", "anch", "bc", "cc", "anc", "unc", "car", "ph", " curs", "urs", "result", "asc", "sr", "keep", "sc", "con", "cer", "cr", "orig", "ser"], "psp": ["apsc", "apsp", "Pspi", "psv", "apsf", "Psp", "arsd", "arsn", "PSlp", "ppsp", "arspi", "arsP", "epsf", "PSf", "lsc", "Psd", "lsp", " psn", "ssl", "ppspi", "arsp", "psP", "psf", "psn", "ppsc", "PSv", "arsps", "psc", "psps", "pspi", "pslp", "Psps", "ppsl", "sspi", "epslp", "psl", "epsp", "lspi", "PSpi", "ssp", "arsv", "Psv", " psd", "PSp", "PSc", "Psn", "apslp", "PSP", "lsl", "ssc", "psd", "epsc", " psps", "PsP"], "t": ["e", "tt", "inter", "d", "col", "num", "i", "tz", "h", "p", "j", "u", "pt", "r", "qt", "it", "z", "dt", "w", "type", "q", "m", "n", "l", "seq", "the", "T", "tim", "time", "int", "tp", "test", "y", "ind", "trial", "g", "ts"]}}
{"code": "def solve():\\n      h, w, m = map(int, raw_input().split())\\n      if h == 1:\\n          print 'c' + '.' * (h * w - m - 1) + '*' * m\\n      elif w == 1:\\n          for c in 'c' + '.' * (h * w - m - 1) + '*' * m:\\n              print c\\n      elif h * w - m == 1:\\n          print 'c' + '*' * (w - 1)\\n          for _ in xrange(h-1):\\n              print '*' * w\\n      else:\\n          m = h * w - m\\n          for i in xrange(h-1):\\n              for j in xrange(w-1):\\n                  t = (i + 2) * 2 + (j + 2) * 2 - 4\\n                  r = (i + 2) * (j + 2)\\n                  if t <= m <= r:\\n                      a = [['*'] * w for _ in xrange(h)]\\n                      for k in xrange(i+2):\\n                          a[k][0] = '.'\\n                          a[k][1] = '.'\\n                      for k in xrange(j+2):\\n                          a[0][k] = '.'\\n                          a[1][k] = '.'\\n                      for y, x in product(range(2, i+2), range(2, j+2)):\\n                          if y == 1 and x == 1:\\n                              continue\\n                          if t >= m:\\n                              break\\n                          a[y][x] = '.'\\n                          t += 1\\n                      a[0][0] = 'c'\\n                      for s in a:\\n                          print ''.join(s)\\n                      return\\n          print 'Impossible'\\n  for t in xrange(int(raw_input())):\\n      print \"Case #%d:\" % (t + 1)\\n      solve()\\n", "target": "60", "substitutes": {"h": ["e", "d", "hi", "p", "ch", "ah", "u", "z", "sh", "ih", "v", "ht", "hm", "q", "n", "l", "oh", "wa", "g", "rh", "time", "H", "ph", "th", "hs", "b", "f", "o", "bh"], "w": ["e", "ws", "d", "ww", "word", "p", "width", "max", "u", "wl", "z", "W", "wb", "sh", "kw", "v", "aw", "ew", "hw", "q", "ow", "n", "l", "wa", "wall", "wx", "wd", "win", "work", "wt", "wan", "we", "wal", "wave", "wh", "b", "sw", "f", "o", "g"], "m": ["e", "range", "mc", "d", "mi", "om", "p", "mr", "sm", "mu", "u", "mm", "z", "W", "M", "v", "ym", "am", "mo", "hm", "q", "n", "tm", "l", "md", "ma", "b", "f", "cm", "o", "g"], "c": ["e", "cf", "mc", "d", "col", "ac", "dc", "C", "p", "ch", "ct", "mac", "z", "co", "cu", "cs", "div", "n", "l", "all", "cc", "unc", "nc", "code", "cm", "b", "fc", "f", "cr", "g", "lc"], "_": ["__", "p", "of", "l", "all", "block", "f"], "i": ["e", "ini", "si", "xi", "ip", "d", "hi", "id", "p", "I", "u", "im", "ie", "z", "li", "it", "ih", "ai", "v", "pi", "ui", "ni", "io", "q", "n", "ci", "l", "ii", "yi", "int", "iu", "b", "f", "iw", "o"], "j": ["e", "d", "J", "p", "jet", "u", "im", "z", "jl", "sh", "li", "jj", "v", "q", "n", "l", "jp", "ij", "ii", "py", "ja", "jc", "ji", "jo", "b", "f", "o", "g", "js"], "t": ["e", "at", "tt", " T", "lit", "d", "tr", "offset", "ta", "p", "u", "ct", "z", "nt", "pt", "it", "total", "dt", "v", "tu", "q", "type", "n", "l", "ot", "T", "temp", "time", "int", "mt", "tick", "test", "b", "f", "o", "trial", "g", "ts"], "r": ["e", "range", "br", "d", "tr", "p", "ar", "er", "u", "z", "v", " R", "re", "q", "n", "l", "R", "right", "rt", "rs", "sr", "nr", "b", "f", "o", "g"], "a": ["e", "at", "d", "aa", "ta", "ac", "p", "ar", "auto", "ana", "sta", "ba", "u", "za", "z", "an", "ha", "v", "am", "sa", "va", "ae", "ata", "n", "la", "l", "alpha", "A", "ad", "ca", "au", "aaa", "ma", "ab", "ga", "code", "b", "array", "f", "o", "area", "fa"], "k": ["ki", "e", "d", "km", "id", "sk", "p", "ch", "u", "kw", "kk", "z", "ky", "K", "ke", "q", "ka", "n", "kn", "ik", "ku", "ak", "ks", "work", "key", "ck", "ok", "b", "f", "o", "ko", "g"], "y": ["e", "ny", "yr", "zy", "my", "d", "yy", "ay", "yt", "sy", "p", "xy", "ye", "ch", "u", "z", "yx", "v", "ym", "yl", "cy", "q", "oy", "n", "py", "yi", "ey", "dy", "yo", "ya", "yn", "vy", "Y", "yd", "o"], "x": ["e", "xi", "xt", "xs", "d", "ww", "X", "px", "xp", "p", "xy", "mx", "u", "z", "rx", "tx", "yx", "v", "xb", "dx", "q", "n", "wy", "l", "index", "ex", "xc", "wx", "xxx", "xe", "dy", "ya", "xx", "ix", "o", "ax"], "s": ["e", "si", "d", "params", "str", "p", "ch", "sb", "series", "services", "sections", "z", "v", "space", "sa", "string", "ses", "sets", "n", "l", "ss", "ks", "S", "storage", "strings", "new", "parts", "states", "st", "b", "f", "o", "span", "g"]}}
{"code": "\\n  \\n  \\n  def solve(C, F, X):\\n      def needtime(cookies, farm):\\n          speed = 2.0 + F * farm\\n          return cookies / speed\\n  \\n      farm = 0\\n      pasttime = 0\\n      while True:\\n          complete = needtime(X, farm)\\n          nextfarm = needtime(C, farm)\\n          nextchallenge = needtime(X, farm + 1)\\n          if complete <= nextfarm + nextchallenge:\\n              return pasttime + complete\\n          pasttime += nextfarm\\n          farm += 1\\n  \\n  \\n  def main(IN, OUT):\\n      T = int(IN.readline())\\n      for index in range(T):\\n          C, F, X = map(float, IN.readline().split())\\n          OUT.write('Case #%d: %.7f\\n' % (index + 1, solve(C, F, X)))\\n  \\n  \\n  def makesample(maxC=500, maxF=4, maxX=2000, T=100):\\n      print T\\n      for index in range(T):\\n          print ' '.join('{0}'.format(random.randint(10000, maxvalue * 10000) / 10000.0)\\n                         for maxvalue in (maxC, maxF, maxX))\\n  \\n  \\n  if __name__ == '__main__':\\n      if '-makesample' in sys.argv[1:]:\\n          makesample()\\n      else:\\n          main(sys.stdin, sys.stdout)\\n  \\n", "target": "61", "substitutes": {"C": ["N", "CF", "U", "G", "Cu", "O", "CL", "CNN", "I", "CA", "W", "M", "NC", "CM", "K", "VC", "EC", "CE", "DC", "CP", "IC", "CW", "CC", "L", "D", "R", "CN", "B", "S", "c", "CR", "E", "H", "CS", "CI", "V", "CU", "Y", "P"], "F": ["N", "CF", "U", "G", "Fs", "FD", "Fore", "OF", "DF", "O", "I", "IF", "FB", "W", "File", "M", "Fi", "FS", "L", "Family", "D", "A", "FO", "R", "PF", "FM", "FH", "B", "WF", "S", "UF", "FE", "Feed", "E", "H", "Fine", "Farm", "RF", "V", "FF", "Y", "Q", "P", "Far", "f", "MF", "AF", "FW"], "X": ["WS", "U", "CH", "XL", "XP", "PH", "IX", "XXX", "CL", "TX", "W", "IP", "File", "NC", "M", "EC", "CE", "K", "Z", "CP", "IC", "CW", "XM", "CC", "L", "EX", "HTTP", "R", "FX", "B", "Check", "Ex", "Work", "FE", "CR", "E", "H", "UX", "Farm", "CI", "x", "V", "WR", "FF", "XY", "Y", "Q", "P", "XX", "PE", "Cross", "FW"], "cookies": ["Cookipes", " cookipes", "copipes", "cookys", "copies", "cooky", "cachey", "Cookies", "cookieies", "cookipes", "cacheips", "cacheys", " cooky", " cookys", "cacheies", "Cooky", "Cookys", "cookieips", "copys", "cookieys", "cookips", "Cookips", "copy", "cookiey"], "farm": ["family", "knife", "fruit", "grain", "fax", "forge", "future", "acre", "case", "fb", "number", "race", "license", "front", "food", "tower", "seed", "PF", "fly", "worker", "P", "cpu", "page", "online", "month", "field", "feed", "eed", "plan", "week", "FE", "time", "RF", "framework", "f", "server", "station", " fence", "profit", "feature", "now", "fake", "year", "file", "fork", "starter", "function", "FM", "FH", "fp", "flake", "hunt", "FU", "finder", "FF", "fen", "yard", "wheel", "password", "crop", "loader", "home", "sf", "cow", "job", "runner", "fan", "Farm", "course", "episode", "path", "flower", "folder", "FW"], "speed": ["page", "size", "stop", "access", "service", "weight", "profit", "clean", "start", "performance", "force", "year", "send", "engine", "select", "sum", "slow", "race", "feed", "wake", "sleep", "rank", "seed", "grade", "Speed", "rate", "fast", "zip", "cache", "sec", "time", "fan", "gain", "scan", "fee", "second", "cost", "f", "skip", "scale"], "pasttime": ["presenttimes", " pastdate", "Pastdate", "presentTime", "pasttimer", "nexttime", "nexttimer", "presenttime", "pastetime", "nextetime", "futureTime", "pasttimes", "Pasttime", "lasttime", "futureetime", "pastTime", " pastetime", "fastetime", "fastime", "futuretime", "Pasttimes", "fasttime", "nextime", "presentetime", "lasttimes", " pasttimes", "futuretimes", "fasttimer", " pasttimer", "pastime", "pastdate", "lastdate", " pastTime", " pastime"], "complete": ["full", "size", "secure", "stop", "fail", "correct", "play", "content", "final", "next", "done", "current", "length", "finished", "match", "future", "sequence", "case", "after", "count", "Complete", "total", "race", "com", "partial", "wait", "grade", "live", "fast", "close", "fill", "progress", "cache", "create", "scale", "time", "empty", "success", "test", "confirmed", "open", "result", "active", "fee", "code", "ready"], "nextfarm": ["lastf", "Nextfolder", "firstfarm", "nextf", "thisfork", "newpage", "firstpage", "nextfolder", "thisfolder", "nextpage", " nextfork", "newf", "Nextfork", "thisfarm", "newfarm", " nextf", " nextfolder", "nextfork", "firstf", "lastpage", "Nextfarm", " nextpage", "lastfarm"], "nextchallenge": ["nextchalace", "nextChallice", "nextpassence", "nextquenge", "nextquence", " nextchalence", "NextChallenge", "nextchallice", "nextchalise", "nextquise", "nextchalence", "NextChallence", "nextchalenge", " nextchalenge", "Nextchallence", " nextchallice", " nextchallise", "Nextchallise", "nextChallenge", "nextChallace", "nextchallise", "NextChallace", "nextchallence", "nextquice", " nextchallence", " nextchalise", "nextpassise", "nextpassenge", "Nextchallace", "NextChallise", "nextchallace", "nextChallise", "Nextchallenge", "nextchalice", "nextpassace", "nextChallence", " nextchalice"], "IN": ["ID", "URL", "INS", "IL", "RAW", "OU", "READ", "CL", "inner", "URI", "out", "PUT", "WIN", "I", "CON", "DATA", "LINE", "PIN", "STR", "Input", "FS", "TIME", "MN", "ins", "MIN", "Reader", "IO", "MC", "EN", "IM", "NG", "GET", "INT", "AC", "String", "In", "USER", "USE", "UID", "MAX", "LIB", "Out", "Client", "LIN"], "OUT": ["DOWN", "URL", "INS", "Writer", "Output", "IL", "OF", "OU", "out", "STDOUT", "PUT", "READ", "TS", "TEXT", "EXT", "DATA", "LINE", "STR", "ST", "OT", "FS", "EX", "TABLE", "outer", "IO", "WORK", "BY", "NG", "INT", " out", "String", "In", "NT", "USE", "FILE", "END", "Out"], "T": ["N", "U", "Length", "G", "TF", "TN", "Time", "O", "length", "I", "LT", "TS", "TB", "W", "t", "IP", "M", "Z", "_", "K", "DT", "Index", "ST", "UTC", "TH", "TIME", "L", "WT", "D", "TW", "A", "R", "B", "S", "TT", "TE", "E", "H", "PO", "V", "PT", "Total", "VT", "Y", "Q", "P", "CT", "TI"], "index": ["page", "ini", "ion", "loop", "name", "pos", "IND", "id", "i", "offset", "append", "word", "slice", "point", "match", "out", "length", "input", "exit", "case", "number", "condition", "ticket", "long", "Index", "error", "connection", "example", "iter", "position", "type", "EX", "thread", "outer", "value", "pointer", "data", "key", "int", "end", "test", "x", "call", "find", "insert", "ix", "pattern", "site", "open", "ind"], "maxC": [" maxN", " maxL", "numN", "MaxT", "maxN", "maxL", " maxT", "maxT", "minN", "minC", "minF", "numF", "numL", "minT", "numC", "MaxC", "MaxF", "MaxL", "MaxN"], "maxF": ["sometimesN", " maxN", "rankX", "rightX", "rightf", "rankF", "maxN", "maxFS", " maxM", " maxFS", "rankf", "rankE", "maxM", "maxf", " maxf", " maxE", "MaxFS", "sometimesM", "sometimesF", "maxE", "MaxF", "sometimesFS", "rightE", "MaxM", "rightF", "MaxN"], "maxX": [" maxN", "MAXN", "axF", "maxN", " maxV", "MAXY", "MaxY", "MaxV", "MAXX", "maxY", "maxV", "MAXV", "axY", "axX", "MaxC", "MaxX", "MaxF", "axC", " maxY", "MaxN"], "maxvalue": ["maxVALUE", " maxValue", "lastvalue", "minValue", "maxValue", "lastval", "Maxvalue", "MaxVALUE", "minVALUE", "maxval", "Maxnumber", " maxval", "minnumber", "maxnumber", "MaxValue", " maxVALUE", "minvalue", "lastVALUE", "Maxval", " maxnumber"]}}
{"code": "\\n  \\n  \\n  def check(R, C, M, _board):\\n      board = [line[:] for line in _board]\\n  \\n      pos = [(0, 0)]\\n      while pos:\\n          row, col = pos.pop()\\n          neighbor = []\\n          for r in (-1, 0, 1):\\n              r += row\\n              for c in (-1, 0, 1):\\n                  c += col\\n                  if r >= 0 and r < R and c >= 0 and c < C:\\n                      neighbor.append((r, c))\\n          count = len([1 for r, c in neighbor if board[r][c] == '*'])\\n          board[row][col] = str(count)\\n          if count == 0:\\n              for r, c in neighbor:\\n                  if board[r][c] == '.':\\n                      pos.append((r, c))\\n  \\n      flat = ''.join(''.join(line) for line in board)\\n      result = not flat.count('.')\\n      if not result and False: # for DEBUG\\n          print '-' * 20\\n          print R, C, M\\n          print '\\n'.join(''.join(line) for line in _board)\\n          print '-' * 20\\n      assert flat.count('*') == M\\n      return result\\n  \\n  \\n  def solve(R, C, M):\\n      board = [['.'] * C for row in range(R)]\\n      board[0][0] = 'c'\\n      row = R\\n      col = C\\n      mine = M\\n  \\n      while mine:\\n          if 0 < row <= col and mine >= row:\\n              for r in range(row):\\n                  board[row - r - 1][col - 1] = '*'\\n              mine -= row\\n              col -= 1\\n          elif 0 < col <= row and mine >= col:\\n              for c in range(col):\\n                  board[row - 1][col - c - 1] = '*'\\n              mine -= col\\n              row -= 1\\n          else:\\n              break\\n  \\n      if mine:\\n          while mine and row > 2:\\n              for r in range(min(mine, row - 2)):\\n                  board[row - r - 1][col - 1] = '*'\\n                  mine -= 1\\n              col -= 1\\n          while mine and col > 2:\\n              for c in range(min(mine, col - 2)):\\n                  board[row - 1][col - c - 1] = '*'\\n                  mine -= 1\\n              row -= 1\\n  \\n      if mine:\\n          if mine:\\n              board[1][1] = '*'\\n              mine -= 1\\n          if mine:\\n              board[1][0] = '*'\\n              mine -= 1\\n          if mine:\\n              board[0][1] = '*'\\n              mine -= 1\\n  \\n      assert mine == 0\\n      return '\\n'.join(''.join(line) for line in board) if check(R, C, M, board) else 'Impossible'\\n  \\n  \\n  def main(IN, OUT):\\n      T = int(IN.readline())\\n      for index in range(T):\\n          R, C, M = map(int, IN.readline().split())\\n          OUT.write('Case #%d:\\n%s\\n' % (index + 1, solve(R, C, M)))\\n  \\n  \\n  def makesample(maxSize=5, T=230):\\n      print T\\n      for index in range(T):\\n          R = random.randint(1, maxSize)\\n          C = random.randint(1, maxSize)\\n          print R, C, random.randint(0, R * C - 1)\\n  \\n  \\n  def makesample():\\n      pattern = []\\n      for R in range(1, 5+1):\\n          for C in range(1, 5+1):\\n              for M in range(R * C):\\n                  pattern.append((R, C, M))\\n      print len(pattern)\\n      for R, C, M in pattern:\\n          print R, C, M\\n  \\n  \\n  if __name__ == '__main__':\\n      if '-makesample' in sys.argv[1:]:\\n          makesample()\\n      else:\\n          main(sys.stdin, sys.stdout)\\n  \\n", "target": "61", "substitutes": {"R": ["N", "Rh", "TR", "U", "RH", "G", "X", "Row", "RR", "I", "W", "Rs", "K", "RO", "L", "D", "A", "T", "B", "S", "CR", "E", "H", "F", "V", "Y", "NR", "Q", "P", "RA", "Col"], "C": ["N", "U", "G", "X", "SC", "O", "I", "CL", "W", "NC", "CM", "K", "DC", "CC", "L", "D", "A", "CN", "T", "B", "S", "CR", "E", "H", "AC", "F", "CI", "V", "CU", "Y", "P", "Col"], "M": ["N", "mc", "U", "d", "G", "center", "O", "man", "I", "W", "m", "n", "D", "A", "MC", "T", "B", "S", "E", "H", "F", "V", "Y", "P", "cm", "MM"], "_board": ["_line", " _card", "dboard", " _row", " _deck", " _block", "_row", "_block", "_card", "drow", " _line", "dline", "_deck"], "board": ["po", "loop", "deck", "bo", "rows", "panel", "cart", "clean", "coll", "player", "word", "boards", "p", "que", "layout", "list", "channel", "hole", "join", "config", "sequence", "case", "flow", "check", "lane", "boarding", "form", "flo", "stream", "co", "object", "design", "pool", "card", "home", "pair", "feed", "nn", "position", "Board", "core", "database", "rank", "video", "data", "body", "ro", "block", "base", "style", "ack", "ide", "reader", "custom", "node", "buffer", "bank", "menu", "array", "game", "bug", "table", "union"], "line": ["page", "range", "po", "ge", "ne", "ine", "cle", "inline", "word", "len", "coll", "clean", "lo", "unit", "liner", "lined", "que", "slice", "point", "list", "ded", "case", "nee", "change", "li", "Line", "comment", "group", "lin", "LINE", "source", "position", "nl", "log", "plan", "l", "entry", "live", "link", "fl", "une", "block", "base", "ner", "pe", "cell", "frame", "call", "ze", "lines", "code", "do", "le", "user", "lc"], "pos": ["po", "strip", "loop", "ps", "player", "len", "coll", "pose", "unit", "slice", "p", "feed", "point", "list", " pack", "none", "down", "POS", "val", "object", "cond", "part", "pack", "pins", "loc", "iter", "position", "source", "Position", " positions", "n", "plan", "l", "os", "index", "ss", "pointer", "data", "body", "neg", "block", "all", "cache", "parent", " position", "lines", "f", "no", "post", "diff", "o", "Pos"], "row": ["e", "range", "rr", "d", "tr", "rows", "rc", "h", "coll", "p", "Row", "u", "v", "ra", "cur", "w", "loc", "q", "feed", "n", "rank", "ow", "uc", "entry", "index", "order", "ru", "cor", "raw", "rh", "ro", "key", "ner", "ry", "k", "x", "nr", "y", "sc", "b", "f", "cr", "user", "o", "post"], "col": ["cf", "num", "coll", "ac", "p", "ch", "max", "column", "year", "ct", "cat", "ref", "co", "loc", "cur", "cy", "q", "rot", "n", "ci", "l", "cl", "el", "index", "cor", "int", "cell", "cin", "lc", "character", "ol", "x", "cycle", "y", "con", "b", "f", "chain", "cr", "Col"], "neighbor": ["neisbr", "neborbour", "neongbor", "neearbor", "neighthbor", "Neighbour", "neigenbor", "nocibour", "necibors", "Neighbor", "nocibors", "neearbour", "nighbour", "neighthbour", "necibor", "noneighored", "neighthbr", "neonggar", "newayored", "neearbors", "neborbor", "newaybors", "nborbour", "newaybor", "noighbour", "nighbor", "neighmember", "necorebor", "Neigenbour", "neighbr", "neongbour", "necoremember", "neigengar", "neighthored", "noighbor", "newaymember", "necibour", "neearored", "neighbors", "neisbors", "neighored", "noneearored", "necorebour", "neisbour", "nbormember", "neisbor", "noneearbour", "neighgar", "newaybour", "neigenbors", "noneighbors", "neighthbors", "noighbr", "Neigengar", "necigar", "noneearbor", "nocibr", "nocibor", "noneearbors", "necibr", "neigenbour", "nborbor", "nebormember", "neighbour", "noneighbor", "Neighgar", "Neighbors", "neongbors", "Neigenbors", "noighbors", "noneighbour", "Neigenbor", "nighmember"], "r": ["e", "range", "yr", "rr", "rb", "br", "d", "tr", "fr", "rc", "h", "p", "pr", "ur", "ar", "rm", "mr", "dr", "u", "er", "z", "t", "v", "lr", "rec", "ir", "re", "cur", "w", "hr", "m", "n", "l", "rf", "ru", "right", "ro", "rt", "s", "kr", "a", "rn", "rl", "rs", "x", "rd", "sr", "nr", "b", "rg", "f", "err", "cr"], "c": ["rec", "cy", "uc", "ca", "xc", "unc", "cell", "rn", "y", "cm", "err", "fc", "ch", "z", "cs", "w", "n", "l", "cor", "cd", "cc", "s", "x", "b", "f", "roc", "e", "d", "i", "rc", "dc", "p", "oc", "ce", "ar", "t", "co", "v", "can", "loc", "m", "ci", "cont", "pc", "ec", "sc", "chain", "cf", "mc", "h", "ac", "coll", "u", "ct", "cu", "cur", "vc", "q", "cache", "k", "course", "nc", "arc", "cp", "cr", "cn", "lc"], "count": ["size", "Count", "counter", "name", "weight", "score", "num", "content", "cmp", "len", "coll", "width", "length", "max", "list", "match", "conn", "start", "case", "agg", "nt", "val", "number", "total", "cat", "first", "cond", "group", "sum", "part", "loc", "type", "limit", "n", "core", "index", "where", "any", "frac", "last", "base", "all", "cc", "cache", "split", "int", "test", "depth", "catch", "call", "find", "found", "code", "b", "err", "f", "every", "check"], "flat": ["full", "at", "plane", "inline", "slice", "unit", "layout", "op", "filter", "atten", "lie", "multi", "cat", "form", "lat", "layer", "mat", "flush", "plain", "feed", "iter", "fit", "plan", "kat", "py", "live", "fl", "dot", "fine", "fast", "single", "zip", "base", "empty", "multiple", "buff", "blank", "fin", "pat", "fat", "float", "f", "format"], "result": ["page", "range", "results", "counter", "our", "compl", "weight", "score", "ault", "num", "match", "list", "ret", "future", "case", "atten", "ver", "response", "number", "root", "res", "pack", "date", "inc", "source", "grade", "order", "rate", "data", "new", "work", "const", "df", "Result", "test", "success", "catch", "mate", "mark", "particip", "dist", "err", "array", "diff", "draw"]}}
{"code": "sys.setrecursionlimit(15000)\\n  \\n  def solve(C, F, X, rate, time):\\n    if (time + (X / rate)) < ((C / rate) + ((X / (rate+F)) + time)):\\n      return time + (X / rate)\\n    else:\\n      return solve(C, F, X, rate+F, time + (C / rate))\\n  \\n  T = int(raw_input())\\n  for t in range(T):\\n    C, F, X = map(float, raw_input().split())\\n    print 'Case #%i: %.7f' % (t+1, solve(C, F, X, 2, 0))\\n", "target": "62", "substitutes": {"C": ["N", "JC", "Count", "CF", "U", "G", "SC", "Co", "Cu", "O", "CL", "CNN", "I", "CA", "W", "YC", "M", "NC", "EC", "K", "VC", "CM", "CE", "GC", "DC", "CP", "IC", "Cache", "Custom", "CC", "L", "Sc", "D", "A", "R", "CN", "MC", "B", "S", "FC", "CO", "c", "CR", "E", "AC", "CS", "H", "CI", "V", "CU", "Y", "P", "Code", "CT", "Con", "Col"], "F": ["N", "CF", "U", "G", "Fs", "FD", "Time", "OF", "FI", "O", "DF", "I", "W", "FL", "BF", "File", "M", "Z", "FIN", "Fin", "Fi", "FS", "L", "D", "A", "EF", "R", "FO", "FH", "B", "PF", "GF", "WF", "FC", "FA", "FM", "FR", "FE", "Fine", "E", "H", "V", "FF", "Y", "Q", "P", "f", "FG", "AF", "FW"], "X": ["N", "U", "XL", "G", "Time", "XP", "ZX", "PH", "IX", "XXX", "CL", "TX", "W", "IP", "File", "M", "Z", "EC", "K", "CE", "MX", "XM", "CC", "L", "EX", "D", "HTTP", "R", "FX", "B", "WH", "Ex", "FC", "Work", "FE", "E", "H", "AC", "UX", "x", "V", "DX", "FF", "XY", "Y", "Q", "XX", "P", "PE"], "rate": ["rating", "range", "size", "charge", "speed", "duration", "weight", "rule", "score", "name", "rated", "play", "step", "capacity", "Time", "unit", "width", "length", "ime", "Rate", "count", "PI", "level", "write", "date", "race", "prime", "rice", "feed", "TIME", "sample", "core", "age", "late", "seed", "grade", "order", "value", "rates", "erate", "sync", "c", "stage", "FE", "use", "factor", "dim", "tone", "depth", "x", "cycle", "delay", "fee", "Y", "code", "cost", "f", "frequency", "scale"], "time": ["size", "stop", "speed", " TIME", "name", "event", "money", "duration", "h", "Time", "length", "ime", "now", "start", "case", "count", "z", " Time", "v", "space", "date", "com", "UTC", "w", "trace", "type", "TIME", "m", "sleep", "clock", "live", "function", "tim", "value", "data", "times", "c", "temp", "once", "end", "test", "depth", "x", "cycle", "how", "delay", "timer", "y", "cost", "f", "frequency", "load", "timeout"], "T": ["N", "U", "G", "TN", "Time", "O", "I", "TS", "TB", "TA", "M", "Z", "K", "TH", "L", "WT", "D", "R", "S", "TT", "TG", "TC", "E", "H", "V", "PT", "Total", "NT", "Y", "Q", "P", "CT", "DT"], "t": ["e", "tt", "inter", "d", " ti", "i", "num", "ta", "h", "tz", "p", "j", "z", "pt", "qt", "nt", "total", "_", "v", "dt", "tw", "type", "n", "m", "l", "tim", "ti", "c", "s", "int", "tp", "test", "x", "y", "tmp", "ind", "f", "ts"]}}
{"code": "\\n  def solve(W, H, M):\\n    board = [['*' for x in xrange(H)] for x in xrange(W)]\\n    board[0][0] = 'c'\\n    \\n    S = [((H*W)-1, board, 0, 0, set())]\\n    H -= 1\\n    W -= 1\\n    while len(S) > 0:\\n      state = S.pop()\\n      mines = state[0]\\n      board = deepcopy(state[1])\\n      x = state[2]\\n      y = state[3]\\n      visited = deepcopy(state[4])\\n      visited.add((x, y))\\n      \\n      if mines == M:\\n        s = ''\\n        for row in board:\\n          s += ''.join(row)\\n          s += '\\n'\\n        return s\\n      \\n      elif mines > M:\\n        if x > 0 and board[x-1][y] == '*':\\n          board[x-1][y] = '.'\\n          mines -= 1\\n        \\n        if x < W and board[x+1][y] == '*':\\n          board[x+1][y] = '.'\\n          mines -= 1\\n        \\n        if y > 0 and board[x][y-1] == '*':\\n          board[x][y-1] = '.'\\n          mines -= 1\\n        \\n        if y < H and board[x][y+1] == '*':\\n          board[x][y+1] = '.'\\n          mines -= 1\\n        \\n        if x > 0 and y > 0 and board[x-1][y-1] == '*':\\n          board[x-1][y-1] = '.'\\n          mines -= 1\\n        \\n        if x > 0 and y < H and board[x-1][y+1] == '*':\\n          board[x-1][y+1] = '.'\\n          mines -= 1\\n        \\n        if x < W and y > 0 and board[x+1][y-1] == '*':\\n          board[x+1][y-1] = '.'\\n          mines -= 1\\n        \\n        if x < W and y < H and board[x+1][y+1] == '*':\\n          board[x+1][y+1] = '.'\\n          mines -= 1\\n        \\n        if x > 0 and not (x-1, y) in visited:\\n          S.append((mines, board, x-1, y, visited))\\n        \\n        if x < W and not (x+1, y) in visited:\\n          S.append((mines, board, x+1, y, visited))\\n        \\n        if y > 0 and not (x, y-1) in visited:\\n          S.append((mines, board, x, y-1, visited))\\n        \\n        if y < H and not (x, y+1) in visited:\\n          S.append((mines, board, x, y+1, visited))\\n        \\n        if x > 0 and y > 0 and not (x-1, y-1) in visited:\\n          S.append((mines, board, x-1, y-1, visited))\\n        \\n        if x > 0 and y < H and not (x-1, y+1) in visited:\\n          S.append((mines, board, x-1, y+1, visited))\\n        \\n        if x < W and y > 0 and not (x+1, y-1) in visited:\\n          S.append((mines, board, x+1, y-1, visited))\\n        \\n        if x < W and y < H and not (x+1, y+1) in visited:\\n          S.append((mines, board, x+1, y+1, visited))\\n    return 'Impossible'\\n  \\n  T = int(raw_input())\\n  for t in range(T):\\n    W, H, M = map(int, raw_input().split())\\n    print 'Case #%i:\\n%s' % (t+1, solve(W, H, M).strip())\\n", "target": "62", "substitutes": {"W": ["N", "WS", "U", "Sl", "G", "Ch", "X", "MW", "C", "Wh", "WP", "Web", "J", "WC", "WN", "VW", "WB", "Z", "K", "WA", "DC", "WE", "CW", "w", "L", "D", "A", "WM", "R", "SH", "B", "WH", "We", "Work", "SW", "E", "Gr", "F", "V", "WR", "Y", "GW", "Q", "P", "Sw", "FW"], "H": ["N", "Th", "Rh", "U", "He", "CH", "RH", "Sl", "G", "Ch", "X", "h", "C", "Wh", "HM", "O", "HS", "PH", "Time", "J", "HH", "EH", "HD", "Cl", "Z", "K", "HA", "w", "TH", "L", "Ha", "D", "R", "FH", "B", "WH", "SH", "Sh", "Work", "Hum", "HI", "E", "Gr", "F", "V", "NH", "OH", "HC", "Y", "HY", "Q", "P", "MH", "DH", "Che", "Ph", "Kh", "Hy", " h", "Sw"], "M": ["N", "U", "G", "X", "C", "J", "O", "I", "MS", "Z", "CM", "K", "NM", "SM", "MX", "m", "MN", "L", "D", "A", "R", "B", "DM", "MB", "E", "F", "V", "Y", "Q", "P", "MH", "MM", "LM"], "board": ["oo", "che", "boards", "section", "sequence", "case", "ward", "design", "object", "card", "index", "back", "node", "stroke", "Q", "table", "loop", "rule", "bo", "player", "word", "clean", "join", "feed", "w", "video", "wall", "body", "all", "ack", "code", "b", "array", "f", "o", "post", "game", "foot", "check", "lay", "U", "client", "deck", "SC", "cart", "slice", "document", "layout", "channel", "input", "down", "lane", "form", "flo", "comment", "Board", "A", "square", "one", "block", "model", "chart", "head", "frame", "run", "sc", "draw", "ko", "lock", "wheel", "bug", "room", "panel", "coll", "view", "way", "que", "point", "list", "hole", "builder", "image", "flow", "boarding", "book", "stream", "Z", "land", "group", "home", "bar", "entry", "boy", "work", "null", "line", "bank", "door", "control", "menu"], "x": ["xs", "xt", "name", "px", "sex", "xp", "fx", " X", "left", "position", "cy", "wy", "index", "ice", " xx", "xc", "wx", "any", "c", "xe", "ph", "xx", "gy", "ax", "my", "event", "pos", "X", "width", "z", "tx", "dx", "w", "type", "n", "l", "wa", "time", "pe", "a", "ic", "code", "b", "f", "o", "area", "check", "e", "full", "d", "zx", "id", "i", "p", "xy", "j", "xml", "oint", "rx", "cross", "yx", "host", "on", "v", "ty", "yl", "m", "ci", "el", "one", "ox", "key", "ey", "ya", "ctx", "size", "xi", "ip", "ux", "content", "ady", "h", "xf", "view", "point", "u", "image", "ct", "r", "lat", "com", "q", "ex", "www", "xxx", "win", "work", "int", "dy", "python", "lex", "k", "height", "line", "ix", "no", "g"], "S": ["N", "WS", "U", "SC", "SL", "C", "sb", "O", "STATE", "Z", "ST", "SE", "L", "State", "OS", "D", "A", "OSS", "R", "south", "SH", "B", "Si", "states", "F", "SS", "V", "SU", "NS", "Y", "SA", "P", "Set"], "state": ["e", "range", "size", "pos", "rule", "player", "step", "slice", "p", "section", "j", "address", "point", "list", "match", "start", "config", "STATE", "case", "image", "r", "object", "comment", "part", "space", "session", "scope", "dict", "position", "core", "State", "private", "resource", "order", "data", "body", "port", "sync", "back", "block", "model", "style", "work", "scale", "key", "parent", "head", "states", "k", "set", "shape", "node", "message", "shadow", "line", "run", "post", "area", "stat", "g", "se", "store"], "mines": ["minsores", "minores", " minores", "Minutes", "minises", "MinES", "eminunes", "mainies", "Minences", "minsenses", "eminions", "Minees", "emininates", " minunes", "Miners", "minions", "minsies", "minsss", "Minunes", " miners", "menes", "Mininates", "minsences", "Minues", "mainutes", "menss", "MINences", "minsises", "minunes", "emines", " minises", "minsodes", "mainions", "minses", " minenses", "minES", "MINues", " minues", "Minions", " minees", " minES", "maines", "Minises", "minodes", "minees", "minues", " minences", "minsES", "Minodes", "minss", "menences", "minsues", "Minenses", "minenses", "minies", " minions", "miners", " mininates", "minsions", "minsutes", "MINions", " minodes", "minences", "eminees", "eminues", "menES", "MINES", "Mines", "Minies", "minutes", "mininates", " minss", "Minores", "minsers", "mainences", "MINes"], "y": ["oo", "out", "ly", "cy", "oy", "wy", "any", "c", "gy", "yes", "yd", "ny", "my", "yy", "sy", "ye", "ch", "yah", "ity", "z", "hot", "w", "type", "n", " Y", "yi", "a", "yo", "vy", "b", "f", "o", "area", "e", "yr", "ys", "zy", "d", "iy", "id", "i", "p", "xy", "j", "year", "ty", "yx", "file", "v", "yl", "ley", "m", "hop", "el", "ot", "iny", "key", "ey", "ry", "ya", "yn", "Y", "fy", "ay", "isy", "ady", "h", "sky", "yt", "yan", "en", "u", "ie", "ky", "ym", "hy", "q", "ies", "py", "ery", "ish", "dy", "height", "ix"], "visited": [" visiting", "denitors", "Visiting", "versed", "minored", "minited", "Vised", "deniting", "visiting", "versited", "VISored", "Visitors", "minITED", " visitors", "Visited", " vised", "versored", "VISited", "visitors", "VISITED", "visored", "dened", "VISed", "denited", "vised", "mined", "visITED", "versITED"], "s": ["e", "settings", "si", "sg", "d", "ns", "i", "rows", "h", "p", "sb", "series", "r", "ing", "ed", "sym", "string", "its", "ses", "session", "w", "es", "n", "l", "ings", "south", "ss", "sl", "single", " parts", "c", "a", "sv", "states", "ions", "us", "b", "f", "o", " ss", "g", "se"], "row": ["page", "range", "loop", "col", "rows", "cube", "slice", "month", "view", "section", "Row", "ride", "hole", "instance", "flow", "r", "ward", "arrow", "server", "string", "feed", "rect", "rank", "entry", "index", "raw", "port", "week", "ro", "block", "sel", "round", "key", "cell", "frame", "ross", "scan", "node", "result", "insert", "line", "up"]}}
{"code": "\\n  \\n  ncases = int(sys.stdin.readline().strip())\\n  \\n  for t in range(1, ncases+1):\\n      values = sys.stdin.readline().split()\\n      c = float(values[0])\\n      f = float(values[1])\\n      x = float(values[2])\\n      r = 2\\n  \\n      time = 0\\n  \\n      while True:\\n          tdirect = x/r\\n          tfactory = c/r + x/(r+f)\\n  \\n          if tdirect<tfactory:\\n              time += tdirect\\n              break\\n          else:\\n              time += c/r\\n              r += f\\n  \\n      print(\"Case #{0}: {1:.7f}\".format(t, time))\\n", "target": "63", "substitutes": {"ncases": ["necasing", "necases", "nicodes", "ncaps", "nase", "dcasing", "dcase", "necase", "codes", "case", "naps", "nsodes", "cases", "nicasing", "casing", "nicase", "nicases", "nasing", "necaps", "ncase", "dcases", "dcaps", "ncodes", "nsasing", "nsases", "nases", "ncasing", "nsase"], "t": ["e", "tt", " T", "d", "col", "name", "id", "num", "i", " ti", "ta", "tz", "p", "series", "start", "count", "nt", "z", "ty", "dt", "v", "w", "type", "n", "m", "l", "tim", "T", "ti", "s", "a", "test", "st", "y", "b", "ind", "trial"], "values": ["settings", "results", "members", "events", "vals", "args", "Values", "places", "reads", "rows", "vector", "words", "series", "vi", "iv", "maps", "errors", "cells", "bytes", "v", "types", "sets", "comments", "pages", "es", "years", "docs", "seconds", "value", "keys", "data", "grades", "ks", "measures", "frames", "times", "files", "strings", "s", "gets", "details", "blocks", "versions", "flows", "items", "vs", "ves", "roots", "tests", "lines", "boxes", "ports", "lists", "objects"], "c": ["e", "cf", "size", "d", "i", "rc", "h", "C", "dc", "p", "ch", "ce", "u", "count", "z", "v", "cu", "cs", "w", "n", "m", "ci", "l", "ca", "cc", "s", "ec", "nc", "y", "b", "con", "fc", "o", "cr", "g", "lc"], "f": ["e", "cf", "fd", "d", "fr", "i", "h", "xf", "p", "fx", "u", "force", "z", "fm", "fb", "v", "feed", "w", "sf", "n", "m", "l", "rf", "fl", "fp", "fs", "F", "fe", "y", "b", "fc", "frequency", "fen", "err", "g"], "x": ["e", "ctx", "d", "i", "X", "rc", "h", "xf", "p", "u", "force", "z", "rx", "cross", "v", "w", "q", "n", "m", "l", "ex", "fast", "xc", "s", "int", "y", "b", "array", "fc", "o", "g"], "r": ["e", "range", "rb", "d", "fr", "i", "rc", "h", "p", "ur", "max", "u", "z", "rx", "v", "lr", "rw", "ir", "w", "m", "n", "hr", "l", "rf", "R", "function", "rate", "right", "ru", "g", "rh", "ro", "rt", "s", "a", "rl", "rs", "sr", "nr", "y", "b", "err", "rg", "cr", "o"], "time": ["tt", "size", "counter", "speed", "duration", "name", "money", "rc", "h", "ac", "Time", "runtime", "length", "ime", "now", "ace", "start", "im", "count", "year", "z", "ty", "etime", "error", "date", "race", "w", "trace", "type", "sleep", "m", "q", "l", "clock", "resource", "tim", "rate", "times", "tc", "end", "depth", "cycle", "timer", "y", "cost", "err", "frequency", "cr", "timeout"], "tdirect": ["fdirection", "aldirection", "tfinite", "ddirection", " tdinct", "tdact", " tdirection", "hdirect", "ddication", "fdiff", "tdirection", "tdoc", "fdinite", " tdinite", "tdiff", "hdication", " tdact", " tdication", "aldact", "aldirect", "ddact", "tdinite", "ddoc", "tdication", "tfiff", "ddinct", "tdinct", "hdoc", "tfirection", "fdirect", " tdiff", "tfirect", "hdirection", "aldinct", " tdoc", "ddirect"], "tfactory": ["TFuture", "tifault", "defraud", "defuture", "tfFactory", "tifactory", "cfFactory", "sfuture", "tifixture", "sfactory", "tfraud", "defuzz", "tfault", "sfixture", "cfault", "sfraud", "sfuzz", "cfactory", "sfFactory", "sfault", "defactory", "tfuzz", "tfuture", "tifFactory", "cfixture", "tfixture", "TFuzz", "TFactory", "TFraud"]}}
{"code": "\\n  \\n  ncases = int(sys.stdin.readline().strip())\\n  \\n  def print_board(r, c, free):\\n      board = {}\\n      for row in range(0, r):\\n          board[row] = {}\\n          for col in range(0, c):\\n              board[row][col] = '*'\\n  \\n      pending = free\\n  \\n      if free == 1:\\n          board[0][0] = '.'\\n      elif r == 1 or c == 1:\\n          for row in range(0, r):\\n              for col in range(0, c):\\n                  if pending > 0:\\n                      pending -= 1\\n                      board[row][col] = '.'\\n      else:\\n          for row in range(0,2):\\n              for col in range(0,2):\\n                  board[row][col] = '.'\\n          pending -= 4\\n          col=2\\n          row=2\\n  \\n          while pending >= 2 and (col<c or row<r):\\n              if pending >= 2 and col<c:\\n                  board[0][col] = '.'\\n                  board[1][col] = '.'\\n                  col += 1\\n                  pending -= 2\\n              if pending >= 2 and row<r:\\n                  board[row][0] = '.'\\n                  board[row][1] = '.'\\n                  row += 1\\n                  pending -= 2\\n  \\n          for row in range(2, r):\\n              for col in range(2, c):\\n                  if pending > 0:\\n                      board[row][col] = '.'\\n                      pending -= 1\\n  \\n      board[0][0] = 'c'\\n  \\n      for row in range(0, r):\\n          line = ''\\n          for col in range(0, c):\\n              line += board[row][col]\\n          print(line)\\n  \\n  \\n  for t in range(1, ncases+1):\\n      values = sys.stdin.readline().strip().split()\\n      r = int(values[0])\\n      c = int(values[1])\\n      m = int(values[2])\\n  \\n      cells = r * c\\n      free = cells - m\\n  \\n      possible = False\\n  \\n      if r == 1 or c == 1:\\n          if free >= 1:\\n              possible = True\\n      elif r == 2 or c == 2:\\n          if free == 1 or (free >= 4 and free%2 == 0):\\n              possible = True\\n      else:\\n          if free == 1 or (free >= 4 and free != 5 and free != 7):\\n              possible = True\\n  \\n      print(\"Case #{0}:\".format(t))\\n  \\n      if possible:\\n          print_board(r, c, free)\\n      else:\\n          print(\"Impossible\")\\n", "target": "63", "substitutes": {"ncases": ["lcasing", "lcasts", "ncased", "necases", "necase", "lcases", "case", "cases", "ncasts", "lcase", "casing", "casts", "lcased", "ncase", "curses", "nsasing", "nsases", "necased", "necasts", "ncasing", "cased", "lcurses", "ncurses", "nsurses", "nsase"], "r": ["e", "range", "yr", "rr", "rb", "br", "d", "tr", "fr", "i", "nor", "rc", "h", "p", "ur", "pr", "j", "ch", "ar", "er", "u", "z", "v", "ra", "ir", "re", "w", "q", "n", "l", "rf", "R", "order", "ru", "right", "g", "rt", "ro", "s", "kr", "rn", "k", "rs", "x", "rd", "sr", "nr", "b", "err", "f", "rg", "cr", "o", "rar"], "c": ["e", "cf", "d", "i", "rc", "h", "ac", "C", "dc", "p", "ch", "ce", "u", "ct", "z", "co", "cu", "v", "rec", "cs", "cur", "w", "cy", "q", "n", "ci", "l", "R", "ru", "cor", "ca", "pc", "cc", "bc", "s", "cell", "a", "k", "ec", "x", "nc", "y", "sc", "b", "con", "f", "cm", "cr", "o", "cp", "fc", "lc"], "free": ["N", "FREE", "cle", "required", "complete", "out", "fun", "util", "left", "rec", "un", "sec", "price", "fe", "off", "con", "float", "err", "version", "range", "rule", "mi", "fr", "current", "usable", "random", "n", "valid", "floor", "common", "all", "empty", "sp", "F", "Free", "found", "available", "f", "const", "low", "e", "lease", "static", "co", "error", "re", "stable", "vol", "outer", "function", "min", "fre", "cf", "size", "len", "unit", "non", "lower", "total", "used", "release", "rf", "covered", "raw", "func", "cache", "use", "open", "fee", "no"], "board": ["che", "boards", "sequence", "ward", "design", "object", "card", "pool", "rank", "back", "cell", "node", "stroke", "bridge", "table", "loop", "rule", "bo", "player", "word", "clean", "ode", "length", "ban", "feed", "plugin", "ack", "buffer", "code", "array", "game", "server", "lay", "client", "deck", "cart", "layout", "channel", "config", "lane", "form", "flo", "comment", "error", "Board", "core", "square", "data", "block", "model", "ide", "phone", "draw", " dashboard", "lock", "ko", "bug", "room", "coll", "view", "que", "point", "list", "hole", "builder", "flow", "book", "boarding", "stream", "land", "group", "home", "boy", "sync", "work", " clipboard", "course", "bank", "control", "menu"], "row": ["name", "offset", "Row", "ward", "object", "uc", "query", "rank", "day", "index", "rh", "mod", "sel", "cell", "node", "y", "table", "page", "range", "ear", "device", "word", "month", "ch", "length", "arrow", "record", "feed", "w", "rect", "ow", "system", "port", "hour", "ack", "ou", "x", "post", "o", "user", "server", "roc", "rr", "module", "tr", "rc", "oc", "channel", "max", "year", "ver", "form", "co", "rw", "error", "re", "loc", "core", "order", "ro", "block", "model", "key", "ry", "ull", "run", "keep", "sc", "draw", "ko", "wheel", "container", "rows", "coll", "h", "view", "column", "u", "flow", "micro", "nt", "roll", "group", "mo", "bar", "cur", "rot", "q", "entry", "rown", "value", "right", "raw", "sync", "round", "cr", "scale"], "col": ["il", "COL", "name", "left", "io", "cy", "oy", "day", "ca", "sel", "cell", "collection", "y", "con", "cm", "fc", "sect", "page", "act", "word", "patch", "enc", "ch", "ll", "length", "count", "cat", "cond", "field", "ell", "w", "ow", "n", "l", "seq", "cor", "ou", "color", "x", "cycle", "f", "num", "fn", "p", "j", "channel", "year", "file", "rel", "flo", "co", "can", "loc", "core", "pixel", "el", "ci", "ro", "char", "block", "temp", "key", "car", "min", "chain", "Col", "ail", "coll", "ac", "point", "cal", "child", "column", "ct", "nt", "ref", "rot", "vc", "q", "cl", "fl", "win", "int", "path", "cn", "arc", "cp", "g", "lc"], "pending": ["spaging", "opushed", "Pend", "padding", "cpadding", "poding", "spanging", "apended", "npanging", "fended", "lpushed", "Pended", " paging", "lpend", "apaging", " pend", "cpend", "opaging", "lpaging", "opend", "jpaying", "lpending", "npend", "pushed", "lpended", "jpoding", "paging", "opaying", "Poding", "spended", " pended", "cpending", "ppend", "spadding", "apushed", "opending", "fending", " paying", "paying", "fadding", " padding", "opended", "Pushed", "pend", "pended", "npadding", "opoding", "npoding", "Pending", "jpended", "Panging", "spoding", "spend", "cpended", " poding", "jpushed", "spending", "ppended", "Paging", "jpending", "ppending", "Padding", "npended", "apending", "panging", "npending", " pushed", "foding", "ppaging", "jpend", "opadding"], "line": ["page", "range", "strip", "name", "cle", "content", "inline", "str", "item", "section", "point", "lf", "letter", "definition", "file", "write", "li", "object", "comment", "long", "lin", "string", "LINE", "source", "feed", "log", "l", "el", "cl", "entry", "link", "value", "text", "zip", "block", "base", "pe", "cell", "frame", "message", "lines", "code", "le"], "t": ["e", "task", "d", "tr", "i", "tab", "lo", "ct", "nt", "it", "cat", "co", "cut", "type", "n", "l", "T", "ti", "te", "got", "times", "time", "toc", "y", "f", "tile", "table"], "values": ["rules", "settings", "results", "members", "ms", "xs", "events", "vals", "images", "Values", "places", "rows", "lists", " lines", "changes", "boards", "codes", "vi", "maps", "dates", "pins", "comments", "forms", "es", "pages", "docs", "seconds", "fields", "verts", "keys", "value", "grades", "days", "fine", "views", "frames", "files", "strings", "details", "gets", "players", "blocks", "names", "flows", "items", "vs", "ves", "tests", "roots", "bs", "lines", "ports", "bytes", "objects"], "m": ["e", "range", "ms", "mc", "d", "mi", "i", "num", "p", "u", "mm", "z", "fm", "M", "co", "v", "nm", "margin", "w", "q", "n", "l", "s", "cell", "mass", "y", "cm", "b", "f", "con", "o", "mn"], "cells": ["classes", "units", "rules", "members", "ms", "mc", "ns", "rows", "p", "features", "mins", "levels", "planes", "v", "cs", "ells", "cats", "pages", "n", "l", "fields", "keys", "breaks", "ks", "groups", "models", "frames", "files", "faces", "s", "blocks", "cell", "states", "flows", "items", "fe", "y", "lines", "cm", "b", "f", "runs", "bytes"], "possible": ["porsche", " porsche", " pable", "Pable", "possibly", "spossible", "spossibility", "picted", "xpossible", "xpable", "Possible", " pausible", "cossibly", "Pausible", "Porsche", "cossibility", "Possibility", "causible", "pable", "sporsche", " possibly", "possibility", "xpicted", "spossibly", "cossible", "xpossibility", " possibility", "Picted", "pausible", "Possibly", " picted"]}}
{"code": "\\n  \\n  def read_case(f):\\n  \treturn map(float, f.readline().split())\\n  \\n  \\n  def solve(C, F, X, rate=2.0):\\n  \taccum = 0\\n  \twhile 1:\\n  \t\tgoal1 = X / rate\\n  \t\\n  \t\tfarm = C / rate\\n  \t\tgoal2 = farm + (X / (rate + F))\\n  \\n  \t\tif goal1 <= goal2:\\n  \t\t\treturn accum + goal1\\n  \t\telse:\\n  \t\t\taccum += farm\\n  \t\t\trate += F\\n  \\n  \t\t\t\\n  def trunc(x, p=7):\\n  \tm = 10 ** p\\n  \treturn round(x * m) / m\\n  \\n  \\n  def main():\\n  \tfn = sys.argv[1]\\n  \twith open(fn, encoding='utf-8') as f:\\n  \t\tncases = int(f.readline())\\n  \t\tfor case in range(1, ncases + 1):\\n  \t\t\tC, F, X = read_case(f)\\n  \t\t\tsolution = solve(C, F, X)\\n  \t\t\tprint('Case #{}: {}'.format(case, trunc(solution)))\\n  \\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "target": "64", "substitutes": {"f": ["e", "fw", "cf", "fd", "d", "fore", "self", "fr", "i", "h", "bf", "fx", "fi", "lf", "af", "r", "file", "t", "fb", "tf", "form", "v", "of", "feed", "w", "sf", "l", "rf", "fp", "fast", "inf", "fs", "ff", "c", "s", "df", "fe", "arf", "b", "fc", "fen", "g", "folder"], "C": ["N", "CF", "Cs", "JC", "U", "G", "Ch", "Co", "Cu", "O", "CL", "CNN", "I", "CA", "W", "M", "CE", "K", "DC", "Cache", "CC", "L", "D", "A", "R", "CN", "T", "MC", "B", "S", "FC", "CO", "c", "CR", "E", "V", "RF", "CU", "Y", "P", "Conf"], "F": ["N", "CF", "U", "G", "Fs", "FD", "FP", "OF", "DF", "I", "IF", "FB", "W", "FL", "M", "Fi", "FS", "L", "Family", "D", "A", "EF", "R", "FO", "T", "PF", "FM", "B", "FH", "S", "FC", "GF", "UF", "FA", "WF", "FE", "Feed", "E", "H", "Farm", "FN", "V", "RF", "Form", "FF", "Y", "Q", "P", "Conf", "AF", "FW"], "X": ["N", "CF", "U", "XL", "G", "XP", "ZX", "IX", "Event", "XXX", "CL", "Rate", "TX", "W", "IP", "File", "M", "Z", "CE", "K", "CP", "XM", "CC", "L", "EX", "D", "A", "R", "FX", "Ex", "FC", "Work", "FE", "E", "H", "UX", "V", "DX", "FF", "XY", "Y", "XX", "P", "Q", "PE", "AF", "FW"], "rate": ["size", "charge", "speed", "weight", "rule", "score", " Rate", "rated", "unit", "feature", "ride", "ale", "Rate", "PI", "acc", "r", "M", "state", "root", "date", "race", "re", "feed", "core", "rank", "age", "grade", "seed", "fare", "SE", "R", "GE", "order", "fine", "rates", "FE", "time", "fan", "test", "depth", "gain", "fe", "Score", "fee", "term", "cost", "cm", "con", "frequency", "ground", "Power", "mode", "scale"], "accum": ["accountam", "ccrum", "acum", "accrum", "gamumm", "acam", "incrum", "accountain", "gamam", "Accrum", "ccum", "acumm", " accnum", "accain", "gamain", "gamum", "incumption", "Accumption", "ccnum", "Accnum", "Accam", "acain", "Accum", "accountumm", "accnum", "accumption", "accountum", " accumption", "incum", "ccam", " accam", "accumm", "ccumption", "incam", "accam"], "goal1": ["result2", "loss0", "goalone", "dayone", "loss1", "goal3", "gain1", "lossone", " goalone", "day2", " goal0", " goal3", " goalOne", "result1", "loss2", "Goal0", "gain2", "resultOne", "goalOne", "day1", "gainone", "Goal1", "dayOne", "gainOne", "Goal2", "Goal3", "loss3", "goal0", "lossOne", "resultone"], "farm": ["page", "charge", "forest", " fence", "profit", "family", "power", "month", "feature", "abuse", "fake", "pen", "flow", "force", "file", "number", "M", "field", "root", "front", "race", "practice", "fork", "feed", "sf", "core", "rank", "np", "grade", "fare", "seed", "rf", "function", "fp", "PF", "prop", "FA", "frac", "FU", "fan", "Farm", "RF", "goal", "fee", "Y", "cost", "P", " ratio", "ground", "trial", "scale", "cpu"], "goal2": ["goal4", "jump1", "wall4", "jump2", "GoalTwo", "wallTwo", "wall1", "Goal1", "Goal2", "jumpTwo", "goalTwo", "jump4", "Goal4", "wall2", " goalTwo", " goal4"], "x": ["e", "xd", "xs", "xi", "d", "i", "num", "px", "h", "xp", "xy", "mx", "z", "r", "rx", "t", "v", "dx", "example", "w", "q", "n", "l", "ex", "data", "xc", "wx", "c", "s", "test", "xx", "y", "b", "P", "ax"], "p": ["e", "d", "pp", "i", "num", "h", "power", "pm", "u", "r", "t", "pi", "M", "v", "pa", "w", "n", "np", "l", "fp", "port", "pc", "c", "s", "tp", "a", "y", "P", "b", "cm", "o", "g"], "m": ["e", "ms", "mc", "d", "mi", "km", "i", "dm", "num", "mp", "month", "pm", "rm", "mr", "mx", "mu", "max", "u", "im", "mm", "r", "bm", "fm", "pi", "M", "v", "nm", "w", "n", "tm", "l", " M", "c", "mass", "min", "mon", "cm", "P", "o", "MM", "wm", "mn"], "fn": ["cf", "cdn", "fd", "name", "ns", "syn", "bf", "fun", "conn", "feat", "fm", "file", "output", "fb", "bn", "filename", "nn", "sf", "n", "kn", "np", "hn", "function", "fl", "fp", "fs", "ann", "func", "pn", "ln", "nb", "sn", "rn", "FN", "arf", "path", "fat", "b", "fc", "o", "fen", "dn", "mn", "cn", "fa"], "ncases": ["cnases", "ncats", "necases", "ncales", "necales", "nase", "dcase", "necase", "nats", "cnats", "cnase", "NCales", "NCases", "naces", "cnales", "dcases", "ncase", "necaces", "ncaces", "NCase", "nases", "dcats", "NCaces", "nales", "dcales"], "case": ["size", "sea", "name", "exc", "num", " trial", "section", "cas", "address", "match", "instance", "ase", "file", "nce", "cases", "ASE", "space", "rice", "race", "uc", "position", "core", "Case", "ice", "de", " c", " line", "purpose", "c", "end", "pe", "ide", "test", "chance", "shape", " suite", "line", "result", "USE", " CASE", "code", "sc", "trial", "lc"], "solution": ["solver", " solving", "Solve", "ssolve", "ssolver", " solve", "Solving", "solving", "Solver", "solve", "ssolution", "Solution", "ssolving", " solver"]}}
{"code": "\\n  \\n  FREE = '.'\\n  BOMB = '*'\\n  CLICK = 'c'\\n  \\n  \\n  class Board:\\n  \\n  \tdef __init__(self, R, C, M):\\n  \t\tself.initial_M = M\\n  \t\tself.R = R\\n  \t\tself.C = C\\n  \t\tself.M = M\\n  \t\tself.matrix = [[FREE for c in range(C)] for r in range(R)]\\n  \t\tself.endx = len(self.matrix[0])\\n  \t\tself.endy = len(self.matrix)  # 0 < R * C\\n  \t\tself.startx = 0\\n  \t\tself.starty = 0\\n  \\n  \tdef fill_row(self, row):\\n  \t\tfor c in self.range_active_cols:\\n  \t\t\tself.matrix[row][c] = BOMB\\n  \t\tself.starty += 1\\n  \t\tself.M -= self.active_cols\\n  \\n  \tdef fill_col(self, col):\\n  \t\tfor r in self.range_active_rows:\\n  \t\t\tself.matrix[r][col] = BOMB\\n  \t\tself.startx += 1\\n  \t\tself.M -= self.active_rows\\n  \\n  \tdef pprint(self):\\n  \t\tfor row in self.matrix:\\n  \t\t\tfor cell in row:\\n  \t\t\t\tprint(cell, end='')\\n  \t\t\tprint()\\n  \\n  \t@property\\n  \tdef active_rows(self):\\n  \t\treturn self.endy - self.starty\\n  \\n  \t@property\\n  \tdef active_cols(self):\\n  \t\treturn self.endx - self.startx\\n  \\n  \tdef optimize(self):\\n  \t\twhile 1:\\n  \t\t\tif (self.active_cols <= self.active_rows\\n  \t\t\t\t\tand self.active_cols <= self.M):\\n  \t\t\t\tself.fill_row(self.starty)\\n  \t\t\telif (self.active_rows < self.active_cols\\n  \t\t\t\t\tand self.active_rows <= self.M):\\n  \t\t\t\tself.fill_col(self.startx)\\n  \t\t\telse:\\n  \t\t\t\tbreak\\n  \\n  \t@property\\n  \tdef range_active_cols(self):\\n  \t\treturn range(self.startx, self.endx)\\n  \\n  \t@property\\n  \tdef range_active_rows(self):\\n  \t\treturn range(self.starty, self.endy)\\n  \\n  \tdef is_free(self, row, col):\\n  \t\treturn self.matrix[row][col] == FREE\\n  \\n  \tdef place_bomb(self):\\n  \t\tfor row in self.range_active_rows:\\n  \t\t\tfor col in self.range_active_cols:\\n  \t\t\t\tif (self.is_free(row, col) \\n  \t\t\t\t\t\tand row + 2 < self.R\\n  \t\t\t\t\t\tand col + 2 < self.C):\\n  \t\t\t\t\tself.matrix[row][col] = BOMB\\n  \t\t\t\t\tself.M -= 1 \\n  \t\t\t\t\treturn True\\n  \t\tfor col in self.range_active_cols:\\n  \t\t\tfor row in self.range_active_rows:\\n  \t\t\t\tif (self.is_free(row, col)\\n  \t\t\t\t\t\tand row + 2 < self.R\\n  \t\t\t\t\t\tand col + 2 < self.C):\\n  \t\t\t\t\tself.matrix[row][col] = BOMB\\n  \t\t\t\t\tself.M -= 1\\n  \t\t\t\t\treturn True\\n  \t\treturn False\\n  \\n  \tdef mark_click(self):\\n  \t\tself.matrix[-1][-1] = 'c'\\n  \\n  \tdef win_condition(self):\\n  \t\tclick_row = len(self.matrix) - 1\\n  \t\tclick_col = len(self.matrix[0]) - 1\\n  \t\tif (click_col - 1 >= 0\\n  \t\t\t\tand not self.is_free(click_row, click_col - 1)):\\n  \t\t\treturn False\\n  \\n  \t\tif (click_row - 1 >= 0\\n  \t\t\t\tand not self.is_free(click_row - 1, click_col)):\\n  \t\t\treturn False\\n  \\n  \t\tif (click_row -1 >= 0\\n  \t\t\t\tand click_col -1 >= 0\\n  \t\t\t\tand not self.is_free(click_row - 1, click_col - 1)):\\n  \t\t\treturn False\\n  \t\t\\n  \t\treturn True\\n  \\n  \tdef win_cond2(self):\\n  \t\tif self.initial_M + 1 == self.C * self.R:\\n  \t\t\treturn True\\n  \t\treturn False\\n  \\n  \tdef solve(self):\\n  \t\tself.optimize()\\n  \t\twhile self.M > 0 and self.place_bomb():\\n  \t\t\tpass\\n  \t\tif self.M == 0 and (self.win_condition() or self.win_cond2()):\\n  \t\t\tself.mark_click()\\n  \t\t\tself.pprint()\\n  \t\telse:\\n  \t\t\tprint('Impossible')\\n  \\n  \\n  def read_case(f):\\n  \treturn map(int, f.readline().split())\\n  \\n  \\n  def main():\\n  \tfn = sys.argv[1]\\n  \twith open(fn, encoding='utf-8') as f:\\n  \t\tncases = int(f.readline())\\n  \t\tfor case in range(1, ncases + 1):\\n  \t\t\tR, C, M = read_case(f)\\n  \t\t\tprint('Case #{}:'.format(case))\\n  \t\t\tb = Board(R, C, M)\\n  \t\t\tb.solve()\\n  \\n  \\n  def main1():\\n  \tb = Board(2, 1, 1)\\n  \tb.solve()\\n  \\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "target": "64", "substitutes": {"FREE": ["NOR", "free", "WARN", "ME", "X", "MW", "ARM", "RE", "REM", "NE", "KER", "WER", "GAME", "ERROR", "NEW", "W", "ARE", "CON", "DE", "random", "RO", "NAME", "GE", "FW", "D", "ER", "UN", "ONE", "ORE", "EW", "FA", "FR", "CO", "NUM", "FE", "FIR", "VALUE", "F", "UM", "Free", "choice", "DEF", "DER", "ANY", "NR", "END", "WARNING", "MAX", "MON", "ERE", "RA", "DEM", "OK"], "BOMB": ["BCOME", " BOWE", " BOWB", " BOWb", " BCOMB", " BOUNDE", "BOMBER", "BCOMBER", "BCOMb", "BOMb", "BOME", "BCOMB", " BCOME", " BOUNDb", " BCOMBER", " BOMBER", " BOWBER", " BOME", " BOMb", " BOUNDB", " BOUNDBER", " BCOMb"], "CLICK": ["CLACK", "clICK", " CLICAL", " CLACK", "clEX", "SLICK", "SLICAL", " CLEX", "CLICAL", "SLACK", "SLEX", "CLEX", "clACK", "clICAL"], "self": ["access", "extra", "args", "proxy", "Self", "manager", "man", "out", "case", "object", "scope", "mod", "parent", "worker", "node", "P", "per", "params", "event", "pos", "plus", "player", "X", "qa", "add", "er", "instance", "w", "n", "system", "x", "f", "game", "user", "e", "full", "module", "client", "d", "default", "G", "p", "config", "context", "host", "static", "co", "layer", "error", "m", "np", "function", "data", "shape", "result", "this", "utils", "other", "load", "private", "ctx", "misc", "results", "members", "high", "hand", "view", "me", "non", "force", "spec", "part", "parse", "connection", "q", "cl", "comp", "both", "func", "base", "style", "work", "cache", "use", "python", "k", "g", "show", "wrapper"], "R": ["N", "U", "RH", "G", "X", "RE", "RR", "MR", "W", "Rs", "RO", "RN", "SR", "Right", "L", "D", "A", "ER", "T", "B", "RS", "S", "RP", "CR", "E", "F", "V", "RF", "DR", "RM", "GR", "Y", "NR", "P", "RT", "RA", "RG"], "C": ["N", "Cs", "U", "G", "Ch", "Cor", "X", "Co", "Cu", "O", "COR", "I", "CL", "CNN", "W", "EC", "VC", "K", "CE", "CM", "DC", "ERC", "CC", "L", "D", "A", "MC", "T", "B", "S", "CO", "CV", "CR", "E", "H", "F", "CI", "V", "CU", "Y", "P"], "M": ["N", "U", "MO", "G", "X", "J", "O", "I", "W", "MD", "CM", "MAN", "Mor", "MX", "m", "MN", "L", "D", "A", "MC", "T", "B", "S", "MA", "E", "H", "MF", "AM", "F", "V", "Man", "RM", "CU", "Y", "Q", "P", "MH", "MM", "LM", "Manager", "RA"], "initial_M": ["final_M", "final_C", "initial_R", "final_m", "initial_C", "final_R", "initial_m"], "matrix": ["Matrix", "mitMatrix", "matagonal", "matangle", "Matangle", "mitrix", "mitrices", "Matdata", "mituration", " matMatrix", " matfix", "maturation", " matrices", "mitdata", "mitfix", "mitangle", "latrices", " matangle", "latrix", "Matagonal", "matrices", "mitagonal", "Matrices", "latMatrix", "matMatrix", "Matfix", " matagonal", " maturation", "MatMatrix", "matfix", "Maturation", "latdata", "matdata"], "c": ["cf", "mc", "rc", "ac", "p", "ce", "ct", "rec", "uc", "m", "rf", "cor", "pc", "bc", "anc", "cin", "a", "rn", "nc", "cm", "arc", "fc", "f", "b", "chain", "cr", "roc", "lc"], "r": ["yr", "rr", "rc", "p", "ur", "j", "ar", "rm", "u", "ra", "ir", "re", "m", "l", "rf", "ro", "rn", "rs", "rd", "sr", "nr", "run", "err", "b", "f", "cm", "cr"], "endx": [" endi", "endedy", "endedi", "endedx", "startx", "starty", "starti", "endi"], "endy": ["endedy", " endpy", "EndY", "Endpy", "endedY", "endY", "endpy", " endY", "endedpy", "endedyy", "Endy", "Endyy", " endyy", "endyy"]}}
{"code": "\\n  \\n  def compute(C, F, X):\\n      k = int(math.floor(X / C - 2.0 / F))\\n      if k <= 0:\\n          return X / 2\\n      total = 0.0\\n      for i in xrange(k):\\n          total += 1.0 / (2.0 + i * F)\\n      return C * total + X / (2.0 + k * F)\\n  \\n  \\n  def parse():\\n      C, F, X = map(float, sys.stdin.readline().strip().split())\\n      return C, F, X\\n  \\n  \\n  if __name__ == \"__main__\":\\n      sys.setrecursionlimit(100000)\\n      T = int(sys.stdin.readline().strip())\\n      for i in xrange(T):\\n          data = parse()\\n          result = compute(*data)\\n          print \"Case #%d: %0.7f\" % (i + 1, result)\\n", "target": "65", "substitutes": {"C": ["N", "CF", "Cs", "U", "UC", "G", "Co", "Cu", "O", "I", "CNN", "CL", "CA", "W", "M", "CM", "K", "CE", "DC", "CP", "CC", "L", "D", "A", "R", "B", " c", "S", "CO", "c", "CV", "CR", "E", "H", "CS", "CI", "V", "CU", "Y", "P", "CT"], "F": ["N", "CF", "U", "G", "Fs", "FD", "DF", "OF", "O", "I", "FB", "W", "FL", "BF", "File", "M", "K", " f", "FIN", "Fi", "FS", "L", "Family", "D", "FO", "EF", "FH", "PF", "FM", "B", "GF", "FC", "FA", "E", "H", "V", "FF", "Y", "Inf", "Q", "P", "f", "MF", "FW"], "X": ["N", "CF", "U", "UC", "ID", "XL", "G", "XP", "PH", "O", "IX", "XXX", "CL", "I", "TX", "W", "IP", "File", "M", "Z", "CE", "K", "EC", "Content", "Data", "CC", "L", "D", "A", "FO", "R", "FX", "WH", "B", "Ex", "S", "FC", "Work", "CO", "CV", "FE", "E", "H", "AC", "UX", "x", "V", "Form", "FF", "XY", "Y", "Q", "P", "XX", "PE"], "k": ["ki", "e", "N", "d", "dk", "sk", "p", "r", "j", "max", "u", "kw", "kk", "t", "unk", "v", "K", "ke", "w", "q", "n", "ik", "m", "ak", "ks", "c", "kick", "key", "a", "x", "ek", "kid", "ok", "b", "f", "o", "ko", "g"], "total": ["full", "d", "TF", "step", "final", "done", "p", "length", "max", "complete", "start", "mu", "count", "fo", "t", "TA", "K", "sum", "error", "partial", "n", "alpha", "valid", "last", "all", "c", "temp", "key", "parent", "a", "Total", "null", " Total", "found", "cost", "fat", "no", "f", " TOTAL", "info", "scale"], "i": ["e", "ki", "N", "si", "ini", "xi", "gi", "d", "id", "num", "mini", "h", "slice", "p", " I", "j", "I", "start", "u", "ie", "z", "multi", "li", "pi", "ai", "ih", "v", "K", "t", "io", "ui", "cli", "uri", "w", "n", "ci", "m", "ii", "index", "di", "c", "int", "a", "phi", "x", "y", "ri", "iu", "b", "ind", "f", "P", "uni", "diff", " j", "chi", "qi"], "T": ["N", "U", "Length", "G", "TN", "Time", "O", "I", "TS", "W", "t", "TA", "M", "IT", "Z", "K", "TH", "L", "D", "A", "R", "B", "S", "TT", "TG", "E", "H", "V", "NT", "Y", "Q", "P", "TL"], "data": ["page", "results", "d", "args", "step", "json", "done", "p", "current", "series", "input", "start", "response", "output", "action", "DATA", "error", "date", "Data", "source", "ata", "feed", "sample", "n", "database", "alpha", "valid", "dat", "raw", "da", "body", "cache", "new", "temp", "df", "test", "call", "array", "f", "draw", "info", "scale"], "result": ["page", "results", "counter", "event", "default", "duration", "final", "current", "match", "ret", "now", "r", "val", "acc", "response", "status", "output", "report", "res", "error", "date", "dict", "expected", "grade", "valid", "function", "func", "new", "work", "Result", "test", "success", "var", "found", "err", "diff"]}}
{"code": "\\n  \\n  DX = (-1, -1, -1, 0, 1, 1, 1, 0)\\n  DY = (-1, 0, 1, 1, 1, 0, -1, -1)\\n  \\n  \\n  def compute(R, C, M):\\n      if M == 0:\\n          return empty(R, C)\\n      free = R * C - M\\n      if free == 1:\\n          return single_free(R, C)\\n      if R == 1:\\n          return single_row(C, M)\\n      if C == 1:\\n          return single_column(R, M)\\n      if R == 2:\\n          return two_rows(C, M)\\n      if C == 2:\\n          return two_columns(R, M)\\n      if free in (2,3,5,7):\\n          return \"\\nImpossible\"\\n      return at_least_three(R, C, M)\\n  \\n  \\n  def make_board(R, C, default='.'):\\n      return [[default for j in xrange(C)] for i in xrange(R)]\\n  \\n  \\n  def to_string(board):\\n      s = \"\"\\n      for i in xrange(len(board)):\\n          s += '\\n' + ''.join(board[i])\\n      return s\\n  \\n          \\n  def empty(R, C):\\n      board = make_board(R, C)\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def single_free(R, C):\\n      board = make_board(R, C, default='*')\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def single_row(C, M):\\n      board = make_board(1, C)\\n      board[0][0] = 'c'\\n      for i in xrange(M):\\n          board[0][C - 1 - i] = '*'\\n      return to_string(board)\\n  \\n  \\n  def single_column(R, M):\\n      board = make_board(R, 1)\\n      board[0][0] = 'c'\\n      for i in xrange(M):\\n          board[R - 1 - i][0] = '*'\\n      return to_string(board)\\n  \\n  \\n  def two_rows(C, M):\\n      if M % 2 != 0:\\n          return \"\\nImpossible\"\\n      if 2 * C - M < 4:\\n          return \"\\nImpossible\"\\n      board = make_board(2, C)\\n      for i in xrange(M / 2):\\n          board[0][C - 1 - i] = '*'\\n          board[1][C - 1 - i] = '*'\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def two_columns(R, M):\\n      if M % 2 != 0:\\n          return \"\\nImpossible\"\\n      if 2 * R - M < 4:\\n          return \"\\nImpossible\"\\n      board = make_board(R, 2)\\n      for i in xrange(M / 2):\\n          board[R - 1 - i][0] = '*'\\n          board[R - 1 - i][1] = '*'\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def finalize(R, C, M, board):\\n      mines = 0\\n      for i in xrange(R):\\n          for j in xrange(C):\\n              if board[i][j] == '0':\\n                  continue\\n              empty = False\\n              for d in xrange(8):\\n                  if i + DX[d] < 0 or i + DX[d] >= R or j + DY[d] < 0 or j + DY[d] >= C:\\n                      continue\\n                  if board[i + DX[d]][j + DY[d]] == '0':\\n                      empty = True\\n                      break\\n              if empty:\\n                  board[i][j] = '.'\\n              else:\\n                  board[i][j] = '*'\\n                  mines += 1\\n      for i in xrange(R):\\n          for j in xrange(C):\\n              if board[i][j] == '0':\\n                  board[i][j] = '.'\\n      board[0][0] = 'c'\\n      if mines != M:\\n          sys.stderr.write(\"mines:%s expected:%s\\n\" % (mines, M))\\n      return to_string(board)\\n  \\n  \\n  def at_least_three(R, C, M):\\n      board = make_board(R, C)\\n      board[0][0] = '0'\\n      free = R * C - M\\n      count = 4\\n      if count == free:\\n          return finalize(R, C, M, board)\\n      board[0][1] = '0'\\n      count += 2\\n      if count == free:\\n          return finalize(R, C, M, board)\\n      board[1][0] = '0'\\n      count += 2\\n      if count == free:\\n          return finalize(R, C, M, board)\\n      for j in xrange(2, C - 1):\\n          if count + 2 > free:\\n              break\\n          board[0][j] = '0'\\n          count += 2\\n      for i in xrange(2, R - 1):\\n          if count + 2 > free:\\n              break\\n          board[i][0] = '0'\\n          count += 2\\n      for i in xrange(1, R - 1):\\n          for j in xrange(1, C - 1):\\n              if count == free:\\n                  return finalize(R, C, M, board)\\n              board[i][j] = '0'\\n              count += 1\\n      sys.stderr.write(\"empty board?\\n\")\\n      return finalize(board)\\n  \\n  \\n  def parse():\\n      R, C, M = map(int, sys.stdin.readline().strip().split())\\n      return R, C, M\\n  \\n  \\n  if __name__ == \"__main__\":\\n      sys.setrecursionlimit(100000)\\n      T = int(sys.stdin.readline().strip())\\n      for i in xrange(T):\\n          sys.stderr.write(\"case:%s\\n\" % (i + 1))\\n          data = parse()\\n          result = compute(*data)\\n          print \"Case #%d: %s\" % (i + 1, result)\\n", "target": "65", "substitutes": {"DX": ["IV", "ID", "DA", "XL", "XP", "DL", "DD", "IP", "MD", "WD", "DE", "DC", "IE", "MX", "DI", "TH", "EX", "D", "ONE", "CD", "DOM", "DS", "YD", "UX", "DR", "XY", "CT", "DT"], "DY": ["Py", "dXY", "DYY", " Dy", " DXY", "Dy", "dYY", "PYY", "dY", " DYY", "PXY", "DXY", "PY", "dy"], "R": ["N", "I", "MR", "Rs", "K", "CC", "Res", "BR", "c", "Q", "P", "Range", "RG", "X", "J", "RR", "CL", "W", "Cl", "Order", "L", "JR", "F", "RF", "RA", "AR", "U", "G", "RL", "RC", "SR", "Re", "A", "S", "RP", "CR", "E", "H", "Br", "V", "WR", "All", "Y", "Ra", "Rh", "RH", "RE", "O", "KR", "r", "RW", "RO", "RN", "Right", "Reader", "D", "OR", "ER", "B", "RS", "Model", "IR", "DR", "Run", "RM", "GR", "NR", "LR"], "C": ["N", "Count", "U", "G", "Ch", "Cor", "X", "SC", "Cu", "O", "WC", "I", "CL", "Size", "CNN", "CA", "r", "W", "YC", "Cl", "CM", "K", "VC", "CE", "EC", "DC", "CW", "CC", "L", "D", "A", "CN", "MC", "B", " c", "S", "CAR", "CO", "c", "CV", "CR", "E", "H", "CS", "AC", "F", "CI", "V", "CU", "Y", "Q", "P", "CT", "Cr"], "M": ["N", "MI", "I", "MR", "MD", "K", "CC", "IM", "end", "AM", "Man", "Q", "P", "MM", "LM", "X", "J", "Me", "CL", "W", "_", "CM", "DC", "MX", "L", "OM", "all", "F", "MF", "U", "G", "num", "MS", "m", "A", "S", "E", "H", "V", "All", "Y", "VM", "O", "r", "NM", "Z", "MN", "D", "OR", "MC", "B", "DM", "MB", "RM", "g"], "free": ["e", "FREE", "ME", "MW", "len", "true", "O", "complete", "none", "max", "MR", "MS", "left", "random", "error", "um", "allow", "Re", "m", "n", "used", "valid", "OR", "function", "UN", "only", " unused", "de", "right", "FR", "all", "c", " Free", "use", "FE", "E", "NO", "F", "x", "fe", "null", "Free", "min", "fee", "void", "con", "float", "f", "no", "fre"], "default": ["standard", "name", "self", "id", "str", "slice", "dc", "p", "current", "length", "none", "switch", "desc", "case", "arrow", "design", "DE", "example", "Default", " defaults", "FAULT", "n", "D", "initial", "index", "value", "de", "data", "common", "enter", "func", "new", "c", "label", "parent", "description", "df", "member", "custom", "null", "x", "second", "void", "option", "arc", "f", "no", "float"], "j": ["gi", "xi", "abi", "ac", "fi", "go", "iii", "ct", "pi", "ai", "co", "ui", "ni", "jac", "ci", "ij", "ice", "ei", "bi", "di", "ti", "ib", "je", "gh", "ji", "ri", "g"], "i": ["e", "gi", "si", "ini", "xi", "ip", "col", "mi", "id", "h", "slice", "p", "I", "u", "iv", "ie", "r", "z", "li", "pi", "ai", "it", "v", "ui", "multi", "io", "ir", "n", "ci", "m", "l", "ii", "ei", "value", "bi", "di", "ti", "one", "yi", "c", "int", "a", "k", "phi", "x", "y", "iu", "b", "ind", "f", "o", "iw", "g", "qi"], "board": ["che", "boards", " row", "sequence", "case", "ward", "design", "object", "card", "row", "pool", " boards", "uc", "index", "back", "c", "cell", " game", "custom", "node", "stroke", "off", "table", "loop", "bo", "player", "word", "clean", "join", "switch", "ban", "bit", "note", "feed", "plan", "video", "body", "ack", "buffer", "code", "foot", "post", "o", "game", "check", "lay", "e", "client", "deck", "cart", "p", "layout", "channel", "go", "config", "lane", "cross", "form", "flo", "co", "comment", "long", "Board", "core", "function", "square", "block", "model", "head", "frame", "ide", "draw", "bug", "coll", "view", "way", "que", "list", "hole", "child", "builder", "image", "flow", "boarding", "land", "group", "string", "bar", "entry", "sync", "base", " clipboard", "line", "bank", "control", "menu", "lc"], "s": ["e", "settings", "ws", "sg", "si", "ns", "h", "words", "p", "sb", "su", "u", "css", "t", "ing", "spec", "ed", "sym", "summary", "comments", "conf", "es", "n", "m", "l", "ss", "S", "sync", "c", "strings", "se", "us", "lines", "sc", "b", "f", "o", "copy", "g", "options", "sup"], "empty": ["full", "e", "size", "clear", "white", "clean", "final", "export", "complete", "none", "ace", "channel", "error", "space", "esc", "private", "equal", "zero", "initial", "missing", "element", "square", "une", "last", "new", "c", "Empty", "blank", "ec", "open", "null", "unknown", "union", "everything"]}}
