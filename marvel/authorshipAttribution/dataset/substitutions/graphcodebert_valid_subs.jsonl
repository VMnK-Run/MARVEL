{"code": "inputFile = open('B-small-attempt0.in', 'r')\\n  lines = inputFile.readlines()\\n  inputFile.close()\\n  \\n  outputFile = open('B-small-attempt0.out', 'w')\\n  \\n  numTests = int(lines[0])\\n  \\n  \\n  def solveCookies(c, f, x):\\n      accumTime = 0\\n      farmRate = 0\\n      while True:\\n          timeToWait = x/(2.0+farmRate)\\n          timeIfBuyFarm = (c/(2.0+farmRate) +   # Time to get a farm\\n                           x/(2.0+farmRate+f))\\n          if timeToWait <= timeIfBuyFarm:\\n              return accumTime+timeToWait\\n          else:\\n              accumTime += c/(2.0+farmRate)\\n              farmRate += f\\n  \\n  for i in range(1, numTests+1):\\n      [c, f, x] = map(lambda x: float(x), lines[i].split())\\n  \\n      outputFile.write('Case #'+str(i)+': ' + str(solveCookies(c, f, x))+'\\n')\\n  outputFile.close()\\n      \\n", "target": "0", "substitutes": {"inputFile": ["inFace", "innerFilename", "inFile", "inputFace", "subjectPath", "outputFilename", "archiveFILE", "subjectFile", "archiveFile", " inputPage", " inputFilename", "innerPage", " inputPath", "outputFiles", "InputFILE", "innerFile", "inputFILE", "subjectfile", "outputFILE", "inPath", "inputfile", "subjectFace", "outputPage", "outputfile", "InputFile", "inputPage", "archiveFiles", "inputFiles", " inputFace", "inputPath", "InputFiles", "archivefile", "innerfile", "infile", "Inputfile", "inputFilename", " inputfile"], "lines": ["olds", "times", "blocks", "cells", "ds", "sections", "cycles", "headers", "details", "steps", " Lines", "links", "its", "ews", "items", "ends", "rs", "prints", "bytes", "ls", "photos", "files", "los", "posts", "results", "vs", "parts", "outs", "line", "dates", "rings", "qs", "elines", "frames", "values", "tests", "years", "els", "works", "vals", "issues", "strings", "lins", "ines", "pins", "rows", "codes", "ues", "reads", "reports", "boxes", "points"], "outputFile": [" outputFormat", "putFile", "OutputFile", "putPath", "putPlace", "writeDirectory", " outputDirectory", "OutputDirectory", "writefile", "writeFile", "responsePath", "inputFormat", "responsefile", " outputPath", "OutputPage", " outputPlace", "putDirectory", "outputDirectory", "inputDirectory", "outputPath", " outputPage", "putPage", "responseFile", "inputfile", "outputPage", "outputfile", "putfile", "putDir", "writeFormat", " outputDir", "OutputDir", " outputfile", "outputDir", "outputPlace", "outputFormat", "responsePlace"], "numTests": ["numNches", " numNets", "numEntests", " numNrees", "numNakes", "numTrees", "numTakes", " numNests", "numLures", "numEntures", "numLakes", "numTures", "numCrees", "numEntakes", " numNtests", "numNures", " numNakes", "numNests", " numTrees", " numTures", "numNrees", " numTakes", "numCests", "numTets", "numSequrees", " numNches", "numTches", "numNets", " numTets", "numTtests", "numSequests", " numTtests", "numSequtests", " numNures", " numTches", "numCets", "numNtests", "numCtests", "numSequets", "numEntches", "numLches", "numLests"], "c": ["cs", "cr", "cont", "cp", "abc", "uc", "u", "y", "cf", "w", "t", "m", "cin", "g", "n", "l", "com", "C", "ac", "z", "con", "mc", "k", "e", "r", "dc", "lc", "co", "time", "b", "fc", "cur", "o", "cos", "ce", "cache", "chain", "v", "cu", "ca", "cd", "ci", "p", "ct", "a", "d", "h", "xc", "cm", "cn", "cc"], "f": ["fed", "file", "cf", "y", "u", "w", "t", "m", "fac", "g", "fal", "n", "l", "sf", "ft", "fx", "bf", "fs", "z", "full", "fe", "fb", "e", "fort", "r", "tf", "q", "fab", "b", "fc", "fo", "fa", "o", "fen", "fg", "xf", "uf", "alf", "j", "rf", "fi", "v", "F", "fd", "family", "fr", "p", "d", "a", "fp", "lf"], "x": ["mx", "cox", "xxx", "ax", "y", "u", "w", "xs", "xt", "t", "xe", "xd", "xml", "xi", "xp", "n", "l", "ix", "xa", "fx", "lex", "z", "e", "xy", "rx", "xb", "r", "time", "b", "px", "o", "xf", "X", "xx", "wx", "dx", "v", "xxxx", "ox", "ex", "rex", "p", "ux", "a", "h", "xc", "tx"], "accumTime": [" accumSize", "accumPoint", "accumptionWait", "accsumTime", "accumsSize", "accumptionPoint", "accumsTimes", " accumTimes", " accsumPoint", "accumptionTime", "accuumPoint", " accummWait", " accsumTim", " accumNow", "accumTimes", "accumbTime", "accUMPoint", " accummNow", "accumbPoint", " accummTimes", "accuumTime", "accummNow", "accumTim", "accsumPoint", "accummTime", " accummPoint", "accumsWait", "accummWait", "accummSize", " accumPoint", "accumptionTim", " accumTim", " accummTime", " accsumTime", "accumNow", "accumbNow", "accuumTim", "accUMNow", "accumptionTimes", "accumptionSize", "accumsTime", "accumSize", "accsumTim", "accUMTime", "accummPoint", " accumWait", "accumWait", " accummSize", "accummTimes"], "farmRate": ["knifeRating", "leadRule", " farmrate", "farmPower", "storerate", "knifeScope", "chanceRate", "permRate", "huntRating", "FarmRule", "huntScope", "huntRank", "huntRate", "chanceRule", "leadRank", " farmRat", " farmRule", " farmScope", "hogPower", " farmFactor", "fortuneRate", "frameworkRule", "farmFactor", "FarmRat", "farmrate", "storeRate", "farmRat", "fortuneRating", "fortuneRule", "hogRule", "hogRate", "permrate", "fleetRule", " farmPower", "farmPerformance", "chanceRating", " farmRank", "frameworkRate", "farmRank", "fortunePower", "leadRate", "fleetRating", "farmScope", " farmPerformance", "fleetRate", " farmRating", "farmRule", "leadFactor", "frameworkRat", "hogRating", "chancePerformance", "huntRule", "fleetPerformance", "huntFactor", "farmRating", "FarmRate", "permRating", "knifeRate", "knifeRule", "storeRating"], "timeToWait": ["timeOfWait", "timeTowait", "TimeTowait", "time2wait", "imeToWa", "time2Hold", " timeToHold", "time2Wa", "timeWillWait", "TimeToWait", "TimeToWa", "timeWillHold", "timetowait", "timeOfwait", "timetoWait", "timeToHold", "timetoWa", " timeToWa", "timeWillWa", "timeToWa", " timeTowait", "imeTowait", "timeWillwait", "timeOfWa", "time2Wait", "imeToWait"], "timeIfBuyFarm": ["timeIfLeanPhoto", "timeIfLeanFarm", "timeIfbuyAg", "timeOfBuyFarm", "timeAndBuyPhoto", "timeIfParkFarm", "timeAndBuyFarm", "timeAndbuyAg", "timeIfPurchaseAg", "timeIfPurchaseFarm", "timeIfBuyAg", "timeIfBuyHardware", "timeIfbuyPhoto", "timeIfParkHardware", "timeAndBuyAg", "timeAndbuyPhoto", "timeIfbuyFarm", "timeIfBuyPhoto", "timeIfbuyHardware", "timeOfBuyHardware", "timeIfLeanAg", "timeAndbuyFarm", "timeIfPurchasePhoto"], "i": ["ti", "y", "ic", "u", "ind", "pi", "li", "m", "t", "xi", "multi", "n", "it", "l", "ix", "index", "z", "e", "k", "zi", "id", "ij", "iu", "q", "ai", "b", "ri", "I", "__", "si", "j", "mi", "ui", "counter", "qi", " j", "di", "gi", "yi", "ii", "me", "ci", "p"]}}
{"code": "inputFile = open('C-small-attempt8.in', 'r')\\n  lines = inputFile.readlines()\\n  inputFile.close()\\n  \\n  outputFile = open('C-small-attempt8.out', 'w')\\n  \\n  numTests = int(lines[0])\\n  \\n  for i in range(1, numTests+1):\\n      [r, c, m] = map(lambda x: int(x), lines[i].split())\\n  \\n      openCells = r*c - m\\n  \\n      works = False\\n      matrix = [['*']*c for j in range(r)]\\n      if r >= 3 and c >= 3:\\n          order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),\\n                   (2,0), (2,1)]\\n          if openCells == 1 or openCells == 4 or openCells == 6:\\n              works = True\\n              for (x,y) in order[:openCells]:\\n                  matrix[x][y] = '.'\\n              matrix[0][0] = 'c'\\n              \\n          elif openCells >= 8:\\n              works = True\\n              filledRows = openCells / c\\n              if filledRows >= 2:\\n                  if filledRows == r:\\n                      matrix = [['.']*c for j in range(r)]\\n                      matrix[0][0] = 'c'\\n                  else:\\n                      remainder = openCells%c\\n                      if not remainder == 1:\\n                          for j in range(filledRows):\\n                              matrix[j] = ['.']*c\\n                          matrix[filledRows] = ['.']*remainder + ['*'] * (c-remainder)\\n                      elif filledRows > 2:\\n                          for j in range(filledRows-1):\\n                              matrix[j] = ['.']*c\\n                          matrix[filledRows-1] = ['.']*(c-1) + ['*']\\n                          matrix[filledRows] = ['.', '.'] + ['*']*(c-2)\\n                      else:\\n                          matrix[0] = ['.']*(c-1) + ['*']                        \\n                          matrix[1] = ['.']*(c-1) + ['*']\\n                          matrix[2] = ['.', '.', '.'] + ['*']*(c-3)\\n                      matrix[0][0] = 'c'\\n                  \\n              else:\\n                  for (x,y) in order:\\n                      matrix[x][y] = '.'\\n                  remainingOpen = openCells - 8\\n                  if remainingOpen % 2 == 0:\\n                      for j in range(remainingOpen/2):\\n                          matrix[0][j+3] = '.'\\n                          matrix[1][j+3] = '.'\\n                  else:\\n                      matrix[2][2] = '.'\\n                      remainingOpen -= 1\\n                      for j in range(remainingOpen/2):\\n                          matrix[0][j+3] = '.'\\n                          matrix[1][j+3] = '.'\\n                  matrix[0][0] = 'c'\\n  \\n      elif r == 1:\\n          works = True\\n          matrix[0] = ['.']*(c-m) + ['*']*m\\n          matrix[0][0] = 'c'\\n      elif c == 1:\\n          works = True\\n          for j in range(r-m):\\n              matrix[j][0] = '.'\\n          matrix[0][0] = 'c'\\n  \\n      elif r == 2 and c == 2:\\n          if m == 3:\\n              works = True\\n              matrix[0][0] = 'c'\\n          elif m == 0:\\n              works = True\\n              matrix = [['c', '.'], ['.', '.']]\\n      elif r == 2:\\n          if m % 2 == 0 and r*c-m > 2:\\n              works = True\\n              matrix[0] = ['.']*(c-m/2) + ['*']*(m/2)\\n              matrix[1] = ['.']*(c-m/2) + ['*']*(m/2)\\n              matrix[0][0] = 'c'\\n          elif r*c-m == 1:\\n              works = True\\n              matrix[0][0] = 'c'\\n      elif c == 2:\\n          if m % 2 == 0 and r*c-m > 2:\\n              works = True\\n              for j in range((r*c-m)/2):\\n                  matrix[j] = ['.', '.']\\n              matrix[0][0] = 'c'\\n          elif r*c-m == 1:\\n              works = True\\n              matrix[0][0] = 'c'\\n      \\n  \\n      outputFile.write('Case #'+str(i)+':\\n')\\n      '''if len(matrix) != r:\\n          print i, matrix\\n      count = 0\\n      for j in range(len(matrix)):\\n          for k in range(len(matrix[j])):\\n              if matrix[j][k] == '*':\\n                  count += 1\\n      if count != m:\\n          print i, matrix'''\\n      if not works:\\n          outputFile.write('Impossible\\n')\\n      else:\\n          for x in range(len(matrix)):\\n              for y in range(len(matrix[0])):\\n                  outputFile.write(matrix[x][y])\\n              outputFile.write('\\n')\\n  outputFile.close()\\n              \\n", "target": "0", "substitutes": {"inputFile": ["inFile", " inputFormat", "openfile", "openPath", "inputFormat", "inFormat", " inputPath", "outputFiles", "openFile", "openFormat", "inputLine", "InputLine", "inPath", "inputfile", "InputDir", "inLine", "outputfile", "InputFile", "inputFiles", " inputFiles", "inputPath", "InputFiles", "outputLine", "outputDir", "infile", "Inputfile", " inputDir", "inputDir", "inFiles", " inputfile"], "lines": ["olds", "rates", "blocks", "plays", "cells", "notes", "ds", "docs", "sections", "cycles", "headers", "comments", "gets", "details", "steps", " Lines", "l", "its", "rs", "prints", "bytes", "ls", "forms", "files", "gs", "posts", "words", "vs", "parts", "bs", "outs", "line", "dates", "rings", "qs", "elines", "frames", "tests", "years", "vals", "issues", "strings", "ines", "pins", "rows", "codes", "reports", "values", "points"], "outputFile": ["Outputfile", "outputPath", " outputPath", "OutputPath", " outputfile", "OutputFiles", "outPath", "outFile", "outputFiles", "outFiles", " outputFiles", "outputfile", "outfile", "OutputFile"], "numTests": ["numNches", "numRest", "numNiments", "numTrees", "numLrees", " numRets", "numTest", " numRests", " numRches", "numTakes", "numRakes", "numLakes", " numTiments", " numRiments", "numPest", "numPrees", "numRiments", "numLest", "numMatets", "numNests", " numTrees", "numMatests", " numTakes", "numTiments", "numTets", "numMatiments", "numRches", "numTches", "numNets", "numRets", " numRrees", "numRrees", " numRest", "numRests", "numMatches", "numPakes", " numRakes", " numTest", " numTches", "numPests", " numTets", "numLests"], "i": ["ti", "ini", "ic", "ind", "pi", "t", "li", "xi", "n", "l", "ix", "index", "z", "bi", "e", "zi", "id", "ij", "ai", "im", "o", "ri", "I", "si", "mi", "v", "di", "gi", "num", "ii", "ci", "p"], "r": ["s", "rt", "cr", "u", "w", "t", "f", "g", "n", "ru", "l", "nr", "rd", "z", "sr", "e", "rs", "re", "q", "rb", "co", "b", "ro", "ar", "o", "R", "rc", "res", "mr", "v", "er", "right", "p", "d", "rar", "a", "h"], "c": ["conf", "chains", "u", "t", "g", "l", "cl", "C", "co", "b", "fc", "cos", "ce", "rc", "v", "cy", "right", "cd", "ct", "tc", "cp", "cont", "w", "anc", "cin", "com", "ac", "z", "mc", "e", "category", "close", "p", "h", "xc", "length", "comments", "f", "n", "arc", "dc", "o", "sc", "self", "col", "ci", "d", "cs", "cr", "ch", "cf", "current", "gc", "con", "re", "lc", "unc", "cache", "chain", "cum", "cu", "pc", "cm", "etc", "cc"], "m": ["sm", "em", "bm", "cr", "mk", "w", "t", "f", "g", "n", "M", "l", "mat", "rm", "tm", "mc", "e", "k", "mm", "b", "im", "o", "am", "mi", "mut", "mr", "v", "gm", "cm", "p", "d", "a", "h"], "x": ["s", "mx", "ax", "xs", "w", "xt", "on", "xe", "xd", "f", "t", "yx", "xi", "xp", "n", "l", "ix", "xa", "fx", "z", "xy", "e", "rx", "px", "xf", "X", "xx", "dx", "wx", "v", "ry", "ox", "ex", "row", "p", "ux", "a", "h", "xc", "tx"], "openCells": ["openCoows", "openNalls", " openNalls", " openChips", "openConods", "openCoells", "freePels", "emptyConells", "openNels", "OpenRcells", "emptyConows", " openClows", "openClcells", "openCaxies", "openCships", "emptyCells", "OpenRods", " openCels", "openRods", "openConows", "openRells", " openCcells", "openWhenells", "openClels", "openCsows", "openScells", "openNows", " openNows", "openCows", "openWhenels", "OpenRodes", "openCries", "openSell", "openPcells", "freePells", "openWhenaxies", " openNhips", " openNels", "freePows", "openButaxies", "OpenRells", "openCcells", "openRels", "emptyCows", "openButells", "openRries", "openClows", "openButows", "openCell", "openNhips", " openCries", "openPels", "openSows", "openCsells", "openShips", "openPalls", "openPods", "emptyCods", "openCsries", "freePaxies", "freeCells", "openRcells", "openCodes", "openNcells", "freeCows", "OpenCcells", "openCoell", "openSells", "openClods", "openCels", " openCalls", "openWhenows", "openRalls", "OpenCells", "openChips", " openNells", "openNells", "openConell", " openCows", "openRodes", "openCods", "freeCaxies", "OpenRows", " openClries", "OpenCods", "openClries", "openPows", "emptyCell", "openRows", "OpenCows", "OpenCodes", " openNcells", "openConells", "freeCels", " openPels", "openCalls", "openButels", "openSodes", " openPows", "openClells", "emptyConell", "emptyConods", "openPaxies", "openSods", "openCscells", "openCoods", " openPcells", " openPells", " openClells", "openPells"], "works": ["cs", " networks", " passes", "shows", "Works", "ists", "ways", "plays", "alks", "working", "worked", "falls", "chains", "cycles", "work", "WORK", "ops", "changes", " runs", "aces", "cases", "yes", " matches", "links", "acts", "runs", "full", "orts", "hands", "ends", "check", " checks", "makes", "forms", "poses", "groups", "es", "words", "results", "outs", "pps", "weights", "checks", "parts", "dates", "features", "ws", "workers", "has", "hops", "grades", "helps", "marks", "points"], "matrix": ["memric", "modulection", "matace", "memrice", "patprint", "twise", "patric", " matix", "docplex", "monrics", "matrench", " matrench", "patrier", "scheric", "plotrix", "scherics", "matension", "atrics", "metrics", "Matric", "statace", "monress", "projectix", " matrixprint", "statrix", "statplex", "Matplex", "mrier", " matric", "docrix", "atrices", "matchrics", "listrice", "Matrice", "Matrics", "plotrench", "docace", "scheress", "timeitude", "atrier", "timerics", "matction", "patrix", "tction", "Matction", "plotprint", "Matace", "monrix", "memrics", "transric", "matchric", "transrices", "matross", "matix", "transrix", "trix", "modulerix", "Matension", "monrices", " matrixribution", "matchrix", "matitude", " matrixrix", "listrics", "listrix", "moduleric", "matrics", "modulewise", "tric", " matprint", "projectrix", "Matross", "monric", " matrixix", "metitude", "metric", "mrices", "metrix", " matress", "atric", "memrix", "matrier", "matchitude", " matrice", "documentrix", "Matrices", "documentrics", "scherix", "mrics", "plotric", "matrice", "projectribution", "statension", "atrice", "timeric", "projectprint", "matwise", "mrix", "docension", "matplex", "documentension", "matric", "matribution", "documentrice", "patrench", "mric", "memrices", " matribution", "matress", "matrices", " matension", "mross", "matprint", "listric", " matrics", "Matrix", "transross", "atrix", "timerix", "Matwise", "patrices"], "j": ["jl", "json", "ja", "cr", "J", "jj", "ch", "ind", "jas", "li", "g", "ie", "it", "kj", "n", "l", "ix", "aj", "z", "js", "jp", "xy", "dj", "k", "ij", "jc", "q", "jac", "bj", "br", "o", "obj", "pr", "jam", "ver", "v", "str", "fr", "jump", "uj", "p", "ji", "ct", "job", "d", "h", "oj"], "order": ["sort", "address", "orient", "case", "Order", "dir", "ordered", "condition", "index", "direction", "map", "set", "rank", "grid", "where", "id", "table", "group", "rule", "cycle", "info", "align", "random", "er", "list", "ice", "position", "der", "scale", "type", "graph", "ord", "ords", "array", "rows", "era", "orders"], "y": ["s", "gy", "ay", "iy", "ty", "ch", "t", "Y", "yx", "n", "yt", "z", "yn", "ies", "py", "xy", "wy", "yy", "ij", "ny", "b", "o", "ey", "xx", "yr", "v", "ry", "sy", "cy", "col", "ym", "p", "h", "yl"], "filledRows": ["filledSrows", "filledNorts", " filledLrows", "filledBRRow", "filledSows", " filledCows", "filledNanks", "illedProws", "filledRRow", "illedROWS", "filledDells", "filledBRells", " filledRanks", "occupiedRrows", "fillRRow", "filledSanks", "filledRsates", "filledRates", "filledROWS", "occupiedRays", "filledLows", " filledRells", "filledRrows", "filledDorts", "filledLrows", " filledLows", "filledCows", "filledPanks", "illedRows", "filledLrs", "filledCells", " filledROWS", "filledRrs", " filledRrows", "illedPanks", " filledLOWS", "fillRows", "illedPows", "filledDows", "illedSells", "filledBRows", "filledPows", "filledNows", "fillRorts", "filledRsOWS", "filledRorts", "filledNrs", "filledRsows", "filledLorts", "fillNorts", "fillNrs", " filledCanks", "fillNows", "filledNrows", "occupiedRows", "filledBRorts", "illedSrows", " filledRrs", "occupiedRrs", "illedSanks", "fillRrs", "illedSows", "fillRates", "filledPells", "filledCrows", "filledLays", "filledRays", "illedPOWS", "filledRells", " filledLrs", "illedRrows", "filledSells", "fillNrows", "filledPOWS", " filledCells", "fillROWS", "filledLells", "filledRanks", "filledPrs", "illedRells", "filledCrs", "filledLates", "fillRells", "filledCorts", "filledNells", "fillNells", "filledCanks", "filledNRow", "filledProws", "filledRsrows", "filledDRow", "fillRrows", "filledLOWS", "fillNRow", "illedRanks", " filledCrows"], "remainder": ["remainingger", "Remrainger", "remrainter", "Remainster", "RemainDER", "remrainner", "REMainsner", "Remainsder", "remainingter", " remainingdr", "remainingdr", "REMainner", "remrainger", "RemrainDER", "Remainsger", "remainDER", "Remainter", "Remrainder", "remainsger", "Remainsdr", "REMainder", "remainedter", "remainedder", "REMainsder", " remainingDER", "remainter", "REMainsDER", "remraindr", "REMainster", "remrainDER", "Remainder", " remainingger", "remainsder", "REMainter", "Remainger", "remaindr", "remainingder", "remainster", "remainsner", "remainedDER", "remainger", "remainner", "remainingDER", "remainedner", "Remrainter", "remrainder", "remainsdr", " remainingder", " remainDER", " remaindr", "remainedger", " remainger", "remainsDER", "REMainDER", "Remaindr"]}}
{"code": "\\n  \\n  \\n  \\n  \\n  \\n  \\n  class memoize(object):\\n     \"\"\"Decorator. Caches a function's return value each time it is called.\\n     If called later with the same arguments, the cached value is returned\\n     (not reevaluated).\\n     \"\"\"\\n     def __init__(self, func):\\n        self.func = func\\n        self.cache = {}\\n     def __call__(self, *args):\\n        if not isinstance(args, collections.Hashable):\\n           return self.func(*args)\\n        if args in self.cache:\\n           return self.cache[args]\\n        else:\\n           value = self.func(*args)\\n           self.cache[args] = value\\n           return value\\n     def __repr__(self):\\n        '''Return the function's docstring.'''\\n        return self.func.__doc__\\n     def __get__(self, obj, objtype):\\n        '''Support instance methods.'''\\n        return functools.partial(self.__call__, obj)\\n  \\n  \\n  def precalculate():\\n      \"\"\"Perform any calculations that need to be performed before the main path\\n      (e.g., preparing lookup tables, etc.)\\n      \\n      N.B. Make sure you make any important variables global so that other\\n      functions can access them.\\n      \"\"\"\\n      pass\\n  \\n  def read_input(infile):\\n      \"\"\"This function should take an open input file, load in all of the\\n      relevant information for a single case of the problem, and output it\\n      as a single object.    \\n      \"\"\"\\n      def read_int():\\n          return int(infile.readline().strip())\\n      def read_ints():\\n          return np.array(infile.readline().split(), dtype=int)\\n      def read_bigints(): #For ints that won't fit directly in an int32 array\\n          line = infile.readline().split()\\n          return np.array(map(lambda x: int(x), line))\\n      def read_float():\\n          return float(infile.readline().strip())\\n      def read_floats():\\n          return np.array(infile.readline().split(), dtype=float)\\n      def read_string():\\n          return infile.readline().strip()\\n      def read_strings():\\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\\n      \\n      C, F, X = read_floats()\\n      \\n      case = (C, F, X)\\n      \\n      return case\\n  \\n  def solve_case(case):\\n      \"\"\"Take the input data (structured in case) and perform any necessary\\n      calculations to obtain the desired output, formatted as the appropriate\\n      string.    \\n      \"\"\"\\n      C, F, X = case\\n      \\n      rate = 2.0\\n      cookies = 0.0\\n      time = 0.0\\n      \\n      if C >= X:\\n          return X / rate\\n      \\n      while cookies < X:\\n          if cookies < C:\\n              wait_time = (C - cookies) / rate\\n              time += wait_time\\n              cookies = C\\n          time_if_wait = (X - C) / rate\\n          time_if_buy = X / (rate + F)\\n          if time_if_wait < time_if_buy:\\n              return time + time_if_wait\\n          else:\\n              rate += F\\n              cookies = 0.0\\n  \\n  \\n  if __name__ == \"__main__\":\\n      precalculate()\\n      \\n      assert len(sys.argv) == 2 #only one argument\\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\\n      infile = open(\"%s\" % sys.argv[1], 'r')\\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\\n      \\n      cases = int(infile.readline().strip('\\n'))\\n      for i in range(cases):\\n          \\n          case = read_input(infile)\\n          \\n          output = solve_case(case)\\n          \\n          outfile.write('Case #%i: %s\\n' % (i+1, output))\\n          print 'Case #%i: %s\\n' % (i+1, output)\\n      \\n      infile.close()\\n      outfile.close()\\n", "target": "1", "substitutes": {"self": ["s", "patch", "conn", "operator", "t", "req", "attr", "cl", "errors", "full", "pub", "rs", "root", "k", "proc", "resp", "q", "ls", "sw", "__", "output", "ae", "wrapper", "debug", "method", "me", "ctx", "pp", "round", "console", "instance", "just", "tx", "also", "first", "w", "cert", "details", "agg", "sh", "sub", "util", "r", "default", "se", "results", "close", "parts", "res", "prefix", "print", "replace", "p", "parent", "h", "eth", "new", "ren", "n", "this", "py", "mp", "context", "ref", "rem", "always", "add", "private", "nt", "raw", "wn", "github", "pl", "rb", "my", "python", "sys", "object", "compl", "subject", "ms", "empty", "th", "public", "today", "view", "dev", "Self", "weak", "ix", "links", "remote", "local", "user", "app", "config", "rel", "pkg", "params", "x", "ws", "cmp", "au", "your", "item"], "func": ["cs", "expr", "conf", "cmd", "gen", "cast", "conn", "cf", "dec", "spec", "fam", "f", "exec", "fac", "sec", "agg", "attr", "fx", "c", "init", "kw", "what", "fs", "cc", "partial", "con", "util", "function", "proc", "map", "grid", "closure", "call", "callback", "co", "orig", "go", "var", "fc", "unc", "cur", "pkg", "apply", "fn", "cu", "ws", "wrapper", "conv", "coord", "impl", "cb", "method", "ctx", "cn", "val", "aux", "imp", "fun", "nc"], "cache": ["cs", "release", "data", "conf", "proxy", "size", "spec", "aches", "cv", "history", " Cache", "memory", "index", "c", "ac", "acl", "buffer", "lock", "parse", "store", "map", "db", "config", "ready", "table", "state", "client", "session", "co", "group", "module", "hash", "cos", "template", "temp", "dict", "Cache", "cycle", "chain", "output", "count", "ae", "storage", "pre", "allow", "use", "list", "ca", "metadata", "filter", "api", "sum", "driver", "ache"], "value": ["sample", "data", "json", "result", "message", "python", "object", "to", "pair", "expression", "new", "we", "Value", "current", "vector", "it", "key", "total", "test", "name", "write", "other", "function", "set", "unit", "root", "response", "get", "default", "property", "variable", "ter", "widget", "field", "ret", "output", "v", "process", "package", "commit", "VALUE", "next", "val", "p", "content", "void", "item", "alt", "instance", "values", "bar"], "args": ["tags", "ys", "arr", "gets", " arguments", "keys", "rs", "ls", "files", "extra", "now", "abs", "els", "vals", "atts", "actions", "GS", "w", "changes", "ips", "uments", "bytes", "groups", "words", "results", "parts", "apps", "ts", "ras", "terms", "md", "ars", "members", "points", "ids", "amps", "ds", "names", "aults", "xs", "annot", "items", "ns", "ps", "ims", "ats", "posts", "bs", "qs", "arg", "any", "pos", "ians", "values", "Args", "cs", "cmd", "ms", "stats", "fs", "gs", "aws", "params", "fields", "ags", "tests", "ig", "ays", "ords", "rows", "ins", "flags"], "obj": ["ob", "expr", "object", "oid", "bo", "t", "typ", "attr", "kind", "js", "inst", "this", "other", "tmp", "obs", "auto", "orig", "ref", "Obj", "o", "elt", "nt", "res", "x", "out", "act", "arg", "ex", "node", "ctx", "val", "type", "item", "instance", "ot"], "objtype": [" objType", "objectType", " objtyp", " objtypes", "objtyp", "xtyp", "objecttypes", "xtypes", "xtype", "xType", "objtypes", "objecttype", "objType", "objecttyp"], "infile": ["infp", "inFile", "outpath", "inifp", "Inpath", "cinFile", "inline", "outfiles", "inputfiles", "cinfile", "cinline", "Infile", "infiles", "outfp", " infp", " inline", "Inline", "inputplace", "outfile", "Inplace", "inputfile", "outplace", "inputline", "inplace", "outline", "inifile", "iniline", "outFile", "cinpath", "inpath", "InFile", "Infiles"]}}
{"code": "\\n  \\n  \\n  \\n  \\n  \\n  \\n  class memoize(object):\\n     \"\"\"Decorator. Caches a function's return value each time it is called.\\n     If called later with the same arguments, the cached value is returned\\n     (not reevaluated).\\n     \"\"\"\\n     def __init__(self, func):\\n        self.func = func\\n        self.cache = {}\\n     def __call__(self, *args):\\n        if not isinstance(args, collections.Hashable):\\n           return self.func(*args)\\n        if args in self.cache:\\n           return self.cache[args]\\n        else:\\n           value = self.func(*args)\\n           self.cache[args] = value\\n           return value\\n     def __repr__(self):\\n        '''Return the function's docstring.'''\\n        return self.func.__doc__\\n     def __get__(self, obj, objtype):\\n        '''Support instance methods.'''\\n        return functools.partial(self.__call__, obj)\\n  \\n  \\n  def precalculate():\\n      \"\"\"Perform any calculations that need to be performed before the main path\\n      (e.g., preparing lookup tables, etc.)\\n      \\n      N.B. Make sure you make any important variables global so that other\\n      functions can access them.\\n      \"\"\"\\n      pass\\n  \\n  def read_input(infile):\\n      \"\"\"This function should take an open input file, load in all of the\\n      relevant information for a single case of the problem, and output it\\n      as a single object.    \\n      \"\"\"\\n      def read_int():\\n          return int(infile.readline().strip())\\n      def read_ints():\\n          return np.array(infile.readline().split(), dtype=int)\\n      def read_bigints(): #For ints that won't fit directly in an int32 array\\n          line = infile.readline().split()\\n          return np.array(map(lambda x: int(x), line))\\n      def read_float():\\n          return float(infile.readline().strip())\\n      def read_floats():\\n          return np.array(infile.readline().split(), dtype=float)\\n      def read_string():\\n          return infile.readline().strip()\\n      def read_strings():\\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\\n      \\n      R, C, M = read_ints()\\n      \\n      return R, C, M\\n  \\n  def solve_case(case):\\n      \"\"\"Take the input data (structured in case) and perform any necessary\\n      calculations to obtain the desired output, formatted as the appropriate\\n      string.    \\n      \"\"\"\\n      R, C, M = case\\n      \\n      free = R * C - M\\n      assert free >= 1\\n      \\n      board = np.zeros((R, C), dtype=int) - 1\\n      \\n      def write_board(board):\\n          d = {0:'.', 1:'c', 2:'*'}\\n          s = \"\\n\"\\n          for row in board:\\n              for num in row:\\n                  try:\\n                      s += d[num]\\n                  except KeyError:\\n                      raise ValueError(\"Board not filled in!\")\\n              s += \"\\n\"\\n          return s\\n      \\n      board[0,0] = 1\\n      \\n      if M == 0:\\n          board[board == -1] = 0\\n          return write_board(board)\\n      \\n      if free == 1:\\n          board[board == -1] = 2\\n          return write_board(board)\\n          \\n      \\n      while min(R, C) <= M:\\n          if R < C:\\n              board[:,C-1] = 2\\n              C -= 1\\n              M -= R\\n          elif C <= R:\\n              board[R-1,:] = 2\\n              R -= 1\\n              M -= C\\n      \\n      def cascades(board, r, c):\\n          rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]\\n          cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]\\n          for r in rows:\\n              for c in cols:\\n                  if board[r,c] == 2: #Mine next to given position\\n                      return False\\n          return True\\n      \\n      if M == 0:\\n          board[board == -1] = 0\\n          if cascades(board, 0, 0):\\n              return write_board(board)\\n          else:\\n              return \"\\nImpossible\"\\n      \\n      \\n      if M > (R + C - 5):\\n          return \"\\nImpossible\"\\n          \\n      if M > 0 and (R <= 2 or C <= 2):\\n          return \"\\nImpossible\"\\n          \\n      print M, R + C - 5\\n      fill_num = min(M, R - 2)\\n      print M, fill_num\\n      board[(R - fill_num):,C-1] = 2\\n      M -= fill_num\\n      \\n      fill_num = min(M, C - 3)\\n      print M, fill_num\\n      board[R-1,(C - fill_num - 1):] = 2\\n      M -= fill_num\\n      \\n      board[board == -1] = 0\\n      return write_board(board)\\n  \\n  \\n  if __name__ == \"__main__\":\\n      precalculate()\\n      \\n      assert len(sys.argv) == 2 #only one argument\\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\\n      infile = open(\"%s\" % sys.argv[1], 'r')\\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\\n      \\n      cases = int(infile.readline().strip('\\n'))\\n      for i in range(cases):\\n          \\n          case = read_input(infile)\\n          \\n          output = solve_case(case)\\n          \\n          outfile.write('Case #%i: %s\\n' % (i+1, output))\\n          print 'Case #%i: %s\\n' % (i+1, output)\\n      \\n      infile.close()\\n      outfile.close()\\n", "target": "1", "substitutes": {"self": ["s", "patch", "conn", "operator", "t", "req", "attr", "cl", "errors", "full", "pub", "rs", "root", "k", "proc", "resp", "q", "ls", "sw", "__", "output", "ae", "wrapper", "debug", "method", "me", "ctx", "pp", "round", "console", "instance", "just", "tx", "also", "first", "w", "cert", "details", "agg", "sh", "sub", "util", "r", "default", "se", "results", "close", "parts", "res", "prefix", "print", "replace", "p", "parent", "h", "eth", "new", "ren", "n", "this", "py", "mp", "context", "ref", "rem", "always", "add", "private", "nt", "raw", "wn", "github", "pl", "rb", "my", "python", "sys", "object", "compl", "subject", "ms", "empty", "th", "public", "today", "view", "dev", "Self", "weak", "ix", "links", "remote", "local", "user", "app", "config", "rel", "pkg", "params", "x", "ws", "cmp", "au", "your", "item"], "func": ["cs", "expr", "conf", "cmd", "gen", "cast", "conn", "cf", "dec", "spec", "fam", "f", "exec", "fac", "sec", "agg", "attr", "fx", "c", "init", "kw", "what", "fs", "cc", "partial", "con", "util", "function", "proc", "map", "grid", "closure", "call", "callback", "co", "orig", "go", "var", "fc", "unc", "cur", "pkg", "apply", "fn", "cu", "ws", "wrapper", "conv", "coord", "impl", "cb", "method", "ctx", "cn", "val", "aux", "imp", "fun", "nc"], "cache": ["cs", "release", "data", "conf", "proxy", "size", "spec", "aches", "cv", "history", " Cache", "memory", "index", "c", "ac", "acl", "buffer", "lock", "parse", "store", "map", "db", "config", "ready", "table", "state", "client", "session", "co", "group", "module", "hash", "cos", "template", "temp", "dict", "Cache", "cycle", "chain", "output", "count", "ae", "storage", "pre", "allow", "use", "list", "ca", "metadata", "filter", "api", "sum", "driver", "ache"], "value": ["sample", "data", "json", "result", "message", "python", "object", "to", "pair", "expression", "new", "we", "Value", "current", "vector", "it", "key", "total", "test", "name", "write", "other", "function", "set", "unit", "root", "response", "get", "default", "property", "variable", "ter", "widget", "field", "ret", "output", "v", "process", "package", "commit", "VALUE", "next", "val", "p", "content", "void", "item", "alt", "instance", "values", "bar"], "args": ["tags", "ys", "arr", "gets", " arguments", "keys", "rs", "ls", "files", "extra", "now", "abs", "els", "vals", "atts", "actions", "GS", "w", "changes", "ips", "uments", "bytes", "groups", "words", "results", "parts", "apps", "ts", "ras", "terms", "md", "ars", "members", "points", "ids", "amps", "ds", "names", "aults", "xs", "annot", "items", "ns", "ps", "ims", "ats", "posts", "bs", "qs", "arg", "any", "pos", "ians", "values", "Args", "cs", "cmd", "ms", "stats", "fs", "gs", "aws", "params", "fields", "ags", "tests", "ig", "ays", "ords", "rows", "ins", "flags"], "obj": ["ob", "expr", "object", "oid", "bo", "t", "typ", "attr", "kind", "js", "inst", "this", "other", "tmp", "obs", "auto", "orig", "ref", "Obj", "o", "elt", "nt", "res", "x", "out", "act", "arg", "ex", "node", "ctx", "val", "type", "item", "instance", "ot"], "objtype": [" objType", "objectType", " objtyp", " objtypes", "objtyp", "xtyp", "objecttypes", "xtypes", "xtype", "xType", "objtypes", "objecttype", "objType", "objecttyp"], "infile": ["infp", "inFile", "outpath", "inifp", "Inpath", "cinFile", "inline", "outfiles", "inputfiles", "cinfile", "cinline", "Infile", "infiles", "outfp", " infp", " inline", "Inline", "inputplace", "outfile", "Inplace", "inputfile", "outplace", "inputline", "inplace", "outline", "inifile", "iniline", "outFile", "cinpath", "inpath", "InFile", "Infiles"]}}
{"code": "\\n  \\n  \\n  class Cookie_2014_QB(puzutils.CodeJamProblem):\\n    def __init__(self, inputFilename):\\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\\n  \\n      self.T = None\\n  \\n    def load(self):\\n      \"\"\"\\n        input:\\n  \\n        T (number of test cases)\\n  \\n        C F X (real numbers)\\n  \\n      \"\"\"\\n  \\n      self.tests = []\\n  \\n      with open(self.inputFilename, \"rt\") as file:\\n        self.T = int(file.readline().strip())\\n  \\n        for i in xrange(self.T):\\n          (C,F,X) = [float(x) for x in file.readline().split(' ')]\\n  \\n          self.tests.append([C,F,X])\\n  \\n      return True\\n  \\n    def timeToNextFarm(self, C, rate):\\n      \"\"\"\\n        How long in seconds until we get the next farm.\\n      \"\"\"\\n  \\n      return (C * 1.0) / rate\\n  \\n    def timeToTarget(self, C, X, rate):\\n      \"\"\"\\n        How long in seconds until we hit the target.\\n      \"\"\"\\n  \\n      return ( X * 1.0) / rate\\n  \\n    def isFarmWorthIt(self, C, X, F, rate):\\n  \\n      withoutFarm = self.timeToTarget(C, X, rate)\\n      withFarm = self.timeToNextFarm(C, rate) + self.timeToTarget(C, X, rate + F)\\n  \\n  \\n      if (withFarm < withoutFarm):\\n        return True\\n      else:\\n        return False\\n  \\n    def executeTest(self, test):\\n      \"\"\"\\n        Run a test and return output.\\n      \"\"\"\\n  \\n      (C,F,X) = test\\n      rate = 2\\n      elapsed = 0.0\\n  \\n  \\n      while True:\\n        if self.isFarmWorthIt(C, X, F, rate):\\n          elapsed = elapsed + self.timeToNextFarm(C, rate)\\n          rate = rate + F\\n        else:\\n          elapsed = elapsed + self.timeToTarget(C, X, rate)\\n          return \"%0.7f\" % (elapsed, )\\n  \\n  with Cookie_2014_QB(sys.argv[1]) as problem:\\n    problem.load()\\n  \\n    problem.run()\\n", "target": "2", "substitutes": {"self": ["s", "disk", "ass", "small", "conn", "spec", "t", "req", "attr", "cl", "full", "rs", "tmp", "resp", "q", "ls", "mem", "shape", "sw", "diff", "ae", "writer", "debug", "method", "me", "console", "instance", "ALL", "tx", "also", "log", "builder", "json", "w", "sql", "details", "history", "xml", "sub", "partial", "db", "client", "r", "left", "handler", "rec", "se", "close", "about", "news", "terms", "print", "conv", "p", "parent", "h", "err", "record", "form", "func", "eth", "asm", "new", "ren", "n", "lex", "this", "py", "ns", "body", "get", "mp", "student", "ref", "rem", "review", "context", "add", "private", "nt", "raw", "reader", "wn", "github", "you", "hw", "my", "python", "sys", "object", "compl", "subject", "np", "series", "th", "public", "ind", "handle", "view", "dev", "Self", "remote", "user", "local", "app", "config", "sq", "make", "obj", "rel", "pkg", "ssl", "info", "params", "fields", "rou", "ws", "cmp", "so", "both", "au", "your", "all", "ins"], "inputFilename": ["imagefilename", " inputString", "imageFilename", "outputFilename", "sourceFilename", "sourcefilename", "imageFiles", "sourceFiles", "outputFiles", "imageFile", "inputfilename", "outputfilename", "InputString", "inputString", "outputFile", " inputfilename", " inputFile", "InputFile", "InputFilename", "inputFiles", "imageString", " inputFiles", "InputFiles", "Inputfilename", "inputFile", "sourceFile"], "T": ["V", "G", "W", "P", "TB", "Time", "J", "TN", "t", "TG", "Y", "PT", "TPS", "N", "M", "B", "TA", "D", "TT", "TV", "H", "TY", "K", "TP", "I", "R", "E", "TS", "S", "TED", "NT", "L", "TR", "TM", "VT", "Z", "TC", "TL"], "tests": ["lets", "tags", "times", "services", "ests", "sections", "stats", "steps", "cases", "drivers", "testers", "ctors", "runs", "items", "lines", "classes", "devices", "tmp", "files", "gs", "suits", "lists", "groups", "fits", "results", "tested", "vs", "loads", "checks", "apps", "features", "units", "uds", "agents", "reads", "uploads", "rets", "reports", "testing"], "i": ["ti", "y", "ind", "f", "it", "n", "ix", "l", "c", "z", " ii", "e", "k", "iter", "id", "r", "im", "I", "j", " j", "ip", "p", "d", "ci"], "C": ["V", "AC", "CS", "G", "CI", "CV", "P", "W", "IC", "Chain", "CNN", "COR", "CC", "CO", "Cod", "Y", "CG", "N", "M", "Can", "CL", "Count", "MC", "Category", "c", "CM", "Car", "B", "D", "CF", "YC", "CB", "Ch", "H", "K", "LC", "CE", "CT", "JC", "You", "Cap", "Cl", "CU", "CD", "DC", "A", "I", "Color", "R", "EC", "CP", "Cache", "CA", "S", "U", "L", "Config", "Chart", "Cat", "CON", "Q", "CH", "CW", "GC", "WC", "TC", "Co", "SC"], "F": ["V", "G", "W", "P", "FU", "FT", "J", "FW", "GF", "FR", "FS", "Fs", "f", "AF", "Y", "FER", "Feed", "N", "M", "MF", "FB", "B", "OW", "RF", "TF", "D", "EF", "CF", "FL", "FD", "IF", "Fi", "H", "K", "DF", "UF", "I", "Full", "R", "E", "FO", "S", "FG", "WF", "Field", "U", "L", "FP", "Fun", "Rate", "FN", "Q", "SF", "OF", "HF", "PF", "FF", "Family", "FE"], "X": ["V", "AC", "Tx", "Test", "IV", "W", "P", "ML", "IC", "J", "Time", "TX", "Fixed", "FX", "XY", "Y", "N", "M", "FC", "EX", "MC", "PE", "B", "Xi", "Win", "HTTP", "XL", "FE", "PC", "WH", "TY", "H", "K", "CE", "IM", "CT", "IX", "XX", "Ax", "Cross", "DX", "I", "R", "E", "S", "L", "U", "Location", "IR", "UX", "XP", "Q", "CH", "XT", "OX", "MX", "Z", "ZX", "XXX", "Ex", "ICE"], "x": ["mx", "ax", "y", "xs", "xt", "t", "at", "xe", "xxxxxxxx", "xi", "n", "ix", "xa", "fx", "z", "e", "k", "xy", "plex", "xb", "xes", "px", "number", "xf", "xx", "cross", "dx", "wx", "v", "ox", " ax", "ex", "inx", "rex", "p", "ux", "tx", "xc", "string", "rx"], "rate": ["ate", "timeout", "prime", "date", "sync", "t", "wheel", "capacity", "float", "counter", "age", "force", "speed", "type", "ct", "chance", "create", "range", "rice", "core", "dr", "sex", "ime", "step", "fine", "e", "rew", "r", "rule", "term", "Rate", "command", "feed", "scale", "delay", " factor", "p", "exp", "price", "fare", "err", "score", "sample", "length", "rates", "rating", "f", "fee", "base", "rat", "rand", "ride", "time", "raw", "ry", "erate", "te", "race", "lr", "stop", "duration", "fps", "value", "seed", "cr", "size", "frequency", "pe", "peed", "pair", "phrase", "cer", "unit", "reason", "rank", "re", "example", "lag", "rated", "request", "R", "cycle", "chain", "currency", "process", "er", "grow", "code", "error", "cm", "average", "factor"], "withoutFarm": ["lessPool", "withoutPool", " withoutfarm", "WithoutHunt", " withoutHunt", "despitePlug", "withoutfarm", " withoutLuck", "justRace", " withoutPlug", "despiteFarm", "WithoutFarm", "WithoutPlug", "withoutLuck", "withoutPlug", " withoutPool", "justFarm", "despitefarm", " withoutRace", "withoutHunt", "justPool", "lessRace", "Withoutfarm", "lessLuck", "justLuck", "lessFarm", "withoutRace", "despiteHunt"], "withFarm": ["withoutShip", "addLuck", "newBarn", "noLuck", "newLuck", " withLuck", "insteadLean", "addLean", "noShip", "insteadBarn", "newLean", "withLuck", "noFarm", "withoutLuck", "withLean", "addBarn", "withShip", "newFarm", "insteadFarm", "insteadLuck", " withShip", "withBarn", "addFarm"], "test": ["sample", "Test", "int", "result", "est", "fake", "new", "t", "feature", "f", "case", "train", "it", "n", "txt", "fe", "function", "tmp", "set", "unit", "iter", "get", "example", "tf", "time", "zero", "instance", "v", "te", "the", "arg", "val", "p", "testing"], "elapsed": ["elimated", "relapse", "lenapses", "eleimated", "alapses", "alapse", "relapsed", "lapse", "eroded", "ellapse", " elimated", "ellapped", "eleapsed", "Elapses", "elapses", "elloded", "located", "lapsed", "Elopped", "aloded", "erimated", "eleapse", "alaped", "elocated", "alimated", "lopped", "Elapse", "ellaped", "lenaped", " elopped", "alapsed", "lenapsed", "elopped", "relapses", "lapses", "ellimated", "reloded", "Elapsed", "eloded", "erapped", "Elocated", "alocated", "elaped", "eleocated", "lenapse", "Eloded", "erapsed", "laped", " elapse", "ellocated", "elapped", "ellapses", "alapped", " elocated", "ellapsed", "elapse"]}}
{"code": "\\n  \\n  \\n  class Minesweeper_2014_QC(puzutils.CodeJamProblem):\\n    def __init__(self, inputFilename):\\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\\n  \\n      self.T = None\\n  \\n    def load(self):\\n      \"\"\"\\n        input:\\n  \\n        T (number of test cases)\\n  \\n        R C M (integers)\\n  \\n      \"\"\"\\n  \\n      self.tests = []\\n  \\n      with open(self.inputFilename, \"rt\") as file:\\n        self.T = int(file.readline().strip())\\n  \\n        for i in xrange(self.T):\\n          (R,C,M) = [int(x) for x in file.readline().split(' ')]\\n  \\n          self.tests.append([R,C,M])\\n  \\n      return True\\n  \\n    def boardToString(self, board):\\n      retval = \"\"\\n  \\n      for row in board:\\n        retval = retval + \"\\n\" + \"\".join(row)\\n  \\n      return retval\\n  \\n    def executeTest(self, test):\\n      \"\"\"\\n        Run a test and return output.\\n      \"\"\"\\n  \\n      (R,C,M) = test\\n  \\n      spaces = R * C\\n      blanks = spaces - M\\n  \\n      if (blanks <= 0):\\n        return \"Impossible\"\\n  \\n      board = [['.' for x in range(C)] for y in range(R)]\\n  \\n      board[R-1][C-1] = \"c\"\\n  \\n      badpositions=[]\\n      positions=[]\\n  \\n      for x in xrange(C):\\n        for y in xrange(R):\\n          if (x == (C-1)) and (y == (R-1)):\\n            continue\\n          if (x == (C-1)) and (y == (R-2)):\\n            badpositions.append((x,y))\\n            continue\\n          if (x == (C-2)) and (y == (R-1)):\\n            badpositions.append((x,y))\\n            continue\\n          if (x == (C-2)) and (y == (R-2)):\\n            badpositions.append((x,y))\\n            continue\\n  \\n          positions.append((x,y))\\n  \\n      positions.reverse()\\n  \\n      for x in badpositions:\\n        positions.insert(0, x)\\n  \\n      m = M\\n  \\n      while (m > 0):\\n        if len(positions) <= 0:\\n          return \"Impossible\"\\n  \\n        pos = positions.pop()\\n        (x,y) = pos\\n  \\n        if (board[y][x] != \".\"):\\n          return \"Impossible\"\\n  \\n        board[y][x] = '*'\\n        m = m - 1\\n  \\n      mines = sum([x.count('*') for x in board])\\n  \\n      if (mines != M):\\n        return \"Impossible\"\\n  \\n      if (blanks > 1):\\n        if (R > 1):\\n          if board[R - 2][C - 1] == \"*\":\\n            return \"Impossible\"\\n  \\n        if (C > 1):\\n          if board[R - 1][C - 2] == \"*\":\\n            return \"Impossible\"\\n  \\n        if (R > 1) and (C > 1):\\n          if board[R - 2][C - 2] == \"*\":\\n            return \"Impossible\"\\n  \\n      return self.boardToString(board)\\n  \\n  with Minesweeper_2014_QC(sys.argv[1]) as problem:\\n    problem.load()\\n  \\n    problem.run()\\n", "target": "2", "substitutes": {"self": ["s", "ng", "complete", "spec", "cl", "full", "rs", "tmp", "resp", "table", "q", "ls", "co", "shape", "sw", "output", "ae", "wrapper", "debug", "me", "console", "instance", "also", "w", "cert", "details", "network", "sh", "sub", "db", "e", "r", "client", "rec", "se", "close", "res", "sel", "print", "p", "h", "name", "author", "form", "eth", "asm", "dig", "input", "new", "ren", "n", "lex", "this", "py", "response", "time", "review", "ref", "context", "add", "nt", "reader", "github", "you", "final", "hw", "my", "Test", "python", "sys", "object", "compl", "subject", "np", "th", "ind", "public", "handle", "dev", "Self", "remote", "other", "local", "user", "app", "config", "make", "obj", "request", "rel", "pkg", "info", "params", "ws", "cmp", "error", "au", "your", "ins"], "inputFilename": ["basefilename", "imagefilename", "imageFilename", "baseFile", "outputFilename", "baseFilename", "inputSourceFile", "sourceFilename", "sourcefilename", " inputSourceFile", "sourceFiles", "outputFiles", "imageFile", "inputfilename", "imageSourceFile", "outputfilename", "outputFile", "InputSourceFile", " inputfilename", " inputFile", "baseSourceFile", "InputFile", "InputFilename", "inputFiles", "InputFiles", "Inputfilename", "inputFile", "sourceFile"], "T": ["V", "GT", "Test", "G", "P", "TB", "Time", "J", "TN", "t", "TG", "Y", "PT", "N", "O", "B", "TA", "D", "TT", "Length", "TV", "H", "K", "CT", "A", "I", "X", "E", "TS", "S", "WT", "NT", "TED", "L", "F", "TR", "Q", "TM", "VT", "Z", "TC", "Int", "TL"], "tests": ["tags", "times", "modules", "ests", "sections", "cases", "steps", "drivers", "types", "testers", "errors", "ctors", "runs", "lines", "items", "classes", "rules", "forms", "files", "suits", "groups", "lists", "results", "tested", "checks", "features", "units", "boxes", "tools", "issues", "strings", "codes", "rows", "reports", "values"], "i": ["ti", "int", "ini", "ic", "ico", "ind", "ie", "xi", "it", "n", "ix", "z", "e", "ior", "id", "r", "ir", "ai", "im", "ri", "I", "ex", "ip", "ci", "io"], "R": ["V", "RS", "G", "P", "RE", "Role", "Remote", "J", "ER", "COR", "RAM", "REM", "OR", "Reg", "Y", "Range", "Re", "RG", "N", "Right", "Rank", "O", "B", "MR", "RF", "GR", "D", "Type", "RA", "r", "BR", "H", "RC", "K", "SR", "RGB", "Row", "RM", "A", "Reader", "RT", "I", "RO", "X", "Reference", "E", "PR", "JR", "S", "RR", "DR", "NR", "L", "U", "Rot", "F", "CR", "IR", "Res", "TR", "Q", "RES", "Cor", "AR", "Random", "Z", "New"], "C": ["V", "CS", "G", "W", "CV", "CO", "Y", "CG", "c", "Control", "CF", "K", "JC", "CT", "E", "CA", "U", "CR", "CN", "Z", "Craig", "CI", "CC", "N", "MC", "B", "CB", "Ch", "CE", "CU", "I", "S", "F", "SC", "Cond", "CNN", "Cr", "CL", "D", "YC", "Cs", "H", "Cl", "CD", "OC", "CP", "Cache", "Cons", "Q", "CH", "VC", "AC", "P", "Chain", "IC", "COR", "Cos", "O", "Category", "CM", "CCC", "DC", "A", "X", "EC", "BC", "L", "From", "CON", "CW", "Co"], "M": ["V", "Mon", "G", "ME", "MAN", "P", "MT", "ML", "J", "Multi", "Y", "N", "Mc", "OM", "O", "MC", "B", "CM", "JM", "MN", "D", "Length", "H", "MP", "Ms", "MI", "K", "IM", "MO", "LM", "RM", "Maker", "A", "I", "Mode", "X", "E", "GM", "S", "OK", "Other", "Size", "L", "PM", "F", "Q", "TM", "MS", "MAX", "MM", "NM", "cm", "Z", "MA", "VM", "DM", "AM", "Manager"], "x": ["mx", "ax", "t", "yx", "l", "lat", "c", "k", "check", "zx", "wx", "v", "ctx", "a", "rx", "tx", "xxx", "sex", "w", "xt", "xml", "step", "index", "z", "e", "xb", "r", "el", "xx", "ick", "p", "exp", "h", "name", "xc", "xs", "on", "xe", "f", "at", "xi", "n", "xa", "fx", "lex", "xy", "id", "hex", "time", "o", "xf", "one", "act", "ex", "inx", "ch", "xd", "xp", "ix", "key", "px", "X", "dx", "xxxx", "ox", "rex", "ux", "item"], "board": ["layout", "length", "loop", "controller", "core", "comment", "Board", "bo", "mode", "boards", "word", "case", "rot", "wheel", "channel", "condition", "window", "clip", "buffer", "runner", "lock", "body", "rank", "system", "sequence", "control", "table", "room", "bank", "ro", "block", "ward", "back", "menu", "stream", "line", "frame", "chain", "reader", "background", "bit", "ack", "bug", "player", "list", "code", "deck", "error", "void", "box", "form", "bar"], "retval": ["reVAL", "altval", " retbal", " retvalue", "returnvals", "retVal", " retVAL", "RETvals", "RETVal", "retbal", " retvals", "reval", "Retbal", " Retbal", "RETVAL", "retvalue", "returnVal", "retVAL", "RetVAL", "RetVal", "RETeval", "retvals", "Retvals", "Reteval", "reteval", " Retval", " retVal", "returnvalue", "revals", "returnval", "alteval", "RETval", "Retval", "reeval", " reteval", "Retvalue", " RetVal", "altVAL", "altVal"], "row": ["loop", "ows", "bow", "pair", "tr", "word", "case", "rect", "wheel", "cell", "key", "order", "OW", "runner", "user", "table", "entry", "r", "box", "ro", "Row", "block", "arrow", "raw", "line", "field", "bug", "ow", "error", "roll", "feed", "col", "run", "rows", "item", "name", "instance", "record", "form", "bar"], "test": ["valid", "sample", "Test", "second", "result", "match", "loop", "est", "value", "message", "length", "master", "string", "ests", "fake", "input", "ester", "mode", "new", "t", "f", "case", "train", "it", "long", "key", "ctor", "correct", "txt", "mark", "sub", "py", "runner", "query", "unit", "check", "set", "iter", "write", "function", "example", "control", "call", "task", "instance", "block", "true", " Test", "bit", "te", "top", "old", "command", "foo", "node", "open", "select", "run", "script", "val", "mate", "execute", "section", "testing", "form"], "spaces": ["bspaps", "bspaces", "paces", "bspans", "bspanks", "Spans", "spans", "Spaces", "blaces", "spacing", "spanks", "Spanks", "Spacing", "pacing", "pans", "Spaps", " spaps", "blacing", " spans", " spanks", "spaps", "panks", "blans"], "blanks": ["spacks", "spances", "blances", " blands", "BLanks", " blaces", "illanks", " blacks", "blacks", "blaces", "spanks", "Blanks", "BLacks", "Blands", "blands", "illaces", "Blances", "illands", "BLances", "Blaces", "Blacks", "illacks", "BLaces"], "y": ["gy", "my", "ay", "sys", "iy", "ty", "hey", "ch", "ly", "ya", "ed", "hot", "t", "Y", "g", "yd", "l", "key", "yt", "c", "z", "yn", "ies", "py", "wy", "xy", "yy", "ny", "r", "ye", "b", "o", "ey", "uy", "by", "j", "story", "yr", "vy", "v", "ry", "sy", "er", "out", "cy", "yi", "you", "yer", "ym", "h", "yl"], "badpositions": ["badPosits", "badpositiveness", "badproables", "badtopitions", "badpoions", "badPOSitions", " badproits", " badposables", " badnegations", " badposations", " badnegitions", "badcondations", "badPOSions", "badPosions", "badposions", "badgenitions", "bugposations", "badposentials", "goodPosions", "badcondresses", "badPosations", "badgenitiveness", " badposions", " badproables", "disabledgenions", "badcompables", "badcompits", "disabledgenitions", " badposits", "badproitions", "badcompions", "badpoitions", "badPositiveness", "badposables", "badcompitions", "badpoments", "badPOSations", "badposresses", "badproions", "badconditions", "bugposions", "badnegations", "badPosables", "bugpositions", " badnegresses", "badpoations", "badnegions", " badproions", "badgenentials", "badPosments", "goodposations", "badcondments", "badPositions", "goodPositions", "badtransions", " badposresses", "goodposresses", "badtopresses", "badtopions", "bugcondions", "badtopations", "badgenions", "bugcondations", "bugposments", "goodposions", "badposations", "badposits", "badPosresses", "disabledgenitiveness", "goodPosresses", "disabledgenentials", "disabledposions", "badtransentials", "goodpositions", "disabledpositions", "badproits", "badcondions", "bugconditions", " badnegions", "disabledposentials", "bugcondments", "badposments", "badPOSresses", "badPosentials", "badtransitions", "goodPosations", "disabledpositiveness", "badnegitions", "badtransitiveness", "badnegresses", " badproitions"], "positions": ["condentials", "POSitions", "formions", "positors", " positors", "osentials", "positives", "condions", " posations", "positionations", "conditions", "Posations", "ositors", "posits", "POSations", "posions", "Posers", " posers", " posions", "conditors", "ositions", "ositives", "Posions", "condits", "POSions", "posentials", "Posits", " positives", "conditives", "positionions", " posentials", "posusters", "condusters", "formitors", "Positions", "formits", "condations", " posusters", "Posusters", "conders", "posers", "positionitions", "posations", "formitions", "Positors"], "m": ["sm", "bm", "ms", "t", "f", "g", "multi", "n", "mn", "l", "wm", "c", "tm", "mt", "mc", "mm", "man", "mu", "r", "im", "perm", "mi", "mut", "mr", "v", "dm", "mis", "gm", "cm", "p", "d", "fm"], "pos": ["os", "spec", "neg", "n", "comp", "POS", "respons", "mat", "lines", "loc", "tmp", "po", "options", "pro", "pres", "Pos", "trans", "ps", "cho", "cond", "diff", "dis", " Pos", "position", "positive", "nos", "fun"]}}
{"code": "\\n  \\n  lines = iter('''\\n  5\\n  30.0 1.0 2.0\\n  30.0 2.0 100.0\\n  30.50000 3.14159 1999.19990\\n  500.0 4.0 2000.0\\n  100.0 1.0 100000.0\\n  '''.splitlines(False)[1:])\\n  \\n  lines = iter(open(r'B-small-attempt0.in').readlines(False))\\n  \\n  caseCnt = int(next(lines))\\n  \\n  for case in range(1, caseCnt+1):\\n  \tC, F, X = map(float, next(lines).split())\\n  \t\\n  \tv = 2.0\\n  \ttotal = 0.0\\n  \tgoal = X/v\\n  \twhile 1:\\n  \t\tfarm = C/v + total\\n  \t\tif farm >= goal:\\n  \t\t\tanswer = goal\\n  \t\t\tbreak\\n  \t\tv += F\\n  \t\ttotal = farm\\n  \t\tif goal > X/v + total:\\n  \t\t\tgoal = X/v + total\t\\n  \tprint('Case #%d: %0.6lf'%(case, answer))\\n  \t\\n  \\n", "target": "3", "substitutes": {"lines": ["ids", "cs", "lets", "rates", "blocks", "cells", "ds", "ms", "headers", "names", "nets", "xs", "details", "steps", "cases", "inline", "l", "links", "fs", "items", "runs", "ns", "rs", "nl", "iter", "papers", "ls", "files", "photos", "gs", "los", "posts", "charges", "results", "vs", "line", "bs", "mails", "qs", "limits", "elines", "frames", "tests", "locks", "vals", "issues", "ines", "codes", "rows", "reads", "ins", "reports", "values", "points"], "caseCnt": ["caseWCnt", "caseNtx", "caseRnt", "CaseCNT", "caseWCtx", "CaseCpt", "caseNnt", "CaseCnt", "caseYCnt", "caseRrc", "caseCtx", "caseCpt", "caseNNT", "caseWCNT", "caseCNT", "caseRNT", "caseNrc", "caseYCrc", "caseWCrc", "caseCrc", "caseYCpt", "CaseCtx", "caseRpt", "CaseCrc", "caseYCNT"], "case": ["catch", "pe", "cases", "ance", "condition", "switch", "c", "test", "nce", "id", "version", "example", "client", "board", "su", "co", "CE", "time", "number", "se", "ce", "line", "cycle", "ASE", "ide", "count", "ase", "cor", "age", "bug", "force", "trial", "ca", "num", "cas", "me", "ace", "chance", "name", "instance", "Case"], "C": ["V", "CS", "CV", "P", "CNN", "CC", "CO", "Y", "N", "M", "FC", "B", "CM", "c", "D", "CF", "CB", "Cs", "H", "CE", "CT", "CU", "T", "A", "DC", "R", "E", "CP", "CA", "S", "BC", "L", "U", "CR", "Q", "VC", "Co", "Case"], "F": ["V", "G", "W", "P", "J", "FS", "f", "AF", "Y", "Total", "N", "M", "O", "B", "D", "CF", "FD", "IF", "Farm", "H", "Fi", "K", "DF", "T", "A", "UF", "I", "R", "E", "FO", "S", "L", "U", "FP", "Q", "SF", "HF", "PF", "FF", "FA", "If", "FE"], "X": ["V", "G", "W", "P", "XXX", "CV", "J", "TX", "FX", "Y", "N", "M", "EX", "B", "D", "CF", "XL", "H", "IX", "XX", "T", "DX", "I", "R", "E", "S", "L", "x", "U", "UX", "XP", "Q", "OX", "MX", "Z", "ZX", "FF", "Ex", "FE"], "v": ["V", "av", "value", "sv", "CV", "y", "u", "w", "t", "cv", "f", "m", "g", "n", "tv", "l", "c", "z", "vote", "GV", "function", "vert", "version", "uv", "ve", "vt", "lv", "r", "q", "response", "vc", "b", "mint", "j", "vs", "ver", "vu", "qv", "x", "vp", "conv", "van", "p", "d", "a", "h", "rev", "i", "vm"], "total": ["valid", "paid", "length", "neutral", "value", "result", "free", "complete", "comment", "size", "bet", "t", "equal", "f", "Total", "database", "dev", "base", "done", "step", "gross", "general", "vote", "full", "other", "unit", "root", "real", "zero", "fa", "normal", "left", "no", "number", "money", "ter", "wall", "start", "otal", "unknown", "counter", "percent", "completely", "net", "count", "random", "human", "page", "error", "available", "scale", "sum", "next", "type", "all", "latest", "final", "parent", "stop", "summary", "tax"], "goal": ["V", "duration", "wait", "neutral", "result", "termination", "value", "CV", "gain", "comment", "cf", "front", "bet", "equal", "cv", "f", "fac", "dev", "database", "cost", "VA", "condition", "profile", "target", "capacity", "switch", "test", "hunt", "general", "vote", "status", "door", "team", "uno", "version", "event", "alias", "category", "loss", "zero", "term", "foreign", "wall", "alf", "cpu", "venture", "field", "percent", "cheat", "efficiency", "success", "campaign", "bolt", "hat", "jump", "scale", "limit", "favorite", "end", "exp", "final", "chance", "Goal", "forward", "avored"], "farm": ["paid", "result", "fortune", "fax", "fake", "front", "animal", "pac", "feature", "f", "fac", "dev", "train", "test", "hunt", "store", "root", "aff", "fork", "Farm", "bank", "callback", "sav", "product", "care", "kill", "fen", "foreign", "profit", "field", "cpu", "plan", " Farm", "force", "efficiency", "computer", "biased", "jump", "p", "job", "chance", "fleet", "transform", "stop", "setup", "forward", "wait", "attack"], "answer": ["Answer", "duration", "result", "value", "front", "bet", "accept", "test", "switch", "order", "rn", "vote", "option", "sen", "vert", "version", "response", "ve", "alias", "aff", "bank", "entry", "wer", "fa", "number", "term", "account", "request", "answered", "offer", "ver", "advert", "question", "agent", "turn", "van", "issue", "next", "chance", "forward"]}}
{"code": "\\n  lines = iter('''\\n  13\\n  5 5 23\\n  3 1 1\\n  1 3 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  10 1 4\\n  1 10 5\\n  2 10 8\\n  10 2 8\\n  2 10 9\\n  10 2 7\\n  5 3 3\\n  '''.splitlines(False)[1:])\\n  out = sys.stdout\\n  \\n  sys.setrecursionlimit(1500)\\n  \\n  \\n  class MyException(Exception):\\n  \tpass\\n  lines = iter(open(r'C-small-attempt7.in').readlines(False))\\n  out = open('c-small.answer', 'w')\\n  \\n  def solve(C, R, M):\\n  \tboard = [['.']*C for _ in range(R)]\\n  \tboard[-1][-1] = 'c'\\n  \ttry:\\n  \t\tfor r in range(R-2):\\n  \t\t\tfor c in range(C-2):\\n  \t\t\t\tif r == R-3 and c == C-3:\\n  \t\t\t\t\traise StopIteration()\\n  \t\t\t\tboard[r][c] = '*'\\n  \t\t\t\tM -= 1\\n  \t\t\t\tif M == 0:\\n  \t\t\t\t\treturn board \\n  \texcept StopIteration:\\n  \t\tpass\\n  \t\t\\n  \tif M % 2 == 0:\\n  \t\tfor r in range(R-3):\\n  \t\t\tboard[r][C-1] = '*'\\n  \t\t\tboard[r][C-2] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\tfor c in range(C-3):\\n  \t\t\tboard[R-1][c] = '*'\\n  \t\t\tboard[R-2][c] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\t\\n  \t\t\\n  \t\traise MyException()\\n  \telse:\\n  \t\tboard[R-3][C-3] = '*'\\n  \t\tM -= 1\\n  \t\tif M == 0:\\n  \t\t\treturn board\\n  \t\tfor r in range(R-2):\\n  \t\t\tboard[r][C-1] = '*'\\n  \t\t\tboard[r][C-2] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\tfor c in range(C-2):\\n  \t\t\tboard[R-1][c] = '*'\\n  \t\t\tboard[R-2][c] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\t\\n  \t\traise MyException()\\n  \t\t\\n  \t\\n  caseCnt = int(next(lines))\\n  \\n  for case in range(1, caseCnt+1):\\n  \tR,C,M = map(int, next(lines).split())\\n  \t\\n  \tprint('Case #%d:'%case, file=out)\\n  \tif M == 0:\\n  \t\tprint('c' + '.'*(C-1), file=out)\\n  \t\tfor _ in range(R-1):\\n  \t\t\tprint('.'*C, file=out)\\n  \telif R*C==M+1:\\n  \t\tprint('c' + '*'*(C-1), file=out)\\n  \t\tfor _ in range(R-1):\\n  \t\t\tprint('*'*C, file=out)\\n  \telif C == 1 and R == 1:\\n  \t\tprint('Impossible', file=out)\\n  \telif C == 1:\\n  \t\tif M > R-1:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c', file=out)\\n  \t\t\tfor _ in range(R-M-1):\\n  \t\t\t\tprint('.', file=out)\\n  \t\t\tfor _ in range(M):\\n  \t\t\t\tprint('*', file=out)\\n  \telif R == 1:\\n  \t\tif M > C-1:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c' + '.'*(C-M-1) + '*'*M, file=out)\\n  \telif C == 2:\\n  \t\tif M %2 or M//2 > R-2:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c.', file=out)\\n  \t\t\tfor _ in range(R-M//2-1):\\n  \t\t\t\tprint('..', file=out)\\n  \t\t\tfor _ in range(M//2):\\n  \t\t\t\tprint('**', file=out)\\n  \telif R == 2:\\n  \t\tif M %2 or M//2 > C-2:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)\\n  \t\t\tprint(      '.'*(C-M//2)   + '*'*(M//2), file=out)\\n  \telif M > R*C-4:\\n  \t\tprint('Impossible', file=out)\\n  \telse:\\n  \t\ttry:\\n  \t\t\tboard = solve(C, R, M)\\n  \t\t\tfor line in board:\\n  \t\t\t\tprint(''.join(line), file=out)\\n  \t\texcept MyException:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\\n  \t\\n", "target": "3", "substitutes": {"lines": ["cs", "s", "blocks", "cells", "ds", "sections", "headers", "cycles", "xs", "nets", "comments", "details", "boards", "steps", "cases", "inline", "breaks", "l", "ors", "links", "ings", "errors", "its", "items", "eds", "runs", "rs", "bytes", "iter", "ls", "files", "los", "groups", "lists", "posts", "es", "words", "results", "vs", "parts", "bs", "rings", "bits", "qs", "limits", "elines", "frames", "objects", "ln", "tests", "vals", "strings", "issues", "lins", "ines", "codes", "rows", "ens", "ins", "err", "ers", "lo", "values", "points"], "out": ["os", "result", "conf", "sys", "file", "OUT", "ch", "w", "t", "n", "can", "pool", "txt", "status", "tmp", "pos", "client", "gt", "co", "o", "bin", "obj", "Out", "outs", "nt", "cache", "res", "output", "v", "net", "col", "p", "io", "name", "ot"], "C": ["V", "AC", "CS", "G", "W", "P", "Chain", "CV", "CI", "cr", "IC", "COR", "CC", "Cr", "CO", "Y", "CG", "N", "Mc", "O", "CL", "MC", "HC", "B", "CM", "Count", "D", "CB", "CF", "Cs", "Ch", "H", "K", "LC", "JC", "CT", "Current", "RC", "CE", "T", "DC", "A", "CU", "Cl", "CD", "I", "X", "E", "CP", "EC", "CA", "S", "BC", "L", "F", "U", "CR", "CON", "Q", "Cor", "Change", "VC", "Col", "TC", "Co", "Craig", "SC"], "R": ["V", "G", "W", "RE", "Y", "Re", "Rs", "Reader", "PR", "E", "JR", "Runner", "RR", "U", "RW", "CR", "IR", "Rec", "Red", "RS", "ER", "RG", "N", "B", "Ch", "RA", "BR", "SR", "RGB", "I", "RO", "S", "DR", "F", "Rot", "AR", "Result", "Remote", "OR", "Reg", "Repl", "Right", "D", "H", "RC", "RM", "Row", "Cl", "RT", "VR", "Q", "HR", "RP", "Ren", "P", "Chain", "COR", "RB", "Range", "O", "MR", "RL", "RH", "Review", "T", "A", "X", "NR", "L", "Res", "TR"], "M": ["V", "Mon", "ME", "G", "MAN", "W", "P", "MT", "Mouse", "J", "MER", "Y", "m", "N", "Mc", "OM", "O", "MC", "MF", "B", "CM", "MR", "JM", "MN", "D", "H", "MP", "MI", "Mom", "IM", "LM", "Me", "RM", "T", "Maker", "Message", "I", "E", "EM", "MAT", "S", "L", "F", "PM", "Mer", "FM", "Q", "TM", "MS", "MX", "MM", "NM", "MA", "DM", "AM"], "board": ["stri", "lib", "du", "copy", "uno", "black", "table", "bird", "co", "zero", "fc", "batch", "ward", "ault", "bard", "cross", "bit", "bug", "link", "foot", "bar", "builder", "book", "loop", " dashboard", "core", "comment", "bench", "database", "design", "ac", "buffer", "fine", "function", "boat", "client", "bro", "clean", "oard", "dict", "planet", "style", "cod", "list", "form", "bot", "bo", "stone", "dam", "base", "body", "flo", "bank", "student", "past", "ro", "back", "reader", "cat", "library", "box", "lo", "hall", "layout", "Board", "pair", "lay", "boards", "rot", "pad", "long", "vote", "runner", "lock", "door", "local", "system", "plate", "rank", "control", "bd", "block", "land", "template", "chain", "ack", "player", "boarding", "old", "code", "deck", "row", " boards"], "_": ["int", "mult", "m", "n", "ac", "con", "co", "time", "ml", "ver", "ox", "x", "pc", "code", "un", "val", "p", "all", "ct", "a", "name"], "r": ["hr", "range", "adr", "rr", "rt", "cr", "dr", "w", "t", "f", "m", "g", "ren", "err", "n", "it", "l", "nr", "rd", "h", "rn", "rm", "sr", "e", "rs", "k", "re", "q", "ir", "b", "ro", "kr", "br", "ar", "o", "ra", "pr", "rec", "rc", "rh", "rel", "j", "res", "yr", "mr", "RR", "reg", "v", "usr", "x", "er", "right", "fr", "row", "vr", "p", "d", "rar", "a", "all", "rb", "run", "i"], "c": ["cs", "cr", "cp", "cont", "tc", "uc", "ch", "ic", "w", "t", "f", "m", "cin", "g", "n", "l", "can", "cl", "ac", "con", "arc", "mc", "e", "k", "ec", "dc", "co", "lc", "category", "b", "fc", "unc", "cur", "o", "bc", "rec", "ce", "rc", "cache", "sc", "cycle", "chain", "cor", "v", "cu", "x", "ca", "pc", "cb", "col", "cm", "p", "cut", "d", "a", "ct", "h", "xc", "ci", "i", "cc"], "caseCnt": ["caseCct", " caseNct", "casecct", "CaseCNT", " caseCct", "casecNT", "caseNnt", "caseYnt", " caseCNT", "CaseCnt", "caseYNT", " caseNount", "caseCCount", " caseCount", "caseCount", " caseNnt", "casecount", "casecCount", "CaseCCount", "casecnt", "caseNNT", "CaseCst", "caseCNT", " caseNNT", "caseNount", "casecst", "caseNct", "caseYCount", "caseCst", "caseYst"], "case": ["result", "match", "hyp", "catch", "first", "pair", "cases", "condition", "key", "test", "sub", "client", "change", "block", "ce", "close", "cycle", "chain", "count", "ase", "code", "cas", "row", "ace", "section", "name", "Case"]}}
{"code": "\\n  T = int(raw_input())\\n  for test_case in xrange(1, T + 1):\\n      C, F, X = map(float, raw_input().split())\\n      answer = X / 2\\n      i = 0\\n      last_tc = 0\\n      while True:\\n          tc = last_tc + C / (2 + (i * F))\\n          if answer < tc:\\n              break\\n          answer = min(tc + X / (2 + (i + 1) * F), answer)\\n  \\n          i += 1\\n          last_tc = tc\\n      print 'Case #{}: {:.7f}'.format(test_case, answer)\\n", "target": "4", "substitutes": {"T": ["V", "G", "W", "P", "TB", "J", "Time", "TN", "t", "Y", "N", "M", "O", "B", "TA", "D", "TT", "TV", "Type", "H", "K", "I", "R", "E", "TS", "S", "L", "Q", "TR", "TM", "TO", "Z", "TC"], "test_case": ["testtesttest", "testcaseset", " test_Case", " test_switch", "test_set", "testtestcase", "test_test", "test_pair", " testcasecase", "testcasepair", " test_test", " test_set", "test_switch", "test_Case", " testcaseset", " test_pair", "testtestCase", "testtestswitch", "testcasecase", " testcasepair"], "C": ["V", "CS", "G", "CI", "P", "CC", "CO", "Y", "N", "M", "FC", "MC", "B", "CM", "c", "D", "CF", "CB", "Cs", "CE", "JC", "CT", "A", "I", "R", "EC", "CP", "CA", "S", "L", "Custom", "U", "CR", "Q", "TC", "Co"], "F": ["V", "G", "W", "P", "FU", "FT", "J", "GF", "FER", "Fs", "f", "AF", "N", "M", "FC", "FI", "B", "RF", "TF", "D", "CF", "FL", "FD", "IF", "H", "DF", "UF", "I", "E", "FO", "FG", "L", "FP", "Q", "SF", "PF", "FF", "FK", "FE"], "X": ["V", "Answer", "G", "W", "P", "TX", "Y", "XM", "N", "M", "FC", "EX", "CF", "H", "TY", "CE", "CT", "IX", "XX", "A", "DX", "I", "R", "E", "S", "L", "x", "U", "UX", "XP", "Q", "XT", "TC", "OX", "FF", "MX", "Z", "XXX", "Ex", "ICE"], "answer": ["Answer", "choice", "result", "value", "message", "match", "say", "address", "item", "expression", "accept", "word", "case", " unanswered", "notice", "ix", "index", "text", "test", "window", "vote", "option", "status", "uit", "e", "uno", "response", "energy", "example", "ve", "sequence", "entry", "q", "wer", "zero", "see", "term", "swers", "section", "video", "answered", "close", "double", "description", "ver", "remember", "v", "after", "question", "x", "random", "ox", "equ", "ever", "ice", "command", "replace", "image", "issue", "end", "me", "au", "average", "next", "err", "name", "record", "score"], "i": ["ori", "ti", "int", "ini", "ic", "cli", "ind", "t", "pi", "li", "f", "xi", "multi", "it", "n", "ix", "index", "l", "c", "bi", "zi", "id", "ij", "iu", "iter", "hi", "ai", "phi", "im", "I", "si", "mi", "ui", "qi", "v", "di", "gi", "ip", "ii", "ci", "ei", "oi"], "last_tc": ["Last_com", "last_tmp", "last_cu", "last_cs", " last_cs", " last_uc", "Last_tc", "full_tim", "full_cu", "last_uc", "last_com", "Last_tmp", "last_tim", "full_tc", "last_TC", "full_cs", "Last_TC", " last_TC"], "tc": ["cs", "timer", "result", "cp", "last", "ta", "timeout", "ic", "cf", "tf", "t", "cv", "tk", "com", "test", "c", "cc", "ac", "tm", "ec", "mc", "tmp", "dc", "cus", "co", "lc", "tt", "toc", "tu", "fc", "unc", "time", "bc", "term", "tty", "temp", "rc", "sc", "ts", "cu", "cum", "tic", "cmp", "pc", "cas", "tim", "ctx", "cm", "ct", "tz", "TC", "tx", "td"]}}
{"code": "\\n  T = int(raw_input())\\n  for test_case in xrange(1, T + 1):\\n      R, C, M = map(int, raw_input().split())\\n      N = R * C\\n      B = N - M\\n  \\n      W, H = (C, R) if R <= C else (R, C)\\n  \\n      if H == 1:\\n          answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]\\n      elif M == N - 1:\\n          answer = [['*'] * W for r in xrange(H)]\\n          answer[0][0] = 'c'\\n      elif B < 4 or B in (5, 7):\\n          answer = None\\n      elif H == 2:\\n          if M % 2 == 0:\\n              bw = B / 2\\n              answer = [\\n                  ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),\\n                  ['.'] * bw + ['*'] * (W - bw),\\n              ]\\n          else:\\n              answer = None\\n      else:\\n          answer = [['*'] * W for y in xrange(H)]\\n          answer[0][0] = 'c'\\n          answer[0][1] = answer[1][0] = answer[1][1] = '.'\\n          left = B - 4\\n          if 2 <= left:\\n              answer[0][2] = answer[1][2] = '.'\\n              left -= 2\\n          if 2 <= left:\\n              answer[2][0] = answer[2][1] = '.'\\n              left -= 2\\n  \\n          x = y = 3\\n          while (x < W or y < H) and 2 <= left:\\n              if x < W and 2 <= left:\\n                  answer[0][x] = answer[1][x] = '.'\\n                  left -= 2\\n                  x += 1\\n              if y < H and 2 <= left:\\n                  answer[y][0] = answer[y][1] = '.'\\n                  left -= 2\\n                  y += 1\\n  \\n          y = 2\\n          while 0 < left and y < H:\\n              x = 2\\n              while 0 < left and x < W:\\n                  answer[y][x] = '.'\\n                  left -= 1\\n                  x += 1\\n              y += 1\\n  \\n      if answer is None:\\n          answer = 'Impossible'\\n      else:\\n          if W == R:\\n              answer = map(list, zip(*answer))\\n          assert len(answer) == R\\n          assert len(answer[0]) == C\\n          assert sum(row.count('*') for row in answer) == M\\n          answer = '\\n'.join([''.join(row) for row in answer])\\n      print 'Case #{}:\\n{}'.format(test_case, answer)\\n", "target": "4", "substitutes": {"T": ["V", "G", "P", "TB", "J", "TN", "t", "Y", "O", "D", "TT", "K", "A", "I", "X", "E", "TS", "S", "NT", "WT", "L", "F", "TH", "Q", "TM", "Z", "TC"], "test_case": ["test_x", "test_test", " test_c", " test_test", "test_c", " test_x"], "R": ["V", "RS", "G", "P", "ER", "RE", "J", "Y", "MR", "RF", "Rs", "D", "RA", "BR", "RC", "RM", "A", "RT", "I", "RO", "X", "E", "S", "RR", "NR", "L", "F", "CR", "Res", "TR", "Q"], "C": ["V", "CS", "G", "P", "CC", "CO", "Y", "O", "MC", "HC", "c", "CM", "D", "CB", "Cs", "K", "CT", "CU", "A", "I", "X", "E", "CP", "S", "L", "F", "U", "CR", "Q", "CH", "CW", "WC"], "M": ["V", "ME", "G", "MAN", "P", "MT", "J", "Y", "m", "O", "MC", "CM", "MR", "MN", "D", "MP", "K", "MI", "MD", "RM", "A", "BM", "I", "X", "E", "S", "L", "F", "FM", "Q", "TM", "MS", "MM", "NM", "MA", "AM"], "N": ["V", "Ns", "G", "P", "NB", "J", "TN", "NA", "Y", "n", "O", "Ni", "SN", "NS", "D", "Num", "K", "A", "NN", "I", "X", "E", "S", "NC", "NT", "NR", "L", "F", "CR", "AN", "Q", "NM", "CN", "Z"], "B": ["V", "wb", "G", "P", "TB", "WB", "Th", "J", "NB", "Bs", "Bl", "Y", "O", "DB", "BB", "Fl", "D", "IB", "CB", "Comb", "Ch", "AB", "BR", "K", "b", "GB", "Cl", "A", "BM", "I", "Sp", "E", "SB", "S", "BC", "bl", "L", "F", "Be", "Q", "Rat", "Z", "Tw", "BT", "BW", "If"], "W": ["V", "WA", "G", "Widget", "P", "WB", "SW", "WP", "J", "WR", "WW", "w", "Y", "West", "EW", "O", "NW", "Win", "D", "HT", "Word", "WH", "K", "We", "TW", "WS", "A", "Wh", "I", "DW", "X", "E", "S", "WT", "Width", "L", "VW", "F", "RW", " w", "U", "Q", "CW", "MW", "Z", "WC", "BW"], "H": ["V", "G", "P", "J", "HH", "MH", "Y", "He", "O", "HC", "OH", "HO", "HB", "D", "HT", "HTTP", "HE", "RH", "K", "HS", "A", "I", "HA", "X", "E", "HI", "S", "GH", "High", "L", "F", "TH", "HL", "Q", "CH", "HR", "IT", "h"], "answer": ["interpret", "poll", "address", "case", "order", "write", "query", "store", "reply", "energy", "swers", "answered", "output", "either", "attribute", "consider", "exit", "era", "ion", "expression", "second", "say", "do", "accept", "quest", "ve", "call", "entry", "wer", "said", "term", "about", "offer", "prefix", "storage", "question", "env", "list", "position", "take", "iterator", "array", "come", "rage", "section", "eni", "record", "form", "Answer", "seat", "message", " Answer", "two", "rue", "urn", "search", "again", "place", "option", "hang", "response", "get", "delete", "review", "video", "remember", "environment", "one", "you", "any", "image", "next", "release", "my", "result", "value", "many", "archive", "leave", "phrase", "echo", "memory", "test", "ask", "vote", "version", "sequence", "example", "see", "request", "space", "cache", "description", "bridge", "aq", "rep", "equ", "player", "issue", "install", "mate", "ee", "queue"], "r": ["hr", "rr", "rt", "cr", "ru", "rd", "rn", "rm", "rs", "rew", "re", "ir", "q", "ro", "ra", "ar", "red", "ri", "pr", "rel", "rc", "ry", "er", "rw", "run", "rb", "rx"], "bw": ["abwp", "lh", "bwin", "yw", "hw", "yh", "lws", "lwd", "bwp", " bwt", "bsw", "lW", " bk", "bkw", "Bsw", "abwt", "bwd", "hws", "bbw", "lwin", "Bwt", " bwh", "wW", "bk", "bW", "bwh", "lw", "gw", "bwt", "Bwin", "bbwin", "abw", "gwp", "hwd", " bsw", "bh", "lwt", "bbwt", "wk", " bwp", "gwt", "yws", " bW", "bbwh", "Bwh", "bbk", "ww", "wwt", "ywd", "gkw", "Bw", "abkw", "bbW", "hh", "bws", " bkw", "BW", "bbsw"], "y": ["s", "ay", "iy", "ys", "t", "Y", "l", "c", "ies", "yy", "ny", "q", "ye", "b", "uy", "j", "yr", "v", "cy", "yi", "type", "iny", "a", "dy", "ty", "to", "hot", "w", "ya", "oy", "ie", "yd", "index", "z", "wy", "e", "axy", "vy", "out", "p", "h", "yl", "gy", "ly", "on", "m", "n", "yt", "py", "xy", "o", "by", "ry", "any", "d", "i", "my", "ch", "yes", "key", "yn", "ey", "ox", "sy", "ady", "fy", "yer", "ym", "yo"], "left": ["small", "only", "l", "full", "down", "Left", "path", " Left", "low", "top", "right", "lic", "bottom", "lt", "exit", "loop", "cont", "w", "st", "li", "shell", "none", "function", "center", "entry", "min", "join", "out", "list", "h", "ll", "length", "minimum", "sp", "wrong", "Right", "this", "where", "time", "no", "used", "scroll", "LE", "ex", "hit", "well", "open", "limit", "lower", "le", "pos", "lo", "locked", "value", "tree", "php", "front", "xp", "long", "high", "width", "text", "lock", "local", "format", "inner", "joined", "localhost", "L", "str", "flex", "old", "error", "level", "all"], "x": ["title", "int", "xxx", "ax", "item", "w", "xt", "on", "t", "xd", "g", "xs", "xe", "yx", "xi", "xp", "n", "nz", "width", "l", "ix", "xa", "key", "lat", "step", "c", "ext", "index", "z", "lex", "m", "name", "e", "xy", "rx", "id", "el", "time", "b", "px", "o", "no", "ey", "point", "j", "X", "true", "xx", "min", "dx", "wx", "v", "xxxx", "ox", "ex", "inx", "ick", "d", "p", "a", "exp", "h", "xc", "i", "tx"]}}
{"code": "\\n  def read_line():\\n      return sys.stdin.readline().rstrip( '\\n' )\\n  \\n  def read_integer():\\n      return int( read_line() )\\n  \\n  def read_float():\\n      return float( read_line() )\\n  \\n  def read_floats():\\n      return [ float( x ) for x in read_line().split() ]\\n  \\n  T = read_integer()\\n  for t in range( T ):\\n      C, F, X = read_floats()\\n      rate = 2\\n      cookies = 0\\n      s = 0\\n      while True:\\n          t1 = X/rate\\n          t2 = C/rate + X/( rate + F )\\n          if t1 < t2:\\n              s += t1\\n              break\\n          s += C/rate\\n          rate += F\\n      print 'Case #%i: %.7f' % ( t + 1, s )\\n", "target": "5", "substitutes": {"x": ["mx", "php", "ax", "y", "xs", "xt", "xe", "xd", "xxxxxxxx", "xi", "xp", "ix", "fx", "lex", "c", "z", "xy", "xb", "xes", "px", "ey", "xf", "rax", "xx", "dx", "wx", "xxxx", "ox", "ex", "ctx", "ux", "tx", "xc", "i", "rx"], "T": ["V", "GT", "G", "P", "TB", "J", "TN", "Y", "N", "M", "O", "B", "TA", "D", "TT", "H", "K", "I", "R", "E", "TS", "S", "WT", "NT", "L", "Q", "TR", "TM", "Z", "TC", "OT"], "t": ["ti", "ty", "ta", "to", "y", "w", "let", "at", "f", "m", "g", "n", "l", "total", "c", "z", "tp", "e", "k", "q", "r", "tt", "b", "tu", "j", "v", "ts", "te", "num", "dt", "type", "p", "d", "ct", "a", "tick", "h", "i", "ot"], "C": ["V", "CS", "G", "CV", "P", "CI", "CNN", "CC", "CO", "Y", "N", "M", "MC", "B", "c", "CM", "D", "CF", "CB", "Cs", "H", "CT", "CU", "A", "I", "R", "E", "CP", "S", "L", "U", "CR", "Q", "TC", "Co"], "F": ["V", "G", "W", "P", "GF", "FR", "Fs", "f", "AF", "Y", "N", "M", "FC", "Float", "FB", "O", "B", "TF", "D", "CF", "FL", "FD", "IF", "H", "K", "DF", "A", "UF", "I", "R", "E", "FO", "S", "FG", "L", "U", "FP", "FM", "Q", "Z", "PF", "FF", "FA", "FE"], "X": ["V", "Tx", "W", "P", "Time", "TX", "Y", "XM", "N", "O", "EX", "D", "CF", "XL", "H", "IX", "XX", "DX", "I", "R", "E", "S", "U", "L", "Rate", "XP", "Q", "XT", "OX", "Z", "ZX", "XXX", "Ex", "Int", "FE"], "rate": ["duration", "length", "fps", "sample", "power", "rates", "times", "ate", "gain", "rice", "core", "domain", "timeout", "frequency", "mode", "prime", "f", "fee", "m", "g", "rot", "base", "n", "step", "capacity", "float", "test", "rand", "c", "status", "function", "TIME", "re", "sequence", "control", "r", "state", "ride", "time", "tt", "rule", "counter", "cycle", "rss", "ts", "count", "process", "device", "force", "Rate", "te", "erate", "race", "command", "code", "error", "speed", "trace", "scale", "delay", "type", "driver", "p", "d"], "cookies": ["posies", "cookries", "emptiers", "cookiers", "posences", "threadies", "emptences", "cookences", "threadiers", "empties", "threadences", "posries", "threadries", "emptries", "posiers"], "s": ["cs", "fps", "os", "second", "sv", "rates", "times", "ms", "ds", "stats", "y", "w", "f", "g", "m", "n", "ates", "c", "fs", "its", "z", "ies", "status", "e", "rs", "r", "ss", "state", "time", "b", "ps", "o", "ats", "es", "se", "j", "S", "v", "ts", "sb", "sum", "p", "d", "reads", "a", "seconds", "flags", "i"], "t1": ["e2", "T2", " t0", "T0", "p0", " tPart", "tone", "e1", "time0", "TPart", " tone", "t001", "tt2", "time001", "time1", "T001", "T1", "ttPart", "ttone", " t001", "Tone", "p1", "p2", "e0", "tt1", "tPart", "time2", "t0"], "t2": ["n02", " tbis", "T2", " T02", "dttwo", " Tbis", "nbis", "T02", "tbis", " T1", "n2", "Ttwo", "n1", "T1", " t02", " T2", "dt02", " ttwo", "dt2", "t02", "dt1", "ttwo"]}}
{"code": "\\n  def read_line():\\n      return sys.stdin.readline().rstrip( '\\n' )\\n  \\n  def read_integer():\\n      return int( read_line() )\\n  \\n  def read_integers():\\n      return [ int( x ) for x in read_line().split() ]\\n  \\n  def flip( grid ):\\n      return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]\\n  \\n  def grow( R, C, M ):\\n      grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]\\n      b = R*C - M\\n      if C > R:\\n          R, C, grid = C, R, flip( grid )\\n          flipped = True\\n      else:\\n          flipped = False\\n      if b < 2*C:\\n          if b == 1:\\n              grid[ 0 ][ 0 ] = 'c'\\n          elif b == 3 and C >= 3:\\n              grid[ 0 ][ : 3 ] = bytearray( '.c.' )\\n          elif b % 2:\\n              return\\n          else:\\n              grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\\n              grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\\n              grid[ 0 ][ 0 ] = 'c'\\n      else:\\n          r = 0\\n          while b >= C:\\n              grid[ r ] = bytearray( C*[ '.' ] )\\n              b -= C\\n              r += 1\\n          if b:\\n              if b >= 2:\\n                  grid[ r ][ : b ] = b*'.'\\n              elif C > 2 and r > 2:\\n                  grid[ r - 1 ][ -1 ] = '*'\\n                  grid[ r ][ : 2 ] = '..'\\n              else:\\n                  return\\n          grid[ 0 ][ 0 ] = 'c'\\n      return flip( grid ) if flipped else grid\\n      \\n  T = read_integer()\\n  for t in range( T ):\\n      print 'Case #%i:' % ( t + 1 )\\n      R, C, M = read_integers()\\n      grid = grow( R, C, M )\\n      print '\\n'.join( str( row ) for row in grid ) if grid else 'Impossible'\\n", "target": "5", "substitutes": {"x": ["mx", "ax", "y", "xs", "xt", "xe", "xd", "xxxxxxxx", "yx", "xi", "xp", "ix", "xa", "fx", "xy", "xb", "xes", "px", "ey", "xf", "zx", "X", "xx", "dx", "wx", "xxxx", "ox", "ex", "ctx", "ux", "tx", "xc", "i", "rx"], "grid": ["G", "gb", "card", "cli", "ed", "stack", "tr", "g", "case", "multi", "cell", "lat", "c", "addr", "query", "adj", "table", "q", "zero", "gru", "modified", "start", "reg", "net", "age", "hold", "fixed", "CR", "wrapper", "debug", "coord", "cut", "ma", "ge", "bar", "range", "gain", "Grid", "stock", "network", "gate", "windows", "window", "cart", "fine", "db", "util", "function", "iter", "gray", "raid", "client", "default", "mA", "mg", "res", "prefix", "storage", "device", "out", "list", "bag", "filter", "grain", "gm", "ace", "h", "form", "func", "domain", "cells", "rid", "new", "f", "m", "ga", "switch", "dim", "rm", "GR", "car", "map", "id", "module", "back", "mod", "ordan", "mr", "scroll", "Q", "tif", "rain", "next", "final", "box", "data", "sys", "cgi", "gr", "file", "work", "lay", "band", "dq", "gc", "CM", "mat", "MR", "remote", "way", "test", "when", "local", "set", "manager", "rank", "config", "sequence", "pipe", "jac", "lag", "group", "lc", "secure", "bin", "cache", "line", "chain", "bridge", "wire", "good", "er", "grow", "old", "tile", "node", "cm", "graph", "MA", "queue"], "row": ["range", "length", "may", "month", "to", "th", "w", "tr", "word", "week", "rot", "rect", "cell", "key", "index", "order", "name", "user", "e", "rs", "con", "id", "re", "entry", "board", "co", "ro", "Row", "batch", "arrow", "block", "ward", "sw", "line", "ox", "rown", "ow", "roll", "char", "col", "run", "rows", "round", "item", "pos", "lo", "record"], "column": ["length", "value", "w", "csv", "current", "Column", "cell", "width", "channel", "key", "index", "header", "c", "con", "table", "entry", "group", "block", "pointer", "arrow", "left", "number", "variable", "umn", "line", "field", "character", "chain", "scroll", "top", "rown", "position", "node", "right", "char", "col", "rain", "cut", "height", "day", "item", "td"], "R": ["V", "RS", "G", "RE", "P", "ER", "Grid", "Y", "RG", "N", "Right", "B", "MR", "GR", "Rs", "D", "RL", "RA", "H", "RH", "SR", "Row", "RM", "A", "RT", "I", "RO", "X", "RI", "S", "RR", "DR", "NR", "L", "U", "CR", "Mr", "Res", "TR", "Q", "AR"], "C": ["V", "CS", "G", "CI", "P", "W", "CNN", "COR", "CC", "Cr", "CO", "Y", "CAR", "CG", "N", "CL", "O", "Count", "MC", "B", "c", "CM", "D", "CB", "YC", "Cs", "Ch", "H", "K", "CCC", "JC", "CT", "DC", "CU", "A", "Cl", "I", "X", "EC", "CP", "E", "CA", "S", "L", "F", "CBS", "U", "CR", "CON", "Q", "CH", "VC", "Z", "One", "WC", "Co"], "M": ["V", "G", "MAN", "W", "P", "MT", "J", "Y", "m", "N", "O", "Mc", "MC", "B", "CM", "MR", "MN", "D", "H", "Ms", "MI", "RM", "A", "I", "X", "E", "EM", "S", "L", "F", "U", "My", "Q", "TM", "MS", "MM", "Z", "DM"], "b": ["wb", "nb", "bt", "gb", "to", "y", "u", "w", "bu", "on", "f", "g", "m", "bound", "base", "bb", "n", "it", "l", "B", "c", "bf", "h", "bi", "z", "fb", "ab", "db", "body", "bp", "br", "batch", "o", "bc", "bin", "back", "j", "bs", "lb", "bit", "v", "ib", " B", "sb", "ba", "cb", "eb", "p", "d", "erb", "a", "rb", "i", "be"], "flipped": [" fliped", "Flipped", "fliped", "slipping", " flip", "slipper", "Flip", "FLipper", "fipping", " flipper", "FLip", "fipper", "sliped", "FLipped", "slip", "flip", "Flipper", "fiped", "FLipping", "flipping", "slipped", "Flipping", "flipper", "fipped", " flipping"], "r": ["rest", "result", "rr", "rt", "cr", "dr", "u", "y", "w", "m", "g", "err", "n", "it", "l", "nr", "rd", "radius", "c", "z", "sr", "e", "k", "rs", "rank", "re", "q", "rb", "ro", "br", "rem", "o", "ar", "pr", "j", "rc", "res", "mr", "v", "usr", "er", "out", "right", "p", "d", "a", "h", "i"], "T": ["V", "ID", "GT", "G", "W", "P", "TB", "TN", "Y", "N", "O", "B", "TA", "D", "TT", "K", "I", "E", "TS", "S", "WT", "L", "F", "Q", "TR", "TM", "Z", "TC"], "t": ["ti", "s", "int", "tree", "ty", "ta", "tz", "y", "w", "let", "tr", "f", "m", "g", "tw", "typ", "n", "ft", "l", "total", "tap", "c", "e", "_", "tt", "tu", "v", "ts", "out", "dt", "p", "d", "ct", "h", "tc", "wt", "i", "ot", "td"]}}
{"code": "\\n  sys.setrecursionlimit(9299999)\\n  \\n  def min_time(C, F, X, speed, nb_cookies):\\n  \tif (X - nb_cookies) / speed < (X - (nb_cookies - C)) / (speed + F):\\n  \t\treturn (X - nb_cookies) / speed\\n  \telif nb_cookies >= C:\\n  \t\treturn min_time(C, F, X, speed + F, nb_cookies - C)\\n  \telse:\\n  \t\treturn (C - nb_cookies) / speed + min_time(C, F, X, speed, C)\\n  \\n  T = int(raw_input())\\n  for i in range(T):\\n  \tC, F, X = map(float, raw_input().split())\\n  \tprint 'Case #%d: %f' % (i + 1, min_time(C, F, X, 2, 0))\\n", "target": "6", "substitutes": {"C": ["V", "AC", "CS", "G", "CI", "CV", "P", "W", "IC", "CNN", "CC", "CO", "Y", "CG", "N", "M", "CL", "O", "Count", "MC", "B", "c", "CM", "Control", "D", "CB", "YC", "CF", "Ch", "H", "K", "LC", "CE", "CT", "DC", "CD", "A", "CU", "I", "R", "E", "CP", "Cache", "CA", "NC", "S", "Cons", "EC", "L", "CR", "CON", "KC", "Q", "CH", "VC", "CN", "Z", "TC", "Co", "SC"], "F": ["V", "G", "W", "P", "J", "GF", "Fixed", "FR", "FW", "Fred", "FS", "FER", "f", "Y", "Fs", "AF", "Feed", "Speed", "Frame", "N", "M", " f", "Def", "MF", "FI", "B", "File", "RF", "TF", "D", "Foreign", "EF", "Factory", "CF", "FD", "FL", "IF", "Fi", "H", "DF", "UF", "I", "Full", "R", "E", "FO", "S", "FG", "Field", "WF", "L", "U", "FP", "Q", "SF", "Free", "Fin", "All", "Z", "PF", "UL", "FF", "Family", "For", "FE"], "X": ["V", "Test", "W", "P", "ML", "IC", "Time", "J", "TX", "CC", "FX", "XY", "Y", "Max", "N", "O", "M", "EX", "MC", "IP", "Win", "D", "HTTP", "XL", "ANY", "AX", "H", "IF", "K", "CE", "IM", "CT", "IX", "Content", "XX", "A", "Cross", "DX", "I", "R", "EC", "E", "S", "Check", "Size", "U", "x", "L", "IR", "UX", "XP", "Q", "Event", "XT", "OX", "MX", " x", "Z", "XXX", "Ex", "Load", "ICE"], "speed": ["length", "duration", "sample", "send", "value", "power", "match", "sort", "gain", "comment", "timeout", "sex", "size", "frequency", "peed", "port", "sp", "f", "cost", "rate", "Speed", "wheel", "width", "sf", "capacity", "float", "spin", "when", "scan", "window", "service", "kind", "load", "function", "seek", "rank", "reason", "control", "time", "shape", "kick", "sw", "gravity", "field", "shock", "cycle", "scroll", "count", "age", "force", "x", "dist", "command", "slow", "weight", "wow", "scale", "delay", "type", "driver", "shift", "EED", "height", "transform", "score"], "nb_cookies": ["nb_Cookers", "nb_bindories", "nb_cookions", "nb_threadues", "nb_configessions", "nb_cleanys", "nb_connects", "nb_sessionys", "nb_cookieys", "nb_authentions", "nb_bindes", "nb_threadators", "nb_Cookessions", "nb_connectessions", "nb_cookessions", "nb_copys", "nb_cookiey", "nb_cookieions", "nb_cookys", "nb_copy", "nb_copions", "nb_bindies", "nb_copies", "nb_cooky", "nb_Cookys", "nb_cookieessions", "nb_cookieers", "nb_Cooks", "nb_Cookies", "nb_authentessions", "nb_authentys", "nb_sessionies", "nb_connectes", "nb_binds", "nb_connecties", "nb_cops", "nb_configies", "nb_Cookories", "nb_authenties", "nb_sessionessions", "nb_cookieies", "nb_Cookes", "nb_cookories", "nb_sessions", "nb_cookers", "nb_cleanators", "nb_configs", "nb_cookes", "nb_cooks", "nb_threadys", "nb_configers", "nb_threadies", "nb_copues", "nb_cleanues", "nb_Cooky", "nb_copators", "nb_connectories", "nb_sessiony", "nb_cleanies", "nb_cookators", "nb_copessions", "nb_cookues"], "T": ["V", "G", "W", "P", "TB", "Time", "TN", "t", "Y", "N", "M", "B", "TA", "D", "TT", "TV", "H", "K", "TP", "I", "R", "E", "TS", "S", "NT", "L", "Q", "TR", "TM", "VT", "Z", "TC", "OT", "TL"], "i": ["ti", "s", "ini", "y", "ic", "t", "pi", "m", "li", "f", "xi", "multi", "n", "ix", "c", "bi", "e", "k", "zi", "r", "q", "ai", "b", "im", "ri", "I", "si", "j", "mi", "ui", "v", "x", "di", "gi", "ii", "me", "p", "d"]}}
{"code": "CACHE = {(1, 1, 0): ['c'],\\n   (1, 2, 0): ['c.'],\\n   (1, 2, 1): ['*c'],\\n   (1, 3, 0): ['c..'],\\n   (1, 3, 1): ['*.c'],\\n   (1, 3, 2): ['**c'],\\n   (1, 4, 0): ['c...'],\\n   (1, 4, 1): ['*.c.'],\\n   (1, 4, 2): ['**.c'],\\n   (1, 4, 3): ['***c'],\\n   (1, 5, 0): ['c....'],\\n   (1, 5, 1): ['*.c..'],\\n   (1, 5, 2): ['**.c.'],\\n   (1, 5, 3): ['***.c'],\\n   (1, 5, 4): ['****c'],\\n   (2, 1, 0): ['c', '.'],\\n   (2, 1, 1): ['*', 'c'],\\n   (2, 2, 0): ['c.', '..'],\\n   (2, 2, 1): None,\\n   (2, 2, 2): None,\\n   (2, 2, 3): ['**', '*c'],\\n   (2, 3, 0): ['c..', '...'],\\n   (2, 3, 1): None,\\n   (2, 3, 2): ['*.c', '*..'],\\n   (2, 3, 3): None,\\n   (2, 3, 4): None,\\n   (2, 3, 5): ['***', '**c'],\\n   (2, 4, 0): ['c...', '....'],\\n   (2, 4, 1): None,\\n   (2, 4, 2): ['*.c.', '*...'],\\n   (2, 4, 3): None,\\n   (2, 4, 4): ['**.c', '**..'],\\n   (2, 4, 5): None,\\n   (2, 4, 6): None,\\n   (2, 4, 7): ['****', '***c'],\\n   (2, 5, 0): ['c....', '.....'],\\n   (2, 5, 1): None,\\n   (2, 5, 2): ['*.c..', '*....'],\\n   (2, 5, 3): None,\\n   (2, 5, 4): ['**.c.', '**...'],\\n   (2, 5, 5): None,\\n   (2, 5, 6): ['***.c', '***..'],\\n   (2, 5, 7): None,\\n   (2, 5, 8): None,\\n   (2, 5, 9): ['*****', '****c'],\\n   (3, 1, 0): ['c', '.', '.'],\\n   (3, 1, 1): ['*', '.', 'c'],\\n   (3, 1, 2): ['*', '*', 'c'],\\n   (3, 2, 0): ['c.', '..', '..'],\\n   (3, 2, 1): None,\\n   (3, 2, 2): ['**', '..', 'c.'],\\n   (3, 2, 3): None,\\n   (3, 2, 4): None,\\n   (3, 2, 5): ['**', '**', '*c'],\\n   (3, 3, 0): ['c..', '...', '...'],\\n   (3, 3, 1): ['*.c', '...', '...'],\\n   (3, 3, 2): None,\\n   (3, 3, 3): ['***', '...', 'c..'],\\n   (3, 3, 4): None,\\n   (3, 3, 5): ['***', '*..', '*.c'],\\n   (3, 3, 6): None,\\n   (3, 3, 7): None,\\n   (3, 3, 8): ['***', '***', '**c'],\\n   (3, 4, 0): ['c...', '....', '....'],\\n   (3, 4, 1): ['*.c.', '....', '....'],\\n   (3, 4, 2): ['**.c', '....', '....'],\\n   (3, 4, 3): ['*.c.', '*...', '*...'],\\n   (3, 4, 4): ['****', '....', 'c...'],\\n   (3, 4, 5): None,\\n   (3, 4, 6): ['****', '*...', '*.c.'],\\n   (3, 4, 7): None,\\n   (3, 4, 8): ['****', '**..', '**.c'],\\n   (3, 4, 9): None,\\n   (3, 4, 10): None,\\n   (3, 4, 11): ['****', '****', '***c'],\\n   (3, 5, 0): ['c....', '.....', '.....'],\\n   (3, 5, 1): ['*.c..', '.....', '.....'],\\n   (3, 5, 2): ['**.c.', '.....', '.....'],\\n   (3, 5, 3): ['***.c', '.....', '.....'],\\n   (3, 5, 4): ['**.c.', '*....', '*....'],\\n   (3, 5, 5): ['*****', '.....', 'c....'],\\n   (3, 5, 6): ['**.c.', '**...', '**...'],\\n   (3, 5, 7): ['*****', '*....', '*.c..'],\\n   (3, 5, 8): None,\\n   (3, 5, 9): ['*****', '**...', '**.c.'],\\n   (3, 5, 10): None,\\n   (3, 5, 11): ['*****', '***..', '***.c'],\\n   (3, 5, 12): None,\\n   (3, 5, 13): None,\\n   (3, 5, 14): ['*****', '*****', '****c'],\\n   (4, 1, 0): ['c', '.', '.', '.'],\\n   (4, 1, 1): ['*', '.', 'c', '.'],\\n   (4, 1, 2): ['*', '*', '.', 'c'],\\n   (4, 1, 3): ['*', '*', '*', 'c'],\\n   (4, 2, 0): ['c.', '..', '..', '..'],\\n   (4, 2, 1): None,\\n   (4, 2, 2): ['**', '..', 'c.', '..'],\\n   (4, 2, 3): None,\\n   (4, 2, 4): ['**', '**', '..', 'c.'],\\n   (4, 2, 5): None,\\n   (4, 2, 6): None,\\n   (4, 2, 7): ['**', '**', '**', '*c'],\\n   (4, 3, 0): ['c..', '...', '...', '...'],\\n   (4, 3, 1): ['*.c', '...', '...', '...'],\\n   (4, 3, 2): ['*.c', '*..', '...', '...'],\\n   (4, 3, 3): ['***', '...', 'c..', '...'],\\n   (4, 3, 4): ['***', '*..', '..c', '...'],\\n   (4, 3, 5): None,\\n   (4, 3, 6): ['***', '***', '...', 'c..'],\\n   (4, 3, 7): None,\\n   (4, 3, 8): ['***', '***', '*..', '*.c'],\\n   (4, 3, 9): None,\\n   (4, 3, 10): None,\\n   (4, 3, 11): ['***', '***', '***', '**c'],\\n   (4, 4, 0): ['c...', '....', '....', '....'],\\n   (4, 4, 1): ['*.c.', '....', '....', '....'],\\n   (4, 4, 2): ['**.c', '....', '....', '....'],\\n   (4, 4, 3): ['**.c', '*...', '....', '....'],\\n   (4, 4, 4): ['****', '....', 'c...', '....'],\\n   (4, 4, 5): ['****', '*...', '..c.', '....'],\\n   (4, 4, 6): ['****', '**..', '...c', '....'],\\n   (4, 4, 7): ['****', '*...', '*.c.', '*...'],\\n   (4, 4, 8): ['****', '****', '....', 'c...'],\\n   (4, 4, 9): None,\\n   (4, 4, 10): ['****', '****', '*...', '*.c.'],\\n   (4, 4, 11): None,\\n   (4, 4, 12): ['****', '****', '**..', '**.c'],\\n   (4, 4, 13): None,\\n   (4, 4, 14): None,\\n   (4, 4, 15): ['****', '****', '****', '***c'],\\n   (4, 5, 0): ['c....', '.....', '.....', '.....'],\\n   (4, 5, 1): ['*.c..', '.....', '.....', '.....'],\\n   (4, 5, 2): ['**.c.', '.....', '.....', '.....'],\\n   (4, 5, 3): ['***.c', '.....', '.....', '.....'],\\n   (4, 5, 4): ['***.c', '*....', '.....', '.....'],\\n   (4, 5, 5): ['*****', '.....', 'c....', '.....'],\\n   (4, 5, 6): ['*****', '*....', '..c..', '.....'],\\n   (4, 5, 7): ['*****', '**...', '...c.', '.....'],\\n   (4, 5, 8): ['*****', '***..', '....c', '.....'],\\n   (4, 5, 9): ['*****', '**...', '*..c.', '*....'],\\n   (4, 5, 10): ['*****', '*****', '.....', 'c....'],\\n   (4, 5, 11): ['*****', '**...', '**.c.', '**...'],\\n   (4, 5, 12): ['*****', '*****', '*....', '*.c..'],\\n   (4, 5, 13): None,\\n   (4, 5, 14): ['*****', '*****', '**...', '**.c.'],\\n   (4, 5, 15): None,\\n   (4, 5, 16): ['*****', '*****', '***..', '***.c'],\\n   (4, 5, 17): None,\\n   (4, 5, 18): None,\\n   (4, 5, 19): ['*****', '*****', '*****', '****c'],\\n   (5, 1, 0): ['c', '.', '.', '.', '.'],\\n   (5, 1, 1): ['*', '.', 'c', '.', '.'],\\n   (5, 1, 2): ['*', '*', '.', 'c', '.'],\\n   (5, 1, 3): ['*', '*', '*', '.', 'c'],\\n   (5, 1, 4): ['*', '*', '*', '*', 'c'],\\n   (5, 2, 0): ['c.', '..', '..', '..', '..'],\\n   (5, 2, 1): None,\\n   (5, 2, 2): ['**', '..', 'c.', '..', '..'],\\n   (5, 2, 3): None,\\n   (5, 2, 4): ['**', '**', '..', 'c.', '..'],\\n   (5, 2, 5): None,\\n   (5, 2, 6): ['**', '**', '**', '..', 'c.'],\\n   (5, 2, 7): None,\\n   (5, 2, 8): None,\\n   (5, 2, 9): ['**', '**', '**', '**', '*c'],\\n   (5, 3, 0): ['c..', '...', '...', '...', '...'],\\n   (5, 3, 1): ['*.c', '...', '...', '...', '...'],\\n   (5, 3, 2): ['*.c', '*..', '...', '...', '...'],\\n   (5, 3, 3): ['***', '...', 'c..', '...', '...'],\\n   (5, 3, 4): ['***', '*..', '..c', '...', '...'],\\n   (5, 3, 5): ['***', '*..', '*.c', '...', '...'],\\n   (5, 3, 6): ['***', '***', '...', 'c..', '...'],\\n   (5, 3, 7): ['***', '***', '*..', '..c', '...'],\\n   (5, 3, 8): None,\\n   (5, 3, 9): ['***', '***', '***', '...', 'c..'],\\n   (5, 3, 10): None,\\n   (5, 3, 11): ['***', '***', '***', '*..', '*.c'],\\n   (5, 3, 12): None,\\n   (5, 3, 13): None,\\n   (5, 3, 14): ['***', '***', '***', '***', '**c'],\\n   (5, 4, 0): ['c...', '....', '....', '....', '....'],\\n   (5, 4, 1): ['*.c.', '....', '....', '....', '....'],\\n   (5, 4, 2): ['**.c', '....', '....', '....', '....'],\\n   (5, 4, 3): ['**.c', '*...', '....', '....', '....'],\\n   (5, 4, 4): ['****', '....', 'c...', '....', '....'],\\n   (5, 4, 5): ['****', '*...', '..c.', '....', '....'],\\n   (5, 4, 6): ['****', '**..', '...c', '....', '....'],\\n   (5, 4, 7): ['****', '**..', '*..c', '....', '....'],\\n   (5, 4, 8): ['****', '****', '....', 'c...', '....'],\\n   (5, 4, 9): ['****', '****', '*...', '..c.', '....'],\\n   (5, 4, 10): ['****', '****', '**..', '...c', '....'],\\n   (5, 4, 11): ['****', '****', '*...', '*.c.', '*...'],\\n   (5, 4, 12): ['****', '****', '****', '....', 'c...'],\\n   (5, 4, 13): None,\\n   (5, 4, 14): ['****', '****', '****', '*...', '*.c.'],\\n   (5, 4, 15): None,\\n   (5, 4, 16): ['****', '****', '****', '**..', '**.c'],\\n   (5, 4, 17): None,\\n   (5, 4, 18): None,\\n   (5, 4, 19): ['****', '****', '****', '****', '***c'],\\n   (5, 5, 0): ['c....', '.....', '.....', '.....', '.....'],\\n   (5, 5, 1): ['*.c..', '.....', '.....', '.....', '.....'],\\n   (5, 5, 2): ['**.c.', '.....', '.....', '.....', '.....'],\\n   (5, 5, 3): ['***.c', '.....', '.....', '.....', '.....'],\\n   (5, 5, 4): ['***.c', '*....', '.....', '.....', '.....'],\\n   (5, 5, 5): ['*****', '.....', 'c....', '.....', '.....'],\\n   (5, 5, 6): ['*****', '*....', '..c..', '.....', '.....'],\\n   (5, 5, 7): ['*****', '**...', '...c.', '.....', '.....'],\\n   (5, 5, 8): ['*****', '***..', '....c', '.....', '.....'],\\n   (5, 5, 9): ['*****', '***..', '*...c', '.....', '.....'],\\n   (5, 5, 10): ['*****', '*****', '.....', 'c....', '.....'],\\n   (5, 5, 11): ['*****', '*****', '*....', '..c..', '.....'],\\n   (5, 5, 12): ['*****', '*****', '**...', '...c.', '.....'],\\n   (5, 5, 13): ['*****', '*****', '***..', '....c', '.....'],\\n   (5, 5, 14): ['*****', '*****', '**...', '*..c.', '*....'],\\n   (5, 5, 15): ['*****', '*****', '*****', '.....', 'c....'],\\n   (5, 5, 16): ['*****', '*****', '**...', '**.c.', '**...'],\\n   (5, 5, 17): ['*****', '*****', '*****', '*....', '*.c..'],\\n   (5, 5, 18): None,\\n   (5, 5, 19): ['*****', '*****', '*****', '**...', '**.c.'],\\n   (5, 5, 20): None,\\n   (5, 5, 21): ['*****', '*****', '*****', '***..', '***.c'],\\n   (5, 5, 22): None,\\n   (5, 5, 23): None,\\n   (5, 5, 24): ['*****', '*****', '*****', '*****', '****c']}\\n  \\n  \\n  T = int(input())\\n  for i in range(T):\\n  \tR, C, M = map(int, input().split())\\n  \tprint('Case #{}:'.format(i + 1))\\n  \ttry:\\n  \t\tprint('\\n'.join(CACHE[(R, C, M)]))\\n  \texcept:\\n  \t\tprint('Impossible')\\n", "target": "6", "substitutes": {"CACHE": ["STAGCH", "CAGHA", "CACHACH", "STACHA", "CACHCH", "STAGHE", "CAGHE", "CASHA", "CACHA", "CASHE", "STAGHA", "CACHHE", "STAGACH", "CASCH", "STACHE", "CAGACH", "CACHHA", "CAGCH", "CASACH", "CACACH", "STACACH", "STACCH", "CACCH"]}}
{"code": "\\n  \\n  f = open(sys.argv[1],'r')\\n  \\n  num = int(f.readline())\\n  \\n  for i in range(num):\\n      c, e, x = [float(x) for x in f.readline().split()]\\n      n = int((x*e-2*c)/(c*e))\\n      if n < 0:\\n          n = 0\\n      t = 0\\n      for j in range(n):\\n          t += c/(2+j*e)\\n      t += x/(2+n*e)\\n      print 'Case #{}: {}'.format(i+1, t)\\n", "target": "7", "substitutes": {"f": ["fed", "conf", "af", "file", "y", "cf", "ma", "g", "ft", "sf", "l", "bf", "fs", "h", "fb", "fl", "r", "tf", "b", "fc", "fo", "o", "fg", "uf", "alf", "rf", "v", "F", "fd", "fr", "feed", "p", "d", "a", "fp", "df", "fm", "lf"], "num": ["nb", "nm", "int", "nu", "cal", "np", "om", "m", "multi", "nine", "N", "mn", "nr", "total", "NUM", "init", "z", "Num", "id", "zero", "um", "no", "number", "na", "ten", "count", "net", "nom", "mon", "sum", "d", "max"], "i": ["ki", "ti", "s", "ini", "ic", "y", "cli", "ind", "pi", "li", "m", "xi", "multi", "it", "ix", "index", "z", "zi", "id", "ij", "hi", "q", "b", "im", "I", "si", "mi", "v", "di", "gi", "ip", "ci", "p"], "c": ["cs", "cr", "cp", "cal", "cf", "y", "u", "m", "cin", "g", "l", "com", "C", "ac", "z", "con", "ec", "r", "lc", "co", "b", "o", "ce", "v", "cu", "xc", "cy", "ca", "cm", "ci", "d", "ct", "a", "p", "h", "cn", "cc"], "e": ["ef", "eu", "de", "ate", "ue", "y", "pe", "ed", "u", "xe", "m", "ze", "eng", "ie", "l", "en", "ec", "r", "el", "ne", "o", "ey", "es", "ce", "ele", "E", "oe", "element", "et", "ae", "te", "er", "eg", "eb", "eeee", "d", "ee", "ge"], "x": ["ax", "y", "ic", "u", "xs", "w", "xt", "xe", "xd", "expl", "m", "xi", "xp", "l", "ix", "xa", "fx", "z", "xy", "xb", "r", "co", "b", "px", "o", "xf", "rax", "zx", "X", "xx", "dx", "wx", "v", "ox", "ex", "rex", "nex", "ctx", "p", "ux", "tx", "a", "xc", "rx"], "n": ["nb", "s", "ng", "nu", "np", "y", "len", "w", "m", "g", "N", "mn", "l", "nor", "nr", "z", "ns", "k", "nl", "nn", "r", "ne", "norm", "o", "no", "na", "nt", "sn", "v", "net", "nan", "ln", "nw", "nia", "un", "cn", "p", "d", "a", "h", "name", "nc"], "t": ["int", "rt", "tree", "ta", "y", "at", "st", "g", "m", "tr", "it", "l", "total", "z", "pt", "r", "vt", "tf", "time", "tt", "tu", "T", "o", "tg", "temp", "nt", "ret", "v", "ts", "te", "out", "trace", "dt", "type", "p", "d", "ct", "h", "tc", "wt", "ot", "td"], "j": ["jl", "ja", "J", "jj", "note", "y", "g", "m", "ie", "kj", "it", "l", "step", "key", "aj", "js", "z", "jp", "dj", "k", "ij", "jc", "q", "bj", "ne", "b", "o", "obj", "si", "v", "di", "uj", "ke", "p", "ji", "h", "job", "oj"]}}
{"code": "\\n  \\n  f = open(sys.argv[1],'r')\\n  \\n  num = int(f.readline())\\n  \\n  def count(z, r, c):\\n      return len(z_and_nei(z,r,c))\\n  \\n  def nei(z, r, c):\\n      s = z_and_nei(z, r, c)\\n      s -= set(z)\\n      return s\\n  \\n  def z_and_nei(z, r, c):\\n      s = set()\\n      for x in z:\\n          s.add(x)\\n          s.add((x[0]-1,x[1]-1))\\n          s.add((x[0]-1,x[1]))\\n          s.add((x[0]-1,x[1]+1))\\n          s.add((x[0],x[1]-1))\\n          s.add((x[0],x[1]+1))\\n          s.add((x[0]+1,x[1]-1))\\n          s.add((x[0]+1,x[1]))\\n          s.add((x[0]+1,x[1]+1))\\n      o = set()\\n      for x in s:\\n          if x[0] < 0 or x[0] > r-1 or x[1] < 0 or x[1] > c-1:\\n              o.add(x)\\n      s-=o\\n      return s\\n  \\n  def find_config(z, r, c, t):\\n      if count(z,r,c) == t:\\n          return z\\n      if count(z,r,c) > t:\\n          return []\\n      n = nei(z,r,c)\\n      for x in n:\\n          z.append(x)\\n          if find_config(z,r,c,t) != []:\\n              return z\\n          z.pop()\\n      return []\\n  \\n  for i in range(num):\\n      print 'Case #{}:'.format(i+1)\\n      r, c, m = [int(x) for x in f.readline().split()]\\n      if r*c-m == 1:\\n          print 'c' + '*'*(c-1)\\n          for i in range(r-1):\\n              print '*'*c\\n      else:\\n          z = find_config([(0,0)], c, r, c*r-m)\\n          if z == []:\\n              print \"Impossible\"\\n          else:\\n              s = z_and_nei(z, c, r)\\n              for j in range(r):\\n                  for k in range(c):\\n                      if j == 0 and k == 0:\\n                          print 'c',\\n                      elif (k,j) in s:\\n                          print '.',\\n                      else:\\n                          print '*',\\n                  print\\n  \\n  \\n", "target": "7", "substitutes": {"f": ["fed", "file", "y", "w", "ze", "g", "l", "ft", "bf", "fs", "fb", "fe", "e", "fl", "tf", "b", "fc", "fo", "fg", "uf", "alf", "rf", "fi", "v", "F", "fd", "fr", "feed", "df", "p", "d", "a", "fp", "h", "fm", "lf", "form"], "num": ["nb", "nm", "Number", "conf", "nu", "cal", "np", "om", "th", "mult", "tr", "multi", "nr", "total", "en", "NUM", "init", "con", "Num", "zero", "um", "no", "number", "na", "nom", "mon", "sim", "un", "sum", "p", "final", "max"], "z": ["os", "data", "zone", "ld", "y", "zen", "u", "zip", "w", "ic", "ze", "yz", "zh", "nz", "g", "new", "xt", "it", "l", "ix", "cl", "h", "zo", "e", "zi", "config", "ez", "pt", "q", "iz", "hz", "zero", "b", "ed", "sw", "az", "nt", "zes", "v", "ry", "one", "cz", "uz", "pl", "zer", "rez", "p", "d", "Z", "oz", "tz", "a", "all", "ll", "ot"], "r": ["hr", "rr", "rt", "cr", "dr", "u", "y", "w", "tr", "g", "err", "rect", "ru", "it", "l", "nr", "rd", "h", "rn", "sr", "e", "rs", "re", "rer", "q", "b", "ro", "br", "ur", "ar", "ra", "ri", "rec", "R", "rel", "rc", "res", "mr", "v", "ry", "usr", "er", "lr", "fr", "vr", "p", "d", "rar", "a", "rg", "rb"], "c": ["cs", "conf", "cr", "cp", "cont", "ch", "cf", "y", "u", "anc", "w", "cin", "g", "l", "com", "gc", "C", "ac", "h", "ec", "arc", "con", "mc", "e", "dc", "lc", "co", "b", "fc", "cur", "ar", "cos", "ce", "rc", "cache", "sc", "chain", "mr", "cor", "v", "count", "cat", "cu", "ca", "cb", "cm", "ci", "cd", "ct", "p", "cn", "d", "tc", "a", "nc", "cc"], "s": ["os", "tags", "ans", "sts", "ys", "ed", "gets", "g", "l", "js", "ies", "lines", "rs", "ss", "ls", "b", "less", "v", "abs", "els", "a", "ions", "ows", "ries", "w", "st", "types", "ings", "e", "settings", "ges", "results", "se", "ments", "S", "sa", "ts", "simple", "terms", "sb", "p", "h", "sets", "sv", "ds", "xs", "sp", "its", "eds", "ns", "ps", "ats", "ses", "ands", "bs", "qs", "ing", "ers", "cs", "sys", "ms", "y", "fs", "ends", "set", "sq", "gs", "es", "ools", "er", "ws", "mods", "so", "tests", "als", "ords", "ins"], "x": ["mx", "ax", "u", "g", "yx", "l", "lat", "ext", "check", "mix", "q", "co", "sw", "zx", "wx", "v", "ctx", "ct", "a", "rx", "tx", "xxx", "ty", "w", "xt", "st", "xml", "ac", "e", " xx", "oxy", "xb", "dl", "\u00e7", "el", "xx", "nex", "p", "exp", "h", "xc", "xs", "on", "xe", "at", "xi", "xa", "fx", "lex", "xy", "hex", "iz", "ml", "xf", "ex", "inx", "any", "y", "ic", "work", "xd", "xp", "ix", "key", "test", "xes", "px", "ey", "X", "dx", "xxxx", "ox", "ux", "content", "item"], "o": ["os", "ob", "to", "oS", "y", "u", "bo", "w", "onet", "ed", "g", "O", "l", "e", "aos", "co", "b", "no", "oin", "v", "ox", "out", "so", "iso", "p", "d", "a", "h", "oa", "ot"], "t": ["ti", "ty", "ta", "to", "size", "w", "at", "tr", "g", "tw", "it", "l", "total", "test", "h", "tm", "tp", "e", "vt", "pt", "q", "time", "tt", "tu", "T", "nt", "v", "ts", "te", " T", "tif", "dt", "type", "p", "d", "ct", "a", "tz", "tc", "wt", "ot", "td"], "n": ["nb", "nu", "names", "np", "y", "nz", "g", "N", "l", "nor", "nr", "ot", "e", "ns", "nl", "nn", "ne", "na", "nt", "sn", "v", "an", "ln", "cn", "p", "d", "name", "ll", "nc"], "i": ["ki", "ti", "ini", "y", "cli", "ic", "pi", "li", "xi", "multi", "it", "l", "index", "bi", "e", "zi", "hi", "q", "ai", "phi", "im", "ri", "I", "si", "mi", "v", "di", "gi", "yi", "sim", "ip", "me", "ci", "a", "ei", "gu"], "m": ["ms", "y", "w", "g", "M", "l", "mc", "e", "mm", "mu", "b", "mi", "mr", "count", "v", "dm", "cm", "p", "d", "h"]}}
{"code": "\\n  \\n  def solve(c, f, x):\\n      time = 0\\n      cps = 2.0\\n      while True:\\n          time_to_farm = c / cps\\n          time_to_end = x / cps\\n          buy_a_farm = (time_to_farm + x / (cps + f)) < time_to_end\\n          if buy_a_farm:\\n              time += time_to_farm\\n              cps += f\\n          else:\\n              time += time_to_end\\n              return time\\n  \\n  if __name__ == '__main__':\\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\\n      with fin, fout:\\n          T = int(fin.readline())\\n          for case in xrange(1, T+1):\\n              c, f, x = map(float, fin.readline().split())\\n              soln = solve(c, f, x)\\n              print >> fout, \"Case #{0}: {1:.7f}\".format(case, soln)\\n  \\n", "target": "8", "substitutes": {"c": ["cs", "cp", "abc", "u", "cf", "y", "w", "t", "g", "m", "n", "l", "C", "ac", "con", "e", "k", "mc", "r", "dc", "co", "lc", "b", "fc", "unc", "cos", "rc", "v", "cu", "xc", "cy", "cd", "ci", "p", "ct", "a", "d", "h", "tc", "cm", "i", "cc"], "f": ["fed", "s", "cox", "file", "u", "cf", "y", "w", "t", "g", "m", "fac", "l", "ft", "sf", "float", "fx", "fs", "h", "z", "fe", "fb", "e", "r", "q", "tf", "co", "b", "fc", "fo", "fa", "fg", "xf", "alf", "rf", "field", "fi", "ff", "v", "F", "fw", "fd", "fr", "p", "d", "a", "fp", "df", "i"], "x": ["s", "y", "u", "cf", "w", "xs", "xt", "t", "xe", "m", "g", "xi", "n", "l", "ix", "xa", "z", "e", "xy", "k", "ic", "r", "q", "b", "fc", "o", "xf", "X", "xx", "v", "ox", "ex", "p", "ux", "a", "h", "xc", "i", "rx"], "time": ["timer", "duration", "length", "then", "value", "power", "times", "message", "Time", "comment", "timeout", "file", "size", "frequency", "port", "date", "t", "etime", "ime", "rate", "done", "step", "window", "tm", "name", "UTC", "TIME", "version", "depth", "tt", "change", "path", "money", "year", "point", "start", "pay", "frame", "ts", "clock", "now", "code", "weight", "speed", "trace", "tim", "mean", "dt", "type", "transform", "tc", "max"], "cps": ["cspp", " cpps", "tcPS", "uncpps", "lcPS", "cPS", "Cpp", "mceps", "tcps", "Cpps", " ceps", "tcts", "CPS", "mcpp", "cseps", "cvPS", "ccpp", "mcps", "cvps", "Ceps", "Cts", "cvbs", "Cps", "uncps", " caps", "cbs", "cepps", "ccPS", "cvpp", "aceps", "uncpp", "caps", "uncPS", "tcaps", "ceeps", "ceps", "acpps", "ccbs", "Caps", "cspps", "mcpps", "csps", "acPS", "lcpp", "Cbs", " cts", "cpps", "ccps", "cepp", "acps", "cts", "lcpps", " cpp", "lcps", " cPS", "cpp"], "time_to_farm": ["time_2_fleet", "time_to_hunt", "time_2_farm", "time_2_Farm", "time_2_end", "time_To_Farm", "time_to_start", "time_To_end", "time_toprefarm", "time_topreend", "time_toprehunt", "time_to_Farm", "time_toprestart", "time_To_pay", "time_to_fleet", "time_to_pay", "time_To_farm"], "time_to_end": ["time_to_stop", "time_to_ended", "time_to_start", "time_to_END", "time_TO_ends", "time_TO_end", "time_to_ends", "time_TO_END", "time_TO_ended"], "buy_a_farm": ["buy_an_fleet", "buy_a_Farm", "buy_an_farm", "buy_an_hunt", "buy_a_fleet", "buy_an_Farm", "buy_a_hunt"], "fin": ["sys", "ini", "conn", "do", "file", "raf", "tr", "fil", "pen", "skip", "mn", "en", "init", "fs", "con", "fine", "proc", "tun", "focus", "ran", "resp", "fl", "fre", "vol", "reset", "trans", "fc", "normal", "fa", "bin", "rec", "find", "oin", "fi", "sn", "res", "fn", " Fin", "FIN", "through", "reader", "syn", "out", "ln", "conv", "writer", "fd", "fr", "open", "Fin", "next", "std", "final", "fp", "fun"], "fout": ["cfin", "pOut", "foutput", "wout", "Fw", "Foutput", " fw", "pin", "fOut", " foutput", "wOut", "fouts", "cfOut", "poutput", "pout", "woutput", "Fout", "finoutput", "cfouts", "fw", " fOut", "wouts", " fouts", "finout", "cfout", "finw", "win"], "T": ["V", "GT", "G", "W", "P", "TB", "J", "Time", "TN", "t", "Y", "N", "M", "O", "B", "C", "TA", "D", "TT", "TY", "H", "K", "TW", "I", "R", "X", "E", "TS", "S", "L", "F", "TH", "Q", "PO", "Z", "TC", "Case"], "case": ["match", "est", "P", " CASE", "tc", "core", "hyp", "pe", "mode", "cases", "condition", "index", "custom", "test", "switch", "C", "option", "set", "nce", "id", "event", "su", "CE", "instance", "zero", "context", "point", "ce", "line", "cycle", "ASE", "chain", "cor", "ase", "bug", "trial", "race", "ice", "cas", "ace", " Case", "name", "TC", "Case"], "soln": ["ssols", "ssoln", " solve", "Sol", "solve", "Sols", " solution", "Soln", " sols", "sols", " sol", "ssol", "Solve", "ssolve", "Solution", "solution", "sol", "ssolution"]}}
{"code": "\\n  \\n  IMPOSSIBLE = []\\n  \\n  def transpose(grid):\\n      return map(list, zip(*grid))\\n  \\n  def find_grid(R, C, M):\\n      \"\"\"Return a grid of a solution, if one exists, otherwise []\\n  \\n      Observations:\\n      * WLOG, C <= R (otherwise, take the transpose of a solution)\\n      * Trivial cases are:\\n        - M = 0 or  M = RC - 1\\n        - C = 1\\n        - (R, C) = (2, 2)\\n        - (R, C, M) = (3, 3, 2)\\n        - (C, M) = (2, 1)\\n      * If M >= C >= 2 and R >= 3, we can add a row of C mines to the bottom and consider M'=M-C, R'=R-1\\n      * The remaining cases are M <= R-2, and M + 1 == R == C >= 4, which are both solvable\\n      \"\"\"\\n      if M == 0:\\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          return grid\\n      elif M == R * C - 1:\\n          grid = [['*' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          return grid\\n      elif C > R:\\n          return transpose(find_grid(C, R, M))\\n      elif C == 1:\\n          return [['c']] + [['.'] for i in xrange(R-M-1)] + [['*'] for i in xrange(M)]\\n      elif (R, C) == (2, 2) or (R, C, M) == (3, 3, 2) or (C, M) == (2, 1):\\n          return IMPOSSIBLE\\n  \\n      assert 2 <= C <= R >= 3, \"R={} C={} M={}\".format(R, C, M)\\n  \\n      if M >= C:\\n          s = find_grid(R-1, C, M-C)\\n          return s and s + [['*' for c in xrange(C)]]\\n      elif M <= R-2 and C >= 3:\\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          for i in xrange(M):\\n              grid[R-i-1][C-1] = '*'\\n          return grid\\n      elif M + 1 == R == C >= 4:\\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          grid[R-1][C-2] = '*'\\n          for i in xrange(M-1):\\n              grid[R-i-1][C-1] = '*'\\n          return grid\\n  \\n      assert False, \"R={} C={} M={}\".format(R, C, M)\\n  \\n  def check_soln(grid, R, C, M):\\n      \"\"\"checking, because debugging...\"\"\"\\n      error = \"R={} C={} M={}\".format(R, C, M)\\n      assert sum(row.count('*') for row in grid) == M, error\\n      assert sum(row.count('c') for row in grid) == 1, error\\n      assert len(grid) == R, error\\n      assert all(len(row) == C for row in grid), error\\n      _ = [i for i, row in enumerate(grid) if 'c' in row][0]\\n      click = (_, [i for i, c in enumerate(grid[_]) if c == 'c'][0])\\n  \\n      def neighbours(r, c):\\n          ns = [(i, j) for i in range(max(r-1,0),min(r+2,R)) for j in range(max(c-1,0),min(c+2,C))]\\n          ns.remove((r, c))\\n          return ns\\n  \\n      cpy = map(list, grid)\\n      def fill(cpy, pos):\\n          cpy[pos[0]][pos[1]] = str(sum(1 for i, j in neighbours(*pos) if grid[i][j] == '*'))\\n          if cpy[pos[0]][pos[1]] == '0':\\n              for i, j in neighbours(*pos):\\n                  if cpy[i][j] == '.':\\n                      fill(cpy, (i, j))\\n      fill(cpy, click)\\n      assert sum(row.count('.') for row in cpy) == 0, error\\n  \\n  def solve(R, C, M):\\n      soln = find_grid(R, C, M)\\n      if soln == IMPOSSIBLE:\\n          return \"Impossible\"\\n      else:\\n          check_soln(soln, R, C, M)\\n          return '\\n'.join(''.join(row) for row in soln)\\n  \\n  if __name__ == '__main__':\\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\\n      with fin, fout:\\n          T = int(fin.readline())\\n          for case in xrange(1, T+1):\\n              r, c, m = map(int, fin.readline().split())\\n              soln = solve(r, c, m)\\n              print >> fout, \"Case #{0}:\\n{1}\".format(case, soln)\\n  \\n", "target": "8", "substitutes": {"IMPOSSIBLE": ["IMSPossABLE", "IMPLOSSIC", "IMPossible", "IMPESSibles", "IMPOSSible", "IMPOSTibles", "IMPESSIBLE", "IMPOSTible", "IMSPOSSibles", "IMPOSSIC", "IMPOSible", "IMPESSible", "IMPOSIBLE", "IMPESSED", "IMPLESSED", "IMSPossibles", "IMPLOSSible", "IMPLOSSED", "IMPLESSible", "IMPossABLE", "IMPossibles", "IMPossED", "IMPLESSIBLE", "IMPOSSibles", "IMSPOSSABLE", "IMPESSIC", "IMPossIBLE", "IMSPossible", "IMSPOSSible", "IMPOSSABLE", "IMPESSABLE", "IMPOSTIBLE", "IMPLESSIC", "IMPOSED", "IMPossIC", "IMPLOSSIBLE", "IMPOSSED", "IMSPOSSIBLE", "IMSPossIBLE", "IMPOSIC", "IMPOSTABLE"], "grid": ["disk", "clear", "card", "cli", "stack", "t", "g", "multi", "cell", "query", "table", "q", "modified", "sid", "frame", "age", "hold", "fixed", "filename", "wrapper", "debug", "console", "ad", "bar", "range", "Grid", "stock", "network", "gate", "index", "mask", "window", "cart", "buffer", "util", "db", "e", "raid", "client", "default", "term", "res", "split", "prefix", "storage", "device", "out", "list", "layer", "bag", "filter", "gm", "array", "section", "record", "form", "func", "valid", "domain", "rid", "zip", "input", "xi", "plot", "load", "status", "car", "map", "column", "module", "pack", "flow", "model", "final", "box", "values", "layout", "data", "result", "gr", "file", "series", "cf", "work", "lay", "csv", "url", "play", "band", "ixture", "memory", "dq", "test", "gc", "mat", "set", "manager", "unit", "sequence", "jac", "lag", "group", "filled", "product", "block", "format", "cache", "line", "field", "chain", "wire", "tile", "server", "node", "cm", "content", "rows", "queue"], "R": ["V", "RS", "G", "Root", "RE", "W", "P", "ER", "J", "Remote", "Range", "Y", "Reg", "N", "O", "Right", "B", "MR", "RF", "Rs", "GR", "D", "RA", "H", "K", "RC", "SR", "BR", "RM", "Row", "A", "Reader", "RT", "I", "RO", "X", "E", "JR", "RI", "S", "RR", "NR", "DR", "L", "U", "F", "Rot", "CR", "IR", "Res", "TR", "Q", "Cor", "AR", "Rat", "HR", "Z"], "C": ["V", "CS", "G", "W", "CV", "RE", "CO", "Y", "CAR", "CG", "Count", "CF", "K", "CT", "E", "U", "CR", "Comp", "CN", "Z", "CI", "CC", "N", "MC", "B", "CB", "Ch", "CE", "CU", "I", "S", "F", "AR", "Col", "WC", "SC", "Cr", "CL", "D", "Cs", "H", "RC", "Cl", "CD", "CP", "Cache", "Cons", "Config", "Q", "VC", "Chain", "P", "IC", "COR", "O", "HC", "CM", "CCC", "DC", "A", "Cal", "X", "EC", "L", "CON", "GC", "Con", "Co"], "M": ["V", "Man", "RS", "G", "ME", "MAN", "W", "P", "MT", "RE", "J", "REM", "Y", "N", "O", "OM", "MC", "B", "CM", "MR", "JM", "MN", "D", "H", "MP", "MI", "IM", "LM", "Me", "RM", "A", "I", "X", "E", "EM", "S", "MIT", "L", "F", "U", "PM", "Rem", "Q", "TM", "MS", "AR", "MM", "NM", "Z", "MA", "VM", "DM", "AM", "Manager"], "c": ["cr", "cp", "ic", "t", "f", "g", "cin", "l", "cl", "can", "ac", "ec", "arc", "con", "const", "ir", "dc", "lc", "co", "unc", "ar", "cur", "icc", "rec", "rc", "sc", "cod", "cor", "count", "cu", "pc", "col", "cm", "ci", "p", "ct", "cc"], "r": ["range", "cr", "rt", "dr", "gr", "w", "ind", "t", "f", "g", "it", "rd", "order", "rm", "sr", "re", "ir", "ro", "ar", "ri", "pr", "rec", "rc", "res", "mr", "er", "run", "p", "rar", "h"], "i": ["ti", "int", "ini", "ic", "ico", "ind", "pi", "t", "it", "il", "e", "ij", "ir", "ai", "co", "b", "im", "ri", "I", "rec", "ati", "ib", "di", "gi", "ii", "ip", "ci", "ion"], "s": ["ids", "os", "ds", "y", "w", "t", "xs", "f", "g", "hs", "n", "l", "single", "its", "sub", "js", "e", "rs", "ls", "ss", "ges", "gs", "b", "ps", "ims", "ats", "es", "ools", "results", "S", "res", "v", "ts", "x", "ws", "sb", "sol", "ches", "p", "d", "rows", "a", "ins", "h"], "row": ["ows", "week", "cell", "way", "load", "column", "where", "box", "zero", "ro", "Row", "block", "line", "ver", "low", "flow", "rown", "ow", "roll", "level", "col", "run", "rows", "round", "day", "section", "post", "component"]}}
{"code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/B/'\\n  \\n  \\n  \\n  def solve (f_in, f_out):\\n      T = int(f_in.readline())\\n      for testcase in range(1,T+1):\\n          line = f_in.readline()\\n          C,F,X = [float(q) for q in line.split()]\\n          result = compute (C,F,X)\\n          f_out.write('Case #' + str(testcase) + ': ' + str(result) + '\\n')\\n  \\n  \\n  def compute(C,F,X):\\n      cps = 2\\n      farms = 0\\n      timespent = 0\\n      while X / cps > C/cps + X/(cps+F):\\n          farms += 1\\n          timespent += C/cps\\n          cps += F\\n  \\n      return timespent + X/cps\\n  \\n  \\n  \\n  \\n  \\n  def main_run():\\n      filenames = [x for x in os.listdir (directory)]\\n      filenames = [x for x in filenames if x.endswith('.in')]\\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\\n      chosen_filename =  sorted(l1)[-1][1][:-3]\\n  \\n      print ('Directory : ', directory)\\n      print ('Chosen Filename : ',chosen_filename)\\n      print()\\n      print ('Start : ', time.ctime())\\n      print()\\n      \\n      f_in = open(directory+chosen_filename+'.in')\\n      f_out = open(directory+chosen_filename+'.out', 'w')\\n      solve(f_in,f_out)\\n      f_in.close()\\n      f_out.close()\\n  \\n      print ()\\n      print ('End : ', time.ctime())\\n  \\n  \\n  main_run()\\n", "target": "9", "substitutes": {"directory": ["disk", "message", "domain", "tree", "language", "folder", "collection", "absolute", "network", "archive", "drive", "word", "dir", "database", "location", "reference", "memory", "division", "application", "password", "copy", "direction", "volume", "relative", "root", "system", "sequence", "maximum", "connection", "delete", "module", "dry", "definition", "path", "number", "variable", "template", "space", "source", "description", "output", "prefix", "device", "environment", "filename", "Directory", "voice", "document", "command", "position", "library", "install", "direct"], "f_in": ["f_inf", " f_or", "f_i", "f2in", "f__or", "f_ins", "f_inner", "f2cin", "f_IN", "f__i", "f7rin", "f__in", "f_cin", "f___in", "f___i", " f_ins", " f_IN", "f__cin", "f7in", "f__IN", "f___ins", "f_gin", "f2out", " f_rin", " f_gin", "f2ins", "f_rin", "f__out", "f7inf", "f__ins", " f_inf", " f_inner", "f_or", "f7out", " f_cin", " f_i", "f___out"], "f_out": [" f_write", "f_write", "fessne", "f___or", " f_or", "f___obj", "f_at", " f_obj", " f_ne", " f_file", "fessout", " f_outs", "f___in", "f_or", "f_io", "f_obj", " f_at", "f_file", "f___out", "f_outs", "fessobj", "f_ne", "fessin", " f_io"], "T": ["V", "GT", "G", "P", "TB", "Time", "TN", "t", "Y", "N", "M", "O", "B", "TA", "D", "TT", "TY", "H", "K", "Now", "I", "E", "TS", "S", "L", "TR", "PO", "Q", "TM", "VT", "Z", "TI", "TC", "OT"], "testcase": ["caseCase", "testtrial", "testingCase", "testrow", "testCase", "Testcase", " testrow", "caserow", " testCase", "Testline", "Testtrial", "matchtrial", "testingcase", "testcell", "testingtrial", "testline", "Testrow", " testline", "casecase", "matchcase", "testingcell", "caseline", "matchCase", "matchcell", "Testcell", "TestCase"], "line": ["sample", "comment", "ue", "ner", "ine", "pe", "pair", "ze", "li", "case", "long", "cell", "profile", "l", "qu", "text", "header", "lin", "lined", "lines", "query", "lock", "nl", "entry", "liner", "block", "ql", "se", "field", "eline", "v", "ry", "L", "Line", "question", "te", "ln", "ip", "row", "quality", "LINE", "le", "string", "log"], "C": ["V", "CS", "G", "CI", "P", "W", "CNN", "COR", "CC", "CO", "Cod", "Y", "CG", "N", "M", "O", "MC", "B", "c", "CM", "D", "CF", "YC", "CB", "Cs", "H", "LC", "JC", "CT", "CCC", "DC", "A", "CU", "CD", "I", "R", "E", "CP", "Cache", "CA", "S", "L", "Custom", "Config", "CR", "KC", "CW", "Z", "TC", "Co", "Case"], "F": ["V", "G", "W", "P", "FU", "FT", "J", "GF", "Fs", "f", "Y", "FER", "AF", "Feed", "N", "M", "O", "FC", "MF", "FI", "B", "RF", "Foreign", "D", "CF", "Factory", "EF", "FD", "IF", "H", "K", "DF", "A", "UF", "I", "Full", "E", "FO", "S", "FG", "Field", "L", "U", "FM", "Fun", "Q", "SF", "Female", "Z", "PF", "FF", "Family", "FA", "FE"], "X": ["V", "W", "P", "J", "Time", "TX", "CC", "Y", "N", "M", "MC", "PE", "D", "CF", "XL", "FE", "TY", "H", "K", "CE", "CT", "IX", "XX", "A", "Cross", "DX", "I", "R", "E", "S", "L", "U", "IR", "UX", "XP", "Q", "CH", "XT", "TC", "OX", "Z", "ZX", "XXX", "ICE"], "q": ["seq", "sample", "match", "comment", "ue", "file", "ch", "cf", "pe", "ind", "t", "f", "case", "qual", "n", "cell", "eq", "l", "qu", "lin", "c", "dq", "query", "e", "sq", "r", "change", "term", "ql", "ck", "field", "qi", "requ", "qv", "bit", "cat", "question", "ox", "quant", "qq", "Q", "char", "quality", "p", "i", "iq", "qt"], "result": ["data", "match", "Result", "successful", "value", "complete", "cert", "successfully", "f", "case", "RESULTS", "correct", "test", "this", "status", "function", "reason", "re", "response", "r", "su", "cur", "results", "true", "ret", "ver", "res", "report", "output", "description", "process", "answer", "the", "out", "success", "error", "mate"], "cps": [" cpps", "Camps", " camps", "Cfps", " cms", "tcamps", "crs", "ccs", " ccs", "cPS", "tcpps", "peps", "icps", "cfps", "ncs", "tcps", "icaps", "Cpps", "cms", "nps", "CPS", "acaps", " cres", "nrs", "laps", "pms", "Ceps", "lps", " caps", "lms", "pfps", "pres", "caps", "tcaps", "iceps", "ceps", "tccs", "cres", "pps", "Caps", "npps", "icfps", "paps", "acPS", "Cms", "pPS", "cpps", "Cres", "acms", "acps", "camps", "tcrs", "leps", " crs", " cPS", "Cps"], "farms": ["varms", "farm", "frarms", "fears", "ffounters", "infounters", "ffears", "infarm", "ffarms", "frarm", "vounters", "gamps", "frears", "carms", "infears", "varm", "gounters", "counters", "frounters", "famps", "founters", "ffarm", "garm", "infarms", "garms", "camps", "vamps", "carm"], "timespent": [" timespots", "timepent", "timepen", "timepots", "timepert", "timespots", "eventspent", "timeent", "namespots", "timecent", " timescent", "imespent", " timespen", "timesent", "timespen", "namespent", "eventscent", "timespert", "imescent", " timesent", "eventspen", "imespert", " timespert", "timescent", "namescent", "imesent", "namesent", "eventsent"], "filenames": ["filesAMES", " filenumbers", " filensame", "filatename", "filensels", "filesels", " filensumbers", "filenumames", "tilenAMES", "filennodes", "filenels", " filensAMES", "tilenitles", "tilensitles", "filatenames", "tilensels", " filensnames", "tilensAMES", "filennames", "filenname", "tilenels", "calennnames", "calenews", "calennodes", "calennames", "filenumels", "filpenames", "filensodes", "filensnames", "filenitles", "tilenames", "filpename", "filennAMES", "filensews", "tilensames", "calenames", "filenumbers", "filenumitles", "filpenumbers", "filesitles", "filatenodes", "calenodes", " filename", "filesames", "filpennames", " filensames", " filenAMES", "filensames", "filensAMES", "filenAMES", "filenews", "filename", "filenodes", "filatenumbers", "filatenews", "filennnames", "filensame", "calennews", "filensitles", "filatenAMES", "filennews", "filatennames", " filennames", "filenumAMES", "filensumbers"], "x": ["wait", "s", "mx", "xxx", "ax", "sex", "y", "xs", "w", "xt", "t", "xe", "xd", "f", "xml", "www", "xi", "xp", "n", "l", "key", "xa", "ix", "fx", "lex", "qu", "z", "xy", "e", "rx", "plex", "k", "re", "xb", " xx", "xia", "hex", "xes", "co", "dit", "px", "xf", "rax", "ck", "ross", "xx", "dx", "wx", "v", "xxxx", "ox", "read", "ex", "inx", "rex", "ctx", "yl", "ux", "p", "ct", "d", "h", "xc", "i", "tx"], "l1": ["L1", " l0", "L3", "li11", "L2", "li2", "li0", "li3", "l2", " l7", "l7", "L7", "l0", "l3", "L11", " l3", "li7", "L0", " l2", " l11", "l11", "li1"], "chosen_filename": ["chosen_hero", "chose_file", "chosen_fp", "chose_Filename", "chosen5Filename", "chosen_stem", "chosen5name", "chose_result", "chosen2name", "chosen2result", "choseningsubject", "chosen_result", "chosen_Filename", "choseningfilename", "chosen2Filename", "chosen_subject", "chosen___Filename", "chosen___fp", "chosen___filename", "choser_hero", "chose_fp", "chosen_name", "chosen2filename", "chosen5filename", "chose_name", "choser_stem", "chosen_file", "chosen5result", "chose_filename", "chose_subject", "chosen___file", "choser_filename", "choser_Filename", "choseningFilename"]}}
{"code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'\\n  \\n  \\n  \\n  def solve_one_case (R,C,M):\\n          l = []\\n          for i in range(R):\\n              for j in range(C):\\n                  l.append((i,j))\\n  \\n          empty_mat = []\\n          for i in range(R):\\n              empty_mat.append(['.']*C)\\n  \\n          found = False\\n  \\n          assert (0,0) in l\\n          l = l[1:]\\n          l = l[::-1]\\n          assert (0,0) not in l\\n          \\n          output = ''\\n          \\n          for mine_placement in itertools.combinations(l,M):\\n              mat = deepcopy(empty_mat)\\n              for cell in mine_placement:\\n                  mat[cell[0]][cell[1]] = '*'\\n              if isOneClick(mat, R, C, M):\\n                  mat[0][0] = 'c'\\n                  for line in mat:\\n                      output += ''.join(line) + '\\n'\\n                  found = True\\n                  return output\\n              \\n          if not found:\\n              return 'Impossible\\n'\\n          \\n          assert ValueError()\\n          \\n  def solve (f_in, f_out):\\n      T = int(f_in.readline())\\n      for testcase in range(1,T+1):\\n          line = f_in.readline()\\n          R,C,M = [int(q) for q in line.split()]\\n          print (testcase,R,C,M)\\n  \\n          output = solve_one_case (R,C,M)\\n          f_out.write('Case #' + str(testcase) + ':\\n')\\n          f_out.write(output)\\n  \\n          \\n  \\n  \\n  def isOneClick (mat, R, C, M):\\n  \\n      mat_cpy = deepcopy(mat)\\n      oneclickcells = [(0,0)]\\n      while oneclickcells:\\n          node = oneclickcells.pop()\\n          mat_cpy[node[0]][node[1]] = 'v'\\n          if noNearbyMines(mat_cpy,node):\\n              oneclickcells.extend(getNearbyUnvisited(mat_cpy, node))\\n  \\n      return sum([l.count('.') for l in mat_cpy]) == 0\\n      \\n  \\n  def getNearbyUnvisited(mat, node):\\n      R = len(mat)\\n      C = len(mat[0])\\n      deltas_r = [0]\\n      deltas_c = [0]\\n      if node[0] > 0:\\n          deltas_r.append(-1)\\n      if node[1] > 0:\\n          deltas_c.append(-1)\\n      if node[0] < R-1:\\n          deltas_r.append(1)\\n      if node[1] < C-1:\\n          deltas_c.append(1)\\n  \\n      ret_list = []\\n      for delta_r in deltas_r:\\n          for delta_c in deltas_c:\\n              next_node = (node[0]+delta_r, node[1] + delta_c)\\n              if mat[next_node[0]][next_node[1]] not in ['*','v']:\\n                  ret_list.append((next_node[0],next_node[1]))\\n  \\n      return ret_list\\n  \\n  def noNearbyMines(mat,node):\\n      R = len(mat)\\n      C = len(mat[0])\\n      deltas_r = [0]\\n      deltas_c = [0]\\n      if node[0] > 0:\\n          deltas_r.append(-1)\\n      if node[1] > 0:\\n          deltas_c.append(-1)\\n      if node[0] < R-1:\\n          deltas_r.append(1)\\n      if node[1] < C-1:\\n          deltas_c.append(1)\\n  \\n      for delta_r in deltas_r:\\n          for delta_c in deltas_c:\\n              if mat[node[0] + delta_r][node[1] + delta_c] == '*':\\n                  return False\\n      return True\\n      \\n  def main_run():\\n      filenames = [x for x in os.listdir (directory)]\\n      filenames = [x for x in filenames if x.endswith('.in')]\\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\\n      chosen_filename =  sorted(l1)[-1][1][:-3]\\n  \\n      print ('Directory : ', directory)\\n      print ('Chosen Filename : ',chosen_filename)\\n      print()\\n      print ('Start : ', time.ctime())\\n      print()\\n      \\n      f_in = open(directory+chosen_filename+'.in')\\n      f_out = open(directory+chosen_filename+'.out', 'w')\\n      solve(f_in,f_out)\\n      f_in.close()\\n      f_out.close()\\n  \\n      print ()\\n      print ('End : ', time.ctime())\\n  \\n  \\n  main_run()\\n  \\n", "target": "9", "substitutes": {"directory": ["disk", "Dir", "uri", "folder", "file", "collection", "database", "dir", "location", "n", "wd", "pattern", "application", "D", "volume", "root", "entry", "doi", "path", "home", "email", "prefix", "filename", "Directory", "command", "library", "d", "project", "picture"], "R": ["V", "G", "RE", "of", "Y", "Rs", "lines", "_", "Ring", "E", "RR", "RW", "U", "CR", "IR", "just", "RS", "cont", "ER", "RG", "N", "com", "Dr", "B", "e", "RA", "r", "BR", "call", "SR", "I", "RO", "S", "DR", "F", "Rot", "join", "Mr", "AR", "Remote", "new", "GR", "D", "H", "RC", "RM", "RT", "Q", "select", "col", "P", "J", "O", "MR", "RL", "block", "A", "X", "RI", "NR", "L", "Res", "TR", "all"], "C": ["V", "AC", "CS", "G", "COM", "W", "P", "CV", "IC", "J", "CNN", "ERC", "CC", "Y", "CG", "N", "O", "CL", "MC", "HC", "B", "CM", "c", "D", "CF", "YC", "Ch", "Cs", "H", "K", "JC", "CE", "CT", "CCC", "CU", "Cl", "DC", "A", "I", "X", "EC", "E", "Cache", "CA", "S", "CP", "Cons", "L", "F", "U", "CBS", "CR", "CON", "Q", "CW", "VC", "CN", "Con", "Co", "Craig", "SC"], "M": ["V", "Mon", "G", "MAN", "W", "P", "MT", "J", "REM", "Y", "m", "N", "O", "OM", "MC", "B", "CM", "MR", "JM", "MN", "D", "Ch", "H", "K", "MI", "Ms", "IM", "MO", "LM", "RM", "A", "I", "Mode", "X", "E", "EM", "S", "L", "PM", "F", "U", "Q", "TM", "MS", "MX", "MM", "NM", "VM", "DM", "AM", "Manager"], "l": ["lab", "t", "g", "c", "lines", "loc", "nl", "ls", "like", "b", "v", "rl", "lt", "a", "log", "range", "ul", "li", "lin", "il", "z", "dl", "r", "el", " L", "left", "layer", "list", "p", "la", "h", "yl", "ll", "ol", "ly", "len", "at", "f", "m", "al", "base", "n", "fl", "ml", "o", "lp", "lr", "pl", "d", "lit", "le", "lo", "jl", "kl", "ch", "lay", "long", "local", "lc", "hl", "tl", "lb", "L", "sl", "ln", "all", "label", "lis"], "i": ["ti", "int", "ini", "ic", "y", "u", "pi", "t", "m", "li", "ie", "xi", "n", "it", "ix", "c", "il", "z", "e", "k", "zi", "ij", "iu", "r", "ir", "ai", "b", "im", "ri", "I", "si", "mi", "v", "gi", "ii", "ip", "ci", "p", "ji", "a"], "j": ["jl", "J", "jj", "y", "t", "f", "m", "li", "g", "n", "kj", "c", "aj", "z", "js", "bi", "jp", "e", "dj", "k", "ij", "jc", "q", "r", "b", "o", "v", "jump", "uj", "p", "ji", "job", "oj"], "empty_mat": ["empty_mot", "empty2mat", " empty_ct", "empty2at", " empty_at", "empty67col", "empty___dat", "empty_col", "complete_mat", "empty_at", "empty67mat", " empty2list", "complete_mot", "complete___mat", "empty___mat", "empty___mot", "empty_list", "empty67dat", "empty2list", " empty2mat", "empty_man", " empty_man", "empty___cat", "complete_col", " empty2at", "empty67mot", "empty_ct", "empty2man", "empty_cat", "empty___col", "complete___mot", "empty_dat", " empty_cat", " empty2man", "complete___dat", "complete_dat", "empty___list", "empty___ct", "complete___col", " empty_list"], "found": ["sent", "valid", "result", "conf", "compl", "printed", "first", "ed", "initialized", "search", "created", "t", "f", "connected", "done", "index", "failed", "seen", "released", "finding", "identified", "filled", "shown", "diff", "find", "used", "stable", "count", "matched", " Found", "fixed", "given", "confirmed", "loaded", "success", "started", "fd", "error", "hit", "ent", "built", "all", "d", "finder", "pos", "form", "Found"], "output": ["data", "result", "value", "message", "string", "successful", "figure", "comment", "file", "generated", "input", "new", "tail", "null", "network", "current", "header", "bool", "ut", "plot", "text", "put", "detail", "shell", "option", "write", "buffer", "body", "response", "config", "update", "table", "example", "hidden", "module", "format", "left", "o", "path", "display", "html", "net", "str", "answer", "Output", "pretty", "print", "out", "success", "document", "command", "position", "error", "debug", "next", "type", "cut", "job", "come", "section", "ion", "summary", "outer", "log"], "mine_placement": ["mine_lacements", "mine_placing", "mine_plification", "mine_replacements", "mine_lacement", "mine_Plancy", "mine_plancy", "mine_lancy", "mine_splacement", "mine_participancy", "mine_pracing", "mine_participacement", "mine_replification", "mine_pracement", "mine_splification", "mine_replacing", "mine_splacing", "mine_participination", "mine_Placements", "mine_Plination", "mine_placements", "mine_pracements", "mine_Placement", "mine_participacements", "mine_replacement", "mine_splacements", "mine_lination", "mine_prification", "mine_plination"], "mat": ["Mat", "match", "lab", "att", "multi", "it", "lat", "c", "mt", "tmp", "grid", "table", "co", "mem", "batch", "path", "flat", "net", "mon", "dt", "sum", "ct", "ma", "log", "json", "cont", "li", "lin", "db", "r", "dict", "ret", "md", "mun", "out", "list", "p", "h", "kat", "ll", "stat", "mk", "doc", "mode", "at", "m", "vec", "mol", "plot", "tm", "rm", "bat", "mac", "ml", "nt", "MAT", "mr", "cat", "mot", "act", "col", "tab", "pos", "pat", "result", "rt", "tree", "np", "text", "test", "unit", "set", "mm", "man", "jac", "tt", "format", "cache", "hat", "cm", "mate", "mit", "dat"], "cell": ["ell", "tex", "butt", "cp", "cells", "slice", "lay", "word", "case", "cin", "cer", " Cell", "cel", "c", "shell", "Cell", "column", "check", "table", "call", "entry", "client", "q", "co", "el", "ql", "ck", "pixel", "ce", "cache", "field", "edge", "sel", "tile", "page", "char", "col", "row", "tab", "square", "item", "tc", "label", "job", "cc"], "line": ["range", "sample", "result", "match", "comment", "ine", "note", "input", "pair", "ze", "word", "case", "inline", "m", "li", "phrase", "quote", "text", "lin", "lined", "lines", "write", "lock", "e", "set", "query", "column", "nl", "unit", "q", "entry", "change", "liner", "block", "format", "left", "email", "term", "source", "edge", "frame", "eline", "define", "field", "Line", "out", " Line", "list", "ln", "code", "link", "page", "position", "lo", "online", "row", "col", "lt", "LINE", "le", "item", "name", "string", "log", "ide"], "T": ["V", "GT", "W", "P", "TB", "Time", "TN", "t", "Y", "N", "O", "B", "TA", "D", "TT", "H", "TY", "K", "I", "X", "TS", "S", "WT", "NT", "L", "F", "TR", "PO", "TM", "VT", "TO", "IT", "Z", "TC", "OT"], "testcase": ["Testtest", "showline", "caseCase", " testtest", "vercase", "testCase", "Testcase", " testCase", "Testline", "traintest", "trainCase", "traincase", "testline", " testline", "casecase", " testase", "testase", "caseline", "testtest", "showcase", "showCase", "Testase", "showtest", "verCase", "verline", "vertest", "casease", "TestCase"], "mat_cpy": ["mat_cibd", "mat_cbd", "mat_lcaxy", "mat_lcly", "mat_cple", "mat_csple", "mat___caxy", "mat_cly", "mat_cacheple", "mat_cPy", "mat_ccpy", "mat___vcly", "mat_caxy", "mat_ppy", "mat_rcbd", "mat_cps", "mat_rcps", "mat___vcpy", "mat_cachepl", "mat_ciny", "mat_cipy", "mat_rcopy", "mat_lcPy", "mat_csPy", "mat_rcply", "mat_rcumpy", "mat_cachePy", "mat_pply", "mat_vcpy", "mat_rcpy", "mat_ccopy", "mat___cpy", "mat_lcpy", "mat_ciopy", "mat___cly", "mat_cachepy", "mat_cply", "mat_Cpy", "mat_Caxy", "mat_rciny", "mat_mcpy", "mat_copy", "mat_cpl", "mat_pumpy", "mat_mcPy", "mat_vcaxy", "mat___vcaxy", "mat_vcly", "mat_lcply", "mat_Cly", "mat_cspl", "mat_lcumpy", "mat_cciny", "mat_coPy", "mat_rcPy", "mat_cops", "mat_cspy", "mat_mcpl", "mat_cumpy", "mat_ciiny", "mat_ccbd", "mat_mcple", "mat_lcps"], "oneclickcells": [" oneclickbands", "onetrackrows", "oneleafbands", "onecloudlocks", "onecommenters", "onecloudcells", " onewaitlets", " onewaitcells", "oneckvalues", "oneclickrooms", "oneleafrows", " onecloudlocks", "oneloaddevices", "oneclickbands", "onecommentrooms", " oneclickrooms", "oneclicklines", "oneclickvalues", "oneloadcells", "onewaitvalues", "oneloadparts", "oneclickcell", "onetrackbands", "onecloudrows", "onewaitcells", "onelinelines", " oneclicklocks", "oneClickvalues", " oneclickparts", "onefocuscells", "onetracklocks", "oneClickcells", " onecommentrooms", " oneclickvalues", " onecloudcells", "oneclickers", " onecommentcell", "oneleaflocks", "onecheckcells", "onefocusrooms", " onecommentcells", " onecloudbands", "oneClicklets", "onecheckrooms", "oneleafcells", "onecklets", " onewaitvalues", "oneclicklocks", "onecloudbands", "onelinecells", "onecommentcells", "onefocuscell", " oneclickers", " oneclicklines", "onelineparts", "onecheckcell", "oneclicklets", " oneclicklets", " onecloudrows", " oneclickrows", "onefocusers", "onecommentcell", "onecheckers", " oneclickcell", "onetrackcells", "oneclickdevices", "oneclickparts", " oneclickdevices", "oneloadlines", "onelinedevices", "oneckcells", "oneclickrows", " onecommenters", "onewaitlets"], "node": ["nd", "conn", "note", "t", "c", "tmp", "proc", "k", "component", "source", "ode", "worker", "wrapper", "num", "link", "instance", "index", "window", "client", "entry", "mid", "se", "station", "sel", "device", "child", "parent", "post", "name", "job", "Node", "bo", "m", "slave", "n", "id", "nn", "student", "ne", "normal", "no", "self", "edge", "sim", "image", "part", "box", "nb", "seed", "object", "tree", "np", "ind", "key", "test", "local", "manager", "our", "msg", "obj", "holder", "cache", "slot", "field", "wife", "server", "nw", "row", "day", "item", "dd", "label"], "f_in": [" f_IN", "file_ins", "file_din", " f_din", "f_In", "file_out", "f_din", "file_in", "f_ins", " f_In", " f_ins", "f_IN"], "f_out": [" f_output", "foutOUT", "f2OUT", "f2w", "f_w", " f2in", " f2w", " f2OUT", "foutw", "f2out", " f_t", "f_err", "f2err", " f_Out", "f2Out", "f2in", "f_output", "f_Out", "f_OUT", "foutout", " f_err", " f_w", " f_OUT", "foutin", "f_t", " f2out"]}}
{"code": "\\n  f = open( sys.argv[1] )\\n  f.readline()\\n  \\n  numcases = 1\\n  input = f.readline()\\n  while input != \"\":\\n  \tinC,inF,inX = [float(x) for x in input.split()]\\n  \\n  \tstart = (0.0,0.0,2.0)\\n  \th = [start]\\n  \tchecked =set()\\n  \\n  \twhile h[0][1] < inX:\\n  \t\tx = heapq.heappop(h)\\n  \\n  \t\tif x in checked:\\n  \t\t\tcontinue\\n  \t\telse:\\n  \t\t\tchecked.add(x)\t\\n  \\n  \t\ttime,numCookies,rate = x\\n  \t\ttimeW = (inX - numCookies) / rate\\n  \t\theapq.heappush( h,(time+timeW,numCookies+rate*timeW,rate) )\\n  \\n  \t\ttimeF = (inC - numCookies) / rate\\n  \t\tnewC = numCookies + rate*timeF\\n  \t\tnewT = time + timeF\\n  \t\theapq.heappush( h,(newT,(newC - inC),rate+inF) )\\n  \t\theapq.heappush( h,(newT,newC,rate) )\\n  \\n  \toutput = \"{:.7f}\".format(h[0][0])\\n  \\n  \tprint \"Case #\"+str(numcases)+\": \"+output\\n  \tinput = f.readline()\\n  \tnumcases += 1\\n  \t\\n", "target": "10", "substitutes": {"f": ["fed", "ef", "inf", "af", "file", "u", "w", "cf", "t", "g", "fast", "l", "fx", "c", "fs", "bf", "fb", "e", "fl", "r", "q", "tf", "elf", "b", "fc", "fo", "o", "fg", "uf", "alf", "ret", "ff", "v", "F", "fw", "fd", "fr", "df", "p", "fp", "fm", "i", "lf", "form", "be"], "numcases": ["umtests", "Numcases", "NUMtests", "umchecks", "numbercases", "numbertests", "NUMtimes", " numcase", "numchecks", " numtests", "numcase", "numtests", "nchecks", "ntests", "ncases", "Numtests", "NUMcases", "numberlines", "Numlines", "sumtests", "numtimes", "sumchecks", "Numtimes", "ntimes", " numtimes", "umcase", "umcases", "umtimes", "NUMcase", "sumtimes", "sumcases", "numbertimes", " numlines", "numlines"], "input": ["more", "sample", "int", "cmd", "comment", "file", "csv", "history", "case", "xml", "Input", "qa", "current", "up", "wrong", "index", "text", "PUT", "pattern", "step", "init", "put", "this", "buffer", "set", "focus", "unit", "config", "sequence", "control", "q", "state", "initial", "reset", "context", "batch", "left", "request", "unknown", "raw", "source", "active", "prefix", "before", "out", "you", "command", "ip", "error", "open", "feed", "next", "p", "all", "each", "found", "string", "label", " Input"], "inC": ["ineR", "ineC", "outT", "intL", "outD", "inT", " inT", "outL", "ineCL", " inH", "outX", " inL", "intC", "inCL", "innerD", " inD", "inL", "ineCo", "inCo", "innerC", "outH", "outF", "inD", "innerT", " inCo", "iniCo", "outC", " inR", "inR", "intF", "inH", "intX", "innerH", " inCL", "iniR", "iniCL", "iniC"], "inF": ["INF", "InH", "InF", "inputH", "inB", "INR", " inH", "inputB", "iC", "ginV", "INH", "InV", "inV", "inputV", "ginH", "iR", "iH", " inR", "ginB", "inR", "InB", "inH", "inputF", "INC", "ginF", "iF"], "inX": ["INV", "innN", "inZ", "outT", "InX", "INZ", "onEX", " inY", "inN", "InZ", "innT", "inT", " inT", " inEX", "outN", "outX", "onY", "INT", "InV", "inV", "onF", "INX", "dinEX", " inN", "InT", "dinX", " inV", "outC", "inY", "innC", "dinY", "onX", "innX", "inEX", "dinF", " inZ"], "x": ["mx", "cox", "ax", "sex", "y", "xs", "pair", "xt", "t", "xe", "xd", "w", "xxxxxxxx", "xml", "xi", "xp", "n", "ix", "xa", "step", "fx", "lex", "c", "key", "z", "xy", "e", "rx", "check", "xb", "r", "xes", "el", "px", "xf", "X", "xx", "dx", "wx", "v", "ox", "ex", "inx", "ctx", "ux", "p", "ct", "xc", "i", "tx"], "start": ["seed", "size", "first", "y", "w", "new", "t", "st", "sp", "current", "base", "n", "offset", "step", "index", "key", "c", "init", "name", "set", "check", "root", "id", "begin", "r", "Start", "reset", "j", "v", "now", "started", "end", "head", "p", "a", "stop", "starting", "i"], "h": ["hr", "s", "hal", "hw", "ch", "here", "w", "th", "t", "ha", "history", "m", "hs", "g", "ho", "n", "he", "l", "sh", "c", "z", "hp", "uh", "set", "k", "kh", "ph", "hd", "H", "q", "r", "host", "hex", "hz", "b", "hl", "o", "bh", "i", "hash", "rh", "ah", "v", "hm", "dh", "oh", "ih", "has", "p", "hh", "pp", "each", "ht"], "checked": ["checking", "locked", "worked", "reported", "xs", "called", "connected", "current", "ordered", " unchecked", "selected", "occupied", "done", "claimed", "linked", "installed", "seen", "added", "verified", "status", "set", "check", "held", "ready", "restricted", "registered", "broken", "picked", "healthy", "tested", "active", "checks", "used", "fixed", "ox", "enabled", "confirmed", "opened", "loaded", "pressed", "finished", "critical", "started", "found", "changed", "closed"], "time": ["timer", "length", "duration", "value", "message", "Time", "tree", "timeout", "size", "frequency", "date", "t", "history", "etime", "ime", "current", "offset", "index", "test", "tm", "user", "runtime", "TIME", "check", "local", "id", "tt", "change", "point", "counter", "count", "age", "before", "now", "race", "weight", "speed", "tim", "mean", "delay", "create", "transform", "hour"], "numCookies": ["NumCooks", "numBindies", " numcookIES", " numCookIES", "Numcookories", "numCookries", " numcookessions", "numcookries", "numCies", " numCookys", "numCs", "Numcookers", "Numcookries", "numCories", "numCookories", "numCookessions", "numCessions", "numChers", "numBindessions", "numCountessions", "numcookies", "Numcookies", "NumCookessions", "numBindIES", "NumCookers", "numCounties", "numcookIES", "numChs", " numBinds", " numcookies", " numCookers", "numBindories", "numCooks", "numBindries", " numcookers", "NumCookries", " numBindys", "Numcookessions", " numCookessions", " numCookories", " numcookys", " numCooks", "numBinders", "numCopories", "numcookories", "numCookers", " numBindies", "numcookys", " numcooks", "numCops", "NumCookories", "numBinds", "numcookers", "numCountries", "numcookessions", "numcooks", "numChies", "numBindys", " numBindories", "Numcooks", "numChIES", "NumCookies", "numCopers", "numCounts", "numCys", "numCopies", "numCookIES", "numCookys"], "rate": ["range", "duration", "length", "power", "rates", "ate", "rice", "core", "domain", "timeout", "trade", "ine", "frequency", "mode", "rating", "date", "prime", "peed", "handle", "fee", "sync", "ime", "base", "phrase", "width", "grade", "late", "rat", "test", "rand", "status", "write", "fine", "factor", "rank", "re", "sequence", "r", "ride", "depth", "rule", "term", "priority", "se", "cycle", "currency", "age", "force", "erate", "Rate", "te", "use", "race", "code", "weight", "speed", "error", "mean", "scale", "delay", "type", "price", "rage", "create", "score"], "timeW": ["depthWh", "TimeW", "depthW", "TimeV", "imeL", "timeWh", " timeS", "depthL", "imeW", " timeWh", "timeV", "imeV", "imeF", "TimeS", "timeL", " timeV", "imeS", " timeL", "timeS", "TimeF", "imeWh"], "timeF": ["imeX", "rankf", "distanceF", "timeFL", "timesF", "timesW", "timFL", "TimeW", "TimeFL", "timW", "distanceRF", "timf", "timeX", "imeL", "timeRF", "distanceX", "imeOF", "rankF", "imeW", " timeOF", "imeF", "rankW", "imeRF", "rankFL", " timeRF", "timeL", "timesOF", "timeOF", " timeL", "timesL", "timF", "distanceW", " timeX", "TimeF", "Timef", "timef"], "newC": ["newF", "NewN", "nextT", "newN", "nextL", " newN", "NewL", "NEWF", "nextC", "newL", "NEWT", "NEWC", "nextN", " newL", "NewC", "NewF", "NEWN", "nextF", "NewT"], "newT": ["newsZ", "longH", "nextT", "NewH", "nextZ", "createZ", "nextTT", "longC", "nextL", "newsC", "createTT", "NewL", "newH", "nextC", "newL", "createC", "createT", "newsTT", " newR", "nextR", "newZ", " newL", "NewC", "newsT", "newR", "NewR", "newTT", "longT", "NewT", "longR", "nextH"], "output": ["result", "value", "message", "successful", "quiet", "new", "O", "echo", "text", "PUT", "put", "write", "dot", "response", "ou", "connection", "auto", "o", "format", "line", "written", "Output", "print", "out", "voice", "success", "position", "end", "exit", "console", "string", "enum"]}}
{"code": "\\n  def makeBoardR(b):\\n  \tnumR, numC, numMines, filledR, filledC = b\\n  \tq = numMines / numR\\n  \tr = numMines % numR\\n  \\n  \tif q <= numC-2 and r == 0:\\n  \t\tboard = [\"*\"*(filledC + numC) for x in range (filledR)]\\n  \t\tboard.append( \"*\"*(filledC+q)+\".\"*(numC-q) )\\n  \t\tboard.append( \"*\"*(filledC+q)+\".\"*(numC-q-1)+\"c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telif numMines == numR * numC - 1:\\n  \t\tboard = [\"*\"*(filledC + numC) for x in range (filledR+1)]\\n  \t\tboard.append( \"*\"*(filledC+numC-1)+\"c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telse:\\n  \t\toutput = \"Impossible\"\\n  \\n  \treturn output\\n  \\n  def makeBoardC(b):\\n  \tnumR, numC, numMines, filledR, filledC = b\\n  \tq = numMines / numC\\n  \tr = numMines % numC\\n  \\n  \tif q <= numR-2 and r == 0:\\n  \t\tboard = [\"*\"*(filledC+numC) for x in range(filledR+q)]\\n  \t\tfor x in range( numR-1-q ):\\n  \t\t\tboard.append( \"*\"*filledC + \"..\" )\\n  \t\tboard.append( \"*\"*filledC + \".c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telif numMines == numR * numC - 1:\\n  \t\tboard = [\"*\"*(filledC+numC) for x in range(filledR+numR-1)]\\n  \t\tboard.append( \"*\"*(filledC+numC-1) + \"c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telse:\\n  \t\toutput = \"Impossible\"\\n  \treturn output\\n  \\n  def makeBoard(b):\\n  \tnumR, numC, numMines, filledR, filledC = b\\n  \tq = numMines / (numC-2)\\n  \tr = numMines % (numC-2)\\n  \\n  \tboard = [\"*\"*(numC+filledC) for x in range(filledR)]\\n  \tfor x in range(q):\\n  \t\tboard.append( \"*\"*(numC-2+filledC)+\"..\" )\\n  \tboard.append( \"*\"*(r+filledC)+\".\"*(numC-r) )\\n  \tfor x in range(numR-q-2):\\n  \t\tboard.append( \"*\"*filledC+\".\"*numC )\\n  \tboard.append( \"*\"*filledC + \".\"*(numC-1) + \"c\" )\\n  \treturn \"\\n\".join(board)\\n  \\n  def makeBoard0(b):\\n  \tnumR,numC,numMines,filledR,filledC = b\\n  \tboard = [\"*\"*(numC+filledC) for x in range(filledR)]\\n  \tfor x in range(numR-1):\\n  \t\tboard.append( \"*\"*(filledC)+\".\"*numC )\\n  \tboard.append( \"*\"*(filledC) + \".\"*(numC-1) + \"c\" )\\n  \treturn \"\\n\".join(board)\\n  \\n  f = open( sys.argv[1] )\\n  f.readline()\\n  \\n  numCase = 1\\n  l = f.readline()\\n  while l != \"\":\\n  \tnumR, numC, numMines = [int(x) for x in l.split()]\\n  \\n  \tboards = deque()\\n  \tif numR == 1:\\n  \t\tif numC == 1 and numMines == 0:\\n  \t\t\toutput = \"c\"\\n  \t\telif numC == 1 and numMines > 0:\\n  \t\t\toutput = \"Impossible\"\\n  \t\telse:\\n  \t\t\toutput = \"*\"*numMines + \".\"*(numC-numMines-1) + \"c\"\\n  \telif numC == 1:\\n  \t\toutput = \"\\n\".join(\"*\"*numMines + \".\"*(numR-numMines-1) + \"c\")\\n  \telse:\\n  \t\tboards.append( (numR,numC,numMines,0,0) )\\n  \t\toutput = \"Impossible\"\\n  \\n  \twhile output == \"Impossible\" and len(boards) > 0:\\n  \t\tb = boards.popleft()\\n  \t\tnumR,numC,numMines,filledR,filledC = b\\n  \t\tif numMines == 0:\\n  \t\t\toutput = makeBoard0(b)\\n  \t\t\tbreak\\n  \\n  \t\tif numMines >= numC and numR > 2:\\n  \t\t\tboards.append( (numR-1,numC,numMines-numC,filledR+1,filledC) )\\n  \t\tif numMines >= numR and numC > 2:\\n  \t\t\tboards.append( (numR,numC-1,numMines-numR,filledR,filledC+1) )\\n  \\n  \t\tif numMines <= (numR-2)*(numC-2):\\n  \t\t\toutput = makeBoard(b)\\n  \\n  \t\tif numR == 2:\\n  \t\t\toutput = makeBoardR(b)\\n  \\n  \t\tif numC == 2:\\n  \t\t\toutput = makeBoardC(b)\\n  \t\t\\n  \tprint \"Case #\"+str(numCase)+\":\\n\"+output\\n  \tl = f.readline()\\n  \tnumCase += 1\\n", "target": "10", "substitutes": {"b": ["wb", "nb", "bt", "ob", "blue", "pb", "gb", "lab", "y", "lib", "bo", "w", "t", "m", "g", "base", "bb", "n", "bool", "bitcoin", "B", "c", "h", "bf", "bi", "sub", "amb", "ab", "fb", "db", "e", "bp", "ref", "br", "batch", "fa", "o", "bh", "bc", "be", "back", "obj", "bs", "self", "lb", "bl", "v", "pre", "ib", "sb", "ba", "mb", "bis", "cb", "eb", "p", "d", "erb", "a", "bg", "rb", "bar"], "numR": ["umBR", "numRO", "getR", " numRO", "numberGR", "timL", "numG", "NumR", "numD", "umP", "umT", "umM", "numL", "timr", " numL", "numberM", "NumG", "numberP", "NumM", "nR", "filledr", " numG", "getBR", "nBR", " numD", "hotRat", "numP", "monGR", "umC", "numberL", "monL", "namC", "numberr", "namR", "numberC", "monRat", " numP", "monRO", "numr", "nRO", "monr", "umR", " numM", "monD", " numA", "hotR", "hotT", "numRat", "namM", "namA", " numB", "nC", "numberR", "monR", "numB", "timRO", "monG", "umRO", "numberD", "getC", " numr", "numM", "getRO", "hotC", "monB", "monP", "numA", "NumA", "NumC", "numBR", "monT", "numberB", "monC", "filledGR", "numGR", "numT", "timR", "umRat", "NumP"], "numC": ["um10", "numCAR", "phyCC", "numCB", "phoneCs", "numN", "moneyR", "NumB", "numberS", "numG", "NumR", "NumSC", "numD", "numberedD", "filledD", "numV", "umT", "omR", "NUMG", "numberc", "numberCM", "numberG", "umS", "snapR", "numL", "snapC", "omCM", "numberedR", "entityC", "dateCC", "tenc", "filledCode", "numCC", "netCs", "currentC", " numL", "numberCB", " numN", "netWC", "tenC", "umB", "snapc", "numberedCond", " numG", "primc", "zeroCM", "monS", "numP", "entityP", "dimCM", "currentAC", "umC", " numSC", "primC", " numCM", "phyC", "umWC", "numberC", "tenR", " numP", "NUMN", "zeroCh", "entityJC", "numberedC", "numAC", "numc", "monCh", "omC", "currentT", "umR", "snapCM", "entityR", "umG", "monc", "omCC", "phyR", "namedWC", "NumL", "monD", "NUMR", "num10", "monCM", "monV", "umCC", "monJC", "numCh", "dimR", "numCs", "namedCAR", "dateR", "umAC", "netc", "primR", " numB", "NumJC", "netC", "numberT", "numberR", "monR", "numB", "numCond", "numWC", "monCB", "monG", "NumCM", "numS", "dateB", "moneyCM", "tenWC", "filledCB", "dateC", "filledCond", "currentR", "NUMC", "zeroR", "zeroCC", "dimC", "numberedCode", "zeroV", "primV", "namedR", "namedC", "phyCh", "phoneWC", "monCC", "monCond", "tenB", "numSC", "zeroC", "umCM", "tenCs", "numberAC", "phonec", "monB", "monCode", "tenSC", "moneyC", "dotCM", "monP", "dimL", "zeroc", "dotR", "monN", "NumC", "dotCC", "monT", "monWC", "monCAR", "umCAR", "numberB", "monC", "numCM", " numT", "number10", "filledG", "money10", "dotC", "numJC", "numCode", "numT", "phoneC", "numberCC", "NumP"], "numMines": ["numVines", "sumMains", "numEmanes", "numChians", "numMine", "numRins", " numNines", "NumRined", "NUMMessine", "numRanes", "numDelines", "numberNine", "numPoons", "numRoons", "numEelines", "numVelines", "sumManes", "numManiners", "numPanes", "numMiners", "numLiners", "NUMmists", "numDiners", "numLains", "numberMined", "nummists", "numRine", "NumMined", "numRemanes", "numDines", "NUMminers", "nmMiners", "NumManes", "numNines", "numDoons", "nmChiners", "numDins", "numNodes", "numminers", "numDodes", "nummoons", "nmChanes", "numMined", "numRemines", "sumEmines", "NumMelines", "numDanes", "numNins", "nmMines", "sumMelines", "numNites", "numMessodes", "nmManes", "numEanes", " numChines", "NUMMine", "numReminers", "numChodes", "numPiners", "numEmine", "NumRanes", "sumMoons", "numEminers", " numNodes", "numRined", "numberRiners", "nmMelines", "numMains", "sumEmoons", "sumMians", "sumMines", " numChine", "numDined", "sumEminers", "numChines", "numModes", "numBodes", "nmChelines", "numLians", "numMists", "numberNiners", "numLelines", "numberMines", "NUMMessodes", "numManined", "numEined", "numChined", "sumEmanes", "numEmoons", "numNelines", "numEines", "NUMMians", "numMelines", "NUMMines", "NUMmoons", "numEmins", "numChelines", "numberMists", "numChine", "numNiners", " numManes", "numberMins", "numEmines", " numMined", " numChanes", "numLines", "numMites", " numNins", "nmChines", "numberMelines", "numberNelines", "numMians", "numNists", "numRelines", "numNians", "NUMMessines", "numLins", "numberNins", "numberNists", "numNined", "numRiners", "numMessians", "numBins", "numMins", "numMessines", "nummines", "numRists", "numPines", "NumMines", "NUMmines", "numberRines", "numDites", "numChanes", "numberRins", "NUMMoons", "numManines", "NUMMessians", "numManins", "numberMiners", "numBines", " numModes", "numMoons", "NUMMists", " numMites", "numChiners", "numLined", " numMine", "NumRelines", "NumRines", "numRines", "numVined", "NUMMiners", "numLists", "NUMModes", "numNine", "numBites", "numRemelines", " numChined", "numberNines", " numNites", "numberNined", "numManes", "numVists", "numMessine", "numberRined", " numMins", "sumMiners", "numberMine", "numChains"], "filledR": ["illedH", "illedP", "killedRight", "illedRes", "illedB", "loadedK", "killedC", "occupiedR", "illedC", "illedr", "numV", "illedW", "killedH", "builtW", "filledL", "occupiedG", "loadedr", " filledRight", "filledH", "linkedX", "filledW", "loadedV", "packedG", "illedK", "illedL", "loadedR", "illedR", "killedRes", "filledB", "killedX", "builtC", "loadedC", "numr", "builtH", "linkedR", "filledP", "packedB", "killedW", "killedR", "occupiedB", " filledL", "filledRes", " filledX", "illedRight", "filledK", " filledP", "filledV", "filledRight", "linkedRes", "builtR", "loadedL", "packedR", " filledr", "illedV", "illedG", "illedX", "linkedC", "killedP", "filledG", "linkedK", "filledX", "filledr"], "filledC": ["representedDC", "illedCons", "illedB", "paintedC", "illedH", "builtc", "illedc", "illedDC", "killedC", "paintedCustom", "ashedCAR", "representedA", "fullCC", "printedCC", "markedL", "illedC", "filledCE", "filledAC", "markedc", "markedTC", "keptR", "packedC", "filledL", "connectedChar", "packedA", "illedA", "focusedAC", "ashedR", "linkedCC", "filledYC", "illedCC", "linedc", "filledH", "filledCR", "connectedC", "selectedT", "ashedC", "loadedSC", "illedL", "claimedA", "claimedYC", "illedCAR", "loadedR", "coloredCNN", "illedR", "coloredAC", "filledB", "illedChar", "fillCAR", "paintedDC", "placedC", "builtC", "filledCar", "registeredCC", "focusedCE", "loadedC", "fullC", "filledCAR", "illedSC", "illedQ", "keptCC", "illedCar", "filledQ", "loadedCAR", "poweredCo", "linkedR", "filledSC", "claimedC", "fullCo", "registeredC", "filledCo", "representedCustom", "representedc", "ashedCR", "poweredCC", "representedCons", "linedTC", "filledc", "killedR", "filledCons", "linkedH", "illedTC", "representedC", "placedCAR", "filledT", "illedCNN", "illedCE", "filledTC", "connectedCar", "claimedc", "fillR", "poweredCAR", "poweredC", "placedCo", "coloredH", "filledDC", "loadedCC", "coloredR", "focusedC", "filledCNN", "printedCar", "paintedB", "linedL", "printedChar", "illedCustom", "fillSC", "placedCC", "representedB", "selectedR", "connectedCC", "packedc", "fillC", "registeredQ", "selectedC", "linkedCR", "filledCC", "illedAC", "packedCons", "coloredCR", "builtYC", "printedC", "illedCR", "registeredR", "illedYC", "filledA", "linkedQ", "linkedC", "fullCAR", "coloredC", "keptC", " filledCNN", " filledCR", "markedC", "filledChar", "builtA", "killedT", "linkedCAR", "coloredCE", "numT", "linedC", "filledCustom"], "q": ["s", "conf", "ike", "u", "t", "req", "ag", "g", "eq", "it", "c", "query", "k", "que", "ph", "j", "rc", "ek", "v", "ih", "alpha", "type", "pp", "w", "xt", "qual", "quest", "z", "e", "el", "qi", "qv", "quant", "qq", "ke", "p", "exp", "h", "err", "ail", "ile", "ld", "ine", "m", "n", "fx", "rm", "id", "kg", "ep", "ur", "requ", "ry", "qs", "ill", "ik", "Q", "d", "i", "ht", "resh", "iq", "kl", "rt", "ue", "ch", "y", "ic", "pe", "pg", "qa", "qu", "ix", "key", "dq", "kw", "re", "sq", "ql", "ck", "count", "aq", "ox", "er", "fy", "ock", "qt"], "r": ["range", "hr", "s", "rr", "cr", "rt", "dr", "y", "u", "w", "pair", "t", "g", "m", "url", "n", "nr", "rd", "c", "h", "sr", "e", "rs", "rank", "id", "re", "ir", "br", "ro", "ra", "ar", "o", "ur", "pr", "R", "rc", "j", "res", "v", "str", "er", "right", "fr", "run", "p", "d", "all", "a", "err", "i"], "board": ["stri", "lib", "stack", "case", "wheel", "uno", "table", "bird", "batch", "ward", "bit", "craft", "builder", "book", "loop", "bench", "division", "pool", "buffer", "bus", "boat", "client", "room", "bro", "oard", "stream", "layer", "out", "won", "beat", "form", "bot", "ard", "bo", "stone", "word", "panel", "flo", "body", "bank", "video", "back", "flow", "box", "layout", "bowl", "onto", "Board", "front", "pair", "lay", "view", "band", "channel", "way", "runner", "lock", "user", "system", "rank", "bang", "control", "bd", "block", "land", "ui", "chain", "bridge", "player", "boarding", "ack", "boot", "deck", "row", "component", "display"], "x": ["mx", "ax", "y", "w", "xs", "xt", "on", "t", "xe", "xd", "yx", "xi", "xp", "n", "ix", "xa", "qu", "index", "lex", "fx", "ext", "z", "full", "xy", "check", "rx", "xb", "mix", "ous", "xes", "co", "xf", "sw", "X", "xx", "wx", "dx", "ox", "xc", "num", "ex", "inx", "wh", "ctx", "ux", "ct", "h", "post", "tx"], "output": ["lib", "ilo", "write", "batch", "production", "net", "answer", "pretty", "exit", "console", "summary", "successful", "figure", "comment", "network", "none", "buffer", "client", "print", "out", "layer", "list", "command", "come", "section", "string", "outer", "job", "message", "quiet", "collection", "input", "detail", "option", "status", "body", "response", "interface", "monitor", "document", "values", "result", "python", "value", "object", " Output", "information", "tree", "four", "public", "current", "channel", "echo", "text", "put", "config", "control", "product", "block", "format", "unknown", "line", "Output", "commit", "success", "error", "writing", "content", "component", "display"]}}
{"code": "\\n  \\n  def click(C, F, X):\\n      states = Queue.PriorityQueue()\\n  \\n      states.put((0.0, 2.0, False))\\n      while not states.empty():\\n          time, rate, is_done = states.get()\\n  \\n          if is_done:\\n              return time\\n  \\n          states.put((\\n              time + X / rate,\\n              rate,\\n              True\\n          ))\\n  \\n          states.put((\\n              time + C / rate,\\n              rate + F,\\n              False\\n          ))\\n  \\n      return None\\n  \\n  def main():\\n      cases = int(sys.stdin.readline())\\n  \\n      for case in range(cases):\\n          C, F, X = map(float, sys.stdin.readline().split())\\n          print 'Case #%d: %.7f' % (case + 1, click(C, F, X))\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "target": "11", "substitutes": {"C": ["V", "AC", "CS", "G", "W", "P", "CI", "IC", "Time", "CNN", "CC", "CO", "Y", "N", "M", "FC", "MC", "B", "CM", "Car", "c", "D", "CF", "Ch", "Cs", "H", "K", "LC", "CE", "CT", "JC", "CU", "DC", "CD", "T", "A", "I", "R", "E", "CP", "EC", "CA", "NC", "S", "Cons", "U", "L", "Config", "CR", "CBS", "Q", "Z", "WC", "Co", "SC"], "F": ["V", "G", "W", "P", "Time", "J", "Fred", "GF", "FR", "FS", "FER", "Y", "f", "Fs", "AF", "N", "M", "FC", "Float", "FI", "B", "Foreign", "D", "EF", "CF", "FL", "FD", "IF", "H", "DF", "T", "UF", "I", "R", "Fe", "E", "FO", "S", "FG", "WF", "L", "U", "FP", "Q", "SF", "OF", "Fin", "Z", "PF", "FF", "FE"], "X": ["V", "Tx", "W", "P", "IC", "Time", "J", "TX", "FX", "XY", "Y", "N", "M", "FC", "O", "EX", "Xi", "B", "CF", "XL", "IF", "H", "IX", "XX", "T", "DX", "I", "R", "E", "S", "U", "x", "L", "Rex", "UX", "XP", "Q", "XT", "OX", "Z", "XXX", "Ex", "FE"], "states": ["lets", "ids", "rates", "blocks", "times", "actions", "tracks", "plays", "services", "ds", "izes", "stats", "chains", "models", "gets", "steps", "finals", "States", "roots", "ients", "rots", "parents", "testers", "ates", "errors", "fs", "runs", "eds", "lines", "ends", "keys", "devices", "ns", "prints", "phones", "settings", "state", "rils", "rooms", "versions", "gs", "groups", "games", "charges", "results", "banks", "outs", "bs", "weights", "stories", "dates", "units", "ports", "users", "frames", "comes", "ories", "ags", "stores", "agents", "locks", "workers", "lights", "years", "ages", "vals", "values", "ians", "pins", "seconds", "flows", "bots"], "time": ["timer", "duration", "second", "s", "result", "value", "times", "stat", "Time", "timeout", "size", "port", "date", "t", "f", "m", "history", "current", "ime", "etime", "done", "total", "index", "when", "c", "z", "tm", "status", "runtime", "TIME", "set", "id", "event", "sequence", "state", "tt", "context", "path", "point", "year", "start", "cycle", "frame", "count", "ts", "clock", "age", "x", "before", "now", "speed", "tim", "delay", "all", "d", "stop", "seconds", "tx"], "rate": ["range", "duration", "length", "sample", "fps", "value", "power", "rates", "seed", "ate", "core", "timeout", "size", "frequency", "mode", "rating", "prime", "t", "f", "fee", "ime", "base", "capacity", "float", "test", "fine", "function", "sequence", "r", "ride", "state", "zero", "change", "rule", "se", "cycle", "counter", "frame", "res", "count", "currency", "process", "age", "force", "erate", "Rate", "race", "code", "speed", "scale", "delay", "type", "complex", "factor", "priority", "beat"], "is_done": [" is_seen", " is_used", " is_Done", "is_Done", "is_used", "is_seen"], "cases": ["cs", "Times", "ids", "uses", "times", "cells", "sections", "chains", "cycles", "models", "xs", "changes", "steps", "aps", "windows", "ces", "runs", "lines", "hands", "classes", "ends", "phones", "tones", "rooms", "caps", "flows", "charges", "events", "checks", "terms", "limits", "frames", "comes", "tests", "stores", "keyes", "codes", "rows", "ases", "orders", "points"], "case": ["seat", "choice", "ch", "catch", "zip", "pair", "mode", "condition", "step", "key", "test", "c", "switch", "lock", "set", "nce", "sequence", "example", "connection", "client", "cone", "rule", "number", "ce", "line", "character", "ASE", "count", "ase", "x", "trial", "race", "use", "ice", "num", "cas", "code", "row", "cd", "p", "ace", "chance", "name", "i", "Case"]}}
{"code": "\\n  NEIGHBOURS = [\\n      (-1, -1), (-1, 0), (-1, 1),\\n      ( 0, -1),          ( 0, 1),\\n      ( 1, -1), ( 1, 0), ( 1, 1),\\n  ]\\n  \\n  MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\n  \\n  def valid(size, location, changes):\\n      y, x = location\\n      for y1, x1 in changes:\\n          y1 += y\\n          x1 += x\\n          if y1 < 0 or y1 >= size[0]:\\n              continue\\n          if x1 < 0 or x1 >= size[1]:\\n              continue\\n          yield (y1, x1)\\n  \\n  def click(size, grid, location):\\n      y, x = location\\n      if grid[y][x] is 0:\\n          return None\\n  \\n      grid = [row[:] for row in grid]\\n      grid[y][x] = 0\\n  \\n      for y, x in valid(size, location, NEIGHBOURS):\\n          if grid[y][x]:\\n              grid[y][x] = False\\n  \\n      return grid\\n  \\n  def sweep(R, C, M):\\n      grid = [[True] * C for _ in range(R)]\\n      size = (R, C)\\n  \\n      if M + 1 == R * C:\\n          grid[0][0] = False\\n          return grid, (0, 0)\\n  \\n      states = []\\n      for y in range(R):\\n          for x in range(C):\\n              location = (y, x)\\n              states.append((click(size, grid, location), location))\\n  \\n      while states:\\n          grid, location = states.pop(0)\\n  \\n          mines_count = sum([sum(row) for row in grid])\\n          if mines_count == M:\\n              return grid, location\\n  \\n          if mines_count < M:\\n              continue\\n  \\n          for new_location in valid(size, location, NEIGHBOURS):\\n              new_grid = click(size, grid, new_location)\\n              if new_grid:\\n                  states.insert(0, (new_grid, new_location))\\n  \\n      return None\\n  \\n  def validate(size, grid, location):\\n  \\n      result = [row[:] for row in grid]\\n  \\n      y, x = location\\n      result[y][x] = sum([\\n          grid[y1][x1]\\n          for y1, x1 in valid(size, (y, x), NEIGHBOURS)\\n      ])\\n      assert result[y][x] == 0\\n  \\n      seen = set([location])\\n      locations = set([location])\\n  \\n      while locations:\\n          location = locations.pop()\\n          for y, x in valid(size, location, NEIGHBOURS):\\n              assert grid[y][x] is not True\\n              result[y][x] = sum([\\n                  grid[y1][x1]\\n                  for y1, x1 in valid(size, (y, x), NEIGHBOURS)\\n              ])\\n              if result[y][x] == 0 and (y, x) not in seen:\\n                  locations.add((y, x))\\n                  seen.add((y, x))\\n  \\n      for row in result:\\n          for col in row:\\n              assert col is not False\\n  \\n      for y, row in enumerate(result):\\n          output = ''\\n          for x, col in enumerate(row):\\n              if col is True:\\n                  output += '*'\\n              else:\\n                  output += str(col)\\n          print output\\n  \\n  \\n  def process(case, R, C, M):\\n      result = sweep(R, C, M)\\n  \\n      print 'Case #%d:' % (case + 1)\\n      if not result:\\n          print 'Impossible'\\n          return\\n  \\n      grid, location = result\\n      for y, row in enumerate(grid):\\n          output = ''\\n          for x, col in enumerate(row):\\n              if (y, x) == location:\\n                  output += 'c'\\n              elif col:\\n                  output += '*'\\n              else:\\n                  output += '.'\\n          print output\\n  \\n  \\n  \\n  def main():\\n      cases = int(sys.stdin.readline())\\n  \\n      for case in range(cases):\\n          R, C, M = map(int, sys.stdin.readline().split())\\n          process(case, R, C, M)\\n  \\n      return\\n      for case in range(100):\\n          R = random.randrange(51) + 1\\n          C = random.randrange(51) + 1\\n          M = random.randrange(R * C - 1) + 1\\n          process(case * 100000 + M - 1, R, C, M)\\n  \\n  \\n  if __name__ == '__main__':\\n      main()\\n", "target": "11", "substitutes": {"NEIGHBOURS": ["NEIGHBROULS", "NEIGHBOUNLS", "NEIGHBouRS", "NEIGHBANKRES", "NEIGHBROWRS", "NEIGHBROURS", "NEIGHBROUNPS", "NEIGHBROUNRS", "NEIGHBROWPS", "NEIGHBOOrs", "NEIGHBANKPS", "NEIGHBROURs", "NEIGHBROWLS", "NEIGHSBOUNrs", "NEIGHSBOURS", "NEIGHBANPS", "NEIGHBROUPS", "NEIGHBOUNPS", "NEIGHBOURES", "NEIGHSBOUNPS", "NEIGHBANRs", "NEIGHBOULS", "NEIGHBOWRs", "NEIGHBROUNLS", "NEIGHBROWRs", "NEIGHBANRS", "NEIGHBOUNRs", "NEIGHBOUPS", "NEIGHBOWRS", "NEIGHBOWPS", "NEIGHBOUNrs", "NEIGHBOOLS", "NEIGHBOUNRS", "NEIGHBANLS", "NEIGHSBOUNLS", "NEIGHBours", "NEIGHBouLS", "NEIGHBOOPS", "NEIGHBANKRS", "NEIGHSBOUPS", "NEIGHSBOULS", "NEIGHBOWLS", "NEIGHBouPS", "NEIGHSBOUrs", "NEIGHBOURs", "NEIGHBOWRES", "NEIGHBANKLS", "NEIGHBOUrs", "NEIGHBROUNRES", "NEIGHBOUNRES", "NEIGHSBOUNRS", "NEIGHBROURES", "NEIGHBOORS"], "MOVES": ["DMACHALS", "MOVED", "DMACHes", "DMOVes", "MANGED", "DMOVALS", "MOVes", "MOVALS", "MACHED", "DMACHED", "DMACHES", "MACHes", "MOTED", "MANGes", "MOTes", "DMOVES", "MANGALS", "DMOVED", "MOTALS", "MOTES", "MACHES", "MANGES", "MACHALS"], "size": ["range", "length", "zone", "power", "small", "empty", "mode", "SIZE", "ze", "m", "n", "scope", "width", "index", "capacity", "radius", "owner", "window", "dim", "general", "c", "z", "color", "area", "function", "unit", "set", "dimension", "settings", "example", "group", "time", "zero", "shape", "format", "see", "year", "number", "space", "start", "false", "source", "cycle", "sn", "style", "count", "news", "Size", "storage", "device", "now", "ger", "grow", "position", "south", "speed", "city", "scale", "square", "type", "sum", "height", "resolution", "name", "ize"], "location": ["address", "cell", "reference", "scope", "capacity", "copy", "loc", "definition", "zero", "modified", "creation", "uration", "translation", "coord", "usage", "type", "height", "ion", "instance", "expression", "range", "selection", "comment", "history", "owner", "region", "color", "function", "center", "entry", "density", "menu", "storage", "Location", "command", "position", "peer", "name", "length", "sample", "zone", "message", "collection", "vector", "resource", "place", "member", "present", "option", "where", "connection", "initial", "time", "go", "Position", "o", "point", "action", "document", "trace", "origin", "resolution", "box", "layout", "value", "file", "behavior", "condition", "ocation", "direction", "local", "original", "number", "move", "line", "slot", "description", "localhost", "directory", "node", "relation", "communication"], "changes": [" updates", "ions", "times", "actions", "names", " change", "xs", "details", "comments", "steps", "Changes", "history", "views", " jumps", "errors", " moves", "items", "lines", "keys", "rs", "options", "places", "settings", "change", "es", "diff", "results", "weights", "dates", "params", "args", "grades", "changed", " modifications", "rows", "codes", "content", "values", "changing"], "y": ["asy", "ay", "iy", "address", "ys", "t", "Y", "g", "yx", "l", "c", "ies", "yy", "ny", "ye", "zero", "b", "uy", "j", "yr", "v", "top", "cy", "yi", "type", "a", "io", "height", "ty", "ya", "hot", "w", "oy", "yd", "index", "z", "e", "wy", "client", "r", "axy", "vy", "an", "out", "page", "p", "h", "yl", "gy", "ly", "on", "at", "m", "n", "sat", "yt", "aily", "py", "lon", "xy", "o", "no", "by", "ry", "i", "ot", "my", "sys", "ch", "yes", "sky", "key", "yn", "user", "set", "ey", "cache", "chain", "ox", "entity", "sy", "fy", "yer", "ip", "node", "ym", "yo"], "x": ["length", "then", "mx", "cox", "xxx", "ax", "xs", "xt", "w", "xe", "xd", "m", "t", "f", "yx", "xi", "xp", "pair", "width", "l", "ix", "index", "xa", "key", "only", "c", "h", "z", "color", "status", "name", "xy", "e", "column", "exclusive", "r", "xes", "el", "time", "px", "left", "point", "xf", "zx", "X", "true", "xx", "wx", "dx", "v", "ox", "axis", "n", "cy", "success", "ex", "right", "any", "inx", "yl", "p", "ux", "tx", "exp", "content", "xc", "a", "i", "rx"], "y1": ["nyone", "nyOne", "x2", "YOne", "iy0", " y3", "yy2", "x3", "xOne", "y3", "yx", "yOne", "oyOne", "ny0", "oy001", " y91", "eyone", "ey4", "yone", "x001", " yx", " y0", "ny1", "y0", "eyx", " yOne", "yy0", "eyOne", "yy1", "oy1", "y2", "yy3", "xx", "cyone", "cyOne", "iy1", "yyOne", "ry1", "y4", "yy91", "ey2", "y91", "y001", "iyOne", "Y2", "ry91", " y4", "Y1", "Y0", "x4", "x0", "oy0", "ny001", "cy1", "iy2", "ryOne", " y2", "ry0", "ey1"], "x1": ["fx0", "x2", "ix1", "fx001", "xOne", "rx01", "x001", "wx001", " x91", " x01", "xone", "rx1", "rxone", "yOne", "z9", "axOne", "ixnum", "x9", " xnum", "xx1", "xx2", "fx1", "xx01", "x0", "ox1", "ax1", "xxOne", "ax9", " xOne", " xone", "wx1", "ix91", " x0", "x91", "fx91", " x2", "ix001", "rxOne", "xxone", "x01", "z1", "rx2", "ox001", "xnum", "zOne", " x001", "ynum", "y9", "ix0"], "grid": ["clear", "address", "g", "multi", "cell", "lat", "copy", "order", "addr", "query", "held", "check", "table", "zero", "modified", "frame", "net", "age", "hold", "fixed", "wrapper", "confirmed", "debug", "range", "cfg", "fresh", "figure", "Grid", "network", "gate", "mask", "window", "region", "game", "buffer", "fine", "db", "util", "holding", "raid", "client", "entry", "close", "mg", "dom", "res", "storage", "device", "out", "list", "bag", "position", "square", "gm", "array", "rage", "setup", "record", "form", "func", "valid", "domain", "cells", "rid", "new", "week", "header", "ga", "dim", "load", "status", "map", "column", "browser", "get", "connection", "state", "module", "back", "edge", "flow", "github", "model", "wrap", "trace", "final", "box", "layout", "data", "locked", "login", "tree", "file", "empty", "work", "lay", "view", "current", "play", "remote", "gc", "test", "set", "manager", "config", "lag", "jac", "group", "filled", " grids", "draw", "block", "cache", "line", "active", "chain", "wire", "grow", "success", "tile", "node", "graph", "content", "rows", "queue"], "row": ["range", "length", "value", "may", "month", "item", "w", "pair", "tr", "view", "week", "m", "word", "cell", "byte", "key", "index", "step", "copy", "status", "user", "loc", "xy", "lock", "column", "ready", "r", "entry", "board", "state", "co", "change", "ro", "Row", "block", "ward", "arrow", "batch", "mod", "rc", "sc", "line", "frame", "res", "sel", "ry", "roy", "now", "cy", "server", "page", "ow", "node", "roll", "rown", "error", "run", "square", "rows", "day", "box", "post", "lo", "record", "bar"], "R": ["V", "RS", "G", "P", "RE", "Y", "N", "B", "MR", "RF", "GR", "Rs", "D", "H", "RA", "r", "BR", "K", "SR", "RM", "T", "A", "RT", "I", "RO", "X", "E", "S", "NR", "DR", "RR", "L", "U", "F", "CR", "Mr", "Res", "TR", "Q", "AR"], "C": ["V", "CS", "G", "CV", "P", "W", "COR", "CC", "SIZE", "Y", "N", "CL", "O", "Count", "B", "CM", "c", "D", "CB", "Cs", "Ch", "H", "K", "JC", "CT", "T", "CU", "Cal", "A", "I", "X", "E", "S", "Size", "L", "U", "F", "CR", "Q", "Cor", "Co"], "M": ["V", "G", "MAN", "W", "P", "SIZE", "Y", "m", "N", "O", "MC", "B", "CM", "MR", "D", "H", "K", "MI", "RM", "T", "I", "X", "E", "S", "Size", "L", "F", "U", "Q", "MS", "MM", "NM", "Z", "DM"], "_": ["ay", "mult", "on", "t", "m", "ix", "c", "ac", "non", "con", "mod", "ox", "ex", "ow", "val", "all", "ct", "ation", "ge"], "states": ["ids", "blocks", "rates", "actions", "cells", "services", "stats", "chains", "sections", "guards", "comments", "history", "steps", "finals", "sites", "States", "jobs", "roots", "ates", "errors", "items", "lines", "status", "devices", "settings", "obs", "resources", "state", "files", "rooms", "gs", "versions", "groups", "games", "ifications", "charges", "results", "ands", "events", "itions", "outs", "stories", "res", "utters", "dates", "ports", "ts", "storage", "frames", "args", "stores", "agents", "workers", "ags", "lights", "doms", "ages", "values", "pins", "rows", "seconds", "flows", "ations", "points"], "mines_count": ["mines____count", "mineters_count", "mines____only", "mineters_sum", "minese_count", "minese____count", "mines_only", "mines_ount", "minese____only", "minesrettyinfo", "minesrettyount", "mines_sum", "minesses_info", "minese_only", "minessesrettycount", "minessesrettyount", "mines____ctr", "mines_info", "minesses_ount", "minese____sum", "minese_ctr", "minesrettycount", "minessesrettyinfo", "minese____ctr", "mines_ctr", "minesses_count", "mineters_number", "mines_number", "minese_sum", "mines____sum"], "new_location": ["New_Location", "new_node", " new_loc", " new_node", "new_behavior", " new_behavior", "new_direction", "New_location", "new_Location", " new_position", "new_loc", "New_direction", "new_position", "New_loc"], "new_grid": ["new_managed", "next___managed", "New_grid", "newnewmanaged", "next_lag", "new___grid", "next_status", "New_age", "newnewlag", "new___status", " new_row", "next_managed", "new_cell", "new___band", "new_status", "new_band", "newnewgrid", " new_cell", "new_wrapper", "next_grid", "new___managed", "next___grid", "new___lag", "new___age", "next___status", "New_band", "next___lag", "new_lag", "new___cell", " new_wrapper", "newnewstatus", "new_row", "New_cell", "new_age"], "result": ["data", "match", "Result", "message", "complete", "goal", "front", "pair", "new", "search", "created", "view", "done", "profile", "total", "correct", "test", "db", "contact", "response", "table", "product", "extra", "number", "results", "ret", "description", "report", "res", "answer", "success", "replace", "mate", "found", "final", "same", "section", "summary"]}}
{"code": "'''\\n  Created on Apr 11, 2014\\n  \\n  @author: mostasem\\n  '''\\n  \\n  \\n  def getSeconds(C,F,X):\\n      seconds = 0.0\\n      cookie_rate = 2\\n      solved =False\\n      while (not solved):\\n          choice1 = X/cookie_rate\\n          choice2 = C/cookie_rate + X/(cookie_rate + F)\\n          if(choice1 < choice2):\\n              seconds += choice1\\n              solved = True\\n          else :\\n              seconds += C/cookie_rate\\n              cookie_rate += F\\n      \\n      return seconds\\n  \\n  f_r = open('B.in',\"r\")\\n  n_test=int(f_r.readline().strip()) \\n  f_w = open(\"B.out\", \"w\")\\n  result = \"\"\\n  for i in range(n_test):\\n      C,F,X = map(float,f_r.readline().split())\\n      seconds = getSeconds(C,F,X)\\n      result = str(seconds)\\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\\n      f_w.write(output_str+'\\n')\\n      \\n  f_r.close()\\n  f_w.close()\\n  \\n", "target": "12", "substitutes": {"C": ["V", "AC", "CS", "G", "CI", "W", "P", "J", "CNN", "CC", "CO", "Cod", "Y", "CG", "N", "M", "O", "CL", "Count", "MC", "B", "CM", "c", "Control", "D", "CF", "YC", "Ch", "Cs", "H", "CE", "LC", "CT", "JC", "T", "Cl", "A", "Cal", "I", "R", "E", "CP", "EC", "CA", "S", "Cache", "NC", "L", "U", "Config", "CR", "KC", "CW", "Co", "Craig", "SC"], "F": ["V", "G", "W", "P", "J", "FW", "GF", "FR", "FS", "Fine", "FER", "f", "Y", "AF", "N", "O", "FC", "M", "MF", "FI", "Def", "B", "Foreign", "D", "CF", "EF", "FD", "IF", "Fi", "H", "K", "DF", "T", "A", "UF", "I", "R", "E", "FO", "S", "FG", "L", "U", "Q", "SF", "Fin", "Z", "PF", "FF", "Family", "FE"], "X": ["V", "AC", "W", "P", "IC", "J", "TX", "CC", "XY", "Y", "N", "O", "FC", "Xi", "EX", "B", "D", "CF", "XL", "H", "K", "CE", "IX", "XX", "T", "A", "Cross", "DX", "I", "R", "E", "S", "L", "x", "U", "IR", "UX", "XP", "Q", "XT", "OX", "MX", "Z", "XXX", "FE"], "seconds": ["duration", "second", "s", "ions", "minimum", "uses", "times", "actions", "services", "timeout", "size", "hours", "sections", "bes", "tes", "utes", "days", "comments", "changes", "steps", "gets", "jobs", "sites", "sec", "ences", "errors", "runs", "beans", "videos", "bytes", "sequence", "settings", "missions", "ss", "xes", "time", "versions", "flows", "games", "states", "ses", "start", "events", "outs", "course", "dates", "units", "bits", "terms", "frames", "tests", "years", "south", "ages", "strings", "codes", "resses", "reports", "values", "https", "sets"], "cookie_rate": ["browsermingrate", "cookie_range", "cookie_rule", "cookieencyrate", "session_time", " cookie_range", "cookieencydelay", "cache_rule", "cookie67limit", "cookie_Rate", "browser_capacity", "cookie_base", "browser_rating", "cookieencyRate", "browsermingrating", "browser_rate", "session_delay", "cache_range", "cookielyrating", "cookiemingcapacity", " cookie_delay", "session_base", "cookielyrange", "cookie2delay", "cookielycapacity", "cookie_time", " cookie_price", "cookie_limit", "cookiewareprice", "cookie_score", "session_force", " cookie_score", "cookie_rating", "cookie_capacity", "session_test", "session_rate", "cookieencyscore", "cookie_delay", "cookiewarerange", " cookie_rates", "cache_limit", "cache_rate", " cookie_Rate", "cookie67rule", "cookie2force", "cookie2time", "cookiemingrating", "browser_range", "cookiewarerates", "cookie_force", "browsermingrange", "cookielyrate", "cookie67range", "cookie_test", "cookiewarerate", "browsermingcapacity", "cookiemingrate", "cookie_rates", "cookie67rate", "cookie_price", "cookiemingrange", "cookie2rate"], "solved": [" solve", "absolved", "isolve", "dsolution", "absolve", "solve", "absolution", "ssolved", " solution", " solving", "isolved", "solves", "ssolving", "tsolved", "tsolve", "resolving", "tsolves", "tsolution", "resolved", "resolve", "dsolving", "tsolving", "dsolve", "ssolve", "dsolved", "solution", "isolving", "ssolves", "isolves", "absolving", "resolution", "solving", "isolution"], "choice1": ["switch01", "select1", "Choice3", "select0", "select01", "switch1", "Choice2", " choice3", "pick0", "Choice0", "pick1", "Choice1", "pick3", "choice01", "switch0", " choice0", "sample1", "Choice01", "pick2", "choice3", "select2", "sample3", "choice0", "sample2", "switch2"], "choice2": ["option2", "Choice3", " choose3", "option5", "option1", " choose2", "Choice22", " choose1", "Choice2", " choice3", "Choice1", " choice5", "choice5", "choice22", "choice3", "option3", "Choice5", " choice22", " choose22"], "f_r": ["flexr", "f_h", "procadein", "fppyin", "f_pair", "f_re", "fp_in", "fmlw", "fpyh", "ffrs", "faden", "fpyr", " f_pair", "proc_n", "proc_rs", "f_n", "fppyw", "fo_w", "f5f", "faders", "flexrs", "f_f", "fpyw", "fockw", "fadein", "fo_in", "foockin", "ffre", "fockin", "ffr", "fppyr", "fmlh", "fp_r", "proc_in", "fader", "foockf", "f_in", " f_rs", "fockr", "fp_w", "fpyin", "f5in", "fockf", "ffpair", "f5r", "proc_r", "f5w", "flexin", "fmlr", "flexn", "fo_r", " f_re", "procaden", "f_rs", "fp_h", "foockr", "fppyh", "fo_f", "foockw", "procader", "fmlin", "procaders"], "n_test": ["n_Test", "n_tested", "n2testing", "nc_testing", "n8tested", "nc8Test", "nc_Test", "nc_tested", " n_train", "n8Test", "nc8tested", "n_testing", "n_tests", "n8testing", "nc_test", " n_Test", "n2tested", "nc8test", "n8test", "n_train", "n2test", " n_tests", "n2Test", "nc8testing"], "f_w": ["streamptw", "f_rw", "f_we", "f3r", "fptrw", "f_out", "stream_rw", "fmtr", " f_wh", "stream_out", "f_wt", " f_wt", "f3we", "streamptout", "fmtwh", "f3wh", " f_we", "f_wx", "fmtwt", "fmtwe", "f_wh", "fmtwx", "streamptrw", "stream_w", "f3w", " f_wx", "fmtw", "fptw", "fptout"], "result": ["valid", "data", "string", "Result", "message", "successful", "gain", "figure", "complete", "comment", "sex", "successfully", "case", "total", "RESULTS", "correct", "test", "full", "status", "buffer", "function", "reason", "response", "ful", "r", "example", "format", "results", "ret", "description", "res", "report", "output", "chain", "str", "answer", "out", "success", "RES", "command", "final", "summary", "relation", "STR"], "i": ["ki", "ti", "s", "ini", "uri", "ind", "pi", "f", "li", "m", "t", "xi", "multi", "it", "n", "l", "ix", "c", "bi", "z", "e", "zi", "id", "q", "b", "im", "I", "si", "j", "mi", "ui", "qi", "v", "x", "di", "gi", "ii", "ci", "p", "ei"], "output_str": ["outputpyusr", "Output_st", "output_st", "outputmmusr", "outputpystr", "output_usr", "outputmmstr", "outputgrtemp", "outputpyst", "outputpyStr", "outputgrr", "output_r", "Output_usr", "output_temp", "outputmmst", " output_arr", "Output_Str", "outputgrstr", "Output_str", "outputgrarr", " output_r", "output_arr", " output_temp", "output_Str", "outputmmStr"]}}
{"code": "'''\\n  Created on Apr 12, 2014\\n  \\n  @author: mostasem\\n  '''\\n  \\n  def getFloorRoots(m):\\n      r1 = -1 + math.sqrt(1 + (8 * m))/2\\n      r2 = -1 - math.sqrt(1 + (8 * m))/2\\n      return int(math.floor(r1))\\n      \\n  def boardHasZero(R,C,M):\\n      if(R > 1 and C > 1):\\n          S = M/C\\n          Sr = M % C\\n          print S,Sr\\n          return R >= S+3 or (R == S+2 and ((Sr % 2) == 0 or (((C + Sr) % 3 == 0) and (2*C >= (C + Sr + 4))))) or (R == S+1  and (C + Sr) % 2 == 0 and (2*C >= (C + Sr + 4)))  #M <= ((R*C) - 4)\\n      else :\\n          return M <= ((R*C) - 2)\\n  \\n  \\n  def generateMineSweeperCase(R,C,M):\\n  \\n      board = \"\"\\n  \\n      if( R > 1 and C > 1 ): # generate special\\n          S = M/C\\n          Sr = M % C\\n          print S,Sr\\n          if(S): # all rows of *\\n              board +=\"\\n\"\\n              if(R >= S+3 or (R == S+2 and Sr % 2 == 0)):\\n                  board += (S - 1) * ((C*\"*\") + \"\\n\")\\n              else:\\n                  board += (S - 2) * ((C*\"*\") + \"\\n\")\\n              board +=  ((C*\"*\"))\\n              \\n          if(R >= S+3):\\n              if(Sr):\\n                  board +=\"\\n\"\\n                  board += ((Sr *\"*\") + ((C - Sr) *\".\"))\\n              Rm = R - (S + 1)\\n              if(Rm):\\n                  board +=\"\\n\"\\n                  board += (Rm - 1) * ((C*\".\") + \"\\n\")\\n                  board +=  ((C*\".\"))\\n                  \\n          elif(R == S + 2):\\n              Sm = 0\\n              if(Sr % 2 == 0):\\n                  board +=\"\\n\"\\n                  board += (((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\") +\"\\n\")\\n                  board += ((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\")\\n              else:\\n                  board +=\"\\n\"\\n                  board += (((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\") +\"\\n\")\\n                  board += ((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\")\\n          else :\\n              Sm = Sr + C\\n              board +=\"\\n\"\\n              board += (((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\") +\"\\n\")\\n              board += ((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\")\\n                  \\n          list_board = list(board)\\n          list_board[len(list_board) - 1] = 'c'\\n          board = \"\".join(list_board)\\n      else:\\n          board +=\"\\n\"\\n          if(C == 1):\\n              board += M * \"*\\n\"\\n              board += (R-M-1) * \".\\n\"\\n              board +=  \"c\"\\n          else:\\n              board += M * \"*\"\\n              board += (C-M-1) * \".\"\\n              board += \"c\"\\n              \\n      return board\\n         \\n         \\n         \\n  \\n  f_r = open('C.in',\"r\")\\n  n_test=int(f_r.readline().strip()) \\n  f_w = open(\"C.out\", \"w\")\\n  result = \"\"\\n  for i in range(n_test):\\n      R,C,M = map(int,f_r.readline().split())\\n      print R,C,M\\n      if(boardHasZero(R,C,M)):\\n          result = generateMineSweeperCase(R,C,M)\\n      else :\\n          result =\"\\nImpossible\"\\n      print result\\n      output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)\\n      f_w.write(output_str+'\\n')\\n      \\n  f_r.close()\\n", "target": "12", "substitutes": {"m": ["s", "nm", "bm", "ms", "y", "om", "t", "f", "g", "n", "l", "wm", "c", "mat", "rm", "tm", "mt", "mc", "k", "mac", "mm", "r", "q", "b", "mi", "mut", "v", "x", "dm", "gm", "cm", "p", "d", "h", "i"], "r1": ["pair1", "R8", "m5", "m3", "m1", "R2", "t2", "ROne", "r5", "R3", "rOne", " r8", "t5", "r8", "m2", "pairOne", "R5", "R1", "t1", "pair2", "t3", "r3", " rOne", "pair8"], "r2": [" r3", "R4", "R2", "ar1", "ar2", "r3", "R3", "ar3", " r4", "r4", "ar4", "R1"], "R": ["V", "RS", "G", "Result", "P", "W", "RE", "ER", "RAM", "Remote", "Role", "REM", "Range", "N", "Right", "O", "B", "MR", "RF", "D", "H", "RA", "r", "BR", "RC", "Return", "RM", "T", "A", "RT", "I", "RO", "X", "JR", "E", "RR", "DR", "L", "U", "F", "CR", "IR", "Res", "TR", "Q", " r", "AR", "Z", "ALL"], "C": ["V", "AC", "CS", "G", "CV", "P", "W", "CI", "CNN", "COR", "Cow", "CC", "Cos", "CO", "Y", "CG", "N", "O", "Mc", "CL", "MC", "HC", "B", "c", "CM", "Car", "D", "CB", "CF", "Ch", "Cs", "H", "K", "CCC", "CE", "CT", "JC", "You", "CU", "DC", "Cal", "CD", "T", "A", "I", "Cl", "Ca", "EC", "CP", "Cache", "CA", "BC", "E", "U", "L", "F", "CR", "CON", "Q", "CH", "CW", "CN", "GC", "WC", "TC", "Co", "SC"], "M": ["V", "G", "W", "P", "MT", "RE", "Y", "N", "O", "MC", "B", "CM", "MR", "D", "H", "MI", "RM", "T", "A", "I", "RO", "X", "E", "L", "F", "U", "Q", "TM", "MS", "MM", "Z", "AM"], "S": ["OS", "s", "V", "RS", "CS", "G", "SAN", "W", "P", "GS", " s", "Y", "SI", "SA", "BS", "PS", "N", "JS", "O", "B", "DS", "NS", "SS", "AS", "H", "SR", "T", "WS", "A", "SU", "I", "SL", "X", "E", "SB", "TS", "SE", "Si", "SM", "Set", "L", "SH", "ES", "Source", "F", "Sl", "Q", "IS", "Z", "VS", "SC"], "Sr": ["Psrin", "Lr", " Snr", "Ther", "Sattr", "SSnr", "ssr", "Newsattr", "Sc", "Serrs", "Serc", "SSz", "Syssr", " Sn", "Thesr", "Sysrin", "Esn", "Src", "Jsrt", "Newattr", "Jsattr", "Sz", "Psdr", "Scr", "Psrs", "Sysrt", "SScr", " Srs", " Sc", " Sz", "SSr", "SR", "Esrc", "Sri", "Newsr", "Thenr", "Srin", "Jssr", "GSr", "NewsR", "Essr", "Newri", "Lsr", "Thez", "Srt", "SSsr", "GSdr", "sr", " Scr", " SR", "Jsrin", "Ssr", "Sersr", "Psr", "sn", "GSR", "Jsri", "NewR", "Srs", "Lcr", "Lnr", "Jsr", "Sysr", " Src", " Ssr", "GSsr", "Psrt", "JsR", "PsR", "Esr", "Sdr", "Psc", "Sn", "Newsri", "Newr", "Pssr", "Serr", " Sdr", "Snr", "src"]}}
{"code": "\\n  def read_str(): return stdin.readline().rstrip('\\n')\\n  def read_int(): return int(stdin.readline())\\n  def read_ints(): return map(int, stdin.readline().split())\\n  def read_floats(): return map(float, stdin.readline().split())\\n  \\n  \\n  def solve_case():\\n      C, F, X = read_floats()\\n      rate = 2\\n      current = 0\\n      best = X / rate\\n      \\n      while True:\\n          current += C / rate\\n          rate += F\\n          next = current + X / rate\\n          if next < best:\\n              best = next\\n          else:\\n              break\\n      \\n      return best\\n  \\n      \\n  def main():\\n      cases = read_int()\\n      for case in range(1, cases + 1):\\n          print('Case #{}: {:.7f}'.format(case, solve_case()))\\n  \\n          \\n  main()\\n", "target": "13", "substitutes": {"C": ["V", "CS", "CI", "P", "CNN", "CC", "CO", "N", "M", "B", "CM", "c", "D", "CF", "CB", "Cs", "H", "K", "CE", "Current", "CT", "T", "CU", "A", "R", "CP", "CA", "S", "U", "L", "CR", "Cu", "Co"], "F": ["V", "W", "P", "GF", "FR", "FER", "f", "Y", "N", "M", "FC", "O", "B", "D", "CF", "EF", "FL", "FD", "IF", "H", "DF", "T", "A", "UF", "I", "R", "E", "FO", "S", "FG", "L", "U", "FP", "FM", "Q", "Z", "PF", "FF", "FA", "FE"], "X": ["V", "G", "W", "P", "J", "XY", "FX", "Y", "N", "M", "Xi", "EX", "D", "CF", "XL", "H", "K", "IX", "XX", "T", "A", "DX", "I", "R", "E", "S", "L", "x", "U", "ICE", "UX", "XP", "Q", "XT", "OX", "FF", "Z", "ZX", "XXX", "Ex", "FE"], "rate": ["range", "sample", "value", "power", "rates", "seed", "free", "ate", "core", "trade", "timeout", "frequency", "pe", "mode", "rating", "prime", "fee", "tone", "step", "capacity", "rat", "test", "rand", "beta", "fine", "function", "rank", "re", "sequence", "r", "change", "rule", "rated", "term", "cycle", "currency", "process", "age", "force", "Rate", "erate", "race", "command", "weight", "speed", "error", "scale", "delay", "average", "chance", "factor", "priority", "score", "beat"], "current": ["result", "complete", "reported", "first", "public", "cover", "new", "history", "multi", "long", "index", "memory", "single", "remote", "present", "this", "status", "local", "tmp", "update", "initial", "client", "default", "Current", "progress", "context", "URRENT", "cur", "number", "active", "counter", "count", "common", "pre", "random", "now", "position", "currently", "recent", "average", "latest", "round", "p", "record", "i"], "best": ["valid", "result", "master", "value", "est", "last", "short", "Best", "adjusted", "first", "better", "new", "cost", "all", "only", "test", "opt", "highest", "fine", "winner", "worst", "default", "b", "score", " Best", "start", "close", "self", "bright", "stable", "largest", "good", "x", "top", "med", "success", "fit", "right", "bottom", "end", "latest", "p", "average", "round", "final", "perfect", "stop", "pop", "just", "same", "max", "peak"], "next": ["more", "second", " NEXT", "result", "value", "ng", "expected", "last", "Next", "to", "first", "front", "new", "accept", "future", "long", "step", "jp", "adj", "set", "default", "ne", "left", "start", "big", "close", "line", "self", "min", "used", "never", "after", "good", "top", " Next", "prev", "success", "right", "end", "latest", "me", "final", "forward", "max", "below"], "cases": ["cs", "Times", "ids", "times", "projects", "cells", "names", "sections", "cycles", "chains", "days", "changes", "steps", "aps", "its", "ces", "runs", "lines", "items", "ends", "classes", "groups", "caps", "lists", "states", "results", "events", " hundreds", "checks", " times", "terms", "limits", "users", "frames", "tests", "stores", "cas", "codes", "ases", "values", " Cases"], "case": ["result", "match", "core", "catch", "zip", "pair", "mode", "condition", "step", "index", "capacity", "test", "c", "switch", "set", "client", "lc", "time", "context", "rule", "number", "ce", "line", "cycle", "ASE", "chain", "ase", "x", "trial", "use", "ice", "cas", "me", "cd", "p", "ace", "tc", "instance", "i", "Case"]}}
{"code": "\\n  \\n  def read_str(): return stdin.readline().rstrip('\\n')\\n  def read_int(): return int(stdin.readline())\\n  def read_ints(): return map(int, stdin.readline().split())\\n  def read_floats(): return map(float, stdin.readline().split())\\n  \\n  \\n  def atos(A):\\n      return '\\n'.join([''.join(row) for row in A])\\n      \\n  \\n  def get_field(r, c):\\n      field = [['.'] * c for i in range(r)]\\n      field[0][0] = 'c'\\n      return field\\n      \\n      \\n  def is_forbidden(i, j):\\n      return i == 0 and j == 0 or i == 0 and j == 1 or \\\\n          i == 1 and j == 0 or i == 1 and j == 1\\n      \\n      \\n  def fill(field, r, c, m):\\n      left = m\\n      for ii in range(r - 1, -1, -1):\\n          i = ii\\n          j = c - 1\\n          while i < r and j >= 0:\\n              if is_forbidden(i, j):\\n                  i += 1\\n                  j -= 1\\n                  continue\\n              if left == 0:\\n                  return 0\\n              field[i][j] = '*'\\n              left -= 1\\n              \\n              i += 1\\n              j -= 1\\n              \\n          if ii == 0:\\n              for jj in range(c - 2, 1, -1):\\n                  i = ii\\n                  j = jj\\n                  while i < r and j >= 0:\\n                      if is_forbidden(i, j):\\n                          i += 1\\n                          j -= 1\\n                          continue\\n                      if left == 0:\\n                          return 0\\n                      field[i][j] = '*'\\n                      left -= 1\\n                      \\n                      i += 1\\n                      j -= 1\\n              \\n      if r * c == m + 1:\\n          if r > 1:\\n              field[1][0] = '*'\\n          if c > 1:\\n              field[0][1] = '*'\\n          if r > 1 and c > 1:\\n              field[1][1] = '*'\\n          return 0\\n              \\n      return left\\n  \\n      \\n  def solve_case():\\n      r, c, m = read_ints()\\n      \\n      field = get_field(r, c)\\n          \\n      left = fill(field, r, c, m)\\n          \\n      return 'Impossible' if left != 0 else atos(field)\\n      \\n      \\n  def main():\\n      cases = read_int()\\n      for case in range(1, cases + 1):\\n          print('Case #{}:\\n{}'.format(case, solve_case()))\\n  \\n          \\n  main()\\n", "target": "13", "substitutes": {"A": ["V", "G", "W", "P", "J", "AA", "Y", "SA", "M", "O", "Ar", "B", "C", "GA", "D", "AB", "H", "Array", "T", "Row", "I", "R", "mA", "X", "AU", "E", "CA", "S", "L", "An", "Area", "Z", "One", "a", "array", "All", "This"], "row": ["post", "data", "ob", "match", "may", "ows", "th", "pair", "tr", "word", "cell", "rs", "ser", "entry", "ro", "Row", "rc", "raw", "line", "ox", "x", "join", "star", "list", "rown", "ow", "right", "roll", "char", "col", "rows", "item", "name", "instance", "record"], "r": ["range", "hr", "rr", "rt", "cr", "dr", "gr", "u", "w", "t", "tr", "f", "err", "g", "ru", "n", "it", "l", "nr", "attr", "rd", "h", "rn", "rm", "sr", "rs", "re", "q", "ir", "co", "b", "ro", "br", "ra", "ar", "o", "ri", "rec", "R", "pr", "rc", "rh", "res", "mr", "v", "str", "x", "er", "lr", "right", "fr", "vr", "p", "d", "rg", "rar", "a", "rb", "rx"], "c": ["cs", "cr", "cp", "tc", "ch", "u", "cf", "y", "w", "ic", "t", "f", "g", "cin", "n", "l", "com", "C", "gc", "z", "ac", "con", "e", "k", "mc", "q", "dc", "lc", "co", "rb", "b", "fc", "cur", "o", "bc", "ar", "cos", "ce", "rc", "cache", "v", "cat", "cu", "xc", "ca", "cb", "col", "cm", "ci", "cn", "ct", "d", "p", "h", "cd", "a", "cc"], "field": ["relation", "tag", "match", "stack", "cell", "fe", "query", "tmp", "table", "attribute", "force", "answer", "link", "right", "json", "comment", "index", "buffer", "util", "function", "db", "entry", "default", "rule", "term", "prefix", "Field", "storage", "join", "list", "command", "position", "child", "section", "name", "post", "record", "job", "form", "length", "FIELD", "message", "ld", "domain", "input", "f", "word", "base", "member", "fix", "this", "load", "map", "column", "mp", "back", "self", "document", "arg", "league", "part", "data", "result", "value", "file", "pair", "pad", "condition", "byte", "key", "test", "service", "local", "user", "config", "control", "group", "lc", "cache", "line", "player", "fields", "node", "level", "item", "component", "label", "button", "display"], "i": ["ori", "ini", "u", "g", "multi", "it", "l", "iri", "ir", "b", "v", "di", "a", "io", "int", "li", "ami", "ie", "index", "iam", "e", "zi", "iu", "ri", "I", "qi", "p", "ei", "ki", "pi", "f", "xi", "n", "bi", "id", "ai", "phi", "o", "si", "mi", "ati", " I", "ia", "ib", "\u0438", "ci", "iti", "oi", "ti", "ic", "y", "ind", "ix", "aci", "init", "hi", "ij", "ni", "im", "ui", "info", "x", "gi", "ip", "ji"], "j": ["s", "then", "note", "u", "t", "g", "it", "l", "aj", "og", "js", "jp", "adj", "k", "_", "q", "b", "v", "di", "ger", "dt", "a", "ion", "json", "ja", "w", "jas", "li", "ie", "z", "db", "bj", "pr", "jack", "res", "out", "ian", "jump", "uj", "p", "err", "h", "job", "f", "n", "jc", "pt", "o", "je", "fr", "d", "jl", "J", "y", "kj", "test", "dj", "ij", "jac", "br", "obj", "ver", "str", "x", "er", "ji", "ress"], "m": ["s", "sm", "em", "ms", "y", "u", "w", "ma", "t", "f", "g", "n", "M", "l", "z", "rm", "mt", "mc", "e", "k", "mm", "man", "mp", "q", "arm", "mem", "b", "im", "am", "o", "pm", "mi", "min", "mr", "v", "dm", "gm", "cm", "p", "d", "a", "h", "vm"], "left": ["only", "l", "full", "down", "Left", "co", "path", " Left", "start", "diff", "low", "net", "top", "right", "lt", "cont", "to", "w", "li", "index", "mask", "none", "center", "default", "min", "op", "join", "out", "list", "p", "err", "name", "ll", "form", "length", "minimum", "wrong", "n", "Right", "this", "ml", "no", "lp", "self", "lower", "le", "lo", "missing", "pair", "url", "long", "width", "lock", "local", "set", "mm", "lc", "format", "inner", "joined", "line", "after", "L", "x", "old", "level", "found", "all"], "ii": ["jl", "ti", "aaa", "irrel", "sv", "iy", "ini", "ta", "inite", "pi", "li", "ie", "zy", "gif", "ix", "iri", "init", "false", "iam", "iw", "II", "\u012b", "itime", "hi", "ij", "ail", "ni", "ir", "ai", "ri", "si", "iii", "ski", "ifi", "iat", "arb", "iona", "ati", "wife", "cu", "ia", "iro", "di", "gi", "ih", "ice", "nil", "qq", "iso", "ios", "ially", "igi", "uj", "ire", "irm", "ci", "ji", "ee", "io", "ort", "ei"], "jj": ["jl", "json", "aaa", "rr", "ja", "ju", "jad", "y", "ind", "jas", "t", "f", "g", "bb", "kj", "it", "n", "nr", "vv", "aj", "jp", " iii", "dj", "k", "yy", "mm", "ij", "jc", "jac", "b", "iii", "jam", "circ", "ctr", "aq", "hn", "bah", "jah", "ia", "uu", "uj", "cm", "ji", "cc"], "cases": ["cs", "ids", "uses", "times", "sections", "cycles", "xs", "changes", "errors", "ces", "runs", "items", "lines", "ends", "ups", "rs", "results", "his", "checks", "features", "terms", "fields", "tests", "codes", "rows", "values", "sets"], "case": ["more", "cont", "of", "ed", "n", "_", "get", "inner", "join", "the", "all", "just"]}}
{"code": "\\n  FILE_NAME_BASE = 'B-small-attempt0'\\n  NUM_PROCESSES = 0\\n  MEM_LIMIT_GB = 1.5 # per worker process\\n  RECURSION_LIMIT = 1000\\n  \\n  def parse(inp):\\n  \tcost, prod, goal = (float(x) for x in inp.readline().split())\\n  \treturn cost, prod, goal\\n  \\n  def solve(cost, prod, goal):\\n  \trate = 2\\n  \tnow = 0\\n  \twhile True:\\n  \t\tnobuyEnd = goal / rate\\n  \t\tbuyEnd = cost / rate + goal / (rate + prod)\\n  \t\tif buyEnd < nobuyEnd:\\n  \t\t\tnow += cost / rate\\n  \t\t\trate += prod\\n  \t\telse:\\n  \t\t\treturn '%0.7f' % (now + nobuyEnd)\\n  \\n  def main():\\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\\n  \\n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\\n  \\n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\\n  \tnumCases = int(inp.readline())\\n  \tif NUM_PROCESSES == 0:\\n  \t\tresults = [\\n  \t\t\tsolve(*parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \telse:\\n  \t\tpool = Pool(NUM_PROCESSES)\\n  \t\tresults = [\\n  \t\t\tpool.apply_async(solve, parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \tinp.close()\\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\\n  \tfor case, result in enumerate(results):\\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\\n  \t\tout.write('Case #%d: %s\\n' % (case + 1, value))\\n  \t\tout.flush()\\n  \tout.close()\\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "target": "14", "substitutes": {"FILE_NAME_BASE": ["FILE_NAME_EBAT", "FILE_NAME_EBETA", "FILE_NAME_DBASE", "FILE_NAME_DBBase", "FILE_NAME_BBase", "FILE_NAME_DBAT", "FILE_NAME_DETA", "FILE_NAME_DASE", "FILE_NAME_EBASE", "FILE_NAME_DBase", "FILE_NAME_BAT", "FILE_NAME_EBBase", "FILE_NAME_DAT", "FILE_NAME_BETA", "FILE_NAME_DBETA"], "NUM_PROCESSES": ["NUM_PROCESSes", "NUM_PROGRESSES", "NUM_PROCODUCTES", "NUM_PROCNECTURES", "NUM_PROGRESSes", "NUM_PROCNECTES", "NUM_PROCODUCTURES", "NUM_PROCODUCTIONS", "NUM_PROGRNECTES", "NUM_PROCUTES", "NUM_PROGRNECTIONS", "NUM_PROGRESSURES", "NUM_PROCESSURES", "NUM_PROCUTes", "NUM_PROCODUCTes", "NUM_PROCNECTIONS", "NUM_PROGRESSIONS", "NUM_PROCUTURES", "NUM_PROGRNECTURES", "NUM_PROGRNECTes", "NUM_PROCUTIONS", "NUM_PROCNECTes", "NUM_PROCESSIONS"], "MEM_LIMIT_GB": ["MEM_LIMITS_AGE", "MEM_LIMITSINMB", "MEM_LIMITTIMEAGE", "MEM_LIMITSINGB", "MEM_LIMITTIMEMB", "MEM_LIMITSINAGE", "MEM_LIMITINMB", "MEM_LIMITTIMEGB", "MEM_LIMITUSMB", "MEM_LIMIT_MB", "MEM_LIMITUSAGE", "MEM_LIMITINAGE", "MEM_LIMITS_MB", "MEM_LIMITS_GB", "MEM_LIMITUSGB", "MEM_LIMITINGB", "MEM_LIMIT_AGE"]}}
{"code": "\\n  FILE_NAME_BASE = 'C-small-attempt0'\\n  NUM_PROCESSES = 0\\n  MEM_LIMIT_GB = 1.5 # per worker process\\n  RECURSION_LIMIT = 1000\\n  \\n  def parse(inp):\\n  \trows, cols, mines = (int(x) for x in inp.readline().split())\\n  \treturn rows, cols, mines\\n  \\n  def search(rows, cols, mines):\\n  \\n  \tassert 0 <= mines < rows * cols\\n  \tif mines == 0:\\n  \t\treturn ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)\\n  \tif mines == rows * cols - 1:\\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\\n  \\n  \tif rows == 1:\\n  \t\treturn ['c' + '.' * (cols - 1 - mines) + '*' * mines]\\n  \tif cols == 1:\\n  \t\treturn ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines\\n  \\n  \tif mines > rows * cols - 4:\\n  \t\treturn None\\n  \\n  \\n  \treturn None\\n  \\n  class SearchBoard(object):\\n  \\n  \tdef __init__(self, rows, cols):\\n  \t\tself.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]\\n  \t\tself.mineCount = 0\\n  \\n  \tdef addMine(self, row, col):\\n  \t\tcounts = self.counts\\n  \t\tassert counts[row + 1][col + 1] < 10\\n  \t\ttop = counts[row + 0]\\n  \t\ttop[col + 0] += 1\\n  \t\ttop[col + 1] += 1\\n  \t\ttop[col + 2] += 1\\n  \t\tmid = counts[row + 1]\\n  \t\tmid[col + 0] += 1\\n  \t\tmid[col + 1] += 10\\n  \t\tmid[col + 2] += 1\\n  \t\tbot = counts[row + 2]\\n  \t\tbot[col + 0] += 1\\n  \t\tbot[col + 1] += 1\\n  \t\tbot[col + 2] += 1\\n  \t\tself.mineCount += 1\\n  \\n  \tdef removeMine(self, row, col):\\n  \t\tcounts = self.counts\\n  \t\tassert counts[row + 1][col + 1] >= 10\\n  \t\ttop = counts[row + 0]\\n  \t\ttop[col + 0] -= 1\\n  \t\ttop[col + 1] -= 1\\n  \t\ttop[col + 2] -= 1\\n  \t\tmid = counts[row + 1]\\n  \t\tmid[col + 0] -= 1\\n  \t\tmid[col + 1] -= 10\\n  \t\tmid[col + 2] -= 1\\n  \t\tbot = counts[row + 2]\\n  \t\tbot[col + 0] -= 1\\n  \t\tbot[col + 1] -= 1\\n  \t\tbot[col + 2] -= 1\\n  \t\tself.mineCount -= 1\\n  \\n  \tdef checkConnected(self):\\n  \t\tcounts = self.counts\\n  \t\tcols = len(counts[0]) - 2\\n  \t\trows = len(counts) - 2\\n  \\n  \t\tfor rowIdx, row in enumerate(counts):\\n  \t\t\tif rowIdx == 0 or rowIdx > rows:\\n  \t\t\t\tcontinue\\n  \t\t\ttry:\\n  \t\t\t\tcolIdx = row.index(0, 1, -1)\\n  \t\t\texcept ValueError:\\n  \t\t\t\tpass\\n  \t\t\telse:\\n  \t\t\t\tclick = (rowIdx, colIdx)\\n  \t\t\t\tbreak\\n  \t\telse:\\n  \t\t\treturn None\\n  \\n  \t\trevealed = set()\\n  \t\tdef reveal(row, col):\\n  \t\t\tif 1 <= row <= rows and 1 <= col <= cols:\\n  \t\t\t\tpos = (row, col)\\n  \t\t\t\tif pos not in revealed:\\n  \t\t\t\t\trevealed.add(pos)\\n  \t\t\t\t\tcount = counts[row][col]\\n  \t\t\t\t\tif count == 0:\\n  \t\t\t\t\t\tfor dr in (-1, 0, 1):\\n  \t\t\t\t\t\t\tfor dc in (-1, 0, 1):\\n  \t\t\t\t\t\t\t\tif dr != 0 or dc != 0:\\n  \t\t\t\t\t\t\t\t\treveal(row + dr, col + dc)\\n  \t\t\t\t\telse:\\n  \t\t\t\t\t\tassert count < 10\\n  \t\treveal(*click)\\n  \t\tnumNonMines = rows * cols - self.mineCount\\n  \t\tif len(revealed) != numNonMines:\\n  \t\t\tassert len(revealed) < numNonMines\\n  \t\t\treturn None\\n  \\n  \t\tboard = [\\n  \t\t\t\t['.' if cell < 10 else '*' for cell in row[1 : -1]]\\n  \t\t\t\tfor row in counts[1 : -1]\\n  \t\t\t\t]\\n  \t\tboard[click[0] - 1][click[1] - 1] = 'c'\\n  \t\treturn [''.join(row) for row in board]\\n  \\n  def searchBruteForce(rows, cols, mines):\\n  \tif mines == rows * cols - 1:\\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\\n  \\n  \tsearchBoard = SearchBoard(rows, cols)\\n  \\n  \tdef searchRec(idx, remaining):\\n  \t\tif remaining == 0:\\n  \t\t\treturn searchBoard.checkConnected()\\n  \t\telif idx < remaining:\\n  \t\t\treturn None\\n  \t\telse:\\n  \t\t\tpos = divmod(idx, cols)\\n  \t\t\tsearchBoard.addMine(*pos)\\n  \t\t\tfound = searchRec(idx - 1, remaining - 1)\\n  \t\t\tsearchBoard.removeMine(*pos)\\n  \t\t\tif found is not None:\\n  \t\t\t\treturn found\\n  \t\t\treturn searchRec(idx - 1, remaining)\\n  \\n  \treturn searchRec(rows * cols - 1, mines)\\n  \\n  def solve(rows, cols, mines):\\n  \tboard = search(rows, cols, mines)\\n  \\n  \tif board is None:\\n  \t\tboard = searchBruteForce(rows, cols, mines)\\n  \t\tif board is None:\\n  \t\t\treturn '\\n' + 'Impossible'\\n  \t\tprint 'ERROR: fast search missed solution for %dx%d board, %d mines:' \\\\n  \t\t\t\t% (rows, cols, mines)\\n  \t\tfor row in board:\\n  \t\t\tprint row\\n  \t\tprint\\n  \\n  \tassert len(board) == rows\\n  \tassert all(len(row) == cols for row in board)\\n  \tcounts = { 'c': 0, '.': 0, '*': 0 }\\n  \tfor row in board:\\n  \t\tfor cell in row:\\n  \t\t\tcounts[cell] += 1\\n  \tassert counts['c'] == 1\\n  \tassert counts['*'] == mines\\n  \\n  \tflowBoard = [\\n  \t\t\t['.' if cell == 'c' else cell for cell in row]\\n  \t\t\tfor row in board\\n  \t\t\t]\\n  \tdef countMinesOn(row, col):\\n  \t\tif 0 <= row < rows and 0 <= col < cols:\\n  \t\t\treturn 1 if flowBoard[row][col] == '*' else 0\\n  \t\telse:\\n  \t\t\treturn 0\\n  \tdef countMinesNear(row, col):\\n  \t\treturn sum(\\n  \t\t\tcountMinesOn(row + dr, col + dc)\\n  \t\t\tfor dr in (-1, 0, 1)\\n  \t\t\tfor dc in (-1, 0, 1)\\n  \t\t\t)\\n  \tdef reveal(row, col):\\n  \t\tif 0 <= row < rows and 0 <= col < cols:\\n  \t\t\tassert flowBoard[row][col] != '*'\\n  \t\t\tif flowBoard[row][col] == '.':\\n  \t\t\t\tcount = countMinesNear(row, col)\\n  \t\t\t\tflowBoard[row][col] = str(count)\\n  \t\t\t\tif count == 0:\\n  \t\t\t\t\tfor dr in (-1, 0, 1):\\n  \t\t\t\t\t\tfor dc in (-1, 0, 1):\\n  \t\t\t\t\t\t\treveal(row + dr, col + dc)\\n  \tclickRow, = [i for i, row in enumerate(board) if 'c' in row]\\n  \tclickCol = board[clickRow].index('c')\\n  \treveal(clickRow, clickCol)\\n  \tassert all('.' not in row for row in flowBoard), flowBoard\\n  \\n  \tassert all(type(row) == str for row in board)\\n  \treturn '\\n' + ''.join('\\n' + ''.join(row) for row in board)\\n  \\n  def main():\\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\\n  \\n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\\n  \\n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\\n  \tnumCases = int(inp.readline())\\n  \tif NUM_PROCESSES == 0:\\n  \t\tresults = [\\n  \t\t\tsolve(*parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \telse:\\n  \t\tpool = Pool(NUM_PROCESSES)\\n  \t\tresults = [\\n  \t\t\tpool.apply_async(solve, parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \tinp.close()\\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\\n  \tfor case, result in enumerate(results):\\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\\n  \t\tout.write('Case #%d: %s\\n' % (case + 1, value))\\n  \t\tout.flush()\\n  \tout.close()\\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "target": "14", "substitutes": {"FILE_NAME_BASE": ["FILE_NAME_BCOWER", "FILE_NAME_BOWER", "FILE_NAME_NBASE", "FILE_NAME_NBAT", "FILE_NAME_BOAT", "FILE_NAME_BORA", "FILE_NAME_NBOWER", "FILE_NAME_NBRA", "FILE_NAME_BCRA", "FILE_NAME_BOASE", "FILE_NAME_BCAT", "FILE_NAME_BOOWER", "FILE_NAME_BAT", "FILE_NAME_BCASE", "FILE_NAME_BRA"], "NUM_PROCESSES": ["NUM_PROCESSes", "NUM_PROGRESSES", "NUM_PROCUSES", "NUM_PROCUSes", "NUM_PROCNECTURES", "NUM_PROCESSED", "NUM_PROCUTED", "NUM_PROGRESSes", "NUM_PROCNECTES", "NUM_PROCUSURES", "NUM_PROGRNECTES", "NUM_PROCUTES", "NUM_PROCNECTED", "NUM_PROGRNECTED", "NUM_PROGRESSURES", "NUM_PROCESSURES", "NUM_PROCUTes", "NUM_PROCUSED", "NUM_PROCUTURES", "NUM_PROGRNECTURES", "NUM_PROGRESSED", "NUM_PROGRNECTes", "NUM_PROCNECTes"], "MEM_LIMIT_GB": ["MEM_LIMITS_AGE", "MEM_LIMITSINMB", "MEM_LIMIT2MB", "MEM_LIMITSINGB", "MEM_LIMITSINAGE", "MEM_LIMITINMB", "MEM_LIMITUSMB", "MEM_LIMIT_MB", "MEM_LIMITUSAGE", "MEM_LIMITINAGE", "MEM_LIMIT2AGE", "MEM_LIMITS_MB", "MEM_LIMITS_GB", "MEM_LIMITUSGB", "MEM_LIMITINGB", "MEM_LIMIT_AGE", "MEM_LIMIT2GB"]}}
{"code": "\\n  \\n  EOL = \"\\n\"\\n  \\n  \\n  def is_equal_approx(x, y, epsilon=1e-6):\\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\\n      \\n      By default, 'epsilon' is 1e-6.\\n      \"\"\"\\n      if -epsilon <= x - y <= epsilon:\\n          return True\\n  \\n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\\n          return False\\n  \\n      return (-epsilon <= (x - y) / x <= epsilon\\n          or -epsilon <= (x - y) / y <= epsilon)\\n    \\n  def read_syms(fd):\\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\\n      return fd.readline().strip().split()\\n  \\n  def read_ints(fd):\\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\\n      return [int(p) for p in read_syms(fd)]\\n  \\n  def read_floats(fd):\\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\\n      return [float(p) for p in read_syms(fd)]\\n  \\n  \\n  class Mtrx(object):\\n      \"\"\"A matrix object.\"\"\"\\n      \\n      def __init__(self, rows, cols, data):\\n          assert len(data) == rows * cols\\n          self.rows = rows\\n          self.cols = cols\\n          self.data = data\\n          \\n      def cell(self, r, c):\\n          return self.data[r * self.cols + c]\\n      \\n      def getrow(self, i):\\n          return [self.cell(i, c) for c in xrange(self.cols)]\\n  \\n      def getcol(self, i):\\n          return [self.cell(c, i) for c in xrange(self.rows)]\\n      \\n      @classmethod\\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\\n          \\n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\\n          Pre-determined size can be passed using `rows` and `cols`.\\n          \"\"\"\\n          data = []\\n          if rows is None:\\n              assert cols is None\\n              rows, cols = read_ints(fd)\\n          else:\\n              assert cols is not None\\n          for _ in range(rows):\\n              line = readfunc(fd)\\n              assert len(line) == cols\\n              data.extend(line)\\n          return Mtrx(rows, cols, data)\\n              \\n      @classmethod\\n      def read_int_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_ints, rows, cols)\\n              \\n      @classmethod\\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_syms, rows, cols)\\n              \\n      def __str__(self):\\n          res = \"\"\\n          for i in xrange(self.rows):\\n              res += str(self.getrow(i)) + EOL\\n          return res\\n      \\n      def __repr__(self):\\n          return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\\n                                         self.cols, self.data)\\n  \\n  \\n  cachetotals = 0\\n  cachemisses = 0\\n  \\n  def statreset():\\n      global cachemisses, cachetotals\\n      cachemisses = 0\\n      cachetotals = 0\\n  \\n  class memoizeit(object):\\n      \"\"\"Decorator. Caches a function's return value each time it is called.\\n      \\n      If called later with the same arguments, the cached value is returned \\n      (not reevaluated).\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          self.cache = {}\\n          \\n      def __call__(self, *args):\\n          \\n          global cachetotals, cachemisses\\n          cachetotals += 1\\n          \\n          try:\\n              return self.cache[args]\\n          except KeyError:\\n              \\n              cachemisses += 1\\n              \\n              value = self.func(*args)\\n              self.cache[args] = value\\n              return value\\n          except TypeError:\\n  \\n              cachemisses += 1\\n  \\n              return self.func(*args)\\n      \\n      @property\\n      def __name__(self):\\n          return self.func.__name__\\n      \\n      def __get__(self, obj, objtype):\\n          \"\"\"Support instance methods.\"\"\"\\n          return functools.partial(self.__call__, obj)\\n  \\n  \\n  class timeit(object):\\n      \"\"\"Decorator that times a function.\\n      \\n      When function ends, print name, runtime, return value and cache stats.\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          \\n      def __call__(self, *args):\\n          start = time.time()\\n          value = self.func(*args)\\n          delta = time.time() - start\\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\\n              cachetotals else 0\\n          print self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\\n              delta, value, cachedata)\\n          return value\\n      \\n      def __get__(self, obj, objtype):\\n          return functools.partial(self.__call__, obj)\\n  \\n  \\n  def read_input(filename):\\n      data = []\\n      with open(filename, \"r\") as f:\\n          cases = read_ints(f)[0]\\n          for _ in xrange(cases):\\n              case = {}\\n              case[\"C\"], case[\"F\"], case[\"X\"] = read_floats(f)\\n              data.append(case)\\n      return data\\n  \\n  def make_output(fname, output):\\n      CASE_PRFX = \"Case #%s: \"\\n      fname = fname + time.strftime(\"%H%M%S\") + \".out\"\\n      with open(fname, \"w\") as f:\\n          restext = []\\n          print \"Output content ===============\"\\n          for i, outdata in enumerate(output):\\n              line = CASE_PRFX % (i + 1,) + str(outdata) + EOL\\n              print line,\\n              restext.append(line)\\n          print \"=\" * 30\\n          f.writelines(restext)\\n  \\n  \\n  @memoizeit\\n  def will_a_farm_help(target, current_rate, farm_cost, farm_rate):\\n      no_farm = target / current_rate\\n      with_farm = farm_cost / current_rate + target / (farm_rate + current_rate)\\n      if no_farm > with_farm:\\n          return True, farm_cost / current_rate\\n      else:\\n          return False, no_farm\\n  \\n  @timeit\\n  def solveit(case):\\n      C = case[\"C\"]\\n      F = case[\"F\"]\\n      X = case[\"X\"]\\n      \\n      t = 0\\n      current_rate = 2.0 # default rate of 2 cookies per seconds\\n      \\n      while True:\\n          new_farm, add_time = will_a_farm_help(X, current_rate, C, F)\\n          if new_farm:\\n              t += add_time\\n              current_rate += F\\n          else:\\n              t += add_time\\n              return t\\n  \\n  \\n  @timeit\\n  def main(fname):\\n      data = read_input(fname)\\n      output = []\\n      for case in data:\\n          statreset() # reset cache stats\\n          res = solveit(case)\\n          output.append(res)\\n      make_output(fname, output)\\n  \\n  \\n  if __name__ == '__main__':\\n      main(\"B-small-attempt0.in\")\\n", "target": "15", "substitutes": {"EOL": ["NAL", "EOF", "EOT", "BOF", "EAL", "NOT", "NOL", "BOL", "BAL", "LAL", "LOL", "BOT", "LOT", "NOF", "LOF"], "x": ["mx", "xxx", "ax", "xs", "w", "xt", "on", "xe", "xd", "m", "xml", "xxxxxxxx", "yx", "xi", "xp", "n", "l", "ix", "xa", "step", "fx", "lat", "text", "window", "z", "xy", "e", "rx", "hex", "time", "px", "o", "zx", "j", "xx", "dx", "wx", "v", "xxxx", "ox", "ex", "ux", "your", "ct", "h", "xc", "tx"], "y": ["s", "gy", "my", "ay", "iy", "ly", "ys", "ya", "hot", "yz", "oy", "Y", "sky", "n", "yd", "l", "yt", "z", "ies", "py", "xy", "e", "yy", "ny", "ye", "b", "axy", "o", "ey", "uy", "j", "yr", "vy", "v", "ox", "sy", "fy", "cy", "yi", "yer", "ym", "h", "yl"], "epsilon": ["epssil\u00f3n", "psilen", "psilond", "epchloron", " epiphanyoner", " epiphanyon", "psion", " epsiloning", "eptyy", " epsilone", "epsalon", "eplitor", "epslons", "eptyon", "epsloner", "epschlorony", "epssilor", "epphalony", " epsilont", "epsiloni", "psilON", "epSiloner", "epfolont", "epSiln", "epiphanyons", " epphalon", "epticoner", " epsiloner", "psien", "epsellony", "epdelayy", "epsiloton", "epSilor", "eptyond", "epslont", "epssilony", "epsilor", " epphaloning", "epsilond", "epsilont", " epsilor", "epchlorON", "epschloron", "epsilON", "epssiloni", "epiphanyon", "psiON", "epsiln", "epilons", "epssilON", "epphaloff", "epschloroni", "epmilon", "epfoloner", "epiloner", "epssilon", "epdelayen", "epmilone", "epilony", "epsilen", "epsaloner", "epsilons", "epphaloton", "epilor", "epsiy", "epsellon", "epsior", "epdelayon", " epphaloff", "epSilone", " epfoloner", "epilont", "epsion", "epsilone", "ependixn", "epssiloner", " epfolON", "epiloton", "psiond", "epsiony", "epchlorony", "epsellons", "epspellor", "epSilon", "epschlorons", "epliton", " epiphanyone", "epspellon", "epsily", "epsin", "epmilON", "epslon", "psiy", "epsell\u00f3n", "epSiloton", "epslON", "epphalon", "epiphanyoner", "eplitoning", "epssilons", "psiln", "epmiln", " epfolon", "epdelayond", "epspelloff", "epspelloning", "eptyen", "ependixon", "psione", "epphalons", "epfolON", "epssiloton", " epphalor", "epticON", "epSiloni", "epphalor", "epsione", "epsiond", "epsions", " epfolont", "epchlor\u00f3n", "epiphanyone", "eplitoff", "epsiloning", "epilon", "psin", "epchloroner", "epsiloff", "psily", "epSilons", "epphaloner", "epfolon", "epilON", " epsiloff", " epsilON", "epsiON", "epSilony", "epchlorone", "epsien", "epchlorons", "epssiln", "epsalony", "ependixoni", "epsilony", "epschlor\u00f3n", "epticon", " epiphanyons", "epchlorn", "epchloroni", "epschlorn", "epsiloner", "epticons", "psilone", "psilon", "epphaloning", "epSil\u00f3n", "epsil\u00f3n", " epsilons"], "fd": ["fed", "disk", "nd", "pdf", "dump", "ld", "kt", "pid", "ini", "ped", "file", "buff", "cf", "fax", "vd", "sd", " fid", "f", "fil", "handle", "dir", "buf", "ft", "wd", "rd", "fx", "bf", "fs", "dial", "fb", "fin", "db", "FD", "ctl", "hd", "fl", "dl", "bd", "pd", "tf", "dat", "FH", "fc", "format", "handler", "uf", "gd", "stream", "fn", "ff", "gz", "uds", "fred", "ln", "wind", "ud", "tif", "fr", "dt", "cd", "dra", "d", "fp", "df", "ad", "dd", "fm", "lf", "form", "td"], "p": ["post", "s", "gp", "pid", "P", "cp", "php", "np", "u", "w", "pi", "f", "m", "sp", "g", "dp", "n", "l", "tap", "z", "jp", "tp", "e", "ph", "ep", "pt", "q", "pol", "mp", "wp", "b", "ps", "pr", "lp", "op", "yp", "osp", "v", "pre", "rep", "pn", "pc", "pa", "ip", "type", "d", "pp", "a", "fp", "h", "pos", "part", "ap"], "self": ["s", "nd", "ng", "quick", "small", "conn", "spec", "attr", "cl", "full", "tmp", "rs", "resp", "q", "sw", "diff", "ae", "debug", "right", "api", "me", "pp", "round", "console", "instance", "log", "also", "json", "w", "details", "history", "xml", "views", "agg", "sh", "partial", "client", "left", "results", "se", "close", "parts", "md", "print", "deep", "parent", "h", "form", "eth", "help", "chart", "new", "ren", "this", "py", "body", "response", "mp", "ref", "context", "review", "ml", "add", "private", "nt", "raw", "wn", "next", "final", "rb", "my", "expr", "python", "object", "subject", "empty", "work", "public", "th", "handle", "dev", "Self", "test", "init", "local", "user", "app", "config", "request", "space", "rel", "pkg", "info", "cmp", "error", "all", "dd"], "rows": ["s", "tracks", "packages", "of", "docs", "sections", "tr", "errors", "lines", "ks", "keys", "rs", "months", "obs", "ls", "files", "sw", "ods", "OWS", "uds", "grades", "type", "pages", "reports", "boxes", "olds", "bys", "ows", "modules", "cont", "to", "jobs", "ros", "views", "types", "roots", "ips", "ors", "index", "classes", "resources", "groups", "words", "results", "ports", "images", "rw", "ow", "ios", "issues", "members", "orders", "points", "form", "ids", "length", "relations", "blocks", "projects", "cells", "ds", "names", "faces", "xs", "days", "levels", "runs", "items", "xy", "ns", " row", "get", "forms", "posts", "bs", "checks", "heads", "dates", "users", "frames", "col", "owners", "values", "cs", "times", "headers", "np", "mins", "ores", "text", "rules", "uns", "format", "fields", "grow", "ws", "workers", "tests", "rown", "row", "ords", "reads", "ins", "uploads", "each", "void", "dat"], "cols": ["columnashes", " Colensions", " colS", " coles", "clS", "colps", "iln", " colts", "colats", " colats", "ctn", " colsets", "colabs", "COLts", " Cols", "colts", "rowssets", "columnensions", "columnps", "ilS", "collS", "ilms", "colms", "roundabs", " colps", "iles", "locs", "rowsS", "col2", "coli", "columnsys", "il2", "ils", "crypts", "columnats", "COLes", "coln", "columni", "rowss", "columnts", "ct2", "columnes", "clals", " colgs", "colS", " colots", "coles", "collps", "cryptps", " coln", "COLs", "butes", "colals", "pooli", "Cols", "COLS", "ilsys", "roundts", "colains", "ctts", "COLps", "colsets", "colashes", "locms", "columnains", " col2", "columnS", "columnots", "columnals", "colls", "butashes", " colashes", " coli", "locsys", " Colps", "poolps", "columngs", " colains", "cles", "butS", "rounds", "cryptains", "cts", "clots", "roundS", "buts", " colals", "Colts", "columnsets", "columnms", "ColS", "colsys", "pools", "cryptS", "ctabs", "columnabs", "collats", "colgs", "Colgs", "loces", "ctS", "colots", "clgs", "poolts", " colensions", "rowsts", "colensions", "colles", " Coles", "columns"], "data": ["done", "errors", "lines", "table", "zero", "batch", "Data", "reg", " DATA", "reports", "json", "actions", "to", "history", "index", "partial", "buffer", "da", "bytes", "groups", "results", "dict", "apps", "images", "out", "list", "feed", "array", "name", "points", "length", "blocks", "cells", "names", "new", "comments", "n", "what", "items", "this", "xy", "map", "initial", "mu", "na", "raw", "users", "trace", "next", "d", "values", "result", "times", "ata", "empty", "missing", "size", "series", "public", "csv", "steps", "text", "options", "draw", "block", "format", "rel", "info", "params", "DATA", "row", "content", "all", "dat"], "r": ["hr", "cr", "rt", "dr", "rid", "f", "m", "n", "ru", "nr", "rd", "sr", "e", "rs", "re", "q", "ir", "rb", "br", "ro", "ar", "ri", "R", "rel", "rc", "j", "mr", "er", "right", "fr", "row", "h"], "c": ["cs", "s", "cr", "cp", "cont", "uc", "ch", "u", "cf", "ic", "f", "m", "cin", "li", "g", "n", "l", "cl", "ac", "con", "ec", "arc", "e", "k", "ir", "dc", "lc", "co", "b", "fc", "cur", "o", "unc", "cos", "ce", "rc", "sc", "v", "cat", "cu", "xc", "ca", "pc", "col", "cm", "ci", "d", "cut", "ct", "h", "tc", "a", "nc", "cc"], "i": ["ti", "s", "int", "ini", "dr", "ch", "ic", "cli", "u", "pi", "f", "li", "cin", "ie", "xi", "it", "ix", "index", "l", "iri", "e", "id", "ij", "iu", "ir", "ai", "b", "o", "ri", "I", "si", "j", "mi", "info", "chain", "cor", "di", "gi", "ik", "pc", "ii", "ip", "ci", "d", "h", "oi"], "cls": ["Cls", "declns", " clps", "lassp", "clt", "CLls", "CLs", "clns", "lasst", " clic", "CLps", "declps", "clps", "clls", "CLis", "lasss", "CLts", " clis", "classic", " clns", " clls", "lassts", " clt", "Clis", "Clp", "clic", "classs", "decls", "lassns", "Clls", "clis", "classt", "clp", "lassic", " clp", " clts", "classts", "Clps", "clts", "lassps", "Clts"], "readfunc": ["writeunc", "getfunc", "readunc", "getfun", " readval", " readfunction", "readfac", "writefunc", "findfunc", " readunc", "readfunction", "readfun", "getfac", "getfunction", "writefunction", " readfac", "writeval", " readfun", "findfunction", "writefac", "writefun", "findunc", "findval", "readval"], "_": ["valid", "int", "ix", "mat", "non", "set", "ex", "val", "all", "ct"], "line": ["sample", "cmd", "file", "ine", "pair", "handle", "word", "inline", "cell", "byte", "l", "text", "lin", "detail", "lines", "column", "nl", "pipe", "entry", "block", "se", "raw", "frame", "chain", "Line", "ln", "command", "link", "page", "lo", "code", "dd", "char", "row", "next", "LINE", "part", "string", "record", "log", "lf"]}}
{"code": "\\n  \\n  EOL = \"\\n\"\\n  \\n  \\n  def is_equal_approx(x, y, epsilon=1e-6):\\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\\n      \\n      By default, 'epsilon' is 1e-6.\\n      \"\"\"\\n      if -epsilon <= x - y <= epsilon:\\n          return True\\n  \\n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\\n          return False\\n  \\n      return (-epsilon <= (x - y) / x <= epsilon\\n          or -epsilon <= (x - y) / y <= epsilon)\\n    \\n  def read_syms(fd):\\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\\n      return fd.readline().strip().split()\\n  \\n  def read_ints(fd):\\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\\n      return [int(p) for p in read_syms(fd)]\\n  \\n  def read_floats(fd):\\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\\n      return [float(p) for p in read_syms(fd)]\\n  \\n  \\n  class Mtrx(object):\\n      \"\"\"A matrix object.\"\"\"\\n      \\n      def __init__(self, rows, cols, data):\\n          assert len(data) == rows * cols\\n          self.rows = rows\\n          self.cols = cols\\n          self.data = data\\n          \\n      def cell(self, r, c):\\n          return self.data[r * self.cols + c]\\n      \\n      def getrow(self, i):\\n          return [self.cell(i, c) for c in xrange(self.cols)]\\n  \\n      def getcol(self, i):\\n          return [self.cell(c, i) for c in xrange(self.rows)]\\n      \\n      @classmethod\\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\\n          \\n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\\n          Pre-determined size can be passed using `rows` and `cols`.\\n          \"\"\"\\n          data = []\\n          if rows is None:\\n              assert cols is None\\n              rows, cols = read_ints(fd)\\n          else:\\n              assert cols is not None\\n          for _ in range(rows):\\n              line = readfunc(fd)\\n              assert len(line) == cols\\n              data.extend(line)\\n          return Mtrx(rows, cols, data)\\n              \\n      @classmethod\\n      def read_int_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_ints, rows, cols)\\n              \\n      @classmethod\\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_syms, rows, cols)\\n              \\n      def __str__(self):\\n          res = \"\"\\n          for i in xrange(self.rows):\\n              res += str(self.getrow(i)) + EOL\\n          return res\\n      \\n      def __repr__(self):\\n          return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\\n                                         self.cols, self.data)\\n  \\n  \\n  cachetotals = 0\\n  cachemisses = 0\\n  \\n  def statreset():\\n      global cachemisses, cachetotals\\n      cachemisses = 0\\n      cachetotals = 0\\n  \\n  class memoizeit(object):\\n      \"\"\"Decorator. Caches a function's return value each time it is called.\\n      \\n      If called later with the same arguments, the cached value is returned \\n      (not reevaluated).\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          self.cache = {}\\n          \\n      def __call__(self, *args):\\n          \\n          global cachetotals, cachemisses\\n          cachetotals += 1\\n          \\n          try:\\n              return self.cache[args]\\n          except KeyError:\\n              \\n              cachemisses += 1\\n              \\n              value = self.func(*args)\\n              self.cache[args] = value\\n              return value\\n          except TypeError:\\n  \\n              cachemisses += 1\\n  \\n              return self.func(*args)\\n      \\n      @property\\n      def __name__(self):\\n          return self.func.__name__\\n      \\n      def __get__(self, obj, objtype):\\n          \"\"\"Support instance methods.\"\"\"\\n          return functools.partial(self.__call__, obj)\\n  \\n  \\n  class timeit(object):\\n      \"\"\"Decorator that times a function.\\n      \\n      When function ends, print name, runtime, return value and cache stats.\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          \\n      def __call__(self, *args):\\n          start = time.time()\\n          value = self.func(*args)\\n          delta = time.time() - start\\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\\n              cachetotals else 0\\n          print self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\\n              delta, value, cachedata)\\n          return value\\n      \\n      def __get__(self, obj, objtype):\\n          return functools.partial(self.__call__, obj)\\n  \\n  \\n  def read_input(filename):\\n      data = []\\n      with open(filename, \"r\") as f:\\n          cases = read_ints(f)[0]\\n          for _ in xrange(cases):\\n              case = {}\\n              case[\"R\"], case[\"C\"], case[\"M\"] = read_ints(f)\\n              data.append(case)\\n      return data\\n  \\n  def make_output(fname, output):\\n      CASE_PRFX = \"Case #%s: \"\\n      fname = fname + time.strftime(\"%H%M%S\") + \".out\"\\n      with open(fname, \"w\") as f:\\n          restext = []\\n          print \"Output content ===============\"\\n          for i, outdata in enumerate(output):\\n              line = CASE_PRFX % (i + 1,) + EOL + str(outdata) + EOL\\n              print line,\\n              restext.append(line)\\n          print \"=\" * 30\\n          f.writelines(restext)\\n  \\n  \\n  MINE = \"*\"\\n  CLICK = \"c\"\\n  UNK = \".\"\\n  \\n  class Board(object):\\n      \\n      def __init__(self, r, c):\\n          self.rows = r\\n          self.cols = c\\n          self.edge_row_idx = self.rows - 1\\n          self.edge_col_idx = self.cols - 1\\n          self.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]\\n          self.board[0][0] = CLICK\\n  \\n      def fill_edge_row(self, m):\\n          i = self.edge_col_idx\\n          while m > 0 and i >= 0:\\n              self.board[self.edge_row_idx][i] = MINE\\n              i -= 1\\n              m -= 1\\n          self.edge_row_idx -= 1\\n  \\n      def fill_edge_col(self, m):\\n          i = self.edge_row_idx\\n          while m > 0 and i >= 0:\\n              self.board[i][self.edge_col_idx] = MINE\\n              i -= 1\\n              m -= 1\\n          self.edge_col_idx -= 1\\n  \\n      def __str__(self):\\n          return EOL.join([\"\".join(r) for r in self.board])\\n  \\n  @memoizeit\\n  def is_stage_solvable(rows, cols, mines):\\n      \"\"\"Return True iff stage is solvable. \\n      Also return fill instruction:\\n      0 if impossible/dontcare, 1 to fill row, 2 to fill column, \\n      3 for row special (most in the row), 4 for col special (most in the col)\\n      \"\"\"\\n      rc = rows * cols\\n      \\n      if mines == rc:\\n          return False, 0\\n  \\n      if rows == 1:\\n          return mines <= rc - 1, 2\\n      if cols == 1:\\n          return mines <= rc - 1, 1\\n      \\n      if mines == rc - 1:\\n          return True, 1  # doesn't matter what to fill\\n      \\n      if mines > rc - 4:\\n          return False, 0\\n      \\n      if rows == 2:\\n          return (False, 0) if mines == 1 else (True, 2)\\n      if cols == 2:\\n          return (False, 0) if mines == 1 else (True, 1)\\n          \\n      if rows <= cols:\\n          if mines >= rows:\\n              return True, 2\\n          if mines == rows - 1:\\n              if mines == cols - 1:\\n                  if rows == 3:\\n                      return False, 0\\n                  return True, 4 # L shape fill, most in the column\\n              else:\\n                  return True, 1 # fill row\\n          return True, 2 \\n      else:\\n          if mines >= cols:\\n              return True, 1\\n          if mines == cols - 1:\\n              if mines == rows - 1:\\n                  if cols == 3:\\n                      return False, 0\\n                  return True, 3 # L shape fill, most in the row\\n              else:\\n                  return True, 2 # fill column\\n          return True, 1 \\n  \\n  @timeit\\n  def solveit(case):\\n      rows = case[\"R\"]\\n      cols = case[\"C\"]\\n      mines = case[\"M\"]\\n      \\n      b = Board(rows, cols)\\n      r, c, m = rows, cols, mines\\n      \\n      while m >= 0:\\n          okgo, howtofill = is_stage_solvable(r, c, m)\\n          if not okgo:\\n              return \"Impossible\"\\n          if howtofill == 1: # fill row\\n              b.fill_edge_row(m)\\n              if m <= c:\\n                  break # fill and done\\n              m -= c\\n              r -= 1\\n          elif howtofill == 2: # fill column\\n              b.fill_edge_col(m)\\n              if m <= r:\\n                  break # fill and done\\n              m -= r\\n              c -= 1\\n          elif howtofill == 3: # L shape fill, most in the row\\n              b.fill_edge_row(m - 1)\\n              b.fill_edge_col(1)\\n              break # fill and done\\n          elif howtofill == 4: # L shape fill, most in the column\\n              b.fill_edge_col(m - 1)\\n              b.fill_edge_row(1)\\n              break # fill and done\\n          else:\\n              assert False\\n  \\n      return str(b) \\n  \\n  \\n  \\n  @timeit\\n  def main(fname):\\n      data = read_input(fname)\\n      output = []\\n      for case in data:\\n          statreset() # reset cache stats\\n          res = solveit(case)\\n          output.append(res)\\n      make_output(fname, output)\\n  \\n  \\n  if __name__ == '__main__':\\n      main(\"C-small-attempt0.in\")\\n", "target": "15", "substitutes": {"EOL": ["NAL", "EOF", "EOT", "BOF", "EAL", "NOT", "NOL", "BOL", "BAL", "LAL", "LOL", "BOT", "LOT", "NOF", "LOF"], "x": ["mx", "xxx", "ax", "xs", "w", "xt", "on", "xe", "xd", "xml", "xxxxxxxx", "yx", "xi", "xp", "n", "l", "ix", "xa", "step", "fx", "lat", "text", "window", "z", "xy", "e", "rx", "hex", "time", "px", "o", "zx", "X", "j", "xx", "dx", "wx", "v", "xxxx", "ox", "ex", "ux", "your", "ct", "h", "xc", "tx"], "y": ["s", "gy", "my", "ay", "iy", "ly", "ys", "ya", "hot", "yz", "oy", "Y", "t", "sky", "n", "yd", "l", "yt", "z", "ies", "py", "xy", "e", "yy", "ny", "ye", "b", "axy", "o", "ey", "uy", "j", "yr", "vy", "v", "ox", "sy", "fy", "cy", "yi", "yer", "ym", "h", "yl"], "epsilon": ["epssil\u00f3n", "psilen", "psilond", "epchloron", " epiphanyoner", " epiphanyon", "psion", " epsiloning", "eptyy", " epsilone", "epsalon", "eplitor", "epslons", "eptyon", "epsloner", "epschlorony", "epssilor", "epphalony", " epsilont", "epsiloni", "psilON", "epSiloner", "epfolont", "epSiln", "epiphanyons", " epphalon", "epticoner", " epsiloner", "psien", "epsellony", "epdelayy", "epsiloton", "epSilor", "eptyond", "epslont", "epssilony", "epsilor", " epphaloning", "epsilond", "epsilont", " epsilor", "epchlorON", "epschloron", "epsilON", "epssiloni", "epiphanyon", "psiON", "epsiln", "epilons", "epssilON", "epphaloff", "epschloroni", "epmilon", "epfoloner", "epiloner", "epssilon", "epdelayen", "epmilone", "epilony", "epsilen", "epsaloner", "epsilons", "epphaloton", "epilor", "epsiy", "epsellon", "epsior", "epdelayon", " epphaloff", "epSilone", " epfoloner", "epilont", "epsion", "epsilone", "ependixn", "epssiloner", " epfolON", "epiloton", "psiond", "epsiony", "epchlorony", "epsellons", "epspellor", "epSilon", "epschlorons", "epliton", " epiphanyone", "epspellon", "epsily", "epsin", "epmilON", "epslon", "psiy", "epsell\u00f3n", "epSiloton", "epslON", "epphalon", "epiphanyoner", "eplitoning", "epssilons", "psiln", "epmiln", " epfolon", "epdelayond", "epspelloff", "epspelloning", "eptyen", "ependixon", "psione", "epphalons", "epfolON", "epssiloton", " epphalor", "epticON", "epSiloni", "epphalor", "epsione", "epsiond", "epsions", " epfolont", "epchlor\u00f3n", "epiphanyone", "eplitoff", "epsiloning", "epilon", "psin", "epchloroner", "epsiloff", "psily", "epSilons", "epphaloner", "epfolon", "epilON", " epsiloff", " epsilON", "epsiON", "epSilony", "epchlorone", "epsien", "epchlorons", "epssiln", "epsalony", "ependixoni", "epsilony", "epschlor\u00f3n", "epticon", " epiphanyons", "epchlorn", "epchloroni", "epschlorn", "epsiloner", "epticons", "psilone", "psilon", "epphaloning", "epSil\u00f3n", "epsil\u00f3n", " epsilons"], "fd": ["fed", "disk", "nd", "pdf", "dump", "ld", "kt", "pid", "ini", "ped", "file", "buff", "cf", "fax", "vd", "sd", " fid", "f", "fil", "handle", "dir", "buf", "ft", "wd", "rd", "fx", "bf", "fs", "dial", "fb", "fin", "db", "FD", "ctl", "hd", "fl", "dl", "bd", "pd", "tf", "dat", "FH", "fc", "format", "handler", "uf", "gd", "stream", "fn", "ff", "gz", "uds", "fred", "ln", "wind", "ud", "tif", "fr", "dt", "cd", "dra", "d", "fp", "df", "ad", "dd", "fm", "lf", "form", "td"], "p": ["post", "s", "gp", "pid", "P", "cp", "php", "np", "u", "w", "t", "pi", "f", "sp", "g", "dp", "n", "l", "tap", "z", "jp", "tp", "e", "ph", "ep", "pt", "q", "pol", "mp", "wp", "b", "ps", "pr", "lp", "op", "yp", "osp", "v", "pre", "rep", "pn", "pc", "pa", "ip", "type", "d", "pp", "a", "fp", "h", "pos", "part", "ap"], "self": ["s", "nd", "ng", "quick", "small", "conn", "spec", "attr", "cl", "full", "tmp", "rs", "resp", "q", "sw", "diff", "ae", "debug", "right", "api", "me", "pp", "round", "console", "instance", "log", "also", "json", "w", "details", "history", "xml", "views", "agg", "sh", "partial", "client", "left", "results", "se", "close", "parts", "md", "print", "deep", "parent", "h", "form", "eth", "help", "chart", "new", "ren", "this", "py", "body", "response", "mp", "ref", "context", "review", "ml", "add", "private", "nt", "raw", "wn", "next", "final", "rb", "my", "expr", "python", "object", "subject", "empty", "work", "public", "th", "handle", "dev", "Self", "test", "init", "local", "user", "app", "config", "request", "space", "rel", "pkg", "info", "cmp", "error", "all", "dd"], "rows": ["s", "tracks", "packages", "of", "docs", "sections", "tr", "errors", "lines", "ks", "keys", "rs", "months", "obs", "ls", "files", "sw", "ods", "OWS", "uds", "grades", "type", "pages", "reports", "boxes", "olds", "bys", "ows", "modules", "cont", "to", "jobs", "ros", "views", "types", "roots", "ips", "ors", "index", "classes", "resources", "groups", "words", "results", "ports", "images", "rw", "ow", "ios", "issues", "members", "orders", "points", "form", "ids", "length", "relations", "blocks", "projects", "cells", "ds", "names", "faces", "xs", "days", "levels", "runs", "items", "xy", "ns", " row", "get", "forms", "posts", "bs", "checks", "heads", "dates", "users", "frames", "col", "owners", "values", "cs", "times", "headers", "np", "mins", "ores", "text", "rules", "uns", "format", "fields", "grow", "ws", "workers", "tests", "rown", "row", "ords", "reads", "ins", "uploads", "each", "void", "dat"], "cols": ["columnashes", " Colensions", " colS", " coles", "clS", "colps", "iln", " colts", "colats", " colats", "ctn", " colsets", "colabs", "COLts", " Cols", "colts", "rowssets", "columnensions", "columnps", "ilS", "collS", "ilms", "colms", "roundabs", " colps", "iles", "locs", "rowsS", "col2", "coli", "columnsys", "il2", "ils", "crypts", "columnats", "COLes", "coln", "columni", "rowss", "columnts", "ct2", "columnes", "clals", " colgs", "colS", " colots", "coles", "collps", "cryptps", " coln", "COLs", "butes", "colals", "pooli", "Cols", "COLS", "ilsys", "roundts", "colains", "ctts", "COLps", "colsets", "colashes", "locms", "columnains", " col2", "columnS", "columnots", "columnals", "colls", "butashes", " colashes", " coli", "locsys", " Colps", "poolps", "columngs", " colains", "cles", "butS", "rounds", "cryptains", "cts", "clots", "roundS", "buts", " colals", "Colts", "columnsets", "columnms", "ColS", "colsys", "pools", "cryptS", "ctabs", "columnabs", "collats", "colgs", "Colgs", "loces", "ctS", "colots", "clgs", "poolts", " colensions", "rowsts", "colensions", "colles", " Coles", "columns"], "data": ["done", "errors", "lines", "table", "zero", "batch", "Data", "reg", " DATA", "reports", "json", "actions", "to", "history", "index", "partial", "buffer", "da", "bytes", "groups", "results", "dict", "apps", "images", "out", "list", "feed", "array", "name", "points", "length", "blocks", "cells", "names", "new", "comments", "n", "what", "items", "this", "xy", "map", "initial", "mu", "na", "raw", "users", "trace", "next", "d", "values", "result", "times", "ata", "empty", "missing", "size", "series", "public", "csv", "steps", "text", "options", "draw", "block", "format", "rel", "info", "params", "DATA", "row", "content", "all", "dat"], "r": ["hr", "cr", "rt", "dr", "rid", "f", "n", "ru", "nr", "rd", "sr", "e", "rs", "re", "q", "ir", "rb", "br", "ro", "ar", "ri", "R", "rel", "j", "mr", "er", "right", "fr", "row", "h"], "c": ["cs", "s", "cr", "cp", "cont", "uc", "ch", "u", "cf", "ic", "t", "f", "cin", "li", "g", "n", "l", "cl", "C", "ac", "con", "ec", "arc", "e", "k", "ir", "dc", "lc", "co", "b", "fc", "cur", "o", "unc", "cos", "ce", "sc", "v", "cat", "cu", "xc", "ca", "pc", "col", "cm", "ci", "d", "cut", "ct", "h", "tc", "a", "nc", "cc"], "i": ["ti", "s", "int", "ini", "dr", "ch", "ic", "cli", "u", "pi", "f", "li", "cin", "ie", "xi", "it", "ix", "index", "l", "iri", "e", "id", "ij", "iu", "ir", "ai", "b", "o", "ri", "I", "si", "j", "mi", "info", "chain", "cor", "di", "gi", "ik", "pc", "ii", "ip", "ci", "d", "h", "oi"], "cls": ["Cls", "declns", " clps", "lassp", "clt", "CLls", "CLs", "clns", "lasst", " clic", "CLps", "declps", "clps", "clls", "CLis", "lasss", "CLts", " clis", "classic", " clns", " clls", "lassts", " clt", "Clis", "Clp", "clic", "classs", "decls", "lassns", "Clls", "clis", "classt", "clp", "lassic", " clp", " clts", "classts", "Clps", "clts", "lassps", "Clts"], "readfunc": ["writeunc", "getfunc", "readunc", "getfun", " readval", " readfunction", "readfac", "writefunc", "findfunc", " readunc", "readfunction", "readfun", "getfac", "getfunction", "writefunction", " readfac", "writeval", " readfun", "findfunction", "writefac", "writefun", "findunc", "findval", "readval"], "_": ["valid", "int", "ix", "mat", "non", "set", "ex", "val", "all", "ct"], "line": ["sample", "cmd", "file", "ine", "pair", "handle", "word", "inline", "cell", "byte", "l", "text", "lin", "detail", "lines", "column", "nl", "pipe", "entry", "block", "se", "raw", "frame", "chain", "Line", "ln", "command", "link", "page", "lo", "code", "dd", "char", "row", "next", "LINE", "part", "string", "record", "log", "lf"]}}
{"code": "\\n  BIG_NUM=100000\\n  def Solve(C,F,X):\\n      best_time=float('inf')\\n      for n in xrange(0,BIG_NUM):\\n          if n==0:\\n              farm_time=0\\n          else:\\n              farm_time += C/(2+(n-1)*F)\\n          if best_time<=farm_time: break\\n          cookie_time=X/(2+n*F)\\n  \\n          if farm_time+cookie_time<best_time:\\n              best_time=farm_time+cookie_time\\n  \\n      return '%.9f'%best_time\\n  \\n  \\n  \\n  def parse(infile):\\n      C,F,X=map(float, infile.readline().split() )\\n      return C,F,X\\n  \\n  \\n  \\n  class GCJ_Parser( object ):\\n      def __init__(self,fname):\\n          self.infile=open(fname,'r')\\n          self.NumCases=int(self.infile.readline().strip() )\\n          self.caseNum=0\\n  \\n      def __iter__(self): return self\\n  \\n      def next(self):\\n          if self.caseNum==self.NumCases: raise StopIteration\\n          self.caseNum += 1\\n          args=parse(self.infile)\\n          return self.caseNum , args\\n  \\n  \\n  def runmain():\\n      myCases=GCJ_Parser(sys.argv[1])\\n  \\n      outname=sys.argv[1].rstrip('.in')+'.out'\\n      if os.path.isfile(outname):\\n          oldout=outname+'.old'\\n          ii=0\\n          while os.path.isfile(oldout):\\n              ii+=1\\n              oldout=outname+'.old'+str(ii)\\n          os.rename(outname,oldout)\\n          print 'Rename: %s -> %s'%(outname,oldout)   \\n   \\n      outfile=open(outname,'w')\\n  \\n      for iCase, args in myCases:\\n          answer=Solve(*args)\\n  \\n          print 'Case #'+str(iCase)+':',answer\\n          print >> outfile, 'Case #'+str(iCase)+':',answer\\n  \\n  \\n  \\n  \\n  if __name__=='__main__':\\n      runmain()\\n", "target": "16", "substitutes": {"BIG_NUM": ["BIG2NAME", "BIGPRFILE", "BIg_FILE", "BIG2FILE", "BIg_Num", "BIG__NUM", "BIG2NUM", "BIGPRMAX", "BIg_NUM", "BIg2MAX", "BIg_MAX", "BIg2FILE", "BIG__MAX", "BIG_SIZE", "BIG2MAX", "BIG__FILE", "BIGPRNUM", "BIG2Num", "BIg2NUM", "BIG_FILE", "BIG2SIZE", "BIG_NAME", "BIG_MAX", "BIg_NAME", "BIG_Num", "BIg_SIZE"], "C": ["V", "CS", "G", "W", "P", "J", "CNN", "CC", "CO", "Cod", "Y", "N", "M", "O", "MC", "B", "CM", "c", "Car", "D", "CB", "CF", "Cs", "H", "K", "You", "CT", "CU", "T", "A", "I", "R", "E", "CP", "S", "Cons", "U", "CBS", "L", "Q", "VC", "Z", "WC", "Con", "Co", "Case"], "F": ["V", "G", "W", "P", "FT", "J", "GF", "FS", "Fs", "f", "Y", "AF", "FER", "N", "M", "FC", "O", "FB", "FI", "B", "File", "TF", "D", "CF", "EF", "FL", "FD", "IF", "H", "DF", "T", "UF", "I", "R", "Fe", "E", "FO", "S", "FG", "U", "L", "FP", "FN", "Q", "SF", "PF", "FF", "FA", "FE"], "X": ["V", "Tx", "G", "W", "P", "IC", "J", "TX", "FX", "XY", "Y", "XM", "N", "O", "EX", "Xi", "B", "CF", "XL", "H", "IX", "XX", "T", "A", "DX", "I", "R", "E", "S", "U", "x", "L", "ICE", "UX", "XP", "Q", "XT", "OX", "Z", "ZX", "FE"], "best_time": [" best_Time", "bestTimeruntime", "bestlytimes", "best_cost", "best_file", "best___Time", " bestlytimes", "best_tim", "bestplacetime", "bestltime", " best_times", "bestTimetime", "good_time", "best_Time", "bestplacefile", "start_ime", " bestlyvalue", "startTimetim", "best___time", "bestttimes", "bestplaceTime", "start_runtime", " bestlytime", " best_tim", "good_Time", "bestplacecost", "bestTimetim", "bestlyTime", "bestttime", "bestlytime", "best_runtime", " bestlyTime", "best_times", "best___times", "bestlruntime", " best_value", "start_time", "best_value", "bestlime", "startTimetime", "bestTimeime", "startTimeime", "start_tim", "bestltim", "best___tim", "besttTime", "startTimeruntime", " best_file", "good_times", " best_cost", "best_ime", "bestlyvalue"], "n": ["nb", "nm", "nd", "ng", "nu", "ner", "np", "note", "y", "w", "t", "f", "g", "m", "nor", "N", "l", "it", "nat", "long", "c", "z", "e", "ns", "k", "nl", "nn", "ni", "r", "ne", "b", "o", "number", "na", "j", "nt", "sn", "fn", "v", "x", "nan", "ln", "num", "nw", "un", "cn", "p", "d", "a", "name", "i", "nc"], "farm_time": ["trained_duration", "fleet_info", "farm_tim", "farmpywindow", "farmlytime", " farm_window", "fleet_time", "farm_info", " farm_rate", "farm_times", "fleetrettyform", "trained_time", "farmrettyduration", "fleet_Time", "farmrettytim", "farmlytimes", " farm_size", " farm_times", " farm_timer", "fleetrettyTime", "farm_size", "farmpytime", "farm_timer", "fleet_form", "fleetrettyinfo", "farm_window", "farm_Time", "trainedrettyduration", "farmpyTime", "farm_duration", "trainedrettytim", "fleetrettytime", "farmlyTime", "farmrettyTime", "trained_tim", "farm_form", "farmrettytime", "farmpyrate", " farm_Time", "farmrettyform", "farmlysize", "farm_rate", "farmrettyinfo", "trainedrettytime"], "cookie_time": [" cookie_Time", "session_times", "cook_times", "cookierettytimes", "cookie_Time", "cookie_times", "session_time", "cook_shift", "cookie_shift", "cook_type", "cookie__Time", " cookie_task", "cookie_version", "cook_time", "cookierettytype", "cookie__times", "cookie_task", "cookie_type", " cookie_times", "cookierettyshift", "cookie__time", "session_Time", "cookie__task", "cookierettytime", "session_version"], "infile": ["inile", " inile", "inf", "iniile", "outfilename", "insline", "inblock", "readname", "inline", " inf", "outile", "logname", "logile", "outfiles", "insfile", " inblock", "infiles", "logfile", "readfiles", " inline", "insile", "infilename", "INname", "readfile", " infilename", " inname", "ininame", "INline", "inputfile", "inputname", "INf", "inputblock", "INile", "outline", "inputf", "logline", "inname", "inifile", "iniline", "readline", " infiles", "INblock", "insfilename", "INfile"], "self": ["s", "disk", "nd", "quick", "small", "t", "req", "http", "cl", "full", "proc", "rs", "tmp", "_", "resp", "q", "ls", "shape", "sw", "ae", "objects", "wrapper", "me", "ctx", "instance", "tx", "also", "book", "w", "details", "xml", "sh", "sub", "r", "left", "rec", "se", "close", "res", "md", "p", "parent", "h", "err", "func", "eth", "asm", "help", "new", "ren", "lex", "this", "py", "body", "response", "get", "mp", "student", "review", "ref", "context", "add", "private", "nt", "raw", "reader", "github", "you", "next", "final", "hw", "my", "sys", "object", "compl", "subject", "empty", "th", "public", "ind", "view", "null", "dev", "Self", "weak", "test", "init", "other", "local", "user", "app", "make", "obj", "rel", "pkg", "look", "x", "ws", "cmp", "both", "all"], "fname": ["outpath", " ffile", "fileName", "outName", "cfilename", "Ffile", "Fname", "filefile", "Fpath", "ffilename", "ffile", "cfile", "cpath", " fpath", "fpath", "filename", "fName", " ffilename", "filepath", "FName", "filefilename", "cname"], "NumCases": ["numClodes", "NumDodes", "numcaps", "Numcases", "NumCaps", "NumClases", "numCaps", "NumClase", "NumChaps", "numcase", "NumChase", "numCase", "numcases", "NumDaps", "numClases", "NumCats", "numCases", "NumClaps", "NumTodes", "numcats", "NumChases", "numCodes", "NumCase", "Numcaps", "NumTats", "NumChats", "NumTases", "numClaps", "NumDases", "Numcats", "numClase", "numCats", "Numcase", "NumCodes", "NumClodes", "NumTaps", "NumTase", "NumDase"], "caseNum": ["caseNo", "cycleNum", "aceNum", "caseNumber", "cycleName", "classObj", "testNum", " caseId", "aseName", "testNumber", "classSum", " caseObj", "testNo", "caseMu", "CaseSum", "aseNum", "CaseOff", "CaseNUM", "aseNo", "caseNUM", "caseSum", "testnum", "casenum", "Casenum", "CaseObj", "caseId", "classNum", "aceNUM", "classId", "CaseName", "CaseId", "acenum", "caseOff", "CaseNumber", "aseNumber", "CaseMu", "aseOff", "CaseNo", "cycleOff", "aceNo", "aseMu", "testNUM", "caseObj", " caseSum", "cycleMu", "asenum", "CaseNum", "caseName"], "args": ["cs", "s", "mx", "cfg", "many", "cmd", "qs", "actions", "amps", "ds", "names", "ms", "GS", "w", "xs", "xt", "arr", "new", "yes", "uments", "cons", "ext", "fs", "lines", "full", "GV", "parse", "ns", "rs", "main", "config", "options", "ls", "files", "gs", "ams", "ims", "i", "posts", "obj", "words", "aws", "parts", "res", "params", "ts", "bits", "ras", "terms", "x", "axis", "ars", "frames", "fields", "arg", "tests", "ants", "ex", "ags", "arms", "aux", "atts", "ins", "name", "values", "flags", "Args", "points"], "myCases": ["mycases", "mycase", "myClategories", "MyClases", "MyCases", " myCased", "myCompased", " mySats", "mySats", "mycats", "myAcases", " myCase", "mycased", "myCompases", "MyClase", "myCategories", " mySases", "mySased", "myClase", "mySases", "MyClased", "myAcase", "myAcategories", "myAcased", "myCase", "myClats", "mySase", " mySased", "myClased", "myCased", "MyClategories", "myCats", "myClases", "MyCased", "myCompase", "MyCategories", " myCats", "myCompategories", "MyCase", " mySase"], "outname": ["oldbase", "outpath", "formman", "outbase", "outto", "outparent", "fparent", "olddir", "outame", "Outname", "lockman", "tmpfile", "outputto", "oldpath", "Outdir", "indir", "formlat", "outName", "iname", "outputname", "lockName", "formName", "oldparent", "OUTpath", "oldame", "Outto", "outputName", "lockname", " outbase", "offdir", "into", "tmpName", "Outame", "offame", "oldName", " outman", " outame", "OUTname", "offfile", "ffile", "inName", "formname", "oldname", "outdir", "tmpname", " outName", "Outbase", "outputfile", "outman", "OUTfile", "fpath", "outlat", "inbase", "offname", " outlat", "OutName", "Outfile", "tmppath", "inname", "OUTparent", "oldfile", " outpath", "locklat"], "oldout": ["oldnet", " oldex", "oldold", "ldout", "olderin", "Oldobj", "newch", "newin", "oldch", " oldobj", " oldname", "olderch", " oldin", " olden", "Olden", " oldOut", "oldobj", "olderex", "altout", "ldold", "oldoff", "oldin", " oldnet", "newout", "altin", "OldOut", "olderen", "olderold", "olderOut", " oldch", "oldname", " oldold", "olderoff", "newnet", "oldex", "Oldnet", "oldername", "olderout", "oldernet", "altname", "olderobj", " oldoff", "altoff", "Oldname", "oldOut", "ldex", "Oldout", "olden", "ldname"], "ii": ["ti", "chi", "say", "ini", " ni", "ta", "pi", "li", "ami", "fee", "xi", "innie", "lli", "iri", "isa", "iw", "II", "aii", "mini", "zi", "hi", "hai", "ni", "tower", "ai", "nai", "eye", "ims", "sci", "si", "iii", "mi", "ifi", "qi", "di", "ice", "iso", "ios", "tif", "irm", "oci", "ci", "eni", "ei", "i"], "outfile": ["newf", "inFile", " outf", "outputname", "newfile", "oldf", "outf", "oldFile", "newout", "outputFile", "oldname", "outputfile", "newFile", " outFile", "outputout", "newname", "outout", "inname", "oldfile", "outFile", "inout"], "iCase": [" iTest", "Icase", "adiFrame", "adiCl", "ICase", "iCl", "iLock", " iCl", "IConnection", "biClass", " iFrame", "iFrame", " iClass", "iniCase", "adiCase", "liFrame", "iClass", "liClass", "liCl", "icase", "iConnection", " iLock", "biCase", "iTest", "licase", "inicase", " icase", "iniLock", "liCase", "bicase", "adicase", "biTest", "ILock", "liTest", " iConnection", "iniConnection"], "answer": ["interpret", "Answer", "ell", "result", "value", "say", "approximately", "rue", "accept", "ze", "anova", " unanswered", "yes", "again", "echo", "response", "example", "entry", "ain", "wer", "ake", "draw", "ence", "see", "swers", "answered", "menu", "affle", "about", "offer", "description", "remember", "aim", "onse", "aq", "OVA", "question", "equ", "turn", "issue", "next", "mate", "rez", "ace", "ache", "a", "au", "eni", "name", "bring", "ee", "anch", "ave"]}}
{"code": "\\n  def Fill(outmat,R,C,F):\\n      nF=F\\n      outmat[:2,:2]='.'\\n      nF-=4\\n      if nF==0: return\\n  \\n      outmat[2,:2]='.'\\n      nF-=2\\n      if nF==0: return    \\n  \\n      outmat[:2,2]='.'\\n      nF-=2\\n      if nF==0: return\\n  \\n      for iC in xrange(3,C):\\n          if nF==1:\\n              outmat[2,2]='.'\\n              return\\n          outmat[:2,iC]='.'\\n          nF-=2\\n          if nF==0: return\\n          \\n      for iR in xrange(3,R):\\n          if nF==1:\\n              outmat[2,2]='.'\\n              return\\n          outmat[iR,:2]='.'\\n          nF-=2\\n          if nF==0: return\\n  \\n      for iR,iC in ( (iR,iC) for iR in xrange(2,R)\\n                     for iC in xrange(2,C)):\\n          outmat[iR,iC]='.'\\n          nF-=1\\n          if nF==0: return\\n      \\n  \\n  \\n  \\n  def Solve(R,C,M):\\n      F=R*C-M\\n      if F==0: return '\\nImpossible'\\n      if (R>1 and C>1 and F in (2,3)):\\n          return '\\nImpossible'\\n  \\n      outmat=np.zeros( (R,C), dtype='S1')\\n      outmat[:,:]='*'\\n  \\n      if R==1:\\n          for i in xrange(F):\\n              outmat[0][i]='.'\\n      \\n      elif C==1:\\n          for i in xrange(F):\\n              outmat[i][0]='.'\\n  \\n      elif F>1:\\n          if F in (2,3,5,7): return \"\\nImpossible\"\\n          elif (R==2 or C==2) and F%2 != 0:\\n              return \"\\nImpossible\"\\n          elif R==2:\\n              outmat[:,:F/2]='.'\\n          elif C==2:\\n              outmat[:F/2,:]='.'\\n          else: Fill(outmat,R,C,F)\\n          \\n      outmat[0,0]='c'\\n      outmatlines=[ ''.join(x) for x in outmat ]\\n      answer='\\n'+'\\n'.join(outmatlines)\\n  \\n      Verify(answer,F)\\n  \\n      return answer\\n  \\n  disp=[ (dx,dy) for dx in (-1,0,1)\\n      for dy in (1,0,-1) if (dx !=0 or dy!=0) ]\\n  \\n  def Verify(answer,F):\\n      lines=[list(x) for x in answer.split('\\n')]\\n      if len(lines[0])==0: lines.pop(0)\\n      R,C=len(lines),len(lines[0])\\n      assert lines[0][0]=='c'\\n      assert answer.count('.')+1==F\\n      q=Queue.Queue()\\n      q.put( (0,0) )\\n  \\n      def adjToMine(x,y):\\n          for dx,dy in disp:\\n              if 0<=x+dx<R and 0<=y+dy<C:\\n                  if lines[x+dx][y+dy]=='*': return True\\n          return False\\n                  \\n  \\n      while not q.empty():\\n          x,y=q.get()\\n          for dx,dy in disp:\\n              if 0<=x+dx<R and 0<=y+dy<C:\\n                  if lines[x+dx][y+dy]=='c': continue\\n                  lines[x+dx][y+dy]='c'\\n                  if not adjToMine(x+dx,y+dy):\\n                      q.put( (x+dx,y+dy) )\\n  \\n      clicked='\\n'.join([ ''.join(x) for x in lines])\\n      if clicked.find('.')>=0:\\n          print '\\n','*'*20,\"\\nERROR, input:\"\\n          print answer\\n          print 'OUTPUT:'\\n          print clicked\\n      \\n  \\n  \\n  \\n  def parse(infile):\\n      R,C,M=map(int, infile.readline().split() )\\n      return R,C,M\\n  \\n  \\n  \\n  class GCJ_Parser( object ):\\n      def __init__(self,fname):\\n          self.infile=open(fname,'r')\\n          self.NumCases=int(self.infile.readline().strip() )\\n          self.caseNum=0\\n  \\n      def __iter__(self): return self\\n  \\n      def next(self):\\n          if self.caseNum==self.NumCases: raise StopIteration\\n          self.caseNum += 1\\n          args=parse(self.infile)\\n          return self.caseNum , args\\n  \\n  \\n  def runmain():\\n      myCases=GCJ_Parser(sys.argv[1])\\n  \\n      outname=sys.argv[1].rstrip('.in')+'.out'\\n      if os.path.isfile(outname):\\n          oldout=outname+'.old'\\n          ii=0\\n          while os.path.isfile(oldout):\\n              ii+=1\\n              oldout=outname+'.old'+str(ii)\\n          os.rename(outname,oldout)\\n          print 'Rename: %s -> %s'%(outname,oldout)   \\n   \\n      outfile=open(outname,'w')\\n  \\n      for iCase, args in myCases:\\n          answer=Solve(*args)\\n  \\n          print 'Case #'+str(iCase)+':',answer\\n          print >> outfile, 'Case #'+str(iCase)+':',answer\\n  \\n  \\n  \\n  \\n  if __name__=='__main__':\\n      runmain()\\n", "target": "16", "substitutes": {"outmat": ["exithat", " outMat", "inpat", "inmem", "OUTdat", " outcat", "exitmt", "upmat", "genmat", " outmem", "outputmem", "outputcat", "oukt", "newmem", "bootmt", "outdat", "newhat", "npat", "outputformat", "outkt", "scanmat", "overformat", "bootmem", " outdoc", "OUTmem", "Outmon", "outputpat", "returnmem", "newMat", "allMat", "overpat", "oumat", " outdat", " outbuf", "outhat", "outMat", "outatt", "incat", "inMat", " outmit", "outpat", "clientMat", "scanhat", "oupat", "scanformat", "nmat", "scanpat", "OutMat", " outhat", " outkt", "outputatt", "outmt", "outtag", "bootpat", "Outmem", "clienttag", "outputmit", "allmem", "uppat", "scanMat", "outcat", "OUTmon", "scandoc", "OUTmat", "Outkt", "OUTbuf", "bootkt", "Outpat", "Outmat", "overhat", "nmit", "ouformat", "genhat", "Outcat", "inmat", "outdoc", "outputmat", "ncat", "inkt", "exitmat", "OUTpat", "clientmat", " outmon", "OUTformat", "returndat", "outbuf", "returnbuf", "overmat", "clientdoc", "allpat", "upmem", "newcat", "scantag", "OUTMat", "upMat", "OUThat", " outpat", "exitpat", "Outhat", "outmon", "newmat", "newpat", "genmem", "newformat", " outformat", "Outformat", " outtag", "outmit", "boothat", "allmat", "allcat", "genpat", "OUTatt", " outmt", "outmem", "outformat", "bootmat", " outatt", "returnmat"], "R": ["V", "RS", "G", "P", "RE", "ER", "W", "J", "OR", "Y", "RG", "N", "O", "Dr", "B", "MR", "RF", "Rs", "GR", "D", "H", "r", "BR", "RA", "K", "SR", "RM", "T", "Row", "A", "RT", "I", "RO", "X", "VR", "S", "RR", "DR", "NR", "Rob", "L", "Rot", "U", "CR", "IR", "Mr", "Res", "Ram", "TR", "KR", "Q", " r", "Rat", "AR", "HR", "Br", "Ren"], "C": ["V", "CS", "G", "W", "P", "Chain", "CV", "CNN", "Cow", "Cos", "CC", "Y", "Common", "Mc", "N", "O", "FC", "MC", "Can", "B", "CM", "c", "CL", "D", "CB", "YC", "CF", "Cs", "Ch", "H", "CE", "JC", "CT", "T", "Cl", "A", "Charlie", "CD", "CU", "I", "DC", "EC", "E", "CP", "S", "BC", "L", "U", "Config", "CR", "KC", "CW", "Col", "GC", "WC", "Con", "Three", "TC", "Co", "Craig"], "F": ["V", "G", "W", "P", "FT", "J", "GF", "Fixed", "FR", "Fs", "f", "Y", "AF", "FER", "N", "FC", "O", " f", "MF", "B", "RF", "D", "CF", "EF", "FL", "FD", "Length", "IF", "If", "H", "K", "DF", "Return", "Fif", "T", "A", "UF", "I", "Fe", "X", "Full", "E", "FO", "S", "FG", "FIN", "WF", "L", "U", "FP", "FM", "FN", "Q", "SF", "Fin", "New", "Z", "PF", "FF", "Family", "Only", "FE"], "nF": ["fnT", "nanF", "connFor", "nFM", "nwTF", "namesFF", "unH", "nFG", " nFe", "namesFO", " nD", "ynF", "pnF", "cnGF", "connFamily", "dnUF", " nE", "connFB", "anFG", "nanGF", "anFM", "namesF", "cnUF", "nwFilter", "cellGF", "connTF", "connFM", "pnTF", " nWF", "snF", "enE", " nAF", "connFW", "fnM", "cnFe", "nnWF", " nR", "noteFD", " nFrame", "nFe", "nGF", "dnF", "nR", " nN", "pnFW", "connFilter", " nM", "nanT", "nAF", "anFW", "fnFrame", "nwFW", "unF", "nD", "mnFW", "anFK", "mnFF", "noneF", "NFF", "nThis", " nFD", "nFD", "cellFW", "fnE", "anF", "nE", "anFO", "nwF", "nFF", "ND", "noteN", "noteFor", "enDF", "nUF", "snE", "fnF", "anFB", "nFamily", "cnH", "nDF", "noteAF", "nwFamily", "connFG", "ynGF", "pnThis", "NF", " nFF", "nanFrame", "noteE", "unT", "nanTF", "noteFB", "connFO", "nFilter", "anFF", "nM", "noteFM", "cnFF", "namesFK", " nH", "nFW", "cellF", "snFF", "NN", "noteFF", "cnF", "nFK", "nFB", "noneFamily", "snUF", "nFrame", "connFK", "unFe", "noneFilter", "nWF", "enWF", "NFD", "snD", "nnE", "cnFB", "anGF", "ynFW", " nT", "nN", "nFO", "enF", "connGF", "noteGF", "pnFamily", "mnF", "connF", "nnDF", "nT", "snDF", "namesE", "noteTF", "namesAF", "dnThis", "namesFG", "ynUF", "nFor", "cellUF", "pnDF", " nDF", "NT", "noneFO", "NR", "nH", "cnT", "dnDF", "NE", "nTF", "nnF", "noteF", "pnUF", "cnFW", "nwFO", "snThis", "fnR", "nanE", "NM", "nanFor", "mnFB"], "iC": ["iCon", "iniCS", " iWC", "icCs", " iCh", "giI", "iCl", " iCR", "hiT", "iCs", "iCR", "iuC", " iCl", " iCS", "giA", "uiT", "uiCh", " iCs", "iCh", "hiCh", "iuR", " iI", "icC", "aiCs", "aiCon", "uiC", "iuWC", "itC", "liCR", "iWC", " iCon", "itCs", "giCs", "iniCl", "iT", "icCon", "iCS", "iniI", "giCl", " iT", "giR", "liC", "aiC", "itR", "iuCR", "hiC", "iniCs", "liR", "hiCs", "uiCs", "iA", "aiR", "pR", "giC", "pCl", "itA", "icR", "pCS", " iA", "iniR", "iI", "pC", "liWC", "iniC"], "iR": ["icRs", "phiR", " iP", "iRow", "iRO", "iSR", " iCR", "liRR", "iCR", "diR", "phiRO", "icRow", "siRow", " iT", "phiRs", " iD", "phiM", "diC", "riR", "iRR", "piT", "piC", "irR", "ciC", "siR", "irRO", "iniM", "iD", "iiC", "ciCR", "iP", "piSR", "piD", "jiRow", "iiR", "riP", "icR", "iniR", "icB", "jiB", "irM", " iRR", "ciR", "diCR", "siRs", "iT", "iniP", "piRR", " iSR", "jiR", "riC", "piR", "iiT", "piP", "piRs", "riM", "iniC", "liP", "irRs", "piM", "jiRs", "iiD", "siB", "iRs", "liR", "liSR", "iB", "iM", "piRO"], "M": ["V", "Mon", "G", "Mo", "W", "P", "MT", "J", "Y", "m", "N", "O", "MF", "MC", "B", "CM", "MR", "D", "CB", "H", "K", "MI", "RM", "T", "A", "I", "X", "E", "MAT", "S", "L", "Mi", "FM", "Q", "MM"], "i": ["ti", "int", "ini", "ic", "ind", "pi", "f", "li", "m", "t", "it", "n", "Ni", "ix", "index", "l", "c", "il", "z", "e", "k", "zi", "id", "ij", "r", "ir", "ai", "b", "phi", "im", "o", "I", "si", "j", "mi", "v", "ib", "ik", "di", "ip", "ig", "ci", "p", "a", "io"], "outmatlines": [" outxyvals", "outpatlines", "outMatvals", " outxylines", "outmatls", "outpatvals", "outMatline", "outpatline", "outpatls", " outmatvals", " outxyline", " outxyls", "outxylines", " outmatline", "outmatvals", "outMatlines", "outxyvals", "outMatls", "outxyline", "outxyls", " outmatls", "outmatline"]}}
{"code": "for i in range(int(input())):\\n  \\n      c, f, x = tuple(map(float, str.split(input())))\\n  \\n      base_time = 0.0\\n      base_rate = 2.0\\n      farms_count = 0\\n      best_time = None\\n  \\n      current_time = base_time + x / (base_rate + farms_count * f)\\n  \\n      while best_time is None or best_time > current_time:\\n  \\n          best_time = current_time\\n          base_time += c / (base_rate + farms_count * f)\\n          farms_count += 1\\n  \\n          current_time = base_time + x / (base_rate + farms_count * f)\\n  \\n      print(str.format(\"Case #{}: {}\", i + 1, best_time))\\n", "target": "17", "substitutes": {"i": ["ti", "s", "my", "ini", "y", "ic", "cli", "u", "pi", "li", "m", "xi", "multi", "n", "it", "key", "ix", " ii", "e", "zi", "id", "q", "ai", "b", "I", "si", "j", "mi", "qi", " j", "di", "gi", "yi", "ii", "me", "ci"], "c": ["cs", "s", "conf", "cp", "u", "ic", "t", "m", "g", "n", "l", "com", "C", "ac", "ec", "con", "e", "r", "dc", "lc", "co", "b", "fc", "unc", "cos", "ce", "count", "v", "p", "ci", "ct", "a", "d", "h", "xc", "cc"], "f": ["of", "frequency", "cf", "w", "t", "m", "fac", "g", "l", "sf", "float", "fx", "fs", "z", "full", "fb", "e", "factor", "fl", "q", "r", "tf", "fc", "fa", "fen", "fg", "xf", "fun", "rf", "fi", "v", "count", "F", "fd", "fr", "df", "p", "d", "all", "fp", "h", "fm", "func"], "x": ["cox", "y", "ic", "input", "w", "xs", "xt", "t", "xe", "m", "xd", "xi", "xp", "n", "l", "xa", "fx", "z", "e", "xy", "rx", "r", "xes", "b", "fc", "xf", "X", "xx", "wx", "v", "ox", "ex", "p", "ci", "a", "h", "xc", "tx"], "base_time": ["commonTimememory", "base7time", "base8speed", "baseTimecounter", "baseTimerate", " base2path", "base__counter", "base27rate", "commonTimetime", "base128path", " base_path", "base27path", "base__memory", "base27template", "base2time", "commonTimerate", "base__rate", "base_clock", "base64name", "commonTimecounter", " base_template", "base_speed", "base2clock", "base64time", "base7rate", "base2path", " base_clock", " base2clock", "base27time", "common_rate", "base8name", "base128rate", "common_memory", " base2rate", "base128clock", "base128time", "base_template", "base_path", "base7template", " base_name", "base7path", "common_time", "base__time", " base2time", "base8rate", "baseTimememory", "base_name", "base8time", "common_counter", "base2rate", " base_speed", "base_memory", "baseTimetime", "base64speed", "base64rate", "base_counter"], "base_rate": ["baseacrace", "server_rate", "base2rates", "base5Rate", "base_rates", " base_function", "server_key", "base17function", "base17time", "base2frequency", "base_race", "base_sequence", "base5sequence", "base2time", "base17race", "base_Rate", "base_function", "baseingfunction", "basepyfrequency", "basepyrates", " base_relation", "server_Rate", "base17rate", "base_frequency", "base17relation", "base_relation", "base5rate", "baseacrelation", " base_erate", "base64key", " base_race", "basepytime", "base_key", "base64sequence", "base64Rate", "baseingrate", " base_rates", " base_frequency", "baseingerate", "server_sequence", "base5key", "basepyrate", "baseacrate", "base2rate", "base_erate", "baseingtime", "base17erate", "base64rate"], "farms_count": ["farms_core", "farms_counter", "farms___count", "farms___label", "fras_flag", "farms_label", "fras12call", "farms__call", "founters_cycle", "fras_no", "founters_count", "farmsCountcount", "farms3force", "farms_cycle", "farms__no", "farms12force", "farms_no", "fras_call", "fras_force", "farmsCountflag", "fras_len", "farms_Count", "farms_flag", "farms_child", "farm_Count", "farms3count", "farms___score", "fras12force", "farms_len", "founters_score", "farms__force", "farm_count", "farms_score", "farms__count", "farms12no", "fras_count", "fras12count", "farmsCountchild", "founters_label", "farms3no", "farm_counter", "fras12no", "farm_flag", "farms12call", "farms_call", "farms12count", "farms_force", "farms3call", "farms___cycle", "farm_child", "fras_core"], "best_time": ["best_message", "best1count", " best_Time", " best_temp", "best_timeout", "bestptrate", "bestxruntime", " best_t", "average_count", "bestlyrate", "best1time", "best_Time", "bestpttime", "best1ime", "average_time", "best_t", "best_temp", "bestxtimeout", "best_rate", "besttt", "bestttemp", "best1Time", " best_rate", " best_count", "bestxtime", "bestlyTime", "bestttime", "bestlytime", "average_ime", "best_runtime", " best_runtime", " best_timeout", "bestlymessage", " best_message", "bestptTime", "average_Time", "bestptcount", "best_count", "bestxTime", "besttruntime", "best_ime"], "current_time": ["currentlyport", "currenttport", "current_stream", " currentttim", "oldtTime", "old_name", " currentttimeout", " currenttport", "current_speed", " current_tim", "currentttim", "complete_stream", "current_name", " current_rate", "currenttday", " current_timeout", "currentlytimeout", "current_day", "current_port", "current_timeout", "oldttime", " current_port", "currentttimeout", "oldtday", " currentttime", " current_Time", "currenttname", "currentlytim", "complete_rate", "current_rate", "old_time", "current_tim", "oldtname", "complete_time", "currentlytime", "old_day", "currenttTime", "currentttime", "complete_speed", "current_Time", "old_Time"]}}
{"code": "\\n  \\n  '''\\n  ...\\n  ...\\n  ...\\n  ...\\n  ...\\n  '''\\n  \\n  for i in range(int(input())):\\n  \\n      r, c, m = tuple(map(int, str.split(input())))\\n      count = r * c - m\\n      field = dict(map(lambda c: (c, \"*\"), itertools.product(range(c), range(r))))\\n      answer = \"Impossible\"\\n  \\n      if m == 0:\\n  \\n          answer = field\\n  \\n      elif 1 in (r, c):\\n  \\n          for p in itertools.islice(itertools.product(range(c), range(r)), count):\\n  \\n              field[p] = \".\"\\n  \\n          answer = field\\n  \\n      elif count in (0, 2, 3, 5, 7):\\n  \\n          pass\\n  \\n      elif count == 1:\\n  \\n          answer = field\\n  \\n      elif count // 2 < c or count == c * 2 + 1:\\n  \\n          if count % 2 != 0:\\n  \\n              tail = 3\\n              ncount = count - 3\\n  \\n          else:\\n  \\n              tail = 0\\n              ncount = count\\n  \\n          for x in range(ncount // 2):\\n  \\n              field[(x, 0)] = field[(x, 1)] = \".\"\\n  \\n          for x in range(tail):\\n  \\n              field[(x, 2)] = \".\"\\n  \\n          answer = field\\n  \\n      elif not (c == 2 and count % c == 1):\\n  \\n          for x in range(c):\\n  \\n              field[(x, 0)] = field[(x, 1)] = \".\"\\n  \\n          count -= 2 * c\\n          tail = 0\\n          if count % c == 1:\\n  \\n              tail = 2\\n              count -= 1\\n  \\n          y = 2\\n          while count > 0:\\n  \\n              rx = min(count, c)\\n              for x in range(rx):\\n  \\n                  field[(x, y)] = \".\"\\n  \\n              count -= rx\\n              y += 1\\n  \\n          for x in range(tail):\\n  \\n              field[(x, y)] = \".\"\\n  \\n          answer = field\\n  \\n      field[(0, 0)] = \"c\"\\n      print(str.format(\"Case #{}:\", i + 1))\\n      if isinstance(answer, dict):\\n  \\n          for y in range(r):\\n  \\n              print(str.join(\"\", map(lambda x: field[(x, y)], range(c))))\\n  \\n      else:\\n  \\n          print(answer)\\n", "target": "17", "substitutes": {"i": ["ki", "ti", "ini", "ic", "ind", "pi", "f", "li", "t", "xi", "multi", "it", "n", "l", "e", "zi", "ij", "phi", "b", "im", "ri", "I", "si", "j", "mi", "v", "di", "gi", "ii", "ip", "ci", "d", "a", "ei"], "r": ["range", "rr", "rt", "cr", "u", "t", "f", "g", "err", "n", "l", "nr", "rd", "sr", "e", "rs", "re", "ir", "q", "co", "b", "ro", "br", "ra", "ar", "R", "rc", "j", "res", "mr", "v", "er", "rl", "run", "rar", "a", "d", "rb"], "c": ["s", "u", "t", "g", "l", "cl", "C", "k", "_", "q", "co", "b", "fc", "bc", "cos", "ce", "rc", "j", "v", "cd", "ct", "a", "tc", "nc", "cp", "anc", "w", "cin", "com", "ac", "z", "mc", "e", "\u00e7", "vc", "cur", "cb", "h", "xc", "f", "n", "can", "dc", "o", "sc", "col", "ci", "d", "cs", "cr", "ch", "cf", "ic", "oc", "gc", "con", "ec", "lc", "unc", "cache", "chain", "cu", "pc", "code", "cm", "cc"], "m": ["s", "ms", "t", "f", "g", "n", "M", "l", "z", "rm", "tm", "mc", "k", "e", "mm", "man", "q", "b", "um", "pm", "perm", "mod", "j", "mi", "mut", "min", "mr", "v", "dm", "num", "gm", "cm", "d", "mate", "a", "h"], "count": ["match", "conf", "t", "g", "case", "only", "cell", "l", "Count", "C", "check", "q", "co", "b", "cond", "counter", "report", "v", "hold", "force", "now", "read", "num", "sum", "cd", "type", "ct", "a", "cp", "cont", "core", "comment", "index", "z", "e", "const", "call", "term", "list", "child", "err", "name", "length", "message", "len", "f", "n", "bool", "flag", "total", "status", "id", "time", "amount", "add", "nt", "scroll", "ctr", "act", "any", "col", "d", "max", "cs", "more", "nb", "result", "cmd", "cr", "size", "ch", "cf", "ind", "current", "long", "key", "test", "gc", "ount", "reason", "lag", "um", "country", "number", "find", "cache", "cycle", "cum", "cmp", "code", "cm", "found", "all", "cc"], "field": ["relation", "tag", "match", "master", "lib", "spec", "operator", "date", "order", "general", "query", "tmp", "table", "bit", "attribute", "force", "range", "comment", "index", "window", "buffer", "util", "function", "db", "entry", "rule", "term", "dict", "prefix", "Field", "storage", "question", "simple", "join", "list", "command", "position", "filter", "child", "section", "post", "string", "record", "name", "form", "message", "ld", "domain", "input", "f", "word", "flag", "fix", "detail", "load", "option", "map", "time", "point", "document", "ment", "part", "data", "result", "value", "file", "here", "view", "null", "play", "pad", "phrase", "condition", "key", "target", "test", "service", "user", "local", "lock", "manager", "config", "control", "update", "group", "lc", "format", "inner", "number", "cache", "line", "description", "wire", "player", "fields", "error", "node", "row", "FIELD", "label", "queue", "display"], "answer": ["interpret", "Answer", "result", "value", "message", "say", " Answer", "comment", "address", "urn", "archive", "rage", "err", "test", "order", "vote", "option", "status", "write", "query", "e", "uno", "response", "reply", "version", "ve", "record", "entry", "energy", "wer", "review", "format", "see", "term", "request", "answered", "about", "cache", "description", "offer", "remember", "onse", "output", "ae", "bridge", "aq", "report", "question", "equ", "consider", "environment", "after", "out", "error", "image", "issue", "install", "enge", "row", "ace", "exit", "ee", "come", "eni", "name", "expression", "form"], "p": ["post", "pid", "P", "cp", "np", "pe", "pair", "t", "sp", "pg", "f", "pi", "n", "par", "key", "jp", "k", "pt", "q", "ps", "o", "point", "pan", "pr", "j", "pkg", "op", "v", "pn", "pc", "pa", "page", "pl", "ip", "d", "pp", "part", "fp", "pos", "ap", "pat"], "tail": ["then", "last", "timeout", "slice", "t", "it", "l", "write", "root", "table", "zero", "termin", "tie", "source", "tails", "wind", "rl", "run", "type", "exit", "foot", "tc", "loop", "margin", "gate", "index", "buffer", "iter", "mint", "left", "term", "thread", "ret", "list", "ail", "length", "ta", "tailed", "len", "detail", "body", "gt", "state", "temp", "mi", "scroll", "bis", "col", "limit", "next", "stop", "lo", "rest", "tree", "size", "port", "rot", "offset", "condition", "test", "vote", "lock", "unit", "vt", "lead", "tt", "cycle", "chain", "wire", "grow", "nil", "level", "end", "addy"], "ncount": [" nlength", " ncond", "Ncond", "Nc", "nconst", "Ncount", "rcond", "Nconst", "NCount", "rcount", "lcurrent", "nnc", "rcurrent", "rmatch", "nlength", " ncurrent", " nc", "ncurrent", "nmatch", "rc", "ncond", "nncount", "nnCount", "Nmatch", "lmatch", " nmatch", " nconst", "nCount", "llength", "nnconst", "lcount", "rlength", "nc", " nCount"], "x": ["mx", "ax", "w", "xs", "xt", "xe", "on", "t", "xml", "yx", "xi", "xp", "n", "ach", "l", "ix", "index", "xa", "fx", "lex", "lat", "test", "z", "key", "h", "name", "xy", "e", "check", "id", "_", " xx", "q", "xes", "el", "time", "batch", "px", "es", "xf", "zx", "sw", "j", "X", "xx", "dx", "wx", "v", "bit", "xxxx", "ox", "read", "edit", "ex", "inx", "nex", "step", "ctx", "ux", "exp", "item", "xc", "tx"], "y": ["gy", "my", "ay", "iy", "ty", "yu", "ch", "ic", "hot", "w", "ys", "size", "t", "ya", "Y", "oy", "n", "yd", "ach", "l", "key", "yt", "z", "yn", "ies", "py", "wy", "xy", "yy", "e", "ny", "q", "ye", "b", "ly", "o", "ey", "uy", "by", "no", "j", "yr", "vy", "ry", "v", "sy", "fy", "out", "cy", "yi", "yer", "col", "yl", "row", "ym", "iny", "h", "dy", "ot"], "rx": ["mx", "rr", "rt", "cr", "ax", "dr", "rue", "rid", "xs", "new", "err", "yx", "xp", "eq", "nr", "ix", "rd", "lex", "fx", "xy", "wy", "re", "rax", "rc", "xx", "res", "dx", "wx", "mr", "ry", "cross", "ox", "rw", "lr", "rl", "ex", "rex", "row", "vr", "rez", "ux", "cd", "tx", "box", "max"]}}
{"code": "\\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  def debug(*args):\\n      print(*args, file=sys.stderr)\\n  \\n  fin = sys.stdin\\n  T = int(fin.readline())\\n  for case in range(1, T + 1):\\n      C, F, X = map(float, fin.readline().split())\\n  \\n  \\n      rate = 2\\n      time = 0\\n  \\n      best = 10**20\\n  \\n      while time < best:\\n          result = X / rate + time\\n          if result < best:\\n              best = result\\n          time += C / rate\\n          rate += F\\n  \\n  \\n  \\n      print(\"Case #%d: %.7f\" % (case, best))\\n  \\n", "target": "18", "substitutes": {"fin": ["sys", "gen", "ini", "conn", "dr", "file", "raf", "len", "ind", "f", "fil", "pen", "dir", "train", "n", "mn", "en", "lin", "txt", "fs", "ran", "fl", "fre", "trans", "fc", "fa", "bin", "obj", "rec", "stream", "line", "res", "reader", "fn", "FIN", "dis", "syn", "den", "ln", "fd", "fr", "Fin", "next", "fp", "han", "fun", "dat"], "T": ["V", "G", "P", "Time", "J", "TN", "t", "Y", "N", "M", "O", "B", "D", "TT", "TY", "K", "A", "I", "R", "E", "TS", "S", "TH", "L", "Q", "TR", "VT", "Z", "TC", "Case"], "case": ["Test", "match", "est", "P", " CASE", "core", "size", "pe", "cases", "com", "test", "c", "set", "example", "client", "zero", "number", "ce", "line", "cycle", "count", "ase", "one", "trial", "race", "use", "ice", "num", "cas", "error", "trace", "p", "ace", " Case", "chance", "tc", "TC", "Case"], "C": ["V", "CS", "G", "CI", "P", "Time", "CC", "CO", "Y", "N", "M", "B", "CM", "c", "D", "CF", "CB", "Cs", "K", "CE", "CU", "A", "DC", "I", "R", "E", "CP", "CA", "S", "L", "CR", "CW", "Con", "TC", "Co"], "F": ["V", "G", "W", "P", "FT", "J", "Time", "Best", "FR", "Fs", "f", "Y", "Speed", "N", "M", "FC", "Score", "D", "CF", "FD", "H", "K", "DF", "A", "I", "R", "E", "S", "FG", "L", "FP", "Rate", "Q", "Fin", "Z", "FF", "FA"], "X": ["V", "G", "W", "P", "J", "TX", "XY", "Y", "N", "M", "B", "D", "CF", "XL", "H", "K", "IX", "XX", "DX", "I", "R", "E", "S", "L", "x", "U", "UX", "XP", "Q", "OX", "MX", "Z", "ZX", "FF", "FE"], "rate": ["sample", "value", "power", "rates", "core", "trade", "frequency", "pe", "mode", "rating", "prime", "t", "ime", "base", "rat", "test", "rand", "fine", "reason", "rank", "r", "depth", "change", "rule", "term", "tie", "cycle", "force", "random", "Rate", "erate", "race", "weight", "speed", "error", "mean", "trace", "scale", "delay", "type", "average", "factor", "score"], "time": ["timer", "duration", "length", "second", "value", "message", "times", "Time", "timeout", "size", "frequency", "mode", "date", "t", "etime", "ime", "cost", "offset", "com", "step", "test", "order", "runtime", "TIME", "sequence", "change", "start", "counter", "ts", "age", "clock", "random", "x", "now", "race", "max", "error", "trace", "tim", "speed", "delay", "mean", "type", "tc", "score"], "best": ["valid", "est", "last", "short", "to", "Best", "size", "standard", "better", "new", "t", "f", "cost", "fast", "long", "only", "test", "highest", "full", "fine", "rank", "worst", "default", "progress", "b", "results", "big", "profit", "ff", "largest", "good", "x", "top", "trial", "off", "success", "old", "num", "max", "right", "fit", "end", "latest", "p", "round", "final", "stop", "just", "score", "peak"], "result": ["valid", "duration", "data", "length", "value", "Result", "match", "performance", "core", "different", "pair", "new", "date", "f", "total", "correct", "test", "this", "root", "rank", "r", "progress", "term", "results", "ter", "R", "start", "true", "ret", "res", "report", "answer", "x", "out", "success", "error", "end", "mate", "average", "lower", "final", "score"]}}
{"code": "\\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n   \\n  \\n  \\n  \\n  \\n  def debug(*args):\\n      print(*args, file=sys.stderr)\\n  \\n  fin = sys.stdin\\n  T = int(fin.readline())\\n  for case in range(1, T + 1):\\n      RR, CC, M = map(int, fin.readline().split())\\n      R, C = None, None\\n      blocks = RR*CC - M\\n      inverse = False\\n      if RR > CC:\\n          inverse = True\\n          R, C = CC, RR\\n      else:\\n          R, C = RR, CC\\n      result = None\\n      if R == 1:\\n          result = [('.' * blocks) + ('*' * M)]\\n      elif R == 2:\\n          if blocks == 1:\\n              result = ['.' + ('*' * (C-1)), '*' * C]\\n          elif blocks % 2 == 0 and blocks != 2:\\n              cc = blocks // 2\\n              result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \\n          else:\\n              result = None\\n      else:\\n          if blocks == 1:\\n              result = ['*' * C] * R\\n          elif blocks == 4:\\n              result = ['..' + (C-2)*'*']*2\\n              result += ['*'*C] * (R-2)\\n          elif blocks == 6:\\n              result = ['...' + (C-3)*'*']*2\\n              result += ['*'*C] * (R-2)\\n          for rows in range(3, R+1):\\n              for columns in range(rows, C+1):\\n                  size = rows * columns\\n                  if size - blocks >= 0:\\n                      if size - blocks <= columns - 2: \\n                          result = []\\n                          for r in range(rows):\\n                              if r < rows - 1:\\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\\n                              else:\\n                                  cc = columns - (size - blocks)\\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\\n                          for r in range(R - rows):\\n                              result.append('*' * C)\\n                      elif size - blocks == columns - 1 and rows >= 4:\\n                          result = []\\n                          for r in range(rows):\\n                              if r < rows - 2:\\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\\n                              elif r == rows - 2:\\n                                  cc = columns - 1\\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\\n                              else:\\n                                  cc = 2\\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\\n                          for r in range(R - rows):\\n                              result.append('*' * C)\\n                      \\n  \\n  \\n  \\n      print(\"Case #%d: \" % (case))\\n      if result is None:\\n          debug('impossible', blocks, RR, CC)\\n          print(\"Impossible\")\\n      else:\\n          mines = 0\\n          for r in range(RR):\\n              row = ''\\n              for c in range(CC):\\n                  rr, cc = r, c\\n                  if inverse:\\n                      rr, cc = c, r\\n                  if rr == 0 and cc == 0:\\n                      row += 'c'\\n                  else:\\n                      row += result[rr][cc]\\n                      if result[rr][cc] == '*':\\n                          mines += 1\\n              print(row)\\n          if mines != M:\\n              raise Exception(\"%d != %d %d x %d\" % (mines, M, RR, CC))\\n              \\n  \\n  \\n", "target": "18", "substitutes": {"fin": ["ven", "rt", "jen", "ini", "file", "conn", "raf", "ind", "f", "ren", "pen", "fil", "dir", "n", "mn", "skip", "tan", "en", "lin", "fs", "txt", "init", "con", "fl", "fre", "trans", "fc", "fa", "fen", "bin", "rec", "fi", "res", "reader", "fn", "FIN", "syn", "den", "ln", "fd", "fr", "irm", "din", "Fin", "fp", "han", "fun"], "T": ["V", "GT", "G", "W", "P", "TB", "Tab", "Time", "TX", "TN", "t", "Y", "N", "O", "B", "TA", "D", "UTC", "TT", "Type", "TY", "K", "A", "I", "X", "TS", "S", "TH", "L", "F", "TR", "Q", "TM", "Z", "TC"], "case": ["Times", " cycles", "times", "P", " traces", " rounds", "cycles", "tr", "Y", "cases", " cores", "runs", " tr", "Row", " cases", "X", " times", " trial", "cor", " X", " tests", " iteration", "race", "tests", "TR", "TM", "Z", "TC"], "RR": ["RS", "RE", "ER", "RB", "RFC", "RG", "CM", "MR", "RF", "Rs", "rs", "RL", "RD", "RA", "BR", "RC", "SR", "RN", "CCC", "RM", "ROM", "RT", "RO", "VR", "JR", "RI", "DR", "NR", "RW", "CR", "IR", "Mr", "TR", "TM", "LR", "AR", "HR", "VC", "RP", "Rec"], "CC": ["RS", "CS", "MT", "IC", "CNN", "Cow", "CO", "CBC", "Mc", "SC", "CL", "FC", "MC", "CM", "CB", "CF", "Cs", "PC", "CCC", "LC", "CT", "RC", "JC", "CE", "CD", "EC", "CP", "CA", "NC", "BC", "RW", "CBS", "CR", "Q", "CH", "ACK", "CW", "FF", "LR", "VC", "ACC", "CN", "LL", "McC", "WC", "TC", "TD"], "M": ["V", "G", "P", "MT", "ML", "J", "Y", "m", "MODE", "N", "CL", "MF", "MC", "B", "CM", "MR", "MN", "D", "Cs", "MP", "Ms", "K", "MI", "LM", "MD", "RM", "A", "BM", "I", "E", "S", "L", "PM", "F", "CR", "Q", "TM", "MS", "MB", "MM"], "R": ["V", "RS", "G", "Result", "P", "RE", "ER", "J", "RB", "Y", "RG", "N", "Right", "O", "Blocks", "B", "MR", "RF", "Rs", "GR", "D", "RL", "RA", "K", "BR", "RC", "SR", "H", "RM", "Row", "A", "Reader", "RT", "I", "RO", "X", "VR", "E", "RI", "S", "NR", "DR", "L", "U", "F", "RW", "CR", "IR", "Mr", "Res", "TR", "Q", "LR", "AR", "HR", "RP", "Rec"], "C": ["V", "AC", "CS", "G", "CI", "P", "W", "J", "CNN", "Cow", "COR", "CO", "Y", "CAR", "CG", "N", "Mc", "CL", "O", "MC", "HC", "B", "CM", "Count", "D", "CB", "CF", "Cs", "Ch", "H", "CCC", "RC", "CT", "JC", "LC", "CE", "CU", "A", "DC", "Cl", "CD", "I", "E", "CP", "EC", "CA", "S", "BC", "Cons", "NC", "Size", "L", "F", "U", "CR", "CON", "Q", "Cu", "CW", "VC", "GC", "WC", "TC", "Co", "SC"], "blocks": ["s", "tags", "MT", "sections", "chains", "Blocks", "errors", "lines", "Rs", "files", "rons", "bc", "elines", "styles", "stores", "works", "codes", "pages", "nos", "boxes", "RS", "bys", "modules", "actions", "usters", "cycles", "bars", "jobs", "ros", "types", "mn", "B", "classes", "mc", "bytes", "PC", "groups", "results", "events", "outs", "S", "units", "bits", "images", "assets", "args", "Mr", "mb", "rights", "offs", "members", "orders", "points", "cells", "names", "guards", "m", "breaks", "scripts", "runs", "pieces", "bs", "checks", "heads", "mr", "ctr", "users", "frames", "plugins", "MS", "ers", "values", "times", "bm", "ms", "headers", "mins", "MR", "rules", "mm", "block", "BM", "params", "limits", "mods", "workers", "tests", "locks", "MB", "builders", "reads", "ins", "maps"], "inverse": ["invert", "Inverse", "Invert", "Inject", "insject", "insvert", "conreverse", "Inreverse", "Inversible", " inversible", " invert", " inject", " inreverse", "inreverse", "inject", "conversible", "inversible", "insversible", "insverse", "converse", "convert"], "result": ["match", "power", "complete", "date", "RESULTS", "full", "root", "table", "report", "output", "answer", "debug", "run", "summary", "create", "also", "comment", "mask", "buffer", "function", "default", "results", "ret", "res", "prefix", "join", "out", "list", "command", "page", "position", "replace", "transform", "section", "name", "length", "mark", "Result", "message", "search", "new", "word", "total", "this", "response", "back", "trace", "next", "final", "data", "front", "work", "public", "view", "memory", "test", "runner", "reason", "config", "sequence", "example", "make", "product", "block", "number", "see", "cache", "description", "chain", "count", "bridge", "process", "success", "error", "mate", "all", "reverse", "void", "render", "component", "relation", "display", "be"], "cc": ["cs", "cp", "uc", "card", "cf", "ic", "ucc", "erc", "sec", "inc", "bb", "cell", "Mc", "vv", "cl", "gc", "ac", "ec", "zz", "mc", "ctl", "sq", "nn", "dc", "lc", "co", "vc", "CCC", "acc", "cus", "fc", "bc", "ck", "ce", "rc", "sc", "circ", "xx", "BC", "ctr", "cu", "cci", "cz", "cmp", "pc", "cy", "code", "cm", "cd", "cn", "ct", "ci", "pp", "kk", "tc", "ll", "cca", "nc"], "rows": ["s", "sections", "chains", "tr", "errors", "lines", "Rs", "keys", "rs", "_", "files", "OWS", "num", "pages", "height", "boxes", "range", "RS", "olds", "cont", "ows", "ries", "ros", "types", "views", "ors", "bytes", "iter", "groups", "results", "S", "res", "orders", "cells", "names", "n", "its", "runs", "items", "bs", "checks", "heads", "users", "frames", "values", "cs", "times", "cr", "headers", "cases", "states", "fields", "x", "tests", "rown", "reads"], "columns": ["characters", "characterensions", " Columns", "clt", "columnsets", "colains", "columnns", "Columns", "columnts", "colsets", "rowners", "columnes", "colns", "paragraphs", "Columnsize", "Columnes", "paragraphensions", " Columntypes", "characterS", "columnains", "paragraphns", "cltypes", "colists", "colS", "columnS", "holdsets", "colers", "colls", "columnls", " columnt", "Columnts", " Columneds", "columnt", "holdS", "cls", "rownes", "coles", "colts", "widthls", "columnensions", "Columnensions", "rownS", "columnsize", "columners", " columneds", "Columnists", " columnS", "colsize", "holds", "columnists", "widthts", "paragraphS", " columntypes", " columnists", "cleds", "cols", "widthes", "holdsize", "widths", "characterns", "Columners", "columneds", "Columnains", "colensions", " Columnt", "Columnls", " columnensions", " columnains", "Columnsets", "columntypes", "ColumnS", "rowns"], "size": ["cs", "length", "s", "data", "send", "second", "sample", "margin", "message", "power", "small", "address", "empty", " sizes", "len", "SIZE", "m", "g", "scope", "width", "total", "capacity", "site", " Size", "scan", "radius", "set", "body", "check", "bytes", "column", "settings", "dimension", "time", "extra", "shape", "format", "see", "number", "space", "si", "tie", "multiple", "sc", "chain", "align", "style", "count", "news", "Size", "storage", "scroll", "sized", "grow", "ice", "num", "fit", "scale", "sum", "type", "ci", "height", "name", "ize", "score"], "r": ["hr", "range", "adr", "rt", "cr", "dr", "w", "t", "f", "m", "err", "n", "l", "nr", "rd", "Rs", "sr", "rs", "re", "q", "ro", "Row", "ur", "ar", "o", "rec", "pr", "j", "res", "yr", "mr", "usr", "x", "er", "fr", "vr", "run", "d", "rar", "p", "rb", "i"]}}
{"code": "\\n  T = int(input())\\n  for case in range(1,T+1):\\n      C,F,X = (Decimal(x) for x in input().split())\\n      \\n      ans = X/2\\n      time,rate = 0,2\\n      while True:\\n          if time >= ans:\\n              break\\n          ans = min(ans,(X/rate)+time)\\n          time,rate = time+(C/rate),rate+F\\n      print(\"Case #\",case,\": \",ans,sep = '')\\n", "target": "19", "substitutes": {"T": ["V", "G", "W", "P", "Time", "TX", "TN", "t", "Y", "N", "M", "O", "B", "D", "TT", "K", "A", "I", "R", "E", "TS", "S", "WT", "L", "Q", "TM", "Z", "TC", "OT", "Case"], "case": ["CI", "P", " CASE", "core", "pe", "ind", "cases", "test", "switch", "c", "name", "set", "PC", "example", "CE", "context", "ce", "line", "cycle", "ASE", "ase", "U", "one", "trial", "race", "ice", "code", "cas", "TC", "type", "ci", "ace", " Case", "tc", "XXX", "i", "Case"], "C": ["V", "CS", "G", "CI", "P", "W", "Time", "CC", "CO", "Y", "N", "M", "B", "CM", "c", "D", "CF", "CB", "Cs", "CT", "CU", "A", "I", "R", "E", "CP", "CA", "S", "L", "U", "TC", "Co", "Case"], "F": ["V", "G", "W", "P", "RE", "J", "Time", "String", "Function", "Fs", "f", "N", "M", "FC", "O", "Float", "B", "D", "CF", "FD", "H", "A", "I", "R", "Fe", "Full", "E", "S", "FG", "L", "U", "FP", "Q", "Z", "FF", "FE"], "X": ["V", "Tx", "ANS", "P", "Time", "TX", "CC", "Y", "XM", "N", "EX", "TIME", "PC", "TY", "CE", "CT", "IX", "XX", "A", "DX", "I", "R", "E", "TS", "S", "L", "U", "Rate", "AN", "UX", "XP", "Q", "XT", "OX", "IME", "Z", "ZX", "XXX", "FE"], "x": ["mx", "cox", "ax", "y", "u", "xs", "xt", "t", "xe", "f", "xi", "xp", "n", "l", "ix", "xa", "fx", "c", "z", "e", "xy", "rx", "plex", "xb", "q", "xf", "xx", "cross", "dx", "wx", "v", "ox", "ex", "inx", "ctx", "p", "ux", "item", "xc", "i", "tx"], "ans": ["cs", "s", "ANS", "rates", "times", "span", "amps", "ms", "names", "anas", "aces", "xs", " Ans", "cases", "ean", "anos", "aus", "can", "ates", "errors", "ces", "ents", "lines", "ns", "rs", "ran", "ls", "uns", "ats", "ons", "es", "pan", "asms", "was", "ts", "ras", "terms", "an", "An", "AN", "ants", "arts", "ann", "mean", "au", "rans", "ays", "reads", "ens", "ins", "ians", "ations"], "time": ["timer", "sample", "length", "choice", "duration", "value", "message", "times", "data", "rice", "Time", "timeout", "ms", "size", "frequency", "date", "t", "history", "etime", "ime", "m", "step", "index", "stop", "test", "c", "tm", "name", "TIME", "set", "event", "change", "context", "point", "pan", "start", "space", "counter", "true", "cycle", "count", "ts", "age", "an", "top", "race", "ice", "speed", "trace", "tim", "mean", "IME", "type", "tick", "tc", "seconds", "max", "tx"], "rate": ["range", "duration", "length", "sample", "value", "power", "rates", "ate", "rice", "core", "trade", "ine", "frequency", "mode", "rating", "prime", "date", "ime", "base", "rat", "test", "rand", "fine", "rank", "re", "control", "r", "ride", "change", "rule", "se", "line", "cycle", "ry", "age", "force", "erate", "Rate", "race", "code", "weight", "speed", "mean", "scale", "delay", "type", "factor", "score"]}}
{"code": "T = int(input())\\n  \\n  def solve(R,C,M):\\n      if R>C:\\n          flipboard = solve(C,R,M)\\n          if flipboard:\\n              return [[flipboard[j][i] for j in range(C)] for i in range(R)]\\n          else:\\n              return\\n      if M==0:\\n          board = [['.']*C for i in range(R)]\\n          board[-1][-1] = 'c'\\n          return board\\n      if R == 1:\\n          board = ['*' if i<M else '.' for i in range(R*C)]\\n          board[-1] = 'c'\\n          return [board]\\n      if R == 2:\\n          if R*C==M+1:\\n              board = [['*']*C for i in range(R)]\\n              board[-1][-1] = 'c'\\n              return board\\n          if (M%2) or (M+2)==(R*C):\\n              return\\n          board = [['*' if i<(M/2) else '.' for i in range(C)] for j in range(R)]\\n          board[-1][-1] = 'c'\\n          return board\\n      if M>=R:\\n          subboard = solve(R,C-1,M-R)\\n          if subboard:\\n              return [['*']+r for r in subboard]\\n          return\\n      if (R,C,M) == (3,3,2):\\n          return\\n      k = min(M,C-2)\\n      board = [['*']*k+['.']*(C-k)]\\n      for i in range(M-k):\\n          board.append(['*']+['.']*(C-1))\\n      while len(board)<R:\\n          board.append(['.']*(C))\\n      board[-1][-1] = 'c'\\n      return board\\n      \\n           \\n      \\n  \\n  for case in range(1,T+1):\\n      print(\"Case #\",case,\": \",sep='')\\n      R,C,M = (int(x) for x in input().split())\\n      ans = solve(R,C,M)\\n      if ans:\\n          for r in ans:\\n              print(''.join(r))\\n      else:\\n          print('Impossible')\\n  \\n  \\n", "target": "19", "substitutes": {"T": ["V", "G", "W", "P", "TB", "Time", "TN", "t", "Y", "N", "O", "B", "TA", "D", "TT", "Type", "TY", "K", "A", "I", "E", "TS", "S", "L", "F", "TR", "Q", "TM", "VT", "IT", "Z", "TI", "TC"], "R": ["V", "RS", "G", "RE", "P", "W", "Remote", "J", "Role", "ER", "Range", "Y", "RG", "Repl", "N", "O", "Right", "B", "MR", "Rs", "D", "RA", "H", "K", "RC", "ro", "RM", "Row", "A", "Reader", "RT", "I", "RO", "X", "E", "JR", "S", "RR", "DR", "L", "U", "Rot", "F", "CR", "RW", "IR", "Mr", "Res", "TR", "Q", "Run", "AR"], "C": ["V", "CS", "G", "COM", "W", "Chain", "P", "CV", "J", "CNN", "COR", "CC", "Cr", "CO", "Y", "CG", "Mc", "N", "CL", "O", "MC", "B", "c", "CM", "D", "Cs", "Ch", "H", "K", "CE", "CCC", "CT", "JC", "CU", "DC", "Cl", "A", "I", "X", "EC", "E", "Cache", "CP", "S", "CA", "L", "U", "F", "CR", "CON", "Q", "CW", "VC", "CN", "WC", "Con", "Co", "Craig"], "M": ["V", "Mon", "G", "ME", "MAN", "RE", "P", "MT", "W", "Mouse", "J", "REM", "Multi", "Y", "m", "N", "Mc", "OM", "O", "MC", "B", "CM", "c", "MR", "JM", "MN", "D", "H", "K", "MI", "IM", "LM", "RM", "A", "BM", "I", "X", "E", "EM", "S", "L", "F", "U", "Mi", "Q", "TM", "MS", "MX", "MM", "NM", "cm", "Z", "MA", "DM", "AM"], "flipboard": ["Flipbox", "flippingline", "flippedboard", "fliprow", "slippBoard", "flippboard", "fllipBoard", "flipBoard", "Flippline", "slippback", "flipprow", "flclipline", "fllipboard", "Flippedline", "flippedrow", "flipline", "slippboard", "flclipBoard", "slipBoard", "flippedback", "Flippedboard", "flipbox", "flippingBoard", "flclipboard", "fllipback", "flclipbox", "flipback", "Flipback", "Flippback", "flippedBoard", "flippback", "sliprow", "flippBoard", "flippingboard", "slipprow", "Flipboard", "flippedbox", "flippline", "flippingback", "slipboard", "fllipline", "Flippedbox", "Flippboard", "slipback", "FlippedBoard", "Flipline", "FlippBoard", "flippingrow", "FlipBoard", "flippbox", "flippedline"], "j": ["oj", "ja", "ju", "J", "jj", "y", "t", "li", "m", "g", "ie", "n", "kj", "it", "l", "ix", "c", "aj", "z", "bi", "js", "jp", "ij", "jc", "q", "ai", "b", "im", "o", "si", "v", "ik", "ip", "jump", "uj", "p", "ji", "job", "a"], "i": ["ki", "ti", "ori", "ini", "y", "u", "ic", "t", "pi", "m", "li", "ie", "xi", "n", "it", "l", "c", "il", "bi", "e", "ili", "ior", "zi", "ij", "iu", "ni", "ir", "ai", "b", "phi", "im", "o", "ri", "I", "si", "mi", "fi", "v", "ati", "ia", "ik", "gi", "di", "ian", "yi", "ii", "ip", "\u0438", "ci", "p", "ji", "iti", "\u00ed", "io", "ei", "oi"], "board": ["poll", "t", "c", "full", "check", "uno", "black", "bird", "co", "zero", "b", "ward", "cross", "bit", "hold", "bug", "run", "bar", "range", "builder", "loop", "core", "bench", "database", "rect", "pool", "ac", "buffer", "function", "room", "bro", "clean", "oard", "menu", "stream", "join", "list", "square", "p", "head", "won", "form", "bot", "valid", "length", "zone", "controller", "ard", "ner", "bo", "chart", "stone", "f", "word", "base", "body", "bank", "ro", "video", "back", "flow", "random", "rain", "box", "lo", "layout", "empty", "Board", "lay", "boards", "view", "blank", "rot", "pad", "channel", "test", "way", "runner", "lock", "door", "local", "rank", "plate", "bang", "sequence", "system", "control", "block", "aco", "inner", "land", "bin", "piece", "cho", "anks", "line", "chain", "bridge", "player", "boarding", "ack", "boot", "deck", "row", "mate", "void", "program", " boards"], "subboard": ["sumback", " subbo", "sumboard", "ubrow", "sumbo", "subbo", "childboard", "SubBoard", " subloop", "Subbox", "ubback", "setBoard", "subloop", "childBoard", "childbo", " subback", "ubloop", "setbo", "setbox", " subrow", "Subrow", "childbox", "ubboards", "subboards", "setboard", "Subloop", "subback", "subBoard", "ubBoard", " subBoard", "subrow", " subboards", "ubboard", "Subboard", "ubbo", "Subbo", "subbox", "sumboards"], "r": ["range", "s", "rr", "cr", "rt", "ard", "dr", "ner", "u", "w", "pair", "t", "f", "m", "err", "ros", "n", "ru", "l", "rat", "rd", "c", "z", "rm", "runs", "runner", "rs", "ring", "rank", "re", "rer", "ran", "q", "ir", "rb", "b", "ro", "br", "ur", "ar", "ra", "kr", "inner", "pr", "ror", "rc", "rec", "mr", "ras", "er", "out", "right", "row", "run", "p", "d", "rar", "cut", "a", "h", "rows"], "k": ["ki", "uk", "kl", "mk", "ka", "ic", "y", "w", "t", "m", "g", "tk", "n", "kj", "l", "key", "c", "kw", "z", "ks", "mc", "kh", "q", "K", "b", "kr", "km", "o", "ck", "ek", "v", "ku", "ack", "ak", "ik", "unk", "ikk", " K", "kan", "ke", "p", "d", "kk", "h", "ko", "max"], "case": ["rial", "choice", " CASE", "tc", "pe", "mode", "ind", "cases", "switch", "test", "c", "ring", "example", "block", "rule", "ce", "line", "cycle", "chain", "cor", "ase", "one", "trial", "race", "ice", "code", "cas", "row", "me", "type", "ace", "section", "name", "instance", "Case"], "x": ["s", "mx", "y", "ic", "w", "xs", "xt", "t", "at", "xe", "pair", "xi", "xp", "l", "ix", "xa", "fx", "z", "e", "xy", "xb", "q", "xes", "el", "px", "xf", "X", "ross", "xx", "dx", "wx", "v", "ox", "ex", "ctx", "p", "ux", "tx", "xc", "rx"], "ans": ["s", "os", "ANS", "relations", "rates", "actions", "angs", "amps", "ms", " fans", "anas", "aces", "anc", "cases", "ros", "aus", "aps", "can", "ents", "orts", "rs", "ns", "ran", "ls", "ai", "rons", "uns", "ats", "ons", "anks", "res", "unes", "ras", "an", "ars", "An", "AN", "ants", "arts", "ann", "rans", "ays", "ens", "ins", "acers", "ians"]}}
{"code": "f = open('Bsmall.in', 'r')\\n  g = open('outputB.txt', 'w')\\n  \\n  data = [[float(e) for e in line.strip(\"\\n\").split(' ')] for line in f]\\n  T = int(data.pop(0)[0])\\n  \\n  for i, case in enumerate(data):\\n      C, F, X = case[0], case[1], case[2]\\n      n = 1\\n      t = X/2\\n      t_next = X/(2 + F) + C/2\\n      metric = (t_next < t)\\n      while metric:\\n          n += 1\\n          t = t_next\\n          t_next = t_next - X/(2 + F*(n-1)) + C/(2 + F*(n-1)) + X/(2 + F*n)\\n          metric = (t_next < t)\\n      g.write('Case #%i: %f\\n' %(i+1, t))\\n  f.close()\\n  g.close()\\n", "target": "20", "substitutes": {"f": ["ef", "s", "ile", "conf", "af", "of", "file", "cf", "w", "l", "ft", "c", "fs", "z", "full", "fb", "fl", "r", "tf", "elf", "b", "fc", "fa", "o", "fo", "format", "fg", "xf", "uf", "alf", "j", "rf", "fi", "frame", "ff", "v", "flow", "force", "fd", "fr", "p", "d", "a", "fp", "h", "fm", "lf"], "g": ["gy", "G", "gp", "gen", "gr", "u", "vg", "w", "m", "pg", "gate", "l", "ga", "gc", "game", "c", "r", "gt", "group", "gs", "go", "b", "o", "tg", "fg", "gg", "j", "gd", "mg", "v", "reg", "gz", "force", "ger", "gi", "ig", "eg", "gm", "d", "bg", "parent", "ge", "gu"], "data": ["sample", "s", "result", "ata", "series", "size", "details", "cases", "history", "csv", "des", "done", "l", "index", "text", "items", "lines", "this", "set", "map", "ns", "iter", "table", "r", "example", "su", "group", "Data", "results", "nt", "cache", "info", "res", "dates", "reader", "x", "users", "out", "list", "open", "DATA", "p", "d", "a", "reports", "values", "dat"], "e": ["ef", "s", "de", "ue", "ine", "u", "pe", "ed", " E", "ie", "l", "en", "c", " fe", "r", "el", "b", "o", "es", "se", "ele", "element", "E", "et", " se", "ode", "ase", "ae", "x", "te", "er", "ex", "me", "p", "d", "ee", "a", "ei", "ge"], "line": ["range", "de", "ner", "file", "ine", "pe", "ze", "cell", "l", "text", "lined", "lines", "ite", "iter", "q", "r", "co", "change", "b", "block", "format", "ce", "cycle", "frame", "edge", "v", "ase", "L", "Line", "str", "te", "age", "out", "code", "lo", "row", "p", "LINE", "name", "string", "ge", "ide"], "T": ["V", "G", "W", "P", "J", "TN", "Y", "N", "M", "O", "B", "D", "TT", "H", "K", "A", "I", "R", "E", "TS", "S", "L", "U", "Q", "Z"], "i": ["ti", "int", "ini", "y", "ic", "cli", "w", "ind", "u", "pi", "li", "m", "it", "ix", "index", "key", "k", "zi", "id", "ij", "r", "ai", "b", "I", "si", "j", "mi", "qi", "v", "x", "di", "gi", "num", "ip", "ii", "ci", "p"], "case": ["choice", "result", "match", "cp", "hyp", "ch", "pe", "pair", "cases", "ie", "it", "condition", "profile", "key", "switch", "test", "c", "set", "connection", "client", "entry", "example", "co", "change", "context", "block", "rule", "cho", "piece", "section", "se", "ce", "frame", "chain", "cor", "ase", "one", "trial", "race", "ice", "code", "ex", "cas", "exc", "row", "me", "p", "ace", "part", "item", "name", "instance", "Case"], "C": ["V", "CS", "G", "W", "P", "CC", "CO", "Y", "N", "M", "O", "B", "c", "CM", "D", "CF", "Cs", "H", "K", "A", "I", "R", "E", "CP", "S", "L", "U", "CR", "CON", "Q", "Z", "TC", "Co", "Case"], "F": ["V", "G", "W", "P", "J", "GF", "FR", "Function", "FER", "Y", "Fs", "Factor", "N", "M", "FC", "O", "FB", "FI", "B", "TF", "D", "CF", "FL", "FD", "Length", "H", "DF", "I", "R", "E", "FO", "FG", "WF", "L", "FP", "Q", "SF", "Fin", "PF", "FF", "Family", "FE"], "X": ["V", "Tx", "G", "W", "P", "XXX", "Time", "J", "TX", "Y", "N", "M", "EX", "Xi", "B", "D", "HTTP", "XL", "H", "K", "CT", "IX", "XX", "Data", "A", "DX", "I", "R", "E", "S", "L", "x", "U", "UX", "XP", "Q", "XT", "OX", "MX", "Z", "ZX", "TC", "Ex", "ICE"], "n": ["nb", "nu", "tn", "names", "np", "y", "u", "note", "w", "new", "dn", "m", "network", "on", "ren", "N", "l", "it", "index", "mn", "en", "c", "z", "non", "ns", "k", "nl", "nn", "r", "ne", "norm", "b", "o", "no", "number", "na", "j", "nt", " N", "sn", "count", "v", "after", "x", "nan", "ln", "num", "un", "cn", "p", "d", "all", "name", "nc"], "t": ["s", "ti", "int", "to", "ta", "y", "w", "at", "m", "tr", "st", "it", "l", "c", "z", "tp", "k", "vt", "r", "q", "time", "tt", "b", "tu", "o", "ter", "j", "nt", "v", "ts", "after", "net", "x", "te", "out", "ent", "dt", "next", "type", "p", "ct", "a", "h", "tc", "wt", "ot"], "t_next": ["tt___new", " t2new", "ttnext", "t_j", "j_ne", " t_gen", " t2gen", "tptNext", "t2new", "t_new", "t_first", " t_Next", "t___next", "tt_new", "tt_below", "t___below", "t_below", "t__gen", "t2Next", "t2ne", "tptnext", "t___env", "t___new", " t2Next", "tt___next", " t_below", "tt___below", "t2next", "ttenv", " t2next", "tt___env", "t__Next", "j_new", "tptsub", "j_end", "t__next", "t_sub", " t_j", "t_end", " t_first", " t_sub", "ttnew", "t_gen", "t__new", "t_Next", "t_env", "t2gen", "ttbelow", " t_new", "j_next", "t_ne", "tt_next", "t2end", "tt_env"], "metric": ["memric", "imetrica", " metrica", "METrix", " metrix", "matrics", "matrique", " metrics", "metic", "METrica", "metrica", "Metrics", " metec", "imetrix", "imetrique", "METrique", "metRIC", "metrics", "matric", "imetrics", "memrics", "metec", "memec", " metRIC", "metrix", " metrique", "memRIC", "imetic", "Metec", "matic", " metic", "metrique", "METric", "imetric", "MetRIC", "Metric"]}}
{"code": "def make_string(R, C, M):\\n      grid = [['.' for j in xrange(C)] for i in xrange(R)]\\n      grid[-1][-1] = 'c'\\n      t = M\\n      for i in xrange(R):\\n          for j in xrange(C):\\n              if M:\\n                  if forbidden(R, C, t, i, j):\\n                      continue\\n                  grid[i][j] = '*'\\n                  M -= 1\\n              else:\\n                  break\\n      s = ''\\n      if M:\\n          return 'Impossible'\\n      for r in grid:\\n          s += ''.join(r)+'\\n'\\n      return s[:-1]\\n  \\n  def forbidden(R, C, M, i, j):\\n      a = M / C\\n      b = M % C\\n      if (R*C - M == 1):\\n          return False\\n  \\n      if i >= (R-2) and j >= (C-2):\\n          return True\\n  \\n      if i >= (R-2) and b:\\n          if b % 2:\\n              return True\\n          if j < b/2:\\n              return False\\n          else:\\n              return True\\n      return False\\n          \\n  \\n  f = open('Csmall.in', 'r')\\n  g = open('outputC.txt', 'w')\\n  \\n  data = [[int(e) for e in line.strip(\"\\n\").split(' ')] for line in f]\\n  T = int(data.pop(0)[0])\\n  for i, case in enumerate(data):\\n      R, C, M = case[0], case[1], case[2]\\n      num_cells = R*C\\n      if (R-1) == 0 or (C-1) == 0:\\n          s = make_string(R, C, M)\\n          g.write('Case #%i:\\n%s\\n' %(i+1,s))\\n          continue\\n      else:\\n          s = make_string(R, C, M)\\n          g.write('Case #%i:\\n%s\\n' %(i+1, s))\\n          \\n  \\n  f.close()\\n  g.close()\\n", "target": "20", "substitutes": {"R": ["V", "RS", "G", "P", "W", "ER", "RE", "J", "Remote", "Range", "Y", "RG", "N", "O", "Right", "B", "MR", "RF", "Rs", "D", "RL", "RA", "H", "BR", "RC", "SR", "Ring", "RH", "Region", "RM", "Row", "A", "RT", "I", "RO", "X", "E", "JR", "RI", "S", "RR", "DR", "NR", "L", "F", "U", "Rot", "CR", "IR", "Mr", "Res", "TR", "Q", "Cor", "AR", "Random"], "C": ["V", "AC", "CS", "G", "COM", "Cond", "W", "P", "Chain", "CI", "J", "COR", "CNN", "CC", "Cut", "Cr", "CO", "Y", "Mc", "N", "O", "CL", "MC", "B", "CM", "c", "Control", "Circ", "D", "CB", "CF", "Cs", "Ch", "H", "K", "CE", "JC", "CT", "CU", "A", "DC", "CD", "Cl", "I", "E", "CP", "Cache", "CA", "S", "EC", "Cons", "L", "F", "U", "CR", "CON", "Q", "CW", "AR", "VC", "CN", "WC", "TC", "Co", "Craig"], "M": ["V", "G", "MAN", "W", "P", "MT", "J", "MH", "Y", "m", "N", "O", "MC", "B", "CM", "MR", "JM", "D", "H", "K", "MI", "Ms", "IM", "MO", "LM", "MD", "RM", " m", "A", "I", "X", "E", "S", "SM", "L", "F", "U", "Mi", "PM", "Q", "TM", "MS", "MM", "NM", "Z", "MA", "VM", "DM", "AM", "Manager", "Method"], "grid": ["cs", "range", "rr", "cells", "Grid", "gr", "stock", "rid", "w", "lay", "m", "cell", "ut", "lat", "dq", "c", "window", "mat", "z", "order", "lines", "cart", "addr", "db", "map", "set", "tmp", " Grid", "sq", "q", "client", " grids", "time", "cur", "cache", "close", "res", "chain", "v", "reg", "ts", "wire", "storage", "age", "er", "out", "tile", "code", "sim", "node", "coord", "row", "gm", "cm", "box"], "j": ["jl", "ja", "J", "jj", "ch", "y", "u", "ind", "tr", "li", "m", "ie", "n", "it", "kj", "l", "ix", "key", "index", "c", "aj", "h", "z", "js", "bi", "jp", "k", "dj", "id", "ij", "jc", "ir", "q", "co", "bj", "im", "o", "obj", "pr", "rel", "v", "x", "fr", "jump", "uj", "ci", "ji", "p", "job", "d", "ot"], "i": ["ki", "ti", "int", "ori", "ini", "u", "ic", "y", "cli", "ind", "pi", "m", "li", "ie", "xi", "it", "n", "ami", "l", "ix", "index", "multi", "key", "c", "init", "iri", "z", "bi", "k", "zi", "id", "ij", "iu", "hi", "ir", "q", "ai", "phi", "im", "o", "ri", "I", "si", "mi", "v", "x", "ia", " I", "ib", "di", "gi", "sim", "ip", "ii", "\u0438", "ci", "p", "ji", "io"], "t": ["ta", "y", "w", "m", "n", "it", "l", "test", "c", "txt", "h", "z", "tm", "mt", "k", "TT", "time", "tt", "o", "v", "ts", "TM", "type", "p", "tz", "tc", "ot"], "s": ["os", "sm", "sts", "ed", "l", "c", "js", "lines", "ies", "rs", "ss", "ls", "less", "v", "sum", "span", "comment", "w", "types", "single", "ings", "z", "results", "parts", "S", "res", "ts", "sb", "conv", "sym", "p", "h", "err", "string", "sets", "sv", "sg", "short", "ds", "days", "comments", "m", "n", "fx", "its", "eds", "ns", "ats", "ps", "ims", "si", "sc", "d", "ers", "cs", "times", "series", "tes", "sd", "steps", "ix", "us", "fs", "set", "sq", "group", "gs", "es", "space", "dx", "str", "x", "er", "ws", "sth", "rows", "ins"], "r": ["range", "result", "cr", "rid", "w", "tr", "m", "nor", "n", "l", "rd", "c", "h", "z", "runs", "sr", "rs", "ring", "re", "ir", "q", "br", "ra", "ar", "cur", "ur", "ri", "pr", "ror", "rh", "res", "v", "reg", "right", "fr", "row", "run", "type", "d", "rar", "p", "err"], "a": ["ea", "ta", "at", "al", "m", "xa", "aj", "area", "ab", "aa", "ai", "am", "A", "ar", "o", "sa", "ae", "ao", "an", "ia", "ba", "alpha", "au", "ma"], "b": ["nb", "bt", "bm", "y", "u", "w", "m", "n", "bb", "l", "B", "c", "z", "bi", "ab", "fb", "rb", "o", "bc", "bs", "v", "x", " B", "ib", "sb", "ba", "cb", "eb", "p", "d", "h", "ot", "be"], "f": ["af", "file", "cf", "w", "m", "l", "ft", "c", "fs", "z", "fb", "fe", "fl", "q", "tf", "fc", "fo", "o", "fa", "fg", "xf", "rf", "fi", "frame", "v", "F", "x", "fd", "fr", "df", "p", "d", "fp", "h", "fm"], "g": ["cfg", "G", "gp", "gen", "gr", "vg", "w", "m", "pg", "it", "l", "ga", "og", "gc", "c", "z", "q", "gt", "group", "gs", "go", "groups", "msg", "fg", "gg", "green", "gd", "mg", "v", "reg", "gz", "out", "gi", "ger", "ig", "gm", "d", "bg", "parent", "h", "ge", "gu"], "data": ["valid", "pie", "result", "times", "players", "ds", "ata", "series", "size", "empty", "new", "details", "cases", "li", "n", "done", "l", "text", "test", "items", "lines", "ns", "da", "bytes", "example", "mu", "group", "zero", "Data", "no", "results", "info", "res", "dates", "split", "users", "trial", "list", "DATA", "next", "p", "d", "dd", "values", "dat"], "e": ["ef", "eu", "est", "ea", "y", "u", "ed", "pe", "ze", "xe", "ie", "n", "it", "l", "en", "c", "ec", "ite", "el", "ne", "o", "es", "se", "ce", "ele", "element", "E", "edge", "ae", "ase", "ode", "x", "te", "er", "eg", "me", "au", "p", "d", "ke", "ee", "ei", "ge"], "line": ["ner", "ine", "ic", "pe", "ze", "li", "n", "cell", "l", "lin", "lined", "lines", "write", "lock", "set", "iter", "q", "change", "liner", "block", "point", "close", "cycle", "frame", "et", "edge", "chain", "v", "ode", "str", "Line", "force", "age", "out", "code", "link", "row", "end", "val", "p", "name", "ge", "ide"], "T": ["V", "G", "W", "P", "J", "Time", "TN", "Y", "N", "O", "B", "D", "Type", "H", "K", "A", "I", "X", "E", "TS", "Index", "S", "L", "F", "U", "Z"], "case": ["choice", "result", "match", "ch", "catch", "pe", "pair", "cases", "it", "cell", "condition", "switch", "test", "set", "connection", "client", "entry", "group", "change", "block", "rule", "piece", "se", "ce", "chain", "ide", "ase", "one", "trial", "use", "ice", "race", "ex", "code", "cas", "exc", "lic", "row", "me", "ace", "part", "section", "instance", "Case"], "num_cells": ["numberoflines", "num_cases", "number_cases", "num_cs", "number_cs", "numofcases", "numofcs", "number_lines", "numoflines", "numberofcs", "num_lines", "numofcells", "numberofcells", "number_cells", "numberofcases"]}}
{"code": "\\n  def read_word(f):\\n      return next(f).strip()\\n  \\n  def read_int(f, b=10):\\n      return int(read_word(f), b)\\n  \\n  def read_letters(f):\\n      return list(read_word(f))\\n  \\n  def read_digits(f, b=10):\\n      return [int(x, b) for x in read_letters(f)]\\n  \\n  def read_words(f, d=' '):\\n      return read_word(f).split(d)\\n  \\n  def read_ints(f, b=10, d=' '):\\n      return [int(x, b) for x in read_words(f, d)]\\n  \\n  def read_floats(f, d=' '):\\n      return [float(x) for x in read_words(f, d)]\\n  \\n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\\n      return [reader(f, *args, **kwargs) for i in range(R)]\\n  \\n  def solve(solver, fn, out_fn=None):\\n      in_fn = fn + '.in'\\n      if out_fn is None:\\n          out_fn = fn + '.out'\\n      with open(in_fn, 'r') as fi:\\n          with open(out_fn, 'w') as fo:\\n              T = read_int(fi)\\n              for i in range(T):\\n                  case = read_case(fi)\\n                  res = solver(case)\\n                  write_case(fo, i, res)\\n  \\n  \\n  def read_case(f):\\n      return read_floats(f)\\n  \\n  def write_case(f, i, res):\\n      f.write('Case #%d: '%i)\\n      f.write('%s'%res)\\n      f.write('\\n')\\n  \\n  \\n  def solve_small(case):\\n      (C, F, X) = case\\n      res = 0\\n      i = 0\\n      while X/(2 + i*F) > C/(2 + i*F) + X/(2 + (i+1)*F):\\n          res += C/(2 + i*F)\\n          i += 1\\n      return res + X/(2 + i*F)\\n  \\n  def solve_large(case):\\n      return solve_small(case)\\n  \\n  DEBUG = 'i'\\n  \\n", "target": "21", "substitutes": {"f": ["fed", "s", "af", "file", "cf", "w", "u", "ed", "t", "pi", "g", "m", "fac", "ma", "it", "far", "l", "sf", "ft", "n", "fx", "test", "bf", "c", "fs", "z", "full", "fb", "fe", "fer", "e", "fl", "r", "q", "tf", "hl", "fc", "fo", "o", "um", "fa", "fg", "xf", "uf", "alf", "info", "ret", "fi", "ff", "v", "fw", "er", "out", "fd", "fr", "p", "exp", "a", "fp", "h", "ct", "fm", "log", "lf", "form"], "b": ["wb", "nb", "ob", "gb", "y", "w", "t", "m", "base", "bb", "n", "l", "bf", "c", "bi", "fb", "ab", "db", "k", "r", "bd", "bp", "br", "batch", "bh", "bc", "by", "be", "back", "bin", "j", "bs", "lb", "bl", "v", "ib", "sb", "ba", "mb", "cb", "bis", "eb", "p", "bg", "a", "rb", "bar"], "x": ["s", "mx", "php", "ax", "y", "xs", "w", "xt", "t", "xe", "xd", "on", "xml", "yx", "xi", "xp", "n", "l", "ix", "index", "xa", "qu", "fx", "c", "z", "xy", "e", "xes", "px", "xf", "ross", "xx", "dx", "wx", "v", "xxxx", "ox", "ex", "inx", "val", "p", "ux", "tx", "ci", "ct", "xc", "rx"], "d": ["s", "de", "ld", "did", "dep", "div", "dr", "ds", "do", "dec", "w", "sd", "t", "ed", "m", "g", "days", "dir", "des", "n", "done", "l", "rd", "c", "dim", "z", "dL", "D", "db", "da", "e", "dl", "r", "bd", "o", "red", "td", "dict", "dx", "v", "md", "dh", "er", "di", "dt", "p", "a", "ad", "dy", "dd", "dat"], "R": ["V", "RS", "G", "P", "W", "RE", "Multiple", "J", "Range", "RG", "N", "M", "Right", "O", "B", "MR", "RF", "Rs", "D", "Length", "H", "r", "K", "RA", "RM", "I", "RO", "S", "NR", "RR", "Size", "L", "Res", "Q", "Rat"], "reader": ["builder", "then", "master", "ner", "creator", "test", "owner", "runner", "function", "interface", "ser", "callback", "reading", "definition", "Reader", "adder", "handler", "inner", "holder", "rator", "actor", "parser", "source", "editor", "older", "style", "mr", "er", "worker", "read", "wrapper", "lr", "writer", "method", "loader", "driver", "finder", "dd", "func"], "i": ["ori", "ti", "int", "ini", "ic", "y", "u", "w", "ind", "pi", "li", "m", "t", "g", "xi", "multi", "it", "n", "ix", "index", "l", "c", "bi", "z", "e", "zi", "hi", "ij", "iu", "id", "r", "ir", "ai", "phi", "im", "o", "ri", "I", "si", "j", "mi", "ui", "info", "fi", "qi", "v", "di", "gi", "ip", "ii", "ci", "p", "a", "io"], "solver": ["Sol", "solve", "sorter", "unsolve", "Solver", "asorter", "Sorter", "esolver", "asolver", "Solve", "Solution", "asolution", "esolve", "solution", "sol", "unsolver", "esol", "asol", "esolution", "asolve", "unsorter", "unsol"], "fn": ["nm", "file", "tn", "conn", "cf", "dn", "sync", "n", "mn", "sf", "bf", "txt", "fs", "function", "ns", "fl", "nn", "fc", "fa", "format", "path", "bin", "bh", "phy", "fun", "na", "fi", "sn", "ff", "hn", "filename", "FN", "out", "ln", "conv", "fd", "fr", "cn", "fp", "fm", "lf", "nc"], "out_fn": ["out_n", " out_fp", "out_file", "outnfn", "out_fo", " out_n", " out_ln", " out_fc", "out_fp", "out_path", "outlockln", "outlockfo", "out_ln", "out_cn", " out_filename", "out_fc", "outlockfn", " out_fo", "outlogfile", "out_filename", "outlogcn", "outlogfn", " out_path", " out_file", "outlogln", "outnpath", "outnfm", "outnn", " out_fm", " out_cn", "out_fm", "outlockfp"], "in_fn": ["in67filename", "in67fn", "in_ln", "in_fl", "in_nn", " in2out", " in2win", "in2fn", " in_out", "inbaseout", "in___nn", " in_fl", "in_out", "in67win", "inbasefn", "in___fn", " in2filename", "in___fl", "in_win", "in___ln", " in_win", " in_filename", " in_ln", "in2out", "in2win", "in67out", "inbasewin", "in2filename", " in_nn", "inbasefilename", "in_filename", " in2fn"], "T": ["V", "G", "W", "P", "J", "TN", "t", "Y", "Total", "N", "M", "O", "B", "TA", "D", "TT", "H", "TY", "I", "E", "TS", "S", "WT", "NT", "L", "Q", "TR", "TM", "Z", "TC"], "case": ["rial", "then", "result", "cp", "core", "hyp", "ch", "cf", "pe", "zip", "pair", "li", "cases", "base", "condition", "profile", "cer", "cl", "switch", "c", "test", "fe", "set", "co", "block", "rule", "se", "ce", "cond", "space", "sc", "line", "info", "che", "frame", "chain", "fi", "ide", "ase", "trial", "wrapper", "use", "ice", "ca", "cas", "sim", "lic", "me", "ced", "ci", "p", "ace", "cd", "Case"], "res": ["cs", "rest", "then", "int", "result", "os", "ber", " Res", "ms", "prime", "req", "yes", "vec", "we", "resource", "nr", "us", "cons", "rand", "init", "c", "rs", "rent", "rx", "re", "resp", "r", "q", "reset", "pres", "mem", "rem", "zero", "ps", "red", "ri", "ress", "results", "cond", "j", "rh", "raw", "rel", "ret", "chain", "rss", "reg", "str", "out", "Res", "success", "RES", "sol", "sim", "right", "max", "rez", "val", "resolution", "err", "pos", "rev", "ins", "tx"], "C": ["V", "CS", "G", "W", "P", "CI", "CNN", "CC", "CO", "Cod", "Y", "N", "M", "B", "c", "CM", "D", "CF", "CB", "Ch", "H", "JC", "CT", "DC", "CD", "I", "CP", "CA", "S", "L", "CR", "CON", "Co"], "F": ["V", "G", "Feature", "W", "P", "J", "Fact", "FW", "GF", "Fixed", "FS", "Function", "FER", "Y", "Fs", "Frame", "N", "M", "FC", "Def", "FB", "FI", "B", "TF", "D", "CF", "FL", "FD", "H", "DF", "UF", "I", "Full", "E", "FO", "S", "FG", "Field", "L", "Q", "Fin", "PF", "FF", "Family", "If", "FE"], "X": ["V", "Tx", "W", "P", "RE", "XXX", "J", "TX", "CO", "Y", "XM", "N", "FC", "CL", "EX", "B", "D", "HTTP", "XL", "H", "IX", "XX", "Cross", "DX", "I", "E", "S", "L", "U", "ICE", "UX", "XP", "Q", "XT", "Z", "FF", "FE"], "DEBUG": ["BUG", "FIX", "G", "RE", "graded", " debug", "comments", "details", "pi", "g", "errors", "D", "iter", "BL", " debugging", "progress", "Debug", "DEF", "E", "info", "chain", "ED", "pretty", "print", "INFO", "debug", "trace", "display"]}}
{"code": "\\n  def read_word(f):\\n      return next(f).strip()\\n  \\n  def read_int(f, b=10):\\n      return int(read_word(f), b)\\n  \\n  def read_letters(f):\\n      return list(read_word(f))\\n  \\n  def read_digits(f, b=10):\\n      return [int(x, b) for x in read_letters(f)]\\n  \\n  def read_words(f, d=' '):\\n      return read_word(f).split(d)\\n  \\n  def read_ints(f, b=10, d=' '):\\n      return [int(x, b) for x in read_words(f, d)]\\n  \\n  def read_floats(f, d=' '):\\n      return [float(x) for x in read_words(f, d)]\\n  \\n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\\n      return [reader(f, *args, **kwargs) for i in range(R)]\\n  \\n  def solve(solver, fn, out_fn=None):\\n      in_fn = fn + '.in'\\n      if out_fn is None:\\n          out_fn = fn + '.out'\\n      with open(in_fn, 'r') as fi:\\n          with open(out_fn, 'w') as fo:\\n              T = read_int(fi)\\n              for i in range(T):\\n                  case = read_case(fi)\\n                  res = solver(case)\\n                  write_case(fo, i, res)\\n  \\n  \\n  def read_case(f):\\n      return read_ints(f)\\n  \\n  def write_case(f, i, res):\\n      f.write('Case #%d: '%i)\\n      if isinstance(res, list):\\n          res[0][0] = 'c'\\n          res = '\\n'.join(''.join(c for c in r) for r in res)\\n      f.write('\\n%s'%res)\\n      f.write('\\n')\\n  \\n  \\n  def solve_small(case):\\n      (R, C, M) = case\\n      if R == 1:\\n          return 'c' + '.'*(C-M-1) + '*'*M\\n      if C == 1:\\n          return '\\n'.join(['c'] + ['.']*(R-M-1) + ['*']*M)\\n      m = R*C - M\\n      res = [['*']*C for r in range(R)]\\n      if m == 1:\\n          return res\\n      for r in range(2, R+1):\\n          c = m // r\\n          z = m % r\\n          if c < 2 or c + (z>0) > C:\\n              continue\\n          if z == 1 and (r < 3 or c < 3):\\n              continue\\n          for x in range(r):\\n              for y in range(c):\\n                  res[x][y] = '.'\\n          for y in range(z):\\n              res[y][c] = '.'\\n          if z == 1:\\n              res[z][c] = '.'\\n              res[r-1][c-1] = '*'\\n          return res\\n      return 'Impossible'\\n  \\n  def solve_large(case):\\n      return solve_small(case)\\n  \\n  DEBUG = 'f'\\n  \\n", "target": "21", "substitutes": {"f": ["inf", "conf", "ed", "u", "t", "g", "it", "l", "sf", "ut", "full", "fe", "q", "fc", "fa", "uf", "j", "rf", "alf", "v", "ct", "a", "fp", "log", "w", "fac", "far", "e", "fer", "ret", "F", "out", "p", "exp", "h", "lf", "form", "fx", "bf", "fb", "fl", "fab", "orig", "fo", "o", "fg", "xf", "fd", "fr", "fed", "af", "file", "cf", "ft", "test", "fs", "tf", "um", "hl", "fi", "ff", "fw", "er", "fm"], "b": ["wb", "nb", "ob", "gb", "w", "t", "g", "base", "bb", "n", "l", "bf", "bi", "fb", "ab", "db", "k", "xb", "bd", "bp", "br", "bh", "bc", "bin", "be", "back", "by", "bs", "lb", "v", "ib", "sb", "ba", "mb", "cb", "bis", "eb", "bg", "a", "rb", "bar"], "x": ["mx", "int", "php", "ax", "xs", "w", "xt", "t", "xe", "on", "yx", "xi", "xp", "l", "ix", "index", "xa", "qu", "key", "xy", "e", "k", "xb", "xes", "px", "ey", "xf", "X", "ross", "xx", "dx", "wx", "v", "xxxx", "ox", "ex", "inx", "val", "p", "ux", "tx", "ci", "ct", "xc", "rx"], "d": ["s", "de", "ld", "did", "dep", "div", "dr", "ds", "do", "dec", "w", "sd", "t", "ed", "g", "days", "dir", "des", "n", "done", "l", "rd", "dim", "dL", "D", "db", "da", "e", "bd", "o", "red", "td", "dict", "dom", "dx", "v", "md", "dh", "er", "di", "debug", "dt", "p", "a", "ad", "dra", "dy", "dd", "dat"], "R": ["V", "RS", "G", "P", "W", "RE", "Multiple", "OR", "RB", "Range", "Y", "RG", "Max", "N", "Right", "O", "B", "MR", "RF", "Rs", "GR", "D", "RL", "H", "K", "RA", "BR", "SR", "RC", "RM", "A", "RT", "I", "RO", "X", "E", "S", "NR", "RR", "DR", "Size", "L", "F", "CR", "Res", "Q", "Rat", "AR", "RP"], "reader": ["builder", "master", "ner", "feature", "handle", "using", "creator", "rd", "test", "owner", "runner", "function", "interface", "ser", "callback", "reading", "definition", "Reader", "adder", "handler", "inner", "holder", "rator", "actor", "parser", "source", "editor", "style", "role", "er", "worker", "read", "wrapper", "writer", "method", "loader", "driver", "finder", "dd", "func"], "i": ["ti", "int", "ini", "ic", "w", "ind", "pi", "li", "t", "ie", "xi", "n", "it", "ix", "l", "index", "bi", "e", "k", "zi", "id", "iu", "ij", "ir", "ai", "phi", "im", "o", "ri", "I", "si", "j", "mi", "fi", "v", "di", "gi", "ip", "ii", "ci", "p", "io", "oi"], "solver": [" solve", "Sol", "solve", " solution", "esolutions", "Solutions", " solutions", "Solver", "solutions", "resol", "esolver", "asolver", "resolve", "Solve", "asolution", "Solution", "esolve", "solution", "resolver", "sol", "asol", "esolution", "resolution", "asolve"], "fn": ["nm", "file", "conn", "cf", "dn", "fil", "n", "sf", "bf", "txt", "function", "ns", "fl", "dl", "nn", "fc", "fa", "format", "path", "bin", "bh", "phy", "fun", "na", "fi", "sn", "ff", "hn", "filename", "FN", "out", "ln", "conv", "fd", "fr", "cn", "fp", "fm", "lf", "nc", "func"], "out_fn": ["outffp", " out_fp", "outoutfn", "out_file", "outoutfile", "outorfn", " out_ln", "out_fp", "out_path", "outoutln", "out_ln", "out_con", " out_filename", "outfcos", "out_cos", " out_con", "out_filename", "outorfm", "outorfilename", " out_path", " out_file", "outoutcon", " out_fm", "outorpath", "outfln", "outffn", "out_fm", " out_cos"], "in_fn": ["in_path", "in2fo", "in2fd", " in_path", "in67fn", "in67path", " in2fo", " in_fo", "in_ln", "in_fd", "in_fo", "in2fn", " in_dn", "inbasefo", "in_fil", "inbasefn", " in_fd", "inbasefd", " in2path", "in67fd", " in_ln", " in_fil", "inbasepath", "in67fo", " in2fd", "in_dn", "in2path", " in2fn"], "T": ["V", "G", "W", "P", "Tab", "J", "TN", "t", "Y", "N", "O", "B", "TA", "D", "TT", "TY", "H", "K", "I", "X", "E", "TS", "S", "NT", "L", "F", "Tu", "Q", "TR", "TM", "Z"], "case": ["rial", "then", "result", "cp", "ch", "cf", "pe", "zip", "pair", "st", "li", "cases", "base", "condition", "profile", "cl", "switch", "test", "name", "set", "co", "block", "rule", "cho", "se", "ce", "sc", "line", "info", "che", "fi", "chain", "cor", "ase", "use", "trial", "ice", "cas", "me", "type", "ci", "p", "ace", "ct", "ion", "instance", "Case"], "res": ["cs", "rest", "os", "then", "result", "s", "ber", "sys", " Res", "ms", "req", "inv", "cases", "yes", "des", "us", "cl", "cons", "respons", "rand", "lines", "rs", "re", "resp", "ser", "response", "resources", "q", "reset", "pres", "mem", "rem", "ps", "obj", "vre", "results", "rc", "rh", "bs", "ret", "chain", "mr", "reg", "ts", "rep", "str", "out", "Res", "success", "RES", "sol", "vals", "val", "rez", "ins", "err", "resolution", "rev", "ress", "tx"], "c": ["cs", "cr", "cp", "tc", "ch", "u", "ic", "w", "t", "g", "n", "ac", "con", "co", "lc", "cur", "unc", "rec", "rc", "sc", "v", "cu", "pc", "cm", "p", "ct", "ci", "cd", "h", "xc", "cc"], "r": ["rr", "rt", "t", "err", "n", "l", "rd", "rm", "e", "rs", "re", "ir", "q", "co", "ro", "ra", "ar", "ri", "pr", "rec", "rc", "j", "mr", "ry", "er", "right", "p", "rar", "h", "rx"], "C": ["V", "RS", "CS", "G", "W", "P", "RE", "CNN", "COR", "CC", "CO", "Y", "N", "O", "B", "CM", "D", "Cs", "H", "K", "CT", "RM", "CU", "A", "I", "X", "E", "CP", "S", "L", "F", "U", "CR", "AR", "Co"], "M": ["V", "G", "MAN", "W", "P", "MT", "J", "Y", "N", "O", "Mc", "MC", "B", "CM", "MR", "MN", "D", "H", "MP", "K", "MI", "RM", "I", "X", "E", "S", "L", "F", "PM", "U", "Q", "TM", "MS", "MX", "MM"]}}
{"code": "\\n  \\n  TEST_CASES = [\\n      (\"\"\"4\\n  30.0 1.0 2.0\\n  30.0 2.0 100.0\\n  30.50000 3.14159 1999.19990\\n  500.0 4.0 2000.0\\n  \"\"\",\"\"\"Case #1: 1.0000000\\n  Case #2: 39.1666667\\n  Case #3: 63.9680013\\n  Case #4: 526.1904762\\n  \"\"\")\\n  ]\\n  \\n  \"\"\"\\n  Z is number of farms held\\n  tF(Z) is time to build a farm = C / (2+(F*Z))\\n  tX(Z) is time to win = X / (2+(F*Z))\\n  No point incresing Z when tX(Z) < (tX(Z+1) + tF(Z)\\n      == X / (2+(F*Z)) < (X / (2+(F*(Z+1))) + (C / (2+(F*Z)))\\n      == (X - C) / (2+(F*Z)) < X / (2+(F*(Z+1)))\\n      == (X - C) * (2+(F*Z)+F) < X * (2+(F*Z))\\n      == 2X - 2C + XFZ - CFZ + XF - CF < 2X + XFZ\\n      == XF - CF - 2C < CFZ\\n      == (XF - CF - 2C) / CF < Z\\n  \"\"\"\\n  \\n  def parse_input(input_reader):\\n      case_count = int(input_reader.readline())\\n      case_idx = 0\\n      while case_count > case_idx:\\n          case_idx += 1\\n          input_line = input_reader.readline().rstrip(\"\\n\").split(\" \")\\n          input_values = {\"C\": float(input_line[0]),\\n                          \"F\": float(input_line[1]),\\n                          \"X\": float(input_line[2]),\\n                          \"case\": case_idx}\\n          yield input_values\\n  \\n  def solve_problem(output_writer=sys.stdout, **kwargs):\\n      case = kwargs['case']\\n      C_val = kwargs['C']\\n      F_val = kwargs['F']\\n      X_val = kwargs['X']\\n  \\n      best_Z = ((X_val * F_val) - (C_val * F_val) - (2 * C_val)) / (C_val * F_val)\\n      best_Z = int(ceil(best_Z))\\n      if best_Z < 0:\\n          best_Z = 0\\n  \\n      tX = lambda z: (X_val / (2+(F_val * z)))\\n      tF = lambda z: (C_val / (2+(F_val * z)))\\n  \\n      total_time = reduce(lambda x,y: x + tF(y), range(best_Z), tX(best_Z))\\n      print >> output_writer, \"Case #%d: %.7f\" % (case, total_time)\\n  \\n  def solve_inputs(input_reader, output_writer):\\n      \"\"\"\\n      Loop through each problem input in input reader and solve it.\\n  \\n      Outputs responses to output_writer.\\n      \"\"\"\\n      for input_values in parse_input(input_reader):\\n          solve_problem(output_writer=output_writer, **input_values)\\n  \\n  def run_tests():\\n      idx = 0\\n      all_pass = True\\n      for problem_input, expected_output in TEST_CASES:\\n          idx += 1\\n          input_reader = StringIO(problem_input)\\n          output_writer = StringIO()\\n          solve_inputs(input_reader, output_writer)\\n          problem_output = output_writer.getvalue()\\n          if problem_output == expected_output:\\n              print \"Test %d: Success\" % idx\\n          else:\\n              all_pass = False\\n              print \"Test %d: Failure\" % idx\\n          input_reader.close()\\n          output_writer.close()\\n      if all_pass:\\n          print \"All tests were successful!\"\\n      else:\\n          print \"Something didn't match - try again.\"\\n  \\n  def main():\\n      parser = OptionParser()\\n      parser.add_option(\"-f\", \"--file\",\\n                        dest=\"filename_stem\",\\n                        help=\"read input from FILE.in and write to FILE.out\",\\n                        metavar=\"FILE\")\\n  \\n      (options, args) = parser.parse_args()\\n      if options.filename_stem:\\n          print \"Running in file mode.\"\\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\\n          solve_inputs(input_reader, output_writer)\\n      else:\\n          print \"Running in test mode.\"\\n          run_tests()\\n  \\n  if __name__ == \"__main__\":\\n      main()\\n", "target": "22", "substitutes": {"TEST_CASES": ["TEST_CASSes", "TEST_CATCHAS", "TEST_CASSAS", "TEST_CASSERS", "TEST_CACHERS", "TEST_CACHes", "TEST_CATCHES", "TEST_CASes", "TEST_CASAS", "TEST_CACHES", "TEST_CATCHERS", "TEST_CASSES", "TEST_CACHAS", "TEST_CASERS", "TEST_CATCHes"], "input_reader": ["input3loader", "output_file", "input7reader", "input_source", "input_file", "input5writer", "input_writer", "output_inner", "input5source", "output_loader", "input3source", "input_inner", "inputmatwriter", "input7inner", "output_reader", "inputmatiter", "input8reader", "input3reader", "input_loader", "input_row", "input7row", "input5loader", "input7writer", "input8row", "input8writer", "input_iter", "input5reader", "inputmatreader", "input3writer", "output_source", "output_row", "output_iter", "inputmatfile", "input8inner"], "case_count": ["Case_count", "Case_parts", "case00number", "case00count", "case00length", "case00nb", "group_count", "group_length", "case_parts", "group00length", "caseElength", "caseEparts", "group_number", "group00count", "case_number", "case_length", "Case_length", "group_nb", "group00nb", "caseEcount", "group00number", "case_nb"], "case_idx": ["case_idj", "casexidindex", "case_IDx", "case_midox", "casexpartb", "case_idy", "casexpartox", "case_dirnum", "case_midx", "case_ridy", "case_Idxs", "case_idxs", "case_midv", "case_dirx", "case_Idj", "case_indexb", "casexidb", "case_indexox", "casexpartindex", "case_ridxs", "case_idox", "case_IDj", "case_Idnum", "case_partx", "case_idindex", "case_ridj", "case_IDy", "case_midindex", "casexidox", "case_idn", "casexpartx", "case_midnum", "case_midxs", "case_idv", "case_midb", "case_ridn", "case_idb", "case_Idindex", "case_Idx", "casexidx", "case_dirxs", "case_ridv", "case_idnum", "case_partox", "case_Idn", "case_partindex", "case_ridx", "case_midn", "case_indexx", "case_Idy", "case_indexindex", "case_dirindex", "case_partb", "case_IDn"], "input_line": [" input_liner", "input64liner", "inputicquery", "input64query", "input2rule", "attributemmline", "hiddenxport", "input_lines", "inputxentry", " input_field", "inputerliner", "inputicstream", "input5line", "inputmmuser", "attribute_stream", "input2entry", "input64line", "attribute_line", "inputptfield", "inputerlink", "inputxline", "input64link", "inputxport", "inputerquery", "input_liner", " input_lines", "input_stream", "file_liner", "input5user", "inputmmquery", "hiddenxrule", "input_user", "input5stream", "inputerrule", "input_query", "inputerport", "inputptlines", " inputptfield", "attributemmquery", "inputxrule", "hiddenxentry", "inputptline", " inputptliner", " inputptlines", "file_link", "input_rule", "input5query", "inputmmline", "attribute_query", "attribute_user", "hiddenxline", "input_field", "file_line", "attributemmstream", "hidden_rule", "inputmmstream", "inputerentry", "input_port", "input2line", "file_query", "attributemmuser", "inputerline", "inputmatfield", "inputmatlines", "inputicuser", "inputmatline", "input_link", "input_entry", "input2port", "hidden_line", " inputptline", "inputmatliner", "hidden_port", "hidden_entry", "inputicline", "inputptliner"], "input_values": ["Input_vals", "input_lines", "input2value", "Input_line", "input_value", "Input_lines", "input_vals", "Input_val", "Input_value", "input2values", "input_val", "input2lines", "input2val", "Input_values"], "output_writer": ["outputpubgroup", "input_group", "outputpubreader", "input_writer", "output_write", "output_reader", "outputpubwrite", "output_group", "outputpubwriter", "input_write"], "case": ["choice", "match", "catch", "pe", "mode", "pair", "cases", "condition", "switch", "Case", "set", "client", "CE", "co", "se", "ce", "cycle", "ASE", "chain", "ase", "force", "use", "ca", "cas", "error", "ace", "USE"], "C_val": ["C00role", "FT", "C___VAL", "C___serv", "C___val", "F_VAL", "F_role", "C___role", "CT", "C_VAL", " CT", "C_role", "CMT", "C00VAL", "F_serv", "C00val", "C00serv", "C_serv"], "F_val": ["P_val", "FStarVAL", " F_div", " FStaralpha", " F_VAL", "F___serv", " FStardiv", "F_alpha", "F_VAL", "FREunit", "F___alpha", "FREserv", "P_VAL", "F___VAL", "FREVAL", "P_serv", "F_div", "F___div", " F_alpha", " FStarVAL", "FStarval", "P_unit", "FStaralpha", "F_unit", "FStardiv", "F_serv", "F___unit", " FStarval", "F___val", "FREval"], "X_val": ["X64val", "P_val", "X2value", "X_loc", "P_value", "X_VAL", "X_value", "X2Val", "Y_loc", "Y_Val", "Y2Val", "X_pos", "Y2VAL", "P_VAL", "X2val", "X2VAL", "Y_VAL", "X_Val", "X64pos", "Y2loc", "Y2val", "X64VAL", "Y_val", "P_pos", "X2pos", "X64value", "X2loc"], "best_Z": ["new_z", "best_z", "bestEV", "bestEZ", "best_V", "best_zone", "new_V", "bestEz", "new_Z", "bestEzone", "new_zone"]}}
{"code": "\\n  \\n  TEST_CASES = [\\n      (\"\"\"5\\n  5 5 23\\n  3 1 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  \"\"\",\"\"\"Case #1:\\n  Impossible\\n  Case #2:\\n  c\\n  .\\n  *\\n  Case #3:\\n  Impossible\\n  Case #4:\\n  c......\\n  .......\\n  .......\\n  ....***\\n  Case #5:\\n  c........*\\n  .........*\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  \"\"\"),\\n      (\"\"\"3\\n  5 4 3\\n  5 3 8\\n  5 5 14\\n  \"\"\",\"\"\"Case #1:\\n  c...\\n  ....\\n  ....\\n  ...*\\n  ..**\\n  Case #2:\\n  Impossible\\n  Case #3:\\n  c...*\\n  ....*\\n  ...**\\n  *****\\n  *****\\n  \"\"\")\\n  ]\\n  \\n  IMPOSSIBLE = \"Impossible\"\\n  \\n  \"\"\"\\n  S is number of safe squares = (R*C) - M\\n  If S == 1 then always possible:\\n      Assume click in top left, all else mines\\n  Special cases (R or C is small):\\n  If R == 1 or C == 1 then always possible:\\n      Assume click in top left and all safe squares in a line\\n  Else if R == 2 or C == 2 then possible iff S % 2 == 0:\\n      Assume click in top left and all safe squares are in a 2 * X line\\n  Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)\\n     OR if S % 2 == 0 \\n  \"\"\"\\n  \\n  def parse_input(input_reader):\\n      case_count = int(input_reader.readline())\\n      case_idx = 0\\n      while case_count > case_idx:\\n          case_idx += 1\\n          input_line = [int(x) for x in input_reader.readline().split()]\\n          input_values = {\"case\": case_idx,\\n                          \"R\": input_line[0],\\n                          \"C\": input_line[1],\\n                          \"M\": input_line[2]}\\n          yield input_values\\n  \\n  \\n  def solve_problem(output_writer=sys.stdout, **kwargs):\\n      case = kwargs['case']\\n      rows = kwargs['R']\\n      cols = kwargs['C']\\n      mines = kwargs['M']\\n      safe_squares = ((rows * cols) - mines)\\n      print >> output_writer, \"Case #%d:\" % case\\n      row_string = \"{:*<%ds}\" % cols\\n      impossible = False\\n      if safe_squares == 1:\\n          print >> output_writer, row_string.format(\"c\")\\n          for row in range(1, rows):\\n              print >> output_writer, row_string.format(\"\")\\n      elif rows == 1:\\n          safe_string = \"c\" + (\".\" * (safe_squares - 1))\\n          print >> output_writer, row_string.format(safe_string)\\n      elif cols == 1:\\n          for row in range(rows):\\n              cell = \"\"\\n              if row == 0:\\n                  cell = \"c\"\\n              elif row < safe_squares:\\n                  cell = \".\"\\n              print >> output_writer, row_string.format(cell)\\n      elif safe_squares == 2:\\n          impossible = True\\n      elif rows == 2:\\n          safe_cols, remainder = divmod(safe_squares, 2)\\n          if remainder == 1:\\n              impossible = True\\n          else:\\n              safe_string = \".\" * (safe_cols - 1)\\n              print >> output_writer, row_string.format(\"c%s\" % safe_string)\\n              print >> output_writer, row_string.format(\".%s\" % safe_string)\\n      elif cols == 2:\\n          safe_rows, remainder = divmod(safe_squares, 2)\\n          if remainder == 1:\\n              impossible = True\\n          else:\\n              for row in range(rows):\\n                  cells = \"\"\\n                  if row == 0:\\n                      cells = \"c.\"\\n                  elif row < safe_rows:\\n                      cells = \"..\"\\n                  print >> output_writer, row_string.format(cells)\\n      else:\\n          safe_rows, remainder = divmod(safe_squares, cols)\\n          if remainder == 1 and cols == 3 and safe_rows == 2:\\n              impossible = True\\n          elif safe_rows > 1:\\n              if remainder == 1 and safe_rows == 2:\\n                  mid_safe = \".\" * (cols-2)\\n                  for row in range(rows):\\n                      cell_one = \".\"\\n                      mid_cells = mid_safe\\n                      last_cell = \".\"\\n                      if row == 0:\\n                          cell_one = \"c\"\\n                      elif safe_rows == 0:\\n                          cell_one = \".\"\\n                          mid_cells = \".\" * (remainder + 1)\\n                      elif safe_rows < 0:\\n                          cell_one = \"\"\\n                          mid_cells = \"\"\\n                      if safe_rows < 3:\\n                          last_cell = \"\"\\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\\n                      safe_rows -= 1\\n              elif remainder == 1:\\n                  mid_safe = \".\" * (cols-2)\\n                  for row in range(rows):\\n                      cell_one = \".\"\\n                      mid_cells = mid_safe\\n                      last_cell = \".\"\\n                      if row == 0:\\n                          cell_one = \"c\"\\n                      elif safe_rows == 0:\\n                          cell_one = \".\"\\n                          mid_cells = \".\" * remainder\\n                      elif safe_rows < 0:\\n                          cell_one = \"\"\\n                          mid_cells = \"\"\\n                      if safe_rows < 2:\\n                          last_cell = \"\"\\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\\n                      safe_rows -= 1\\n              else:\\n                  full_safe = \".\" * cols\\n                  for row in range(rows):\\n                      cells = full_safe\\n                      if row == 0:\\n                          cells = \"c\" + (\".\" * (cols - 1))\\n                      elif row == safe_rows:\\n                          cells = \".\" * remainder\\n                      elif row > safe_rows:\\n                          cells = \"\"\\n                      print >> output_writer, row_string.format(cells)\\n          else:\\n              safe_cols, remainder = divmod(safe_squares, 2)\\n              if remainder == 1 and safe_cols < 4:\\n                  impossible = True\\n              elif remainder == 0:\\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\\n                  for row in range(2, rows):\\n                      print >> output_writer, row_string.format(\"\")\\n              else:\\n                  safe_cols -= 1\\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\\n                  print >> output_writer, row_string.format(\"...\")\\n                  for row in range(3, rows):\\n                      print >> output_writer, row_string.format(\"\")\\n      if impossible:\\n          print >> output_writer, IMPOSSIBLE\\n  \\n  def solve_inputs(input_reader, output_writer):\\n      \"\"\"\\n      Loop through each problem input in input reader and solve it.\\n  \\n      Outputs responses to output_writer.\\n      \"\"\"\\n      for input_values in parse_input(input_reader):\\n          solve_problem(output_writer=output_writer, **input_values)\\n  \\n  def run_tests():\\n      idx = 0\\n      all_pass = True\\n      for problem_input, expected_output in TEST_CASES:\\n          idx += 1\\n          input_reader = StringIO(problem_input)\\n          output_writer = StringIO()\\n          solve_inputs(input_reader, output_writer)\\n          problem_output = output_writer.getvalue()\\n          if problem_output == expected_output:\\n              print \"Test %d: Success\" % idx\\n          else:\\n              all_pass = False\\n              print \"Test %d: Failure\" % idx\\n              print problem_output\\n          input_reader.close()\\n          output_writer.close()\\n      if all_pass:\\n          print \"All tests were successful!\"\\n      else:\\n          print \"Something didn't match - try again.\"\\n  \\n  def main():\\n      parser = OptionParser()\\n      parser.add_option(\"-f\", \"--file\",\\n                        dest=\"filename_stem\",\\n                        help=\"read input from FILE.in and write to FILE.out\",\\n                        metavar=\"FILE\")\\n  \\n      (options, args) = parser.parse_args()\\n      if options.filename_stem:\\n          print \"Running in file mode.\"\\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\\n          solve_inputs(input_reader, output_writer)\\n      else:\\n          print \"Running in test mode.\"\\n          run_tests()\\n  \\n  if __name__ == \"__main__\":\\n      main()\\n", "target": "22", "substitutes": {"TEST_CASES": ["TEST_CATCHIONS", "TEST_cASED", "TEST_cATCHES", "TEST_cATCHes", "TEST_cATCHED", "TEST_cASIONS", "TEST_CATCHED", "TEST_CASEes", "TEST_CATCHES", "TEST_CASes", "TEST_CODes", "TEST_CODIONS", "TEST_CASEES", "TEST_cATCHIONS", "TEST_cASES", "TEST_CODED", "TEST_CASEED", "TEST_CASED", "TEST_CODES", "TEST_cASes", "TEST_CASIONS", "TEST_CATCHes", "TEST_CASEIONS"], "IMPOSSIBLE": ["IMPossible", "IMPPOSSIBLE", "IMPONSible", "IMPOSSible", "IMPOSibles", "IMPOSSIVE", "IMPOSible", "IMPPONSIVE", "IMPOSIBLE", "IMPONSIBLE", "IMPPOSSibles", "IMPONSibles", "IMPossibles", "IMPOSSibles", "IMPossIBLE", "IMPossIVE", "IMPPONSibles", "IMPONSIVE", "IMPOSIVE", "IMPPONSible", "IMPPOSSible", "IMPPONSIBLE", "IMPPOSSIVE"], "input_reader": [" input_stream", " input2reader", "input1liner", "output_file", "input2stream", "input_file", " input_liner", "input2reader", "inputfilefile", "input_writer", "output_loader", "inputfilewriter", "inputmatwriter", "input2liner", " input2stream", "output_reader", " input2liner", "input1writer", " input_writer", "input_loader", "input1reader", "input1stream", "inputmatline", "inputfilereader", "input_liner", "input_stream", "inputmatloader", "inputfileloader", "input2writer", "inputmatreader", " input2writer", "output_line"], "case_count": ["case1length", "Case_count", "Case_number", "case1number", " case_code", " case_base", "case_base", " case_number", "case_code", "case1count", "case_number", "case_length", "Case_length"], "case_idx": ["case_idw", "case_Idn", "case_indxs", "case_index", "case_idn", "case_ideb", "case_endw", "case_idsxs", "case_idexs", "case_ideex", "case_endx", "case_ridx", "case_idsv", "case_Idex", "case_endn", "case_ridb", "case_idv", "case_endex", "case_ridxs", "case_ridn", "case_indb", "case_idb", "case_ridex", "case_Idx", "case_Idv", "case_indv", "case_idex", "case_Idxs", "case_indx", "case_indn", "case_idxs", "case_idsn", "case_Idw", "case_idsx"], "input_line": ["request_lines", "input12liner", "input12look", "request_look", "output_lines", "input_lines", " input_look", "input5line", "output_entry", "input5look", "input_word", "input_Line", " input_word", "inputsword", "input12lines", "input_look", "input5Line", "request_liner", "input_liner", " input_lines", "request_line", "input_value", "inputsline", "inputslines", " input_Line", "input12line", "input_entry", "output_value", "output_line"], "x": ["mx", "xxx", "ax", "y", "xs", "xt", "t", "xe", "xd", "xi", "xp", "ix", "xa", "fx", "z", "xy", "rx", " xx", "xes", "px", "ey", "xf", "X", "xx", "dx", "wx", "v", "xxxx", "ox", " ax", "ex", "nex", "ick", "ux", "p", "xc", "i", "tx"], "input_values": ["output_values", "output_lines", "input_lines", "input_value", "output_vals", "input_vals", "output_value"], "output_writer": ["output___writing", "output_wrapper", "output2writing", "output___wrapper", "input_writer", "output2write", "output2writer", "output_write", "output_reader", "output___reader", "output2reader", "input_writing", "output___writer", "output_buffer", "input_write", "output_writing", "input_buffer", "input_wrapper", "output2buffer", "output2wrapper"], "case": ["choice", "match", "power", "patch", "zip", "pair", "cases", "condition", "switch", "set", "connection", "client", "example", "The", "block", "rule", "path", "ce", "E", "chain", "ase", "force", "use", "ice", "cas", "position", "error", "ace", "section", "Case"], "rows": ["cs", "times", "blocks", "ows", "ries", "chains", "xs", "mins", "cases", "jobs", "views", "ros", "roots", "runs", "lines", "rs", "obs", "r", "groups", "states", "posts", "words", "checks", "heads", "dates", "OWS", "orders", "users", "frames", "tests", "rown", "values", "pages", "boxes", "maps"], "cols": ["columnats", "COLes", "Coles", "columnts", " coles", "columnes", " colts", "colats", " colats", " colgs", "Colins", "COLts", "colins", "coles", "colgs", "colts", "columngs", "COLs", "Colats", "COLgs", "columnins", " colins", "columns", "Cols"], "mines": ["minies", "menies", "Minions", "minutes", "passeds", "MINions", "indexutes", "indexeds", "passes", "amines", "passses", "mineds", "MINes", "minions", "aminses", "minovers", "MINoes", " minies", " minovers", "Minovers", "passutes", " minese", "Minoes", " minoes", "indexses", "menses", "aminutes", "menese", "minese", "indexes", "sixes", " minses", "sixies", " minions", "minoes", "amineds", "minses", "menes", "MINovers", "sixses", "Mines", "sixese"], "safe_squares": ["safenessshares", "safe_quares", "safenessshales", "safe_shared", "safenesssquales", "safenessshared", "safe_squared", "safe_shars", "safe_quared", "safe_shares", "safe_quars", "safenesssquars", "safenessshars", "safenesssquared", "safe_squales", "safe_shales", "safenesssquares", "safe_squars", "safe_quales"]}}
{"code": "\\n  \\n  N = int(sys.stdin.readline())\\n  \\n  for T in range(1, N+1):\\n      C, F, X = map(float, sys.stdin.readline().split(' '))\\n  \\n      N = 0\\n      for i in range(int(X)):\\n          diff = (2 + F * i) * C - F * X\\n          if diff >= 0: break\\n          N = i\\n  \\n      total = 0\\n      for i in range(N):\\n          val = C / (2 + i * F)\\n          total += val\\n      val = X / (2.0 + N * F)\\n      total += val\\n          \\n      ans = '%s' % (total)\\n      print 'Case #%(T)s: %(ans)s' % locals()\\n", "target": "23", "substitutes": {"N": ["V", "Ns", "Number", "G", "P", "NB", "J", "CNN", "TN", "NH", "NA", "Y", "Total", "n", "M", "Ni", "O", "SN", " n", "B", "NUM", "NS", "D", "Num", "GN", "K", "NP", "A", "NN", "I", "R", "E", "NC", "NT", "S", "NR", "L", "No", "Q", "NM", "CN", "Z", "NO", "NI"], "T": ["V", "P", "J", "TN", "Y", "O", "M", "Num", "TT", "K", "A", "I", "R", "Is", "E", "S", " t", "L", "Ti", "TC"], "C": ["V", "CS", "G", "W", "P", "J", "CC", "CO", "Y", "M", "B", "c", "CM", "D", "CF", "YC", "Cs", "H", "K", "CE", "CT", "CU", "A", "I", "R", "E", "CP", "S", "L", "U", "CR", "CON", "Q", "Z", "TC", "Co"], "F": ["V", "G", "W", "P", "FT", "J", "FW", "GF", "Fs", "f", "FER", "Y", "AF", "M", "FC", "FI", "B", "TF", "D", "CF", "FL", "FD", "IF", "H", "K", "DF", "I", "R", "Fe", "E", "FO", "S", "FG", "L", "U", "Q", "SF", "Z", "FF", "FE"], "X": ["V", "W", "P", "J", "TX", "Y", "M", "Xi", "EX", "D", "XL", "H", "K", "IX", "XX", "A", "DX", "I", "R", "E", "S", "L", "x", "U", "UX", "XP", "Q", "XT", "Z", "ZX", "XXX", "Int"], "i": ["ti", "s", "int", "IC", "ini", "ic", "y", "ind", "pi", "f", "li", "t", "m", "g", "xi", "it", "n", "ix", "index", "l", "Ni", "Xi", "c", "il", "z", "II", "e", "k", "zi", "iter", "iu", "ij", "ai", "phi", "im", "I", "si", "j", "mi", "fi", "v", "x", "Ti", "ik", "gi", "di", "ii", "ip", "ci", "d", "p", "iti", "io"], "diff": ["inf", "patch", "div", "different", "missing", "dev", "fix", "erence", "sub", "iff", " difference", "adj", "mix", "dl", "change", "extra", "rel", "add", "dx", "split", "dirty", "dis", "dist", "cmp", "distance", "error", "delay", "changed", "d", "Delta", "Diff", "df", "dust"], "total": ["valid", "result", "value", "complete", "last", "to", "stats", "bo", "t", "f", "Total", "base", "n", "done", "test", "eta", "errors", "full", "meta", "local", "real", "table", "earned", "zero", "normal", "no", "number", "OTAL", "otal", "nt", "info", "NT", "count", "percent", "v", "net", "out", "quant", "num", "alpha", "mean", "sum", "p", "all", "final", "OT", "ot"], "val": ["valid", "VAL", "pal", "value", "int", "div", "cal", "ind", "AL", "al", "li", "dev", " valid", " aval", "qual", "it", "key", "Val", "fx", "test", " eval", "eval", " el", "rol", "mix", "vt", "pol", "el", "var", "ref", "aval", "cho", "pr", " Val", "rel", "elt", " v", "res", "sel", "v", "crit", "x", "prop", " VAL", "num", "alpha", "pl", "vals", "col", "ctx", "p", "sum", "err", "tx"], "ans": ["s", "ANS", "ms", "ds", "san", " Ans", "aus", "ents", "ies", "lines", "ks", "ns", "ls", "ats", "ses", "ands", "outs", "anks", "ts", "an", "An", "nan", "AN", "ants", "ann", "vals"]}}
{"code": "\\n  \\n  \\n  def show_board(board):\\n      for row in board:\\n          print ''.join(row)\\n  \\n  \\n  N = int(sys.stdin.readline())\\n  \\n  for T in range(1, N+1):\\n      (R, C, M) = map(int, sys.stdin.readline().split(' '))\\n      E = R*C-M # empty\\n      possible, reverse, need_adjust, column_base = (False, False, False, False)\\n      if C > R:\\n          (R, C) = (C, R)\\n          reverse = True\\n  \\n      W = 0\\n      lastRow = 0\\n      if E == 0:\\n          pass\\n      elif E == 1 or M == 0:\\n          W = C\\n          possible = True\\n      elif C == 1:\\n          W = 1\\n          if E > 0:\\n              possible = True\\n      elif C == 2:\\n          W = 2\\n          lastRow = int(E / 2) + 1   # 1 base\\n          if E % 2 == 0 and E >= 4:\\n              possible = True\\n      elif C >= 3:\\n          for w in range(2, C+1):\\n              lastRow = int(E / w) + 1   # 1 base\\n              if lastRow > R: continue\\n              lastRowNum = E % w\\n              \\n              if lastRow == 2 and lastRowNum == 0:\\n                  pass\\n              elif lastRow == 2:   # lastRow == 1 => impossible\\n                  if lastRowNum == 0:\\n                      W = w\\n                      possible = True\\n                      break\\n              elif lastRow >= 3:\\n                  if lastRowNum >= 2 or lastRowNum == 0:\\n                      W = w\\n                      possible = True\\n                      break\\n                  elif C >= 4 and lastRowNum == 1 and R >= 3:\\n                      W = w\\n                      possible = True\\n                      need_adjust = True\\n                      break\\n          if not possible:\\n              for w in range(2, R+1):\\n                  lastRow = int(E / w) + 1   # 1 base\\n                  if lastRow > R: continue\\n                  lastRowNum = E % w\\n                  if lastRow == 2 and lastRowNum == 0:\\n                      pass\\n                  elif lastRow == 2:   # lastRow == 1 => impossible\\n                      if lastRowNum == 0:\\n                          W = w\\n                          possible = True\\n                          column_base = True\\n                          break\\n                  elif lastRow >= 3:\\n                      if lastRowNum >= 2 or lastRowNum == 0:\\n                          W = w\\n                          possible = True\\n                          column_base = True\\n                          break\\n                      elif C >= 4 and lastRowNum == 1 and R >= 3:\\n                          W = w\\n                          possible = True\\n                          need_adjust = True\\n                          column_base = True\\n                          break\\n                                  \\n      if not possible:\\n          if reverse:\\n              R, C = (C, R)        \\n          ans = 'Impossible %sx%s M=%s' % (R, C, M)\\n          print 'Case #%(T)s: %(ans)s' % locals()\\n          continue\\n  \\n      board = [['*'] * C for i in range(R)]\\n      for i in range(E):\\n          if not column_base:\\n              c = i % W\\n              r = i / W\\n          else:\\n              r = i % W\\n              c = i / W            \\n          board[r][c] = '.'\\n      if need_adjust:\\n          board[lastRow-1][1], board[lastRow-2][-1] = board[lastRow-2][-1], board[lastRow-1][1]\\n      if reverse:\\n          board = map(list, zip(*board))\\n          R, C = (C, R)\\n  \\n      clicked = False\\n      for r in range(R):\\n          if clicked: break\\n          for c in range(C):\\n              cell = board[r][c]\\n              if cell != '.': continue\\n              if E == 1:\\n                  board[r][c] = 'c'\\n                  clicked = True\\n                  break\\n              \\n              if r >= 1  and c >= 1  and board[r-1][c-1] == '*': continue\\n              if r >= 1              and board[r-1][c]   == '*': continue\\n              if r >= 1  and c < C-1 and board[r-1][c+1] == '*': continue\\n              if             c >= 1  and board[r][c-1]   == '*': continue\\n              if             c < C-1 and board[r][c+1]   == '*': continue\\n              if r < R-1 and c >= 1  and board[r+1][c-1] == '*': continue\\n              if r < R-1             and board[r+1][c]   == '*': continue\\n              if r < R-1 and c < C-1 and board[r+1][c+1] == '*': continue\\n              board[r][c] = 'c'\\n              clicked = True\\n              break\\n  \\n      ans = 'Possible' if possible else 'Impossible'\\n      print 'Case #%(T)s:' % locals()\\n      show_board(board)\\n", "target": "23", "substitutes": {"board": ["ob", "comment", "Board", "bo", "lay", "boards", "word", "case", "pad", "cell", "game", "window", "full", "buffer", "body", "table", "bro", "past", "b", "ro", "fc", "oard", "ward", "back", "menu", "stream", "line", "frame", "course", "bit", "boarding", "list", "node", "paste", "array", "box", "lo", "form"], "row": [" star", "range", "ows", "to", " rc", "th", "word", " user", "rect", "cell", " f", " cur", "OW", " tr", "user", "table", "entry", " ro", "ro", "Row", "block", " cursor", "ward", " prow", "tty", " dow", " word", "line", "frame", " cell", " su", "prefix", " each", "star", "ow", "node", "roll", " instance", "col", "rows", "each", " Row", "post", "record", " re", " rows"], "N": ["V", "Ns", "NF", "P", "NB", "NA", "n", "O", "Ni", "SN", "NW", "B", "NUM", "NS", "D", "H", "NP", "NPR", "NN", "I", "ND", "NC", "S", "NT", "NR", "L", "NV", "NE", "Q", "NL", "NM", "NI", "Z", "NO"], "T": [" Y", " D", "Y", " Li", "O", " TD", " W", "K", " L", "IX", " P", "I", " U", " J", " X", " Q", " I", " each", " ki", " B", " w", " O", " K", " F", " S", " Z", " Xi"], "R": ["V", "RS", "G", "P", "RE", "W", "J", "Y", "RG", "Repl", "B", "GR", "D", "H", "RA", "K", "r", "RC", "SR", "RM", "A", "I", "RO", "X", "S", "RR", "L", "U", "F", "TR", " r", "AR", "HR"], "C": ["V", "CS", "Cond", "G", "P", "CNN", "Cow", "CC", "CO", "CG", "B", "CM", "c", "D", "YC", "Cs", "H", "K", "JC", "CE", "CT", "CU", "A", "CP", "CA", "S", "Cons", "L", "U", "F", "CR", "CON", "Co"], "M": ["V", "G", "MAN", "W", "P", "MT", "J", "m", "O", "MC", "B", "JM", "MN", "D", "H", "K", "Ms", "A", "I", "X", "S", "L", "F", "PM", "U", "Q", "MM", "Z"], "E": ["V", "G", "W", "P", "J", "EEE", "O", "ET", "B", "D", "e", "EF", "H", "EN", "I", "X", "EC", "S", "L", "ES", "F", "Q", "AE", "Z"]}}
{"code": "\\n  def calculate_time(c, f, x, num_farms):\\n  \tt = 0.0\\n  \trate = 2.0\\n  \tfor i in range(num_farms):\\n  \t\tt += c / rate\\n  \t\trate += f\\n  \t\t\\n  \tt += x / rate\\n  \treturn t\t\\n  \\n  t = int(sys.stdin.readline().strip())\\n  \\n  for i in range(t):\\n  \tprint \"Case #\" + str(i + 1) + \":\",\\n  \\n  \t(c, f, x) = [float(i) for i in sys.stdin.readline().strip().split()]\\n  \t\\n  \tif x <= c:\\n  \t\tt = calculate_time(c, f, x, 0)\\n  \telse:\\n  \t\topt_rate = f * (x - c) / c\\n  \t\tnum_farms = (opt_rate - 2) / f\\n  \t\tt1 = calculate_time(c, f, x, int(math.floor(num_farms)))\\n  \t\tt2 = calculate_time(c, f, x, int(math.ceil(num_farms)))\\n  \\n  \t\tt = min(t1, t2)\\n  \t\t\\n  \tprint \"%.7f\" % t\\n", "target": "24", "substitutes": {"c": ["cs", "s", "cr", "abc", "cp", "tc", "cal", "cont", "uc", "ch", "y", "u", "cf", "w", "g", "m", "etc", "cin", "n", "l", "com", "cl", "C", "ac", "z", "con", "mc", "e", "k", "r", "q", "dc", "lc", "co", "time", "b", "vc", "fc", "unc", "cur", "o", "cos", "ce", "rc", "cache", "course", "chain", "v", "count", "cor", "cu", "ca", "cb", "col", "cd", "ci", "cm", "ct", "p", "d", "h", "xc", "a", "cc"], "f": ["fed", "file", "y", "cf", "u", "w", "frequency", "g", "m", "fac", "n", "l", "sf", "fx", "float", "fs", "bf", "z", "full", "fe", "fb", "e", "k", "r", "tf", "q", "fre", "b", "um", "fc", "fo", "fa", "o", "fg", "xf", "uf", "j", "rf", "fi", "v", "F", "fw", "fit", " F", "fd", "fr", "df", "p", "d", "a", "fp", "h", "lf", "form"], "x": ["ax", "y", "u", "ic", "xs", "w", "xt", "xe", "m", "xml", "xi", "xp", "n", "l", "ix", "xa", "ext", "z", "e", "xy", "rx", "r", "q", "hex", "co", "time", "b", "o", "xf", "X", "j", "xx", "wx", "v", "ox", "ex", "inx", "ux", "p", "a", "ct", "h", "xc", "tx"], "num_farms": ["num_pars", "num_vars", "num_Faves", "num_facarts", "num_varm", "num_farts", "num_vays", "num_fats", "num_Fms", "num_Fairs", "num_barm", "num_facars", "num_pats", "num_parms", "num_facarm", "num_pairs", "num_marms", "num_frarm", "num_fairs", "num_facarms", "num_fays", "num_farm", "num_Fars", "num_frars", "num_fms", "num_fars", "num_bairs", "num_Fats", "num_pays", "num_mats", "num_baves", "num_frays", "num_facms", "num_Farts", "num_varts", "num_parm", "num_paves", "num_marts", "num_varms", "num_frms", "num_Farms", "num_frarms", "num_barms", "num_faves", "num_parts", "num_Farm", "num_marm"], "t": ["u", "tr", "g", "got", "it", "l", "table", "b", "j", "iat", " T", "num", "ent", "dt", "type", "ct", "a", "tc", "just", "to", "hot", "e", "r", "ert", "tg", "term", "ret", "ts", "print", "out", "p", "transform", "length", "ta", "new", "at", "m", "n", "total", "tm", "load", "status", "pt", "time", "o", "temp", "nt", "te", "payment", "trace", "d", "ot", "title", "ti", "value", "rt", "tw", "long", "target", "test", "tp", "set", "vt", "tt", "trans", "tu", "T", "elt", "after", "all", "wt", "qt", "td"], "rate": ["range", "rates", "ate", "cr", "ta", "frequency", "pe", "prime", "at", "fee", "tone", "rot", "base", "stop", "late", "capacity", "rat", "float", "test", "function", "unit", "rew", "set", "e", "re", "r", "ride", "time", "change", "tt", "go", "term", "pr", "se", "force", "erate", "Rate", "te", "grow", "command", "error", "speed", "delay", "scale", "type", "p", "transform", "tc", "ot"], "i": ["ti", "s", "int", "ini", "uri", "y", "ic", "ind", "pi", "li", "m", "xi", "multi", "it", "n", "ix", "index", "l", "iri", "bi", "k", "zi", "id", "ij", "hi", "r", "q", "ai", "phi", "im", "ri", "I", "si", "j", "mi", "ui", "ski", "di", "gi", "ip", "ii", "ci", "p", "ji", "ei", "oi"], "opt_rate": ["opt_Rate", "opt2rate", " opt_rule", " optgrates", "option_rate", "opt2rule", "optgrule", "opt_rates", " opt_Rate", " optgRate", " optgrule", "optgrate", " optgrate", "opt2erate", "opt_rule", "optgrates", "opt_erate", "option_rates", "opt2Rate", "option_Rate", " opt_rates", "opt2rates", "option_erate", "optgRate"], "t1": ["l1", "T2", "f01", " t0", "T0", "l2", "f2", "T01", "tt2", "T1", "t01", "tt81", "f1", "f81", "tt01", "tt1", "T81", "t81", "l0", "t0"], "t2": ["T2", "tpl", "timetwo", "ittwo", "T4", "tt2", "Ttwo", " t4", "t4", "tttwo", "T1", "timepl", " tpl", "ttpl", "tt102", "it4", "t102", "it1", "it2", " ttwo", "time102", "ttwo", "time2", " t102"]}}
{"code": "\\n  def generate_matrix(r, c, char):\\n  \tmat = [[char for i in range(c)] for j in range(r)]\\n  \treturn mat\\n  \t\\n  def merge(mat1, mat2):\\n  \tfor i in range(len(mat1)):\\n  \t\tfor j in range(len(mat1[i])):\\n  \t\t\tmat2[i][j] = mat1[i][j]\\n  \treturn mat2\\n  \\n  def solve(r, c, m):\\n  \tif 0 == m:\\n  \t\tmat = generate_matrix(r, c, '.')\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \t\t\\n  \tf = r * c - m\\n  \t\\n  \tif 0 == f:\\n  \t\treturn False\\n  \t\t\\n  \tif 1 == f:\\n  \t\tmat = generate_matrix(r, c, '*')\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \t\t\\n  \tif 1 == min(r, c):\\n  \t\tmat = generate_matrix(r, c, '*')\\n  \t\tfor i in range(f):\\n  \t\t\tmat[0 if 1 == r else i][0 if 1 == c else i] = '.'\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \\n  \tif 2 == min(r, c):\\n  \t\tif (0 != f % 2) or (2 == f):\\n  \t\t\treturn False\\n  \t\tmat = generate_matrix(r, c, '*')\\n  \t\tfor i in range(f // 2):\\n  \t\t\tmat[0 if 2 == r else i][0 if 2 == c else i] = '.'\\n  \t\t\tmat[1 if 2 == r else i][1 if 2 == c else i] = '.'\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \t\t\\n  \tif (3 == r) and (3 == c):\\n  \t\tif (4 == f) or (6 == f):\\n  \t\t\tmat = generate_matrix(r, c, '*')\\n  \t\t\tfor i in range(f // 2):\\n  \t\t\t\tmat[0][i] = '.'\\n  \t\t\t\tmat[1][i] = '.'\\n  \t\t\tmat[0][0] = 'c'\\n  \t\t\treturn mat\\n  \t\tif 8 == f:\\n  \t\t\tmat = generate_matrix(r, c, '.')\\n  \t\t\tmat[2][2] = '*'\\n  \t\t\tmat[0][0] = 'c'\\n  \t\t\treturn mat\\n  \t\treturn False\\n  \t\t\\n  \trows_to_reduce = min(r - 3, m // c)\\n  \tif 0 < rows_to_reduce:\\n  \t\tres = solve(r - rows_to_reduce, c, m - rows_to_reduce * c)\\n  \t\tif False == res:\\n  \t\t\treturn False\\n  \t\tmat = merge(res, generate_matrix(r, c, '*'))\\n  \t\treturn mat\\n  \t\t\\n  \tcols_to_reduce = min(c - 3, m // r)\\n  \tif 0 < cols_to_reduce:\\n  \t\tres = solve(r, c - cols_to_reduce, m - cols_to_reduce * r)\\n  \t\tif False == res:\\n  \t\t\treturn False\\n  \t\tmat = merge(res, generate_matrix(r, c, '*'))\\n  \t\treturn mat\\n  \t\\n  \tmat = generate_matrix(r, c, '.')\\n  \tfor i in range(min(m, r - 2)):\\n  \t\tmat[r - i - 1][c - 1] = '*'\\n  \tif m == r - 1:\\n  \t\tmat[r - 1][c - 2] = '*'\\n  \tmat[0][0] = 'c'\\n  \treturn mat\\n  \t\t\t\\n  \\n  t = int(sys.stdin.readline().strip())\\n  \\n  for i in range(t):\\n  \tprint \"Case #\" + str(i + 1) + \":\"\\n  \\n  \tr, c, m = [int(i) for i in sys.stdin.readline().strip().split()]\\n  \t\\n  \tres = solve(r, c, m)\\n  \t\\n  \tif False == res:\\n  \t\tprint \"Impossible\"\\n  \telse:\\n  \t\tfor i in range(r):\\n  \t\t\tfor j in range(c):\\n  \t\t\t\tsys.stdout.write(res[i][j])\\n  \t\t\tprint\\n", "target": "24", "substitutes": {"r": ["hr", "range", "rr", "rt", "cr", "dr", "gr", "u", "y", "w", "th", "tr", "ren", "g", "rect", "rate", "ru", "n", "l", "nr", "attr", "rd", "h", "rn", "rm", "sr", "e", "rs", "root", "re", "ir", "q", "br", "ro", "b", "ur", "ar", "o", "ra", "rem", "ri", "pr", "R", "rec", "rc", "raw", "rf", "rh", "mr", "v", "reg", "usr", "x", "er", "rw", "lr", "fr", "me", "vr", "p", "d", "rar", "rg", "rb", "rx"], "c": ["s", "u", "g", "l", "cl", "C", "loc", "co", "b", "fc", "bc", "cos", "ce", "rc", "v", "cor", "cd", "ct", "a", "tc", "nc", "cp", "cont", "w", "anc", "cin", "com", "ac", "z", "e", "mc", "vc", "cur", "ca", "cb", "p", "h", "xc", "n", "can", "arc", "dc", "o", "sc", "cat", "col", "ci", "d", "cs", "cr", "ch", "y", "cf", "ic", "erc", "gc", "con", "ec", "lc", "unc", "cache", "chain", "cu", "x", "pc", "cm", "content", "enc", "etc", "cc"], "char": ["cher", "int", "cr", "cp", "CHAR", "ch", "u", "new", "tr", "word", "ie", "cell", "com", "text", "test", "color", "car", "Char", "k", "q", "ar", "cur", "term", "ter", "character", "che", "v", "ctr", "letter", "str", "er", "fr", "col", "err", "name", "string"], "mat": ["atten", "tag", "Mat", "match", "spec", "att", "gem", "struct", "case", "multi", "it", "only", "lat", "mt", "full", "prot", "tmp", "wat", "grid", "mem", "sit", "path", "cond", "hist", "flat", "mut", "net", "num", "mon", "umat", "method", "dt", "ct", "ma", "cfg", "apt", "tar", "sche", "cert", "gate", "txt", "function", "db", "red", "term", "dict", "html", "md", "pit", "mun", "prop", "list", "exp", "transform", "form", "func", "stat", "mk", "doc", "mode", "mult", "at", "vec", "mol", "buf", " Mat", "bool", "late", "sat", "plot", "rat", "mand", "dim", "tm", "pred", "vert", "xy", "mac", "map", "pt", "mp", " matrix", "mod", "MAT", "met", "cat", "mot", "act", "col", "pos", "ht", "pat", "cmd", "mit", "port", "rot", "feat", "init", "pose", "unit", "mm", "config", "man", "jac", "tt", "um", "product", "trans", "det", "format", "msg", "et", "x", "hat", "Matrix", "img", "mate", "wt", "fm", "qt", "dat"], "i": ["iy", "ini", "u", "g", "it", "l", "iri", "ir", "v", "di", "yi", "a", "io", "ma", "ion", "int", "li", "ami", "ie", "index", "il", "e", "zi", "iu", "iter", "ri", "I", "ii", "\u00ed", "p", "name", "ei", "ki", "uri", "pi", "xi", "n", "bi", "id", "ai", "phi", "o", "si", "mi", "ati", "ia", "ib", "ik", "ci", "iti", "ti", "ic", "y", "ix", "key", "hi", "ij", "im", "ui", "info", "x", "gi", "ip", "ji", "ee", "item"], "j": ["jl", "ja", "J", "jj", "ch", "u", "y", "ind", "li", "g", "ie", "it", "n", "kj", "l", "ix", "index", "aj", "z", "bi", "js", "jp", "dj", "k", "ij", "jc", "ir", "q", "jac", "bj", "b", "o", "si", "v", "x", "er", "je", "fr", "uj", "jump", "p", "ji", "h", "oj"], "mat1": ["catOne", "cat3", "MatOne", "hat3", "pat01", " matOne", "cat2", "mat8", "Mat01", " mat0", "matOne", "Mat0", "pat0", "matone", "mt2", "Mat2", "hat2", " mat3", "Matone", "pat1", "patOne", "pat8", "mat3", "mt8", "hatone", "Mat8", " mat01", "Mat1", "cat1", "mt1", "hat1", "mtOne", "mat01", " matone", "Mat3", "mat0", "pat2"], "mat2": ["cat3", "mt0", "hat3", "cat2", "mat8", "mt3", "cat0", " mat0", "mem3", "Mat0", "pat0", "mt2", "Mat2", " mat3", "hat2", "mt5", "pat1", "cat5", "hat5", "pat3", "hat0", "mat3", "mat5", "Mat8", "Mat1", "mem8", "Mat3", "mat0", "mem2", "pat2", " mat8", "mem1"], "m": ["ms", "y", "u", "ma", "g", "n", "M", "l", "tm", "mt", "mc", "e", "k", "mm", "q", "b", "km", "o", "perm", "mi", "mut", "mr", "v", "gm", "cm", "p", "d", "a", "h", "fm"], "f": ["of", "file", "u", "cf", "w", "y", "g", "fac", "n", "it", "l", "sf", "float", "bf", "z", "full", "fe", "fb", "e", "k", "fl", "q", "tf", "b", "fc", "fa", "o", "fg", "rf", "frac", "fi", "ff", "v", "F", "x", "fd", "fr", "df", "p", "d", "all", "a", "fp", "h", "fm"], "rows_to_reduce": ["rows_to_redure", "rows_to_deduce", "rows_to_resuce", "rows_to_deduction", "rows_to_dedure", "rows_to_Reduction", "rows_to_reducer", "rows_to_resure", "rows_to_deducer", "rows_to_Reducer", "rows_to_resuction", "rows_to_resucer", "rows_to_reduction", "rows_to_Reduce", "rows_to_Redure"]}}
{"code": "def time_to_get(target, num_factories, factory_cost, factory_increase):\\n      rate = 2.0\\n      t = 0\\n      for i in range(num_factories):\\n          t += factory_cost/rate\\n          rate += factory_increase\\n      return t + target/rate\\n      \\n  def solve(C,F,X):\\n      min_sol = None\\n      num_fact = 0\\n      while True:\\n          t = time_to_get(X, num_fact, C, F)\\n          if min_sol is None or t < min_sol:\\n              min_sol = t\\n              num_fact += 1\\n          else:\\n              return min_sol\\n  \\n  if __name__ == \"__main__\":\\n      T = int(raw_input())\\n      for i in range(1, T+1):\\n          C,F,X = map(float, raw_input().split())\\n          print \"Case #%d: %.07f\" % (i, solve(C,F,X))\\n", "target": "25", "substitutes": {"target": ["result", "value", "goal", "size", "y", "prime", "new", "g", "current", "base", "offset", "total", "grade", "test", "arget", "unit", "root", "gt", "default", "b", "term", "point", "source", "cpu", "output", "v", "force", "x", "Target", "top", "out", "weight", "scale", "next", "type", "stop", "max"], "num_factories": ["num_Factors", "num_creatories", "num_colorial", "num_colors", "num_factors", "num_Factries", "num_Factories", "num_Factorial", "num_creators", "num_actories", "num_actors", "num_colions", "num_creatries", "num_actions", "num_Factions", "num_actries", "num_colories", "num_Factory", "num_factorial", "num_actory", "num_factions", "num_actorial", "num_factries", "num_creatory", "num_factory"], "factory_cost": ["factory__loss", "factory_weight", "factory__cost", "fault_loss", "factory__price", "fault__cost", "factory_price", "fault__loss", "fault_price", "factory2cost", "factory2price", "factory_loss", "fault_cost", "fault__price", "factory2weight"], "factory_increase": ["factory_incases", "factory__increases", "factory_increasing", "factory_Increase", "factory__easing", "factory_reate", "factory_eate", "factory_iterate", "factory_increate", "factory_Increchange", "factory_rechange", "factory_Increases", "factory_incase", "factory_iterases", "factory_increases", "factory_iterase", "factory__ease", "factory__increasing", "factory_rease", "factory_Increate", "factory__eases", "factory__increase", "factory_incasing", "factory_incate", "factory__eate", "factory_ease", "factory_reases", "factory_eases", "factory_iterchange", "factory_Increasing", "factory_easing", "factory_increchange", "factory__increate"], "rate": ["range", "duration", "rates", "seed", "ate", "rice", "core", "timeout", "ta", "frequency", "rating", "prime", "f", "m", "fee", "rot", "n", "step", "beta", "rat", "rand", "e", "unit", "set", "re", "r", "ride", "time", "tt", "change", "rule", "term", "rated", "pr", "currency", "force", "x", "erate", "Rate", "te", "weight", "speed", "trace", "delay", "scale", "dt", "average", "d", "factor", "tc", "ot"], "t": ["s", "title", "rt", "to", "ta", "ty", "y", "w", "at", "f", "g", "m", "tw", "that", "typ", "n", "it", "l", "total", "test", "c", "h", "tm", "token", "tp", "set", "unit", "qt", "vt", "r", "pt", "time", "tt", "b", "o", "tg", "term", "start", "temp", "j", "elt", "iat", "ten", "v", "ts", "x", "te", "out", "trace", "dt", "type", "p", "d", "ct", "tz", "tc", "wt", "ot"], "i": ["ti", "int", "iy", "ic", "y", "ind", "pi", "f", "li", "g", "m", "xi", "n", "it", "ix", "index", "l", "c", "bi", "e", "k", "iter", "id", "q", "r", "ai", "b", "im", "I", "si", "j", "mi", "counter", "v", "x", "ik", "gi", "di", "ip", "ci", "p", "iti", "d", "ion", "oi"], "C": ["V", "CS", "G", "CI", "P", "Chain", "CNN", "CC", "Y", "CG", "N", "CL", "MC", "B", "CM", "c", "D", "CF", "CB", "YC", "Ch", "Cs", "H", "CE", "JC", "CT", "CU", "Cl", "DC", "OC", "A", "I", "R", "CP", "CA", "S", "Cons", "L", "Config", "CR", "CH", "CW", "VC", "CN", "Con", "Co", "SC"], "F": ["V", "G", "W", "P", "Fact", "GF", "Fred", "FR", "FER", "f", "AF", "Y", "Feed", "N", "M", "FC", "FI", "B", "RF", "Foreign", "D", "CF", "Factory", "EF", "FD", "FL", "IF", "Fi", "H", "DF", "A", "UF", "I", "Full", "Fe", "E", "FG", "WF", "Form", "U", "L", "FN", "Q", "SF", "Fin", "PF", "FF", "Family", "FE"], "X": ["V", "Tx", "G", "W", "P", "ML", "J", "TX", "XY", "FX", "Y", "XM", "N", "O", "M", "Xi", "B", "D", "XL", "H", "K", "IX", "XX", "A", "DX", "I", "R", "E", "S", "L", "x", "U", "Target", "UX", "XP", "Q", "XT", "OX", "Z", "ZX", "Ex", "ICE"], "min_sol": ["minablestress", "minverserv", "minimum_sol", "min_stress", "min_rol", "MIN_sum", "MIN_Sol", " min_Sol", "min_serv", "minversol", " min_serv", "min_sel", "minimum_s", "min_pos", " min_vol", " min_sel", "minverpos", " min_pos", "min_rel", "minimum_stress", "minverrel", "min_val", "minableSol", "minables", "minimum_Sol", "minablesol", "min_sat", " min_sat", "min_vol", "min_sum", "MIN_rol", "min_s", "MIN_sol", "min_Sol", " min_rel", " min_val"], "num_fact": ["num_fac", "multi_factor", "num_fe", " num_feat", "num___factor", "num_facts", "num_feat", "multi_facts", "num_tag", "num___tag", "multi_tag", " num_Fact", " num_factor", "num___facts", " num_fac", "multi_fact", "num___fe", "num_factor", "num___fact", "num___feat", " num_fe", "num_Fact"], "T": ["V", "GT", "G", "P", "TB", "Time", "J", "TN", "Y", "N", "M", "B", "TA", "D", "TT", "TY", "H", "K", "I", "R", "TS", "S", "NT", "WT", "L", "Target", "Q", "TM", "VT", "Z", "TC"]}}
{"code": "\\n  def all_grids(R,C,M, lp=0,placed=0):\\n      rem = R*C-lp\\n      if M-placed >= rem:\\n          if M-placed > rem:\\n              return None\\n          \\n          res = set()\\n          for i in range(lp, R*C):\\n              res.add(i)\\n          return [res]\\n          \\n      if placed == M:\\n          return [set()]\\n  \\n      res = []\\n      for i in range(lp, R*C):\\n          sub_sol = all_grids(R,C,M,i+1, placed+1)\\n          if sub_sol is None:\\n              continue\\n              \\n          for s in sub_sol:\\n              s.add(i)\\n              res.append(s)\\n      return res\\n  \\n  def adj(R,C,i):\\n      \\n      res = []\\n      left_edge = i % C == 0\\n      top_edge = i // C == 0\\n      right_edge = (i+1) % C == 0\\n      bottom_edge = i // C == R-1\\n      \\n      if not left_edge:\\n          res.append(i-1)\\n          if not top_edge:\\n              res.append(i-1-C)\\n          if not bottom_edge:\\n              res.append(i+C-1)\\n              \\n      if not right_edge:\\n          res.append(i+1)\\n          if not top_edge:\\n              res.append(i+1-C)\\n          if not bottom_edge:\\n              res.append(i+1+C)\\n              \\n      if not bottom_edge:\\n          res.append(i+C)\\n      if not top_edge:\\n          res.append(i-C)\\n      return res\\n          \\n      \\n      \\n      \\n  def solution(R,C,g):\\n      M = R*C\\n      res = []\\n      num_zeroes = 0\\n      for i in range(M):\\n          if i in g:\\n              res.append('x')\\n              continue\\n          x = 0\\n          for a in adj(R,C,i):\\n              if a in g:\\n                  x += 1\\n          if x == 0:\\n              num_zeroes += 1\\n          res.append(x)\\n          \\n      for i in range(M):\\n          if i in g:\\n              continue\\n          r = res[i]\\n          if r == 0 and num_zeroes == 1:\\n              continue\\n          connected = False\\n          for a in adj(R,C,i):\\n              if res[a] == 0:\\n                  connected = True\\n                  break\\n          if not connected:\\n              return None\\n      \\n      return res.index(0)\\n  \\n  def transcribe(R,C, g, sol):\\n      res = []\\n      for i in range(R):\\n          r = []\\n          for j in range(C):\\n              x = i*C+j\\n              if x in g:\\n                  r.append('*')\\n              elif x == sol:\\n                  r.append('c')\\n              else:\\n                  r.append('.')\\n          res.append(r)\\n      return res\\n  \\n  def printed_sol(transcript):\\n      if transcript is None:\\n          return \"Impossible\"\\n      else:\\n          return \"\\n\".join(\"\".join(row) for row in transcript)\\n  \\n  def solve(R,C,M):\\n      if M == R*C-1:\\n          g = []\\n          for i in range(R*C-1):\\n              g.append(i)\\n          return transcribe(R,C, g, R*C-1)\\n      \\n      for g in all_grids(R,C,M):\\n          sol = solution(R,C,g)\\n          if sol is None:\\n              continue\\n          return transcribe(R,C, g, sol)\\n      return None\\n              \\n      \\n  def output_grid(R,C,g):\\n      for i in range(R):\\n          for j in range(C):\\n              if i*C+j not in g:\\n                  sys.stdout.write(\".\")\\n              else:\\n                  sys.stdout.write(\"*\")\\n          sys.stdout.write(\"\\n\")\\n  \\n  if __name__ == \"__main__\":\\n      T = int(raw_input())\\n      for i in range(1,T+1):\\n          R,C,M = map(int, raw_input().split())\\n          print \"Case #%d:\" % i\\n          print printed_sol(solve(R,C,M))\\n", "target": "25", "substitutes": {"R": ["V", "Rel", "RS", "G", "Root", "P", "RE", "Role", "Remote", "Range", "RG", "Repl", "N", "Right", "Rank", "B", "MR", "RF", "Rs", "D", "RA", "BR", "H", "Ring", "SR", "RM", "A", "RT", "I", "RO", "X", "JR", "E", "S", "RR", "NR", "DR", "L", "F", "Rot", "U", "CR", "Mr", "Res", "right", "Cor", "Rat", "LR", "HR", "AR", "Br", "RP", "Red"], "C": ["V", "CS", "G", "CI", "Chain", "P", "CV", "W", "CNN", "Cow", "COR", "CC", "CO", "Y", "CAR", "CG", "N", "CL", "O", "Count", "B", "CM", "c", "Car", "D", "CF", "CB", "YC", "Cs", "Ch", "H", "K", "CCC", "CE", "CT", "JC", "CU", "DC", "Cl", "A", "CD", "I", "EC", "CP", "E", "Cache", "S", "BC", "Cons", "L", "F", "CBS", "Config", "CR", "CON", "CH", "Ct", "Cu", "CW", "Cor", "VC", "CN", "WC", "Con", "TC", "Co", "Craig", "SC"], "M": ["V", "Man", "Mon", "G", "Mat", "MAN", "RE", "P", "MT", "W", "REM", "Multi", "Y", "m", "N", "O", "MC", "B", "CM", "MR", "JM", "MN", "D", "H", "MP", "K", "MI", "LM", "RM", " m", "A", "I", "X", "E", "S", "Size", "L", "F", "PM", "Mi", "FM", "Rem", "Q", "TM", "MS", "MM", "NM", "MA", "DM", "AM"], "lp": ["gp", "cp", "pert", "np", "ic", "GP", "sp", "pi", "m", "li", "xi", "LP", "l", "lik", "il", "LG", "illed", "rm", "BP", "nl", "dl", "ls", "bp", "mp", "lc", "lv", "lip", "LM", "ml", "LI", "joined", "left", "pr", "PL", "isi", "mi", "si", "lb", "mr", "L", "ill", "list", "ln", "pc", "lr", "pa", "pl", "ip", "lic", "LR", "lt", "p", "pp", "fp", "ap", "lis", "Li"], "placed": ["led", "paid", "stated", "aid", "P", "inged", "there", "reported", "priced", "ed", "m", "selected", "occupied", "l", "place", "linked", "mounted", "balanced", "added", "illed", "loc", "registered", "places", "filled", "Position", "LI", "played", "said", "left", "holder", "pr", "PL", "mi", "oved", "lb", "used", "listed", "powered", "reg", "Place", "matched", "L", "aced", "pressed", "position", "pl", "apped", "found", "p", "changed", "Pl", "pos", "marked", "represented"], "rem": ["hr", "rest", "em", "RE", "remove", "ms", "REM", "sp", "m", "xp", "n", "mn", "l", "remote", "rm", "fine", "loc", " Rem", "mm", "re", "resp", "registered", "mem", "pres", "ref", "ps", "pm", "pr", "rel", "ret", "mr", "reg", "rep", "pers", "Rem", "lr", "gm", "cm", "p", "recent", "lim", "rom", "pos"], "res": ["os", " Res", "conn", "arr", "req", "des", "only", "l", "cons", "js", "full", "Rs", "rs", "grid", "resp", "mem", "pres", "rek", "cond", "gas", "alg", "reg", "abs", "right", "els", "vals", "powers", "rx", "range", "fresh", "details", "we", "finals", "none", "resources", "reset", "groups", "ons", "ri", "pr", "results", "ret", "S", "ts", "bits", "ras", "terms", "usr", "out", "list", "RES", "conv", "eps", "exp", "err", "helps", "points", "ids", "rates", "blocks", "xs", "m", "vec", "rm", "ns", "ps", "back", "bs", "mr", "frames", "next", "rez", "ers", "resolution", "values", "resh", "cs", "rest", "expr", "result", "times", "ms", "gr", "yes", "css", "us", "ris", "fs", "set", "re", "gs", "es", "ress", "obj", "rel", "pas", "rep", "fields", "pers", "ws", "Res", "nil", "rex", "level", "ires", "als", "val", "all", "ins", "rev"], "i": ["ori", "iy", "ini", "cli", "t", "multi", "it", "l", "iri", "c", "ir", "bp", "b", "v", "di", "yi", "int", "li", "ie", "index", "il", "z", "e", "zi", "iu", "ri", "I", "asi", "ii", "p", "ei", "ki", "pi", "m", "xi", "n", "bi", "id", "ai", "phi", "ims", "o", "si", "mi", "ati", "ia", "ik", "pl", "adi", "ci", "iti", "oi", "ti", "rest", "ic", "y", "ind", "ix", "aii", "hi", "ij", "im", "ui", "info", "fi", "gi", "pc", "ip", "ji"], "sub_sol": ["sub_site", "sub2sol", "sub_sim", "submatsg", "Sub_sg", "Sub_s", "submatSol", "sub2sim", "subsubSol", "subsubsel", "sub_Sol", "submatres", "Sub_sol", "Sub_res", "Sub_sim", "sub2Sol", "sub_s", "Sub_Sol", "subsubsite", "sub2s", "Sub_sel", "subsubsol", "Sub_site", "sub_sg", "sub_sel", "submatsol", "sub_res"], "s": ["sm", "os", "sg", "stat", "ds", "ms", "stats", "xs", "sp", "f", "m", "l", "us", "single", "its", "js", "e", "rs", "set", "ns", "sing", "sq", "ss", "ls", "gs", "ps", "ims", "ats", "es", "si", "bs", "S", "sa", "ts", "ws", "sb", "sym", "p", "exp", "ins", "iss"], "left_edge": ["leftinggate", "leftingedge", " left_device", "leftingline", "top_gate", "top_line", "left_device", "left_gate", "left_line", "left_ink", " left_ink"], "top_edge": ["middle67edge", "toppyee", "top2Edge", "middle_edge", "middle67relation", "top2edge", "top2node", "toplyedge", "top_node", "top_field", "top_relation", "top67field", "top_Edge", "toplyfield", "top_link", "middle_field", "top67edge", "top_ee", "left_node", "bottom_ee", "top67relation", "toppynode", "toppyedge", "bottom_node", "toppyhop", "bottom_Edge", "top2link", "left_link", "middle_relation", "toplyrelation", "bottom_hop", "top_hop", "middle67field"], "right_edge": ["right_ee", "right_node", "rightlynode", "right_link", "rightlydevice", "top_node", "left_ee", "rightlyee", "top_link", "left_node", "left_device", "rightlyedge", "right_device"], "bottom_edge": ["bottom5edge", "floor_edge", "bottom2link", "top_link", "floor___edge", "bottomTheedge", "bottom_node", "bottom___evidence", "bottom_link", "bottom2edge", "top_route", "bottom___route", "floor___evidence", "top_Edge", "bottom_ee", "bottom___relation", "bottom_Edge", "bottomTheevidence", "bottomTheroute", "bottom5route", "bottom___edge", "floor_route", " bottom_ee", "floor___route", "bottom_relation", "bottomTherelation", "bottom5node", "bottom_evidence", "floor_evidence", "top_node", " bottom_node", "bottom2Edge", "floor_relation", "floor___relation", "bottom_route"], "g": ["cfg", "G", "gp", "gen", "gr", "ic", "y", "u", "w", "ag", "m", "gate", "gh", "n", "l", "ga", "c", "og", "gc", "z", "gre", "e", "ged", "gray", "gt", "group", "gs", "go", "b", "leg", "o", "msg", "gg", "erg", "gd", " G", "mg", "v", "reg", "ger", "gi", "ig", "eg", "gn", "gm", "p", "d", "rg", "bg", "h", "ge", "gu"], "num_zeroes": ["num_ermes", "num_zerones", "num_zodes", "num_zeros", "num_zenoes", "num_erosos", "num_erosoms", "num_eros", "num_zermes", "num_eroms", "num_zeroms", "num_zenmes", "num_erosoes", "num_erones", "num_zoes", "num_zerodes", "num_zones", "num_zerooes", "num_zeroodes", "num_zeroos", "num_zenos", "num_zmes", "num_eroes", "num_zeroones", "num_erodes", "num_zos", "num_erosodes", "num_zerooms", "num_zenones"], "x": ["mx", "xxx", "ax", "y", "u", "w", "xs", "xt", "t", "xe", "xml", "m", "yx", "xi", "xp", "n", "xxxxxxxx", "ix", "xa", "fx", "c", "z", "xy", "e", "re", "xes", "px", "xf", "X", "xx", "wx", "dx", "v", "ox", "ex", "inx", "p", "tx", "xc", "rx"], "a": ["aaa", "ea", "ta", "ka", "sta", "u", "y", "ed", "ha", "at", "t", "m", "err", "li", "ie", "ana", "n", "ach", "xa", "ga", "c", "ac", "z", "ab", "aa", "za", "e", "ij", "ai", "b", "fa", "ra", "o", "A", "ar", "ri", "na", "sa", "action", "ae", "ua", "aq", "ao", "an", "ia", "er", "di", "ca", "ba", "pa", "wa", "adi", "va", "au", "p", "ma", "ap", "apa"], "r": ["adr", "rr", "rt", "u", "ed", "w", "t", "f", "m", "rage", "n", "l", "nr", "rd", "c", "z", "sr", "e", "rs", "re", "rb", "b", "ar", "o", "mr", "v", "ry", "er", "p", "d", "rar", "h", "rx"], "connected": ["valid", "chron", "conn", "visible", "ed", "created", " disconnected", "functional", "essential", "scribed", "n", "condition", "wired", "linked", "index", "ended", "balanced", "c", " bonded", "z", "con", "broken", "connection", "state", "filled", "induced", "normal", "shown", "modified", "rolled", "cond", "encrypted", "close", "active", "powered", "colored", "out", "opened", "loaded", "connect", "num", "directed", "charged", "open", "graph", "established", "closed"], "sol": ["sg", "gp", "ol", "Sol", "gr", "sp", "mol", "xi", "sat", "rol", "ls", "jac", "vol", "gs", "ps", "msg", "rel", "mg", "sa", "sel", "mr", "str", "ln", "rl", "gm", "val", "err", "pos"]}}
{"code": "T = int(raw_input())\\n  \\n  def solve(C, F, X):\\n      best = x/2\\n      buildTime, speed = 0, 2\\n      while True:\\n          buildTime += C/speed\\n          if buildTime > best:\\n              break\\n          speed += F\\n          best = min(best, buildTime + X/speed)\\n      return best\\n  \\n  for z in xrange(T):\\n      c, f, x = map(float, raw_input().split())\\n      print \"Case #%d: %.7f\" % (z+1, solve(c, f, x))\\n", "target": "26", "substitutes": {"T": ["V", "G", "W", "P", "TB", "Time", "TN", "t", "Y", "N", "M", "B", "D", "TT", "H", "K", "A", "I", "R", "E", "TS", "S", "WT", "L", "TH", "Q", "TM", "Z"], "C": ["V", "CS", "G", "CI", "P", "Time", "CNN", "CC", "CO", "Y", "N", "FC", "MC", "B", "CM", "D", "CB", "CF", "Cs", "H", "CT", "CU", "A", "DC", "CD", "I", "R", "CP", "S", "L", "U", "Q", "Z", "Co"], "F": ["V", "G", "W", "FU", "P", "FT", "Time", "J", "FW", "GF", "FR", "AF", "Y", "Speed", "N", "M", "FC", "B", "D", "EF", "CF", "FD", "IF", "H", "K", "DF", "A", "UF", "I", "E", "FO", "S", "FG", "WF", "L", "U", "FP", "Q", "Z", "PF", "FF", "FE"], "X": ["V", "Tx", "W", "P", "XXX", "Time", "J", "FX", "XY", "Y", "N", "FC", "EX", "D", "XL", "IF", "K", "IX", "XX", "DX", "I", "E", "S", "L", "U", "UX", "XP", "Q", "XT", "Z", "FF", "Ex", "FE"], "best": ["result", "master", "est", "last", "pb", "short", "Best", "goal", "adjusted", "better", "new", "t", "g", "cost", "fast", "only", "index", "test", " optimum", "window", "failed", "highest", "opt", "fine", "tmp", "worst", "pro", "snap", "b", "score", "ps", "obj", " Best", "start", "stable", "ff", "largest", "v", "good", "top", "success", "fit", "bottom", "end", "latest", "p", "all", "round", "final", "average", "stop", "pop", "just", "broad", "max", "peak"], "buildTime": ["uildName", "builderTime", " buildNow", "buildTimes", "BuildStart", "BuildTime", " rebuildTimes", " buildTurn", "BuildTurn", "uildTurn", "buildTurn", " rebuildTurn", "builderTim", " buildTim", "uildNow", " buildStart", "BuildTimes", "uildStart", "buildStart", " rebuildName", "BuildTim", " buildTimes", "buildNow", " rebuildTime", "BuildNow", "uildTime", "buildTim", "buildName", "builderTimes", " buildName", "uildTimes"], "speed": ["length", "duration", "send", "value", "power", "performance", "gain", "sex", "size", "frequency", "goal", "spec", "peed", "cost", "rate", "Speed", "fast", "step", "float", "test", "service", "function", "reason", "rank", "build", "control", "sign", "time", "loss", "sw", "start", "field", "shock", "force", " Speed", "efficiency", "distance", "slow", "weight", "error", "delay", "scale", "spe", "type", "EED", "height", "stop", "score"], "z": ["zone", "y", "zen", "u", "zip", "w", "yz", "ze", "nz", "zh", "t", "n", "step", "window", "rand", "zi", "id", "ez", "q", "state", "iz", "hz", "j", "az", "wx", "count", "v", "gz", "cz", "code", "zer", "p", "Z", " Z", "tz", "i"], "c": ["cs", "cr", "cp", "abc", "uc", "cf", "ic", "t", "g", "l", "com", "cl", "ac", "ec", "mc", "lc", "co", "b", "fc", "cos", "ce", "cod", "cu", "cb", "cn", "ci", "cm", "ct", "cd", "d", "xc", "cc"], "f": ["cf", "y", "w", "t", "ft", "l", "fx", "fs", "fb", "fe", "e", "tf", "b", "fc", "fo", "fa", "fg", "xf", "uf", "alf", "rf", "fi", "v", "fd", "fr", "d", "fp", "fm", "i", "lf"], "x": ["s", "y", "ic", "xs", "w", "xt", "t", "xe", "g", "xi", "xp", "fast", "n", "l", "fx", "xy", "e", "q", "r", "b", "XX", "xf", "xx", "wx", "ff", "v", "ox", "XP", "ex", "p", "d", "ux", "tx", "h", "xc", "i", "rx"]}}
{"code": "\\n  T = int(raw_input())\\n  \\n  def generate(R, C, a, sw):\\n      if sw:\\n          R, C = C, R\\n      res = [['*']*C for i in xrange(R)]\\n      for i in xrange(len(a)):\\n          for j in xrange(a[i]):\\n              if sw:\\n                  res[j][i] = '.'\\n              else:\\n                  res[i][j] = '.'\\n      res[0][0] = 'c'\\n      return str(res)[2:-2].replace(' ', '').replace(\"'\",'').replace('[', '').replace('],','\\n').replace(',', '')\\n  \\n  \\n  def solveEq(k, s, x1):\\n      if 2*(x1 + k - 2) > s or k*x1 < s:\\n          return None\\n      r = [0]*k\\n      r[0] = r[1] = x1\\n      s -= 2*x1\\n      for i in xrange(k-2, 0, -1):\\n          t = min(x1, s - 2*i + 2)\\n          r[k-i] = t\\n          s -= t\\n      return r\\n  \\n  def solve(R, C, M):\\n      S = R*C\\n      nm = S - M\\n      if R == 1 or C == 1:\\n          if R == 1:\\n              return '*'*M + '.'*(S-M-1) + 'c'\\n          else:\\n              return '*\\n'*M + '.\\n'*(S-M-1) + 'c'\\n      else:\\n          sw = False\\n          if R > C:\\n              R, C = C, R\\n              sw = True\\n          if nm == 2 or nm == 3 or nm == 5 or nm == 7 or (R == 2 and nm%2 == 1 and nm > 1):\\n              return \"Impossible\"\\n          if nm == 1:\\n              return generate(R, C, [1], sw)\\n          for k in xrange(2, R+1):\\n              for x1 in xrange(2, C+1):\\n                  r = solveEq(k, nm, x1)\\n                  if r != None:\\n                      return generate(R, C, r, sw)\\n          return \"Something wrong\"\\n  \\n  for z in xrange(T):\\n      c, f, x = map(int, raw_input().split())\\n      print \"Case #%d:\\n%s\" % (z+1, solve(c, f, x))\\n", "target": "26", "substitutes": {"T": ["V", "G", "W", "P", "TB", "J", "TN", "Y", "N", "O", "B", "TA", "D", "TT", "H", "K", "A", "I", "X", "E", "TS", "WT", "L", "F", "TH", "Q", "TR", "TM", "Z", "TC"], "R": ["V", "RS", "G", "Root", "P", "Role", "W", "RE", "Remote", "J", "Y", "RG", "Repl", "n", "N", "O", "B", "MR", "RF", "Rs", "D", "RL", "RA", "H", "BR", "K", "SR", "ro", "RM", "A", "RT", "I", "RO", "X", "E", "RR", "DR", "NR", "L", "F", "Rot", "U", "CR", "IR", "Mr", "Res", "Q", "KR", "Rat", "AR", "HR", "NM", "Br", "Z"], "C": ["V", "CS", "Cond", "G", "CV", "Chain", "W", "P", "J", "CC", "Cr", "Y", "CG", "N", "CL", "Can", "O", "Count", "MC", "B", "CM", "c", "HC", "D", "CB", "CF", "Cs", "Ch", "H", "K", "CE", "JC", "CT", "CCC", "CU", "A", "Cal", "DC", "Cl", "I", "CD", "X", "E", "CP", "CA", "BC", "Cons", "Size", "L", "F", "U", "CR", "CON", "Q", "Cu", "CW", "Cor", "VC", "Comp", "Col", "CN", "WC", "Con", "TC", "Co"], "a": ["data", "aaa", "ja", "ta", "ata", "w", "at", "f", "m", "l", "c", "aj", "mat", "ac", "area", "ab", "aa", "e", "rs", "da", "re", "b", "ar", "A", "o", "am", "es", "na", "sa", "v", "x", "an", "er", "ca", "abs", "alpha", "aux", "p", "au", "ma", "ap"], "sw": ["hr", "hw", "sm", "send", "ew", "sv", "warn", "SW", "sex", "w", "th", "sd", "sp", "tr", "sync", "st", "we", "tw", "skip", "only", "sh", "sf", "ust", "switch", "pool", "isc", "iw", "sr", "store", "rew", "swe", " SW", "se", "stream", "sc", "ssl", "Sw", "wo", "sn", "sa", "ok", "wn", " Sw", "sy", "syn", "ww", "rw", "ws", "sl", "so", "fw", "nw", "ow", "wrap", "now", "wa", "wh", "aw", "enc", "ost", "wait", "wt", "resh", "ssh"], "res": ["rest", "os", "expr", "result", "free", "rt", " Res", "gr", "ms", "arr", "new", "req", "ren", "us", "cons", "js", "rs", "rx", "re", "resp", "q", "reset", "pres", "mem", "rem", "ref", "ro", "ps", "obj", "ress", "results", "pr", "rel", "rc", "ret", "v", "reg", "rep", "out", "Res", "RES", "sol", "right", "rez", "p", "content", "resolution", "err", "rev", "tx", "resh"], "i": ["ki", "ti", "int", "ic", "y", "u", "f", "m", "pi", "li", "ie", "xi", "g", "it", "n", "l", "ix", "index", "c", "z", "jp", "e", "zi", "id", "ij", "iu", "ir", "q", "ai", "b", "phi", "im", "o", "I", "si", "v", "x", "ia", "ak", "ik", "gi", "di", "ip", "ii", "ci", "p", "ji", "d", "h"], "j": ["jl", "ja", "J", "ax", "jj", "y", "u", "f", "li", "n", "kj", "it", "l", "ix", "index", "aj", "z", "js", " ii", "jp", "dj", "ij", "jc", "q", "b", "o", "obj", "si", "v", "ion", "ik", "ii", "jump", "uj", "ijk", "p", "ji", "name", "job", "oj"], "k": ["ki", "uk", "kl", "mk", "ka", "ch", "y", "w", "m", "g", "tk", "n", "kj", "it", "l", "key", "c", "kw", "z", "ks", "kh", "q", "K", "kar", "kn", "b", "kr", "km", "ck", "wk", "ok", "ek", "sk", "v", "ku", "kid", "x", "ak", "ik", "unk", "num", "ikk", "kan", " K", "ke", "ijk", "p", "kk", "h", "ko"], "s": ["cs", "sm", "second", "os", "sv", "ms", "y", "u", "ys", "w", "sp", "sd", "m", "g", "f", "xs", "n", "l", "sh", "c", "its", "z", "js", "e", "ns", "rs", "sq", "ss", "ls", "q", "gs", "b", "o", "es", "si", "self", "v", "ts", "x", "sb", "sym", "south", "p", "d", "ins", "h"], "x1": [" xp", "tx2", "ex1", "Xx", "Xone", "ax1", "ax3", "xxone", "ax0", "ex3", "x2", "xxx", "ix1", "xt0", "xs", "x3", " x9", "X0", "Xs", "xp", "X9", "tx0", "k0", "x9", " xs", "ks", "ax2", "X3", "xx1", " x0", "xx2", "ixx", "ix2", "X1", "X2", "ixone", "k3", "xt9", "k2", "xx", "xt1", "ex0", "x0", "Xp", " x3", "ex2", "exp", "xt2", "tx1", " x2", "xone", "k1"], "r": ["hr", "range", "result", "rr", "rt", "y", "u", "w", "pair", "f", "m", "g", "err", "rect", "n", "l", "rd", "c", "h", "rn", "z", "rm", "sr", "e", "rs", "re", "q", "ir", "b", "ro", "kr", "br", "ar", "o", "pr", "rc", "mr", "v", "answer", "x", "er", "lr", "rl", "row", "vr", "p", "d", "rar", "rb"], "t": ["ti", "rt", "ty", "ta", "y", "w", "tr", "f", "m", "at", "tw", "n", "it", "l", "c", "z", "tm", "tp", "e", "pt", "q", "tf", "tt", "b", "o", "v", "ts", "x", "te", "out", "dt", "lt", "p", "d", "tz", "tc", "wt", "ot"], "M": ["V", "Man", "G", "MAN", "W", "P", "MT", "J", "Y", "m", "N", "O", "MC", "B", "CM", "MN", "D", "H", "K", "MI", "RM", "A", "I", "X", "E", "L", "U", "F", "Q", "TM", "MS", "NM", "AM"], "S": ["V", "Ns", "RS", "CS", "G", "W", "P", "J", "TN", "SAM", "SIZE", "Y", "SI", "SA", "SP", "N", "O", "SN", "B", "NS", "MN", "D", "Sn", "SS", "H", "K", "SR", "A", "SU", "I", "SL", "X", "SE", "Si", "SM", "Size", "L", "SH", "Q", "MS", "NM", "Z"], "nm": ["Ns", "sm", "em", "tem", "nu", "asm", "orm", "TN", "np", "NH", "om", "f", "m", "nam", "dem", "nor", "mn", "n", "N", "nr", "sam", "htm", "NW", "rn", "iam", "rm", "tm", "MN", "sr", "Num", "NS", "ns", "nn", "ny", "ni", "NJ", "mem", " NM", "ne", "um", "im", "km", "RM", "no", " sm", " N", "sn", "fn", "mr", "NR", "ctr", "reg", "mom", "nom", "num", "sym", "NM", "cm", "ym", "ct", "name", "fm", "nc"]}}
{"code": "\\n  def readint():\\n      return int(sys.stdin.readline())\\n  \\n  def readfloatarray():\\n      return map(float, sys.stdin.readline().strip().split())\\n  \\n  def readintarray():\\n      return map(int, sys.stdin.readline().strip().split())\\n  \\n  def readpairs(start=0):\\n      elems = readintarray()[start:]\\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\\n  \\n  def readstring():\\n      return sys.stdin.readline()[:-1]\\n  \\n", "target": "27", "substitutes": {"start": ["say", "size", "first", "art", "sp", "st", "g", "current", "base", "skip", "offset", "it", "stop", "index", "init", "z", "set", "tmp", "root", "begin", "get", "Start", " Start", "j", "add", "count", "top", "end", "next", "p", "origin", "part", "shift", "pos", "starting"], "elems": ["lets", "elemins", "lels", "lemms", "Elecs", "lemins", "lemts", " elecs", "Elemers", "lemcs", "Elels", "elemes", "elemers", "lecs", "Elems", " elels", "elecs", "itests", " elemins", "Elets", "lemes", "itesmes", "lems", "itesms", "elets", "lemmers", " elemers", "elels", " elets", "itesmins", " elemes"], "i": ["ti", "ini", "ic", "cli", "ind", "pi", "f", "li", "m", "xi", "it", "ix", "key", "c", "bi", "zi", "id", "ij", "iu", "iter", "ai", "phi", "im", "I", "si", "j", "mi", "ui", "x", "di", "gi", "ii", "ip", "me", "ci", "p", "ji", "io", "ei", "oi"]}}
{"code": "\\n  \\n  \\n  directions = list(itertools.product([1, 0, -1], [1, 0, -1]))\\n  def count_neighbors(table, r, c):\\n      cols = len(table[0])\\n      rows = len(table)\\n      return sum(table[r + x][c + y] == \"*\" for x, y in directions \\n                  if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\\n  \\n  def is_valid(table):\\n      cols = len(table[0])\\n      rows = len(table)\\n      for r in xrange(rows):\\n          for c in xrange(cols):\\n              has_zero = any(table[r + x][c + y] == 0 for x, y in directions \\n                              if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\\n              if table[r][c] != \"*\" and not has_zero:\\n                  return False\\n  \\n      return True\\n  \\n  \\n  def draw_table(table, hide=False):\\n      cols = len(table[0])\\n      rows = len(table)\\n      ascii_table = \"\"\\n      for r in xrange(rows):\\n          for c in xrange(cols):\\n              if table[r][c] != \"*\":\\n                  ch = \"c\" if r == 0 and c == 0 else \".\"\\n                  table[r][c] = count_neighbors(table, r, c) if not hide else ch\\n  \\n              ascii_table += str(table[r][c])\\n  \\n          ascii_table += \"\\n\"\\n  \\n      return ascii_table[:-1]\\n  \\n  def solve(R, C, M):\\n      r = c = 0\\n      current_mines = R * C\\n      table = [[\"*\"] * C for k in xrange(R)]\\n      while M < current_mines:\\n          if table[r][c] == '*':\\n              table[r][c] = \".\"\\n              current_mines -= 1\\n  \\n          if current_mines > M and r + 1 < R and table[r+1][c] == \"*\":\\n              table[r+1][c] = \".\"\\n              current_mines -= 1\\n  \\n          draw_table(table)\\n          c += 1\\n          if c >= C:\\n              c = 0\\n              r += 1\\n  \\n      return table\\n  \\n  for i in xrange(readint()):\\n      R, C, M = readintarray()\\n  \\n      print \"Case #%d:\" % (i + 1)\\n      if M < (R * C) - 1:\\n          table = solve(R, C, M)\\n          if is_valid(table):\\n              print draw_table(table, hide=True)\\n          else:\\n              table = solve(C, R, M)\\n              rotated = [[\"*\"] * C for k in xrange(R)]\\n              for r in xrange(R - 1, -1, -1):\\n                  for c in xrange(C):\\n                      rotated[R - r - 1][c] = table[c][r]\\n  \\n              print draw_table(rotated, hide=True) if is_valid(rotated) else \"Impossible\"\\n  \\n      elif M == R * C:\\n          print \"Impossible\"\\n  \\n      else:\\n          table = [[\"*\"] * C for k in xrange(R)]\\n          table[0][0] = '.'\\n          print draw_table(table, hide=True)\\n", "target": "27", "substitutes": {"directions": ["Directtions", " directications", "governtions", "suggestion", "projectives", " directensions", "selection", "governifiers", "suggestions", "suggestifiers", "selectors", "Directives", "irectories", "Directions", "irectications", "directensions", "Direction", "projectors", "directifiers", "direction", " directories", "Directifiers", "draftensions", "directications", "projections", "governions", "directors", "directives", "irectensions", "draftions", "draftories", "projection", "irections", "directories", "draftications", "selections", "directtions", "suggesttions", "Directors", "selectives", "governion"], "table": ["note", "t", "tr", "cell", "query", "tmp", "minute", "batch", "source", "frame", "report", "output", "attribute", "type", "console", "summary", "json", "expected", "figure", "comment", "history", "database", "index", "buffer", "db", "function", "entry", "change", "term", "dict", "Table", "html", "stable", "style", "out", "list", "page", "position", "filter", "array", "section", "transform", "record", "form", "minimum", "collection", "chart", "panel", "total", "this", "option", "TABLE", "body", "column", "interface", "time", "module", "normal", "point", "able", "scroll", "journal", "model", "document", "trace", "tab", "data", "result", "tree", "file", "problem", "empty", "port", "public", "csv", "view", "key", "text", "user", "config", "sequence", "tf", "toc", " Table", "block", "inner", "see", "number", "template", "year", "variable", "cache", "info", "chain", "count", "qualified", "server", "error", "article", "row", "display", "td"], "r": ["hr", "u", "t", "tr", "g", "it", "l", "attr", "rd", "rn", "rs", "root", "q", "ir", "b", "ar", "rc", "j", "v", "rl", "right", "run", "rar", "a", "rx", "range", "adr", "to", "dr", "art", "w", "rect", "e", "kr", "pr", "res", "usr", "p", "err", "h", "record", "rr", "rid", "f", "m", "ren", "n", "ru", "nr", "this", "rm", "sr", "id", "rem", "ro", "o", "self", "mr", "ry", "lr", "fr", "vr", "d", "rg", "rb", "max", "result", "cr", "rt", "remote", "re", "br", "ra", "rel", "er", "row", "item"], "c": ["conf", "u", "t", "g", "only", "l", "cl", "_", "q", "co", "b", "fc", "ar", "bc", "ce", "rc", "v", "cor", "cy", "cd", "cut", "ct", "tc", "nc", "cp", "cont", "uc", "w", "cin", "com", "ac", "z", "mc", "e", "\u00e7", "category", "vc", "cur", "cod", "join", "ca", "cb", "p", "h", "name", "cam", "chart", "f", "m", "n", "can", "arc", "dc", "sc", "col", "cn", "ci", "d", "cs", "more", "cr", "cf", "ic", "csv", "gc", "ec", "con", "lc", "unc", "cache", "chain", "count", "cu", "pc", "code", "cm", "content", "void", "cc"], "cols": ["columnings", "tabes", "colords", "Coles", " colS", "llS", " coles", "ColS", "columnes", "llds", "llgs", "Colords", " colgs", "lls", "columnds", "columnses", "colx", "colS", "columnjs", "columnS", "tabx", "colses", "colds", "colings", "Colgs", "colgs", " colds", "coles", " colings", "cmds", "columnx", "COLses", " coljs", "columngs", "COLs", "Colds", "cmdgs", "tabs", "coljs", "tabgs", "cmdes", "llings", " colx", "columns", "Cols", "cmdjs", "columnords", "COLS", " colords", " colses"], "rows": ["cs", "s", "rates", "blocks", "relations", "bys", "ows", "ways", "cells", "tracks", "ms", "docs", "ries", "modules", "sections", "ys", "days", "opens", "jobs", "views", "ros", "types", "roots", "ris", "runs", "orts", "lines", "rs", "papers", "allows", "months", "obs", "files", "rooms", "groups", "flows", "posts", "es", "states", "results", "eeks", "outs", "bs", "heads", "dates", "ports", "orders", "images", "users", "frames", "fields", "uds", "tests", "workers", "boxes", "rown", "rices", "ios", "row", "issues", "pages", "uploads", "reads", "reports", "values"], "x": ["s", "mx", "step", "ax", "xs", "w", "xt", "xe", "xd", "xml", "yx", "xi", "xp", "width", "ix", "xa", "index", "lat", "fx", "lex", "h", "z", "ext", "xy", " xx", "column", "gal", "id", "exclusive", "xes", "time", "px", "path", "left", "sw", "X", "j", "element", "xx", "cross", "wx", "dx", "v", " X", "ox", "axis", "ex", " dx", "image", "row", "ctx", "col", "ux", "ct", "tx", "exp", "item", "xc", "content", "rx"], "y": ["s", "gy", "my", "ay", "sys", "iy", "very", "yout", "ty", "hey", "ly", "ya", "ys", "hot", "yz", "t", "Y", "oy", "sky", "yd", "l", "key", "yt", "z", "yn", "ies", "py", "xy", "wy", "yy", "ny", "client", "ye", "kit", "b", "ey", "uy", "dy", "j", "yr", "vy", "v", "ry", "sy", "fy", "cy", "yi", "yer", "sim", "ip", "col", "hy", "ym", "type", "content", "io", "yl"], "has_zero": ["hasnonone", "has_equal", " has_one", " has_equal", "hasnonzero", "has_Zero", "has_one", "hasnonZero", "hasnonequal", " has_Zero"], "hide": ["ignore", "free", "clear", "remove", "visible", "bid", "leave", "err", "hid", " Hide", "skip", "late", "plot", "spin", "pose", "set", "shadow", "ride", "hidden", "change", "hover", "include", "Hidden", "shown", "home", "see", " show", "close", "reve", "frame", "isl", "scroll", "Show", "enable", "show", "hold", "bare", "use", "Hide", "disable", "h", "label", "display", "ide"], "ascii_table": ["ascii2Table", "asciic8Table", "ascii2buffer", "ascii_stable", "ascipi_file", "ascii8Table", "asciini_table", "ascipi2file", "ascii64buffer", "ascii_binary", "ascipi_table", "ascii_Table", "asciic_total", "asciic_table", "ascii_buffer", "ascii64table", "asciic_Table", "ascii_connection", "asciiAuthtable", "asciini_buffer", "asciic_buffer", "ascii8total", "ascipi2Table", "ascipi2table", "ascipi_buffer", "ascii64connection", "asciiPTable", "ascii2table", "ascii_database", "asciini_Table", "ascii64database", "asciic_connection", "ascipi2buffer", "ascii8stable", "asciic_database", "asciic8table", "asciiPbinary", "asciini_binary", "asciiPtable", "asciic8stable", "asciiAuthconnection", "asciiAuthbuffer", "ascii2file", "ascii8table", "asciiPbuffer", "asciic8total", "asciiAuthdatabase", "ascipi_Table", "asciic_stable", "ascii_total", "ascii_file"], "ch": ["chi", "chan", "tch", " Ch", "th", "f", "case", "channel", "cell", "ach", "sh", "he", "l", "cl", "text", "ich", "z", "sch", "Ch", "kh", "q", "change", "br", "b", "cur", "chn", "cho", "pr", "j", "che", "hair", "str", "ih", "cht", "CH", "char", "ech", "och", "h", "chid", "how", "form"], "R": ["V", "RS", "G", "RE", "P", "J", "Y", "N", "O", "B", "MR", "GR", "Rs", "D", "H", "RA", "BR", "K", "RM", "T", "Row", "RT", "I", "RO", "X", "E", "S", "NR", "RR", "DR", "L", "F", "CR", "Mr", "TR", "Q"], "C": ["V", "CS", "G", "W", "P", "COR", "CC", "Y", "N", "O", "MC", "B", "CM", "D", "Cs", "K", "CT", "T", "DC", "A", "CU", "CD", "I", "X", "E", "EC", "S", "BC", "L", "F", "U", "CR", "CN"], "M": ["V", "RS", "G", "RE", "P", "W", "J", "Ma", "OR", "Y", "m", "Max", "N", "O", "MC", "B", "CM", "MR", "Rs", "MN", "D", "H", "K", "MI", "RM", "T", "A", "I", "E", "S", "RR", "L", "F", "U", "CR", "Q", "TM", "MM", "NM", "DM", "AM"], "current_mines": ["current_mineions", "current_minsutes", "current_minores", "current_mesions", "current_terminions", "current_termines", "current_mesodes", "current_monues", "current_dones", "current_minees", "current_Mines", "current_minsies", "current_donores", "current_Minets", "current_genries", "current_Minions", "current_terminies", "current_monets", "current_genues", "current_monutes", "current_menies", "current_meses", "current_minsodes", "current_terminutes", "current_genions", "current_donions", "current_minies", "current_minsets", "current_donets", "current_menes", "current_monions", "current_mones", "current_monries", "current_mesutes", "current_menutes", "current_minets", "current_minses", "current_minions", "current_minutes", "current_menions", "current_minues", "current_minodes", "current_minsions", "current_minsues", "current_genes", "current_minsores", "current_mineores", "current_minries", "current_Minutes", "current_Minodes", "current_mineets", "current_minsries"], "k": ["cr", "th", "w", "tr", "m", "g", "ru", "n", "ach", "rd", "ir", "co", "b", "br", "ur", "ar", "pr", "rec", "actor", "yr", "cu", "an", "ak", "fr", "rac", "run", "ket"]}}
{"code": "\\n  def iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tyield line_index, line.strip().split(' ')\\n  \\n  def iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 1\\n  \t\tcase = []\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not line_index % n:\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \\n  def iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 0\\n  \t\tnew_case = True\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tif new_case:\\n  \t\t\t\tnew_case = False\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \t\t\t\tassert len(line.strip().split(' ')) == 1\\n  \t\t\t\tlines_left = int(line.strip())\\n  \t\t\t\tif not lines_left:\\n  \t\t\t\t\tnew_case = True\\n  \t\t\t\t\tyield case_counter, case\\n  \t\t\t\tcontinue\\n  \t\t\tif lines_left:\\n  \t\t\t\tlines_left -= 1\\n  \t\t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not lines_left:\\n  \t\t\t\tnew_case = True\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\\n  def part_of_list_to_int(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(int(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_int(array):\\n  \treturn part_of_list_to_int(array, [True] * len(array))\\n  \\n  def part_of_list_to_float(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(float(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_float(array):\\n  \treturn part_of_list_to_float(array, [True] * len(array))\\n  \\n  def get_max_array_on_index(array, index):\\n  \telem_len = len(array[0])\\n  \tassert index < elem_len\\n  \tfor elem in array:\\n  \t\tassert elem_len == len(elem)\\n  \tmax_sub = array[0][index]\\n  \tmax_elem = array[0]\\n  \tfor elem in array:\\n  \t\tif elem[index] > max_sub:\\n  \t\t\tmax_sub = elem[index]\\n  \t\t\tmax_elem = elem\\n  \treturn max_elem\\n  \\n  def list_index_in_sorted_with_position(a_list, value, pos):\\n  \tlist_len = len(a_list)\\n  \tif list_len == 1:\\n  \t\tif a_list[0] == value:\\n  \t\t\treturn pos\\n  \t\treturn -1\\n  \tif a_list[list_len/2] > value:\\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\\n  \telse:\\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\\n  \t\\n  def list_index_in_sorted_list(a_list, value):\\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\\n  \\n  def copy_list(list):\\n  \tres = []\\n  \tfor elem in list:\\n  \t\tres.append(elem)\\n  \treturn res\t\\n  \\n  \\n  def solve(C, F, X):\\n  \tfarms_num = 0\\n  \twaiting_for_farms = 0\\n  \tproduction_rate = 2\\n  \tfinal_run_time = X / production_rate\\n  \tresult = final_run_time + waiting_for_farms\\n  \t\\n  \tprint \"%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f\" % (farms_num,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tproduction_rate,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfinal_run_time,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twaiting_for_farms,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult)\\n  \t\t\\n  \\n  \t\\n  \twhile True:\\n  \t\tfarms_num += 1\\n  \t\twaiting_for_farms += C / production_rate\\n  \t\tproduction_rate += F\\n  \t\tfinal_run_time = X / production_rate\\n  \t\tnew_result = final_run_time + waiting_for_farms\\n  \t\tprint \"%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f\" % (farms_num,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tproduction_rate,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfinal_run_time,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twaiting_for_farms,\\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew_result)\\n  \t\tif new_result > result:\\n  \t\t\treturn result\\n  \t\tresult = new_result\\n  \t\\n  def calc_result(case):\\n  \tresult = None\\n  \t\\n  \tC = float(case[0])\\n  \tF = float(case[1])\\n  \tX = float(case[2])\\n  \tprint C, F, X\\n  \t\\n  \tresult = solve(C, F, X)\\n  \tprint result\\n  \t\\n  \treturn result\\n  \\n  def main(filepath):\\n  \tstart_time = time.time()\\n  \twith file('output.txt', 'wb') as f_out:\\n  \t\t\\n  \t\tfor case_index, case in iterate_cases_1lpc(filepath):\\n  \t\t\t\\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\\n  \t\t\tresult = calc_result(case)\\n  \t\t\t\\n  \t\t\tf_out.write(\"Case #%d: %.07f\\n\" % (case_index, result))\\n  \t\t\t\t\\n  if __name__ == '__main__':\\n  \tmain(sys.argv[1])\\n", "target": "28", "substitutes": {"filepath": ["filename", "reportname", "reportfile", "reportpath", "ffile", "fdir", "filedir", "fname", " filefile", " filename", "reportdir", " filedir", "fpath", "filefile"]}}
{"code": "\\n  def iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tyield line_index, line.strip().split(' ')\\n  \\n  def iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 1\\n  \t\tcase = []\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not line_index % n:\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \\n  def iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 0\\n  \t\tnew_case = True\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tif new_case:\\n  \t\t\t\tnew_case = False\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \t\t\t\tassert len(line.strip().split(' ')) == 1\\n  \t\t\t\tlines_left = int(line.strip())\\n  \t\t\t\tif not lines_left:\\n  \t\t\t\t\tnew_case = True\\n  \t\t\t\t\tyield case_counter, case\\n  \t\t\t\tcontinue\\n  \t\t\tif lines_left:\\n  \t\t\t\tlines_left -= 1\\n  \t\t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not lines_left:\\n  \t\t\t\tnew_case = True\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\\n  def part_of_list_to_int(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(int(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_int(array):\\n  \treturn part_of_list_to_int(array, [True] * len(array))\\n  \\n  def part_of_list_to_float(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(float(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_float(array):\\n  \treturn part_of_list_to_float(array, [True] * len(array))\\n  \\n  def get_max_array_on_index(array, index):\\n  \telem_len = len(array[0])\\n  \tassert index < elem_len\\n  \tfor elem in array:\\n  \t\tassert elem_len == len(elem)\\n  \tmax_sub = array[0][index]\\n  \tmax_elem = array[0]\\n  \tfor elem in array:\\n  \t\tif elem[index] > max_sub:\\n  \t\t\tmax_sub = elem[index]\\n  \t\t\tmax_elem = elem\\n  \treturn max_elem\\n  \\n  def list_index_in_sorted_with_position(a_list, value, pos):\\n  \tlist_len = len(a_list)\\n  \tif list_len == 1:\\n  \t\tif a_list[0] == value:\\n  \t\t\treturn pos\\n  \t\treturn -1\\n  \tif a_list[list_len/2] > value:\\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\\n  \telse:\\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\\n  \t\\n  def list_index_in_sorted_list(a_list, value):\\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\\n  \\n  def copy_list(list):\\n  \tres = []\\n  \tfor elem in list:\\n  \t\tres.append(elem)\\n  \treturn res\t\\n  \\n  \\n  def conj_mat(a):\\n  \tR = len(a)\\n  \tC = len(a[0])\\n  \tres = [['.' for _ in xrange(R)] for __ in xrange(C)]\\n  \tfor i in xrange(R):\\n  \t\tfor j in xrange(C):\\n  \t\t\tres[j][i] = a[i][j]\\n  \treturn res\\n  \\n  def one_line_builder(R, C, M):\\n  \tres = []\\n  \tres.extend(['*'] * M)\\n  \tres.extend(['.'] * (C - M))\\n  \tres[-1] = 'c'\\n  \treturn [res]\\n  \t\\n  def two_line_builder(R, C, M):\\n  \tline = []\\n  \tline.extend(['*'] * (M / 2))\\n  \tline.extend(['.'] * (C - M / 2))\\n  \tres = [line, copy_list(line)]\\n  \tres[1][-1] = 'c'\\n  \tif M%2 == 1:\\n  \t\tres[0][-1] = '*'\\n  \treturn res\\n  \t\\n  def three_line_builder(R, C, M):\\n  \tres = [['.' for _ in xrange(C)] for __ in xrange(R)]\\n  \tres[-1][-1] = 'c'\\n  \tm = min([M, R * C - 9])\\n  \tstop_flag = False\\n  \tfor j in xrange(C):\\n  \t\tif stop_flag:\\n  \t\t\tbreak\\n  \t\tfor i in xrange(R):\\n  \t\t\tif m == 0:\\n  \t\t\t\tstop_flag = True\\n  \t\t\t\tbreak\\n  \t\t\tres[i][j] = '*'\\n  \t\t\tm -= 1\\n  \tprint i,j\\n  \tif i == 2:\\n  \t\tres[1][j-1] = '.'\\n  \t\tif j == C - 3:\\n  \t\t\tres[0][j] = '*'\\n  \t\telse:\\n  \t\t\tres[0][-1] = '*'\\n  \t\\n  \tif M <= R * C - 9:\\n  \t\treturn res\\n  \telse:\\n  \t\tm = M - (R * C - 9)\\n  \t\tassert m not in [2, 4, 6, 7, 9]\\n  \t\tassert m > 0\\n  \t\tassert m < 10\\n  \t\t\\n  \t\tres[-3][-3] = '*'\\n  \t\tm -= 1\\n  \t\tif m == 0: return res\\n  \t\tres[-2][-3] = '*'\\n  \t\tres[-1][-3] = '*'\\n  \t\tm -= 2\\n  \t\tif m == 0: return res\\n  \t\tres[-3][-2] = '*'\\n  \t\tres[-3][-1] = '*'\\n  \t\tm -= 2\\n  \t\tif m == 0: return res\\n  \t\tres[-2][-2] = '*'\\n  \t\tres[-2][-1] = '*'\\n  \t\tres[-1][-2] = '*'\\n  \t\tm -= 3\\n  \t\tif m == 0: return res\\n  \t\tassert False\\n  \t\\n  \t\\n  \t\\n  def over_three_line_builder(R, C, M):\\n  \tif M <= (R - 3) * C:\\n  \t\tres = [['*' for _ in xrange(C)] for __ in xrange(M / C)]\\n  \t\tflag = False\\n  \t\tif (M % C) != (C - 1):\\n  \t\t\tline = ['*' for _ in xrange(M % C)]\\n  \t\t\tline.extend(['.' for _ in xrange(C - (M % C))])\\n  \t\telse:\\n  \t\t\tline = ['*' for _ in xrange((M % C) - 1)]\\n  \t\t\tline.extend(['.' for _ in xrange((C - (M % C)) + 1)])\\n  \t\t\tflag = True\\n  \t\tres.append(line)\\n  \t\tindex = len(res)\\n  \t\tres.extend([['.' for _ in xrange(C)] for __ in xrange(R - len(res))])\\n  \t\tif flag:\\n  \t\t\tres[index][0] = '*'\\n  \t\tres[-1][-1] = 'c'\\n  \t\tassert len(res) == R\\n  \t\tassert len(res[0]) == C\\n  \t\treturn res\\n  \telse:\\n  \t\tres = [['*' for _ in xrange(C)] for __ in xrange(R - 3)]\\n  \t\tM -= (R - 3) * C\\n  \t\ttmp = three_line_builder(3, C, M)\\n  \t\tif len(tmp) != 3: # error msg\\n  \t\t\treturn tmp\\n  \t\tres.extend(tmp)\\n  \t\treturn res\\n  \t\\n  def solve(R, C, M):\\n  \tres = None\\n  \t\\n  \tif M == R * C:\\n  \t\treturn 'Impossible'\\n  \tif R >= 3 and C >= 3:\\n  \t\tif R*C - M in [7, 5, 3, 2]:\\n  \t\t\treturn 'Impossible'\\n  \t\treturn over_three_line_builder(R, C, M)\\n  \t\t\\n  \telif R != 1 and C != 1:  #which means one of them is 2, and the other not 1\\n  \t\tif (R*C - M) % 2 == 1:\\n  \t\t\tif M < R*C - 1:\\n  \t\t\t\treturn 'Impossible'\\n  \t\tif M + 2 == R * C:\\n  \t\t\treturn 'Impossible'\\n  \t\telse:\\n  \t\t\tif R == 2:\\n  \t\t\t\treturn two_line_builder(R, C, M)\\n  \t\t\telse:\\n  \t\t\t\ttmp = two_line_builder(C, R, M)\\n  \t\t\t\treturn conj_mat(tmp)\\n  \t\\n  \telse:\t\t\t\t\t#which means one of them is 1\\n  \t\tif R == 1:\\n  \t\t\treturn one_line_builder(R, C, M)\\n  \t\telse:\\n  \t\t\ttmp = one_line_builder(C, R, M)\\n  \t\t\treturn conj_mat(tmp)\\n  \t\t\\n  \treturn res\\n  \\n  def mat_to_str(a):\\n  \tif a in ['Impossible', 'Not Implemented']:\\n  \t\treturn a\\n  \tstr_out = ''\\n  \tfor row in a:\\n  \t\tfor elem in row:\\n  \t\t\tstr_out += elem\\n  \t\tstr_out += '\\n'\\n  \treturn str_out[:-1]\\n  \t\\n  def calc_result(case):\\n  \tresult = None\\n  \t\\n  \tR = int(case[0])\\n  \tC = int(case[1])\\n  \tM = int(case[2])\\n  \tprint R, C, M\\n  \t\\n  \tresult = solve(R, C, M)\\n  \t\\n  \tstr_out = mat_to_str(result)\\n  \tm = str_out.count('*')\\n  \tassert (m==0 or m==M)\\n  \tprint str_out\\n  \t\\n  \treturn '\\n%s' % str_out\\n  \\n  def main(filepath):\\n  \tstart_time = time.time()\\n  \twith file('output.txt', 'wb') as f_out:\\n  \t\t\\n  \t\tfor case_index, case in iterate_cases_1lpc(filepath):\\n  \t\t\t\\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\\n  \t\t\tresult = calc_result(case)\\n  \t\t\t\\n  \t\t\tf_out.write(\"Case #%d: %s\\n\" % (case_index, result))\\n  \t\t\t\t\\n  if __name__ == '__main__':\\n  \tmain(sys.argv[1])\\n", "target": "28", "substitutes": {"filepath": ["filename", "reportname", "reportfile", "reportpath", "ffile", "fdir", "filedir", "fname", " filefile", " filename", "reportdir", " filedir", "fpath", "filefile"]}}
{"code": "\\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      t = int(f.readline())\\n      for _t in range(t):\\n  \\n          C, F, X = [float(x) for x in f.readline().split()]\\n  \\n          base = X / 2.0\\n  \\n          new_strategy = old_strategy = base\\n          time_building = 0\\n          farms = 0\\n          fastest_speed = 2\\n          while new_strategy <= old_strategy:\\n              old_strategy = new_strategy\\n              time_building += C / fastest_speed\\n              farms += 1\\n              fastest_speed += F\\n              new_strategy = time_building + X / fastest_speed\\n              \\n          \\n          print (\"Case #\" + str(_t+1) + \": \" + str(old_strategy))\\n      \\n  \\n", "target": "29", "substitutes": {"f": ["ef", "s", "conf", "af", "file", "cf", "input", "w", "g", "n", "ft", "l", "sf", "fx", "c", "fs", "h", "bf", "fb", "e", "iter", "fl", "r", "tf", "elf", "b", "fc", "fo", "o", "fg", "uf", "alf", "v", "fd", "fr", "feed", "p", "d", "fp", "df", "fm", "i", "lf"], "fn": ["nm", "cmd", "file", "np", "cf", "dn", "that", "typ", "pen", "n", "mn", "orth", "bf", "txt", "rn", "fs", "full", "fin", "function", "ns", "fl", "fc", "unc", "path", "obj", "phy", "fun", "nt", "sn", "bn", "filename", "syn", "FN", "nil", "ln", "fd", "fr", "cn", "fp", "fm", "lf"], "t": ["ti", "ty", "ta", "ties", "to", "y", "tr", "m", "g", "tw", "n", "l", "total", "index", "c", "z", "tm", "tp", "k", "qt", "q", "r", "time", "tt", "b", "tu", "T", "j", "v", "ts", "te", "trial", "dt", "p", "d", "ct", "tc", "i", "ot"], "_t": [" _y", "\tta", "___dt", "_ta", "_tr", "_n", "___y", "_dt", "\ttc", " _n", "_y", "\ttr", "___t", "_tc", " _dt", "___n"], "C": ["V", "CS", "Base", "CI", "P", "Time", "CNN", "CC", "CO", "Y", "N", "M", "FC", "B", "c", "CM", "D", "CF", "CB", "Cs", "H", "K", "CE", "CT", "T", "A", "Cal", "I", "R", "E", "S", "L", "CON", "Con", "Co"], "F": ["V", "G", "W", "P", "J", "Time", "FW", "FR", "FS", "Fs", "Y", "N", "M", "FC", "O", "B", "D", "CF", "H", "K", "T", "A", "I", "R", "E", "S", "FG", "L", "U", "Q", "Z", "FF", "FE"], "X": ["V", "G", "W", "P", "Time", "J", "TX", "FX", "XY", "Y", "N", "M", "FC", "EX", "B", "D", "XL", "H", "IX", "XX", "T", "A", "DX", "I", "R", "E", "S", "L", "U", "UX", "XP", "Q", "Z", "ZX", "XXX", "FE"], "x": ["mx", "ax", "y", "xs", "xt", "xe", "xd", "xi", "xp", "n", "ix", "xa", "fx", "ext", "z", "name", "xy", "e", "rx", "xes", "px", "xf", "xx", "cross", "dx", "wx", "v", "ox", " ax", "ex", "rex", "nex", "ux", "p", "xc", "i", "tx"], "base": ["Base", "core", "size", "y", "prime", "m", "n", "total", "index", "beta", "B", "bf", "c", "based", "buffer", "unit", "root", "initial", "reset", "change", "time", "b", "score", "fa", "start", "fact", "cpu", "ASE", "chain", "v", "ase", "prefix", "weight", "scale", "type", "p", "name", "create", "max"], "new_strategy": ["new_grativity", "new_strativity", "new_rategic", "new_stronent", "new_trateg", "new_tracker", "new_racker", "new_grategic", "new_trategy", "new_rategy", "new_rateg", "new_keyonent", "new_ronent", "new_trategic", "new_rativity", "new_keyateg", "new_grateg", "new_drategy", "new_grategy", "new_gronent", "new_keyategy", "new_keyategic", "new_Strategic", "new_drategic", "new_gracker", "new_strategic", "new_drativity", "new_Strateg", "new_strateg", "new_drateg", "new_Strategy", "new_stracker"], "old_strategy": ["old_trategic", "old_STRator", "old_gracker", "old_designategic", "old_rator", "old_strativity", "old_Strativity", "old_grategy", "old_strator", "old_stristics", "old_STRategic", "old_gristics", "old_grateg", "old_Strategic", "old_rategy", "old_STRategy", "old_stativity", "old_stategic", "old_grativity", "old_designistics", "old_Stristics", "old_strategic", "old_Strateg", "old_stracker", "old_rategic", "old_trategy", "old_strateg", "old_stateg", "old_Strategy", "old_trativity", "old_stategy", "old_designategy", "old_grator", "old_grategic", "old_racker", "old_rativity", "old_STRateg", "old_designateg", "old_tracker", "old_rateg"], "time_building": ["time_running", " time_loading", " time_boxing", "time10ring", "time2loading", " time_running", "time__building", "time2building", "time_loading", "time2builder", " time10building", "time_build", " time_ring", "time101building", "time101boxing", "time101ring", "time___building", "time_living", "date_build", "date_building", "time_builder", " time10running", "time10running", "time___including", "time___build", " time_builder", "time101running", " time10ring", "time_ring", "time10building", "time__boxing", "date_living", "date_including", " time10boxing", "time__running", "time_boxing", "time2ring", "time_including", "time10boxing", "time__ring", "time___living"], "farms": ["tfarms", "farm", "fars", "fairs", "marts", "mairs", "sfarts", "Farms", "tfars", "fastairs", "Farts", "Fairs", "Farm", "tfarm", "marmed", "sfarms", "tfairs", "fastars", "fastarms", "fastarm", "marms", "sfairs", "Fars", "Farmed", "sfarmed", "farmed", "farts"], "fastest_speed": ["fastEST_weight", "fastest_time", "fastest_Speed", "fastestfulspeed", "fastEST_Speed", "fastestfulstrength", "fastestfulweight", "fastEST_speed", "fastgest_weight", "fastgest_speed", "fastest_loss", "fastest_weight", "fastest_strength", "fastest_length", "fastgest_strength", "fastestfulloss", "fastgest_loss", "fastEST_time", "fastEST_length"]}}
{"code": "\\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      t = int(f.readline())\\n      for _t in range(t):\\n  \\n          R, C, M = [int(x) for x in f.readline().split()]\\n          free_spots = R * C - M - 1\\n  \\n          if M == 0:\\n              answer = [[\".\" for x in range(C)] for y in range(R)]\\n              answer[0][0] = \"c\"\\n          elif R == 1:\\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\\n          elif C == 1:\\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\\n              answer = zip(*answer[::-1])\\n          elif free_spots >= 3: # and M % R >= 2:\\n              answer = [[\"*\" for x in range(C)] for y in range(R)]\\n              answer[0][0] = \"c\"\\n              answer[0][1] = \".\"\\n              answer[1][1] = \".\"\\n              answer[1][0] = \".\"\\n              free_spots -= 3\\n              tr, br, c = 0, 1, 2\\n              if c >= C:\\n                  tr, br, c = 2, 3, 0\\n              for _i in range(free_spots):\\n                  if answer[tr][c] == \"*\":\\n                      answer[tr][c] = \".\"\\n                  elif answer[br][c] == \"*\":\\n                      answer[br][c] = \".\"\\n                      if c < C-1:\\n                          c+=1\\n                      else:\\n                          tr, br = tr + 2, br + 2\\n                          c = 0\\n                          if br == R:\\n                              br, tr = br-1, tr-1\\n                  \\n          else:\\n              answer = [\"Impossible\",]\\n  \\n          \\n          \\n          print (\"Case #\" + str(_t+1) + \":\")\\n          for _i in answer:\\n              print \"\".join(_i)\\n      \\n  \\n", "target": "29", "substitutes": {"f": ["fed", "af", "file", "cf", "input", "w", "g", "n", "ft", "l", "sf", "c", "fs", "h", "bf", "fb", "e", "iter", "r", "q", "tf", "elf", "b", "fc", "fo", "o", "fa", "fg", "xf", "alf", "v", "F", "fw", "fd", "fr", "open", "feed", "p", "d", "fp", "df", "fm", "lf"], "fn": ["nm", "kl", "nu", "file", "cf", "dn", "typ", "fil", "pen", "n", "mn", "bf", "txt", "rn", "fs", "rm", "full", "fin", "function", "ns", "nl", "fl", "tf", "orig", "fc", "unc", "path", "o", "obj", "fun", "nt", "sn", "ff", "hn", "wl", "filename", "syn", "FN", "nil", "ln", "fd", "fr", "ct", "fp", "fm", "lf", "nc"], "t": ["ti", "int", "ty", "ta", "to", "ties", "w", "tr", "g", "tw", "n", "it", "l", "total", "c", "z", "tm", "tp", "e", "vt", "r", "time", "tt", "tu", "T", "v", "ts", "te", "dt", "p", "tz", "tc", "i", "ot"], "_t": ["_n", " _T", "_r", " _n", "_T", " _r"], "R": ["V", "RS", "G", "P", "RE", "ER", "W", "J", "Y", "RG", "N", "B", "MR", "RF", "GR", "Rs", "D", "RA", "r", "BR", "H", "SR", "RM", "T", "A", "RT", "I", "RO", "X", "E", "S", "RR", "L", "F", "CR", "Res", "TR", "Q"], "C": ["V", "CS", "G", "CV", "P", "W", "CNN", "COR", "CC", "Cr", "CO", "Y", "N", "O", "CL", "MC", "B", "CM", "c", "D", "CB", "Ch", "Cs", "H", "K", "CE", "You", "CT", "T", "CU", "A", "Charlie", "I", "X", "E", "CP", "Cache", "S", "Cons", "L", "F", "CR", "CON", "Q", "WC", "Co"], "M": ["V", "G", "MAN", "W", "P", "MT", "J", "Y", "N", "O", "Mc", "MC", "B", "CM", "MR", "D", "H", "MU", "MI", "Me", "Maker", "T", "RM", "I", "X", "S", "L", "F", "Mi", "Q", "TM", "MS", "MM", "Z", "MA", "DM", "AM"], "x": ["mx", "ax", "xs", "w", "xt", "xe", "at", "on", "xml", "yx", "xi", "xp", "n", "l", "ix", "xa", "fx", "lat", "c", "h", "z", "name", "xy", "k", "e", "_", "xb", "\u00e7", "q", "xes", "co", "px", "ey", "xf", "zx", "X", "mut", "xx", "cross", "dx", "wx", "v", "ox", " ax", "yi", "ex", "rex", "p", "ct", "tx", "ux", "ma", "xc", "i", "rx"], "free_spots": ["free1storeents", "free_prots", "free_snapics", "free_spaceot", "free1spots", "free_storeots", "free_splices", "free_spices", "free_Spotes", "free1spics", "free_spics", "free1spotic", "free_spaceents", "free_sploms", "free1storeot", "free_staticots", "free_staticics", "free_Spots", "free_bspices", "free_storeot", "free_snapaces", "free_spoms", "free1snapaces", "free_spents", "free_storeents", "free1snapots", "free_pot", "free_pots", "free_spicks", "free1snaprots", "free_spaceots", "free_spotes", "free_spaces", "free1storeotic", "free1spaces", "free1storeots", "free_snapots", "free_Spaces", "free_poms", "free_paces", "free_splotes", "free_pices", "free_potes", "free_spaceotic", "free_shots", "free1snapics", "free_staticrots", "free_spotic", "free_snaprots", "free_splot", "free_splaces", "free_splots", "free_pics", "free1spot", "free1spents", "free_spot", "free_bspot", "free_storeotic", "free_bspots", "free_shot", "free1sprots", "free_picks", "free_shents", "free_bspicks", "free_staticaces", "free_sprots", "free_Spoms", "free_shotic", "free_splicks"], "answer": ["interpret", "Answer", "ell", "range", "result", "message", "say", " Answer", "ue", "do", "urn", "zip", "search", "ze", "accept", "archive", " unanswered", "place", "test", "window", "order", "vote", "option", "query", "e", "set", "vert", "response", "ve", "sequence", "reply", "entry", "record", "q", "wer", "don", "said", "see", "cho", "section", "answered", "cache", "oe", "offer", "field", "remember", "question", "consider", "equ", "rep", "list", "turn", "position", "issue", "install", "next", "rez", "iterator", "array", "ee", "eni", "era", "expression", "queue", "form", "be"], "y": ["my", "mx", "ay", "yu", "ys", "w", "on", "Y", "yd", "yt", "z", "yn", "xy", "e", "yy", "re", "ye", "im", "o", "ey", "yr", "ry", "cy", "yi", "yer", "ym", "yl", "ho"], "m": ["sm", "mx", "em", "ms", "w", "on", "mn", "l", "c", "h", "z", "mt", "mm", "man", "q", "um", "ml", "im", "am", "pm", "perm", "mut", "v", "md", "gm", "ym", "me", "cm", "ct", "d", "ma", "xc"]}}
{"code": "def solve_case(t):\\n      c, f, x = [float(num) for num in raw_input().strip().split()]\\n      current_time_usage = x / 2.0\\n  \\n      n = 1\\n      build_farm_time = c / (2.0 + float((n - 1) * f))\\n      attemp_time_usage = (x / (2.0 + float(n * f))) + build_farm_time\\n  \\n      while attemp_time_usage < current_time_usage:\\n          current_time_usage = attemp_time_usage\\n  \\n          n += 1\\n          build_farm_time += c / (2.0 + float((n - 1) * f))\\n          attemp_time_usage = (x / (2.0 + float(n * f))) + build_farm_time\\n  \\n      print 'Case #%d: %.7f' % (t, current_time_usage,)\\n  \\n  def main():\\n      t = int(raw_input().strip())\\n      for i in range(1, t + 1):\\n          solve_case(i)\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "target": "30", "substitutes": {"t": ["ti", "s", "title", "rt", "ty", "ta", "tz", "y", "at", "m", "g", "st", "it", "l", "total", "test", "tp", "e", "k", "id", "pt", "r", "q", "time", "tt", "b", "tu", "T", "o", "j", "tip", "ten", "v", "ts", "te", " T", "dt", "type", "p", "d", "ct", "tick", "h", "tc", "ot"], "c": ["cs", "cp", "cont", "ch", "y", "u", "cf", "w", "m", "l", "com", "C", "ac", "con", "mc", "e", "r", "lc", "co", "b", "fc", "o", "cos", "ce", "v", "xc", "cu", "ex", "cm", "ci", "d", "ct", "p", "cn", "h", "tc", "cd", "cc"], "f": ["fed", "s", "af", "fff", "cf", "w", "m", "g", "fac", "l", "float", "fx", "bf", "fs", "z", "h", "full", "fb", "e", "fl", "fort", "tf", "r", "fc", "fa", "fg", "xf", "j", "rf", "fi", "ff", "v", "flow", "F", "fd", "fr", "p", "d", "all", "fp", "df", "fm"], "x": ["ax", "y", "ic", "cf", "xs", "xt", "xe", "xml", "xi", "xp", "l", "ix", "xa", "fx", "z", "xy", "e", "rx", "r", "b", "fc", "xf", "X", "xx", "wx", "v", "ox", "ex", "p", "ct", "ux", "a", "h", "xc", "tx"], "num": ["nm", "nu", "np", "gpu", "mult", "umber", "nam", "bid", "index", "digit", "NUM", "umer", "Num", "unit", "uno", "hex", "um", "uni", "number", "alph", "na", "umn", "bum", "sel", "ker", "fn", "umi", "filename", "nom", "nil", "mon", "conv", "coord", "node", "tim", "ident", "sum", "ord", "name", "enum"], "current_time_usage": ["current_current_free", "current_Time_limit", "current_time_slot", "current_time_limit", "current_time_time", "current_time_used", "current_Time_Usage", "current_current_time", "current_current_usage", "current_current_slot", "current_time_Usage", "current_Time_free", "current_time_free", "current_time_using", "current_Time_using", "current_Time_used", "current_Time_usage"], "n": ["nb", "s", "nm", "nu", "names", "np", "y", "note", "ul", "len", "u", "new", "on", "m", "g", "it", "network", "current", "mn", "N", "nr", "l", "en", "long", "index", "non", "ns", "nl", "nn", "r", "ne", "norm", "o", "na", "j", "nt", "sn", "fn", "v", "net", "next", "cn", "p", "d", "all", "name", "nc"], "build_farm_time": ["build_farm8sequence", "build_farm__Time", "build_app_sequence", "build_farm_file", "build_app_duration", "build_app8sequence", "build_app8duration", "build_farm__file", "build_sector_Time", "build_farm8time", "build_app8time", "build_sector_mode", "build_farm_t", "build_farm_sequence", "build_farm_mode", "build_farm_Time", "build_farm__time", "build_sector_time", "build_sector_file", "build_farm_duration", "build_farm__mode", "build_farm_times", "build_app_time", "build_farm8duration"], "attemp_time_usage": ["attemp_time_efficiency", "attemp_time_value", "attemp_Time_Usage", "attemp_Time_value", "attemp_time_using", "attemp_time_growth", "attemp_time_volume", "attemp_Time_using", "attemp_time_used", "attemp_time_use", "attemp_Time_used", "attemp_Time_growth", "attemp_Time_usage", "attemp_time_Usage"], "i": ["ti", "int", "ini", "y", "ic", "pi", "li", "m", "xi", "it", "index", "iri", "bi", "z", "zi", "id", "hi", "ij", "ai", "b", "I", "si", "j", "mi", "qi", "v", "di", "gi", "ip", "ii", "p", "ci", "d", "h"]}}
{"code": "class Sweeper(object):\\n      def __init__(self, r, c, m):\\n          self.matrix = [['.' for j in range(0, c)] for i in range(0, r)]\\n          self.matrix[0][0] = 'c'\\n  \\n          self.r = r\\n          self.c = c\\n          self.m = m\\n          self.current_r = r\\n          self.current_c = c\\n          self.current_m = m\\n  \\n      def fill_row(self):\\n          if self.current_r >= 3 and self.current_m >= self.current_c:\\n              for i in range(0, self.current_c):\\n                  self.matrix[self.current_r - 1][i] = '*'\\n              self.current_r -= 1\\n              self.current_m -= self.current_c\\n              return True\\n          return False\\n  \\n      def fill_col(self):\\n          if self.current_c >= 3 and self.current_m >= self.current_r:\\n              for i in range(0, self.current_r):\\n                  self.matrix[i][self.current_c - 1] = '*'\\n              self.current_c -= 1\\n              self.current_m -= self.current_r\\n              return True\\n          return False\\n  \\n      def fill_partial(self):\\n          if self.current_r >= 3:\\n              fill_num = min(self.current_m, self.current_c - 2)\\n              for i in range(0, fill_num):\\n                  self.matrix[self.current_r - 1][self.current_c - 1 - i] = '*'\\n              self.current_m -= fill_num\\n              if fill_num > 0:\\n                  self.current_r -= 1\\n          if self.current_c >= 3:\\n              fill_num = min(self.current_m, self.current_r - 2)\\n              for i in range(0, fill_num):\\n                  self.matrix[self.current_r - 1 - i][self.current_c - 1] = '*'\\n              self.current_m -= fill_num\\n              if fill_num > 0:\\n                  self.current_c -= 1\\n          if self.current_m > 0:\\n              return False\\n          else:\\n              return True\\n  \\n      def fill_special_one(self):\\n          if self.current_r * self.current_c == self.current_m + 1:\\n              for i in range(0, self.current_r):\\n                  for j in range(0, self.current_c):\\n                      self.matrix[i][j] = '*'\\n              self.matrix[0][0] = 'c'\\n              self.current_r = 0\\n              self.current_c = 0\\n              self.current_m = 0\\n              return True\\n          return False\\n  \\n      def fill_special_col(self):\\n          if self.current_c == 1 and self.current_r > self.current_m:\\n              for i in range(0, self.current_m):\\n                  self.matrix[self.current_r - 1 - i][0] = '*'\\n              self.matrix[0][0] = 'c'\\n              self.current_m = 0\\n              self.current_r = 0\\n              self.current_c = 0\\n              return True\\n          return False\\n  \\n      def fill_special_row(self):\\n          if self.current_r == 1 and self.current_c > self.current_m:\\n              for i in range(0, self.current_m):\\n                  self.matrix[0][self.current_c - 1 - i] = '*'\\n              self.matrix[0][0] = 'c'\\n              self.current_m = 0\\n              self.current_r = 0\\n              self.current_c = 0\\n              return True\\n          return False\\n  \\n  def print_matrix(matrix):\\n      for row in matrix:\\n          s = ''\\n          for col in row:\\n              s += col\\n          print s\\n  \\n      \\n  def solve_case(t):\\n      r, c, m = [int(num) for num in raw_input().strip().split()]\\n      sweeper = Sweeper(r, c, m)\\n      print 'Case #%d:' % (t,)\\n      if sweeper.fill_special_one() or sweeper.fill_special_col() or sweeper.fill_special_row():\\n          print_matrix(sweeper.matrix)\\n          return\\n      f_result = True\\n      while sweeper.current_m > 0 and f_result:\\n          f_result = False\\n          f_result |= sweeper.fill_row()\\n          f_result |= sweeper.fill_col()\\n      if sweeper.current_m > 0:\\n          sweeper.fill_partial()\\n      if sweeper.current_m > 0:\\n          print 'Impossible'\\n      else:\\n          print_matrix(sweeper.matrix)\\n  \\n  def main():\\n      t = int(raw_input().strip())\\n      for i in range(1, t + 1):\\n          solve_case(i)\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "target": "30", "substitutes": {"self": ["disk", "conf", "complete", "quick", "small", "conn", "spec", "req", "gh", "comp", "attr", "cl", "full", "query", "proc", "tmp", "_", "resp", "table", "q", "mix", "mem", "shape", "path", "sw", "start", "diff", "output", "ae", "thus", "attribute", "warning", "ih", "math", "debug", "right", "api", "exc", "method", "me", "eff", "console", "instance", "log", "tx", "also", "book", "json", "ial", "w", "changes", "details", "sql", "history", "xml", "views", "agg", "com", "txt", "util", "event", "client", "entry", "default", "el", "change", "axy", "term", "rec", "se", "results", "close", "about", "html", "res", "esh", "sis", "news", "md", "terms", "before", "show", "print", "args", "wh", "replace", "page", "them", "p", "parent", "h", "name", "own", "form", "func", "eth", "asm", "short", "help", "urn", "chart", "new", "sp", "ren", "lex", "what", "this", "load", "py", "body", "where", "soc", "response", "get", "auto", "mp", "time", "go", "context", "rem", "ref", "review", "by", "add", "private", "raw", "nt", "github", "model", "you", "coll", "open", "select", "next", "part", "final", "hw", "my", "expr", "result", "python", "data", "sys", "compl", "cmd", "subject", "here", "empty", "series", "th", "public", "work", "view", "dev", "Self", "par", "test", "other", "local", "user", "system", "app", "config", "ready", "hi", "group", "make", "var", "\u00e4", "block", "serial", "cho", "obj", "template", "request", "space", "rel", "sect", "cache", "ssl", "info", "pkg", "through", "params", "good", "look", "ws", "cmp", "ln", "old", "error", "both", "graph", "all", "your", "item", "dd"], "r": ["range", "hr", "rt", "cr", "dr", "rid", "w", "tr", "f", "g", "rate", "n", "ru", "l", "nr", "rd", "rm", "sr", "e", "rs", "re", "ir", "rb", "b", "ro", "br", "ra", "ar", "ur", "R", "rc", "res", "mr", "v", "x", "er", "p", "d", "rar", "a", "h"], "c": ["cs", "conf", "cr", "cp", "ch", "cf", "u", "f", "cin", "n", "l", "com", "C", "ac", "con", "ec", "mc", "e", "dc", "co", "lc", "category", "b", "cur", "cos", "ce", "rc", "cache", "v", "cat", "cu", "ca", "cb", "cm", "ci", "cd", "ct", "d", "p", "h", "tc", "cn", "cc"], "m": ["em", "bm", "mk", "ms", "u", "w", "ma", "f", "g", "n", "M", "l", "mat", "z", "rm", "mt", "tm", "e", "mc", "mm", "mu", "q", "b", "um", "o", "am", "mi", "mr", "v", "gm", "cm", "p", "d", "a", "h"], "matrix": ["scherix", "tmmat", "atrices", "manmat", "scherie", "dimrix", "macrix", "mutMatrix", "catMatrix", "tmtable", "matrie", "matpack", "tmrices", "schepack", "mattable", "dimMatrix", "mmat", "scheprint", " matprint", "mMatrix", "moduleMatrix", "attable", "matmat", "mrix", "mprint", "transtable", "modulerie", "mrices", "manrices", "catrices", "macrices", "catrix", "transrices", "scheMatrix", " matMatrix", "modulepack", "matrices", "transrix", "mutrices", "matprint", "mutrix", "modulerix", "tmrix", " matpack", " matrices", "matMatrix", "dimrices", "atrix", "transmat", "scherices", "macmat", " matrie", "atmat", "manrix"], "j": [" cs", " ni", " di", " cc", "ic", " ja", " mi", " ca", "n", "ix", " cu", " chi", " cx", " iii", "zi", "ij", " ic", "jc", "q", " il", " ch", " bi", " vi", "ji", " Xi", " li", "ei", "oj"], "i": ["ki", "ti", "ori", "iy", "ini", "y", "ic", "cli", "u", "ind", "pi", "li", "xi", "n", "it", "ix", "index", "l", "il", "iri", "z", "e", "k", "zi", "id", "ij", "iu", "hi", "ir", "ai", "b", "phi", "im", "o", "ri", "I", "si", "mi", "ski", "ui", "fi", "v", "x", "ia", "er", "ik", "di", "gi", "yi", "ih", "ip", "ii", "me", "ci", "p", "iti", "ji", "h", "ei", "oi"], "current_r": ["reported_rc", "currentptmr", "this___p", "current_e", "current64dr", "current__row", "current8raw", "current00r", "currentlyedp", "current___n", "active_m", "current___t", "current1h", "currently_i", "currentedmr", " currentedrd", "current_n", "this_fr", "current0r", "current__ir", "current_u", "current1t", "current8c", "currentedrect", "running8c", "reported_ro", "active_i", "current8p", "currently_row", "active_e", "current__ro", "currentptrd", "complete_r", "complete1t", "this_p", " current_mr", "currentjp", "currentcurrentp", "complete_t", "currentcurrentu", "running_ir", "currentptrect", "currentedi", "current_ir", "current___rect", "current0sr", "current8m", "this_ro", "current___r", "currently_l", "current__i", " current_rd", "current___fr", " currentedrect", "current___rt", "currentcurrentl", "reported_p", "current_fr", "current64rc", "reported__h", "current__t", "currentedrd", "current_re", "currentcurrentc", "currently_p", "currentlyedr", "reported_sr", "running_r", "current__m", "running_c", "current__e", "current_rect", "complete_rc", "current_dr", "currently_r", "current_ro", "reported_rg", "reported_c", "currentjm", "current_sr", "this___r", "current_i", "current__rc", "current64c", "current8ir", "currently_u", "reported_h", "current64r", "current_p", "current8r", "currentcurrenti", "current_l", " current_rect", "current_rc", "current1ro", "current_row", "reported_row", "current___ro", "currentcurrentrow", "currentcurrentr", "current1c", "current_h", "currentlyedu", "currentjraw", "current0c", "reported_re", "running8r", "current00ro", "current__c", "current___rd", "current_t", "current__r", "current___p", "current00m", "reported__r", "this___ro", "current_rg", "complete_ro", "complete1rc", "currentjr", "complete1ro", "reported_m", "reported_raw", "current_mr", " currentedr", "currentedp", "currentlyedi", "active_r", "reported_r", "reported_dr", "reported__c", "currentptr", "this___fr", "this_r", "current0re", "current1r", "current___mr", "current1row", "reported__row", "currentedr", "running8ir", "current_raw", "current___rc", "complete1r", "current_rt", "reported_n", "current_rd", "current__h", "currentedu", "reported_rt", "current00rg", "currently_c", "current1rc", " currentedmr"], "current_c": ["client_m", "reported_rc", "current__p", "g", "client_c", "currently__p", "current__cs", "current_lc", "currentSetcf", "current__co", "_", "currently2sc", "reported_cur", "reported_cu", "current5cs", "current2cs", "reported_tc", "currently__c", "currently_sc", "current5sc", "reported__m", "current_cp", "currentablecu", "currently2m", "currently__m", "present_cp", "current5c", "reported_cm", "current1cp", "current_ce", "reported_mc", "w", "current64b", "present_cy", "currentSetc", "currentabletc", "current_cy", "currently_co", "currentSetcache", "current_cache", "current_cur", "current2c", "reported__rc", "current_g", "currentSetm", "currently_p", "current_con", "reported_g", "current__cl", "current64m", "current__m", "current_cm", "current64l", "current_cu", "currentablecm", "current__l", "current64g", "current5m", "reported_lc", "current2sc", "current_sc", "reported_c", "current__cy", "current2mc", "current__rc", "current64c", "n", "current__cp", "current_p", "reported_l", "current_l", "current_rc", "current_tc", "currently2c", "reported_b", "current1c", "current__cur", "current__c", "reported_ce", "client_cf", "currently__co", "currentablec", "current_mc", "reported_cs", "ic", "currently_m", "current_co", "currently_cs", "reported_m", "current_b", "current_cl", "reported_r", "reported__c", "reported__cp", "current64con", "present_c", "currently2cs", "current1m", "reported_cp", "current2r", "current_cs", "current_cf", "client_cache", "reported_cl", "current2m", "present_p", "reported_con", "currently_c", "cm", "current1rc", "current64cur"], "current_m": [" current_mid", "currentxperm", "current__p", "current_e", "currentxm", "current_dm", "next_c", "reported_e", " current_mt", "current_mid", "current_man", "current_n", "current_v", "current64mat", "current_rm", "reported_rm", "current5c", "current11m", "reported_perm", "reported_cm", "reported_mc", "current_me", "currentJmt", "current__man", "current11mt", "currentptc", "current00c", "currentJm", "currentptm", "current64n", "cur_m", "currentptmc", "current64m", "next_m", "current_cm", "current__m", "current__e", "current__l", "current5m", "cur_r", "reported_c", "currentxc", "current11c", "current64c", "current_mt", "currentJr", "current_p", "cur_mt", "reported_v", "reported_l", "current_l", "currently_n", "currentptdm", "current00me", "currentJc", "current__perm", "current5rm", "current__c", "current_perm", "currently_mat", "current00m", "cur_c", "current_mc", "current__r", "reported_me", "current5me", "current11mid", "currently_m", "reported_dm", "reported_m", "current00rm", "reported_r", "currentxe", "current_mat", "next_p", "currently_c", "next_man"], "fill_num": ["fill_mean", "fill2min", " fill_nom", " fill_rat", "fill10mon", "fill2num", "filllysum", "fill_mun", "fill_cum", " fill_number", "fill2nam", " fill_nm", "fill67mun", "fill2nu", "fill_nu", " fill_nam", "fillsetalph", "fill67mean", "kill_nam", "fill67nom", "train_num", "trainsetmun", "fill7num", "fill8eng", "train_mean", "replace10mon", "replace_nam", "replace10num", "fill10nam", " fill_min", "filllynm", " fill2num", "fill_min", "fill67nam", "replace_num", "replace10number", "fill67min", "replace_number", "trainsetalph", "fill10num", "train_mun", "fill_nam", " fill2nu", "fillsetmun", "fill8mon", "fill10number", " fill_buf", " fill_sum", "fill_buf", "fill_number", "fill67nu", "fill_rat", "fill1mon", "fill7mon", "fill_mon", " fill_eng", "fillsetnum", "fill_alph", "train_alph", "fill_nom", "kill_mon", "replace10nam", " fill2min", "fill2mon", "fill8num", "fill67eng", " fill_cum", "kill_sum", "filllyrat", "fill_sum", " fill_mon", "fill7nu", "fill7min", "fill67mon", "filllynumber", "fill1number", "fill_nm", "fillsetmean", "fill1nam", "fill8nam", " fill2mon", "filllycum", "replace_mon", "fill2sum", "filllynam", "trainsetnum", "fill67alph", "fill_eng", "kill_num", "fill67buf", "fill67num", "filllynum", "fill1num", "trainsetmean", " fill_nu"]}}
{"code": "__author__ = 'jrokicki'\\n  \\n  RL = lambda: sys.stdin.readline().strip()\\n  IA = lambda: map(int, RL().split(\" \"))\\n  LA = lambda: map(long, RL().split(\" \"))\\n  FA = lambda: map(float, RL().split(\" \"))\\n  \\n  T = int(sys.stdin.readline())\\n  \\n  for CASE in range(T):\\n      C,F,X = FA()\\n      tick = 2.\\n      answer = X/tick\\n  \\n      game = 0\\n      while True:\\n          span = C / tick\\n          tick += F\\n          test = game + span + X/tick\\n          game = game + span\\n  \\n          if test < answer:\\n              answer = test\\n          else:\\n              if tick > X:\\n                  break\\n  \\n      print \"Case #%d: %s\" % (CASE+1, answer)\\n  \\n", "target": "31", "substitutes": {"__author__": ["__author____", "__author___", "__Author__", "___creator____", "___creator__", "___author__", "__Author_", "___creator_", "___author_", "__authors__", "__authors____", "___author____", "__Author___", "___creator___", "__Author____", "__author_", "__authors_", "__creator_", "__creator__", "__authors___", "__creator____", "___author___", "__creator___"], "RL": ["RS", "Pull", "ML", "ULL", "RB", "RG", "LP", "CL", "DL", "DIR", "RF", "YL", "FL", "XL", "BL", "OL", "RD", "LC", "SR", "RC", "LI", "VL", "PL", "ELL", "SL", "VR", "R", "RR", "DR", "LIN", "REL", "HL", "TR", "rl", "LR", "HR", "NL", "LL", "DERR", "LS", "STR", "TL", "EL"], "IA": ["III", "BI", "CI", "GI", "IC", "BA", "AA", "SI", "IG", "OTA", "II", "VI", "AI", "ICA", "MI", "IM", "ANG", " SI", "PI", "si", "EA", "IE", "CHA", "EST", "AG", "NI", "ci", "AM", "ICE"], "LA": ["WA", "BA", "AA", "PLE", "NA", "AL", "AF", "SA", "VA", "LP", "TA", "GA", "LAN", "FL", "LI", "LM", "PL", "LY", "SL", "HA", "EA", "LU", "L", "LE", "NL", "MA", "PA", "LS", "TL"], "FA": ["Answer", "FU", "AA", "GF", "PLE", "FS", "AF", "SA", "VA", "Fa", "FB", "DA", "TA", "GA", "LAN", "TF", "FL", "FD", "IF", "Fi", "DF", "UF", "AU", "HA", "FO", "FY", "CA", "FG", "LU", "LE", "FN", "Fal", "SF", "IFA", "IFE", "PF", "PA", "FE"], "T": ["V", "Test", "G", "P", "TB", "J", "TN", "t", "TG", "Y", "N", "M", "TA", "D", "TT", "TV", "K", "I", "R", "E", "TS", "S", "WT", "TION", "L", "Q", "TR", "TM", "VT", "Z", "TI", "TC", "TL"], "CASE": ["cEST", "cATCH", "BUE", "cCase", "TATCH", "BASE", "NCase", "BODE", "NASE", "CUE", "CCase", "TUE", "VUE", "TODE", "DEST", "cASE", "NEST", "CEST", "TASE", "DASE", "BATCH", "CATCH", "VASE", "VATCH", "VODE", "CODE", "DCase", "NATCH", "DATCH"], "C": ["V", "CS", "G", "CI", "P", "CC", "Y", "N", "M", "B", "c", "CM", "D", "CB", "CF", "K", "JC", "CT", "CU", "A", "I", "R", "E", "CA", "S", "U", "L", "Q", "Z", "TC", "Co", "Case"], "F": ["V", "G", "W", "FU", "P", "GF", "f", "Y", "N", "M", "FC", "O", "B", "D", "FL", "FD", "TD", "IF", "H", "K", "DF", "A", "UF", "I", "R", "Fe", "E", "FO", "S", "FG", "WF", "L", "U", "Q", "Z", "PF", "FF", "FE"], "X": ["V", "FIX", "Test", "Tx", "Answer", "G", "W", "P", "XXX", "TX", "FX", "Y", "N", "EX", "D", "XL", "FFFF", "H", "TY", "IX", "XX", "TW", "A", "DX", "I", "R", "E", "S", "L", "x", "U", "UX", "XP", "Q", "XT", "Z", "ZX", "FF", "FE"], "tick": ["timer", "click", "choice", "tag", "butt", "match", "poll", "ping", "timeout", "TX", "pe", "dig", "t", "shot", "case", "pad", "eddy", "quote", "icked", "step", "index", "yt", "trip", "switch", "text", "token", "lock", "unit", "check", "rank", "fork", "event", "tower", "stick", "time", " Tick", "quarter", "tie", "repeat", "tip", "cycle", "frame", "dx", "style", "panic", "ICK", "icker", "ox", "clock", "axis", "trial", "turn", "error", "pick", "ticket", "issue", "tim", "ick", "hit", "type", "tc", "label", "score", "tx", "beat", "td"], "answer": ["Answer", "duration", "choice", "result", "match", "message", "value", "say", "FIX", "comment", "do", "timeout", "empty", "accept", "shot", "word", "case", "n", "long", "again", "echo", "index", "TA", "window", "ask", "vote", "option", "status", "winner", "rank", "episode", "response", "sequence", "example", "version", "ANY", "energy", "time", "zero", "change", "wer", "answered", "cache", "line", "angle", "action", "remember", "TION", "question", "x", "player", "one", "turn", "command", "position", "error", "Q", "issue", "next", "val", "league", "exit", "chance", "a", "name", "record", "score"], "game": ["result", "value", "match", "power", "message", "players", "card", "size", "goal", "timeout", "bet", "Player", "g", "case", "play", "fight", "index", "GAME", "gam", "vote", "team", "status", "winner", "playing", "episode", "event", "example", "board", "state", "GUI", "time", "zero", "games", "rule", "win", "played", "field", "slot", "role", "player", "x", "CHA", "command", "sim", "PLAY", "error", "ticket", "Game", "scale", "script", "league", "chance", "score"], "span": ["duration", "match", "div", "timeout", "size", "sp", "screen", "ana", "n", "step", "index", "division", "spin", "single", "dim", "window", "team", "status", "winner", "uno", "rank", "stick", "time", "change", "shape", "number", "pan", "start", "player", "an", "num", "sim", "ticket", "error", "tim", "scale", "sum", "script", "share", "mate", "part", "tc", "button", "score"], "test": ["valid", "Test", "second", "result", "match", "tag", "est", "message", "setup", "then", "fake", "new", "prime", "feature", "case", "train", "stop", "index", "trip", "switch", "txt", "single", "this", "status", "unit", "check", "set", "sequence", "example", "task", "time", "zero", "term", "tested", "true", "ver", "fail", " Test", "split", "style", "x", "trial", "tests", "script", "val", "mate", "tc", "testing", "score"]}}
{"code": "__author__ = 'jrokicki'\\n  \\n  RL = lambda: sys.stdin.readline().strip()\\n  IA = lambda: map(int, RL().split(\" \"))\\n  LA = lambda: map(long, RL().split(\" \"))\\n  FA = lambda: map(float, RL().split(\" \"))\\n  \\n  T = int(sys.stdin.readline())\\n  \\n  def clear(R,C,b, x, y):\\n      b = b[:]\\n      n = 0\\n      for i in range(max(0,x-1), min(R,x+2)):\\n          for j in range(max(0,y-1), min(C, y+2)):\\n              if b[C*i+j] == '*':\\n                  n += 1\\n                  b = b[:C*i+j] + '.' + b[C*i+j+1:]\\n      return b, n\\n  mem = dict()\\n  def pb(R,C,b):\\n      for x in range(R):\\n          print b[x*C:x*C+C]\\n  \\n  def board(R,C,b,x,y,M,m):\\n      global mem\\n      print x\\n      key = (R,C,b,M,x,y,m)\\n      if key in mem: return mem[key]\\n      if x >= R or y >= C:\\n          mem[key] = None\\n      else:\\n          lb = b\\n          n = 0\\n          good = False\\n          for i in range(y,C):\\n              nb,nn = clear(R,C, lb, x, i)\\n              n += nn\\n              if m - n - M == 0:\\n                  mem[key] = nb\\n                  good = True\\n                  break\\n              elif m - n - M < 0:\\n                  break\\n              lb = bb\\n          mem[key] = board(R,C,bb,M,x+1,0,m-n)\\n      return mem[key]\\n  \\n  for CASE in range(T):\\n      R,C,M = IA()\\n      IMPOSSIBLE = \"Impossible\"\\n  \\n      b = \"\"\\n      cleared = R*C-M\\n      for x in range(R):\\n          b += \"*\" * C\\n      if M == R*C-1:\\n          b = \"c\" + b[1:]\\n          answer = b\\n      else:\\n          good = False\\n          x,y = 0,0\\n          q = [(b,0,0,0)]\\n          mem = {}\\n          while not good and q:\\n              board,total_cleared,x,y = q.pop(0)\\n              if (board,total_cleared,x,y) in mem:\\n                  continue\\n              mem[(board,total_cleared,x,y)] = True\\n              if x >= R: continue\\n              if y >= C:\\n                  q.append((last_board,total_cleared,x+1,0))\\n                  continue\\n              last_board = board\\n              new_board, cleared_mines = clear(R,C,last_board,x,y)\\n              total_cleared += cleared_mines\\n  \\n              if total_cleared == cleared:\\n                  good = True\\n                  last_board = new_board\\n                  q = []\\n                  break\\n              elif total_cleared - cleared == -1:\\n                  q.append((new_board,total_cleared,x,y+1))\\n                  q.append((new_board,total_cleared,x+1,0))\\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\\n              elif total_cleared > cleared:\\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\\n              else:\\n                  q.append((new_board,total_cleared,x,y+1))\\n              last_board = new_board\\n          if good:\\n              answer = last_board\\n          else:\\n              answer = None\\n      if not answer:\\n          answer = \"Impossible\"\\n      else:\\n          b = \"\"\\n          for x in range(R):\\n              b += answer[x*C:x*C+C] + \"\\n\"\\n          answer = \"c\" + b[1:-1]\\n      print \"Case #%d:\\n%s\" % (CASE+1, answer)\\n  \\n", "target": "31", "substitutes": {"__author__": ["__author____", "___Author__", "__author___", "__Author__", "___Author____", "___author__", "__authors__", "__authors____", "___author____", "__Author___", "__Author____", "___Author___", "__authors___", "___author___"], "RL": ["RS", "Pull", "ML", "WAR", "ULL", "RB", "CL", "DL", "RF", "YL", "FL", "XL", "BL", "OL", "BR", "RD", "RC", "SR", "LC", "UR", "PL", "SL", "VR", "RR", "DR", "L", "CR", "HL", "REL", " ML", "TR", "rl", "LR", "HR", "NL", "LL", "OGR", "DERR", "UL", "LS", "STR", "TL"], "IA": ["BI", "CI", "GI", "SY", "IC", "BA", "Y", "SI", "SA", "AF", "TA", "IP", "IO", "II", "IJ", "IB", "IL", "ISA", "AI", "IF", "RA", "TY", "MI", "ICA", "IM", "LI", "I", "AU", "RI", "CA", "IE", "IR", "AR", "NI", "MA"], "LA": ["LD", "ML", "BA", "AA", "SA", "LP", "DL", "TA", "LAN", "LG", "LC", "LI", "LM", "PL", "LY", "SL", "LT", "LU", "La", "LE", "L", "LR", "NL", "LL", "MA", "PA", "LS"], "FA": ["NF", "WA", "FU", "GF", "AA", "FR", "FS", "AF", "VA", "Fa", "FB", "FI", "TA", "EF", "CF", "FL", "FD", "FFFF", "fa", "HA", "FG", "FIN", "F", "FP", "FN", "IFA", "FF", "FE"], "T": ["V", "GT", "TB", "P", "J", "Time", "TN", "t", "TG", "Y", "PT", "N", "B", "TA", "TT", "TV", "TY", "CT", "TW", "I", "X", "E", "TS", "WT", "NT", "TIT", "L", "TH", "TM", "VT", "TO", "XT", "Z", "TI", "TC"], "R": ["V", "RS", "G", "RE", "P", "ER", "W", "J", "Remote", "Y", "RG", "N", "O", "Right", "B", "MR", "RF", "GR", "Rs", "D", "RA", "r", "BR", "RH", "RC", "SR", "H", "K", "RN", "RM", "Reader", "A", "RT", "I", "RO", "X", "RI", "S", "RR", "DR", "NR", "L", "F", "RW", "Rot", "CR", "U", "IR", "Res", "TR", "Q", "KR", " r", "Cor", "AR", "HR", "RP", "Z", "Rec", "Ren"], "C": ["V", "AC", "CS", "G", "CI", "CV", "P", "Chain", "IC", "J", "COR", "CNN", "CC", "Cr", "CO", "Y", "CG", "N", "CL", "O", "Count", "MC", "HC", "B", "c", "CM", "Code", "D", "CF", "YC", "CB", "Ch", "Cs", "H", "K", "JC", "CCC", "CT", "CE", "LC", "CU", "DC", "Cl", "CD", "A", "I", "Ca", "X", "EC", "CP", "E", "CA", "S", "Size", "L", "F", "CR", "CON", "Cu", "CN", "GC", "WC", "Co", "Craig", "SC"], "b": ["s", "ob", "gb", "u", "t", "Y", "g", "l", "c", "ab", "_", "bp", "bc", "E", "bit", "v", "a", "to", "bu", "B", "BB", "z", "db", "binary", "r", "reb", "sb", "cb", "p", "bg", "wb", "pb", "BA", "bo", "new", "f", "base", "bf", "bi", "fb", "body", "o", "bs", "ib", "ble", "eb", "d", "rb", "bt", "bm", "J", "bb", "bd", "br", "A", "bin", "bl", "ba", "erb", "all", "be"], "x": ["s", "mx", "int", "ty", "ax", "u", "item", "xs", "w", "xt", "on", "t", "f", "xe", "xd", "yx", "xi", "xp", "pair", "l", "ix", "xa", "index", "fx", "lex", "c", "z", "xy", "e", "k", " xx", "ic", "r", "hex", "im", "o", "ey", "xf", "X", "xx", "wx", "dx", "v", "xxxx", " X", "ox", "ex", "inx", "ctx", "p", "ct", "tx", "a", "ci", "xc", "exp", "d", "rx"], "y": ["my", "gy", "ay", "sys", "iy", "ty", "ch", "ly", "ys", "hot", "ya", "ic", "t", "oy", "Y", "g", "l", "yt", "c", "z", "yn", "ies", "py", "xy", "wy", "yy", "e", "k", "ny", "r", "ye", "axy", "im", "o", "ey", "by", "no", "yr", "v", "ry", "ox", "sy", "er", "ia", "out", "cy", "yi", "any", "ip", "col", "ym", "p", "height", "a", "h", "yl", "ot"], "n": ["s", "nm", "nu", "tn", "conn", "np", "names", "size", "w", "len", "dn", "t", "f", "g", "mn", "N", "l", "long", "nr", "en", "nor", "c", "rn", "z", "yn", "index", "none", "e", "ns", "k", "nl", "r", "ne", "o", "no", "na", "nt", "min", "sn", "fn", "count", "v", "an", "nan", "out", "ln", "num", "node", "gn", "un", "cn", "p", "d", "a", "h", "name", "nc"], "i": ["ki", "ti", "int", "iy", "ini", "ic", "u", "pi", "t", "li", "g", "ie", "xi", "it", "l", "ix", "c", "bi", "z", "ite", "e", "zi", "hi", "iu", "ij", "id", "r", "ir", "ai", "phi", "im", "o", "I", "si", "mi", "ui", "info", "v", "ia", "di", "gi", "ik", "yi", "ip", "ii", "ci", "p", "d", "a", "io", "h"], "j": ["jl", "json", "ja", "J", "jj", "ch", "ind", "t", "f", "g", "li", "ie", "kj", "it", "l", "c", "aj", "z", "js", "jp", "e", "k", "dj", "ij", "jc", "r", "pt", "o", "si", "v", "ox", "er", "out", "je", "fr", "jump", "uj", "p", "ji", "h"], "mem": ["tem", "note", "mind", "ond", "mt", "adj", "tmp", "store", "_", "resp", "norm", "hist", "erm", "reg", "link", "usage", "sum", "me", "lim", "ct", "log", "tx", "ge", "ram", "em", "cfg", "Mem", "w", "index", "txt", "db", "mc", "thread", "EM", "ret", "res", "md", "mb", "err", "f", "dem", "member", "dim", "rm", "tm", "mac", "mp", "time", "rem", "mod", "temp", "mi", "raw", "met", "tim", "tab", "med", "gram", "my", "result", "sys", "cmd", "bm", "buff", "size", " memories", "pair", "ind", " Mem", "memory", "gc", "mat", "local", "set", "ems", "mm", "man", "jac", "um", "msg", "cache", "process", "metadata", "val", "all", "display"], "M": ["V", "G", "W", "P", "MT", "bm", "J", "Multi", "Y", "N", "O", "MC", "B", "CM", "MN", "D", "H", "K", "MI", "Ms", "IM", "MD", "Me", "RM", "A", "BM", "I", "mA", "X", "E", "S", "L", "F", "U", "Mi", "My", "Q", "TM", "MS", "MM", "NM", "cm", "MA", "DM", "AM"], "m": ["nm", "sm", "em", "mx", "bm", "ms", "mo", "ma", "t", "on", "f", "g", "mn", "l", "c", "z", "tm", "mc", "k", "e", "mm", "r", "mu", "im", "o", "am", "mi", "min", "v", "an", "dm", "num", "gm", "cm", "p", "d", "h"], "key": ["tag", "ay", "note", "case", "it", "Key", "keys", "k", "check", "cond", "net", "num", "link", "sum", "type", "step", "index", "entry", "prefix", "prop", "char", "ke", "p", "name", "record", "mode", "KEY", "new", "at", "bool", "member", "rand", "option", "py", "xy", "mac", "id", "by", "ry", "te", "one", "ice", "any", "col", "next", "title", "my", "value", "bm", "pair", "phrase", "kw", "set", "ey", "number", "obj", "info", "ver", "slot", "chain", "str", "ox", "er", "code", "node", "error", "ip", "row", "val", "item"], "lb": ["wb", "bt", "ob", "ld", "lbs", "lab", "li", "bb", "l", "B", "bf", "BB", "fb", "db", "nl", "zb", "dl", "ls", "bp", "lc", "lu", "lp", "bl", "bn", "LB", "L", "ub", "sb", "ln", "lr", "rl", "pl", "cb", "eb", "lt", "la", "rb", "lo", "ll", "lf"], "good": ["valid", "sent", "important", "comment", "doc", "quick", "bad", "ind", "mad", " Good", "poor", "dev", "yes", "high", "done", "kind", "buy", "id", "ready", "broken", "clean", "acc", "msg", "win", "green", "mod", "Good", "big", "cond", "gu", "Bad", "ok", "stable", "used", "md", "bug", "low", " GOOD", "fail", "success", "debug", "best", "nice", "desc", "found", "same", "med", "dead", "score", " bad"], "nb": ["wb", "kb", "nd", "abb", "bm", "nu", "pb", "NB", "gb", "tn", "np", "bb", "nr", "bf", "nv", "bi", "fb", "db", "zb", "bd", "bj", "bl", "bn", "NR", "ib", "sb", "ble", "ln", "mb", "cb", "eb", "cn", "bg", "rb"], "nn": ["nd", "nu", "inn", "tn", "np", "dn", "nz", "bb", "mn", "nr", "nv", "rn", "yn", "ns", "nl", "ny", "ni", "kn", "ne", "nah", "NN", "na", "nt", "xx", "sn", "bn", "NR", "wn", "pn", "nan", "ln", "cb", "gn", "cn", "ll", "nc"], "CASE": ["RODE", "JCtime", "Base", "Rase", "JCase", "JCODE", "JCASE", "CODE", "Rtime", "BASE", "BODE", "Btime", "RASE", "Ctime", "Case"], "IMPOSSIBLE": ["IMPossible", "IMPOSSible", "IMSPOSSBILITY", "IMPESSIBLE", "IMPESSible", "IMPOSSBILITY", "IMPASSIBLE", "IMPESSibility", "IMSPossBILITY", "IMPossIBLE", "IMSPOSSibility", "IMPASSible", "IMSPossible", "IMSPOSSible", "IMPOSSibility", "IMPESSBILITY", "IMPASSBILITY", "IMPossibility", "IMPossBILITY", "IMSPOSSIBLE", "IMSPossIBLE", "IMSPossibility", "IMPASSibility"], "cleared": ["declanned", "cleaned", "uncleined", "declined", "uncleared", " cleaned", "uncleaned", "cleanned", "declaned", "cleined", "declared", " cleanned", "uncleanned", " cleined"], "answer": ["Answer", "result", "rr", "bm", "note", "err", " ba", "repl", "up", "test", "rn", "ac", "fb", "write", "ab", "adj", "ben", "update", "abin", "une", "back", "bridge", "ak", "ble", "eb", "exit", "eni", "be"], "q": ["ue", "u", "w", "t", "f", "g", "qa", "qual", "l", "qu", "dq", "z", "query", "k", "sq", "r", "ql", "qi", "qv", "qs", "qq", "Q", "quit", "p", "d", "queue", "iq", "qt"], "board": ["click", "butt", "loop", "Board", "bo", "lay", "boards", "play", "cell", "shell", "buffer", "lock", "mac", "bang", "control", "bank", "bd", "co", "bird", "block", "oard", "ward", "land", "ck", "back", "line", "chain", "comb", "bit", "flow", "player", "boarding", "ack", "code", "row", "paste", "box", "stroke", "button"]}}
{"code": "T = int(raw_input().strip())\\n  \\n  for i in xrange(T):\\n  \tC, F, X = map(float, raw_input().strip().split(' '))\\n  \tbest = X / 2.0\\n  \tc_sum = 0\\n  \tfactories = 1\\n  \tn_sum = c_sum + C / (2.0 + (factories - 1) * F)\\n  \twhile n_sum + X / (2.0 + factories * F) < best:\\n  \t\tbest = n_sum + X / (2.0 + factories * F)\\n  \t\tc_sum = n_sum\\n  \t\tfactories += 1\\n  \t\tn_sum = c_sum + C / (2.0 + (factories - 1) * F)\\n  \\n  \tprint \"Case #%s: %s\" % (i + 1, best)\\n", "target": "32", "substitutes": {"T": ["V", "GT", "G", "W", "P", "TB", "J", "TN", "t", "Y", "N", "M", "O", "B", "TA", "D", "TT", "H", "K", "I", "R", "E", "TS", "S", "NT", "L", "TH", "Q", "TR", "TM", "Z", "TC"], "i": ["ti", "ini", "y", "ic", "cli", "ind", "pi", "t", "li", "m", "f", "xi", "n", "it", "ix", "index", "c", "zi", "hi", "id", "ij", "q", "ai", "batch", "im", "I", "j", "mi", "qi", " j", "x", "di", "gi", "yi", "out", "ii", "ip", "p", "ci", "d"], "C": ["V", "CS", "G", "CI", "P", "W", "CNN", "CC", "CO", "Y", "N", "M", "MC", "B", "c", "CM", "D", "CF", "Cs", "H", "K", "CT", "CU", "A", "I", "R", "CP", "Cache", "CA", "S", "L", "U", "Co"], "F": ["V", "W", "FK", "J", "Fact", "GF", "Fixed", "FR", "FS", "Function", "Fs", "f", "AF", "FER", "N", "M", "FC", "O", "MF", "FB", "RF", "TF", "D", "CF", "Factory", "FL", "FD", "IF", "H", "DF", "UF", "I", "E", "FO", "FG", "FIN", "WF", "Field", "L", "U", "Fun", "FN", "Q", "Free", "SF", "Z", "All", "PF", "UL", "FF", "Family", "FE"], "X": ["V", "W", "P", "IC", "TX", "XY", "Y", "XM", "N", "M", "EX", "Xi", "D", "HTTP", "XL", "FE", "H", "K", "CE", "CT", "IX", "XX", "Content", "A", "Cross", "DX", "I", "R", "E", "S", "Check", "L", "x", "U", "UX", "XP", "Q", "XT", "OX", "MX", "Z", "ZX", "XXX", "ICE"], "best": ["valid", "rest", "est", "last", "to", "short", "Best", "first", "pe", "better", "new", "cost", "it", "only", "high", "index", "test", "hest", "enough", "highest", "full", "most", "fine", "p", "worst", "default", "b", "score", "ps", " Best", "start", "self", "stable", "largest", "v", "good", "x", "top", "one", "trial", "old", "success", "fit", "right", "bottom", "end", "latest", "next", "average", "all", "round", "found", "final", "stop", "same", "just", "higher", "max", "peak"], "c_sum": ["c_total", "i_min", " c_total", "n_set", "n_score", "c__sum", "c3min", "c0cal", "c3sim", "c67sum", " c0sum", "c_scale", "c__cal", " c_scale", "costonsim", " c_cal", "i3min", "cmatsim", " c0summary", "cmatscale", "c0total", " c0total", "c3sum", "c67score", "c_sim", "c67set", "i3sim", "c0summary", "c_cal", "cmatsum", "c_min", "costonsum", "i_sum", "i3sum", "c__total", "c_set", "c_score", " c0cal", "i_sim", " c_sim", "c_summary", "costonmin", "c0sum", " c_summary", "c__summary"], "factories": [" factory", "Factiques", " facticles", "factures", "facticles", "factsries", "factorometers", "facories", "factory", "manufactors", "factograms", "factsies", "factsors", "factsiques", "Factories", "factistries", " factilies", "factorory", "Factries", "ACTies", "factsograms", "factsistries", " factures", "facors", "factors", "fiurers", " facturers", " factometers", " Factors", " facties", "actilies", "Factograms", "ACTories", "factsilies", "facilies", "factilies", "factsicles", "factries", " Factiques", "manufactries", "factsories", "factsurers", " factors", "factorories", "factometers", " Factistries", "facties", "factologies", "factsologies", "ACTors", "Factors", " Factories", "manufactories", "manufactograms", "fiories", "actometers", "Factistries", " factologies", "fiures", "actories", "facologies", "fiors", "ACTicles", "factorilies", "actory", "factsures", "facturers", "factiques"], "n_sum": ["n67util", "n_sim", "npostonutil", "n__all", "cn_Sum", "n67sum", " c_fac", "npostonsum", "n_summary", "np_sum", " n_num", "n_Sum", "n__mean", " c_mean", "c_sim", "cn_sum", "nostonsummary", "np_vol", "n__Sum", "np_util", "cn_all", "n_fac", "nostonvol", "n67vol", "npostonsummary", "n_num", "nxsum", "cn_mean", "n_util", "n_mean", "npostonvol", "np_summary", "nxsim", "n_all", "c_summary", "n67summary", "nostonsum", "nostonutil", "nxsummary", "n_vol", " n_Sum", "n__sum"]}}
{"code": "T = int(raw_input().strip())\\n  misses = set()\\n  \\n  for i in xrange(T):\\n  \tR, C, M = map(int, raw_input().strip().split(' '))\\n  \tF = R * C - M\\n  \timpossible = False\\n  \tif F == 1:\\n  \t\tmatrix = [\"c\" + \"*\" * (C - 1)]\\n  \t\tfor _ in xrange(R - 1):\\n  \t\t\tmatrix.append(\"*\" * C)\\n  \telif R == 1:\\n  \t\tmatrix = [\"c\" + \".\" * (F - 1) + \"*\" * (C - F)]\\n  \telif C == 1:\\n  \t\tmatrix = [\"c\"]\\n  \t\tfor _ in xrange(F - 1):\\n  \t\t\tmatrix.append(\".\")\\n  \t\tfor _ in xrange(R - F):\\n  \t\t\tmatrix.append(\"*\")\\n  \telif R == 2:\\n  \t\tif F % 2 == 0 and (C > 1 and F != 2 or C == 1 and F <= 2):\\n  \t\t\tmatrix = [\\n  \t\t\t\t\"c\" + \".\" * (F / 2 - 1) + \"*\" * (C - F / 2),\t\\n  \t\t\t\t\".\" * (F / 2) + \"*\" * (C - F / 2)\\n  \t\t\t]\\n  \t\telse:\\n  \t\t\tmatrix = []\\n  \t\t\timpossible = True\\n  \telse:\\n  \t\tstack = []\\n  \t\tmatrix = []\\n  \t\tfor j in xrange(C, 1, -1):\\n  \t\t\tif F - 2 * j >= 0 and (R - 2) * j >= F - 2 * j:\\n  \t\t\t\tstack.append([j, j])\\n  \\n  \t\twhile stack:\\n  \t\t\telems = stack.pop()\\n  \t\t\tse = sum(elems)\\n  \t\t\tif se == F:\\n  \t\t\t\tfor count in elems:\\n  \t\t\t\t\tmatrix.append(\".\" * count + \"*\" * (C - count))\\n  \t\t\t\tfor _ in xrange(R - len(elems)):\\n  \t\t\t\t\tmatrix.append(\"*\" * C)\\n  \t\t\t\tmatrix[0] = \"c\" + matrix[0][1:]\\n  \t\t\t\tbreak\\n  \t\t\telif len(elems) < R:\\n  \t\t\t\tfor j in xrange(elems[-1], 1, -1):\\n  \t\t\t\t\tif F - se - j >= 0 and (R - len(elems)) * j >= F - se:\\n  \t\t\t\t\t\tstack.append(elems[::] + [j])\\n  \\n  \t\tif matrix == []:\\n  \t\t\timpossible =True\\n  \\n  \tprint \"Case #%s:\" % (i + 1)\\n  \tif impossible:\\n  \t\tprint \"Impossible\"\\n  \telse:\\n  \t\tfor row in matrix:\\n  \t\t\tprint row\\n", "target": "32", "substitutes": {"T": ["V", "GT", "G", "W", "P", "TB", "J", "TN", "t", "Y", "N", "B", "TA", "D", "TT", "H", "K", "I", "X", "E", "TS", "S", "NT", "L", "TH", "TR", "Q", "TM", "Z", "TI", "TC"], "misses": [" Missees", "writenses", "lossES", "writES", "losses", "writees", "lossenses", " MissES", "missES", " Misses", "missenses", "lossees", "missees", " Missenses", "writes"], "i": ["ti", "y", "ind", "t", "f", "li", "m", "ie", "it", "n", "l", "ix", "index", " ii", "e", "iter", "id", "r", "b", "im", "I", " I", "x", "p", "ci", "ji"], "R": ["V", "RS", "G", "P", "RE", "W", "ER", "J", "FR", "Range", "Y", "RG", "N", "O", "B", "MR", "RF", "Rs", "GR", "D", "H", "r", "RA", "BR", "RC", "SR", "RM", "A", "RT", "I", "RO", "X", "E", "S", "RR", "DR", "NR", "L", "U", "CR", "Run", "IR", "Res", "TR", "Q", "AR"], "C": ["V", "CS", "G", "W", "P", "CI", "J", "CC", "Y", "CAR", "N", "O", "FC", "Count", "MC", "B", "CM", "c", "Car", "D", "CF", "Cs", "Ch", "H", "K", "CT", "CU", "A", "I", "X", "E", "CP", "S", "L", "U", "CR", "CON", "Q", "VC", "WC", "TC", "Co"], "M": ["V", "G", "W", "P", "MT", "J", "Y", "m", "N", "O", "MC", "B", "CM", "MR", "D", "H", "K", "RM", "A", "I", "X", "E", "S", "L", "FM", "Q", "TM", "MM"], "F": ["V", "G", "W", "P", "RE", "FT", "FU", "J", "GF", "Fixed", "FR", "FS", "Function", "Fs", "f", "Y", "AF", "FER", "N", "FC", "O", "FB", "FI", " f", "B", "MF", "RF", "TF", "D", "Ret", "CF", "EF", "FL", "Type", "IF", "Length", "H", "FD", "K", "DF", "A", "UF", "I", "Fe", "X", "Family", "E", "FO", "S", "FG", "WF", "L", "U", "FP", "FM", "FN", "Q", "SF", "Fin", "Format", "Z", "PF", "FF", "FK", "FA", "FE"], "impossible": ["Impacted", "impulse", "excallowed", "explatible", "ispossible", "explured", "impossibility", "explallowed", " impacted", "explossible", "excossible", "impatible", "ispulse", "Impatible", "excured", "impured", "excatible", "Impossible", "Impulse", "Impured", " impulse", " impossibility", "ispacted", "impallowed", "ispossibility", "Impallowed", "impacted", "Impossibility"], "matrix": ["umatrix", "mitrix", "matchrices", "mmric", "patric", "umatbook", "moduleroll", "mmrix", "matrench", "mmrics", "formatrier", "plotrix", "mprint", "atrics", "Matric", "mitric", "mmrench", "modulezero", "mitrices", "mpack", " matzero", "mtment", "magric", "manrix", " matric", "plotrics", "atrices", "matchMatrix", "mbook", "Matrice", "dimrix", "Matrics", "atpack", "metrice", "tarrix", "magrix", "patcher", "mtrices", "patrics", "patrix", "formatrices", "mtrix", "matcher", "formatrice", "minate", "mride", "matchric", "scherice", "magrics", "modulerix", "manbook", "dimrice", " matpack", "metrier", "formatrix", "mroll", "umatric", "matzero", "matchrix", "magrench", "formatric", "formatcher", "atprint", "moduleric", "matrics", "metrices", "plotrices", "mitinate", " matprint", " matinate", "manric", "matinate", " matroll", "manrice", "tarride", "Matcher", "matride", "mrices", "metrix", "atric", "matrier", "tarbook", "dimric", "tarric", "mzero", "Matrices", "Matment", "matMatrix", "matroll", "mtrice", "scherix", "mrics", "matbook", "atMatrix", "umatride", "plotric", "matrice", "matpack", "atrice", "atrench", "mMatrix", "formatrics", "mrix", "Matbook", "matric", "atment", "mric", "scherier", "dimbook", "matrices", "matprint", " matrices", "Matrix", " matrics", "scherices", "atrix", "matment"], "_": ["int", "Not", "t", " the", "____", "get", "pt", "ml", "__", "x", "___", "all"], "stack": ["valid", "upper", "loop", "complete", "slice", "empty", "first", "stage", "fake", "Stack", "push", "zip", "st", "history", "view", "scope", "acks", "switch", "window", "test", "load", "status", "buffer", "parse", "store", "set", "check", "iter", "table", "call", "make", "via", "pack", "batch", "track", "space", "cache", "cycle", "counter", "frame", "chain", "storage", "ack", "forest", "hold", "frames", "args", "list", "trace", "level", "found", "pop", "reverse", "each", "queue", "wait"], "j": ["jl", "s", "json", "ja", "J", "jj", "ch", "y", "t", "f", "m", "g", "n", "kj", "it", "l", "c", "aj", "z", "js", "jp", "k", "dj", "ij", "jc", "r", "q", "el", "jit", "bj", "b", "o", "obj", "v", "x", "fr", "jump", "uj", "p", "ji", "d", "job", "h", "oj"], "elems": ["lets", "vemes", "veems", "Elemes", "letes", "lemms", "Elecs", "vems", "temes", "lemmes", "lers", "lemts", "germes", "temn", " elecs", "plers", "lemems", "lemtes", "leems", "eleems", "elemes", "Elels", "gerems", "lemmn", " eletes", "lemn", "vemn", "plems", "Elems", "Elemn", "lecs", "germn", "elemers", "tilems", "tilecs", "Elemb", "elers", " elers", "elemn", "temers", " elels", "eletes", "elecs", "tenmn", "lemls", "Elets", "lemes", "germs", "lems", "tilemb", "elemb", "plemes", "elets", " elemn", "pleems", "lemers", " elemers", "tilemes", "plemn", " elemb", "tems", "elels", " elets", "Eleems", "plets", "tenmes", " elemes", "tenms", "tencs"], "se": ["second", "ree", "sv", "est", "sex", "ine", "sed", "pe", "th", "sd", "ze", "sp", "prime", "SI", "we", "al", "ie", "sec", "sle", "Se", "sh", " Se", "sr", "parse", "e", "re", "ser", "ve", "sq", "ss", "su", "sign", "ne", "see", "ses", "si", "sc", "SE", "sa", "ase", "sy", "te", "sem", "use", "so", "fr", "square", "ke", "me", "pse", "ct", "ge", "ese"], "count": ["length", "second", "s", "value", "cr", "sex", "size", "cf", "ch", "th", "ind", "ze", "st", "f", "sp", "case", "current", "ie", "t", "n", "total", "index", "Count", "c", "z", "ount", "e", "set", "const", "q", " c", "acc", "cre", "cur", "number", "cond", "nt", "cycle", "counter", "ctr", "code", "num", "node", "fr", "sum", "ctx", "val", "me", "p", "err", "name", "cc"]}}
{"code": "if len(sys.argv) == 1:\\n      sys.stdin = open(\"B.in\")\\n  else:\\n      sys.stdin = open(sys.argv[1])\\n  \\n  def to_floats(s):\\n      return map(float, s.split())\\n  \\n  def get_floats():\\n      return to_floats(raw_input())\\n  \\n  n_cases = input()\\n  \\n  for case in xrange(1, n_cases + 1):\\n      farm_cost, farm_increase, goal = get_floats()\\n  \\n      best_time = float('inf')\\n      time = 0.0\\n      rate = 2.0\\n      while time < best_time:\\n          best_time = min(best_time, time + goal / rate)\\n          time += farm_cost / rate\\n          rate += farm_increase\\n  \\n      print \"Case #%d: %.7f\" % (case, best_time)\\n", "target": "33", "substitutes": {"sys": ["os", "hw", "python", "rt", "cgi", "Sys", "psy", "y", "ys", "np", "lib", "req", "yes", "xi", "us", "windows", "fs", "shell", "py", "proc", "ns", "system", "usa", "machine", "module", "se", "__", "mi", "nt", "dar", "process", "usr", "boot", "math", "server", "linux", "iso", "nuts", "pse", "std", "console", "kernel", "etc", "System", "phys"], "stdin": ["desccin", "descout", "stdck", "standardIn", "randin", "randcin", " stdck", "standardck", "descck", "standardout", "descIn", "stdcin", "standardin", "stdout", " stdIn", "stdIn", " stdcin", " stdout", "randout", "randIn", "descin"], "s": ["sample", "sv", "say", "spec", "input", "t", "w", "f", "g", "m", "n", "sf", "l", "single", "c", "its", "rs", "sq", "ls", "ss", "r", "b", "ps", "ats", "se", "source", "S", "v", "qs", "str", "sl", "ws", "sb", "p", "a", "string", "i"], "n_cases": ["n2case", "num_cases", "n2tests", "n_apps", "num_tests", "n_case", "n_tests", "num_case", "n2cases", "num_apps"], "case": ["est", " CASE", "core", "size", "catch", "pe", "cases", "ance", "condition", "cer", "test", "switch", "c", "rand", "bite", "lock", "set", "nce", "id", "connection", "client", "su", "board", "CE", "example", " c", "zero", "context", "ce", "ASE", "chain", "course", "count", "ase", "bug", "race", "ca", "ice", "code", "cas", "ace", " Case", "name", "instance", "Case"], "farm_cost": ["farmlycons", "farm_gain", "forge_cons", " farm_Cost", "farmlyshift", "farm___shift", "forge___cons", "forge___cost", " farm_gain", "farm_shift", "forge___shift", "farm_cons", "farm___cost", "forge_shift", "forge_cost", "farm___cons", "farm_Cost", "farmlycost"], "farm_increase": ["farm_changease", "farm_increased", "farm_incases", "farm_rease", "farm_reased", "farm_enhases", "farm_incate", "farm_changement", "farm_enhse", "farm_incment", "farm_changeate", "farm_increate", "farm_increases", "farm_enhased", "farm_incased", "farm_enhase", "farm_increse", "farm_incase", "farm_rement", "farm_changeases", "farm_increment", "farm_reate", "farm_rese", "farm_reases", "farm_incse"], "goal": ["duration", "half", "result", "gain", "standard", "bet", "date", "equal", "cost", "width", "grade", "game", "window", "gam", "vote", "team", "what", "general", "episode", "loss", " goals", "go", "kick", "wall", "tie", "den", "best", "level", "hat", "jump", "limit", "recent", "all", "chance", "leader", "final", "Goal", "save"], "best_time": ["best5rate", "best5cost", "peak_speed", "worst_Time", "bestlytimes", "best_cost", "best5Time", "best1rate", " best_times", "best1time", "best_Time", "better_rate", "peak_rate", "peak_time", "peak_times", "best_rate", " best_rate", "better_size", "best1cost", "bestlysize", "better_cost", "worst_cost", "worst_time", "better_times", "bestlyTime", "bestlytime", "best_speed", "best5time", "best_times", "better_Time", "best1times", "worst_rate", "better_time", "best_size", " best_cost"], "time": ["timer", "length", "duration", "value", "times", "last", "Time", "timeout", "size", "port", "date", "t", "history", "etime", "cost", "ime", "view", "com", "step", "test", "window", "tm", "runtime", "TIME", "set", "rank", "version", "sequence", "event", "depth", "task", "go", "change", "path", "point", "start", "temp", "ts", "age", "before", "clock", "now", "weight", "speed", "trace", "tim", "level", "mean", "latest", "type", "delay", "end", "transform", "create", "trip"], "rate": ["range", "value", "power", "rates", "gain", "efficient", "rice", "frequency", "mode", "rating", "rage", "fee", "grade", "capacity", "rat", "float", "rand", "status", "fine", "rank", "re", "state", "r", "change", "rule", "term", "money", "tie", "currency", "force", "erate", "Rate", "race", "weight", "speed", "error", "mean", "scale", "delay", "type", "average", "fare", "price", "factor", "score"]}}
{"code": "if len(sys.argv) == 1:\\n      sys.stdin = open(\"C.in\")\\n  else:\\n      sys.stdin = open(sys.argv[1])\\n  \\n  def to_ints(s):\\n      return map(int, s.split())\\n  \\n  def get_ints():\\n      return to_ints(raw_input())\\n  \\n  sys.setrecursionlimit(4000)\\n  \\n  def fill(rows, cols, mines):\\n      seen = set()\\n      visited = set()\\n  \\n      def search(numbered, zeros, min_numbered):\\n          left = (rows * cols - mines) - len(numbered)\\n          if left == 0:\\n              raise StopIteration((numbered, zeros))\\n          if left < 0:\\n              return\\n          for n in xrange(min_numbered, len(numbered)):\\n              number = numbered[n]\\n              if number in zeros:\\n                  continue\\n              row, col = number\\n              neigh = []\\n              if row > 0:\\n                  if col > 0: neigh.append((row - 1, col - 1))\\n                  neigh.append((row - 1, col))\\n                  if col < cols - 1: neigh.append((row - 1, col + 1))\\n              if col > 0: neigh.append((row, col - 1))\\n              if col < cols - 1: neigh.append((row, col + 1))\\n              if row < rows - 1:\\n                  if col > 0: neigh.append((row + 1, col - 1))\\n                  neigh.append((row + 1, col))\\n                  if col < cols - 1: neigh.append((row + 1, col + 1))\\n              neigh = list(set(neigh) - set(numbered))\\n              zeros.add(number)\\n              search(numbered + neigh, zeros, n + 1)\\n              zeros.remove(number)\\n  \\n      try:\\n          for row in xrange(rows):\\n              for col in xrange(cols):\\n                  search([(row, col)], set(), 0)\\n      except StopIteration, e:\\n          numbered, zeros = e.message\\n          board = {}\\n          for row, col in numbered + list(zeros):\\n              board[row, col] = '.'\\n          if zeros:\\n              board[zeros.pop()] = 'c'\\n          else: # case where first click is on a number\\n              board[0, 0] = 'c'\\n          out = ''\\n          for row in xrange(rows):\\n              for col in xrange(cols):\\n                  out += board.get((row, col), '*')\\n              out += '\\n'\\n          return out.strip()\\n      return 'Impossible'\\n  \\n  n_cases = input()\\n  for case in xrange(1, n_cases + 1):\\n      rows, cols, mines = get_ints()\\n  \\n      result = fill(rows, cols, mines)\\n  \\n      print \"Case #%d:\" % case\\n      print result\\n", "target": "33", "substitutes": {"sys": ["os", "hw", "python", "rt", "Sys", "mk", "psy", "y", "ys", "np", "lib", "spec", "req", "sync", "dev", "sec", "sky", "xi", "rus", "site", "windows", "fs", "init", "shell", "py", "tp", "util", "proc", "ns", "system", "machine", "go", "bin", "se", "__", "thread", "nt", "dar", "ry", "process", "usr", "boot", "math", "so", "linux", "iso", "nuts", "pse", "std", "console", "kernel", "io", "exit", "Python", "program", "System", "src", "phys", "func"], "stdin": [" stdOut", "stdOut", " stddin", "standardout", "shins", "stdino", "standardin", "stin", "shdin", "stdout", "wideino", "shout", " stdino", "shin", "standardOut", " stdins", "stdins", "widein", "wideOut", "standardino", " stdout", "wideout", "stout", "stins", "stddin"], "s": ["sv", "spec", "t", "f", "g", "m", "single", "c", "its", "js", "rs", "sing", "sq", "ls", "r", "ss", "q", "gs", "b", "ps", "ats", "se", "source", "S", "v", "qs", "str", "sl", "sb", "p", "ins", "h", "string"], "rows": ["olds", "projects", "blocks", "ows", "cells", "ms", "ears", "names", "xs", "mins", "days", "gets", "boards", "views", "ros", "roots", "ors", "ris", "runs", "ews", "lines", "keys", "classes", "rs", "ns", "months", "r", "rooms", "los", "uns", "es", "rolled", "results", "rc", "eeks", "outs", "yrs", "bs", "checks", "heads", "ums", "res", "orders", "fields", "users", "uds", "frames", "objects", "tests", "boxes", "rown", "hops", "urs", "right", "ords", "pages", "ins", "flows", "maps", "max"], "cols": ["coln", "columnms", " colS", "columnts", "Colabs", "munds", "divls", "chs", "Colms", "munabs", " colms", " colgs", "COLins", "columnds", "COLls", "colS", " colabs", "columnS", "celgs", "divs", "colabs", "columnabs", "COLts", "columnn", "colls", " colss", "munS", "colds", "cels", "chls", "columnls", "colins", "widthls", "colgs", " colds", "Colgs", "colts", "celn", "locins", " coln", "columngs", "widthss", "COLs", " colls", "colms", "columnins", "celabs", "locls", "widths", "chabs", "locs", "locts", "muns", "colss", "columns", "Cols", "divss"], "mines": ["menions", "menials", " mined", "menxes", "smalles", "minions", "mned", "minsxes", "minsials", "smallions", "minxes", " minials", "mnions", "manxes", "manials", "mined", "mnials", " minions", "smalled", "mnes", "minses", "menes", "manes", "manions", "minials", "minsions", "smallials"], "seen": ["recorded", "there", "generated", "printed", "new", "ordered", "named", "selected", "known", "en", "served", "existing", "held", "kept", "shown", "holder", "written", "used", "common", "read", "killed", "rown", "found", "drawn", "own", "marked", "represented"], "visited": ["visended", "exended", "exified", "visified", "tited", "versited", "tified", "tended", "versended", "versitted", "exited", "visitted", "titted", "exitted", "versified"], "numbered": ["created", "another", "done", "umbers", "lines", "uno", "zero", "shown", "modified", "tested", "enos", "num", "mon", "mentioned", "successful", "born", "ered", "connected", "nine", "edited", "ned", "even", "limited", "said", "rolled", "rawn", "made", "killed", "loaded", "started", "straight", "umen", "osen", "won", "ranked", "generated", "still", "ordered", "named", "selected", "occupied", "lined", "NUM", "centered", "los", "normal", "written", "ten", "matched", "signed", "solid", "next", "lower", "marked", "layout", "itten", "printed", "initialized", "blank", "long", "linked", "runner", "umbered", "elected", "sequence", "filled", "liner", "original", "aned", "holder", "line", "colored", "ln", "rown", "dated", "found", "drawn"], "zeros": ["zops", "zeoss", "enzoes", "zedos", "zoes", "zoS", "silOS", "zos", "erososs", "ozops", "enzens", "zoss", "zero", "zerograms", "siloS", "zioes", "zeo", "siloes", "erosos", "zOS", "ezos", "zeroes", "zesos", "erosoes", "zeos", "zograms", "zerslements", "ozoses", "zeroograms", "zeroS", "zerus", "eroso", "zesoses", "ozens", "ezoes", "zelements", "neo", "neos", "zedoes", "zens", "zeol", "ezoses", "zesoes", "ozos", "zesus", "zenoes", "enzos", "zeroo", "zeoes", "zeroos", "zersoss", "zenoS", "zersos", "zlements", "neeros", "zus", "ozOS", "zenOS", "zo", "neoss", "silos", "zerons", "neoes", "zerOS", "ozoes", "ziol", "zerops", "zedoses", "zeross", "zions", "zereros", "ozograms", "zons", "zedops", "zoses", "ozo", "zerol", "enzOS", "zerooes", "zol", "zenos", "zerlements", "zerso", "zeroeros", "ezus", "zerens", "zeons", "zios", "zeroses", "zerool"], "min_numbered": ["minute67umbered", "minute_numbered", "max_shown", "min67shown", "minute67shown", "min___shown", "minute67mon", "min_umbered", "min_colored", "minute_shown", "max_numbered", "min_mon", "min67numbered", "minute67numbered", "min___numbered", "min67umbered", "max_colored", "min___umbered", "min_shown", "min___mon", "minute_mon", "minute_umbered", "min67mon"], "left": ["length", "half", "loop", "padding", "small", "size", "missing", "len", "li", "wrong", "m", "offset", "only", "l", "long", "none", "loc", "down", "Left", "local", "nl", "center", "inner", "no", " Left", "start", "rel", "min", "low", "net", "L", "x", "off", "right", "level", "lt", "next", "lower", "all", "le", "lo", "ll", "below"], "n": ["nm", "nb", "nd", "nu", "y", "ul", "u", "ind", "t", "m", "mn", "nor", "N", "l", "nr", "index", "c", "z", "ns", "k", "nl", "nn", "r", "ne", "o", "na", "j", "nt", "sn", "bn", "x", "nan", "ln", "num", "nw", "node", "un", "p", "a", "name", "ll", "i"], "number": ["length", "Number", "result", "message", "value", "object", "neutral", "notation", "comment", "language", "note", "collection", "umber", "word", "long", "another", "byte", "total", "nr", "member", "NUM", "password", "integer", "none", "non", "national", "uno", "version", "initial", "even", "zero", "original", "normal", "inal", "no", "block", "money", "na", "multiple", "line", "counter", "negative", "never", "random", "one", "nom", "document", "num", "rown", "position", "node", "next", "final", "name", "string", "record", "phone"], "row": ["tr", "cell", "order", "ocr", "addr", "rs", "co", "zero", "batch", "arrow", "sw", "rc", "rod", "frame", "low", "bug", "num", "run", "round", "bar", "range", "month", "ows", "dr", "rect", "iter", "ran", "r", "entry", "cur", "rec", "res", "sel", "oh", "ow", "char", "post", "record", "form", "length", "bo", "rid", "week", "word", "ser", "ro", "Row", "mod", "raw", "scroll", "ry", "wn", "coll", "uu", "fr", "tab", "box", "rt", "gr", "th", "pair", "pg", "dir", "rot", "runner", "user", "rank", "re", "our", "block", "ra", "rel", "line", "ver", "ox", "str", "server", "rown", "roll", "day", "dd"], "col": ["cal", "cell", "comp", "cl", "c", "aj", "loc", "proc", "yy", "table", "co", "fc", "path", "cond", "fn", "cor", "num", "mon", "coord", "ct", "round", "tx", "nc", "int", "cp", "cont", "il", "ac", "non", "color", "ctl", "client", "el", "cur", "term", "pr", "min", "res", "prop", "child", "char", "Col", "name", "ll", "form", "ell", "div", "ol", "doc", "len", "sp", "sec", "column", "fl", "pt", "pol", "ref", "rem", "nt", "cat", "mot", "prev", "act", "coll", "fr", "disc", "tab", "pos", "ht", "COL", "pat", "cmd", "file", "th", "dir", "rot", "key", "mat", "con", "rol", "var", "br", "block", "obj", "rel", "cycle", "bl", "count", "ox", "str", "cmp", "roll", "ann", "val", "day", "item", "label"], "neigh": ["veigh", "nigh", "nerox", "ereigh", " nerog", "neder", "nyigh", "seigh", "anneigh", "naig", " neNeigh", "naob", "seil", "nane", "ereagle", "naollo", "deir", " nenel", "seob", "noteld", " knechel", "ereir", "neag", "narog", "diir", "dild", "uneigh", "neir", "nesigh", "niig", "nider", "diigh", " nene", "naigh", "nesig", " kneagle", "deNeigh", " kneigh", "senel", "nieil", " nerox", "neway", " neesh", "nychel", "deig", "naome", "diig", "nenel", "nNeigh", "neesh", "nig", "niigh", "naag", "ereder", "uneig", "nir", "nesesh", "neig", "nesome", " neig", "nyollo", "verog", "neld", "serox", "noteigh", " neag", "niagle", "nene", " neir", "nyway", "nerog", "nail", "anneld", "nald", "neome", "uneir", " neome", "seig", "seway", "nirox", "nair", " neil", "veir", "nirog", "nieigh", "annene", " kneway", "noteig", "deigh", "neil", "sechel", "nieob", "noteir", " kneder", "nyig", " neld", "neNeigh", "uneollo", "niir", "nechel", "nieig", "niag", "neagle", " neagle", " kneir", "veil", "nil", "ninel", "nyir", "neob", "neollo", "naagle", "niil", "naesh", " kneig", "nagle"], "board": ["layout", "book", "loop", "butt", "poll", "controller", "Board", "bo", "boards", "design", "pad", "cell", "byte", "pool", "balanced", "failed", "runner", "lock", "buffer", "uno", "black", "plate", "bang", "control", "bd", "bank", "ro", "block", "oard", "ward", "land", "holder", "back", "menu", "line", " clipboard", "colored", "flow", "player", "ack", "boarding", "hold", "deck", "box", "stroke", "won", "button", " boards"], "pop": ["strip", "clear", "last", "push", "new", "drop", "ext", "flush", "dot", "delete", "reset", "op", "pull", "crop", "top", "read", "prev", "hop", "pick", "ip", "bottom", "paste", "end", "sum", "shift", "Pop", "max"]}}
{"code": "\\n  INPUT = 'B-small-attempt1.in'\\n  OUTPUT = 'B-small-attempt1.out'\\n  \\n  \\n  def solve(C, F, X):\\n  \\n      cps = 2.0\\n      farm_time = 0.0\\n      time = X / cps\\n      \\n      while True:\\n          farm_time += C / cps\\n          cps += F\\n          ntime = farm_time + X / cps\\n          if ntime < time:\\n              time = ntime\\n          else:\\n              break\\n      return time\\n  \\n  \\n  if __name__ == '__main__':\\n      inp = open(INPUT)\\n      out = open(OUTPUT, 'w')\\n      \\n      T = int(inp.readline())\\n  \\n      for case in range(T):\\n          sol = solve(*map(float, inp.readline().split()))\\n          out.write('Case #%i: %.7f\\n' % (case + 1, sol))\\n", "target": "34", "substitutes": {"INPUT": ["inFACE", "inFILE", " inUSE", "INFACE", "INUSE", "INFILE", " INFILE", "OUPUT", "InFACE", "inPUT", " inFIX", " INFIX", "InFIX", "OUUSE", " inSPEC", "inFIX", " INFACE", "INFIX", "INSPEC", "OUSPEC", " inPUT", "OUFIX", "InPUT", "InUSE", "InFILE", "InSPEC"], "OUTPUT": ["OUPUTOT", "OUPUTUT", "OUSPut", "UTTPOT", "OUSPUT", "OUTPOT", "OUPPUTE", "OUDPOST", "OUPPPUT", "OUTPSut", "OUPPOST", "UTPPOST", "UTTPPUT", "OUTPSUT", "OUTPUTE", "OUTPut", "OUPPOT", "UTTPUTE", "OUPPut", "OUTPOST", "UTPPUT", "UTTPOST", "OUSPOT", "UTPPPUT", "UTTPUT", "OUSPUTE", "UTTPut", "OUTPSOT", "OUTPPUT", "OUDPOT", "OUTPSUTE", "OUPUTOST", "UTPPut", "UTPPOT", "UTPPUTE", "OUPPUT", "OUDPPUT", "OUDPUT", "OUPUTPUT"], "C": ["V", "CS", "G", "W", "P", "CV", "CC", "Y", "N", "M", "FC", "B", "CM", "c", "D", "CB", "CF", "Cs", "H", "K", "CE", "CT", "A", "I", "R", "E", "CP", "CA", "S", "L", "CW", "Co"], "F": ["V", "W", "P", "FU", "FT", "J", "FW", "GF", "FR", "Fs", "f", "AF", "FER", "Y", "N", "M", "FC", "O", "FB", "B", "D", "EF", "CF", "FD", "IF", "H", "K", "A", "I", "R", "E", "FO", "S", "FG", "L", "FP", "Q", "PF", "FF", "FA", "FE"], "X": ["V", "W", "P", "J", "Time", "FW", "Y", "f", "N", "FC", "Xi", "File", "D", "CF", "XL", "IF", "H", "K", "IX", "XX", "DX", "I", "R", "E", "S", "L", "x", "U", "UX", "XP", "Q", "XT", "MX", "Z", "ZX", "FF", "FK", "FE"], "cps": ["Ccs", "fps", " cpps", "scps", "Cfps", " cms", "ccs", "lcPS", " ccs", "cPS", "peps", "cfps", "Cpp", " cfps", "Cpps", "cms", " ceps", "CPS", "feps", "Ceps", "scPS", "dcps", "Cts", "Cps", " caps", "cpr", "faps", "scpr", "caps", "ceps", "fms", "dcts", "pps", "sceps", "Caps", "paps", "Cms", "ppr", "pPS", "pcs", " cts", "cpps", "dcPS", "lcfps", "dcpp", "Cpr", "lcpps", "cts", "pms", " cpp", "lcps", " cPS", "cpp"], "farm_time": ["farm_times", " farm_clock", "farm_Time", "Farm_t", " farm_Time", "farm_t", "Farm_time", "Farm_times", " farm_times", "farm_rate", "farm_clock", "farm_speed", "Farm_Time", " farm_speed", " farm_rate"], "time": ["timer", "length", "duration", "value", "message", "times", "month", "Time", "timeout", "file", "size", "frequency", "mode", "date", "t", "prime", "f", "etime", "ime", "offset", "stop", "com", "step", "test", "c", "tm", "name", "runtime", "TIME", "check", "set", "UTC", "event", "sequence", "table", "tf", "tt", "change", "path", "year", "point", "start", "close", "frame", "clock", "before", "x", "now", "code", "weight", "error", "trace", "tim", "end", "IME", "type", "exit", "tc", "instance", "max", "tx"], "ntime": ["pttime", "onetimer", "NTim", "ntimet", "ndimet", "NTimes", "ntetime", "ctim", "ntimer", "NTetime", "nttime", "onetime", "ndimes", "NTtime", "ptime", "ndetime", "ctetime", "ntimes", "ctime", "ndime", "ptim", "NTimer", "ntim", "ptimet", "cttime", "ndim", "NTimet", "NTime", "ndtime", "ndimer", "ctimet", "onetimes", "onetimet"], "inp": ["outp", "inf", "inport", " inpos", "inisp", "outsp", " inf", "intpos", " insp", "INp", "INsp", "inq", "outf", " inq", "incport", "intp", "intps", "intsp", "incp", "insp", " inps", "inps", "inip", "INq", "INf", "outport", "outq", " inport", "inpos", "inips", "inipos", "incq", "incsp"], "out": ["s", "os", "gen", "to", "file", "OUT", "w", "new", "t", "at", "null", "up", "n", "can", "over", "write", "aos", "ou", "gt", "co", "o", "obj", "Out", "nt", "outs", "res", "output", "net", "off", "list", "ex", "writer", "ent", "end", "p", "io", "outer", "log"], "T": ["V", "GT", "P", "TB", "J", "TN", "t", "Y", "N", "M", "O", "B", "TA", "TT", "Type", "H", "TY", "K", "TP", "I", "R", "TS", "S", "NT", "TED", "L", "TR", "Q", "TM", "IT", "TI", "TC"], "case": ["choice", "to", "catch", "pe", "mode", "t", "st", "cases", "condition", "test", "c", "name", "set", "sequence", "example", "client", "connection", "context", "point", "ce", "cycle", "character", "ASE", "chain", "ase", "x", "trial", "race", "ice", "num", "cas", "code", "position", "me", "p", "ace", "ci", "ct", "cation", "tc", "TC", "i", "Case"], "sol": ["s", "rr", "cr", "Sol", "ol", "sd", "successfully", "mol", "n", "sat", "sr", "status", "fine", "oln", "rol", "sch", "body", "resp", "sq", "rup", "r", "ls", "vol", "loss", "stress", "no", "rel", "sal", "ols", "sel", "stable", "res", "sels", "str", "sy", "mot", "ln", "success", "pot", "val", "olve", "err"]}}
{"code": "\\n  INPUT = 'C-small-attempt0.in'\\n  OUTPUT = 'C-small-attempt0.out'\\n  \\n  \\n  def solve(R, C, M):\\n      grid = [[0 for c in range(C)] for r in range(R)]\\n  \\n      def get_cell(cell_r, cell_c):\\n          if not(0 <= cell_r < R):\\n              return None\\n          if not(0 <= cell_c < C):\\n              return None\\n          return grid[cell_r][cell_c]\\n  \\n      def for_each_neighbour(cell_r, cell_c, func):\\n          ret = []\\n          coords = (\\n              (cell_r - 1, cell_c - 1), (cell_r - 1, cell_c), (cell_r - 1, cell_c + 1),\\n              (cell_r, cell_c - 1), (cell_r, cell_c + 1),\\n              (cell_r + 1, cell_c - 1), (cell_r + 1, cell_c), (cell_r + 1, cell_c + 1)\\n          )\\n          for nb in coords:\\n              if get_cell(nb[0], nb[1]) is not None:\\n                  ret.append(func(nb[0], nb[1]))\\n          return ret\\n  \\n      def mark_dirty(cell_r, cell_c):\\n          if grid[cell_r][cell_c] != '*':\\n              grid[cell_r][cell_c] += 1\\n      \\n      def unmark_dirty(cell_r, cell_c):\\n          if grid[cell_r][cell_c] != '*':\\n              grid[cell_r][cell_c] -= 1\\n  \\n      def check_empty_neighbours(cell_r, cell_c):\\n          return (0 in for_each_neighbour(cell_r, cell_c, lambda r, c: get_cell(r, c)))\\n  \\n      def click():\\n          for i, row in enumerate(grid):\\n              for j, cell in enumerate(row):\\n                  if cell != '*':\\n                      if cell == 0 or ((R * C - M) == 1):\\n                          grid[i][j] = 'c'\\n                          return\\n  \\n      def place_mine():\\n          for i, row in enumerate(grid):\\n              for j, cell in enumerate(row):\\n                  if cell == '*':\\n                      continue\\n                  prevstate = grid[i][j]\\n                  grid[i][j] = '*'\\n                  for_each_neighbour(i, j, mark_dirty)\\n                  if not (True in for_each_neighbour(i, j, check_empty_neighbours)):\\n                      grid[i][j] = prevstate\\n                      for_each_neighbour(i, j, unmark_dirty)\\n                  else:\\n                      return True\\n          return False\\n  \\n      for m in range(M):\\n          if not place_mine():\\n              return 'Impossible\\n'\\n  \\n      click()\\n  \\n      ret = ''\\n      for row in grid:\\n          ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '\\n'\\n  \\n      return ret\\n  \\n  \\n  if __name__ == '__main__':\\n      inp = open(INPUT)\\n      out = open(OUTPUT, 'w')\\n      \\n      T = int(inp.readline())\\n  \\n      for case in range(T):\\n          sol = solve(*map(int, inp.readline().split()))\\n          out.write('Case #%i:\\n%s' % (case + 1, sol))\\n", "target": "34", "substitutes": {"INPUT": ["CONFORMATION", "CONPUT", "ANFIX", "InFIX", "INFORMATION", "ANPUT", "INFIX", "InFORMATION", "InCEPT", "CONFIX", "InPUT", "INCEPT", "ANCEPT", "CONCEPT", "ANFORMATION"], "OUTPUT": ["OUDPPUT", "OUPUTUT", " OUTTPODE", "OUSPUT", " OUTPUTUTE", "OUTPODE", "OUTPUTE", "OUPUTUTE", "OUDPODE", "OUSPODE", " OUTTPUT", " OUTTPUTE", "OUSPUTE", "OUTPPUT", " OUTTPPUT", " OUTPUTPUT", " OUTPUTUT", " OUTPUTODE", "OUSPPUT", "OUPUTODE", "OUDPUTE", "OUDPUT", "OUPUTPUT"], "R": ["V", "RS", "G", "P", "RE", "RG", "N", "B", "MR", "RF", "Rs", "GR", "D", "H", "RA", "SR", "RM", "A", "RT", "I", "RO", "X", "E", "RI", "S", "NR", "RR", "DR", "L", "U", "F", "CR", "Res", "TR", "Q", "AR", "HR"], "C": ["V", "CS", "G", "CI", "P", "CV", "W", "COR", "CNN", "CC", "CO", "Y", "N", "CL", "Count", "MC", "B", "CM", "D", "Cs", "H", "K", "CE", "CCC", "CT", "CU", "A", "I", "X", "E", "CP", "EC", "S", "L", "F", "U", "CR", "CON", "Q", "CH", "WC", "Co"], "M": ["V", "G", "W", "P", "J", "Y", "N", "O", "MC", "B", "CM", "MR", "D", "H", "K", "LM", "RM", "A", "I", "X", "E", "S", "L", "F", "Q", "TM", "cm", "NM"], "grid": ["disk", "clear", "gb", "stack", "g", "wd", "lat", "site", "order", "addr", "query", "adj", "table", "reg", "net", "fixed", "hold", "age", "wrapper", "ad", "range", "Grid", "stock", "pool", "window", "cart", "fine", "db", "raid", "client", "mg", "res", "storage", "device", "layer", "list", "square", "gm", "form", "free", "domain", "cells", "rid", "map", "module", "hash", "fill", "managed", "image", "box", "data", "gr", "work", "lay", "sky", "remote", "gc", "dq", "mat", "set", "manager", "lag", "jac", "group", "filled", "block", "cache", "line", "ssl", "chain", "wire", "tile", "server", "node", "graph", "rows", "queue"], "c": ["cs", "cr", "cp", "cont", "tc", "ch", "u", "cf", "y", "t", "f", "cin", "g", "n", "l", "com", "cl", "ac", "con", "ec", "re", "co", "lc", "b", "ar", "unc", "cur", "cos", "ce", "rc", "v", "cu", "pc", "cb", "col", "cm", "ci", "cd", "ct", "p", "h", "xc", "cc"], "r": ["hr", "rr", "rt", "cr", "gr", "dr", "y", "rid", "w", "t", "f", "g", "n", "ru", "l", "rd", "h", "rm", "sr", "rs", "re", "ir", "b", "ro", "br", "ra", "ar", "ur", "pr", "rc", "rh", "res", "mr", "ry", "x", "er", "right", "p", "rar", "rb", "rx"], "cell_r": ["cel__r", "cand_d", "module_vr", "cell_b", "process8rar", "nel_l", "cell_d", "process_r", "cell_res", "cellablerd", "nel_rs", "node_ar", "area_rar", "process_ir", "cell10ra", "nel___rs", "cell___rs", "cel_r", "cellingreg", "cell__er", "cell_rc", "cell7r", "cell_right", "entry_ir", "tab_c", "component10r", "cellingrt", "process8r", "component_rg", "cellpyreg", "process7rr", "cell64rr", "cell___r", "cell5d", "node_right", "cell___rb", "nel___l", "pixel_rt", "tab_br", "cellingvr", "cell_rar", "conn_rel", "area_nr", "cellpylr", "cell2l", "celldbra", "cell___rc", "cell9r", "moduleingr", "cel_er", "nel___r", "cel__dr", "cell10rb", "cellingrc", "cellpyir", "areaingnr", "cell2rc", "cell9re", "cell_rg", "pixel_rd", "cell_rr", "cel_ro", "cell_reg", "component10rg", "cell_er", "entry_r", "cell10lr", "cellingrb", "cell_rel", "cellabler", "cell2r", "cell8adr", "entry_c", "cell_vr", "reportinglr", "cellptr", "cellpyar", "cellptrt", "cell64rar", "cell_ir", "shell_rc", "module_rc", "cell_rb", " cell_rc", "cell8rb", " cell_rr", "cell2ar", "process8ir", "shell5d", "cell10right", "cell8br", "cellinglr", "areaingrar", "cel__er", "cel_vr", "cell_nr", "cellpyrb", "report_r", "cell___rt", "process8rb", "celldblr", "node_rb", "cell_re", "cell64c", "cellpyright", "cell2ro", "cell8res", "cell5rc", "cell8r", "celldbr", "tab_b", "cell64ir", "pixel_or", "cell__rc", "component10ra", "moduleingvr", "cell5l", "report_lr", "cel_rb", "shell_d", "cell_or", "report_rt", "cel_dr", "cell9ir", "cell__dr", "celldbrg", "cell10ar", "moduleingrc", "cellingnr", "report_reg", "shell_r", "cell2o", "cell___vr", "pixel_br", "cellpyr", "node_r", "cellablert", "entry_lr", "cellptrect", "pixel_res", "entry_l", "cel__rs", "cellpyc", "cell_adr", "cell_l", "cell8rar", "cellpyrar", "process7rect", "areaingr", "component_ra", "cell10rg", "cell_ar", "cell_dr", "nel_rc", "cell_o", "nel_r", "cell___l", "shell5rc", "tab_r", "cell_ro", "reportingreg", "cel_o", "process7r", "cell_lr", "cell10r", "cel_rt", "cell_ra", "process_rar", "process_rect", "cellpyl", "moduleingrb", "cell_rt", "cellptrr", "cell7rect", "reportingr", "cellingr", "cell_rd", "conn_br", "areaingir", "cellingir", "shell5r", "reportingrt", "cell5r", "cell_ur", "cell64rc", "conn_r", "component10lr", "entry_re", "module_r", "cell2rs", "cell64nr", "process_rb", "entry_ur", "conn_ur", "cell9ur", "cel_rs", "area_r", "process_rt", "shell_l", "cand_r", "process_rr", "cand_rc", "cell64r", "cell__vr", "pixel_r", "cell__r", "cellingrar", "cel_ar", "component_r", "component_lr", "nel___rc", "cell__rb", "cell_rs", "cell__rs", "cellpyrt", "cellableor", "cell7rr", "cell_br", "cand_c", "cell7rt", "shell5l", "pixel_adr", "module_rb", "cell_rect", "area_ir", "process7rt", "cell8ir"], "cell_c": ["char_con", "cell_cs", "cell64co", "cell09C", "Cell_c", "ell_cc", "cell5cache", "cellYac", "component64c", "char_rc", "cell_b", "cellJcd", "cell09c", "cell8cd", "ell_rc", "component_c", "cell_cf", "cell_rc", "cel1c", "char0c", "ell_c", "ell_cs", "ell_cu", "char0lc", "component64ce", "cell64cm", "cell64cf", "tile_cd", "cell1tc", "cell_ci", "cell09ec", " cell_ci", "cellYcs", "char_cc", "cell2c", "cell23cont", "cell2p", "cell2l", "cell09cc", " cell_col", "cell_co", "cel_tc", "cell8cf", "cel_ct", "cell5cc", "Cell_lc", "cell2cm", " cell2ec", "shell_lc", "char0rc", "cell0col", "cell_cu", "cell2col", "area_ec", "cell_mc", "command_cc", "cell_h", "cell64cont", " cell_cn", "cell_cache", "cell0lc", "cel_rc", "cell1c", "cell_cn", "cell1lc", "cellablec", " cell2c", "char5h", "shell_rc", "cell8c", "area_cont", "cell_f", "cell9co", " cell2C", "command_c", "cell1rc", "cell0ec", "cell09cm", "shell_c", "cell5ct", "char0e", "cel_lc", "ell_mc", "char5cc", "cellaxyc", "cell1ct", "cell5h", "cell64c", "cell9ec", "area_c", "char_c", "cellYc", "cel_ic", "cell_ce", "cell2ec", "cel_p", "node_c", "ell_ct", "component64cm", "command9cc", "command9co", "cell0p", "command9c", "cell0e", "cellaxyf", " cell_f", "cellablece", "cellaxyci", " cell_l", "node64co", "cellablef", "cel_cache", "cell_cr", "node64c", "cell_e", "cell8tc", "tile_c", "component_ce", "component_cu", " cell_ce", "command_lc", "cell09cont", "command_co", "cell_cd", "node_cr", "char5c", "cell_ec", "cell_ic", "cell_l", "cell_cc", "cellablecn", "char_lc", "shell_cf", "cell1cache", "cell_cont", "cell_p", "node64cr", " cell_cm", "cel1rc", "cell_ct", "char_h", "cell_tc", "cel_col", "cell64cc", "cell23cc", "node_ac", "Cell_cu", "cell64cr", "cell64ac", " cell2col", "area09ec", "component64cu", "area_cc", "cell_cm", "cel1ic", "cell_name", "cell64ec", "cell5p", "cell64rc", "cellJcf", "cell5cu", "area09cc", "cel_c", "cellaxyp", "ell_ac", "tile_cf", "cell64ce", "cell09l", "cell23ec", "cell_lc", "area09c", "cell5con", "ell_co", " cell_ec", "cell64lc", "cell9p", "cell0rc", "cell_ac", "cell_C", "cel_C", "cel1cache", "node64ac", "cell0c", "node_co", "cell9cc", "cell_con", "char_e", " cell_p", "cell9lc", " cell2cm", "cellJc", "component_cm", "cell_col", " cell2p", "area09cont", "command9lc", "char5con", " cell2l", " cell_C", "Cell_r", "tile_tc", "cell64cu", "ell_name", "cel_b", "cellYname", "cell9c", "cell9col", "cellJtc", "cell2C", "cell23c", "cell1ic", "cell5c"], "func": ["cs", "sys", "cmd", "cast", "conn", "cf", "f", "fac", "cin", "sec", "agg", "cc", "kw", "ac", "fs", "con", "util", "function", "proc", "mac", "closure", "callback", "fc", "unc", "obj", "apply", "fn", "package", "str", "ws", "ln", "conv", "cb", "ctx", "aux", "val", "df", "fun", "nc"], "ret": ["result", "rt", "tn", "arr", "t", "tr", "rect", "agg", "it", "ft", "ary", "ext", "mt", "full", "Ret", "jp", "mont", "nl", "re", "gt", "utils", "reset", "quad", "rem", "br", "RET", "back", "ter", "elt", "nt", "az", "res", "reg", "ts", "net", "usr", "print", "args", "nil", "list", " Ret", "union", "val", "rg", "rets", "alt", "bar"], "coords": ["oats", "Coorders", "coats", " coorders", " coels", "Coels", "Coord", " coats", "conels", " coinates", "Coords", "conord", "oords", "oinates", "Coinates", "coels", "conorders", "coorders", " coord", "Coats", "coord", "conords", "oorders", "coinates"], "nb": ["wb", "nm", "kb", "adr", "nd", "abb", "ob", "nu", "pb", "NB", "gb", "conn", "tn", "np", "note", "buff", "dn", "nz", "bb", "n", "nr", "nv", "xy", "db", "ns", "nit", "binary", "resp", "nn", "ny", "zb", "bd", "nob", " neb", "bj", "ne", "b", "batch", "obj", "nt", "bs", "lb", "bn", "ib", "ln", "sb", "mb", "node", "cb", "img", "erb", "rb", "name", "nc"], "i": ["ti", "int", "ini", "y", "ic", "pi", "li", "ami", "xi", "it", "ix", "l", "iri", "bi", "zi", "ij", "ir", "phi", "ri", "I", "si", "mi", "ui", "v", "x", "ii", "ip", "ci", "p", "a"], "row": ["range", "rr", "ows", "rowd", "item", "w", "pair", "new", "tr", "rect", "re", "entry", "group", "ro", "Row", "block", "rec", "rc", "sc", "line", "field", "edge", "sel", "res", "ry", "ox", "rown", "ow", "node", "roll", "rl", "col", "rows", "array", "box", "form"], "j": ["ja", "J", "jj", "y", "ind", "t", "tr", "g", "n", "it", "l", "kj", "aj", "z", "jp", "k", "dj", "ij", "jc", "q", "br", "b", "o", "v", "x", "er", "col", "uj", "p", "ji"], "cell": ["ell", "cont", "cells", "slice", "ind", "cin", "n", "cel", "ac", "con", "function", "Cell", "column", "call", "entry", "co", "b", "fc", "unc", "obj", "ck", "ce", "pixel", "nel", "field", "edge", "sel", "cod", "cy", "tile", "ice", "node", "cb", "child", "col", "char", "ion", "cc"]}}
{"code": "\\n  class Solver(object):\\n      def __init__(self):\\n          pass\\n      \\n      def solve(self, inputs):\\n          c, f, x = [float(t) for t in inputs[0].split()]\\n          if x <= c:\\n              return '%.7f'%(x/2)\\n          ii = int(math.ceil((f*x-2*c)/(f*c)-1))\\n          if ii <= 0:\\n              return '%.7f'%(x/2)\\n          t = 0\\n          for i in range(ii):\\n              t += c/(2+i*f)\\n          t += x/(2+ii*f)\\n          return '%.7f'%t\\n          pass\\n      \\n      def feed(self, inputs):\\n          lines = [x.strip() for x in inputs]\\n          outputs = []\\n          test_case_n = int(lines[0])\\n          cur = 1\\n          for i in range(test_case_n):\\n              i = i\\n              case_line_cnt = 1\\n              case_inputs = lines[cur:cur+case_line_cnt]\\n              cur += case_line_cnt\\n              outputs.append(self.solve(case_inputs))\\n          return outputs\\n  \\n  if __name__ == '__main__':\\n      iname = 'B-small-attempt0.in'\\n      sample_in = '''\\n      4\\n  30.0 1.0 2.0\\n  30.0 2.0 100.0\\n  30.50000 3.14159 1999.19990\\n  500.0 4.0 2000.0\\n      '''\\n      sample_out = '''\\n  Case #1: 1.0000000\\n  Case #2: 39.1666667\\n  Case #3: 63.9680013\\n  Case #4: 526.1904762\\n      '''\\n      if os.path.exists(iname):\\n          with open(iname) as f:\\n              inputs = f.readlines()\\n      else:\\n          inputs = [x.strip() for x in sample_in.split('\\n') if x.strip()]\\n      solver = Solver()\\n      outputs = solver.feed(inputs)\\n      fail_flag = False\\n      if os.path.exists(iname):\\n          with open(iname+'.out', 'w') as f:\\n              for i, v in enumerate(outputs):\\n                  print >> f, 'Case #%d: %s'%(i+1, str(v))\\n      else:\\n          ans = set([x.strip() for x in sample_out.split('\\n') if x.strip()])\\n          for i, v in enumerate(outputs):\\n              t = 'Case #%d: %s'%(i+1, str(v))\\n              if t not in ans:\\n                  print '!!! Wrong:', t\\n                  fail_flag = True\\n      print '===================================================='\\n      for i, v in enumerate(outputs):\\n          print 'Case #%d: %s'%(i+1, str(v))\\n      print '===================================================='\\n      print 'done' if not fail_flag else 'fail'\\n      pass\\n", "target": "35", "substitutes": {"self": ["s", "os", "my", "json", "python", "book", "sys", "object", "cp", "subject", "np", "w", "th", "new", "details", "ren", "handle", "dev", "Self", "n", "cl", "test", "remote", "sub", "this", "py", "other", "local", "e", "config", "app", "q", "r", "client", "ref", "context", "rem", "obj", "add", "rel", "pkg", "res", "reader", "github", "you", "cmp", "der", "me", "p", "your", "parent", "h", "name", "instance", "also"], "inputs": ["inputments", "controls", " inputd", " Inputitions", " inputments", " inputitions", " Inputd", " inputerences", "Inputs", "outputS", "putments", "feedts", "outputts", "inputes", "inputd", "controles", "puterences", "configts", "configses", "configS", "outputes", "outputses", " inputS", "selects", "configs", " Inputs", "outputerences", " InputS", " inputes", "putes", "controlS", "InputS", "inputS", "inputts", "putses", "putS", "feedS", "Inputes", "outputd", "inputitions", "outputments", "puts", "selectes", "selectS", "putd", "inputerences", "feeds", "inputses", "outputitions"], "c": ["cs", "s", "cr", "cp", "ch", "y", "cf", "u", "w", "ic", "g", "cin", "m", "n", "l", "C", "z", "con", "e", "k", "const", "r", "lc", "co", "b", "fc", "o", "ce", "count", "cu", "col", "cm", "ci", "cd", "ct", "p", "d", "h", "xc", "a", "cc"], "f": ["s", "file", "cf", "u", "y", "w", "g", "m", "fac", "n", "l", "ft", "sf", "float", "fx", "fs", "bf", "z", "full", "fe", "fb", "e", "fl", "r", "tf", "co", "q", "elf", "b", "fc", "fa", "fo", "o", "fg", "xf", "j", "alf", "fi", "utf", "fn", "F", "off", "fd", "fr", "df", "p", "d", "ci", "a", "fp", "h", "fm", "lf", "form", "func"], "x": ["s", "ax", "u", "g", "l", "ext", "check", "q", "co", "b", "j", "wx", "ct", "a", "rx", "tx", "int", "xxx", "w", "xt", "xml", "z", "e", "xb", "r", "xx", "out", "p", "exp", "h", "name", "xc", "input", "xs", "on", "xe", "pi", "m", "xi", "n", "xa", "fx", "xy", "time", "o", "xf", "ice", "ex", "ci", "d", "y", "xd", "xxxxxxxx", "xp", "width", "ix", "key", "test", "xes", "px", "X", "dx", "xxxx", "ox", "ux"], "t": ["ti", "tar", "ty", "ta", "to", "u", "y", "w", "xt", "g", "m", "etc", "tw", "n", "it", "ft", "l", "done", "text", "z", "tp", "e", "k", "r", "tf", "time", "tt", "b", "tu", "T", "o", "tg", "j", "nt", "ts", "ox", "te", "out", "ex", "tim", "dt", "p", "d", "ct", "a", "h", "tc", "wt", "td"], "ii": ["ki", "ti", "chi", "iy", "ini", " ni", "ta", "y", "pi", "li", "ami", "ie", "xi", "ix", "index", "iri", "II", "zi", "ij", "iu", "ni", "ir", "ai", "co", "phi", "im", "sci", "si", "vi", "mi", "ui", "info", "fi", "qi", "ati", "ia", "di", "yi", "ice", "ios", "tif", "iso", "oci", "ci", "io", "ians", "ei"], "i": ["ki", "ti", "s", "int", "iy", "ini", "ic", "y", "u", "ind", "pi", "li", "m", "ie", "xi", "g", "it", "n", "ami", "l", "ix", "index", "key", "bi", "z", "e", "k", "set", "zi", "id", "hi", "iu", "ij", "r", "ai", "phi", "b", "im", "o", "I", "si", "j", "mi", "info", " j", "ia", "di", "gi", "yi", "ip", "ci", "p", "a", "io", "h", "oi"], "lines": ["blocks", "plays", "cells", "ds", "sections", "cycles", "xs", "gets", "steps", "cases", " Lines", "l", "links", "its", "runs", "items", "ns", "bytes", "ls", "xes", "files", "gs", "lists", "posts", "ses", "words", "vs", "line", "parts", "rings", "limits", "elines", "frames", "tests", "works", "vals", "strings", "ines", "codes", "rows", "reads", "pins", "ins", "points"], "outputs": ["returns", "streamd", " outputsl", "outputS", "inputensions", "outputts", "OutputS", "inputes", "outensions", "returnS", " outputd", "putts", "Outputes", "outes", "Outputts", "outS", "outputes", "streamt", "returnd", "putes", "streams", "outputensions", "inputS", "inputts", "returnsl", " outputt", "Outputs", "returnt", "outs", "putensions", "outputt", "putits", "putS", "streamsl", "outputd", "puts", "returnes", "outputits", "inputits", "returnts", "outputsl", "Outputits"], "test_case_n": ["test_case2n", "test_line_n", "test_line_i", "test_case_name", "test_case2name", "test_line_num", "test_case2num", "test_line_name", "test_line_N", "test_case_num", "test_case2N", "test_case_i", "test_case_N"], "cur": ["cr", "cont", "cp", "dr", "gr", "ch", "th", "tr", "pg", "nc", "cv", "current", "g", "Cur", "gc", "sr", "con", "loc", "car", "tmp", "set", " Cur", "ser", "dc", "lc", "co", "ur", "ptr", "ce", "rc", "sur", "sc", "stable", "cor", "ctr", "pre", "cat", "cu", "now", "pri", "lr", "char", "col", "cm", "ci", "ct", "ctrl"], "case_line_cnt": ["case_line_count", "case_line_nount", "case_line_nst", "case_line_cct", "case_line_Cst", "case_line_pnt", "case_line_countpt", "case_line_pst", "case_line_Cnt", "case_line_Cpt", "case_line_countct", "case_line_countount", "case_line_nnt", "case_line_cpt", "case_line_Cct", "case_line_cst", "case_line_Count", "case_line_countnt", "case_line_npt", "case_line_pount", "case_line_ppt"], "case_inputs": ["case_outputerences", "case_inputeds", "case_configerences", "case_outputts", "case_inputls", "case_feeds", "case_contexterences", "case_Inputlines", "case_feedlines", "case_Inputeds", "case_Inputs", "case_contextls", "case_outputs", "case_inputerences", "case_inputlines", "case_configls", "case_configts", "case_contexts", "case_inputts", "case_outputls", "case_configs", "case_contextts", "case_feededs", "case_outputlines", "case_outputeds"], "iname": ["insamd", "oamd", "samed", "oname", "iniamer", "onname", "ciname", " inename", "iniamel", "sename", "oame", "dinname", "inamd", "oamel", "iamd", "named", "inename", "iame", "onamed", "enami", "insamel", "insamer", "INamer", "iniename", "INamel", "inami", "inamed", "dinamed", "iamer", "INename", "IName", "iniame", " inname", " inamer", "oamer", "dinamer", "sami", "inamer", "inamel", "diname", "insame", "nname", "cinamer", " inamel", "namer", "inname", "cinamed", " inami", "cinname", "ename", "enamed", "enename", "iamel", "same", "name", "onamer", " inamed"], "sample_in": [" sample_inner", "Sample_in", "sample_ins", "sample_IN", "sample_inner", "sample2ins", " sample_ins", "Sample_ins", "sample2IN", "sample2out", "sample2in", "Sample_IN", "Sample_out"], "sample_out": ["sample_Out", " sample_Out"], "solver": ["psolution", "sanger", "resorter", " solve", "gsolver", "psolve", "resanger", "solve", "psaver", " solution", "sorter", "gsanger", " saver", "saver", "Solver", "asanger", "asorter", "asolver", "Solve", "gsolution", "Solution", "asolution", "solution", "gsorter", "resolver", "psolver", "resolution", "Saver"], "fail_flag": ["pass_flag", "fail2Flag", "fail2flags", "fail2flag", "fail_Flag", "fail_flags", "pass_flags", "pass_Flag"], "v": ["V", "sv", "y", "u", "m", "g", "tv", "vv", "nv", "ev", "z", "e", "k", "uv", "ve", "vt", "r", "q", "iv", "var", "b", "vi", "j", "val", "p", "d", "h"]}}
{"code": "\\n  class Solver(object):\\n      def __init__(self):\\n          pass\\n      \\n      def solve(self, inputs):\\n          R, C, M = [int(x) for x in inputs[0].split()]\\n          mp = []\\n          for r in range(R):\\n              mp.append(['.']*C)\\n          mp[0][0] = 'c'\\n          outputs = []\\n          if M == 0:\\n              for row in mp:\\n                  outputs.append(''.join(row))\\n              return outputs\\n          rr, cc, rm = R, C, M\\n          while rm >= min(rr, cc):\\n              if rr <= cc:\\n                  for r in range(rr):\\n                      mp[r][cc-1] = '*'\\n                  cc -= 1\\n                  rm -= rr\\n              else:\\n                  for c in range(cc):\\n                      mp[rr-1][c] = '*'\\n                  rr -= 1\\n                  rm -= cc\\n          \\n          if rm == 0:\\n              if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R, C) != 1:\\n                  return ['Impossible']\\n          else:\\n              if min(rr, cc) - rm >= 2:\\n                  if rr <= cc:\\n                      for r in range(rr-rm, rr):\\n                          mp[r][cc-1] = '*'\\n                  else:\\n                      for c in range(cc-rm, cc):\\n                          mp[rr-1][c] = '*'\\n              else:\\n                  if min(rr, cc) >= 4:\\n                      if rr <= cc:\\n                          for r in range(2, rr):\\n                              mp[r][cc-1] = '*'\\n                          mp[rr-1][cc-2] = '*'\\n                      else:\\n                          for c in range(2, cc):\\n                              mp[rr-1][c] = '*'\\n                          mp[rr-2][cc-1]='*'\\n                  elif min(rr,cc) == 3:\\n                      if max(rr, cc) == 3:\\n                          return ['Impossible']\\n                      else:\\n                          if rr <= cc:\\n                              mp[2][cc-1] = '*'\\n                              mp[2][cc-2] = '*'\\n                          else:\\n                              mp[rr-1][2] = '*'\\n                              mp[rr-2][2] = '*'\\n                  else:\\n                      return ['Impossible']\\n                      \\n          for row in mp:\\n              outputs.append(''.join(row))\\n          return outputs\\n          pass\\n      \\n      def feed(self, inputs):\\n          lines = [x.strip() for x in inputs]\\n          outputs = []\\n          test_case_n = int(lines[0])\\n          cur = 1\\n          for i in range(test_case_n):\\n              i = i\\n              case_line_cnt = 1\\n              case_inputs = lines[cur:cur+case_line_cnt]\\n              cur += case_line_cnt\\n              R, C, M = [int(x) for x in case_inputs[0].split()]\\n              rslt = self.solve(case_inputs)\\n              if self.verify(rslt, R, C, M):\\n                  outputs.append(rslt)\\n              else:\\n                  raise 'Failed'\\n          return outputs\\n      \\n      def verify(self, outputs, RR, CC, MCNT):\\n          if 'Impossible' == outputs[0]:\\n              return True\\n          rr = len(outputs)\\n          cc = len(outputs[0])\\n          if RR != rr or CC != cc:\\n              return False\\n          bd = []\\n          mask = []\\n          for i in range(rr):\\n              mask.append([1]*cc)\\n              bd.append([0]*cc)\\n              for j in range(cc):\\n                  if outputs[i][j] == '*':\\n                      bd[i][j] = 9\\n                  elif outputs[i][j] == 'c':\\n                      start = (i, j)\\n          for r in range(rr):\\n              for c in range(cc):\\n                  if bd[r][c] == 9:\\n                      for i in [r-1,r,r+1]:\\n                          for j in [c-1,c,c+1]:\\n                              if 0 <= i < rr and 0 <= j < cc:\\n                                  if bd[i][j] != 9:\\n                                      bd[i][j] += 1\\n  \\n          nlist = [start]\\n          while len(nlist):\\n              i, j = nlist.pop(0)\\n              if mask[i][j] != 0:\\n                  mask[i][j] = 0\\n                  if bd[i][j] == 9:\\n                      raise '!!! BOMB'\\n                  elif bd[i][j] == 0:\\n                      for ii in [i-1,i,i+1]:\\n                          for jj in [j-1,j,j+1]:\\n                              if 0<=ii<rr and 0<=jj<cc:\\n                                  if ii != i or jj != j:\\n                                      nlist.append((ii,jj))\\n          mcnt = 0\\n          for r in range(rr):\\n              for c in range(cc):\\n                  if mask[r][c] == 1:\\n                      mcnt += 1\\n                  if mask[r][c] == 1 and bd[r][c] != 9:\\n                      return False\\n                  if mask[r][c] != 1 and bd[r][c] == 9:\\n                      return False\\n          return (mcnt == MCNT)\\n                  \\n  \\n  if __name__ == '__main__':\\n      iname = 'C-small-attempt0.in'\\n      sample_in = '''\\n  7\\n  5 5 23\\n  3 1 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  3 4 0\\n  2 2 3\\n      '''\\n      sample_out = '''\\n  Case #1: 1.0000000\\n  Case #2: 39.1666667\\n  Case #3: 63.9680013\\n  Case #4: 526.1904762\\n      '''\\n      if os.path.exists(iname):\\n          with open(iname) as f:\\n              inputs = f.readlines()\\n      else:\\n          inputs = [x.strip() for x in sample_in.split('\\n') if x.strip()]\\n      solver = Solver()\\n      outputs = solver.feed(inputs)\\n      fail_flag = False\\n      if os.path.exists(iname):\\n          with open(iname+'.out', 'w') as f:\\n              for i, v in enumerate(outputs):\\n                  print >> f, 'Case #%d:'%(i+1)\\n                  print >> f, '\\n'.join(v)\\n      print '===================================================='\\n      for i, v in enumerate(outputs):\\n          print 'Case #%d:'%(i+1)\\n          print '\\n'.join(v)\\n      print '===================================================='\\n      print 'done' if not fail_flag else 'fail'\\n      pass\\n", "target": "35", "substitutes": {"self": ["s", "my", "python", "object", "cp", "subject", "np", "w", "new", "network", "ren", "Self", "cl", "test", "this", "py", "local", "rs", "ls", "q", "ref", "obj", "pr", "se", "private", "crit", "print", "ws", "you", "cmp", "me", "p"], "inputs": ["outputds", "acceptS", " inputds", "Inputs", "outputS", "inputes", "outputes", " inputS", "accepts", " inputes", " inputts", "InputS", "inputS", "inputts", "Inputds", "inputds", "Inputes", "Inputts", "acceptts"], "R": ["V", "RS", "G", "P", "RE", "W", "RG", "N", "Dr", "B", "MR", "GR", "Rs", "D", "RA", "BR", "H", "RC", "SR", "K", "RM", "T", "A", "RT", "I", "RO", "X", "S", "NR", "F", "Rot", "CR", "IR", "Mr", "Res", "TR", "RP"], "C": ["V", "CS", "G", "CI", "P", "CV", "W", "COR", "CNN", "CO", "N", "CL", "MC", "B", "CM", "D", "CB", "YC", "Cs", "Ch", "PC", "H", "K", "CCC", "JC", "CT", "RM", "T", "DC", "A", "I", "X", "E", "CP", "EC", "S", "L", "F", "U", "CR", "KC", "CW", "VC", "CN", "WC", "TC", "Co"], "M": ["V", "G", "W", "P", "MT", "m", "N", "O", "MC", "B", "CM", "MR", "D", "H", "MP", "K", "MI", "LM", "RM", "T", "I", "X", "E", "S", "L", "PM", "F", "Mi", "Q", "TM", "MS", "MM", "NM", "AM"], "x": ["mx", "ax", "y", "xs", "xt", "xe", "xd", "case", "xxxxxxxx", "yx", "xi", "xp", "ix", "xa", "key", "fx", "name", "xy", "hex", "xes", "px", "xf", "X", "xx", "wx", "dx", "xxxx", "ox", "ex", "ctx", "ux", "tx", "xc", "rx"], "mp": ["mph", "multi", "dp", "comp", "mpeg", "mt", "jp", "rs", "tmp", "proc", "mop", "ph", "mem", "pm", "perm", "vp", "top", "mon", "method", "pp", "ma", "em", "cp", "sql", "cap", "aps", "mc", "prim", "omp", "pr", "pps", "mg", "res", "sym", "mb", "p", "ap", "phys", "sv", "pb", "amps", "mk", "sp", "m", "tm", "py", "arp", "map", "mac", "ep", "rem", "ps", "mod", "temp", "mr", "met", "trap", "pl", "meg", "ms", "np", "pg", "mat", "meta", "tp", "mm", "app", "rup", "MP", "px", "msg", "rpm", "pkg", "rep", "cmp", "emp", "ip", "ym", "rows", "prep"], "r": ["hr", "adr", "rt", "cr", "dr", "w", "tr", "f", "m", "g", "n", "l", "attr", "rad", "rd", "h", "rn", "sr", "k", "rs", "re", "ir", "co", "rb", "b", "ro", "kr", "br", "ar", "ur", "rec", "pr", "rc", "rel", "res", "mr", "reg", "usr", "cu", "er", "lr", "right", "fr", "run", "p", "vr", "rar", "all", "rg", "err", "d"], "outputs": ["returns", " outputsb", "columnts", "outputts", "columnes", " outputgs", "output_", "putts", "Outputes", "Outputts", "return_", "outputes", "Outputsb", "putgs", "putes", "returnsb", "Outputgs", " outputes", "Outputs", " outputts", "puts", "outputsb", "columns", " output_", "Output_", "outputgs"], "row": ["ob", "may", "ows", "pair", "tr", "word", "cell", "mat", "OW", "mor", "user", "rs", "our", "entry", "mem", "ro", "Row", "rec", "sw", "mod", "rc", "sur", "raw", "line", "wo", "res", "ry", "ox", "usr", "rw", "out", "rown", "ow", "roll", "col", "rows", "round", "post", "lo", "record", "cro", "rx"], "rr": ["hr", "arr", "req", "cell", "attr", "rd", "rn", "addr", "rs", "nder", "ir", "co", "ar", "rc", "JR", "reg", "rl", "rar", "pp", "rint", "rx", "nc", "adr", "dr", "repl", "wr", "vv", "iter", "vc", "kr", "rec", "ptr", "pr", "rin", "res", "Mr", "kk", "rage", "err", "ll", "ail", "ell", "mk", "rid", "nr", "sr", "ndra", "orig", "ro", "gg", "ror", "mr", "lr", "uu", "fr", "vr", "rg", "rb", "cs", "cmd", "rt", "cr", "gr", "ario", "vd", "bb", "aa", "rol", "rer", "re", "br", "ra", "irt", "rpm", "ck", "rel", "rh", "elt", "rog", "cmp", "pc", "dd", "eor"], "cc": ["cell", "cl", "zz", "rs", "co", "fc", "bc", "ce", "rc", "cy", "cd", "ct", "pp", "tc", "nc", "cp", "uc", "vv", "ac", "mc", "ctl", "vc", "rec", "xx", "ca", "kk", "err", "xc", "ll", "ucc", "sec", "isc", "ship", "dc", "acc", "sc", "circ", "ctr", "ib", "coll", "col", "cn", "ci", "cs", "cmd", "cr", "rt", "cf", "ic", "cv", "erc", "bb", "cel", "gc", "ec", "con", "sq", "lc", "unc", "icc", "ck", "cycle", "BC", "ff", "cu", "cci", "cmp", "pc", "cm", "dd", "cca"], "rm": ["sm", "attr", "rd", "rn", "rs", "tmp", "co", "mem", "like", "norm", "adjust", "km", "pm", "perm", "cond", "rc", "fn", "reg", "rl", "lamm", "ct", "rar", "rom", "rx", "range", "nm", "cp", "wr", "mc", "change", "drm", "ri", "min", "mir", "md", "dm", "Mr", "imm", "rage", "err", "remove", "mk", "m", "n", "beta", "dim", "time", "ref", "rem", "RM", "mod", "mi", "mr", "dist", "act", "lr", "fr", "irm", "col", "cn", "ort", "rb", "bm", "cr", "rt", "orm", "cv", "handle", "MR", "rol", "mm", "tri", "arm", "rpm", "off", "cmp", "pc", "cm", "fm", "vm"], "c": ["cs", "cr", "cp", "tc", "cf", "ic", "u", "t", "f", "m", "g", "cin", "n", "ach", "l", "cl", "can", "gc", "h", "ac", "ec", "arc", "con", "mc", "e", "dc", "co", "lc", "vc", "b", "fc", "unc", "ar", "bc", "rec", "ce", "rc", "sc", "cache", "cul", "cu", "ca", "pc", "col", "cut", "ci", "cm", "p", "ct", "err", "xc", "nc"]}}
{"code": "filename = raw_input(\"Name of file: \")\\n  infile = open(filename, \"r\")\\n  outfile = open(filename + \".out\", \"w\")\\n  \\n  \\n  T = int(infile.readline()[:-1])\\n  \\n  \\n  def getMinTime(c, f, x):\\n      p0 = 2.0\\n      s_prev = x / p0\\n      s_curr = c / p0\\n      prev_item = 0\\n      next_item = x / (p0 + f)\\n      n = 1\\n      while s_prev + prev_item > s_curr + next_item:\\n          s_prev = s_curr\\n          prev_item = next_item\\n          s_curr += c / (p0 + (n * f))\\n          next_item = x / (p0 + ((n + 1) * f))\\n          n += 1\\n      return s_prev + prev_item\\n  \\n  for t in range(1, T + 1):\\n      items = infile.readline()[:-1].split(\" \")\\n      c = float(items[0])\\n      f = float(items[1])\\n      x = float(items[2])\\n      time = getMinTime(c, f, x)\\n      outfile.write(\"Case #%d: %.7f\\n\" %(t, time))\\n      \\n          \\n      \\n  \\n  outfile.close()\\n  infile.close()\\n", "target": "36", "substitutes": {"filename": ["nm", "title", "kl", "mson", "unction", "ames", "knit", "subject", "file", "aka", "sql", "Filename", "fil", "word", "udder", "location", "sword", "println", "mpeg", "lua", "isa", "ame", "knife", "nl", "fle", "phy", "wine", "pak", "fn", "SourceFile", "prefix", "journal", "directory", "nom", "ername", "nil", "out", "nw", "username", "wav", "ename", "FILE", "fp", "name", "nc"], "infile": ["outqueue", "innqueue", "inFile", "innfile", "inipipe", "inputcomplete", "inblock", "inplay", "inline", "incomplete", "Infile", " inline", "Inline", "outplay", "iFile", " inuse", "innplay", "innblock", "inputplay", "inputplace", "inqueue", "inicomplete", "inncomplete", "outuse", "Inplace", "inputpipe", "inputfile", "outplace", "iuse", "inputline", "inplace", "iniblock", "innpipe", "inputblock", "outline", "inuse", "inifile", "outFile", "inputFile", "ifile", "iline", "inputqueue", "innline", "inpipe", "InFile", " inFile"], "outfile": ["inFile", "inf", "offf", "offline", "outfilename", "cachefiles", " outline", " outf", "outsFile", "cachef", "inline", "outfiles", "infiles", "outf", "outerfilename", " outfilename", "offfile", "cacheFile", "outsfilename", "outsf", "outerfile", " outFile", "cachefile", "outline", "outsfile", "outFile", "outerFile", "offFile", "outerf", " outfiles"], "T": ["V", "GT", "W", "P", "TB", "J", "Time", "TN", "Y", "PT", "N", "M", "O", "C", "TA", "UTC", "TIME", "TT", "H", "K", "TP", "CT", "X", "TS", "S", "WT", "NT", "TH", "F", "Q", "TR", "TM", "VT", "Z", "TC"], "c": ["cs", "s", "cr", "cp", "cont", "tc", "u", "y", "ic", "w", "cf", "g", "m", "cin", "l", "com", "C", "z", "ac", "con", "mc", "e", "r", "dc", "lc", "co", "b", "fc", "unc", "o", "cur", "cos", "ce", "rc", "chain", "v", "cod", "cu", "cy", "cb", "cm", "p", "d", "ct", "cd", "h", "xc", "i", "nc", "cc"], "f": ["fed", "u", "y", "cf", "w", "frequency", "m", "g", "fac", "l", "ft", "sf", "fx", "fs", "bf", "z", "h", "fb", "e", "fort", "r", "tf", "b", "fc", "fa", "o", "xf", "fun", "alf", "rf", "fi", "ff", "v", "F", "fd", "fr", "p", "d", "a", "fp", "df", "fm", "i", "lf"], "x": ["s", "mx", "ax", "y", "u", "ic", "w", "xs", "xt", "xe", "on", "xi", "xp", "l", "ix", "xa", "z", "e", "xy", "rx", "r", "hex", "xes", "co", "q", "b", "fc", "o", "xf", "X", "xx", "wx", "v", "xxxx", "ox", "ex", "ux", "p", "ct", "h", "xc", "i", "tx"], "p0": [" p2", "vp5", "m5", "pu0", "c1", "P08", "P5", "carg", "pu02", "pi1", "p6", "iarg", "m3", "P256", "p256", "n6", "P02", "p02", "n5", "n0", "vpzero", "p3", "c0", "i0", "P2", "p50", "puzero", "pi0", " p3", "parg", "pi256", "Pzero", " p5", "c2", " p50", "p1", " p6", " p256", "p2", "vp02", "P0", "i5", "i1", "n3", "Parg", "pzero", "m0", "P50", "i08", "p08", "P1", "vp0", " p1", "c50", "vp08", "p5", "vp1", "pu1", "m6"], "s_prev": ["gs_prev", "s___init", "s___first", "s___prev", " s__history", "s2rev", "s_pre", "s__init", "s_attr", "iesalprev", "s_rel", "ls_prev", "ies_rel", " s_prop", "s___rel", "s___history", "s2rel", "ies_prev", " s__prop", "s___attr", "s__prev", "s_cur", "salprev", " s_init", "s2cur", "s__history", "gs_rel", "s_history", "s_next", "salattr", "salfirst", "iesalrel", "s__prop", "iesalfirst", "s___prop", "ies_first", " s__init", "s_first", "s_rev", "s___pre", "gs_rev", "iesalattr", "ls_prop", "s_init", "s_prop", "ls_pre", " s__prev", "ies_attr", " s_history", "s2prev", "salrel", "ls_next", "gs_cur", "s___next"], "s_curr": ["s_cer", "s__prirer", "s_ctrr", "s_cerer", "s_burrer", "s_Curp", "s_Curred", "s_cej", "s_prij", "s_cero", "s_curm", "s_curp", "s_curred", "s_prirer", "s_Curr", "s__priro", "s_crr", "s_ctrred", "s_curry", "s_currer", "s_burro", "s_verred", "s__curj", "s_curro", "s_burr", "s_Curm", "s__prij", "s_priro", "s_Curl", "s_Curry", "s_burj", "s_crm", "s_verp", "s_crl", "s_curre", "s__curr", "s_verl", "s__curro", "s_verr", "s_prir", "s_curj", "s__currer", "s_verry", "s_Curre", "s_ctrp", "s_crre", "s_ctrry", "s__prir", "s_curl"], "prev_item": ["prev_it", "Prev_it", "prevjattr", "vious_it", "vious___it", "vious___val", "prevjitem", " prev_attr", "prevjstatus", "vious_val", "Prev_attr", "prev__val", "prev___it", "prev___item", " prev_val", "prev___Item", "prev___attr", "Prev_items", "Prev_Item", "prev_status", "vious_items", "prev_attr", "prev__it", " prev_it", "prev___val", "prevjItem", "prev___items", "prev___status", "prev_val", "vious___item", "Prev_status", "prev_items", "prev__item", "vious_item", "prev_Item", "Prev_item", "prev__attr", "vious___items"], "next_item": ["prev_it", " next_Item", "nextxindex", "prev_element", "next_Item", "nextxItem", "prev_iter", "next_val", "next_iter", "prev_index", " next_items", "prev_val", "next_items", "next_element", "next_it", "nextxitem", "prev_items", "prev_Item", "next_index"], "n": ["nb", "s", "nm", "nu", "tn", "names", "np", "y", "w", "len", "dn", "new", "m", "g", "mn", "l", "N", "nr", "long", "en", "ns", "nl", "nn", "r", "ne", "norm", "b", "o", "number", "na", "j", "nt", "sn", "fn", "an", "ln", "num", "un", "cn", "p", "all", "a", "i", "nc"], "t": ["title", "ti", "s", "ty", "tz", "y", "w", "at", "m", "g", "it", "l", "total", "step", "z", "q", "tf", "tt", "j", "v", "ts", "tim", "dt", "type", "p", "d", "ct", "h", "tc", "wt", "i", "ot"], "items": ["ids", "ows", "packages", "modules", "actions", "docs", "stats", "Items", "headers", "sections", "xs", "details", "ites", "steps", "ips", "amples", "airs", "aps", "lines", "keys", "phones", "photos", "files", "groups", "ims", "words", "ools", "parts", "features", "images", "bits", "units", "orders", "terms", "users", "args", "objects", "plugins", "tests", "els", "vals", "issues", "ords", "rows", "ues", "ers", "members", "reports", "boxes", "points"], "time": ["timer", "duration", "length", "second", "value", "message", "times", "Time", "timeout", "frequency", "date", "m", "etime", "ime", "ft", "step", "text", "z", "tm", "mt", "runtime", "TIME", "depth", "context", "tt", "counter", "count", "v", "now", "trace", "tim", "type", "tc", "string"]}}
{"code": "filename = raw_input(\"Name of file: \")\\n  infile = open(filename, \"r\")\\n  outfile = open(filename + \".out\", \"w\")\\n  \\n  \\n  T = int(infile.readline()[:-1])\\n  \\n  def addMinesDiagonally(r, c, m):\\n      field = []\\n      for i in range (r):\\n          row = []\\n          for j in range(c):\\n              row += [\".\"]\\n          field += [row]\\n          \\n      for i in range (r + c):\\n          ver = min (i, r - 1)\\n          hor = max (0, 1 + i - r)\\n          while ver >= 0 and hor <= c - 1 and m > 0:\\n              if m == 1 and hor == c - 2 and ver == r - 2:\\n                  ver -= 1\\n                  hor += 1\\n              field[ver][hor] = \"*\"\\n              ver -= 1\\n              hor += 1\\n              m -= 1\\n          \\n      return field\\n  \\n  def isPossible(field):\\n      if field[-1][-1] != \".\":\\n          return False\\n      up = True\\n      left = True\\n      diag = True\\n      if len(field) > 1 and field[-2][-1] != \".\":\\n              up = len(field[-1]) <= 1\\n      if len(field[-1]) > 1 and field[-1][-2] != \".\":\\n              left = len(field) <= 1\\n      if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != \".\":\\n          diag = False\\n      return (up and left and diag) or \\\\n             ((not up) and (not left) and (not diag))\\n      \\n  \\n  for t in range(1, T + 1):\\n      items = infile.readline()[:-1].split(\" \")\\n      r = int(items[0])\\n      c = int(items[1])\\n      m = int(items[2])\\n      field = addMinesDiagonally(r, c, m)\\n      if isPossible(field):\\n          field[-1][-1] = \"c\"\\n          s = \"\"\\n          for line in field:\\n              for cell in line:\\n                  s += cell\\n              s += \"\\n\"\\n          outfile.write(\"Case #%d:\\n%s\\n\" %(t, s[:-1]))\\n      else:\\n          s = \"IMPOSSIBLE!!!!\\n\"\\n          for line in field:\\n              for cell in line:\\n                  s += cell\\n              s += \"\\n\"\\n          outfile.write(\"Case #%d:\\n%s\\n\" %(t, s[:-1]))\\n      \\n          \\n      \\n  \\n  outfile.close()\\n  infile.close()\\n", "target": "36", "substitutes": {"filename": ["nm", "title", "kl", "mson", "unction", "jen", "figure", "there", "knit", "file", "aka", "rake", "Filename", "f", "fil", "wr", "sword", "println", "text", "lua", "txt", "isa", "tp", "knife", "fle", "til", "phy", "tek", "fn", "SourceFile", "wright", "wire", "prefix", "ername", "nil", "directory", "out", "instead", "nw", "username", "ename", "FILE", "fp", "name", "string", "nc"], "infile": ["inFile", "innfile", " informat", "innerqueue", " inqueue", "inline", "iniFile", "Infile", "infiles", " inline", "Inline", "innFile", "inqueue", "innerFile", "innerline", "Inqueue", "Informat", "iniout", "innfiles", "outline", "outout", "inifile", "iniline", "outFile", "innerfile", "inout", " infiles", "Inout", "InFile", " inFile", "innformat", "informat", "Infiles"], "outfile": ["inFile", "outto", "overfile", " outline", " outwrite", "otfile", "inline", "inwrite", "otwrite", "into", " outto", "outwrite", "otline", "overto", " outFile", "outline", "outFile", "overline", "overFile", "otFile"], "T": ["V", "GT", "W", "P", "TB", "J", "Time", "TN", "Y", "Total", "N", "M", "O", "B", "C", "TA", "D", "Type", "H", "K", "TP", "I", "R", "TS", "S", "WT", "L", "F", "TR", "Q", "TM", "VT", "TO", "IT", "TI", "TC"], "r": ["rt", "cr", "dr", "u", "rid", "w", "tr", "ren", "g", "f", "ru", "n", "l", "nr", "rd", "sr", "e", "rs", "re", "ir", "q", "rb", "b", "ro", "ra", "ar", "o", "ri", "R", "rc", "rh", "res", "mr", "v", "x", "er", "pc", "lr", "right", "fr", "vr", "p", "d", "rar", "a", "h"], "c": ["cs", "cr", "cp", "ch", "u", "y", "cf", "w", "f", "cin", "g", "n", "l", "com", "cl", "C", "h", "ac", "z", "con", "ec", "mc", "e", "k", "dc", "co", "lc", "b", "fc", "o", "cur", "cos", "ce", "rc", "cache", "v", "cu", "x", "ca", "coll", "cb", "col", "cd", "ci", "cn", "ct", "cm", "d", "p", "tc", "a", "cc"], "m": ["bm", "ms", "y", "u", "w", "ma", "pi", "f", "g", "on", "n", "mn", "M", "l", "z", "tm", "rm", "mt", "mc", "k", "e", "mm", "re", "man", "arm", "b", "im", "am", "o", "ter", "mi", "min", "mr", "v", "x", "er", "dm", "mon", "gm", "cm", "p", "d", "all", "a", "h", "vm"], "field": ["tag", "match", "butt", "spec", "stack", "case", "comp", "query", "proc", "grid", "table", "co", "frame", "bit", "v", "attribute", "force", "answer", "link", "method", "type", "range", "comment", "index", "db", "event", "entry", "rule", "term", "ter", "dict", "label", "prefix", "Field", "storage", "out", "list", "layer", "command", "position", "filter", "char", "child", "p", "exp", "section", "name", "string", "record", "post", "job", "form", "length", "message", "ld", "domain", "input", "f", "word", "vector", "flag", "header", "member", "load", "option", "column", "time", "point", "back", "arg", "ment", "col", "tab", "param", "part", "box", "data", "result", "value", "file", "here", "pair", "feature", "play", "pad", "condition", "byte", "key", "test", "user", "set", "config", "version", "group", "lc", "var", "block", "format", "inner", "bin", "obj", "cache", "wire", "good", "player", "fields", "er", "node", "error", "level", "FIELD", "component", "relation", "display"], "i": ["ti", "int", "ic", "y", "u", "rid", "ind", "pi", "f", "li", "ie", "it", "n", "l", "index", "il", "bi", "e", "id", "iu", "ij", "ir", "b", "im", "o", "ri", "I", "si", "mi", "v", "x", "ia", "er", "ip", "ii", "p", "ci", "d", "a", "h", "inter", "oi"], "row": ["range", "ows", "w", "pair", "th", "tr", "rot", "index", "order", "rs", "pos", "re", "ser", "co", "group", "ro", "ter", "rc", "res", "ry", "ox", "x", "out", "num", "rown", "ow", "roll", "col", "vr", "rows", "box", "name"], "j": ["oj", "cr", "cont", "ch", "g", "cl", "gc", "aj", "z", "rm", "car", "mc", "k", "ij", "jc", "q", "jac", "co", "b", "mod", "ck", "cod", "code", "cm", "cut", "cd", "cc"], "ver": ["hr", "av", "dr", "gr", "rid", "tr", "li", "iver", "rot", "test", "h", "over", "con", "vert", "iter", "version", "ser", "ve", "re", "ir", "browser", "co", "var", "b", "um", "pr", "ter", "vet", "res", "mr", "v", "er", "ever", "server", "lr", "Ver", "aver", "VER", "fr", "vr", "val", "type", "vers", "inter"], "hor": ["hr", "hal", "eth", "Hor", "hard", "dr", "rid", "len", "ind", "ha", "tr", "dir", "rot", "high", "orth", "her", "en", "hel", "mt", "con", "vert", "mil", "hang", "iter", "hi", "ser", "hd", "ir", "hl", "phi", "bh", "hei", "pr", "ter", "mi", "hom", "vers", "mir", "mr", "v", "dh", "hold", "hair", "mot", "den", "lr", "fr", "vr", "h", "floor", "lo", "inter", "ho"], "up": ["post", "upper", "ote", "uc", "ouch", "u", "y", "push", "uph", "upid", "high", "Up", "over", "ups", "down", "user", "prom", "ou", "ump", "mp", "um", "omp", "ra", "home", "ap", "back", "space", "op", " Up", "low", "upt", "flow", "sup", "top", "upload", "out", "success", "ex", "ow", "ud", "ip", "UP", "sum", "au", "p", "all", "pos", "upp", "own"], "left": ["length", "own", "cont", "ner", "small", "len", "push", "li", "leave", "wrong", "long", "only", "done", "l", "com", "false", "shell", "full", "down", "local", "Left", "nl", "lock", "body", "loc", "dl", "ml", "inner", "path", "start", "rel", "cond", "min", "fail", "low", "net", "L", "top", "out", "list", "right", "pl", "lic", "level", "open", "bottom", "both", "lt", "p", "lower", "all", "la", "le", "broad", "pos", "lo", "lit", "log", "below"], "diag": ["Diagger", "giag", "diagger", "Diang", " diagger", "diags", "giagg", "Diags", "diang", "liagg", " diig", "giig", "giagger", " diang", "liig", "liags", "duags", "liag", "duig", "duagger", "Diagg", " diagg", "Diag", "liang", "diig", "duag", "diagg", " diags", "Diig"], "t": ["ti", "ty", "ta", "to", "size", "y", "w", "at", "f", "g", "typ", "n", "l", "total", "tm", "tp", "e", "k", "q", "time", "tt", "b", "o", "tip", "v", "ts", "x", "te", "out", "dt", "type", "p", "d", "h", "tc", "wt", "ot"], "items": ["ids", "lets", "os", "times", "ows", "amps", "cells", "docs", "stats", "Items", "ops", "sections", "ites", "cats", "jobs", "ips", "aps", "links", "airs", "its", "ics", "lines", "keys", "phones", "ls", "files", "groups", "flows", "ims", "bits", "qs", "terms", "users", "args", "objects", "plugins", "tests", "workers", "els", "vals", "aux", "rows", "pages", "ins", "ers", "ues", "orders", "points"], "s": ["os", "sm", "of", "ed", "g", "l", "sf", "js", "lines", "ies", "rs", "_", "ls", "ss", "sit", "b", "sid", "v", "num", "sand", "type", "a", "ge", "cont", "w", "sam", "e", "se", "S", "ts", "args", "the", "sb", "p", "string", "form", "sv", "cells", "ds", "new", "f", "n", "sat", "its", "ns", "get", "ps", "ats", "o", "si", "strings", "col", "d", "ers", "cs", "sys", "ms", "y", "sd", "ix", "us", "fs", "mat", "set", "gs", "es", "X", "fields", "x", "er", "ws", "rows", "ins"], "line": ["range", "match", "ner", "ine", "note", "lay", "li", "case", "inline", "l", "lin", "lined", "load", " inline", "write", "lock", "lines", "set", "vert", "change", "liner", "block", "email", "start", "se", "edge", "frame", "age", "Line", "ln", "code", "link", "open", "end", "col", "box", "ge", "ide"], "cell": ["ell", "butt", "cells", "ner", "slice", "lay", "new", "word", "case", "inline", "null", "pad", "cel", "shell", "Cell", "check", "_", "table", "call", "entry", "co", "draw", "batch", "inner", "obj", "ck", "ter", "nel", "v", "er", "cy", "code", "char", "col", "tab", "cut", "ad", "box", "name", "string", "label", "form"]}}
{"code": "\"\"\"Usage:\\n      pypy X.py < X-size.in > X-size.out\\n  or sometimes\\n      python X.py < X-size.in > X-size.out\\n  \"\"\"\\n  \\n  def setup(infile):\\n      return locals()\\n  \\n  def reader(testcase, infile, C=None, **ignore):\\n      I = map(float, infile.next().split())\\n      return locals()\\n  \\n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\\n  \\n      C, F, X = I\\n      n = [0]\\n      r = 2.\\n  \\n      res = X / r\\n      while True:\\n          n.append(n[-1] + C / r)\\n          r += F\\n          nres = n[-1] + X / r\\n          if nres >= res:\\n              break\\n          res = nres\\n  \\n      return 'Case #%s: %s\\n' % (testcase, res)\\n  \\n  if __name__ == '__main__':\\n      T = int(sys.stdin.next())\\n      common = setup(sys.stdin)\\n      for t in xrange(1, T+1):\\n          sys.stdout.write(solver(**reader(t, **common)))\\n", "target": "37", "substitutes": {"infile": ["inile", "inFile", "outpath", " inile", "inputile", "ginfile", "ginpath", "inline", "outfiles", "outile", "Infile", "infiles", " inpath", "outfile", "ginFile", "inputfile", "inputline", "inputpath", "outline", "ginline", "outFile", " infiles", "inputFile", "inpath", "InFile", " inFile", "Infiles"], "testcase": [" testname", "caseCase", "testname", "testCase", "Testcase", "casestring", " testCase", " teststring", " testprefix", " testcore", "Testprefix", "casecase", "teststring", "Teststring", "caseprefix", "Testname", "casecore", "Testcore", "casename", "testcore", "testprefix", "TestCase"], "C": ["V", "CS", "G", "CI", "CC", "CO", "Y", "M", "O", "B", "c", "CM", "D", "CF", "Cs", "Type", "H", "K", "CT", "DC", "A", "R", "E", "CP", "EC", "L", "U", "CR", "CN", "Co"], "I": ["V", "int", "IA", "G", "IC", "J", " i", "Y", "SI", "M", "O", "Ni", "B", "IP", "IO", "II", "D", "IL", "IF", "H", "MI", "A", "R", "Is", "E", "RI", "Si", "L", "U", "Res", "It", "Q", "IT", "NI", "TI", "Int", "i"], "N": ["V", "Ns", "G", "J", "Y", "M", "O", "B", "NS", "D", "H", "K", "A", "NN", "R", "E", "L", "FN", "Q", "Z"], "P": ["V", "PD", "J", "Y", "PT", "M", "O", "B", "PP", "H", "TP", "A", "R", "PR", "E", "CP", "L", "Q", "Py", "p", "Ps"], "T": ["V", "GT", "G", "W", "J", "TN", "Y", "PT", "M", "O", "B", "TF", "D", "TT", "TV", "Type", "H", "TY", "K", "TP", "R", "E", "TS", "Ts", "NT", "WT", "L", "To", "TM", "VT", "Z", "TC"], "S": ["V", "s", "OS", "G", "Y", "SI", "SA", "M", "O", "B", "NS", "SS", "H", "A", "R", "SL", "E", "TS", "Si", "L", "SH", "Q", "Z"], "F": ["V", "G", "W", "J", "GF", "FR", "f", "Y", "M", "FC", "O", "FI", "B", "D", "CF", "H", "K", "DF", "A", "UF", "R", "E", "FG", "L", "U", "FP", "Q", "Z", "FF", "FE"], "X": ["V", "Tx", "G", "W", "J", "Y", "M", "O", "B", "D", "XL", "H", "TY", "K", "IX", "XX", "A", "DX", "R", "E", "L", "x", "U", "UX", "XP", "Q", "XT", "Z", "ZX", "FE"], "n": ["s", "nb", "nu", "conn", "tn", "np", "new", "on", "f", "m", "g", "ren", "l", "nr", "nor", "en", "c", "init", "rn", "z", "ns", "nl", "nn", "reset", "ne", "b", "na", "j", "nt", "sn", "fn", "v", "x", "nan", "out", "ln", "node", "next", "cn", "p", "i", "nc"], "r": ["hr", "s", "result", "rt", "cr", "u", "w", "f", "m", "g", "err", "ren", "rate", "ru", "l", "nr", "rd", "c", "rn", "z", "sr", "rs", "k", "re", "q", "rb", "b", "ro", "rem", "o", "rec", "R", "rel", "rc", "j", "rf", "mr", "v", "x", "out", "right", "fr", "p", "d", "rar", "h", "i", "rx"], "res": ["cs", "rest", "result", "RE", " Res", "gr", "prime", "new", "req", "f", "m", "resource", "cons", "rand", "init", "test", "c", "con", "e", "rs", "rx", "re", "resp", "q", "reset", "pres", "ref", "rem", "zero", "ro", "ps", "i", "msg", "R", "results", "j", "ret", "chain", "reg", "rep", "crit", "x", "out", "Res", "RES", "sol", "p", "resolution", "err", "rev", "tx", "resh"], "nres": ["newr", "rr", "nRes", "cRES", "Nr", "ccons", "newres", " nchain", "nbres", "nr", "Nres", "cRes", "nbchain", "tRES", "tRes", "nchain", "tres", "Nchain", "Ncons", "Nrem", "cres", "rRES", "nrem", "nRES", "newRES", "nbrem", "tcons", "NRes", "ncons", "NRES", " nrem", "rres"], "common": ["data", "conf", "shared", "basic", "standard", "new", "Common", "m", "base", "known", "com", "total", "custom", "test", "c", "general", "name", "other", "local", "util", "tmp", "set", "main", "config", "initial", "default", "context", "module", "normal", "extra", "stable", "x", "generic", "old", "specific", "ctx", "cm", "all", "tc", "setup"], "t": ["ti", "s", "int", "tc", "ty", "ta", "to", "y", "w", "st", "f", "g", "m", "typ", "tw", "it", "l", "c", "z", "e", "k", "q", "tf", "time", "tt", "o", "j", "v", "ts", "x", "te", " tid", "type", "p", "d", "a", "h", "name"]}}
{"code": "\"\"\"Usage:\\n      pypy X.py < X-size.in > X-size.out\\n  or sometimes\\n      python X.py < X-size.in > X-size.out\\n  \"\"\"\\n  \\n  def setup(infile):\\n      return locals()\\n  \\n  def reader(testcase, infile, C=None, **ignore):\\n      P = map(int, infile.next().split())\\n      return locals()\\n  \\n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\\n  \\n      R, C, M = P\\n      MM = M\\n  \\n      F = np.array([['.'] * C] * R)\\n      while M > 0:\\n          if R >= C and M >= C and R > 2:\\n              M -= C\\n              R -= 1\\n              F[R] = '*'\\n          elif C > R  and M >= R and C > 2:\\n              M -= R\\n              C -= 1\\n              F[:, C] = '*'\\n          elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):\\n              if M < C - 1:\\n                  R -= 1\\n                  F[R, C - M:C] = '*'\\n              elif M < R - 1:\\n                  C -= 1\\n                  F[R - M:R, C] = '*'\\n              elif M == C - 1:\\n                  R -= 1\\n                  F[R, C - M + 1:C] = '*'\\n                  F[R - 1, C - 1] = '*'\\n              else:\\n                  C -= 1\\n                  F[R - M + 1:R, C] = '*'\\n                  F[R - 1, C - 1] = '*'\\n              M = 0\\n          elif M == R * C - 1:\\n              F[:, :] = '*'\\n              M = 0\\n          else:\\n              return 'Case #%s:\\n%s\\n' % (testcase, 'Impossible')\\n  \\n      F[0, 0] = 'c'\\n      assert (F == '*').sum() == MM\\n      return 'Case #%s:\\n%s\\n' % (testcase, '\\n'.join(''.join(f.tolist()) for f in F))\\n  \\n  if __name__ == '__main__':\\n      T = int(sys.stdin.next())\\n      common = setup(sys.stdin)\\n      for t in xrange(1, T+1):\\n          sys.stdout.write(solver(**reader(t, **common)))\\n", "target": "37", "substitutes": {"infile": ["innercase", "infp", "inile", "inFile", " inile", "inputile", "ginfp", "outfilename", "ginfile", "outcase", "insFile", "outile", "insfile", "outfp", "ginfilename", " infp", "infilename", "outfile", " infilename", "innerFile", "inscase", "ginFile", "inputfile", "incase", "inputfp", "outFile", "innerfile", "inputFile", "insfilename", " inFile", "innerfilename"], "testcase": [" testname", "caseCase", "testname", "testCase", "Testcase", "testcondition", " testCase", "Testkey", " testcondition", "testkey", " testkey", "casecase", "Testname", "casekey", "casename", "Testcondition", "casecondition", "TestCase"], "C": ["V", "CS", "G", "W", "CO", "Y", "CAR", "CG", "Mc", "c", "K", "JC", "CT", "E", "CA", "U", "CR", "Z", "CI", "CC", "MC", "B", "Car", "CB", "Ch", "Size", "Col", "WC", "SC", "Cr", "CL", "D", "YC", "Cs", "Type", "H", "Cl", "CD", "CP", "Cons", "Config", "Q", "CH", "Cu", "VC", "TC", "IC", "J", "COR", "Cut", "O", "CM", "DC", "A", "X", "EC", "L", "CW", "GC", "Con", "Co"], "P": ["V", "G", "PD", "J", "Y", "PT", "PS", "O", "B", "D", "PP", "PC", "H", "MP", "K", "TP", "A", "PR", "X", "E", "CP", "L", "U", "Q", "PO", "p", "PA", "Ps"], "N": ["Ns", "V", "G", "J", "Y", "n", "O", "B", "NS", "D", "Sn", "H", "K", "NN", "X", "E", "NT", "NC", "NR", "L", "FN", "Z"], "I": ["V", "G", "IC", "J", "SI", "O", "Ni", "B", "IP", "IO", "II", "IL", "H", "MI", "LI", "Is", "Si", "L", "DI", "Im", "IS", "IT", "TI", "Int", "i"], "T": ["V", "GT", "G", "W", "J", "TN", "t", "Y", "O", "B", "TF", "D", "TT", "TV", "Type", "H", "K", "TP", "A", "X", "E", "TS", "Ts", "WT", "NT", "L", "Q", "TR", "TM", "IT", "Z", "TC"], "S": ["V", "s", "Ns", "G", "TN", "Y", "SI", "SA", "O", "SN", "B", "NS", "SS", "H", "SU", "SL", "E", "Si", "Size", "L", "SH", "Q", "Z"], "R": ["V", "RS", "G", "Result", "RE", "ER", "W", "J", "OR", "Range", "Y", "Re", "RG", "O", "Right", "Dr", "B", "MR", "Rs", "D", "Ch", "H", "r", "RA", "K", "BR", "SR", "RC", "RGB", "RM", "Cl", "A", "Reader", "RT", "RO", "X", "E", "JR", "RR", "DR", "L", "U", "Rot", "CR", "Res", "TR", "Q", " r", "Cor", "AR", "Rat", "HR", "Br", "Z", "All"], "M": ["V", "Man", "Mon", "MED", "G", "ME", "MAN", "RE", "MT", "W", "J", "OR", "Y", "m", "O", "OM", "MF", "MC", "Mc", "B", "CM", "MR", "MN", "D", "Ch", "H", "MP", "K", "MI", "Ms", "IM", "MO", "LM", "Me", "RM", "MD", "A", "X", "E", "L", "PM", "U", "FM", "CR", "Mer", "TM", "MS", "AR", "MX", "NM", "MA", "VM", "DM", "AM", "Manager"], "MM": ["W", "OUR", "Mem", "CC", "Y", "MODE", "O", "MF", "MC", "mm", "Length", "ANY", "MP", "MI", "IM", "DF", "AME", "MD", "mmm", "OC", "Mode", "Full", "X", "EM", "OK", "Form", "L", "PM", "FM", "TM", "MS", "MB", "NM", "MW", "NO", "ALL"], "F": ["V", "G", "W", "FT", "J", "GF", "Fixed", "FS", "Function", "Fs", "AF", "BF", "Y", "Feed", "Frame", "FC", "O", "MF", "FI", "FB", "B", "File", "RF", "TF", "D", "CF", "EF", "FL", "FD", "IF", "Fi", "H", "DF", "A", "UF", "Full", "X", "E", "FO", "ELF", "FG", "WF", "Filter", "L", "U", "FP", "FM", "FN", "Q", "SF", "OF", "All", "PF", "FF", "FK", "FE"], "f": [" fu", "file", "cf", "t", "m", " cf", "sf", " ff", "test", "c", "h", "fs", " fe", "fe", "fb", "e", "aff", "fl", "tf", "fc", "fen", "xf", " fo", "uf", "alf", "rf", "field", "fi", "ff", "v", "x", "fd", "p", "fp", "df", "fm", "i", "lf", "form"]}}
{"code": "\\n  \\n  \\n  sys.setrecursionlimit(5000)\\n  \\n  INPUT = \"tiny\"\\n  INPUT = \"B-large.in\"\\n  INPUT = \"B-small-attempt0.in\"\\n  \\n  def debug(*args):\\n      return\\n      sys.stderr.write(str(args) + \"\\n\")\\n  \\n  class Memoize:\\n      def __init__(self,function):\\n          self._cache = {}\\n          self._callable = function\\n              \\n      def __call__(self, *args, **kwds):\\n          cache = self._cache\\n          key = self._getKey(*args,**kwds)\\n          try: return cache[key]\\n          except KeyError:\\n              cachedValue = cache[key] = self._callable(*args,**kwds)\\n              return cachedValue\\n      \\n      def _getKey(self,*args,**kwds):\\n          return kwds and (args, ImmutableDict(kwds)) or args    \\n  \\n  def do_trial(C, F, X, rate=2.0):\\n      win_time_wait = X / rate\\n      buy_time = C / rate\\n      win_time_buy_1 = buy_time + X / (rate+F)\\n      if win_time_wait < win_time_buy_1:\\n          return win_time_wait\\n      return buy_time + do_trial(C, F, X, rate+F)\\n  \\n  f = file(INPUT)\\n  T = int(f.readline()[:-1])\\n  for i in range(T):\\n      C, F, X = [float(x) for x in f.readline().split()]\\n      v = do_trial(C, F, X)\\n      print \"Case #%d: %s\" % (i+1, v)\\n", "target": "38", "substitutes": {"INPUT": ["inFILE", "inOUT", "OUTPUT", " INJECT", " OUTFILE", " INTABLE", "INHT", "inInput", " OUTFIX", "OUTFIX", "INInput", "INFILE", " INFILE", "OUTFILE", "INTABLE", "inPUT", " OUTHT", " INInput", " INFIX", "InFIX", "OUTInput", " INHT", "INFIX", "InTABLE", "InHT", " OUTJECT", "INJECT", " OUTTABLE", "INOUT", "OUTJECT", "OUTOUT", " INOUT", " OUTPUT", "InPUT", "InFILE"], "self": ["s", "spec", "req", "attr", "cl", "c", "full", "rs", "tmp", "resp", "ls", "q", "co", "sw", "me", "instance", "also", "w", "details", "agg", "partial", "r", "rec", "close", "parts", "sel", "prefix", "args", "replace", "p", "parent", "h", "func", "eth", "new", "ren", "n", "lex", "this", "py", "mp", "ref", "context", "add", "private", "nt", "requ", "github", "my", "python", "sys", "object", "subject", "th", "public", "handle", "view", "today", "dev", "Self", "remote", "init", "local", "user", "app", "config", "sq", "obj", "rel", "pkg", "params", "pre", "fields", "look", "ws", "cmp", "all", "your", "dd"], "function": ["FUN", "relation", "value", "python", "message", "object", "Function", "feature", "word", "functional", "condition", "partial", "closure", "call", "callback", "connection", "module", "normal", "handler", " Function", "description", "action", "fn", "package", "role", "command", "library", "method", "driver", "evaluate", "fun", "job", "func"], "_cache": ["_aches", "_c", "_Cache", "_session", "_case", " _case", " _Cache", " _session"], "_callable": ["_codant", "_callabe", "_capable", " _codor", " _codables", "_capor", "_callor", "_Callable", "_callant", "_codor", "_Callabe", "_capables", "_callables", " _callor", "_Callor", "_Callant", " _codant", "_calables", " _callables", " _callant", "_codable", "_capant", "_calant", "_calabe", "_codables", "_Callables", " _codable", "_calable"], "cache": ["cs", "ached", "master", "conf", "result", "cp", "members", "sche", "aches", "memory", "can", "c", "gc", "ac", "local", "mc", "map", "store", "db", "tmp", "config", "HE", "table", "auto", "co", "mem", "module", "hash", "cos", "dict", "cycle", "Cache", "remember", "chain", "storage", "force", "apache", "use", "wrapper", "ca", "cmp", "metadata", "api", "p", "ache", "h"], "key": ["title", "my", "result", "value", "match", "tag", "y", "input", "KEY", "pair", "new", "case", "primary", "it", "index", "member", "test", "owner", "kw", "Key", "keys", "k", "set", "where", "id", "entry", "path", "ey", "by", "hash", "source", "chain", "ek", "prefix", "prop", "cy", "ice", "page", "ip", "pick", "col", "next", "sum", "p", "item", "name", "label"], "cachedValue": ["cachedVal", "cachedResult", "Codedvalue", "curyptedItem", "cazyvalue", "cachableItem", "cachedItem", "cuachedResult", "codedVal", "cachingClass", "cachingValue", "cachableValue", "cappedVALUE", "cryptedValue", "curyptedVALUE", "cachedvalue", "codedValue", "codedvalue", "cachingvalue", "cuachedItem", "cryptedResult", "CodedVal", "CachedValue", "cappedValue", "curyptedValue", "cuachedVALUE", "cachableVALUE", "cachedVALUE", "cazyClass", "curyptedResult", "CodedValue", "cachedClass", "cachableResult", "CachedVal", "cryptedItem", "cuachedValue", "cryptedVALUE", "cappedResult", "cappedItem", "cachingVal", "codedClass", "CachedClass", "cazyVal", "CodedClass", "cazyValue", "Cachedvalue"], "C": ["V", "AC", "CS", "Cond", "G", "CI", "CV", "P", "W", "CNN", "CC", "CO", "Y", "CG", "N", "M", "O", "Mc", "Count", "MC", "B", "c", "CM", "Control", "D", "CB", "YC", "CF", "Ch", "H", "K", "CE", "LC", "CT", "JC", "Cl", "CU", "DC", "A", "I", "R", "EC", "E", "Cache", "CA", "S", "CP", "NC", "L", "U", "Config", "CR", "KC", "CN", "TC", "Co", "Craig", "SC"], "F": ["V", "G", "W", "P", "FK", "FT", "J", "GF", "FW", "FR", "Fixed", "FS", "Function", "Factor", "Y", "Fs", "Feed", "N", "Def", "FC", "M", "FI", "B", "File", "RF", "Foreign", "D", "EF", "CF", "FL", "Factory", "FD", "IF", "H", "K", "DF", "UF", "I", "Full", "R", "E", "S", "FG", "Field", "WF", "L", "U", "FP", "Rate", "FN", "SF", "HF", "PF", "FF", "Family", "FA", "FE"], "X": ["V", "Tx", "W", "P", "IC", "Time", "J", "TX", "FX", "XY", "Y", "N", "EX", "PE", "HTTP", "XL", "FE", "WH", "H", "K", "IX", "XX", "Cross", "DX", "I", "R", "E", "S", "L", "Rate", "U", "IR", "UX", "XP", "Q", "XT", "OX", "MX", "Z", "ZX", "Ex", "ICE"], "rate": ["range", "fps", "sample", "value", "power", "rates", "cr", "rice", "core", "domain", "trade", "timeout", "size", "frequency", "pe", "zip", "mode", "prime", "t", "sync", "fee", "Y", "case", "base", "ric", "capacity", "rat", "test", "rand", "beta", "market", "fine", "unit", "rank", "buy", "re", "r", "ride", "time", "rule", "R", "cycle", "pay", "count", "currency", "force", "Rate", "erate", "transfer", "race", "weight", "speed", "feed", "delay", "scale", "type", "price", "factor"], "win_time_wait": ["win_TIME_wait", "win_time_ait", "win_time_status", "win_time_hold", "win_TIME_wa", "win_TIME_delay", "win_TIME_ait", "win_time_wa", "win_time_Wait", "win_time_delay"], "buy_time": ["buy2wait", "buy_Time", "buy_rate", "buy1time", "buy1wait", "Buy_times", "buyxTime", "buy_value", "buy1rate", "buy1Time", "buy2time", "sell_timeout", "buyjTime", "sell_time", "buyxtime", "buyjdelay", "buyjtime", "bid_wait", "buy_wait", "Buy_Time", "buy_times", "bid_time", "sell_value", "buyjtimes", "sell_Time", "bid_rate", "buy_delay", "buy2Time", "buyxtimeout", "bid_Time", "Buy_time", "buy_timeout", "Buy_delay", "buy2rate", "buyxvalue"], "win_time_buy_1": ["win_time_sell_2", "win_time_buy_0", "win_time_buy_2", "win_time_sell_1", "win_time_buy_time", "win_time_buy_one", "win_time_sell_time", "win_time_sell_one"], "f": ["af", "file", "cf", "input", "w", "t", "g", "fast", "l", "ft", "sf", "c", "fs", "bf", "fb", "fe", "e", "fl", "r", "tf", "b", "fc", "fo", "fa", "xf", "uf", "alf", "rf", "fw", "fd", "fr", "feed", "df", "p", "fp", "h", "fm", "lf", "form"], "T": ["V", "GT", "G", "W", "TB", "P", "J", "TN", "t", "Y", "N", "M", "B", "TA", "D", "TT", "TV", "TY", "K", "A", "I", "R", "E", "TS", "S", "NT", "L", "TH", "TR", "Q", "TM", "VT", "IT", "TI", "TC"], "i": ["ti", "s", "ini", "u", "y", "ic", "w", "t", "pi", "li", "m", "xi", "n", "it", "l", "c", "bi", "e", "k", "q", "r", "b", "I", "si", "j", "mi", "di", "gi", "ip", "ii", "me", "ci", "p", "d", "a", "h"], "x": ["mx", "ax", "y", "xs", "xt", "t", "xe", "xd", "xi", "xp", "n", "ix", "xa", "fx", "z", "xy", "e", "rx", "plex", "xb", "px", "xf", "rax", "xx", "cross", "dx", "wx", "ox", " ax", "ex", "p", "ux", "xc", "tx"], "v": ["V", "value", "sv", "u", "y", "w", "t", "cv", "m", "g", "tv", "n", "vv", "c", "nv", "ev", "e", "uv", "ve", "vt", "lv", "var", "b", "vi", "vs", "ver", "qv", "vy", "vp", "NV", "val", "p", "d", "values", "vm"]}}
{"code": "\\n  \\n  \\n  \\n  INPUT = \"tiny\"\\n  INPUT = \"C-small-attempt1.in\"\\n  \\n  def debug(*args):\\n      sys.stderr.write(str(args) + \"\\n\")\\n  \\n  class Memoize:\\n      def __init__(self,function):\\n          self._cache = {}\\n          self._callable = function\\n              \\n      def __call__(self, *args, **kwds):\\n          cache = self._cache\\n          key = self._getKey(*args,**kwds)\\n          try: return cache[key]\\n          except KeyError:\\n              cachedValue = cache[key] = self._callable(*args,**kwds)\\n              return cachedValue\\n      \\n      def _getKey(self,*args,**kwds):\\n          return kwds and (args, ImmutableDict(kwds)) or args    \\n  \\n  IMPOSSIBLE = set([(2,2,2), (2,2,1), (2,3,1), (2,4,1), (2,5,1)])\\n  \\n  for i in range(2,51):\\n      IMPOSSIBLE.add((2,i,1))\\n      IMPOSSIBLE.add((i,2,1))\\n  \\n  SOLN = {\\n      (1,2,1) : [\"c*\"],\\n      (2,1,1) : [\"c\", \"*\"],\\n      (2,2,3) : [\"c*\", \"**\"],\\n  }\\n  \\n  def solve(R, C, M):\\n      if M == 0:\\n          s = [\"c%s\" % ('.' * (C-1))]\\n          for i in range(R-1):\\n              s.append('.' * C)\\n          return s\\n      t = (R, C, M)\\n      if t in IMPOSSIBLE:\\n          debug(\"** %s %s %s\" % t)\\n          raise ValueError\\n      if t in SOLN:\\n          return SOLN[t]\\n  \\n      if C < M and R > 2:\\n          try:\\n              return solve(R-1, C, M-C) + [\"*\" * C]\\n          except ValueError:\\n              pass\\n  \\n      if C <= R:\\n          if M >= C and R > 2:\\n              return solve(R-1, C, M-C) + [\"*\" * C]\\n      else:\\n          if M >= R and C > 2:\\n              return [\"%s*\" % s for s in solve(R, C-1, M-R)]\\n      if R > 2:\\n          mines = min(C, M)\\n          if mines == C - 1:\\n              mines -= 1\\n          try:\\n              return solve(R-1, C, M-mines) + [(\".\" * (C - mines)) + (\"*\" * mines)]\\n          except ValueError:\\n              if C > 2:\\n                  mines = min(R, M)\\n              if mines == R - 1:\\n                  mines -= 1\\n              s = [\"%s%s\" % (s, '*' if k > C-mines else '.') for k, s in enumerate(solve(R, C-1, M-mines))]\\n              return s\\n      debug(R, C, M)\\n      return []\\n  \\n  def do_trial(R, C, M):\\n      try:\\n          r = solve(R,C,M)\\n          s = \"\\n\" + '\\n'.join(r)\\n          assert len(r) == R\\n          for r1 in r:\\n              assert len(r1) == C\\n          assert len(''.join(k for k in s if k == '*')) == M\\n          return s\\n      except ValueError:\\n          return \"\\nImpossible\"\\n  \\n  \\n  def all():\\n      for R in range(1,50):\\n          for C in range(1,50):\\n              for M in range(R*C):\\n                  print(R, C, M)\\n                  print(do_trial(R, C, M))\\n      sys.exit(0)\\n  \\n  \\n  f = file(INPUT)\\n  T = int(f.readline()[:-1])\\n  for i in range(T):\\n      R, C, M = [int(x) for x in f.readline().split()]\\n      v = do_trial(R, C, M)\\n      print \"Case #%d: %s\" % (i+1, v)\\n", "target": "38", "substitutes": {"INPUT": ["InST", "OUTPUT", " INJECT", "OUTP", "INHT", " OUTFIX", "INP", "inP", "inJECT", "inPUT", "InP", " OUTHT", " INFIX", "InFIX", "inST", " INHT", "INFIX", "OUTST", "InHT", "INST", "INJECT", "OUTJECT", "InJECT", " OUTPUT", "InPUT", " OUTJECT"], "self": ["spec", "req", "cl", "full", "rs", "tmp", "resp", "ls", "q", "sw", "me", "console", "instance", "also", "w", "details", "agg", "client", "default", "left", "rec", "se", "close", "responsible", "prefix", "print", "args", "replace", "p", "exp", "h", "func", "eth", "new", "ren", "n", "lex", "this", "py", "mp", "ref", "rem", "review", "add", "private", "nt", "requ", "reader", "github", "you", "final", "my", "python", "object", "subject", "np", "th", "public", "handle", "dev", "Self", "weak", "remote", "local", "user", "app", "config", "obj", "rel", "pkg", "params", "pre", "ws", "cmp", "your"], "function": ["FUN", "value", "python", "object", "Function", "feature", "word", "functional", "what", "partial", "closure", "call", "callback", "connection", "initial", "module", "normal", "handler", " Function", "number", "component", "action", "fn", "never", "role", "F", "command", "library", "method", "evaluate", "string", "fun", "func"], "_cache": ["_root", "_Cache", "__cache", "__Cache", "__root", "_ac", "__ache", "_chain", "_ache", "_key"], "_callable": ["_cabe", "_drawable", "_cacheable", "_callabe", "_actionabe", "_drawation", "_cable", "_Callable", "_variation", "_callables", "_variABLE", "_variable", "_CallABLE", "_Callation", "_callback", "_callation", "_actionback", "_callABLE", "_drawABLE", "_actionable", "_cacheback", "_cables", "_cacheabe", "_caller", "_actionables", "_cback", "_drawer", "_cacheables", "_Caller", "_varier"], "cache": ["cs", "ached", "master", "conf", "match", "cp", "aches", "case", "memory", "can", "index", "c", "gc", "ac", "local", "mc", "map", "set", "db", "store", "config", "HE", "tmp", "table", "call", "auto", "co", "mem", "miss", "go", "see", "hash", "cos", "dict", "close", "cycle", "Cache", "remember", "chain", "force", "use", "wrapper", "cmp", "parse", "metadata", "cm", "p", "driver", "ache"], "key": ["title", "my", "tag", "value", "match", "y", "KEY", "pair", "new", "case", "primary", "it", "index", "member", "test", "owner", "kw", "Key", "keys", "set", "where", "id", "client", "entry", "oto", "path", "ey", "by", "hash", "ter", "slot", "chain", "ek", "prefix", "te", "foo", "page", "row", "next", "val", "item", "name"], "cachedValue": ["tavedValues", "tavedVALUE", "Codedvalue", "codedCurrent", "cacherValue", "codedVALUE", "cashedvalue", "cachedValues", "cashedVALUE", "cachableValue", "cachedvalue", "codedValue", "cacherVALUE", "codedvalue", "tavedvalue", "tachedVALUE", "cavedValues", "CodedCurrent", "tavedValue", "cachervalue", "cacherCurrent", "CachedValue", "cachableVALUE", "cachedCurrent", "cachedVALUE", "cavedValue", "CodedValue", "cavedvalue", "CachedCurrent", "tachedvalue", "codedValues", "CachedVALUE", "cavedVALUE", "CodedVALUE", "tachedValues", "cachablevalue", "cashedValues", "cachableCurrent", "cashedValue", "tachedValue", "Cachedvalue"], "IMPOSSIBLE": ["IMFPOSible", "IMTPOSSABLE", "IMSPESSABLE", "IMPossible", "IMPESSibles", "IMPOSSible", "IMFPOSibility", "IMPPOSSIBLE", "IMPPESSible", "IMPESSIBLE", "IMPASSABLE", "IMTPossibility", "IMSPOSSibles", "IMPOSBILITY", "IMPOSible", "IMPESSible", "IMPOSIBLE", "IMTPOSSibility", "IMTPOSSIBLE", "IMPASSibles", "IMPOSSBILITY", "IMPPESSibles", "IMPPOSSibles", "IMPossBILITY", "IMPASSIBLE", "IMTPossBILITY", "IMPESSibility", "IMPossABLE", "IMPossibles", "IMPPESSIBLE", "IMSPOSSABLE", "IMPOSSibles", "IMPPESSABLE", "IMPOSibility", "IMPossIBLE", "IMTPossIBLE", "IMPASSible", "IMSPOSSible", "IMPOSSABLE", "IMTPOSSBILITY", "IMPOSSibility", "IMPESSABLE", "IMPOSTIBLE", "IMPOSABLE", "IMFPOSSible", "IMSPESSIBLE", "IMTPossABLE", "IMFPOSSBILITY", "IMFPOSBILITY", "IMPESSBILITY", "IMFPOSSibility", "IMFPOSSIBLE", "IMFPOSIBLE", "IMPPOSSible", "IMPOSTibility", "IMPPOSSABLE", "IMSPESSibles", "IMPOSTBILITY", "IMSPESSible", "IMSPOSSIBLE", "IMPossibility", "IMPOSTABLE"], "i": ["ti", "int", "ic", "y", "ind", "pi", "m", "li", "xi", "it", "n", "l", "index", "c", "bi", "z", "e", "id", "ij", "ai", "b", "phi", "im", "o", "I", "si", "j", "mi", "di", "gi", "ip", "ii", "p", "ci", "d", "io"], "SOLN": [" SOTM", "SILNG", "SOLNT", "SALMN", "SOOLNG", "SILM", " SOTN", " SOLNG", "SUNMN", "SOLMN", "SolNT", "SALN", "MOLG", "SILNT", "MolNT", "MOLNG", "SUNNS", "SILMN", "SOOLN", "SULNT", "SULNG", "SSILNS", " SOTNT", "SOTNT", "MOLN", "SALNS", "SULN", "SSILMN", "SILN", "MolN", "SUNN", "SOOLG", "SOLNG", "SSOLMN", "SOTN", "MolNG", " SOLM", "SALNT", "SALNG", "SOLG", "SOTM", " SOLNT", "SOLM", "SolN", "SSOLN", "SSILN", "SILNS", "SolNG", "SALM", "SOLNS", "SOTNG", "SSOLNS", " SOTNG", "SolG", "MOLNT", "MolG", "SULG", "SOOLNT"], "R": ["V", "RS", "G", "P", "RE", "W", "J", "Range", "Y", "RG", "N", "Right", "O", "B", "MR", "GR", "Rs", "D", "RA", "BR", "H", "RC", "SR", "RM", "A", "RT", "I", "RO", "X", "E", "RI", "S", "NR", "RR", "DR", "L", "F", "U", "CR", "IR", "Res", "TR", "Q", "Rat", "AR"], "C": ["V", "AC", "CS", "G", "CV", "P", "RE", "Chain", "W", "IC", "COR", "CC", "CO", "Y", "CG", "N", "O", "Mc", "MC", "B", "c", "CM", "Car", "D", "CF", "Ch", "H", "K", "CCC", "CT", "You", "RM", "CU", "Cl", "A", "DC", "CD", "I", "X", "E", "CP", "CA", "S", "L", "F", "U", "CR", "Q", "AR", "VC", "TC", "Co", "This"], "M": ["V", "G", "MAN", "W", "P", "MT", "RE", "J", "Multi", "Y", "m", "N", "O", "Mc", "MC", "B", "CM", "MR", "D", "H", "K", "MI", "IM", "MD", "RM", "A", "I", "X", "E", "MAT", "S", "Size", "L", "F", "U", "Q", "TM", "MS", "AR", "MM", "MA", "AM"], "s": ["os", "string", "sv", "sys", "sts", "ds", "ed", "w", "gets", "m", "g", "spec", "n", "c", "fs", "its", "js", "rs", "ns", "set", "ss", "ls", "sign", "gs", "b", "ps", "es", "ses", "bs", "S", "ts", "qs", "str", "er", "tests", "sb", "sol", "abs", "strings", "als", "type", "p", "rows", "a", "ins", "h", "seconds", "sets"], "t": ["ti", "title", "rt", "to", "ta", "y", "tes", "w", "new", "tr", "g", "m", "tw", "st", "n", "it", "l", "lat", "c", "txt", "opt", "mt", "e", "set", "TT", "gt", "fort", "tt", "b", "TW", "o", "tg", "j", "nt", "Ts", "ret", "ts", "str", "te", "out", "alt", "tif", "dt", "lt", "type", "p", "d", "ct", "a", "TI", "h", "tc", "wt", "ot", "td"]}}
{"code": "T = int(raw_input());\\n  for q in range(T):\\n      [C,F,X] = map(float, raw_input().split());\\n  \\n  \\n      Time = 0.;\\n      Rate = 2.;\\n      Fin = False;\\n      while (not Fin):\\n          t0 = X/Rate;\\n          t1 = C/Rate + X/(Rate+F);\\n  \\n          if t0 <= t1:\\n              Time += t0;\\n              Fin = True;\\n          else:\\n              Time += C/Rate;\\n              Rate += F;\\n  \\n      print \"Case #%d:\" % (q+1),;\\n      print \"%.7f\" % Time;\\n      \\n          \\n", "target": "39", "substitutes": {"T": ["V", "GT", "G", "P", "TN", "t", "Y", "N", "M", "O", "B", "TA", "D", "TIME", "TT", "TV", "K", "TP", "A", "I", "R", "E", "TS", "S", "NT", "L", "Q", "TR", "TM", "Z", "TC"], "q": [" u", " p", "t", "f", "g", "m", "eq", "n", " f", "qu", "ix", "dq", "c", "z", "query", " k", "k", "sq", "r", "ck", "j", " v", " qu", "qi", "requ", "v", "aq", " j", " Q", "qs", "x", " eq", "quant", "qq", " seq", "Q", "p", "d", "i", "iq", "qt"], "C": ["V", "CS", "G", "CI", "P", "CC", "Y", "N", "M", "B", "CM", "c", "D", "CF", "H", "K", "CT", "DC", "A", "CD", "I", "R", "E", "CP", "CA", "S", "L", "U", "CR", "Q", "TC", "Co"], "F": ["V", "G", "W", "P", "FT", "J", "FW", "FR", "Fs", "f", "Y", "FER", "N", "M", "FC", "Float", "B", "TF", "D", "FL", "FD", "IF", "H", "DF", "A", "UF", "I", "R", "E", "FO", "S", "FG", "L", "U", "FP", "Q", "Z", "FF", "FE"], "X": ["V", "Tx", "W", "P", "TX", "Y", "N", "M", "O", "B", "D", "CF", "XL", "H", "K", "IX", "XX", "A", "DX", "I", "R", "E", "S", "U", "x", "L", "XP", "Q", "OX", "Z", "XXX", "Ex", "Int", "FE"], "Time": ["Times", "Age", "Root", "Clock", "Duration", "Tim", "Date", "Finish", "Value", "Timeout", "Total", "Speed", "Frame", "Count", "Instant", "Token", "File", "TIME", "TT", "Length", "Point", "Type", "Now", "Temp", "Start", "Current", "time", "Position", "Message", "Memory", "Data", "TS", "Version", "Offset", "Size", "Form", "U", "Q", "TM", "Timer", "Context", "IME", "Runtime", "Format", "Path"], "Rate": ["Gate", "Base", "RE", "Chain", "Multiple", "Duration", "Core", "Function", "Cause", "Factor", "Policy", "Range", "Y", "Scale", "Average", "rate", "Speed", "Process", "N", "Rule", "Float", "Rank", "Count", "M", "Code", "Frame", "Chance", "Strength", "IO", "Channel", "Report", "D", "Service", "Length", "FD", "Type", "Hz", "Memory", " rate", "R", "Family", "Sample", "Force", "Performance", "Size", "Power", "GHz", "Audio", "Q", "State", "Rat", "IME", "Runtime", "Random", "Reward", "Pause", "Weight", "Amount", "Rating", "Prime", "Per", "Reason", "Method"], "Fin": ["Fram", "Bur", "Front", "Written", "Boot", "Sent", "Tr", "Fre", "Reg", "Fs", "Finish", "Last", "Ev", "Dr", "Fl", "Done", "Ret", "fin", "Weak", "Fr", "Writ", "Finally", "Gr", "Financial", "Final", "Low", "Cl", "Wh", "Good", "Fe", "Dur", "Crit", "Conf", "Sup", "Cons", "FIN", "Foot", "Pol", "FP", "Fun", "Res", "Fore", "Syn", "Qu", "Ok", "St"], "t0": ["at8", "T2", "at1", "tor", "T0", "T8", "tp2", "tc2", "T02", "tc0", "time0", "ts1", "at0", "tsor", "t2", "ts0", "t000", "td6", "time1", "T000", "ator", "T1", "Tor", "tc000", "tc02", " t6", "tp02", "tp0", "td1", "tdne", "tp000", "ts8", "tne", "td0", "timene", "t8", "t02", "t6", " tne", "time6"], "t1": ["tt0", "tree0", "T6", "tOne", "T0", "tree1", "tt6", " t81", "tree81", "ttOne", "T1", " t6", "tt1", "treeOne", "T81", "t81", "t6", "TOne", " tOne"]}}
{"code": "def Trivial(R,C,char):\\n      for i in range(R):\\n          Ans = '';\\n          for j in range(C):\\n              if (i==j==0):\\n                  Ans += 'c';\\n              else:\\n                  Ans += char;\\n          print Ans;\\n  \\n  \\n  def Draw1(R,C,Blank):\\n      Ans = \"c\";\\n      for i in range(Blank-1):\\n          Ans += '.';\\n      for i in range(R*C-Blank):\\n          Ans += '*';\\n      if (R == 1):\\n          print Ans;        \\n          return;\\n      if (C == 1):\\n          for i in range(len(Ans)):\\n              print Ans[i];\\n  \\n  def Draw2(R,C,Blank):\\n      if (Blank%2 != 0) or (Blank == 2):\\n          print \"Impossible\";\\n          return;\\n      Row1 = '.'*(Blank/2) + '*'*(Mine/2);\\n      Row0 = 'c' + Row1[1:];\\n      if R==2:\\n          print Row0;\\n          print Row1;\\n      else:\\n          for i in range(len(Row0)):\\n              print Row0[i]+Row1[i];\\n      return;\\n  \\n  \\n  def Generate(R, C, Blank):\\n      TODO = Blank;\\n      Spaces = [0]*R;\\n      if TODO <= 2*C:\\n          if TODO%2 == 0:\\n              Spaces[0] = TODO/2;\\n              Spaces[1] = TODO-Spaces[0];\\n          else:\\n              if (TODO == 7):\\n                  Spaces[0] = 3;\\n                  Spaces[1] = 2;\\n                  Spaces[2] = 2;\\n              else:\\n                  Spaces[0] = (TODO-3)/2;\\n                  Spaces[1] = (TODO-3)/2;\\n                  Spaces[2] = 3;\\n      else:\\n          row = 0;\\n          if (TODO >= 2*C+2):\\n              Spaces[0] = C;\\n              Spaces[1] = C;\\n              TODO -= 2*C;\\n              row = 2;\\n              \\n          while TODO > C+1:\\n              if (TODO == 2*C+1) and (C != 3):\\n                  Spaces[row] = C-1;\\n                  Spaces[row+1] = C-1;\\n                  Spaces[row+2] = 3;\\n                  TODO = 0;\\n              else:\\n                  Spaces[row] = C;\\n                  TODO -= C;\\n                  row += 1;\\n          if (TODO == C+1):\\n              Spaces[row] += C-1;\\n              Spaces[row+1] = 2;\\n              TODO = 0;\\n          Spaces[row] += TODO;\\n  \\n      for r in range(R):\\n          Ans = '.'*Spaces[r] + '*'*(C-Spaces[r]);\\n          if r == 0:\\n              Ans = 'c'+Ans[1:];\\n          print Ans;\\n  \\n  \\n  def Solve(R, C, M):\\n      Blank = R*C-M;\\n      if Blank == 0:\\n          print \"Impossible\";\\n          return;\\n  \\n      if (Blank == 1):\\n          Trivial(R,C,'*');\\n          return\\n      if (Blank == R*C):\\n          Trivial(R,C,'.');\\n          return\\n  \\n      if (R == 1) or (C == 1):\\n            Draw1(R,C,Blank);\\n            return\\n  \\n      if (R-2)*(C-2) == 0:\\n          Draw2(R,C,Blank);\\n          return\\n  \\n      if Blank in [2,3,5,7]:\\n          print \"Impossible\";\\n          return;\\n      \\n      if (R >= 3) and (C >= 3):\\n          Generate(R, C, Blank);\\n  \\n      return;\\n  \\n  \\n  T = int(raw_input());\\n  for q in range(T):\\n      [Row,Col,Mine] = map(int, raw_input().split());\\n  \\n      Blanks = Row*Col - Mine;\\n      \\n      print \"Case #%d:\" % (q+1)\\n      Solve(Row, Col, Mine);\\n      \\n          \\n", "target": "39", "substitutes": {"R": ["V", "RS", "G", "P", "W", "RE", "J", "Remote", "Range", "Y", "Reg", "RG", "N", "O", "Right", "B", "MR", "RF", "GR", "Rs", "D", "Char", "Length", "RL", "H", "RA", "BR", "RC", "SR", "K", "RM", "A", "RT", "I", "RO", "X", "E", "RI", "S", "RR", "DR", "NR", "L", "F", "U", "Rot", "CR", "RW", "Res", "TR", "Q", "Rat", "AR", "HR"], "C": ["V", "CS", "G", "W", "CV", "CO", "Y", "CG", "Count", "c", "CF", "K", "JC", "CT", "Color", "E", "U", "CBS", "CR", "CN", "Craig", "Counter", "CI", "CC", "N", "B", "CB", "Char", "Ch", "CE", "CU", "I", "S", "F", "WC", "SC", "CHAR", "CNN", "Cr", "D", "YC", "Cs", "H", "CD", "CP", "Cache", "Q", "CH", "VC", "New", "TC", "AC", "P", "Chain", "J", "COR", "Cow", "O", "HC", "CM", "CCC", "DC", "A", "X", "EC", "BC", "L", "CON", "Co"], "char": ["int", "CHAR", "short", "ch", "tr", "f", "word", "letters", "cell", "attr", "text", "com", "c", "color", "car", "user", "Char", "Ch", "hex", "ar", "cur", "escape", "start", "ter", "Character", "character", "utf", "v", "ctr", "letter", "str", "cat", "star", "a", "name", "string"], "i": ["s", "ini", "u", "t", "g", "it", "l", "c", "k", "ir", "b", "batch", "v", "di", "a", "io", "int", "li", "ie", "index", "il", "e", "zi", "iu", "ri", "I", "ii", "p", "exp", "ei", "ki", "pi", "f", "m", "xi", "n", "bi", "id", "ai", "phi", "si", "mi", "ati", "ia", "ib", "\u0438", "col", "ci", "iti", "oi", "ti", "ch", "ic", "y", "ind", "ix", "ij", "im", "ui", "info", "fi", "x", "gi", "ip"], "Ans": ["ANs", "Arls", "Anr", "Anses", " Ansi", "Auths", "Anns", "AntS", "Arn", "Asi", "Annls", "ANcs", "Acs", "EnS", "Ats", "ANns", " AnS", " Ann", "Animsi", "Authcs", "Ens", "ANses", "Annns", "Ansi", "Anps", "Ants", "Ancs", "Canns", "Annges", "Anims", "AnS", "Acsi", "Arcs", "Authses", " Anc", "Ann", "ANps", "Authts", " Anses", "As", "Ar", "ANls", "Antps", "Anls", "anns", "annc", "Acn", " Anges", " Anns", "An", "Als", "Canls", "Enns", "Anges", "ANc", "ANS", "Acls", "Enps", "Animn", "ANts", " Ancs", "Animr", "Ars", "Cancs", "Anc", " Anr", "ANsi", "Canges", "AuthS", "annls", "Antns", " Anls", "Cans", "annns", "ANr", "ANn"], "j": ["jl", "s", "ja", "J", "jj", "ch", "iaz", "len", "ind", "t", "f", "g", "n", "cell", "it", "l", "ix", "c", "aj", "bi", "z", " ii", "e", "k", "ij", "jc", "jac", "co", "b", "uni", "o", "bc", "I", "v", "ik", "uj", "col", "p", "ji", "d", "a", "Ja", "iq", "oj"], "Blank": ["Blanking", "Blark", "blanking", "blANK", " BlANK", "Black", "BLanking", "Spank", "SpANK", "BLanks", "BLark", "Blunk", "blank", "SlANK", "Blork", "BLink", "Blull", "Brank", "Slank", "Spanking", " Blanking", "Clack", "Spark", "Clan", "BlANK", "Lork", " Blork", "Branking", "ClANK", "BLack", "Slan", "Clunk", " Blull", "Spink", "BLork", "Spanks", "BLANK", " Blark", "Clank", "Clark", "Clanking", "Blink", " Blink", "Lull", "blark", "BLank", "Lanking", "Brack", "Slunk", "BLunk", "blanks", "Lanks", "BrANK", "LANK", "Brark", "Blan", "Spull", "BLan", "Lank"], "Row1": ["row2", "rowN", "row3", "Line0", "Block2", "LineOne", " RowN", "Line1", "rowOne", "LineN", " Row3", "Block1", "Line2", "Line3", " RowOne", "Row2", "row0", "RowOne", "row1", "RowN", "Block0", "Block3", " Row2", "Row3"], "Row0": ["RowSource", "row2", "rowSource", "R0", "BlockStart", "row6", "Grid6", "Line0", "Block2", "R2", "Line1", "R3", "Grid1", "BlockSource", " Row3", "Block1", "Line2", "Line3", "Grid0", "Row2", "row0", "LineStart", " Row6", "row1", " RowSource", "R1", "Block0", "Row6", "RowStart", " Row2", " RowStart", "Row3"], "TODO": [" TOKY", "TODEOS", "PTODOS", "Dodo", "TADO", "TUDOS", "TARKo", " TODOS", " TODPO", "TOMON", "TTYo", " TIDOS", "TODEO", "TOKE", "TOLOGo", " TOTS", " TOTO", "PTodPO", "TODPO", "GODO", "TARKO", "TOTE", "TOKOD", "PTodOs", "GUDE", "PTodO", "TIDO", "TOKOX", "TUDOG", "TodOE", "DodO", "TOTOs", "TODOs", "TodO", "TOKOs", " TODOs", "TOMOO", "GODOG", "tTYOD", "PTODOD", " TODOO", "TDDOD", "TADPO", "TodOC", "PTodOE", "TIDOD", " TADOO", "TODo", "TOTO", " TODo", "THPDO", "THODo", "PTodOD", "TUDO", "TTODON", " TOTE", "TOKS", "TADOO", "TodPO", "TodON", "tTYO", "GUDOG", "TARKOC", "TOLOGO", "TodOG", "TODON", "TODOX", "TodOS", "TODE", "TPDPO", "TodY", " TODY", "TOKOS", "TOTY", "TDDO", "TODOG", "tODOD", "TOMOs", "Todo", "TOMO", "GUDO", "TOLOGOE", "TODOO", " TADOS", "TTYE", "TPDE", "TTYOD", "DodOs", " TIDo", " TOTOs", "TOKOC", "TTodO", "TOTPO", "TodOO", "TOTOG", "TODEOO", "TOKPO", "TTODOO", "TOKOO", "TPDOG", " TOTo", "TTODO", "PTODPO", "DODo", "PTodOS", "TARKOs", "TTYO", "TOTo", "TOKO", "TODEOs", "TOKo", "TTODOs", "TodS", "tODO", " TODS", "TOKOE", " TODOD", " TOKO", "TODOC", "tTYo", "THODO", "DODO", "TODY", "tODo", "PTODOs", "TIDOS", " TADPO", " TOKPO", "TODOS", "TODEPO", "GODE", "THODOG", "TODS", " TIDO", "DODOC", "DodOC", "TODOE", "TPDOs", " TIDOD", "TOTS", "TTYOX", "THPDOG", "TPDOS", "TADOS", "TodOs", "PTodo", "TTYOs", "PTODo", "TOKY", "TodOD", " TADO", "TUDOD", "TOKOG", "TDDo", "TDDOX", "TUDo", "THPDo", "DODOs", "TUDE", "TOLOGOD", "TODOD", "PTODOE", "TTodON", "PTODO", " TOKo", "TODEON", "TIDo", "TPDo", "TTodOs", "tODOX", "TTodOO", " TODE", "tTYOX", "TPDO"], "Spaces": ["Sprpaces", " Spinks", "SPans", "Prels", "Palaces", " Spacing", "Staces", "Trabs", "Prikes", "Variacs", "Sppaces", " Spacs", "SPacs", "Stans", "spabs", "Variaces", "Profaces", "Placs", "Slots", "Compaces", "Profots", " Spaps", "SPacing", "Prans", "Blacing", " Spabs", "Compacing", "Spans", "spans", "sppaces", "Prouses", "SPaces", "Profacs", "Profinks", "Prices", "Spots", "Stracs", " Spikes", "Prents", "Prabs", "Palacs", "spaps", "Spabs", "SPpaces", "Slpaces", "Blaps", "Slaces", "Exppaces", "Tracs", "Spices", "Compots", "Blices", "Palikes", "Strpaces", "Spels", "Profpaces", "Strouses", "Prots", "spacing", "Spinks", "Spacing", "Stacs", "Sprents", "Prpaces", "Praps", "Pracing", "Spracs", "spaces", "Spikes", "Profouses", "Variabs", "Spraces", "Plpaces", " Spels", "Palels", "Staps", "Trices", "Spacs", "Spents", "Varipaces", "SPices", "Slacs", " Spents", "Praces", " Spices", "Places", "Stacing", " Spouses", " Sppaces", "SPaps", "Plans", "Compacs", "Spouses", " Spans", "Expaces", "Straces", "Spaps", "spices", "Expouses", "Traces", "Blaces", "Stpaces", "spacs", "Expinks", " Spots", "Stices", "Pracs"], "row": ["length", "value", "month", "size", "y", "tr", "week", "pad", "channel", "cell", "offset", "key", "index", "user", "pos", "iter", "column", "table", "entry", "group", "batch", "block", "no", "mod", "raw", "line", "field", "scroll", "dirty", "x", "num", "page", "ow", "server", "roll", "level", "right", "col", "next", "tab", "all", "rows", "round", "item", "post", "lo", "record"], "Mine": ["AC", "Coin", "Double", "COR", "empty", "Cr", "Max", "CG", "Fill", "White", "RAW", "Circ", "black", "Empty", "CCC", "Content", "Roman", "red", "Text", "self", "Cat", "star", "MAX", "Random", "Normal", "New", "Ruby", "Red"]}}
{"code": "\\n  \\n  def process(C, F, X):\\n  \tspeed = 2.0\\n  \ttime = 0.0\\n  \twhile True:\\n  \t\tif C / speed + X / (speed + F) > X / speed:\\n  \t\t\ttime += X / speed\\n  \t\t\tbreak\\n  \t\ttime += C / speed\\n  \t\tspeed += F\\n  \treturn round(time, 7)\\n  \\n  input_file = open(sys.argv[1], 'r')\\n  T = int(input_file.readline())\\n  for i in range(T):\\n  \t(C, F, X) = map(float, input_file.readline().split())\\n  \tprint 'Case #%d:' % (i + 1), process(C, F, X)\\n", "target": "40", "substitutes": {"C": ["V", "AC", "CS", "G", "Cond", "CI", "P", "CV", "W", "J", "CNN", "COR", "CC", "CO", "Y", "CG", "N", "M", "O", "MC", "B", "CM", "c", "D", "CF", "CB", "Cs", "Ch", "H", "K", "CE", "LC", "CT", "JC", "DC", "A", "I", "R", "E", "CP", "Cache", "CA", "NC", "S", "U", "L", "Config", "CR", "Q", "CW", "VC", "Z", "WC", "Co"], "F": ["V", "G", "W", "P", "J", "FW", "GF", "FR", "FS", "FER", "Y", "f", "Fs", "Feed", "N", "M", "FC", "O", "FI", "B", "File", "TF", "D", "EF", "CF", "Factory", "FD", "FL", "IF", "H", "DF", "A", "UF", "I", "R", "Full", "E", "FO", "S", "FG", "Field", "WF", "L", "U", "FP", "Q", "SF", "Z", "PF", "FF", "Family", "FE"], "X": ["V", "W", "P", "CI", "ML", "J", "Time", "TX", "CC", "XY", "FX", "Y", "N", "FC", "EX", "B", "D", "CF", "HTTP", "XL", "H", "IX", "XX", "A", "DX", "I", "R", "E", "S", "L", "x", "U", "IR", "UX", "XP", "Q", "XT", "OX", "FF", "Z", "ZX", "XXX", "FE"], "speed": ["length", "duration", "power", "performance", "gain", "timeout", "size", "frequency", "peed", "port", "t", "f", "history", "case", "ime", "rate", "Speed", "fast", "cost", "sec", "capacity", "float", "test", "c", "status", "function", "TIME", "reason", "config", "control", "state", "change", "number", "sw", "start", "stream", "cycle", "field", "scroll", "count", "process", "age", "force", "x", "clock", "hold", "efficiency", "distance", "command", "slow", "weight", "error", "delay", "scale", "type", "shift", "EED", "transform", "stop", "string", "score"], "time": ["timer", "duration", "second", "length", "value", "message", "times", "power", "Time", "timeout", "size", "frequency", "date", "t", "history", "ime", "rate", "cost", "Speed", "offset", "sec", "step", "memory", "test", "window", "runtime", "TIME", "response", "r", "tt", "change", "year", "start", "counter", "count", "process", "clock", "age", "x", "now", "distance", "slow", "weight", "tim", "error", "delay", "stop", "seconds", "trip"], "input_file": ["output_files", "Input_FILE", "input_File", "input_field", "output_file", "inputptfile", "Input_stream", "input2file", "Input_url", "output_File", "inputptfiles", "input2File", "input12field", "output_field", "inputptFILE", "input12files", "input_files", "input_FILE", "input12File", "input_url", "inputLockFile", "input_stream", "inputptstream", "Input_files", "inputLockfile", "input2url", "input12file", "inputLockurl", "Input_File", "Input_file"], "T": ["V", "W", "P", "TB", "J", "TN", "t", "Y", "TPS", "N", "M", "O", "B", "TA", "D", "TT", "Type", "TY", "K", "TP", "A", "I", "R", "TS", "S", "NT", "L", "Q", "TR", "TM", "TC", "OT"], "i": ["s", "ti", "ini", "uri", "y", "ind", "t", "pi", "f", "li", "m", "multi", "xi", "n", "ix", "key", "c", "bi", "e", "k", "zi", "id", "r", "q", "ai", "im", "I", "si", "j", "mi", "ui", "v", "x", "di", "gi", "ii", "me", "p", "d", "oi"]}}
{"code": "\\n  def put_mines_last_step(R, C, M, grid):\\n  \tif M == 0:\\n  \t\treturn\\n  \tR -= 1\\n  \tC -= 1\\n  \tgrid[R][C] = '*'\\n  \tM -= 1\\n  \tr = R - 1\\n  \tc = C - 1\\n  \twhile M > 0:\\n  \t\tif r > c:\\n  \t\t\tgrid[r][C] = '*'\\n  \t\t\tr -= 1\\n  \t\telse:\\n  \t\t\tgrid[R][c] = '*'\\n  \t\t\tc -= 1\\n  \t\tM -= 1\\n  \\n  def put_mines(R, C, M, grid):\\n  \tif R > C:\\n  \t\tif M < C:\\n  \t\t\tput_mines_last_step(R, C, M, grid)\\n  \t\t\treturn\\n  \t\tfor i in range(C):\\n  \t\t\tgrid[R - 1][i] = '*'\\n  \t\tput_mines(R - 1, C, M - C, grid)\\n  \t\treturn\\n  \tif M < R:\\n  \t\tput_mines_last_step(R, C, M, grid)\\n  \t\treturn\\n  \tfor i in range(R):\\n  \t\tgrid[i][C - 1] = '*'\\n  \tput_mines(R, C - 1, M - R, grid)\\n  \treturn\\n  \\n  def process(R, C, M):\\n  \trlt = ''\\n  \tgrid = []\\n  \tfor i in range(R):\\n  \t\tgrid.append(['.'] * C)\\n  \tput_mines(R, C, M, grid)\\n  \tif not C == 1:\\n  \t\tfor i in range(R):\\n  \t\t\tif not grid[i][0] == '.':\\n  \t\t\t\tbreak\\n  \t\t\tif not grid[i][1] == '.':\\n  \t\t\t\treturn '\\nImpossible'\\n  \tif not R == 1:\\n  \t\tfor i in range(C):\\n  \t\t\tif not grid[0][i] == '.':\\n  \t\t\t\tbreak\\n  \t\t\tif not grid[1][i] == '.':\\n  \t\t\t\treturn '\\nImpossible'\\n  \tgrid[0][0] = 'c'\\n  \tfor i in grid:\\n  \t\trlt += '\\n' + ''.join(i)\\n  \treturn rlt\\n  \\n  input_file = open(sys.argv[1], 'r')\\n  T = int(input_file.readline())\\n  for i in range(T):\\n  \t(R, C, M) = map(int, input_file.readline().split())\\n  \tprint 'Case #%d:' % (i + 1), process(R, C, M)\\n", "target": "40", "substitutes": {"R": ["V", "RS", "G", "Root", "RE", "P", "ER", "Remote", "J", "OR", "Y", "Re", "RG", "N", "Right", "O", "B", "CM", "MR", "Rs", "GR", "D", "RL", "RA", "BR", "H", "RC", "RH", "SR", "K", "RM", "Row", "A", "Reader", "RT", "I", "RO", "X", "E", "JR", "RI", "S", "res", "RR", "DR", "NR", "L", "U", "Rot", "F", "CR", "IR", "Run", "Res", "TR", "Q", "Mr", "Cor", "Rat", "AR", "HR"], "C": ["V", "CS", "G", "W", "CO", "Y", "CAR", "CG", "Mc", "Count", "CF", "K", "JC", "CT", "E", "CA", "U", "CR", "CN", "Craig", "CI", "CC", "N", "MC", "B", "Car", "CB", "Ch", "CE", "CU", "I", "S", "F", "WC", "SC", "CNN", "Cr", "CL", "D", "Cs", "H", "Cl", "CD", "CP", "Cache", "Cons", "Config", "Q", "Cu", "VC", "Chain", "P", "cr", "IC", "J", "COR", "Cow", "O", "CM", "CCC", "DC", "A", "X", "EC", "L", "CON", "Con", "Co"], "M": ["V", "Mon", "Man", "G", "MAN", "RE", "P", "MT", "W", "J", "REM", "Multi", "Y", "m", "N", "Mc", "OM", "O", "MC", "B", "CM", "MR", "JM", "MN", "D", "mc", "Ch", "H", "Ms", "MI", "IM", "LM", "Me", "RM", "MD", " m", "Memory", "I", "X", "E", "EM", "S", "L", "U", "F", "Mi", "CR", "PM", "My", "Rem", "Q", "TM", "MS", "AR", "MM", "NM", "cm", "New", "Min", "MA", "DM", "AM", "Manager"], "grid": ["master", "power", "clear", "cli", "stack", "req", "g", "multi", "cell", "lat", "order", "addr", "query", "table", "zero", "gru", "reg", "net", "age", "hold", "fixed", "now", "wrapper", "link", "coord", "media", "bar", "range", "gain", "Grid", "stock", "network", "gate", "fac", "index", "pool", "mask", "windows", "window", "scan", "util", "db", "fine", "gray", "raid", "client", "entry", "via", "dict", "mg", "res", "rix", "storage", "device", "out", "list", "bag", "filter", "gm", "array", "medium", "rage", "record", "func", "domain", "cells", "rid", "input", "pi", "week", "slave", "xi", "this", "status", "xy", "map", "id", "browser", "get", "module", "hash", "back", "edge", "wei", "flow", "sim", "image", "rain", "box", "iq", "data", "result", "cgi", "gr", "work", "gpu", "lay", "band", "ix", "dq", "gc", "mat", "user", "set", "manager", "rank", "config", "pipe", "jac", "lag", "group", "block", "cache", "line", "chain", "bridge", "wire", "good", "gi", "tile", "node", "row", "graph", "queue"], "r": ["rest", "rr", "cr", "rt", "u", "t", "f", "m", "g", "n", "l", "nr", "rm", "sr", "e", "rs", "re", "ir", "q", "rb", "b", "br", "ro", "o", "ar", "rc", "j", "res", "mr", "v", "reg", "x", "er", "cm", "p", "d", "rar", "a", "h", "rx"], "c": ["cs", "cr", "cp", "y", "u", "Cr", "w", "t", "f", "m", "g", "n", "l", "z", "mc", "e", "k", "re", "lc", "co", "b", "o", "ar", "red", "ce", "rc", "j", "res", "v", "x", "col", "cm", "p", "d", "ct", "a", "ci", "h"], "i": ["ori", "s", "ini", "u", "cli", "t", "g", "eri", "multi", "it", "l", "Xi", "iri", "q", "ir", "b", "j", "v", "di", "yi", "me", "a", "io", "int", "w", "li", "ie", "index", "z", "e", "zi", "iu", "ri", "I", "qi", "res", "out", "list", "ii", "gm", "\u00ed", "p", "array", "ei", "ki", "uri", "pi", "f", "m", "xi", "n", "bi", "this", "status", "id", "ai", "phi", "o", "si", "mi", "ati", "ia", "ik", "adi", "\u0438", "ci", "iti", "oi", "ti", "IC", "ic", "y", "ix", "aci", "hi", "ij", "im", "ui", "RI", "fi", "info", "chain", "x", "gi", "ip", "ji"], "rlt": ["rclit", "erlt", "mLT", " rrt", "rwt", " rwt", "ergt", "mli", "dgt", "dli", " rli", "mwt", "Rlt", " rgt", "erlit", "rcgt", "mgt", "mformat", "mrt", " rlit", "Rformat", "rgt", " rformat", "Rwt", "rli", " rlet", "rformat", "rclt", "dlt", "rclet", "rLT", "mlt", " rLT", "erlet", "rlit", "dLT", "Rrt", "rrt", "rlet"], "input_file": ["input1FILE", "Input_FILE", "inputlockfile", "inputffile", "input__open", "input_File", "feedlockfilename", "input__file", "input1file", "Input_stream", "input1dir", "input2file", " input_fp", "input_fp", "feed_file", "input_dir", "input_filename", "input_open", "feed_filename", "inputfdir", "feed_File", "input2File", "feed_open", "input__File", "inputLockfilename", " input2File", "input_FILE", "input1stream", "feedlockFile", "Input_dir", "inputfFILE", "feedlockfile", "inputLockopen", " input2open", "inputLockFile", "input2open", "input_stream", " input_open", "inputLockfile", "feedlockopen", "inputlockopen", "inputlockFile", "input2fp", "input__fp", " input_File", "inputfstream", " input2file", "inputlockfilename", "Input_file", " input2fp"], "T": ["V", "GT", "G", "P", "TB", "Time", "J", "TX", "TN", "t", "Y", "Total", "N", "O", "B", "TA", "D", "TT", "TY", "K", "TP", "I", "E", "TS", "S", "WT", "NT", "L", "F", "Q", "TR", "TM", "Ct", "TI", "TC", "OT", "TL"]}}
{"code": "\\n  lines = [line.strip() for line in open(sys.argv[1])]\\n  count = int(lines[0])\\n  \\n  for i in xrange(count):\\n      farm_cost,farm_production,target = map(float, lines[i+1].split())\\n      seconds = 0\\n      production = 2\\n      best = float(\"inf\")\\n      while True:\\n          best = min(best, seconds + target / production)\\n          seconds += farm_cost / production\\n          if seconds >= best: break\\n          production += farm_production\\n  \\n      print \"Case #%s: %.7f\" % (i+1, best)\\n", "target": "41", "substitutes": {"lines": ["olds", "blocks", "plays", "cells", "ds", "nets", "cases", " Lines", "links", "items", "rs", "phones", "ls", "photos", "files", "rooms", "gs", "lists", "groups", "posts", "words", "vs", "parts", "bs", "mails", "dates", "rings", "qs", "limits", "elines", "frames", "tests", "years", "ages", "works", "vals", "strings", "lins", "ines", "pins", "rows", "pages", "members", "boxes", "points"], "line": ["range", "string", "comment", "file", "ine", "size", "word", "inline", "cell", "l", "lin", "option", "write", "set", "column", "entry", "zero", "block", "path", "field", "frame", "eline", "chain", "Line", "out", "list", "ln", "command", "link", "code", "page", "char", "row", "next", "limit", "col", "LINE", "console", "name", "lo", "record", "lf"], "count": ["nb", "length", "conf", "cont", "size", "len", "ind", "current", "n", "total", "Count", "index", "c", "gc", "order", "z", "iter", "depth", "number", "find", "nt", "cache", "counter", "ctr", "process", "consider", "cum", "hold", "force", "read", "list", "num", "limit", "sum", "found", "all", "ct", "max"], "i": ["ti", "s", "my", "ini", "uri", "y", "ic", "cli", "ind", "pi", "f", "li", "m", "g", "multi", "xi", "it", "l", "ix", "index", "c", "z", "bi", "ite", "e", "k", "zi", "id", "ij", "q", "ai", "b", "phi", "im", "I", "j", "mi", "qi", "v", "x", "ik", "gi", "di", "sim", "ii", "me", "ci", "p", "h", "ion", "ei"], "farm_cost": [" farm_head", " farm_hack", "farm___hack", "farm___head", "farm_hack", " farm_info", "farm_head", "farmprohack", "farm___cost", "farmprohead", " farm_loss", "farmprocost", "farm_loss", "farm_info"], "farm_production": [" farm_productive", " farm_development", "farm_productive", "farm_length", " farm_capacity", "farm_power", "farm_product", " farm_product", "farm_capacity", " farm_power", " farm_length", "farm_development"], "target": ["length", "result", "value", "to", "goal", "generated", "size", "stage", "public", "t", "primary", "current", "base", "total", "capacity", "test", "beta", "arget", "window", "buffer", "local", "tmp", "table", "number", "template", "source", "output", "process", "net", "Target", "top", "secondary", "arg", "success", "alpha", "node", "hop", "next", "type", "stop", "max", "attack", "peak"], "seconds": ["s", "second", "ones", "duration", "fps", "times", "sts", "timeout", "goal", "hours", "sections", "size", "bes", "utes", "tes", "steps", "jobs", "sites", "sec", "scripts", "errors", "general", "runs", "pieces", "videos", "bytes", "settings", "obs", "resources", "files", "utils", "versions", "games", "states", "ses", "scenes", "events", "bs", "dates", "units", "ts", "assets", "bits", "terms", "users", "frames", "tests", "workers", "years", "ages", "strings", "lower", "reports", "values"], "production": ["length", "power", "performance", "rice", "confidence", "goal", "revolution", "problem", "stage", "public", "operator", "comments", "steps", "Production", "resource", "total", "capacity", "processing", "division", "test", "beta", "errors", "prototype", "technology", "proc", "competitive", "system", "conference", "pro", "maximum", "productive", "product", "number", "population", "profit", "component", "scientific", "output", "assets", " Production", "process", "growth", "top", "efficiency", "success", "computer", "position", "development", "debug", "critical", "error", "p", "project", "resolution", "testing", "priority", "majority"], "best": ["result", "value", "est", "last", "short", "to", "Best", "problem", "goal", "adjusted", "better", "first", "new", "cost", "long", "high", "gold", "test", "highest", "full", "status", "fine", "winner", "rank", "worst", "pro", "default", "progress", "b", "fair", "ps", " Best", "profit", "bright", "stretched", "largest", "good", "top", "success", "max", "fit", "bottom", "end", "latest", "p", "average", "round", "final", "same", "stop", "just", "score", "peak"]}}
{"code": "\\n  lines = [line.strip() for line in open(sys.argv[1])]\\n  count = int(lines[0])\\n  \\n  for i in xrange(count):\\n      R,C,M = map(int, lines[i+1].split())\\n      print \"Case #%s:\" % (i+1)\\n  \\n      w = max(R,C)\\n      h = min(R,C)\\n      X = R*C - M\\n      assert X > 0\\n  \\n      if X == 1:\\n          rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]\\n      elif h == 1:\\n          rows = ['c' + '.' * (X-1) + '*' * M]\\n      elif X == 4:\\n              rows = [\\n                  'c.' + '*' * (w-2),\\n                  '..' + '*' * (w-2),\\n              ] + ['*' * w] * (h-2)\\n      elif h == 2:\\n          if X%2 == 1 or X == 2:\\n              rows = None\\n          else:\\n              rows = [\\n                  'c' + '.' * (X/2-1) + '*' * (M/2),\\n                  '.' + '.' * (X/2-1) + '*' * (M/2)\\n              ]\\n      elif X <= 5 or X == 7:\\n          rows = None\\n  \\n      elif X%2 == 0 and X <= w*2:\\n          r = X/2\\n          rows = [\\n              'c' + '.' * (r - 1) + '*' * (w-r),\\n                    '.' * r       + '*' * (w-r),\\n          ] + ['*' * w] * (h-2)\\n  \\n      elif X <= w*3 and (X % 3) != 1:\\n          n = (X+1) / 3\\n          t = X - 2*n\\n          rows = [\\n              'c' + '.' * (n-1) + '*' * (w-n),\\n                    '.' * n     + '*' * (w-n),\\n                    '.' * t     + '*' * (w-t)\\n          ] + ['*' * w] * (h-3)\\n      else:\\n          n = X / w\\n          t = X % w\\n          if t == 1:\\n              rows = (\\n                      ['c' + (w-1) * '.']\\n                  +   ['.' * w] * (n-2)\\n                  +   ['.' * (w-1) + '*']\\n                  +   ['..' + '*' * (w-2)]\\n                  +   ['*' * w] * (h - n - 1)\\n              )\\n          else:\\n              k = 1 if t == 0 else 0\\n              rows = (\\n                      ['c' + (w-1) * '.']\\n                  +   ['.' * w] * (n-1)\\n                  +   ['.' * t + '*' * (w-t)] * (1 - k)\\n                  +   ['*' * w] * (h - n - 1 + k)\\n              )\\n  \\n      if rows:\\n          if R > C:\\n              rows = [\"\".join(row[i] for row in rows) for i in xrange(R)]\\n  \\n          for row in rows:\\n              print row\\n  \\n          assert len(rows) == R\\n          assert len(rows[0]) == C\\n          assert sum(1 for row in rows for col in row if col == '*') == M\\n  \\n      else:\\n          print \"Impossible\"\\n  \\n", "target": "41", "substitutes": {"lines": ["ids", "rates", "blocks", "cells", "ds", "sections", "xs", " Lines", "links", "fs", "ns", "rs", "prints", "bytes", "ls", "files", "gs", "groups", "posts", "words", "vs", "parts", "bs", "mails", "dates", "rings", "qs", "limits", "elines", "frames", "args", "ln", "years", "vals", "strings", "lins", "ines", "codes", "reads", "ins", "pages", "pins", "values", "points"], "line": ["message", "comment", "file", "ine", "new", "word", "li", "inline", "cell", "l", "lin", "column", "nl", "iter", "entry", "liner", "block", "field", "frame", "eline", "chain", "Line", "L", "x", "str", "out", "list", "ln", "code", "page", "lo", "command", "ip", "dd", "next", "limit", "LINE", "name", "string", "record"], "count": ["length", "nb", "cont", "size", "ch", "len", "ind", "m", "history", "current", "N", "l", "total", "Count", "index", "c", "z", "q", "number", "start", "nt", "counter", "cycle", "v", "ctr", "cum", "x", "read", "num", "max", "sum", "ct"], "i": ["ti", "s", "ini", "y", "ind", "pi", "on", "li", "m", "xi", "multi", "it", "l", "ix", "index", "us", "c", "z", "bi", "e", "zi", "hi", "id", "ij", "ai", "im", "o", "I", "si", "j", "mi", "info", "v", "x", "di", "gi", "sim", "ip", "me", "p", "ci", "oi"], "R": ["V", "RS", "G", "W", "P", "RE", "Y", "RG", "N", "Right", "B", "MR", "Rs", "GR", "D", "H", "RA", "RC", "SR", "RM", "T", "A", "RT", "I", "RO", "RI", "S", "RR", "L", "Rot", "CR", "IR", "Res", "TR", "Q"], "C": ["V", "CS", "G", "CI", "W", "P", "CNN", "COR", "CC", "CO", "Y", "N", "Mc", "MC", "B", "c", "CM", "D", "CB", "YC", "Cs", "H", "K", "CE", "CT", "T", "DC", "A", "CU", "I", "EC", "CP", "S", "L", "F", "CBS", "Custom", "CR", "CON", "Q", "Co", "Craig"], "M": ["V", "G", "MAN", "W", "P", "MT", "J", "MH", "Y", "m", "N", "O", "Mc", "MC", "B", "CM", "D", "H", "K", "MI", "Ms", "LM", "RM", "T", "I", "E", "S", "L", "PM", "F", "U", "Mi", "Q", "TM", "MS", "MM", "NM", "Z"], "w": ["s", "power", "W", "wd", "l", "c", "write", "wat", "q", "mem", "b", "sw", "wall", "wx", "v", "wa", "weight", "wait", "ew", "history", "we", "wr", "N", "wm", "window", "z", "rew", "TW", "term", "words", "wo", "rw", "wh", "ow", "p", "exp", "wb", "new", "f", "m", "word", " W", "H", "o", "temp", "widget", "wn", "wl", "d", "win", "max", "hw", "y", "tw", "width", "kw", "iw", "man", "wp", "space", "wk", "wal", "L", "x", "fw", "ws", "nw", "wt"], "h": ["hr", "hw", "ch", "y", "HH", "th", "ha", "zh", "m", "history", "hs", "ho", "he", "high", "l", "sh", "her", "c", "z", "hp", "uh", "e", "hang", "kh", "hi", "ph", "hd", "H", "q", "host", "hz", "hl", "b", "o", "bh", "ah", "html", "v", "hm", "dh", " H", "oh", "x", "ih", "p", "hh", "height", "head", "ht"], "X": ["V", "Tx", "W", "P", "ML", "J", "Time", "ax", "TX", "XY", "Y", "XM", "N", "O", "EX", "MC", "PE", "Xi", "D", "HTTP", "XL", "Length", "WH", "H", "K", "IM", "IX", "XX", "Ax", "T", "PH", "A", "DX", "I", "E", "S", "Width", "L", "TH", "x", "ox", "F", "U", "UX", "XP", "Q", "XT", "Event", "OX", "HTML", "MS", "MX", " x", "Z", "ZX", "XXX", "Ex"], "rows": ["rates", "projects", "relations", "bys", "ows", "blocks", "cells", "ways", "points", "names", "headers", "models", "jobs", "ros", "views", "roots", "runs", "items", "hands", "rules", "keys", "rs", "ns", "body", "papers", "options", "rooms", "los", "groups", "flows", "posts", "eeks", "bs", "res", "heads", "units", "ports", "fields", "users", "uds", "frames", "workers", "tests", "sheets", "rown", "values", "vals", "issues", "owners", "ues", "ins", "pages", "orders"], "r": ["rr", "rt", "cr", "dr", "u", "y", "tr", "g", "m", "rate", "it", "l", "nr", "rd", "radius", "c", "z", "sr", "e", "rs", "re", "q", "rb", "b", "ro", "br", "ur", "ar", "pr", "j", "rc", "res", "mr", "v", "reg", "usr", "x", "er", "fr", "vr", "p", "d", "rg", "rar", "rx"], "n": ["nb", "nm", "s", "ng", "nu", "tn", "np", "y", "new", "at", "f", "m", "g", "N", "l", "mn", "nr", "en", "long", "ot", "c", "nv", "z", "yn", "ns", "nl", "nn", "ne", "b", "o", "no", "number", "na", "j", "nt", " N", "sn", "v", "net", "pn", "x", "an", "ln", "num", "nw", "node", "un", "cn", "p", "d", "name", "nc"], "t": ["s", "ti", "rt", "ty", "ta", "to", "y", "th", "tr", "at", "m", "tw", "g", "st", "f", "it", "l", "lat", "test", "c", "z", "ant", "mt", "e", "pt", "tf", "tt", "b", "tu", "T", "o", "j", "nt", "v", "ts", "x", "te", "out", " T", "unt", "dt", "type", "p", "d", "tz", "tc", "wt", "ot", "td"]}}
{"code": "\\n  '''\\n  Input\\n  The first line of the input gives the number of test cases, T. T lines follow. \\n  Each line contains three space-separated real-valued numbers: C, F and X.\\n  \\n  Output\\n  For each test case, output one line containing \"Case #x: y\", where x is \\n  the test case number (starting from 1) and y is the minimum number of seconds \\n  it takes before you can have X delicious cookies.\\n  \\n  We recommend outputting y to 7 decimal places, but it is not required. \\n  y will be considered correct if it is close enough to the correct number: \\n  within an absolute or relative error of 10^-6. \\n  \\n  Limits\\n  1 <= T <= 100.\\n  \\n  Small dataset\\n  1 <= C <= 500.\\n  1 <= F <= 4.\\n  1 <= X <= 2000.\\n  \\n  Large dataset\\n  1 <= C <= 10000.\\n  1 <= F <= 100.\\n  1 <= X <= 100000.\\n  \\n  \\n  ---Input  \\n  4\\n  30.0 1.0 2.0\\n  30.0 2.0 100.0\\n  30.50000 3.14159 1999.19990\\n  500.0 4.0 2000.0\\n  \\n  ---Output \\n  Case #1: 1.0000000\\n  Case #2: 39.1666667\\n  Case #3: 63.9680013\\n  Case #4: 526.1904762\\n  \\n  '''\\n  \\n  \\n  \\n  \\n  \\n  f = open(sys.argv[1])\\n  def input(): return f.readline().strip();\\n  \\n  def bestTime(C, F, X):\\n      v = 2   #speed of production, cookies/sec\\n      t = 0   #total time of production, sec\\n      while True:\\n          tX = X / v          #time to reach goal at current speed\\n          tC = C / v          #time to buy farm\\n          tXc = X / (v + F)   #time to reach goal after adding farm\\n          if tX <= tC + tXc:\\n              break\\n          t += tC\\n          v += F\\n      t += tX\\n      return t\\n  \\n  \\n  for caseNo in xrange(1, int(input())+1):\\n      C, F, X = map(float, input().split())\\n      print 'Case #%d: %.7f' % (caseNo, bestTime(C, F, X))\\n      \\n  \\n  \\n", "target": "42", "substitutes": {"f": ["af", "file", "input", "w", "t", "m", "g", "l", "ft", "c", "fs", "h", "fb", "e", "q", "r", "tf", "b", "fc", "fo", "o", "fa", "fg", "x", "fd", "p", "d", "a", "fp", "df", "fm", "i", "lf"], "C": ["V", "G", "CI", "P", "CV", "W", "J", "CC", "CO", "Y", "N", "M", "B", "c", "CM", "D", "CB", "Cs", "K", "T", "CD", "A", "R", "E", "CA", "S", "Z"], "F": ["V", "G", "W", "P", "J", "GF", "Fs", "AF", "N", "M", "FC", "CF", "H", "T", "I", "R", "E", "FO", "FG", "WF", "L", "U", "FP", "Q", "Z", "FF"], "X": ["V", "G", "W", "P", "J", "XY", "Y", "N", "M", "B", "K", "IX", "XX", "T", "A", "DX", "I", "R", "E", "S", "U", "x", "L", "Q", "Z", "ZX"], "v": ["V", "s", "sv", "u", "y", "w", "t", "g", "m", "n", "l", "c", "nv", "z", "k", "version", "r", "q", "b", "o", "j", "vs", "x", "p", "d", "h", "i"]}}
{"code": "\\n  '''\\n  Input\\n  The first line of the input gives the number of test cases, T. T lines follow. \\n  Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).\\n  \\n  Output\\n  For each test case, output a line containing \"Case #x:\", where x is the test case number. \\n  On the following R lines, output the board configuration with C characters per line, \\n  using '.' to represent an empty cell, '*' to represent a cell that contains a mine, \\n  and 'c' to represent the clicked cell. If there is no possible configuration, \\n  then instead of the grid, output a line with \"Impossible\" instead. \\n  If there are multiple possible configurations, output any one of them.\\n  \\n  Limits\\n  0 <= M < R * C.\\n  \\n  Small dataset\\n  1 <= T <= 230.\\n  1 <= R, C <= 5.\\n  \\n  Large dataset\\n  1 <= T <= 140.\\n  1 <= R, C <= 50.\\n  \\n  Sample\\n  ---Input \\n  5\\n  5 5 23\\n  3 1 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  \\n  ---Output \\n  Case #1:\\n  Impossible\\n  Case #2:\\n  c\\n  .\\n  *\\n  Case #3:\\n  Impossible\\n  Case #4:\\n  ......*\\n  .c....*\\n  .......\\n  ..*....\\n  Case #5:\\n  **********\\n  **********\\n  **********\\n  ****....**\\n  ***.....**\\n  ***.c...**\\n  ***....***\\n  **********\\n  **********\\n  **********\\n  \\n  \\n  '''\\n  \\n  \\n  f = open(sys.argv[1])\\n  def input(): return f.readline().strip();\\n  \\n  def genBoards(R, C, M):\\n      for mines in combinations( product(range(R), range(C)), M):\\n          board = [ ['.'] * C + [''] for _ in range(R) ]\\n          for row, col in mines:\\n              board[row][col] = '*'\\n          yield board + [[''] * (C+1)]\\n      pass\\n  \\n  def oneClickSolution(R, C, M):\\n      for bd in genBoards(R, C, M):\\n          minTile = 10\\n          for r in range(R):\\n              for c in range(C):\\n                  if bd[r][c] == '.':\\n                      n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))\\n                      bd[r][c] = `n`\\n                      if n <= minTile:\\n                          minTile = n\\n                          minR, minC = r, c\\n          if minTile < 10:\\n              queue = [ (minR, minC) ]\\n              nOpen = 0\\n              while queue:\\n                  r,c = queue.pop()\\n                  if bd[r][c] == '0':\\n                      for i in -1,0,1:\\n                          for j in -1,0,1:\\n                              if i or j: # we don't add the one we popped back\\n                                  queue.append( (r+i, c+j) )\\n                  if bd[r][c] not in '.*':\\n                      bd[r][c] = '.'\\n                      nOpen += 1\\n              if M + nOpen == R*C:\\n                  bd[minR][minC] = 'c'\\n                  return '\\n'.join( ''.join(row[:-1]) for row in bd[:-1] )\\n  \\n      return 'Impossible'\\n  \\n  \\n  clk = clock()\\n  \\n  for caseNo in xrange(1, int(input())+1):\\n      R, C, M = map(int, input().split())\\n      print >>sys.stderr, caseNo, R, C, M #, oneClickSolution(R, C, M)<>'Impossible'\\n      print 'Case #%d:' % caseNo  \\n      print oneClickSolution(R, C, M)\\n      \\n  print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\\n  \\n", "target": "42", "substitutes": {"f": ["af", "file", "cf", "input", "w", "t", "m", "g", "ft", "l", "fs", "bf", "fb", "e", "tf", "b", "fc", "fa", "o", "fg", "rf", "fi", "fn", "v", "F", "fw", "x", "fd", "fr", "df", "p", "d", "a", "fp", "h", "fm", "lf"], "R": ["V", "RS", "G", "RE", "P", "J", "Remote", "OR", "Range", "Y", "Reg", "RG", "N", "Right", "Dr", "B", "MR", "Rs", "D", "RL", "RA", "H", "BR", "RC", "SR", "Review", "Row", "T", "RM", "A", "RT", "I", "RO", "X", "RI", "S", "NR", "RR", "DR", "L", "F", "Rot", "U", "CR", "IR", "Mr", "Res", "TR", "Rat", "Rect", "AR", "Br", "Rating"], "C": ["V", "AC", "CS", "G", "CV", "P", "W", "CNN", "COR", "Cow", "CC", "Y", "CG", "N", "O", "Mc", "CL", "MC", "HC", "B", "CM", "D", "CB", "YC", "CF", "Ch", "Cs", "H", "K", "CCC", "CE", "CT", "JC", "T", "Cl", "DC", "A", "I", "X", "EC", "E", "Cache", "CA", "S", "Size", "L", "F", "U", "CR", "CON", "Q", "VC", "CN", "Co", "Craig", "SC"], "M": ["V", "Mon", "P", "MT", "J", "Y", "m", "N", "O", "MC", "B", "CM", "JM", "MN", "D", "H", "K", "MI", "Ms", "LM", "RM", "T", "A", "I", "Mode", "X", "E", "S", "L", "F", "Q", "TM", "MS", "Matrix", "MX", "MM", "NM", "DM", "AM", "Manager"], "mines": [" mine", "mnES", "minsess", "minse", "createss", "creatES", "Minbes", "createse", "Minses", "creates", "mness", "minese", "minsses", "minsese", "mine", " minses", "miness", "minsES", "minsbes", "mnes", " minbes", "minES", "minses", "mnese", "Mines", "minbes", "Mine"], "board": ["layout", "butt", "loop", "core", "ard", "card", "Board", "bo", "lay", "boards", "cell", "buffer", "fine", "lock", "runner", "body", "flo", "table", "bank", "room", "bro", "control", "b", "ro", "block", "oard", "ward", "balance", "bin", "be", "back", "line", "chain", "comb", "flow", "ack", "boarding", "player", "boot", "list", "ble", "deck", "d", "box", "button", "bar"], "_": ["ner", "mult", "ix", "ac", "non", "ml", "line", "ox", "an", "un", "val", "all", "ct", "ation"], "row": ["w", "pair", "th", "tr", "rect", "rot", "cell", "key", "index", "color", "rs", "re", "our", "co", "box", "br", "ro", "Row", "rc", "line", "ry", "ox", "x", "rown", "ow", "roll", "vr", "p", "rows", "item", "pos", "record", "bar"], "col": ["cp", "ol", "ch", "y", "th", "rot", "channel", "cell", "key", "color", "con", "loc", "pos", "column", "fl", "pt", "box", "co", "el", "br", "fc", "left", "obj", "cond", "fn", "count", "cat", "ox", "prop", "mot", "coll", "mon", "coord", "roll", "Col", "tab", "val", "ct", "foot", "day", "name", "label", "win", "COL"], "bd": ["nb", "bt", "ob", "de", "ld", "bm", "gb", "ds", "bo", "bes", "vd", "bet", "boards", "deb", "band", "bb", "des", "ond", "bf", "hands", "db", "bind", "dj", "da", "ben", "hd", "fl", "bro", "bj", "b", "BD", "br", "bh", "bc", "be", "edd", "bs", "bl", "bn", "player", "dis", "dm", "ba", "fd", "cb", "bos", "dt", "bis", "cd", "d", "box", "dd", "pd", "bar"], "minTile": ["minimumPixel", "beginThumbnail", "minFeature", " minSlot", "MINTexture", "maxtile", "MINEntry", "MINTile", " minPixel", " minThumbnail", "MinTexture", "minimumEntry", "minEntry", "MINtile", "Mintile", "beginTile", " minCell", "minimumFeature", "maxTile", "MINPixel", "MinPixel", "minThumbnail", " minTexture", "minimumSlot", "minCell", "minSlot", "minPixel", "maxCell", "MINSlot", "beginFeature", "MinCell", "mintile", " mintile", "minTexture", "minimumTile", " minEntry", "MinTile", " minFeature", "minimumThumbnail"], "r": ["hr", "range", "s", "rr", "rt", "cr", "dr", "gr", "y", "w", "t", "tr", "m", "g", "ru", "l", "nr", "attr", "rd", "rn", "z", "sr", "e", "rs", "root", "re", "ir", "q", "rb", "br", "ro", "kr", "ur", "ar", "o", "b", "rec", "pr", "rc", "rh", "res", "mr", "v", "reg", "er", "rl", "fr", "vr", "p", "d", "rg", "rar", "h", "rx"], "c": ["cs", "cr", "cp", "cont", "uc", "ch", "u", "cf", "w", "t", "m", "cin", "g", "cell", "l", "com", "can", "cl", "ac", "z", "con", "ec", "mc", "k", "e", "jc", "dc", "co", "lc", "vc", "b", "category", "fc", "cur", "unc", "bc", "ce", "rc", "cache", "sc", "chain", "v", "cor", "cat", "cu", "x", "xc", "pc", "cb", "cm", "p", "ci", "ct", "cn", "cd", "tc", "cc"], "n": ["s", "nb", "nm", "nu", "np", "size", "len", "dn", "t", "m", "g", "N", "l", "Ni", "mn", "nat", "nr", "z", "ns", "nl", "nn", "ni", "b", "o", "no", "inner", "number", "na", "nt", "min", "sn", "fn", "v", "x", "nan", "ln", "num", "un", "cn", "p", "d", "all", "nc"], "i": ["ti", "iy", "ini", "y", "u", "ic", "pi", "m", "li", "ie", "it", "l", "ix", "il", "z", "e", "k", "zi", "hi", "ij", "iu", "ni", "q", "id", "ai", "phi", "im", "o", "ri", "I", "si", "mi", "rin", "v", "x", "ia", "ib", "ik", "gi", "di", "yi", "ii", "ip", "ig", "ci", "p", "iti", "io", "h", "ei"], "j": ["json", "ja", "ju", "J", "jj", "ch", "y", "u", "t", "jas", "g", "li", "serv", "ie", "cell", "kj", "l", "aj", "z", "js", "bi", "py", "jp", "e", "k", "dj", "ij", "jc", "q", "ai", "bj", "b", "o", "pr", "bar", "bl", "res", "v", "x", "je", "fr", "jump", "uj", "p", "ji", "d", "ci", "job", "h", "oj"], "minR": ["MinC", "lowerRange", "smallRange", "MinT", "minRange", "MinR", "smallR", "minM", " minRange", "currentC", "minT", "lowerR", "currentT", "smallT", " minT", "smallM", "lowerM", "currentR", "lowerT", " minM"], "minC": ["minimumT", "MinC", "minCl", "minimumc", "minc", "Minc", "MinCl", "MinI", "MinT", " minO", "minimumI", "minI", "minimumCl", "MinR", " minc", " minI", "minimumC", "minT", "minO", " minT", " minCl", "minimumR", "minimumO", "MinO"], "queue": ["timer", "message", "free", "ue", "file", "stack", "bench", "zip", "pen", "case", "buf", "channel", "quote", "Queue", "late", "dq", "tube", "required", "buffer", "set", "store", "que", "grid", "sequence", "update", "q", "entry", "ume", "block", "batch", "button", "checked", "ques", "menu", "line", "qv", "count", "force", "ued", "worker", "list", "Q", "rl", "position", "quit", "lot", "select", "next", "vr", "ire", "me", "console", "priority", "wait"], "nOpen": ["nopen", "numTotal", "nClose", "numOpen", " nopen", "mClose", "numClose", "mOpen", "mopen", "nTotal", " nTotal", " nClose", "numopen", "mTotal"]}}
{"code": "__author__ = 'Jeffrey'\\n  \\n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\B-small-attempt0.in\"\\n  outFileName = inFileName[ : -2] + \"out\"\\n  \\n  \\n  def parseInput(f):\\n      T = int(f.readline())\\n      L = []\\n  \\n      for i in range(T):\\n          L.append([float(i) for i in f.readline().split()])\\n  \\n      return T, L\\n  \\n  \\n  def calculateWinTime(C, F, X):\\n      R = 2.0 # rate of cookie profit (cookies/s)\\n      totalTime = 0.0\\n      while (X / R >= C/R + X/(R + F)):\\n          totalTime += C / R\\n          R += F\\n      return totalTime + X / R\\n  \\n  \\n  def playGame(T,L):\\n      for i in range(T):\\n          result = calculateWinTime(L[i][0], L[i][1], L[i][2])\\n          yield \"Case #\" + str(i + 1) + \": \" + \"{:0.7f}\".format(result)\\n  \\n  \\n  if __name__==\"__main__\":\\n      iF = open(inFileName, 'r')\\n      T, L = parseInput(iF)\\n      iF.close()\\n  \\n      print(T)\\n      print(L)\\n  \\n      oF = open(outFileName, \"wb\")\\n      for out in playGame(T, L):\\n          print(out)\\n          oF.write(bytes(out + \"\\n\",'utf-8'))\\n      oF.close()\\n", "target": "43", "substitutes": {"__author__": ["__author____", "_______author___", "_______author_", "__author___", "_______name_", "__Author__", "_______author____", "__name_", "__name___", "_______name____", "__name__", "__Author_", "_______author__", "__Author___", "__Author____", "__author_", "__creator_", "__creator__", "_______name___", "__creator____", "__creator___", "__name____", "_______name__"], "inFileName": ["inFilenameName", "inFilenameFile", "inFolderNames", " inFilenameFile", "infileName", "inFilenamePath", " inFilenameName", "inFileFile", "inFolderSet", "inPathType", "inFileNames", "inFilenameType", " inFileSet", "inPathName", "infilePath", "inPathFile", " inFilenameType", "infileFile", "inPathPath", " inFilenamePath", "inFolderSystem", "inFilenameNames", "inFileSystem", "inFilePath", "inFilenameSystem", " inFilenameSet", " inFileNames", " inFilePath", "inFolderName", " inFileType", " inFilenameNames", "infileType", "infileSet", "infileSystem", "inFilenameSet", " inFileSystem", " inFileFile", "inFileSet", " inFilenameSystem", "infileNames", "inFileType"], "outFileName": ["infileName", "outfilename", "outFilesName", "outFilenamename", "inFileNames", "inFilename", "infilePath", "outFilesNames", "infilename", "outFilenameNames", "inFilePath", "outfilePath", "outFilesname", "outfileName", "outFilename", "outfileNames", "outFileNames", "outFilenamePath", "outFilenameName", "outFilesPath", "infileNames", "outFilePath"], "f": ["inf", "conf", "af", "of", "file", "cf", "w", "t", "m", "up", "fast", "it", "l", "sf", "ft", "fx", "c", "bf", "fs", "z", "ac", "fb", "fl", "r", "tf", "b", "fc", "xf", "uf", "alf", "fn", "v", "fw", "fd", "fr", "feed", "df", "p", "d", "fp", "h", "fm", "lf", "form"], "T": ["V", "GT", "G", "P", "TB", "J", "Time", "TX", "TN", "TG", "t", "PT", "N", "M", "B", "TA", "INT", "TT", "Length", "TV", "TY", "CT", "Len", "A", "I", "TS", "S", "NT", "TIT", "TH", "TM", "XT", "IT", "Z", "TI", "TC", "OT", "TL"], "L": ["V", "LD", "P", "ML", "LV", "N", "LP", "CL", "DL", "l", "M", "B", "LG", "LA", "FL", "XL", "RL", "BL", "H", "LC", "LI", "LM", "VL", "I", "PL", "SL", "LT", "S", "LU", "LE", "U", "List", "LR", "NL", "LL", "Z", "LS", "TL", "Li", "EL"], "i": ["ori", "ti", "ki", "int", "ini", "ic", "u", "y", "cli", "ind", "pi", "li", "m", "t", "xi", "n", "it", "l", "ix", "iri", "z", "bi", "zi", "id", "ij", "hi", "ai", "phi", "im", "o", "I", "si", "j", "mi", "vi", "qi", "v", "ati", "x", "di", "gi", "ip", "ii", "\u0438", "p", "\u00ed", "ji", "ei", "oi"], "C": ["V", "G", "CI", "P", "CC", "CO", "Y", "N", "M", "B", "c", "CM", "D", "CB", "Cs", "H", "K", "JC", "CE", "CT", "A", "CD", "E", "CP", "S", "CR", "Co"], "F": ["V", "G", "W", "P", "FT", "J", "GF", "FR", "FS", "Fs", "N", "M", "FC", "D", "CF", "FL", "FD", "IF", "H", "DF", "I", "E", "FO", "FG", "WF"], "X": ["V", "G", "W", "P", "J", "TX", "XY", "Y", "N", "M", "EX", "XL", "K", "IX", "XX", "DX", "I", "E", "x", "XP", "Q", "XT", "Z", "ZX", "XXX", "Ex"], "R": ["V", "RS", "G", "P", "W", "N", "M", "O", "Right", "B", "MR", "D", "RA", "r", "K", "BR", "A", "I", "RO", "S", "RR", "TR", "Q", "Z"]}}
{"code": "__author__ = 'Jeffrey'\\n  \\n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-small-attempt0.in\"\\n  \\n  outFileName = inFileName[: -2] + \"out\"\\n  \\n  \\n  def parseInput(f):\\n      T = int(f.readline())\\n      L = []\\n  \\n      for i in range(T):\\n          L.append([int(i) for i in f.readline().split()])\\n  \\n      return T, L\\n  \\n  \\n  def calculateOneClick(R, C, M):\\n      size = R * C\\n      if R == 1 or C == 1 and M < size:\\n          return generateWinBoardBaseCase(R, C, M)\\n      elif size - M == 1:\\n          return generateWinBoardBaseCase(R, C, M)\\n      elif size - M >= 4:\\n          return generateWinBoard(R, C, M)\\n      return \"Impossible\"\\n  \\n  def generateWinBoard(R,C,M):\\n      emptySpace = R * C - M - 4\\n      out = \"c\"\\n      if C > 1:\\n          out += \".\"\\n          for i in range(2,C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      if R > 1:\\n          out += '\\n'\\n          out += \".\"\\n          if C > 1:\\n              out += \".\"\\n          for i in range(2,C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      for r in range(2,R):\\n          out += '\\n'\\n          for c in range(C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      return out\\n  \\n  def generateWinBoardBaseCase(R,C,M):\\n      emptySpace = R * C - M - 1\\n      out = \"c\"\\n      if C > 1:\\n          for c in range(1,C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      for r in range(1,R):\\n          out += '\\n'\\n          for c in range(C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      return out\\n  \\n  \\n  def playGame(T, L):\\n      for i in range(T):\\n          result = calculateOneClick(L[i][0], L[i][1], L[i][2])\\n          yield \"Case #\" + str(i + 1) + \":\\n\" + str(result)\\n  \\n  \\n  if __name__ == \"__main__\":\\n      iF = open(inFileName, 'r')\\n      T, L = parseInput(iF)\\n      iF.close()\\n  \\n      print(T)\\n      print(L)\\n  \\n      oF = open(outFileName, \"wb\")\\n      for out in playGame(T, L):\\n          print(out)\\n          oF.write(bytes(out + \"\\n\", 'utf-8'))\\n      oF.close()\\n", "target": "43", "substitutes": {"__author__": ["__creatorname", "__author___", "__authorname", "__Author__", "_Authorname", "_author_", "_author___", "__Author_", "__Authorname", "_Author__", "__Author___", "_Author___", "_authorname", "__author_", "__creator_", "_Author_", "__creator__", "__creator___", "_author__"], "inFileName": ["inSourceFilePath", " infilePath", "inFilenameName", "inFilesPath", "infileName", "inFilenamePath", " infileDir", "inFileNames", "inSourceFileNames", "inFilenameDir", " infileName", "inSourceFileName", "inFilesNames", "infilePath", "inFilesSet", "inFilenameNames", "inSourceFileDir", " infileNames", "inFilePath", " inFileNames", " inFilePath", "outfilePath", "infileSet", "outFileSet", "outfileName", "inFilenameSet", "inFileDir", "infileDir", "outfileNames", "inFileSet", "outFileNames", "inFilesName", "outfileSet", " inFileDir", "infileNames", "outFilePath"], "outFileName": ["infileName", "outFullName", "inFileNames", "outFileSize", "outFullPath", "infilePath", "outFilenameNames", "inFilePath", "outfilePath", "outFilenameSize", "outfileName", "infileSize", "infileNames", "outfileSize", "outFullSize", "outfileNames", "outFileNames", "inFileSize", "outFilenamePath", "outFilenameName", "outFullNames", "outFilePath"], "f": ["inf", "af", "cont", "file", "input", "w", "t", "m", "g", "fast", "l", "sf", "ft", "bf", "fs", "fb", "tf", "b", "fc", "uf", "alf", "v", "F", "fw", "x", "fd", "fr", "feed", "df", "p", "d", "fp", "h", "io", "fm", "lf", "form"], "T": ["V", "GT", "G", "W", "P", "J", "TX", "TN", "t", "Y", "N", "O", "B", "TA", "D", "TT", "Length", "TV", "TY", "H", "K", "Len", "A", "I", "X", "E", "LT", "TS", "Table", "S", "NT", "WT", "Size", "F", "Tu", "TH", "TR", "TM", "VT", "TI", "TC", "OT", "TL"], "L": ["V", "LD", "G", "W", "P", "ML", "AL", "N", "l", "DL", "CL", "LP", "B", "dL", "D", "LA", "IL", "FL", "RL", "H", "LC", "LI", "VL", "Len", "A", "LM", "I", "PL", "SL", "LT", "E", "S", "LU", "LE", "F", "Line", "List", "Lu", "NL", "LL", "Z", " l", "LS", "TL", "Li", "EL"], "i": ["ki", "ti", "int", "iy", "ini", "ic", "cli", "y", "ico", "pi", "t", "li", "m", "cin", "xi", "ie", "n", "it", "l", "index", "iri", "il", "z", "bi", "e", "k", "zi", "id", "iu", "ij", "ir", "ai", "b", "phi", "im", "ar", "ri", "I", "si", "j", "mi", "v", "ati", "x", "cu", "ia", "ib", "di", "gi", "yi", "ii", "ip", "\u0438", "ci", "p", "d", "\u00ed", "ji", "iti", "rit", "ei", "oi"], "R": ["V", "RS", "G", "Root", "P", "Role", "W", "RE", "Remote", "ER", "J", "OR", "Range", "Y", "RG", "N", "Right", "O", "Dr", "B", "MR", "Rs", "D", "RL", "H", "BR", "RA", "RC", "SR", "RM", "Reader", "A", "RT", "I", "RO", "X", "E", "JR", "RI", "S", "RR", "DR", "F", "Rot", "U", "CR", "RW", "IR", "Res", "Q", "Cor", "Rect", "Rat", "AR", "HR", "Br", "Random", "Co"], "C": ["V", "CS", "G", "W", "CV", "Y", "CG", "Count", "CF", "K", "JC", "CT", "ARC", "Color", "E", "CA", "U", "CR", "Z", "Craig", "Class", "Container", "CC", "N", "MC", "B", "CB", "Ch", "CE", "LC", "CU", "I", "S", "Size", "F", "WC", "SC", "CNN", "Cr", "CL", "D", "Cs", "H", "You", "Cl", "CD", "CP", "Cache", "Config", "Q", "Cu", "VC", "AC", "P", "Chain", "COR", "Cow", "O", "HC", "CM", "CCC", "DC", "A", "X", "EC", "CON", "Co"], "M": ["V", "G", "MAN", "W", "P", "MT", "Many", "J", "Multi", "Y", "m", "MODE", "N", "O", "Mc", "MC", "B", "CM", "D", "H", "Ms", "MI", "MU", "LM", "RM", "Memory", "A", "I", "X", "E", "EM", "S", "Size", "F", "U", "Mi", "FM", "PM", "Q", "MS", "MAC", "AR", "MB", "MM", "NM", "MX", "Z", "MAX", "MA", "VM", "DM", "AM", "Manager"], "size": ["length", "s", "sample", "second", "small", "empty", "len", "SIZE", "equal", "m", "case", "g", "n", "N", "sh", "capacity", "dim", "z", "set", "room", "time", "too", "shape", "see", "number", "year", "space", "big", "gravity", "S", "sn", "news", "count", "largest", "Size", "sized", "num", "position", "scale", "sum", "p", "height", "name", "ize", "max"], "emptySpace": ["emptyRoom", " emptyPlace", "EmptyFree", "emptySize", "EmptyArea", " emptySp", "blankSpace", "openSpace", "emptySp", "fullspace", "messagespace", "EmptySlot", "encryptedPrice", "missingspace", "encryptedSpace", "enablePrice", "zeroPoint", "smallSpace", "completeSize", "entitySlot", "entityZero", "messagePlace", "completespace", "cleanPrice", " emptyRoom", "EmptyString", "completeSp", "emptyFree", "encryptedPackage", "absolutePoint", "completePlace", "importantPackage", " emptySize", "entitySpace", "zeroService", "EmptySpace", "completeSpace", "EmptyZero", "errorspace", " emptyspace", "encryptedPlace", "missingPrice", "EmptyOnly", "emptyPlace", "emptyOnly", "smallSp", "openSp", "emptyspace", "encryptedRoom", " emptyPrice", " emptyPackage", " emptyOnly", "cleanSpace", " emptyPoint", " emptyString", "emptyPackage", "EmptySp", "entityArea", "emptyZero", "openString", "clearFree", " emptySlot", "smallFree", " emptyService", "blankPrice", "absoluteSpace", " emptyZero", "messageSpace", "emptyPrice", "cleanSlot", "emptySlot", "emptyArea", "clearSp", " emptyFree", "EmptySize", "fullSpace", "errorPlace", "importantPlace", "missingSpace", "Emptyspace", "blankPackage", "cleanspace", "importantRoom", "errorSpace", "fullSp", "importantSpace", "missingSlot", "emptyPoint", "emptyService", "clearSpace", "emptyString", "enablePackage", " emptyArea", "zeroSpace", "enableSpace", "absoluteService"], "out": ["conf", "timeout", "att", "t", "g", "it", "check", "table", "co", "batch", "output", "net", "pretty", "external", "ent", "sum", "ion", "expression", "log", "json", "int", "to", "comment", "art", "com", "index", "pool", "over", "ou", "client", "task", "outs", "res", "print", "list", "exp", "post", "name", "short", "at", "up", "n", "again", "can", "this", "option", "status", "auto", "go", "o", "no", "point", "soft", "append", "raw", "nt", "one", "ex", "part", "ort", "ot", "value", "cmd", "OUT", "empty", "null", "long", "text", "init", "set", "aos", "group", "block", "format", "inner", "cho", "obj", "Out", "line", "chain", "er", "off", "error", "end", "val", "all", "alt"], "r": ["rr", "cr", "rt", "ic", "w", "t", "m", "g", "it", "l", "car", "ibr", "ir", "co", "rb", "b", "ra", "ar", "ri", "pr", "rec", "rc", "rin", "cu", "p", "ci", "d", "ct", "h"], "c": ["cs", "cr", "cp", "ic", "w", "g", "cin", "n", "can", "cl", "ac", "ec", "arc", "car", "con", "\u00e7", "co", "ai", "lc", "cus", "b", "unc", "cur", "ar", "rec", "rc", "sc", "chain", "cor", "cat", "cu", "pc", "col", "cut", "ci", "ct", "cation", "xc", "cc"], "result": ["length", "data", "mark", "Result", "successful", "new", "url", "profile", "total", "test", "function", "table", "number", "back", "results", "diff", "ret", "res", "output", "list", "success", "found", "all", "df", "name"]}}
{"code": "\\n  T = int(input())\\n  \\n  for x in range(1, T+1):\\n      (C, F, X) = [float(y) for y in input().split()]\\n      totalsecs = 0\\n      cur_speed = 2\\n      while True:\\n          cur_time = X/cur_speed\\n          new_speed = cur_speed + F\\n          new_time = C/cur_speed + X/new_speed\\n          if new_time < cur_time:\\n              totalsecs += C/cur_speed\\n              cur_speed = new_speed\\n          else:\\n              totalsecs += cur_time\\n              break\\n      \\n      print(\"Case #%d: %.7f\" % (x, totalsecs))\\n", "target": "44", "substitutes": {"T": ["V", "G", "W", "P", "Time", "TN", "t", "Y", "N", "M", "O", "B", "D", "TT", "TV", "H", "K", "A", "I", "R", "E", "TS", "S", "WT", "L", "Q", "TR", "TM", "Z", "TC"], "x": ["mx", "xxx", "ax", "u", "xs", "w", "xt", "xd", "f", "yx", "xi", "xp", "ix", "xa", "key", "fx", "step", "c", "z", "name", "xy", "check", "xes", "context", "xf", "xx", "dx", "wx", "v", "ox", "trial", "num", "ex", "inx", "ctx", "ux", "ct", "tx", "xc", "i", "rx"], "C": ["V", "CS", "G", "CI", "P", "W", "CNN", "CC", "Y", "CG", "N", "M", "FC", "B", "c", "CM", "D", "CF", "CB", "Cs", "H", "K", "CT", "CU", "A", "I", "R", "E", "CA", "S", "L", "U", "CN", "Z", "Co"], "F": ["V", "G", "W", "P", "J", "Time", "FW", "Fs", "Y", "f", "N", "M", "FC", "O", "B", "D", "FL", "FD", "IF", "H", "K", "DF", "A", "I", "R", "E", "S", "FG", "L", "U", "FP", "Q", "Z", "PF", "FF", "FE"], "X": ["V", "W", "P", "Time", "XY", "Y", "N", "O", "B", "D", "CF", "XL", "H", "K", "CE", "IX", "XX", "A", "DX", "I", "R", "E", "S", "L", "TH", "U", "XP", "Q", "XT", "Z", "ZX", "Int", "ICE"], "y": ["gy", "isy", "yu", "u", "ys", "ya", "t", "oy", "Y", "f", "m", "yz", "zy", "n", "yd", "key", "c", "z", "py", "xy", "wy", "yy", "ny", "ye", "b", "ey", "uy", "yk", "yo", "j", "yr", "vy", "v", "ry", "sy", "fy", "cy", "yi", "yer", "ym", "p", "yl", "i"], "totalsecs": [" totalSecls", "totalccs", "totalecs", "totalSecions", "totalSECS", "totalccses", "totalccS", " totalSeces", "totalsecets", "totalccls", " totalSecs", "totalSECs", " totalsecses", "totalSECions", "totalsecls", "totalreqions", "totalSecets", "totalsces", "totalSECses", "totalSecls", "totalSecses", "totalseces", "totalscS", "totalscs", "totalecis", "totalscets", " totalSecses", "totalSeces", "totalreqS", " totalsecS", "totaleces", " totalsecions", "totalSecS", "totalreqses", " totalsecis", "totalsecis", " totalSecis", "totalreqs", "totalsecions", "totalsecS", " totalSecS", " totalseces", " totalsecets", "totalSecs", " totalsecls", " totalSecions", "totalecS", "totalSecis", "totalsecses"], "cur_speed": ["cur2Speed", "Cur_Speed", "curjtime", "newjtime", "new_weight", "newjstate", "Cur_length", "curjlength", "cur_weight", "curjSpeed", " cur_size", "curjweight", "cur_Speed", "Cur_weight", "cur_size", "cur_scope", "cur2length", "cur_sum", "newjspeed", " cur_sum", " cur_scope", "curjsize", "curjspeed", "Cur_rate", "cur_depth", "cur_length", "newjweight", "cur2speed", "cur_state", "cur2rate", " cur_weight", " cur_depth", "cur_rate", "new_state", "curjstate", "curjrate", "Cur_time", "Cur_speed", " cur_length"], "cur_time": ["curjtime", "Cur_times", " cur_tim", "curjTime", "cur_Time", "cur_times", "cur_tim", " curjTime", "curjtim", "curjspeed", "Cur_Time", " cur_Time", "Cur_time", " curjtime", " curjspeed", " curjtim", "Cur_speed"], "new_speed": ["newlytime", "newjtime", " new_frequency", "new2speed", "new2length", "newjspeed", "new_length", "old_length", "new2system", "newlysystem", "old_system", "newjlength", "newjfrequency", "old_time", "old_speed", "newlylength", "cur_length", "newlyspeed", " new_length", "new_frequency", "new2time", "new_system"], "new_time": ["new_Time", "newtimetime", "New_Time", "newtimet", "newtimeTime", "New_t", "New_speed", "new_tim", "New_time", "new_t", "newtimespeed", " new_tim"]}}
{"code": "\\n  T = int(input())\\n  \\n  for n in range(1, T+1):\\n      print(\"Case #%d:\" % n)\\n      (R, C, M) = (int(x) for x in input().split())\\n      dots = R*C - M\\n      if M == 0:\\n          print(\"\\n\".join([\"c\"+(C-1)*\".\"] + (R-1)*[C*\".\"]))\\n      elif dots == 0:\\n          print(\"Impossible\")\\n      elif R == 1:\\n          assert C - M > 0\\n          print(\"c\"+(C-M-1)*\".\"+M*\"*\")\\n      elif C == 1:\\n          assert R - M > 0\\n          print(\"c\\n\"+(R-M-1)*\".\\n\"+M*\"*\\n\", end='')\\n      elif dots == 1:\\n          print(\"\\n\".join([\"c\"+ (C-1)*\"*\"] + (R-1)*[C*\"*\"]))\\n      elif dots > 3:\\n          if (dots == 5) or (dots == 7):\\n              print(\"Impossible\")\\n              continue\\n          if (R == 2) or (C == 2):\\n              if dots%2 != 0 :\\n                  print(\"Impossible\")\\n                  continue\\n              elif R == 2:\\n                  l = int(dots/2)\\n                  print(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\\n                  print(l*\".\"+(C-l)*\"*\")\\n                  continue\\n              elif C == 2:\\n                  l = int(dots/2)\\n                  print(\"c.\")\\n                  print((l-1)*\"..\\n\", end='')\\n                  print(int(M/2)*\"**\\n\", end='')\\n                  continue\\n          (lines, extra) = divmod(dots, C)\\n          temp = []\\n          if (lines >= 2) and (extra != 1):\\n              temp.append(\"c\"+(C-1)*\".\")\\n              temp.extend((lines-1)*[C*\".\"])\\n              temp.append(extra*\".\"+(C-extra)*\"*\")\\n              temp.extend((R-lines-1)*[C*\"*\"])\\n              print(\"\\n\".join(temp))\\n              continue\\n          elif (lines > 2) and (extra == 1):\\n              temp.append(\"c\"+(C-1)*\".\")\\n              temp.extend((lines-2)*[C*\".\"])\\n              temp.append((C-1)*\".\"+\"*\")\\n              temp.append(\"..\"+ (C-2)*\"*\")\\n              temp.extend((R-lines-1)*[C*\"*\"])\\n              print(\"\\n\".join(temp))\\n              continue\\n          elif (lines == 2) and (extra == 1):\\n              temp.append(\"c\"+(C-2)*\".\"+\"*\")\\n              temp.append((C-1)*\".\"+\"*\")\\n              temp.append(3*\".\"+(C-3)*\"*\")\\n              temp.extend((R-3)*[C*\"*\"])\\n              print(\"\\n\".join(temp))\\n              continue\\n          elif lines < 2:\\n              (l, rem) = divmod(dots, 2)\\n              if rem == 1:\\n                  l -= 1\\n                  rem += 2\\n              temp.append(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\\n              temp.append(l*\".\"+(C-l)*\"*\")\\n              temp.append(rem*\".\"+(C-rem)*\"*\")\\n              temp.extend( (R-3)*[ C*\"*\" ])\\n              print(\"\\n\".join(temp))\\n              continue\\n      else:\\n          print(\"Impossible\")\\n  \\n", "target": "44", "substitutes": {"T": ["V", "GT", "G", "W", "P", "TB", "Time", "TN", "t", "Y", "N", "O", "B", "TA", "D", "TT", "TV", "TY", "K", "I", "X", "E", "TS", "S", "NT", "L", "F", "TH", "TR", "Q", "TM", "VT", "Z", "TI", "TC"], "n": ["nm", "nb", "nd", "ng", "nu", "tn", "note", "np", "w", "new", "t", "N", "nor", "nr", "nv", "z", "yn", "ns", "k", "nl", "nn", "r", "ne", "o", "no", "na", "nt", " N", "sn", "an", "nan", "nil", "ln", "nw", "node", "un", "NL", "next", "p", "name", "nc"], "R": ["V", "RS", "G", "P", "RE", "W", "ER", "J", "RB", "Y", "Re", "RG", "N", "O", "B", "c", "MR", "RF", "Rs", "GR", "D", "RL", "H", "r", "RA", "BR", "RC", "SR", "RM", "Reader", "A", "RT", "RO", "X", "VR", "E", "S", "RR", "DR", "L", "U", "F", "CR", "IR", "Res", "TR", "Q", "RES", "AR", "HR", "RP", "Co"], "C": ["V", "CS", "G", "CV", "CO", "Y", "CAR", "CG", "Count", "Code", "c", "CF", "Length", "K", "JC", "CT", "E", "CA", "U", "CR", "CN", "CI", "CC", "N", "MC", "B", "Car", "CB", "Ch", "CE", "CU", "I", "S", "Size", "F", "WC", "SC", "length", "Cr", "CL", "D", "Cs", "H", "Cl", "CD", "CP", "Cons", "Q", "Cu", "TC", "AC", "P", "Chain", "J", "COR", "SIZE", "O", "HC", "CM", "DC", "A", "X", "EC", "BC", "L", "CON", "MAX", "Con", "Co"], "M": ["V", "Mon", "G", "MAN", "W", "P", "MT", "J", "Multi", "Y", "m", "N", "Mc", "O", "MC", "B", "CM", "MR", "JM", "D", "H", "Ms", "MI", "IM", "MO", "LM", "MD", "RM", "Memory", "Me", "A", "I", "X", "E", "MAT", "S", "MIT", "L", "PM", "F", "U", "Q", "TM", "MS", "MM", "NM", "Z", "MA", "VM", "DM", "AM"], "x": ["s", "mx", "ax", "y", "xs", "xt", "t", "xe", "f", "m", "xd", "xi", "ix", "xa", "fx", "c", "z", "e", "k", "xy", "xb", "r", "q", "px", "xf", "X", "xx", "dx", "wx", "v", "ex", "inx", "nex", "ctx", "p", "ux", "a", "tx", "xc", "i", "rx"], "dots": ["tates", "tshots", "hits", " dents", "Dits", "hdots", "hots", "draots", "digots", "Drots", "odots", "dot", "tiffs", " dends", "bdugs", "nates", "digogs", " dotted", "notted", "dotted", "mdates", "bdshots", "draot", "Dots", "drashots", "dets", "mdths", "odOTS", "dhOTS", "daysogs", "sdots", "drots", " dates", "dups", "daysots", "hashes", "dths", "Dends", "dotic", "nots", "tots", "dOTS", "dogs", "odups", " diffs", "dsumps", "Dups", "daysets", "didents", "rshots", " dashes", "dashes", "dugs", "bdumps", "totted", "dshots", "Dashes", "tummies", "sdets", " dups", "sdogs", "dsths", "nits", "dsots", "didots", " dugs", "dsates", "Dot", " dshots", "tits", "draummies", " dumps", "dends", "dhotic", " dOTS", "dits", " dits", "dates", "dummies", "hdot", "Dotic", "mdumps", "DOTS", "dotes", "hrots", "digets", "bdots", "niffs", "rugs", "dents", " dths", "dumps", "odumps", "rots", "hdummies", "mdots", "nOTS", "sdotes", "didends", "rumps", "diffs", "tot", "didOTS", "dhumps", "hdshots", "dhots", "tOTS", " dotic", " drots", "Dumps", "daysotes", "Dents", "digotes"], "l": ["jl", "s", "kl", "ld", "w", "len", "t", "m", "li", "g", "long", "cl", "lin", "c", "h", "z", "lock", "loc", "nl", "fl", "dl", "ls", "lv", "r", "lc", "el", "b", " L", "ml", "o", "left", "tl", "j", "lp", "line", "lang", "v", "L", "sl", "ln", "lr", "pl", "lt", "p", "la", "d", "le", "lo", "ll", "i"], "end": ["ell", "rend", "send", "nd", "ender", " End", "size", "until", "st", "url", "pad", "END", "stay", "offset", "stop", "ended", "order", "ends", "set", "pend", "entry", "call", "start", "append", "close", "edge", "chain", "device", "use", "out", "enter", "commit", "server", "error", "End", "ent", "desc", "std", "exit", "post", "ending"], "lines": ["cs", "s", "RS", "times", "blocks", "cells", "ds", "chains", "cycles", "faces", "sections", "xs", "days", "comments", "steps", "cats", "jobs", "inline", "verts", "N", "links", "levels", "errors", "runs", "items", "Rs", "ns", "rs", "iter", "ls", "r", "files", "lists", "groups", "posts", "RT", "line", "parts", "LIN", "Line", "frames", "objects", "stores", "ln", "tests", "vals", "ines", "codes", "rows", "pages", "LINE", "reads", "LS", "boxes", "points"], "extra": ["more", "expected", "important", "empty", "size", "missing", "item", "absolute", "prime", "t", "optional", "Extra", "equal", "offset", "special", "adding", "total", "ext", "tra", "added", "area", "meta", "other", "fine", "e", "related", "tmp", "border", "relative", "buffer", "interrupted", "exclusive", "auto", "alias", "r", "entry", "depth", " extras", "normal", "o", "inner", "i", "diff", "add", "repeat", "E", "line", "info", "incre", "ras", "er", "di", "external", "secondary", "ex", "alpha", "error", "exc", "aux", "a", "err", "max"], "temp": ["tem", "em", "generated", "empty", "fake", "prime", "t", "tr", "created", "m", "tail", "current", "multi", " temporary", "total", "warm", "test", "porary", "tm", "buffer", "relative", "tmp", "iter", "pt", "Temp", "mem", "mint", "template", "perm", "thread", "v", "ts", "EMP", "pretty", "now", "por", "emp", "stem", "alt", "unt", "level", "trace", "plates", "tim", "p", "tc", "create", "dat"]}}
{"code": "\\n  numCases = input()\\n  for case in range( 1, numCases + 1 ):\\n    C, F, X = raw_input().split()\\n    C = float(C)\\n    F = float(F)\\n    X = float(X)\\n    time = 0.0\\n    rate = 2.0\\n    \\n    while ( True ):\\n      timeToFinish = X / rate\\n      timeToFarm   = C / rate\\n      farmPayoffTime = C / F\\n  \\n      if timeToFinish < ( timeToFarm + farmPayoffTime ):\\n        time += timeToFinish\\n        break\\n      else:\\n        time += timeToFarm\\n        rate += F\\n  \\n  \\n    output = '{0:0.15f}'.format( time )\\n  \\n    print 'Case #' + str( case ) + ': ' + str( output )\\n", "target": "45", "substitutes": {"numCases": ["numSuases", "numRase", " numCcases", "numberCats", "numChases", "numCsase", "numCaps", " numClase", " numClcases", "numSuaps", " numClaps", "numSucases", "numCase", "numBests", "numBase", "numberBases", "numBases", "numChase", "numberCase", "numSuase", "numChats", "numClases", "numCscases", "numCests", "numCsaps", " numCaps", "numClaps", "numberCases", "numRests", "numberBase", "numChests", "numberBests", "numberCests", "numClase", " numCase", "numRats", "numCats", "numClcases", "numCsases", "numBats", "numRases", "numberBats", " numClases", "numCcases"], "case": ["core", "hyp", "mode", "pair", "feature", "cases", "ie", "cer", "test", "set", "example", "ride", "client", "CE", "zero", "block", "rule", "number", "se", "ce", "line", "cycle", "ASE", "chain", "ide", "count", "ase", "cor", "force", "one", "use", "race", "trial", "ice", "code", "once", "row", "ace", " Case", "name", "ion", "Case"], "C": ["V", "CPU", "AC", "CS", "G", "CI", "P", "Time", "CNN", "CC", "CO", "Y", "Mc", "N", "FC", "CL", "M", "MC", "O", "B", "CM", "Car", "c", "D", "CF", "Cs", "Ch", "H", "LC", "CE", "You", "CT", "CU", "T", "A", "DC", "Cl", "I", "R", "E", "CP", "CA", "S", "Cons", "L", "U", "CON", "CW", "VC", "CN", "Con", "Co", "Case"], "F": ["V", "G", "W", "P", "FT", "Time", "FW", "GF", "FS", "FER", "Y", "AF", "f", "Fs", "N", "M", "FC", "MF", "FI", "B", "File", "RF", "D", "CF", "EF", "FL", "FD", "IF", "Farm", "H", "K", "DF", "T", "A", "UF", "I", "R", "E", "FO", "FY", "S", "FG", "L", "U", "FP", "FM", "Rate", "Q", "Z", "FILE", "PF", "FF", "FA", "FE"], "X": ["V", "Tx", "W", "P", "IC", "Time", "J", "FX", "Y", "Input", "XM", "N", "O", "Xi", "EX", "B", "D", "CF", "XL", "IF", "H", "IX", "XX", "T", "A", "Cross", "I", "R", "E", "S", "U", "x", "L", "ICE", "Rate", "UX", "XP", "Q", "CH", "XT", "OX", "Z", "ZX", "FF", "Ex", "FE"], "time": ["timer", "length", "duration", "value", "message", "times", "performance", "rice", "Time", "comment", "timeout", "size", "frequency", "port", "date", "t", "history", "etime", "ime", "offset", "memory", "runtime", "TIME", "rank", "sequence", "tt", "money", "point", "start", "amount", "cycle", "count", "clock", "age", "x", "now", "race", "weight", "speed", "trace", "tim", "delay", "type", "price", "trip"], "rate": ["farm", "power", "rates", "gain", "rice", "core", "frequency", "pe", "peed", "date", "feature", "f", "fee", "ime", "capacity", "rat", "test", " Rate", "fine", "function", "unit", "factor", "rank", "fork", "r", "bank", " rates", "state", "rule", "term", "money", "pay", "count", "currency", "age", "force", "transfer", "Rate", "erate", "race", "error", "speed", "family", " speed", "delay", "scale", "fare", "price", "rage", "relation", "score", "tax"], "timeToFinish": ["timeOfFin", "timetoFarm", "timeTOStart", "timeToStart", " timetoFinish", "timeTOFinish", "TimeToNext", "timeToComplete", "timeTOFin", " timeToStop", "timetoFin", "time_Finish", "timetoComplete", " timeToComplete", " timetoFarm", "timeOfFarm", "timeToNext", " timeToFin", "timeToFin", "TimeToFinish", "timetoStart", "timeToStop", " timetoStart", "time_Next", " timetoComplete", "TimeToStop", " timetoStop", "timetoStop", "timetoFinish", " timeToStart", "time_Stop", " timetoFin", "timetoNext", "timeTOComplete", "timeOfStop", "timeOfFinish"], "timeToFarm": ["timetoFarm", "timeTOStart", "timToFinish", "timtoPen", "timeToStart", " timetoFinish", "time2Start", "timeTOFinish", "timeTOLean", "time2Spider", "timeTooStart", "time2Pen", " timeToLean", "etimeTOFarm", "timetoLean", "timeTOFarm", " timetoFarm", "time2Farm", "timtoFinish", "timeTooFarm", "etimeTOSpider", "etimeToSpider", "timeOfFarm", "etimeToStart", "timToPen", "timetoPen", "timToFarm", "timeTooSpider", "time2Finish", "etimeTOStart", "etimeTOFinish", "etimeToFinish", "timeToPen", "timeOfPen", "timeToLean", "etimeToFarm", "timeTooFinish", "timeToSpider", "timetoFinish", "timtoFarm", "timeTOSpider", "timeOfFinish", " timetoLean"], "farmPayoffTime": ["farmPaydownTime", "farmPayoffLength", "farmPayoffRate", "farmPayoffsLength", "farmPayoffsRate", "farmPaydownTimes", "farmPayoffsTime", "farmPaydownRate", "farmPaydownLength", "farmPayoffTimes", "farmPayoffsTimes"], "output": ["data", "result", "value", "message", "successful", "confidence", "comment", "quiet", "generated", "four", "input", "new", "network", "xml", "text", "put", "status", "write", "reason", "dot", "response", "control", "state", "hidden", "format", "report", "written", "answer", "Output", "pretty", "print", "out", "voice", "success", "human", "command", "position", "next", "log", "content", "console", "string", "display", "coin"]}}
{"code": "\\n  def DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines ):\\n    x = []\\n    numSpaces = 0\\n    numMines = 0\\n  \\n    gridRows = max( R-2, 0 )\\n    gridCols = max( C-2, 0 )\\n  \\n    for r in xrange( 0, R ):\\n      x.append( [] )\\n      for c in xrange( 0, C ):\\n        x[ r ].append( '.' )\\n        numSpaces += 1\\n  \\n    if gridMines > 0:\\n      for r in xrange( 0, gridRows ):\\n        if numMines >= gridMines:\\n          break;\\n        for c in xrange( 0, gridCols ):\\n          x[ r ][ c ] = '*'\\n          numMines += 1\\n          numSpaces -= 1\\n          if numMines >= gridMines:\\n            break;\\n  \\n    for r in xrange( 0, R ):\\n      if sideMines <= 0:\\n        break\\n      for c in xrange( gridCols, C ):\\n        x[ r ][ c ] = '*'\\n        numMines += 1\\n        numSpaces -= 1\\n        sideMines -= 1\\n        if sideMines <= 0:\\n          break\\n  \\n    for c in xrange( 0, C ):\\n      if bottomMines <= 0:\\n        break\\n      for r in xrange( gridRows, R ):\\n        x[ r ][ c ] = '*'\\n        numMines += 1\\n        numSpaces -= 1\\n        bottomMines -= 1\\n        if bottomMines <= 0:\\n          break\\n      \\n    x[ R - 1][ C - 1 ] = 'c'\\n    \\n    if numMines != M and ( R * C ) - M != 1:\\n      print \"ERROR!!!!!!!!!!!!!!!!!!!!!!!!\"\\n      print ( R * C ) - M\\n  \\n  \\n    o = \"\"\\n  \\n    if Flip:\\n      for c in xrange( 0, C ):\\n        for r in xrange( 0, R ):\\n           o += x[ r ][ c ]\\n        o += '\\n'\\n    else:\\n      for r in xrange( 0, R ):\\n        for c in xrange( 0, C ):\\n           o += x[ r ][ c ]\\n        o += '\\n'\\n  \\n    return o[:-1] #strip the extra newline\\n  \\n  \\n  \\n  \\n  numCases = input()\\n  for case in xrange( 1, numCases + 1 ):\\n    R, C, M = [int(x) for x in raw_input().split()]\\n  \\n    Output = None\\n  \\n    Flip = C > R\\n    if Flip:\\n      temp = R\\n      R = C\\n      C = temp\\n  \\n    NonMines = ( R * C ) - M\\n    if ( NonMines == 0 ):\\n      Output = \"Impossible\"\\n    elif ( C == 1 ):\\n      gridMines = 0\\n      extraMines = M - gridMines\\n      Output = DrawMines( R, C, M, Flip, gridMines, extraMines, 0 )\\n    elif ( NonMines == 2 or  NonMines == 3 ):\\n      Output = \"Impossible\"\\n    else:\\n      maxGridCols = max( 0, C - 2 )\\n      maxGridRows = max( 0, R - 2 )\\n      gridMines = min( M, maxGridCols * maxGridRows )\\n      extraMines = M - gridMines\\n      extraPairs = ( extraMines + 1 ) / 2\\n      extraPairsSide = max( min( extraPairs, maxGridRows - 1 ), 0 )\\n      extraPairsBottom = max( min( extraPairs - extraPairsSide, maxGridCols - 1 ), 0 )\\n      safeExtraPairs = extraPairsSide + extraPairsBottom\\n      blockingPairsSide = max( min( extraPairs - safeExtraPairs, 1 ), 0 )\\n      blockingPairsBottom = max( min( extraPairs - blockingPairsSide - safeExtraPairs, 1 ), 0 )\\n      blockingPairs = blockingPairsSide + blockingPairsBottom\\n      totalPairs = safeExtraPairs + blockingPairs\\n  \\n      \\n      if ( gridMines > 0 and extraMines % 2 != 0 and blockingPairs == 0 ):\\n        extraMines += 1\\n        gridMines -= 1\\n  \\n      if ( NonMines == 1 ):\\n        if extraMines % 2 != 0:\\n          extraMines += 1\\n        blockingPairsSide += 1\\n        blockingPairsBottom += 1\\n      \\n      if extraMines % 2 == 0:\\n        sideMines = 2 * ( extraPairsSide + blockingPairsSide )\\n        bottomMines = 2 * ( extraPairsBottom + blockingPairsBottom )\\n        Output = DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines )\\n      else:\\n        Output = \"Impossible\"\\n  \\n    output = \"\\n\" + Output\\n    print 'Case #' + str( case ) + ': ' + str( output )\\n", "target": "45", "substitutes": {"R": ["V", "RS", "G", "P", "RE", "ER", "W", "OR", "Y", "Re", "RG", "N", "O", "B", "MR", "RF", "GR", "Rs", "D", "RL", "RA", "BR", "H", "RC", "SR", "RM", "T", "Row", "A", "RT", "I", "RO", "X", "E", "JR", "S", "RR", "NR", "DR", "L", "U", "Rot", "F", "CR", "IR", "Res", "TR", "Q", "AR", "HR"], "C": ["V", "CS", "G", "W", "P", "Chain", "CV", "COR", "Cow", "CNN", "CC", "CO", "Y", "CAR", "CG", "N", "CL", "O", "MC", "HC", "B", "CM", "D", "CF", "CB", "Cs", "Ch", "CLE", "H", "K", "CE", "JC", "CT", "CCC", "T", "DC", "A", "Charlie", "CU", "CD", "I", "X", "EC", "CP", "E", "S", "BC", "L", "U", "F", "CR", "CON", "Q", "CN", "Z", "WC", "Three", "Co"], "M": ["V", "Mon", "G", "MAN", "W", "P", "MT", "J", "Ma", "Multi", "Y", "m", "Max", "N", "O", "MC", "B", "CM", "MR", "D", "Num", "Length", "H", "ONE", "K", "MI", "RM", "T", "MD", "A", "I", "X", "E", "S", "OK", "Size", "L", "F", "U", "Q", "TM", "MM", "NM", "All", "One", "Z", "DM", "AM"], "Flip": ["Flipped", "Blrip", " FlIP", " Flipping", "Swipe", "FLlip", " flip", "FLipe", " flipped", "Swlip", "Swip", "FLip", "Flipe", " flipe", "FLipped", "flip", "Blipping", "Fllip", "FlIP", "flrip", "BlIP", "Swipped", "Blip", " fllip", "flipping", "Flipping", " Flrip", "flIP", "Flrip"], "gridMines": ["gridGarks", " gridManes", "gridGanes", "gridMeiners", "numMine", "gridMeanes", "numRins", "latSines", "numRanes", "gridRels", "gridMels", "gridMine", "latSows", "numMiners", "gridSows", "gridMows", "gridRins", "numRine", "gridBines", "latMinks", "latMiners", "gridGinks", "latSiners", "latMows", "gridRanes", "gridRiners", "gridMins", " gridMarks", "gridBanes", " gridMiners", "gridPines", "gridGiners", "gridGows", "gridBinks", "gridRine", "gridMiners", "gridMeines", "gridLarks", "gridNMels", "numMels", "gridManes", "gridBarks", "gridPiners", " gridGarks", "gridLines", "gridGines", "gridSinks", "gridBiners", "gridMinks", "latMines", "gridNMines", "gridSiners", "gridSines", "gridPels", "numRiners", "gridNManes", " gridGanes", "gridPine", "numMins", "gridMarks", "gridPanes", " gridGiners", "gridLiners", "numRels", "gridMeine", "numRines", "gridBows", " gridGines", "numManes", "gridRines", "gridNMins", "gridPins", "latSinks", "gridLanes"], "sideMines": ["sideNensions", "sideRains", "sidePines", "sideMananes", "sideMManes", "sideManiners", "sideMMiners", "sideMeaces", "sideMains", "sideMiners", "sideMMains", "sideMeiners", "bottomPines", "SideNensions", "sideNains", "sideManines", "sideMMines", "SideNines", "sideGarks", "sideSensions", "sideMeites", "SideNains", "sideHiners", "bottomPaces", "bottomPiners", "sideSanes", "sideRines", "sideMensions", "sideNines", "SideMiners", "sideNanes", "SideNiners", "SideNanes", "bottomPanes", "sideSines", "sideMaces", "sideRanes", "SideMains", "sideHines", "bottomMiners", "sideRiners", "sideGines", "sideManes", "sideHanes", "sideManaces", "bottomParks", "sidePanes", "SideMites", "SideMensions", "sideHarks", "sideSites", "sideMeensions", "sideNites", "SideManes", "sideNiners", "sideGiners", "bottomMarks", "bottomManes", "sideMeanes", "sideMites", "sidePaces", "SideMines", "sideMeines", "sideParks", "bottomMaces", "SideNites", "sidePiners", "sideGanes", "sideMarks"], "bottomMines": ["sideLinks", "bottomNroups", "bottomMined", "topMones", "bottomNined", "bottomRemines", "bottomVined", "bottomMones", "bottomNiers", "bottomNanes", "bottomPines", "bottomSiers", "bottomRemones", "bottomSanes", "topMiers", "bottomMizes", "bottomMetines", "bottomMetiers", "bottomVanes", "bottomNones", "bottomSines", "bottomLinks", "topNiers", "bottomPanes", "bottomNines", "sideLanes", "topNined", "topMined", "bottomMananes", "topMines", "bottomMetanes", "bottomPinks", "topNines", "bottomMiers", "sideManes", "bottomLizes", "topMroups", "bottomManines", "topNinks", "bottomNaces", "bottomManined", "bottomNinks", "bottomSinks", "bottomLanes", "sideMizes", "bottomManroups", "bottomSones", "bottomVroups", "bottomRemanes", "topNones", "bottomMroups", "bottomPizes", "topManes", "topMaces", "bottomSaces", "bottomMetaces", "bottomManes", "bottomReminks", "bottomVines", "topMinks", "sideMinks", "bottomMaces", "topNroups", "sideLizes", "topNaces", "topNanes", "sideLines", "bottomLines", "bottomMinks"], "x": ["s", "php", "y", "xs", "w", "xt", "t", "xe", "xd", "xml", "work", "f", "xi", "xp", "n", "m", "l", "index", "xa", "fx", "lex", "z", "xy", "e", "check", "xb", "xes", "px", "xf", "X", "xx", "wx", "v", "xxxx", "ox", "ex", "p", "ux", "tx", "a", "h", "xc", "exp", "ct", "i", "rx"], "numSpaces": ["nSpans", "numStices", "numSpacepaces", "numSpans", "numSpaceaces", "numSpace", "numSPaces", "numspots", "numPans", "numberSpaces", "numberSpans", "numSace", "numPaces", "numSPace", "numberSpices", "numSots", "numSpots", "numSPresses", "numSaces", "numStpaces", "numspace", "numberSppaces", "numSpaceices", "numberSPans", "numberSPices", "numSppaces", "nspots", "numberSpabs", "numStaces", "numberSPaces", "nSpots", "numspans", "numsppaces", "numberSPabs", "numSpresses", "numSpabs", "numSPans", "numSPices", "nSpices", "numStabs", "numPabs", "numberSPresses", "nSpaces", "numStresses", "numSPpaces", "nspace", "nspaces", "numspaces", "numSpices", "numSPots", "numberSPpaces", "nspices", "numberSpresses", "numspices", "numSices", "numSans", "nspans", "numStans", "numSpaceans", "nSpace", "numSPabs", "numPresses"], "numMines": ["nMaces", "numEmanes", "gridNears", "numMine", "numGines", "numMizes", "numRaces", "numberMiles", "numNiles", "nPaces", "gridMears", "numberMaces", "numPanes", "numNaces", "numMonine", "numSanes", "numLiles", "numMonines", "numLaces", "numRine", "numMears", "nPelines", "numberNiles", "nPines", "numDines", "sumRines", "numLanes", "nPanes", "numSine", "numNines", "sumRine", "numPains", "numLears", "sumMaces", "numberNanes", "nManes", "gridNines", "numDanes", "nPains", "sumMelines", "numSpanes", "numberNaces", "numSpains", "gridNaces", "numNanes", "numPelines", "numMains", "gridManes", "numberManes", "sumMines", "numSines", "numMonaces", "numEmelines", "numberNizes", "nMelines", "numberMines", "numGelines", "numberMizes", "numMelines", "numSpines", "numPizes", "numPiles", "sumRelines", "numMiles", "numDizes", "numEmaces", "numNears", "numGanes", "numSains", "numEmines", "numPears", "numLines", "numMaces", "numRelines", "numMonelines", "numPines", "sumRaces", "nMines", "numPaces", "numNizes", "numGaces", "numSaces", "gridNanes", "numRines", "gridMaces", "sumMine", "numberNines", "numDaces", "numManes", "numSelines", "nMains"], "gridRows": [" gridLoots", "GridRoots", "gridLows", "gridROWS", "gridrods", " gridLOWS", "gridLoots", " gridRines", "gridRrows", " gridRrows", "gridRods", "gridRsrows", "gridLOWS", "GridLoots", "GridLows", " gridROWS", "gridRsods", "gridGRines", "gridLines", "GridLrows", "gridSines", "GridLods", "gridLoles", " gridLows", "gridrows", "gridNrows", "gridrrows", "GridRows", " gridLines", "gridRoots", "gridRsoots", "gridRsows", "gridSOWS", " gridRoles", "gridroots", "GridRods", "gridSoles", " gridLoles", "gridSows", "gridNOWS", "gridRoles", " gridRoots", "gridRines", "gridNows", "gridLods", "gridNoots", " gridLrows", "gridLrows", "GridRrows", "gridGROWS", "gridGRows", "gridGRoles"], "gridCols": ["numColumnows", "gridColumns", "numCols", "gridcolabs", "gridCollows", "numColumnols", "gridDocols", "gridDocabs", "gridColumnols", "gridColumnls", "gridColes", "gridcoles", "numColols", "gridColls", "gridColols", "numColumnabs", "Gridcols", "gridDocows", " gridcolls", "GridColabs", "GridColes", "gridColumnes", "gridcolols", "gridcols", " gridcolabs", "numColumns", "gridColumnabs", "gridcolls", "gridColumnows", "Gridcoles", "Gridcolabs", "gridColows", "gridcolows", "gridCollabs", "numColabs", " gridColls", "gridCollls", " gridColabs", " gridcols", " gridcolows", " gridColows", "gridDocs", "GridCols", "gridColabs", "numColows"], "r": ["hr", "t", "tr", "g", "l", "attr", "rd", "rn", "rs", "root", "k", "q", "ir", "b", "ar", "rc", "j", "v", "cut", "rar", "a", "ct", "range", "adr", "dr", "art", "w", "e", "kr", "cur", "pr", "rec", "res", "p", "h", "rr", "f", "m", "ren", "ru", "n", "can", "sr", "rem", "ro", "ur", "mr", "lr", "fr", "vr", "d", "rg", "byter", "rb", "result", "rt", "cr", "gr", "rer", "re", "br", "unc", "rel", "rh", "chain", "str", "cu", "er", "row"], "c": ["cs", "cr", "cp", "cont", "ch", "cf", "ic", "y", "u", "t", "f", "m", "g", "n", "l", "can", "gc", "ac", "h", "ec", "arc", "con", "mc", "k", "e", "\u00e7", "call", "dc", "lc", "co", "cus", "b", "fc", "unc", "cur", "bc", "ar", "rec", "ce", "rc", "sc", "cache", "chain", "cor", "v", "count", "cat", "cu", "cy", "ca", "pc", "code", "col", "cm", "ci", "p", "ct", "content", "d", "a", "tc", "i", "nc", "cc"], "o": ["data", "os", "to", "do", "u", "y", "mo", "bo", "onet", "ic", " i", "t", "f", "ooo", "ho", "ando", "uo", "m", "w", "n", "O", "ato", "l", " yo", "z", "e", "xy", "po", " mo", "auto", "co", "go", "ro", "oto", "no", "i", "fo", "cho", "oin", "line", "output", "v", "ao", "ox", "oa", "di", "out", " O", "so", "off", "oo", "vo", "iso", "p", "ano", "d", "io", "h", "lo", "yo", "ot", "\u00f3"]}}
{"code": "\\n  def oneMoreFarm(C, F, nFarms):\\n  \treturn C/(2.0 + nFarms*F)\\n  \t\\n  \\n  \\n  inputFileName = sys.argv[1]\\n  \\n  f = file(inputFileName)\\n  fout = file(\"output.txt\", \"w\")\\n  \\n  T = int(f.readline().strip())\\n  \\n  for case in xrange(T):\\n  \\n  \tdata = f.readline().split()\\n  \tC = eval(data[0])\\n  \tF = eval(data[1])\\n  \tX = eval(data[2])\\n  \\n  \ttmin = X/2.0\\n  \tfoundMin = False\\n  \\n  \tS = 0\\n  \tnFarms = 0\\n  \\n  \twhile not foundMin:\\n  \t\tnFarms += 1\\n  \t\tS += oneMoreFarm(C, F, nFarms - 1)\\n  \t\tt = S + X/(2.0 + nFarms*F)\\n  \t\tif t < tmin:\\n  \t\t\ttmin = t\\n  \t\telse:\\n  \t\t\tfoundMin = True\\n  \\n  \tfout.write(\"Case #%d: %.7f\\n\" %(case + 1, tmin))\\n", "target": "46", "substitutes": {"C": ["V", "CS", "G", "W", "P", "CI", "CNN", "Cow", "CC", "Y", "N", "M", "O", "MC", "B", "c", "CM", "D", "CF", "YC", "Cs", "Ch", "H", "K", "CE", "CT", "DC", "A", "I", "R", "E", "CP", "CA", "L", "U", "CR", "CON", "VC", "Co", "Craig", "Case"], "F": ["V", "G", "W", "P", "FT", "GF", "FW", "FR", "FS", "Fs", "Y", "FER", "AF", "Feed", "N", "M", "FB", "MF", "B", "File", "RF", "Foreign", "TF", "D", "CF", "EF", "FL", "FD", "IF", "Fi", "H", "DF", "UF", "I", "R", "E", "FO", "FY", "FG", "Field", "L", "U", "FM", "FN", "Fun", "Q", "SF", "Z", "PF", "FF", "Family", "FE"], "nFarms": ["nParms", "nfars", "nMarms", " nWeatures", "nPrees", " nFears", "nRFairs", " nFFairs", "nWounters", "NFers", "nFamilyarms", "nDers", "nFairs", "nRFarms", "nFeatures", "nRFears", "nFamilyarts", "nFiers", " nfars", "NDers", "NFees", "nFamilyears", "pFarm", "nMrees", " nfarms", " nFrees", "nFFarts", "nNarms", "nAFrees", "nFees", "pParm", "nMers", "pPiers", "nWarts", " nFairs", " nFarts", "nfarts", "nVounters", "nfarm", " nFeatures", "NFarts", "nWarm", "nForearms", "nAFarm", "nFFears", "nFears", "nWiers", "nPrefounters", "nFers", "NDarts", "nNars", "nPrefeatures", " nFarm", "nFFairs", " nWarm", "pFarms", "nFounters", "nDees", " nFFarts", " nFFears", " nfrees", "nAFiers", "nfrees", "pPrees", "nFamilyairs", "nFarm", "nFFarms", "nMees", "nParm", "nWarms", " nFars", "nRFarts", "nForearts", "nDarms", "nFars", "NDarms", "nAFarms", "pFiers", "nWars", " nfarts", "nMarm", "nForeees", "NDees", "nDarts", "NFarms", "nVarms", "nWeatures", "nVarm", " nWounters", "nVeatures", "nNarm", "nWrees", "nPrefarm", "nMarts", " nWarms", " nfarm", "nNrees", "nFrees", " nFFarms", "nFarts", " nFounters", "nForeers", "pFrees", "nfarms", "nPrefarms", "nPiers", "pParms"], "inputFileName": [" inputFileNo", "inputFilenameNo", "inputSourceFileNames", "inputFileNum", "inputfilePath", "inputPathName", "InputfilePath", " inputFileNum", " inputPathPath", "inputfileNames", "inputFilenameNum", "InputFileNames", "InputfileSet", "inputFilenameName", "inputSourceFileSet", "inputPathNo", "inputfileNum", "inputFilePath", "inputFilenameNames", "inputFileNames", "inputPathPath", "inputFilenameSet", " inputFilePath", "InputFileName", " inputPathNo", "InputfileNames", "InputfileName", "inputFileSet", "inputfileName", "inputFileNo", "inputfileSet", "inputFilenamePath", " inputPathName", "inputSourceFilePath", " inputPathNum", "InputFileSet", "inputPathNum", "inputfileNo", "inputSourceFileName", "InputFilePath"], "f": ["inf", "af", "file", "w", "g", "up", "it", "fast", "ft", "l", "sf", "fx", "c", "fs", "h", "bf", "fb", "fe", "e", "iu", "r", "tf", "elf", "fc", "fo", "o", "fa", "fg", "xf", "uf", "v", "ow", "fd", "fr", "feed", "p", "fp", "df", "lo", "fm", "i", "lf", "form"], "fout": ["tstore", "foutput", "hout", "fstore", "fOut", "fin", " foutput", "houtput", "tOut", "hOut", "toutput", " fstore", " fin", "dOut", "tin", "dstore", " fOut", "dout", "hin", "din", "tout"], "T": ["V", "P", "TB", "J", "Time", "TN", "Y", "N", "M", "AT", "TA", "B", "D", "TT", "TY", "H", "K", "TP", "A", "I", "R", "E", "TS", "NT", "L", "TH", "Q", "TR", "TM", "Z", "TC"], "case": ["Test", "choice", "P", "to", "pe", "mode", "cases", "condition", "index", "test", "c", "name", "nce", "set", "sequence", "example", "client", "CE", "ce", "cycle", "ASE", "chain", "cor", "ase", "trial", "race", "use", "ice", "code", "cas", "success", "me", "p", "ace", " Case", "tc", "TC", "Case"], "data": ["json", "pie", "times", "ata", "series", "new", "date", "details", "base", "done", "step", "text", "key", "window", "pieces", "keys", "query", "user", "bus", "da", "rew", "bytes", "set", "table", "group", "time", "zero", "block", "batch", "Data", "video", "results", "rel", "raw", "cache", "info", "frame", "chain", "reader", "dates", "str", "device", "join", "read", "list", "debug", "filter", "feed", "DATA", "vals", "next", "d", "aw", "values", "dat"], "X": ["V", "Tx", "W", "P", "J", "TX", "XY", "Y", "AF", "N", "M", "EX", "B", "D", "XL", "H", "IX", "XX", "Data", "DX", "I", "R", "E", "TS", "L", "x", "U", "XP", "Q", "XT", "Z", "FE"], "tmin": ["fdiff", " tMin", "Tmins", "tmins", "Tmini", "dtmin", "tMIN", "tdiff", "lmax", "ttstart", "Tdiff", "ttlt", "tstart", "dtstart", "pmin", "pMin", " tmax", "ttMIN", "ttmin", "TMin", "lmin", " tmini", "Tmax", "dtMin", "pstart", "Tminimum", "ttminimum", "fMin", "dtlt", "tminimum", " tMIN", "TMIN", " tdiff", "tmini", " tminimum", " tmins", "ttMin", "Tmin", "lMin", "tMin", "fmins", "tlt", "plt", "tmax", "lmini", "fmin"], "foundMin": [" foundmin", "usedMin", "foundVal", "keptMIN", " foundVal", "foundMIN", "FoundVal", "usedMini", " foundMIN", "foundmin", "findmin", "foundMini", "FoundMIN", "keptMini", "usedMinimum", "FoundMin", "FoundMini", "Foundmin", " foundMinimum", "findVal", "findMin", "keptmin", "keptMin", "foundMinimum", " foundMini", "FoundMinimum", "usedmin", "findMini"], "S": ["V", "s", "RS", "CS", "G", "W", "P", "J", "Y", "SI", "SA", "N", "M", "O", "B", "NS", "D", "SS", "H", "K", "SR", "Su", "WS", "A", "SU", "I", "R", "E", "TS", "Si", "Size", "L", "U", "Q", "State", "MS", "Z"], "t": ["title", "s", "kt", "rt", "to", "ta", "y", "new", "at", "st", "g", "tw", "m", "xt", "got", "it", "n", "ot", "l", "total", "lat", "test", "c", "h", "txt", "z", "tm", "k", "pt", "r", "time", "tt", "b", "tail", "temp", "j", "elt", "v", "ts", "x", "te", "dt", "p", "tick", "ct", "a", "d", "tz", "tc", "wt", "i", "qt"]}}
{"code": "\\n  def transpose(result, R, C):\\n  \tresultSplitted = result.split(\"\\n\")\\n  \taux = R*[\"\"]\\n  \tfor i in xrange(R):\\n  \t\tfor j in xrange(C):\\n  \t\t    aux[i] += resultSplitted[j][i]\\n  \t\taux[i] += \"\\n\"\\n  \tresult = \"\"\\n  \tfor item in aux:\\n  \t\tresult += item + \"\\n\"\\n  \treturn result.strip()\\n  \\n  \\n  inputFileName = sys.argv[1]\\n  \\n  f = file(inputFileName)\\n  fout = file(\"output.txt\", \"w\")\\n  \\n  T = int(f.readline())\\n  \\n  for case in xrange(T):\\n  \tdata = f.readline().strip().split(\" \")\\n  \tR = int(data[0])\\n  \tC = int(data[1])\\n  \tM = int(data[2])\\n  \\n  \tresult = \"\"\\n  \\n  \tx = min(R,C)\\n  \ty = max(R,C)\\n  \\n  \tif M > (y - 2)*x and M != y*x - 1:\\n  \t\tN = M - (y-2)*x\\n  \t\tif N%2 == 1 or y*x - M == 2:\\n  \t\t\tresult = \"Impossible\"\\n  \tif result != \"Impossible\":\\n  \t\ti = 0\\n  \t\twhile M > 0: # 2\\n  \t\t\tif i < y - 2:\\n  \t\t\t\tif M >= x:\\n  \t\t\t\t\tresult += x*\"*\" + \"\\n\"\\n  \t\t\t\t\tM -= x\\n  \t\t\t\t\ti += 1\\n  \t\t\t\telif M <= x - 2:\\n  \t\t\t\t\tresult += M*\"*\" + (x - M) * \".\" + \"\\n\"\\n  \t\t\t\t\tM = 0\\n  \t\t\t\t\ti += 1\\n  \t\t\t\telif i + 2 < y - 1:\\n  \t\t\t\t\tresult += (M-1)*\"*\" + (x - M + 1) * \".\" + \"\\n\" + \"*\" + (x-1)*\".\" + \"\\n\"\\n  \t\t\t\t\tM = 0\\n  \t\t\t\t\ti += 2\\n  \t\t\t\telse:\\n  \t\t\t\t\tresult = \"Impossible\"\\n  \t\t\t\t\tbreak\\n  \t\t\telse:\\n  \t\t\t\tif M%2 != 0:\\n  \t\t\t\t\tresult += x*\"*\" + \"\\n\"\\n  \t\t\t\t\tresult += (x-1)*\"*\" + \"c\"\\n  \t\t\t\telse:\\n  \t\t\t\t\tn = M/2\\n  \t\t\t\t\tresult += n*\"*\" + (x-n)*\".\" + \"\\n\"\\n  \t\t\t\t\tresult += n*\"*\" + (x-n-1)*\".\" + \"c\"\\n  \t\t\t\tM = 0\\n  \t\t\t\ti += 2\\n  \t\t\t\t\t\\n  \t\twhile i <= y - 1 and result != \"Impossible\":\\n  \t\t\tif i == y - 1:\\n  \t\t\t\tresult += (x-1)*\".\" + \"c\"\\n  \t\t\telse:\\n  \t\t\t\tresult += x*\".\" + \"\\n\"\\n  \t\t\ti += 1\\n  \t\\n  \tif R < C and result != \"Impossible\":\\n  \t\tresult = transpose(result, R, C)\\n  \\n  \tfout.write(\"Case #%d:\\n%s\\n\" %(case + 1, result))\\n", "target": "46", "substitutes": {"result": ["match", "complete", "RESULTS", "order", "full", "root", "table", "rc", "true", "report", "output", "answer", "type", "evaluate", "summary", "expression", "successful", "comment", "sql", "buffer", "ERROR", "function", "e", "r", "term", "results", "ret", "res", "prefix", "the", "out", "command", "p", "name", "string", "ME", "Result", "message", "asm", "search", "new", "successfully", "m", "total", "grade", "false", "this", "status", "response", "back", "final", "value", "OUT", "text", "test", "reason", "sequence", "example", "su", "make", "product", "format", "number", "obj", "ULT", "cache", "description", "package", "success", "error", "row", "reverse", "relation"], "R": ["V", "RS", "G", "Result", "RE", "P", "J", "RAM", "Range", "Y", "Re", "RG", "B", "MR", "RF", "Rs", "GR", "D", "RL", "RA", "r", "H", "BR", "RC", "SR", "RGB", "ro", "RM", "A", "RT", "I", "RO", "X", "RI", "S", "RR", "NR", "DR", "U", "F", "L", "Rot", "CR", "IR", "Mr", "Res", "TR", "Q", "AR"], "C": ["V", "CS", "G", "CV", "P", "J", "CNN", "CC", "CO", "Y", "CL", "MC", "B", "CM", "c", "D", "CB", "YC", "CF", "Cs", "Ch", "JC", "CE", "CT", "LC", "CU", "DC", "Cl", "I", "X", "EC", "CP", "E", "CA", "S", "BC", "L", "F", "CR", "CON", "Q", "Cu", "CW", "VC", "CN", "WC", "Co", "SC"], "resultSplitted": ["resultsplited", "Resultsplatted", "ResultSplatted", "resultPlatted", "resultPlotted", " resultSplited", "resultSPotted", "ResultSplitted", "resultPlitted", "Resultsplotted", "resultsplotted", "resultSPitted", "resultsplitted", "resultsplit", " resultSplatted", "resultSPatted", "Resultsplitted", "resultSplotted", "resultPlit", " resultSplit", "resultSplatted", "ResultSplotted", "resultSplited", "resultSplit", "resultsplatted", "resultPlited", "ResultSplited", "resultSPited", "Resultsplited"], "aux": ["conf", " Aux", "af", "xxx", "actions", "abc", "amps", "iq", "names", "buff", "Items", "finals", "jobs", "buf", "aus", "ru", "us", "area", "items", "axe", "rs", "tmp", "aos", "aff", "alias", "utils", "ai", "extra", "obj", "rc", "bs", "res", "ras", "ox", "sup", " auxiliary", "args", "external", "foo", "abs", "ex", "ux", "au", "offs", "a", "array", "final", "etc", "tx"], "i": ["ti", "s", "int", "ini", "ic", "u", "ind", "t", "pi", "li", "m", "xi", "multi", "it", "n", "l", "index", "c", "h", "z", "bi", "e", "k", "id", "ij", "iu", "r", "ir", "q", "ai", "im", "o", "I", "si", "mi", "v", "ik", "ip", "ii", "ci", "p", "a"], "j": ["jl", "ja", "J", "jj", "ind", "t", "li", "g", "n", "kj", "it", "l", "ix", "c", "aj", "z", "bi", " ii", "jp", "dj", "k", "ij", "jc", "q", "jac", "bj", "b", "o", "left", "obj", "si", "v", "di", "jump", "uj", "p", "ji", "name", "job", "oj"], "item": ["value", "ue", "gem", "it", "key", "ix", "index", "area", "items", "option", "what", " Item", "other", "ite", "unit", "iter", "q", "ai", "mem", "im", "inner", "obj", "mod", "Item", "element", "aq", "ox", "sim", "ip", "row", "val", "anything", "name", "instance", "job", "iq", "oj"], "inputFileName": ["inputFILENames", "inputFileLine", "outputFilenameLine", "inputFILEName", "inputfilePath", "outputFileFull", "inputFileFull", "InputfilePath", "outputFileLine", "inputfileNames", "outputFilenameFull", "InputFileSystem", "outputFilenameName", "inputFILEPath", "inputFilenameSystem", "inputFilenameFull", "InputFileNames", "InputfileSystem", "inputFilenameName", "inputFILELine", "inputfileSystem", "inputFILEFull", "inputFilenameNames", "inputFilenameLine", "inputStringLine", "inputFilePath", "inputFileNames", "outputFileName", "outputFilenameNames", "inputStringNames", "inputFILESystem", "InputFileName", "InputfileNames", "inputStringName", "InputfileName", "inputfileName", "inputStringFull", "outputFileNames", "inputFilenamePath", "inputFileSystem", "InputFilePath"], "f": ["inf", "af", "of", "file", "cf", "w", "t", "sp", "ft", "l", "sf", "c", "fs", "h", "bf", "fb", "e", "r", "tf", "b", "fc", "fo", "o", "fa", "xf", "uf", "alf", "fn", "v", "F", "fw", "out", "fd", "fr", "feed", "p", "fp", "df", "fm", "lf"], "fout": [" fOut", "dfin", "fOut", "dfout", "Fin", " fin", "fin", "fname", "Fout", "Fname", "dfname", "dfOut", "FOut", " fname"], "T": ["V", "W", "P", "TB", "J", "TN", "t", "Y", "O", "B", "TA", "D", "TT", "TY", "K", "I", "X", "E", "TS", "S", "NT", "L", "F", "TH", "Q", "TM", "TI", "TC", "OT", "TL"], "case": ["ti", "Test", "P", "J", "ta", "li", "key", "test", "z", " ii", "D", "time", " c", "Item", "X", " J", " ti", "S", " trial", "ox", " I", "trial", "Ti", "JD", "Z", "name", "job", "Case"], "data": ["sample", "json", "times", "ds", "ata", "series", "stats", "ops", "new", "date", "details", "first", "steps", "done", "step", "key", "window", "area", "items", "pieces", "keys", "ns", "rew", "da", "bytes", "table", "mu", "group", "zero", "block", "Data", "no", "rel", "raw", "cache", "info", "chain", "dates", "apps", "bits", "list", "filter", "feed", "DATA", "row", "next", "vals", "d", "val", "aw", "values", "dat"], "M": ["V", "G", "W", "P", "MT", "J", "Y", "m", "MC", "B", "CM", "MN", "D", "H", "K", "MI", "A", "I", "X", "E", "S", "L", "F", "U", "Q", "TM", "MS", "MX", "MM", "NM", "Z", "DM"], "x": ["length", "mx", "int", "ax", "size", "xs", "w", "xt", "t", "m", "Y", "xi", "n", "l", "ix", "text", "key", "width", "c", "z", "xy", "rx", "r", "q", "time", "X", "min", "xx", "dx", "v", "ox", "L", "ex", "MX", "p", "ct", "a", "d", "h", "tx"], "y": [" Y", "my", "gy", "ay", "two", "ty", "ch", "size", "hot", "w", "ya", "t", "Y", "m", "g", "sky", "n", "l", "yt", "c", "z", "ies", "py", "xy", "yy", "ny", "r", "b", "o", "ey", "by", "uy", "year", "yr", "v", "sy", "cy", "ym", "p", "type", "a", "height", "h", "dy"], "N": ["Ns", "V", "W", "P", "J", "TN", "NA", "Y", "n", "Ni", "O", " n", "NS", "D", "H", "I", "X", "E", "S", "NT", "NC", "NR", "Size", "L", "F", "Q", "NM", "NI"]}}
{"code": "\\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      T = int(f.readline())\\n      for _T in xrange(T):\\n          C, F, X = map(float, f.readline().split())\\n  \\n          cps = 2.0\\n          t = 0.0\\n          best_t = X / cps\\n  \\n          while True:\\n              t += C / cps\\n              if t >= best_t:\\n                  break\\n  \\n              cps += F\\n              best_t = min(best_t, t + X / cps)\\n  \\n          print \"Case #%d: %.7f\" % (_T+1, best_t)\\n", "target": "47", "substitutes": {"f": ["inf", "af", "of", "file", "cf", "input", "g", "n", "ft", "l", "sh", "sf", "fx", "c", "fs", "h", "bf", "ac", "fb", "iter", "tf", "elf", "b", "fc", "fo", "o", "fa", "fg", "xf", "obj", "uf", "alf", "v", "x", "fd", "fr", "feed", "p", "d", "fp", "df", "aw", "lo", "fm", "i", "lf"], "fn": ["nm", "kl", "cmd", "nu", "file", "cf", "dn", "typ", "n", "orth", "bf", "txt", "rn", "fin", "function", "ns", "fl", "orig", "fc", "unc", "path", "obj", "fun", "nt", "sn", "ff", "filename", "syn", "FN", "nil", "ln", "fr", "cn", "fp", "name", "fm", "lf", "nc"], "T": ["V", "GT", "P", "TB", "J", "Time", "TN", "Y", "N", "M", "B", "TA", "D", "TT", "TV", "TY", "K", "A", "I", "R", "TS", "S", "NT", "TH", "L", "TR", "Q", "TM", "Z", "TC", "OT"], "_T": [" _A", " _DT", "_A", "_DT", " _TH", "_N", "_Y", " _N", "_TH", " _Y"], "C": ["V", "CS", "G", "CI", "P", "W", "Cos", "CC", "CO", "Y", "N", "M", "FC", "B", "c", "CM", "D", "CB", "YC", "CF", "Cs", "H", "K", "CT", "A", "I", "R", "CP", "S", "Cons", "L", "CR", "TC", "Co"], "F": ["V", "G", "W", "P", "FT", "J", "GF", "Fs", "Y", "N", "M", "O", "B", "D", "CF", "H", "K", "DF", "A", "I", "R", "E", "S", "FG", "L", "U", "Q", "Z", "PF", "FF"], "X": ["V", "G", "W", "P", "J", "TX", "FX", "XY", "Y", "N", "M", "FC", "EX", "D", "CF", "XL", "H", "K", "IX", "XX", "A", "DX", "I", "R", "E", "S", "L", "x", "U", "UX", "XP", "Q", "XT", "OX", "MX", "Z", "ZX", "FF", "FE"], "cps": ["gcPS", "Ccs", "pales", "gcops", " cpps", "Cgs", " cms", " cgs", "Ccaps", "ccpps", "ccs", "ucPS", " ccs", "cPS", " cops", " cpp", "tcps", "Cpps", "cms", "CPS", "coaps", "cales", "ucps", "fcPS", "gcgs", " caps", "coales", "coups", " cups", "pts", "Cops", "ucips", "caps", "tcaps", "coms", "fcips", "ccaps", "tccs", "cccaps", "tcups", "pps", "cpp", "cips", " ccaps", "cops", "cccs", " cales", "gcps", " cts", "fcps", "cpps", " cips", "ccps", "cups", "fcpp", "cgs", "cts", "cots", "pms", "cocs", "ucpp", " cPS", "Cps"], "t": ["title", "int", "tree", "to", "ta", "y", "u", "w", "xt", "at", "g", "m", "n", "it", "l", "total", "lat", "c", "tp", "e", "set", "pt", "time", "tt", "b", "tu", "o", "start", "temp", "j", "tip", "v", "ts", "after", "x", "te", "dt", "lt", "p", "d", "tick", "a", "ct", "h", "tc", "wt", "i", "ot"], "best_t": ["bestlogT", "best2y", "Best_d", "bestlogy", "best_n", "best_j", "best_T", "highest_d", "bestlogn", "best_g", "best2T", "best_dt", "bestabled", "bestlogt", "highest_t", "best2n", "bestabledt", "best_p", " best_y", "bestablep", " best_g", " best_T", "best_d", "best_ts", "highest_dt", "best2p", "better_j", " best2t", "bestablet", "better_p", "best2d", " best2n", "best_y", " best2T", "better_ts", "better_t", " best2y", "best2t", "Best_t", "highest_p", " best_d", "Best_p", "Best_T", " best_n"]}}
{"code": "\\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      T = int(f.readline())\\n      for _T in xrange(T):\\n          R, C, M = map(int, f.readline().split())\\n  \\n          print \"Case #%d:\" % (_T+1)\\n  \\n          left = R * C - M\\n  \\n          if R == 1:\\n              s = 'c'\\n              s += '.' * (left - 1)\\n              s += '*' * M\\n              print s\\n              continue\\n          if C == 1:\\n              print 'c'\\n              for i in xrange(left - 1):\\n                  print '.'\\n              for i in xrange(M):\\n                  print '*'\\n              continue\\n  \\n          if left == 1:\\n              print 'c' + '*' * (C-1)\\n              for i in xrange(R-1):\\n                  print '*' * C\\n              continue\\n  \\n          if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\\n              print \"Impossible\"\\n              continue\\n          if R == 2:\\n              assert left not in (2, 3, 5, 7)\\n              assert left >= 4\\n              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)\\n              print '.' + '.' * (left/2 - 1) + '*' * (M/2)\\n              continue\\n          if C == 2:\\n              assert left >= 4\\n              assert left not in (2, 3, 5, 7)\\n              print 'c.'\\n              left -= 2\\n              R -= 1\\n              while left:\\n                  print '..'\\n                  left -= 2\\n                  R -= 1\\n              assert R >= 0\\n              while R:\\n                  print '**'\\n                  R -= 1\\n              continue\\n  \\n          assert R >= 3\\n          assert C >= 3\\n  \\n          if left == 4:\\n              print 'c.' + '*' * (C-2)\\n              print '..' + '*' * (C-2)\\n              for i in xrange(R-2):\\n                  print '*' * C\\n              continue\\n  \\n          if left in (2, 3, 5, 7):\\n              print \"Impossible\"\\n              continue\\n  \\n          assert left >= 6\\n  \\n          cols = max(3, (left + R-1) // R)\\n  \\n          if left % cols == 1:\\n              assert left >= 10\\n  \\n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\\n              left -= cols\\n              R -= 1\\n  \\n              while left > cols + 1:\\n                  print '.' * cols + '*' * (C - cols)\\n                  left -= cols\\n                  R -= 1\\n              assert left == cols + 1\\n              print '.' * (cols - 1) + '*' * (C - cols + 1)\\n              print '.' * (2) + '*' * (C - 2)\\n              R -= 2\\n  \\n              assert R >= 0\\n  \\n              while R:\\n                  print '*' * C\\n                  R -= 1\\n              continue\\n          else:\\n              assert left >= 6\\n  \\n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\\n              left -= cols\\n              R -= 1\\n  \\n              while left > cols:\\n                  print '.' * cols + '*' * (C - cols)\\n                  left -= cols\\n                  R -= 1\\n              assert left >= 2\\n              print '.' * (left) + '*' * (C - left)\\n              R -= 1\\n  \\n              assert R >= 0\\n  \\n              while R:\\n                  print '*' * C\\n                  R -= 1\\n              continue\\n  \\n          1/0\\n", "target": "47", "substitutes": {"f": ["inf", "af", "of", "file", "y", "cf", "w", "t", "m", "g", "n", "fast", "l", "ft", "sf", "c", "fs", "h", "bf", "ac", "fb", "e", "r", "tf", "elf", "b", "fc", "fo", "o", "fa", "xf", "uf", "alf", "v", "F", "fw", "x", "fd", "open", "feed", "fr", "p", "d", "fp", "df", "fm", "lf"], "fn": ["nm", "cmd", "file", "TN", "cf", "np", "dn", "typ", "n", "mn", "N", "bf", "txt", "rn", "rm", "full", "fin", "function", "fl", "tf", "fc", "unc", "path", "format", "obj", "fun", "nt", "sn", "ff", "F", "filename", "syn", "FN", "out", "ln", "fd", "fr", "cn", "fp", "name", "fm"], "T": ["V", "G", "W", "P", "TB", "FT", "J", "TN", "t", "Y", "N", "O", "B", "TA", "D", "TT", "H", "A", "I", "X", "E", "TS", "S", "WT", "NT", "L", "F", "TH", "TR", "TM", "IT", "Z"], "_T": [" _C", "_N", "_R", " _R", " _Z", " _E", " _N", "_C", "_E", "_Z"], "R": ["V", "RS", "G", "P", "W", "RE", "ER", "J", "Y", "RG", "N", "Right", "O", "B", "MR", "RF", "Rs", "D", "Left", "RL", "H", "r", "RA", "BR", "RC", "RN", "SR", "K", "ro", "RM", "Row", "A", "RT", "I", "RO", "X", "E", "S", "RR", "DR", "L", "F", "U", "Rot", "CR", "Res", "TR", "Q", "right", "AR", "Z"], "C": ["V", "Can", "CS", "G", "COM", "W", "P", "Chain", "J", "COR", "CC", "CO", "Y", "CAR", "CG", "Mc", "N", "Right", "O", "MC", "HC", "B", "c", "CM", "CL", "D", "Cs", "Ch", "H", "K", "CCC", "CT", "CU", "A", "Cl", "DC", "I", "X", "E", "CP", "EC", "S", "Cons", "L", "F", "U", "Config", "CR", "Cu", "CW", "VC", "WC", "Con", "Co", "SC"], "M": ["V", "ME", "G", "MAN", "W", "P", "MT", "J", "Y", "m", "N", "O", "MC", "B", "CM", "MR", "JM", "D", "Left", "H", "MP", "K", "MI", "LM", "MD", "RM", "A", "I", "X", "E", "S", "L", "F", "U", "PM", "Q", "TM", "MS", "MM", "NM", "MA"], "left": ["FT", "last", "small", "t", "location", "it", "only", "l", "cl", "c", "full", "loc", "Left", "root", "check", "co", "path", "start", "j", "low", "top", "right", "lt", "LL", " l", "ion", "just", "log", "range", "second", "cont", "to", "w", "none", "center", "r", " L", "term", "RO", "LT", "min", "before", "out", "list", "position", "p", "err", "name", "length", " right", "ner", "len", "sp", "on", "m", "wrong", "n", "Right", "this", "relative", "column", "state", "rem", "ro", "no", "nt", "role", "LE", "lr", "open", "limit", "lower", "d", "le", "lo", "max", "rest", "data", "value", "tree", "file", "size", "empty", "ind", "url", "long", "condition", "LP", "width", "ft", "text", "ont", "local", "set", "RL", "insert", "control", "inner", "rel", "field", "localhost", "L", "x", "old", "level", "row", "end", "cm", "all", "shift"], "s": ["cs", "sm", "sv", "ans", "sts", "w", "sp", "t", "m", "g", "n", "only", "single", "c", "its", "z", "status", "e", "ns", "rs", "re", "sq", "ss", "r", "ls", "gs", "b", "ps", "ats", "o", "es", "scl", "se", "start", "S", "ts", "str", "ing", "er", "sb", "south", "strings", "p", "d", "a", "ins", "just"], "i": ["ki", "ti", "iy", "ini", "ic", "cli", "pi", "li", "xi", "it", "ix", "iri", "il", "init", "ior", "ili", "iu", "ij", "ir", "ai", "ri", "I", "si", "fi", "ati", "x", "ia", "ib", "di", "gi", "ip", "ii", "ci", "iti", "io", "ei", "oi"], "cols": ["Colts", "colords", "COLds", " colS", "columnts", "ColS", "Colords", "Colers", "columnds", "colS", "columnS", " colers", "COLts", "colers", "colds", "colts", "COLs", "COLers", "Colds", "columns", "COLords", "Cols", "COLS", " colords"]}}
{"code": "\"\"\"\\n  Google Code Jam 2014 Qualification Problem B\\n  Usage:\\n      python b.py < input.txt > output.txt\\n  \"\"\"\\n  \\n  \\n  def solve_problem(farm_cost, farm_rate, target):\\n      rate = 2.0\\n      farms = 0.0\\n  \\n      while (farms + target / rate) > (farms + farm_cost / rate + target / (rate + farm_rate)):\\n          farms = farms + farm_cost / rate\\n          rate = rate + farm_rate\\n  \\n      return farms + target / rate\\n  \\n  \\n  if __name__ == \"__main__\":\\n      num_of_cases = int(sys.stdin.readline().strip())\\n      for i in xrange(1, num_of_cases + 1):\\n          farm_cost, farm_rate, target = map(float, sys.stdin.readline().strip().split())\\n          print \"Case #{0}: {1:9.7f}\".format(i, solve_problem(farm_cost, farm_rate, target))\\n", "target": "48", "substitutes": {"farm_cost": ["farm_coin", "fleet_cost", " farm_resource", " farm_target", "farm_charge", " farm_window", "farmaccharge", "farm_length", "farmaccost", "farm_doc", "farmlyresource", "fleet_coin", "farmnetlength", "farm_window", "farmnetdoc", "farm_gross", " farm_risk", "farmnetcost", "farm_resource", "farmlycost", "farmlywindow", "farmacgross", " farm_doc", "farmaccoin", "farmlytarget", "farm_target", "farmlyrate", "fleet_gross", " farm_length", "farm_risk", "fleet_charge"], "farm_rate": [" farm_rates", "farm_range", "farm_rat", "lead_range", "fleet_race", "farm_rates", "farm_scale", "lead_rat", "fleet_rage", "lead_rate", " farm_scale", "lead_rates", "farm_rage", " farm_rule", "fleet_rule", "farm_rule", "fleet_rate", " farm_range", " farm_rat", "farm_race"], "target": ["range", "length", "json", "right", "result", "match", "value", "sys", "eth", "rt", "to", "ta", "goal", "size", "tor", "address", "hot", "port", "prime", "t", "that", "new", "base", "location", "resource", "total", "grade", "memory", "test", "arget", "window", "name", "buffer", "user", "set", "root", "unit", "table", "gt", "state", "time", "policy", "home", "path", "term", "template", "back", "ter", "rel", "ptr", "format", "source", "ret", "chain", "output", "Target", "top", "arg", "secondary", "trap", "bolt", "replace", "hop", "peer", "trace", "jump", "scale", "next", "type", "node", "transform", "stop", "inter"], "rate": ["range", "length", "value", "power", "rates", "seed", "ate", "rice", "core", "domain", "dr", "trade", "timeout", "frequency", "address", "ta", "goal", "rating", "prime", "date", "pair", "size", "fee", "base", "rat", "test", "rand", "capacity", " Rate", "factor", "e", "root", "rank", "unit", "re", "rer", "r", "arm", "ride", "time", "change", "zero", "rule", "term", "rator", "report", "currency", "ry", "wire", "device", "force", "process", "erate", "Rate", "grow", "te", "race", "code", "error", "speed", "trace", "mean", "delay", "scale", "me", "average", "type", "price", "rage", " rat", "score"], "farms": [" fires", "farm", "frarms", "formares", "forts", "garts", " fees", "flarm", "piers", "flances", "Fiers", "forarm", "flays", " fays", "frarm", " fonents", "parm", "Farms", "foreatures", "gays", " fats", "flonents", "foarm", "flarms", " farts", "fays", " farm", "gats", "forarms", "Farts", "fares", "formarms", "fires", "foarms", "Farm", "Features", "gares", "gires", "fances", " fares", " forts", "forarts", "pires", "parms", "Fances", "fiers", "formorts", "gorts", "fees", "fonents", "features", "frarts", "fliers", "garm", "foonents", "freatures", "gees", "garms", "flees", "formarts", "pances", "fleatures", "fats", "pats", "foeatures", " features", "farts"], "num_of_cases": ["num_of_case", "num_of28lines", "num_of28cases", "num_Of_cases", "num_of28case", "num_of_cycles", "num_of_lines", "num_of_tests", "num_of28cycles", "num_Of_cycles", "num_Of_case", "num_Of_lines"], "i": ["s", "ti", "ini", "y", "u", "ind", "pi", "f", "li", "t", "m", "xi", "n", "it", "key", "index", "ix", "c", "bi", "e", "k", "id", "ij", "q", "r", "b", "I", "j", "mi", "v", " j", "x", "di", "gi", "num", "ci", "p", "d"]}}
{"code": "\"\"\"\\n  Google Code Jam 2014 Qualification Problem C\\n  Usage:\\n      python c.py < input.txt > output.txt\\n  \"\"\"\\n  \\n  \\n  def iter_neighbors(x, y, cells):\\n      columns = len(cells[0])\\n      rows = len(cells)\\n  \\n      if y > 0:\\n          if x > 0:\\n              yield x - 1, y - 1\\n          yield x, y - 1\\n  \\n          if x + 1 < columns:\\n              yield x + 1, y - 1\\n  \\n      if x > 0:\\n          yield x - 1, y\\n  \\n      if x + 1 < columns:\\n          yield x + 1, y\\n  \\n      if y + 1 < rows:\\n          if x > 0:\\n              yield x - 1, y + 1\\n  \\n          yield x, y + 1\\n  \\n          if x + 1 < columns:\\n              yield x + 1, y + 1\\n  \\n  \\n  def try_to_click(x, y, cells, remaining):\\n      if remaining == 0:\\n          return cells\\n  \\n      recent = []\\n  \\n      opened = 0\\n  \\n      for n_x, n_y in iter_neighbors(x, y, cells):\\n          if cells[n_y][n_x] == \"?\":\\n              cells[n_y][n_x] = \".\"\\n              opened += 1\\n              recent.append((n_x, n_y))\\n  \\n      if opened == remaining:\\n          return cells\\n  \\n      if opened > remaining:\\n          return []\\n  \\n      for n_x, n_y in recent:\\n          solution = try_to_click(n_x, n_y, copy.deepcopy(cells), remaining - opened)\\n          if solution:\\n              return solution\\n  \\n      return []\\n  \\n  \\n  def solve_problem(rows, columns, mines):\\n  \\n      for x in xrange(columns):\\n          for y in xrange(rows):\\n              cells = [[\"?\" for i in xrange(columns)] for j in xrange(rows)]\\n              cells[y][x] = \"c\"\\n              solution = try_to_click(x, y, cells, rows * columns - mines - 1)\\n  \\n              if solution:\\n                  return \"\\n\".join([\"\".join(row) for row in solution]).replace(\"?\", \"*\")\\n  \\n      return \"Impossible\"\\n  \\n  \\n  if __name__ == \"__main__\":\\n      num_of_cases = int(sys.stdin.readline().strip())\\n      for i in xrange(1, num_of_cases + 1):\\n  \\n          rows, columns, mines = map(int, sys.stdin.readline().strip().split())\\n  \\n          print \"Case #{0}:\\n{1}\".format(i, solve_problem(rows, columns, mines))\\n", "target": "48", "substitutes": {"x": ["s", "mx", "ay", "ax", "u", "t", "g", "yx", "l", "lat", "c", "full", "k", "zx", "ce", "wx", "v", "cy", "right", "ctx", "ct", "a", "tx", "rx", "int", "to", "ty", "w", "xt", "xml", "step", "index", "z", "e", "r", "el", "left", "min", "xx", "nex", "p", "ace", "ord", "h", "name", "xc", "yl", "est", "xs", "search", "on", "xe", "at", "m", "al", "f", "xi", "n", "xa", "fx", "lex", "xy", "id", "hex", "time", "o", "ware", "point", "xf", "back", "act", "ice", "ex", "inx", "any", "d", "le", "max", "file", "rame", "xd", "xp", "width", "ix", "key", "text", "xes", "px", "X", "line", "dx", "xxxx", "ox", "code", "ux", "content", "item"], "y": ["ay", "iy", "ys", "t", "Y", "g", "yx", "cell", "c", "ony", "ies", "yy", "ied", "_", "ny", "ye", "b", "uy", "yr", "v", "cy", "yi", "hy", "type", "dy", "ty", "ery", "ya", "hot", "w", "oy", "z", "e", "wy", "axy", "vy", "an", "south", "icy", "p", "h", "yl", "gy", "ly", "on", "f", "m", "n", "ier", "yt", "py", "xy", "o", "by", "ry", "fill", "any", "col", "d", "my", "yu", "ch", "yes", "sky", "key", "yn", "poly", "ey", "year", "story", "sy", "yer", "ym"], "cells": ["s", "sections", "bes", "gets", "cell", "js", "lines", "ies", "keys", "grid", "phones", "files", "rooms", "versions", "facts", "less", "ods", "rings", "objects", "els", "vals", "codes", "reports", "flows", "boxes", "ones", "ions", "olds", "actions", "plays", "ows", "ries", "details", "jobs", "types", "windows", "classes", "devices", "results", "parts", "units", "ports", "bits", "cod", "terms", "holes", "images", "args", "sheets", "hips", "points", "blocks", "names", "faces", "xs", "comments", "products", "letters", "ells", "acts", "items", "eds", "ns", "Cell", "tones", "ices", "games", "ses", "charges", "odes", "bs", "sels", "scroll", "they", "frames", "___", "strings", "seconds", " Cells", "iques", "values", "cs", "buff", "headers", "csv", "cats", "cases", "cers", "ctors", "ews", "papers", "states", "obj", "cache", "fields", "tests", "workers", "locks", "content"], "columns": ["lengthS", "colments", "chronifiers", "chronnames", "colations", "platformensions", "chrones", "subjects", "columnt", "columnments", "columnensions", "Columngroups", "columniffs", "alignes", "Columnds", "colities", "alignments", "ifities", "colgroups", "subjectensions", "lengthes", "Columns", "columnes", "colt", "ifations", "columnds", "colS", "platformgroups", "columnations", "columnities", "coles", "Columniffs", "columnways", "Columnifiers", "colways", "subjectes", "chronways", "ColumnS", "chrons", " Columns", "lengtht", "ifensions", "Columnt", "columngroups", "columnS", "lengths", "colds", "alignensions", "Columnensions", "minimumds", "Columnations", "platforms", "minimumS", "Columnways", "Columnnames", "subjectiffs", "columnifiers", "chronensions", " Columnensions", " Columnities", "Columnes", "colnames", "coliffs", "minimums", "ififiers", "ifs", "colifiers", "Columnments", "platformS", "cols", "columnnames", "colensions", "minimumensions", "aligns"], "rows": ["ids", "cs", "olds", "many", "relations", "blocks", "times", "ows", "modules", "docs", "names", "headers", "sections", "xs", "mins", "cases", "jobs", "ros", "types", "views", "ris", "errors", "runs", "lines", "items", "keys", "classes", "rs", "months", "obs", "files", "rooms", "groups", "flows", "states", "posts", "results", "bs", "heads", "dates", "orders", "images", "ports", "users", "frames", "uds", "fields", "tests", "workers", "boxes", "rown", "years", "ios", "issues", "builders", "pages", "ins", "reads", "reports", "values"], "remaining": [" remain", "promgoing", "promaining", "Remains", "resain", "resaining", " remgoing", "promain", "remain", "reshained", "promained", "reshain", "remained", "resgoing", "reshains", "Remain", " remained", "resains", "reshaining", "Remaining", "remgoing", " remains", "resained", "remains", "Remained", "Remgoing"], "recent": ["release", "safe", "many", "expected", "recorded", "fresh", "later", "complete", "reported", "new", "days", "created", "history", "connected", "current", "finals", "remote", "windows", "window", "seen", "region", "released", "related", "rent", "held", "relative", "registered", "restricted", "sequent", "example", "past", " Recent", "Recent", "modified", "similar", "dom", "used", "sofar", "reg", "common", "good", "random", "given", "confirmed", "command", "latest", "desc", "final", "same", "record", "closed"], "opened": ["stated", "turned", "locked", "worked", "ed", "initialized", "created", "opens", "successfully", "connected", "ordered", "occupied", "linked", "focused", "balanced", "issued", "released", "held", "registered", "exclusive", "earned", "opening", "induced", "played", "shown", "joined", "made", "checked", "tested", "stretched", "powered", "used", "enabled", "loaded", "confirmed", "pressed", "started", "charged", "open", "activated", "approved", "closed", "established", "ened", "raised", "represented"], "n_x": ["n_fx", "nxy", "nXx", "nThex", "n___ex", "nXy", "nThesex", "nXxc", "ln_fx", "n_sex", "noxxc", "n___e", "nXxf", "N_ex", "n_xt", "on_xx", "n___x", "noxxf", "noxy", " n_xc", "nxx", "ln_y", " n_xf", "n___y", "n_xf", "n_ex", "nxw", "on_y", "on_w", " n_xt", "N_x", "ln_x", "nThexc", "n_xc", "nThey", "n_key", " n_sex", "n_w", "n_xi", " n_xi", "ln_key", "n_xx", "nxxx", "on_x", "N_e", "noxx", "n_e", "N_y"], "n_y": ["current_yr", "nThevy", "n7yr", "n_ny", "n2x", "n_ry", "nTheym", "current_y", "n_ym", "n___ry", "n___ny", "current_x", " n_yt", "n7yt", " n2yer", "n_yer", "n7y", "np_y", "n_yy", "n2y", " n_Y", "n2yy", " n_yer", "n___y", " n2y", "n7Y", "dn_ys", "np_ry", " n2Y", "n___Y", "n___ys", "n_ys", "n2ies", "n7vy", "n7x", "np_ym", "dn_y", "n_yl", "n2yer", "n2Y", " n_yy", " n_vy", "nThey", "dn_Y", "n___vy", "dn___Y", "n_ies", "n_vy", "dn___ny", "n2yl", "np_vy", "n_yt", "current_vy", "n___ym", " n_yl", "dn___y", "n_Y", "nThery", "dn_ny", "n_yr", "dn___ys", " n_ies", " n2ies"], "solution": ["sigration", " solver", "jsolve", " solve", "convolved", "gsansion", "convolutions", "ssolver", " sigration", "solve", "gsigration", "ssolved", "ssolutions", "solved", "solver", " sansion", "Solved", " solving", "jsresolution", "Solutions", "sansion", "ssansion", " solutions", "resresolution", "ssolving", "resolving", "solutions", "gsolve", "ssigration", " solved", "resolved", "convolution", "jsolution", "resolve", "sresolution", "Solve", "Sresolution", "gsolution", "gsresolution", "Solution", "resolutions", "gsolved", "convolve", "jsolved", "resolution", "solving", "Solving", "ssolution"], "mines": ["sines", "Minions", "Minces", "minsees", "serveds", "minseds", "sinions", "mineds", "minions", "minees", "minues", "sineds", "servions", "minces", "sinees", "tences", "minsces", " minES", "servees", "tenES", " minces", " minions", "tenes", "minsES", "minsues", "minES", "minses", "tenions", "Mines", " minues", "minsions", "Minues", "serves"], "i": ["ti", "iy", "ini", "ic", "pi", "li", "ie", "xi", "it", "ix", "il", "zi", "hi", "ij", "ir", "ai", "im", "ri", "si", "mi", "v", "ia", "di", "ik", "gi", "yi", "ice", "ii", "ip", "ci", "io"], "j": ["jl", "ja", "ju", "jj", "jas", "ie", "kj", "aj", "z", " ii", "py", " iii", "dj", "k", "e", "ij", "jc", "jac", "ai", "o", " vi", "ia", "je", "di", "uj", " dj", "ji", "oj"], "row": ["ob", " Row", "ows", "rowd", "pair", "tr", "word", "case", "cell", "key", "test", "OW", "runner", "user", "r", "entry", "ro", "Row", "arrow", "ri", "mod", "rc", "raw", "line", "ry", "rep", "bug", "rown", "ow", "node", "roll", "error", " r", "col", "run", "val", "item", "post", "instance", "record", "rx"], "num_of_cases": ["num_of_case", "num_ofxcase", "num_Of_cases", "num_ofxtests", "num_Of_classes", "num_of__case", "num_Of_tests", "num_ofxcases", "num_of_tests", "num_ofxclasses", "num_of_cells", "num_of_classes", "num_Of_case", "num_of__cases", "num_of__tests", "num_of__cells"]}}
{"code": "\\n  \\n  data Test = Test {\\n        cout     :: Double\\n      , bonus    :: Double\\n      , objectif :: Double\\n      } deriving Show\\n  \\n  newtype Solution = Solution { temps :: Double }\\n  \\n  instance Show Solution where\\n      show (Solution t) = show t\\n  \\n  main = do\\n      interact (unlines . map showCase . zip [1..] . map resoudre . goTest . tail . lines)\\n  \\n    where\\n      goTest [] = []\\n      goTest (l:ls) =\\n          let [c, f, x] = map read $ words l\\n          in Test c f x : goTest ls\\n  \\n      showCase :: (Int, Solution) -> String\\n      showCase (i, s) = printf \"Case #%d: %s\" i (show s)\\n  \\n  resoudre :: Test -> Solution\\n  resoudre Test {..} | premierAchat > sansAchat = Solution sansAchat\\n                     | otherwise                = go premierAchat 2\\n    where\\n      go t prod | tempsAvecAchat >= tempsSansAchat = Solution (t + tempsSansAchat)\\n                | otherwise                        =\\n                    go (t + delaiProchainAchat) prod'\\n        where\\n          prod' = prod + bonus\\n  \\n          tempsAvecAchat = objectif / prod'\\n          tempsSansAchat = (objectif - cout) / prod\\n  \\n          delaiProchainAchat = cout / prod'\\n  \\n      premierAchat = cout / 2\\n      sansAchat    = objectif / 2\\n", "target": "49", "substitutes": {"Test": ["Id", "Tx", "Box", "Feature", "Result", "Root", "Time", "Default", "Fixed", "ests", "Testing", "Port", "Bed", "Server", "Function", "Sub", "Edit", "Use", "Value", "Student", "Proof", "Live", "Score", "Code", "test", "Sim", "File", "Dev", " test", "Service", "Type", "Load", "Main", "Empty", "Rest", "Null", "Start", "Temp", "Var", "Reader", "T", "Data", "Script", "Ser", "Full", "Task", "Table", "Check", "Runner", "Sample", "Parent", "Set", "Show", "Single", " tests", "F", "Config", "Target", "Example", "It", "Builder", "All", "New", "Path", "Step", "Model", "Write", "Train", "Site", "Node", "If", "Case"], "Solution": ["V", "Group", "Sol", "Fixed", "Server", "Proof", "Status", " solutions", "Results", "Option", "Reader", "Data", "Problem", "Simple", "List", "Error", "Goal", "If", "Title", "Only", "Solid", "Salt", "Time", "Software", " solution", "Tile", " Solutions", "File", "Section", "Map", "Array", "Various", "Ser", "Move", "Table", "S", "Union", "Single", "No", "My", "Game", "Small", "Node", "Answer", "ID", "Result", "SO", "Product", "Value", " Sample", "Tool", "Point", "Type", "Split", "Position", "Row", "Copy", "Tree", "VE", "Si", "Space", "Source", "Or", "Song", "Search", "Population", "New", "Site", "String", "Range", "O", "Score", "Sat", "Sim", "Query", "T", "Exception", "Spe", "Sample", "Version", "Set", "Response", "Integer", "DO", "Management", "Matrix", "Delta", "All", "Model"], "main": ["data", "lay", "days", "blank", "long", "done", "total", "index", "sub", "name", " test", "db", "body", "id", "begin", "Main", "left", "start", " start", "join", " Main", "all", "exit", "alt"], "goTest": ["GOTest", "otest", "GOScript", "GoSample", "loT", "GoTesting", "goSample", " goVer", "GoSet", "GOSample", "motest", "GoVer", "GOTesting", "GoCheck", "oTest", "goT", "GoTest", "goCheck", "moTest", " goSet", "goSet", " goT", "oCheck", "gotest", "oSample", "goRoot", "goTesting", "poSample", "poScript", " goScript", "lotest", "GORoot", " gotest", "loTest", "GoT", "goScript", "GOSet", "Gotest", " goTesting", "moSample", " goSample", "moCheck", " goRoot", "poRoot", "poTest", "goVer", "GOVer"], "let": ["lets", "ld", "gen", "tree", "lay", "g", "long", "l", "Cop", "local", "ve", "gt", "Let", "var", "LET", "line", "lang", "L", "lett", "Line", "print", "list", "ln", "sol", "link", "lt", "Lay", "le", "lit"], "c": ["cs", "s", "cp", "uc", "y", "ic", "cf", "w", "t", "g", "m", " C", "case", "n", "l", "C", "gc", "z", "ac", "con", "ec", "e", "mc", "r", "lc", "co", "b", "fc", "o", "unc", "rc", "sc", "chain", "v", "ca", "cm", "ci", "p", "d", "h", "tc", "i", "cc"], "f": ["af", "u", "cf", "w", "g", "m", "n", "l", "sf", "ft", "fx", "fs", "bf", "z", "fe", "fb", "e", "fer", "ve", "fl", "tf", "b", "fc", "o", "fg", "xf", "uf", "j", "rf", "fi", "ff", "v", "F", "fd", "fr", "df", "p", "fp", "h", "i", "lf"], "x": ["s", "Tx", "ax", "y", "u", "w", "xs", "xt", "t", "xe", "g", "m", "xi", "xp", "n", "l", "z", "e", "k", "xy", "xb", "q", "r", "co", "b", "o", "xf", "X", "xx", "v", "ox", "xc", "ex", "inx", "p", "h", "yl", "i", "rx"], "otherwise": ["OTHERwise", "Otherwise", "elsewith", "OTHERwhen", "Otherwhen", "elsewise", " otherwith", "otherwith", "Otherthen", "OTHERwith", "Otherwith", "otherthen", "elsethen", "OTHERthen", " otherwhen", "otherwhen"], "tempsAvecAchat": ["tempsAvecApic", "tempsAvecCAshop", "tempsAvecAschat", "tempsAvecAxpic", "tempsAcosAchat", "tempsAvecCAChat", "tempsAcosAshop", "tempsAverAsc", "tempsAvecAxChat", "tempsAvecNAchat", "tempsAverAChat", "tempsAvecAssc", "tempsAvecAsc", "tempsAcosAchan", "tempsAverApic", "tempsAvecAxsc", "tempsAvecAsChat", "tempsAcosAChat", "tempsAvecAchan", "tempsAvecAspic", "tempsAvecAshop", "tempsAvecCAchan", "tempsAvecNAshop", "tempsAvecAxchat", "tempsAvecAChat", "tempsAvecNAChat", "tempsAvecCAchat", "tempsAverAchat", "tempsAvecNAchan"], "delaiProchainAchat": ["delaiProchainBchat", "delaiProchainBChat", "delaiProchainsApic", "delaiProchainsAChat", "delaiProchainAbutt", "delaiProchainBbutt", "delaiProchainAAchat", "delaiProchainAspi", "delaiProchainAschat", "delaiProchainApic", "delaiProchainAsChat", "delaiProchainsApi", "delaiProchainAAbutt", "delaiProchainsAbutt", "delaiProchainBpic", "delaiProchainsAchat", "delaiProchainAChat", "delaiProchainAApi", "delaiProchainApi", "delaiProchainAspic", "delaiProchainAsbutt", "delaiProchainAAChat"], "sansAchat": ["sensAiac", "sansAChat", "sansEchange", "sannAbutt", "sansachat", "sansWachat", "sannAChat", "sansEchat", "sansHAchat", "sansBbutt", "sansaiac", "sanAchange", "sansapc", "sansabutt", "sansAch", "sanAChat", "sansAiac", "sansBChat", "sansHApc", "sansaChat", "sansAbutt", "sannAchat", "sansApc", "sanAchat", "sansApic", "sansBchat", "sensAChat", "sansWaChat", "sansAchange", "sansHAiac", "sansHAChat", "sanAch", "sensAchat", "sansBpic", "sensApc", "sansEChat", "sansWach", "sansapic", "sansWachange", "sansEch", "sannApic"]}}
{"code": "t = int(input())\\n  \\n  VIDE = 0\\n  MINE = 1\\n  CURSEUR = 2\\n  \\n  def test_position(arr, lignes, cols, y, x):\\n      def voisinage_libre(arr, y, x):\\n          if y > 0:\\n              if x > 0 and arr[y-1][x-1] == MINE:\\n                  return False\\n              if arr[y-1][x] == MINE:\\n                  return False\\n              if x < cols - 1 and arr[y-1][x+1] == MINE:\\n                  return False\\n  \\n          if x > 0 and arr[y][x-1] == MINE:\\n              return False\\n          if x < cols - 1 and arr[y][x+1] == MINE:\\n              return False\\n  \\n          if y < lignes - 1:\\n              if x > 0 and arr[y+1][x-1] == MINE:\\n                  return False\\n              if arr[y+1][x] == MINE:\\n                  return False\\n              if x < cols - 1 and arr[y+1][x+1] == MINE:\\n                  return False\\n  \\n          return True\\n  \\n      def remplissage_rec(arr, y, x):\\n          if x < 0 or y < 0 or x >= cols or y >= lignes:\\n              return\\n          elif arr[y][x] == CURSEUR:\\n              return\\n  \\n          arr[y][x] = CURSEUR\\n          if voisinage_libre(arr, y, x):\\n              remplissage_rec(arr, y-1, x-1)\\n              remplissage_rec(arr, y-1, x)\\n              remplissage_rec(arr, y-1, x+1)\\n              remplissage_rec(arr, y, x-1)\\n              remplissage_rec(arr, y, x+1)\\n              remplissage_rec(arr, y+1, x-1)\\n              remplissage_rec(arr, y+1, x)\\n              remplissage_rec(arr, y+1, x+1)\\n  \\n      if arr[y][x] != VIDE:\\n          return False\\n  \\n      arr2 = [ [ arr[i][j] for j in range(0, cols) ] for i in range(0, lignes) ]\\n  \\n      remplissage_rec(arr2, y, x)\\n  \\n      for i in range(0, lignes):\\n          for j in range(0, cols):\\n              if arr2[i][j] == VIDE:\\n                  return False\\n      return True\\n  \\n  def dfs(arr, lignes, cols, mines, y, x):\\n      cases_restantes = (cols - x) + ((lignes - y) * cols)\\n  \\n      if cases_restantes < mines:\\n          return None\\n      elif mines <= 0:\\n          for i in range(0, lignes):\\n              for j in range(0, cols):\\n                  if test_position(arr, lignes, cols, i, j):\\n                      return (i, j)\\n      elif x >= cols:\\n          return dfs(arr, lignes, cols, mines, y+1, 0)\\n      elif y >= lignes:\\n          return None\\n      else:\\n          res = dfs(arr, lignes, cols, mines, y, x+1)\\n          if res != None:\\n              return res\\n  \\n          arr[y][x] = MINE\\n          res = dfs(arr, lignes, cols, mines-1, y, x+1)\\n          if res != None:\\n              return res\\n  \\n          arr[y][x] = VIDE\\n          return None\\n  \\n  for i in range(0, t):\\n      ligne  = input().split(\" \")\\n      lignes = int(ligne[0])\\n      cols   = int(ligne[1])\\n      mines  = int(ligne[2])\\n  \\n      arr = [ [VIDE] * cols for _ in range(0, lignes) ]\\n  \\n      res = dfs(arr, lignes, cols, mines, 0, 0)\\n  \\n      print (\"Case #\"+str(i+1)+\":\")\\n  \\n      if res == None:\\n          print (\"Impossible\")\\n      else:\\n          (y, x) = res\\n  \\n          for i in range(0, lignes):\\n              for j in range(0, cols):\\n                  if i == y and j == x:\\n                      print('c', end='')\\n                  elif arr[i][j] == VIDE:\\n                      print('.', end='')\\n                  else:\\n                      print('*', end='')\\n  \\n              print('', end='\\n')\\n", "target": "49", "substitutes": {"t": ["s", "ta", "w", "f", "g", "m", "n", "l", "total", "c", "z", "tp", "e", "q", "r", "time", "tt", "b", "T", "o", "v", "ts", "dt", "p", "d", "a", "h"], "VIDE": ["VISe", "VISEE", " VIDe", "VERSEE", "VERSE", "VIDEE", "VDE", " VIDIE", "VIDIE", "VIDe", "VISE", "VDEE", "VERSEA", "VERSe", "VDe", "VISIE", " VIDEA", "VIDEA", "VDIE", "VISEA", "VERSIE"], "MINE": ["FIME", "WMINE", "IMIDE", "FFINE", " MIME", "FALE", "DMINE", "MANINE", "IMINK", "Finite", "WMines", "MIDE", " MIM", "MINK", "Cinite", "MITE", "SMines", " Mine", " Mines", "IMINE", "MALE", "Ginite", "WMITE", "MCINE", "HINE", " MID", "MANFINE", "MID", "CIM", "IMine", "IMIM", "MIME", "DMIM", " MIDE", "Mine", "IMinite", "VINE", "FID", "MCine", "Hinite", "MIine", "MIINE", " MINK", "CINE", "WMine", "FINE", "GALE", "MANinite", "MANine", " Minite", "MCinite", "Minite", "MIM", " MALE", " MITE", "FIM", "HFINE", "MFINE", "MIIDE", "Hine", "Fine", "Vine", "MCIM", "Gine", "Cine", "VID", "VIME", "MANIM", "FIDE", "SMine", "GINE", "SMINE", "DMine", "SMITE", "DMIDE", " MFINE", "MIINK", "Mines"], "CURSEUR": ["CURseur", "CURSEURL", "CADGEUR", "CADSEUD", "CURSEOR", "COUSEur", "CURTEur", "COUGEur", "CURGEURR", "CURTEUR", "CURGEur", "CURTHur", "CURCLEURR", "CURGEUD", "COUSEUR", "CURSEur", "COUGEOR", "COUseur", "CURseUD", "CURCLEUR", "CURseURE", "COUGEURR", "COUSEOR", "CURTHURE", "CURSEUD", "CURSEURR", "CURTHUR", "CURCLEURL", "CURCLEUD", "CURGEURE", "CURGEURL", "CURTEOR", "COUGEUR", "CADSEUR", "CURGEOR", "CURseURR", "CADSEURL", "CADSEURR", "CURGEUR", "CURSEURE", "CURseUR", "COUSEURE", "CADGEURL", "CADGEURR", "COUseURR", "CURTEURR", "COUseUR", "COUseURE", "CURTHURR", "CURseURL", "CADGEUD", "COUSEURR", "CURseOR"], "arr": ["conf", "ay", "ray", "ax", "att", "ag", "req", "it", "cell", "attr", "cl", "addr", "ab", "adj", "proc", "resp", "batch", "ar", "hist", "alg", "arb", "deg", "gz", "ait", "bar", "int", "dr", "emb", "art", "agg", "window", "z", "arch", "db", "comm", "r", "Array", "dict", "mg", "usr", "args", "out", "list", "p", "array", "err", "ll", "func", "ell", "aaa", "rr", "warn", "days", "at", "buf", "rad", "plot", "rand", "inst", "py", "map", "vol", "nt", "raw", "arg", "urg", "pl", "fr", "irm", "rest", "data", "expr", "kl", "compl", "gr", "np", "work", "aug", "par", "ix", "mat", "aa", "app", "ij", "arm", "var", "br", "adv", "block", "msg", "obj", "ck", "rel", "elt", "bl", "good", "ack", "str", "row", "img", "val", "au", "all", "enc", "dat"], "lignes": ["lgnses", "llignES", "lignies", "linnists", "lgnets", "longets", "Lgnions", "llignists", "llignes", "lsoadses", "Lignates", "linsES", "loades", "linsions", "linsets", "lignists", "lligists", "Lignions", "lignions", "Lignets", "Lgns", "linses", "linsists", "lignES", "lligets", "loadies", "linnes", "lsoads", "lignmentES", "lignmentes", "lignments", "lignates", "ligES", "longes", "longions", "lsoadies", "linnates", "lsignes", "ligns", "llignets", "lignses", "lsoades", "lgnes", "lignmentses", "lsignies", "lignets", "Lgnets", "lliges", "lligES", "loads", "loadses", "lgnates", "lgnies", "longs", "lsignses", "lgnES", "lignmentates", "linnets", "linnES", "lignmenties", "LgnES", "Lignes", "lgnions", "LignES", "Ligns", "lgns", "liges", "Lgnates", "ligists", "linss", "lsigns", "ligets", "Lgnes", "linns"], "cols": ["Colts", "columnats", "COLes", "llss", "Coles", "Colps", "columnns", "columnts", " coles", "colps", "columnes", "colns", "igns", " colts", "colats", "colxs", " colns", "lls", " colats", " colgs", " colsd", "ylats", "colsb", "COLxs", "ctsd", "ctsb", "colsd", "ignts", " colsb", " colss", "colds", "coles", "colts", "colgs", "ctss", " colds", "ignns", "ylds", "columnps", "columnxs", "COLats", "columngs", "yles", "COLs", "COLgs", "Colats", "yls", "Colds", " colps", "llsd", " colxs", "llsb", "colss", "columns", "cts", "Cols", "ignxs"], "y": ["ay", "iy", "ys", "Y", "g", "yx", "c", "ies", "yy", "ny", "table", "ye", "b", "uy", "yk", "yr", "v", "cy", "yi", "hy", "ty", "ery", "ya", "w", "yz", "oy", "zy", "yd", "index", "z", "wy", "axy", "ky", "vy", "out", "icy", "p", "yl", "gy", "ly", "m", "n", "yt", "py", "xy", "kit", "o", "by", "ry", "ia", "any", "col", "ot", "my", "sys", "hey", "yu", "yes", "sky", "key", "yn", "ey", "year", "ox", "sy", "er", "fy", "yer", "ym", "yo"], "x": ["mx", "ax", "g", "yx", "only", "l", "lat", "ext", "c", "k", "check", "q", "path", "hello", "true", "wx", "v", "net", "fixed", "right", "ct", "tx", "rx", "xxx", "w", "xt", "history", "xml", "step", "index", "z", "color", "e", "exclusive", "el", "left", "xx", "out", "p", "exp", "h", "name", "xc", "xs", "on", "xe", "f", "m", "xi", "n", "xa", "fx", "lex", "status", "xy", "id", "time", "o", "no", "xf", "fill", "ice", "ex", "inx", "any", "d", "max", "data", "ic", "pe", "yes", "xp", "width", "ix", "key", "yn", "mm", "xes", "px", "ey", "X", "dx", "xxxx", "ox", "ux", "content"], "arr2": ["array8", "arbelse", "err1", "arr1", " arrTrue", " arrelse", "array3", "err2", "arrif", "err4", "arrayelse", "arbif", " arr1", " arr8", "arbTrue", "err3", " arr3", "array1", " arrif", "arb8", " arr4", "array2", "arrelse", "arrayif", "arr4", "arr8", "arrayTrue", "arr3", "arrTrue", "array4"], "i": ["s", "ti", "int", "ini", "u", "ic", "ind", "pi", "on", "m", "li", "ie", "xi", "n", "it", "l", "ix", "c", "il", "z", "bi", "e", "zi", "id", "ij", "ir", "ai", "im", "o", "I", "si", "mi", "v", "di", "ii", "ci", "p", "io", "h"], "j": ["jl", "ja", "J", "jj", "ch", "u", "g", "li", "m", "ie", "n", "it", "kj", "l", "ix", "key", "c", "z", "bi", "js", "jp", "xy", "k", "dj", "ij", "jc", "b", "o", "si", "v", "di", "uj", "col", "ijk", "p", "ji", "ci", "job", "h"]}}
{"code": "\\n  f = open(sys.argv[1])\\n  T = int(f.readline())\\n  for test in range(T):\\n      data = f.readline().split()\\n      C = Decimal(data[0])\\n      F = Decimal(data[1])\\n      X = Decimal(data[2])\\n      curr_rate = Decimal(2)\\n      best_time = Decimal(10**100)\\n      curr_time = Decimal(0)\\n      while curr_time < best_time:\\n          poss_finish_time = curr_time + X / curr_rate\\n          if poss_finish_time < best_time:\\n              best_time = poss_finish_time\\n  \\n          curr_time += C / curr_rate\\n          curr_rate += F\\n  \\n      print \"Case #%d: %.7f\" % (test + 1, best_time)\\n", "target": "50", "substitutes": {"f": ["fed", "inf", "af", "file", "t", "l", "ft", "sf", "c", "fs", "bf", "ac", "h", "fb", "e", "tf", "elf", "b", "fc", "fo", "o", "fg", "xf", "uf", "alf", "v", "fw", "x", "fd", "fr", "feed", "p", "d", "fp", "df", "fm", "i", "lf"], "T": ["V", "GT", "Test", "G", "P", "J", "TN", "t", "Y", "N", "M", "B", "TA", "D", "TT", "TY", "H", "K", "I", "R", "TS", "S", "NT", "L", "TH", "TR", "Q", "TM", "VT", "Z", "TC"], "test": ["Test", "int", "tag", "est", "seed", " testing", "port", "feature", "case", "dev", "train", "ite", "set", "unit", "iter", " suite", "time", "instance", "ter", "tested", "ver", "sel", " trial", "v", " tested", " TEST", " Test", "show", "trial", "tests", " sample", "num", "EST", "sim", " val", "val", "tc", "testing", "trip"], "data": ["json", "blocks", "ata", "size", "dec", "first", "new", "details", "dev", "des", "done", "step", "window", "pieces", "lines", "keys", "bus", "da", "rew", "bytes", "table", "hex", "zero", "block", "extra", "Data", "hash", "words", "rel", "raw", "info", "chain", "reader", "dates", "apps", "bits", "good", "str", "users", "join", "list", "DATA", "feed", "next", "row", "vals", "d", "val", "aw", "reports", "values", "dat"], "C": ["V", "CS", "G", "P", "CNN", "CC", "CO", "N", "M", "CL", "FC", "MC", "B", "c", "CM", "D", "CF", "YC", "CB", "Cs", "H", "K", "CE", "LC", "CT", "DC", "A", "CU", "I", "R", "E", "CP", "S", "BC", "L", "CON", "Cu", "Co"], "F": ["V", "G", "W", "P", "FU", "J", "GF", "FS", "FER", "Y", "AF", "BF", "N", "M", "FC", "O", "B", "D", "CF", "EF", "H", "K", "DF", "A", "I", "R", "E", "FO", "L", "U", "FM", "Q", "Z", "PF", "FE"], "X": ["V", "Tx", "W", "P", "Time", "TX", "XY", "Y", "XM", "N", "FC", "EX", "CF", "XL", "IX", "XX", "DX", "I", "R", "E", "L", "x", "UX", "XP", "XT", "OX", "MX", "Z", "ZX", "XXX", "FE"], "curr_rate": ["currt_time", "currt_rate", "currev_rat", "curerr_rate", "curcr_term", "curcr_rate", "curr2term", "currev_rates", "curr_rates", "curr_rat", "curerr_rates", "curr_range", "currt_Rate", "curr_Rate", "curr2rat", "currev_rate", "curr2rate", "curr2rates", "currt_sequence", "curcr_rat", "curerr_range", "curr_term", "currev_time", "curerr_Rate", "curcr_rates", "curr_sequence"], "best_time": ["better_name", "bestlyonly", " best_Time", "bestedspeed", "testlydate", "better_runtime", "best_only", "bestjspeed", "latest_tag", "test_time", "bestlingruntime", "latest_only", "bestptname", "best_tim", " best_speed", "testlyTime", "best64Time", "bestlingtag", "bestlydate", "bestingonly", "testlytimer", " best_start", "best_Time", "bestlingonly", "bestingtag", "bestpttime", "latestlytag", "bestjtim", "bestedtime", "best_start", "latestlyruntime", "best_rate", "best_date", " best_tim", "test_timer", " best_rate", "best_name", "testlytime", "test_Time", "bestedtim", "best64name", "test_date", "bestedrate", "bestingruntime", "latestlyonly", "bestlyTime", "bestlytime", "best_runtime", "best_speed", "bestlytimer", "bestingtime", "latestlytime", "bestjtime", "better_Time", "best64time", " best_name", "latest_time", "bestjrate", "bestptTime", "best_timer", "best_tag", "bestptstart", "bestlingtime", "better_time", "best64start", "latest_runtime", "bestlyruntime", "bestlytag"], "curr_time": ["curr_message", "curr_t", "currptmessage", "curc_version", "curor_rate", "curr1rate", "currptTime", "curor_time", "currvalTime", "curr_version", "curp_Time", "currtimemessage", "currtimeTime", "curor_count", "curr_count", "curry_history", "curr_history", "curc_time", "currvalrate", "curr_Time", "currtimeversion", "currptversion", "curp_value", "curor_Time", "curr1Time", "currpttime", "curp_time", "currtimetime", "curry_Time", "curc_message", "curr1value", "curry_time", "currvalcount", "currvaltime", "curr_value", "curr1time", "curc_Time", "curry_t", "curp_rate"], "poss_finish_time": ["poss_finish_times", "poss_finend_times", "poss_finish_length", "poss_finish_date", "poss_finish_t", "poss_finend_time", "poss_finish_rate", "poss_finISH_date", "poss_finISH_rate", "poss_finISH_time", "poss_finend_t", "poss_finISH_length", "poss_finISH_times"]}}
{"code": "\\n  f = open(sys.argv[1])\\n  T = int(f.readline())\\n  for test in range(T):\\n      R, C, M = map(int, f.readline().strip().split())\\n      Rorig = R\\n      Corig = C\\n      impossible = False\\n      grid = [['.' for i in range(C)] for j in range(R)]\\n  \\n      curr_coord = [0,0]\\n      while M > 0 and not impossible:\\n          if (C > R): # more columns - fill one in\\n              num_mines_in_column = R\\n              if M < R:\\n                  num_mines_in_column = min(R - 2, M)\\n              if num_mines_in_column <= 0:\\n                  impossible = True\\n                  break\\n              for ii in range(num_mines_in_column):\\n                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'\\n              C -= 1\\n              curr_coord[1] += 1\\n              M -= num_mines_in_column\\n          else:\\n              num_mines_in_row = C\\n              if M < C:\\n                  num_mines_in_row = min(C - 2, M)\\n              if num_mines_in_row <= 0:\\n                  impossible = True\\n                  break\\n              for ii in range(num_mines_in_row):\\n                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'\\n              R -= 1\\n              curr_coord[0] += 1\\n              M -= num_mines_in_row\\n  \\n      print \"Case #%d:\" % (test + 1)\\n      if impossible:\\n          print \"Impossible\"\\n      else:\\n          for ii in range(Rorig):\\n              for jj in range(Corig):\\n                  if grid[ii][jj] == '.':\\n                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':\\n                          grid[ii][jj] = 'dirty'\\n                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\\n                          grid[ii][jj] = 'dirty'\\n                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\\n                          grid[ii][jj] = 'dirty'\\n  \\n          for ii in range(Rorig):\\n              for jj in range(Corig):\\n                  if grid[ii][jj] == 'dirty':\\n                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':\\n                          grid[ii][jj] = '.'\\n                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':\\n                          grid[ii][jj] = '.'\\n                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\\n                          grid[ii][jj] = '.'\\n                      else:\\n                          if ii != Rorig - 1 or jj != Corig - 1:\\n                              impossible = True\\n  \\n          if impossible:\\n              print \"Impossible\"\\n          else:\\n              grid[Rorig-1][Corig-1] = 'c'\\n  \\n              for ii in range(Rorig):\\n                  print \" \".join([val for val in grid[ii]])\\n  \\n  \\n", "target": "50", "substitutes": {"f": ["inf", "af", "file", "cf", "t", "sp", "l", "sf", "ft", "fx", "bf", "fs", "c", "fb", "r", "tf", "b", "fc", "fo", "o", "fa", "fg", "xf", "uf", "fn", "v", "F", "x", "fd", "fr", "feed", "df", "p", "fp", "h", "fm", "lf"], "T": ["V", "GT", "G", "W", "P", "TB", "J", "TX", "TN", "t", "Y", "N", "B", "TA", "D", "TT", "TV", "K", "I", "X", "E", "TS", "S", "NT", "L", "F", "TH", "TR", "Q", "TM", "XT", "Z", "TL"], "test": ["Test", " D", " TT", " TM", "t", "tr", " E", " time", " TD", " RT", " Tr", " tr", "TT", " tc", "tt", " P", "ter", " iT", " J", " ti", " N", " trial", " Test", " X", " Ti", " temp", " tmp", "TM"], "R": ["V", "RS", "G", "P", "RE", "J", "Y", "RG", "N", "O", "B", "MR", "RF", "Rs", "D", "RA", "r", "H", "K", "SR", "RM", "A", "RT", "I", "RO", "X", "E", "S", "RR", "DR", "NR", "L", "F", "CR", "Res", "TR", "Q"], "C": ["V", "CS", "G", "CI", "P", "J", "COR", "Cos", "CC", "CO", "N", "CL", "O", "MC", "B", "CM", "c", "D", "CF", "YC", "CB", "Cs", "K", "CE", "JC", "CT", "CU", "A", "I", "E", "CP", "S", "L", "F", "CR", "CON", "CN", "WC", "Con", "TC", "Co"], "M": ["V", "G", "MAN", "P", "MT", "J", "Multi", "m", "N", "MC", "B", "CM", "MR", "MN", "D", "H", "MP", "MI", "LM", "RM", "Mass", "I", "E", "S", "L", "F", "PM", "TM", "MS", "MM", "NM", "VM", "DM"], "Rorig": ["Toriginal", "GOrig", "Gcap", "ROrig", " Roriginal", "Gorig", "Goriginal", " ROrig", "Tcap", "TOrig", " Rcap", "Roriginal", "Rcap", "Torig"], "Corig": ["qualig", "corIG", "corig", "torig", "torbit", " Corbit", " CorIG", "corun", "qualIG", "torun", "torIG", "corbit", "qualun", " Corun", "qualbit"], "impossible": ["Impacted", "Impausible", "impure", "impossibility", " impacted", "expure", "deport", " impure", "depossibility", "Impossible", " impossibility", " impacked", "depacked", "expacted", " impausible", "impacked", "expausible", "Impacked", "impacted", "depossible", "Impure", "Impossibility", "expossible", "Import", "impausible"], "grid": ["Grid", "rid", "work", "stack", "g", "cell", "dq", "dim", "mask", "mat", "addr", "db", "xy", "check", "id", " Grid", " grids", "cache", "chain", "tile", "num", "sim", "code", "debug", "cb", "scale", "cale", "complex"], "i": ["ti", "s", "u", "y", "ic", "li", "ie", "n", "l", "c", "z", "k", "iu", "r", "q", "b", "im", "o", "I", "v", "x", "ia", "gi", "ci", "io", "ei"], "j": ["J", "ch", "g", "m", "ie", "n", "l", "nr", "z", "jp", "e", "k", "ij", "jc", "q", "ir", "r", "b", "o", "v", "di", "fr", "un", "p", "ji", "d", "h"], "curr_coord": ["curend_loc", "curend_coord", "curr_loc", "curr_pos", "curend_num", "curr_num", "curend_pos"]}}
{"code": "\\n  \\n  \\n  \\n  tCase = int(sys.stdin.readline())\\n  \\n  def calcTemp(taxa, X):\\n  \treturn X/taxa;\\n  \\n  def main(C, F, X):\\n  \\n  \ttaxa = 2.0\\n  \tresp = 0\\n  \t\\n  \t\\n  \twhile True:\\n  \t\tif C/taxa + calcTemp(taxa + F, X) < calcTemp(taxa, X):\\n  \t\t\tresp += C/taxa\\n  \t\t\ttaxa += F\t\t\t\\n  \t\telse:\\n  \t\t\tresp += calcTemp(taxa, X)\\n  \t\t\treturn resp\\n  \t\\n  \t\\n  \treturn 0\\n  \t\t\\n   \\n  if __name__ == '__main__':\\n  \tfor i in xrange(tCase):\t\\n  \t\t\\n  \t\tC, F, X = [float(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tprint \"Case #%d: %s\" % (i + 1, main(C, F, X))\\n", "target": "51", "substitutes": {"tCase": ["tucase", "tuFirst", " tTest", "gFirst", "TCase", "testCase", "tUse", "tcase", "gCase", "tuCase", " tLen", "testcase", "TLen", "Tcase", "testTest", "testLen", "tuUse", " tFirst", "gcase", "tFirst", " tcase", " tUse", "tTest", "tLen", "gUse", "TTest"], "taxa": ["gena", "axarea", "taxana", "Taxae", " taxA", "TaxA", "zipoa", " taxana", "taxae", "zipa", "axa", "Taxea", "taxea", "zipA", "cata", "oxoa", "catea", "oxA", " Taxa", "Taxana", " taxae", "Taxoa", " taxarea", "taxA", "axea", "geno", "taxo", "genea", "axae", " taxoa", " TaxA", "taxarea", " taxan", "Taxan", "genA", "axan", " taxo", "axoa", " taxea", "catA", "taxoa", " Taxea", "oxa", "Taxo", "Taxarea", "oxan", "axA", "cato", "zipan", " Taxo", "taxan", "axana", "Taxa"], "X": ["V", "Tx", "P", "XXX", "IC", "ML", "Time", "TX", "CC", "XY", "FX", "Y", "XM", "N", "EX", "Xi", "PE", "IP", "Key", "Win", "HTTP", "XL", "PC", "WH", "H", "IX", "XX", "T", "A", "Cross", "DX", "I", "R", "E", "CA", "S", "L", "Rex", "U", "IR", "UX", "XP", "Q", "XT", "OX", "MX", "IT", "Z", "TC", "Ex", "ICE"], "C": ["V", "AC", "CS", "G", "CI", "P", "CV", "W", "J", "CNN", "CC", "CO", "Cod", "Y", "N", "M", "O", "Mc", "MC", "B", "c", "CM", "Control", "D", "Ch", "Cs", "Cont", "H", "K", "LC", "CE", "CT", "CU", "T", "DC", "Cl", "A", "I", "R", "E", "CP", "Cache", "S", "Cons", "L", "U", "Config", "CR", "CON", "Q", "WC", "Con", "TC", "Co"], "F": ["V", "G", "W", "P", "FT", "J", "GF", "FW", "FR", "FS", "Fs", "f", "Y", "N", "Def", "FC", "M", "O", "FI", "B", "RF", "TF", "Foreign", "D", "EF", "CF", "FL", "FD", "IF", "H", "K", "DF", "T", "A", "UF", "I", "Full", "R", "E", "FO", "S", "FG", "WF", "L", "U", "Fun", "Q", "SF", "OF", "Fin", "Z", "PF", "FF", "Family", "FE"], "resp": ["wb", "cmd", "compl", "conn", "sp", "repre", "nz", "Resp", "wr", "repl", "xp", "comp", "respons", "jp", "adj", "tmp", "rew", "comm", "response", "re", "r", "esp", "acc", "red", "term", "obj", "rec", "cond", "rel", "j", "rh", "nt", "pas", "ret", "res", "reg", "rep", "Response", "out", "respond", "cmp", "RES", "lr", "rex", "col", "ctx", "rez", "p", "val", "eff", "andre", "exp", "err", "pos", "trip"], "i": ["ti", "s", "ini", "y", "ic", "u", "ind", "pi", "f", "li", "m", "t", "xi", "multi", "n", "it", "ix", "index", "us", "l", "c", "e", "k", "zi", "id", "ij", "q", "ai", "im", "I", "si", "j", "mi", "v", "ik", "gi", "di", "ip", "me", "p", "d", "ci", "name"], "x": ["mx", "ax", "ch", "y", "xs", "xt", "t", "xe", "xd", "xi", "xp", "ix", "xa", "fx", "lex", "ext", "z", "e", "xy", "rx", "xb", "q", "co", "px", "ey", "xf", "xx", "wx", "dx", "v", "ox", "ex", "ick", "ux", "p", "xc", "tx"]}}
{"code": "\\n  \\n  tCase = int(sys.stdin.readline())\\n  \\n  \\n  def map(R, C, Bombs):\\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\\n  \tprint Bombs\\n  \tm[R-1][C-1] = 'c'\\n  \tlastSkip = False\\n  \tfor i in xrange(R):\\n  \t\tfor j in xrange(C):\\n  \t\t\tif Bombs == 0:\\n  \t\t\t\tbreak\\n  \t\t\t\\n  \t\t\tif lastSkip:\\n  \t\t\t\tm[i][j] = 'f'\\n  \t\t\t\tcontinue\\n  \t\t\t\\n  \t\t\tif R - i == 2 or C - j == 2:\\n  \t\t\t\tif Bombs == 1:\\n  \t\t\t\t\tm[i][j] = 'f'\\n  \t\t\t\t\tlastSkip = True\\n  \t\t\t\t\tcontinue\\n  \t\t\t\\n  \t\t\t\t\\n  \t\t\tm[i][j] = '*'\\n  \t\t\tBombs -= 1\\n  \t\t\tlastSkip = False\\n  \t\tlastSkip = False\\n  \t\t\t\t\\n  \t\\n  \t\\n  \tfor line in m:\\n  \t\tfor c in line:\\n  \t\t\tprint c,\\n  \t\tprint\\n  \t\t\\n  \t\t\\n  def imprimir(m):\\n  \tfor line in m:\\n  \t\tfor c in line:\\n  \t\t\tprint c,\\n  \t\tprint\\n  \t\t\\n  def map2(R, C, Bombs):\\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\\n  \tm[R-1][C-1] = 'c'\\n  \tlastSkip = False\\n  \t\\n  \tii = 0\\n  \tjj = 0\\n  \twhile Bombs > 0:\\n  \t\tfor j in xrange(jj, C):\\n  \t\t\tif Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\\n  \t\t\t\tm[ii][j] = '*'\\n  \t\t\t\tBombs -= 1\\n  \t\t\telse:\\n  \t\t\t\tcontinue\\n  \t\t\\n  \t\t\\n  \t\tfor i in xrange(ii+1, R):\\n  \t\t\tif Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\\n  \t\t\t\tm[i][jj] = '*'\\n  \t\t\t\tBombs -= 1\\n  \t\t\telse:\\n  \t\t\t\tif Bombs > 0:\\n  \t\t\t\t\tprint \"Impossible\"\\n  \t\t\t\t\treturn\\n  \t\t\t\tcontinue\\n  \t\tjj += 1\\n  \t\tii += 1\\n  \timprimir(m)\\n  \t\\n  \t\t\t\t\\n  \t\\n  \t\\n  \\n  \t\t\\n  def main(R, C, M):\\n  \tvazios = R * C - M\\n  \\n  \tif R == 1 or C == 1 or vazios == 1 or vazios >= 4:\\n  \t\tmap2(R, C, M)\\n  \telse:\\n  \t\tprint \"Impossible\"\\n  \\n  \treturn \"\"\\n  \t\t\\n   \\n  if __name__ == '__main__':\\n  \tfor i in xrange(tCase):\t\\n  \t\t\\n  \t\tR, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tprint \"Case #%d:\" % (i + 1)\\n  \t\tmain(R, C, M)\\n", "target": "51", "substitutes": {"tCase": ["dTest", " tTest", "TCase", "TNow", "tcase", "gCase", " tNow", " tCons", "dcase", "Tcase", "dCase", "TCons", "gCons", "gcase", " tcase", "gTest", "tTest", "tCons", "tNow", "TTest", "dNow"], "R": ["V", "RS", "G", "RE", "P", "Role", "W", "Remote", "J", "ER", "RB", "Range", "Y", "Reg", "Re", "RG", "N", "Right", "O", "Dr", "B", "MR", "RF", "Rs", "GR", "D", "RL", "RA", "r", "H", "BR", "RH", "SR", "RC", "RGB", "RM", "T", "Reader", "A", "Row", "RT", "I", "RO", "X", "JR", "RI", "S", "RR", "NR", "DR", "U", "F", "Rot", "RW", "CR", "IR", "Mr", "Res", "Q", " r", "AR", "Rat", "HR", "Br", "RP", "Rec", "Ren", "Ref", "Red"], "C": ["V", "CS", "G", "W", "Y", "CG", "Mc", "Count", "CF", "K", "JC", "CT", "E", "CA", "Custom", "CBS", "CR", "CN", "Craig", "CI", "Rh", "CC", "N", "B", "CB", "Ch", "CE", "CU", "Charlie", "I", "S", "F", "WC", "SC", "CNN", "Cr", "CL", "D", "YC", "Cs", "H", "Cl", "CD", "CP", "Cache", "Cons", "Config", "Cu", "VC", "TC", "AC", "P", "Chain", "IC", "J", "COR", "Cow", "HC", "CM", "CCC", "T", "DC", "A", "X", "EC", "BC", "L", "CON", "CW", "Con", "Co"], "Bombs": ["Blockbusters", " Bounces", "Berombs", " Baos", "Bitis", "Bashes", "bogens", "IBumps", "Robguns", "Batos", "Robaos", "Gumps", "Gombs", "Blusters", "BWatos", "BRombs", " Bomes", "Rombies", "Dotos", "Berounces", "Butashes", "VBombies", "Bbusters", "Tatos", "Abombies", "Abashes", " Bicals", "Bootounces", "Berombies", "Robombs", "Debombs", "Bomes", "IBombs", " Bbusters", "Baos", "BWCBS", " Bombies", " Baxies", "NBombs", "Bobs", "Gomb", "BWombs", "NBobs", "Bogs", "VBatos", "Butounces", "Tumps", "BWombies", "Blaxies", "Vbusters", "bombs", "bitis", "Tashes", "bombies", "NBumps", "Blockobs", "Bogens", " Bitis", "Tbusters", "IBomb", "Robombies", "Debrones", "Blogens", "Bounces", "Bumps", "Vombs", "Blockrones", " BCBS", "Debogs", "Berotos", " Bobs", "IBaos", "CBaos", "Dombs", "Gounces", "CBombs", "Butombies", "Bootombies", " Bogs", "Bicals", "Blockusters", "NBomb", "Bombies", " Botos", "Blockicals", "BRCBS", "Debombies", "Rotos", "Bomb", "Vashes", "Blounces", "Baxies", "BCBS", " Busters", "VBombs", "Blockguns", "Busters", "Butombs", " Batos", "Bootaxies", "CBombies", "Debogens", "bomb", "Abounces", "CBguns", "Gombies", "Rombs", "Debbusters", "Brones", "bogs", " Bashes", "Botos", "BRombies", "Vumps", " Bumps", "bumps", "NBombies", "VBomes", "Tombs", "Bguns", " Bguns", "NBguns", "Gaos", "Abombs", "Dombies", "Debusters", "Tomes", "NBicals", "Bootombs", "Blockombs", "Blombs", "BRatos", "Titis", "Rbusters", "Gotos", "Blombies", " Brones", " Bomb", " Bogens", "Tombies", "Blumps", "Dbusters", "Gbusters"], "m": ["s", "sm", "mx", "t", "g", "multi", "l", "mt", "mem", "b", "km", "pm", "perm", "mut", "v", "me", "a", "ma", "nm", "em", "w", "mn", "wm", "mos", "mc", "db", "e", "r", "hm", "md", "dm", "gm", "p", "come", "h", "mark", "esm", "mail", "asm", "mk", "mode", "f", "n", "rm", "tm", "map", "body", "mac", "mp", "fm", "ml", "am", "o", "mod", "mi", "mr", "d", "bm", "ms", "y", "ze", "memory", "mat", "mm", "app", "man", "arm", "um", "im", "params", "cm", "mit", "vm"], "x": ["mx", "int", "php", "ax", "y", "w", "xs", "xt", "on", "t", "f", "xe", "xml", "yx", "xi", "at", "n", "byte", "ix", "xa", "cl", "fx", "lat", "fix", "lex", "z", "ont", "full", "e", "k", "check", "plex", "rx", "xy", "id", "get", "\u00e7", "mix", "r", "xes", "co", "time", "change", "pr", "xf", "X", "ction", "rox", "xx", "wx", "dx", "v", "ox", "fill", "index", "key", "ex", "inx", "ctx", "ci", "p", "ct", "ux", "a", "xc", "tx"], "lastSkip": [" lastScan", "lastStep", "nextSkip", "LastKill", "nextKill", "basePass", "lastPass", "lastScan", "baseKill", " lastPass", "baseSkip", "LastSkip", "scopeStep", "LastMiss", "firstSkip", "scopeCopy", "LastPass", "firstPass", "nextCopy", " lastStep", "LastScan", "LastStep", " lastMiss", "lastCopy", "lastMiss", "LastCopy", "lastKill", "nextPass", "scopeSkip", "firstScan", "baseCopy", " lastKill", " lastCopy", "firstCopy", "scopeMiss", "firstKill"], "i": ["ori", "ti", "ki", "int", "ish", "ini", "y", "ic", "u", "ind", "pi", "f", "li", "ami", "ie", "xi", "it", "ix", "index", "l", "iri", "h", "bi", "z", "II", "e", "zi", "id", "iu", "ij", "hi", "r", "ir", "q", "ai", "iv", "b", "im", "o", "ri", "I", "si", "mi", "info", "fi", "v", "ia", "ib", "di", "gi", "ik", "ip", "ci", "ji", "iti", "d", "p", "item", "io", "ei"], "j": ["jl", "json", "ja", "ju", "J", "y", "item", "t", "jas", "f", "li", "g", "ie", "n", "kj", "it", "l", "ix", "index", "key", "aj", "z", "js", "bi", "jp", "dj", "k", "zi", "ij", "jc", "q", "r", "jac", "ai", "bj", "b", "o", "obj", "pr", "v", "er", "di", "je", "fr", "jump", "uj", "col", "ci", "ji", "p", "job", "h", "ion", "rev", "oj"], "line": ["range", "ile", "loop", "ner", "do", "file", "ine", "note", "icate", "to", "let", "mode", "ze", "li", "inline", "skip", "only", "l", "cl", "lin", "lined", "lines", "load", "write", "lock", "live", "ite", "check", "set", "parse", "main", "store", "call", "co", "change", "draw", "go", "liner", "block", "rule", "ward", "no", "see", "point", "se", "stream", "cycle", "frame", "chain", "eline", "lining", "ode", "ase", "side", "Line", "fill", "now", "use", "list", "code", "link", "page", "ste", "open", "online", "verse", "lo", "ge", "ide"], "c": ["cs", "cr", "cont", "ic", "y", "u", "w", "f", "g", "n", "it", "l", "cl", "can", "gc", "ac", "h", "z", "con", "mc", "e", "\u00e7", "call", "r", "dc", "lc", "co", "fc", "unc", "o", "bc", "ar", "icc", "cache", "chain", "cod", "v", "cat", "cu", "er", "orc", "out", "pc", "cm", "ci", "p", "ct", "cation", "a", "d", "xc", "nc", "cc"], "ii": ["ki", "ti", "jl", "aaa", "ja", "iy", "ini", "obi", "tti", "pi", "li", "ami", "ie", "xi", "ix", "nr", "iri", "iw", "bi", "II", "IJ", "aa", " iii", "zi", "hi", "iu", "ij", "ni", "hai", "ir", "ai", "I", "si", "iii", "ui", "qi", "iona", "ia", "di", "ih", "yi", "ios", "iann", "uj", "ci", "ji", "ei"], "jj": ["jl", "json", "ja", "xxx", "ju", "J", "Ju", "jad", "CC", "jas", "gh", "jobs", "bb", "kj", "it", "JJ", "nr", "john", "aj", "isa", "II", "jp", "IJ", " iii", "dj", "aa", "yy", "ij", "nn", "jc", "obs", "jac", "iu", "JC", "jit", "bj", "r", "b", "I", "ordan", "jack", "iii", "JR", "iona", "aq", "Jr", "jah", "ia", "cu", "fr", "jump", "uj", "ijk", "ci", "ji", "Ja", "cc"], "M": ["V", "Mon", "G", "MAN", "W", "P", "MT", "J", "Multi", "Y", "N", "O", "MC", "B", "CM", "D", "H", "Ms", "K", "MI", "RM", "T", "A", "I", "X", "E", "S", "L", "F", "PM", "U", "Q", "MS", "MM", "NM", "Z", "AM"], "vazios": ["vuzians", "vizios", "vagillas", "mizios", "lazios", "vAZillas", "lozios", "vAZians", "vazians", "mazies", "tvAZillas", "vazials", "tvAZios", "vzians", "lozians", "vozios", "vAZials", "loziers", "laziers", "lazians", "vizians", "vozians", "tvAZians", "vagios", "vuzillas", "tvazials", "vzios", "vazio", "vizies", "mazios", "vuzio", "mizians", "vzio", "tvAZials", "vaziers", "miziers", "vuziers", "lazio", "voziers", "maziers", "mizies", "vagians", "vazillas", "tvazios", "vozio", "mazians", "viziers", "vziers", "vzies", "vuzials", "vAZios", "vuzios", "lozio", "tvazillas", "vazies", "vozies", "vagials", "tvazians"]}}
{"code": "\\n  def debug(v):\\n      pass#print(v)\\n  \\n  def read(f):\\n      t = tuple(int(v) for v in f.readline().split())\\n      debug(t)\\n      return t\\n  \\n  def readf(f):\\n      t = tuple(float(v) for v in f.readline().split())\\n      debug(t)\\n      return t\\n  \\n  def answer(f, X, ans):\\n      out = \"Case #{}: {}\".format(X, ans)\\n      f.write(out)\\n      f.write(\"\\n\")\\n      print(out)\\n  \\n  \\n  \\n  def main(inf, outf):\\n      T, = read(inf)\\n      for casenmbr in range(1, T + 1):\\n          C, F, X = readf(inf)\\n  \\n          power = 2\\n          farmtime = round(C / power, 7)\\n          keikatime = 0\\n          totaltime = round(X / power, 7)\\n  \\n          while True:\\n              keikatime += farmtime\\n              power += F\\n              farmtime = round(C / power, 7)\\n              nokoritime = round(X / power, 7)\\n              if keikatime + nokoritime > totaltime:\\n                  break\\n              totaltime = keikatime + nokoritime\\n  \\n          answer(outf, casenmbr, totaltime)\\n  \\n  \\n  if __name__==\"__main__\":\\n      infname = sys.argv[1]\\n      outfname = os.path.splitext(infname)[0] + \".out\"\\n      with open(infname, \"r\") as inf:\\n          with open(outfname, \"w\") as outf:\\n              main(inf, outf)\\n", "target": "52", "substitutes": {"v": ["V", "value", "sv", "y", "u", "w", "t", "f", "g", "m", "n", "vv", "c", "z", "k", "uv", "vt", "q", "r", "b", "o", "qv", "x", "env", "p", "d", "a", "h"]}}
{"code": "\\n  def debug(v):\\n      pass#print(v)\\n  \\n  def read(f):\\n      t = tuple(int(v) for v in f.readline().split())\\n      debug(t)\\n      return t\\n  \\n  def readf(f):\\n      t = tuple(float(v) for v in f.readline().split())\\n      debug(t)\\n      return t\\n  \\n  def answer(f, X, ans):\\n      out = \"Case #{}:\\n{}\".format(X, ans)\\n      f.write(out)\\n      f.write(\"\\n\")\\n      print(out)\\n  \\n  def answer_cells(f, X, cells):\\n      out = \"Case #{}:\".format(X)\\n      f.write(out)\\n      f.write(\"\\n\")\\n      print(out)\\n      for row in cells:\\n          out = \"\".join(row)\\n          f.write(out)\\n          f.write(\"\\n\")\\n          print(out)\\n  \\n  def main(inf, outf):\\n      T, = read(inf)\\n      for casenmbr in range(1, T + 1):\\n          R, C, M = read(inf)\\n  \\n          if M == 0:\\n              cells = [['.'] * C for i in range(R)]\\n              cells[0][0] = 'c'\\n              answer_cells(outf, casenmbr, cells)\\n              continue\\n  \\n          empty = R * C - M\\n  \\n          if empty == 1:\\n              cells = [['*'] * C for i in range(R)]\\n              cells[0][0] = 'c'\\n              answer_cells(outf, casenmbr, cells)\\n              continue\\n  \\n          if R == 1 or C == 1:\\n              cells = [['.'] * C for i in range(R)]\\n              m = 0\\n              for r in range(R):\\n                  for c in range(C):\\n                      cells[r][c] = '*'\\n                      m += 1\\n                      if m == M:\\n                          break\\n                  else:\\n                      continue\\n                  break\\n              cells[-1][-1] = 'c'\\n              answer_cells(outf, casenmbr, cells)\\n              continue\\n  \\n          if empty in (2, 3, 5, 7):\\n              answer(outf, casenmbr, \"Impossible\")\\n              continue\\n  \\n          if (R == 2 or C == 2) and empty % 2:\\n              answer(outf, casenmbr, \"Impossible\")\\n              continue\\n  \\n          cells = [['*'] * C for i in range(R)]\\n  \\n  \\n          cells[0][0] = 'c'\\n          empty -= 1\\n          cc = 1\\n          rr = 1\\n          while empty > 0:\\n              if cc < C:\\n                  for r in range(rr):\\n                      if empty == 2 and r == rr - 1:\\n                          break\\n                      cells[r][cc] = '.'\\n                      empty -= 1\\n                      if empty == 0:\\n                          break\\n                  cc += 1\\n              if rr < R and empty > 0:\\n                  for c in range(cc):\\n                      if empty == 2 and c == cc - 1:\\n                          break\\n                      cells[rr][c] = '.'\\n                      empty -= 1\\n                      if empty == 0:\\n                          break\\n                  rr += 1            \\n  \\n          answer_cells(outf, casenmbr, cells)\\n  \\n  \\n  if __name__==\"__main__\":\\n      infname = sys.argv[1]\\n      outfname = os.path.splitext(infname)[0] + \".out\"\\n      with open(infname, \"r\") as inf:\\n          with open(outfname, \"w\") as outf:\\n              main(inf, outf)\\n", "target": "52", "substitutes": {"v": ["V", "value", "sv", "y", "u", "w", "t", "f", "g", "m", "n", "vv", "c", "z", "k", "uv", "vt", "q", "r", "b", "o", "qv", "x", "env", "p", "d", "a", "h"]}}
{"code": "\\n  \\n  def solve(C, F, X):\\n      rate = 2.0\\n      time_to_win = X / rate\\n  \\n      time_used = C / rate\\n      rate += F\\n      time_to_win_new = time_used + X / rate\\n  \\n      while time_to_win_new < time_to_win:\\n          time_to_win = time_to_win_new\\n          \\n          time_used += C / rate\\n          rate += F\\n          time_to_win_new = time_used + X / rate\\n  \\n      return time_to_win\\n  \\n  def main():\\n      N = int(sys.stdin.readline()) # number of testcases\\n      for i in range(N):\\n          [C, F, X] = [float(x) for x in sys.stdin.readline().rstrip().split()]\\n  \\n          result = solve(C, F, X)\\n          print (\"Case #%s: %.7f\" % (i+1, result))\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "target": "53", "substitutes": {"C": ["V", "CS", "W", "P", "CNN", "CC", "CO", "Y", "M", "FC", "B", "c", "CM", "D", "CB", "CF", "YC", "Ch", "H", "CE", "CCC", "T", "DC", "A", "R", "E", "CP", "Cache", "S", "L", "U", "CR", "CON", "Co"], "F": ["V", "W", "P", "FU", "FT", "Time", "GF", "FR", "Fs", "f", "AF", "Y", "FER", "Frame", "M", "FC", "Float", "FB", "MF", "B", "TF", "D", "CF", "EF", "FD", "IF", "H", "DF", "T", "A", "UF", "I", "R", "E", "FO", "FG", "L", "FP", "FM", "New", "PF", "FF", "Family", "FA", "Only", "FE"], "X": ["V", "W", "P", "XXX", "J", "Time", "TX", "FX", "Y", "XM", "FC", "EX", "D", "CF", "HTTP", "XL", "H", "K", "CE", "IX", "XX", "T", "Cross", "DX", "I", "R", "E", "S", "L", "x", "U", "UX", "XP", "Q", "XT", "Once", "Z", "ZX", "FF", "Int", "ICE"], "rate": ["power", "ate", "timeout", "prime", "date", "sync", "wheel", "capacity", "float", "write", "root", "ipe", "force", "weight", "speed", "type", "range", "gain", "rice", "core", "goal", "sex", "step", "buffer", "fine", "function", "rew", "r", "depth", "change", "rule", "term", "Rate", "distance", "command", "mean", "feed", "delay", "scale", "score", "length", "sample", "rates", "domain", "mode", "rating", "zip", "f", "fee", "slave", "base", "grade", "late", "rat", "state", "ride", "time", "go", "erate", "te", "race", "execute", "fps", "value", "efficient", "frequency", "peed", "url", "test", "con", "rank", "re", "control", "cycle", "count", "currency", "grow", "code", "error", "complex", "factor"], "time_to_win": ["time_2_win", "time_too_Win", "time_2_close", "time_to2Win", "time_left_window", "time_to2in", "time_too_win", "time_left__in", "time_to_close", "time_left_win", "time_left_Win", "time_to__in", "time_too_windows", "time_to__Win", "time_to_window", "time_to___close", "time_to__window", "time_2_Win", "time_to_won", "time_to___win", "time_too_window", "time_left__Win", "time_2_won", "time_left__win", "time_to2win", "time_to_in", "time_to__win", "time_to_Win", "time_to2window", "time_to___Win", "time_left__window", "time_left_in", "time_to_windows", "time_to___won"], "time_used": ["etime09using", "time_given", "time_created", "TIME_use", " time_given", "time_available", "timet0", "TIME_available", "etime_usage", "etime09after", "windowtcreated", "timetimegiven", "window_used", "time_us", "timetimereported", "time_using", "window_using", "etime09used", "time09usage", "window_0", "time_usage", "time09using", "etime_used", "TIME_used", "time09used", "timetcreated", "etime_after", "etime09usage", "windowtused", "TIME_us", "windowt0", "windowtusing", "timetusing", "etime_using", "time09after", "time_0", "timetused", "time_reported", "time_after", "time_use", "window_created", " time_reported", "timetimeused"], "time_to_win_new": ["time_to_Win_unit", "time_to_win_New", "time_to_win_old", "time_to_win_unit", "time_to_Win_gen", "time_to_Win_old", "time_to_Win_new", "time_to_window_next", "time_to_window_full", "time_to_win_gen", "time_to_window_new", "time_to_win_next", "time_to_win_full", "time_to_Win_win", "time_to_window_old", "time_to_win_win"], "N": ["V", "G", "P", "J", "Y", "n", "M", "O", "B", "NS", "D", "H", "K", "T", "A", "I", "R", "E", "S", "NT", "NC", "L", "FN", "Q", "Z"]}}
{"code": "\\n  \\n  def neighbours(grid, (i, j), n, m):\\n      for a in range(max(i-1, 0), min(i+2, n)):\\n          for b in range(max(j-1, 0), min(j+2, m)):\\n              if (a != i or b != j):\\n                  yield (a, b)\\n  \\n  def isGridCorrect(grid):\\n      g = list(grid)\\n      n = len(g)\\n      m = len(g[0])\\n      queue = [(0, 0)]\\n  \\n      while queue:\\n          v = queue.pop(0)\\n          g[v[0]][v[1]] = 'r'\\n          bomb = False\\n          for (i, j) in neighbours(g, v, n, m):\\n              if g[i][j] == '*':\\n                  bomb = True\\n          if not bomb:\\n              for (i, j) in neighbours(g, v, n, m):\\n                  if g[i][j] != 'r':\\n                      queue.append((i, j))\\n  \\n      for i in range(n):\\n          for j in range(m):\\n              if g[i][j] != 'r' and g[i][j] != '*':\\n                  return 'WRONG'\\n  \\n      return 'Right'\\n  \\n  def createGrid(R, C, s):\\n      field = []\\n      for i in range(R):\\n          field.append([s] * C)\\n      field[0][0] = 'c'\\n      return field\\n  \\n  def draw(grid):\\n      s = \"\"\\n      for row in grid:\\n          s += \"\\n\" + ''.join(row)\\n      return s\\n  \\n  def reduceRows(grid, k, l, M):\\n      if k <= 2:\\n          return (grid, k, l, M)\\n      \\n  \\n      for j in range(l):\\n          grid[k-1][j] = '*'\\n      k -= 1\\n      M -= l\\n      return (grid, k, l, M)\\n  \\n  def reduceCols(grid, k, l, M):\\n      if l <= 2:\\n          return (grid, k, l, M)\\n      \\n  \\n      for i in range(k):\\n          grid[i][l-1] = '*'\\n      l -= 1\\n      M -= k\\n      return (grid, k, l, M)\\n  \\n  def solve(R, C, M):\\n      mp = M\\n      if M == 0:\\n          f = createGrid(R, C, '.')\\n          return draw(f)\\n      elif M == R*C - 1:\\n          f = createGrid(R, C, '*')\\n          return draw(f)\\n      elif (R == 2 or C == 2) and (M % 2 == 1 or M == R*C - 2):\\n          return \"\\n\" + 'Impossible' #+ '1: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\\n      elif R > 2 and C > 2 and (M == R*C - 2 or M == R*C - 3 or M == R*C - 5 or M == R*C - 7):\\n          return \"\\n\" + 'Impossible' #+ '2: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\\n      else:\\n          grid = createGrid(R, C, '.')\\n  \\n  \\n          k = R\\n          l = C\\n  \\n          while (M >= l and k > 2) or (M >= k and l > 2):\\n              if l >= k:\\n                  (grid, k, l, M) = reduceCols(grid, k, l, M)\\n              elif k > l:\\n                  (grid, k, l, M) = reduceRows(grid, k, l, M)\\n  \\n  \\n          if M == 0:\\n              return draw(grid)\\n          if M < l - 1 and k > 2:\\n              for j in range(l - M, l):\\n                  grid[k-1][j] = '*'\\n          elif M < k - 1 and l > 2:\\n              for i in range(k - M, k):\\n                  grid[i][l-1] = '*'\\n          elif l > 3 and k > 3:\\n              for i in range(2, k):\\n                  grid[i][l-1] = '*'\\n              M -= k - 2\\n              for j in range(l - M - 1, l - 1):\\n                  grid[k-1][j] = '*'\\n          else:\\n              return \"\\n\" + 'Impossible' #+ '3: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\\n  \\n          return draw(grid)\\n  \\n  def main():\\n      N = int(sys.stdin.readline()) # number of testcases\\n      for i in range(N):\\n          [R, C, M] = [int(x) for x in sys.stdin.readline().rstrip().split()]\\n  \\n          result = solve(R, C, M)\\n          print (\"Case #%s:%s\" % (i+1, result))\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "target": "53", "substitutes": {"grid": ["ay", "clear", "card", "cli", "stack", "http", "cell", "lat", "c", "addr", "query", "table", "q", "modified", "frame", "output", "reg", "net", "age", "now", "wrapper", "console", "ad", "ge", "bar", "range", "Grid", "stock", "w", "network", "gate", "sh", "window", "game", "cart", "util", "db", "e", "fine", "gray", "raid", "r", "client", "via", "mg", "res", "storage", "out", "list", "gm", "p", "ace", "array", "record", "form", "domain", "rid", "input", "this", "browser", "back", "sheet", "raw", "d", "box", "cs", "data", "result", "sys", "gr", "y", "work", "lay", "play", "dq", "gc", "remote", "mat", "manager", "config", "jac", "group", "gs", "cache", "chain", "wire", "x", "fields", "er", "gi", "tile", "server", "item"], "n": ["nm", "nb", "ng", "nu", "names", "np", "y", "size", "len", "w", "t", "N", "nr", "mn", "en", "nor", "c", "z", "ns", "nl", "nn", "ny", "r", "q", "ne", "o", "no", "na", "nt", "min", "sn", "fn", "net", "x", "an", "nan", "out", "ln", "num", "nw", "nia", "cn", "p", "d", "h", "nc"], "m": ["sm", "mx", "em", "bm", "ms", "y", "om", "ma", "t", "mn", "c", "dim", "mat", "z", "tm", "rm", "mt", "mc", "mm", "r", "q", "mu", "mem", "um", "im", "am", "o", "perm", "mod", "mi", "min", "mr", "dm", "gm", "cm", "p", "d", "h", "vm"], "a": ["aaa", "af", "ja", "ea", "ta", "ka", "ata", "sta", "ax", "at", "c", "aj", "ac", "z", "ab", "aa", "da", "aff", "ai", "eas", "am", "ar", "A", "na", "sa", "ae", "aq", "ao", "anta", "an", "ia", "ak", "ca", "ba", "va", "au", "p", "la", "aw", "ma", "ap"], "b": ["ob", "abb", "y", "t", "bb", "B", "c", "bf", "z", "bi", "ab", "fb", "e", "db", "aa", "r", "bd", "bj", "br", "o", "bc", "by", "lb", "bl", "ib", "sb", "ba", "mb", "bis", "eb", "erb", "d", "be"], "g": ["cfg", "G", "gp", "gain", "gb", "gr", "vg", "t", "pg", "gh", "gate", "ga", "c", "game", "gc", "z", "og", "ac", "gam", "gre", "db", "e", "config", "fl", "r", "gt", "q", "group", "gs", "go", "gent", "msg", "tg", "gg", "back", "erg", "gd", "mg", "google", "gas", "alg", "reg", "deg", "ger", "gi", "di", "ig", "eg", "gm", "graph", "p", "d", "bg", "h", "ge", "gu"], "queue": ["timer", "loop", "message", "ue", "file", "card", "stack", "bench", "history", "archive", "buf", "channel", "quote", "Queue", "nr", "index", "late", "plot", "dq", "test", "tube", "order", "required", "status", "buffer", "store", "check", "que", "sequence", "iter", "update", "q", "event", "pipe", "batch", "block", "menu", "line", "counter", "forced", "qv", "count", "age", "hold", "ued", "trigger", "enabled", "worker", "layer", "list", "Q", "rl", "position", "next", "league", "array", "priority", "wait"], "v": ["V", "av", "sv", "u", "t", "cv", "inv", "vector", "tv", "it", "vv", "nv", "ev", "c", "z", "uv", "ve", "lv", "vt", "q", "r", "vol", "vc", "iv", "o", "vi", "vs", "ver", "qv", "vy", "vp", "env", "vic", "conv", "va", "vr", "p", "h", "vm"], "bomb": ["Break", "rick", "threat", "butt", "aaa", "Invalid", "controller", "card", "Board", "beard", "bo", "Failure", "Dynamic", "Controller", "charge", "zz", "buffer", "BALL", "Bomb", "bang", "bill", "board", "bird", "healthy", "Battery", "kick", "piece", "possibly", "BO", "bard", "nt", "rike", "burst", "bug", "ack", "boot", "Ball", " bombs", "bolt", "Buzz", "claimer", "blow", "fuck", "Attack", "Fail", "attack", "beat"], "i": ["ki", "ti", "ori", "int", "ini", "u", "y", "ic", "pi", "at", "li", "ami", "ie", "xi", "it", "ix", "c", "il", "bi", "z", "e", "zi", "hi", "iu", "ij", "id", "r", "ir", "q", "ai", "on", "im", "o", "left", "ri", "I", "si", "mi", "ui", "info", "x", "ia", "di", "gi", "yi", "ik", "ii", "ip", "me", "ci", "ji", "p", "io", "h", "ion", "t", "ei"], "j": ["jl", "json", "ja", "ju", "J", "jj", "note", "y", "u", "t", "at", "sp", "li", "ie", "kj", "it", "key", "c", "aj", "false", "z", "js", "bi", "when", "jp", "db", "dj", "e", "adj", "ij", "jc", "r", "q", "jac", "ai", "bj", "br", "o", "obj", "bs", "jo", "str", "x", "je", "off", "di", "fr", "jump", "uj", "dt", "p", "ji", "job", "d", "h", "ion", "rev", "ll", "oj"], "R": ["V", "RS", "G", "P", "W", "cont", "J", "of", "ed", "Y", "multi", "N", "Right", "B", "c", "GR", "Rs", "D", "full", "_", "H", "r", "K", "BR", "RA", "get", "Row", "T", "A", "I", "RO", "X", "E", "self", "S", "RR", "NR", "L", "F", "CR", "join", "Q", "func"], "C": ["V", "CS", "G", "W", "P", "J", "CC", "Cr", "Y", "N", "B", "c", "CM", "D", "Cs", "Ch", "H", "K", "T", "DC", "A", "I", "X", "E", "S", "L", "F", "CR", "Q", "Z", "Co"], "s": ["cs", "sys", "ds", "y", "w", "t", "types", "c", "fs", "ings", "js", "z", "eds", "its", "lines", "status", "e", "rs", "ns", "set", "sq", "r", "ss", "ls", "q", "ges", "gs", "ps", "ats", "es", "space", "ments", "sc", "bs", "S", "res", "ts", "str", "x", "ing", "fields", "er", "ws", "strings", "p", "d", "rows", "ers", "h", "string", "sets"], "field": ["length", "data", "tag", "butt", "value", "ld", "message", "string", "result", "comment", "file", "pair", "word", "mount", "pad", "band", "flag", "cell", "vector", "key", "attr", "c", "window", "z", "load", "buffer", "function", "column", "record", "control", "r", "table", "group", "instance", "rule", "handler", "number", "obj", "line", "label", "Field", "attribute", "str", "force", "fields", "player", "join", "layer", "node", "level", "char", "league", "array", "complex", "FIELD", "component", "relation", "form", "bar"], "row": ["post", "ows", "card", "pair", "tr", "case", "cell", "step", "set", "rs", "r", "entry", "our", "box", "board", "Row", "fc", "obj", "rec", "rc", "raw", "line", "frame", "ry", "usr", "star", "rown", "ow", "node", "error", "roll", "col", "rows", "array", "item", "name", "instance", "record", "job"], "k": ["ki", "uk", "kl", "kat", "kt", "mk", "ka", "ch", "u", "ic", "y", "w", "dk", "tk", "it", "kj", "key", "kind", "c", "kw", "z", "ac", "ks", "keys", "kh", "id", "kg", "q", "K", "r", "kn", "kar", "kr", "km", "o", "ck", "wk", "ky", "ok", "ek", "sk", "ku", "kid", "x", "ak", "ik", "ke", "ijk", "p", "d", "kk", "h", "ko"], "l": ["jl", "kl", "ld", "ol", "u", "ul", "len", "t", "li", "al", "lin", "c", "il", "h", "z", "nl", "fl", "dl", "ls", "r", "lv", "lc", "el", "lu", " L", "ml", "hl", "o", "left", "lp", "line", "lb", "L", "sl", "list", "ln", "pl", "lt", "p", "la", "le", "yl", "lo", "ll", "lis"], "M": ["V", "G", "MAN", "W", "P", "MT", "J", "Men", "Y", "N", "O", "MC", "B", "CM", "JM", "D", "Num", "Length", "Ch", "H", "Ms", "MI", "K", "IM", "LM", "RM", "T", "Message", "A", "Memory", "I", "X", "S", "Size", "L", "F", "PM", "Mi", "U", "My", "Q", "TM", "MS", "Matrix", "MX", "MM", "NM", "All", "Motion", "Method", "DM", "AM", "Manager"]}}
{"code": "\\n  def solve_case(c, f, x, case_number):\\n      rate = 2.0\\n      time = 0.0\\n      rest = x\\n      while True:\\n          time_to_c = c / rate\\n          time_to_x = rest / rate\\n          if time_to_c < time_to_x:\\n              time_to_x_with_boost = time_to_c + (rest / (rate + f))\\n              if time_to_x_with_boost < time_to_x:\\n                  rate += f\\n                  time += time_to_c\\n              else:\\n                  break\\n          else:\\n              break\\n      time += rest / rate\\n      print \"Case #%d: %.7f\" % (case_number, time)\\n  \\n  r = sys.stdin\\n  \\n  if len(sys.argv) > 1:\\n      r = open(sys.argv[1], 'r')\\n  \\n  total_cases = r.readline()\\n  for case_number in range(1, int(total_cases) + 1):\\n      values = map(float, r.readline().split(' '))\\n      solve_case(values[0], values[1], values[2], case_number)\\n", "target": "54", "substitutes": {"c": ["cs", "abc", "cp", "y", "t", "m", "case", "n", "l", "com", "C", "e", "lc", "co", "b", "fc", "cur", "cos", "ce", "rc", "v", "cor", "cu", "cm", "cd", "d", "ct", "h", "tc", "cc"], "f": ["inf", "cf", "frequency", "y", "w", "t", "m", "fac", "n", "ft", "sf", "l", "fx", "float", "bf", "fs", "z", "fe", "fb", "fer", "e", "q", "tf", "b", "fc", "xf", "fun", "rf", "fact", "fi", "ff", "v", "F", "force", "fd", "fr", "p", "d", "fp", "h", "fm", "i"], "x": ["s", "y", "ic", "xs", "w", "xt", "t", "xi", "xp", "n", "long", "step", "fx", "z", "full", "xy", "e", "rx", "xes", "fc", "xf", "X", "xx", "wx", "v", "ox", "force", "ex", "ux", "p", "xc", "max", "tx"], "case_number": ["case8position", "case2n", "case6num", "case_Number", "catch8index", "Case_number", "Case_no", "case2no", "case_index", "catch_position", "catch8number", "case_no", "catch8num", "Case_n", "case2num", "case_num", "case_n", "case_position", "catch_number", "catch_num", "catch8position", "case8number", "catch_index", "Case_Number", "case8index", "case6position", "Case_num", "case8num", "case2number", "case6number", "case6index"], "rate": ["range", "fed", "length", "duration", "power", "rates", "cr", "ate", "rice", "core", "trade", "frequency", "prime", "fee", "case", "base", "rot", "phrase", "late", "float", "test", "rand", "fine", "factor", "rew", "rank", "re", "fork", "control", "change", "boost", "rule", "term", "fact", "cycle", "currency", "force", "Rate", "transfer", "erate", "grow", "race", "lr", "weight", "speed", "mean", "feed", "scale", "delay", "cut", "price", "transform", "score"], "time": ["timer", "duration", "length", "value", "message", "times", "Time", "file", "timeout", "size", "frequency", "mode", "date", "t", "history", "case", "etime", "ime", "offset", "estamp", "total", "memory", "step", "test", "name", "runtime", "TIME", "sequence", "tt", "context", "path", "start", "space", "temp", "counter", "count", "clock", "now", "race", "error", "speed", "trace", "tim", "mean", "delay", "type", "transform", "stop", "tx"], "rest": ["range", "int", "core", "art", "frequency", "w", "t", "st", "case", "base", "rot", "long", "ft", "step", "test", "rand", "z", "fe", "rew", "re", "const", "Rest", "tt", "b", "boost", "i", "term", "start", "repeat", "min", "cycle", "res", "chain", "v", "force", "stem", "fr", "end", "limit", "val", "cut", "d", "part", "p", "stop", "just", "max", "rx"], "time_to_c": ["time_to_cs", "time_To_x", "time_to_r", "time_to_e", "time_To_c", "time_To_e", "time_to_v"], "time_to_x": ["time_toxx", "time_to_X", "time_to_ax", "time_To_ax", "time_toxy", "time_To_x", "time_to_ex", "time_toxc", "time_To_X", "time_To_c", "time_to_cox", "time_to_y", "time_To_ex", "time_toxax", "time_To_y"], "time_to_x_with_boost": ["time_to_x_with_score", "time_to_x_with_rate", "time_to_x_with_Boost"], "r": ["hr", "rr", "rt", "cr", "dr", "w", "t", "ren", "m", "err", "n", "rus", "l", "nr", "rd", "h", "sr", "rs", "re", "b", "ro", "kr", "br", "ar", "rec", "pr", "R", "rc", "rel", "res", "reader", "mr", "v", "usr", "er", "read", "rw", "rl", "writer", "right", "fr", "vr", "p", "d", "rar", "rb", "rx"], "total_cases": ["total67phones", "total8cases", "total2lines", "totalfulcons", "total_tests", "total_projects", " total_cons", "total67cases", "total67tests", "total8phones", "total8tests", "otal8tests", "otal_phones", "otal8cases", "total_cons", "otal8projects", "total_phones", "totalfulcases", "total2cases", "total2tests", "total2cons", " total_lines", "otal_projects", "totalfullines", "otal_tests", "total_lines", "totalfultests", "otal_cases", "otal8phones", " total_tests", "total67projects", "total8projects"], "values": ["ves", "value", "times", "blocks", "rates", "actions", "plays", "Values", "ms", "ries", "stats", "packs", "models", "days", "gets", "details", "cases", "views", "roots", "items", "lines", "keys", "settings", "places", "forms", "files", "versions", "gs", "lists", "groups", "fixes", "flows", "ools", "results", "words", "vs", "checks", "ums", "dates", "v", "ports", "measures", "users", "objects", "tests", "boxes", "years", "grades", "vals", "als", "val", "pins", "rows", "reports", "seconds", "maps", "points"]}}
{"code": "\\n  \\n  def print_basic_board(no_mine, r, c):\\n      printed_c = False\\n      for row in range(0, r):\\n          line = []\\n          for column in range(0, c):\\n              if printed_c:\\n                  if no_mine > 0:\\n                      line.append(\".\")\\n                      no_mine -= 1\\n                  else:\\n                      line.append(\"*\")\\n              else:\\n                  line.append(\"c\")\\n                  no_mine -= 1\\n                  printed_c = True\\n          print \"\".join(line)\\n  \\n  \\n  def print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c):\\n      printed_c = False\\n      for row in range(0, r):\\n          line = []\\n          for column in range(0, c):\\n              if printed_c:\\n                  if row < no_mine_row and column < no_mine_column:\\n                      line.append(\".\")\\n                  elif rest_no_mine_for_column > 0 and column == no_mine_column:\\n                      line.append(\".\")\\n                      rest_no_mine_for_column -= 1\\n                  elif rest_no_mine_for_row > 0 and row == no_mine_row:\\n                      line.append(\".\")\\n                      rest_no_mine_for_row -= 1\\n                  else:\\n                      line.append(\"*\")\\n              else:\\n                  line.append(\"c\")\\n                  printed_c = True\\n          print \"\".join(line)\\n  \\n  \\n  def solve_case(r, c, m, case_number):\\n      print \"Case #%d:\" % case_number\\n      no_mine = r * c - m\\n      if r < 2 or c < 2 or no_mine == 1:\\n          print_basic_board(no_mine, r, c)\\n      else:\\n          no_mine_row_max = int(math.ceil(float(no_mine) / 2))\\n          if no_mine_row_max > r:\\n              no_mine_row_max = r\\n          for no_mine_column in range(2, int(math.ceil(float(no_mine) / 2)) + 1):\\n              if no_mine_column > c:\\n                  break\\n              for no_mine_row in range(2, no_mine_row_max + 1):\\n                  rest_no_mine = no_mine - (no_mine_column * no_mine_row)\\n                  if rest_no_mine < 0:\\n                      continue\\n                  if rest_no_mine == 1:\\n                      continue\\n  \\n                  if rest_no_mine == 0:\\n                      print_board(no_mine_row, no_mine_column, 0, 0, r, c)\\n                      return\\n                  if rest_no_mine <= no_mine_row and no_mine_column < c:\\n                      print_board(no_mine_row, no_mine_column, 0, rest_no_mine, r, c)\\n                      return\\n                  if rest_no_mine <= no_mine_column and no_mine_row < r:\\n                      print_board(no_mine_row, no_mine_column, rest_no_mine, 0, r, c)\\n                      return\\n  \\n                  if rest_no_mine > 3 and no_mine_column < c and no_mine_row < r:\\n                      for rest_no_mine_for_row in range(2, no_mine_column):\\n                          rest_no_mine_for_column = rest_no_mine - rest_no_mine_for_row\\n                          if rest_no_mine_for_column < no_mine_row:\\n                              print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c)\\n                              return\\n  \\n          print \"Impossible\"\\n  \\n  r_file = sys.stdin\\n  \\n  if len(sys.argv) > 1:\\n      r_file = open(sys.argv[1], 'r')\\n  \\n  total_cases = r_file.readline()\\n  for case_number in range(1, int(total_cases) + 1):\\n      values = map(int, r_file.readline().split(' '))\\n      solve_case(values[0], values[1], values[2], case_number)\\n  \\n", "target": "54", "substitutes": {"no_mine": ["no_roy", "yes_gray", " no_roy", "nojmine", "no___mie", "nolygray", " Nojmire", "notgrade", " no_gray", "no___mark", " no_grade", "noovote", "NO_graduate", "nolyminute", "no2gray", " no_return", "noomark", "no_mark", "no_bird", "no_bench", "no_cal", "no_mie", "no2mine", "no_mire", "yes_mine", "No_mie", "NO_issue", "no_return", "no_meet", "notroy", " No_mix", "nolybench", "no2bird", " no_date", "no_issue", " Nojissue", " no_mark", "no__mate", " No_mine", "no___mine", "n___mie", "n___mate", " No_issue", "no___mate", "No_mate", " no_bench", " no_cal", "notmix", "no_mate", "no___cal", "no_graduate", "noomate", "noftymine", "no_vote", "NO_mine", " No_mire", "NO_download", "noftydownload", "yes_bird", "nolymine", " no_minute", " Nojmix", "nojissue", "no_grade", "n_meet", "notmine", "No_mark", "noftyissue", "n_mine", " no_mate", "no___date", "n___mine", "no_minute", "nojmire", "no_download", "no_mix", " no_mix", "no__mine", "no__meet", "noftygraduate", "no2mate", " no_vote", "noomine", "n___meet", " Nojmine", "n_mie", "no___meet", "no__mie", "No_mine", "no_gray", "n_mate", "yes_mate", "nojmix", "no_date"], "r": ["hr", "rest", "range", "s", "result", "rr", "cr", "rt", "dr", "u", "y", "w", "t", "f", "g", "err", "n", "ru", "l", "nr", "rd", "h", "sr", "e", "rs", "k", "re", "ran", "q", "b", "ro", "br", "ra", "ar", "pr", "rec", "R", "rc", "j", "rh", "res", "mr", "v", "ry", "er", "rw", "lr", "max", "right", "error", "fr", "run", "p", "d", "rar", "vr", "a", "rb", "rows", "i", "rx"], "c": ["cs", "s", "conf", "cr", "cp", "cont", "uc", "ch", "cf", "ic", "u", "y", "t", "cv", "f", "g", "cin", "n", "l", "com", "cl", "C", "h", "ac", "ec", "con", "e", "mc", "k", "dc", "lc", "co", "b", "fc", "cur", "bc", "cos", "ce", "rc", "cache", "sc", "cor", "v", "cat", "cum", "cu", "x", "ca", "cb", "col", "cm", "cd", "ct", "p", "d", "ci", "tc", "cc"], "printed_c": [" printed_cn", "encrypted_cache", "printed_cn", "printedtowncation", "printed_p", "printed_cv", "printedMemcn", " printed_cs", "encrypted_ci", "printedplecache", "brokenipcv", "printed_ci", " Printed_c", "printedurecache", "encrypted_c", "encrypted_cv", " printed_e", "printedeffgc", "broken_cn", "printed_cs", "successfulIlc", "printedMemnc", "printedplecv", "printededcn", "printedurec", " Printed_p", "printedipgc", "printedpleci", "printedeffc", "printedolyc", "successful_nc", "printedIc", "printedtowne", " printed_dc", "printed_gc", "printedureci", "printedeffcv", "successful_c", "broken_cv", " Printed_dc", "printed_lc", "printededc", "printedurecv", "printed_cation", "successfulInc", "successfulIc", "printedolydc", "brokenipcn", "successful_cn", "printedplec", "broken_c", "printedInc", "printedMemlc", "printedipcn", "printedipcv", "printed_e", "printedolya", "printedede", "printedtowndc", "printedIcn", "printed_a", "printed_cache", "successful_lc", "printed_nc", "printedeffcn", "printed_dc", "printedipc", "successfulIcn", "printededcs", "printedIlc", "brokenipc", " Printed_a", "printedtownc", "printedolyp", " printed_cation", "broken_gc", "printedMemc", "brokenipgc"], "row": ["range", "adr", "cr", "month", "collection", "w", "pair", "tr", "week", "word", "rect", "rot", "cell", "order", "ocr", "user", "rank", "record", "table", "board", "our", "group", "entry", "co", "ro", "batch", "block", "arrow", "Row", "number", "year", "rc", "frame", "ry", "ox", "x", "rown", "ow", "page", "roll", "family", "right", "char", "col", "run", "p", "rows", "round", "day", "box", "name", "hour"], "line": ["range", "zone", "message", "string", "ner", "file", "do", "ine", "note", "cli", "stack", "lane", "word", "inline", "band", "phrase", "stay", "profile", "l", "site", "lin", "lined", "detail", "shell", "lines", "lock", "query", "user", "nl", "iter", "auto", "call", "entry", "co", "group", "ne", "time", "liner", "block", "no", "path", "email", "term", "pr", "se", "space", "cho", "frame", "chain", "net", "Line", "force", "device", "print", "out", "list", "ln", "code", "link", "page", "trace", "dd", "limit", "LINE", "part", "le", "lo", "record", "log", "cle"], "column": ["collection", "tr", "csv", "word", "current", "header", "cell", "condition", "pattern", "width", "Column", "member", "con", "car", "dimension", "table", "client", "group", "category", "pointer", "arrow", "path", "property", "number", "variable", "widget", "umn", "field", "character", "attribute", "paragraph", "container", "rown", "char", "col", "period", "method", "cut", "ct", "rain", "day", "section", "name", "component", "label", "forward", "td"], "no_mine_row": ["no_mine__col", "no_mine_word", "no_mix_cell", "no_mineistcolumn", "no_forge_column", "no_forge_roll", "no_mine_item", "no_mix_ro", "no_forge_item", "no_mine_cell", "no_mineistnumber", "no_mineistrow", "no_mine__word", "no_mix_row", "no_forge_rows", "no_mine_rows", "no_mine_ro", "no_mine__rows", "no_mine__row", "no_forge_row", "no_mineistroll", "no_mine_col", "no_min_col", "no_mine_number", "no_min_row", "no_forge_number", "no_forge_col", "no_mix_column", "no_mine_roll", "no_min_word", "no_min_rows"], "no_mine_column": ["no_mine_pointer", "no_mate_col", "no_minetcolumn", "no_grade_number", "no_forge_column", "no_mate_row", "no_mine67pointer", "no_mine_cell", "no_grade_cell", "no_minetlabel", "w", "no_mine_double", "no_such_cell", "no_minetcol", "no_such_column", "no_mate_pointer", "no_grade_column", "chart", "no_forge_row", "no_mine67row", "no_mine67col", "no_such_row", "no_such_col", "no_mine_col", "no_mine_label", "no_mine_number", "no_forge_cell", "no_grade_double", "no_forge_field", "no_forge_col", "no_forge_label", "no_minetcell", "no_mine67column", "no_mine_field", "no_mate_column"], "rest_no_mine_for_row": ["rest_no_mine_for__column", "rest_no_mine_for_rows", "rest_no_mine_forxcell", "rest_no_mine_forxrow", "rest_no_mine_for__rows", "rest_no_mine_for_col", "rest_no_mine_for__row", "rest_no_mine_forxcol", "rest_no_mine_forxrows", "rest_no_mine_for_cell", "rest_no_mine_for__cell"], "rest_no_mine_for_column": ["rest_no_mine_for___col", "rest_no_mine_for___character", "rest_no_mine_for__column", "rest_no_mine_for__col", "rest_no_mine_for_col", "rest_no_mine_for__Column", "rest_no_mine_for_value", "rest_no_mine_for__character", "rest_no_mine_for___Column", "rest_no_mine_for___column", "rest_no_mine_for_character", "rest_no_mine_for_Column", "rest_no_mine_for___row"], "m": ["month", "ch", "t", "f", "g", "case", "n", "M", "l", "mask", "mat", "rm", "tm", "mt", "mc", "mm", "re", "man", "mu", "q", "um", "b", "im", "perm", "j", "mi", "mut", "min", "mr", "v", "x", "dm", "mon", "gm", "cm", "p", "d", "mate", "h", "i"], "case_number": ["case2address", "case9number", "case_Number", "Case_number", "case_size", " case_size", "case_no", "case2Number", "case___size", "case9size", "case9span", "case9no", "Case_address", " case_span", "Case_Number", "case___no", "case___span", "case_span", "case___number", " case_no", "case2number", "case_address"], "no_mine_row_max": ["no_mine_row_mod", "no_mine_row_MAX", "no_mine_col_min", "no_mine_col_ax", "no_mine_row_ax", "no_mine_col_MAX", "no_mine_col_mod", "no_mine_row_min", "no_mine_col_max"], "rest_no_mine": ["rest_No_mate", "rest_no___mate", "rest_no__mate", "rest_no_mate", "rest_no___mine", "rest_no_fine", "rest_no_mie", "rest_No_mie", "rest_no___fine", "rest_No_mine", "rest_No_fine", "rest_no__mine", "rest_no__fine", "rest_no__mie", "rest_no___mie"]}}
{"code": "t = int(raw_input())\\n  \\n  for case in range(t):\\n  \\n  \tc, f, x = raw_input().split()\\n  \tc = float(c)\\n  \tf = float(f)\\n  \tx = float(x)\\n  \\n  \tt = 0\\n  \tcps = 2.0\\n  \twhile c/cps < x/cps and t+x/cps > t+c/cps + x/(cps+f):\\n  \t\tt += c/cps\\n  \t\tcps += f\\n  \\n  \tt += x/cps\\n  \\n  \tprint 'Case #'+str(case+1)+':', t\\n", "target": "55", "substitutes": {"t": ["s", "title", "int", "tree", "to", "ta", "y", "u", "w", "new", "at", "g", "m", "n", "it", "l", "total", "index", "text", "z", "tm", "tp", "e", "set", "qt", "tmp", "pt", "q", "r", "vt", "tf", "gt", "time", "tt", "b", "tu", "T", "o", "ert", "temp", "j", "v", "ts", "te", "out", "trace", "ent", "dt", "p", "d", "ct", "a", "all", "tc", "wt", "i", "ot", "td"], "case": ["choice", "de", "catch", "pe", "mode", "pair", "cases", "condition", "site", "test", "set", "sequence", "example", "client", "CE", "time", "context", "se", "ce", "cycle", "ASE", "chain", "cor", "ase", "one", "trial", "use", "race", "ice", "code", "cas", "ci", "ace", " Case", "cation", "tc", "TC", "Case"], "c": ["cs", "cr", "abc", "cp", "tc", "cont", "uc", "ch", "cf", "u", "ic", "w", "g", "cin", "n", "l", "C", "ac", "z", "ec", "con", "mc", "k", "r", "dc", "lc", "co", "vc", "b", "fc", "cur", "unc", "cos", "ce", "rc", "cache", "sc", "v", "cu", "code", "cb", "cd", "ci", "p", "ct", "a", "d", "h", "xc", "etc", "i", "nc", "cc"], "f": ["fed", "of", "file", "y", "u", "cf", "g", "m", "n", "l", "sf", "ft", "float", "fx", "fs", "bf", "z", "ac", "full", "fb", "e", "k", "fl", "r", "q", "tf", "b", "fc", "fa", "fo", "o", "fg", "xf", "uf", "alf", "rf", "j", "fi", "v", "F", "ex", "fd", "fr", "df", "p", "d", "fp", "h", "fm", "i"], "x": ["mx", "ax", "y", "u", "ic", "xs", "w", "xt", "xe", "g", "xml", "xi", "n", "l", "ix", "xa", "fx", "z", "e", "xy", "rx", "r", "b", "fc", "px", "o", "xf", "X", "j", "xx", "wx", "v", "xxxx", "ox", "ex", "p", "ux", "ci", "a", "h", "xc", "i", "tx"], "cps": ["pcps", "dcvs", "mcpp", "lcpse", " cpu", "lcales", "cupp", "mcamps", "ctpu", "csps", "vpp", "hpp", "camps", "gcpr", "Camps", " cbps", "cuamps", "cpse", "cobps", "Cpp", "cales", "pcts", "gcpp", " cpse", "lcamps", "pcaps", " credits", "coeps", "csgs", "prs", "ppp", "pps", "hps", "lcpu", "pcpse", " cts", " cvs", "dcpp", "cvs", "lcress", "veps", "lcps", "pcvs", "cpp", "crs", "vrs", "peps", "mcpr", "cress", "lcbps", "lceps", "csales", "ceps", "credits", "cpu", "lcaps", "Caps", "ctps", "cops", "gcps", "lcpp", "pcrs", "pcpp", "pcredits", " cress", "cups", "coamps", "vps", "cts", " cpp", "Cps", " camps", " cgs", " ceps", "hrs", "ctpp", "mcps", "dcps", " caps", "cpr", "pcgs", "heps", "caps", "cupr", "gcamps", "ctress", "pcales", " cales", "cbps", "lcts", "csredits", "cgs", "dcrs", " crs"]}}
{"code": "t = int(raw_input())\\n  \\n  for case in range(t):\\n  \tprint 'Case #'+str(case+1)+':'\\n  \tr, c, m = raw_input().split()\\n  \tr = int(r)\\n  \tc = int(c)\\n  \tm = int(m)\\n  \\n  \tif m==0:\\n  \t\tprint 'c' + ('.'*(c-1))\\n  \t\tfor i in range(r-1):\\n  \t\t\tprint '.'*c\\n  \telif r == 1:\\n  \t\tprint 'c'+('.'*(c-m-1))+('*'*(m))\\n  \telif c == 1:\\n  \t\tprint 'c'\\n  \t\tfor i in range(r-m-1):\\n  \t\t\tprint '.'\\n  \t\tfor i in range(m):\\n  \t\t\tprint '*'\\n  \telif r == 2:\\n  \t\tif m%2==0 and c>2 and m<r*c-2:\\n  \t\t\tprint 'c'+('.'*(c-m/2-1))+('*'*(m/2))\\n  \t\t\tprint ('.'*(c-m/2))+('*'*(m/2))\\n  \t\telif m == r*c - 1:\\n  \t\t\tprint 'c'+('*'*(c-1))\\n  \t\t\tprint '*'*c\\n  \t\telse:\\n  \t\t\tprint 'Impossible'\\n  \telif c == 2:\\n  \t\tif m%2==0 and r>2 and m<r*c-2:\\n  \t\t\tprint 'c.'\\n  \t\t\tfor i in range(r-m/2-1):\\n  \t\t\t\tprint '..'\\n  \t\t\tfor i in range(m/2):\\n  \t\t\t\tprint '**'\\n  \t\telif m == r*c - 1:\\n  \t\t\tprint 'c*'\\n  \t\t\tfor i in range(r-1):\\n  \t\t\t\tprint '**'\\n  \t\telse:\\n  \t\t\tprint 'Impossible'\\n  \telif c == 3 and r == 3:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\telif m == 6:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 7:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c**'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \telif c == 3 and r == 4:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 5:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 9:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c**'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \telif c == 3 and r == 5:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 8:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 12:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c**'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \telif c == 4 and r == 3:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\telif m == 5:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\telif m == 7:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c***'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \telif c == 4 and r == 4:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '..**'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 11:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 15:\\n  \t\t\tprint 'c***'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \telif c == 4 and r == 5:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 15:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 16:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 17:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 18:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 19:\\n  \t\t\tprint 'c***'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \telif c == 5 and r == 3:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '...**'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '..***'\\n  \t\telif m == 8:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \telif c == 5 and r == 4:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '..***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 15:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 16:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 17:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 18:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 19:\\n  \t\t\tprint 'c****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \telif c == 5 and r == 5:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '*****'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 13:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 15:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 16:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 17:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 18:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 19:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 20:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 21:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 22:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 23:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 24:\\n  \t\t\tprint 'c****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \telse:\\n  \t\tprint 'Impossible'\\n  \\n", "target": "55", "substitutes": {"t": ["s", "rt", "ta", "ties", "y", "tr", "f", "g", "at", "n", "l", "z", "tm", "e", "q", "tt", "b", "T", "o", "j", "v", "ts", "te", "trial", "dt", "type", "p", "d", "ct", "a", "tc", "ot"], "case": ["rial", "choice", "tc", "core", "hyp", "catch", "pe", "mode", "ind", "cases", "test", "switch", "set", "sequence", "co", "change", "rule", "se", "ce", "ASE", "chain", "cor", "ase", "one", "trial", "race", "ice", "code", "cas", "ste", "me", "ci", "ace", "cation", "name", "ion", "Case"], "r": ["range", "s", "adr", "rr", "rt", "cr", "dr", "ch", "y", "u", "w", "f", "g", "n", "ru", "it", "l", "nr", "attr", "rd", "z", "rm", "sr", "e", "rs", "re", "ir", "q", "rb", "b", "ro", "br", "ra", "o", "ar", "kr", "rec", "R", "ter", "rc", "j", "mr", "v", "reg", "ry", "x", "an", "er", "pc", "vr", "p", "d", "rar", "a", "rg", "h", "run"], "c": ["cs", "s", "cr", "cp", "tc", "uc", "ch", "y", "cf", "ic", "u", "w", "f", "cin", "g", "n", "l", "com", "cl", "C", "ac", "z", "con", "arc", "mc", "e", "k", "re", "q", "dc", "lc", "co", "b", "o", "cur", "bc", "unc", "ar", "cos", "ter", "ce", "rc", "cache", "sc", "v", "cat", "cum", "cu", "x", "er", "an", "ca", "pc", "cb", "cm", "p", "d", "ct", "ci", "a", "h", "cut", "cc"], "m": ["s", "sm", "mo", "om", "g", "it", "l", "mt", "q", "mem", "b", "ar", "pm", "perm", "j", "mut", "v", "me", "a", "ma", "nm", "em", "span", "z", "mc", "e", "term", "ter", "min", "md", "an", "dm", "gm", "p", "h", "mk", "f", "n", "M", "tm", "rm", "mu", "module", "rem", "o", "am", "no", "mi", "mr", "d", "med", "max", "bm", "ms", "ch", "y", "mat", "mm", "re", "man", "arm", "um", "im", "mom", "x", "er", "cm", "fm", "vm"], "i": ["ki", "ti", "int", "iy", "ini", "ic", "cli", "pi", "li", "ie", "it", "l", "il", "iri", "e", "ili", "itime", "zi", "iu", "ij", "ir", "ai", "im", "o", "ri", "si", "mi", "fi", "ati", "ia", "ib", "di", "gi", "ii", "ip", "ig", "adi", "\u0438", "ci", "p", "iti", "ei", "oi"]}}
{"code": "def CASE(IN):\\n      def rstr(): return IN.readline().strip()\\n      def rint(): return int(rstr())\\n      def rints(): return map(int, rstr().split())\\n      def rfs(): return map(float, rstr().split())\\n      c, f, x = rfs()\\n      b = 2.0\\n      if x <= c:\\n          return x/b\\n      t = 0\\n      while True:\\n          tf = x/(b+f) + c/b\\n          tn = x/b\\n          if tn <= tf:\\n              return t + tn\\n          t += c/b\\n          b += f\\n  \\n  \\n  def RUN(IN, OUT):\\n      t = int(IN.readline().strip())\\n      for i in xrange(1,t+1):\\n          OUT.write(\"Case #%i: %.7f\\n\" % (i, CASE(IN)))\\n  \\n  if __name__ == \"__main__\":\\n      RUN(sys.stdin, sys.stdout)\\n", "target": "56", "substitutes": {"IN": ["NULL", "INE", "ID", "GEN", "UID", "LOC", "RE", "ML", "OU", "NAME", "STDOUT", "AL", "Input", "READ", "CL", "ST", "EX", "IND", "DIR", "RAW", "INS", "MN", "INT", "IL", "RL", "FIL", "BL", "EN", "ON", "inner", "R", "Out", "HEAD", "SOURCE", "LIN", "TH", "PIN", "out", "IR", "AN", "FLAG", "VALUE", "DATA", "IT", "MX", "URL", "MM", "LL", "FILE", "UL", "TEXT", "In", "DERR", "LINE", "ILL", "STR", "ALL", "INC"], "c": ["cs", "cp", "ch", "y", "u", "cf", "w", "g", "m", "n", "l", "C", "z", "e", "k", "r", "lc", "co", "fc", "v", "xc", "cu", "ca", "cb", "ci", "d", "ct", "a", "p", "h", "tc", "cc"], "f": ["u", "cf", "y", "g", "m", "l", "ft", "fx", "fs", "bf", "z", "fb", "fe", "e", "r", "fc", "fa", "fo", "fg", "xf", "rf", "fi", "ff", "v", "F", "fd", "fr", "df", "p", "d", "a", "fp", "h", "fm"], "x": ["int", "y", "u", "ic", "w", "xs", "xt", "xe", "g", "m", "xi", "n", "l", "ix", "xa", "z", "e", "xy", "rx", "r", "co", "xf", "X", "xx", "dx", "v", "ox", "out", "cf", "ex", "p", "ct", "a", "h", "xc", "tx"], "b": ["wb", "nb", "s", "bt", "ob", "pb", "to", "gb", "y", "u", "bo", "w", "st", "g", "m", "base", "bb", "n", "l", "B", "bf", "h", "bi", "z", "fb", "ab", "db", "e", "k", "r", "ref", "br", "bc", "bin", "j", "bs", "v", "ib", "out", "sb", "ba", "cb", "tab", "p", "d", "a", "bg", "rb", "be"], "t": ["rt", "to", "ta", "ty", "y", "tz", "w", "at", "tr", "m", "g", "n", "it", "l", "total", "z", "tm", "tp", "e", "pt", "r", "gt", "time", "tt", "tu", "T", "o", "j", "nt", "v", "ts", "te", "out", " T", "dt", "type", "p", "d", "a", "h", "tc", "wt", "ot", "td"], "tf": ["pb", "ty", "tr", "tw", "tv", "FB", "bf", "tm", "TF", "fb", "tp", "vt", "fort", "tt", "tu", "fc", "fa", "tg", "fg", "tl", "uf", "nt", "ts", "te", "fd", "tif", "dt", "fp", "df", "tc", "fm", "tx", "td"], "tn": ["nb", "kt", "rt", "ta", "cf", "tr", "st", "btn", "tw", "n", "bb", "l", "attr", "bf", "txt", "ont", "tm", "fb", "tp", "tmp", "fl", "nn", "gt", "bj", "tt", "fc", "unc", "tg", "fg", "tl", "uf", "j", "nt", "bs", "sn", "bl", "bn", "fn", "ts", "ctr", "ox", "out", "fd", "cb", "dt", "cn", "tc", "wt", "tx", "ot", "td"], "OUT": ["NULL", "OS", "Writer", "BW", "OU", "NAME", "TN", "STDOUT", "PATH", "O", "ST", "PUT", "AT", "RAW", "DIR", "IO", "USER", "INT", "TABLE", "BL", "GROUP", "RET", "Out", "MIT", "NT", "TH", "ES", "Output", "out", "INAL", "TO", "VER", "IT", "DIS", "US", "FILE", "UL", "TEXT", "DERR", "STR", "OT"], "i": ["s", "ti", "int", "ini", "y", "u", "ind", "li", "m", "pi", "xi", "n", "ix", "index", "z", "bi", "k", "zi", "id", "ij", "q", "ai", "I", "si", "j", "mi", "qi", "di", "gi", "yi", "ii", "p", "d", "name", "ei", "oi"]}}
{"code": "def get_a(r, c, f='.'):\\n      A = []\\n      for i in xrange(r):\\n          A.append([f] * c)\\n      return A\\n  \\n  \\n  def apply(A, r, c, B):\\n      for i, b in enumerate(B):\\n          for j, v in enumerate(b):\\n              A[r + i][c + j] = v\\n  \\n  \\n  def draw(A):\\n      if A is None:\\n          return '\\nImpossible'\\n      res = ['']\\n      for a in A:\\n          res.append(''.join(a))\\n      return '\\n'.join(res)\\n  \\n  \\n  def trans(A):\\n      if not A:\\n          return None\\n      B = get_a(len(A[0]), len(A))\\n      for i, a in enumerate(A):\\n          for j, v in enumerate(a):\\n              B[j][i] = v\\n      return B\\n  \\n  \\n  def check(A, m, r, c):\\n      if A is None:\\n          return True\\n      cnts = {'c': 0, '*': 0, '.': 0}\\n  \\n      assert len(A) == r\\n      for i in xrange(r):\\n          assert len(A[i]) == c\\n          for j in xrange(c):\\n              cnts[A[i][j]] += 1\\n      assert cnts['*'] == m\\n      assert cnts['c'] == 1\\n      assert cnts['.'] == r * c - m - 1\\n  \\n  \\n  def CASE(IN):\\n      def rstr():\\n          return IN.readline().strip()\\n  \\n      def rint():\\n          return int(rstr())\\n  \\n      def rints():\\n          return map(int, rstr().split())\\n      r, c, m = rints()\\n      A = solve(m, r, c)\\n      if A:\\n          A[-1][-1] = 'c'\\n      check(A, m, r, c)\\n      return draw(A)\\n  \\n  \\n  def solve(m, r, c):\\n      if r > c:\\n          return trans(solve(m, c, r))\\n      assert r <= c\\n      assert m != r * c\\n      e = r * c - m\\n      if e == 1:\\n          A = get_a(r, c, '*')\\n          return A\\n      if r == 1:\\n          A = get_a(1, c, '.')\\n          for i in xrange(m):\\n              A[0][i] = '*'\\n          return A\\n      if r == 2:\\n          if e == 2 or e % 2 == 1:\\n              return None\\n          A = get_a(2, c, '.')\\n          assert m % 2 == 0\\n          for i in xrange(m / 2):\\n              A[0][i] = A[1][i] = '*'\\n          return A\\n      assert r >= 3\\n      A = get_a(r, c, '*')\\n      if e in (2, 3, 5, 7):\\n          return None\\n      E = [c] * (e / c) + ([e % c] if e % c else [])\\n      if sum(E) < e:\\n          E.append(e % c)\\n          assert sum(E) == e\\n      if len(E) == 1:\\n          E = [e / 2] * 2\\n          if sum(E) < e:\\n              e.append(1)\\n      if E[0] != E[1]:\\n          s = sum(E[:2])\\n          E[0] = E[1] = s / 2\\n          if sum(E[:2]) != s:\\n              assert len(E) == 2\\n              E.append(1)\\n      if E[-1] == 1:\\n          if len(E) > 3:\\n              E[-2] -= 1\\n              E[-1] += 1\\n          else:\\n              E[0] -= 1\\n              E[1] -= 1\\n              E[2] += 2\\n      for i in xrange(len(E)):\\n          for j in xrange(E[i]):\\n              A[-i - 1][-j - 1] = '.'\\n      return A\\n  \\n  \\n  def RUN(IN, OUT):\\n      t = int(IN.readline().strip())\\n      for i in xrange(1, t + 1):\\n          OUT.write(\"Case #%i: %s\\n\" % (i, CASE(IN)))\\n  \\n  if __name__ == \"__main__\":\\n      RUN(sys.stdin, sys.stdout)\\n", "target": "56", "substitutes": {"r": ["range", "rr", "rt", "cr", "dr", "u", "w", "tr", "g", "err", "n", "it", "ru", "l", "nr", "attr", "rd", "z", "sr", "rs", "re", "ir", "q", "rb", "ro", "br", "ra", "ar", "o", "ri", "R", "rc", "mr", "x", "er", "lr", "p", "d", "rar", "rg", "h"], "c": ["cs", "cr", "cp", "uc", "ch", "u", "cf", "y", "w", "ic", "cin", "g", "n", "l", "com", "C", "gc", "ac", "z", "con", "ec", "mc", "k", "q", "dc", "co", "lc", "fc", "o", "ar", "cur", "cos", "ce", "rc", "sc", "cat", "cu", "x", "ca", "cb", "col", "cm", "ci", "d", "ct", "p", "h", "tc", "cc"], "f": ["ef", "cf", "u", "w", "fac", "g", "n", "l", "sf", "ft", "float", "fb", "k", "fl", "q", "fab", "tf", "fm", "fc", "fa", "o", "fg", "rf", "fi", "ff", "F", "p", "d", "fp", "h", "fun"], "A": ["V", "ACT", "G", "W", "of", "AL", "Y", "AF", "SA", "App", "only", "C", "GA", "What", "_", "K", "Ax", "HA", "CA", "U", "Z", "Bar", "just", "AM", "If", "cont", "RAM", "Not", "N", "Al", "Am", "RA", "call", "The", "Array", "AP", "Ab", "I", "AU", "S", "Some", "Ag", "F", "AR", "At", "Abs", "form", "This", "func", "Answer", "Art", "BA", "AA", "As", "new", "M", "Ar", "D", "LA", "AS", "AB", "H", "And", "You", "ref", "Av", "JA", "An", "Q", "AE", "New", "One", "AC", "P", "J", "NA", "O", "AT", "AV", "AI", "T", "obj", "R", "X", "L", "AN", "Res", "All", "Alpha", "all", "MA", "void"], "i": ["ki", "ti", "int", "ini", "ic", "u", "y", "pi", "li", "ie", "xi", "g", "it", "n", "l", "z", "bi", "k", "zi", "id", "ij", "hi", "iu", "ir", "q", "ai", "phi", "im", "ar", "o", "ri", "I", "si", "mi", "x", "ia", "ib", "di", "ik", "gi", "ip", "ii", "ci", "p", "ji", "h", "ei"], "B": ["V", "G", "BI", "W", "P", "Bern", "WB", "NB", "J", "BA", "TB", "Bs", "Bo", "RB", "Y", "BF", "BS", "N", "O", "M", "DB", "C", "BB", "D", "IB", "CB", "AB", "H", "BR", "EB", "BE", "Bu", "Array", "T", "Ab", "BM", "I", "R", "BO", "SB", "S", "BC", "L", "F", "U", "Be", "Br", "Z", "Bar"], "b": ["ch", "u", "y", "w", "g", "bb", "n", "l", "bi", "z", "ab", "db", "rb", "br", "o", "ar", "bc", "bs", "bl", "ba", "p", "d", "h", "be"], "j": ["ja", "cr", "J", "jj", "ch", "y", "u", "li", "g", "n", "kj", "it", "l", "aj", "z", "bi", "js", "jp", "dj", "k", "ij", "q", "bj", "br", "o", "obj", "pr", "x", "fr", "uj", "p", "ji", "d", "h"], "v": ["V", "av", "value", "sv", "u", "y", "w", "g", "n", "l", "ev", "z", "vert", "ve", "uv", "vt", "q", "vc", "iv", "var", "br", "o", "vi", "vs", "ver", "bl", "qv", "val", "p", "h"], "res": ["os", "RS", "result", "rest", "gr", "ms", "arr", "inv", "us", "ac", "rs", "re", "resp", "q", "reset", "pres", "rem", "ro", "ps", "ra", "ress", "results", "na", "rel", "R", "pas", "ret", "reg", "ras", "str", "er", "out", "Res", "RES", "rez", "p", "ins", "err", "rev", "rys"], "a": ["av", "ja", "ea", "ata", "y", "u", "w", "ama", "at", "al", "ana", "n", "ach", "l", "xa", "ga", "aj", "h", "area", "ac", "z", "ab", "aa", "re", "sha", "ai", "reset", " ra", "\u00e4", "fa", "ar", "am", "o", "ap", "na", "action", "sa", "ae", "aq", "ao", "an", "x", "ak", "er", "ca", "ba", "pa", "va", "au", "p", "la", "all", "ara", "aw", "d", "oa", "ei", "apa"], "m": ["sm", "ms", "y", "u", "w", "ma", "g", "n", "M", "l", "z", "rm", "mt", "tm", "mc", "k", "mm", "re", "q", "co", "um", "im", "o", "am", "ar", "perm", "mi", "mr", "an", "x", "er", "fr", "gm", "cm", "p", "d", "h"], "cnts": ["cNTps", "cctls", " cptps", "cCounts", "cntjs", "dcnts", "countps", "ccountjs", "cptxs", "csnts", "csntps", " counts", " cptentials", "ccounts", "csntS", "crypts", "crents", "ccountps", "cctds", "cCountns", "cntxs", "ccountentials", "dcntns", "countjs", "cNTs", "counts", "cptS", "csNTs", "csNTS", "csNTps", "cryptps", " cpts", "cntds", "cptps", "cntps", "cpts", "cryptjs", "conts", " cntds", "cNTxs", "dcNTs", "cntns", "cCountxs", " cntjs", "crentps", " countjs", "cntls", "cryptentials", "csntls", "contds", "contls", "dcNTxs", "cntS", " cntls", " cptds", "csNTls", " countps", "cptls", "ccts", "cNTS", "cNTls", "cNTjs", "cntentials", " cntentials", "dcntxs", " cntps", "dcntS", " cptls", "cctps", "cptns", "dcNTS", "contps", "cNTns", "cCountS", "dcNTns", "cctS", " cptjs", "cptds", "cptjs", "cptentials", "crentjs"], "IN": ["INE", "ML", "IC", "ER", "OU", "Input", "READ", "OM", "ST", "EX", "IND", "RAW", "INS", "MN", "USER", "INT", "IL", "BL", "EN", "inner", "R", "Out", "HEAD", "SOURCE", "LIN", "IR", "PIN", "AN", "DATA", "LINE", "FILE", "UL", "TEXT", "In", "DERR", "STR"], "e": ["eu", "ate", "ue", "y", "pe", "u", "g", "it", "n", "l", "en", "z", "ec", "re", "o", "es", "se", "ce", "oe", "ae", "x", "er", "me", "type", "p", " ie", "eff", "ee", "d", "err", "ei"]}}
{"code": "\\n  \\n  filename = \"B-small-attempt0.in\"\\n  \\n  inp = open(filename, \"rU\")\\n  \\n  n = int(inp.readline().strip())\\n  \\n  for case in range(1, n + 1):\\n      cost, freq, goal = map(float, inp.readline().strip().split(\" \"))\\n      fac = 0.0\\n      time = 0.0\\n      test = lambda x: (goal/(2+(freq * (x + 1)))) + (cost /(2+(freq * x)))\\n      test2 = lambda x: (goal/(2+(freq * x)))\\n      while(test2(fac) > test(fac)):\\n          time += cost/(2 + (freq *  fac))\\n          fac += 1\\n      time += goal/(2+(freq*fac))\\n      print(\"Case #{}: {}\".format(case, time))\\n", "target": "57", "substitutes": {"filename": ["nm", "title", "kl", "mson", "unction", "erguson", "there", "file", "bestos", "endix", "Filename", "f", "udder", "orus", "fil", "alse", "sbm", "kj", "println", "mpeg", "File", "txt", "itled", "nants", "fle", "PDATE", "phy", "fn", "SourceFile", "prefix", "FN", "upload", "directory", "ln", "username", "ename", "FILE", "fp", "emis", "save"], "inp": ["outp", "inf", "innp", " inP", " Inq", "inline", " inf", "innf", "outsp", " insp", "inP", " InP", "insg", "inq", " inq", " inline", "Inpm", "Inline", "innsp", " inl", "InP", "insp", "Inp", "insl", "outl", "ing", "inpm", " Inpm", " inpm", " Inp", "Insp", "innline", "Inf", "outg", "inl", " ing", "inssp", "Inq"], "n": ["nb", "s", "nd", "nu", "np", "len", "t", "f", "m", "mn", "N", "nr", "l", "c", "non", "ns", "k", "nl", "ne", "b", "no", "number", "na", "nt", "sn", "count", "v", "x", "num", "gn", "cn", "p", "d", "name", "i", "nc"], "case": ["hyp", "catch", "y", "pe", "size", "zip", "condition", "index", "c", " cx", "name", "nce", "set", "example", "client", "co", " c", " num", "number", "ce", "X", "line", "cycle", " line", "chain", "comb", "count", "ase", "ox", "trial", "race", "ice", "num", "ex", "cas", "code", "p", "ace", "xc", "instance", "i", "Case"], "cost": ["length", "duration", "cmd", "gain", "cal", "size", "work", "f", "fee", "dev", "width", "total", "com", "grade", "spread", "gross", "charge", "risk", "util", "runtime", "co", "mem", "loss", "go", "make", "progress", "Cost", "amount", "wall", "profit", "grad", "force", "x", "max", "weight", "wage", "end", "sum", "limit", "scale", "stop", "score", "func"], "freq": ["frce", " FREqs", "genreqi", "freqi", "renqi", "frequencyqi", "frj", "permq", "Frej", "Frecl", "frece", "faj", "fej", "freqt", "frequencyj", " FREq", "Freq", "frej", "Frez", "frxt", "frez", "dimj", "dimq", "fext", "genrecler", "frv", " FREqi", "FreQ", " freqi", "freqs", "permj", " FREcler", "face", "renQ", "feq", "fecler", "frq", "frequencyqt", "frequencyq", "frex", "faq", "genreqs", "renq", "fav", "frequencycl", "Frev", "Frece", "Frext", "feqs", "frecler", "fez", "permqt", "freQ", "dimx", "feqi", "frz", "frequencyx", "Freqt", "Frex", "dimqi", "genreq", "frecl", "frext", "Freqi", "frev", " freQ", "permcl"], "goal": ["duration", "data", "result", "gen", "gain", "cal", "size", "gem", "history", "dev", "stay", "width", "total", "grade", "beta", "window", "game", "general", "gam", "team", "session", "mem", "loss", "go", " goals", "zero", "change", "path", "home", "wall", "out", "den", "success", "num", "wage", "hat", "scale", "limit", "log", "end", "all", "chance", "gap", "factor", "final", "Goal", "wait", "also"], "fac": ["half", "lif", "result", "gain", "auc", "Fac", "cf", "cert", "bu", "mult", "pac", "cv", "f", "fam", "g", "lam", "cap", "fx", "mask", "ac", "gam", "z", "util", "aff", "mu", "sav", "prof", "vol", "sit", "func", "acc", "fc", "cur", "term", "perm", "uf", "temp", "j", "frac", "mut", "ver", "ff", "percent", "cum", "x", "prop", "quant", "act", "conv", "alpha", "pl", "weight", "fr", "char", "scale", "sum", "fat", "eff", "factor", "gu", "fan"], "time": ["timer", "duration", "length", "value", "message", "times", "Time", "timeout", "ms", "size", "frequency", "work", "date", "t", "ime", "rate", "offset", "total", "memory", "step", "tm", "runtime", "TIME", "mem", "tt", "go", "path", "term", "point", "start", "temp", "ver", "ts", "now", "out", "weight", "speed", "trace", "tim", "mean", "delay", "end", "tc", "wait", "form"], "test": ["Test", "match", "loop", "est", "prime", "t", "f", "rate", "train", "step", "pred", "util", "tmp", "check", "user", "iter", "store", "get", "zero", "tt", "ter", "tested", "temp", "ver", "split", "fill", "x", "prop", "use", "cmp", "fit", "filter", "scale", "val", "p", "testing", "fun", "trip", "save"], "test2": ["check2", "prime4", "Test2", "prime3", "Test3", " test4", " test3", "Test02", "test1", "prime1", "test4", "check3", " test02", " test1", "prime2", "check1", "test3", "test02", "Test1", "Test4", "check02"]}}
{"code": "\\n  def check_bounds(state, coord):\\n      if coord[0] < 0 or coord[1] < 0:\\n          return False\\n      elif coord[0] > (len(state) - 1):\\n          return False\\n      elif coord[1] > (len(state[coord[0]]) - 1):\\n          return False\\n      else:\\n          return True\\n  \\n  def clear(state, coord):\\n      for r in range(-1,2):\\n          for c in range(-1,2):\\n              row = coord[0] + r\\n              col = coord[1] + c\\n              if check_bounds(state, (row, col)):\\n                  state[row][col] = 0\\n  \\n  def count(state):\\n      return sum([sum(x) for x in state])\\n  \\n  def state_print(state):\\n      print(\"c\" + \"\".join([\"*\"  if x else \".\" for x in state[0][1:]]))\\n      for line in state[1:]:\\n          print(\"\".join([\"*\"  if x else \".\" for x in line]))\\n  \\n  def solve(state, mines):\\n      prev_state = deepcopy(state)\\n      for row in range(len(state)):\\n          for col in range(len(state[row])):\\n              new_state = deepcopy(state)\\n              clear(new_state, (row, col))\\n              c = count(new_state)\\n              if(c < mines):\\n                  state = prev_state\\n              elif( c == mines):\\n                  state_print(new_state)\\n                  return True\\n              else:\\n                  if col == len(state[row]) -2:\\n                      prev_state = deepcopy(state)\\n                  state = new_state\\n      print(\"Impossible\")\\n      return False\\n  \\n  \\n  \\n  \\n  def main():\\n      filename = \"C-small-attempt0.in\"\\n  \\n  \\n      inp = open(filename, \"rU\")\\n  \\n      n = int(inp.readline().strip())\\n  \\n      for case in range(1, n + 1):\\n          R, C, M = map(int, inp.readline().strip().split(\" \"))\\n          state = [[1 for x in range(C)] for y in range(R)]\\n          print(\"Case #{}:\".format(case))\\n          solve(state, M)\\n  \\n  main()\\n", "target": "57", "substitutes": {"state": ["tag", "power", "clear", "cal", "conn", "note", "spec", "t", "it", "cell", "scope", "order", "area", "loc", "store", "table", "co", "mem", "start", "frame", "output", "reg", "force", "now", "debug", "run", "type", "instance", "log", "range", "loop", "core", "there", "st", "history", "rect", "step", "index", "color", "buffer", "db", "iter", "event", "call", "progress", "change", "rule", "trust", "dict", "close", "print", "out", "list", "State", "position", "un", "p", "ace", "name", "post", "form", "length", "sample", "zone", "stat", "that", "al", "m", "base", "resource", "plot", "this", "status", "map", "body", "go", "point", "back", "hash", "self", "action", "topic", "trace", "open", "next", "pos", "data", "result", "value", "seed", "size", "stats", "port", "public", "null", "STATE", "target", "memory", "test", "remote", "init", "runner", "local", "set", "unit", "re", "config", "sequence", "update", "version", "draw", "trans", "block", "policy", "see", "states", "space", "cache", "info", "cycle", "story", "count", "er", "commit", "code", "node", "all", "item", "component", "queue"], "coord": ["tag", "result", "cmd", "cp", "cal", "form", "address", "ch", "work", "pair", "date", "req", "nc", "word", "url", "rect", "location", "cell", "resource", "com", "ordinate", "index", "lat", "dim", "mat", "con", "cart", "loc", "xy", "addr", "local", "store", "grid", "aff", "tmp", "iter", "call", "dc", "co", "orig", "func", "block", "cur", "point", "obj", "request", "pixel", "cache", "ver", "comb", "align", "cor", "cat", "deg", "cum", "prop", "tile", "num", "mon", "position", "trace", "mate", "p", "ord", "cation", "pos", "inter", "Co", "ctrl", "dat"], "r": ["range", "s", "rr", "rt", "cr", "w", "pair", "t", "f", "m", "g", "l", "nr", "rd", "rm", "e", "rs", "re", "q", "co", "ref", "br", "ro", "ar", "rc", "j", "res", "v", "reg", "right", "fr", "run", "p", "d", "h", "i", "rx"], "c": ["cs", "s", "conf", "cr", "cp", "abc", "tc", "cont", "ch", "cf", "u", "w", "t", "cv", "f", "m", "cin", "g", "l", "com", "can", "capacity", "gc", "ac", "z", "con", "e", "const", "q", "dc", "co", "lc", "b", "cur", "unc", "cos", "ce", "rc", "j", "cache", "count", "v", "cat", "cum", "cu", "cy", "ca", "cut", "cm", "ci", "ct", "p", "cd", "h", "xc", "d", "cn", "i", "nc", "cc"], "row": ["range", "post", "set", "ob", "rt", "month", "ows", "dr", "rid", "th", "bo", "w", "tr", "week", "rect", "rot", "cell", "key", "index", "order", "con", "name", "loc", "e", "rs", "user", "rank", "re", "column", "ser", "iter", "our", "board", "co", "var", "br", "ro", "Row", "ra", "cur", "arrow", "block", "sw", "mod", "rc", "j", "frame", "res", "ry", "ox", "race", "coll", "num", "rown", "ow", "roll", "run", "rows", "round", "box", "pos", "record", "form", "bar"], "col": ["ell", "chron", "cmd", "cp", "cal", "ol", "ch", "cf", "port", "th", "rot", "cell", "offset", "key", "cl", "con", "loc", "xy", "icol", "column", "pt", "client", "co", " Col", "var", "br", "fc", "cur", "left", "point", "sect", "cos", "cond", "pr", "nt", "cycle", "min", "cor", "count", "ctr", "cat", "ox", "cul", "top", "cy", "act", "coll", "num", "mon", "pc", "roll", "child", "Col", "tab", "p", "ct", "yl", "cut", "char", "pos", "COL", "nc"], "x": ["s", "mx", "ax", "ic", "xs", "w", "xt", "t", "xe", "f", "on", "xml", "xd", "yx", "xi", "xp", "l", "ix", "xa", "qu", "fx", "lat", "h", "z", "xy", "e", "check", "_", "xb", "q", "xes", "co", "px", "xf", "rax", "X", "rox", "xx", "dx", "wx", "v", "cat", "ox", "act", "ex", "inx", "ctx", "yl", "d", "ct", "tx", "p", "ux", "xc", "rit", "ci", "i", "rx"], "line": ["range", "ner", "ine", "w", "cell", "l", "text", "lin", "lines", "con", "write", "e", "nl", "iter", "q", "el", "co", "ne", "change", "draw", "liner", "block", "point", "ce", "j", "cycle", "chain", "cross", "v", "cat", "Line", "fill", "ox", "cy", "ln", "code", "ex", "run", "next", "val", "pos", "lo", "nc"], "mines": ["minies", "Minces", " minees", "Minions", "minseds", "gences", "genes", "MINes", "mineds", "mindists", "mindes", "minions", "verses", "Minees", "minees", "mindeds", "minists", "MINeds", "versions", "minces", "mindES", "versES", "Minies", "minsists", "MinES", "minsies", " minces", "MINists", " minions", "minsES", "genees", "minES", "MINES", "minses", "genions", "versies", "Mines", "minsions"], "prev_state": ["new_val", "prevxState", "prev_states", "prevxval", "prev_stat", "prevedState", "req_config", "req_State", "prev_user", "pre_state", "prev_State", "req_state", "req_states", "prev_config", "prevedval", "prevedstat", "new_stat", "prevxuser", "pre_State", "pre_val", "prev_val", "new_State", "prevxstate", "prevedstate", "pre_user"], "new_state": ["new____state", "new_test", "newptstate", "new2sample", "single_state", "new_instance", "old2state", "old_start", "old2start", "old2sample", "newptinstance", "new2state", "newptstart", "var_test", "new_row", "new____row", " new_State", "new_start", " new_val", "newlymemory", "single_zone", "new____test", "single____state", "single____stat", "new____State", "old_sample", "newlystart", "newlystate", "old_instance", "newptsample", "var_mem", "new_zone", "new_val", " new_memory", "single____zone", "newlyinstance", "newlysample", "new_stat", "new____mem", "new_statement", "new_State", "new2instance", "newlyval", "newlyState", " new_statement", "old2instance", "new_sample", "single_stat", "new_mem", "var_state", "new2start", "single_State", "old_state", "new_memory", "new____stat", "new____zone", "single____State", "var_row"], "filename": ["nm", "title", "pai", "mson", "kl", "whatever", "file", "Filename", "network", "udder", "fil", "f", "sbm", "mpeg", "lua", "txt", "bite", "knife", "fle", "files", "path", "til", "phy", "pak", "wine", "description", "fn", "SourceFile", "journal", "FN", "directory", "WHAT", "upload", "username", "wav", "ename", "FILE", "fp", "name", "png"], "inp": ["outp", "inf", "interctx", "interp", " inm", " inctx", "outsp", "inctx", " inf", " insp", "winlike", "INp", "INsp", "outf", "inq", "erlike", "erpr", "inm", "winp", "erp", "insp", "winpr", "interf", "Inp", " inlike", "INq", "erm", "intersp", "INf", "outq", "inlike", "inpr", "Insp", "winm", "Inf", " inpr", "Inctx", "Inq"], "n": ["nb", "nu", "np", "w", "t", "network", "m", "N", "l", "nr", "nor", "mn", "en", "z", "ns", "nl", "nn", "ne", "o", "no", "number", "na", "nt", " N", "sn", "count", "net", "num", "p", "name", "i", "nc"], "case": ["cp", "core", "size", "catch", "pe", "mode", "cases", "li", "condition", "key", "switch", "test", "rand", "set", "nce", "example", "co", "number", "se", "ce", "cycle", "ASE", "chain", "count", "ase", "cor", "trial", "race", "use", "code", "cas", "me", "cd", "p", "ace", "cation", "name", "instance", "i", "Case"], "R": ["V", "RS", "G", "P", "J", "Y", "N", "B", "MR", "D", "H", "K", "RA", "Row", "T", "RM", "A", "I", "RO", "X", "E", "S", "RR", "NR", "L", "U", "CR", "Res", "Q", "Co"], "C": ["V", "CS", "G", "W", "P", "CO", "Y", "N", "O", "B", "CM", "D", "Ch", "Cs", "H", "K", "T", "CU", "A", "Cl", "I", "X", "E", "CP", "S", "L", "U", "F", "CR", "Co"], "M": ["V", "G", "W", "P", "MT", "J", "Y", "m", "N", "O", "Mc", "MC", "B", "CM", "MR", "JM", "MN", "D", "H", "Ms", "MI", "RM", "T", "A", "I", "E", "S", "L", "F", "U", "Q", "MM"], "y": ["my", "ay", "yu", "ch", "w", "oy", "Y", "m", "yd", "z", "yn", "xy", "yy", "b", "o", "ey", "j", "cycle", "yr", "ry", "cy", "yi", "ym", "d", "h", "yl"]}}
{"code": "\\n  BASE_RATE = 2.0\\n  \\n  def process_case(C, F, X):\\n      rate = BASE_RATE\\n      total_time = 0.0\\n      while True:        \\n          xtime = X / rate\\n          ctime = C / rate\\n          ext_rate = rate + F\\n          ext_time = ctime + (X / ext_rate)\\n          if xtime <= ext_time:\\n              total_time += xtime\\n              break\\n          total_time += ctime\\n          rate = ext_rate\\n      return total_time\\n  \\n  def result_gen(lines):\\n      ncases = int(next(lines))\\n      for ci in range(1,ncases+1):\\n          C, F, X = line_of_floats(next(lines))\\n          result = process_case(C, F, X)\\n          yield 'Case #{0}: {1:.7f}\\n'.format(ci, result)\\n  \\n  def line_of_floats(s):\\n      return [float(sub) for sub in s.split()]\\n  \\n  def input_gen(f_in):\\n      for line in f_in:\\n          if line.endswith('\\n'):\\n              line = line[:-1]\\n          yield line\\n  \\n  def start(basename):\\n      infile = basename + '.in'\\n      outfile = basename + '.out'\\n      f_in = open(infile, 'r')\\n      f_out = open(outfile, 'w')\\n      f_out.writelines(result_gen(input_gen(f_in)))\\n      f_in.close()\\n      f_out.close()\\n  \\n  start('B-small-attempt0')\\n", "target": "58", "substitutes": {"BASE_RATE": ["BASE_RANGE", "BASE_ORATES", "BASE_ERAT", "BASE_WATING", "BASE_WATE", "BASE_DATING", "BASE_CRAT", "BASE_CRATE", "BASE_ERANGE", "BASE_RATING", "BASE_ORANGE", "BASE_DATE", "BASE_ERATE", "BASE_CRATING", "BASE_WATES", "BASE_DATES", "BASE_RAT", "BASE_DANGE", "BASE_ERATES", "BASE_RATES", "BASE_ORATE", "BASE_ORAT", "BASE_CRATES", "BASE_DAT", "BASE_WAT"], "C": ["V", "CS", "G", "CI", "P", "Chain", "CNN", "CC", "CO", "Cod", "Y", "CG", "N", "O", "CL", "FC", "M", "MC", "B", "c", "CM", "D", "CF", "CB", "Cs", "Ch", "H", "CE", "JC", "CT", "CU", "Cl", "DC", "T", "A", "I", "R", "E", "CP", "CA", "NC", "S", "L", "U", "CR", "CW", "Con", "Co", "Case"], "F": ["V", "G", "W", "P", "FT", "Time", "J", "FR", "FS", "FER", "Y", "f", "AF", "Fs", "N", "M", "FC", "O", "FI", "B", "TF", "D", "CF", "Factory", "FL", "FD", "Ch", "IF", "H", "DF", "The", "T", "A", "UF", "I", "R", "Fe", "E", "FO", "S", "FG", "U", "L", "Rate", "Q", "SF", "PF", "FF", "FA", "If", "FE"], "X": ["V", "Tx", "W", "P", "ML", "IC", "Time", "J", "TX", "CC", "Y", "N", "O", "FC", "EX", "Xi", "D", "CF", "XL", "H", "CE", "IX", "XX", "T", "Cross", "DX", "I", "R", "E", "S", "U", "x", "L", "ICE", "IR", "UX", "XP", "Q", "XT", "OX", "FF", "Z", "ZX", "XXX", "Ex", "FE"], "rate": ["range", "sample", "fed", "power", "rates", "ate", "cr", "rice", "core", "timeout", "frequency", "mode", "prime", "date", "tail", "fee", "case", "tone", "base", "phrase", "late", "capacity", "rat", "test", "write", "fine", "factor", "unit", "rew", "rank", "re", "ride", "r", "state", "time", "change", "zero", "rule", "term", "cycle", "count", "currency", "process", "ase", "age", "force", "transfer", "Rate", "te", "erate", "race", "code", "command", "lr", "error", "speed", "scale", "delay", "mate", "type", "exp", " factor", "transform", "forward"], "total_time": [" total_memory", "total_error", "total_memory", "total_Time", " total_Time", " total_rate", "totalTimeerror", "Total_time", "total_times", "Total_length", "totalTimerate", "Total_times", "totalTimetime", "totalTimeTime", "total_rate", "total_length", "Total_Time", "Total_rate", " total_error"], "xtime": ["ctIME", "xtetime", "ximes", "xtIME", "ixtime", "mintetime", "xIME", "extim", "ctim", "ixture", "mintimer", "extime", "xttime", "xtimer", "mintime", "xtim", "ctimes", "minture", "extetime", "xture", "ixtimer", "ctetime", "exttime", "cttime", "ctimer", "extimes", "cture", "mintim", "extIME", "ixtetime", "xtimes", "xime", "minttime"], "ctime": ["xtetime", "ttimet", "ttimer", "centetime", "ftimer", "utime", "contimet", "utetime", "fttime", "conttime", "contime", "centimet", "centimer", "contetime", "xttime", "ftimet", "xtimer", "utimer", "uptimet", "centime", "upttime", "ctetime", "ftime", "tttime", "utimet", "cttime", "ctimer", "ttime", "uptetime", "uptime", "ctimet", "xtimet"], "ext_rate": ["xt_type", "xt_Rate", "extRatrate", "ext_rat", "ext2rate", "xt_rate", "Ext_time", "Ext_range", "ext_mode", "ext2rule", "Ext_rate", "xt_mode", "ext_range", "xt_rates", "extRatrat", "extRattype", "Ext_rule", "ext_type", "ext2range", "ext_rates", "ext_rule", "ext2time", "ext_Rate", "xt_rat"], "ext_time": ["Ext_Time", "ext_speed", "exttimetime", "exttimespeed", "exttimerate", "external_Time", "Ext_time", "external_speed", "Ext_rate", "external_time", "external_rate", "ext_Time", "exttimeTime"], "lines": ["cs", "lets", "times", "blocks", "cells", "ds", "ms", "cycles", "xs", "nets", "steps", "cases", "l", "its", "fs", "items", "runs", "ns", "rs", "ls", "ges", "files", "gs", "posts", "ses", "words", "results", "states", "vs", "parts", "elines", "frames", "grades", "works", "values", "lins", "ines", "codes", "rows", "reads", "ins", "pages", "boxes", "points"], "ncases": ["ntase", "naps", "ncaps", "nsaps", "nsase", "nicodes", "nASE", "cnASE", "nsASE", "ntases", "ncaces", "cnase", "nase", "nicase", "cnases", "nsases", "naces", "nicaces", "nodes", "nases", "cnaps", "ncodes", "ntodes", "ncase", "ncASE", "nicases", "ntaces"], "ci": ["ki", "ti", "cia", "CI", "cr", "ini", "ic", "ico", "cf", "pi", "li", "cin", "case", "multi", "cell", "c", "zi", "ni", "co", "ai", "lc", "uci", "sci", "bc", "si", "ce", "mi", "info", "cor", "cod", "cu", "trial", "gi", "ca", "code", "cas", "ii", "cm", "ct", "nic", "tc", "i", "nc"], "result": ["data", "value", "Result", "match", "cont", "pair", "f", "case", "com", "text", "correct", "test", "status", "response", "re", "ful", "r", "su", "cur", "results", "ret", "ver", "res", "report", "output", "cor", "description", "comb", "answer", "x", "out", "success", "next", "mate", "p", "final", "record"], "s": ["os", "ans", "sts", "ds", "ties", "ms", "sections", "ys", "xs", "ns", "rs", "sq", "ls", "ss", "gs", "b", "ps", "ats", "ses", "es", "se", "ments", "parts", "S", "sels", "ts", "sl", "ples", "ws", "sb", "ches", "strings", "p", "ines", "ins", "sets"], "sub": ["seq", "second", "subject", "slice", "sed", "item", "Sub", "new", "sp", "st", "du", "case", "super", "sam", "sat", "sing", "set", "ser", "sq", "su", "obj", "se", "si", "space", "sur", "sc", "sel", "side", "str", "sl", "sup", "ub", "sb", "so", "sim", "un", "sum", "desc", "section", "name", "string", "src"], "f_in": ["f_con", "h_out", "f2in", "f__din", "f_ins", "f_IN", "h_in", "f__in", " f_din", "f__inc", " f_con", "f2con", "f_ini", "f_inc", "fockin", " f_ins", "h_ini", " f_IN", "fockout", "f__IN", "f2out", "f2ins", "fockinc", "f__out", "f__ins", "h_input", "f_din", "fockIN", " f_inc", "f_input"], "line": ["range", "sample", "loop", "file", "slice", "ine", "pe", "pair", "lay", "handle", "li", "case", "inline", "word", "base", "header", "cell", "l", "single", "lin", "lined", "none", " inline", "write", "set", "body", "nl", "iter", "column", "sequence", "entry", "change", "ne", "liner", "block", "path", "point", "se", "field", "edge", "frame", "eline", "Line", "fill", "str", "out", " Line", "ln", "list", "link", "lo", "node", "error", "page", "char", "row", "end", "next", "LINE", "name", "string"], "basename": [" basage", "baseno", "basenum", "lifame", "baseeno", "basage", "lifename", "baseness", "lifenum", "lifage", "zoneness", "baseename", "baseeness", "Basename", "namage", "zoneno", "zonername", "namenum", "baseername", "Basername", "zonename", " baseness", "namername", "Basame", " basenum", "nameno", "namame", " baseno", " basername", " basame", "namename", "basame", "basername", "Baseno"], "infile": ["outname", "outpath", "outfilename", "Inpath", "Inname", "outfiles", "cinfile", "Infile", "infiles", " inpath", "infilename", " infilename", " inname", "inname", "cinpath", " infiles", "cinfilename", "cinname", "inpath", "Infiles"], "outfile": ["outname", "inFile", "Outname", "outfilename", "nullname", "outputname", "infilename", "outputfilename", "offfile", "outputFile", "outputfile", "offfilename", "offname", "OutFile", "Outfilename", "nullfile", "Outfile", "inname", "outout", "nullfilename", "outFile", "inout", "nullout", "offout"], "f_out": ["f__o", "bufferJconn", "f_r", "f8opt", "buffer_opt", "e_in", "bufferJopt", "f_o", "e_out", "buffer_file", "f__in", "f_conn", "f_crit", "f_end", "bufferJfile", "f___conn", "f8out", "e_o", "f_opt", "buffer_out", " f_crit", "fJopt", "f___opt", "f8file", "f_file", "fJconn", "f__end", "fJfile", "f___out", "f8conn", "buffer_conn", "f__out", "f___file", "fJout", " f_r", "e_end", "bufferJout"]}}
{"code": "\\n  def mines_refill(board, xr, xc, nfree):\\n      to_refill = xr*xc - nfree\\n      for r in reversed(range(2, xr)):\\n          for c in reversed(range(2, xc)):\\n              if not to_refill:\\n                  return\\n              assert(board[r][c] == '.')\\n              board[r][c] = '*'\\n              to_refill -= 1\\n      for r in reversed(range(xr)):\\n          for c in reversed(range(xc)):\\n              if not to_refill:\\n                  return\\n              if board[r][c] == '.':\\n                  board[r][c] = '*'\\n                  to_refill -= 1\\n      assert(to_refill == 0)\\n      \\n  def generate_board(nrows, ncols, nmines):\\n      nfree = nrows*ncols - nmines\\n      xr=1; xc=1;\\n      while True:\\n          if xr*xc >= nfree:\\n              break\\n          if xr < nrows:\\n              xr += 1\\n          if xr*xc >= nfree:\\n              break\\n          if xc < ncols:\\n              xc += 1\\n      board = [['*' for c in range(ncols)] for r in range(nrows)]\\n      for r in range(xr):\\n          for c in range(xc):\\n              board[r][c] = '.'\\n      mines_refill(board, xr, xc, nfree)\\n      board[0][0] = 'c'\\n      return board\\n          \\n  def find_click_point(board):\\n      nrows = len(board)\\n      ncols = len(board[0])\\n      for r in range(nrows):\\n          for c in range(ncols):\\n              if board[r][c] == 'c':\\n                  return (r,c)\\n      raise ValueError('Start point not present')\\n  \\n  def enum_neighbour_coords(r0, c0, nrows, ncols):\\n      for r in range(r0-1, r0+2):\\n          if r<0 or r>=nrows:\\n              continue\\n          for c in range(c0-1, c0+2):\\n              if c<0 or c>=ncols:\\n                  continue\\n              yield (r,c)\\n  \\n  def click_board(board, click_coords):\\n      nrows = len(board)\\n      ncols = len(board[0])\\n      points = [click_coords]\\n      while points:\\n          r0,c0 = points.pop()\\n          mines_cnt = 0\\n          for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\\n              if board[r][c] == '*':\\n                  mines_cnt += 1\\n          board[r0][c0] = str(mines_cnt)\\n          if not mines_cnt:\\n              for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\\n                  if board[r][c] == '.':\\n                      points.append((r,c))\\n  \\n  def all_fields_checked(board):\\n      nrows = len(board)\\n      ncols = len(board[0])\\n      for r in range(nrows):\\n          for c in range(ncols):\\n              if board[r][c] == '.':\\n                  return False\\n      return True\\n  \\n  def is_board_oneclick(original_board):\\n      board = [row[:] for row in original_board] # deep copy\\n      assert(board[0][0] == 'c')\\n      r,c = find_click_point(board)\\n      click_board(board, (r,c))\\n      is_oneclick = all_fields_checked(board)\\n      return is_oneclick\\n  \\n  def board2result(board):\\n      return [''.join(row) for row in board]\\n  \\n  def process_case(nrows, ncols, nmines):\\n      board = generate_board(nrows, ncols, nmines)\\n      if is_board_oneclick(board):\\n          result = board2result(board)\\n      else:\\n          result = ['Impossible']\\n      return result\\n  \\n  def result_gen(lines):\\n      ncases = int(next(lines))\\n      for ci in range(1,ncases+1):\\n          R, C, M = line_of_numbers(next(lines))\\n          result = process_case(R, C, M)\\n          yield 'Case #{0}:\\n'.format(ci, result)\\n          for res_line in result:\\n              yield res_line + '\\n'\\n      \\n  def line_of_numbers(s):\\n      return [int(sub) for sub in s.split()]\\n  \\n  def input_gen(f_in):\\n      for line in f_in:\\n          if line.endswith('\\n'):\\n              line = line[:-1]\\n          yield line\\n  \\n  def start(basename):\\n      infile = basename + '.in'\\n      outfile = basename + '.out'\\n      f_in = open(infile, 'r')\\n      f_out = open(outfile, 'w')\\n      f_out.writelines(result_gen(input_gen(f_in)))\\n      f_in.close()\\n      f_out.close()\\n  \\n  start('C-small-attempt0')\\n", "target": "58", "substitutes": {"board": ["poll", "lib", "du", "case", "cell", "full", "uno", "black", "check", "table", "bird", "co", "b", "fc", "ward", "rc", "frame", "cross", "bit", "hold", "bug", "paste", "bar", "range", "builder", "book", "loop", "core", "comment", "database", "rect", "design", "buffer", "bro", "clean", "oard", "stream", "dict", "style", "out", "list", "command", "stroke", "form", "bot", "message", "ard", "bo", "chart", "word", "flo", "body", "bank", "review", "ro", "video", "back", "private", "sc", "che", "library", "league", "box", "layout", "data", "buff", "Board", "front", "public", "pair", "boards", "rot", "pad", "channel", "test", "runner", "user", "lock", "local", "rol", "rank", "system", "bang", "sequence", "plate", "control", "bd", "block", "inner", "line", "ui", "chain", "player", "ack", "boarding", "boot", "deck", "node", "mate", "void", "component"], "xr": ["oxer", "Xrs", "oxar", "qrt", "fxrs", "uxmr", "oxbr", "xvr", "uxr", "xxr", "exor", " xbr", "xrs", "wxer", "fxre", "uxh", "ixrt", "mxr", "xer", " xn", "wxrb", " Xr", " xer", "qrs", "uxer", "qR", "xtr", " Xvr", "oxr", "fxer", "xh", "ixr", "fxR", "exbr", "xre", "wxr", "xxrd", "wxh", " xrd", "mxrb", "rxr", "xdr", "xor", "exdr", " xrt", " xor", " xR", "exr", "xn", "ixrd", "wxor", "wxrd", "uxsr", "xxrt", " xh", "fxrt", "ixrs", "fxr", "xmr", " xrs", "mxR", "qr", " xdr", "wxar", " Xrs", "rxrs", " xrb", "oxrb", "ixvr", "fxar", "oxrt", "oxre", "oxdr", "rxrd", "xrd", "xrt", "wxre", "Xrd", "oxn", "uxor", "xxrb", "oxsr", "oxrs", "xR", "oxmr", "Xr", "mxrs", " xvr", "rxR", "xrb", "xar", "oxrd", "xtsr", "uxrb", "xbr", "oxR", "xtrb", "ixn", "xsr", "XR", "xtmr", "oxor", "Xrb", "ixrb", "wxrt"], "xc": ["xon", "mx", "ffff", "cp", "cox", "abc", "cow", "uc", "cf", "xs", "xe", "xd", "nc", "cin", "nz", "yx", "sec", "xp", "wic", "xa", "oc", "gc", "ac", "tm", "ec", "con", "ape", "xy", "mc", "xb", "jc", "xes", "co", "vc", "lc", "dc", "phi", "xff", "fc", "cone", "px", "unc", "bc", "xf", "ce", "rc", "wx", "xxxx", "ox", "cum", "x", "colm", "cmp", "pc", "conv", "ex", "lic", "cb", "ctx", "cd", "ci", "exp", "ct", "tc", "etc", "wt", "coe"], "nfree": ["jfree", " nused", "nsfree", "dnfine", "nsFree", " noccupied", " nbytes", "ntfree", "numfree", "dnfree", "nanfree", "nbytes", "nused", "Nused", "numleft", "dnavailable", "ntFree", "javailable", "Nfine", "jfine", "noccupied", "ntotal", "nfine", "nsleft", "nanFree", "dnFree", "numFree", " nleft", " ntotal", "Nbytes", "onFree", "numavailable", "Nright", " nFree", "nanoccupied", "Ntotal", "onused", "nFree", "nleft", "navailable", "Noccupied", "Navailable", "onfree", " navailable", "nantotal", "NFree", " nright", " nfine", "nright", "nsavailable", "onbytes", "jFree", "Nfree", "ntright"], "to_refill": ["to_filling", "to_refrill", "to_rebillin", "to_rebil", "to_reill", "to_rebill", "to_reresh", "to_referenceill", "to_repill", "to_referenceILL", "to_rebILL", "to_referencerill", "to_rebille", "to_Refillin", "to_defill", "to_frresh", "to_rotiller", "to_refillin", "to_rebilling", "to_reshresh", "to_Refill", "to_relil", "to_rebrill", "to_Refiller", "to_reshill", "to_rebresh", "to_referenceresh", "to_referenceild", "to_Refresh", "to_relresh", "to_filler", "to_relill", "to_Refilling", "to_reiller", "to_refilling", "to_frill", "to_fresh", "to_rotill", "to_rebiller", "to_frILL", "to_refil", "to_repil", "to_defilling", "to_reshild", "to_reshrill", "to_defresh", "to_refiller", "to_fill", "to_rotillin", "to_rotresh", "to_relille", "to_reilling", "to_refild", "to_defiller", "to_refille", "to_repille", "to_represh", "to_refresh", "to_refILL", "to_frrill", "to_rebild"], "r": ["hr", "u", "arr", "t", "tr", "g", "l", "attr", "rd", "rn", "rs", "root", "k", "q", "ir", "b", "ar", "rc", "j", "v", "reg", "right", "rar", "a", "bar", "range", "adr", "dr", "w", "rect", "e", "kr", "pr", "res", "usr", "rw", "p", "err", "h", "rr", "f", "m", "ru", "n", "rad", "nr", "sr", "ro", "ur", "o", "mr", "ry", "fr", "vr", "d", "rg", "rb", "i", "result", "rt", "cr", "gr", "re", "var", "br", "R", "rel", "str", "x", "er"], "c": ["s", "u", "t", "g", "cell", "l", "cl", "C", "loc", "co", "b", "fc", "ar", "bc", "cos", "ce", "rc", "v", "cut", "type", "cd", "ct", "tc", "nc", "cp", "uc", "w", "cin", "ac", "z", "mc", "e", "const", "\u00e7", "vc", "cur", "cod", "ca", "cb", "p", "name", "div", "f", "m", "n", "usc", "can", "arc", "dc", "sc", "cat", "cul", "coll", "col", "ci", "d", "i", "cs", "cr", "ic", "gc", "con", "ec", "lc", "unc", "cache", "chain", "count", "cu", "x", "pc", "code", "cm", "cc"], "nrows": ["ontimes", "onrows", " nviews", " nows", "tows", "xows", "nows", " nruns", "nrow", "lruns", "nrs", "orows", "lows", "onrs", "trow", "srow", "Nrow", "xrows", "xfree", "stimes", "lrs", "onrow", " nrow", "onows", "Nrs", "truns", "sruns", "Nrows", "onruns", "ntimes", "lrows", "sows", "orow", "srows", "oows", " nrs", "Nviews", "nviews", " ntimes", "Nruns", "lrow", "Nows", "trows", "xrow", "nruns", "Nfree", "oviews"], "ncols": ["nwidthums", "Ncolumni", " ncolts", "nColi", "Ncolds", "Ncols", "nlogs", "onColS", "Ncoles", "Ncolumnds", "nColss", "ndirabs", "oncols", "ncolts", "onColums", "nwidths", "oncolums", "nCols", "oncolves", "oncolumnabs", "ncolumnours", "nconds", "ncolS", "ncolumnabs", " ncolums", "ncolves", "npathes", " ncolumnS", "ncolumnves", "oncolumnours", "oncolS", "ncolumnts", " npathes", "ncolumnS", " npaths", "onCols", "ncolumnss", "nfles", "ncolumns", "nColS", " nColts", "npaths", "Ncolumns", "Ncolss", "oncolumnves", "nfls", "npathums", " ncolumnes", " nColums", "ncoli", " nCols", "ndirves", "nwidthts", "oncolabs", " ncoles", "ncolours", "Ncolumnes", "nlogves", "nlogabs", "nColes", "oncolours", "npathS", " npathums", "nlogours", "ncloudds", "nColums", "ndirours", "nflss", "ncolumni", "Ncoli", "Ncolums", "Ncolumnss", "ncolumnds", "nflums", "oncolumns", "ncolss", "ncloudi", "ncloudes", "ncolumnes", "ndirs", "ncondes", "ncolums", "ncolabs", "nColts", "ncolumnums", "ncoles", "ncolds", " ncolumns", "Ncolumnums", "nColds", " ncolS", "nclouds"], "nmines": [" nminions", "Nmaxices", "nMinES", "nminES", "Nmines", "Nminions", "Nmaxes", "nMines", "nmaxess", "Nminess", "nminess", "nminions", " nminES", "nmaxions", "Nminices", " nservES", " nserves", "npanions", "nmindices", "nmindions", "npaness", " nservis", "nservis", "nserves", "npanes", "nmaxices", "nservions", " nminis", "nmaxES", "nmaxis", " nservions", "nminis", "nminices", "nmindess", "nmindes", "Nmaxions", "nmaxes", "npanices", "nservES", "Nmaxess", "nMinions", "nMinis"], "r0": ["rcZero", "rr2", "nElement", "rrElement", "rar000", "rank0", "mr5", "rc0", "mr0", "rankZero", "rr0", " rElement", "rootZero", "n00", "n0", "r00", "n2", "rarau", "r5", "rZero", " r2", "rcau", "mrau", "rElement", "rr00", "rau", "mrZero", "root5", "rar0", "r2", "mr000", "rc5", " r00", "root0", "rootau", "r000", "rankau", "rarZero", "rank000"], "c0": ["lc5", "c1", "pcZero", "z00", "l00", "con0", "conZero", "crElement", "cElement", "lc0", "rc0", "l2", "c5", " c1", "lc1", "lZero", "lcZero", "crZero", "rc1", " cElement", "c2", "zZero", "cr1", "z0", " cZero", "con2", "cr0", "c00", "pcElement", "rc5", " c5", "pc1", "con00", "z2", "l0", "cZero", "rcZero", "pc0"]}}
{"code": "f = open('input.in')\\n  g = open('output', 'w')\\n  \\n  T = int(f.readline()[:-1])\\n  \\n  def tot(n) :\\n      if n == 0 : return X / 2\\n      else :\\n          s = 0\\n          for i in range(0, n) : s += C / (2 + i*F)\\n          return s + X / (2 + n*F)\\n  \\n  for case in xrange(T) :\\n      C, F, X = map(float, f.readline()[:-1].split())\\n      N =  int(X/C) + 1\\n      s, e = 0, N\\n      if tot(0) >= tot(1) : \\n          while True :\\n              m = (s+e)/2\\n              if tot(m) <= tot(m-1) and tot(m) <= tot(m+1) : break\\n              elif tot(m-1) <= tot(m) <= tot(m+1) : e = m\\n              elif tot(m-1) >= tot(m) >= tot(m+1) : s = m\\n              else : 1/0\\n      else : m = 0\\n      output = 'Case #' + str(case + 1) + ': ' + str(tot(m))\\n      g.write(output + '\\n')\\n      print output\\n  \\n  f.close()\\n  g.close()\\n", "target": "59", "substitutes": {"f": ["ef", "af", "file", "u", "cf", "input", "w", "t", "ft", "l", "sf", "c", "fs", "bf", "z", "fb", "fl", "r", "tf", "b", "fc", "fo", "o", "fa", "fg", "uf", "v", "x", "fd", "fr", "p", "fp", "h", "fm", "lf"], "g": ["G", "gp", "gen", "gb", "gr", "y", "u", "vg", "w", "t", "pg", "gate", "l", "gio", "ga", "og", "gc", "c", "game", "r", "gt", "group", "gs", "go", "b", "o", "msg", "tg", "fg", "gg", "j", "gd", "mg", "v", "gz", "out", "gi", "ig", "eg", "gm", "p", "d", "bg", "io", "ge", "gu"], "T": ["V", "GT", "G", "P", "J", "Time", "TN", "t", "Y", "M", "O", "B", "D", "TT", "H", "K", "A", "I", "R", "E", "TS", "S", "L", "TH", "Q", "Z"], "n": ["nb", "nu", "y", "w", "t", "l", "nor", "it", "c", "z", "ns", "k", "nn", "ni", "r", "q", "ne", "b", "o", "no", "j", "nt", "sn", "v", "x", "num", "p", "d", "a", "h", "ot"], "s": ["cs", "os", "ions", "times", "ms", "y", "ed", "w", "t", "xs", "sp", "l", "c", "its", "z", "h", "rs", "ns", "ss", "r", "gs", "b", "ats", "o", "es", "sw", "start", "j", "TS", "S", "v", "ts", "x", "p", "d", " S", "a", "ins", "ers"], "i": ["ti", "int", "ini", "ic", "y", "ind", "pi", "li", "t", "xi", "it", "l", "c", "z", "q", "r", "phi", "b", "im", "o", "I", "si", "j", "mi", "v", "x", "ip", "ii", "p", "ci", "a"], "case": ["Test", "CI", "P", "ine", "pe", "mode", "cases", "index", "switch", "test", "Case", "set", "_", "co", "CE", "ne", "no", "A", "number", "I", "se", "ce", "E", "line", "Name", "ASE", "cor", "ase", "U", "L", "x", "one", "trial", "ice", "code", "num", "me", "p", "ace", "name", "ion", "be"], "C": ["V", "CS", "G", "W", "P", "J", "CC", "CO", "Y", "M", "O", "Mc", "B", "c", "CM", "D", "Cs", "H", "K", "CT", "A", "I", "R", "E", "S", "L", "U", "Q", "Z", "TC", "Co", "Case"], "F": ["V", "G", "W", "P", "FT", "J", "GF", "Fs", "Y", "AF", "M", "FC", "O", "B", "TF", "D", "CF", "IF", "H", "DF", "I", "R", "E", "FO", "S", "FG", "L", "U", "Q", "Z", "FF", "FE"], "X": ["V", "Tx", "G", "W", "P", "J", "TX", "TN", "Y", "M", "EX", "D", "H", "K", "IX", "XX", "A", "DX", "I", "R", "E", "S", "L", "x", "U", "TH", "XP", "Q", "XT", " x", "Z", "ZX", "XXX", "Int"], "N": ["Ns", "V", "G", "W", "P", "J", "Y", "Max", "M", "O", "Ni", "Ne", "B", "NS", "D", "Num", "K", "A", "I", "R", "E", "S", "NC", "L", "No", "Q", "NM", "Z"], "e": ["em", "ue", "u", "ed", "w", "t", "xe", "l", "en", "c", "ec", "r", "el", "ne", "b", "o", "es", "se", "j", "E", "oe", "v", "x", "te", "er", "ex", "eg", "end", "p", "d", "ee", "le", "h"], "m": ["sm", "mo", "om", "t", "l", "c", "mt", "k", "mem", "b", "km", "perm", "j", "mut", "v", "hold", "me", "a", "ma", "em", "int", "w", "mn", "z", "mc", "r", "md", "an", "mean", "gm", "p", "h", "mail", "on", "M", "tm", "mac", "body", "mu", "mp", "time", "module", "o", "am", "point", "mod", "mi", "mr", "met", "one", "d", "ms", "y", "mm", "re", "man", "arm", "um", "lem", "x", "er", "cm", "all", "item"], "output": ["result", "figure", "comment", "file", "generated", "four", "input", "new", "network", "current", "ut", "plot", "text", "PUT", "put", "shell", "option", "write", "unit", "response", "ou", "config", "connection", "client", "update", "hidden", "module", "o", "format", "close", "line", "monitor", "answer", "ion", "Output", "print", "out", "you", "command", "position", "pot", "debug", "next", "cut", "exit", "name", "string", "outer", "enum", "display"]}}
{"code": "f = open('input.in')\\n  g = open('output', 'w')\\n  \\n  T = int(f.readline()[:-1])\\n  \\n  for case in xrange(T) :\\n      R, C, M = map(int, f.readline()[:-1].split())\\n      FREE = R*C - M\\n      if FREE == 0 : res = '\\nImpossible'\\n      elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '\\nImpossible'\\n      elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '\\nImpossible'\\n      else :\\n          MAP = [['.' for c in range(C)] for r in range(R)]\\n          MAP[0][0] = 'c'\\n          if R == 1 :\\n              for i in range(C-1, C-M-1, -1) : MAP[0][i] = '*'\\n          elif C == 1 :\\n              for i in range(R-1, R-M-1, -1) : MAP[i][0] = '*'\\n          elif R == 2 :\\n              for i in range(C-1, C-M/2-1, -1) : MAP[0][i], MAP[1][i] = '*', '*'\\n              if FREE == 1 : MAP[1][0] = '*'\\n          elif C == 2 :\\n              for i in range(R-1, R-M/2-1, -1) : MAP[i][0], MAP[i][1] = '*', '*'\\n              if FREE == 1 : MAP[0][1] = '*'\\n          else :\\n              com = M / C\\n              for i in range(R-1, max(R-com-1, 2), -1) :\\n                  MAP[i] = ['*' for j in range(C)]\\n                  M -= C\\n              I = max([i for i, j in enumerate(MAP) if j[0] == '.'])\\n              if I == 2 :\\n                  com = M / 3\\n                  if com == 0 : i = C\\n                  for i in range(C-1, C-com-1, -1) :\\n                      MAP[0][i], MAP[1][i], MAP[2][i] = '*', '*', '*'\\n                      M -= 3\\n                  if M >= 1 : MAP[2][i-1] = '*'\\n                  if M >= 2 :\\n                      if i != 1 : MAP[2][i-2] = '*'\\n                      else : MAP[1][0] = '*'\\n              else :\\n                  for i in range(C-1, C-M-1, -1) : MAP[I][i] = '*'\\n                  if i == 1 :\\n                      MAP[I][i] = '.'\\n                      MAP[I-1][C-1] = '*'\\n          res = '\\n' + '\\n'.join([''.join(i) for i in MAP])\\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\\n      g.write(output + '\\n')\\n      print output\\n  \\n  f.close()\\n  g.close()\\n", "target": "59", "substitutes": {"f": ["file", "input", "w", "t", "sp", "m", "n", "l", "ft", "sf", "fs", "bf", "e", "fl", "q", "tf", "b", "fc", "fa", "o", "fo", "fg", "alf", "v", "F", "x", "fd", "fr", "df", "p", "a", "fp", "h", "fm", "lf"], "g": ["G", "gp", "gen", "gr", "gl", "m", "n", "ga", "gc", "og", "z", "e", "k", "gt", "gs", "go", "gg", " G", "gd", "v", "gz", "ger", "eg", "gm", "d", "h"], "T": ["V", "G", "W", "P", "J", "TN", "t", "Y", "N", "O", "B", "TA", "D", "TT", "TV", "K", "A", "X", "TS", "S", "WT", "L", "F", "TH", "TR", "Q", "TM", "VT", "Z", "TC", "TL"], "case": ["ti", " TM", " IC", " key", "li", " time", "key", "name", "tri", "time", "IX", " ti", "chain", " trial", "cor", "U", " Ti", "trial", "race", "Ti", "ice", "TM", " CI", "type", "ci", "tc", "TC", "Case"], "R": ["V", "RS", "G", "RE", "P", "W", "ER", "J", "Remote", "REM", "RB", "Range", "Y", "Reg", "Re", "RG", "N", "O", "Right", "CL", "B", "CM", "MR", "RF", "GR", "Rs", "D", "RL", "RA", "H", "BR", "RC", "SR", "Resource", "RGB", "RM", "A", "RT", "RO", "PR", "VR", "E", "X", "RI", "S", "RR", "NR", "L", "F", "U", "CR", "IR", "Res", "TR", "Q", "RES", "Cor", "AR", "HR"], "C": ["V", "CS", "G", "W", "RE", "CO", "Y", "CAR", "CG", "CF", "K", "JC", "CT", "E", "CA", "U", "CR", "Craig", "CI", "Container", "CC", "N", "MC", "B", "Car", "CB", "Ch", "CE", "LC", "CU", "RO", "S", "F", "WC", "SC", "COM", "Cond", "CHAR", "CNN", "ERC", "Cod", "RFC", "CL", "D", "Cs", "H", "Cl", "CP", "Cons", "Q", "VC", "AC", "P", "Chain", "IC", "J", "COR", "O", "CM", "CCC", "DC", "Cal", "A", "X", "EC", "BC", "L", "CON", "GC", "Con", "Co"], "M": ["V", "Man", "COM", "G", "MAN", "W", "P", "MT", "RE", "J", "REM", "Men", "Y", "m", "N", "O", "MC", "B", "CM", "MR", "D", "H", "MP", "K", "MI", "IM", "MO", "RM", "A", "RO", "E", "S", "L", "F", "U", "TM", "MS", "AR", "Z", "MA", "VM", "DM", "AM", "Manager"], "FREE": ["V", "CRE", "MED", "RE", "REM", "Y", "EW", "HOW", "READ", "NOTE", "WARNING", "WE", "NEW", "BOX", "FIR", "CBS", "CR", "YOU", "IRE", "ICE", "ER", "N", "MC", "ERROR", "MI", "XXXX", "MORE", "WARN", "F", "RES", "VER", "REE", "RED", "GRE", "COM", "free", "CHAR", "MER", "FR", "VOL", "OR", "ARE", "NUM", "ONE", "KNOWN", "VE", "LE", "Free", "MS", "MAC", "WIN", "NO", "VM", "FE", "NULL", "OUT", "SIZE", "ERE", "STAT", "TIME", "ANY", "AME", "DER", "NR", "CON", "NOR", "TM", "ZE", "NOT", "VALUE", "DIS", "COMPLE", " FRE", "OVER", "USE"], "res": ["rest", "os", "result", "conf", "RE", "gr", "ms", "details", "inv", "req", "yes", "cons", "respons", "rs", "response", "resp", "re", "reset", "pres", "rem", "results", "ret", "report", "chain", "reg", "terms", "out", "Res", "RES", "sol", "rez", "resolution", "rev", "ress"], "MAP": ["LOC", "RE", "OU", "SP", "NOTE", "RESULTS", "JP", "IP", "MN", "WE", "NEW", "APP", "PRES", "UP", "CN", "MEN", "RAM", "BY", "MC", "PUT", "TON", "HE", "MI", "Map", "AP", "MIT", "WARN", "RES", "HTML", "CLAIM", "IT", "MAS", "COM", "WA", "MAN", "SO", "KEY", "SPEC", "MODE", "NUM", "DIR", "BP", "map", "TABLE", "VE", "MAT", "TH", "AMP", "SET", "TO", "MAC", "MG", "TC", "NA", "SIZE", "CAP", "LOAD", "ALE", "FORM", "FIL", "MP", "DC", "BM", "Maps", "CON", "WHAT", "VIEW", "TM", "VALUE", "DATA", "MX", "MAX", "MA", "LOCK"], "c": ["cr", "cp", "tc", "ic", "cf", "t", "cin", "l", "ec", "con", "lc", "co", "b", "cur", "unc", "cat", "cu", "cy", "cm", "cut", "xc", "cc"], "r": ["range", "rr", "cr", "rt", "dr", "m", "n", "rd", "rn", "rm", "car", "re", "ir", "co", "ro", "ar", "ri", "rec", "pr", "rc", "mr", "er", "run", "p", "rar"], "i": ["ini", "cli", "t", "it", "l", "comp", "iri", "q", "ir", "b", "v", "di", "a", "io", "int", "li", "ie", "index", "il", "z", "e", "zi", "iu", "iter", "ii", "\u00ed", "p", "ei", "ki", "uri", "ico", "on", "pi", "m", "xi", "n", "bi", "status", "id", "ai", "phi", "o", "si", "mi", "ati", "ia", "ib", "adi", "\u0438", "ci", "iti", "oi", "ti", "ic", "y", "ix", "key", "init", "ili", "itime", "ij", "im", "ql", "ui", "info", "x", "gi", "ip", "ig", "item"], "com": ["em", "COM", "conf", "cp", "complete", "cal", "COR", "ch", "obi", "om", "m", "comp", "OM", "cl", "cons", "tm", "this", "con", "comm", "re", "pro", "mp", "co", "IM", "time", "ai", "rem", "cre", "im", "bin", "term", "mod", "cond", "Com", "dom", "min", "comb", "cor", "reg", "common", "mom", "cum", "cu", "one", "race", "computer", "num", "ex", "max", "sim", "char", "me", "cm", "Comp", "lim", "ci", "sum", "tc", "rom", "inter"], "j": ["jl", "ja", "J", "jj", "ch", "jas", "li", "m", "n", "kj", "it", "l", "aj", "js", "z", "bi", "jp", "dj", "k", "ij", "jc", "jac", "q", "ni", "jit", "b", "br", "o", "obj", " J", "v", "x", "je", "char", "uj", "p", "ji", "job", "oj"], "I": ["G", "III", "CI", "P", "IC", "J", "Y", "SI", "N", "O", "Xi", "B", "IO", "II", "IJ", "D", "VI", "AI", "MI", "IM", "You", "Is", "PI", "E", "RI", "HI", "Si", "L", "F", "U", "Ti", "DI", "Im", "It", "IT", "NI", "TI"]}}
{"code": "def solve():\\n      c, f, x = map(float, raw_input().split())\\n      ans = 1e40\\n      cur = 0.0\\n      psp = 2.0\\n      while cur < ans + 1e-8:\\n          ans = min(ans, cur + x / psp)\\n          cur += c / psp\\n          psp += f\\n      return ans\\n  for t in xrange(int(raw_input())):\\n      print \"Case #%d: %.7f\" % (t + 1, solve())\\n", "target": "60", "substitutes": {"c": ["cs", "s", "cr", "cp", "u", "cf", "g", "m", "n", "l", "can", "C", "h", "e", "r", "dc", "lc", "co", "b", "fc", "o", "unc", "ce", "v", "cu", "xc", "cb", "cd", "ci", "p", "cm", "ct", "d", "a", "tc", "cc"], "f": ["y", "u", "cf", "w", "m", "g", "fac", "l", "fx", "fs", "bf", "z", "fb", "fe", "e", "q", "r", "tf", "b", "fc", "fa", "o", "fg", "xf", "j", "fi", "ff", "v", "F", "fr", "p", "d", "a", "fp", "df", "i"], "x": ["ax", "y", "xs", "w", "xt", "xe", "xd", "xi", "xp", "n", "l", "ix", "xa", "fx", "z", "fe", "e", "xy", "q", "xes", "fc", "px", "xf", "X", "xx", "v", "ox", "ex", "p", "tx", "a", "xc", "i", "rx"], "ans": ["cs", "s", "os", "ANS", "rates", "amps", "ms", "anas", "aces", "xs", "anc", "aus", "n", "aps", "can", "ates", "cons", "ents", " means", "con", "ks", "ends", "rs", "ns", "ran", "ls", "ai", "co", "gs", "oss", "uns", "ams", "ps", "ats", "ons", "unc", "posts", "es", "vs", "outs", "res", "ts", "oos", "an", "ars", "ants", "arts", "eps", "ann", "gn", "un", "offs", "ens", "ins", "vers", "anes"], "cur": ["cs", "cmd", "cr", "cont", "cp", "div", "cars", "dec", "anc", "new", "cv", "pg", "current", "Cur", "can", "en", "gc", "con", "car", "tmp", " Cur", "ctrl", "const", "ser", "obs", "co", "clean", "go", "um", "ur", "cot", "unc", "ce", "rc", "sur", "sc", "ver", "count", "ctr", "cor", "pre", "cat", "cum", "cu", "now", "old", "pri", "num", "cmp", "col", "sum", "cd", "ctx", "round", "err", "tc", "max", "nc"], "psp": ["tsf", "mspan", "PSpc", "csvp", "pspc", "csp", "tspn", "psf", "epsr", "psvp", "cspa", "PSp", "tsc", "csf", "asc", "fpsc", "alsp", "psr", "psc", "wspn", "aspan", "wsp", "pspn", "msp", "cspn", "PSf", "alsc", "psP", "csP", "alsf", "asp", "epsp", "pspa", "PSvp", "fpsp", "msr", "asr", "alspn", "epspan", "wsP", "asf", "tsp", "asvp", "PSpa", "wspc", "fpspn", "PSpn", "fpsf", "msc", "epsc", "cspc", "aspa", "PSP", "pspan"], "t": ["ti", "s", "ta", "y", "u", "th", "w", "xt", "on", "at", "g", "tw", "m", "n", "ft", "l", "total", "ont", "e", "k", "q", "r", "tt", "b", "T", "o", "ar", "j", "v", "ts", "te", "p", "d", "a", "h", "tc", "i", "ot"]}}
{"code": "def solve():\\n      h, w, m = map(int, raw_input().split())\\n      if h == 1:\\n          print 'c' + '.' * (h * w - m - 1) + '*' * m\\n      elif w == 1:\\n          for c in 'c' + '.' * (h * w - m - 1) + '*' * m:\\n              print c\\n      elif h * w - m == 1:\\n          print 'c' + '*' * (w - 1)\\n          for _ in xrange(h-1):\\n              print '*' * w\\n      else:\\n          m = h * w - m\\n          for i in xrange(h-1):\\n              for j in xrange(w-1):\\n                  t = (i + 2) * 2 + (j + 2) * 2 - 4\\n                  r = (i + 2) * (j + 2)\\n                  if t <= m <= r:\\n                      a = [['*'] * w for _ in xrange(h)]\\n                      for k in xrange(i+2):\\n                          a[k][0] = '.'\\n                          a[k][1] = '.'\\n                      for k in xrange(j+2):\\n                          a[0][k] = '.'\\n                          a[1][k] = '.'\\n                      for y, x in product(range(2, i+2), range(2, j+2)):\\n                          if y == 1 and x == 1:\\n                              continue\\n                          if t >= m:\\n                              break\\n                          a[y][x] = '.'\\n                          t += 1\\n                      a[0][0] = 'c'\\n                      for s in a:\\n                          print ''.join(s)\\n                      return\\n          print 'Impossible'\\n  for t in xrange(int(raw_input())):\\n      print \"Case #%d:\" % (t + 1)\\n      solve()\\n", "target": "60", "substitutes": {"h": ["hr", "hw", "hal", "ch", "th", "ha", "history", "hs", "g", "ho", "http", "n", "he", "high", "sh", "l", "z", "hp", "kh", "hi", "hd", "H", "host", "q", "ph", "hl", "b", "o", "home", "bh", "rh", "ah", "html", "hm", "v", " H", "oh", "ih", "p", "hh", "ht"], "w": ["wb", "hw", "ew", "W", "u", "work", "f", "we", "tw", "g", "word", "wr", "n", "width", "wd", "l", "wm", "kw", "z", "iw", " W", "wat", "q", "wp", "wi", "b", "o", "sw", "wk", "wx", "wal", "v", "wl", "rw", "ws", "wa", "wh", "nw", "p", "d", "aw", "wt", "win"], "m": ["sm", "em", "bm", "ms", "u", "mo", "ma", "f", "g", "mag", "n", "mn", "M", "l", "wm", "mat", "z", "tm", "mt", "rm", "mc", "e", "mm", "man", "mp", "q", "mu", "mem", "b", "o", "mod", "perm", "mi", "mut", "mr", "v", "met", "mean", "gm", "cm", "p", "d"], "c": ["wb", "conf", "cr", "cont", "uc", "ic", "cf", "anc", "f", "etc", "n", "comp", "com", "gc", "C", "ac", "mc", "mac", "e", "dc", "lc", "co", "b", "fc", "unc", "rc", "sc", "cum", "cu", "orc", "ca", "cut", "ci", "cm", "ct", "p", "enc", "tc", "d", "nc", "cc"], "_": ["valid", "int", "match", "W", "on", "f", "g", "place", "____", "py", "get", "q", "ml", "__", "an", "list", "___", "ex", "p", "all", "ation"], "i": ["ki", "ti", "int", "ini", "u", "ic", "ind", "pi", "li", "ie", "xi", "it", "ix", "iri", "bi", "zi", "id", "ij", "iu", "hi", "ir", "ai", "phi", "b", "im", "o", "ri", "I", "si", "mi", "info", "ia", "di", "ik", "yi", "ih", "gi", "ip", "ii", "ci", "io"], "j": ["jl", "json", "ja", "J", "jj", "g", "n", "kj", "it", "l", "key", "aj", "z", "js", "jp", "dj", "ij", "jc", "q", "bj", "b", "br", "o", "obj", "pr", "rel", "v", "jump", "uj", "next", "ji", "d", "oj"], "t": ["title", "ti", "kt", "tree", "ty", "ta", "to", "tn", "let", "th", "tr", "f", "typ", "g", "at", "tw", "st", "n", "it", "ft", "l", "lat", "test", "tm", "mt", "tp", "e", "set", "pt", "vt", "tf", "time", "tt", "tu", "T", "o", "tip", "v", "ts", "te", " T", "tim", "dt", "type", "p", "d", "ct", "tick", "tc", "wt", "ot", "td"], "r": ["range", "rr", "rt", "cr", "u", "g", "n", "l", "nr", "rd", "z", "rm", "sr", "e", "re", "q", "rb", "b", "ro", "kr", "o", "R", "rc", "res", "mr", "v", "p", "d"], "a": ["aaa", "ea", "ta", "ka", "sta", "ata", "att", "at", "f", "g", "ana", "n", "another", "l", "xa", "ga", "ac", "z", "area", "ab", "aa", "e", "aos", "app", "aff", "sha", "ai", "eas", "b", "fa", "am", "A", "o", "ada", "na", "sa", "v", "ae", "ao", "an", "ia", "ca", "ba", "abs", "alpha", "va", "aux", "p", "all", "au", "la", "ma", "era", "oa", "ap", "each"], "k": ["ki", "kl", "kt", "ka", "u", "ic", "ind", "th", "dk", "tk", "g", "n", "kj", "l", "key", "kind", "kw", "z", "ks", "kh", "id", "kg", "K", "q", "kn", "kar", "kr", "km", "o", "ck", "wk", "ok", "ek", "sk", "v", "ku", "kid", "ak", "ik", "unk", "ke", "ijk", "p", "ci", "kk", "ko"], "y": ["gy", "my", "ay", "iy", "ch", "ic", "Y", "sky", "n", "key", "yt", "z", "yn", "ies", "xy", "wy", "yy", "ny", "ye", "b", "o", "ey", "uy", "vy", "v", "ry", "sy", "cy", "yi", "hy", "ym", "p", "yl", "ot"], "x": ["mx", "ax", "u", "ic", "xs", "xt", "xe", "xd", "g", "at", "yx", "xi", "xp", "it", "n", "l", "ix", "fx", "z", "xy", "e", "rx", " xx", "q", "o", "xf", "X", "xx", "wx", "dx", "v", "ox", "ex", "inx", "ux", "p", "xc", "tx"], "s": ["cs", "os", "actions", "ds", "ms", "tes", "ys", "xs", "bes", "csv", "f", "g", "hs", "n", "another", "l", "its", "js", "z", "eds", "e", "rs", "ns", "ls", "ss", "ges", "gs", "b", "ps", "ats", "o", "es", "ses", "sw", "S", "res", "sa", "v", "ars", "args", "ws", "out", "abs", "eps", "p", "rows", "ins"]}}
{"code": "\\n  \\n  \\n  def solve(C, F, X):\\n      def needtime(cookies, farm):\\n          speed = 2.0 + F * farm\\n          return cookies / speed\\n  \\n      farm = 0\\n      pasttime = 0\\n      while True:\\n          complete = needtime(X, farm)\\n          nextfarm = needtime(C, farm)\\n          nextchallenge = needtime(X, farm + 1)\\n          if complete <= nextfarm + nextchallenge:\\n              return pasttime + complete\\n          pasttime += nextfarm\\n          farm += 1\\n  \\n  \\n  def main(IN, OUT):\\n      T = int(IN.readline())\\n      for index in range(T):\\n          C, F, X = map(float, IN.readline().split())\\n          OUT.write('Case #%d: %.7f\\n' % (index + 1, solve(C, F, X)))\\n  \\n  \\n  def makesample(maxC=500, maxF=4, maxX=2000, T=100):\\n      print T\\n      for index in range(T):\\n          print ' '.join('{0}'.format(random.randint(10000, maxvalue * 10000) / 10000.0)\\n                         for maxvalue in (maxC, maxF, maxX))\\n  \\n  \\n  if __name__ == '__main__':\\n      if '-makesample' in sys.argv[1:]:\\n          makesample()\\n      else:\\n          main(sys.stdin, sys.stdout)\\n  \\n", "target": "61", "substitutes": {"C": ["V", "CS", "G", "CI", "P", "W", "CV", "J", "CNN", "Cow", "COR", "CC", "CO", "Y", "CG", "N", "M", "MC", "B", "c", "CM", "Car", "Control", "D", "CF", "CB", "YC", "Cs", "Ch", "H", "K", "CE", "CT", "A", "I", "R", "E", "CP", "Cache", "S", "NC", "Cons", "U", "L", "Config", "CR", "CON", "KC", "VC", "Cy", "WC", "TC", "Co"], "F": ["V", "G", "W", "P", "FU", "FT", "FW", "GF", "frequency", "FS", "FER", "f", "Y", "AF", "Feed", "N", "M", "FC", "Def", "MF", "B", "RF", "D", "CF", "EF", "Factory", "FD", "IF", "Fi", "H", "Farm", "K", "DF", "A", "UF", "I", "R", "Full", "E", "FO", "S", "FG", "L", "FP", "Fun", "FM", "FN", "SF", "Female", "Fin", "FILE", "PF", "FF", "Family", "FA", "For", "FE"], "X": ["V", "Tx", "CI", "P", "XXX", "IC", "ML", "J", "TX", "CC", "XY", "FX", "Y", "N", "EX", "PE", "IP", "CF", "IL", "XL", "PC", "H", "TP", "CE", "CT", "IX", "XX", "DX", "I", "R", "E", "S", "U", "x", "L", "ICE", "UX", "XP", "Q", "XT", "OX", "MX", "Z", "FF", "Ex", "FE"], "cookies": ["Cookies", " cookys", "copies", "foody", "Cooky", "cookces", "copys", " cooky", "foodies", "copy", "cookIES", "copers", "cookers", "Cookys", "Cookces", "Cookers", " cookers", "coIES", "cookys", "coces", "foodIES", "cooky", "foodces", "coy", "CookIES", "coies"], "farm": [" field", "fortune", "conn", "pac", " turbine", "capacity", "proc", "store", "root", "soon", "host", "batch", "path", "perm", "force", "computer", "hop", "type", "chance", " startup", "gain", "goal", "fac", "hunt", "company", "client", "kill", "device", "page", "jump", "scale", "feed", "p", "transform", "setup", "job", "sample", "framework", "f", "charge", "password", "fork", "browser", "callback", "time", "cpu", " Farm", "admin", " chance", "loader", "fleet", "stop", "stuff", "duration", "front", "port", "url", " farms", "test", "when", "service", "user", "ready", "Farm", "lead", "product", "policy", "profit", "field", "ff", "percent", "success", "server", "row", " tend", "FIELD", "forward"], "speed": ["length", "species", "send", "power", "performance", "gain", "sex", "size", "frequency", "peed", "f", "cost", "rate", "Speed", "fast", "spin", "scan", "service", "status", "rank", "time", "policy", "sw", "field", "count", "age", "force", "read", "efficiency", "success", "connect", "slow", "weight", "error", "scale", "delay", "transform", "stop", "forward"], "pasttime": [" pastTime", "Pasttime", "Pastspace", "pastime", " pastspace", "productionTime", "presenttim", "pastspace", "pasttim", "PastTime", "pastTime", "Pastime", "presentTime", " pastime", "futurespace", "futuretime", "futureTime", "productionime", "presenttime", "productiontim", " pasttim", "productiontime", "Pasttim"], "complete": [" Complete", "duration", "result", "match", "empty", "plete", "impact", "current", "future", "fast", "done", "com", "total", "correct", "test", "when", "pletion", "full", "partial", "map", "ready", "update", "progress", "time", "clean", "change", "batch", " completes", "Complete", "close", "completely", "process", "transfer", "commit", "success", "race", "confirmed", "open", "recent", "mate", "COMPLE", "reverse", "Completed", "final", "transform", "stop", "execute", "create"], "nextfarm": ["nextcomputer", "nextready", "nextfield", "nextproc", " nextproc", "Nextfield", "newready", "anotherbridge", " nextbridge", "anotherfarm", "newproc", "firstproc", "newfarm", "newbridge", "anotherfield", "newcomputer", "Nextcomputer", " nextcomputer", "firstfarm", " nextfield", "newfield", " nextready", "firstready", "Nextfarm", "nextbridge"], "nextchallenge": [" nextchallenges", "nextchalenges", "nextchallicate", "nextreplicate", "nextchallenges", "nextchalicate", "nextchalonge", "nextChallicate", "nextchalenge", "nextChallenges", " nextchalenges", " nextchallicate", " nextchalicate", " nextchalonge", "nextChallonge", "nextchallonge", "nextreplenges", " nextchalenge", "nextreplonge", " nextchallonge", "nextChallenge", "nextreplenge"], "IN": ["NULL", "GEN", "REC", "ML", "ER", "IC", "OU", "AL", "STDOUT", "Input", "READ", "CL", "ST", "GET", "IND", "RAW", "DIR", "INS", "INT", "IL", "RL", "EN", "FINE", "Out", "MIT", "SOURCE", "LIN", "L", "IR", "PIN", "AN", "out", "DATA", "IT", "FILE", "DERR", "UL", "In", "ILL", "GER", "ALL", "USE"], "OUT": ["NULL", "Writer", "OU", "TN", "BY", "STDOUT", "AL", "ALL", "PATH", "O", "PUT", "AT", "DIR", "UT", "RAW", "WARNING", "HT", "INT", "TABLE", "NER", "RET", "Out", "SOURCE", "TH", "Output", "out", "SET", "INAL", "TO", "VER", "FILE", "DERR", "UL", "TEXT", "STR", "OT"], "T": ["V", "GT", "G", "W", "P", "TB", "NB", "Time", "TX", "TN", "J", "t", "Y", "Total", "TPS", "N", "M", "O", "B", "TA", "D", "UTC", "TIME", "TT", "TV", "TY", "H", "K", "CT", "I", "R", "E", "TS", "S", "NT", "WT", "TED", "L", "TH", "TR", "PO", "Q", "TM", "IT", "Z", "TI", "TC", "OT", "TD"], "index": ["length", "second", "int", "value", "seed", "slice", "size", "address", "port", "ind", "f", "case", "condition", "key", "ix", "site", "test", "order", "name", "loc", "unit", "set", "where", "pos", "id", "insert", "connection", "time", "zero", "serial", "number", "thread", "eight", "find", "Index", "field", "dx", "count", "ox", "device", "x", "axis", "success", "num", "ex", "position", "error", "link", "page", "open", "row", "head", "val", "ion", "instance", "i"], "maxC": ["hugeCB", "maxN", "maxDC", "maxT", " maxCB", "masterDC", "maxCB", "endC", "masterCB", "MaxV", "MaxN", "endN", " maxV", "endV", " maxDC", "maxV", "hugeDC", "hugeC", "MaxC", "MaxT", " maxN", "masterC", " maxCS", "maxCS", "masterCS", " maxT", "endT", "hugeCS"], "maxF": ["maxf", "cacheX", "cachef", " maxFF", "maxFF", " maxf", "hugeG", " maxV", "masterFF", " maxG", "maxV", "finalV", "hugeFF", "hugef", "masterf", "masterG", "hugeF", "masterF", "finalf", "maxG", "cacheF", "finalX", "finalF", "cacheV"], "maxX": [" maxP", " maxx", "maxY", "MaxF", "maxP", " maxY", "MAXX", "hugeY", "MaxX", "Maxx", "MAXY", "MaxY", "maxx", "hugeP", "hugeF", "hugeX", "MAXP", "MAXx", "MaxP"], "maxvalue": [" maxValue", "maxdata", "Maxvalue", "MAXValue", "maxvalues", "maxVALUE", " maxVALUE", "Maxvalues", "MAXVALUE", "Maxval", "Maxdata", " maxvalues", "maximumvalue", "MaxValue", "MAXval", "MaxVALUE", " maxval", " maxdata", "Maxresult", "maxresult", "maxValue", "maximumresult", "maximumvalues", "maximumdata", " maxresult", "maxval", "MAXvalue"]}}
{"code": "\\n  \\n  \\n  def check(R, C, M, _board):\\n      board = [line[:] for line in _board]\\n  \\n      pos = [(0, 0)]\\n      while pos:\\n          row, col = pos.pop()\\n          neighbor = []\\n          for r in (-1, 0, 1):\\n              r += row\\n              for c in (-1, 0, 1):\\n                  c += col\\n                  if r >= 0 and r < R and c >= 0 and c < C:\\n                      neighbor.append((r, c))\\n          count = len([1 for r, c in neighbor if board[r][c] == '*'])\\n          board[row][col] = str(count)\\n          if count == 0:\\n              for r, c in neighbor:\\n                  if board[r][c] == '.':\\n                      pos.append((r, c))\\n  \\n      flat = ''.join(''.join(line) for line in board)\\n      result = not flat.count('.')\\n      if not result and False: # for DEBUG\\n          print '-' * 20\\n          print R, C, M\\n          print '\\n'.join(''.join(line) for line in _board)\\n          print '-' * 20\\n      assert flat.count('*') == M\\n      return result\\n  \\n  \\n  def solve(R, C, M):\\n      board = [['.'] * C for row in range(R)]\\n      board[0][0] = 'c'\\n      row = R\\n      col = C\\n      mine = M\\n  \\n      while mine:\\n          if 0 < row <= col and mine >= row:\\n              for r in range(row):\\n                  board[row - r - 1][col - 1] = '*'\\n              mine -= row\\n              col -= 1\\n          elif 0 < col <= row and mine >= col:\\n              for c in range(col):\\n                  board[row - 1][col - c - 1] = '*'\\n              mine -= col\\n              row -= 1\\n          else:\\n              break\\n  \\n      if mine:\\n          while mine and row > 2:\\n              for r in range(min(mine, row - 2)):\\n                  board[row - r - 1][col - 1] = '*'\\n                  mine -= 1\\n              col -= 1\\n          while mine and col > 2:\\n              for c in range(min(mine, col - 2)):\\n                  board[row - 1][col - c - 1] = '*'\\n                  mine -= 1\\n              row -= 1\\n  \\n      if mine:\\n          if mine:\\n              board[1][1] = '*'\\n              mine -= 1\\n          if mine:\\n              board[1][0] = '*'\\n              mine -= 1\\n          if mine:\\n              board[0][1] = '*'\\n              mine -= 1\\n  \\n      assert mine == 0\\n      return '\\n'.join(''.join(line) for line in board) if check(R, C, M, board) else 'Impossible'\\n  \\n  \\n  def main(IN, OUT):\\n      T = int(IN.readline())\\n      for index in range(T):\\n          R, C, M = map(int, IN.readline().split())\\n          OUT.write('Case #%d:\\n%s\\n' % (index + 1, solve(R, C, M)))\\n  \\n  \\n  def makesample(maxSize=5, T=230):\\n      print T\\n      for index in range(T):\\n          R = random.randint(1, maxSize)\\n          C = random.randint(1, maxSize)\\n          print R, C, random.randint(0, R * C - 1)\\n  \\n  \\n  def makesample():\\n      pattern = []\\n      for R in range(1, 5+1):\\n          for C in range(1, 5+1):\\n              for M in range(R * C):\\n                  pattern.append((R, C, M))\\n      print len(pattern)\\n      for R, C, M in pattern:\\n          print R, C, M\\n  \\n  \\n  if __name__ == '__main__':\\n      if '-makesample' in sys.argv[1:]:\\n          makesample()\\n      else:\\n          main(sys.stdin, sys.stdout)\\n  \\n", "target": "61", "substitutes": {"R": ["V", "RS", "G", "P", "W", "RE", "Y", "RG", "N", "O", "B", "MR", "GR", "D", "H", "RA", "T", "A", "RT", "I", "RO", "X", "E", "S", "RR", "L", "F", "U", "CR", "TR", "Q"], "C": ["V", "CS", "G", "CI", "P", "CC", "Y", "N", "MC", "B", "CM", "D", "CB", "YC", "Cs", "H", "K", "CE", "CT", "T", "DC", "CU", "A", "I", "E", "CP", "S", "L", "F", "U", "CR", "CH", "WC"], "M": ["V", "Mon", "G", "W", "P", "OR", "m", "n", "N", "O", "B", "D", "H", "RM", "T", "A", "I", "X", "E", "S", "L", "F", "U", "Mr", "Q", "p", "Z"], "_board": ["_deck", "_boards", " _boards", "_line", " _frame", "_frame", " _deck", "\u00a0frame", "pline", " _line", " _stream", "\u00a0base", "\u00a0deck", "pstream", "_base", "_stream", " _base", "pboard", "pboards"], "board": ["layout", "bot", "range", "loop", "empty", "Board", "bo", "lay", "boards", "view", "database", "rot", "base", "channel", "play", "pool", "full", "buffer", "lock", "runner", "bus", "body", "black", "plate", "bang", "flo", "rank", "control", "bank", "table", "co", "bro", "bird", "clean", "ro", "block", "ward", "user", "back", "stream", "frame", "style", "bit", "player", "ack", "bug", "out", "list", "position", "deck", "node", "boat", "square", "league", "box", "lo", "form", "bar"], "line": ["range", "ner", "ine", "note", "lay", "lane", "word", "m", "inline", "play", "cell", "l", "text", "lin", "lined", "lines", "load", "write", "lock", "live", "store", "name", "iter", "change", "draw", "liner", "block", "rule", "left", "email", "point", "se", "move", "cycle", "frame", "chain", "Line", "player", "model", "out", "list", "ln", "code", "link", "page", "node", "kin", "online", "end", "LINE", "verse", "day", "lo", "ide"], "pos": ["range", "os", "conf", "pid", "gen", "size", "spec", "port", "bo", "at", "pi", "yes", "rot", "neg", "up", "POS", "present", "loc", "pose", "local", "body", "po", "tmp", "resp", "pro", "pt", "Pos", "trans", "block", "ps", "pack", "path", "point", "obj", "cond", "rel", "pr", "cos", "nt", "op", "res", "bit", "ports", "ack", "out", "list", "off", "abs", "position", "pl", "next", "p", "all", "points"], "row": ["range", "ob", "rt", "month", "ows", "dr", "rid", "th", "pair", "tr", "rect", "rot", "ru", "cell", "index", "rd", "order", "rs", "rank", "re", "our", "room", "co", "br", "ro", "Row", "ra", "arrow", "ri", "rc", "sur", "rod", "ver", "res", "ry", "ox", "x", "rown", "ow", "roll", "fr", "val", "vr", "rows"], "col": ["cs", "cmd", "cp", "cal", "ol", "ch", "y", "port", "th", "rot", "cell", "l", "key", "cl", "con", "loc", "icol", "rol", "column", "fl", "pt", "client", "co", "fc", "path", "point", "cos", "character", "fn", "cor", "scroll", "cat", "cul", "prop", "cy", "coll", "pc", "num", "roll", "char", "Col", "val", "cut", "ct", "foot", "COL"], "neighbor": ["noighbors", "noigler", "neearbor", "neigbor", "neIGHbit", "noteigbit", "noigbor", "noteighbour", "noighler", "neldbors", "neighor", "nelderbor", "neldor", "neoothbors", "neIGHbour", "neIGHbor", "neighne", "neighbit", "neigbour", " neighbour", "neigbit", " neldor", "noigbors", "noteighne", "neoothbour", "neearbors", "noigbour", "neigor", "neigerne", "noteigne", "neIGHne", "nelderbors", "neaglebors", " neighor", "neaglebour", "neigne", "neearbour", "neldbour", "neaglebor", "neagleor", "neigerbit", "neoothor", "noteigbor", "noighbor", "noteigbour", "noighbour", "neigler", "neigerbor", "noteighbor", "neearler", "neldbor", " neighbors", "neigbors", " neldbors", " neldbour", "neighbors", "nelderbour", "noteighbit", "neoothbor", "neigerbour", "neighler", "neighbour", "nelderler", " neldbor"], "r": ["hr", "range", "adr", "rr", "rt", "cr", "dr", "art", "u", "rid", "w", "t", "tr", "ren", "m", "g", "err", "rect", "rate", "n", "ru", "l", "attr", "rd", "h", "rm", "sr", "e", "rs", "ring", "re", "ir", "q", "b", "ro", "br", "ur", "ar", "ra", "o", "kr", "pr", "rel", "rc", "rh", "j", "res", "yr", "mr", "v", "reg", "usr", "x", "er", "race", "lr", "rl", "fr", "run", "p", "d", "rar", "vr", "rg", "rb", "i"], "c": ["cs", "cr", "cp", "uc", "ch", "cf", "u", "ic", "anc", "t", "f", "m", "cin", "g", "n", "cell", "ach", "l", "com", "cl", "gc", "ac", "z", "ec", "arc", "con", "mc", "k", "dc", "lc", "co", "vc", "b", "fc", "cur", "unc", "o", "bc", "cos", "ce", "rc", "sc", "cache", "chain", "cod", "v", "cor", "cat", "cu", "x", "xc", "ca", "pc", "cd", "cm", "ci", "ct", "p", "cn", "d", "tc", "i", "cc"], "count": ["more", "length", "nb", "match", "conf", "cont", "last", "stat", "conn", "ch", "size", "first", "len", "ind", "search", "mount", "collect", "n", "flag", "only", "total", "Count", "index", "test", "rand", "z", "cloud", "ount", "loc", "check", "get", "unique", "depth", "delete", "call", "change", "score", "number", "display", "amount", "find", "nt", "cache", "counter", "close", "ctr", "common", "deep", "list", "connect", "num", "code", "replace", "select", "sum", "cd", "found", "shift", "ct", "max"], "flat": ["atten", "layout", "pal", "short", "animate", "att", "plant", "at", "f", "functional", "fast", "sat", "float", "lat", "full", "flush", "vert", "unit", "dot", "plain", "boat", "ran", "fl", "ful", "oat", "clean", "pack", "format", "who", "frac", "pure", "bit", "plan", "cat", "out", "wide", "hat", "feed", "mate", "straight", "plane", "complex", "final"], "result": ["mark", "match", "Result", "power", "successful", "comment", "goal", "work", "mult", "date", "feature", "fac", "case", "ure", "flag", "total", "correct", "test", "mask", "false", "status", "contact", "set", "make", "zero", "product", "number", "diff", "know", "res", "currency", "process", "degree", "force", "success", "debug", "error", "trace", "mate", "run", "final", "void", "relation"]}}
{"code": "sys.setrecursionlimit(15000)\\n  \\n  def solve(C, F, X, rate, time):\\n    if (time + (X / rate)) < ((C / rate) + ((X / (rate+F)) + time)):\\n      return time + (X / rate)\\n    else:\\n      return solve(C, F, X, rate+F, time + (C / rate))\\n  \\n  T = int(raw_input())\\n  for t in range(T):\\n    C, F, X = map(float, raw_input().split())\\n    print 'Case #%i: %.7f' % (t+1, solve(C, F, X, 2, 0))\\n", "target": "62", "substitutes": {"C": ["V", "CPU", "AC", "CS", "G", "Cond", "CI", "P", "Chain", "W", "CV", "Time", "CNN", "Cow", "CC", "CO", "Cod", "Y", "CG", "N", "M", "Mc", "O", "Count", "MC", "B", "c", "CM", "Car", "Control", "D", "CF", "YC", "Ch", "Cs", "H", "LC", "CT", "CU", "Cal", "A", "Cl", "DC", "I", "R", "E", "CP", "Cache", "CA", "NC", "S", "Che", "Size", "L", "U", "Rate", "CR", "Config", "KC", "CN", "Con", "TC", "Co", "SC"], "F": ["V", "G", "W", "P", "FT", "GF", "Fixed", "FR", "FW", "FS", "FER", "f", "Y", "Fs", "AF", "Feed", "N", "M", "FC", "FB", "FI", "B", "File", "RF", "TF", "D", "EF", "Factory", "FL", "FD", "CF", "IF", "H", "DF", "UF", "I", "Full", "R", "Fe", "E", "FO", "S", "FG", "Form", "Filter", "L", "U", "FP", "Rate", "FM", "SF", "HF", "All", "PF", "FF", "Family", "For", "FE"], "X": ["V", "Tx", "AC", "W", "P", "ML", "Time", "J", "TX", "FX", "XY", "Y", "XM", "N", "M", "EX", "B", "IP", "D", "IL", "XL", "H", "K", "IM", "IX", "Content", "XX", "A", "DX", "I", "R", "E", "S", "U", "x", "L", "Example", "UX", "IR", "XP", "Q", "Event", "XT", "OX", "Z", "One", "XXX", "ICE"], "rate": ["range", "length", "sample", "scene", "power", "rates", "seed", "cr", "ate", "rice", "core", "size", "frequency", "mode", "prime", "date", "f", "fee", "ime", "capacity", "float", "test", "rand", "rat", "c", "D", "fine", "function", "rank", "re", "r", "state", "co", "change", "rule", "term", "R", "cycle", "frame", "count", "currency", "age", "force", "x", "Rate", "erate", "transfer", "race", "code", "speed", "delay", "scale", "type", "p", "d", "factor"], "time": ["timer", "duration", "second", "length", "sample", "value", "message", "times", "Time", "timeout", "size", "frequency", "port", "mode", "date", "f", "m", "ime", "offset", "test", "when", "c", "tm", "runtime", "TIME", "set", "event", "sequence", "r", "tt", "context", "start", "cycle", "frame", "count", "age", "clock", "x", "now", "once", "speed", "trace", "tim", "delay", "type", "period", "transform", "tc", "max"], "T": ["V", "P", "TB", "J", "TN", "Y", "N", "M", "B", "TA", "D", "TT", "TV", "TY", "K", "TP", "A", "I", "R", "TS", "S", "NT", "WT", "TH", "L", "TR", "TM", "VT", "TI", "TC", "OT"], "t": ["s", "ty", "ta", "y", "w", "tr", "f", "m", "g", "n", "l", "step", "c", "z", "e", "k", "q", "r", "tf", "tt", "b", "tu", "j", "tip", "v", "ts", "x", "num", "p", "d", "ct", "a", "h", "tc", "i"]}}
{"code": "\\n  def solve(W, H, M):\\n    board = [['*' for x in xrange(H)] for x in xrange(W)]\\n    board[0][0] = 'c'\\n    \\n    S = [((H*W)-1, board, 0, 0, set())]\\n    H -= 1\\n    W -= 1\\n    while len(S) > 0:\\n      state = S.pop()\\n      mines = state[0]\\n      board = deepcopy(state[1])\\n      x = state[2]\\n      y = state[3]\\n      visited = deepcopy(state[4])\\n      visited.add((x, y))\\n      \\n      if mines == M:\\n        s = ''\\n        for row in board:\\n          s += ''.join(row)\\n          s += '\\n'\\n        return s\\n      \\n      elif mines > M:\\n        if x > 0 and board[x-1][y] == '*':\\n          board[x-1][y] = '.'\\n          mines -= 1\\n        \\n        if x < W and board[x+1][y] == '*':\\n          board[x+1][y] = '.'\\n          mines -= 1\\n        \\n        if y > 0 and board[x][y-1] == '*':\\n          board[x][y-1] = '.'\\n          mines -= 1\\n        \\n        if y < H and board[x][y+1] == '*':\\n          board[x][y+1] = '.'\\n          mines -= 1\\n        \\n        if x > 0 and y > 0 and board[x-1][y-1] == '*':\\n          board[x-1][y-1] = '.'\\n          mines -= 1\\n        \\n        if x > 0 and y < H and board[x-1][y+1] == '*':\\n          board[x-1][y+1] = '.'\\n          mines -= 1\\n        \\n        if x < W and y > 0 and board[x+1][y-1] == '*':\\n          board[x+1][y-1] = '.'\\n          mines -= 1\\n        \\n        if x < W and y < H and board[x+1][y+1] == '*':\\n          board[x+1][y+1] = '.'\\n          mines -= 1\\n        \\n        if x > 0 and not (x-1, y) in visited:\\n          S.append((mines, board, x-1, y, visited))\\n        \\n        if x < W and not (x+1, y) in visited:\\n          S.append((mines, board, x+1, y, visited))\\n        \\n        if y > 0 and not (x, y-1) in visited:\\n          S.append((mines, board, x, y-1, visited))\\n        \\n        if y < H and not (x, y+1) in visited:\\n          S.append((mines, board, x, y+1, visited))\\n        \\n        if x > 0 and y > 0 and not (x-1, y-1) in visited:\\n          S.append((mines, board, x-1, y-1, visited))\\n        \\n        if x > 0 and y < H and not (x-1, y+1) in visited:\\n          S.append((mines, board, x-1, y+1, visited))\\n        \\n        if x < W and y > 0 and not (x+1, y-1) in visited:\\n          S.append((mines, board, x+1, y-1, visited))\\n        \\n        if x < W and y < H and not (x+1, y+1) in visited:\\n          S.append((mines, board, x+1, y+1, visited))\\n    return 'Impossible'\\n  \\n  T = int(raw_input())\\n  for t in range(T):\\n    W, H, M = map(int, raw_input().split())\\n    print 'Case #%i:\\n%s' % (t+1, solve(W, H, M).strip())\\n", "target": "62", "substitutes": {"W": ["V", "WA", "G", "P", "SW", "WP", "FW", "WR", "WW", "w", "Y", "EW", "N", "NW", "Sh", "B", "C", "OW", "Win", "D", "HT", "Word", "WH", "K", "We", "TW", "WS", "A", "Wh", "I", "DW", "R", "X", "E", "Sw", "WT", "Width", "VW", "RW", "F", "L", "TH", "U", "Wr", "WM", "Q", "CW", "Wil", "MW", "Z", "All", "Weight", "WC", "BW"], "H": ["V", "G", "P", "Th", "J", "WR", "HH", "w", "MH", "Host", "HM", "Y", "He", "N", "HK", "HD", "Eh", "HC", "B", "C", "OH", "Sh", "HB", "Haw", "Win", "HT", "HTTP", "HE", "WH", "Hi", "K", "HS", "A", "Wh", "I", "R", "HA", "X", "E", "Sw", "HI", "Her", "GH", "TH", "L", "F", "SH", "HL", "Q", "Where", "wh", "HTML", "Z", "Here", "h", "His"], "M": ["V", "G", "MAN", "P", "J", "Y", "m", "N", "O", "MC", "B", "C", "CM", "D", "K", "MI", "A", "I", "R", "X", "E", "L", "F", "U", "WM", "Q", "TM", "MM", "NM", "Z", "MA"], "board": ["disk", "poll", "card", "lib", "wheel", "hole", "radio", "full", "down", "check", "black", "table", "zero", "b", "ward", "frame", "cross", "bit", "hold", "bug", "bar", "builder", "book", "loop", "ows", "core", "w", "database", "window", "game", "buffer", "fine", "boat", "r", "room", "client", "clean", "oard", "left", "hub", "menu", "stream", "planet", "style", "device", "join", "out", "list", "position", "square", "p", "post", "record", "cam", "form", "message", "controller", "ard", "bo", "chart", "word", "base", "up", "panel", "body", "bank", "ro", "video", "back", "flow", "image", "well", "rain", "box", "win", "layout", "empty", "Board", "work", "public", "lay", "boards", "null", "view", "rot", "pad", "channel", "test", "runner", "lock", "door", "set", "user", "system", "rank", "config", "sequence", "control", "block", "inner", "bin", "number", "land", "cache", "line", "chain", "ox", "player", "boarding", "ack", "good", "node", "deck", "error"], "x": ["mx", "ax", "u", "g", "yx", "only", "l", "lat", "c", "k", "q", "path", "zx", "j", "wx", "bit", "v", "fixed", "axis", "edit", "ctx", "ct", "a", "rx", "tx", "xxx", "to", "w", "xt", "xml", "ie", "step", "index", "z", "e", " xx", "r", "el", "left", "xx", "p", "exp", "ace", "h", "name", "xc", "xs", "on", "xe", "at", "m", "f", "xi", "n", "xa", "fx", "lex", "lon", "status", "xy", "column", "id", "time", "o", "point", "xf", "one", "act", "ex", "inx", "image", "col", "pos", "i", "data", "xd", "xp", "ix", "key", "px", "X", "dx", "xxxx", "ox", "ip", "ux", "content", "item"], "S": ["V", "P", "SW", "Sub", "SI", "SA", "SP", "BS", "N", "O", "STATE", "B", "C", "NS", "D", "SS", "SEC", "SQL", "Row", "WS", "A", "SU", "I", "R", "SL", "SB", "TS", "SE", "Si", "Set", "L", "Sl", "State", "VS", "seconds"], "state": ["tag", "zone", "loop", "seed", "stat", "stats", "spec", "port", "pair", "n", "resource", "step", "STATE", "index", "key", "test", "area", "status", "runner", "local", "user", "store", "root", "set", "unit", "config", "event", "function", "r", "block", "rule", "states", "hash", "se", "start", "space", "dict", "cache", "close", "info", "monitor", "count", "role", "player", "er", "list", "success", "State", "node", "type", "p", "section", "queue", "job"], "mines": ["menensions", "miners", "MINions", "minsees", "manees", "smalles", "mintses", "minsuses", "timses", "mates", "minovers", "mintels", "mineers", "Minedes", "versions", "minsales", "coolses", "MinES", "mintales", "minsces", "minsets", "smallES", "memesi", "minsovers", "minses", "raines", "monses", "menions", "Minions", "mineis", "minsesi", "rainees", "monsions", "servces", "Minses", "smallions", "minsies", "minsedes", "minales", "minels", "timions", "memensions", "menes", "versis", "manes", "minises", "rainovers", "serves", "Minces", "timales", "minuses", "minesi", "MINes", "mintions", "memales", "minions", "verses", "rainies", "MINis", "minees", "miniales", "memes", "versers", "MINets", "mintuses", "matis", "mations", "minis", "minties", "cooles", "coolions", "mineions", "rainels", "minsES", "menales", "minES", "minensions", "rainions", "matets", "minsions", "memions", "minies", "times", "MINies", "smallses", "monsesi", "manovers", "mintes", "MINuses", "minets", "minsers", "minsis", "minsensions", "minsels", "servions", "minces", "servedes", "minsses", "monsales", "miniions", "minedes", "manions", "Mines", "coolales"], "y": ["ay", "isy", "iy", "lib", "Y", "cell", "l", "ies", "k", "yy", "ny", "table", "ye", "b", "uy", "j", "yr", "v", "top", "cy", "yi", "hy", "type", "iny", "height", "io", "dy", "ty", "to", "ery", "hot", "ya", "w", "oy", "zy", "yd", "index", "z", "wy", "client", "axy", "html", "vy", "out", "page", "icy", "p", "h", "yl", " Y", "gy", "ly", "on", "at", "m", "ley", "iley", "up", "n", "sat", "yt", "aily", "py", "status", "xy", "id", "kit", "time", "ory", "o", "no", "by", "scroll", "ry", "fill", "any", "col", "i", "more", "my", "hey", "file", "ch", "size", "yes", "sky", "rot", "key", "yn", "ey", "year", "ox", "ady", "sy", "fy", "er", "yer", "ip", "ym"], "visited": ["viewitted", "Visited", "waITED", "Vised", "viewITED", "visit", "VISitted", "Visit", "viewited", "viewit", "Visitted", "vised", "VisITED", "VISit", "VISited", "visiting", "waitted", "waiting", "viewed", "Visiting", "visITED", "VISed", "visitted", "viewiting", "waited"], "s": ["cs", "sv", "ows", "stat", "short", "stats", "tes", "w", "f", "m", "g", "n", "long", "l", "c", "its", "eds", "e", "rs", "ns", "set", "_", "r", "ss", "ls", "gs", "b", "ps", "ats", "states", "es", "ses", "bs", "v", "ts", "bits", "str", "ws", "sb", "abs", "sol", "strings", "als", "p", "all", "rows", "a", "ins", "h", "i"], "row": ["ows", "w", "pair", "word", "week", "rect", "rot", "wheel", "cell", "index", "order", "runner", "user", "set", "entry", "r", "box", "ro", "Row", "arrow", "ward", "path", "sw", "raw", "line", "sc", "scroll", "ox", "star", "server", "node", "error", "roll", "col", "rows", "item", "name", "record", "rx", "bar"]}}
{"code": "\\n  \\n  ncases = int(sys.stdin.readline().strip())\\n  \\n  for t in range(1, ncases+1):\\n      values = sys.stdin.readline().split()\\n      c = float(values[0])\\n      f = float(values[1])\\n      x = float(values[2])\\n      r = 2\\n  \\n      time = 0\\n  \\n      while True:\\n          tdirect = x/r\\n          tfactory = c/r + x/(r+f)\\n  \\n          if tdirect<tfactory:\\n              time += tdirect\\n              break\\n          else:\\n              time += c/r\\n              r += f\\n  \\n      print(\"Case #{0}: {1:.7f}\".format(t, time))\\n", "target": "63", "substitutes": {"ncases": ["nccases", "cvaces", "NCase", "cvcases", "NCcases", "nsaves", "NCaves", "ncaces", "nase", "nages", "cvase", "ncaves", "nsases", "naces", "naves", "nsages", "nscases", "NCages", "nases", "ncages", "NCases", "ncase", "NCaces", "cvases"], "t": ["ti", "s", "title", "rt", "to", "ta", "y", " pt", "w", "new", "g", "m", " te", "it", "n", "l", "total", "test", "z", "e", "k", " ot", " td", "q", " th", "tt", "T", "ter", " ti", "ret", "v", "te", " w", "trial", " T", " tid", "dt", "p", "d", "a", "tc", "i"], "values": ["lets", "ves", "value", "blocks", "ives", "actions", "Values", "bes", "days", "changes", "details", "views", "verts", "aps", "waters", "items", "ups", "bytes", "settings", "places", "forms", "files", "lists", "flows", "ps", "words", "vi", "vs", "bs", "weights", "dates", "ters", "ports", "terms", "fields", "measures", "users", "ples", "objects", "years", "ages", "ires", "vals", "als", "tools", "pins", "ins", "seconds", "boxes", "maps", "points"], "c": ["cs", "cr", "cp", "tc", "y", "u", "cf", "m", "n", "l", "C", "z", "con", "e", "k", "lc", "co", "b", "cur", "rc", "v", "cu", "cy", "cb", "col", "cn", "ci", "p", "d", "a", "ct", "h", "xc", "cd", "cm", "cc"], "f": ["file", "u", "y", "w", "cf", "m", "n", "l", "fx", "float", "z", "fb", "e", "k", "fl", "tf", "b", "fc", "ur", "o", "xf", "rf", "fi", "v", "F", "force", "out", "fd", "fr", "p", "d", "a", "fp", "h", "i"], "x": ["int", "y", "u", "ic", "xs", "w", "xt", "xe", "g", "xi", "n", "l", "fx", "z", "e", "xy", "co", "b", "xf", "X", "rc", "xx", "wx", "v", "ox", "cf", "ex", "ctx", "p", "ct", "a", "tx", "ux", "xc", "i", "rx"], "r": ["range", "result", "rt", "cr", "y", "u", "w", "g", "m", "rate", "n", "ru", "l", "nr", "rd", "h", "rn", "z", "e", "k", "rs", "re", "q", "rb", "b", "ro", "br", "ur", "o", "ar", "term", "R", "rc", "j", "rf", "res", "v", "er", "rw", "right", "fr", "type", "p", "d", "err", "i", "rx"], "time": ["timer", "duration", "value", "message", "times", "Time", "timeout", "size", "frequency", "mode", "w", "date", "m", "etime", "ime", "rate", "offset", "step", "index", "memory", "test", "window", "tm", "mt", "runtime", "TIME", "depth", "tt", "context", "im", "path", "start", "rc", "counter", "v", "ts", "clock", "now", "error", "speed", "trace", "tim", "dt", "delay", "type", "tc", "tx"], "tdirect": ["cdrict", "cddirect", " tdirection", "TDdirect", "ndirect", "ndirection", "cdirection", "TDirection", "TDirect", "sdir", "tdirection", "sdirect", "ndir", "TDir", "tdient", "nddirect", " tdrict", "cdirect", "tdrict", " tdient", "ndient", "sdirection", "tddirect", "cdir", "sdient", "TDrict", " tdir", "tdir"], "tfactory": [" tfication", "TFfact", "tffact", "tfactor", "tifactor", "TFactor", "tdactor", "tfication", "tiffact", " tffact", "tdfact", "TFication", "tifactory", "tdactory", "TFactory", "tdication", " tfactor"]}}
{"code": "\\n  \\n  ncases = int(sys.stdin.readline().strip())\\n  \\n  def print_board(r, c, free):\\n      board = {}\\n      for row in range(0, r):\\n          board[row] = {}\\n          for col in range(0, c):\\n              board[row][col] = '*'\\n  \\n      pending = free\\n  \\n      if free == 1:\\n          board[0][0] = '.'\\n      elif r == 1 or c == 1:\\n          for row in range(0, r):\\n              for col in range(0, c):\\n                  if pending > 0:\\n                      pending -= 1\\n                      board[row][col] = '.'\\n      else:\\n          for row in range(0,2):\\n              for col in range(0,2):\\n                  board[row][col] = '.'\\n          pending -= 4\\n          col=2\\n          row=2\\n  \\n          while pending >= 2 and (col<c or row<r):\\n              if pending >= 2 and col<c:\\n                  board[0][col] = '.'\\n                  board[1][col] = '.'\\n                  col += 1\\n                  pending -= 2\\n              if pending >= 2 and row<r:\\n                  board[row][0] = '.'\\n                  board[row][1] = '.'\\n                  row += 1\\n                  pending -= 2\\n  \\n          for row in range(2, r):\\n              for col in range(2, c):\\n                  if pending > 0:\\n                      board[row][col] = '.'\\n                      pending -= 1\\n  \\n      board[0][0] = 'c'\\n  \\n      for row in range(0, r):\\n          line = ''\\n          for col in range(0, c):\\n              line += board[row][col]\\n          print(line)\\n  \\n  \\n  for t in range(1, ncases+1):\\n      values = sys.stdin.readline().strip().split()\\n      r = int(values[0])\\n      c = int(values[1])\\n      m = int(values[2])\\n  \\n      cells = r * c\\n      free = cells - m\\n  \\n      possible = False\\n  \\n      if r == 1 or c == 1:\\n          if free >= 1:\\n              possible = True\\n      elif r == 2 or c == 2:\\n          if free == 1 or (free >= 4 and free%2 == 0):\\n              possible = True\\n      else:\\n          if free == 1 or (free >= 4 and free != 5 and free != 7):\\n              possible = True\\n  \\n      print(\"Case #{0}:\".format(t))\\n  \\n      if possible:\\n          print_board(r, c, free)\\n      else:\\n          print(\"Impossible\")\\n", "target": "63", "substitutes": {"ncases": ["uncasing", "ncades", "ecases", "NCasing", "NCase", "uncases", "uncums", "ecase", "uncase", "bcases", "uncleases", "ncasing", "NCleases", "bcades", "ecleases", "ncums", "bcase", "uncades", "ncleases", "NCades", "NCases", "bcasing", "ecums", "ncase", "NCums"], "r": ["hr", "range", "rr", "rt", "cr", "dr", "u", "rid", "w", "f", "g", "n", "ru", "l", "nr", "attr", "rd", "h", "rn", "z", "sr", "rs", "k", "re", "ran", "ir", "co", "b", "ro", "br", "ra", "ar", "kr", "o", "ri", "pr", "R", "rator", "rc", "j", "rec", "res", "mr", "v", "reg", "x", "er", "rw", "right", "fr", "run", "p", "d", "rar", "rg", "a", "rb", "name", "i"], "c": ["cs", "s", "cr", "cp", "ch", "cf", "ic", "u", "y", "w", "f", "cin", "g", "n", "cell", "l", "com", "C", "ac", "ec", "con", "mc", "k", "e", "re", "_", "q", "dc", "co", "lc", "b", "fc", "cur", "o", "bc", "ce", "rc", "sc", "cache", "res", "v", "cu", "x", "ca", "pc", "cb", "cm", "ci", "p", "ct", "a", "d", "h", "tc", "cation", "i", "cc"], "free": ["clear", "conn", "note", "prime", "done", "cell", "float", "full", "Left", "store", "grid", "co", "mem", "zero", "OK", "fail", "net", "confirmed", "num", "usage", "cold", "ent", "type", "broad", "range", "rozen", "N", "index", "none", "non", "buffer", "fine", "released", "alloc", "bytes", "reset", "clean", "left", "min", "res", "stable", "F", "use", "out", "available", "un", "score", "valid", "domain", "new", "f", "fee", "occupied", "total", "mouse", "vol", "ne", "no", "used", "Free", "open", "next", "le", "floor", "max", "release", "locked", "empty", "size", "current", "blank", "when", "FREE", "con", "bill", "ready", "Now", "filled", "cache", "off", "code", "When", "mate", "All", "dead"], "board": ["layout", "builder", "disk", "bot", "book", "loop", "poll", "pb", "buff", "Board", "bo", "bench", "public", "lay", "bet", "front", "boards", "word", "lib", "database", "pad", "rot", "blank", "design", "pool", "test", "buffer", "runner", "lock", "door", "uno", "body", "flo", "boat", "sequence", "bang", "table", "bank", "control", "co", "bird", "bd", "zero", "student", "bro", "block", "oard", "ward", "past", "ro", "back", "anks", "ui", "chain", "cross", "bit", "player", "boarding", "hold", "bug", "plate", "deck", "square", "mate", "league", "foot", "box", "bishop", "form", "bar"], "row": ["ob", "tr", "cell", "order", "loc", "root", "co", "zero", "batch", "arrow", "ward", "sw", "rc", "frame", "num", "right", "run", "type", "round", "height", "bar", "range", "ram", "month", "ows", "rect", "index", "entry", "left", "rec", "res", "prefix", "out", "list", "page", "ow", "post", "name", "record", "form", "bo", "rid", "f", "week", "column", "id", "ro", "Row", "no", "raw", "sc", "scroll", "ry", "role", "coll", "next", "tab", "box", "pos", "lo", "th", "lay", "dir", "rot", "byte", "key", "con", "runner", "user", "rank", "re", "our", "group", "draw", "block", "rel", "ox", "x", "grow", "off", "server", "rown", "node", "roll", "rows", "day", "item", "void", "hour"], "col": ["cal", "tr", "crypt", "cell", "l", "comp", "chlor", "cl", "aj", "fol", "loc", "table", "co", "fc", "path", "cos", "cond", "fn", "cor", "num", "mon", "coord", "cut", "ct", "foot", "gall", "int", "chron", "cp", "li", "pool", "il", "ac", "color", "ctl", "el", "cur", "left", "pr", "res", "prop", "child", "char", "Col", "p", "name", "ll", "ell", "ol", "len", "on", "f", "word", "n", "fix", "dial", "icol", "column", "fl", "pt", "ref", "nt", "scroll", "cat", "cul", "ill", "act", "coll", "lr", "city", "tab", "box", "pos", "win", "COL", "pat", "ht", "cmd", "ch", "y", "cf", "ind", "handle", "dir", "rot", "channel", "key", "ont", "con", "rol", "draw", "obj", "rel", "field", "count", "crit", "ox", "x", "str", "pc", "roll", "val", "day", "label", "ctrl"], "pending": ["ipending", "jpends", "ppending", "prended", "prend", "pends", "preending", "opends", "Pension", "npushing", "npend", "psended", "Pressed", "penny", "tpender", "pend", "psends", "jpending", "Pender", " pend", "spossible", "preended", "prenny", "tpended", "tpends", "pressed", "psending", "preends", "Pend", "Pends", "paged", "prending", "npinning", "ipended", "opused", "pushing", "preossible", "Pused", " pinning", " pused", "Possible", "jpended", "jpossible", "tpending", "opender", "jpender", "spenny", "prossible", "spaged", " pension", "psension", "praged", "npused", "pension", "npended", "Penny", "ipender", "spended", "opossible", "ppended", "Pushing", "spushing", "Paged", "opended", "psossible", "spending", " pressed", "pused", "Pinning", "ppushing", "Pended", " pended", "Pending", "opending", "ppend", "ipends", "jpend", "npending", "pended", " pushing", "spend", "pinning", "psressed", "pender"], "line": ["range", "string", "comment", "file", "ine", "mode", "pair", "lay", "lane", "inline", "base", "phrase", "cell", "channel", "l", "text", "lin", "lines", "buffer", "lock", "user", "column", "liner", "block", "path", "email", "point", "frame", "eline", "chain", "Line", "out", "ln", "code", "page", "link", "online", "limit", "LINE", "le", "day", " Line", "lo", "label", "log", "ide"], "t": ["to", "y", "let", "w", "mult", "tr", "f", "typ", "n", "l", "total", "mat", "token", "con", "e", "set", "table", "time", "ter", "mut", "counter", "top", "out", "cut", "ct", "ket", "tc", "i", "td"], "values": ["value", "times", "blocks", "actions", "plays", "Values", "ms", "players", "series", "icks", "bes", "days", "changes", "details", "ings", " Values", "items", "lines", "videos", "settings", "makes", "phones", "places", "forms", "ices", "lists", "groups", "flows", "states", "ses", "words", "results", "vi", "vs", "weights", "ums", "dates", "ports", "qs", "iques", "terms", "measures", "frames", "ples", "objects", "tests", "years", "ires", "vals", "als", "ays", "pins", "codes", "seconds", "maps", "points"], "m": ["range", "s", "sm", "ms", "size", "y", "w", "f", "mol", "n", "cell", "M", "l", "mat", "z", "rm", "tm", "mc", "e", "re", "mem", "b", "mid", "mod", "j", "mi", "v", "count", "md", "num", "mon", "mb", "cm", "p", "d", "rows", "mate", "i"], "cells": ["cs", "ones", "blocks", "ms", "faces", "size", "mins", "gets", "cats", "types", "n", "cell", "cons", "ells", "runs", "lines", "items", "keys", "classes", "hands", "ns", "oms", "shots", "tones", "resources", "files", "flows", "odes", "mi", "parts", "outs", "bs", "res", "ods", "frames", "num", "locks", "cm", "rows", "offs", "points"], "possible": ["plossible", "plossibly", "spended", "pvalid", " paired", "spossibility", "repvalid", "spvalid", "npaired", "Possibility", "repuppet", "possibility", "npossibility", "pused", "pluppet", " possibility", " pended", "possibly", "npused", "repossibility", "Pused", "spossible", "reposed", " posed", "paired", "npossible", "posed", "plosed", " pused", "pended", " pvalid", "repended", "puppet", "Paired", "Possible", "repossibly", " possibly", " puppet", "repossible"]}}
{"code": "\\n  \\n  def read_case(f):\\n  \treturn map(float, f.readline().split())\\n  \\n  \\n  def solve(C, F, X, rate=2.0):\\n  \taccum = 0\\n  \twhile 1:\\n  \t\tgoal1 = X / rate\\n  \t\\n  \t\tfarm = C / rate\\n  \t\tgoal2 = farm + (X / (rate + F))\\n  \\n  \t\tif goal1 <= goal2:\\n  \t\t\treturn accum + goal1\\n  \t\telse:\\n  \t\t\taccum += farm\\n  \t\t\trate += F\\n  \\n  \t\t\t\\n  def trunc(x, p=7):\\n  \tm = 10 ** p\\n  \treturn round(x * m) / m\\n  \\n  \\n  def main():\\n  \tfn = sys.argv[1]\\n  \twith open(fn, encoding='utf-8') as f:\\n  \t\tncases = int(f.readline())\\n  \t\tfor case in range(1, ncases + 1):\\n  \t\t\tC, F, X = read_case(f)\\n  \t\t\tsolution = solve(C, F, X)\\n  \t\t\tprint('Case #{}: {}'.format(case, trunc(solution)))\\n  \\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "target": "64", "substitutes": {"f": ["af", "file", "cf", "input", "w", "y", "t", "g", "fac", "l", "sf", "ft", "c", "fs", "bf", "full", "fb", "fe", "e", "fl", "r", "q", "tf", "b", "fc", "fo", "fa", "xf", "uf", "alf", "fi", "frame", "v", "fw", "out", "ln", "conv", "fd", "fr", "d", "fp", "h", "fm", "i", "lf", "form", "be"], "C": ["V", "AC", "CS", "G", "CI", "P", "W", "IC", "CNN", "CC", "CO", "Y", "CG", "N", "M", "O", "MC", "B", "CM", "c", "D", "CF", "CB", "Cs", "Ch", "H", "LC", "JC", "CT", "CU", "T", "DC", "A", "Cl", "CD", "I", "R", "E", "CP", "EC", "CA", "S", "Cons", "U", "L", "Config", "CR", "Cat", "VC", "TC", "Co"], "F": ["V", "G", "W", "P", "FU", "FT", "J", "FW", "GF", "Fred", "FR", "FS", "FER", "AF", "Y", "Feed", "N", "M", "FI", "B", "RF", "Foreign", "D", "CF", "Factory", "FL", "EF", "FD", "IF", "Farm", "H", "Fi", "K", "DF", "T", "A", "UF", "I", "R", "E", "S", "FG", "L", "Rate", "FP", "FN", "Q", "SF", "Fin", "Z", "PF", "FF", "Family", "FA", "If", "FE"], "X": ["V", "Tx", "P", "XXX", "ML", "Time", "J", "TX", "FX", "XY", "Y", "N", "M", "EX", "D", "CF", "XL", "H", "CE", "IX", "XX", "T", "A", "DX", "I", "R", "E", "S", "U", "L", "IR", "UX", "XP", "Q", "XT", "OX", "MX", "Z", "FF", "Ex", "FE"], "rate": ["fps", "power", "rates", "seed", "ate", "rice", "core", "size", "frequency", "pe", "prime", "date", "fee", "base", "capacity", "rat", "test", "c", " Rate", "fine", "root", "rank", "re", "fork", "r", "state", "time", "rule", "path", "term", "point", "R", "fact", "cycle", "percent", "currency", "age", "force", "Rate", "race", "code", "error", "speed", "family", "feed", "scale", "type", "mate", "price", "rage"], "accum": ["occuc", "occum", "agguc", "ACCumption", "accumb", "accam", "Accumption", "occam", "ACCums", " accam", " accumb", "acom", "ACCom", "aggum", "accuc", "acum", " accom", "occumption", "acums", " accums", "Accum", "Accumb", "ACCum", "accumption", "acumption", "accom", "aggam", " accuc", "accums", " accumption", "occums", "Accums", "aggums", "occumb"], "goal1": ["jump0", " goal0", "goalOne", "teamOne", "team0", "goal0", "Goal2", "goal01", "Goal01", "GoalOne", "jumpone", " goal01", "jump1", "Goalone", " goalone", "Goal1", "team01", " goalOne", "team2", "team1", "Goal0", "jump2", "goalone"], "farm": ["fed", "result", "cp", "conn", "goal", "np", "cf", "front", "chart", "pair", "pac", "framework", "plant", "spring", "fac", "test", "hunt", "market", "con", "util", "db", "store", "root", "aff", "fork", "Farm", "r", "bank", "lead", "policy", "kill", "fen", "perm", "profit", "forge", "field", "cpu", "percent", " Farm", "force", "race", "biased", "speed", "wage", "family", "feed", "scale", "row", "fat", "fp", "transform", "stop", "setup", "job"], "goal2": ["go2", "goal3", " goal0", " goal3", "goal4", "team0", "goal0", "goal02", "Goal2", "Goal02", "go02", " goal4", "Goal4", "Goal1", "go3", "team2", "team1", "Goal0", " goal02", "team4", "go1", "Goal3"], "x": ["mx", "cox", "ax", "y", "xs", "xt", "xe", "at", "xml", "xi", "xp", "n", "l", "xa", "fx", "c", "z", "xy", "r", "time", "px", "xf", "xx", "dx", "wx", "v", "ox", "ex", "tx", "item", "xc", "rx"], "p": ["power", "ping", "P", "cp", "pb", "per", "np", "pe", "w", "pair", "t", "pi", "g", "n", "l", "c", "tp", "k", "r", "q", "b", "ps", "perm", "lp", "v", "press", "pn", "pc", "pa", "d", "pp", "h", "ap", "i"], "m": ["s", "mx", "margin", "P", "month", "mk", "ms", "t", "g", "n", "mn", "M", "l", "mos", "c", "tm", "mt", "mc", "k", "mm", "r", "mp", "q", "mu", "b", "pm", "perm", "mi", "mut", "mr", "v", "dm", "mean", "gm", "cm", "d", "ma", "fm", "i"], "fn": ["nm", "fps", "kl", "file", "np", "cf", "dn", "n", "mn", "bf", "txt", "rn", "fs", "fin", "fl", "tf", "fc", "format", "path", "obj", "fun", "sn", "ff", "pn", "filename", "syn", "FN", "ln", "conv", "fd", "fr", "cn", "fp", "fm", "lf", "nc"], "ncases": ["gnats", "uncodes", "nccases", "uncats", "mnodes", "uncases", "nsase", "gnases", "nsaves", "cnaces", "ncaces", "mncases", "cnase", "nase", "gncases", "cnaves", "cnases", "mnases", "ncaves", "naces", "nsases", "naves", "mnats", "nases", "unccases", "ncodes", "ncats", "ncase", "nsaces", "gnodes"], "case": ["match", "ate", " CASE", "to", "size", "catch", "zip", "pair", "cases", "li", "condition", "step", "test", "c", "nce", "board", "client", "block", "rule", "number", "space", "ce", "se", "line", "cycle", "ASE", "chain", "count", "ase", "cor", "age", "bug", "one", "use", "race", "ice", "cas", "row", "mate", "ace", "day", "name", "instance", "Case"], "solution": ["sololution", "ssolver", "solve", "ssolved", "ssolutions", "solved", "solver", "Solved", "Solutions", "Solver", "solutions", "sololver", "sololved", "resolve", "Solve", "ssolve", "Solution", "resolver", "resolutions", "resolution", "ssolution", "sololve"]}}
{"code": "\\n  \\n  FREE = '.'\\n  BOMB = '*'\\n  CLICK = 'c'\\n  \\n  \\n  class Board:\\n  \\n  \tdef __init__(self, R, C, M):\\n  \t\tself.initial_M = M\\n  \t\tself.R = R\\n  \t\tself.C = C\\n  \t\tself.M = M\\n  \t\tself.matrix = [[FREE for c in range(C)] for r in range(R)]\\n  \t\tself.endx = len(self.matrix[0])\\n  \t\tself.endy = len(self.matrix)  # 0 < R * C\\n  \t\tself.startx = 0\\n  \t\tself.starty = 0\\n  \\n  \tdef fill_row(self, row):\\n  \t\tfor c in self.range_active_cols:\\n  \t\t\tself.matrix[row][c] = BOMB\\n  \t\tself.starty += 1\\n  \t\tself.M -= self.active_cols\\n  \\n  \tdef fill_col(self, col):\\n  \t\tfor r in self.range_active_rows:\\n  \t\t\tself.matrix[r][col] = BOMB\\n  \t\tself.startx += 1\\n  \t\tself.M -= self.active_rows\\n  \\n  \tdef pprint(self):\\n  \t\tfor row in self.matrix:\\n  \t\t\tfor cell in row:\\n  \t\t\t\tprint(cell, end='')\\n  \t\t\tprint()\\n  \\n  \t@property\\n  \tdef active_rows(self):\\n  \t\treturn self.endy - self.starty\\n  \\n  \t@property\\n  \tdef active_cols(self):\\n  \t\treturn self.endx - self.startx\\n  \\n  \tdef optimize(self):\\n  \t\twhile 1:\\n  \t\t\tif (self.active_cols <= self.active_rows\\n  \t\t\t\t\tand self.active_cols <= self.M):\\n  \t\t\t\tself.fill_row(self.starty)\\n  \t\t\telif (self.active_rows < self.active_cols\\n  \t\t\t\t\tand self.active_rows <= self.M):\\n  \t\t\t\tself.fill_col(self.startx)\\n  \t\t\telse:\\n  \t\t\t\tbreak\\n  \\n  \t@property\\n  \tdef range_active_cols(self):\\n  \t\treturn range(self.startx, self.endx)\\n  \\n  \t@property\\n  \tdef range_active_rows(self):\\n  \t\treturn range(self.starty, self.endy)\\n  \\n  \tdef is_free(self, row, col):\\n  \t\treturn self.matrix[row][col] == FREE\\n  \\n  \tdef place_bomb(self):\\n  \t\tfor row in self.range_active_rows:\\n  \t\t\tfor col in self.range_active_cols:\\n  \t\t\t\tif (self.is_free(row, col) \\n  \t\t\t\t\t\tand row + 2 < self.R\\n  \t\t\t\t\t\tand col + 2 < self.C):\\n  \t\t\t\t\tself.matrix[row][col] = BOMB\\n  \t\t\t\t\tself.M -= 1 \\n  \t\t\t\t\treturn True\\n  \t\tfor col in self.range_active_cols:\\n  \t\t\tfor row in self.range_active_rows:\\n  \t\t\t\tif (self.is_free(row, col)\\n  \t\t\t\t\t\tand row + 2 < self.R\\n  \t\t\t\t\t\tand col + 2 < self.C):\\n  \t\t\t\t\tself.matrix[row][col] = BOMB\\n  \t\t\t\t\tself.M -= 1\\n  \t\t\t\t\treturn True\\n  \t\treturn False\\n  \\n  \tdef mark_click(self):\\n  \t\tself.matrix[-1][-1] = 'c'\\n  \\n  \tdef win_condition(self):\\n  \t\tclick_row = len(self.matrix) - 1\\n  \t\tclick_col = len(self.matrix[0]) - 1\\n  \t\tif (click_col - 1 >= 0\\n  \t\t\t\tand not self.is_free(click_row, click_col - 1)):\\n  \t\t\treturn False\\n  \\n  \t\tif (click_row - 1 >= 0\\n  \t\t\t\tand not self.is_free(click_row - 1, click_col)):\\n  \t\t\treturn False\\n  \\n  \t\tif (click_row -1 >= 0\\n  \t\t\t\tand click_col -1 >= 0\\n  \t\t\t\tand not self.is_free(click_row - 1, click_col - 1)):\\n  \t\t\treturn False\\n  \t\t\\n  \t\treturn True\\n  \\n  \tdef win_cond2(self):\\n  \t\tif self.initial_M + 1 == self.C * self.R:\\n  \t\t\treturn True\\n  \t\treturn False\\n  \\n  \tdef solve(self):\\n  \t\tself.optimize()\\n  \t\twhile self.M > 0 and self.place_bomb():\\n  \t\t\tpass\\n  \t\tif self.M == 0 and (self.win_condition() or self.win_cond2()):\\n  \t\t\tself.mark_click()\\n  \t\t\tself.pprint()\\n  \t\telse:\\n  \t\t\tprint('Impossible')\\n  \\n  \\n  def read_case(f):\\n  \treturn map(int, f.readline().split())\\n  \\n  \\n  def main():\\n  \tfn = sys.argv[1]\\n  \twith open(fn, encoding='utf-8') as f:\\n  \t\tncases = int(f.readline())\\n  \t\tfor case in range(1, ncases + 1):\\n  \t\t\tR, C, M = read_case(f)\\n  \t\t\tprint('Case #{}:'.format(case))\\n  \t\t\tb = Board(R, C, M)\\n  \t\t\tb.solve()\\n  \\n  \\n  def main1():\\n  \tb = Board(2, 1, 1)\\n  \tb.solve()\\n  \\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "target": "64", "substitutes": {"FREE": ["NULL", "CRE", "free", "RE", "W", "CHAR", "FW", "NAME", "REM", "FR", "XY", "KEY", "WER", "Y", "EW", "B", "ERE", "ERROR", "D", "CB", "KER", "CLE", "CE", "T", "NEW", "A", "RET", "UN", "BO", "BOX", "E", "OK", "WT", "LE", "F", "YOU", "RES", "Q", "Free", "VALUE", "DE", "WIN", "NO", "DEF", "LEASE", "FE"], "BOMB": ["BOOME", "BOOBO", "BOMBO", "BUMPBO", "BOME", "BOOOB", "BOOMBO", "BOOOBO", "BOOMBC", "BUMPB", "BOOOE", "BOOBC", "BOOOBC", "BOOE", "BUMPBC", "BOOB", "BUMBC", "BUMBO", "BOOMB", "BOMBC", "BUMPE", "BUME", "BUMB"], "CLICK": ["BLINK", "CHACK", " CLINK", " CLAPE", " CLACK", "CLAPE", "BLICK", "CLINK", "BLACK", "CHICK", "CHINK", "CHAPE", "BLAPE", "CLACK"], "self": ["s", "conf", "complete", "conn", "spec", "req", "comp", "attr", "cl", "full", "tmp", "proc", "resp", "ls", "shape", "path", "sw", "diff", "output", "rss", "wrapper", "debug", "api", "me", "console", "instance", "just", "log", "also", "builder", "cp", "first", "sche", "sql", "details", "network", "xml", "views", "agg", "txt", "sub", "partial", "client", "clean", "se", "results", "dict", "close", "responsible", "print", "deep", "sb", "replace", "parent", "h", "form", "asm", "short", "help", "new", "ren", "drive", "n", "lex", "eval", "this", "load", "review", "context", "add", "nt", "raw", "Big", "you", "next", "final", "my", "expr", "Writer", "python", "sys", "compl", "object", "Th", "subject", "public", "pair", "view", "dev", "Self", "weak", "local", "user", "system", "app", "config", "serial", "cho", "obj", "sect", "rel", "pkg", "cache", "info", "ws", "ln", "cmp", "so", "error", "all"], "R": ["V", "RS", "G", "RE", "P", "W", "J", "Range", "Y", "N", "B", "MR", "RF", "Rs", "D", "RL", "RA", "H", "K", "SR", "RM", "T", "A", "RT", "I", "RO", "X", "RI", "S", "RR", "DR", "L", "U", "F", "Res", "TR", "Q", "RP"], "C": ["V", "CS", "G", "W", "P", "CV", "CHAR", "CNN", "ERC", "CC", "CO", "Y", "N", "CL", "O", "MC", "B", "CM", "D", "CF", "Cs", "Ch", "H", "K", "CE", "JC", "CT", "CU", "T", "A", "I", "E", "CP", "EC", "CA", "S", "BC", "Cons", "L", "F", "U", "CR", "CON", "Q", "CH", "Z", "WC", "Con", "Co"], "M": ["V", "Mon", "MED", "G", "MAN", "W", "P", "MT", "J", "Mem", "MH", "Y", "m", "N", "O", "MC", "B", "CM", "Med", "JM", "D", "MOD", "H", "MU", "MI", "K", "MO", "LM", "RM", "T", "Mass", "A", "I", "X", "S", "L", "F", "U", "Q", "TM", "MS", "MAC", "MM", "Z", "MA"], "initial_M": ["initial___R", "Initial_R", "initial_R", "Initial_T", "initial___m", "initial___M", "Initial_m", "initial_T", "initial_m", "initial___T", "Initial_M"], "matrix": ["umatrix", "matchrix", "atrices", "atMatrix", "matchMatrix", "mction", "matchrices", "mtMatrix", "atvector", "catMatrix", "mvector", "MATrices", "mtrices", "mMatrix", "matction", "MATrix", "mtrix", "mrix", "umatction", "umatrices", "mrices", "catrices", "MATction", "catrix", "matrices", "matvector", "matMatrix", "atrix", "mtvector"], "c": ["cs", "cp", "cont", "ch", "cf", "cv", "f", "n", "cl", "z", "ec", "con", "mc", "k", "q", "lc", "b", "cur", "rc", "cu", "cb", "col", "cm", "cd", "p", "xc", "nc"], "r": ["rr", "rt", "cr", "dr", "w", "m", "ru", "rd", "rn", "rm", "sr", "re", "ir", "q", "b", "ro", "ra", "ar", "rc", "j", "mr", "er", "p", "d", "rg", "rb", "rx"], "endx": ["endedx", " endcol", "endcol", "startx", "startcol", "endedcol", "endedz", "endedy", " endz", "endz", "starty", "startz"], "endy": ["startny", "endedx", "endY", "endsny", "endny", "startx", "startY", "endedY", "endedy", "endsY", "starty", "endsy", "endsx", "endedny"]}}
{"code": "\\n  \\n  def compute(C, F, X):\\n      k = int(math.floor(X / C - 2.0 / F))\\n      if k <= 0:\\n          return X / 2\\n      total = 0.0\\n      for i in xrange(k):\\n          total += 1.0 / (2.0 + i * F)\\n      return C * total + X / (2.0 + k * F)\\n  \\n  \\n  def parse():\\n      C, F, X = map(float, sys.stdin.readline().strip().split())\\n      return C, F, X\\n  \\n  \\n  if __name__ == \"__main__\":\\n      sys.setrecursionlimit(100000)\\n      T = int(sys.stdin.readline().strip())\\n      for i in xrange(T):\\n          data = parse()\\n          result = compute(*data)\\n          print \"Case #%d: %0.7f\" % (i + 1, result)\\n", "target": "65", "substitutes": {"C": ["V", "CS", "G", "CI", "P", "W", "CV", "J", "CNN", "CC", "CO", "Y", "CG", "N", "M", "O", "B", "CM", "c", "Car", "D", "CF", "YC", "Cs", "Ch", "H", "K", "CE", "JC", "CT", "CU", "A", "Cal", "I", "R", "E", "CP", "Cache", "CA", "S", "L", "U", "CR", "CON", "VC", "CN", "Z", "GC", "Co", "Craig"], "F": ["V", "G", "W", "P", "FT", "J", "GF", "Fred", "FR", "FS", "Fs", "Y", "f", "FER", "N", "M", "FC", "O", "MF", "FI", "B", "RF", "D", "CF", "EF", "FD", "IF", "H", "K", "DF", "A", "UF", "I", "R", "Fe", "E", "FO", "S", "FG", "WF", "L", "U", "FM", "Q", "SF", "Fin", "Z", "PF", "FF", "FE"], "X": ["V", "G", "W", "P", "ML", "J", "Time", "TX", "XY", "Y", "N", "M", "Right", "Xi", "IO", "Key", "D", "CF", "XL", "H", "K", "CT", "IX", "XX", "Array", "Data", "A", "DX", "I", "R", "E", "S", "L", "x", "U", "Location", "UX", "XP", "Q", "Integer", "XT", "OX", "MAX", "Z", "ZX", "XXX", "FE"], "k": ["ki", "s", "kl", "mk", "ka", "y", "w", "t", "f", "m", "tk", "n", "kj", "c", "kw", "z", "kok", "ks", "kh", "q", "K", "r", "kn", "kr", "km", "o", "yk", "ck", "j", "wk", "ek", "sk", "v", "ku", "kid", "x", "ak", "ik", "unk", "ikk", "kan", "ke", "p", "kk", "ko"], "total": ["valid", "value", "shared", "free", "basic", "complete", "new", "t", "equal", "f", "null", "Total", "current", "base", "n", "done", "index", "c", "eta", "required", "general", "full", "this", "meta", "local", "tmp", "set", "table", "initial", " Total", "zero", "normal", "no", "otal", "info", "count", "percent", "net", "pretty", "human", "you", "max", "mean", "sum", "type", "all", "final", "parent", "physical", "bar"], "i": ["ki", "ti", "s", "int", "ini", "y", "ic", "u", "ind", "pi", "t", "li", "f", "m", "xi", "n", "l", "ix", "index", "c", "z", "bi", "e", "zi", "hi", "id", "ij", "r", "ai", "b", "phi", "im", "I", "si", "j", "mi", "v", "x", "di", "gi", "ik", "yi", "ii", "ip", "me", "ci", "p", "d", "a", "oi"], "T": ["V", "Test", "TB", "P", "Time", "J", "TN", "t", "Y", "N", "M", "Temperature", "O", "B", "TA", "D", "UTC", "TT", "K", "I", "R", "E", "TS", "S", "NT", "L", "TH", "It", "Q", "TM", "Z", "TI", "TC"], "data": ["valid", "sample", "pie", "json", "times", "ds", "ata", "series", "size", "t", "steps", "n", "text", "window", "items", "lines", "partial", "ns", "rew", "bytes", "table", "mu", "group", "batch", "extra", "Data", "results", "rel", "raw", "cache", "info", "chain", "images", "image", "DATA", "row", "share", "next", "d", "aw", "reports", "values", "dat"], "result": ["duration", "int", "fully", "Result", "successful", "performance", "value", "gain", "different", "date", "successfully", "f", "current", "rate", "correct", "test", "float", "rat", "integer", "status", "function", "tmp", "ful", "r", "su", "ne", "results", "diff", "ret", "report", "res", "output", "percent", "the", "success", "mate", "average", "final", "summary", "score"]}}
{"code": "\\n  \\n  DX = (-1, -1, -1, 0, 1, 1, 1, 0)\\n  DY = (-1, 0, 1, 1, 1, 0, -1, -1)\\n  \\n  \\n  def compute(R, C, M):\\n      if M == 0:\\n          return empty(R, C)\\n      free = R * C - M\\n      if free == 1:\\n          return single_free(R, C)\\n      if R == 1:\\n          return single_row(C, M)\\n      if C == 1:\\n          return single_column(R, M)\\n      if R == 2:\\n          return two_rows(C, M)\\n      if C == 2:\\n          return two_columns(R, M)\\n      if free in (2,3,5,7):\\n          return \"\\nImpossible\"\\n      return at_least_three(R, C, M)\\n  \\n  \\n  def make_board(R, C, default='.'):\\n      return [[default for j in xrange(C)] for i in xrange(R)]\\n  \\n  \\n  def to_string(board):\\n      s = \"\"\\n      for i in xrange(len(board)):\\n          s += '\\n' + ''.join(board[i])\\n      return s\\n  \\n          \\n  def empty(R, C):\\n      board = make_board(R, C)\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def single_free(R, C):\\n      board = make_board(R, C, default='*')\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def single_row(C, M):\\n      board = make_board(1, C)\\n      board[0][0] = 'c'\\n      for i in xrange(M):\\n          board[0][C - 1 - i] = '*'\\n      return to_string(board)\\n  \\n  \\n  def single_column(R, M):\\n      board = make_board(R, 1)\\n      board[0][0] = 'c'\\n      for i in xrange(M):\\n          board[R - 1 - i][0] = '*'\\n      return to_string(board)\\n  \\n  \\n  def two_rows(C, M):\\n      if M % 2 != 0:\\n          return \"\\nImpossible\"\\n      if 2 * C - M < 4:\\n          return \"\\nImpossible\"\\n      board = make_board(2, C)\\n      for i in xrange(M / 2):\\n          board[0][C - 1 - i] = '*'\\n          board[1][C - 1 - i] = '*'\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def two_columns(R, M):\\n      if M % 2 != 0:\\n          return \"\\nImpossible\"\\n      if 2 * R - M < 4:\\n          return \"\\nImpossible\"\\n      board = make_board(R, 2)\\n      for i in xrange(M / 2):\\n          board[R - 1 - i][0] = '*'\\n          board[R - 1 - i][1] = '*'\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def finalize(R, C, M, board):\\n      mines = 0\\n      for i in xrange(R):\\n          for j in xrange(C):\\n              if board[i][j] == '0':\\n                  continue\\n              empty = False\\n              for d in xrange(8):\\n                  if i + DX[d] < 0 or i + DX[d] >= R or j + DY[d] < 0 or j + DY[d] >= C:\\n                      continue\\n                  if board[i + DX[d]][j + DY[d]] == '0':\\n                      empty = True\\n                      break\\n              if empty:\\n                  board[i][j] = '.'\\n              else:\\n                  board[i][j] = '*'\\n                  mines += 1\\n      for i in xrange(R):\\n          for j in xrange(C):\\n              if board[i][j] == '0':\\n                  board[i][j] = '.'\\n      board[0][0] = 'c'\\n      if mines != M:\\n          sys.stderr.write(\"mines:%s expected:%s\\n\" % (mines, M))\\n      return to_string(board)\\n  \\n  \\n  def at_least_three(R, C, M):\\n      board = make_board(R, C)\\n      board[0][0] = '0'\\n      free = R * C - M\\n      count = 4\\n      if count == free:\\n          return finalize(R, C, M, board)\\n      board[0][1] = '0'\\n      count += 2\\n      if count == free:\\n          return finalize(R, C, M, board)\\n      board[1][0] = '0'\\n      count += 2\\n      if count == free:\\n          return finalize(R, C, M, board)\\n      for j in xrange(2, C - 1):\\n          if count + 2 > free:\\n              break\\n          board[0][j] = '0'\\n          count += 2\\n      for i in xrange(2, R - 1):\\n          if count + 2 > free:\\n              break\\n          board[i][0] = '0'\\n          count += 2\\n      for i in xrange(1, R - 1):\\n          for j in xrange(1, C - 1):\\n              if count == free:\\n                  return finalize(R, C, M, board)\\n              board[i][j] = '0'\\n              count += 1\\n      sys.stderr.write(\"empty board?\\n\")\\n      return finalize(board)\\n  \\n  \\n  def parse():\\n      R, C, M = map(int, sys.stdin.readline().strip().split())\\n      return R, C, M\\n  \\n  \\n  if __name__ == \"__main__\":\\n      sys.setrecursionlimit(100000)\\n      T = int(sys.stdin.readline().strip())\\n      for i in xrange(T):\\n          sys.stderr.write(\"case:%s\\n\" % (i + 1))\\n          data = parse()\\n          result = compute(*data)\\n          print \"Case #%d: %s\" % (i + 1, result)\\n", "target": "65", "substitutes": {"DX": ["TX", "YD", "FX", "XY", "YE", "DL", "EX", "Xi", "DS", "DP", "WD", "DT", "WH", "RH", "IX", "XX", "DC", "CD", "DW", "X", "dx", "DR", "DI", "UX", "OX", "DD", "DH", "DK", "TD"], "DY": ["DEYY", "DPYD", "DYD", "DYY", "DEX", " DYY", "DPYY", "DEY", " DYD", "DPX", "DEYD", "DPY"], "R": ["V", "RS", "G", "Root", "P", "RE", "ER", "J", "W", "REM", "OR", "Range", "Y", "Re", "RG", "RON", "N", "Right", "O", "B", "MR", "GR", "Rs", "D", "RL", "RA", "r", "BR", "H", "RC", "SR", "RM", "Row", "A", "Reader", "RT", "ROM", "I", "RO", "X", "JR", "E", "RI", "S", "RR", "DR", "NR", "RW", "L", "U", "F", "CR", "Rot", "IR", "Res", "TR", "KR", "Cor", "AR", "HR", "Br", "Random"], "C": ["V", "CS", "G", "CV", "W", "RE", "CO", "Y", "CAR", "CG", "c", "CF", "K", "JC", "CT", "E", "CA", "U", "CR", "CN", "RS", "CI", "CC", "N", "MC", "B", "CB", "Ch", "r", "BR", "CE", "CU", "I", "S", "F", "WC", "SC", "COM", "CNN", "Cr", "CL", "D", "YC", "Cs", "H", "RC", "Cl", "CD", "CP", "Config", "VC", "One", "AC", "P", "IC", "J", "O", "HC", "CM", "CCC", "DC", "A", "X", "EC", "BC", "L", "CON", "CW", "Con", "Co"], "M": ["V", "G", "W", "RE", "MT", "REM", "Y", "MN", "_", "K", "IM", "LM", "b", "E", "U", "Z", "a", "AM", "Mon", "N", "com", "MC", "B", "none", "MI", "Memory", "left", "I", "S", "F", "the", "MAN", "new", "m", "n", "D", "H", "RM", "Mi", "Q", "MS", "VM", "DM", "P", "J", "O", "CM", "MR", "A", "X", "L", "AN", "TM", "MM", "NM", "all", "void"], "free": ["valid", "de", "are", "clear", "ms", "size", "new", "sp", "equal", "f", "m", "fee", "blank", "occupied", "done", "only", "total", "mask", "c", "FREE", "none", "over", "full", "con", "fine", "non", "set", "re", "MI", "co", "mem", "zero", "no", "left", "space", "close", "min", "res", "used", "good", "F", "given", "out", "nil", "Free", "error", "available", "open", "mate", "MA", "void", "floor", "Only"], "default": [" Default", "release", "choice", "value", "de", "Default", "help", "aults", "new", "optional", "f", "g", "null", "current", "m", "primary", "key", "switch", "c", "password", "none", "option", "root", "grid", "config", "FAULT", "initial", "r", "b", "normal", "left", "menu", "self", "description", "field", "slot", "fixed", "force", "right", "weight", "error", "dt", "delay", "DE", "p", "df", "name", "label"], "j": ["ki", "ja", "J", "iaz", "y", "aj", "bi", "k", "zi", "ij", "jc", "q", "jac", "r", "ai", "co", "b", "ri", "pr", "rel", "fi", "di", "fr", "uj", "cm", "ji", "ion", "ei"], "i": ["ki", "ti", "ish", "iy", "ini", "y", "u", "ic", "ind", "pi", "t", "m", "li", "f", "ie", "xi", "it", "n", "l", "index", "c", "il", "z", "bi", "e", "k", "irin", "zi", "id", "iu", "ij", "r", "ir", "ai", "phi", "b", "im", "o", "ri", "I", "si", "mi", "fi", "v", "ati", "x", "ia", "ib", "ik", "gi", "di", "yi", "ii", "ip", "ig", "\u0438", "ci", "p", "iti", "h", "oi"], "board": ["disk", "stri", "butt", "poll", "card", "lib", "case", "hole", "full", "black", "table", "bird", "b", "fc", "ward", "cross", "bit", "bug", "foot", "bar", "builder", "book", "loop", "core", "bench", "roller", "design", "database", "pool", "game", "ac", "buffer", "bus", "client", "room", "stick", "clean", "oard", "hub", "menu", "stream", "style", "join", "out", "list", "command", "array", "string", "won", "form", "bot", "controller", "pb", "ard", "bo", "san", "stone", "member", "body", "flo", "bank", "ro", "video", "back", "library", "league", "part", "box", "layout", "data", "Board", "front", "public", "lay", "view", "pad", "channel", "test", "way", "runner", "lock", "local", "door", "rank", "system", "sequence", "control", "bd", "draw", "block", "inner", "bin", "land", "piece", "ui", "line", "chain", "player", "boarding", "ack", "boot", "node", "deck", "row", "display"], "s": ["cs", "os", "sv", "sys", "ds", "stats", "w", "comments", "t", "f", "g", "m", "changes", "n", "c", "its", "js", "ends", "e", "ns", "rs", "r", "ss", "ls", "gs", "b", "ps", "ats", "o", "es", "sw", "ments", "bs", "S", "ts", "bits", "str", "ws", "sb", "conv", "p", "a", "ins", "h", "sets"], "empty": ["valid", "clear", "complete", "quiet", "size", "missing", "address", "optional", "equal", "null", "inline", "blank", "occupied", "none", "full", "flush", "util", " Empty", "Empty", "exclusive", "delete", "example", "initial", "table", "filled", "make", "zero", "clean", "export", "une", "unknown", "negative", "simple", "fill", "nil", "open", "mate", "execute", "void"]}}
